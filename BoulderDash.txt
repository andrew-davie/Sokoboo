------- FILE ./notBoulderDash.asm LEVEL 1 PASS 3
      1  8000 ????
      2  8000 ????						;------------------------------------------------------------------------------
      3  8000 ????						; not-Boulderdash(R)! Copyright (C)2003-2011 Andrew Davie and Thomas Jentzsch.
      4  8000 ????						; This is an engine for background animation games. The engine uses bankswitch scheme
      5  8000 ????						; Tigervision Extended (3E). Display technology developed late 2004, Copyright (C)2005-2011
      6  8000 ????						; Andrew Davie, Thomas Jentzsch. Thomas on-board mid-MAY 2005.
      7  8000 ????						; Abandoned ~Febuary 2008, re-started December 2008. Abandoned!
      8  8000 ????						; Re-started for demo release June 2011.
      9  8000 ????
     10  8000 ????						; Some portions of this code may be freely used for private, educational and research
     11  8000 ????						; purposes, excluding Boulder Dash(R)-specific logic and routines, which may not
     12  8000 ????						; be distributed and which remain Copyright (C) First Star Software 1984-2011.
     13  8000 ????						; If you wish to profit from this code, please ask for permission first.
     14  8000 ????						;------------------------------------------------------------------------------
     15  8000 ????
     16  8000 ????
     17  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     18  8000 ????
     19  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  8000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  8000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  8000 ????						;
     10  8000 ????						; This file defines hardware registers and memory mapping for the
     11  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  8000 ????						; available at at http://www.atari2600.org/dasm
     14  8000 ????						;
     15  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  8000 ????						; with your views.  Please contribute, if you think you can improve this
     19  8000 ????						; file!
     20  8000 ????						;
     21  8000 ????						; Latest Revisions...
     22  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  8000 ????						;			    This will allow conditional code to verify VCS.H being
     25  8000 ????						;			    used for code assembly.
     26  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  8000 ????						;			 mirrored reading/writing differences.	This is more a
     29  8000 ????						;			 readability issue, and binary compatibility with disassembled
     30  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  8000 ????						;			 which was broken by the use of segments in this file, as
     33  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  8000 ????						;						   it is safe to leave it undefined, and the base address will
     38  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  8000 ????						;			  - register definitions are now generated through assignment
     41  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  8000 ????						;			    address architecture.
     43  8000 ????						; 1.0	22/MAR/2003		Initial release
     44  8000 ????
     45  8000 ????
     46  8000 ????						;-------------------------------------------------------------------------------
     47  8000 ????
     48  8000 ????						; TIA_BASE_ADDRESS
     49  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  8000 ????						; Normally 0, the base address should (externally, before including this file)
     51  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  8000 ????						; < $40 as a bankswitch.
     54  8000 ????
     55  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     56  8000 ????			  -TIA_BASE_ADDRESS =	0
     57  8000 ????				      ENDIF
     58  8000 ????
     59  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  8000 ????						; *OR* by declaring the label before including this file, eg:
     62  8000 ????						; TIA_BASE_ADDRESS = $40
     63  8000 ????						;   include "vcs.h"
     64  8000 ????
     65  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  8000 ????						; for the mirrored ROM hardware registers.
     68  8000 ????
     69  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     71  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     74  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  8000 ????				      ENDIF
     80  8000 ????
     81  8000 ????						;-------------------------------------------------------------------------------
     82  8000 ????
     83 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0040
     86 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0040
     88 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U006d
    134 U006d							;-------------------------------------------------------------------------------
    135 U006d
    136 U004e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0040					      ORG	TIA_BASE_READ_ADDRESS
    138 U0040
    139 U0040							;											bit 7	 bit 6
    140 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U004e
    155 U004e							;-------------------------------------------------------------------------------
    156 U004e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE ./notBoulderDash.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  0000 ????
      4  0000 ????	       00 6a	   VERSION_MACRO =	106
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	22/MAR/2003		Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Andrew Davie
     97  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  0000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  0000 ????						; Use as very first section of code on boot (ie: at reset)
    101  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  0000 ????
    103  0000 ????				      MAC	clean_start
    104  0000 ????				      sei
    105  0000 ????				      cld
    106  0000 ????
    107  0000 ????				      ldx	#0
    108  0000 ????				      txa
    109  0000 ????				      tay
    110  0000 ????			   .CLEAR_STACK dex
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  0000 ????
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    151  0000 ????			   .FREE_BYTES SET	0
    152  0000 ????				      MAC	boundary
    153  0000 ????				      REPEAT	256
    154  0000 ????				      IF	<. % {1} = 0
    155  0000 ????				      MEXIT
    156  0000 ????				      ELSE
    157  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    158  0000 ????				      .byte	$00
    159  0000 ????				      ENDIF
    160  0000 ????				      REPEND
    161  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    162  0000 ????				      ENDM
    163  0000 ????
    164  0000 ????
    165  0000 ????						; EOF
------- FILE ./notBoulderDash.asm
     22  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						; segtime optimization (averages):
      2  0000 ????						;   lost time = segtime/2 * 64
      3  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
      4  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
      5  0000 ????						;
      6  0000 ????						; segtime = 2:
      7  0000 ????						;   lost time = 64
      8  0000 ????						;   num-segments = 28
      9  0000 ????						;   overhead = 224!
     10  0000 ????						; segtime = 3:
     11  0000 ????						;   lost time = 96
     12  0000 ????						;   num-segments = 18
     13  0000 ????						;   overhead = 144!
     14  0000 ????						; segtime = 4: 	     <--!!!
     15  0000 ????						;   lost time = 128!
     16  0000 ????						;   num-segments = 28
     17  0000 ????						;   overhead = 112
     18  0000 ????						; segtime = 5:
     19  0000 ????						;   lost time = 160!
     20  0000 ????						;   num-segments = 11
     21  0000 ????						;   overhead = 88
     22  0000 ????						; segtime = 6:
     23  0000 ????						;   lost time = 192!
     24  0000 ????						;   num-segments = 9
     25  0000 ????						;   overhead = 72
     26  0000 ????						; segtime = 7:
     27  0000 ????						;   lost time = 224!
     28  0000 ????						;   num-segments = 8
     29  0000 ????						;   overhead = 64
     30  0000 ????						; segtime = 10:
     31  0000 ????						;   lost time = 320!
     32  0000 ????						;   num-segments = 5
     33  0000 ????						;   overhead = 40
     34  0000 ????						; segtime = 20:
     35  0000 ????						;   lost time = 640!
     36  0000 ????						;   num-segments = 2
     37  0000 ????						;   overhead = 16
     38  0000 ????						; segtime = 40:
     39  0000 ????						;   lost time = 1280!
     40  0000 ????						;   num-segments = 1
     41  0000 ????						;   overhead = 8
     42  0000 ????
     43  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     44  0000 ????						; below wasted time increases rapidly, above only moderately
     45  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     46  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     47  0000 ????						;  so larger segtimes are not that bad then
     48  0000 ????
     49  0000 ????
     50  0000 ????				      MAC	segtime
     51  0000 ????			   {1}	      SET	{2}
     52  0000 ????			   TEST_{1}   =	0
     53  0000 ????				      ENDM
     54  0000 ????
     55  0000 ????				      MAC	xsegtime
     56  0000 ????			   {1}	      SET	{2}-1
     57  0000 ????			   TEST_{1}   =	1
     58  0000 ????				      ENDM
     59  0000 ????
     60  0000 ????						;@TJ -- SIMPLY PUT AN X IN FRONT OF THE LINE(S) YOU WANT TO TEST
     61  0000 ????						; eg: XSEGTIME SEGTIME_BOULDER1,5
     62  0000 ????						; No other action required.  All code enables/disables automatically.
     63  0000 ????
     64  0000 ????						; 2012/02/11 -- experimental reduction in times (but not stress tested)
     65  0000 ????						; due to separation of timeslice overhead to separate check
     66  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_SCD_DIRECT,8	; TODO: 392@12/2/2012
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	8
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_QUICK,9	; TODO: 414@12/2/2012
      1  0000 ????			   SEGTIME_SCD_QUICK SET	9
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_SLOW,12	; TODO: cycles: ~635 @12/2/2012.
      1  0000 ????			   SEGTIME_SCD_SLOW SET	12
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_PF0,5	; TODO: cycle counted ~126 @12/2/2012
      1  0000 ????			   SEGTIME_SCD_PF0 SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_MIN,SEGTIME_SCD_PF0	; * MINIMUM TIME OF THE ABOVE + 1
      1  0000 ????			   SEGTIME_SCD_MIN SET	SEGTIME_SCD_PF0
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_MIN =	0
     72  0000 ????
     73  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
     74  0000 ????			  -	      SEGTIME	SEGTIME_BDF,42	; * 5/8/11 stress tested DHS->DS
     75  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BDF,41	; * 7/8/11
      1  0000 ????			   SEGTIME_BDF SET	41
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
     77  0000 ????				      ENDIF
     78  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BDS,5	; *AD 11/8/11
      1  0000 ????			   SEGTIME_BDS SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME	SEGTIME_DSL,5	; * 9/8/11 unrolled once
      1  0000 ????			   SEGTIME_DSL SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
     81  0000 ????
     82  0000 ????
     83  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SORT_TIME,3	;     157(A)->2.45
      1  0000 ????			   MINIMUM_SORT_TIME SET	3
      2  0000 ????	       00 00	   TEST_MINIMUM_SORT_TIME =	0
     85  0000 ????
     86  0000 ????
     87  0000 ????						;following will lock-up system if used as 'XSEGTIME'.
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIME,4	; processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	4
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
     89  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIMEBLANK,16	;17		 ; * 7/8/11	 993(A)->15.5
      1  0000 ????			   MINIMUM_SEGTIMEBLANK SET	16
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIMEBLANK =	0
     91  0000 ????
     92  0000 ????						; MINIMUM_SEGTIME
     93  0000 ????						; MINIMUM_SEGTIMEBLANK
     94  0000 ????						; SEGTIME_BDF
     95  0000 ????						; SEGTIME_BDS
     96  0000 ????						; SEGTIME_DSL
     97  0000 ????						; SEGTIME_SWITCHOBJECTS
     98  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MINIMUM_TIMESLICE,MINIMUM_SEGTIME+1	; MINIMUM of the TIMESLICE segments listed above
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	MINIMUM_SEGTIME+1
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    100  0000 ????
    101  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    102  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    103  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    104  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    105  0000 ????						; uses ...
    106  0000 ????
    107  0000 ????
    108  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    109  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    110  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    111  0000 ????
    112  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    113  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    114  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,24	;<< using this as XSEGTIME stops player working ...?!
      1  0000 ????			   SEGTIME_MAN SET	24
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
    116  0000 ????						; TJ: I should only prevent processes with an extra check (e.g. get diamond)
    117  0000 ????
    118  0000 ????						; push boulder is slowest (besides get diamond which has an extra timer check)
    119  0000 ????						; if we add another check for it, SEGTIME_MAN reduces by ~5
    120  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BOULDER1,5	; ~182 cycles if falling on man + sort overhead!
      1  0000 ????			   SEGTIME_BOULDER1 SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_BOULDER1 =	0
      0  0000 ????				      SEGTIME	SEGTIME_BOULDER3,8	; SEGTIME_BOULDER4 causes freezes if stressed
      1  0000 ????			   SEGTIME_BOULDER3 SET	8
      2  0000 ????	       00 00	   TEST_SEGTIME_BOULDER3 =	0
      0  0000 ????				      SEGTIME	SEGTIME_BOULDER4,7	;(*) not 100% sure, maybe one more
      1  0000 ????			   SEGTIME_BOULDER4 SET	7
      2  0000 ????	       00 00	   TEST_SEGTIME_BOULDER4 =	0
      0  0000 ????				      SEGTIME	SEGTIME_MAGIC,SEGTIME_BOULDER4 + 2	; tied together (diamond falling through magic wall)
      1  0000 ????			   SEGTIME_MAGIC SET	SEGTIME_BOULDER4 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MAGIC =	0
    125  0000 ????
    126  0000 ????						; the following values have been tested with the STRESS_TIME macro:
    127  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
    128  0000 ????			  -	      SEGTIME	SEGTIME_BIGBANG,34	; TODO* 5/8/11, 1732(B)+218(butterfly)->1940->30.3
    129  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BIGBANG,31	; * 7/8/11
      1  0000 ????			   SEGTIME_BIGBANG SET	31
      2  0000 ????	       00 00	   TEST_SEGTIME_BIGBANG =	0
    131  0000 ????				      ENDIF
      0  0000 ????				      SEGTIME	SEGTIME_EXPLOSION,7	; * 5/8/11
      1  0000 ????			   SEGTIME_EXPLOSION SET	7
      2  0000 ????	       00 00	   TEST_SEGTIME_EXPLOSION =	0
      0  0000 ????				      SEGTIME	SEGTIME_GET_DIAMOND,17	; * 14/8/11, required if UpdateScore loops (e.g. 9990->10000)
      1  0000 ????			   SEGTIME_GET_DIAMOND SET	17
      2  0000 ????	       00 00	   TEST_SEGTIME_GET_DIAMOND =	0
      0  0000 ????				      SEGTIME	SEGTIME_BUTTERFLY,10	; * 7/8/11, 525(B)->8.20
      1  0000 ????			   SEGTIME_BUTTERFLY SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_BUTTERFLY =	0
    135  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_SWITCHOBJECTS,3	; 16/8/11 by calculation. 72 cycles -->  ceil(72/64)+1 --> 3 Object stack switchover
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	3
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
    137  0000 ????
------- FILE ./notBoulderDash.asm
     24  0000 ????
     25  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     26  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     27  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     28  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     29  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     30  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     31  0000 ????
     32  0000 ????	       00 01	   YES	      =	1
     33  0000 ????	       00 00	   NO	      =	0
     34  0000 ????
     35  0000 ????	       00 00	   DEBUG      =	NO
     36  0000 ????
     37  0000 ????	       00 00	   TJ_MODE    =	NO	; some changes which TJ prefers
     38  0000 ????	       00 00	   AD_MODE    =	NO	; some changes which AD prefers
     39  0000 ????
     40  0000 ????			  -	      IF	TJ_MODE && AD_MODE
     41  0000 ????			  -	      ECHO	"ERROR: Both TJ_MODE and AD_MODE set. Can't do both TJ and AD at the same time!"
     42  0000 ????			  -	      ERR
     43  0000 ????				      ENDIF
     44  0000 ????
     45  0000 ????
     46  0000 ????						; Note: you may also need to change the emulator "-format" switch in the Makefile.
     47  0000 ????
     48  0000 ????			   NTSC_MODE  SET	YES
     49  0000 ????
     50  0000 ????			  -	      IF	TJ_MODE
     51  0000 ????			  -NTSC_MODE  SET	NO	; force NTSC or PAL for difficulty switch
     52  0000 ????				      ENDIF
     53  0000 ????			  -	      IF	AD_MODE
     54  0000 ????			  -NTSC_MODE  SET	NO
     55  0000 ????				      ENDIF
     56  0000 ????
     57  0000 ????
     58  0000 ????
     59  0000 ????						;===================================
     60  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     61  0000 ????						;===================================
     62  0000 ????
     63  0000 ????
     64  0000 ????						;===================================
     65  0000 ????			   DEMO_VERSION SET	NO	; force a dual-level playable demo only
     66  0000 ????						;===================================
     67  0000 ????
     68  0000 ????
     69  0000 ????						;-------------------------------------------------------------------------------
     70  0000 ????						; The following should be NO for the final or DEMO version
     71  0000 ????			   TEST_BONUS_COUNTDOWN SET	NO	; causes level A1 to have a special setup for testing the bonus countdown
     72  0000 ????			   F1F2NEXTCAVE SET	NO	; debugging -- F1+F2 will trigger next level. Good to test the progression of level/caves
     73  0000 ????			   CONSTRUCTIONKIT SET	NO	; patch-capable binary for construction kit usage
     74  0000 ????			   SHOWDIAMONDP SET	NO	; debug show diamond on P
     75  0000 ????
     76  0000 ????						;-------------------------------------------------------------------------------
     77  0000 ????						; The following should be YES for the final or DEMO version
     78  0000 ????			   SHOW_COPYRIGHT SET	YES	; must be YES for final release
     79  0000 ????			   EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
     80  0000 ????			   SORT_OBJECTS SET	YES	; Warning: can be slow on complex screens
     81  0000 ????			   SPECIAL_ADD_DECODECAVE SET	YES	; causes boulders and diamonds to be added as falling objects on cave startup
     82  0000 ????			   EASTER_EGG SET	YES	; enable easter egg (instead intermission of INT4)
     83  0000 ????
     84  0000 ????						;-------------------------------------------------------------------------------
     85  0000 ????						; The following are optional YES/NO depending on phase of the moon
     86  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     87  0000 ????			   INITIAL_SCROLL SET	NO	; initially scroll board from Rockford's last position
     88  0000 ????						;-------------------------------------------------------------------------------
     89  0000 ????
     90  0000 ????	       00 01	   NUMPLAYERS =	1	; 1-indexed
     91  0000 ????	       00 05	   NUM_LEVELS =	5
     92  0000 ????			   NUM_LIVES  SET	3	; use -1 for unlimited lives
     93  0000 ????
     94  0000 ????			   DEMO_DELAY SET	1	; number of music loops without joystick input before demo kicks in
     95  0000 ????
     96  0000 ????						;-------------------------------------------------------------------------------
     97  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     98  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     99  0000 ????			  -	      IF	FINAL_VERSION = YES
    100  0000 ????			  -DEMO_VERSION SET	NO	; force a dual-level playable demo only
    101  0000 ????			  -TEST_BONUS_COUNTDOWN SET	NO	; causes level A1 to have a special setup for testing the bonus countdown
    102  0000 ????			  -F1F2NEXTCAVE SET	NO	; debugging -- F1+F2 will trigger next level. Good to test the progression of level/caves
    103  0000 ????			  -CONSTRUCTIONKIT SET	NO	; patch-capable binary for construction kit usage
    104  0000 ????			  -SHOW_COPYRIGHT SET	YES	; must be YES for final release
    105  0000 ????			  -EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
    106  0000 ????			  -SORT_OBJECTS SET	YES	; Warning: can be slow on complex screens
    107  0000 ????			  -SPECIAL_ADD_DECODECAVE SET	YES	; causes boulders and diamonds to be added as falling objects on cave startup
    108  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
    109  0000 ????			  -SHOWDIAMONDP SET	NO	; debug show diamond on P
    110  0000 ????			  -
    111  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
    112  0000 ????			  -DEMO_DELAY SET	2	; number of music loops without joystick input before demo kicks in
    113  0000 ????			  -EASTER_EGG SET	YES	; enable easter egg (instead intermission of INT4)
    114  0000 ????			  -NTSC_MODE  SET	YES	; mmh
    115  0000 ????				      ENDIF
    116  0000 ????
    117  0000 ????			  -	      IF	DEMO_VERSION = YES
    118  0000 ????			  -TEST_BONUS_COUNTDOWN SET	NO	; causes level A1 to have a special setup for testing the bonus countdown
    119  0000 ????			  -F1F2NEXTCAVE SET	NO	; debugging -- F1+F2 will trigger next level. Good to test the progression of level/caves
    120  0000 ????			  -CONSTRUCTIONKIT SET	NO	; patch-capable binary for construction kit usage
    121  0000 ????			  -SHOW_COPYRIGHT SET	YES	; must be YES for final release
    122  0000 ????			  -EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
    123  0000 ????			  -SORT_OBJECTS SET	YES	; Warning: can be slow on complex screens
    124  0000 ????			  -SPECIAL_ADD_DECODECAVE SET	YES	; causes boulders and diamonds to be added as falling objects on cave startup
    125  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
    126  0000 ????			  -SHOWDIAMONDP SET	NO	; debug show diamond on P
    127  0000 ????			  -
    128  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
    129  0000 ????			  -DEMO_DELAY SET	2	; number of music loops without joystick input before demo kicks in
    130  0000 ????			  -EASTER_EGG SET	NO	; enable easter egg (instead intermission of INT4)
    131  0000 ????			  -NTSC_MODE  SET	YES	; mmh
    132  0000 ????				      ENDIF
    133  0000 ????
    134  0000 ????						;-------------------------------------------------------------------------------
    135  0000 ????
    136  0000 ????						;SHOW_TITLE			  SET YES	  ; NOW *REQUIRED* FOR CAVE/LEVEL SELECTION!!!
    137  0000 ????
    138  0000 ????
    139  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
    140  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
    141  0000 ????
    142  0000 ????
    143  0000 ????	       00 06	   PUSH_LIMIT =	6	; slowdown when pushing on a boulder
    144  0000 ????	       00 01	   GENERIC_MASK_ROUNDED =	1	; lets rocks/diamonds roll off
    145  0000 ????	       00 02	   GENERIC_MASK_SQUASHABLE =	2	; gets pummelled by anything falling on it
    146  0000 ????	       00 08	   GENERIC_MASK_EXPLODABLE =	8	; takes part in an explosion
    147  0000 ????	       00 10	   GENERIC_MASK_KILLSBUTTERFLY =	16	; causes nearby butterfly/firefly to explode
    148  0000 ????	       00 20	   GENERIC_MASK_MAGICWALL =	32	; a magic wall character
    149  0000 ????	       00 80	   GENERIC_MASK_FALLABLE =	128	; objects can fall into blanks (BMI usage assumed!!)
    150  0000 ????
    151  0000 ????						; POS_VAR flags:
    152  0000 ????	       00 80	   VAR_FALLING =	%10000000	; hardwired! negative assumed
    153  0000 ????	       00 40	   VAR_JUST_GENERATED =	%01000000	; object cannot fall and squash things yet
    154  0000 ????
    155  0000 ????						; amoeba and magic wall constants:
    156  0000 ????	       00 ff	   MAGIC_WALL_DORMANT =	$FF	; wall dormant, waiting for trigger
    157  0000 ????	       00 ff	   AMOEBA_FAST_GROW =	MAGIC_WALL_DORMANT
    158  0000 ????	       00 c8	   TOO_MUCH_AMOEBA =	200	; squares of amoeba before turns into boulders (original 200)
    159  0000 ????						; we should try to adjust the growth first by changing MIN_AMOEBA_SCAN,
    160  0000 ????						; maybe we can assume FAST_GROW to be 256 and then can remove the code for it.
    161  0000 ????	       00 1d	   SLOW_GROW  =	30+1-2	; should be ~3%
    162  0000 ????	       00 e9	   FAST_GROW  =	240+1-8	; should be ~25% (8x SLOW_GROW)
    163  0000 ????	       00 1e	   MIN_AMOEBA_SCAN =	30	; minimum required checks/scan (this slows down small Amoebas)
    164  0000 ????
    165  0000 ????						; time bonus countdown constants:
    166  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
    167  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
    168  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
    169  0000 ????
    170  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    171  0000 ????
    172  0000 ????	       00 02	   FACE_DOWN  =	2
    173  0000 ????	       00 03	   FACE_LEFT  =	3
    174  0000 ????
    175  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
    176  0000 ????	       00 06	   FLASH_TIME =	6	; flash time for BG colour when door opens
    177  0000 ????	       00 0a	   RED_TIME_WARNING =	10	; time remaining before time remaining flashes
    178  0000 ????
    179  0000 ????						;scoring flags contants:
    180  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
    181  0000 ????	       00 00	   DISPLAY_TIME =	%00
    182  0000 ????	       00 01	   DISPLAY_SCORE =	%01
    183  0000 ????	       00 02	   DISPLAY_LIVES =	%10
    184  0000 ????	       00 03	   DISPLAY_HIGH =	%11
    185  0000 ????	       00 40	   EXTRA_100_DIAMONDS =	$40	; set if more than 100 extra diamonds collected
    186  0000 ????	       00 80	   EXTRA_DIAMONDS =	$80	; set if collecting extra diamonds
    187  0000 ????
    188  0000 ????						;------------------------------------------------------------------------------
    189  0000 ????
    190  0000 ????	       00 01	   MIRRORED_BOULDER =	YES
    191  0000 ????	       00 01	   MIRRORED_AMOEBA =	YES
    192  0000 ????	       00 01	   MIRRORED_STEEL =	YES
    193  0000 ????	       00 01	   MIRRORED_WALL =	YES
    194  0000 ????
    195  0000 ????						;------------------------------------------------------------------------------
    196  0000 ????
    197  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    198  0000 ????
    199  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    200  0000 ????	       00 15	   LINES_PER_CHAR =	21	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    201  0000 ????
    202  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    203  0000 ????
    204  0000 ????
    205  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    206  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    207  0000 ????
    208  0000 ????
    209  0000 ????						; color constants:
    210  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    211  0000 ????
    212  0000 ????	       00 10	   YELLOW_NTSC =	$10
    213  0000 ????	       00 20	   YELLOW_PAL =	$20
    214  0000 ????
    215  0000 ????
    216  0000 ????	       10 00	   RAM_3E     =	$1000
    217  0000 ????	       04 00	   RAM_SIZE   =	$400
    218  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    219  0000 ????
    220  0000 ????
    221  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    222  0000 ????
    223  0000 ????
    224  0000 ????						; Platform constants:
    225  0000 ????	       00 02	   PAL	      =	%10
    226  0000 ????	       00 02	   PAL_50     =	PAL|0
    227  0000 ????	       00 03	   PAL_60     =	PAL|1
    228  0000 ????
    229  0000 ????
    230  0000 ????				      IF	L276
    231  0000 ????	       00 3e	   VBLANK_TIM_NTSC =	62	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    232  0000 ????			  -	      ELSE
    233  0000 ????			  -VBLANK_TIM_NTSC =	45	; NTSC 262
    234  0000 ????				      ENDIF
    235  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    236  0000 ????
    237  0000 ????				      IF	L276
    238  0000 ????	       00 33	   OVERSCAN_TIM_NTSC =	51	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    239  0000 ????			  -	      ELSE
    240  0000 ????			  -OVERSCAN_TIM_NTSC =	51	; NTSC 262
    241  0000 ????				      ENDIF
    242  0000 ????	       00 46	   OVERSCAN_TIM_PAL =	70	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    243  0000 ????
    244  0000 ????				      IF	L276
    245  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    246  0000 ????			  -	      ELSE
    247  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    248  0000 ????				      ENDIF
    249  0000 ????	       01 38	   SCANLINES_PAL =	312
    250  0000 ????
    251  0000 ????
    252  0000 ????						;------------------------------------------------------------------------------
    253  0000 ????						; MACRO definitions
    254  0000 ????
    255  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    256  0000 ????
    257  0000 ????				      MAC	newbank
    258  0000 ????				      SEG	{1}
    259  0000 ????				      ORG	ORIGIN
    260  0000 ????				      RORG	$F000
    261  0000 ????			   BANK_START SET	*
    262  0000 ????			   {1}	      SET	ORIGIN / 2048
    263  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    264  0000 ????			   _CURRENT_BANK SET	{1}
    265  0000 ????				      ENDM		; bank name
    266  0000 ????
    267  0000 ????				      MAC	define_1k_segment
    268  0000 ????				      ALIGN	$400
    269  0000 ????			   SEGMENT_{1} SET	*
    270  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    271  0000 ????				      ENDM		; {seg name}
    272  0000 ????
    273  0000 ????				      MAC	check_bank_size
    274  0000 ????			   .TEMP      =	* - BANK_START
    275  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    276  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    277  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    278  0000 ????				      ERR
    279  0000 ????				      endif
    280  0000 ????				      ENDM		; name
    281  0000 ????
    282  0000 ????
    283  0000 ????				      MAC	check_half_bank_size
    284  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    285  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    286  0000 ????			   .TEMP      =	* - BANK_START
    287  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    288  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    289  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    290  0000 ????				      ERR
    291  0000 ????				      endif
    292  0000 ????				      ENDM		; name
    293  0000 ????
    294  0000 ????
    295  0000 ????				      MAC	overlay
    296  0000 ????				      SEG.U	OVERLAY_{1}
    297  0000 ????				      org	Overlay
    298  0000 ????				      ENDM		; {name}
    299  0000 ????
    300  0000 ????						;--------------------------------------------------------------------------
    301  0000 ????
    302  0000 ????				      MAC	validate_overlay
    303  0000 ????				      LIST	OFF
    304  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    305  0000 ????				      ERR
    306  0000 ????				      endif
    307  0000 ????				      LIST	ON
    308  0000 ????				      ENDM
    309  0000 ????
    310  0000 ????						;--------------------------------------------------------------------------
    311  0000 ????						; Macro inserts a page break if the object would overlap a page
    312  0000 ????
    313  0000 ????				      MAC	optional_pagebreak
    314  0000 ????				      LIST	OFF
    315  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    316  0000 ????			   EARLY_LOCATION SET	*
    317  0000 ????				      ALIGN	256
    318  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    319  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    320  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    321  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    322  0000 ????				      ENDIF
    323  0000 ????				      LIST	ON
    324  0000 ????				      ENDM		; { string, size }
    325  0000 ????
    326  0000 ????
    327  0000 ????				      MAC	check_page_crossing
    328  0000 ????				      LIST	OFF
    329  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    330  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    331  0000 ????				      endif
    332  0000 ????				      LIST	ON
    333  0000 ????				      ENDM
    334  0000 ????
    335  0000 ????				      MAC	checkpage
    336  0000 ????				      LIST	OFF
    337  0000 ????				      IF	>. != >{1}
    338  0000 ????				      ECHO	""
    339  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    340  0000 ????				      ECHO	""
    341  0000 ????				      ERR
    342  0000 ????				      ENDIF
    343  0000 ????				      LIST	ON
    344  0000 ????				      ENDM
    345  0000 ????
    346  0000 ????				      MAC	checkpage_bne
    347  0000 ????				      LIST	OFF
    348  0000 ????				      IF	0	;>(. + 2) != >{1}
    349  0000 ????				      ECHO	""
    350  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    351  0000 ????				      ECHO	""
    352  0000 ????				      ERR
    353  0000 ????				      ENDIF
    354  0000 ????				      LIST	ON
    355  0000 ????				      bne	{1}
    356  0000 ????				      ENDM
    357  0000 ????
    358  0000 ????				      MAC	checkpage_bpl
    359  0000 ????				      LIST	OFF
    360  0000 ????				      IF	(>(.+2 )) != >{1}
    361  0000 ????				      ECHO	""
    362  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    363  0000 ????				      ECHO	""
    364  0000 ????				      ERR
    365  0000 ????				      ENDIF
    366  0000 ????				      LIST	ON
    367  0000 ????				      bpl	{1}
    368  0000 ????				      ENDM
    369  0000 ????
    370  0000 ????				      MAC	align_free
    371  0000 ????			   FREE       SET	FREE - .
    372  0000 ????				      align	{1}
    373  0000 ????			   FREE       SET	FREE + .
    374  0000 ????				      echo	"@", ., ":", FREE
    375  0000 ????				      ENDM
    376  0000 ????
    377  0000 ????				      MAC	stress_time
    378  0000 ????				      IF	TEST_{1} = 1
    379  0000 ????
    380  0000 ????
    381  0000 ????						;LIST OFF
    382  0000 ????						; has to be put *directly* after cmp #SEGTIME_... , bcc abort
    383  0000 ????						;LIST ON
    384  0000 ????				      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
    385  0000 ????				      bne	. - 7	; branches to lda INTIM
    386  0000 ????				      ENDIF
    387  0000 ????				      ENDM
    388  0000 ????
    389  0000 ????			   IDENTITY   SET	0
    390  0000 ????				      MAC	ident
    391  0000 ????				      if	DEBUG=YES
    392  0000 ????				      lda	#IDENTITY
    393  0000 ????				      sta	debug_ident
    394  0000 ????				      lda	{1}
    395  0000 ????				      sta	debug_object
    396  0000 ????				      endif
    397  0000 ????			   IDENTITY   SET	IDENTITY + 1
    398  0000 ????				      ENDM		; {object}
    399  0000 ????
    400  0000 ????						;--------------------------------------------------------------------------
    401  0000 ????
    402  0000 ????				      MAC	vector
    403  0000 ????				      .word	{1}
    404  0000 ????				      ENDM		; just a word pointer to code
    405  0000 ????
    406  0000 ????
    407  0000 ????				      MAC	define_subroutine
    408  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    409  0000 ????				      SUBROUTINE		; keep everything local
    410  0000 ????			   {1}			; entry point
    411  0000 ????				      ENDM		; name of subroutine
    412  0000 ????
    413  0000 ????
    414  0000 ????
    415  0000 ????						;--------------------------------------------------------------------------
    416  0000 ????
    417  0000 ????				      MAC	newrambank
    418  0000 ????				      SEG.U	{1}
    419  0000 ????				      ORG	ORIGIN
    420  0000 ????				      RORG	RAM_3E
    421  0000 ????			   BANK_START SET	*
    422  0000 ????			   {1}	      SET	ORIGIN / RAM_SIZE
    423  0000 ????			   ORIGIN     SET	ORIGIN + RAM_SIZE
    424  0000 ????				      ENDM		; bank name
    425  0000 ????
    426  0000 ????				      MAC	validate_ram_size
    427  0000 ????				      if	* - RAM_3E > RAM_SIZE
    428  0000 ????				      ERR
    429  0000 ????				      endif
    430  0000 ????				      ENDM
    431  0000 ????
    432  0000 ????				      MAC	next_random
    433  0000 ????						; update random value:
    434  0000 ????				      lda	rnd	; 3
    435  0000 ????				      lsr		; 2
    436  0000 ????				      IFCONST	rndHi
    437  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    438  0000 ????				      ENDIF
    439  0000 ????				      bcc	.skipEOR	; 2/3
    440  0000 ????				      eor	#RND_EOR_VAL	; 2
    441  0000 ????			   .skipEOR
    442  0000 ????				      sta	rnd	; 3 = 14/19
    443  0000 ????				      ENDM
    444  0000 ????
    445  0000 ????				      MAC	resync
    446  0000 ????						; resync screen, X and Y == 0 afterwards
    447  0000 ????				      lda	#%10	; make sure VBLANK is ON
    448  0000 ????				      sta	VBLANK
    449  0000 ????
    450  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    451  0000 ????			   .loopResync
    452  0000 ????				      VERTICAL_SYNC
    453  0000 ????
    454  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    455  0000 ????				      lda	Platform
    456  0000 ????				      eor	#PAL_50	; PAL-50?
    457  0000 ????				      bne	.ntsc
    458  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    459  0000 ????			   .ntsc
    460  0000 ????			   .loopWait
    461  0000 ????				      sta	WSYNC
    462  0000 ????				      sta	WSYNC
    463  0000 ????				      dey
    464  0000 ????				      bne	.loopWait
    465  0000 ????				      dex
    466  0000 ????				      bne	.loopResync
    467  0000 ????				      ENDM
    468  0000 ????
    469  0000 ????				      MAC	set_platform
    470  0000 ????						; 00 = NTSC
    471  0000 ????						; 01 = NTSC
    472  0000 ????						; 10 = PAL-50
    473  0000 ????						; 11 = PAL-60
    474  0000 ????				      lda	SWCHB
    475  0000 ????				      rol
    476  0000 ????				      rol
    477  0000 ????				      rol
    478  0000 ????				      and	#%11
    479  0000 ????				      if	NTSC_MODE = NO
    480  0000 ????				      eor	#PAL
    481  0000 ????				      endif
    482  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    483  0000 ????				      ENDM
    484  0000 ????
    485  0000 ????						;  IF TJ_MODE
    486  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM ; = 29
    487  0000 ????						;	  ldy #{1}			  ; 2	  read bank
    488  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    489  0000 ????						;	  jsr GetRAMByteFromRAM 	  ;25
    490  0000 ????						;    ENDM
    491  0000 ????						;
    492  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM ; = 30
    493  0000 ????						;	  ldy #{1}			  ; 2	  write bank
    494  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    495  0000 ????						;	  jsr PutRAMByteFromRAM 	  ;26
    496  0000 ????						;    ENDM
    497  0000 ????						;
    498  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM_ADR ; = 39
    499  0000 ????						;	  ldx #<{1}			  ; 2
    500  0000 ????						;	  stx addressR			  ; 3
    501  0000 ????						;	  ldx #>{1}			  ; 2
    502  0000 ????						;	  stx addressR+1		  ; 3
    503  0000 ????						;	  GET_RAM_BYTE_FROM_RAM {2}, {3}  ;29
    504  0000 ????						;    ENDM
    505  0000 ????						;
    506  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM_ADR ; = 40
    507  0000 ????						;	  ldx #<{1}			  ; 2
    508  0000 ????						;	  stx addressW			  ; 3
    509  0000 ????						;	  ldx #>({1}+RAM_WRITE) 	  ; 2
    510  0000 ????						;	  stx addressW+1		  ; 3
    511  0000 ????						;	  PUT_RAM_BYTE_FROM_RAM {2}, {3}  ;30
    512  0000 ????						;    ENDM
    513  0000 ????						;  ENDIF
    514  0000 ????
    515  0000 ????				      MAC	nop_b
    516  0000 ????				      .byte	$82
    517  0000 ????				      ENDM		; unused
    518  0000 ????
    519  0000 ????				      MAC	nop_w
    520  0000 ????				      .byte	$0c
    521  0000 ????				      ENDM
    522  0000 ????
    523  0000 ????						;------------------------------------------------------------------------------
    524  0000 ????
    525  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????
      2 U00fb ????				      SEG.U	variables
      3 U0080					      ORG	$80
      4 U0080
      5 U0080		       00 40	   GAMEMODE_2600 =	64
      6 U0080		       00 80	   GAMEMODE_PAUSED =	128
      7 U0080
      8 U0080		       00	   gameMode   ds	1	; bit7=0: 7800; bit7=1: 2600.	bit 6=1: paused: bit3: toggle bit for B/W
      9 U0081		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     10 U0082							; above variables are preserved ALL the time!
     11 U0082
     12 U0082		       00 00 00 00*Surround   ds	5
     13 U0087		       00	   rnd	      ds	1
     14 U0088		       00	   rndHi      ds	1	; to get better random values
     15 U0089
     16 U0089		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     17 U008a		       00	   ObjStackNum ds	1	; which stack in use
     18 U008b		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     19 U008d		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     20 U008e		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     21 U008f
     22 U008f		       00	   POS_X      ds	1
     23 U0090		       00	   POS_Y      ds	1
     24 U0091		       00	   POS_X_NEW  ds	1
     25 U0092		       00	   POS_Y_NEW  ds	1
     26 U0093		       00	   POS_Type   ds	1
     27 U0094		       00	   POS_VAR    ds	1
     28 U0095
     29 U0095		       00 00	   BufferedJoystick ds	2	; player joystick input
     30 U0097		       00	   BufferedButton ds	1	; player button press
     31 U0098
     32 U0098							; Scrolling is limited to only show board within the following area...
     33 U0098		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in DecodeCave)
     34 U0099		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in DecodeCave)
     35 U009a		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     36 U009b		       00	   BoardScrollX ds	1	; scroll position in board (X)
     37 U009b		       00 98	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     38 U009b		       00 99	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     39 U009c		       00	   scrollBits ds	1
     40 U009d
     41 U009d		       00	   MagicAmoebaFlag ds	1	; status of magic wall and amoeba
     42 U009e
     43 U009e		       00	   whichPlayer ds	1	; 0 = P1, 1 = P2
     44 U009f
     45 U009f		       00	   ManX       ds	1
     46 U00a0		       00	   ManY       ds	1
     47 U00a1		       00	   ManDrawX   ds	1
     48 U00a2		       00	   ManDrawY   ds	1
     49 U00a3		       00	   ManMode    ds	1
     50 U00a4		       00	   ManDelayCount ds	1
     51 U00a5		       00 00	   ManAnimation ds	2
     52 U00a7		       00	   ManAnimationFrameLO ds	1
     53 U00a8		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     54 U00a9		       00	   ManPushCounter ds	1
     55 U00aa		       00	   LookingAround ds	1
     56 U00ab		       00	   MenCurrent ds	1	; player life counter
     57 U00ac		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     58 U00ad
     59 U00ad							;---------------------------------------------------------------------------
     60 U00ad							; 2 (shared) demo mode variables:
     61 U00ad		       00 ac	   demoMode   =	jtoggle	; bit 7==1 => demo mode
     62 U00ad		       00 ac	   moveLen    =	jtoggle	; bits 0..6
     63 U00ad		       00 9e	   moveIdx    =	whichPlayer
     64 U00ad
     65 U00ad		       00	   LastSpriteY ds	1
     66 U00ae
     67 U00ae		       00	   timer      ds	1
     68 U00af
     69 U00af		       00	   BGColour   ds	1
     70 U00b0
     71 U00b0							; cave and level have to be consecutive variables!
     72 U00b0		       00	   cave       ds	1	; current player's cave (other in scoring bank)
     73 U00b1		       00	   level      ds	1	; current player's level (other in scoring bank)
     74 U00b2		       00	   caveDisplay ds	1	; what to display as the cave ID
     75 U00b3		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
     76 U00b4		       00	   ThrottleSpeed ds	1	; system-dependant throttle speed
     77 U00b5
     78 U00b5		       00	   magicAmoebaTime ds	1	; time for magic wall and amoeba slow growth
     79 U00b6		       00	   diamondsNeeded ds	1	; TJ: changed that (NOTE: counts down to 0 then (negatively) UP to give extra diamonds found.)
     80 U00b7		       00	   diamondsWorth ds	1	; TJ: could be moved to Scoring Bank
     81 U00b8		       00	   diamondsExtraWorth ds	1	; TJ: could be moved to Scoring Bank
     82 U00b9		       00	   caveTime   ds	1	; BCD seconds for level
     83 U00ba		       00	   caveTimeHi ds	1
     84 U00bb		       00	   caveTimeFrac ds	1
     85 U00bc		       00 00 00    color      ds	3	; RGB for NTSC, RGB for PAL
     86 U00bf		       00 00	   Board_AddressR ds	2
     87 U00c1		       00 00	   Board_AddressW ds	2
     88 U00c3		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
     89 U00c4		       00	   RAM_Bank   ds	1
     90 U00c5
     91 U00c5							;  IF TJ_MODE
     92 U00c5							;addressR			  = Board_AddressR
     93 U00c5							;addressW			  = Board_AddressW
     94 U00c5							;  ENDIF
     95 U00c5
     96 U00c5		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
     97 U00c6		       00	   extraLifeTimer ds	1	; should be 5 seconds!
     98 U00c7
     99 U00c7							; extraLifeTimer:
    100 U00c7							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    101 U00c7
    102 U00c7		       00	   scoringTimer ds	1	; times the various score displays
    103 U00c8		       00	   scoringFlags ds	1	; scoring flags are stored here
    104 U00c9
    105 U00c9							; scoringFlags:
    106 U00c9							; D7		 Extra diamonds in effect (diamonds collected over requirement score more) ASSUMED BPL/BMI usage
    107 U00c9							; D6		 unused
    108 U00c9							; D5		 unused
    109 U00c9							; D4		 unused
    110 U00c9							; D3		 unused
    111 U00c9							; D2		 unused
    112 U00c9							; D1	 D1-D0	 Which display kernel to use for scoring
    113 U00c9							; D0		 0 = 2x4     used for diamonds/time
    114 U00c9							;		 1 = 1x6     used for score
    115 U00c9							;		 2 = 3x2     used for level/lives/player
    116 U00c9
    117 U00c9		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    118 U00c9		       00 80	   BIT_NEXTLEVEL =	128
    119 U00c9		       00 40	   BIT_NEXTLIFE =	64
    120 U00c9		       00 01	   BIT_GOTOLOGO =	1
    121 U00ca
    122 U00ca		       00	   amoebaX    ds	1	; x-pos of currently scanned cell
    123 U00cb		       00	   amoebaY    ds	1	; y-pos of currently scanned cell
    124 U00cc		       00	   amoebaFlag ds	1	; current status of amoeba
    125 U00cd
    126 U00cd							; constants for amoebaFlag:
    127 U00cd		       00 01	   NOT_ENCLOSED =	%00000001	;
    128 U00cd		       00 02	   SCAN_FINISHED =	%00000010	; indicates that one scan finished and the next one has to wait
    129 U00cd		       00 20	   FINISHEDDIAMOND =	%00100000	;
    130 U00cd		       00 40	   AMOEBA_PRESENT =	%01000000	; set during the very first amoeba object init
    131 U00cd		       00 80	   TODIAMOND  =	%10000000	;
    132 U00cd
    133 U00cd		       00	   amoebaCount ds	1	; number of cells counted in current scan
    134 U00ce							; bounding box for amoeba scan:
    135 U00ce		       00	   amoebaMinX ds	1
    136 U00cf		       00	   amoebaMinY ds	1
    137 U00d0		       00	   amoebaMaxX ds	1
    138 U00d1		       00	   amoebaMaxY ds	1
    139 U00d2		       00	   amoebaStepCount ds	1	; scan speed limiter
    140 U00d3
    141 U00d3							;---------------------------------------------------------------------------
    142 U00d3
    143 U00d3		       00	   sortRequired ds	1
    144 U00d4		       00	   sortPtr    ds	1
    145 U00d5
    146 U00d5							;---------------------------------------------------------------------------
    147 U00d5							; sound driver needs 6 bytes:
    148 U00d5		       00 00	   soundIdxLst ds	2	; index of current sound
    149 U00d7		       00 00	   decayIdxLst ds	2	; index of current note
    150 U00d9		       00 00	   decayTimeLst ds	2	; remaining lenght of current note
    151 U00d9		       00 d7	   soundBonusPts =	decayIdxLst	; shared, used for bonus points count down (channel 0!)
    152 U00db		       00	   newSounds  ds	1
    153 U00dc
    154 U00dc							;------------------------------------------------------------------------------
    155 U00dc
    156 U00dc		       00	   specialTimeFlag ds	1	; detects time problem with man
    157 U00dd		       00	   ObjIterator ds	1	; count UP iterator over objects
    158 U00de		       00	   DSL	      ds	1	; stack line counter
    159 U00df
    160 U00df				   OVERLAY_SIZE SET	16
    161 U00df
    162 U00df
    163 U00df
    164 U00df							; This overlay variable is used for the overlay variables.  That's OK.
    165 U00df							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    166 U00df							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    167 U00df							; (especially the latter ones) are only used in rare occasions.
    168 U00df
    169 U00df							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    170 U00df							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    171 U00df
    172 U00df		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00ef					      VALIDATE_OVERLAY
      5 U00ef					      LIST	ON
    174 U00ef
    175 U00ef
    176 U00ef		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    177 U00fb
 FREE BYTES IN ZERO PAGE =  $4
    178 U00fb					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    179 U00fb				  -	      IF	* > $FF
    180 U00fb				  -	      ERR
    181 U00fb					      ENDIF
------- FILE ./notBoulderDash.asm
    527 U00fb
    528 U00fb
    529 U00fb							;------------------------------------------------------------------------------
    530 U00fb							; OVERLAYS!
    531 U00fb							; These variables are overlays, and should be managed with care
    532 U00fb							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    533 U00fb
    534 U00fb							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    535 U00fb							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    536 U00fb
    537 U00fb							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    538 U00fb
    539 U00fb							;------------------------------------------------------------------------------
      0 U00fb					      OVERLAY	BuildDrawFlags
      1 U00ea ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00df					      org	Overlay
    541 U00df
    542 U00df		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    543 U00e1		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    544 U00e3		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    545 U00e5		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    546 U00e7							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    547 U00e7		       00	   BDF_BoardBank ds	1	; holds bank of current line
    548 U00e8							;  ENDIF
    549 U00e8		       00	   DHS_Line   ds	1
    550 U00e9		       00	   DHS_Stack  ds	1	; for restoring SP
    551 U00ea							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00ea					      VALIDATE_OVERLAY
      5 U00ea					      LIST	ON
    553 U00ea
    554 U00ea							;------------------------------------------------------------------------------
    555 U00ea
      0 U00ea					      OVERLAY	Process
      1 U00e1 ????				      SEG.U	OVERLAY_Process
      2 U00df					      org	Overlay
    557 U00df
    558 U00df		       00	   BoulderLeft ds	1
    559 U00e0		       00	   BoulderRight ds	1
    560 U00e1
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    562 U00e1
    563 U00e1							;------------------------------------------------------------------------------
    564 U00e1
      0 U00e1					      OVERLAY	Animate
      1 U00e0 ????				      SEG.U	OVERLAY_Animate
      2 U00df					      org	Overlay
    566 U00df		       00	   halftimer  ds	1
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    568 U00e0
    569 U00e0							;------------------------------------------------------------------------------
    570 U00e0
      0 U00e0					      OVERLAY	TimeSlice
      1 U00e1 ????				      SEG.U	OVERLAY_TimeSlice
      2 U00df					      org	Overlay
    572 U00df
    573 U00df		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    574 U00e1							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    576 U00e1
    577 U00e1							;------------------------------------------------------------------------------
    578 U00e1
      0 U00e1					      OVERLAY	CopyROMShadowToRAM
      1 U00e2 ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00df					      org	Overlay
    580 U00df
    581 U00df		       00	   O_CopyCount ds	1
    582 U00e0		       00	   O_ROM_Source_Bank ds	1
    583 U00e1		       00	   O_Index    ds	1
    584 U00e2							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e2					      VALIDATE_OVERLAY
      5 U00e2					      LIST	ON
    586 U00e2
    587 U00e2							;------------------------------------------------------------------------------
    588 U00e2
      0 U00e2					      OVERLAY	Scoring
      1 U00e1 ????				      SEG.U	OVERLAY_Scoring
      2 U00df					      org	Overlay
    590 U00df		       00	   tmpStack   ds	1
    591 U00df		       00 df	   newDisplay =	tmpStack
    592 U00e0							; also for UpdateTimer
    593 U00e0		       00 df	   tmpSound   =	tmpStack
    594 U00e0		       00	   timerLoops ds	1
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    596 U00e1
    597 U00e1
    598 U00e1							;------------------------------------------------------------------------------
    599 U00e1
      0 U00e1					      OVERLAY	SaveKey
      1 U00e8 ????				      SEG.U	OVERLAY_SaveKey
      2 U00df					      org	Overlay
    601 U00df
    602 U00df		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    603 U00e2		       00 00 00    highScoreSK ds	3
    604 U00e5		       00	   startCave  ds	1	; cave * 5
    605 U00e6		       00	   startLevel ds	1
    606 U00e7		       00	   offsetSK   ds	1	; for calculating the SK slot address
    607 U00e8
      0 U00e8					      VALIDATE_OVERLAY
      5 U00e8					      LIST	ON
    609 U00e8
    610 U00e8							;------------------------------------------------------------------------------
    611 U00e8
      0 U00e8					      OVERLAY	DrawMan
      1 U00e1 ????				      SEG.U	OVERLAY_DrawMan
      2 U00df					      org	Overlay
    613 U00df
    614 U00df		       00 00	   MAN_Move   ds	2
    615 U00e1
    616 U00e1							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    618 U00e1
    619 U00e1							;------------------------------------------------------------------------------
    620 U00e1
      0 U00e1					      OVERLAY	ProcessObjStack
      1 U00e1 ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00df					      org	Overlay
    622 U00df
    623 U00df		       00 00	   POS_Vector ds	2
    624 U00e1
    625 U00e1							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    627 U00e1
    628 U00e1							;------------------------------------------------------------------------------
      0 U00e1					      OVERLAY	Surround
      1 U00e7 ????				      SEG.U	OVERLAY_Surround
      2 U00df					      org	Overlay
    630 U00df		       00 00	   Temp_Board_Address1 ds	2
    631 U00e1		       00 00	   Temp_Board_Address2 ds	2
    632 U00e3		       00 00	   Temp_Board_Address3 ds	2
    633 U00e5							;    IF MULTI_BANK_BOARD = YES 	 ; commented, else DASM freaks out
    634 U00e5		       00	   Temp_Bank2 ds	1
    635 U00e6		       00	   Temp_Bank3 ds	1
    636 U00e7							;    ENDIF
    637 U00e7
    638 U00e7							;ECHO "FREE BYTES IN OVERLAY_Surround = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e7					      VALIDATE_OVERLAY
      5 U00e7					      LIST	ON
    640 U00e7							;------------------------------------------------------------------------------
    641 U00e7
      0 U00e7					      OVERLAY	ScoreLineOverlay
      1 U00ee ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00df					      org	Overlay
    643 U00df
    644 U00df		       00 00	   S0	      ds	2	; used for addressing digits of score
    645 U00e1		       00 00	   S1	      ds	2
    646 U00e3		       00 00	   S2	      ds	2
    647 U00e5		       00 00	   S3	      ds	2
    648 U00e7		       00 00	   S4	      ds	2
    649 U00e9		       00 00	   S5	      ds	2
    650 U00eb
    651 U00eb		       00	   stkp       ds	1
    652 U00ec		       00	   sreg       ds	1
    653 U00ed		       00	   loop       ds	1
    654 U00ee
    655 U00ee							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00ee					      VALIDATE_OVERLAY
      5 U00ee					      LIST	ON
    657 U00ee
    658 U00ee							;------------------------------------------------------------------------------
    659 U00ee
    660 U00ee
      0 U00ee					      OVERLAY	DecodeCaveOverlay
      1 U00ea ????				      SEG.U	OVERLAY_DecodeCaveOverlay
      2 U00df					      org	Overlay
    662 U00df
    663 U00df							; used everywhere
    664 U00df		       00 00 00 00 ptrCave    ds	4	; two pointers
    665 U00e3
    666 U00e3		       00	   randSeed1  ds	1
    667 U00e4		       00	   randSeed2  ds	1
    668 U00e5		       00	   tempRand1  ds	1
    669 U00e6		       00	   tempRand2  ds	1
    670 U00e7		       00	   tmpScore   ds	1
    671 U00e8
    672 U00e8							;------------------------------------------------------------------------------
    673 U00e8
    674 U00e8		       00	   object     ds	1
    675 U00e8		       00 e3	   structType =	randSeed1
    676 U00e8		       00 e4	   column     =	randSeed2
    677 U00e8		       00 e5	   row	      =	tempRand1
    678 U00e8		       00 e6	   length     =	tempRand2
    679 U00e8		       00 e1	   height     =	ptrCave+2
    680 U00e8		       00 e2	   direction  =	ptrCave+3
    681 U00e9		       00	   tmpLength  ds	1
    682 U00ea
    683 U00ea							;ECHO "FREE BYTES IN DecodeCaveOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00ea					      VALIDATE_OVERLAY
      5 U00ea					      LIST	ON
    685 U00ea
    686 U00ea							;------------------------------------------------------------------------------
    687 U00ea
      0 U00ea					      OVERLAY	Copyright
      1 U00e5 ????				      SEG.U	OVERLAY_Copyright
      2 U00df					      org	Overlay
    689 U00df		       00	   LoopCount  ds	1
    690 U00e0		       00	   colorBK    ds	1
    691 U00e1		       00 00	   Temp       ds	2
    692 U00e3		       00	   CopyTime   ds	1
    693 U00e4		       00	   saveSP     ds	1
      0 U00e5					      VALIDATE_OVERLAY
      5 U00e5					      LIST	ON
    695 U00e5
      0 U00e5					      OVERLAY	ManProcessing
      1 U00e1 ????				      SEG.U	OVERLAY_ManProcessing
      2 U00df					      org	Overlay
    697 U00df		       00 00	   actionVector ds	2
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    699 U00e1
      0 U00e1					      OVERLAY	CaveDecode
      1 U00e0 ????				      SEG.U	OVERLAY_CaveDecode
      2 U00df					      org	Overlay
    701 U00df		       00	   savex      ds	1
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    703 U00e0
    704 U00e0
      0 U00e0					      OVERLAY	TJSound
      1 U00e4 ????				      SEG.U	OVERLAY_TJSound
      2 U00df					      org	Overlay
    706 U00df							; temps (overlay these with existing temps to save RAM)
    707 U00df		       00	   musicTemp  ds	1
    708 U00e0		       00	   musicTemp16L ds	1
    709 U00e1		       00	   musicTemp16H ds	1
    710 U00e2		       00	   musicAtten ds	1
    711 U00e3		       00	   tmpVar     ds	1
      0 U00e4					      VALIDATE_OVERLAY
      5 U00e4					      LIST	ON
    713 U00e4
      0 U00e4					      OVERLAY	SetPlatformColours
      1 U00e0 ????				      SEG.U	OVERLAY_SetPlatformColours
      2 U00df					      org	Overlay
    715 U00df		       00	   colorIdx   ds	1
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    717 U00e0
      0 U00e0					      OVERLAY	SwapPlayers
      1 U00e0 ????				      SEG.U	OVERLAY_SwapPlayers
      2 U00df					      org	Overlay
    719 U00df		       00	   tmpX       ds	1
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    721 U00e0
      0 U00e0					      OVERLAY	DrawIntoStack
      1 U00e0 ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00df					      org	Overlay
    723 U00df		       00	   save_SP    ds	1
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    725 U00e0
    726 U00e0
    727 U00e0							;------------------------------------------------------------------------------
    728 U00e0							;##############################################################################
    729 U00e0							; TITLE SCREEN VARS
    730 U00e0							;------------------------------------------------------------------------------
    731 U00e0
    732 U00e0		       00 21	   NUM_BLOCKS =	33	; number of text graphics blocks
    733 U00e0		       00 04	   BLOCK_H    =	4	; height of the text graphics blocks
    734 U00e0		       00 08	   BORDER_H   =	8	; height of border blocks (~width of one PF pixel)
    735 U00e0		       00 06	   GAP_H      =	6	; height of gap blocks (~width of one PF pixel)
    736 U00e0		       00 a0	   TKERNEL_H  =	NUM_BLOCKS*BLOCK_H + 2*BORDER_H + 2*GAP_H	; = 160
    737 U00e0		       00 20	   LKERNEL_H  =	32	; height of logo/selection
    738 U00e0
    739 U00ff ????				      SEG.U	variables2
    740 U0082					      ORG	Platform+1
    741 U0082
    742 U0082		       00 82	   startOfTitleRAM =	.
    743 U0082							; current selection (has to be 0..x):
    744 U0082		       00 04	   NUM_SEL    =	4
    745 U0082
    746 U0082		       00 00 00 00 selLst     ds	NUM_SEL
    747 U0082		       00 82	   sCave      =	selLst	; 0..3/19 (FINAL_VERSION = A, E, I, M, multiply by 5 to get real number, )
    748 U0082		       00 83	   sLevel     =	selLst+1	; 0..4
    749 U0082		       00 84	   sPlayers   =	selLst+2	; 0..1
    750 U0082		       00 85	   sJoysticks =	selLst+3	; 0..1
    751 U0082		       00 86	   endTitleClear =	.
    752 U0086
    753 U0086							; from here the variables can be cleared
    754 U0086		       00	   titleMode  ds	1	; logo = 0/selection = 1
    755 U0087		       00	   counter    ds	1
    756 U0088		       00	   btnReleased ds	1
    757 U0089		       00	   hmJunior   ds	1	; $f0/$50
    758 U008a							; music vars:
    759 U008a		       00	   noteLen    ds	1
    760 U008b		       00	   noteIdx    ds	1
    761 U008c		       00	   note0      ds	1
    762 U008d		       00	   note1      ds	1
    763 U008e
    764 U008e		       00	   inputBuffer ds	1
    765 U008f		       00	   demoDelay  ds	1
    766 U0090
    767 U0090		       00	   audv0Lo    ds	1
    768 U0091		       00	   audv0Hi    ds	1
    769 U0092		       00	   audv1Lo    ds	1
    770 U0093		       00	   audv1Hi    ds	1
    771 U0094							; offset to compensate early precalculation:
    772 U0094		       00	   audvOfsLo  ds	1
    773 U0095		       00	   audvOfsHi  ds	1
    774 U0096
    775 U0096							; selection vars
    776 U0096		       00	   tmpY       ds	1
    777 U0096		       00 96	   tmpGfx     =	tmpY
    778 U0096		       00 96	   tmpGfxA    =	tmpGfx
    779 U0097		       00	   tmpGfxB    ds	1
    780 U0098
    781 U0098		       00	   loopCntFSS ds	1
    782 U0098		       00 98	   loopCntSel =	loopCntFSS
    783 U0099		       00 00	   ptrGfxA    ds	2
    784 U009b		       00 00	   ptrGfxB    ds	2
    785 U009d
    786 U009d		       00	   selRow     ds	1
    787 U009e
    788 U009e		       00	   audvTmpLo  ds	1	; high values stored in following list
    789 U009f		       00 00 00 00*audV0Lst   ds	(TKERNEL_H + LKERNEL_H)/2	; = 96 bytes
    790 U009f		       00 9f	   audV0LstBtm =	audV0Lst
    791 U009f		       00 af	   audV0LstTop =	audV0Lst + LKERNEL_H/2
    792 U009f		       00 ff	   endOfTitleRAM =	.
    793 U00ff
    794 U00ff							;------------------------------------------------------------------------------
    795 U00ff							;##############################################################################
    796 U00ff							;------------------------------------------------------------------------------
    797 U00ff
    798 U00ff							; NOW THE VERY INTERESTING '3E' RAM BANKS
    799 U00ff							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    800 U00ff
    801 U00ff				   ORIGIN     SET	0
      0 U00ff					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN / RAM_SIZE
      6 U0000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    803 U0000
    804 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    805 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    806 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    807 U0000
    808 U0000		       00 54	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    809 U0000
    810 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    811 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    812 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    813 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    814 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    815 U0000
    816 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    817 U0000							; is that we can use that code to switch between banks, and the system will happily
    818 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    819 U0000
    820 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    821 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    822 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    823 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    824 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    825 U0000
    826 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    827 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    828 U0000							; part of the draw routine *every* scanline (though the system currently uses
    829 U0000							; one colour shared between both players).
    830 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    832 U0000
    833 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    834 U0000							; accessed via the above labels but with the appropriate bank switched in.
    835 U0000
    836 U0000							;------------------------------------------------------------------------------
    837 U0000
    838 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    838 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    838 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    838 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1000				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    838 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    838 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    838 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    841 U1c00					      REPEND
    842 U1c00
    843 U1c00							;------------------------------------------------------------------------------
    844 U1c00							;##############################################################################
    845 U1c00							;------------------------------------------------------------------------------
    846 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN / RAM_SIZE
      6 U2000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    848 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    849 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    851 U2000
    852 U2000							;------------------------------------------------------------------------------
    853 U2000							;##############################################################################
    854 U2000							;------------------------------------------------------------------------------
    855 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN / RAM_SIZE
      6 U2400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    857 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    858 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    860 U2400
    861 U2400							;------------------------------------------------------------------------------
    862 U2400							;##############################################################################
    863 U2400							;------------------------------------------------------------------------------
    864 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_CAVE
      1 U2800 ????				      SEG.U	BANK_DECODE_CAVE
      2 U2800					      ORG	ORIGIN
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_CAVE SET	ORIGIN / RAM_SIZE
      6 U2800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    866 U2800							; VARS DEFINED IN BANK_DECODE_CAVE_SHADOW
    867 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    869 U2800
    870 U2800							;------------------------------------------------------------------------------
    871 U2800							;##############################################################################
    872 U2800							;------------------------------------------------------------------------------
    873 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN / RAM_SIZE
      6 U2c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
    875 U2c00
    876 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    877 U2c00							; position of something that needs to be processed.  These things include anything
    878 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    879 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    880 U2c00							; one for the next processing iteration.
    881 U2c00
    882 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    883 U2c00
    884 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    885 U2c00
    886 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    887 U2c00
    888 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    889 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    890 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    891 U2d80
    892 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    893 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    894 U2e00
    895 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    896 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    897 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    898 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    900 U2e80
    901 U2e80							;------------------------------------------------------------------------------
    902 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN / RAM_SIZE
      6 U3000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    904 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    906 U3000
    907 U3000							;------------------------------------------------------------------------------
    908 U3000
    909 U3000							;		  NEWRAMBANK BANK_OBJSTACKA
    910 U3000
    911 U3000							;
    912 U3000
    913 U3000
    914 U3000							;    ECHO "FREE RAM IN BANK_OBJSTACKA = ", RAM_SIZE - ( * - BANK_START )
    915 U3000
    916 U3000							;		VALIDATE_RAM_SIZE
    917 U3000
    918 U3000							;------------------------------------------------------------------------------
    919 U3000
    920 U3000							;		  NEWRAMBANK BANK_OBJSTACKA2
    921 U3000							; THIS IS A MIRROR OF BANK_OBJSTACKA -- DO NOT MODIFY OR USE!!
    922 U3000							;		  VALIDATE_RAM_SIZE
    923 U3000
    924 U3000							;------------------------------------------------------------------------------
    925 U3000							;##############################################################################
    926 U3000							;------------------------------------------------------------------------------
    927 U3000
    928 U3000							;		  NEWRAMBANK BANK_TITLE_SCREEN
    929 U3000							; VARS DEFINED IN ROM_SHADOW_OF_TITLE_SCREEN
    930 U3000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
    931 U3000							;		  VALIDATE_RAM_SIZE
    932 U3000
    933 U3000
    934 U3000							;------------------------------------------------------------------------------
    935 U3000							;##############################################################################
    936 U3000							;------------------------------------------------------------------------------
    937 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U37a0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN / RAM_SIZE
      6 U3400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    939 U3400
    940 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    941 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    942 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    943 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    944 U3400							; when accessing.
    945 U3400
    946 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    947 U3400							; automatically based on the sizes set in these constants. The board may overlay
    948 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    949 U3400							; we're doing OK.
    950 U3400
    951 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    952 U3400
    953 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    954 U3400
    955 U3400		       00 28	   SIZE_BOARD_X =	40
    956 U3400		       00 16	   SIZE_BOARD_Y =	22
    957 U3400
    958 U3400							; have to precalculate it here, else DASM freaks out:
    959 U3400				   .BOARD_SIZE SET	0
    960 U3400				   .BOARD_LOCATION SET	0
    961 U3400					      REPEAT	SIZE_BOARD_Y
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    961 U3400					      REPEND
    962 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    963 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    964 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    965 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    966 U3400					      ENDIF
    967 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    968 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400
    971 U3400		       03 a0	   SIZE_BOARD =	.BOARD_SIZE
    972 U3400
    973 U3400
    974 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    975 U3400				  -MULTI_BANK_BOARD =	YES
    976 U3400					      ELSE
    977 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    978 U3400					      ENDIF
    979 U3400
    980 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    981 U37a0							; 1024 byte chunks, switching RAM
    982 U37a0							; banks as we go.  In other words,
    983 U37a0							; this overlaps multiple banks!
    984 U37a0
    985 U37a0
    986 U37a0							; free space here (but hard to use)
    987 U37a0							; So we need to calculate where the next free bank is!
    988 U37a0							; TODO: This looks dodgy.  Check..
    989 U37a0
    990 U37a0				   ORIGIN     SET	( * + RAM_SIZE - 1 ) / RAM_SIZE
    991 U37a0				   ORIGIN     SET	ORIGIN * RAM_SIZE
    992 U37a0
    993 U37a0
    994 U37a0
    995 U37a0							;------------------------------------------------------------------------------
    996 U37a0							;##############################################################################
    997 U37a0							;------------------------------------------------------------------------------
    998 U37a0
    999 U37a0							;------------------------------------------------------------------------------
   1000 U37a0
   1001 U37a0							;    IFNCONST MAX_CAVE_SIZE
   1002 U37a0				   MAX_CAVE_SIZE SET	0
   1003 U37a0							;    ENDIF
   1004 U37a0
   1005 U37a0							;    IFNCONST MAX_CAVE_NUMBER
   1006 U37a0				   MAX_CAVE_NUMBER SET	0
   1007 U37a0							;    ENDIF
   1008 U37a0
   1009 U37a0					      MAC	start_cave
   1010 U37a0				   CAVE_START SET	*
   1011 U37a0				   BANK_CAVE_{1} =	_CURRENT_BANK
   1012 U37a0				   CAVE_{1}   SUBROUTINE
   1013 U37a0				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
   1014 U37a0							; ECHO "current MAX_CAVE_NUMBER = ", MAX_CAVE_NUMBER
   1015 U37a0					      ENDM		; {name}
   1016 U37a0
   1017 U37a0
   1018 U37a0					      MAC	end_cave
   1019 U37a0					      .byte	$FF
   1020 U37a0				   CAVE_SIZE_{1} =	* - CAVE_START
   1021 U37a0					      IF	CAVE_SIZE_{1} > MAX_CAVE_SIZE
   1022 U37a0				   MAX_CAVE_SIZE SET	CAVE_SIZE_{1}
   1023 U37a0					      ENDIF
   1024 U37a0					      ENDM		; {name}
   1025 U37a0
   1026 U37a0					      MAC	cave_size
   1027 U37a0					      .byte	{1},{2}
   1028 U37a0					      ENDM		; x, y
   1029 U37a0
   1030 U37a0					      MAC	cave_size_room
   1031 U37a0					      CAVE_SIZE	40, 22
   1032 U37a0					      ENDM
   1033 U37a0
   1034 U37a0					      MAC	cave_size_intermission
   1035 U37a0					      CAVE_SIZE	20, 12
   1036 U37a0					      ENDM
   1037 U37a0
   1038 U37a0					      MAC	stoch
   1039 U37a0					      .byte	{1},{2},{3}
   1040 U37a0					      ENDM		; {character} {x} {y}
   1041 U37a0
   1042 U37a0					      MAC	cave_random
   1043 U37a0					      .byte	{1},{2},{3},{4},{5}
   1044 U37a0					      ENDM		; {1}{2}{3}{4}{5}
   1045 U37a0
   1046 U37a0							;-------------------------------------------------------------------------------
   1047 U37a0							; Define which screens are to be included in assembly. This sets the INCLUSION.
   1048 U37a0							; The ORDERING is defined in a similar table in DecodeCave.asm.
   1049 U37a0
   1050 U37a0					      MAC	include_cave
   1051 U37a0				   CAVE_ACTIVE_{1} SET	0
   1052 U37a0					      ENDM		; {name}
   1053 U37a0					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0 U37a0					      INCLUDE_CAVE	INTRO
      1 U37a0				   CAVE_ACTIVE_INTRO SET	0
      0 U37a0					      INCLUDE_CAVE	ROOMS
      1 U37a0				   CAVE_ACTIVE_ROOMS SET	0
      0 U37a0					      INCLUDE_CAVE	MAZE
      1 U37a0				   CAVE_ACTIVE_MAZE SET	0
      0 U37a0					      INCLUDE_CAVE	BUTTERFLIES
      1 U37a0				   CAVE_ACTIVE_BUTTERFLIES SET	0
      0 U37a0					      INCLUDE_CAVE	GUARDS
      1 U37a0				   CAVE_ACTIVE_GUARDS SET	0
      0 U37a0					      INCLUDE_CAVE	FIREFLY_DENS
      1 U37a0				   CAVE_ACTIVE_FIREFLY_DENS SET	0
      0 U37a0					      INCLUDE_CAVE	AMOEBA
      1 U37a0				   CAVE_ACTIVE_AMOEBA SET	0
      0 U37a0					      INCLUDE_CAVE	ENCHANTED_WALL
      1 U37a0				   CAVE_ACTIVE_ENCHANTED_WALL SET	0
      0 U37a0					      INCLUDE_CAVE	GREED
      1 U37a0				   CAVE_ACTIVE_GREED SET	0
      0 U37a0					      INCLUDE_CAVE	TRACKS
      1 U37a0				   CAVE_ACTIVE_TRACKS SET	0
      0 U37a0					      INCLUDE_CAVE	CROWD
      1 U37a0				   CAVE_ACTIVE_CROWD SET	0
      0 U37a0					      INCLUDE_CAVE	WALLS
      1 U37a0				   CAVE_ACTIVE_WALLS SET	0
      0 U37a0					      INCLUDE_CAVE	APOCALYPSE
      1 U37a0				   CAVE_ACTIVE_APOCALYPSE SET	0
      0 U37a0					      INCLUDE_CAVE	ZIGZAG
      1 U37a0				   CAVE_ACTIVE_ZIGZAG SET	0
      0 U37a0					      INCLUDE_CAVE	FUNNEL
      1 U37a0				   CAVE_ACTIVE_FUNNEL SET	0
      0 U37a0					      INCLUDE_CAVE	ENCHANTED_BOXES
      1 U37a0				   CAVE_ACTIVE_ENCHANTED_BOXES SET	0
      0 U37a0					      INCLUDE_CAVE	INTERMISSION_1
      1 U37a0				   CAVE_ACTIVE_INTERMISSION_1 SET	0
      0 U37a0					      INCLUDE_CAVE	INTERMISSION_2
      1 U37a0				   CAVE_ACTIVE_INTERMISSION_2 SET	0
      0 U37a0					      INCLUDE_CAVE	INTERMISSION_3
      1 U37a0				   CAVE_ACTIVE_INTERMISSION_3 SET	0
      0 U37a0					      INCLUDE_CAVE	INTERMISSION_4
      1 U37a0				   CAVE_ACTIVE_INTERMISSION_4 SET	0
   1074 U37a0					      IF	EASTER_EGG = YES
      0 U37a0					      INCLUDE_CAVE	SPINDIZZY
      1 U37a0				   CAVE_ACTIVE_SPINDIZZY SET	0
   1076 U37a0					      ENDIF
   1077 U37a0				  -	      ELSE
   1078 U37a0				  -	      INCLUDE_CAVE	APOCALYPSE
   1079 U37a0				  -	      INCLUDE_CAVE	FUNNEL
   1080 U37a0					      ENDIF
   1081 U37a0
   1082 U37a0		       00 64	   MAX_CAVENUM EQU	CAVENUM
   1083 U37a0
      0 U37a0					      INCLUDE_CAVE	SELECTION_SCREEN	; This should be the LAST cave, though!
      1 U37a0				   CAVE_ACTIVE_SELECTION_SCREEN SET	0
   1085 U37a0
   1086 U37a0
   1087 U37a0							;--------------------------------------------------------------------------------
   1088 U37a0
   1089 U37a0
   1090 U37a0
   1091 U37a0				   ORIGIN     SET	$00000
   1092 U37a0
   1093 U37a0
   1094 U37a0
   1095 U37a0
   1096 U37a0							; Eight 2K Banks = 16K
   1097 U37a0
------- FILE BANK_MUSIC.asm LEVEL 2 PASS 3
      0 U37a0					      include	"BANK_MUSIC.asm"
      1 U37a0							;------------------------------------------------------------------------------
      2 U37a0							;##############################################################################
      3 U37a0							;------------------------------------------------------------------------------
      4 U37a0
      5 U37a0							; 2K reserved for music.
      6 U37a0
      0 U37a0					      NEWBANK	BANK_MUSIC1
      1  045c ????				      SEG	BANK_MUSIC1
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   BANK_MUSIC1 SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	BANK_MUSIC1
      8  0000
      9  0000							;build datestamp
     10  0000
     11  0000					      IF	DEMO_VERSION = NO
     12  0000		       46 65 62 20*	      .byte.b	"Feb 29 2012"
     13  000b				  -	      ELSE
     14  000b				  -	      .byte	"Jan 18 2014"
     15  000b					      ENDIF
     16  000b
     17  000b					      IF	EMBED_COPYRIGHT = YES
     18  000b		       20 20 20 20*	      ds	80, " "
     19  005b		       54 68 69 73*	      .byte.b	"This Atari 2600 "
     20  006b		       76 65 72 73*	      .byte.b	"version of Bould"
     21  007b		       65 72 20 44*	      .byte.b	"er Dash(R) was p"
     22  008b		       72 6f 67 72*	      .byte.b	"rogrammed by And"
     23  009b		       72 65 77 20*	      .byte.b	"rew Davie and Th"
     24  00ab		       6f 6d 61 73*	      .byte.b	"omas Jentzsch be"
     25  00bb		       74 77 65 65*	      .byte.b	"tween 2003 and 2"
     26  00cb		       30 31 32 2e*	      .byte.b	"012. Boulder Das"
     27  00db		       68 28 52 29*	      .byte.b	"h(R) is a regist"
     28  00eb		       65 72 65 64*	      .byte.b	"ered trademark o"
     29  00fb		       66 20 46 69*	      .byte.b	"f First Star Sof"
     30  010b		       74 77 61 72*	      .byte.b	"tware, Inc. Copy"
     31  011b		       72 69 67 68*	      .byte.b	"right (C)1984-20"
     32  012b		       31 32 20 46*	      .byte.b	"12 First Star So"
     33  013b		       66 74 77 61*	      .byte.b	"ftware, Inc. All"
     34  014b		       20 72 69 67*	      .byte.b	" rights reserved"
     35  015b		       2e 20 54 68*	      .byte.b	". The supporting"
     36  016b		       20 73 6f 66*	      .byte.b	" software, inclu"
     37  017b		       64 69 6e 67*	      .byte.b	"ding the graphic"
     38  018b		       73 20 65 6e*	      .byte.b	"s engine, optmis"
     39  019b		       61 74 69 6f*	      .byte.b	"ation algorithms"
     40  01ab		       2c 20 61 6e*	      .byte.b	", and other code"
     41  01bb		       20 61 6e 64*	      .byte.b	" and logic not p"
     42  01cb		       65 72 74 61*	      .byte.b	"ertaining to the"
     43  01db		       20 42 6f 75*	      .byte.b	" Boulder Dash(R)"
     44  01eb		       20 69 6d 70*	      .byte.b	" implementation,"
     45  01fb		       20 61 72 65*	      .byte.b	" are Copyright ("
     46  020b		       43 29 32 30*	      .byte.b	"C)2012 Andrew Da"
     47  021b		       76 69 65 20*	      .byte.b	"vie and Thomas J"
     48  022b		       65 6e 74 7a*	      .byte.b	"entzsch."
     49  0233					      IF	DEMO_VERSION = NO
     50  0233		       20 54 68 69*	      .byte.b	" This bi"
     51  023b		       6e 61 72 79*	      .byte.b	"nary is not free"
     52  024b		       20 61 6e 64*	      .byte.b	" and may not be "
     53  025b		       73 6f 6c 64*	      .byte.b	"sold, or redistr"
     54  026b		       69 62 75 74*	      .byte.b	"ibuted in any mo"
     55  027b		       64 69 66 69*	      .byte.b	"dified form. "
     56  0288				  -	      ELSE
     57  0288				  -	      .byte	" This 2nd demo version Copyright (C)2014."
     58  0288					      ENDIF
     59  0288		       20 20 20 20*	      ds	80, "	"
     60  02d8					      ENDIF
     61  02d8
     62  02d8							;--------------------------------------------------------------------------
     63  02d8
------- FILE sounds.asm LEVEL 3 PASS 3
      0  02d8					      include	"sounds.asm"	; code and data for the various sounds:
      1  02d8							; Sound TODOs:
      2  02d8							; ? (un)cover cave (not done yet)
      3  02d8							; + initial crack sound
      4  02d8							; + diamond pickup
      5  02d8							; o diamond starts falling (double start bug)
      6  02d8							; + diamond lands
      7  02d8							; o boulder stars falling (double start bug)
      8  02d8							; + boulder lands
      9  02d8							; + boulder is pushed
     10  02d8							; + Rockford moves through soil
     11  02d8							; + Rockford moves through blank
     12  02d8							; + Rockfords digs into soil
     13  02d8							; + magic wall
     14  02d8							; + amoeba
     15  02d8							; + door opens (background flash fixed)
     16  02d8							; + running out of time
     17  02d8							; + bonus points
     18  02d8							; x extra live (no sound, Cosmic Ark effect instead, fix colors)
     19  02d8
     20  02d8							; - BD doku seems wrong, there are sound priorities
     21  02d8							;   -> rework sound system, prioritisize sounds!
     22  02d8
     23  02d8
     24  02d8
     25  02d8		       00 01	   LOW_BONUS_SOUND =	1	; 1 = the bonus points sound goes deeper
     26  02d8		       00 0f	   SND_MASK_LO =	%1111
     27  02d8		       00 f0	   SND_MASK_HI =	%11110000
     28  02d8
     29  02d8							;-----------------------------------------------------------
     30  02d8
     31  02d8					      MAC	start_sound
     32  02d8					      SUBROUTINE
     33  02d8					      lda	newSounds	; 3
     34  02d8					      IF	{1} < 16
     35  02d8					      and	#SND_MASK_LO	; 2
     36  02d8					      cmp	#SOUND_MOVE_SOIL+1	; 2	 overwrite low priority move sounds
     37  02d8					      bcs	.skipNew	; 2/3
     38  02d8					      ELSE
     39  02d8					      and	#SND_MASK_HI	; 2
     40  02d8					      cmp	#(SOUND_MOVE_SOIL+1)<<4	; 2	 overwrite low priority move sounds
     41  02d8					      bcs	.skipNew	; 2/3
     42  02d8							;	  bne	  .skipNew	      ; 2/3
     43  02d8					      ENDIF
     44  02d8					      eor	newSounds	; 3
     45  02d8					      ora	#{1}	; 2
     46  02d8					      sta	newSounds	; 3
     47  02d8				   .skipNew
     48  02d8					      SUBROUTINE
     49  02d8					      ENDM		; = 15
     50  02d8
     51  02d8
     52  02d8							;-----------------------------------------------------------
     53  02d8
     54  02d8					      MAC	start_prio_sound
     55  02d8					      lda	newSounds	; 3
     56  02d8					      IF	{1} < 16
     57  02d8					      and	#<(~SND_MASK_LO)	; 2
     58  02d8					      ELSE
     59  02d8					      and	#<(~SND_MASK_HI)	; 2
     60  02d8					      ENDIF
     61  02d8					      ora	#{1}	; 2
     62  02d8					      sta	newSounds	; 3
     63  02d8					      ENDM		; = 10
     64  02d8
     65  02d8							;-----------------------------------------------------------
     66  02d8
     67  02d8					      MAC	stop_channel
     68  02d8							; only any sound in the channel
     69  02d8					      lda	#0
     70  02d8					      sta	soundIdxLst+{1}
     71  02d8					      sta	AUDV0+{1}
     72  02d8					      ENDM		; {0 or 1}
     73  02d8
     74  02d8							;-----------------------------------------------------------
     75  02d8
     76  02d8					      MAC	stop_sound
     77  02d8							; only stops a given sound the channel
     78  02d8					      lda	#{2}
     79  02d8					      eor	soundIdxLst+{1}
     80  02d8					      bne	.skipStop
     81  02d8					      sta	soundIdxLst+{1}
     82  02d8					      sta	AUDV0+{1}
     83  02d8				   .skipStop
     84  02d8					      ENDM		; {0 or 1, sound offset}
     85  02d8
     86  02d8							;-----------------------------------------------------------
      0  02d8					      DEFINE_SUBROUTINE	StartSound
      1  02d8		       00 00	   BANK_StartSound =	_CURRENT_BANK
      2  02d8					      SUBROUTINE
      3  02d8				   StartSound
     88  02d8							;-----------------------------------------------------------
     89  02d8							; worst case timings:
     90  02d8							; SOIL, DIRT = 82
     91  02d8							; channel0   = 69
     92  02d8							; channel1   = 68
     93  02d8							; channel1   = 80+(1..2*9) (random frequency)
     94  02d8							;-----------------------------------------------------------
     95  02d8							; a = sound idx
     96  02d8							; 1. assign all sounds (except move) to their channels:
     97  02d8
     98  02d8		       a2 01		      ldx	#1	; 2
     99  02da		       c9 20		      cmp	#SOUND_GROUP_HI	; 2
    100  02dc		       90 08		      bcc	.checkChannel0	; 2/3
    101  02de							; channel 1 group sounds get prioritized:
    102  02de		       c5 d6		      cmp	soundIdxLst+1	; 2
    103  02e0		       f0 47		      beq	.skipSound	; 2/3	     avoid restarting the same sound
    104  02e2		       b0 1d		      bcs	.startChannel	; 2/3=12
    105  02e4		       90 43		      bcc	.skipSound	; 3
    106  02e6
    107  02e6				   .checkChannel0		; 7
    108  02e6		       ca		      dex		; 2 =	9
    109  02e7
    110  02e7		       c9 0c		      cmp	#SOUND_GROUP_LO	; 2
    111  02e9		       90 0c		      bcc	.soundFree	; 2/3
    112  02eb		       c5 d5		      cmp	soundIdxLst	; 3	     prio >= current sound?
    113  02ed		       b0 12		      bcs	.startChannel	; 2/3	      yes, overwrite
    114  02ef		       a4 d5		      ldy	soundIdxLst	; 3
    115  02f1		       c0 18		      cpy	#OFSS_EXPLOSION	; 2	     current explosion?
    116  02f3		       b0 34		      bcs	.skipSound	; 2/3	      yes, keep
    117  02f5		       90 0a		      bcc	.startChannel	; 2/3	      no, overwrite
    118  02f7
    119  02f7							; 2. move sound, check for a free channel (1 preferred):
    120  02f7				   .soundFree
    121  02f7		       e8		      inx		; 2
    122  02f8		       a4 d6		      ldy	soundIdxLst+1	; 3	     channel 1 free?
    123  02fa		       f0 05		      beq	.startChannel	; 2/3	      yes, use it
    124  02fc		       ca		      dex		; 2
    125  02fd		       a4 d5		      ldy	soundIdxLst	; 3	     channel 0 free?
    126  02ff		       d0 28		      bne	.skipSound	; 2/3=14     no, skip sound
    127  0301
    128  0301							; 3. create new sound:
    129  0301				   .startChannel		;13/14/21/27 (ch1, ch0, dirt/soil)
    130  0301		       95 d5		      sta	soundIdxLst,x	; 4
    131  0303		       a8		      tay		; 2 =	6
    132  0304
    133  0304				   RestartSound
    134  0304							; x = sound channel 0/1
    135  0304							; y = sound index
    136  0304		       a9 00		      lda	#0	; 2
    137  0306		       95 d9		      sta	decayTimeLst,x	; 4
    138  0308		       95 59		      sta	AUDV0,x	; 4
    139  030a		       b9 02 f4 	      lda	SoundTbl+OFS_RND_FREQ,y	; 4
    140  030d		       f0 0a		      beq	.fixedFreq	; 2/3=16
    141  030f
    142  030f							; increase base frequency by random value:
    143  030f		       a5 87		      lda	rnd	;NEXT_RANDOM		 ; 3
    144  0311		       29 0e		      and	#%1110	; 2 =	5    up to 8 different variations
    145  0313				   .reTry
    146  0313		       4a		      lsr		; 2
    147  0314		       d9 02 f4 	      cmp	SoundTbl+OFS_RND_FREQ,y	; 4
    148  0317		       b0 fa		      bcs	.reTry	; 2/3= 8
    149  0319				   .fixedFreq
    150  0319		       18		      clc		; 2
    151  031a		       79 01 f4 	      adc	SoundTbl+OFS_FREQ,y	; 4
    152  031d		       95 57		      sta	AUDF0,x	; 4
    153  031f		       b9 00 f4 	      lda	SoundTbl+OFS_DIST,y	; 4
    154  0322		       95 55		      sta	AUDC0,x	; 4
    155  0324		       b9 03 f4 	      lda	SoundTbl+OFS_DECAY,y	; 4
    156  0327		       95 d7		      sta	decayIdxLst,x	; 4 = 26
    157  0329
    158  0329				   .skipSound
    159  0329		       60		      rts		; 6 =	6
    160  032a
    161  032a							;-----------------------------------------------------------
    162  032a
    163  032a							;ManActionSounds
    164  032a							;		  .byte 1 ;<manStartup		  ; 0		  sounds
    165  032a							;		  .byte 1 ;<normalMan		  ; 1
    166  032a							;		  .byte 1 ;<deadMan		  ; 2
    167  032a							;		  .byte 1 ;<waitingMan		  ; 3
    168  032a							;		  .byte 1 ;<waitingManPress	  ; 4
    169  032a							;		  .byte 1 ;<waitingManNoTim	  ; 5
    170  032a							;		  .byte 1 ;<waitingManPressNoTim  ; 6
    171  032a							;		  .byte 0 ;<nextLevelMan	  ; 7
    172  032a							;		  .byte 1 ;<BonusCountdownStart   ; 8
    173  032a							;		  .byte 1 ;<BonusCountdownRun	  ; 9
    174  032a
    175  032a
    176  032a							;-----------------------------------------------------------
      0  032a					      DEFINE_SUBROUTINE	PlaySounds
      1  032a		       00 00	   BANK_PlaySounds =	_CURRENT_BANK
      2  032a					      SUBROUTINE
      3  032a				   PlaySounds
    178  032a							;-----------------------------------------------------------
    179  032a
    180  032a		       a4 a3		      ldy	ManMode	; 3	     new sounds allowed?
    181  032c		       c0 07		      cpy	#MANMODE_NEXTLEVEL	; 2
    182  032e		       f0 18		      beq	.skipHi	; 2/3
    183  0330
    184  0330		       a5 db		      lda	newSounds	; 3
    185  0332		       29 0f		      and	#SND_MASK_LO	; 2
    186  0334		       f0 05		      beq	.skipLo	; 2/3	     no new low sound was triggered
    187  0336		       0a		      asl		; 2
    188  0337		       0a		      asl		; 2
    189  0338		       20 d8 f2 	      jsr	StartSound	; 6
    190  033b				   .skipLo
    191  033b		       a5 db		      lda	newSounds	; 3
    192  033d		       29 f0		      and	#SND_MASK_HI	; 2
    193  033f		       f0 07		      beq	.skipHi	; 2/3	     no new high sound was triggered
    194  0341		       4a		      lsr		; 2
    195  0342		       4a		      lsr		; 2
    196  0343		       69 1c		      adc	#<(SoundTblHi-SoundTbl-4)
    197  0345		       20 d8 f2 	      jsr	StartSound	; 6
    198  0348				   .skipHi
    199  0348		       a9 00		      lda	#0	; 2	     prepare for new triggers
    200  034a		       85 db		      sta	newSounds	; 3
    201  034c
    202  034c							; fall through
    203  034c
    204  034c							; The issue here is that this code writes to channels which are not in use.
    205  034c
      0  034c					      NEXT_RANDOM		; this makes sure rnd is updated each frame, also used for other things!
      1  034c
      2  034c		       a5 87		      lda	rnd
      3  034e		       4a		      lsr
      4  034f					      IFCONST	rndHi
      5  034f		       66 88		      ror	rndHi
      6  0351					      ENDIF
      7  0351		       90 02		      bcc	.skipEOR
      8  0353		       49 b4		      eor	#RND_EOR_VAL
      9  0355				   .skipEOR
     10  0355		       85 87		      sta	rnd
    207  0357
    208  0357		       00 e3	   .freqVibrato =	tmpVar	; @Andrew: replace with whatever is available
    209  0357							; called once/frame
    210  0357		       a2 01		      ldx	#1
    211  0359				   .loopSound
    212  0359
    213  0359		       b5 d5		      lda	soundIdxLst,x
    214  035b		       f0 4c		      beq	.nextSound	; don't write to inactive channels! IMPORTANT SO MUSIC CAN CO-EXIST
    215  035d
    216  035d		       c9 1c		      cmp	#OFSS_BONUS_POINTS
    217  035f		       f0 1d		      beq	.bonusPointsSound	;
    218  0361
    219  0361		       b5 d9		      lda	decayTimeLst,x
    220  0363		       d0 42		      bne	.contNote
    221  0365							; start next note:
    222  0365		       b4 d7		      ldy	decayIdxLst,x
    223  0367		       b9 b3 f3 	      lda	DecayTbl,y
    224  036a		       95 59		      sta	AUDV0,x
    225  036c		       d0 31		      bne	.contSound
    226  036e							; current sound is over, now check what to do next:
    227  036e		       b4 d5		      ldy	soundIdxLst,x
    228  0370		       c0 1c		      cpy	#OFSS_BONUS_POINTS
    229  0372		       f0 0a		      beq	.bonusPointsSound	;
    230  0374		       b9 00 f4 	      lda	SoundTbl+OFS_DIST,y	;   loop sound?
    231  0377		       10 34		      bpl	.endSound	;
    232  0379		       20 04 f3 	      jsr	RestartSound
    233  037c		       d0 db		      bne	.loopSound
    234  037e
    235  037e							; special handling for score countdown sound:
    236  037e				   .bonusPointsSound
    237  037e		       a5 d7		      lda	soundBonusPts
    238  0380		       a8		      tay
    239  0381		       29 03		      and	#$03
    240  0383		       49 03		      eor	#$03
    241  0385		       85 e3		      sta	.freqVibrato
    242  0387		       98		      tya
    243  0388		       4a		      lsr
    244  0389		       4a		      lsr
    245  038a		       4a		      lsr
    246  038b		       38		      sec		; frequency divider:
    247  038c		       e5 e3		      sbc	.freqVibrato	; 1,2,3,4, 1,2,3,4, 2,3,4,5...
    248  038e		       85 57		      sta	AUDF0	; ...28,29,30,31, 28,29,30,31
    249  0390		       a9 07		      lda	#VOL_SOUND_BONUS
    250  0392		       85 59		      sta	AUDV0
    251  0394							;		  cpy	  #MAX_SOUND_BONUS-1
    252  0394							;		  bcc	  .skipReset
    253  0394		       98		      tya
    254  0395		       d0 08		      bne	.skipReset
    255  0397					      IF	LOW_BONUS_SOUND
    256  0397		       a0 06		      ldy	#DIST_DIV31
    257  0399		       84 55		      sty	AUDC0
    258  039b		       a0 37		      ldy	#$38-1
    259  039d				  -	      ELSE
    260  039d				  -	      ldy	#MIN_SOUND_BONUS-1
    261  039d					      ENDIF
    262  039d		       84 d7		      sty	soundBonusPts	; = decayIdxLst !
    263  039f				   .skipReset
    264  039f							;		  lda	  #1<<4 		  ; -> decayTimeLst,x = 1
    265  039f
    266  039f							; continue with normal sounds:
    267  039f				   .contSound
    268  039f		       4a		      lsr
    269  03a0		       4a		      lsr
    270  03a1		       4a		      lsr
    271  03a2		       4a		      lsr
    272  03a3		       95 d9		      sta	decayTimeLst,x
    273  03a5		       f6 d7		      inc	decayIdxLst,x
    274  03a7				   .contNote
    275  03a7		       d6 d9		      dec	decayTimeLst,x
    276  03a9				   .nextSound
    277  03a9		       ca		      dex
    278  03aa		       10 ad		      bpl	.loopSound
    279  03ac		       60		      rts
    280  03ad				   .endSound
    281  03ad		       a9 00		      lda	#0	; THIS FIXES THE SOUNDS NOT 'STOPPING' -- A was NOT 0 as commented below :)
    282  03af		       95 d5		      sta	soundIdxLst,x	; a = 0!
    283  03b1		       f0 f6		      beq	.nextSound
    284  03b3
    285  03b3
    286  03b3							;-----------------------------------------------------------
    287  03b3							; S O U N D - D A T A
    288  03b3							;-----------------------------------------------------------
    289  03b3
    290  03b3		       00 08	   DIST_NOISE =	$08
    291  03b3		       00 04	   DIST_DIV2  =	$04	; 15720..491 Hz
    292  03b3		       00 0c	   DIST_DIV6  =	$0c	;  5240..164 Hz
    293  03b3		       00 06	   DIST_DIV31 =	$06	;  1014.. 32 Hz
    294  03b3							;DIST_DIV93	  = $0e ; unused
    295  03b3
    296  03b3		       00 80	   LOOP_SOUND =	$80
    297  03b3
    298  03b3		       00 00	   OFS_DIST   =	0
    299  03b3		       00 01	   OFS_FREQ   =	1
    300  03b3		       00 02	   OFS_RND_FREQ =	2
    301  03b3		       00 03	   OFS_DECAY  =	3
    302  03b3
    303  03b3		       00 20	   MIN_SOUND_BONUS =	$20	;$08
    304  03b3		       01 00	   MAX_SOUND_BONUS =	$100	;$e8
    305  03b3		       00 07	   VOL_SOUND_BONUS =	$07
    306  03b3
    307  03b3							;Note: The ADSR values documented at www.elmerproductions.com/sp/peterb
    308  03b3							;  are sometimes not matching what I hear when playing the original
    309  03b3							;  Also be base volume is not documented, therefore I assume 15 here. If the
    310  03b3							;  result is too loud the decays have to be adjusted.
    311  03b3				   DecayTbl
    312  03b3		       00		      .byte.b	$00
    313  03b4				   DecayMove		; 24/12ms = 1/1
    314  03b4		       12 14 00 	      .byte.b	$12, $14, $00
    315  03b7				   DecayExplosion		; 8/2400ms = 1/144
    316  03b7		       15		      .byte.b	$15	;  1
    317  03b8							; Vol: 10, Len: 144
    318  03b8		       5a		      .byte.b	$5a	;  5
    319  03b9		       59		      .byte.b	$59	;  5
    320  03ba		       48		      .byte.b	$48	;  4
    321  03bb		       57		      .byte.b	$57	;  5
    322  03bc		       56		      .byte.b	$56	;  5
    323  03bd		       55		      .byte.b	$55	;  5
    324  03be		       84		      .byte.b	$84	;  8
    325  03bf		       b3		      .byte.b	$b3	; 11
    326  03c0		       f2 62		      .byte.b	$f2, $62	; 21
    327  03c2		       f1		      .byte.b	$f1	;, $f1, $f1, $f1, $f1 ; 75   shortened!
    328  03c3		       00		      .byte.b	$00
    329  03c4				   DecayDiamondPickup		; 2/6ms??  != 1/30
    330  03c4				   DecayBoulder
    331  03c4							; Vol: 10, Len: 30
    332  03c4		       1a		      .byte.b	$1a	;  1
    333  03c5		       19		      .byte.b	$19	;  1
    334  03c6		       18		      .byte.b	$18	;  1
    335  03c7		       17		      .byte.b	$17	;  1
    336  03c8		       16		      .byte.b	$16	;  1
    337  03c9		       15		      .byte.b	$15	;  1
    338  03ca		       24		      .byte.b	$24	;  2
    339  03cb		       23		      .byte.b	$23	;  2
    340  03cc		       42		      .byte.b	$42	;  4
    341  03cd		       f1 11		      .byte.b	$f1, $11	; 16
    342  03cf		       00		      .byte.b	$00
    343  03d0				   DecayDiamondFalling		; 2/6+6ms??  != 1/30
    344  03d0		       13		      .byte.b	$13	;  1
    345  03d1							; Vol: 7, Len: 30
    346  03d1		       17		      .byte.b	$17	;  1
    347  03d2		       26		      .byte.b	$26	;  2
    348  03d3		       15		      .byte.b	$15	;  1
    349  03d4		       24		      .byte.b	$24	;  2
    350  03d5		       23		      .byte.b	$23	;  2
    351  03d6		       42		      .byte.b	$42	;  4
    352  03d7		       f1 31		      .byte.b	$f1, $31	; 18
    353  03d9		       00		      .byte.b	$00
    354  03da				   DecayAmoeba		; 24/??ms
    355  03da							;    .byte   $12, $13, $12, $00
    356  03da		       11 12 13 00	      .byte.b	$11, $12, $13, $00
    357  03de				   DecayMagic		;  2/12ms = 0/1
    358  03de		       13 00		      .byte.b	$13, $00
    359  03e0				   DecayCrack		; 24/750ms = 2/45
    360  03e0		       15		      .byte.b	$15	;  1
    361  03e1							; Vol: 10, Len: 45
    362  03e1		       1a		      .byte.b	$1a	;  1
    363  03e2		       29		      .byte.b	$29	;  2
    364  03e3		       28		      .byte.b	$28	;  2
    365  03e4		       17		      .byte.b	$17	;  1
    366  03e5		       26		      .byte.b	$26	;  2
    367  03e6		       15		      .byte.b	$15	;  1
    368  03e7		       34		      .byte.b	$34	;  3
    369  03e8		       33		      .byte.b	$33	;  3
    370  03e9		       62		      .byte.b	$62	;  6
    371  03ea		       f1 91		      .byte.b	$f1, $91	; 24
    372  03ec		       00		      .byte.b	$00
    373  03ed							;DecayUncover:       ; 2/168/??ms = 0/10
    374  03ed							;    .byte   $1a		      ;  1
    375  03ed							;    .byte   $19		      ;  1
    376  03ed							;    .byte   $18		      ;  1
    377  03ed							;    .byte   $17		      ;  1
    378  03ed							;    .byte   $16		      ;  1
    379  03ed							;    .byte   $15		      ;  1
    380  03ed							;    .byte   $24		      ;  2
    381  03ed							;    .byte   $23		      ;  2
    382  03ed							;    .byte   $42		      ;  4
    383  03ed							;    .byte   $f1, $11		      ; 16
    384  03ed							;    .byte   $00
    385  03ed				   DecayTime		; 2/1500ms = 1/90
    386  03ed		       15		      .byte.b	$15	;  1
    387  03ee							; Vol: 10, Len: 90
    388  03ee		       3a		      .byte.b	$3a	;  3
    389  03ef		       39		      .byte.b	$39	;  3
    390  03f0		       38		      .byte.b	$38	;  3
    391  03f1		       37		      .byte.b	$37	;  3
    392  03f2		       36		      .byte.b	$36	;  3
    393  03f3		       35		      .byte.b	$35	;  3
    394  03f4		       54		      .byte.b	$54	;  5
    395  03f5		       73		      .byte.b	$73	;  7
    396  03f6		       d2		      .byte.b	$d2	; 13
    397  03f7		       f1 f1 f1 21	      .byte.b	$f1, $f1, $f1, $21	; 47
    398  03fb		       00		      .byte.b	$00
    399  03fc
    400  0400		       00 00 00 00	      ALIGN	256
    401  0400
    402  0400							;Note: The exact NOISE base frequency is not working. Therefore I assume a base
    403  0400							; frequency of 2620 HZ (31440/6) after comparing the sounds with the original.
    404  0400				   SoundTbl
    405  0400		       00		      .byte.b	0
    406  0401		       00 00		      .byte.b	0, 0
    407  0403		       00		      .byte.b	0
    408  0403		       00 04	   OFSS_MOVE_BLANK =	. - SoundTbl
    409  0404		       08		      .byte.b	DIST_NOISE
    410  0405		       02 00		      .byte.b	2, 0	; ~873 Hz (vs. 827)
    411  0407		       01		      .byte.b	DecayMove-DecayTbl
    412  0407		       00 08	   OFSS_MOVE_SOIL =	. - SoundTbl
    413  0408		       08		      .byte.b	DIST_NOISE
    414  0409		       00 00		      .byte.b	0, 0	; ~2620 Hz (vs. 2576)
    415  040b		       01		      .byte.b	DecayMove-DecayTbl
    416  040c
    417  040c
    418  040c							;Sounds of group LO belong to channel 0. If a new sound is requested, this
    419  040c							; overwrites existing sounds:
    420  040c		       00 0c	   SOUND_GROUP_LO =	. - SoundTbl
    421  040c
    422  040c		       00 0c	   OFSS_BOULDER =	. - SoundTbl
    423  040c		       08		      .byte.b	DIST_NOISE
    424  040d		       11 00		      .byte.b	17, 0	; ~146 Hz (vs. 143)
    425  040f		       11		      .byte.b	DecayBoulder-DecayTbl
    426  040f		       00 10	   OFSS_DIAMOND_PICKUP =	. - SoundTbl
    427  0410		       0c		      .byte.b	DIST_DIV6
    428  0411		       10 00		      .byte.b	16, 0	; 308 Hz
    429  0413		       11		      .byte.b	DecayDiamondPickup-DecayTbl
    430  0413		       00 14	   OFSS_DIAMOND_FALLING =	. - SoundTbl
    431  0414		       04		      .byte.b	DIST_DIV2
    432  0415		       03 05		      .byte.b	3, 5	; 1965..3930 Hz
    433  0417		       1d		      .byte.b	DecayDiamondFalling-DecayTbl
    434  0417		       00 18	   OFSS_EXPLOSION =	. - SoundTbl
    435  0418		       08		      .byte.b	DIST_NOISE
    436  0419		       07 00		      .byte.b	7, 0	; ~328 Hz (vs. 315)
    437  041b		       04		      .byte.b	DecayExplosion-DecayTbl
    438  041b		       00 1c	   OFSS_BONUS_POINTS =	. - SoundTbl
    439  041c							; at the end of each level, the time is counted down 30s/frame,
    440  041c							; during that period, this sound it played
    441  041c							; it last for up to
    442  041c							; Note: the last 10s (= 20 frames) the timer sound is played
    443  041c		       0c		      .byte.b	DIST_DIV6
    444  041d		       00 00		      .byte.b	0, 0	; unused (vs. 3246..164)
    445  041f		       20		      .byte.b	MIN_SOUND_BONUS	; here the inital frequency divider is set!
    446  0420
    447  0420
    448  0420							;Sounds of group HI belong to channel 1. If a new sound is requested, this
    449  0420							; only overwrites existing sounds if it has higher priority (index).
    450  0420		       00 20	   SOUND_GROUP_HI =	. - SoundTbl
    451  0420
    452  0420				   SoundTblHi
    453  0420		       00 20	   OFFS_HI    =	. - SoundTbl
    454  0420
    455  0420		       00 20	   OFSS_MOVE_BLANK_HI =	. - SoundTbl
    456  0420		       08		      .byte.b	DIST_NOISE
    457  0421		       02 00		      .byte.b	2, 0	; ~873 Hz (vs. 827)
    458  0423		       01		      .byte.b	DecayMove-DecayTbl
    459  0423		       00 24	   OFSS_MOVE_SOIL_HI =	. - SoundTbl
    460  0424		       08		      .byte.b	DIST_NOISE
    461  0425		       00 00		      .byte.b	0, 0	; ~2620 Hz (vs. 2576)
    462  0427		       01		      .byte.b	DecayMove-DecayTbl
    463  0427		       00 28	   OFSS_AMOEBA =	. - SoundTbl
    464  0428		       86		      .byte.b	DIST_DIV31|LOOP_SOUND
    465  0429		       04 05		      .byte.b	4, 5	; 101..203 Hz
    466  042b		       27		      .byte.b	DecayAmoeba-DecayTbl
    467  042b		       00 2c	   OFSS_MAGIC_WALL =	. - SoundTbl
    468  042c		       84		      .byte.b	DIST_DIV2|LOOP_SOUND
    469  042d		       05 03		      .byte.b	5, 3	; 1965..2620 Hz
    470  042f		       2b		      .byte.b	DecayMagic-DecayTbl
    471  042f		       00 30	   OFSS_CRACK =	. - SoundTbl
    472  0430		       08		      .byte.b	DIST_NOISE
    473  0431		       03 00		      .byte.b	3, 0	; ~655 Hz (vs. 737)
    474  0433		       2d		      .byte.b	DecayCrack-DecayTbl
    475  0434							;OFSS_UNCOVER		 = . - SoundTbl
    476  0434							;    .byte   DIST_DIV2|LOOP_SOUND
    477  0434							;    .byte   4, 6    ; 1572..3930 Hz (vs. 1561..3543)
    478  0434							;    .byte   DecayUncover-DecayTbl
    479  0434		       00 34	   OFSS_TIME_9 =	. - SoundTbl
    480  0434		       0c		      .byte.b	DIST_DIV6
    481  0435		       0b 00		      .byte.b	11, 0	; 437 Hz (vs. 468)
    482  0437		       3a		      .byte.b	DecayTime-DecayTbl
    483  0437		       00 38	   OFSS_TIME_8 =	. - SoundTbl
    484  0438		       0c		      .byte.b	DIST_DIV6
    485  0439		       0a 00		      .byte.b	10, 0	; 476 Hz (vs. 484)
    486  043b		       3a		      .byte.b	DecayTime-DecayTbl
    487  043b		       00 3c	   OFSS_TIME_7 =	. - SoundTbl
    488  043c		       04		      .byte.b	DIST_DIV2
    489  043d		       1f 00		      .byte.b	31, 0	; 491 Hz (vs. 500)
    490  043f		       3a		      .byte.b	DecayTime-DecayTbl
    491  043f		       00 40	   OFSS_TIME_6 =	. - SoundTbl
    492  0440		       04		      .byte.b	DIST_DIV2
    493  0441		       1e 00		      .byte.b	30, 0	; 507 Hz (vs. 515)
    494  0443		       3a		      .byte.b	DecayTime-DecayTbl
    495  0443		       00 44	   OFSS_TIME_5 =	. - SoundTbl
    496  0444		       04		      .byte.b	DIST_DIV2
    497  0445		       1d 00		      .byte.b	29, 0	; 524 Hz (vs. 531)
    498  0447		       3a		      .byte.b	DecayTime-DecayTbl
    499  0447		       00 48	   OFSS_TIME_4 =	. - SoundTbl
    500  0448		       04		      .byte.b	DIST_DIV2
    501  0449		       1c 00		      .byte.b	28, 0	; 542 Hz (vs. 546)
    502  044b		       3a		      .byte.b	DecayTime-DecayTbl
    503  044b		       00 4c	   OFSS_TIME_3 =	. - SoundTbl
    504  044c		       04		      .byte.b	DIST_DIV2
    505  044d		       1b 00		      .byte.b	27, 0	; 561 Hz (vs. 562)
    506  044f		       3a		      .byte.b	DecayTime-DecayTbl
    507  044f		       00 50	   OFSS_TIME_2 =	. - SoundTbl
    508  0450		       04		      .byte.b	DIST_DIV2
    509  0451		       1a 00		      .byte.b	26, 0	; 582 Hz (vs. 578)
    510  0453		       3a		      .byte.b	DecayTime-DecayTbl
    511  0453		       00 54	   OFSS_TIME_1 =	. - SoundTbl
    512  0454		       04		      .byte.b	DIST_DIV2
    513  0455		       19 00		      .byte.b	25, 0	; 605 Hz (vs. 593)
    514  0457		       3a		      .byte.b	DecayTime-DecayTbl
    515  0457		       00 58	   OFSS_TIME_0 =	. - SoundTbl
    516  0458		       04		      .byte.b	DIST_DIV2
    517  0459		       18 00		      .byte.b	24, 0	; 629 Hz (vs. 609)
    518  045b		       3a		      .byte.b	DecayTime-DecayTbl
    519  045c
    520  045c
    521  045c							; special low priority:
    522  045c		       00 01	   SOUND_MOVE_BLANK =	OFSS_MOVE_BLANK / 4
    523  045c		       00 02	   SOUND_MOVE_SOIL =	OFSS_MOVE_SOIL / 4
    524  045c							; group lo:
    525  045c		       00 03	   SOUND_BOULDER =	OFSS_BOULDER / 4
    526  045c		       00 06	   SOUND_EXPLOSION =	OFSS_EXPLOSION / 4
    527  045c		       00 04	   SOUND_DIAMOND_PICKUP =	OFSS_DIAMOND_PICKUP / 4
    528  045c		       00 05	   SOUND_DIAMOND_FALLING =	OFSS_DIAMOND_FALLING / 4
    529  045c		       00 07	   SOUND_BONUS_POINTS =	OFSS_BONUS_POINTS / 4
    530  045c							; group hi:
    531  045c
    532  045c		       00 30	   SOUND_AMOEBA =	(OFSS_AMOEBA - OFFS_HI) * 4 + $10
    533  045c		       00 40	   SOUND_MAGIC_WALL =	(OFSS_MAGIC_WALL - OFFS_HI) * 4 + $10
    534  045c		       00 50	   SOUND_CRACK =	(OFSS_CRACK - OFFS_HI) * 4 + $10
    535  045c		       00 60	   SOUND_TIME_9 =	(OFSS_TIME_9 - OFFS_HI) * 4 + $10
    536  045c		       00 70	   SOUND_TIME_8 =	(OFSS_TIME_8 - OFFS_HI) * 4 + $10
    537  045c		       00 80	   SOUND_TIME_7 =	(OFSS_TIME_7 - OFFS_HI) * 4 + $10
    538  045c		       00 90	   SOUND_TIME_6 =	(OFSS_TIME_6 - OFFS_HI) * 4 + $10
    539  045c		       00 a0	   SOUND_TIME_5 =	(OFSS_TIME_5 - OFFS_HI) * 4 + $10
    540  045c		       00 b0	   SOUND_TIME_4 =	(OFSS_TIME_4 - OFFS_HI) * 4 + $10
    541  045c		       00 c0	   SOUND_TIME_3 =	(OFSS_TIME_3 - OFFS_HI) * 4 + $10
    542  045c		       00 d0	   SOUND_TIME_2 =	(OFSS_TIME_2 - OFFS_HI) * 4 + $10
    543  045c		       00 e0	   SOUND_TIME_1 =	(OFSS_TIME_1 - OFFS_HI) * 4 + $10
    544  045c		       00 f0	   SOUND_TIME_0 =	(OFSS_TIME_0 - OFFS_HI) * 4 + $10
------- FILE BANK_MUSIC.asm
     65  045c
      0  045c					      CHECK_BANK_SIZE	"BANK_MUSIC1"
      1  045c		       04 5c	   .TEMP      =	* - BANK_START
 BANK_MUSIC1 (2K) SIZE =  $45c , FREE= $3a4
      2  045c					      ECHO	"BANK_MUSIC1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  045c				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  045c				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  045c				  -	      ERR
      6  045c					      endif
     67  045c
     68  045c							;------------------------------------------------------------------------------
     69  045c							;##############################################################################
     70  045c							;------------------------------------------------------------------------------
     71  045c
     72  045c
------- FILE ./notBoulderDash.asm
------- FILE 48x128.asm LEVEL 2 PASS 3
      0  045c					      include	"48x128.asm"
      1  045c
      2  045c							;  IF FINAL_VERSION = NO
      3  045c							;COPYTIMESTART       = 29		  ; = 0.5s
      4  045c							;  ELSE
      5  045c		       00 e4	   COPYTIMESTART =	228	; = 4.0s (4*60/276*262)
      6  045c							;  ENDIF
      7  045c		       00 0e	   COPYCOLOUR =	WHITE
      8  045c
      9  045c							;------------------------------------------------------------------------
     10  045c
      0  045c					      NEWBANK	COPYRIGHT_BANK
      1  0ff9 ????				      SEG	COPYRIGHT_BANK
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   COPYRIGHT_BANK SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	COPYRIGHT_BANK
     12  0800
------- FILE copyright.asm LEVEL 3 PASS 3
      0  0800					      include	"copyright.asm"
      1  0800							; BANK00.asm
      2  0800							; Created by Banker v1.00
      3  0800
      4  0800							; Sprite set.	Each line is a single sprite, 128 bytes deep, defined bottom-up
      5  0800
      6  0800							; This bank contains 3 frames, consisting of 6 sprites.
      7  0800
      8  0800					      ALIGN	256
      9  0800				   CopyrightNotice
     10  0800		       02		      .byte.b	%00000010
     11  0801		       02		      .byte.b	%00000010
     12  0802		       02		      .byte.b	%00000010
     13  0803		       02		      .byte.b	%00000010
     14  0804		       03		      .byte.b	%00000011
     15  0805		       02		      .byte.b	%00000010
     16  0806		       00		      .byte.b	%00000000
     17  0807		       00		      .byte.b	%00000000
     18  0808		       00		      .byte.b	%00000000
     19  0809		       00		      .byte.b	%00000000
     20  080a		       01		      .byte.b	%00000001
     21  080b		       01		      .byte.b	%00000001
     22  080c		       01		      .byte.b	%00000001
     23  080d		       01		      .byte.b	%00000001
     24  080e		       01		      .byte.b	%00000001
     25  080f		       00		      .byte.b	%00000000
     26  0810		       00		      .byte.b	%00000000
     27  0811		       00		      .byte.b	%00000000
     28  0812		       00		      .byte.b	%00000000
     29  0813		       00		      .byte.b	%00000000
     30  0814		       e3		      .byte.b	%11100011
     31  0815		       94		      .byte.b	%10010100
     32  0816		       14		      .byte.b	%00010100
     33  0817		       14		      .byte.b	%00010100
     34  0818		       62		      .byte.b	%01100010
     35  0819		       81		      .byte.b	%10000001
     36  081a		       90		      .byte.b	%10010000
     37  081b		       60		      .byte.b	%01100000
     38  081c		       00		      .byte.b	%00000000
     39  081d		       00		      .byte.b	%00000000
     40  081e		       02		      .byte.b	%00000010
     41  081f		       02		      .byte.b	%00000010
     42  0820		       02		      .byte.b	%00000010
     43  0821		       02		      .byte.b	%00000010
     44  0822		       03		      .byte.b	%00000011
     45  0823		       02		      .byte.b	%00000010
     46  0824		       02		      .byte.b	%00000010
     47  0825		       07		      .byte.b	%00000111
     48  0826		       00		      .byte.b	%00000000
     49  0827		       00		      .byte.b	%00000000
     50  0828		       38		      .byte.b	%00111000
     51  0829		       44		      .byte.b	%01000100
     52  082a		       9a		      .byte.b	%10011010
     53  082b		       a2		      .byte.b	%10100010
     54  082c		       a2		      .byte.b	%10100010
     55  082d		       92		      .byte.b	%10010010
     56  082e		       44		      .byte.b	%01000100
     57  082f		       38		      .byte.b	%00111000
     58  0830		       00		      .byte.b	%00000000
     59  0831		       00		      .byte.b	%00000000
     60  0832		       00		      .byte.b	%00000000
     61  0833		       e3		      .byte.b	%11100011
     62  0834		       94		      .byte.b	%10010100
     63  0835		       14		      .byte.b	%00010100
     64  0836		       14		      .byte.b	%00010100
     65  0837		       62		      .byte.b	%01100010
     66  0838		       81		      .byte.b	%10000001
     67  0839		       90		      .byte.b	%10010000
     68  083a		       60		      .byte.b	%01100000
     69  083b		       00		      .byte.b	%00000000
     70  083c		       04		      .byte.b	%00000100
     71  083d		       32		      .byte.b	%00110010
     72  083e		       4a		      .byte.b	%01001010
     73  083f		       4a		      .byte.b	%01001010
     74  0840		       4a		      .byte.b	%01001010
     75  0841		       2a		      .byte.b	%00101010
     76  0842		       17		      .byte.b	%00010111
     77  0843		       02		      .byte.b	%00000010
     78  0844		       01		      .byte.b	%00000001
     79  0845		       00		      .byte.b	%00000000
     80  0846		       00		      .byte.b	%00000000
     81  0847		       14		      .byte.b	%00010100
     82  0848		       24		      .byte.b	%00100100
     83  0849		       24		      .byte.b	%00100100
     84  084a		       24		      .byte.b	%00100100
     85  084b		       26		      .byte.b	%00100110
     86  084c		       75		      .byte.b	%01110101
     87  084d		       20		      .byte.b	%00100000
     88  084e		       20		      .byte.b	%00100000
     89  084f		       00		      .byte.b	%00000000
     90  0850		       00		      .byte.b	%00000000
     91  0851		       21		      .byte.b	%00100001
     92  0852		       22		      .byte.b	%00100010
     93  0853		       23		      .byte.b	%00100011
     94  0854		       22		      .byte.b	%00100010
     95  0855		       32		      .byte.b	%00110010
     96  0856		       29		      .byte.b	%00101001
     97  0857		       00		      .byte.b	%00000000
     98  0858		       00		      .byte.b	%00000000
     99  0859		       00		      .byte.b	%00000000
    100  085a		       00		      .byte.b	%00000000
    101  085b		       00		      .byte.b	%00000000
    102  085c		       00		      .byte.b	%00000000
    103  085d		       00		      .byte.b	%00000000
    104  085e		       00		      .byte.b	%00000000
    105  085f		       00		      .byte.b	%00000000
    106  0860		       00		      .byte.b	%00000000
    107  0861		       00		      .byte.b	%00000000
    108  0862		       00		      .byte.b	%00000000
    109  0863		       00		      .byte.b	%00000000
    110  0864		       00		      .byte.b	%00000000
    111  0865		       00		      .byte.b	%00000000
    112  0866		       00		      .byte.b	%00000000
    113  0867		       00		      .byte.b	%00000000
    114  0868		       00		      .byte.b	%00000000
    115  0869		       00		      .byte.b	%00000000
    116  086a		       00		      .byte.b	%00000000
    117  086b		       00		      .byte.b	%00000000
    118  086c		       00		      .byte.b	%00000000
    119  086d		       00		      .byte.b	%00000000
    120  086e		       00		      .byte.b	%00000000
    121  086f		       00		      .byte.b	%00000000
    122  0870		       00		      .byte.b	%00000000
    123  0871		       00		      .byte.b	%00000000
    124  0872		       00		      .byte.b	%00000000
    125  0873		       00		      .byte.b	%00000000
    126  0874		       07		      .byte.b	%00000111
    127  0875		       07		      .byte.b	%00000111
    128  0876		       07		      .byte.b	%00000111
    129  0877		       07		      .byte.b	%00000111
    130  0878		       07		      .byte.b	%00000111
    131  0879		       07		      .byte.b	%00000111
    132  087a		       07		      .byte.b	%00000111
    133  087b		       07		      .byte.b	%00000111
    134  087c		       07		      .byte.b	%00000111
    135  087d		       07		      .byte.b	%00000111
    136  087e		       07		      .byte.b	%00000111
    137  087f
    138  087f		       00		      .byte.b	%00000000
    139  0880		       18		      .byte.b	%00011000
    140  0881		       25		      .byte.b	%00100101
    141  0882		       30		      .byte.b	%00110000
    142  0883		       28		      .byte.b	%00101000
    143  0884		       25		      .byte.b	%00100101
    144  0885		       98		      .byte.b	%10011000
    145  0886		       00		      .byte.b	%00000000
    146  0887		       00		      .byte.b	%00000000
    147  0888		       00		      .byte.b	%00000000
    148  0889		       00		      .byte.b	%00000000
    149  088a		       25		      .byte.b	%00100101
    150  088b		       2a		      .byte.b	%00101010
    151  088c		       2a		      .byte.b	%00101010
    152  088d		       ea		      .byte.b	%11101010
    153  088e		       2a		      .byte.b	%00101010
    154  088f		       aa		      .byte.b	%10101010
    155  0890		       6a		      .byte.b	%01101010
    156  0891		       0a		      .byte.b	%00001010
    157  0892		       00		      .byte.b	%00000000
    158  0893		       40		      .byte.b	%01000000
    159  0894		       21		      .byte.b	%00100001
    160  0895		       a2		      .byte.b	%10100010
    161  0896		       a2		      .byte.b	%10100010
    162  0897		       a2		      .byte.b	%10100010
    163  0898		       a2		      .byte.b	%10100010
    164  0899		       77		      .byte.b	%01110111
    165  089a		       22		      .byte.b	%00100010
    166  089b		       1a		      .byte.b	%00011010
    167  089c		       00		      .byte.b	%00000000
    168  089d		       00		      .byte.b	%00000000
    169  089e		       14		      .byte.b	%00010100
    170  089f		       14		      .byte.b	%00010100
    171  08a0		       14		      .byte.b	%00010100
    172  08a1		       14		      .byte.b	%00010100
    173  08a2		       96		      .byte.b	%10010110
    174  08a3		       05		      .byte.b	%00000101
    175  08a4		       10		      .byte.b	%00010000
    176  08a5		       e0		      .byte.b	%11100000
    177  08a6		       00		      .byte.b	%00000000
    178  08a7		       00		      .byte.b	%00000000
    179  08a8		       24		      .byte.b	%00100100
    180  08a9		       22		      .byte.b	%00100010
    181  08aa		       21		      .byte.b	%00100001
    182  08ab		       27		      .byte.b	%00100111
    183  08ac		       a9		      .byte.b	%10101001
    184  08ad		       69		      .byte.b	%01101001
    185  08ae		       26		      .byte.b	%00100110
    186  08af		       00		      .byte.b	%00000000
    187  08b0		       00		      .byte.b	%00000000
    188  08b1		       00		      .byte.b	%00000000
    189  08b2		       40		      .byte.b	%01000000
    190  08b3		       21		      .byte.b	%00100001
    191  08b4		       a2		      .byte.b	%10100010
    192  08b5		       a2		      .byte.b	%10100010
    193  08b6		       a2		      .byte.b	%10100010
    194  08b7		       a2		      .byte.b	%10100010
    195  08b8		       77		      .byte.b	%01110111
    196  08b9		       22		      .byte.b	%00100010
    197  08ba		       1a		      .byte.b	%00011010
    198  08bb		       00		      .byte.b	%00000000
    199  08bc		       00		      .byte.b	%00000000
    200  08bd		       10		      .byte.b	%00010000
    201  08be		       10		      .byte.b	%00010000
    202  08bf		       10		      .byte.b	%00010000
    203  08c0		       10		      .byte.b	%00010000
    204  08c1		       1c		      .byte.b	%00011100
    205  08c2		       10		      .byte.b	%00010000
    206  08c3		       10		      .byte.b	%00010000
    207  08c4		       bf		      .byte.b	%10111111
    208  08c5		       00		      .byte.b	%00000000
    209  08c6		       00		      .byte.b	%00000000
    210  08c7		       6b		      .byte.b	%01101011
    211  08c8		       94		      .byte.b	%10010100
    212  08c9		       94		      .byte.b	%10010100
    213  08ca		       74		      .byte.b	%01110100
    214  08cb		       12		      .byte.b	%00010010
    215  08cc		       61		      .byte.b	%01100001
    216  08cd		       00		      .byte.b	%00000000
    217  08ce		       00		      .byte.b	%00000000
    218  08cf		       18		      .byte.b	%00011000
    219  08d0		       04		      .byte.b	%00000100
    220  08d1		       82		      .byte.b	%10000010
    221  08d2		       4e		      .byte.b	%01001110
    222  08d3		       12		      .byte.b	%00010010
    223  08d4		       92		      .byte.b	%10010010
    224  08d5		       4a		      .byte.b	%01001010
    225  08d6		       86		      .byte.b	%10000110
    226  08d7		       00		      .byte.b	%00000000
    227  08d8		       00		      .byte.b	%00000000
    228  08d9		       00		      .byte.b	%00000000
    229  08da		       00		      .byte.b	%00000000
    230  08db		       00		      .byte.b	%00000000
    231  08dc		       00		      .byte.b	%00000000
    232  08dd		       00		      .byte.b	%00000000
    233  08de		       00		      .byte.b	%00000000
    234  08df		       00		      .byte.b	%00000000
    235  08e0		       00		      .byte.b	%00000000
    236  08e1		       00		      .byte.b	%00000000
    237  08e2		       00		      .byte.b	%00000000
    238  08e3		       00		      .byte.b	%00000000
    239  08e4		       00		      .byte.b	%00000000
    240  08e5		       00		      .byte.b	%00000000
    241  08e6		       00		      .byte.b	%00000000
    242  08e7		       3c		      .byte.b	%00111100
    243  08e8		       3e		      .byte.b	%00111110
    244  08e9		       3f		      .byte.b	%00111111
    245  08ea		       39		      .byte.b	%00111001
    246  08eb		       39		      .byte.b	%00111001
    247  08ec		       39		      .byte.b	%00111001
    248  08ed		       39		      .byte.b	%00111001
    249  08ee		       39		      .byte.b	%00111001
    250  08ef		       3b		      .byte.b	%00111011
    251  08f0		       3e		      .byte.b	%00111110
    252  08f1		       3c		      .byte.b	%00111100
    253  08f2		       00		      .byte.b	%00000000
    254  08f3		       00		      .byte.b	%00000000
    255  08f4		       e1		      .byte.b	%11100001
    256  08f5		       f3		      .byte.b	%11110011
    257  08f6		       fb		      .byte.b	%11111011
    258  08f7		       fb		      .byte.b	%11111011
    259  08f8		       3b		      .byte.b	%00111011
    260  08f9		       3b		      .byte.b	%00111011
    261  08fa		       33		      .byte.b	%00110011
    262  08fb		       e1		      .byte.b	%11100001
    263  08fc		       30		      .byte.b	%00110000
    264  08fd		       30		      .byte.b	%00110000
    265  08fe		       e0		      .byte.b	%11100000
    266  08ff
    267  08ff		       00		      .byte.b	%00000000
    268  0900		       c6		      .byte.b	%11000110
    269  0901		       29		      .byte.b	%00101001
    270  0902		       2c		      .byte.b	%00101100
    271  0903		       ca		      .byte.b	%11001010
    272  0904		       09		      .byte.b	%00001001
    273  0905		       c6		      .byte.b	%11000110
    274  0906		       00		      .byte.b	%00000000
    275  0907		       00		      .byte.b	%00000000
    276  0908		       00		      .byte.b	%00000000
    277  0909		       00		      .byte.b	%00000000
    278  090a		       11		      .byte.b	%00010001
    279  090b		       11		      .byte.b	%00010001
    280  090c		       11		      .byte.b	%00010001
    281  090d		       11		      .byte.b	%00010001
    282  090e		       19		      .byte.b	%00011001
    283  090f		       14		      .byte.b	%00010100
    284  0910		       01		      .byte.b	%00000001
    285  0911		       00		      .byte.b	%00000000
    286  0912		       00		      .byte.b	%00000000
    287  0913		       00		      .byte.b	%00000000
    288  0914		       28		      .byte.b	%00101000
    289  0915		       7d		      .byte.b	%01111101
    290  0916		       55		      .byte.b	%01010101
    291  0917		       54		      .byte.b	%01010100
    292  0918		       44		      .byte.b	%01000100
    293  0919		       44		      .byte.b	%01000100
    294  091a		       00		      .byte.b	%00000000
    295  091b		       00		      .byte.b	%00000000
    296  091c		       00		      .byte.b	%00000000
    297  091d		       00		      .byte.b	%00000000
    298  091e		       62		      .byte.b	%01100010
    299  091f		       94		      .byte.b	%10010100
    300  0920		       14		      .byte.b	%00010100
    301  0921		       64		      .byte.b	%01100100
    302  0922		       84		      .byte.b	%10000100
    303  0923		       6e		      .byte.b	%01101110
    304  0924		       04		      .byte.b	%00000100
    305  0925		       04		      .byte.b	%00000100
    306  0926		       00		      .byte.b	%00000000
    307  0927		       00		      .byte.b	%00000000
    308  0928		       30		      .byte.b	%00110000
    309  0929		       48		      .byte.b	%01001000
    310  092a		       4b		      .byte.b	%01001011
    311  092b		       32		      .byte.b	%00110010
    312  092c		       4a		      .byte.b	%01001010
    313  092d		       49		      .byte.b	%01001001
    314  092e		       31		      .byte.b	%00110001
    315  092f		       00		      .byte.b	%00000000
    316  0930		       00		      .byte.b	%00000000
    317  0931		       00		      .byte.b	%00000000
    318  0932		       00		      .byte.b	%00000000
    319  0933		       28		      .byte.b	%00101000
    320  0934		       7d		      .byte.b	%01111101
    321  0935		       55		      .byte.b	%01010101
    322  0936		       54		      .byte.b	%01010100
    323  0937		       44		      .byte.b	%01000100
    324  0938		       44		      .byte.b	%01000100
    325  0939		       00		      .byte.b	%00000000
    326  093a		       00		      .byte.b	%00000000
    327  093b		       00		      .byte.b	%00000000
    328  093c		       00		      .byte.b	%00000000
    329  093d		       a3		      .byte.b	%10100011
    330  093e		       a4		      .byte.b	%10100100
    331  093f		       a0		      .byte.b	%10100000
    332  0940		       a3		      .byte.b	%10100011
    333  0941		       b4		      .byte.b	%10110100
    334  0942		       2b		      .byte.b	%00101011
    335  0943		       80		      .byte.b	%10000000
    336  0944		       00		      .byte.b	%00000000
    337  0945		       00		      .byte.b	%00000000
    338  0946		       00		      .byte.b	%00000000
    339  0947		       59		      .byte.b	%01011001
    340  0948		       a5		      .byte.b	%10100101
    341  0949		       b1		      .byte.b	%10110001
    342  094a		       a9		      .byte.b	%10101001
    343  094b		       a5		      .byte.b	%10100101
    344  094c		       99		      .byte.b	%10011001
    345  094d		       80		      .byte.b	%10000000
    346  094e		       80		      .byte.b	%10000000
    347  094f		       00		      .byte.b	%00000000
    348  0950		       00		      .byte.b	%00000000
    349  0951		       98		      .byte.b	%10011000
    350  0952		       a5		      .byte.b	%10100101
    351  0953		       85		      .byte.b	%10000101
    352  0954		       99		      .byte.b	%10011001
    353  0955		       a1		      .byte.b	%10100001
    354  0956		       1b		      .byte.b	%00011011
    355  0957		       81		      .byte.b	%10000001
    356  0958		       01		      .byte.b	%00000001
    357  0959		       00		      .byte.b	%00000000
    358  095a		       00		      .byte.b	%00000000
    359  095b		       00		      .byte.b	%00000000
    360  095c		       4c		      .byte.b	%01001100
    361  095d		       52		      .byte.b	%01010010
    362  095e		       42		      .byte.b	%01000010
    363  095f		       4c		      .byte.b	%01001100
    364  0960		       50		      .byte.b	%01010000
    365  0961		       0c		      .byte.b	%00001100
    366  0962		       40		      .byte.b	%01000000
    367  0963		       00		      .byte.b	%00000000
    368  0964		       00		      .byte.b	%00000000
    369  0965		       00		      .byte.b	%00000000
    370  0966		       00		      .byte.b	%00000000
    371  0967		       35		      .byte.b	%00110101
    372  0968		       7d		      .byte.b	%01111101
    373  0969		       6d		      .byte.b	%01101101
    374  096a		       ec		      .byte.b	%11101100
    375  096b		       bc		      .byte.b	%10111100
    376  096c		       9d		      .byte.b	%10011101
    377  096d		       8d		      .byte.b	%10001101
    378  096e		       99		      .byte.b	%10011001
    379  096f		       30		      .byte.b	%00110000
    380  0970		       00		      .byte.b	%00000000
    381  0971		       00		      .byte.b	%00000000
    382  0972		       00		      .byte.b	%00000000
    383  0973		       00		      .byte.b	%00000000
    384  0974		       c6		      .byte.b	%11000110
    385  0975		       ef		      .byte.b	%11101111
    386  0976		       ef		      .byte.b	%11101111
    387  0977		       ef		      .byte.b	%11101111
    388  0978		       6d		      .byte.b	%01101101
    389  0979		       6d		      .byte.b	%01101101
    390  097a		       6d		      .byte.b	%01101101
    391  097b		       ed		      .byte.b	%11101101
    392  097c		       c5		      .byte.b	%11000101
    393  097d		       00		      .byte.b	%00000000
    394  097e		       00		      .byte.b	%00000000
    395  097f
    396  097f		       00		      .byte.b	%00000000
    397  0980		       42		      .byte.b	%01000010
    398  0981		       45		      .byte.b	%01000101
    399  0982		       45		      .byte.b	%01000101
    400  0983		       44		      .byte.b	%01000100
    401  0984		       64		      .byte.b	%01100100
    402  0985		       54		      .byte.b	%01010100
    403  0986		       00		      .byte.b	%00000000
    404  0987		       00		      .byte.b	%00000000
    405  0988		       60		      .byte.b	%01100000
    406  0989		       10		      .byte.b	%00010000
    407  098a		       0a		      .byte.b	%00001010
    408  098b		       3a		      .byte.b	%00111010
    409  098c		       4a		      .byte.b	%01001010
    410  098d		       4a		      .byte.b	%01001010
    411  098e		       2a		      .byte.b	%00101010
    412  098f		       1b		      .byte.b	%00011011
    413  0990		       02		      .byte.b	%00000010
    414  0991		       02		      .byte.b	%00000010
    415  0992		       00		      .byte.b	%00000000
    416  0993		       00		      .byte.b	%00000000
    417  0994		       d8		      .byte.b	%11011000
    418  0995		       29		      .byte.b	%00101001
    419  0996		       29		      .byte.b	%00101001
    420  0997		       e9		      .byte.b	%11101001
    421  0998		       2d		      .byte.b	%00101101
    422  0999		       ca		      .byte.b	%11001010
    423  099a		       00		      .byte.b	%00000000
    424  099b		       00		      .byte.b	%00000000
    425  099c		       00		      .byte.b	%00000000
    426  099d		       00		      .byte.b	%00000000
    427  099e		       38		      .byte.b	%00111000
    428  099f		       25		      .byte.b	%00100101
    429  09a0		       05		      .byte.b	%00000101
    430  09a1		       05		      .byte.b	%00000101
    431  09a2		       19		      .byte.b	%00011001
    432  09a3		       23		      .byte.b	%00100011
    433  09a4		       25		      .byte.b	%00100101
    434  09a5		       19		      .byte.b	%00011001
    435  09a6		       00		      .byte.b	%00000000
    436  09a7		       00		      .byte.b	%00000000
    437  09a8		       83		      .byte.b	%10000011
    438  09a9		       82		      .byte.b	%10000010
    439  09aa		       c1		      .byte.b	%11000001
    440  09ab		       98		      .byte.b	%10011000
    441  09ac		       00		      .byte.b	%00000000
    442  09ad		       02		      .byte.b	%00000010
    443  09ae		       01		      .byte.b	%00000001
    444  09af		       00		      .byte.b	%00000000
    445  09b0		       00		      .byte.b	%00000000
    446  09b1		       00		      .byte.b	%00000000
    447  09b2		       00		      .byte.b	%00000000
    448  09b3		       d8		      .byte.b	%11011000
    449  09b4		       29		      .byte.b	%00101001
    450  09b5		       29		      .byte.b	%00101001
    451  09b6		       e9		      .byte.b	%11101001
    452  09b7		       2d		      .byte.b	%00101101
    453  09b8		       ca		      .byte.b	%11001010
    454  09b9		       00		      .byte.b	%00000000
    455  09ba		       00		      .byte.b	%00000000
    456  09bb		       00		      .byte.b	%00000000
    457  09bc		       00		      .byte.b	%00000000
    458  09bd		       11		      .byte.b	%00010001
    459  09be		       a1		      .byte.b	%10100001
    460  09bf		       a0		      .byte.b	%10100000
    461  09c0		       20		      .byte.b	%00100000
    462  09c1		       20		      .byte.b	%00100000
    463  09c2		       71		      .byte.b	%01110001
    464  09c3		       21		      .byte.b	%00100001
    465  09c4		       20		      .byte.b	%00100000
    466  09c5		       00		      .byte.b	%00000000
    467  09c6		       00		      .byte.b	%00000000
    468  09c7		       53		      .byte.b	%01010011
    469  09c8		       54		      .byte.b	%01010100
    470  09c9		       54		      .byte.b	%01010100
    471  09ca		       53		      .byte.b	%01010011
    472  09cb		       50		      .byte.b	%01010000
    473  09cc		       a3		      .byte.b	%10100011
    474  09cd		       00		      .byte.b	%00000000
    475  09ce		       00		      .byte.b	%00000000
    476  09cf		       00		      .byte.b	%00000000
    477  09d0		       00		      .byte.b	%00000000
    478  09d1		       99		      .byte.b	%10011001
    479  09d2		       25		      .byte.b	%00100101
    480  09d3		       31		      .byte.b	%00110001
    481  09d4		       29		      .byte.b	%00101001
    482  09d5		       25		      .byte.b	%00100101
    483  09d6		       99		      .byte.b	%10011001
    484  09d7		       00		      .byte.b	%00000000
    485  09d8		       00		      .byte.b	%00000000
    486  09d9		       00		      .byte.b	%00000000
    487  09da		       00		      .byte.b	%00000000
    488  09db		       00		      .byte.b	%00000000
    489  09dc		       34		      .byte.b	%00110100
    490  09dd		       48		      .byte.b	%01001000
    491  09de		       48		      .byte.b	%01001000
    492  09df		       38		      .byte.b	%00111000
    493  09e0		       08		      .byte.b	%00001000
    494  09e1		       30		      .byte.b	%00110000
    495  09e2		       00		      .byte.b	%00000000
    496  09e3		       00		      .byte.b	%00000000
    497  09e4		       00		      .byte.b	%00000000
    498  09e5		       00		      .byte.b	%00000000
    499  09e6		       00		      .byte.b	%00000000
    500  09e7		       cd		      .byte.b	%11001101
    501  09e8		       ed		      .byte.b	%11101101
    502  09e9		       ed		      .byte.b	%11101101
    503  09ea		       6d		      .byte.b	%01101101
    504  09eb		       ed		      .byte.b	%11101101
    505  09ec		       cd		      .byte.b	%11001101
    506  09ed		       8f		      .byte.b	%10001111
    507  09ee		       ac		      .byte.b	%10101100
    508  09ef		       ec		      .byte.b	%11101100
    509  09f0		       0c		      .byte.b	%00001100
    510  09f1		       0c		      .byte.b	%00001100
    511  09f2		       00		      .byte.b	%00000000
    512  09f3		       00		      .byte.b	%00000000
    513  09f4		       b3		      .byte.b	%10110011
    514  09f5		       b3		      .byte.b	%10110011
    515  09f6		       b7		      .byte.b	%10110111
    516  09f7		       b7		      .byte.b	%10110111
    517  09f8		       b6		      .byte.b	%10110110
    518  09f9		       b6		      .byte.b	%10110110
    519  09fa		       b6		      .byte.b	%10110110
    520  09fb		       b3		      .byte.b	%10110011
    521  09fc		       b1		      .byte.b	%10110001
    522  09fd		       30		      .byte.b	%00110000
    523  09fe		       30		      .byte.b	%00110000
    524  09ff
    525  09ff		       00		      .byte.b	%00000000
    526  0a00		       18		      .byte.b	%00011000
    527  0a01		       25		      .byte.b	%00100101
    528  0a02		       31		      .byte.b	%00110001
    529  0a03		       a9		      .byte.b	%10101001
    530  0a04		       a4		      .byte.b	%10100100
    531  0a05		       98		      .byte.b	%10011000
    532  0a06		       00		      .byte.b	%00000000
    533  0a07		       00		      .byte.b	%00000000
    534  0a08		       00		      .byte.b	%00000000
    535  0a09		       00		      .byte.b	%00000000
    536  0a0a		       49		      .byte.b	%01001001
    537  0a0b		       52		      .byte.b	%01010010
    538  0a0c		       50		      .byte.b	%01010000
    539  0a0d		       51		      .byte.b	%01010001
    540  0a0e		       92		      .byte.b	%10010010
    541  0a0f		       39		      .byte.b	%00111001
    542  0a10		       10		      .byte.b	%00010000
    543  0a11		       10		      .byte.b	%00010000
    544  0a12		       00		      .byte.b	%00000000
    545  0a13		       00		      .byte.b	%00000000
    546  0a14		       c5		      .byte.b	%11000101
    547  0a15		       25		      .byte.b	%00100101
    548  0a16		       85		      .byte.b	%10000101
    549  0a17		       45		      .byte.b	%01000101
    550  0a18		       25		      .byte.b	%00100101
    551  0a19		       c5		      .byte.b	%11000101
    552  0a1a		       04		      .byte.b	%00000100
    553  0a1b		       04		      .byte.b	%00000100
    554  0a1c		       00		      .byte.b	%00000000
    555  0a1d		       00		      .byte.b	%00000000
    556  0a1e		       b6		      .byte.b	%10110110
    557  0a1f		       4a		      .byte.b	%01001010
    558  0a20		       4a		      .byte.b	%01001010
    559  0a21		       3a		      .byte.b	%00111010
    560  0a22		       0b		      .byte.b	%00001011
    561  0a23		       b2		      .byte.b	%10110010
    562  0a24		       00		      .byte.b	%00000000
    563  0a25		       00		      .byte.b	%00000000
    564  0a26		       00		      .byte.b	%00000000
    565  0a27		       00		      .byte.b	%00000000
    566  0a28		       cc		      .byte.b	%11001100
    567  0a29		       12		      .byte.b	%00010010
    568  0a2a		       12		      .byte.b	%00010010
    569  0a2b		       92		      .byte.b	%10010010
    570  0a2c		       52		      .byte.b	%01010010
    571  0a2d		       4a		      .byte.b	%01001010
    572  0a2e		       84		      .byte.b	%10000100
    573  0a2f		       00		      .byte.b	%00000000
    574  0a30		       00		      .byte.b	%00000000
    575  0a31		       00		      .byte.b	%00000000
    576  0a32		       00		      .byte.b	%00000000
    577  0a33		       c5		      .byte.b	%11000101
    578  0a34		       25		      .byte.b	%00100101
    579  0a35		       85		      .byte.b	%10000101
    580  0a36		       45		      .byte.b	%01000101
    581  0a37		       25		      .byte.b	%00100101
    582  0a38		       c5		      .byte.b	%11000101
    583  0a39		       04		      .byte.b	%00000100
    584  0a3a		       04		      .byte.b	%00000100
    585  0a3b		       00		      .byte.b	%00000000
    586  0a3c		       00		      .byte.b	%00000000
    587  0a3d		       c5		      .byte.b	%11000101
    588  0a3e		       2a		      .byte.b	%00101010
    589  0a3f		       2a		      .byte.b	%00101010
    590  0a40		       29		      .byte.b	%00101001
    591  0a41		       c8		      .byte.b	%11001000
    592  0a42		       1d		      .byte.b	%00011101
    593  0a43		       28		      .byte.b	%00101000
    594  0a44		       c8		      .byte.b	%11001000
    595  0a45		       00		      .byte.b	%00000000
    596  0a46		       00		      .byte.b	%00000000
    597  0a47		       62		      .byte.b	%01100010
    598  0a48		       a2		      .byte.b	%10100010
    599  0a49		       a3		      .byte.b	%10100011
    600  0a4a		       a3		      .byte.b	%10100011
    601  0a4b		       b2		      .byte.b	%10110010
    602  0a4c		       2a		      .byte.b	%00101010
    603  0a4d		       02		      .byte.b	%00000010
    604  0a4e		       02		      .byte.b	%00000010
    605  0a4f		       00		      .byte.b	%00000000
    606  0a50		       00		      .byte.b	%00000000
    607  0a51		       0c		      .byte.b	%00001100
    608  0a52		       12		      .byte.b	%00010010
    609  0a53		       18		      .byte.b	%00011000
    610  0a54		       14		      .byte.b	%00010100
    611  0a55		       92		      .byte.b	%10010010
    612  0a56		       4c		      .byte.b	%01001100
    613  0a57		       00		      .byte.b	%00000000
    614  0a58		       00		      .byte.b	%00000000
    615  0a59		       00		      .byte.b	%00000000
    616  0a5a		       00		      .byte.b	%00000000
    617  0a5b		       00		      .byte.b	%00000000
    618  0a5c		       00		      .byte.b	%00000000
    619  0a5d		       00		      .byte.b	%00000000
    620  0a5e		       00		      .byte.b	%00000000
    621  0a5f		       00		      .byte.b	%00000000
    622  0a60		       00		      .byte.b	%00000000
    623  0a61		       00		      .byte.b	%00000000
    624  0a62		       00		      .byte.b	%00000000
    625  0a63		       00		      .byte.b	%00000000
    626  0a64		       00		      .byte.b	%00000000
    627  0a65		       00		      .byte.b	%00000000
    628  0a66		       00		      .byte.b	%00000000
    629  0a67		       80		      .byte.b	%10000000
    630  0a68		       80		      .byte.b	%10000000
    631  0a69		       80		      .byte.b	%10000000
    632  0a6a		       8e		      .byte.b	%10001110
    633  0a6b		       91		      .byte.b	%10010001
    634  0a6c		       aa		      .byte.b	%10101010
    635  0a6d		       2c		      .byte.b	%00101100
    636  0a6e		       2a		      .byte.b	%00101010
    637  0a6f		       2c		      .byte.b	%00101100
    638  0a70		       11		      .byte.b	%00010001
    639  0a71		       0e		      .byte.b	%00001110
    640  0a72		       00		      .byte.b	%00000000
    641  0a73		       00		      .byte.b	%00000000
    642  0a74		       ce		      .byte.b	%11001110
    643  0a75		       de		      .byte.b	%11011110
    644  0a76		       dc		      .byte.b	%11011100
    645  0a77		       d8		      .byte.b	%11011000
    646  0a78		       de		      .byte.b	%11011110
    647  0a79		       de		      .byte.b	%11011110
    648  0a7a		       da		      .byte.b	%11011010
    649  0a7b		       da		      .byte.b	%11011010
    650  0a7c		       cc		      .byte.b	%11001100
    651  0a7d		       c0		      .byte.b	%11000000
    652  0a7e		       c0		      .byte.b	%11000000
    653  0a7f
    654  0a7f		       00		      .byte.b	%00000000
    655  0a80		       d4		      .byte.b	%11010100
    656  0a81		       20		      .byte.b	%00100000
    657  0a82		       20		      .byte.b	%00100000
    658  0a83		       20		      .byte.b	%00100000
    659  0a84		       a0		      .byte.b	%10100000
    660  0a85		       60		      .byte.b	%01100000
    661  0a86		       20		      .byte.b	%00100000
    662  0a87		       20		      .byte.b	%00100000
    663  0a88		       00		      .byte.b	%00000000
    664  0a89		       00		      .byte.b	%00000000
    665  0a8a		       80		      .byte.b	%10000000
    666  0a8b		       40		      .byte.b	%01000000
    667  0a8c		       40		      .byte.b	%01000000
    668  0a8d		       80		      .byte.b	%10000000
    669  0a8e		       00		      .byte.b	%00000000
    670  0a8f		       80		      .byte.b	%10000000
    671  0a90		       00		      .byte.b	%00000000
    672  0a91		       00		      .byte.b	%00000000
    673  0a92		       00		      .byte.b	%00000000
    674  0a93		       00		      .byte.b	%00000000
    675  0a94		       25		      .byte.b	%00100101
    676  0a95		       28		      .byte.b	%00101000
    677  0a96		       28		      .byte.b	%00101000
    678  0a97		       28		      .byte.b	%00101000
    679  0a98		       a4		      .byte.b	%10100100
    680  0a99		       42		      .byte.b	%01000010
    681  0a9a		       00		      .byte.b	%00000000
    682  0a9b		       00		      .byte.b	%00000000
    683  0a9c		       00		      .byte.b	%00000000
    684  0a9d		       00		      .byte.b	%00000000
    685  0a9e		       00		      .byte.b	%00000000
    686  0a9f		       00		      .byte.b	%00000000
    687  0aa0		       00		      .byte.b	%00000000
    688  0aa1		       00		      .byte.b	%00000000
    689  0aa2		       00		      .byte.b	%00000000
    690  0aa3		       80		      .byte.b	%10000000
    691  0aa4		       00		      .byte.b	%00000000
    692  0aa5		       00		      .byte.b	%00000000
    693  0aa6		       00		      .byte.b	%00000000
    694  0aa7		       00		      .byte.b	%00000000
    695  0aa8					      IF	DEMO_VERSION = NO
    696  0aa8		       2f		      .byte.b	%00101111
    697  0aa9		       28		      .byte.b	%00101000
    698  0aaa		       24		      .byte.b	%00100100
    699  0aab		       22		      .byte.b	%00100010
    700  0aac		       a1		      .byte.b	%10100001
    701  0aad		       69		      .byte.b	%01101001
    702  0aae		       26		      .byte.b	%00100110
    703  0aaf				  -	      ELSE
    704  0aaf				  -	      .byte	%00100010
    705  0aaf				  -	      .byte	%00100010
    706  0aaf				  -	      .byte	%00101111
    707  0aaf				  -	      .byte	%00101010
    708  0aaf				  -	      .byte	%10101000
    709  0aaf				  -	      .byte	%01100100
    710  0aaf				  -	      .byte	%00100100
    711  0aaf					      ENDIF
    712  0aaf		       00		      .byte.b	%00000000
    713  0ab0		       00		      .byte.b	%00000000
    714  0ab1		       00		      .byte.b	%00000000
    715  0ab2		       00		      .byte.b	%00000000
    716  0ab3		       25		      .byte.b	%00100101
    717  0ab4		       28		      .byte.b	%00101000
    718  0ab5		       28		      .byte.b	%00101000
    719  0ab6		       28		      .byte.b	%00101000
    720  0ab7		       a4		      .byte.b	%10100100
    721  0ab8		       42		      .byte.b	%01000010
    722  0ab9		       00		      .byte.b	%00000000
    723  0aba		       00		      .byte.b	%00000000
    724  0abb		       00		      .byte.b	%00000000
    725  0abc		       00		      .byte.b	%00000000
    726  0abd		       b0		      .byte.b	%10110000
    727  0abe		       50		      .byte.b	%01010000
    728  0abf		       50		      .byte.b	%01010000
    729  0ac0		       d0		      .byte.b	%11010000
    730  0ac1		       58		      .byte.b	%01011000
    731  0ac2		       94		      .byte.b	%10010100
    732  0ac3		       00		      .byte.b	%00000000
    733  0ac4		       00		      .byte.b	%00000000
    734  0ac5		       00		      .byte.b	%00000000
    735  0ac6		       00		      .byte.b	%00000000
    736  0ac7		       40		      .byte.b	%01000000
    737  0ac8		       40		      .byte.b	%01000000
    738  0ac9		       80		      .byte.b	%10000000
    739  0aca		       00		      .byte.b	%00000000
    740  0acb		       80		      .byte.b	%10000000
    741  0acc		       40		      .byte.b	%01000000
    742  0acd		       00		      .byte.b	%00000000
    743  0ace		       00		      .byte.b	%00000000
    744  0acf		       00		      .byte.b	%00000000
    745  0ad0		       00		      .byte.b	%00000000
    746  0ad1		       68		      .byte.b	%01101000
    747  0ad2		       90		      .byte.b	%10010000
    748  0ad3		       90		      .byte.b	%10010000
    749  0ad4		       90		      .byte.b	%10010000
    750  0ad5		       50		      .byte.b	%01010000
    751  0ad6		       30		      .byte.b	%00110000
    752  0ad7		       10		      .byte.b	%00010000
    753  0ad8		       10		      .byte.b	%00010000
    754  0ad9		       00		      .byte.b	%00000000
    755  0ada		       00		      .byte.b	%00000000
    756  0adb		       00		      .byte.b	%00000000
    757  0adc		       00		      .byte.b	%00000000
    758  0add		       00		      .byte.b	%00000000
    759  0ade		       00		      .byte.b	%00000000
    760  0adf		       00		      .byte.b	%00000000
    761  0ae0		       00		      .byte.b	%00000000
    762  0ae1		       00		      .byte.b	%00000000
    763  0ae2		       00		      .byte.b	%00000000
    764  0ae3		       00		      .byte.b	%00000000
    765  0ae4		       00		      .byte.b	%00000000
    766  0ae5		       00		      .byte.b	%00000000
    767  0ae6		       00		      .byte.b	%00000000
    768  0ae7		       00		      .byte.b	%00000000
    769  0ae8		       00		      .byte.b	%00000000
    770  0ae9		       00		      .byte.b	%00000000
    771  0aea		       00		      .byte.b	%00000000
    772  0aeb		       00		      .byte.b	%00000000
    773  0aec		       80		      .byte.b	%10000000
    774  0aed		       80		      .byte.b	%10000000
    775  0aee		       80		      .byte.b	%10000000
    776  0aef		       80		      .byte.b	%10000000
    777  0af0		       00		      .byte.b	%00000000
    778  0af1		       00		      .byte.b	%00000000
    779  0af2		       00		      .byte.b	%00000000
    780  0af3		       00		      .byte.b	%00000000
    781  0af4		       c0		      .byte.b	%11000000
    782  0af5		       c0		      .byte.b	%11000000
    783  0af6		       c0		      .byte.b	%11000000
    784  0af7		       c0		      .byte.b	%11000000
    785  0af8		       c0		      .byte.b	%11000000
    786  0af9		       c0		      .byte.b	%11000000
    787  0afa		       c0		      .byte.b	%11000000
    788  0afb		       f0		      .byte.b	%11110000
    789  0afc		       b0		      .byte.b	%10110000
    790  0afd		       00		      .byte.b	%00000000
    791  0afe		       00		      .byte.b	%00000000
    792  0aff		       00		      .byte.b	%00000000
------- FILE 48x128.asm
     14  0b00
     15  0b00							;--------------------------------------------------------------------------
     16  0b00							; The beautiful, beautiful, draw loop which draws the entire matrix onscreen
     17  0b00							; This caters for an adjustable (at compile-time) number of rows and also
     18  0b00							; facilitates double-size pixels.
     19  0b00
     20  0b00					      SUBROUTINE
     21  0b00
     22  0b00							; Each sprite has 6 columns, each with a pointer to the column data
     23  0b00							; setup in the vertical blank.  The columns are already mirrored (that
     24  0b00							; is, they point to the correct column for the mirrored-state of the
     25  0b00							; frame).
     26  0b00
      0  0b00					      DEFINE_SUBROUTINE	DrawSprite
      1  0b00		       00 01	   BANK_DrawSprite =	_CURRENT_BANK
      2  0b00					      SUBROUTINE
      3  0b00				   DrawSprite
     28  0b00
     29  0b00		       a0 80		      ldy	#128
     30  0b02				   .LABB
     31  0b02		       88		      dey		; 2
     32  0b03		       85 42		      sta	WSYNC
     33  0b05		       84 df		      sty	LoopCount	; 3
     34  0b07
     35  0b07		       b9 00 f0 	      lda	CopyrightNotice+128*0,y	; 4
     36  0b0a		       85 5b		      sta	GRP0	; 3
     37  0b0c		       b9 80 f0 	      lda	CopyrightNotice+128*1,y	; 4
     38  0b0f		       85 5c		      sta	GRP1	; 3
     39  0b11		       b9 00 f1 	      lda	CopyrightNotice+128*2,y	; 4
     40  0b14		       85 5b		      sta	GRP0	; 3
     41  0b16
     42  0b16		       b9 80 f2 	      lda	CopyrightNotice+128*5,y	; 4
     43  0b19		       85 e1		      sta	Temp	; 3
     44  0b1b		       be 00 f2 	      ldx	CopyrightNotice+128*4,y	; 4
     45  0b1e		       b9 80 f1 	      lda	CopyrightNotice+128*3,y	; 4
     46  0b21		       a4 e1		      ldy	Temp	; 3
     47  0b23		       85 5c		      sta	GRP1	; 3
     48  0b25		       86 5b		      stx	GRP0	; 3
     49  0b27		       84 5c		      sty	GRP1	; 3
     50  0b29		       85 5b		      sta	GRP0	; 3
     51  0b2b
     52  0b2b		       a4 df		      ldy	LoopCount	; 3
     53  0b2d		       d0 d3		      bne	.LABB	; 3
     54  0b2f
     55  0b2f		       84 5b		      sty	GRP0
     56  0b31		       84 5c		      sty	GRP1
     57  0b33		       84 5b		      sty	GRP0	; buffered!
     58  0b35		       60		      rts
     59  0b36
     60  0b36
     61  0b36							;--------------------------------------------------------------------------
     62  0b36							; Object X,Y positioning
     63  0b36							; Timing is absolutely critical here!
     64  0b36
     65  0b36				   PositionObject
     66  0b36
     67  0b36							; Waste scanlines to start of object position, giving our vertical movement
     68  0b36
     69  0b36				   .delayVert
     70  0b36		       85 42		      sta	WSYNC
     71  0b38							;---------------------------------------
     72  0b38		       ca		      dex		; 2
     73  0b39		       d0 fb		      bne	.delayVert	; 2/3
     74  0b3b
     75  0b3b							; Now the horizontal magic
     76  0b3b		       a9 0e		      lda	#COPYCOLOUR	; 2
     77  0b3d		       85 46		      sta	COLUP0	; 3
     78  0b3f		       85 47		      sta	COLUP1	; 3
     79  0b41
     80  0b41		       a9 33		      lda	#%110011	; 2
     81  0b43		       85 44		      sta	NUSIZ0	; 3
     82  0b45		       85 45		      sta	NUSIZ1	; 3
     83  0b47
     84  0b47		       85 65		      sta	VDELP0	; 3
     85  0b49
     86  0b49		       a2 4f		      ldx	#$4f	; 2
     87  0b4b		       85 52		      sta	RESM0	; 3	 @28	 mask left of AA text
     88  0b4d		       85 66		      sta	VDELP1	; 3
     89  0b4f		       86 60		      stx	HMP0	; 3
     90  0b51		       86 62		      stx	HMM0	; 3
     91  0b53
     92  0b53		       8d 50 00 	      sta.w	RESP0	; 4	 @41
     93  0b56		       85 51		      sta	RESP1	; 3	 @44
     94  0b58		       85 54		      sta	RESBL	; 3	 @47
     95  0b5a
     96  0b5a		       86 64		      stx	HMBL	; 3		 ball is used for blue AA text
     97  0b5c		       e8		      inx		; 2
     98  0b5d		       85 53		      sta	RESM1	; 3	 @55	 mask right of AA text
     99  0b5f
    100  0b5f		       86 61		      stx	HMP1	; 3
    101  0b61		       a9 d0		      lda	#$d0	; 2
    102  0b63		       85 63		      sta	HMM1	; 3
    103  0b65
    104  0b65		       85 42		      sta	WSYNC
    105  0b67							;---------------------------------------
    106  0b67		       85 6a		      sta	HMOVE
    107  0b69		       60		      rts
    108  0b6a
    109  0b6a
    110  0b6a							;------------------------------------------------------------------------------
    111  0b6a
      0  0b6a					      DEFINE_SUBROUTINE	CopyrightVerticalSync
      1  0b6a		       00 01	   BANK_CopyrightVerticalSync =	_CURRENT_BANK
      2  0b6a					      SUBROUTINE
      3  0b6a				   CopyrightVerticalSync
    113  0b6a
    114  0b6a							; Start of vertical blank processing
    115  0b6a
    116  0b6a		       a9 02		      lda	#$02
    117  0b6c		       85 42		      sta	WSYNC
    118  0b6e		       85 41		      sta	VBLANK
    119  0b70		       85 40		      sta	VSYNC
    120  0b72		       85 42		      sta	WSYNC
    121  0b74		       85 42		      sta	WSYNC
    122  0b76		       4a		      lsr
    123  0b77		       85 42		      sta	WSYNC
    124  0b79		       85 40		      sta	VSYNC
    125  0b7b
    126  0b7b		       a4 81		      ldy	Platform
    127  0b7d		       b9 c6 f3 	      lda	VBlankTblC,y
    128  0b80		       8d 96 02 	      sta	TIM64T
    129  0b83
    130  0b83		       ad 84 02    VblankLoop lda	INTIM
    131  0b86		       d0 fb		      bne	VblankLoop
    132  0b88
    133  0b88		       85 42		      sta	WSYNC
    134  0b8a		       85 41		      sta	VBLANK
    135  0b8c
    136  0b8c							;------------------------------------------------------------------------------
    137  0b8c							; START OF DISPLAY
    138  0b8c
    139  0b8c		       a9 ee		      lda	#238
    140  0b8e		       8d 96 02 	      sta	TIM64T
    141  0b91		       60		      rts
    142  0b92
    143  0b92
    144  0b92							;------------------------------------------------------------------------------
    145  0b92
      0  0b92					      DEFINE_SUBROUTINE	EndOfScreen
      1  0b92		       00 01	   BANK_EndOfScreen =	_CURRENT_BANK
      2  0b92					      SUBROUTINE
      3  0b92				   EndOfScreen
    147  0b92
    148  0b92				   .waitKernel
    149  0b92		       ad 84 02 	      lda	INTIM
    150  0b95		       d0 fb		      bne	.waitKernel
    151  0b97
    152  0b97		       85 42		      sta	WSYNC
    153  0b99
    154  0b99		       a9 42		      lda	#%01000010
    155  0b9b		       85 41		      sta	VBLANK	; end of screen - enter blanking
    156  0b9d
    157  0b9d				   OverscanStart
      0  0b9d					      SET_PLATFORM
      1  0b9d
      2  0b9d
      3  0b9d
      4  0b9d
      5  0b9d		       ad 82 02 	      lda	SWCHB
      6  0ba0		       2a		      rol
      7  0ba1		       2a		      rol
      8  0ba2		       2a		      rol
      9  0ba3		       29 03		      and	#%11
     10  0ba5				  -	      if	NTSC_MODE = NO
     11  0ba5				  -	      eor	#PAL
     12  0ba5					      endif
     13  0ba5		       85 81		      sta	Platform
    159  0ba7
    160  0ba7		       a8		      tay
    161  0ba8		       b9 ca f3 	      lda	OverscanTblC,y
    162  0bab		       8d 96 02 	      sta	TIM64T
    163  0bae
    164  0bae							; shorten wait time for PAL (identical to NTSC)
    165  0bae		       c0 02		      cpy	#PAL_50
    166  0bb0		       d0 08		      bne	.timeOK	; NTSC
    167  0bb2		       a9 c9		      lda	#COPYTIMESTART*SCANLINES_NTSC/SCANLINES_PAL	; = 201
    168  0bb4		       c5 e3		      cmp	CopyTime
    169  0bb6		       b0 02		      bcs	.timeOK
    170  0bb8		       85 e3		      sta	CopyTime
    171  0bba				   .timeOK
    172  0bba		       24 4c		      bit	INPT4
    173  0bbc		       10 52		      bpl	CopyExit
    174  0bbe
    175  0bbe		       ad 84 02    Overscan   lda	INTIM
    176  0bc1		       d0 fb		      bne	Overscan
    177  0bc3
    178  0bc3		       c6 e3		      dec	CopyTime
    179  0bc5		       60		      rts
    180  0bc6
    181  0bc6
    182  0bc6				   VBlankTblC
    183  0bc6					      IF	L276
    184  0bc6		       28		      .byte.b	40
    185  0bc7		       28		      .byte.b	40
    186  0bc8		       39		      .byte.b	57
    187  0bc9		       28		      .byte.b	40
    188  0bca				  -	      ELSE
    189  0bca				  -	      .byte	34
    190  0bca				  -	      .byte	34
    191  0bca				  -	      .byte	57
    192  0bca				  -	      .byte	34
    193  0bca					      ENDIF
    194  0bca
    195  0bca				   OverscanTblC
    196  0bca					      IF	L276
    197  0bca		       2e		      .byte.b	46
    198  0bcb		       2e		      .byte.b	46
    199  0bcc		       48		      .byte.b	72
    200  0bcd		       2e		      .byte.b	46
    201  0bce				  -	      ELSE
    202  0bce				  -	      .byte	35
    203  0bce				  -	      .byte	35
    204  0bce				  -	      .byte	72
    205  0bce				  -	      .byte	35
    206  0bce					      ENDIF
    207  0bce
    208  0bce
    209  0bce							;------------------------------------------------------------------------------
    210  0bce
      0  0bce					      DEFINE_SUBROUTINE	DrawCopyright
      1  0bce		       00 01	   BANK_DrawCopyright =	_CURRENT_BANK
      2  0bce					      SUBROUTINE
      3  0bce				   DrawCopyright
    212  0bce
    213  0bce		       a9 00		      lda	#0
    214  0bd0		       a0 40		      ldy	#GAMEMODE_2600
    215  0bd2		       a6 d0		      ldx	$d0
    216  0bd4		       e0 2c		      cpx	#$2c
    217  0bd6		       d0 07		      bne	.is2600
    218  0bd8		       a6 d1		      ldx	$d1
    219  0bda		       e0 a9		      cpx	#$a9
    220  0bdc		       d0 01		      bne	.is2600
    221  0bde		       a8		      tay		; 7800: bit 6 = 0
    222  0bdf				   .is2600		; 2600: bit 6 = 1
    223  0bdf		       aa		      tax		; A=0!
    224  0be0
    225  0be0		       d8		      cld
    226  0be1				   .clearLoop
    227  0be1		       ca		      dex
    228  0be2		       9a		      txs
    229  0be3		       48		      pha
    230  0be4		       d0 fb		      bne	.clearLoop	; SP=$FF, X = A = 0
    231  0be6
    232  0be6		       84 80		      sty	gameMode	; store console type
    233  0be8
    234  0be8		       a9 e4		      lda	#<COPYTIMESTART
    235  0bea		       85 e3		      sta	CopyTime
    236  0bec
    237  0bec
      0  0bec					      DEFINE_SUBROUTINE	NewCopyRightFrame
      1  0bec		       00 01	   BANK_NewCopyRightFrame =	_CURRENT_BANK
      2  0bec					      SUBROUTINE
      3  0bec				   NewCopyRightFrame
    239  0bec
    240  0bec		       20 6a f3 	      jsr	CopyrightVerticalSync
    241  0bef
    242  0bef		       a2 24		      ldx	#36
    243  0bf1		       20 36 f3 	      jsr	PositionObject
    244  0bf4		       20 00 f3 	      jsr	DrawSprite
    245  0bf7
    246  0bf7		       20 92 f3 	      jsr	EndOfScreen
    247  0bfa		       d0 f0		      bne	NewCopyRightFrame
    248  0bfc
    249  0bfc							; fall through
    250  0bfc
    251  0bfc							;*******************************************************************************
    252  0bfc							;*******************************************************************************
    253  0bfc							;*******************************************************************************
    254  0bfc
    255  0bfc					      SUBROUTINE
    256  0bfc
      0  0bfc					      DEFINE_SUBROUTINE	AtariAge
      1  0bfc		       00 01	   BANK_AtariAge =	_CURRENT_BANK
      2  0bfc					      SUBROUTINE
      3  0bfc				   AtariAge
    258  0bfc
    259  0bfc		       a9 e4		      lda	#<COPYTIMESTART
    260  0bfe		       85 e3		      sta	CopyTime
    261  0c00
      0  0c00					      DEFINE_SUBROUTINE	NewAtariAgeFrame
      1  0c00		       00 01	   BANK_NewAtariAgeFrame =	_CURRENT_BANK
      2  0c00					      SUBROUTINE
      3  0c00				   NewAtariAgeFrame
    263  0c00
    264  0c00		       20 6a f3 	      jsr	CopyrightVerticalSync
    265  0c03		       a2 2c		      ldx	#44
    266  0c05		       20 36 f3 	      jsr	PositionObject	; center AA logo
    267  0c08
    268  0c08		       20 ed f4 	      jsr	DrawAtariAge
    269  0c0b
    270  0c0b		       20 92 f3 	      jsr	EndOfScreen
    271  0c0e		       d0 f0		      bne	NewAtariAgeFrame
    272  0c10
    273  0c10				   CopyExit
    274  0c10		       4c e4 fc 	      jmp	ExitCopyRight
    275  0c13
    276  0c13							;--------------------------------------------------------------------------
    277  0c13
    278  0c13				   AABlueTbl
    279  0c13		       a2 a2		      .byte.b	$a2, $a2
    280  0c15		       b2 b2		      .byte.b	$b2, $b2	;96
    281  0c17				   AAOrangeTbl
    282  0c17		       3c 3c		      .byte.b	$3c, $3c
    283  0c19		       4c 4c		      .byte.b	$4c, $4c
    284  0c1b
    285  0c1b				   LOGO_AA3
    286  0c1b		       c0		      .byte.b	%11000000
    287  0c1c		       f8		      .byte.b	%11111000
    288  0c1d		       fe		      .byte.b	%11111110
    289  0c1e		       ff		      .byte.b	%11111111
    290  0c1f		       ff		      .byte.b	%11111111
    291  0c20		       ff		      .byte.b	%11111111
    292  0c21		       ff		      .byte.b	%11111111
    293  0c22		       ff		      .byte.b	%11111111
    294  0c23
    295  0c23		       ff		      .byte.b	%11111111
    296  0c24		       ff		      .byte.b	%11111111
    297  0c25		       ff		      .byte.b	%11111111
    298  0c26		       1f		      .byte.b	%00011111
    299  0c27		       07		      .byte.b	%00000111
    300  0c28		       03		      .byte.b	%00000011
    301  0c29		       00		      .byte.b	%00000000
    302  0c2a		       00		      .byte.b	%00000000
    303  0c2b
    304  0c2b		       00		      .byte.b	%00000000
    305  0c2c		       00		      .byte.b	%00000000
    306  0c2d		       00		      .byte.b	%00000000
    307  0c2e		       00		      .byte.b	%00000000
    308  0c2f		       03		      .byte.b	%00000011
    309  0c30		       03		      .byte.b	%00000011
    310  0c31		       03		      .byte.b	%00000011
    311  0c32		       07		      .byte.b	%00000111
    312  0c33
    313  0c33		       07		      .byte.b	%00000111
    314  0c34		       07		      .byte.b	%00000111
    315  0c35		       0f		      .byte.b	%00001111
    316  0c36		       0f		      .byte.b	%00001111
    317  0c37		       0f		      .byte.b	%00001111
    318  0c38		       0f		      .byte.b	%00001111
    319  0c39		       1e		      .byte.b	%00011110
    320  0c3a		       1e		      .byte.b	%00011110
    321  0c3b
    322  0c3b		       1e		      .byte.b	%00011110
    323  0c3c		       3c		      .byte.b	%00111100
    324  0c3d		       3c		      .byte.b	%00111100
    325  0c3e		       3c		      .byte.b	%00111100
    326  0c3f		       78		      .byte.b	%01111000
    327  0c40		       78		      .byte.b	%01111000
    328  0c41		       78		      .byte.b	%01111000
    329  0c42		       76		      .byte.b	%01110110
    330  0c43
    331  0c43		       f7		      .byte.b	%11110111
    332  0c44		       ff		      .byte.b	%11111111
    333  0c45		       ff		      .byte.b	%11111111
    334  0c46		       ef		      .byte.b	%11101111
    335  0c47		       ef		      .byte.b	%11101111
    336  0c48		       fe		      .byte.b	%11111110
    337  0c49		       de		      .byte.b	%11011110
    338  0c4a		       de		      .byte.b	%11011110
    339  0c4b
    340  0c4b		       fc		      .byte.b	%11111100
    341  0c4c		       bc		      .byte.b	%10111100
    342  0c4d		       3c		      .byte.b	%00111100
    343  0c4e		       78		      .byte.b	%01111000
    344  0c4f		       78		      .byte.b	%01111000
    345  0c50		       78		      .byte.b	%01111000
    346  0c51		       78		      .byte.b	%01111000
    347  0c52		       f0		      .byte.b	%11110000
    348  0c53
    349  0c53		       f0		      .byte.b	%11110000
    350  0c54		       f0		      .byte.b	%11110000
    351  0c55		       e0		      .byte.b	%11100000
    352  0c56		       e0		      .byte.b	%11100000
    353  0c57		       e0		      .byte.b	%11100000
    354  0c58		       c0		      .byte.b	%11000000
    355  0c59		       c0		      .byte.b	%11000000
    356  0c5a		       c0		      .byte.b	%11000000
    357  0c5b
    358  0c5b		       80		      .byte.b	%10000000
    359  0c5c		       80		      .byte.b	%10000000
    360  0c5d		       80		      .byte.b	%10000000
    361  0c5e		       80		      .byte.b	%10000000
    362  0c5f		       00		      .byte.b	%00000000
    363  0c60		       00		      .byte.b	%00000000
    364  0c61		       00		      .byte.b	%00000000
    365  0c62		       00		      .byte.b	%00000000
    366  0c63
    367  0c63		       00		      .byte.b	%00000000
    368  0c64		       00		      .byte.b	%00000000
    369  0c65		       03		      .byte.b	%00000011
    370  0c66		       07		      .byte.b	%00000111
    371  0c67		       1f		      .byte.b	%00011111
    372  0c68		       ff		      .byte.b	%11111111
    373  0c69		       ff		      .byte.b	%11111111
    374  0c6a		       ff		      .byte.b	%11111111
    375  0c6b
    376  0c6b		       ff		      .byte.b	%11111111
    377  0c6c		       ff		      .byte.b	%11111111
    378  0c6d		       ff		      .byte.b	%11111111
    379  0c6e		       ff		      .byte.b	%11111111
    380  0c6f		       ff		      .byte.b	%11111111
    381  0c70		       fe		      .byte.b	%11111110
    382  0c71		       f8		      .byte.b	%11111000
    383  0c72		       c0		      .byte.b	%11000000
    384  0c73
    385  0c73
    386  0c73				   Text_AA4b
    387  0c73		       f9		      .byte.b	%11111001
    388  0c74		       f4		      .byte.b	%11110100
    389  0c75		       fe		      .byte.b	%11111110
    390  0c76
    391  0c76		       90		      .byte.b	%10010000
    392  0c77		       86		      .byte.b	%10000110
    393  0c78		       26		      .byte.b	%00100110
    394  0c79		       26		      .byte.b	%00100110
    395  0c7a		       70		      .byte.b	%01110000
    396  0c7b		       7a		      .byte.b	%01111010
    397  0c7c							;    .byte   %11111111
    398  0c7c							;    .byte   %11111111
    399  0c7c
    400  0c7c				   Text_AA1b
    401  0c7c		       ff		      .byte.b	%11111111
    402  0c7d		       ff		      .byte.b	%11111111
    403  0c7e		       ff		      .byte.b	%11111111
    404  0c7f
    405  0c7f		       48		      .byte.b	%01001000
    406  0c80		       13		      .byte.b	%00010011
    407  0c81		       90		      .byte.b	%10010000
    408  0c82		       9f		      .byte.b	%10011111
    409  0c83		       9b		      .byte.b	%10011011
    410  0c84		       0c		      .byte.b	%00001100
    411  0c85		       9f		      .byte.b	%10011111
    412  0c86							;    .byte   %11111111
    413  0c86
    414  0c86				   Text_AA2b
    415  0c86		       ff		      .byte.b	%11111111
    416  0c87		       ff		      .byte.b	%11111111
    417  0c88		       ff		      .byte.b	%11111111
    418  0c89
    419  0c89		       26		      .byte.b	%00100110
    420  0c8a		       26		      .byte.b	%00100110
    421  0c8b		       26		      .byte.b	%00100110
    422  0c8c		       26		      .byte.b	%00100110
    423  0c8d		       22		      .byte.b	%00100010
    424  0c8e		       6a		      .byte.b	%01101010
    425  0c8f		       ff		      .byte.b	%11111111
    426  0c90		       fe		      .byte.b	%11111110
    427  0c91
    428  0c91				   Text_AA0b
    429  0c91		       ff		      .byte.b	%11111111
    430  0c92		       ff		      .byte.b	%11111111
    431  0c93		       ff		      .byte.b	%11111111
    432  0c94
    433  0c94		       3e		      .byte.b	%00111110
    434  0c95		       3e		      .byte.b	%00111110
    435  0c96		       80		      .byte.b	%10000000
    436  0c97		       9c		      .byte.b	%10011100
    437  0c98		       c9		      .byte.b	%11001001
    438  0c99		       c9		      .byte.b	%11001001
    439  0c9a		       e3		      .byte.b	%11100011
    440  0c9b		       e3		      .byte.b	%11100011
    441  0c9c
    442  0c9c				   Text_AA5b
    443  0c9c		       ff		      .byte.b	%11111111
    444  0c9d		       ff		      .byte.b	%11111111
    445  0c9e		       7f		      .byte.b	%01111111
    446  0c9f
    447  0c9f		       60		      .byte.b	%01100000
    448  0ca0		       4f		      .byte.b	%01001111
    449  0ca1		       40		      .byte.b	%01000000
    450  0ca2		       4c		      .byte.b	%01001100
    451  0ca3		       61		      .byte.b	%01100001
    452  0ca4		       73		      .byte.b	%01110011
    453  0ca5							;    .byte   %11111111
    454  0ca5							;    .byte   %11111111
    455  0ca5
    456  0ca5				   Text_AA3b
    457  0ca5		       ff		      .byte.b	%11111111
    458  0ca6		       ff		      .byte.b	%11111111
    459  0ca7		       ff		      .byte.b	%11111111
    460  0ca8
    461  0ca8		       4f		      .byte.b	%01001111
    462  0ca9		       4f		      .byte.b	%01001111
    463  0caa		       60		      .byte.b	%01100000
    464  0cab		       67		      .byte.b	%01100111
    465  0cac		       72		      .byte.b	%01110010
    466  0cad		       72		      .byte.b	%01110010
    467  0cae		       f8		      .byte.b	%11111000
    468  0caf		       78		      .byte.b	%01111000
    469  0cb0		       ff		      .byte.b	%11111111
    470  0cb1
    471  0cb1
    472  0cb1
    473  0cb1				   Text_AA4a
    474  0cb1		       f0		      .byte.b	%11110000
    475  0cb2		       fe		      .byte.b	%11111110
    476  0cb3
    477  0cb3		       9a		      .byte.b	%10011010
    478  0cb4		       90		      .byte.b	%10010000
    479  0cb5		       26		      .byte.b	%00100110
    480  0cb6		       26		      .byte.b	%00100110
    481  0cb7		       66		      .byte.b	%01100110
    482  0cb8		       70		      .byte.b	%01110000
    483  0cb9		       ff		      .byte.b	%11111111
    484  0cba							;    .byte   %11111111
    485  0cba							;    .byte   %11111111
    486  0cba
    487  0cba				   Text_AA1a
    488  0cba		       ff		      .byte.b	%11111111
    489  0cbb		       ff		      .byte.b	%11111111
    490  0cbc
    491  0cbc		       6d		      .byte.b	%01101101
    492  0cbd		       12		      .byte.b	%00010010
    493  0cbe		       93		      .byte.b	%10010011
    494  0cbf		       98		      .byte.b	%10011000
    495  0cc0		       9f		      .byte.b	%10011111
    496  0cc1		       08		      .byte.b	%00001000
    497  0cc2		       9f		      .byte.b	%10011111
    498  0cc3		       df		      .byte.b	%11011111
    499  0cc4							;    .byte   %11111111
    500  0cc4
    501  0cc4				   Text_AA2a
    502  0cc4		       ff		      .byte.b	%11111111
    503  0cc5		       ff		      .byte.b	%11111111
    504  0cc6
    505  0cc6		       26		      .byte.b	%00100110
    506  0cc7		       26		      .byte.b	%00100110
    507  0cc8		       26		      .byte.b	%00100110
    508  0cc9		       26		      .byte.b	%00100110
    509  0cca		       26		      .byte.b	%00100110
    510  0ccb		       22		      .byte.b	%00100010
    511  0ccc		       ff		      .byte.b	%11111111
    512  0ccd		       fe		      .byte.b	%11111110
    513  0cce		       fe		      .byte.b	%11111110
    514  0ccf
    515  0ccf				   Text_AA0a
    516  0ccf		       ff		      .byte.b	%11111111
    517  0cd0		       ff		      .byte.b	%11111111
    518  0cd1
    519  0cd1		       3e		      .byte.b	%00111110
    520  0cd2		       3e		      .byte.b	%00111110
    521  0cd3		       80		      .byte.b	%10000000
    522  0cd4		       9c		      .byte.b	%10011100
    523  0cd5		       c9		      .byte.b	%11001001
    524  0cd6		       c9		      .byte.b	%11001001
    525  0cd7		       e3		      .byte.b	%11100011
    526  0cd8		       e3		      .byte.b	%11100011
    527  0cd9							;    .byte   %11111111
    528  0cd9
    529  0cd9				   Text_AA5a
    530  0cd9		       ff		      .byte.b	%11111111
    531  0cda		       7f		      .byte.b	%01111111
    532  0cdb
    533  0cdb		       71		      .byte.b	%01110001
    534  0cdc		       66		      .byte.b	%01100110
    535  0cdd		       4f		      .byte.b	%01001111
    536  0cde		       40		      .byte.b	%01000000
    537  0cdf		       4c		      .byte.b	%01001100
    538  0ce0		       61		      .byte.b	%01100001
    539  0ce1		       ff		      .byte.b	%11111111
    540  0ce2							;    .byte   %11111111
    541  0ce2							;    .byte   %11111111
    542  0ce2
    543  0ce2				   Text_AA3a
    544  0ce2		       ff		      .byte.b	%11111111
    545  0ce3		       ff		      .byte.b	%11111111
    546  0ce4
    547  0ce4		       4f		      .byte.b	%01001111
    548  0ce5		       4f		      .byte.b	%01001111
    549  0ce6		       60		      .byte.b	%01100000
    550  0ce7		       67		      .byte.b	%01100111
    551  0ce8		       72		      .byte.b	%01110010
    552  0ce9		       72		      .byte.b	%01110010
    553  0cea		       f8		      .byte.b	%11111000
    554  0ceb		       78		      .byte.b	%01111000
    555  0cec		       7f		      .byte.b	%01111111
    556  0ced
    557  0ced
    558  0ced							;--------------------------------------------------------------------------
    559  0ced
    560  0ced							;    align 256
    561  0ced
      0  0ced					      DEFINE_SUBROUTINE	DrawAtariAge
      1  0ced		       00 01	   BANK_DrawAtariAge =	_CURRENT_BANK
      2  0ced					      SUBROUTINE
      3  0ced				   DrawAtariAge
    563  0ced		       ba		      tsx		; 2
    564  0cee		       86 e4		      stx	saveSP	; 3
    565  0cf0
    566  0cf0		       a9 0e		      lda	#$0e	; 2
    567  0cf2		       85 46		      sta	COLUP0	; 3
    568  0cf4		       85 47		      sta	COLUP1	; 3
    569  0cf6		       a4 81		      ldy	Platform	; 3
    570  0cf8		       b9 13 f4 	      lda	AABlueTbl,y	; 4
    571  0cfb		       85 48		      sta	COLUPF	; 3
    572  0cfd		       b9 17 f4 	      lda	AAOrangeTbl,y	; 4
    573  0d00		       85 e0		      sta	colorBK	; 3
    574  0d02
    575  0d02		       a9 01		      lda	#%000001	; 2
    576  0d04		       85 4a		      sta	CTRLPF	; 3
    577  0d06
    578  0d06		       a2 57		      ldx	#88-1	; 2
    579  0d08				   .loopLogo
    580  0d08		       9a		      txs		; 2
    581  0d09		       bd d1 f5 	      lda	LOGO_AA_PF,x	; 4/5
    582  0d0c		       85 42		      sta	WSYNC	; 3 =	9/10
    583  0d0e							;---------------------------------------
    584  0d0e		       85 4f		      sta	PF2	; 3 =	3
    585  0d10
    586  0d10		       bd 00 f7 	      lda	LOGO_AA0,x	; 4
    587  0d13		       85 5b		      sta	GRP0	; 3
    588  0d15		       bd 79 f6 	      lda	LOGO_AA1,x	; 4
    589  0d18		       85 5c		      sta	GRP1	; 3
    590  0d1a		       bd a1 f7 	      lda	LOGO_AA2,x	; 4
    591  0d1d		       85 5b		      sta	GRP0	; 3 = 21
    592  0d1f
    593  0d1f		       bd 49 f7 	      lda	LOGO_AA5,x	; 4
    594  0d22		       85 e1		      sta	Temp	; 3
    595  0d24		       bc 25 f6 	      ldy	LOGO_AA4,x	; 4
    596  0d27		       bd 1b f4 	      lda	LOGO_AA3,x	; 4 = 15
    597  0d2a
    598  0d2a		       a6 e1		      ldx	Temp	; 3
    599  0d2c		       85 5c		      sta	GRP1	; 3	     @45!
    600  0d2e		       84 5b		      sty	GRP0	; 3
    601  0d30		       86 5c		      stx	GRP1	; 3
    602  0d32		       85 5b		      sta	GRP0	; 3 = 15
    603  0d34
    604  0d34		       ba		      tsx		; 2
    605  0d35		       ca		      dex		; 2
    606  0d36		       10 d0		      bpl	.loopLogo	; 2/3= 6/7
    607  0d38
    608  0d38							; add some vertical gap between logo and text
    609  0d38		       a0 0b		      ldy	#22/2	; 2	     = 50% of text height
    610  0d3a				   .delayVert
    611  0d3a		       85 42		      sta	WSYNC	; 3
    612  0d3c							;---------------------------------------
    613  0d3c		       88		      dey		; 2
    614  0d3d		       d0 fb		      bne	.delayVert	; 2/3
    615  0d3f		       84 46		      sty	COLUP0	; 3
    616  0d41		       84 47		      sty	COLUP1	; 3 = 10
    617  0d43
    618  0d43		       a0 07		      ldy	#7	; 2
    619  0d45				   .delayText
    620  0d45		       88		      dey		; 2
    621  0d46		       d0 fd		      bne	.delayText	; 2/3
    622  0d48		       68		      pla		; 4 = 40    waste some time
    623  0d49
    624  0d49		       a9 30		      lda	#%110000	; 2
    625  0d4b		       85 4a		      sta	CTRLPF	; 3 =	5
    626  0d4d
    627  0d4d		       86 5f		      stx	ENABL	; 3
    628  0d4f		       86 5d		      stx	ENAM0	; 3
    629  0d51		       86 5e		      stx	ENAM1	; 3 =	9
    630  0d53
    631  0d53		       a2 0b		      ldx	#22/2	; 2
    632  0d55		       9a		      txs		; 2 =	4
    633  0d56				   .loopText		;	     @68
    634  0d56		       bd ce f4 	      lda	Text_AA0a-1,x	; 4
    635  0d59		       85 5b		      sta	GRP0	; 3
    636  0d5b							;---------------------------------------
    637  0d5b		       bd b9 f4 	      lda	Text_AA1a-1,x	; 4
    638  0d5e		       85 5c		      sta	GRP1	; 3
    639  0d60		       bd c3 f4 	      lda	Text_AA2a-1,x	; 4
    640  0d63		       85 5b		      sta	GRP0	; 3 = 21
    641  0d65
    642  0d65		       bd d8 f4 	      lda	Text_AA5a-1,x	; 4
    643  0d68		       85 e1		      sta	Temp	; 3
    644  0d6a		       bc b0 f4 	      ldy	Text_AA4a-1,x	; 4
    645  0d6d		       bd e1 f4 	      lda	Text_AA3a-1,x	; 4 = 15
    646  0d70
    647  0d70		       a2 ff		      ldx	#$ff	; 2
    648  0d72		       86 4f		      stx	PF2	; 3
    649  0d74		       a6 e0		      ldx	colorBK	; 3
    650  0d76		       86 49		      stx	COLUBK	; 3 = 11
    651  0d78
    652  0d78		       a6 e1		      ldx	Temp	; 3
    653  0d7a		       85 5c		      sta	GRP1	; 3	     @45!
    654  0d7c		       84 5b		      sty	GRP0	; 3
    655  0d7e		       86 5c		      stx	GRP1	; 3
    656  0d80		       85 5b		      sta	GRP0	; 3 = 15
    657  0d82
    658  0d82		       a9 00		      lda	#0	; 2
    659  0d84		       85 49		      sta	COLUBK	; 3
    660  0d86		       85 4f		      sta	PF2	; 3 =	8
    661  0d88
    662  0d88		       ba		      tsx		; 2
    663  0d89		       ca		      dex		; 2
    664  0d8a		       9a		      txs		; 2 =	6    @68
    665  0d8b
    666  0d8b		       bd 91 f4 	      lda	Text_AA0b,x	; 4
    667  0d8e		       85 5b		      sta	GRP0	; 3
    668  0d90							;---------------------------------------
    669  0d90		       bd 7c f4 	      lda	Text_AA1b,x	; 4
    670  0d93		       85 5c		      sta	GRP1	; 3
    671  0d95		       bd 86 f4 	      lda	Text_AA2b,x	; 4
    672  0d98		       85 5b		      sta	GRP0	; 3 = 21
    673  0d9a
    674  0d9a		       bd 9c f4 	      lda	Text_AA5b,x	; 4
    675  0d9d		       85 e1		      sta	Temp	; 3
    676  0d9f		       bc 73 f4 	      ldy	Text_AA4b,x	; 4
    677  0da2		       bd a5 f4 	      lda	Text_AA3b,x	; 4 = 15
    678  0da5
    679  0da5		       a2 ff		      ldx	#$ff	; 2
    680  0da7		       86 4f		      stx	PF2	; 3
    681  0da9		       a6 e0		      ldx	colorBK	; 3
    682  0dab		       86 49		      stx	COLUBK	; 3 = 11
    683  0dad
    684  0dad		       a6 e1		      ldx	Temp	; 3
    685  0daf		       85 5c		      sta	GRP1	; 3	     @45!
    686  0db1		       84 5b		      sty	GRP0	; 3
    687  0db3		       86 5c		      stx	GRP1	; 3
    688  0db5		       85 5b		      sta	GRP0	; 3 = 15
    689  0db7
    690  0db7		       a9 00		      lda	#0	; 2
    691  0db9		       85 49		      sta	COLUBK	; 3
    692  0dbb		       8d 4f 00 	      sta.w	PF2	; 4 =	9
    693  0dbe
    694  0dbe		       ba		      tsx		; 2
    695  0dbf		       d0 95		      bne	.loopText	; 2/3= 4/5  @68
    696  0dc1
    697  0dc1		       86 5b		      stx	GRP0
    698  0dc3		       86 5c		      stx	GRP1
    699  0dc5		       86 5b		      stx	GRP0
    700  0dc7		       86 5d		      stx	ENAM0
    701  0dc9		       86 5e		      stx	ENAM1
    702  0dcb		       86 5f		      stx	ENABL
    703  0dcd
    704  0dcd		       a6 e4		      ldx	saveSP
    705  0dcf		       9a		      txs
    706  0dd0		       60		      rts
    707  0dd1
    708  0dd1							;    align 256
    709  0dd1
    710  0dd1				   LOGO_AA_PF		; crosses page, no problem here!
    711  0dd1		       00 00 00 00*	      ds	11, %00000000
    712  0ddc		       c0 c0 c0 c0	      ds	4, %11000000
    713  0de0		       f0 f0 f0 f0*	      ds	58, %11110000
    714  0e1a		       c0 c0 c0 c0	      ds	4, %11000000
    715  0e1e		       00 00 00 00*	      ds	11-4, %00000000
    716  0e25
    717  0e25				   LOGO_AA4
    718  0e25		       00		      .byte.b	%00000000
    719  0e26		       00		      .byte.b	%00000000
    720  0e27		       00		      .byte.b	%00000000
    721  0e28		       00		      .byte.b	%00000000
    722  0e29		       c0		      .byte.b	%11000000
    723  0e2a		       e0		      .byte.b	%11100000
    724  0e2b		       e0		      .byte.b	%11100000
    725  0e2c		       f0		      .byte.b	%11110000
    726  0e2d
    727  0e2d		       f8		      .byte.b	%11111000
    728  0e2e		       fc		      .byte.b	%11111100
    729  0e2f		       fc		      .byte.b	%11111100
    730  0e30		       fe		      .byte.b	%11111110
    731  0e31		       fe		      .byte.b	%11111110
    732  0e32		       ff		      .byte.b	%11111111
    733  0e33		       ff		      .byte.b	%11111111
    734  0e34		       7f		      .byte.b	%01111111
    735  0e35
    736  0e35		       7f		      .byte.b	%01111111
    737  0e36		       3f		      .byte.b	%00111111
    738  0e37		       1f		      .byte.b	%00011111
    739  0e38		       1f		      .byte.b	%00011111
    740  0e39		       0f		      .byte.b	%00001111
    741  0e3a		       cf		      .byte.b	%11001111
    742  0e3b		       c7		      .byte.b	%11000111
    743  0e3c		       87		      .byte.b	%10000111
    744  0e3d
    745  0e3d		       87		      .byte.b	%10000111
    746  0e3e		       83		      .byte.b	%10000011
    747  0e3f		       03		      .byte.b	%00000011
    748  0e40		       03		      .byte.b	%00000011
    749  0e41		       01		      .byte.b	%00000001
    750  0e42		       01		      .byte.b	%00000001
    751  0e43		       01		      .byte.b	%00000001
    752  0e44		       01		      .byte.b	%00000001
    753  0e45
    754  0e45		       00		      .byte.b	%00000000
    755  0e46		       00		      .byte.b	%00000000
    756  0e47		       00		      .byte.b	%00000000
    757  0e48		       00		      .byte.b	%00000000
    758  0e49		       00		      .byte.b	%00000000
    759  0e4a		       00		      .byte.b	%00000000
    760  0e4b		       00		      .byte.b	%00000000
    761  0e4c		       00		      .byte.b	%00000000
    762  0e4d
    763  0e4d		       80		      .byte.b	%10000000
    764  0e4e		       80		      .byte.b	%10000000
    765  0e4f		       00		      .byte.b	%00000000
    766  0e50		       00		      .byte.b	%00000000
    767  0e51		       00		      .byte.b	%00000000
    768  0e52		       00		      .byte.b	%00000000
    769  0e53		       00		      .byte.b	%00000000
    770  0e54		       00		      .byte.b	%00000000
    771  0e55
    772  0e55		       00		      .byte.b	%00000000
    773  0e56		       00		      .byte.b	%00000000
    774  0e57		       00		      .byte.b	%00000000
    775  0e58		       00		      .byte.b	%00000000
    776  0e59		       00		      .byte.b	%00000000
    777  0e5a		       00		      .byte.b	%00000000
    778  0e5b		       00		      .byte.b	%00000000
    779  0e5c		       00		      .byte.b	%00000000
    780  0e5d
    781  0e5d		       01		      .byte.b	%00000001
    782  0e5e		       01		      .byte.b	%00000001
    783  0e5f		       01		      .byte.b	%00000001
    784  0e60		       01		      .byte.b	%00000001
    785  0e61		       03		      .byte.b	%00000011
    786  0e62		       03		      .byte.b	%00000011
    787  0e63		       03		      .byte.b	%00000011
    788  0e64		       07		      .byte.b	%00000111
    789  0e65
    790  0e65		       07		      .byte.b	%00000111
    791  0e66		       07		      .byte.b	%00000111
    792  0e67		       0f		      .byte.b	%00001111
    793  0e68		       0f		      .byte.b	%00001111
    794  0e69		       1f		      .byte.b	%00011111
    795  0e6a		       1f		      .byte.b	%00011111
    796  0e6b		       3f		      .byte.b	%00111111
    797  0e6c		       7f		      .byte.b	%01111111
    798  0e6d
    799  0e6d		       7f		      .byte.b	%01111111
    800  0e6e		       ff		      .byte.b	%11111111
    801  0e6f		       ff		      .byte.b	%11111111
    802  0e70		       fe		      .byte.b	%11111110
    803  0e71		       fe		      .byte.b	%11111110
    804  0e72		       fc		      .byte.b	%11111100
    805  0e73		       fc		      .byte.b	%11111100
    806  0e74		       f8		      .byte.b	%11111000
    807  0e75
    808  0e75		       f0		      .byte.b	%11110000
    809  0e76		       e0		      .byte.b	%11100000
    810  0e77		       e0		      .byte.b	%11100000
    811  0e78		       c0		      .byte.b	%11000000
    812  0e79							;    .byte   %00000000
    813  0e79							;    .byte   %00000000
    814  0e79							;    .byte   %00000000
    815  0e79							;    .byte   %00000000
    816  0e79
    817  0e79
    818  0e79				   LOGO_AA1
    819  0e79		       00		      .byte.b	%00000000
    820  0e7a		       00		      .byte.b	%00000000
    821  0e7b		       00		      .byte.b	%00000000
    822  0e7c		       00		      .byte.b	%00000000
    823  0e7d		       03		      .byte.b	%00000011
    824  0e7e		       07		      .byte.b	%00000111
    825  0e7f		       07		      .byte.b	%00000111
    826  0e80		       0f		      .byte.b	%00001111
    827  0e81
    828  0e81		       1f		      .byte.b	%00011111
    829  0e82		       3f		      .byte.b	%00111111
    830  0e83		       3f		      .byte.b	%00111111
    831  0e84		       7f		      .byte.b	%01111111
    832  0e85		       7f		      .byte.b	%01111111
    833  0e86		       ff		      .byte.b	%11111111
    834  0e87		       ff		      .byte.b	%11111111
    835  0e88		       fe		      .byte.b	%11111110
    836  0e89
    837  0e89		       fe		      .byte.b	%11111110
    838  0e8a		       fc		      .byte.b	%11111100
    839  0e8b		       f8		      .byte.b	%11111000
    840  0e8c		       f8		      .byte.b	%11111000
    841  0e8d		       f0		      .byte.b	%11110000
    842  0e8e		       f0		      .byte.b	%11110000
    843  0e8f		       e0		      .byte.b	%11100000
    844  0e90		       e0		      .byte.b	%11100000
    845  0e91
    846  0e91		       e0		      .byte.b	%11100000
    847  0e92		       c0		      .byte.b	%11000000
    848  0e93		       c0		      .byte.b	%11000000
    849  0e94		       c0		      .byte.b	%11000000
    850  0e95		       80		      .byte.b	%10000000
    851  0e96		       80		      .byte.b	%10000000
    852  0e97		       80		      .byte.b	%10000000
    853  0e98		       80		      .byte.b	%10000000
    854  0e99
    855  0e99		       00		      .byte.b	%00000000
    856  0e9a		       00		      .byte.b	%00000000
    857  0e9b		       00		      .byte.b	%00000000
    858  0e9c		       00		      .byte.b	%00000000
    859  0e9d		       00		      .byte.b	%00000000
    860  0e9e		       00		      .byte.b	%00000000
    861  0e9f		       00		      .byte.b	%00000000
    862  0ea0		       00		      .byte.b	%00000000
    863  0ea1
    864  0ea1		       00		      .byte.b	%00000000
    865  0ea2		       00		      .byte.b	%00000000
    866  0ea3		       00		      .byte.b	%00000000
    867  0ea4		       00		      .byte.b	%00000000
    868  0ea5		       00		      .byte.b	%00000000
    869  0ea6		       00		      .byte.b	%00000000
    870  0ea7		       00		      .byte.b	%00000000
    871  0ea8		       00		      .byte.b	%00000000
    872  0ea9
    873  0ea9		       00		      .byte.b	%00000000
    874  0eaa		       00		      .byte.b	%00000000
    875  0eab		       00		      .byte.b	%00000000
    876  0eac		       00		      .byte.b	%00000000
    877  0ead		       00		      .byte.b	%00000000
    878  0eae		       00		      .byte.b	%00000000
    879  0eaf		       00		      .byte.b	%00000000
    880  0eb0		       00		      .byte.b	%00000000
    881  0eb1
    882  0eb1		       80		      .byte.b	%10000000
    883  0eb2		       80		      .byte.b	%10000000
    884  0eb3		       80		      .byte.b	%10000000
    885  0eb4		       80		      .byte.b	%10000000
    886  0eb5		       c0		      .byte.b	%11000000
    887  0eb6		       c0		      .byte.b	%11000000
    888  0eb7		       c0		      .byte.b	%11000000
    889  0eb8		       e0		      .byte.b	%11100000
    890  0eb9
    891  0eb9		       e0		      .byte.b	%11100000
    892  0eba		       e0		      .byte.b	%11100000
    893  0ebb		       f0		      .byte.b	%11110000
    894  0ebc		       f0		      .byte.b	%11110000
    895  0ebd		       f8		      .byte.b	%11111000
    896  0ebe		       f8		      .byte.b	%11111000
    897  0ebf		       fc		      .byte.b	%11111100
    898  0ec0		       fe		      .byte.b	%11111110
    899  0ec1
    900  0ec1		       fe		      .byte.b	%11111110
    901  0ec2		       ff		      .byte.b	%11111111
    902  0ec3		       ff		      .byte.b	%11111111
    903  0ec4		       7f		      .byte.b	%01111111
    904  0ec5		       7f		      .byte.b	%01111111
    905  0ec6		       3f		      .byte.b	%00111111
    906  0ec7		       3f		      .byte.b	%00111111
    907  0ec8		       1f		      .byte.b	%00011111
    908  0ec9
    909  0ec9		       0f		      .byte.b	%00001111
    910  0eca		       07		      .byte.b	%00000111
    911  0ecb		       07		      .byte.b	%00000111
    912  0ecc		       03		      .byte.b	%00000011
    913  0ecd		       00		      .byte.b	%00000000
    914  0ece		       00		      .byte.b	%00000000
    915  0ecf		       00		      .byte.b	%00000000
    916  0ed0		       00		      .byte.b	%00000000
    917  0ed1
    918  0f00		       00 00 00 00*	      align	256
    919  0f00
    920  0f00				   LOGO_AA0
    921  0f00		       00		      .byte.b	%00000000
    922  0f01		       00		      .byte.b	%00000000
    923  0f02		       00		      .byte.b	%00000000
    924  0f03		       00		      .byte.b	%00000000
    925  0f04		       00		      .byte.b	%00000000
    926  0f05		       00		      .byte.b	%00000000
    927  0f06		       00		      .byte.b	%00000000
    928  0f07		       00		      .byte.b	%00000000
    929  0f08
    930  0f08		       00		      .byte.b	%00000000
    931  0f09		       00		      .byte.b	%00000000
    932  0f0a		       00		      .byte.b	%00000000
    933  0f0b		       00		      .byte.b	%00000000
    934  0f0c		       00		      .byte.b	%00000000
    935  0f0d		       00		      .byte.b	%00000000
    936  0f0e		       00		      .byte.b	%00000000
    937  0f0f		       01		      .byte.b	%00000001
    938  0f10
    939  0f10		       01		      .byte.b	%00000001
    940  0f11		       03		      .byte.b	%00000011
    941  0f12		       03		      .byte.b	%00000011
    942  0f13		       03		      .byte.b	%00000011
    943  0f14		       07		      .byte.b	%00000111
    944  0f15		       07		      .byte.b	%00000111
    945  0f16		       07		      .byte.b	%00000111
    946  0f17		       07		      .byte.b	%00000111
    947  0f18
    948  0f18		       0f		      .byte.b	%00001111
    949  0f19		       0f		      .byte.b	%00001111
    950  0f1a		       0f		      .byte.b	%00001111
    951  0f1b		       0f		      .byte.b	%00001111
    952  0f1c		       1f		      .byte.b	%00011111
    953  0f1d		       1f		      .byte.b	%00011111
    954  0f1e		       1f		      .byte.b	%00011111
    955  0f1f		       1f		      .byte.b	%00011111
    956  0f20
    957  0f20		       1f		      .byte.b	%00011111
    958  0f21		       1f		      .byte.b	%00011111
    959  0f22		       3f		      .byte.b	%00111111
    960  0f23		       3f		      .byte.b	%00111111
    961  0f24		       3f		      .byte.b	%00111111
    962  0f25		       3f		      .byte.b	%00111111
    963  0f26		       3f		      .byte.b	%00111111
    964  0f27		       3f		      .byte.b	%00111111
    965  0f28
    966  0f28		       3f		      .byte.b	%00111111
    967  0f29		       3f		      .byte.b	%00111111
    968  0f2a		       3f		      .byte.b	%00111111
    969  0f2b		       3f		      .byte.b	%00111111
    970  0f2c		       3f		      .byte.b	%00111111
    971  0f2d		       3f		      .byte.b	%00111111
    972  0f2e		       3f		      .byte.b	%00111111
    973  0f2f		       3f		      .byte.b	%00111111
    974  0f30
    975  0f30		       3f		      .byte.b	%00111111
    976  0f31		       3f		      .byte.b	%00111111
    977  0f32		       3f		      .byte.b	%00111111
    978  0f33		       3f		      .byte.b	%00111111
    979  0f34		       3f		      .byte.b	%00111111
    980  0f35		       3f		      .byte.b	%00111111
    981  0f36		       1f		      .byte.b	%00011111
    982  0f37		       1f		      .byte.b	%00011111
    983  0f38
    984  0f38		       1f		      .byte.b	%00011111
    985  0f39		       1f		      .byte.b	%00011111
    986  0f3a		       1f		      .byte.b	%00011111
    987  0f3b		       1f		      .byte.b	%00011111
    988  0f3c		       0f		      .byte.b	%00001111
    989  0f3d		       0f		      .byte.b	%00001111
    990  0f3e		       0f		      .byte.b	%00001111
    991  0f3f		       0f		      .byte.b	%00001111
    992  0f40
    993  0f40		       07		      .byte.b	%00000111
    994  0f41		       07		      .byte.b	%00000111
    995  0f42		       07		      .byte.b	%00000111
    996  0f43		       07		      .byte.b	%00000111
    997  0f44		       03		      .byte.b	%00000011
    998  0f45		       03		      .byte.b	%00000011
    999  0f46		       03		      .byte.b	%00000011
   1000  0f47		       01		      .byte.b	%00000001
   1001  0f48
   1002  0f48		       01		      .byte.b	%00000001
   1003  0f49							;    .byte   %00000000
   1004  0f49							;    .byte   %00000000
   1005  0f49							;    .byte   %00000000
   1006  0f49							;    .byte   %00000000
   1007  0f49							;    .byte   %00000000
   1008  0f49							;    .byte   %00000000
   1009  0f49							;    .byte   %00000000
   1010  0f49
   1011  0f49							;    .byte   %00000000
   1012  0f49							;    .byte   %00000000
   1013  0f49							;    .byte   %00000000
   1014  0f49							;    .byte   %00000000
   1015  0f49							;    .byte   %00000000
   1016  0f49							;    .byte   %00000000
   1017  0f49							;    .byte   %00000000
   1018  0f49							;    .byte   %00000000
   1019  0f49
   1020  0f49				   LOGO_AA5
   1021  0f49		       00		      .byte.b	%00000000
   1022  0f4a		       00		      .byte.b	%00000000
   1023  0f4b		       00		      .byte.b	%00000000
   1024  0f4c		       00		      .byte.b	%00000000
   1025  0f4d		       00		      .byte.b	%00000000
   1026  0f4e		       00		      .byte.b	%00000000
   1027  0f4f		       00		      .byte.b	%00000000
   1028  0f50		       00		      .byte.b	%00000000
   1029  0f51
   1030  0f51		       00		      .byte.b	%00000000
   1031  0f52		       00		      .byte.b	%00000000
   1032  0f53		       00		      .byte.b	%00000000
   1033  0f54		       00		      .byte.b	%00000000
   1034  0f55		       00		      .byte.b	%00000000
   1035  0f56		       00		      .byte.b	%00000000
   1036  0f57		       00		      .byte.b	%00000000
   1037  0f58		       80		      .byte.b	%10000000
   1038  0f59
   1039  0f59		       80		      .byte.b	%10000000
   1040  0f5a		       c0		      .byte.b	%11000000
   1041  0f5b		       c0		      .byte.b	%11000000
   1042  0f5c		       c0		      .byte.b	%11000000
   1043  0f5d		       e0		      .byte.b	%11100000
   1044  0f5e		       e0		      .byte.b	%11100000
   1045  0f5f		       e0		      .byte.b	%11100000
   1046  0f60		       e0		      .byte.b	%11100000
   1047  0f61
   1048  0f61		       f0		      .byte.b	%11110000
   1049  0f62		       f0		      .byte.b	%11110000
   1050  0f63		       f0		      .byte.b	%11110000
   1051  0f64		       f0		      .byte.b	%11110000
   1052  0f65		       f8		      .byte.b	%11111000
   1053  0f66		       f8		      .byte.b	%11111000
   1054  0f67		       f8		      .byte.b	%11111000
   1055  0f68		       f8		      .byte.b	%11111000
   1056  0f69
   1057  0f69		       f8		      .byte.b	%11111000
   1058  0f6a		       f8		      .byte.b	%11111000
   1059  0f6b		       fc		      .byte.b	%11111100
   1060  0f6c		       fc		      .byte.b	%11111100
   1061  0f6d		       fc		      .byte.b	%11111100
   1062  0f6e		       fc		      .byte.b	%11111100
   1063  0f6f		       fc		      .byte.b	%11111100
   1064  0f70		       fc		      .byte.b	%11111100
   1065  0f71
   1066  0f71		       fc		      .byte.b	%11111100
   1067  0f72		       fc		      .byte.b	%11111100
   1068  0f73		       fc		      .byte.b	%11111100
   1069  0f74		       fc		      .byte.b	%11111100
   1070  0f75		       fc		      .byte.b	%11111100
   1071  0f76		       fc		      .byte.b	%11111100
   1072  0f77		       fc		      .byte.b	%11111100
   1073  0f78		       fc		      .byte.b	%11111100
   1074  0f79
   1075  0f79		       fc		      .byte.b	%11111100
   1076  0f7a		       fc		      .byte.b	%11111100
   1077  0f7b		       fc		      .byte.b	%11111100
   1078  0f7c		       fc		      .byte.b	%11111100
   1079  0f7d		       fc		      .byte.b	%11111100
   1080  0f7e		       fc		      .byte.b	%11111100
   1081  0f7f		       f8		      .byte.b	%11111000
   1082  0f80		       f8		      .byte.b	%11111000
   1083  0f81
   1084  0f81		       f8		      .byte.b	%11111000
   1085  0f82		       f8		      .byte.b	%11111000
   1086  0f83		       f8		      .byte.b	%11111000
   1087  0f84		       f8		      .byte.b	%11111000
   1088  0f85		       f0		      .byte.b	%11110000
   1089  0f86		       f0		      .byte.b	%11110000
   1090  0f87		       f0		      .byte.b	%11110000
   1091  0f88		       f0		      .byte.b	%11110000
   1092  0f89
   1093  0f89		       e0		      .byte.b	%11100000
   1094  0f8a		       e0		      .byte.b	%11100000
   1095  0f8b		       e0		      .byte.b	%11100000
   1096  0f8c		       e0		      .byte.b	%11100000
   1097  0f8d		       c0		      .byte.b	%11000000
   1098  0f8e		       c0		      .byte.b	%11000000
   1099  0f8f		       c0		      .byte.b	%11000000
   1100  0f90		       80		      .byte.b	%10000000
   1101  0f91
   1102  0f91		       80		      .byte.b	%10000000
   1103  0f92		       00		      .byte.b	%00000000
   1104  0f93		       00		      .byte.b	%00000000
   1105  0f94		       00		      .byte.b	%00000000
   1106  0f95		       00		      .byte.b	%00000000
   1107  0f96		       00		      .byte.b	%00000000
   1108  0f97		       00		      .byte.b	%00000000
   1109  0f98		       00		      .byte.b	%00000000
   1110  0f99
   1111  0f99		       00		      .byte.b	%00000000
   1112  0f9a		       00		      .byte.b	%00000000
   1113  0f9b		       00		      .byte.b	%00000000
   1114  0f9c		       00		      .byte.b	%00000000
   1115  0f9d		       00		      .byte.b	%00000000
   1116  0f9e		       00		      .byte.b	%00000000
   1117  0f9f		       00		      .byte.b	%00000000
   1118  0fa0		       00		      .byte.b	%00000000
   1119  0fa1
   1120  0fa1
   1121  0fa1				   LOGO_AA2
   1122  0fa1		       03		      .byte.b	%00000011
   1123  0fa2		       1f		      .byte.b	%00011111
   1124  0fa3		       7f		      .byte.b	%01111111
   1125  0fa4		       ff		      .byte.b	%11111111
   1126  0fa5		       ff		      .byte.b	%11111111
   1127  0fa6		       ff		      .byte.b	%11111111
   1128  0fa7		       ff		      .byte.b	%11111111
   1129  0fa8		       ff		      .byte.b	%11111111
   1130  0fa9
   1131  0fa9		       ff		      .byte.b	%11111111
   1132  0faa		       ff		      .byte.b	%11111111
   1133  0fab		       ff		      .byte.b	%11111111
   1134  0fac		       f8		      .byte.b	%11111000
   1135  0fad		       e0		      .byte.b	%11100000
   1136  0fae		       c0		      .byte.b	%11000000
   1137  0faf		       00		      .byte.b	%00000000
   1138  0fb0		       00		      .byte.b	%00000000
   1139  0fb1
   1140  0fb1		       00		      .byte.b	%00000000
   1141  0fb2		       60		      .byte.b	%01100000
   1142  0fb3		       78		      .byte.b	%01111000
   1143  0fb4		       78		      .byte.b	%01111000
   1144  0fb5		       78		      .byte.b	%01111000
   1145  0fb6		       78		      .byte.b	%01111000
   1146  0fb7		       38		      .byte.b	%00111000
   1147  0fb8		       3c		      .byte.b	%00111100
   1148  0fb9
   1149  0fb9		       3c		      .byte.b	%00111100
   1150  0fba		       3c		      .byte.b	%00111100
   1151  0fbb		       3c		      .byte.b	%00111100
   1152  0fbc		       3c		      .byte.b	%00111100
   1153  0fbd		       1c		      .byte.b	%00011100
   1154  0fbe		       1c		      .byte.b	%00011100
   1155  0fbf		       1e		      .byte.b	%00011110
   1156  0fc0		       1e		      .byte.b	%00011110
   1157  0fc1
   1158  0fc1		       1e		      .byte.b	%00011110
   1159  0fc2		       1e		      .byte.b	%00011110
   1160  0fc3		       0e		      .byte.b	%00001110
   1161  0fc4		       0e		      .byte.b	%00001110
   1162  0fc5		       ce		      .byte.b	%11001110
   1163  0fc6		       ef		      .byte.b	%11101111
   1164  0fc7		       ff		      .byte.b	%11111111
   1165  0fc8		       ff		      .byte.b	%11111111
   1166  0fc9
   1167  0fc9		       f7		      .byte.b	%11110111
   1168  0fca		       f7		      .byte.b	%11110111
   1169  0fcb		       f7		      .byte.b	%11110111
   1170  0fcc		       77		      .byte.b	%01110111
   1171  0fcd		       77		      .byte.b	%01110111
   1172  0fce		       7f		      .byte.b	%01111111
   1173  0fcf		       7f		      .byte.b	%01111111
   1174  0fd0		       7b		      .byte.b	%01111011
   1175  0fd1
   1176  0fd1		       7b		      .byte.b	%01111011
   1177  0fd2		       7b		      .byte.b	%01111011
   1178  0fd3		       38		      .byte.b	%00111000
   1179  0fd4		       38		      .byte.b	%00111000
   1180  0fd5		       3c		      .byte.b	%00111100
   1181  0fd6		       3c		      .byte.b	%00111100
   1182  0fd7		       3c		      .byte.b	%00111100
   1183  0fd8		       3c		      .byte.b	%00111100
   1184  0fd9
   1185  0fd9		       1c		      .byte.b	%00011100
   1186  0fda		       1c		      .byte.b	%00011100
   1187  0fdb		       1d		      .byte.b	%00011101
   1188  0fdc		       1f		      .byte.b	%00011111
   1189  0fdd		       1f		      .byte.b	%00011111
   1190  0fde		       1f		      .byte.b	%00011111
   1191  0fdf		       0f		      .byte.b	%00001111
   1192  0fe0		       0f		      .byte.b	%00001111
   1193  0fe1
   1194  0fe1		       0f		      .byte.b	%00001111
   1195  0fe2		       0f		      .byte.b	%00001111
   1196  0fe3		       0f		      .byte.b	%00001111
   1197  0fe4		       0f		      .byte.b	%00001111
   1198  0fe5		       07		      .byte.b	%00000111
   1199  0fe6		       00		      .byte.b	%00000000
   1200  0fe7		       00		      .byte.b	%00000000
   1201  0fe8		       00		      .byte.b	%00000000
   1202  0fe9
   1203  0fe9		       00		      .byte.b	%00000000
   1204  0fea		       00		      .byte.b	%00000000
   1205  0feb		       c0		      .byte.b	%11000000
   1206  0fec		       e0		      .byte.b	%11100000
   1207  0fed		       f8		      .byte.b	%11111000
   1208  0fee		       ff		      .byte.b	%11111111
   1209  0fef		       ff		      .byte.b	%11111111
   1210  0ff0		       ff		      .byte.b	%11111111
   1211  0ff1
   1212  0ff1		       ff		      .byte.b	%11111111
   1213  0ff2		       ff		      .byte.b	%11111111
   1214  0ff3		       ff		      .byte.b	%11111111
   1215  0ff4		       ff		      .byte.b	%11111111
   1216  0ff5		       ff		      .byte.b	%11111111
   1217  0ff6		       7f		      .byte.b	%01111111
   1218  0ff7		       1f		      .byte.b	%00011111
   1219  0ff8		       03		      .byte.b	%00000011
   1220  0ff9
   1221  0ff9							;-------------------------------------------------------------------------------
   1222  0ff9
      0  0ff9					      CHECK_BANK_SIZE	"COPYRIGHT"
      1  0ff9		       07 f9	   .TEMP      =	* - BANK_START
 COPYRIGHT (2K) SIZE =  $7f9 , FREE= $7
      2  0ff9					      ECHO	"COPYRIGHT", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0ff9				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0ff9				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0ff9				  -	      ERR
      6  0ff9					      endif
------- FILE ./notBoulderDash.asm
------- FILE BANK_TITLE.asm LEVEL 2 PASS 3
      0  0ff9					      include	"BANK_TITLE.asm"
      1  0ff9							; TODOs
      2  0ff9							; + update channel 1 each scanline
      3  0ff9							; + update channel 0 each scanline
      4  0ff9							; + convert both kernels to 2LK counters
      5  0ff9							; + split graphic data into odd and even lines
      6  0ff9							; + precalculate values
      7  0ff9							; + calculate inital values some scanlines ahead
      8  0ff9							; + update AUD0 during kernels
      9  0ff9							; + check carry flags! AGAIN!!!
     10  0ff9							; + DEBUG!!!
     11  0ff9							; + revert code to use ROM bank
     12  0ff9
     13  0ff9							; music ideas:
     14  0ff9							; + precalculate 1 channel (96 bytes RAM = 48 scanlines)
     15  0ff9							; + calculate other channel during kernel over two scanlines
     16  0ff9							; x use self-modifying code
     17  0ff9
     18  0ff9							; + sync music
     19  0ff9							; + share logo bank with other bank (copyright!)
     20  0ff9							; + set pointers
     21  0ff9							; + joystick input
     22  0ff9							;   + switch from logo to selection
     23  0ff9							;   + block 2 joystick row for 1 player
     24  0ff9							; x calculate cave*=4/5 (done somewhere else)
     25  0ff9
     26  0ff9							;------------------------------------------------------------------------------
     27  0ff9							;##############################################################################
     28  0ff9							;------------------------------------------------------------------------------
     29  0ff9
      0  0ff9					      NEWBANK	TITLE_BANK
      1  17fe ????				      SEG	TITLE_BANK
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   TITLE_BANK SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	TITLE_BANK
     31  1000
     32  1000		       00 01	   PLAY_CH_0  =	YES	; play the very tricky, precalculated channel 0
     33  1000		       00 01	   PLAY_CH_1  =	YES	; play the on-the-fly calculated channel 1
     34  1000
     35  1000		       00 0e	   TWHITE     =	WHITE
     36  1000
     37  1000		       00 09	   NOTE_LEN_NTSC =	9	; was: 9 ; number of frames each note is played in total
     38  1000		       00 08	   NOTE_LEN_PAL =	NOTE_LEN_NTSC-1	; was: NOTE_LEN_NTSC-1 = 8
     39  1000		       00 02	   NOTE_OFF_LEN =	2	; number of silent frames between each note (>=1!)
     40  1000		       00 0c	   VOL_MASK   =	%1100
     41  1000
     42  1000							; number of precalculated values
     43  1000		       00 30	   PC_TOP     =	48	; calculated during vertical blank
     44  1000		       00 30	   PC_BTM     =	48	; calculated during overscan
     45  1000
     46  1000					      MAC	check_clc
     47  1000							;    bcs     . 		  ; 2/3       set carry causes endless loop
     48  1000					      ENDM
     49  1000
     50  1000					      MAC	update_music_data_lo
     51  1000					      CHECK_CLC
     52  1000							;    clc			  ; 2	      we always assume that carry is clear!
     53  1000					      lda	audv{1}Lo	; 3
     54  1000					      adc	note{1}	; 3
     55  1000					      sta	audv{1}Lo	; 3 =	9
     56  1000					      ENDM
     57  1000
     58  1000					      MAC	update_music_data_hi
     59  1000					      lda	audv{1}Hi	; 3
     60  1000					      adc	#0	; 2
     61  1000					      sta	audv{1}Hi	; 3 =	8
     62  1000					      ENDM
     63  1000
     64  1000					      MAC	update_music_data
     65  1000					      UPDATE_MUSIC_DATA_LO	{1}	; 9
     66  1000					      UPDATE_MUSIC_DATA_HI	{1}	; 8 = 17
     67  1000					      ENDM
     68  1000
     69  1000					      MAC	update_music_prep_vol
     70  1000					      and	#VOL_MASK/2	; 2	     optional, but sounds a tiny bit better if left in
     71  1000					      asl		; 2 =	4    carry clear now!
     72  1000					      ENDM
     73  1000
     74  1000					      MAC	update_music_set_vol
     75  1000					      IF	PLAY_CH_{1} == YES
     76  1000					      sta	AUDV{1}	; 3	     @07!    NOTE: this store must always occur on the same cycle
     77  1000					      ELSE
     78  1000					      nop	AUDV{1}	; 3 =	3
     79  1000					      ENDIF
     80  1000					      ENDM
     81  1000
     82  1000					      MAC	update_music_set_vol_w
     83  1000					      IF	PLAY_CH_{1} == YES
     84  1000					      sta.w	AUDV{1}	; 4	     @07!    NOTE: this store must always occur on the same cycle
     85  1000					      ELSE
     86  1000					      nop.w	AUDV{1}	; 4 =	4
     87  1000					      ENDIF
     88  1000					      ENDM
     89  1000
     90  1000					      MAC	update_music_vol
     91  1000					      UPDATE_MUSIC_PREP_VOL	{1}	; 4
     92  1000					      UPDATE_MUSIC_SET_VOL	{1}	; 3 =	7
     93  1000					      ENDM
     94  1000
     95  1000					      MAC	update_music
     96  1000					      UPDATE_MUSIC_DATA	{1}	;17
     97  1000					      UPDATE_MUSIC_VOL	{1}	; 7 = 24
     98  1000					      ENDM
     99  1000
    100  1000					      MAC	update_music_wsync
    101  1000					      UPDATE_MUSIC_DATA	{1}	;17
    102  1000					      sta	WSYNC	; 3
    103  1000							;---------------------------------------
    104  1000					      UPDATE_MUSIC_VOL	{1}	; 7 = 27
    105  1000					      ENDM
    106  1000
    107  1000
    108  1000		       00 0a	   NOT_SEL_COL =	$0a
    109  1000
    110  1000					      MAC	set_row_col
    111  1000					      ldx	Platform	; 3
    112  1000					      lda	selRow	; 3
    113  1000					      IF	{1} != 0
    114  1000					      eor	#{1}	; 2	     do NOT change carry!
    115  1000					      ENDIF
    116  1000					      beq	.isSel{1}	; 2/3
    117  1000					      lda	#NOT_SEL_COL	; 2
    118  1000					      bne	.notSel{1}	; 3
    119  1000
    120  1000				   .isSel{1}
    121  1000					      lda	SelectionColTbl,x	; 4
    122  1000				   .notSel{1}
    123  1000					      sta	COLUP0	; 3
    124  1000					      sta	COLUP1	; 3 = 21
    125  1000					      ENDM
    126  1000
    127  1000					      MAC	end_row
    128  1000					      sty	COLUP0	; 3
    129  1000					      sty	COLUP1	; 3
    130  1000					      SLEEP	3	; 3
    131  1000							;    nop     GRP0		      ; 3
    132  1000							;    nop     GRP1		      ; 3
    133  1000							;    nop     GRP0		      ; 3
    134  1000
    135  1000					      UPDATE_MUSIC_DATA_HI	1	; 8 = 17
    136  1000							;---------------------------------------
    137  1000					      UPDATE_MUSIC_VOL	1	; 7	     @07!    <-- AUDV1
    138  1000
    139  1000					      UPDATE_MUSIC_DATA_LO	1	; 9	     @16
    140  1000					      ENDM		;	     @59
    141  1000
    142  1000					      MAC	start_row
    143  1000					      ldy	#LKERNEL_H/8-1	; 2
    144  1000					      sty	loopCntSel	; 3
    145  1000					      lda	(ptrGfxA),y	; 5
    146  1000					      sta	tmpGfxA	; 3
    147  1000
    148  1000					      SET_ROW_COL	{1}	;21		     has to be late!
    149  1000
    150  1000					      jmp	EnterSelLoop{1}	; 3 = 16    @70
    151  1000					      ENDM		;	     @33
    152  1000
    153  1000					      MAC	set_digit_ptr
    154  1000					      ldy	selLst+{1}	; 3
    155  1000					      lda	SelDigitAPtr,y	; 4
    156  1000					      sta	ptrGfxA	; 3
    157  1000					      lda	SelDigitBPtr,y	; 4
    158  1000					      sta	ptrGfxB	; 3 = 14
    159  1000					      ENDM
    160  1000
    161  1000					      MAC	set_char_ptr
    162  1000					      lda	SelCharAPtr,y	; 4
    163  1000					      sta	ptrGfxA	; 3
    164  1000					      lda	SelCharBPtr,y	; 4
    165  1000					      sta	ptrGfxB	; 3 = 14
    166  1000					      ENDM
    167  1000
    168  1000					      MAC	draw_row
    169  1000
    170  1000					      IF	{1} != 0
    171  1000					      ALIGN_FREE	256
    172  1000					      ENDIF
    173  1000
    174  1000							;--------------------------------------------------------------------------
    175  1000							; Code is exquisitely timed so that each line takes
    176  1000							; *EXACTLY* 76 cycles.  Code cannot cross page-boundaries, as the branch
    177  1000							; would then take an extra cycle, and bugger the display.
    178  1000				   LoopSelGfx{1}		;	     @60
    179  1000					      ldx	SelGfxB0_{1}-1,y	; 4
    180  1000					      stx.w	GRP0	; 4
    181  1000
    182  1000					      UPDATE_MUSIC_DATA_HI	1	; 8 = 16    @76
    183  1000							;---------------------------------------
    184  1000					      UPDATE_MUSIC_VOL	1	; 7	     @07!    <-- AUDV1
    185  1000
    186  1000					      UPDATE_MUSIC_DATA_LO	1	; 9	     @16
    187  1000
    188  1000					      lda	SelGfxB1_{1}-1,y	; 4
    189  1000					      sta	GRP1	; 3
    190  1000					      lda	SelGfxB2_{1}-1,y	; 4
    191  1000					      sta	GRP0	; 4 = 14    @30
    192  1000
    193  1000					      lax	(ptrGfxB),y	; 5
    194  1000					      lda	SelGfxB3_{1}-1,y	; 4
    195  1000					      ldy	tmpGfxB	; 3 = 12
    196  1000
    197  1000					      sta	GRP1	; 3	     @45
    198  1000					      sty	GRP0	; 3	     @48
    199  1000					      stx	GRP1	; 3	     @51
    200  1000					      sta	GRP0	; 3 = 15    @54
    201  1000
    202  1000					      ldy	loopCntSel	; 3
    203  1000					      dey		; 2 =	5
    204  1000					      sty	loopCntSel	; 3
    205  1000					      lda	(ptrGfxA),y	; 5
    206  1000					      sta	tmpGfxA	; 3 = 11
    207  1000				   EnterSelLoop{1}		;	     @70
    208  1000					      lax	SelGfxB4_{1}-1,y	; 4
    209  1000							;---------------------------------------
    210  1000				   V_OFS      SET	(3-{1})*4	;		     calculate separately, else this gives wrong results!
    211  1000					      lda	audV0LstBtm+V_OFS,y	; 4
    212  1000					      and	#VOL_MASK	; 2
    213  1000					      UPDATE_MUSIC_SET_VOL	0	; 3 = 13    @07!    <-- AUDV0
    214  1000
    215  1000					      stx	tmpGfxB	; 3
    216  1000					      ldx	SelGfxA0_{1},y	; 4
    217  1000					      stx	GRP0	; 3
    218  1000					      lda	SelGfxA1_{1},y	; 4
    219  1000					      sta	GRP1	; 3
    220  1000					      lda	SelGfxA2_{1},y	; 4
    221  1000					      sta	GRP0	; 3 = 24
    222  1000							;	     @31
    223  1000					      lax	SelGfxA4_{1},y	; 4
    224  1000					      lda	SelGfxA3_{1},y	; 4
    225  1000					      ldy	tmpGfxA	; 3
    226  1000					      sta	GRP1	; 3 = 14    @45!
    227  1000					      stx	GRP0	; 3	     @48
    228  1000					      sty	GRP1	; 3	     @51
    229  1000					      sta	GRP0	; 3 =	9    @54!
    230  1000
    231  1000					      ldy	loopCntSel	; 3
    232  1000					      bne	LoopSelGfx{1}	; 2/3= 5/6  @59
    233  1000					      CHECKPAGE	LoopSelGfx{1}
    234  1000					      ENDM
    235  1000
    236  1000
    237  1000							;===============================================================================
    238  1000							; code starts here
    239  1000							;===============================================================================
    240  1000
    241  1000				   FREE       SET	0
    242  1000
    243  1000							;--------------------------------------------------------------------------
    244  1000
    245  1000				   SwitchToContTitleBank SUBROUTINE
    246  1000							; has to be at start of bank!
    247  1000		       a9 03		      lda	#BANK_ContTitle	; 2
    248  1002		       85 3f		      sta	SET_BANK	; 3
    249  1004		       4c f1 f1 	      jmp	NewFrameTitle	; 3 =	8
    250  1007
    251  1007				   SwitchToDrawLogoBank SUBROUTINE
    252  1007							; has to be at start of bank!
    253  1007		       a9 03		      lda	#BANK_DrawLogo	; 2
    254  1009		       85 3f		      sta	SET_BANK	; 3
    255  100b
    256  100b							; color tables for NTSC/PAL:
    257  100b				   BkColTbl
    258  100b		       82		      .byte.b	$82
    259  100c		       d2		      .byte.b	$d2
    260  100d				   StarsColTbl
    261  100d		       9a		      .byte.b	$9a
    262  100e		       da		      .byte.b	$da
    263  100f
    264  100f		       f0 0b	   TradeMarkA =	. - 4
    265  100f		       00 00 00 00*	      ds	28, 0	; bottom 7 bytes don't matter
    266  102b		       1c		      .byte.b	%00011100
    267  102c							;    .byte   %00100010
    268  102c		       22		      .byte.b	%00100010
    269  102d							;    .byte   %01010101
    270  102d		       55		      .byte.b	%01010101
    271  102e							;    .byte   %01011001
    272  102e		       55		      .byte.b	%01010101
    273  102f							;    .byte   %01011001
    274  102f		       22		      .byte.b	%00100010
    275  1030							;    .byte   %00100010
    276  1030		       1c		      .byte.b	%00011100
    277  1031		       00 00 00 00*	      ds	(TKERNEL_H-66-9-BORDER_H+1)/2, 0	;
    278  1031		       f0 37	   TradeMarkB =	. - 33
    279  1058							;    .byte   %00011100
    280  1058		       22		      .byte.b	%00100010
    281  1059							;    .byte   %00100010
    282  1059		       55		      .byte.b	%01010101
    283  105a							;    .byte   %01010101
    284  105a		       59		      .byte.b	%01011001
    285  105b							;    .byte   %01010101
    286  105b		       59		      .byte.b	%01011001
    287  105c							;    .byte   %00100010
    288  105c		       22		      .byte.b	%00100010
    289  105d							;    .byte   %00011100
    290  105d		       00 00 00 00*	      ds	(TKERNEL_H-66-9-BORDER_H+1)/2, 0	;
      0  1084					      CHECKPAGE	TradeMarkA
      8  1084					      LIST	ON
    292  1084
    293  1084							;-----------------------------------------------------------
    294  1084							; Table defining the height of each PF graphics block.
    295  1084							; Total number must be even!
    296  1084
    297  1084				   NextXTbl
    298  1084							; stop byte
    299  1084		       ff		      .byte.b	-1
    300  1085							; bottom border:
    301  1085					      REPEAT	BORDER_H/2
    302  1085		       00		      .byte.b	0
    301  1085					      REPEND
    302  1086		       00		      .byte.b	0
    301  1086					      REPEND
    302  1087		       00		      .byte.b	0
    301  1087					      REPEND
    302  1088		       00		      .byte.b	0
    303  1089					      REPEND
    304  1089					      REPEAT	GAP_H/2
    305  1089		       01		      .byte.b	1
    304  1089					      REPEND
    305  108a		       01		      .byte.b	1
    304  108a					      REPEND
    305  108b		       01		      .byte.b	1
    306  108c					      REPEND
    307  108c							; title graphics:
    308  108c				   X	      SET	2
    309  108c					      REPEAT	NUM_BLOCKS
    310  108c					      REPEAT	BLOCK_H/2
    311  108c		       02		      .byte.b	X
    310  108c					      REPEND
    311  108d		       02		      .byte.b	X
    312  108e					      REPEND
    313  108e				   X	      SET	X+1
    309  108e					      REPEND
    310  108e					      REPEAT	BLOCK_H/2
    311  108e		       03		      .byte.b	X
    310  108e					      REPEND
    311  108f		       03		      .byte.b	X
    312  1090					      REPEND
    313  1090				   X	      SET	X+1
    309  1090					      REPEND
    310  1090					      REPEAT	BLOCK_H/2
    311  1090		       04		      .byte.b	X
    310  1090					      REPEND
    311  1091		       04		      .byte.b	X
    312  1092					      REPEND
    313  1092				   X	      SET	X+1
    309  1092					      REPEND
    310  1092					      REPEAT	BLOCK_H/2
    311  1092		       05		      .byte.b	X
    310  1092					      REPEND
    311  1093		       05		      .byte.b	X
    312  1094					      REPEND
    313  1094				   X	      SET	X+1
    309  1094					      REPEND
    310  1094					      REPEAT	BLOCK_H/2
    311  1094		       06		      .byte.b	X
    310  1094					      REPEND
    311  1095		       06		      .byte.b	X
    312  1096					      REPEND
    313  1096				   X	      SET	X+1
    309  1096					      REPEND
    310  1096					      REPEAT	BLOCK_H/2
    311  1096		       07		      .byte.b	X
    310  1096					      REPEND
    311  1097		       07		      .byte.b	X
    312  1098					      REPEND
    313  1098				   X	      SET	X+1
    309  1098					      REPEND
    310  1098					      REPEAT	BLOCK_H/2
    311  1098		       08		      .byte.b	X
    310  1098					      REPEND
    311  1099		       08		      .byte.b	X
    312  109a					      REPEND
    313  109a				   X	      SET	X+1
    309  109a					      REPEND
    310  109a					      REPEAT	BLOCK_H/2
    311  109a		       09		      .byte.b	X
    310  109a					      REPEND
    311  109b		       09		      .byte.b	X
    312  109c					      REPEND
    313  109c				   X	      SET	X+1
    309  109c					      REPEND
    310  109c					      REPEAT	BLOCK_H/2
    311  109c		       0a		      .byte.b	X
    310  109c					      REPEND
    311  109d		       0a		      .byte.b	X
    312  109e					      REPEND
    313  109e				   X	      SET	X+1
    309  109e					      REPEND
    310  109e					      REPEAT	BLOCK_H/2
    311  109e		       0b		      .byte.b	X
    310  109e					      REPEND
    311  109f		       0b		      .byte.b	X
    312  10a0					      REPEND
    313  10a0				   X	      SET	X+1
    309  10a0					      REPEND
    310  10a0					      REPEAT	BLOCK_H/2
    311  10a0		       0c		      .byte.b	X
    310  10a0					      REPEND
    311  10a1		       0c		      .byte.b	X
    312  10a2					      REPEND
    313  10a2				   X	      SET	X+1
    309  10a2					      REPEND
    310  10a2					      REPEAT	BLOCK_H/2
    311  10a2		       0d		      .byte.b	X
    310  10a2					      REPEND
    311  10a3		       0d		      .byte.b	X
    312  10a4					      REPEND
    313  10a4				   X	      SET	X+1
    309  10a4					      REPEND
    310  10a4					      REPEAT	BLOCK_H/2
    311  10a4		       0e		      .byte.b	X
    310  10a4					      REPEND
    311  10a5		       0e		      .byte.b	X
    312  10a6					      REPEND
    313  10a6				   X	      SET	X+1
    309  10a6					      REPEND
    310  10a6					      REPEAT	BLOCK_H/2
    311  10a6		       0f		      .byte.b	X
    310  10a6					      REPEND
    311  10a7		       0f		      .byte.b	X
    312  10a8					      REPEND
    313  10a8				   X	      SET	X+1
    309  10a8					      REPEND
    310  10a8					      REPEAT	BLOCK_H/2
    311  10a8		       10		      .byte.b	X
    310  10a8					      REPEND
    311  10a9		       10		      .byte.b	X
    312  10aa					      REPEND
    313  10aa				   X	      SET	X+1
    309  10aa					      REPEND
    310  10aa					      REPEAT	BLOCK_H/2
    311  10aa		       11		      .byte.b	X
    310  10aa					      REPEND
    311  10ab		       11		      .byte.b	X
    312  10ac					      REPEND
    313  10ac				   X	      SET	X+1
    309  10ac					      REPEND
    310  10ac					      REPEAT	BLOCK_H/2
    311  10ac		       12		      .byte.b	X
    310  10ac					      REPEND
    311  10ad		       12		      .byte.b	X
    312  10ae					      REPEND
    313  10ae				   X	      SET	X+1
    309  10ae					      REPEND
    310  10ae					      REPEAT	BLOCK_H/2
    311  10ae		       13		      .byte.b	X
    310  10ae					      REPEND
    311  10af		       13		      .byte.b	X
    312  10b0					      REPEND
    313  10b0				   X	      SET	X+1
    309  10b0					      REPEND
    310  10b0					      REPEAT	BLOCK_H/2
    311  10b0		       14		      .byte.b	X
    310  10b0					      REPEND
    311  10b1		       14		      .byte.b	X
    312  10b2					      REPEND
    313  10b2				   X	      SET	X+1
    309  10b2					      REPEND
    310  10b2					      REPEAT	BLOCK_H/2
    311  10b2		       15		      .byte.b	X
    310  10b2					      REPEND
    311  10b3		       15		      .byte.b	X
    312  10b4					      REPEND
    313  10b4				   X	      SET	X+1
    309  10b4					      REPEND
    310  10b4					      REPEAT	BLOCK_H/2
    311  10b4		       16		      .byte.b	X
    310  10b4					      REPEND
    311  10b5		       16		      .byte.b	X
    312  10b6					      REPEND
    313  10b6				   X	      SET	X+1
    309  10b6					      REPEND
    310  10b6					      REPEAT	BLOCK_H/2
    311  10b6		       17		      .byte.b	X
    310  10b6					      REPEND
    311  10b7		       17		      .byte.b	X
    312  10b8					      REPEND
    313  10b8				   X	      SET	X+1
    309  10b8					      REPEND
    310  10b8					      REPEAT	BLOCK_H/2
    311  10b8		       18		      .byte.b	X
    310  10b8					      REPEND
    311  10b9		       18		      .byte.b	X
    312  10ba					      REPEND
    313  10ba				   X	      SET	X+1
    309  10ba					      REPEND
    310  10ba					      REPEAT	BLOCK_H/2
    311  10ba		       19		      .byte.b	X
    310  10ba					      REPEND
    311  10bb		       19		      .byte.b	X
    312  10bc					      REPEND
    313  10bc				   X	      SET	X+1
    309  10bc					      REPEND
    310  10bc					      REPEAT	BLOCK_H/2
    311  10bc		       1a		      .byte.b	X
    310  10bc					      REPEND
    311  10bd		       1a		      .byte.b	X
    312  10be					      REPEND
    313  10be				   X	      SET	X+1
    309  10be					      REPEND
    310  10be					      REPEAT	BLOCK_H/2
    311  10be		       1b		      .byte.b	X
    310  10be					      REPEND
    311  10bf		       1b		      .byte.b	X
    312  10c0					      REPEND
    313  10c0				   X	      SET	X+1
    309  10c0					      REPEND
    310  10c0					      REPEAT	BLOCK_H/2
    311  10c0		       1c		      .byte.b	X
    310  10c0					      REPEND
    311  10c1		       1c		      .byte.b	X
    312  10c2					      REPEND
    313  10c2				   X	      SET	X+1
    309  10c2					      REPEND
    310  10c2					      REPEAT	BLOCK_H/2
    311  10c2		       1d		      .byte.b	X
    310  10c2					      REPEND
    311  10c3		       1d		      .byte.b	X
    312  10c4					      REPEND
    313  10c4				   X	      SET	X+1
    309  10c4					      REPEND
    310  10c4					      REPEAT	BLOCK_H/2
    311  10c4		       1e		      .byte.b	X
    310  10c4					      REPEND
    311  10c5		       1e		      .byte.b	X
    312  10c6					      REPEND
    313  10c6				   X	      SET	X+1
    309  10c6					      REPEND
    310  10c6					      REPEAT	BLOCK_H/2
    311  10c6		       1f		      .byte.b	X
    310  10c6					      REPEND
    311  10c7		       1f		      .byte.b	X
    312  10c8					      REPEND
    313  10c8				   X	      SET	X+1
    309  10c8					      REPEND
    310  10c8					      REPEAT	BLOCK_H/2
    311  10c8		       20		      .byte.b	X
    310  10c8					      REPEND
    311  10c9		       20		      .byte.b	X
    312  10ca					      REPEND
    313  10ca				   X	      SET	X+1
    309  10ca					      REPEND
    310  10ca					      REPEAT	BLOCK_H/2
    311  10ca		       21		      .byte.b	X
    310  10ca					      REPEND
    311  10cb		       21		      .byte.b	X
    312  10cc					      REPEND
    313  10cc				   X	      SET	X+1
    309  10cc					      REPEND
    310  10cc					      REPEAT	BLOCK_H/2
    311  10cc		       22		      .byte.b	X
    310  10cc					      REPEND
    311  10cd		       22		      .byte.b	X
    312  10ce					      REPEND
    313  10ce				   X	      SET	X+1
    314  10ce					      REPEND
    315  10ce							; top border:
    316  10ce					      REPEAT	GAP_H/2
    317  10ce		       01		      .byte.b	1	; use symmetry
    316  10ce					      REPEND
    317  10cf		       01		      .byte.b	1	; use symmetry
    316  10cf					      REPEND
    317  10d0		       01		      .byte.b	1	; use symmetry
    318  10d1					      REPEND
    319  10d1				   X	      SET	X+1
    320  10d1					      REPEAT	BORDER_H/2
    321  10d1		       00		      .byte.b	0	; use symmetry
    320  10d1					      REPEND
    321  10d2		       00		      .byte.b	0	; use symmetry
    320  10d2					      REPEND
    321  10d3		       00		      .byte.b	0	; use symmetry
    320  10d3					      REPEND
    321  10d4		       00		      .byte.b	0	; use symmetry
    322  10d5					      REPEND
      0  10d5					      CHECKPAGE	NextXTbl
      8  10d5					      LIST	ON
    324  10d5
    325  10d5							;-----------------------------------------------------------
    326  10d5							; BOULDER DASH PF graphics data:
    327  10d5
    328  10d5				   title_STRIP_0
    329  10d5		       f0		      .byte.b	240
    330  10d6		       10		      .byte.b	16
    331  10d7		       10		      .byte.b	16
    332  10d8		       10		      .byte.b	16
    333  10d9		       10		      .byte.b	16
    334  10da		       10		      .byte.b	16
    335  10db		       10		      .byte.b	16
    336  10dc		       10		      .byte.b	16
    337  10dd		       10		      .byte.b	16
    338  10de		       10		      .byte.b	16
    339  10df		       10		      .byte.b	16
    340  10e0		       10		      .byte.b	16
    341  10e1		       10		      .byte.b	16
    342  10e2		       10		      .byte.b	16
    343  10e3		       10		      .byte.b	16
    344  10e4		       10		      .byte.b	16
    345  10e5		       10		      .byte.b	16
    346  10e6		       10		      .byte.b	16
    347  10e7		       10		      .byte.b	16
    348  10e8		       d0		      .byte.b	208
    349  10e9		       d0		      .byte.b	208
    350  10ea		       d0		      .byte.b	208
    351  10eb		       d0		      .byte.b	208
    352  10ec		       d0		      .byte.b	208
    353  10ed		       d0		      .byte.b	208
    354  10ee		       d0		      .byte.b	208
    355  10ef		       d0		      .byte.b	208
    356  10f0		       d0		      .byte.b	208
    357  10f1		       d0		      .byte.b	208
    358  10f2		       d0		      .byte.b	208
    359  10f3		       d0		      .byte.b	208
    360  10f4		       d0		      .byte.b	208
    361  10f5		       d0		      .byte.b	208
    362  10f6		       d0		      .byte.b	208
    363  10f7		       d0		      .byte.b	208
      0  10f8					      CHECKPAGE	title_STRIP_0
      8  10f8					      LIST	ON
    365  10f8
      0  10f8					      ALIGN_FREE	256
      1  10f8				   FREE       SET	FREE - .
      2  1100		       00 00 00 00*	      align	256
      3  1100				   FREE       SET	FREE + .
 @ $f100 : $8
      4  1100					      echo	"@", ., ":", FREE
    367  1100
    368  1100				   title_STRIP_1
    369  1100		       ff		      .byte.b	255
    370  1101		       00		      .byte.b	0
    371  1102		       03		      .byte.b	3
    372  1103		       03		      .byte.b	3
    373  1104		       03		      .byte.b	3
    374  1105		       03		      .byte.b	3
    375  1106		       03		      .byte.b	3
    376  1107		       03		      .byte.b	3
    377  1108		       03		      .byte.b	3
    378  1109		       03		      .byte.b	3
    379  110a		       03		      .byte.b	3
    380  110b		       03		      .byte.b	3
    381  110c		       03		      .byte.b	3
    382  110d		       03		      .byte.b	3
    383  110e		       03		      .byte.b	3
    384  110f		       03		      .byte.b	3
    385  1110		       03		      .byte.b	3
    386  1111		       03		      .byte.b	3
    387  1112		       00		      .byte.b	0
    388  1113		       cf		      .byte.b	207
    389  1114		       ef		      .byte.b	239
    390  1115		       ef		      .byte.b	239
    391  1116		       ef		      .byte.b	239
    392  1117		       2d		      .byte.b	45
    393  1118		       2d		      .byte.b	45
    394  1119		       2d		      .byte.b	45
    395  111a		       2d		      .byte.b	45
    396  111b		       ed		      .byte.b	237
    397  111c		       ed		      .byte.b	237
    398  111d		       cd		      .byte.b	205
    399  111e		       ed		      .byte.b	237
    400  111f		       2d		      .byte.b	45
    401  1120		       2f		      .byte.b	47
    402  1121		       ef		      .byte.b	239
    403  1122		       c0		      .byte.b	192
      0  1123					      CHECKPAGE	title_STRIP_1
      8  1123					      LIST	ON
    405  1123
    406  1123				   title_STRIP_2
    407  1123		       ff		      .byte.b	255
    408  1124		       00		      .byte.b	0
    409  1125		       b3		      .byte.b	179
    410  1126		       b7		      .byte.b	183
    411  1127		       b7		      .byte.b	183
    412  1128		       b7		      .byte.b	183
    413  1129		       b7		      .byte.b	183
    414  112a		       b4		      .byte.b	180
    415  112b		       b4		      .byte.b	180
    416  112c		       f4		      .byte.b	244
    417  112d		       f4		      .byte.b	244
    418  112e		       b4		      .byte.b	180
    419  112f		       b4		      .byte.b	180
    420  1130		       b4		      .byte.b	180
    421  1131		       b4		      .byte.b	180
    422  1132		       e4		      .byte.b	228
    423  1133		       67		      .byte.b	%01100111
    424  1134		       03		      .byte.b	3
    425  1135		       00		      .byte.b	0
    426  1136		       de		      .byte.b	222
    427  1137		       de		      .byte.b	222
    428  1138		       de		      .byte.b	222
    429  1139		       de		      .byte.b	222
    430  113a		       d6		      .byte.b	214
    431  113b		       d6		      .byte.b	214
    432  113c		       d6		      .byte.b	214
    433  113d		       d6		      .byte.b	214
    434  113e		       d6		      .byte.b	214
    435  113f		       d6		      .byte.b	214
    436  1140		       d6		      .byte.b	214
    437  1141		       d6		      .byte.b	214
    438  1142		       d6		      .byte.b	214
    439  1143		       d6		      .byte.b	214
    440  1144		       d6		      .byte.b	214
    441  1145		       00		      .byte.b	0
      0  1146					      CHECKPAGE	title_STRIP_2
      8  1146					      LIST	ON
    443  1146
    444  1146				   title_STRIP_3
    445  1146		       f0		      .byte.b	240
    446  1147		       00		      .byte.b	0
    447  1148		       e0		      .byte.b	224
    448  1149		       e0		      .byte.b	224
    449  114a		       e0		      .byte.b	224
    450  114b		       e0		      .byte.b	224
    451  114c		       00		      .byte.b	0
    452  114d		       00		      .byte.b	0
    453  114e		       00		      .byte.b	0
    454  114f		       e0		      .byte.b	224
    455  1150		       e0		      .byte.b	224
    456  1151		       e0		      .byte.b	224
    457  1152		       60		      .byte.b	96
    458  1153		       60		      .byte.b	96
    459  1154		       60		      .byte.b	96
    460  1155		       e0		      .byte.b	224
    461  1156		       e0		      .byte.b	224
    462  1157		       00		      .byte.b	0
    463  1158		       00		      .byte.b	0
    464  1159		       b0		      .byte.b	176
    465  115a		       b0		      .byte.b	176
    466  115b		       b0		      .byte.b	176
    467  115c		       b0		      .byte.b	176
    468  115d		       80		      .byte.b	128
    469  115e		       80		      .byte.b	128
    470  115f		       80		      .byte.b	128
    471  1160		       80		      .byte.b	128
    472  1161		       80		      .byte.b	128
    473  1162		       80		      .byte.b	128
    474  1163		       80		      .byte.b	128
    475  1164		       80		      .byte.b	128
    476  1165		       80		      .byte.b	128
    477  1166		       80		      .byte.b	128
    478  1167		       80		      .byte.b	128
    479  1168		       00		      .byte.b	0
      0  1169					      CHECKPAGE	title_STRIP_3
      8  1169					      LIST	ON
    481  1169
    482  1169				   title_STRIP_4
    483  1169		       ff		      .byte.b	255
    484  116a		       00		      .byte.b	0
    485  116b		       b4		      .byte.b	180
    486  116c		       b4		      .byte.b	180
    487  116d		       b4		      .byte.b	180
    488  116e		       b4		      .byte.b	180
    489  116f		       b4		      .byte.b	180
    490  1170		       b4		      .byte.b	180
    491  1171		       b4		      .byte.b	180
    492  1172		       bc		      .byte.b	188
    493  1173		       bc		      .byte.b	188
    494  1174		       bc		      .byte.b	188
    495  1175		       34		      .byte.b	52
    496  1176		       34		      .byte.b	52
    497  1177		       34		      .byte.b	52
    498  1178		       b4		      .byte.b	180
    499  1179		       b4		      .byte.b	180
    500  117a		       00		      .byte.b	0
    501  117b		       00		      .byte.b	0
    502  117c		       e7		      .byte.b	231
    503  117d		       f7		      .byte.b	247
    504  117e		       f7		      .byte.b	247
    505  117f		       f7		      .byte.b	247
    506  1180		       96		      .byte.b	150
    507  1181		       96		      .byte.b	150
    508  1182		       96		      .byte.b	150
    509  1183		       97		      .byte.b	151
    510  1184		       97		      .byte.b	151
    511  1185		       97		      .byte.b	151
    512  1186		       96		      .byte.b	150
    513  1187		       96		      .byte.b	150
    514  1188		       96		      .byte.b	150
    515  1189		       f7		      .byte.b	247
    516  118a		       e7		      .byte.b	231
    517  118b		       00		      .byte.b	0
      0  118c					      CHECKPAGE	title_STRIP_4
      8  118c					      LIST	ON
    519  118c
    520  118c				   title_STRIP_5
    521  118c		       ff		      .byte.b	255
    522  118d		       80		      .byte.b	128
    523  118e		       80		      .byte.b	128
    524  118f		       80		      .byte.b	128
    525  1190		       80		      .byte.b	128
    526  1191		       80		      .byte.b	128
    527  1192		       80		      .byte.b	128
    528  1193		       80		      .byte.b	128
    529  1194		       80		      .byte.b	128
    530  1195		       80		      .byte.b	128
    531  1196		       80		      .byte.b	128
    532  1197		       80		      .byte.b	128
    533  1198		       80		      .byte.b	128
    534  1199		       80		      .byte.b	128
    535  119a		       80		      .byte.b	128
    536  119b		       80		      .byte.b	128
    537  119c		       80		      .byte.b	128
    538  119d		       80		      .byte.b	128
    539  119e		       80		      .byte.b	128
    540  119f		       ad		      .byte.b	173
    541  11a0		       ad		      .byte.b	173
    542  11a1		       ad		      .byte.b	173
    543  11a2		       ad		      .byte.b	173
    544  11a3		       bc		      .byte.b	188
    545  11a4		       bc		      .byte.b	188
    546  11a5		       9c		      .byte.b	156
    547  11a6		       bc		      .byte.b	188
    548  11a7		       ac		      .byte.b	172
    549  11a8		       ac		      .byte.b	172
    550  11a9		       ac		      .byte.b	172
    551  11aa		       ac		      .byte.b	172
    552  11ab		       ac		      .byte.b	172
    553  11ac		       bd		      .byte.b	189
    554  11ad		       9d		      .byte.b	157
    555  11ae		       80		      .byte.b	128
      0  11af					      CHECKPAGE	title_STRIP_5
      8  11af					      LIST	ON
    557  11af
    558  11af							;    ALIGN_FREE 256
    559  11af
    560  11af							;    ds  $1d, 0
    561  11af							; kernel alignment
    562  11af							;    ds  11, 0
    563  11af							;------------------------------------------------------------------------------
    564  11af
      0  11af					      DEFINE_SUBROUTINE	TitleScreen
      1  11af		       00 02	   BANK_TitleScreen =	_CURRENT_BANK
      2  11af					      SUBROUTINE
      3  11af				   TitleScreen
    566  11af
    567  11af							; clear TIA:
    568  11af		       a9 00		      lda	#0
    569  11b1		       a2 2c		      ldx	#CXCLR-TIA_BASE_ADDRESS
    570  11b3				   .loopClearTIA
    571  11b3		       95 40		      sta	TIA_BASE_ADDRESS,x
    572  11b5		       ca		      dex
    573  11b6		       10 fb		      bpl	.loopClearTIA
    574  11b8
    575  11b8							; clear title RAM to avoid initial sound disturbances
    576  11b8		       a2 7d		      ldx	#endOfTitleRAM-startOfTitleRAM
    577  11ba				   .loopClearRAM
    578  11ba		       ca		      dex
    579  11bb		       95 82		      sta	startOfTitleRAM,x
    580  11bd		       d0 fb		      bne	.loopClearRAM
    581  11bf
    582  11bf		       e6 8a		      inc	noteLen	; 5	     == 1
    583  11c1		       e6 86		      inc	titleMode
    584  11c3
    585  11c3		       a9 02		      lda	#BANK_TitleScreen
    586  11c5		       85 c3		      sta	ROM_Bank
    587  11c7
    588  11c7		       a9 f6		      lda	#>CharGfx
    589  11c9		       85 9a		      sta	ptrGfxA+1
    590  11cb		       85 9c		      sta	ptrGfxB+1
    591  11cd
    592  11cd		       20 d5 f7 	      jsr	DetectConsole
    593  11d0
    594  11d0							; special resync required here, since PAL-60 is not supported:
    595  11d0							;    RESYNC			      ; 		  -> X, Y == 0
    596  11d0
    597  11d0							; resync screen, X and Y == 0 afterwards
    598  11d0							;	  lda #%10			  ; make sure VBLANK is ON
    599  11d0		       85 41		      sta	VBLANK
    600  11d2
    601  11d2		       a2 08		      ldx	#8	; 5 or more RESYNC_FRAMES
    602  11d4				   .loopResync
      0  11d4					      VERTICAL_SYNC
      1  11d4		       a9 0e		      lda	#%1110
      2  11d6		       85 42	   .VSLP1     sta	WSYNC
      3  11d8		       85 40		      sta	VSYNC
      4  11da		       4a		      lsr
      5  11db		       d0 f9		      bne	.VSLP1
    604  11dd
    605  11dd		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
    606  11df		       a5 81		      lda	Platform
    607  11e1		       29 02		      and	#PAL	; only test for PAL (carry unharmed!)
    608  11e3		       f0 02		      beq	.ntsc
    609  11e5		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
    610  11e7				   .ntsc
    611  11e7				   .loopWait
    612  11e7		       85 42		      sta	WSYNC
    613  11e9		       85 42		      sta	WSYNC
    614  11eb		       88		      dey
    615  11ec		       d0 f9		      bne	.loopWait
    616  11ee		       ca		      dex
    617  11ef		       d0 e3		      bne	.loopResync
    618  11f1
    619  11f1
    620  11f1							;    clc			      ; 		 can be removed after debugging
    621  11f1
    622  11f1				   NewFrameTitle SUBROUTINE
    623  11f1
    624  11f1							; start of vertical sync processing:
    625  11f1				   VerticalSync
    626  11f1							; Y = 00!
    627  11f1							;---------------------------------------
    628  11f1				   TEST1
    629  11f1							;    jsr     UpdateMusicWSync1       ;39	  @13
      0  11f1					      UPDATE_MUSIC_WSYNC	1	;27	     @07
      0  11f1					      UPDATE_MUSIC_DATA	1
      0  11f1					      UPDATE_MUSIC_DATA_LO	1
      0  11f1					      CHECK_CLC
      1  11f1
      2  11f1
      3  11f1		       a5 92		      lda	audv1Lo
      4  11f3		       65 8d		      adc	note1
      5  11f5		       85 92		      sta	audv1Lo
      0  11f7					      UPDATE_MUSIC_DATA_HI	1
      1  11f7		       a5 93		      lda	audv1Hi
      2  11f9		       69 00		      adc	#0
      3  11fb		       85 93		      sta	audv1Hi
      2  11fd		       85 42		      sta	WSYNC
      3  11ff
      0  11ff					      UPDATE_MUSIC_VOL	1
      0  11ff					      UPDATE_MUSIC_PREP_VOL	1
      1  11ff		       29 06		      and	#VOL_MASK/2
      2  1201		       0a		      asl
      0  1202					      UPDATE_MUSIC_SET_VOL	1
      1  1202					      IF	PLAY_CH_1 == YES
      2  1202		       85 5a		      sta	AUDV1
      3  1204				  -	      ELSE
      4  1204				  -	      nop	AUDV1
      5  1204					      ENDIF
    631  1204		       a9 72		      lda	#$72	; 2		     this value is important for the stars effect
    632  1206		       85 63		      sta	HMM1	; 3
    633  1208		       85 40		      sta	VSYNC	; 3 =	8	     enable VSYNC
    634  120a							; put into here, just because we have time:
    635  120a		       a9 0e		      lda	#TWHITE	; 2
    636  120c		       85 48		      sta	COLUPF	; 3
    637  120e		       85 46		      sta	COLUP0	; 3 =	8
    638  1210
    639  1210							; prepare data for 1st screen row:
    640  1210		       a5 86		      lda	titleMode	; 3
    641  1212		       f0 06		      beq	.selMode	; 2/3
    642  1214							; for logo screen:
    643  1214		       a2 90		      ldx	#$90	; 2
    644  1216		       86 60		      stx	HMP0	; 3
    645  1218		       d0 05		      bne	.setHMP0	; 3
    646  121a
    647  121a							; for selection screen:
    648  121a				   .selMode		; 6
    649  121a		       a6 89		      ldx	hmJunior	; 3		     $f0/$50
    650  121c		       86 61		      stx	HMP1	; 3
    651  121e		       ca		      dex		; 2
    652  121f				   .setHMP0
    653  121f		       86 60		      stx	HMP0	; 3 = 16
    654  1221
    655  1221							;    ldy     #0
    656  1221		       2c 82 02 	      bit	SWCHB	; 4
    657  1224					      IF	NTSC_MODE = YES
    658  1224		       10 01		      bpl	.primaryPlatform	; 2/3
    659  1226				  -	      ELSE
    660  1226				  -	      bmi	.primaryPlatform	; 2/3
    661  1226					      ENDIF
    662  1226		       c8		      iny		; 2
    663  1227				   .primaryPlatform
    664  1227		       84 81		      sty	Platform	; 3 = 11    @47     P1 difficulty --> TV system (0=NTSC, 1=PAL)
    665  1229
    666  1229		       c6 8a		      dec	noteLen	; 5		     update frame counter
    667  122b							; free: 1
    668  122b							;---------------------------------------
    669  122b							;    jsr     UpdateMusicWSync0       ;39	  @13
      0  122b					      UPDATE_MUSIC_WSYNC	0	;27
      0  122b					      UPDATE_MUSIC_DATA	0
      0  122b					      UPDATE_MUSIC_DATA_LO	0
      0  122b					      CHECK_CLC
      1  122b
      2  122b
      3  122b		       a5 90		      lda	audv0Lo
      4  122d		       65 8c		      adc	note0
      5  122f		       85 90		      sta	audv0Lo
      0  1231					      UPDATE_MUSIC_DATA_HI	0
      1  1231		       a5 91		      lda	audv0Hi
      2  1233		       69 00		      adc	#0
      3  1235		       85 91		      sta	audv0Hi
      2  1237		       85 42		      sta	WSYNC
      3  1239
      0  1239					      UPDATE_MUSIC_VOL	0
      0  1239					      UPDATE_MUSIC_PREP_VOL	0
      1  1239		       29 06		      and	#VOL_MASK/2
      2  123b		       0a		      asl
      0  123c					      UPDATE_MUSIC_SET_VOL	0
      1  123c					      IF	PLAY_CH_0 == YES
      2  123c		       85 59		      sta	AUDV0
      3  123e				  -	      ELSE
      4  123e				  -	      nop	AUDV0
      5  123e					      ENDIF
    671  123e
    672  123e							; prepare data for 1st screen row:
    673  123e		       a6 86		      ldx	titleMode	; 3
    674  1240		       f0 05		      beq	.selMode2	; 2/3
    675  1242					      IF	DEMO_VERSION = NO
    676  1242		       ca		      dex
    677  1243				  -	      ELSE
    678  1243				  -	      nop		;		     start with 2nd row in demo version because cave cannot be changed anyway
    679  1243					      ENDIF
    680  1243		       86 9d		      stx	selRow	; 3
    681  1245		       10 19		      bpl	.skipJoyX
    682  1247
    683  1247				   .selMode2
    684  1247
    685  1247		       a5 8a		      lda	noteLen	; 3
    686  1249		       d0 15		      bne	.skipJoyX	; 2/3= 5
    687  124b
    688  124b		       a4 9d		      ldy	selRow	; 3
    689  124d		       b6 82		      ldx	selLst,y	; 4 =	7
    690  124f
    691  124f		       ad 80 02 	      lda	SWCHA	; 4
    692  1252		       0a		      asl		; 2
    693  1253		       b0 03		      bcs	.notRight	; 2/3
    694  1255		       e8		      inx		; 2
    695  1256		       10 06		      bpl	.setJoyX	; 3
    696  1258
    697  1258				   .notRight		; 9
    698  1258		       18		      clc		; 2
    699  1259		       30 03		      bmi	.notLeft	; 2/3
    700  125b		       ca		      dex		; 2
    701  125c		       30 02		      bmi	.skipJoyX	; 2/3
    702  125e				   .notLeft
    703  125e				   .setJoyX
    704  125e		       96 82		      stx	selLst,y	; 4
    705  1260				   .skipJoyX		;   = 21 max
    706  1260		       a0 00		      ldy	#0	; 2
    707  1262							;---------------------------------------
    708  1262		       20 1a f4 	      jsr	UpdateMusicWSync1	;39	     @13
    709  1265
    710  1265							; limit selection values:
    711  1265
    712  1265				  -	      IF	FINAL_VERSION = YES
    713  1265				  -			; limit cave:
    714  1265				  -	      lda	sLevel	; 3
    715  1265				  -	      cmp	#3	; 2		     above level 3 only cave A is allowed
    716  1265				  -	      bcc	.lowLevel	; 2/3
    717  1265				  -	      sty	sCave	; 3 = 10
    718  1265				  -.lowLevel
    719  1265					      ENDIF
    720  1265
    721  1265							; limit joysticks:
    722  1265		       a5 84		      lda	sPlayers	; 3
    723  1267		       d0 02		      bne	.twoPlayers	; 2/3
    724  1269		       84 85		      sty	sJoysticks	; 3 =	8
    725  126b
    726  126b							; limit current selection:
    727  126b				   .twoPlayers
    728  126b		       a6 9d		      ldx	selRow	; 3
    729  126d		       bd cf f7 	      lda	SelMaxTbl,x	; 4
    730  1270		       d5 82		      cmp	selLst,x	; 3
    731  1272		       b0 02		      bcs	.selOk	; 2/3
    732  1274		       95 82		      sta	selLst,x	; 4
    733  1276				   .selOk
    734  1276		       18		      clc		; 2 = 18
    735  1277							; free: 1
    736  1277							;---------------------------------------
    737  1277		       20 06 f4 	      jsr	UpdateMusicWSync0	;39	     @13
    738  127a		       84 40		      sty	VSYNC	; 3	     @16     disable VSYNC
    739  127c
      0  127c					      UPDATE_MUSIC_DATA_LO	0	; 9
      0  127c					      CHECK_CLC
      1  127c
      2  127c
      3  127c		       a5 90		      lda	audv0Lo
      4  127e		       65 8c		      adc	note0
      5  1280		       85 90		      sta	audv0Lo
    741  1282		       08		      php		; 3 = 12    @28
    742  1283							;    clc			      ; 2 = 14	  @30
    743  1283
    744  1283		       e6 87		      inc	counter	; 5
    745  1285		       a5 87		      lda	counter	; 3
    746  1287		       29 38		      and	#%111000	; 2
    747  1289		       4a		      lsr		; 2
    748  128a		       4a		      lsr		; 2
    749  128b		       4a		      lsr		; 2
    750  128c		       aa		      tax		; 2 = 18    @48
    751  128d							; free: 4
    752  128d							;---------------------------------------
    753  128d		       20 1a f4 	      jsr	UpdateMusicWSync1	;39	     @13
    754  1290				   .r2
    755  1290		       ca		      dex		; 2
    756  1291		       10 fd		      bpl	.r2	; 2/3
    757  1293		       85 53		      sta	RESM1	; 3	     @20..55
    758  1295
    759  1295		       28		      plp		; 4
      0  1296					      UPDATE_MUSIC_DATA_HI	0	; 8
      1  1296		       a5 91		      lda	audv0Hi
      2  1298		       69 00		      adc	#0
      3  129a		       85 91		      sta	audv0Hi
      0  129c					      UPDATE_MUSIC_PREP_VOL	0	; 4
      1  129c		       29 06		      and	#VOL_MASK/2
      2  129e		       0a		      asl
    762  129f							; free: 2
    763  129f		       85 42		      sta	WSYNC	; 3
    764  12a1							;---------------------------------------
    765  12a1		       85 6a		      sta	HMOVE	; 3
      0  12a3					      UPDATE_MUSIC_SET_VOL_W	0	; 7	     @07!    <-- AUDV0
      1  12a3					      IF	PLAY_CH_0 == YES
      2  12a3		       8d 59 00 	      sta.w	AUDV0
      3  12a6				  -	      ELSE
      4  12a6				  -	      nop.w	AUDV0
      5  12a6					      ENDIF
    767  12a6		       20 2d f4 	      jsr	Wait12	;12		     waste 18 cycles and load move value
    768  12a9		       88		      dey		; 2
    769  12aa		       84 63		      sty	HMM1	; 3	     @27     this is the tricky part
    770  12ac
    771  12ac							;-----------------------------------------------------------
    772  12ac
    773  12ac					      IF	L276
    774  12ac		       a0 07		      ldy	#(38-PC_TOP/2)/2	; 2
    775  12ae				  -	      ELSE
    776  12ae				  -	      ldy	#(32-PC_TOP/2)/2	; 2
    777  12ae					      ENDIF
    778  12ae		       a5 81		      lda	Platform	; 3
    779  12b0		       f0 02		      beq	.vSyncNTSC	; 2/3
    780  12b2		       a0 16		      ldy	#(68-PC_TOP/2)/2	; 2 = 11
    781  12b4				   .vSyncNTSC		;	     @38
    782  12b4		       84 96		      sty	tmpY	; 3
    783  12b6
    784  12b6		       a4 cf		      ldy	audV0Lst+PC_TOP	; 3		     take the last precalculated hi value
    785  12b8							; here we precalculate another 48 values
    786  12b8		       a2 2f		      ldx	#PC_TOP-1	; 2 =	8
    787  12ba							; free: 10
    788  12ba				   .loopVSync		;	     @46
    789  12ba							;---------------------------------------
      0  12ba					      UPDATE_MUSIC_WSYNC	1	;27	     @07     maintain sound while precalcuating
      0  12ba					      UPDATE_MUSIC_DATA	1
      0  12ba					      UPDATE_MUSIC_DATA_LO	1
      0  12ba					      CHECK_CLC
      1  12ba
      2  12ba
      3  12ba		       a5 92		      lda	audv1Lo
      4  12bc		       65 8d		      adc	note1
      5  12be		       85 92		      sta	audv1Lo
      0  12c0					      UPDATE_MUSIC_DATA_HI	1
      1  12c0		       a5 93		      lda	audv1Hi
      2  12c2		       69 00		      adc	#0
      3  12c4		       85 93		      sta	audv1Hi
      2  12c6		       85 42		      sta	WSYNC
      3  12c8
      0  12c8					      UPDATE_MUSIC_VOL	1
      0  12c8					      UPDATE_MUSIC_PREP_VOL	1
      1  12c8		       29 06		      and	#VOL_MASK/2
      2  12ca		       0a		      asl
      0  12cb					      UPDATE_MUSIC_SET_VOL	1
      1  12cb					      IF	PLAY_CH_1 == YES
      2  12cb		       85 5a		      sta	AUDV1
      3  12cd				  -	      ELSE
      4  12cd				  -	      nop	AUDV1
      5  12cd					      ENDIF
    791  12cd							; 1st calculation:
      0  12cd					      CHECK_CLC
      1  12cd
    793  12cd		       a5 9e		      lda	audvTmpLo	; 3
    794  12cf		       65 8c		      adc	note0	; 3 =	6
    795  12d1		       90 03		      bcc	.skipHi1	; 2/3
    796  12d3		       c8		      iny		; 2
    797  12d4		       c8		      iny		; 2
    798  12d5		       18		      clc		; 2
    799  12d6				   .skipHi1
    800  12d6		       94 9f		      sty	audV0Lst,x	; 4
    801  12d8		       ca		      dex		; 2 = 14
    802  12d9							; 2nd calculation:
      0  12d9					      CHECK_CLC
      1  12d9
    804  12d9		       65 8c		      adc	note0	; 3
    805  12db		       85 9e		      sta	audvTmpLo	; 3 =	6
    806  12dd		       90 03		      bcc	.skipHi2	; 2/3
    807  12df		       c8		      iny		; 2
    808  12e0		       c8		      iny		; 2
    809  12e1		       18		      clc		; 2
    810  12e2				   .skipHi2
    811  12e2		       94 9f		      sty	audV0Lst,x	; 4
    812  12e4		       ca		      dex		; 2 = 14
    813  12e5							;	     @47 max
    814  12e5							;---------------------------------------
      0  12e5					      UPDATE_MUSIC_WSYNC	0	;27	     @07     maintain sound while precalcuating
      0  12e5					      UPDATE_MUSIC_DATA	0
      0  12e5					      UPDATE_MUSIC_DATA_LO	0
      0  12e5					      CHECK_CLC
      1  12e5
      2  12e5
      3  12e5		       a5 90		      lda	audv0Lo
      4  12e7		       65 8c		      adc	note0
      5  12e9		       85 90		      sta	audv0Lo
      0  12eb					      UPDATE_MUSIC_DATA_HI	0
      1  12eb		       a5 91		      lda	audv0Hi
      2  12ed		       69 00		      adc	#0
      3  12ef		       85 91		      sta	audv0Hi
      2  12f1		       85 42		      sta	WSYNC
      3  12f3
      0  12f3					      UPDATE_MUSIC_VOL	0
      0  12f3					      UPDATE_MUSIC_PREP_VOL	0
      1  12f3		       29 06		      and	#VOL_MASK/2
      2  12f5		       0a		      asl
      0  12f6					      UPDATE_MUSIC_SET_VOL	0
      1  12f6					      IF	PLAY_CH_0 == YES
      2  12f6		       85 59		      sta	AUDV0
      3  12f8				  -	      ELSE
      4  12f8				  -	      nop	AUDV0
      5  12f8					      ENDIF
    816  12f8							; 3rd calculation:
      0  12f8					      CHECK_CLC
      1  12f8
    818  12f8		       a5 9e		      lda	audvTmpLo	; 3
    819  12fa		       65 8c		      adc	note0	; 3 =	6
    820  12fc		       90 03		      bcc	.skipHi3	; 2/3
    821  12fe		       c8		      iny		; 2
    822  12ff		       c8		      iny		; 2
    823  1300		       18		      clc		; 2
    824  1301				   .skipHi3
    825  1301		       94 9f		      sty	audV0Lst,x	; 4
    826  1303		       ca		      dex		; 2 = 14
    827  1304							; 4th calculation:
      0  1304					      CHECK_CLC
      1  1304
    829  1304		       65 8c		      adc	note0	; 3
    830  1306		       85 9e		      sta	audvTmpLo	; 3 =	6
    831  1308		       90 03		      bcc	.skipHi4	; 2/3
    832  130a		       c8		      iny		; 2
    833  130b		       c8		      iny		; 2
    834  130c		       18		      clc		; 2
    835  130d				   .skipHi4
    836  130d		       94 9f		      sty	audV0Lst,x	; 4
    837  130f		       ca		      dex		; 2 = 14
    838  1310		       10 a8		      bpl	.loopVSync	; 2/3
    839  1312							;	     @49 max
    840  1312		       a6 96		      ldx	tmpY	; 3
    841  1314							; do the remaining scanlines (required for PAL)
    842  1314				   .waitVSync
    843  1314							;---------------------------------------
      0  1314					      UPDATE_MUSIC_WSYNC	1	;27	     @07
      0  1314					      UPDATE_MUSIC_DATA	1
      0  1314					      UPDATE_MUSIC_DATA_LO	1
      0  1314					      CHECK_CLC
      1  1314
      2  1314
      3  1314		       a5 92		      lda	audv1Lo
      4  1316		       65 8d		      adc	note1
      5  1318		       85 92		      sta	audv1Lo
      0  131a					      UPDATE_MUSIC_DATA_HI	1
      1  131a		       a5 93		      lda	audv1Hi
      2  131c		       69 00		      adc	#0
      3  131e		       85 93		      sta	audv1Hi
      2  1320		       85 42		      sta	WSYNC
      3  1322
      0  1322					      UPDATE_MUSIC_VOL	1
      0  1322					      UPDATE_MUSIC_PREP_VOL	1
      1  1322		       29 06		      and	#VOL_MASK/2
      2  1324		       0a		      asl
      0  1325					      UPDATE_MUSIC_SET_VOL	1
      1  1325					      IF	PLAY_CH_1 == YES
      2  1325		       85 5a		      sta	AUDV1
      3  1327				  -	      ELSE
      4  1327				  -	      nop	AUDV1
      5  1327					      ENDIF
    845  1327
    846  1327		       e0 01		      cpx	#1
    847  1329		       18		      clc
    848  132a		       f0 0e		      beq	.lastLoop
    849  132c
    850  132c		       a4 82		      ldy	sCave
    851  132e		       b9 9d f7 	      lda	SelCharAPtr,y	; 4
    852  1331		       85 99		      sta	ptrGfxA	; 3
    853  1333		       b9 b1 f7 	      lda	SelCharBPtr,y	; 4
    854  1336		       85 9b		      sta	ptrGfxB	; 3
    855  1338		       90 1c		      bcc	.endLoop	; 3 = 17
    856  133a
    857  133a				   .lastLoop
    858  133a		       a0 03		      ldy	#LKERNEL_H/8-1	; 2
    859  133c		       84 98		      sty	loopCntSel	; 3
    860  133e		       b1 99		      lda	(ptrGfxA),y	; 5
    861  1340		       85 96		      sta	tmpGfxA	; 3 = 13
    862  1342
    863  1342		       a4 81		      ldy	Platform	; 3
    864  1344		       b9 0b f0 	      lda	BkColTbl,y	; 4
    865  1347		       85 49		      sta	COLUBK	; 3 = 10
    866  1349
    867  1349							; prepare data for 1st selection screen row:
    868  1349		       a5 9d		      lda	selRow	; 3
    869  134b		       f0 04		      beq	.isSel	; 2/3
    870  134d		       a9 0a		      lda	#NOT_SEL_COL	; 2
    871  134f		       d0 03		      bne	.notSel	; 3
    872  1351
    873  1351				   .isSel
    874  1351		       b9 fc f6 	      lda	SelectionColTbl,y	; 4
    875  1354				   .notSel
    876  1354		       85 97		      sta	tmpGfxB	; 3 = 13
    877  1356				   .endLoop
    878  1356							;---------------------------------------
    879  1356		       20 06 f4 	      jsr	UpdateMusicWSync0	;39	     @13
    880  1359		       ca		      dex		; 2
    881  135a		       d0 b8		      bne	.waitVSync	; 2/3
    882  135c
    883  135c							;------------------------------------------------------------------------------
    884  135c							; START OF DISPLAY
    885  135c							;				     ;		 @17
    886  135c		       b9 0d f0 	      lda	StarsColTbl,y	; 4		     Y is still set from above!
    887  135f		       85 47		      sta	COLUP1	; 3 =	7    @24
    888  1361
    889  1361		       a2 00		      ldx	#0	; 2	     also used for kernel!
    890  1363		       86 65		      stx	VDELP0	; 3
    891  1365		       86 44		      stx	NUSIZ0	; 3 =	8    @32
    892  1367
    893  1367		       a9 15		      lda	#%10101	; 2	     double width missile, double width player
    894  1369		       85 45		      sta	NUSIZ1	; 3
    895  136b		       4a		      lsr		; 2	     bit 1 is set, turn missile0 on
    896  136c		       85 5e		      sta	ENAM1	; 3
    897  136e		       0a		      asl		; 2
    898  136f		       85 4a		      sta	CTRLPF	; 3 = 15    @47     = %00010100
    899  1371
    900  1371		       a0 50		      ldy	#TKERNEL_H/2	; 2	     total number of scanlines to display (160, was 149)
    901  1373
      0  1373					      UPDATE_MUSIC_DATA_LO	1	; 9
      0  1373					      CHECK_CLC
      1  1373
      2  1373
      3  1373		       a5 92		      lda	audv1Lo
      4  1375		       65 8d		      adc	note1
      5  1377		       85 92		      sta	audv1Lo
    903  1379
    904  1379		       85 50		      sta	RESP0	; 3	     @61
    905  137b
      0  137b					      UPDATE_MUSIC_DATA_HI	1	; 8
      1  137b		       a5 93		      lda	audv1Hi
      2  137d		       69 00		      adc	#0
      3  137f		       85 93		      sta	audv1Hi
      0  1381					      UPDATE_MUSIC_PREP_VOL	1	; 4 = 12    @73
      1  1381		       29 06		      and	#VOL_MASK/2
      2  1383		       0a		      asl
    908  1384							;    bne    .enterKernel
    909  1384							;
    910  1384							;    align 256
    911  1384							;
    912  1384							;.enterKernel
    913  1384		       85 42		      sta	WSYNC
    914  1386							;---------------------------------------
    915  1386		       8e 41 00 	      stx.w	VBLANK	; 4 =	4
    916  1389				   LoopTitle		;	     @04
      0  1389					      UPDATE_MUSIC_SET_VOL	1	; 3	     @07!    <-- AUDV1
      1  1389					      IF	PLAY_CH_1 == YES
      2  1389		       85 5a		      sta	AUDV1
      3  138b				  -	      ELSE
      4  138b				  -	      nop	AUDV1
      5  138b					      ENDIF
    918  138b		       bd d5 f0 	      lda	title_STRIP_0,x	; 4
    919  138e		       85 4d		      sta	PF0	; 3
    920  1390		       bd 00 f1 	      lda	title_STRIP_1,x	; 4
    921  1393		       85 4e		      sta	PF1	; 3
    922  1395		       bd 23 f1 	      lda	title_STRIP_2,x	; 4
    923  1398		       85 4f		      sta	PF2	; 3 = 21    @28
    924  139a
    925  139a		       b9 0b f0 	      lda	TradeMarkA,y	; 4
    926  139d		       85 5b		      sta	GRP0	; 3 =	7    @35
    927  139f
    928  139f		       bd 46 f1 	      lda	title_STRIP_3,x	; 4
    929  13a2		       85 4d		      sta	PF0	; 3	     @42     <= @47!
    930  13a4		       bd 69 f1 	      lda	title_STRIP_4,x	; 4
    931  13a7		       85 4e		      sta	PF1	; 3
    932  13a9		       bd 8c f1 	      lda	title_STRIP_5,x	; 4
    933  13ac		       85 4f		      sta	PF2	; 3 = 21    @56
    934  13ae
      0  13ae					      UPDATE_MUSIC_DATA_LO	1	; 9
      0  13ae					      CHECK_CLC
      1  13ae
      2  13ae
      3  13ae		       a5 92		      lda	audv1Lo
      4  13b0		       65 8d		      adc	note1
      5  13b2		       85 92		      sta	audv1Lo
    936  13b4							;    SLEEP   9 		      ; 9 = 18	  @74
    937  13b4		       48		      pha		; 3
    938  13b5		       68		      pla		; 4
    939  13b6		       ea		      nop		; 2
    940  13b7							;---------------------------------------
    941  13b7		       b9 ae 00 	      lda	audV0LstTop-1,y	; 4
    942  13ba		       29 0c		      and	#VOL_MASK	; 2
      0  13bc					      UPDATE_MUSIC_SET_VOL	0	; 3 =	9    @07!    <-- AUDV0
      1  13bc					      IF	PLAY_CH_0 == YES
      2  13bc		       85 59		      sta	AUDV0
      3  13be				  -	      ELSE
      4  13be				  -	      nop	AUDV0
      5  13be					      ENDIF
    944  13be
    945  13be		       bd d5 f0 	      lda	title_STRIP_0,x	; 4
    946  13c1		       85 4d		      sta	PF0	; 3
    947  13c3		       bd 00 f1 	      lda	title_STRIP_1,x	; 4
    948  13c6		       85 4e		      sta	PF1	; 3
    949  13c8		       bd 23 f1 	      lda	title_STRIP_2,x	; 4
    950  13cb		       85 4f		      sta	PF2	; 3 = 21    @28
    951  13cd
    952  13cd		       b9 37 f0 	      lda	TradeMarkB,y	; 4
    953  13d0		       85 5b		      sta	GRP0	; 3 =	7    @35
    954  13d2
    955  13d2		       bd 46 f1 	      lda	title_STRIP_3,x	; 4
    956  13d5		       85 4d		      sta	PF0	; 3
    957  13d7		       bd 69 f1 	      lda	title_STRIP_4,x	; 4
    958  13da		       85 4e		      sta	PF1	; 3
    959  13dc		       bd 8c f1 	      lda	title_STRIP_5,x	; 4
    960  13df		       85 4f		      sta	PF2	; 3 = 21    @56
    961  13e1
      0  13e1					      UPDATE_MUSIC_DATA_HI	1	; 8
      1  13e1		       a5 93		      lda	audv1Hi
      2  13e3		       69 00		      adc	#0
      3  13e5		       85 93		      sta	audv1Hi
      0  13e7					      UPDATE_MUSIC_PREP_VOL	1	; 4
      1  13e7		       29 06		      and	#VOL_MASK/2
      2  13e9		       0a		      asl
      0  13ea					      SLEEP	3	; 3 = 15    @71
      1  13ea				   .CYCLES    SET	3
      2  13ea
      3  13ea				  -	      IF	.CYCLES < 2
      4  13ea				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  13ea				  -	      ERR
      6  13ea					      ENDIF
      7  13ea
      8  13ea					      IF	.CYCLES & 1
      9  13ea					      IFNCONST	NO_ILLEGAL_OPCODES
     10  13ea		       04 00		      nop	0
     11  13ec				  -	      ELSE
     12  13ec				  -	      bit	VSYNC
     13  13ec					      ENDIF
     14  13ec				   .CYCLES    SET	.CYCLES - 3
     15  13ec					      ENDIF
     16  13ec
     17  13ec				  -	      REPEAT	.CYCLES / 2
     18  13ec				  -	      nop
     19  13ec					      REPEND
    965  13ec
    966  13ec		       88		      dey		; 2
    967  13ed		       be 84 f0 	      ldx	NextXTbl,y	; 4 =	6    @01
    968  13f0							;---------------------------------------
    969  13f0		       10 97		      bpl	LoopTitle	; 2/3= 6    @04
      0  13f2					      CHECKPAGE	LoopTitle
      8  13f2					      LIST	ON
    971  13f2
      0  13f2					      UPDATE_MUSIC_SET_VOL_W	1	; 4	     @07!    <-- AUDV1
      1  13f2					      IF	PLAY_CH_1 == YES
      2  13f2		       8d 5a 00 	      sta.w	AUDV1
      3  13f5				  -	      ELSE
      4  13f5				  -	      nop.w	AUDV1
      5  13f5					      ENDIF
    973  13f5
    974  13f5		       84 49		      sty	COLUBK	; 3		     Y==0
    975  13f7		       84 4d		      sty	PF0	; 3
    976  13f9		       84 4e		      sty	PF1	; 3
    977  13fb		       84 4f		      sty	PF2	; 3
    978  13fd		       84 5e		      sty	ENAM1	; 3 = 15    @22
    979  13ff
    980  13ff		       a5 86		      lda	titleMode	; 3
    981  1401		       f0 2b		      beq	DrawSelection	; 2/4	     @29
    982  1403		       4c 07 f0 	      jmp	SwitchToDrawLogoBank	; 8	     @35
    983  1406
    984  1406							;--------------------------------------------------------------------------
    985  1406
    986  1406				   UpdateMusicWSync0
    987  1406							; maintain first channel
      0  1406					      UPDATE_MUSIC_WSYNC	0	;27
      0  1406					      UPDATE_MUSIC_DATA	0
      0  1406					      UPDATE_MUSIC_DATA_LO	0
      0  1406					      CHECK_CLC
      1  1406
      2  1406
      3  1406		       a5 90		      lda	audv0Lo
      4  1408		       65 8c		      adc	note0
      5  140a		       85 90		      sta	audv0Lo
      0  140c					      UPDATE_MUSIC_DATA_HI	0
      1  140c		       a5 91		      lda	audv0Hi
      2  140e		       69 00		      adc	#0
      3  1410		       85 91		      sta	audv0Hi
      2  1412		       85 42		      sta	WSYNC
      3  1414
      0  1414					      UPDATE_MUSIC_VOL	0
      0  1414					      UPDATE_MUSIC_PREP_VOL	0
      1  1414		       29 06		      and	#VOL_MASK/2
      2  1416		       0a		      asl
      0  1417					      UPDATE_MUSIC_SET_VOL	0
      1  1417					      IF	PLAY_CH_0 == YES
      2  1417		       85 59		      sta	AUDV0
      3  1419				  -	      ELSE
      4  1419				  -	      nop	AUDV0
      5  1419					      ENDIF
    989  1419		       60		      rts		; 6 = 33
    990  141a
    991  141a				   UpdateMusicWSync1
    992  141a							; maintain second channel
      0  141a					      UPDATE_MUSIC_WSYNC	1	;27
      0  141a					      UPDATE_MUSIC_DATA	1
      0  141a					      UPDATE_MUSIC_DATA_LO	1
      0  141a					      CHECK_CLC
      1  141a
      2  141a
      3  141a		       a5 92		      lda	audv1Lo
      4  141c		       65 8d		      adc	note1
      5  141e		       85 92		      sta	audv1Lo
      0  1420					      UPDATE_MUSIC_DATA_HI	1
      1  1420		       a5 93		      lda	audv1Hi
      2  1422		       69 00		      adc	#0
      3  1424		       85 93		      sta	audv1Hi
      2  1426		       85 42		      sta	WSYNC
      3  1428
      0  1428					      UPDATE_MUSIC_VOL	1
      0  1428					      UPDATE_MUSIC_PREP_VOL	1
      1  1428		       29 06		      and	#VOL_MASK/2
      2  142a		       0a		      asl
      0  142b					      UPDATE_MUSIC_SET_VOL	1
      1  142b					      IF	PLAY_CH_1 == YES
      2  142b		       85 5a		      sta	AUDV1
      3  142d				  -	      ELSE
      4  142d				  -	      nop	AUDV1
      5  142d					      ENDIF
    994  142d				   Wait12
    995  142d		       60		      rts		; 6 = 33
    996  142e
    997  142e							;--------------------------------------------------------------------------
    998  142e							; 6-sprite routine; 32+2 lines of sprites for selection screen.
      0  142e					      DEFINE_SUBROUTINE	DrawSelection
      1  142e		       00 02	   BANK_DrawSelection =	_CURRENT_BANK
      2  142e					      SUBROUTINE
      3  142e				   DrawSelection
   1000  142e
   1001  142e							;    lda     #1		      ; 2
   1002  142e							;    sta.w   VDELP1		      ; 4
   1003  142e
      0  142e					      SLEEP	6
      1  142e				   .CYCLES    SET	6
      2  142e
      3  142e				  -	      IF	.CYCLES < 2
      4  142e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  142e				  -	      ERR
      6  142e					      ENDIF
      7  142e
      8  142e				  -	      IF	.CYCLES & 1
      9  142e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  142e				  -	      nop	0
     11  142e				  -	      ELSE
     12  142e				  -	      bit	VSYNC
     13  142e				  -	      ENDIF
     14  142e				  -.CYCLES    SET	.CYCLES - 3
     15  142e					      ENDIF
     16  142e
     17  142e					      REPEAT	.CYCLES / 2
     18  142e		       ea		      nop
     17  142e					      REPEND
     18  142f		       ea		      nop
     17  142f					      REPEND
     18  1430		       ea		      nop
     19  1431					      REPEND
   1005  1431							;	     @35
   1006  1431		       a9 03		      lda	#%00011	; 2
   1007  1433
   1008  1433		       85 50		      sta	RESP0	; 3	     @40     centered
   1009  1435		       85 51		      sta	RESP1	; 3	     @43
   1010  1437
   1011  1437		       85 44		      sta	NUSIZ0	; 3
   1012  1439		       85 45		      sta	NUSIZ1	; 3
   1013  143b		       85 65		      sta	VDELP0	; 3 =	9    @52
   1014  143d
   1015  143d							; Cave:
   1016  143d		       a0 03		      ldy	#LKERNEL_H/8-1	; 2
   1017  143f							;    sty     loopCntSel	      ; 3
   1018  143f							;    lda     (ptrGfxA),y	      ; 5
   1019  143f							;    sta     tmpGfxA		      ; 3 = 10
   1020  143f		       a5 97		      lda	tmpGfxB	; 3
   1021  1441		       8d 46 00 	      sta.w	COLUP0	; 4
   1022  1444		       85 47		      sta	COLUP1	; 3 = 10    @64
   1023  1446							;---------------------------------------
   1024  1446							;    sta     HMOVE		      ; 3	  @67
   1025  1446							;    jmp     EnterSelLoop0	      ; 3 =  6	  @70
   1026  1446
   1027  1446		       bf b1 f6 	      lax	SelGfxB4_0-1,y	; 4
   1028  1449		       85 6a		      sta	HMOVE	; 3	     @71
   1029  144b		       4c 8a f4 	      jmp	EnterSelLoop0+3	; 3 =	6    @74
   1030  144e
   1031  144e							;    ALIGN_FREE 256
   1032  144e
      0  144e					      DRAW_ROW	0	;	     @59
      1  144e
      2  144e				  -	      IF	0 != 0
      3  144e				  -	      ALIGN_FREE	256
      4  144e					      ENDIF
      5  144e
      6  144e
      7  144e
      8  144e
      9  144e
     10  144e				   LoopSelGfx0
     11  144e		       be d5 f5 	      ldx	SelGfxB0_0-1,y
     12  1451		       8e 5b 00 	      stx.w	GRP0
     13  1454
      0  1454					      UPDATE_MUSIC_DATA_HI	1
      1  1454		       a5 93		      lda	audv1Hi
      2  1456		       69 00		      adc	#0
      3  1458		       85 93		      sta	audv1Hi
     15  145a
      0  145a					      UPDATE_MUSIC_VOL	1
      0  145a					      UPDATE_MUSIC_PREP_VOL	1
      1  145a		       29 06		      and	#VOL_MASK/2
      2  145c		       0a		      asl
      0  145d					      UPDATE_MUSIC_SET_VOL	1
      1  145d					      IF	PLAY_CH_1 == YES
      2  145d		       85 5a		      sta	AUDV1
      3  145f				  -	      ELSE
      4  145f				  -	      nop	AUDV1
      5  145f					      ENDIF
     17  145f
      0  145f					      UPDATE_MUSIC_DATA_LO	1
      0  145f					      CHECK_CLC
      1  145f
      2  145f
      3  145f		       a5 92		      lda	audv1Lo
      4  1461		       65 8d		      adc	note1
      5  1463		       85 92		      sta	audv1Lo
     19  1465
     20  1465		       b9 e1 f5 	      lda	SelGfxB1_0-1,y
     21  1468		       85 5c		      sta	GRP1
     22  146a		       b9 ed f5 	      lda	SelGfxB2_0-1,y
     23  146d		       85 5b		      sta	GRP0
     24  146f
     25  146f		       b3 9b		      lax	(ptrGfxB),y
     26  1471		       b9 f9 f5 	      lda	SelGfxB3_0-1,y
     27  1474		       a4 97		      ldy	tmpGfxB
     28  1476
     29  1476		       85 5c		      sta	GRP1
     30  1478		       84 5b		      sty	GRP0
     31  147a		       86 5c		      stx	GRP1
     32  147c		       85 5b		      sta	GRP0
     33  147e
     34  147e		       a4 98		      ldy	loopCntSel
     35  1480		       88		      dey
     36  1481		       84 98		      sty	loopCntSel
     37  1483		       b1 99		      lda	(ptrGfxA),y
     38  1485		       85 96		      sta	tmpGfxA
     39  1487				   EnterSelLoop0
     40  1487		       bf b1 f6 	      lax	SelGfxB4_0-1,y
     41  148a
     42  148a				   V_OFS      SET	(3-0)*4
     43  148a		       b9 ab 00 	      lda	audV0LstBtm+V_OFS,y
     44  148d		       29 0c		      and	#VOL_MASK
      0  148f					      UPDATE_MUSIC_SET_VOL	0
      1  148f					      IF	PLAY_CH_0 == YES
      2  148f		       85 59		      sta	AUDV0
      3  1491				  -	      ELSE
      4  1491				  -	      nop	AUDV0
      5  1491					      ENDIF
     46  1491
     47  1491		       86 97		      stx	tmpGfxB
     48  1493		       be a9 f5 	      ldx	SelGfxA0_0,y
     49  1496		       86 5b		      stx	GRP0
     50  1498		       b9 89 f7 	      lda	SelGfxA1_0,y
     51  149b		       85 5c		      sta	GRP1
     52  149d		       b9 99 f7 	      lda	SelGfxA2_0,y
     53  14a0		       85 5b		      sta	GRP0
     54  14a2
     55  14a2		       bf c9 f5 	      lax	SelGfxA4_0,y
     56  14a5		       b9 b9 f5 	      lda	SelGfxA3_0,y
     57  14a8		       a4 96		      ldy	tmpGfxA
     58  14aa		       85 5c		      sta	GRP1
     59  14ac		       86 5b		      stx	GRP0
     60  14ae		       84 5c		      sty	GRP1
     61  14b0		       85 5b		      sta	GRP0
     62  14b2
     63  14b2		       a4 98		      ldy	loopCntSel
     64  14b4		       d0 98		      bne	LoopSelGfx0
      0  14b6					      CHECKPAGE	LoopSelGfx0
      8  14b6					      LIST	ON
      0  14b6					      END_ROW		;	     @16
      1  14b6		       84 46		      sty	COLUP0
      2  14b8		       84 47		      sty	COLUP1
      0  14ba					      SLEEP	3
      1  14ba				   .CYCLES    SET	3
      2  14ba
      3  14ba				  -	      IF	.CYCLES < 2
      4  14ba				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  14ba				  -	      ERR
      6  14ba					      ENDIF
      7  14ba
      8  14ba					      IF	.CYCLES & 1
      9  14ba					      IFNCONST	NO_ILLEGAL_OPCODES
     10  14ba		       04 00		      nop	0
     11  14bc				  -	      ELSE
     12  14bc				  -	      bit	VSYNC
     13  14bc					      ENDIF
     14  14bc				   .CYCLES    SET	.CYCLES - 3
     15  14bc					      ENDIF
     16  14bc
     17  14bc				  -	      REPEAT	.CYCLES / 2
     18  14bc				  -	      nop
     19  14bc					      REPEND
      4  14bc
      5  14bc
      6  14bc
      7  14bc
      0  14bc					      UPDATE_MUSIC_DATA_HI	1
      1  14bc		       a5 93		      lda	audv1Hi
      2  14be		       69 00		      adc	#0
      3  14c0		       85 93		      sta	audv1Hi
      9  14c2
      0  14c2					      UPDATE_MUSIC_VOL	1
      0  14c2					      UPDATE_MUSIC_PREP_VOL	1
      1  14c2		       29 06		      and	#VOL_MASK/2
      2  14c4		       0a		      asl
      0  14c5					      UPDATE_MUSIC_SET_VOL	1
      1  14c5					      IF	PLAY_CH_1 == YES
      2  14c5		       85 5a		      sta	AUDV1
      3  14c7				  -	      ELSE
      4  14c7				  -	      nop	AUDV1
      5  14c7					      ENDIF
     11  14c7
      0  14c7					      UPDATE_MUSIC_DATA_LO	1
      0  14c7					      CHECK_CLC
      1  14c7
      2  14c7
      3  14c7		       a5 92		      lda	audv1Lo
      4  14c9		       65 8d		      adc	note1
      5  14cb		       85 92		      sta	audv1Lo
   1035  14cd
   1036  14cd							; Level 1/2:
      0  14cd					      SET_DIGIT_PTR	1	;17
      1  14cd		       a4 83		      ldy	selLst+1
      2  14cf		       b9 c5 f7 	      lda	SelDigitAPtr,y
      3  14d2		       85 99		      sta	ptrGfxA
      4  14d4		       b9 ca f7 	      lda	SelDigitBPtr,y
      5  14d7		       85 9b		      sta	ptrGfxB
      0  14d9					      START_ROW	1
      1  14d9		       a0 03		      ldy	#LKERNEL_H/8-1
      2  14db		       84 98		      sty	loopCntSel
      3  14dd		       b1 99		      lda	(ptrGfxA),y
      4  14df		       85 96		      sta	tmpGfxA
      5  14e1
      0  14e1					      SET_ROW_COL	1
      1  14e1		       a6 81		      ldx	Platform
      2  14e3		       a5 9d		      lda	selRow
      3  14e5					      IF	1 != 0
      4  14e5		       49 01		      eor	#1
      5  14e7					      ENDIF
      6  14e7		       f0 04		      beq	.isSel1
      7  14e9		       a9 0a		      lda	#NOT_SEL_COL
      8  14eb		       d0 03		      bne	.notSel1
      9  14ed
     10  14ed				   .isSel1
     11  14ed		       bd fc f6 	      lda	SelectionColTbl,x
     12  14f0				   .notSel1
     13  14f0		       85 46		      sta	COLUP0
     14  14f2		       85 47		      sta	COLUP1
      7  14f4
      8  14f4		       4c 39 f5 	      jmp	EnterSelLoop1
   1039  14f7
   1040  14f7							;-------------------------------------------------------------------------------
   1041  14f7							; fill align gaps:
   1042  14f7				   SelGfx1
   1043  14f7					      IF	FINAL_VERSION = NO
   1044  14f7				   SelGfxA0_2
   1045  14f7		       e0		      .byte.b	%11100000
   1046  14f8		       fc		      .byte.b	%11111100
   1047  14f9		       e6		      .byte.b	%11100110
   1048  14fa		       fc		      .byte.b	%11111100
   1049  14fb				   SelGfxA0_1
   1050  14fb		       fd		      .byte.b	%11111101
   1051  14fc		       e1		      .byte.b	%11100001
   1052  14fd		       e1		      .byte.b	%11100001
   1053  14fe		       e1		      .byte.b	%11100001
   1054  14ff					      ENDIF
      0  14ff					      CHECKPAGE	SelGfx1
      8  14ff					      LIST	ON
   1056  14ff
   1057  14ff							;-------------------------------------------------------------------------------
   1058  14ff							; Level 2/2
      0  14ff					      DRAW_ROW	1	;	     @59
      1  14ff
      2  14ff					      IF	1 != 0
      0  14ff					      ALIGN_FREE	256
      1  14ff				   FREE       SET	FREE - .
      2  1500		       00		      align	256
      3  1500				   FREE       SET	FREE + .
 @ $f500 : $9
      4  1500					      echo	"@", ., ":", FREE
      4  1500					      ENDIF
      5  1500
      6  1500
      7  1500
      8  1500
      9  1500
     10  1500				   LoopSelGfx1
     11  1500		       be d2 f5 	      ldx	SelGfxB0_1-1,y
     12  1503		       8e 5b 00 	      stx.w	GRP0
     13  1506
      0  1506					      UPDATE_MUSIC_DATA_HI	1
      1  1506		       a5 93		      lda	audv1Hi
      2  1508		       69 00		      adc	#0
      3  150a		       85 93		      sta	audv1Hi
     15  150c
      0  150c					      UPDATE_MUSIC_VOL	1
      0  150c					      UPDATE_MUSIC_PREP_VOL	1
      1  150c		       29 06		      and	#VOL_MASK/2
      2  150e		       0a		      asl
      0  150f					      UPDATE_MUSIC_SET_VOL	1
      1  150f					      IF	PLAY_CH_1 == YES
      2  150f		       85 5a		      sta	AUDV1
      3  1511				  -	      ELSE
      4  1511				  -	      nop	AUDV1
      5  1511					      ENDIF
     17  1511
      0  1511					      UPDATE_MUSIC_DATA_LO	1
      0  1511					      CHECK_CLC
      1  1511
      2  1511
      3  1511		       a5 92		      lda	audv1Lo
      4  1513		       65 8d		      adc	note1
      5  1515		       85 92		      sta	audv1Lo
     19  1517
     20  1517		       b9 de f5 	      lda	SelGfxB1_1-1,y
     21  151a		       85 5c		      sta	GRP1
     22  151c		       b9 ea f5 	      lda	SelGfxB2_1-1,y
     23  151f		       85 5b		      sta	GRP0
     24  1521
     25  1521		       b3 9b		      lax	(ptrGfxB),y
     26  1523		       b9 f6 f5 	      lda	SelGfxB3_1-1,y
     27  1526		       a4 97		      ldy	tmpGfxB
     28  1528
     29  1528		       85 5c		      sta	GRP1
     30  152a		       84 5b		      sty	GRP0
     31  152c		       86 5c		      stx	GRP1
     32  152e		       85 5b		      sta	GRP0
     33  1530
     34  1530		       a4 98		      ldy	loopCntSel
     35  1532		       88		      dey
     36  1533		       84 98		      sty	loopCntSel
     37  1535		       b1 99		      lda	(ptrGfxA),y
     38  1537		       85 96		      sta	tmpGfxA
     39  1539				   EnterSelLoop1
     40  1539		       bf ae f6 	      lax	SelGfxB4_1-1,y
     41  153c
     42  153c				   V_OFS      SET	(3-1)*4
     43  153c		       b9 a7 00 	      lda	audV0LstBtm+V_OFS,y
     44  153f		       29 0c		      and	#VOL_MASK
      0  1541					      UPDATE_MUSIC_SET_VOL	0
      1  1541					      IF	PLAY_CH_0 == YES
      2  1541		       85 59		      sta	AUDV0
      3  1543				  -	      ELSE
      4  1543				  -	      nop	AUDV0
      5  1543					      ENDIF
     46  1543
     47  1543		       86 97		      stx	tmpGfxB
     48  1545		       be fb f4 	      ldx	SelGfxA0_1,y
     49  1548		       86 5b		      stx	GRP0
     50  154a		       b9 85 f7 	      lda	SelGfxA1_1,y
     51  154d		       85 5c		      sta	GRP1
     52  154f		       b9 95 f7 	      lda	SelGfxA2_1,y
     53  1552		       85 5b		      sta	GRP0
     54  1554
     55  1554		       bf c5 f5 	      lax	SelGfxA4_1,y
     56  1557		       b9 b5 f5 	      lda	SelGfxA3_1,y
     57  155a		       a4 96		      ldy	tmpGfxA
     58  155c		       85 5c		      sta	GRP1
     59  155e		       86 5b		      stx	GRP0
     60  1560		       84 5c		      sty	GRP1
     61  1562		       85 5b		      sta	GRP0
     62  1564
     63  1564		       a4 98		      ldy	loopCntSel
     64  1566		       d0 98		      bne	LoopSelGfx1
      0  1568					      CHECKPAGE	LoopSelGfx1
      8  1568					      LIST	ON
      0  1568					      END_ROW		;	     @16
      1  1568		       84 46		      sty	COLUP0
      2  156a		       84 47		      sty	COLUP1
      0  156c					      SLEEP	3
      1  156c				   .CYCLES    SET	3
      2  156c
      3  156c				  -	      IF	.CYCLES < 2
      4  156c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  156c				  -	      ERR
      6  156c					      ENDIF
      7  156c
      8  156c					      IF	.CYCLES & 1
      9  156c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  156c		       04 00		      nop	0
     11  156e				  -	      ELSE
     12  156e				  -	      bit	VSYNC
     13  156e					      ENDIF
     14  156e				   .CYCLES    SET	.CYCLES - 3
     15  156e					      ENDIF
     16  156e
     17  156e				  -	      REPEAT	.CYCLES / 2
     18  156e				  -	      nop
     19  156e					      REPEND
      4  156e
      5  156e
      6  156e
      7  156e
      0  156e					      UPDATE_MUSIC_DATA_HI	1
      1  156e		       a5 93		      lda	audv1Hi
      2  1570		       69 00		      adc	#0
      3  1572		       85 93		      sta	audv1Hi
      9  1574
      0  1574					      UPDATE_MUSIC_VOL	1
      0  1574					      UPDATE_MUSIC_PREP_VOL	1
      1  1574		       29 06		      and	#VOL_MASK/2
      2  1576		       0a		      asl
      0  1577					      UPDATE_MUSIC_SET_VOL	1
      1  1577					      IF	PLAY_CH_1 == YES
      2  1577		       85 5a		      sta	AUDV1
      3  1579				  -	      ELSE
      4  1579				  -	      nop	AUDV1
      5  1579					      ENDIF
     11  1579
      0  1579					      UPDATE_MUSIC_DATA_LO	1
      0  1579					      CHECK_CLC
      1  1579
      2  1579
      3  1579		       a5 92		      lda	audv1Lo
      4  157b		       65 8d		      adc	note1
      5  157d		       85 92		      sta	audv1Lo
   1061  157f
   1062  157f							; Players 1/2:
      0  157f					      SET_DIGIT_PTR	2	;17
      1  157f		       a4 84		      ldy	selLst+2
      2  1581		       b9 c5 f7 	      lda	SelDigitAPtr,y
      3  1584		       85 99		      sta	ptrGfxA
      4  1586		       b9 ca f7 	      lda	SelDigitBPtr,y
      5  1589		       85 9b		      sta	ptrGfxB
      0  158b					      START_ROW	2
      1  158b		       a0 03		      ldy	#LKERNEL_H/8-1
      2  158d		       84 98		      sty	loopCntSel
      3  158f		       b1 99		      lda	(ptrGfxA),y
      4  1591		       85 96		      sta	tmpGfxA
      5  1593
      0  1593					      SET_ROW_COL	2
      1  1593		       a6 81		      ldx	Platform
      2  1595		       a5 9d		      lda	selRow
      3  1597					      IF	2 != 0
      4  1597		       49 02		      eor	#2
      5  1599					      ENDIF
      6  1599		       f0 04		      beq	.isSel2
      7  159b		       a9 0a		      lda	#NOT_SEL_COL
      8  159d		       d0 03		      bne	.notSel2
      9  159f
     10  159f				   .isSel2
     11  159f		       bd fc f6 	      lda	SelectionColTbl,x
     12  15a2				   .notSel2
     13  15a2		       85 46		      sta	COLUP0
     14  15a4		       85 47		      sta	COLUP1
      7  15a6
      8  15a6		       4c 39 f6 	      jmp	EnterSelLoop2
   1065  15a9
   1066  15a9							;-------------------------------------------------------------------------------
   1067  15a9							; fill align gaps:
   1068  15a9				   SelGfx2
   1069  15a9				   SelGfxA0_0
   1070  15a9		       7c		      .byte.b	%01111100
   1071  15aa		       e6		      .byte.b	%11100110
   1072  15ab		       e0		      .byte.b	%11100000
   1073  15ac		       7c		      .byte.b	%01111100
   1074  15ad
   1075  15ad				   SelGfxA3_3
   1076  15ad		       f8		      .byte.b	%11111000
   1077  15ae		       0c		      .byte.b	%00001100
   1078  15af		       f8		      .byte.b	%11111000
   1079  15b0		       fb		      .byte.b	%11111011
   1080  15b1				   SelGfxA3_2
   1081  15b1		       9b		      .byte.b	%10011011
   1082  15b2		       f0		      .byte.b	%11110000
   1083  15b3		       99		      .byte.b	%10011001
   1084  15b4		       f1		      .byte.b	%11110001
   1085  15b5				   SelGfxA3_1
   1086  15b5		       fd		      .byte.b	%11111101
   1087  15b6		       c1		      .byte.b	%11000001
   1088  15b7		       f9		      .byte.b	%11111001
   1089  15b8		       fd		      .byte.b	%11111101
   1090  15b9				   SelGfxA3_0
   1091  15b9		       fe		      .byte.b	%11111110
   1092  15ba		       e0		      .byte.b	%11100000
   1093  15bb		       fc		      .byte.b	%11111100
   1094  15bc		       fe		      .byte.b	%11111110
   1095  15bd
   1096  15bd				   SelGfxA4_3
   1097  15bd		       e0		      .byte.b	%11100000
   1098  15be		       e3		      .byte.b	%11100011
   1099  15bf		       e3		      .byte.b	%11100011
   1100  15c0		       f8		      .byte.b	%11111000
   1101  15c1				   SelGfxA4_2
   1102  15c1		       f0		      .byte.b	%11110000
   1103  15c2		       1b		      .byte.b	%00011011
   1104  15c3		       f3		      .byte.b	%11110011
   1105  15c4		       f0		      .byte.b	%11110000
   1106  15c5				   SelGfxA4_1
   1107  15c5		       f8		      .byte.b	%11111000
   1108  15c6		       c3		      .byte.b	%11000011
   1109  15c7		       c3		      .byte.b	%11000011
   1110  15c8		       c0		      .byte.b	%11000000
   1111  15c9				   SelGfxA4_0
   1112  15c9		       00		      .byte.b	%00000000
   1113  15ca		       03		      .byte.b	%00000011
   1114  15cb		       03		      .byte.b	%00000011
   1115  15cc		       00		      .byte.b	%00000000
   1116  15cd
   1117  15cd				   SelGfxB0_3
   1118  15cd		       fd		      .byte.b	%11111101
   1119  15ce		       0d		      .byte.b	%00001101
   1120  15cf		       0d		      .byte.b	%00001101
   1121  15d0				   SelGfxB0_2
   1122  15d0		       e0		      .byte.b	%11100000
   1123  15d1		       fe		      .byte.b	%11111110
   1124  15d2		       e6		      .byte.b	%11100110
   1125  15d3				   SelGfxB0_1
   1126  15d3		       fd		      .byte.b	%11111101
   1127  15d4		       e1		      .byte.b	%11100001
   1128  15d5		       e1		      .byte.b	%11100001
   1129  15d6				   SelGfxB0_0
   1130  15d6		       fe		      .byte.b	%11111110
   1131  15d7		       e0		      .byte.b	%11100000
   1132  15d8		       e6		      .byte.b	%11100110
   1133  15d9
   1134  15d9				   SelGfxB1_3
   1135  15d9		       fc		      .byte.b	%11111100
   1136  15da		       8c		      .byte.b	%10001100
   1137  15db		       8d		      .byte.b	%10001101
   1138  15dc				   SelGfxB1_2
   1139  15dc		       fc		      .byte.b	%11111100
   1140  15dd		       e0		      .byte.b	%11100000
   1141  15de		       e3		      .byte.b	%11100011
   1142  15df				   SelGfxB1_1
   1143  15df		       fc		      .byte.b	%11111100
   1144  15e0		       c1		      .byte.b	%11000001
   1145  15e1		       c1		      .byte.b	%11000001
   1146  15e2				   SelGfxB1_0
   1147  15e2		       e6		      .byte.b	%11100110
   1148  15e3		       e6		      .byte.b	%11100110
   1149  15e4		       7c		      .byte.b	%01111100
   1150  15e5
   1151  15e5				   SelGfxB2_3
   1152  15e5		       71		      .byte.b	%01110001
   1153  15e6		       70		      .byte.b	%01110000
   1154  15e7		       8d		      .byte.b	%10001101
   1155  15e8				   SelGfxB2_2
   1156  15e8		       e3		      .byte.b	%11100011
   1157  15e9		       e3		      .byte.b	%11100011
   1158  15ea		       1b		      .byte.b	%00011011
   1159  15eb				   SelGfxB2_1
   1160  15eb		       f9		      .byte.b	%11111001
   1161  15ec		       cd		      .byte.b	%11001101
   1162  15ed		       cd		      .byte.b	%11001101
   1163  15ee				   SelGfxB2_0
   1164  15ee		       7c		      .byte.b	%01111100
   1165  15ef		       e6		      .byte.b	%11100110
   1166  15f0		       e6		      .byte.b	%11100110
   1167  15f1
   1168  15f1				   SelGfxB3_3
   1169  15f1		       fc		      .byte.b	%11111100
   1170  15f2		       0c		      .byte.b	%00001100
   1171  15f3		       c0		      .byte.b	%11000000
   1172  15f4				   SelGfxB3_2
   1173  15f4		       9b		      .byte.b	%10011011
   1174  15f5		       f0		      .byte.b	%11110000
   1175  15f6		       9b		      .byte.b	%10011011
   1176  15f7				   SelGfxB3_1
   1177  15f7		       fd		      .byte.b	%11111101
   1178  15f8		       c1		      .byte.b	%11000001
   1179  15f9		       c1		      .byte.b	%11000001
   1180  15fa				   SelGfxB3_0
   1181  15fa		       fe		      .byte.b	%11111110
   1182  15fb		       e0		      .byte.b	%11100000
   1183  15fc		       e0		      .byte.b	%11100000
      0  15fd					      CHECKPAGE	SelGfx2
      8  15fd					      LIST	ON
   1185  15fd
   1186  15fd							;-------------------------------------------------------------------------------
   1187  15fd							; Players 2/2:
      0  15fd					      DRAW_ROW	2	;	     @59
      1  15fd
      2  15fd					      IF	2 != 0
      0  15fd					      ALIGN_FREE	256
      1  15fd				   FREE       SET	FREE - .
      2  1600		       00 00 00 	      align	256
      3  1600				   FREE       SET	FREE + .
 @ $f600 : $c
      4  1600					      echo	"@", ., ":", FREE
      4  1600					      ENDIF
      5  1600
      6  1600
      7  1600
      8  1600
      9  1600
     10  1600				   LoopSelGfx2
     11  1600		       be cf f5 	      ldx	SelGfxB0_2-1,y
     12  1603		       8e 5b 00 	      stx.w	GRP0
     13  1606
      0  1606					      UPDATE_MUSIC_DATA_HI	1
      1  1606		       a5 93		      lda	audv1Hi
      2  1608		       69 00		      adc	#0
      3  160a		       85 93		      sta	audv1Hi
     15  160c
      0  160c					      UPDATE_MUSIC_VOL	1
      0  160c					      UPDATE_MUSIC_PREP_VOL	1
      1  160c		       29 06		      and	#VOL_MASK/2
      2  160e		       0a		      asl
      0  160f					      UPDATE_MUSIC_SET_VOL	1
      1  160f					      IF	PLAY_CH_1 == YES
      2  160f		       85 5a		      sta	AUDV1
      3  1611				  -	      ELSE
      4  1611				  -	      nop	AUDV1
      5  1611					      ENDIF
     17  1611
      0  1611					      UPDATE_MUSIC_DATA_LO	1
      0  1611					      CHECK_CLC
      1  1611
      2  1611
      3  1611		       a5 92		      lda	audv1Lo
      4  1613		       65 8d		      adc	note1
      5  1615		       85 92		      sta	audv1Lo
     19  1617
     20  1617		       b9 db f5 	      lda	SelGfxB1_2-1,y
     21  161a		       85 5c		      sta	GRP1
     22  161c		       b9 e7 f5 	      lda	SelGfxB2_2-1,y
     23  161f		       85 5b		      sta	GRP0
     24  1621
     25  1621		       b3 9b		      lax	(ptrGfxB),y
     26  1623		       b9 f3 f5 	      lda	SelGfxB3_2-1,y
     27  1626		       a4 97		      ldy	tmpGfxB
     28  1628
     29  1628		       85 5c		      sta	GRP1
     30  162a		       84 5b		      sty	GRP0
     31  162c		       86 5c		      stx	GRP1
     32  162e		       85 5b		      sta	GRP0
     33  1630
     34  1630		       a4 98		      ldy	loopCntSel
     35  1632		       88		      dey
     36  1633		       84 98		      sty	loopCntSel
     37  1635		       b1 99		      lda	(ptrGfxA),y
     38  1637		       85 96		      sta	tmpGfxA
     39  1639				   EnterSelLoop2
     40  1639		       bf ab f6 	      lax	SelGfxB4_2-1,y
     41  163c
     42  163c				   V_OFS      SET	(3-2)*4
     43  163c		       b9 a3 00 	      lda	audV0LstBtm+V_OFS,y
     44  163f		       29 0c		      and	#VOL_MASK
      0  1641					      UPDATE_MUSIC_SET_VOL	0
      1  1641					      IF	PLAY_CH_0 == YES
      2  1641		       85 59		      sta	AUDV0
      3  1643				  -	      ELSE
      4  1643				  -	      nop	AUDV0
      5  1643					      ENDIF
     46  1643
     47  1643		       86 97		      stx	tmpGfxB
     48  1645		       be f7 f4 	      ldx	SelGfxA0_2,y
     49  1648		       86 5b		      stx	GRP0
     50  164a		       b9 81 f7 	      lda	SelGfxA1_2,y
     51  164d		       85 5c		      sta	GRP1
     52  164f		       b9 91 f7 	      lda	SelGfxA2_2,y
     53  1652		       85 5b		      sta	GRP0
     54  1654
     55  1654		       bf c1 f5 	      lax	SelGfxA4_2,y
     56  1657		       b9 b1 f5 	      lda	SelGfxA3_2,y
     57  165a		       a4 96		      ldy	tmpGfxA
     58  165c		       85 5c		      sta	GRP1
     59  165e		       86 5b		      stx	GRP0
     60  1660		       84 5c		      sty	GRP1
     61  1662		       85 5b		      sta	GRP0
     62  1664
     63  1664		       a4 98		      ldy	loopCntSel
     64  1666		       d0 98		      bne	LoopSelGfx2
      0  1668					      CHECKPAGE	LoopSelGfx2
      8  1668					      LIST	ON
      0  1668					      END_ROW		;	     @16
      1  1668		       84 46		      sty	COLUP0
      2  166a		       84 47		      sty	COLUP1
      0  166c					      SLEEP	3
      1  166c				   .CYCLES    SET	3
      2  166c
      3  166c				  -	      IF	.CYCLES < 2
      4  166c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  166c				  -	      ERR
      6  166c					      ENDIF
      7  166c
      8  166c					      IF	.CYCLES & 1
      9  166c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  166c		       04 00		      nop	0
     11  166e				  -	      ELSE
     12  166e				  -	      bit	VSYNC
     13  166e					      ENDIF
     14  166e				   .CYCLES    SET	.CYCLES - 3
     15  166e					      ENDIF
     16  166e
     17  166e				  -	      REPEAT	.CYCLES / 2
     18  166e				  -	      nop
     19  166e					      REPEND
      4  166e
      5  166e
      6  166e
      7  166e
      0  166e					      UPDATE_MUSIC_DATA_HI	1
      1  166e		       a5 93		      lda	audv1Hi
      2  1670		       69 00		      adc	#0
      3  1672		       85 93		      sta	audv1Hi
      9  1674
      0  1674					      UPDATE_MUSIC_VOL	1
      0  1674					      UPDATE_MUSIC_PREP_VOL	1
      1  1674		       29 06		      and	#VOL_MASK/2
      2  1676		       0a		      asl
      0  1677					      UPDATE_MUSIC_SET_VOL	1
      1  1677					      IF	PLAY_CH_1 == YES
      2  1677		       85 5a		      sta	AUDV1
      3  1679				  -	      ELSE
      4  1679				  -	      nop	AUDV1
      5  1679					      ENDIF
     11  1679
      0  1679					      UPDATE_MUSIC_DATA_LO	1
      0  1679					      CHECK_CLC
      1  1679
      2  1679
      3  1679		       a5 92		      lda	audv1Lo
      4  167b		       65 8d		      adc	note1
      5  167d		       85 92		      sta	audv1Lo
   1190  167f
   1191  167f							; Joysticks 1/2:
      0  167f					      SET_DIGIT_PTR	3	;17
      1  167f		       a4 85		      ldy	selLst+3
      2  1681		       b9 c5 f7 	      lda	SelDigitAPtr,y
      3  1684		       85 99		      sta	ptrGfxA
      4  1686		       b9 ca f7 	      lda	SelDigitBPtr,y
      5  1689		       85 9b		      sta	ptrGfxB
      0  168b					      START_ROW	3
      1  168b		       a0 03		      ldy	#LKERNEL_H/8-1
      2  168d		       84 98		      sty	loopCntSel
      3  168f		       b1 99		      lda	(ptrGfxA),y
      4  1691		       85 96		      sta	tmpGfxA
      5  1693
      0  1693					      SET_ROW_COL	3
      1  1693		       a6 81		      ldx	Platform
      2  1695		       a5 9d		      lda	selRow
      3  1697					      IF	3 != 0
      4  1697		       49 03		      eor	#3
      5  1699					      ENDIF
      6  1699		       f0 04		      beq	.isSel3
      7  169b		       a9 0a		      lda	#NOT_SEL_COL
      8  169d		       d0 03		      bne	.notSel3
      9  169f
     10  169f				   .isSel3
     11  169f		       bd fc f6 	      lda	SelectionColTbl,x
     12  16a2				   .notSel3
     13  16a2		       85 46		      sta	COLUP0
     14  16a4		       85 47		      sta	COLUP1
      7  16a6
      8  16a6		       4c 39 f7 	      jmp	EnterSelLoop3
   1194  16a9
   1195  16a9							;-------------------------------------------------------------------------------
   1196  16a9							; fill align gaps:
   1197  16a9				   SelGfx3
   1198  16a9				   SelGfxB4_3
   1199  16a9		       e3		      .byte.b	%11100011
   1200  16aa		       e0		      .byte.b	%11100000
   1201  16ab		       e3		      .byte.b	%11100011
   1202  16ac				   SelGfxB4_2
   1203  16ac		       fb		      .byte.b	%11111011
   1204  16ad		       18		      .byte.b	%00011000
   1205  16ae		       83		      .byte.b	%10000011
   1206  16af				   SelGfxB4_1
   1207  16af		       fb		      .byte.b	%11111011
   1208  16b0		       c0		      .byte.b	%11000000
   1209  16b1		       c3		      .byte.b	%11000011
   1210  16b2				   SelGfxB4_0
   1211  16b2		       03		      .byte.b	%00000011
   1212  16b3		       00		      .byte.b	%00000000
   1213  16b4		       03		      .byte.b	%00000011
   1214  16b5
   1215  16b5				   CharGfx
   1216  16b5				   Gfx5_A
   1217  16b5		       3e		      .byte.b	%00111110
   1218  16b6		       73		      .byte.b	%01110011
   1219  16b7		       7e		      .byte.b	%01111110
   1220  16b8		       7f		      .byte.b	%01111111
   1221  16b9				   Gfx5_B
   1222  16b9		       7f		      .byte.b	%01111111
   1223  16ba		       03		      .byte.b	%00000011
   1224  16bb		       70		      .byte.b	%01110000
   1225  16bc
   1226  16bc				   GfxA_A
   1227  16bc		       73		      .byte.b	%01110011
   1228  16bd		       7f		      .byte.b	%01111111
   1229  16be		       73		      .byte.b	%01110011
   1230  16bf		       1c		      .byte.b	%00011100
   1231  16c0				   Gfx1_A
   1232  16c0		       3f		      .byte.b	%00111111
   1233  16c1		       0c		      .byte.b	%00001100
   1234  16c2		       1c		      .byte.b	%00011100
   1235  16c3		       0c		      .byte.b	%00001100
   1236  16c4				   GfxE_A
   1237  16c4		       7f		      .byte.b	%01111111
   1238  16c5		       70		      .byte.b	%01110000
   1239  16c6		       7e		      .byte.b	%01111110
   1240  16c7		       7f		      .byte.b	%01111111
   1241  16c8				   Gfx2_A
   1242  16c8		       7f		      .byte.b	%01111111
   1243  16c9		       38		      .byte.b	%00111000
   1244  16ca		       0e		      .byte.b	%00001110
   1245  16cb		       3e		      .byte.b	%00111110
   1246  16cc				   GfxI_A
   1247  16cc		       3e		      .byte.b	%00111110
   1248  16cd		       1c		      .byte.b	%00011100
   1249  16ce		       1c		      .byte.b	%00011100
   1250  16cf		       3e		      .byte.b	%00111110
   1251  16d0				   Gfx3_A
   1252  16d0		       3e		      .byte.b	%00111110
   1253  16d1		       73		      .byte.b	%01110011
   1254  16d2		       0c		      .byte.b	%00001100
   1255  16d3		       3f		      .byte.b	%00111111
   1256  16d4				   GfxM_A
   1257  16d4		       63		      .byte.b	%01100011
   1258  16d5		       63		      .byte.b	%01100011
   1259  16d6		       7f		      .byte.b	%01111111
   1260  16d7		       63		      .byte.b	%01100011
   1261  16d8				   Gfx4_A
   1262  16d8		       0e		      .byte.b	%00001110
   1263  16d9		       0e		      .byte.b	%00001110
   1264  16da		       6e		      .byte.b	%01101110
   1265  16db		       60		      .byte.b	%01100000
   1266  16dc
   1267  16dc				   GfxA_B
   1268  16dc		       73		      .byte.b	%01110011
   1269  16dd		       73		      .byte.b	%01110011
   1270  16de		       3e		      .byte.b	%00111110
   1271  16df					      IF	FINAL_VERSION = NO
   1272  16df		       00		      .byte.b	0
   1273  16e0					      ENDIF
   1274  16e0				   Gfx1_B
   1275  16e0		       3f		      .byte.b	%00111111
   1276  16e1		       0c		      .byte.b	%00001100
   1277  16e2		       1c		      .byte.b	%00011100
   1278  16e3				   GfxE_B
   1279  16e3		       7f		      .byte.b	%01111111
   1280  16e4		       70		      .byte.b	%01110000
   1281  16e5		       70		      .byte.b	%01110000
   1282  16e6					      IF	FINAL_VERSION = NO
   1283  16e6		       00		      .byte.b	0
   1284  16e7					      ENDIF
   1285  16e7				   Gfx2_B
   1286  16e7		       7f		      .byte.b	%01111111
   1287  16e8		       1c		      .byte.b	%00011100
   1288  16e9		       63		      .byte.b	%01100011
   1289  16ea				   GfxI_B
   1290  16ea		       3e		      .byte.b	%00111110
   1291  16eb		       1c		      .byte.b	%00011100
   1292  16ec		       1c		      .byte.b	%00011100
   1293  16ed					      IF	FINAL_VERSION = NO
   1294  16ed		       00		      .byte.b	0
   1295  16ee					      ENDIF
   1296  16ee				   Gfx3_B
   1297  16ee		       7f		      .byte.b	%01111111
   1298  16ef		       06		      .byte.b	%00000110
   1299  16f0		       06		      .byte.b	%00000110
   1300  16f1				   GfxM_B
   1301  16f1		       63		      .byte.b	%01100011
   1302  16f2		       6b		      .byte.b	%01101011
   1303  16f3		       77		      .byte.b	%01110111
   1304  16f4					      IF	FINAL_VERSION = NO
   1305  16f4		       00		      .byte.b	0
   1306  16f5					      ENDIF
   1307  16f5				   Gfx4_B
   1308  16f5		       0e		      .byte.b	%00001110
   1309  16f6		       7f		      .byte.b	%01111111
   1310  16f7		       60		      .byte.b	%01100000
   1311  16f8
   1312  16f8				   SelGfxA0_3
   1313  16f8		       78		      .byte.b	%01111000
   1314  16f9		       cd		      .byte.b	%11001101
   1315  16fa		       0d		      .byte.b	%00001101
   1316  16fb		       0c		      .byte.b	%00001100
   1317  16fc
   1318  16fc				   SelectionColTbl
   1319  16fc		       1c		      .byte.b	YELLOW_NTSC|$C
   1320  16fd		       2c		      .byte.b	YELLOW_PAL|$C
   1321  16fe							;    CHECKPAGE CharGfx
      0  16fe					      CHECKPAGE	(SelGfx3-1)
      8  16fe					      LIST	ON
   1323  16fe
   1324  16fe							;-------------------------------------------------------------------------------
   1325  16fe							; Joysticks 2/2:
      0  16fe					      DRAW_ROW	3	;	     @59
      1  16fe
      2  16fe					      IF	3 != 0
      0  16fe					      ALIGN_FREE	256
      1  16fe				   FREE       SET	FREE - .
      2  1700		       00 00		      align	256
      3  1700				   FREE       SET	FREE + .
 @ $f700 : $e
      4  1700					      echo	"@", ., ":", FREE
      4  1700					      ENDIF
      5  1700
      6  1700
      7  1700
      8  1700
      9  1700
     10  1700				   LoopSelGfx3
     11  1700		       be cc f5 	      ldx	SelGfxB0_3-1,y
     12  1703		       8e 5b 00 	      stx.w	GRP0
     13  1706
      0  1706					      UPDATE_MUSIC_DATA_HI	1
      1  1706		       a5 93		      lda	audv1Hi
      2  1708		       69 00		      adc	#0
      3  170a		       85 93		      sta	audv1Hi
     15  170c
      0  170c					      UPDATE_MUSIC_VOL	1
      0  170c					      UPDATE_MUSIC_PREP_VOL	1
      1  170c		       29 06		      and	#VOL_MASK/2
      2  170e		       0a		      asl
      0  170f					      UPDATE_MUSIC_SET_VOL	1
      1  170f					      IF	PLAY_CH_1 == YES
      2  170f		       85 5a		      sta	AUDV1
      3  1711				  -	      ELSE
      4  1711				  -	      nop	AUDV1
      5  1711					      ENDIF
     17  1711
      0  1711					      UPDATE_MUSIC_DATA_LO	1
      0  1711					      CHECK_CLC
      1  1711
      2  1711
      3  1711		       a5 92		      lda	audv1Lo
      4  1713		       65 8d		      adc	note1
      5  1715		       85 92		      sta	audv1Lo
     19  1717
     20  1717		       b9 d8 f5 	      lda	SelGfxB1_3-1,y
     21  171a		       85 5c		      sta	GRP1
     22  171c		       b9 e4 f5 	      lda	SelGfxB2_3-1,y
     23  171f		       85 5b		      sta	GRP0
     24  1721
     25  1721		       b3 9b		      lax	(ptrGfxB),y
     26  1723		       b9 f0 f5 	      lda	SelGfxB3_3-1,y
     27  1726		       a4 97		      ldy	tmpGfxB
     28  1728
     29  1728		       85 5c		      sta	GRP1
     30  172a		       84 5b		      sty	GRP0
     31  172c		       86 5c		      stx	GRP1
     32  172e		       85 5b		      sta	GRP0
     33  1730
     34  1730		       a4 98		      ldy	loopCntSel
     35  1732		       88		      dey
     36  1733		       84 98		      sty	loopCntSel
     37  1735		       b1 99		      lda	(ptrGfxA),y
     38  1737		       85 96		      sta	tmpGfxA
     39  1739				   EnterSelLoop3
     40  1739		       bf a8 f6 	      lax	SelGfxB4_3-1,y
     41  173c
     42  173c				   V_OFS      SET	(3-3)*4
     43  173c		       b9 9f 00 	      lda	audV0LstBtm+V_OFS,y
     44  173f		       29 0c		      and	#VOL_MASK
      0  1741					      UPDATE_MUSIC_SET_VOL	0
      1  1741					      IF	PLAY_CH_0 == YES
      2  1741		       85 59		      sta	AUDV0
      3  1743				  -	      ELSE
      4  1743				  -	      nop	AUDV0
      5  1743					      ENDIF
     46  1743
     47  1743		       86 97		      stx	tmpGfxB
     48  1745		       be f8 f6 	      ldx	SelGfxA0_3,y
     49  1748		       86 5b		      stx	GRP0
     50  174a		       b9 7d f7 	      lda	SelGfxA1_3,y
     51  174d		       85 5c		      sta	GRP1
     52  174f		       b9 8d f7 	      lda	SelGfxA2_3,y
     53  1752		       85 5b		      sta	GRP0
     54  1754
     55  1754		       bf bd f5 	      lax	SelGfxA4_3,y
     56  1757		       b9 ad f5 	      lda	SelGfxA3_3,y
     57  175a		       a4 96		      ldy	tmpGfxA
     58  175c		       85 5c		      sta	GRP1
     59  175e		       86 5b		      stx	GRP0
     60  1760		       84 5c		      sty	GRP1
     61  1762		       85 5b		      sta	GRP0
     62  1764
     63  1764		       a4 98		      ldy	loopCntSel
     64  1766		       d0 98		      bne	LoopSelGfx3
      0  1768					      CHECKPAGE	LoopSelGfx3
      8  1768					      LIST	ON
   1327  1768
   1328  1768		       84 5b		      sty	GRP0	; 3
   1329  176a		       88		      dey		; 2		     -> y = $ff
   1330  176b		       84 41		      sty	VBLANK	; 3		     end of screen - enter blanking
      0  176d					      SLEEP	4	; 4
      1  176d				   .CYCLES    SET	4
      2  176d
      3  176d				  -	      IF	.CYCLES < 2
      4  176d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  176d				  -	      ERR
      6  176d					      ENDIF
      7  176d
      8  176d				  -	      IF	.CYCLES & 1
      9  176d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  176d				  -	      nop	0
     11  176d				  -	      ELSE
     12  176d				  -	      bit	VSYNC
     13  176d				  -	      ENDIF
     14  176d				  -.CYCLES    SET	.CYCLES - 3
     15  176d					      ENDIF
     16  176d
     17  176d					      REPEAT	.CYCLES / 2
     18  176d		       ea		      nop
     17  176d					      REPEND
     18  176e		       ea		      nop
     19  176f					      REPEND
      0  176f					      UPDATE_MUSIC_DATA_HI	1	; 8 = 17    @76
      1  176f		       a5 93		      lda	audv1Hi
      2  1771		       69 00		      adc	#0
      3  1773		       85 93		      sta	audv1Hi
   1333  1775				   ---------------------------------------
      0  1775					      UPDATE_MUSIC_VOL	1	; 7	     @07!    <-- AUDV1
      0  1775					      UPDATE_MUSIC_PREP_VOL	1
      1  1775		       29 06		      and	#VOL_MASK/2
      2  1777		       0a		      asl
      0  1778					      UPDATE_MUSIC_SET_VOL	1
      1  1778					      IF	PLAY_CH_1 == YES
      2  1778		       85 5a		      sta	AUDV1
      3  177a				  -	      ELSE
      4  177a				  -	      nop	AUDV1
      5  177a					      ENDIF
   1335  177a
   1336  177a							; free: 2
   1337  177a
   1338  177a		       4c 00 f0 	      jmp	SwitchToContTitleBank	;11	     @18
   1339  177d
   1340  177d							;-------------------------------------------------------------------------------
   1341  177d
   1342  177d				  -	      IF	FINAL_VERSION = YES
   1343  177d				  -SelGfxA0_2
   1344  177d				  -	      .byte	%11100000
   1345  177d				  -	      .byte	%11111100
   1346  177d				  -	      .byte	%11100110
   1347  177d				  -	      .byte	%11111100
   1348  177d				  -SelGfxA0_1
   1349  177d				  -	      .byte	%11111101
   1350  177d				  -	      .byte	%11100001
   1351  177d				  -	      .byte	%11100001
   1352  177d				  -	      .byte	%11100001
   1353  177d					      ENDIF
   1354  177d
   1355  177d				   SelGfxA1_3
   1356  177d		       f8		      .byte.b	%11111000
   1357  177e		       8c		      .byte.b	%10001100
   1358  177f		       8c		      .byte.b	%10001100
   1359  1780		       f9		      .byte.b	%11111001
   1360  1781				   SelGfxA1_2
   1361  1781		       fc		      .byte.b	%11111100
   1362  1782		       e0		      .byte.b	%11100000
   1363  1783		       e1		      .byte.b	%11100001
   1364  1784		       e3		      .byte.b	%11100011
   1365  1785				   SelGfxA1_1
   1366  1785		       fc		      .byte.b	%11111100
   1367  1786		       c1		      .byte.b	%11000001
   1368  1787		       f9		      .byte.b	%11111001
   1369  1788		       fd		      .byte.b	%11111101
   1370  1789				   SelGfxA1_0
   1371  1789		       e6		      .byte.b	%11100110
   1372  178a		       fe		      .byte.b	%11111110
   1373  178b		       e6		      .byte.b	%11100110
   1374  178c		       38		      .byte.b	%00111000
   1375  178d
   1376  178d				   SelGfxA2_3
   1377  178d		       71		      .byte.b	%01110001
   1378  178e		       70		      .byte.b	%01110000
   1379  178f		       f8		      .byte.b	%11111000
   1380  1790		       8c		      .byte.b	%10001100
   1381  1791				   SelGfxA2_2
   1382  1791		       e3		      .byte.b	%11100011
   1383  1792		       e3		      .byte.b	%11100011
   1384  1793		       f3		      .byte.b	%11110011
   1385  1794		       1b		      .byte.b	%00011011
   1386  1795				   SelGfxA2_1
   1387  1795		       71		      .byte.b	%01110001
   1388  1796		       cd		      .byte.b	%11001101
   1389  1797		       cd		      .byte.b	%11001101
   1390  1798		       cd		      .byte.b	%11001101
   1391  1799				   SelGfxA2_0
   1392  1799		       38		      .byte.b	%00111000
   1393  179a		       e6		      .byte.b	%11100110
   1394  179b		       e6		      .byte.b	%11100110
   1395  179c		       e6		      .byte.b	%11100110
   1396  179d
   1397  179d				  -	      IF	FINAL_VERSION = YES
   1398  179d				  -			; only caves A, E, I and M allowed
   1399  179d				  -SelCharAPtr
   1400  179d				  -	      .byte	<GfxA_A, <GfxE_A, <GfxI_A, <GfxM_A
   1401  179d				  -	      CHECKPAGE	SelCharAPtr
   1402  179d				  -SelCharBPtr
   1403  179d				  -	      .byte	<GfxA_B-1, <GfxE_B-1, <GfxI_B-1, <GfxM_B-1
   1404  179d				  -	      CHECKPAGE	(SelCharBPtr-1)
   1405  179d					      ELSE
   1406  179d					      IF	DEMO_VERSION = NO
   1407  179d							; allow selecting all caves and intermissions
   1408  179d							; (intermediate caves displayed by "scrolling" effect)
   1409  179d				   SelCharAPtr
   1410  179d		       bc bd be bf*	      .byte.b	<GfxA_A, <GfxA_A+1 , <GfxA_A+2, <GfxA_A+3, <Gfx1_A
   1411  17a2		       c4 c5 c6 c7*	      .byte.b	<GfxE_A, <GfxE_A+1 , <GfxE_A+2, <GfxE_A+3, <Gfx2_A
   1412  17a7		       cc cd ce cf*	      .byte.b	<GfxI_A, <GfxI_A+1 , <GfxI_A+2, <GfxI_A+3, <Gfx3_A
   1413  17ac		       d4 d5 d6 d7*	      .byte.b	<GfxM_A, <GfxM_A+1 , <GfxM_A+2, <GfxM_A+3, <Gfx4_A
      0  17b1					      CHECKPAGE	SelCharAPtr
      8  17b1					      LIST	ON
   1415  17b1				   SelCharBPtr
   1416  17b1		       db dc dd de*	      .byte.b	<GfxA_B-1, <GfxA_B-1+1 , <GfxA_B-1+2, <GfxA_B-1+3, <Gfx1_B-1
   1417  17b6		       e2 e3 e4 e5*	      .byte.b	<GfxE_B-1, <GfxE_B-1+1 , <GfxE_B-1+2, <GfxE_B-1+3, <Gfx2_B-1
   1418  17bb		       e9 ea eb ec*	      .byte.b	<GfxI_B-1, <GfxI_B-1+1 , <GfxI_B-1+2, <GfxI_B-1+3, <Gfx3_B-1
   1419  17c0		       f0 f1 f2 f3*	      .byte.b	<GfxM_B-1, <GfxM_B-1+1 , <GfxM_B-1+2, <GfxM_B-1+3, <Gfx4_B-1
      0  17c5					      CHECKPAGE	(SelCharBPtr-1)
      8  17c5					      LIST	ON
   1421  17c5				  -	      ELSE
   1422  17c5				  -			; demo version starts with cave M
   1423  17c5				  -SelCharAPtr
   1424  17c5				  -	      .byte	<GfxM_A
   1425  17c5				  -SelCharBPtr
   1426  17c5				  -	      .byte	<GfxM_B-1
   1427  17c5					      ENDIF
   1428  17c5					      ENDIF
   1429  17c5
   1430  17c5				   SelDigitAPtr
   1431  17c5		       c0 c8 d0 d8*	      .byte.b	<Gfx1_A, <Gfx2_A, <Gfx3_A, <Gfx4_A, <Gfx5_A
      0  17ca					      CHECKPAGE	SelDigitAPtr
      8  17ca					      LIST	ON
   1433  17ca				   SelDigitBPtr
   1434  17ca		       df e6 ed f4*	      .byte.b	<Gfx1_B-1, <Gfx2_B-1, <Gfx3_B-1, <Gfx4_B-1, <Gfx5_B-1
      0  17cf					      CHECKPAGE	(SelDigitBPtr-1)
      8  17cf					      LIST	ON
   1436  17cf
   1437  17cf				   SelMaxTbl
   1438  17cf				  -	      IF	FINAL_VERSION
   1439  17cf				  -	      .byte	4-1	; only A, E, I, M selectable
   1440  17cf					      ELSE
   1441  17cf					      IF	DEMO_VERSION = NO
   1442  17cf		       13		      .byte.b	20-1	; all caves selectable
   1443  17d0				  -	      ELSE
   1444  17d0				  -	      .byte	1-1	; no caves selectable
   1445  17d0					      ENDIF
   1446  17d0					      IF	DEMO_VERSION = NO
   1447  17d0		       04 01 01 	      .byte.b	NUM_LEVELS-1, 1, 1
   1448  17d3				  -	      ELSE
   1449  17d3				  -	      .byte	NUM_LEVELS-2-1
   1450  17d3					      ENDIF
   1451  17d3		       01 01		      .byte.b	1, 1
   1452  17d5
   1453  17d5							;--------------------------------------------------------------------------
   1454  17d5
   1455  17d5							;------------------------------------------------------------------------------
   1456  17d5
      0  17d5					      DEFINE_SUBROUTINE	DetectConsole
      1  17d5		       00 02	   BANK_DetectConsole =	_CURRENT_BANK
      2  17d5					      SUBROUTINE
      3  17d5				   DetectConsole
   1458  17d5
   1459  17d5							;	  ldx	  #$80	      ;       disable VDELP1, else detection will fail!
   1460  17d5							;	  stx	  VDELP1
   1461  17d5							;	  dex
   1462  17d5		       a2 7f		      ldx	#$7f	;
   1463  17d7		       86 61		      stx	HMP1	;	 move P1
   1464  17d9		       86 5d		      stx	ENAM0	;	 enable M0
   1465  17db		       86 5c		      stx	GRP1	;	 enable P1
   1466  17dd		       85 42		      sta	WSYNC
   1467  17df		       85 52		      sta	RESM0
   1468  17e1		       85 51		      sta	RESP1
   1469  17e3		       85 6a		      sta	HMOVE	;	 HMOVE during RESPx
   1470  17e5		       85 42		      sta	WSYNC	;	 start new line
   1471  17e7		       85 6c		      sta	CXCLR	;	 clear any collisions
   1472  17e9		       85 42		      sta	WSYNC	;	 wait one line
   1473  17eb		       a9 c0		      lda	#$f0-$30
   1474  17ed		       24 40		      bit	CXM0P	;	 if M0/P1 collision then
   1475  17ef		       30 02		      bmi	.compatible
   1476  17f1		       a9 10		      lda	#$50-$40	;	 console Kool Aid Man incompatible (Jr.) -- FIXED WOBBLE FOR ALL AD'S MACHINES
   1477  17f3				   .compatible
   1478  17f3		       85 89		      sta	hmJunior	;	 different HM values for Jr.
   1479  17f5							; reset graphics:
   1480  17f5		       a9 00		      lda	#0
   1481  17f7		       85 5d		      sta	ENAM0
   1482  17f9		       85 5c		      sta	GRP1
   1483  17fb
   1484  17fb		       a9 02		      lda	#%10	;	 ugly: make sure VBLANK is ON
   1485  17fd		       60		      rts
   1486  17fe
   1487  17fe
   1488  17fe				   FREE       SET	FREE + BANK_START + ROM_BANK_SIZE - .
   1489  17fe
 Free bytes in TITLE_BANK: $10
   1490  17fe					      ECHO	"Free bytes in TITLE_BANK:", FREE
   1491  17fe
      0  17fe					      CHECK_BANK_SIZE	"TITLE_BANK"
      1  17fe		       07 fe	   .TEMP      =	* - BANK_START
 TITLE_BANK (2K) SIZE =  $7fe , FREE= $2
      2  17fe					      ECHO	"TITLE_BANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  17fe				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  17fe				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  17fe				  -	      ERR
      6  17fe					      endif
------- FILE ./notBoulderDash.asm
------- FILE BANK_TITLE_LOGO.asm LEVEL 2 PASS 3
      0  17fe					      include	"BANK_TITLE_LOGO.asm"
      1  17fe							;------------------------------------------------------------------------------
      2  17fe							;##############################################################################
      3  17fe							;------------------------------------------------------------------------------
      4  17fe
      0  17fe					      NEWBANK	TITLE_LOGO_BANK
      1  1cdf ????				      SEG	TITLE_LOGO_BANK
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   TITLE_LOGO_BANK SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	TITLE_LOGO_BANK
      6  1800							;
      7  1800							;===============================================================================
      8  1800							; code starts here
      9  1800							;===============================================================================
     10  1800
     11  1800				   FREE       SET	0
     12  1800
     13  1800				   SwitchToNewFrameTitleBank SUBROUTINE
     14  1800		       a9 02		      lda	#BANK_TitleScreen	; 2
     15  1802		       85 3f		      sta	SET_BANK	; 3
     16  1804		       4c 9d f0 	      jmp	ContTitle	; 3 = 8
     17  1807
     18  1807							; unused, but required!
     19  1807		       00 00 00 00	      ds	4, 0
     20  180b							; coming from SwitchToDrawLogoBank
     21  180b
     22  180b							; fall through
     23  180b
     24  180b							;--------------------------------------------------------------------------
     25  180b							; 6-sprite routine; 32 lines of sprites for "First Star Software" logo.
      0  180b					      DEFINE_SUBROUTINE	DrawLogo
      1  180b		       00 03	   BANK_DrawLogo =	_CURRENT_BANK
      2  180b					      SUBROUTINE
      3  180b				   DrawLogo
     27  180b
     28  180b							;--------------------------------------------------------------------------
     29  180b							; Object X,Y positioning
     30  180b							; Timing is absolutely critical here!
     31  180b
     32  180b							;	     @29
     33  180b
     34  180b		       a9 a3		      lda	#$a3	; 2
     35  180d		       85 61		      sta	HMP1	; 3 =	5    @38
     36  180f
     37  180f							;    lda     #%00011		      ; 2
     38  180f		       85 44		      sta	NUSIZ0	; 3
     39  1811		       85 45		      sta	NUSIZ1	; 3
     40  1813		       85 65		      sta	VDELP0	; 3 = 11    @49
     41  1815
     42  1815		       85 50		      sta	RESP0	; 3	     @52
     43  1817		       85 51		      sta	RESP1	; 3 =	6    @55
     44  1819
     45  1819		       85 66		      sta	VDELP1	; 3
     46  181b		       a9 0e		      lda	#TWHITE	; 2
     47  181d		       85 47		      sta	COLUP1	; 3
     48  181f		       a0 0f		      ldy	#LKERNEL_H/2-1	; 2
     49  1821		       84 98		      sty	loopCntFSS	; 3 = 13    @68
     50  1823
     51  1823		       b9 9f 00 	      lda	audV0LstBtm,y	; 4
     52  1826		       29 0c		      and	#VOL_MASK	; 2
     53  1828							;---------------------------------------
     54  1828		       85 6a		      sta	HMOVE	; 3
     55  182a		       4c 5c f0 	      jmp	.enterFSSLoop	; 3 = 12    @04
     56  182d
     57  182d							;    ALIGN_FREE 256
     58  182d
     59  182d							;--------------------------------------------------------------------------
     60  182d							; Code is exquisitely timed so that each line takes
     61  182d							; *EXACTLY* 76 cycles.  Code cannot cross page-boundaries, as the branch
     62  182d							; would then take an extra cycle, and bugger the display.
     63  182d
     64  182d				   LoopFSS		;	     @13
     65  182d		       88		      dey		; 2
     66  182e		       84 98		      sty	loopCntFSS	; 3 =	5    @18
     67  1830
     68  1830		       b9 a3 f2 	      lda	FSSlogoB0,y	; 4
     69  1833		       85 5b		      sta	GRP0	; 3
     70  1835		       b9 b2 f2 	      lda	FSSlogoB1,y	; 4
     71  1838		       85 5c		      sta	GRP1	; 3
     72  183a		       b9 c1 f2 	      lda	FSSlogoB2,y	; 4
     73  183d		       85 5b		      sta	GRP0	; 3 = 21    @39
     74  183f
     75  183f		       b9 ee f2 	      lda	FSSlogoB5,y	; 4
     76  1842		       85 96		      sta	tmpGfx	; 3
     77  1844		       bf df f2 	      lax	FSSlogoB4,y	; 4
     78  1847		       b9 d0 f2 	      lda	FSSlogoB3,y	; 4 = 15
     79  184a		       a4 96		      ldy	tmpGfx	; 3
     80  184c		       85 5c		      sta	GRP1	; 3
     81  184e		       86 5b		      stx	GRP0	; 3
     82  1850		       84 5c		      sty	GRP1	; 3
     83  1852		       85 5b		      sta	GRP0	; 3 = 15    @69
     84  1854
     85  1854		       a4 98		      ldy	loopCntFSS	; 3
      0  1856					      SLEEP	2	; 2 =	5    @74
      1  1856				   .CYCLES    SET	2
      2  1856
      3  1856				  -	      IF	.CYCLES < 2
      4  1856				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1856				  -	      ERR
      6  1856					      ENDIF
      7  1856
      8  1856				  -	      IF	.CYCLES & 1
      9  1856				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1856				  -	      nop	0
     11  1856				  -	      ELSE
     12  1856				  -	      bit	VSYNC
     13  1856				  -	      ENDIF
     14  1856				  -.CYCLES    SET	.CYCLES - 3
     15  1856					      ENDIF
     16  1856
     17  1856					      REPEAT	.CYCLES / 2
     18  1856		       ea		      nop
     19  1857					      REPEND
     87  1857							;---------------------------------------
     88  1857		       b9 9f 00 	      lda	audV0LstBtm,y	; 4
     89  185a		       29 0c		      and	#VOL_MASK	; 2
     90  185c				   .enterFSSLoop		;	     @04
      0  185c					      UPDATE_MUSIC_SET_VOL	0	; 3	     @07!    <-- AUDV0
      1  185c					      IF	PLAY_CH_0 == YES
      2  185c		       85 59		      sta	AUDV0
      3  185e				  -	      ELSE
      4  185e				  -	      nop	AUDV0
      5  185e					      ENDIF
      0  185e					      UPDATE_MUSIC_DATA_LO	1	; 9 = 18    @16
      0  185e					      CHECK_CLC
      1  185e
      2  185e
      3  185e		       a5 92		      lda	audv1Lo
      4  1860		       65 8d		      adc	note1
      5  1862		       85 92		      sta	audv1Lo
     93  1864
     94  1864		       b9 43 f2 	      lda	FSSlogoA0,y	; 4
     95  1867		       8d 5b 00 	      sta.w	GRP0	; 4
     96  186a		       b9 53 f2 	      lda	FSSlogoA1,y	; 4
     97  186d		       85 5c		      sta	GRP1	; 3
     98  186f		       b9 63 f2 	      lda	FSSlogoA2,y	; 4
     99  1872		       85 5b		      sta	GRP0	; 3 = 22    @38
    100  1874
    101  1874		       b9 93 f2 	      lda	FSSlogoA5,y	; 4
    102  1877		       85 96		      sta	tmpGfx	; 3
    103  1879		       bf 83 f2 	      lax	FSSlogoA4,y	; 4
    104  187c		       b9 73 f2 	      lda	FSSlogoA3,y	; 4 = 15
    105  187f		       a4 96		      ldy	tmpGfx	; 3
    106  1881		       85 5c		      sta	GRP1	; 3
    107  1883		       86 5b		      stx	GRP0	; 3
    108  1885		       84 5c		      sty	GRP1	; 3
    109  1887		       85 5b		      sta	GRP0	; 3 = 15    @68
    110  1889
      0  1889					      UPDATE_MUSIC_DATA_HI	1	; 8	     @76
      1  1889		       a5 93		      lda	audv1Hi
      2  188b		       69 00		      adc	#0
      3  188d		       85 93		      sta	audv1Hi
    112  188f							;---------------------------------------
      0  188f					      UPDATE_MUSIC_VOL	1	; 7	     @07!    <-- AUDV1
      0  188f					      UPDATE_MUSIC_PREP_VOL	1
      1  188f		       29 06		      and	#VOL_MASK/2
      2  1891		       0a		      asl
      0  1892					      UPDATE_MUSIC_SET_VOL	1
      1  1892					      IF	PLAY_CH_1 == YES
      2  1892		       85 5a		      sta	AUDV1
      3  1894				  -	      ELSE
      4  1894				  -	      nop	AUDV1
      5  1894					      ENDIF
    114  1894
    115  1894		       a4 98		      ldy	loopCntFSS	; 3
    116  1896		       d0 95		      bne	LoopFSS	; 2/3= 5/6
      0  1898					      CHECKPAGE	LoopFSS
      8  1898					      LIST	ON
    118  1898		       84 5b		      sty	GRP0	; 3
    119  189a		       88		      dey
    120  189b		       84 41		      sty	VBLANK	; 3	     @20     Y = $ff, end of screen - enter blanking
    121  189d							; note: GRP1 is cleared later!
    122  189d
    123  189d							; here we return from the other bank:
      0  189d					      DEFINE_SUBROUTINE	ContTitle	;	     @17/18
      1  189d		       00 03	   BANK_ContTitle =	_CURRENT_BANK
      2  189d					      SUBROUTINE
      3  189d				   ContTitle
    125  189d							; copy last precalculated channel 0 value for on-the-fly calculations:
    126  189d		       a5 9e		      lda	audvTmpLo	; 3
    127  189f		       85 90		      sta	audv0Lo	; 3
    128  18a1		       a5 9f		      lda	audV0LstBtm	; 3		     should be always even...
    129  18a3		       4a		      lsr		; 2		     ...so no carry set here
    130  18a4		       85 91		      sta	audv0Hi	; 3 = 14    @32
    131  18a6
    132  18a6							; new BD music
    133  18a6		       a9 01		      lda	#NOTE_OFF_LEN-1	; 2		     run music for 7 frames, then turn off
    134  18a8		       c5 8a		      cmp	noteLen	; 3
    135  18aa		       30 78		      bmi	.skipChangeNote	; 2/3= 7/8	     C == 0 if taken!
    136  18ac		       a5 8a		      lda	noteLen	; 3		     update frame counter
    137  18ae		       30 2d		      bmi	.nextNote	; 2/3
    138  18b0
    139  18b0				   StopNote		;	     @46     debug label
    140  18b0							; calculate offset of precalculated values:
    141  18b0		       a0 27		      ldy	#(SCANLINES_NTSC-196)/2-1	;2
    142  18b2		       a5 81		      lda	Platform	; 3
    143  18b4		       f0 02		      beq	.stopNoteNTSC	; 2/3
    144  18b6		       a0 39		      ldy	#(SCANLINES_PAL-196)/2-1	; 2
    145  18b8				   .stopNoteNTSC
    146  18b8		       a6 8b		      ldx	noteIdx	; 3
    147  18ba		       bd 00 f3 	      lda	MusicData,x	; 4
    148  18bd							;a*y -> a:y, CF = 0
    149  18bd		       00 94	   .acc       =	audvOfsLo
    150  18bd		       00 95	   .aux       =	audvOfsHi
    151  18bd							;    dey			      ; 2
    152  18bd		       84 95		      sty	.aux	; 3
    153  18bf		       85 94		      sta	.acc	; 3
    154  18c1		       85 42		      sta	WSYNC
    155  18c3							;---------------------------------------
    156  18c3		       a9 00		      lda	#0	; 2
    157  18c5		       46 94		      lsr	.acc	; 5
    158  18c7		       a0 08		      ldy	#8	; 2
    159  18c9		       90 02		      bcc	.noAdd	; 2/3=17.5
    160  18cb				   .add
    161  18cb		       65 95		      adc	.aux	; 3
    162  18cd				   .noAdd
    163  18cd		       6a		      ror		; 2
    164  18ce		       66 94		      ror	.acc	; 5
    165  18d0		       88		      dey		; 2
    166  18d1		       b0 f8		      bcs	.add	; 2/3
    167  18d3		       d0 f8		      bne	.noAdd	; 2/3=14.5
    168  18d5							; max total: 17+120-1 = 136
    169  18d5							;    sta     WSYNC		      ; 	      no music, so no need to update waveforms here
    170  18d5							;    and     #$0f		      ; 	      mask upper 4 bits to avoid overflow
    171  18d5		       85 95		      sta	audvOfsHi	;		 audvOfsLo is in .acc
    172  18d7		       84 8c		      sty	note0	;		 Y == 0, turns off music
    173  18d9		       84 8d		      sty	note1
    174  18db		       90 50		      bcc	.exitUpdateNote	;		 or .exitStopNote, but then audV0LstBtm cannot be assumed always even
    175  18dd
    176  18dd							;-------------------------------------------------------------------------------
    177  18dd				   .nextNote		;
    178  18dd		       85 42		      sta	WSYNC	;		 no music, so no need to update waveforms here
    179  18df
    180  18df		       a5 8e		      lda	inputBuffer
    181  18e1		       2d 80 02 	      and	SWCHA
    182  18e4		       a4 8b		      ldy	noteIdx
    183  18e6		       d0 1b		      bne	.contTitle
    184  18e8				   _CountDown		;		 label defined for debugging only
    185  18e8		       a6 8f		      ldx	demoDelay	;		 get collected input over the last 256 notes (initially 0!)
    186  18ea		       c9 f0		      cmp	#$f0	;		 any input?
    187  18ec		       f0 04		      beq	.noInput
    188  18ee		       a2 02		      ldx	#DEMO_DELAY+1	;		 yes, reset delay
    189  18f0		       a9 f0		      lda	#$f0
    190  18f2				   .noInput
    191  18f2		       18		      clc
    192  18f3		       ca		      dex
    193  18f4					      IF	DEMO_VERSION = NO
    194  18f4		       86 8f		      stx	demoDelay	;		 no input for DEMO_DELAY frames?
    195  18f6				  -	      ELSE
    196  18f6				  -	      ldx	#1
    197  18f6					      ENDIF
    198  18f6		       d0 0b		      bne	.contTitle
    199  18f8		       86 82		      stx	sCave	;		 yes, switch to demo mode
    200  18fa		       86 83		      stx	sLevel
    201  18fc		       a9 80		      lda	#$80
    202  18fe		       85 85		      sta	sJoysticks	;		 -> jtoggle = demoMode
    203  1900		       4c c1 f1 	      jmp	ExitTitle
    204  1903
    205  1903				   .contTitle
    206  1903		       85 8e		      sta	inputBuffer
    207  1905
    208  1905							;	  lda	  #0
    209  1905							;	  sta	  audv0Lo
    210  1905							;	  sta	  audv0Hi
    211  1905							;	  sta	  audv1Lo
    212  1905							;	  sta	  audv1Hi
    213  1905		       85 42		      sta	WSYNC
    214  1907							;---------------------------------------
    215  1907		       a2 08		      ldx	#NOTE_LEN_NTSC-1
    216  1909					      IF	NOTE_LEN_NTSC > NOTE_LEN_PAL
    217  1909		       a5 81		      lda	Platform
    218  190b		       f0 01		      beq	.ntscLen
    219  190d		       ca		      dex		;		     == NOTE_LEN_PAL-1
    220  190e				   .ntscLen
    221  190e					      ENDIF
    222  190e		       86 8a		      stx	noteLen	;		     reset frame counter
    223  1910
    224  1910		       a4 8b		      ldy	noteIdx
    225  1912		       b9 00 f3 	      lda	MusicData,y	;		     grab and store next channel 0 note
    226  1915		       85 8c		      sta	note0
    227  1917		       c8		      iny		;		     next channel
    228  1918		       b9 00 f3 	      lda	MusicData,y	;		     grab and store next channel 1 note
    229  191b		       85 8d		      sta	note1
    230  191d		       c8		      iny
    231  191e		       84 8b		      sty	noteIdx	;		     get ready for next note
    232  1920		       85 42		      sta	WSYNC	;		     still no music yet, don't update waveforms
    233  1922							;---------------------------------------
    234  1922		       90 09		      bcc	.exitUpdateNote
    235  1924
    236  1924							;-------------------------------------------------------------------------------
    237  1924				   TEST2
    238  1924				   .skipChangeNote		;	     @40/41  still playing current notes
    239  1924		       20 1b f2 	      jsr	UpdateMusicWSync0L	;39
    240  1927		       20 2f f2 	      jsr	UpdateMusicWSync1L	;39
    241  192a		       20 1b f2 	      jsr	UpdateMusicWSync0L	;39
    242  192d
    243  192d				   .exitUpdateNote
      0  192d					      CHECK_CLC
      1  192d
    245  192d		       a5 90		      lda	audv0Lo	; 3
    246  192f		       65 94		      adc	audvOfsLo	; 3
    247  1931		       85 9e		      sta	audvTmpLo	; 3
    248  1933		       a5 91		      lda	audv0Hi	; 3
    249  1935							;    and     #$0f		      ; 2	      mask upper 4 bits to avoid overflow here and later
    250  1935		       65 95		      adc	audvOfsHi	; 3		  ...now this can't overflow!
    251  1937		       0a		      asl		; 2
    252  1938		       18		      clc
    253  1939
    254  1939				   .exitStopNote
    255  1939					      IF	L276
    256  1939		       a0 06		      ldy	#(36-PC_BTM/2)/2	; 2
    257  193b				  -	      ELSE
    258  193b				  -	      ldy	#(28-PC_BTM/2)/2	; 2
    259  193b					      ENDIF
    260  193b		       a6 81		      ldx	Platform	; 3
    261  193d		       f0 02		      beq	.overScanNTSC	; 2/3
    262  193f		       a0 09		      ldy	#(42-PC_BTM/2)/2	; 2 =	9
    263  1941				   .overScanNTSC
    264  1941		       84 96		      sty	tmpY
    265  1943
    266  1943							; here we precalculate the first 48 values:
    267  1943		       a8		      tay		; 2
    268  1944		       a2 2f		      ldx	#PC_BTM-1	; 2
    269  1946				   .loopOverScan
    270  1946							;---------------------------------------
      0  1946					      UPDATE_MUSIC_WSYNC	1	;27	     @07     maintain sound while precalcuating
      0  1946					      UPDATE_MUSIC_DATA	1
      0  1946					      UPDATE_MUSIC_DATA_LO	1
      0  1946					      CHECK_CLC
      1  1946
      2  1946
      3  1946		       a5 92		      lda	audv1Lo
      4  1948		       65 8d		      adc	note1
      5  194a		       85 92		      sta	audv1Lo
      0  194c					      UPDATE_MUSIC_DATA_HI	1
      1  194c		       a5 93		      lda	audv1Hi
      2  194e		       69 00		      adc	#0
      3  1950		       85 93		      sta	audv1Hi
      2  1952		       85 42		      sta	WSYNC
      3  1954
      0  1954					      UPDATE_MUSIC_VOL	1
      0  1954					      UPDATE_MUSIC_PREP_VOL	1
      1  1954		       29 06		      and	#VOL_MASK/2
      2  1956		       0a		      asl
      0  1957					      UPDATE_MUSIC_SET_VOL	1
      1  1957					      IF	PLAY_CH_1 == YES
      2  1957		       85 5a		      sta	AUDV1
      3  1959				  -	      ELSE
      4  1959				  -	      nop	AUDV1
      5  1959					      ENDIF
    272  1959							; 1st calculation:
      0  1959					      CHECK_CLC
      1  1959
    274  1959		       a5 9e		      lda	audvTmpLo	; 3
    275  195b		       65 8c		      adc	note0	; 3 =	6
    276  195d		       90 03		      bcc	.skipHi1	; 2/3
    277  195f		       c8		      iny		; 2
    278  1960		       c8		      iny		; 2
    279  1961		       18		      clc		; 2
    280  1962				   .skipHi1
    281  1962		       94 cf		      sty	audV0Lst+PC_TOP,x	; 4
    282  1964		       ca		      dex		; 2 = 14
    283  1965							; 2nd calculation:
      0  1965					      CHECK_CLC
      1  1965
    285  1965		       65 8c		      adc	note0	; 3
    286  1967		       85 9e		      sta	audvTmpLo	; 3 =	6
    287  1969		       90 03		      bcc	.skipHi2	; 2/3
    288  196b		       c8		      iny		; 2
    289  196c		       c8		      iny		; 2
    290  196d		       18		      clc		; 2
    291  196e				   .skipHi2
    292  196e		       94 cf		      sty	audV0Lst+PC_TOP,x	; 4
    293  1970		       ca		      dex		; 2 = 14
    294  1971							; total: 63					 @47 max
    295  1971							;---------------------------------------
      0  1971					      UPDATE_MUSIC_WSYNC	0	;27	     @07     maintain sound while precalcuating
      0  1971					      UPDATE_MUSIC_DATA	0
      0  1971					      UPDATE_MUSIC_DATA_LO	0
      0  1971					      CHECK_CLC
      1  1971
      2  1971
      3  1971		       a5 90		      lda	audv0Lo
      4  1973		       65 8c		      adc	note0
      5  1975		       85 90		      sta	audv0Lo
      0  1977					      UPDATE_MUSIC_DATA_HI	0
      1  1977		       a5 91		      lda	audv0Hi
      2  1979		       69 00		      adc	#0
      3  197b		       85 91		      sta	audv0Hi
      2  197d		       85 42		      sta	WSYNC
      3  197f
      0  197f					      UPDATE_MUSIC_VOL	0
      0  197f					      UPDATE_MUSIC_PREP_VOL	0
      1  197f		       29 06		      and	#VOL_MASK/2
      2  1981		       0a		      asl
      0  1982					      UPDATE_MUSIC_SET_VOL	0
      1  1982					      IF	PLAY_CH_0 == YES
      2  1982		       85 59		      sta	AUDV0
      3  1984				  -	      ELSE
      4  1984				  -	      nop	AUDV0
      5  1984					      ENDIF
    297  1984							; 3rd calculation:
      0  1984					      CHECK_CLC
      1  1984
    299  1984		       a5 9e		      lda	audvTmpLo	; 3
    300  1986		       65 8c		      adc	note0	; 3 =	6
    301  1988		       90 03		      bcc	.skipHi3	; 2/3
    302  198a		       c8		      iny		; 2
    303  198b		       c8		      iny		; 2
    304  198c		       18		      clc		; 2
    305  198d				   .skipHi3
    306  198d		       94 cf		      sty	audV0Lst+PC_TOP,x	; 4
    307  198f		       ca		      dex		; 2 = 14
    308  1990							; 4th calculation:
      0  1990					      CHECK_CLC
      1  1990
    310  1990		       65 8c		      adc	note0	; 3
    311  1992		       85 9e		      sta	audvTmpLo	; 3 =	6
    312  1994		       90 03		      bcc	.skipHi4	; 2/3
    313  1996		       c8		      iny		; 2
    314  1997		       c8		      iny		; 2
    315  1998		       18		      clc		; 2
    316  1999				   .skipHi4
    317  1999		       94 cf		      sty	audV0Lst+PC_TOP,x	; 4
    318  199b		       ca		      dex		; 2 = 14
    319  199c		       10 a8		      bpl	.loopOverScan	; 2/3
    320  199e
    321  199e		       a4 96		      ldy	tmpY	; 3
    322  19a0				   .waitOverScan
    323  19a0							;---------------------------------------
    324  19a0							;    jsr     UpdateMusicWSync1L      ;39
      0  19a0					      UPDATE_MUSIC_WSYNC	1	;27	     @07     maintain sound while precalcuating
      0  19a0					      UPDATE_MUSIC_DATA	1
      0  19a0					      UPDATE_MUSIC_DATA_LO	1
      0  19a0					      CHECK_CLC
      1  19a0
      2  19a0
      3  19a0		       a5 92		      lda	audv1Lo
      4  19a2		       65 8d		      adc	note1
      5  19a4		       85 92		      sta	audv1Lo
      0  19a6					      UPDATE_MUSIC_DATA_HI	1
      1  19a6		       a5 93		      lda	audv1Hi
      2  19a8		       69 00		      adc	#0
      3  19aa		       85 93		      sta	audv1Hi
      2  19ac		       85 42		      sta	WSYNC
      3  19ae
      0  19ae					      UPDATE_MUSIC_VOL	1
      0  19ae					      UPDATE_MUSIC_PREP_VOL	1
      1  19ae		       29 06		      and	#VOL_MASK/2
      2  19b0		       0a		      asl
      0  19b1					      UPDATE_MUSIC_SET_VOL	1
      1  19b1					      IF	PLAY_CH_1 == YES
      2  19b1		       85 5a		      sta	AUDV1
      3  19b3				  -	      ELSE
      4  19b3				  -	      nop	AUDV1
      5  19b3					      ENDIF
    326  19b3
    327  19b3		       a5 88		      lda	btnReleased	; 3
    328  19b5		       f0 16		      beq	.notReleased	; 2/3
    329  19b7		       24 4c		      bit	INPT4	; 4	     button pressed?
    330  19b9		       30 18		      bmi	.exitButton	; 2/3
    331  19bb
    332  19bb							; switch to next mode:
    333  19bb		       c6 88		      dec	btnReleased	; 5
    334  19bd		       c6 86		      dec	titleMode	; 5
    335  19bf		       10 12		      bpl	.exitButton	; 2/3
    336  19c1							;--------------------------------------------------------------------------
    337  19c1							; title screen done
    338  19c1							; clear the RAM (between Platform and last zeropage variables) to avoid wrongly initialized variables
    339  19c1				   ExitTitle		;	     debug label  only
    340  19c1		       a9 00		      lda	#0
    341  19c3		       a2 57		      ldx	#DSL-endTitleClear-1
    342  19c5				   .loopClear
    343  19c5		       95 87		      sta	endTitleClear+1,x
    344  19c7		       ca		      dex
    345  19c8		       10 fb		      bpl	.loopClear
    346  19ca		       4c f5 fc 	      jmp	ExitTitleScreen
    347  19cd
    348  19cd				   .notReleased
    349  19cd		       24 4c		      bit	INPT4	; 4	     button released?
    350  19cf		       10 02		      bpl	.exitButton	; 2/3
    351  19d1		       e6 88		      inc	btnReleased	; 5
    352  19d3				   .exitButton		;   = 24    @31 max
    353  19d3
    354  19d3							; free: 20
    355  19d3							; prepare evaluating joystick up and down:
    356  19d3		       a6 9d		      ldx	selRow	; 3
    357  19d5		       ad 80 02 	      lda	SWCHA	; 4
    358  19d8		       49 ff		      eor	#$ff	; 2
    359  19da		       0a		      asl		; 2
    360  19db		       0a		      asl		; 2
    361  19dc		       48		      pha		; 3
    362  19dd		       18		      clc		; 2 = 18
    363  19de							;---------------------------------------
    364  19de							;    jsr     UpdateMusicWSync0L      ;39	  @13
      0  19de					      UPDATE_MUSIC_WSYNC	0	;27	     @07
      0  19de					      UPDATE_MUSIC_DATA	0
      0  19de					      UPDATE_MUSIC_DATA_LO	0
      0  19de					      CHECK_CLC
      1  19de
      2  19de
      3  19de		       a5 90		      lda	audv0Lo
      4  19e0		       65 8c		      adc	note0
      5  19e2		       85 90		      sta	audv0Lo
      0  19e4					      UPDATE_MUSIC_DATA_HI	0
      1  19e4		       a5 91		      lda	audv0Hi
      2  19e6		       69 00		      adc	#0
      3  19e8		       85 91		      sta	audv0Hi
      2  19ea		       85 42		      sta	WSYNC
      3  19ec
      0  19ec					      UPDATE_MUSIC_VOL	0
      0  19ec					      UPDATE_MUSIC_PREP_VOL	0
      1  19ec		       29 06		      and	#VOL_MASK/2
      2  19ee		       0a		      asl
      0  19ef					      UPDATE_MUSIC_SET_VOL	0
      1  19ef					      IF	PLAY_CH_0 == YES
      2  19ef		       85 59		      sta	AUDV0
      3  19f1				  -	      ELSE
      4  19f1				  -	      nop	AUDV0
      5  19f1					      ENDIF
    366  19f1
    367  19f1		       68		      pla		; 4
    368  19f2
    369  19f2		       88		      dey		; 2
    370  19f3		       d0 ab		      bne	.waitOverScan	; 2/3= 8/9
    371  19f5
    372  19f5		       84 5c		      sty	GRP1	; 3 =	3    @18
    373  19f7
    374  19f7		       0a		      asl		; 2
    375  19f8		       90 13		      bcc	.notDown	; 2/3
    376  19fa		       e8		      inx		; 2
    377  19fb		       a5 84		      lda	sPlayers	; 3
    378  19fd		       f0 07		      beq	.onePlayer	; 2/3
    379  19ff		       e0 04		      cpx	#NUM_SEL	; 2
    380  1a01		       90 0f		      bcc	.setJoyY	; 2/3
    381  1a03		       18		      clc		; 2
    382  1a04		       90 12		      bcc	.skipJoyY	; 3
    383  1a06
    384  1a06				   .onePlayer		;12
    385  1a06		       e0 03		      cpx	#NUM_SEL-1	; 2
    386  1a08		       90 08		      bcc	.setJoyY	; 2/3
    387  1a0a		       18		      clc		; 2
    388  1a0b		       90 0b		      bcc	.skipJoyY	; 3 = 21
    389  1a0d
    390  1a0d				   .notDown		; 5
    391  1a0d		       10 09		      bpl	.skipJoyY	; 2/3
    392  1a0f		       ca		      dex		; 2
    393  1a10					      IF	DEMO_VERSION = NO
    394  1a10		       30 06		      bmi	.skipJoyY	; 2/3
    395  1a12				  -	      ELSE
    396  1a12				  -	      beq	.skipJoyY	; 2/3
    397  1a12					      ENDIF
    398  1a12				   .setJoyY
    399  1a12		       a5 8a		      lda	noteLen	; 3
    400  1a14		       d0 02		      bne	.skipJoyY	; 2/3
    401  1a16		       86 9d		      stx	selRow	; 3 =	8
    402  1a18				   .skipJoyY		;
    403  1a18							; free: 5
    404  1a18							;    jmp     NewFrameTitle	      ; 3 = 29 max
    405  1a18		       4c 00 f0 	      jmp	SwitchToNewFrameTitleBank	;11 = 37 max
    406  1a1b
    407  1a1b							;-----------------------------------------------------------
    408  1a1b
    409  1a1b				   UpdateMusicWSync0L
    410  1a1b							; maintain first channel
      0  1a1b					      UPDATE_MUSIC_WSYNC	0	;27
      0  1a1b					      UPDATE_MUSIC_DATA	0
      0  1a1b					      UPDATE_MUSIC_DATA_LO	0
      0  1a1b					      CHECK_CLC
      1  1a1b
      2  1a1b
      3  1a1b		       a5 90		      lda	audv0Lo
      4  1a1d		       65 8c		      adc	note0
      5  1a1f		       85 90		      sta	audv0Lo
      0  1a21					      UPDATE_MUSIC_DATA_HI	0
      1  1a21		       a5 91		      lda	audv0Hi
      2  1a23		       69 00		      adc	#0
      3  1a25		       85 91		      sta	audv0Hi
      2  1a27		       85 42		      sta	WSYNC
      3  1a29
      0  1a29					      UPDATE_MUSIC_VOL	0
      0  1a29					      UPDATE_MUSIC_PREP_VOL	0
      1  1a29		       29 06		      and	#VOL_MASK/2
      2  1a2b		       0a		      asl
      0  1a2c					      UPDATE_MUSIC_SET_VOL	0
      1  1a2c					      IF	PLAY_CH_0 == YES
      2  1a2c		       85 59		      sta	AUDV0
      3  1a2e				  -	      ELSE
      4  1a2e				  -	      nop	AUDV0
      5  1a2e					      ENDIF
    412  1a2e		       60		      rts		; 6 = 33
    413  1a2f
    414  1a2f				   UpdateMusicWSync1L
    415  1a2f							; maintain second channel
      0  1a2f					      UPDATE_MUSIC_WSYNC	1	;27
      0  1a2f					      UPDATE_MUSIC_DATA	1
      0  1a2f					      UPDATE_MUSIC_DATA_LO	1
      0  1a2f					      CHECK_CLC
      1  1a2f
      2  1a2f
      3  1a2f		       a5 92		      lda	audv1Lo
      4  1a31		       65 8d		      adc	note1
      5  1a33		       85 92		      sta	audv1Lo
      0  1a35					      UPDATE_MUSIC_DATA_HI	1
      1  1a35		       a5 93		      lda	audv1Hi
      2  1a37		       69 00		      adc	#0
      3  1a39		       85 93		      sta	audv1Hi
      2  1a3b		       85 42		      sta	WSYNC
      3  1a3d
      0  1a3d					      UPDATE_MUSIC_VOL	1
      0  1a3d					      UPDATE_MUSIC_PREP_VOL	1
      1  1a3d		       29 06		      and	#VOL_MASK/2
      2  1a3f		       0a		      asl
      0  1a40					      UPDATE_MUSIC_SET_VOL	1
      1  1a40					      IF	PLAY_CH_1 == YES
      2  1a40		       85 5a		      sta	AUDV1
      3  1a42				  -	      ELSE
      4  1a42				  -	      nop	AUDV1
      5  1a42					      ENDIF
    417  1a42		       60		      rts		; 6 = 33
    418  1a43
    419  1a43							;-----------------------------------------------------------
      0  1a43					      OPTIONAL_PAGEBREAK	"FSSlogo", (31*6)
     10  1a43					      LIST	ON
    421  1a43							;    ALIGN_FREE 256
    422  1a43
    423  1a43				   FSSlogo
    424  1a43				   FSSlogoA0
    425  1a43		       00		      .byte.b	0
    426  1a44		       ff		      .byte.b	255
    427  1a45		       00		      .byte.b	0
    428  1a46		       ff		      .byte.b	255
    429  1a47		       00		      .byte.b	0
    430  1a48		       01		      .byte.b	1
    431  1a49		       03		      .byte.b	3
    432  1a4a		       06		      .byte.b	6
    433  1a4b		       07		      .byte.b	7
    434  1a4c		       00		      .byte.b	0
    435  1a4d		       0c		      .byte.b	12
    436  1a4e		       07		      .byte.b	7
    437  1a4f		       03		      .byte.b	3
    438  1a50		       07		      .byte.b	7
    439  1a51		       0c		      .byte.b	12
    440  1a52		       00		      .byte.b	0
    441  1a53				   FSSlogoA1
    442  1a53		       09		      .byte.b	9
    443  1a54		       d5		      .byte.b	213
    444  1a55		       6d		      .byte.b	109
    445  1a56		       6f		      .byte.b	111
    446  1a57		       e1		      .byte.b	225
    447  1a58		       83		      .byte.b	131
    448  1a59		       06		      .byte.b	6
    449  1a5a		       0c		      .byte.b	12
    450  1a5b		       db		      .byte.b	219
    451  1a5c		       70		      .byte.b	112
    452  1a5d		       60		      .byte.b	96
    453  1a5e		       60		      .byte.b	96
    454  1a5f		       bf		      .byte.b	191
    455  1a60		       e0		      .byte.b	224
    456  1a61		       cc		      .byte.b	204
    457  1a62		       40		      .byte.b	64
    458  1a63				   FSSlogoA2
    459  1a63		       12		      .byte.b	18
    460  1a64		       95		      .byte.b	149
    461  1a65		       fc		      .byte.b	252
    462  1a66		       33		      .byte.b	51
    463  1a67		       b3		      .byte.b	179
    464  1a68		       33		      .byte.b	51
    465  1a69		       33		      .byte.b	51
    466  1a6a		       33		      .byte.b	51
    467  1a6b		       fb		      .byte.b	251
    468  1a6c		       00		      .byte.b	0
    469  1a6d		       22		      .byte.b	34
    470  1a6e		       22		      .byte.b	34
    471  1a6f		       ba		      .byte.b	186
    472  1a70		       22		      .byte.b	34
    473  1a71		       3a		      .byte.b	58
    474  1a72		       00		      .byte.b	0
    475  1a73				   FSSlogoA3
    476  1a73		       95		      .byte.b	149
    477  1a74		       5d		      .byte.b	93
    478  1a75		       49		      .byte.b	73
    479  1a76		       36		      .byte.b	54
    480  1a77		       36		      .byte.b	54
    481  1a78		       f7		      .byte.b	247
    482  1a79		       36		      .byte.b	54
    483  1a7a		       36		      .byte.b	54
    484  1a7b		       f7		      .byte.b	247
    485  1a7c		       00		      .byte.b	0
    486  1a7d		       d7		      .byte.b	215
    487  1a7e		       e0		      .byte.b	224
    488  1a7f		       f7		      .byte.b	247
    489  1a80		       d4		      .byte.b	212
    490  1a81		       f7		      .byte.b	247
    491  1a82		       00		      .byte.b	0
    492  1a83				   FSSlogoA4
    493  1a83		       5c		      .byte.b	92
    494  1a84		       98		      .byte.b	152
    495  1a85		       9c		      .byte.b	156
    496  1a86		       70		      .byte.b	112
    497  1a87		       f0		      .byte.b	240
    498  1a88		       e0		      .byte.b	224
    499  1a89		       70		      .byte.b	112
    500  1a8a		       70		      .byte.b	112
    501  1a8b		       f0		      .byte.b	240
    502  1a8c		       00		      .byte.b	0
    503  1a8d		       b0		      .byte.b	176
    504  1a8e		       b0		      .byte.b	176
    505  1a8f		       b7		      .byte.b	183
    506  1a90		       30		      .byte.b	48
    507  1a91		       7b		      .byte.b	123
    508  1a92		       00		      .byte.b	0
    509  1a93				   FSSlogoA5
    510  1a93		       ab		      .byte.b	%10101011
    511  1a94		       2a		      .byte.b	%00101010
    512  1a95		       00		      .byte.b	%00000000
    513  1a96		       00		      .byte.b	0
    514  1a97		       00		      .byte.b	0
    515  1a98		       00		      .byte.b	0
    516  1a99		       00		      .byte.b	0
    517  1a9a		       00		      .byte.b	0
    518  1a9b		       00		      .byte.b	0
    519  1a9c		       00		      .byte.b	0
    520  1a9d		       00		      .byte.b	0
    521  1a9e		       00		      .byte.b	0
    522  1a9f		       ff		      .byte.b	255
    523  1aa0		       00		      .byte.b	0
    524  1aa1		       ff		      .byte.b	255
    525  1aa2		       00		      .byte.b	0
    526  1aa3
    527  1aa3				   FSSlogoB0
    528  1aa3		       ff		      .byte.b	255
    529  1aa4		       ff		      .byte.b	255
    530  1aa5		       00		      .byte.b	0
    531  1aa6		       fe		      .byte.b	254
    532  1aa7		       01		      .byte.b	1
    533  1aa8		       03		      .byte.b	3
    534  1aa9		       07		      .byte.b	7
    535  1aaa		       06		      .byte.b	6
    536  1aab		       07		      .byte.b	7
    537  1aac		       18		      .byte.b	24
    538  1aad		       07		      .byte.b	7
    539  1aae		       03		      .byte.b	3
    540  1aaf		       03		      .byte.b	3
    541  1ab0		       07		      .byte.b	7
    542  1ab1		       00		      .byte.b	0
    543  1ab2				   FSSlogoB1
    544  1ab2		       9d		      .byte.b	157
    545  1ab3		       d5		      .byte.b	213
    546  1ab4		       60		      .byte.b	96
    547  1ab5		       6f		      .byte.b	111
    548  1ab6		       c3		      .byte.b	195
    549  1ab7		       87		      .byte.b	135
    550  1ab8		       0e		      .byte.b	14
    551  1ab9		       18		      .byte.b	24
    552  1aba		       b7		      .byte.b	183
    553  1abb		       e0		      .byte.b	224
    554  1abc		       60		      .byte.b	96
    555  1abd		       7c		      .byte.b	124
    556  1abe		       df		      .byte.b	223
    557  1abf		       f8		      .byte.b	248
    558  1ac0		       40		      .byte.b	64
    559  1ac1				   FSSlogoB2
    560  1ac1		       12		      .byte.b	18
    561  1ac2		       15		      .byte.b	21
    562  1ac3		       00		      .byte.b	0
    563  1ac4		       b3		      .byte.b	179
    564  1ac5		       b3		      .byte.b	179
    565  1ac6		       33		      .byte.b	51
    566  1ac7		       33		      .byte.b	51
    567  1ac8		       33		      .byte.b	51
    568  1ac9		       f9		      .byte.b	249
    569  1aca		       00		      .byte.b	0
    570  1acb		       22		      .byte.b	34
    571  1acc		       22		      .byte.b	34
    572  1acd		       ba		      .byte.b	186
    573  1ace		       22		      .byte.b	34
    574  1acf		       3a		      .byte.b	58
    575  1ad0				   FSSlogoB3
    576  1ad0		       95		      .byte.b	149
    577  1ad1		       55		      .byte.b	85
    578  1ad2		       00		      .byte.b	0
    579  1ad3		       36		      .byte.b	54
    580  1ad4		       f7		      .byte.b	247
    581  1ad5		       f7		      .byte.b	247
    582  1ad6		       36		      .byte.b	54
    583  1ad7		       f7		      .byte.b	247
    584  1ad8		       f7		      .byte.b	247
    585  1ad9		       00		      .byte.b	0
    586  1ada		       f7		      .byte.b	247
    587  1adb		       e0		      .byte.b	224
    588  1adc		       f7		      .byte.b	247
    589  1add		       d4		      .byte.b	212
    590  1ade		       f7		      .byte.b	247
    591  1adf				   FSSlogoB4
    592  1adf		       50		      .byte.b	80
    593  1ae0		       50		      .byte.b	80
    594  1ae1		       00		      .byte.b	0
    595  1ae2		       f0		      .byte.b	240
    596  1ae3		       c0		      .byte.b	192
    597  1ae4		       f0		      .byte.b	240
    598  1ae5		       70		      .byte.b	112
    599  1ae6		       f0		      .byte.b	240
    600  1ae7		       e0		      .byte.b	224
    601  1ae8		       00		      .byte.b	0
    602  1ae9		       b0		      .byte.b	176
    603  1aea		       b0		      .byte.b	176
    604  1aeb		       b7		      .byte.b	183
    605  1aec		       30		      .byte.b	48
    606  1aed		       7b		      .byte.b	123
    607  1aee				   FSSlogoB5
    608  1aee		       aa		      .byte.b	%10101010
    609  1aef		       b1		      .byte.b	%10110001
    610  1af0		       00		      .byte.b	0
    611  1af1		       00		      .byte.b	0
    612  1af2		       00		      .byte.b	0
    613  1af3		       00		      .byte.b	0
    614  1af4		       00		      .byte.b	0
    615  1af5		       00		      .byte.b	0
    616  1af6		       00		      .byte.b	0
    617  1af7		       00		      .byte.b	0
    618  1af8		       00		      .byte.b	0
    619  1af9		       00		      .byte.b	0
    620  1afa		       ff		      .byte.b	255
    621  1afb		       00		      .byte.b	0
    622  1afc		       ff		      .byte.b	255
      0  1afd					      CHECKPAGE	FSSlogo
      8  1afd					      LIST	ON
    624  1afd
      0  1afd					      ALIGN_FREE	256
      1  1afd				   FREE       SET	FREE - .
      2  1b00		       00 00 00 	      align	256
      3  1b00				   FREE       SET	FREE + .
 @ $f300 : $3
      4  1b00					      echo	"@", ., ":", FREE
    626  1b00
    627  1b00							; Music data for two channels
    628  1b00							; exactly 256 bytes, must start at page start!
    629  1b00				   MusicData
    630  1b00		       2d 17		      .byte.b	45 , 23
    631  1b02		       39 22		      .byte.b	57 , 34
    632  1b04		       44 2d		      .byte.b	68 , 45
    633  1b06		       5b 36		      .byte.b	91 , 54
    634  1b08		       33 14		      .byte.b	51 , 20
    635  1b0a		       3d 26		      .byte.b	61 , 38
    636  1b0c		       44 28		      .byte.b	68 , 40
    637  1b0e		       66 3d		      .byte.b	102, 61
    638  1b10		       48 12		      .byte.b	72 , 18
    639  1b12		       51 12		      .byte.b	81 , 18
    640  1b14		       5b 24		      .byte.b	91 , 36
    641  1b16		       6c 12		      .byte.b	108, 18
    642  1b18		       51 28		      .byte.b	81 , 40
    643  1b1a		       99 79		      .byte.b	153, 121
    644  1b1c		       56 2b		      .byte.b	86 , 43
    645  1b1e		       88 6c		      .byte.b	136, 108
    646  1b20		       2d 17		      .byte.b	45 , 23
    647  1b22		       5b 17		      .byte.b	91 , 23
    648  1b24		       22 17		      .byte.b	34 , 23
    649  1b26		       33 17		      .byte.b	51 , 23
    650  1b28		       28 14		      .byte.b	40 , 20
    651  1b2a		       66 14		      .byte.b	102, 20
    652  1b2c		       33 14		      .byte.b	51 , 20
    653  1b2e		       28 14		      .byte.b	40 , 20
    654  1b30		       2d 17		      .byte.b	45 , 23
    655  1b32		       5b 17		      .byte.b	91 , 23
    656  1b34		       22 17		      .byte.b	34 , 23
    657  1b36		       33 17		      .byte.b	51 , 23
    658  1b38		       48 24		      .byte.b	72 , 36
    659  1b3a		       b6 24		      .byte.b	182, 36
    660  1b3c		       5b 24		      .byte.b	91 , 36
    661  1b3e		       48 24		      .byte.b	72 , 36
    662  1b40		       51 14		      .byte.b	81 , 20
    663  1b42		       51 14		      .byte.b	81 , 20
    664  1b44		       1e 14		      .byte.b	30 , 20
    665  1b46		       2d 14		      .byte.b	45 , 20
    666  1b48		       40 20		      .byte.b	64 , 32
    667  1b4a		       a2 20		      .byte.b	162, 32
    668  1b4c		       51 20		      .byte.b	81 , 32
    669  1b4e		       40 20		      .byte.b	64 , 32
    670  1b50		       22 11		      .byte.b	34 , 17
    671  1b52		       56 44		      .byte.b	86 , 68
    672  1b54		       26 11		      .byte.b	38 , 17
    673  1b56		       5b 44		      .byte.b	91 , 68
    674  1b58		       3d 0f		      .byte.b	61 , 15
    675  1b5a		       3d 0f		      .byte.b	61 , 15
    676  1b5c		       79 17		      .byte.b	121, 23
    677  1b5e		       3d 17		      .byte.b	61 , 23
    678  1b60		       5b 17		      .byte.b	91 , 23
    679  1b62		       5b 17		      .byte.b	91 , 23
    680  1b64		       5b 17		      .byte.b	91 , 23
    681  1b66		       5b 17		      .byte.b	91 , 23
    682  1b68		       5b 2d		      .byte.b	91 , 45
    683  1b6a		       5b 2d		      .byte.b	91 , 45
    684  1b6c		       5b 17		      .byte.b	91 , 23
    685  1b6e		       5b 17		      .byte.b	91 , 23
    686  1b70		       5b 14		      .byte.b	91 , 20
    687  1b72		       5b 14		      .byte.b	91 , 20
    688  1b74		       5b 14		      .byte.b	91 , 20
    689  1b76		       5b 14		      .byte.b	91 , 20
    690  1b78		       5b 28		      .byte.b	91 , 40
    691  1b7a		       5b 28		      .byte.b	91 , 40
    692  1b7c		       5b 14		      .byte.b	91 , 20
    693  1b7e		       5b 14		      .byte.b	91 , 20
    694  1b80		       5b 17		      .byte.b	91 , 23
    695  1b82		       73 5b		      .byte.b	115, 91
    696  1b84		       5b 17		      .byte.b	91 , 23
    697  1b86		       79 5b		      .byte.b	121, 91
    698  1b88		       5b 2d		      .byte.b	91 , 45
    699  1b8a		       73 5b		      .byte.b	115, 91
    700  1b8c		       5b 17		      .byte.b	91 , 23
    701  1b8e		       79 5b		      .byte.b	121, 91
    702  1b90		       5b 14		      .byte.b	91 , 20
    703  1b92		       73 5b		      .byte.b	115, 91
    704  1b94		       5b 14		      .byte.b	91 , 20
    705  1b96		       79 5b		      .byte.b	121, 91
    706  1b98		       51 28		      .byte.b	81 , 40
    707  1b9a		       66 51		      .byte.b	102, 81
    708  1b9c		       51 14		      .byte.b	81 , 20
    709  1b9e		       6c 51		      .byte.b	108, 81
    710  1ba0		       5b 17		      .byte.b	91 , 23
    711  1ba2		       b6 17		      .byte.b	182, 23
    712  1ba4		       5b 17		      .byte.b	91 , 23
    713  1ba6		       a2 88		      .byte.b	162, 136
    714  1ba8		       5b 2d		      .byte.b	91 , 45
    715  1baa		       99 2d		      .byte.b	153, 45
    716  1bac		       5b 17		      .byte.b	91 , 23
    717  1bae		       88 6c		      .byte.b	136, 108
    718  1bb0		       51 14		      .byte.b	81 , 20
    719  1bb2		       a2 14		      .byte.b	162, 20
    720  1bb4		       51 14		      .byte.b	81 , 20
    721  1bb6		       a2 14		      .byte.b	162, 20
    722  1bb8		       51 28		      .byte.b	81 , 40
    723  1bba		       79 28		      .byte.b	121, 40
    724  1bbc		       51 14		      .byte.b	81 , 20
    725  1bbe		       a2 14		      .byte.b	162, 20
    726  1bc0		       5b 17		      .byte.b	91 , 23
    727  1bc2		       73 5b		      .byte.b	115, 91
    728  1bc4		       5b 17		      .byte.b	91 , 23
    729  1bc6		       79 5b		      .byte.b	121, 91
    730  1bc8		       5b 2d		      .byte.b	91 , 45
    731  1bca		       73 5b		      .byte.b	115, 91
    732  1bcc		       5b 17		      .byte.b	91 , 23
    733  1bce		       79 5b		      .byte.b	121, 91
    734  1bd0		       5b 14		      .byte.b	91 , 20
    735  1bd2		       73 5b		      .byte.b	115, 91
    736  1bd4		       5b 14		      .byte.b	91 , 20
    737  1bd6		       79 5b		      .byte.b	121, 91
    738  1bd8		       51 28		      .byte.b	81 , 40
    739  1bda		       66 51		      .byte.b	102, 81
    740  1bdc		       51 14		      .byte.b	81 , 20
    741  1bde		       6c 51		      .byte.b	108, 81
    742  1be0		       73 5b		      .byte.b	115, 91
    743  1be2		       5b 44		      .byte.b	91 , 68
    744  1be4		       44 39		      .byte.b	68 , 57
    745  1be6		       39 2d		      .byte.b	57 , 45
    746  1be8		       66 51		      .byte.b	102, 81
    747  1bea		       51 3d		      .byte.b	81 , 61
    748  1bec		       3d 33		      .byte.b	61 , 51
    749  1bee		       28 14		      .byte.b	40 , 20
    750  1bf0		       88 73		      .byte.b	136, 115
    751  1bf2		       73 5b		      .byte.b	115, 91
    752  1bf4		       5b 44		      .byte.b	91 , 68
    753  1bf6		       44 39		      .byte.b	68 , 57
    754  1bf8		       66 3d		      .byte.b	102, 61
    755  1bfa		       51 33		      .byte.b	81 , 51
    756  1bfc		       3d 28		      .byte.b	61 , 40
    757  1bfe		       28 14		      .byte.b	40 , 20
    758  1c00
    759  1c00
    760  1c00				   FREE       SET	FREE + BANK_START + ROM_BANK_SIZE/2 - .
    761  1c00
 Free bytes in TITLE_LOGO_BANK: $3
    762  1c00					      ECHO	"Free bytes in TITLE_LOGO_BANK:", FREE
    763  1c00
      0  1c00					      CHECK_HALF_BANK_SIZE	"TITLE_LOGO_BANK"
      1  1c00
      2  1c00
      3  1c00		       04 00	   .TEMP      =	* - BANK_START
 TITLE_LOGO_BANK (1K) SIZE =  $400 , FREE= $0
      4  1c00					      ECHO	"TITLE_LOGO_BANK", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1c00				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1c00				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1c00				  -	      ERR
      8  1c00					      endif
------- FILE ./notBoulderDash.asm
------- FILE BANK_Demo.asm LEVEL 2 PASS 3
      0  1c00					      include	"BANK_Demo.asm"	; upper half of BANK_TITLE_LOGO
      1  1c00							;    NEWBANK DEMO_BANK
      0  1c00					      DEFINE_1K_SEGMENT	DEMO
      1  1c00					      ALIGN	$400
      2  1c00				   SEGMENT_DEMO SET	*
      3  1c00				   BANK_DEMO  SET	_CURRENT_BANK
      3  1c00
      4  1c00		       ff ff ff ff MOVE_NONE  =	~0
      5  1c00		       ff ff ff 7f MOVE_RIGHT =	~%10000000
      6  1c00		       ff ff ff bf MOVE_LEFT  =	~%01000000
      7  1c00		       ff ff ff df MOVE_DOWN  =	~%00100000
      8  1c00		       ff ff ff ef MOVE_UP    =	~%00010000
      9  1c00
      0  1c00					      DEFINE_SUBROUTINE	AdvanceJoystick
      1  1c00		       00 03	   BANK_AdvanceJoystick =	_CURRENT_BANK
      2  1c00					      SUBROUTINE
      3  1c00				   AdvanceJoystick
     11  1c00
     12  1c00		       a9 f0		      lda	#$F0
     13  1c02		       85 95		      sta	BufferedJoystick	; processed joystick OK, so clear any direction bits
     14  1c04		       85 96		      sta	BufferedJoystick+1
     15  1c06
     16  1c06		       24 ac		      bit	demoMode
     17  1c08		       10 0d		      bpl	noAdvance
     18  1c0a		       c6 ac		      dec	moveLen
     19  1c0c		       30 09		      bmi	noAdvance
     20  1c0e		       e6 9e		      inc	moveIdx
     21  1c10		       a4 9e		      ldy	moveIdx
     22  1c12		       b9 34 f4 	      lda	MoveLenTbl-1,y	; 4
     23  1c15		       85 ac		      sta	moveLen	; 3
     24  1c17
     25  1c17		       60	   noAdvance  rts
     26  1c18
     27  1c18							;===============================================================================
     28  1c18							; code starts here
     29  1c18							;===============================================================================
     30  1c18
      0  1c18					      DEFINE_SUBROUTINE	GetJoystickForDemoMode	; = 42/49/49
      1  1c18		       00 03	   BANK_GetJoystickForDemoMode =	_CURRENT_BANK
      2  1c18					      SUBROUTINE
      3  1c18				   GetJoystickForDemoMode
     32  1c18
     33  1c18		       24 ac		      bit	demoMode	; 3
     34  1c1a		       10 18		      bpl	.normalMode	; 2/3= 5/6
     35  1c1c
     36  1c1c							; if in demo mode, the joystick direction is returned by the demo date
     37  1c1c
     38  1c1c		       a5 4c		      lda	INPT4	; 4
     39  1c1e		       10 09		      bpl	.exitDemo	; 2/3= 6/7	 interrupt demo
     40  1c20		       85 97		      sta	BufferedButton
     41  1c22
     42  1c22		       a4 9e		      ldy	moveIdx	; 3
     43  1c24		       b9 73 f4 	      lda	MoveDirTbl-1,y	; 4
     44  1c27		       d0 07		      bne	.setMove	; 3 = 29
     45  1c29
     46  1c29		       a5 c9	   .exitDemo  lda	NextLevelTrigger	; 3
     47  1c2b		       29 7f		      and	#<(~BIT_NEXTLEVEL)	; 2
     48  1c2d		       85 c9		      sta	NextLevelTrigger	; 3
     49  1c2f		       60		      rts		; 6
     50  1c30
     51  1c30		       85 95	   .setMove   sta	BufferedJoystick	; 3
     52  1c32		       85 96		      sta	BufferedJoystick+1	; 3
     53  1c34
     54  1c34		       60	   .normalMode rts		; 6
     55  1c35
     56  1c35							;-------------------------------------------------------------------------------
     57  1c35
     58  1c35				   MoveLenTbl
     59  1c35		       a0		      .byte.b	$80|32	; MOVE_NONE
     60  1c36		       80		      .byte.b	$80|0	; MOVE_UP
     61  1c37		       86		      .byte.b	$80|6	; MOVE_RIGHT
     62  1c38		       81		      .byte.b	$80|1	; MOVE_DOWN
     63  1c39		       88		      .byte.b	$80|8	; MOVE_RIGHT  ; D1    148
     64  1c3a		       85		      .byte.b	$80|5	; MOVE_NONE
     65  1c3b		       81		      .byte.b	$80|1	; MOVE_DOWN
     66  1c3c		       83		      .byte.b	$80|3	; MOVE_RIGHT
     67  1c3d		       82		      .byte.b	$80|2	; MOVE_UP
     68  1c3e		       80		      .byte.b	$80|0	; MOVE_LEFT   ; D2    144
     69  1c3f		       85		      .byte.b	$80|5	; MOVE_NONE
     70  1c40		       80		      .byte.b	$80|0	; MOVE_UP
     71  1c41		       8a		      .byte.b	$80|10	; MOVE_RIGHT
     72  1c42		       80		      .byte.b	$80|0	; MOVE_DOWN
     73  1c43		       81		      .byte.b	$80|1	; MOVE_RIGHT
     74  1c44		       84		      .byte.b	$80|5-1	; MOVE_NONE   ;       141
     75  1c45		       85		      .byte.b	$80|5	; MOVE_DOWN
     76  1c46		       81		      .byte.b	$80|0+1	; MOVE_RIGHT
     77  1c47		       83		      .byte.b	$80|3	; MOVE_DOWN
     78  1c48		       82		      .byte.b	$80|2	;+1 ; MOVE_LEFT   ; D3    139+1     fixes broken demo!
     79  1c49		       84		      .byte.b	$80|4	; MOVE_NONE
     80  1c4a		       80		      .byte.b	$80|0	; MOVE_DOWN
     81  1c4b		       80		      .byte.b	$80|0	; MOVE_LEFT   ; D4
     82  1c4c		       83		      .byte.b	$80|3	; MOVE_RIGHT
     83  1c4d		       83		      .byte.b	$80|2+1	; MOVE_LEFT   ; D5
     84  1c4e		       84		      .byte.b	$80|4	; MOVE_NONE
     85  1c4f		       83		      .byte.b	$80|3	; MOVE_UP
     86  1c50		       84		      .byte.b	$80|4	; MOVE_LEFT   ; D6
     87  1c51		       80		      .byte.b	$80|0	; MOVE_UP
     88  1c52		       84		      .byte.b	$80|4	; MOVE_NONE
     89  1c53		       84		      .byte.b	$80|4	; MOVE_LEFT   ; D7+8
     90  1c54		       83		      .byte.b	$80|3	; MOVE_DOWN   ; D9
     91  1c55		       82		      .byte.b	$80|2	; MOVE_LEFT   ; D10   133+1
     92  1c56		       84		      .byte.b	$80|4	; MOVE_NONE
     93  1c57		       82		      .byte.b	$80|2	; MOVE_UP
     94  1c58		       87		      .byte.b	$80|7	; MOVE_LEFT
     95  1c59		       80		      .byte.b	$80|0	; MOVE_UP
     96  1c5a		       85		      .byte.b	$80|4+1	; MOVE_LEFT   ; D11
     97  1c5b		       80		      .byte.b	$80|0	; MOVE_DOWN
     98  1c5c		       86		      .byte.b	$80|5+1	; MOVE_LEFT
     99  1c5d		       83		      .byte.b	$80|3	; MOVE_DOWN
    100  1c5e		       80		      .byte.b	$80|0	; MOVE_RIGHT  ; D12   130
    101  1c5f		       84		      .byte.b	$80|4	; MOVE_NONE
    102  1c60		       81		      .byte.b	$80|1	; MOVE_DOWN
    103  1c61		       83		      .byte.b	$80|3	; MOVE_RIGHT
    104  1c62		       84		      .byte.b	$80|4	; MOVE_DOWN
    105  1c63		       83		      .byte.b	$80|3	; MOVE_LEFT   ; D13   127
    106  1c64		       82		      .byte.b	$80|1+1	; MOVE_UP
    107  1c65		       81		      .byte.b	$80|1	; MOVE_RIGHT
    108  1c66		       82		      .byte.b	$80|2	; MOVE_UP
    109  1c67		       8f		      .byte.b	$80|15	; MOVE_RIGHT  ; D14   125
    110  1c68		       84		      .byte.b	$80|4	; MOVE_NONE
    111  1c69		       80		      .byte.b	$80|0	; MOVE_DOWN
    112  1c6a		       84		      .byte.b	$80|4	; MOVE_RIGHT
    113  1c6b		       80		      .byte.b	$80|0	; MOVE_DOWN
    114  1c6c		       83		      .byte.b	$80|3	; MOVE_RIGHT
    115  1c6d		       81		      .byte.b	$80|1	; MOVE_DOWN   ; D15/6 122
    116  1c6e		       84		      .byte.b	$80|4	; MOVE_NONE
    117  1c6f		       84		      .byte.b	$80|4	; MOVE_RIGHT
    118  1c70		       84		      .byte.b	$80|3+1	; MOVE_UP     ;       121
    119  1c71		       84		      .byte.b	$80|4	; MOVE_RIGHT
    120  1c72		       84		      .byte.b	$80|4	; MOVE_NONE   ;       119
    121  1c73		       ff		      .byte.b	$80|127	; MOVE_DOWN   ; 329 points
    122  1c74
    123  1c74				   MoveDirTbl
    124  1c74		       ff		      .byte.b	MOVE_NONE
    125  1c75		       ef		      .byte.b	MOVE_UP
    126  1c76		       7f		      .byte.b	MOVE_RIGHT
    127  1c77		       df		      .byte.b	MOVE_DOWN
    128  1c78		       7f		      .byte.b	MOVE_RIGHT	; D1	 148
    129  1c79		       ff		      .byte.b	MOVE_NONE
    130  1c7a		       df		      .byte.b	MOVE_DOWN
    131  1c7b		       7f		      .byte.b	MOVE_RIGHT
    132  1c7c		       ef		      .byte.b	MOVE_UP
    133  1c7d		       bf		      .byte.b	MOVE_LEFT	; D2	 144
    134  1c7e		       ff		      .byte.b	MOVE_NONE
    135  1c7f		       ef		      .byte.b	MOVE_UP
    136  1c80		       7f		      .byte.b	MOVE_RIGHT
    137  1c81		       df		      .byte.b	MOVE_DOWN
    138  1c82		       7f		      .byte.b	MOVE_RIGHT
    139  1c83		       ff		      .byte.b	MOVE_NONE	;	 141
    140  1c84		       df		      .byte.b	MOVE_DOWN
    141  1c85		       7f		      .byte.b	MOVE_RIGHT
    142  1c86		       df		      .byte.b	MOVE_DOWN
    143  1c87		       bf		      .byte.b	MOVE_LEFT	; D3	 139
    144  1c88		       ff		      .byte.b	MOVE_NONE
    145  1c89		       df		      .byte.b	MOVE_DOWN
    146  1c8a		       bf		      .byte.b	MOVE_LEFT	; D4
    147  1c8b		       7f		      .byte.b	MOVE_RIGHT
    148  1c8c		       bf		      .byte.b	MOVE_LEFT	; D5
    149  1c8d		       ff		      .byte.b	MOVE_NONE
    150  1c8e		       ef		      .byte.b	MOVE_UP
    151  1c8f		       bf		      .byte.b	MOVE_LEFT	; D6
    152  1c90		       ef		      .byte.b	MOVE_UP
    153  1c91		       ff		      .byte.b	MOVE_NONE
    154  1c92		       bf		      .byte.b	MOVE_LEFT	; D7/8
    155  1c93		       df		      .byte.b	MOVE_DOWN	; D9
    156  1c94		       bf		      .byte.b	MOVE_LEFT	; D10	 134
    157  1c95		       ff		      .byte.b	MOVE_NONE
    158  1c96		       ef		      .byte.b	MOVE_UP
    159  1c97		       bf		      .byte.b	MOVE_LEFT
    160  1c98		       ef		      .byte.b	MOVE_UP
    161  1c99		       bf		      .byte.b	MOVE_LEFT	; D11
    162  1c9a		       df		      .byte.b	MOVE_DOWN
    163  1c9b		       bf		      .byte.b	MOVE_LEFT
    164  1c9c		       df		      .byte.b	MOVE_DOWN
    165  1c9d		       7f		      .byte.b	MOVE_RIGHT	; D12	 129
    166  1c9e		       ff		      .byte.b	MOVE_NONE
    167  1c9f		       df		      .byte.b	MOVE_DOWN
    168  1ca0		       7f		      .byte.b	MOVE_RIGHT
    169  1ca1		       df		      .byte.b	MOVE_DOWN
    170  1ca2		       bf		      .byte.b	MOVE_LEFT	; D13	 127
    171  1ca3		       ef		      .byte.b	MOVE_UP
    172  1ca4		       7f		      .byte.b	MOVE_RIGHT
    173  1ca5		       ef		      .byte.b	MOVE_UP
    174  1ca6		       7f		      .byte.b	MOVE_RIGHT	; D14	 125
    175  1ca7		       ff		      .byte.b	MOVE_NONE
    176  1ca8		       df		      .byte.b	MOVE_DOWN
    177  1ca9		       7f		      .byte.b	MOVE_RIGHT
    178  1caa		       df		      .byte.b	MOVE_DOWN
    179  1cab		       7f		      .byte.b	MOVE_RIGHT
    180  1cac		       df		      .byte.b	MOVE_DOWN	; D15/6 122
    181  1cad		       ff		      .byte.b	MOVE_NONE
    182  1cae		       7f		      .byte.b	MOVE_RIGHT
    183  1caf		       ef		      .byte.b	MOVE_UP	;	 121
    184  1cb0		       7f		      .byte.b	MOVE_RIGHT
    185  1cb1		       ff		      .byte.b	MOVE_NONE	;	 119
    186  1cb2		       df		      .byte.b	MOVE_DOWN	; 329 points
    187  1cb3
    188  1cb3
    189  1cb3							;------------------------------------------------------------------------------
    190  1cb3					      MAC	checksounds
    191  1cb3					      lda	soundIdxLst+1
    192  1cb3					      cmp	#OFSS_MAGIC_WALL+1	; Amoeba or Magic Wall?
    193  1cb3					      bcs	.waitForIt
    194  1cb3					      STOP_CHANNEL	1	; yes, stop repeating sounds
    195  1cb3					      lda	soundIdxLst
    196  1cb3				   .waitForIt
    197  1cb3					      ENDM
    198  1cb3							;------------------------------------------------------------------------------
    199  1cb3
      0  1cb3					      DEFINE_SUBROUTINE	NextCave
      1  1cb3		       00 03	   BANK_NextCave =	_CURRENT_BANK
      2  1cb3					      SUBROUTINE
      3  1cb3				   NextCave
    201  1cb3
      0  1cb3					      CHECKSOUNDS		; wait until all sounds are over
      1  1cb3		       a5 d6		      lda	soundIdxLst+1
      2  1cb5		       c9 2d		      cmp	#OFSS_MAGIC_WALL+1
      3  1cb7		       b0 08		      bcs	.waitForIt
      0  1cb9					      STOP_CHANNEL	1
      1  1cb9
      2  1cb9		       a9 00		      lda	#0
      3  1cbb		       85 d6		      sta	soundIdxLst+1
      4  1cbd		       85 5a		      sta	AUDV0+1
      5  1cbf		       a5 d5		      lda	soundIdxLst
      6  1cc1				   .waitForIt
    203  1cc1		       d0 1b		      bne	.skipNextLevel
    204  1cc3
    205  1cc3							; Now do the actual switching
    206  1cc3
    207  1cc3		       a5 c9		      lda	NextLevelTrigger
    208  1cc5		       29 7f		      and	#<(~BIT_NEXTLEVEL)
    209  1cc7		       85 c9		      sta	NextLevelTrigger
    210  1cc9
    211  1cc9							; Next level is due. Point to the next cave, but if we're at the end of playable caves,
    212  1cc9							; then increment the level number. This is completely circular, so we eventually wrap
    213  1cc9							; the cave back to 0 and start afresh. The level maxes out at P5 then remains at the top.
    214  1cc9
    215  1cc9		       a5 b0	   NextCaveAlong lda	cave
    216  1ccb		       18		      clc
    217  1ccc		       69 05		      adc	#CAVE_DATA_SIZE
    218  1cce		       c9 64		      cmp	#MAX_CAVENUM
    219  1cd0		       90 0a		      bcc	.caveOK
    220  1cd2
    221  1cd2		       a6 b1		      ldx	level
    222  1cd4		       e0 04		      cpx	#NUM_LEVELS-1
    223  1cd6		       b0 02		      bcs	.skipIncLevel
    224  1cd8		       e6 b1		      inc	level
    225  1cda				   .skipIncLevel
    226  1cda
    227  1cda		       a9 00		      lda	#0
    228  1cdc		       85 b0	   .caveOK    sta	cave
    229  1cde		       60	   .skipNextLevel rts
    230  1cdf
    231  1cdf
      0  1cdf					      CHECK_BANK_SIZE	"DEMO_BANK"
      1  1cdf		       04 df	   .TEMP      =	* - BANK_START
 DEMO_BANK (2K) SIZE =  $4df , FREE= $321
      2  1cdf					      ECHO	"DEMO_BANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1cdf				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1cdf				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1cdf				  -	      ERR
      6  1cdf					      endif
------- FILE ./notBoulderDash.asm
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 3
      0  1cdf					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1  1cdf							;------------------------------------------------------------------------------
      2  1cdf							;##############################################################################
      3  1cdf							;------------------------------------------------------------------------------
      0  1cdf					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  268c ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
      5  2000
      6  2000							; This is essentially a ROM mirror of a RAM bank.
      7  2000							; The contents of this bank are copied to each of the ROW banks on startup, and
      8  2000							; this gives a 1:1 correspondence between the data/addresses defined here, and
      9  2000							; the addresses in the switched-in RAM bank.
     10  2000
     11  2000							; Note: Bankswitching code between any of these banks guarantees the code can
     12  2000							; continue to run -- because, of course, the same code is still at the same
     13  2000							; memory address.
     14  2000
     15  2000		       00 01	   _PROFILE_DRAW =	YES
     16  2000
     17  2000					      MAC	profile_draw
     18  2000					      IF	_PROFILE_DRAW
     19  2000					      inc	Profile{1}
     20  2000					      bne	$skip
     21  2000					      inc	Profile{1}+1
     22  2000				   $skip
     23  2000					      ENDIF
     24  2000					      ENDM		; {label}
     25  2000
     26  2000
      0  2000					      DEFINE_SUBROUTINE	DrawTheScreen
      1  2000		       00 04	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  2000					      SUBROUTINE
      3  2000				   DrawTheScreen
     28  2000
     29  2000							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     30  2000							; A refactor of the kernel to improve the timing.
     31  2000							; Experimental refactor to remove the blank line...
     32  2000
     33  2000							; adjust here so that the first line of the kernel starts exactly at cycle 67
     34  2000							; (since TJ said it could start up to 5 cycles earlier than #67).
     35  2000
     36  2000							; TODO: remove GRP1 and COLUP1 access (or use higher resolution Rockford)
     37  2000							;	     @57
      0  2000					      SLEEP	3	; 3
      1  2000				   .CYCLES    SET	3
      2  2000
      3  2000				  -	      IF	.CYCLES < 2
      4  2000				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2000				  -	      ERR
      6  2000					      ENDIF
      7  2000
      8  2000					      IF	.CYCLES & 1
      9  2000					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2000		       04 00		      nop	0
     11  2002				  -	      ELSE
     12  2002				  -	      bit	VSYNC
     13  2002					      ENDIF
     14  2002				   .CYCLES    SET	.CYCLES - 3
     15  2002					      ENDIF
     16  2002
     17  2002				  -	      REPEAT	.CYCLES / 2
     18  2002				  -	      nop
     19  2002					      REPEND
     39  2002
     40  2002		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     41  2004		       10 3e		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     42  2006
     43  2006				   Proc2		; 5
      0  2006					      SLEEP	3	; 3	     @64
      1  2006				   .CYCLES    SET	3
      2  2006
      3  2006				  -	      IF	.CYCLES < 2
      4  2006				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2006				  -	      ERR
      6  2006					      ENDIF
      7  2006
      8  2006					      IF	.CYCLES & 1
      9  2006					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2006		       04 00		      nop	0
     11  2008				  -	      ELSE
     12  2008				  -	      bit	VSYNC
     13  2008					      ENDIF
     14  2008				   .CYCLES    SET	.CYCLES - 3
     15  2008					      ENDIF
     16  2008
     17  2008				  -	      REPEAT	.CYCLES / 2
     18  2008				  -	      nop
     19  2008					      REPEND
     45  2008		       10 3c		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     46  200a
     47  200a				   ScanRED		;	     @60
     48  200a		       b9 3a f3    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     49  200d		       85 4d		      sta	PF0	; 3	     @67
     50  200f		       b9 3e f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     51  2012		       85 4e		      sta	PF1	; 3 = 14    @74
     52  2014				   SELFMOD_PLAYERCOL_RED
     53  2014		       b9 af f0 	      lda	SpriteColourRED,y	; 4
     54  2017		       85 46		      sta	COLUP0	; 3	     @05
     55  2019		       85 47		      sta	COLUP1	; 3 = 10    @08
     56  201b
     57  201b							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     58  201b
     59  201b				   SELFMOD_RED
     60  201b		       a9 00		      lda	#0	; 2
     61  201d		       85 48		      sta	COLUPF	; 3 =	5    @13
     62  201f
     63  201f				   SELFMOD_PLAYER0_RED
     64  201f		       b9 3a f3 	      lda	ShapePlayerRED,y	; 4
     65  2022		       85 5b		      sta	GRP0	; 3 =	7    @20
     66  2024
     67  2024		       b9 53 f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
     68  2027		       85 4f		      sta	PF2	; 3 =	7    @27
     69  2029
     70  2029		       b9 3a f3    SM_PF0_REDr lda	CHARACTERSHAPE_BLANK,y	; 4
     71  202c		       85 4d		      sta	PF0	; 3	     @34
     72  202e		       b9 68 f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
     73  2031		       85 4e		      sta	PF1	; 3	     @41
     74  2033		       b9 7d f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
     75  2036		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
     76  2038
     77  2038				   SELFMOD_PLAYER1_RED
     78  2038		       b9 3a f3 	      lda	ShapePlayerRED,y	; 4
     79  203b		       8d 5c 00 	      sta.w	GRP1	; 4 =	8    @56   VDELed!
     80  203e
     81  203e		       88		      dey		; 2
     82  203f		       10 c5		      bpl	Proc2	; 2(3)      --> 61 if taken
     83  2041
     84  2041		       e8	   SELFMOD_X  inx		; 2
     85  2042		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
     86  2044							;EXIT_RETURN_HERE
     87  2044				   NextALineStart
     88  2044		       a0 06		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
     89  2046				   ScanBLUEBD		;	     @67     let's start as late as possible
     90  2046
     91  2046							;------------------------------------------------------------------------------
     92  2046
     93  2046		       b9 3a f3    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
     94  2049		       85 4d		      sta	PF0	; 3 =	7    @74
     95  204b				   SELFMOD_PLAYERCOL_BLUE
     96  204b		       b9 bd f0 	      lda	SpriteColourBLUE,y	; 4
     97  204e		       85 47		      sta	COLUP1	; 3	     @05
     98  2050		       85 46		      sta	COLUP0	; 3 = 10    @08
     99  2052
    100  2052				   SELFMOD_BLUE
    101  2052		       a9 00		      lda	#0	; 2
    102  2054		       85 48		      sta	COLUPF	; 3 =	5    @13
    103  2056
    104  2056				   SELFMOD_PLAYER0_BLUE
    105  2056		       b9 3a f3 	      lda	ShapePlayerBLUE,y	; 4
    106  2059		       85 5b		      sta	GRP0	; 3 =	7    @20
    107  205b
    108  205b		       b9 4c f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    109  205e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    110  2060		       b9 61 f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    111  2063		       85 4f		      sta	PF2	; 3 = 14    @34
    112  2065
    113  2065		       b9 3a f3    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    114  2068		       85 4d		      sta	PF0	; 3	     @41
    115  206a		       b9 76 f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    116  206d		       85 4e		      sta	PF1	; 3	     @48
    117  206f		       b9 8b f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    118  2072		       85 4f		      sta	PF2	; 3 = 21    @55
    119  2074
    120  2074				   SELFMOD_PLAYER1_BLUE
    121  2074		       b9 3a f3 	      lda	ShapePlayerBLUE,y	; 4
    122  2077		       85 5c		      sta	GRP1	; 3 =	7    VDELed! @62
    123  2079
    124  2079							;------------------------------------------------------------------------------
    125  2079
    126  2079				   ScanGREEN		;	     @62
    127  2079		       b9 3a f3    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    128  207c		       85 4d		      sta	PF0	; 3 =	7    @69
    129  207e				   SELFMOD_PLAYERCOL_GREEN
    130  207e		       b9 b6 f0 	      lda	SpriteColourGREEN,y	; 4
    131  2081		       85 47		      sta	COLUP1	; 3	     @00
    132  2083		       85 46		      sta	COLUP0	; 3 = 10    @03
    133  2085
    134  2085				   SELFMOD_GREEN
    135  2085		       a9 00		      lda	#0	; 2
    136  2087		       85 48		      sta	COLUPF	; 3 =	5    @08
    137  2089
    138  2089				   SELFMOD_PLAYER0_GREEN
    139  2089		       b9 3a f3 	      lda	ShapePlayerGREEN,y	; 4
    140  208c		       85 5b		      sta	GRP0	; 3 =	7    @15
    141  208e
    142  208e		       b9 45 f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    143  2091		       85 4e		      sta	PF1	; 3	     @22
    144  2093		       b9 5a f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    145  2096		       85 4f		      sta	PF2	; 3 = 14    @29
    146  2098
    147  2098		       b9 3a f3    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    148  209b		       85 4d		      sta	PF0	; 3	     @36
    149  209d		       b9 6f f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    150  20a0		       85 4e		      sta	PF1	; 3	     @43
    151  20a2		       b9 84 f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    152  20a5		       85 4f		      sta	PF2	; 3 = 21    @50
    153  20a7
    154  20a7				   SELFMOD_PLAYER1_GREEN
    155  20a7		       b9 3a f3 	      lda	ShapePlayerGREEN,y	; 4
    156  20aa		       85 5c		      sta	GRP1	; 3 =	7    @57     VDELed!
    157  20ac
    158  20ac		       4c 0a f0 	      jmp	ScanRED	; 3	     @60
    159  20af
    160  20af							;------------------------------------------------------------------------------
    161  20af
    162  20af							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    163  20af
    164  20af		       f3 3a	   ShapePlayer =	PLAYER_BLANK
    165  20af		       f3 3a	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    166  20af		       f3 3a	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    167  20af		       f3 3a	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    168  20af
    169  20af		       f3 3a	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    170  20af		       f3 3a	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    171  20af		       f3 3a	   CHARACTERSHAPE_EXITDOOR2 =	PLAYER_BLANK
    172  20af		       f2 a7	   CHARACTERSHAPE_EXPLOSION =	CHARACTERSHAPE_EXPLOSION2	;PLAYER_BLANK
    173  20af		       f2 a7	   CHARACTERSHAPE_EXPLOSION_MIRRORED =	CHARACTERSHAPE_EXPLOSION2	;PLAYER_BLANK		     ; TODO: change
    174  20af
------- FILE Rockford_Color.asm LEVEL 3 PASS 3
      0  20af					      include	"Rockford_Color.asm"	; 1 * LINES_PER_CHAR bytes
      0  20af					      OPTIONAL_PAGEBREAK	"SpriteColour", LINES_PER_CHAR*2
     10  20af					      LIST	ON
      2  20af
      3  20af		       00 10	   YELLOW_NTSC =	$10	; hair
      4  20af		       00 30	   ORANGE_NTSC =	$30	; skin
      5  20af		       00 40	   RED_NTSC   =	$40	; shirt
      6  20af
      7  20af		       00 20	   YELLOW_PAL =	$20
      8  20af		       00 40	   ORANGE_PAL =	$40
      9  20af		       00 60	   RED_PAL    =	$60
     10  20af
     11  20af				   SpriteColour
     12  20af							; NTSC
     13  20af							;SpriteColourRED
     14  20af							;    .byte RED_NTSC|$6       ; 0 feet
     15  20af							;    .byte WHITE	      ; 3
     16  20af							;    .byte RED_NTSC|$4       ; 6
     17  20af							;    .byte RED_NTSC|$4       ; 9
     18  20af							;    .byte ORANGE_NTSC|$6    ;12
     19  20af							;    .byte ORANGE_NTSC|$8    ;15
     20  20af							;    .byte WHITE	      ;18
     21  20af							;SpriteColourGREEN
     22  20af							;    .byte RED_NTSC|$4       ; 1
     23  20af							;    .byte WHITE	      ; 4
     24  20af							;    .byte WHITE	      ; 7
     25  20af							;    .byte WHITE	      ;10
     26  20af							;    .byte ORANGE_NTSC|$8    ;13
     27  20af							;    .byte ORANGE_NTSC|$6    ;16
     28  20af							;    .byte WHITE	      ;19
     29  20af							;SpriteColourBLUE
     30  20af							;    .byte WHITE	      ; 2
     31  20af							;    .byte RED_NTSC|$4       ; 5
     32  20af							;    .byte RED_NTSC|$4       ; 8
     33  20af							;    .byte ORANGE_NTSC|$4    ;11 neck
     34  20af							;    .byte ORANGE_NTSC|$a    ;14
     35  20af							;    .byte YELLOW_NTSC|$c    ;17 hair
     36  20af							;    .byte WHITE	      ;20
     37  20af
     38  20af				   SpriteColourRED
     39  20af		       46		      .byte.b	RED_NTSC|$6	; 0 feet
     40  20b0		       0e		      .byte.b	WHITE	; 3
     41  20b1		       44		      .byte.b	RED_NTSC|$4	; 6
     42  20b2		       44		      .byte.b	RED_NTSC|$4	; 9
     43  20b3		       0e		      .byte.b	WHITE	;12 neck
     44  20b4		       38		      .byte.b	ORANGE_NTSC|$8	;15
     45  20b5		       36		      .byte.b	ORANGE_NTSC|$6	;18
     46  20b6				   SpriteColourGREEN
     47  20b6		       44		      .byte.b	RED_NTSC|$4	; 1
     48  20b7		       0e		      .byte.b	WHITE	; 4
     49  20b8		       44		      .byte.b	RED_NTSC|$4	; 7
     50  20b9		       44		      .byte.b	RED_NTSC|$4	;10
     51  20ba		       34		      .byte.b	ORANGE_NTSC|$4	;13 neck
     52  20bb		       3a		      .byte.b	ORANGE_NTSC|$a	;16
     53  20bc		       1c		      .byte.b	YELLOW_NTSC|$c	;19 hair
     54  20bd				   SpriteColourBLUE
     55  20bd		       0e		      .byte.b	WHITE	; 2
     56  20be		       44		      .byte.b	RED_NTSC|$4	; 5
     57  20bf		       0e		      .byte.b	WHITE	; 8
     58  20c0		       44		      .byte.b	RED_NTSC|$4	;11
     59  20c1		       36		      .byte.b	ORANGE_NTSC|$6	;14
     60  20c2		       38		      .byte.b	ORANGE_NTSC|$8	;17
     61  20c3		       0e		      .byte.b	WHITE	;20 unused
     62  20c4
     63  20c4							; PAL
     64  20c4							;    .byte RED_PAL|$6	      ; 0 feet
     65  20c4							;    .byte WHITE	      ; 3
     66  20c4							;    .byte RED_PAL|$4	      ; 6
     67  20c4							;    .byte RED_PAL|$4	      ; 9
     68  20c4							;    .byte ORANGE_PAL|$4     ;12
     69  20c4							;    .byte ORANGE_PAL|$6     ;15
     70  20c4							;    .byte WHITE	      ;18
     71  20c4							;
     72  20c4							;    .byte RED_PAL|$4	      ; 1
     73  20c4							;    .byte WHITE	      ; 4
     74  20c4							;    .byte WHITE	      ; 7
     75  20c4							;    .byte WHITE	      ;10
     76  20c4							;    .byte ORANGE_PAL|$6     ;13
     77  20c4							;    .byte ORANGE_PAL|$4     ;16
     78  20c4							;    .byte WHITE	      ;19
     79  20c4							;
     80  20c4							;    .byte WHITE	      ; 2
     81  20c4							;    .byte RED_PAL|$4	      ; 5
     82  20c4							;    .byte RED_PAL|$4	      ; 8
     83  20c4							;    .byte ORANGE_PAL|$2     ;11 neck
     84  20c4							;    .byte ORANGE_PAL|$8     ;14
     85  20c4							;    .byte YELLOW_PAL|$c     ;17 hair
     86  20c4							;    .byte WHITE	      ;20
     87  20c4
     88  20c4		       66		      .byte.b	RED_PAL|$6	; 0 feet
     89  20c5		       0e		      .byte.b	WHITE	; 3
     90  20c6		       64		      .byte.b	RED_PAL|$4	; 6
     91  20c7		       64		      .byte.b	RED_PAL|$4	; 9
     92  20c8		       0e		      .byte.b	WHITE	;12 neck
     93  20c9		       46		      .byte.b	ORANGE_PAL|$6	;15
     94  20ca		       44		      .byte.b	ORANGE_PAL|$4	;18
     95  20cb
     96  20cb		       64		      .byte.b	RED_PAL|$4	; 1
     97  20cc		       0e		      .byte.b	WHITE	; 4
     98  20cd		       64		      .byte.b	RED_PAL|$4	; 7
     99  20ce		       64		      .byte.b	RED_PAL|$4	;10
    100  20cf		       42		      .byte.b	ORANGE_PAL|$2	;13 neck
    101  20d0		       48		      .byte.b	ORANGE_PAL|$8	;16
    102  20d1		       2c		      .byte.b	YELLOW_PAL|$c	;19 hair
    103  20d2
    104  20d2		       0e		      .byte.b	WHITE	; 2
    105  20d3		       64		      .byte.b	RED_PAL|$4	; 5
    106  20d4		       0e		      .byte.b	WHITE	; 8
    107  20d5		       64		      .byte.b	RED_PAL|$4	;11
    108  20d6		       44		      .byte.b	ORANGE_PAL|$4	;14
    109  20d7		       46		      .byte.b	ORANGE_PAL|$6	;17
    110  20d8		       0e		      .byte.b	WHITE	;20 unused
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    176  20d9
    177  20d9
    178  20d9							;------------------------------------------------------------------------------
    179  20d9
    180  20d9							;*** Ideas: ***
    181  20d9							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    182  20d9							;   13.5% on average), also unrolling would be more effective than now
    183  20d9							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    184  20d9							;   see EXPERIMENTAL)
    185  20d9							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    186  20d9							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    187  20d9							;   bidirectional linked list instead)
    188  20d9							; - calculate mirrored gfx data into RAM (saves ROM)
    189  20d9
    190  20d9							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    191  20d9							;currently:
    192  20d9							; 72%*539 (!unrolled)
    193  20d9							;+ 8%*304 (unrolled)
    194  20d9							;+20%*269 (unrolled)
    195  20d9							;--------
    196  20d9							;=   ~466.2 cycles on average
    197  20d9
    198  20d9							;alternative #1:
    199  20d9							; 72%*522 (unrolled)
    200  20d9							;+ 8%*352 (!unrolled)
    201  20d9							;+20%*307 (!unrolled)
    202  20d9							;--------
    203  20d9							;=   ~465.4 cycles on average
    204  20d9
    205  20d9
    206  20d9		       00 01	   MIRROR     =	1
    207  20d9		       00 80	   DIRECT     =	$80
    208  20d9
    209  20d9							;------------------------------------------------------------------------------
    210  20d9							; Here we don't draw into a buffer, but directly patch the kernel
    211  20d9							; VERY fast!
    212  20d9							;
    213  20d9							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    214  20d9							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    215  20d9
    216  20d9				   PF0Draw		; 25 cycles until here
    217  20d9
    218  20d9		       ae 84 02 	      ldx	INTIM	; 4
    219  20dc		       e0 05		      cpx	#SEGTIME_SCD_PF0	; 2
    220  20de		       90 72		      bcc	ExitDraw	; 2(3)=8
      0  20e0					      STRESS_TIME	SEGTIME_SCD_PF0	; ok!
      1  20e0				  -	      IF	TEST_SEGTIME_SCD_PF0 = 1
      2  20e0				  -
      3  20e0				  -
      4  20e0				  -
      5  20e0				  -
      6  20e0				  -
      7  20e0				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  20e0				  -	      bne	. - 7
      9  20e0					      ENDIF
    222  20e0
    223  20e0		       29 7f		      and	#<(~DIRECT)	; 2
    224  20e2		       aa		      tax		; 2 =	4
    225  20e3
    226  20e3		       98		      tya		; 2
    227  20e4		       0a		      asl		; 2	     no mirrored chars in PF0
    228  20e5		       a8		      tay		; 2 =	6
    229  20e6							;		  clc				  ; 2
    230  20e6
    231  20e6		       b9 07 fe 	      lda	CharacterDataVecHI,y	; 4
    232  20e9		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    233  20ec		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    234  20ef		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19
    235  20f2
    236  20f2		       b9 d1 fd 	      lda	CharacterDataVecLO,y	; 4
    237  20f5		       9d 0b f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    238  20f8		       69 06		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    239  20fa		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    240  20fd		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    241  20ff		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23
    242  2102
    243  2102		       4c 77 fc 	      jmp	DrawAnother	; 3 =	3
    244  2105
    245  2105							; Timing for PF0Draw
    246  2105							; 7+63 = 70
    247  2105							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    248  2105
    249  2105
    250  2105							;------------------------------------------------------------------------------
    251  2105							; Direct draw draws to PF0, which only has one active member of the character
    252  2105							; pair -- so it can be a direct copy.	Quicker still!
    253  2105
    254  2105				   DirectDraw		; 37 cycles until here
    255  2105
    256  2105							;ldy #16
    257  2105		       ad 84 02 	      lda	INTIM	; 4
    258  2108		       c9 08		      cmp	#SEGTIME_SCD_DIRECT	; 2
    259  210a		       90 46		      bcc	ExitDraw	; 2(3)=8
      0  210c					      STRESS_TIME	SEGTIME_SCD_DIRECT	; ok!
      1  210c				  -	      IF	TEST_SEGTIME_SCD_DIRECT = 1
      2  210c				  -
      3  210c				  -
      4  210c				  -
      5  210c				  -
      6  210c				  -
      7  210c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  210c				  -	      bne	. - 7
      9  210c					      ENDIF
    261  210c
    262  210c							; TIME REQUIRED FROM HERE (9/JAN)
    263  210c							; 16 + 20 + 20 + 2 + ( 7 * 32 ) - 1  + (42 SUFFIX)
    264  210c							; = 323 --> /64 = 5.04 USE 7
    265  210c
    266  210c		       b9 07 fe 	      lda	CharacterDataVecHI,y	; 4
    267  210f		       8d 3c f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    268  2112		       8d 42 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    269  2115		       8d 48 f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    270  2118
    271  2118		       b9 d1 fd 	      lda	CharacterDataVecLO,y	; 4
    272  211b		       8d 3b f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    273  211e		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    274  2120		       8d 41 f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    275  2123		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    276  2125		       8d 47 f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    277  2128
    278  2128		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    279  212b		       8d 3e f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    280  212e		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    281  2130		       8d 44 f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    282  2133		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    283  2135		       8d 4a f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    284  2138
    285  2138		       a0 06		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    286  213a				   TSFill3
    287  213a		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    288  213d		       99 3e f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    289  2140		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    290  2143		       99 3e f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    291  2146		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    292  2149		       99 3e f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    293  214c
    294  214c		       88		      dey		; 2
      0  214d					      CHECKPAGE_BPL	TSFill3	; 3(2)=5
      8  214d					      LIST	ON
      9  214d		       10 eb		      bpl	TSFill3
    296  214f
    297  214f		       4c 77 fc 	      jmp	DrawAnother	; 3
    298  2152
    299  2152							; Timing for DirectDraw
    300  2152							; 17+8+16+20+20+2+(32*7)-1+3 = 309 (was: 302 + 3)
    301  2152							; total: 37+309+6 = 352 => 352/64 + 1.4 = 6.90 = 7 (= SEGTIME_SLOWDRAW-5)
    302  2152
    303  2152				   ExitDraw
    304  2152		       60		      rts
    305  2153
    306  2153							;------------------------------------------------------------------------------
      0  2153					      DEFINE_SUBROUTINE	StealPart3	; 18 CYCLES HERE
      1  2153		       00 04	   BANK_StealPart3 =	_CURRENT_BANK
      2  2153					      SUBROUTINE
      3  2153				   StealPart3
    308  2153
    309  2153		       bd ee f1 	      lda	MOD10,x	; 4
    310  2156		       30 81		      bmi	PF0Draw	; 2/3
    311  2158		       4a		      lsr		; 2
    312  2159		       aa		      tax		; 2
    313  215a		       98		      tya		; 2
    314  215b		       2a		      rol		; 2	     allows for mirrored char = * | 1
    315  215c		       a8		      tay		; 2
    316  215d		       b0 a6		      bcs	DirectDraw	; 2(3)      when draw stack was built, bit 7 flags direct-drawn character
    317  215f							;	     => +19 starting DirectDraw BUT WHO CARES AS IT'S ONLY AFTER THAT COUNTS
    318  215f
    319  215f		       b9 07 fe 	      lda	CharacterDataVecHI,y	; 4
    320  2162		       10 38		      bpl	QuickDraw	; 2(3)=42   special-case blank characters for extra speed
    321  2164							;	     => 42 starting QuickDraw
    322  2164		       8d 8d f5 	      sta	SMEOR1+RAM_WRITE+2	; 4 =	4
    323  2167
    324  2167		       ad 84 02 	      lda	INTIM	; 4
    325  216a		       c9 0c		      cmp	#SEGTIME_SCD_SLOW	; 2
    326  216c		       90 e4		      bcc	ExitDraw	; 2(3)=8
      0  216e					      STRESS_TIME	SEGTIME_SCD_SLOW	; ok!
      1  216e				  -	      IF	TEST_SEGTIME_SCD_SLOW = 1
      2  216e				  -
      3  216e				  -
      4  216e				  -
      5  216e				  -
      6  216e				  -
      7  216e				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  216e				  -	      bne	. - 7
      9  216e					      ENDIF
    328  216e
    329  216e							; TIME REQUIRED FROM HERE (9/JAN)
    330  216e							; 8 + 16 + 8 + 2 + (21 * 23) -1 + (42 OVERHEAD WHEN RETURNING)
    331  216e							; = 558 --> /64 = 8.71 INTIM --> USE 10
    332  216e
    333  216e		       b9 d1 fd 	      lda	CharacterDataVecLO,y	; 4
    334  2171		       8d 8c f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    335  2174
    336  2174		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    337  2177		       8d 89 f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    338  217a		       8d 91 f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    339  217d		       8d 94 f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    340  2180
    341  2180		       bd e6 f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    342  2183		       8d 8f f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    343  2186
    344  2186		       a0 14	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2
    345  2188
    346  2188							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    347  2188							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    348  2188
    349  2188				   TSFill
    350  2188
    351  2188		       b9 3e f2    SMLOAD     lda	ScreenBitmap,y	; 4
    352  218b		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    353  218e		       29 00	   SMMASK     and	#0	; 2
    354  2190		       59 3e f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    355  2193		       99 3e f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    356  2196
    357  2196		       88		      dey		; 2
      0  2197					      CHECKPAGE_BPL	TSFill	; 3(2)=5
      8  2197					      LIST	ON
      9  2197		       10 ef		      bpl	TSFill
    359  2199
    360  2199		       4c 77 fc 	      jmp	DrawAnother	; 3
    361  219c
    362  219c							; Timing for "SLOW" draw
    363  219c							; 22+4+8+8+16+8+2+(21*24)-1+3 = 574 (was: 566 + 3)
    364  219c							; total: 37+574+6 = 617 => 628/64 + 1.4 = 11.04 = 12 (= SEGTIME_SLOWDRAW)
    365  219c
    366  219c
    367  219c							;------------------------------------------------------------------------------
    368  219c							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    369  219c							; existing character data, so can be special-cased from the normal character
    370  219c							; draw, saving roughly 230 cycles.
    371  219c
    372  219c				   QuickDraw		; 42 cycles until here
    373  219c
    374  219c		       ad 84 02 	      lda	INTIM	; 4
    375  219f		       c9 09		      cmp	#SEGTIME_SCD_QUICK	; 2	     SEE TIMING CALCS BELOW
    376  21a1		       90 af		      bcc	ExitDraw	; 2(3)=8
      0  21a3					      STRESS_TIME	SEGTIME_SCD_QUICK	; ok!
      1  21a3				  -	      IF	TEST_SEGTIME_SCD_QUICK = 1
      2  21a3				  -
      3  21a3				  -
      4  21a3				  -
      5  21a3				  -
      6  21a3				  -
      7  21a3				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  21a3				  -	      bne	. - 7
      9  21a3					      ENDIF
    378  21a3
    379  21a3							; TIME REQUIRED FROM HERE (9/JAN)
    380  21a3							;   = 32 + 4 + 2 + ( 7 * 38 ) - 1 + 3	+ (42 SUFFIX)
    381  21a3							;   = 348 --> /64 = 5.43. USE 7
    382  21a3
    383  21a3		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    384  21a6		       8d c3 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    385  21a9		       8d c6 f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    386  21ac		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    387  21ae		       8d ca f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    388  21b1		       8d cd f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    389  21b4		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    390  21b6		       8d d1 f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    391  21b9		       8d d4 f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32
    392  21bc
    393  21bc		       bc e4 f1 	      ldy	CharMask,x	; 4 =	4    masks out left or right
    394  21bf
    395  21bf		       a2 06		      ldx	#LINES_PER_CHAR/3 - 1	; 2 =	2
    396  21c1				   TSFill2
    397  21c1		       98		      tya		; 2
    398  21c2		       3d 3e f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    399  21c5		       9d 3e f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    400  21c8		       98		      tya		; 2
    401  21c9		       3d 3e f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    402  21cc		       9d 3e f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    403  21cf		       98		      tya		; 2
    404  21d0		       3d 3e f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    405  21d3		       9d 3e f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33
    406  21d6
    407  21d6		       ca		      dex		; 2
      0  21d7					      CHECKPAGE_BPL	TSFill2	; 3(2)=5
      8  21d7					      LIST	ON
      9  21d7		       10 e8		      bpl	TSFill2
    409  21d9
    410  21d9		       4c 77 fc 	      jmp	DrawAnother	; 3
    411  21dc
    412  21dc							; Timing for QuickDraw
    413  21dc							; 23+8+32+4+2+(7*38)-1+3 = 337 (was: 330 + 3)
    414  21dc							; total: 37+337+6 = 380 => 380/64 + 1.4 = 7.34 = 8 (= SEGTIME_SLOWDRAW-4)
    415  21dc
    416  21dc
    417  21dc							;------------------------------------------------------------------------------
    418  21dc
    419  21dc
    420  21dc				   CharAddressLO		;[abs char location % 10]
    421  21dc
    422  21dc							; Gives the absolute screen buffer address of the first line of the given character
    423  21dc							; Where character number is 0-9
    424  21dc
    425  21dc		       3e		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    426  21dd		       3e		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    427  21de		       53		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    428  21df		       53		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    429  21e0		       68		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    430  21e1		       68		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    431  21e2		       7d		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    432  21e3		       7d		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    433  21e4							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    434  21e4							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    435  21e4
    436  21e4				   CharMask		; [abs char location % 10]
    437  21e4
    438  21e4							; Gives the mask for any char of the screen (per row)
    439  21e4							; Note, this is hardwired to the screen format of 6 bytes/line
    440  21e4
    441  21e4		       0f		      .byte.b	$0F	; 1
    442  21e5		       f0		      .byte.b	$F0	; 2
    443  21e6				   CharMaskNeg
    444  21e6		       f0		      .byte.b	$F0	; 3/1
    445  21e7		       0f		      .byte.b	$0F	; 4/2
    446  21e8		       0f		      .byte.b	$0F	; 6/3
    447  21e9		       f0		      .byte.b	$F0	; 7/4
    448  21ea		       f0		      .byte.b	$F0	; 8/6
    449  21eb		       0f		      .byte.b	$0F	; 9/7
    450  21ec		       0f		      .byte.b	$0F	; -/8
    451  21ed		       f0		      .byte.b	$F0	; -/9
    452  21ee				   MOD10
    453  21ee					      REPEAT	SCREEN_LINES
    454  21ee							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  21ee							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  21ee		       80		      .byte.b	DIRECT
    457  21ef		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  21f3		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  21f4		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  21f4					      REPEND
    454  21f8							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  21f8							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  21f8		       80		      .byte.b	DIRECT
    457  21f9		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  21fd		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  21fe		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  21fe					      REPEND
    454  2202							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  2202							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  2202		       80		      .byte.b	DIRECT
    457  2203		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  2207		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  2208		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  2208					      REPEND
    454  220c							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  220c							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  220c		       80		      .byte.b	DIRECT
    457  220d		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  2211		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  2212		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  2212					      REPEND
    454  2216							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  2216							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  2216		       80		      .byte.b	DIRECT
    457  2217		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  221b		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  221c		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  221c					      REPEND
    454  2220							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  2220							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  2220		       80		      .byte.b	DIRECT
    457  2221		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  2225		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  2226		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  2226					      REPEND
    454  222a							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  222a							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  222a		       80		      .byte.b	DIRECT
    457  222b		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  222f		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  2230		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  2230					      REPEND
    454  2234							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  2234							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  2234		       80		      .byte.b	DIRECT
    457  2235		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  2239		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  223a		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    460  223e					      REPEND
    461  223e
    462  223e							;------------------------------------------------------------------------------
    463  223e
    464  223e
    465  223e
      0  223e					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  223e					      LIST	ON
    467  223e
    468  223e		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,$0	; character bitmap row (10 chars wide)
    469  223e		       f2 3e	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    470  223e		       f2 45	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    471  223e		       f2 4c	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    472  2292
      0  2292					      CHECKPAGE	ScreenBitmap
      8  2292					      LIST	ON
    474  2292
    475  2292							;--------------------------------------------------------------------------
    476  2292							;    CHARACTER_SET
    477  2292
------- FILE Explosion.asm LEVEL 3 PASS 3
      0  2292					      include	"Explosion.asm"	; 3 * LINES_PER_CHAR bytes
      0  2292					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_EXPLOSION1", LINES_PER_CHAR
     10  2292					      LIST	ON
      2  2292				   CHARACTERSHAPE_EXPLOSION1		; large
      3  2292				   CHARACTERSHAPE_EXPLOSION1_MIRRORED		; we don't worry about mirrored explosions!
      4  2292		       44		      .byte.b	%01000100	; R (#3 bright, complementary color)
      5  2293		       99		      .byte.b	%10011001
      6  2294		       00		      .byte.b	%00000000
      7  2295		       99		      .byte.b	%10011001
      8  2296		       00		      .byte.b	%00000000
      9  2297		       99		      .byte.b	%10011001
     10  2298		       22		      .byte.b	%00100010
     11  2299
     12  2299		       44		      .byte.b	%01000100	; G (#2 basic dirt color, usually the darkest one)
     13  229a		       99		      .byte.b	%10011001
     14  229b		       22		      .byte.b	%00100010
     15  229c		       dd		      .byte.b	%11011101
     16  229d		       44		      .byte.b	%01000100
     17  229e		       99		      .byte.b	%10011001
     18  229f		       22		      .byte.b	%00100010
     19  22a0
     20  22a0		       44		      .byte.b	%01000100	; B (#1 additional wall/boulder color)
     21  22a1		       99		      .byte.b	%10011001
     22  22a2		       22		      .byte.b	%00100010
     23  22a3		       bb		      .byte.b	%10111011
     24  22a4		       44		      .byte.b	%01000100
     25  22a5		       99		      .byte.b	%10011001
     26  22a6		       22		      .byte.b	%00100010
     27  22a7
      0  22a7					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_EXPLOSION2", LINES_PER_CHAR
     10  22a7					      LIST	ON
     29  22a7				   CHARACTERSHAPE_EXPLOSION2		; medium
     30  22a7				   CHARACTERSHAPE_EXPLOSION2_MIRRORED		; we don't worry about mirrored explosions!
     31  22a7		       00		      .byte.b	%00000000	; R
     32  22a8		       22		      .byte.b	%00100010
     33  22a9		       88		      .byte.b	%10001000
     34  22aa		       66		      .byte.b	%01100110
     35  22ab		       11		      .byte.b	%00010001
     36  22ac		       44		      .byte.b	%01000100
     37  22ad		       00		      .byte.b	%00000000
     38  22ae
     39  22ae		       00		      .byte.b	%00000000	; G
     40  22af		       22		      .byte.b	%00100010
     41  22b0		       99		      .byte.b	%10011001
     42  22b1		       66		      .byte.b	%01100110
     43  22b2		       99		      .byte.b	%10011001
     44  22b3		       44		      .byte.b	%01000100
     45  22b4		       00		      .byte.b	%00000000
     46  22b5
     47  22b5		       00		      .byte.b	%00000000	; B
     48  22b6		       22		      .byte.b	%00100010
     49  22b7		       99		      .byte.b	%10011001
     50  22b8		       66		      .byte.b	%01100110
     51  22b9		       99		      .byte.b	%10011001
     52  22ba		       44		      .byte.b	%01000100
     53  22bb							; .byte %00000000
     54  22bb
     55  22bb							;    OPTIONAL_PAGEBREAK "CHARACTERSHAPE_EXPLOSION3", LINES_PER_CHAR
     56  22bb				   CHARACTERSHAPE_EXPLOSION3		; small
     57  22bb				   CHARACTERSHAPE_EXPLOSION3_MIRRORED		; we don't worry about mirrored explosions!
     58  22bb		       00		      .byte.b	%00000000	; R
     59  22bc		       00		      .byte.b	%00000000
     60  22bd		       44		      .byte.b	%01000100
     61  22be		       00		      .byte.b	%00000000
     62  22bf		       22		      .byte.b	%00100010
     63  22c0		       00		      .byte.b	%00000000
     64  22c1		       00		      .byte.b	%00000000
     65  22c2
     66  22c2		       00		      .byte.b	%00000000	; G
     67  22c3		       00		      .byte.b	%00000000
     68  22c4		       44		      .byte.b	%01000100
     69  22c5		       00		      .byte.b	%00000000
     70  22c6		       22		      .byte.b	%00100010
     71  22c7		       00		      .byte.b	%00000000
     72  22c8		       00		      .byte.b	%00000000
     73  22c9
     74  22c9		       00		      .byte.b	%00000000	; B
     75  22ca		       00		      .byte.b	%00000000
     76  22cb		       44		      .byte.b	%01000100
     77  22cc		       00		      .byte.b	%00000000
     78  22cd		       22		      .byte.b	%00100010
     79  22ce		       00		      .byte.b	%00000000
     80  22cf		       00		      .byte.b	%00000000
     81  22d0
      0  22d0					      CHECKPAGE	CHARACTERSHAPE_EXPLOSION2	; since we share one byte!
      8  22d0					      LIST	ON
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE Diamond.asm LEVEL 3 PASS 3
      0  22d0					      include	"Diamond.asm"	; 2 * LINES_PER_CHAR + 2 bytes
      1  22d0		       00 02	   DIAMOND_DEF =	2
      2  22d0
      3  22d0				  -	      if	DIAMOND_DEF = 0
      4  22d0				  -
      5  22d0				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_DIAMOND", LINES_PER_CHAR+1
      6  22d0				  -CHARACTERSHAPE_DIAMOND2
      7  22d0				  -	      .byte	%00000000
      8  22d0				  -CHARACTERSHAPE_DIAMOND
      9  22d0				  -	      .byte	%01000100,%01100110,%01110111,%01110111,%01100110,%01000100,%00000000	;R
     10  22d0				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;B
     11  22d0				  -	      .byte	%01000100,%01100110,%01110111,%01110111,%01100110,%01000100	;,%00000000 ;G
     12  22d0				  -
     13  22d0				  -			;--------------------------------------------------------------------------
     14  22d0				  -			;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_DIAMOND_MIRRORED", LINES_PER_CHAR+1
     15  22d0				  -CHARACTERSHAPE_DIAMOND2_MIRRORED
     16  22d0				  -	      .byte	%00000000
     17  22d0				  -CHARACTERSHAPE_DIAMOND_MIRRORED
     18  22d0				  -	      .byte	%00100010,%01100110,%11101110,%11101110,%01100110,%00100010,%00000000	;R
     19  22d0				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;B
     20  22d0				  -	      .byte	%00100010,%01100110,%11101110,%11101110,%01100110,%00100010,%00000000	;G
     21  22d0				  -
     22  22d0				  -	      CHECKPAGE	CHARACTERSHAPE_DIAMOND2	; since we share one byte!
     23  22d0				  -
     24  22d0					      endif
     25  22d0
     26  22d0				  -	      if	DIAMOND_DEF = 1
     27  22d0				  -
     28  22d0				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_DIAMOND", LINES_PER_CHAR+1
     29  22d0				  -CHARACTERSHAPE_DIAMOND2
     30  22d0				  -	      .byte	%00000000
     31  22d0				  -CHARACTERSHAPE_DIAMOND
     32  22d0				  -	      .byte	%00100010
     33  22d0				  -	      .byte	%01100110
     34  22d0				  -	      .byte	%11101110
     35  22d0				  -	      .byte	%11101110
     36  22d0				  -	      .byte	%01100110
     37  22d0				  -	      .byte	%00100010
     38  22d0				  -	      .byte	%00000000	;R
     39  22d0				  -	      .byte	%00000000
     40  22d0				  -	      .byte	%00000000
     41  22d0				  -	      .byte	%00000000
     42  22d0				  -	      .byte	%10001000
     43  22d0				  -	      .byte	%01000100
     44  22d0				  -	      .byte	%00100010
     45  22d0				  -	      .byte	%00000000	;B
     46  22d0				  -	      .byte	%00100010
     47  22d0				  -	      .byte	%01100110
     48  22d0				  -	      .byte	%11101110
     49  22d0				  -	      .byte	%11101110
     50  22d0				  -	      .byte	%01100110
     51  22d0				  -	      .byte	%00100010
     52  22d0				  -			;    .byte %00000000 ;G
     53  22d0				  -
     54  22d0				  -			;--------------------------------------------------------------------------
     55  22d0				  -			;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_DIAMOND_MIRRORED", LINES_PER_CHAR+1
     56  22d0				  -CHARACTERSHAPE_DIAMOND2_MIRRORED
     57  22d0				  -	      .byte	%00000000
     58  22d0				  -CHARACTERSHAPE_DIAMOND_MIRRORED
     59  22d0				  -	      .byte	%01000100
     60  22d0				  -	      .byte	%01100110
     61  22d0				  -	      .byte	%01110111
     62  22d0				  -	      .byte	%01110111
     63  22d0				  -	      .byte	%01100110
     64  22d0				  -	      .byte	%01000100
     65  22d0				  -	      .byte	%00000000	;R
     66  22d0				  -	      .byte	%00000000
     67  22d0				  -	      .byte	%00000000
     68  22d0				  -	      .byte	%00000000
     69  22d0				  -	      .byte	%00010001
     70  22d0				  -	      .byte	%00100010
     71  22d0				  -	      .byte	%01000100
     72  22d0				  -	      .byte	%00000000	;B
     73  22d0				  -	      .byte	%01000100
     74  22d0				  -	      .byte	%01100110
     75  22d0				  -	      .byte	%01110111
     76  22d0				  -	      .byte	%01110111
     77  22d0				  -	      .byte	%01100110
     78  22d0				  -	      .byte	%01000100
     79  22d0				  -	      .byte	%00000000	;G
     80  22d0				  -
     81  22d0				  -	      CHECKPAGE	CHARACTERSHAPE_DIAMOND2	; since we share one byte!
     82  22d0				  -
     83  22d0					      endif
     84  22d0
     85  22d0					      if	DIAMOND_DEF = 2
     86  22d0
      0  22d0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_DIAMOND", LINES_PER_CHAR+1
     10  22d0					      LIST	ON
     88  22d0				   CHARACTERSHAPE_DIAMOND2_MIRRORED
     89  22d0		       00		      .byte.b	%00000000
     90  22d1				   CHARACTERSHAPE_DIAMOND_MIRRORED
     91  22d1		       22		      .byte.b	%00100010
     92  22d2		       66		      .byte.b	%01100110
     93  22d3		       ee		      .byte.b	%11101110
     94  22d4		       ee		      .byte.b	%11101110
     95  22d5		       66		      .byte.b	%01100110
     96  22d6		       22		      .byte.b	%00100010
     97  22d7		       00		      .byte.b	%00000000	;R
     98  22d8		       00		      .byte.b	%00000000
     99  22d9		       00		      .byte.b	%00000000
    100  22da		       00		      .byte.b	%00000000
    101  22db		       ee		      .byte.b	%11101110
    102  22dc		       66		      .byte.b	%01100110
    103  22dd		       22		      .byte.b	%00100010
    104  22de		       00		      .byte.b	%00000000	;B
    105  22df		       22		      .byte.b	%00100010
    106  22e0		       66		      .byte.b	%01100110
    107  22e1		       ee		      .byte.b	%11101110
    108  22e2		       ee		      .byte.b	%11101110
    109  22e3		       66		      .byte.b	%01100110
    110  22e4		       22		      .byte.b	%00100010
    111  22e5							;    .byte %00000000 ;G
    112  22e5
    113  22e5							;--------------------------------------------------------------------------
    114  22e5							;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_DIAMOND_MIRRORED", LINES_PER_CHAR+1
    115  22e5				   CHARACTERSHAPE_DIAMOND2
    116  22e5		       00		      .byte.b	%00000000
    117  22e6				   CHARACTERSHAPE_DIAMOND
    118  22e6		       44		      .byte.b	%01000100
    119  22e7		       66		      .byte.b	%01100110
    120  22e8		       77		      .byte.b	%01110111
    121  22e9		       77		      .byte.b	%01110111
    122  22ea		       66		      .byte.b	%01100110
    123  22eb		       44		      .byte.b	%01000100
    124  22ec		       00		      .byte.b	%00000000	;R
    125  22ed		       00		      .byte.b	%00000000
    126  22ee		       00		      .byte.b	%00000000
    127  22ef		       00		      .byte.b	%00000000
    128  22f0		       77		      .byte.b	%01110111
    129  22f1		       66		      .byte.b	%01100110
    130  22f2		       44		      .byte.b	%01000100
    131  22f3		       00		      .byte.b	%00000000	;B
    132  22f4		       44		      .byte.b	%01000100
    133  22f5		       66		      .byte.b	%01100110
    134  22f6		       77		      .byte.b	%01110111
    135  22f7		       77		      .byte.b	%01110111
    136  22f8		       66		      .byte.b	%01100110
    137  22f9		       44		      .byte.b	%01000100
    138  22fa		       00		      .byte.b	%00000000	;G
    139  22fb
      0  22fb					      CHECKPAGE	CHARACTERSHAPE_DIAMOND2	; since we share one byte!
      8  22fb					      LIST	ON
    141  22fb
    142  22fb					      endif
    143  22fb
    144  22fb				  -	      if	DIAMOND_DEF = 3
    145  22fb				  -
    146  22fb				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_DIAMOND", LINES_PER_CHAR+1
    147  22fb				  -CHARACTERSHAPE_DIAMOND2
    148  22fb				  -	      .byte	%00000000
    149  22fb				  -CHARACTERSHAPE_DIAMOND
    150  22fb				  -	      .byte	%00100010
    151  22fb				  -	      .byte	%01100110
    152  22fb				  -	      .byte	%11101110
    153  22fb				  -	      .byte	%11101110
    154  22fb				  -	      .byte	%01100110
    155  22fb				  -	      .byte	%00100010
    156  22fb				  -	      .byte	%00000000	;R
    157  22fb				  -	      .byte	%00000000
    158  22fb				  -	      .byte	%00000000
    159  22fb				  -	      .byte	%00000000
    160  22fb				  -	      .byte	%11101110
    161  22fb				  -	      .byte	%00000000
    162  22fb				  -	      .byte	%00000000
    163  22fb				  -	      .byte	%00000000	;B
    164  22fb				  -	      .byte	%00100010
    165  22fb				  -	      .byte	%01100110
    166  22fb				  -	      .byte	%11101110
    167  22fb				  -	      .byte	%11101110
    168  22fb				  -	      .byte	%01100110
    169  22fb				  -	      .byte	%00100010
    170  22fb				  -			;    .byte %00000000 ;G
    171  22fb				  -
    172  22fb				  -			;--------------------------------------------------------------------------
    173  22fb				  -			;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_DIAMOND_MIRRORED", LINES_PER_CHAR+1
    174  22fb				  -CHARACTERSHAPE_DIAMOND2_MIRRORED
    175  22fb				  -	      .byte	%00000000
    176  22fb				  -CHARACTERSHAPE_DIAMOND_MIRRORED
    177  22fb				  -	      .byte	%01000100
    178  22fb				  -	      .byte	%01100110
    179  22fb				  -	      .byte	%01110111
    180  22fb				  -	      .byte	%01110111
    181  22fb				  -	      .byte	%01100110
    182  22fb				  -	      .byte	%01000100
    183  22fb				  -	      .byte	%00000000	;R
    184  22fb				  -	      .byte	%00000000
    185  22fb				  -	      .byte	%00000000
    186  22fb				  -	      .byte	%00000000
    187  22fb				  -	      .byte	%01110111
    188  22fb				  -	      .byte	%00000000
    189  22fb				  -	      .byte	%00000000
    190  22fb				  -	      .byte	%00000000	;B
    191  22fb				  -	      .byte	%01000100
    192  22fb				  -	      .byte	%01100110
    193  22fb				  -	      .byte	%01110111
    194  22fb				  -	      .byte	%01110111
    195  22fb				  -	      .byte	%01100110
    196  22fb				  -	      .byte	%01000100
    197  22fb				  -	      .byte	%00000000	;G
    198  22fb				  -
    199  22fb				  -	      CHECKPAGE	CHARACTERSHAPE_DIAMOND2	; since we share one byte!
    200  22fb				  -
    201  22fb					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    480  22fb							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    481  22fb
    482  22fb
      0  22fb					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  22fb		       00 04	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  22fb					      SUBROUTINE
      3  22fb				   SelfModDrawPlayers
    484  22fb
    485  22fb							; Now the player(s) have animated, update the appropriate shape pointers
    486  22fb							; in the draw code.
    487  22fb
    488  22fb							; Sets the shapes to a blank player -- effectively erasing
    489  22fb		       a5 ad		      lda	LastSpriteY
    490  22fd		       a2 3a		      ldx	#<PLAYER_BLANK
    491  22ff		       20 0e f3 	      jsr	SetSelfModPlayer
    492  2302
    493  2302							; Now we've erased, we write the new shape
    494  2302
    495  2302							;		  sec
    496  2302							;		  lda ManDrawX
    497  2302							;		  sbc BoardScrollX
    498  2302							;		  cmp #SCREEN_WIDTH			  ; disabled because we assume always onscreen
    499  2302							;		  bcs NoMod				  ; skip if off visible screen
    500  2302
    501  2302		       a5 a1		      lda	ManDrawX
    502  2304		       c9 0a		      cmp	#SCREEN_WIDTH	; disabled because we assume always onscreen
    503  2306		       b0 1c		      bcs	NoMod	; skip if off visible screen
    504  2308
    505  2308							;lda LookingAround
    506  2308							;bne NoMod
    507  2308
    508  2308		       a5 a2		      lda	ManDrawY
    509  230a		       85 ad		      sta	LastSpriteY
    510  230c
    511  230c		       a6 a7		      ldx	ManAnimationFrameLO
    512  230e
    513  230e				   SetSelfModPlayer
    514  230e		       c9 08		      cmp	#SCREEN_LINES	; only erase/draw if was/is onscreen
    515  2310		       b0 12		      bcs	NoMod
    516  2312		       69 00		      adc	#BANK_SCREENMARKII1
    517  2314		       85 3e		      sta	SET_BANK_RAM	; switch old/new bank in
    518  2316
    519  2316		       8a		      txa
    520  2317		       8d 20 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1	; lo of frame
    521  231a		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    522  231c		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    523  231f		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    524  2321		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    525  2324
    526  2324				   NoMod
    527  2324		       60		      rts
    528  2325
------- FILE Dirt.asm LEVEL 3 PASS 3
      0  2325					      include	"Dirt.asm"	; 2 * LINES_PER_CHAR bytes
      1  2325		       00 05	   SOIL_DEF   =	5
      2  2325
      3  2325							; 3   RELEASED BD1
      4  2325							; 4
      5  2325							; 5   AD SOLID
      6  2325							; 6   AD INVERTED of released version
      7  2325
      8  2325
      9  2325				  -	      if	SOIL_DEF = 0
     10  2325				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     11  2325				  -CHARACTERSHAPE_SOIL
     12  2325				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     13  2325				  -	      .byte	%01110111,%11011101,%11101110,%11011101,%10101010,%01010101,%11101110	;G
     14  2325				  -			;  .byte %01010101,%10111011,%11101110,%11011101,%01110111,%11011101,%10101010 ;G
     15  2325				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;B
     16  2325				  -
     17  2325				  -			;--------------------------------------------------------------------------
     18  2325				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     19  2325				  -CHARACTERSHAPE_SOIL_MIRRORED
     20  2325				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     21  2325				  -	      .byte	%10111011,%11111111,%11011101,%11111111,%01110111,%11111111,%11101110	;G
     22  2325				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00010001,%00000000,%00000000	;B
     23  2325					      endif
     24  2325
     25  2325				  -	      if	SOIL_DEF = 1
     26  2325				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     27  2325				  -CHARACTERSHAPE_SOIL
     28  2325				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     29  2325				  -			;  .byte %01110111,%11011101,%11101110,%11011101,%10101010,%01010101,%11101110 ;G
     30  2325				  -	      .byte	%01010101,%10111011,%11101110,%11011101,%01110111,%11011101,%10101010	;G
     31  2325				  -	      .byte	%00000000,%00010001,%00000000,%00000000,%01000100,%00000000,%00000000	;B
     32  2325				  -
     33  2325				  -			;--------------------------------------------------------------------------
     34  2325				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     35  2325				  -CHARACTERSHAPE_SOIL_MIRRORED
     36  2325				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     37  2325				  -	      .byte	%10101010,%11011101,%01110111,%10111011,%11101110,%10111011,%01010101	;G
     38  2325				  -	      .byte	%00000000,%10001000,%00000000,%00000000,%00100010,%00000000,%00000000	;B
     39  2325				  -			; .byte %10111011,%11111111,%11011101,%11111111,%01110111,%11111111,%11101110 ;G
     40  2325				  -			; .byte %00000000,%00000000,%01000100,%00000000,%00010001,%00000000,%00000000 ;B
     41  2325					      endif
     42  2325
     43  2325				  -	      if	SOIL_DEF = 2
     44  2325				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     45  2325				  -CHARACTERSHAPE_SOIL
     46  2325				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     47  2325				  -	      .byte	%10101010,%01110111,%11011101,%10101010,%01110111,%10111011,%01010101	;G
     48  2325				  -	      .byte	%00000000,%01000100,%00000000,%00000000,%00010001,%00000000,%00000000	;B
     49  2325				  -
     50  2325				  -			;--------------------------------------------------------------------------
     51  2325				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     52  2325				  -CHARACTERSHAPE_SOIL_MIRRORED
     53  2325				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     54  2325				  -	      .byte	%01010101,%11101110,%10111011,%01010101,%11101110,%11011101,%10101010	;G
     55  2325				  -	      .byte	%00000000,%00100010,%00000000,%00000000,%10001000,%00000000,%00000000	;B
     56  2325					      endif
     57  2325
     58  2325				  -	      if	SOIL_DEF = 3
     59  2325				  -			; "ORIGINAL"
     60  2325				  -			;--------------------------------------------------------------------------
     61  2325				  -
     62  2325				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     63  2325				  -CHARACTERSHAPE_SOIL
     64  2325				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     65  2325				  -	      .byte	%10101010,%00100010,%01010101,%00100010,%01010101,%10101010,%00010001	;G
     66  2325				  -			;.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ;B
     67  2325				  -
     68  2325				  -			;--------------------------------------------------------------------------
     69  2325				  -			;	 OPTIONAL_PAGEBREAK "CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     70  2325				  -CHARACTERSHAPE_SOIL_MIRRORED
     71  2325				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     72  2325				  -	      .byte	%01010101,%01000100,%10101010,%01000100,%10101010,%01010101,%10001000	;G
     73  2325				  -
     74  2325				  -			; AD TODO - THIS IS ERRONEOUSLY OPTIMISED OUT....
     75  2325				  -			; AD IT RELIES ON WHATEVER FOLLOWS TO BE 0 BUT NOT ENFORCED SO ERRROR
     76  2325				  -			; .byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ;B shared with Rockford.asm!
     77  2325				  -
     78  2325				  -			;--------------------------------------------------------------------------
     79  2325					      endif
     80  2325
     81  2325				  -	      if	SOIL_DEF = 4
     82  2325				  -			; "ORIGINAL"
     83  2325				  -			;--------------------------------------------------------------------------
     84  2325				  -
     85  2325				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     86  2325				  -CHARACTERSHAPE_SOIL
     87  2325				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     88  2325				  -	      .byte	%10001000,%01010101,%10101010,%01010101,%00100010,%10101010,%01010101	;G
     89  2325				  -	      .byte	%00000000,%00000000,%10001000,%00000000,%00000000,%00100010,%00000000	;B
     90  2325				  -
     91  2325				  -			;--------------------------------------------------------------------------
     92  2325				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     93  2325				  -CHARACTERSHAPE_SOIL_MIRRORED
     94  2325				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     95  2325				  -	      .byte	%00010001,%10101010,%01010101,%10101010,%01000100,%01010101,%10101010	;G
     96  2325				  -	      .byte	%00000000,%00000000,%00010001,%00000000,%00000000,%01000100,%00000000	;B
     97  2325				  -
     98  2325				  -			;--------------------------------------------------------------------------
     99  2325					      endif
    100  2325
    101  2325					      if	SOIL_DEF = 5
    102  2325							; SOLID
      0  2325					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  2325					      LIST	ON
    104  2325				   CHARACTERSHAPE_SOIL
    105  2325				   CHARACTERSHAPE_SOIL_MIRRORED
    106  2325		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
    107  232c		       ff		      .byte.b	%11111111
    108  232d		       ff		      .byte.b	%11111111
    109  232e		       ff		      .byte.b	%11111111
    110  232f		       ff		      .byte.b	%11111111
    111  2330		       ff		      .byte.b	%11111111
    112  2331		       ff		      .byte.b	%11111111
    113  2332		       ff		      .byte.b	%11111111
    114  2333		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
    115  233a					      endif
    116  233a
    117  233a				  -	      if	SOIL_DEF = 6
    118  233a				  -			; INVERTED
    119  233a				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
    120  233a				  -CHARACTERSHAPE_SOIL
    121  233a				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
    122  233a				  -	      .byte	%01010101,%11011101,%10101010,%11011101,%10101010,%01010101,%11101110	;G
    123  233a				  -			;.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ;B
    124  233a				  -
    125  233a				  -			;--------------------------------------------------------------------------
    126  233a				  -			;	 OPTIONAL_PAGEBREAK "CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
    127  233a				  -CHARACTERSHAPE_SOIL_MIRRORED
    128  233a				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
    129  233a				  -	      .byte	%10101010,%10111011,%01010101,%10111011,%01010101,%10101010,%01110111	;G
    130  233a				  -
    131  233a				  -			; AD TODO - THIS IS ERRONEOUSLY OPTIMISED OUT....
    132  233a				  -			; AD IT RELIES ON WHATEVER FOLLOWS TO BE 0 BUT NOT ENFORCED SO ERRROR
    133  233a				  -			; .byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ;B shared with Rockford.asm!
    134  233a					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE Rockford.asm LEVEL 3 PASS 3
      0  233a					      include	"Rockford.asm"	; 6 * LINES_PER_CHAR	       MUST FOLLOW DIRT.ASM as data is shared
      1  233a							;    OPTIONAL_PAGEBREAK "PLAYER", LINES_PER_CHAR * 6 - 1
      2  233a
      3  233a
      4  233a		       f3 3a	   PLAYER_BLANK =	.	; MUST APPEAR AT TOP AS DATA SHARED BY DIRT
      5  233a					      REPEAT	LINES_PER_CHAR	;-1  ; as we have a "0" in the line below
      6  233a		       00		      .byte.b	0
      5  233a					      REPEND
      6  233b		       00		      .byte.b	0
      5  233b					      REPEND
      6  233c		       00		      .byte.b	0
      5  233c					      REPEND
      6  233d		       00		      .byte.b	0
      5  233d					      REPEND
      6  233e		       00		      .byte.b	0
      5  233e					      REPEND
      6  233f		       00		      .byte.b	0
      5  233f					      REPEND
      6  2340		       00		      .byte.b	0
      5  2340					      REPEND
      6  2341		       00		      .byte.b	0
      5  2341					      REPEND
      6  2342		       00		      .byte.b	0
      5  2342					      REPEND
      6  2343		       00		      .byte.b	0
      5  2343					      REPEND
      6  2344		       00		      .byte.b	0
      5  2344					      REPEND
      6  2345		       00		      .byte.b	0
      5  2345					      REPEND
      6  2346		       00		      .byte.b	0
      5  2346					      REPEND
      6  2347		       00		      .byte.b	0
      5  2347					      REPEND
      6  2348		       00		      .byte.b	0
      5  2348					      REPEND
      6  2349		       00		      .byte.b	0
      5  2349					      REPEND
      6  234a		       00		      .byte.b	0
      5  234a					      REPEND
      6  234b		       00		      .byte.b	0
      5  234b					      REPEND
      6  234c		       00		      .byte.b	0
      5  234c					      REPEND
      6  234d		       00		      .byte.b	0
      5  234d					      REPEND
      6  234e		       00		      .byte.b	0
      7  234f					      REPEND
      8  234f
      9  234f				   PLAYER_RIGHT0
     10  234f							;  X XX
     11  234f							;  XXXX
     12  234f							;  XXX
     13  234f							;  XXX
     14  234f							;   XX
     15  234f							;   XX
     16  234f							;   XX
     17  234f							;   XX
     18  234f							;   XXX
     19  234f							;   XXX
     20  234f							;   XX
     21  234f							;   XX
     22  234f							;   XX
     23  234f							;   XX
     24  234f							;  XXXX
     25  234f							;  XXX X
     26  234f							;  XXX X
     27  234f							;  XXX X
     28  234f							;  XXXX
     29  234f							;   XX
     30  234f							;
     31  234f
     32  234f		       2c		      .byte.b	%00101100	; 0
     33  2350		       38		      .byte.b	%00111000	; 3
     34  2351		       18		      .byte.b	%00011000	; 6 etc.
     35  2352		       1c		      .byte.b	%00011100
     36  2353		       18		      .byte.b	%00011000
     37  2354		       3a		      .byte.b	%00111010
     38  2355		       3c		      .byte.b	%00111100
     39  2356
     40  2356		       3c		      .byte.b	%00111100	; 1
     41  2357		       18		      .byte.b	%00011000	; 4 etc.
     42  2358		       18		      .byte.b	%00011000
     43  2359		       18		      .byte.b	%00011000
     44  235a		       18		      .byte.b	%00011000
     45  235b		       3a		      .byte.b	%00111010
     46  235c		       18		      .byte.b	%00011000
     47  235d
     48  235d		       38		      .byte.b	%00111000	; 2
     49  235e		       18		      .byte.b	%00011000	; 5 etc.
     50  235f		       1c		      .byte.b	%00011100
     51  2360		       18		      .byte.b	%00011000
     52  2361		       3c		      .byte.b	%00111100
     53  2362		       3a		      .byte.b	%00111010
     54  2363		       00		      .byte.b	0
     55  2364
     56  2364				   PLAYER_RIGHT1
     57  2364
     58  2364					      IF	1 = 1
     59  2364							; X?	 XX
     60  2364							; X	 X
     61  2364							; X	 X
     62  2364							; XX	XX
     63  2364							;  XXXXX
     64  2364							;     XX
     65  2364							;     XX
     66  2364							;     XX
     67  2364							;     XXX
     68  2364							;     XXX
     69  2364							;     XX
     70  2364							;     XX
     71  2364							;     XX
     72  2364							;     XX
     73  2364							;    XXXX
     74  2364							;    XXX X
     75  2364							;    XXX X
     76  2364							;    XXX X
     77  2364							;    XXXX
     78  2364							;     XX
     79  2364
     80  2364		       43		      .byte.b	%01000011	; 0
     81  2365		       66		      .byte.b	%01100110	; 3
     82  2366		       18		      .byte.b	%00011000	; 6 etc.
     83  2367		       1c		      .byte.b	%00011100
     84  2368		       18		      .byte.b	%00011000
     85  2369		       3a		      .byte.b	%00111010
     86  236a		       3c		      .byte.b	%00111100
     87  236b
     88  236b		       42		      .byte.b	%01000010	; 1
     89  236c		       3c		      .byte.b	%00111100	; 4 etc.
     90  236d		       18		      .byte.b	%00011000
     91  236e		       18		      .byte.b	%00011000
     92  236f		       18		      .byte.b	%00011000
     93  2370		       3a		      .byte.b	%00111010
     94  2371		       18		      .byte.b	%00011000
     95  2372
     96  2372		       42		      .byte.b	%01000010	; 2
     97  2373		       18		      .byte.b	%00011000	; 5 etc.
     98  2374		       1c		      .byte.b	%00011100
     99  2375		       18		      .byte.b	%00011000
    100  2376		       3c		      .byte.b	%00111100
    101  2377		       3a		      .byte.b	%00111010
    102  2378		       00		      .byte.b	0
    103  2379				  -	      ELSE
    104  2379				  -			; Alternativly make his neck pixel shorter here.
    105  2379				  -			; This looks more dynamic, but shows a problems with the hair color.
    106  2379				  -			; Maybe if we remove the t-shirt/trousers color look and make him
    107  2379				  -			; look more like an insect (which he acutally is), we can fix this.
    108  2379				  -
    109  2379				  -			; X?	 XX
    110  2379				  -			; X	 X
    111  2379				  -			; X	 X
    112  2379				  -			; XX	XX
    113  2379				  -			;  XXXXX
    114  2379				  -			;     XX
    115  2379				  -			;     XX
    116  2379				  -			;     XX
    117  2379				  -			;     XXX
    118  2379				  -			;     XXX
    119  2379				  -			;     XX
    120  2379				  -			;     XX
    121  2379				  -			;     XX
    122  2379				  -			;    XXXX
    123  2379				  -			;    XXX X
    124  2379				  -			;    XXX X
    125  2379				  -			;    XXX X
    126  2379				  -			;    XXXX
    127  2379				  -			;     XX
    128  2379				  -
    129  2379				  -	      .byte	%01000011	; 0
    130  2379				  -	      .byte	%01100110	; 3
    131  2379				  -	      .byte	%00011000	; 6 etc.
    132  2379				  -	      .byte	%00011100
    133  2379				  -	      .byte	%00011000
    134  2379				  -	      .byte	%00111010
    135  2379				  -	      .byte	%00011000
    136  2379				  -
    137  2379				  -	      .byte	%01000010	; 1
    138  2379				  -	      .byte	%00111100	; 4 etc.
    139  2379				  -	      .byte	%00011000
    140  2379				  -	      .byte	%00011000
    141  2379				  -	      .byte	%00111100
    142  2379				  -	      .byte	%00111010
    143  2379				  -	      .byte	0
    144  2379				  -
    145  2379				  -	      .byte	%01000010	; 2
    146  2379				  -	      .byte	%00011000	; 5 etc.
    147  2379				  -	      .byte	%00011100
    148  2379				  -	      .byte	%00011000
    149  2379				  -	      .byte	%00111010
    150  2379				  -	      .byte	%00111100
    151  2379				  -	      .byte	0
    152  2379					      ENDIF
    153  2379
    154  2379							;------------------------------------------------------------------------------
    155  2379
    156  2379							; NOTE: PLAYER SHAPES ARE *NOT* RGB
    157  2379							; THEY ARE JUST REORDERED THIS WAY FOR THE KERNEL
    158  2379
    159  2379				   PLAYER_STAND
    160  2379							; original 15 pixel tall, ours was 18 pixel, stretched to 20 now
    161  2379							; this makes Rockford looks closer to original, slimmer and less fat
    162  2379							; also boulder/diamonds above his head look less levitating now
    163  2379
    164  2379							; XX  XX    XX  XX    XX  XX
    165  2379							;  X  X      X  X	X  X
    166  2379							;  X  X      X  X	X  X
    167  2379							;  XXXX      X  X	X  X
    168  2379							;   XX       XXXX	XXXX
    169  2379							;   XX        XX	 XX
    170  2379							; X XX X    X XX X	 XX
    171  2379							; X XX X    X XX X	 XX
    172  2379							;  XXXX     X XX X    X XX X
    173  2379							;   XX       XXXX     X XX X
    174  2379							;  XXXX       XX      X XX X
    175  2379							; X XX X      XX	XXXX
    176  2379							; X XX X     XXXX	 XX
    177  2379							;  XXXX     X XX X	 XX
    178  2379							;  X  X     X XX X	XXXX
    179  2379							;	     X XX X    X XX X
    180  2379							;	      XXXX     X XX X
    181  2379							;	      X  X     X XX X
    182  2379							;			XXXX
    183  2379							;			X  X
    184  2379
    185  2379		       66		      .byte.b	%01100110	; 0
    186  237a		       24		      .byte.b	%00100100	; 3
    187  237b		       18		      .byte.b	%00011000	; 6 etc.
    188  237c		       5a		      .byte.b	%01011010
    189  237d		       18		      .byte.b	%00011000
    190  237e		       5a		      .byte.b	%01011010
    191  237f		       3c		      .byte.b	%00111100
    192  2380
    193  2380		       24		      .byte.b	%00100100	; 1
    194  2381		       3c		      .byte.b	%00111100	; 4 etc.
    195  2382		       18		      .byte.b	%00011000
    196  2383		       5a		      .byte.b	%01011010
    197  2384		       18		      .byte.b	%00011000
    198  2385		       5a		      .byte.b	%01011010
    199  2386		       24		      .byte.b	%00100100
    200  2387
    201  2387		       24		      .byte.b	%00100100	; 2
    202  2388		       18		      .byte.b	%00011000	; 5 etc.
    203  2389		       5a		      .byte.b	%01011010
    204  238a		       3c		      .byte.b	%00111100
    205  238b		       3c		      .byte.b	%00111100
    206  238c		       5a		      .byte.b	%01011010
    207  238d		       00		      .byte.b	0
    208  238e
    209  238e				   PLAYER_BLINK
    210  238e							; XX  XX
    211  238e							;  X  X
    212  238e							;  X  X
    213  238e							;  X  X
    214  238e							;  XXXX
    215  238e							;   XX
    216  238e							;   XX
    217  238e							;   XX
    218  238e							; X XX X
    219  238e							; X XX X
    220  238e							; X XX X
    221  238e							;  XXXX
    222  238e							;   XX
    223  238e							;   XX
    224  238e							;  XXXX
    225  238e							; XXXXXX
    226  238e							; XXXXXX
    227  238e							; XXXXXX
    228  238e							;  XXXX
    229  238e							;  X  X
    230  238e
    231  238e		       66		      .byte.b	%01100110	; 0
    232  238f		       24		      .byte.b	%00100100	; 3
    233  2390		       18		      .byte.b	%00011000	; 6 etc.
    234  2391		       5a		      .byte.b	%01011010
    235  2392		       18		      .byte.b	%00011000
    236  2393		       7e		      .byte.b	%01111110
    237  2394		       3c		      .byte.b	%00111100
    238  2395
    239  2395		       24		      .byte.b	%00100100	; 1
    240  2396		       3c		      .byte.b	%00111100	; 4 etc.
    241  2397		       18		      .byte.b	%00011000
    242  2398		       5a		      .byte.b	%01011010
    243  2399		       18		      .byte.b	%00011000
    244  239a		       7e		      .byte.b	%01111110
    245  239b		       24		      .byte.b	%00100100
    246  239c
    247  239c		       24		      .byte.b	%00100100	; 2
    248  239d		       18		      .byte.b	%00011000	; 5 etc.
    249  239e		       5a		      .byte.b	%01011010
    250  239f		       3c		      .byte.b	%00111100
    251  23a0		       3c		      .byte.b	%00111100
    252  23a1		       7e		      .byte.b	%01111110
    253  23a2		       00		      .byte.b	0
    254  23a3							; 1
    255  23a3				   PLAYER_TAP0
    256  23a3							; XX  XX
    257  23a3							;  X  X
    258  23a3							;  X  X
    259  23a3							;  X  X
    260  23a3							;  XXXX
    261  23a3							;   XX
    262  23a3							;   XX
    263  23a3							;   XX
    264  23a3							;  XXXX
    265  23a3							; X XX X
    266  23a3							; X XX X
    267  23a3							;  XXXX
    268  23a3							;   XX
    269  23a3							;   XX
    270  23a3							;  XXXX
    271  23a3							; X XX X
    272  23a3							; X XX X
    273  23a3							; X XX X
    274  23a3							;  XXXX
    275  23a3							;  X  X
    276  23a3
    277  23a3		       66		      .byte.b	%01100110	; 0
    278  23a4		       24		      .byte.b	%00100100	; 3
    279  23a5		       18		      .byte.b	%00011000	; 6 etc.
    280  23a6		       5a		      .byte.b	%01011010
    281  23a7		       18		      .byte.b	%00011000
    282  23a8		       5a		      .byte.b	%01011010
    283  23a9		       3c		      .byte.b	%00111100
    284  23aa
    285  23aa		       24		      .byte.b	%00100100	; 1
    286  23ab		       3c		      .byte.b	%00111100	; 4 etc.
    287  23ac		       18		      .byte.b	%00011000
    288  23ad		       5a		      .byte.b	%01011010
    289  23ae		       18		      .byte.b	%00011000
    290  23af		       5a		      .byte.b	%01011010
    291  23b0		       24		      .byte.b	%00100100
    292  23b1
    293  23b1		       24		      .byte.b	%00100100	; 2
    294  23b2		       18		      .byte.b	%00011000	; 5 etc.
    295  23b3		       3c		      .byte.b	%00111100
    296  23b4		       3c		      .byte.b	%00111100
    297  23b5		       3c		      .byte.b	%00111100
    298  23b6		       5a		      .byte.b	%01011010
    299  23b7		       00		      .byte.b	0
    300  23b8
    301  23b8				   PLAYER_TAP1
    302  23b8							;     XX
    303  23b8							; XX  X
    304  23b8							;  X  X
    305  23b8							;  X  X
    306  23b8							;  XXXX
    307  23b8							;   XX
    308  23b8							;   XX
    309  23b8							;   XX
    310  23b8							;  XXXX
    311  23b8							; X XX X
    312  23b8							; X XX X
    313  23b8							;  XXXX
    314  23b8							;   XX
    315  23b8							;   XX
    316  23b8							;  XXXX
    317  23b8							; X XX X
    318  23b8							; X XX X
    319  23b8							; X XX X
    320  23b8							;  XXXX
    321  23b8							;  X  X
    322  23b8
    323  23b8		       06		      .byte.b	%00000110	; 0
    324  23b9		       24		      .byte.b	%00100100	; 3
    325  23ba		       18		      .byte.b	%00011000	; 6 etc.
    326  23bb		       5a		      .byte.b	%01011010
    327  23bc		       18		      .byte.b	%00011000
    328  23bd		       5a		      .byte.b	%01011010
    329  23be		       3c		      .byte.b	%00111100
    330  23bf
    331  23bf		       64		      .byte.b	%01100100	; 1
    332  23c0		       3c		      .byte.b	%00111100	; 4 etc.
    333  23c1		       18		      .byte.b	%00011000
    334  23c2		       5a		      .byte.b	%01011010
    335  23c3		       18		      .byte.b	%00011000
    336  23c4		       5a		      .byte.b	%01011010
    337  23c5		       24		      .byte.b	%00100100
    338  23c6
    339  23c6		       24		      .byte.b	%00100100	; 2
    340  23c7		       18		      .byte.b	%00011000	; 5 etc.
    341  23c8		       3c		      .byte.b	%00111100
    342  23c9		       3c		      .byte.b	%00111100
    343  23ca		       3c		      .byte.b	%00111100
    344  23cb		       5a		      .byte.b	%01011010
    345  23cc		       00		      .byte.b	0
    346  23cd
    347  23cd							;    CHECKPAGE PLAYER_BLANK
      0  23cd					      CHECKPAGE	CHARACTERSHAPE_SOIL	; since we share some 0 bytes!
      8  23cd					      LIST	ON
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE Magic_Wall.asm LEVEL 3 PASS 3
      0  23cd					      include	"Magic_Wall.asm"	; 3 * LINES_PER_CHAR bytes
      1  23cd							;    OPTIONAL_PAGEBREAK "CHARACTERSHAPE_WALL3", LINES_PER_CHAR
      2  23cd							;CHARACTERSHAPE_WALL3
      3  23cd							; .byte %00000000,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011 ;R
      4  23cd							; .byte %11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011 ;G
      5  23cd							; .byte %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000 ;B
      6  23cd
      7  23cd							;--------------------------------------------------------------------------
      0  23cd					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL2", LINES_PER_CHAR
     10  23cd					      LIST	ON
      9  23cd				   CHARACTERSHAPE_WALL2
     10  23cd		       00 dd dd 00*	      .byte.b	%00000000,%11011101,%11011101,%00000000,%01110111,%01110111,%01110111	;R
     11  23d4		       dd dd dd 00*	      .byte.b	%11011101,%11011101,%11011101,%00000000,%01110111,%01110111,%01110111	;G
     12  23db		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;,%0 ;B
     13  23e2
     14  23e2							;--------------------------------------------------------------------------
     15  23e2							;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_WALL1", LINES_PER_CHAR
     16  23e2				   CHARACTERSHAPE_WALL1
     17  23e2		       00 bb bb 00*	      .byte.b	%00000000,%10111011,%10111011,%00000000,%11101110,%11101110,%11101110	;R
     18  23e9		       bb bb bb 00*	      .byte.b	%10111011,%10111011,%10111011,%00000000,%11101110,%11101110,%11101110	;G
     19  23f0		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     20  23f7
      0  23f7					      CHECKPAGE	CHARACTERSHAPE_WALL2	; since we share one byte!
      8  23f7					      LIST	ON
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    532  23f7
      0  23f7					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  23f7
      2  23f7
      3  23f7		       03 f7	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $3f7 , FREE= $9
      4  23f7					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  23f7				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  23f7				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  23f7				  -	      ERR
      8  23f7					      endif
    534  23f7
    535  23f7							;------------------------------------------------------------------------------
    536  23f7
    537  23f7							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    538  23f7
    539  23f7							;------------------------------------------------------------------------------
    540  23f7
    541  23f7
    542  23f7
    543  23f7							;	 CHECK_HALF_BANK_SIZE "ROM_SHADOW_OF_RAMBANK_CODE"
    544  23f7
    545  23f7
    546  23f7							; Here there's another 1K of usable ROM....
    547  23f7							; BUT!!! WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    548  23f7
    549  23f7							;-----------------------------------------------------------
    550  23f7							; Stella 3E autodetect signature, can live anywhere
    551  23f7		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
    552  23fb							;-----------------------------------------------------------
------- FILE CaveBank2.asm LEVEL 3 PASS 3
      0  23fb					      include	"CaveBank2.asm"
      1  23fb							; Cave definitions
      2  23fb
      3  23fb
      4  23fb							;------------------------------------------------------------------------------
      5  23fb							;##############################################################################
      6  23fb							;------------------------------------------------------------------------------
      7  23fb
      8  23fb							;IFCONST CAVE_NAMED_FUNNEL
      0  23fb					      START_CAVE	FUNNEL
      1  23fb				   CAVE_START SET	*
      2  23fb		       00 04	   BANK_CAVE_FUNNEL =	_CURRENT_BANK
      3  23fb				   CAVE_FUNNEL SUBROUTINE
      4  23fb				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  23fb
     10  23fb
     11  23fb		       0f		      .byte.b	$0F	; Cave 15 O
      0  23fc					      CAVE_SIZE_ROOM		; width, height
      0  23fc					      CAVE_SIZE	40, 22
      1  23fc		       28 16		      .byte.b	40,22
     13  23fe		       08		      .byte.b	$08	; Magic wall/amoeba slow growth for: 8 seconds
     14  23ff		       10		      .byte.b	$10	;BCD'd $0A			    ; Diamonds worth: 10 points
     15  2400		       20		      .byte.b	$20	;BCD'd $14			    ; Extra diamonds worth: 20 points
     16  2401		       01 1d 1e 1f*	      .byte.b	$01, $1D, $1E, $1F, $20	; Randomiser seed values for difficulty levels 1-5
     17  2406		       0f 14 14 19*	      .byte.b	$0F, $14, $14, $19, $1E	; Diamonds needed: 15, 20, 20, 25, 30 (for difficulty levels 1-5)
     18  240b		       78 78 78 78*	      .byte.b	$78, $78, $78, $78, $8C	; Cave time: 120, 120, 120, 120, 140 seconds
     19  2410
     20  2410							;-------------------------------------------------------------------------------------
     21  2410							; PALETTE DEFINITIONS
     22  2410
     23  2410					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
     24  2410		       88 c6		      .byte.b	$88, $c6
     25  2412		       24 44		      .byte.b	$24, $44
     26  2414		       ee 5e		      .byte.b	$ee, $5e
     27  2416				  -	      ELSE
     28  2416				  -
     29  2416				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
     30  2416				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
     31  2416				  -	      IF	AD_MODE
     32  2416				  -	      .byte	$88, $c6
     33  2416				  -	      .byte	$24, $44
     34  2416				  -	      .byte	$ee, $5e
     35  2416				  -	      ENDIF
     36  2416				  -
     37  2416				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
     38  2416				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
     39  2416				  -	      IF	TJ_MODE
     40  2416				  -	      .byte	$88, $c6
     41  2416				  -	      .byte	$24, $44
     42  2416				  -	      .byte	$ee, $5e
     43  2416				  -	      ENDIF
     44  2416				  -
     45  2416					      ENDIF
     46  2416
     47  2416							;-------------------------------------------------------------------------------------
     48  2416
     49  2416
     50  2416		       00 02 09 00	      .byte.b	$00, CHARACTER_BOULDER, CHARACTER_FIREFLY, $00	; Random objects:
     51  241a		       64 50 02 00	      .byte.b	$64, $50, $02, $00	;   zSpace : 100/256 = 39%
     52  241e							;   zBouS  :  80/256 = 31%
     53  241e							;   zFFly1 :	2/256 =  0%
     54  241e							;   fourth code unused (0%)
     55  241e
     56  241e		       50 02 04 0a*	      .byte.b	LINE+CHARACTER_WALL, $02, $04, $0A, $03	; Line of zBrick from ( 2, 4); length = 10; direction = down/right
     57  2423		       50 0f 0d 0a*	      .byte.b	LINE+CHARACTER_WALL, $0F, $0D, $0A, $01	; Line of zBrick from (15,13); length = 10; direction = up/right
     58  2428		       41 0c 0e 03*	      .byte.b	LINE+CHARACTER_SOIL, $0C, $0E, $03, $02	; Line of zDirt from (12,14); length = 3; direction = right
     59  242d		       4b 0c 0f 03*	      .byte.b	LINE+CHARACTER_WALL0, $0C, $0F, $03, $02	; Line of zMagic from (12,15); length = 3; direction = right
     60  2432		       11 14 16 	      .byte.b	CHARACTER_EXITDOOR, $14, $16	; StoreChar zPreOut at (20,22)
     61  2435		       06 14 03 	      .byte.b	CHARACTER_MANOCCUPIED, $14, $03	; StoreChar zPRFd1 at (20, 3)
     62  2438
      0  2438					      END_CAVE	FUNNEL
      1  2438		       ff		      .byte.b	$FF
      2  2438		       00 3e	   CAVE_SIZE_FUNNEL =	* - CAVE_START
      3  2439					      IF	CAVE_SIZE_FUNNEL > MAX_CAVE_SIZE
      4  2439				   MAX_CAVE_SIZE SET	CAVE_SIZE_FUNNEL
      5  2439					      ENDIF
     64  2439							;ENDIF
     65  2439
     66  2439							;------------------------------------------------------------------------------
     67  2439
     68  2439					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
     69  2439
      0  2439					      START_CAVE	INTERMISSION_4
      1  2439				   CAVE_START SET	*
      2  2439		       00 04	   BANK_CAVE_INTERMISSION_4 =	_CURRENT_BANK
      3  2439				   CAVE_INTERMISSION_4 SUBROUTINE
      4  2439				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2439
     71  2439
     72  2439		       14		      .byte.b	$14	; Cave 20
      0  243a					      CAVE_SIZE_INTERMISSION		; width, height
      0  243a					      CAVE_SIZE	20, 12
      1  243a		       14 0c		      .byte.b	20,12
     74  243c		       03		      .byte.b	$03	; Magic wall/amoeba slow growth for: 3 seconds
     75  243d		       30		      .byte.b	$30	;BCD'd $1E			    ; Diamonds worth: 30 points
     76  243e		       00		      .byte.b	$00	; Extra diamonds worth: 0 points
     77  243f		       00 00 00 00*	      .byte.b	$00, $00, $00, $00, $00	; Randomiser seed values for difficulty levels 1-5
     78  2444		       06 06 06 06*	      .byte.b	$06, $06, $06, $06, $06	; Diamonds needed: 6, 6, 6, 6, 6 (for difficulty levels 1-5)
     79  2449		       14 14 14 14*	      .byte.b	$14, $14, $14, $14, $14	; Cave time: 20, 20, 20, 20, 20 seconds
     80  244e
     81  244e							;-------------------------------------------------------------------------------------
     82  244e							; PALETTE DEFINITIONS
     83  244e
     84  244e					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
     85  244e		       28 48		      .byte.b	$28, $48
     86  2450		       a6 b6		      .byte.b	$a6, $b6
     87  2452		       0e 0e		      .byte.b	$0e, $0e
     88  2454				  -	      ELSE
     89  2454				  -
     90  2454				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
     91  2454				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
     92  2454				  -	      IF	AD_MODE
     93  2454				  -	      .byte	$28, $48
     94  2454				  -	      .byte	$a6, $b6
     95  2454				  -	      .byte	$0e, $0e
     96  2454				  -	      ENDIF
     97  2454				  -
     98  2454				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
     99  2454				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    100  2454				  -	      IF	TJ_MODE
    101  2454				  -	      .byte	$28, $48
    102  2454				  -	      .byte	$a6, $b6
    103  2454				  -	      .byte	$0e, $0e
    104  2454				  -	      ENDIF
    105  2454				  -
    106  2454					      ENDIF
    107  2454
    108  2454							;-------------------------------------------------------------------------------------
    109  2454
    110  2454
    111  2454
    112  2454							; ENDIF
    113  2454
    114  2454		       00 00 00 00	      .byte.b	$00, $00, $00, $00	; Random objects:
    115  2458		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
    116  245c							;   second code unused (0%)
    117  245c							;   third code unused (0%)
    118  245c							;   fourth code unused (0%)
    119  245c
    120  245c							;   superfluous due to limited cave size
    121  245c							;    .byte   FILL+CHARACTER_STEEL, $00, $02, $28, $16, CHARACTER_STEEL; FilledRect of zSteel from ( 0, 2); length = 40; height = 22; fill = zSteel
    122  245c		       8f 00 02 14*	      .byte.b	FILL+CHARACTER_STEEL, $00, $02, $14, $0C, CHARACTER_SOIL	; FilledRect of zSteel from ( 0, 2); length = 20; height = 12; fill = zDirt
    123  2462		       c2 0b 03 03*	      .byte.b	RECT+CHARACTER_BOULDER, $0B, $03, $03, $02	; Rect of zBouS from (11, 3); length = 3; height = 2
    124  2467		       80 0b 07 03*	      .byte.b	FILL+CHARACTER_BLANK, $0B, $07, $03, $06, CHARACTER_BLANK	; FilledRect of zSpace from (11, 7); length = 3; height = 6; fill = zSpace
    125  246d		       4b 0b 06 03*	      .byte.b	LINE+CHARACTER_WALL0, $0B, $06, $03, $02	; Line of zMagic from (11, 6); length = 3; direction = right
    126  2472		       4b 0b 0a 03*	      .byte.b	LINE+CHARACTER_WALL0, $0B, $0A, $03, $02	; Line of zMagic from (11,10); length = 3; direction = right
    127  2477		       42 08 07 03*	      .byte.b	LINE+CHARACTER_BOULDER, $08, $07, $03, $03	; Line of zBouS from ( 8, 7); length = 3; direction = down/right
    128  247c		       06 03 03 	      .byte.b	CHARACTER_MANOCCUPIED, $03, $03	; StoreChar zPRFd1 at ( 3, 3)
    129  247f		       11 09 0a 	      .byte.b	CHARACTER_EXITDOOR, $09, $0A	; StoreChar zPreOut at ( 9,10)
    130  2482
      0  2482					      END_CAVE	INTERMISSION_4
      1  2482		       ff		      .byte.b	$FF
      2  2482		       00 4a	   CAVE_SIZE_INTERMISSION_4 =	* - CAVE_START
      3  2483					      IF	CAVE_SIZE_INTERMISSION_4 > MAX_CAVE_SIZE
      4  2483				   MAX_CAVE_SIZE SET	CAVE_SIZE_INTERMISSION_4
      5  2483					      ENDIF
    132  2483
    133  2483							;------------------------------------------------------------------------------
    134  2483
    135  2483					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2483					      START_CAVE	GUARDS
      1  2483				   CAVE_START SET	*
      2  2483		       00 04	   BANK_CAVE_GUARDS =	_CURRENT_BANK
      3  2483				   CAVE_GUARDS SUBROUTINE
      4  2483				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2483
    137  2483
    138  2483		       05		      .byte.b	$05	; Cave 05 E
      0  2484					      CAVE_SIZE_ROOM		; width, height
      0  2484					      CAVE_SIZE	40, 22
      1  2484		       28 16		      .byte.b	40,22
    140  2486		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    141  2487		       50		      .byte.b	$50	;BCD'd $32			    ; Diamonds worth: 50 points
    142  2488		       90		      .byte.b	$90	;BCD'd $5A			    ; Extra diamonds worth: 90 points
    143  2489		       00 00 00 00*	      .byte.b	$00, $00, $00, $00, $00	; Randomiser seed values for difficulty levels 1-5
    144  248e		       04 05 06 07*	      .byte.b	$04, $05, $06, $07, $08	; Diamonds needed: 4, 5, 6, 7, 8 (for difficulty levels 1-5)
    145  2493		       96 78 5a 3c*	      .byte.b	$96, $78, $5A, $3C, $1E	; Cave time: 150, 120, 90, 60, 30 seconds
    146  2498
    147  2498							;-------------------------------------------------------------------------------------
    148  2498							; PALETTE DEFINITIONS
    149  2498
    150  2498					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    151  2498		       48 68		      .byte.b	$48, $68	; NTSC/PAL
    152  249a		       24 46		      .byte.b	$24, $46	; NTSC/PAL
    153  249c		       ae be		      .byte.b	$ae, $be	; NTSC/PAL
    154  249e				  -	      ELSE
    155  249e				  -
    156  249e				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    157  249e				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    158  249e				  -	      IF	AD_MODE
    159  249e				  -			;good
    160  249e				  -			;	  .byte   $e8, $38
    161  249e				  -			;	  .byte   $58, $86
    162  249e				  -			;	  .byte   $ca, $5a
    163  249e				  -	      .byte	$26, $68
    164  249e				  -	      .byte	$04, $24
    165  249e				  -	      .byte	$9e, $0e
    166  249e				  -	      ENDIF
    167  249e				  -
    168  249e				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    169  249e				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    170  249e				  -	      IF	TJ_MODE
    171  249e				  -	      .byte	$48, $68
    172  249e				  -	      .byte	$24, $46
    173  249e				  -	      .byte	$ae, $9e
    174  249e				  -	      ENDIF
    175  249e				  -
    176  249e					      ENDIF
    177  249e
    178  249e							;-------------------------------------------------------------------------------------
    179  249e
    180  249e		       00 00 00 00	      .byte.b	$00, $00, $00, $00	; Random objects:
    181  24a2		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
    182  24a6							;   second code unused (0%)
    183  24a6							;   third code unused (0%)
    184  24a6							;   fourth code unused (0%)
    185  24a6
    186  24a6		       06 01 03 	      .byte.b	CHARACTER_MANOCCUPIED, $01, $03	; StoreChar zPRFd1 at ( 1, 3)
    187  24a9		       11 27 16 	      .byte.b	CHARACTER_EXITDOOR, $27, $16	; StoreChar zPreOut at (39,22)
    188  24ac		       80 08 0a 03*	      .byte.b	FILL+CHARACTER_BLANK, $08, $0A, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from ( 8,10); length = 3; height = 3; fill = zSpace
    189  24b2		       80 10 0a 03*	      .byte.b	FILL+CHARACTER_BLANK, $10, $0A, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from (16,10); length = 3; height = 3; fill = zSpace
    190  24b8		       80 18 0a 03*	      .byte.b	FILL+CHARACTER_BLANK, $18, $0A, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from (24,10); length = 3; height = 3; fill = zSpace
    191  24be		       80 20 0a 03*	      .byte.b	FILL+CHARACTER_BLANK, $20, $0A, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from (32,10); length = 3; height = 3; fill = zSpace
    192  24c4		       04 09 0c 	      .byte.b	CHARACTER_DIAMOND, $09, $0C	; StoreChar zDiaS at ( 9,12)
    193  24c7		       09 0a 0a 	      .byte.b	CHARACTER_FIREFLY, $0A, $0A	; StoreChar zFFly1 at (10,10)
    194  24ca		       04 11 0c 	      .byte.b	CHARACTER_DIAMOND, $11, $0C	; StoreChar zDiaS at (17,12)
    195  24cd		       09 12 0a 	      .byte.b	CHARACTER_FIREFLY, $12, $0A	; StoreChar zFFly1 at (18,10)
    196  24d0		       04 19 0c 	      .byte.b	CHARACTER_DIAMOND, $19, $0C	; StoreChar zDiaS at (25,12)
    197  24d3		       09 1a 0a 	      .byte.b	CHARACTER_FIREFLY, $1A, $0A	; StoreChar zFFly1 at (26,10)
    198  24d6		       04 21 0c 	      .byte.b	CHARACTER_DIAMOND, $21, $0C	; StoreChar zDiaS at (33,12)
    199  24d9		       09 22 0a 	      .byte.b	CHARACTER_FIREFLY, $22, $0A	; StoreChar zFFly1 at (34,10)
    200  24dc		       80 08 10 03*	      .byte.b	FILL+CHARACTER_BLANK, $08, $10, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from ( 8,16); length = 3; height = 3; fill = zSpace
    201  24e2		       80 10 10 03*	      .byte.b	FILL+CHARACTER_BLANK, $10, $10, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from (16,16); length = 3; height = 3; fill = zSpace
    202  24e8		       80 18 10 03*	      .byte.b	FILL+CHARACTER_BLANK, $18, $10, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from (24,16); length = 3; height = 3; fill = zSpace
    203  24ee		       80 20 10 03*	      .byte.b	FILL+CHARACTER_BLANK, $20, $10, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from (32,16); length = 3; height = 3; fill = zSpace
    204  24f4		       04 09 12 	      .byte.b	CHARACTER_DIAMOND, $09, $12	; StoreChar zDiaS at ( 9,18)
    205  24f7		       09 0a 10 	      .byte.b	CHARACTER_FIREFLY, $0A, $10	; StoreChar zFFly1 at (10,16)
    206  24fa		       04 11 12 	      .byte.b	CHARACTER_DIAMOND, $11, $12	; StoreChar zDiaS at (17,18)
    207  24fd		       09 12 10 	      .byte.b	CHARACTER_FIREFLY, $12, $10	; StoreChar zFFly1 at (18,16)
    208  2500		       04 19 12 	      .byte.b	CHARACTER_DIAMOND, $19, $12	; StoreChar zDiaS at (25,18)
    209  2503		       09 1a 10 	      .byte.b	CHARACTER_FIREFLY, $1A, $10	; StoreChar zFFly1 at (26,16)
    210  2506		       04 21 12 	      .byte.b	CHARACTER_DIAMOND, $21, $12	; StoreChar zDiaS at (33,18)
    211  2509		       09 22 10 	      .byte.b	CHARACTER_FIREFLY, $22, $10	; StoreChar zFFly1 at (34,16)
    212  250c
    213  250c							;    .byte   LINE+CHARACTER_WALL, $09, $10, $1E, $02	 ; Line of zBrick from ( 9,16); length = 30; direction = right
    214  250c
      0  250c					      END_CAVE	GUARDS
      1  250c		       ff		      .byte.b	$FF
      2  250c		       00 8a	   CAVE_SIZE_GUARDS =	* - CAVE_START
      3  250d					      IF	CAVE_SIZE_GUARDS > MAX_CAVE_SIZE
      4  250d				   MAX_CAVE_SIZE SET	CAVE_SIZE_GUARDS
      5  250d					      ENDIF
    216  250d					      ENDIF
    217  250d
    218  250d							;------------------------------------------------------------------------------
    219  250d
    220  250d					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  250d					      START_CAVE	FIREFLY_DENS
      1  250d				   CAVE_START SET	*
      2  250d		       00 04	   BANK_CAVE_FIREFLY_DENS =	_CURRENT_BANK
      3  250d				   CAVE_FIREFLY_DENS SUBROUTINE
      4  250d				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  250d
    222  250d
    223  250d		       06		      .byte.b	$06	; Cave 06 F
      0  250e					      CAVE_SIZE_ROOM		; width, height
      0  250e					      CAVE_SIZE	40, 22
      1  250e		       28 16		      .byte.b	40,22
    225  2510		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    226  2511		       40		      .byte.b	$40	;BCD'd $28			    ; Diamonds worth: 40 points
    227  2512		       60		      .byte.b	$60	;BCD'd $3C			    ; Extra diamonds worth: 60 points
    228  2513		       00 14 15 16*	      .byte.b	$00, $14, $15, $16, $17	; Randomiser seed values for difficulty levels 1-5
    229  2518		       04 06 07 08*	      .byte.b	$04, $06, $07, $08, $08	; Diamonds needed: 4, 6, 7, 8, 8 (for difficulty levels 1-5)
    230  251d		       96 78 64 5a*	      .byte.b	$96, $78, $64, $5A, $50	; Cave time: 150, 120, 100, 90, 80 seconds
    231  2522
    232  2522							;-------------------------------------------------------------------------------------
    233  2522							; PALETTE DEFINITIONS
    234  2522
    235  2522					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    236  2522		       26 48		      .byte.b	$26, $48
    237  2524		       78 a4		      .byte.b	$78, $a4
    238  2526		       de 5e		      .byte.b	$de, $5e
    239  2528				  -	      ELSE
    240  2528				  -
    241  2528				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    242  2528				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    243  2528				  -	      IF	AD_MODE
    244  2528				  -	      .byte	$26, $48
    245  2528				  -	      .byte	$78, $a4
    246  2528				  -	      .byte	$de, $5e
    247  2528				  -	      ENDIF
    248  2528				  -
    249  2528				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    250  2528				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    251  2528				  -	      IF	TJ_MODE
    252  2528				  -	      .byte	$26, $48
    253  2528				  -	      .byte	$78, $a4
    254  2528				  -	      .byte	$de, $5e
    255  2528				  -	      ENDIF
    256  2528				  -
    257  2528					      ENDIF
    258  2528
    259  2528							;-------------------------------------------------------------------------------------
    260  2528
    261  2528		       02 00 00 00	      .byte.b	CHARACTER_BOULDER, $00, $00, $00	; Random objects:
    262  252c		       32 00 00 00	      .byte.b	$32, $00, $00, $00	;   zBouS  :  50/256 = 19%
    263  2530							;   second code unused (0%)
    264  2530							;   third code unused (0%)
    265  2530							;   fourth code unused (0%)
    266  2530
    267  2530		       90 01 03 0a*	      .byte.b	FILL+CHARACTER_WALL, $01, $03, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from ( 1, 3); length = 10; height = 4; fill = zSpace
    268  2536		       90 01 06 0a*	      .byte.b	FILL+CHARACTER_WALL, $01, $06, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from ( 1, 6); length = 10; height = 4; fill = zSpace
    269  253c		       90 01 09 0a*	      .byte.b	FILL+CHARACTER_WALL, $01, $09, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from ( 1, 9); length = 10; height = 4; fill = zSpace
    270  2542		       90 01 0c 0a*	      .byte.b	FILL+CHARACTER_WALL, $01, $0C, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from ( 1,12); length = 10; height = 4; fill = zSpace
    271  2548		       41 0a 03 0d*	      .byte.b	LINE+CHARACTER_SOIL, $0A, $03, $0D, $04	; Line of zDirt from (10, 3); length = 13; direction = down
    272  254d		       04 03 05 	      .byte.b	CHARACTER_DIAMOND, $03, $05	; StoreChar zDiaS at ( 3, 5)
    273  2550		       09 04 05 	      .byte.b	CHARACTER_FIREFLY, $04, $05	; StoreChar zFFly1 at ( 4, 5)
    274  2553		       04 03 08 	      .byte.b	CHARACTER_DIAMOND, $03, $08	; StoreChar zDiaS at ( 3, 8)
    275  2556		       09 04 08 	      .byte.b	CHARACTER_FIREFLY, $04, $08	; StoreChar zFFly1 at ( 4, 8)
    276  2559		       04 03 0b 	      .byte.b	CHARACTER_DIAMOND, $03, $0B	; StoreChar zDiaS at ( 3,11)
    277  255c		       09 04 0b 	      .byte.b	CHARACTER_FIREFLY, $04, $0B	; StoreChar zFFly1 at ( 4,11)
    278  255f		       04 03 0e 	      .byte.b	CHARACTER_DIAMOND, $03, $0E	; StoreChar zDiaS at ( 3,14)
    279  2562		       09 04 0e 	      .byte.b	CHARACTER_FIREFLY, $04, $0E	; StoreChar zFFly1 at ( 4,14)
    280  2565		       90 1d 03 0a*	      .byte.b	FILL+CHARACTER_WALL, $1D, $03, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from (29, 3); length = 10; height = 4; fill = zSpace
    281  256b		       90 1d 06 0a*	      .byte.b	FILL+CHARACTER_WALL, $1D, $06, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from (29, 6); length = 10; height = 4; fill = zSpace
    282  2571		       90 1d 09 0a*	      .byte.b	FILL+CHARACTER_WALL, $1D, $09, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from (29, 9); length = 10; height = 4; fill = zSpace
    283  2577		       90 1d 0c 0a*	      .byte.b	FILL+CHARACTER_WALL, $1D, $0C, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from (29,12); length = 10; height = 4; fill = zSpace
    284  257d		       41 1d 03 0d*	      .byte.b	LINE+CHARACTER_SOIL, $1D, $03, $0D, $04	; Line of zDirt from (29, 3); length = 13; direction = down
    285  2582		       04 24 05 	      .byte.b	CHARACTER_DIAMOND, $24, $05	; StoreChar zDiaS at (36, 5)
    286  2585		       09 23 05 	      .byte.b	CHARACTER_FIREFLY, $23, $05	; StoreChar zFFly1 at (35, 5)
    287  2588		       04 24 08 	      .byte.b	CHARACTER_DIAMOND, $24, $08	; StoreChar zDiaS at (36, 8)
    288  258b		       09 23 08 	      .byte.b	CHARACTER_FIREFLY, $23, $08	; StoreChar zFFly1 at (35, 8)
    289  258e		       04 24 0b 	      .byte.b	CHARACTER_DIAMOND, $24, $0B	; StoreChar zDiaS at (36,11)
    290  2591		       09 23 0b 	      .byte.b	CHARACTER_FIREFLY, $23, $0B	; StoreChar zFFly1 at (35,11)
    291  2594		       04 24 0e 	      .byte.b	CHARACTER_DIAMOND, $24, $0E	; StoreChar zDiaS at (36,14)
    292  2597		       09 23 0e 	      .byte.b	CHARACTER_FIREFLY, $23, $0E	; StoreChar zFFly1 at (35,14)
    293  259a		       06 03 14 	      .byte.b	CHARACTER_MANOCCUPIED, $03, $14	; StoreChar zPRFd1 at ( 3,20)
    294  259d		       11 26 14 	      .byte.b	CHARACTER_EXITDOOR, $26, $14	; StoreChar zPreOut at (38,20)
    295  25a0
      0  25a0					      END_CAVE	FIREFLY_DENS
      1  25a0		       ff		      .byte.b	$FF
      2  25a0		       00 94	   CAVE_SIZE_FIREFLY_DENS =	* - CAVE_START
      3  25a1					      IF	CAVE_SIZE_FIREFLY_DENS > MAX_CAVE_SIZE
      4  25a1				   MAX_CAVE_SIZE SET	CAVE_SIZE_FIREFLY_DENS
      5  25a1					      ENDIF
    297  25a1					      ENDIF
    298  25a1
    299  25a1							;------------------------------------------------------------------------------
    300  25a1
    301  25a1					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  25a1					      START_CAVE	AMOEBA
      1  25a1				   CAVE_START SET	*
      2  25a1		       00 04	   BANK_CAVE_AMOEBA =	_CURRENT_BANK
      3  25a1				   CAVE_AMOEBA SUBROUTINE
      4  25a1				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  25a1
    303  25a1
    304  25a1		       07		      .byte.b	$07	; Cave 07 G
      0  25a2					      CAVE_SIZE_ROOM		; width, height
      0  25a2					      CAVE_SIZE	40, 22
      1  25a2		       28 16		      .byte.b	40,22
    306  25a4		       4b		      .byte.b	$4B	; Magic wall/amoeba slow growth for: 75 seconds
    307  25a5		       10		      .byte.b	$10	;BCD'd $0A			    ; Diamonds worth: 10 points
    308  25a6		       20		      .byte.b	$20	;BCD'd $14			    ; Extra diamonds worth: 20 points
    309  25a7		       02 07 08 0a*	      .byte.b	$02, $07, $08, $0A, $09	; Randomiser seed values for difficulty levels 1-5
    310  25ac		       0f 14 19 19*	      .byte.b	$0F, $14, $19, $19, $19	; Diamonds needed: 15, 20, 25, 25, 25 (for difficulty levels 1-5)
    311  25b1		       78 78 78 78*	      .byte.b	$78, $78, $78, $78, $78	; Cave time: 120, 120, 120, 120, 120 seconds
    312  25b6
    313  25b6							;-------------------------------------------------------------------------------------
    314  25b6							; PALETTE DEFINITIONS
    315  25b6
    316  25b6					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    317  25b6		       48 68		      .byte.b	$48, $68
    318  25b8		       04 06		      .byte.b	$04, $06
    319  25ba		       c8 5a		      .byte.b	$c8, $5a
    320  25bc				  -	      ELSE
    321  25bc				  -
    322  25bc				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    323  25bc				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    324  25bc				  -	      IF	AD_MODE
    325  25bc				  -	      .byte	$48, $66
    326  25bc				  -	      .byte	$04, $04
    327  25bc				  -	      .byte	$c8, $58
    328  25bc				  -	      ENDIF
    329  25bc				  -
    330  25bc				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    331  25bc				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    332  25bc				  -	      IF	TJ_MODE
    333  25bc				  -	      .byte	$4a, $68
    334  25bc				  -	      .byte	$26, $24
    335  25bc				  -	      .byte	$d8, $7a
    336  25bc				  -	      ENDIF
    337  25bc				  -
    338  25bc					      ENDIF
    339  25bc
    340  25bc							;-------------------------------------------------------------------------------------
    341  25bc							;
    342  25bc
    343  25bc		       00		      .byte.b	CHARACTER_BLANK	; Random objects:
    344  25bd		       02		      .byte.b	CHARACTER_BOULDER
    345  25be		       09		      .byte.b	CHARACTER_FIREFLY
    346  25bf		       00		      .byte.b	0	; unused
    347  25c0		       64 28 02 00	      .byte.b	$64, $28, $02, $00	;   zSpace : 100/256 = 39%
    348  25c4							;   zBouS  :  40/256 = 15%
    349  25c4							;   zFFly1 :	2/256 =  0%
    350  25c4							;   fourth code unused (0%)
    351  25c4
    352  25c4		       50 01 07 0c*	      .byte.b	LINE+CHARACTER_WALL, $01, $07, $0C, $02	; Line of zBrick from ( 1, 7); length = 12; direction = right
    353  25c9		       50 1c 05 0b*	      .byte.b	LINE+CHARACTER_WALL, $1C, $05, $0B, $02	; Line of zBrick from (28, 5); length = 11; direction = right
    354  25ce		       43 13 15 02*	      .byte.b	LINE+CHARACTER_AMOEBA, $13, $15, $02, $02	; Line of zAmoe from (19,21); length = 2; direction = right
    355  25d3		       04 04 06 	      .byte.b	CHARACTER_DIAMOND, $04, $06	; StoreChar zDiaS at ( 4, 6)
    356  25d6		       04 04 0e 	      .byte.b	CHARACTER_DIAMOND, $04, $0E	; StoreChar zDiaS at ( 4,14)
    357  25d9		       04 04 16 	      .byte.b	CHARACTER_DIAMOND, $04, $16	; StoreChar zDiaS at ( 4,22)
    358  25dc		       04 22 04 	      .byte.b	CHARACTER_DIAMOND, $22, $04	; StoreChar zDiaS at (34, 4)
    359  25df		       04 22 0c 	      .byte.b	CHARACTER_DIAMOND, $22, $0C	; StoreChar zDiaS at (34,12)
    360  25e2		       04 22 16 	      .byte.b	CHARACTER_DIAMOND, $22, $16	; StoreChar zDiaS at (34,22)
    361  25e5		       06 14 06 	      .byte.b	CHARACTER_MANOCCUPIED, $14, $06	; StoreChar zPRFd1 at (20, 3)
    362  25e8		       11 27 07 	      .byte.b	CHARACTER_EXITDOOR, $27, $07	; StoreChar zPreOut at (39, 7)
    363  25eb
      0  25eb					      END_CAVE	AMOEBA
      1  25eb		       ff		      .byte.b	$FF
      2  25eb		       00 4b	   CAVE_SIZE_AMOEBA =	* - CAVE_START
      3  25ec				  -	      IF	CAVE_SIZE_AMOEBA > MAX_CAVE_SIZE
      4  25ec				  -MAX_CAVE_SIZE SET	CAVE_SIZE_AMOEBA
      5  25ec					      ENDIF
    365  25ec					      ENDIF
    366  25ec
    367  25ec							;------------------------------------------------------------------------------
    368  25ec
    369  25ec					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  25ec					      START_CAVE	ENCHANTED_WALL
      1  25ec				   CAVE_START SET	*
      2  25ec		       00 04	   BANK_CAVE_ENCHANTED_WALL =	_CURRENT_BANK
      3  25ec				   CAVE_ENCHANTED_WALL SUBROUTINE
      4  25ec				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  25ec
    371  25ec
    372  25ec		       08		      .byte.b	$08	; Cave 08 H
      0  25ed					      CAVE_SIZE_ROOM		; width, height
      0  25ed					      CAVE_SIZE	40, 22
      1  25ed		       28 16		      .byte.b	40,22
    374  25ef		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    375  25f0		       10		      .byte.b	$10	;BCD'd $0A			    ; Diamonds worth: 10 points
    376  25f1		       20		      .byte.b	$20	;BCD'd $14			    ; Extra diamonds worth: 20 points
    377  25f2		       01 03 04 05*	      .byte.b	$01, $03, $04, $05, $06	; Randomiser seed values for difficulty levels 1-5
    378  25f7		       0a 0f 14 14*	      .byte.b	$0A, $0F, $14, $14, $14	; Diamonds needed: 10, 15, 20, 20, 20 (for difficulty levels 1-5)
    379  25fc		       78 6e 64 5a*	      .byte.b	$78, $6E, $64, $5A, $50	; Cave time: 120, 110, 100, 90, 80 seconds
    380  2601
    381  2601							;-------------------------------------------------------------------------------------
    382  2601							; PALETTE DEFINITIONS
    383  2601
    384  2601					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    385  2601		       98 d8		      .byte.b	$98, $d8
    386  2603		       44 66		      .byte.b	$44, $66
    387  2605		       de 3e		      .byte.b	$de, $3e
    388  2607				  -	      ELSE
    389  2607				  -
    390  2607				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    391  2607				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    392  2607				  -	      IF	AD_MODE
    393  2607				  -	      .byte	$98, $d8
    394  2607				  -	      .byte	$44, $66
    395  2607				  -	      .byte	$de, $3e
    396  2607				  -	      ENDIF
    397  2607				  -
    398  2607				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    399  2607				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    400  2607				  -	      IF	TJ_MODE
    401  2607				  -	      .byte	$98, $d8
    402  2607				  -	      .byte	$44, $66
    403  2607				  -	      .byte	$de, $3e
    404  2607				  -	      ENDIF
    405  2607				  -
    406  2607					      ENDIF
    407  2607
    408  2607							;-------------------------------------------------------------------------------------
    409  2607
    410  2607		       00 02 09 00	      .byte.b	$00, CHARACTER_BOULDER, CHARACTER_FIREFLY, $00	; Random objects:
    411  260b		       5a 32 02 00	      .byte.b	$5A, $32, $02, $00	;   zSpace :  90/256 = 35%
    412  260f							;   zBouS  :  50/256 = 19%
    413  260f							;   zFFly1 :	2/256 =  0%
    414  260f							;   fourth code unused (0%)
    415  260f		       04 04 06 	      .byte.b	CHARACTER_DIAMOND, $04, $06	; StoreChar zDiaS at ( 4, 6)
    416  2612		       04 22 04 	      .byte.b	CHARACTER_DIAMOND, $22, $04	; StoreChar zDiaS at (34, 4)
    417  2615		       04 22 0c 	      .byte.b	CHARACTER_DIAMOND, $22, $0C	; StoreChar zDiaS at (34,12)
    418  2618		       11 00 05 	      .byte.b	CHARACTER_EXITDOOR, $00, $05	; StoreChar zPreOut at ( 0, 5)
    419  261b		       06 14 03 	      .byte.b	CHARACTER_MANOCCUPIED, $14, $03	; StoreChar zPRFd1 at (20, 3)
    420  261e		       50 01 07 0c*	      .byte.b	LINE+CHARACTER_WALL, $01, $07, $0C, $02	; Line of zBrick from ( 1, 7); length = 12; direction = right
    421  2623		       50 01 0f 0c*	      .byte.b	LINE+CHARACTER_WALL, $01, $0F, $0C, $02	; Line of zBrick from ( 1,15); length = 12; direction = right
    422  2628		       50 1c 05 0b*	      .byte.b	LINE+CHARACTER_WALL, $1C, $05, $0B, $02	; Line of zBrick from (28, 5); length = 11; direction = right
    423  262d		       50 1c 0d 0b*	      .byte.b	LINE+CHARACTER_WALL, $1C, $0D, $0B, $02	; Line of zBrick from (28,13); length = 11; direction = right
    424  2632		       4b 0e 11 08*	      .byte.b	LINE+CHARACTER_WALL0, $0E, $11, $08, $02	; Line of zMagic from (14,17); length = 8; direction = right
    425  2637		       04 0c 10 	      .byte.b	CHARACTER_DIAMOND, $0C, $10	; StoreChar zDiaS at (12,16)
    426  263a		       00 0e 12 	      .byte.b	CHARACTER_BLANK, $0E, $12	; StoreChar zSpace at (14,18)
    427  263d		       04 13 12 	      .byte.b	CHARACTER_DIAMOND, $13, $12	; StoreChar zDiaS at (19,18)
    428  2640		       41 0e 0f 08*	      .byte.b	LINE+CHARACTER_SOIL, $0E, $0F, $08, $02	; Line of zDirt from (14,15); length = 8; direction = right
    429  2645
      0  2645					      END_CAVE	ENCHANTED_WALL
      1  2645		       ff		      .byte.b	$FF
      2  2645		       00 5a	   CAVE_SIZE_ENCHANTED_WALL =	* - CAVE_START
      3  2646				  -	      IF	CAVE_SIZE_ENCHANTED_WALL > MAX_CAVE_SIZE
      4  2646				  -MAX_CAVE_SIZE SET	CAVE_SIZE_ENCHANTED_WALL
      5  2646					      ENDIF
    431  2646					      ENDIF
    432  2646
    433  2646							;------------------------------------------------------------------------------
    434  2646
    435  2646					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2646					      START_CAVE	GREED
      1  2646				   CAVE_START SET	*
      2  2646		       00 04	   BANK_CAVE_GREED =	_CURRENT_BANK
      3  2646				   CAVE_GREED SUBROUTINE
      4  2646				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2646
    437  2646
    438  2646		       09		      .byte.b	$09	; Cave 09 I
      0  2647					      CAVE_SIZE_ROOM		; width, height
      0  2647					      CAVE_SIZE	40, 22
      1  2647		       28 16		      .byte.b	40,22
    440  2649		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    441  264a		       05		      .byte.b	$05	; Diamonds worth: 5 points
    442  264b		       10		      .byte.b	$10	;BCD'd $0A			    ; Extra diamonds worth: 10 points
    443  264c		       64 89 8c fb*	      .byte.b	$64, $89, $8C, $FB, $33	; Randomiser seed values for difficulty levels 1-5
    444  2651		       4b 4b 50 55*	      .byte.b	$4B, $4B, $50, $55, $5A	; Diamonds needed: 75, 75, 80, 85, 90 (for difficulty levels 1-5)
    445  2656		       96 96 82 82*	      .byte.b	$96, $96, $82, $82, $78	; Cave time: 150, 150, 130, 130, 120 seconds
    446  265b
    447  265b							;-------------------------------------------------------------------------------------
    448  265b							; PALETTE DEFINITIONS
    449  265b
    450  265b					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    451  265b		       d6 34		      .byte.b	$d6, $34
    452  265d		       88 d8		      .byte.b	$88, $d8
    453  265f		       2e 2e		      .byte.b	$2e, $2e
    454  2661				  -	      ELSE
    455  2661				  -
    456  2661				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    457  2661				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    458  2661				  -	      IF	AD_MODE
    459  2661				  -	      .byte	$d6, $34
    460  2661				  -	      .byte	$88, $d8
    461  2661				  -	      .byte	$2e, $2e
    462  2661				  -	      ENDIF
    463  2661				  -
    464  2661				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    465  2661				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    466  2661				  -	      IF	TJ_MODE
    467  2661				  -	      .byte	$d8, $78
    468  2661				  -	      .byte	$94, $d4
    469  2661				  -	      .byte	$3e, $4e
    470  2661				  -	      ENDIF
    471  2661				  -
    472  2661					      ENDIF
    473  2661
    474  2661							;-------------------------------------------------------------------------------------
    475  2661
    476  2661
    477  2661		       02 04 00 00	      .byte.b	CHARACTER_BOULDER, CHARACTER_DIAMOND, $00, $00	; Random objects:
    478  2665		       f0 78 00 00	      .byte.b	$F0, $78, $00, $00	;   zBouS  : 240/256 = 93-46%
    479  2669							;   zDiaS  : 120/256 = 46%
    480  2669							;   third code unused (0%)
    481  2669							;   fourth code unused (0%)
    482  2669
    483  2669		       90 05 0a 0d*	      .byte.b	FILL+CHARACTER_WALL, $05, $0A, $0D, $0D, CHARACTER_BLANK	; FilledRect of zBrick from ( 5,10); length = 13; height = 13; fill = zSpace
    484  266f		       01 0c 0a 	      .byte.b	CHARACTER_SOIL, $0C, $0A	; StoreChar zDirt at (12,10)
    485  2672		       90 19 0a 0d*	      .byte.b	FILL+CHARACTER_WALL, $19, $0A, $0D, $0D, CHARACTER_BLANK	; FilledRect of zBrick from (25,10); length = 13; height = 13; fill = zSpace
    486  2678		       01 1f 0a 	      .byte.b	CHARACTER_SOIL, $1F, $0A	; StoreChar zDirt at (31,10)
    487  267b		       50 11 12 09*	      .byte.b	LINE+CHARACTER_WALL, $11, $12, $09, $02	; Line of zBrick from (17,18); length = 9; direction = right
    488  2680		       40 11 13 09*	      .byte.b	LINE+CHARACTER_BLANK, $11, $13, $09, $02	; Line of zSpace from (17,19); length = 9; direction = right
    489  2685		       06 07 0c 	      .byte.b	CHARACTER_MANOCCUPIED, $07, $0C	; StoreChar zPRFd1 at ( 7,12)
    490  2688		       11 08 0c 	      .byte.b	CHARACTER_EXITDOOR, $08, $0C	; StoreChar zPreOut at ( 8,12)
    491  268b
      0  268b					      END_CAVE	GREED
      1  268b		       ff		      .byte.b	$FF
      2  268b		       00 46	   CAVE_SIZE_GREED =	* - CAVE_START
      3  268c				  -	      IF	CAVE_SIZE_GREED > MAX_CAVE_SIZE
      4  268c				  -MAX_CAVE_SIZE SET	CAVE_SIZE_GREED
      5  268c					      ENDIF
    493  268c					      ENDIF
    494  268c
    495  268c							;ECHO "MAX CAVE SIZE = ", MAX_CAVE_SIZE
    496  268c							;ECHO "MAX_CAVE_NUMBER = ", MAX_CAVE_NUMBER
    497  268c
    498  268c
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    554  268c
    555  268c
      0  268c					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  268c		       06 8c	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $68c , FREE= $174
      2  268c					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  268c				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  268c				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  268c				  -	      ERR
      6  268c					      endif
    557  268c
------- FILE ./notBoulderDash.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 3
      0  268c					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  268c							;------------------------------------------------------------------------------
      2  268c							;##############################################################################
      3  268c							;------------------------------------------------------------------------------
      4  268c
      0  268c					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  2edc ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      6  2800
      7  2800							; NOTE: Access to these buffers must NOT overlap pages...
      8  2800
      9  2800
     10  2800							; The blank stack is a stack of recently blanked-out squares.	These squares
     11  2800							; are processed to determine if any of the surrounding squares should also
     12  2800							; be processed (for example, an action causing a blank square may cause some
     13  2800							; other action in surrounding squares, a sort of chain reaction).  The blank
     14  2800							; stack is usually added to when objects move.  Objects on the blank stack
     15  2800							; are not persistant (the blanks reference squares on the board, not physical
     16  2800							; objects doing things).
     17  2800
     18  2800
     19  2800							; THe BlankStack lists can NOT overlap page boundaries. Be careful.
     20  2800		       00 80	   BLANK_STACK_MAX =	128	; may NOT be extended
     21  2800
     22  2800		       00 00 00 00*BlankStackX ds	BLANK_STACK_MAX
     23  2880		       00 00 00 00*BlankStackY ds	BLANK_STACK_MAX
     24  2900
     25  2900							; NOTE: We get auto-initialisation of these variables from the ROM values by
     26  2900							; copying the whole bank into the RAM bank.  Neato.
     27  2900
     28  2900		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     29  2900
     30  2900
     31  2900
     32  2900		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     33  2950		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     34  29a0
      0  29a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  29a0					      LIST	ON
     36  29a0
     37  29a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     38  29a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     39  29a0							; what we want to happen!
     40  29a0
     41  29a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
     42  29f0
     43  29f0
     44  29f0
     45  29f0							;------------------------------------------------------------------------------
     46  29f0							; RAM-BASED SUBROUTINES...
     47  29f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     48  29f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     49  29f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     50  29f0							; the RAM-based routine.
     51  29f0
     52  29f0
     53  29f0
     54  29f0							;------------------------------------------------------------------------------
     55  29f0
      0  29f0					      DEFINE_SUBROUTINE	InsertBlankStack	;=32(A) ; in RAM
      1  29f0		       00 05	   BANK_InsertBlankStack =	_CURRENT_BANK
      2  29f0					      SUBROUTINE
      3  29f0				   InsertBlankStack
     57  29f0
     58  29f0							; places a blank square (POS_X,POS_Y) into the blank object stack
     59  29f0
     60  29f0		       a4 8d		      ldy	BlankStackPtr	; 3
     61  29f2
     62  29f2					      if	BLANK_STACK_MAX = 128
     63  29f2		       30 0c		      bmi	BuffersFull	; 2/3
     64  29f4				  -	      else
     65  29f4				  -	      cpy	#BLANK_STACK_MAX
     66  29f4				  -	      beq	BuffersFull	; A REAL PROBLEM, BUT GRACEFULLY HANDLE IT
     67  29f4					      endif
     68  29f4
     69  29f4		       a5 90		      lda	POS_Y	; 3
     70  29f6		       99 80 f4 	      sta	BlankStackY+RAM_WRITE,y	; 5
     71  29f9		       a5 8f		      lda	POS_X	; 3
     72  29fb		       99 00 f4 	      sta	BlankStackX+RAM_WRITE,y	; 5
     73  29fe
     74  29fe		       e6 8d		      inc	BlankStackPtr	; 5
     75  2a00
     76  2a00				   waitForDraw
     77  2a00		       60	   BuffersFull rts		; 6
     78  2a01
     79  2a01							;------------------------------------------------------------------------------
     80  2a01
      0  2a01					      DEFINE_SUBROUTINE	DrawStackUpdate	;=196 (+13 for fall-through bit)
      1  2a01		       00 05	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  2a01					      SUBROUTINE
      3  2a01				   DrawStackUpdate
     82  2a01
     83  2a01							; Parse the DrawFlags buffer and create a draw stack
     84  2a01							; so that the actual draw doesn't need to scan for characters to draw.
     85  2a01
     86  2a01
     87  2a01							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     88  2a01							; symptoms would be missing parts of screen when scrolling.
     89  2a01							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     90  2a01
     91  2a01		       a5 89		      lda	DrawStackPointer
     92  2a03		       10 fb		      bpl	waitForDraw	; Wait for previously not-drawn characters to be drawn
     93  2a05
     94  2a05		       ad 84 02 	      lda	INTIM	;4
     95  2a08		       c9 05		      cmp	#SEGTIME_BDS	;2
     96  2a0a		       90 f4		      bcc	waitForDraw	;2/3
      0  2a0c					      STRESS_TIME	SEGTIME_BDS
      1  2a0c				  -	      IF	TEST_SEGTIME_BDS = 1
      2  2a0c				  -
      3  2a0c				  -
      4  2a0c				  -
      5  2a0c				  -
      6  2a0c				  -
      7  2a0c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  2a0c				  -	      bne	. - 7
      9  2a0c					      ENDIF
     98  2a0c
     99  2a0c
    100  2a0c							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
    101  2a0c							; moving into the middle of dirt, or boulders when pushing, or diamonds when grabbing.
    102  2a0c
    103  2a0c							;		  sec		 already set
    104  2a0c		       a5 a0		      lda	ManY	;3
    105  2a0e		       e5 9a		      sbc	BoardScrollY	;3
    106  2a10		       85 a2		      sta	ManDrawY	;3
    107  2a12
    108  2a12		       38		      sec		;2
    109  2a13		       a5 9f		      lda	ManX	;3
    110  2a15		       e5 9b		      sbc	BoardScrollX	;3
    111  2a17		       c9 0a		      cmp	#SCREEN_WIDTH	;2
    112  2a19		       90 06		      bcc	onsc	;2/3
    113  2a1b
    114  2a1b							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
    115  2a1b							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
    116  2a1b							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
    117  2a1b
    118  2a1b		       a9 08		      lda	#SCREEN_LINES	;2
    119  2a1d		       85 a2		      sta	ManDrawY	;3
    120  2a1f		       d0 02		      bne	skipsc	;3		  unconditional
    121  2a21
    122  2a21		       85 a1	   onsc       sta	ManDrawX	;3
    123  2a23				   skipsc
    124  2a23
    125  2a23		       e6 ae		      inc	timer	;5
    126  2a25		       4c 95 fe 	      jmp	AnimateCharReplacements2	;3+139
    127  2a28				   retAnim
    128  2a28
    129  2a28		       e6 8e		      inc	ScreenDrawPhase	;5
    130  2a2a
    131  2a2a		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
    132  2a2c		       85 de		      sta	DSL	;3
    133  2a2e
    134  2a2e							; fall through...
    135  2a2e							;---------------------------------------------------------------------------
    136  2a2e
      0  2a2e					      DEFINE_SUBROUTINE	DrawIntoStack
      1  2a2e		       00 05	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  2a2e					      SUBROUTINE
      3  2a2e				   DrawIntoStack
    138  2a2e
    139  2a2e		       ba		      tsx		;2
    140  2a2f		       86 df		      stx	save_SP	;3
    141  2a31		       a6 89		      ldx	DrawStackPointer	;3
    142  2a33		       9a		      txs		;2 = 10
    143  2a34
    144  2a34		       a4 de		      ldy	DSL	;3
    145  2a36
    146  2a36							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    147  2a36							; + exit cost which is +10 cycles
    148  2a36							; TJ: I count 63
    149  2a36							;   + 14 for the wtf2 exit
    150  2a36							;   + 22 for the end of loop exit
    151  2a36
    152  2a36							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    153  2a36							; For 80 iterations that is 640 cycles, just for checking INTIM
    154  2a36							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    155  2a36							; it also will require a lot of CPU time for updating the screen data.
    156  2a36
    157  2a36							; TODO: optimize!
    158  2a36							;
    159  2a36							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    160  2a36							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    161  2a36							; costs some detection time here, but saves ~240 cylces for drawing the two
    162  2a36
    163  2a36		       ad 84 02    .loopDrawStack lda	INTIM	;4
    164  2a39		       c9 05		      cmp	#SEGTIME_DSL	;2
    165  2a3b		       90 4d		      bcc	.exitDrawStack	;2/3= 8/9
      0  2a3d					      STRESS_TIME	SEGTIME_DSL
      1  2a3d				  -	      IF	TEST_SEGTIME_DSL = 1
      2  2a3d				  -
      3  2a3d				  -
      4  2a3d				  -
      5  2a3d				  -
      6  2a3d				  -
      7  2a3d				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  2a3d				  -	      bne	. - 7
      9  2a3d					      ENDIF
    167  2a3d
    168  2a3d		       b9 50 f1 	      lda	DrawFlag,y	;4
    169  2a40		       d9 a0 f1 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    170  2a43		       f0 16		      beq	.next0	;2/3=10/11	 yes, so we don't draw anything
    171  2a45
    172  2a45							; Character is NOT the same. Figure out how it should be drawn.
    173  2a45							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    174  2a45							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    175  2a45							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    176  2a45
    177  2a45		       be ef f2 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    178  2a48		       dd 50 f1 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    179  2a4b		       d0 05		      bne	.notPaired0	;2/3=10/11
    180  2a4d
    181  2a4d							; Consider two 'paired' characters. Either A:A or A:B
    182  2a4d							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    183  2a4d							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    184  2a4d							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    185  2a4d							; on the comparison, so the character will not be added to the draw stack. So our first character will
    186  2a4d							; do the job of drawing BOTH characters to the screen.
    187  2a4d
    188  2a4d		       9d a0 f5 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    189  2a50		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    190  2a52
    191  2a52							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    192  2a52							; the last write(below) marks the character as to be direct-drawn.
    193  2a52
    194  2a52		       99 a0 f5    .notPaired0 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    195  2a55
    196  2a55							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    197  2a55
    198  2a55		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    199  2a56		       98		      tya		;2
    200  2a57		       ba		      tsx		;2		 << now X holds drawstackpointer
    201  2a58		       9d 00 f5 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    202  2a5b
    203  2a5b		       88	   .next0     dey		;2
    204  2a5c		       30 21		      bmi	.finishedDrawStack	;2/3= 4/5
    205  2a5e
    206  2a5e							; unrolled 2nd loop:
    207  2a5e		       b9 50 f1 	      lda	DrawFlag,y	;4
    208  2a61		       d9 a0 f1 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    209  2a64		       f0 16		      beq	.next1	;2/3=10/11	 yes, so we don't draw anything
    210  2a66
    211  2a66		       be ef f2 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    212  2a69		       dd 50 f1 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    213  2a6c		       d0 05		      bne	.notPaired1	;2/3=10/11
    214  2a6e
    215  2a6e		       9d a0 f5 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    216  2a71		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    217  2a73
    218  2a73		       99 a0 f5    .notPaired1 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    219  2a76
    220  2a76		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    221  2a77		       98		      tya		;2
    222  2a78		       ba		      tsx		;2
    223  2a79		       9d 00 f5 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    224  2a7c
    225  2a7c		       88	   .next1     dey		;2
    226  2a7d		       10 b7		      bpl	.loopDrawStack	;2/3= 4/5
    227  2a7f							;worst case: 111-4
    228  2a7f							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    229  2a7f
    230  2a7f							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    231  2a7f
    232  2a7f				   .finishedDrawStack
    233  2a7f		       e6 8e		      inc	ScreenDrawPhase	;5 =  5
    234  2a81		       ba		      tsx		;2
    235  2a82		       86 89		      stx	DrawStackPointer	;3
    236  2a84		       a6 df		      ldx	save_SP	;3
    237  2a86		       9a		      txs		;2 = 10
    238  2a87
    239  2a87		       4c 84 f9 	      jmp	SwitchObjects
    240  2a8a
    241  2a8a							;rts				  ;6 =	6
    242  2a8a
    243  2a8a				   .exitDrawStack
    244  2a8a		       84 de		      sty	DSL	;3 =  3
    245  2a8c		       ba		      tsx		;2
    246  2a8d		       86 89		      stx	DrawStackPointer	;3
    247  2a8f		       a6 df		      ldx	save_SP	;3
    248  2a91		       9a		      txs		;2 = 10
    249  2a92		       60	   NoBlanks   rts		;6 =  6
    250  2a93
    251  2a93							;------------------------------------------------------------------------------
    252  2a93
      0  2a93					      DEFINE_SUBROUTINE	BlankCreatureInsertion	;=853(A)
      1  2a93		       00 05	   BANK_BlankCreatureInsertion =	_CURRENT_BANK
      2  2a93					      SUBROUTINE
      3  2a93				   BlankCreatureInsertion
    254  2a93
    255  2a93		       a4 8d		      ldy	BlankStackPtr	;3
    256  2a95		       88		      dey		;2
    257  2a96
    258  2a96							; Processes a blank stack object.
    259  2a96
    260  2a96		       b9 80 f0 	      lda	BlankStackY,y	;4
    261  2a99		       85 90		      sta	POS_Y	;3
    262  2a9b		       b9 00 f0 	      lda	BlankStackX,y	;4
    263  2a9e		       85 8f		      sta	POS_X	;3
    264  2aa0
    265  2aa0							; We have the position of a blank square on the board that has been placed onto
    266  2aa0							; the blank stack in the previous iteration.  IFF the square is still blank, then
    267  2aa0							; we check the squares immediately above and to the sides and place those object(s)
    268  2aa0							; into the object stack
    269  2aa0
    270  2aa0		       a9 00		      lda	#0	;2
    271  2aa2		       85 94		      sta	POS_VAR	;3		 for object stack insertion
    272  2aa4
    273  2aa4							;  +---+---+---+
    274  2aa4							;  | 1 | 2 | 3 |
    275  2aa4							;  +---+---+---+
    276  2aa4							;  | 0 | B | 4 |
    277  2aa4							;  +---+---+---+
    278  2aa4
    279  2aa4							; Given a position 'B', checks the surrounding squares 0-4 for objects that could
    280  2aa4							; possibly be caused to "fall" by the creation of a blank at 'B'.  These objects
    281  2aa4							; are pushed onto the object stack to let them do their stuff.
    282  2aa4
    283  2aa4		       c6 8f		      dec	POS_X	;5
    284  2aa6		       20 fd f8 	      jsr	GetBoardCharacter__CALL_FROM_RAM__	;6+61
    285  2aa9		       20 c7 f2 	      jsr	CheckIt	;6+108(A)	 @ "0"
    286  2aac
    287  2aac		       e6 8f		      inc	POS_X	;5
    288  2aae		       e6 8f		      inc	POS_X	;5
    289  2ab0		       20 c2 f2 	      jsr	CheckIt2	;6+141 	 # "4"
    290  2ab3
    291  2ab3		       c6 90		      dec	POS_Y	;5
    292  2ab5		       20 fd f8 	      jsr	GetBoardCharacter__CALL_FROM_RAM__	;6+61
    293  2ab8		       20 c7 f2 	      jsr	CheckIt	;6+110(A)	 @ "3"
    294  2abb
    295  2abb		       c6 8f		      dec	POS_X	;5
    296  2abd		       20 c2 f2 	      jsr	CheckIt2	;6+141 	 @ "2"
    297  2ac0
    298  2ac0		       c6 8f		      dec	POS_X	;5
    299  2ac2
    300  2ac2							; fall through (@ "1")
    301  2ac2
    302  2ac2				   CheckIt2		;=141
    303  2ac2
    304  2ac2		       a9 0d		      lda	#BANK_BOARD	;2			 Warning -- will not work for multiple bank board!
    305  2ac4		       20 06 f9 	      jsr	PartialGetBoardCharacter	;6+23
    306  2ac7
    307  2ac7				   CheckIt		;=110(A)
    308  2ac7
    309  2ac7		       bd 3d fe 	      lda	GenericCharFlag,x	; 4	 check char as a fallable item
    310  2aca		       10 c6		      bpl	NoBlanks	; 2/3	 NOT a fallable object!
    311  2acc
    312  2acc							; Only FALLABLE objects detected in the candidate position are added to the object list.
    313  2acc							; These objects then make their own minds up if they're ACTUALLY going to fall.
    314  2acc
    315  2acc
    316  2acc		       bd 7a fe 	      lda	CharToType,x	;4	 get type of object based on character
    317  2acf		       85 93		      sta	POS_Type	;3
    318  2ad1
    319  2ad1		       4c 74 fb 	      jmp	InsertObjectStackFromRAM	;3+94(B)
    320  2ad4
    321  2ad4							;------------------------------------------------------------------------------
    322  2ad4							; Gives character replacements used during screen drawing.
    323  2ad4							; The character from the board is morphed via this array into an actual character
    324  2ad4							; to draw.  This allows global animation and replacment of characters without
    325  2ad4							; individual objects needing to do this.  Note, the draw-time replacement happens,
    326  2ad4							; not board-time.
    327  2ad4
    328  2ad4				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    329  2ad4
    330  2ad4							; Converts a character # to an animated creature type
    331  2ad4							; The array is indexed by CHARACTER_...
    332  2ad4
    333  2ad4		       00		      .byte.b	CHARACTER_BLANK	;  0
    334  2ad5		       01		      .byte.b	CHARACTER_SOIL	;  1
    335  2ad6		       02		      .byte.b	CHARACTER_BOULDER	;  2
    336  2ad7		       03	   ANIM_AMOEBA .byte.b	CHARACTER_AMOEBA	;  3
    337  2ad8		       04	   ANIM_DIAMOND .byte.b	CHARACTER_DIAMOND	;  4
    338  2ad9		       00		      .byte.b	0	;CHARACTER_DIAMOND   ;  5
    339  2ada		       06		      .byte.b	CHARACTER_MANOCCUPIED	;  6
    340  2adb		       07	   ANIM_BUTTERFLY0 .byte.b	CHARACTER_FLUTTERBY	;  7
    341  2adc		       07	   ANIM_BUTTERFLY1 .byte.b	CHARACTER_FLUTTERBY	;  8
    342  2add		       09	   ANIM_FIREFLY0 .byte.b	CHARACTER_FIREFLY	;  9
    343  2ade		       09	   ANIM_FIREFLY1 .byte.b	CHARACTER_FIREFLY	; 0a
    344  2adf		       0b	   ANIM_MAGICWALL .byte.b	CHARACTER_WALL0	; 0b
    345  2ae0		       00		      .byte.b	0	;CHARACTER_WALL0     ; 0c
    346  2ae1		       00		      .byte.b	0	;CHARACTER_WALL0     ; 0d
    347  2ae2		       00		      .byte.b	0	;CHARACTER_WALL0     ; 0e
    348  2ae3		       0f		      .byte.b	CHARACTER_STEEL	; 0f
    349  2ae4		       10		      .byte.b	CHARACTER_WALL	; 10
    350  2ae5		       11	   ANIM_EXITDOOR .byte.b	CHARACTER_EXITDOOR	; 11
    351  2ae6		       00		      .byte.b	0	;CHARACTER_EXITDOOR  ; 12
    352  2ae7		       13		      .byte.b	CHARACTER_EXPLOSION	; 13
    353  2ae8		       14		      .byte.b	CHARACTER_EXPLOSION1	; 14
    354  2ae9		       15		      .byte.b	CHARACTER_EXPLOSION2	; 15
    355  2aea		       16		      .byte.b	CHARACTER_EXPLOSION3	; 16
    356  2aeb		       00		      .byte.b	0	;CHARACTER_AMOEBA    ; 17
    357  2aec		       02		      .byte.b	CHARACTER_BOULDER	; 18	 falling boulder
    358  2aed		       04		      .byte.b	CHARACTER_DIAMOND	; 19	 falling diamond, no anim
    359  2aee		       1a		      .byte.b	CHARACTER_NOGO	;20 the unkillable man for end of level
    360  2aef
    361  2aef				  -	      IF	* - CharReplacement < CHARACTER_MAXIMUM
    362  2aef				  -	      ECHO	"ERROR: Missing entry in CharReplacement table!"
    363  2aef				  -	      EXIT
    364  2aef					      ENDIF
      0  2aef					      CHECKPAGE	CharReplacement
      8  2aef					      LIST	ON
    366  2aef
    367  2aef							;------------------------------------------------------------------------------
    368  2aef
    369  2aef				   PairedCharacter
    370  2aef
    371  2aef				   SOFF       SET	0
    372  2aef					      REPEAT	SCREEN_LINES
    373  2aef		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  2aef				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  2aef					      REPEND
    373  2af9		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  2af9				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  2af9					      REPEND
    373  2b03		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  2b03				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  2b03					      REPEND
    373  2b0d		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  2b0d				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  2b0d					      REPEND
    373  2b17		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  2b17				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  2b17					      REPEND
    373  2b21		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  2b21				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  2b21					      REPEND
    373  2b2b		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  2b2b				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  2b2b					      REPEND
    373  2b35		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  2b35				   SOFF       SET	SOFF + SCREEN_WIDTH
    375  2b3f					      REPEND
    376  2b3f
      0  2b3f					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
     10  2b3f					      LIST	ON
      0  2b3f					      DEFINE_SUBROUTINE	ROW_BankChar
      1  2b3f		       00 05	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  2b3f					      SUBROUTINE
      3  2b3f				   ROW_BankChar
    379  2b3f
    380  2b3f				   .BANK      SET	BANK_SCREENMARKII1
    381  2b3f					      REPEAT	SCREEN_LINES
    382  2b3f					      REPEAT	SCREEN_WIDTH
    383  2b3f		       00		      .byte.b	.BANK
    382  2b3f					      REPEND
    383  2b40		       00		      .byte.b	.BANK
    382  2b40					      REPEND
    383  2b41		       00		      .byte.b	.BANK
    382  2b41					      REPEND
    383  2b42		       00		      .byte.b	.BANK
    382  2b42					      REPEND
    383  2b43		       00		      .byte.b	.BANK
    382  2b43					      REPEND
    383  2b44		       00		      .byte.b	.BANK
    382  2b44					      REPEND
    383  2b45		       00		      .byte.b	.BANK
    382  2b45					      REPEND
    383  2b46		       00		      .byte.b	.BANK
    382  2b46					      REPEND
    383  2b47		       00		      .byte.b	.BANK
    382  2b47					      REPEND
    383  2b48		       00		      .byte.b	.BANK
    384  2b49					      REPEND
    385  2b49				   .BANK      SET	.BANK + 1
    381  2b49					      REPEND
    382  2b49					      REPEAT	SCREEN_WIDTH
    383  2b49		       01		      .byte.b	.BANK
    382  2b49					      REPEND
    383  2b4a		       01		      .byte.b	.BANK
    382  2b4a					      REPEND
    383  2b4b		       01		      .byte.b	.BANK
    382  2b4b					      REPEND
    383  2b4c		       01		      .byte.b	.BANK
    382  2b4c					      REPEND
    383  2b4d		       01		      .byte.b	.BANK
    382  2b4d					      REPEND
    383  2b4e		       01		      .byte.b	.BANK
    382  2b4e					      REPEND
    383  2b4f		       01		      .byte.b	.BANK
    382  2b4f					      REPEND
    383  2b50		       01		      .byte.b	.BANK
    382  2b50					      REPEND
    383  2b51		       01		      .byte.b	.BANK
    382  2b51					      REPEND
    383  2b52		       01		      .byte.b	.BANK
    384  2b53					      REPEND
    385  2b53				   .BANK      SET	.BANK + 1
    381  2b53					      REPEND
    382  2b53					      REPEAT	SCREEN_WIDTH
    383  2b53		       02		      .byte.b	.BANK
    382  2b53					      REPEND
    383  2b54		       02		      .byte.b	.BANK
    382  2b54					      REPEND
    383  2b55		       02		      .byte.b	.BANK
    382  2b55					      REPEND
    383  2b56		       02		      .byte.b	.BANK
    382  2b56					      REPEND
    383  2b57		       02		      .byte.b	.BANK
    382  2b57					      REPEND
    383  2b58		       02		      .byte.b	.BANK
    382  2b58					      REPEND
    383  2b59		       02		      .byte.b	.BANK
    382  2b59					      REPEND
    383  2b5a		       02		      .byte.b	.BANK
    382  2b5a					      REPEND
    383  2b5b		       02		      .byte.b	.BANK
    382  2b5b					      REPEND
    383  2b5c		       02		      .byte.b	.BANK
    384  2b5d					      REPEND
    385  2b5d				   .BANK      SET	.BANK + 1
    381  2b5d					      REPEND
    382  2b5d					      REPEAT	SCREEN_WIDTH
    383  2b5d		       03		      .byte.b	.BANK
    382  2b5d					      REPEND
    383  2b5e		       03		      .byte.b	.BANK
    382  2b5e					      REPEND
    383  2b5f		       03		      .byte.b	.BANK
    382  2b5f					      REPEND
    383  2b60		       03		      .byte.b	.BANK
    382  2b60					      REPEND
    383  2b61		       03		      .byte.b	.BANK
    382  2b61					      REPEND
    383  2b62		       03		      .byte.b	.BANK
    382  2b62					      REPEND
    383  2b63		       03		      .byte.b	.BANK
    382  2b63					      REPEND
    383  2b64		       03		      .byte.b	.BANK
    382  2b64					      REPEND
    383  2b65		       03		      .byte.b	.BANK
    382  2b65					      REPEND
    383  2b66		       03		      .byte.b	.BANK
    384  2b67					      REPEND
    385  2b67				   .BANK      SET	.BANK + 1
    381  2b67					      REPEND
    382  2b67					      REPEAT	SCREEN_WIDTH
    383  2b67		       04		      .byte.b	.BANK
    382  2b67					      REPEND
    383  2b68		       04		      .byte.b	.BANK
    382  2b68					      REPEND
    383  2b69		       04		      .byte.b	.BANK
    382  2b69					      REPEND
    383  2b6a		       04		      .byte.b	.BANK
    382  2b6a					      REPEND
    383  2b6b		       04		      .byte.b	.BANK
    382  2b6b					      REPEND
    383  2b6c		       04		      .byte.b	.BANK
    382  2b6c					      REPEND
    383  2b6d		       04		      .byte.b	.BANK
    382  2b6d					      REPEND
    383  2b6e		       04		      .byte.b	.BANK
    382  2b6e					      REPEND
    383  2b6f		       04		      .byte.b	.BANK
    382  2b6f					      REPEND
    383  2b70		       04		      .byte.b	.BANK
    384  2b71					      REPEND
    385  2b71				   .BANK      SET	.BANK + 1
    381  2b71					      REPEND
    382  2b71					      REPEAT	SCREEN_WIDTH
    383  2b71		       05		      .byte.b	.BANK
    382  2b71					      REPEND
    383  2b72		       05		      .byte.b	.BANK
    382  2b72					      REPEND
    383  2b73		       05		      .byte.b	.BANK
    382  2b73					      REPEND
    383  2b74		       05		      .byte.b	.BANK
    382  2b74					      REPEND
    383  2b75		       05		      .byte.b	.BANK
    382  2b75					      REPEND
    383  2b76		       05		      .byte.b	.BANK
    382  2b76					      REPEND
    383  2b77		       05		      .byte.b	.BANK
    382  2b77					      REPEND
    383  2b78		       05		      .byte.b	.BANK
    382  2b78					      REPEND
    383  2b79		       05		      .byte.b	.BANK
    382  2b79					      REPEND
    383  2b7a		       05		      .byte.b	.BANK
    384  2b7b					      REPEND
    385  2b7b				   .BANK      SET	.BANK + 1
    381  2b7b					      REPEND
    382  2b7b					      REPEAT	SCREEN_WIDTH
    383  2b7b		       06		      .byte.b	.BANK
    382  2b7b					      REPEND
    383  2b7c		       06		      .byte.b	.BANK
    382  2b7c					      REPEND
    383  2b7d		       06		      .byte.b	.BANK
    382  2b7d					      REPEND
    383  2b7e		       06		      .byte.b	.BANK
    382  2b7e					      REPEND
    383  2b7f		       06		      .byte.b	.BANK
    382  2b7f					      REPEND
    383  2b80		       06		      .byte.b	.BANK
    382  2b80					      REPEND
    383  2b81		       06		      .byte.b	.BANK
    382  2b81					      REPEND
    383  2b82		       06		      .byte.b	.BANK
    382  2b82					      REPEND
    383  2b83		       06		      .byte.b	.BANK
    382  2b83					      REPEND
    383  2b84		       06		      .byte.b	.BANK
    384  2b85					      REPEND
    385  2b85				   .BANK      SET	.BANK + 1
    381  2b85					      REPEND
    382  2b85					      REPEAT	SCREEN_WIDTH
    383  2b85		       07		      .byte.b	.BANK
    382  2b85					      REPEND
    383  2b86		       07		      .byte.b	.BANK
    382  2b86					      REPEND
    383  2b87		       07		      .byte.b	.BANK
    382  2b87					      REPEND
    383  2b88		       07		      .byte.b	.BANK
    382  2b88					      REPEND
    383  2b89		       07		      .byte.b	.BANK
    382  2b89					      REPEND
    383  2b8a		       07		      .byte.b	.BANK
    382  2b8a					      REPEND
    383  2b8b		       07		      .byte.b	.BANK
    382  2b8b					      REPEND
    383  2b8c		       07		      .byte.b	.BANK
    382  2b8c					      REPEND
    383  2b8d		       07		      .byte.b	.BANK
    382  2b8d					      REPEND
    383  2b8e		       07		      .byte.b	.BANK
    384  2b8f					      REPEND
    385  2b8f				   .BANK      SET	.BANK + 1
    386  2b8f					      REPEND
    387  2b8f
    388  2b8f
    389  2b8f
    390  2b8f
      0  2b8f					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  2b8f
      2  2b8f
      3  2b8f		       03 8f	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $38f , FREE= $71
      4  2b8f					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  2b8f				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  2b8f				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  2b8f				  -	      ERR
      8  2b8f					      endif
    392  2b8f
    393  2b8f							; Here there is another 1K of usable ROM
    394  2b8f
      0  2b8f					      DEFINE_SUBROUTINE	MoveExit
      1  2b8f		       00 05	   BANK_MoveExit =	_CURRENT_BANK
      2  2b8f					      SUBROUTINE
      3  2b8f				   MoveExit
    396  2b8f
    397  2b8f		       24 c8		      bit	scoringFlags
    398  2b91		       10 43		      bpl	NoExitYet	; D7 (extra diamond) triggers exit open
    399  2b93
    400  2b93		       a5 b2		      lda	caveDisplay
    401  2b95		       10 1c		      bpl	lifeMaxedOut	; not a bonus level
    402  2b97		       a5 ab		      lda	MenCurrent
    403  2b99		       29 0f		      and	#$0f
    404  2b9b		       c9 09		      cmp	#9
    405  2b9d		       b0 14		      bcs	lifeMaxedOut
    406  2b9f		       e6 ab		      inc	MenCurrent
    407  2ba1
    408  2ba1							; bonus life has priority over score:
    409  2ba1		       a5 c8		      lda	scoringFlags
    410  2ba3		       29 03		      and	#DISPLAY_FLAGS
    411  2ba5		       45 c8		      eor	scoringFlags	; remove existing score mode
    412  2ba7		       09 02		      ora	#DISPLAY_LIVES	; switch to new score mode
    413  2ba9		       85 c8		      sta	scoringFlags
    414  2bab		       a9 3c		      lda	#SCORING_TIMER
    415  2bad		       85 c7		      sta	scoringTimer
    416  2baf		       a9 ff		      lda	#EXTRA_LIFE_TIMER
    417  2bb1		       85 c6		      sta	extraLifeTimer
    418  2bb3
    419  2bb3				   lifeMaxedOut
    420  2bb3
    421  2bb3		       a9 08		      lda	#MANMODE_BONUS_START
    422  2bb5		       85 a3		      sta	ManMode
    423  2bb7
    424  2bb7		       a9 05		      lda	#BANK_MoveExit
    425  2bb9		       85 c3		      sta	ROM_Bank
    426  2bbb
    427  2bbb		       20 22 fc 	      jsr	MoveNoButton2	; move man over exit door area
    428  2bbe
    429  2bbe							; Stop the sort, so it doesn't accidentally swap "in" any creatures
    430  2bbe
    431  2bbe		       a9 ff		      lda	#<(-1)
    432  2bc0		       85 d3		      sta	sortRequired
    433  2bc2		       a9 00		      lda	#0
    434  2bc4		       85 d4		      sta	sortPtr
    435  2bc6		       85 8d		      sta	BlankStackPtr	; don't allow any new objects either!
    436  2bc8
    437  2bc8							; We want *everything* to stop, but the player to keep processing
    438  2bc8							; So, kill every creature in the two object stacks, re-add the man (automatic), and continue
    439  2bc8
    440  2bc8		       a6 8a		      ldx	ObjStackNum
    441  2bca		       95 8b		      sta	ObjStackPtr,x	; =0, kill new object stack
    442  2bcc		       8a		      txa
    443  2bcd		       49 01		      eor	#1
    444  2bcf		       aa		      tax
    445  2bd0		       b5 8b		      lda	ObjStackPtr,x
    446  2bd2		       85 dd		      sta	ObjIterator	; set the iterator to the END of the current object stack so it ends
    447  2bd4
    448  2bd4							; all creatures now dead and we'll only have the (reinserted) man left
    449  2bd4
    450  2bd4		       06 b4		      asl	ThrottleSpeed	; double game loop speed
    451  2bd6
    452  2bd6		       60	   NoExitYet  rts
    453  2bd7
------- FILE CaveBank1.asm LEVEL 3 PASS 3
      0  2bd7					      include	"CaveBank1.asm"
      1  2bd7							; Cave definitions
      2  2bd7
      3  2bd7		       00 00	   .DIR_UP    =	0
      4  2bd7		       00 02	   .DIR_RIGHT =	2
      5  2bd7		       00 04	   .DIR_DOWN  =	4
      6  2bd7		       00 06	   .DIR_LEFT  =	6
      7  2bd7
      8  2bd7
      9  2bd7					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2bd7					      START_CAVE	TRACKS
      1  2bd7				   CAVE_START SET	*
      2  2bd7		       00 05	   BANK_CAVE_TRACKS =	_CURRENT_BANK
      3  2bd7				   CAVE_TRACKS SUBROUTINE
      4  2bd7				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2bd7
     11  2bd7
     12  2bd7		       0a		      .byte.b	$0A	; Cave 10 J
      0  2bd8					      CAVE_SIZE_ROOM		; width, height
      0  2bd8					      CAVE_SIZE	40, 22
      1  2bd8		       28 16		      .byte.b	40,22
     14  2bda		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
     15  2bdb		       25		      .byte.b	$25	;BCD'd $19				    ; Diamonds worth: 25 points
     16  2bdc		       60		      .byte.b	$60	;BCD'd $3C				    ; Extra diamonds worth: 60 points
     17  2bdd		       00 00 00 00*	      .byte.b	$00, $00, $00, $00, $00	; Randomiser seed values for difficulty levels 1-5
     18  2be2				  -	      IF	TEST_BONUS_COUNTDOWN = YES
     19  2be2				  -	      .byte	$01, $01, $01, $01, $01
     20  2be2					      ELSE
     21  2be2		       0c 0c 0c 0c*	      .byte.b	$0C, $0C, $0C, $0C, $0C	; Diamonds needed: 12, 12, 12, 12, 12 (for difficulty levels 1-5)
     22  2be7					      ENDIF
     23  2be7
     24  2be7
     25  2be7		       96 82 78 6e*	      .byte.b	$96, $82, $78, $6E, $64	; Cave time: 150, 130, 120, 110, 100 seconds
     26  2bec
     27  2bec
     28  2bec							;-------------------------------------------------------------------------------------
     29  2bec							; PALETTE DEFINITIONS
     30  2bec
     31  2bec					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
     32  2bec		       26 26		      .byte.b	$26, $26
     33  2bee		       76 c4		      .byte.b	$76, $c4
     34  2bf0		       be 7e		      .byte.b	$be, $7e
     35  2bf2				  -	      ELSE
     36  2bf2				  -
     37  2bf2				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
     38  2bf2				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
     39  2bf2				  -	      IF	AD_MODE
     40  2bf2				  -	      .byte	$26, $26
     41  2bf2				  -	      .byte	$76, $c4
     42  2bf2				  -	      .byte	$be, $7e
     43  2bf2				  -	      ENDIF
     44  2bf2				  -
     45  2bf2				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
     46  2bf2				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
     47  2bf2				  -	      IF	TJ_MODE
     48  2bf2				  -	      .byte	$26, $26
     49  2bf2				  -	      .byte	$76, $c4
     50  2bf2				  -	      .byte	$be, $7e
     51  2bf2				  -	      ENDIF
     52  2bf2				  -
     53  2bf2					      ENDIF
     54  2bf2
     55  2bf2							;-------------------------------------------------------------------------------------
     56  2bf2
     57  2bf2
     58  2bf2		       00 00 00 00	      .byte.b	$00, $00, $00, $00	; Random objects:
     59  2bf6		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
     60  2bfa							;   second code unused (0%)
     61  2bfa							;   third code unused (0%)
     62  2bfa							;   fourth code unused (0%)
     63  2bfa		       06 0d 03 	      .byte.b	CHARACTER_MANOCCUPIED, $0D, $03	; StoreChar zPRFd1 at (13, 3)
     64  2bfd
     65  2bfd				  -	      IF	TEST_BONUS_COUNTDOWN = YES
     66  2bfd				  -	      .byte	CHARACTER_EXITDOOR, $19, 3	; StoreChar zPreOut at (39,22)
     67  2bfd					      ELSE
     68  2bfd		       11 27 16 	      .byte.b	CHARACTER_EXITDOOR, $27, $16	; StoreChar zPreOut at (39,22)
     69  2c00					      ENDIF
     70  2c00
     71  2c00
     72  2c00
     73  2c00		       44 05 04 11*	      .byte.b	LINE+CHARACTER_DIAMOND, $05, $04, $11, $03	; Line of zDiaS from ( 5, 4); length = 17; direction = down/right
     74  2c05		       44 15 04 11*	      .byte.b	LINE+CHARACTER_DIAMOND, $15, $04, $11, $05	; Line of zDiaS from (21, 4); length = 17; direction = down/left
     75  2c0a		       80 05 0b 11*	      .byte.b	FILL+CHARACTER_BLANK, $05, $0B, $11, $03, CHARACTER_FIREFLY	; FilledRect of zSpace from ( 5,11); length = 17; height = 3; fill = zFFly1
     76  2c10		       d0 01 04 15*	      .byte.b	RECT+CHARACTER_WALL, $01, $04, $15, $11	; Rect of zBrick from ( 1, 4); length = 21; height = 17
     77  2c15		       00 0d 04 	      .byte.b	CHARACTER_BLANK, $0D, $04	; StoreChar zSpace at (13, 4)
     78  2c18		       d0 07 06 0d*	      .byte.b	RECT+CHARACTER_WALL, $07, $06, $0D, $0D	; Rect of zBrick from ( 7, 6); length = 13; height = 13
     79  2c1d		       00 0d 06 	      .byte.b	CHARACTER_BLANK, $0D, $06	; StoreChar zSpace at (13, 6)
     80  2c20		       d0 09 08 09*	      .byte.b	RECT+CHARACTER_WALL, $09, $08, $09, $09	; Rect of zBrick from ( 9, 8); length = 9; height = 9
     81  2c25		       00 0d 08 	      .byte.b	CHARACTER_BLANK, $0D, $08	; StoreChar zSpace at (13, 8)
     82  2c28		       d0 0b 0a 05*	      .byte.b	RECT+CHARACTER_WALL, $0B, $0A, $05, $05	; Rect of zBrick from (11,10); length = 5; height = 5
     83  2c2d		       00 0d 0a 	      .byte.b	CHARACTER_BLANK, $0D, $0A	; StoreChar zSpace at (13,10)
     84  2c30		       90 03 06 03*	      .byte.b	FILL+CHARACTER_WALL, $03, $06, $03, $0F, CHARACTER_FIREFLY	; FilledRect of zBrick from ( 3, 6); length = 3; height = 15; fill = zFFly1
     85  2c36		       00 04 06 	      .byte.b	CHARACTER_BLANK, $04, $06	; StoreChar zSpace at ( 4, 6)
     86  2c39		       44 04 10 04*	      .byte.b	LINE+CHARACTER_DIAMOND, $04, $10, $04, $04	; Line of zDiaS from ( 4,16); length = 4; direction = down
     87  2c3e
      0  2c3e					      END_CAVE	TRACKS
      1  2c3e		       ff		      .byte.b	$FF
      2  2c3e		       00 68	   CAVE_SIZE_TRACKS =	* - CAVE_START
      3  2c3f				  -	      IF	CAVE_SIZE_TRACKS > MAX_CAVE_SIZE
      4  2c3f				  -MAX_CAVE_SIZE SET	CAVE_SIZE_TRACKS
      5  2c3f					      ENDIF
     89  2c3f					      ENDIF
     90  2c3f
     91  2c3f							;------------------------------------------------------------------------------
     92  2c3f
     93  2c3f					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2c3f					      START_CAVE	CROWD
      1  2c3f				   CAVE_START SET	*
      2  2c3f		       00 05	   BANK_CAVE_CROWD =	_CURRENT_BANK
      3  2c3f				   CAVE_CROWD SUBROUTINE
      4  2c3f				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2c3f
     95  2c3f
     96  2c3f		       0b		      .byte.b	$0B	; Cave 11 K
      0  2c40					      CAVE_SIZE_ROOM		; width, height
      0  2c40					      CAVE_SIZE	40, 22
      1  2c40		       28 16		      .byte.b	40,22
     98  2c42		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
     99  2c43		       50		      .byte.b	$50	;BCD'd $32				    ; Diamonds worth: 50 points
    100  2c44		       00		      .byte.b	$00	; Extra diamonds worth: 0 points
    101  2c45		       00 04 66 97*	      .byte.b	$00, $04, $66, $97, $64	; Randomiser seed values for difficulty levels 1-5
    102  2c4a		       06 06 06 06*	      .byte.b	$06, $06, $06, $06, $06	; Diamonds needed: 6, 6, 6, 6, 6 (for difficulty levels 1-5)
    103  2c4f		       78 78 96 96*	      .byte.b	$78, $78, $96, $96, $F0	; Cave time: 120, 120, 150, 150, 240 seconds
    104  2c54
    105  2c54
    106  2c54							;-------------------------------------------------------------------------------------
    107  2c54							; PALETTE DEFINITIONS
    108  2c54
    109  2c54					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    110  2c54		       26 48		      .byte.b	$26, $48
    111  2c56		       04 16		      .byte.b	$04, $16
    112  2c58		       9e be		      .byte.b	$9e, $be
    113  2c5a				  -	      ELSE
    114  2c5a				  -
    115  2c5a				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    116  2c5a				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    117  2c5a				  -	      IF	AD_MODE
    118  2c5a				  -	      .byte	$26, $48
    119  2c5a				  -	      .byte	$04, $16
    120  2c5a				  -	      .byte	$9e, $be
    121  2c5a				  -	      ENDIF
    122  2c5a				  -
    123  2c5a				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    124  2c5a				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    125  2c5a				  -	      IF	TJ_MODE
    126  2c5a				  -	      .byte	$26, $48
    127  2c5a				  -	      .byte	$04, $16
    128  2c5a				  -	      .byte	$9e, $be
    129  2c5a				  -	      ENDIF
    130  2c5a				  -
    131  2c5a					      ENDIF
    132  2c5a
    133  2c5a							;-------------------------------------------------------------------------------------
    134  2c5a
    135  2c5a
    136  2c5a
    137  2c5a		       00		      .byte.b	CHARACTER_BLANK	; Random objects:
    138  2c5b		       02		      .byte.b	CHARACTER_BOULDER
    139  2c5c		       09		      .byte.b	CHARACTER_FIREFLY
    140  2c5d		       00		      .byte.b	CHARACTER_BLANK
    141  2c5e		       64 50 02 00	      .byte.b	$64, $50, $02, $00	;   zSpace : 100/256 = 39%
    142  2c62							;   zBouS  :  80/256 = 31%
    143  2c62							;   zFFly1 :	2/256 =  0%
    144  2c62							;   fourth code unused (0%)
    145  2c62		       50 0a 03 09*	      .byte.b	LINE+CHARACTER_WALL, $0A, $03, $09, $04	; Line of zBrick from (10, 3); length = 9; direction = down
    146  2c67		       50 14 03 09*	      .byte.b	LINE+CHARACTER_WALL, $14, $03, $09, $04	; Line of zBrick from (20, 3); length = 9; direction = down
    147  2c6c		       50 1e 03 09*	      .byte.b	LINE+CHARACTER_WALL, $1E, $03, $09, $04	; Line of zBrick from (30, 3); length = 9; direction = down
    148  2c71		       50 09 16 09*	      .byte.b	LINE+CHARACTER_WALL, $09, $16, $09, $00	; Line of zBrick from ( 9,22); length = 9; direction = up
    149  2c76		       50 0c 0f 11*	      .byte.b	LINE+CHARACTER_WALL, $0C, $0F, $11, $02	; Line of zBrick from (12,15); length = 17; direction = right
    150  2c7b		       50 05 0b 09*	      .byte.b	LINE+CHARACTER_WALL, $05, $0B, $09, $02	; Line of zBrick from ( 5,11); length = 9; direction = right
    151  2c80		       50 0f 0b 09*	      .byte.b	LINE+CHARACTER_WALL, $0F, $0B, $09, $02	; Line of zBrick from (15,11); length = 9; direction = right
    152  2c85		       50 19 0b 09*	      .byte.b	LINE+CHARACTER_WALL, $19, $0B, $09, $02	; Line of zBrick from (25,11); length = 9; direction = right
    153  2c8a		       50 1c 13 0b*	      .byte.b	LINE+CHARACTER_WALL, $1C, $13, $0B, $01	; Line of zBrick from (28,19); length = 11; direction = up/right
    154  2c8f		       04 04 03 	      .byte.b	CHARACTER_DIAMOND, $04, $03	; StoreChar zDiaS at ( 4, 3)
    155  2c92		       04 0e 03 	      .byte.b	CHARACTER_DIAMOND, $0E, $03	; StoreChar zDiaS at (14, 3)
    156  2c95		       04 18 03 	      .byte.b	CHARACTER_DIAMOND, $18, $03	; StoreChar zDiaS at (24, 3)
    157  2c98		       04 22 03 	      .byte.b	CHARACTER_DIAMOND, $22, $03	; StoreChar zDiaS at (34, 3)
    158  2c9b		       04 04 16 	      .byte.b	CHARACTER_DIAMOND, $04, $16	; StoreChar zDiaS at ( 4,22)
    159  2c9e		       04 23 15 	      .byte.b	CHARACTER_DIAMOND, $23, $15	; StoreChar zDiaS at (35,21)
    160  2ca1		       06 14 14 	      .byte.b	CHARACTER_MANOCCUPIED, $14, $14	; StoreChar zPRFd1 at (20,20)
    161  2ca4		       11 26 11 	      .byte.b	CHARACTER_EXITDOOR, $26, $11	; StoreChar zPreOut at (38,17)
    162  2ca7
      0  2ca7					      END_CAVE	CROWD
      1  2ca7		       ff		      .byte.b	$FF
      2  2ca7		       00 69	   CAVE_SIZE_CROWD =	* - CAVE_START
      3  2ca8				  -	      IF	CAVE_SIZE_CROWD > MAX_CAVE_SIZE
      4  2ca8				  -MAX_CAVE_SIZE SET	CAVE_SIZE_CROWD
      5  2ca8					      ENDIF
    164  2ca8					      ENDIF
    165  2ca8							;------------------------------------------------------------------------------
    166  2ca8
    167  2ca8					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2ca8					      START_CAVE	WALLS
      1  2ca8				   CAVE_START SET	*
      2  2ca8		       00 05	   BANK_CAVE_WALLS =	_CURRENT_BANK
      3  2ca8				   CAVE_WALLS SUBROUTINE
      4  2ca8				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2ca8
    169  2ca8
    170  2ca8		       0c		      .byte.b	$0C	; Cave 12 L
      0  2ca9					      CAVE_SIZE_ROOM		; width, height
      0  2ca9					      CAVE_SIZE	40, 22
      1  2ca9		       28 16		      .byte.b	40,22
    172  2cab		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    173  2cac		       20		      .byte.b	$20	;BCD'd $14				    ; Diamonds worth: 20 points
    174  2cad		       00		      .byte.b	$00	; Extra diamonds worth: 0 points
    175  2cae		       00 3c 02 3b*	      .byte.b	$00, $3C, $02, $3B, $66	; Randomiser seed values for difficulty levels 1-5
    176  2cb3		       13 13 0e 10*	      .byte.b	$13, $13, $0E, $10, $15	; Diamonds needed: 19, 19, 14, 16, 21 (for difficulty levels 1-5)
    177  2cb8		       b4 aa a0 a0*	      .byte.b	$B4, $AA, $A0, $A0, $A0	; Cave time: 180, 170, 160, 160, 160 seconds
    178  2cbd
    179  2cbd							;-------------------------------------------------------------------------------------
    180  2cbd							; PALETTE DEFINITIONS
    181  2cbd
    182  2cbd					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    183  2cbd		       46 66		      .byte.b	$46, $66
    184  2cbf		       06 18		      .byte.b	$06, $18
    185  2cc1		       ae 7e		      .byte.b	$ae, $7e
    186  2cc3				  -	      ELSE
    187  2cc3				  -
    188  2cc3				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    189  2cc3				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    190  2cc3				  -	      IF	AD_MODE
    191  2cc3				  -	      .byte	$46, $66
    192  2cc3				  -	      .byte	$06, $18
    193  2cc3				  -	      .byte	$ae, $7e
    194  2cc3				  -	      ENDIF
    195  2cc3				  -
    196  2cc3				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    197  2cc3				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    198  2cc3				  -	      IF	TJ_MODE
    199  2cc3				  -	      .byte	$46, $66
    200  2cc3				  -	      .byte	$06, $18
    201  2cc3				  -	      .byte	$ae, $7e
    202  2cc3				  -	      ENDIF
    203  2cc3				  -
    204  2cc3					      ENDIF
    205  2cc3
    206  2cc3							;-------------------------------------------------------------------------------------
    207  2cc3
    208  2cc3
    209  2cc3		       00 02 04 00	      .byte.b	$00, CHARACTER_BOULDER, CHARACTER_DIAMOND, $00	; Random objects:
    210  2cc7		       3c 32 09 00	      .byte.b	$3C, $32, $09, $00	;   zSpace :  60/256 = 23%
    211  2ccb							;   zBouS  :  50/256 = 19%
    212  2ccb							;   zDiaS  :	9/256 =  3%
    213  2ccb							;   fourth code unused (0%)
    214  2ccb
    215  2ccb		       50 0a 05 12*	      .byte.b	LINE+CHARACTER_WALL, $0A, $05, $12, $04	; Line of zBrick from (10, 5); length = 18; direction = down
    216  2cd0		       50 0e 05 12*	      .byte.b	LINE+CHARACTER_WALL, $0E, $05, $12, $04	; Line of zBrick from (14, 5); length = 18; direction = down
    217  2cd5		       50 12 05 12*	      .byte.b	LINE+CHARACTER_WALL, $12, $05, $12, $04	; Line of zBrick from (18, 5); length = 18; direction = down
    218  2cda		       50 16 05 12*	      .byte.b	LINE+CHARACTER_WALL, $16, $05, $12, $04	; Line of zBrick from (22, 5); length = 18; direction = down
    219  2cdf		       50 02 06 0b*	      .byte.b	LINE+CHARACTER_WALL, $02, $06, $0B, $02	; Line of zBrick from ( 2, 6); length = 11; direction = right
    220  2ce4		       50 02 0a 0b*	      .byte.b	LINE+CHARACTER_WALL, $02, $0A, $0B, $02	; Line of zBrick from ( 2,10); length = 11; direction = right
    221  2ce9		       50 02 0e 0f*	      .byte.b	LINE+CHARACTER_WALL, $02, $0E, $0F, $02	; Line of zBrick from ( 2,14); length = 15; direction = right
    222  2cee		       50 02 12 0b*	      .byte.b	LINE+CHARACTER_WALL, $02, $12, $0B, $02	; Line of zBrick from ( 2,18); length = 11; direction = right
    223  2cf3		       81 1e 04 04*	      .byte.b	FILL+CHARACTER_SOIL, $1E, $04, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (30, 4); length = 4; height = 4; fill = zSpace
    224  2cf9		       09 20 05 	      .byte.b	CHARACTER_FIREFLY, $20, $05	; StoreChar zFFly1 at (32, 5)
    225  2cfc		       81 1e 09 04*	      .byte.b	FILL+CHARACTER_SOIL, $1E, $09, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (30, 9); length = 4; height = 4; fill = zSpace
    226  2d02		       09 20 0a 	      .byte.b	CHARACTER_FIREFLY, $20, $0A	; StoreChar zFFly1 at (32,10)
    227  2d05		       81 1e 0e 04*	      .byte.b	FILL+CHARACTER_SOIL, $1E, $0E, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (30,14); length = 4; height = 4; fill = zSpace
    228  2d0b		       09 20 0f 	      .byte.b	CHARACTER_FIREFLY, $20, $0F	; StoreChar zFFly1 at (32,15)
    229  2d0e		       06 03 14 	      .byte.b	CHARACTER_MANOCCUPIED, $03, $14	; StoreChar zPRFd1 at ( 3,20)
    230  2d11		       11 27 16 	      .byte.b	CHARACTER_EXITDOOR, $27, $16	; StoreChar zPreOut at (39,22)
    231  2d14
      0  2d14					      END_CAVE	WALLS
      1  2d14		       ff		      .byte.b	$FF
      2  2d14		       00 6d	   CAVE_SIZE_WALLS =	* - CAVE_START
      3  2d15				  -	      IF	CAVE_SIZE_WALLS > MAX_CAVE_SIZE
      4  2d15				  -MAX_CAVE_SIZE SET	CAVE_SIZE_WALLS
      5  2d15					      ENDIF
    233  2d15					      ENDIF
    234  2d15
    235  2d15							;------------------------------------------------------------------------------
    236  2d15
    237  2d15							;IFCONST CAVE_NAMED_APOCALYPSE
      0  2d15					      START_CAVE	APOCALYPSE
      1  2d15				   CAVE_START SET	*
      2  2d15		       00 05	   BANK_CAVE_APOCALYPSE =	_CURRENT_BANK
      3  2d15				   CAVE_APOCALYPSE SUBROUTINE
      4  2d15				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2d15
    239  2d15
    240  2d15		       0d		      .byte.b	$0D	; Cave 13 M
      0  2d16					      CAVE_SIZE_ROOM		; width, height
      0  2d16					      CAVE_SIZE	40, 22
      1  2d16		       28 16		      .byte.b	40,22
    242  2d18		       8c		      .byte.b	$8C	; Magic wall/amoeba slow growth for: 140 seconds
    243  2d19		       05		      .byte.b	$05	; Diamonds worth: 5 points
    244  2d1a		       08		      .byte.b	$08	; Extra diamonds worth: 8 points
    245  2d1b		       00 01 02 03*	      .byte.b	$00, $01, $02, $03, $04	; Randomiser seed values for difficulty levels 1-5
    246  2d20		       32 37 3c 46*	      .byte.b	$32, $37, $3C, $46, $50	; Diamonds needed: 50, 55, 60, 70, 80 (for difficulty levels 1-5)
    247  2d25							;   .byte 30,35,40,45,50    ; modified goal due to fewer butterflies; TJ: reverted, now that we can have all 30
    248  2d25
    249  2d25		       a0 9b 96 91*	      .byte.b	$A0, $9B, $96, $91, $8C	; Cave time: 160, 155, 150, 145, 140 seconds
    250  2d2a
    251  2d2a
    252  2d2a							;-------------------------------------------------------------------------------------
    253  2d2a							; PALETTE DEFINITIONS
    254  2d2a
    255  2d2a					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    256  2d2a		       88 c8		      .byte.b	$88, $c8
    257  2d2c		       24 24		      .byte.b	$24, $24
    258  2d2e		       cc 7a		      .byte.b	$cc, $7a
    259  2d30				  -	      ELSE
    260  2d30				  -
    261  2d30				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    262  2d30				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    263  2d30				  -	      IF	AD_MODE
    264  2d30				  -	      .byte	$88, $c8
    265  2d30				  -	      .byte	$24, $24
    266  2d30				  -	      .byte	$cc, $7a
    267  2d30				  -	      ENDIF
    268  2d30				  -
    269  2d30				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    270  2d30				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    271  2d30				  -	      IF	TJ_MODE
    272  2d30				  -	      .byte	$88, $c8
    273  2d30				  -	      .byte	$24, $24
    274  2d30				  -	      .byte	$cc, $7a
    275  2d30				  -	      ENDIF
    276  2d30				  -
    277  2d30					      ENDIF
    278  2d30
    279  2d30							;-------------------------------------------------------------------------------------
    280  2d30
    281  2d30
    282  2d30
    283  2d30		       02 00 00 00	      .byte.b	CHARACTER_BOULDER, $00, $00, $00	; Random objects:
    284  2d34		       28 00 00 00	      .byte.b	$28, $00, $00, $00	;   zBouS  :  40/256 = 15%
    285  2d38							;   second code unused (0%)
    286  2d38							;   third code unused (0%)
    287  2d38							;   fourth code unused (0%)
    288  2d38
    289  2d38		       06 12 03 	      .byte.b	CHARACTER_MANOCCUPIED, $12, $03	; StoreChar zPRFd1 at (18, 3)
    290  2d3b		       11 0a 03 	      .byte.b	CHARACTER_EXITDOOR, $0A, $03	; StoreChar zPreOut at (10, 3)
    291  2d3e		       03 14 03 	      .byte.b	CHARACTER_AMOEBA, $14, $03	; StoreChar zAmoe at (20, 3)
    292  2d41
    293  2d41							;-----
    294  2d41							; Modified version with fewer butterflies to allow apocalpyse to be playable for the demo
    295  2d41							; Basically reduced the butterfly count significantly
    296  2d41							;.byte   $70, $05, $13, $1E, $02	     ; Line of zBFly1 from ( 5,19); length = 30; direction = right
    297  2d41
    298  2d41
    299  2d41		       50 05 12 1e*	      .byte.b	LINE+CHARACTER_WALL, $05, $12, $1E, $02	; Line of zBrick from ( 5,18); length = 30; direction = right
    300  2d46		       47 05 13 1e*	      .byte.b	LINE+CHARACTER_FLUTTERBY, $05, $13, $1E, $02	; Line of zBFly1 from ( 5,19); length = 30; direction = right
    301  2d4b		       42 05 14 1e*	      .byte.b	LINE+CHARACTER_BOULDER, $05, $14, $1E, $02	; Line of zBouS from ( 5,20); length = 30; direction = right
    302  2d50		       c1 05 15 1e*	      .byte.b	RECT+CHARACTER_SOIL, $05, $15, $1E, $02	; Rect of zDirt from ( 5,21); length = 30; height = 2
    303  2d55
      0  2d55					      END_CAVE	APOCALYPSE
      1  2d55		       ff		      .byte.b	$FF
      2  2d55		       00 41	   CAVE_SIZE_APOCALYPSE =	* - CAVE_START
      3  2d56				  -	      IF	CAVE_SIZE_APOCALYPSE > MAX_CAVE_SIZE
      4  2d56				  -MAX_CAVE_SIZE SET	CAVE_SIZE_APOCALYPSE
      5  2d56					      ENDIF
    305  2d56							;ENDIF
    306  2d56
    307  2d56							;------------------------------------------------------------------------------
    308  2d56
    309  2d56					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2d56					      START_CAVE	ZIGZAG
      1  2d56				   CAVE_START SET	*
      2  2d56		       00 05	   BANK_CAVE_ZIGZAG =	_CURRENT_BANK
      3  2d56				   CAVE_ZIGZAG SUBROUTINE
      4  2d56				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2d56
    311  2d56
    312  2d56		       0e		      .byte.b	$0E	; Cave 14 N
      0  2d57					      CAVE_SIZE_ROOM		; width, height
      0  2d57					      CAVE_SIZE	40, 22
      1  2d57		       28 16		      .byte.b	40,22
    314  2d59		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    315  2d5a		       10		      .byte.b	$10	;BCD'd $0A				    ; Diamonds worth: 10 points
    316  2d5b		       20		      .byte.b	$20	;BCD'd $14				    ; Extra diamonds worth: 20 points
    317  2d5c		       00 00 00 00*	      .byte.b	$00, $00, $00, $00, $00	; Randomiser seed values for difficulty levels 1-5
    318  2d61		       1e 23 28 2a*	      .byte.b	$1E, $23, $28, $2A, $2D	; Diamonds needed: 30, 35, 40, 42, 45 (for difficulty levels 1-5)
    319  2d66		       96 91 8c 87*	      .byte.b	$96, $91, $8C, $87, $82	; Cave time: 150, 145, 140, 135, 130 seconds
    320  2d6b
    321  2d6b
    322  2d6b							;-------------------------------------------------------------------------------------
    323  2d6b							; PALETTE DEFINITIONS
    324  2d6b
    325  2d6b					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    326  2d6b		       2a 2a		      .byte.b	$2A, $2A
    327  2d6d		       66 a4		      .byte.b	$66, $a4
    328  2d6f		       ce 5e		      .byte.b	$ce, $5e
    329  2d71				  -	      ELSE
    330  2d71				  -
    331  2d71				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    332  2d71				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    333  2d71				  -	      IF	AD_MODE
    334  2d71				  -	      .byte	$2A, $2A
    335  2d71				  -	      .byte	$66, $a4
    336  2d71				  -	      .byte	$ce, $5e
    337  2d71				  -	      ENDIF
    338  2d71				  -
    339  2d71				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    340  2d71				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    341  2d71				  -	      IF	TJ_MODE
    342  2d71				  -	      .byte	$26, $46
    343  2d71				  -	      .byte	$04, $06
    344  2d71				  -	      .byte	$9e, $be
    345  2d71				  -	      ENDIF
    346  2d71				  -
    347  2d71					      ENDIF
    348  2d71
    349  2d71							;-------------------------------------------------------------------------------------
    350  2d71
    351  2d71
    352  2d71		       02 00 00 00	      .byte.b	CHARACTER_BOULDER, $00, $00, $00	; Random objects:
    353  2d75		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
    354  2d79							;   second code unused (0%) ???
    355  2d79							;   third code unused (0%) ???
    356  2d79							;   fourth code unused (0%) ???
    357  2d79
    358  2d79		       81 0a 0a 0d*	      .byte.b	FILL+CHARACTER_SOIL, $0A, $0A, $0D, $0D, CHARACTER_BLANK	; FilledRect of zDirt from (10,10); length = 13; height = 13; fill = zSpace
    359  2d7f		       47 0b 0b 0c*	      .byte.b	LINE+CHARACTER_FLUTTERBY, $0B, $0B, $0C, $03	; Line of zBFly1 from (11,11); length = 12; direction = down/right
    360  2d84		       c1 0c 0a 03*	      .byte.b	RECT+CHARACTER_SOIL, $0C, $0A, $03, $0D	; Rect of zDirt from (12,10); length = 3; height = 13
    361  2d89		       c1 10 0a 03*	      .byte.b	RECT+CHARACTER_SOIL, $10, $0A, $03, $0D	; Rect of zDirt from (16,10); length = 3; height = 13
    362  2d8e		       c1 14 0a 03*	      .byte.b	RECT+CHARACTER_SOIL, $14, $0A, $03, $0D	; Rect of zDirt from (20,10); length = 3; height = 13
    363  2d93		       42 16 08 0c*	      .byte.b	LINE+CHARACTER_BOULDER, $16, $08, $0C, $02	; Line of zBouS from (22, 8); length = 12; direction = right
    364  2d98		       49 16 07 0c*	      .byte.b	LINE+CHARACTER_FIREFLY, $16, $07, $0C, $02	; Line of zFFly1 from (22, 7); length = 12; direction = right
    365  2d9d		       c1 17 06 03*	      .byte.b	RECT+CHARACTER_SOIL, $17, $06, $03, $04	; Rect of zDirt from (23, 6); length = 3; height = 4
    366  2da2		       c1 1b 06 03*	      .byte.b	RECT+CHARACTER_SOIL, $1B, $06, $03, $04	; Rect of zDirt from (27, 6); length = 3; height = 4
    367  2da7		       c1 1f 06 03*	      .byte.b	RECT+CHARACTER_SOIL, $1F, $06, $03, $04	; Rect of zDirt from (31, 6); length = 3; height = 4
    368  2dac		       06 03 03 	      .byte.b	CHARACTER_MANOCCUPIED, $03, $03	; StoreChar zPRFd1 at ( 3, 3)
    369  2daf		       11 27 14 	      .byte.b	CHARACTER_EXITDOOR, $27, $14	; StoreChar zPreOut at (39,20)
    370  2db2
    371  2db2							;    .byte   LINE+CHARACTER_WALL, $01, $09, $1E, $02	 ; Line of zBrick from ( 1, 9); length = 30; direction = right
    372  2db2
      0  2db2					      END_CAVE	ZIGZAG
      1  2db2		       ff		      .byte.b	$FF
      2  2db2		       00 5d	   CAVE_SIZE_ZIGZAG =	* - CAVE_START
      3  2db3				  -	      IF	CAVE_SIZE_ZIGZAG > MAX_CAVE_SIZE
      4  2db3				  -MAX_CAVE_SIZE SET	CAVE_SIZE_ZIGZAG
      5  2db3					      ENDIF
    374  2db3					      ENDIF
    375  2db3
    376  2db3							;------------------------------------------------------------------------------
    377  2db3
    378  2db3					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2db3					      START_CAVE	ENCHANTED_BOXES
      1  2db3				   CAVE_START SET	*
      2  2db3		       00 05	   BANK_CAVE_ENCHANTED_BOXES =	_CURRENT_BANK
      3  2db3				   CAVE_ENCHANTED_BOXES SUBROUTINE
      4  2db3				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2db3
    380  2db3
    381  2db3		       10		      .byte.b	$10	; Cave 16 P
      0  2db4					      CAVE_SIZE_ROOM		; width, height
      0  2db4					      CAVE_SIZE	40, 22
      1  2db4		       28 16		      .byte.b	40,22
    383  2db6		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    384  2db7		       10		      .byte.b	$10	;BCD'd $0A				    ; Diamonds worth: 10 points
    385  2db8		       20		      .byte.b	$20	;BCD'd $14				    ; Extra diamonds worth: 20 points
    386  2db9		       01 78 81 7e*	      .byte.b	$01, $78, $81, $7E, $7B	; Randomiser seed values for difficulty levels 1-5
    387  2dbe		       0c 0f 0f 0f*	      .byte.b	$0C, $0F, $0F, $0F, $0C	; Diamonds needed: 12, 15, 15, 15, 12 (for difficulty levels 1-5)
    388  2dc3		       96 96 96 96*	      .byte.b	$96, $96, $96, $96, $96	; Cave time: 150, 150, 150, 150, 150 seconds
    389  2dc8
    390  2dc8							;-------------------------------------------------------------------------------------
    391  2dc8							; PALETTE DEFINITIONS
    392  2dc8
    393  2dc8					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    394  2dc8		       58 68		      .byte.b	$58, $68
    395  2dca		       24 44		      .byte.b	$24, $44
    396  2dcc		       be 9e		      .byte.b	$be, $9e
    397  2dce				  -	      ELSE
    398  2dce				  -
    399  2dce				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    400  2dce				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    401  2dce				  -	      IF	AD_MODE
    402  2dce				  -	      .byte	$58, $68
    403  2dce				  -	      .byte	$24, $44
    404  2dce				  -	      .byte	$be, $9e
    405  2dce				  -	      ENDIF
    406  2dce				  -
    407  2dce				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    408  2dce				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    409  2dce				  -	      IF	TJ_MODE
    410  2dce				  -	      .byte	$58, $68
    411  2dce				  -	      .byte	$24, $44
    412  2dce				  -	      .byte	$be, $9e
    413  2dce				  -	      ENDIF
    414  2dce				  -
    415  2dce					      ENDIF
    416  2dce
    417  2dce							;-------------------------------------------------------------------------------------
    418  2dce
    419  2dce		       02 00 00 00	      .byte.b	CHARACTER_BOULDER, $00, $00, $00	; Random objects:
    420  2dd2		       32 00 00 00	      .byte.b	$32, $00, $00, $00	;   zBouS  :  50/256 = 19%
    421  2dd6							;   second code unused (0%)
    422  2dd6							;   third code unused (0%)
    423  2dd6							;   fourth code unused (0%)
    424  2dd6		       06 01 03 	      .byte.b	CHARACTER_MANOCCUPIED, $01, $03	; StoreChar zPRFd1 at ( 1, 3)
    425  2dd9		       11 27 04 	      .byte.b	CHARACTER_EXITDOOR, $27, $04	; StoreChar zPreOut at (39, 4)
    426  2ddc		       81 08 13 04*	      .byte.b	FILL+CHARACTER_SOIL, $08, $13, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from ( 8,19); length = 4; height = 4; fill = zSpace
    427  2de2		       09 0a 14 	      .byte.b	CHARACTER_FIREFLY, $0A, $14	; StoreChar zFFly1 at (10,20)
    428  2de5				  -	      IF	SHOWDIAMONDP
    429  2de5				  -	      .byte	CHARACTER_DIAMOND, $08, $8	; StoreChar zFFly1 at (10,20)
    430  2de5					      ENDIF
    431  2de5		       d0 07 0a 06*	      .byte.b	RECT+CHARACTER_WALL, $07, $0A, $06, $08	; Rect of zBrick from ( 7,10); length = 6; height = 8
    432  2dea		       4b 07 0a 06*	      .byte.b	LINE+CHARACTER_WALL0, $07, $0A, $06, $02	; Line of zMagic from ( 7,10); length = 6; direction = right
    433  2def		       81 10 13 04*	      .byte.b	FILL+CHARACTER_SOIL, $10, $13, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (16,19); length = 4; height = 4; fill = zSpace
    434  2df5		       09 12 14 	      .byte.b	CHARACTER_FIREFLY, $12, $14	; StoreChar zFFly1 at (18,20)
    435  2df8		       d0 0f 0a 06*	      .byte.b	RECT+CHARACTER_WALL, $0F, $0A, $06, $08	; Rect of zBrick from (15,10); length = 6; height = 8
    436  2dfd		       4b 0f 0a 06*	      .byte.b	LINE+CHARACTER_WALL0, $0F, $0A, $06, $02	; Line of zMagic from (15,10); length = 6; direction = right
    437  2e02		       81 18 13 04*	      .byte.b	FILL+CHARACTER_SOIL, $18, $13, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (24,19); length = 4; height = 4; fill = zSpace
    438  2e08		       09 1a 14 	      .byte.b	CHARACTER_FIREFLY, $1A, $14	; StoreChar zFFly1 at (26,20)
    439  2e0b		       81 20 13 04*	      .byte.b	FILL+CHARACTER_SOIL, $20, $13, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (32,19); length = 4; height = 4; fill = zSpace
    440  2e11		       09 22 14 	      .byte.b	CHARACTER_FIREFLY, $22, $14	; StoreChar zFFly1 at (34,20)
    441  2e14
      0  2e14					      END_CAVE	ENCHANTED_BOXES
      1  2e14		       ff		      .byte.b	$FF
      2  2e14		       00 62	   CAVE_SIZE_ENCHANTED_BOXES =	* - CAVE_START
      3  2e15				  -	      IF	CAVE_SIZE_ENCHANTED_BOXES > MAX_CAVE_SIZE
      4  2e15				  -MAX_CAVE_SIZE SET	CAVE_SIZE_ENCHANTED_BOXES
      5  2e15					      ENDIF
    443  2e15					      ENDIF
    444  2e15
    445  2e15							;------------------------------------------------------------------------------
    446  2e15
    447  2e15					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2e15					      START_CAVE	INTERMISSION_1
      1  2e15				   CAVE_START SET	*
      2  2e15		       00 05	   BANK_CAVE_INTERMISSION_1 =	_CURRENT_BANK
      3  2e15				   CAVE_INTERMISSION_1 SUBROUTINE
      4  2e15				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2e15
    449  2e15
    450  2e15		       11		      .byte.b	$11	; Cave 17 I1
      0  2e16					      CAVE_SIZE_INTERMISSION		; width, height
      0  2e16					      CAVE_SIZE	20, 12
      1  2e16		       14 0c		      .byte.b	20,12
    452  2e18		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    453  2e19		       30		      .byte.b	$30	;BCD'd $1E				    ; Diamonds worth: 30 points
    454  2e1a		       00		      .byte.b	$00	; Extra diamonds worth: 0 points
    455  2e1b		       0a 0b 0c 0d*	      .byte.b	$0A, $0B, $0C, $0D, $0E	; Randomiser seed values for difficulty levels 1-5
    456  2e20		       06 06 06 06*	      .byte.b	$06, $06, $06, $06, $06	; Diamonds needed: 6, 6, 6, 6, 6 (for difficulty levels 1-5)
    457  2e25		       0a 0a 0a 0a*	      .byte.b	$0A, $0A, $0A, $0A, $0A	; Cave time: 10, 10, 10, 10, 10 seconds
    458  2e2a
    459  2e2a							;-------------------------------------------------------------------------------------
    460  2e2a							; PALETTE DEFINITIONS
    461  2e2a
    462  2e2a					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    463  2e2a		       28 46		      .byte.b	$28, $46
    464  2e2c		       54 a4		      .byte.b	$54, $a4
    465  2e2e		       be 5e		      .byte.b	$be, $5e
    466  2e30				  -	      ELSE
    467  2e30				  -
    468  2e30				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    469  2e30				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    470  2e30				  -	      IF	AD_MODE
    471  2e30				  -	      .byte	$28, $46
    472  2e30				  -	      .byte	$54, $a4
    473  2e30				  -	      .byte	$be, $7e
    474  2e30				  -	      ENDIF
    475  2e30				  -
    476  2e30				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    477  2e30				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    478  2e30				  -	      IF	TJ_MODE
    479  2e30				  -	      .byte	$28, $46
    480  2e30				  -	      .byte	$54, $a4
    481  2e30				  -	      .byte	$be, $7e
    482  2e30				  -	      ENDIF
    483  2e30				  -
    484  2e30					      ENDIF
    485  2e30
    486  2e30							;-------------------------------------------------------------------------------------
    487  2e30
    488  2e30
    489  2e30		       00 04 00 00	      .byte.b	$00, CHARACTER_DIAMOND, $00, $00	; Random objects:
    490  2e34		       ff 09 00 00	      .byte.b	$FF, $09, $00, $00	;   zSpace : 255/256 = 99%
    491  2e38							;   zDiaS  :	9/256 =  3%
    492  2e38							;   third code unused (0%)
    493  2e38							;   fourth code unused (0%)
    494  2e38
    495  2e38							;   superfluous due to limited cave size
    496  2e38							;    .byte   FILL+CHARACTER_STEEL, $00, $02, $28, $16, CHARACTER_STEEL; FilledRect of zSteel from ( 0, 2); length = 40; height = 22; fill = zSteel
    497  2e38		       8f 00 02 14*	      .byte.b	FILL+CHARACTER_STEEL, $00, $02, $14, 9+3, CHARACTER_BLANK	; FilledRect of zSteel from ( 0, 2); length = 20; height = 12; fill = zSpace
    498  2e3e							;    .byte   CHARACTER_FLUTTERBY2, $0A, $0C	      ; StoreChar zBFly3 at (10,12)
    499  2e3e							;    .byte   CHARACTER_BOULDER, $0A, $05	      ; StoreChar zBouS at (10, 4)
    500  2e3e							;    .byte   CHARACTER_SOIL, $0A, $6		      ; StoreChar zDirt at (10, 5)
    501  2e3e							;    .byte   CHARACTER_MANOCCUPIED, $03, $05	      ; StoreChar zPRFd1 at ( 3, 5)
    502  2e3e		       08 05 0c 	      .byte.b	CHARACTER_FLUTTERBY2, $05, $0C	; StoreChar zBFly3 at (10,12)
    503  2e41		       02 06 07 	      .byte.b	CHARACTER_BOULDER, $06, $07	; StoreChar zBouS at (10, 4)
    504  2e44		       01 06 08 	      .byte.b	CHARACTER_SOIL, $06, $8	; StoreChar zDirt at (10, 5)
    505  2e47		       06 03 0b 	      .byte.b	CHARACTER_MANOCCUPIED, $03, $b	; StoreChar zPRFd1 at ( 3, 5)
    506  2e4a
    507  2e4a		       11 12 0c 	      .byte.b	CHARACTER_EXITDOOR, $12, $0C	; StoreChar zPreOut at (18,12)
    508  2e4d
      0  2e4d					      END_CAVE	INTERMISSION_1
      1  2e4d		       ff		      .byte.b	$FF
      2  2e4d		       00 39	   CAVE_SIZE_INTERMISSION_1 =	* - CAVE_START
      3  2e4e				  -	      IF	CAVE_SIZE_INTERMISSION_1 > MAX_CAVE_SIZE
      4  2e4e				  -MAX_CAVE_SIZE SET	CAVE_SIZE_INTERMISSION_1
      5  2e4e					      ENDIF
    510  2e4e					      ENDIF
    511  2e4e
    512  2e4e							;------------------------------------------------------------------------------
    513  2e4e
    514  2e4e					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2e4e					      START_CAVE	INTERMISSION_2
      1  2e4e				   CAVE_START SET	*
      2  2e4e		       00 05	   BANK_CAVE_INTERMISSION_2 =	_CURRENT_BANK
      3  2e4e				   CAVE_INTERMISSION_2 SUBROUTINE
      4  2e4e				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2e4e
    516  2e4e
    517  2e4e		       12		      .byte.b	$12	; Cave 18
      0  2e4f					      CAVE_SIZE_INTERMISSION		; width, height
      0  2e4f					      CAVE_SIZE	20, 12
      1  2e4f		       14 0c		      .byte.b	20,12
    519  2e51		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    520  2e52		       10		      .byte.b	$10	;BCD'd $0A				    ; Diamonds worth: 10 points
    521  2e53		       00		      .byte.b	$00	; Extra diamonds worth: 0 points
    522  2e54		       0a 0b 0c 0d*	      .byte.b	$0A, $0B, $0C, $0D, $0E	;	Randomiser seed values for difficulty levels 1-5
    523  2e59		       10 10 10 10*	      .byte.b	$10, $10, $10, $10, $10	;	Diamonds needed: 16, 16, 16, 16, 16 (for difficulty levels 1-5)
    524  2e5e		       0f 0f 0f 0f*	      .byte.b	$0F, $0F, $0F, $0F, $0F	;	Cave time: 15, 15, 15, 15, 15 seconds
    525  2e63
    526  2e63							;-------------------------------------------------------------------------------------
    527  2e63							; PALETTE DEFINITIONS
    528  2e63
    529  2e63					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    530  2e63		       0a 0a		      .byte.b	$0a, $0a
    531  2e65		       76 c4		      .byte.b	$76, $c4
    532  2e67		       2e 2e		      .byte.b	$2e, $2e
    533  2e69				  -	      ELSE
    534  2e69				  -
    535  2e69				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    536  2e69				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    537  2e69				  -	      IF	AD_MODE
    538  2e69				  -	      .byte	$0a, $0a
    539  2e69				  -	      .byte	$76, $c4
    540  2e69				  -	      .byte	$2e, $2e
    541  2e69				  -	      ENDIF
    542  2e69				  -
    543  2e69				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    544  2e69				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    545  2e69				  -	      IF	TJ_MODE
    546  2e69				  -	      .byte	$0a, $0a
    547  2e69				  -	      .byte	$76, $c4
    548  2e69				  -	      .byte	$2e, $2e
    549  2e69				  -	      ENDIF
    550  2e69				  -
    551  2e69					      ENDIF
    552  2e69
    553  2e69							;-------------------------------------------------------------------------------------
    554  2e69
    555  2e69		       00 00 00 00	      .byte.b	$00, $00, $00, $00	; Random objects:
    556  2e6d		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
    557  2e71							;   second code unused (0%)
    558  2e71							;   third code unused (0%)
    559  2e71							;   fourth code unused (0%)
    560  2e71
    561  2e71							;   superfluous due to limited cave size
    562  2e71							;    .byte   FILL+CHARACTER_STEEL, $00, $02, $28, $16, CHARACTER_STEEL; FilledRect of zSteel from ( 0, 2); length = 40; height = 22; fill = zSteel
    563  2e71		       8f 00 02 14*	      .byte.b	FILL+CHARACTER_STEEL, $00, $02, $14, $0C, CHARACTER_SOIL	; FilledRect of zSteel from ( 0, 2); length = 20; height = 12; fill = zDirt
    564  2e77		       42 01 03 09*	      .byte.b	LINE+CHARACTER_BOULDER, $01, $03, $09, $03	; Line of zBouS from ( 1, 3); length = 9; direction = down/right
    565  2e7c		       49 02 03 08*	      .byte.b	LINE+CHARACTER_FIREFLY, $02, $03, $08, $03	; Line of zFFly1 from ( 2, 3); length = 8; direction = down/right
    566  2e81		       44 01 05 08*	      .byte.b	LINE+CHARACTER_DIAMOND, $01, $05, $08, $03	; Line of zDiaS from ( 1, 5); length = 8; direction = down/right
    567  2e86		       42 01 06 07*	      .byte.b	LINE+CHARACTER_BOULDER, $01, $06, $07, $03	; Line of zBouS from ( 1, 6); length = 7; direction = down/right
    568  2e8b		       42 12 03 09*	      .byte.b	LINE+CHARACTER_BOULDER, $12, $03, $09, $05	; Line of zBouS from (18, 3); length = 9; direction = down/left
    569  2e90		       44 12 05 08*	      .byte.b	LINE+CHARACTER_DIAMOND, $12, $05, $08, $05	; Line of zDiaS from (18, 5); length = 8; direction = down/left
    570  2e95		       42 12 06 07*	      .byte.b	LINE+CHARACTER_BOULDER, $12, $06, $07, $05	; Line of zBouS from (18, 6); length = 7; direction = down/left
    571  2e9a		       06 01 04 	      .byte.b	CHARACTER_MANOCCUPIED, $01, $04	; StoreChar zPRFd1 at ( 1, 4)
    572  2e9d		       11 12 04 	      .byte.b	CHARACTER_EXITDOOR, $12, $04	; StoreChar zPreOut at (18, 4)
    573  2ea0
      0  2ea0					      END_CAVE	INTERMISSION_2
      1  2ea0		       ff		      .byte.b	$FF
      2  2ea0		       00 53	   CAVE_SIZE_INTERMISSION_2 =	* - CAVE_START
      3  2ea1				  -	      IF	CAVE_SIZE_INTERMISSION_2 > MAX_CAVE_SIZE
      4  2ea1				  -MAX_CAVE_SIZE SET	CAVE_SIZE_INTERMISSION_2
      5  2ea1					      ENDIF
    575  2ea1					      ENDIF
    576  2ea1
    577  2ea1							;------------------------------------------------------------------------------
    578  2ea1
    579  2ea1					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2ea1					      START_CAVE	INTERMISSION_3
      1  2ea1				   CAVE_START SET	*
      2  2ea1		       00 05	   BANK_CAVE_INTERMISSION_3 =	_CURRENT_BANK
      3  2ea1				   CAVE_INTERMISSION_3 SUBROUTINE
      4  2ea1				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2ea1
    581  2ea1
    582  2ea1		       13		      .byte.b	$13	; Cave 19
      0  2ea2					      CAVE_SIZE_INTERMISSION		; width, height
      0  2ea2					      CAVE_SIZE	20, 12
      1  2ea2		       14 0c		      .byte.b	20,12
    584  2ea4		       04		      .byte.b	$04	; Magic wall/amoeba slow growth for: 4 seconds
    585  2ea5		       10		      .byte.b	$10	;BCD'd $0A				    ; Diamonds worth: 10 points
    586  2ea6		       00		      .byte.b	$00	; Extra diamonds worth: 0 points
    587  2ea7		       0a 0b 0c 0d*	      .byte.b	$0A, $0B, $0C, $0D, $0E	; Randomiser seed values for difficulty levels 1-5
    588  2eac		       0e 0e 0e 0e*	      .byte.b	$0E, $0E, $0E, $0E, $0E	; Diamonds needed: 14, 14, 14, 14, 14 (for difficulty levels 1-5)
    589  2eb1		       14 14 14 14*	      .byte.b	$14, $14, $14, $14, $14	; Cave time: 20, 20, 20, 20, 20 seconds
    590  2eb6
    591  2eb6							;-------------------------------------------------------------------------------------
    592  2eb6							; PALETTE DEFINITIONS
    593  2eb6
    594  2eb6					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    595  2eb6		       16 26		      .byte.b	$16, $26
    596  2eb8		       36 44		      .byte.b	$36, $44
    597  2eba		       8e 9e		      .byte.b	$8e, $9e
    598  2ebc				  -	      ELSE
    599  2ebc				  -
    600  2ebc				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    601  2ebc				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    602  2ebc				  -	      IF	AD_MODE
    603  2ebc				  -	      .byte	$16, $26
    604  2ebc				  -	      .byte	$36, $44
    605  2ebc				  -	      .byte	$8e, $9e
    606  2ebc				  -	      ENDIF
    607  2ebc				  -
    608  2ebc				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    609  2ebc				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    610  2ebc				  -	      IF	TJ_MODE
    611  2ebc				  -	      .byte	$16, $26
    612  2ebc				  -	      .byte	$36, $44
    613  2ebc				  -	      .byte	$8e, $9e
    614  2ebc				  -	      ENDIF
    615  2ebc				  -
    616  2ebc					      ENDIF
    617  2ebc
    618  2ebc							;-------------------------------------------------------------------------------------
    619  2ebc
    620  2ebc
    621  2ebc		       00 00 00 00	      .byte.b	$00, $00, $00, $00	; Random objects:
    622  2ec0		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
    623  2ec4							;   second code unused (0%)
    624  2ec4							;   third code unused (0%)
    625  2ec4							;   fourth code unused (0%)
    626  2ec4
    627  2ec4							;   superfluous due to limited cave size
    628  2ec4							;    .byte   FILL+CHARACTER_STEEL, $00, $02, $28, $16, CHARACTER_STEEL; FilledRect of zSteel from ( 0, 2); length = 40; height = 22; fill = zSteel
    629  2ec4		       8f 00 02 14*	      .byte.b	FILL+CHARACTER_STEEL, $00, $02, $14, $0C, CHARACTER_BLANK	; FilledRect of zSteel from ( 0, 2); length = 20; height = 12; fill = zSpace
    630  2eca		       44 01 0c 12*	      .byte.b	LINE+CHARACTER_DIAMOND, $01, $0C, $12, $02	; Line of zDiaS from ( 1,12); length = 18; direction = right
    631  2ecf		       89 0f 08 04*	      .byte.b	FILL+CHARACTER_FIREFLY, $0F, $08, $04, $04, CHARACTER_FIREFLY	; FilledRect of zFFly1 from (15, 9); length = 4; height = 4; fill = zFFly1
    632  2ed5							;    .byte   FILL+CHARACTER_FIREFLY, $0f, $09, $04, $03, CHARACTER_FIREFLY; FilledRect of zFFly1 from (15, 9); length = 4; height = 4; fill = zFFly1
    633  2ed5							;    .byte   CHARACTER_MANOCCUPIED, $08, 3		  ; StoreChar zPRFd1 at ( 8, 3)
    634  2ed5		       06 0f 06 	      .byte.b	CHARACTER_MANOCCUPIED, 15, 6	; StoreChar zPRFd1 at ( 8, 3)
    635  2ed8		       11 12 07 	      .byte.b	CHARACTER_EXITDOOR, $12, $07	; StoreChar zPreOut at (18, 7)
    636  2edb
    637  2edb							; remainders of WAKA WAKA :(
    638  2edb							;    .byte   $13				  ; Cave WAKA_WAKA
    639  2edb							;    CAVE_SIZE_ROOM				  ; width, height
    640  2edb							;    .byte   $04				  ; Magic wall/amoeba slow growth for: 4 seconds
    641  2edb							;    .byte   $50				  ; Diamonds worth: 50 points
    642  2edb							;    .byte   $99				  ; Extra diamonds worth: 0 points
    643  2edb							;    .byte   $00, $00, $00, $00, $00		  ; Randomiser seed values for difficulty levels 1-5
    644  2edb							;    .byte   $05, $05, $05, $05, $05		  ; Diamonds needed: 14, 14, 14, 14, 14 (for difficulty levels 1-5)
    645  2edb							;    .byte   90, 75, 60, 50, 40		  ; Cave time: 20, 20, 20, 20, 20 seconds
    646  2edb							;
    647  2edb							;    .byte   $16, $26				  ; medium yellow     NTSC/PAL
    648  2edb							;    .byte   $36, $44				  ; dark orange
    649  2edb							;    .byte   $8e, $9e				  ; bright blue
    650  2edb							;
    651  2edb							;    .byte   0, 0, 0, 0			  ; Random objects, unused
    652  2edb							;    .byte   0, 0, 0, 0			  ; random values, unused
    653  2edb							;
    654  2edb							;    .byte   FILL+CHARACTER_STEEL, 10,  2, 19, 22, CHARACTER_BLANK
    655  2edb							;    .byte   CHARACTER_BLANK, 10, 10
    656  2edb							;    .byte   CHARACTER_BLANK, 10, 12
    657  2edb							;    .byte   CHARACTER_BLANK, 10, 14
    658  2edb							;    .byte   CHARACTER_BLANK, 28, 10
    659  2edb							;    .byte   CHARACTER_BLANK, 28, 12
    660  2edb							;    .byte   CHARACTER_BLANK, 28, 14
    661  2edb							;
    662  2edb							;    .byte   RECT+CHARACTER_STEEL, 12,  4,  2,  2
    663  2edb							;    .byte   RECT+CHARACTER_STEEL, 15,  4,  3,  2
    664  2edb							;    .byte   LINE+CHARACTER_STEEL, 19,  3,  3, .DIR_DOWN
    665  2edb							;    .byte   RECT+CHARACTER_STEEL, 21,  4,  3,  2
    666  2edb							;    .byte   RECT+CHARACTER_STEEL, 25,  4,  2,  2
    667  2edb							;
    668  2edb							;    .byte   LINE+CHARACTER_STEEL, 12,  7,  2, .DIR_RIGHT
    669  2edb							;    .byte   LINE+CHARACTER_STEEL, 15,  7,  5, .DIR_DOWN
    670  2edb							;    .byte   LINE+CHARACTER_STEEL, 17,  7,  5, .DIR_RIGHT
    671  2edb							;    .byte   LINE+CHARACTER_STEEL, 19,  7,  3, .DIR_DOWN
    672  2edb							;    .byte   LINE+CHARACTER_STEEL, 23,  7,  5, .DIR_DOWN
    673  2edb							;    .byte   LINE+CHARACTER_STEEL, 25,  7,  2, .DIR_RIGHT
    674  2edb							;
    675  2edb							;    .byte   LINE+CHARACTER_STEEL, 11,  9,  3, .DIR_RIGHT
    676  2edb							;    .byte   LINE+CHARACTER_STEEL, 15,  9,  3, .DIR_RIGHT
    677  2edb							;    .byte   LINE+CHARACTER_STEEL, 21,  9,  3, .DIR_RIGHT
    678  2edb							;    .byte   LINE+CHARACTER_STEEL, 25,  9,  3, .DIR_RIGHT
    679  2edb							;
    680  2edb							;    .byte   CHARACTER_STEEL, 13, 10
    681  2edb							;    .byte   CHARACTER_STEEL, 15, 10
    682  2edb							;    .byte   CHARACTER_STEEL, 23, 10
    683  2edb							;    .byte   CHARACTER_STEEL, 25, 10
    684  2edb							;
    685  2edb							;    .byte   LINE+CHARACTER_STEEL, 11, 11,  3, .DIR_RIGHT
    686  2edb							;    .byte   LINE+CHARACTER_STEEL, 17, 11,  3, .DIR_DOWN
    687  2edb							;    .byte   LINE+CHARACTER_STEEL, 21, 11,  3, .DIR_DOWN
    688  2edb							;    .byte   LINE+CHARACTER_STEEL, 25, 11,  3, .DIR_RIGHT
    689  2edb							;
    690  2edb							;    .byte   CHARACTER_STEEL, 17, 11
    691  2edb							;    .byte   CHARACTER_STEEL, 21, 11
    692  2edb							;
    693  2edb							;    .byte   LINE+CHARACTER_STEEL, 11, 12,  3, .DIR_RIGHT
    694  2edb							;    .byte   LINE+CHARACTER_STEEL, 15, 12,  3, .DIR_DOWN
    695  2edb							;    .byte   LINE+CHARACTER_STEEL, 17, 12,  5, .DIR_RIGHT
    696  2edb							;    .byte   LINE+CHARACTER_STEEL, 23, 12,  3, .DIR_DOWN
    697  2edb							;    .byte   LINE+CHARACTER_STEEL, 25, 12,  3, .DIR_RIGHT
    698  2edb							;
    699  2edb							;    .byte   CHARACTER_STEEL, 13, 14
    700  2edb							;    .byte   CHARACTER_STEEL, 15, 14
    701  2edb							;    .byte   CHARACTER_STEEL, 23, 14
    702  2edb							;    .byte   CHARACTER_STEEL, 25, 14
    703  2edb							;
    704  2edb							; about half way done until here...
    705  2edb							;
    706  2edb							;    .byte   CHARACTER_MANOCCUPIED, 1, 12
    707  2edb							;    .byte   CHARACTER_EXITDOOR, 38, 12
    708  2edb
    709  2edb					      ENDIF
    710  2edb
      0  2edb					      END_CAVE	INTERMISSION_3
      1  2edb		       ff		      .byte.b	$FF
      2  2edb		       00 3b	   CAVE_SIZE_INTERMISSION_3 =	* - CAVE_START
      3  2edc				  -	      IF	CAVE_SIZE_INTERMISSION_3 > MAX_CAVE_SIZE
      4  2edc				  -MAX_CAVE_SIZE SET	CAVE_SIZE_INTERMISSION_3
      5  2edc					      ENDIF
    712  2edc					      ENDIF
    713  2edc
    714  2edc
    715  2edc
    716  2edc
    717  2edc
    718  2edc							;ECHO "MAX CAVE SIZE = ", MAX_CAVE_SIZE
    719  2edc
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm
    455  2edc
      0  2edc					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  2edc		       06 dc	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $6dc , FREE= $124
      2  2edc					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2edc				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2edc				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2edc				  -	      ERR
      6  2edc					      endif
    457  2edc
    458  2edc
------- FILE ./notBoulderDash.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 3
      0  2edc					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  2edc							;------------------------------------------------------------------------------
      2  2edc							;##############################################################################
      3  2edc							;------------------------------------------------------------------------------
      0  2edc					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  355d ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
      5  3000
      6  3000							;TODOs:
      7  3000							; + store diamondsNeeded as BCD (with extra diamond flag in separate variable)
      8  3000							; + store caveTime as BCD (2 bytes)
      9  3000							; + diamonds left, time right (while playing)
     10  3000							; + six digit score, centered (short period after scoring)
     11  3000							; + player, men, cave/level (P#2 3 R, E/1) (at start of level, until Rockford appears)
     12  3000							; + make digits a bit darker
     13  3000							; o minimize space before and after digits
     14  3000							; - add missing texts (somehow)
     15  3000							;   - PAUSED (six digits)
     16  3000							;   ? OUT OF TIME (?)
     17  3000							;   ? BONUS LIFE (?)
     18  3000
     19  3000
     20  3000		       00 0e	   SCORE_COL  =	WHITE	;-2
     21  3000		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     22  3000		       00 66	   SCORE_COL_HIGH_PAL =	$66
     23  3000
     24  3000
     25  3000				   DigitVectorLOr
     26  3000		       8b 97 a4 91*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     27  300a		       5f 66 6c 73	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     28  300e				   DigitVectorLO
     29  300e		       50 5c 69 56*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     30  3018		       37		      .byte.b	<BLANKL-1
     31  3019
     32  3019
     33  3019		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     34  3019		       00 0b	   ID_DIAMOND =	11
     35  3019		       00 0c	   ID_EXTRA   =	12
     36  3019		       00 0d	   ID_CLOCK   =	13
     37  3019		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     38  3019							;ID_A	      = 13
     39  3019							;ID_B	      = 14
     40  3019							;ID_C	      = 15
     41  3019							;ID_D	      = 16
     42  3019							;ID_E	      = 17
     43  3019							;ID_F	      = 18
     44  3019							;ID_G	      = 19
     45  3019							;ID_H	      = 20
     46  3019							;ID_I	      = 21
     47  3019							;ID_J	      = 22
     48  3019							;ID_K	      = 23
     49  3019							;ID_L	      = 24
     50  3019							;ID_M	      = 25
     51  3019							;ID_N	      = 26
     52  3019							;ID_O	      = 27
     53  3019							;ID_P	      = 28
     54  3019							;ID_BONUS0   = 29
     55  3019							;ID_BONUS1   = 30
     56  3019							;ID_BONUS2   = 31
     57  3019
     58  3019							; score patch adresses:
     59  3019				   SMTblLSB
     60  3019				   SMTblDiamonds
     61  3019		       52 48		      .byte.b	SM_Diamond0+1-SM_BASE, SM_Diamond2+1-SM_BASE
     62  301b				   SMTblTime
     63  301b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     64  301d				   SMTblScore
     65  301d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     66  3020				   SMTblMSB
     67  3020		       4d 43		      .byte.b	SM_Diamond1+1-SM_BASE, SM_Diamond3+1-SM_BASE
     68  3022		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     69  3024		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     70  3027
     71  3027		       00 00	   SM_OFS_DIAMONDS =	SMTblDiamonds - SMTblLSB
     72  3027		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     73  3027		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     74  3027
     75  3027				   CharVectorLO
     76  3027		       37		      .byte.b	<BLANKL-1
     77  3028		       8e a2 af bc	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     78  302c		       ca d3 c3 89	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     79  3030		       b5 95 83 d0	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     80  3034		       da 7d a9 9c	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     81  3038							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     82  3038
     83  3038							; Digit shape definitions are at start of bank so that we don't have page boundary
     84  3038							; crossing issues.
     85  3038
     86  3038							;	  .byte 0	      ; required!
     87  3038
     88  3038		       00 07	   DIGIT_H    =	7	; height of a score digit
     89  3038
     90  3038		       00 00 00 00*BLANKL     ds	7,0
     91  303f
     92  303f				   NineL
     93  303f		       70		      .byte.b	%01110000
     94  3040		       38		      .byte.b	%00111000
     95  3041		       1c		      .byte.b	%00011100
     96  3042		       7e		      .byte.b	%01111110
     97  3043		       e6		      .byte.b	%11100110
     98  3044		       e6		      .byte.b	%11100110
     99  3045							;    .byte %01111100
    100  3045				   SixL
    101  3045		       7c		      .byte.b	%01111100
    102  3046		       fe		      .byte.b	%11111110
    103  3047		       e6		      .byte.b	%11100110
    104  3048		       e6		      .byte.b	%11100110
    105  3049		       fc		      .byte.b	%11111100
    106  304a		       e0		      .byte.b	%11100000
    107  304b							;    .byte %01111100
    108  304b				   EightL
    109  304b		       7c		      .byte.b	%01111100
    110  304c		       fe		      .byte.b	%11111110
    111  304d		       e6		      .byte.b	%11100110
    112  304e		       e6		      .byte.b	%11100110
    113  304f		       7c		      .byte.b	%01111100
    114  3050		       e6		      .byte.b	%11100110
    115  3051							;    .byte %01111100
    116  3051				   ZeroL
    117  3051		       7c		      .byte.b	%01111100
    118  3052		       fe		      .byte.b	%11111110
    119  3053		       e6		      .byte.b	%11100110
    120  3054		       e6		      .byte.b	%11100110
    121  3055		       e6		      .byte.b	%11100110
    122  3056		       e6		      .byte.b	%11100110
    123  3057							;    .byte %01111100
    124  3057				   ThreeL
    125  3057		       7c		      .byte.b	%01111100
    126  3058		       fe		      .byte.b	%11111110
    127  3059		       e6		      .byte.b	%11100110
    128  305a		       0c		      .byte.b	%00001100
    129  305b		       18		      .byte.b	%00011000
    130  305c		       0c		      .byte.b	%00001100
    131  305d							;    .byte %01111110
    132  305d				   OneL
    133  305d		       7e		      .byte.b	%01111110
    134  305e		       7e		      .byte.b	%01111110
    135  305f		       18		      .byte.b	%00011000
    136  3060		       18		      .byte.b	%00011000
    137  3061		       38		      .byte.b	%00111000
    138  3062		       38		      .byte.b	%00111000
    139  3063		       18		      .byte.b	%00011000
    140  3064
    141  3064				   SevenL
    142  3064		       e0		      .byte.b	%11100000
    143  3065		       e0		      .byte.b	%11100000
    144  3066		       70		      .byte.b	%01110000
    145  3067		       38		      .byte.b	%00111000
    146  3068		       1c		      .byte.b	%00011100
    147  3069		       8e		      .byte.b	%10001110
    148  306a							;    .byte %11111110
    149  306a				   TwoL
    150  306a		       fe		      .byte.b	%11111110
    151  306b		       fe		      .byte.b	%11111110
    152  306c		       70		      .byte.b	%01110000
    153  306d		       38		      .byte.b	%00111000
    154  306e		       1c		      .byte.b	%00011100
    155  306f		       ce		      .byte.b	%11001110
    156  3070							;    .byte %01111100
    157  3070				   FiveL
    158  3070		       7c		      .byte.b	%01111100
    159  3071		       fe		      .byte.b	%11111110
    160  3072		       ee		      .byte.b	%11101110
    161  3073		       0e		      .byte.b	%00001110
    162  3074		       fc		      .byte.b	%11111100
    163  3075		       e0		      .byte.b	%11100000
    164  3076		       fe		      .byte.b	%11111110
    165  3077
    166  3077				   FourL
    167  3077		       1c		      .byte.b	%00011100
    168  3078		       1c		      .byte.b	%00011100
    169  3079		       1c		      .byte.b	%00011100
    170  307a		       fe		      .byte.b	%11111110
    171  307b		       dc		      .byte.b	%11011100
    172  307c		       c0		      .byte.b	%11000000
    173  307d		       c0		      .byte.b	%11000000
    174  307e
    175  307e							; cave "name" characters (left only!):
    176  307e
    177  307e				   CharN
    178  307e		       73		      .byte.b	%01110011
    179  307f		       77		      .byte.b	%01110111
    180  3080		       7f		      .byte.b	%01111111
    181  3081		       7f		      .byte.b	%01111111
    182  3082		       7f		      .byte.b	%01111111
    183  3083		       7b		      .byte.b	%01111011
    184  3084							;	  .byte %01110011
    185  3084				   CharK
    186  3084		       73		      .byte.b	%01110011
    187  3085		       73		      .byte.b	%01110011
    188  3086		       76		      .byte.b	%01110110
    189  3087		       7c		      .byte.b	%01111100
    190  3088		       7c		      .byte.b	%01111100
    191  3089		       76		      .byte.b	%01110110
    192  308a							;	  .byte %01110011
    193  308a				   CharH
    194  308a		       73		      .byte.b	%01110011
    195  308b		       73		      .byte.b	%01110011
    196  308c		       73		      .byte.b	%01110011
    197  308d		       73		      .byte.b	%01110011
    198  308e		       7f		      .byte.b	%01111111
    199  308f							;	  .byte %01110011
    200  308f							;	  .byte %01110011
    201  308f				   CharA
    202  308f		       73		      .byte.b	%01110011
    203  3090		       73		      .byte.b	%01110011
    204  3091		       7f		      .byte.b	%01111111
    205  3092		       73		      .byte.b	%01110011
    206  3093		       73		      .byte.b	%01110011
    207  3094		       3e		      .byte.b	%00111110
    208  3095		       1c		      .byte.b	%00011100
    209  3096
    210  3096				   CharJ
    211  3096		       1e		      .byte.b	%00011110
    212  3097		       3f		      .byte.b	%00111111
    213  3098		       73		      .byte.b	%01110011
    214  3099		       03		      .byte.b	%00000011
    215  309a		       03		      .byte.b	%00000011
    216  309b		       03		      .byte.b	%00000011
    217  309c		       03		      .byte.b	%00000011
    218  309d
    219  309d				   CharP
    220  309d		       70		      .byte.b	%01110000
    221  309e		       70		      .byte.b	%01110000
    222  309f		       7e		      .byte.b	%01111110
    223  30a0		       7f		      .byte.b	%01111111
    224  30a1		       73		      .byte.b	%01110011
    225  30a2		       73		      .byte.b	%01110011
    226  30a3							;	  .byte %01111110
    227  30a3				   CharB
    228  30a3		       7e		      .byte.b	%01111110
    229  30a4		       7f		      .byte.b	%01111111
    230  30a5		       73		      .byte.b	%01110011
    231  30a6		       73		      .byte.b	%01110011
    232  30a7		       7e		      .byte.b	%01111110
    233  30a8		       73		      .byte.b	%01110011
    234  30a9		       7e		      .byte.b	%01111110
    235  30aa
    236  30aa				   CharO
    237  30aa		       3e		      .byte.b	%00111110
    238  30ab		       7f		      .byte.b	%01111111
    239  30ac		       63		      .byte.b	%01100011
    240  30ad		       63		      .byte.b	%01100011
    241  30ae		       63		      .byte.b	%01100011
    242  30af		       63		      .byte.b	%01100011
    243  30b0							;	  .byte %00111110
    244  30b0				   CharC
    245  30b0		       3e		      .byte.b	%00111110
    246  30b1		       7f		      .byte.b	%01111111
    247  30b2		       73		      .byte.b	%01110011
    248  30b3		       70		      .byte.b	%01110000
    249  30b4		       70		      .byte.b	%01110000
    250  30b5		       73		      .byte.b	%01110011
    251  30b6							;	  .byte %00111110
    252  30b6				   CharI
    253  30b6		       3e		      .byte.b	%00111110
    254  30b7		       3e		      .byte.b	%00111110
    255  30b8		       1c		      .byte.b	%00011100
    256  30b9		       1c		      .byte.b	%00011100
    257  30ba		       1c		      .byte.b	%00011100
    258  30bb		       1c		      .byte.b	%00011100
    259  30bc		       3e		      .byte.b	%00111110
    260  30bd
    261  30bd				   CharD
    262  30bd		       7c		      .byte.b	%01111100
    263  30be		       7e		      .byte.b	%01111110
    264  30bf		       76		      .byte.b	%01110110
    265  30c0		       73		      .byte.b	%01110011
    266  30c1		       73		      .byte.b	%01110011
    267  30c2		       76		      .byte.b	%01110110
    268  30c3		       7c		      .byte.b	%01111100
    269  30c4				   CharG
    270  30c4		       3f		      .byte.b	%00111111
    271  30c5		       7f		      .byte.b	%01111111
    272  30c6		       73		      .byte.b	%01110011
    273  30c7		       77		      .byte.b	%01110111
    274  30c8		       70		      .byte.b	%01110000
    275  30c9		       70		      .byte.b	%01110000
    276  30ca		       3f		      .byte.b	%00111111
    277  30cb
    278  30cb				   CharE
    279  30cb		       7f		      .byte.b	%01111111
    280  30cc		       7f		      .byte.b	%01111111
    281  30cd		       70		      .byte.b	%01110000
    282  30ce		       70		      .byte.b	%01110000
    283  30cf		       7e		      .byte.b	%01111110
    284  30d0		       70		      .byte.b	%01110000
    285  30d1							;	  .byte %01111111
    286  30d1				   CharL
    287  30d1		       7f		      .byte.b	%01111111
    288  30d2		       7f		      .byte.b	%01111111
    289  30d3		       70		      .byte.b	%01110000
    290  30d4							;	  .byte %01110000
    291  30d4							;	  .byte %01110000
    292  30d4							;	  .byte %01110000
    293  30d4							;	  .byte %01110000
    294  30d4				   CharF
    295  30d4		       70		      .byte.b	%01110000
    296  30d5		       70		      .byte.b	%01110000
    297  30d6		       70		      .byte.b	%01110000
    298  30d7		       70		      .byte.b	%01110000
    299  30d8		       7e		      .byte.b	%01111110
    300  30d9		       70		      .byte.b	%01110000
    301  30da		       7f		      .byte.b	%01111111
    302  30db
    303  30db				   CharM
    304  30db		       63		      .byte.b	%01100011
    305  30dc		       63		      .byte.b	%01100011
    306  30dd		       63		      .byte.b	%01100011
    307  30de		       6b		      .byte.b	%01101011
    308  30df		       7f		      .byte.b	%01111111
    309  30e0		       77		      .byte.b	%01110111
    310  30e1		       63		      .byte.b	%01100011
    311  30e2
    312  30e2				   HeadL
    313  30e2		       24		      .byte.b	%00100100
    314  30e3		       18		      .byte.b	%00011000
    315  30e4		       3c		      .byte.b	%00111100
    316  30e5		       5a		      .byte.b	%01011010
    317  30e6		       5a		      .byte.b	%01011010
    318  30e7		       3c		      .byte.b	%00111100
    319  30e8		       24		      .byte.b	%00100100
    320  30e9
    321  30e9				   IntermissionL
    322  30e9		       1e		      .byte.b	%00011110
    323  30ea		       1e		      .byte.b	%00011110
    324  30eb		       0c		      .byte.b	%00001100
    325  30ec		       0c		      .byte.b	%00001100
    326  30ed		       1e		      .byte.b	%00011110
    327  30ee		       00		      .byte.b	%00000000
    328  30ef		       0c		      .byte.b	%00001100
    329  30f0
    330  30f0							;-------------------------------------------------------------------------------------
    331  30f0				   PosTbl
    332  30f0		       40		      .byte.b	$40
    333  30f1		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    334  30f9		       b9		      .byte.b	$b9
    335  30fa
    336  30fa
    337  30fa							;------------------------------------------------------------------------------
    338  30fa							; RAM-BASED SUBROUTINES...
    339  30fa							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    340  30fa							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    341  30fa							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    342  30fa							; the RAM-based routine.
    343  30fa
    344  30fa							;z26 call ..\Tools\Z26\4A50\z26.exe -v18 -g14 -r60 $(ProjectName)$(ConfigurationName).bin
    345  30fa
    346  30fa
    347  3100		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    348  3100
    349  3100		       f1 00	   SM_BASE    =	.
    350  3100
    351  3100							;#IF 0 ;{
    352  3100							;    DEFINE_SUBROUTINE Score3x3
    353  3100							;
    354  3100							;	  sta	  RESP0
    355  3100							;	   sta	   RESP1
    356  3100							;	   lda	   #$$000
    357  3100							;	    sta     GRP0
    358  3100							;	    lda     #$$009
    359  3100							;	    sta     GRP1
    360  3100							;	    lda     #$$202
    361  3100							;	    sta     ENABL
    362  3100							;	    nop
    363  3100							;	    nop
    364  3100							;	    nop
    365  3100							;	    lda     #$$016
    366  3100							;	    ldy     #$$100
    367  3100							;	    ldx     #$$109
    368  3100							;	    sta     GRP0    ; Critical time is right here
    369  3100							;	    stx     GRP1
    370  3100							;	    sty     GRP0
    371  3100							;	    sta     RESP0
    372  3100							;	    sta     RESP1
    373  3100							;	    ldx     #$$116
    374  3100							;	    lda     #$$209
    375  3100							;	    stx     GRP0
    376  3100							;	    sta     GRP1
    377  3100							;	    lda     #$$200
    378  3100							;	    sta     GRP0
    379  3100							;	    sta     RESP0
    380  3100							;	    sta     RESP1
    381  3100							;	    lda     #$$216
    382  3100							;	    nop
    383  3100							;	    sta     GRP0
    384  3100							;
    385  3100							;	      rts
    386  3100							;#ENDIF ;}
    387  3100
    388  3100
    389  3100							;------------------------------------------------------------------------------
    390  3100				   Score1x6Fix SUBROUTINE
      0  3100					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  3100		       00 06	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  3100					      SUBROUTINE
      3  3100				   DrawDigits1x6
    392  3100							;					     @07
    393  3100		       ba		      tsx		; 2
    394  3101
    395  3101		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 58    @65
    396  3104
    397  3104		       86 df		      stx	tmpStack	; 3 =	3
    398  3106
    399  3106				   LoopDraw1x6		;
    400  3106				   SMDIGIT0
    401  3106		       b9 8b f3 	      lda	ZeroR-1,y	; 4
    402  3109		       85 42		      sta	WSYNC	; 3
    403  310b							;---------------------------------------------------------------
    404  310b		       85 6a		      sta	HMOVE	; 3
      0  310d					      SLEEP	3	; 3 =	6
      1  310d				   .CYCLES    SET	3
      2  310d
      3  310d				  -	      IF	.CYCLES < 2
      4  310d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  310d				  -	      ERR
      6  310d					      ENDIF
      7  310d
      8  310d					      IF	.CYCLES & 1
      9  310d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  310d		       04 00		      nop	0
     11  310f				  -	      ELSE
     12  310f				  -	      bit	VSYNC
     13  310f					      ENDIF
     14  310f				   .CYCLES    SET	.CYCLES - 3
     15  310f					      ENDIF
     16  310f
     17  310f				  -	      REPEAT	.CYCLES / 2
     18  310f				  -	      nop
     19  310f					      REPEND
    406  310f		       85 5b		      sta	GRP0	; 3
    407  3111				   SMDIGIT1
    408  3111		       b9 50 f0 	      lda	ZeroL-1,y	; 4
    409  3114		       85 5c		      sta	GRP1	; 3
    410  3116				   SMDIGIT2
    411  3116		       b9 8b f3 	      lda	ZeroR-1,y	; 4
    412  3119		       85 5b		      sta	GRP0	; 3 = 17
    413  311b				   SMDIGIT5
    414  311b		       be 50 f0 	      ldx	ZeroL-1,y	; 4
    415  311e		       9a		      txs		; 2
    416  311f				   SMDIGIT3
    417  311f		       be 50 f0 	      ldx	ZeroL-1,y	; 4
    418  3122				   SMDIGIT4
    419  3122		       b9 8b f3 	      lda	ZeroR-1,y	; 4
    420  3125		       85 6b		      sta	HMCLR	; 3
    421  3127		       86 5c		      stx	GRP1	; 3
    422  3129		       85 5b		      sta	GRP0	; 3 = 23
    423  312b
    424  312b		       ba		      tsx		; 2
    425  312c		       86 5c		      stx	GRP1	; 3
    426  312e		       85 5b		      sta	GRP0	; 3 =	8
    427  3130
    428  3130		       88		      dey		; 2
      0  3131					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  3131					      LIST	ON
      9  3131		       d0 d3		      bne	LoopDraw1x6
    430  3133
    431  3133		       a6 df		      ldx	tmpStack	; 3
    432  3135		       9a		      txs		; 2
    433  3136				   ExitDigitKernel6
      0  3136					      SLEEP	3	; 3
      1  3136				   .CYCLES    SET	3
      2  3136
      3  3136				  -	      IF	.CYCLES < 2
      4  3136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  3136				  -	      ERR
      6  3136					      ENDIF
      7  3136
      8  3136					      IF	.CYCLES & 1
      9  3136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  3136		       04 00		      nop	0
     11  3138				  -	      ELSE
     12  3138				  -	      bit	VSYNC
     13  3138					      ENDIF
     14  3138				   .CYCLES    SET	.CYCLES - 3
     15  3138					      ENDIF
     16  3138
     17  3138				  -	      REPEAT	.CYCLES / 2
     18  3138				  -	      nop
     19  3138					      REPEND
    435  3138		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    436  313b
    437  313b
    438  313b							;------------------------------------------------------------------------------
    439  313b				   Score2x4Fix SUBROUTINE
      0  313b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  313b		       00 06	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  313b					      SUBROUTINE
      3  313b				   DrawDigits2x4
    441  313b
    442  313b
    443  313b							; Subroutine by Thomas Jentzsch.  Magic!
    444  313b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    445  313b
    446  313b		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 56    @63
    447  313e
    448  313e		       85 6a		      sta	HMOVE	; 3
      0  3140					      SLEEP	4	; 4  =  7
      1  3140				   .CYCLES    SET	4
      2  3140
      3  3140				  -	      IF	.CYCLES < 2
      4  3140				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  3140				  -	      ERR
      6  3140					      ENDIF
      7  3140
      8  3140				  -	      IF	.CYCLES & 1
      9  3140				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  3140				  -	      nop	0
     11  3140				  -	      ELSE
     12  3140				  -	      bit	VSYNC
     13  3140				  -	      ENDIF
     14  3140				  -.CYCLES    SET	.CYCLES - 3
     15  3140					      ENDIF
     16  3140
     17  3140					      REPEAT	.CYCLES / 2
     18  3140		       ea		      nop
     17  3140					      REPEND
     18  3141		       ea		      nop
     19  3142					      REPEND
    450  3142
    451  3142				   LoopDraw2x4		;	     @70
    452  3142				   SM_Diamond3
    453  3142		       b9 66 f3 	      lda	DequalsR-1,y	; 4		     G
    454  3145							;---------------------------------------------------------------
    455  3145		       85 5b		      sta	GRP0	; 3
    456  3147				   SM_Diamond2
    457  3147		       b9 50 f0 	      lda	ZeroL-1,y	; 4		     A
    458  314a		       85 5c		      sta	GRP1	; 3
    459  314c				   SM_Diamond1
    460  314c		       b9 8b f3 	      lda	ZeroR-1,y	; 4		     M
    461  314f		       85 5b		      sta	GRP0	; 3
    462  3151				   SM_Diamond0
    463  3151		       be 50 f0 	      ldx	ZeroL-1,y	; 4		     E
    464  3154		       85 50		      sta	RESP0	; 3 = 28    @22
    465  3156		       85 51		      sta	RESP1	; 3 =	3    @25
    466  3158				   SM_Time3
    467  3158		       b9 73 f3 	      lda	ClockR-1,y	; 4		     O
    468  315b		       86 5c		      stx	GRP1	; 3
    469  315d		       85 5b		      sta	GRP0	; 3
    470  315f				   SM_Time2
    471  315f		       b9 50 f0 	      lda	ZeroL-1,y	; 4		     V
    472  3162		       85 5c		      sta	GRP1	; 3
    473  3164				   SM_Time1
    474  3164		       b9 8b f3 	      lda	ZeroR-1,y	; 4		     E
    475  3167		       85 5b		      sta	GRP0	; 3
    476  3169		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    477  316b		       85 51		      sta	RESP1	; 3 =	3    @55
    478  316d				   SM_Time0
    479  316d		       b9 50 f0 	      lda	ZeroL-1,y	; 4		     R
    480  3170		       85 5c		      sta	GRP1	; 3
    481  3172		       85 5b		      sta	GRP0	; 3
    482  3174		       88		      dey		; 2
      0  3175					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  3175					      LIST	ON
      9  3175		       d0 cb		      bne	LoopDraw2x4
    484  3177
    485  3177				   ExitDigitKernel		;	     @69
    486  3177		       84 5b		      sty	GRP0	; 3
    487  3179		       84 5c		      sty	GRP1	; 3
    488  317b							;---------------------------------------------------------------
    489  317b		       84 5b		      sty	GRP0	; 3	     @02
    490  317d
    491  317d							; Contribution by Thomas Jentzsch
    492  317d							; Rewrite/Optimised for single sprite AD
    493  317d
    494  317d		       a6 a1		      ldx	ManDrawX	; 3
    495  317f		       bd f0 f0 	      lda	PosTbl,x	; 4
    496  3182		       85 60		      sta	HMP0	; 3
    497  3184		       29 0f		      and	#$0f	; 2
    498  3186		       f0 04		      beq	.zeroPos	; 2/3=15
    499  3188		       aa		      tax		; 2
    500  3189				   .loopWait
    501  3189		       ca		      dex		; 2
    502  318a		       d0 fd		      bne	.loopWait	; 2/3= 6
    503  318c				   .zeroPos
    504  318c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    505  318e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    506  3190		       a5 af		      lda	BGColour	; 3
    507  3192		       86 62		      stx	HMM0	; 3	     for extra life stars!
    508  3194		       85 42		      sta	WSYNC	; 3
    509  3196							;---------------------------------------------------------------
    510  3196		       85 6a		      sta	HMOVE	; 3
    511  3198		       60		      rts		; 6	     @09
    512  3199
    513  3199							;------------------------------------------------------------------------------
    514  3199				   Score3x2Fix SUBROUTINE
      0  3199					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  3199		       00 06	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  3199					      SUBROUTINE
      3  3199				   DrawDigits3x2
    516  3199							;					     @07
    517  3199		       a9 16		      lda	#%010110	; 2
    518  319b		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    519  319d		       20 f4 f1 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    520  31a0
    521  31a0		       a9 00		      lda	#0
    522  31a2		       85 66		      sta	VDELP1
    523  31a4				   LoopDraw3x2		;
    524  31a4		       85 42		      sta	WSYNC	; 3
    525  31a6							;---------------------------------------------------------------
    526  31a6		       85 6a		      sta	HMOVE	; 3 =	3
    527  31a8		       b9 9c f0 	      lda	CharP-1,y	; 4
    528  31ab		       85 5b		      sta	GRP0	; 3
    529  31ad				   SMPLAYER
    530  31ad		       b9 97 f3 	      lda	OneR-1,y	; 4
    531  31b0		       85 5c		      sta	GRP1	; 3 = 14    @17
    532  31b2		       b9 e1 f0 	      lda	HeadL-1,y	; 4
    533  31b5				   SMMEN
    534  31b5		       be 91 f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  31b8					      SLEEP	5	;   =	5
      1  31b8				   .CYCLES    SET	5
      2  31b8
      3  31b8				  -	      IF	.CYCLES < 2
      4  31b8				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  31b8				  -	      ERR
      6  31b8					      ENDIF
      7  31b8
      8  31b8					      IF	.CYCLES & 1
      9  31b8					      IFNCONST	NO_ILLEGAL_OPCODES
     10  31b8		       04 00		      nop	0
     11  31ba				  -	      ELSE
     12  31ba				  -	      bit	VSYNC
     13  31ba					      ENDIF
     14  31ba				   .CYCLES    SET	.CYCLES - 3
     15  31ba					      ENDIF
     16  31ba
     17  31ba					      REPEAT	.CYCLES / 2
     18  31ba		       ea		      nop
     19  31bb					      REPEND
    536  31bb		       85 5b		      sta	GRP0	; 3
    537  31bd				   SMCAVE
    538  31bd		       b9 8e f0 	      lda	CharA-1,y	; 4
    539  31c0		       85 6b		      sta	HMCLR	; 3 = 10    @40
    540  31c2		       86 5c		      stx	GRP1	; 3 =	3    @43
    541  31c4		       85 5b		      sta	GRP0	; 3
    542  31c6				   SMLEVEL
    543  31c6		       b9 97 f3 	      lda	OneR-1,y	; 4
    544  31c9		       85 5c		      sta	GRP1	; 3 = 10    @53
    545  31cb
    546  31cb		       88		      dey		; 2
      0  31cc					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  31cc					      LIST	ON
      9  31cc		       d0 d6		      bne	LoopDraw3x2
    548  31ce							;					     @57
      0  31ce					      SLEEP	3	; 3
      1  31ce				   .CYCLES    SET	3
      2  31ce
      3  31ce				  -	      IF	.CYCLES < 2
      4  31ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  31ce				  -	      ERR
      6  31ce					      ENDIF
      7  31ce
      8  31ce					      IF	.CYCLES & 1
      9  31ce					      IFNCONST	NO_ILLEGAL_OPCODES
     10  31ce		       04 00		      nop	0
     11  31d0				  -	      ELSE
     12  31d0				  -	      bit	VSYNC
     13  31d0					      ENDIF
     14  31d0				   .CYCLES    SET	.CYCLES - 3
     15  31d0					      ENDIF
     16  31d0
     17  31d0				  -	      REPEAT	.CYCLES / 2
     18  31d0				  -	      nop
     19  31d0					      REPEND
    550  31d0		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    551  31d3
    552  31d3
    553  31d3							;------------------------------------------------------------------------------
      0  31d3					      DEFINE_SUBROUTINE	DrawDigits
      1  31d3		       00 06	   BANK_DrawDigits =	_CURRENT_BANK
      2  31d3					      SUBROUTINE
      3  31d3				   DrawDigits
    555  31d3
    556  31d3				   VblankLoopBD
    557  31d3		       ac 84 02 	      ldy	INTIM
    558  31d6		       d0 fb		      bne	VblankLoopBD
    559  31d8
    560  31d8		       84 41		      sty	VBLANK	; 3	     <-- 0
    561  31da		       a5 c8		      lda	scoringFlags	; 3
    562  31dc		       29 03		      and	#DISPLAY_FLAGS	; 2
    563  31de		       aa		      tax		; 2
    564  31df
    565  31df							;    DEFINE_SUBROUTINE DrawDigit2
    566  31df							;
    567  31df							;    ; Generic interface to scoring routine
    568  31df
    569  31df		       bd ea f1 	      lda	ScoreKernelLo,x	; 4
    570  31e2
    571  31e2		       85 42		      sta	WSYNC	; 3
    572  31e4							;---------------------------------------------------------------
    573  31e4		       8d e8 f5 	      sta	SMJUMP+1+RAM_WRITE	; 4
    574  31e7				   SMJUMP
    575  31e7		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    576  31ea
    577  31ea				   ScoreKernelLo
    578  31ea		       3b		      .byte.b	<Score2x4Fix	; diamonds, time
    579  31eb		       00		      .byte.b	<Score1x6Fix	; score
    580  31ec		       99		      .byte.b	<Score3x2Fix	; player, lives, cave/level
    581  31ed		       00		      .byte.b	<Score1x6Fix	; high score
    582  31ee
      0  31ee					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  31ee					      LIST	ON
    584  31ee
    585  31ee							;------------------------------------------------------------------------------
      0  31ee					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  31ee		       00 06	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  31ee					      SUBROUTINE
      3  31ee				   PrepareDrawDigits
    587  31ee							;					     @13
    588  31ee		       a0 d1		      ldy	#$d1	; 2
    589  31f0		       a9 13		      lda	#%010011	; 2
    590  31f2		       85 66		      sta	VDELP1	; 3 =	7
    591  31f4				   PrepareDrawDigits2		;	    @17/20
    592  31f4		       84 65		      sty	VDELP0	; 3 =	3
    593  31f6
    594  31f6		       85 45		      sta	NUSIZ1	; 3
    595  31f8		       85 44		      sta	NUSIZ0	; 3 =	6
    596  31fa
    597  31fa		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    598  31fd		       85 50		      sta	RESP0	; 3	     @33/36
    599  31ff		       85 51		      sta	RESP1	; 3 = 10    @36/39
    600  3201
    601  3201		       84 60		      sty	HMP0	; 3
    602  3203		       c8		      iny		; 2
    603  3204		       84 61		      sty	HMP1	; 3 =	8
    604  3206				   SMCOLOR
    605  3206		       a0 0e		      ldy	#SCORE_COL	; 2
    606  3208		       84 46		      sty	COLUP0	; 3
    607  320a		       84 47		      sty	COLUP1	; 3 =	8
    608  320c
    609  320c		       a0 07		      ldy	#DIGIT_H	; 2
    610  320e		       60		      rts		; 6 =	8
    611  320f							; total: 27
    612  320f
    613  320f
    614  320f							;------------------------------------------------------------------------------
      0  320f					      DEFINE_SUBROUTINE	UpdateScore
      1  320f		       00 06	   BANK_UpdateScore =	_CURRENT_BANK
      2  320f					      SUBROUTINE
      3  320f				   UpdateScore
    616  320f							; a = added score value
    617  320f
    618  320f							; initially switch to score:
    619  320f		       a0 01		      ldy	#DISPLAY_SCORE
    620  3211		       84 df		      sty	newDisplay
    621  3213
    622  3213		       18		      clc
    623  3214		       f8		      sed
    624  3215		       a0 04		      ldy	#SM_OFS_SCORE
    625  3217				   .loopScore
    626  3217		       79 ec f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    627  321a		       99 ec f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    628  321d		       08		      php
    629  321e							; *** bonus life every 500 points: ***
    630  321e		       c0 05		      cpy	#SM_OFS_SCORE+1
    631  3220		       d0 1c		      bne	.skipBonusLife
    632  3222		       aa		      tax
    633  3223
    634  3223		       29 0f		      and	#$0f
    635  3225		       f0 04		      beq	.bonusLife	; 000?
    636  3227		       c9 05		      cmp	#$05
    637  3229		       d0 12		      bne	.noBonusLife	; 500?
    638  322b				   .bonusLife
    639  322b							; add extra life, limited to 9
    640  322b
    641  322b		       a5 ab		      lda	MenCurrent
    642  322d		       29 0f		      and	#$0f
    643  322f		       c9 09		      cmp	#9
    644  3231		       b0 0a		      bcs	.noBonusLife
    645  3233		       e6 ab		      inc	MenCurrent
    646  3235
    647  3235							; bonus life has priority over score:
    648  3235		       a9 02		      lda	#DISPLAY_LIVES
    649  3237		       85 df		      sta	newDisplay
    650  3239		       a9 ff		      lda	#EXTRA_LIFE_TIMER
    651  323b		       85 c6		      sta	extraLifeTimer
    652  323d
    653  323d				   .noBonusLife
    654  323d		       8a		      txa
    655  323e				   .skipBonusLife
    656  323e		       20 40 f3 	      jsr	SetupBCDPtr
    657  3241		       28		      plp
    658  3242		       a9 00		      lda	#0
    659  3244		       b0 d1		      bcs	.loopScore
    660  3246		       d8		      cld
    661  3247
    662  3247							; switch display
    663  3247		       a5 c8		      lda	scoringFlags
    664  3249		       29 03		      and	#DISPLAY_FLAGS
    665  324b		       c5 df		      cmp	newDisplay	; lower priority than current?
    666  324d		       f0 08		      beq	.restartTime
    667  324f		       b0 0a		      bcs	.skipNew
    668  3251		       45 c8		      eor	scoringFlags	; remove existing score mode
    669  3253		       05 df		      ora	newDisplay	; switch to new score mode
    670  3255		       85 c8		      sta	scoringFlags
    671  3257				   .restartTime
    672  3257		       a9 3c		      lda	#SCORING_TIMER	; maybe always restart timer?
    673  3259		       85 c7		      sta	scoringTimer
    674  325b				   .skipNew
    675  325b
    676  325b		       60		      rts
    677  325c
    678  325c							;---------------------------------------------------------------------------
    679  325c
      0  325c					      DEFINE_SUBROUTINE	SwapPlayers
      1  325c		       00 06	   BANK_SwapPlayers =	_CURRENT_BANK
      2  325c					      SUBROUTINE
      3  325c				   SwapPlayers
    681  325c
    682  325c							; assume no new high score:
    683  325c		       a0 ff		      ldy	#-1
    684  325e		       84 e2		      sty	highScoreSK
    685  3260
    686  3260							; update highscore after last live:
    687  3260		       a5 ab		      lda	MenCurrent
    688  3262		       29 0f		      and	#$0f	; player has lives left?
    689  3264		       d0 1c		      bne	.playerAlive	; YES, so we don't check high score
    690  3266
    691  3266							; check for a new high score:
    692  3266							;	  ldy #-1
    693  3266		       18		      clc		; score has to be at least 1 bigger!
    694  3267				   .loopCheckHighScore
    695  3267		       c8		      iny
    696  3268		       b9 f0 f3 	      lda	ScoreCurrent,y
    697  326b		       f9 fa f3 	      sbc	HighScore,y
    698  326e		       98		      tya
    699  326f		       49 02		      eor	#2
    700  3271		       d0 f4		      bne	.loopCheckHighScore
    701  3273		       90 0d		      bcc	.noHighScore
    702  3275
    703  3275							; new high score, update:
    704  3275		       a2 04		      ldx	#5-1
    705  3277				   .loopSetHighScore
    706  3277		       bd f0 f3 	      lda	ScoreCurrent,x
    707  327a		       9d fa f7 	      sta	HighScore+RAM_WRITE,x
    708  327d		       95 e2		      sta	highScoreSK,x
    709  327f		       ca		      dex
    710  3280		       10 f5		      bpl	.loopSetHighScore
    711  3282				   .noHighScore
    712  3282
    713  3282				   .playerAlive
    714  3282		       a5 ab		      lda	MenCurrent
    715  3284		       29 f0		      and	#$f0	; other player has lives left?
    716  3286		       f0 21		      beq	.otherPlayerDead	; NO, so we don't swap scores
    717  3288
    718  3288							; save the current player variables to the player's backup:
    719  3288		       a0 02		      ldy	#3-1
    720  328a				   .swapScore
    721  328a		       be f5 f3 	      ldx	PlayerScores,y
    722  328d		       b9 f0 f3 	      lda	ScoreCurrent,y
    723  3290		       99 f5 f7 	      sta	PlayerScores+RAM_WRITE,y
    724  3293		       8a		      txa
    725  3294		       99 f0 f7 	      sta	ScoreCurrent+RAM_WRITE,y
    726  3297		       88		      dey
    727  3298		       10 f0		      bpl	.swapScore
    728  329a
    729  329a							; swap cave and level:
    730  329a		       a2 01		      ldx	#1
    731  329c				   .loopCaveLevel
    732  329c		       bc f8 f3 	      ldy	PlayerCave,x
    733  329f		       b5 b0		      lda	cave,x
    734  32a1		       9d f8 f7 	      sta	PlayerCave+RAM_WRITE,x
    735  32a4		       94 b0		      sty	cave,x
    736  32a6		       ca		      dex
    737  32a7		       10 f3		      bpl	.loopCaveLevel
    738  32a9
    739  32a9				   .otherPlayerDead
    740  32a9		       60		      rts
    741  32aa
    742  32aa							;---------------------------------------------------------------------------
    743  32aa
    744  32aa				   HighScoreColTbl
    745  32aa		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    746  32ac		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    747  32ae
      0  32ae					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  32ae		       00 06	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  32ae					      SUBROUTINE
      3  32ae				   GeneralScoringSetups
    749  32ae
    750  32ae		       a0 04		      ldy	#SM_OFS_SCORE
    751  32b0				   .loopScore2
    752  32b0		       a5 c8		      lda	scoringFlags
    753  32b2		       29 03		      and	#DISPLAY_FLAGS
    754  32b4		       c9 03		      cmp	#DISPLAY_HIGH
    755  32b6		       a6 81		      ldx	Platform
    756  32b8		       bd aa f2 	      lda	HighScoreColTbl,x
    757  32bb		       aa		      tax
    758  32bc		       b9 f6 f3 	      lda	HighScore-SM_OFS_SCORE,y
    759  32bf		       b0 05		      bcs	.showHighScore
    760  32c1		       a2 0e		      ldx	#SCORE_COL
    761  32c3		       b9 ec f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    762  32c6				   .showHighScore
    763  32c6		       8e 07 f6 	      stx	SMCOLOR+1+RAM_WRITE
    764  32c9		       20 40 f3 	      jsr	SetupBCDPtr
    765  32cc		       c0 07		      cpy	#SM_OFS_SCORE+3
    766  32ce		       90 e0		      bcc	.loopScore2
    767  32d0
    768  32d0							; display number of lives in leftmost digit of middle score XX nX XX
    769  32d0
    770  32d0		       a5 ab		      lda	MenCurrent
    771  32d2		       29 0f		      and	#$0f
    772  32d4		       a8		      tay
    773  32d5		       b9 00 f0 	      lda	DigitVectorLOr,y
    774  32d8		       8d b6 f5 	      sta	SMMEN+1+RAM_WRITE
    775  32db
    776  32db							; modify player number pointer (Xp XX XX)
    777  32db
    778  32db		       a4 9e		      ldy	whichPlayer
    779  32dd		       b9 01 f0 	      lda	DigitVectorLOr+1,y
    780  32e0		       8d ae f5 	      sta	SMPLAYER+1+RAM_WRITE
    781  32e3
    782  32e3							; fall through
    783  32e3
    784  32e3							;    ;---------------------------------------------------------------------------
    785  32e3
    786  32e3							; modify cave character pointer (XX XX cX)
    787  32e3
    788  32e3		       a2 e8		      ldx	#<IntermissionL-1
    789  32e5		       a5 b2		      lda	caveDisplay
    790  32e7		       c9 80		      cmp	#$80
    791  32e9		       29 1f		      and	#$1f
    792  32eb		       a8		      tay
    793  32ec		       b0 05		      bcs	.intermission
    794  32ee		       be 27 f0 	      ldx	CharVectorLO,y
    795  32f1		       a4 b1		      ldy	level
    796  32f3				   .intermission
    797  32f3		       8e be f5 	      stx	SMCAVE+1+RAM_WRITE
    798  32f6
    799  32f6							; modify level number pointer (XX XX Xl)
    800  32f6
    801  32f6		       b9 01 f0 	      lda	DigitVectorLOr+1,y
    802  32f9		       8d c7 f5 	      sta	SMLEVEL+1+RAM_WRITE
    803  32fc
    804  32fc							;---------------------------------------------------------------------------
    805  32fc
    806  32fc		       20 05 f3 	      jsr	SetupDiamondsPtr	; modify required diamonds pointers
    807  32ff		       4c 37 f3 	      jmp	SetupTimePtr	; modify time pointers
    808  3302
    809  3302							;------------------------------------------------------------------------------
    810  3302							;    DEFINE_SUBROUTINE SetupGameOverPtr
    811  3302
    812  3302							;		  ldy #8-1
    813  3302							;.loopGameOver:
    814  3302							;		  ldx SMGameOverOfs,y
    815  3302							;		  lda SMGameOverPtr,y
    816  3302							;		  sta SM_BASE+1+RAM_WRITE,x
    817  3302							;		  dey
    818  3302							;		  bpl .loopGameOver
    819  3302
    820  3302							;		  rts
    821  3302
    822  3302							;SMGameOverOfs:
    823  3302							;		  .byte <SM_Diamond3-SM_BASE, <SM_Diamond2-SM_BASE
    824  3302							;		  .byte <SM_Diamond1-SM_BASE, <SM_Diamond0-SM_BASE
    825  3302							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    826  3302							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    827  3302							;SMGameOverPtr:
    828  3302							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    829  3302							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    830  3302
    831  3302							;------------------------------------------------------------------------------
      0  3302					      DEFINE_SUBROUTINE	GetDiamond
      1  3302		       00 06	   BANK_GetDiamond =	_CURRENT_BANK
      2  3302					      SUBROUTINE
      3  3302				   GetDiamond
    833  3302
    834  3302		       20 0f f2 	      jsr	UpdateScore	;looong!
    835  3305
    836  3305							;------------------------------------------------------------------------------
      0  3305					      DEFINE_SUBROUTINE	SetupDiamondsPtr
      1  3305		       00 06	   BANK_SetupDiamondsPtr =	_CURRENT_BANK
      2  3305					      SUBROUTINE
      3  3305				   SetupDiamondsPtr
    838  3305							; Show current diamond counter in the top left
    839  3305
    840  3305		       a0 00		      ldy	#SM_OFS_DIAMONDS
    841  3307		       a5 b6		      lda	diamondsNeeded
    842  3309		       20 40 f3 	      jsr	SetupBCDPtr
    843  330c
    844  330c		       a9 b0		      lda	#ID_DIAMOND<<4	; if no extra diamonds, display the normal icon
    845  330e		       24 c8		      bit	scoringFlags	;
    846  3310		       10 2e		      bpl	SetupBCDPtr
    847  3312		       a9 c0		      lda	#ID_EXTRA<<4	; otherwise, display the extra icon
    848  3314		       50 2a		      bvc	SetupBCDPtr
    849  3316		       09 01		      ora	#1	; display 1xx diamonds
    850  3318		       d0 26		      bne	SetupBCDPtr	; unconditional
    851  331a
    852  331a							;------------------------------------------------------------------------------
      0  331a					      DEFINE_SUBROUTINE	DrawTime
      1  331a		       00 06	   BANK_DrawTime =	_CURRENT_BANK
      2  331a					      SUBROUTINE
      3  331a				   DrawTime
    854  331a
    855  331a							; mid-digit-change, but we may be required to flash/display
    856  331a		       a0 02		      ldy	#SM_OFS_TIME
    857  331c		       a5 ba		      lda	caveTimeHi
    858  331e		       d0 17		      bne	BGOK
    859  3320		       a5 b9		      lda	caveTime
    860  3322		       c9 0a		      cmp	#RED_TIME_WARNING
    861  3324		       b0 11		      bcs	BGOK
    862  3326		       a5 bb		      lda	caveTimeFrac
    863  3328		       69 20		      adc	#$20
    864  332a		       29 60		      and	#$60	; 75% on, 25% off
    865  332c		       d0 09		      bne	BGOK
    866  332e
    867  332e		       a9 aa		      lda	#ID_BLANK<<4|ID_BLANK
    868  3330		       20 40 f3 	      jsr	SetupBCDPtr
    869  3333		       a9 da		      lda	#ID_CLOCK<<4|ID_BLANK
    870  3335		       d0 09		      bne	SetupBCDPtr	; ASSUMES ID_BLANK != 0
    871  3337				   BGOK
    872  3337							;------------------------------------------------------------------------------
      0  3337					      DEFINE_SUBROUTINE	SetupTimePtr
      1  3337		       00 06	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  3337					      SUBROUTINE
      3  3337				   SetupTimePtr
    874  3337
    875  3337		       a5 b9		      lda	caveTime
    876  3339		       20 40 f3 	      jsr	SetupBCDPtr
    877  333c		       a5 ba		      lda	caveTime+1
    878  333e		       09 d0		      ora	#ID_CLOCK<<4
    879  3340
    880  3340							; fall through
    881  3340
    882  3340							;------------------------------------------------------------------------------
      0  3340					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  3340		       00 06	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  3340					      SUBROUTINE
      3  3340				   SetupBCDPtr
    884  3340
    885  3340							; a = BCD value
    886  3340							; y = SM table offset
    887  3340
    888  3340		       48		      pha
    889  3341		       29 0f		      and	#$0f
    890  3343		       aa		      tax
    891  3344		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    892  3347		       be 19 f0 	      ldx	SMTblLSB,y
    893  334a		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    894  334d		       68		      pla
    895  334e		       4a		      lsr
    896  334f		       4a		      lsr
    897  3350		       4a		      lsr
    898  3351		       4a		      lsr
    899  3352		       aa		      tax
    900  3353		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    901  3356		       be 20 f0 	      ldx	SMTblMSB,y
    902  3359		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    903  335c
    904  335c		       c8		      iny
    905  335d
    906  335d		       a5 c3		      lda	ROM_Bank
    907  335f				   RTS
    908  335f		       60		      rts
    909  3360
      0  3360					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
     10  3360					      LIST	ON
    911  3360
    912  3360				  -	      IF	<. = 0
    913  3360				  -	      .byte	0	; required!
    914  3360					      ENDIF
    915  3360
    916  3360				   BLANKR
    917  3360		       00 00 00 00*	      .ds	DIGIT_H, 0
    918  3367
    919  3367				   DequalsR
    920  3367		       10		      .byte.b	%00010000
    921  3368		       28		      .byte.b	%00101000
    922  3369		       44		      .byte.b	%01000100
    923  336a		       82		      .byte.b	%10000010
    924  336b		       44		      .byte.b	%01000100
    925  336c		       28		      .byte.b	%00101000
    926  336d							;    .byte %00010000
    927  336d				   DplusR
    928  336d		       10		      .byte.b	%00010000
    929  336e		       28		      .byte.b	%00101000
    930  336f		       6c		      .byte.b	%01101100
    931  3370		       c6		      .byte.b	%11000110
    932  3371		       6c		      .byte.b	%01101100
    933  3372		       28		      .byte.b	%00101000
    934  3373		       10		      .byte.b	%00010000
    935  3374
    936  3374				   ClockR
    937  3374		       38		      .byte.b	%00111000
    938  3375		       44		      .byte.b	%01000100
    939  3376		       a2		      .byte.b	%10100010
    940  3377		       92		      .byte.b	%10010010
    941  3378		       92		      .byte.b	%10010010
    942  3379		       54		      .byte.b	%01010100
    943  337a							;	  .byte %00111000
    944  337a				   NineR
    945  337a		       38		      .byte.b	%00111000
    946  337b		       1c		      .byte.b	%00011100
    947  337c		       0e		      .byte.b	%00001110
    948  337d		       3f		      .byte.b	%00111111
    949  337e		       73		      .byte.b	%01110011
    950  337f		       73		      .byte.b	%01110011
    951  3380							;	  .byte %00111110
    952  3380				   SixR
    953  3380		       3e		      .byte.b	%00111110
    954  3381		       7f		      .byte.b	%01111111
    955  3382		       73		      .byte.b	%01110011
    956  3383		       73		      .byte.b	%01110011
    957  3384		       7e		      .byte.b	%01111110
    958  3385		       70		      .byte.b	%01110000
    959  3386							;	  .byte %00111110
    960  3386				   EightR
    961  3386		       3e		      .byte.b	%00111110
    962  3387		       7f		      .byte.b	%01111111
    963  3388		       73		      .byte.b	%01110011
    964  3389		       73		      .byte.b	%01110011
    965  338a		       3e		      .byte.b	%00111110
    966  338b		       73		      .byte.b	%01110011
    967  338c							;	  .byte %00111110
    968  338c				   ZeroR
    969  338c		       3e		      .byte.b	%00111110
    970  338d		       7f		      .byte.b	%01111111
    971  338e		       73		      .byte.b	%01110011
    972  338f		       73		      .byte.b	%01110011
    973  3390		       73		      .byte.b	%01110011
    974  3391		       73		      .byte.b	%01110011
    975  3392							;	  .byte %00111110
    976  3392				   ThreeR
    977  3392		       3e		      .byte.b	%00111110
    978  3393		       7f		      .byte.b	%01111111
    979  3394		       73		      .byte.b	%01110011
    980  3395		       06		      .byte.b	%00000110
    981  3396		       0c		      .byte.b	%00001100
    982  3397		       06		      .byte.b	%00000110
    983  3398							;	  .byte %00111111
    984  3398				   OneR
    985  3398		       3f		      .byte.b	%00111111
    986  3399		       3f		      .byte.b	%00111111
    987  339a		       0c		      .byte.b	%00001100
    988  339b		       0c		      .byte.b	%00001100
    989  339c		       1c		      .byte.b	%00011100
    990  339d		       1c		      .byte.b	%00011100
    991  339e		       0c		      .byte.b	%00001100
    992  339f
    993  339f				   SevenR
    994  339f		       70		      .byte.b	%01110000
    995  33a0		       70		      .byte.b	%01110000
    996  33a1		       38		      .byte.b	%00111000
    997  33a2		       1c		      .byte.b	%00011100
    998  33a3		       0e		      .byte.b	%00001110
    999  33a4		       43		      .byte.b	%01000011
   1000  33a5							;	  .byte %01111111
   1001  33a5				   TwoR
   1002  33a5		       7f		      .byte.b	%01111111
   1003  33a6		       7f		      .byte.b	%01111111
   1004  33a7		       38		      .byte.b	%00111000
   1005  33a8		       1c		      .byte.b	%00011100
   1006  33a9		       0e		      .byte.b	%00001110
   1007  33aa		       67		      .byte.b	%01100111
   1008  33ab							;	  .byte %00111110
   1009  33ab				   FiveR
   1010  33ab		       3e		      .byte.b	%00111110
   1011  33ac		       7f		      .byte.b	%01111111
   1012  33ad		       77		      .byte.b	%01110111
   1013  33ae		       07		      .byte.b	%00000111
   1014  33af		       7e		      .byte.b	%01111110
   1015  33b0		       70		      .byte.b	%01110000
   1016  33b1		       7f		      .byte.b	%01111111
   1017  33b2				   FourR
   1018  33b2		       0e		      .byte.b	%00001110
   1019  33b3		       0e		      .byte.b	%00001110
   1020  33b4		       0e		      .byte.b	%00001110
   1021  33b5		       7f		      .byte.b	%01111111
   1022  33b6		       6e		      .byte.b	%01101110
   1023  33b7		       60		      .byte.b	%01100000
   1024  33b8		       60		      .byte.b	%01100000
   1025  33b9
   1026  33b9							;CharAL:
   1027  33b9							;    .byte %11100110
   1028  33b9							;    .byte %11100110
   1029  33b9							;    .byte %11111110
   1030  33b9							;    .byte %11100110
   1031  33b9							;    .byte %11100110
   1032  33b9							;    .byte %01111100
   1033  33b9							;    .byte %00111000
   1034  33b9							;CharEL:
   1035  33b9							;    .byte %11111110
   1036  33b9							;    .byte %11111110
   1037  33b9							;    .byte %11100000
   1038  33b9							;    .byte %11100000
   1039  33b9							;    .byte %11111100
   1040  33b9							;    .byte %11100000
   1041  33b9							;    .byte %11111110
   1042  33b9							;CharRL:
   1043  33b9							;    .byte %11100110
   1044  33b9							;    .byte %11100110
   1045  33b9							;    .byte %11111100
   1046  33b9							;    .byte %11111100
   1047  33b9							;    .byte %11100110
   1048  33b9							;    .byte %11100110
   1049  33b9							;    .byte %11111100
   1050  33b9							;CharVL:
   1051  33b9							;    .byte %00111000
   1052  33b9							;    .byte %01111100
   1053  33b9							;    .byte %11100110
   1054  33b9							;    .byte %11100110
   1055  33b9							;    .byte %11100110
   1056  33b9							;    .byte %11100110
   1057  33b9							;    .byte %11100110
   1058  33b9
      0  33b9					      CHECKPAGE	BLANKR
      8  33b9					      LIST	ON
   1060  33b9
   1061  33b9							;---------------------------------------------------------------------------
   1062  33b9
      0  33b9					      DEFINE_SUBROUTINE	GameInitialise
      1  33b9		       00 06	   BANK_GameInitialise =	_CURRENT_BANK
      2  33b9					      SUBROUTINE
      3  33b9				   GameInitialise
   1064  33b9
   1065  33b9							; copy loaded SK high score into scoring RAM:
   1066  33b9		       a2 02		      ldx	#3-1
   1067  33bb				   .loopCopyHighScore
   1068  33bb		       b5 e2		      lda	highScoreSK,x
   1069  33bd		       c9 ff		      cmp	#$ff
   1070  33bf		       f0 06		      beq	.noSaveKey
   1071  33c1		       9d fa f7 	      sta	HighScore+RAM_WRITE,x
   1072  33c4		       ca		      dex
   1073  33c5		       10 f4		      bpl	.loopCopyHighScore
   1074  33c7				   .noSaveKey
   1075  33c7
   1076  33c7							; clear both players scores
   1077  33c7		       a0 05		      ldy	#2*3-1
   1078  33c9		       a9 00		      lda	#0
   1079  33cb				   .loopClearScore
   1080  33cb		       99 f0 f7 	      sta	ScoreCurrent+RAM_WRITE,y
   1081  33ce		       88		      dey
   1082  33cf		       10 fa		      bpl	.loopClearScore
   1083  33d1
   1084  33d1							; copy cave and level for other player and SaveKey:
   1085  33d1		       a5 b0		      lda	cave
   1086  33d3		       8d f8 f7 	      sta	PlayerCave+RAM_WRITE
   1087  33d6		       a5 e5		      lda	startCave
   1088  33d8		       8d f3 f7 	      sta	StartCave+RAM_WRITE
   1089  33db		       a5 b1		      lda	level
   1090  33dd		       8d f9 f7 	      sta	PlayerLevel+RAM_WRITE
   1091  33e0		       8d f4 f7 	      sta	StartLevel+RAM_WRITE
   1092  33e3		       60		      rts
   1093  33e4
   1094  33e4							;---------------------------------------------------------------------------
   1095  33e4
   1096  33e4					      IF	EASTER_EGG = YES
      0  33e4					      DEFINE_SUBROUTINE	GetScore
      1  33e4		       00 06	   BANK_GetScore =	_CURRENT_BANK
      2  33e4					      SUBROUTINE
      3  33e4				   GetScore
   1098  33e4		       ad f0 f3 	      lda	ScoreCurrent
   1099  33e7		       ae f1 f3 	      ldx	ScoreCurrent+1
   1100  33ea		       ac f2 f3 	      ldy	ScoreCurrent+2
   1101  33ed							;		  lda #$33
   1102  33ed							;		  tax
   1103  33ed							;		  tay
   1104  33ed		       85 e7		      sta	tmpScore
   1105  33ef		       60		      rts
   1106  33f0					      ENDIF
   1107  33f0
   1108  33f0		       00 00 00    ScoreCurrent ds	3, 0
   1109  33f3							; start cave and level have to be after ScoreCurrent!
   1110  33f3		       00	   StartCave  .byte.b	0
   1111  33f4		       00	   StartLevel .byte.b	0
   1112  33f5		       00 00 00    PlayerScores ds	3, 0
   1113  33f8							; cave and level have to be consecutive variables!
   1114  33f8		       00	   PlayerCave .byte.b	0
   1115  33f9		       00	   PlayerLevel .byte.b	0
   1116  33fa		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1117  33ff
   1118  33ff
   1119  33ff
   1120  33ff							;------------------------------------------------------------------------------
   1121  33ff
      0  33ff					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  33ff
      2  33ff
      3  33ff		       03 ff	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $3ff , FREE= $1
      4  33ff					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  33ff				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  33ff				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  33ff				  -	      ERR
      8  33ff					      endif
   1123  33ff
   1124  33ff							;------------------------------------------------------------------------------
   1125  33ff
   1126  33ff							; CAVE DATA banks can go anywhere - *EXCEPT* for the same bank as the cave
   1127  33ff							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_CAVE_SIZE
   1128  33ff							; which is used as a buffer size inside DecodeCave.  It's not important if
   1129  33ff							; this is defined before or after, as once the caves have processed it will be
   1130  33ff							; correct. Note, that caves should all be defined BEFORE *OR* AFTER the
   1131  33ff							; DecodeCave code -- but that they should not be both, nor in the same bank.
   1132  33ff
------- FILE CaveBank0.asm LEVEL 3 PASS 3
      0  33ff					      include	"CaveBank0.asm"
      1  33ff							; Cave definitions
      2  33ff							; Sample cave definitions.
      3  33ff							; Any cave can be in any bank.  System auto-calculates required bank buffer size in RAM.
      4  33ff							; have as many banks as you like.  Add new banks in notBoulderDash.asm.
      5  33ff
      6  33ff
      7  33ff							;------------------------------------------------------------------------------
      8  33ff							;##############################################################################
      9  33ff							;------------------------------------------------------------------------------
     10  33ff
     11  33ff				  -	      IF	0	;{
     12  33ff				  -			;IF DEMO_VERSION = NO && FINAL_VERSION = NO
     13  33ff				  -	      START_CAVE	SELECTION_SCREEN
     14  33ff				  -
     15  33ff				  -
     16  33ff				  -	      .byte	0	; cave 0 -- selection screen
     17  33ff				  -	      CAVE_SIZE	10, SCREEN_LINES	; width, height
     18  33ff				  -	      .byte	$14	; Magic wall/amoeba slow growth for: 20 seconds
     19  33ff				  -	      .byte	$10	;BCD'd $0A			    ; Diamonds worth: 10 points
     20  33ff				  -	      .byte	$15	;BCD'd $0F			    ; Extra diamonds worth: 15 points
     21  33ff				  -	      CAVE_RANDOM	$0,0,0,0,0	; Randomiser seed values for difficulty levels 1-5
     22  33ff				  -	      .byte	$0C, $0C, $0C, $0C, $0C	; Diamonds needed: 12, 12, 12, 12, 12 (for difficulty levels 1-5)
     23  33ff				  -	      .byte	$FF,0,0,0,0	; cave time
     24  33ff				  -	      .byte	$a6, $96	; NTSC/PAL
     25  33ff				  -	      .byte	$36, $46	; NTSC/PAL
     26  33ff				  -	      .byte	$0e, $0e	; NTSC/PAL
     27  33ff				  -	      .byte	$00, $00, $00, $00	; Random objects:
     28  33ff				  -	      .byte	$00, $00, $00, $00	;   SPACE / BOULDERS/ DIAMONDS / unused
     29  33ff				  -
     30  33ff				  -
     31  33ff				  -			;.byte   FILL+CHARACTER_BOULDER, $01, $03, 38,6, $00
     32  33ff				  -	      STOCH	CHARACTER_MANOCCUPIED, $03, $04	; StoreChar zPRFd1 at ( 3, 4)
     33  33ff				  -	      STOCH	CHARACTER_EXPLOSION3, 1,3	; special selector creature (overload explosion character)
     34  33ff				  -	      END_CAVE	SELECTION_SCREEN
     35  33ff					      ENDIF		;}
     36  33ff
     37  33ff							;------------------------------------------------------------------------------
     38  33ff
     39  33ff					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  33ff					      START_CAVE	INTRO
      1  33ff				   CAVE_START SET	*
      2  33ff		       00 06	   BANK_CAVE_INTRO =	_CURRENT_BANK
      3  33ff				   CAVE_INTRO SUBROUTINE
      4  33ff				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  33ff
     41  33ff
     42  33ff		       01		      .byte.b	$01	; Cave 01 A
      0  3400					      CAVE_SIZE_ROOM		; width, height
      0  3400					      CAVE_SIZE	40, 22
      1  3400		       28 16		      .byte.b	40,22
     44  3402		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
     45  3403		       10		      .byte.b	$10	;BCD'd $0A				    ; Diamonds worth: 10 points
     46  3404		       15		      .byte.b	$15	;BCD'd $0F				    ; Extra diamonds worth: 15 points
      0  3405					      CAVE_RANDOM	$0A, $0B, $0C, $0D, $0E	; Randomiser seed values for difficulty levels 1-5
      1  3405		       0a 0b 0c 0d*	      .byte.b	$0A,$0B,$0C,$0D,$0E
     48  340a
     49  340a				  -	      IF	TEST_BONUS_COUNTDOWN = YES
     50  340a				  -	      .byte	$01, $0C, $0C, $0C, $0C	; Diamonds needed: 12, 12, 12, 12, 12 (for difficulty levels 1-5)
     51  340a					      ELSE
     52  340a		       0c 0c 0c 0c*	      .byte.b	$0C, $0C, $0C, $0C, $0C	; Diamonds needed: 12, 12, 12, 12, 12 (for difficulty levels 1-5)
     53  340f					      ENDIF
     54  340f
     55  340f		       96 6e 46 28*	      .byte.b	$96, $6E, $46, $28, $1E	; Cave time
     56  3414
     57  3414							; z26 palette/z26 palette:
     58  3414							;    .byte   $a8, $96				  ; NTSC/PAL
     59  3414							;    .byte   $36, $46				  ; NTSC/PAL
     60  3414							;    .byte   $0e, $0e				  ; NTSC/PAL
     61  3414							; z26 palette/TJ's PAL TV palette:
     62  3414
     63  3414
     64  3414							;-------------------------------------------------------------------------------------
     65  3414							; PALETTE DEFINITIONS
     66  3414
     67  3414					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
     68  3414		       a8 b6		      .byte.b	$a8, $b6
     69  3416		       36 46		      .byte.b	$36, $46
     70  3418		       0e 0e		      .byte.b	$0e, $0e
     71  341a				  -	      ELSE
     72  341a				  -
     73  341a				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
     74  341a				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
     75  341a				  -	      IF	AD_MODE
     76  341a				  -	      .byte	$a8, $b6
     77  341a				  -	      .byte	$36, $46
     78  341a				  -	      .byte	$0e, $0e
     79  341a				  -	      ENDIF
     80  341a				  -
     81  341a				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
     82  341a				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
     83  341a				  -	      IF	TJ_MODE
     84  341a				  -	      .byte	$a8, $b6
     85  341a				  -	      .byte	$36, $46
     86  341a				  -	      .byte	$0e, $0e
     87  341a				  -	      ENDIF
     88  341a				  -
     89  341a					      ENDIF
     90  341a
     91  341a							;-------------------------------------------------------------------------------------
     92  341a
     93  341a		       00		      .byte.b	CHARACTER_BLANK	; Random objects:
     94  341b		       02		      .byte.b	CHARACTER_BOULDER
     95  341c		       04		      .byte.b	CHARACTER_DIAMOND
     96  341d		       00		      .byte.b	CHARACTER_BLANK
     97  341e		       3c 32 09 00	      .byte.b	$3C, $32, $09, $00	;   zSpace :  60/256 = 23-19-3%
     98  3422							;   zBouS  :  50/256 = 19-3%
     99  3422							;   zDiaS  :	9/256 =  3%
    100  3422							;   fourth code unused (0%)
    101  3422
    102  3422		       50 01 09 1e*	      .byte.b	LINE+CHARACTER_WALL, $01, $09, $1E, $02	; Line of zBrick from ( 1, 9); length = 30; direction = right
    103  3427		       50 09 10 1e*	      .byte.b	LINE+CHARACTER_WALL, $09, $10, $1E, $02	; Line of zBrick from ( 9,16); length = 30; direction = right
      0  342c					      STOCH	CHARACTER_MANOCCUPIED, $03, $04	; StoreChar zPRFd1 at ( 3, 4)
      1  342c		       06 03 04 	      .byte.b	CHARACTER_MANOCCUPIED,$03,$04
    105  342f
    106  342f
    107  342f				  -	      IF	TEST_BONUS_COUNTDOWN = YES
    108  342f				  -			;Thomas the following 2 are a quick test for bonus countdown...
    109  342f				  -			; there's a diamond below the man, and an exit door below that.
    110  342f				  -			; so you go to level A1, then down/down and you are at the bonus sequence...
    111  342f				  -
    112  342f				  -			; The butterfly and boulder are added so you can test...
    113  342f				  -			; Hitting the exit door and then having the butterfly come and try to kill you in the exit
    114  342f				  -			;  To do this, open a path for the butterfly above/right the boulder, then go to the exit.
    115  342f				  -
    116  342f				  -
    117  342f				  -	      STOCH	CHARACTER_DIAMOND, 3, 5
    118  342f				  -	      STOCH	CHARACTER_EXITDOOR, 3, 6	; StoreChar zPreOut at (38,18)
    119  342f				  -	      .byte	LINE+CHARACTER_BLANK, 4,5,5,2	; blank row
    120  342f				  -	      .byte	CHARACTER_BOULDER, 4,5
    121  342f				  -	      .byte	CHARACTER_FLUTTERBY, 9,5
    122  342f					      ELSE
      0  342f					      STOCH	CHARACTER_EXITDOOR, $26, $12	; StoreChar zPreOut at (38,18)
      1  342f		       11 26 12 	      .byte.b	CHARACTER_EXITDOOR,$26,$12
    124  3432					      ENDIF
    125  3432
      0  3432					      END_CAVE	INTRO
      1  3432		       ff		      .byte.b	$FF
      2  3432		       00 34	   CAVE_SIZE_INTRO =	* - CAVE_START
      3  3433				  -	      IF	CAVE_SIZE_INTRO > MAX_CAVE_SIZE
      4  3433				  -MAX_CAVE_SIZE SET	CAVE_SIZE_INTRO
      5  3433					      ENDIF
    127  3433					      ENDIF
    128  3433
    129  3433							;------------------------------------------------------------------------------
    130  3433
    131  3433					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
    132  3433
      0  3433					      START_CAVE	ROOMS
      1  3433				   CAVE_START SET	*
      2  3433		       00 06	   BANK_CAVE_ROOMS =	_CURRENT_BANK
      3  3433				   CAVE_ROOMS SUBROUTINE
      4  3433				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  3433
    134  3433
    135  3433		       02		      .byte.b	$02	; Cave 02 B
      0  3434					      CAVE_SIZE_ROOM		; width, height
      0  3434					      CAVE_SIZE	40, 22
      1  3434		       28 16		      .byte.b	40,22
    137  3436		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    138  3437		       20		      .byte.b	$20	;BCD'd $14				    ; Diamonds worth: 20 points
    139  3438		       50		      .byte.b	$50	;BCD'd $32				    ; Extra diamonds worth: 50 points
      0  3439					      CAVE_RANDOM	$03, $00, $01, $57, $58	; Randomiser seed values for difficulty levels 1-5
      1  3439		       03 00 01 57*	      .byte.b	$03,$00,$01,$57,$58
    141  343e		       0a 0c 09 0d*	      .byte.b	$0A, $0C, $09, $0D, $0A	; Diamonds needed: 10, 12, 9, 13, 10 (for difficulty levels 1-5)
    142  3443		       96 6e 46 46*	      .byte.b	$96, $6E, $46, $46, $46	; Cave time: 150, 110, 70, 70, 70 seconds
    143  3448
    144  3448
    145  3448							;-------------------------------------------------------------------------------------
    146  3448							; PALETTE DEFINITIONS
    147  3448
    148  3448					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    149  3448		       78 a8		      .byte.b	$78, $a8
    150  344a		       34 44		      .byte.b	$34, $44
    151  344c		       ce 7e		      .byte.b	$ce, $7e
    152  344e				  -	      ELSE
    153  344e				  -
    154  344e				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    155  344e				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    156  344e				  -	      IF	AD_MODE
    157  344e				  -	      .byte	$78, $a8
    158  344e				  -	      .byte	$34, $44
    159  344e				  -	      .byte	$ce, $7e
    160  344e				  -	      ENDIF
    161  344e				  -
    162  344e				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    163  344e				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    164  344e				  -	      IF	TJ_MODE
    165  344e				  -	      .byte	$78, $a8
    166  344e				  -	      .byte	$34, $44
    167  344e				  -	      .byte	$ce, $7e
    168  344e				  -	      ENDIF
    169  344e				  -
    170  344e					      ENDIF
    171  344e
    172  344e							;-------------------------------------------------------------------------------------
    173  344e
    174  344e
    175  344e		       00		      .byte.b	CHARACTER_BLANK	; Random objects:
    176  344f		       02		      .byte.b	CHARACTER_BOULDER
    177  3450		       04		      .byte.b	CHARACTER_DIAMOND
    178  3451		       09		      .byte.b	CHARACTER_FIREFLY
    179  3452		       3c 32 09 02	      .byte.b	$3C, $32, $09, $02	;   zSpace :  60/256 = 23-19-3%
    180  3456							;   zBouS  :  50/256 = 19-3%
    181  3456							;   zDiaS  :	9/256 =  3%
    182  3456							;   zFFly1 :	2/256 =  0%
    183  3456		       50 01 08 26*	      .byte.b	LINE+CHARACTER_WALL, $01, $08, $26, $02	; Line of zBrick from ( 1, 8); length = 38; direction = right
    184  345b		       50 01 0f 26*	      .byte.b	LINE+CHARACTER_WALL, $01, $0F, $26, $02	; Line of zBrick from ( 1,15); length = 38; direction = right
    185  3460		       50 08 03 14*	      .byte.b	LINE+CHARACTER_WALL, $08, $03, $14, $04	; Line of zBrick from ( 8, 3); length = 20; direction = down
    186  3465		       50 10 03 14*	      .byte.b	LINE+CHARACTER_WALL, $10, $03, $14, $04	; Line of zBrick from (16, 3); length = 20; direction = down
    187  346a		       50 18 03 14*	      .byte.b	LINE+CHARACTER_WALL, $18, $03, $14, $04	; Line of zBrick from (24, 3); length = 20; direction = down
    188  346f		       50 20 03 14*	      .byte.b	LINE+CHARACTER_WALL, $20, $03, $14, $04	; Line of zBrick from (32, 3); length = 20; direction = down
    189  3474		       40 01 05 26*	      .byte.b	LINE+CHARACTER_BLANK, $01, $05, $26, $02	; Line of zSpace from ( 1, 5); length = 38; direction = right
    190  3479		       40 01 0b 26*	      .byte.b	LINE+CHARACTER_BLANK, $01, $0B, $26, $02	; Line of zSpace from ( 1,11); length = 38; direction = right
    191  347e		       40 01 12 26*	      .byte.b	LINE+CHARACTER_BLANK, $01, $12, $26, $02	; Line of zSpace from ( 1,18); length = 38; direction = right
    192  3483		       40 14 03 14*	      .byte.b	LINE+CHARACTER_BLANK, $14, $03, $14, $04	; Line of zSpace from (20, 3); length = 20; direction = down
    193  3488		       06 12 15 	      .byte.b	CHARACTER_MANOCCUPIED, $12, $15	; StoreChar zPRFd1 at (18,21)
    194  348b		       11 12 16 	      .byte.b	CHARACTER_EXITDOOR, $12, $16	; StoreChar zPreOut at (18,22)
      0  348e					      END_CAVE	ROOMS
      1  348e		       ff		      .byte.b	$FF
      2  348e		       00 5c	   CAVE_SIZE_ROOMS =	* - CAVE_START
      3  348f				  -	      IF	CAVE_SIZE_ROOMS > MAX_CAVE_SIZE
      4  348f				  -MAX_CAVE_SIZE SET	CAVE_SIZE_ROOMS
      5  348f					      ENDIF
    196  348f							;  ELSE
    197  348f							;    START_CAVE ROOMS
    198  348f							;
    199  348f							;    .byte   $02				  ; Cave 02 B
    200  348f							;    CAVE_SIZE_ROOM				  ; width, height
    201  348f							;    .byte   $14				  ; Magic wall/amoeba slow growth for: 20 seconds
    202  348f							;    .byte   $20 ;BCD'd $14				     ; Diamonds worth: 20 points
    203  348f							;    .byte   $50 ;BCD'd $32				     ; Extra diamonds worth: 50 points
    204  348f							;    CAVE_RANDOM $04, $00, $01, $57, $58	  ; Randomiser seed values for difficulty levels 1-5
    205  348f							;    .byte   99, $0C, $09, $0D, $0A		 ; Diamonds needed: 10, 12, 9, 13, 10 (for difficulty levels 1-5)
    206  348f							;    .byte   120, $6E, $46, $46, $46		  ; Cave time: 150, 110, 70, 70, 70 seconds
    207  348f							;
    208  348f							;;; z26 palette/z26 palette
    209  348f							;;    .byte   $8a, $ca 			   ; NTSC/PAL
    210  348f							;;    .byte   $46, $66 			   ; NTSC/PAL
    211  348f							;;    .byte   $de, $3e 			   ; NTSC/PAL
    212  348f							;; z26 palette/TJ's PAL TV palette
    213  348f							;    .byte   $78, $a8				  ; NTSC/PAL
    214  348f							;    .byte   $34, $44				  ; NTSC/PAL
    215  348f							;    .byte   $ce, $7e				  ; NTSC/PAL
    216  348f							;
    217  348f							;    .byte   CHARACTER_DIAMOND 			   ; Random objects:
    218  348f							;    .byte   CHARACTER_FIREFLY
    219  348f							;    .byte   0
    220  348f							;    .byte   0
    221  348f							;    .byte   255, 50, $00, $00 		 ;   zSpace :  60/256 = 23-19-3%
    222  348f							;						  ;   zBouS  :	50/256 = 19-3%
    223  348f							;						  ;   zDiaS  :	 9/256 =  3%
    224  348f							;						  ;   zFFly1 :	 2/256 =  0%
    225  348f							;
    226  348f							;;    .byte   FILL+CHARACTER_DIAMOND, 1, 3, 28, 10, CHARACTER_DIAMOND; FilledRect of zDirt from ( 8,10); length = 4; height = 4; fill = zSpace
    227  348f							;    .byte   CHARACTER_MANOCCUPIED, 1, 3		; StoreChar zPRFd1 at (18,21)
    228  348f							;    .byte   CHARACTER_EXITDOOR, 38, 22		   ; StoreChar zPreOut at (18,22)
    229  348f							;    END_CAVE ROOMS
    230  348f							;  ENDIF
    231  348f					      ENDIF
    232  348f
    233  348f							;------------------------------------------------------------------------------
    234  348f
    235  348f					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  348f					      START_CAVE	MAZE
      1  348f				   CAVE_START SET	*
      2  348f		       00 06	   BANK_CAVE_MAZE =	_CURRENT_BANK
      3  348f				   CAVE_MAZE  SUBROUTINE
      4  348f				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  348f
    237  348f
    238  348f		       03		      .byte.b	$03	; Cave 03 C
      0  3490					      CAVE_SIZE_ROOM		; width, height
      0  3490					      CAVE_SIZE	40, 22
      1  3490		       28 16		      .byte.b	40,22
    240  3492		       00		      .byte.b	$00	; Magic wall/amoeba slow growth for: 0 seconds
    241  3493		       15		      .byte.b	$15	;BCD'd $0F				    ; Diamonds worth: 15 points
    242  3494		       00		      .byte.b	$0	;BCD'd $00				    ; Extra diamonds worth: 0 points
      0  3495					      CAVE_RANDOM	$00, $32, $36, $34, $37	; Randomiser seed values for difficulty levels 1-5
      1  3495		       00 32 36 34*	      .byte.b	$00,$32,$36,$34,$37
    244  349a		       18 17 18 17*	      .byte.b	$18, $17, $18, $17, $15	; Diamonds needed: 24, 23, 24, 23, 21 (for difficulty levels 1-5)
    245  349f		       96 64 5a 50*	      .byte.b	$96, $64, $5A, $50, $46	; Cave time: 150, 100, 90, 80, 70 seconds
    246  34a4
    247  34a4
    248  34a4							;-------------------------------------------------------------------------------------
    249  34a4							; PALETTE DEFINITIONS
    250  34a4
    251  34a4					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    252  34a4		       f6 48		      .byte.b	$f6, $48	; NTSC/PAL
    253  34a6		       24 24		      .byte.b	$24, $24	; NTSC/PAL
    254  34a8		       9e be		      .byte.b	$9e, $be	; NTSC/PAL
    255  34aa				  -	      ELSE
    256  34aa				  -
    257  34aa				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    258  34aa				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    259  34aa				  -	      IF	AD_MODE
    260  34aa				  -	      .byte	$c4, $52
    261  34aa				  -	      .byte	$26, $44
    262  34aa				  -	      .byte	$8e, $de
    263  34aa				  -	      ENDIF
    264  34aa				  -
    265  34aa				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    266  34aa				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    267  34aa				  -	      IF	TJ_MODE
    268  34aa				  -	      .byte	$c4, $52
    269  34aa				  -	      .byte	$26, $44
    270  34aa				  -	      .byte	$8e, $de
    271  34aa				  -	      ENDIF
    272  34aa				  -
    273  34aa					      ENDIF
    274  34aa
    275  34aa							;-------------------------------------------------------------------------------------
    276  34aa
    277  34aa		       10		      .byte.b	CHARACTER_WALL	; Random objects:
    278  34ab		       02		      .byte.b	CHARACTER_BOULDER
    279  34ac		       04		      .byte.b	CHARACTER_DIAMOND
    280  34ad		       00		      .byte.b	CHARACTER_BLANK
    281  34ae		       64 32 09 00	      .byte.b	$64, $32, $09, $00	;   zBrick : 100/256 = 39%
    282  34b2							;   zBouS  :  50/256 = 19%
    283  34b2							;   zDiaS  :	9/256 =  3%
    284  34b2							;   fourth code unused (0%)
    285  34b2		       06 03 04 	      .byte.b	CHARACTER_MANOCCUPIED, $03, $04	; StoreChar zPRFd1 at ( 3, 4)
    286  34b5
    287  34b5		       11 27 14 	      .byte.b	CHARACTER_EXITDOOR, $27, $14	; StoreChar zPreOut at (39,20)
      0  34b8					      END_CAVE	MAZE
      1  34b8		       ff		      .byte.b	$FF
      2  34b8		       00 2a	   CAVE_SIZE_MAZE =	* - CAVE_START
      3  34b9				  -	      IF	CAVE_SIZE_MAZE > MAX_CAVE_SIZE
      4  34b9				  -MAX_CAVE_SIZE SET	CAVE_SIZE_MAZE
      5  34b9					      ENDIF
    289  34b9					      ENDIF
    290  34b9
    291  34b9							;------------------------------------------------------------------------------
    292  34b9
    293  34b9					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  34b9					      START_CAVE	BUTTERFLIES
      1  34b9				   CAVE_START SET	*
      2  34b9		       00 06	   BANK_CAVE_BUTTERFLIES =	_CURRENT_BANK
      3  34b9				   CAVE_BUTTERFLIES SUBROUTINE
      4  34b9				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  34b9
    295  34b9
    296  34b9		       04		      .byte.b	$04	; Cave 04 D
      0  34ba					      CAVE_SIZE_ROOM		; width, height
      0  34ba					      CAVE_SIZE	40, 22
      1  34ba		       28 16		      .byte.b	40,22
    298  34bc		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    299  34bd		       05		      .byte.b	$05	; Diamonds worth: 5 points
    300  34be		       20		      .byte.b	$20	;BCD'd $14				    ; Extra diamonds worth: 20 points
      0  34bf					      CAVE_RANDOM	$00, $6E, $70, $73, $77	; Randomiser seed values for difficulty levels 1-5
      1  34bf		       00 6e 70 73*	      .byte.b	$00,$6E,$70,$73,$77
    302  34c4		       24 24 24 24*	      .byte.b	$24, $24, $24, $24, $24	; Diamonds needed: 36, 36, 36, 36, 36 (for difficulty levels 1-5)
    303  34c9		       78 64 50 3c*	      .byte.b	$78, $64, $50, $3C, $32	; Cave time: 120, 100, 80, 60, 50 seconds
    304  34ce
    305  34ce							;; z26 palette/z26 palette:
    306  34ce							;    .byte   $16, $26				  ; NTSC/PAL
    307  34ce							;    .byte   $54, $84				  ; NTSC/PAL
    308  34ce							;    .byte   $ae, $7e				  ; NTSC/PAL
    309  34ce							; z26 palette/TJ's PAL TV palette:
    310  34ce
    311  34ce							;-------------------------------------------------------------------------------------
    312  34ce							; PALETTE DEFINITIONS
    313  34ce
    314  34ce					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    315  34ce		       16 26		      .byte.b	$16, $26
    316  34d0		       54 86		      .byte.b	$54, $86
    317  34d2		       ae 9e		      .byte.b	$ae, $9e
    318  34d4				  -	      ELSE
    319  34d4				  -
    320  34d4				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    321  34d4				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    322  34d4				  -	      IF	AD_MODE
    323  34d4				  -	      .byte	$16, $26
    324  34d4				  -	      .byte	$54, $86
    325  34d4				  -	      .byte	$ae, $9e
    326  34d4				  -	      ENDIF
    327  34d4				  -
    328  34d4				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    329  34d4				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    330  34d4				  -	      IF	TJ_MODE
    331  34d4				  -	      .byte	$16, $26
    332  34d4				  -	      .byte	$54, $86
    333  34d4				  -	      .byte	$ae, $9e
    334  34d4				  -	      ENDIF
    335  34d4				  -
    336  34d4					      ENDIF
    337  34d4
    338  34d4							;-------------------------------------------------------------------------------------
    339  34d4
    340  34d4
    341  34d4		       02		      .byte.b	CHARACTER_BOULDER	; Random objects:
    342  34d5		       00		      .byte.b	CHARACTER_BLANK
    343  34d6		       00		      .byte.b	CHARACTER_BLANK
    344  34d7		       00		      .byte.b	CHARACTER_BLANK
    345  34d8		       14 00 00 00	      .byte.b	$14, $00, $00, $00	;   zBouS  :  20/256 =  7%
    346  34dc
    347  34dc		       06 01 03 	      .byte.b	CHARACTER_MANOCCUPIED, $01, $03	; StoreChar zPRFd1 at ( 1, 3)
    348  34df		       11 26 16 	      .byte.b	CHARACTER_EXITDOOR, $26, $16	; StoreChar zPreOut at (38,22)
    349  34e2		       81 08 0a 04*	      .byte.b	FILL+CHARACTER_SOIL, $08, $0A, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from ( 8,10); length = 4; height = 4; fill = zSpace
    350  34e8		       07 0a 0b 	      .byte.b	CHARACTER_FLUTTERBY, $0A, $0B	; StoreChar zBFly1 at (10,11)
    351  34eb		       81 10 0a 04*	      .byte.b	FILL+CHARACTER_SOIL, $10, $0A, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (16,10); length = 4; height = 4; fill = zSpace
    352  34f1		       07 12 0b 	      .byte.b	CHARACTER_FLUTTERBY, $12, $0B	; StoreChar zBFly1 at (18,11)
    353  34f4		       81 18 0a 04*	      .byte.b	FILL+CHARACTER_SOIL, $18, $0A, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (24,10); length = 4; height = 4; fill = zSpace
    354  34fa		       07 1a 0b 	      .byte.b	CHARACTER_FLUTTERBY, $1A, $0B	; StoreChar zBFly1 at (26,11)
    355  34fd		       81 20 0a 04*	      .byte.b	FILL+CHARACTER_SOIL, $20, $0A, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (32,10); length = 4; height = 4; fill = zSpace
    356  3503		       07 22 0b 	      .byte.b	CHARACTER_FLUTTERBY, $22, $0B	; StoreChar zBFly1 at (34,11)
      0  3506					      END_CAVE	BUTTERFLIES
      1  3506		       ff		      .byte.b	$FF
      2  3506		       00 4e	   CAVE_SIZE_BUTTERFLIES =	* - CAVE_START
      3  3507				  -	      IF	CAVE_SIZE_BUTTERFLIES > MAX_CAVE_SIZE
      4  3507				  -MAX_CAVE_SIZE SET	CAVE_SIZE_BUTTERFLIES
      5  3507					      ENDIF
    358  3507					      ENDIF
    359  3507
    360  3507							;------------------------------------------------------------------------------
    361  3507
    362  3507					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
    363  3507					      IF	EASTER_EGG = YES
      0  3507					      START_CAVE	SPINDIZZY	; "Spindizzy"
      1  3507				   CAVE_START SET	*
      2  3507		       00 06	   BANK_CAVE_SPINDIZZY =	_CURRENT_BANK
      3  3507				   CAVE_SPINDIZZY SUBROUTINE
      4  3507				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  3507
    365  3507		       15		      .byte.b	$15	; Cave 21
      0  3508					      CAVE_SIZE	10, 8+1	; width, height
      1  3508		       0a 09		      .byte.b	10,8+1
    367  350a		       04		      .byte.b	4	; amoeba slow growth for: 3 seconds
    368  350b		       10		      .byte.b	$10	; Diamonds worth: 10 points
    369  350c		       50		      .byte.b	$50	; Extra diamonds worth: 50 points
    370  350d		       00 00 00 00*	      .byte.b	$00, $00, $00, $00, $00	; Randomiser seed values for difficulty levels 1-5
    371  3512		       08 09 0a 0b*	      .byte.b	8, 9, 10, 11, 12	; Diamonds needed: 12, 13, 14, 15, 16 (for difficulty levels 1-5)
    372  3517		       0f 0f 0f 0f*	      .byte.b	15, 15, 15, 15, 15	; Cave time: 15, 15, 15, 15, 15 seconds
    373  351c
    374  351c							;-------------------------------------------------------------------------------------
    375  351c							; PALETTE DEFINITIONS
    376  351c
    377  351c					      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    378  351c		       68 88		      .byte.b	$68, $88	; NTSC/PAL
    379  351e		       24 24		      .byte.b	$24, $24	; PAL amoeba color is now identical to cave G
    380  3520		       cc 7a		      .byte.b	$cc, $7a	;
    381  3522				  -	      ELSE
    382  3522				  -
    383  3522				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    384  3522				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    385  3522				  -	      IF	AD_MODE
    386  3522				  -	      .byte	$68, $88
    387  3522				  -	      .byte	$24, $24
    388  3522				  -	      .byte	$cc, $7a
    389  3522				  -	      ENDIF
    390  3522				  -
    391  3522				  -			; COMMENT FOLLOWING OUT IF NOT WANTED!
    392  3522				  -			; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    393  3522				  -	      IF	TJ_MODE
    394  3522				  -	      .byte	$68, $88
    395  3522				  -	      .byte	$24, $24
    396  3522				  -	      .byte	$cc, $7a
    397  3522				  -	      ENDIF
    398  3522				  -
    399  3522					      ENDIF
    400  3522
    401  3522							;-------------------------------------------------------------------------------------
    402  3522
    403  3522
    404  3522		       00 00 00 00	      .byte.b	$00, $00, $00, $00	; Random objects:
    405  3526		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
    406  352a							;   second code unused (0%)
    407  352a							;   third code unused (0%)
    408  352a							;   fourth code unused (0%)
    409  352a
    410  352a		       90 00 03 05*	      .byte.b	FILL+CHARACTER_WALL, 0, 3, 5, 6, CHARACTER_SOIL
    411  3530		       90 05 03 05*	      .byte.b	FILL+CHARACTER_WALL, 5, 3, 5, 6, CHARACTER_BLANK
    412  3536		       cf 00 02 0a*	      .byte.b	RECT+CHARACTER_STEEL, 0, 2, 10, 8
    413  353b
    414  353b		       03 01 04 	      .byte.b	CHARACTER_AMOEBA,1, 4
    415  353e		       03 03 04 	      .byte.b	CHARACTER_AMOEBA,3, 4
    416  3541		       03 01 07 	      .byte.b	CHARACTER_AMOEBA,1, 7
    417  3544		       03 03 07 	      .byte.b	CHARACTER_AMOEBA,3, 7
    418  3547
    419  3547		       0f 04 04 	      .byte.b	CHARACTER_STEEL, 4, 4
    420  354a		       04 05 04 	      .byte.b	CHARACTER_DIAMOND, 5, 4
    421  354d		       01 05 05 	      .byte.b	CHARACTER_SOIL, 5, 5
    422  3550		       01 05 07 	      .byte.b	CHARACTER_SOIL, 5, 7
    423  3553
    424  3553		       09 06 07 	      .byte.b	CHARACTER_FIREFLY, 6, 7
    425  3556		       06 05 06 	      .byte.b	CHARACTER_MANOCCUPIED, 5, 6
    426  3559		       11 04 09 	      .byte.b	CHARACTER_EXITDOOR, 4, 9
      0  355c					      END_CAVE	SPINDIZZY
      1  355c		       ff		      .byte.b	$FF
      2  355c		       00 56	   CAVE_SIZE_SPINDIZZY =	* - CAVE_START
      3  355d				  -	      IF	CAVE_SIZE_SPINDIZZY > MAX_CAVE_SIZE
      4  355d				  -MAX_CAVE_SIZE SET	CAVE_SIZE_SPINDIZZY
      5  355d					      ENDIF
    428  355d					      ENDIF
    429  355d					      ENDIF
    430  355d
    431  355d
    432  355d							; ECHO "MAX CAVE SIZE = ", MAX_CAVE_SIZE
    433  355d
    434  355d
------- FILE BANK_ROM_SHADOW_SCORING.asm
   1134  355d
      0  355d					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  355d		       05 5d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $55d , FREE= $2a3
      2  355d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  355d				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  355d				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  355d				  -	      ERR
      6  355d					      endif
------- FILE ./notBoulderDash.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 3
      0  355d					      include	"BANK_GENERIC.asm"
      1  355d							;------------------------------------------------------------------------------
      2  355d							;##############################################################################
      3  355d							;------------------------------------------------------------------------------
      4  355d
      0  355d					      NEWBANK	GENERIC_BANK_1
      1  3fd7 ????				      SEG	GENERIC_BANK_1
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	GENERIC_BANK_1
      6  3800
      7  3800
      8  3800
      0  3800					      DEFINE_1K_SEGMENT	DECODE_CAVE_SHADOW
      1  3800					      ALIGN	$400
      2  3800				   SEGMENT_DECODE_CAVE_SHADOW SET	*
      3  3800				   BANK_DECODE_CAVE_SHADOW SET	_CURRENT_BANK
------- FILE DecodeCave.asm LEVEL 3 PASS 3
      0  3800					      include	"DecodeCave.asm"
      1  3800							;TODOs:
      2  3800							;+ load cave from ROM
      3  3800							;- remove delimiter
      4  3800							;+ variable board sizes
      5  3800							;- use Andrew's character ids
      6  3800							;+ store other cave parameter (times, diamonds, points etc.)
      7  3800
      8  3800							;---------------------------------------------------------------------------
      9  3800							; Board area must not overlap page boundary, as writing code uses indexing to save
     10  3800
      0  3800					      OPTIONAL_PAGEBREAK	"BOARD_DATA_AREA", MAX_CAVE_SIZE
     10  3800					      LIST	ON
     12  3800				   BOARD_DATA_AREA
     13  3800		       ff ff ff ff*	      ds	MAX_CAVE_SIZE,$FF
     14  3894
     15  3894							;---------------------------------------------------------------------------
     16  3894
     17  3894				   ThrottleSpeedTbl
     18  3894							; based on MAX_THROTTLE = 160, NTSC_276/PAL (312/276=1.13)
     19  3894		       13 16		      .byte.b	19, 22	; level 1 (E1: 5.60s) 1,16; 1.00/1.00 (1.00)
     20  3896		       16 1a		      .byte.b	22, 26	; level 2 (E2	4.80s) 1,18  1.16/1.18 (1.17)
     21  3898		       18 1c		      .byte.b	24, 28	; level 3 (E3: 4.40s) 1,16  1.26/1.27 (1.27)
     22  389a		       1a 1e		      .byte.b	26, 30	; level 4 (E4: 4.17s) 1,15  1.37/1.36 (1.34)
     23  389c		       1b 1f		      .byte.b	27, 31	; level 5 (E5: 4.00s) 1,14; 1.42/1.41 (1.40)
     24  389e
      0  389e					      DEFINE_SUBROUTINE	DecodeCave
      1  389e		       00 07	   BANK_DecodeCave =	_CURRENT_BANK
      2  389e					      SUBROUTINE
      3  389e				   DecodeCave
     26  389e
     27  389e							; *** local constants for cava data: ***
     28  389e
     29  389e		       00 04	   .NUM_RANDOM =	4	; number of random objects
     30  389e
     31  389e		       00 01	   .SIZE_OFS  =	1	; -1
     32  389e		       00 03	   .MAGIC_OFS =	3
     33  389e		       00 04	   .WORTH_OFS =	4
     34  389e		       00 05	   .EXTRA_WORTH_OFS =	5
     35  389e		       00 0b	   .DIAMONDS_OFS =	11
     36  389e		       00 10	   .TIME_OFS  =	16
     37  389e		       00 06	   .RND_INIT_OFS =	$04+2	; -1
     38  389e		       00 1b	   .RND_OBJECT_OFS =	$18+3	; -3
     39  389e		       00 1f	   .RND_VALUE_OFS =	$1c+3	; -3
     40  389e		       00 15	   .COLOR_OFS =	$13+2
     41  389e
     42  389e		       00 23	   .STRUCT_OFFSET =	$20+3	; -3
     43  389e		       00 ff	   .STRUCT_DELIMITER =	$ff
     44  389e		       00 c0	   .STRUCTURE_MASK =	%11000000
     45  389e
     46  389e		       00 00	   .STRUCT_SINGLE =	%00 << 6
     47  389e							;.STRUCT_LINE	      = LINE
     48  389e							;.STRUCT_FILLED      = FILL
     49  389e							;.STRUCT_RECTANGLE   = RECT
     50  389e		       00 40	   .STRUCT_LINE =	%01 << 6
     51  389e		       00 80	   .STRUCT_FILLED =	%10 << 6
     52  389e		       00 c0	   .STRUCT_RECTANGLE =	%11 << 6
     53  389e							;POINT 	      = .STRUCT_POINT
     54  389e		       00 80	   FILL       =	.STRUCT_FILLED
     55  389e		       00 40	   LINE       =	.STRUCT_LINE
     56  389e		       00 c0	   RECT       =	.STRUCT_RECTANGLE
     57  389e
     58  389e		       00 00	   .DIR_UP    =	0
     59  389e		       00 02	   .DIR_RIGHT =	2
     60  389e		       00 04	   .DIR_DOWN  =	4
     61  389e		       00 06	   .DIR_LEFT  =	6
     62  389e
     63  389e
     64  389e		       85 c4		      sta	RAM_Bank
     65  38a0
     66  38a0							; Setup for NTSC/PAL based on P1 difficulty (0=NTSC, 1=PAL)
     67  38a0							; Set the throttle speed based on system.
     68  38a0
      0  38a0					      DEFINE_SUBROUTINE	PlatformSelect
      1  38a0		       00 07	   BANK_PlatformSelect =	_CURRENT_BANK
      2  38a0					      SUBROUTINE
      3  38a0				   PlatformSelect
     70  38a0
     71  38a0							; has to be done before decoding the cave to have the platform right:
      0  38a0					      SET_PLATFORM
      1  38a0
      2  38a0
      3  38a0
      4  38a0
      5  38a0		       ad 82 02 	      lda	SWCHB
      6  38a3		       2a		      rol
      7  38a4		       2a		      rol
      8  38a5		       2a		      rol
      9  38a6		       29 03		      and	#%11
     10  38a8				  -	      if	NTSC_MODE = NO
     11  38a8				  -	      eor	#PAL
     12  38a8					      endif
     13  38a8		       85 81		      sta	Platform
     73  38aa
     74  38aa
     75  38aa							;------------------------------------------------------------------------------
     76  38aa							; Copy the ROM cave data into our local RAM cave data buffer.	Note that the
     77  38aa							; system is automatically setup so that the biggest cave will cause the available
     78  38aa							; buffer to increase during compile time.  So all we really need to do here is
     79  38aa							; copy the appropriate amount of data for the cave from ROM elsewhere, and then
     80  38aa							; let the system run just as it was before.
     81  38aa
     82  38aa							; Note that cave is an index to 4-byte entry table, so please use CAVE_NAMED_*
     83  38aa							; for cave reference numbers.
     84  38aa
     85  38aa							;		  sta RAM_Bank
     86  38aa
     87  38aa		       a5 c9		      lda	NextLevelTrigger
     88  38ac		       09 80		      ora	#BIT_NEXTLEVEL
     89  38ae		       85 c9		      sta	NextLevelTrigger
     90  38b0
     91  38b0
     92  38b0
     93  38b0		       a9 07		      lda	#BANK_DecodeCave	; the *ROM* bank of this routine (NOT RAM)
     94  38b2		       85 c3		      sta	ROM_Bank	; GetROMByte returns to this bank
     95  38b4
     96  38b4					      IF	EASTER_EGG = YES
     97  38b4							; check for easter egg (all digits identical)
     98  38b4		       c4 e7		      cpy	tmpScore
     99  38b6		       d0 1c		      bne	.noEE
    100  38b8		       e4 e7		      cpx	tmpScore
    101  38ba		       d0 18		      bne	.noEE
    102  38bc		       a5 e7		      lda	tmpScore
    103  38be		       f0 14		      beq	.noEE
    104  38c0		       4a		      lsr
    105  38c1		       4a		      lsr
    106  38c2		       4a		      lsr
    107  38c3		       4a		      lsr
    108  38c4		       45 e7		      eor	tmpScore
    109  38c6		       29 0f		      and	#$0f
    110  38c8		       d0 0a		      bne	.noEE
    111  38ca							; only instead if intermission 4:
    112  38ca		       a4 b0		      ldy	cave
    113  38cc		       c0 5f		      cpy	#MAX_CAVENUM-CAVE_DATA_SIZE
    114  38ce		       d0 04		      bne	.noEE
    115  38d0							; enable easter egg intermission cave:
    116  38d0		       a0 64		      ldy	#MAX_CAVENUM
    117  38d2		       84 b0		      sty	cave
    118  38d4				   .noEE
    119  38d4					      ENDIF
    120  38d4		       a4 b0		      ldy	cave
    121  38d6		       b9 7d f3 	      lda	CaveInformation,y
    122  38d9		       85 bf		      sta	Board_AddressR
    123  38db		       b9 7e f3 	      lda	CaveInformation+1,y
    124  38de		       85 c0		      sta	Board_AddressR+1	; source of the board data (bank handled later)
    125  38e0
    126  38e0		       b9 80 f3 	      lda	CaveInformation+3,y	; size of the board data in bytes
    127  38e3		       8d 0e f5 	      sta	SMLimit+RAM_WRITE+1	; might as well use self-modifying
    128  38e6
    129  38e6		       b9 81 f3 	      lda	CaveInformation+4,y
    130  38e9		       85 b2		      sta	caveDisplay	; what to display as the cave ID.
    131  38eb
    132  38eb		       a2 00		      ldx	#0
    133  38ed		       86 bb		      stx	caveTimeFrac	; now the 1st second is fully available
    134  38ef		       86 cc		      stx	amoebaFlag
    135  38f1		       86 df	   CopyBoardData stx	savex
    136  38f3
    137  38f3							; We are using GetROMByte to get *any* byte from ROM (although it was designed
    138  38f3							; just to get a board-character).  Should be OK.
    139  38f3
    140  38f3		       a4 b0		      ldy	cave
    141  38f5		       b9 7f f3 	      lda	CaveInformation+2,y	; bank of the board data
    142  38f8		       a0 00		      ldy	#0
    143  38fa		       20 df f8 	      jsr	GetROMByte	; note, this returns to ROM -- but that's a copy of us!!
    144  38fd		       a4 c4		      ldy	RAM_Bank	; RAM bank we are *actually* running from
    145  38ff		       84 3e		      sty	SET_BANK_RAM	; and switch 'ourself' back in.  Sneaky.
    146  3901
    147  3901		       a6 df		      ldx	savex
    148  3903		       9d 00 f4 	      sta	BOARD_DATA_AREA + RAM_WRITE,x	; save byte from ROM into our local RAM buffer
    149  3906
    150  3906		       e6 bf		      inc	Board_AddressR
    151  3908		       d0 02		      bne	NoPage
    152  390a		       e6 c0		      inc	Board_AddressR+1	; point to next byte of data
    153  390c				   NoPage
    154  390c
    155  390c		       e8		      inx
    156  390d		       e0 00	   SMLimit    cpx	#0	; byte count (self) modified by board size
    157  390f		       d0 e0		      bne	CopyBoardData
    158  3911
    159  3911
    160  3911							;------------------------------------------------------------------------------
    161  3911
    162  3911
    163  3911		       a9 00		      lda	#<BOARD_DATA_AREA
    164  3913		       85 df		      sta	ptrCave
    165  3915		       a9 f0		      lda	#>BOARD_DATA_AREA
    166  3917		       85 e0		      sta	ptrCave+1
    167  3919
    168  3919							; colors are organised in 3 NTSC/PAL pairs (medium mixcolor, dark color, bright mixcolor)
    169  3919		       a5 81		      lda	Platform
    170  391b		       c9 02		      cmp	#PAL
    171  391d		       a0 1a		      ldy	#.COLOR_OFS+5
    172  391f		       b0 01		      bcs	.originalPlatform
    173  3921		       88		      dey
    174  3922				   .originalPlatform
    175  3922		       a2 02		      ldx	#3-1
    176  3924				   .copyCols
    177  3924		       b1 df		      lda	(ptrCave),y
    178  3926		       95 bc		      sta	color,x
    179  3928		       88		      dey
    180  3929		       88		      dey
    181  392a		       ca		      dex
    182  392b		       10 f7		      bpl	.copyCols
    183  392d
    184  392d		       a0 01		      ldy	#.SIZE_OFS
    185  392f		       b1 df		      lda	(ptrCave),y
    186  3931		       85 98		      sta	BoardLimit_Width
    187  3933		       8d f7 f7 	      sta	BoundingWall+RAM_WRITE+3
    188  3936		       c8		      iny
    189  3937		       b1 df		      lda	(ptrCave),y
    190  3939		       85 99		      sta	BoardLimit_Height
    191  393b		       8d f8 f7 	      sta	BoundingWall+RAM_WRITE+4
    192  393e
    193  393e							;*** 1. load some cave data ***
    194  393e		       c8		      iny		;	     Y == 3 == .MAGIC_OFS
    195  393f		       b1 df		      lda	(ptrCave),y
    196  3941		       85 b5		      sta	magicAmoebaTime
    197  3943
    198  3943		       c8		      iny		;	     Y == 4 == .WORTH_OFS
    199  3944		       b1 df		      lda	(ptrCave),y
    200  3946							;jsr	  Convert2BCD
    201  3946		       85 b7		      sta	diamondsWorth	; now BCD in cave data
    202  3948
    203  3948		       a0 05		      ldy	#.EXTRA_WORTH_OFS
    204  394a		       b1 df		      lda	(ptrCave),y
    205  394c							;jsr	  Convert2BCD
    206  394c		       85 b8		      sta	diamondsExtraWorth	; now BCD in cave data
    207  394e
    208  394e		       a9 10		      lda	#.TIME_OFS
    209  3950		       20 73 f2 	      jsr	GetLevelDataBCD
    210  3953		       85 b9		      sta	caveTime
    211  3955		       86 ba		      stx	caveTimeHi
    212  3957
    213  3957		       a9 0b		      lda	#.DIAMONDS_OFS
    214  3959		       20 73 f2 	      jsr	GetLevelDataBCD
    215  395c		       85 b6		      sta	diamondsNeeded	;	 should never be 0
    216  395e
    217  395e							; *** 2. create random objects ***
    218  395e							; set initial random seed for level:
    219  395e		       a9 00		      lda	#0
    220  3960		       85 e3		      sta	randSeed1
    221  3962		       a9 06		      lda	#.RND_INIT_OFS
    222  3964		       20 97 f2 	      jsr	GetLevelData
    223  3967		       85 e4		      sta	randSeed2
    224  3969
    225  3969							; setup pointers:
    226  3969		       a9 1f		      lda	#.RND_VALUE_OFS
    227  396b		       a2 02		      ldx	#2
    228  396d		       20 a0 f2 	      jsr	AddPointer	;	 set ptrCave+2 to random values
    229  3970		       a9 1b		      lda	#.RND_OBJECT_OFS
    230  3972		       20 9e f2 	      jsr	AddPointer0	;	 set ptrCave+0 to random objects
    231  3975
    232  3975							; loop the board:
    233  3975		       a0 01		      ldy	#1
    234  3977				   .loopRows
    235  3977		       84 90		      sty	POS_Y
    236  3979		       a2 00		      ldx	#0
    237  397b				   .loopColumns
    238  397b		       86 8f		      stx	POS_X
    239  397d							; get random object type:
    240  397d		       20 ac f2 	      jsr	NextRandom	;	 a = randSeed1
    241  3980		       a0 03		      ldy	#.NUM_RANDOM-1
    242  3982				   .loopRandom
    243  3982		       d1 e1		      cmp	(ptrCave+2),y
    244  3984		       90 06		      bcc	.exitRandom
    245  3986		       88		      dey
    246  3987		       10 f9		      bpl	.loopRandom
    247  3989		       a9 01		      lda	#CHARACTER_SOIL	;	 default character (dirt), = 0
      0  398b					      NOP_W
      1  398b		       0c		      .byte.b	$0c
    249  398c				   .exitRandom
    250  398c		       b1 df		      lda	(ptrCave),y
    251  398e		       85 93		      sta	POS_Type
    252  3990
    253  3990							; put new object on board:
    254  3990		       20 11 f9 	      jsr	PutBoardCharacterFromRAM
    255  3993							; goto next board cell:
    256  3993		       a6 8f		      ldx	POS_X
    257  3995		       e8		      inx
    258  3996		       e4 98		      cpx	BoardLimit_Width
    259  3998		       90 e1		      bcc	.loopColumns
    260  399a		       a4 90		      ldy	POS_Y
    261  399c		       c8		      iny
    262  399d		       c4 99		      cpy	BoardLimit_Height
    263  399f		       90 d6		      bcc	.loopRows
    264  39a1
    265  39a1							; *** 3. draw the bounding steel wall: ***
    266  39a1		       a9 f4		      lda	#<(BoundingWall)
    267  39a3		       85 df		      sta	ptrCave
    268  39a5		       a9 f3		      lda	#>(BoundingWall)
    269  39a7		       85 e0		      sta	ptrCave+1
    270  39a9		       20 d0 f2 	      jsr	DecodeBoundary
    271  39ac
    272  39ac							; ...and decode the structures...
    273  39ac		       a9 00		      lda	#<(BOARD_DATA_AREA)
    274  39ae		       85 df		      sta	ptrCave
    275  39b0		       a9 f0		      lda	#>(BOARD_DATA_AREA)
    276  39b2		       85 e0		      sta	ptrCave+1
    277  39b4		       20 cb f2 	      jsr	DecodeStructures
    278  39b7
    279  39b7							;*** 4. activate all objects: ***
    280  39b7
    281  39b7				   ActivateObjects
    282  39b7
    283  39b7		       a4 99		      ldy	BoardLimit_Height
    284  39b9				   .loopY
    285  39b9		       88		      dey
    286  39ba		       84 90		      sty	POS_Y
    287  39bc		       a6 98		      ldx	BoardLimit_Width
    288  39be				   .loopX
    289  39be		       ca		      dex
    290  39bf		       86 8f		      stx	POS_X
    291  39c1		       20 fd f8 	      jsr	GetBoardCharacter__CALL_FROM_RAM__	;6+61(A)
    292  39c4		       aa		      tax
    293  39c5		       bd 4a f2 	      lda	CharToType2,x
    294  39c8		       30 64		      bmi	.skipActivate
    295  39ca
    296  39ca		       c9 40		      cmp	#SPECIAL_ADD
    297  39cc		       29 1f		      and	#TYPEMASK
    298  39ce		       85 93		      sta	POS_Type	;	 creature TYPE
    299  39d0		       90 23		      bcc	.Activate
    300  39d2
    301  39d2					      IF	SPECIAL_ADD_DECODECAVE = YES
    302  39d2
    303  39d2							;-------------------------------------------------------------------------------------------------------------
    304  39d2							; 23/June/2011: Some objects (boulders, diamonds) of type SPECIAL_ADD only go onto the creature stack IF they
    305  39d2							; have a surrounding blank square which means they MAY fall on startup.  So, we need to see if the LRD squares
    306  39d2							; (any) are blank. They may not ACTUALLY fall, but that will be checked in due course as they're on the stack.
    307  39d2
    308  39d2							;  +---+---+---+
    309  39d2							;  | 1 | X | 2 |
    310  39d2							;  +---+---+---+
    311  39d2							;	| 0 |
    312  39d2							;	+---+
    313  39d2
    314  39d2
    315  39d2		       e6 90		      inc	POS_Y
    316  39d4		       20 fd f8 	      jsr	GetBoardCharacter__CALL_FROM_RAM__	;6+61(A)[0]
    317  39d7		       c6 90		      dec	POS_Y
    318  39d9		       c9 00		      cmp	#0
    319  39db		       f0 16		      beq	ItIsBlank
    320  39dd
    321  39dd		       c6 8f		      dec	POS_X
    322  39df		       20 fd f8 	      jsr	GetBoardCharacter__CALL_FROM_RAM__	;6+61(A)[1]
    323  39e2		       e6 8f		      inc	POS_X
    324  39e4		       c9 00		      cmp	#0
    325  39e6		       f0 0b		      beq	ItIsBlank
    326  39e8
    327  39e8		       e6 8f		      inc	POS_X
    328  39ea		       20 fd f8 	      jsr	GetBoardCharacter__CALL_FROM_RAM__	;6+61(A)[2]
    329  39ed		       c6 8f		      dec	POS_X
    330  39ef		       c9 00		      cmp	#0
    331  39f1		       d0 3b		      bne	.skipActivate
    332  39f3
    333  39f3		       a5 93	   ItIsBlank  lda	POS_Type
    334  39f5
    335  39f5				  -	      ELSE
    336  39f5				  -	      jmp	.skipActivate
    337  39f5					      ENDIF
    338  39f5
    339  39f5							;-------------------------------------------------------------------------------------------------------------
    340  39f5
    341  39f5				   .Activate
    342  39f5		       a8		      tay
    343  39f6		       b9 62 f2 	      lda	InitialFace,y
    344  39f9		       85 94		      sta	POS_VAR
    345  39fb
    346  39fb		       bd 4a f2 	      lda	CharToType2,x
    347  39fe		       29 20		      and	#ALTERNATE_FACE
    348  3a00		       f0 04		      beq	noAlternate
    349  3a02
    350  3a02		       e6 94		      inc	POS_VAR
    351  3a04		       e6 94		      inc	POS_VAR
    352  3a06
    353  3a06		       98	   noAlternate tya
    354  3a07		       aa		      tax
    355  3a08		       e0 02		      cpx	#TYPE_AMOEBA
    356  3a0a		       f0 03		      beq	skipAmoebaSpecial
    357  3a0c
    358  3a0c		       20 74 fb 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    359  3a0f
    360  3a0f				   skipAmoebaSpecial
    361  3a0f							;tes
    362  3a0f
    363  3a0f							; handle special types:
    364  3a0f		       a6 8f		      ldx	POS_X	;	 x coordinate
    365  3a11		       a4 90		      ldy	POS_Y	;	 y coordinate
    366  3a13		       a5 93		      lda	POS_Type
    367  3a15		       c9 02		      cmp	#TYPE_AMOEBA
    368  3a17		       d0 0d		      bne	.skipAmoeba
    369  3a19
    370  3a19		       a9 40		      lda	#AMOEBA_PRESENT
    371  3a1b		       85 cc		      sta	amoebaFlag	; this turns ON the scanning for this level
    372  3a1d							; Remember initial Amoeba position for bounding box.
    373  3a1d							; Since always the left most cell is added last and there are no more than two cells in same row at the beginning,
    374  3a1d							; simply increasing the maximum X by 1 solves the problem
    375  3a1d		       86 ce		      stx	amoebaMinX
    376  3a1f		       e8		      inx
    377  3a20		       86 d0		      stx	amoebaMaxX
    378  3a22		       84 cf		      sty	amoebaMinY
    379  3a24		       84 d1		      sty	amoebaMaxY
    380  3a26
    381  3a26				   .skipAmoeba
    382  3a26		       c9 00		      cmp	#TYPE_MAN
    383  3a28		       d0 04		      bne	.skipActivate
    384  3a2a
    385  3a2a							; insert man:
    386  3a2a		       86 9f		      stx	ManX
    387  3a2c		       84 a0		      sty	ManY
    388  3a2e
    389  3a2e		       a6 8f	   .skipActivate ldx	POS_X	;	 x coordinate
    390  3a30		       d0 8c		      bne	.loopX
    391  3a32		       a4 90		      ldy	POS_Y	;	 y coordinate
    392  3a34		       d0 83		      bne	.loopY
    393  3a36
    394  3a36
    395  3a36							; adjusts playing speed based on level:
    396  3a36
    397  3a36		       a9 04		      lda	#NUM_LEVELS-1	; intermissions run at full speed
    398  3a38		       24 b2		      bit	caveDisplay
    399  3a3a		       30 02		      bmi	.intermission3
    400  3a3c		       a5 b1		      lda	level
    401  3a3e				   .intermission3
    402  3a3e		       0a		      asl
    403  3a3f		       0a		      asl
    404  3a40		       05 81		      ora	Platform
    405  3a42		       4a		      lsr
    406  3a43		       aa		      tax
    407  3a44		       bd 94 f0 	      lda	ThrottleSpeedTbl,x
    408  3a47		       85 b4		      sta	ThrottleSpeed
    409  3a49
    410  3a49		       60		      rts
    411  3a4a
    412  3a4a
    413  3a4a							;------------------------------------------------------------------------------
    414  3a4a
    415  3a4a
    416  3a4a		       00 80	   NOT_ADDED  =	128
    417  3a4a		       00 ff	   NULL_TYPE  =	255
    418  3a4a		       00 40	   SPECIAL_ADD =	64
    419  3a4a		       00 20	   ALTERNATE_FACE =	32
    420  3a4a		       00 1f	   TYPEMASK   =	31
    421  3a4a
    422  3a4a
    423  3a4a				   CharToType2
    424  3a4a
    425  3a4a							; Converts a character # to a creature type
    426  3a4a							; add 128 if character is NOT to be added as a creature on board draw
    427  3a4a
    428  3a4a		       ff		      .byte.b	NULL_TYPE	; blank
    429  3a4b		       ff		      .byte.b	NULL_TYPE	; soil
    430  3a4c		       41		      .byte.b	TYPE_BOULDER + SPECIAL_ADD
    431  3a4d		       02		      .byte.b	TYPE_AMOEBA
    432  3a4e		       45		      .byte.b	TYPE_DIAMOND + SPECIAL_ADD
    433  3a4f		       45		      .byte.b	TYPE_DIAMOND + SPECIAL_ADD
    434  3a50		       00		      .byte.b	TYPE_MAN
    435  3a51		       03		      .byte.b	TYPE_FLUTTERBY
    436  3a52		       23		      .byte.b	TYPE_FLUTTERBY + ALTERNATE_FACE	; character_flutterby2
    437  3a53		       04		      .byte.b	TYPE_FIREFLY
    438  3a54		       24		      .byte.b	TYPE_FIREFLY + ALTERNATE_FACE	; character_firefly2
    439  3a55		       86		      .byte.b	TYPE_MAGICWALL + NOT_ADDED
    440  3a56		       86		      .byte.b	TYPE_MAGICWALL + NOT_ADDED
    441  3a57		       86		      .byte.b	TYPE_MAGICWALL + NOT_ADDED
    442  3a58		       86		      .byte.b	TYPE_MAGICWALL + NOT_ADDED
    443  3a59		       ff		      .byte.b	NULL_TYPE	; steel wall
    444  3a5a		       ff		      .byte.b	NULL_TYPE	; plain brick wall
    445  3a5b		       87		      .byte.b	TYPE_EXITDOOR + NOT_ADDED
    446  3a5c		       87		      .byte.b	TYPE_EXITDOOR + NOT_ADDED
    447  3a5d		       09		      .byte.b	TYPE_EXPLOSION
    448  3a5e		       0a		      .byte.b	TYPE_EXPLOSION1
    449  3a5f		       0b		      .byte.b	TYPE_EXPLOSION2
    450  3a60		       08		      .byte.b	TYPE_SELECTOR	;EXPLOSION3		     ; overload explosion character
    451  3a61		       02		      .byte.b	TYPE_AMOEBA
    452  3a62
    453  3a62							; The following two will NEVER APPEAR ON BOARD DECODE DATA so can be skipped
    454  3a62							;.byte TYPE_BOULDER				  ; falling boulder
    455  3a62							;.byte TYPE_DIAMOND
    456  3a62							;.byte TYPE_MAN				 ; unkillable man
    457  3a62
    458  3a62							; --> see also MoveVec
    459  3a62							; --> see also DecodeCave's table
    460  3a62
      0  3a62					      DEFINE_SUBROUTINE	InitialFace	;[type]
      1  3a62		       00 07	   BANK_InitialFace =	_CURRENT_BANK
      2  3a62					      SUBROUTINE
      3  3a62				   InitialFace
    462  3a62
    463  3a62							; Given an object type, gives an initial facing direction for that type.
    464  3a62							; If changing, also see 'DEFINE' definitions of types in BANK_INITBANK.asm
    465  3a62
    466  3a62		       00		      .byte.b	0	; MAN
    467  3a63		       00		      .byte.b	0	; BOULDER
    468  3a64		       00		      .byte.b	0	; AMOEBA
    469  3a65		       02		      .byte.b	FACE_DOWN	; FLUTTERBY	 starts life facing down
    470  3a66		       0b		      .byte.b	FACE_LEFT+8	; FIREFLY	 starts life facing left
    471  3a67		       00		      .byte.b	0	; DIAMOND
    472  3a68		       01		      .byte.b	1	; WALL0						 facing????
    473  3a69		       00		      .byte.b	0	; EXITDOOR
    474  3a6a		       00		      .byte.b	0	; SELECT
    475  3a6b		       00		      .byte.b	0	; EXPLOSION
    476  3a6c		       00		      .byte.b	0	; EXPLOSION1
    477  3a6d		       00		      .byte.b	0	; EXPLOSION2
    478  3a6e		       00		      .byte.b	0	; EXPLOSION3
    479  3a6f		       00		      .byte.b	0	; BLANK
    480  3a70		       00		      .byte.b	0	; SOIL
    481  3a71		       00		      .byte.b	0	; STEEL
    482  3a72		       00		      .byte.b	0	; WALL
    483  3a73
    484  3a73
    485  3a73				   GetLevelDataBCD		; SUBROUTINE
    486  3a73		       20 97 f2 	      jsr	GetLevelData
    487  3a76
    488  3a76				   Convert2BCD		; SUBROUTINE
    489  3a76		       a2 00		      ldx	#0
    490  3a78		       a0 ff		      ldy	#<(-1)
    491  3a7a				   .loop
    492  3a7a		       c8		      iny
    493  3a7b		       c0 0a		      cpy	#10
    494  3a7d		       90 03		      bcc	.ok
    495  3a7f		       a0 00		      ldy	#0
    496  3a81		       e8		      inx
    497  3a82				   .ok
    498  3a82		       38		      sec
    499  3a83		       e9 0a		      sbc	#10
    500  3a85		       b0 f3		      bcs	.loop
    501  3a87		       69 0a		      adc	#10
    502  3a89		       19 8d f2 	      ora	Mult16Tbl,y
    503  3a8c		       60		      rts
    504  3a8d
    505  3a8d				   Y	      SET	0
    506  3a8d				   Mult16Tbl
    507  3a8d					      REPEAT	10
    508  3a8d		       00		      .byte.b	Y
    509  3a8d				   Y	      SET	Y + $10
    507  3a8d					      REPEND
    508  3a8e		       10		      .byte.b	Y
    509  3a8e				   Y	      SET	Y + $10
    507  3a8e					      REPEND
    508  3a8f		       20		      .byte.b	Y
    509  3a8f				   Y	      SET	Y + $10
    507  3a8f					      REPEND
    508  3a90		       30		      .byte.b	Y
    509  3a90				   Y	      SET	Y + $10
    507  3a90					      REPEND
    508  3a91		       40		      .byte.b	Y
    509  3a91				   Y	      SET	Y + $10
    507  3a91					      REPEND
    508  3a92		       50		      .byte.b	Y
    509  3a92				   Y	      SET	Y + $10
    507  3a92					      REPEND
    508  3a93		       60		      .byte.b	Y
    509  3a93				   Y	      SET	Y + $10
    507  3a93					      REPEND
    508  3a94		       70		      .byte.b	Y
    509  3a94				   Y	      SET	Y + $10
    507  3a94					      REPEND
    508  3a95		       80		      .byte.b	Y
    509  3a95				   Y	      SET	Y + $10
    507  3a95					      REPEND
    508  3a96		       90		      .byte.b	Y
    509  3a96				   Y	      SET	Y + $10
    510  3a97					      REPEND
    511  3a97
    512  3a97				   GetLevelData 		; SUBROUTINE
    513  3a97		       18		      clc
    514  3a98		       65 b1		      adc	level
    515  3a9a		       a8		      tay
    516  3a9b		       b1 df		      lda	(ptrCave),y
    517  3a9d		       60		      rts
    518  3a9e
    519  3a9e				   AddPointer0
    520  3a9e		       a2 00		      ldx	#0
    521  3aa0				   AddPointer
    522  3aa0		       18		      clc
    523  3aa1		       65 df		      adc	ptrCave
    524  3aa3		       95 df		      sta	ptrCave,x
    525  3aa5		       a5 e0		      lda	ptrCave+1
    526  3aa7		       69 00		      adc	#0
    527  3aa9		       95 e0		      sta	ptrCave+1,x
    528  3aab		       60		      rts
    529  3aac
    530  3aac
    531  3aac				   NextRandom
    532  3aac		       a5 e3		      lda	randSeed1
    533  3aae		       6a		      ror
    534  3aaf		       6a		      ror
    535  3ab0		       29 80		      and	#$80
    536  3ab2		       85 e5		      sta	tempRand1	;	 TempRand1 = (RandSeed1 & 1) << 7
    537  3ab4
    538  3ab4		       a5 e4		      lda	randSeed2
    539  3ab6		       4a		      lsr
    540  3ab7		       85 e6		      sta	tempRand2	;	 TempRand2 = RandSeed2 >> 1
    541  3ab9
    542  3ab9							;		  lda	  randSeed2
    543  3ab9							;		  and	  #$01
    544  3ab9							;		  lsr
    545  3ab9		       a9 00		      lda	#$00
    546  3abb		       6a		      ror
    547  3abc		       65 e4		      adc	randSeed2	;	 C=0!
    548  3abe		       69 13		      adc	#$13	;	 C=?
    549  3ac0		       85 e4		      sta	randSeed2	;	 RandSeed2 = RandSeed2 << 7 + RandSeed2 + $13
    550  3ac2
    551  3ac2		       a5 e3		      lda	randSeed1
    552  3ac4		       65 e5		      adc	tempRand1	;	 C=?
    553  3ac6		       65 e6		      adc	tempRand2	;	 C=?
    554  3ac8		       85 e3		      sta	randSeed1
    555  3aca				   Exit
    556  3aca		       60		      rts
    557  3acb
    558  3acb
    559  3acb				   DecodeStructures
    560  3acb		       a9 23		      lda	#.STRUCT_OFFSET
    561  3acd				   .loopStructures
    562  3acd		       20 9e f2 	      jsr	AddPointer0
    563  3ad0				   DecodeBoundary
    564  3ad0							; load structure type and object:
    565  3ad0		       a0 00		      ldy	#0
    566  3ad2		       b1 df		      lda	(ptrCave),y
    567  3ad4		       c9 ff		      cmp	#.STRUCT_DELIMITER
    568  3ad6		       f0 f2		      beq	Exit
    569  3ad8		       29 3f		      and	#(~.STRUCTURE_MASK) & $FF
    570  3ada		       85 93		      sta	POS_Type
    571  3adc		       51 df		      eor	(ptrCave),y
    572  3ade		       0a		      asl
    573  3adf		       2a		      rol
    574  3ae0		       2a		      rol
    575  3ae1		       85 e3		      sta	structType
    576  3ae3							; load structure values:
    577  3ae3		       a0 01		      ldy	#1
    578  3ae5		       b1 df		      lda	(ptrCave),y	;	 +1
    579  3ae7		       85 e4		      sta	column
    580  3ae9		       c8		      iny
    581  3aea		       b1 df		      lda	(ptrCave),y	;	 +2
    582  3aec		       38		      sec
    583  3aed		       e9 02		      sbc	#2	;	 cave starts at row 2 in C64 original
    584  3aef		       85 e5		      sta	row
    585  3af1		       c8		      iny
    586  3af2		       b1 df		      lda	(ptrCave),y	;	 +3
    587  3af4		       85 e6		      sta	length
    588  3af6		       c8		      iny
    589  3af7		       b1 df		      lda	(ptrCave),y	;	 +4
    590  3af9		       85 e1		      sta	height	;	 == direction for LINE
    591  3afb
    592  3afb							; process structure:
    593  3afb		       a6 e3		      ldx	structType
    594  3afd		       d0 12		      bne	.skipSingle
    595  3aff							; draw single object:
    596  3aff		       a6 e4		      ldx	column
    597  3b01		       86 8f		      stx	POS_X
    598  3b03		       a5 e5		      lda	row
    599  3b05		       85 90		      sta	POS_Y
    600  3b07		       20 11 f9 	      jsr	PutBoardCharacterFromRAM
    601  3b0a
    602  3b0a				   .nextStructure
    603  3b0a		       a6 e3		      ldx	structType
    604  3b0c		       bd f0 f3 	      lda	StructureSizeTbl,x
    605  3b0f		       d0 bc		      bne	.loopStructures	; 3	 unconditional
    606  3b11							;    DEBUG_BRK
    607  3b11
    608  3b11				   .skipSingle
    609  3b11		       ca		      dex
    610  3b12		       d0 05		      bne	.skipLine
    611  3b14							; draw a line:
    612  3b14		       20 3d f3 	      jsr	DrawLine	;	 a == direction
    613  3b17		       f0 f1		      beq	.nextStructure	; 3	 unconditional
    614  3b19							;    DEBUG_BRK
    615  3b19
    616  3b19				   .skipLine
    617  3b19		       ca		      dex
    618  3b1a		       d0 1a		      bne	.skipFilled
    619  3b1c							; draw a filled rectangle:
    620  3b1c		       20 68 f3 	      jsr	DrawRectangle
    621  3b1f
    622  3b1f		       a0 05		      ldy	#5
    623  3b21		       b1 df		      lda	(ptrCave),y	;	 +5
    624  3b23		       85 93		      sta	POS_Type
    625  3b25
    626  3b25		       e6 e4		      inc	column
    627  3b27		       c6 e1		      dec	height
    628  3b29		       c6 e6		      dec	length
    629  3b2b				   .loopFill
    630  3b2b		       e6 e5		      inc	row
    631  3b2d		       20 3b f3 	      jsr	DrawLineRight
    632  3b30		       c6 e1		      dec	height
    633  3b32		       d0 f7		      bne	.loopFill
    634  3b34		       f0 d4		      beq	.nextStructure	; 3	 unconditional
    635  3b36
    636  3b36				   .skipFilled
    637  3b36							; draw a rectangle:
    638  3b36		       20 68 f3 	      jsr	DrawRectangle
    639  3b39		       f0 cf		      beq	.nextStructure	; 3	 unconditional
    640  3b3b							;    DEBUG_BRK
    641  3b3b
    642  3b3b				   DrawLineRight
    643  3b3b		       a9 02		      lda	#.DIR_RIGHT
    644  3b3d				   DrawLine
    645  3b3d		       a6 e4		      ldx	column
    646  3b3f		       a4 e5		      ldy	row
    647  3b41							; direction is set outside
    648  3b41		       86 8f		      stx	POS_X
    649  3b43		       84 90		      sty	POS_Y
    650  3b45				   DrawNextHLine
    651  3b45		       a6 e6		      ldx	length
      0  3b47					      NOP_W
      1  3b47		       0c		      .byte.b	$0c
    653  3b48				   DrawNextVLine
    654  3b48		       a6 e1		      ldx	height
    655  3b4a		       85 e2		      sta	direction
    656  3b4c		       86 e9		      stx	tmpLength
    657  3b4e				   .loopLine
    658  3b4e		       20 11 f9 	      jsr	PutBoardCharacterFromRAM
    659  3b51		       a4 e2		      ldy	direction
    660  3b53		       a5 8f		      lda	POS_X
    661  3b55		       18		      clc
    662  3b56		       79 e8 f3 	      adc	ColumnDirTbl,y
    663  3b59		       85 8f		      sta	POS_X
    664  3b5b		       a5 90		      lda	POS_Y
    665  3b5d		       18		      clc
    666  3b5e		       79 e6 f3 	      adc	RowDirTbl,y
    667  3b61		       85 90		      sta	POS_Y
    668  3b63		       c6 e9		      dec	tmpLength
    669  3b65		       d0 e7		      bne	.loopLine
    670  3b67		       60		      rts
    671  3b68
    672  3b68
    673  3b68				   DrawRectangle
    674  3b68		       c6 e6		      dec	length
    675  3b6a		       c6 e1		      dec	height
    676  3b6c
    677  3b6c		       20 3b f3 	      jsr	DrawLineRight
    678  3b6f
    679  3b6f		       a9 04		      lda	#.DIR_DOWN
    680  3b71		       20 48 f3 	      jsr	DrawNextVLine
    681  3b74		       a9 06		      lda	#.DIR_LEFT
    682  3b76		       20 45 f3 	      jsr	DrawNextHLine
    683  3b79		       a9 00		      lda	#.DIR_UP
    684  3b7b		       10 cb		      bpl	DrawNextVLine	; 3	 unconditional
    685  3b7d							;    DEBUG_BRK
    686  3b7d
    687  3b7d
    688  3b7d
    689  3b7d
    690  3b7d		       00 40	   SORT       =	$40	; wait for complete sort on this screen
    691  3b7d				   CAVENUM    SET	0
    692  3b7d		       00 05	   CAVE_DATA_SIZE =	5
    693  3b7d
    694  3b7d					      MAC	add_cave
    695  3b7d				   CAVE_ACTIVE_{1} SET	1
    696  3b7d				   CAVE_NAMED_{1} =	CAVENUM
    697  3b7d					      .byte	<CAVE_{1}
    698  3b7d					      .byte	>CAVE_{1}
    699  3b7d					      .byte	BANK_CAVE_{1}
    700  3b7d					      .byte	CAVE_SIZE_{1}
    701  3b7d					      .byte	{2}	; display as #.  $80 indicates intermission.
    702  3b7d				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    703  3b7d					      ENDM		; {name}
    704  3b7d
    705  3b7d				   CaveInformation
    706  3b7d
    707  3b7d							; The ordering here corresponds to the ordering when playing...
    708  3b7d					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  3b7d					      ADD_CAVE	INTRO,SORT+1
      1  3b7d				   CAVE_ACTIVE_INTRO SET	1
      2  3b7d		       00 00	   CAVE_NAMED_INTRO =	CAVENUM
      3  3b7d		       ff		      .byte.b	<CAVE_INTRO
      4  3b7e		       f3		      .byte.b	>CAVE_INTRO
      5  3b7f		       06		      .byte.b	BANK_CAVE_INTRO
      6  3b80		       34		      .byte.b	CAVE_SIZE_INTRO
      7  3b81		       41		      .byte.b	SORT+1
      8  3b81				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3b82					      ADD_CAVE	ROOMS,SORT+2
      1  3b82				   CAVE_ACTIVE_ROOMS SET	1
      2  3b82		       00 05	   CAVE_NAMED_ROOMS =	CAVENUM
      3  3b82		       33		      .byte.b	<CAVE_ROOMS
      4  3b83		       f4		      .byte.b	>CAVE_ROOMS
      5  3b84		       06		      .byte.b	BANK_CAVE_ROOMS
      6  3b85		       5c		      .byte.b	CAVE_SIZE_ROOMS
      7  3b86		       42		      .byte.b	SORT+2
      8  3b86				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3b87					      ADD_CAVE	MAZE,SORT+3
      1  3b87				   CAVE_ACTIVE_MAZE SET	1
      2  3b87		       00 0a	   CAVE_NAMED_MAZE =	CAVENUM
      3  3b87		       8f		      .byte.b	<CAVE_MAZE
      4  3b88		       f4		      .byte.b	>CAVE_MAZE
      5  3b89		       06		      .byte.b	BANK_CAVE_MAZE
      6  3b8a		       2a		      .byte.b	CAVE_SIZE_MAZE
      7  3b8b		       43		      .byte.b	SORT+3
      8  3b8b				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3b8c					      ADD_CAVE	BUTTERFLIES,SORT+4
      1  3b8c				   CAVE_ACTIVE_BUTTERFLIES SET	1
      2  3b8c		       00 0f	   CAVE_NAMED_BUTTERFLIES =	CAVENUM
      3  3b8c		       b9		      .byte.b	<CAVE_BUTTERFLIES
      4  3b8d		       f4		      .byte.b	>CAVE_BUTTERFLIES
      5  3b8e		       06		      .byte.b	BANK_CAVE_BUTTERFLIES
      6  3b8f		       4e		      .byte.b	CAVE_SIZE_BUTTERFLIES
      7  3b90		       44		      .byte.b	SORT+4
      8  3b90				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3b91					      ADD_CAVE	INTERMISSION_1,SORT+$80|$0
      1  3b91				   CAVE_ACTIVE_INTERMISSION_1 SET	1
      2  3b91		       00 14	   CAVE_NAMED_INTERMISSION_1 =	CAVENUM
      3  3b91		       15		      .byte.b	<CAVE_INTERMISSION_1
      4  3b92		       f6		      .byte.b	>CAVE_INTERMISSION_1
      5  3b93		       05		      .byte.b	BANK_CAVE_INTERMISSION_1
      6  3b94		       39		      .byte.b	CAVE_SIZE_INTERMISSION_1
      7  3b95		       c0		      .byte.b	SORT+$80|$0
      8  3b95				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    714  3b96
      0  3b96					      ADD_CAVE	GUARDS,SORT+5
      1  3b96				   CAVE_ACTIVE_GUARDS SET	1
      2  3b96		       00 19	   CAVE_NAMED_GUARDS =	CAVENUM
      3  3b96		       83		      .byte.b	<CAVE_GUARDS
      4  3b97		       f4		      .byte.b	>CAVE_GUARDS
      5  3b98		       04		      .byte.b	BANK_CAVE_GUARDS
      6  3b99		       8a		      .byte.b	CAVE_SIZE_GUARDS
      7  3b9a		       45		      .byte.b	SORT+5
      8  3b9a				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3b9b					      ADD_CAVE	FIREFLY_DENS,SORT+6
      1  3b9b				   CAVE_ACTIVE_FIREFLY_DENS SET	1
      2  3b9b		       00 1e	   CAVE_NAMED_FIREFLY_DENS =	CAVENUM
      3  3b9b		       0d		      .byte.b	<CAVE_FIREFLY_DENS
      4  3b9c		       f5		      .byte.b	>CAVE_FIREFLY_DENS
      5  3b9d		       04		      .byte.b	BANK_CAVE_FIREFLY_DENS
      6  3b9e		       94		      .byte.b	CAVE_SIZE_FIREFLY_DENS
      7  3b9f		       46		      .byte.b	SORT+6
      8  3b9f				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3ba0					      ADD_CAVE	AMOEBA,SORT+7
      1  3ba0				   CAVE_ACTIVE_AMOEBA SET	1
      2  3ba0		       00 23	   CAVE_NAMED_AMOEBA =	CAVENUM
      3  3ba0		       a1		      .byte.b	<CAVE_AMOEBA
      4  3ba1		       f5		      .byte.b	>CAVE_AMOEBA
      5  3ba2		       04		      .byte.b	BANK_CAVE_AMOEBA
      6  3ba3		       4b		      .byte.b	CAVE_SIZE_AMOEBA
      7  3ba4		       47		      .byte.b	SORT+7
      8  3ba4				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3ba5					      ADD_CAVE	ENCHANTED_WALL,SORT+8
      1  3ba5				   CAVE_ACTIVE_ENCHANTED_WALL SET	1
      2  3ba5		       00 28	   CAVE_NAMED_ENCHANTED_WALL =	CAVENUM
      3  3ba5		       ec		      .byte.b	<CAVE_ENCHANTED_WALL
      4  3ba6		       f5		      .byte.b	>CAVE_ENCHANTED_WALL
      5  3ba7		       04		      .byte.b	BANK_CAVE_ENCHANTED_WALL
      6  3ba8		       5a		      .byte.b	CAVE_SIZE_ENCHANTED_WALL
      7  3ba9		       48		      .byte.b	SORT+8
      8  3ba9				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    719  3baa
      0  3baa					      ADD_CAVE	INTERMISSION_2,SORT+$80|$1
      1  3baa				   CAVE_ACTIVE_INTERMISSION_2 SET	1
      2  3baa		       00 2d	   CAVE_NAMED_INTERMISSION_2 =	CAVENUM
      3  3baa		       4e		      .byte.b	<CAVE_INTERMISSION_2
      4  3bab		       f6		      .byte.b	>CAVE_INTERMISSION_2
      5  3bac		       05		      .byte.b	BANK_CAVE_INTERMISSION_2
      6  3bad		       53		      .byte.b	CAVE_SIZE_INTERMISSION_2
      7  3bae		       c1		      .byte.b	SORT+$80|$1
      8  3bae				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    721  3baf
      0  3baf					      ADD_CAVE	GREED,9
      1  3baf				   CAVE_ACTIVE_GREED SET	1
      2  3baf		       00 32	   CAVE_NAMED_GREED =	CAVENUM
      3  3baf		       46		      .byte.b	<CAVE_GREED
      4  3bb0		       f6		      .byte.b	>CAVE_GREED
      5  3bb1		       04		      .byte.b	BANK_CAVE_GREED
      6  3bb2		       46		      .byte.b	CAVE_SIZE_GREED
      7  3bb3		       09		      .byte.b	9
      8  3bb3				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3bb4					      ADD_CAVE	TRACKS,SORT+10
      1  3bb4				   CAVE_ACTIVE_TRACKS SET	1
      2  3bb4		       00 37	   CAVE_NAMED_TRACKS =	CAVENUM
      3  3bb4		       d7		      .byte.b	<CAVE_TRACKS
      4  3bb5		       f3		      .byte.b	>CAVE_TRACKS
      5  3bb6		       05		      .byte.b	BANK_CAVE_TRACKS
      6  3bb7		       68		      .byte.b	CAVE_SIZE_TRACKS
      7  3bb8		       4a		      .byte.b	SORT+10
      8  3bb8				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3bb9					      ADD_CAVE	CROWD,SORT+11
      1  3bb9				   CAVE_ACTIVE_CROWD SET	1
      2  3bb9		       00 3c	   CAVE_NAMED_CROWD =	CAVENUM
      3  3bb9		       3f		      .byte.b	<CAVE_CROWD
      4  3bba		       f4		      .byte.b	>CAVE_CROWD
      5  3bbb		       05		      .byte.b	BANK_CAVE_CROWD
      6  3bbc		       69		      .byte.b	CAVE_SIZE_CROWD
      7  3bbd		       4b		      .byte.b	SORT+11
      8  3bbd				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3bbe					      ADD_CAVE	WALLS,SORT+12
      1  3bbe				   CAVE_ACTIVE_WALLS SET	1
      2  3bbe		       00 41	   CAVE_NAMED_WALLS =	CAVENUM
      3  3bbe		       a8		      .byte.b	<CAVE_WALLS
      4  3bbf		       f4		      .byte.b	>CAVE_WALLS
      5  3bc0		       05		      .byte.b	BANK_CAVE_WALLS
      6  3bc1		       6d		      .byte.b	CAVE_SIZE_WALLS
      7  3bc2		       4c		      .byte.b	SORT+12
      8  3bc2				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    726  3bc3
      0  3bc3					      ADD_CAVE	INTERMISSION_3,SORT+$80|$2
      1  3bc3				   CAVE_ACTIVE_INTERMISSION_3 SET	1
      2  3bc3		       00 46	   CAVE_NAMED_INTERMISSION_3 =	CAVENUM
      3  3bc3		       a1		      .byte.b	<CAVE_INTERMISSION_3
      4  3bc4		       f6		      .byte.b	>CAVE_INTERMISSION_3
      5  3bc5		       05		      .byte.b	BANK_CAVE_INTERMISSION_3
      6  3bc6		       3b		      .byte.b	CAVE_SIZE_INTERMISSION_3
      7  3bc7		       c2		      .byte.b	SORT+$80|$2
      8  3bc7				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    728  3bc8
      0  3bc8					      ADD_CAVE	APOCALYPSE,13
      1  3bc8				   CAVE_ACTIVE_APOCALYPSE SET	1
      2  3bc8		       00 4b	   CAVE_NAMED_APOCALYPSE =	CAVENUM
      3  3bc8		       15		      .byte.b	<CAVE_APOCALYPSE
      4  3bc9		       f5		      .byte.b	>CAVE_APOCALYPSE
      5  3bca		       05		      .byte.b	BANK_CAVE_APOCALYPSE
      6  3bcb		       41		      .byte.b	CAVE_SIZE_APOCALYPSE
      7  3bcc		       0d		      .byte.b	13
      8  3bcc				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3bcd					      ADD_CAVE	ZIGZAG,SORT+14
      1  3bcd				   CAVE_ACTIVE_ZIGZAG SET	1
      2  3bcd		       00 50	   CAVE_NAMED_ZIGZAG =	CAVENUM
      3  3bcd		       56		      .byte.b	<CAVE_ZIGZAG
      4  3bce		       f5		      .byte.b	>CAVE_ZIGZAG
      5  3bcf		       05		      .byte.b	BANK_CAVE_ZIGZAG
      6  3bd0		       5d		      .byte.b	CAVE_SIZE_ZIGZAG
      7  3bd1		       4e		      .byte.b	SORT+14
      8  3bd1				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3bd2					      ADD_CAVE	FUNNEL,SORT+15
      1  3bd2				   CAVE_ACTIVE_FUNNEL SET	1
      2  3bd2		       00 55	   CAVE_NAMED_FUNNEL =	CAVENUM
      3  3bd2		       fb		      .byte.b	<CAVE_FUNNEL
      4  3bd3		       f3		      .byte.b	>CAVE_FUNNEL
      5  3bd4		       04		      .byte.b	BANK_CAVE_FUNNEL
      6  3bd5		       3e		      .byte.b	CAVE_SIZE_FUNNEL
      7  3bd6		       4f		      .byte.b	SORT+15
      8  3bd6				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  3bd7					      ADD_CAVE	ENCHANTED_BOXES,SORT+16
      1  3bd7				   CAVE_ACTIVE_ENCHANTED_BOXES SET	1
      2  3bd7		       00 5a	   CAVE_NAMED_ENCHANTED_BOXES =	CAVENUM
      3  3bd7		       b3		      .byte.b	<CAVE_ENCHANTED_BOXES
      4  3bd8		       f5		      .byte.b	>CAVE_ENCHANTED_BOXES
      5  3bd9		       05		      .byte.b	BANK_CAVE_ENCHANTED_BOXES
      6  3bda		       62		      .byte.b	CAVE_SIZE_ENCHANTED_BOXES
      7  3bdb		       50		      .byte.b	SORT+16
      8  3bdb				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    733  3bdc
      0  3bdc					      ADD_CAVE	INTERMISSION_4,SORT+$80|$3
      1  3bdc				   CAVE_ACTIVE_INTERMISSION_4 SET	1
      2  3bdc		       00 5f	   CAVE_NAMED_INTERMISSION_4 =	CAVENUM
      3  3bdc		       39		      .byte.b	<CAVE_INTERMISSION_4
      4  3bdd		       f4		      .byte.b	>CAVE_INTERMISSION_4
      5  3bde		       04		      .byte.b	BANK_CAVE_INTERMISSION_4
      6  3bdf		       4a		      .byte.b	CAVE_SIZE_INTERMISSION_4
      7  3be0		       c3		      .byte.b	SORT+$80|$3
      8  3be0				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    735  3be1
    736  3be1					      IF	EASTER_EGG = YES
      0  3be1					      ADD_CAVE	SPINDIZZY,SORT+$80|$4
      1  3be1				   CAVE_ACTIVE_SPINDIZZY SET	1
      2  3be1		       00 64	   CAVE_NAMED_SPINDIZZY =	CAVENUM
      3  3be1		       07		      .byte.b	<CAVE_SPINDIZZY
      4  3be2		       f5		      .byte.b	>CAVE_SPINDIZZY
      5  3be3		       06		      .byte.b	BANK_CAVE_SPINDIZZY
      6  3be4		       56		      .byte.b	CAVE_SIZE_SPINDIZZY
      7  3be5		       c4		      .byte.b	SORT+$80|$4
      8  3be5				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    738  3be5				   CAVENUM    SET	CAVENUM - CAVE_DATA_SIZE
    739  3be6					      ENDIF
    740  3be6				  -	      ELSE
    741  3be6				  -	      ADD_CAVE	APOCALYPSE,13
    742  3be6				  -	      ADD_CAVE	FUNNEL,SORT+15
    743  3be6					      ENDIF
    744  3be6							;---------------------------------------------------------------------------
    745  3be6
    746  3be6
    747  3be6				   RowDirTbl
    748  3be6		       ff ff		      .byte.b	-1, -1	;, 0, 1, 1, 1, 0, -1
    749  3be8				   ColumnDirTbl
    750  3be8		       00 01 01 01*	      .byte.b	0, 1, 1, 1, 0, -1, -1, -1
    751  3bf0
    752  3bf0				   StructureSizeTbl
    753  3bf0		       03 05 06 05	      .byte.b	3, 5, 6, 5
    754  3bf4
    755  3bf4
    756  3bf4							;foreground color is ignored (white instead), except for amoeba levels G and M (light green)
    757  3bf4
    758  3bf4							;C64 palette:
    759  3bf4							;	 website     x64	 ccs64
    760  3bf4							;00	 00 00 00    00 00 00	 19 1d 19    black
    761  3bf4							;01	 FF FF FF    ff ff ff	 fc f9 fc    white
    762  3bf4							;02	 74 43 35		 a0 3a 4c    red
    763  3bf4							;03	 7c ac ba		 b6 fa fa    cyan
    764  3bf4							;04	 7b 48 90    8a 46 ae	 d2 7d ed    magenta/purple
    765  3bf4							;05	 64 97 4e		 6a cf 6f    green
    766  3bf4							;06	 40 32 85		 4f 44 d8    blue
    767  3bf4							;07	 bf cd 7a		 fb fb 8b    yellow
    768  3bf4							;08	 7b 5b 2f    90 5f 35	 d8 9c 5b    orange
    769  3bf4							;09	 4f 45 00    92 71 00	 7f 53 07    brown
    770  3bf4							;0a	 a3 72 65    bb 77 6d	 ef 83 9f    light-red
    771  3bf4							;0b	 50 50 50    55 55 55	 57 57 53    dark-gray
    772  3bf4							;0c	 78 78 78		 a3 a7 a7    gray
    773  3bf4							;0d	 a4 d7 d7		 b7 fb bf    light-cyan
    774  3bf4							;0e	 78 6a bd		 a3 9f ff    light-blue
    775  3bf4							;0f	 9f 9f 9f		 ef f9 e7    light-gray
    776  3bf4
    777  3bf4
    778  3bf4							; structure for the bounding steel wall:
    779  3bf4				   BoundingWall
    780  3bf4		       cf 00 02 63*	      .byte.b	.STRUCT_RECTANGLE|CHARACTER_STEEL, 0, 2, 99, 99	; bounding steel wall
    781  3bf9		       ff		      .byte.b	.STRUCT_DELIMITER
    782  3bfa
    783  3bfa
    784  3bfa
    785  3bfa
    786  3bfa
------- FILE BANK_GENERIC.asm
     11  3bfa
      0  3bfa					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_CAVE)"
      1  3bfa
      2  3bfa
      3  3bfa		       03 fa	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_CAVE) (1K) SIZE =  $3fa , FREE= $6
      4  3bfa					      ECHO	"GENERIC_BANK_1 (DECODE_CAVE)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  3bfa				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  3bfa				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  3bfa				  -	      ERR
      8  3bfa					      endif
     13  3bfa
     14  3bfa							;------------------------------------------------------------------------------
     15  3bfa							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     16  3bfa							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     17  3bfa							; bank finishes.  Just continue on from where it left off...
     18  3bfa							;------------------------------------------------------------------------------
     19  3bfa
      0  3bfa					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  3bfa		       00 07	   BANK_Cart_Init =	_CURRENT_BANK
      2  3bfa					      SUBROUTINE
      3  3bfa				   Cart_Init
     21  3bfa
     22  3bfa							; Note the variables from the title selection are incredibly transient an can be stomped
     23  3bfa							; at any time.  So they need to be used immediately.
     24  3bfa
     25  3bfa
     26  3bfa							; odd usage below is to prevent any possibility of variable stomping/assumptions
     27  3bfa
     28  3bfa		       a5 82		      lda	sCave	; cave # from title select
     29  3bfc		       48		      pha
     30  3bfd		       a5 84		      lda	sPlayers
     31  3bff		       a6 83		      ldx	sLevel	; level # from title select
     32  3c01		       a4 85		      ldy	sJoysticks
     33  3c03		       84 ac		      sty	jtoggle
     34  3c05		       86 b1		      stx	level
     35  3c07		       85 ab		      sta	MenCurrent	; = #players
     36  3c09		       68		      pla
     37  3c0a		       85 b0		      sta	cave	; make an immediate copy to safe variables!
     38  3c0c
     39  3c0c				  -	      IF	FINAL_VERSION
     40  3c0c				  -	      asl
     41  3c0c				  -	      asl
     42  3c0c				  -	      adc	cave	; *5 because it only cycles 0/1/2/3 equaing to caves 0/5/10/15
     43  3c0c				  -	      sta	cave
     44  3c0c					      ENDIF
     45  3c0c		       85 e5		      sta	startCave
     46  3c0e
     47  3c0e							; multiply with CAVE_DATA_SIZE (5):
     48  3c0e		       0a		      asl
     49  3c0f		       0a		      asl
     50  3c10		       65 b0		      adc	cave
     51  3c12		       85 b0		      sta	cave
     52  3c14
     53  3c14		       a9 01		      lda	#1
     54  3c16		       85 9e		      sta	whichPlayer	; will switch to 0 on 1st go
     55  3c18
     56  3c18		       a9 30		      lda	#NUM_LIVES<<4	; 3 lives
     57  3c1a		       a6 ab		      ldx	MenCurrent	; = sPlayers
     58  3c1c		       f0 02		      beq	opg
     59  3c1e		       a9 33		      lda	#NUM_LIVES<<4|NUM_LIVES
     60  3c20		       85 ab	   opg	      sta	MenCurrent	; P2P1 nybble each
     61  3c22
     62  3c22							;---------------------------------------------------------------------------
     63  3c22
     64  3c22		       a9 00		      lda	#0
     65  3c24		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     66  3c27		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     67  3c2a		       85 6b		      sta	HMCLR
     68  3c2c
     69  3c2c							; cleanup remains of title screen
     70  3c2c		       85 5b		      sta	GRP0
     71  3c2e		       85 5c		      sta	GRP1
     72  3c30		       85 5b		      sta	GRP0
     73  3c32
     74  3c32		       85 8e		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     75  3c34
     76  3c34							;    IFCONST DEBUG_CREATURE
     77  3c34							;		  sta worstTime
     78  3c34							;    ENDIF
     79  3c34
     80  3c34		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     81  3c36		       85 4a		      sta	CTRLPF
     82  3c38		       85 87		      sta	rnd	; anything non-0
     83  3c3a
     84  3c3a		       a9 ff		      lda	#$FF
     85  3c3c		       85 89		      sta	DrawStackPointer
     86  3c3e
     87  3c3e		       a9 07		      lda	#DIRECTION_BITS
     88  3c40		       85 a8		      sta	ManLastDirection
     89  3c42
     90  3c42		       a9 00		      lda	#0
     91  3c44							;		  sta ObjStackPtr		  ; object stack index of last entry
     92  3c44							;		  sta ObjStackPtr+1
     93  3c44							;		  sta BlankStackPtr		  ; blank stack index of last entry
     94  3c44							;		  sta ObjStackNum
     95  3c44							;		  sta ObjIterator
     96  3c44
     97  3c44		       85 d4		      sta	sortPtr
     98  3c46		       a9 ff		      lda	#<(-1)
     99  3c48		       85 d3		      sta	sortRequired
    100  3c4a
    101  3c4a							; read high score from SaveKey and store in highScoreSK,
    102  3c4a							; which is transferred to high score variable in RAM by GeneralScoringSetups
    103  3c4a		       4c 77 f7 	      jmp	ReadSaveKey
    104  3c4d
    105  3c4d							;LEVEL0CREATURE  .byte TYPE_MAN,	  0,	  3,	  5
    106  3c4d							;		  .byte -1
    107  3c4d
    108  3c4d							;------------------------------------------------------------------------------
    109  3c4d
      0  3c4d					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  3c4d		       00 07	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  3c4d					      SUBROUTINE
      3  3c4d				   SwapPlayersGeneric
    111  3c4d
    112  3c4d							; at the start of a cave (or player, doesn't matter) we grab the current state of the colour/B&W switch
    113  3c4d							; into the gameMode variable.
    114  3c4d
    115  3c4d		       a5 80		      lda	gameMode
    116  3c4f		       29 77		      and	#~(BW_SWITCH|GAMEMODE_PAUSED)
    117  3c51		       85 80		      sta	gameMode
    118  3c53		       ad 82 02 	      lda	SWCHB
    119  3c56		       29 08		      and	#BW_SWITCH
    120  3c58		       05 80		      ora	gameMode	; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    121  3c5a		       85 80		      sta	gameMode	; also, BIT7=0 -- system is NOT paused
    122  3c5c
    123  3c5c
    124  3c5c							; restart cave
    125  3c5c		       a5 c9		      lda	NextLevelTrigger
    126  3c5e		       29 bf		      and	#<(~BIT_NEXTLIFE)
    127  3c60		       85 c9		      sta	NextLevelTrigger
    128  3c62
    129  3c62							; swap player and lives, returns C-flag = 1 if player is dead
    130  3c62
    131  3c62		       a5 ab		      lda	MenCurrent
    132  3c64		       29 f0		      and	#$F0	; other player has lives left?
    133  3c66		       f0 12		      beq	.playerDead2	; NO, so we don't swap scores
    134  3c68
    135  3c68		       a5 9e		      lda	whichPlayer
    136  3c6a		       49 01		      eor	#1
    137  3c6c		       85 9e		      sta	whichPlayer
    138  3c6e
    139  3c6e							; switch nybbles over -- the low 4 bits holds current player's life count
    140  3c6e
    141  3c6e		       a5 ab		      lda	MenCurrent
    142  3c70		       a2 04		      ldx	#4
    143  3c72		       c9 80	   .swapNybble cmp	#$80
    144  3c74		       2a		      rol
    145  3c75		       ca		      dex
    146  3c76		       d0 fa		      bne	.swapNybble
    147  3c78		       85 ab		      sta	MenCurrent	; only 0 when BOTH players dead :))
    148  3c7a
    149  3c7a				   .playerDead2
    150  3c7a							; if new high score was set by SwapPlayers, update it:
    151  3c7a		       4c 9d f7 	      jmp	WriteSaveKey
    152  3c7d
    153  3c7d							;------------------------------------------------------------------------------
      0  3c7d					      DEFINE_SUBROUTINE	CheckDiamondFlash
      1  3c7d		       00 07	   BANK_CheckDiamondFlash =	_CURRENT_BANK
      2  3c7d					      SUBROUTINE
      3  3c7d				   CheckDiamondFlash
    155  3c7d
      0  3c7d					      START_SOUND	SOUND_DIAMOND_PICKUP	;15
      1  3c7d					      SUBROUTINE
      2  3c7d		       a5 db		      lda	newSounds
      3  3c7f					      IF	SOUND_DIAMOND_PICKUP < 16
      4  3c7f		       29 0f		      and	#SND_MASK_LO
      5  3c81		       c9 03		      cmp	#SOUND_MOVE_SOIL+1
      6  3c83		       b0 06		      bcs	.skipNew
      7  3c85				  -	      ELSE
      8  3c85				  -	      and	#SND_MASK_HI
      9  3c85				  -	      cmp	#(SOUND_MOVE_SOIL+1)<<4
     10  3c85				  -	      bcs	.skipNew
     11  3c85				  -
     12  3c85					      ENDIF
     13  3c85		       45 db		      eor	newSounds
     14  3c87		       09 04		      ora	#SOUND_DIAMOND_PICKUP
     15  3c89		       85 db		      sta	newSounds
     16  3c8b				   .skipNew
     17  3c8b					      SUBROUTINE
    157  3c8b
    158  3c8b							; determine additional points, used later!
    159  3c8b		       a5 b7		      lda	diamondsWorth	;3
    160  3c8d		       24 c8		      bit	scoringFlags	;3	   ; D7 = Extra diamonds
    161  3c8f		       10 02		      bpl	.noExtra	;2/3
    162  3c91		       a5 b8		      lda	diamondsExtraWorth	;3
    163  3c93				   .noExtra
    164  3c93		       a8		      tay
    165  3c94
    166  3c94		       18		      clc
    167  3c95		       f8		      sed
    168  3c96		       a9 99		      lda	#$99
    169  3c98		       24 c8		      bit	scoringFlags	; EXTRA_DIAMONDS?
    170  3c9a		       10 02		      bpl	.subtract	; NO, so branch
    171  3c9c		       a9 01		      lda	#$01
    172  3c9e				   .subtract
    173  3c9e		       65 b6		      adc	diamondsNeeded
    174  3ca0		       85 b6		      sta	diamondsNeeded
    175  3ca2		       d8		      cld
    176  3ca3		       aa		      tax		; ???	reported to SA ???  fix, Stella emulates wrong here!
    177  3ca4		       d0 1e		      bne	.noCrack
    178  3ca6		       24 c8		      bit	scoringFlags	; EXTRA_DIAMONDS?
    179  3ca8		       10 04		      bpl	.openDoor
    180  3caa		       a9 c1		      lda	#EXTRA_DIAMONDS|EXTRA_100_DIAMONDS|DISPLAY_SCORE	; must be >= 100 extra diamonds now!
    181  3cac		       d0 14		      bne	.setDiamondFlag	; unconditional
    182  3cae
    183  3cae							; required number of diamons collected:
    184  3cae				   .openDoor
      0  3cae					      START_SOUND	SOUND_CRACK	; start "crack" sound to indicate open door
      1  3cae					      SUBROUTINE
      2  3cae		       a5 db		      lda	newSounds
      3  3cb0				  -	      IF	SOUND_CRACK < 16
      4  3cb0				  -	      and	#SND_MASK_LO
      5  3cb0				  -	      cmp	#SOUND_MOVE_SOIL+1
      6  3cb0				  -	      bcs	.skipNew
      7  3cb0					      ELSE
      8  3cb0		       29 f0		      and	#SND_MASK_HI
      9  3cb2		       c9 30		      cmp	#(SOUND_MOVE_SOIL+1)<<4
     10  3cb4		       b0 06		      bcs	.skipNew
     11  3cb6
     12  3cb6					      ENDIF
     13  3cb6		       45 db		      eor	newSounds
     14  3cb8		       09 50		      ora	#SOUND_CRACK
     15  3cba		       85 db		      sta	newSounds
     16  3cbc				   .skipNew
     17  3cbc					      SUBROUTINE
    186  3cbc
    187  3cbc							;		  lda #WHITE
    188  3cbc							;		  sta BGColour			      ; "flash" to show door is open
    189  3cbc		       a9 06		      lda	#FLASH_TIME
    190  3cbe		       85 c5		      sta	ColourTimer
    191  3cc0		       a9 81		      lda	#EXTRA_DIAMONDS|DISPLAY_SCORE
    192  3cc2				   .setDiamondFlag
    193  3cc2		       85 c8		      sta	scoringFlags
    194  3cc4				   .noCrack
    195  3cc4		       98		      tya
    196  3cc5		       60		      rts
    197  3cc6
    198  3cc6							;------------------------------------------------------------------------------
    199  3cc6
      0  3cc6					      DEFINE_SUBROUTINE	CreateCreatures	; GENERIC_BANK_1
      1  3cc6		       00 07	   BANK_CreateCreatures =	_CURRENT_BANK
      2  3cc6					      SUBROUTINE
      3  3cc6				   CreateCreatures
    201  3cc6
    202  3cc6
    203  3cc6							; Calculate rightmost value for scrolling edge.  .
    204  3cc6
    205  3cc6		       85 c3		      sta	ROM_Bank
    206  3cc8
    207  3cc8		       38		      sec
    208  3cc9		       a5 98		      lda	BoardLimit_Width
    209  3ccb		       e9 09		      sbc	#SCREEN_WIDTH-1
    210  3ccd		       85 98		      sta	BoardEdge_Right	; absolute rightmost scroll value
    211  3ccf				  -	      IF	INITIAL_SCROLL = YES
    212  3ccf				  -	      sbc	#1
    213  3ccf				  -	      cmp	BoardScrollX
    214  3ccf				  -	      bcs	.Xok
    215  3ccf				  -	      sta	BoardScrollX
    216  3ccf				  -	      sec
    217  3ccf				  -.Xok
    218  3ccf					      ENDIF
    219  3ccf
    220  3ccf							;		  sec			     already set
    221  3ccf		       a5 99		      lda	BoardLimit_Height
    222  3cd1		       e9 07		      sbc	#SCREEN_LINES-1
    223  3cd3		       85 99		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    224  3cd5				  -	      IF	INITIAL_SCROLL = YES
    225  3cd5				  -	      sbc	#1
    226  3cd5				  -	      cmp	BoardScrollY
    227  3cd5				  -	      bcs	.Yok
    228  3cd5				  -	      sta	BoardScrollY
    229  3cd5				  -.Yok
    230  3cd5					      ENDIF
    231  3cd5
    232  3cd5							; kludge position scroll roughly at player
    233  3cd5
    234  3cd5							;TODO: "correct" BD scrolling.
    235  3cd5							; The game scrolls from the players last position (no difference between 1st and 2nd player)
    236  3cd5
    237  3cd5					      IF	INITIAL_SCROLL = NO
    238  3cd5							;		  sec			 already set
    239  3cd5		       a5 9f		      lda	ManX
    240  3cd7		       e9 05		      sbc	#5
    241  3cd9		       b0 02		      bcs	notL0
    242  3cdb		       a9 00		      lda	#0
    243  3cdd		       85 9b	   notL0      sta	BoardScrollX
    244  3cdf
    245  3cdf
    246  3cdf		       38		      sec
    247  3ce0		       a5 a0		      lda	ManY
    248  3ce2		       e9 05		      sbc	#5	; TJ: why 5???
    249  3ce4		       b0 02		      bcs	notU0
    250  3ce6		       a9 00		      lda	#0
    251  3ce8		       85 9a	   notU0      sta	BoardScrollY
    252  3cea					      ENDIF
    253  3cea
    254  3cea		       a9 00		      lda	#0
    255  3cec		       85 a3		      sta	ManMode
    256  3cee		       85 a4		      sta	ManDelayCount
    257  3cf0
    258  3cf0		       a9 2c		      lda	#AnimateBLANK-Manimate	;0 ;<AnimateBLANK ;STAND
    259  3cf2		       85 a5		      sta	ManAnimation
    260  3cf4							;lda #>AnimateBLANK ;
    261  3cf4							;sta ManAnimation+1
    262  3cf4
    263  3cf4		       a9 ff		      lda	#$FF
    264  3cf6		       85 ad		      sta	LastSpriteY
    265  3cf8
    266  3cf8		       a9 07		      lda	#DIRECTION_BITS
    267  3cfa		       85 a8		      sta	ManLastDirection
    268  3cfc
    269  3cfc		       24 cc		      bit	amoebaFlag	; AMOEBA_PRESENT?
    270  3cfe		       50 12		      bvc	.noAmoeba
    271  3d00
    272  3d00		       a6 d0		      ldx	amoebaMaxX
    273  3d02		       86 ca		      stx	amoebaX
    274  3d04		       a4 d1		      ldy	amoebaMaxY
    275  3d06		       84 cb		      sty	amoebaY
    276  3d08		       a9 01		      lda	#1
    277  3d0a		       85 d2		      sta	amoebaStepCount
    278  3d0c		       85 cd		      sta	amoebaCount	; doesn't matter to be 1 too big here initially
    279  3d0e							;		 lda #0
    280  3d0e							;sta amoebaFlag		     ; now initialised in DecodeCave
    281  3d0e							;		 sta amoebaCount
    282  3d0e		       a5 b5		      lda	magicAmoebaTime	; setup slow growth time
    283  3d10		       85 9d		      sta	MagicAmoebaFlag	;
    284  3d12				   .noAmoeba
    285  3d12
    286  3d12		       60		      rts
    287  3d13
    288  3d13							;-------------------------------------------------------------------------------------
    289  3d13
      0  3d13					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  3d13		       00 07	   BANK_LevelInit =	_CURRENT_BANK
      2  3d13					      SUBROUTINE
      3  3d13				   LevelInit
    291  3d13
    292  3d13		       a9 00		      lda	#0
    293  3d15		       85 8b		      sta	ObjStackPtr
    294  3d17		       85 8c		      sta	ObjStackPtr+1	; kill all creatures
    295  3d19		       85 8a		      sta	ObjStackNum
    296  3d1b		       85 dd		      sta	ObjIterator
    297  3d1d
    298  3d1d		       85 9c		      sta	scrollBits
    299  3d1f		       85 8e		      sta	ScreenDrawPhase
    300  3d21
    301  3d21		       85 af		      sta	BGColour
    302  3d23		       85 c5		      sta	ColourTimer
    303  3d25		       85 c6		      sta	extraLifeTimer	; Cosmic Ark stars off
    304  3d27
    305  3d27		       85 8d		      sta	BlankStackPtr
    306  3d29
    307  3d29		       85 d5		      sta	soundIdxLst
    308  3d2b		       85 d6		      sta	soundIdxLst+1
    309  3d2d		       85 db		      sta	newSounds
    310  3d2f
    311  3d2f		       85 59		      sta	AUDV0
    312  3d31		       85 5a		      sta	AUDV1	; turn off music while levels init
    313  3d33							;		  sta AUDC0
    314  3d33
    315  3d33		       85 a8		      sta	ManLastDirection
    316  3d35		       85 a9		      sta	ManPushCounter
    317  3d37
    318  3d37		       85 d4		      sta	sortPtr	; sort stopped
    319  3d39		       a9 ff		      lda	#<(-1)
    320  3d3b		       85 d3		      sta	sortRequired	; nothing needed
    321  3d3d		       85 89		      sta	DrawStackPointer
    322  3d3f
    323  3d3f
    324  3d3f		       a9 ff		      lda	#MAGIC_WALL_DORMANT
    325  3d41		       85 9d		      sta	MagicAmoebaFlag
    326  3d43
    327  3d43		       a9 02		      lda	#DISPLAY_LIVES
    328  3d45		       85 c8		      sta	scoringFlags
    329  3d47		       a9 96		      lda	#SCORING_TIMER_FIRST	; We want the first timer display to be long, to show level and lives
    330  3d49		       85 c7		      sta	scoringTimer
    331  3d4b		       60		      rts
    332  3d4c
    333  3d4c							;-------------------------------------------------------------------------------------
    334  3d4c
    335  3d4c
    336  3d4c							;---------------------------------------------------------------------------
    337  3d4c
      0  3d4c					      DEFINE_SUBROUTINE	Resync
      1  3d4c		       00 07	   BANK_Resync =	_CURRENT_BANK
      2  3d4c					      SUBROUTINE
      3  3d4c				   Resync
      0  3d4c					      RESYNC
      1  3d4c
      2  3d4c		       a9 02		      lda	#%10
      3  3d4e		       85 41		      sta	VBLANK
      4  3d50
      5  3d50		       a2 08		      ldx	#8
      6  3d52				   .loopResync
      0  3d52					      VERTICAL_SYNC
      1  3d52		       a9 0e		      lda	#%1110
      2  3d54		       85 42	   .VSLP1     sta	WSYNC
      3  3d56		       85 40		      sta	VSYNC
      4  3d58		       4a		      lsr
      5  3d59		       d0 f9		      bne	.VSLP1
      8  3d5b
      9  3d5b		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  3d5d		       a5 81		      lda	Platform
     11  3d5f		       49 02		      eor	#PAL_50
     12  3d61		       d0 02		      bne	.ntsc
     13  3d63		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  3d65				   .ntsc
     15  3d65				   .loopWait
     16  3d65		       85 42		      sta	WSYNC
     17  3d67		       85 42		      sta	WSYNC
     18  3d69		       88		      dey
     19  3d6a		       d0 f9		      bne	.loopWait
     20  3d6c		       ca		      dex
     21  3d6d		       d0 e3		      bne	.loopResync
    340  3d6f		       60	   Ret	      rts
    341  3d70
    342  3d70							;---------------------------------------------------------------------------
    343  3d70				   Manimate
    344  3d70				   AnimateSTAND
    345  3d70				   AnimateSTOPPED
    346  3d70		       7f		      .byte.b	127
    347  3d71		       79		      .byte.b	<PLAYER_STAND
    348  3d72		       0a		      .byte.b	10
    349  3d73		       8e		      .byte.b	< PLAYER_BLINK
    350  3d74		       7f		      .byte.b	127
    351  3d75		       79		      .byte.b	< PLAYER_STAND
    352  3d76							;.byte 0
    353  3d76							;.word AnimateTAP
    354  3d76
    355  3d76				   AnimateTAP
    356  3d76		       80 00		      .byte.b	128, %0	; reflect off, always tap with left foot
    357  3d78		       08		      .byte.b	8
    358  3d79		       a3		      .byte.b	< PLAYER_TAP0
    359  3d7a		       08		      .byte.b	8
    360  3d7b		       b8		      .byte.b	< PLAYER_TAP1
    361  3d7c		       08		      .byte.b	8
    362  3d7d		       a3		      .byte.b	< PLAYER_TAP0
    363  3d7e		       08		      .byte.b	8
    364  3d7f		       b8		      .byte.b	< PLAYER_TAP1
    365  3d80		       08		      .byte.b	8
    366  3d81		       a3		      .byte.b	< PLAYER_TAP0
    367  3d82		       08		      .byte.b	8
    368  3d83		       b8		      .byte.b	< PLAYER_TAP1
    369  3d84		       00		      .byte.b	0
    370  3d85		       00		      .byte.b	AnimateSTAND-Manimate	;word AnimateSTAND
    371  3d86
    372  3d86				   AnimateRIGHT
    373  3d86		       80 00		      .byte.b	128, %0	; reflect off
    374  3d88		       05		      .byte.b	5
    375  3d89		       4f		      .byte.b	< PLAYER_RIGHT0
    376  3d8a		       05		      .byte.b	5
    377  3d8b		       64		      .byte.b	< PLAYER_RIGHT1
    378  3d8c		       00		      .byte.b	0
    379  3d8d		       16		      .byte.b	AnimateRIGHT-Manimate	;word AnimateRIGHT
    380  3d8e
    381  3d8e				   AnimateLEFT
    382  3d8e		       80 08		      .byte.b	128, %1000	; reflect ON
    383  3d90		       05		      .byte.b	5
    384  3d91		       4f		      .byte.b	< PLAYER_RIGHT0
    385  3d92		       05		      .byte.b	5
    386  3d93		       64		      .byte.b	< PLAYER_RIGHT1
    387  3d94		       00		      .byte.b	0
    388  3d95		       1e		      .byte.b	AnimateLEFT-Manimate	;word AnimateLEFT
    389  3d96
    390  3d96							;AnimateUP
    391  3d96							;    .byte 128, %0		   ; reflect off
    392  3d96							;    .byte 5
    393  3d96							;    .byte < PLAYER_TAP
    394  3d96							;    .byte 128, %1000
    395  3d96							;    .byte 5
    396  3d96							;    .byte < PLAYER_TAP
    397  3d96							;    .byte 0
    398  3d96							;    .word AnimateUP
    399  3d96
    400  3d96				   AnimateUP		; keep last reflection, like in original game
    401  3d96		       05		      .byte.b	5
    402  3d97		       4f		      .byte.b	< PLAYER_RIGHT0
    403  3d98		       05		      .byte.b	5
    404  3d99		       64		      .byte.b	< PLAYER_RIGHT1
    405  3d9a		       00		      .byte.b	0
    406  3d9b		       26		      .byte.b	AnimateUP-Manimate	;word AnimateUP
    407  3d9c
    408  3d9c				   AnimateBLANK
    409  3d9c		       7f		      .byte.b	127
    410  3d9d		       3a		      .byte.b	< PLAYER_BLANK
    411  3d9e		       00		      .byte.b	0
    412  3d9f		       2c		      .byte.b	AnimateBLANK-Manimate	;word AnimateBLANK
    413  3da0
    414  3da0				   AnimateEND
      0  3da0					      CHECKPAGE	Manimate
      8  3da0					      LIST	ON
    416  3da0							;---------------------------------------------------------------------------
    417  3da0
    418  3da0
      0  3da0					      DEFINE_SUBROUTINE	TrackPlayer	; =145; in GENERIC_BANK_1
      1  3da0		       00 07	   BANK_TrackPlayer =	_CURRENT_BANK
      2  3da0					      SUBROUTINE
      3  3da0				   TrackPlayer
    420  3da0
    421  3da0		       a5 aa		      lda	LookingAround	; 3
    422  3da2		       30 cb		      bmi	Ret	; 2/3=5/6   don't track when looking around
    423  3da4
    424  3da4							; Contribution by Thomas Jentzsch
    425  3da4
    426  3da4							; scrolling constants:
    427  3da4		       00 03	   .SCRL_START_LEFT =	3	; 3
    428  3da4		       00 05	   .SCRL_STOP_LEFT =	SCREEN_WIDTH-5	; 5 scrolls 5-3+1 = 3 pixel
    429  3da4		       00 07	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT	; 7
    430  3da4		       00 05	   .SCRL_STOP_RIGHT =	SCREEN_WIDTH-.SCRL_STOP_LEFT	; 5
    431  3da4		       00 11	   .SCRL_LEFT_BIT =	%00010001
    432  3da4		       00 22	   .SCRL_RIGHT_BIT =	%00100010
    433  3da4		       00 33	   .SCRL_X_BITS =	.SCRL_LEFT_BIT|.SCRL_RIGHT_BIT
    434  3da4
    435  3da4		       00 02	   .SCRL_START_UP =	2	; 2
    436  3da4		       00 03	   .SCRL_STOP_UP =	SCREEN_LINES-5	; 3 scrolls 3-2+1 = 2 pixel
    437  3da4		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP	; 6
    438  3da4		       00 05	   .SCRL_STOP_DOWN =	SCREEN_LINES-.SCRL_STOP_UP	; 5
    439  3da4		       00 44	   .SCRL_UP_BIT =	%01000100
    440  3da4		       00 88	   .SCRL_DOWN_BIT =	%10001000
    441  3da4		       00 cc	   .SCRL_Y_BITS =	.SCRL_UP_BIT|.SCRL_DOWN_BIT
    442  3da4
    443  3da4							; *** horizontal scrolling (unoptimized version): ***
    444  3da4
    445  3da4							; check for enabling horizontal scrolling:
    446  3da4		       a5 9f		      lda	ManX	; 3
    447  3da6		       38		      sec		; 2
    448  3da7		       e5 9b		      sbc	BoardScrollX	; 3
    449  3da9		       a8		      tay		; 2	     for later use
    450  3daa		       a9 11		      lda	#.SCRL_LEFT_BIT	; 2
    451  3dac		       c0 03		      cpy	#.SCRL_START_LEFT	; 2	     <3?
    452  3dae		       30 06		      bmi	.startXScroll	; 2/3	     yes, scroll left
    453  3db0		       c0 07		      cpy	#.SCRL_START_RIGHT	; 2	     <8?
    454  3db2		       30 08		      bmi	.skipStartXScroll	; 2/3	     no
    455  3db4		       a9 22		      lda	#.SCRL_RIGHT_BIT	; 2 = 22    yes, scroll right
    456  3db6				   .startXScroll
    457  3db6		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    458  3db8		       05 9c		      ora	scrollBits	; 3
    459  3dba		       85 9c		      sta	scrollBits	; 3 =	8
    460  3dbc				   .skipStartXScroll
    461  3dbc
    462  3dbc							; do horizontal scrolling:
    463  3dbc		       a5 9c		      lda	scrollBits	; 3
    464  3dbe		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    465  3dc0		       f0 23		      beq	.skipXScroll	; 2/3
    466  3dc2		       29 22		      and	#.SCRL_RIGHT_BIT	; 2
    467  3dc4		       d0 0c		      bne	.xScrollRight	; 2/3=11/12
    468  3dc6
    469  3dc6							; scroll left:
    470  3dc6		       a5 9b		      lda	BoardScrollX	; 3	     already at left edge?
    471  3dc8		       f0 15		      beq	.stopXScroll	; 2
    472  3dca		       c6 9b		      dec	BoardScrollX	; 5
    473  3dcc		       c0 04		      cpy	#.SCRL_STOP_LEFT-1	; 2
    474  3dce		       10 0f		      bpl	.stopXScroll	; 2/3=15
    475  3dd0		       30 13		      bmi	.skipXScroll	; 3
    476  3dd2							;---------------------------------------
    477  3dd2				   .xScrollRight
    478  3dd2		       a6 9b		      ldx	BoardScrollX	; 3
    479  3dd4		       e8		      inx		; 2
    480  3dd5		       e4 98		      cpx	BoardEdge_Right	; 3	     already at right edge?
    481  3dd7		       10 06		      bpl	.stopXScroll	; 2/3
    482  3dd9		       86 9b		      stx	BoardScrollX	; 3
    483  3ddb		       c0 06		      cpy	#.SCRL_STOP_RIGHT+1	; 2
    484  3ddd		       10 06		      bpl	.skipXScroll	; 2/3=17/18
    485  3ddf				   .stopXScroll
    486  3ddf		       a5 9c		      lda	scrollBits	; 3
    487  3de1		       29 fc		      and	#(~(.SCRL_X_BITS >> 4))	; 2
    488  3de3		       85 9c		      sta	scrollBits	; 3 =	8
    489  3de5				   .skipXScroll
    490  3de5							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    491  3de5
    492  3de5							; *** vertical scrolling (unoptimized version): ***
    493  3de5
    494  3de5							; check for enabling vertical scrolling:
    495  3de5		       a5 a0		      lda	ManY	; 3
    496  3de7		       38		      sec		; 2
    497  3de8		       e5 9a		      sbc	BoardScrollY	; 3
    498  3dea		       a8		      tay		; 2	     for later use
    499  3deb		       a9 44		      lda	#.SCRL_UP_BIT	; 2
    500  3ded		       c0 02		      cpy	#.SCRL_START_UP	; 2	     <2?
    501  3def		       30 06		      bmi	.startYScroll	; 2/3	     yes, scroll up
    502  3df1		       c0 06		      cpy	#.SCRL_START_DOWN	; 2	     <6?
    503  3df3		       30 08		      bmi	.skipStartYScroll	; 2/3
    504  3df5		       a9 88		      lda	#.SCRL_DOWN_BIT	; 2 = 22    yes, scroll down
    505  3df7				   .startYScroll
    506  3df7		       29 0c		      and	#.SCRL_Y_BITS >> 4	; 2
    507  3df9		       05 9c		      ora	scrollBits	; 3
    508  3dfb		       85 9c		      sta	scrollBits	; 3 =	8
    509  3dfd				   .skipStartYScroll
    510  3dfd
    511  3dfd							; do vertical scrolling:
    512  3dfd		       a5 9c		      lda	scrollBits	; 3
    513  3dff		       29 cc		      and	#.SCRL_Y_BITS	; 2
    514  3e01		       f0 23		      beq	.skipYScroll	; 2/3
    515  3e03		       29 88		      and	#.SCRL_DOWN_BIT	; 2
    516  3e05		       d0 0c		      bne	.yScrollDown	; 2/3=11/12
    517  3e07
    518  3e07							; scroll up
    519  3e07		       a5 9a		      lda	BoardScrollY	; 3
    520  3e09		       f0 15		      beq	.stopYScroll	; 2
    521  3e0b		       c6 9a		      dec	BoardScrollY	; 5
    522  3e0d		       c0 02		      cpy	#.SCRL_STOP_UP-1	; 2
    523  3e0f		       10 0f		      bpl	.stopYScroll	; 2/3=15
    524  3e11		       30 13		      bmi	.skipYScroll	; 3
    525  3e13							;---------------------------------------
    526  3e13				   .yScrollDown
    527  3e13		       a6 9a		      ldx	BoardScrollY	; 3
    528  3e15		       e8		      inx		; 2
    529  3e16		       e4 99		      cpx	BoardEdge_Bottom	;     ; 3
    530  3e18		       10 06		      bpl	.stopYScroll	; 2/3
    531  3e1a		       86 9a		      stx	BoardScrollY	; 3
    532  3e1c		       c0 06		      cpy	#.SCRL_STOP_DOWN+1	; 2
    533  3e1e		       10 06		      bpl	.skipYScroll	; 2/3=17/18
    534  3e20				   .stopYScroll
    535  3e20		       a5 9c		      lda	scrollBits	; 3
    536  3e22		       29 f3		      and	#(~(.SCRL_Y_BITS >> 4))	; 2
    537  3e24		       85 9c		      sta	scrollBits	; 3 =	8
    538  3e26				   .skipYScroll
    539  3e26							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    540  3e26
    541  3e26		       60	   EarlyAbortx rts		; 6 =	6
    542  3e27							; total: 5+67*2+6 = 145
    543  3e27
    544  3e27							;------------------------------------------------------------------------------
    545  3e27
    546  3e27
    547  3e27
    548  3e27							; worst case time from positive last check to rts: 123
    549  3e27							; cycles until 0-check: 15
    550  3e27							; minimum cycles available after last positive check until timer turns 0: (MINIMUM_SORT_TIME-1)*64+1
    551  3e27							; MINIMUM_SORT_TIME = 3 = 129
    552  3e27							; MINIMUM_SORT_TIME = 4 = 193 <- ok
    553  3e27
    554  3e27							;------------------------------------------------------------------------------
    555  3e27
    556  3e27							;    DEFINE_SUBROUTINE PrepareTimeVector ; = 27
    557  3e27
    558  3e27							;		  ldx ScreenDrawPhase		  ; 3		; current phase of drawing
    559  3e27							;		  lda TS_PhaseVectorLO,x	  ; 4
    560  3e27							;		  sta TS_Vector 		  ; 3
    561  3e27							;		  lda TS_PhaseVectorHI,x	  ; 4
    562  3e27							;		  sta TS_Vector+1		  ; 3
    563  3e27
    564  3e27							;		  lda TS_PhaseBank,x		  ; 4
    565  3e27							;sta ROM_Bank			  ; 4	     GUESS!  SEEMS TO RUN OK WITHOUT THIS.
    566  3e27							;		  rts				  ; 6
    567  3e27
    568  3e27							;------------------------------------------------------------------------------
    569  3e27
    570  3e27							; This is a GOOD home for these tables.  Move AD's tables here and fix code appropriately
    571  3e27
      0  3e27					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  3e27		       00 07	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  3e27					      SUBROUTINE
      3  3e27				   TS_PhaseVectorLO
    573  3e27
    574  3e27							; Gives LO byte of addresses of subroutines for timeslice processing
    575  3e27
    576  3e27		       27		      .byte.b	<ProcessObjStack
    577  3e28		       6d		      .byte.b	<ProcessBlankStack
    578  3e29		       08		      .byte.b	<DrawFullScreen
    579  3e2a		       a2		      .byte.b	<BuildDrawStack
    580  3e2b		       a9		      .byte.b	<DrawAIntoStack
    581  3e2c		       84		      .byte.b	<SwitchObjects
    582  3e2d
    583  3e2d				   TS_PhaseVectorHI
    584  3e2d
    585  3e2d							; Gives HI byte of addresses of subroutines for timeslice processing
    586  3e2d
    587  3e2d		       f9		      .byte.b	>ProcessObjStack
    588  3e2e		       f9		      .byte.b	>ProcessBlankStack
    589  3e2f		       f6		      .byte.b	>DrawFullScreen
    590  3e30		       fc		      .byte.b	>BuildDrawStack
    591  3e31		       fc		      .byte.b	>DrawAIntoStack
    592  3e32		       f9		      .byte.b	>SwitchObjects
    593  3e33
    594  3e33				   TS_PhaseBank
    595  3e33
    596  3e33							; Gives bank of subroutines for timeslice processing
    597  3e33
    598  3e33		       0f		      .byte.b	BANK_ProcessObjStack
    599  3e34		       0f		      .byte.b	BANK_ProcessBlankStack
    600  3e35		       08		      .byte.b	BANK_DrawFullScreen
    601  3e36		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    602  3e37		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    603  3e38		       0f		      .byte.b	BANK_SwitchObjects
    604  3e39
    605  3e39							;------------------------------------------------------------------------------
    606  3e39		       02 02	   lookColour2 .byte.b	$02, $02
    607  3e3b		       04 04		      .byte.b	$04, $04
    608  3e3d
    609  3e3d				   OverscanTime
    610  3e3d		       33 33		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    611  3e3f		       46 33		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    612  3e41
    613  3e41
    614  3e41
    615  3e41
      0  3e41					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  3e41		       00 07	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  3e41					      SUBROUTINE
      3  3e41				   PostScreenCleanup
    617  3e41
    618  3e41		       c8		      iny		; --> 0
    619  3e42
    620  3e42		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    621  3e44							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    622  3e44
    623  3e44		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    624  3e46							; TJ: no idea why, but you had removed it in revision 758 ;)
    625  3e46							; completely accidental -- one of our cats may have deleted it.
    626  3e46		       84 4e		      sty	PF1
    627  3e48		       84 4f		      sty	PF2
    628  3e4a		       84 5d		      sty	ENAM0
    629  3e4c		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    630  3e4e		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    631  3e50
    632  3e50
    633  3e50
    634  3e50							; D1 VBLANK turns off beam
    635  3e50							; It needs to be turned on 37 scanlines later
    636  3e50
    637  3e50		       a9 42		      lda	#%01000010	; bit6 is not required
    638  3e52		       85 41		      sta	VBLANK	; end of screen - enter blanking
    639  3e54
    640  3e54							;------------------------------------------------------------------------------
    641  3e54							; This is where the PAL system has a bit of extra time on a per-frame basis.
    642  3e54
    643  3e54		       a6 81		      ldx	Platform
    644  3e56		       bd 3d f6 	      lda	OverscanTime,x
    645  3e59		       8d 96 02 	      sta	TIM64T
    646  3e5c
    647  3e5c							; Background colour priorities. Increasing order of priority...
    648  3e5c							;	black -- nothing happening
    649  3e5c							;	looking around			     lookingAround<0		     BLUE
    650  3e5c							;	when paused			     gameMode... BIT7		     RED
    651  3e5c							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    652  3e5c
    653  3e5c
    654  3e5c		       a5 aa		      lda	LookingAround
    655  3e5e		       10 02		      bpl	nolooker	; if not looking around, that will do nicely
    656  3e60		       a0 d0		      ldy	#$d0
    657  3e62							;		  ldy lookColour2,x		  ; otherwise, use the lookaround colour as the base
    658  3e62		       84 af	   nolooker   sty	BGColour	; 'BASE' colour pause reverts TO when unpaused
    659  3e64
    660  3e64		       a5 b4		      lda	ThrottleSpeed
    661  3e66		       18		      clc
    662  3e67		       65 b3		      adc	Throttle
    663  3e69		       b0 02		      bcs	noVerflo
    664  3e6b		       85 b3		      sta	Throttle
    665  3e6d				   noVerflo
    666  3e6d
    667  3e6d
    668  3e6d							;----------------------------------------------------------------------------------------------
    669  3e6d							; handle pause button for 2600 and 7800
    670  3e6d
    671  3e6d							; Timings:  NOT including palette setting or platform detect
    672  3e6d							; 2600:     no button press:	 11 cycles
    673  3e6d							;	     with button press:  21 cycles
    674  3e6d							; 7800      no button press:	 16 cycles
    675  3e6d							;	     with button press:  21 cycles
    676  3e6d
    677  3e6d
    678  3e6d
    679  3e6d		       00 08	   BW_SWITCH  =	$08	; NOTE: Shares bit position with SWCHB COLOUR/B&W SWITCH
    680  3e6d
    681  3e6d		       24 80		      bit	gameMode
    682  3e6f		       50 0b		      bvc	.pause7800	; 7800 platform
    683  3e71
    684  3e71							; 2600 pause logic...
    685  3e71
    686  3e71		       ad 82 02 	      lda	SWCHB
    687  3e74		       45 80		      eor	gameMode
    688  3e76		       29 08		      and	#BW_SWITCH
    689  3e78		       f0 17		      beq	.setPauseCol	; no different to original state = no pause change
    690  3e7a		       d0 0f		      bne	.buttonDown	; unconditional
    691  3e7c
    692  3e7c							; 7800 pause logic...
    693  3e7c
    694  3e7c							; When the button is pressed, we check if it's the FIRST time it's pressed.
    695  3e7c							; This FIRST time is indicated by the PFLAG7800 being clear.  If it's the first time, we toggle the pause
    696  3e7c							; flag (BIT6) AND we toggle the PFLAG7800 so continued button-down does nothing.  When the button is
    697  3e7c							; released, then we again toggle the PFLAG7800, allowing a FIRST time check once again, when the button
    698  3e7c							; is next pressed.
    699  3e7c
    700  3e7c		       a9 08	   .pause7800 lda	#BW_SWITCH
    701  3e7e		       2c 82 02 	      bit	SWCHB
    702  3e81		       f0 04		      beq	.pausePress
    703  3e83		       05 80		      ora	gameMode	; not pressed, so enable first time press
    704  3e85		       d0 08		      bne	.fixPause	; unconditional
    705  3e87
    706  3e87		       24 80	   .pausePress bit	gameMode
    707  3e89		       f0 06		      beq	.setPauseCol	; NOT the first time in pause - so do nothing new
    708  3e8b
    709  3e8b							; Button is down, and we have detected it as a FIRST-TIME button press.
    710  3e8b
    711  3e8b		       45 80	   .buttonDown eor	gameMode	; toggle first time flag(7800) or current switch state(2600)
    712  3e8d		       49 80		      eor	#GAMEMODE_PAUSED	; toggle pause flag
    713  3e8f		       85 80	   .fixPause  sta	gameMode
    714  3e91
    715  3e91		       a5 80	   .setPauseCol lda	gameMode	; are we paused?
    716  3e93		       10 07		      bpl	.exitPause	; only show pause colour when actually paused
    717  3e95
    718  3e95		       a6 81		      ldx	Platform
    719  3e97		       bd 08 f7 	      lda	pscol,x
    720  3e9a		       85 af		      sta	BGColour	; set main screen background colour.  RED is paused.
    721  3e9c
    722  3e9c				   .exitPause
    723  3e9c
    724  3e9c							;----------------------------------------------------------------------------------------------
    725  3e9c
    726  3e9c							; has to be done AFTER screen display, because it disables the effect!
    727  3e9c		       a5 87		      lda	rnd	; 3	 randomly reposition the Cosmic Ark missile
    728  3e9e		       85 62		      sta	HMM0	; 3	 this assumes that HMOVE is called at least once/frame
    729  3ea0
    730  3ea0							; "Flash" has highest BG colour priority
    731  3ea0
    732  3ea0		       a6 c5		      ldx	ColourTimer
    733  3ea2		       f0 06		      beq	noFlashBG
    734  3ea4		       c6 c5		      dec	ColourTimer
    735  3ea6		       a9 0e		      lda	#WHITE
    736  3ea8		       85 af		      sta	BGColour
    737  3eaa				   noFlashBG
    738  3eaa
    739  3eaa		       a5 c6		      lda	extraLifeTimer
    740  3eac		       f0 02		      beq	alreadyBlack2
    741  3eae		       c6 c6		      dec	extraLifeTimer
    742  3eb0				   alreadyBlack2
    743  3eb0
    744  3eb0							; Handle the player joystick reading. We do it *every frame* so that we can incorporate a two-frame
    745  3eb0							; buffer.  This is designed to give a little better responsiveness to the 'quick tap' movement.
    746  3eb0
    747  3eb0		       a5 95		      lda	BufferedJoystick	; previous frame
    748  3eb2		       85 96		      sta	BufferedJoystick+1	; -> buffered
    749  3eb4
    750  3eb4							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    751  3eb4							; P2 is shifted UP, so we don't need to worry in usage elsewhere (it's same format as a P1 joystick)
    752  3eb4
    753  3eb4		       a5 9e		      lda	whichPlayer	; 3
    754  3eb6		       25 ac		      and	jtoggle	; 3
    755  3eb8		       aa		      tax		; 2
    756  3eb9
    757  3eb9		       b5 4c		      lda	INPT4,x	; 4
    758  3ebb		       85 97		      sta	BufferedButton	; 3 = 15
    759  3ebd
    760  3ebd		       ad 80 02 	      lda	SWCHA	; 4
    761  3ec0
    762  3ec0		       ca		      dex		; 2
    763  3ec1		       30 04		      bmi	notP2	; 2/3= 8/9
    764  3ec3
    765  3ec3		       0a		      asl		; 2
    766  3ec4		       0a		      asl		; 2
    767  3ec5		       0a		      asl		; 2
    768  3ec6		       0a		      asl		; 2 =	8
    769  3ec7		       85 95	   notP2      sta	BufferedJoystick	; 3
    770  3ec9
    771  3ec9
    772  3ec9							; "Scoring timer" reset stomp comment
    773  3ec9
    774  3ec9		       a5 c7		      lda	scoringTimer
    775  3ecb		       f0 0a		      beq	timer0now
    776  3ecd		       c6 c7		      dec	scoringTimer
    777  3ecf		       d0 06		      bne	timer0now
    778  3ed1		       a5 c8		      lda	scoringFlags
    779  3ed3		       29 fc		      and	#<(~DISPLAY_FLAGS)	;	 switches to time display
    780  3ed5		       85 c8		      sta	scoringFlags
    781  3ed7				   timer0now
    782  3ed7
    783  3ed7							; fall through
    784  3ed7
    785  3ed7							;-------------------------------------------------------------------------------------
    786  3ed7							; Player animation happens *every* frame so that we get good animation speeds.  Note that
    787  3ed7							; the player animation consists of running a small animation 'program', and then actually drawing
    788  3ed7							; the player.	The draw is the neat bit, because all it does is update some self-modifying pointers
    789  3ed7							; inside the actual draw kernel in the appropriate bank.
    790  3ed7
    791  3ed7
      0  3ed7					      DEFINE_SUBROUTINE	AnimatePlayers	; in GENERIC_BANK_1
      1  3ed7		       00 07	   BANK_AnimatePlayers =	_CURRENT_BANK
      2  3ed7					      SUBROUTINE
      3  3ed7				   AnimatePlayers
    793  3ed7
    794  3ed7							; Optimised 7/1/2012 -- single page tables
    795  3ed7
    796  3ed7							; This interesting code performs the animations for the player(s) and sets the
    797  3ed7							; pointers INSIDE the row bank for the draw code to point to the correct player
    798  3ed7							; shape.  Kind of neat, as it doesn't require any shape copying (=speed!)
    799  3ed7
    800  3ed7
    801  3ed7							; Cycle the player through his animation list.  The animation of a player is a direct
    802  3ed7							; pointer to the actual shape used to display the player.  This shape is in turn
    803  3ed7							; written to the current bank's self-modifying locations for the draw.  Since
    804  3ed7							; we are effectively drawing from this current bank, the same code can be used
    805  3ed7							; to 'undraw' the player as required.
    806  3ed7
    807  3ed7
    808  3ed7							; x = player index
    809  3ed7							; sets ManAnimation = FRAME to display for player
    810  3ed7							; ManAnimation = index of player program into Manimate list
    811  3ed7
    812  3ed7		       24 80		      bit	gameMode
    813  3ed9		       30 2c		      bmi	AnimationOK	; don't animate during pause
    814  3edb
    815  3edb		       c6 a4		      dec	ManDelayCount
    816  3edd		       10 28		      bpl	AnimationOK
    817  3edf
    818  3edf		       a4 a5	   ReloadAnimation ldy	ManAnimation
    819  3ee1		       b9 70 f5    ContinueAnim lda	Manimate,y	; delay count
    820  3ee4		       d0 07		      bne	NewFrameOK
    821  3ee6		       b9 71 f5 	      lda	Manimate+1,y
    822  3ee9		       a8		      tay
    823  3eea		       4c e1 f6 	      jmp	ContinueAnim
    824  3eed
    825  3eed		       10 0d	   NewFrameOK bpl	doDelay
    826  3eef
    827  3eef		       c8		      iny		; handle a REFLECT
    828  3ef0		       a5 a8		      lda	ManLastDirection
    829  3ef2		       29 f7		      and	#%11110111
    830  3ef4		       19 70 f5 	      ora	Manimate,y
    831  3ef7		       85 a8		      sta	ManLastDirection
    832  3ef9
    833  3ef9		       c8		      iny
    834  3efa		       d0 e5		      bne	ContinueAnim
    835  3efc
    836  3efc		       85 a4	   doDelay    sta	ManDelayCount
    837  3efe
    838  3efe		       c8		      iny
    839  3eff		       b9 70 f5 	      lda	Manimate,y
    840  3f02		       85 a7		      sta	ManAnimationFrameLO
    841  3f04
    842  3f04		       c8		      iny
    843  3f05		       84 a5		      sty	ManAnimation
    844  3f07
    845  3f07		       60	   AnimationOK rts
    846  3f08
    847  3f08
    848  3f08
    849  3f08		       40 40	   pscol      .byte.b	$40, $40
    850  3f0a		       60 60		      .byte.b	$60, $60
    851  3f0c
    852  3f0c							;------------------------------------------------------------------------------
    853  3f0c
------- FILE i2c_v2.2.inc LEVEL 3 PASS 3
      0  3f0c					      include	"i2c_v2.2.inc"
      1  3f0c							;
      2  3f0c							; i2c_v2.2.inc
      3  3f0c							;
      4  3f0c							;
      5  3f0c							; AtariVox EEPROM Driver
      6  3f0c							;
      7  3f0c							; By Alex Herbert, 2004
      8  3f0c							;
      9  3f0c							; Optimisations by Thomas Jentzsch, 2006/2008
     10  3f0c							;
     11  3f0c
     12  3f0c
     13  3f0c							; I/O Constants
     14  3f0c
     15  3f0c		       00 04	   I2C_SDA_MASK equ	$04
     16  3f0c		       00 08	   I2C_SCL_MASK equ	$08
     17  3f0c
     18  3f0c
     19  3f0c							; Signalling Macros
     20  3f0c
     21  3f0c							;  MAC     I2C_SCL_0
     22  3f0c							;    lda     #$00
     23  3f0c							;    sta     SWCHA
     24  3f0c							;  ENDM
     25  3f0c
     26  3f0c							;  MAC     I2C_SCL_1
     27  3f0c							;    lda     #I2C_SCL_MASK
     28  3f0c							;    sta     SWCHA
     29  3f0c							;  ENDM
     30  3f0c
     31  3f0c							;  MAC     I2C_SDA_IN
     32  3f0c							;    lda     #I2C_SCL_MASK
     33  3f0c							;    sta     SWACNT
     34  3f0c							;  ENDM
     35  3f0c
     36  3f0c							;  MAC     I2C_SDA_OUT
     37  3f0c							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  3f0c							;    sta     SWACNT
     39  3f0c							;  ENDM
     40  3f0c
     41  3f0c
     42  3f0c					      MAC	i2c_start
     43  3f0c							; I2C_SCL_1
     44  3f0c					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  3f0c					      sta	SWCHA	; 4
     46  3f0c							; I2C_SDA_OUT
     47  3f0c					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  3f0c					      sta	SWACNT	; 4
     49  3f0c							; total: 12 cycles
     50  3f0c					      ENDM
     51  3f0c
     52  3f0c
     53  3f0c					      MAC	i2c_txbit
     54  3f0c							; I2C_SCL_0
     55  3f0c					      lda	#%0011	; 2
     56  3f0c					      sta	SWCHA	; 4
     57  3f0c							; set bit
     58  3f0c					      adc	#%1000	; 2
     59  3f0c					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  3f0c							; I2C_SCL_1
     61  3f0c					      lda	#I2C_SCL_MASK	; 2
     62  3f0c					      sta	SWCHA	; 4
     63  3f0c							; total: 18 cycles
     64  3f0c					      ENDM
     65  3f0c
     66  3f0c
     67  3f0c					      MAC	i2c_txnack
     68  3f0c							; I2C_SCL_0
     69  3f0c					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  3f0c					      sta	SWCHA	; 4
     71  3f0c							; I2C_SDA_IN
     72  3f0c					      lsr		; 2	     I2C_SCL_MASK
     73  3f0c					      sta	SWACNT	; 4
     74  3f0c							; I2C_SCL_1
     75  3f0c					      nop		; 2	     required for timing!
     76  3f0c					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  3f0c							; total: 18 cycles
     78  3f0c					      ENDM
     79  3f0c
     80  3f0c
     81  3f0c							; Subroutine Macros
     82  3f0c
     83  3f0c					      MAC	i2c_subs
     84  3f0c
     85  3f0c				   i2c_startread
     86  3f0c							; use V to flag if previous byte needs ACK
     87  3f0c					      ldy	#%10100001	; 2	     eeprom read command
     88  3f0c					      .byte	$2c	; 2
     89  3f0c				   i2c_startwrite
     90  3f0c					      ldy	#%10100000	; 2	     eeprom write command
     91  3f0c					      I2C_START		;12	     start signal (clears V flag)
     92  3f0c					      tya		; 2 = 16
     93  3f0c				   i2c_txbyte
     94  3f0c					      eor	#$ff	; 2	     invert data byte
     95  3f0c					      sec		; 2
     96  3f0c					      rol		; 2 =	6    shift loop bit into a
     97  3f0c				   i2c_txbyteloop
     98  3f0c					      tay		; 2
     99  3f0c					      I2C_TXBIT		;18	     transmit
    100  3f0c					      tya		; 2
    101  3f0c					      asl		; 2	     shift next bit into C
    102  3f0c					      bne	i2c_txbyteloop	; 2= 26/27
    103  3f0c
    104  3f0c							; receive acknowledge bit
    105  3f0c
    106  3f0c					      beq	i2c_rxbit	;43 = 43
    107  3f0c							; i2c_txbyte: 264 cycles
    108  3f0c							;-------------------------------------------------------------------------------
    109  3f0c
    110  3f0c				   i2c_rxbyte
    111  3f0c					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  3f0c					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  3f0c
    114  3f0c				   i2c_rxskipack
    115  3f0c					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  3f0c
    117  3f0c					      lda	#1	; 2
    118  3f0c				   i2c_rxbyteloop
    119  3f0c					      tay		; 2 =	2
    120  3f0c				   i2c_rxbit		;	     receive bit in C
    121  3f0c					      I2C_TXNACK		;18 = 18
    122  3f0c
    123  3f0c					      lda	SWCHA	; 4
    124  3f0c					      lsr		; 2
    125  3f0c					      lsr		; 2
    126  3f0c					      lsr		; 2 = 10    C = SDA
    127  3f0c
    128  3f0c					      tya		; 2
    129  3f0c					      rol		; 2	     rotate into Y
    130  3f0c					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  3f0c
    132  3f0c							; received byte in A
    133  3f0c					      rts		; 6 =	6
    134  3f0c							; i2c_rxbit:  40 cycles
    135  3f0c							; i2c_rxbyte: 310/333 cycles
    136  3f0c							;-------------------------------------------------------------------------------
    137  3f0c
    138  3f0c				   i2c_stopread
    139  3f0c					      bvc	i2c_stopwrite	; 2
    140  3f0c					      ldy	#$80	; 2
    141  3f0c					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  3f0c
    143  3f0c				   i2c_stopwrite
    144  3f0c					      jsr	i2c_txack	;30
    145  3f0c
    146  3f0c							; return port to input mode
    147  3f0c					      lda	#0	; 2	     0
    148  3f0c					      sta	SWACNT	; 4
    149  3f0c					      rts		; 6 = 12
    150  3f0c							; i2c_stopread:  45/92
    151  3f0c							; i2c_stopwrite: 42
    152  3f0c							;-------------------------------------------------------------------------------
    153  3f0c
    154  3f0c				   i2c_txack
    155  3f0c							; I2C_SCL_0
    156  3f0c					      lda	#0	; 2	     $00
    157  3f0c					      sta	SWCHA	; 4
    158  3f0c							; I2C_SDA_OUT
    159  3f0c					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  3f0c					      sta	SWACNT	; 4
    161  3f0c							; I2C_SCL_1
    162  3f0c					      asl		; 2	     I2C_SCL_MASK
    163  3f0c					      sta	SWCHA	; 4
    164  3f0c
    165  3f0c					      rts		; 6
    166  3f0c							; total: 24 cycles
    167  3f0c							;-------------------------------------------------------------------------------
    168  3f0c
    169  3f0c					      ENDM
    170  3f0c
    171  3f0c
    172  3f0c
------- FILE BANK_GENERIC.asm
    855  3f0c
      0  3f0c					      i2c_subs
      1  3f0c
      2  3f0c				   i2c_startread
      3  3f0c
      4  3f0c		       a0 a1		      ldy	#%10100001
      5  3f0e		       2c		      .byte.b	$2c
      6  3f0f				   i2c_startwrite
      7  3f0f		       a0 a0		      ldy	#%10100000
      0  3f11					      I2C_START
      1  3f11
      2  3f11		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  3f13		       8d 80 02 	      sta	SWCHA
      4  3f16
      5  3f16		       4a		      lsr
      6  3f17		       8d 81 02 	      sta	SWACNT
      7  3f1a
      9  3f1a		       98		      tya
     10  3f1b				   i2c_txbyte
     11  3f1b		       49 ff		      eor	#$ff
     12  3f1d		       38		      sec
     13  3f1e		       2a		      rol
     14  3f1f				   i2c_txbyteloop
     15  3f1f		       a8		      tay
      0  3f20					      I2C_TXBIT
      1  3f20
      2  3f20		       a9 03		      lda	#%0011
      3  3f22		       8d 80 02 	      sta	SWCHA
      4  3f25
      5  3f25		       69 08		      adc	#%1000
      6  3f27		       8d 81 02 	      sta	SWACNT
      7  3f2a
      8  3f2a		       a9 08		      lda	#I2C_SCL_MASK
      9  3f2c		       8d 80 02 	      sta	SWCHA
     10  3f2f
     17  3f2f		       98		      tya
     18  3f30		       0a		      asl
     19  3f31		       d0 ec		      bne	i2c_txbyteloop
     20  3f33
     21  3f33
     22  3f33
     23  3f33		       f0 0b		      beq	i2c_rxbit
     24  3f35
     25  3f35
     26  3f35
     27  3f35				   i2c_rxbyte
     28  3f35		       50 03		      bvc	i2c_rxskipack
     29  3f37		       20 68 f7 	      jsr	i2c_txack
     30  3f3a
     31  3f3a				   i2c_rxskipack
     32  3f3a		       2c 35 f7 	      bit	i2c_rxbyte
     33  3f3d
     34  3f3d		       a9 01		      lda	#1
     35  3f3f				   i2c_rxbyteloop
     36  3f3f		       a8		      tay
     37  3f40				   i2c_rxbit
      0  3f40					      I2C_TXNACK
      1  3f40
      2  3f40		       a9 10		      lda	#I2C_SCL_MASK*2
      3  3f42		       8d 80 02 	      sta	SWCHA
      4  3f45
      5  3f45		       4a		      lsr
      6  3f46		       8d 81 02 	      sta	SWACNT
      7  3f49
      8  3f49		       ea		      nop
      9  3f4a		       8d 80 02 	      sta	SWCHA
     10  3f4d
     39  3f4d
     40  3f4d		       ad 80 02 	      lda	SWCHA
     41  3f50		       4a		      lsr
     42  3f51		       4a		      lsr
     43  3f52		       4a		      lsr
     44  3f53
     45  3f53		       98		      tya
     46  3f54		       2a		      rol
     47  3f55		       90 e8		      bcc	i2c_rxbyteloop
     48  3f57
     49  3f57
     50  3f57		       60		      rts
     51  3f58
     52  3f58
     53  3f58
     54  3f58
     55  3f58				   i2c_stopread
     56  3f58		       50 05		      bvc	i2c_stopwrite
     57  3f5a		       a0 80		      ldy	#$80
     58  3f5c		       20 40 f7 	      jsr	i2c_rxbit
     59  3f5f
     60  3f5f				   i2c_stopwrite
     61  3f5f		       20 68 f7 	      jsr	i2c_txack
     62  3f62
     63  3f62
     64  3f62		       a9 00		      lda	#0
     65  3f64		       8d 81 02 	      sta	SWACNT
     66  3f67		       60		      rts
     67  3f68
     68  3f68
     69  3f68
     70  3f68
     71  3f68				   i2c_txack
     72  3f68
     73  3f68		       a9 00		      lda	#0
     74  3f6a		       8d 80 02 	      sta	SWCHA
     75  3f6d
     76  3f6d		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  3f6f		       8d 81 02 	      sta	SWACNT
     78  3f72
     79  3f72		       0a		      asl
     80  3f73		       8d 80 02 	      sta	SWCHA
     81  3f76
     82  3f76		       60		      rts
     83  3f77
     84  3f77
     85  3f77
    857  3f77
    858  3f77				   HandleSaveKey SUBROUTINE
    859  3f77
    860  3f77		       06 00	   SAVEKEY_ADR =	$0600	;	     reserved address for Boulder Dash (64 bytes)
    861  3f77
    862  3f77							; SK Memory Map:
    863  3f77							;		 cave	 level
    864  3f77							; $0600-$0602	 A	 1
    865  3f77							; $0603-$0605	 A	 2
    866  3f77							; $0606-$0608	 A	 3
    867  3f77							; $0609-$060b	 A	 4
    868  3f77							; $060c-$060e	 A	 5
    869  3f77							; $060f-$0611	 E	 1
    870  3f77							; $0612-$0614	 E	 2
    871  3f77							; $0615-$0617	 E	 3
    872  3f77							; $0618-$061a	 unused
    873  3f77							; $061b-$061d	 unused
    874  3f77							; $061e-$0620	 I	 1
    875  3f77							; $0621-$0623	 I	 2
    876  3f77							; $0624-$0626	 I	 3
    877  3f77							; $0627-$0629	 unused
    878  3f77							; $062a-$062c	 unused
    879  3f77							; $062d-$062f	 M	 1
    880  3f77							; $0630-$0632	 M	 2
    881  3f77							; $0633-$0635	 M	 3
    882  3f77							; $0636-$063f	 unused
    883  3f77
    884  3f77							;------------------------------------------------------------------------------
      0  3f77					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  3f77		       00 07	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  3f77					      SUBROUTINE
      3  3f77				   ReadSaveKey
    886  3f77
    887  3f77							; assume no SaveKey found:
    888  3f77		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    889  3f79		       85 e4		      sta	highScoreSK+2	; 3
    890  3f7b
    891  3f7b							; setup SaveKey:
    892  3f7b		       a5 e5		      lda	startCave	; 3	     load start cave*5 and level
    893  3f7d		       a6 b1		      ldx	level	; 3
    894  3f7f		       20 b8 f7 	      jsr	SetupSaveKey	;6+853
    895  3f82		       90 52		      bcc	NoSKfound	; 2/3
    896  3f84
    897  3f84							;    lda     #$34
    898  3f84							;    sta     COLUBK
    899  3f84
    900  3f84							; start read
    901  3f84		       20 5f f7 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    902  3f87		       20 0c f7 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    903  3f8a
    904  3f8a							; read high score:
    905  3f8a		       a2 02		      ldx	#3-1	; 2 = 1187
    906  3f8c				   .loopRead
    907  3f8c		       20 35 f7 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    908  3f8f		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    909  3f91		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    910  3f93		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    911  3f95				   .skipEmpty
    912  3f95		       95 e2		      sta	highScoreSK,x	; 4
    913  3f97		       ca		      dex		; 2
    914  3f98		       10 f2		      bpl	.loopRead	; 2/3= 354
    915  3f9a
    916  3f9a							; stop read:
    917  3f9a		       4c 58 f7 	      jmp	i2c_stopread	;3+92=95    terminate read
    918  3f9d
    919  3f9d							;------------------------------------------------------------------------------
      0  3f9d					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  3f9d		       00 07	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  3f9d					      SUBROUTINE
      3  3f9d				   WriteSaveKey
    921  3f9d
    922  3f9d							; check if new high score:
    923  3f9d		       a6 e2		      ldx	highScoreSK	; 3
    924  3f9f		       e8		      inx		; 2
    925  3fa0		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    926  3fa2
    927  3fa2							; setup SaveKey:
    928  3fa2		       a5 e5		      lda	startCave	; 3	     load start cave*5 and level
    929  3fa4		       a6 e6		      ldx	startLevel	; 3
    930  3fa6		       20 b8 f7 	      jsr	SetupSaveKey	; 6+853
    931  3fa9		       90 2b		      bcc	NoSKfound	; 2/3
    932  3fab
    933  3fab							;    lda     #$64
    934  3fab							;    sta     COLUBK
    935  3fab
    936  3fab							; write high score:
    937  3fab		       a2 02		      ldx	#3-1	; 2 = 841
    938  3fad				   .loopWrite
    939  3fad		       b5 e2		      lda	highScoreSK,x	; 4
    940  3faf		       20 1b f7 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    941  3fb2		       ca		      dex		; 2
    942  3fb3		       10 f8		      bpl	.loopWrite	; 2/3= 837
    943  3fb5
    944  3fb5							; stop write:
    945  3fb5		       4c 5f f7 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    946  3fb8
    947  3fb8
    948  3fb8							;------------------------------------------------------------------------------
      0  3fb8					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  3fb8		       00 07	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  3fb8					      SUBROUTINE
      3  3fb8				   SetupSaveKey
    950  3fb8
    951  3fb8							; calculate slot;
    952  3fb8							; a = cave (5*n): A=$00; E=$05; I=$0a; M=$0f
    953  3fb8							; x = level (0..4)
    954  3fb8		       85 e7		      sta	offsetSK	; 3
    955  3fba		       8a		      txa		; 2
    956  3fbb		       18		      clc		; 2
    957  3fbc		       65 e7		      adc	offsetSK	; 3
    958  3fbe		       85 e7		      sta	offsetSK	; 3
    959  3fc0		       0a		      asl		; 2	     multiply by 3
    960  3fc1		       65 e7		      adc	offsetSK	; 3
    961  3fc3		       69 00		      adc	#<SAVEKEY_ADR	; 2
    962  3fc5		       aa		      tax		; 2 = 22
    963  3fc6							; detect SaveKey:
    964  3fc6		       20 0f f7 	      jsr	i2c_startwrite	;6+280
    965  3fc9		       d0 0a		      bne	.exitSK	; 2/3
    966  3fcb
    967  3fcb							; setup address:
    968  3fcb		       b8		      clv		; 2
    969  3fcc		       a9 06		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    970  3fce		       20 1b f7 	      jsr	i2c_txbyte	;6+264
    971  3fd1		       8a		      txa		; 2	     x = lower byte offset
    972  3fd2		       4c 1b f7 	      jmp	i2c_txbyte	;3+264      returns C==1
    973  3fd5
    974  3fd5				   .exitSK
    975  3fd5		       18		      clc
    976  3fd6				   NoSKfound
    977  3fd6		       60		      rts
    978  3fd6					      ENDIF
    979  3fd7
    980  3fd7
      0  3fd7					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  3fd7		       07 d7	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $7d7 , FREE= $29
      2  3fd7					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3fd7				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3fd7				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3fd7				  -	      ERR
      6  3fd7					      endif
------- FILE ./notBoulderDash.asm
   1107  3fd7
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 3
      0  3fd7					      include	"BANK_INITBANK.asm"	; MUST be after banks that include caves -- otherwise MAX_CAVEBANK is not calculated properly
      1  3fd7
      0  3fd7					      NEWBANK	INITBANK
      1  471d ????				      SEG	INITBANK
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   INITBANK   SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	INITBANK
      3  4000
      4  4000		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
      5  4001
      0  4001					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  4001		       00 08	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  4001					      SUBROUTINE
      3  4001				   BoardLineStartLO
      7  4001
      8  4001							; Gives the start address (LO) of each board line
      9  4001
     10  4001				   .BOARD_LOCATION SET	Board
     11  4001					      REPEAT	SIZE_BOARD_Y
     12  4001				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4001				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4001					      ENDIF
     15  4001		       00		      .byte.b	<.BOARD_LOCATION
     16  4001				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4001					      REPEND
     12  4002				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4002				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4002					      ENDIF
     15  4002		       28		      .byte.b	<.BOARD_LOCATION
     16  4002				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4002					      REPEND
     12  4003				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4003				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4003					      ENDIF
     15  4003		       50		      .byte.b	<.BOARD_LOCATION
     16  4003				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4003					      REPEND
     12  4004				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4004				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4004					      ENDIF
     15  4004		       78		      .byte.b	<.BOARD_LOCATION
     16  4004				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4004					      REPEND
     12  4005				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4005				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4005					      ENDIF
     15  4005		       a0		      .byte.b	<.BOARD_LOCATION
     16  4005				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4005					      REPEND
     12  4006				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4006				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4006					      ENDIF
     15  4006		       c8		      .byte.b	<.BOARD_LOCATION
     16  4006				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4006					      REPEND
     12  4007					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4007				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4007					      ENDIF
     15  4007		       00		      .byte.b	<.BOARD_LOCATION
     16  4007				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4007					      REPEND
     12  4008				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4008				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4008					      ENDIF
     15  4008		       28		      .byte.b	<.BOARD_LOCATION
     16  4008				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4008					      REPEND
     12  4009				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4009				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4009					      ENDIF
     15  4009		       50		      .byte.b	<.BOARD_LOCATION
     16  4009				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4009					      REPEND
     12  400a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  400a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  400a					      ENDIF
     15  400a		       78		      .byte.b	<.BOARD_LOCATION
     16  400a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  400a					      REPEND
     12  400b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  400b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  400b					      ENDIF
     15  400b		       a0		      .byte.b	<.BOARD_LOCATION
     16  400b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  400b					      REPEND
     12  400c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  400c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  400c					      ENDIF
     15  400c		       c8		      .byte.b	<.BOARD_LOCATION
     16  400c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  400c					      REPEND
     12  400d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  400d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  400d					      ENDIF
     15  400d		       00		      .byte.b	<.BOARD_LOCATION
     16  400d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  400d					      REPEND
     12  400e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  400e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  400e					      ENDIF
     15  400e		       28		      .byte.b	<.BOARD_LOCATION
     16  400e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  400e					      REPEND
     12  400f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  400f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  400f					      ENDIF
     15  400f		       50		      .byte.b	<.BOARD_LOCATION
     16  400f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  400f					      REPEND
     12  4010				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4010				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4010					      ENDIF
     15  4010		       78		      .byte.b	<.BOARD_LOCATION
     16  4010				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4010					      REPEND
     12  4011				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4011				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4011					      ENDIF
     15  4011		       a0		      .byte.b	<.BOARD_LOCATION
     16  4011				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4011					      REPEND
     12  4012				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4012				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4012					      ENDIF
     15  4012		       c8		      .byte.b	<.BOARD_LOCATION
     16  4012				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4012					      REPEND
     12  4013					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4013				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4013					      ENDIF
     15  4013		       00		      .byte.b	<.BOARD_LOCATION
     16  4013				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4013					      REPEND
     12  4014				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4014				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4014					      ENDIF
     15  4014		       28		      .byte.b	<.BOARD_LOCATION
     16  4014				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4014					      REPEND
     12  4015				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4015				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4015					      ENDIF
     15  4015		       50		      .byte.b	<.BOARD_LOCATION
     16  4015				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  4015					      REPEND
     12  4016				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  4016				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  4016					      ENDIF
     15  4016		       78		      .byte.b	<.BOARD_LOCATION
     16  4016				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     17  4017					      REPEND
      0  4017					      CHECKPAGE	BoardLineStartLO
      8  4017					      LIST	ON
     19  4017
     20  4017		       03 a0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     21  4017
     22  4017							;------------------------------------------------------------------------------
     23  4017
     24  4017				   BoardLineStartHiR
     25  4017
     26  4017							; Gives the start address (HI) of each board line
     27  4017							; Note this caters for the memory wrapping when we go from bank to bank, as
     28  4017							; the board overlays multiple banks!
     29  4017
     30  4017				   .BOARD_LOCATION SET	Board
     31  4017					      REPEAT	SIZE_BOARD_Y
     32  4017				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4017				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4017					      ENDIF
     35  4017		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4017				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4017					      REPEND
     32  4018				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4018				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4018					      ENDIF
     35  4018		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4018				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4018					      REPEND
     32  4019				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4019				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4019					      ENDIF
     35  4019		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4019				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4019					      REPEND
     32  401a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  401a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  401a					      ENDIF
     35  401a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  401a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  401a					      REPEND
     32  401b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  401b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  401b					      ENDIF
     35  401b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  401b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  401b					      REPEND
     32  401c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  401c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  401c					      ENDIF
     35  401c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  401c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  401c					      REPEND
     32  401d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  401d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  401d					      ENDIF
     35  401d		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  401d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  401d					      REPEND
     32  401e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  401e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  401e					      ENDIF
     35  401e		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  401e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  401e					      REPEND
     32  401f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  401f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  401f					      ENDIF
     35  401f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  401f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  401f					      REPEND
     32  4020				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4020				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4020					      ENDIF
     35  4020		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4020				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4020					      REPEND
     32  4021				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4021				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4021					      ENDIF
     35  4021		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4021				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4021					      REPEND
     32  4022				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4022				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4022					      ENDIF
     35  4022		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4022				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4022					      REPEND
     32  4023					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4023				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4023					      ENDIF
     35  4023		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4023				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4023					      REPEND
     32  4024				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4024				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4024					      ENDIF
     35  4024		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4024				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4024					      REPEND
     32  4025				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4025				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4025					      ENDIF
     35  4025		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4025				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4025					      REPEND
     32  4026				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4026				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4026					      ENDIF
     35  4026		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4026				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4026					      REPEND
     32  4027				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4027				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4027					      ENDIF
     35  4027		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4027				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4027					      REPEND
     32  4028				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4028				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4028					      ENDIF
     35  4028		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4028				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4028					      REPEND
     32  4029					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  4029				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  4029					      ENDIF
     35  4029		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  4029				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  4029					      REPEND
     32  402a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  402a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  402a					      ENDIF
     35  402a		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  402a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  402a					      REPEND
     32  402b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  402b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  402b					      ENDIF
     35  402b		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  402b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  402b					      REPEND
     32  402c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  402c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  402c					      ENDIF
     35  402c		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  402c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     37  402d					      REPEND
      0  402d					      CHECKPAGE	BoardLineStartHiR
      8  402d					      LIST	ON
     39  402d							;------------------------------------------------------------------------------
     40  402d
     41  402d				   BoardLineStartHiW
     42  402d
     43  402d							; Gives the start address (HI) of each board line
     44  402d							; Note this caters for the memory wrapping when we go from bank to bank, as
     45  402d							; the board overlays multiple banks!
     46  402d
     47  402d				   .BOARD_LOCATION SET	Board
     48  402d					      REPEAT	SIZE_BOARD_Y
     49  402d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  402d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  402d					      ENDIF
     52  402d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  402d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  402d					      REPEND
     49  402e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  402e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  402e					      ENDIF
     52  402e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  402e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  402e					      REPEND
     49  402f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  402f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  402f					      ENDIF
     52  402f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  402f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  402f					      REPEND
     49  4030				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4030				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4030					      ENDIF
     52  4030		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4030				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  4030					      REPEND
     49  4031				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4031				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4031					      ENDIF
     52  4031		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4031				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  4031					      REPEND
     49  4032				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4032				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4032					      ENDIF
     52  4032		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4032				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  4032					      REPEND
     49  4033					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4033				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4033					      ENDIF
     52  4033		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4033				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  4033					      REPEND
     49  4034				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4034				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4034					      ENDIF
     52  4034		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4034				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  4034					      REPEND
     49  4035				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4035				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4035					      ENDIF
     52  4035		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4035				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  4035					      REPEND
     49  4036				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4036				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4036					      ENDIF
     52  4036		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4036				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  4036					      REPEND
     49  4037				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4037				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4037					      ENDIF
     52  4037		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4037				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  4037					      REPEND
     49  4038				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4038				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4038					      ENDIF
     52  4038		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4038				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  4038					      REPEND
     49  4039					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4039				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4039					      ENDIF
     52  4039		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4039				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  4039					      REPEND
     49  403a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  403a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  403a					      ENDIF
     52  403a		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  403a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  403a					      REPEND
     49  403b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  403b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  403b					      ENDIF
     52  403b		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  403b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  403b					      REPEND
     49  403c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  403c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  403c					      ENDIF
     52  403c		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  403c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  403c					      REPEND
     49  403d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  403d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  403d					      ENDIF
     52  403d		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  403d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  403d					      REPEND
     49  403e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  403e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  403e					      ENDIF
     52  403e		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  403e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  403e					      REPEND
     49  403f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  403f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  403f					      ENDIF
     52  403f		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  403f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  403f					      REPEND
     49  4040				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4040				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4040					      ENDIF
     52  4040		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4040				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  4040					      REPEND
     49  4041				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4041				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4041					      ENDIF
     52  4041		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4041				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  4041					      REPEND
     49  4042				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  4042				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  4042					      ENDIF
     52  4042		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  4042				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     54  4043					      REPEND
      0  4043					      CHECKPAGE	BoardLineStartHiW
      8  4043					      LIST	ON
     56  4043
     57  4043							;------------------------------------------------------------------------------
     58  4043				  -	      IF	MULTI_BANK_BOARD = YES
     59  4043				  -BoardBank
     60  4043					      ENDIF
     61  4043							; Gives the RAM bank of the start of the board row for a given row.
     62  4043
     63  4043				   .BOARD_LOCATION SET	Board - RAM_3E
     64  4043					      REPEAT	SIZE_BOARD_Y
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  4043					      REPEND
     65  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4043					      ENDIF
     68  4043				  -	      IF	MULTI_BANK_BOARD = YES
     69  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  4043					      ENDIF
     71  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     72  4043					      REPEND
     73  4043				  -	      IF	MULTI_BANK_BOARD = YES
     74  4043				  -	      CHECKPAGE	BoardBank
     75  4043					      ENDIF
     76  4043
     77  4043
     78  4043							;------------------------------------------------------------------------------
     79  4043
     80  4043				   CopyROMShadowToRAM_F000
     81  4043		       a9 f0		      lda	#>$F000
     82  4045
      0  4045					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  4045		       00 08	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  4045					      SUBROUTINE
      3  4045				   CopyROMShadowToRAM
     84  4045
     85  4045							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
     86  4045							; the variable definitions are in the ROM shadow because this allows auto-initialisation
     87  4045							; of the variable contents from ROM declarations, but still allows access to them as
     88  4045							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
     89  4045							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
     90  4045							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
     91  4045							; code co-lives in all banks and may run even as bankswitching occurs between those
     92  4045							; banks -- by the very code itself.
     93  4045
     94  4045							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
     95  4045		       85 c0		      sta	Board_AddressR+1
     96  4047		       86 e0		      stx	O_ROM_Source_Bank	; source bank
     97  4049		       84 c4		      sty	RAM_Bank	; destination bank
     98  404b
     99  404b		       a0 00		      ldy	#0
    100  404d		       84 bf		      sty	Board_AddressR
    101  404f		       84 c1		      sty	Board_AddressW
    102  4051		       a9 14		      lda	#>($1000+RAM_WRITE)
    103  4053		       85 c2		      sta	Board_AddressW+1
    104  4055
    105  4055							; Iterate 4 pages (1K) for complete bank copy
    106  4055
    107  4055		       a9 04		      lda	#4
    108  4057		       85 df		      sta	O_CopyCount
    109  4059
    110  4059		       84 e1	   CopyPage   sty	O_Index
    111  405b		       a5 e0		      lda	O_ROM_Source_Bank
    112  405d		       20 df f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    113  4060							;tax
    114  4060		       a4 e1		      ldy	O_Index
    115  4062		       a6 c4		      ldx	RAM_Bank
    116  4064		       20 ed f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    117  4067
    118  4067		       a4 e1		      ldy	O_Index
    119  4069		       c8		      iny
    120  406a		       d0 ed		      bne	CopyPage
    121  406c
    122  406c		       e6 c0		      inc	Board_AddressR+1
    123  406e		       e6 c2		      inc	Board_AddressW+1
    124  4070
    125  4070		       c6 df		      dec	O_CopyCount
    126  4072		       d0 e5		      bne	CopyPage
    127  4074
    128  4074		       a4 c4		      ldy	RAM_Bank	; TODO: remove!?
    129  4076		       60		      rts
    130  4077
    131  4077
    132  4077							;------------------------------------------------------------------------------
      0  4077					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  4077		       00 08	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  4077					      SUBROUTINE
      3  4077				   SetPlatformColours
    134  4077
    135  4077							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    136  4077							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    137  4077							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    138  4077							; addressing will not violate the page-crossing restriction of 3E.
    139  4077
    140  4077							; TODO: adapt for fast vertical scrolling
    141  4077
    142  4077							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    143  4077
    144  4077		       a9 00		      lda	#<DrawTheScreen	; = 0
    145  4079		       85 c1		      sta	Board_AddressW
    146  407b		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    147  407d		       85 c2		      sta	Board_AddressW+1
    148  407f
    149  407f							; first, set the x index (with last one being a RTS ($60))
    150  407f
    151  407f		       a6 c4		      ldx	RAM_Bank
    152  4081		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    153  4083		       d0 07		      bne	.skipPatch
    154  4085		       a9 60		      lda	#$60	; rts
    155  4087		       a0 41		      ldy	#<SELFMOD_X
    156  4089		       20 ed f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    157  408c				   .skipPatch
    158  408c
    159  408c		       a2 02		      ldx	#3-1
    160  408e				   .loopColor
    161  408e		       86 df		      stx	colorIdx
    162  4090							; set PF colors
    163  4090		       b5 bc		      lda	color,x
    164  4092		       bc b7 f0 	      ldy	SelfModColOfsTbl,x
    165  4095							;tax
    166  4095		       a6 c4		      ldx	RAM_Bank
    167  4097		       20 ed f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy PF colour RED/GREEN/BLUE to self-modifying RAM
    168  409a							; set player colors
    169  409a		       a6 df		      ldx	colorIdx
    170  409c		       bd ba f0 	      lda	SelfModePlayerTbl,x
    171  409f		       a4 81		      ldy	Platform
    172  40a1		       c0 02		      cpy	#PAL
    173  40a3		       90 02		      bcc	.platform0
    174  40a5		       69 14		      adc	#LINES_PER_CHAR-1	; C==1!
    175  40a7				   .platform0
    176  40a7		       bc bd f0 	      ldy	SelfModPlayerColOfsTbl,x
    177  40aa							;tax
    178  40aa		       a6 c4		      ldx	RAM_Bank
    179  40ac		       20 ed f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy player colour RED/GREEN/BLUE to self-modifying RAM
    180  40af							; loop
    181  40af		       a6 df		      ldx	colorIdx
    182  40b1		       ca		      dex
    183  40b2		       10 da		      bpl	.loopColor
    184  40b4
    185  40b4		       a4 c4		      ldy	RAM_Bank
    186  40b6		       60		      rts
    187  40b7
    188  40b7				   SelfModColOfsTbl
    189  40b7		       53 86 1c 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    190  40ba				   SelfModePlayerTbl
    191  40ba		       bd b6 af 	      .byte.b	<SpriteColourBLUE, <SpriteColourGREEN, <SpriteColourRED
    192  40bd				   SelfModPlayerColOfsTbl
    193  40bd		       4c 7f 15 	      .byte.b	<(SELFMOD_PLAYERCOL_BLUE+1), <(SELFMOD_PLAYERCOL_GREEN+1), <(SELFMOD_PLAYERCOL_RED+1)
    194  40c0
    195  40c0
    196  40c0				   DrawLineStartLO
    197  40c0
    198  40c0							; Gives the start address of each line in the draw flags buffer
    199  40c0
    200  40c0				   .DRAW_LOCATION SET	DrawFlag
    201  40c0					      REPEAT	SCREEN_LINES
    202  40c0		       50		      .byte.b	<.DRAW_LOCATION
    203  40c0				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  40c0					      REPEND
    202  40c1		       5a		      .byte.b	<.DRAW_LOCATION
    203  40c1				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  40c1					      REPEND
    202  40c2		       64		      .byte.b	<.DRAW_LOCATION
    203  40c2				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  40c2					      REPEND
    202  40c3		       6e		      .byte.b	<.DRAW_LOCATION
    203  40c3				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  40c3					      REPEND
    202  40c4		       78		      .byte.b	<.DRAW_LOCATION
    203  40c4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  40c4					      REPEND
    202  40c5		       82		      .byte.b	<.DRAW_LOCATION
    203  40c5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  40c5					      REPEND
    202  40c6		       8c		      .byte.b	<.DRAW_LOCATION
    203  40c6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  40c6					      REPEND
    202  40c7		       96		      .byte.b	<.DRAW_LOCATION
    203  40c7				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    204  40c8					      REPEND
    205  40c8
    206  40c8
    207  40c8							;------------------------------------------------------------------------------
    208  40c8
      0  40c8					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  40c8		       00 08	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  40c8					      SUBROUTINE
      3  40c8				   GetBoardAddressRW
    210  40c8							; Must share same bank as BoardLineStart tables
    211  40c8
    212  40c8		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    213  40cb		       85 bf		      sta	Board_AddressR	; 3
    214  40cd		       85 c1		      sta	Board_AddressW	; 3
    215  40cf		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    216  40d2		       85 c0		      sta	Board_AddressR+1	; 3	     READ address
    217  40d4		       09 04		      ora	#>RAM_WRITE	; 2
    218  40d6		       85 c2		      sta	Board_AddressW+1	; 3	     WRITE address
    219  40d8				  -	      IF	MULTI_BANK_BOARD = YES
    220  40d8				  -	      ldx	BoardBank,y	; 4 = 26    switch this on return
    221  40d8					      ELSE
    222  40d8		       a2 0d		      ldx	#BANK_BOARD	; 2
    223  40da					      ENDIF
    224  40da		       60		      rts		; 6 = 32[-2]
    225  40db
    226  40db							;------------------------------------------------------------------------------
    227  40db
      0  40db					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  40db		       00 08	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  40db					      SUBROUTINE
      3  40db				   GetBoardAddressR
    229  40db
    230  40db		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    231  40de		       85 bf		      sta	Board_AddressR	; 3
    232  40e0		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    233  40e3		       85 c0		      sta	Board_AddressR+1	; 3	 READ address
    234  40e5				  -	      IF	MULTI_BANK_BOARD = YES
    235  40e5				  -	      lda	BoardBank,y	; 4	 switch this on return
    236  40e5					      ELSE
    237  40e5		       a9 0d		      lda	#BANK_BOARD	; 2
    238  40e7					      ENDIF
    239  40e7		       60		      rts		; 6[-2]
    240  40e8
    241  40e8							;------------------------------------------------------------------------------
    242  40e8
    243  40e8							; +------+------+------+
    244  40e8							; |*	  | a(0) |	|   *= where Temp_board_address1 points
    245  40e8							; +------+------+------+
    246  40e8							; | d(3) | X(4) | b(1) |
    247  40e8							; +------+------+------+
    248  40e8							; |	  | c(2) |	|
    249  40e8							; +------+------+------+
    250  40e8
    251  40e8
      0  40e8					      DEFINE_SUBROUTINE	GetBoardAddress4	;=72[-16](C)
      1  40e8		       00 08	   BANK_GetBoardAddress4 =	_CURRENT_BANK
      2  40e8					      SUBROUTINE
      3  40e8				   GetBoardAddress4
    253  40e8
    254  40e8		       a4 90		      ldy	POS_Y	;3
    255  40ea
    256  40ea		       b9 00 f0 	      lda	BoardLineStartLO-1,y	;4
    257  40ed		       85 df		      sta	Temp_Board_Address1	;3
    258  40ef		       b9 01 f0 	      lda	BoardLineStartLO+1-1,y	;4
    259  40f2		       85 e1		      sta	Temp_Board_Address2	;3
    260  40f4		       b9 02 f0 	      lda	BoardLineStartLO+2-1,y	;4
    261  40f7		       85 e3		      sta	Temp_Board_Address3	;3
    262  40f9		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	;4
    263  40fc		       85 e0		      sta	Temp_Board_Address1+1	;3
    264  40fe		       b9 17 f0 	      lda	BoardLineStartHiR+1-1,y	;4
    265  4101		       85 e2		      sta	Temp_Board_Address2+1	;3
    266  4103		       b9 18 f0 	      lda	BoardLineStartHiR+2-1,y	;4
    267  4106		       85 e4		      sta	Temp_Board_Address3+1	;3
    268  4108				  -	      IF	MULTI_BANK_BOARD = YES
    269  4108				  -	      lda	BoardBank+1-1,y	;4
    270  4108				  -	      sta	Temp_Bank2	;3
    271  4108				  -	      lda	BoardBank+2-1,y	;4
    272  4108				  -	      sta	Temp_Bank3	;3
    273  4108				  -	      lda	BoardBank-1,y	;4
    274  4108				  -			;sta Temp_Bank 		 ;   this becomes switched in RAM bank in normal usage
    275  4108					      ELSE
    276  4108		       a9 0d		      lda	#BANK_BOARD	;2
    277  410a					      ENDIF
    278  410a		       a4 8f		      ldy	POS_X	;3
    279  410c		       60		      rts		;6 = 72[-16]
    280  410d
    281  410d							;------------------------------------------------------------------------------
    282  410d
      0  410d					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  410d		       00 08	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  410d					      SUBROUTINE
      3  410d				   GetBoardAddressW
    284  410d
    285  410d							; Must share same bank as BoardLineStart tables
    286  410d
    287  410d		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    288  4110		       85 c1		      sta	Board_AddressW	;3
    289  4112		       b9 2d f0 	      lda	BoardLineStartHiW,y	;4
    290  4115		       85 c2		      sta	Board_AddressW+1	;3 WRITE address
    291  4117				  -	      IF	MULTI_BANK_BOARD = YES
    292  4117				  -	      ldx	BoardBank,y	;4 switch this on return
    293  4117					      ELSE
    294  4117		       a2 0d		      ldx	#BANK_BOARD	;2
    295  4119					      ENDIF
    296  4119		       60	   QRet       rts		;6
    297  411a
    298  411a							;------------------------------------------------------------------------------
    299  411a
    300  411a				  -	      IF	0	;{
    301  411a				  -			;IF DEMO_VERSION = YES && FINAL_VERSION = NO
    302  411a				  -	      DEFINE_SUBROUTINE	ProcessSelector	; in INITBANK
    303  411a				  -
    304  411a				  -	      sta	ROM_Bank
    305  411a				  -
    306  411a				  -			; This object handles the selection of screen and level
    307  411a				  -
    308  411a				  -	      jsr	MoveViaJoystick
    309  411a				  -	      jsr	InsertObjectStack	;6+76(B)	  re-insert object at same position
    310  411a				  -
    311  411a				  -	      asl	NextLevelTrigger
    312  411a				  -	      lda	BufferedButton	; button pressed?
    313  411a				  -	      asl
    314  411a				  -	      ror	NextLevelTrigger
    315  411a				  -
    316  411a				  -	      lda	POS_VAR
    317  411a				  -	      and	#31
    318  411a				  -	      sta	caveDisplay
    319  411a				  -	      asl
    320  411a				  -	      asl
    321  411a				  -	      adc	caveDisplay	; *5
    322  411a				  -	      sta	cave
    323  411a				  -
    324  411a				  -			; Note: we can only select level 1,2,3,4
    325  411a				  -			; Didn't have enough bits in the POS_VAR variable to hold 0-4 for level and 0-34 for cave... eh?
    326  411a				  -	      lda	POS_VAR
    327  411a				  -	      lsr
    328  411a				  -	      lsr
    329  411a				  -	      lsr
    330  411a				  -	      lsr
    331  411a				  -	      lsr
    332  411a				  -	      sta	level
    333  411a				  -
    334  411a				  -
    335  411a				  -	      ldx	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    336  411a				  -	      lda	ThrottlePerSystem,x
    337  411a				  -	      sta	ThrottleSpeed	; only for selection screen
    338  411a				  -
    339  411a				  -	      rts
    340  411a				  -ThrottlePerSystem
    341  411a				  -	      .byte	19
    342  411a				  -	      .byte	21
    343  411a					      ENDIF		;}
    344  411a
    345  411a							;------------------------------------------------------------------------------
    346  411a
      0  411a					      DEFINE_SUBROUTINE	ProcessExplosion	; in INITBANK
      1  411a		       00 08	   BANK_ProcessExplosion =	_CURRENT_BANK
      2  411a					      SUBROUTINE
      3  411a				   ProcessExplosion
    348  411a
    349  411a							; Explosion object delays for 4 animation frames and
    350  411a							; then replaces itself with a character or diamond (and generates diamond creature).
    351  411a							; If blanks are generated, these are pushed to the blank-stack.
    352  411a		       85 c3		      sta	ROM_Bank
    353  411c
    354  411c							; Check if the board character is our (last) written explosion character
    355  411c							; if NOT, then something's happened (another explosion over the top, perhaps...?) so die.
    356  411c
    357  411c		       a4 90		      ldy	POS_Y	;3
    358  411e		       20 db f0 	      jsr	GetBoardAddressR	;6+24[-2](A)
    359  4121		       a4 8f		      ldy	POS_X
    360  4123		       20 e4 f8 	      jsr	GetBoardCharacter
    361  4126		       45 94		      eor	POS_VAR
    362  4128		       0a		      asl
    363  4129		       d0 ee		      bne	QRet	; something happened -- not expected char so die
    364  412b
    365  412b
    366  412b		       e6 94		      inc	POS_VAR
    367  412d		       a5 94		      lda	POS_VAR	; d7 = diamond/blank, rest = animation index
    368  412f		       29 7f		      and	#~$80
    369  4131		       c9 17		      cmp	#CHARACTER_EXPLOSION3+1
    370  4133		       f0 0f		      beq	PostExplosion
    371  4135		       48		      pha
    372  4136
    373  4136		       a4 90		      ldy	POS_Y
    374  4138		       20 0d f1 	      jsr	GetBoardAddressW
    375  413b		       a4 8f		      ldy	POS_X
    376  413d		       68		      pla
    377  413e		       20 ed f8 	      jsr	PutBoardCharacter	; write new post-explosion character
    378  4141
    379  4141							;inc POS_VAR			  ; frame and diamond/blank flag
    380  4141		       4c 7c fb 	      jmp	InsertObjectStack	;6+76(B)	  re-insert object
    381  4144
    382  4144
      0  4144					      DEFINE_SUBROUTINE	PostExplosion
      1  4144		       00 08	   BANK_PostExplosion =	_CURRENT_BANK
      2  4144					      SUBROUTINE
      3  4144				   PostExplosion
    384  4144
    385  4144		       a5 94		      lda	POS_VAR
    386  4146		       10 17		      bpl	ExplosionBlank
    387  4148		       a9 40		      lda	#VAR_JUST_GENERATED
    388  414a		       85 94		      sta	POS_VAR	; NOT a falling diamond -- fixes chained butterfly explosion
    389  414c		       a4 90		      ldy	POS_Y
    390  414e		       20 0d f1 	      jsr	GetBoardAddressW
    391  4151		       a4 8f		      ldy	POS_X
    392  4153		       a9 04		      lda	#CHARACTER_DIAMOND
    393  4155		       20 ed f8 	      jsr	PutBoardCharacter	; write new post-explosion character
    394  4158
    395  4158							; Become an active diamond (in case it needs to fall)
    396  4158
    397  4158		       a9 05		      lda	#TYPE_DIAMOND
    398  415a		       85 93		      sta	POS_Type
    399  415c		       4c 7c fb 	      jmp	InsertObjectStack	;3+76(B)	  and return
    400  415f
    401  415f				   ExplosionBlank
    402  415f
    403  415f							; Place this square onto the blank stack so creatures may fall into it
    404  415f
    405  415f		       a4 90		      ldy	POS_Y
    406  4161		       20 0d f1 	      jsr	GetBoardAddressW
    407  4164		       a4 8f		      ldy	POS_X
    408  4166		       a9 00		      lda	#CHARACTER_BLANK
    409  4168		       20 ed f8 	      jsr	PutBoardCharacter	; write new post-explosion character
    410  416b
    411  416b		       a9 08		      lda	#BANK_DRAW_BUFFERS
    412  416d		       4c d5 f8 	      jmp	InsertBlankStack2	;6+51(A) place object on blank stack and return
    413  4170
    414  4170							;------------------------------------------------------------------------------
    415  4170							;Amoeba is stuff that grows randomly. If trapped such that it can't grow any more, it "suffocates" and turns into
    416  4170							; diamonds. If it grows too large, it turns into boulders. Fireflies and butterflies will explode on contact with
    417  4170							; amoeba. Every scan, a count is kept of how many amoeba have been found. For each amoeba found during the current scan,
    418  4170							; it does these things:
    419  4170							;
    420  4170							;If there were too many (see below) amoeba found in the scan during the last frame, the amoeba is considered to have
    421  4170							; grown too large, and so all amoeba found in this scan frame are quietly replaced with boulders. Failing that, if it
    422  4170							; was determined in the scan during the last frame that the amoeba was completely enclosed (could not grow), then each
    423  4170							; amoeba is quietly replaced with a diamond. Failing that, if there have been no amoeba found during the current scan
    424  4170							; that had the potential to grow, then a check is made to see whether this amoeba could grow. If it is possible for it
    425  4170							; to grow, then the flag is changed to indicate that there is at least one amoeba in existance that can grow during this
    426  4170							; frame. If the amoeba did not turn into a diamond or a boulder (in steps 1 or 2 above), it may or may not attempt to
    427  4170							; grow. A random number is generated to decide whether the amoeba will attempt grow: it has a 4/128 chance (about 3%)
    428  4170							; normally, or a 4/16 chance (25%) in some circumstances. If the decision is that the amoeba will atempt to grow, it
    429  4170							; randomly chooses one of the four directions to grow in. If that direction contains a space or dirt, the amoeba grows
    430  4170							; to fill that spot. The new amoeba just grown does not itself get the chance to grow until the next frame (ie the new
    431  4170							; amoeba is marked as "amoeba, scanned this frame"). How many is too many? For the Commodore 64 implementation of
    432  4170							; Boulder Dash, "too many" amoeba (the point where they turn into boulders) is 200 or more. Since other implementations
    433  4170							; of Boulder Dash may permit cave sizes other than 40 x 22 (= 880 squares), I suggest that "too many" is defined as
    434  4170							; being 200/880 = 22.7% of the total number of squares available in the cave. In other words, once 22.7% or more of the
    435  4170							; cave is occupied by amoeba, it should turn into boulders. When is it 3% and when 25%? Initially, the amoeba growth
    436  4170							; probability is 4/128 (about 3%). Once the "amoeba slow growth time" has elapsed, the amoeba suddenly starts growing a
    437  4170							; lot quicker (amoeba growth probability = 25%). The "amoeba slow growth time" is set on a cave-by-cave basis, and is in
    438  4170							; seconds.
    439  4170
    440  4170							; TODOs:
    441  4170							; ? maybe scan in a different order to hide scanning character (step x rows and y columns)
    442  4170							; - the processing of the whole board should be done at a fixed speed
    443  4170
      0  4170					      DEFINE_SUBROUTINE	ProcessAmoeba	; in INITBANK
      1  4170		       00 08	   BANK_ProcessAmoeba =	_CURRENT_BANK
      2  4170					      SUBROUTINE
      3  4170				   ProcessAmoeba
    445  4170
    446  4170							; This routine gets priority over everything, so it really needs to use as LITTLE time as it possibly can.
    447  4170		       85 c3		      sta	ROM_Bank
    448  4172
    449  4172							; before we start a new scan wait a minimum number of scan calls (keeps the  Amoeba speed more constant)
    450  4172		       a6 d2		      ldx	amoebaStepCount	; 3
    451  4174		       f0 13		      beq	.doScan	; 2/3
    452  4176		       ca		      dex		; 2
    453  4177		       d0 08		      bne	.notZero
    454  4179		       a5 cc		      lda	amoebaFlag	; 3	 when the count reaches zero, we are allowed to start a new scan
    455  417b		       29 fd		      and	#(<~SCAN_FINISHED)	; 2
    456  417d		       85 cc		      sta	amoebaFlag	; 3
    457  417f		       a2 1d		      ldx	#MIN_AMOEBA_SCAN-1	; 2
    458  4181				   .notZero
    459  4181		       86 d2		      stx	amoebaStepCount	; 3				    ;
    460  4183		       a5 cc		      lda	amoebaFlag	; 3
    461  4185		       29 02		      and	#SCAN_FINISHED
    462  4187		       d0 65		      bne	ambRet
    463  4189				   .doScan
    464  4189		       a9 20		      lda	#FINISHEDDIAMOND
    465  418b		       24 cc		      bit	amoebaFlag
    466  418d		       d0 5f		      bne	ambRet	;
    467  418f		       10 03		      bpl	aCycle	; not TODIAMOND, run only once
    468  4191
    469  4191		       20 97 f1 	      jsr	nextAmobPos	; 3 scans/frame, do quicker if converting to diamonds/boulders
    470  4194
    471  4194							; Scan amoeba position
    472  4194
    473  4194		       20 97 f1    aCycle     jsr	nextAmobPos	; 2 scans/frame
    474  4197
    475  4197				   nextAmobPos
    476  4197							;		  ldy amoebaY			  ; 3	 TODO: replace following code
    477  4197							;		  jsr GetBoardAddressR
    478  4197							;		  ldy amoebaX			  ; 3
    479  4197
    480  4197		       a6 cb		      ldx	amoebaY	; 3
    481  4199		       a4 ca		      ldy	amoebaX	; 3
    482  419b		       bd 01 f0 	      lda	BoardLineStartLO,x	; 4
    483  419e		       85 bf		      sta	Board_AddressR	; 3
    484  41a0		       bd 17 f0 	      lda	BoardLineStartHiR,x	; 4
    485  41a3		       85 c0		      sta	Board_AddressR+1	; 3
    486  41a5				  -	      IF	MULTI_BANK_BOARD = YES
    487  41a5				  -	      lda	BoardBank,x	; 4
    488  41a5				  -	      sta	RAM_Bank	; 3
    489  41a5					      ELSE
    490  41a5		       a9 0d		      lda	#BANK_BOARD	; 2
    491  41a7					      ENDIF
    492  41a7
    493  41a7		       20 e4 f8 	      jsr	GetBoardCharacter	;6+20(A)
    494  41aa
    495  41aa		       bd 7a fe 	      lda	CharToType,x	; 4
    496  41ad		       c9 02		      cmp	#TYPE_AMOEBA	; 2
    497  41af		       f0 03		      beq	.isAmoeba
    498  41b1		       4c 6a f2 	      jmp	.nextPos	; 2/3=61    All that work to see if square is an amoeba
    499  41b4
    500  41b4				   .isAmoeba
    501  41b4
    502  41b4		       a5 cb		      lda	amoebaY	; 3
    503  41b6		       85 90		      sta	POS_Y	; 3
    504  41b8		       a4 ca		      ldy	amoebaX	; 3
    505  41ba		       84 8f		      sty	POS_X	; 3 = 12
    506  41bc
    507  41bc		       24 cc		      bit	amoebaFlag	; 3	     TODIAMOND?
    508  41be		       10 2f		      bpl	normalOperate	; 2/3= 5/6
    509  41c0
    510  41c0		       a5 cd		      lda	amoebaCount	; 3
    511  41c2		       c9 c8		      cmp	#TOO_MUCH_AMOEBA	; 2
    512  41c4		       a2 04		      ldx	#CHARACTER_DIAMOND	; 2
    513  41c6		       90 02		      bcc	diam	; 2/3
    514  41c8		       a2 02		      ldx	#CHARACTER_BOULDER	; 2
    515  41ca				   diam 		;   = 10/11
    516  41ca							;amoebaToRocksOrDiamonds
    517  41ca
    518  41ca		       a5 bf		      lda	Board_AddressR	; 3
    519  41cc		       85 c1		      sta	Board_AddressW	; 3
    520  41ce		       a5 c0		      lda	Board_AddressR+1	; 3
    521  41d0		       09 04		      ora	#>RAM_WRITE	; 2
    522  41d2		       85 c2		      sta	Board_AddressW+1	; 3
    523  41d4
    524  41d4		       bd 7a fe 	      lda	CharToType,x	;	 X = boulder/diamond character shape
    525  41d7		       85 93		      sta	POS_Type
    526  41d9		       8a		      txa
    527  41da				  -	      IF	MULTI_BANK_BOARD = YES
    528  41da				  -	      ldx	RAM_Bank
    529  41da					      ELSE
    530  41da		       a2 0d		      ldx	#BANK_BOARD	; 2
    531  41dc					      ENDIF
    532  41dc		       20 ed f8 	      jsr	PutBoardCharacter	;29
    533  41df
    534  41df							; To reduce object count, and increase speed on conversion, only add objects if they have a blank around them.
    535  41df
    536  41df		       20 a8 f8 	      jsr	GetSurroundingChars	;6+161[-28](C)
    537  41e2
    538  41e2		       a5 83		      lda	Surround+1
    539  41e4		       25 84		      and	Surround+2
    540  41e6		       25 85		      and	Surround+3
    541  41e8		       d0 3a		      bne	.nextPosBne	; if NONE of the L/R or D squares are blank, then don't generate creature
    542  41ea
    543  41ea		       85 94		      sta	POS_VAR
    544  41ec		       f0 79		      beq	.insertObject	; 3	 unconditional
    545  41ee							;----------------------------------------------------------
    546  41ee				   ambRet
    547  41ee		       60		      rts
    548  41ef							;----------------------------------------------------------
    549  41ef				   normalOperate
    550  41ef		       e6 cd		      inc	amoebaCount
    551  41f1
    552  41f1		       20 a8 f8 	      jsr	GetSurroundingChars	;6+161[-28](C)
    553  41f4
    554  41f4							; if any of the UDLR are soil or blank, then amoeba is NOT enclosed
    555  41f4
    556  41f4		       a9 01		      lda	#CHARACTER_SOIL	; blank/soil ?
    557  41f6		       c5 82		      cmp	Surround
    558  41f8		       b0 0c		      bcs	notEnclosed
    559  41fa		       c5 83		      cmp	Surround+1
    560  41fc		       b0 08		      bcs	notEnclosed
    561  41fe		       c5 84		      cmp	Surround+2
    562  4200		       b0 04		      bcs	notEnclosed
    563  4202		       c5 85		      cmp	Surround+3
    564  4204		       90 64		      bcc	.nextPos	;	 enclosed
    565  4206
    566  4206		       a5 cc	   notEnclosed lda	amoebaFlag
    567  4208		       09 01		      ora	#NOT_ENCLOSED
    568  420a		       85 cc		      sta	amoebaFlag	; found a blank for amoeba (OR there are ghosts around) so it's OK to continue
    569  420c
    570  420c							; If the amoeba did not turn into a diamond or a boulder (in steps 1 or 2 above), it may or may not attempt to
    571  420c							; grow. A random number is generated to decide whether the amoeba will attempt grow: it has a 4/128 chance (about 3%)
    572  420c							; normally, or a 4/16 chance (25%) in some circumstances. If the decision is that the amoeba will atempt to grow,
    573  420c							; it randomly chooses one of the four directions to grow in. If that direction contains a space or dirt, the amoeba
    574  420c							; grows to fill that spot. The new amoeba just grown does not itself get the chance to grow until the next frame
    575  420c							; (ie the new amoeba is marked as "amoeba, scanned this frame")
    576  420c
      0  420c					      NEXT_RANDOM		; need it to change as we do multiple loops of amoeba per call
      1  420c
      2  420c		       a5 87		      lda	rnd
      3  420e		       4a		      lsr
      4  420f					      IFCONST	rndHi
      5  420f		       66 88		      ror	rndHi
      6  4211					      ENDIF
      7  4211		       90 02		      bcc	.skipEOR
      8  4213		       49 b4		      eor	#RND_EOR_VAL
      9  4215				   .skipEOR
     10  4215		       85 87		      sta	rnd
    578  4217		       c9 1d		      cmp	#SLOW_GROW
    579  4219		       45 88		      eor	rndHi	; to become independent from previous random value, due to the simplicity of the LFSR
    580  421b							; there is a bg chance of consecutive numbers becoming dependent
    581  421b							; @AD: remove it and you will see the "stuck" Amoeba
    582  421b		       90 09		      bcc	.growAmoeba	; slow things down -- only do the amoeba occasionally
    583  421d							; reenable if FAST_GROW becomes too fast
    584  421d		       c9 e9		      cmp	#FAST_GROW
    585  421f		       b0 49		      bcs	.nextPos
    586  4221				   .loopFastGrow
    587  4221		       a6 9d		      ldx	MagicAmoebaFlag
    588  4223		       e8		      inx		; AMOEBA_FAST_GROW?
    589  4224				   .nextPosBne
    590  4224		       d0 44		      bne	.nextPos	;  no
    591  4226				   .growAmoeba
    592  4226							; TJ: The original checks only ONCE. This slows down the grow rate of a large Amoeba, since the
    593  4226							; chance to select and occupied space become larger.
    594  4226							; NEW: ADs loop code, but only for fast grow
    595  4226
    596  4226							; we *know* at least one direction is blank.
    597  4226							; Choose circularly until we find one;
    598  4226
    599  4226							; neat bit of code, and yes it's correct.
    600  4226							; 1st time through we don't care about carry.	Thereafter it's set.
    601  4226
    602  4226		       69 00		      adc	#0
    603  4228		       29 03		      and	#3
    604  422a		       a8		      tay
    605  422b		       b6 82		      ldx	Surround,y
    606  422d		       e0 02		      cpx	#CHARACTER_SOIL+1	; allow only blank/soil for amoeba growth
    607  422f		       b0 f0		      bcs	.loopFastGrow
    608  4231							;		  bcs .nextPos
    609  4231
    610  4231							;clc
    611  4231		       a5 ca		      lda	amoebaX
    612  4233		       79 92 f3 	      adc	RDirX,y
    613  4236		       85 8f		      sta	POS_X
    614  4238
    615  4238							; Note: The scan box increases during the scan, more efficient would be to increase it afterwards
    616  4238							;  but that would require at least another byte and gain not that much speed.
    617  4238							; update scan box width:
    618  4238		       c5 ce		      cmp	amoebaMinX
    619  423a		       b0 02		      bcs	.skipNewMinX
    620  423c		       85 ce		      sta	amoebaMinX
    621  423e				   .skipNewMinX
    622  423e		       c5 d0		      cmp	amoebaMaxX
    623  4240		       90 03		      bcc	.skipNewMaxX
    624  4242		       85 d0		      sta	amoebaMaxX
    625  4244		       18		      clc
    626  4245				   .skipNewMaxX
    627  4245
    628  4245							;		  clc
    629  4245		       a5 cb		      lda	amoebaY
    630  4247		       79 91 f3 	      adc	RDirY,y
    631  424a		       85 90		      sta	POS_Y
    632  424c							; update scan box height:
    633  424c		       c5 cf		      cmp	amoebaMinY
    634  424e		       b0 02		      bcs	.skipNewMinY
    635  4250		       85 cf		      sta	amoebaMinY
    636  4252				   .skipNewMinY
    637  4252		       c5 d1		      cmp	amoebaMaxY
    638  4254		       90 02		      bcc	.skipNewMaxY
    639  4256		       85 d1		      sta	amoebaMaxY
    640  4258				   .skipNewMaxY
    641  4258
    642  4258							; Bypass object creation -- just write the amoeba character directly
    643  4258
    644  4258		       a4 90		      ldy	POS_Y
    645  425a		       20 0d f1 	      jsr	GetBoardAddressW	;6+24[-2]
    646  425d		       a4 8f		      ldy	POS_X
    647  425f		       a9 03		      lda	#CHARACTER_AMOEBA
    648  4261		       20 ed f8 	      jsr	PutBoardCharacter
    649  4264		       4c 6a f2 	      jmp	.nextPos
    650  4267
    651  4267				   .insertObject
    652  4267		       20 7c fb 	      jsr	InsertObjectStack	;6+76(B)
    653  426a
    654  426a				   .nextPos
    655  426a							; scan next column:
    656  426a		       c6 ca		      dec	amoebaX
    657  426c		       a6 ca		      ldx	amoebaX
    658  426e		       e4 ce		      cpx	amoebaMinX
    659  4270		       b0 3a		      bcs	.exit
    660  4272
    661  4272							; scan next row:
    662  4272		       a6 d0		      ldx	amoebaMaxX
    663  4274		       86 ca		      stx	amoebaX
    664  4276
    665  4276		       c6 cb		      dec	amoebaY
    666  4278		       a4 cb		      ldy	amoebaY
    667  427a		       c4 cf		      cpy	amoebaMinY
    668  427c		       b0 2e		      bcs	.exit
    669  427e
    670  427e							; start complete new boxed scan:
    671  427e		       a4 d1		      ldy	amoebaMaxY
    672  4280		       84 cb		      sty	amoebaY
    673  4282
    674  4282							; This happens at the completion of each board scan
    675  4282							; IF we're totally enclosed, OR we're too big, then the interesting stuff happens!
    676  4282
    677  4282		       a5 cc		      lda	amoebaFlag	;	 TODIAMOND?
    678  4284		       30 27		      bmi	.convertedToDiamonds
    679  4286
    680  4286		       a6 cd		      ldx	amoebaCount
    681  4288		       e0 c8		      cpx	#TOO_MUCH_AMOEBA
    682  428a		       b0 1c		      bcs	.tooMany
    683  428c
    684  428c		       4a		      lsr		;	  NOT_ENCLOSED?
    685  428d		       90 18		      bcc	.enclosed
    686  428f
    687  428f							; reset per-scan variables as we're starting a complete new scan at this point
    688  428f		       0a		      asl		; 2	 clears NOT_ENCLOSED bit
    689  4290		       09 02	   dontConvertIt ora	#SCAN_FINISHED	; 2	 indicate that we finshed last scan
    690  4292		       85 cc		      sta	amoebaFlag	; 3
    691  4294
    692  4294		       a9 00		      lda	#0	; 2	 has to be done here. Do NOT move!!!
    693  4296		       85 cd		      sta	amoebaCount	; 3
    694  4298							; (re)enable sound with each new scan (e.g. after being disabled by crack or time sound)
      0  4298					      START_SOUND	SOUND_AMOEBA
      1  4298					      SUBROUTINE
      2  4298		       a5 db		      lda	newSounds
      3  429a				  -	      IF	SOUND_AMOEBA < 16
      4  429a				  -	      and	#SND_MASK_LO
      5  429a				  -	      cmp	#SOUND_MOVE_SOIL+1
      6  429a				  -	      bcs	.skipNew
      7  429a					      ELSE
      8  429a		       29 f0		      and	#SND_MASK_HI
      9  429c		       c9 30		      cmp	#(SOUND_MOVE_SOIL+1)<<4
     10  429e		       b0 06		      bcs	.skipNew
     11  42a0
     12  42a0					      ENDIF
     13  42a0		       45 db		      eor	newSounds
     14  42a2		       09 30		      ora	#SOUND_AMOEBA
     15  42a4		       85 db		      sta	newSounds
     16  42a6				   .skipNew
     17  42a6					      SUBROUTINE
    696  42a6		       60		      rts
    697  42a7
    698  42a7							;-------------------------------------------------------------------------------
    699  42a7				   .enclosed
    700  42a7		       0a		      asl
    701  42a8				   .tooMany
    702  42a8							; enclosed or too many, so set todiamonds
    703  42a8		       09 80		      ora	#TODIAMOND
    704  42aa		       85 cc		      sta	amoebaFlag	;	 force "to boulder" or "to diamond"
    705  42ac				   .exit
    706  42ac				   Rts
    707  42ac		       60		      rts
    708  42ad
    709  42ad							;-------------------------------------------------------------------------------
    710  42ad							; the amoeba was converted in to either diamonds or boulders, so it dies here
    711  42ad				   .convertedToDiamonds
    712  42ad		       09 20		      ora	#FINISHEDDIAMOND
    713  42af		       85 cc		      sta	amoebaFlag
    714  42b1
      0  42b1					      STOP_SOUND	1, OFSS_AMOEBA
      1  42b1
      2  42b1		       a9 28		      lda	#OFSS_AMOEBA
      3  42b3		       45 d6		      eor	soundIdxLst+1
      4  42b5		       d0 04		      bne	.skipStop
      5  42b7		       85 d6		      sta	soundIdxLst+1
      6  42b9		       85 5a		      sta	AUDV0+1
      7  42bb				   .skipStop
    716  42bb		       60		      rts
    717  42bc
    718  42bc							;-------------------------------------------------------------------------------
    719  42bc
    720  42bc
    721  42bc				   OBJTYPE    SET	0
    722  42bc					      MAC	define_character
    723  42bc				   CHARACTER_{1} =	OBJTYPE
    724  42bc				   OBJTYPE    .SET	OBJTYPE + 1
    725  42bc					      ENDM
    726  42bc
    727  42bc							; Modifications to character #/order must also ensure the following are correct...
    728  42bc							;   CharacterDataVecLO[...]	     in BANK_FIXED.asm
    729  42bc							;   CharacterDataVecHI[...]	     in BANK_FIXED.asm
    730  42bc							;   GenericCharFlag[...]	     in BANK_FIXED.asm
    731  42bc							;   MoveVecLO[...]		     in BANK_INITBANK.asm
    732  42bc							;   MoveVecHI[...]		     in BANK_INITBANK.asm
    733  42bc							;   CharToType[...]		     in BANK_FIXED.asm
    734  42bc							;   CharToType2[...]		     in DecodeCave.asm
    735  42bc
      0  42bc					      DEFINE_CHARACTER	BLANK
      1  42bc		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	SOIL
      1  42bc		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	BOULDER
      1  42bc		       00 02	   CHARACTER_BOULDER =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	AMOEBA
      1  42bc		       00 03	   CHARACTER_AMOEBA =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	DIAMOND
      1  42bc		       00 04	   CHARACTER_DIAMOND =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	DIAMOND2
      1  42bc		       00 05	   CHARACTER_DIAMOND2 =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	MANOCCUPIED
      1  42bc		       00 06	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	FLUTTERBY
      1  42bc		       00 07	   CHARACTER_FLUTTERBY =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	FLUTTERBY2
      1  42bc		       00 08	   CHARACTER_FLUTTERBY2 =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	FIREFLY
      1  42bc		       00 09	   CHARACTER_FIREFLY =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	FIREFLY2
      1  42bc		       00 0a	   CHARACTER_FIREFLY2 =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	WALL0
      1  42bc		       00 0b	   CHARACTER_WALL0 =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	WALL1
      1  42bc		       00 0c	   CHARACTER_WALL1 =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	WALL2
      1  42bc		       00 0d	   CHARACTER_WALL2 =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	WALL3
      1  42bc		       00 0e	   CHARACTER_WALL3 =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	STEEL
      1  42bc		       00 0f	   CHARACTER_STEEL =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	WALL
      1  42bc		       00 10	   CHARACTER_WALL =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	EXITDOOR
      1  42bc		       00 11	   CHARACTER_EXITDOOR =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	EXITDOOR2
      1  42bc		       00 12	   CHARACTER_EXITDOOR2 =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	EXPLOSION
      1  42bc		       00 13	   CHARACTER_EXPLOSION =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	EXPLOSION1
      1  42bc		       00 14	   CHARACTER_EXPLOSION1 =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	EXPLOSION2
      1  42bc		       00 15	   CHARACTER_EXPLOSION2 =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	EXPLOSION3
      1  42bc		       00 16	   CHARACTER_EXPLOSION3 =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	AMOEBA2
      1  42bc		       00 17	   CHARACTER_AMOEBA2 =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	BOULDER_FALLING
      1  42bc		       00 18	   CHARACTER_BOULDER_FALLING =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	DIAMOND_FALLING
      1  42bc		       00 19	   CHARACTER_DIAMOND_FALLING =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
      0  42bc					      DEFINE_CHARACTER	NOGO
      1  42bc		       00 1a	   CHARACTER_NOGO =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
    763  42bc
      0  42bc					      DEFINE_CHARACTER	MAXIMUM
      1  42bc		       00 1b	   CHARACTER_MAXIMUM =	OBJTYPE
      2  42bc				   OBJTYPE    .SET	OBJTYPE + 1
    765  42bc
    766  42bc							;------------------------------------------------------------------------------
    767  42bc
      0  42bc					      DEFINE_SUBROUTINE	PushBoulder	; in INITBANK
      1  42bc		       00 08	   BANK_PushBoulder =	_CURRENT_BANK
      2  42bc					      SUBROUTINE
      3  42bc				   PushBoulder
    769  42bc
    770  42bc							; Note: FALLING boulders are not really boulders. They are falling boulders. They are a different
    771  42bc							; character type, so will not get to this code. So you can't push falling objects :)
    772  42bc
    773  42bc		       85 c3		      sta	ROM_Bank
    774  42be
    775  42be							; Determine if the boulder is pushable
    776  42be							; we use the joystick to calculate the subsequent square
    777  42be
    778  42be		       a5 95		      lda	BufferedJoystick
    779  42c0		       25 96		      and	BufferedJoystick+1
    780  42c2		       49 ff		      eor	#$FF
    781  42c4		       29 c0		      and	#%11000000	; right/left
    782  42c6		       f0 48		      beq	cannotPush2
    783  42c8		       0a		      asl
    784  42c9		       2a		      rol
    785  42ca		       2a		      rol
    786  42cb		       a8		      tay
    787  42cc
    788  42cc		       a5 91		      lda	POS_X_NEW
    789  42ce		       79 94 f3 	      adc	DirPushMod,y
    790  42d1		       48		      pha
    791  42d2		       a8		      tay
    792  42d3
    793  42d3				  -	      IF	MULTI_BANK_BOARD = YES
    794  42d3				  -	      lda	RAM_Bank
    795  42d3					      ELSE
    796  42d3		       a9 0d		      lda	#BANK_BOARD	; 2
    797  42d5					      ENDIF
    798  42d5		       20 e4 f8 	      jsr	GetBoardCharacter	;6+20(A)
    799  42d8		       c9 00		      cmp	#CHARACTER_BLANK
    800  42da		       d0 33		      bne	cannotPush
    801  42dc
    802  42dc		       68		      pla
    803  42dd		       a8		      tay
    804  42de
    805  42de		       e6 a9		      inc	ManPushCounter
    806  42e0		       a5 a9		      lda	ManPushCounter
    807  42e2		       49 06		      eor	#PUSH_LIMIT
    808  42e4		       d0 2a		      bne	cannotPush2	; nice 'get to 0' optimisation
    809  42e6		       85 a9		      sta	ManPushCounter
    810  42e8
    811  42e8
    812  42e8				  -	      IF	MULTI_BANK_BOARD = YES
    813  42e8				  -	      ldx	RAM_Bank
    814  42e8					      ELSE
    815  42e8		       a2 0d		      ldx	#BANK_BOARD	; 2
    816  42ea					      ENDIF
    817  42ea		       a9 02		      lda	#CHARACTER_BOULDER
    818  42ec		       20 ed f8 	      jsr	PutBoardCharacter	;6+21(A)
    819  42ef
    820  42ef		       a6 92		      ldx	POS_Y_NEW
    821  42f1		       86 90		      stx	POS_Y
    822  42f3		       a4 91		      ldy	POS_X_NEW
    823  42f5		       84 8f		      sty	POS_X
    824  42f7
    825  42f7		       20 03 fa 	      jsr	BlankOriginalLocationXY	;6+87[-2](A)	     and stacks newly blank position for checking -- also causing boulder to fall!
    826  42fa
      0  42fa					      START_SOUND	SOUND_BOULDER
      1  42fa					      SUBROUTINE
      2  42fa		       a5 db		      lda	newSounds
      3  42fc					      IF	SOUND_BOULDER < 16
      4  42fc		       29 0f		      and	#SND_MASK_LO
      5  42fe		       c9 03		      cmp	#SOUND_MOVE_SOIL+1
      6  4300		       b0 06		      bcs	.skipNew
      7  4302				  -	      ELSE
      8  4302				  -	      and	#SND_MASK_HI
      9  4302				  -	      cmp	#(SOUND_MOVE_SOIL+1)<<4
     10  4302				  -	      bcs	.skipNew
     11  4302				  -
     12  4302					      ENDIF
     13  4302		       45 db		      eor	newSounds
     14  4304		       09 03		      ora	#SOUND_BOULDER
     15  4306		       85 db		      sta	newSounds
     16  4308				   .skipNew
     17  4308					      SUBROUTINE
    828  4308
    829  4308		       a5 97		      lda	BufferedButton	; button pressed?
    830  430a		       10 04		      bpl	PushWithButton
    831  430c		       4c ae fb 	      jmp	MovePlayer	; now there's a gap, player should move in
    832  430f
    833  430f		       68	   cannotPush pla
    834  4310							;lda #0
    835  4310							;sta ManPushCounter
    836  4310				   PushWithButton
    837  4310				   cannotPush2
    838  4310				   timeout
    839  4310		       60		      rts
    840  4311
    841  4311				   Bango
    842  4311		       20 44 f6 	      jsr	BigBang	;6+1732[-58](B)
    843  4314		       90 fa		      bcc	timeout	;2/3
    844  4316
    845  4316		       4c 52 fb 	      jmp	NextObject	;??? >-- should be OK. Creature dies.
    846  4319
    847  4319							;------------------------------------------------------------------------------
    848  4319
      0  4319					      DEFINE_SUBROUTINE	PROCESS_FLUTTERBY	;=521[-32](B) if moving worst case
      1  4319		       00 08	   BANK_PROCESS_FLUTTERBY =	_CURRENT_BANK
      2  4319					      SUBROUTINE
      3  4319				   PROCESS_FLUTTERBY
      0  4319					      DEFINE_SUBROUTINE	PROCESS_FIREFLY
      1  4319		       00 08	   BANK_PROCESS_FIREFLY =	_CURRENT_BANK
      2  4319					      SUBROUTINE
      3  4319				   PROCESS_FIREFLY
    851  4319
    852  4319		       ad 84 02 	      lda	INTIM	;4
    853  431c		       c9 0a		      cmp	#SEGTIME_BUTTERFLY	;2
    854  431e		       90 f0		      bcc	timeout	;2/3
      0  4320					      STRESS_TIME	SEGTIME_BUTTERFLY
      1  4320				  -	      IF	TEST_SEGTIME_BUTTERFLY = 1
      2  4320				  -
      3  4320				  -
      4  4320				  -
      5  4320				  -
      6  4320				  -
      7  4320				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  4320				  -	      bne	. - 7
      9  4320					      ENDIF
    856  4320
    857  4320
    858  4320							; The butterfly and firefly are wall-huggers.
    859  4320							; Algorithm:  current direction (0-3) encoded in POS_VAR.  +8 for fireflies.
    860  4320							; Butterfly: Try to turn right (direction++&3). Now try to move forward.
    861  4320							; If no move, then repeat above for all directions.
    862  4320							; Firefly: same as above, but turning anti-clockwise.
    863  4320
    864  4320		       20 a8 f8 	      jsr	GetSurroundingChars	;6+161[-28](C) (return BANK is OK)
    865  4323
    866  4323							; Check surrounding squares for proximity to anything that causes butterfly/firefly
    867  4323							; to explode.	These include man, amoeba.
    868  4323
    869  4323							;		  ldx Surround			  ;3
    870  4323		       bd 3d fe 	      lda	GenericCharFlag,x	;4
    871  4326		       a6 83		      ldx	Surround+1	;3
    872  4328		       1d 3d fe 	      ora	GenericCharFlag,x	;4
    873  432b		       a6 84		      ldx	Surround+2	;3
    874  432d		       1d 3d fe 	      ora	GenericCharFlag,x	;4
    875  4330		       a6 85		      ldx	Surround+3	;3
    876  4332		       1d 3d fe 	      ora	GenericCharFlag,x	;4 = 25
    877  4335
    878  4335							;TODO: here we could check if we've hit the man (via GenericCharFlag) and trigger a manual kill
    879  4335							; so even if the man doesn't check the squares he DOES know he's dead.
    880  4335
    881  4335		       29 10		      and	#GENERIC_MASK_KILLSBUTTERFLY	;2
    882  4337		       d0 d8		      bne	Bango	;2/3		    (-> 206@Bango)
    883  4339
    884  4339							; If the butterfly/firefly board character is not the object's type -- something must have
    885  4339							; happened (eg: boulder/diamond falling, man moving) and so the object should die.
    886  4339
    887  4339		       a6 86		      ldx	Surround+4	;3	current position
    888  433b		       bd 7a fe 	      lda	CharToType,x	;4
    889  433e		       c5 93		      cmp	POS_Type	;3
    890  4340		       d0 cf		      bne	Bango	;2/3
    891  4342
    892  4342		       a4 94		      ldy	POS_VAR	;3	Current movement direction
    893  4344		       b9 98 f3 	      lda	Directional,y	;4
    894  4347		       aa		      tax		;2
    895  4348		       29 03		      and	#3	;2
    896  434a		       a8		      tay		;2
    897  434b		       b9 82 00 	      lda	Surround,y	;4
    898  434e		       f0 14		      beq	MoveThatWay	;2/(3+277[-4](B))
    899  4350
    900  4350							; Failed to turn, try to go straight ahead
    901  4350
    902  4350		       a5 94		      lda	POS_VAR	;3
    903  4352		       29 03		      and	#3	;2
    904  4354		       a8		      tay		;2
    905  4355		       b9 82 00 	      lda	Surround,y	;4
    906  4358		       f0 0c		      beq	MoveThatWayStraight	;2/(3+274[-4](B))
    907  435a
    908  435a							; turn LEFT, as we can't turn right or go straight ahead
    909  435a
    910  435a		       a4 94		      ldy	POS_VAR	;3
    911  435c		       b9 9a f3 	      lda	Directional+2,y	;4
    912  435f		       85 94		      sta	POS_VAR	;3
    913  4361		       4c 4f fb 	      jmp	ReInsertObject	;3+98(B)	 (animation now happens automatically)
    914  4364
    915  4364							;------------------------------------------------------------------------------
    916  4364				   MoveThatWay		;=276[-4](B)
    917  4364
    918  4364		       86 94		      stx	POS_VAR	;3
    919  4366
    920  4366				   MoveThatWayStraight		;=273[-4](B)
    921  4366
    922  4366		       20 ff f9 	      jsr	BlankOriginalLocation	;6+93[-2](A)
    923  4369
    924  4369		       a5 94		      lda	POS_VAR	;3
    925  436b		       29 03		      and	#3	;2
    926  436d		       aa		      tax		;2
    927  436e
    928  436e		       18		      clc		;2
    929  436f		       a5 90		      lda	POS_Y	;3
    930  4371		       7d 91 f3 	      adc	RDirY,x	;4
    931  4374		       85 90		      sta	POS_Y	;3
    932  4376
    933  4376		       a8		      tay		;2
    934  4377
    935  4377		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    936  437a		       85 c1		      sta	Board_AddressW	;3
    937  437c		       b9 2d f0 	      lda	BoardLineStartHiW,y	;4
    938  437f		       85 c2		      sta	Board_AddressW+1	;3		 WRITE address
    939  4381
    940  4381		       18		      clc		;2
    941  4382		       a5 8f		      lda	POS_X	;3
    942  4384		       7d 92 f3 	      adc	RDirX,x	;4
    943  4387		       85 8f		      sta	POS_X	;3
    944  4389
    945  4389				  -	      IF	MULTI_BANK_BOARD = YES
    946  4389				  -	      ldx	BoardBank,y	;4		 switch this on return
    947  4389					      ELSE
    948  4389		       a2 0d		      ldx	#BANK_BOARD	;2
    949  438b					      ENDIF
    950  438b		       a8		      tay		;2		 a == POS_X
    951  438c		       a5 86		      lda	Surround+4	;3
    952  438e		       4c f6 f8 	      jmp	PutBoardCharacterButterfly	;3+110[-2](B)
    953  4391
    954  4391
    955  4391							;------------------------------------------------------------------------------
    956  4391
    957  4391							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    958  4391							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    959  4391
    960  4391							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    961  4391
    962  4391							; if the creature dies then jump NextObject
    963  4391
    964  4391
    965  4391
    966  4391		       ff	   RDirY      .byte.b	-1	;,0,1,0
    967  4392		       00 01	   RDirX      .byte.b	0,1	;,0,-1
    968  4394		       00 ff 01 00 DirPushMod .byte.b	0,-1,1,0
    969  4398		       01 02 03 00*Directional .byte.b	1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    970  43a6
    971  43a6
    972  43a6							;------------------------------------------------------------------------------
    973  43a6
    974  43a6							; Thomas, the auto-calculation of these was causing DASM to get confused and abort assembling.
    975  43a6							; I don't particularly know why; probably because of the cave variable-size array and the values
    976  43a6							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    977  43a6
    978  43a6		       00 00	   MANMODE_STARTUP =	0
    979  43a6		       00 01	   MANMODE_NORMAL =	1
    980  43a6		       00 02	   MANMODE_DEAD =	2
    981  43a6		       00 03	   MANMODE_WAITING =	3
    982  43a6		       00 04	   MANMODE_WAITING2 =	4
    983  43a6		       00 05	   MANMODE_WAITING_NT =	5
    984  43a6		       00 06	   MANMODE_WAITING_NT2 =	6
    985  43a6		       00 07	   MANMODE_NEXTLEVEL =	7
    986  43a6		       00 08	   MANMODE_BONUS_START =	8
    987  43a6		       00 09	   MANMODE_BONUS_RUN =	9
    988  43a6
      0  43a6					      DEFINE_SUBROUTINE	ManProcess	; in INITBANK
      1  43a6		       00 08	   BANK_ManProcess =	_CURRENT_BANK
      2  43a6					      SUBROUTINE
      3  43a6				   ManProcess
    990  43a6
    991  43a6		       a9 ff		      lda	#$FF
    992  43a8		       85 dc		      sta	specialTimeFlag	; detects time overflow in bigbang (and diamond grab)
    993  43aa
    994  43aa
    995  43aa							; ManMode tells the player what it is currently doing.  State machine.
    996  43aa
    997  43aa		       ad 82 02 	      lda	SWCHB
    998  43ad		       29 03		      and	#3
    999  43af		       d0 03		      bne	.skipReset	; BOTH select/reset = restart
   1000  43b1
   1001  43b1							;		  lsr SWCHB
   1002  43b1							;		  bcs .skipReset
   1003  43b1
   1004  43b1				  -	      IF	F1F2NEXTCAVE=YES
   1005  43b1				  -	      lda	#MANMODE_NEXTLEVEL
   1006  43b1				  -	      sta	ManMode
   1007  43b1					      ELSE
   1008  43b1		       4c eb fc 	      jmp	Restart	; RESET = end game, jump to title screen
   1009  43b4					      ENDIF
   1010  43b4
   1011  43b4				   .skipReset
   1012  43b4
   1013  43b4		       a4 a3		      ldy	ManMode
   1014  43b6		       b9 cd f3 	      lda	ManActionTimer,y
   1015  43b9		       f0 03		      beq	.skipTimer
   1016  43bb		       20 eb f3 	      jsr	UpdateTimer
   1017  43be				   .skipTimer
   1018  43be		       a4 a3		      ldy	ManMode
   1019  43c0		       b9 d7 f3 	      lda	ManActionLO,y
   1020  43c3		       85 df		      sta	actionVector
   1021  43c5		       b9 e1 f3 	      lda	ManActionHI,y
   1022  43c8		       85 e0		      sta	actionVector+1
   1023  43ca		       6c df 00 	      jmp	(actionVector)
   1024  43cd
   1025  43cd				   ManActionTimer
   1026  43cd		       00		      .byte.b	0	;<manStartup		 ; 0		 no timer
   1027  43ce		       01		      .byte.b	1	;<normalMan		 ; 1		 timer
   1028  43cf		       01		      .byte.b	1	;<deadMan		 ; 2		 timer
   1029  43d0		       01		      .byte.b	1	;<waitingMan		 ; 3		 timer
   1030  43d1		       01		      .byte.b	1	;<waitingManPress	 ; 4		 timer
   1031  43d2		       00		      .byte.b	0	;<waitingManNoTim	 ; 5		 no timer
   1032  43d3		       00		      .byte.b	0	;<waitingManPressNoTim  ; 6		 no timer
   1033  43d4		       00		      .byte.b	0	;<nextLevelMan 	 ; 7		 no timer
   1034  43d5		       02		      .byte.b	2	;<BonusCountdownStart	 ; 8		 fast timer
   1035  43d6		       02		      .byte.b	2	;<BonusCountdownRun	 ; 9		 fast timer
   1036  43d7				   ManActionLO
   1037  43d7		       70		      .byte.b	<manStartup	; 0		 no timer
   1038  43d8		       12		      .byte.b	<normalMan	; 1		 timer
   1039  43d9		       3b		      .byte.b	<deadMan	; 2		 timer
   1040  43da		       b6		      .byte.b	<waitingMan	; 3		 timer
   1041  43db		       d9		      .byte.b	<waitingManPress	; 4		 timer
   1042  43dc		       b6		      .byte.b	<waitingMan	; 5		 no timer
   1043  43dd		       d9		      .byte.b	<waitingManPress	; 6		 no timer
   1044  43de		       06		      .byte.b	<nextLevelMan	; 7		 no timer
   1045  43df		       50		      .byte.b	<BonusCountdownStart	; 8		 fast timer
   1046  43e0		       6d		      .byte.b	<BonusCountdownRun	; 9		 fast timer
   1047  43e1
   1048  43e1				   ManActionHI
   1049  43e1		       f4		      .byte.b	>manStartup	; no timer
   1050  43e2		       f5		      .byte.b	>normalMan	; timer
   1051  43e3		       f5		      .byte.b	>deadMan	; timer
   1052  43e4		       f4		      .byte.b	>waitingMan	; timer
   1053  43e5		       f4		      .byte.b	>waitingManPress	; timer
   1054  43e6		       f4		      .byte.b	>waitingMan	; no timer
   1055  43e7		       f4		      .byte.b	>waitingManPress	; no timer
   1056  43e8		       ff		      .byte.b	>nextLevelMan	; no timer
   1057  43e9		       f5		      .byte.b	>BonusCountdownStart	; fast timer
   1058  43ea		       f5		      .byte.b	>BonusCountdownRun	; fast timer
   1059  43eb
   1060  43eb							;------------------------------------------------------------------------------
      0  43eb					      DEFINE_SUBROUTINE	UpdateTimer
      1  43eb		       00 08	   BANK_UpdateTimer =	_CURRENT_BANK
      2  43eb					      SUBROUTINE
      3  43eb				   UpdateTimer
   1062  43eb
   1063  43eb		       a2 03		      ldx	#3
   1064  43ed		       a5 a3		      lda	ManMode
   1065  43ef		       c9 09		      cmp	#MANMODE_BONUS_RUN
   1066  43f1		       f0 20		      beq	.setLoops
   1067  43f3
   1068  43f3		       a2 04		      ldx	#NUM_LEVELS-1	; intermissions run at full speed
   1069  43f5		       24 b2		      bit	caveDisplay
   1070  43f7		       30 02		      bmi	.intermission2
   1071  43f9		       a6 b1		      ldx	level
   1072  43fb				   .intermission2
   1073  43fb		       bd 6b f4 	      lda	TimeFracTbl,x
   1074  43fe		       24 aa		      bit	LookingAround
   1075  4400		       10 02		      bpl	notSlowTime
   1076  4402		       a9 00		      lda	#0	; new behaviour: time does not count down when looking around
   1077  4404							;lsr				  ; go half-speed time countdown when looking around
   1078  4404				   notSlowTime
   1079  4404		       65 bb		      adc	caveTimeFrac
   1080  4406		       85 bb		      sta	caveTimeFrac
   1081  4408		       90 56		      bcc	.forceTimeDraw
   1082  440a
   1083  440a							; count down magic wall time in sync with cave time:
   1084  440a		       a6 9d		      ldx	MagicAmoebaFlag
   1085  440c		       e8		      inx		; $FF = dormant?
   1086  440d		       f0 02		      beq	.notActive
   1087  440f		       c6 9d		      dec	MagicAmoebaFlag
   1088  4411				   .notActive
   1089  4411		       a2 01		      ldx	#1
   1090  4413				   .setLoops
   1091  4413		       86 e0		      stx	timerLoops
   1092  4415		       d0 08		      bne	.notScoring
   1093  4417				   .loopTimer
   1094  4417		       a5 b1		      lda	level	; each second left adds 'level' to score
   1095  4419		       18		      clc
   1096  441a		       69 01		      adc	#1
   1097  441c		       20 fa fe 	      jsr	ScoreAdd
   1098  441f				   .notScoring
   1099  441f		       f8		      sed
   1100  4420		       38		      sec
   1101  4421		       a5 b9		      lda	caveTime
   1102  4423		       e9 01		      sbc	#1
   1103  4425		       85 b9		      sta	caveTime
   1104  4427		       d8		      cld
   1105  4428		       b0 02		      bcs	.skipHi2a
   1106  442a		       c6 ba		      dec	caveTimeHi
   1107  442c				   .skipHi2a
   1108  442c							; check for running out of time sound:
   1109  442c		       a5 ba		      lda	caveTimeHi
   1110  442e		       d0 35		      bne	.timeAbove9
   1111  4430		       a9 09		      lda	#$09
   1112  4432		       38		      sec
   1113  4433		       e5 b9		      sbc	caveTime
   1114  4435		       90 2e		      bcc	.timeAbove9
   1115  4437							; this assumes that SND_MASK_HI = %11110000
   1116  4437							;  and the time entries are ordered 9 to 0!
   1117  4437		       0a		      asl
   1118  4438		       0a		      asl
   1119  4439		       0a		      asl
   1120  443a		       0a		      asl
   1121  443b		       69 60		      adc	#SOUND_TIME_9
   1122  443d		       85 df		      sta	tmpSound
   1123  443f		       a5 db		      lda	newSounds
   1124  4441		       29 0f		      and	#<(~SND_MASK_HI)
   1125  4443		       05 df		      ora	tmpSound
   1126  4445		       85 db		      sta	newSounds
   1127  4447				   .skipTimeSound
   1128  4447		       a6 b9		      ldx	caveTime
   1129  4449		       d0 15		      bne	.timeNotZero
   1130  444b		       86 59		      stx	AUDV0	; stop bonus sound
   1131  444d		       86 d5		      stx	soundIdxLst
   1132  444f				   .contChannel1
   1133  444f		       a2 07		      ldx	#MANMODE_NEXTLEVEL	; time bonus
   1134  4451		       a5 a3		      lda	ManMode
   1135  4453		       c9 09		      cmp	#MANMODE_BONUS_RUN
   1136  4455		       f0 07		      beq	.nextLevel
   1137  4457		       a2 06		      ldx	#MANMODE_WAITING_NT2	; time over
   1138  4459		       c9 04		      cmp	#MANMODE_WAITING2	; Man already dead?
   1139  445b		       f0 01		      beq	.nextLevel
   1140  445d		       ca		      dex		; == MANMODE_WAITING_NT
   1141  445e				   .nextLevel
   1142  445e		       86 a3		      stx	ManMode	; -> man dies, but no explosion
   1143  4460				   .timeNotZero
   1144  4460				   .forceTimeDraw
   1145  4460		       a9 09		      lda	#BANK_SCORING
   1146  4462		       4c cd f8 	      jmp	DrawTimeFromROM	; Z-flag == 0!
   1147  4465
   1148  4465				   .timeAbove9
   1149  4465		       c6 e0		      dec	timerLoops
   1150  4467		       d0 ae		      bne	.loopTimer
   1151  4469		       f0 f5		      beq	.forceTimeDraw
   1152  446b
   1153  446b				   TimeFracTbl
   1154  446b		       1f		      .byte.b	31	; level 1, NTSC/PAL
   1155  446c		       1b		      .byte.b	27	; level 2, NTSC/PAL
   1156  446d		       18		      .byte.b	24	; level 3, NTSC/PAL
   1157  446e		       17		      .byte.b	23	; level 4, NTSC/PAL
   1158  446f		       16		      .byte.b	22	; level 5, NTSC/PAL
   1159  4470							; calculate: level 5 throttle * level 5 time / level x throttle
   1160  4470
   1161  4470
   1162  4470							;------------------------------------------------------------------------------
      0  4470					      DEFINE_SUBROUTINE	manStartup
      1  4470		       00 08	   BANK_manStartup =	_CURRENT_BANK
      2  4470					      SUBROUTINE
      3  4470				   manStartup
   1164  4470
   1165  4470		       a5 9f		      lda	ManX
   1166  4472		       85 91		      sta	POS_X_NEW	;NewX
   1167  4474		       85 8f		      sta	POS_X
   1168  4476		       a5 a0		      lda	ManY
   1169  4478		       85 92		      sta	POS_Y_NEW	;NewY
   1170  447a		       85 90		      sta	POS_Y
   1171  447c
   1172  447c		       e6 94		      inc	POS_VAR
   1173  447e		       a6 94		      ldx	POS_VAR	; animation index
   1174  4480		       bd a2 f4 	      lda	.RockfordStartup-1,x
   1175  4483		       30 1b		      bmi	CreateRockford
   1176  4485		       85 93		      sta	POS_Type
   1177  4487
   1178  4487							; check for start of "crack" sound:
   1179  4487		       c9 16		      cmp	#CHARACTER_EXPLOSION3	; first explosion frame?
   1180  4489		       d0 0e		      bne	.skipCrack1
      0  448b					      START_SOUND	SOUND_CRACK	;  yes, start "crack" sound
      1  448b					      SUBROUTINE
      2  448b		       a5 db		      lda	newSounds
      3  448d				  -	      IF	SOUND_CRACK < 16
      4  448d				  -	      and	#SND_MASK_LO
      5  448d				  -	      cmp	#SOUND_MOVE_SOIL+1
      6  448d				  -	      bcs	.skipNew
      7  448d					      ELSE
      8  448d		       29 f0		      and	#SND_MASK_HI
      9  448f		       c9 30		      cmp	#(SOUND_MOVE_SOIL+1)<<4
     10  4491		       b0 06		      bcs	.skipNew
     11  4493
     12  4493					      ENDIF
     13  4493		       45 db		      eor	newSounds
     14  4495		       09 50		      ora	#SOUND_CRACK
     15  4497		       85 db		      sta	newSounds
     16  4499				   .skipNew
     17  4499					      SUBROUTINE
   1182  4499				   .skipCrack1
   1183  4499		       a9 ff		      lda	#$FF
   1184  449b		       85 a4		      sta	ManDelayCount	; anything, just non-0
   1185  449d
   1186  449d		       4c 11 f9 	      jmp	PutBoardCharacterFromRAM	;70 --> switches this bank out but who cares!
   1187  44a0
   1188  44a0				   CreateRockford
   1189  44a0		       e6 a3		      inc	ManMode	; --> MANMODE_NORMAL
   1190  44a2				   RTS_CF
   1191  44a2		       60		      rts
   1192  44a3
   1193  44a3				   .RockfordStartup
   1194  44a3							;    .byte CHARACTER_NOGO
   1195  44a3							;    .byte CHARACTER_NOGO
   1196  44a3		       0f		      .byte.b	CHARACTER_STEEL
   1197  44a4		       0f		      .byte.b	CHARACTER_STEEL
   1198  44a5		       1a		      .byte.b	CHARACTER_NOGO
   1199  44a6		       0f		      .byte.b	CHARACTER_STEEL
   1200  44a7		       1a		      .byte.b	CHARACTER_NOGO
   1201  44a8		       0f		      .byte.b	CHARACTER_STEEL
   1202  44a9		       1a		      .byte.b	CHARACTER_NOGO
   1203  44aa		       0f		      .byte.b	CHARACTER_STEEL
   1204  44ab		       1a		      .byte.b	CHARACTER_NOGO
   1205  44ac		       0f		      .byte.b	CHARACTER_STEEL
   1206  44ad		       1a		      .byte.b	CHARACTER_NOGO
   1207  44ae		       0f		      .byte.b	CHARACTER_STEEL
   1208  44af		       1a		      .byte.b	CHARACTER_NOGO
   1209  44b0		       0f		      .byte.b	CHARACTER_STEEL
   1210  44b1							;.byte CHARACTER_NOGO
   1211  44b1		       16		      .byte.b	CHARACTER_EXPLOSION3
   1212  44b2							;.byte CHARACTER_EXPLOSION
   1213  44b2		       15		      .byte.b	CHARACTER_EXPLOSION2
   1214  44b3		       14		      .byte.b	CHARACTER_EXPLOSION1
   1215  44b4		       06		      .byte.b	CHARACTER_MANOCCUPIED
   1216  44b5		       ff		      .byte.b	-1
   1217  44b6
   1218  44b6							;------------------------------------------------------------------------------
   1219  44b6
   1220  44b6		       c6 a4	   waitingMan dec	ManDelayCount
   1221  44b8
   1222  44b8		       a9 00		      lda	#0
   1223  44ba		       85 aa		      sta	LookingAround
   1224  44bc		       85 af		      sta	BGColour
   1225  44be
   1226  44be							; Wait for button to be RELEASED first!
   1227  44be
   1228  44be		       a5 97		      lda	BufferedButton
   1229  44c0		       10 4f		      bpl	noChange
   1230  44c2		       e6 a3		      inc	ManMode
   1231  44c4
   1232  44c4							; Man loses a life and re-starts level if lives available
   1233  44c4							; Special-case: Bonus levels go to next level.
   1234  44c4
   1235  44c4		       a5 b2		      lda	caveDisplay
   1236  44c6		       30 0d		      bmi	intermission	; don't lose a life on intermission screens
   1237  44c8					      IF	NUM_LIVES != -1
   1238  44c8		       c6 ab		      dec	MenCurrent	; works for P1P2 format
   1239  44ca							; display lives after a live is lost
   1240  44ca		       a5 c8		      lda	scoringFlags	;
   1241  44cc		       29 fc		      and	#~DISPLAY_FLAGS
   1242  44ce		       09 02		      ora	#DISPLAY_LIVES
   1243  44d0		       85 c8		      sta	scoringFlags	;
   1244  44d2					      ENDIF
   1245  44d2		       20 62 ff 	      jsr	goGeneralScoringSetups	; update the life display. Roundabout way of doing it.
   1246  44d5				   intermission
   1247  44d5
   1248  44d5		       a9 78		      lda	#120	; something long.  anything.
   1249  44d7		       85 c7		      sta	scoringTimer	; first time through we wait on the current display
   1250  44d9
   1251  44d9				   waitingManPress
   1252  44d9
   1253  44d9							; Cycle the score display, player display, level display based on timing
   1254  44d9							; see "Scoring timer" reset stomp comment in bank_generic.
   1255  44d9
   1256  44d9		       a5 c7		      lda	scoringTimer
   1257  44db		       c9 0a		      cmp	#10	; non-zero so we don't get stomped on by the scoring reset in
   1258  44dd		       b0 19		      bcs	stillKicking
   1259  44df		       a9 5a		      lda	#90	; something long.  anything.
   1260  44e1		       85 c7		      sta	scoringTimer
   1261  44e3
   1262  44e3		       a5 ab		      lda	MenCurrent
   1263  44e5		       29 0f		      and	#$0f
   1264  44e7		       c9 01		      cmp	#$01
   1265  44e9		       a6 c8		      ldx	scoringFlags
   1266  44eb		       e8		      inx
   1267  44ec		       8a		      txa
   1268  44ed							; if game over for current player, display diamonds/time, score, player/lives/cave and high score
   1269  44ed		       29 f3		      and	#$f3
   1270  44ef		       90 02		      bcc	gameOver
   1271  44f1							; else display diamonds/time and score only
   1272  44f1		       29 f1		      and	#$f1
   1273  44f3		       85 c8	   gameOver   sta	scoringFlags	;
   1274  44f5
   1275  44f5		       20 62 ff 	      jsr	goGeneralScoringSetups	; update the score display.
   1276  44f8
   1277  44f8				   stillKicking
   1278  44f8
   1279  44f8		       a5 97		      lda	BufferedButton	; button pressed?
   1280  44fa		       30 15		      bmi	noChange
   1281  44fc
      0  44fc					      STOP_CHANNEL	1	; stop all long running sounds
      1  44fc
      2  44fc		       a9 00		      lda	#0
      3  44fe		       85 d6		      sta	soundIdxLst+1
      4  4500		       85 5a		      sta	AUDV0+1
   1283  4502
   1284  4502							; If it's a bonus level, even though we've died... we go to the next cave
   1285  4502
   1286  4502		       a5 b2		      lda	caveDisplay
   1287  4504		       10 05		      bpl	nonextlevel
   1288  4506		       a2 07		      ldx	#MANMODE_NEXTLEVEL
   1289  4508		       86 a3		      stx	ManMode
   1290  450a		       60		      rts
   1291  450b
   1292  450b
   1293  450b		       a5 c9	   nonextlevel lda	NextLevelTrigger
   1294  450d		       09 40		      ora	#BIT_NEXTLIFE
   1295  450f		       85 c9		      sta	NextLevelTrigger
   1296  4511
   1297  4511		       60	   noChange   rts
   1298  4512
   1299  4512							;------------------------------------------------------------------------------
   1300  4512							; Normal man state
   1301  4512
   1302  4512
   1303  4512				   normalMan
   1304  4512
   1305  4512							; Timer is still running, so we see if the player is to die for any reason
   1306  4512
   1307  4512		       24 ac		      bit	demoMode
   1308  4514		       30 09		      bmi	stayAlive
   1309  4516							; SELECT pressed?
   1310  4516		       ad 82 02 	      lda	SWCHB
   1311  4519		       49 ff		      eor	#$FF
   1312  451b		       29 03		      and	#3
   1313  451d		       d0 1a		      bne	Time0	; EITHER select or reset are pressed
   1314  451f							;		  lsr
   1315  451f							;		  lsr
   1316  451f							;		  bcc Time0			  ; suicide!
   1317  451f				   stayAlive
   1318  451f
   1319  451f							;------------------------------------------------------------------------------
   1320  451f
   1321  451f		       a6 a0		      ldx	ManY
   1322  4521		       a4 9f		      ldy	ManX
   1323  4523
   1324  4523		       bd 01 f0 	      lda	BoardLineStartLO,x
   1325  4526		       85 bf		      sta	Board_AddressR
   1326  4528		       bd 17 f0 	      lda	BoardLineStartHiR,x
   1327  452b		       85 c0		      sta	Board_AddressR+1
   1328  452d
   1329  452d				  -	      IF	MULTI_BANK_BOARD = YES
   1330  452d				  -	      lda	BoardBank,x	;4
   1331  452d				  -	      sta	RAM_Bank	;3
   1332  452d					      ELSE
   1333  452d		       a9 0d		      lda	#BANK_BOARD	;2
   1334  452f					      ENDIF
   1335  452f		       20 e4 f8 	      jsr	GetBoardCharacter	;6+20(A)
   1336  4532
   1337  4532		       bd 7a fe 	      lda	CharToType,x
   1338  4535		       c9 00		      cmp	#TYPE_MAN
   1339  4537		       f0 55		      beq	PlayerAlive
   1340  4539
   1341  4539							; character he's on isn't a MAN character, so he dies...
   1342  4539
   1343  4539				   Time0
   1344  4539
   1345  4539		       e6 a3		      inc	ManMode	; #1 -- player dead!
   1346  453b
   1347  453b
   1348  453b							; the dead man creates an explosion...
   1349  453b							; note, if we get a segtime problem, this code will re-execute OK
   1350  453b
   1351  453b		       a5 9f	   deadMan    lda	ManX
   1352  453d		       85 8f		      sta	POS_X
   1353  453f		       a5 a0		      lda	ManY
   1354  4541		       85 90		      sta	POS_Y
   1355  4543
   1356  4543		       20 65 f5 	      jsr	BlankPlayerFrame
   1357  4546
   1358  4546		       20 44 f6 	      jsr	BigBang
   1359  4549		       66 dc		      ror	specialTimeFlag
   1360  454b		       10 02		      bpl	timeTooShortToDie	; wait until next time around
   1361  454d
   1362  454d							; and becomes a man waiting for resurrection...
   1363  454d
   1364  454d		       e6 a3		      inc	ManMode
   1365  454f
   1366  454f				   timeTooShortToDie
   1367  454f		       60		      rts
   1368  4550
   1369  4550							;------------------------------------------------------------------------------
      0  4550					      DEFINE_SUBROUTINE	BonusCountdownStart
      1  4550		       00 08	   BANK_BonusCountdownStart =	_CURRENT_BANK
      2  4550					      SUBROUTINE
      3  4550				   BonusCountdownStart
   1371  4550		       e6 a3		      inc	ManMode	; waiting for countdown to complete
   1372  4552
      0  4552					      START_SOUND	SOUND_BONUS_POINTS	; one-off trigger of bonus countdown sound
      1  4552					      SUBROUTINE
      2  4552		       a5 db		      lda	newSounds
      3  4554					      IF	SOUND_BONUS_POINTS < 16
      4  4554		       29 0f		      and	#SND_MASK_LO
      5  4556		       c9 03		      cmp	#SOUND_MOVE_SOIL+1
      6  4558		       b0 06		      bcs	.skipNew
      7  455a				  -	      ELSE
      8  455a				  -	      and	#SND_MASK_HI
      9  455a				  -	      cmp	#(SOUND_MOVE_SOIL+1)<<4
     10  455a				  -	      bcs	.skipNew
     11  455a				  -
     12  455a					      ENDIF
     13  455a		       45 db		      eor	newSounds
     14  455c		       09 07		      ora	#SOUND_BONUS_POINTS
     15  455e		       85 db		      sta	newSounds
     16  4560				   .skipNew
     17  4560					      SUBROUTINE
   1374  4560
   1375  4560		       a9 00		      lda	#AnimateSTAND-Manimate
   1376  4562		       85 a5		      sta	ManAnimation
   1377  4564							;lda #>AnimateSTAND
   1378  4564							;sta ManAnimation+1
   1379  4564
   1380  4564
   1381  4564		       60		      rts
   1382  4565
   1383  4565							;------------------------------------------------------------------------------
   1384  4565
      0  4565					      DEFINE_SUBROUTINE	BlankPlayerFrame
      1  4565		       00 08	   BANK_BlankPlayerFrame =	_CURRENT_BANK
      2  4565					      SUBROUTINE
      3  4565				   BlankPlayerFrame
   1386  4565
   1387  4565		       a9 2c		      lda	#AnimateBLANK-Manimate
   1388  4567		       85 a5		      sta	ManAnimation
   1389  4569							;lda #>AnimateBLANK
   1390  4569							;sta ManAnimation+1
   1391  4569		       a9 00		      lda	#0
   1392  456b		       85 a4		      sta	ManDelayCount
   1393  456d							;rts
   1394  456d
   1395  456d							; do NOT fall through!  Above removed just while there's a plain rts following...
   1396  456d
   1397  456d							;------------------------------------------------------------------------------
      0  456d					      DEFINE_SUBROUTINE	BonusCountdownRun
      1  456d		       00 08	   BANK_BonusCountdownRun =	_CURRENT_BANK
      2  456d					      SUBROUTINE
      3  456d				   BonusCountdownRun
   1399  456d		       60		      rts
   1400  456e
   1401  456e							;------------------------------------------------------------------------------
   1402  456e
   1403  456e							;lookColour	  .byte $b0,$02
   1404  456e
      0  456e					      DEFINE_SUBROUTINE	LookAround	; in INITBANK
      1  456e		       00 08	   BANK_LookAround =	_CURRENT_BANK
      2  456e					      SUBROUTINE
      3  456e				   LookAround
   1406  456e
   1407  456e							;ldx Platform
   1408  456e							;lda lookColour,x
   1409  456e							;sta BGColour
   1410  456e
   1411  456e							; Use the joystick as a window-scroller to change the viewport
   1412  456e
   1413  456e		       a5 95		      lda	BufferedJoystick
   1414  4570		       4a		      lsr
   1415  4571		       4a		      lsr
   1416  4572		       4a		      lsr
   1417  4573		       4a		      lsr
   1418  4574		       a8		      tay
   1419  4575
   1420  4575		       b9 ea f5 	      lda	JoyMoveX,y
   1421  4578							;asl
   1422  4578		       18		      clc
   1423  4579		       65 9b		      adc	BoardScrollX
   1424  457b		       c5 98		      cmp	BoardEdge_Right
   1425  457d		       b0 02		      bcs	AbandonX
   1426  457f		       85 9b		      sta	BoardScrollX
   1427  4581
   1428  4581		       b9 f6 f5    AbandonX   lda	JoyMoveY,y
   1429  4584							;asl
   1430  4584		       18		      clc
   1431  4585		       65 9a		      adc	BoardScrollY
   1432  4587		       c5 99		      cmp	BoardEdge_Bottom
   1433  4589		       b0 02		      bcs	AbandonY
   1434  458b		       85 9a		      sta	BoardScrollY
   1435  458d
   1436  458d		       60	   AbandonY   rts
   1437  458e
   1438  458e
   1439  458e
   1440  458e
   1441  458e				   PlayerAlive
   1442  458e
   1443  458e							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
   1444  458e							; before exiting via (for example) look-around option :)
   1445  458e
   1446  458e		       a5 9f		      lda	ManX
   1447  4590		       85 91		      sta	POS_X_NEW
   1448  4592		       a5 a0		      lda	ManY
   1449  4594		       85 92		      sta	POS_Y_NEW
   1450  4596
   1451  4596
   1452  4596							;------------------------------------------------------------------------------
   1453  4596							; Look around is triggered by holding down the fire button for a while, without any other
   1454  4596							; joystick directions chosen. The variable LookingAround has a negative value ($FF) when looking
   1455  4596							; is active. Otherwise, it is counting down to the time where it will trigger.
   1456  4596
   1457  4596		       00 06	   LOOK_DELAY =	6
   1458  4596
   1459  4596		       a2 06		      ldx	#LOOK_DELAY
   1460  4598		       a5 97		      lda	BufferedButton
   1461  459a		       30 0d		      bmi	noLook	; button?
   1462  459c		       a5 aa		      lda	LookingAround
   1463  459e		       30 ce		      bmi	LookAround	; already looking
   1464  45a0		       a5 95		      lda	BufferedJoystick
   1465  45a2		       c9 f0		      cmp	#$F0
   1466  45a4		       90 03		      bcc	noLook	; must have no directions chosen
   1467  45a6		       a6 aa		      ldx	LookingAround
   1468  45a8		       ca		      dex
   1469  45a9		       86 aa	   noLook     stx	LookingAround
   1470  45ab
   1471  45ab							;------------------------------------------------------------------------------
   1472  45ab
   1473  45ab							; control the scrolling via the joystick
   1474  45ab
   1475  45ab		       a5 a8		      lda	ManLastDirection
   1476  45ad		       29 07		      and	#DIRECTION_BITS
   1477  45af		       a8		      tay
   1478  45b0
   1479  45b0		       a5 95		      lda	BufferedJoystick	; joystick
   1480  45b2		       25 96		      and	BufferedJoystick+1
   1481  45b4
   1482  45b4		       a2 00		      ldx	#0
   1483  45b6		       0a	   .loopDirs  asl
   1484  45b7		       90 07		      bcc	.dirFound
   1485  45b9		       88		      dey
   1486  45ba		       e8		      inx
   1487  45bb		       e0 04		      cpx	#4
   1488  45bd		       d0 f7		      bne	.loopDirs
   1489  45bf		       18		      clc
   1490  45c0				   .dirFound
   1491  45c0		       a5 91		      lda	POS_X_NEW	;NewX
   1492  45c2		       7d 03 f6 	      adc	JoyDirX,x
   1493  45c5		       85 91		      sta	POS_X_NEW	;NewX
   1494  45c7		       a5 92		      lda	POS_Y_NEW	;NewY
   1495  45c9		       18		      clc
   1496  45ca		       7d 01 f6 	      adc	JoyDirY,x
   1497  45cd		       85 92		      sta	POS_Y_NEW	;NewY
   1498  45cf
   1499  45cf		       98		      tya
   1500  45d0		       f0 12		      beq	noMovement	; animation OK
   1501  45d2
   1502  45d2		       8a		      txa
   1503  45d3		       45 a8		      eor	ManLastDirection
   1504  45d5		       29 07		      and	#DIRECTION_BITS
   1505  45d7		       45 a8		      eor	ManLastDirection
   1506  45d9		       85 a8		      sta	ManLastDirection
   1507  45db		       bd e5 f5 	      lda	ManAnimTblLo,x
   1508  45de		       85 a5		      sta	ManAnimation
   1509  45e0							;lda ManAnimTblHi,x
   1510  45e0							;sta ManAnimation+1
   1511  45e0		       a9 00		      lda	#0
   1512  45e2		       85 a4		      sta	ManDelayCount
   1513  45e4				   phase0		;jsr MovePlayer
   1514  45e4				   noMovement		;ldx MAN_Player
   1515  45e4
   1516  45e4		       60	   DFS_rts    rts
   1517  45e5
   1518  45e5
   1519  45e5				   ManAnimTblLo
   1520  45e5		       16 1e 26 26*	      .byte.b	AnimateRIGHT-Manimate, AnimateLEFT-Manimate, AnimateUP-Manimate, AnimateUP-Manimate, AnimateSTOPPED-Manimate
   1521  45ea							;ManAnimTblHi
   1522  45ea							;    .byte   >AnimateRIGHT, >AnimateLEFT, >AnimateUP, >AnimateUP, >AnimateSTOPPED
   1523  45ea
   1524  45ea
   1525  45ea
   1526  45ea		       00 00 00 00*JoyMoveX   .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1	;,0, 0,0,0
   1527  45f6		       00 00 00 00*JoyMoveY   .byte.b	0,0,0,0,0,1,-1,0,0, 1,-1	;, 0,0,1,-1,0
   1528  4601
   1529  4601				   JoyDirY
   1530  4601		       00 00		      .byte.b	0,0	;,1,-1,0
   1531  4603				   JoyDirX
   1532  4603		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
   1533  4608
   1534  4608
   1535  4608							;------------------------------------------------------------------------------
   1536  4608
   1537  4608
      0  4608					      DEFINE_SUBROUTINE	DrawFullScreen	; = 2568[-96]
      1  4608		       00 08	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  4608					      SUBROUTINE
      3  4608				   DrawFullScreen
   1539  4608
   1540  4608							; 83[-7] + 2484[-89] = 2567[-96]
   1541  4608
   1542  4608
   1543  4608		       ad 84 02 	      lda	INTIM	; 4
   1544  460b		       c9 29		      cmp	#SEGTIME_BDF	; 2
   1545  460d		       90 d5		      bcc	DFS_rts	; 2/3
      0  460f					      STRESS_TIME	SEGTIME_BDF
      1  460f				  -	      IF	TEST_SEGTIME_BDF = 1
      2  460f				  -
      3  460f				  -
      4  460f				  -
      5  460f				  -
      6  460f				  -
      7  460f				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  460f				  -	      bne	. - 7
      9  460f					      ENDIF
   1547  460f
   1548  460f		       a9 f5		      lda	#>( DrawFlag + RAM_WRITE )	; 2
   1549  4611		       85 e0		      sta	BDF_DrawFlagAddress+1	; 3
   1550  4613		       85 e2		      sta	BDF_DrawFlagAddress2+1	; 3
   1551  4615
   1552  4615		       ba		      tsx		; 2
   1553  4616		       86 e9		      stx	DHS_Stack	; 3
   1554  4618
   1555  4618		       e6 8e		      inc	ScreenDrawPhase	; 5
   1556  461a
   1557  461a		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
   1558  461b		       a2 08		      ldx	#SCREEN_LINES	; 2
   1559  461d		       8a		      txa		; 2 = 31
   1560  461e
   1561  461e							; fall through
   1562  461e
   1563  461e							;------------------------------------------------------------------------------
   1564  461e
      0  461e					      DEFINE_SUBROUTINE	DrawScreenRowPreparation	; = 52[-7]
      1  461e		       00 08	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  461e					      SUBROUTINE
      3  461e				   DrawScreenRowPreparation
   1566  461e
   1567  461e							;clc
   1568  461e		       ca		      dex		; 2
   1569  461f		       86 e8		      stx	DHS_Line	; 3
   1570  4621		       65 9a		      adc	BoardScrollY	; 3	     the Y offset of screen into board
   1571  4623		       a8		      tay		; 2 = 10
   1572  4624
   1573  4624							;clc
   1574  4624		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
   1575  4627		       65 9b		      adc	BoardScrollX	; 3	     the X offset of screen into board
   1576  4629		       85 e3		      sta	BDF_BoardAddress	; 3
   1577  462b		       69 05		      adc	#SCREEN_WIDTH/2	; 2
   1578  462d		       85 e5		      sta	BDF_BoardAddress2	; 3
   1579  462f
   1580  462f		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
   1581  4632		       85 e4		      sta	BDF_BoardAddress+1	; 3
   1582  4634		       85 e6		      sta	BDF_BoardAddress2+1	; 3 = 25
   1583  4636
   1584  4636		       bd c0 f0 	      lda	DrawLineStartLO,x	; 4
   1585  4639		       85 df		      sta	BDF_DrawFlagAddress	; 3
   1586  463b		       69 05		      adc	#SCREEN_WIDTH/2	; 2
   1587  463d		       85 e1		      sta	BDF_DrawFlagAddress2	; 3 = 12
   1588  463f
   1589  463f				  -	      IF	MULTI_BANK_BOARD = YES
   1590  463f				  -	      lda	BoardBank-1,y	; 4
   1591  463f				  -	      sta	BDF_BoardBank	; 3
   1592  463f					      ENDIF
   1593  463f		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
   1594  4641		       4c b0 fc 	      jmp	CopyRow2	; 3 = 12[-7]
   1595  4644
   1596  4644							;------------------------------------------------------------------------------
   1597  4644
      0  4644					      DEFINE_SUBROUTINE	BigBang	;=1630[-85](B)
      1  4644		       00 08	   BANK_BigBang =	_CURRENT_BANK
      2  4644					      SUBROUTINE
      3  4644				   BigBang
   1599  4644							; requires a lot of complicated to calculate/test extra time if called from PROCESS_MAN!
   1600  4644
   1601  4644							; requires POS_X, POS_Y, POS_Type to be set
   1602  4644							; returns C if time too short
   1603  4644
   1604  4644		       ad 84 02 	      lda	INTIM	;4
   1605  4647		       c9 1f		      cmp	#SEGTIME_BIGBANG	;2
   1606  4649		       90 48		      bcc	AbortExplosion	;2/3= 8	 not enough processing time (carry important)
   1607  464b
      0  464b					      STRESS_TIME	SEGTIME_BIGBANG
      1  464b				  -	      IF	TEST_SEGTIME_BIGBANG = 1
      2  464b				  -
      3  464b				  -
      4  464b				  -
      5  464b				  -
      6  464b				  -
      7  464b				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  464b				  -	      bne	. - 7
      9  464b					      ENDIF
   1609  464b
      0  464b					      START_PRIO_SOUND	SOUND_EXPLOSION	;10= 10
      1  464b		       a5 db		      lda	newSounds
      2  464d					      IF	SOUND_EXPLOSION < 16
      3  464d		       29 f0		      and	#<(~SND_MASK_LO)
      4  464f				  -	      ELSE
      5  464f				  -	      and	#<(~SND_MASK_HI)
      6  464f					      ENDIF
      7  464f		       09 06		      ora	#SOUND_EXPLOSION
      8  4651		       85 db		      sta	newSounds
   1611  4653
   1612  4653		       a9 13		      lda	#CHARACTER_EXPLOSION	;2
   1613  4655		       a6 93		      ldx	POS_Type	;3
   1614  4657		       e0 03		      cpx	#TYPE_FLUTTERBY	;2
   1615  4659		       d0 02		      bne	noDiamExp	;2/3
   1616  465b		       09 80		      ora	#$80	;2		 butterfly generates diamond
   1617  465d		       85 94	   noDiamExp  sta	POS_VAR	;3 = 14	 object type to become, identified by char
   1618  465f
   1619  465f		       a9 09		      lda	#TYPE_EXPLOSION	;2
   1620  4661		       85 93		      sta	POS_Type	;3 =  5
   1621  4663
   1622  4663		       c6 8f		      dec	POS_X	;5
   1623  4665		       c6 90		      dec	POS_Y	;5
   1624  4667		       20 94 f6 	      jsr	ExplodeADiamond	;6+186(B)	 @x-1,y-1
   1625  466a		       e6 8f		      inc	POS_X	;5
   1626  466c		       20 a6 f6 	      jsr	ExplodeADiamondSameRow	;6+161(B)	 @x,  y-1
   1627  466f		       e6 8f		      inc	POS_X	;5
   1628  4671		       20 a6 f6 	      jsr	ExplodeADiamondSameRow	;6+161(B)	 @x+1,y-1
   1629  4674
   1630  4674		       e6 90		      inc	POS_Y	;5
   1631  4676		       20 94 f6 	      jsr	ExplodeADiamond	;6+186(B)	 @x+1,y
   1632  4679		       c6 8f		      dec	POS_X	;5
   1633  467b		       20 b4 f6 	      jsr	ExplodeADiamond0	;6+118(B)	 @x,  y
   1634  467e		       c6 8f		      dec	POS_X	;5
   1635  4680		       20 a6 f6 	      jsr	ExplodeADiamondSameRow	;6+161(B)	 @x-1,y
   1636  4683
   1637  4683		       e6 90		      inc	POS_Y	;5
   1638  4685		       20 94 f6 	      jsr	ExplodeADiamond	;6+186(B)	 @x-1,y+1
   1639  4688		       e6 8f		      inc	POS_X	;5
   1640  468a		       20 a6 f6 	      jsr	ExplodeADiamondSameRow	;6+161(B)	 @x,  y+1
   1641  468d		       e6 8f		      inc	POS_X	;5
   1642  468f		       20 a6 f6 	      jsr	ExplodeADiamondSameRow	;6+161(B)	 @x+1,y+1
   1643  4692
   1644  4692		       38		      sec		;2		 flags to callee that creature processed OK
   1645  4693				   AbortExplosion
   1646  4693				   NotEnoughProcessTime
   1647  4693		       60		      rts		;6 =  8
   1648  4694
   1649  4694
   1650  4694				   ExplodeADiamond		;=186[-10](B)
   1651  4694
   1652  4694							; Explosions generate explode creatures.  This allows the explosion to progress over
   1653  4694							; a series of frames. The explode creature subsequently dies and creates a diamond, or
   1654  4694							; a blank, as appropriate.  Meanwhile, creatures cannot move into exploding squares.
   1655  4694
   1656  4694							; First check if the creature at this position may be exploded
   1657  4694
   1658  4694		       a4 90		      ldy	POS_Y	;3
   1659  4696		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
   1660  4699		       85 bf		      sta	Board_AddressR	;3
   1661  469b		       85 c1		      sta	Board_AddressW	;3
   1662  469d		       b9 17 f0 	      lda	BoardLineStartHiR,y	;4
   1663  46a0		       85 c0		      sta	Board_AddressR+1	;3		 READ address
   1664  46a2		       09 04		      ora	#>RAM_WRITE	;2
   1665  46a4		       85 c2		      sta	Board_AddressW+1	;3 = 25	 WRITE address
   1666  46a6
   1667  46a6				   ExplodeADiamondSameRow		;=161[-10](B)
   1668  46a6
   1669  46a6				  -	      IF	MULTI_BANK_BOARD = YES
   1670  46a6				  -	      ldy	POS_Y	;3		 we could save another 9 cycles here at the cost of 10 bytes
   1671  46a6				  -	      lda	BoardBank,y	;4		 switch this on return
   1672  46a6					      ELSE
   1673  46a6		       a9 0d		      lda	#BANK_BOARD	;2
   1674  46a8					      ENDIF
   1675  46a8		       a4 8f		      ldy	POS_X	;3
   1676  46aa		       20 e4 f8 	      jsr	GetBoardCharacter	;6+20(A)	 sets RAM bank, ROM bank, needs Board_AddressR
   1677  46ad
   1678  46ad		       bd 3d fe 	      lda	GenericCharFlag,x	;3
   1679  46b0		       29 08		      and	#GENERIC_MASK_EXPLODABLE	;2
   1680  46b2		       f0 df		      beq	AbortExplosion	;2/3=43[-5]
   1681  46b4
   1682  46b4							; It can, so draw an explosion in the square and create an explosion object
   1683  46b4
   1684  46b4				   ExplodeADiamond0		;=118[-5](B)
   1685  46b4
   1686  46b4							; The following puts immediate explosion characters onscreen. This reduces the visual
   1687  46b4							; delay before the explosion creature(s) activate and draw themselves.
   1688  46b4
   1689  46b4							; Actually... consider a firefly/butterfly which is next to the player.  The firefly
   1690  46b4							; checks and finds the player there, so it decides to explode.  Gets to here. But the
   1691  46b4							; player moves away in the very same cycle (AFTER the firefly/butterfly). He's now one
   1692  46b4							; away and escapes the (next frame) explosion. By putting in the explosion characters
   1693  46b4							; immediately, we make sure that the player blows up too.
   1694  46b4
   1695  46b4				  -	      IF	MULTI_BANK_BOARD = YES
   1696  46b4				  -	      ldy	POS_Y	;3
   1697  46b4				  -	      ldx	BoardBank,y	;4		 switch this on return
   1698  46b4					      ELSE
   1699  46b4		       a2 0d		      ldx	#BANK_BOARD	;2
   1700  46b6					      ENDIF
   1701  46b6		       a4 8f		      ldy	POS_X	;3
   1702  46b8		       a9 13		      lda	#CHARACTER_EXPLOSION	;2
   1703  46ba		       20 ed f8 	      jsr	PutBoardCharacter	;6+21(A)=39[-5] write new post-explosion character, sets RAM bank, ROM bank, needs Board_AddressW
   1704  46bd
   1705  46bd
   1706  46bd							; Create the explosion object.  Note that POS_VAR tells it what sort of object it
   1707  46bd							; becomes, once it has finished its delay processing.
   1708  46bd
   1709  46bd		       4c 7c fb 	      jmp	InsertObjectStack	;3+76(B)	 place on stack so it stays alive
   1710  46c0
   1711  46c0							;------------------------------------------------------------------------------
   1712  46c0
      0  46c0					      DEFINE_SUBROUTINE	VectorProcess	;=19(A)
      1  46c0		       00 08	   BANK_VectorProcess =	_CURRENT_BANK
      2  46c0					      SUBROUTINE
      3  46c0				   VectorProcess
   1714  46c0
   1715  46c0							;sta ROM_Bank			  ;3		  processors can assume bank is stored
   1716  46c0
   1717  46c0		       bd da f6 	      lda	OSPointerHI,x	;4
   1718  46c3		       85 e0		      sta	POS_Vector+1	;3
   1719  46c5		       bd cd f6 	      lda	OSPointerLO,x	;4
   1720  46c8		       85 df		      sta	POS_Vector	;3
   1721  46ca
   1722  46ca		       6c df 00 	      jmp	(POS_Vector)	;5 = 19	 vector to processor for particular object type
   1723  46cd							;		 NOTE: Bank is either INITBANK or FIXED.
   1724  46cd
   1725  46cd
   1726  46cd				   OBJTYPE    SET	0
   1727  46cd					      MAC	define
   1728  46cd				   TYPE_{1}   =	OBJTYPE
   1729  46cd				   OBJTYPE    .SET	OBJTYPE + 1
   1730  46cd					      ENDM
   1731  46cd
   1732  46cd							; If adding/removing types, the following must also be updated...
   1733  46cd							;   InitialFace[...]		     in DecodeCave.asm
   1734  46cd							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
   1735  46cd							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
   1736  46cd							;   OSPointerLO[...]		     in BANK_INITBANK.asm
   1737  46cd							;   OSPointerHI[...]		     in BANK_INITBANK.asm
   1738  46cd							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1739  46cd							;   CharToType[...]		     in BANK_FIXED.asm (may have deleted types)
   1740  46cd							;   CharToType2[...]		     in DecodeCave.asm (may have deleted types)
   1741  46cd							;   Sortable[...]		     in BANK_FIXED.asm
   1742  46cd
   1743  46cd
      0  46cd					      DEFINE	MAN
      1  46cd		       00 00	   TYPE_MAN   =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	BOULDER
      1  46cd		       00 01	   TYPE_BOULDER =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	AMOEBA
      1  46cd		       00 02	   TYPE_AMOEBA =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	FLUTTERBY
      1  46cd		       00 03	   TYPE_FLUTTERBY =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	FIREFLY
      1  46cd		       00 04	   TYPE_FIREFLY =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	DIAMOND
      1  46cd		       00 05	   TYPE_DIAMOND =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	MAGICWALL
      1  46cd		       00 06	   TYPE_MAGICWALL =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	EXITDOOR
      1  46cd		       00 07	   TYPE_EXITDOOR =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	SELECTOR
      1  46cd		       00 08	   TYPE_SELECTOR =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	EXPLOSION
      1  46cd		       00 09	   TYPE_EXPLOSION =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	EXPLOSION1
      1  46cd		       00 0a	   TYPE_EXPLOSION1 =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	EXPLOSION2
      1  46cd		       00 0b	   TYPE_EXPLOSION2 =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	EXPLOSION3
      1  46cd		       00 0c	   TYPE_EXPLOSION3 =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	BLANK
      1  46cd		       00 0d	   TYPE_BLANK =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	SOIL
      1  46cd		       00 0e	   TYPE_SOIL  =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	STEELWALL
      1  46cd		       00 0f	   TYPE_STEELWALL =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
      0  46cd					      DEFINE	BRICKWALL
      1  46cd		       00 10	   TYPE_BRICKWALL =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
   1761  46cd
      0  46cd					      DEFINE	MAXIMUM
      1  46cd		       00 11	   TYPE_MAXIMUM =	OBJTYPE
      2  46cd				   OBJTYPE    .SET	OBJTYPE + 1
   1763  46cd							;    IF DEMO_VERSION = NO
   1764  46cd							;PROCESS_SELECTOR = 0
   1765  46cd							;    ENDIF
   1766  46cd
   1767  46cd
      0  46cd					      DEFINE_SUBROUTINE	OSPointerLO
      1  46cd		       00 08	   BANK_OSPointerLO =	_CURRENT_BANK
      2  46cd					      SUBROUTINE
      3  46cd				   OSPointerLO
   1769  46cd		       c9		      .byte.b	<PROCESS_MAN
   1770  46ce		       25		      .byte.b	<PROCESS_BOULDER
   1771  46cf		       00		      .byte.b	0	;<PROCESS_AMOEBA
   1772  46d0		       19		      .byte.b	<PROCESS_FLUTTERBY
   1773  46d1		       19		      .byte.b	<PROCESS_FIREFLY
   1774  46d2		       25		      .byte.b	<PROCESS_DIAMOND
   1775  46d3		       00		      .byte.b	0	; magic wall
   1776  46d4		       00		      .byte.b	0	; exit door
   1777  46d5		       00		      .byte.b	0	;<PROCESS_SELECTOR	    ; selection screen controller
   1778  46d6		       b8		      .byte.b	<PROCESS_EXPLOSION
   1779  46d7		       b8		      .byte.b	<PROCESS_EXPLOSION
   1780  46d8		       b8		      .byte.b	<PROCESS_EXPLOSION
   1781  46d9		       b8		      .byte.b	<PROCESS_EXPLOSION
   1782  46da							;		  .byte 0
   1783  46da							;		  .byte 0			  ; soil
   1784  46da							;		  .byte 0			  ; steel
   1785  46da							;		  .byte 0			  ; wall
   1786  46da
   1787  46da				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
   1788  46da				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
   1789  46da				  -	      EXIT
   1790  46da					      ENDIF
   1791  46da
   1792  46da
      0  46da					      DEFINE_SUBROUTINE	OSPointerHI
      1  46da		       00 08	   BANK_OSPointerHI =	_CURRENT_BANK
      2  46da					      SUBROUTINE
      3  46da				   OSPointerHI
   1794  46da		       f9		      .byte.b	>PROCESS_MAN
   1795  46db		       fa		      .byte.b	>PROCESS_BOULDER
   1796  46dc		       00		      .byte.b	0	;>PROCESS_AMOEBA
   1797  46dd		       f3		      .byte.b	>PROCESS_FLUTTERBY
   1798  46de		       f3		      .byte.b	>PROCESS_FIREFLY
   1799  46df		       fa		      .byte.b	>PROCESS_DIAMOND
   1800  46e0		       00		      .byte.b	0	;>PROCESS_MAGICWALL
   1801  46e1		       00		      .byte.b	0	; exit door
   1802  46e2		       00		      .byte.b	0	;>PROCESS_SELECTOR	    ; selection screen controller
   1803  46e3		       f9		      .byte.b	>PROCESS_EXPLOSION
   1804  46e4		       f9		      .byte.b	>PROCESS_EXPLOSION
   1805  46e5		       f9		      .byte.b	>PROCESS_EXPLOSION
   1806  46e6		       f9		      .byte.b	>PROCESS_EXPLOSION
   1807  46e7							;		  .byte 0
   1808  46e7							;		  .byte 0 ;soil
   1809  46e7							;		  .byte 0 ;steel
   1810  46e7							;		  .byte 0 ;wall
   1811  46e7
   1812  46e7				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
   1813  46e7				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
   1814  46e7				  -	      EXIT
   1815  46e7					      ENDIF
   1816  46e7
   1817  46e7							;	 IF TIMER_DEBUG = NO
   1818  46e7							;    DEFINE_SUBROUTINE OSTimer
   1819  46e7							;		  .byte SEGTIME_MAN
   1820  46e7							;		  .byte SEGTIME_BOULDER1
   1821  46e7							;		  .byte SEGTIME_AMOEBASQUARE
   1822  46e7							;		  .byte SEGTIME_BUTTERFLY
   1823  46e7							;		  .byte SEGTIME_FIREFLY
   1824  46e7							;		  .byte SEGTIME_BOULDER1
   1825  46e7							;		  .byte 0		 ; MAGICWALL
   1826  46e7							;		  .byte 0		  ; exit door
   1827  46e7							;		  .byte 0		     ; selection screen controller (no timer)
   1828  46e7							;		  .byte SEGTIME_EXPLOSION
   1829  46e7							;		  .byte SEGTIME_EXPLOSION
   1830  46e7							;		  .byte SEGTIME_EXPLOSION
   1831  46e7							;		  .byte SEGTIME_EXPLOSION
   1832  46e7							;;		   .byte 0
   1833  46e7							;;		   .byte 0 ;soil
   1834  46e7							;;		   .byte 0 ;steel
   1835  46e7							;;		   .byte 0 ;wall
   1836  46e7							;
   1837  46e7							;    IF * - OSTimer < TYPE_MAXIMUM-4
   1838  46e7							;	  ECHO "ERROR: Missing entry in OSTimer table!"
   1839  46e7							;	  EXIT
   1840  46e7							;    ENDIF
   1841  46e7							;	 ENDIF
   1842  46e7
   1843  46e7
   1844  46e7							;------------------------------------------------------------------------------
   1845  46e7
      0  46e7					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  46e7		       00 08	   BANK_MoveVecLO =	_CURRENT_BANK
      2  46e7					      SUBROUTINE
      3  46e7				   MoveVecLO
   1847  46e7
   1848  46e7		       f7		      .byte.b	<MOVE_BLANK
   1849  46e8		       fa		      .byte.b	<MOVE_SOIL
   1850  46e9		       49		      .byte.b	<MOVE_BOULDER
   1851  46ea		       3d		      .byte.b	<MOVE_GENERIC	;amoeba
   1852  46eb		       da		      .byte.b	<MOVE_DIAMOND
   1853  46ec		       da		      .byte.b	<MOVE_DIAMOND
   1854  46ed		       3d		      .byte.b	<MOVE_GENERIC
   1855  46ee		       3d		      .byte.b	<MOVE_GENERIC
   1856  46ef		       3d		      .byte.b	<MOVE_GENERIC
   1857  46f0		       3d		      .byte.b	<MOVE_GENERIC
   1858  46f1		       3d		      .byte.b	<MOVE_GENERIC
   1859  46f2		       3d		      .byte.b	<MOVE_GENERIC
   1860  46f3		       3d		      .byte.b	<MOVE_GENERIC
   1861  46f4		       3d		      .byte.b	<MOVE_GENERIC
   1862  46f5		       3d		      .byte.b	<MOVE_GENERIC
   1863  46f6		       3d		      .byte.b	<MOVE_GENERIC
   1864  46f7		       3d		      .byte.b	<MOVE_GENERIC
   1865  46f8		       42		      .byte.b	<MOVE_EXIT
   1866  46f9		       42		      .byte.b	<MOVE_EXIT
   1867  46fa
   1868  46fa		       3d		      .byte.b	<MOVE_GENERIC
   1869  46fb		       3d		      .byte.b	<MOVE_GENERIC
   1870  46fc		       3d		      .byte.b	<MOVE_GENERIC
   1871  46fd		       3d		      .byte.b	<MOVE_GENERIC
   1872  46fe		       3d		      .byte.b	<MOVE_GENERIC	; amoeba???
   1873  46ff
   1874  46ff		       3d		      .byte.b	<MOVE_GENERIC	; falling boulder
   1875  4700		       3d		      .byte.b	<MOVE_GENERIC	; falling diamond
   1876  4701
   1877  4701		       3d		      .byte.b	<MOVE_GENERIC	; unkillable man
   1878  4702
   1879  4702				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
   1880  4702				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
   1881  4702				  -	      EXIT
   1882  4702					      ENDIF
   1883  4702
   1884  4702
   1885  4702
      0  4702					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  4702		       00 08	   BANK_MoveVecHI =	_CURRENT_BANK
      2  4702					      SUBROUTINE
      3  4702				   MoveVecHI
   1887  4702
   1888  4702		       fb		      .byte.b	>MOVE_BLANK
   1889  4703		       fb		      .byte.b	>MOVE_SOIL
   1890  4704		       fc		      .byte.b	>MOVE_BOULDER
   1891  4705		       fc		      .byte.b	>MOVE_GENERIC	;amoeba
   1892  4706		       fb		      .byte.b	>MOVE_DIAMOND
   1893  4707		       fb		      .byte.b	>MOVE_DIAMOND
   1894  4708		       fc		      .byte.b	>MOVE_GENERIC
   1895  4709		       fc		      .byte.b	>MOVE_GENERIC
   1896  470a		       fc		      .byte.b	>MOVE_GENERIC
   1897  470b		       fc		      .byte.b	>MOVE_GENERIC
   1898  470c		       fc		      .byte.b	>MOVE_GENERIC
   1899  470d		       fc		      .byte.b	>MOVE_GENERIC
   1900  470e		       fc		      .byte.b	>MOVE_GENERIC
   1901  470f		       fc		      .byte.b	>MOVE_GENERIC
   1902  4710		       fc		      .byte.b	>MOVE_GENERIC
   1903  4711		       fc		      .byte.b	>MOVE_GENERIC
   1904  4712		       fc		      .byte.b	>MOVE_GENERIC
   1905  4713		       fc		      .byte.b	>MOVE_EXIT
   1906  4714		       fc		      .byte.b	>MOVE_EXIT
   1907  4715
   1908  4715		       fc		      .byte.b	>MOVE_GENERIC
   1909  4716		       fc		      .byte.b	>MOVE_GENERIC
   1910  4717		       fc		      .byte.b	>MOVE_GENERIC
   1911  4718		       fc		      .byte.b	>MOVE_GENERIC
   1912  4719		       fc		      .byte.b	>MOVE_GENERIC	;amoeba
   1913  471a
   1914  471a		       fc		      .byte.b	>MOVE_GENERIC	; falling boulder
   1915  471b		       fc		      .byte.b	>MOVE_GENERIC	; falling diamond
   1916  471c
   1917  471c		       fc		      .byte.b	>MOVE_GENERIC	; unkillable man
   1918  471d
   1919  471d				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
   1920  471d				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
   1921  471d				  -	      EXIT
   1922  471d					      ENDIF
   1923  471d
   1924  471d
      0  471d					      CHECK_BANK_SIZE	"INITBANK"
      1  471d		       07 1d	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $71d , FREE= $e3
      2  471d					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  471d				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  471d				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  471d				  -	      ERR
      6  471d					      endif
------- FILE ./notBoulderDash.asm
------- FILE BANK_FIXED.asm LEVEL 2 PASS 3
      0  471d					      include	"BANK_FIXED.asm"
      1  471d							;------------------------------------------------------------------------------
      2  471d							;###############################  FIXED BANK  #################################
      3  471d							;------------------------------------------------------------------------------
      4  471d
      5  471d
      6  471d				   ORIGIN     SET	FIXED_BANK
      7  471d
      0  471d					      NEWBANK	THE_FIXED_BANK
      1  7ff5 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
      9  7800					      RORG	$f800
     10  7800
     11  7800
     12  7800							;------------------------------------------------------------------------------
     13  7800							; TJ: used by:
     14  7800							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
------- FILE Amoeba.asm LEVEL 3 PASS 3
      0  7800					      include	"Amoeba.asm"	; 4 * LINES_PER_CHAR bytes
      1  7800
      2  7800
      0  7800					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA", LINES_PER_CHAR
     10  7800					      LIST	ON
      4  7800
      5  7800		       00 04	   AMOEBA_DEF =	4
      6  7800
      7  7800				  -	      if	AMOEBA_DEF = 0
      8  7800				  -CHARACTERSHAPE_AMOEBA
      9  7800				  -	      if	MIRRORED_AMOEBA = NO
     10  7800				  -CHARACTERSHAPE_AMOEBA_MIRRORED
     11  7800				  -	      endif
     12  7800				  -	      .byte	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     13  7800				  -	      .byte	%01000100,%10101010,%0,%0,%10101100,%0,%0	;G
     14  7800				  -	      .byte	%01000100,%10101010,%0,%0,%10101100,%0,%0	;B
     15  7800				  -			;--------------------------------------------------------------------------
     16  7800				  -	      if	MIRRORED_AMOEBA = YES
     17  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA_MIRRORED", LINES_PER_CHAR
     18  7800				  -CHARACTERSHAPE_AMOEBA_MIRRORED
     19  7800				  -	      .byte	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     20  7800				  -	      .byte	%00100010,%01010101,%0,%0,%00110101,%0,%0	;G
     21  7800				  -	      .byte	%01000100,%01010101,%0,%0,%00110101,%0,%0	;B
     22  7800				  -	      endif
     23  7800				  -			;--------------------------------------------------------------------------
     24  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA2", LINES_PER_CHAR
     25  7800				  -CHARACTERSHAPE_AMOEBA2
     26  7800				  -	      if	MIRRORED_AMOEBA = NO
     27  7800				  -CHARACTERSHAPE_AMOEBA2_MIRRORED
     28  7800				  -	      endif
     29  7800				  -	      .byte	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     30  7800				  -	      .byte	%11101110,%10001000,%0,%00100010,%0,%0,%0	;G
     31  7800				  -	      .byte	%11101110,%10001000,%0,%00100010,%0,%0,%0	;G
     32  7800				  -			;--------------------------------------------------------------------------
     33  7800				  -	      if	MIRRORED_AMOEBA = YES
     34  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA2_MIRRORED", LINES_PER_CHAR
     35  7800				  -CHARACTERSHAPE_AMOEBA2_MIRRORED
     36  7800				  -	      .byte	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     37  7800				  -	      .byte	%01110111,%00010001,%0,%01000100,%0,%0,%0	;G
     38  7800				  -	      .byte	%01110111,%00010001,%0,%01000100,%0,%0,%0	;G
     39  7800				  -	      endif
     40  7800					      endif
     41  7800
     42  7800				  -	      if	AMOEBA_DEF = 1
     43  7800				  -			;"ORIGINAL"
     44  7800				  -
     45  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA", LINES_PER_CHAR
     46  7800				  -CHARACTERSHAPE_AMOEBA
     47  7800				  -	      if	MIRRORED_AMOEBA = NO
     48  7800				  -CHARACTERSHAPE_AMOEBA_MIRRORED
     49  7800				  -	      endif
     50  7800				  -	      .byte	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     51  7800				  -	      .byte	%01000100,%10101010,%0,%0,%10101100,%0,%0	;G
     52  7800				  -	      .byte	%01000100,%10101010,%0,%0,%10101100,%0,%0	;B
     53  7800				  -			;--------------------------------------------------------------------------
     54  7800				  -	      if	MIRRORED_AMOEBA = YES
     55  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA_MIRRORED", LINES_PER_CHAR
     56  7800				  -CHARACTERSHAPE_AMOEBA_MIRRORED
     57  7800				  -	      .byte	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     58  7800				  -	      .byte	%00100010,%01010101,%0,%0,%00110101,%0,%0	;G
     59  7800				  -	      .byte	%01000100,%01010101,%0,%0,%00110101,%0,%0	;B
     60  7800				  -	      endif
     61  7800				  -			;--------------------------------------------------------------------------
     62  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA2", LINES_PER_CHAR
     63  7800				  -CHARACTERSHAPE_AMOEBA2
     64  7800				  -	      if	MIRRORED_AMOEBA = NO
     65  7800				  -CHARACTERSHAPE_AMOEBA2_MIRRORED
     66  7800				  -	      endif
     67  7800				  -	      .byte	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     68  7800				  -	      .byte	%11101110,%10001000,%0,%00100010,%0,%0,%0	;G
     69  7800				  -	      .byte	%11101110,%10001000,%0,%00100010,%0,%0,%0	;G
     70  7800				  -			;--------------------------------------------------------------------------
     71  7800				  -	      if	MIRRORED_AMOEBA = YES
     72  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA2_MIRRORED", LINES_PER_CHAR
     73  7800				  -CHARACTERSHAPE_AMOEBA2_MIRRORED
     74  7800				  -	      .byte	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     75  7800				  -	      .byte	%01110111,%00010001,%0,%01000100,%0,%0,%0	;G
     76  7800				  -	      .byte	%01110111,%00010001,%0,%01000100,%0,%0,%0	;G
     77  7800				  -	      endif
     78  7800				  -
     79  7800					      endif
     80  7800
     81  7800				  -	      if	AMOEBA_DEF = 2
     82  7800				  -CHARACTERSHAPE_AMOEBA
     83  7800				  -	      if	MIRRORED_AMOEBA = NO
     84  7800				  -CHARACTERSHAPE_AMOEBA_MIRRORED
     85  7800				  -	      endif
     86  7800				  -	      .byte	%10111011	; R (#3 bright, complementary color)
     87  7800				  -	      .byte	%11111111
     88  7800				  -	      .byte	%11111111
     89  7800				  -	      .byte	%11101110
     90  7800				  -	      .byte	%11101110
     91  7800				  -	      .byte	%11111111
     92  7800				  -	      .byte	%10111011
     93  7800				  -
     94  7800				  -	      .byte	%10111011	; G (#2 basic dirt color, usually the darkest one)
     95  7800				  -	      .byte	%11111111
     96  7800				  -	      .byte	%11111111
     97  7800				  -	      .byte	%11101110
     98  7800				  -	      .byte	%11111111
     99  7800				  -	      .byte	%11111111
    100  7800				  -	      .byte	%10111011
    101  7800				  -
    102  7800				  -	      .byte	%11111111	; B (#1 additional wall/boulder color)
    103  7800				  -	      .byte	%11111111
    104  7800				  -	      .byte	%11111111
    105  7800				  -	      .byte	%11101110
    106  7800				  -	      .byte	%11111111
    107  7800				  -	      .byte	%10111011
    108  7800				  -	      .byte	%10111011
    109  7800				  -
    110  7800				  -			;--------------------------------------------------------------------------
    111  7800				  -	      if	MIRRORED_AMOEBA = YES
    112  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA_MIRRORED", LINES_PER_CHAR
    113  7800				  -CHARACTERSHAPE_AMOEBA_MIRRORED
    114  7800				  -	      .byte	%11011101	; R (#3 bright, complementary color)
    115  7800				  -	      .byte	%11111111
    116  7800				  -	      .byte	%11111111
    117  7800				  -	      .byte	%01110111
    118  7800				  -	      .byte	%01110111
    119  7800				  -	      .byte	%11111111
    120  7800				  -	      .byte	%11011101
    121  7800				  -
    122  7800				  -	      .byte	%11011101	; G (#2 basic dirt color, usually the darkest one)
    123  7800				  -	      .byte	%11111111
    124  7800				  -	      .byte	%11111111
    125  7800				  -	      .byte	%01110111
    126  7800				  -	      .byte	%11111111
    127  7800				  -	      .byte	%11111111
    128  7800				  -	      .byte	%11011101
    129  7800				  -
    130  7800				  -	      .byte	%11111111	; B (#1 additional wall/boulder color)
    131  7800				  -	      .byte	%11111111
    132  7800				  -	      .byte	%11111111
    133  7800				  -	      .byte	%01110111
    134  7800				  -	      .byte	%11111111
    135  7800				  -	      .byte	%11011101
    136  7800				  -	      .byte	%11011101
    137  7800				  -	      endif
    138  7800				  -			;--------------------------------------------------------------------------
    139  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA2", LINES_PER_CHAR
    140  7800				  -CHARACTERSHAPE_AMOEBA2
    141  7800				  -	      if	MIRRORED_AMOEBA = NO
    142  7800				  -CHARACTERSHAPE_AMOEBA2_MIRRORED
    143  7800				  -	      endif
    144  7800				  -	      .byte	%10111011	; R (#3 bright, complementary color)
    145  7800				  -	      .byte	%11111111
    146  7800				  -	      .byte	%11111111
    147  7800				  -	      .byte	%11101110
    148  7800				  -	      .byte	%11101110
    149  7800				  -	      .byte	%11111111
    150  7800				  -	      .byte	%10111011
    151  7800				  -
    152  7800				  -	      .byte	%11111111	; G (#2 basic dirt color, usually the darkest one)
    153  7800				  -	      .byte	%11111111
    154  7800				  -	      .byte	%11111111
    155  7800				  -	      .byte	%01000100
    156  7800				  -	      .byte	%11101110
    157  7800				  -	      .byte	%11111111
    158  7800				  -	      .byte	%10111011
    159  7800				  -
    160  7800				  -	      .byte	%11111111	; B (#1 additional wall/boulder color)
    161  7800				  -	      .byte	%11111111
    162  7800				  -	      .byte	%11101110
    163  7800				  -	      .byte	%01000100
    164  7800				  -	      .byte	%11111111
    165  7800				  -	      .byte	%11111111
    166  7800				  -	      .byte	%10111011
    167  7800				  -			;--------------------------------------------------------------------------
    168  7800				  -	      if	MIRRORED_AMOEBA = YES
    169  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA2_MIRRORED", LINES_PER_CHAR
    170  7800				  -CHARACTERSHAPE_AMOEBA2_MIRRORED
    171  7800				  -	      .byte	%11011101	; R (#3 bright, complementary color)
    172  7800				  -	      .byte	%11111111
    173  7800				  -	      .byte	%11111111
    174  7800				  -	      .byte	%01110111
    175  7800				  -	      .byte	%01110111
    176  7800				  -	      .byte	%11111111
    177  7800				  -	      .byte	%11011101
    178  7800				  -
    179  7800				  -	      .byte	%11111111	; G (#2 basic dirt color, usually the darkest one)
    180  7800				  -	      .byte	%11111111
    181  7800				  -	      .byte	%11111111
    182  7800				  -	      .byte	%00100010
    183  7800				  -	      .byte	%01110111
    184  7800				  -	      .byte	%11111111
    185  7800				  -	      .byte	%11011101
    186  7800				  -
    187  7800				  -	      .byte	%11111111	; B (#1 additional wall/boulder color)
    188  7800				  -	      .byte	%11111111
    189  7800				  -	      .byte	%01110111
    190  7800				  -	      .byte	%00100010
    191  7800				  -	      .byte	%11111111
    192  7800				  -	      .byte	%11111111
    193  7800				  -	      .byte	%11011101
    194  7800				  -	      endif
    195  7800					      endif
    196  7800
    197  7800				  -	      if	AMOEBA_DEF = 3
    198  7800				  -CHARACTERSHAPE_AMOEBA
    199  7800				  -	      if	MIRRORED_AMOEBA = NO
    200  7800				  -CHARACTERSHAPE_AMOEBA_MIRRORED
    201  7800				  -	      endif
    202  7800				  -	      .byte	%10111011	; R (#3 bright, complementary color)
    203  7800				  -	      .byte	%11111111
    204  7800				  -	      .byte	%11111111
    205  7800				  -	      .byte	%11101110
    206  7800				  -	      .byte	%11101110
    207  7800				  -	      .byte	%11111111
    208  7800				  -	      .byte	%10111011
    209  7800				  -
    210  7800				  -	      .byte	%10111011	; G (#2 basic dirt color, usually the darkest one)
    211  7800				  -	      .byte	%11111111
    212  7800				  -	      .byte	%11111111
    213  7800				  -	      .byte	%11101110
    214  7800				  -	      .byte	%11111111
    215  7800				  -	      .byte	%11111111
    216  7800				  -	      .byte	%10111011
    217  7800				  -
    218  7800				  -	      .byte	%00000000	; B (#1 additional wall/boulder color)
    219  7800				  -	      .byte	%00000000
    220  7800				  -	      .byte	%00000000
    221  7800				  -	      .byte	%00000000
    222  7800				  -	      .byte	%00000000
    223  7800				  -	      .byte	%00000000
    224  7800				  -	      .byte	%00000000
    225  7800				  -
    226  7800				  -			;--------------------------------------------------------------------------
    227  7800				  -	      if	MIRRORED_AMOEBA = YES
    228  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA_MIRRORED", LINES_PER_CHAR
    229  7800				  -CHARACTERSHAPE_AMOEBA_MIRRORED
    230  7800				  -	      .byte	%11011101	; R (#3 bright, complementary color)
    231  7800				  -	      .byte	%11111111
    232  7800				  -	      .byte	%11111111
    233  7800				  -	      .byte	%01110111
    234  7800				  -	      .byte	%01110111
    235  7800				  -	      .byte	%11111111
    236  7800				  -	      .byte	%11011101
    237  7800				  -
    238  7800				  -	      .byte	%11011101	; G (#2 basic dirt color, usually the darkest one)
    239  7800				  -	      .byte	%11111111
    240  7800				  -	      .byte	%11111111
    241  7800				  -	      .byte	%01110111
    242  7800				  -	      .byte	%11111111
    243  7800				  -	      .byte	%11111111
    244  7800				  -	      .byte	%11011101
    245  7800				  -
    246  7800				  -	      .byte	%00000000	; B (#1 additional wall/boulder color)
    247  7800				  -	      .byte	%00000000
    248  7800				  -	      .byte	%00000000
    249  7800				  -	      .byte	%00000000
    250  7800				  -	      .byte	%00000000
    251  7800				  -	      .byte	%00000000
    252  7800				  -	      .byte	%00000000
    253  7800				  -	      endif
    254  7800				  -			;--------------------------------------------------------------------------
    255  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA2", LINES_PER_CHAR
    256  7800				  -CHARACTERSHAPE_AMOEBA2
    257  7800				  -	      if	MIRRORED_AMOEBA = NO
    258  7800				  -CHARACTERSHAPE_AMOEBA2_MIRRORED
    259  7800				  -	      endif
    260  7800				  -	      .byte	%10111011	; R (#3 bright, complementary color)
    261  7800				  -	      .byte	%11111111
    262  7800				  -	      .byte	%11111111
    263  7800				  -	      .byte	%11101110
    264  7800				  -	      .byte	%11101110
    265  7800				  -	      .byte	%11111111
    266  7800				  -	      .byte	%10111011
    267  7800				  -
    268  7800				  -	      .byte	%11111111	; G (#2 basic dirt color, usually the darkest one)
    269  7800				  -	      .byte	%11111111
    270  7800				  -	      .byte	%11111111
    271  7800				  -	      .byte	%01000100
    272  7800				  -	      .byte	%11101110
    273  7800				  -	      .byte	%11111111
    274  7800				  -	      .byte	%10111011
    275  7800				  -
    276  7800				  -	      .byte	%00000000	; B (#1 additional wall/boulder color)
    277  7800				  -	      .byte	%00000000
    278  7800				  -	      .byte	%00000000
    279  7800				  -	      .byte	%00000000
    280  7800				  -	      .byte	%00000000
    281  7800				  -	      .byte	%00000000
    282  7800				  -	      .byte	%00000000
    283  7800				  -			;--------------------------------------------------------------------------
    284  7800				  -	      if	MIRRORED_AMOEBA = YES
    285  7800				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA2_MIRRORED", LINES_PER_CHAR
    286  7800				  -CHARACTERSHAPE_AMOEBA2_MIRRORED
    287  7800				  -	      .byte	%11011101	; R (#3 bright, complementary color)
    288  7800				  -	      .byte	%11111111
    289  7800				  -	      .byte	%11111111
    290  7800				  -	      .byte	%01110111
    291  7800				  -	      .byte	%01110111
    292  7800				  -	      .byte	%11111111
    293  7800				  -	      .byte	%11011101
    294  7800				  -
    295  7800				  -	      .byte	%11111111	; G (#2 basic dirt color, usually the darkest one)
    296  7800				  -	      .byte	%11111111
    297  7800				  -	      .byte	%11111111
    298  7800				  -	      .byte	%00100010
    299  7800				  -	      .byte	%01110111
    300  7800				  -	      .byte	%11111111
    301  7800				  -	      .byte	%11011101
    302  7800				  -
    303  7800				  -	      .byte	%00000000	; B (#1 additional wall/boulder color)
    304  7800				  -	      .byte	%00000000
    305  7800				  -	      .byte	%00000000
    306  7800				  -	      .byte	%00000000
    307  7800				  -	      .byte	%00000000
    308  7800				  -	      .byte	%00000000
    309  7800				  -	      .byte	%00000000
    310  7800				  -	      endif
    311  7800					      endif
    312  7800
    313  7800					      if	AMOEBA_DEF = 4
    314  7800				   CHARACTERSHAPE_AMOEBA
    315  7800				  -	      if	MIRRORED_AMOEBA = NO
    316  7800				  -CHARACTERSHAPE_AMOEBA_MIRRORED
    317  7800					      endif
    318  7800		       bb		      .byte.b	%10111011	; R (#3 bright, complementary color)
    319  7801		       ff		      .byte.b	%11111111
    320  7802		       ee		      .byte.b	%11101110
    321  7803		       44		      .byte.b	%01000100
    322  7804		       ee		      .byte.b	%11101110
    323  7805		       ff		      .byte.b	%11111111
    324  7806		       ff		      .byte.b	%11111111
    325  7807
    326  7807		       ff		      .byte.b	%11111111	; G (#2 basic dirt color, usually the darkest one)
    327  7808		       ee		      .byte.b	%11101110
    328  7809		       44		      .byte.b	%01000100
    329  780a		       44		      .byte.b	%01000100
    330  780b		       ee		      .byte.b	%11101110
    331  780c		       ff		      .byte.b	%11111111
    332  780d		       ff		      .byte.b	%11111111
    333  780e
    334  780e		       44		      .byte.b	%01000100	; B (#1 additional wall/boulder color)
    335  780f		       00		      .byte.b	%00000000
    336  7810		       00		      .byte.b	%00000000
    337  7811		       00		      .byte.b	%00000000
    338  7812		       00		      .byte.b	%00000000
    339  7813		       00		      .byte.b	%00000000
    340  7814		       44		      .byte.b	%01000100
    341  7815
    342  7815							;--------------------------------------------------------------------------
    343  7815					      if	MIRRORED_AMOEBA = YES
      0  7815					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA_MIRRORED", LINES_PER_CHAR
     10  7815					      LIST	ON
    345  7815				   CHARACTERSHAPE_AMOEBA_MIRRORED
    346  7815		       dd		      .byte.b	%11011101	; R (#3 bright, complementary color)
    347  7816		       ff		      .byte.b	%11111111
    348  7817		       77		      .byte.b	%01110111
    349  7818		       22		      .byte.b	%00100010
    350  7819		       77		      .byte.b	%01110111
    351  781a		       ff		      .byte.b	%11111111
    352  781b		       ff		      .byte.b	%11111111
    353  781c
    354  781c		       ff		      .byte.b	%11111111	; G (#2 basic dirt color, usually the darkest one)
    355  781d		       77		      .byte.b	%01110111
    356  781e		       22		      .byte.b	%00100010
    357  781f		       22		      .byte.b	%00100010
    358  7820		       77		      .byte.b	%01110111
    359  7821		       ff		      .byte.b	%11111111
    360  7822		       ff		      .byte.b	%11111111
    361  7823
    362  7823		       22		      .byte.b	%00100010	; B (#1 additional wall/boulder color)
    363  7824		       00		      .byte.b	%00000000
    364  7825		       00		      .byte.b	%00000000
    365  7826		       00		      .byte.b	%00000000
    366  7827		       00		      .byte.b	%00000000
    367  7828		       00		      .byte.b	%00000000
    368  7829		       22		      .byte.b	%00100010
    369  782a					      endif
    370  782a							;--------------------------------------------------------------------------
      0  782a					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA2", LINES_PER_CHAR
     10  782a					      LIST	ON
    372  782a				   CHARACTERSHAPE_AMOEBA2
    373  782a				  -	      if	MIRRORED_AMOEBA = NO
    374  782a				  -CHARACTERSHAPE_AMOEBA2_MIRRORED
    375  782a					      endif
    376  782a		       bb		      .byte.b	%10111011	; R (#3 bright, complementary color)
    377  782b		       ff		      .byte.b	%11111111
    378  782c		       ee		      .byte.b	%11101110
    379  782d		       44		      .byte.b	%01000100
    380  782e		       ee		      .byte.b	%11101110
    381  782f		       ff		      .byte.b	%11111111
    382  7830		       ff		      .byte.b	%11111111
    383  7831
    384  7831		       bb		      .byte.b	%10111011	; G (#2 basic dirt color, usually the darkest one)
    385  7832		       ff		      .byte.b	%11111111
    386  7833		       ee		      .byte.b	%11101110
    387  7834		       ee		      .byte.b	%11101110
    388  7835		       ff		      .byte.b	%11111111
    389  7836		       ff		      .byte.b	%11111111
    390  7837		       bb		      .byte.b	%10111011
    391  7838
    392  7838		       00		      .byte.b	%00000000	; B (#1 additional wall/boulder color)
    393  7839		       11		      .byte.b	%00010001
    394  783a		       aa		      .byte.b	%10101010
    395  783b		       aa		      .byte.b	%10101010
    396  783c		       11		      .byte.b	%00010001
    397  783d		       00		      .byte.b	%00000000
    398  783e		       00		      .byte.b	%00000000
    399  783f							;--------------------------------------------------------------------------
    400  783f					      if	MIRRORED_AMOEBA = YES
      0  783f					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_AMOEBA2_MIRRORED", LINES_PER_CHAR
     10  783f					      LIST	ON
    402  783f				   CHARACTERSHAPE_AMOEBA2_MIRRORED
    403  783f		       dd		      .byte.b	%11011101	; R (#3 bright, complementary color)
    404  7840		       ff		      .byte.b	%11111111
    405  7841		       77		      .byte.b	%01110111
    406  7842		       22		      .byte.b	%00100010
    407  7843		       77		      .byte.b	%01110111
    408  7844		       ff		      .byte.b	%11111111
    409  7845		       ff		      .byte.b	%11111111
    410  7846
    411  7846		       dd		      .byte.b	%11011101	; G (#2 basic dirt color, usually the darkest one)
    412  7847		       ff		      .byte.b	%11111111
    413  7848		       77		      .byte.b	%01110111
    414  7849		       77		      .byte.b	%01110111
    415  784a		       ff		      .byte.b	%11111111
    416  784b		       ff		      .byte.b	%11111111
    417  784c		       dd		      .byte.b	%11011101
    418  784d
    419  784d		       00		      .byte.b	%00000000	; B (#1 additional wall/boulder color)
    420  784e		       88		      .byte.b	%10001000
    421  784f		       55		      .byte.b	%01010101
    422  7850		       55		      .byte.b	%01010101
    423  7851		       88		      .byte.b	%10001000
    424  7852		       00		      .byte.b	%00000000
    425  7853		       00		      .byte.b	%00000000
    426  7854					      endif
    427  7854					      endif
    428  7854
    429  7854
    430  7854
    431  7854
    432  7854
------- FILE BANK_FIXED.asm
------- FILE Brick_Wall.asm LEVEL 3 PASS 3
      0  7854					      include	"Brick_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      0  7854					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  7854					      LIST	ON
      2  7854
      3  7854		       00 00	   BRICK_WALL_DEF =	0
      4  7854
      5  7854				   CHARACTERSHAPE_FLUTTERBYHOLD
      6  7854				   CHARACTERSHAPE_FLUTTERBYHOLD_MIRRORED
      7  7854				   CHARACTERSHAPE_FIREFLYHOLD
      8  7854				   CHARACTERSHAPE_FIREFLYHOLD_MIRRORED
      9  7854				   CHARACTERSHAPE_FLUTTERBYHOLD2
     10  7854				   CHARACTERSHAPE_FLUTTERBYHOLD2_MIRRORED
     11  7854				   CHARACTERSHAPE_FIREFLYHOLD2
     12  7854				   CHARACTERSHAPE_FIREFLYHOLD2_MIRRORED
     13  7854
     14  7854
     15  7854				   CHARACTERSHAPE_WALL
     16  7854				   CHARACTERSHAPE_WALL0
     17  7854
     18  7854
     19  7854
     20  7854				  -	      if	MIRRORED_WALL = NO
     21  7854				  -CHARACTERSHAPE_WALL_MIRRORED
     22  7854				  -CHARACTERSHAPE_WALL0_MIRRORED
     23  7854					      endif
     24  7854
     25  7854					      if	BRICK_WALL_DEF = 0
     26  7854		       00 77 77 00*	      .byte.b	%00000000,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;R
     27  785b		       77 77 77 00*	      .byte.b	%01110111,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;G
     28  7862		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;B
     29  7869					      endif
     30  7869
     31  7869				  -	      if	BRICK_WALL_DEF = 1
     32  7869				  -	      .byte	%01100110	;R #2 bright color
     33  7869				  -	      .byte	%01110111
     34  7869				  -	      .byte	%01110111
     35  7869				  -	      .byte	%00000000
     36  7869				  -	      .byte	%10011001
     37  7869				  -	      .byte	%11011101
     38  7869				  -	      .byte	%11011101
     39  7869				  -
     40  7869				  -	      .byte	%01100110	;G #1 dark, dirt color
     41  7869				  -	      .byte	%01110111
     42  7869				  -	      .byte	%01110111
     43  7869				  -	      .byte	%00000000
     44  7869				  -	      .byte	%10011001
     45  7869				  -	      .byte	%11011101
     46  7869				  -	      .byte	%11011101
     47  7869				  -
     48  7869				  -	      .byte	%01100110	;B #0 medium, mix color
     49  7869				  -	      .byte	%01110111
     50  7869				  -	      .byte	%00000000
     51  7869				  -	      .byte	%00000000
     52  7869				  -	      .byte	%10011001
     53  7869				  -	      .byte	%11011101
     54  7869				  -	      .byte	%00000000
     55  7869					      endif
     56  7869
     57  7869				  -	      if	BRICK_WALL_DEF = 2
     58  7869				  -	      .byte	%01100110	;R #2 bright color
     59  7869				  -	      .byte	%01110111
     60  7869				  -	      .byte	%01110111
     61  7869				  -	      .byte	%00000000
     62  7869				  -	      .byte	%10011001
     63  7869				  -	      .byte	%11011101
     64  7869				  -	      .byte	%11011101
     65  7869				  -
     66  7869				  -	      .byte	%11111111	;G #1 dark, dirt color
     67  7869				  -	      .byte	%11111111
     68  7869				  -	      .byte	%11111111
     69  7869				  -	      .byte	%11111111
     70  7869				  -	      .byte	%11111111
     71  7869				  -	      .byte	%11111111
     72  7869				  -	      .byte	%11111111
     73  7869				  -
     74  7869				  -	      .byte	%11111111	;B #0 medium, mix color
     75  7869				  -	      .byte	%11111111
     76  7869				  -	      .byte	%11111111
     77  7869				  -	      .byte	%11111111
     78  7869				  -	      .byte	%11111111
     79  7869				  -	      .byte	%11111111
     80  7869				  -	      .byte	%00000000
     81  7869					      endif
     82  7869
     83  7869				  -	      if	BRICK_WALL_DEF = 3
     84  7869				  -	      .byte	%00000000
     85  7869				  -	      .byte	%10011001	;R #2 bright color
     86  7869				  -	      .byte	%11011101
     87  7869				  -	      .byte	%11011101
     88  7869				  -			;.byte %00000000
     89  7869				  -	      .byte	%01100110
     90  7869				  -	      .byte	%01110111
     91  7869				  -	      .byte	%01110111
     92  7869				  -
     93  7869				  -	      .byte	%00000000
     94  7869				  -	      .byte	%10011001	;G #1 dark, dirt color
     95  7869				  -	      .byte	%11011101
     96  7869				  -			;.byte %11011101
     97  7869				  -	      .byte	%00000000
     98  7869				  -	      .byte	%01100110
     99  7869				  -	      .byte	%01110111
    100  7869				  -	      .byte	%01110111
    101  7869				  -
    102  7869				  -	      .byte	%10111011	;B #0 medium, mix color
    103  7869				  -	      .byte	%11111111
    104  7869				  -	      .byte	%11111111
    105  7869				  -	      .byte	%00000000
    106  7869				  -	      .byte	%11101110
    107  7869				  -	      .byte	%11111111
    108  7869				  -	      .byte	%11111111
    109  7869				  -			;.byte %00000000
    110  7869					      endif
    111  7869
    112  7869
    113  7869							;--------------------------------------------------------------------------
    114  7869					      if	MIRRORED_WALL = YES
      0  7869					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  7869					      LIST	ON
    116  7869				   CHARACTERSHAPE_WALL_MIRRORED
    117  7869				   CHARACTERSHAPE_WALL0_MIRRORED
    118  7869
    119  7869					      if	BRICK_WALL_DEF = 0
    120  7869		       00 ee ee 00*	      .byte.b	%00000000,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;R
    121  7870		       ee ee ee 00*	      .byte.b	%11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;G
    122  7877		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;B
    123  787e					      endif
    124  787e
    125  787e				  -	      if	BRICK_WALL_DEF = 1
    126  787e				  -	      .byte	%01100110	;R
    127  787e				  -	      .byte	%11101110
    128  787e				  -	      .byte	%11101110
    129  787e				  -	      .byte	%00000000
    130  787e				  -	      .byte	%10011001
    131  787e				  -	      .byte	%10111011
    132  787e				  -	      .byte	%10111011
    133  787e				  -
    134  787e				  -	      .byte	%01100110	;G
    135  787e				  -	      .byte	%11101110
    136  787e				  -	      .byte	%11101110
    137  787e				  -	      .byte	%00000000
    138  787e				  -	      .byte	%10011001
    139  787e				  -	      .byte	%10111011
    140  787e				  -	      .byte	%10111011
    141  787e				  -
    142  787e				  -	      .byte	%01100110	;B
    143  787e				  -	      .byte	%11101110
    144  787e				  -	      .byte	%00000000
    145  787e				  -	      .byte	%00000000
    146  787e				  -	      .byte	%10011001
    147  787e				  -	      .byte	%10111011
    148  787e				  -	      .byte	%00000000
    149  787e					      endif
    150  787e
    151  787e				  -	      if	BRICK_WALL_DEF = 2
    152  787e				  -	      .byte	%01100110	;R
    153  787e				  -	      .byte	%11101110
    154  787e				  -	      .byte	%11101110
    155  787e				  -	      .byte	%00000000
    156  787e				  -	      .byte	%10011001
    157  787e				  -	      .byte	%10111011
    158  787e				  -	      .byte	%10111011
    159  787e				  -
    160  787e				  -	      .byte	%11111111	;G #1 dark, dirt color
    161  787e				  -	      .byte	%11111111
    162  787e				  -	      .byte	%11111111
    163  787e				  -	      .byte	%11111111
    164  787e				  -	      .byte	%11111111
    165  787e				  -	      .byte	%11111111
    166  787e				  -	      .byte	%11111111
    167  787e				  -
    168  787e				  -	      .byte	%11111111	;B #0 medium, mix color
    169  787e				  -	      .byte	%11111111
    170  787e				  -	      .byte	%11111111
    171  787e				  -	      .byte	%11111111
    172  787e				  -	      .byte	%11111111
    173  787e				  -	      .byte	%11111111
    174  787e				  -	      .byte	%00000000
    175  787e					      endif
    176  787e
    177  787e				  -	      if	BRICK_WALL_DEF = 3
    178  787e				  -	      .byte	%00000000
    179  787e				  -	      .byte	%10011001	;R
    180  787e				  -	      .byte	%10111011
    181  787e				  -	      .byte	%10111011
    182  787e				  -			;.byte %00000000
    183  787e				  -	      .byte	%01100110
    184  787e				  -	      .byte	%11101110
    185  787e				  -	      .byte	%11101110
    186  787e				  -
    187  787e				  -	      .byte	%00000000
    188  787e				  -	      .byte	%10011001	;G
    189  787e				  -	      .byte	%10111011
    190  787e				  -			;.byte %10111011
    191  787e				  -	      .byte	%00000000
    192  787e				  -	      .byte	%01100110
    193  787e				  -	      .byte	%11101110
    194  787e				  -	      .byte	%11101110
    195  787e				  -
    196  787e				  -	      .byte	%11011101	;B
    197  787e				  -	      .byte	%11111111
    198  787e				  -	      .byte	%11111111
    199  787e				  -	      .byte	%00000000
    200  787e				  -	      .byte	%01110111
    201  787e				  -	      .byte	%11111111
    202  787e				  -	      .byte	%11111111
    203  787e				  -			;.byte %00000000
    204  787e					      endif
    205  787e
    206  787e					      endif
    207  787e
    208  787e
------- FILE BANK_FIXED.asm
------- FILE FireFly.asm LEVEL 3 PASS 3
      0  787e					      include	"FireFly.asm"	; 2 * LINES_PER_CHAR bytes
      1  787e		       00 02	   FIREFLY_DEF =	2
      2  787e
      3  787e				  -	      if	FIREFLY_DEF = 0
      4  787e				  -			;--------------------------------------------------------------------------
      5  787e				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FIREFLY", LINES_PER_CHAR
      6  787e				  -CHARACTERSHAPE_FIREFLY
      7  787e				  -	      .byte	%00000000,%00000000,%01100110,%01100110,%00000000,%00000000,%00000000	;R
      8  787e				  -	      .byte	%00000000,%00000000,%01100110,%01100110,%00000000,%00000000,%00000000	;G
      9  787e				  -	      .byte	%00000000,%01100110,%01100110,%01100110,%00000000,%00000000,%00000000	;B
     10  787e				  -
     11  787e				  -			;--------------------------------------------------------------------------
     12  787e				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FIREFLY2", LINES_PER_CHAR
     13  787e				  -CHARACTERSHAPE_FIREFLY2
     14  787e				  -	      .byte	%00000000,%11111111,%10011001,%10011001,%10011001,%11111111,%00000000	;R
     15  787e				  -	      .byte	%01100110,%10011001,%10011001,%10011001,%10011001,%01100110,%00000000	;G
     16  787e				  -	      .byte	%11111111,%10011001,%10011001,%10011001,%11111111,%00000000,%00000000	;B
     17  787e					      endif
     18  787e
     19  787e				  -	      if	FIREFLY_DEF = 1
     20  787e				  -			;--------------------------------------------------------------------------
     21  787e				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FIREFLY", LINES_PER_CHAR
     22  787e				  -CHARACTERSHAPE_FIREFLY
     23  787e				  -	      .byte	%11111111	; R (#3 bright, complementary color)
     24  787e				  -	      .byte	%11111111
     25  787e				  -	      .byte	%10011001
     26  787e				  -	      .byte	%10011001
     27  787e				  -	      .byte	%10011001
     28  787e				  -	      .byte	%11111111
     29  787e				  -	      .byte	%11111111
     30  787e				  -
     31  787e				  -	      .byte	%11111111	; G (#2 basic dirt color, usually the darkest one)
     32  787e				  -	      .byte	%11111111
     33  787e				  -	      .byte	%10011001
     34  787e				  -	      .byte	%10011001
     35  787e				  -	      .byte	%10011001
     36  787e				  -	      .byte	%11111111
     37  787e				  -	      .byte	%11111111
     38  787e				  -
     39  787e				  -	      .byte	%11111111	; B (#1 additional wall/boulder color)
     40  787e				  -	      .byte	%11111111
     41  787e				  -	      .byte	%10011001
     42  787e				  -	      .byte	%10011001
     43  787e				  -	      .byte	%10011001
     44  787e				  -	      .byte	%11111111
     45  787e				  -	      .byte	%11111111
     46  787e				  -
     47  787e				  -			;--------------------------------------------------------------------------
     48  787e				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FIREFLY2", LINES_PER_CHAR
     49  787e				  -CHARACTERSHAPE_FIREFLY2
     50  787e				  -	      .byte	%00000000	; R (#3 bright, complementary color)
     51  787e				  -	      .byte	%00000000
     52  787e				  -	      .byte	%01100110
     53  787e				  -	      .byte	%01100110
     54  787e				  -	      .byte	%01100110
     55  787e				  -	      .byte	%00000000
     56  787e				  -	      .byte	%00000000
     57  787e				  -
     58  787e				  -	      .byte	%11111111	; G (#2 basic dirt color, usually the darkest one)
     59  787e				  -	      .byte	%11111111
     60  787e				  -	      .byte	%11111111
     61  787e				  -	      .byte	%11111111
     62  787e				  -	      .byte	%11111111
     63  787e				  -	      .byte	%11111111
     64  787e				  -	      .byte	%11111111
     65  787e				  -
     66  787e				  -	      .byte	%11111111	; B (#1 additional wall/boulder color)
     67  787e				  -	      .byte	%11111111
     68  787e				  -	      .byte	%11111111
     69  787e				  -	      .byte	%11111111
     70  787e				  -	      .byte	%11111111
     71  787e				  -	      .byte	%11111111
     72  787e				  -	      .byte	%11111111
     73  787e					      endif
     74  787e
     75  787e					      if	FIREFLY_DEF = 2
     76  787e							;--------------------------------------------------------------------------
      0  787e					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FIREFLY", LINES_PER_CHAR
     10  787e					      LIST	ON
     78  787e				   CHARACTERSHAPE_FIREFLY
     79  787e		       ff		      .byte.b	%11111111	; R (#3 bright, complementary color)
     80  787f		       ff		      .byte.b	%11111111
     81  7880		       99		      .byte.b	%10011001
     82  7881		       99		      .byte.b	%10011001
     83  7882		       99		      .byte.b	%10011001
     84  7883		       99		      .byte.b	%10011001
     85  7884		       ff		      .byte.b	%11111111
     86  7885
     87  7885		       ff		      .byte.b	%11111111	; G (#2 basic dirt color, usually the darkest one)
     88  7886		       ff		      .byte.b	%11111111
     89  7887		       99		      .byte.b	%10011001
     90  7888		       99		      .byte.b	%10011001
     91  7889		       99		      .byte.b	%10011001
     92  788a		       ff		      .byte.b	%11111111
     93  788b		       ff		      .byte.b	%11111111
     94  788c
     95  788c		       ff		      .byte.b	%11111111	; B (#1 additional wall/boulder color)
     96  788d		       99		      .byte.b	%10011001
     97  788e		       99		      .byte.b	%10011001
     98  788f		       99		      .byte.b	%10011001
     99  7890		       99		      .byte.b	%10011001
    100  7891		       ff		      .byte.b	%11111111
    101  7892		       ff		      .byte.b	%11111111
    102  7893
    103  7893							;--------------------------------------------------------------------------
      0  7893					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FIREFLY2", LINES_PER_CHAR
     10  7893					      LIST	ON
    105  7893				   CHARACTERSHAPE_FIREFLY2
    106  7893		       00		      .byte.b	%00000000	; R (#3 bright, complementary color)
    107  7894		       00		      .byte.b	%00000000
    108  7895		       66		      .byte.b	%01100110
    109  7896		       66		      .byte.b	%01100110
    110  7897		       66		      .byte.b	%01100110
    111  7898		       66		      .byte.b	%01100110
    112  7899		       00		      .byte.b	%00000000
    113  789a
    114  789a		       00		      .byte.b	%00000000	; G (#2 basic dirt color, usually the darkest one)
    115  789b		       00		      .byte.b	%00000000
    116  789c		       66		      .byte.b	%01100110
    117  789d		       66		      .byte.b	%01100110
    118  789e		       66		      .byte.b	%01100110
    119  789f		       00		      .byte.b	%00000000
    120  78a0		       00		      .byte.b	%00000000
    121  78a1
    122  78a1		       ff		      .byte.b	%11111111	; B (#1 additional wall/boulder color)
    123  78a2		       ff		      .byte.b	%11111111
    124  78a3		       ff		      .byte.b	%11111111
    125  78a4		       ff		      .byte.b	%11111111
    126  78a5		       ff		      .byte.b	%11111111
    127  78a6		       ff		      .byte.b	%11111111
    128  78a7		       ff		      .byte.b	%11111111
    129  78a8					      endif
------- FILE BANK_FIXED.asm
     18  78a8
     19  78a8							;------------------------------------------------------------------------------
     20  78a8
      0  78a8					      DEFINE_SUBROUTINE	GetSurroundingChars	;=156[-28](C)
      1  78a8		       00 0f	   BANK_GetSurroundingChars =	_CURRENT_BANK
      2  78a8					      SUBROUTINE
      3  78a8				   GetSurroundingChars
     22  78a8							; TJ: used by:
     23  78a8							; - BANK_INITBANK.asm
     24  78a8
     25  78a8							; Retrieve the surrounding characters from the board around a given position.
     26  78a8							; These are placed into the Surround array with the indexes as shown...
     27  78a8
     28  78a8							; +------+------+------+
     29  78a8							; |*	  | a(0) |	|   *= where Temp_board_address1 points
     30  78a8							; +------+------+------+
     31  78a8							; | d(3) | X(4) | b(1) |
     32  78a8							; +------+------+------+
     33  78a8							; |	  | c(2) |	|
     34  78a8							; +------+------+------+
     35  78a8
     36  78a8							; X = ( POS_X,POS_Y )
     37  78a8							; IMPORTANT: The indexing is assumed in firefly/butterfly directional turning checks.
     38  78a8
     39  78a8		       a9 08		      lda	#BANK_GetBoardAddress4	;
     40  78aa		       85 3f		      sta	SET_BANK	;
     41  78ac		       20 e8 f0 	      jsr	GetBoardAddress4	;11+72[-16](C)
     42  78af
     43  78af		       85 3e		      sta	SET_BANK_RAM	;3
     44  78b1		       b3 df		      lax	(Temp_Board_Address1),y	;5
     45  78b3		       85 82		      sta	Surround	;3
     46  78b5
     47  78b5				  -	      IF	MULTI_BANK_BOARD = YES
     48  78b5				  -	      lda	Temp_Bank3	;3
     49  78b5				  -	      sta	SET_BANK_RAM	;3
     50  78b5					      ENDIF
     51  78b5		       b1 e3		      lda	(Temp_Board_Address3),y	;5
     52  78b7		       85 84		      sta	Surround+2	;3
     53  78b9
     54  78b9				  -	      IF	MULTI_BANK_BOARD = YES
     55  78b9				  -	      lda	Temp_Bank2	;3
     56  78b9				  -	      sta	SET_BANK_RAM	;3
     57  78b9					      ENDIF
     58  78b9		       b1 e1		      lda	(Temp_Board_Address2),y	;5
     59  78bb		       85 86		      sta	Surround+4	;3
     60  78bd
     61  78bd		       88		      dey		;2
     62  78be		       b1 e1		      lda	(Temp_Board_Address2),y	;5
     63  78c0		       85 85		      sta	Surround+3	;3
     64  78c2
     65  78c2		       c8		      iny		;2
     66  78c3		       c8		      iny		;2
     67  78c4		       b1 e1		      lda	(Temp_Board_Address2),y	;5
     68  78c6		       85 83		      sta	Surround+1	;3
     69  78c8
     70  78c8		       a5 c3		      lda	ROM_Bank	;3
     71  78ca		       85 3f		      sta	SET_BANK	;3
     72  78cc
     73  78cc							; returns: X = Surround
     74  78cc		       60		      rts		;6 = 156[-12]
     75  78cd
     76  78cd							;------------------------------------------------------------------------------
     77  78cd
      0  78cd					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  78cd		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  78cd					      SUBROUTINE
      3  78cd				   DrawTimeFromROM
     79  78cd							; TJ: used by:
     80  78cd							; - BANK_INITBANK.asm
     81  78cd
     82  78cd		       85 3e		      sta	SET_BANK_RAM
     83  78cf		       20 1a f3 	      jsr	DrawTime
     84  78d2		       85 3f		      sta	SET_BANK
     85  78d4		       60		      rts
     86  78d5
     87  78d5							;------------------------------------------------------------------------------
     88  78d5
      0  78d5					      DEFINE_SUBROUTINE	InsertBlankStack2	;=51(A)
      1  78d5		       00 0f	   BANK_InsertBlankStack2 =	_CURRENT_BANK
      2  78d5					      SUBROUTINE
      3  78d5				   InsertBlankStack2
     90  78d5							; TJ: used by:
     91  78d5							; - BANK_INITBANK.asm
     92  78d5
     93  78d5		       85 3e		      sta	SET_BANK_RAM	; 3
     94  78d7		       20 f0 f1 	      jsr	InsertBlankStack	; 6+30(A)
     95  78da		       a5 c3		      lda	ROM_Bank	; 3
     96  78dc		       85 3f		      sta	SET_BANK	; 3
     97  78de		       60		      rts		; 6
     98  78df
     99  78df							;------------------------------------------------------------------------------
    100  78df
    101  78df
      0  78df					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  78df		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  78df					      SUBROUTINE
      3  78df				   GetROMByte
    103  78df							; TJ: used by:
    104  78df							; - BANK_INITBANK.asm
    105  78df							; - DecodeCave.asm
    106  78df
    107  78df							; a = ROM bank to retrieve (NOTE: status negative flag important!!!!!!!)
    108  78df							; y = page index
    109  78df							; ROM_Bank = bank to return to
    110  78df							; (Board_AddressR) = page
    111  78df							; out a = byte from (Board_AddressR)
    112  78df
    113  78df		       85 3f		      sta	SET_BANK	;3
    114  78e1		       4c e6 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
    115  78e4
    116  78e4							;------------------------------------------------------------------------------
    117  78e4
      0  78e4					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  78e4		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  78e4					      SUBROUTINE
      3  78e4				   GetBoardCharacter
    119  78e4							; TJ: used by:
    120  78e4							; - BANK_INITBANK.asm
    121  78e4
    122  78e4							; call from ROM bank
    123  78e4							; switches back to ROM_Bank on exit
    124  78e4
    125  78e4							; pass A = bank containing character
    126  78e4							; Y = x character position
    127  78e4							; (Board_AddressR) points to character position
    128  78e4							; returns character from board
    129  78e4
    130  78e4
    131  78e4		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
    132  78e6
    133  78e6				   GetBoardCharacter2		;=17(A)
    134  78e6
    135  78e6		       b3 bf		      lax	(Board_AddressR),y	;5
    136  78e8		       a4 c3		      ldy	ROM_Bank	;3
    137  78ea		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
    138  78ec		       60		      rts		;6   and go back
    139  78ed
    140  78ed							;---------------------------------------------------------------------------
    141  78ed
      0  78ed					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  78ed		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  78ed					      SUBROUTINE
      3  78ed				   PutBoardCharacter
    143  78ed							; TJ: used by:
    144  78ed							; - BANK_INITBANK.asm
    145  78ed		       86 3e		      stx	SET_BANK_RAM	; 3
    146  78ef
    147  78ef				   PutBoardCharacterSB		; =18
    148  78ef		       91 c1		      sta	(Board_AddressW),y	; 6
    149  78f1		       a5 c3		      lda	ROM_Bank	; 3
    150  78f3		       85 3f		      sta	SET_BANK	; 3
    151  78f5		       60		      rts		; 6 = 21
    152  78f6
    153  78f6							;---------------------------------------------------------------------------
    154  78f6
      0  78f6					      DEFINE_SUBROUTINE	PutBoardCharacterButterfly	;=110(B)
      1  78f6		       00 0f	   BANK_PutBoardCharacterButterfly =	_CURRENT_BANK
      2  78f6					      SUBROUTINE
      3  78f6				   PutBoardCharacterButterfly
    156  78f6							; TJ: used by:
    157  78f6							; - BANK_INITBANK.asm
    158  78f6
    159  78f6
    160  78f6		       86 3e		      stx	SET_BANK_RAM	;3
    161  78f8		       91 c1		      sta	(Board_AddressW),y	;6
    162  78fa		       4c 4f fb 	      jmp	ReInsertObject	;3+98(B)
    163  78fd
    164  78fd							;------------------------------------------------------------------------------
    165  78fd
      0  78fd					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  78fd		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  78fd					      SUBROUTINE
      3  78fd				   GetBoardCharacter__CALL_FROM_RAM__
    167  78fd							; TJ: used by:
    168  78fd							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
    169  78fd							; - DecodeCave.asm
    170  78fd
    171  78fd		       a4 90		      ldy	POS_Y	;3
    172  78ff
    173  78ff		       a9 08		      lda	#BANK_GetBoardAddressR	;
    174  7901		       85 3f		      sta	SET_BANK	;
    175  7903		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    176  7906
    177  7906
      0  7906					      DEFINE_SUBROUTINE	PartialGetBoardCharacter	;=23
      1  7906		       00 0f	   BANK_PartialGetBoardCharacter =	_CURRENT_BANK
      2  7906					      SUBROUTINE
      3  7906				   PartialGetBoardCharacter
    179  7906							; TJ: used by:
    180  7906							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
    181  7906
    182  7906		       85 3e		      sta	SET_BANK_RAM	;3
    183  7908		       a4 8f		      ldy	POS_X	;3
    184  790a		       b3 bf		      lax	(Board_AddressR),y	;5
    185  790c		       a4 c4		      ldy	RAM_Bank	;3
    186  790e		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    187  7910		       60		      rts		;6		 and go back
    188  7911
    189  7911							;---------------------------------------------------------------------------
    190  7911
      0  7911					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  7911		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  7911					      SUBROUTINE
      3  7911				   PutBoardCharacterFromRAM
    192  7911							; TJ: used by:
    193  7911							; - BANK_INITBANK.asm
    194  7911							; - DecodeCave.asm
    195  7911
    196  7911							; POS_Y  = row
    197  7911							; POS_Type = character to write
    198  7911							; POS_X     = column
    199  7911							; RAM_Bank = caller's bank
    200  7911
    201  7911		       a4 90		      ldy	POS_Y	;3
    202  7913
    203  7913		       a9 08		      lda	#BANK_GetBoardAddressW	;
    204  7915		       85 3f		      sta	SET_BANK	;
    205  7917		       20 0d f1 	      jsr	GetBoardAddressW	;11+24[-2](A)
    206  791a
    207  791a		       86 3e		      stx	SET_BANK_RAM	;3
    208  791c
    209  791c		       a4 8f		      ldy	POS_X	;3
    210  791e		       a5 93		      lda	POS_Type	;3
    211  7920		       91 c1		      sta	(Board_AddressW),y	;6
    212  7922		       a4 c4		      ldy	RAM_Bank	;3
    213  7924		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    214  7926		       60		      rts		;6
    215  7927
    216  7927
    217  7927							;---------------------------------------------------------------------------
    218  7927
    219  7927							;  IF TJ_MODE
    220  7927							;; experimental code
    221  7927							;    DEFINE_SUBROUTINE GetRAMByteFromRAM ; = 19
    222  7927							;
    223  7927							;		  sty SET_BANK_RAM		      ; 3
    224  7927							;		  ldy #0			      ; 2
    225  7927							;		  lda (addressR),y		      ; 5
    226  7927							;		  stx SET_BANK_RAM		      ; 3     return to RAM caller
    227  7927							;		  rts				      ; 6
    228  7927							;
    229  7927							;    ;---------------------------------------------------------------------------
    230  7927							;
    231  7927							;    DEFINE_SUBROUTINE PutRAMByteFromRAM ; = 20
    232  7927							;
    233  7927							;		  sty SET_BANK_RAM		      ; 3
    234  7927							;		  ldy #0			      ; 2
    235  7927							;		  sta (addressW),y		      ; 6
    236  7927							;		  stx SET_BANK_RAM		      ; 3     return to RAM caller
    237  7927							;		  rts				      ; 6
    238  7927							;
    239  7927							;    ;---------------------------------------------------------------------------
    240  7927							;  ENDIF
    241  7927
    242  7927
    243  7927							;---------------------------------------------------------------------------
    244  7927
    245  7927
      0  7927					      DEFINE_SUBROUTINE	ProcessObjStack	; 15 minimum segtime abort
      1  7927		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  7927					      SUBROUTINE
      3  7927				   ProcessObjStack
    247  7927							; TJ: used by:
    248  7927							; - BANK_FIXED.asm
    249  7927
    250  7927		       ad 84 02 	      lda	INTIM	;4
    251  792a		       c9 04		      cmp	#MINIMUM_SEGTIME	;2
    252  792c		       90 55		      bcc	EarlyAbort	;2/3= 8
      0  792e					      STRESS_TIME	MINIMUM_SEGTIME
      1  792e				  -	      IF	TEST_MINIMUM_SEGTIME = 1
      2  792e				  -
      3  792e				  -
      4  792e				  -
      5  792e				  -
      6  792e				  -
      7  792e				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  792e				  -	      bne	. - 7
      9  792e					      ENDIF
    254  792e
    255  792e		       a5 8a		      lda	ObjStackNum	;3
    256  7930		       49 01		      eor	#1	;2
    257  7932		       aa		      tax		;2
    258  7933
    259  7933		       a5 dd		      lda	ObjIterator	;3
    260  7935		       d5 8b		      cmp	ObjStackPtr,x	;5
    261  7937		       b0 2e		      bcs	doBlanks	;2/3		check for blanks
    262  7939
    263  7939							; Process an object...
    264  7939							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    265  7939
    266  7939		       bc ac fb 	      ldy	BankObjStack,x	;4
    267  793c		       84 3e		      sty	SET_BANK_RAM	;3
    268  793e
    269  793e		       aa		      tax		;2
    270  793f		       bc 80 11 	      ldy	SortedObjPtr,x	;4		 indirect object pointer list (sorted)
    271  7942
    272  7942		       b9 00 10 	      lda	ObjStackX,y	;4
    273  7945		       85 8f		      sta	POS_X	;3
    274  7947		       b9 80 10 	      lda	ObjStackY,y	;4
    275  794a		       85 90		      sta	POS_Y	;3
    276  794c		       b9 00 11 	      lda	ObjStackVar,y	;4
    277  794f		       85 94		      sta	POS_VAR	;3
    278  7951		       be 00 12 	      ldx	ObjStackType,y	;4
    279  7954		       86 93		      stx	POS_Type	;3
    280  7956
    281  7956		       a9 08		      lda	#BANK_VectorProcess	;2
    282  7958		       85 3f		      sta	SET_BANK	;3
    283  795a
    284  795a		       bd da f6 	      lda	OSPointerHI,x	;4
    285  795d		       85 e0		      sta	POS_Vector+1	;3
    286  795f		       bd cd f6 	      lda	OSPointerLO,x	;4
    287  7962		       85 df		      sta	POS_Vector	;3
    288  7964
    289  7964		       6c df 00 	      jmp	(POS_Vector)	;5 = 82	 vector to processor for particular object type
    290  7967
    291  7967
    292  7967							;---------------------------------------------------------------------------
    293  7967							; Now process the blank stack.  This stack holds all the recently blanked squares
    294  7967							; and determines (and moves) boulders or diamonds into these squares.	The space vacated
    295  7967							; by these objects are added again to the blank stack.
    296  7967
    297  7967		       e6 8e	   doBlanks   inc	ScreenDrawPhase
    298  7969		       a4 8d		      ldy	BlankStackPtr	; 3
    299  796b		       f0 14		      beq	nextPhase	; 2/3		 blanks finished!!
    300  796d
      0  796d					      DEFINE_SUBROUTINE	ProcessBlankStack	;=892
      1  796d		       00 0f	   BANK_ProcessBlankStack =	_CURRENT_BANK
      2  796d					      SUBROUTINE
      3  796d				   ProcessBlankStack
    302  796d
    303  796d		       ad 84 02 	      lda	INTIM	;4
    304  7970		       c9 10		      cmp	#MINIMUM_SEGTIMEBLANK	;2
    305  7972		       90 0f		      bcc	EarlyAbort	;2/3
      0  7974					      STRESS_TIME	MINIMUM_SEGTIMEBLANK
      1  7974				  -	      IF	TEST_MINIMUM_SEGTIMEBLANK = 1
      2  7974				  -
      3  7974				  -
      4  7974				  -
      5  7974				  -
      6  7974				  -
      7  7974				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7974				  -	      bne	. - 7
      9  7974					      ENDIF
    307  7974
    308  7974		       a9 08		      lda	#BANK_DRAW_BUFFERS	;2
    309  7976		       85 3e		      sta	SET_BANK_RAM	;3
    310  7978		       85 c4		      sta	RAM_Bank	;3
    311  797a		       20 93 f2 	      jsr	BlankCreatureInsertion	;6+853
    312  797d
    313  797d		       c6 8d	   NextBlank  dec	BlankStackPtr	;5		 one less object on the blank stack
    314  797f		       d0 ec		      bne	ProcessBlankStack	;2/3
    315  7981
    316  7981		       e6 8e	   nextPhase  inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    317  7983		       60	   EarlyAbort rts		;6
    318  7984
    319  7984
    320  7984
    321  7984							;---------------------------------------------------------------------------
    322  7984
      0  7984					      DEFINE_SUBROUTINE	SwitchObjects	;=72
      1  7984		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  7984					      SUBROUTINE
      3  7984				   SwitchObjects
    324  7984							; TJ: used by:
    325  7984							; - BANK_FIXED.asm
    326  7984
    327  7984							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    328  7984							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    329  7984							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    330  7984
    331  7984		       ad 84 02 	      lda	INTIM	; 4
    332  7987		       c9 03		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    333  7989		       90 f8		      bcc	EarlyAbort	; 2/3= 8
      0  798b					      STRESS_TIME	SEGTIME_SWITCHOBJECTS
      1  798b				  -	      IF	TEST_SEGTIME_SWITCHOBJECTS = 1
      2  798b				  -
      3  798b				  -
      4  798b				  -
      5  798b				  -
      6  798b				  -
      7  798b				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  798b				  -	      bne	. - 7
      9  798b					      ENDIF
    335  798b
    336  798b							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    337  798b							; we're at the throttle cutoff do we switch game-frames.
    338  798b
    339  798b							;sec
    340  798b		       a5 b3		      lda	Throttle	;3
    341  798d		       e9 a0		      sbc	#MAX_THROTTLE	;2
    342  798f		       90 f2		      bcc	EarlyAbort	;2/3		 plenty of time left!
    343  7991
    344  7991							; Time is up. But we may be in a cave which requires perfect sorting (e.g., intermission 4)
    345  7991							; So we check for these caves, and wait for the sort to complete for those.
    346  7991
    347  7991		       24 b2		      bit	caveDisplay	;3
    348  7993		       50 08		      bvc	keepFractional	;2/3		 screen does not require complete sort
    349  7995
    350  7995							; We have an intermission or screen which requires the sort to go to completion
    351  7995							; Check to see if the sort is finished...
    352  7995
    353  7995		       a4 d4		      ldy	sortPtr	;3
    354  7997		       d0 ea		      bne	EarlyAbort	;2/3		 sort still in progress, so wait
    355  7999		       a4 d3		      ldy	sortRequired	;3
    356  799b		       10 e6		      bpl	EarlyAbort	;2/3		 sort still in progress, so wait
    357  799d
    358  799d		       85 b3	   keepFractional sta	Throttle	;3		 save fractional 'left over' bit
    359  799f
    360  799f
    361  799f							; Pause the game with B/W switch:
    362  799f
    363  799f		       a5 80		      lda	gameMode
    364  79a1							;		  ora LookingAround		  ; New behavour of looking around pauses creatures when activated.
    365  79a1		       30 14		      bmi	.paused	; pause flag set
    366  79a3
    367  79a3							; Now that we have completed processing both the object and blanks stacks, we switch
    368  79a3							; the stack bank pointers for the next time around.
    369  79a3
    370  79a3		       a5 8a		      lda	ObjStackNum	;3
    371  79a5		       49 01		      eor	#1	;2
    372  79a7		       aa		      tax		;2
    373  79a8		       86 8a		      stx	ObjStackNum	;3		 swap stacks @here
    374  79aa
    375  79aa							; STOP the sort so it doesn't corrupt the "other" object stack. Sort may get a look-in immediately after
    376  79aa							; this code is finished, so we don't want it to do something unexpected!
    377  79aa
    378  79aa		       a0 ff		      ldy	#<(-1)	;2
    379  79ac		       84 d3		      sty	sortRequired	;3
    380  79ae		       c8		      iny		;2		 Y==0
    381  79af		       84 d4		      sty	sortPtr	;3
    382  79b1
    383  79b1							; Initialise the iterator and stack pointer for next time around.
    384  79b1							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    385  79b1							; necessary to initialise both.
    386  79b1
    387  79b1		       84 dd		      sty	ObjIterator	;3		 Y==0
    388  79b3		       94 8b		      sty	ObjStackPtr,x	;4
    389  79b5
    390  79b5		       84 8e		      sty	ScreenDrawPhase	;3
    391  79b7				   .paused
    392  79b7		       60	   quickExit  rts		;6
    393  79b8
    394  79b8							;---------------------------------------------------------------------------
    395  79b8
      0  79b8					      DEFINE_SUBROUTINE	PROCESS_EXPLOSION
      1  79b8		       00 0f	   BANK_PROCESS_EXPLOSION =	_CURRENT_BANK
      2  79b8					      SUBROUTINE
      3  79b8				   PROCESS_EXPLOSION
    397  79b8							; TJ: used by:
    398  79b8							; - BANK_INITBANK.asm
    399  79b8
    400  79b8		       ad 84 02 	      lda	INTIM
    401  79bb		       c9 07		      cmp	#SEGTIME_EXPLOSION
    402  79bd		       90 c4		      bcc	EarlyAbort
      0  79bf					      STRESS_TIME	SEGTIME_EXPLOSION
      1  79bf				  -	      IF	TEST_SEGTIME_EXPLOSION = 1
      2  79bf				  -
      3  79bf				  -
      4  79bf				  -
      5  79bf				  -
      6  79bf				  -
      7  79bf				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  79bf				  -	      bne	. - 7
      9  79bf					      ENDIF
    404  79bf
    405  79bf		       a9 08		      lda	#BANK_ProcessExplosion	; 2
    406  79c1		       85 3f		      sta	SET_BANK	; 3
    407  79c3		       20 1a f1 	      jsr	ProcessExplosion	; 6+x
    408  79c6
    409  79c6		       4c 52 fb 	      jmp	NextObject
    410  79c9
    411  79c9							;---------------------------------------------------------------------------
    412  79c9
      0  79c9					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  79c9		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  79c9					      SUBROUTINE
      3  79c9				   PROCESS_MAN
    414  79c9							; TJ: used by:
    415  79c9							; - BANK_INITBANK.asm
    416  79c9
    417  79c9		       ad 84 02 	      lda	INTIM
    418  79cc		       c9 18		      cmp	#SEGTIME_MAN
    419  79ce		       90 b3		      bcc	EarlyAbort
      0  79d0					      STRESS_TIME	SEGTIME_MAN
      1  79d0				  -	      IF	TEST_SEGTIME_MAN = 1
      2  79d0				  -
      3  79d0				  -
      4  79d0				  -
      5  79d0				  -
      6  79d0				  -
      7  79d0				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  79d0				  -	      bne	. - 7
      9  79d0					      ENDIF
    421  79d0
    422  79d0		       a9 03		      lda	#BANK_GetJoystickForDemoMode
    423  79d2		       85 3f		      sta	SET_BANK
    424  79d4		       20 18 f4 	      jsr	GetJoystickForDemoMode	; 2 player/2 joysticks
    425  79d7
    426  79d7		       a9 08		      lda	#BANK_ManProcess
    427  79d9		       85 c3		      sta	ROM_Bank
    428  79db		       85 3f		      sta	SET_BANK
    429  79dd		       20 a6 f3 	      jsr	ManProcess
    430  79e0
    431  79e0		       20 ae fb 	      jsr	MovePlayer	; 6+{}
    432  79e3
    433  79e3		       a5 dc		      lda	specialTimeFlag
    434  79e5		       10 d0		      bpl	quickExit	; time problem (e.g., bigbang)
    435  79e7
    436  79e7		       a9 03		      lda	#BANK_AdvanceJoystick	;
    437  79e9		       85 3f		      sta	SET_BANK	;
    438  79eb		       20 00 f4 	      jsr	AdvanceJoystick	;11+49      2 player/2 joysticks
    439  79ee
    440  79ee		       a9 07		      lda	#BANK_TrackPlayer	;
    441  79f0		       85 3f		      sta	SET_BANK	;
    442  79f2		       20 a0 f5 	      jsr	TrackPlayer	;11+145
    443  79f5
    444  79f5		       a9 00		      lda	#TYPE_MAN	; 2
    445  79f7		       85 93		      sta	POS_Type	; 3
    446  79f9
    447  79f9		       20 7c fb 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    448  79fc		       4c 52 fb    gnobj      jmp	NextObject
    449  79ff
    450  79ff							;---------------------------------------------------------------------------
    451  79ff
      0  79ff					      DEFINE_SUBROUTINE	BlankOriginalLocation	;=93[-2](A)
      1  79ff		       00 0f	   BANK_BlankOriginalLocation =	_CURRENT_BANK
      2  79ff					      SUBROUTINE
      3  79ff				   BlankOriginalLocation
    453  79ff							; TJ: used by:
    454  79ff							; - BANK_FIXED.asm
    455  79ff							; - BANK_INITBANK.asm
    456  79ff
    457  79ff		       a6 90		      ldx	POS_Y	;3
    458  7a01		       a4 8f		      ldy	POS_X	;3
    459  7a03
      0  7a03					      DEFINE_SUBROUTINE	BlankOriginalLocationXY	;=87[-2](A)
      1  7a03		       00 0f	   BANK_BlankOriginalLocationXY =	_CURRENT_BANK
      2  7a03					      SUBROUTINE
      3  7a03				   BlankOriginalLocationXY
    461  7a03
    462  7a03		       a9 08		      lda	#BANK_BoardLineStartLO	;2
    463  7a05		       85 3f		      sta	SET_BANK	;3
    464  7a07
    465  7a07		       bd 01 f0 	      lda	BoardLineStartLO,x	;4
    466  7a0a		       85 c1		      sta	Board_AddressW	;3
    467  7a0c		       bd 2d f0 	      lda	BoardLineStartHiW,x	;4
    468  7a0f		       85 c2		      sta	Board_AddressW+1	;3 WRITE address
    469  7a11				  -	      IF	MULTI_BANK_BOARD = YES
    470  7a11				  -	      lda	BoardBank,x	;4 switch this on return
    471  7a11					      ELSE
    472  7a11		       a9 0d		      lda	#BANK_BOARD	;2
    473  7a13					      ENDIF
    474  7a13		       85 3e		      sta	SET_BANK_RAM	;3
    475  7a15
    476  7a15		       a9 00		      lda	#CHARACTER_BLANK	;2
    477  7a17		       91 c1		      sta	(Board_AddressW),y	;6 clear vacated board position
    478  7a19
    479  7a19		       a9 08		      lda	#BANK_DRAW_BUFFERS	;2
    480  7a1b		       85 3e		      sta	SET_BANK_RAM	;3
    481  7a1d		       20 f0 f1 	      jsr	InsertBlankStack	;6+30(A)
    482  7a20
    483  7a20		       a5 c3		      lda	ROM_Bank	;3
    484  7a22		       85 3f		      sta	SET_BANK	;3
    485  7a24
    486  7a24				   EarlyAbortBoulder
    487  7a24
    488  7a24		       60		      rts		;6
    489  7a25
    490  7a25							;---------------------------------------------------------------------------
    491  7a25
    492  7a25							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    493  7a25							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    494  7a25
    495  7a25							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    496  7a25
    497  7a25							; if the creature dies then jump NextObject
    498  7a25
    499  7a25
      0  7a25					      DEFINE_SUBROUTINE	PROCESS_BOULDER
      1  7a25		       00 0f	   BANK_PROCESS_BOULDER =	_CURRENT_BANK
      2  7a25					      SUBROUTINE
      3  7a25				   PROCESS_BOULDER
      0  7a25					      DEFINE_SUBROUTINE	PROCESS_DIAMOND
      1  7a25		       00 0f	   BANK_PROCESS_DIAMOND =	_CURRENT_BANK
      2  7a25					      SUBROUTINE
      3  7a25				   PROCESS_DIAMOND
    502  7a25							; TJ: used by:
    503  7a25							; - BANK_INITBANK.asm
    504  7a25
    505  7a25		       ad 84 02 	      lda	INTIM	;4
    506  7a28		       c9 05		      cmp	#SEGTIME_BOULDER1	;2
    507  7a2a		       90 f8		      bcc	EarlyAbortBoulder	;2/3
      0  7a2c					      STRESS_TIME	SEGTIME_BOULDER1
      1  7a2c				  -	      IF	TEST_SEGTIME_BOULDER1 = 1
      2  7a2c				  -
      3  7a2c				  -
      4  7a2c				  -
      5  7a2c				  -
      6  7a2c				  -
      7  7a2c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7a2c				  -	      bne	. - 7
      9  7a2c					      ENDIF
    509  7a2c
    510  7a2c		       a5 8f		      lda	POS_X	;3
    511  7a2e		       85 91		      sta	POS_X_NEW	;3
    512  7a30		       a4 90		      ldy	POS_Y	;3
    513  7a32		       84 92		      sty	POS_Y_NEW	;3
    514  7a34
    515  7a34							; Make sure the character we're working with is still the same type of object
    516  7a34							; (for example, a 'boulder' placed on the object stack by the blank stack
    517  7a34							; handler, may no longer be there, so it's really a dummy).
    518  7a34
    519  7a34							;ldy POS_Y			  ;3
    520  7a34
    521  7a34		       a9 08		      lda	#BANK_GetBoardAddressR	;
    522  7a36		       85 3f		      sta	SET_BANK	;
    523  7a38		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    524  7a3b		       85 3e		      sta	SET_BANK_RAM	;3
    525  7a3d
    526  7a3d		       a4 8f		      ldy	POS_X	;3
    527  7a3f		       b3 bf		      lax	(Board_AddressR),y	;5
    528  7a41		       bd 7a fe 	      lda	CharToType,x	;4
    529  7a44		       c5 93		      cmp	POS_Type	;3
    530  7a46		       d0 b4		      bne	gnobj	;2/3
    531  7a48
    532  7a48							; Test immediately under the current object.
    533  7a48							;  If there's something we can fall on, then we *do*.
    534  7a48
    535  7a48		       a4 90		      ldy	POS_Y	;3
    536  7a4a		       c8		      iny		;2
    537  7a4b
    538  7a4b		       a9 08		      lda	#BANK_GetBoardAddressR	;
    539  7a4d		       85 3f		      sta	SET_BANK	;
    540  7a4f		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    541  7a52		       85 3e		      sta	SET_BANK_RAM	;3
    542  7a54
    543  7a54		       a4 8f		      ldy	POS_X	;3
    544  7a56		       b3 bf		      lax	(Board_AddressR),y	;5		 checking immediately below
    545  7a58		       f0 17		      beq	FallForSure	;2/3		 always fall into blank
    546  7a5a
    547  7a5a							; ... unless we were just generated, in which case we don't fall
    548  7a5a							; (prevents falling on a butterfly and causing chain reaction)
    549  7a5a
    550  7a5a		       a5 94		      lda	POS_VAR	;3
    551  7a5c		       0a		      asl		;2
    552  7a5d		       30 69		      bmi	NotStraightDown	;2/3
    553  7a5f
    554  7a5f		       bd 3d fe 	      lda	GenericCharFlag,x	;4
    555  7a62		       29 02		      and	#GENERIC_MASK_SQUASHABLE	;2		 can this object be fallen upon?
    556  7a64		       f0 62		      beq	NotStraightDown	;3(2)		 NOT squashable
    557  7a66
    558  7a66
    559  7a66							; OK, we could be falling on a magic wall.  If we are, then we actually end up
    560  7a66							; two characters below (if it is blank).
    561  7a66
    562  7a66		       bd 3d fe 	      lda	GenericCharFlag,x	;4
    563  7a69		       29 20		      and	#GENERIC_MASK_MAGICWALL	;2		 magic wall chars
    564  7a6b		       d0 14		      bne	doMagicWall	;2/3
    565  7a6d
    566  7a6d		       a5 94		      lda	POS_VAR	;3
    567  7a6f		       10 57		      bpl	NotStraightDown	;2/3		 don't fall on anything if we weren't already falling
    568  7a71
    569  7a71		       e6 92	   FallForSure inc	POS_Y_NEW	;5		 object to move straight down
    570  7a73		       4c 24 fb 	      jmp	BlankDown	;3		 unconditional
    571  7a76
    572  7a76		       a5 93	   FallForSure2 lda	POS_Type
    573  7a78		       49 04		      eor	#TYPE_DIAMOND^TYPE_BOULDER
    574  7a7a		       85 93		      sta	POS_Type
    575  7a7c		       e6 92		      inc	POS_Y_NEW
    576  7a7e		       4c 24 fb 	      jmp	BlankDown
    577  7a81
    578  7a81				   doMagicWall
    579  7a81							; only fall into magic wall if we are already falling... and if so
    580  7a81							; and the magic wall isn't turned on, turn it on.
    581  7a81
    582  7a81		       a5 94		      lda	POS_VAR	; 3
    583  7a83		       10 43		      bpl	NotStraightDown	; 2(3)  disallow objects not already falling
    584  7a85
    585  7a85		       a6 9d		      ldx	MagicAmoebaFlag	; 3
    586  7a87		       f0 38		      beq	WallExp	; 2(3)
    587  7a89		       e8		      inx		; 2	 $ff = MAGIC_WALL_DORMANT?
    588  7a8a		       d0 16		      bne	ActiveWall	; 2(3)
    589  7a8c		       a5 b5		      lda	magicAmoebaTime	; 2	 was wall active before?
    590  7a8e		       f0 31		      beq	WallExp	; 2(3)
    591  7a90
    592  7a90		       85 9d		      sta	MagicAmoebaFlag	; 3	 start the timer
    593  7a92		       86 b5		      stx	magicAmoebaTime	; 3	 prevent restart
    594  7a94
      0  7a94					      START_SOUND	SOUND_MAGIC_WALL	;	 start the magic wall sound
      1  7a94					      SUBROUTINE
      2  7a94		       a5 db		      lda	newSounds
      3  7a96				  -	      IF	SOUND_MAGIC_WALL < 16
      4  7a96				  -	      and	#SND_MASK_LO
      5  7a96				  -	      cmp	#SOUND_MOVE_SOIL+1
      6  7a96				  -	      bcs	.skipNew
      7  7a96					      ELSE
      8  7a96		       29 f0		      and	#SND_MASK_HI
      9  7a98		       c9 30		      cmp	#(SOUND_MOVE_SOIL+1)<<4
     10  7a9a		       b0 06		      bcs	.skipNew
     11  7a9c
     12  7a9c					      ENDIF
     13  7a9c		       45 db		      eor	newSounds
     14  7a9e		       09 40		      ora	#SOUND_MAGIC_WALL
     15  7aa0		       85 db		      sta	newSounds
     16  7aa2				   .skipNew
     17  7aa2					      SUBROUTINE
    596  7aa2
    597  7aa2				   ActiveWall
    598  7aa2
    599  7aa2							; We must prevent an action which has no 'reversibility' -- that is, don't remove a diamond/boulder
    600  7aa2							; and then find out we're out of time.  Actions must be "units" indivisible.  So we do a segtime check
    601  7aa2							; first, to guarantee we have enough time.
    602  7aa2
    603  7aa2		       ad 84 02 	      lda	INTIM
    604  7aa5		       c9 09		      cmp	#SEGTIME_MAGIC
    605  7aa7		       90 1e		      bcc	NotEnoughTime2	; otherwise we have disappearing diamonds due to segtime aborts
    606  7aa9
    607  7aa9		       e6 92		      inc	POS_Y_NEW	; moves 2 squares
    608  7aab
    609  7aab							; The following was the cause of the missing diamonds in, for example, INT4. The issue is that
    610  7aab							; we remove the original diamond, branch to FallForSure, which then says "aha, not enough time!" and
    611  7aab							; aborts the object. But it's not on the board anymore, and so it disappears!	The solution, just
    612  7aab							; removing this line, is OK because actually the original location is already blanked in the code after
    613  7aab							; FallForSure... so this was a duplicate anyway.  In short, you can't abort halfway through an irreversible
    614  7aab							; action (like removing an object).
    615  7aab
    616  7aab							;jsr BlankOriginalLocation	  ;6+97(A)	      blank/stack previous position
    617  7aab
    618  7aab							; Check to see if the new position is available (=blank).  If not, object disappears
    619  7aab
    620  7aab		       a4 90		      ldy	POS_Y
    621  7aad		       c8		      iny
    622  7aae		       c8		      iny
    623  7aaf
    624  7aaf		       a9 08		      lda	#BANK_GetBoardAddressR	;
    625  7ab1		       85 3f		      sta	SET_BANK	;
    626  7ab3		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    627  7ab6		       85 3e		      sta	SET_BANK_RAM	;3
    628  7ab8
    629  7ab8		       a4 8f		      ldy	POS_X
    630  7aba		       b1 bf		      lda	(Board_AddressR),y
    631  7abc		       f0 b8		      beq	FallForSure2
    632  7abe		       4c d6 fa 	      jmp	ReplaceFallingChar	; become a 'normal' boulder/diamond
    633  7ac1
    634  7ac1		       20 ff f9    WallExp    jsr	BlankOriginalLocation	;6+97(A)	 blank/stack previous position
    635  7ac4		       4c 52 fb 	      jmp	NextObject	; 3	       object simply disappears
    636  7ac7
    637  7ac7
    638  7ac7				   NotEnoughTime2
    639  7ac7		       60		      rts
    640  7ac8
    641  7ac8				   NotStraightDown
    642  7ac8		       ad 84 02 	      lda	INTIM
    643  7acb		       c9 08		      cmp	#SEGTIME_BOULDER3
    644  7acd		       90 f8		      bcc	NotEnoughTime2
      0  7acf					      STRESS_TIME	SEGTIME_BOULDER3
      1  7acf				  -	      IF	TEST_SEGTIME_BOULDER3 = 1
      2  7acf				  -
      3  7acf				  -
      4  7acf				  -
      5  7acf				  -
      6  7acf				  -
      7  7acf				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7acf				  -	      bne	. - 7
      9  7acf					      ENDIF
    646  7acf
    647  7acf				   ProcessBD
    648  7acf
    649  7acf							; Depending on the character UNDER this object (since this object can't fall straight
    650  7acf							; down), we either fall sideways or not.  Currently we fall if the object we are
    651  7acf							; on top of is a 'rounded' object AND the two sideways squares are blank.
    652  7acf
    653  7acf							; Note that the object under us may be a NON-ROUNDED (=FALLING) boulder/diamond
    654  7acf
    655  7acf		       bd 3d fe 	      lda	GenericCharFlag,x	; is the object we're sitting on 'rounded'?
    656  7ad2		       29 01		      and	#GENERIC_MASK_ROUNDED
    657  7ad4		       d0 1a		      bne	mayRoundOff
    658  7ad6
    659  7ad6							; Could have been FALLING character/object type, so replace with a default character on the board
    660  7ad6
    661  7ad6				   ReplaceFallingChar
    662  7ad6
    663  7ad6		       a4 90		      ldy	POS_Y
    664  7ad8
    665  7ad8		       a9 08		      lda	#BANK_GetBoardAddressW	;
    666  7ada		       85 3f		      sta	SET_BANK	;
    667  7adc		       20 0d f1 	      jsr	GetBoardAddressW	;11+24[-2](A)
    668  7adf		       86 3e		      stx	SET_BANK_RAM	;3
    669  7ae1
    670  7ae1		       a4 8f		      ldy	POS_X
    671  7ae3		       a6 93		      ldx	POS_Type
    672  7ae5		       bd 58 fe 	      lda	BaseTypeCharacter,x	; original character base character
    673  7ae8		       91 c1		      sta	(Board_AddressW),y	; draw object in new location (Y = new X posn)
    674  7aea
    675  7aea							; We have just...
    676  7aea							; a) Rolled off a rounded object, or...  (TJ, TODO: Original makes no sound here)
    677  7aea							; b) Hit an object which we can't squash
    678  7aea							; So, play a terminating sound but only if the object was already falling
    679  7aea
    680  7aea		       20 57 fb 	      jsr	StartSoundCheckAlreadyFalling
    681  7aed				   silentAlways
    682  7aed		       4c 52 fb    wasNotFalling jmp	NextObject	; no, so we can't roll off it. Object becomes quiescent.
    683  7af0
    684  7af0							; The object underneath is rounded, so we may roll off it.  We preferentially roll
    685  7af0							; to the left.  Rolling involves moving sideways if the square to the side is blank AND
    686  7af0							; the one below that one is squashable.  Here we get the 4 squares which will be
    687  7af0							; involved in the calcs...
    688  7af0				   mayRoundOff		; y == POS_X
    689  7af0		       88		      dey
    690  7af1		       b1 bf		      lda	(Board_AddressR),y	; leftward of row UNDERNEATH
    691  7af3		       85 df		      sta	BoulderLeft
    692  7af5		       c8		      iny
    693  7af6		       c8		      iny
    694  7af7		       b1 bf		      lda	(Board_AddressR),y
    695  7af9		       85 e0		      sta	BoulderRight	; rightward of row UNDERNEATH
    696  7afb
    697  7afb		       a4 90		      ldy	POS_Y
    698  7afd
    699  7afd		       a9 08		      lda	#BANK_GetBoardAddressR	;
    700  7aff		       85 3f		      sta	SET_BANK	;
    701  7b01		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    702  7b04		       85 3e		      sta	SET_BANK_RAM	;3
    703  7b06
    704  7b06		       a4 8f		      ldy	POS_X
    705  7b08		       88		      dey
    706  7b09		       b1 bf		      lda	(Board_AddressR),y	; leftward of current row
    707  7b0b
    708  7b0b		       05 df		      ora	BoulderLeft	; check for the movement left/down
    709  7b0d		       d0 04		      bne	MayRollRight	; there must be NOTHING in the left squares
    710  7b0f
    711  7b0f		       c6 91		      dec	POS_X_NEW	; new position (LEFT)
    712  7b11		       10 0a		      bpl	BlankDownSound	; unconditional
    713  7b13
    714  7b13				   MayRollRight
    715  7b13
    716  7b13							; check for the movement right/down
    717  7b13		       c8		      iny
    718  7b14		       c8		      iny
    719  7b15		       b1 bf		      lda	(Board_AddressR),y	; rightward of current row
    720  7b17		       05 e0		      ora	BoulderRight
    721  7b19		       d0 bb		      bne	ReplaceFallingChar	; there must be NOTHING in the right squares
    722  7b1b
    723  7b1b		       e6 91		      inc	POS_X_NEW	; new position (RIGHT)
    724  7b1d
    725  7b1d				   BlankDownSound
    726  7b1d
    727  7b1d		       20 57 fb 	      jsr	StartSoundCheckAlreadyFalling	; prevent a sound if the object wasn't already falling
    728  7b20		       a9 80		      lda	#VAR_FALLING	; this prevents a sound in the following
    729  7b22		       85 94		      sta	POS_VAR	; ...call to StartSoundCheckFalling
    730  7b24
    731  7b24				   BlankDown
    732  7b24
    733  7b24		       ad 84 02 	      lda	INTIM
    734  7b27		       c9 07		      cmp	#SEGTIME_BOULDER4
    735  7b29		       90 50		      bcc	NotEnoughTime
      0  7b2b					      STRESS_TIME	SEGTIME_BOULDER4
      1  7b2b				  -	      IF	TEST_SEGTIME_BOULDER4 = 1
      2  7b2b				  -
      3  7b2b				  -
      4  7b2b				  -
      5  7b2b				  -
      6  7b2b				  -
      7  7b2b				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7b2b				  -	      bne	. - 7
      9  7b2b					      ENDIF
    737  7b2b
    738  7b2b							; The object is 'falling' into position (POS_X_NEW,POS_Y_NEW)
    739  7b2b							; object starts falling, so we play a sound here too:
    740  7b2b
    741  7b2b		       a9 7f		      lda	#<(~VAR_FALLING)	; do not start if already falling
    742  7b2d		       20 59 fb 	      jsr	StartSoundCheckFalling
    743  7b30
    744  7b30		       a9 80		      lda	#VAR_FALLING
    745  7b32		       85 94		      sta	POS_VAR
    746  7b34
    747  7b34							;lda POS_VAR
    748  7b34							;ora #VAR_FALLING
    749  7b34							;sta POS_VAR			      ; indicate object *is* falling
    750  7b34
    751  7b34		       20 ff f9 	      jsr	BlankOriginalLocation	;6+97(A)	 blank/stack previous position
    752  7b37
    753  7b37		       a4 92		      ldy	POS_Y_NEW
    754  7b39		       84 90		      sty	POS_Y
    755  7b3b
    756  7b3b		       a9 08		      lda	#BANK_GetBoardAddressW	;
    757  7b3d		       85 3f		      sta	SET_BANK	;
    758  7b3f		       20 0d f1 	      jsr	GetBoardAddressW	;11+24[-2](A)
    759  7b42		       86 3e		      stx	SET_BANK_RAM	;3
    760  7b44
    761  7b44		       a4 91		      ldy	POS_X_NEW
    762  7b46		       84 8f		      sty	POS_X
    763  7b48
    764  7b48		       a6 93		      ldx	POS_Type
    765  7b4a		       bd 69 fe 	      lda	BaseTypeCharacterFalling,x	; original character base character
    766  7b4d		       91 c1		      sta	(Board_AddressW),y	; draw object in new location (Y = new X posn)
    767  7b4f
    768  7b4f		       20 7c fb    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    769  7b52
    770  7b52				   NextObject
    771  7b52		       e6 dd		      inc	ObjIterator	; 5
    772  7b54							;		  dec ObjStackPtr,x		  ; 6
    773  7b54		       4c 27 f9 	      jmp	ProcessObjStack	; 3 = 16
    774  7b57
    775  7b57							;---------------------------------------------------------------------------
    776  7b57
      0  7b57					      DEFINE_SUBROUTINE	StartSoundCheckAlreadyFalling
      1  7b57		       00 0f	   BANK_StartSoundCheckAlreadyFalling =	_CURRENT_BANK
      2  7b57					      SUBROUTINE
      3  7b57				   StartSoundCheckAlreadyFalling
    778  7b57							; TJ: used by:
    779  7b57							; - BANK_FIXED.asm
    780  7b57		       a9 80		      lda	#VAR_FALLING	; play ONLY if we were already falling
      0  7b59					      DEFINE_SUBROUTINE	StartSoundCheckFalling
      1  7b59		       00 0f	   BANK_StartSoundCheckFalling =	_CURRENT_BANK
      2  7b59					      SUBROUTINE
      3  7b59				   StartSoundCheckFalling
    782  7b59		       45 94		      eor	POS_VAR	; check if already falling or not
    783  7b5b		       30 11		      bmi	.noSound	; <--- DANGEROUS assumption of flag value
      0  7b5d					      DEFINE_SUBROUTINE	StartSoundAlways
      1  7b5d		       00 0f	   BANK_StartSoundAlways =	_CURRENT_BANK
      2  7b5d					      SUBROUTINE
      3  7b5d				   StartSoundAlways
    785  7b5d		       a4 93		      ldy	POS_Type
    786  7b5f		       a5 db		      lda	newSounds
    787  7b61		       29 0f		      and	#SND_MASK_LO	; already a new sound triggerd?
    788  7b63		       c9 03		      cmp	#SOUND_MOVE_SOIL+1	; except for low priority move sounds!
    789  7b65		       b0 07		      bcs	.noSound	; yes, no new sound
    790  7b67		       45 db		      eor	newSounds
    791  7b69		       19 6e fb 	      ora	FallSoundTbl-TYPE_BOULDER,y
    792  7b6c		       85 db		      sta	newSounds
    793  7b6e				   .noSound
    794  7b6e		       60		      rts
    795  7b6f
    796  7b6f							;---------------------------------------------------------------------------
    797  7b6f
    798  7b6f							; Warning: Hardwired dependence on existing TYPE_
    799  7b6f							; sounds are played when boulders/diamonds start *and* end falling:
    800  7b6f				   FallSoundTbl
    801  7b6f							; TJ: used by:
    802  7b6f							; - BANK_FIXED.asm
    803  7b6f		       03		      .byte.b	SOUND_BOULDER	; TYPE_BOULDER
    804  7b70		       00		      .byte.b	0
    805  7b71		       00		      .byte.b	0
    806  7b72		       00		      .byte.b	0
    807  7b73		       05		      .byte.b	SOUND_DIAMOND_FALLING	; TYPE_DIAMOND
    808  7b74
    809  7b74							;---------------------------------------------------------------------------
    810  7b74
      0  7b74					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  7b74		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  7b74					      SUBROUTINE
      3  7b74				   InsertObjectStackFromRAM
    812  7b74							; TJ: used by:
    813  7b74							; - BANK_FIXED.asm
    814  7b74							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
    815  7b74
    816  7b74		       20 7c fb 	      jsr	InsertObjectStack	;6+76(B)
    817  7b77		       a5 c4		      lda	RAM_Bank	;3
    818  7b79		       85 3e		      sta	SET_BANK_RAM	;3
    819  7b7b
    820  7b7b		       60	   NotEnoughTime rts		;6
    821  7b7c
    822  7b7c							;---------------------------------------------------------------------------
    823  7b7c
      0  7b7c					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  7b7c		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  7b7c					      SUBROUTINE
      3  7b7c				   InsertObjectStack
    825  7b7c							; TJ: used by:
    826  7b7c							; - BANK_FIXED.asm
    827  7b7c							; - BANK_INITBANK.asm
    828  7b7c
    829  7b7c							; POS_X     x position
    830  7b7c							; POS_Y     y position
    831  7b7c							; POS_VAR   direction or other variable
    832  7b7c							; POS_Type  type of object
    833  7b7c
    834  7b7c		       a6 8a		      ldx	ObjStackNum	; 3
    835  7b7e		       bc ac fb 	      ldy	BankObjStack,x	; 4
    836  7b81		       84 3e		      sty	SET_BANK_RAM	; 3
    837  7b83		       b4 8b		      ldy	ObjStackPtr,x	; 4 = 14
    838  7b85
    839  7b85
    840  7b85		       a5 90		      lda	POS_Y	; 3
    841  7b87		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    842  7b8a		       a5 8f		      lda	POS_X	; 3
    843  7b8c		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    844  7b8f		       a5 94		      lda	POS_VAR	; 3
    845  7b91		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    846  7b94		       a5 93		      lda	POS_Type	; 3
    847  7b96		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    848  7b99
    849  7b99							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    850  7b99							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    851  7b99							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    852  7b99
    853  7b99
    854  7b99				  -	      IF	TYPE_MAN != 0
    855  7b99				  -	      cmp	#TYPE_MAN	; 2
    856  7b99					      ENDIF
    857  7b99		       f0 04		      beq	alwaysAllowMan	; 2/3
    858  7b9b
    859  7b9b		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    860  7b9d		       b0 08		      bcs	insertDone	; 2/3= 6    no room -- drop object
    861  7b9f				   alwaysAllowMan
    862  7b9f
    863  7b9f		       98		      tya		; 2
    864  7ba0		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    865  7ba3
    866  7ba3		       f6 8b		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    867  7ba5					      IF	SORT_OBJECTS = YES
    868  7ba5		       84 d3		      sty	sortRequired	; 3	     flag that a sort is required
    869  7ba7					      ENDIF
    870  7ba7
    871  7ba7		       a4 c3	   insertDone ldy	ROM_Bank	; 3
    872  7ba9		       84 3f		      sty	SET_BANK	; 3
    873  7bab
    874  7bab		       60	   ManIsDead2 rts		; 6 = 29
    875  7bac
    876  7bac							;---------------------------------------------------------------------------
    877  7bac
    878  7bac		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    879  7bae							; TJ: used by:
    880  7bae							; - BANK_FIXED.asm
    881  7bae
    882  7bae							;---------------------------------------------------------------------------
    883  7bae
    884  7bae
    885  7bae				   MovePlayer
    886  7bae							; TJ: used by:
    887  7bae							; - BANK_FIXED.asm
    888  7bae							; - BANK_INITBANK.asm
    889  7bae		       a5 a3		      lda	ManMode
    890  7bb0		       c9 02		      cmp	#MANMODE_DEAD
    891  7bb2		       b0 f7		      bcs	ManIsDead2
    892  7bb4
    893  7bb4		       a4 92		      ldy	POS_Y_NEW
    894  7bb6
    895  7bb6		       a9 08		      lda	#BANK_GetBoardAddressRW	;2
    896  7bb8		       85 3f		      sta	SET_BANK	;3
    897  7bba		       85 c3		      sta	ROM_Bank	;3
    898  7bbc		       20 c8 f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    899  7bbf				  -	      IF	MULTI_BANK_BOARD = YES
    900  7bbf				  -	      stx	RAM_Bank
    901  7bbf					      ENDIF
    902  7bbf		       86 3e		      stx	SET_BANK_RAM	; 3
    903  7bc1
    904  7bc1		       a4 91		      ldy	POS_X_NEW
    905  7bc3		       b3 bf		      lax	(Board_AddressR),y
    906  7bc5							; TODO: would it makes sense to add a move conversion table?
    907  7bc5							; that way, the move tables would become much smaller
    908  7bc5		       a9 08		      lda	#BANK_MoveVecLO
    909  7bc7		       85 3f		      sta	SET_BANK
    910  7bc9
    911  7bc9		       bd e7 f6 	      lda	MoveVecLO,x
    912  7bcc		       85 df		      sta	MAN_Move
    913  7bce		       bd 02 f7 	      lda	MoveVecHI,x
    914  7bd1		       85 e0		      sta	MAN_Move+1
    915  7bd3
    916  7bd3				  -	      IF	MULTI_BANK_BOARD = YES
    917  7bd3				  -	      lda	RAM_Bank
    918  7bd3					      ELSE
    919  7bd3		       a9 0d		      lda	#BANK_BOARD
    920  7bd5					      ENDIF
    921  7bd5		       85 3e		      sta	SET_BANK_RAM
    922  7bd7		       6c df 00 	      jmp	(MAN_Move)
    923  7bda
    924  7bda							;---------------------------------------------------------------------------
    925  7bda
    926  7bda
    927  7bda				   MOVE_DIAMOND
    928  7bda							; TJ: used by:
    929  7bda							; - BANK_FIXED.asm
    930  7bda
    931  7bda		       ad 84 02 	      lda	INTIM
    932  7bdd		       c9 11		      cmp	#SEGTIME_GET_DIAMOND
    933  7bdf		       66 dc		      ror	specialTimeFlag	; mark any overtime!
    934  7be1		       10 5e		      bpl	timeExit
      0  7be3					      STRESS_TIME	SEGTIME_GET_DIAMOND
      1  7be3				  -	      IF	TEST_SEGTIME_GET_DIAMOND = 1
      2  7be3				  -
      3  7be3				  -
      4  7be3				  -
      5  7be3				  -
      6  7be3				  -
      7  7be3				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7be3				  -	      bne	. - 7
      9  7be3					      ENDIF
    936  7be3
    937  7be3		       a9 07		      lda	#BANK_CheckDiamondFlash	; 2
    938  7be5		       85 3f		      sta	SET_BANK	; 3
    939  7be7		       20 7d f4 	      jsr	CheckDiamondFlash	; 3	 returns points to add in A
    940  7bea
    941  7bea		       a0 09		      ldy	#BANK_SCORING	; 2
    942  7bec		       84 3e		      sty	SET_BANK_RAM	; 3
    943  7bee		       20 02 f3 	      jsr	GetDiamond	;	 this takes quite long!
    944  7bf1
    945  7bf1				  -	      IF	MULTI_BANK_BOARD = YES
    946  7bf1				  -	      lda	RAM_Bank
    947  7bf1					      ELSE
    948  7bf1		       a9 0d		      lda	#BANK_BOARD
    949  7bf3					      ENDIF
    950  7bf3		       85 3e		      sta	SET_BANK_RAM
    951  7bf5		       10 1c		      bpl	checkForSnatch	;3		 unconditional
    952  7bf7
    953  7bf7							;---------------------------------------------------------------------------
    954  7bf7
    955  7bf7				   MOVE_BLANK
    956  7bf7							; TJ: used by:
    957  7bf7							; - BANK_FIXED.asm
    958  7bf7
    959  7bf7							; The movement sounds are lowest priority. They only trigger if there is a free channel.
    960  7bf7							; The code below checks the two channels and if either is free, uses it for the move sound.
    961  7bf7
    962  7bf7		       a0 01		      ldy	#SOUND_MOVE_BLANK	; 2
      0  7bf9					      NOP_W		; 2
      1  7bf9		       0c		      .byte.b	$0c
    964  7bfa		       a0 02	   MOVE_SOIL  ldy	#SOUND_MOVE_SOIL	; 2
    965  7bfc							; TJ: used by:
    966  7bfc							; - BANK_FIXED.asm
    967  7bfc
    968  7bfc							; lowest priority, look for a free channel, 0 first
    969  7bfc
    970  7bfc		       a7 db		      lax	newSounds
    971  7bfe		       29 0f		      and	#SND_MASK_LO
    972  7c00		       d0 03		      bne	.skipUseLow	;		 LO channel is not available
    973  7c02
    974  7c02		       98		      tya
    975  7c03		       d0 0a		      bne	.setSound	;		 unconditional: USE lo channel!
    976  7c05
    977  7c05				   .skipUseLow
    978  7c05		       8a		      txa
    979  7c06		       29 f0		      and	#SND_MASK_HI
    980  7c08		       d0 09		      bne	checkForSnatch	;2/3		 no channel available so skip sound
    981  7c0a
    982  7c0a		       98		      tya
    983  7c0b		       0a		      asl
    984  7c0c		       0a		      asl
    985  7c0d		       0a		      asl
    986  7c0e		       0a		      asl		;		 use requested sound in Hi channel
    987  7c0f
    988  7c0f		       05 db	   .setSound  ora	newSounds
    989  7c11		       85 db		      sta	newSounds
    990  7c13
    991  7c13							;---------------------------------------------------------------------------
    992  7c13							; Handle snatching...
    993  7c13
    994  7c13		       a4 91	   checkForSnatch ldy	POS_X_NEW	; 3
    995  7c15		       a5 97		      lda	BufferedButton	; 3		 button pressed?
    996  7c17		       30 0d		      bmi	MoveNoButton	; 2/3		 NO, so we move to new square, otherwise...
    997  7c19
    998  7c19							; We only 'snatch' and the player doesn't move. Blank the snatched square...
    999  7c19
   1000  7c19		       a6 92		      ldx	POS_Y_NEW	; 3
   1001  7c1b		       86 90		      stx	POS_Y	; 3		 needed for InsertBlankStack
   1002  7c1d		       84 8f		      sty	POS_X	; 3		 needed for InsertBlankStack
   1003  7c1f		       4c 03 fa 	      jmp	BlankOriginalLocationXY	; 6+87[-2](A)	 snatch/grab the new location
   1004  7c22
   1005  7c22							;---------------------------------------------------------------------------
   1006  7c22
   1007  7c22				   MoveNoButton2
   1008  7c22							; TJ: used by:
   1009  7c22							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1010  7c22		       a9 0d		      lda	#BANK_BOARD
   1011  7c24		       85 3e		      sta	SET_BANK_RAM
   1012  7c26
   1013  7c26		       a9 06	   MoveNoButton lda	#CHARACTER_MANOCCUPIED	; 2
   1014  7c28		       91 c1		      sta	(Board_AddressW),y	; 6 =	8	 the man's new square
   1015  7c2a
   1016  7c2a		       a6 a0		      ldx	ManY	; 3
   1017  7c2c		       86 90		      stx	POS_Y	; 3
   1018  7c2e		       a4 9f		      ldy	ManX	; 3
   1019  7c30		       84 8f		      sty	POS_X	; 3 = 12
   1020  7c32
   1021  7c32		       20 03 fa 	      jsr	BlankOriginalLocationXY	; 6+87[-2](A)	 and stacks newly blank position for checking
   1022  7c35
   1023  7c35		       a5 91		      lda	POS_X_NEW	; 3
   1024  7c37		       85 9f		      sta	ManX	; 3
   1025  7c39		       a5 92		      lda	POS_Y_NEW	; 3
   1026  7c3b		       85 a0		      sta	ManY	; 3 = 12	 actually MOVE!
   1027  7c3d
   1028  7c3d				   MOVE_GENERIC
   1029  7c3d							; TJ: used by:
   1030  7c3d							; - BANK_FIXED.asm
   1031  7c3d		       a9 00		      lda	#0	; 2
   1032  7c3f		       85 a9		      sta	ManPushCounter	; 3
   1033  7c41		       60	   timeExit   rts		; 6 = 11
   1034  7c42
   1035  7c42							;---------------------------------------------------------------------------
   1036  7c42
      0  7c42					      DEFINE_SUBROUTINE	MOVE_EXIT
      1  7c42		       00 0f	   BANK_MOVE_EXIT =	_CURRENT_BANK
      2  7c42					      SUBROUTINE
      3  7c42				   MOVE_EXIT
   1038  7c42							; TJ: used by:
   1039  7c42							; - BANK_FIXED.asm
   1040  7c42
   1041  7c42		       a9 05		      lda	#BANK_MoveExit
   1042  7c44		       85 3f		      sta	SET_BANK
   1043  7c46		       4c 8f f3 	      jmp	MoveExit
   1044  7c49
   1045  7c49							;---------------------------------------------------------------------------
   1046  7c49
      0  7c49					      DEFINE_SUBROUTINE	MOVE_BOULDER
      1  7c49		       00 0f	   BANK_MOVE_BOULDER =	_CURRENT_BANK
      2  7c49					      SUBROUTINE
      3  7c49				   MOVE_BOULDER
   1048  7c49							; TJ: used by:
   1049  7c49							; - BANK_FIXED.asm
   1050  7c49
   1051  7c49		       a9 08		      lda	#BANK_PushBoulder
   1052  7c4b		       85 3f		      sta	SET_BANK
   1053  7c4d		       4c bc f2 	      jmp	PushBoulder
   1054  7c50
   1055  7c50							;---------------------------------------------------------------------------
   1056  7c50
      0  7c50					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7c50		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7c50					      SUBROUTINE
      3  7c50				   StealCharDraw
   1058  7c50							; TJ: used by:
   1059  7c50							; - BANK_FIXED.asm
   1060  7c50
   1061  7c50		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
   1062  7c52		       85 3e		      sta	SET_BANK_RAM	; 3
   1063  7c54		       a4 89		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
   1064  7c56		       10 35		      bpl	EnterStealCharDraw	; 3 = 10(11)
   1065  7c58
   1066  7c58				   ExitStealCharDraw
   1067  7c58
   1068  7c58							; fall through...
   1069  7c58
   1070  7c58							;---------------------------------------------------------------------------
   1071  7c58
      0  7c58					      DEFINE_SUBROUTINE	TimeSlice
      1  7c58		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7c58					      SUBROUTINE
      3  7c58				   TimeSlice
   1073  7c58							; TJ: used by:
   1074  7c58							; - BANK_FIXED.asm
   1075  7c58
   1076  7c58							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
   1077  7c58							; going ahead if there's insufficient time. This allows the previous character drawing to
   1078  7c58							; be much smaller in time, as they don't have to include the timeslice code overhead.
   1079  7c58
   1080  7c58		       ad 84 02 	      lda	INTIM	; 4
   1081  7c5b		       c9 05		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
   1082  7c5d		       90 e2		      bcc	timeExit	; 2(3)
   1083  7c5f
   1084  7c5f							; Uses the phase variable to vector to the correct processing code for the given timeslice
   1085  7c5f							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
   1086  7c5f							; it should increment ScreenDrawPhase.
   1087  7c5f
   1088  7c5f							; Switched-in bank(s) are undefined after this function is called!
   1089  7c5f
   1090  7c5f		       a9 07		      lda	#BANK_TS_PhaseVectorLO	; 2
   1091  7c61		       85 3f		      sta	SET_BANK	; 3
   1092  7c63
   1093  7c63		       a6 8e		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
   1094  7c65		       bd 27 f6 	      lda	TS_PhaseVectorLO,x	; 4
   1095  7c68		       85 df		      sta	TS_Vector	; 3
   1096  7c6a		       bd 2d f6 	      lda	TS_PhaseVectorHI,x	; 4
   1097  7c6d		       85 e0		      sta	TS_Vector+1	; 3
   1098  7c6f
   1099  7c6f		       bd 33 f6 	      lda	TS_PhaseBank,x	; 4
   1100  7c72		       85 3f		      sta	SET_BANK	; 3		 switch bank
   1101  7c74
   1102  7c74		       6c df 00 	      jmp	(TS_Vector)	; 3 = 40	 vector to timeslice handler
   1103  7c77
   1104  7c77							; = 55 minimum return time (if segtime abort)
   1105  7c77
   1106  7c77							;---------------------------------------------------------------------------
   1107  7c77
   1108  7c77
   1109  7c77				   DrawAnother
   1110  7c77							; TJ: used by:
   1111  7c77							; - BANK_ROM_SHADOW_RAMBANK.asm
   1112  7c77
   1113  7c77		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
   1114  7c79		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
   1115  7c7b
   1116  7c7b		       a4 89		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
   1117  7c7d
   1118  7c7d		       be 00 f1 	      ldx	DrawStack,y	; 4	     in actuality a character index
   1119  7c80		       bd a0 f1 	      lda	ScreenBuffer,x	; 4	     new character to draw
   1120  7c83		       29 7f		      and	#~128	; 2
   1121  7c85		       9d a0 f5 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
   1122  7c88
   1123  7c88		       88		      dey		; 2
   1124  7c89		       84 89		      sty	DrawStackPointer	; 3	     one less to draw
   1125  7c8b		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7
   1126  7c8d
   1127  7c8d				   EnterStealCharDraw		;	     RAM bank MUST be at BANK_DRAW_BUFFERS
   1128  7c8d							; TJ: used by:
   1129  7c8d							; - BANK_FIXED.asm
   1130  7c8d
   1131  7c8d		       ad 84 02 	      lda	INTIM	; 4
   1132  7c90		       c9 05		      cmp	#SEGTIME_SCD_MIN	; 2
   1133  7c92		       90 c4		      bcc	ExitStealCharDraw	; 2/3= 8
   1134  7c94
   1135  7c94		       be 00 f1 	      ldx	DrawStack,y	; 4	     in actuality a character index
   1136  7c97		       bc a0 f1 	      ldy	ScreenBuffer,x	; 4 =	8    new character to draw
   1137  7c9a
   1138  7c9a		       bd 3f f3 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
   1139  7c9d		       85 3e		      sta	SET_BANK_RAM	; 3
   1140  7c9f		       4c 53 f1 	      jmp	StealPart3	; 3 = 10    --> 18 cycles after check for SEGTIME_SCD_MIN
   1141  7ca2
   1142  7ca2
   1143  7ca2							;---------------------------------------------------------------------------
   1144  7ca2
      0  7ca2					      DEFINE_SUBROUTINE	BuildDrawStack	; in FIXED BANK
      1  7ca2		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7ca2					      SUBROUTINE
      3  7ca2				   BuildDrawStack
   1146  7ca2							; TJ: used by:
   1147  7ca2							; - BANK_FIXED.asm
   1148  7ca2
   1149  7ca2		       a9 08		      lda	#BANK_DRAW_BUFFERS
   1150  7ca4		       85 3e		      sta	SET_BANK_RAM
   1151  7ca6		       4c 01 f2 	      jmp	DrawStackUpdate
   1152  7ca9
   1153  7ca9							;---------------------------------------------------------------------------
   1154  7ca9
      0  7ca9					      DEFINE_SUBROUTINE	DrawAIntoStack	; in FIXED BANK
      1  7ca9		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7ca9					      SUBROUTINE
      3  7ca9				   DrawAIntoStack
   1156  7ca9							; TJ: used by:
   1157  7ca9							; - BANK_FIXED.asm
   1158  7ca9
   1159  7ca9		       a9 08		      lda	#BANK_DRAW_BUFFERS
   1160  7cab		       85 3e		      sta	SET_BANK_RAM
   1161  7cad		       4c 2e f2 	      jmp	DrawIntoStack
   1162  7cb0
   1163  7cb0
   1164  7cb0							;---------------------------------------------------------------------------
   1165  7cb0
   1166  7cb0
      0  7cb0					      DEFINE_SUBROUTINE	DrawFullScreenMain	;=2484[-89]
      1  7cb0		       00 0f	   BANK_DrawFullScreenMain =	_CURRENT_BANK
      2  7cb0					      SUBROUTINE
      3  7cb0				   DrawFullScreenMain
   1168  7cb0
   1169  7cb0							; Check the screen for all those characters that need to be redrawn
   1170  7cb0							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
   1171  7cb0							; the drawflags array is different to the ScreenBuffer array entry, then the
   1172  7cb0							; screenbuffer will need redrawing.
   1173  7cb0
   1174  7cb0				   CopyRow2
   1175  7cb0							; TJ: used by:
   1176  7cb0							; - BANK_INITBANK.asm
   1177  7cb0
   1178  7cb0				  -	      IF	MULTI_BANK_BOARD = YES
   1179  7cb0				  -	      lda	BDF_BoardBank	; 3
   1180  7cb0					      ELSE
   1181  7cb0		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
   1182  7cb2					      ENDIF
   1183  7cb2		       85 3e		      sta	SET_BANK_RAM	; 3
   1184  7cb4		       b3 e3		      lax	(BDF_BoardAddress),y	; 5
   1185  7cb6		       9a		      txs		; 2
   1186  7cb7		       b3 e5		      lax	(BDF_BoardAddress2),y	; 5(= 18[-1])
   1187  7cb9
   1188  7cb9		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
   1189  7cbb		       85 3e		      sta	SET_BANK_RAM	; 3
   1190  7cbd		       bd d4 f2 	      lda	CharReplacement,x	; 4
   1191  7cc0		       91 e1		      sta	(BDF_DrawFlagAddress2),y	; 6
   1192  7cc2		       ba		      tsx		; 2
   1193  7cc3		       bd d4 f2 	      lda	CharReplacement,x	; 4
   1194  7cc6		       91 df		      sta	(BDF_DrawFlagAddress),y	; 6(= 27)
   1195  7cc8
   1196  7cc8		       88		      dey		; 2
   1197  7cc9		       10 e5		      bpl	CopyRow2	; 2/3=49/50[-1]
   1198  7ccb							; total: 5*49[-1]-1 = 244[-5]
   1199  7ccb
   1200  7ccb							; TJ: examples for multi RAM bank access.
   1201  7ccb							;CopyRow2
   1202  7ccb							;		  lax (BDF_BoardAddress),y	  ; 5
   1203  7ccb							;		  txs				  ; 2
   1204  7ccb							;		  lax (BDF_BoardAddress2),y	  ; 5(= 12)
   1205  7ccb							;		  lda CharReplacement,x 	  ; 4
   1206  7ccb							;		  sta (BDF_DrawFlagAddress2),y	  ; 6
   1207  7ccb							;		  tsx				  ; 2
   1208  7ccb							;		  lda CharReplacement,x 	  ; 4
   1209  7ccb							;		  sta (BDF_DrawFlagAddress),y	  ; 6(= 22)
   1210  7ccb							;		  dey				  ; 2
   1211  7ccb							;		  bpl CopyRow2			  ; 2/3=38/39
   1212  7ccb							;; total: 5*39 - 1 = 194
   1213  7ccb							;
   1214  7ccb							;CopyRow2
   1215  7ccb							;		  lax (BDF_BoardAddress),y	  ; 5
   1216  7ccb							;		  lda CharReplacement,x 	  ; 4
   1217  7ccb							;		  sta (BDF_DrawFlagAddress),y	  ; 6(= 15)
   1218  7ccb							;		  dey				  ; 2
   1219  7ccb							;		  bpl CopyRow2			  ; 2/3=19/20
   1220  7ccb							;; total: 10*20 - 1 = 199 (and much less setup code)
   1221  7ccb
   1222  7ccb		       a7 e8		      lax	DHS_Line	; 3
   1223  7ccd		       f0 07		      beq	.exitCopy	; 2/3= 5/6
   1224  7ccf
   1225  7ccf		       a0 08		      ldy	#BANK_DrawScreenRowPreparation	;2
   1226  7cd1		       84 3f		      sty	SET_BANK	; 3
   1227  7cd3		       4c 1e f6 	      jmp	DrawScreenRowPreparation	;55[-7] = 60[-7]
   1228  7cd6
   1229  7cd6							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
   1230  7cd6
   1231  7cd6
      0  7cd6					      CHECKPAGE	CopyRow2
      8  7cd6					      LIST	ON
   1233  7cd6
   1234  7cd6		       a6 e9	   .exitCopy  ldx	DHS_Stack	; 3
   1235  7cd8		       9a		      txs		; 2
   1236  7cd9
   1237  7cd9		       4c a2 fc 	      jmp	BuildDrawStack
   1238  7cdc
   1239  7cdc		       60	   SwitchPhaseR rts		; 6 = 11
   1240  7cdd
   1241  7cdd							;---------------------------------------------------------------------------
   1242  7cdd
   1243  7cdd				   Reset
   1244  7cdd							; TJ: used by:
   1245  7cdd							; - BANK_FIXED.asm
   1246  7cdd
   1247  7cdd				  -	      IF	SHOW_COPYRIGHT = NO
   1248  7cdd				  -	      CLEAN_START
   1249  7cdd					      ELSE
   1250  7cdd		       a9 01		      lda	#BANK_DrawCopyright	; 2
   1251  7cdf		       85 3f		      sta	SET_BANK	; 3
   1252  7ce1		       4c ce f3 	      jmp	DrawCopyright	; 3+x
   1253  7ce4				   ExitCopyRight
   1254  7ce4					      ENDIF
   1255  7ce4
   1256  7ce4
   1257  7ce4
   1258  7ce4
   1259  7ce4							; Scoring bank is copied once (not per game, not per level...)
   1260  7ce4							; otherwise non-SaveKey high score gets zapped
   1261  7ce4
   1262  7ce4		       a2 06		      ldx	#ROM_SHADOW_OF_BANK_SCORING
   1263  7ce6		       a0 09		      ldy	#BANK_SCORING
   1264  7ce8		       20 6e ff 	      jsr	CopyROM2RAM_F000
   1265  7ceb
   1266  7ceb				   Restart		; go here on RESET + SELECT
   1267  7ceb							; TJ: used by:
   1268  7ceb							; - BANK_INITBANK.asm
   1269  7ceb
   1270  7ceb
   1271  7ceb				   Title
   1272  7ceb		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
   1273  7ced		       9a		      txs
   1274  7cee
   1275  7cee		       a9 02		      lda	#BANK_TitleScreen	; 2
   1276  7cf0		       85 3f		      sta	SET_BANK	; 3
   1277  7cf2		       4c af f1 	      jmp	TitleScreen	; 3+x
   1278  7cf5				   ExitTitleScreen
   1279  7cf5							; temporary vars from title screen are used to init level/cave
   1280  7cf5		       a9 07		      lda	#BANK_Cart_Init	; 2
   1281  7cf7		       85 3f		      sta	SET_BANK	; 3
   1282  7cf9		       20 fa f3 	      jsr	Cart_Init	; 6+x
   1283  7cfc
   1284  7cfc
   1285  7cfc							;---------------------------------------------------------------------------
   1286  7cfc
   1287  7cfc
   1288  7cfc		       f0 00	   SEGMENT_DECODE_CAVE_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
   1289  7cfc
   1290  7cfc		       a2 07		      ldx	#BANK_DECODE_CAVE_SHADOW
   1291  7cfe		       a0 0a		      ldy	#BANK_DECODE_CAVE
   1292  7d00		       20 6e ff 	      jsr	CopyROM2RAM_F000
   1293  7d03
   1294  7d03
   1295  7d03							;---------------------------------------------------------------------------
   1296  7d03							; Once-only game initialisation goes here...
   1297  7d03							; now we have two players so things get a bit tricky
   1298  7d03
   1299  7d03		       a9 09		      lda	#BANK_SCORING
   1300  7d05		       85 3e		      sta	SET_BANK_RAM
   1301  7d07		       20 b9 f3 	      jsr	GameInitialise
   1302  7d0a
   1303  7d0a
   1304  7d0a							;---------------------------------------------------------------------------
   1305  7d0a
   1306  7d0a				   RestartCaveNextPlayer
   1307  7d0a							; TJ: used by:
   1308  7d0a							; - BANK_FIXED.asm
   1309  7d0a
   1310  7d0a							; a player has lost a life.
   1311  7d0a							; store his vars, swap to other player, continue
   1312  7d0a
   1313  7d0a		       a9 09		      lda	#BANK_SCORING
   1314  7d0c		       85 3e		      sta	SET_BANK_RAM
   1315  7d0e		       20 5c f2 	      jsr	SwapPlayers
   1316  7d11
   1317  7d11		       a9 07		      lda	#BANK_SwapPlayersGeneric
   1318  7d13		       85 3f		      sta	SET_BANK
   1319  7d15		       20 4d f4 	      jsr	SwapPlayersGeneric
   1320  7d18
   1321  7d18
   1322  7d18		       a5 ab		      lda	MenCurrent
   1323  7d1a		       f0 cf		      beq	Title	; all lives lost! (works for both P1P2)
   1324  7d1c		       d0 04		      bne	skipDemoCheck
   1325  7d1e
   1326  7d1e				   NextCaveLevel
   1327  7d1e		       24 ac		      bit	demoMode
   1328  7d20		       30 c9		      bmi	Title
   1329  7d22				   skipDemoCheck
   1330  7d22
   1331  7d22							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
   1332  7d22							; including those for general systems function. But NOT those which do not need re-initialising between
   1333  7d22							; levels.
   1334  7d22		       a9 07		      lda	#BANK_LevelInit	; 2
   1335  7d24		       85 3f		      sta	SET_BANK	; 3
   1336  7d26		       20 13 f5 	      jsr	LevelInit	; 6+x
   1337  7d29
   1338  7d29					      IF	EASTER_EGG = YES
   1339  7d29		       a9 09		      lda	#BANK_SCORING
   1340  7d2b		       85 3e		      sta	SET_BANK_RAM
   1341  7d2d		       20 e4 f3 	      jsr	GetScore
   1342  7d30					      ENDIF
   1343  7d30
   1344  7d30		       a9 0a		      lda	#BANK_DECODE_CAVE
   1345  7d32		       85 3e		      sta	SET_BANK_RAM
   1346  7d34		       20 9e f0 	      jsr	DecodeCave
   1347  7d37
   1348  7d37							; Setup player animation and scroll limits.
   1349  7d37							; Initialise amoeba if present
   1350  7d37							; Mangle the board colours based on level
   1351  7d37
   1352  7d37		       a9 07		      lda	#BANK_CreateCreatures	; 2
   1353  7d39		       85 3f		      sta	SET_BANK	; 3
   1354  7d3b		       20 c6 f4 	      jsr	CreateCreatures	; 6+x
   1355  7d3e
   1356  7d3e
   1357  7d3e							; Setup the various digit and display pointers
   1358  7d3e							; Grab current player's score/cave/level from backup
   1359  7d3e
   1360  7d3e		       20 62 ff 	      jsr	goGeneralScoringSetups
   1361  7d41
   1362  7d41							; copy the screen draw ROM shadow to RAM
   1363  7d41
   1364  7d41		       a0 07		      ldy	#SCREEN_LINES-1
   1365  7d43				   CopyScreenBanks
   1366  7d43
   1367  7d43		       a2 04		      ldx	#ROM_SHADOW_OF_RAMBANK_CODE
   1368  7d45		       20 6e ff 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
   1369  7d48
   1370  7d48							;		  lda #BANK_SetPlatformColours	     ; same bank!
   1371  7d48							;		  sta SET_BANK
   1372  7d48		       20 77 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
   1373  7d4b
   1374  7d4b		       88		      dey
   1375  7d4c		       10 f5		      bpl	CopyScreenBanks
   1376  7d4e
   1377  7d4e							;---------------------------------------------------------------------------
   1378  7d4e
   1379  7d4e							;		  lda #BANK_CopyROMShadowToRAM	     ; same bank!
   1380  7d4e							;		  ;sta ROM_Bank 				   ; <-- pretty sure this one can go.
   1381  7d4e							;		  sta SET_BANK
   1382  7d4e
   1383  7d4e		       a2 05		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
   1384  7d50		       a0 08		      ldy	#BANK_DRAW_BUFFERS
   1385  7d52		       20 43 f0 	      jsr	CopyROMShadowToRAM_F000
   1386  7d55
   1387  7d55							;---------------------------------------------------------------------------
   1388  7d55
   1389  7d55		       a9 07		      lda	#BANK_Resync	; 2
   1390  7d57		       85 3f		      sta	SET_BANK	; 3
   1391  7d59		       20 4c f5 	      jsr	Resync	; 6+x
   1392  7d5c
   1393  7d5c				   NewFrameBD
   1394  7d5c							; the (at least) 220 cycles wasted in the above... bugs me!
   1395  7d5c							; the below is an unrolled version.  I've moved some other code between the sync writes, effectively saving um... 22 cycles/frame.
   1396  7d5c							; This required TIM64T values to be increased by 1 for each platform (we have actually gained back some usable time :)
   1397  7d5c
   1398  7d5c		       24 c9		      bit	NextLevelTrigger
   1399  7d5e		       10 be		      bpl	NextCaveLevel	; game-triggered next level
   1400  7d60		       70 a8		      bvs	RestartCaveNextPlayer	; loss of life
   1401  7d62
   1402  7d62							; Note: VSYNC must NOT be on when starting a new cave! Else you get annoying TV signals.
   1403  7d62		       a9 0e		      lda	#%1110	; VSYNC ON
   1404  7d64				   .loopVSync
   1405  7d64							;		  ldx #BANK_PlaySounds
   1406  7d64							;		  stx SET_BANK
   1407  7d64
   1408  7d64							;		  ldx Platform
   1409  7d64							;		  ldy VBlankTime,x
   1410  7d64
   1411  7d64		       85 42		      sta	WSYNC
   1412  7d66		       85 40		      sta	VSYNC
   1413  7d68
   1414  7d68							;		  sty TIM64T			  ; better set timer after (last) WSYNC
   1415  7d68
   1416  7d68							; Ignorant comment removed. (TJ: and you were wrong anyway. :)
   1417  7d68
   1418  7d68		       4a		      lsr
   1419  7d69		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
   1420  7d6b
   1421  7d6b							; moved *after* the loop since this allows to *increase* timer values by 1!
   1422  7d6b		       a6 81		      ldx	Platform
   1423  7d6d		       bc cd fd 	      ldy	VBlankTime,x
   1424  7d70		       8c 96 02 	      sty	TIM64T
   1425  7d73
   1426  7d73		       a2 00		      ldx	#BANK_PlaySounds
   1427  7d75		       86 3f		      stx	SET_BANK
   1428  7d77
   1429  7d77							;---------------------------------------------------------------------------
   1430  7d77							; Do not separate code, as bank assumption is made
   1431  7d77
   1432  7d77		       20 2a f3 	      jsr	PlaySounds	; 6+x	 Jentzsch sound system
   1433  7d7a
   1434  7d7a		       20 50 fc 	      jsr	StealCharDraw	; NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
   1435  7d7d					      IF	SORT_OBJECTS = YES
   1436  7d7d		       20 0d ff 	      jsr	SortObjects2	; 6+15 mininum. Opportunistic sorting
   1437  7d80					      ENDIF
   1438  7d80
   1439  7d80							;---------------------------------------------------------------------------
   1440  7d80							; START OF DISPLAY
   1441  7d80
   1442  7d80		       a9 09		      lda	#BANK_SCORING	; 2
   1443  7d82		       85 3e		      sta	SET_BANK_RAM	; 3
   1444  7d84		       20 d3 f1 	      jsr	DrawDigits	; 6 = 11
   1445  7d87
   1446  7d87							;---------------------------------------------------------------------------
   1447  7d87							; A 42-cycle timing window in the screen draw code.  Perform any general
   1448  7d87							; per-frame code here, provided it takes exactly 42 cycles to execute.
   1449  7d87							; TJ: Well, not exactly 42 cycles, but it works! :)
   1450  7d87							;	 @09
   1451  7d87		       85 49		      sta	COLUBK	; 3	 value comes from subroutine
   1452  7d89							; + the 'black' left-side of top screen colour change when look-around is actually a HMOVE bar, so we can't fix it :)
   1453  7d89
   1454  7d89
   1455  7d89							;		  inc Throttle		      ; 5     speed limiter
      0  7d89					      SLEEP	5	;	 TODO: optimize for space
      1  7d89				   .CYCLES    SET	5
      2  7d89
      3  7d89				  -	      IF	.CYCLES < 2
      4  7d89				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7d89				  -	      ERR
      6  7d89					      ENDIF
      7  7d89
      8  7d89					      IF	.CYCLES & 1
      9  7d89					      IFNCONST	NO_ILLEGAL_OPCODES
     10  7d89		       04 00		      nop	0
     11  7d8b				  -	      ELSE
     12  7d8b				  -	      bit	VSYNC
     13  7d8b					      ENDIF
     14  7d8b				   .CYCLES    SET	.CYCLES - 3
     15  7d8b					      ENDIF
     16  7d8b
     17  7d8b					      REPEAT	.CYCLES / 2
     18  7d8b		       ea		      nop
     19  7d8c					      REPEND
   1457  7d8c
   1458  7d8c		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
   1459  7d8e		       ca		      dex		; 2	 = $6f, stars effect!
   1460  7d8f		       86 62		      stx	HMM0	; 3	 @24, exactly 21 cycles after the HMOVE
   1461  7d91
   1462  7d91		       85 44		      sta	NUSIZ0	; 3
   1463  7d93		       84 65		      sty	VDELP0	; 3	 y = 0!
   1464  7d95
   1465  7d95		       c8		      iny		; 2	 this relies on Y == 0 before...
   1466  7d96		       c4 c6		      cpy	extraLifeTimer	; 3	 ..,and bit 0 is set in A
   1467  7d98		       69 02		      adc	#2	; 2
   1468  7d9a		       85 5d		      sta	ENAM0	; 3	 dis/enable Cosmic Ark star effect
   1469  7d9c
   1470  7d9c		       a5 a8		      lda	ManLastDirection	; 3
   1471  7d9e		       85 4b		      sta	REFP0	; 3
   1472  7da0
   1473  7da0		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
   1474  7da2		       85 3e		      sta	SET_BANK_RAM	; 3
   1475  7da4		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1476  7da7							;	 @66
   1477  7da7		       a9 07		      lda	#BANK_PostScreenCleanup	; 2
   1478  7da9		       85 3f		      sta	SET_BANK	; 3
   1479  7dab		       20 41 f6 	      jsr	PostScreenCleanup	; 6+x
   1480  7dae
   1481  7dae		       a9 04		      lda	#BANK_SelfModDrawPlayers	; 2
   1482  7db0		       85 3f		      sta	SET_BANK	; 3
   1483  7db2		       20 fb f2 	      jsr	SelfModDrawPlayers	; 6+x
   1484  7db5
   1485  7db5		       24 cc		      bit	amoebaFlag	; AMOEBA_PRESENT?
   1486  7db7		       50 07		      bvc	noscanning	; NO amoeba on this level so skip scan
   1487  7db9
   1488  7db9		       a9 08		      lda	#BANK_ProcessAmoeba	; 2
   1489  7dbb		       85 3f		      sta	SET_BANK	; 3
   1490  7dbd		       20 70 f1 	      jsr	ProcessAmoeba	; 6+x
   1491  7dc0				   noscanning
   1492  7dc0
   1493  7dc0		       20 50 fc 	      jsr	StealCharDraw
   1494  7dc3					      IF	SORT_OBJECTS = YES
   1495  7dc3		       20 0d ff 	      jsr	SortObjects2	;6+15 minimum	Opportunistic sorting
   1496  7dc6					      ENDIF
   1497  7dc6
   1498  7dc6		       ad 84 02    OverscanBD lda	INTIM	;4
   1499  7dc9		       d0 fb		      bne	OverscanBD	;2/3
   1500  7dcb		       f0 8f		      beq	NewFrameBD	;3	 unconditional
   1501  7dcd
   1502  7dcd				   VBlankTime
   1503  7dcd							; TJ: used by:
   1504  7dcd							; - BANK_FIXED.asm
   1505  7dcd		       3e 3e		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
   1506  7dcf		       55 3e		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_NTSC
   1507  7dd1
   1508  7dd1							;---------------------------------------------------------------------------
   1509  7dd1
   1510  7dd1				   CharacterDataVecLO
   1511  7dd1							; TJ: used by:
   1512  7dd1							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1513  7dd1
   1514  7dd1							; Two entries per character.  2nd is ptr to mirrored character
   1515  7dd1							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
   1516  7dd1
   1517  7dd1		       3a		      .byte.b	<CHARACTERSHAPE_BLANK
   1518  7dd2		       3a		      .byte.b	<CHARACTERSHAPE_BLANK
   1519  7dd3		       25		      .byte.b	<CHARACTERSHAPE_SOIL
   1520  7dd4		       25		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
   1521  7dd5		       77		      .byte.b	<CHARACTERSHAPE_BOULDER
   1522  7dd6		       8c		      .byte.b	<CHARACTERSHAPE_BOULDER_MIRRORED
   1523  7dd7		       00		      .byte.b	<CHARACTERSHAPE_AMOEBA
   1524  7dd8		       15		      .byte.b	<CHARACTERSHAPE_AMOEBA_MIRRORED
   1525  7dd9		       e6		      .byte.b	<CHARACTERSHAPE_DIAMOND
   1526  7dda		       d1		      .byte.b	<CHARACTERSHAPE_DIAMOND_MIRRORED
   1527  7ddb		       e5		      .byte.b	<CHARACTERSHAPE_DIAMOND2
   1528  7ddc		       d0		      .byte.b	<CHARACTERSHAPE_DIAMOND2_MIRRORED
   1529  7ddd		       3a		      .byte.b	<CHARACTERSHAPE_BLANK
   1530  7dde		       3a		      .byte.b	<CHARACTERSHAPE_BLANK
   1531  7ddf		       a1		      .byte.b	<CHARACTERSHAPE_FLUTTERBY
   1532  7de0		       a1		      .byte.b	<CHARACTERSHAPE_FLUTTERBY
   1533  7de1		       b6		      .byte.b	<CHARACTERSHAPE_FLUTTERBY2
   1534  7de2		       b6		      .byte.b	<CHARACTERSHAPE_FLUTTERBY2
   1535  7de3		       7e		      .byte.b	<CHARACTERSHAPE_FIREFLY
   1536  7de4		       7e		      .byte.b	<CHARACTERSHAPE_FIREFLY
   1537  7de5		       93		      .byte.b	<CHARACTERSHAPE_FIREFLY2
   1538  7de6		       93		      .byte.b	<CHARACTERSHAPE_FIREFLY2
   1539  7de7		       54		      .byte.b	<CHARACTERSHAPE_WALL0
   1540  7de8		       69		      .byte.b	<CHARACTERSHAPE_WALL0_MIRRORED
   1541  7de9		       e2		      .byte.b	<CHARACTERSHAPE_WALL1
   1542  7dea		       e2		      .byte.b	<CHARACTERSHAPE_WALL1
   1543  7deb		       54		      .byte.b	<CHARACTERSHAPE_WALL0
   1544  7dec		       54		      .byte.b	<CHARACTERSHAPE_WALL0
   1545  7ded		       cd		      .byte.b	<CHARACTERSHAPE_WALL2
   1546  7dee		       cd		      .byte.b	<CHARACTERSHAPE_WALL2
   1547  7def		       cb		      .byte.b	<CHARACTERSHAPE_STEEL
   1548  7df0		       e0		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
   1549  7df1		       54		      .byte.b	<CHARACTERSHAPE_WALL
   1550  7df2		       69		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
   1551  7df3		       cb		      .byte.b	<CHARACTERSHAPE_EXITDOOR
   1552  7df4		       e0		      .byte.b	<CHARACTERSHAPE_EXITDOOR_MIRRORED
   1553  7df5		       3a		      .byte.b	<CHARACTERSHAPE_EXITDOOR2
   1554  7df6		       3a		      .byte.b	<CHARACTERSHAPE_EXITDOOR2
   1555  7df7
   1556  7df7		       a7		      .byte.b	<CHARACTERSHAPE_EXPLOSION
   1557  7df8		       a7		      .byte.b	<CHARACTERSHAPE_EXPLOSION_MIRRORED
   1558  7df9		       92		      .byte.b	<CHARACTERSHAPE_EXPLOSION1
   1559  7dfa		       92		      .byte.b	<CHARACTERSHAPE_EXPLOSION1_MIRRORED
   1560  7dfb		       a7		      .byte.b	<CHARACTERSHAPE_EXPLOSION2
   1561  7dfc		       a7		      .byte.b	<CHARACTERSHAPE_EXPLOSION2_MIRRORED
   1562  7dfd		       bb		      .byte.b	<CHARACTERSHAPE_EXPLOSION3
   1563  7dfe		       bb		      .byte.b	<CHARACTERSHAPE_EXPLOSION3_MIRRORED
   1564  7dff
   1565  7dff		       2a		      .byte.b	<CHARACTERSHAPE_AMOEBA2
   1566  7e00		       3f		      .byte.b	<CHARACTERSHAPE_AMOEBA2_MIRRORED
   1567  7e01
   1568  7e01		       77		      .byte.b	<CHARACTERSHAPE_BOULDER	; falling boulder
   1569  7e02		       8c		      .byte.b	<CHARACTERSHAPE_BOULDER_MIRRORED	; falling boulder
   1570  7e03		       e6		      .byte.b	<CHARACTERSHAPE_DIAMOND	; falling diamond
   1571  7e04		       d1		      .byte.b	<CHARACTERSHAPE_DIAMOND_MIRRORED	; falling diamond
   1572  7e05
   1573  7e05		       3a		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
   1574  7e06		       3a		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
   1575  7e07
   1576  7e07				  -	      IF	* - CharacterDataVecLO < CHARACTER_MAXIMUM*2
   1577  7e07				  -	      ECHO	"ERROR: Missing entry in CharacterDataVecLO table!"
   1578  7e07				  -	      EXIT
   1579  7e07					      ENDIF
   1580  7e07
   1581  7e07							;---------------------------------------------------------------------------
   1582  7e07
   1583  7e07				   CharacterDataVecHI
   1584  7e07							; TJ: used by:
   1585  7e07							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1586  7e07
   1587  7e07		       73		      .byte.b	( >CHARACTERSHAPE_BLANK ) & $7F
   1588  7e08		       73		      .byte.b	( >CHARACTERSHAPE_BLANK ) & $7F
   1589  7e09		       f3		      .byte.b	>CHARACTERSHAPE_SOIL
   1590  7e0a		       f3		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
   1591  7e0b		       ff		      .byte.b	>CHARACTERSHAPE_BOULDER
   1592  7e0c		       ff		      .byte.b	>CHARACTERSHAPE_BOULDER_MIRRORED
   1593  7e0d		       f8		      .byte.b	>CHARACTERSHAPE_AMOEBA
   1594  7e0e		       f8		      .byte.b	>CHARACTERSHAPE_AMOEBA_MIRRORED
   1595  7e0f		       f2		      .byte.b	>CHARACTERSHAPE_DIAMOND
   1596  7e10		       f2		      .byte.b	>CHARACTERSHAPE_DIAMOND_MIRRORED
   1597  7e11		       f2		      .byte.b	>CHARACTERSHAPE_DIAMOND2
   1598  7e12		       f2		      .byte.b	>CHARACTERSHAPE_DIAMOND2_MIRRORED
   1599  7e13		       73		      .byte.b	( >CHARACTERSHAPE_BLANK ) & $7F	;manoccupied
   1600  7e14		       73		      .byte.b	( >CHARACTERSHAPE_BLANK ) & $7F	;manoccupied
   1601  7e15		       ff		      .byte.b	>CHARACTERSHAPE_FLUTTERBY
   1602  7e16		       ff		      .byte.b	>CHARACTERSHAPE_FLUTTERBY
   1603  7e17		       ff		      .byte.b	>CHARACTERSHAPE_FLUTTERBY2
   1604  7e18		       ff		      .byte.b	>CHARACTERSHAPE_FLUTTERBY2
   1605  7e19		       f8		      .byte.b	>CHARACTERSHAPE_FIREFLY
   1606  7e1a		       f8		      .byte.b	>CHARACTERSHAPE_FIREFLY
   1607  7e1b		       f8		      .byte.b	>CHARACTERSHAPE_FIREFLY2
   1608  7e1c		       f8		      .byte.b	>CHARACTERSHAPE_FIREFLY2
   1609  7e1d		       f8		      .byte.b	>CHARACTERSHAPE_WALL0
   1610  7e1e		       f8		      .byte.b	>CHARACTERSHAPE_WALL0_MIRRORED
   1611  7e1f		       f3		      .byte.b	>CHARACTERSHAPE_WALL1
   1612  7e20		       f3		      .byte.b	>CHARACTERSHAPE_WALL1
   1613  7e21		       f8		      .byte.b	>CHARACTERSHAPE_WALL0
   1614  7e22		       f8		      .byte.b	>CHARACTERSHAPE_WALL0
   1615  7e23		       f3		      .byte.b	>CHARACTERSHAPE_WALL2
   1616  7e24		       f3		      .byte.b	>CHARACTERSHAPE_WALL2
   1617  7e25		       ff		      .byte.b	>CHARACTERSHAPE_STEEL
   1618  7e26		       ff		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
   1619  7e27		       f8		      .byte.b	>CHARACTERSHAPE_WALL
   1620  7e28		       f8		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
   1621  7e29		       ff		      .byte.b	>CHARACTERSHAPE_EXITDOOR
   1622  7e2a		       ff		      .byte.b	>CHARACTERSHAPE_EXITDOOR_MIRRORED
   1623  7e2b		       73		      .byte.b	( >CHARACTERSHAPE_EXITDOOR2 ) & $7F
   1624  7e2c		       73		      .byte.b	( >CHARACTERSHAPE_EXITDOOR2 ) & $7F
   1625  7e2d
   1626  7e2d		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION
   1627  7e2e		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION_MIRRORED
   1628  7e2f		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION1
   1629  7e30		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION1_MIRRORED
   1630  7e31		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION2
   1631  7e32		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION2_MIRRORED
   1632  7e33		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION3
   1633  7e34		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION3_MIRRORED
   1634  7e35
   1635  7e35		       f8		      .byte.b	>CHARACTERSHAPE_AMOEBA2
   1636  7e36		       f8		      .byte.b	>CHARACTERSHAPE_AMOEBA2_MIRRORED
   1637  7e37
   1638  7e37		       ff		      .byte.b	>CHARACTERSHAPE_BOULDER	; falling boulder
   1639  7e38		       ff		      .byte.b	>CHARACTERSHAPE_BOULDER_MIRRORED	; falling boulder
   1640  7e39		       f2		      .byte.b	>CHARACTERSHAPE_DIAMOND	; falling diamond
   1641  7e3a		       f2		      .byte.b	>CHARACTERSHAPE_DIAMOND_MIRRORED	; falling diamond
   1642  7e3b
   1643  7e3b		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
   1644  7e3c		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
   1645  7e3d
   1646  7e3d				  -	      IF	* - CharacterDataVecHI < CHARACTER_MAXIMUM*2
   1647  7e3d				  -	      ECHO	"ERROR: Missing entry in CharacterDataVecHI table!"
   1648  7e3d				  -	      EXIT
   1649  7e3d					      ENDIF
   1650  7e3d
   1651  7e3d							;---------------------------------------------------------------------------
   1652  7e3d
   1653  7e3d				   GenericCharFlag
   1654  7e3d							; TJ: used by:
   1655  7e3d							; - BANK_FIXED.asm
   1656  7e3d							; - BANK_INITBANK.asm
   1657  7e3d							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1658  7e3d
   1659  7e3d							; Tells us information about a particular character.  Multiple bits define characteristics
   1660  7e3d							; of how the character behaves during gameplay.
   1661  7e3d
   1662  7e3d		       0a		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_SQUASHABLE	; blank
   1663  7e3e		       08		      .byte.b	GENERIC_MASK_EXPLODABLE	; soil
   1664  7e3f		       89		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_ROUNDED|GENERIC_MASK_FALLABLE	; boulder
   1665  7e40		       18		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_KILLSBUTTERFLY	; Amoeba
   1666  7e41		       89		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_ROUNDED|GENERIC_MASK_FALLABLE	; diamond
   1667  7e42		       89		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_ROUNDED|GENERIC_MASK_FALLABLE	; diamond2
   1668  7e43		       1a		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_SQUASHABLE|GENERIC_MASK_KILLSBUTTERFLY	; man
   1669  7e44
   1670  7e44							; Note: Butterflies and fireflies are not explodable, to prevent chain-reactions
   1671  7e44
   1672  7e44		       02		      .byte.b	GENERIC_MASK_SQUASHABLE	; butterfly
   1673  7e45		       02		      .byte.b	GENERIC_MASK_SQUASHABLE	; butterfly
   1674  7e46		       02		      .byte.b	GENERIC_MASK_SQUASHABLE	; firefly
   1675  7e47		       02		      .byte.b	GENERIC_MASK_SQUASHABLE	; firefly
   1676  7e48		       22		      .byte.b	GENERIC_MASK_SQUASHABLE|GENERIC_MASK_MAGICWALL	; magic wall
   1677  7e49		       22		      .byte.b	GENERIC_MASK_SQUASHABLE|GENERIC_MASK_MAGICWALL	; magic wall
   1678  7e4a		       22		      .byte.b	GENERIC_MASK_SQUASHABLE|GENERIC_MASK_MAGICWALL	; magic wall
   1679  7e4b		       22		      .byte.b	GENERIC_MASK_SQUASHABLE|GENERIC_MASK_MAGICWALL	; magic wall
   1680  7e4c		       00		      .byte.b	0	; steel wall
   1681  7e4d		       09		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_ROUNDED	; plain brick wall
   1682  7e4e		       00		      .byte.b	0	; exit
   1683  7e4f		       00		      .byte.b	0	; exit
   1684  7e50		       00		      .byte.b	0	; explosion
   1685  7e51		       00		      .byte.b	0	; explosion 1
   1686  7e52		       00		      .byte.b	0	; explosion 2
   1687  7e53		       00		      .byte.b	0	; explosion 3
   1688  7e54		       18		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_KILLSBUTTERFLY	; amoeba2
   1689  7e55
   1690  7e55		       09		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_ROUNDED	; falling boulder
   1691  7e56		       09		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_ROUNDED	; falling diamond
   1692  7e57
   1693  7e57		       00		      .byte.b	0	; unkillable man
   1694  7e58
   1695  7e58				  -	      IF	* - GenericCharFlag < CHARACTER_MAXIMUM
   1696  7e58				  -	      ECHO	"ERROR: Missing entry in GenericCharFlag table!"
   1697  7e58				  -	      EXIT
   1698  7e58					      ENDIF
   1699  7e58
   1700  7e58							;---------------------------------------------------------------------------
   1701  7e58
   1702  7e58				   BaseTypeCharacter
   1703  7e58							; TJ: used by:
   1704  7e58							; - BANK_FIXED.asm
   1705  7e58
   1706  7e58							; Given an object type, gives a base character to use for that type
   1707  7e58							; essentially the conversion BaseTypeCharacer[ TYPE ] --> character
   1708  7e58
   1709  7e58		       06		      .byte.b	CHARACTER_MANOCCUPIED
   1710  7e59		       02		      .byte.b	CHARACTER_BOULDER
   1711  7e5a		       03		      .byte.b	CHARACTER_AMOEBA
   1712  7e5b		       07		      .byte.b	CHARACTER_FLUTTERBY
   1713  7e5c		       09		      .byte.b	CHARACTER_FIREFLY
   1714  7e5d		       04		      .byte.b	CHARACTER_DIAMOND
   1715  7e5e		       0b		      .byte.b	CHARACTER_WALL0
   1716  7e5f		       11		      .byte.b	CHARACTER_EXITDOOR	; exit door
   1717  7e60		       00		      .byte.b	CHARACTER_BLANK	; select
   1718  7e61		       13		      .byte.b	CHARACTER_EXPLOSION
   1719  7e62		       14		      .byte.b	CHARACTER_EXPLOSION1
   1720  7e63		       15		      .byte.b	CHARACTER_EXPLOSION2
   1721  7e64		       16		      .byte.b	CHARACTER_EXPLOSION3
   1722  7e65		       00		      .byte.b	CHARACTER_BLANK
   1723  7e66		       01		      .byte.b	CHARACTER_SOIL
   1724  7e67		       0f		      .byte.b	CHARACTER_STEEL
   1725  7e68		       10		      .byte.b	CHARACTER_WALL
   1726  7e69
   1727  7e69							;--> if adding types, also see InitialFace in DecodeCave.asm
   1728  7e69
   1729  7e69				  -	      IF	* - BaseTypeCharacter < TYPE_MAXIMUM
   1730  7e69				  -	      ECHO	"ERROR: Missing entry in BaseTypeCharacter table!"
   1731  7e69				  -	      EXIT
   1732  7e69					      ENDIF
   1733  7e69
   1734  7e69							;---------------------------------------------------------------------------
   1735  7e69
   1736  7e69				   BaseTypeCharacterFalling
   1737  7e69							; TJ: used by:
   1738  7e69							; - BANK_FIXED.asm
   1739  7e69
   1740  7e69							; Given an object type, gives a base character to use for that type
   1741  7e69							; essentially the conversion BaseTypeCharacer[ TYPE ] --> character
   1742  7e69
   1743  7e69		       06		      .byte.b	CHARACTER_MANOCCUPIED
   1744  7e6a		       18		      .byte.b	CHARACTER_BOULDER_FALLING
   1745  7e6b		       03		      .byte.b	CHARACTER_AMOEBA
   1746  7e6c		       07		      .byte.b	CHARACTER_FLUTTERBY
   1747  7e6d		       09		      .byte.b	CHARACTER_FIREFLY
   1748  7e6e		       19		      .byte.b	CHARACTER_DIAMOND_FALLING
   1749  7e6f		       0b		      .byte.b	CHARACTER_WALL0
   1750  7e70		       11		      .byte.b	CHARACTER_EXITDOOR	; exit door
   1751  7e71		       00		      .byte.b	CHARACTER_BLANK	; select
   1752  7e72		       13		      .byte.b	CHARACTER_EXPLOSION
   1753  7e73		       14		      .byte.b	CHARACTER_EXPLOSION1
   1754  7e74		       15		      .byte.b	CHARACTER_EXPLOSION2
   1755  7e75		       16		      .byte.b	CHARACTER_EXPLOSION3
   1756  7e76		       00		      .byte.b	CHARACTER_BLANK
   1757  7e77		       01		      .byte.b	CHARACTER_SOIL
   1758  7e78		       0f		      .byte.b	CHARACTER_STEEL
   1759  7e79		       10		      .byte.b	CHARACTER_WALL
   1760  7e7a
   1761  7e7a							;--> if adding types, also see InitialFace in DecodeCave.asm
   1762  7e7a
   1763  7e7a				  -	      IF	* - BaseTypeCharacterFalling < TYPE_MAXIMUM
   1764  7e7a				  -	      ECHO	"ERROR: Missing entry in BaseTypeCharacterFalling table!"
   1765  7e7a				  -	      EXIT
   1766  7e7a					      ENDIF
   1767  7e7a
   1768  7e7a							;---------------------------------------------------------------------------
   1769  7e7a
      0  7e7a					      DEFINE_SUBROUTINE	CharToType	; in FIXED_BANK
      1  7e7a		       00 0f	   BANK_CharToType =	_CURRENT_BANK
      2  7e7a					      SUBROUTINE
      3  7e7a				   CharToType
   1771  7e7a							; TJ: used by:
   1772  7e7a							; - BANK_FIXED.asm
   1773  7e7a							; - BANK_INITBANK.asm
   1774  7e7a
   1775  7e7a							; Converts a character # to a creature type
   1776  7e7a							; add 128 if character is NOT to be added as a creature on board draw
   1777  7e7a
   1778  7e7a		       0d		      .byte.b	TYPE_BLANK	;  0	 blank
   1779  7e7b		       0e		      .byte.b	TYPE_SOIL	;  1	 soil
   1780  7e7c		       01		      .byte.b	TYPE_BOULDER	;  2
   1781  7e7d		       02		      .byte.b	TYPE_AMOEBA	;  3
   1782  7e7e		       05		      .byte.b	TYPE_DIAMOND	;  4
   1783  7e7f		       05		      .byte.b	TYPE_DIAMOND	;  5
   1784  7e80		       00		      .byte.b	TYPE_MAN	;  6
   1785  7e81		       03		      .byte.b	TYPE_FLUTTERBY	;  7
   1786  7e82		       03		      .byte.b	TYPE_FLUTTERBY	;  8
   1787  7e83		       04		      .byte.b	TYPE_FIREFLY	;  9
   1788  7e84		       04		      .byte.b	TYPE_FIREFLY	; 0a
   1789  7e85		       06		      .byte.b	TYPE_MAGICWALL	; 0b
   1790  7e86		       06		      .byte.b	TYPE_MAGICWALL	; 0c
   1791  7e87		       06		      .byte.b	TYPE_MAGICWALL	; 0d
   1792  7e88		       06		      .byte.b	TYPE_MAGICWALL	; 0e
   1793  7e89		       0f		      .byte.b	TYPE_STEELWALL	; 0f	  ; steel wall
   1794  7e8a		       10		      .byte.b	TYPE_BRICKWALL	; 10	  ; plain brick wall
   1795  7e8b		       07		      .byte.b	TYPE_EXITDOOR	; 11
   1796  7e8c		       07		      .byte.b	TYPE_EXITDOOR	; 12
   1797  7e8d		       09		      .byte.b	TYPE_EXPLOSION	; 13
   1798  7e8e		       0a		      .byte.b	TYPE_EXPLOSION1	; 14
   1799  7e8f		       0b		      .byte.b	TYPE_EXPLOSION2	; 15
   1800  7e90		       0c		      .byte.b	TYPE_EXPLOSION3	; 16
   1801  7e91		       02		      .byte.b	TYPE_AMOEBA	; 17
   1802  7e92
   1803  7e92		       01		      .byte.b	TYPE_BOULDER	; falling boulder
   1804  7e93		       05		      .byte.b	TYPE_DIAMOND	; falling diamond
   1805  7e94
   1806  7e94		       0d		      .byte.b	TYPE_BLANK	; 20 unkillable man
   1807  7e95							; --> see also MoveVec
   1808  7e95							; --> see also DecodeCave's table
   1809  7e95
   1810  7e95				  -	      IF	* - CharToType < CHARACTER_MAXIMUM
   1811  7e95				  -	      ECHO	"ERROR: Missing entry in CharToType table!"
   1812  7e95				  -	      EXIT
   1813  7e95					      ENDIF
   1814  7e95
   1815  7e95							;---------------------------------------------------------------------------
   1816  7e95
      0  7e95					      DEFINE_SUBROUTINE	AnimateCharReplacements2	;139
      1  7e95		       00 0f	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  7e95					      SUBROUTINE
      3  7e95				   AnimateCharReplacements2
   1818  7e95							; TJ: used by:
   1819  7e95							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1820  7e95
   1821  7e95							; This manages character animation on a per-object basis.  Morph/animate these
   1822  7e95							; characters individually or as required.  Change will affect all characters
   1823  7e95							; of the same type in the visible display.
   1824  7e95
   1825  7e95		       ad db f2 	      lda	ANIM_BUTTERFLY0	;4
   1826  7e98		       49 0f		      eor	#CHARACTER_FLUTTERBY^CHARACTER_FLUTTERBY2	;2
   1827  7e9a		       8d db f6 	      sta	ANIM_BUTTERFLY0 + RAM_WRITE	;4
   1828  7e9d		       8d dc f6 	      sta	ANIM_BUTTERFLY1 + RAM_WRITE	;4 = 14	 butterfly
   1829  7ea0
   1830  7ea0		       ad dd f2 	      lda	ANIM_FIREFLY0	;4
   1831  7ea3		       49 03		      eor	#CHARACTER_FIREFLY^CHARACTER_FIREFLY2	;2
   1832  7ea5		       8d dd f6 	      sta	ANIM_FIREFLY0 + RAM_WRITE	;4
   1833  7ea8		       8d de f6 	      sta	ANIM_FIREFLY1 + RAM_WRITE	;4 = 14	 firefly
   1834  7eab
   1835  7eab							; handle the mandatory animating things
   1836  7eab
   1837  7eab							; -------------------------------------------
   1838  7eab							; The door will animate when it is 'open'. It's open when the required number of diamonds have been
   1839  7eab							; collected. This in turn triggers the "extra diamonds" flag for scoring, so that is used to determine
   1840  7eab							; when the door should flash.
   1841  7eab
   1842  7eab		       24 c8		      bit	scoringFlags	;3
   1843  7ead		       10 08		      bpl	NoDoor	;2/3		 extra diamonds (D7) set when door animates
   1844  7eaf
   1845  7eaf		       ad e5 f2 	      lda	ANIM_EXITDOOR	;4
   1846  7eb2		       49 03		      eor	#CHARACTER_EXITDOOR2^CHARACTER_EXITDOOR	;2
   1847  7eb4		       8d e5 f6 	      sta	ANIM_EXITDOOR + RAM_WRITE	;4 = 22	 exit door
   1848  7eb7				   NoDoor
   1849  7eb7
   1850  7eb7							; -------------------------------------------
   1851  7eb7
   1852  7eb7							; handle the non-mandatory animating things
   1853  7eb7
   1854  7eb7		       a5 ae		      lda	timer	;3
   1855  7eb9		       29 03		      and	#%11	;2
   1856  7ebb		       d0 14		      bne	nothingAnimates	;2/3
   1857  7ebd
   1858  7ebd		       a5 9c		      lda	scrollBits	;3
   1859  7ebf		       d0 10		      bne	nothingAnimates	;2/3		 DON'T animate if we scrolled
   1860  7ec1
   1861  7ec1		       ad d8 f2 	      lda	ANIM_DIAMOND	;4
   1862  7ec4		       49 01		      eor	#CHARACTER_DIAMOND^CHARACTER_DIAMOND2	;2
   1863  7ec6		       8d d8 f6 	      sta	ANIM_DIAMOND + RAM_WRITE	;4 = 15	 diamond
   1864  7ec9
   1865  7ec9							;lda timer					  ;3
   1866  7ec9							;and #%1 ;1 ;1 				      ;2
   1867  7ec9							;bne nothingAnimates				  ;2/3
   1868  7ec9
   1869  7ec9
   1870  7ec9		       ad d7 f2 	      lda	ANIM_AMOEBA	;4
   1871  7ecc		       49 14		      eor	#CHARACTER_AMOEBA^CHARACTER_AMOEBA2	;2
   1872  7ece		       8d d7 f6 	      sta	ANIM_AMOEBA + RAM_WRITE	;4 = 17	 amoeba
   1873  7ed1
   1874  7ed1				   nothingAnimates
   1875  7ed1
   1876  7ed1							; Handle magic wall animation. If the Magic wall is active, only, then cycle the characters used
   1877  7ed1							; for displaying the wall.
   1878  7ed1
   1879  7ed1		       a6 9d		      ldx	MagicAmoebaFlag	;3
   1880  7ed3		       e8		      inx		;2		 $FF = dormant?
   1881  7ed4		       f0 21		      beq	noMagicWall	;2/3
   1882  7ed6		       ca		      dex		;2		 $00 = set to dormant?
   1883  7ed7		       d0 0e		      bne	animateWall	;2/3
   1884  7ed9
      0  7ed9					      STOP_SOUND	1, OFSS_MAGIC_WALL	;10
      1  7ed9
      2  7ed9		       a9 2c		      lda	#OFSS_MAGIC_WALL
      3  7edb		       45 d6		      eor	soundIdxLst+1
      4  7edd		       d0 04		      bne	.skipStop
      5  7edf		       85 d6		      sta	soundIdxLst+1
      6  7ee1		       85 5a		      sta	AUDV0+1
      7  7ee3				   .skipStop
   1886  7ee3
   1887  7ee3		       a9 0b		      lda	#CHARACTER_WALL0	;2
   1888  7ee5		       d0 0d		      bne	forceToChar0	;2/3
   1889  7ee7
   1890  7ee7				   animateWall
   1891  7ee7
   1892  7ee7							; Because we don't have MIRRORED wall characters, so any regular pattern will look very odd when
   1893  7ee7							; displayed across the mirrored PF registers.	With a random pattern, it's totally obscured.
   1894  7ee7
   1895  7ee7		       45 87		      eor	rnd	;3
   1896  7ee9		       69 01	   reGen      adc	#1	;2
   1897  7eeb		       29 03		      and	#3	;2
   1898  7eed		       69 0b		      adc	#CHARACTER_WALL0	;2
   1899  7eef		       cd df f2 	      cmp	ANIM_MAGICWALL	;3
   1900  7ef2		       f0 f5		      beq	reGen	;2/3		 (worst case 1 repeat = +11)
   1901  7ef4		       8d df f6    forceToChar0 sta	ANIM_MAGICWALL + RAM_WRITE	;3 = 29
   1902  7ef7
   1903  7ef7				   noMagicWall
   1904  7ef7		       4c 28 f2 	      jmp	retAnim	;3
   1905  7efa
   1906  7efa
   1907  7efa							;---------------------------------------------------------------------------
   1908  7efa
      0  7efa					      DEFINE_SUBROUTINE	ScoreAdd
      1  7efa		       00 0f	   BANK_ScoreAdd =	_CURRENT_BANK
      2  7efa					      SUBROUTINE
      3  7efa				   ScoreAdd
   1910  7efa							; TJ: used by:
   1911  7efa							; - BANK_INITBANK.asm
   1912  7efa		       a2 09		      ldx	#BANK_SCORING
   1913  7efc		       86 3e		      stx	SET_BANK_RAM
   1914  7efe		       20 0f f2 	      jsr	UpdateScore
   1915  7f01		       a5 c3	   rbret      lda	ROM_Bank
   1916  7f03		       85 3f		      sta	SET_BANK
   1917  7f05		       60		      rts
   1918  7f06
   1919  7f06							;---------------------------------------------------------------------------
   1920  7f06
      0  7f06					      DEFINE_SUBROUTINE	nextLevelMan
      1  7f06		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7f06					      SUBROUTINE
      3  7f06				   nextLevelMan
   1922  7f06							; TJ: used by:
   1923  7f06							; - BANK_INITBANK.asm
   1924  7f06		       a9 03		      lda	#BANK_NextCave
   1925  7f08		       85 3f		      sta	SET_BANK
   1926  7f0a		       4c b3 f4 	      jmp	NextCave
   1927  7f0d
   1928  7f0d							;---------------------------------------------------------------------------
   1929  7f0d
      0  7f0d					      DEFINE_SUBROUTINE	SortObjects2	;=128(A), minimum 15 @ segtime exit
      1  7f0d		       00 0f	   BANK_SortObjects2 =	_CURRENT_BANK
      2  7f0d					      SUBROUTINE
      3  7f0d				   SortObjects2
   1931  7f0d							; TJ: used by:
   1932  7f0d							; - BANK_FIXED.asm
   1933  7f0d
   1934  7f0d		       ad 84 02 	      lda	INTIM	;4
   1935  7f10		       c9 03		      cmp	#MINIMUM_SORT_TIME	;2
   1936  7f12		       90 4d		      bcc	.sortExit	;2(3)=8	insufficient time
      0  7f14					      STRESS_TIME	MINIMUM_SORT_TIME
      1  7f14				  -	      IF	TEST_MINIMUM_SORT_TIME = 1
      2  7f14				  -
      3  7f14				  -
      4  7f14				  -
      5  7f14				  -
      6  7f14				  -
      7  7f14				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7f14				  -	      bne	. - 7
      9  7f14					      ENDIF
   1938  7f14
   1939  7f14		       a6 8a		      ldx	ObjStackNum	;3
   1940  7f16		       bd ac fb 	      lda	BankObjStack,x	;4
   1941  7f19		       85 3e		      sta	SET_BANK_RAM	;3
   1942  7f1b		       4c 59 ff 	      jmp	.enterSort	;3 = 13
   1943  7f1e
   1944  7f1e				   restartSort		;  = 11
   1945  7f1e
   1946  7f1e							; So there's another sort 'starting' and we reset the ptr to the end of the obj list
   1947  7f1e
   1948  7f1e							; retrieve size of list to sort
   1949  7f1e		       a9 ff		      lda	#<(-1)	;2
   1950  7f20		       85 d3		      sta	sortRequired	;3		 flag that we're DOING it
   1951  7f22
   1952  7f22		       a6 8a		      ldx	ObjStackNum	;3
   1953  7f24		       b4 8b		      ldy	ObjStackPtr,x	;4		 index of 1st free slot = # slots in use
   1954  7f26		       88		      dey		;2
   1955  7f27		       84 d4		      sty	sortPtr	;3		 earlier potential swappable object
   1956  7f29		       f0 36		      beq	.sortExit	;2/3
   1957  7f2b
   1958  7f2b				   midSort		;  =  6
   1959  7f2b
   1960  7f2b		       b9 80 11 	      lda	SortedObjPtr,y	;4		 y = sortPtr!
   1961  7f2e		       be 7f 11 	      ldx	SortedObjPtr-1,y	;4		 the 'current' object looking to be sorted correctly
   1962  7f31		       a8		      tay		;2
   1963  7f32
   1964  7f32		       bd 80 10 	      lda	ObjStackY,x	;4
   1965  7f35		       d9 80 10 	      cmp	ObjStackY,y	;4
   1966  7f38		       90 16		      bcc	earlierObject	;2(3)
   1967  7f3a		       d0 08		      bne	swapAround	;2(3)
   1968  7f3c
   1969  7f3c		       b9 00 10 	      lda	ObjStackX,y	;4
   1970  7f3f		       dd 00 10 	      cmp	ObjStackX,x	;4
   1971  7f42		       b0 0c		      bcs	earlierObject	;2(3)		 WE DO NOT WANT TO SWAP IF == OTHERWISE LOCKUP
   1972  7f44
   1973  7f44				   swapAround		;   = 32 max.
   1974  7f44		       98		      tya		;2		 y = SortedObjPtr[sortPtr]
   1975  7f45		       a4 d4		      ldy	sortPtr	;3
   1976  7f47		       99 7f 15 	      sta	SortedObjPtr+RAM_WRITE-1,y	;5
   1977  7f4a		       8a		      txa		;2		 x = SortedObjPtr[sortPtr-1]
   1978  7f4b		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	;5
   1979  7f4e		       84 d3		      sty	sortRequired	;3 = 20	 as we've done a swap, ensure another pass (ANY non-neg value)
   1980  7f50
   1981  7f50		       c6 d4	   earlierObject dec	sortPtr	;5 =  5	 look at earlier object
   1982  7f52
   1983  7f52		       ad 84 02 	      lda	INTIM	;4
   1984  7f55		       c9 03		      cmp	#MINIMUM_SORT_TIME	;2
   1985  7f57		       90 08		      bcc	.sortExit	;2(3)=8	insufficient time
      0  7f59					      STRESS_TIME	MINIMUM_SORT_TIME
      1  7f59				  -	      IF	TEST_MINIMUM_SORT_TIME = 1
      2  7f59				  -
      3  7f59				  -
      4  7f59				  -
      5  7f59				  -
      6  7f59				  -
      7  7f59				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7f59				  -	      bne	. - 7
      9  7f59					      ENDIF
   1987  7f59							; loop max: 71 cycles, + 15 for exit + overhead outside
   1988  7f59							; -> MINIMUM_SORT_TIME = ceiling(86/64)+1 = 3
   1989  7f59							; TJ: I do not count the 1st INTIM, that's why I have 4 cylces less.
   1990  7f59				   .enterSort
   1991  7f59		       a4 d4		      ldy	sortPtr	;3		 sort 'stops' when potential swappable objects run out
   1992  7f5b		       d0 ce		      bne	midSort	;2(3)=5
   1993  7f5d		       a5 d3		      lda	sortRequired	;3		 AND there were no more sort requests
   1994  7f5f		       10 bd		      bpl	restartSort	;2(3)=5
   1995  7f61
   1996  7f61		       60	   .sortExit  rts		;6		 completed sort! (or time exit)
   1997  7f62
   1998  7f62
   1999  7f62							;---------------------------------------------------------------------------
   2000  7f62
      0  7f62					      DEFINE_SUBROUTINE	goGeneralScoringSetups
      1  7f62		       00 0f	   BANK_goGeneralScoringSetups =	_CURRENT_BANK
      2  7f62					      SUBROUTINE
      3  7f62				   goGeneralScoringSetups
   2002  7f62							; TJ: used by:
   2003  7f62							; - BANK_INITBANK.asm
   2004  7f62		       a9 09		      lda	#BANK_SCORING
   2005  7f64		       85 3e		      sta	SET_BANK_RAM
   2006  7f66		       20 ae f2 	      jsr	GeneralScoringSetups
   2007  7f69		       a5 c3		      lda	ROM_Bank
   2008  7f6b		       85 3f		      sta	SET_BANK
   2009  7f6d		       60		      rts
   2010  7f6e
   2011  7f6e
   2012  7f6e							;---------------------------------------------------------------------------
   2013  7f6e
      0  7f6e					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7f6e		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7f6e					      SUBROUTINE
      3  7f6e				   CopyROM2RAM_F000
   2015  7f6e							; TJ: used by:
   2016  7f6e							; - BANK_FIXED.asm
   2017  7f6e
   2018  7f6e		       a9 08		      lda	#BANK_CopyROMShadowToRAM
   2019  7f70		       85 3f		      sta	SET_BANK
   2020  7f72		       85 c3		      sta	ROM_Bank
   2021  7f74		       4c 43 f0 	      jmp	CopyROMShadowToRAM_F000
   2022  7f77
   2023  7f77
   2024  7f77							;---------------------------------------------------------------------------
   2025  7f77							; TJ: used by:
   2026  7f77							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
------- FILE Boulder.asm LEVEL 3 PASS 3
      0  7f77					      include	"Boulder.asm"	; 2 * LINES_PER_CHAR bytes
      0  7f77					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOULDER", LINES_PER_CHAR
     10  7f77					      LIST	ON
      2  7f77				   CHARACTERSHAPE_BOULDER
      3  7f77				  -	      if	MIRRORED_BOULDER = NO
      4  7f77				  -CHARACTERSHAPE_BOULDER_MIRRORED
      5  7f77					      endif
      6  7f77		       00 00 00 88*	      .byte.b	%00000000,%00000000,%00000000,%10001000,%11001100,%11111111,%01100110	;R
      7  7f7e		       66 dd ff ff*	      .byte.b	%01100110,%11011101,%11111111,%11111111,%11111111,%11111111,%01100110	;G
      8  7f85		       66 dd ee bb*	      .byte.b	%01100110,%11011101,%11101110,%10111011,%11011101,%11101110,%01000100	;B
      9  7f8c
     10  7f8c							;--------------------------------------------------------------------------
     11  7f8c					      if	MIRRORED_BOULDER = YES
      0  7f8c					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOULDER_MIRRORED", LINES_PER_CHAR
     10  7f8c					      LIST	ON
     13  7f8c				   CHARACTERSHAPE_BOULDER_MIRRORED
     14  7f8c		       00 00 00 11*	      .byte.b	%00000000,%00000000,%00000000,%00010001,%00110011,%11111111,%01100110	;R
     15  7f93		       66 bb ff ff*	      .byte.b	%01100110,%10111011,%11111111,%11111111,%11111111,%11111111,%01100110	;G
     16  7f9a		       66 bb 77 dd*	      .byte.b	%01100110,%10111011,%01110111,%11011101,%10111011,%01110111,%00100010	;B
     17  7fa1					      endif
------- FILE BANK_FIXED.asm
------- FILE Butterfly.asm LEVEL 3 PASS 3
      0  7fa1					      include	"Butterfly.asm"	; 2 * LINES_PER_CHAR bytes
      1  7fa1		       00 02	   BUTTERFLY_DEF =	2
      2  7fa1
      3  7fa1				  -	      if	BUTTERFLY_DEF = 0
      4  7fa1				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FLUTTERBY", LINES_PER_CHAR
      5  7fa1				  -CHARACTERSHAPE_FLUTTERBY
      6  7fa1				  -
      7  7fa1				  -			; an x shape
      8  7fa1				  -
      9  7fa1				  -	      .byte	%00000000	;R
     10  7fa1				  -	      .byte	%10011001
     11  7fa1				  -	      .byte	%11111111
     12  7fa1				  -	      .byte	%01100110
     13  7fa1				  -	      .byte	%10011001
     14  7fa1				  -	      .byte	%00000000
     15  7fa1				  -	      .byte	0
     16  7fa1				  -
     17  7fa1				  -	      .byte	%10011001	;G
     18  7fa1				  -	      .byte	%10011001
     19  7fa1				  -	      .byte	%11111111
     20  7fa1				  -	      .byte	%11111111
     21  7fa1				  -	      .byte	%10011001
     22  7fa1				  -	      .byte	%10011001
     23  7fa1				  -	      .byte	0
     24  7fa1				  -
     25  7fa1				  -	      .byte	%00000000	;B
     26  7fa1				  -	      .byte	%10011001
     27  7fa1				  -	      .byte	%01100110
     28  7fa1				  -	      .byte	%11111111
     29  7fa1				  -	      .byte	%10011001
     30  7fa1				  -	      .byte	%00000000
     31  7fa1				  -	      .byte	0
     32  7fa1				  -
     33  7fa1				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FLUTTERBY2", LINES_PER_CHAR
     34  7fa1				  -CHARACTERSHAPE_FLUTTERBY2
     35  7fa1				  -
     36  7fa1				  -			; an x shape (flutter)
     37  7fa1				  -
     38  7fa1				  -	      .byte	%00000000	;R
     39  7fa1				  -	      .byte	%01100110
     40  7fa1				  -	      .byte	%01100110
     41  7fa1				  -	      .byte	%01100110
     42  7fa1				  -	      .byte	%01100110
     43  7fa1				  -	      .byte	%01100110
     44  7fa1				  -	      .byte	0
     45  7fa1				  -
     46  7fa1				  -	      .byte	%01100110	;G
     47  7fa1				  -	      .byte	%01100110
     48  7fa1				  -	      .byte	%01100110
     49  7fa1				  -	      .byte	%01100110
     50  7fa1				  -	      .byte	%01100110
     51  7fa1				  -	      .byte	%01100110
     52  7fa1				  -	      .byte	0
     53  7fa1				  -
     54  7fa1				  -	      .byte	%01100110	;B
     55  7fa1				  -	      .byte	%01100110
     56  7fa1				  -	      .byte	%01100110
     57  7fa1				  -	      .byte	%01100110
     58  7fa1				  -	      .byte	%01100110
     59  7fa1				  -	      .byte	%00000000
     60  7fa1				  -	      .byte	0
     61  7fa1					      endif
     62  7fa1
     63  7fa1				  -	      if	BUTTERFLY_DEF = 1
     64  7fa1				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FLUTTERBY", LINES_PER_CHAR
     65  7fa1				  -CHARACTERSHAPE_FLUTTERBY
     66  7fa1				  -
     67  7fa1				  -			; an x shape
     68  7fa1				  -
     69  7fa1				  -	      .byte	%10011001	;R (#3 bright color)
     70  7fa1				  -	      .byte	%11011101
     71  7fa1				  -	      .byte	%11111111
     72  7fa1				  -	      .byte	%01100110
     73  7fa1				  -	      .byte	%11111111
     74  7fa1				  -	      .byte	%10111011
     75  7fa1				  -	      .byte	%10011001
     76  7fa1				  -
     77  7fa1				  -	      .byte	%00000000	;G (#2 dirt color)
     78  7fa1				  -	      .byte	%10001000
     79  7fa1				  -	      .byte	%11111111
     80  7fa1				  -	      .byte	%01100110
     81  7fa1				  -	      .byte	%01000100
     82  7fa1				  -	      .byte	%10101010
     83  7fa1				  -	      .byte	%10011001
     84  7fa1				  -
     85  7fa1				  -	      .byte	%10011001	;B (#1 wall color)
     86  7fa1				  -	      .byte	%11011101
     87  7fa1				  -	      .byte	%11111111
     88  7fa1				  -	      .byte	%01100110
     89  7fa1				  -	      .byte	%11111111
     90  7fa1				  -	      .byte	%10111011
     91  7fa1				  -	      .byte	%10011001
     92  7fa1				  -
     93  7fa1				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FLUTTERBY2", LINES_PER_CHAR
     94  7fa1				  -CHARACTERSHAPE_FLUTTERBY2
     95  7fa1				  -
     96  7fa1				  -			; an x shape (flutter)
     97  7fa1				  -
     98  7fa1				  -	      .byte	%00000000	;R
     99  7fa1				  -	      .byte	%00000000
    100  7fa1				  -	      .byte	%00000000
    101  7fa1				  -	      .byte	%00000000
    102  7fa1				  -	      .byte	%00000000
    103  7fa1				  -	      .byte	%00000000
    104  7fa1				  -	      .byte	%00100010
    105  7fa1				  -
    106  7fa1				  -	      .byte	%01100110	;G
    107  7fa1				  -	      .byte	%01100110
    108  7fa1				  -	      .byte	%01000100
    109  7fa1				  -	      .byte	%00100010
    110  7fa1				  -	      .byte	%01100110
    111  7fa1				  -	      .byte	%01100110
    112  7fa1				  -	      .byte	%01000100
    113  7fa1				  -
    114  7fa1				  -	      .byte	%01100110	;B
    115  7fa1				  -	      .byte	%01100110
    116  7fa1				  -	      .byte	%01100110
    117  7fa1				  -	      .byte	%01000100
    118  7fa1				  -	      .byte	%00100010
    119  7fa1				  -	      .byte	%01100110
    120  7fa1				  -	      .byte	%01100110
    121  7fa1					      endif
    122  7fa1
    123  7fa1					      if	BUTTERFLY_DEF = 2
      0  7fa1					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FLUTTERBY", LINES_PER_CHAR
     10  7fa1					      LIST	ON
    125  7fa1				   CHARACTERSHAPE_FLUTTERBY
    126  7fa1
    127  7fa1		       99		      .byte.b	%10011001	;R (#3 bright color)
    128  7fa2		       99		      .byte.b	%10011001
    129  7fa3		       99		      .byte.b	%10011001
    130  7fa4		       00		      .byte.b	%00000000
    131  7fa5		       99		      .byte.b	%10011001
    132  7fa6		       99		      .byte.b	%10011001
    133  7fa7		       99		      .byte.b	%10011001
    134  7fa8
    135  7fa8		       99		      .byte.b	%10011001	;G (#2 dirt color)
    136  7fa9		       ff		      .byte.b	%11111111
    137  7faa		       ff		      .byte.b	%11111111
    138  7fab		       66		      .byte.b	%01100110
    139  7fac		       66		      .byte.b	%01100110
    140  7fad		       00		      .byte.b	%00000000
    141  7fae		       00		      .byte.b	%00000000
    142  7faf
    143  7faf		       00		      .byte.b	%00000000	;B (#1 wall color)
    144  7fb0		       66		      .byte.b	%01100110
    145  7fb1		       66		      .byte.b	%01100110
    146  7fb2		       66		      .byte.b	%01100110
    147  7fb3		       ff		      .byte.b	%11111111
    148  7fb4		       99		      .byte.b	%10011001
    149  7fb5		       99		      .byte.b	%10011001
    150  7fb6
      0  7fb6					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FLUTTERBY2", LINES_PER_CHAR
     10  7fb6					      LIST	ON
    152  7fb6				   CHARACTERSHAPE_FLUTTERBY2
    153  7fb6
    154  7fb6		       66		      .byte.b	%01100110	;R
    155  7fb7		       66		      .byte.b	%01100110
    156  7fb8		       66		      .byte.b	%01100110
    157  7fb9		       00		      .byte.b	%00000000
    158  7fba		       66		      .byte.b	%01100110
    159  7fbb		       66		      .byte.b	%01100110
    160  7fbc		       66		      .byte.b	%01100110
    161  7fbd
    162  7fbd		       66		      .byte.b	%01100110	;G
    163  7fbe		       66		      .byte.b	%01100110
    164  7fbf		       66		      .byte.b	%01100110
    165  7fc0		       66		      .byte.b	%01100110
    166  7fc1		       66		      .byte.b	%01100110
    167  7fc2		       00		      .byte.b	%00000000
    168  7fc3		       00		      .byte.b	%00000000
    169  7fc4
    170  7fc4		       00		      .byte.b	%00000000	;B
    171  7fc5		       66		      .byte.b	%01100110
    172  7fc6		       66		      .byte.b	%01100110
    173  7fc7		       66		      .byte.b	%01100110
    174  7fc8		       66		      .byte.b	%01100110
    175  7fc9		       66		      .byte.b	%01100110
    176  7fca		       66		      .byte.b	%01100110
    177  7fcb					      endif
------- FILE BANK_FIXED.asm
------- FILE Steel_Wall.asm LEVEL 3 PASS 3
      0  7fcb					      include	"Steel_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      1  7fcb							;--------------------------------------------------------------------------
      0  7fcb					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
     10  7fcb					      LIST	ON
      3  7fcb				   CHARACTERSHAPE_STEEL
      4  7fcb				   CHARACTERSHAPE_EXITDOOR
      5  7fcb				  -	      if	MIRRORED_STEEL = NO
      6  7fcb				  -CHARACTERSHAPE_STEEL_MIRRORED
      7  7fcb				  -CHARACTERSHAPE_EXITDOOR_MIRRORED
      8  7fcb					      endif
      9  7fcb		       00 11 00 00*	      .byte.b	%00000000,%00010001,%00000000,%00000000,%01000100,%00000000,%00000000	;R
     10  7fd2		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;G
     11  7fd9		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;B
     12  7fe0
     13  7fe0							;--------------------------------------------------------------------------
     14  7fe0					      if	MIRRORED_STEEL = YES
      0  7fe0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
     10  7fe0					      LIST	ON
     16  7fe0				   CHARACTERSHAPE_STEEL_MIRRORED
     17  7fe0				   CHARACTERSHAPE_EXITDOOR_MIRRORED
     18  7fe0		       00 88 00 00*	      .byte.b	%00000000,%10001000,%00000000,%00000000,%00100010,%00000000,%00000000	;R
     19  7fe7		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;G
     20  7fee		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;B
     21  7ff5					      endif
------- FILE BANK_FIXED.asm
   2030  7ff5							;---------------------------------------------------------------------------
   2031  7ff5
   2032  7ff5
 FREE BYTES IN FIXED BANK =  $6
   2033  7ff5					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   2034  7ff5
   2035  7ff5							;---------------------------------------------------------------------------
   2036  7ff5							; The reset vectors
   2037  7ff5							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   2038  7ff5
   2039  8000 ????				      SEG	InterruptVectors
   2040  7ffc					      ORG	FIXED_BANK + $7FC
   2041  7ffc					      RORG	$7ffC
   2042  7ffc
   2043  7ffc							;		 .word Reset	       ; NMI	    (not used)
   2044  7ffc		       dd fc		      .word.w	Reset	; RESET
   2045  7ffe		       dd fc		      .word.w	Reset	; IRQ	      (not used)
   2046  8000
   2047  8000							;---------------------------------------------------------------------------
------- FILE ./notBoulderDash.asm
   1110  8000
   1111  8000					      END
