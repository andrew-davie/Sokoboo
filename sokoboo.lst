------- FILE ./sokoboo.asm LEVEL 1 PASS 3
      1  8000 ????						;    Sokoboo - a Sokoban implementation
      2  8000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  8000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  8000 ????						;
      5  8000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  8000 ????						;
      7  8000 ????						;    Code related to the generic tile-based display engine was developed by
      8  8000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  8000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  8000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  8000 ????						;
     12  8000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  8000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  8000 ????						;    directory for Apache licensing details.
     15  8000 ????						;
     16  8000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  8000 ????						;    See the copyright notices in the License directory for a list of level
     18  8000 ????						;    contributors.
     19  8000 ????						;
     20  8000 ????						;    Except where otherwise indicated, this software is released under the
     21  8000 ????						;    following licensing arrangement...
     22  8000 ????						;
     23  8000 ????						;    This program is free software: you can redistribute it and/or modify
     24  8000 ????						;    it under the terms of the GNU General Public License as published by
     25  8000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  8000 ????						;    (at your option) any later version.
     27  8000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  8000 ????
     29  8000 ????						;    This program is distributed in the hope that it will be useful,
     30  8000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  8000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  8000 ????						;    GNU General Public License for more details.
     33  8000 ????
     34  8000 ????
     35  8000 ????
     36  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     37  8000 ????
     38  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./sokoboo.asm
     41  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	xsegtime
     89  0000 ????			   {1}	      SET	{2}-1
     90  0000 ????			   TEST_{1}   =	1
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????
     94  0000 ????				      MAC	segtime_c
     95  0000 ????			   {1}	      SET	({2}+16)/64 + 1
     96  0000 ????			   TEST_{1}   =	0
     97  0000 ????				      ENDM
     98  0000 ????
     99  0000 ????						;@TJ -- SIMPLY PUT AN X IN FRONT OF THE LINE(S) YOU WANT TO TEST
    100  0000 ????						; eg: XSEGTIME SEGTIME_BOX1,5
    101  0000 ????						; No other action required.  All code enables/disables automatically.
    102  0000 ????
    103  0000 ????						; 2012/02/11 -- experimental reduction in times (but not stress tested)
    104  0000 ????						; due to separation of timeslice overhead to separate check
    105  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_DIRECT, 361 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	(361 + CYCLES_DRAWANOTHER+16)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_QUICK, 344 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_QUICK SET	(344 + CYCLES_DRAWANOTHER+16)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_SLOW, 676 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_SLOW SET	(676 + CYCLES_DRAWANOTHER+16)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_PF0, 88 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019 ??
      1  0000 ????			   SEGTIME_SCD_PF0 SET	(88 + CYCLES_DRAWANOTHER+16)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
    110  0000 ????
    111  0000 ????						;---------------------------------------------------------------------------------------------------
    112  0000 ????						; Pathways
    113  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
    114  0000 ????						; if QuickDraw does immediate exit, 58✅
    115  0000 ????
    116  0000 ????
    117  0000 ????	       00 03	   SEGTIME_SCD_MIN =	SEGTIME_SCD_PF0
    118  0000 ????
    119  0000 ????						;    SEGTIME_C SEGTIME_SCD_MIN, SEGTIME_SCD_PF0
    120  0000 ????						;---------------------------------------------------------------------------------------------------
    121  0000 ????
    122  0000 ????						; IF MULTI_BANK_BOARD = YES
    123  0000 ????						;    SEGTIME SEGTIME_BDF,42 +4 +5		       ; * 5/8/11 stress tested DHS->DS
    124  0000 ????						; ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BDF,39	; glitches on 37 - 10/8/2019
      1  0000 ????			   SEGTIME_BDF SET	39
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
    126  0000 ????						; ENDIF
    127  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_BDS, 83	;✅
      1  0000 ????			   SEGTIME_BDS SET	(83+16)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_DSL, 127	;✅
      1  0000 ????			   SEGTIME_DSL SET	(127+16)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SWITCHOBJECTS,46	;✅
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	(46+16)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
    131  0000 ????
    132  0000 ????						;following will lock-up system if used as 'XSEGTIME'.
      0  0000 ????				      SEGTIME_C	MINIMUM_SEGTIME, 95	;✅ processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	(95+16)/64 + 1
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+16)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    135  0000 ????
    136  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    137  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    138  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    139  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    140  0000 ????						; uses ...
    141  0000 ????
    142  0000 ????
    143  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    144  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    145  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    146  0000 ????
    147  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    148  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    149  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,10	; 10 +6 ;24 ;<< using this as XSEGTIME stops player working ...?!
      1  0000 ????			   SEGTIME_MAN SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE, 10	; drawing circle creature
      1  0000 ????			   SEGTIME_CIRCLE SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE_HELPER, 10	; drawing circle creature's helper
      1  0000 ????			   SEGTIME_CIRCLE_HELPER SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE_HELPER =	0
------- FILE ./sokoboo.asm
     43  0000 ????
     44  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     45  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     46  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     47  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     48  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     49  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     50  0000 ????
     51  0000 ????	       00 01	   YES	      =	1
     52  0000 ????	       00 00	   NO	      =	0
     53  0000 ????
     54  0000 ????	       00 00	   DEBUG      =	NO
     55  0000 ????
     56  0000 ????	       00 00	   TJ_MODE    =	NO	; some changes which TJ prefers
     57  0000 ????	       00 01	   AD_MODE    =	YES	; some changes which AD prefers
     58  0000 ????
     59  0000 ????			  -	      IF	TJ_MODE && AD_MODE
     60  0000 ????			  -	      ECHO	"ERROR: Both TJ_MODE and AD_MODE set. Can't do both TJ and AD at the same time!"
     61  0000 ????			  -	      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????
     65  0000 ????						; Note: you may also need to change the emulator "-format" switch in the Makefile.
     66  0000 ????
     67  0000 ????
     68  0000 ????						;===================================
     69  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     70  0000 ????						;===================================
     71  0000 ????
     72  0000 ????						;-------------------------------------------------------------------------------
     73  0000 ????						; The following should be YES for the final or DEMO version
     74  0000 ????			   EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
     75  0000 ????
     76  0000 ????						;-------------------------------------------------------------------------------
     77  0000 ????						; The following are optional YES/NO depending on phase of the moon
     78  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????
     81  0000 ????	       00 01	   NUMPLAYERS =	1	; 1-indexed
     82  0000 ????	       00 05	   NUM_LEVELS =	5
     83  0000 ????			   NUM_LIVES  SET	3	; use -1 for unlimited lives
     84  0000 ????
     85  0000 ????						;-------------------------------------------------------------------------------
     86  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     87  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     88  0000 ????			  -	      IF	FINAL_VERSION = YES
     89  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     90  0000 ????			  -
     91  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
     92  0000 ????				      ENDIF
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????
     96  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     97  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
     98  0000 ????
     99  0000 ????
    100  0000 ????	       00 02	   PUSH_LIMIT =	2	; slowdown when pushing on a BOX
    101  0000 ????
    102  0000 ????						; time bonus countdown constants:
    103  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
    104  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
    105  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
    106  0000 ????
    107  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    108  0000 ????
    109  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
    110  0000 ????
    111  0000 ????						;scoring flags contants:
    112  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
    113  0000 ????	       00 00	   DISPLAY_TIME =	%00
    114  0000 ????	       00 01	   DISPLAY_SCORE =	%01
    115  0000 ????	       00 02	   DISPLAY_LIVES =	%10
    116  0000 ????	       00 03	   DISPLAY_HIGH =	%11
    117  0000 ????
    118  0000 ????						;------------------------------------------------------------------------------
    119  0000 ????
    120  0000 ????	       00 01	   MIRRORED_BOX =	YES
    121  0000 ????	       00 01	   MIRRORED_STEEL =	YES
    122  0000 ????	       00 01	   MIRRORED_WALL =	YES
    123  0000 ????
    124  0000 ????	       00 00	   DIGITS     =	NO
    125  0000 ????	       00 01	   WAIT_FOR_INITIAL_DRAW =	YES	; blank until all initial tiles drawn
    126  0000 ????
    127  0000 ????						;------------------------------------------------------------------------------
    128  0000 ????
    129  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    130  0000 ????
    131  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    132  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    133  0000 ????
    134  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    135  0000 ????
    136  0000 ????
    137  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    138  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    139  0000 ????
    140  0000 ????
    141  0000 ????						; color constants:
    142  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    143  0000 ????
    144  0000 ????	       00 10	   YELLOW_NTSC =	$10
    145  0000 ????	       00 20	   YELLOW_PAL =	$20
    146  0000 ????
    147  0000 ????
    148  0000 ????	       10 00	   RAM_3E     =	$1000
    149  0000 ????	       04 00	   RAM_SIZE   =	$400
    150  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    151  0000 ????
    152  0000 ????
    153  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    154  0000 ????
    155  0000 ????
    156  0000 ????						; Platform constants:
    157  0000 ????	       00 02	   PAL	      =	%10
    158  0000 ????	       00 02	   PAL_50     =	PAL|0
    159  0000 ????	       00 03	   PAL_60     =	PAL|1
    160  0000 ????
    161  0000 ????
    162  0000 ????				      IF	L276
    163  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    164  0000 ????			  -	      ELSE
    165  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    166  0000 ????				      ENDIF
    167  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    168  0000 ????
    169  0000 ????				      IF	L276
    170  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    171  0000 ????			  -	      ELSE
    172  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    173  0000 ????				      ENDIF
    174  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    175  0000 ????
    176  0000 ????				      IF	L276
    177  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    178  0000 ????			  -	      ELSE
    179  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    180  0000 ????				      ENDIF
    181  0000 ????	       01 38	   SCANLINES_PAL =	312
    182  0000 ????
    183  0000 ????
    184  0000 ????						;------------------------------------------------------------------------------
    185  0000 ????						; MACRO definitions
    186  0000 ????
------- FILE macro2.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro2.h"
      1  0000 ????						; macros
      2  0000 ????
      3  0000 ????				      MAC	ntsc_to_pal
      4  0000 ????				      IF	{1} = 0
      5  0000 ????				      .byte	{1}+{2}
      6  0000 ????				      ENDIF
      7  0000 ????				      IF	{1} = $10
      8  0000 ????				      .byte	$22+{2}
      9  0000 ????				      ENDIF
     10  0000 ????				      IF	{1} = $20
     11  0000 ????				      .byte	$42+{2}
     12  0000 ????				      ENDIF
     13  0000 ????				      IF	{1} = $30
     14  0000 ????				      .byte	$42+{2}
     15  0000 ????				      ENDIF
     16  0000 ????				      IF	{1} = $40
     17  0000 ????				      .byte	$62+{2}
     18  0000 ????				      ENDIF
     19  0000 ????				      IF	{1} = $50
     20  0000 ????				      .byte	$82+{2}
     21  0000 ????				      ENDIF
     22  0000 ????				      IF	{1} = $60
     23  0000 ????				      .byte	$C2+{2}
     24  0000 ????				      ENDIF
     25  0000 ????				      IF	{1} = $70
     26  0000 ????				      .byte	$D2+{2}
     27  0000 ????				      ENDIF
     28  0000 ????				      IF	{1} = $80
     29  0000 ????				      .byte	$B2+{2}
     30  0000 ????				      ENDIF
     31  0000 ????				      IF	{1} = $90
     32  0000 ????				      .byte	$92+{2}
     33  0000 ????				      ENDIF
     34  0000 ????				      IF	{1} = $A0
     35  0000 ????				      .byte	$72+{2}
     36  0000 ????				      ENDIF
     37  0000 ????				      IF	{1} = $B0
     38  0000 ????				      .byte	$52+{2}
     39  0000 ????				      ENDIF
     40  0000 ????				      IF	{1} = $C0
     41  0000 ????				      .byte	$32+{2}
     42  0000 ????				      ENDIF
     43  0000 ????				      IF	{1} = $D0
     44  0000 ????				      .byte	$32+{2}
     45  0000 ????				      ENDIF
     46  0000 ????				      IF	{1} = $E0
     47  0000 ????				      .byte	$22+{2}
     48  0000 ????				      ENDIF
     49  0000 ????				      IF	{1} = $F0
     50  0000 ????				      .byte	$42+{2}
     51  0000 ????				      ENDIF
     52  0000 ????				      ENDM		; {col} {intensity}
------- FILE ./sokoboo.asm
    188  0000 ????
    189  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    190  0000 ????
    191  0000 ????				      MAC	newbank
    192  0000 ????				      SEG	{1}
    193  0000 ????				      ORG	ORIGIN
    194  0000 ????				      RORG	$F000
    195  0000 ????			   BANK_START SET	*
    196  0000 ????			   {1}	      SET	ORIGIN / 2048
    197  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    198  0000 ????			   _CURRENT_BANK SET	{1}
    199  0000 ????				      ENDM		; bank name
    200  0000 ????
    201  0000 ????				      MAC	define_1k_segment
    202  0000 ????				      ALIGN	$400
    203  0000 ????			   SEGMENT_{1} SET	*
    204  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    205  0000 ????				      ENDM		; {seg name}
    206  0000 ????
    207  0000 ????				      MAC	check_bank_size
    208  0000 ????			   .TEMP      =	* - BANK_START
    209  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    210  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    211  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    212  0000 ????				      ERR
    213  0000 ????				      endif
    214  0000 ????				      ENDM		; name
    215  0000 ????
    216  0000 ????
    217  0000 ????				      MAC	check_half_bank_size
    218  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    219  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    220  0000 ????			   .TEMP      =	* - BANK_START
    221  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    222  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    223  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    224  0000 ????				      ERR
    225  0000 ????				      endif
    226  0000 ????				      ENDM		; name
    227  0000 ????
    228  0000 ????
    229  0000 ????				      MAC	overlay
    230  0000 ????				      SEG.U	OVERLAY_{1}
    231  0000 ????				      org	Overlay
    232  0000 ????				      ENDM		; {name}
    233  0000 ????
    234  0000 ????						;--------------------------------------------------------------------------
    235  0000 ????
    236  0000 ????				      MAC	validate_overlay
    237  0000 ????				      LIST	OFF
    238  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    239  0000 ????				      ERR
    240  0000 ????				      endif
    241  0000 ????				      LIST	ON
    242  0000 ????				      ENDM
    243  0000 ????
    244  0000 ????						;--------------------------------------------------------------------------
    245  0000 ????						; Macro inserts a page break if the object would overlap a page
    246  0000 ????
    247  0000 ????				      MAC	optional_pagebreak
    248  0000 ????				      LIST	OFF
    249  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    250  0000 ????			   EARLY_LOCATION SET	*
    251  0000 ????				      ALIGN	256
    252  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    253  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    254  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    255  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    256  0000 ????				      ENDIF
    257  0000 ????				      LIST	ON
    258  0000 ????				      ENDM		; { string, size }
    259  0000 ????
    260  0000 ????
    261  0000 ????				      MAC	check_page_crossing
    262  0000 ????				      LIST	OFF
    263  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    264  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    265  0000 ????				      endif
    266  0000 ????				      LIST	ON
    267  0000 ????				      ENDM
    268  0000 ????
    269  0000 ????				      MAC	checkpage
    270  0000 ????				      LIST	OFF
    271  0000 ????				      IF	>. != >{1}
    272  0000 ????				      ECHO	""
    273  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    274  0000 ????				      ECHO	""
    275  0000 ????				      ERR
    276  0000 ????				      ENDIF
    277  0000 ????				      LIST	ON
    278  0000 ????				      ENDM
    279  0000 ????
    280  0000 ????				      MAC	checkpagex
    281  0000 ????				      LIST	OFF
    282  0000 ????				      IF	>. != >{1}
    283  0000 ????				      ECHO	""
    284  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    285  0000 ????				      ECHO	{2}
    286  0000 ????				      ECHO	""
    287  0000 ????				      ERR
    288  0000 ????				      ENDIF
    289  0000 ????				      LIST	ON
    290  0000 ????				      ENDM
    291  0000 ????
    292  0000 ????
    293  0000 ????				      MAC	checkpage_bne
    294  0000 ????				      LIST	OFF
    295  0000 ????				      IF	0	;>(. + 2) != >{1}
    296  0000 ????				      ECHO	""
    297  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    298  0000 ????				      ECHO	""
    299  0000 ????				      ERR
    300  0000 ????				      ENDIF
    301  0000 ????				      LIST	ON
    302  0000 ????				      bne	{1}
    303  0000 ????				      ENDM
    304  0000 ????
    305  0000 ????				      MAC	checkpage_bpl
    306  0000 ????				      LIST	OFF
    307  0000 ????				      IF	(>(.+2 )) != >{1}
    308  0000 ????				      ECHO	""
    309  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    310  0000 ????				      ECHO	""
    311  0000 ????				      ERR
    312  0000 ????				      ENDIF
    313  0000 ????				      LIST	ON
    314  0000 ????				      bpl	{1}
    315  0000 ????				      ENDM
    316  0000 ????
    317  0000 ????				      MAC	align_free
    318  0000 ????			   FREE       SET	FREE - .
    319  0000 ????				      align	{1}
    320  0000 ????			   FREE       SET	FREE + .
    321  0000 ????				      echo	"@", ., ":", FREE
    322  0000 ????				      ENDM
    323  0000 ????
    324  0000 ????
    325  0000 ????			   IDENTITY   SET	0
    326  0000 ????				      MAC	ident
    327  0000 ????				      if	DEBUG=YES
    328  0000 ????				      lda	#IDENTITY
    329  0000 ????				      sta	debug_ident
    330  0000 ????				      lda	{1}
    331  0000 ????				      sta	debug_object
    332  0000 ????				      endif
    333  0000 ????			   IDENTITY   SET	IDENTITY + 1
    334  0000 ????				      ENDM		; {object}
    335  0000 ????
    336  0000 ????						;--------------------------------------------------------------------------
    337  0000 ????
    338  0000 ????				      MAC	vector
    339  0000 ????				      .word	{1}
    340  0000 ????				      ENDM		; just a word pointer to code
    341  0000 ????
    342  0000 ????
    343  0000 ????				      MAC	define_subroutine
    344  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    345  0000 ????				      SUBROUTINE		; keep everything local
    346  0000 ????			   {1}			; entry point
    347  0000 ????				      ENDM		; name of subroutine
    348  0000 ????
    349  0000 ????
    350  0000 ????
    351  0000 ????						;--------------------------------------------------------------------------
    352  0000 ????
    353  0000 ????				      MAC	newrambank
    354  0000 ????				      SEG.U	{1}
    355  0000 ????				      ORG	ORIGIN
    356  0000 ????				      RORG	RAM_3E
    357  0000 ????			   BANK_START SET	*
    358  0000 ????			   {1}	      SET	ORIGIN / RAM_SIZE
    359  0000 ????			   ORIGIN     SET	ORIGIN + RAM_SIZE
    360  0000 ????				      ENDM		; bank name
    361  0000 ????
    362  0000 ????				      MAC	validate_ram_size
    363  0000 ????				      if	* - RAM_3E > RAM_SIZE
    364  0000 ????				      ERR
    365  0000 ????				      endif
    366  0000 ????				      ENDM
    367  0000 ????
    368  0000 ????				      MAC	next_random
    369  0000 ????						; update random value:
    370  0000 ????				      lda	rnd	; 3
    371  0000 ????				      lsr		; 2
    372  0000 ????				      IFCONST	rndHi
    373  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    374  0000 ????				      ENDIF
    375  0000 ????				      bcc	.skipEOR	; 2/3
    376  0000 ????				      eor	#RND_EOR_VAL	; 2
    377  0000 ????			   .skipEOR
    378  0000 ????				      sta	rnd	; 3 = 14/19
    379  0000 ????				      ENDM
    380  0000 ????
    381  0000 ????				      MAC	resync
    382  0000 ????						; resync screen, X and Y == 0 afterwards
    383  0000 ????				      lda	#%10	; make sure VBLANK is ON
    384  0000 ????				      sta	VBLANK
    385  0000 ????
    386  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    387  0000 ????			   .loopResync
    388  0000 ????				      VERTICAL_SYNC
    389  0000 ????
    390  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    391  0000 ????				      lda	Platform
    392  0000 ????				      eor	#PAL_50	; PAL-50?
    393  0000 ????				      bne	.ntsc
    394  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    395  0000 ????			   .ntsc
    396  0000 ????			   .loopWait
    397  0000 ????				      sta	WSYNC
    398  0000 ????				      sta	WSYNC
    399  0000 ????				      dey
    400  0000 ????				      bne	.loopWait
    401  0000 ????				      dex
    402  0000 ????				      bne	.loopResync
    403  0000 ????				      ENDM
    404  0000 ????
    405  0000 ????				      MAC	set_platform
    406  0000 ????						; 00 = NTSC
    407  0000 ????						; 01 = NTSC
    408  0000 ????						; 10 = PAL-50
    409  0000 ????						; 11 = PAL-60
    410  0000 ????				      lda	SWCHB
    411  0000 ????				      rol
    412  0000 ????				      rol
    413  0000 ????				      rol
    414  0000 ????				      and	#%11
    415  0000 ????				      eor	#PAL
    416  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    417  0000 ????				      ENDM
    418  0000 ????
    419  0000 ????						;  IF TJ_MODE
    420  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM ; = 29
    421  0000 ????						;	  ldy #{1}			  ; 2	  read bank
    422  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    423  0000 ????						;	  jsr GetRAMByteFromRAM 	  ;25
    424  0000 ????						;    ENDM
    425  0000 ????						;
    426  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM ; = 30
    427  0000 ????						;	  ldy #{1}			  ; 2	  write bank
    428  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    429  0000 ????						;	  jsr PutRAMByteFromRAM 	  ;26
    430  0000 ????						;    ENDM
    431  0000 ????						;
    432  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM_ADR ; = 39
    433  0000 ????						;	  ldx #<{1}			  ; 2
    434  0000 ????						;	  stx addressR			  ; 3
    435  0000 ????						;	  ldx #>{1}			  ; 2
    436  0000 ????						;	  stx addressR+1		  ; 3
    437  0000 ????						;	  GET_RAM_BYTE_FROM_RAM {2}, {3}  ;29
    438  0000 ????						;    ENDM
    439  0000 ????						;
    440  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM_ADR ; = 40
    441  0000 ????						;	  ldx #<{1}			  ; 2
    442  0000 ????						;	  stx addressW			  ; 3
    443  0000 ????						;	  ldx #>({1}+RAM_WRITE) 	  ; 2
    444  0000 ????						;	  stx addressW+1		  ; 3
    445  0000 ????						;	  PUT_RAM_BYTE_FROM_RAM {2}, {3}  ;30
    446  0000 ????						;    ENDM
    447  0000 ????						;  ENDIF
    448  0000 ????
    449  0000 ????				      MAC	nop_b
    450  0000 ????				      .byte	$82
    451  0000 ????				      ENDM		; unused
    452  0000 ????
    453  0000 ????				      MAC	nop_w
    454  0000 ????				      .byte	$0c
    455  0000 ????				      ENDM
    456  0000 ????
    457  0000 ????				      MAC	load_animation
    458  0000 ????				      lda	#<{1}
    459  0000 ????				      sta	animation
    460  0000 ????				      lda	#>{1}
    461  0000 ????				      sta	animation+1
    462  0000 ????				      lda	#0
    463  0000 ????				      sta	animation_delay
    464  0000 ????				      ENDM
    465  0000 ????
    466  0000 ????
    467  0000 ????						;------------------------------------------------------------------------------
    468  0000 ????
    469  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34 U00fc ????				      SEG.U	variables
     35 U0080					      ORG	$80
     36 U0080
     37 U0080
     38 U0080		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     39 U0081
     40 U0081		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     41 U0082		       00	   ObjStackNum ds	1	; which stack in use
     42 U0083		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     43 U0085		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     44 U0086		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     45 U0087
     46 U0087		       00	   POS_X      ds	1
     47 U0088		       00	   POS_Y      ds	1
     48 U0089		       00	   POS_X_NEW  ds	1
     49 U008a		       00	   POS_Y_NEW  ds	1
     50 U008b		       00	   POS_Type   ds	1
     51 U008c		       00	   POS_VAR    ds	1
     52 U008d
     53 U008d		       00	   TB_X       ds	1
     54 U008e		       00	   TB_Y       ds	1
     55 U008f		       00	   TB_PUSHX   ds	1
     56 U0090		       00	   TB_PUSHY   ds	1
     57 U0091		       00	   TB_CHAR    ds	1
     58 U0092
     59 U0092		       00 00	   BufferedJoystick ds	2	; player joystick input
     60 U0094		       00 00	   BufferedButton ds	2	; player button press
     61 U0096
     62 U0096							; Scrolling is limited to only show board within the following area...
     63 U0096		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in UnpackLevel)
     64 U0097		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in UnpackLevel)
     65 U0098		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     66 U0099		       00	   BoardScrollX ds	1	; scroll position in board (X)
     67 U0099		       00 96	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     68 U0099		       00 97	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     69 U009a		       00	   scrollBits ds	1
     70 U009b
     71 U009b		       00	   animation_index ds	1	; new
     72 U009c		       00 00	   animation  ds	2
     73 U009e		       00	   animation_delay ds	1
     74 U009f		       00	   ManX       ds	1
     75 U00a0		       00	   ManY       ds	1
     76 U00a1		       00	   ManDrawX   ds	1
     77 U00a2		       00	   ManDrawY   ds	1
     78 U00a3		       00	   ManMode    ds	1
     79 U00a4		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     80 U00a5		       00	   ManTurnStart ds	1
     81 U00a6		       00	   ManPushCounter ds	1
     82 U00a7		       00	   LookingAround ds	1
     83 U00a8		       00	   ManAnimationID ds	1
     84 U00a9		       00	   DelayEndOfLevel ds	1
     85 U00aa		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     86 U00ab
     87 U00ab				  -	      if	0
     88 U00ab				  -circ_x     ds	1
     89 U00ab				  -circ_y     ds	1
     90 U00ab				  -circ_char  ds	1
     91 U00ab				  -circ_scratch ds	1
     92 U00ab					      endif
     93 U00ab		       00	   LEVEL_bank ds	1
     94 U00ac		       00 00	   levelPtr   ds	2
     95 U00ae
     96 U00ae					      IF	WAIT_FOR_INITIAL_DRAW
     97 U00ae		       00	   blankState ds	1
     98 U00af					      ENDIF
     99 U00af
    100 U00af							;---------------------------------------------------------------------------
    101 U00af							; 2 (shared) demo mode variables:
    102 U00af		       00 aa	   demoMode   =	jtoggle	; bit 7==1 => demo mode
    103 U00af		       00 aa	   moveLen    =	jtoggle	; bits 0..6
    104 U00af		       00	   moveIdx    ds	1
    105 U00b0
    106 U00b0		       00	   LastSpriteY ds	1
    107 U00b1
    108 U00b1		       00	   timer      ds	1
    109 U00b2
    110 U00b2		       00	   BGColour   ds	1
    111 U00b3
    112 U00b3							; levelx and level have to be consecutive variables!
    113 U00b3		       00	   levelX     ds	1	; current player's level (other in scoring bank)
    114 U00b4		       00	   level      ds	1	; current player's level (other in scoring bank)
    115 U00b5							;levelDisplay			   ds 1 	   ; what to display as the level ID
    116 U00b5		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
    117 U00b6		       00	   ThrottleSpeed ds	1	; system-dependant throttle speed
    118 U00b7
    119 U00b7		       00	   BCD_targetsRequired ds	1	; number of un-targeted left to go
    120 U00b8		       00	   BCD_moveCounter ds	1	; BCD seconds for level
    121 U00b9		       00	   BCD_moveCounterHi ds	1
    122 U00ba
    123 U00ba		       00	   takebackIndex ds	1
    124 U00bb		       00	   takebackBaseIndex ds	1
    125 U00bc		       00	   TakebackInhibit ds	1
    126 U00bd
    127 U00bd		       00 00 00    color      ds	3	; RGB for NTSC, RGB for PAL
    128 U00c0		       00 00	   Board_AddressR ds	2
    129 U00c2		       00 00	   Board_AddressW ds	2
    130 U00c4		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
    131 U00c5		       00	   RAM_Bank   ds	1
    132 U00c6
    133 U00c6		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
    134 U00c7		       00	   ColourFlash ds	1	; colour of flash
    135 U00c8		       00	   extraLifeTimer ds	1	; should be 5 seconds!
    136 U00c9
    137 U00c9							; extraLifeTimer:
    138 U00c9							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    139 U00c9
    140 U00c9		       00	   scoringTimer ds	1	; times the various score displays
    141 U00ca		       00	   scoringFlags ds	1	; scoring flags are stored here
    142 U00cb
    143 U00cb							; scoringFlags:
    144 U00cb							; D7		 Extra TARGETs in effect (TARGETs collected over requirement score more) ASSUMED BPL/BMI usage
    145 U00cb							; D6		 unused
    146 U00cb							; D5		 unused
    147 U00cb							; D4		 unused
    148 U00cb							; D3		 unused
    149 U00cb							; D2		 unused
    150 U00cb							; D1	 D1-D0	 Which display kernel to use for scoring
    151 U00cb							; D0		 0 = 2x4     used for TARGETs/time
    152 U00cb							;		 1 = 1x6     used for score
    153 U00cb							;		 2 = 3x2     used for level/lives/player
    154 U00cb
    155 U00cb		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    156 U00cb		       00 80	   BIT_NEXTLEVEL =	128
    157 U00cb		       00 40	   BIT_NEXTLIFE =	64
    158 U00cc
    159 U00cc							;------------------------------------------------------------------------------
    160 U00cc
    161 U00cc		       00	   ObjIterator ds	1	; count UP iterator over objects
    162 U00cd		       00	   DSL	      ds	1	; stack line counter
    163 U00ce
    164 U00ce		       00	   ethnic     ds	1
    165 U00cf		       00	   animate_char_index ds	1
    166 U00d0
    167 U00d0
    168 U00d0
------- FILE sound/intro1_variables.asm LEVEL 3 PASS 3
      0 U00d0					      include	"sound/intro1_variables.asm"
      1 U00d0							; TIATracker music player
      2 U00d0							; Copyright 2016 Andre "Kylearan" Wichmann
      3 U00d0							; Website: https://bitbucket.org/kylearan/tiatracker
      4 U00d0							; Email: andre.wichmann@gmx.de
      5 U00d0							;
      6 U00d0							; Licensed under the Apache License, Version 2.0 (the "License");
      7 U00d0							; you may not use this file except in compliance with the License.
      8 U00d0							; You may obtain a copy of the License at
      9 U00d0							;
     10 U00d0							;   http://www.apache.org/licenses/LICENSE-2.0
     11 U00d0							;
     12 U00d0							; Unless required by applicable law or agreed to in writing, software
     13 U00d0							; distributed under the License is distributed on an "AS IS" BASIS,
     14 U00d0							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15 U00d0							; See the License for the specific language governing permissions and
     16 U00d0							; limitations under the License.
     17 U00d0
     18 U00d0							; Song author: 
     19 U00d0							; Song name: 
     20 U00d0
     21 U00d0							; @com.wudsn.ide.asm.hardware=ATARI2600
     22 U00d0
     23 U00d0							; =====================================================================
     24 U00d0							; Flags
     25 U00d0							; =====================================================================
     26 U00d0
     27 U00d0							; 1: Global song speed, 0: Each pattern has individual speed
     28 U00d0		       00 01	   TT_GLOBAL_SPEED =	1
     29 U00d0							; duration (number of TV frames) of a note
     30 U00d0		       00 05	   TT_SPEED   =	5
     31 U00d0							; duration of odd frames (needs TT_USE_FUNKTEMPO)
     32 U00d0		       00 04	   TT_ODD_SPEED =	4
     33 U00d0
     34 U00d0							; 1: Overlay percussion, +40 bytes
     35 U00d0		       00 01	   TT_USE_OVERLAY =	1
     36 U00d0							; 1: Melodic instrument slide, +9 bytes
     37 U00d0		       00 00	   TT_USE_SLIDE =	0
     38 U00d0							; 1: Goto pattern, +8 bytes
     39 U00d0		       00 01	   TT_USE_GOTO =	1
     40 U00d0							; 1: Odd/even rows have different SPEED values, +7 bytes
     41 U00d0		       00 01	   TT_USE_FUNKTEMPO =	1
     42 U00d0							; If the very first notes played on each channel are not PAUSE, HOLD or
     43 U00d0							; SLIDE, i.e. if they start with an instrument or percussion, then set
     44 U00d0							; this flag to 0 to save 2 bytes.
     45 U00d0							; 0: +2 bytes
     46 U00d0		       00 01	   TT_STARTS_WITH_NOTES =	1
     47 U00d0
     48 U00d0
     49 U00d0							; =====================================================================
     50 U00d0							; Permanent variables. These are states needed by the player.
     51 U00d0							; =====================================================================
     52 U00d0		       00	   tt_timer   ds	1	; current music timer value
     53 U00d1		       00	   tt_cur_pat_index_c0 ds	1	; current pattern index into tt_SequenceTable
     54 U00d2		       00	   tt_cur_pat_index_c1 ds	1
     55 U00d3		       00	   tt_cur_note_index_c0 ds	1	; note index into current pattern
     56 U00d4		       00	   tt_cur_note_index_c1 ds	1
     57 U00d5		       00	   tt_envelope_index_c0 ds	1	; index into ADSR envelope
     58 U00d6		       00	   tt_envelope_index_c1 ds	1
     59 U00d7		       00	   tt_cur_ins_c0 ds	1	; current instrument
     60 U00d8		       00	   tt_cur_ins_c1 ds	1
     61 U00d9
     62 U00d9
     63 U00d9							; =====================================================================
     64 U00d9							; Temporary variables. These will be overwritten during a call to the
     65 U00d9							; player routine, but can be used between calls for other things.
     66 U00d9							; =====================================================================
     67 U00d9		       00 00	   tt_ptr     ds	2
------- FILE zeropage.asm
    170 U00db
    171 U00db
    172 U00db
    173 U00db				   OVERLAY_SIZE SET	21
    174 U00db
    175 U00db
    176 U00db
    177 U00db							; This overlay variable is used for the overlay variables.  That's OK.
    178 U00db							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    179 U00db							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    180 U00db							; (especially the latter ones) are only used in rare occasions.
    181 U00db
    182 U00db							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    183 U00db							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    184 U00db
    185 U00db		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00f0					      VALIDATE_OVERLAY
      5 U00f0					      LIST	ON
    187 U00f0
    188 U00f0
    189 U00f0		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    190 U00fc
 FREE BYTES IN ZERO PAGE =  $3
    191 U00fc					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    192 U00fc				  -	      IF	* > $FF
    193 U00fc				  -	      ERR
    194 U00fc					      ENDIF
------- FILE ./sokoboo.asm
    471 U00fc
    472 U00fc
    473 U00fc							;------------------------------------------------------------------------------
    474 U00fc							; OVERLAYS!
    475 U00fc							; These variables are overlays, and should be managed with care
    476 U00fc							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    477 U00fc
    478 U00fc							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    479 U00fc							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    480 U00fc
    481 U00fc							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    482 U00fc
    483 U00fc
    484 U00fc
    485 U00fc							;------------------------------------------------------------------------------
      0 U00fc					      OVERLAY	BuildDrawFlags
      1 U00e6 ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00db					      org	Overlay
    487 U00db
    488 U00db		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    489 U00dd		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    490 U00df		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    491 U00e1		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    492 U00e3							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    493 U00e3		       00	   BDF_BoardBank ds	1	; holds bank of current line
    494 U00e4							;  ENDIF
    495 U00e4		       00	   DHS_Line   ds	1
    496 U00e5		       00	   DHS_Stack  ds	1	; for restoring SP
    497 U00e6							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e6					      VALIDATE_OVERLAY
      5 U00e6					      LIST	ON
    499 U00e6
    500 U00e6							;------------------------------------------------------------------------------
    501 U00e6
      0 U00e6					      OVERLAY	Animator
      1 U00e1 ????				      SEG.U	OVERLAY_Animator
      2 U00db					      org	Overlay
    503 U00db		       00 00	   frame_ptr  ds	2
    504 U00dd		       00 00	   colour_ptr ds	2
    505 U00df		       00	   bank       ds	1
    506 U00e0		       00	   ethnicity  ds	1
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    508 U00e1
    509 U00e1
      0 U00e1					      OVERLAY	Process
      1 U00de ????				      SEG.U	OVERLAY_Process
      2 U00db					      org	Overlay
    511 U00db
    512 U00db		       00	   BOXLeft    ds	1
    513 U00dc		       00	   BOXRight   ds	1
    514 U00dd		       00	   restorationCharacter ds	1
    515 U00de
      0 U00de					      VALIDATE_OVERLAY
      5 U00de					      LIST	ON
    517 U00de
    518 U00de							;------------------------------------------------------------------------------
    519 U00de
    520 U00de
      0 U00de					      OVERLAY	Animate
      1 U00dc ????				      SEG.U	OVERLAY_Animate
      2 U00db					      org	Overlay
    522 U00db		       00	   halftimer  ds	1
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    524 U00dc
    525 U00dc							;------------------------------------------------------------------------------
    526 U00dc
      0 U00dc					      OVERLAY	TitleScreen
      1 U00f0 ????				      SEG.U	OVERLAY_TitleScreen
      2 U00db					      org	Overlay
    528 U00db		       00 00	   colour_table ds	2
    529 U00dd		       00 00	   digit1     ds	2
    530 U00df		       00 00 00    digit2     ds	3
    531 U00e2		       00 00	   digitstar  ds	2
    532 U00e4		       00 00 00    digit      ds	3
    533 U00e7		       00	   digitick   ds	1
    534 U00e8		       00 00 00    targetDigit ds	3
    535 U00eb		       00	   initialdelay ds	1
    536 U00ec		       00	   endwait    ds	1
    537 U00ed		       00	   colourindex ds	1
    538 U00ee		       00 00	   digitHundreds ds	2
      0 U00f0					      VALIDATE_OVERLAY
      5 U00f0					      LIST	ON
    540 U00f0
    541 U00f0							;------------------------------------------------------------------------------
    542 U00f0
      0 U00f0					      OVERLAY	TimeSlice
      1 U00dd ????				      SEG.U	OVERLAY_TimeSlice
      2 U00db					      org	Overlay
    544 U00db
    545 U00db		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    546 U00dd							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    548 U00dd
    549 U00dd							;------------------------------------------------------------------------------
    550 U00dd
      0 U00dd					      OVERLAY	CopyROMShadowToRAM
      1 U00de ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00db					      org	Overlay
    552 U00db
    553 U00db		       00	   O_CopyCount ds	1
    554 U00dc		       00	   O_ROM_Source_Bank ds	1
    555 U00dd		       00	   O_Index    ds	1
    556 U00de							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00de					      VALIDATE_OVERLAY
      5 U00de					      LIST	ON
    558 U00de
    559 U00de							;------------------------------------------------------------------------------
    560 U00de
      0 U00de					      OVERLAY	Scoring
      1 U00dc ????				      SEG.U	OVERLAY_Scoring
      2 U00db					      org	Overlay
    562 U00db		       00	   tmpStack   ds	1
    563 U00db		       00 db	   newDisplay =	tmpStack
    564 U00dc							; also for UpdateTimer
    565 U00dc		       00 db	   tmpSound   =	tmpStack
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    567 U00dc
    568 U00dc
    569 U00dc							;------------------------------------------------------------------------------
    570 U00dc
      0 U00dc					      OVERLAY	SaveKey
      1 U00e4 ????				      SEG.U	OVERLAY_SaveKey
      2 U00db					      org	Overlay
    572 U00db
    573 U00db		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    574 U00de		       00 00 00    highScoreSK ds	3
    575 U00e1		       00	   startingLevel ds	1	; levelx * 5
    576 U00e2		       00	   startLevel ds	1
    577 U00e3		       00	   offsetSK   ds	1	; for calculating the SK slot address
    578 U00e4
      0 U00e4					      VALIDATE_OVERLAY
      5 U00e4					      LIST	ON
    580 U00e4
    581 U00e4							;------------------------------------------------------------------------------
    582 U00e4
      0 U00e4					      OVERLAY	DrawMan
      1 U00dd ????				      SEG.U	OVERLAY_DrawMan
      2 U00db					      org	Overlay
    584 U00db
    585 U00db		       00 00	   MAN_Move   ds	2
    586 U00dd
    587 U00dd							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    589 U00dd
    590 U00dd							;------------------------------------------------------------------------------
    591 U00dd
      0 U00dd					      OVERLAY	ProcessObjStack
      1 U00dd ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00db					      org	Overlay
    593 U00db
    594 U00db		       00 00	   POS_Vector ds	2
    595 U00dd
    596 U00dd							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    598 U00dd
    599 U00dd							;------------------------------------------------------------------------------
    600 U00dd
      0 U00dd					      OVERLAY	ScoreLineOverlay
      1 U00ea ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00db					      org	Overlay
    602 U00db
    603 U00db		       00 00	   S0	      ds	2	; used for addressing digits of score
    604 U00dd		       00 00	   S1	      ds	2
    605 U00df		       00 00	   S2	      ds	2
    606 U00e1		       00 00	   S3	      ds	2
    607 U00e3		       00 00	   S4	      ds	2
    608 U00e5		       00 00	   S5	      ds	2
    609 U00e7
    610 U00e7		       00	   stkp       ds	1
    611 U00e8		       00	   sreg       ds	1
    612 U00e9		       00	   loop       ds	1
    613 U00ea
    614 U00ea							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00ea					      VALIDATE_OVERLAY
      5 U00ea					      LIST	ON
    616 U00ea
    617 U00ea							;------------------------------------------------------------------------------
    618 U00ea
    619 U00ea
      0 U00ea					      OVERLAY	UnpackLevelOverlay
      1 U00e0 ????				      SEG.U	OVERLAY_UnpackLevelOverlay
      2 U00db					      org	Overlay
    621 U00db
    622 U00db		       00	   base_x     ds	1
    623 U00dc		       00	   base_y     ds	1
    624 U00dd		       00	   upk_length ds	1
    625 U00de		       00	   upk_column ds	1
    626 U00df		       00	   upk_temp   ds	1
    627 U00e0
    628 U00e0							;ECHO "FREE BYTES IN UnpackLevelOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    630 U00e0
    631 U00e0							;------------------------------------------------------------------------------
    632 U00e0
      0 U00e0					      OVERLAY	ManProcessing
      1 U00dd ????				      SEG.U	OVERLAY_ManProcessing
      2 U00db					      org	Overlay
    634 U00db		       00 00	   actionVector ds	2
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    636 U00dd
      0 U00dd					      OVERLAY	SetPlatformColours
      1 U00dc ????				      SEG.U	OVERLAY_SetPlatformColours
      2 U00db					      org	Overlay
    638 U00db		       00	   colorIdx   ds	1
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    640 U00dc
      0 U00dc					      OVERLAY	DrawIntoStack
      1 U00dc ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00db					      org	Overlay
    642 U00db		       00	   save_SP    ds	1
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    644 U00dc
    645 U00dc							;------------------------------------------------------------------------------
    646 U00dc							;##############################################################################
    647 U00dc							;------------------------------------------------------------------------------
    648 U00dc
    649 U00dc							; NOW THE VERY INTERESTING '3E' RAM BANKS
    650 U00dc							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    651 U00dc
    652 U00dc				   ORIGIN     SET	0
      0 U00dc					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN / RAM_SIZE
      6 U0000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    654 U0000
    655 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    656 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    657 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    658 U0000
    659 U0000		       00 60	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    660 U0000
    661 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    662 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    663 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    664 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    665 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    666 U0000
    667 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    668 U0000							; is that we can use that code to switch between banks, and the system will happily
    669 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    670 U0000
    671 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    672 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    673 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    674 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    675 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    676 U0000
    677 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    678 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    679 U0000							; part of the draw routine *every* scanline (though the system currently uses
    680 U0000							; one colour shared between both players).
    681 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    683 U0000
    684 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    685 U0000							; accessed via the above labels but with the appropriate bank switched in.
    686 U0000
    687 U0000							;------------------------------------------------------------------------------
    688 U0000
    689 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    689 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    689 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    689 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1000				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    689 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    689 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    689 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    692 U1c00					      REPEND
    693 U1c00
    694 U1c00							;------------------------------------------------------------------------------
    695 U1c00							;##############################################################################
    696 U1c00							;------------------------------------------------------------------------------
    697 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN / RAM_SIZE
      6 U2000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    699 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    700 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    702 U2000
    703 U2000							;------------------------------------------------------------------------------
    704 U2000							;##############################################################################
    705 U2000							;------------------------------------------------------------------------------
    706 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN / RAM_SIZE
      6 U2400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    708 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    709 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    711 U2400
    712 U2400							;------------------------------------------------------------------------------
    713 U2400							;##############################################################################
    714 U2400							;------------------------------------------------------------------------------
    715 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_LEVEL
      1 U2800 ????				      SEG.U	BANK_DECODE_LEVEL
      2 U2800					      ORG	ORIGIN
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_LEVEL SET	ORIGIN / RAM_SIZE
      6 U2800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    717 U2800							; VARS DEFINED IN BANK_DECODE_LEVEL_SHADOW
    718 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    720 U2800
    721 U2800							;------------------------------------------------------------------------------
    722 U2800							;##############################################################################
    723 U2800							;------------------------------------------------------------------------------
    724 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN / RAM_SIZE
      6 U2c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
    726 U2c00
    727 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    728 U2c00							; position of something that needs to be processed.  These things include anything
    729 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    730 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    731 U2c00							; one for the next processing iteration.
    732 U2c00
    733 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    734 U2c00
    735 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    736 U2c00
    737 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    738 U2c00
    739 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    740 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    741 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    742 U2d80
    743 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    744 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    745 U2e00
    746 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    747 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    748 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    749 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    751 U2e80
    752 U2e80							;------------------------------------------------------------------------------
    753 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN / RAM_SIZE
      6 U3000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    755 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    757 U3000
    758 U3000							;------------------------------------------------------------------------------
    759 U3000							;##############################################################################
    760 U3000							;------------------------------------------------------------------------------
    761 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U35f0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN / RAM_SIZE
      6 U3400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    763 U3400
    764 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    765 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    766 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    767 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    768 U3400							; when accessing.
    769 U3400
    770 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    771 U3400							; automatically based on the sizes set in these constants. The board may overlay
    772 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    773 U3400							; we're doing OK.
    774 U3400
    775 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    776 U3400
    777 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    778 U3400
    779 U3400		       00 18	   SIZE_BOARD_X =	24	;
    780 U3400		       00 14	   SIZE_BOARD_Y =	20	;22
    781 U3400				  -	      if	0
    782 U3400				  -			; have to precalculate it here, else DASM freaks out:
    783 U3400				  -.BOARD_SIZE SET	0
    784 U3400				  -.BOARD_LOCATION SET	0
    785 U3400				  -	      REPEAT	SIZE_BOARD_Y
    786 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    787 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    788 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    789 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    790 U3400				  -	      ENDIF
    791 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    792 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    793 U3400				  -	      REPEND
    794 U3400				  -
    795 U3400				  -SIZE_BOARD =	.BOARD_SIZE
    796 U3400					      endif
    797 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    798 U3400				  -MULTI_BANK_BOARD =	YES
    799 U3400					      ELSE
    800 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    801 U3400					      ENDIF
    802 U3400
    803 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    804 U35f0							; 1024 byte chunks, switching RAM
    805 U35f0							; banks as we go.  In other words,
    806 U35f0							; this overlaps multiple banks!
    807 U35f0
      0 U35f0					      NEWRAMBANK	BANK_TAKEBACK
      1 U3940 ????				      SEG.U	BANK_TAKEBACK
      2 U3800					      ORG	ORIGIN
      3 U3800					      RORG	RAM_3E
      4 U3800				   BANK_START SET	*
      5 U3800				   BANK_TAKEBACK SET	ORIGIN / RAM_SIZE
      6 U3800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    809 U3800
    810 U3800		       00 3f	   TAKEBACK_MASK =	$3F
    811 U3800
    812 U3800		       00 00 00 00*TakeBackPreviousX ds	$40
    813 U3840		       00 00 00 00*TakeBackPreviousY ds	$40
    814 U3880		       00 00 00 00*TakeBackPushX ds	$40
    815 U38c0		       00 00 00 00*TakeBackPushY ds	$40
    816 U3900		       00 00 00 00*TakeBackPushChar ds	$40
    817 U3940
    818 U3940							; reverting...
    819 U3940							; A prevoius position
    820 U3940							;	     POS_VAR = board
    821 U3940							;	     board = MANOCCUPIED
    822 U3940							;	     manx,y = x,y
    823 U3940							; B current position (MANX,Y)
    824 U3940							;	     board = POS_VAR
    825 U3940							; C push position
    826 U3940							;	     BOARD = PREV_BOARD
    827 U3940							; TAKEBACK_PREV_X, TAKEBACK_PREV_Y, TAKEBACK_PUSH_X,PUSH_Y,TAKEBACK_PUSH_PREV
    828 U3940							;
    829 U3940
    830 U3940
    831 U3940							; free space here (but hard to use)
    832 U3940							; So we need to calculate where the next free bank is!
    833 U3940							; TODO: This looks dodgy.  Check..
    834 U3940
    835 U3940				   ORIGIN     SET	( * + RAM_SIZE - 1 ) / RAM_SIZE
    836 U3940				   ORIGIN     SET	ORIGIN * RAM_SIZE
    837 U3940
    838 U3940
    839 U3940
    840 U3940							;------------------------------------------------------------------------------
    841 U3940							;##############################################################################
    842 U3940							;------------------------------------------------------------------------------
    843 U3940
    844 U3940							;------------------------------------------------------------------------------
    845 U3940
    846 U3940							;    IFNCONST MAX_LEVEL_SIZE
    847 U3940				   MAX_LEVEL_SIZE SET	0
    848 U3940							;    ENDIF
    849 U3940
    850 U3940
    851 U3940				   MAX_LEVEL_NUMBER SET	0
    852 U3940					      MAC	start_level
    853 U3940				   LEVEL_START SET	*
    854 U3940				   BANK_LEVEL_{1} =	_CURRENT_BANK
    855 U3940				   LEVEL_{1}  SUBROUTINE
    856 U3940				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
    857 U3940							; ECHO "current MAX_LEVEL_NUMBER = ", MAX_LEVEL_NUMBER
    858 U3940					      ENDM		; {name}
    859 U3940
    860 U3940
    861 U3940					      MAC	end_level
    862 U3940				   LEVEL_SIZE_{1} =	* - LEVEL_START
    863 U3940					      IF	LEVEL_SIZE_{1} > MAX_LEVEL_SIZE
    864 U3940				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_{1}
    865 U3940					      ENDIF
    866 U3940					      ENDM		; {name}
    867 U3940
    868 U3940
    869 U3940					      MAC	defl
    870 U3940					      START_LEVEL	{1}
    871 U3940					      .byte	{2},0
    872 U3940					      END_LEVEL	{1}
    873 U3940					      ENDM
    874 U3940
    875 U3940							;--------------------------------------------------------------------------------
    876 U3940
    877 U3940				   ORIGIN     SET	$00000
    878 U3940
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 3
      0 U3940					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1 U3940							;    Sokoboo - a Sokoban implementation
      2 U3940							;    using a generic tile-based display engine for the Atari 2600
      3 U3940							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4 U3940							;
      5 U3940							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6 U3940							;
      7 U3940							;    Code related to the generic tile-based display engine was developed by
      8 U3940							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9 U3940							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10 U3940							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11 U3940							;
     12 U3940							;    Code related to music and sound effects uses the TIATracker music player
     13 U3940							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14 U3940							;    directory for Apache licensing details.
     15 U3940							;
     16 U3940							;    Some level data incorporated in this program were created by Lee J Haywood.
     17 U3940							;    See the copyright notices in the License directory for a list of level
     18 U3940							;    contributors.
     19 U3940							;
     20 U3940							;    Except where otherwise indicated, this software is released under the
     21 U3940							;    following licensing arrangement...
     22 U3940							;
     23 U3940							;    This program is free software: you can redistribute it and/or modify
     24 U3940							;    it under the terms of the GNU General Public License as published by
     25 U3940							;    the Free Software Foundation, either version 3 of the License, or
     26 U3940							;    (at your option) any later version.
     27 U3940							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28 U3940
     29 U3940							;    This program is distributed in the hope that it will be useful,
     30 U3940							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31 U3940							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32 U3940							;    GNU General Public License for more details.
     33 U3940
     34 U3940							;------------------------------------------------------------------------------
     35 U3940							;##############################################################################
     36 U3940							;------------------------------------------------------------------------------
      0 U3940					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  0362 ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
     38  0000
     39  0000							; This is essentially a ROM mirror of a RAM bank.
     40  0000							; The contents of this bank are copied to each of the ROW banks on startup, and
     41  0000							; this gives a 1:1 correspondence between the data/addresses defined here, and
     42  0000							; the addresses in the switched-in RAM bank.
     43  0000
     44  0000							; Note: Bankswitching code between any of these banks guarantees the code can
     45  0000							; continue to run -- because, of course, the same code is still at the same
     46  0000							; memory address.
     47  0000
     48  0000		       00 01	   _PROFILE_DRAW =	YES
     49  0000
     50  0000					      MAC	profile_draw
     51  0000					      IF	_PROFILE_DRAW
     52  0000					      inc	Profile{1}
     53  0000					      bne	$skip
     54  0000					      inc	Profile{1}+1
     55  0000				   $skip
     56  0000					      ENDIF
     57  0000					      ENDM		; {label}
     58  0000
     59  0000
      0  0000					      DEFINE_SUBROUTINE	DrawTheScreen
      1  0000		       00 00	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  0000					      SUBROUTINE
      3  0000				   DrawTheScreen
     61  0000
     62  0000							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     63  0000							; A refactor of the kernel to improve the timing.
     64  0000							; Experimental refactor to remove the blank line...
     65  0000
     66  0000							; adjust here so that the first line of the kernel starts exactly at cycle 67
     67  0000							; (since TJ said it could start up to 5 cycles earlier than #67).
     68  0000
     69  0000							; TODO: remove GRP1 and COLUP1 access (or use higher resolution player)
     70  0000							;	     @57
      0  0000					      SLEEP	3	; 3
      1  0000				   .CYCLES    SET	3
      2  0000
      3  0000				  -	      IF	.CYCLES < 2
      4  0000				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0000				  -	      ERR
      6  0000					      ENDIF
      7  0000
      8  0000					      IF	.CYCLES & 1
      9  0000					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0000		       04 00		      nop	0
     11  0002				  -	      ELSE
     12  0002				  -	      bit	VSYNC
     13  0002					      ENDIF
     14  0002				   .CYCLES    SET	.CYCLES - 3
     15  0002					      ENDIF
     16  0002
     17  0002				  -	      REPEAT	.CYCLES / 2
     18  0002				  -	      nop
     19  0002					      REPEND
     72  0002
     73  0002		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     74  0004		       10 3e		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     75  0006
     76  0006				   Proc2		; 5
      0  0006					      SLEEP	3	; 3	     @64
      1  0006				   .CYCLES    SET	3
      2  0006
      3  0006				  -	      IF	.CYCLES < 2
      4  0006				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0006				  -	      ERR
      6  0006					      ENDIF
      7  0006
      8  0006					      IF	.CYCLES & 1
      9  0006					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0006		       04 00		      nop	0
     11  0008				  -	      ELSE
     12  0008				  -	      bit	VSYNC
     13  0008					      ENDIF
     14  0008				   .CYCLES    SET	.CYCLES - 3
     15  0008					      ENDIF
     16  0008
     17  0008				  -	      REPEAT	.CYCLES / 2
     18  0008				  -	      nop
     19  0008					      REPEND
     78  0008		       10 3c		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     79  000a
     80  000a				   ScanRED		;	     @60
     81  000a		       b9 b6 f2    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     82  000d		       85 4d		      sta	PF0	; 3	     @67
     83  000f		       b9 2c f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     84  0012		       85 4e		      sta	PF1	; 3 = 14    @74
     85  0014							;SELFMOD_PLAYERCOL_RED
     86  0014		       b9 af f0 	      lda	SpriteColourRED,y	; 4
     87  0017							;lda #$66
     88  0017							;nop
     89  0017		       85 46		      sta	COLUP0	; 3	     @05
     90  0019		       85 47		      sta	COLUP1	; 3 = 10    @08
     91  001b
     92  001b							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     93  001b
     94  001b				   SELFMOD_RED
     95  001b		       a9 00		      lda	#0	; 2
     96  001d		       85 48		      sta	COLUPF	; 3 =	5    @13
     97  001f
     98  001f				   SELFMOD_PLAYER0_RED
     99  001f		       b9 b6 f2 	      lda	ShapePlayerRED,y	; 4
    100  0022		       85 5b		      sta	GRP0	; 3 =	7    @20
    101  0024
    102  0024		       b9 44 f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
    103  0027		       85 4f		      sta	PF2	; 3 =	7    @27
    104  0029
    105  0029		       b9 b6 f2    SM_PF0_REDr lda	CHARACTERSHAPE_BLANK,y	; 4
    106  002c		       85 4d		      sta	PF0	; 3	     @34
    107  002e		       b9 5c f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
    108  0031		       85 4e		      sta	PF1	; 3	     @41
    109  0033		       b9 74 f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
    110  0036		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
    111  0038
    112  0038				   SELFMOD_PLAYER1_RED
    113  0038		       b9 b6 f2 	      lda	ShapePlayerRED,y	; 4
    114  003b		       8d 5c 00 	      sta.w	GRP1	; 4 =	8    @56   VDELed!
    115  003e
    116  003e		       88		      dey		; 2
    117  003f		       10 c5		      bpl	Proc2	; 2(3)      --> 61 if taken
    118  0041
    119  0041		       e8	   SELFMOD_X  inx		; 2
    120  0042		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
    121  0044							;EXIT_RETURN_HERE
    122  0044				   NextALineStart
    123  0044		       a0 07		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
    124  0046				   ScanBLUEBD		;	     @67     let's start as late as possible
    125  0046
    126  0046							;------------------------------------------------------------------------------
    127  0046
    128  0046		       b9 b6 f2    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
    129  0049		       85 4d		      sta	PF0	; 3 =	7    @74
    130  004b							;SELFMOD_PLAYERCOL_BLUE
    131  004b		       b9 bf f0 	      lda	SpriteColourBLUE,y	; 4
    132  004e							;lda #$66
    133  004e							;nop
    134  004e		       85 47		      sta	COLUP1	; 3	     @05
    135  0050		       85 46		      sta	COLUP0	; 3 = 10    @08
    136  0052
    137  0052				   SELFMOD_BLUE
    138  0052		       a9 00		      lda	#0	; 2
    139  0054		       85 48		      sta	COLUPF	; 3 =	5    @13
    140  0056
    141  0056				   SELFMOD_PLAYER0_BLUE
    142  0056		       b9 b6 f2 	      lda	ShapePlayerBLUE,y	; 4
    143  0059		       85 5b		      sta	GRP0	; 3 =	7    @20
    144  005b
    145  005b		       b9 3c f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    146  005e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    147  0060		       b9 54 f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    148  0063		       85 4f		      sta	PF2	; 3 = 14    @34
    149  0065
    150  0065		       b9 b6 f2    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    151  0068		       85 4d		      sta	PF0	; 3	     @41
    152  006a		       b9 6c f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    153  006d		       85 4e		      sta	PF1	; 3	     @48
    154  006f		       b9 84 f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    155  0072		       85 4f		      sta	PF2	; 3 = 21    @55
    156  0074
    157  0074				   SELFMOD_PLAYER1_BLUE
    158  0074		       b9 b6 f2 	      lda	ShapePlayerBLUE,y	; 4
    159  0077		       85 5c		      sta	GRP1	; 3 =	7    VDELed! @62
    160  0079
    161  0079							;------------------------------------------------------------------------------
    162  0079
    163  0079				   ScanGREEN		;	     @62
    164  0079		       b9 b6 f2    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    165  007c		       85 4d		      sta	PF0	; 3 =	7    @69
    166  007e							;SELFMOD_PLAYERCOL_GREEN
    167  007e		       b9 b7 f0 	      lda	SpriteColourGREEN,y	; 4
    168  0081							;lda #$66
    169  0081							;nop
    170  0081		       85 47		      sta	COLUP1	; 3	     @00
    171  0083		       85 46		      sta	COLUP0	; 3 = 10    @03
    172  0085
    173  0085				   SELFMOD_GREEN
    174  0085		       a9 00		      lda	#0	; 2
    175  0087		       85 48		      sta	COLUPF	; 3 =	5    @08
    176  0089
    177  0089				   SELFMOD_PLAYER0_GREEN
    178  0089		       b9 b6 f2 	      lda	ShapePlayerGREEN,y	; 4
    179  008c		       85 5b		      sta	GRP0	; 3 =	7    @15
    180  008e
    181  008e		       b9 34 f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    182  0091		       85 4e		      sta	PF1	; 3	     @22
    183  0093		       b9 4c f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    184  0096		       85 4f		      sta	PF2	; 3 = 14    @29
    185  0098
    186  0098		       b9 b6 f2    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    187  009b		       85 4d		      sta	PF0	; 3	     @36
    188  009d		       b9 64 f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    189  00a0		       85 4e		      sta	PF1	; 3	     @43
    190  00a2		       b9 7c f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    191  00a5		       85 4f		      sta	PF2	; 3 = 21    @50
    192  00a7
    193  00a7				   SELFMOD_PLAYER1_GREEN
    194  00a7		       b9 b6 f2 	      lda	ShapePlayerGREEN,y	; 4
    195  00aa		       85 5c		      sta	GRP1	; 3 =	7    @57     VDELed!
    196  00ac
    197  00ac		       4c 0a f0 	      jmp	ScanRED	; 3	     @60
    198  00af
    199  00af							;------------------------------------------------------------------------------
    200  00af
    201  00af							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    202  00af
    203  00af		       f2 b6	   ShapePlayer =	PLAYER_BLANK
    204  00af		       f2 b6	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    205  00af		       f2 b6	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    206  00af		       f2 b6	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    207  00af
    208  00af		       f2 b6	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    209  00af		       f2 b6	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    210  00af
    211  00af
    212  00af				   PLAYER_COLOUR
    213  00af				   SpriteColourRED
    214  00af					      REPEAT	LINES_PER_CHAR/3
    215  00af		       24		      .byte.b	$24
    214  00af					      REPEND
    215  00b0		       24		      .byte.b	$24
    214  00b0					      REPEND
    215  00b1		       24		      .byte.b	$24
    214  00b1					      REPEND
    215  00b2		       24		      .byte.b	$24
    214  00b2					      REPEND
    215  00b3		       24		      .byte.b	$24
    214  00b3					      REPEND
    215  00b4		       24		      .byte.b	$24
    214  00b4					      REPEND
    215  00b5		       24		      .byte.b	$24
    214  00b5					      REPEND
    215  00b6		       24		      .byte.b	$24
    216  00b7					      REPEND
    217  00b7				   SpriteColourGREEN
    218  00b7					      REPEAT	LINES_PER_CHAR/3
    219  00b7		       24		      .byte.b	$24
    218  00b7					      REPEND
    219  00b8		       24		      .byte.b	$24
    218  00b8					      REPEND
    219  00b9		       24		      .byte.b	$24
    218  00b9					      REPEND
    219  00ba		       24		      .byte.b	$24
    218  00ba					      REPEND
    219  00bb		       24		      .byte.b	$24
    218  00bb					      REPEND
    219  00bc		       24		      .byte.b	$24
    218  00bc					      REPEND
    219  00bd		       24		      .byte.b	$24
    218  00bd					      REPEND
    219  00be		       24		      .byte.b	$24
    220  00bf					      REPEND
    221  00bf				   SpriteColourBLUE
    222  00bf					      REPEAT	LINES_PER_CHAR/3
    223  00bf		       24		      .byte.b	$24
    222  00bf					      REPEND
    223  00c0		       24		      .byte.b	$24
    222  00c0					      REPEND
    223  00c1		       24		      .byte.b	$24
    222  00c1					      REPEND
    223  00c2		       24		      .byte.b	$24
    222  00c2					      REPEND
    223  00c3		       24		      .byte.b	$24
    222  00c3					      REPEND
    223  00c4		       24		      .byte.b	$24
    222  00c4					      REPEND
    223  00c5		       24		      .byte.b	$24
    222  00c5					      REPEND
    223  00c6		       24		      .byte.b	$24
    224  00c7					      REPEND
    225  00c7
    226  00c7
    227  00c7							;------------------------------------------------------------------------------
    228  00c7
    229  00c7							;*** Ideas: ***
    230  00c7							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    231  00c7							;   13.5% on average), also unrolling would be more effective than now
    232  00c7							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    233  00c7							;   see EXPERIMENTAL)
    234  00c7							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    235  00c7							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    236  00c7							;   bidirectional linked list instead)
    237  00c7							; - calculate mirrored gfx data into RAM (saves ROM)
    238  00c7
    239  00c7							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    240  00c7							;currently:
    241  00c7							; 72%*539 (!unrolled)
    242  00c7							;+ 8%*304 (unrolled)
    243  00c7							;+20%*269 (unrolled)
    244  00c7							;--------
    245  00c7							;=   ~466.2 cycles on average
    246  00c7
    247  00c7							;alternative #1:
    248  00c7							; 72%*522 (unrolled)
    249  00c7							;+ 8%*352 (!unrolled)
    250  00c7							;+20%*307 (!unrolled)
    251  00c7							;--------
    252  00c7							;=   ~465.4 cycles on average
    253  00c7
    254  00c7
    255  00c7		       00 01	   MIRROR     =	1
    256  00c7		       00 80	   DIRECT     =	$80
    257  00c7
    258  00c7							;------------------------------------------------------------------------------
    259  00c7							; Here we don't draw into a buffer, but directly patch the kernel
    260  00c7							; VERY fast!
    261  00c7							;
    262  00c7							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    263  00c7							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    264  00c7
    265  00c7				   PF0Draw		; 25✅ cycles until here
    266  00c7
    267  00c7		       ae 84 02 	      ldx	INTIM	; 4
    268  00ca		       e0 03		      cpx	#SEGTIME_SCD_PF0	; 2
    269  00cc		       90 72		      bcc	ExitDraw	; 2(3)=8✅
    270  00ce
    271  00ce		       29 7f		      and	#<(~DIRECT)	; 2
    272  00d0		       aa		      tax		; 2 =	4✅
    273  00d1
    274  00d1		       98		      tya		; 2
    275  00d2		       0a		      asl		; 2	     no mirrored chars in PF0
    276  00d3		       a8		      tay		; 2 =	6✅
    277  00d4							;		  clc				  ; 2
    278  00d4
    279  00d4		       b9 44 f3 	      lda	CharacterDataVecHI,y	; 4
    280  00d7		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    281  00da		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    282  00dd		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19✅
    283  00e0
    284  00e0		       b9 26 f3 	      lda	CharacterDataVecLO,y	; 4
    285  00e3		       9d 0b f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    286  00e6		       69 07		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    287  00e8		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    288  00eb		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    289  00ed		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23✅
    290  00f0
    291  00f0		       4c ad fa 	      jmp	DrawAnother	; 3 =	[25]+8+4+6+19+24+3 = 88✅ entering DrawAnother
    292  00f3
    293  00f3							; Timing for PF0Draw
    294  00f3							; 88
    295  00f3							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    296  00f3
    297  00f3
    298  00f3							;------------------------------------------------------------------------------
    299  00f3							; Direct draw draws to PF0, which only has one active member of the character
    300  00f3							; pair -- so it can be a direct copy.	Quicker still!
    301  00f3
    302  00f3				   DirectDraw		; 37✅ cycles until here
    303  00f3
    304  00f3		       ad 84 02 	      lda	INTIM	; 4
    305  00f6		       c9 07		      cmp	#SEGTIME_SCD_DIRECT	; 2
    306  00f8		       90 46		      bcc	ExitDraw	; 2(3)=8
    307  00fa							; => [37]+(9)+6rts = 51 cycles if draw exits
    308  00fa
    309  00fa							; @ [37]+8 =45✅
    310  00fa
    311  00fa		       b9 44 f3 	      lda	CharacterDataVecHI,y	; 4
    312  00fd		       8d 2a f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    313  0100		       8d 30 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    314  0103		       8d 36 f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    315  0106
    316  0106		       b9 26 f3 	      lda	CharacterDataVecLO,y	; 4
    317  0109		       8d 29 f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    318  010c		       69 07		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    319  010e		       8d 2f f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    320  0111		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    321  0113		       8d 35 f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    322  0116
    323  0116		       bd ca f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    324  0119		       8d 2c f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    325  011c		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    326  011e		       8d 32 f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    327  0121		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    328  0123		       8d 38 f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    329  0126
    330  0126		       a0 07		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    331  0128
    332  0128							; @45+16+20+20+2 = @103
    333  0128				   TSFill3		; 8*{...
    334  0128		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    335  012b		       99 2c f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    336  012e		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    337  0131		       99 2c f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    338  0134		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    339  0137		       99 2c f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    340  013a
    341  013a		       88		      dey		; 2
      0  013b					      CHECKPAGE_BPL	TSFill3	; 3(2)=5 ...32✅} = 8*32-1 = 255
      8  013b					      LIST	ON
      9  013b		       10 eb		      bpl	TSFill3
    343  013d
    344  013d		       4c ad fa 	      jmp	DrawAnother	; 3
    345  0140							; => @103+255+3 = 361✅ entering DrawAnother
    346  0140
    347  0140		       60	   ExitDraw   rts		; 6
    348  0141
    349  0141							;------------------------------------------------------------------------------
    350  0141
      0  0141					      DEFINE_SUBROUTINE	StealPart3	; [18]✅ CYCLES TO HERE
      1  0141		       00 00	   BANK_StealPart3 =	_CURRENT_BANK
      2  0141					      SUBROUTINE
      3  0141				   StealPart3
    352  0141
    353  0141		       bd dc f1 	      lda	MOD10,x	; 4
    354  0144		       30 81		      bmi	PF0Draw	; 2/3 --> 25 cycles entering PF0Draw
    355  0146
    356  0146		       4a		      lsr		; 2
    357  0147		       aa		      tax		; 2
    358  0148		       98		      tya		; 2
    359  0149		       2a		      rol		; 2	       allows for mirrored char = * | 1
    360  014a		       a8		      tay		; 2
    361  014b		       b0 a6		      bcs	DirectDraw	; 2(3) = 18✅ when draw stack was built, bit 7 flags direct-drawn character
    362  014d							; ==> [18]+{19) = 37 @ start of DirectDraw
    363  014d
    364  014d		       b9 44 f3 	      lda	CharacterDataVecHI,y	; 4
    365  0150		       10 38		      bpl	QuickDraw	; 2(3) = 6(7)	 special-case blank characters for extra speed
    366  0152							; => [18]+18+(7) = 43✅ starting QuickDraw
    367  0152							; +15 => 58✅ if QuickDraw exits
    368  0152
    369  0152							; @ 24
    370  0152
    371  0152		       8d 7b f5 	      sta	SMEOR1+RAM_WRITE+2	; 4
    372  0155
    373  0155		       ad 84 02 	      lda	INTIM	; 4
    374  0158		       c9 0c		      cmp	#SEGTIME_SCD_SLOW	; 2
    375  015a		       90 e4		      bcc	ExitDraw	; 2(3) = 8
    376  015c							; => [18]+55+6rts=79✅ cycles if we decline
    377  015c
    378  015c							; @36
    379  015c							; [18]+36 = @54
    380  015c
    381  015c		       b9 26 f3 	      lda	CharacterDataVecLO,y	; 4
    382  015f		       8d 7a f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    383  0162
    384  0162		       bd ca f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    385  0165		       8d 77 f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    386  0168		       8d 7f f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    387  016b		       8d 82 f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    388  016e
    389  016e		       bd d4 f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    390  0171		       8d 7d f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    391  0174
    392  0174		       a0 17	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2 => @88+
    393  0176
    394  0176							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    395  0176							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    396  0176
    397  0176				   TSFill		; 24*{...✅
    398  0176
    399  0176		       b9 2c f2    SMLOAD     lda	ScreenBitmap,y	; 4
    400  0179		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    401  017c		       29 00	   SMMASK     and	#0	; 2
    402  017e		       59 2c f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    403  0181		       99 2c f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    404  0184
    405  0184		       88		      dey		; 2
      0  0185					      CHECKPAGE_BPL	TSFill	; 3(2)=5  ...24}-1 = 575✅
      8  0185					      LIST	ON
      9  0185		       10 ef		      bpl	TSFill
    407  0187
    408  0187		       4c ad fa 	      jmp	DrawAnother	; 3 = @88+575+3 = @676✅
    409  018a
    410  018a
    411  018a							;------------------------------------------------------------------------------
    412  018a							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    413  018a							; existing character data, so can be special-cased from the normal character
    414  018a							; draw, saving roughly 230 cycles.
    415  018a
    416  018a				   QuickDraw		; [43]✅ cycles until here
    417  018a
    418  018a		       ad 84 02 	      lda	INTIM	; 4
    419  018d		       c9 07		      cmp	#SEGTIME_SCD_QUICK	; 2
    420  018f		       90 af		      bcc	ExitDraw	; 2(3)=8(9)
    421  0191							; =>[43]+(9)+6rts =58✅ if exit
    422  0191							;@[43]+8=51✅
    423  0191
    424  0191		       bd ca f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    425  0194		       8d b1 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    426  0197		       8d b4 f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    427  019a		       69 07		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    428  019c		       8d b8 f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    429  019f		       8d bb f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    430  01a2		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    431  01a4		       8d bf f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    432  01a7		       8d c2 f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32✅
    433  01aa
    434  01aa		       bc d2 f1 	      ldy	CharMask,x	; 4	     masks out left or right
    435  01ad
    436  01ad		       a2 07		      ldx	#LINES_PER_CHAR/3 - 1	; 2	     =32+4+2+8*{...✅
    437  01af				   TSFill2
    438  01af		       98		      tya		; 2
    439  01b0		       3d 2c f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    440  01b3		       9d 2c f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    441  01b6		       98		      tya		; 2
    442  01b7		       3d 2c f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    443  01ba		       9d 2c f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    444  01bd		       98		      tya		; 2
    445  01be		       3d 2c f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    446  01c1		       9d 2c f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33✅
    447  01c4
    448  01c4		       ca		      dex		; 2
      0  01c5					      CHECKPAGE_BPL	TSFill2	; 3(2) = 5  ...} = 32+4+2+8*38-1
      8  01c5					      LIST	ON
      9  01c5		       10 e8		      bpl	TSFill2
    450  01c7							;		  => 341✅
    451  01c7
    452  01c7		       4c ad fa 	      jmp	DrawAnother	; 3 = 344
    453  01ca
    454  01ca							;------------------------------------------------------------------------------
    455  01ca
    456  01ca
    457  01ca				   CharAddressLO		;[abs char location % 10]
    458  01ca
    459  01ca							; Gives the absolute screen buffer address of the first line of the given character
    460  01ca							; Where character number is 0-9
    461  01ca
    462  01ca		       2c		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    463  01cb		       2c		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    464  01cc		       44		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    465  01cd		       44		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    466  01ce		       5c		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    467  01cf		       5c		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    468  01d0		       74		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    469  01d1		       74		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    470  01d2							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    471  01d2							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    472  01d2
    473  01d2				   CharMask		; [abs char location % 10]
    474  01d2
    475  01d2							; Gives the mask for any char of the screen (per row)
    476  01d2							; Note, this is hardwired to the screen format of 6 bytes/line
    477  01d2
    478  01d2		       0f		      .byte.b	$0F	; 1
    479  01d3		       f0		      .byte.b	$F0	; 2
    480  01d4				   CharMaskNeg
    481  01d4		       f0		      .byte.b	$F0	; 3/1
    482  01d5		       0f		      .byte.b	$0F	; 4/2
    483  01d6		       0f		      .byte.b	$0F	; 6/3
    484  01d7		       f0		      .byte.b	$F0	; 7/4
    485  01d8		       f0		      .byte.b	$F0	; 8/6
    486  01d9		       0f		      .byte.b	$0F	; 9/7
    487  01da		       0f		      .byte.b	$0F	; -/8
    488  01db		       f0		      .byte.b	$F0	; -/9
    489  01dc				   MOD10
    490  01dc					      REPEAT	SCREEN_LINES
    491  01dc							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    492  01dc							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    493  01dc		       80		      .byte.b	DIRECT
    494  01dd		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    495  01e1		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    496  01e2		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    490  01e2					      REPEND
    491  01e6							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    492  01e6							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    493  01e6		       80		      .byte.b	DIRECT
    494  01e7		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    495  01eb		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    496  01ec		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    490  01ec					      REPEND
    491  01f0							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    492  01f0							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    493  01f0		       80		      .byte.b	DIRECT
    494  01f1		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    495  01f5		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    496  01f6		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    490  01f6					      REPEND
    491  01fa							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    492  01fa							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    493  01fa		       80		      .byte.b	DIRECT
    494  01fb		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    495  01ff		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    496  0200		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    490  0200					      REPEND
    491  0204							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    492  0204							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    493  0204		       80		      .byte.b	DIRECT
    494  0205		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    495  0209		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    496  020a		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    490  020a					      REPEND
    491  020e							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    492  020e							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    493  020e		       80		      .byte.b	DIRECT
    494  020f		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    495  0213		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    496  0214		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    490  0214					      REPEND
    491  0218							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    492  0218							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    493  0218		       80		      .byte.b	DIRECT
    494  0219		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    495  021d		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    496  021e		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    490  021e					      REPEND
    491  0222							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    492  0222							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    493  0222		       80		      .byte.b	DIRECT
    494  0223		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    495  0227		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    496  0228		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    497  022c					      REPEND
    498  022c
    499  022c							;------------------------------------------------------------------------------
    500  022c
      0  022c					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  022c					      LIST	ON
    502  022c
    503  022c		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,0	; character bitmap row (10 chars wide)
    504  022c		       f2 2c	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    505  022c		       f2 34	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    506  022c		       f2 3c	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    507  028c
      0  028c					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  028c					      LIST	ON
    509  028c
    510  028c
    511  028c							;--------------------------------------------------------------------------
    512  028c
      0  028c					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  028c		       00 00	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  028c					      SUBROUTINE
      3  028c				   SelfModDrawPlayers
    514  028c
    515  028c							; Now the player(s) have animated, update the appropriate shape pointers
    516  028c							; in the draw code.
    517  028c
    518  028c							; Sets the shapes to a blank player -- effectively erasing
    519  028c
    520  028c		       a5 b0		      lda	LastSpriteY
    521  028e		       a2 b6		      ldx	#<PLAYER_BLANK
    522  0290		       20 9f f2 	      jsr	SetSelfModPlayer
    523  0293
    524  0293							; Now we've erased, we write the new shape
    525  0293
    526  0293		       a5 a1		      lda	ManDrawX
    527  0295		       c9 0a		      cmp	#SCREEN_WIDTH
    528  0297		       b0 1c		      bcs	NoMod	; skip if off visible screen
    529  0299
    530  0299		       a5 a2		      lda	ManDrawY
    531  029b		       85 b0		      sta	LastSpriteY
    532  029d
    533  029d		       a2 ce		      ldx	#<PLAYER_RIGHT0
    534  029f
    535  029f				   SetSelfModPlayer
    536  029f		       c9 08		      cmp	#SCREEN_LINES	; only erase/draw if was/is onscreen
    537  02a1		       b0 12		      bcs	NoMod
    538  02a3		       69 00		      adc	#BANK_SCREENMARKII1
    539  02a5		       85 3e		      sta	SET_BANK_RAM	; switch old/new bank in
    540  02a7
    541  02a7		       8a		      txa
    542  02a8		       8d 20 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1	; lo of frame
    543  02ab		       69 08		      adc	#LINES_PER_CHAR/3
    544  02ad		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    545  02b0		       69 08		      adc	#LINES_PER_CHAR/3
    546  02b2		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    547  02b5
    548  02b5		       60	   NoMod      rts
    549  02b6
      0  02b6					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  02b6
      2  02b6
      3  02b6		       02 b6	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $2b6 , FREE= $14a
      4  02b6					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  02b6				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  02b6				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  02b6				  -	      ERR
      8  02b6					      endif
    551  02b6
------- FILE player.asm LEVEL 3 PASS 3
      0  02b6					      include	"player.asm"	; 6 * LINES_PER_CHAR	       MUST FOLLOW DIRT.ASM as data is shared
      1  02b6							;    Sokoboo - a Sokoban implementation
      2  02b6							;    using a generic tile-based display engine for the Atari 2600
      3  02b6							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  02b6							;
      5  02b6							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  02b6							;
      7  02b6							;    Code related to the generic tile-based display engine was developed by
      8  02b6							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  02b6							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  02b6							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  02b6							;
     12  02b6							;    Code related to music and sound effects uses the TIATracker music player
     13  02b6							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  02b6							;    directory for Apache licensing details.
     15  02b6							;
     16  02b6							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  02b6							;    See the copyright notices in the License directory for a list of level
     18  02b6							;    contributors.
     19  02b6							;
     20  02b6							;    Except where otherwise indicated, this software is released under the
     21  02b6							;    following licensing arrangement...
     22  02b6							;
     23  02b6							;    This program is free software: you can redistribute it and/or modify
     24  02b6							;    it under the terms of the GNU General Public License as published by
     25  02b6							;    the Free Software Foundation, either version 3 of the License, or
     26  02b6							;    (at your option) any later version.
     27  02b6							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  02b6
     29  02b6							;    This program is distributed in the hope that it will be useful,
     30  02b6							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  02b6							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  02b6							;    GNU General Public License for more details.
     33  02b6
     34  02b6							;    OPTIONAL_PAGEBREAK "PLAYER", LINES_PER_CHAR * 6 - 1
     35  02b6
     36  02b6
     37  02b6				   PLAYER_BLANK
     38  02b6					      REPEAT	LINES_PER_CHAR	;-1  ; as we have a "0" in the line below
     39  02b6		       00		      .byte.b	0
     38  02b6					      REPEND
     39  02b7		       00		      .byte.b	0
     38  02b7					      REPEND
     39  02b8		       00		      .byte.b	0
     38  02b8					      REPEND
     39  02b9		       00		      .byte.b	0
     38  02b9					      REPEND
     39  02ba		       00		      .byte.b	0
     38  02ba					      REPEND
     39  02bb		       00		      .byte.b	0
     38  02bb					      REPEND
     39  02bc		       00		      .byte.b	0
     38  02bc					      REPEND
     39  02bd		       00		      .byte.b	0
     38  02bd					      REPEND
     39  02be		       00		      .byte.b	0
     38  02be					      REPEND
     39  02bf		       00		      .byte.b	0
     38  02bf					      REPEND
     39  02c0		       00		      .byte.b	0
     38  02c0					      REPEND
     39  02c1		       00		      .byte.b	0
     38  02c1					      REPEND
     39  02c2		       00		      .byte.b	0
     38  02c2					      REPEND
     39  02c3		       00		      .byte.b	0
     38  02c3					      REPEND
     39  02c4		       00		      .byte.b	0
     38  02c4					      REPEND
     39  02c5		       00		      .byte.b	0
     38  02c5					      REPEND
     39  02c6		       00		      .byte.b	0
     38  02c6					      REPEND
     39  02c7		       00		      .byte.b	0
     38  02c7					      REPEND
     39  02c8		       00		      .byte.b	0
     38  02c8					      REPEND
     39  02c9		       00		      .byte.b	0
     38  02c9					      REPEND
     39  02ca		       00		      .byte.b	0
     38  02ca					      REPEND
     39  02cb		       00		      .byte.b	0
     38  02cb					      REPEND
     39  02cc		       00		      .byte.b	0
     38  02cc					      REPEND
     39  02cd		       00		      .byte.b	0
     40  02ce					      REPEND
     41  02ce
     42  02ce				   PLAYER_RIGHT0
     43  02ce
     44  02ce		       18		      .byte.b	%00011000	;20
     45  02cf		       18		      .byte.b	%00011000	;20
     46  02d0		       7e		      .byte.b	%01111110	;20
     47  02d1		       7e		      .byte.b	%01111110	;20
     48  02d2		       7e		      .byte.b	%01111110	;20
     49  02d3		       18		      .byte.b	%00011000	;20
     50  02d4		       18		      .byte.b	%00011000	;20
     51  02d5		       00		      .byte.b	%00000000	;20
     52  02d6
     53  02d6		       18		      .byte.b	%00011000	;20
     54  02d7		       18		      .byte.b	%00011000	;20
     55  02d8		       7e		      .byte.b	%01111110	;20
     56  02d9		       7e		      .byte.b	%01111110	;20
     57  02da		       7e		      .byte.b	%01111110	;20
     58  02db		       18		      .byte.b	%00011000	;20
     59  02dc		       18		      .byte.b	%00011000	;20
     60  02dd		       00		      .byte.b	%00000000	;20
     61  02de
     62  02de		       18		      .byte.b	%00011000	;20
     63  02df		       18		      .byte.b	%00011000	;20
     64  02e0		       7e		      .byte.b	%01111110	;20
     65  02e1		       7e		      .byte.b	%01111110	;20
     66  02e2		       7e		      .byte.b	%01111110	;20
     67  02e3		       18		      .byte.b	%00011000	;20
     68  02e4		       18		      .byte.b	%00011000	;20
     69  02e5		       00		      .byte.b	%00000000	;20
     70  02e6
     71  02e6				   PLAYER_RIGHT1
     72  02e6				   PLAYER_STAND
     73  02e6				   PLAYER_BLINK
     74  02e6				   PLAYER_TAP0
     75  02e6				   PLAYER_TAP1
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    553  02e6
    554  02e6							;------------------------------------------------------------------------------
    555  02e6
    556  02e6							; The acutal colour palette to use for the player. The player may be any "ethnicity" which refers
    557  02e6							; to the colours for a frame. The skin could be asian/black/caucasian, the cloting could be anything.
    558  02e6							; Each ethnicity is defined as first 8 bytes for NTSC and then 8 bytes for PAL. The 8 bytes refer
    559  02e6							; to the "CL#" index values defined in the player COLOUR frames. So, an index is grabbed from the
    560  02e6							; player frame, it is adjusted to add the base ethnicity and the NTSC/PAL, and that gives the base
    561  02e6							; for reading 8 successive bytes for CL0..CL7 from the frame definitions.
    562  02e6
    563  02e6				   EthnicityColourPalette
    564  02e6
    565  02e6
    566  02e6
    567  02e6
    568  02e6
    569  02e6
    570  02e6
    571  02e6
    572  02e6
    573  02e6
    574  02e6
    575  02e6
    576  02e6							; CL0	   = BLACK
    577  02e6							; CL1	   = HAT
    578  02e6							; CL2	   = SKIN
    579  02e6							; CL3	   = CUFFS/TRIM
    580  02e6							; CL4	   = JUMPER
    581  02e6							; CL5	   = PANTS
    582  02e6							; CL6	   = SHOES
    583  02e6							; CL7	   = UNUSED
    584  02e6
    585  02e6							; CL0 = black
    586  02e6							; CL1 = hat
    587  02e6							; CL2 = face, hands
    588  02e6							; CL3 = trim
    589  02e6							; CL4 = jumper
    590  02e6							; CL5 = pants
    591  02e6							; CL6 = shoes
    592  02e6							; CL7 = NOT USABLE
    593  02e6
    594  02e6							; (*) = unchecked/converted
    595  02e6
    596  02e6					      MAC	colour_group
    597  02e6							; NTSC...
    598  02e6					      .byte	0
    599  02e6					      .byte	{1}+{2}
    600  02e6					      .byte	{3}+{4}
    601  02e6					      .byte	{5}+{6}
    602  02e6					      .byte	{7}+{8}
    603  02e6					      .byte	{9}+{10}
    604  02e6					      .byte	{11}+{12}
    605  02e6					      .byte	0
    606  02e6
    607  02e6							; PAL...
    608  02e6					      .byte	0
    609  02e6					      NTSC_TO_PAL	{1}, {2}
    610  02e6					      NTSC_TO_PAL	{3}, {4}
    611  02e6					      NTSC_TO_PAL	{5}, {6}
    612  02e6					      NTSC_TO_PAL	{7}, {8}
    613  02e6					      NTSC_TO_PAL	{9}, {10}
    614  02e6					      NTSC_TO_PAL	{11}, {12}
    615  02e6					      .byte	0
    616  02e6					      ENDM
    617  02e6
    618  02e6							; USE NTSC COLOUR+INTENSITY. WILL AUTO-ADD PAL EQUIVALENT...
    619  02e6							;		 HAT	 FACE	 TRIM	 JUMPER  PANTS	SHOES
      0  02e6					      COLOUR_GROUP	$10,$A, $40,$8, $00,$C, $80,$8, $90,6, $10,6	; 0
      1  02e6
      2  02e6		       00		      .byte.b	0
      3  02e7		       1a		      .byte.b	$10+$A
      4  02e8		       48		      .byte.b	$40+$8
      5  02e9		       0c		      .byte.b	$00+$C
      6  02ea		       88		      .byte.b	$80+$8
      7  02eb		       96		      .byte.b	$90+6
      8  02ec		       16		      .byte.b	$10+6
      9  02ed		       00		      .byte.b	0
     10  02ee
     11  02ee
     12  02ee		       00		      .byte.b	0
      0  02ef					      NTSC_TO_PAL	$10, $A
      1  02ef				  -	      IF	$10 = 0
      2  02ef				  -	      .byte	$10+$A
      3  02ef					      ENDIF
      4  02ef					      IF	$10 = $10
      5  02ef		       2c		      .byte.b	$22+$A
      6  02f0					      ENDIF
      7  02f0				  -	      IF	$10 = $20
      8  02f0				  -	      .byte	$42+$A
      9  02f0					      ENDIF
     10  02f0				  -	      IF	$10 = $30
     11  02f0				  -	      .byte	$42+$A
     12  02f0					      ENDIF
     13  02f0				  -	      IF	$10 = $40
     14  02f0				  -	      .byte	$62+$A
     15  02f0					      ENDIF
     16  02f0				  -	      IF	$10 = $50
     17  02f0				  -	      .byte	$82+$A
     18  02f0					      ENDIF
     19  02f0				  -	      IF	$10 = $60
     20  02f0				  -	      .byte	$C2+$A
     21  02f0					      ENDIF
     22  02f0				  -	      IF	$10 = $70
     23  02f0				  -	      .byte	$D2+$A
     24  02f0					      ENDIF
     25  02f0				  -	      IF	$10 = $80
     26  02f0				  -	      .byte	$B2+$A
     27  02f0					      ENDIF
     28  02f0				  -	      IF	$10 = $90
     29  02f0				  -	      .byte	$92+$A
     30  02f0					      ENDIF
     31  02f0				  -	      IF	$10 = $A0
     32  02f0				  -	      .byte	$72+$A
     33  02f0					      ENDIF
     34  02f0				  -	      IF	$10 = $B0
     35  02f0				  -	      .byte	$52+$A
     36  02f0					      ENDIF
     37  02f0				  -	      IF	$10 = $C0
     38  02f0				  -	      .byte	$32+$A
     39  02f0					      ENDIF
     40  02f0				  -	      IF	$10 = $D0
     41  02f0				  -	      .byte	$32+$A
     42  02f0					      ENDIF
     43  02f0				  -	      IF	$10 = $E0
     44  02f0				  -	      .byte	$22+$A
     45  02f0					      ENDIF
     46  02f0				  -	      IF	$10 = $F0
     47  02f0				  -	      .byte	$42+$A
     48  02f0					      ENDIF
      0  02f0					      NTSC_TO_PAL	$40, $8
      1  02f0				  -	      IF	$40 = 0
      2  02f0				  -	      .byte	$40+$8
      3  02f0					      ENDIF
      4  02f0				  -	      IF	$40 = $10
      5  02f0				  -	      .byte	$22+$8
      6  02f0					      ENDIF
      7  02f0				  -	      IF	$40 = $20
      8  02f0				  -	      .byte	$42+$8
      9  02f0					      ENDIF
     10  02f0				  -	      IF	$40 = $30
     11  02f0				  -	      .byte	$42+$8
     12  02f0					      ENDIF
     13  02f0					      IF	$40 = $40
     14  02f0		       6a		      .byte.b	$62+$8
     15  02f1					      ENDIF
     16  02f1				  -	      IF	$40 = $50
     17  02f1				  -	      .byte	$82+$8
     18  02f1					      ENDIF
     19  02f1				  -	      IF	$40 = $60
     20  02f1				  -	      .byte	$C2+$8
     21  02f1					      ENDIF
     22  02f1				  -	      IF	$40 = $70
     23  02f1				  -	      .byte	$D2+$8
     24  02f1					      ENDIF
     25  02f1				  -	      IF	$40 = $80
     26  02f1				  -	      .byte	$B2+$8
     27  02f1					      ENDIF
     28  02f1				  -	      IF	$40 = $90
     29  02f1				  -	      .byte	$92+$8
     30  02f1					      ENDIF
     31  02f1				  -	      IF	$40 = $A0
     32  02f1				  -	      .byte	$72+$8
     33  02f1					      ENDIF
     34  02f1				  -	      IF	$40 = $B0
     35  02f1				  -	      .byte	$52+$8
     36  02f1					      ENDIF
     37  02f1				  -	      IF	$40 = $C0
     38  02f1				  -	      .byte	$32+$8
     39  02f1					      ENDIF
     40  02f1				  -	      IF	$40 = $D0
     41  02f1				  -	      .byte	$32+$8
     42  02f1					      ENDIF
     43  02f1				  -	      IF	$40 = $E0
     44  02f1				  -	      .byte	$22+$8
     45  02f1					      ENDIF
     46  02f1				  -	      IF	$40 = $F0
     47  02f1				  -	      .byte	$42+$8
     48  02f1					      ENDIF
      0  02f1					      NTSC_TO_PAL	$00, $C
      1  02f1					      IF	$00 = 0
      2  02f1		       0c		      .byte.b	$00+$C
      3  02f2					      ENDIF
      4  02f2				  -	      IF	$00 = $10
      5  02f2				  -	      .byte	$22+$C
      6  02f2					      ENDIF
      7  02f2				  -	      IF	$00 = $20
      8  02f2				  -	      .byte	$42+$C
      9  02f2					      ENDIF
     10  02f2				  -	      IF	$00 = $30
     11  02f2				  -	      .byte	$42+$C
     12  02f2					      ENDIF
     13  02f2				  -	      IF	$00 = $40
     14  02f2				  -	      .byte	$62+$C
     15  02f2					      ENDIF
     16  02f2				  -	      IF	$00 = $50
     17  02f2				  -	      .byte	$82+$C
     18  02f2					      ENDIF
     19  02f2				  -	      IF	$00 = $60
     20  02f2				  -	      .byte	$C2+$C
     21  02f2					      ENDIF
     22  02f2				  -	      IF	$00 = $70
     23  02f2				  -	      .byte	$D2+$C
     24  02f2					      ENDIF
     25  02f2				  -	      IF	$00 = $80
     26  02f2				  -	      .byte	$B2+$C
     27  02f2					      ENDIF
     28  02f2				  -	      IF	$00 = $90
     29  02f2				  -	      .byte	$92+$C
     30  02f2					      ENDIF
     31  02f2				  -	      IF	$00 = $A0
     32  02f2				  -	      .byte	$72+$C
     33  02f2					      ENDIF
     34  02f2				  -	      IF	$00 = $B0
     35  02f2				  -	      .byte	$52+$C
     36  02f2					      ENDIF
     37  02f2				  -	      IF	$00 = $C0
     38  02f2				  -	      .byte	$32+$C
     39  02f2					      ENDIF
     40  02f2				  -	      IF	$00 = $D0
     41  02f2				  -	      .byte	$32+$C
     42  02f2					      ENDIF
     43  02f2				  -	      IF	$00 = $E0
     44  02f2				  -	      .byte	$22+$C
     45  02f2					      ENDIF
     46  02f2				  -	      IF	$00 = $F0
     47  02f2				  -	      .byte	$42+$C
     48  02f2					      ENDIF
      0  02f2					      NTSC_TO_PAL	$80, $8
      1  02f2				  -	      IF	$80 = 0
      2  02f2				  -	      .byte	$80+$8
      3  02f2					      ENDIF
      4  02f2				  -	      IF	$80 = $10
      5  02f2				  -	      .byte	$22+$8
      6  02f2					      ENDIF
      7  02f2				  -	      IF	$80 = $20
      8  02f2				  -	      .byte	$42+$8
      9  02f2					      ENDIF
     10  02f2				  -	      IF	$80 = $30
     11  02f2				  -	      .byte	$42+$8
     12  02f2					      ENDIF
     13  02f2				  -	      IF	$80 = $40
     14  02f2				  -	      .byte	$62+$8
     15  02f2					      ENDIF
     16  02f2				  -	      IF	$80 = $50
     17  02f2				  -	      .byte	$82+$8
     18  02f2					      ENDIF
     19  02f2				  -	      IF	$80 = $60
     20  02f2				  -	      .byte	$C2+$8
     21  02f2					      ENDIF
     22  02f2				  -	      IF	$80 = $70
     23  02f2				  -	      .byte	$D2+$8
     24  02f2					      ENDIF
     25  02f2					      IF	$80 = $80
     26  02f2		       ba		      .byte.b	$B2+$8
     27  02f3					      ENDIF
     28  02f3				  -	      IF	$80 = $90
     29  02f3				  -	      .byte	$92+$8
     30  02f3					      ENDIF
     31  02f3				  -	      IF	$80 = $A0
     32  02f3				  -	      .byte	$72+$8
     33  02f3					      ENDIF
     34  02f3				  -	      IF	$80 = $B0
     35  02f3				  -	      .byte	$52+$8
     36  02f3					      ENDIF
     37  02f3				  -	      IF	$80 = $C0
     38  02f3				  -	      .byte	$32+$8
     39  02f3					      ENDIF
     40  02f3				  -	      IF	$80 = $D0
     41  02f3				  -	      .byte	$32+$8
     42  02f3					      ENDIF
     43  02f3				  -	      IF	$80 = $E0
     44  02f3				  -	      .byte	$22+$8
     45  02f3					      ENDIF
     46  02f3				  -	      IF	$80 = $F0
     47  02f3				  -	      .byte	$42+$8
     48  02f3					      ENDIF
      0  02f3					      NTSC_TO_PAL	$90, 6
      1  02f3				  -	      IF	$90 = 0
      2  02f3				  -	      .byte	$90+6
      3  02f3					      ENDIF
      4  02f3				  -	      IF	$90 = $10
      5  02f3				  -	      .byte	$22+6
      6  02f3					      ENDIF
      7  02f3				  -	      IF	$90 = $20
      8  02f3				  -	      .byte	$42+6
      9  02f3					      ENDIF
     10  02f3				  -	      IF	$90 = $30
     11  02f3				  -	      .byte	$42+6
     12  02f3					      ENDIF
     13  02f3				  -	      IF	$90 = $40
     14  02f3				  -	      .byte	$62+6
     15  02f3					      ENDIF
     16  02f3				  -	      IF	$90 = $50
     17  02f3				  -	      .byte	$82+6
     18  02f3					      ENDIF
     19  02f3				  -	      IF	$90 = $60
     20  02f3				  -	      .byte	$C2+6
     21  02f3					      ENDIF
     22  02f3				  -	      IF	$90 = $70
     23  02f3				  -	      .byte	$D2+6
     24  02f3					      ENDIF
     25  02f3				  -	      IF	$90 = $80
     26  02f3				  -	      .byte	$B2+6
     27  02f3					      ENDIF
     28  02f3					      IF	$90 = $90
     29  02f3		       98		      .byte.b	$92+6
     30  02f4					      ENDIF
     31  02f4				  -	      IF	$90 = $A0
     32  02f4				  -	      .byte	$72+6
     33  02f4					      ENDIF
     34  02f4				  -	      IF	$90 = $B0
     35  02f4				  -	      .byte	$52+6
     36  02f4					      ENDIF
     37  02f4				  -	      IF	$90 = $C0
     38  02f4				  -	      .byte	$32+6
     39  02f4					      ENDIF
     40  02f4				  -	      IF	$90 = $D0
     41  02f4				  -	      .byte	$32+6
     42  02f4					      ENDIF
     43  02f4				  -	      IF	$90 = $E0
     44  02f4				  -	      .byte	$22+6
     45  02f4					      ENDIF
     46  02f4				  -	      IF	$90 = $F0
     47  02f4				  -	      .byte	$42+6
     48  02f4					      ENDIF
      0  02f4					      NTSC_TO_PAL	$10, 6
      1  02f4				  -	      IF	$10 = 0
      2  02f4				  -	      .byte	$10+6
      3  02f4					      ENDIF
      4  02f4					      IF	$10 = $10
      5  02f4		       28		      .byte.b	$22+6
      6  02f5					      ENDIF
      7  02f5				  -	      IF	$10 = $20
      8  02f5				  -	      .byte	$42+6
      9  02f5					      ENDIF
     10  02f5				  -	      IF	$10 = $30
     11  02f5				  -	      .byte	$42+6
     12  02f5					      ENDIF
     13  02f5				  -	      IF	$10 = $40
     14  02f5				  -	      .byte	$62+6
     15  02f5					      ENDIF
     16  02f5				  -	      IF	$10 = $50
     17  02f5				  -	      .byte	$82+6
     18  02f5					      ENDIF
     19  02f5				  -	      IF	$10 = $60
     20  02f5				  -	      .byte	$C2+6
     21  02f5					      ENDIF
     22  02f5				  -	      IF	$10 = $70
     23  02f5				  -	      .byte	$D2+6
     24  02f5					      ENDIF
     25  02f5				  -	      IF	$10 = $80
     26  02f5				  -	      .byte	$B2+6
     27  02f5					      ENDIF
     28  02f5				  -	      IF	$10 = $90
     29  02f5				  -	      .byte	$92+6
     30  02f5					      ENDIF
     31  02f5				  -	      IF	$10 = $A0
     32  02f5				  -	      .byte	$72+6
     33  02f5					      ENDIF
     34  02f5				  -	      IF	$10 = $B0
     35  02f5				  -	      .byte	$52+6
     36  02f5					      ENDIF
     37  02f5				  -	      IF	$10 = $C0
     38  02f5				  -	      .byte	$32+6
     39  02f5					      ENDIF
     40  02f5				  -	      IF	$10 = $D0
     41  02f5				  -	      .byte	$32+6
     42  02f5					      ENDIF
     43  02f5				  -	      IF	$10 = $E0
     44  02f5				  -	      .byte	$22+6
     45  02f5					      ENDIF
     46  02f5				  -	      IF	$10 = $F0
     47  02f5				  -	      .byte	$42+6
     48  02f5					      ENDIF
     19  02f5		       00		      .byte.b	0
      0  02f6					      COLOUR_GROUP	$10,$A, $F0,$8, $60,$C, $50,$4, $70,6, $40,6	; 1
      1  02f6
      2  02f6		       00		      .byte.b	0
      3  02f7		       1a		      .byte.b	$10+$A
      4  02f8		       f8		      .byte.b	$F0+$8
      5  02f9		       6c		      .byte.b	$60+$C
      6  02fa		       54		      .byte.b	$50+$4
      7  02fb		       76		      .byte.b	$70+6
      8  02fc		       46		      .byte.b	$40+6
      9  02fd		       00		      .byte.b	0
     10  02fe
     11  02fe
     12  02fe		       00		      .byte.b	0
      0  02ff					      NTSC_TO_PAL	$10, $A
      1  02ff				  -	      IF	$10 = 0
      2  02ff				  -	      .byte	$10+$A
      3  02ff					      ENDIF
      4  02ff					      IF	$10 = $10
      5  02ff		       2c		      .byte.b	$22+$A
      6  0300					      ENDIF
      7  0300				  -	      IF	$10 = $20
      8  0300				  -	      .byte	$42+$A
      9  0300					      ENDIF
     10  0300				  -	      IF	$10 = $30
     11  0300				  -	      .byte	$42+$A
     12  0300					      ENDIF
     13  0300				  -	      IF	$10 = $40
     14  0300				  -	      .byte	$62+$A
     15  0300					      ENDIF
     16  0300				  -	      IF	$10 = $50
     17  0300				  -	      .byte	$82+$A
     18  0300					      ENDIF
     19  0300				  -	      IF	$10 = $60
     20  0300				  -	      .byte	$C2+$A
     21  0300					      ENDIF
     22  0300				  -	      IF	$10 = $70
     23  0300				  -	      .byte	$D2+$A
     24  0300					      ENDIF
     25  0300				  -	      IF	$10 = $80
     26  0300				  -	      .byte	$B2+$A
     27  0300					      ENDIF
     28  0300				  -	      IF	$10 = $90
     29  0300				  -	      .byte	$92+$A
     30  0300					      ENDIF
     31  0300				  -	      IF	$10 = $A0
     32  0300				  -	      .byte	$72+$A
     33  0300					      ENDIF
     34  0300				  -	      IF	$10 = $B0
     35  0300				  -	      .byte	$52+$A
     36  0300					      ENDIF
     37  0300				  -	      IF	$10 = $C0
     38  0300				  -	      .byte	$32+$A
     39  0300					      ENDIF
     40  0300				  -	      IF	$10 = $D0
     41  0300				  -	      .byte	$32+$A
     42  0300					      ENDIF
     43  0300				  -	      IF	$10 = $E0
     44  0300				  -	      .byte	$22+$A
     45  0300					      ENDIF
     46  0300				  -	      IF	$10 = $F0
     47  0300				  -	      .byte	$42+$A
     48  0300					      ENDIF
      0  0300					      NTSC_TO_PAL	$F0, $8
      1  0300				  -	      IF	$F0 = 0
      2  0300				  -	      .byte	$F0+$8
      3  0300					      ENDIF
      4  0300				  -	      IF	$F0 = $10
      5  0300				  -	      .byte	$22+$8
      6  0300					      ENDIF
      7  0300				  -	      IF	$F0 = $20
      8  0300				  -	      .byte	$42+$8
      9  0300					      ENDIF
     10  0300				  -	      IF	$F0 = $30
     11  0300				  -	      .byte	$42+$8
     12  0300					      ENDIF
     13  0300				  -	      IF	$F0 = $40
     14  0300				  -	      .byte	$62+$8
     15  0300					      ENDIF
     16  0300				  -	      IF	$F0 = $50
     17  0300				  -	      .byte	$82+$8
     18  0300					      ENDIF
     19  0300				  -	      IF	$F0 = $60
     20  0300				  -	      .byte	$C2+$8
     21  0300					      ENDIF
     22  0300				  -	      IF	$F0 = $70
     23  0300				  -	      .byte	$D2+$8
     24  0300					      ENDIF
     25  0300				  -	      IF	$F0 = $80
     26  0300				  -	      .byte	$B2+$8
     27  0300					      ENDIF
     28  0300				  -	      IF	$F0 = $90
     29  0300				  -	      .byte	$92+$8
     30  0300					      ENDIF
     31  0300				  -	      IF	$F0 = $A0
     32  0300				  -	      .byte	$72+$8
     33  0300					      ENDIF
     34  0300				  -	      IF	$F0 = $B0
     35  0300				  -	      .byte	$52+$8
     36  0300					      ENDIF
     37  0300				  -	      IF	$F0 = $C0
     38  0300				  -	      .byte	$32+$8
     39  0300					      ENDIF
     40  0300				  -	      IF	$F0 = $D0
     41  0300				  -	      .byte	$32+$8
     42  0300					      ENDIF
     43  0300				  -	      IF	$F0 = $E0
     44  0300				  -	      .byte	$22+$8
     45  0300					      ENDIF
     46  0300					      IF	$F0 = $F0
     47  0300		       4a		      .byte.b	$42+$8
     48  0301					      ENDIF
      0  0301					      NTSC_TO_PAL	$60, $C
      1  0301				  -	      IF	$60 = 0
      2  0301				  -	      .byte	$60+$C
      3  0301					      ENDIF
      4  0301				  -	      IF	$60 = $10
      5  0301				  -	      .byte	$22+$C
      6  0301					      ENDIF
      7  0301				  -	      IF	$60 = $20
      8  0301				  -	      .byte	$42+$C
      9  0301					      ENDIF
     10  0301				  -	      IF	$60 = $30
     11  0301				  -	      .byte	$42+$C
     12  0301					      ENDIF
     13  0301				  -	      IF	$60 = $40
     14  0301				  -	      .byte	$62+$C
     15  0301					      ENDIF
     16  0301				  -	      IF	$60 = $50
     17  0301				  -	      .byte	$82+$C
     18  0301					      ENDIF
     19  0301					      IF	$60 = $60
     20  0301		       ce		      .byte.b	$C2+$C
     21  0302					      ENDIF
     22  0302				  -	      IF	$60 = $70
     23  0302				  -	      .byte	$D2+$C
     24  0302					      ENDIF
     25  0302				  -	      IF	$60 = $80
     26  0302				  -	      .byte	$B2+$C
     27  0302					      ENDIF
     28  0302				  -	      IF	$60 = $90
     29  0302				  -	      .byte	$92+$C
     30  0302					      ENDIF
     31  0302				  -	      IF	$60 = $A0
     32  0302				  -	      .byte	$72+$C
     33  0302					      ENDIF
     34  0302				  -	      IF	$60 = $B0
     35  0302				  -	      .byte	$52+$C
     36  0302					      ENDIF
     37  0302				  -	      IF	$60 = $C0
     38  0302				  -	      .byte	$32+$C
     39  0302					      ENDIF
     40  0302				  -	      IF	$60 = $D0
     41  0302				  -	      .byte	$32+$C
     42  0302					      ENDIF
     43  0302				  -	      IF	$60 = $E0
     44  0302				  -	      .byte	$22+$C
     45  0302					      ENDIF
     46  0302				  -	      IF	$60 = $F0
     47  0302				  -	      .byte	$42+$C
     48  0302					      ENDIF
      0  0302					      NTSC_TO_PAL	$50, $4
      1  0302				  -	      IF	$50 = 0
      2  0302				  -	      .byte	$50+$4
      3  0302					      ENDIF
      4  0302				  -	      IF	$50 = $10
      5  0302				  -	      .byte	$22+$4
      6  0302					      ENDIF
      7  0302				  -	      IF	$50 = $20
      8  0302				  -	      .byte	$42+$4
      9  0302					      ENDIF
     10  0302				  -	      IF	$50 = $30
     11  0302				  -	      .byte	$42+$4
     12  0302					      ENDIF
     13  0302				  -	      IF	$50 = $40
     14  0302				  -	      .byte	$62+$4
     15  0302					      ENDIF
     16  0302					      IF	$50 = $50
     17  0302		       86		      .byte.b	$82+$4
     18  0303					      ENDIF
     19  0303				  -	      IF	$50 = $60
     20  0303				  -	      .byte	$C2+$4
     21  0303					      ENDIF
     22  0303				  -	      IF	$50 = $70
     23  0303				  -	      .byte	$D2+$4
     24  0303					      ENDIF
     25  0303				  -	      IF	$50 = $80
     26  0303				  -	      .byte	$B2+$4
     27  0303					      ENDIF
     28  0303				  -	      IF	$50 = $90
     29  0303				  -	      .byte	$92+$4
     30  0303					      ENDIF
     31  0303				  -	      IF	$50 = $A0
     32  0303				  -	      .byte	$72+$4
     33  0303					      ENDIF
     34  0303				  -	      IF	$50 = $B0
     35  0303				  -	      .byte	$52+$4
     36  0303					      ENDIF
     37  0303				  -	      IF	$50 = $C0
     38  0303				  -	      .byte	$32+$4
     39  0303					      ENDIF
     40  0303				  -	      IF	$50 = $D0
     41  0303				  -	      .byte	$32+$4
     42  0303					      ENDIF
     43  0303				  -	      IF	$50 = $E0
     44  0303				  -	      .byte	$22+$4
     45  0303					      ENDIF
     46  0303				  -	      IF	$50 = $F0
     47  0303				  -	      .byte	$42+$4
     48  0303					      ENDIF
      0  0303					      NTSC_TO_PAL	$70, 6
      1  0303				  -	      IF	$70 = 0
      2  0303				  -	      .byte	$70+6
      3  0303					      ENDIF
      4  0303				  -	      IF	$70 = $10
      5  0303				  -	      .byte	$22+6
      6  0303					      ENDIF
      7  0303				  -	      IF	$70 = $20
      8  0303				  -	      .byte	$42+6
      9  0303					      ENDIF
     10  0303				  -	      IF	$70 = $30
     11  0303				  -	      .byte	$42+6
     12  0303					      ENDIF
     13  0303				  -	      IF	$70 = $40
     14  0303				  -	      .byte	$62+6
     15  0303					      ENDIF
     16  0303				  -	      IF	$70 = $50
     17  0303				  -	      .byte	$82+6
     18  0303					      ENDIF
     19  0303				  -	      IF	$70 = $60
     20  0303				  -	      .byte	$C2+6
     21  0303					      ENDIF
     22  0303					      IF	$70 = $70
     23  0303		       d8		      .byte.b	$D2+6
     24  0304					      ENDIF
     25  0304				  -	      IF	$70 = $80
     26  0304				  -	      .byte	$B2+6
     27  0304					      ENDIF
     28  0304				  -	      IF	$70 = $90
     29  0304				  -	      .byte	$92+6
     30  0304					      ENDIF
     31  0304				  -	      IF	$70 = $A0
     32  0304				  -	      .byte	$72+6
     33  0304					      ENDIF
     34  0304				  -	      IF	$70 = $B0
     35  0304				  -	      .byte	$52+6
     36  0304					      ENDIF
     37  0304				  -	      IF	$70 = $C0
     38  0304				  -	      .byte	$32+6
     39  0304					      ENDIF
     40  0304				  -	      IF	$70 = $D0
     41  0304				  -	      .byte	$32+6
     42  0304					      ENDIF
     43  0304				  -	      IF	$70 = $E0
     44  0304				  -	      .byte	$22+6
     45  0304					      ENDIF
     46  0304				  -	      IF	$70 = $F0
     47  0304				  -	      .byte	$42+6
     48  0304					      ENDIF
      0  0304					      NTSC_TO_PAL	$40, 6
      1  0304				  -	      IF	$40 = 0
      2  0304				  -	      .byte	$40+6
      3  0304					      ENDIF
      4  0304				  -	      IF	$40 = $10
      5  0304				  -	      .byte	$22+6
      6  0304					      ENDIF
      7  0304				  -	      IF	$40 = $20
      8  0304				  -	      .byte	$42+6
      9  0304					      ENDIF
     10  0304				  -	      IF	$40 = $30
     11  0304				  -	      .byte	$42+6
     12  0304					      ENDIF
     13  0304					      IF	$40 = $40
     14  0304		       68		      .byte.b	$62+6
     15  0305					      ENDIF
     16  0305				  -	      IF	$40 = $50
     17  0305				  -	      .byte	$82+6
     18  0305					      ENDIF
     19  0305				  -	      IF	$40 = $60
     20  0305				  -	      .byte	$C2+6
     21  0305					      ENDIF
     22  0305				  -	      IF	$40 = $70
     23  0305				  -	      .byte	$D2+6
     24  0305					      ENDIF
     25  0305				  -	      IF	$40 = $80
     26  0305				  -	      .byte	$B2+6
     27  0305					      ENDIF
     28  0305				  -	      IF	$40 = $90
     29  0305				  -	      .byte	$92+6
     30  0305					      ENDIF
     31  0305				  -	      IF	$40 = $A0
     32  0305				  -	      .byte	$72+6
     33  0305					      ENDIF
     34  0305				  -	      IF	$40 = $B0
     35  0305				  -	      .byte	$52+6
     36  0305					      ENDIF
     37  0305				  -	      IF	$40 = $C0
     38  0305				  -	      .byte	$32+6
     39  0305					      ENDIF
     40  0305				  -	      IF	$40 = $D0
     41  0305				  -	      .byte	$32+6
     42  0305					      ENDIF
     43  0305				  -	      IF	$40 = $E0
     44  0305				  -	      .byte	$22+6
     45  0305					      ENDIF
     46  0305				  -	      IF	$40 = $F0
     47  0305				  -	      .byte	$42+6
     48  0305					      ENDIF
     19  0305		       00		      .byte.b	0
      0  0306					      COLOUR_GROUP	$40,$6, $E0,$8, $00,$C, $C0,$4, $90,6, $20,6	; 2
      1  0306
      2  0306		       00		      .byte.b	0
      3  0307		       46		      .byte.b	$40+$6
      4  0308		       e8		      .byte.b	$E0+$8
      5  0309		       0c		      .byte.b	$00+$C
      6  030a		       c4		      .byte.b	$C0+$4
      7  030b		       96		      .byte.b	$90+6
      8  030c		       26		      .byte.b	$20+6
      9  030d		       00		      .byte.b	0
     10  030e
     11  030e
     12  030e		       00		      .byte.b	0
      0  030f					      NTSC_TO_PAL	$40, $6
      1  030f				  -	      IF	$40 = 0
      2  030f				  -	      .byte	$40+$6
      3  030f					      ENDIF
      4  030f				  -	      IF	$40 = $10
      5  030f				  -	      .byte	$22+$6
      6  030f					      ENDIF
      7  030f				  -	      IF	$40 = $20
      8  030f				  -	      .byte	$42+$6
      9  030f					      ENDIF
     10  030f				  -	      IF	$40 = $30
     11  030f				  -	      .byte	$42+$6
     12  030f					      ENDIF
     13  030f					      IF	$40 = $40
     14  030f		       68		      .byte.b	$62+$6
     15  0310					      ENDIF
     16  0310				  -	      IF	$40 = $50
     17  0310				  -	      .byte	$82+$6
     18  0310					      ENDIF
     19  0310				  -	      IF	$40 = $60
     20  0310				  -	      .byte	$C2+$6
     21  0310					      ENDIF
     22  0310				  -	      IF	$40 = $70
     23  0310				  -	      .byte	$D2+$6
     24  0310					      ENDIF
     25  0310				  -	      IF	$40 = $80
     26  0310				  -	      .byte	$B2+$6
     27  0310					      ENDIF
     28  0310				  -	      IF	$40 = $90
     29  0310				  -	      .byte	$92+$6
     30  0310					      ENDIF
     31  0310				  -	      IF	$40 = $A0
     32  0310				  -	      .byte	$72+$6
     33  0310					      ENDIF
     34  0310				  -	      IF	$40 = $B0
     35  0310				  -	      .byte	$52+$6
     36  0310					      ENDIF
     37  0310				  -	      IF	$40 = $C0
     38  0310				  -	      .byte	$32+$6
     39  0310					      ENDIF
     40  0310				  -	      IF	$40 = $D0
     41  0310				  -	      .byte	$32+$6
     42  0310					      ENDIF
     43  0310				  -	      IF	$40 = $E0
     44  0310				  -	      .byte	$22+$6
     45  0310					      ENDIF
     46  0310				  -	      IF	$40 = $F0
     47  0310				  -	      .byte	$42+$6
     48  0310					      ENDIF
      0  0310					      NTSC_TO_PAL	$E0, $8
      1  0310				  -	      IF	$E0 = 0
      2  0310				  -	      .byte	$E0+$8
      3  0310					      ENDIF
      4  0310				  -	      IF	$E0 = $10
      5  0310				  -	      .byte	$22+$8
      6  0310					      ENDIF
      7  0310				  -	      IF	$E0 = $20
      8  0310				  -	      .byte	$42+$8
      9  0310					      ENDIF
     10  0310				  -	      IF	$E0 = $30
     11  0310				  -	      .byte	$42+$8
     12  0310					      ENDIF
     13  0310				  -	      IF	$E0 = $40
     14  0310				  -	      .byte	$62+$8
     15  0310					      ENDIF
     16  0310				  -	      IF	$E0 = $50
     17  0310				  -	      .byte	$82+$8
     18  0310					      ENDIF
     19  0310				  -	      IF	$E0 = $60
     20  0310				  -	      .byte	$C2+$8
     21  0310					      ENDIF
     22  0310				  -	      IF	$E0 = $70
     23  0310				  -	      .byte	$D2+$8
     24  0310					      ENDIF
     25  0310				  -	      IF	$E0 = $80
     26  0310				  -	      .byte	$B2+$8
     27  0310					      ENDIF
     28  0310				  -	      IF	$E0 = $90
     29  0310				  -	      .byte	$92+$8
     30  0310					      ENDIF
     31  0310				  -	      IF	$E0 = $A0
     32  0310				  -	      .byte	$72+$8
     33  0310					      ENDIF
     34  0310				  -	      IF	$E0 = $B0
     35  0310				  -	      .byte	$52+$8
     36  0310					      ENDIF
     37  0310				  -	      IF	$E0 = $C0
     38  0310				  -	      .byte	$32+$8
     39  0310					      ENDIF
     40  0310				  -	      IF	$E0 = $D0
     41  0310				  -	      .byte	$32+$8
     42  0310					      ENDIF
     43  0310					      IF	$E0 = $E0
     44  0310		       2a		      .byte.b	$22+$8
     45  0311					      ENDIF
     46  0311				  -	      IF	$E0 = $F0
     47  0311				  -	      .byte	$42+$8
     48  0311					      ENDIF
      0  0311					      NTSC_TO_PAL	$00, $C
      1  0311					      IF	$00 = 0
      2  0311		       0c		      .byte.b	$00+$C
      3  0312					      ENDIF
      4  0312				  -	      IF	$00 = $10
      5  0312				  -	      .byte	$22+$C
      6  0312					      ENDIF
      7  0312				  -	      IF	$00 = $20
      8  0312				  -	      .byte	$42+$C
      9  0312					      ENDIF
     10  0312				  -	      IF	$00 = $30
     11  0312				  -	      .byte	$42+$C
     12  0312					      ENDIF
     13  0312				  -	      IF	$00 = $40
     14  0312				  -	      .byte	$62+$C
     15  0312					      ENDIF
     16  0312				  -	      IF	$00 = $50
     17  0312				  -	      .byte	$82+$C
     18  0312					      ENDIF
     19  0312				  -	      IF	$00 = $60
     20  0312				  -	      .byte	$C2+$C
     21  0312					      ENDIF
     22  0312				  -	      IF	$00 = $70
     23  0312				  -	      .byte	$D2+$C
     24  0312					      ENDIF
     25  0312				  -	      IF	$00 = $80
     26  0312				  -	      .byte	$B2+$C
     27  0312					      ENDIF
     28  0312				  -	      IF	$00 = $90
     29  0312				  -	      .byte	$92+$C
     30  0312					      ENDIF
     31  0312				  -	      IF	$00 = $A0
     32  0312				  -	      .byte	$72+$C
     33  0312					      ENDIF
     34  0312				  -	      IF	$00 = $B0
     35  0312				  -	      .byte	$52+$C
     36  0312					      ENDIF
     37  0312				  -	      IF	$00 = $C0
     38  0312				  -	      .byte	$32+$C
     39  0312					      ENDIF
     40  0312				  -	      IF	$00 = $D0
     41  0312				  -	      .byte	$32+$C
     42  0312					      ENDIF
     43  0312				  -	      IF	$00 = $E0
     44  0312				  -	      .byte	$22+$C
     45  0312					      ENDIF
     46  0312				  -	      IF	$00 = $F0
     47  0312				  -	      .byte	$42+$C
     48  0312					      ENDIF
      0  0312					      NTSC_TO_PAL	$C0, $4
      1  0312				  -	      IF	$C0 = 0
      2  0312				  -	      .byte	$C0+$4
      3  0312					      ENDIF
      4  0312				  -	      IF	$C0 = $10
      5  0312				  -	      .byte	$22+$4
      6  0312					      ENDIF
      7  0312				  -	      IF	$C0 = $20
      8  0312				  -	      .byte	$42+$4
      9  0312					      ENDIF
     10  0312				  -	      IF	$C0 = $30
     11  0312				  -	      .byte	$42+$4
     12  0312					      ENDIF
     13  0312				  -	      IF	$C0 = $40
     14  0312				  -	      .byte	$62+$4
     15  0312					      ENDIF
     16  0312				  -	      IF	$C0 = $50
     17  0312				  -	      .byte	$82+$4
     18  0312					      ENDIF
     19  0312				  -	      IF	$C0 = $60
     20  0312				  -	      .byte	$C2+$4
     21  0312					      ENDIF
     22  0312				  -	      IF	$C0 = $70
     23  0312				  -	      .byte	$D2+$4
     24  0312					      ENDIF
     25  0312				  -	      IF	$C0 = $80
     26  0312				  -	      .byte	$B2+$4
     27  0312					      ENDIF
     28  0312				  -	      IF	$C0 = $90
     29  0312				  -	      .byte	$92+$4
     30  0312					      ENDIF
     31  0312				  -	      IF	$C0 = $A0
     32  0312				  -	      .byte	$72+$4
     33  0312					      ENDIF
     34  0312				  -	      IF	$C0 = $B0
     35  0312				  -	      .byte	$52+$4
     36  0312					      ENDIF
     37  0312					      IF	$C0 = $C0
     38  0312		       36		      .byte.b	$32+$4
     39  0313					      ENDIF
     40  0313				  -	      IF	$C0 = $D0
     41  0313				  -	      .byte	$32+$4
     42  0313					      ENDIF
     43  0313				  -	      IF	$C0 = $E0
     44  0313				  -	      .byte	$22+$4
     45  0313					      ENDIF
     46  0313				  -	      IF	$C0 = $F0
     47  0313				  -	      .byte	$42+$4
     48  0313					      ENDIF
      0  0313					      NTSC_TO_PAL	$90, 6
      1  0313				  -	      IF	$90 = 0
      2  0313				  -	      .byte	$90+6
      3  0313					      ENDIF
      4  0313				  -	      IF	$90 = $10
      5  0313				  -	      .byte	$22+6
      6  0313					      ENDIF
      7  0313				  -	      IF	$90 = $20
      8  0313				  -	      .byte	$42+6
      9  0313					      ENDIF
     10  0313				  -	      IF	$90 = $30
     11  0313				  -	      .byte	$42+6
     12  0313					      ENDIF
     13  0313				  -	      IF	$90 = $40
     14  0313				  -	      .byte	$62+6
     15  0313					      ENDIF
     16  0313				  -	      IF	$90 = $50
     17  0313				  -	      .byte	$82+6
     18  0313					      ENDIF
     19  0313				  -	      IF	$90 = $60
     20  0313				  -	      .byte	$C2+6
     21  0313					      ENDIF
     22  0313				  -	      IF	$90 = $70
     23  0313				  -	      .byte	$D2+6
     24  0313					      ENDIF
     25  0313				  -	      IF	$90 = $80
     26  0313				  -	      .byte	$B2+6
     27  0313					      ENDIF
     28  0313					      IF	$90 = $90
     29  0313		       98		      .byte.b	$92+6
     30  0314					      ENDIF
     31  0314				  -	      IF	$90 = $A0
     32  0314				  -	      .byte	$72+6
     33  0314					      ENDIF
     34  0314				  -	      IF	$90 = $B0
     35  0314				  -	      .byte	$52+6
     36  0314					      ENDIF
     37  0314				  -	      IF	$90 = $C0
     38  0314				  -	      .byte	$32+6
     39  0314					      ENDIF
     40  0314				  -	      IF	$90 = $D0
     41  0314				  -	      .byte	$32+6
     42  0314					      ENDIF
     43  0314				  -	      IF	$90 = $E0
     44  0314				  -	      .byte	$22+6
     45  0314					      ENDIF
     46  0314				  -	      IF	$90 = $F0
     47  0314				  -	      .byte	$42+6
     48  0314					      ENDIF
      0  0314					      NTSC_TO_PAL	$20, 6
      1  0314				  -	      IF	$20 = 0
      2  0314				  -	      .byte	$20+6
      3  0314					      ENDIF
      4  0314				  -	      IF	$20 = $10
      5  0314				  -	      .byte	$22+6
      6  0314					      ENDIF
      7  0314					      IF	$20 = $20
      8  0314		       48		      .byte.b	$42+6
      9  0315					      ENDIF
     10  0315				  -	      IF	$20 = $30
     11  0315				  -	      .byte	$42+6
     12  0315					      ENDIF
     13  0315				  -	      IF	$20 = $40
     14  0315				  -	      .byte	$62+6
     15  0315					      ENDIF
     16  0315				  -	      IF	$20 = $50
     17  0315				  -	      .byte	$82+6
     18  0315					      ENDIF
     19  0315				  -	      IF	$20 = $60
     20  0315				  -	      .byte	$C2+6
     21  0315					      ENDIF
     22  0315				  -	      IF	$20 = $70
     23  0315				  -	      .byte	$D2+6
     24  0315					      ENDIF
     25  0315				  -	      IF	$20 = $80
     26  0315				  -	      .byte	$B2+6
     27  0315					      ENDIF
     28  0315				  -	      IF	$20 = $90
     29  0315				  -	      .byte	$92+6
     30  0315					      ENDIF
     31  0315				  -	      IF	$20 = $A0
     32  0315				  -	      .byte	$72+6
     33  0315					      ENDIF
     34  0315				  -	      IF	$20 = $B0
     35  0315				  -	      .byte	$52+6
     36  0315					      ENDIF
     37  0315				  -	      IF	$20 = $C0
     38  0315				  -	      .byte	$32+6
     39  0315					      ENDIF
     40  0315				  -	      IF	$20 = $D0
     41  0315				  -	      .byte	$32+6
     42  0315					      ENDIF
     43  0315				  -	      IF	$20 = $E0
     44  0315				  -	      .byte	$22+6
     45  0315					      ENDIF
     46  0315				  -	      IF	$20 = $F0
     47  0315				  -	      .byte	$42+6
     48  0315					      ENDIF
     19  0315		       00		      .byte.b	0
      0  0316					      COLOUR_GROUP	$30,$A, $50,$8, $10,$C, $40,$4, $60,6, $50,8	; 3
      1  0316
      2  0316		       00		      .byte.b	0
      3  0317		       3a		      .byte.b	$30+$A
      4  0318		       58		      .byte.b	$50+$8
      5  0319		       1c		      .byte.b	$10+$C
      6  031a		       44		      .byte.b	$40+$4
      7  031b		       66		      .byte.b	$60+6
      8  031c		       58		      .byte.b	$50+8
      9  031d		       00		      .byte.b	0
     10  031e
     11  031e
     12  031e		       00		      .byte.b	0
      0  031f					      NTSC_TO_PAL	$30, $A
      1  031f				  -	      IF	$30 = 0
      2  031f				  -	      .byte	$30+$A
      3  031f					      ENDIF
      4  031f				  -	      IF	$30 = $10
      5  031f				  -	      .byte	$22+$A
      6  031f					      ENDIF
      7  031f				  -	      IF	$30 = $20
      8  031f				  -	      .byte	$42+$A
      9  031f					      ENDIF
     10  031f					      IF	$30 = $30
     11  031f		       4c		      .byte.b	$42+$A
     12  0320					      ENDIF
     13  0320				  -	      IF	$30 = $40
     14  0320				  -	      .byte	$62+$A
     15  0320					      ENDIF
     16  0320				  -	      IF	$30 = $50
     17  0320				  -	      .byte	$82+$A
     18  0320					      ENDIF
     19  0320				  -	      IF	$30 = $60
     20  0320				  -	      .byte	$C2+$A
     21  0320					      ENDIF
     22  0320				  -	      IF	$30 = $70
     23  0320				  -	      .byte	$D2+$A
     24  0320					      ENDIF
     25  0320				  -	      IF	$30 = $80
     26  0320				  -	      .byte	$B2+$A
     27  0320					      ENDIF
     28  0320				  -	      IF	$30 = $90
     29  0320				  -	      .byte	$92+$A
     30  0320					      ENDIF
     31  0320				  -	      IF	$30 = $A0
     32  0320				  -	      .byte	$72+$A
     33  0320					      ENDIF
     34  0320				  -	      IF	$30 = $B0
     35  0320				  -	      .byte	$52+$A
     36  0320					      ENDIF
     37  0320				  -	      IF	$30 = $C0
     38  0320				  -	      .byte	$32+$A
     39  0320					      ENDIF
     40  0320				  -	      IF	$30 = $D0
     41  0320				  -	      .byte	$32+$A
     42  0320					      ENDIF
     43  0320				  -	      IF	$30 = $E0
     44  0320				  -	      .byte	$22+$A
     45  0320					      ENDIF
     46  0320				  -	      IF	$30 = $F0
     47  0320				  -	      .byte	$42+$A
     48  0320					      ENDIF
      0  0320					      NTSC_TO_PAL	$50, $8
      1  0320				  -	      IF	$50 = 0
      2  0320				  -	      .byte	$50+$8
      3  0320					      ENDIF
      4  0320				  -	      IF	$50 = $10
      5  0320				  -	      .byte	$22+$8
      6  0320					      ENDIF
      7  0320				  -	      IF	$50 = $20
      8  0320				  -	      .byte	$42+$8
      9  0320					      ENDIF
     10  0320				  -	      IF	$50 = $30
     11  0320				  -	      .byte	$42+$8
     12  0320					      ENDIF
     13  0320				  -	      IF	$50 = $40
     14  0320				  -	      .byte	$62+$8
     15  0320					      ENDIF
     16  0320					      IF	$50 = $50
     17  0320		       8a		      .byte.b	$82+$8
     18  0321					      ENDIF
     19  0321				  -	      IF	$50 = $60
     20  0321				  -	      .byte	$C2+$8
     21  0321					      ENDIF
     22  0321				  -	      IF	$50 = $70
     23  0321				  -	      .byte	$D2+$8
     24  0321					      ENDIF
     25  0321				  -	      IF	$50 = $80
     26  0321				  -	      .byte	$B2+$8
     27  0321					      ENDIF
     28  0321				  -	      IF	$50 = $90
     29  0321				  -	      .byte	$92+$8
     30  0321					      ENDIF
     31  0321				  -	      IF	$50 = $A0
     32  0321				  -	      .byte	$72+$8
     33  0321					      ENDIF
     34  0321				  -	      IF	$50 = $B0
     35  0321				  -	      .byte	$52+$8
     36  0321					      ENDIF
     37  0321				  -	      IF	$50 = $C0
     38  0321				  -	      .byte	$32+$8
     39  0321					      ENDIF
     40  0321				  -	      IF	$50 = $D0
     41  0321				  -	      .byte	$32+$8
     42  0321					      ENDIF
     43  0321				  -	      IF	$50 = $E0
     44  0321				  -	      .byte	$22+$8
     45  0321					      ENDIF
     46  0321				  -	      IF	$50 = $F0
     47  0321				  -	      .byte	$42+$8
     48  0321					      ENDIF
      0  0321					      NTSC_TO_PAL	$10, $C
      1  0321				  -	      IF	$10 = 0
      2  0321				  -	      .byte	$10+$C
      3  0321					      ENDIF
      4  0321					      IF	$10 = $10
      5  0321		       2e		      .byte.b	$22+$C
      6  0322					      ENDIF
      7  0322				  -	      IF	$10 = $20
      8  0322				  -	      .byte	$42+$C
      9  0322					      ENDIF
     10  0322				  -	      IF	$10 = $30
     11  0322				  -	      .byte	$42+$C
     12  0322					      ENDIF
     13  0322				  -	      IF	$10 = $40
     14  0322				  -	      .byte	$62+$C
     15  0322					      ENDIF
     16  0322				  -	      IF	$10 = $50
     17  0322				  -	      .byte	$82+$C
     18  0322					      ENDIF
     19  0322				  -	      IF	$10 = $60
     20  0322				  -	      .byte	$C2+$C
     21  0322					      ENDIF
     22  0322				  -	      IF	$10 = $70
     23  0322				  -	      .byte	$D2+$C
     24  0322					      ENDIF
     25  0322				  -	      IF	$10 = $80
     26  0322				  -	      .byte	$B2+$C
     27  0322					      ENDIF
     28  0322				  -	      IF	$10 = $90
     29  0322				  -	      .byte	$92+$C
     30  0322					      ENDIF
     31  0322				  -	      IF	$10 = $A0
     32  0322				  -	      .byte	$72+$C
     33  0322					      ENDIF
     34  0322				  -	      IF	$10 = $B0
     35  0322				  -	      .byte	$52+$C
     36  0322					      ENDIF
     37  0322				  -	      IF	$10 = $C0
     38  0322				  -	      .byte	$32+$C
     39  0322					      ENDIF
     40  0322				  -	      IF	$10 = $D0
     41  0322				  -	      .byte	$32+$C
     42  0322					      ENDIF
     43  0322				  -	      IF	$10 = $E0
     44  0322				  -	      .byte	$22+$C
     45  0322					      ENDIF
     46  0322				  -	      IF	$10 = $F0
     47  0322				  -	      .byte	$42+$C
     48  0322					      ENDIF
      0  0322					      NTSC_TO_PAL	$40, $4
      1  0322				  -	      IF	$40 = 0
      2  0322				  -	      .byte	$40+$4
      3  0322					      ENDIF
      4  0322				  -	      IF	$40 = $10
      5  0322				  -	      .byte	$22+$4
      6  0322					      ENDIF
      7  0322				  -	      IF	$40 = $20
      8  0322				  -	      .byte	$42+$4
      9  0322					      ENDIF
     10  0322				  -	      IF	$40 = $30
     11  0322				  -	      .byte	$42+$4
     12  0322					      ENDIF
     13  0322					      IF	$40 = $40
     14  0322		       66		      .byte.b	$62+$4
     15  0323					      ENDIF
     16  0323				  -	      IF	$40 = $50
     17  0323				  -	      .byte	$82+$4
     18  0323					      ENDIF
     19  0323				  -	      IF	$40 = $60
     20  0323				  -	      .byte	$C2+$4
     21  0323					      ENDIF
     22  0323				  -	      IF	$40 = $70
     23  0323				  -	      .byte	$D2+$4
     24  0323					      ENDIF
     25  0323				  -	      IF	$40 = $80
     26  0323				  -	      .byte	$B2+$4
     27  0323					      ENDIF
     28  0323				  -	      IF	$40 = $90
     29  0323				  -	      .byte	$92+$4
     30  0323					      ENDIF
     31  0323				  -	      IF	$40 = $A0
     32  0323				  -	      .byte	$72+$4
     33  0323					      ENDIF
     34  0323				  -	      IF	$40 = $B0
     35  0323				  -	      .byte	$52+$4
     36  0323					      ENDIF
     37  0323				  -	      IF	$40 = $C0
     38  0323				  -	      .byte	$32+$4
     39  0323					      ENDIF
     40  0323				  -	      IF	$40 = $D0
     41  0323				  -	      .byte	$32+$4
     42  0323					      ENDIF
     43  0323				  -	      IF	$40 = $E0
     44  0323				  -	      .byte	$22+$4
     45  0323					      ENDIF
     46  0323				  -	      IF	$40 = $F0
     47  0323				  -	      .byte	$42+$4
     48  0323					      ENDIF
      0  0323					      NTSC_TO_PAL	$60, 6
      1  0323				  -	      IF	$60 = 0
      2  0323				  -	      .byte	$60+6
      3  0323					      ENDIF
      4  0323				  -	      IF	$60 = $10
      5  0323				  -	      .byte	$22+6
      6  0323					      ENDIF
      7  0323				  -	      IF	$60 = $20
      8  0323				  -	      .byte	$42+6
      9  0323					      ENDIF
     10  0323				  -	      IF	$60 = $30
     11  0323				  -	      .byte	$42+6
     12  0323					      ENDIF
     13  0323				  -	      IF	$60 = $40
     14  0323				  -	      .byte	$62+6
     15  0323					      ENDIF
     16  0323				  -	      IF	$60 = $50
     17  0323				  -	      .byte	$82+6
     18  0323					      ENDIF
     19  0323					      IF	$60 = $60
     20  0323		       c8		      .byte.b	$C2+6
     21  0324					      ENDIF
     22  0324				  -	      IF	$60 = $70
     23  0324				  -	      .byte	$D2+6
     24  0324					      ENDIF
     25  0324				  -	      IF	$60 = $80
     26  0324				  -	      .byte	$B2+6
     27  0324					      ENDIF
     28  0324				  -	      IF	$60 = $90
     29  0324				  -	      .byte	$92+6
     30  0324					      ENDIF
     31  0324				  -	      IF	$60 = $A0
     32  0324				  -	      .byte	$72+6
     33  0324					      ENDIF
     34  0324				  -	      IF	$60 = $B0
     35  0324				  -	      .byte	$52+6
     36  0324					      ENDIF
     37  0324				  -	      IF	$60 = $C0
     38  0324				  -	      .byte	$32+6
     39  0324					      ENDIF
     40  0324				  -	      IF	$60 = $D0
     41  0324				  -	      .byte	$32+6
     42  0324					      ENDIF
     43  0324				  -	      IF	$60 = $E0
     44  0324				  -	      .byte	$22+6
     45  0324					      ENDIF
     46  0324				  -	      IF	$60 = $F0
     47  0324				  -	      .byte	$42+6
     48  0324					      ENDIF
      0  0324					      NTSC_TO_PAL	$50, 8
      1  0324				  -	      IF	$50 = 0
      2  0324				  -	      .byte	$50+8
      3  0324					      ENDIF
      4  0324				  -	      IF	$50 = $10
      5  0324				  -	      .byte	$22+8
      6  0324					      ENDIF
      7  0324				  -	      IF	$50 = $20
      8  0324				  -	      .byte	$42+8
      9  0324					      ENDIF
     10  0324				  -	      IF	$50 = $30
     11  0324				  -	      .byte	$42+8
     12  0324					      ENDIF
     13  0324				  -	      IF	$50 = $40
     14  0324				  -	      .byte	$62+8
     15  0324					      ENDIF
     16  0324					      IF	$50 = $50
     17  0324		       8a		      .byte.b	$82+8
     18  0325					      ENDIF
     19  0325				  -	      IF	$50 = $60
     20  0325				  -	      .byte	$C2+8
     21  0325					      ENDIF
     22  0325				  -	      IF	$50 = $70
     23  0325				  -	      .byte	$D2+8
     24  0325					      ENDIF
     25  0325				  -	      IF	$50 = $80
     26  0325				  -	      .byte	$B2+8
     27  0325					      ENDIF
     28  0325				  -	      IF	$50 = $90
     29  0325				  -	      .byte	$92+8
     30  0325					      ENDIF
     31  0325				  -	      IF	$50 = $A0
     32  0325				  -	      .byte	$72+8
     33  0325					      ENDIF
     34  0325				  -	      IF	$50 = $B0
     35  0325				  -	      .byte	$52+8
     36  0325					      ENDIF
     37  0325				  -	      IF	$50 = $C0
     38  0325				  -	      .byte	$32+8
     39  0325					      ENDIF
     40  0325				  -	      IF	$50 = $D0
     41  0325				  -	      .byte	$32+8
     42  0325					      ENDIF
     43  0325				  -	      IF	$50 = $E0
     44  0325				  -	      .byte	$22+8
     45  0325					      ENDIF
     46  0325				  -	      IF	$50 = $F0
     47  0325				  -	      .byte	$42+8
     48  0325					      ENDIF
     19  0325		       00		      .byte.b	0
    624  0326
    625  0326							;------------------------------------------------------------------------------
    626  0326
    627  0326							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    628  0326
    629  0326							;------------------------------------------------------------------------------
    630  0326
    631  0326
    632  0326
    633  0326
    634  0326				   OBJTYPE    SET	0
    635  0326					      MAC	define_character
    636  0326				   CHARACTER_{1} =	OBJTYPE
    637  0326				   OBJTYPE    .SET	OBJTYPE + 1
    638  0326					      ENDM
    639  0326
    640  0326							; Modifications to character #/order must also ensure the following are correct...
    641  0326							;   CharacterDataVecLO/HI	   in this file
    642  0326							;   MoveVecLO/HI		   in BANK_INITBANK
    643  0326							;   CharReplacement		   in BANK_ROM_SHADOW_DRAWBUFFERS
    644  0326
      0  0326					      DEFINE_CHARACTER	BLANK
      1  0326		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	SOIL
      1  0326		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	BOX
      1  0326		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	TARGET
      1  0326		       00 03	   CHARACTER_TARGET =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	TARGET2
      1  0326		       00 04	   CHARACTER_TARGET2 =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	MANOCCUPIED
      1  0326		       00 05	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	STEEL
      1  0326		       00 06	   CHARACTER_STEEL =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	WALL
      1  0326		       00 07	   CHARACTER_WALL =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	BOX_ON_TARGET
      1  0326		       00 08	   CHARACTER_BOX_ON_TARGET =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	BOX_ON_TARGET2
      1  0326		       00 09	   CHARACTER_BOX_ON_TARGET2 =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	NOGO
      1  0326		       00 0a	   CHARACTER_NOGO =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	TARGET1
      1  0326		       00 0b	   CHARACTER_TARGET1 =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	TARGET3
      1  0326		       00 0c	   CHARACTER_TARGET3 =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	TARGET5
      1  0326		       00 0d	   CHARACTER_TARGET5 =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	TARGET7
      1  0326		       00 0e	   CHARACTER_TARGET7 =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
    660  0326
    661  0326				  -	      if	DIGITS
    662  0326				  -	      DEFINE_CHARACTER	0
    663  0326				  -	      DEFINE_CHARACTER	1
    664  0326				  -	      DEFINE_CHARACTER	2
    665  0326				  -	      DEFINE_CHARACTER	3
    666  0326				  -	      DEFINE_CHARACTER	4
    667  0326				  -	      DEFINE_CHARACTER	5
    668  0326				  -	      DEFINE_CHARACTER	6
    669  0326				  -	      DEFINE_CHARACTER	7
    670  0326				  -	      DEFINE_CHARACTER	8
    671  0326				  -	      DEFINE_CHARACTER	9
    672  0326					      endif
    673  0326
      0  0326					      DEFINE_CHARACTER	MAXIMUM
      1  0326		       00 0f	   CHARACTER_MAXIMUM =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
    675  0326
    676  0326
    677  0326				   CharacterDataVecLO
    678  0326
    679  0326							; Two entries per character.  2nd is ptr to mirrored character
    680  0326							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
    681  0326
    682  0326		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    683  0327		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    684  0328		       18		      .byte.b	<CHARACTERSHAPE_SOIL
    685  0329		       18		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
    686  032a		       30		      .byte.b	<CHARACTERSHAPE_BOX
    687  032b		       48		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
    688  032c		       d7		      .byte.b	<CHARACTERSHAPE_TARGET
    689  032d		       00		      .byte.b	<CHARACTERSHAPE_TARGET_MIRRORED
    690  032e		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    691  032f		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    692  0330		       b6		      .byte.b	<CHARACTERSHAPE_BLANK	; man occupied
    693  0331		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    694  0332		       d8		      .byte.b	<CHARACTERSHAPE_STEEL
    695  0333		       00		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
    696  0334		       c0		      .byte.b	<CHARACTERSHAPE_WALL
    697  0335		       d8		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
    698  0336		       60		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET
    699  0337		       78		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    700  0338		       90		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET2
    701  0339		       a8		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED
    702  033a		       b6		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    703  033b		       b6		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    704  033c		       18		      .byte.b	<CHARACTERSHAPE_TARGET1
    705  033d		       30		      .byte.b	<CHARACTERSHAPE_TARGET1_MIRRORED
    706  033e		       48		      .byte.b	<CHARACTERSHAPE_TARGET3
    707  033f		       60		      .byte.b	<CHARACTERSHAPE_TARGET3_MIRRORED
    708  0340		       78		      .byte.b	<CHARACTERSHAPE_TARGET5
    709  0341		       90		      .byte.b	<CHARACTERSHAPE_TARGET5_MIRRORED
    710  0342		       a8		      .byte.b	<CHARACTERSHAPE_TARGET7
    711  0343		       c0		      .byte.b	<CHARACTERSHAPE_TARGET7_MIRRORED
    712  0344
    713  0344				  -	      if	DIGITS
    714  0344				  -	      .byte	<CHARACTERSHAPE_0, <CHARACTERSHAPE_0_MIRRORED
    715  0344				  -	      .byte	<CHARACTERSHAPE_1, <CHARACTERSHAPE_1_MIRRORED
    716  0344				  -	      .byte	<CHARACTERSHAPE_2, <CHARACTERSHAPE_2_MIRRORED
    717  0344				  -	      .byte	<CHARACTERSHAPE_3, <CHARACTERSHAPE_3_MIRRORED
    718  0344				  -	      .byte	<CHARACTERSHAPE_4, <CHARACTERSHAPE_4_MIRRORED
    719  0344				  -	      .byte	<CHARACTERSHAPE_5, <CHARACTERSHAPE_5_MIRRORED
    720  0344				  -	      .byte	<CHARACTERSHAPE_6, <CHARACTERSHAPE_6_MIRRORED
    721  0344				  -	      .byte	<CHARACTERSHAPE_7, <CHARACTERSHAPE_7_MIRRORED
    722  0344				  -	      .byte	<CHARACTERSHAPE_8, <CHARACTERSHAPE_8_MIRRORED
    723  0344				  -	      .byte	<CHARACTERSHAPE_9, <CHARACTERSHAPE_9_MIRRORED
    724  0344					      endif
    725  0344
    726  0344
    727  0344				  -	      IF	* - CharacterDataVecLO != CHARACTER_MAXIMUM*2
    728  0344				  -	      ECHO	"ERROR: Incorrect CharacterDataVecLO table!"
    729  0344				  -	      ERR
    730  0344					      ENDIF
    731  0344
    732  0344
    733  0344							;ds 20,0
    734  0344
    735  0344							;---------------------------------------------------------------------------
    736  0344
    737  0344				   CharacterDataVecHI
    738  0344
    739  0344		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    740  0345		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    741  0346		       fe		      .byte.b	>CHARACTERSHAPE_SOIL
    742  0347		       fe		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
    743  0348		       fe		      .byte.b	>CHARACTERSHAPE_BOX
    744  0349		       fe		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
    745  034a		       fc		      .byte.b	>CHARACTERSHAPE_TARGET
    746  034b		       fd		      .byte.b	>CHARACTERSHAPE_TARGET_MIRRORED
    747  034c		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    748  034d		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    749  034e		       f2		      .byte.b	>CHARACTERSHAPE_BLANK	; man occupied
    750  034f		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    751  0350		       fd		      .byte.b	>CHARACTERSHAPE_STEEL
    752  0351		       fe		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
    753  0352		       fe		      .byte.b	>CHARACTERSHAPE_WALL
    754  0353		       fe		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
    755  0354		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET
    756  0355		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    757  0356		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET2
    758  0357		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED
    759  0358		       f2		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    760  0359		       f2		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    761  035a		       fd		      .byte.b	>CHARACTERSHAPE_TARGET1
    762  035b		       fd		      .byte.b	>CHARACTERSHAPE_TARGET1_MIRRORED
    763  035c		       fd		      .byte.b	>CHARACTERSHAPE_TARGET3
    764  035d		       fd		      .byte.b	>CHARACTERSHAPE_TARGET3_MIRRORED
    765  035e		       fd		      .byte.b	>CHARACTERSHAPE_TARGET5
    766  035f		       fd		      .byte.b	>CHARACTERSHAPE_TARGET5_MIRRORED
    767  0360		       fd		      .byte.b	>CHARACTERSHAPE_TARGET7
    768  0361		       fd		      .byte.b	>CHARACTERSHAPE_TARGET7_MIRRORED
    769  0362
    770  0362				  -	      if	DIGITS
    771  0362				  -	      .byte	>CHARACTERSHAPE_0, >CHARACTERSHAPE_0_MIRRORED
    772  0362				  -	      .byte	>CHARACTERSHAPE_1, >CHARACTERSHAPE_1_MIRRORED
    773  0362				  -	      .byte	>CHARACTERSHAPE_2, >CHARACTERSHAPE_2_MIRRORED
    774  0362				  -	      .byte	>CHARACTERSHAPE_3, >CHARACTERSHAPE_3_MIRRORED
    775  0362				  -	      .byte	>CHARACTERSHAPE_4, >CHARACTERSHAPE_4_MIRRORED
    776  0362				  -	      .byte	>CHARACTERSHAPE_5, >CHARACTERSHAPE_5_MIRRORED
    777  0362				  -	      .byte	>CHARACTERSHAPE_6, >CHARACTERSHAPE_6_MIRRORED
    778  0362				  -	      .byte	>CHARACTERSHAPE_7, >CHARACTERSHAPE_7_MIRRORED
    779  0362				  -	      .byte	>CHARACTERSHAPE_8, >CHARACTERSHAPE_8_MIRRORED
    780  0362				  -	      .byte	>CHARACTERSHAPE_9, >CHARACTERSHAPE_9_MIRRORED
    781  0362					      endif
    782  0362
    783  0362
    784  0362				  -	      IF	* - CharacterDataVecHI != CHARACTER_MAXIMUM*2
    785  0362				  -	      ECHO	"ERROR: Incorrect CharacterDataVecHI table!"
    786  0362				  -	      ERR
    787  0362					      ENDIF
    788  0362
      0  0362					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- 1K"
      1  0362
      2  0362
      3  0362		       03 62	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- 1K (1K) SIZE =  $362 , FREE= $9e
      4  0362					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0362				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0362				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0362				  -	      ERR
      8  0362					      endif
    790  0362
    791  0362							; Here there's another 1K of usable ROM....
    792  0362							; Anything here is ONLY accessible if the bank is switched in as a ROM bank
    793  0362							; WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    794  0362
      0  0362					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  0362		       03 62	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $362 , FREE= $49e
      2  0362					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0362				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0362				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0362				  -	      ERR
      6  0362					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 3
      0  0362					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  0362							;    Sokoboo - a Sokoban implementation
      2  0362							;    using a generic tile-based display engine for the Atari 2600
      3  0362							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0362							;
      5  0362							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0362							;
      7  0362							;    Code related to the generic tile-based display engine was developed by
      8  0362							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0362							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0362							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0362							;
     12  0362							;    Code related to music and sound effects uses the TIATracker music player
     13  0362							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0362							;    directory for Apache licensing details.
     15  0362							;
     16  0362							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0362							;    See the copyright notices in the License directory for a list of level
     18  0362							;    contributors.
     19  0362							;
     20  0362							;    Except where otherwise indicated, this software is released under the
     21  0362							;    following licensing arrangement...
     22  0362							;
     23  0362							;    This program is free software: you can redistribute it and/or modify
     24  0362							;    it under the terms of the GNU General Public License as published by
     25  0362							;    the Free Software Foundation, either version 3 of the License, or
     26  0362							;    (at your option) any later version.
     27  0362							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0362
     29  0362							;    This program is distributed in the hope that it will be useful,
     30  0362							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0362							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0362							;    GNU General Public License for more details.
     33  0362
     34  0362							;------------------------------------------------------------------------------
     35  0362							;##############################################################################
     36  0362							;------------------------------------------------------------------------------
     37  0362
      0  0362					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  0a50 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
     39  0800
     40  0800							; NOTE: Access to these buffers must NOT overlap pages...
     41  0800							; NOTE: We get auto-initialisation of these variables from the ROM values by
     42  0800							; copying the whole bank into the RAM bank.  Neato.
     43  0800
     44  0800		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     45  0800
     46  0800
     47  0800
     48  0800		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     49  0850		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     50  08a0
      0  08a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  08a0					      LIST	ON
     52  08a0
     53  08a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     54  08a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     55  08a0							; what we want to happen!
     56  08a0
     57  08a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
     58  08f0
     59  08f0
     60  08f0							;------------------------------------------------------------------------------
     61  08f0							; RAM-BASED SUBROUTINES...
     62  08f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     63  08f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     64  08f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     65  08f0							; the RAM-based routine.
     66  08f0
     67  08f0
     68  08f0
     69  08f0							;------------------------------------------------------------------------------
     70  08f0
     71  08f0
     72  08f0		       60	   waitForDraw rts		; 6
     73  08f1
     74  08f1							;------------------------------------------------------------------------------
     75  08f1
      0  08f1					      DEFINE_SUBROUTINE	DrawStackUpdate	; @39✅
      1  08f1		       00 01	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  08f1					      SUBROUTINE
      3  08f1				   DrawStackUpdate
     77  08f1
     78  08f1							; Parse the DrawFlags buffer and create a draw stack
     79  08f1							; so that the actual draw doesn't need to scan for characters to draw.
     80  08f1
     81  08f1
     82  08f1							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     83  08f1							; symptoms would be missing parts of screen when scrolling.
     84  08f1							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     85  08f1							; disabled for sokoban 27/7/2019
     86  08f1
     87  08f1							;lda DrawStackPointer
     88  08f1							;bpl waitForDraw		  ; Wait for previously not-drawn characters to be drawn
     89  08f1
     90  08f1		       ad 84 02 	      lda	INTIM	;4
     91  08f4		       c9 02		      cmp	#SEGTIME_BDS	;2
     92  08f6		       90 f8		      bcc	waitForDraw	;2/3
     93  08f8							; =>[39]+(9)+6rts = 54✅ when exit
     94  08f8
     95  08f8							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
     96  08f8							; moving into the middle of dirt, or BOXs when pushing, or TARGETs when grabbing.
     97  08f8
     98  08f8							;		  sec		 already set
     99  08f8		       a5 a0		      lda	ManY	;3
    100  08fa		       e5 98		      sbc	BoardScrollY	;3
    101  08fc		       85 a2		      sta	ManDrawY	;3 = 9✅
    102  08fe
    103  08fe		       38		      sec		;2
    104  08ff		       a5 9f		      lda	ManX	;3
    105  0901		       e5 99		      sbc	BoardScrollX	;3
    106  0903		       c9 0a		      cmp	#SCREEN_WIDTH	;2
    107  0905		       90 06		      bcc	onsc	;2/3 = 12(13)✅
    108  0907
    109  0907							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
    110  0907							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
    111  0907							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
    112  0907
    113  0907		       a9 08		      lda	#SCREEN_LINES	;2
    114  0909		       85 a2		      sta	ManDrawY	;3
    115  090b		       d0 02		      bne	skipsc	;3 =8		    unconditional
    116  090d
    117  090d		       85 a1	   onsc       sta	ManDrawX	;3
    118  090f				   skipsc
    119  090f
    120  090f							;32✅ worst
    121  090f
    122  090f		       20 db f1 	      jsr	AnimateCharReplacements2	;6+29 = 35✅
    123  0912
    124  0912							;@67✅ worst
    125  0912
    126  0912		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
    127  0914		       85 cd		      sta	DSL	;3
    128  0916
    129  0916		       e6 86		      inc	ScreenDrawPhase	;5
    130  0918		       60		      rts		; 6 TEST allows segtime test to be smaller on next part
    131  0919							; ==> @83✅ worst
    132  0919
    133  0919							;---------------------------------------------------------------------------
    134  0919
      0  0919					      DEFINE_SUBROUTINE	DrawIntoStack	; @39✅
      1  0919		       00 01	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  0919					      SUBROUTINE
      3  0919				   DrawIntoStack
    136  0919
    137  0919		       ba		      tsx		; 2
    138  091a		       86 db		      stx	save_SP	; 3
    139  091c		       a6 81		      ldx	DrawStackPointer	; 3
    140  091e		       9a		      txs		; 2 = 10
    141  091f
    142  091f		       a4 cd		      ldy	DSL	; 3
    143  0921
    144  0921							; @ 52✅
    145  0921
    146  0921							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    147  0921							; + exit cost which is +10 cycles
    148  0921							; TJ: I count 63
    149  0921							;   + 14 for the wtf2 exit
    150  0921							;   + 22 for the end of loop exit
    151  0921
    152  0921							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    153  0921							; For 80 iterations that is 640 cycles, just for checking INTIM
    154  0921							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    155  0921							; it also will require a lot of CPU time for updating the screen data.
    156  0921
    157  0921							; TODO: optimize!
    158  0921							;
    159  0921							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    160  0921							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    161  0921							; costs some detection time here, but saves ~240 cylces for drawing the two
    162  0921
    163  0921				   .loopDrawStack		; @100✅ from bottom of loop
    164  0921
    165  0921		       ad 84 02 	      lda	INTIM	; 4
    166  0924		       c9 03		      cmp	#SEGTIME_DSL	; 2
    167  0926		       90 4b		      bcc	.exitDrawStack	; 2(3)  + [costs 18 more to exit fully at .exit..]
    168  0928							; => full exit on 1st pass = 78✅ cycles
    169  0928							; => full exit on a single loop = 127✅ cycles
    170  0928
    171  0928							; @0✅
    172  0928
    173  0928		       b9 50 f0 	      lda	DrawFlag,y	; 4
    174  092b		       d9 a0 f0 	      cmp	ScreenBuffer,y	; 4		  Is the character already there the same as the new one?
    175  092e		       f0 16		      beq	.next0	; 2/3=10/11	  yes, so we don't draw anything
    176  0930							; @10✅
    177  0930
    178  0930							; Character is NOT the same. Figure out how it should be drawn.
    179  0930							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    180  0930							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    181  0930							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    182  0930
    183  0930		       be 7c f1 	      ldx	PairedCharacter,y	; 4		  the "paired" character for this one
    184  0933		       dd 50 f0 	      cmp	DrawFlag,x	; 4		  same as partner character in new drawn screen?
    185  0936		       d0 05		      bne	.notPaired0	; 2(3)
    186  0938							; @20✅
    187  0938
    188  0938							; Consider two 'paired' characters. Either A:A or A:B
    189  0938							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    190  0938							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    191  0938							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    192  0938							; on the comparison, so the character will not be added to the draw stack. So our first character will
    193  0938							; do the job of drawing BOTH characters to the screen.
    194  0938
    195  0938		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 5		  mark paired character as drawn already (!!)
    196  093b		       09 80		      ora	#$80	; 2 =	7	  DirectDraw this character 'pair'
    197  093d							; @27✅
    198  093d							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    199  093d							; the last write(below) marks the character as to be direct-drawn.
    200  093d
    201  093d				   .notPaired0		; @27✅ worst
    202  093d
    203  093d		       99 a0 f4 	      sta	ScreenBuffer+RAM_WRITE,y	; 5		  NEW character to draw + DirectDraw flag (128)
    204  0940
    205  0940							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    206  0940
    207  0940		       68		      pla		; 4		  ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    208  0941		       98		      tya		; 2
    209  0942		       ba		      tsx		; 2		  << now X holds drawstackpointer
    210  0943		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	; 5 = 18	  index of character to draw
    211  0946
    212  0946		       88	   .next0     dey		; 2
    213  0947		       30 21		      bmi	.finishedDrawStack	; 2(3)= 4/5
    214  0949							; @50✅
    215  0949							; unrolled 2nd loop:
    216  0949		       b9 50 f0 	      lda	DrawFlag,y	; 4
    217  094c		       d9 a0 f0 	      cmp	ScreenBuffer,y	; 4		  Is the character already there the same as the new one?
    218  094f		       f0 16		      beq	.next1	; 2(3) 	  yes, so we don't draw anything
    219  0951
    220  0951		       be 7c f1 	      ldx	PairedCharacter,y	; 4		  the "paired" character for this one
    221  0954		       dd 50 f0 	      cmp	DrawFlag,x	; 4		  same as partner character in new drawn screen?
    222  0957		       d0 05		      bne	.notPaired1	; 2(3)
    223  0959
    224  0959		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 5		  mark paired character as drawn already (!!)
    225  095c		       09 80		      ora	#$80	; 2 =	7	  DirectDraw this character 'pair'
    226  095e
    227  095e				   .notPaired1		; @77✅ worst
    228  095e
    229  095e		       99 a0 f4 	      sta	ScreenBuffer+RAM_WRITE,y	; 5		  NEW character to draw + DirectDraw flag (128)
    230  0961
    231  0961		       68		      pla		; 4		  ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    232  0962		       98		      tya		; 2
    233  0963		       ba		      tsx		; 2
    234  0964		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	; 5 = 18	  index of character to draw
    235  0967							; @95✅
    236  0967
    237  0967		       88	   .next1     dey		; 2
    238  0968		       10 b7		      bpl	.loopDrawStack	; 2(3)
    239  096a							; @100✅ --> @.loopDrawStack
    240  096a
    241  096a							;worst case: 111-4
    242  096a							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    243  096a
    244  096a							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    245  096a
    246  096a				   .finishedDrawStack
    247  096a		       e6 86		      inc	ScreenDrawPhase	;5 =  5
    248  096c		       ba		      tsx		;2
    249  096d		       86 81		      stx	DrawStackPointer	;3
    250  096f
    251  096f		       a6 db		      ldx	save_SP	;3
    252  0971		       9a		      txs		;2 = 10
    253  0972		       60		      rts		;6 =  6
    254  0973
    255  0973				   .exitDrawStack
    256  0973		       84 cd		      sty	DSL	;3 =  3
    257  0975		       ba		      tsx		;2
    258  0976		       86 81		      stx	DrawStackPointer	;3
    259  0978		       a6 db		      ldx	save_SP	;3
    260  097a		       9a		      txs		;2 = 10
    261  097b		       60		      rts		;6 =  6
    262  097c
    263  097c				   PairedCharacter
    264  097c
    265  097c				   SOFF       SET	0
    266  097c					      REPEAT	SCREEN_LINES
    267  097c		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    268  097c				   SOFF       SET	SOFF + SCREEN_WIDTH
    266  097c					      REPEND
    267  0986		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    268  0986				   SOFF       SET	SOFF + SCREEN_WIDTH
    266  0986					      REPEND
    267  0990		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    268  0990				   SOFF       SET	SOFF + SCREEN_WIDTH
    266  0990					      REPEND
    267  099a		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    268  099a				   SOFF       SET	SOFF + SCREEN_WIDTH
    266  099a					      REPEND
    267  09a4		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    268  09a4				   SOFF       SET	SOFF + SCREEN_WIDTH
    266  09a4					      REPEND
    267  09ae		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    268  09ae				   SOFF       SET	SOFF + SCREEN_WIDTH
    266  09ae					      REPEND
    267  09b8		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    268  09b8				   SOFF       SET	SOFF + SCREEN_WIDTH
    266  09b8					      REPEND
    267  09c2		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    268  09c2				   SOFF       SET	SOFF + SCREEN_WIDTH
    269  09cc					      REPEND
    270  09cc
    271  09cc							;------------------------------------------------------------------------------
    272  09cc							; Gives character replacements used during screen drawing.
    273  09cc							; The character from the board is morphed via this array into an actual character
    274  09cc							; to draw.  This allows global animation and replacment of characters without
    275  09cc							; individual objects needing to do this.  Note, the draw-time replacement happens,
    276  09cc							; not board-time.
    277  09cc
    278  09cc				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    279  09cc
    280  09cc							; Converts a character # to an animated creature type
    281  09cc							; The array is indexed by CHARACTER_...
    282  09cc
    283  09cc		       00		      .byte.b	CHARACTER_BLANK	;  0
    284  09cd		       01		      .byte.b	CHARACTER_SOIL	;  1
    285  09ce		       02		      .byte.b	CHARACTER_BOX	;  2
    286  09cf		       03	   ANIM_TARGET .byte.b	CHARACTER_TARGET	;  3  XOR'd to give flashing target squares
    287  09d0		       04		      .byte.b	CHARACTER_TARGET2	;  4
    288  09d1		       05		      .byte.b	CHARACTER_MANOCCUPIED	;  5
    289  09d2		       06		      .byte.b	CHARACTER_STEEL	;  6
    290  09d3		       07		      .byte.b	CHARACTER_WALL	;  7
    291  09d4		       08	   ANIM_TARGET2 .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    292  09d5		       09		      .byte.b	CHARACTER_BOX_ON_TARGET2
    293  09d6		       00		      .byte.b	CHARACTER_BLANK	;  9
    294  09d7		       0b		      .byte.b	CHARACTER_TARGET1
    295  09d8		       0c		      .byte.b	CHARACTER_TARGET3
    296  09d9		       0d		      .byte.b	CHARACTER_TARGET5
    297  09da		       0e		      .byte.b	CHARACTER_TARGET7
    298  09db
    299  09db				  -	      if	DIGITS
    300  09db				  -	      .byte	CHARACTER_0
    301  09db				  -	      .byte	CHARACTER_1
    302  09db				  -	      .byte	CHARACTER_2
    303  09db				  -	      .byte	CHARACTER_3
    304  09db				  -	      .byte	CHARACTER_4
    305  09db				  -	      .byte	CHARACTER_5
    306  09db				  -	      .byte	CHARACTER_6
    307  09db				  -	      .byte	CHARACTER_7
    308  09db				  -	      .byte	CHARACTER_8
    309  09db				  -	      .byte	CHARACTER_9
    310  09db					      endif
    311  09db
    312  09db				  -	      IF	(* - CharReplacement != CHARACTER_MAXIMUM)
    313  09db				  -	      ECHO	"ERROR: Incorrect CharReplacement table!"
    314  09db				  -	      ERR
    315  09db					      ENDIF
      0  09db					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  09db					      LIST	ON
    317  09db
    318  09db
      0  09db					      DEFINE_SUBROUTINE	AnimateCharReplacements2	; 29✅
      1  09db		       00 01	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  09db					      SUBROUTINE
      3  09db				   AnimateCharReplacements2
    320  09db
    321  09db							; This manages character animation on a per-object basis.  Morph/animate these
    322  09db							; characters individually or as required.  Change will affect all characters
    323  09db							; of the same type in the visible display.
    324  09db
    325  09db		       a5 cf		      lda	animate_char_index	; 3
    326  09dd		       29 03		      and	#3	; 2
    327  09df		       aa		      tax		; 2
    328  09e0
    329  09e0		       bd ed f1 	      lda	targetReplaceChar,x	; 4
    330  09e3		       8d cf f5 	      sta	ANIM_TARGET + RAM_WRITE	; 4
    331  09e6		       bd f1 f1 	      lda	targetReplaceChar2,x	; 4
    332  09e9		       8d d4 f5 	      sta	ANIM_TARGET2 + RAM_WRITE	; 4 = 23
    333  09ec
    334  09ec		       60		      rts		; 6 = 29✅
    335  09ed
    336  09ed
    337  09ed				   targetReplaceChar
    338  09ed		       00		      .byte.b	CHARACTER_BLANK	;CHARACTER_TARGET1	;  3  XOR'd to give flashing target squares
    339  09ee		       00		      .byte.b	CHARACTER_BLANK	;  8	 box on target
    340  09ef		       03		      .byte.b	CHARACTER_TARGET	;  8	 box on target
    341  09f0		       03		      .byte.b	CHARACTER_TARGET	;  8	 box on target
    342  09f1
    343  09f1				   targetReplaceChar2
    344  09f1		       02		      .byte.b	CHARACTER_BOX	;CHARACTER_TARGET1	;  3  XOR'd to give flashing target squares
    345  09f2		       02		      .byte.b	CHARACTER_BOX	;  8	 box on target
    346  09f3		       08		      .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    347  09f4		       08		      .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    348  09f5
    349  09f5							;------------------------------------------------------------------------------
    350  09f5
    351  09f5
      0  09f5					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
 PAGE BREAK INSERTED FOR  ROW_BankChar
 REQUESTED SIZE =  $50
 WASTED SPACE =  $b
 PAGEBREAK LOCATION =  $f200
     10  0a00					      LIST	ON
      0  0a00					      DEFINE_SUBROUTINE	ROW_BankChar
      1  0a00		       00 01	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  0a00					      SUBROUTINE
      3  0a00				   ROW_BankChar
    354  0a00
    355  0a00				   .BANK      SET	BANK_SCREENMARKII1
    356  0a00					      REPEAT	SCREEN_LINES
    357  0a00					      REPEAT	SCREEN_WIDTH
    358  0a00		       00		      .byte.b	.BANK
    357  0a00					      REPEND
    358  0a01		       00		      .byte.b	.BANK
    357  0a01					      REPEND
    358  0a02		       00		      .byte.b	.BANK
    357  0a02					      REPEND
    358  0a03		       00		      .byte.b	.BANK
    357  0a03					      REPEND
    358  0a04		       00		      .byte.b	.BANK
    357  0a04					      REPEND
    358  0a05		       00		      .byte.b	.BANK
    357  0a05					      REPEND
    358  0a06		       00		      .byte.b	.BANK
    357  0a06					      REPEND
    358  0a07		       00		      .byte.b	.BANK
    357  0a07					      REPEND
    358  0a08		       00		      .byte.b	.BANK
    357  0a08					      REPEND
    358  0a09		       00		      .byte.b	.BANK
    359  0a0a					      REPEND
    360  0a0a				   .BANK      SET	.BANK + 1
    356  0a0a					      REPEND
    357  0a0a					      REPEAT	SCREEN_WIDTH
    358  0a0a		       01		      .byte.b	.BANK
    357  0a0a					      REPEND
    358  0a0b		       01		      .byte.b	.BANK
    357  0a0b					      REPEND
    358  0a0c		       01		      .byte.b	.BANK
    357  0a0c					      REPEND
    358  0a0d		       01		      .byte.b	.BANK
    357  0a0d					      REPEND
    358  0a0e		       01		      .byte.b	.BANK
    357  0a0e					      REPEND
    358  0a0f		       01		      .byte.b	.BANK
    357  0a0f					      REPEND
    358  0a10		       01		      .byte.b	.BANK
    357  0a10					      REPEND
    358  0a11		       01		      .byte.b	.BANK
    357  0a11					      REPEND
    358  0a12		       01		      .byte.b	.BANK
    357  0a12					      REPEND
    358  0a13		       01		      .byte.b	.BANK
    359  0a14					      REPEND
    360  0a14				   .BANK      SET	.BANK + 1
    356  0a14					      REPEND
    357  0a14					      REPEAT	SCREEN_WIDTH
    358  0a14		       02		      .byte.b	.BANK
    357  0a14					      REPEND
    358  0a15		       02		      .byte.b	.BANK
    357  0a15					      REPEND
    358  0a16		       02		      .byte.b	.BANK
    357  0a16					      REPEND
    358  0a17		       02		      .byte.b	.BANK
    357  0a17					      REPEND
    358  0a18		       02		      .byte.b	.BANK
    357  0a18					      REPEND
    358  0a19		       02		      .byte.b	.BANK
    357  0a19					      REPEND
    358  0a1a		       02		      .byte.b	.BANK
    357  0a1a					      REPEND
    358  0a1b		       02		      .byte.b	.BANK
    357  0a1b					      REPEND
    358  0a1c		       02		      .byte.b	.BANK
    357  0a1c					      REPEND
    358  0a1d		       02		      .byte.b	.BANK
    359  0a1e					      REPEND
    360  0a1e				   .BANK      SET	.BANK + 1
    356  0a1e					      REPEND
    357  0a1e					      REPEAT	SCREEN_WIDTH
    358  0a1e		       03		      .byte.b	.BANK
    357  0a1e					      REPEND
    358  0a1f		       03		      .byte.b	.BANK
    357  0a1f					      REPEND
    358  0a20		       03		      .byte.b	.BANK
    357  0a20					      REPEND
    358  0a21		       03		      .byte.b	.BANK
    357  0a21					      REPEND
    358  0a22		       03		      .byte.b	.BANK
    357  0a22					      REPEND
    358  0a23		       03		      .byte.b	.BANK
    357  0a23					      REPEND
    358  0a24		       03		      .byte.b	.BANK
    357  0a24					      REPEND
    358  0a25		       03		      .byte.b	.BANK
    357  0a25					      REPEND
    358  0a26		       03		      .byte.b	.BANK
    357  0a26					      REPEND
    358  0a27		       03		      .byte.b	.BANK
    359  0a28					      REPEND
    360  0a28				   .BANK      SET	.BANK + 1
    356  0a28					      REPEND
    357  0a28					      REPEAT	SCREEN_WIDTH
    358  0a28		       04		      .byte.b	.BANK
    357  0a28					      REPEND
    358  0a29		       04		      .byte.b	.BANK
    357  0a29					      REPEND
    358  0a2a		       04		      .byte.b	.BANK
    357  0a2a					      REPEND
    358  0a2b		       04		      .byte.b	.BANK
    357  0a2b					      REPEND
    358  0a2c		       04		      .byte.b	.BANK
    357  0a2c					      REPEND
    358  0a2d		       04		      .byte.b	.BANK
    357  0a2d					      REPEND
    358  0a2e		       04		      .byte.b	.BANK
    357  0a2e					      REPEND
    358  0a2f		       04		      .byte.b	.BANK
    357  0a2f					      REPEND
    358  0a30		       04		      .byte.b	.BANK
    357  0a30					      REPEND
    358  0a31		       04		      .byte.b	.BANK
    359  0a32					      REPEND
    360  0a32				   .BANK      SET	.BANK + 1
    356  0a32					      REPEND
    357  0a32					      REPEAT	SCREEN_WIDTH
    358  0a32		       05		      .byte.b	.BANK
    357  0a32					      REPEND
    358  0a33		       05		      .byte.b	.BANK
    357  0a33					      REPEND
    358  0a34		       05		      .byte.b	.BANK
    357  0a34					      REPEND
    358  0a35		       05		      .byte.b	.BANK
    357  0a35					      REPEND
    358  0a36		       05		      .byte.b	.BANK
    357  0a36					      REPEND
    358  0a37		       05		      .byte.b	.BANK
    357  0a37					      REPEND
    358  0a38		       05		      .byte.b	.BANK
    357  0a38					      REPEND
    358  0a39		       05		      .byte.b	.BANK
    357  0a39					      REPEND
    358  0a3a		       05		      .byte.b	.BANK
    357  0a3a					      REPEND
    358  0a3b		       05		      .byte.b	.BANK
    359  0a3c					      REPEND
    360  0a3c				   .BANK      SET	.BANK + 1
    356  0a3c					      REPEND
    357  0a3c					      REPEAT	SCREEN_WIDTH
    358  0a3c		       06		      .byte.b	.BANK
    357  0a3c					      REPEND
    358  0a3d		       06		      .byte.b	.BANK
    357  0a3d					      REPEND
    358  0a3e		       06		      .byte.b	.BANK
    357  0a3e					      REPEND
    358  0a3f		       06		      .byte.b	.BANK
    357  0a3f					      REPEND
    358  0a40		       06		      .byte.b	.BANK
    357  0a40					      REPEND
    358  0a41		       06		      .byte.b	.BANK
    357  0a41					      REPEND
    358  0a42		       06		      .byte.b	.BANK
    357  0a42					      REPEND
    358  0a43		       06		      .byte.b	.BANK
    357  0a43					      REPEND
    358  0a44		       06		      .byte.b	.BANK
    357  0a44					      REPEND
    358  0a45		       06		      .byte.b	.BANK
    359  0a46					      REPEND
    360  0a46				   .BANK      SET	.BANK + 1
    356  0a46					      REPEND
    357  0a46					      REPEAT	SCREEN_WIDTH
    358  0a46		       07		      .byte.b	.BANK
    357  0a46					      REPEND
    358  0a47		       07		      .byte.b	.BANK
    357  0a47					      REPEND
    358  0a48		       07		      .byte.b	.BANK
    357  0a48					      REPEND
    358  0a49		       07		      .byte.b	.BANK
    357  0a49					      REPEND
    358  0a4a		       07		      .byte.b	.BANK
    357  0a4a					      REPEND
    358  0a4b		       07		      .byte.b	.BANK
    357  0a4b					      REPEND
    358  0a4c		       07		      .byte.b	.BANK
    357  0a4c					      REPEND
    358  0a4d		       07		      .byte.b	.BANK
    357  0a4d					      REPEND
    358  0a4e		       07		      .byte.b	.BANK
    357  0a4e					      REPEND
    358  0a4f		       07		      .byte.b	.BANK
    359  0a50					      REPEND
    360  0a50				   .BANK      SET	.BANK + 1
    361  0a50					      REPEND
    362  0a50
      0  0a50					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  0a50
      2  0a50
      3  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $250 , FREE= $1b0
      4  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0a50				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0a50				  -	      ERR
      8  0a50					      endif
    364  0a50
    365  0a50
      0  0a50					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $250 , FREE= $5b0
      2  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0a50				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0a50				  -	      ERR
      6  0a50					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 3
      0  0a50					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  0a50							;    Sokoboo - a Sokoban implementation
      2  0a50							;    using a generic tile-based display engine for the Atari 2600
      3  0a50							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0a50							;
      5  0a50							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0a50							;
      7  0a50							;    Code related to the generic tile-based display engine was developed by
      8  0a50							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0a50							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0a50							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0a50							;
     12  0a50							;    Code related to music and sound effects uses the TIATracker music player
     13  0a50							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0a50							;    directory for Apache licensing details.
     15  0a50							;
     16  0a50							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0a50							;    See the copyright notices in the License directory for a list of level
     18  0a50							;    contributors.
     19  0a50							;
     20  0a50							;    Except where otherwise indicated, this software is released under the
     21  0a50							;    following licensing arrangement...
     22  0a50							;
     23  0a50							;    This program is free software: you can redistribute it and/or modify
     24  0a50							;    it under the terms of the GNU General Public License as published by
     25  0a50							;    the Free Software Foundation, either version 3 of the License, or
     26  0a50							;    (at your option) any later version.
     27  0a50							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0a50
     29  0a50							;    This program is distributed in the hope that it will be useful,
     30  0a50							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0a50							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0a50							;    GNU General Public License for more details.
     33  0a50
     34  0a50							;------------------------------------------------------------------------------
     35  0a50							;##############################################################################
     36  0a50							;------------------------------------------------------------------------------
      0  0a50					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  139d ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
     38  1000
     39  1000
     40  1000		       00 9a	   SCORE_COL  =	$9a	;WHITE ;-2
     41  1000		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     42  1000		       00 66	   SCORE_COL_HIGH_PAL =	$66
     43  1000
     44  1000
     45  1000				   DigitVectorLOr
     46  1000		       31 3f 4d 38*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     47  100a		       00 07 0e 15	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     48  100e				   DigitVectorLO
     49  100e		       53 61 6e 5a*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     50  1018		       37		      .byte.b	<BLANKL-1
     51  1019
     52  1019
     53  1019		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     54  1019		       00 0b	   ID_TARGET  =	11
     55  1019		       00 0c	   ID_EXTRA   =	12
     56  1019		       00 0d	   ID_CLOCK   =	13
     57  1019		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     58  1019
     59  1019							; score patch adresses:
     60  1019				   SMTblLSB
     61  1019				   SMTblTargets
     62  1019		       52 48		      .byte.b	SM_TARGET0+1-SM_BASE, SM_TARGET2+1-SM_BASE
     63  101b				   SMTblTime
     64  101b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     65  101d				   SMTblScore
     66  101d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     67  1020				   SMTblMSB
     68  1020		       4d 43		      .byte.b	SM_TARGET1+1-SM_BASE, SM_TARGET3+1-SM_BASE
     69  1022		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     70  1024		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     71  1027
     72  1027		       00 00	   SM_OFS_TARGETS =	SMTblTargets - SMTblLSB
     73  1027		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     74  1027		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     75  1027
     76  1027				   CharVectorLO
     77  1027		       37		      .byte.b	<BLANKL-1
     78  1028		       ad ad ad ad	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     79  102c		       ad ad ad ad	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     80  1030		       ad ad ad ad	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     81  1034		       ad ad ad ad	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     82  1038							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     83  1038
     84  1038							; Digit shape definitions are at start of bank so that we don't have page boundary
     85  1038							; crossing issues.
     86  1038
     87  1038							;	  .byte 0	      ; required!
     88  1038
     89  1038		       00 07	   DIGIT_H    =	7	; height of a score digit
     90  1038
     91  1038		       00 00 00 00*BLANKL     ds	7,0
     92  103f
     93  103f
     94  103f
     95  103f				   NineL
     96  103f		       1e		      .byte.b	%00011110
     97  1040		       02		      .byte.b	%00000010
     98  1041		       02		      .byte.b	%00000010
     99  1042		       fe		      .byte.b	%11111110
    100  1043		       82		      .byte.b	%10000010
    101  1044		       82		      .byte.b	%10000010
    102  1045		       fe		      .byte.b	%11111110
    103  1046
    104  1046				   SixL
    105  1046		       fe		      .byte.b	%11111110
    106  1047		       82		      .byte.b	%10000010
    107  1048		       82		      .byte.b	%10000010
    108  1049		       fe		      .byte.b	%11111110
    109  104a		       80		      .byte.b	%10000000
    110  104b		       80		      .byte.b	%10000000
    111  104c		       f0		      .byte.b	%11110000
    112  104d
    113  104d							;    .byte %01111100
    114  104d							;    .byte %11000010
    115  104d							;    .byte %11000010
    116  104d							;    .byte %11111100
    117  104d							;    .byte %11000000
    118  104d							;    .byte %01100000
    119  104d							;    .byte %00111000
    120  104d				   EightL
    121  104d
    122  104d
    123  104d		       fe		      .byte.b	%11111110
    124  104e		       82		      .byte.b	%10000010
    125  104f		       82		      .byte.b	%10000010
    126  1050		       fe		      .byte.b	%11111110
    127  1051		       82		      .byte.b	%10000010
    128  1052		       82		      .byte.b	%10000010
    129  1053		       fe		      .byte.b	%11111110
    130  1054
    131  1054							;  .byte %01111100
    132  1054							;  .byte %10000110
    133  1054							;  .byte %10000110
    134  1054							;  .byte %01111100
    135  1054							;  .byte %01000110
    136  1054							;  .byte %01000110
    137  1054							;  .byte %00111100
    138  1054				   ZeroL
    139  1054							;  .byte %01111100
    140  1054							;  .byte %10000110
    141  1054							;  .byte %10000110
    142  1054							;  .byte %10000110
    143  1054							;  .byte %10000110
    144  1054							;  .byte %01000110
    145  1054							;  .byte %00111100
    146  1054
    147  1054		       fe		      .byte.b	%11111110
    148  1055		       82		      .byte.b	%10000010
    149  1056		       82		      .byte.b	%10000010
    150  1057		       82		      .byte.b	%10000010
    151  1058		       82		      .byte.b	%10000010
    152  1059		       82		      .byte.b	%10000010
    153  105a		       fe		      .byte.b	%11111110
    154  105b
    155  105b				   ThreeL
    156  105b		       fe		      .byte.b	%11111110
    157  105c		       02		      .byte.b	%00000010
    158  105d		       02		      .byte.b	%00000010
    159  105e		       1e		      .byte.b	%00011110
    160  105f		       02		      .byte.b	%00000010
    161  1060		       02		      .byte.b	%00000010
    162  1061		       fe		      .byte.b	%11111110
    163  1062				   OneL
    164  1062		       10		      .byte.b	%00010000
    165  1063		       10		      .byte.b	%00010000
    166  1064		       10		      .byte.b	%00010000
    167  1065		       10		      .byte.b	%00010000
    168  1066		       10		      .byte.b	%00010000
    169  1067		       10		      .byte.b	%00010000
    170  1068		       10		      .byte.b	%00010000
    171  1069
    172  1069				   SevenL
    173  1069
    174  1069		       10		      .byte.b	%00010000
    175  106a		       10		      .byte.b	%00010000
    176  106b		       10		      .byte.b	%00010000
    177  106c		       1e		      .byte.b	%00011110
    178  106d		       02		      .byte.b	%00000010
    179  106e		       02		      .byte.b	%00000010
    180  106f							;  .byte %11111110
    181  106f
    182  106f							;    .byte %00010000
    183  106f							;    .byte %00010000
    184  106f							;    .byte %00010000
    185  106f							;    .byte %00011000
    186  106f							;    .byte %00001100
    187  106f							;    .byte %10000110
    188  106f							;    ;.byte %11111110
    189  106f				   TwoL
    190  106f		       fe		      .byte.b	%11111110
    191  1070		       80		      .byte.b	%10000000
    192  1071		       80		      .byte.b	%10000000
    193  1072		       fe		      .byte.b	%11111110
    194  1073		       02		      .byte.b	%00000010
    195  1074		       02		      .byte.b	%00000010
    196  1075		       fe		      .byte.b	%11111110
    197  1076
    198  1076				   FiveL
    199  1076		       fe		      .byte.b	%11111110
    200  1077		       02		      .byte.b	%00000010
    201  1078		       02		      .byte.b	%00000010
    202  1079		       fe		      .byte.b	%11111110
    203  107a		       80		      .byte.b	%10000000
    204  107b		       80		      .byte.b	%10000000
    205  107c		       f0		      .byte.b	%11110000
    206  107d
    207  107d				   FourL
    208  107d		       10		      .byte.b	%00010000
    209  107e		       10		      .byte.b	%00010000
    210  107f		       10		      .byte.b	%00010000
    211  1080		       fe		      .byte.b	%11111110
    212  1081		       90		      .byte.b	%10010000
    213  1082		       90		      .byte.b	%10010000
    214  1083		       90		      .byte.b	%10010000
    215  1084
    216  1084
    217  1084				   ZL
    218  1084		       7f		      .byte.b	%01111111
    219  1085		       40		      .byte.b	%01000000
    220  1086		       40		      .byte.b	%01000000
    221  1087		       7f		      .byte.b	%01111111
    222  1088		       01		      .byte.b	%00000001
    223  1089		       01		      .byte.b	%00000001
    224  108a		       0f		      .byte.b	%00001111
    225  108b
    226  108b				   EL
    227  108b		       7f		      .byte.b	%01111111
    228  108c		       40		      .byte.b	%01000000
    229  108d		       40		      .byte.b	%01000000
    230  108e		       78		      .byte.b	%01111000
    231  108f		       40		      .byte.b	%01000000
    232  1090		       40		      .byte.b	%01000000
    233  1091		       7f		      .byte.b	%01111111
    234  1092
    235  1092				   RL
    236  1092		       48		      .byte.b	%01001000
    237  1093		       48		      .byte.b	%01001000
    238  1094		       48		      .byte.b	%01001000
    239  1095		       7f		      .byte.b	%01111111
    240  1096		       41		      .byte.b	%01000001
    241  1097		       41		      .byte.b	%01000001
    242  1098		       7f		      .byte.b	%01111111
    243  1099
    244  1099				   PL
    245  1099		       40		      .byte.b	%01000000
    246  109a		       40		      .byte.b	%01000000
    247  109b		       40		      .byte.b	%01000000
    248  109c		       7f		      .byte.b	%01111111
    249  109d		       41		      .byte.b	%01000001
    250  109e		       41		      .byte.b	%01000001
    251  109f		       7f		      .byte.b	%01111111
    252  10a0
    253  10a0				   AL
    254  10a0		       41		      .byte.b	%01000001
    255  10a1		       41		      .byte.b	%01000001
    256  10a2		       41		      .byte.b	%01000001
    257  10a3		       7f		      .byte.b	%01111111
    258  10a4		       41		      .byte.b	%01000001
    259  10a5		       41		      .byte.b	%01000001
    260  10a6		       7f		      .byte.b	%01111111
    261  10a7
    262  10a7				   GL
    263  10a7		       7f		      .byte.b	%01111111
    264  10a8		       41		      .byte.b	%01000001
    265  10a9		       41		      .byte.b	%01000001
    266  10aa		       4f		      .byte.b	%01001111
    267  10ab		       40		      .byte.b	%01000000
    268  10ac		       40		      .byte.b	%01000000
    269  10ad		       7f		      .byte.b	%01111111
    270  10ae
    271  10ae
    272  10ae							; level "name" characters (left only!):
    273  10ae
    274  10ae				   CharN
    275  10ae				   CharK
    276  10ae				   CharH
    277  10ae				   CharA
    278  10ae				   CharJ
    279  10ae				   CharP
    280  10ae				   CharB
    281  10ae				   CharO
    282  10ae				   CharC
    283  10ae				   CharI
    284  10ae				   CharD
    285  10ae				   CharG
    286  10ae				   CharE
    287  10ae				   CharL
    288  10ae				   CharF
    289  10ae				   CharM
    290  10ae		       00 00 00 00*	      ds	7,0
    291  10b5
    292  10b5				   charPlace
    293  10b5		       0c		      .byte.b	%00001100
    294  10b6		       0c		      .byte.b	%00001100
    295  10b7		       0c		      .byte.b	%00001100
    296  10b8		       0c		      .byte.b	%00001100
    297  10b9		       0c		      .byte.b	%00001100
    298  10ba		       00		      .byte.b	%00000000
    299  10bb		       0c		      .byte.b	%00001100
    300  10bc
    301  10bc							;-------------------------------------------------------------------------------------
    302  10bc				   PosTbl
    303  10bc		       40		      .byte.b	$40
    304  10bd		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    305  10c5		       b9		      .byte.b	$b9
    306  10c6
    307  10c6
    308  10c6							;------------------------------------------------------------------------------
    309  10c6							; RAM-BASED SUBROUTINES...
    310  10c6							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    311  10c6							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    312  10c6							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    313  10c6							; the RAM-based routine.
    314  10c6
    315  1100		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    316  1100
    317  1100		       f1 00	   SM_BASE    =	.
    318  1100
    319  1100							;#IF 0 ;{
    320  1100							;    DEFINE_SUBROUTINE Score3x3
    321  1100							;
    322  1100							;	  sta	  RESP0
    323  1100							;	   sta	   RESP1
    324  1100							;	   lda	   #$$000
    325  1100							;	    sta     GRP0
    326  1100							;	    lda     #$$009
    327  1100							;	    sta     GRP1
    328  1100							;	    lda     #$$202
    329  1100							;	    sta     ENABL
    330  1100							;	    nop
    331  1100							;	    nop
    332  1100							;	    nop
    333  1100							;	    lda     #$$016
    334  1100							;	    ldy     #$$100
    335  1100							;	    ldx     #$$109
    336  1100							;	    sta     GRP0    ; Critical time is right here
    337  1100							;	    stx     GRP1
    338  1100							;	    sty     GRP0
    339  1100							;	    sta     RESP0
    340  1100							;	    sta     RESP1
    341  1100							;	    ldx     #$$116
    342  1100							;	    lda     #$$209
    343  1100							;	    stx     GRP0
    344  1100							;	    sta     GRP1
    345  1100							;	    lda     #$$200
    346  1100							;	    sta     GRP0
    347  1100							;	    sta     RESP0
    348  1100							;	    sta     RESP1
    349  1100							;	    lda     #$$216
    350  1100							;	    nop
    351  1100							;	    sta     GRP0
    352  1100							;
    353  1100							;	      rts
    354  1100							;#ENDIF ;}
    355  1100
    356  1100
    357  1100							;------------------------------------------------------------------------------
    358  1100				   Score1x6Fix SUBROUTINE
      0  1100					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  1100		       00 02	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  1100					      SUBROUTINE
      3  1100				   DrawDigits1x6
    360  1100							;					     @07
    361  1100		       ba		      tsx		; 2
    362  1101
    363  1101		       20 f2 f1 	      jsr	PrepareDrawDigits	;56 = 58    @65
    364  1104
    365  1104		       86 db		      stx	tmpStack	; 3 =	3
    366  1106
    367  1106				   LoopDraw1x6		;
    368  1106				   SMDIGIT0
    369  1106		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    370  1109		       85 42		      sta	WSYNC	; 3
    371  110b							;---------------------------------------------------------------
    372  110b		       85 6a		      sta	HMOVE	; 3
      0  110d					      SLEEP	3	; 3 =	6
      1  110d				   .CYCLES    SET	3
      2  110d
      3  110d				  -	      IF	.CYCLES < 2
      4  110d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  110d				  -	      ERR
      6  110d					      ENDIF
      7  110d
      8  110d					      IF	.CYCLES & 1
      9  110d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  110d		       04 00		      nop	0
     11  110f				  -	      ELSE
     12  110f				  -	      bit	VSYNC
     13  110f					      ENDIF
     14  110f				   .CYCLES    SET	.CYCLES - 3
     15  110f					      ENDIF
     16  110f
     17  110f				  -	      REPEAT	.CYCLES / 2
     18  110f				  -	      nop
     19  110f					      REPEND
    374  110f		       85 5b		      sta	GRP0	; 3
    375  1111				   SMDIGIT1
    376  1111		       b9 53 f0 	      lda	ZeroL-1,y	; 4
    377  1114		       85 5c		      sta	GRP1	; 3
    378  1116				   SMDIGIT2
    379  1116		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    380  1119		       85 5b		      sta	GRP0	; 3 = 17
    381  111b				   SMDIGIT5
    382  111b		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    383  111e		       9a		      txs		; 2
    384  111f				   SMDIGIT3
    385  111f		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    386  1122				   SMDIGIT4
    387  1122		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    388  1125		       85 6b		      sta	HMCLR	; 3
    389  1127		       86 5c		      stx	GRP1	; 3
    390  1129		       85 5b		      sta	GRP0	; 3 = 23
    391  112b
    392  112b		       ba		      tsx		; 2
    393  112c		       86 5c		      stx	GRP1	; 3
    394  112e		       85 5b		      sta	GRP0	; 3 =	8
    395  1130
    396  1130		       88		      dey		; 2
      0  1131					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  1131					      LIST	ON
      9  1131		       d0 d3		      bne	LoopDraw1x6
    398  1133
    399  1133		       a6 db		      ldx	tmpStack	; 3
    400  1135		       9a		      txs		; 2
    401  1136				   ExitDigitKernel6
      0  1136					      SLEEP	3	; 3
      1  1136				   .CYCLES    SET	3
      2  1136
      3  1136				  -	      IF	.CYCLES < 2
      4  1136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1136				  -	      ERR
      6  1136					      ENDIF
      7  1136
      8  1136					      IF	.CYCLES & 1
      9  1136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1136		       04 00		      nop	0
     11  1138				  -	      ELSE
     12  1138				  -	      bit	VSYNC
     13  1138					      ENDIF
     14  1138				   .CYCLES    SET	.CYCLES - 3
     15  1138					      ENDIF
     16  1138
     17  1138				  -	      REPEAT	.CYCLES / 2
     18  1138				  -	      nop
     19  1138					      REPEND
    403  1138		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    404  113b
    405  113b
    406  113b							;------------------------------------------------------------------------------
    407  113b				   Score2x4Fix SUBROUTINE
      0  113b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  113b		       00 02	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  113b					      SUBROUTINE
      3  113b				   DrawDigits2x4
    409  113b
    410  113b
    411  113b							; Subroutine by Thomas Jentzsch.  Magic!
    412  113b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    413  113b
    414  113b							;sta COLUBK
    415  113b
    416  113b		       20 f2 f1 	      jsr	PrepareDrawDigits	;56 = 56    @63
    417  113e
    418  113e		       85 6a		      sta	HMOVE	; 3
      0  1140					      SLEEP	4	; 4  =  7
      1  1140				   .CYCLES    SET	4
      2  1140
      3  1140				  -	      IF	.CYCLES < 2
      4  1140				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1140				  -	      ERR
      6  1140					      ENDIF
      7  1140
      8  1140				  -	      IF	.CYCLES & 1
      9  1140				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1140				  -	      nop	0
     11  1140				  -	      ELSE
     12  1140				  -	      bit	VSYNC
     13  1140				  -	      ENDIF
     14  1140				  -.CYCLES    SET	.CYCLES - 3
     15  1140					      ENDIF
     16  1140
     17  1140					      REPEAT	.CYCLES / 2
     18  1140		       ea		      nop
     17  1140					      REPEND
     18  1141		       ea		      nop
     19  1142					      REPEND
    420  1142
    421  1142				   LoopDraw2x4		;	     @70
    422  1142				   SM_TARGET3
    423  1142		       b9 07 f3 	      lda	DequalsR-1,y	; 4		     G
    424  1145							;---------------------------------------------------------------
    425  1145		       85 5b		      sta	GRP0	; 3
    426  1147				   SM_TARGET2
    427  1147		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     A
    428  114a		       85 5c		      sta	GRP1	; 3
    429  114c				   SM_TARGET1
    430  114c		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     M
    431  114f		       85 5b		      sta	GRP0	; 3
    432  1151				   SM_TARGET0
    433  1151		       be 53 f0 	      ldx	ZeroL-1,y	; 4		     E
    434  1154		       85 50		      sta	RESP0	; 3 = 28    @22
    435  1156		       85 51		      sta	RESP1	; 3 =	3    @25
    436  1158				   SM_Time3
    437  1158		       b9 15 f3 	      lda	ClockR-1,y	; 4		     O
    438  115b		       86 5c		      stx	GRP1	; 3
    439  115d		       85 5b		      sta	GRP0	; 3
    440  115f				   SM_Time2
    441  115f		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     V
    442  1162		       85 5c		      sta	GRP1	; 3
    443  1164				   SM_Time1
    444  1164		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     E
    445  1167		       85 5b		      sta	GRP0	; 3
    446  1169		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    447  116b		       85 51		      sta	RESP1	; 3 =	3    @55
    448  116d				   SM_Time0
    449  116d		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     R
    450  1170		       85 5c		      sta	GRP1	; 3
    451  1172		       85 5b		      sta	GRP0	; 3
    452  1174		       88		      dey		; 2
      0  1175					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  1175					      LIST	ON
      9  1175		       d0 cb		      bne	LoopDraw2x4
    454  1177
    455  1177				   ExitDigitKernel		;	     @69
    456  1177		       84 5b		      sty	GRP0	; 3
    457  1179		       84 5c		      sty	GRP1	; 3
    458  117b							;---------------------------------------------------------------
    459  117b		       84 5b		      sty	GRP0	; 3	     @02
    460  117d
    461  117d							; Contribution by Thomas Jentzsch
    462  117d							; Rewrite/Optimised for single sprite AD
    463  117d
    464  117d		       a6 a1		      ldx	ManDrawX	; 3
    465  117f		       bd bc f0 	      lda	PosTbl,x	; 4
    466  1182		       85 60		      sta	HMP0	; 3
    467  1184		       29 0f		      and	#$0f	; 2
    468  1186		       f0 04		      beq	.zeroPos	; 2/3=15
    469  1188		       aa		      tax		; 2
    470  1189				   .loopWait
    471  1189		       ca		      dex		; 2
    472  118a		       d0 fd		      bne	.loopWait	; 2/3= 6
    473  118c				   .zeroPos
    474  118c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    475  118e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    476  1190		       a5 b2		      lda	BGColour	; 3
    477  1192		       86 62		      stx	HMM0	; 3	     for extra life stars!
    478  1194		       85 42		      sta	WSYNC	; 3
    479  1196							;    sta WSYNC
    480  1196							;    sta WSYNC
    481  1196							;---------------------------------------------------------------
    482  1196		       85 6a		      sta	HMOVE	; 3
    483  1198		       85 49		      sta	COLUBK
    484  119a		       60		      rts		; 6	     @09
    485  119b
    486  119b							;------------------------------------------------------------------------------
    487  119b				   Score3x2Fix SUBROUTINE
      0  119b					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  119b		       00 02	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  119b					      SUBROUTINE
      3  119b				   DrawDigits3x2
    489  119b							;					     @07
    490  119b		       a9 16		      lda	#%010110	; 2
    491  119d		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    492  119f		       20 f8 f1 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    493  11a2
    494  11a2		       a9 00		      lda	#0
    495  11a4		       85 66		      sta	VDELP1
    496  11a6				   LoopDraw3x2		;
    497  11a6		       85 42		      sta	WSYNC	; 3
    498  11a8							;---------------------------------------------------------------
    499  11a8		       85 6a		      sta	HMOVE	; 3 =	3
    500  11aa		       b9 ad f0 	      lda	CharP-1,y	; 4
    501  11ad		       85 5b		      sta	GRP0	; 3
    502  11af				   SMPLAYER
    503  11af		       b9 3f f3 	      lda	OneR-1,y	; 4
    504  11b2		       85 5c		      sta	GRP1	; 3 = 14    @17
    505  11b4		       b9 b4 f0 	      lda	charPlace-1,y	; 4
    506  11b7				   SMMEN
    507  11b7		       be 38 f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  11ba					      SLEEP	5	;   =	5
      1  11ba				   .CYCLES    SET	5
      2  11ba
      3  11ba				  -	      IF	.CYCLES < 2
      4  11ba				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11ba				  -	      ERR
      6  11ba					      ENDIF
      7  11ba
      8  11ba					      IF	.CYCLES & 1
      9  11ba					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11ba		       04 00		      nop	0
     11  11bc				  -	      ELSE
     12  11bc				  -	      bit	VSYNC
     13  11bc					      ENDIF
     14  11bc				   .CYCLES    SET	.CYCLES - 3
     15  11bc					      ENDIF
     16  11bc
     17  11bc					      REPEAT	.CYCLES / 2
     18  11bc		       ea		      nop
     19  11bd					      REPEND
    509  11bd		       85 5b		      sta	GRP0	; 3
    510  11bf				   SMLEVELX
    511  11bf		       b9 ad f0 	      lda	CharA-1,y	; 4
    512  11c2		       85 6b		      sta	HMCLR	; 3 = 10    @40
    513  11c4		       86 5c		      stx	GRP1	; 3 =	3    @43
    514  11c6		       85 5b		      sta	GRP0	; 3
    515  11c8				   SMLEVEL
    516  11c8		       b9 3f f3 	      lda	OneR-1,y	; 4
    517  11cb		       85 5c		      sta	GRP1	; 3 = 10    @53
    518  11cd
    519  11cd		       88		      dey		; 2
      0  11ce					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  11ce					      LIST	ON
      9  11ce		       d0 d6		      bne	LoopDraw3x2
    521  11d0							;					     @57
      0  11d0					      SLEEP	3	; 3
      1  11d0				   .CYCLES    SET	3
      2  11d0
      3  11d0				  -	      IF	.CYCLES < 2
      4  11d0				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11d0				  -	      ERR
      6  11d0					      ENDIF
      7  11d0
      8  11d0					      IF	.CYCLES & 1
      9  11d0					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11d0		       04 00		      nop	0
     11  11d2				  -	      ELSE
     12  11d2				  -	      bit	VSYNC
     13  11d2					      ENDIF
     14  11d2				   .CYCLES    SET	.CYCLES - 3
     15  11d2					      ENDIF
     16  11d2
     17  11d2				  -	      REPEAT	.CYCLES / 2
     18  11d2				  -	      nop
     19  11d2					      REPEND
    523  11d2		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    524  11d5
    525  11d5
    526  11d5							;------------------------------------------------------------------------------
      0  11d5					      DEFINE_SUBROUTINE	DrawDigits
      1  11d5		       00 02	   BANK_DrawDigits =	_CURRENT_BANK
      2  11d5					      SUBROUTINE
      3  11d5				   DrawDigits
    528  11d5
    529  11d5				   VblankLoopGame
    530  11d5		       ac 84 02 	      ldy	INTIM
    531  11d8		       d0 fb		      bne	VblankLoopGame
    532  11da
    533  11da					      IF	WAIT_FOR_INITIAL_DRAW
    534  11da		       a4 ae		      ldy	blankState
    535  11dc					      ENDIF
    536  11dc		       84 41		      sty	VBLANK	; 3	     <-- 0
    537  11de		       a5 ca		      lda	scoringFlags	; 3
    538  11e0		       29 03		      and	#DISPLAY_FLAGS	; 2
    539  11e2		       aa		      tax		; 2
    540  11e3
    541  11e3							;    DEFINE_SUBROUTINE DrawDigit2
    542  11e3							;
    543  11e3							;    ; Generic interface to scoring routine
    544  11e3
    545  11e3		       bd ee f1 	      lda	ScoreKernelLo,x	; 4
    546  11e6
    547  11e6		       85 42		      sta	WSYNC	; 3
    548  11e8							;---------------------------------------------------------------
    549  11e8		       8d ec f5 	      sta	SMJUMP+1+RAM_WRITE	; 4
    550  11eb				   SMJUMP
    551  11eb		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    552  11ee
    553  11ee				   ScoreKernelLo
    554  11ee		       3b		      .byte.b	<Score2x4Fix	; TARGETs, time
    555  11ef		       00		      .byte.b	<Score1x6Fix	; score
    556  11f0		       9b		      .byte.b	<Score3x2Fix	; player, lives, level
    557  11f1		       00		      .byte.b	<Score1x6Fix	; high score
    558  11f2
      0  11f2					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  11f2					      LIST	ON
    560  11f2
    561  11f2							;------------------------------------------------------------------------------
      0  11f2					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  11f2		       00 02	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  11f2					      SUBROUTINE
      3  11f2				   PrepareDrawDigits
    563  11f2							;					     @13
    564  11f2		       a0 d1		      ldy	#$d1	; 2
    565  11f4		       a9 13		      lda	#%010011	; 2
    566  11f6		       85 66		      sta	VDELP1	; 3 =	7
    567  11f8				   PrepareDrawDigits2		;	    @17/20
    568  11f8		       84 65		      sty	VDELP0	; 3 =	3
    569  11fa
    570  11fa		       85 45		      sta	NUSIZ1	; 3
    571  11fc		       85 44		      sta	NUSIZ0	; 3 =	6
    572  11fe
    573  11fe		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    574  1201		       85 50		      sta	RESP0	; 3	     @33/36
    575  1203		       85 51		      sta	RESP1	; 3 = 10    @36/39
    576  1205
    577  1205		       84 60		      sty	HMP0	; 3
    578  1207		       c8		      iny		; 2
    579  1208		       84 61		      sty	HMP1	; 3 =	8
    580  120a				   SMCOLOR
    581  120a		       a0 9a		      ldy	#SCORE_COL	; 2
    582  120c		       84 46		      sty	COLUP0	; 3
    583  120e		       84 47		      sty	COLUP1	; 3 =	8
    584  1210
    585  1210		       a0 07		      ldy	#DIGIT_H	; 2
    586  1212		       60		      rts		; 6 =	8
    587  1213							; total: 27
    588  1213
    589  1213
    590  1213							;------------------------------------------------------------------------------
      0  1213					      DEFINE_SUBROUTINE	UpdateScore
      1  1213		       00 02	   BANK_UpdateScore =	_CURRENT_BANK
      2  1213					      SUBROUTINE
      3  1213				   UpdateScore
    592  1213							; a = added score value
    593  1213
    594  1213							; initially switch to score:
    595  1213		       a0 01		      ldy	#DISPLAY_SCORE
    596  1215		       84 db		      sty	newDisplay
    597  1217
    598  1217		       18		      clc
    599  1218		       f8		      sed
    600  1219		       a0 04		      ldy	#SM_OFS_SCORE
    601  121b				   .loopScore
    602  121b		       79 8a f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    603  121e		       99 8a f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    604  1221		       08		      php
    605  1222							; *** bonus life every 500 points: ***
    606  1222							;	  cpy #SM_OFS_SCORE+1
    607  1222							;	  bne .skipBonusLife
    608  1222							;	  tax
    609  1222
    610  1222							;	  and #$0f
    611  1222							;	  beq .bonusLife		      ; 000?
    612  1222							;	  cmp #$05
    613  1222							;	  bne .noBonusLife		      ; 500?
    614  1222							;.bonusLife:
    615  1222							; add extra life, limited to 9
    616  1222
    617  1222							;	  lda ManCount
    618  1222							;	  and #$0f
    619  1222							;	  cmp #9
    620  1222							;	  bcs .noBonusLife
    621  1222							;	  inc ManCount
    622  1222
    623  1222							; bonus life has priority over score:
    624  1222							;	  lda #DISPLAY_LIVES
    625  1222							;	  sta newDisplay
    626  1222							;lda #EXTRA_LIFE_TIMER
    627  1222							;sta extraLifeTimer
    628  1222
    629  1222				   .noBonusLife
    630  1222		       8a		      txa
    631  1223				   .skipBonusLife
    632  1223		       20 cc f2 	      jsr	SetupBCDPtr
    633  1226		       28		      plp
    634  1227		       a9 00		      lda	#0
    635  1229		       b0 f0		      bcs	.loopScore
    636  122b		       d8		      cld
    637  122c
    638  122c							; switch display
    639  122c		       a5 ca		      lda	scoringFlags
    640  122e		       29 03		      and	#DISPLAY_FLAGS
    641  1230		       c5 db		      cmp	newDisplay	; lower priority than current?
    642  1232		       f0 08		      beq	.restartTime
    643  1234		       b0 0a		      bcs	.skipNew
    644  1236		       45 ca		      eor	scoringFlags	; remove existing score mode
    645  1238		       05 db		      ora	newDisplay	; switch to new score mode
    646  123a		       85 ca		      sta	scoringFlags
    647  123c				   .restartTime
    648  123c		       a9 3c		      lda	#SCORING_TIMER	; maybe always restart timer?
    649  123e		       85 c9		      sta	scoringTimer
    650  1240				   .skipNew
    651  1240
    652  1240		       60		      rts
    653  1241
    654  1241							;---------------------------------------------------------------------------
    655  1241
      0  1241					      DEFINE_SUBROUTINE	SwapPlayers
      1  1241		       00 02	   BANK_SwapPlayers =	_CURRENT_BANK
      2  1241					      SUBROUTINE
      3  1241				   SwapPlayers
    657  1241
    658  1241							; assume no new high score:
    659  1241		       a0 ff		      ldy	#-1
    660  1243		       84 de		      sty	highScoreSK
    661  1245
    662  1245							; update highscore after last live:
    663  1245							;lda ManCount
    664  1245							;and #$0f			      ; player has lives left?
    665  1245							;bne .playerAlive		      ; YES, so we don't check high score
    666  1245
    667  1245							; check for a new high score:
    668  1245							;	  ldy #-1
    669  1245		       18		      clc		; score has to be at least 1 bigger!
    670  1246				   .loopCheckHighScore
    671  1246		       c8		      iny
    672  1247		       b9 8e f3 	      lda	ScoreCurrent,y
    673  124a		       f9 98 f3 	      sbc	HighScore,y
    674  124d		       98		      tya
    675  124e		       49 02		      eor	#2
    676  1250		       d0 f4		      bne	.loopCheckHighScore
    677  1252		       90 0d		      bcc	.noHighScore
    678  1254
    679  1254							; new high score, update:
    680  1254		       a2 04		      ldx	#5-1
    681  1256				   .loopSetHighScore
    682  1256		       bd 8e f3 	      lda	ScoreCurrent,x
    683  1259		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
    684  125c		       95 de		      sta	highScoreSK,x
    685  125e		       ca		      dex
    686  125f		       10 f5		      bpl	.loopSetHighScore
    687  1261				   .noHighScore
    688  1261
    689  1261				   .playerAlive
    690  1261							;lda ManCount
    691  1261							;and #$f0			      ; other player has lives left?
    692  1261							;beq .otherPlayerDead		      ; NO, so we don't swap scores
    693  1261
    694  1261							; save the current player variables to the player's backup:
    695  1261		       a0 02		      ldy	#3-1
    696  1263				   .swapScore
    697  1263		       be 93 f3 	      ldx	PlayerScores,y
    698  1266		       b9 8e f3 	      lda	ScoreCurrent,y
    699  1269		       99 93 f7 	      sta	PlayerScores+RAM_WRITE,y
    700  126c		       8a		      txa
    701  126d		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
    702  1270		       88		      dey
    703  1271		       10 f0		      bpl	.swapScore
    704  1273
    705  1273							; swap levelx and level:
    706  1273		       a2 01		      ldx	#1
    707  1275				   .loopLevelXLevel
    708  1275		       bc 96 f3 	      ldy	PlayerLevelX,x
    709  1278		       b5 b3		      lda	levelX,x
    710  127a		       9d 96 f7 	      sta	PlayerLevelX+RAM_WRITE,x
    711  127d		       94 b3		      sty	levelX,x
    712  127f		       ca		      dex
    713  1280		       10 f3		      bpl	.loopLevelXLevel
    714  1282
    715  1282				   .otherPlayerDead
    716  1282		       60		      rts
    717  1283
    718  1283							;---------------------------------------------------------------------------
    719  1283
    720  1283				   HighScoreColTbl
    721  1283		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    722  1285		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    723  1287
      0  1287					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  1287		       00 02	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  1287					      SUBROUTINE
      3  1287				   GeneralScoringSetups
    725  1287
    726  1287		       a0 04		      ldy	#SM_OFS_SCORE
    727  1289				   .loopScore2
    728  1289		       a5 ca		      lda	scoringFlags
    729  128b		       29 03		      and	#DISPLAY_FLAGS
    730  128d		       c9 03		      cmp	#DISPLAY_HIGH
    731  128f		       a6 80		      ldx	Platform
    732  1291		       bd 83 f2 	      lda	HighScoreColTbl,x
    733  1294		       aa		      tax
    734  1295		       b9 94 f3 	      lda	HighScore-SM_OFS_SCORE,y
    735  1298		       b0 05		      bcs	.showHighScore
    736  129a		       a2 9a		      ldx	#SCORE_COL
    737  129c		       b9 8a f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    738  129f				   .showHighScore
    739  129f		       8e 0b f6 	      stx	SMCOLOR+1+RAM_WRITE
    740  12a2		       20 cc f2 	      jsr	SetupBCDPtr
    741  12a5		       c0 07		      cpy	#SM_OFS_SCORE+3
    742  12a7		       90 e0		      bcc	.loopScore2
    743  12a9
    744  12a9							; display number of lives in leftmost digit of middle score XX nX XX
    745  12a9
    746  12a9							;lda ManCount
    747  12a9							;and #$0f
    748  12a9							;tay
    749  12a9							;lda DigitVectorLOr,y
    750  12a9							;sta SMMEN+1+RAM_WRITE
    751  12a9
    752  12a9							; modify player number pointer (Xp XX XX)
    753  12a9
    754  12a9							;ldy whichPlayer
    755  12a9							;lda DigitVectorLOr+1,y
    756  12a9							;sta SMPLAYER+1+RAM_WRITE
    757  12a9
    758  12a9							; fall through
    759  12a9
    760  12a9							;    ;---------------------------------------------------------------------------
    761  12a9
    762  12a9							; modify levelx character pointer (XX XX cX)
    763  12a9
    764  12a9							;ldx #<charPlace-1
    765  12a9							;lda levelDisplay
    766  12a9							;cmp #$80
    767  12a9							;and #$1f
    768  12a9							;tay
    769  12a9							;bcs .intermission
    770  12a9							;ldx CharVectorLO,y
    771  12a9							;ldy level
    772  12a9							;.intermission
    773  12a9							;stx SMLEVELX+1+RAM_WRITE
    774  12a9
    775  12a9							; modify level number pointer (XX XX Xl)
    776  12a9
    777  12a9							;lda DigitVectorLOr+1,y
    778  12a9							;sta SMLEVEL+1+RAM_WRITE
    779  12a9
    780  12a9							;---------------------------------------------------------------------------
    781  12a9
    782  12a9		       4c c3 f2 	      jmp	SetupTimePtr	; modify time pointers
    783  12ac
    784  12ac							;------------------------------------------------------------------------------
    785  12ac							;    DEFINE_SUBROUTINE SetupGameOverPtr
    786  12ac
    787  12ac							;		  ldy #8-1
    788  12ac							;.loopGameOver:
    789  12ac							;		  ldx SMGameOverOfs,y
    790  12ac							;		  lda SMGameOverPtr,y
    791  12ac							;		  sta SM_BASE+1+RAM_WRITE,x
    792  12ac							;		  dey
    793  12ac							;		  bpl .loopGameOver
    794  12ac
    795  12ac							;		  rts
    796  12ac
    797  12ac							;SMGameOverOfs:
    798  12ac							;		  .byte <SM_TARGET3-SM_BASE, <SM_TARGET2-SM_BASE
    799  12ac							;		  .byte <SM_TARGET1-SM_BASE, <SM_TARGET0-SM_BASE
    800  12ac							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    801  12ac							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    802  12ac							;SMGameOverPtr:
    803  12ac							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    804  12ac							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    805  12ac
    806  12ac							;------------------------------------------------------------------------------
    807  12ac
      0  12ac					      DEFINE_SUBROUTINE	DrawBCD_targetsRequired
      1  12ac		       00 02	   BANK_DrawBCD_targetsRequired =	_CURRENT_BANK
      2  12ac					      SUBROUTINE
      3  12ac				   DrawBCD_targetsRequired
    809  12ac							; Show current TARGET counter in the top left
    810  12ac
    811  12ac		       a0 00		      ldy	#SM_OFS_TARGETS
    812  12ae		       a5 b7		      lda	BCD_targetsRequired
    813  12b0		       20 cc f2 	      jsr	SetupBCDPtr
    814  12b3
    815  12b3		       a9 b0		      lda	#ID_TARGET<<4	; if no extra targets, display the normal icon
    816  12b5		       24 ca		      bit	scoringFlags	;
    817  12b7		       10 13		      bpl	SetupBCDPtr
    818  12b9		       a9 c0		      lda	#ID_EXTRA<<4	; otherwise, display the extra icon
    819  12bb		       50 0f		      bvc	SetupBCDPtr
    820  12bd		       09 01		      ora	#1	; display 1xx targets
    821  12bf		       d0 0b		      bne	SetupBCDPtr	; unconditional
    822  12c1
    823  12c1							;------------------------------------------------------------------------------
      0  12c1					      DEFINE_SUBROUTINE	DrawTime
      1  12c1		       00 02	   BANK_DrawTime =	_CURRENT_BANK
      2  12c1					      SUBROUTINE
      3  12c1				   DrawTime
    825  12c1
    826  12c1							; mid-digit-change, but we may be required to flash/display
    827  12c1		       a0 02		      ldy	#SM_OFS_TIME
    828  12c3							;------------------------------------------------------------------------------
      0  12c3					      DEFINE_SUBROUTINE	SetupTimePtr
      1  12c3		       00 02	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  12c3					      SUBROUTINE
      3  12c3				   SetupTimePtr
    830  12c3
    831  12c3		       a5 b8		      lda	BCD_moveCounter
    832  12c5		       20 cc f2 	      jsr	SetupBCDPtr
    833  12c8		       a5 b9		      lda	BCD_moveCounter+1
    834  12ca		       09 d0		      ora	#ID_CLOCK<<4
    835  12cc
    836  12cc							; fall through
    837  12cc
    838  12cc							;------------------------------------------------------------------------------
      0  12cc					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  12cc		       00 02	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  12cc					      SUBROUTINE
      3  12cc				   SetupBCDPtr
    840  12cc
    841  12cc							; a = BCD value
    842  12cc							; y = SM table offset
    843  12cc
    844  12cc		       48		      pha
    845  12cd		       29 0f		      and	#$0f
    846  12cf		       aa		      tax
    847  12d0		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    848  12d3		       be 19 f0 	      ldx	SMTblLSB,y
    849  12d6		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    850  12d9		       68		      pla
    851  12da		       4a		      lsr
    852  12db		       4a		      lsr
    853  12dc		       4a		      lsr
    854  12dd		       4a		      lsr
    855  12de		       aa		      tax
    856  12df		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    857  12e2		       be 20 f0 	      ldx	SMTblMSB,y
    858  12e5		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    859  12e8
    860  12e8		       c8		      iny
    861  12e9
    862  12e9		       a5 c4		      lda	ROM_Bank
    863  12eb				   RTS
    864  12eb		       60		      rts
    865  12ec
      0  12ec					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
 PAGE BREAK INSERTED FOR  LeftDigits
 REQUESTED SIZE =  $5b
 WASTED SPACE =  $14
 PAGEBREAK LOCATION =  $f300
     10  1300					      LIST	ON
    867  1300
    868  1300					      IF	<. = 0
    869  1300		       00		      .byte.b	0	; required!
    870  1301					      ENDIF
    871  1301
    872  1301				   BLANKR
    873  1301		       00 00 00 00*	      .ds	DIGIT_H, 0
    874  1308
    875  1308				   DequalsR
    876  1308		       00		      .byte.b	%00000000
    877  1309		       00		      .byte.b	%00000000
    878  130a		       f0		      .byte.b	%11110000
    879  130b		       00		      .byte.b	%00000000
    880  130c		       f0		      .byte.b	%11110000
    881  130d		       00		      .byte.b	%00000000
    882  130e		       f0		      .byte.b	%11110000
    883  130f				   DplusR
    884  130f		       10		      .byte.b	%00010000
    885  1310		       28		      .byte.b	%00101000
    886  1311		       6c		      .byte.b	%01101100
    887  1312		       c6		      .byte.b	%11000110
    888  1313		       6c		      .byte.b	%01101100
    889  1314		       28		      .byte.b	%00101000
    890  1315		       10		      .byte.b	%00010000
    891  1316
    892  1316				   ClockR
    893  1316		       00		      .byte.b	%00000000
    894  1317		       48		      .byte.b	%01001000
    895  1318		       fc		      .byte.b	%11111100
    896  1319		       48		      .byte.b	%01001000
    897  131a		       48		      .byte.b	%01001000
    898  131b		       fc		      .byte.b	%11111100
    899  131c		       48		      .byte.b	%01001000
    900  131d				   NineR
    901  131d		       0f		      .byte.b	%00001111
    902  131e		       01		      .byte.b	%00000001
    903  131f		       01		      .byte.b	%00000001
    904  1320		       7f		      .byte.b	%01111111
    905  1321		       41		      .byte.b	%01000001
    906  1322		       41		      .byte.b	%01000001
    907  1323		       7f		      .byte.b	%01111111
    908  1324				   SixR
    909  1324		       7f		      .byte.b	%01111111
    910  1325		       41		      .byte.b	%01000001
    911  1326		       41		      .byte.b	%01000001
    912  1327		       7f		      .byte.b	%01111111
    913  1328		       40		      .byte.b	%01000000
    914  1329		       40		      .byte.b	%01000000
    915  132a		       78		      .byte.b	%01111000
    916  132b				   EightR
    917  132b							;  .byte %00111110
    918  132b							;  .byte %01000011
    919  132b							;  .byte %01000011
    920  132b							;  .byte %00111110
    921  132b							;  .byte %00100011
    922  132b							;  .byte %00100011
    923  132b							;  .byte %00011110
    924  132b
    925  132b
    926  132b		       7f		      .byte.b	%01111111
    927  132c		       41		      .byte.b	%01000001
    928  132d		       41		      .byte.b	%01000001
    929  132e		       7f		      .byte.b	%01111111
    930  132f		       41		      .byte.b	%01000001
    931  1330		       41		      .byte.b	%01000001
    932  1331		       7f		      .byte.b	%01111111
    933  1332
    934  1332				   ZeroR
    935  1332		       7f		      .byte.b	%01111111
    936  1333		       41		      .byte.b	%01000001
    937  1334		       41		      .byte.b	%01000001
    938  1335		       41		      .byte.b	%01000001
    939  1336		       41		      .byte.b	%01000001
    940  1337		       41		      .byte.b	%01000001
    941  1338		       7f		      .byte.b	%01111111
    942  1339
    943  1339							;	  .byte %00111110
    944  1339							;	  .byte %01000011
    945  1339							;	  .byte %01000011
    946  1339							;	  .byte %01000011
    947  1339							;	  .byte %01000011
    948  1339							;	  .byte %00100011
    949  1339							;	  .byte %00011110
    950  1339				   ThreeR
    951  1339		       7f		      .byte.b	%01111111
    952  133a		       01		      .byte.b	%00000001
    953  133b		       01		      .byte.b	%00000001
    954  133c		       0f		      .byte.b	%00001111
    955  133d		       01		      .byte.b	%00000001
    956  133e		       01		      .byte.b	%00000001
    957  133f		       7f		      .byte.b	%01111111
    958  1340				   OneR
    959  1340		       08		      .byte.b	%00001000
    960  1341		       08		      .byte.b	%00001000
    961  1342		       08		      .byte.b	%00001000
    962  1343		       08		      .byte.b	%00001000
    963  1344		       08		      .byte.b	%00001000
    964  1345		       08		      .byte.b	%00001000
    965  1346		       08		      .byte.b	%00001000
    966  1347
    967  1347				   SevenR
    968  1347		       08		      .byte.b	%00001000
    969  1348		       08		      .byte.b	%00001000
    970  1349		       08		      .byte.b	%00001000
    971  134a		       0f		      .byte.b	%00001111
    972  134b		       01		      .byte.b	%00000001
    973  134c		       01		      .byte.b	%00000001
    974  134d		       7f		      .byte.b	%01111111
    975  134e
    976  134e				   TwoR
    977  134e		       7f		      .byte.b	%01111111
    978  134f		       40		      .byte.b	%01000000
    979  1350		       40		      .byte.b	%01000000
    980  1351		       7f		      .byte.b	%01111111
    981  1352		       01		      .byte.b	%00000001
    982  1353		       01		      .byte.b	%00000001
    983  1354		       7f		      .byte.b	%01111111
    984  1355				   FiveR
    985  1355		       7f		      .byte.b	%01111111
    986  1356		       01		      .byte.b	%00000001
    987  1357		       01		      .byte.b	%00000001
    988  1358		       7f		      .byte.b	%01111111
    989  1359		       40		      .byte.b	%01000000
    990  135a		       40		      .byte.b	%01000000
    991  135b		       78		      .byte.b	%01111000
    992  135c				   FourR
    993  135c		       08		      .byte.b	%00001000
    994  135d		       08		      .byte.b	%00001000
    995  135e		       08		      .byte.b	%00001000
    996  135f		       7f		      .byte.b	%01111111
    997  1360		       48		      .byte.b	%01001000
    998  1361		       48		      .byte.b	%01001000
    999  1362		       48		      .byte.b	%01001000
   1000  1363
   1001  1363							;CharAL:
   1002  1363							;    .byte %11100110
   1003  1363							;    .byte %11100110
   1004  1363							;    .byte %11111110
   1005  1363							;    .byte %11100110
   1006  1363							;    .byte %11100110
   1007  1363							;    .byte %01111100
   1008  1363							;    .byte %00111000
   1009  1363							;CharEL:
   1010  1363							;    .byte %11111110
   1011  1363							;    .byte %11111110
   1012  1363							;    .byte %11100000
   1013  1363							;    .byte %11100000
   1014  1363							;    .byte %11111100
   1015  1363							;    .byte %11100000
   1016  1363							;    .byte %11111110
   1017  1363							;CharRL:
   1018  1363							;    .byte %11100110
   1019  1363							;    .byte %11100110
   1020  1363							;    .byte %11111100
   1021  1363							;    .byte %11111100
   1022  1363							;    .byte %11100110
   1023  1363							;    .byte %11100110
   1024  1363							;    .byte %11111100
   1025  1363							;CharVL:
   1026  1363							;    .byte %00111000
   1027  1363							;    .byte %01111100
   1028  1363							;    .byte %11100110
   1029  1363							;    .byte %11100110
   1030  1363							;    .byte %11100110
   1031  1363							;    .byte %11100110
   1032  1363							;    .byte %11100110
   1033  1363
      0  1363					      CHECKPAGE	BLANKR
      8  1363					      LIST	ON
   1035  1363
   1036  1363							;---------------------------------------------------------------------------
   1037  1363
      0  1363					      DEFINE_SUBROUTINE	GameInitialise
      1  1363		       00 02	   BANK_GameInitialise =	_CURRENT_BANK
      2  1363					      SUBROUTINE
      3  1363				   GameInitialise
   1039  1363
   1040  1363							; copy loaded SK high score into scoring RAM:
   1041  1363		       a2 02		      ldx	#3-1
   1042  1365				   .loopCopyHighScore
   1043  1365		       b5 de		      lda	highScoreSK,x
   1044  1367		       c9 ff		      cmp	#$ff
   1045  1369		       f0 06		      beq	.noSaveKey
   1046  136b		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
   1047  136e		       ca		      dex
   1048  136f		       10 f4		      bpl	.loopCopyHighScore
   1049  1371				   .noSaveKey
   1050  1371
   1051  1371							; clear both players scores
   1052  1371		       a0 05		      ldy	#2*3-1
   1053  1373		       a9 00		      lda	#0
   1054  1375				   .loopClearScore
   1055  1375		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
   1056  1378		       88		      dey
   1057  1379		       10 fa		      bpl	.loopClearScore
   1058  137b
   1059  137b							; copy levelX and level for other player and SaveKey:
   1060  137b		       a5 b3		      lda	levelX
   1061  137d		       8d 96 f7 	      sta	PlayerLevelX+RAM_WRITE
   1062  1380		       a5 e1		      lda	startingLevel
   1063  1382		       8d 91 f7 	      sta	StartLevelX+RAM_WRITE
   1064  1385		       a5 b4		      lda	level
   1065  1387		       8d 97 f7 	      sta	PlayerLevel+RAM_WRITE
   1066  138a		       8d 92 f7 	      sta	StartLevel+RAM_WRITE
   1067  138d		       60		      rts
   1068  138e
   1069  138e							;---------------------------------------------------------------------------
   1070  138e
   1071  138e		       00 00 00    ScoreCurrent ds	3, 0
   1072  1391							; start levelx and level have to be after ScoreCurrent!
   1073  1391		       00	   StartLevelX .byte.b	0
   1074  1392		       00	   StartLevel .byte.b	0
   1075  1393		       00 00 00    PlayerScores ds	3, 0
   1076  1396							; levelx and level have to be consecutive variables!
   1077  1396		       00	   PlayerLevelX .byte.b	0
   1078  1397		       00	   PlayerLevel .byte.b	0
   1079  1398		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1080  139d
   1081  139d
   1082  139d
   1083  139d							;------------------------------------------------------------------------------
   1084  139d
      0  139d					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  139d
      2  139d
      3  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $39d , FREE= $63
      4  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  139d				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  139d				  -	      ERR
      8  139d					      endif
   1086  139d
   1087  139d							;------------------------------------------------------------------------------
   1088  139d
   1089  139d							; LEVEL DATA banks can go anywhere - *EXCEPT* for the same bank as the level
   1090  139d							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_LEVEL_SIZE
   1091  139d							; which is used as a buffer size inside UnpackLevel.  It's not important if
   1092  139d							; this is defined before or after, as once the levels have processed it will be
   1093  139d							; correct. Note, that levels should all be defined BEFORE *OR* AFTER the
   1094  139d							; UnpackLevel code -- but that they should not be both, nor in the same bank.
   1095  139d							; TODO: verify above is still valid
   1096  139d
   1097  139d
      0  139d					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $39d , FREE= $463
      2  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  139d				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  139d				  -	      ERR
      6  139d					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 3
      0  139d					      include	"BANK_GENERIC.asm"
      1  139d							;    Sokoboo - a Sokoban implementation
      2  139d							;    using a generic tile-based display engine for the Atari 2600
      3  139d							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  139d							;
      5  139d							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  139d							;
      7  139d							;    Code related to the generic tile-based display engine was developed by
      8  139d							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  139d							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  139d							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  139d							;
     12  139d							;    Code related to music and sound effects uses the TIATracker music player
     13  139d							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  139d							;    directory for Apache licensing details.
     15  139d							;
     16  139d							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  139d							;    See the copyright notices in the License directory for a list of level
     18  139d							;    contributors.
     19  139d							;
     20  139d							;    Except where otherwise indicated, this software is released under the
     21  139d							;    following licensing arrangement...
     22  139d							;
     23  139d							;    This program is free software: you can redistribute it and/or modify
     24  139d							;    it under the terms of the GNU General Public License as published by
     25  139d							;    the Free Software Foundation, either version 3 of the License, or
     26  139d							;    (at your option) any later version.
     27  139d							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  139d
     29  139d							;    This program is distributed in the hope that it will be useful,
     30  139d							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  139d							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  139d							;    GNU General Public License for more details.
     33  139d
     34  139d							;------------------------------------------------------------------------------
     35  139d							;##############################################################################
     36  139d							;------------------------------------------------------------------------------
     37  139d
      0  139d					      NEWBANK	GENERIC_BANK_1
      1  1e57 ????				      SEG	GENERIC_BANK_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	GENERIC_BANK_1
     39  1800
     40  1800
     41  1800
      0  1800					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  1800					      ALIGN	$400
      2  1800				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  1800				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
------- FILE DecodeLevel.asm LEVEL 3 PASS 3
      0  1800					      include	"DecodeLevel.asm"
      1  1800							;    Sokoboo - a Sokoban implementation
      2  1800							;    using a generic tile-based display engine for the Atari 2600
      3  1800							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1800							;
      5  1800							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1800							;
      7  1800							;    Code related to the generic tile-based display engine was developed by
      8  1800							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1800							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1800							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1800							;
     12  1800							;    Code related to music and sound effects uses the TIATracker music player
     13  1800							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1800							;    directory for Apache licensing details.
     15  1800							;
     16  1800							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1800							;    See the copyright notices in the License directory for a list of level
     18  1800							;    contributors.
     19  1800							;
     20  1800							;    Except where otherwise indicated, this software is released under the
     21  1800							;    following licensing arrangement...
     22  1800							;
     23  1800							;    This program is free software: you can redistribute it and/or modify
     24  1800							;    it under the terms of the GNU General Public License as published by
     25  1800							;    the Free Software Foundation, either version 3 of the License, or
     26  1800							;    (at your option) any later version.
     27  1800							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1800
     29  1800							;    This program is distributed in the hope that it will be useful,
     30  1800							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1800							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1800							;    GNU General Public License for more details.
     33  1800
     34  1800							; The ordering here corresponds to the ordering when playing...
     35  1800
     36  1800				   LevelInfoLO
     37  1800		       ff		      .byte.b	<(LEVEL__001_L-1)
     38  1801		       11		      .byte.b	<(LEVEL__001_R-1)
     39  1802		       1d		      .byte.b	<(LEVEL__002_L-1)
     40  1803		       36		      .byte.b	<(LEVEL__002_R-1)
     41  1804		       5e		      .byte.b	<(LEVEL__003_L-1)
     42  1805		       8a		      .byte.b	<(LEVEL__003_R-1)
     43  1806		       b4		      .byte.b	<(LEVEL__004_L-1)
     44  1807		       d7		      .byte.b	<(LEVEL__004_R-1)
     45  1808		       f3		      .byte.b	<(LEVEL__005_L-1)
     46  1809		       25		      .byte.b	<(LEVEL__005_R-1)
     47  180a		       64		      .byte.b	<(LEVEL__006_L-1)
     48  180b		       9f		      .byte.b	<(LEVEL__006_R-1)
     49  180c		       dd		      .byte.b	<(LEVEL__007_L-1)
     50  180d		       0a		      .byte.b	<(LEVEL__007_R-1)
     51  180e		       3d		      .byte.b	<(LEVEL__008_L-1)
     52  180f		       73		      .byte.b	<(LEVEL__008_R-1)
     53  1810		       a4		      .byte.b	<(LEVEL__009_L-1)
     54  1811		       d6		      .byte.b	<(LEVEL__009_R-1)
     55  1812		       06		      .byte.b	<(LEVEL__010_L-1)
     56  1813		       40		      .byte.b	<(LEVEL__010_R-1)
     57  1814		       73		      .byte.b	<(LEVEL__011_L-1)
     58  1815		       a6		      .byte.b	<(LEVEL__011_R-1)
     59  1816		       e0		      .byte.b	<(LEVEL__012_L-1)
     60  1817		       10		      .byte.b	<(LEVEL__012_R-1)
     61  1818		       4c		      .byte.b	<(LEVEL__013_L-1)
     62  1819		       8b		      .byte.b	<(LEVEL__013_R-1)
     63  181a		       be		      .byte.b	<(LEVEL__014_L-1)
     64  181b		       01		      .byte.b	<(LEVEL__014_R-1)
     65  181c		       44		      .byte.b	<(LEVEL__015_L-1)
     66  181d		       79		      .byte.b	<(LEVEL__015_R-1)
     67  181e		       be		      .byte.b	<(LEVEL__016_L-1)
     68  181f		       f5		      .byte.b	<(LEVEL__016_R-1)
     69  1820		       28		      .byte.b	<(LEVEL__017_L-1)
     70  1821		       72		      .byte.b	<(LEVEL__017_R-1)
     71  1822		       b5		      .byte.b	<(LEVEL__018_L-1)
     72  1823		       e9		      .byte.b	<(LEVEL__018_R-1)
     73  1824		       25		      .byte.b	<(LEVEL__019_L-1)
     74  1825		       60		      .byte.b	<(LEVEL__019_R-1)
     75  1826		       ff		      .byte.b	<(LEVEL__020_L-1)
     76  1827		       3e		      .byte.b	<(LEVEL__020_R-1)
     77  1828		       7e		      .byte.b	<(LEVEL__021_L-1)
     78  1829		       d4		      .byte.b	<(LEVEL__021_R-1)
     79  182a		       08		      .byte.b	<(LEVEL__022_L-1)
     80  182b		       4e		      .byte.b	<(LEVEL__022_R-1)
     81  182c		       8a		      .byte.b	<(LEVEL__023_L-1)
     82  182d		       cb		      .byte.b	<(LEVEL__023_R-1)
     83  182e		       0d		      .byte.b	<(LEVEL__024_L-1)
     84  182f		       5d		      .byte.b	<(LEVEL__024_R-1)
     85  1830		       a5		      .byte.b	<(LEVEL__025_L-1)
     86  1831		       e8		      .byte.b	<(LEVEL__025_R-1)
     87  1832		       27		      .byte.b	<(LEVEL__026_L-1)
     88  1833		       60		      .byte.b	<(LEVEL__026_R-1)
     89  1834		       a1		      .byte.b	<(LEVEL__027_L-1)
     90  1835		       df		      .byte.b	<(LEVEL__027_R-1)
     91  1836		       1d		      .byte.b	<(LEVEL__028_L-1)
     92  1837		       69		      .byte.b	<(LEVEL__028_R-1)
     93  1838		       b7		      .byte.b	<(LEVEL__029_L-1)
     94  1839		       fc		      .byte.b	<(LEVEL__029_R-1)
     95  183a		       40		      .byte.b	<(LEVEL__030_L-1)
     96  183b		       90		      .byte.b	<(LEVEL__030_R-1)
     97  183c		       e3		      .byte.b	<(LEVEL__031_L-1)
     98  183d		       29		      .byte.b	<(LEVEL__031_R-1)
     99  183e		       68		      .byte.b	<(LEVEL__032_L-1)
    100  183f		       a0		      .byte.b	<(LEVEL__032_R-1)
    101  1840		       e4		      .byte.b	<(LEVEL__033_L-1)
    102  1841		       2e		      .byte.b	<(LEVEL__033_R-1)
    103  1842		       6e		      .byte.b	<(LEVEL__034_L-1)
    104  1843		       ff		      .byte.b	<(LEVEL__034_R-1)
    105  1844		       48		      .byte.b	<(LEVEL__035_L-1)
    106  1845		       8d		      .byte.b	<(LEVEL__035_R-1)
    107  1846		       cd		      .byte.b	<(LEVEL__036_L-1)
    108  1847		       03		      .byte.b	<(LEVEL__036_R-1)
    109  1848		       49		      .byte.b	<(LEVEL__037_L-1)
    110  1849		       86		      .byte.b	<(LEVEL__037_R-1)
    111  184a		       cf		      .byte.b	<(LEVEL__038_L-1)
    112  184b		       17		      .byte.b	<(LEVEL__038_R-1)
    113  184c		       66		      .byte.b	<(LEVEL__039_L-1)
    114  184d		       b5		      .byte.b	<(LEVEL__039_R-1)
    115  184e		       0f		      .byte.b	<(LEVEL__040_L-1)
    116  184f		       56		      .byte.b	<(LEVEL__040_R-1)
    117  1850
    118  1850		       9d		      .byte.b	<(LEVEL__041_L-1)
    119  1851		       e7		      .byte.b	<(LEVEL__041_R-1)
    120  1852		       2e		      .byte.b	<(LEVEL__042_L-1)
    121  1853		       7c		      .byte.b	<(LEVEL__042_R-1)
    122  1854		       d4		      .byte.b	<(LEVEL__043_L-1)
    123  1855		       21		      .byte.b	<(LEVEL__043_R-1)
    124  1856		       6d		      .byte.b	<(LEVEL__044_L-1)
    125  1857		       a5		      .byte.b	<(LEVEL__044_R-1)
    126  1858		       f5		      .byte.b	<(LEVEL__045_L-1)
    127  1859		       43		      .byte.b	<(LEVEL__045_R-1)
    128  185a		       8d		      .byte.b	<(LEVEL__046_L-1)
    129  185b		       da		      .byte.b	<(LEVEL__046_R-1)
    130  185c		       1f		      .byte.b	<(LEVEL__047_L-1)
    131  185d		       75		      .byte.b	<(LEVEL__047_R-1)
    132  185e		       ff		      .byte.b	<(LEVEL__048_L-1)
    133  185f		       4b		      .byte.b	<(LEVEL__048_R-1)
    134  1860		       96		      .byte.b	<(LEVEL__049_L-1)
    135  1861		       e8		      .byte.b	<(LEVEL__049_R-1)
    136  1862
    137  1862		       2b		      .byte.b	<(LEVEL__050_L-1)
    138  1863		       78		      .byte.b	<(LEVEL__050_R-1)
    139  1864		       b1		      .byte.b	<(LEVEL__051_L-1)
    140  1865		       04		      .byte.b	<(LEVEL__051_R-1)
    141  1866		       55		      .byte.b	<(LEVEL__052_L-1)
    142  1867		       8f		      .byte.b	<(LEVEL__052_R-1)
    143  1868		       d7		      .byte.b	<(LEVEL__053_L-1)
    144  1869		       2c		      .byte.b	<(LEVEL__053_R-1)
    145  186a		       79		      .byte.b	<(LEVEL__054_L-1)
    146  186b		       c5		      .byte.b	<(LEVEL__054_R-1)
    147  186c		       0e		      .byte.b	<(LEVEL__055_L-1)
    148  186d		       68		      .byte.b	<(LEVEL__055_R-1)
    149  186e		       bd		      .byte.b	<(LEVEL__056_L-1)
    150  186f		       17		      .byte.b	<(LEVEL__056_R-1)
    151  1870		       72		      .byte.b	<(LEVEL__057_L-1)
    152  1871		       c8		      .byte.b	<(LEVEL__057_R-1)
    153  1872		       11		      .byte.b	<(LEVEL__058_L-1)
    154  1873		       56		      .byte.b	<(LEVEL__058_R-1)
    155  1874		       a6		      .byte.b	<(LEVEL__059_L-1)
    156  1875		       f8		      .byte.b	<(LEVEL__059_R-1)
    157  1876
    158  1876		       ff		      .byte.b	<(LEVEL__060_R-1)
    159  1877		       9b		      .byte.b	<(LEVEL__061_R-1)
    160  1878		       47		      .byte.b	<(LEVEL__061_L-1)
    161  1879		       e4		      .byte.b	<(LEVEL__062_L-1)
    162  187a		       3b		      .byte.b	<(LEVEL__062_R-1)
    163  187b		       87		      .byte.b	<(LEVEL__063_L-1)
    164  187c		       d7		      .byte.b	<(LEVEL__063_R-1)
    165  187d		       84		      .byte.b	<(LEVEL__064_R-1)
    166  187e		       29		      .byte.b	<(LEVEL__064_L-1)
    167  187f		       28		      .byte.b	<(LEVEL__065_R-1)
    168  1880		       d0		      .byte.b	<(LEVEL__065_L-1)
    169  1881		       ca		      .byte.b	<(LEVEL__066_R-1)
    170  1882		       70		      .byte.b	<(LEVEL__066_L-1)
    171  1883		       6d		      .byte.b	<(LEVEL__067_R-1)
    172  1884		       20		      .byte.b	<(LEVEL__067_L-1)
    173  1885		       26		      .byte.b	<(LEVEL__068_R-1)
    174  1886		       d2		      .byte.b	<(LEVEL__068_L-1)
    175  1887		       ca		      .byte.b	<(LEVEL__069_R-1)
    176  1888		       7c		      .byte.b	<(LEVEL__069_L-1)
    177  1889
    178  1889		       e8		      .byte.b	<(LEVEL__103_Arielle-1)
    179  188a		       a1		      .byte.b	<(LEVEL__103_Ajalae-1)
    180  188b		       56		      .byte.b	<(LEVEL__103_Adin-1)
    181  188c		       e8		      .byte.b	<(LEVEL__102_Raven-1)
    182  188d		       a4		      .byte.b	<(LEVEL__102_Oralia-1)
    183  188e		       ff		      .byte.b	<(LEVEL__102_Natalie-1)
    184  188f		       45		      .byte.b	<(LEVEL__102_Mirabel-1)
    185  1890		       38		      .byte.b	<(LEVEL__1XJH_Tara_Gelson-1)
    186  1891		       72		      .byte.b	<(LEVEL__1R7X_Alison-1)
    187  1892		       9f		      .byte.b	<(LEVEL__1KWD_Cecile_Clayworth-1)
    188  1893		       d3		      .byte.b	<(LEVEL__1EKT_Samantha_Gelson-1)
    189  1894		       0c		      .byte.b	<(LEVEL__0VM5_Andrea_Wadd-1)
    190  1895		       39		      .byte.b	<(LEVEL__0PAL_Jill_Leatherby-1)
    191  1896		       63		      .byte.b	<(LEVEL__0IZ1_Sophia-1)
    192  1897		       8e		      .byte.b	<(LEVEL__0CNH_Alice-1)
    193  1898		       18		      .byte.b	<(LEVEL__122_Maya-1)
    194  1899
    195  1899		       00 99	   MAX_LEVEL  =	* - LevelInfoLO
 $99 LEVELS INSTALLED
    196  1899					      ECHO	MAX_LEVEL, "LEVELS INSTALLED"
    197  1899				   LevelInfoHI
    198  1899
    199  1899		       ef		      .byte.b	>(LEVEL__001_L-1)
    200  189a		       f0		      .byte.b	>(LEVEL__001_R-1)
    201  189b		       f0		      .byte.b	>(LEVEL__002_L-1)
    202  189c		       f0		      .byte.b	>(LEVEL__002_R-1)
    203  189d		       f0		      .byte.b	>(LEVEL__003_L-1)
    204  189e		       f0		      .byte.b	>(LEVEL__003_R-1)
    205  189f		       f0		      .byte.b	>(LEVEL__004_L-1)
    206  18a0		       f0		      .byte.b	>(LEVEL__004_R-1)
    207  18a1		       f0		      .byte.b	>(LEVEL__005_L-1)
    208  18a2		       f1		      .byte.b	>(LEVEL__005_R-1)
    209  18a3		       f1		      .byte.b	>(LEVEL__006_L-1)
    210  18a4		       f1		      .byte.b	>(LEVEL__006_R-1)
    211  18a5		       f1		      .byte.b	>(LEVEL__007_L-1)
    212  18a6		       f2		      .byte.b	>(LEVEL__007_R-1)
    213  18a7		       f2		      .byte.b	>(LEVEL__008_L-1)
    214  18a8		       f2		      .byte.b	>(LEVEL__008_R-1)
    215  18a9		       f2		      .byte.b	>(LEVEL__009_L-1)
    216  18aa		       f2		      .byte.b	>(LEVEL__009_R-1)
    217  18ab		       f3		      .byte.b	>(LEVEL__010_L-1)
    218  18ac		       f3		      .byte.b	>(LEVEL__010_R-1)
    219  18ad		       f3		      .byte.b	>(LEVEL__011_L-1)
    220  18ae		       f3		      .byte.b	>(LEVEL__011_R-1)
    221  18af		       f3		      .byte.b	>(LEVEL__012_L-1)
    222  18b0		       f4		      .byte.b	>(LEVEL__012_R-1)
    223  18b1		       f4		      .byte.b	>(LEVEL__013_L-1)
    224  18b2		       f4		      .byte.b	>(LEVEL__013_R-1)
    225  18b3		       f4		      .byte.b	>(LEVEL__014_L-1)
    226  18b4		       f5		      .byte.b	>(LEVEL__014_R-1)
    227  18b5		       f5		      .byte.b	>(LEVEL__015_L-1)
    228  18b6		       f5		      .byte.b	>(LEVEL__015_R-1)
    229  18b7		       f5		      .byte.b	>(LEVEL__016_L-1)
    230  18b8		       f5		      .byte.b	>(LEVEL__016_R-1)
    231  18b9		       f6		      .byte.b	>(LEVEL__017_L-1)
    232  18ba		       f6		      .byte.b	>(LEVEL__017_R-1)
    233  18bb		       f6		      .byte.b	>(LEVEL__018_L-1)
    234  18bc		       f6		      .byte.b	>(LEVEL__018_R-1)
    235  18bd		       f7		      .byte.b	>(LEVEL__019_L-1)
    236  18be		       f7		      .byte.b	>(LEVEL__019_R-1)
    237  18bf		       ef		      .byte.b	>(LEVEL__020_L-1)
    238  18c0		       f0		      .byte.b	>(LEVEL__020_R-1)
    239  18c1		       f0		      .byte.b	>(LEVEL__021_L-1)
    240  18c2		       f0		      .byte.b	>(LEVEL__021_R-1)
    241  18c3		       f1		      .byte.b	>(LEVEL__022_L-1)
    242  18c4		       f1		      .byte.b	>(LEVEL__022_R-1)
    243  18c5		       f1		      .byte.b	>(LEVEL__023_L-1)
    244  18c6		       f1		      .byte.b	>(LEVEL__023_R-1)
    245  18c7		       f2		      .byte.b	>(LEVEL__024_L-1)
    246  18c8		       f2		      .byte.b	>(LEVEL__024_R-1)
    247  18c9		       f2		      .byte.b	>(LEVEL__025_L-1)
    248  18ca		       f2		      .byte.b	>(LEVEL__025_R-1)
    249  18cb		       f3		      .byte.b	>(LEVEL__026_L-1)
    250  18cc		       f3		      .byte.b	>(LEVEL__026_R-1)
    251  18cd		       f3		      .byte.b	>(LEVEL__027_L-1)
    252  18ce		       f3		      .byte.b	>(LEVEL__027_R-1)
    253  18cf		       f4		      .byte.b	>(LEVEL__028_L-1)
    254  18d0		       f4		      .byte.b	>(LEVEL__028_R-1)
    255  18d1		       f4		      .byte.b	>(LEVEL__029_L-1)
    256  18d2		       f4		      .byte.b	>(LEVEL__029_R-1)
    257  18d3		       f5		      .byte.b	>(LEVEL__030_L-1)
    258  18d4		       f5		      .byte.b	>(LEVEL__030_R-1)
    259  18d5		       f5		      .byte.b	>(LEVEL__031_L-1)
    260  18d6		       f6		      .byte.b	>(LEVEL__031_R-1)
    261  18d7		       f6		      .byte.b	>(LEVEL__032_L-1)
    262  18d8		       f6		      .byte.b	>(LEVEL__032_R-1)
    263  18d9		       f6		      .byte.b	>(LEVEL__033_L-1)
    264  18da		       f7		      .byte.b	>(LEVEL__033_R-1)
    265  18db		       f7		      .byte.b	>(LEVEL__034_L-1)
    266  18dc		       ef		      .byte.b	>(LEVEL__034_R-1)
    267  18dd		       f0		      .byte.b	>(LEVEL__035_L-1)
    268  18de		       f0		      .byte.b	>(LEVEL__035_R-1)
    269  18df		       f0		      .byte.b	>(LEVEL__036_L-1)
    270  18e0		       f1		      .byte.b	>(LEVEL__036_R-1)
    271  18e1		       f1		      .byte.b	>(LEVEL__037_L-1)
    272  18e2		       f1		      .byte.b	>(LEVEL__037_R-1)
    273  18e3		       f1		      .byte.b	>(LEVEL__038_L-1)
    274  18e4		       f2		      .byte.b	>(LEVEL__038_R-1)
    275  18e5		       f2		      .byte.b	>(LEVEL__039_L-1)
    276  18e6		       f2		      .byte.b	>(LEVEL__039_R-1)
    277  18e7		       f3		      .byte.b	>(LEVEL__040_L-1)
    278  18e8		       f3		      .byte.b	>(LEVEL__040_R-1)
    279  18e9
    280  18e9		       f3		      .byte.b	>(LEVEL__041_L-1)
    281  18ea		       f3		      .byte.b	>(LEVEL__041_R-1)
    282  18eb		       f4		      .byte.b	>(LEVEL__042_L-1)
    283  18ec		       f4		      .byte.b	>(LEVEL__042_R-1)
    284  18ed		       f4		      .byte.b	>(LEVEL__043_L-1)
    285  18ee		       f5		      .byte.b	>(LEVEL__043_R-1)
    286  18ef		       f5		      .byte.b	>(LEVEL__044_L-1)
    287  18f0		       f5		      .byte.b	>(LEVEL__044_R-1)
    288  18f1		       f5		      .byte.b	>(LEVEL__045_L-1)
    289  18f2		       f6		      .byte.b	>(LEVEL__045_R-1)
    290  18f3		       f6		      .byte.b	>(LEVEL__046_L-1)
    291  18f4		       f6		      .byte.b	>(LEVEL__046_R-1)
    292  18f5		       f7		      .byte.b	>(LEVEL__047_L-1)
    293  18f6		       f7		      .byte.b	>(LEVEL__047_R-1)
    294  18f7		       ef		      .byte.b	>(LEVEL__048_L-1)
    295  18f8		       f0		      .byte.b	>(LEVEL__048_R-1)
    296  18f9		       f0		      .byte.b	>(LEVEL__049_L-1)
    297  18fa		       f0		      .byte.b	>(LEVEL__049_R-1)
    298  18fb
    299  18fb		       f1		      .byte.b	>(LEVEL__050_L-1)
    300  18fc		       f1		      .byte.b	>(LEVEL__050_R-1)
    301  18fd		       f1		      .byte.b	>(LEVEL__051_L-1)
    302  18fe		       f2		      .byte.b	>(LEVEL__051_R-1)
    303  18ff		       f2		      .byte.b	>(LEVEL__052_L-1)
    304  1900		       f2		      .byte.b	>(LEVEL__052_R-1)
    305  1901		       f2		      .byte.b	>(LEVEL__053_L-1)
    306  1902		       f3		      .byte.b	>(LEVEL__053_R-1)
    307  1903		       f3		      .byte.b	>(LEVEL__054_L-1)
    308  1904		       f3		      .byte.b	>(LEVEL__054_R-1)
    309  1905		       f4		      .byte.b	>(LEVEL__055_L-1)
    310  1906		       f4		      .byte.b	>(LEVEL__055_R-1)
    311  1907		       f4		      .byte.b	>(LEVEL__056_L-1)
    312  1908		       f5		      .byte.b	>(LEVEL__056_R-1)
    313  1909		       f5		      .byte.b	>(LEVEL__057_L-1)
    314  190a		       f5		      .byte.b	>(LEVEL__057_R-1)
    315  190b		       f6		      .byte.b	>(LEVEL__058_L-1)
    316  190c		       f6		      .byte.b	>(LEVEL__058_R-1)
    317  190d		       f6		      .byte.b	>(LEVEL__059_L-1)
    318  190e		       f6		      .byte.b	>(LEVEL__059_R-1)
    319  190f
    320  190f		       ef		      .byte.b	>(LEVEL__060_R-1)
    321  1910		       f0		      .byte.b	>(LEVEL__061_R-1)
    322  1911		       f0		      .byte.b	>(LEVEL__061_L-1)
    323  1912		       f0		      .byte.b	>(LEVEL__062_L-1)
    324  1913		       f1		      .byte.b	>(LEVEL__062_R-1)
    325  1914		       f1		      .byte.b	>(LEVEL__063_L-1)
    326  1915		       f1		      .byte.b	>(LEVEL__063_R-1)
    327  1916		       f2		      .byte.b	>(LEVEL__064_R-1)
    328  1917		       f2		      .byte.b	>(LEVEL__064_L-1)
    329  1918		       f3		      .byte.b	>(LEVEL__065_R-1)
    330  1919		       f2		      .byte.b	>(LEVEL__065_L-1)
    331  191a		       f3		      .byte.b	>(LEVEL__066_R-1)
    332  191b		       f3		      .byte.b	>(LEVEL__066_L-1)
    333  191c		       f4		      .byte.b	>(LEVEL__067_R-1)
    334  191d		       f4		      .byte.b	>(LEVEL__067_L-1)
    335  191e		       f5		      .byte.b	>(LEVEL__068_R-1)
    336  191f		       f4		      .byte.b	>(LEVEL__068_L-1)
    337  1920		       f5		      .byte.b	>(LEVEL__069_R-1)
    338  1921		       f5		      .byte.b	>(LEVEL__069_L-1)
    339  1922
    340  1922		       f1		      .byte.b	>(LEVEL__103_Arielle-1)
    341  1923		       f1		      .byte.b	>(LEVEL__103_Ajalae-1)
    342  1924		       f1		      .byte.b	>(LEVEL__103_Adin-1)
    343  1925		       f0		      .byte.b	>(LEVEL__102_Raven-1)
    344  1926		       f0		      .byte.b	>(LEVEL__102_Oralia-1)
    345  1927		       ef		      .byte.b	>(LEVEL__102_Natalie-1)
    346  1928		       f0		      .byte.b	>(LEVEL__102_Mirabel-1)
    347  1929		       f2		      .byte.b	>(LEVEL__1XJH_Tara_Gelson-1)
    348  192a		       f2		      .byte.b	>(LEVEL__1R7X_Alison-1)
    349  192b		       f2		      .byte.b	>(LEVEL__1KWD_Cecile_Clayworth-1)
    350  192c		       f2		      .byte.b	>(LEVEL__1EKT_Samantha_Gelson-1)
    351  192d		       f3		      .byte.b	>(LEVEL__0VM5_Andrea_Wadd-1)
    352  192e		       f3		      .byte.b	>(LEVEL__0PAL_Jill_Leatherby-1)
    353  192f		       f3		      .byte.b	>(LEVEL__0IZ1_Sophia-1)
    354  1930		       f3		      .byte.b	>(LEVEL__0CNH_Alice-1)
    355  1931		       f6		      .byte.b	>(LEVEL__122_Maya-1)
    356  1932
    357  1932				  -	      IF	(* - LevelInfoHI != MAX_LEVEL)
    358  1932				  -	      ECHO	"ERROR: Incorrect LevelInfoHI table!"
    359  1932				  -	      ERR
    360  1932					      ENDIF
    361  1932
    362  1932				   LevelInfoBANK
    363  1932
    364  1932		       04		      .byte.b	BANK_LEVEL__001_L
    365  1933		       04		      .byte.b	BANK_LEVEL__001_R
    366  1934		       04		      .byte.b	BANK_LEVEL__002_L
    367  1935		       04		      .byte.b	BANK_LEVEL__002_R
    368  1936		       04		      .byte.b	BANK_LEVEL__003_L
    369  1937		       04		      .byte.b	BANK_LEVEL__003_R
    370  1938		       04		      .byte.b	BANK_LEVEL__004_L
    371  1939		       04		      .byte.b	BANK_LEVEL__004_R
    372  193a		       04		      .byte.b	BANK_LEVEL__005_L
    373  193b		       04		      .byte.b	BANK_LEVEL__005_R
    374  193c		       04		      .byte.b	BANK_LEVEL__006_L
    375  193d		       04		      .byte.b	BANK_LEVEL__006_R
    376  193e		       04		      .byte.b	BANK_LEVEL__007_L
    377  193f		       04		      .byte.b	BANK_LEVEL__007_R
    378  1940		       04		      .byte.b	BANK_LEVEL__008_L
    379  1941		       04		      .byte.b	BANK_LEVEL__008_R
    380  1942		       04		      .byte.b	BANK_LEVEL__009_L
    381  1943		       04		      .byte.b	BANK_LEVEL__009_R
    382  1944		       04		      .byte.b	BANK_LEVEL__010_L
    383  1945		       04		      .byte.b	BANK_LEVEL__010_R
    384  1946		       04		      .byte.b	BANK_LEVEL__011_L
    385  1947		       04		      .byte.b	BANK_LEVEL__011_R
    386  1948		       04		      .byte.b	BANK_LEVEL__012_L
    387  1949		       04		      .byte.b	BANK_LEVEL__012_R
    388  194a		       04		      .byte.b	BANK_LEVEL__013_L
    389  194b		       04		      .byte.b	BANK_LEVEL__013_R
    390  194c		       04		      .byte.b	BANK_LEVEL__014_L
    391  194d		       04		      .byte.b	BANK_LEVEL__014_R
    392  194e		       04		      .byte.b	BANK_LEVEL__015_L
    393  194f		       04		      .byte.b	BANK_LEVEL__015_R
    394  1950		       04		      .byte.b	BANK_LEVEL__016_L
    395  1951		       04		      .byte.b	BANK_LEVEL__016_R
    396  1952		       04		      .byte.b	BANK_LEVEL__017_L
    397  1953		       04		      .byte.b	BANK_LEVEL__017_R
    398  1954		       04		      .byte.b	BANK_LEVEL__018_L
    399  1955		       04		      .byte.b	BANK_LEVEL__018_R
    400  1956		       04		      .byte.b	BANK_LEVEL__019_L
    401  1957		       04		      .byte.b	BANK_LEVEL__019_R
    402  1958		       05		      .byte.b	BANK_LEVEL__020_L
    403  1959		       05		      .byte.b	BANK_LEVEL__020_R
    404  195a		       05		      .byte.b	BANK_LEVEL__021_L
    405  195b		       05		      .byte.b	BANK_LEVEL__021_R
    406  195c		       05		      .byte.b	BANK_LEVEL__022_L
    407  195d		       05		      .byte.b	BANK_LEVEL__022_R
    408  195e		       05		      .byte.b	BANK_LEVEL__023_L
    409  195f		       05		      .byte.b	BANK_LEVEL__023_R
    410  1960		       05		      .byte.b	BANK_LEVEL__024_L
    411  1961		       05		      .byte.b	BANK_LEVEL__024_R
    412  1962		       05		      .byte.b	BANK_LEVEL__025_L
    413  1963		       05		      .byte.b	BANK_LEVEL__025_R
    414  1964		       05		      .byte.b	BANK_LEVEL__026_L
    415  1965		       05		      .byte.b	BANK_LEVEL__026_R
    416  1966		       05		      .byte.b	BANK_LEVEL__027_L
    417  1967		       05		      .byte.b	BANK_LEVEL__027_R
    418  1968		       05		      .byte.b	BANK_LEVEL__028_L
    419  1969		       05		      .byte.b	BANK_LEVEL__028_R
    420  196a		       05		      .byte.b	BANK_LEVEL__029_L
    421  196b		       05		      .byte.b	BANK_LEVEL__029_R
    422  196c		       05		      .byte.b	BANK_LEVEL__030_L
    423  196d		       05		      .byte.b	BANK_LEVEL__030_R
    424  196e		       05		      .byte.b	BANK_LEVEL__031_L
    425  196f		       05		      .byte.b	BANK_LEVEL__031_R
    426  1970		       05		      .byte.b	BANK_LEVEL__032_L
    427  1971		       05		      .byte.b	BANK_LEVEL__032_R
    428  1972		       05		      .byte.b	BANK_LEVEL__033_L
    429  1973		       05		      .byte.b	BANK_LEVEL__033_R
    430  1974		       05		      .byte.b	BANK_LEVEL__034_L
    431  1975		       06		      .byte.b	BANK_LEVEL__034_R
    432  1976		       06		      .byte.b	BANK_LEVEL__035_L
    433  1977		       06		      .byte.b	BANK_LEVEL__035_R
    434  1978		       06		      .byte.b	BANK_LEVEL__036_L
    435  1979		       06		      .byte.b	BANK_LEVEL__036_R
    436  197a		       06		      .byte.b	BANK_LEVEL__037_L
    437  197b		       06		      .byte.b	BANK_LEVEL__037_R
    438  197c		       06		      .byte.b	BANK_LEVEL__038_L
    439  197d		       06		      .byte.b	BANK_LEVEL__038_R
    440  197e		       06		      .byte.b	BANK_LEVEL__039_L
    441  197f		       06		      .byte.b	BANK_LEVEL__039_R
    442  1980		       06		      .byte.b	BANK_LEVEL__040_L
    443  1981		       06		      .byte.b	BANK_LEVEL__040_R
    444  1982
    445  1982		       06		      .byte.b	BANK_LEVEL__041_L
    446  1983		       06		      .byte.b	BANK_LEVEL__041_R
    447  1984		       06		      .byte.b	BANK_LEVEL__042_L
    448  1985		       06		      .byte.b	BANK_LEVEL__042_R
    449  1986		       06		      .byte.b	BANK_LEVEL__043_L
    450  1987		       06		      .byte.b	BANK_LEVEL__043_R
    451  1988		       06		      .byte.b	BANK_LEVEL__044_L
    452  1989		       06		      .byte.b	BANK_LEVEL__044_R
    453  198a		       06		      .byte.b	BANK_LEVEL__045_L
    454  198b		       06		      .byte.b	BANK_LEVEL__045_R
    455  198c		       06		      .byte.b	BANK_LEVEL__046_L
    456  198d		       06		      .byte.b	BANK_LEVEL__046_R
    457  198e		       06		      .byte.b	BANK_LEVEL__047_L
    458  198f		       06		      .byte.b	BANK_LEVEL__047_R
    459  1990		       07		      .byte.b	BANK_LEVEL__048_L
    460  1991		       07		      .byte.b	BANK_LEVEL__048_R
    461  1992		       07		      .byte.b	BANK_LEVEL__049_L
    462  1993		       07		      .byte.b	BANK_LEVEL__049_R
    463  1994
    464  1994		       07		      .byte.b	BANK_LEVEL__050_L
    465  1995		       07		      .byte.b	BANK_LEVEL__050_R
    466  1996		       07		      .byte.b	BANK_LEVEL__051_L
    467  1997		       07		      .byte.b	BANK_LEVEL__051_R
    468  1998		       07		      .byte.b	BANK_LEVEL__052_L
    469  1999		       07		      .byte.b	BANK_LEVEL__052_R
    470  199a		       07		      .byte.b	BANK_LEVEL__053_L
    471  199b		       07		      .byte.b	BANK_LEVEL__053_R
    472  199c		       07		      .byte.b	BANK_LEVEL__054_L
    473  199d		       07		      .byte.b	BANK_LEVEL__054_R
    474  199e		       07		      .byte.b	BANK_LEVEL__055_L
    475  199f		       07		      .byte.b	BANK_LEVEL__055_R
    476  19a0		       07		      .byte.b	BANK_LEVEL__056_L
    477  19a1		       07		      .byte.b	BANK_LEVEL__056_R
    478  19a2		       07		      .byte.b	BANK_LEVEL__057_L
    479  19a3		       07		      .byte.b	BANK_LEVEL__057_R
    480  19a4		       07		      .byte.b	BANK_LEVEL__058_L
    481  19a5		       07		      .byte.b	BANK_LEVEL__058_R
    482  19a6		       07		      .byte.b	BANK_LEVEL__059_L
    483  19a7		       07		      .byte.b	BANK_LEVEL__059_R
    484  19a8
    485  19a8		       08		      .byte.b	BANK_LEVEL__060_R
    486  19a9		       08		      .byte.b	BANK_LEVEL__061_R
    487  19aa		       08		      .byte.b	BANK_LEVEL__061_L
    488  19ab		       08		      .byte.b	BANK_LEVEL__062_L
    489  19ac		       08		      .byte.b	BANK_LEVEL__062_R
    490  19ad		       08		      .byte.b	BANK_LEVEL__063_L
    491  19ae		       08		      .byte.b	BANK_LEVEL__063_R
    492  19af		       08		      .byte.b	BANK_LEVEL__064_R
    493  19b0		       08		      .byte.b	BANK_LEVEL__064_L
    494  19b1		       08		      .byte.b	BANK_LEVEL__065_R
    495  19b2		       08		      .byte.b	BANK_LEVEL__065_L
    496  19b3		       08		      .byte.b	BANK_LEVEL__066_R
    497  19b4		       08		      .byte.b	BANK_LEVEL__066_L
    498  19b5		       08		      .byte.b	BANK_LEVEL__067_R
    499  19b6		       08		      .byte.b	BANK_LEVEL__067_L
    500  19b7		       08		      .byte.b	BANK_LEVEL__068_R
    501  19b8		       08		      .byte.b	BANK_LEVEL__068_L
    502  19b9		       08		      .byte.b	BANK_LEVEL__069_R
    503  19ba		       08		      .byte.b	BANK_LEVEL__069_L
    504  19bb
    505  19bb		       09		      .byte.b	BANK_LEVEL__103_Arielle
    506  19bc		       09		      .byte.b	BANK_LEVEL__103_Ajalae
    507  19bd		       09		      .byte.b	BANK_LEVEL__103_Adin
    508  19be		       09		      .byte.b	BANK_LEVEL__102_Raven
    509  19bf		       09		      .byte.b	BANK_LEVEL__102_Oralia
    510  19c0		       09		      .byte.b	BANK_LEVEL__102_Natalie
    511  19c1		       09		      .byte.b	BANK_LEVEL__102_Mirabel
    512  19c2		       09		      .byte.b	BANK_LEVEL__1XJH_Tara_Gelson
    513  19c3		       09		      .byte.b	BANK_LEVEL__1R7X_Alison
    514  19c4		       09		      .byte.b	BANK_LEVEL__1KWD_Cecile_Clayworth
    515  19c5		       09		      .byte.b	BANK_LEVEL__1EKT_Samantha_Gelson
    516  19c6		       09		      .byte.b	BANK_LEVEL__0VM5_Andrea_Wadd
    517  19c7		       09		      .byte.b	BANK_LEVEL__0PAL_Jill_Leatherby
    518  19c8		       09		      .byte.b	BANK_LEVEL__0IZ1_Sophia
    519  19c9		       09		      .byte.b	BANK_LEVEL__0CNH_Alice
    520  19ca
    521  19ca		       08		      .byte.b	BANK_LEVEL__122_Maya
    522  19cb
    523  19cb				  -	      IF	(* - LevelInfoBANK != MAX_LEVEL)
    524  19cb				  -	      ECHO	"ERROR: Incorrect LevelInfoBANK table!"
    525  19cb				  -	      ERR
    526  19cb					      ENDIF
    527  19cb
    528  19cb
    529  19cb
    530  19cb				   finX
    531  19cb							; now put the soil in - fill from the outsides
    532  19cb
    533  19cb		       a9 01		      lda	#CHARACTER_SOIL
    534  19cd		       85 8b		      sta	POS_Type
    535  19cf
    536  19cf		       a9 13		      lda	#SIZE_BOARD_Y-1
    537  19d1		       85 88		      sta	POS_Y
    538  19d3
    539  19d3		       a9 17	   xlin       lda	#SIZE_BOARD_X-1
    540  19d5		       85 87		      sta	POS_X
    541  19d7		       20 26 f8    zap1       jsr	GetBoardCharacter__CALL_FROM_RAM__
    542  19da		       c9 01		      cmp	#CHARACTER_SOIL
    543  19dc		       f0 07		      beq	kg2a
    544  19de		       c9 00		      cmp	#0
    545  19e0		       d0 07		      bne	endzap1
    546  19e2		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    547  19e5		       c6 87	   kg2a       dec	POS_X
    548  19e7		       10 ee		      bpl	zap1
    549  19e9
    550  19e9		       a9 00	   endzap1    lda	#0
    551  19eb		       85 87		      sta	POS_X
    552  19ed		       20 26 f8    zap2       jsr	GetBoardCharacter__CALL_FROM_RAM__
    553  19f0		       c9 01		      cmp	#CHARACTER_SOIL
    554  19f2		       f0 07		      beq	kg2
    555  19f4		       c9 00		      cmp	#0
    556  19f6		       d0 0b		      bne	endzap2
    557  19f8		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    558  19fb		       e6 87	   kg2	      inc	POS_X
    559  19fd		       a5 87		      lda	POS_X
    560  19ff		       c9 18		      cmp	#SIZE_BOARD_X
    561  1a01		       d0 ea		      bne	zap2
    562  1a03
    563  1a03		       c6 88	   endzap2    dec	POS_Y
    564  1a05		       10 cc		      bpl	xlin
    565  1a07
    566  1a07
    567  1a07		       a9 17		      lda	#SIZE_BOARD_X-1
    568  1a09		       85 87		      sta	POS_X
    569  1a0b
    570  1a0b		       a9 13	   ylin       lda	#SIZE_BOARD_Y-1
    571  1a0d		       85 88		      sta	POS_Y
    572  1a0f		       20 26 f8    zapy1      jsr	GetBoardCharacter__CALL_FROM_RAM__
    573  1a12		       c9 01		      cmp	#CHARACTER_SOIL
    574  1a14		       f0 07		      beq	kg3
    575  1a16		       c9 00		      cmp	#0
    576  1a18		       d0 07		      bne	endzapy1
    577  1a1a		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    578  1a1d		       c6 88	   kg3	      dec	POS_Y
    579  1a1f		       10 ee		      bpl	zapy1
    580  1a21
    581  1a21		       a9 00	   endzapy1   lda	#0
    582  1a23		       85 88		      sta	POS_Y
    583  1a25		       20 26 f8    zapy2      jsr	GetBoardCharacter__CALL_FROM_RAM__
    584  1a28		       c9 01		      cmp	#CHARACTER_SOIL
    585  1a2a		       f0 07		      beq	kg3b
    586  1a2c		       c9 00		      cmp	#0
    587  1a2e		       d0 0b		      bne	endzapy2
    588  1a30		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    589  1a33		       e6 88	   kg3b       inc	POS_Y
    590  1a35		       a5 88		      lda	POS_Y
    591  1a37		       c9 14		      cmp	#SIZE_BOARD_Y
    592  1a39		       d0 ea		      bne	zapy2
    593  1a3b
    594  1a3b		       c6 87	   endzapy2   dec	POS_X
    595  1a3d		       10 cc		      bpl	ylin
    596  1a3f		       60		      rts
    597  1a40
    598  1a40							;A	 steel wall
    599  1a40							;B	 soil (surround)
    600  1a40							;C	 box
    601  1a40
    602  1a40					      MAC	ntscpal
    603  1a40					      .byte	{1}+{2}
    604  1a40					      NTSC_TO_PAL	{1},{2}
    605  1a40					      ENDM		; {col} {intensity}
    606  1a40
    607  1a40				   C1			;
    608  1a40							; mortar for bricks
      0  1a40					      NTSCPAL	$C0,$6
      1  1a40		       c6		      .byte.b	$C0+$6
      0  1a41					      NTSC_TO_PAL	$C0,$6
      1  1a41				  -	      IF	$C0 = 0
      2  1a41				  -	      .byte	$C0+$6
      3  1a41					      ENDIF
      4  1a41				  -	      IF	$C0 = $10
      5  1a41				  -	      .byte	$22+$6
      6  1a41					      ENDIF
      7  1a41				  -	      IF	$C0 = $20
      8  1a41				  -	      .byte	$42+$6
      9  1a41					      ENDIF
     10  1a41				  -	      IF	$C0 = $30
     11  1a41				  -	      .byte	$42+$6
     12  1a41					      ENDIF
     13  1a41				  -	      IF	$C0 = $40
     14  1a41				  -	      .byte	$62+$6
     15  1a41					      ENDIF
     16  1a41				  -	      IF	$C0 = $50
     17  1a41				  -	      .byte	$82+$6
     18  1a41					      ENDIF
     19  1a41				  -	      IF	$C0 = $60
     20  1a41				  -	      .byte	$C2+$6
     21  1a41					      ENDIF
     22  1a41				  -	      IF	$C0 = $70
     23  1a41				  -	      .byte	$D2+$6
     24  1a41					      ENDIF
     25  1a41				  -	      IF	$C0 = $80
     26  1a41				  -	      .byte	$B2+$6
     27  1a41					      ENDIF
     28  1a41				  -	      IF	$C0 = $90
     29  1a41				  -	      .byte	$92+$6
     30  1a41					      ENDIF
     31  1a41				  -	      IF	$C0 = $A0
     32  1a41				  -	      .byte	$72+$6
     33  1a41					      ENDIF
     34  1a41				  -	      IF	$C0 = $B0
     35  1a41				  -	      .byte	$52+$6
     36  1a41					      ENDIF
     37  1a41					      IF	$C0 = $C0
     38  1a41		       38		      .byte.b	$32+$6
     39  1a42					      ENDIF
     40  1a42				  -	      IF	$C0 = $D0
     41  1a42				  -	      .byte	$32+$6
     42  1a42					      ENDIF
     43  1a42				  -	      IF	$C0 = $E0
     44  1a42				  -	      .byte	$22+$6
     45  1a42					      ENDIF
     46  1a42				  -	      IF	$C0 = $F0
     47  1a42				  -	      .byte	$42+$6
     48  1a42					      ENDIF
      0  1a42					      NTSCPAL	$40,$4
      1  1a42		       44		      .byte.b	$40+$4
      0  1a43					      NTSC_TO_PAL	$40,$4
      1  1a43				  -	      IF	$40 = 0
      2  1a43				  -	      .byte	$40+$4
      3  1a43					      ENDIF
      4  1a43				  -	      IF	$40 = $10
      5  1a43				  -	      .byte	$22+$4
      6  1a43					      ENDIF
      7  1a43				  -	      IF	$40 = $20
      8  1a43				  -	      .byte	$42+$4
      9  1a43					      ENDIF
     10  1a43				  -	      IF	$40 = $30
     11  1a43				  -	      .byte	$42+$4
     12  1a43					      ENDIF
     13  1a43					      IF	$40 = $40
     14  1a43		       66		      .byte.b	$62+$4
     15  1a44					      ENDIF
     16  1a44				  -	      IF	$40 = $50
     17  1a44				  -	      .byte	$82+$4
     18  1a44					      ENDIF
     19  1a44				  -	      IF	$40 = $60
     20  1a44				  -	      .byte	$C2+$4
     21  1a44					      ENDIF
     22  1a44				  -	      IF	$40 = $70
     23  1a44				  -	      .byte	$D2+$4
     24  1a44					      ENDIF
     25  1a44				  -	      IF	$40 = $80
     26  1a44				  -	      .byte	$B2+$4
     27  1a44					      ENDIF
     28  1a44				  -	      IF	$40 = $90
     29  1a44				  -	      .byte	$92+$4
     30  1a44					      ENDIF
     31  1a44				  -	      IF	$40 = $A0
     32  1a44				  -	      .byte	$72+$4
     33  1a44					      ENDIF
     34  1a44				  -	      IF	$40 = $B0
     35  1a44				  -	      .byte	$52+$4
     36  1a44					      ENDIF
     37  1a44				  -	      IF	$40 = $C0
     38  1a44				  -	      .byte	$32+$4
     39  1a44					      ENDIF
     40  1a44				  -	      IF	$40 = $D0
     41  1a44				  -	      .byte	$32+$4
     42  1a44					      ENDIF
     43  1a44				  -	      IF	$40 = $E0
     44  1a44				  -	      .byte	$22+$4
     45  1a44					      ENDIF
     46  1a44				  -	      IF	$40 = $F0
     47  1a44				  -	      .byte	$42+$4
     48  1a44					      ENDIF
      0  1a44					      NTSCPAL	$40,$A
      1  1a44		       4a		      .byte.b	$40+$A
      0  1a45					      NTSC_TO_PAL	$40,$A
      1  1a45				  -	      IF	$40 = 0
      2  1a45				  -	      .byte	$40+$A
      3  1a45					      ENDIF
      4  1a45				  -	      IF	$40 = $10
      5  1a45				  -	      .byte	$22+$A
      6  1a45					      ENDIF
      7  1a45				  -	      IF	$40 = $20
      8  1a45				  -	      .byte	$42+$A
      9  1a45					      ENDIF
     10  1a45				  -	      IF	$40 = $30
     11  1a45				  -	      .byte	$42+$A
     12  1a45					      ENDIF
     13  1a45					      IF	$40 = $40
     14  1a45		       6c		      .byte.b	$62+$A
     15  1a46					      ENDIF
     16  1a46				  -	      IF	$40 = $50
     17  1a46				  -	      .byte	$82+$A
     18  1a46					      ENDIF
     19  1a46				  -	      IF	$40 = $60
     20  1a46				  -	      .byte	$C2+$A
     21  1a46					      ENDIF
     22  1a46				  -	      IF	$40 = $70
     23  1a46				  -	      .byte	$D2+$A
     24  1a46					      ENDIF
     25  1a46				  -	      IF	$40 = $80
     26  1a46				  -	      .byte	$B2+$A
     27  1a46					      ENDIF
     28  1a46				  -	      IF	$40 = $90
     29  1a46				  -	      .byte	$92+$A
     30  1a46					      ENDIF
     31  1a46				  -	      IF	$40 = $A0
     32  1a46				  -	      .byte	$72+$A
     33  1a46					      ENDIF
     34  1a46				  -	      IF	$40 = $B0
     35  1a46				  -	      .byte	$52+$A
     36  1a46					      ENDIF
     37  1a46				  -	      IF	$40 = $C0
     38  1a46				  -	      .byte	$32+$A
     39  1a46					      ENDIF
     40  1a46				  -	      IF	$40 = $D0
     41  1a46				  -	      .byte	$32+$A
     42  1a46					      ENDIF
     43  1a46				  -	      IF	$40 = $E0
     44  1a46				  -	      .byte	$22+$A
     45  1a46					      ENDIF
     46  1a46				  -	      IF	$40 = $F0
     47  1a46				  -	      .byte	$42+$A
     48  1a46					      ENDIF
      0  1a46					      NTSCPAL	$C0,$8
      1  1a46		       c8		      .byte.b	$C0+$8
      0  1a47					      NTSC_TO_PAL	$C0,$8
      1  1a47				  -	      IF	$C0 = 0
      2  1a47				  -	      .byte	$C0+$8
      3  1a47					      ENDIF
      4  1a47				  -	      IF	$C0 = $10
      5  1a47				  -	      .byte	$22+$8
      6  1a47					      ENDIF
      7  1a47				  -	      IF	$C0 = $20
      8  1a47				  -	      .byte	$42+$8
      9  1a47					      ENDIF
     10  1a47				  -	      IF	$C0 = $30
     11  1a47				  -	      .byte	$42+$8
     12  1a47					      ENDIF
     13  1a47				  -	      IF	$C0 = $40
     14  1a47				  -	      .byte	$62+$8
     15  1a47					      ENDIF
     16  1a47				  -	      IF	$C0 = $50
     17  1a47				  -	      .byte	$82+$8
     18  1a47					      ENDIF
     19  1a47				  -	      IF	$C0 = $60
     20  1a47				  -	      .byte	$C2+$8
     21  1a47					      ENDIF
     22  1a47				  -	      IF	$C0 = $70
     23  1a47				  -	      .byte	$D2+$8
     24  1a47					      ENDIF
     25  1a47				  -	      IF	$C0 = $80
     26  1a47				  -	      .byte	$B2+$8
     27  1a47					      ENDIF
     28  1a47				  -	      IF	$C0 = $90
     29  1a47				  -	      .byte	$92+$8
     30  1a47					      ENDIF
     31  1a47				  -	      IF	$C0 = $A0
     32  1a47				  -	      .byte	$72+$8
     33  1a47					      ENDIF
     34  1a47				  -	      IF	$C0 = $B0
     35  1a47				  -	      .byte	$52+$8
     36  1a47					      ENDIF
     37  1a47					      IF	$C0 = $C0
     38  1a47		       3a		      .byte.b	$32+$8
     39  1a48					      ENDIF
     40  1a48				  -	      IF	$C0 = $D0
     41  1a48				  -	      .byte	$32+$8
     42  1a48					      ENDIF
     43  1a48				  -	      IF	$C0 = $E0
     44  1a48				  -	      .byte	$22+$8
     45  1a48					      ENDIF
     46  1a48				  -	      IF	$C0 = $F0
     47  1a48				  -	      .byte	$42+$8
     48  1a48					      ENDIF
    613  1a48				   C2			; soil stripes
      0  1a48					      NTSCPAL	$30,$6
      1  1a48		       36		      .byte.b	$30+$6
      0  1a49					      NTSC_TO_PAL	$30,$6
      1  1a49				  -	      IF	$30 = 0
      2  1a49				  -	      .byte	$30+$6
      3  1a49					      ENDIF
      4  1a49				  -	      IF	$30 = $10
      5  1a49				  -	      .byte	$22+$6
      6  1a49					      ENDIF
      7  1a49				  -	      IF	$30 = $20
      8  1a49				  -	      .byte	$42+$6
      9  1a49					      ENDIF
     10  1a49					      IF	$30 = $30
     11  1a49		       48		      .byte.b	$42+$6
     12  1a4a					      ENDIF
     13  1a4a				  -	      IF	$30 = $40
     14  1a4a				  -	      .byte	$62+$6
     15  1a4a					      ENDIF
     16  1a4a				  -	      IF	$30 = $50
     17  1a4a				  -	      .byte	$82+$6
     18  1a4a					      ENDIF
     19  1a4a				  -	      IF	$30 = $60
     20  1a4a				  -	      .byte	$C2+$6
     21  1a4a					      ENDIF
     22  1a4a				  -	      IF	$30 = $70
     23  1a4a				  -	      .byte	$D2+$6
     24  1a4a					      ENDIF
     25  1a4a				  -	      IF	$30 = $80
     26  1a4a				  -	      .byte	$B2+$6
     27  1a4a					      ENDIF
     28  1a4a				  -	      IF	$30 = $90
     29  1a4a				  -	      .byte	$92+$6
     30  1a4a					      ENDIF
     31  1a4a				  -	      IF	$30 = $A0
     32  1a4a				  -	      .byte	$72+$6
     33  1a4a					      ENDIF
     34  1a4a				  -	      IF	$30 = $B0
     35  1a4a				  -	      .byte	$52+$6
     36  1a4a					      ENDIF
     37  1a4a				  -	      IF	$30 = $C0
     38  1a4a				  -	      .byte	$32+$6
     39  1a4a					      ENDIF
     40  1a4a				  -	      IF	$30 = $D0
     41  1a4a				  -	      .byte	$32+$6
     42  1a4a					      ENDIF
     43  1a4a				  -	      IF	$30 = $E0
     44  1a4a				  -	      .byte	$22+$6
     45  1a4a					      ENDIF
     46  1a4a				  -	      IF	$30 = $F0
     47  1a4a				  -	      .byte	$42+$6
     48  1a4a					      ENDIF
      0  1a4a					      NTSCPAL	$20,$8
      1  1a4a		       28		      .byte.b	$20+$8
      0  1a4b					      NTSC_TO_PAL	$20,$8
      1  1a4b				  -	      IF	$20 = 0
      2  1a4b				  -	      .byte	$20+$8
      3  1a4b					      ENDIF
      4  1a4b				  -	      IF	$20 = $10
      5  1a4b				  -	      .byte	$22+$8
      6  1a4b					      ENDIF
      7  1a4b					      IF	$20 = $20
      8  1a4b		       4a		      .byte.b	$42+$8
      9  1a4c					      ENDIF
     10  1a4c				  -	      IF	$20 = $30
     11  1a4c				  -	      .byte	$42+$8
     12  1a4c					      ENDIF
     13  1a4c				  -	      IF	$20 = $40
     14  1a4c				  -	      .byte	$62+$8
     15  1a4c					      ENDIF
     16  1a4c				  -	      IF	$20 = $50
     17  1a4c				  -	      .byte	$82+$8
     18  1a4c					      ENDIF
     19  1a4c				  -	      IF	$20 = $60
     20  1a4c				  -	      .byte	$C2+$8
     21  1a4c					      ENDIF
     22  1a4c				  -	      IF	$20 = $70
     23  1a4c				  -	      .byte	$D2+$8
     24  1a4c					      ENDIF
     25  1a4c				  -	      IF	$20 = $80
     26  1a4c				  -	      .byte	$B2+$8
     27  1a4c					      ENDIF
     28  1a4c				  -	      IF	$20 = $90
     29  1a4c				  -	      .byte	$92+$8
     30  1a4c					      ENDIF
     31  1a4c				  -	      IF	$20 = $A0
     32  1a4c				  -	      .byte	$72+$8
     33  1a4c					      ENDIF
     34  1a4c				  -	      IF	$20 = $B0
     35  1a4c				  -	      .byte	$52+$8
     36  1a4c					      ENDIF
     37  1a4c				  -	      IF	$20 = $C0
     38  1a4c				  -	      .byte	$32+$8
     39  1a4c					      ENDIF
     40  1a4c				  -	      IF	$20 = $D0
     41  1a4c				  -	      .byte	$32+$8
     42  1a4c					      ENDIF
     43  1a4c				  -	      IF	$20 = $E0
     44  1a4c				  -	      .byte	$22+$8
     45  1a4c					      ENDIF
     46  1a4c				  -	      IF	$20 = $F0
     47  1a4c				  -	      .byte	$42+$8
     48  1a4c					      ENDIF
      0  1a4c					      NTSCPAL	$A0,$4
      1  1a4c		       a4		      .byte.b	$A0+$4
      0  1a4d					      NTSC_TO_PAL	$A0,$4
      1  1a4d				  -	      IF	$A0 = 0
      2  1a4d				  -	      .byte	$A0+$4
      3  1a4d					      ENDIF
      4  1a4d				  -	      IF	$A0 = $10
      5  1a4d				  -	      .byte	$22+$4
      6  1a4d					      ENDIF
      7  1a4d				  -	      IF	$A0 = $20
      8  1a4d				  -	      .byte	$42+$4
      9  1a4d					      ENDIF
     10  1a4d				  -	      IF	$A0 = $30
     11  1a4d				  -	      .byte	$42+$4
     12  1a4d					      ENDIF
     13  1a4d				  -	      IF	$A0 = $40
     14  1a4d				  -	      .byte	$62+$4
     15  1a4d					      ENDIF
     16  1a4d				  -	      IF	$A0 = $50
     17  1a4d				  -	      .byte	$82+$4
     18  1a4d					      ENDIF
     19  1a4d				  -	      IF	$A0 = $60
     20  1a4d				  -	      .byte	$C2+$4
     21  1a4d					      ENDIF
     22  1a4d				  -	      IF	$A0 = $70
     23  1a4d				  -	      .byte	$D2+$4
     24  1a4d					      ENDIF
     25  1a4d				  -	      IF	$A0 = $80
     26  1a4d				  -	      .byte	$B2+$4
     27  1a4d					      ENDIF
     28  1a4d				  -	      IF	$A0 = $90
     29  1a4d				  -	      .byte	$92+$4
     30  1a4d					      ENDIF
     31  1a4d					      IF	$A0 = $A0
     32  1a4d		       76		      .byte.b	$72+$4
     33  1a4e					      ENDIF
     34  1a4e				  -	      IF	$A0 = $B0
     35  1a4e				  -	      .byte	$52+$4
     36  1a4e					      ENDIF
     37  1a4e				  -	      IF	$A0 = $C0
     38  1a4e				  -	      .byte	$32+$4
     39  1a4e					      ENDIF
     40  1a4e				  -	      IF	$A0 = $D0
     41  1a4e				  -	      .byte	$32+$4
     42  1a4e					      ENDIF
     43  1a4e				  -	      IF	$A0 = $E0
     44  1a4e				  -	      .byte	$22+$4
     45  1a4e					      ENDIF
     46  1a4e				  -	      IF	$A0 = $F0
     47  1a4e				  -	      .byte	$42+$4
     48  1a4e					      ENDIF
      0  1a4e					      NTSCPAL	$60,$6
      1  1a4e		       66		      .byte.b	$60+$6
      0  1a4f					      NTSC_TO_PAL	$60,$6
      1  1a4f				  -	      IF	$60 = 0
      2  1a4f				  -	      .byte	$60+$6
      3  1a4f					      ENDIF
      4  1a4f				  -	      IF	$60 = $10
      5  1a4f				  -	      .byte	$22+$6
      6  1a4f					      ENDIF
      7  1a4f				  -	      IF	$60 = $20
      8  1a4f				  -	      .byte	$42+$6
      9  1a4f					      ENDIF
     10  1a4f				  -	      IF	$60 = $30
     11  1a4f				  -	      .byte	$42+$6
     12  1a4f					      ENDIF
     13  1a4f				  -	      IF	$60 = $40
     14  1a4f				  -	      .byte	$62+$6
     15  1a4f					      ENDIF
     16  1a4f				  -	      IF	$60 = $50
     17  1a4f				  -	      .byte	$82+$6
     18  1a4f					      ENDIF
     19  1a4f					      IF	$60 = $60
     20  1a4f		       c8		      .byte.b	$C2+$6
     21  1a50					      ENDIF
     22  1a50				  -	      IF	$60 = $70
     23  1a50				  -	      .byte	$D2+$6
     24  1a50					      ENDIF
     25  1a50				  -	      IF	$60 = $80
     26  1a50				  -	      .byte	$B2+$6
     27  1a50					      ENDIF
     28  1a50				  -	      IF	$60 = $90
     29  1a50				  -	      .byte	$92+$6
     30  1a50					      ENDIF
     31  1a50				  -	      IF	$60 = $A0
     32  1a50				  -	      .byte	$72+$6
     33  1a50					      ENDIF
     34  1a50				  -	      IF	$60 = $B0
     35  1a50				  -	      .byte	$52+$6
     36  1a50					      ENDIF
     37  1a50				  -	      IF	$60 = $C0
     38  1a50				  -	      .byte	$32+$6
     39  1a50					      ENDIF
     40  1a50				  -	      IF	$60 = $D0
     41  1a50				  -	      .byte	$32+$6
     42  1a50					      ENDIF
     43  1a50				  -	      IF	$60 = $E0
     44  1a50				  -	      .byte	$22+$6
     45  1a50					      ENDIF
     46  1a50				  -	      IF	$60 = $F0
     47  1a50				  -	      .byte	$42+$6
     48  1a50					      ENDIF
    618  1a50				   C3			;
      0  1a50					      NTSCPAL	$10,$6
      1  1a50		       16		      .byte.b	$10+$6
      0  1a51					      NTSC_TO_PAL	$10,$6
      1  1a51				  -	      IF	$10 = 0
      2  1a51				  -	      .byte	$10+$6
      3  1a51					      ENDIF
      4  1a51					      IF	$10 = $10
      5  1a51		       28		      .byte.b	$22+$6
      6  1a52					      ENDIF
      7  1a52				  -	      IF	$10 = $20
      8  1a52				  -	      .byte	$42+$6
      9  1a52					      ENDIF
     10  1a52				  -	      IF	$10 = $30
     11  1a52				  -	      .byte	$42+$6
     12  1a52					      ENDIF
     13  1a52				  -	      IF	$10 = $40
     14  1a52				  -	      .byte	$62+$6
     15  1a52					      ENDIF
     16  1a52				  -	      IF	$10 = $50
     17  1a52				  -	      .byte	$82+$6
     18  1a52					      ENDIF
     19  1a52				  -	      IF	$10 = $60
     20  1a52				  -	      .byte	$C2+$6
     21  1a52					      ENDIF
     22  1a52				  -	      IF	$10 = $70
     23  1a52				  -	      .byte	$D2+$6
     24  1a52					      ENDIF
     25  1a52				  -	      IF	$10 = $80
     26  1a52				  -	      .byte	$B2+$6
     27  1a52					      ENDIF
     28  1a52				  -	      IF	$10 = $90
     29  1a52				  -	      .byte	$92+$6
     30  1a52					      ENDIF
     31  1a52				  -	      IF	$10 = $A0
     32  1a52				  -	      .byte	$72+$6
     33  1a52					      ENDIF
     34  1a52				  -	      IF	$10 = $B0
     35  1a52				  -	      .byte	$52+$6
     36  1a52					      ENDIF
     37  1a52				  -	      IF	$10 = $C0
     38  1a52				  -	      .byte	$32+$6
     39  1a52					      ENDIF
     40  1a52				  -	      IF	$10 = $D0
     41  1a52				  -	      .byte	$32+$6
     42  1a52					      ENDIF
     43  1a52				  -	      IF	$10 = $E0
     44  1a52				  -	      .byte	$22+$6
     45  1a52					      ENDIF
     46  1a52				  -	      IF	$10 = $F0
     47  1a52				  -	      .byte	$42+$6
     48  1a52					      ENDIF
      0  1a52					      NTSCPAL	$C0,$6
      1  1a52		       c6		      .byte.b	$C0+$6
      0  1a53					      NTSC_TO_PAL	$C0,$6
      1  1a53				  -	      IF	$C0 = 0
      2  1a53				  -	      .byte	$C0+$6
      3  1a53					      ENDIF
      4  1a53				  -	      IF	$C0 = $10
      5  1a53				  -	      .byte	$22+$6
      6  1a53					      ENDIF
      7  1a53				  -	      IF	$C0 = $20
      8  1a53				  -	      .byte	$42+$6
      9  1a53					      ENDIF
     10  1a53				  -	      IF	$C0 = $30
     11  1a53				  -	      .byte	$42+$6
     12  1a53					      ENDIF
     13  1a53				  -	      IF	$C0 = $40
     14  1a53				  -	      .byte	$62+$6
     15  1a53					      ENDIF
     16  1a53				  -	      IF	$C0 = $50
     17  1a53				  -	      .byte	$82+$6
     18  1a53					      ENDIF
     19  1a53				  -	      IF	$C0 = $60
     20  1a53				  -	      .byte	$C2+$6
     21  1a53					      ENDIF
     22  1a53				  -	      IF	$C0 = $70
     23  1a53				  -	      .byte	$D2+$6
     24  1a53					      ENDIF
     25  1a53				  -	      IF	$C0 = $80
     26  1a53				  -	      .byte	$B2+$6
     27  1a53					      ENDIF
     28  1a53				  -	      IF	$C0 = $90
     29  1a53				  -	      .byte	$92+$6
     30  1a53					      ENDIF
     31  1a53				  -	      IF	$C0 = $A0
     32  1a53				  -	      .byte	$72+$6
     33  1a53					      ENDIF
     34  1a53				  -	      IF	$C0 = $B0
     35  1a53				  -	      .byte	$52+$6
     36  1a53					      ENDIF
     37  1a53					      IF	$C0 = $C0
     38  1a53		       38		      .byte.b	$32+$6
     39  1a54					      ENDIF
     40  1a54				  -	      IF	$C0 = $D0
     41  1a54				  -	      .byte	$32+$6
     42  1a54					      ENDIF
     43  1a54				  -	      IF	$C0 = $E0
     44  1a54				  -	      .byte	$22+$6
     45  1a54					      ENDIF
     46  1a54				  -	      IF	$C0 = $F0
     47  1a54				  -	      .byte	$42+$6
     48  1a54					      ENDIF
      0  1a54					      NTSCPAL	$70,$A
      1  1a54		       7a		      .byte.b	$70+$A
      0  1a55					      NTSC_TO_PAL	$70,$A
      1  1a55				  -	      IF	$70 = 0
      2  1a55				  -	      .byte	$70+$A
      3  1a55					      ENDIF
      4  1a55				  -	      IF	$70 = $10
      5  1a55				  -	      .byte	$22+$A
      6  1a55					      ENDIF
      7  1a55				  -	      IF	$70 = $20
      8  1a55				  -	      .byte	$42+$A
      9  1a55					      ENDIF
     10  1a55				  -	      IF	$70 = $30
     11  1a55				  -	      .byte	$42+$A
     12  1a55					      ENDIF
     13  1a55				  -	      IF	$70 = $40
     14  1a55				  -	      .byte	$62+$A
     15  1a55					      ENDIF
     16  1a55				  -	      IF	$70 = $50
     17  1a55				  -	      .byte	$82+$A
     18  1a55					      ENDIF
     19  1a55				  -	      IF	$70 = $60
     20  1a55				  -	      .byte	$C2+$A
     21  1a55					      ENDIF
     22  1a55					      IF	$70 = $70
     23  1a55		       dc		      .byte.b	$D2+$A
     24  1a56					      ENDIF
     25  1a56				  -	      IF	$70 = $80
     26  1a56				  -	      .byte	$B2+$A
     27  1a56					      ENDIF
     28  1a56				  -	      IF	$70 = $90
     29  1a56				  -	      .byte	$92+$A
     30  1a56					      ENDIF
     31  1a56				  -	      IF	$70 = $A0
     32  1a56				  -	      .byte	$72+$A
     33  1a56					      ENDIF
     34  1a56				  -	      IF	$70 = $B0
     35  1a56				  -	      .byte	$52+$A
     36  1a56					      ENDIF
     37  1a56				  -	      IF	$70 = $C0
     38  1a56				  -	      .byte	$32+$A
     39  1a56					      ENDIF
     40  1a56				  -	      IF	$70 = $D0
     41  1a56				  -	      .byte	$32+$A
     42  1a56					      ENDIF
     43  1a56				  -	      IF	$70 = $E0
     44  1a56				  -	      .byte	$22+$A
     45  1a56					      ENDIF
     46  1a56				  -	      IF	$70 = $F0
     47  1a56				  -	      .byte	$42+$A
     48  1a56					      ENDIF
      0  1a56					      NTSCPAL	$20,$A
      1  1a56		       2a		      .byte.b	$20+$A
      0  1a57					      NTSC_TO_PAL	$20,$A
      1  1a57				  -	      IF	$20 = 0
      2  1a57				  -	      .byte	$20+$A
      3  1a57					      ENDIF
      4  1a57				  -	      IF	$20 = $10
      5  1a57				  -	      .byte	$22+$A
      6  1a57					      ENDIF
      7  1a57					      IF	$20 = $20
      8  1a57		       4c		      .byte.b	$42+$A
      9  1a58					      ENDIF
     10  1a58				  -	      IF	$20 = $30
     11  1a58				  -	      .byte	$42+$A
     12  1a58					      ENDIF
     13  1a58				  -	      IF	$20 = $40
     14  1a58				  -	      .byte	$62+$A
     15  1a58					      ENDIF
     16  1a58				  -	      IF	$20 = $50
     17  1a58				  -	      .byte	$82+$A
     18  1a58					      ENDIF
     19  1a58				  -	      IF	$20 = $60
     20  1a58				  -	      .byte	$C2+$A
     21  1a58					      ENDIF
     22  1a58				  -	      IF	$20 = $70
     23  1a58				  -	      .byte	$D2+$A
     24  1a58					      ENDIF
     25  1a58				  -	      IF	$20 = $80
     26  1a58				  -	      .byte	$B2+$A
     27  1a58					      ENDIF
     28  1a58				  -	      IF	$20 = $90
     29  1a58				  -	      .byte	$92+$A
     30  1a58					      ENDIF
     31  1a58				  -	      IF	$20 = $A0
     32  1a58				  -	      .byte	$72+$A
     33  1a58					      ENDIF
     34  1a58				  -	      IF	$20 = $B0
     35  1a58				  -	      .byte	$52+$A
     36  1a58					      ENDIF
     37  1a58				  -	      IF	$20 = $C0
     38  1a58				  -	      .byte	$32+$A
     39  1a58					      ENDIF
     40  1a58				  -	      IF	$20 = $D0
     41  1a58				  -	      .byte	$32+$A
     42  1a58					      ENDIF
     43  1a58				  -	      IF	$20 = $E0
     44  1a58				  -	      .byte	$22+$A
     45  1a58					      ENDIF
     46  1a58				  -	      IF	$20 = $F0
     47  1a58				  -	      .byte	$42+$A
     48  1a58					      ENDIF
    623  1a58
    624  1a58
    625  1a58							;good...
    626  1a58							;walls
    627  1a58							; C6/36/16
    628  1a58							; 4a/a4/7a
    629  1a58							;bricks
    630  1a58							; 44/28/C6
    631  1a58
    632  1a58
      0  1a58					      DEFINE_SUBROUTINE	UnpackLevel
      1  1a58		       00 03	   BANK_UnpackLevel =	_CURRENT_BANK
      2  1a58					      SUBROUTINE
      3  1a58				   UnpackLevel
    634  1a58
    635  1a58		       85 c5		      sta	RAM_Bank
    636  1a5a
    637  1a5a							; has to be done before decoding the level to have the platform right:
    638  1a5a							;	    SET_PLATFORM
    639  1a5a
    640  1a5a		       a9 01		      lda	#CHARACTER_SOIL
    641  1a5c		       85 8b		      sta	POS_Type
    642  1a5e
    643  1a5e		       a9 13		      lda	#SIZE_BOARD_Y-1
    644  1a60		       85 88		      sta	POS_Y
    645  1a62		       a9 17	   xyLine     lda	#SIZE_BOARD_X-1
    646  1a64		       85 87		      sta	POS_X
    647  1a66		       20 3a f8    xyClear    jsr	PutBoardCharacterFromRAM
    648  1a69		       c6 87		      dec	POS_X
    649  1a6b		       10 f9		      bpl	xyClear
    650  1a6d		       c6 88		      dec	POS_Y
    651  1a6f		       10 f1		      bpl	xyLine
    652  1a71
    653  1a71		       a9 04		      lda	#4
    654  1a73		       85 db		      sta	base_x
    655  1a75		       85 dc		      sta	base_y
    656  1a77
    657  1a77		       a5 cb		      lda	NextLevelTrigger
    658  1a79		       09 80		      ora	#BIT_NEXTLEVEL
    659  1a7b		       85 cb		      sta	NextLevelTrigger
    660  1a7d
    661  1a7d		       a6 b3		      ldx	levelX
    662  1a7f		       bd 00 f0 	      lda	LevelInfoLO,x
    663  1a82		       85 c0		      sta	Board_AddressR
    664  1a84		       bd 99 f0 	      lda	LevelInfoHI,x
    665  1a87		       85 c1		      sta	Board_AddressR+1
    666  1a89		       bd 32 f1 	      lda	LevelInfoBANK,x
    667  1a8c		       85 ab		      sta	LEVEL_bank
    668  1a8e
    669  1a8e		       a9 03		      lda	#BANK_UnpackLevel	; the *ROM* bank of this routine (NOT RAM)
    670  1a90		       85 c4		      sta	ROM_Bank	; GetROMByte returns to this bank
    671  1a92
    672  1a92		       a5 b3		      lda	levelX
    673  1a94		       29 03		      and	#3
    674  1a96		       0a		      asl
    675  1a97		       0a		      asl
    676  1a98		       05 80		      ora	Platform	; NTSC/PAL
    677  1a9a		       4a		      lsr
    678  1a9b		       aa		      tax
    679  1a9c		       bd 40 f2 	      lda	C1,x
    680  1a9f		       85 bd		      sta	color
    681  1aa1		       bd 48 f2 	      lda	C2,x
    682  1aa4		       85 be		      sta	color+1
    683  1aa6		       bd 50 f2 	      lda	C3,x
    684  1aa9		       85 bf		      sta	color+2
    685  1aab
    686  1aab		       a9 00		      lda	#$00
    687  1aad		       85 b8		      sta	BCD_moveCounter
    688  1aaf		       85 b9		      sta	BCD_moveCounterHi
    689  1ab1		       85 ba		      sta	takebackIndex
    690  1ab3		       85 bb		      sta	takebackBaseIndex
    691  1ab5
    692  1ab5		       a9 00		      lda	#$00	; BCD reminder!
    693  1ab7		       85 b7		      sta	BCD_targetsRequired	; # of targets that do NOT have boxes on them
    694  1ab9
    695  1ab9		       a6 80		      ldx	Platform
    696  1abb		       bd c4 f3 	      lda	theThrottler,x
    697  1abe		       85 b6		      sta	ThrottleSpeed
    698  1ac0
    699  1ac0							; first fill bg with character_soil
    700  1ac0							; then rle unpack level
    701  1ac0							; change level colours
    702  1ac0
    703  1ac0		       a9 00		      lda	#0
    704  1ac2		       85 87		      sta	POS_X
    705  1ac4		       85 88		      sta	POS_Y
    706  1ac6		       85 96		      sta	BoardLimit_Width
    707  1ac8		       85 97		      sta	BoardLimit_Height
    708  1aca
    709  1aca				   GetNextItem
    710  1aca
    711  1aca		       a9 01		      lda	#1
    712  1acc		       85 dd		      sta	upk_length
    713  1ace		       a9 00		      lda	#0
    714  1ad0		       85 de		      sta	upk_column	; reuse var - this flags a digit already
    715  1ad2
    716  1ad2		       e6 c0	   Get2       inc	Board_AddressR
    717  1ad4		       d0 02		      bne	addrOK
    718  1ad6		       e6 c1		      inc	Board_AddressR+1
    719  1ad8				   addrOK
    720  1ad8
    721  1ad8		       a5 ab		      lda	LEVEL_bank
    722  1ada		       a0 00		      ldy	#0
    723  1adc		       20 0f f8 	      jsr	GetROMByte
    724  1adf		       85 df		      sta	upk_temp	;scratch
    725  1ae1
    726  1ae1
    727  1ae1		       c9 00		      cmp	#0
    728  1ae3		       d0 03		      bne	parse
    729  1ae5		       4c cb f1 	      jmp	finX
    730  1ae8				   parse
    731  1ae8		       c9 3a		      cmp	#"9"+1
    732  1aea		       b0 1e		      bcs	notDigit
    733  1aec		       c9 30		      cmp	#"0"
    734  1aee		       90 1a		      bcc	notDigit
    735  1af0
    736  1af0		       a5 de		      lda	upk_column
    737  1af2		       f0 09		      beq	firstDig
    738  1af4
    739  1af4		       a5 dd		      lda	upk_length
    740  1af6		       0a		      asl
    741  1af7		       0a		      asl
    742  1af8		       0a		      asl
    743  1af9		       65 dd		      adc	upk_length
    744  1afb		       65 dd		      adc	upk_length
    745  1afd
    746  1afd		       18	   firstDig   clc
    747  1afe		       65 df		      adc	upk_temp
    748  1b00		       38		      sec
    749  1b01		       e9 30		      sbc	#"0"
    750  1b03		       85 dd		      sta	upk_length
    751  1b05		       e6 de		      inc	upk_column	; flag we have seen a digit
    752  1b07		       4c d2 f2 	      jmp	Get2
    753  1b0a
    754  1b0a		       c9 7c	   notDigit   cmp	#"|"	; newline
    755  1b0c		       d0 11		      bne	checkWall
    756  1b0e
    757  1b0e							; Handle new-line
    758  1b0e		       a9 00		      lda	#0
    759  1b10		       85 87		      sta	POS_X
    760  1b12		       e6 88		      inc	POS_Y
    761  1b14
    762  1b14
    763  1b14		       a5 88		      lda	POS_Y
    764  1b16		       c5 97		      cmp	BoardLimit_Height
    765  1b18		       90 02		      bcc	wOK2
    766  1b1a		       85 97		      sta	BoardLimit_Height	;???^^^
    767  1b1c				   wOK2
    768  1b1c
    769  1b1c		       4c ca f2 	      jmp	GetNextItem
    770  1b1f
    771  1b1f		       c9 23	   checkWall  cmp	#"#"	; wall
    772  1b21		       d0 09		      bne	checkForGap
    773  1b23		       a5 b3		      lda	levelX
    774  1b25		       29 01		      and	#1
    775  1b27		       18		      clc
    776  1b28		       69 06		      adc	#CHARACTER_STEEL
    777  1b2a		       d0 62		      bne	WriteChars
    778  1b2c
    779  1b2c		       c9 20	   checkForGap cmp	#32
    780  1b2e		       f0 08		      beq	writeGap
    781  1b30		       c9 2d		      cmp	#"-"
    782  1b32		       f0 04		      beq	writeGap
    783  1b34		       c9 5f		      cmp	#"_"
    784  1b36		       d0 05		      bne	checkForMan
    785  1b38
    786  1b38		       a9 00	   writeGap   lda	#CHARACTER_BLANK
    787  1b3a		       4c 8e f3 	      jmp	WriteChars
    788  1b3d
    789  1b3d				   checkForMan
    790  1b3d		       c9 2b		      cmp	#"+"	; player on goal square
    791  1b3f		       d0 07		      bne	notPlayerGoal
    792  1b41
    793  1b41		       20 c3 fc 	      jsr	RegisterTarget
    794  1b44
    795  1b44							; put goal square, init player with POS_VAR = CHARACTER_TARGET
    796  1b44
    797  1b44		       a9 03		      lda	#CHARACTER_TARGET
    798  1b46		       d0 06		      bne	genPlayer
    799  1b48
    800  1b48				   notPlayerGoal
    801  1b48		       c9 40		      cmp	#"@"	; player on normal square
    802  1b4a		       d0 29		      bne	checkBox
    803  1b4c
    804  1b4c		       a9 00		      lda	#CHARACTER_BLANK
    805  1b4e
    806  1b4e				   genPlayer
    807  1b4e
    808  1b4e		       85 8c		      sta	POS_VAR	; character man is on
    809  1b50
    810  1b50		       18		      clc
    811  1b51		       a5 87		      lda	POS_X
    812  1b53		       48		      pha
    813  1b54		       65 db		      adc	base_x
    814  1b56		       85 87		      sta	POS_X
    815  1b58		       85 9f		      sta	ManX
    816  1b5a
    817  1b5a		       a5 88		      lda	POS_Y
    818  1b5c		       48		      pha
    819  1b5d		       65 dc		      adc	base_y
    820  1b5f		       85 88		      sta	POS_Y
    821  1b61		       85 a0		      sta	ManY
    822  1b63
    823  1b63							; POS_X     x position
    824  1b63							; POS_Y     y position
    825  1b63							; POS_VAR   CHARACTER UNDER MAN TO RESTORE
    826  1b63							; POS_Type  type of object
    827  1b63
    828  1b63		       a9 00		      lda	#TYPE_MAN
    829  1b65		       85 8b		      sta	POS_Type	;	 creature TYPE
    830  1b67		       20 05 f9 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    831  1b6a
    832  1b6a		       68		      pla
    833  1b6b		       85 88		      sta	POS_Y
    834  1b6d		       68		      pla
    835  1b6e		       85 87		      sta	POS_X
    836  1b70
    837  1b70		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    838  1b72		       4c 8e f3 	      jmp	WriteChars
    839  1b75
    840  1b75		       c9 24	   checkBox   cmp	#"$"
    841  1b77		       d0 04		      bne	checkBoxTarget
    842  1b79
    843  1b79		       a9 02		      lda	#CHARACTER_BOX
    844  1b7b		       d0 11		      bne	WriteChars
    845  1b7d
    846  1b7d		       c9 2a	   checkBoxTarget cmp	#"*"
    847  1b7f		       d0 04		      bne	checkTarget
    848  1b81
    849  1b81		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    850  1b83		       d0 09		      bne	WriteChars
    851  1b85
    852  1b85		       c9 2e	   checkTarget cmp	#"."
    853  1b87		       f0 03		      beq	targ
    854  1b89		       4c ca f2 	      jmp	GetNextItem
    855  1b8c				   targ
    856  1b8c
    857  1b8c		       a9 03		      lda	#CHARACTER_TARGET
    858  1b8e
    859  1b8e		       85 8b	   WriteChars sta	POS_Type
    860  1b90
    861  1b90		       18	   Wc2x       clc
    862  1b91		       a5 87		      lda	POS_X
    863  1b93		       48		      pha
    864  1b94		       65 db		      adc	base_x
    865  1b96		       85 87		      sta	POS_X
    866  1b98
    867  1b98		       a5 88		      lda	POS_Y
    868  1b9a		       48		      pha
    869  1b9b		       65 dc		      adc	base_y
    870  1b9d		       85 88		      sta	POS_Y
    871  1b9f
    872  1b9f		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    873  1ba2
    874  1ba2		       a5 8b		      lda	POS_Type
    875  1ba4		       c9 03		      cmp	#CHARACTER_TARGET
    876  1ba6		       d0 03		      bne	notargdet
    877  1ba8		       20 c3 fc 	      jsr	RegisterTarget
    878  1bab				   notargdet
    879  1bab
    880  1bab		       68		      pla
    881  1bac		       85 88		      sta	POS_Y
    882  1bae		       68		      pla
    883  1baf		       85 87		      sta	POS_X
    884  1bb1
    885  1bb1		       18		      clc
    886  1bb2		       69 01		      adc	#1
    887  1bb4		       85 87		      sta	POS_X
    888  1bb6
    889  1bb6		       c5 96		      cmp	BoardLimit_Width
    890  1bb8		       90 02		      bcc	wOK
    891  1bba		       85 96		      sta	BoardLimit_Width
    892  1bbc				   wOK
    893  1bbc
    894  1bbc		       c6 dd		      dec	upk_length
    895  1bbe		       d0 d0		      bne	Wc2x
    896  1bc0		       4c ca f2 	      jmp	GetNextItem
    897  1bc3
    898  1bc3				   finishedUnpack
    899  1bc3
    900  1bc3		       60		      rts
    901  1bc3					      endif
    902  1bc4
    903  1bc4				   theThrottler
    904  1bc4		       1e 1e 24 1e	      .byte.b	30, 30, 30*60/50, 30
------- FILE BANK_GENERIC.asm
     44  1bc8
      0  1bc8					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_LEVEL)"
      1  1bc8
      2  1bc8
      3  1bc8		       03 c8	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_LEVEL) (1K) SIZE =  $3c8 , FREE= $38
      4  1bc8					      ECHO	"GENERIC_BANK_1 (DECODE_LEVEL)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1bc8				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1bc8				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1bc8				  -	      ERR
      8  1bc8					      endif
     46  1bc8
     47  1bc8							;------------------------------------------------------------------------------
     48  1bc8							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     49  1bc8							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     50  1bc8							; bank finishes.  Just continue on from where it left off...
     51  1bc8							;------------------------------------------------------------------------------
     52  1bc8
      0  1bc8					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  1bc8		       00 03	   BANK_Cart_Init =	_CURRENT_BANK
      2  1bc8					      SUBROUTINE
      3  1bc8				   Cart_Init
     54  1bc8
     55  1bc8							; Note the variables from the title selection are incredibly transient an can be stomped
     56  1bc8							; at any time.  So they need to be used immediately.
     57  1bc8
     58  1bc8
     59  1bc8							; odd usage below is to prevent any possibility of variable stomping/assumptions
     60  1bc8
     61  1bc8		       a9 01		      lda	#1
     62  1bca		       a2 00		      ldx	#0	;sLevel				      ; level # from title select
     63  1bcc		       a0 00		      ldy	#0	;sJoysticks
     64  1bce		       84 aa		      sty	jtoggle
     65  1bd0		       86 b4		      stx	level
     66  1bd2		       a9 00		      lda	#0
     67  1bd4							;sta levelX					    ; make an immediate copy to safe variables!
     68  1bd4		       85 e1		      sta	startingLevel
     69  1bd6
     70  1bd6							; multiply with LEVEL_DEFINITION_SIZE (5):
     71  1bd6		       0a		      asl
     72  1bd7		       0a		      asl
     73  1bd8		       85 b3		      sta	levelX
     74  1bda
      0  1bda					      LOAD_ANIMATION	Animation_IDLE
      1  1bda		       a9 36		      lda	#<Animation_IDLE
      2  1bdc		       85 9c		      sta	animation
      3  1bde		       a9 f0		      lda	#>Animation_IDLE
      4  1be0		       85 9d		      sta	animation+1
      5  1be2		       a9 00		      lda	#0
      6  1be4		       85 9e		      sta	animation_delay
     76  1be6		       a9 02		      lda	#ANIMATION_IDLE_ID
     77  1be8		       85 a8		      sta	ManAnimationID
     78  1bea
     79  1bea		       a9 00		      lda	#0
     80  1bec		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     81  1bef		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     82  1bf2		       85 6b		      sta	HMCLR
     83  1bf4
     84  1bf4							; cleanup remains of title screen
     85  1bf4		       85 5b		      sta	GRP0
     86  1bf6		       85 5c		      sta	GRP1
     87  1bf8							;?		   sta GRP0
     88  1bf8
     89  1bf8		       85 86		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     90  1bfa		       85 ce		      sta	ethnic
     91  1bfc
     92  1bfc				  -	      if	0
     93  1bfc				  -	      sta	circle_d
     94  1bfc				  -	      sta	circle_d+1
     95  1bfc					      endif
     96  1bfc
     97  1bfc							;    IFCONST DEBUG_CREATURE
     98  1bfc							;		  sta worstTime
     99  1bfc							;    ENDIF
    100  1bfc
    101  1bfc		       a9 04		      lda	#%100	; players/missiles BEHIND BG
    102  1bfe		       85 4a		      sta	CTRLPF
    103  1c00
    104  1c00		       a9 ff		      lda	#$FF
    105  1c02		       85 81		      sta	DrawStackPointer
    106  1c04		       85 94		      sta	BufferedButton
    107  1c06		       85 95		      sta	BufferedButton+1
    108  1c08
    109  1c08							;lda #DIRECTION_BITS		  ;???
    110  1c08							;sta ManLastDirection
    111  1c08
    112  1c08							;lda #0
    113  1c08							;		  sta ObjStackPtr		  ; object stack index of last entry
    114  1c08							;		  sta ObjStackPtr+1
    115  1c08							;		  sta ObjStackNum
    116  1c08							;		  sta ObjIterator
    117  1c08
    118  1c08							;sta sortPtr
    119  1c08							;lda #<(-1)
    120  1c08							;sta sortRequired
    121  1c08
    122  1c08							; read high score from SaveKey and store in highScoreSK,
    123  1c08							; which is transferred to high score variable in RAM by GeneralScoringSetups
    124  1c08		       4c f7 f5 	      jmp	ReadSaveKey
    125  1c0b
    126  1c0b							;------------------------------------------------------------------------------
    127  1c0b
      0  1c0b					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  1c0b		       00 03	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  1c0b					      SUBROUTINE
      3  1c0b				   SwapPlayersGeneric
    129  1c0b
    130  1c0b							; at the start of a level (or player, doesn't matter) we grab the current state of the colour/B&W switch
    131  1c0b							; into the gameMode variable.
    132  1c0b
    133  1c0b							;		  lda gameMode
    134  1c0b							;		  and #~(BW_SWITCH|GAMEMODE_PAUSED)
    135  1c0b							;		  sta gameMode
    136  1c0b							;		  lda SWCHB
    137  1c0b							;		  and #BW_SWITCH
    138  1c0b							;		  ora gameMode			  ; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    139  1c0b							;		  sta gameMode			  ; also, BIT7=0 -- system is NOT paused
    140  1c0b
    141  1c0b
    142  1c0b							; restart level
    143  1c0b		       a5 cb		      lda	NextLevelTrigger
    144  1c0d		       29 bf		      and	#<(~BIT_NEXTLIFE)
    145  1c0f		       85 cb		      sta	NextLevelTrigger
    146  1c11
    147  1c11							; if new high score was set by SwapPlayers, update it:
    148  1c11
    149  1c11		       4c 1d f6 	      jmp	WriteSaveKey
    150  1c14
    151  1c14
    152  1c14							;------------------------------------------------------------------------------
    153  1c14
      0  1c14					      DEFINE_SUBROUTINE	CreateCreatures
      1  1c14		       00 03	   BANK_CreateCreatures =	_CURRENT_BANK
      2  1c14					      SUBROUTINE
      3  1c14				   CreateCreatures
    155  1c14
    156  1c14							; Calculate rightmost value for scrolling edge.  .
    157  1c14
    158  1c14		       85 c4		      sta	ROM_Bank
    159  1c16
    160  1c16		       38		      sec
    161  1c17		       a5 96		      lda	BoardLimit_Width
    162  1c19		       e9 09		      sbc	#SCREEN_WIDTH-1
    163  1c1b		       85 96		      sta	BoardEdge_Right	; absolute rightmost scroll value
    164  1c1d
    165  1c1d							;		  sec			     already set
    166  1c1d		       a5 97		      lda	BoardLimit_Height
    167  1c1f		       e9 07		      sbc	#SCREEN_LINES-1
    168  1c21		       85 97		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    169  1c23
    170  1c23							; kludge position scroll roughly at player
    171  1c23
    172  1c23							;		  sec			 already set
    173  1c23		       a5 9f		      lda	ManX
    174  1c25		       e9 05		      sbc	#5
    175  1c27		       b0 02		      bcs	notL0
    176  1c29		       a9 00		      lda	#0
    177  1c2b		       85 99	   notL0      sta	BoardScrollX
    178  1c2d
    179  1c2d		       38		      sec
    180  1c2e		       a5 a0		      lda	ManY
    181  1c30		       e9 04		      sbc	#4
    182  1c32		       b0 02		      bcs	notU0
    183  1c34		       a9 00		      lda	#0
    184  1c36		       85 98	   notU0      sta	BoardScrollY
    185  1c38
    186  1c38		       a9 00		      lda	#0
    187  1c3a		       85 a3		      sta	ManMode
    188  1c3c							;sta ManDelayCount
    189  1c3c		       85 bc		      sta	TakebackInhibit
    190  1c3e		       85 db		      sta	base_x
    191  1c40		       85 dc		      sta	base_y
    192  1c42		       85 a6		      sta	ManPushCounter
    193  1c44
    194  1c44		       a9 ff		      lda	#$FF
    195  1c46		       85 b0		      sta	LastSpriteY
    196  1c48		       85 a8		      sta	ManAnimationID
    197  1c4a
    198  1c4a							;lda #DIRECTION_BITS		  ;????
    199  1c4a							;sta ManLastDirection		  ; duplicate?
    200  1c4a
    201  1c4a		       60		      rts
    202  1c4b
    203  1c4b							;-------------------------------------------------------------------------------------
    204  1c4b
      0  1c4b					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  1c4b		       00 03	   BANK_LevelInit =	_CURRENT_BANK
      2  1c4b					      SUBROUTINE
      3  1c4b				   LevelInit
    206  1c4b
    207  1c4b		       a9 00		      lda	#0
    208  1c4d		       85 83		      sta	ObjStackPtr
    209  1c4f		       85 84		      sta	ObjStackPtr+1	; kill all creatures
    210  1c51		       85 82		      sta	ObjStackNum
    211  1c53		       85 cc		      sta	ObjIterator
    212  1c55
    213  1c55		       85 9a		      sta	scrollBits
    214  1c57		       85 86		      sta	ScreenDrawPhase
    215  1c59
    216  1c59		       85 b2		      sta	BGColour
    217  1c5b		       85 c6		      sta	ColourTimer
    218  1c5d
    219  1c5d		       85 59		      sta	AUDV0
    220  1c5f		       85 5a		      sta	AUDV1	; turn off music while levels init
    221  1c61							;		  sta AUDC0
    222  1c61
    223  1c61							;sta ManLastDirection
    224  1c61							;sta ManPushCounter
    225  1c61
    226  1c61							;sta sortPtr			  ; sort stopped
    227  1c61							;lda #<(-1)
    228  1c61							;sta sortRequired		  ; nothing needed
    229  1c61		       85 81		      sta	DrawStackPointer
    230  1c63
    231  1c63		       a9 00		      lda	#DISPLAY_TIME	;DISPLAY_SCORE
    232  1c65		       85 ca		      sta	scoringFlags
    233  1c67		       a9 00		      lda	#0	;SCORING_TIMER_FIRST		      ; We want the first timer display to be long, to show level and lives
    234  1c69		       85 c9		      sta	scoringTimer
    235  1c6b
    236  1c6b		       18		      clc
    237  1c6c		       a5 ce		      lda	ethnic
    238  1c6e		       69 10		      adc	#16
    239  1c70		       c9 40		      cmp	#4*16
    240  1c72		       90 02		      bcc	ethOK
    241  1c74		       a9 00		      lda	#0
    242  1c76		       85 ce	   ethOK      sta	ethnic
    243  1c78
    244  1c78		       60		      rts
    245  1c79
    246  1c79							;-------------------------------------------------------------------------------------
    247  1c79
      0  1c79					      DEFINE_SUBROUTINE	Resync
      1  1c79		       00 03	   BANK_Resync =	_CURRENT_BANK
      2  1c79					      SUBROUTINE
      3  1c79				   Resync
      0  1c79					      RESYNC
      1  1c79
      2  1c79		       a9 02		      lda	#%10
      3  1c7b		       85 41		      sta	VBLANK
      4  1c7d
      5  1c7d		       a2 08		      ldx	#8
      6  1c7f				   .loopResync
      0  1c7f					      VERTICAL_SYNC
      1  1c7f		       a9 0e		      lda	#%1110
      2  1c81		       85 42	   .VSLP1     sta	WSYNC
      3  1c83		       85 40		      sta	VSYNC
      4  1c85		       4a		      lsr
      5  1c86		       d0 f9		      bne	.VSLP1
      8  1c88
      9  1c88		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  1c8a		       a5 80		      lda	Platform
     11  1c8c		       49 02		      eor	#PAL_50
     12  1c8e		       d0 02		      bne	.ntsc
     13  1c90		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  1c92				   .ntsc
     15  1c92				   .loopWait
     16  1c92		       85 42		      sta	WSYNC
     17  1c94		       85 42		      sta	WSYNC
     18  1c96		       88		      dey
     19  1c97		       d0 f9		      bne	.loopWait
     20  1c99		       ca		      dex
     21  1c9a		       d0 e3		      bne	.loopResync
    250  1c9c		       60	   Ret	      rts
    251  1c9d
    252  1c9d							;---------------------------------------------------------------------------
    253  1c9d
      0  1c9d					      DEFINE_SUBROUTINE	TrackPlayer	; =145; in GENERIC_BANK_1
      1  1c9d		       00 03	   BANK_TrackPlayer =	_CURRENT_BANK
      2  1c9d					      SUBROUTINE
      3  1c9d				   TrackPlayer
    255  1c9d
    256  1c9d		       a5 a7		      lda	LookingAround	; 3
    257  1c9f		       d0 fb		      bne	Ret	; 2/3=5/6   don't track when looking around
    258  1ca1
    259  1ca1							; Contribution by Thomas Jentzsch
    260  1ca1
    261  1ca1							; scrolling constants:
    262  1ca1		       00 02	   .SCRL_START_LEFT =	2	; 3
    263  1ca1		       00 02	   .SCRL_STOP_LEFT =	2	;SCREEN_WIDTH-5		    ; 5 scrolls 5-3+1 = 3 pixel
    264  1ca1		       00 08	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT	; 7
    265  1ca1		       00 08	   .SCRL_STOP_RIGHT =	SCREEN_WIDTH-.SCRL_STOP_LEFT	; 5
    266  1ca1		       00 11	   .SCRL_LEFT_BIT =	%00010001
    267  1ca1		       00 22	   .SCRL_RIGHT_BIT =	%00100010
    268  1ca1		       00 33	   .SCRL_X_BITS =	.SCRL_LEFT_BIT|.SCRL_RIGHT_BIT
    269  1ca1
    270  1ca1		       00 02	   .SCRL_START_UP =	2	; 2
    271  1ca1		       00 02	   .SCRL_STOP_UP =	2	;SCREEN_LINES-5		    ; 3 scrolls 3-2+1 = 2 pixel
    272  1ca1		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP	; 6
    273  1ca1		       00 06	   .SCRL_STOP_DOWN =	SCREEN_LINES-.SCRL_STOP_UP	; 5
    274  1ca1		       00 44	   .SCRL_UP_BIT =	%01000100
    275  1ca1		       00 88	   .SCRL_DOWN_BIT =	%10001000
    276  1ca1		       00 cc	   .SCRL_Y_BITS =	.SCRL_UP_BIT|.SCRL_DOWN_BIT
    277  1ca1
    278  1ca1							; *** horizontal scrolling (unoptimized version): ***
    279  1ca1
    280  1ca1							; check for enabling horizontal scrolling:
    281  1ca1		       a5 9f		      lda	ManX	; 3
    282  1ca3		       38		      sec		; 2
    283  1ca4		       e5 99		      sbc	BoardScrollX	; 3
    284  1ca6		       a8		      tay		; 2	     for later use
    285  1ca7		       a9 11		      lda	#.SCRL_LEFT_BIT	; 2
    286  1ca9		       c0 02		      cpy	#.SCRL_START_LEFT	; 2	     <3?
    287  1cab		       30 06		      bmi	.startXScroll	; 2/3	     yes, scroll left
    288  1cad		       c0 08		      cpy	#.SCRL_START_RIGHT	; 2	     <8?
    289  1caf		       30 08		      bmi	.skipStartXScroll	; 2/3	     no
    290  1cb1		       a9 22		      lda	#.SCRL_RIGHT_BIT	; 2 = 22    yes, scroll right
    291  1cb3				   .startXScroll
    292  1cb3		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    293  1cb5		       05 9a		      ora	scrollBits	; 3
    294  1cb7		       85 9a		      sta	scrollBits	; 3 =	8
    295  1cb9				   .skipStartXScroll
    296  1cb9
    297  1cb9							; do horizontal scrolling:
    298  1cb9		       a5 9a		      lda	scrollBits	; 3
    299  1cbb		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    300  1cbd		       f0 23		      beq	.skipXScroll	; 2/3
    301  1cbf		       29 22		      and	#.SCRL_RIGHT_BIT	; 2
    302  1cc1		       d0 0c		      bne	.xScrollRight	; 2/3=11/12
    303  1cc3
    304  1cc3							; scroll left:
    305  1cc3		       a5 99		      lda	BoardScrollX	; 3	     already at left edge?
    306  1cc5		       f0 15		      beq	.stopXScroll	; 2
    307  1cc7		       c6 99		      dec	BoardScrollX	; 5
    308  1cc9		       c0 01		      cpy	#.SCRL_STOP_LEFT-1	; 2
    309  1ccb		       10 0f		      bpl	.stopXScroll	; 2/3=15
    310  1ccd		       30 13		      bmi	.skipXScroll	; 3
    311  1ccf							;---------------------------------------
    312  1ccf				   .xScrollRight
    313  1ccf		       a6 99		      ldx	BoardScrollX	; 3
    314  1cd1		       e8		      inx		; 2
    315  1cd2		       e4 96		      cpx	BoardEdge_Right	; 3	     already at right edge?
    316  1cd4		       10 06		      bpl	.stopXScroll	; 2/3
    317  1cd6		       86 99		      stx	BoardScrollX	; 3
    318  1cd8		       c0 09		      cpy	#.SCRL_STOP_RIGHT+1	; 2
    319  1cda		       10 06		      bpl	.skipXScroll	; 2/3=17/18
    320  1cdc				   .stopXScroll
    321  1cdc		       a5 9a		      lda	scrollBits	; 3
    322  1cde		       29 fc		      and	#(~(.SCRL_X_BITS >> 4))	; 2
    323  1ce0		       85 9a		      sta	scrollBits	; 3 =	8
    324  1ce2				   .skipXScroll
    325  1ce2							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    326  1ce2
    327  1ce2							; *** vertical scrolling (unoptimized version): ***
    328  1ce2
    329  1ce2							; check for enabling vertical scrolling:
    330  1ce2		       a5 a0		      lda	ManY	; 3
    331  1ce4		       38		      sec		; 2
    332  1ce5		       e5 98		      sbc	BoardScrollY	; 3
    333  1ce7		       a8		      tay		; 2	     for later use
    334  1ce8		       a9 44		      lda	#.SCRL_UP_BIT	; 2
    335  1cea		       c0 02		      cpy	#.SCRL_START_UP	; 2	     <2?
    336  1cec		       30 06		      bmi	.startYScroll	; 2/3	     yes, scroll up
    337  1cee		       c0 06		      cpy	#.SCRL_START_DOWN	; 2	     <6?
    338  1cf0		       30 08		      bmi	.skipStartYScroll	; 2/3
    339  1cf2		       a9 88		      lda	#.SCRL_DOWN_BIT	; 2 = 22    yes, scroll down
    340  1cf4				   .startYScroll
    341  1cf4		       29 0c		      and	#.SCRL_Y_BITS >> 4	; 2
    342  1cf6		       05 9a		      ora	scrollBits	; 3
    343  1cf8		       85 9a		      sta	scrollBits	; 3 =	8
    344  1cfa				   .skipStartYScroll
    345  1cfa
    346  1cfa							; do vertical scrolling:
    347  1cfa		       a5 9a		      lda	scrollBits	; 3
    348  1cfc		       29 cc		      and	#.SCRL_Y_BITS	; 2
    349  1cfe		       f0 23		      beq	.skipYScroll	; 2/3
    350  1d00		       29 88		      and	#.SCRL_DOWN_BIT	; 2
    351  1d02		       d0 0c		      bne	.yScrollDown	; 2/3=11/12
    352  1d04
    353  1d04							; scroll up
    354  1d04		       a5 98		      lda	BoardScrollY	; 3
    355  1d06		       f0 15		      beq	.stopYScroll	; 2
    356  1d08		       c6 98		      dec	BoardScrollY	; 5
    357  1d0a		       c0 01		      cpy	#.SCRL_STOP_UP-1	; 2
    358  1d0c		       10 0f		      bpl	.stopYScroll	; 2/3=15
    359  1d0e		       30 13		      bmi	.skipYScroll	; 3
    360  1d10							;---------------------------------------
    361  1d10				   .yScrollDown
    362  1d10		       a6 98		      ldx	BoardScrollY	; 3
    363  1d12		       e8		      inx		; 2
    364  1d13		       e4 97		      cpx	BoardEdge_Bottom	;     ; 3
    365  1d15		       10 06		      bpl	.stopYScroll	; 2/3
    366  1d17		       86 98		      stx	BoardScrollY	; 3
    367  1d19		       c0 07		      cpy	#.SCRL_STOP_DOWN+1	; 2
    368  1d1b		       10 06		      bpl	.skipYScroll	; 2/3=17/18
    369  1d1d				   .stopYScroll
    370  1d1d		       a5 9a		      lda	scrollBits	; 3
    371  1d1f		       29 f3		      and	#(~(.SCRL_Y_BITS >> 4))	; 2
    372  1d21		       85 9a		      sta	scrollBits	; 3 =	8
    373  1d23				   .skipYScroll
    374  1d23							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    375  1d23
    376  1d23		       60	   EarlyAbortx rts		; 6 =	6
    377  1d24							; total: 5+67*2+6 = 145
    378  1d24
    379  1d24
    380  1d24							;------------------------------------------------------------------------------
    381  1d24
    382  1d24							; This is a GOOD home for these tables.
    383  1d24
      0  1d24					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  1d24		       00 03	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  1d24					      SUBROUTINE
      3  1d24				   TS_PhaseVectorLO
    385  1d24
    386  1d24							; Gives LO byte of addresses of subroutines for timeslice processing
    387  1d24							; note +31✅ cycles at start of the function called
    388  1d24
    389  1d24		       58		      .byte.b	<ProcessObjStack	; abort = 46✅
    390  1d25		       e3		      .byte.b	<DrawFullScreen	; abort = 46✅
    391  1d26		       8e		      .byte.b	<BuildDrawStack	; abort = 54✅
    392  1d27		       95		      .byte.b	<DrawAIntoStack	; abort = 54✅
    393  1d28		       91		      .byte.b	<SwitchObjects	; abort = 46✅
    394  1d29
    395  1d29				   TS_PhaseVectorHI
    396  1d29
    397  1d29							; Gives HI byte of addresses of subroutines for timeslice processing
    398  1d29
    399  1d29		       f8		      .byte.b	>ProcessObjStack
    400  1d2a		       f2		      .byte.b	>DrawFullScreen
    401  1d2b		       fb		      .byte.b	>BuildDrawStack
    402  1d2c		       fb		      .byte.b	>DrawAIntoStack
    403  1d2d		       f8		      .byte.b	>SwitchObjects
    404  1d2e
    405  1d2e				   TS_PhaseBank
    406  1d2e
    407  1d2e							; Gives bank of subroutines for timeslice processing
    408  1d2e
    409  1d2e		       0f		      .byte.b	BANK_ProcessObjStack
    410  1d2f		       0d		      .byte.b	BANK_DrawFullScreen
    411  1d30		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    412  1d31		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    413  1d32		       0f		      .byte.b	BANK_SwitchObjects
    414  1d33
    415  1d33							;------------------------------------------------------------------------------
    416  1d33		       02 02	   lookColour2 .byte.b	$02, $02
    417  1d35		       04 04		      .byte.b	$04, $04
    418  1d37
    419  1d37				   OverscanTime
    420  1d37		       23 23		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    421  1d39		       29 23		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    422  1d3b
    423  1d3b		       c4 c4 54 54 FlashColour .byte.b	$C4, $C4, $54, $54
    424  1d3f		       34 34 64 64	      .byte.b	$34, $34, $64, $64	; reds - cannot takeback
    425  1d43		       16 16 26 26	      .byte.b	$16, $16, $26, $26	; yellow
    426  1d47
    427  1d47
      0  1d47					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  1d47		       00 03	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  1d47					      SUBROUTINE
      3  1d47				   PostScreenCleanup
    429  1d47
    430  1d47		       c8		      iny		; --> 0
    431  1d48
    432  1d48		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    433  1d4a							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    434  1d4a
    435  1d4a		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    436  1d4c							; TJ: no idea why, but you had removed it in revision 758 ;)
    437  1d4c							; completely accidental -- one of our cats may have deleted it.
    438  1d4c		       84 4e		      sty	PF1
    439  1d4e		       84 4f		      sty	PF2
    440  1d50		       84 5d		      sty	ENAM0
    441  1d52		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    442  1d54		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    443  1d56
    444  1d56							; D1 VBLANK turns off beam
    445  1d56
    446  1d56		       a9 42		      lda	#%01000010	; bit6 is not required
    447  1d58		       85 41		      sta	VBLANK	; end of screen - enter blanking
    448  1d5a
    449  1d5a							;------------------------------------------------------------------------------
    450  1d5a							; This is where the PAL system has a bit of extra time on a per-frame basis.
    451  1d5a
    452  1d5a		       a6 80		      ldx	Platform
    453  1d5c		       bd 37 f5 	      lda	OverscanTime,x
    454  1d5f		       8d 96 02 	      sta	TIM64T
    455  1d62
    456  1d62							; Background colour priorities. Increasing order of priority...
    457  1d62							;	black -- nothing happening
    458  1d62							;	looking around			     lookingAround<0		     BLUE
    459  1d62							;	when paused			     gameMode... BIT7		     RED
    460  1d62							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    461  1d62
    462  1d62
    463  1d62							;		  lda LookingAround
    464  1d62							;		  bpl nolooker			  ; if not looking around, that will do nicely
    465  1d62							;		  ldy #0 ;sok
    466  1d62							;;		   ldy lookColour2,x		   ; otherwise, use the lookaround colour as the base
    467  1d62							;nolooker	  sty BGColour			  ; 'BASE' colour pause reverts TO when unpaused
    468  1d62
    469  1d62		       a5 b6		      lda	ThrottleSpeed
    470  1d64		       18		      clc
    471  1d65		       65 b5		      adc	Throttle
    472  1d67		       b0 02		      bcs	noVerflo
    473  1d69		       85 b5		      sta	Throttle
    474  1d6b				   noVerflo
    475  1d6b
    476  1d6b							;----------------------------------------------------------------------------------------------
    477  1d6b
    478  1d6b							; has to be done AFTER screen display, because it disables the effect!
    479  1d6b							;SLEEP 6
    480  1d6b							;lda rnd		      ; 3     randomly reposition the Cosmic Ark missile
    481  1d6b							;sta HMM0		      ; 3     this assumes that HMOVE is called at least once/frame
    482  1d6b
    483  1d6b							; "Flash" has highest BG colour priority
    484  1d6b
    485  1d6b		       a5 c6		      lda	ColourTimer
    486  1d6d		       f0 07		      beq	noFlashBG
    487  1d6f		       c6 c6		      dec	ColourTimer
    488  1d71		       a6 c7		      ldx	ColourFlash
    489  1d73		       bd 3b f5 	      lda	FlashColour,x
    490  1d76		       85 b2	   noFlashBG  sta	BGColour
    491  1d78
    492  1d78							; Handle the player joystick reading. We do it *every frame* so that we can incorporate a two-frame
    493  1d78							; buffer.  This is designed to give a little better responsiveness to the 'quick tap' movement.
    494  1d78
    495  1d78		       a5 92		      lda	BufferedJoystick	; previous frame
    496  1d7a		       85 93		      sta	BufferedJoystick+1	; -> buffered
    497  1d7c
    498  1d7c
    499  1d7c							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    500  1d7c
    501  1d7c		       a5 4c		      lda	INPT4
    502  1d7e		       25 94		      and	BufferedButton
    503  1d80		       85 94		      sta	BufferedButton
    504  1d82
    505  1d82		       ad 80 02 	      lda	SWCHA
    506  1d85		       85 92		      sta	BufferedJoystick
    507  1d87
    508  1d87
    509  1d87				  -	      if	0
    510  1d87				  -			; "Scoring timer" reset stomp comment
    511  1d87				  -
    512  1d87				  -	      lda	scoringTimer
    513  1d87				  -	      beq	timer0now
    514  1d87				  -	      dec	scoringTimer
    515  1d87				  -	      bne	timer0now
    516  1d87				  -	      lda	scoringFlags
    517  1d87				  -	      and	#<(~DISPLAY_FLAGS)	;	 switches to time display
    518  1d87				  -	      sta	scoringFlags
    519  1d87				  -timer0now
    520  1d87					      endif
    521  1d87
    522  1d87							; TODO - fast frame-based animation handling can go here
    523  1d87
    524  1d87		       60		      rts
    525  1d88
    526  1d88
    527  1d88
    528  1d88		       40 40	   pscol      .byte.b	$40, $40
    529  1d8a		       60 60		      .byte.b	$60, $60
    530  1d8c
    531  1d8c							;------------------------------------------------------------------------------
    532  1d8c
------- FILE i2c_v2.2.inc LEVEL 3 PASS 3
      0  1d8c					      include	"i2c_v2.2.inc"
      1  1d8c							;
      2  1d8c							; i2c_v2.2.inc
      3  1d8c							;
      4  1d8c							;
      5  1d8c							; AtariVox EEPROM Driver
      6  1d8c							;
      7  1d8c							; By Alex Herbert, 2004
      8  1d8c							;
      9  1d8c							; Optimisations by Thomas Jentzsch, 2006/2008
     10  1d8c							;
     11  1d8c
     12  1d8c
     13  1d8c							; I/O Constants
     14  1d8c
     15  1d8c		       00 04	   I2C_SDA_MASK equ	$04
     16  1d8c		       00 08	   I2C_SCL_MASK equ	$08
     17  1d8c
     18  1d8c
     19  1d8c							; Signalling Macros
     20  1d8c
     21  1d8c							;  MAC     I2C_SCL_0
     22  1d8c							;    lda     #$00
     23  1d8c							;    sta     SWCHA
     24  1d8c							;  ENDM
     25  1d8c
     26  1d8c							;  MAC     I2C_SCL_1
     27  1d8c							;    lda     #I2C_SCL_MASK
     28  1d8c							;    sta     SWCHA
     29  1d8c							;  ENDM
     30  1d8c
     31  1d8c							;  MAC     I2C_SDA_IN
     32  1d8c							;    lda     #I2C_SCL_MASK
     33  1d8c							;    sta     SWACNT
     34  1d8c							;  ENDM
     35  1d8c
     36  1d8c							;  MAC     I2C_SDA_OUT
     37  1d8c							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  1d8c							;    sta     SWACNT
     39  1d8c							;  ENDM
     40  1d8c
     41  1d8c
     42  1d8c					      MAC	i2c_start
     43  1d8c							; I2C_SCL_1
     44  1d8c					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  1d8c					      sta	SWCHA	; 4
     46  1d8c							; I2C_SDA_OUT
     47  1d8c					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  1d8c					      sta	SWACNT	; 4
     49  1d8c							; total: 12 cycles
     50  1d8c					      ENDM
     51  1d8c
     52  1d8c
     53  1d8c					      MAC	i2c_txbit
     54  1d8c							; I2C_SCL_0
     55  1d8c					      lda	#%0011	; 2
     56  1d8c					      sta	SWCHA	; 4
     57  1d8c							; set bit
     58  1d8c					      adc	#%1000	; 2
     59  1d8c					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  1d8c							; I2C_SCL_1
     61  1d8c					      lda	#I2C_SCL_MASK	; 2
     62  1d8c					      sta	SWCHA	; 4
     63  1d8c							; total: 18 cycles
     64  1d8c					      ENDM
     65  1d8c
     66  1d8c
     67  1d8c					      MAC	i2c_txnack
     68  1d8c							; I2C_SCL_0
     69  1d8c					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  1d8c					      sta	SWCHA	; 4
     71  1d8c							; I2C_SDA_IN
     72  1d8c					      lsr		; 2	     I2C_SCL_MASK
     73  1d8c					      sta	SWACNT	; 4
     74  1d8c							; I2C_SCL_1
     75  1d8c					      nop		; 2	     required for timing!
     76  1d8c					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  1d8c							; total: 18 cycles
     78  1d8c					      ENDM
     79  1d8c
     80  1d8c
     81  1d8c							; Subroutine Macros
     82  1d8c
     83  1d8c					      MAC	i2c_subs
     84  1d8c
     85  1d8c				   i2c_startread
     86  1d8c							; use V to flag if previous byte needs ACK
     87  1d8c					      ldy	#%10100001	; 2	     eeprom read command
     88  1d8c					      .byte	$2c	; 2
     89  1d8c				   i2c_startwrite
     90  1d8c					      ldy	#%10100000	; 2	     eeprom write command
     91  1d8c					      I2C_START		;12	     start signal (clears V flag)
     92  1d8c					      tya		; 2 = 16
     93  1d8c				   i2c_txbyte
     94  1d8c					      eor	#$ff	; 2	     invert data byte
     95  1d8c					      sec		; 2
     96  1d8c					      rol		; 2 =	6    shift loop bit into a
     97  1d8c				   i2c_txbyteloop
     98  1d8c					      tay		; 2
     99  1d8c					      I2C_TXBIT		;18	     transmit
    100  1d8c					      tya		; 2
    101  1d8c					      asl		; 2	     shift next bit into C
    102  1d8c					      bne	i2c_txbyteloop	; 2= 26/27
    103  1d8c
    104  1d8c							; receive acknowledge bit
    105  1d8c
    106  1d8c					      beq	i2c_rxbit	;43 = 43
    107  1d8c							; i2c_txbyte: 264 cycles
    108  1d8c							;-------------------------------------------------------------------------------
    109  1d8c
    110  1d8c				   i2c_rxbyte
    111  1d8c					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  1d8c					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  1d8c
    114  1d8c				   i2c_rxskipack
    115  1d8c					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  1d8c
    117  1d8c					      lda	#1	; 2
    118  1d8c				   i2c_rxbyteloop
    119  1d8c					      tay		; 2 =	2
    120  1d8c				   i2c_rxbit		;	     receive bit in C
    121  1d8c					      I2C_TXNACK		;18 = 18
    122  1d8c
    123  1d8c					      lda	SWCHA	; 4
    124  1d8c					      lsr		; 2
    125  1d8c					      lsr		; 2
    126  1d8c					      lsr		; 2 = 10    C = SDA
    127  1d8c
    128  1d8c					      tya		; 2
    129  1d8c					      rol		; 2	     rotate into Y
    130  1d8c					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  1d8c
    132  1d8c							; received byte in A
    133  1d8c					      rts		; 6 =	6
    134  1d8c							; i2c_rxbit:  40 cycles
    135  1d8c							; i2c_rxbyte: 310/333 cycles
    136  1d8c							;-------------------------------------------------------------------------------
    137  1d8c
    138  1d8c				   i2c_stopread
    139  1d8c					      bvc	i2c_stopwrite	; 2
    140  1d8c					      ldy	#$80	; 2
    141  1d8c					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  1d8c
    143  1d8c				   i2c_stopwrite
    144  1d8c					      jsr	i2c_txack	;30
    145  1d8c
    146  1d8c							; return port to input mode
    147  1d8c					      lda	#0	; 2	     0
    148  1d8c					      sta	SWACNT	; 4
    149  1d8c					      rts		; 6 = 12
    150  1d8c							; i2c_stopread:  45/92
    151  1d8c							; i2c_stopwrite: 42
    152  1d8c							;-------------------------------------------------------------------------------
    153  1d8c
    154  1d8c				   i2c_txack
    155  1d8c							; I2C_SCL_0
    156  1d8c					      lda	#0	; 2	     $00
    157  1d8c					      sta	SWCHA	; 4
    158  1d8c							; I2C_SDA_OUT
    159  1d8c					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  1d8c					      sta	SWACNT	; 4
    161  1d8c							; I2C_SCL_1
    162  1d8c					      asl		; 2	     I2C_SCL_MASK
    163  1d8c					      sta	SWCHA	; 4
    164  1d8c
    165  1d8c					      rts		; 6
    166  1d8c							; total: 24 cycles
    167  1d8c							;-------------------------------------------------------------------------------
    168  1d8c
    169  1d8c					      ENDM
    170  1d8c
    171  1d8c
    172  1d8c
------- FILE BANK_GENERIC.asm
    534  1d8c
      0  1d8c					      i2c_subs
      1  1d8c
      2  1d8c				   i2c_startread
      3  1d8c
      4  1d8c		       a0 a1		      ldy	#%10100001
      5  1d8e		       2c		      .byte.b	$2c
      6  1d8f				   i2c_startwrite
      7  1d8f		       a0 a0		      ldy	#%10100000
      0  1d91					      I2C_START
      1  1d91
      2  1d91		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  1d93		       8d 80 02 	      sta	SWCHA
      4  1d96
      5  1d96		       4a		      lsr
      6  1d97		       8d 81 02 	      sta	SWACNT
      7  1d9a
      9  1d9a		       98		      tya
     10  1d9b				   i2c_txbyte
     11  1d9b		       49 ff		      eor	#$ff
     12  1d9d		       38		      sec
     13  1d9e		       2a		      rol
     14  1d9f				   i2c_txbyteloop
     15  1d9f		       a8		      tay
      0  1da0					      I2C_TXBIT
      1  1da0
      2  1da0		       a9 03		      lda	#%0011
      3  1da2		       8d 80 02 	      sta	SWCHA
      4  1da5
      5  1da5		       69 08		      adc	#%1000
      6  1da7		       8d 81 02 	      sta	SWACNT
      7  1daa
      8  1daa		       a9 08		      lda	#I2C_SCL_MASK
      9  1dac		       8d 80 02 	      sta	SWCHA
     10  1daf
     17  1daf		       98		      tya
     18  1db0		       0a		      asl
     19  1db1		       d0 ec		      bne	i2c_txbyteloop
     20  1db3
     21  1db3
     22  1db3
     23  1db3		       f0 0b		      beq	i2c_rxbit
     24  1db5
     25  1db5
     26  1db5
     27  1db5				   i2c_rxbyte
     28  1db5		       50 03		      bvc	i2c_rxskipack
     29  1db7		       20 e8 f5 	      jsr	i2c_txack
     30  1dba
     31  1dba				   i2c_rxskipack
     32  1dba		       2c b5 f5 	      bit	i2c_rxbyte
     33  1dbd
     34  1dbd		       a9 01		      lda	#1
     35  1dbf				   i2c_rxbyteloop
     36  1dbf		       a8		      tay
     37  1dc0				   i2c_rxbit
      0  1dc0					      I2C_TXNACK
      1  1dc0
      2  1dc0		       a9 10		      lda	#I2C_SCL_MASK*2
      3  1dc2		       8d 80 02 	      sta	SWCHA
      4  1dc5
      5  1dc5		       4a		      lsr
      6  1dc6		       8d 81 02 	      sta	SWACNT
      7  1dc9
      8  1dc9		       ea		      nop
      9  1dca		       8d 80 02 	      sta	SWCHA
     10  1dcd
     39  1dcd
     40  1dcd		       ad 80 02 	      lda	SWCHA
     41  1dd0		       4a		      lsr
     42  1dd1		       4a		      lsr
     43  1dd2		       4a		      lsr
     44  1dd3
     45  1dd3		       98		      tya
     46  1dd4		       2a		      rol
     47  1dd5		       90 e8		      bcc	i2c_rxbyteloop
     48  1dd7
     49  1dd7
     50  1dd7		       60		      rts
     51  1dd8
     52  1dd8
     53  1dd8
     54  1dd8
     55  1dd8				   i2c_stopread
     56  1dd8		       50 05		      bvc	i2c_stopwrite
     57  1dda		       a0 80		      ldy	#$80
     58  1ddc		       20 c0 f5 	      jsr	i2c_rxbit
     59  1ddf
     60  1ddf				   i2c_stopwrite
     61  1ddf		       20 e8 f5 	      jsr	i2c_txack
     62  1de2
     63  1de2
     64  1de2		       a9 00		      lda	#0
     65  1de4		       8d 81 02 	      sta	SWACNT
     66  1de7		       60		      rts
     67  1de8
     68  1de8
     69  1de8
     70  1de8
     71  1de8				   i2c_txack
     72  1de8
     73  1de8		       a9 00		      lda	#0
     74  1dea		       8d 80 02 	      sta	SWCHA
     75  1ded
     76  1ded		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  1def		       8d 81 02 	      sta	SWACNT
     78  1df2
     79  1df2		       0a		      asl
     80  1df3		       8d 80 02 	      sta	SWCHA
     81  1df6
     82  1df6		       60		      rts
     83  1df7
     84  1df7
     85  1df7
    536  1df7
    537  1df7				   HandleSaveKey SUBROUTINE
    538  1df7
    539  1df7		       2f 00	   SAVEKEY_ADR =	$2F00	;	     tentative address for Sokoban (64 bytes)
    540  1df7
    541  1df7							;------------------------------------------------------------------------------
      0  1df7					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  1df7		       00 03	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  1df7					      SUBROUTINE
      3  1df7				   ReadSaveKey
    543  1df7
    544  1df7							; assume no SaveKey found:
    545  1df7		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    546  1df9		       85 e0		      sta	highScoreSK+2	; 3
    547  1dfb
    548  1dfb							; setup SaveKey:
    549  1dfb		       a5 e1		      lda	startingLevel	; 3	     load start levelX*5 and level
    550  1dfd		       a6 b4		      ldx	level	; 3
    551  1dff		       20 38 f6 	      jsr	SetupSaveKey	;6+853
    552  1e02		       90 52		      bcc	NoSKfound	; 2/3
    553  1e04
    554  1e04							;    lda     #$34
    555  1e04							;    sta     COLUBK
    556  1e04
    557  1e04							; start read
    558  1e04		       20 df f5 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    559  1e07		       20 8c f5 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    560  1e0a
    561  1e0a							; read high score:
    562  1e0a		       a2 02		      ldx	#3-1	; 2 = 1187
    563  1e0c				   .loopRead
    564  1e0c		       20 b5 f5 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    565  1e0f		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    566  1e11		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    567  1e13		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    568  1e15				   .skipEmpty
    569  1e15		       95 de		      sta	highScoreSK,x	; 4
    570  1e17		       ca		      dex		; 2
    571  1e18		       10 f2		      bpl	.loopRead	; 2/3= 354
    572  1e1a
    573  1e1a							; stop read:
    574  1e1a		       4c d8 f5 	      jmp	i2c_stopread	;3+92=95    terminate read
    575  1e1d
    576  1e1d							;------------------------------------------------------------------------------
      0  1e1d					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  1e1d		       00 03	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  1e1d					      SUBROUTINE
      3  1e1d				   WriteSaveKey
    578  1e1d
    579  1e1d							; check if new high score:
    580  1e1d		       a6 de		      ldx	highScoreSK	; 3
    581  1e1f		       e8		      inx		; 2
    582  1e20		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    583  1e22
    584  1e22							; setup SaveKey:
    585  1e22		       a5 e1		      lda	startingLevel	; 3	     load start levelX*5 and level
    586  1e24		       a6 e2		      ldx	startLevel	; 3
    587  1e26		       20 38 f6 	      jsr	SetupSaveKey	; 6+853
    588  1e29		       90 2b		      bcc	NoSKfound	; 2/3
    589  1e2b
    590  1e2b							;    lda     #$64
    591  1e2b							;    sta     COLUBK
    592  1e2b
    593  1e2b							; write high score:
    594  1e2b		       a2 02		      ldx	#3-1	; 2 = 841
    595  1e2d				   .loopWrite
    596  1e2d		       b5 de		      lda	highScoreSK,x	; 4
    597  1e2f		       20 9b f5 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    598  1e32		       ca		      dex		; 2
    599  1e33		       10 f8		      bpl	.loopWrite	; 2/3= 837
    600  1e35
    601  1e35							; stop write:
    602  1e35		       4c df f5 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    603  1e38
    604  1e38
    605  1e38							;------------------------------------------------------------------------------
    606  1e38
      0  1e38					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  1e38		       00 03	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  1e38					      SUBROUTINE
      3  1e38				   SetupSaveKey
    608  1e38
    609  1e38							; calculate slot;
    610  1e38							; a = levelX
    611  1e38							; x = level (0..4)
    612  1e38		       85 e3		      sta	offsetSK	; 3
    613  1e3a		       8a		      txa		; 2
    614  1e3b		       18		      clc		; 2
    615  1e3c		       65 e3		      adc	offsetSK	; 3
    616  1e3e		       85 e3		      sta	offsetSK	; 3
    617  1e40		       0a		      asl		; 2	     multiply by 3
    618  1e41		       65 e3		      adc	offsetSK	; 3
    619  1e43		       69 00		      adc	#<SAVEKEY_ADR	; 2
    620  1e45		       aa		      tax		; 2 = 22
    621  1e46							; detect SaveKey:
    622  1e46		       20 8f f5 	      jsr	i2c_startwrite	;6+280
    623  1e49		       d0 0a		      bne	.exitSK	; 2/3
    624  1e4b
    625  1e4b							; setup address:
    626  1e4b		       b8		      clv		; 2
    627  1e4c		       a9 2f		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    628  1e4e		       20 9b f5 	      jsr	i2c_txbyte	;6+264
    629  1e51		       8a		      txa		; 2	     x = lower byte offset
    630  1e52		       4c 9b f5 	      jmp	i2c_txbyte	;3+264      returns C==1
    631  1e55
    632  1e55				   .exitSK
    633  1e55		       18		      clc
    634  1e56				   NoSKfound
    635  1e56		       60		      rts
    636  1e56					      ENDIF
    637  1e57
    638  1e57
      0  1e57					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  1e57		       06 57	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $657 , FREE= $1a9
      2  1e57					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1e57				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1e57				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1e57				  -	      ERR
      6  1e57					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS1.asm LEVEL 2 PASS 3
      0  1e57					      include	"BANK_LEVELS1.asm"
      1  1e57							;    Sokoboo - a Sokoban implementation
      2  1e57							;    using a generic tile-based display engine for the Atari 2600
      3  1e57							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1e57							;
      5  1e57							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1e57							;
      7  1e57							;    Code related to the generic tile-based display engine was developed by
      8  1e57							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1e57							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1e57							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1e57							;
     12  1e57							;    Code related to music and sound effects uses the TIATracker music player
     13  1e57							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1e57							;    directory for Apache licensing details.
     15  1e57							;
     16  1e57							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1e57							;    See the copyright notices in the License directory for a list of level
     18  1e57							;    contributors.
     19  1e57							;
     20  1e57							;    Except where otherwise indicated, this software is released under the
     21  1e57							;    following licensing arrangement...
     22  1e57							;
     23  1e57							;    This program is free software: you can redistribute it and/or modify
     24  1e57							;    it under the terms of the GNU General Public License as published by
     25  1e57							;    the Free Software Foundation, either version 3 of the License, or
     26  1e57							;    (at your option) any later version.
     27  1e57							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1e57
     29  1e57							;    This program is distributed in the hope that it will be useful,
     30  1e57							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1e57							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1e57							;    GNU General Public License for more details.
     33  1e57
      0  1e57					      NEWBANK	LEVELS1
      1  27b5 ????				      SEG	LEVELS1
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   LEVELS1    SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	LEVELS1
     35  2000
     36  2000
     37  2000							;  DEFL _000_SELECT, "12#|#@3-5$.#|10-|10-|12#"
     38  2000
     39  2000							; "SOKWHOLE" collection...
     40  2000
     41  2000
      0  2000					      DEFL	_001_L, "3#|#@#|#$#|#.#|3#"
      0  2000					      START_LEVEL	_001_L
      1  2000				   LEVEL_START SET	*
      2  2000		       00 04	   BANK_LEVEL__001_L =	_CURRENT_BANK
      3  2000				   LEVEL__001_L SUBROUTINE
      4  2000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2000
      2  2000		       33 23 7c 23*	      .byte.b	"3#|#@#|#$#|#.#|3#",0
      0  2012					      END_LEVEL	_001_L
      1  2012		       00 12	   LEVEL_SIZE__001_L =	* - LEVEL_START
      2  2012					      IF	LEVEL_SIZE__001_L > MAX_LEVEL_SIZE
      3  2012				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_L
      4  2012					      ENDIF
      0  2012					      DEFL	_001_R, "5#|#.$@#|5#"
      0  2012					      START_LEVEL	_001_R
      1  2012				   LEVEL_START SET	*
      2  2012		       00 04	   BANK_LEVEL__001_R =	_CURRENT_BANK
      3  2012				   LEVEL__001_R SUBROUTINE
      4  2012				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2012
      2  2012		       35 23 7c 23*	      .byte.b	"5#|#.$@#|5#",0
      0  201e					      END_LEVEL	_001_R
      1  201e		       00 0c	   LEVEL_SIZE__001_R =	* - LEVEL_START
      2  201e				  -	      IF	LEVEL_SIZE__001_R > MAX_LEVEL_SIZE
      3  201e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_R
      4  201e					      ENDIF
      0  201e					      DEFL	_002_L, "3#2-|#.3#|#*$-#|#2-@#|5#"
      0  201e					      START_LEVEL	_002_L
      1  201e				   LEVEL_START SET	*
      2  201e		       00 04	   BANK_LEVEL__002_L =	_CURRENT_BANK
      3  201e				   LEVEL__002_L SUBROUTINE
      4  201e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  201e
      2  201e		       33 23 32 2d*	      .byte.b	"3#2-|#.3#|#*$-#|#2-@#|5#",0
      0  2037					      END_LEVEL	_002_L
      1  2037		       00 19	   LEVEL_SIZE__002_L =	* - LEVEL_START
      2  2037					      IF	LEVEL_SIZE__002_L > MAX_LEVEL_SIZE
      3  2037				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_L
      4  2037					      ENDIF
      0  2037					      DEFL	_002_R, "2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#"
      0  2037					      START_LEVEL	_002_R
      1  2037				   LEVEL_START SET	*
      2  2037		       00 04	   BANK_LEVEL__002_R =	_CURRENT_BANK
      3  2037				   LEVEL__002_R SUBROUTINE
      4  2037				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2037
      2  2037		       32 2d 35 23*	      .byte.b	"2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#",0
      0  205f					      END_LEVEL	_002_R
      1  205f		       00 28	   LEVEL_SIZE__002_R =	* - LEVEL_START
      2  205f					      IF	LEVEL_SIZE__002_R > MAX_LEVEL_SIZE
      3  205f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_R
      4  205f					      ENDIF
      0  205f					      DEFL	_003_L, "4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-"
      0  205f					      START_LEVEL	_003_L
      1  205f				   LEVEL_START SET	*
      2  205f		       00 04	   BANK_LEVEL__003_L =	_CURRENT_BANK
      3  205f				   LEVEL__003_L SUBROUTINE
      4  205f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  205f
      2  205f		       34 2d 35 23*	      .byte.b	"4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-",0
      0  208b					      END_LEVEL	_003_L
      1  208b		       00 2c	   LEVEL_SIZE__003_L =	* - LEVEL_START
      2  208b					      IF	LEVEL_SIZE__003_L > MAX_LEVEL_SIZE
      3  208b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_L
      4  208b					      ENDIF
      0  208b					      DEFL	_003_R, "9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-"
      0  208b					      START_LEVEL	_003_R
      1  208b				   LEVEL_START SET	*
      2  208b		       00 04	   BANK_LEVEL__003_R =	_CURRENT_BANK
      3  208b				   LEVEL__003_R SUBROUTINE
      4  208b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  208b
      2  208b		       39 23 7c 23*	      .byte.b	"9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-",0
      0  20b5					      END_LEVEL	_003_R
      1  20b5		       00 2a	   LEVEL_SIZE__003_R =	* - LEVEL_START
      2  20b5				  -	      IF	LEVEL_SIZE__003_R > MAX_LEVEL_SIZE
      3  20b5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_R
      4  20b5					      ENDIF
      0  20b5					      DEFL	_004_L, "5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-"
      0  20b5					      START_LEVEL	_004_L
      1  20b5				   LEVEL_START SET	*
      2  20b5		       00 04	   BANK_LEVEL__004_L =	_CURRENT_BANK
      3  20b5				   LEVEL__004_L SUBROUTINE
      4  20b5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20b5
      2  20b5		       35 23 2d 7c*	      .byte.b	"5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-",0
      0  20d8					      END_LEVEL	_004_L
      1  20d8		       00 23	   LEVEL_SIZE__004_L =	* - LEVEL_START
      2  20d8				  -	      IF	LEVEL_SIZE__004_L > MAX_LEVEL_SIZE
      3  20d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_L
      4  20d8					      ENDIF
      0  20d8					      DEFL	_004_R, "-6#|-#4-#|2#-$*$#|#@$3.#|7#"
      0  20d8					      START_LEVEL	_004_R
      1  20d8				   LEVEL_START SET	*
      2  20d8		       00 04	   BANK_LEVEL__004_R =	_CURRENT_BANK
      3  20d8				   LEVEL__004_R SUBROUTINE
      4  20d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20d8
      2  20d8		       2d 36 23 7c*	      .byte.b	"-6#|-#4-#|2#-$*$#|#@$3.#|7#",0
      0  20f4					      END_LEVEL	_004_R
      1  20f4		       00 1c	   LEVEL_SIZE__004_R =	* - LEVEL_START
      2  20f4				  -	      IF	LEVEL_SIZE__004_R > MAX_LEVEL_SIZE
      3  20f4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_R
      4  20f4					      ENDIF
      0  20f4					      DEFL	_005_L, "3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-"
      0  20f4					      START_LEVEL	_005_L
      1  20f4				   LEVEL_START SET	*
      2  20f4		       00 04	   BANK_LEVEL__005_L =	_CURRENT_BANK
      3  20f4				   LEVEL__005_L SUBROUTINE
      4  20f4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20f4
      2  20f4		       33 2d 35 23*	      .byte.b	"3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-",0
      0  2126					      END_LEVEL	_005_L
      1  2126		       00 32	   LEVEL_SIZE__005_L =	* - LEVEL_START
      2  2126					      IF	LEVEL_SIZE__005_L > MAX_LEVEL_SIZE
      3  2126				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_L
      4  2126					      ENDIF
      0  2126					      DEFL	_005_R, "6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-"
      0  2126					      START_LEVEL	_005_R
      1  2126				   LEVEL_START SET	*
      2  2126		       00 04	   BANK_LEVEL__005_R =	_CURRENT_BANK
      3  2126				   LEVEL__005_R SUBROUTINE
      4  2126				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2126
      2  2126		       36 23 32 2d*	      .byte.b	"6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-",0
      0  2165					      END_LEVEL	_005_R
      1  2165		       00 3f	   LEVEL_SIZE__005_R =	* - LEVEL_START
      2  2165					      IF	LEVEL_SIZE__005_R > MAX_LEVEL_SIZE
      3  2165				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_R
      4  2165					      ENDIF
      0  2165					      DEFL	_006_L, "5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-"
      0  2165					      START_LEVEL	_006_L
      1  2165				   LEVEL_START SET	*
      2  2165		       00 04	   BANK_LEVEL__006_L =	_CURRENT_BANK
      3  2165				   LEVEL__006_L SUBROUTINE
      4  2165				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2165
      2  2165		       35 23 33 2d*	      .byte.b	"5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-",0
      0  21a0					      END_LEVEL	_006_L
      1  21a0		       00 3b	   LEVEL_SIZE__006_L =	* - LEVEL_START
      2  21a0				  -	      IF	LEVEL_SIZE__006_L > MAX_LEVEL_SIZE
      3  21a0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_L
      4  21a0					      ENDIF
      0  21a0					      DEFL	_006_R, "3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-"
      0  21a0					      START_LEVEL	_006_R
      1  21a0				   LEVEL_START SET	*
      2  21a0		       00 04	   BANK_LEVEL__006_R =	_CURRENT_BANK
      3  21a0				   LEVEL__006_R SUBROUTINE
      4  21a0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21a0
      2  21a0		       33 23 34 2d*	      .byte.b	"3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-",0
      0  21de					      END_LEVEL	_006_R
      1  21de		       00 3e	   LEVEL_SIZE__006_R =	* - LEVEL_START
      2  21de				  -	      IF	LEVEL_SIZE__006_R > MAX_LEVEL_SIZE
      3  21de				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_R
      4  21de					      ENDIF
      0  21de					      DEFL	_007_L, "6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#"
      0  21de					      START_LEVEL	_007_L
      1  21de				   LEVEL_START SET	*
      2  21de		       00 04	   BANK_LEVEL__007_L =	_CURRENT_BANK
      3  21de				   LEVEL__007_L SUBROUTINE
      4  21de				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21de
      2  21de		       36 23 2d 7c*	      .byte.b	"6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#",0
      0  220b					      END_LEVEL	_007_L
      1  220b		       00 2d	   LEVEL_SIZE__007_L =	* - LEVEL_START
      2  220b				  -	      IF	LEVEL_SIZE__007_L > MAX_LEVEL_SIZE
      3  220b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_L
      4  220b					      ENDIF
      0  220b					      DEFL	_007_R, "4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#"
      0  220b					      START_LEVEL	_007_R
      1  220b				   LEVEL_START SET	*
      2  220b		       00 04	   BANK_LEVEL__007_R =	_CURRENT_BANK
      3  220b				   LEVEL__007_R SUBROUTINE
      4  220b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  220b
      2  220b		       34 23 34 2d*	      .byte.b	"4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#",0
      0  223e					      END_LEVEL	_007_R
      1  223e		       00 33	   LEVEL_SIZE__007_R =	* - LEVEL_START
      2  223e				  -	      IF	LEVEL_SIZE__007_R > MAX_LEVEL_SIZE
      3  223e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_R
      4  223e					      ENDIF
      0  223e					      DEFL	_008_L, "2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-"
      0  223e					      START_LEVEL	_008_L
      1  223e				   LEVEL_START SET	*
      2  223e		       00 04	   BANK_LEVEL__008_L =	_CURRENT_BANK
      3  223e				   LEVEL__008_L SUBROUTINE
      4  223e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  223e
      2  223e		       32 2d 35 23*	      .byte.b	"2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-",0
      0  2274					      END_LEVEL	_008_L
      1  2274		       00 36	   LEVEL_SIZE__008_L =	* - LEVEL_START
      2  2274				  -	      IF	LEVEL_SIZE__008_L > MAX_LEVEL_SIZE
      3  2274				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_L
      4  2274					      ENDIF
      0  2274					      DEFL	_008_R, "-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#"
      0  2274					      START_LEVEL	_008_R
      1  2274				   LEVEL_START SET	*
      2  2274		       00 04	   BANK_LEVEL__008_R =	_CURRENT_BANK
      3  2274				   LEVEL__008_R SUBROUTINE
      4  2274				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2274
      2  2274		       2d 35 23 33*	      .byte.b	"-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#",0
      0  22a5					      END_LEVEL	_008_R
      1  22a5		       00 31	   LEVEL_SIZE__008_R =	* - LEVEL_START
      2  22a5				  -	      IF	LEVEL_SIZE__008_R > MAX_LEVEL_SIZE
      3  22a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_R
      4  22a5					      ENDIF
      0  22a5					      DEFL	_009_L, "-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#"
      0  22a5					      START_LEVEL	_009_L
      1  22a5				   LEVEL_START SET	*
      2  22a5		       00 04	   BANK_LEVEL__009_L =	_CURRENT_BANK
      3  22a5				   LEVEL__009_L SUBROUTINE
      4  22a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22a5
      2  22a5		       2d 35 23 2d*	      .byte.b	"-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#",0
      0  22d7					      END_LEVEL	_009_L
      1  22d7		       00 32	   LEVEL_SIZE__009_L =	* - LEVEL_START
      2  22d7				  -	      IF	LEVEL_SIZE__009_L > MAX_LEVEL_SIZE
      3  22d7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_L
      4  22d7					      ENDIF
      0  22d7					      DEFL	_009_R, "-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#"
      0  22d7					      START_LEVEL	_009_R
      1  22d7				   LEVEL_START SET	*
      2  22d7		       00 04	   BANK_LEVEL__009_R =	_CURRENT_BANK
      3  22d7				   LEVEL__009_R SUBROUTINE
      4  22d7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22d7
      2  22d7		       2d 33 23 33*	      .byte.b	"-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#",0
      0  2307					      END_LEVEL	_009_R
      1  2307		       00 30	   LEVEL_SIZE__009_R =	* - LEVEL_START
      2  2307				  -	      IF	LEVEL_SIZE__009_R > MAX_LEVEL_SIZE
      3  2307				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_R
      4  2307					      ENDIF
      0  2307					      DEFL	_010_L, "2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-"
      0  2307					      START_LEVEL	_010_L
      1  2307				   LEVEL_START SET	*
      2  2307		       00 04	   BANK_LEVEL__010_L =	_CURRENT_BANK
      3  2307				   LEVEL__010_L SUBROUTINE
      4  2307				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2307
      2  2307		       32 2d 33 23*	      .byte.b	"2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-",0
      0  2341					      END_LEVEL	_010_L
      1  2341		       00 3a	   LEVEL_SIZE__010_L =	* - LEVEL_START
      2  2341				  -	      IF	LEVEL_SIZE__010_L > MAX_LEVEL_SIZE
      3  2341				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_L
      4  2341					      ENDIF
      0  2341					      DEFL	_010_R, "4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-"
      0  2341					      START_LEVEL	_010_R
      1  2341				   LEVEL_START SET	*
      2  2341		       00 04	   BANK_LEVEL__010_R =	_CURRENT_BANK
      3  2341				   LEVEL__010_R SUBROUTINE
      4  2341				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2341
      2  2341		       34 23 32 2d*	      .byte.b	"4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-",0
      0  2374					      END_LEVEL	_010_R
      1  2374		       00 33	   LEVEL_SIZE__010_R =	* - LEVEL_START
      2  2374				  -	      IF	LEVEL_SIZE__010_R > MAX_LEVEL_SIZE
      3  2374				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_R
      4  2374					      ENDIF
      0  2374					      DEFL	_011_L, "-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-"
      0  2374					      START_LEVEL	_011_L
      1  2374				   LEVEL_START SET	*
      2  2374		       00 04	   BANK_LEVEL__011_L =	_CURRENT_BANK
      3  2374				   LEVEL__011_L SUBROUTINE
      4  2374				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2374
      2  2374		       2d 34 23 32*	      .byte.b	"-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-",0
      0  23a7					      END_LEVEL	_011_L
      1  23a7		       00 33	   LEVEL_SIZE__011_L =	* - LEVEL_START
      2  23a7				  -	      IF	LEVEL_SIZE__011_L > MAX_LEVEL_SIZE
      3  23a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_L
      4  23a7					      ENDIF
      0  23a7					      DEFL	_011_R, "2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#"
      0  23a7					      START_LEVEL	_011_R
      1  23a7				   LEVEL_START SET	*
      2  23a7		       00 04	   BANK_LEVEL__011_R =	_CURRENT_BANK
      3  23a7				   LEVEL__011_R SUBROUTINE
      4  23a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23a7
      2  23a7		       32 2d 33 23*	      .byte.b	"2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#",0
      0  23e1					      END_LEVEL	_011_R
      1  23e1		       00 3a	   LEVEL_SIZE__011_R =	* - LEVEL_START
      2  23e1				  -	      IF	LEVEL_SIZE__011_R > MAX_LEVEL_SIZE
      3  23e1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_R
      4  23e1					      ENDIF
      0  23e1					      DEFL	_012_L, "7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#"
      0  23e1					      START_LEVEL	_012_L
      1  23e1				   LEVEL_START SET	*
      2  23e1		       00 04	   BANK_LEVEL__012_L =	_CURRENT_BANK
      3  23e1				   LEVEL__012_L SUBROUTINE
      4  23e1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23e1
      2  23e1		       37 23 33 2d*	      .byte.b	"7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#",0
      0  2411					      END_LEVEL	_012_L
      1  2411		       00 30	   LEVEL_SIZE__012_L =	* - LEVEL_START
      2  2411				  -	      IF	LEVEL_SIZE__012_L > MAX_LEVEL_SIZE
      3  2411				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_L
      4  2411					      ENDIF
      0  2411					      DEFL	_012_R, "-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-"
      0  2411					      START_LEVEL	_012_R
      1  2411				   LEVEL_START SET	*
      2  2411		       00 04	   BANK_LEVEL__012_R =	_CURRENT_BANK
      3  2411				   LEVEL__012_R SUBROUTINE
      4  2411				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2411
      2  2411		       2d 36 23 32*	      .byte.b	"-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-",0
      0  244d					      END_LEVEL	_012_R
      1  244d		       00 3c	   LEVEL_SIZE__012_R =	* - LEVEL_START
      2  244d				  -	      IF	LEVEL_SIZE__012_R > MAX_LEVEL_SIZE
      3  244d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_R
      4  244d					      ENDIF
      0  244d					      DEFL	_013_L, "2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-"
      0  244d					      START_LEVEL	_013_L
      1  244d				   LEVEL_START SET	*
      2  244d		       00 04	   BANK_LEVEL__013_L =	_CURRENT_BANK
      3  244d				   LEVEL__013_L SUBROUTINE
      4  244d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  244d
      2  244d		       32 2d 35 23*	      .byte.b	"2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-",0
      0  248c					      END_LEVEL	_013_L
      1  248c		       00 3f	   LEVEL_SIZE__013_L =	* - LEVEL_START
      2  248c				  -	      IF	LEVEL_SIZE__013_L > MAX_LEVEL_SIZE
      3  248c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_L
      4  248c					      ENDIF
      0  248c					      DEFL	_013_R, "-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-"
      0  248c					      START_LEVEL	_013_R
      1  248c				   LEVEL_START SET	*
      2  248c		       00 04	   BANK_LEVEL__013_R =	_CURRENT_BANK
      3  248c				   LEVEL__013_R SUBROUTINE
      4  248c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  248c
      2  248c		       2d 35 23 32*	      .byte.b	"-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-",0
      0  24bf					      END_LEVEL	_013_R
      1  24bf		       00 33	   LEVEL_SIZE__013_R =	* - LEVEL_START
      2  24bf				  -	      IF	LEVEL_SIZE__013_R > MAX_LEVEL_SIZE
      3  24bf				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_R
      4  24bf					      ENDIF
      0  24bf					      DEFL	_014_L, "6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#"
      0  24bf					      START_LEVEL	_014_L
      1  24bf				   LEVEL_START SET	*
      2  24bf		       00 04	   BANK_LEVEL__014_L =	_CURRENT_BANK
      3  24bf				   LEVEL__014_L SUBROUTINE
      4  24bf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24bf
      2  24bf		       36 23 34 2d*	      .byte.b	"6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#",0
      0  2502					      END_LEVEL	_014_L
      1  2502		       00 43	   LEVEL_SIZE__014_L =	* - LEVEL_START
      2  2502					      IF	LEVEL_SIZE__014_L > MAX_LEVEL_SIZE
      3  2502				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_L
      4  2502					      ENDIF
      0  2502					      DEFL	_014_R, "6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-"
      0  2502					      START_LEVEL	_014_R
      1  2502				   LEVEL_START SET	*
      2  2502		       00 04	   BANK_LEVEL__014_R =	_CURRENT_BANK
      3  2502				   LEVEL__014_R SUBROUTINE
      4  2502				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2502
      2  2502		       36 23 33 2d*	      .byte.b	"6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-",0
      0  2545					      END_LEVEL	_014_R
      1  2545		       00 43	   LEVEL_SIZE__014_R =	* - LEVEL_START
      2  2545				  -	      IF	LEVEL_SIZE__014_R > MAX_LEVEL_SIZE
      3  2545				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_R
      4  2545					      ENDIF
      0  2545					      DEFL	_015_L, "2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#"
      0  2545					      START_LEVEL	_015_L
      1  2545				   LEVEL_START SET	*
      2  2545		       00 04	   BANK_LEVEL__015_L =	_CURRENT_BANK
      3  2545				   LEVEL__015_L SUBROUTINE
      4  2545				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2545
      2  2545		       32 2d 35 23*	      .byte.b	"2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#",0
      0  257a					      END_LEVEL	_015_L
      1  257a		       00 35	   LEVEL_SIZE__015_L =	* - LEVEL_START
      2  257a				  -	      IF	LEVEL_SIZE__015_L > MAX_LEVEL_SIZE
      3  257a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_L
      4  257a					      ENDIF
      0  257a					      DEFL	_015_R, "3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-"
      0  257a					      START_LEVEL	_015_R
      1  257a				   LEVEL_START SET	*
      2  257a		       00 04	   BANK_LEVEL__015_R =	_CURRENT_BANK
      3  257a				   LEVEL__015_R SUBROUTINE
      4  257a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  257a
      2  257a		       33 2d 35 23*	      .byte.b	"3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-",0
      0  25bf					      END_LEVEL	_015_R
      1  25bf		       00 45	   LEVEL_SIZE__015_R =	* - LEVEL_START
      2  25bf					      IF	LEVEL_SIZE__015_R > MAX_LEVEL_SIZE
      3  25bf				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_R
      4  25bf					      ENDIF
      0  25bf					      DEFL	_016_L, "4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-"
      0  25bf					      START_LEVEL	_016_L
      1  25bf				   LEVEL_START SET	*
      2  25bf		       00 04	   BANK_LEVEL__016_L =	_CURRENT_BANK
      3  25bf				   LEVEL__016_L SUBROUTINE
      4  25bf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25bf
      2  25bf		       34 2d 33 23*	      .byte.b	"4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-",0
      0  25f6					      END_LEVEL	_016_L
      1  25f6		       00 37	   LEVEL_SIZE__016_L =	* - LEVEL_START
      2  25f6				  -	      IF	LEVEL_SIZE__016_L > MAX_LEVEL_SIZE
      3  25f6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_L
      4  25f6					      ENDIF
      0  25f6					      DEFL	_016_R, "5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-"
      0  25f6					      START_LEVEL	_016_R
      1  25f6				   LEVEL_START SET	*
      2  25f6		       00 04	   BANK_LEVEL__016_R =	_CURRENT_BANK
      3  25f6				   LEVEL__016_R SUBROUTINE
      4  25f6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25f6
      2  25f6		       35 23 2d 7c*	      .byte.b	"5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-",0
      0  2629					      END_LEVEL	_016_R
      1  2629		       00 33	   LEVEL_SIZE__016_R =	* - LEVEL_START
      2  2629				  -	      IF	LEVEL_SIZE__016_R > MAX_LEVEL_SIZE
      3  2629				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_R
      4  2629					      ENDIF
      0  2629					      DEFL	_017_L, "5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-"
      0  2629					      START_LEVEL	_017_L
      1  2629				   LEVEL_START SET	*
      2  2629		       00 04	   BANK_LEVEL__017_L =	_CURRENT_BANK
      3  2629				   LEVEL__017_L SUBROUTINE
      4  2629				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2629
      2  2629		       35 23 34 2d*	      .byte.b	"5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-",0
      0  2673					      END_LEVEL	_017_L
      1  2673		       00 4a	   LEVEL_SIZE__017_L =	* - LEVEL_START
      2  2673					      IF	LEVEL_SIZE__017_L > MAX_LEVEL_SIZE
      3  2673				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_L
      4  2673					      ENDIF
      0  2673					      DEFL	_017_R, "3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-"
      0  2673					      START_LEVEL	_017_R
      1  2673				   LEVEL_START SET	*
      2  2673		       00 04	   BANK_LEVEL__017_R =	_CURRENT_BANK
      3  2673				   LEVEL__017_R SUBROUTINE
      4  2673				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2673
      2  2673		       33 2d 34 23*	      .byte.b	"3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-",0
      0  26b6					      END_LEVEL	_017_R
      1  26b6		       00 43	   LEVEL_SIZE__017_R =	* - LEVEL_START
      2  26b6				  -	      IF	LEVEL_SIZE__017_R > MAX_LEVEL_SIZE
      3  26b6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_R
      4  26b6					      ENDIF
      0  26b6					      DEFL	_018_L, "6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#"
      0  26b6					      START_LEVEL	_018_L
      1  26b6				   LEVEL_START SET	*
      2  26b6		       00 04	   BANK_LEVEL__018_L =	_CURRENT_BANK
      3  26b6				   LEVEL__018_L SUBROUTINE
      4  26b6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26b6
      2  26b6		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#",0
      0  26ea					      END_LEVEL	_018_L
      1  26ea		       00 34	   LEVEL_SIZE__018_L =	* - LEVEL_START
      2  26ea				  -	      IF	LEVEL_SIZE__018_L > MAX_LEVEL_SIZE
      3  26ea				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_L
      4  26ea					      ENDIF
      0  26ea					      DEFL	_018_R, "-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#"
      0  26ea					      START_LEVEL	_018_R
      1  26ea				   LEVEL_START SET	*
      2  26ea		       00 04	   BANK_LEVEL__018_R =	_CURRENT_BANK
      3  26ea				   LEVEL__018_R SUBROUTINE
      4  26ea				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26ea
      2  26ea		       2d 34 23 33*	      .byte.b	"-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#",0
      0  2726					      END_LEVEL	_018_R
      1  2726		       00 3c	   LEVEL_SIZE__018_R =	* - LEVEL_START
      2  2726				  -	      IF	LEVEL_SIZE__018_R > MAX_LEVEL_SIZE
      3  2726				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_R
      4  2726					      ENDIF
      0  2726					      DEFL	_019_L, "4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#"
      0  2726					      START_LEVEL	_019_L
      1  2726				   LEVEL_START SET	*
      2  2726		       00 04	   BANK_LEVEL__019_L =	_CURRENT_BANK
      3  2726				   LEVEL__019_L SUBROUTINE
      4  2726				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2726
      2  2726		       34 2d 35 23*	      .byte.b	"4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#",0
      0  2761					      END_LEVEL	_019_L
      1  2761		       00 3b	   LEVEL_SIZE__019_L =	* - LEVEL_START
      2  2761				  -	      IF	LEVEL_SIZE__019_L > MAX_LEVEL_SIZE
      3  2761				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_L
      4  2761					      ENDIF
      0  2761					      DEFL	_019_R, "2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#"
      0  2761					      START_LEVEL	_019_R
      1  2761				   LEVEL_START SET	*
      2  2761		       00 04	   BANK_LEVEL__019_R =	_CURRENT_BANK
      3  2761				   LEVEL__019_R SUBROUTINE
      4  2761				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2761
      2  2761		       32 2d 37 23*	      .byte.b	"2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#",0
      0  27b1					      END_LEVEL	_019_R
      1  27b1		       00 50	   LEVEL_SIZE__019_R =	* - LEVEL_START
      2  27b1					      IF	LEVEL_SIZE__019_R > MAX_LEVEL_SIZE
      3  27b1				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_R
      4  27b1					      ENDIF
     80  27b1
     81  27b1							;-----------------------------------------------------------
     82  27b1							; Stella 3E autodetect signature, can live anywhere
     83  27b1		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
     84  27b5							;-----------------------------------------------------------
     85  27b5
      0  27b5					      CHECK_BANK_SIZE	"LEVELS1"
      1  27b5		       07 b5	   .TEMP      =	* - BANK_START
 LEVELS1 (2K) SIZE =  $7b5 , FREE= $4b
      2  27b5					      ECHO	"LEVELS1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27b5				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  27b5				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27b5				  -	      ERR
      6  27b5					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS2.asm LEVEL 2 PASS 3
      0  27b5					      include	"BANK_LEVELS2.asm"
      1  27b5							;    Sokoboo - a Sokoban implementation
      2  27b5							;    using a generic tile-based display engine for the Atari 2600
      3  27b5							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  27b5							;
      5  27b5							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  27b5							;
      7  27b5							;    Code related to the generic tile-based display engine was developed by
      8  27b5							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  27b5							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  27b5							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  27b5							;
     12  27b5							;    Code related to music and sound effects uses the TIATracker music player
     13  27b5							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  27b5							;    directory for Apache licensing details.
     15  27b5							;
     16  27b5							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  27b5							;    See the copyright notices in the License directory for a list of level
     18  27b5							;    contributors.
     19  27b5							;
     20  27b5							;    Except where otherwise indicated, this software is released under the
     21  27b5							;    following licensing arrangement...
     22  27b5							;
     23  27b5							;    This program is free software: you can redistribute it and/or modify
     24  27b5							;    it under the terms of the GNU General Public License as published by
     25  27b5							;    the Free Software Foundation, either version 3 of the License, or
     26  27b5							;    (at your option) any later version.
     27  27b5							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  27b5
     29  27b5							;    This program is distributed in the hope that it will be useful,
     30  27b5							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  27b5							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  27b5							;    GNU General Public License for more details.
     33  27b5
      0  27b5					      NEWBANK	LEVELS2
      1  2fbe ????				      SEG	LEVELS2
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   LEVELS2    SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	LEVELS2
     35  2800
      0  2800					      DEFL	_020_L, "-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-"
      0  2800					      START_LEVEL	_020_L
      1  2800				   LEVEL_START SET	*
      2  2800		       00 05	   BANK_LEVEL__020_L =	_CURRENT_BANK
      3  2800				   LEVEL__020_L SUBROUTINE
      4  2800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2800
      2  2800		       2d 36 23 2d*	      .byte.b	"-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-",0
      0  283f					      END_LEVEL	_020_L
      1  283f		       00 3f	   LEVEL_SIZE__020_L =	* - LEVEL_START
      2  283f				  -	      IF	LEVEL_SIZE__020_L > MAX_LEVEL_SIZE
      3  283f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_L
      4  283f					      ENDIF
      0  283f					      DEFL	_020_R, "5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-"
      0  283f					      START_LEVEL	_020_R
      1  283f				   LEVEL_START SET	*
      2  283f		       00 05	   BANK_LEVEL__020_R =	_CURRENT_BANK
      3  283f				   LEVEL__020_R SUBROUTINE
      4  283f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  283f
      2  283f		       35 2d 34 23*	      .byte.b	"5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-",0
      0  287f					      END_LEVEL	_020_R
      1  287f		       00 40	   LEVEL_SIZE__020_R =	* - LEVEL_START
      2  287f				  -	      IF	LEVEL_SIZE__020_R > MAX_LEVEL_SIZE
      3  287f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_R
      4  287f					      ENDIF
      0  287f					      DEFL	_021_L, "4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-"
      0  287f					      START_LEVEL	_021_L
      1  287f				   LEVEL_START SET	*
      2  287f		       00 05	   BANK_LEVEL__021_L =	_CURRENT_BANK
      3  287f				   LEVEL__021_L SUBROUTINE
      4  287f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  287f
      2  287f		       34 2d 34 23*	      .byte.b	"4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-",0
      0  28d5					      END_LEVEL	_021_L
      1  28d5		       00 56	   LEVEL_SIZE__021_L =	* - LEVEL_START
      2  28d5					      IF	LEVEL_SIZE__021_L > MAX_LEVEL_SIZE
      3  28d5				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_L
      4  28d5					      ENDIF
      0  28d5					      DEFL	_021_R, "-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-"
      0  28d5					      START_LEVEL	_021_R
      1  28d5				   LEVEL_START SET	*
      2  28d5		       00 05	   BANK_LEVEL__021_R =	_CURRENT_BANK
      3  28d5				   LEVEL__021_R SUBROUTINE
      4  28d5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  28d5
      2  28d5		       2d 34 23 33*	      .byte.b	"-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-",0
      0  2909					      END_LEVEL	_021_R
      1  2909		       00 34	   LEVEL_SIZE__021_R =	* - LEVEL_START
      2  2909				  -	      IF	LEVEL_SIZE__021_R > MAX_LEVEL_SIZE
      3  2909				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_R
      4  2909					      ENDIF
      0  2909					      DEFL	_022_L, "3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-"
      0  2909					      START_LEVEL	_022_L
      1  2909				   LEVEL_START SET	*
      2  2909		       00 05	   BANK_LEVEL__022_L =	_CURRENT_BANK
      3  2909				   LEVEL__022_L SUBROUTINE
      4  2909				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2909
      2  2909		       33 2d 33 23*	      .byte.b	"3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-",0
      0  294f					      END_LEVEL	_022_L
      1  294f		       00 46	   LEVEL_SIZE__022_L =	* - LEVEL_START
      2  294f				  -	      IF	LEVEL_SIZE__022_L > MAX_LEVEL_SIZE
      3  294f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_L
      4  294f					      ENDIF
      0  294f					      DEFL	_022_R, "-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-"
      0  294f					      START_LEVEL	_022_R
      1  294f				   LEVEL_START SET	*
      2  294f		       00 05	   BANK_LEVEL__022_R =	_CURRENT_BANK
      3  294f				   LEVEL__022_R SUBROUTINE
      4  294f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  294f
      2  294f		       2d 33 23 34*	      .byte.b	"-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-",0
      0  298b					      END_LEVEL	_022_R
      1  298b		       00 3c	   LEVEL_SIZE__022_R =	* - LEVEL_START
      2  298b				  -	      IF	LEVEL_SIZE__022_R > MAX_LEVEL_SIZE
      3  298b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_R
      4  298b					      ENDIF
      0  298b					      DEFL	_023_L, "6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#"
      0  298b					      START_LEVEL	_023_L
      1  298b				   LEVEL_START SET	*
      2  298b		       00 05	   BANK_LEVEL__023_L =	_CURRENT_BANK
      3  298b				   LEVEL__023_L SUBROUTINE
      4  298b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  298b
      2  298b		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#",0
      0  29cc					      END_LEVEL	_023_L
      1  29cc		       00 41	   LEVEL_SIZE__023_L =	* - LEVEL_START
      2  29cc				  -	      IF	LEVEL_SIZE__023_L > MAX_LEVEL_SIZE
      3  29cc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_L
      4  29cc					      ENDIF
      0  29cc					      DEFL	_023_R, "7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-"
      0  29cc					      START_LEVEL	_023_R
      1  29cc				   LEVEL_START SET	*
      2  29cc		       00 05	   BANK_LEVEL__023_R =	_CURRENT_BANK
      3  29cc				   LEVEL__023_R SUBROUTINE
      4  29cc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  29cc
      2  29cc		       37 23 32 2d*	      .byte.b	"7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-",0
      0  2a0e					      END_LEVEL	_023_R
      1  2a0e		       00 42	   LEVEL_SIZE__023_R =	* - LEVEL_START
      2  2a0e				  -	      IF	LEVEL_SIZE__023_R > MAX_LEVEL_SIZE
      3  2a0e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_R
      4  2a0e					      ENDIF
      0  2a0e					      DEFL	_024_L, "-9#|-#7-#|-#-#2-$#-#|-#-#.*.#-#|2#2-.*-#-#|#3-.2$2-#|#-$2#2-3#|2#@2#2-#2-|-7#2-"
      0  2a0e					      START_LEVEL	_024_L
      1  2a0e				   LEVEL_START SET	*
      2  2a0e		       00 05	   BANK_LEVEL__024_L =	_CURRENT_BANK
      3  2a0e				   LEVEL__024_L SUBROUTINE
      4  2a0e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a0e
      2  2a0e		       2d 39 23 7c*	      .byte.b	"-9#|-#7-#|-#-#2-$#-#|-#-#.*.#-#|2#2-.*-#-#|#3-.2$2-#|#-$2#2-3#|2#@2#2-#2-|-7#2-",0
      0  2a5e					      END_LEVEL	_024_L
      1  2a5e		       00 50	   LEVEL_SIZE__024_L =	* - LEVEL_START
      2  2a5e				  -	      IF	LEVEL_SIZE__024_L > MAX_LEVEL_SIZE
      3  2a5e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__024_L
      4  2a5e					      ENDIF
      0  2a5e					      DEFL	_024_R, "-8#|2#6-#|#-$-*-#-#|#-3.*$-#|#2-*.*.2#|#2-#$-$-#|4#-$2-#|3-2#@3#|4-3#2-"
      0  2a5e					      START_LEVEL	_024_R
      1  2a5e				   LEVEL_START SET	*
      2  2a5e		       00 05	   BANK_LEVEL__024_R =	_CURRENT_BANK
      3  2a5e				   LEVEL__024_R SUBROUTINE
      4  2a5e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a5e
      2  2a5e		       2d 38 23 7c*	      .byte.b	"-8#|2#6-#|#-$-*-#-#|#-3.*$-#|#2-*.*.2#|#2-#$-$-#|4#-$2-#|3-2#@3#|4-3#2-",0
      0  2aa6					      END_LEVEL	_024_R
      1  2aa6		       00 48	   LEVEL_SIZE__024_R =	* - LEVEL_START
      2  2aa6				  -	      IF	LEVEL_SIZE__024_R > MAX_LEVEL_SIZE
      3  2aa6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__024_R
      4  2aa6					      ENDIF
      0  2aa6					      DEFL	_025_L, "4-4#2-|5#@-2#-|#4-2$-2#|#-3#2-$-#|#-3.2*.-#|#-2$*$2.2#|2#6-#-|-8#-"
      0  2aa6					      START_LEVEL	_025_L
      1  2aa6				   LEVEL_START SET	*
      2  2aa6		       00 05	   BANK_LEVEL__025_L =	_CURRENT_BANK
      3  2aa6				   LEVEL__025_L SUBROUTINE
      4  2aa6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2aa6
      2  2aa6		       34 2d 34 23*	      .byte.b	"4-4#2-|5#@-2#-|#4-2$-2#|#-3#2-$-#|#-3.2*.-#|#-2$*$2.2#|2#6-#-|-8#-",0
      0  2ae9					      END_LEVEL	_025_L
      1  2ae9		       00 43	   LEVEL_SIZE__025_L =	* - LEVEL_START
      2  2ae9				  -	      IF	LEVEL_SIZE__025_L > MAX_LEVEL_SIZE
      3  2ae9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__025_L
      4  2ae9					      ENDIF
      0  2ae9					      DEFL	_025_R, "-6#-|2#.-$-#-|#.*$*-2#|#.*2.$-#|2#3-#@#|-#-$-$-#|-3#2-2#|3-4#-"
      0  2ae9					      START_LEVEL	_025_R
      1  2ae9				   LEVEL_START SET	*
      2  2ae9		       00 05	   BANK_LEVEL__025_R =	_CURRENT_BANK
      3  2ae9				   LEVEL__025_R SUBROUTINE
      4  2ae9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ae9
      2  2ae9		       2d 36 23 2d*	      .byte.b	"-6#-|2#.-$-#-|#.*$*-2#|#.*2.$-#|2#3-#@#|-#-$-$-#|-3#2-2#|3-4#-",0
      0  2b28					      END_LEVEL	_025_R
      1  2b28		       00 3f	   LEVEL_SIZE__025_R =	* - LEVEL_START
      2  2b28				  -	      IF	LEVEL_SIZE__025_R > MAX_LEVEL_SIZE
      3  2b28				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__025_R
      4  2b28					      ENDIF
      0  2b28					      DEFL	_026_L, "-6#2-|2#-3.3#|#-$-2*.-#|#2-$-2*-#|#-$-$.$-#|#2-#-@2-#|9#"
      0  2b28					      START_LEVEL	_026_L
      1  2b28				   LEVEL_START SET	*
      2  2b28		       00 05	   BANK_LEVEL__026_L =	_CURRENT_BANK
      3  2b28				   LEVEL__026_L SUBROUTINE
      4  2b28				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b28
      2  2b28		       2d 36 23 32*	      .byte.b	"-6#2-|2#-3.3#|#-$-2*.-#|#2-$-2*-#|#-$-$.$-#|#2-#-@2-#|9#",0
      0  2b61					      END_LEVEL	_026_L
      1  2b61		       00 39	   LEVEL_SIZE__026_L =	* - LEVEL_START
      2  2b61				  -	      IF	LEVEL_SIZE__026_L > MAX_LEVEL_SIZE
      3  2b61				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__026_L
      4  2b61					      ENDIF
      0  2b61					      DEFL	_026_R, "5-4#|4-2#2-#|-4#3-#|2#2.-$2-#|#.3*$-2#|2#.$-$-#-|-3#-@2#-|3-4#2-"
      0  2b61					      START_LEVEL	_026_R
      1  2b61				   LEVEL_START SET	*
      2  2b61		       00 05	   BANK_LEVEL__026_R =	_CURRENT_BANK
      3  2b61				   LEVEL__026_R SUBROUTINE
      4  2b61				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b61
      2  2b61		       35 2d 34 23*	      .byte.b	"5-4#|4-2#2-#|-4#3-#|2#2.-$2-#|#.3*$-2#|2#.$-$-#-|-3#-@2#-|3-4#2-",0
      0  2ba2					      END_LEVEL	_026_R
      1  2ba2		       00 41	   LEVEL_SIZE__026_R =	* - LEVEL_START
      2  2ba2				  -	      IF	LEVEL_SIZE__026_R > MAX_LEVEL_SIZE
      3  2ba2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__026_R
      4  2ba2					      ENDIF
      0  2ba2					      DEFL	_027_L, "8#-|#3-@2-#-|#-*4$2#|2#*.#3-#|-#3.$2-#|-3#*.$-#|3-#.4#|3-3#3-"
      0  2ba2					      START_LEVEL	_027_L
      1  2ba2				   LEVEL_START SET	*
      2  2ba2		       00 05	   BANK_LEVEL__027_L =	_CURRENT_BANK
      3  2ba2				   LEVEL__027_L SUBROUTINE
      4  2ba2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ba2
      2  2ba2		       38 23 2d 7c*	      .byte.b	"8#-|#3-@2-#-|#-*4$2#|2#*.#3-#|-#3.$2-#|-3#*.$-#|3-#.4#|3-3#3-",0
      0  2be0					      END_LEVEL	_027_L
      1  2be0		       00 3e	   LEVEL_SIZE__027_L =	* - LEVEL_START
      2  2be0				  -	      IF	LEVEL_SIZE__027_L > MAX_LEVEL_SIZE
      3  2be0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__027_L
      4  2be0					      ENDIF
      0  2be0					      DEFL	_027_R, "7#2-|#5-2#-|#$2*-$-#-|#-*2.2-2#|#2.*3$-#|3#.#3-#|2-4#-@#|5-4#"
      0  2be0					      START_LEVEL	_027_R
      1  2be0				   LEVEL_START SET	*
      2  2be0		       00 05	   BANK_LEVEL__027_R =	_CURRENT_BANK
      3  2be0				   LEVEL__027_R SUBROUTINE
      4  2be0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2be0
      2  2be0		       37 23 32 2d*	      .byte.b	"7#2-|#5-2#-|#$2*-$-#-|#-*2.2-2#|#2.*3$-#|3#.#3-#|2-4#-@#|5-4#",0
      0  2c1e					      END_LEVEL	_027_R
      1  2c1e		       00 3e	   LEVEL_SIZE__027_R =	* - LEVEL_START
      2  2c1e				  -	      IF	LEVEL_SIZE__027_R > MAX_LEVEL_SIZE
      3  2c1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__027_R
      4  2c1e					      ENDIF
      0  2c1e					      DEFL	_028_L, "3-3#4-|4#.#4-|#-$-.#4-|#@#.*5#|#-$.*.3-#|#-2$-*$#-#|#2-#-.$2-#|4#4-2#|3-6#-"
      0  2c1e					      START_LEVEL	_028_L
      1  2c1e				   LEVEL_START SET	*
      2  2c1e		       00 05	   BANK_LEVEL__028_L =	_CURRENT_BANK
      3  2c1e				   LEVEL__028_L SUBROUTINE
      4  2c1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c1e
      2  2c1e		       33 2d 33 23*	      .byte.b	"3-3#4-|4#.#4-|#-$-.#4-|#@#.*5#|#-$.*.3-#|#-2$-*$#-#|#2-#-.$2-#|4#4-2#|3-6#-",0
      0  2c6a					      END_LEVEL	_028_L
      1  2c6a		       00 4c	   LEVEL_SIZE__028_L =	* - LEVEL_START
      2  2c6a				  -	      IF	LEVEL_SIZE__028_L > MAX_LEVEL_SIZE
      3  2c6a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__028_L
      4  2c6a					      ENDIF
      0  2c6a					      DEFL	_028_R, "9#-|#4-2#@#-|#-2#$#-$2#|#-.-.2$2-#|#-.*.2-#-#|#-#.#$3-#|#-#2*3-2#|#4-4#-|6#4-"
      0  2c6a					      START_LEVEL	_028_R
      1  2c6a				   LEVEL_START SET	*
      2  2c6a		       00 05	   BANK_LEVEL__028_R =	_CURRENT_BANK
      3  2c6a				   LEVEL__028_R SUBROUTINE
      4  2c6a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c6a
      2  2c6a		       39 23 2d 7c*	      .byte.b	"9#-|#4-2#@#-|#-2#$#-$2#|#-.-.2$2-#|#-.*.2-#-#|#-#.#$3-#|#-#2*3-2#|#4-4#-|6#4-",0
      0  2cb8					      END_LEVEL	_028_R
      1  2cb8		       00 4e	   LEVEL_SIZE__028_R =	* - LEVEL_START
      2  2cb8				  -	      IF	LEVEL_SIZE__028_R > MAX_LEVEL_SIZE
      3  2cb8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__028_R
      4  2cb8					      ENDIF
      0  2cb8					      DEFL	_029_L, "-5#3-|-#-@-2#2-|2#$*$-3#|#2.*.$2-#|#.*.$3-#|2#2-$-3#|-3#2-#2-|3-4#2-"
      0  2cb8					      START_LEVEL	_029_L
      1  2cb8				   LEVEL_START SET	*
      2  2cb8		       00 05	   BANK_LEVEL__029_L =	_CURRENT_BANK
      3  2cb8				   LEVEL__029_L SUBROUTINE
      4  2cb8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cb8
      2  2cb8		       2d 35 23 33*	      .byte.b	"-5#3-|-#-@-2#2-|2#$*$-3#|#2.*.$2-#|#.*.$3-#|2#2-$-3#|-3#2-#2-|3-4#2-",0
      0  2cfd					      END_LEVEL	_029_L
      1  2cfd		       00 45	   LEVEL_SIZE__029_L =	* - LEVEL_START
      2  2cfd				  -	      IF	LEVEL_SIZE__029_L > MAX_LEVEL_SIZE
      3  2cfd				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__029_L
      4  2cfd					      ENDIF
      0  2cfd					      DEFL	_029_R, "-4#4-|-#@-4#-|2#$-$2-2#|#2.3$2-#|#.2*.*$-#|3#2-2.-#|2-#2-$.2#|2-6#-"
      0  2cfd					      START_LEVEL	_029_R
      1  2cfd				   LEVEL_START SET	*
      2  2cfd		       00 05	   BANK_LEVEL__029_R =	_CURRENT_BANK
      3  2cfd				   LEVEL__029_R SUBROUTINE
      4  2cfd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cfd
      2  2cfd		       2d 34 23 34*	      .byte.b	"-4#4-|-#@-4#-|2#$-$2-2#|#2.3$2-#|#.2*.*$-#|3#2-2.-#|2-#2-$.2#|2-6#-",0
      0  2d41					      END_LEVEL	_029_R
      1  2d41		       00 44	   LEVEL_SIZE__029_R =	* - LEVEL_START
      2  2d41				  -	      IF	LEVEL_SIZE__029_R > MAX_LEVEL_SIZE
      3  2d41				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__029_R
      4  2d41					      ENDIF
      0  2d41					      DEFL	_030_L, "6-5#|5#-#2-@#|#3-3#2$-#|#2-$-2.-$2#|3#-.*.*-2#|2-3#-.$2-#|4-#3-#-#|4-2#4-#|5-6#"
      0  2d41					      START_LEVEL	_030_L
      1  2d41				   LEVEL_START SET	*
      2  2d41		       00 05	   BANK_LEVEL__030_L =	_CURRENT_BANK
      3  2d41				   LEVEL__030_L SUBROUTINE
      4  2d41				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d41
      2  2d41		       36 2d 35 23*	      .byte.b	"6-5#|5#-#2-@#|#3-3#2$-#|#2-$-2.-$2#|3#-.*.*-2#|2-3#-.$2-#|4-#3-#-#|4-2#4-#|5-6#",0
      0  2d91					      END_LEVEL	_030_L
      1  2d91		       00 50	   LEVEL_SIZE__030_L =	* - LEVEL_START
      2  2d91				  -	      IF	LEVEL_SIZE__030_L > MAX_LEVEL_SIZE
      3  2d91				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__030_L
      4  2d91					      ENDIF
      0  2d91					      DEFL	_030_R, "-7#2-|2#-$2-.#2-|#-$-$#.#2-|#-#.$2.#2-|#-#3.$2#-|#2-$#*2-2#|3#2-*2$-#|2-#@5-#|2-8#"
      0  2d91					      START_LEVEL	_030_R
      1  2d91				   LEVEL_START SET	*
      2  2d91		       00 05	   BANK_LEVEL__030_R =	_CURRENT_BANK
      3  2d91				   LEVEL__030_R SUBROUTINE
      4  2d91				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d91
      2  2d91		       2d 37 23 32*	      .byte.b	"-7#2-|2#-$2-.#2-|#-$-$#.#2-|#-#.$2.#2-|#-#3.$2#-|#2-$#*2-2#|3#2-*2$-#|2-#@5-#|2-8#",0
      0  2de4					      END_LEVEL	_030_R
      1  2de4		       00 53	   LEVEL_SIZE__030_R =	* - LEVEL_START
      2  2de4				  -	      IF	LEVEL_SIZE__030_R > MAX_LEVEL_SIZE
      3  2de4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__030_R
      4  2de4					      ENDIF
      0  2de4					      DEFL	_031_L, "-7#2-|-#3-@-3#|-#-2$*2$-#|3#2-*.2-#|#2.2*.*2-#|#$#2-.2-2#|#3-5#-|5#5-"
      0  2de4					      START_LEVEL	_031_L
      1  2de4				   LEVEL_START SET	*
      2  2de4		       00 05	   BANK_LEVEL__031_L =	_CURRENT_BANK
      3  2de4				   LEVEL__031_L SUBROUTINE
      4  2de4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2de4
      2  2de4		       2d 37 23 32*	      .byte.b	"-7#2-|-#3-@-3#|-#-2$*2$-#|3#2-*.2-#|#2.2*.*2-#|#$#2-.2-2#|#3-5#-|5#5-",0
      0  2e2a					      END_LEVEL	_031_L
      1  2e2a		       00 46	   LEVEL_SIZE__031_L =	* - LEVEL_START
      2  2e2a				  -	      IF	LEVEL_SIZE__031_L > MAX_LEVEL_SIZE
      3  2e2a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__031_L
      4  2e2a					      ENDIF
      0  2e2a					      DEFL	_031_R, "6#-|#2-#+#-|#2-$.2#|#2-2*.#|#-$-.$#|#-$-*.#|#-2$.-#|#-$-.-#|7#"
      0  2e2a					      START_LEVEL	_031_R
      1  2e2a				   LEVEL_START SET	*
      2  2e2a		       00 05	   BANK_LEVEL__031_R =	_CURRENT_BANK
      3  2e2a				   LEVEL__031_R SUBROUTINE
      4  2e2a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e2a
      2  2e2a		       36 23 2d 7c*	      .byte.b	"6#-|#2-#+#-|#2-$.2#|#2-2*.#|#-$-.$#|#-$-*.#|#-2$.-#|#-$-.-#|7#",0
      0  2e69					      END_LEVEL	_031_R
      1  2e69		       00 3f	   LEVEL_SIZE__031_R =	* - LEVEL_START
      2  2e69				  -	      IF	LEVEL_SIZE__031_R > MAX_LEVEL_SIZE
      3  2e69				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__031_R
      4  2e69					      ENDIF
      0  2e69					      DEFL	_032_L, "-4#2-|-#2-3#|2#2-2.#|#@2$*.#|#-$2-.#|#-$-#*#|3#3-#|2-5#"
      0  2e69					      START_LEVEL	_032_L
      1  2e69				   LEVEL_START SET	*
      2  2e69		       00 05	   BANK_LEVEL__032_L =	_CURRENT_BANK
      3  2e69				   LEVEL__032_L SUBROUTINE
      4  2e69				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e69
      2  2e69		       2d 34 23 32*	      .byte.b	"-4#2-|-#2-3#|2#2-2.#|#@2$*.#|#-$2-.#|#-$-#*#|3#3-#|2-5#",0
      0  2ea1					      END_LEVEL	_032_L
      1  2ea1		       00 38	   LEVEL_SIZE__032_L =	* - LEVEL_START
      2  2ea1				  -	      IF	LEVEL_SIZE__032_L > MAX_LEVEL_SIZE
      3  2ea1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__032_L
      4  2ea1					      ENDIF
      0  2ea1					      DEFL	_032_R, "9#-|#7-2#|#-$3#-$@#|#2-2.#.$-#|#-.*.2*$-#|#-$.*2-$-#|#2-#.$-3#|8#2-"
      0  2ea1					      START_LEVEL	_032_R
      1  2ea1				   LEVEL_START SET	*
      2  2ea1		       00 05	   BANK_LEVEL__032_R =	_CURRENT_BANK
      3  2ea1				   LEVEL__032_R SUBROUTINE
      4  2ea1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ea1
      2  2ea1		       39 23 2d 7c*	      .byte.b	"9#-|#7-2#|#-$3#-$@#|#2-2.#.$-#|#-.*.2*$-#|#-$.*2-$-#|#2-#.$-3#|8#2-",0
      0  2ee5					      END_LEVEL	_032_R
      1  2ee5		       00 44	   LEVEL_SIZE__032_R =	* - LEVEL_START
      2  2ee5				  -	      IF	LEVEL_SIZE__032_R > MAX_LEVEL_SIZE
      3  2ee5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__032_R
      4  2ee5					      ENDIF
      0  2ee5					      DEFL	_033_L, "2-7#-|-2#2-#2-2#|-#2-.*-$-#|-#-$.$-$@#|2#$-2*-3#|#2-$*.*.#-|#3-2.3#-|7#3-"
      0  2ee5					      START_LEVEL	_033_L
      1  2ee5				   LEVEL_START SET	*
      2  2ee5		       00 05	   BANK_LEVEL__033_L =	_CURRENT_BANK
      3  2ee5				   LEVEL__033_L SUBROUTINE
      4  2ee5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ee5
      2  2ee5		       32 2d 37 23*	      .byte.b	"2-7#-|-2#2-#2-2#|-#2-.*-$-#|-#-$.$-$@#|2#$-2*-3#|#2-$*.*.#-|#3-2.3#-|7#3-",0
      0  2f2f					      END_LEVEL	_033_L
      1  2f2f		       00 4a	   LEVEL_SIZE__033_L =	* - LEVEL_START
      2  2f2f				  -	      IF	LEVEL_SIZE__033_L > MAX_LEVEL_SIZE
      3  2f2f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__033_L
      4  2f2f					      ENDIF
      0  2f2f					      DEFL	_033_R, "-7#2-|2#2-#@-2#-|#-$-#3-2#|#-$2-$*$-#|#2-*.*.2-#|2#.*2.-$-#|-9#"
      0  2f2f					      START_LEVEL	_033_R
      1  2f2f				   LEVEL_START SET	*
      2  2f2f		       00 05	   BANK_LEVEL__033_R =	_CURRENT_BANK
      3  2f2f				   LEVEL__033_R SUBROUTINE
      4  2f2f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2f2f
      2  2f2f		       2d 37 23 32*	      .byte.b	"-7#2-|2#2-#@-2#-|#-$-#3-2#|#-$2-$*$-#|#2-*.*.2-#|2#.*2.-$-#|-9#",0
      0  2f6f					      END_LEVEL	_033_R
      1  2f6f		       00 40	   LEVEL_SIZE__033_R =	* - LEVEL_START
      2  2f6f				  -	      IF	LEVEL_SIZE__033_R > MAX_LEVEL_SIZE
      3  2f6f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__033_R
      4  2f6f					      ENDIF
      0  2f6f					      DEFL	_034_L, "5-4#-|-5#2-#-|-#-$@$2-#-|2#-#*$.*2#|#3-.2*2.#|#2-$2-4#|4#2-#3-|3-#2-#3-|3-4#3-"
      0  2f6f					      START_LEVEL	_034_L
      1  2f6f				   LEVEL_START SET	*
      2  2f6f		       00 05	   BANK_LEVEL__034_L =	_CURRENT_BANK
      3  2f6f				   LEVEL__034_L SUBROUTINE
      4  2f6f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2f6f
      2  2f6f		       35 2d 34 23*	      .byte.b	"5-4#-|-5#2-#-|-#-$@$2-#-|2#-#*$.*2#|#3-.2*2.#|#2-$2-4#|4#2-#3-|3-#2-#3-|3-4#3-",0
      0  2fbe					      END_LEVEL	_034_L
      1  2fbe		       00 4f	   LEVEL_SIZE__034_L =	* - LEVEL_START
      2  2fbe				  -	      IF	LEVEL_SIZE__034_L > MAX_LEVEL_SIZE
      3  2fbe				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__034_L
      4  2fbe					      ENDIF
     65  2fbe
      0  2fbe					      CHECK_BANK_SIZE	"LEVELS2"
      1  2fbe		       07 be	   .TEMP      =	* - BANK_START
 LEVELS2 (2K) SIZE =  $7be , FREE= $42
      2  2fbe					      ECHO	"LEVELS2", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2fbe				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2fbe				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2fbe				  -	      ERR
      6  2fbe					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS3.asm LEVEL 2 PASS 3
      0  2fbe					      include	"BANK_LEVELS3.asm"
      1  2fbe							;    Sokoboo - a Sokoban implementation
      2  2fbe							;    using a generic tile-based display engine for the Atari 2600
      3  2fbe							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  2fbe							;
      5  2fbe							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  2fbe							;
      7  2fbe							;    Code related to the generic tile-based display engine was developed by
      8  2fbe							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  2fbe							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  2fbe							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  2fbe							;
     12  2fbe							;    Code related to music and sound effects uses the TIATracker music player
     13  2fbe							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  2fbe							;    directory for Apache licensing details.
     15  2fbe							;
     16  2fbe							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  2fbe							;    See the copyright notices in the License directory for a list of level
     18  2fbe							;    contributors.
     19  2fbe							;
     20  2fbe							;    Except where otherwise indicated, this software is released under the
     21  2fbe							;    following licensing arrangement...
     22  2fbe							;
     23  2fbe							;    This program is free software: you can redistribute it and/or modify
     24  2fbe							;    it under the terms of the GNU General Public License as published by
     25  2fbe							;    the Free Software Foundation, either version 3 of the License, or
     26  2fbe							;    (at your option) any later version.
     27  2fbe							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  2fbe
     29  2fbe							;    This program is distributed in the hope that it will be useful,
     30  2fbe							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  2fbe							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  2fbe							;    GNU General Public License for more details.
     33  2fbe
      0  2fbe					      NEWBANK	LEVELS3
      1  37c7 ????				      SEG	LEVELS3
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   LEVELS3    SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	LEVELS3
     35  3000
      0  3000					      DEFL	_034_R, "-6#3-|-#4-#3-|2#-$.-3#-|#-2$*.$@#-|#-3.#2$2#|4#.4-#|3-3#-#-#|5-#3-#|5-5#"
      0  3000					      START_LEVEL	_034_R
      1  3000				   LEVEL_START SET	*
      2  3000		       00 06	   BANK_LEVEL__034_R =	_CURRENT_BANK
      3  3000				   LEVEL__034_R SUBROUTINE
      4  3000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3000
      2  3000		       2d 36 23 33*	      .byte.b	"-6#3-|-#4-#3-|2#-$.-3#-|#-2$*.$@#-|#-3.#2$2#|4#.4-#|3-3#-#-#|5-#3-#|5-5#",0
      0  3049					      END_LEVEL	_034_R
      1  3049		       00 49	   LEVEL_SIZE__034_R =	* - LEVEL_START
      2  3049				  -	      IF	LEVEL_SIZE__034_R > MAX_LEVEL_SIZE
      3  3049				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__034_R
      4  3049					      ENDIF
      0  3049					      DEFL	_035_L, "5-3#2-|6#.2#-|#@2-2#*.#-|#-3$2.-#-|2#2-$*.$2#|-#-$2-.2-#|-5#3-#|5-5#"
      0  3049					      START_LEVEL	_035_L
      1  3049				   LEVEL_START SET	*
      2  3049		       00 06	   BANK_LEVEL__035_L =	_CURRENT_BANK
      3  3049				   LEVEL__035_L SUBROUTINE
      4  3049				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3049
      2  3049		       35 2d 33 23*	      .byte.b	"5-3#2-|6#.2#-|#@2-2#*.#-|#-3$2.-#-|2#2-$*.$2#|-#-$2-.2-#|-5#3-#|5-5#",0
      0  308e					      END_LEVEL	_035_L
      1  308e		       00 45	   LEVEL_SIZE__035_L =	* - LEVEL_START
      2  308e				  -	      IF	LEVEL_SIZE__035_L > MAX_LEVEL_SIZE
      3  308e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__035_L
      4  308e					      ENDIF
      0  308e					      DEFL	_035_R, "-11#|-#4-@4-#|-#-2$3*$#-#|3#-*.$.-$-#|#3-.*.-4#|#3-2#.2#3-|8#4-"
      0  308e					      START_LEVEL	_035_R
      1  308e				   LEVEL_START SET	*
      2  308e		       00 06	   BANK_LEVEL__035_R =	_CURRENT_BANK
      3  308e				   LEVEL__035_R SUBROUTINE
      4  308e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  308e
      2  308e		       2d 31 31 23*	      .byte.b	"-11#|-#4-@4-#|-#-2$3*$#-#|3#-*.$.-$-#|#3-.*.-4#|#3-2#.2#3-|8#4-",0
      0  30ce					      END_LEVEL	_035_R
      1  30ce		       00 40	   LEVEL_SIZE__035_R =	* - LEVEL_START
      2  30ce				  -	      IF	LEVEL_SIZE__035_R > MAX_LEVEL_SIZE
      3  30ce				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__035_R
      4  30ce					      ENDIF
      0  30ce					      DEFL	_036_L, "5#2-|#3-3#|#*#-$@#|#.2-$-#|#.*2$-#|#2.#2-#|4#2-#|3-4#"
      0  30ce					      START_LEVEL	_036_L
      1  30ce				   LEVEL_START SET	*
      2  30ce		       00 06	   BANK_LEVEL__036_L =	_CURRENT_BANK
      3  30ce				   LEVEL__036_L SUBROUTINE
      4  30ce				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  30ce
      2  30ce		       35 23 32 2d*	      .byte.b	"5#2-|#3-3#|#*#-$@#|#.2-$-#|#.*2$-#|#2.#2-#|4#2-#|3-4#",0
      0  3104					      END_LEVEL	_036_L
      1  3104		       00 36	   LEVEL_SIZE__036_L =	* - LEVEL_START
      2  3104				  -	      IF	LEVEL_SIZE__036_L > MAX_LEVEL_SIZE
      3  3104				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__036_L
      4  3104					      ENDIF
      0  3104					      DEFL	_036_R, "2-5#2-|-2#.2-2#-|-#.*-$-2#|2#2.$-$-#|#.2*.-$@#|#2-$2-$2#|3#4-#-|2-6#-"
      0  3104					      START_LEVEL	_036_R
      1  3104				   LEVEL_START SET	*
      2  3104		       00 06	   BANK_LEVEL__036_R =	_CURRENT_BANK
      3  3104				   LEVEL__036_R SUBROUTINE
      4  3104				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3104
      2  3104		       32 2d 35 23*	      .byte.b	"2-5#2-|-2#.2-2#-|-#.*-$-2#|2#2.$-$-#|#.2*.-$@#|#2-$2-$2#|3#4-#-|2-6#-",0
      0  314a					      END_LEVEL	_036_R
      1  314a		       00 46	   LEVEL_SIZE__036_R =	* - LEVEL_START
      2  314a				  -	      IF	LEVEL_SIZE__036_R > MAX_LEVEL_SIZE
      3  314a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__036_R
      4  314a					      ENDIF
      0  314a					      DEFL	_037_L, "5-6#|6#4-#|#2-#@2.2$-#|#2-$.3*.-#|#3-$.$-$-#|2#2-#.3-2#|-9#-"
      0  314a					      START_LEVEL	_037_L
      1  314a				   LEVEL_START SET	*
      2  314a		       00 06	   BANK_LEVEL__037_L =	_CURRENT_BANK
      3  314a				   LEVEL__037_L SUBROUTINE
      4  314a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  314a
      2  314a		       35 2d 36 23*	      .byte.b	"5-6#|6#4-#|#2-#@2.2$-#|#2-$.3*.-#|#3-$.$-$-#|2#2-#.3-2#|-9#-",0
      0  3187					      END_LEVEL	_037_L
      1  3187		       00 3d	   LEVEL_SIZE__037_L =	* - LEVEL_START
      2  3187				  -	      IF	LEVEL_SIZE__037_L > MAX_LEVEL_SIZE
      3  3187				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__037_L
      4  3187					      ENDIF
      0  3187					      DEFL	_037_R, "9#2-|#7-3#|#-$2-.2*.-#|2#-*.*$3-#|-2#-2*.#2-#|2-2#@$-$-2#|3-3#3-#-|5-5#-"
      0  3187					      START_LEVEL	_037_R
      1  3187				   LEVEL_START SET	*
      2  3187		       00 06	   BANK_LEVEL__037_R =	_CURRENT_BANK
      3  3187				   LEVEL__037_R SUBROUTINE
      4  3187				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3187
      2  3187		       39 23 32 2d*	      .byte.b	"9#2-|#7-3#|#-$2-.2*.-#|2#-*.*$3-#|-2#-2*.#2-#|2-2#@$-$-2#|3-3#3-#-|5-5#-",0
      0  31d0					      END_LEVEL	_037_R
      1  31d0		       00 49	   LEVEL_SIZE__037_R =	* - LEVEL_START
      2  31d0				  -	      IF	LEVEL_SIZE__037_R > MAX_LEVEL_SIZE
      3  31d0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__037_R
      4  31d0					      ENDIF
      0  31d0					      DEFL	_038_L, "6-4#2-|4-3#@-3#|3-2#2.*$2-#|4#.*.*3-#|#2-2$3-$2-#|#5-6#|3#2-2#5-|2-4#6-"
      0  31d0					      START_LEVEL	_038_L
      1  31d0				   LEVEL_START SET	*
      2  31d0		       00 06	   BANK_LEVEL__038_L =	_CURRENT_BANK
      3  31d0				   LEVEL__038_L SUBROUTINE
      4  31d0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  31d0
      2  31d0		       36 2d 34 23*	      .byte.b	"6-4#2-|4-3#@-3#|3-2#2.*$2-#|4#.*.*3-#|#2-2$3-$2-#|#5-6#|3#2-2#5-|2-4#6-",0
      0  3218					      END_LEVEL	_038_L
      1  3218		       00 48	   LEVEL_SIZE__038_L =	* - LEVEL_START
      2  3218				  -	      IF	LEVEL_SIZE__038_L > MAX_LEVEL_SIZE
      3  3218				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__038_L
      4  3218					      ENDIF
      0  3218					      DEFL	_038_R, "6-6#|4-3#.#-@#|2-3#2.*#$-#|3#-.*2.-$-#|#2-2$2-#-3#|#-$2-#-$-#2-|2#5-3#2-|-7#4-"
      0  3218					      START_LEVEL	_038_R
      1  3218				   LEVEL_START SET	*
      2  3218		       00 06	   BANK_LEVEL__038_R =	_CURRENT_BANK
      3  3218				   LEVEL__038_R SUBROUTINE
      4  3218				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3218
      2  3218		       36 2d 36 23*	      .byte.b	"6-6#|4-3#.#-@#|2-3#2.*#$-#|3#-.*2.-$-#|#2-2$2-#-3#|#-$2-#-$-#2-|2#5-3#2-|-7#4-",0
      0  3267					      END_LEVEL	_038_R
      1  3267		       00 4f	   LEVEL_SIZE__038_R =	* - LEVEL_START
      2  3267				  -	      IF	LEVEL_SIZE__038_R > MAX_LEVEL_SIZE
      3  3267				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__038_R
      4  3267					      ENDIF
      0  3267					      DEFL	_039_L, "-7#2-|-#5-#2-|2#-#-$-#2-|#.2*.-3#-|2#@3*2-2#|-2#-2.$2-#|2-2#$#-$-#|3-#5-#|3-7#"
      0  3267					      START_LEVEL	_039_L
      1  3267				   LEVEL_START SET	*
      2  3267		       00 06	   BANK_LEVEL__039_L =	_CURRENT_BANK
      3  3267				   LEVEL__039_L SUBROUTINE
      4  3267				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3267
      2  3267		       2d 37 23 32*	      .byte.b	"-7#2-|-#5-#2-|2#-#-$-#2-|#.2*.-3#-|2#@3*2-2#|-2#-2.$2-#|2-2#$#-$-#|3-#5-#|3-7#",0
      0  32b6					      END_LEVEL	_039_L
      1  32b6		       00 4f	   LEVEL_SIZE__039_L =	* - LEVEL_START
      2  32b6				  -	      IF	LEVEL_SIZE__039_L > MAX_LEVEL_SIZE
      3  32b6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__039_L
      4  32b6					      ENDIF
      0  32b6					      DEFL	_039_R, "4-4#4-|3-2#2-3#2-|2-2#-$.2-#2-|3#-.2*-$3#|#-$-4.3-#|#@$3#-#-#-#|2#4-$2-$-#|-5#3-3#|5-5#2-"
      0  32b6					      START_LEVEL	_039_R
      1  32b6				   LEVEL_START SET	*
      2  32b6		       00 06	   BANK_LEVEL__039_R =	_CURRENT_BANK
      3  32b6				   LEVEL__039_R SUBROUTINE
      4  32b6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  32b6
      2  32b6		       34 2d 34 23*	      .byte.b	"4-4#4-|3-2#2-3#2-|2-2#-$.2-#2-|3#-.2*-$3#|#-$-4.3-#|#@$3#-#-#-#|2#4-$2-$-#|-5#3-3#|5-5#2-",0
      0  3310					      END_LEVEL	_039_R
      1  3310		       00 5a	   LEVEL_SIZE__039_R =	* - LEVEL_START
      2  3310					      IF	LEVEL_SIZE__039_R > MAX_LEVEL_SIZE
      3  3310				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__039_R
      4  3310					      ENDIF
      0  3310					      DEFL	_040_L, "6#3-|#3-@#3-|#2-$.3#-|3#$*$.2#|3#-.2*.#|#2-$-.3#|#2-$3-#-|4#3-#-|3-5#-"
      0  3310					      START_LEVEL	_040_L
      1  3310				   LEVEL_START SET	*
      2  3310		       00 06	   BANK_LEVEL__040_L =	_CURRENT_BANK
      3  3310				   LEVEL__040_L SUBROUTINE
      4  3310				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3310
      2  3310		       36 23 33 2d*	      .byte.b	"6#3-|#3-@#3-|#2-$.3#-|3#$*$.2#|3#-.2*.#|#2-$-.3#|#2-$3-#-|4#3-#-|3-5#-",0
      0  3357					      END_LEVEL	_040_L
      1  3357		       00 47	   LEVEL_SIZE__040_L =	* - LEVEL_START
      2  3357				  -	      IF	LEVEL_SIZE__040_L > MAX_LEVEL_SIZE
      3  3357				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__040_L
      4  3357					      ENDIF
      0  3357					      DEFL	_040_R, "5-4#-|-5#2-2#|2#.-$2-$-#|#-2.*.$#@#|#-*-.2-$-#|2#-$*-4#|-#3-2#3-|-5#4-"
      0  3357					      START_LEVEL	_040_R
      1  3357				   LEVEL_START SET	*
      2  3357		       00 06	   BANK_LEVEL__040_R =	_CURRENT_BANK
      3  3357				   LEVEL__040_R SUBROUTINE
      4  3357				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3357
      2  3357		       35 2d 34 23*	      .byte.b	"5-4#-|-5#2-2#|2#.-$2-$-#|#-2.*.$#@#|#-*-.2-$-#|2#-$*-4#|-#3-2#3-|-5#4-",0
      0  339e					      END_LEVEL	_040_R
      1  339e		       00 47	   LEVEL_SIZE__040_R =	* - LEVEL_START
      2  339e				  -	      IF	LEVEL_SIZE__040_R > MAX_LEVEL_SIZE
      3  339e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__040_R
      4  339e					      ENDIF
     49  339e
      0  339e					      DEFL	_041_L, "4-3#5-|4-#.4#2-|5#*.$-#2-|#4-3.-3#|#-3$-*.$2-#|2#-@2#.$-$-#|-5#4-2#|5-6#-"
      0  339e					      START_LEVEL	_041_L
      1  339e				   LEVEL_START SET	*
      2  339e		       00 06	   BANK_LEVEL__041_L =	_CURRENT_BANK
      3  339e				   LEVEL__041_L SUBROUTINE
      4  339e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  339e
      2  339e		       34 2d 33 23*	      .byte.b	"4-3#5-|4-#.4#2-|5#*.$-#2-|#4-3.-3#|#-3$-*.$2-#|2#-@2#.$-$-#|-5#4-2#|5-6#-",0
      0  33e8					      END_LEVEL	_041_L
      1  33e8		       00 4a	   LEVEL_SIZE__041_L =	* - LEVEL_START
      2  33e8				  -	      IF	LEVEL_SIZE__041_L > MAX_LEVEL_SIZE
      3  33e8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__041_L
      4  33e8					      ENDIF
      0  33e8					      DEFL	_041_R, "-4#3-|2#2-3#-|#-@2$-#-|#-$-#.#-|2#$-2.2#|#2-$*2.#|#2-$-*2#|#3-#.#-|7#-"
      0  33e8					      START_LEVEL	_041_R
      1  33e8				   LEVEL_START SET	*
      2  33e8		       00 06	   BANK_LEVEL__041_R =	_CURRENT_BANK
      3  33e8				   LEVEL__041_R SUBROUTINE
      4  33e8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  33e8
      2  33e8		       2d 34 23 33*	      .byte.b	"-4#3-|2#2-3#-|#-@2$-#-|#-$-#.#-|2#$-2.2#|#2-$*2.#|#2-$-*2#|#3-#.#-|7#-",0
      0  342f					      END_LEVEL	_041_R
      1  342f		       00 47	   LEVEL_SIZE__041_R =	* - LEVEL_START
      2  342f				  -	      IF	LEVEL_SIZE__041_R > MAX_LEVEL_SIZE
      3  342f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__041_R
      4  342f					      ENDIF
      0  342f					      DEFL	_042_L, "8#4-|#6-#4-|#-#-$*-#4-|#-#-#.3#3-|#3-#2.-3#-|#3-2*4-2#|5#.-3$-#|4-4#2-@#|7-5#"
      0  342f					      START_LEVEL	_042_L
      1  342f				   LEVEL_START SET	*
      2  342f		       00 06	   BANK_LEVEL__042_L =	_CURRENT_BANK
      3  342f				   LEVEL__042_L SUBROUTINE
      4  342f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  342f
      2  342f		       38 23 34 2d*	      .byte.b	"8#4-|#6-#4-|#-#-$*-#4-|#-#-#.3#3-|#3-#2.-3#-|#3-2*4-2#|5#.-3$-#|4-4#2-@#|7-5#",0
      0  347d					      END_LEVEL	_042_L
      1  347d		       00 4e	   LEVEL_SIZE__042_L =	* - LEVEL_START
      2  347d				  -	      IF	LEVEL_SIZE__042_L > MAX_LEVEL_SIZE
      3  347d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__042_L
      4  347d					      ENDIF
      0  347d					      DEFL	_042_R, "3-5#4-|2-2#3-#4-|2-#-$-$#4-|3#-*.-2#3-|#@$-#.$-2#2-|#-$2-.*.-3#|3#2.*-$3-#|2-6#3-#|7-5#"
      0  347d					      START_LEVEL	_042_R
      1  347d				   LEVEL_START SET	*
      2  347d		       00 06	   BANK_LEVEL__042_R =	_CURRENT_BANK
      3  347d				   LEVEL__042_R SUBROUTINE
      4  347d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  347d
      2  347d		       33 2d 35 23*	      .byte.b	"3-5#4-|2-2#3-#4-|2-#-$-$#4-|3#-*.-2#3-|#@$-#.$-2#2-|#-$2-.*.-3#|3#2.*-$3-#|2-6#3-#|7-5#",0
      0  34d5					      END_LEVEL	_042_R
      1  34d5		       00 58	   LEVEL_SIZE__042_R =	* - LEVEL_START
      2  34d5				  -	      IF	LEVEL_SIZE__042_R > MAX_LEVEL_SIZE
      3  34d5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__042_R
      4  34d5					      ENDIF
      0  34d5					      DEFL	_043_L, "-8#4-|-#@$.-.-5#|-#2$*.2*.3-#|2#2-$-.2-#$-#|#-$-2#.#3-2#|#3-8#-|#2-2#8-|4#9-"
      0  34d5					      START_LEVEL	_043_L
      1  34d5				   LEVEL_START SET	*
      2  34d5		       00 06	   BANK_LEVEL__043_L =	_CURRENT_BANK
      3  34d5				   LEVEL__043_L SUBROUTINE
      4  34d5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  34d5
      2  34d5		       2d 38 23 34*	      .byte.b	"-8#4-|-#@$.-.-5#|-#2$*.2*.3-#|2#2-$-.2-#$-#|#-$-2#.#3-2#|#3-8#-|#2-2#8-|4#9-",0
      0  3522					      END_LEVEL	_043_L
      1  3522		       00 4d	   LEVEL_SIZE__043_L =	* - LEVEL_START
      2  3522				  -	      IF	LEVEL_SIZE__043_L > MAX_LEVEL_SIZE
      3  3522				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__043_L
      4  3522					      ENDIF
      0  3522					      DEFL	_043_R, "2-6#-|-2#4-#-|2#@$-#-#-|#-$#$2.#-|#*.*2.*2#|#-$2-$2.#|#-$-$2-2#|#4-3#-|6#3-"
      0  3522					      START_LEVEL	_043_R
      1  3522				   LEVEL_START SET	*
      2  3522		       00 06	   BANK_LEVEL__043_R =	_CURRENT_BANK
      3  3522				   LEVEL__043_R SUBROUTINE
      4  3522				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3522
      2  3522		       32 2d 36 23*	      .byte.b	"2-6#-|-2#4-#-|2#@$-#-#-|#-$#$2.#-|#*.*2.*2#|#-$2-$2.#|#-$-$2-2#|#4-3#-|6#3-",0
      0  356e					      END_LEVEL	_043_R
      1  356e		       00 4c	   LEVEL_SIZE__043_R =	* - LEVEL_START
      2  356e				  -	      IF	LEVEL_SIZE__043_R > MAX_LEVEL_SIZE
      3  356e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__043_R
      4  356e					      ENDIF
      0  356e					      DEFL	_044_L, "7#-|#@4-#-|#$-.2$#-|#3.*-2#|#*$2*2-#|#3-#2-#|#3-#2-#|8#"
      0  356e					      START_LEVEL	_044_L
      1  356e				   LEVEL_START SET	*
      2  356e		       00 06	   BANK_LEVEL__044_L =	_CURRENT_BANK
      3  356e				   LEVEL__044_L SUBROUTINE
      4  356e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  356e
      2  356e		       37 23 2d 7c*	      .byte.b	"7#-|#@4-#-|#$-.2$#-|#3.*-2#|#*$2*2-#|#3-#2-#|#3-#2-#|8#",0
      0  35a6					      END_LEVEL	_044_L
      1  35a6		       00 38	   LEVEL_SIZE__044_L =	* - LEVEL_START
      2  35a6				  -	      IF	LEVEL_SIZE__044_L > MAX_LEVEL_SIZE
      3  35a6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__044_L
      4  35a6					      ENDIF
      0  35a6					      DEFL	_044_R, "4#-4#-|#2-3#2-#-|#@$2-#-$2#|#$*$5-#|#-*2.$2#-#|#3.#4-#|2#-.-$4#|-3#2-#3-|3-4#3-"
      0  35a6					      START_LEVEL	_044_R
      1  35a6				   LEVEL_START SET	*
      2  35a6		       00 06	   BANK_LEVEL__044_R =	_CURRENT_BANK
      3  35a6				   LEVEL__044_R SUBROUTINE
      4  35a6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35a6
      2  35a6		       34 23 2d 34*	      .byte.b	"4#-4#-|#2-3#2-#-|#@$2-#-$2#|#$*$5-#|#-*2.$2#-#|#3.#4-#|2#-.-$4#|-3#2-#3-|3-4#3-",0
      0  35f6					      END_LEVEL	_044_R
      1  35f6		       00 50	   LEVEL_SIZE__044_R =	* - LEVEL_START
      2  35f6				  -	      IF	LEVEL_SIZE__044_R > MAX_LEVEL_SIZE
      3  35f6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__044_R
      4  35f6					      ENDIF
      0  35f6					      DEFL	_045_L, "3-4#2-|3-#2.3#|4#$.$-#|#@-#-.*-#|#-$2-2*.#|2#-$-*2-#|-2#-$3-#|2-2#2-3#|3-4#2-"
      0  35f6					      START_LEVEL	_045_L
      1  35f6				   LEVEL_START SET	*
      2  35f6		       00 06	   BANK_LEVEL__045_L =	_CURRENT_BANK
      3  35f6				   LEVEL__045_L SUBROUTINE
      4  35f6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35f6
      2  35f6		       33 2d 34 23*	      .byte.b	"3-4#2-|3-#2.3#|4#$.$-#|#@-#-.*-#|#-$2-2*.#|2#-$-*2-#|-2#-$3-#|2-2#2-3#|3-4#2-",0
      0  3644					      END_LEVEL	_045_L
      1  3644		       00 4e	   LEVEL_SIZE__045_L =	* - LEVEL_START
      2  3644				  -	      IF	LEVEL_SIZE__045_L > MAX_LEVEL_SIZE
      3  3644				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__045_L
      4  3644					      ENDIF
      0  3644					      DEFL	_045_R, "3-6#2-|4#4-#2-|#-$-$2#-3#|#-2$-$-$2-#|#-5.#$-#|#-.*#$2.2-#|2#.-$@5#|-6#4-"
      0  3644					      START_LEVEL	_045_R
      1  3644				   LEVEL_START SET	*
      2  3644		       00 06	   BANK_LEVEL__045_R =	_CURRENT_BANK
      3  3644				   LEVEL__045_R SUBROUTINE
      4  3644				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3644
      2  3644		       33 2d 36 23*	      .byte.b	"3-6#2-|4#4-#2-|#-$-$2#-3#|#-2$-$-$2-#|#-5.#$-#|#-.*#$2.2-#|2#.-$@5#|-6#4-",0
      0  368e					      END_LEVEL	_045_R
      1  368e		       00 4a	   LEVEL_SIZE__045_R =	* - LEVEL_START
      2  368e				  -	      IF	LEVEL_SIZE__045_R > MAX_LEVEL_SIZE
      3  368e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__045_R
      4  368e					      ENDIF
      0  368e					      DEFL	_046_L, "10#-|#@3-#3-2#|#-#*$2-2$-#|#-*.$-$3-#|3#.*$-#2-#|2-#.*.-4#|2-#2.-2#3-|2-5#4-"
      0  368e					      START_LEVEL	_046_L
      1  368e				   LEVEL_START SET	*
      2  368e		       00 06	   BANK_LEVEL__046_L =	_CURRENT_BANK
      3  368e				   LEVEL__046_L SUBROUTINE
      4  368e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  368e
      2  368e		       31 30 23 2d*	      .byte.b	"10#-|#@3-#3-2#|#-#*$2-2$-#|#-*.$-$3-#|3#.*$-#2-#|2-#.*.-4#|2-#2.-2#3-|2-5#4-",0
      0  36db					      END_LEVEL	_046_L
      1  36db		       00 4d	   LEVEL_SIZE__046_L =	* - LEVEL_START
      2  36db				  -	      IF	LEVEL_SIZE__046_L > MAX_LEVEL_SIZE
      3  36db				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__046_L
      4  36db					      ENDIF
      0  36db					      DEFL	_046_R, "8#3-|#3-4#3-|#-$2-$@3#-|#2-5$-#-|3#3.*2.2#|2-2#2-$3.#|3-#2-5#|3-4#4-"
      0  36db					      START_LEVEL	_046_R
      1  36db				   LEVEL_START SET	*
      2  36db		       00 06	   BANK_LEVEL__046_R =	_CURRENT_BANK
      3  36db				   LEVEL__046_R SUBROUTINE
      4  36db				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  36db
      2  36db		       38 23 33 2d*	      .byte.b	"8#3-|#3-4#3-|#-$2-$@3#-|#2-5$-#-|3#3.*2.2#|2-2#2-$3.#|3-#2-5#|3-4#4-",0
      0  3720					      END_LEVEL	_046_R
      1  3720		       00 45	   LEVEL_SIZE__046_R =	* - LEVEL_START
      2  3720				  -	      IF	LEVEL_SIZE__046_R > MAX_LEVEL_SIZE
      3  3720				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__046_R
      4  3720					      ENDIF
      0  3720					      DEFL	_047_L, "5-3#5-|3-3#.#5-|2-2#2-.#5-|2-#-$#.6#|3#3-.2#3-#|#-$@2*.$-$#-#|#4-2#-$3-#|8#3-2#|7-5#-"
      0  3720					      START_LEVEL	_047_L
      1  3720				   LEVEL_START SET	*
      2  3720		       00 06	   BANK_LEVEL__047_L =	_CURRENT_BANK
      3  3720				   LEVEL__047_L SUBROUTINE
      4  3720				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3720
      2  3720		       35 2d 33 23*	      .byte.b	"5-3#5-|3-3#.#5-|2-2#2-.#5-|2-#-$#.6#|3#3-.2#3-#|#-$@2*.$-$#-#|#4-2#-$3-#|8#3-2#|7-5#-",0
      0  3776					      END_LEVEL	_047_L
      1  3776		       00 56	   LEVEL_SIZE__047_L =	* - LEVEL_START
      2  3776				  -	      IF	LEVEL_SIZE__047_L > MAX_LEVEL_SIZE
      3  3776				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__047_L
      4  3776					      ENDIF
      0  3776					      DEFL	_047_R, "4-6#|3-2#3-@#|-3#-3$-#|-#.2-#-$-#|2#.*2-$2-#|#2.-2$#-2#|2#2.#-3#-|-#.3-#3-|-6#3-"
      0  3776					      START_LEVEL	_047_R
      1  3776				   LEVEL_START SET	*
      2  3776		       00 06	   BANK_LEVEL__047_R =	_CURRENT_BANK
      3  3776				   LEVEL__047_R SUBROUTINE
      4  3776				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3776
      2  3776		       34 2d 36 23*	      .byte.b	"4-6#|3-2#3-@#|-3#-3$-#|-#.2-#-$-#|2#.*2-$2-#|#2.-2$#-2#|2#2.#-3#-|-#.3-#3-|-6#3-",0
      0  37c7					      END_LEVEL	_047_R
      1  37c7		       00 51	   LEVEL_SIZE__047_R =	* - LEVEL_START
      2  37c7				  -	      IF	LEVEL_SIZE__047_R > MAX_LEVEL_SIZE
      3  37c7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__047_R
      4  37c7					      ENDIF
     64  37c7
     65  37c7
     66  37c7
      0  37c7					      CHECK_BANK_SIZE	"LEVELS3 -- full 2K"
      1  37c7		       07 c7	   .TEMP      =	* - BANK_START
 LEVELS3 -- full 2K (2K) SIZE =  $7c7 , FREE= $39
      2  37c7					      ECHO	"LEVELS3 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  37c7				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  37c7				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  37c7				  -	      ERR
      6  37c7					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS4.asm LEVEL 2 PASS 3
      0  37c7					      include	"BANK_LEVELS4.asm"
      1  37c7							;    Sokoboo - a Sokoban implementation
      2  37c7							;    using a generic tile-based display engine for the Atari 2600
      3  37c7							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  37c7							;
      5  37c7							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  37c7							;
      7  37c7							;    Code related to the generic tile-based display engine was developed by
      8  37c7							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  37c7							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  37c7							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  37c7							;
     12  37c7							;    Code related to music and sound effects uses the TIATracker music player
     13  37c7							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  37c7							;    directory for Apache licensing details.
     15  37c7							;
     16  37c7							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  37c7							;    See the copyright notices in the License directory for a list of level
     18  37c7							;    contributors.
     19  37c7							;
     20  37c7							;    Except where otherwise indicated, this software is released under the
     21  37c7							;    following licensing arrangement...
     22  37c7							;
     23  37c7							;    This program is free software: you can redistribute it and/or modify
     24  37c7							;    it under the terms of the GNU General Public License as published by
     25  37c7							;    the Free Software Foundation, either version 3 of the License, or
     26  37c7							;    (at your option) any later version.
     27  37c7							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  37c7
     29  37c7							;    This program is distributed in the hope that it will be useful,
     30  37c7							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  37c7							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  37c7							;    GNU General Public License for more details.
     33  37c7
     34  37c7							; level definitions
     35  37c7							; Sample level definitions.
     36  37c7							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  37c7							; have as many banks as you like.
     38  37c7
      0  37c7					      NEWBANK	LEVELS4
      1  3f4a ????				      SEG	LEVELS4
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   LEVELS4    SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	LEVELS4
     40  3800
      0  3800					      DEFL	_048_L, "2-7#-|2-#5-2#|3#$2-#2-#|#-$.3-$-#|#.2*2-4#|#+.#-2#3-|2#$3-#3-|-#4-#3-|-6#3-"
      0  3800					      START_LEVEL	_048_L
      1  3800				   LEVEL_START SET	*
      2  3800		       00 07	   BANK_LEVEL__048_L =	_CURRENT_BANK
      3  3800				   LEVEL__048_L SUBROUTINE
      4  3800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3800
      2  3800		       32 2d 37 23*	      .byte.b	"2-7#-|2-#5-2#|3#$2-#2-#|#-$.3-$-#|#.2*2-4#|#+.#-2#3-|2#$3-#3-|-#4-#3-|-6#3-",0
      0  384c					      END_LEVEL	_048_L
      1  384c		       00 4c	   LEVEL_SIZE__048_L =	* - LEVEL_START
      2  384c				  -	      IF	LEVEL_SIZE__048_L > MAX_LEVEL_SIZE
      3  384c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__048_L
      4  384c					      ENDIF
      0  384c					      DEFL	_048_R, "5-5#|2-4#3-#|3#-.$-$-#|#2-*3.3#|#2-*.-4#|2#2$*$3-#|-#@$.4-#|-4#2-3#|4-4#2-"
      0  384c					      START_LEVEL	_048_R
      1  384c				   LEVEL_START SET	*
      2  384c		       00 07	   BANK_LEVEL__048_R =	_CURRENT_BANK
      3  384c				   LEVEL__048_R SUBROUTINE
      4  384c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  384c
      2  384c		       35 2d 35 23*	      .byte.b	"5-5#|2-4#3-#|3#-.$-$-#|#2-*3.3#|#2-*.-4#|2#2$*$3-#|-#@$.4-#|-4#2-3#|4-4#2-",0
      0  3897					      END_LEVEL	_048_R
      1  3897		       00 4b	   LEVEL_SIZE__048_R =	* - LEVEL_START
      2  3897				  -	      IF	LEVEL_SIZE__048_R > MAX_LEVEL_SIZE
      3  3897				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__048_R
      4  3897					      ENDIF
      0  3897					      DEFL	_049_L, "4#7-|#2-4#4-|#2-$2-5#|#-$-#-4.#|2#-2$-.-.2#|-#$-#-*#-#-|-#-@#$-#-#-|-4#4-#-|4-6#-"
      0  3897					      START_LEVEL	_049_L
      1  3897				   LEVEL_START SET	*
      2  3897		       00 07	   BANK_LEVEL__049_L =	_CURRENT_BANK
      3  3897				   LEVEL__049_L SUBROUTINE
      4  3897				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3897
      2  3897		       34 23 37 2d*	      .byte.b	"4#7-|#2-4#4-|#2-$2-5#|#-$-#-4.#|2#-2$-.-.2#|-#$-#-*#-#-|-#-@#$-#-#-|-4#4-#-|4-6#-",0
      0  38e9					      END_LEVEL	_049_L
      1  38e9		       00 52	   LEVEL_SIZE__049_L =	* - LEVEL_START
      2  38e9				  -	      IF	LEVEL_SIZE__049_L > MAX_LEVEL_SIZE
      3  38e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__049_L
      4  38e9					      ENDIF
      0  38e9					      DEFL	_049_R, "8#2-|#6-3#|#-$2#$.*-#|#-$-$2.*+#|#3-#2.$-#|#-2$#-.3#|2#5-#2-|-7#2-"
      0  38e9					      START_LEVEL	_049_R
      1  38e9				   LEVEL_START SET	*
      2  38e9		       00 07	   BANK_LEVEL__049_R =	_CURRENT_BANK
      3  38e9				   LEVEL__049_R SUBROUTINE
      4  38e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  38e9
      2  38e9		       38 23 32 2d*	      .byte.b	"8#2-|#6-3#|#-$2#$.*-#|#-$-$2.*+#|#3-#2.$-#|#-2$#-.3#|2#5-#2-|-7#2-",0
      0  392c					      END_LEVEL	_049_R
      1  392c		       00 43	   LEVEL_SIZE__049_R =	* - LEVEL_START
      2  392c				  -	      IF	LEVEL_SIZE__049_R > MAX_LEVEL_SIZE
      3  392c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__049_R
      4  392c					      ENDIF
     45  392c
      0  392c					      DEFL	_050_L, "4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#"
      0  392c					      START_LEVEL	_050_L
      1  392c				   LEVEL_START SET	*
      2  392c		       00 07	   BANK_LEVEL__050_L =	_CURRENT_BANK
      3  392c				   LEVEL__050_L SUBROUTINE
      4  392c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  392c
      2  392c		       34 2d 35 23*	      .byte.b	"4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#",0
      0  3979					      END_LEVEL	_050_L
      1  3979		       00 4d	   LEVEL_SIZE__050_L =	* - LEVEL_START
      2  3979				  -	      IF	LEVEL_SIZE__050_L > MAX_LEVEL_SIZE
      3  3979				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_L
      4  3979					      ENDIF
      0  3979					      DEFL	_050_R, "8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#"
      0  3979					      START_LEVEL	_050_R
      1  3979				   LEVEL_START SET	*
      2  3979		       00 07	   BANK_LEVEL__050_R =	_CURRENT_BANK
      3  3979				   LEVEL__050_R SUBROUTINE
      4  3979				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3979
      2  3979		       38 23 7c 23*	      .byte.b	"8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#",0
      0  39b2					      END_LEVEL	_050_R
      1  39b2		       00 39	   LEVEL_SIZE__050_R =	* - LEVEL_START
      2  39b2				  -	      IF	LEVEL_SIZE__050_R > MAX_LEVEL_SIZE
      3  39b2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_R
      4  39b2					      ENDIF
      0  39b2					      DEFL	_051_L, "-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#"
      0  39b2					      START_LEVEL	_051_L
      1  39b2				   LEVEL_START SET	*
      2  39b2		       00 07	   BANK_LEVEL__051_L =	_CURRENT_BANK
      3  39b2				   LEVEL__051_L SUBROUTINE
      4  39b2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  39b2
      2  39b2		       2d 36 23 34*	      .byte.b	"-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#",0
      0  3a05					      END_LEVEL	_051_L
      1  3a05		       00 53	   LEVEL_SIZE__051_L =	* - LEVEL_START
      2  3a05				  -	      IF	LEVEL_SIZE__051_L > MAX_LEVEL_SIZE
      3  3a05				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_L
      4  3a05					      ENDIF
      0  3a05					      DEFL	_051_R, "-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-"
      0  3a05					      START_LEVEL	_051_R
      1  3a05				   LEVEL_START SET	*
      2  3a05		       00 07	   BANK_LEVEL__051_R =	_CURRENT_BANK
      3  3a05				   LEVEL__051_R SUBROUTINE
      4  3a05				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a05
      2  3a05		       2d 38 23 2d*	      .byte.b	"-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-",0
      0  3a56					      END_LEVEL	_051_R
      1  3a56		       00 51	   LEVEL_SIZE__051_R =	* - LEVEL_START
      2  3a56				  -	      IF	LEVEL_SIZE__051_R > MAX_LEVEL_SIZE
      3  3a56				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_R
      4  3a56					      ENDIF
      0  3a56					      DEFL	_052_L, "5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-"
      0  3a56					      START_LEVEL	_052_L
      1  3a56				   LEVEL_START SET	*
      2  3a56		       00 07	   BANK_LEVEL__052_L =	_CURRENT_BANK
      3  3a56				   LEVEL__052_L SUBROUTINE
      4  3a56				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a56
      2  3a56		       35 23 36 2d*	      .byte.b	"5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-",0
      0  3a90					      END_LEVEL	_052_L
      1  3a90		       00 3a	   LEVEL_SIZE__052_L =	* - LEVEL_START
      2  3a90				  -	      IF	LEVEL_SIZE__052_L > MAX_LEVEL_SIZE
      3  3a90				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_L
      4  3a90					      ENDIF
      0  3a90					      DEFL	_052_R, "2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-"
      0  3a90					      START_LEVEL	_052_R
      1  3a90				   LEVEL_START SET	*
      2  3a90		       00 07	   BANK_LEVEL__052_R =	_CURRENT_BANK
      3  3a90				   LEVEL__052_R SUBROUTINE
      4  3a90				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a90
      2  3a90		       32 2d 37 23*	      .byte.b	"2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-",0
      0  3ad8					      END_LEVEL	_052_R
      1  3ad8		       00 48	   LEVEL_SIZE__052_R =	* - LEVEL_START
      2  3ad8				  -	      IF	LEVEL_SIZE__052_R > MAX_LEVEL_SIZE
      3  3ad8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_R
      4  3ad8					      ENDIF
      0  3ad8					      DEFL	_053_L, "6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-"
      0  3ad8					      START_LEVEL	_053_L
      1  3ad8				   LEVEL_START SET	*
      2  3ad8		       00 07	   BANK_LEVEL__053_L =	_CURRENT_BANK
      3  3ad8				   LEVEL__053_L SUBROUTINE
      4  3ad8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ad8
      2  3ad8		       36 23 36 2d*	      .byte.b	"6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-",0
      0  3b2d					      END_LEVEL	_053_L
      1  3b2d		       00 55	   LEVEL_SIZE__053_L =	* - LEVEL_START
      2  3b2d				  -	      IF	LEVEL_SIZE__053_L > MAX_LEVEL_SIZE
      3  3b2d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_L
      4  3b2d					      ENDIF
      0  3b2d					      DEFL	_053_R, "5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-"
      0  3b2d					      START_LEVEL	_053_R
      1  3b2d				   LEVEL_START SET	*
      2  3b2d		       00 07	   BANK_LEVEL__053_R =	_CURRENT_BANK
      3  3b2d				   LEVEL__053_R SUBROUTINE
      4  3b2d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b2d
      2  3b2d		       35 2d 35 23*	      .byte.b	"5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-",0
      0  3b7a					      END_LEVEL	_053_R
      1  3b7a		       00 4d	   LEVEL_SIZE__053_R =	* - LEVEL_START
      2  3b7a				  -	      IF	LEVEL_SIZE__053_R > MAX_LEVEL_SIZE
      3  3b7a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_R
      4  3b7a					      ENDIF
      0  3b7a					      DEFL	_054_L, "-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-"
      0  3b7a					      START_LEVEL	_054_L
      1  3b7a				   LEVEL_START SET	*
      2  3b7a		       00 07	   BANK_LEVEL__054_L =	_CURRENT_BANK
      3  3b7a				   LEVEL__054_L SUBROUTINE
      4  3b7a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b7a
      2  3b7a		       2d 38 23 32*	      .byte.b	"-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-",0
      0  3bc6					      END_LEVEL	_054_L
      1  3bc6		       00 4c	   LEVEL_SIZE__054_L =	* - LEVEL_START
      2  3bc6				  -	      IF	LEVEL_SIZE__054_L > MAX_LEVEL_SIZE
      3  3bc6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_L
      4  3bc6					      ENDIF
      0  3bc6					      DEFL	_054_R, "2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-"
      0  3bc6					      START_LEVEL	_054_R
      1  3bc6				   LEVEL_START SET	*
      2  3bc6		       00 07	   BANK_LEVEL__054_R =	_CURRENT_BANK
      3  3bc6				   LEVEL__054_R SUBROUTINE
      4  3bc6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3bc6
      2  3bc6		       32 2d 34 23*	      .byte.b	"2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-",0
      0  3c0f					      END_LEVEL	_054_R
      1  3c0f		       00 49	   LEVEL_SIZE__054_R =	* - LEVEL_START
      2  3c0f				  -	      IF	LEVEL_SIZE__054_R > MAX_LEVEL_SIZE
      3  3c0f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_R
      4  3c0f					      ENDIF
      0  3c0f					      DEFL	_055_L, "2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-"
      0  3c0f					      START_LEVEL	_055_L
      1  3c0f				   LEVEL_START SET	*
      2  3c0f		       00 07	   BANK_LEVEL__055_L =	_CURRENT_BANK
      3  3c0f				   LEVEL__055_L SUBROUTINE
      4  3c0f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c0f
      2  3c0f		       32 2d 34 23*	      .byte.b	"2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-",0
      0  3c69					      END_LEVEL	_055_L
      1  3c69		       00 5a	   LEVEL_SIZE__055_L =	* - LEVEL_START
      2  3c69				  -	      IF	LEVEL_SIZE__055_L > MAX_LEVEL_SIZE
      3  3c69				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_L
      4  3c69					      ENDIF
      0  3c69					      DEFL	_055_R, "5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-"
      0  3c69					      START_LEVEL	_055_R
      1  3c69				   LEVEL_START SET	*
      2  3c69		       00 07	   BANK_LEVEL__055_R =	_CURRENT_BANK
      3  3c69				   LEVEL__055_R SUBROUTINE
      4  3c69				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c69
      2  3c69		       35 2d 34 23*	      .byte.b	"5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-",0
      0  3cbe					      END_LEVEL	_055_R
      1  3cbe		       00 55	   LEVEL_SIZE__055_R =	* - LEVEL_START
      2  3cbe				  -	      IF	LEVEL_SIZE__055_R > MAX_LEVEL_SIZE
      3  3cbe				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_R
      4  3cbe					      ENDIF
      0  3cbe					      DEFL	_056_L, "6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#"
      0  3cbe					      START_LEVEL	_056_L
      1  3cbe				   LEVEL_START SET	*
      2  3cbe		       00 07	   BANK_LEVEL__056_L =	_CURRENT_BANK
      3  3cbe				   LEVEL__056_L SUBROUTINE
      4  3cbe				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3cbe
      2  3cbe		       36 2d 35 23*	      .byte.b	"6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#",0
      0  3d18					      END_LEVEL	_056_L
      1  3d18		       00 5a	   LEVEL_SIZE__056_L =	* - LEVEL_START
      2  3d18				  -	      IF	LEVEL_SIZE__056_L > MAX_LEVEL_SIZE
      3  3d18				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_L
      4  3d18					      ENDIF
      0  3d18					      DEFL	_056_R, "-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-"
      0  3d18					      START_LEVEL	_056_R
      1  3d18				   LEVEL_START SET	*
      2  3d18		       00 07	   BANK_LEVEL__056_R =	_CURRENT_BANK
      3  3d18				   LEVEL__056_R SUBROUTINE
      4  3d18				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d18
      2  3d18		       2d 34 23 2d*	      .byte.b	"-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-",0
      0  3d73					      END_LEVEL	_056_R
      1  3d73		       00 5b	   LEVEL_SIZE__056_R =	* - LEVEL_START
      2  3d73					      IF	LEVEL_SIZE__056_R > MAX_LEVEL_SIZE
      3  3d73				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_R
      4  3d73					      ENDIF
      0  3d73					      DEFL	_057_L, "5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-"
      0  3d73					      START_LEVEL	_057_L
      1  3d73				   LEVEL_START SET	*
      2  3d73		       00 07	   BANK_LEVEL__057_L =	_CURRENT_BANK
      3  3d73				   LEVEL__057_L SUBROUTINE
      4  3d73				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d73
      2  3d73		       35 2d 36 23*	      .byte.b	"5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-",0
      0  3dc9					      END_LEVEL	_057_L
      1  3dc9		       00 56	   LEVEL_SIZE__057_L =	* - LEVEL_START
      2  3dc9				  -	      IF	LEVEL_SIZE__057_L > MAX_LEVEL_SIZE
      3  3dc9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_L
      4  3dc9					      ENDIF
      0  3dc9					      DEFL	_057_R, "5#4-|#3-3#2-|#+2.2-3#|#.#*$-$-#|#.#.-#$-#|#-$2-$2-#|2#$2#3-#|-#5-2#|-7#-"
      0  3dc9					      START_LEVEL	_057_R
      1  3dc9				   LEVEL_START SET	*
      2  3dc9		       00 07	   BANK_LEVEL__057_R =	_CURRENT_BANK
      3  3dc9				   LEVEL__057_R SUBROUTINE
      4  3dc9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3dc9
      2  3dc9		       35 23 34 2d*	      .byte.b	"5#4-|#3-3#2-|#+2.2-3#|#.#*$-$-#|#.#.-#$-#|#-$2-$2-#|2#$2#3-#|-#5-2#|-7#-",0
      0  3e12					      END_LEVEL	_057_R
      1  3e12		       00 49	   LEVEL_SIZE__057_R =	* - LEVEL_START
      2  3e12				  -	      IF	LEVEL_SIZE__057_R > MAX_LEVEL_SIZE
      3  3e12				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_R
      4  3e12					      ENDIF
      0  3e12					      DEFL	_058_L, "-6#4-|-#-3.5#|-#-#.*2#2-#|2#-.*$4-#|#-2$*-$-$-#|#@2-2#4-#|7#3-#|6-5#"
      0  3e12					      START_LEVEL	_058_L
      1  3e12				   LEVEL_START SET	*
      2  3e12		       00 07	   BANK_LEVEL__058_L =	_CURRENT_BANK
      3  3e12				   LEVEL__058_L SUBROUTINE
      4  3e12				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3e12
      2  3e12		       2d 36 23 34*	      .byte.b	"-6#4-|-#-3.5#|-#-#.*2#2-#|2#-.*$4-#|#-2$*-$-$-#|#@2-2#4-#|7#3-#|6-5#",0
      0  3e57					      END_LEVEL	_058_L
      1  3e57		       00 45	   LEVEL_SIZE__058_L =	* - LEVEL_START
      2  3e57				  -	      IF	LEVEL_SIZE__058_L > MAX_LEVEL_SIZE
      3  3e57				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__058_L
      4  3e57					      ENDIF
      0  3e57					      DEFL	_058_R, "4-5#-|3-2#3-#-|4#-.#$#-|#-$2-.#-#-|#@-3*.-2#|#-$.2-*2-#|3#*$#3-#|2-#4-3#|2-6#2-"
      0  3e57					      START_LEVEL	_058_R
      1  3e57				   LEVEL_START SET	*
      2  3e57		       00 07	   BANK_LEVEL__058_R =	_CURRENT_BANK
      3  3e57				   LEVEL__058_R SUBROUTINE
      4  3e57				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3e57
      2  3e57		       34 2d 35 23*	      .byte.b	"4-5#-|3-2#3-#-|4#-.#$#-|#-$2-.#-#-|#@-3*.-2#|#-$.2-*2-#|3#*$#3-#|2-#4-3#|2-6#2-",0
      0  3ea7					      END_LEVEL	_058_R
      1  3ea7		       00 50	   LEVEL_SIZE__058_R =	* - LEVEL_START
      2  3ea7				  -	      IF	LEVEL_SIZE__058_R > MAX_LEVEL_SIZE
      3  3ea7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__058_R
      4  3ea7					      ENDIF
      0  3ea7					      DEFL	_059_L, "6#5-|#4-#5-|#-$#-5#-|#4-.-$@#-|#-#-2*-#$2#|#-$.*-$3-#|2#$#.-2#2-#|-#-3.2#2-#|-10#"
      0  3ea7					      START_LEVEL	_059_L
      1  3ea7				   LEVEL_START SET	*
      2  3ea7		       00 07	   BANK_LEVEL__059_L =	_CURRENT_BANK
      3  3ea7				   LEVEL__059_L SUBROUTINE
      4  3ea7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ea7
      2  3ea7		       36 23 35 2d*	      .byte.b	"6#5-|#4-#5-|#-$#-5#-|#4-.-$@#-|#-#-2*-#$2#|#-$.*-$3-#|2#$#.-2#2-#|-#-3.2#2-#|-10#",0
      0  3ef9					      END_LEVEL	_059_L
      1  3ef9		       00 52	   LEVEL_SIZE__059_L =	* - LEVEL_START
      2  3ef9				  -	      IF	LEVEL_SIZE__059_L > MAX_LEVEL_SIZE
      3  3ef9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__059_L
      4  3ef9					      ENDIF
      0  3ef9					      DEFL	_059_R, "7-3#-|8#.#-|#4-#-2.2#|#-#-2$*.$-#|#5-2.#-#|2#2-2#-2#-#|#2-$-2$2#-#|#3-2#3-@#|11#"
      0  3ef9					      START_LEVEL	_059_R
      1  3ef9				   LEVEL_START SET	*
      2  3ef9		       00 07	   BANK_LEVEL__059_R =	_CURRENT_BANK
      3  3ef9				   LEVEL__059_R SUBROUTINE
      4  3ef9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ef9
      2  3ef9		       37 2d 33 23*	      .byte.b	"7-3#-|8#.#-|#4-#-2.2#|#-#-2$*.$-#|#5-2.#-#|2#2-2#-2#-#|#2-$-2$2#-#|#3-2#3-@#|11#",0
      0  3f4a					      END_LEVEL	_059_R
      1  3f4a		       00 51	   LEVEL_SIZE__059_R =	* - LEVEL_START
      2  3f4a				  -	      IF	LEVEL_SIZE__059_R > MAX_LEVEL_SIZE
      3  3f4a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__059_R
      4  3f4a					      ENDIF
     66  3f4a
      0  3f4a					      CHECK_BANK_SIZE	"LEVELS4 -- full 2K"
      1  3f4a		       07 4a	   .TEMP      =	* - BANK_START
 LEVELS4 -- full 2K (2K) SIZE =  $74a , FREE= $b6
      2  3f4a					      ECHO	"LEVELS4 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3f4a				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3f4a				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3f4a				  -	      ERR
      6  3f4a					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS5.asm LEVEL 2 PASS 3
      0  3f4a					      include	"BANK_LEVELS5.asm"
      1  3f4a							;    Sokoboo - a Sokoban implementation
      2  3f4a							;    using a generic tile-based display engine for the Atari 2600
      3  3f4a							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  3f4a							;
      5  3f4a							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  3f4a							;
      7  3f4a							;    Code related to the generic tile-based display engine was developed by
      8  3f4a							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  3f4a							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  3f4a							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  3f4a							;
     12  3f4a							;    Code related to music and sound effects uses the TIATracker music player
     13  3f4a							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  3f4a							;    directory for Apache licensing details.
     15  3f4a							;
     16  3f4a							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  3f4a							;    See the copyright notices in the License directory for a list of level
     18  3f4a							;    contributors.
     19  3f4a							;
     20  3f4a							;    Except where otherwise indicated, this software is released under the
     21  3f4a							;    following licensing arrangement...
     22  3f4a							;
     23  3f4a							;    This program is free software: you can redistribute it and/or modify
     24  3f4a							;    it under the terms of the GNU General Public License as published by
     25  3f4a							;    the Free Software Foundation, either version 3 of the License, or
     26  3f4a							;    (at your option) any later version.
     27  3f4a							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  3f4a
     29  3f4a							;    This program is distributed in the hope that it will be useful,
     30  3f4a							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  3f4a							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  3f4a							;    GNU General Public License for more details.
     33  3f4a
     34  3f4a							; level definitions
     35  3f4a							; Sample level definitions.
     36  3f4a							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  3f4a							; have as many banks as you like.
     38  3f4a
      0  3f4a					      NEWBANK	LEVELS5
      1  4675 ????				      SEG	LEVELS5
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   LEVELS5    SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	LEVELS5
     40  4000
      0  4000					      DEFL	_060_R, "3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#"
      0  4000					      START_LEVEL	_060_R
      1  4000				   LEVEL_START SET	*
      2  4000		       00 08	   BANK_LEVEL__060_R =	_CURRENT_BANK
      3  4000				   LEVEL__060_R SUBROUTINE
      4  4000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4000
      2  4000		       33 2d 36 23*	      .byte.b	"3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#",0
      0  4048					      END_LEVEL	_060_R
      1  4048		       00 48	   LEVEL_SIZE__060_R =	* - LEVEL_START
      2  4048				  -	      IF	LEVEL_SIZE__060_R > MAX_LEVEL_SIZE
      3  4048				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__060_R
      4  4048					      ENDIF
      0  4048					      DEFL	_061_L, "10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#"
      0  4048					      START_LEVEL	_061_L
      1  4048				   LEVEL_START SET	*
      2  4048		       00 08	   BANK_LEVEL__061_L =	_CURRENT_BANK
      3  4048				   LEVEL__061_L SUBROUTINE
      4  4048				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4048
      2  4048		       31 30 23 2d*	      .byte.b	"10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#",0
      0  409c					      END_LEVEL	_061_L
      1  409c		       00 54	   LEVEL_SIZE__061_L =	* - LEVEL_START
      2  409c				  -	      IF	LEVEL_SIZE__061_L > MAX_LEVEL_SIZE
      3  409c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_L
      4  409c					      ENDIF
      0  409c					      DEFL	_061_R, "4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#"
      0  409c					      START_LEVEL	_061_R
      1  409c				   LEVEL_START SET	*
      2  409c		       00 08	   BANK_LEVEL__061_R =	_CURRENT_BANK
      3  409c				   LEVEL__061_R SUBROUTINE
      4  409c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  409c
      2  409c		       34 2d 35 23*	      .byte.b	"4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#",0
      0  40e5					      END_LEVEL	_061_R
      1  40e5		       00 49	   LEVEL_SIZE__061_R =	* - LEVEL_START
      2  40e5				  -	      IF	LEVEL_SIZE__061_R > MAX_LEVEL_SIZE
      3  40e5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_R
      4  40e5					      ENDIF
      0  40e5					      DEFL	_062_L, "-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#"
      0  40e5					      START_LEVEL	_062_L
      1  40e5				   LEVEL_START SET	*
      2  40e5		       00 08	   BANK_LEVEL__062_L =	_CURRENT_BANK
      3  40e5				   LEVEL__062_L SUBROUTINE
      4  40e5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  40e5
      2  40e5		       2d 35 23 36*	      .byte.b	"-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#",0
      0  413c					      END_LEVEL	_062_L
      1  413c		       00 57	   LEVEL_SIZE__062_L =	* - LEVEL_START
      2  413c				  -	      IF	LEVEL_SIZE__062_L > MAX_LEVEL_SIZE
      3  413c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_L
      4  413c					      ENDIF
      0  413c					      DEFL	_062_R, "5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-"
      0  413c					      START_LEVEL	_062_R
      1  413c				   LEVEL_START SET	*
      2  413c		       00 08	   BANK_LEVEL__062_R =	_CURRENT_BANK
      3  413c				   LEVEL__062_R SUBROUTINE
      4  413c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  413c
      2  413c		       35 2d 35 23*	      .byte.b	"5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-",0
      0  4188					      END_LEVEL	_062_R
      1  4188		       00 4c	   LEVEL_SIZE__062_R =	* - LEVEL_START
      2  4188				  -	      IF	LEVEL_SIZE__062_R > MAX_LEVEL_SIZE
      3  4188				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_R
      4  4188					      ENDIF
      0  4188					      DEFL	_063_L, "2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#"
      0  4188					      START_LEVEL	_063_L
      1  4188				   LEVEL_START SET	*
      2  4188		       00 08	   BANK_LEVEL__063_L =	_CURRENT_BANK
      3  4188				   LEVEL__063_L SUBROUTINE
      4  4188				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4188
      2  4188		       32 2d 35 23*	      .byte.b	"2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#",0
      0  41d8					      END_LEVEL	_063_L
      1  41d8		       00 50	   LEVEL_SIZE__063_L =	* - LEVEL_START
      2  41d8				  -	      IF	LEVEL_SIZE__063_L > MAX_LEVEL_SIZE
      3  41d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_L
      4  41d8					      ENDIF
      0  41d8					      DEFL	_063_R, "2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-"
      0  41d8					      START_LEVEL	_063_R
      1  41d8				   LEVEL_START SET	*
      2  41d8		       00 08	   BANK_LEVEL__063_R =	_CURRENT_BANK
      3  41d8				   LEVEL__063_R SUBROUTINE
      4  41d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  41d8
      2  41d8		       32 2d 36 23*	      .byte.b	"2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-",0
      0  422a					      END_LEVEL	_063_R
      1  422a		       00 52	   LEVEL_SIZE__063_R =	* - LEVEL_START
      2  422a				  -	      IF	LEVEL_SIZE__063_R > MAX_LEVEL_SIZE
      3  422a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_R
      4  422a					      ENDIF
      0  422a					      DEFL	_064_L, "-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-"
      0  422a					      START_LEVEL	_064_L
      1  422a				   LEVEL_START SET	*
      2  422a		       00 08	   BANK_LEVEL__064_L =	_CURRENT_BANK
      3  422a				   LEVEL__064_L SUBROUTINE
      4  422a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  422a
      2  422a		       2d 38 23 33*	      .byte.b	"-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-",0
      0  4285					      END_LEVEL	_064_L
      1  4285		       00 5b	   LEVEL_SIZE__064_L =	* - LEVEL_START
      2  4285				  -	      IF	LEVEL_SIZE__064_L > MAX_LEVEL_SIZE
      3  4285				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_L
      4  4285					      ENDIF
      0  4285					      DEFL	_064_R, "4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-"
      0  4285					      START_LEVEL	_064_R
      1  4285				   LEVEL_START SET	*
      2  4285		       00 08	   BANK_LEVEL__064_R =	_CURRENT_BANK
      3  4285				   LEVEL__064_R SUBROUTINE
      4  4285				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4285
      2  4285		       34 23 2d 36*	      .byte.b	"4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-",0
      0  42d1					      END_LEVEL	_064_R
      1  42d1		       00 4c	   LEVEL_SIZE__064_R =	* - LEVEL_START
      2  42d1				  -	      IF	LEVEL_SIZE__064_R > MAX_LEVEL_SIZE
      3  42d1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_R
      4  42d1					      ENDIF
      0  42d1					      DEFL	_065_L, "2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-"
      0  42d1					      START_LEVEL	_065_L
      1  42d1				   LEVEL_START SET	*
      2  42d1		       00 08	   BANK_LEVEL__065_L =	_CURRENT_BANK
      3  42d1				   LEVEL__065_L SUBROUTINE
      4  42d1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  42d1
      2  42d1		       32 2d 35 23*	      .byte.b	"2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-",0
      0  4329					      END_LEVEL	_065_L
      1  4329		       00 58	   LEVEL_SIZE__065_L =	* - LEVEL_START
      2  4329				  -	      IF	LEVEL_SIZE__065_L > MAX_LEVEL_SIZE
      3  4329				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_L
      4  4329					      ENDIF
      0  4329					      DEFL	_065_R, "3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#"
      0  4329					      START_LEVEL	_065_R
      1  4329				   LEVEL_START SET	*
      2  4329		       00 08	   BANK_LEVEL__065_R =	_CURRENT_BANK
      3  4329				   LEVEL__065_R SUBROUTINE
      4  4329				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4329
      2  4329		       33 2d 35 23*	      .byte.b	"3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#",0
      0  4371					      END_LEVEL	_065_R
      1  4371		       00 48	   LEVEL_SIZE__065_R =	* - LEVEL_START
      2  4371				  -	      IF	LEVEL_SIZE__065_R > MAX_LEVEL_SIZE
      3  4371				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_R
      4  4371					      ENDIF
      0  4371					      DEFL	_066_L, "10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-"
      0  4371					      START_LEVEL	_066_L
      1  4371				   LEVEL_START SET	*
      2  4371		       00 08	   BANK_LEVEL__066_L =	_CURRENT_BANK
      3  4371				   LEVEL__066_L SUBROUTINE
      4  4371				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4371
      2  4371		       31 30 23 33*	      .byte.b	"10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-",0
      0  43cb					      END_LEVEL	_066_L
      1  43cb		       00 5a	   LEVEL_SIZE__066_L =	* - LEVEL_START
      2  43cb				  -	      IF	LEVEL_SIZE__066_L > MAX_LEVEL_SIZE
      3  43cb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_L
      4  43cb					      ENDIF
      0  43cb					      DEFL	_066_R, "2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#"
      0  43cb					      START_LEVEL	_066_R
      1  43cb				   LEVEL_START SET	*
      2  43cb		       00 08	   BANK_LEVEL__066_R =	_CURRENT_BANK
      3  43cb				   LEVEL__066_R SUBROUTINE
      4  43cb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  43cb
      2  43cb		       32 2d 35 23*	      .byte.b	"2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#",0
      0  4421					      END_LEVEL	_066_R
      1  4421		       00 56	   LEVEL_SIZE__066_R =	* - LEVEL_START
      2  4421				  -	      IF	LEVEL_SIZE__066_R > MAX_LEVEL_SIZE
      3  4421				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_R
      4  4421					      ENDIF
      0  4421					      DEFL	_067_L, "8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#"
      0  4421					      START_LEVEL	_067_L
      1  4421				   LEVEL_START SET	*
      2  4421		       00 08	   BANK_LEVEL__067_L =	_CURRENT_BANK
      3  4421				   LEVEL__067_L SUBROUTINE
      4  4421				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4421
      2  4421		       38 23 33 2d*	      .byte.b	"8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#",0
      0  446e					      END_LEVEL	_067_L
      1  446e		       00 4d	   LEVEL_SIZE__067_L =	* - LEVEL_START
      2  446e				  -	      IF	LEVEL_SIZE__067_L > MAX_LEVEL_SIZE
      3  446e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_L
      4  446e					      ENDIF
      0  446e					      DEFL	_067_R, "7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-"
      0  446e					      START_LEVEL	_067_R
      1  446e				   LEVEL_START SET	*
      2  446e		       00 08	   BANK_LEVEL__067_R =	_CURRENT_BANK
      3  446e				   LEVEL__067_R SUBROUTINE
      4  446e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  446e
      2  446e		       37 23 32 2d*	      .byte.b	"7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-",0
      0  44d3					      END_LEVEL	_067_R
      1  44d3		       00 65	   LEVEL_SIZE__067_R =	* - LEVEL_START
      2  44d3					      IF	LEVEL_SIZE__067_R > MAX_LEVEL_SIZE
      3  44d3				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_R
      4  44d3					      ENDIF
      0  44d3					      DEFL	_068_L, "10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-"
      0  44d3					      START_LEVEL	_068_L
      1  44d3				   LEVEL_START SET	*
      2  44d3		       00 08	   BANK_LEVEL__068_L =	_CURRENT_BANK
      3  44d3				   LEVEL__068_L SUBROUTINE
      4  44d3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  44d3
      2  44d3		       31 30 23 7c*	      .byte.b	"10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-",0
      0  4527					      END_LEVEL	_068_L
      1  4527		       00 54	   LEVEL_SIZE__068_L =	* - LEVEL_START
      2  4527				  -	      IF	LEVEL_SIZE__068_L > MAX_LEVEL_SIZE
      3  4527				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_L
      4  4527					      ENDIF
      0  4527					      DEFL	_068_R, "5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-"
      0  4527					      START_LEVEL	_068_R
      1  4527				   LEVEL_START SET	*
      2  4527		       00 08	   BANK_LEVEL__068_R =	_CURRENT_BANK
      3  4527				   LEVEL__068_R SUBROUTINE
      4  4527				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4527
      2  4527		       35 2d 35 23*	      .byte.b	"5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-",0
      0  457d					      END_LEVEL	_068_R
      1  457d		       00 56	   LEVEL_SIZE__068_R =	* - LEVEL_START
      2  457d				  -	      IF	LEVEL_SIZE__068_R > MAX_LEVEL_SIZE
      3  457d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_R
      4  457d					      ENDIF
      0  457d					      DEFL	_069_L, "-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#"
      0  457d					      START_LEVEL	_069_L
      1  457d				   LEVEL_START SET	*
      2  457d		       00 08	   BANK_LEVEL__069_L =	_CURRENT_BANK
      3  457d				   LEVEL__069_L SUBROUTINE
      4  457d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  457d
      2  457d		       2d 36 23 33*	      .byte.b	"-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#",0
      0  45cb					      END_LEVEL	_069_L
      1  45cb		       00 4e	   LEVEL_SIZE__069_L =	* - LEVEL_START
      2  45cb				  -	      IF	LEVEL_SIZE__069_L > MAX_LEVEL_SIZE
      3  45cb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_L
      4  45cb					      ENDIF
      0  45cb					      DEFL	_069_R, "2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-"
      0  45cb					      START_LEVEL	_069_R
      1  45cb				   LEVEL_START SET	*
      2  45cb		       00 08	   BANK_LEVEL__069_R =	_CURRENT_BANK
      3  45cb				   LEVEL__069_R SUBROUTINE
      4  45cb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  45cb
      2  45cb		       32 2d 35 23*	      .byte.b	"2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-",0
      0  4619					      END_LEVEL	_069_R
      1  4619		       00 4e	   LEVEL_SIZE__069_R =	* - LEVEL_START
      2  4619				  -	      IF	LEVEL_SIZE__069_R > MAX_LEVEL_SIZE
      3  4619				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_R
      4  4619					      ENDIF
     60  4619
      0  4619					      DEFL	_122_Maya, "14#|4#3-3#2-2#|#-$-$2-2#3-2#|#.2-$4#$2-2#|#.*2-$3-$-3#|#*.#$*.$-#2$-#|#6.*-#-@-#|2#4-8#|14#"
      0  4619					      START_LEVEL	_122_Maya
      1  4619				   LEVEL_START SET	*
      2  4619		       00 08	   BANK_LEVEL__122_Maya =	_CURRENT_BANK
      3  4619				   LEVEL__122_Maya SUBROUTINE
      4  4619				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4619
      2  4619		       31 34 23 7c*	      .byte.b	"14#|4#3-3#2-2#|#-$-$2-2#3-2#|#.2-$4#$2-2#|#.*2-$3-$-3#|#*.#$*.$-#2$-#|#6.*-#-@-#|2#4-8#|14#",0
      0  4675					      END_LEVEL	_122_Maya
      1  4675		       00 5c	   LEVEL_SIZE__122_Maya =	* - LEVEL_START
      2  4675				  -	      IF	LEVEL_SIZE__122_Maya > MAX_LEVEL_SIZE
      3  4675				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__122_Maya
      4  4675					      ENDIF
     62  4675
      0  4675					      CHECK_BANK_SIZE	"LEVELS5 -- full 2K"
      1  4675		       06 75	   .TEMP      =	* - BANK_START
 LEVELS5 -- full 2K (2K) SIZE =  $675 , FREE= $18b
      2  4675					      ECHO	"LEVELS5 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4675				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4675				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4675				  -	      ERR
      6  4675					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS6.asm LEVEL 2 PASS 3
      0  4675					      include	"BANK_LEVELS6.asm"
      1  4675							;    Sokoboo - a Sokoban implementation
      2  4675							;    using a generic tile-based display engine for the Atari 2600
      3  4675							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  4675							;
      5  4675							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  4675							;
      7  4675							;    Code related to the generic tile-based display engine was developed by
      8  4675							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  4675							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  4675							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  4675							;
     12  4675							;    Code related to music and sound effects uses the TIATracker music player
     13  4675							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  4675							;    directory for Apache licensing details.
     15  4675							;
     16  4675							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  4675							;    See the copyright notices in the License directory for a list of level
     18  4675							;    contributors.
     19  4675							;
     20  4675							;    Except where otherwise indicated, this software is released under the
     21  4675							;    following licensing arrangement...
     22  4675							;
     23  4675							;    This program is free software: you can redistribute it and/or modify
     24  4675							;    it under the terms of the GNU General Public License as published by
     25  4675							;    the Free Software Foundation, either version 3 of the License, or
     26  4675							;    (at your option) any later version.
     27  4675							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  4675
     29  4675							;    This program is distributed in the hope that it will be useful,
     30  4675							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  4675							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  4675							;    GNU General Public License for more details.
     33  4675
     34  4675							; level definitions
     35  4675							; Sample level definitions.
     36  4675							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  4675							; have as many banks as you like.
     38  4675
      0  4675					      NEWBANK	LEVELS6
      1  4d9f ????				      SEG	LEVELS6
      2  4800					      ORG	ORIGIN
      3  4800					      RORG	$F000
      4  4800				   BANK_START SET	*
      5  4800				   LEVELS6    SET	ORIGIN / 2048
      6  4800				   ORIGIN     SET	ORIGIN + 2048
      7  4800				   _CURRENT_BANK SET	LEVELS6
     40  4800
     41  4800
     42  4800							; Level definitions
     43  4800
     44  4800							; "sokhard" collection
     45  4800
      0  4800					      START_LEVEL	_102_Natalie
      1  4800				   LEVEL_START SET	*
      2  4800		       00 09	   BANK_LEVEL__102_Natalie =	_CURRENT_BANK
      3  4800				   LEVEL__102_Natalie SUBROUTINE
      4  4800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4800
     47  4800		       31 31 23 7c*	      .byte.b	"11#|2#2-#@4.#|2#3-2$.2*#|2#-$2-2$#.#|#2-$#-#2-.#|#2-$-#-2#-#|#9-#|11#",0
      0  4846					      END_LEVEL	_102_Natalie
      1  4846		       00 46	   LEVEL_SIZE__102_Natalie =	* - LEVEL_START
      2  4846				  -	      IF	LEVEL_SIZE__102_Natalie > MAX_LEVEL_SIZE
      3  4846				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Natalie
      4  4846					      ENDIF
     49  4846
      0  4846					      START_LEVEL	_102_Mirabel
      1  4846				   LEVEL_START SET	*
      2  4846		       00 09	   BANK_LEVEL__102_Mirabel =	_CURRENT_BANK
      3  4846				   LEVEL__102_Mirabel SUBROUTINE
      4  4846				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4846
     51  4846		       31 31 23 7c*	      .byte.b	"11#|6#3-2#|2#2-2#$2-2#|2#2-#-2$-2#|#7-3#|#.-#$-#-3#|#.#.-#2-$-#|#3.#-2$#@#|#-2.4-$-#|#2-8#|11#",0
      0  48a5					      END_LEVEL	_102_Mirabel
      1  48a5		       00 5f	   LEVEL_SIZE__102_Mirabel =	* - LEVEL_START
      2  48a5				  -	      IF	LEVEL_SIZE__102_Mirabel > MAX_LEVEL_SIZE
      3  48a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Mirabel
      4  48a5					      ENDIF
     53  48a5
      0  48a5					      START_LEVEL	_102_Oralia
      1  48a5				   LEVEL_START SET	*
      2  48a5		       00 09	   BANK_LEVEL__102_Oralia =	_CURRENT_BANK
      3  48a5				   LEVEL__102_Oralia SUBROUTINE
      4  48a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  48a5
     55  48a5		       39 23 7c 23*	      .byte.b	"9#|#2.$.#2-#|#4.2*-#|#-$.2#2-#|2#-$2-$-#|4#$-$-#|#-$3-$-#|#5-#@#|9#",0
      0  48e9					      END_LEVEL	_102_Oralia
      1  48e9		       00 44	   LEVEL_SIZE__102_Oralia =	* - LEVEL_START
      2  48e9				  -	      IF	LEVEL_SIZE__102_Oralia > MAX_LEVEL_SIZE
      3  48e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Oralia
      4  48e9					      ENDIF
     57  48e9
     58  48e9
     59  48e9							;---------------------------------------------------------------------------------------------------
     60  48e9							; IMAGE IS ABOVE DEFINITION
     61  48e9
     62  48e9							;  ###########
     63  48e9							;  #  #      #
     64  48e9							;  # $# $ $$ #
     65  48e9							;  #  ##$#$  #
     66  48e9							;  #  $    #@#
     67  48e9							;  # $## #  ##
     68  48e9							;  ##	# .## #
     69  48e9							;  ##$ #.*. ##
     70  48e9							;  # ..*. *. #
     71  48e9							;  # # .. #  #
     72  48e9							;  ###########
     73  48e9
      0  48e9					      START_LEVEL	_102_Raven
      1  48e9				   LEVEL_START SET	*
      2  48e9		       00 09	   BANK_LEVEL__102_Raven =	_CURRENT_BANK
      3  48e9				   LEVEL__102_Raven SUBROUTINE
      4  48e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  48e9
     75  48e9		       31 31 23 7c*	      .byte.b	"11#|#2-#6-#|#-$#-$-2$-#|#2-2#$#$2-#|#2-$4-#@#|#-$2#-#2-2#|2#2-#-.2#-#|2#$-#.*.-2#|#-2.*.-*.-#|#-#-2.-#2-#|11#",0
      0  4957					      END_LEVEL	_102_Raven
      1  4957		       00 6e	   LEVEL_SIZE__102_Raven =	* - LEVEL_START
      2  4957					      IF	LEVEL_SIZE__102_Raven > MAX_LEVEL_SIZE
      3  4957				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Raven
      4  4957					      ENDIF
     77  4957
     78  4957							;  ############
     79  4957							;  #@##. #  # #
     80  4957							;  #**..$#    #
     81  4957							;  #. $..#  # #
     82  4957							;  # $#.$#$$$ #
     83  4957							;  #	      ##
     84  4957							;  #  ##  #   #
     85  4957							;  ############
     86  4957
      0  4957					      START_LEVEL	_103_Adin
      1  4957				   LEVEL_START SET	*
      2  4957		       00 09	   BANK_LEVEL__103_Adin =	_CURRENT_BANK
      3  4957				   LEVEL__103_Adin SUBROUTINE
      4  4957				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4957
     88  4957		       31 32 23 7c*	      .byte.b	"12#|#@2#.-#2-#-#|#2*2.$#4-#|#.-$2.#2-#-#|#-$#.$#3$-#|#9-2#|#2-2#2-#3-#|12#",0
      0  49a2					      END_LEVEL	_103_Adin
      1  49a2		       00 4b	   LEVEL_SIZE__103_Adin =	* - LEVEL_START
      2  49a2				  -	      IF	LEVEL_SIZE__103_Adin > MAX_LEVEL_SIZE
      3  49a2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Adin
      4  49a2					      ENDIF
     90  49a2
     91  49a2							;  #######___
     92  49a2							;  #	  #___
     93  49a2							;  #	$$#___
     94  49a2							;  #.*  .#___
     95  49a2							;  #$*$#*###_
     96  49a2							;  #@*... .#_
     97  49a2							;  #####$ .##
     98  49a2							;  ___# $ $ #
     99  49a2							;  ___#     #
    100  49a2							;  ___#######	(_ = modified by boo from wall)
    101  49a2
      0  49a2					      START_LEVEL	_103_Ajalae
      1  49a2				   LEVEL_START SET	*
      2  49a2		       00 09	   BANK_LEVEL__103_Ajalae =	_CURRENT_BANK
      3  49a2				   LEVEL__103_Ajalae SUBROUTINE
      4  49a2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  49a2
    103  49a2		       37 23 7c 23*	      .byte.b	"7#|#5-#|#3-2$#|#.*2-.#|#$*$#*3#|#@*3.-.#|5#$-.2#|3-#-$-$-#|3-#5-#|3-7#",0
      0  49e9					      END_LEVEL	_103_Ajalae
      1  49e9		       00 47	   LEVEL_SIZE__103_Ajalae =	* - LEVEL_START
      2  49e9				  -	      IF	LEVEL_SIZE__103_Ajalae > MAX_LEVEL_SIZE
      3  49e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Ajalae
      4  49e9					      ENDIF
    105  49e9
    106  49e9							;  ############
    107  49e9							;  #@#  #     #
    108  49e9							;  #  # #$#$# #
    109  49e9							;  # *$       #
    110  49e9							;  #..##$#$   #
    111  49e9							;  #..#. #  $ #
    112  49e9							;  #....# $$$##
    113  49e9							;  #	       #
    114  49e9							;  ############
    115  49e9
      0  49e9					      START_LEVEL	_103_Arielle
      1  49e9				   LEVEL_START SET	*
      2  49e9		       00 09	   BANK_LEVEL__103_Arielle =	_CURRENT_BANK
      3  49e9				   LEVEL__103_Arielle SUBROUTINE
      4  49e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  49e9
    117  49e9		       31 32 23 7c*	      .byte.b	"12#|#@#2-#5-#|#2-#-#$#$#-#|#-*$7-#|#2.2#$#$3-#|#2.#.-#2-$-#|#4.#-3$2#|#10-#|12#",0
      0  4a39					      END_LEVEL	_103_Arielle
      1  4a39		       00 50	   LEVEL_SIZE__103_Arielle =	* - LEVEL_START
      2  4a39				  -	      IF	LEVEL_SIZE__103_Arielle > MAX_LEVEL_SIZE
      3  4a39				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Arielle
      4  4a39					      ENDIF
    119  4a39
    120  4a39
    121  4a39
      0  4a39					      START_LEVEL	_1XJH_Tara_Gelson
      1  4a39				   LEVEL_START SET	*
      2  4a39		       00 09	   BANK_LEVEL__1XJH_Tara_Gelson =	_CURRENT_BANK
      3  4a39				   LEVEL__1XJH_Tara_Gelson SUBROUTINE
      4  4a39				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4a39
    123  4a39		       38 23 7c 23*	      .byte.b	"8#|#2-#2-*#|#2-*-*-#|#-*$-$-#|#2-.#.-#|#3-#-*#|2#-@3-#|8#",0
      0  4a73					      END_LEVEL	_1XJH_Tara_Gelson
      1  4a73		       00 3a	   LEVEL_SIZE__1XJH_Tara_Gelson =	* - LEVEL_START
      2  4a73				  -	      IF	LEVEL_SIZE__1XJH_Tara_Gelson > MAX_LEVEL_SIZE
      3  4a73				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1XJH_Tara_Gelson
      4  4a73					      ENDIF
    125  4a73
      0  4a73					      START_LEVEL	_1R7X_Alison
      1  4a73				   LEVEL_START SET	*
      2  4a73		       00 09	   BANK_LEVEL__1R7X_Alison =	_CURRENT_BANK
      3  4a73				   LEVEL__1R7X_Alison SUBROUTINE
      4  4a73				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4a73
    127  4a73		       37 23 7c 23*	      .byte.b	"7#|#2-.2-#|#-$*2$#|#-2.$.#|#@*-$-#|2#.3-#|7#",0
      0  4aa0					      END_LEVEL	_1R7X_Alison
      1  4aa0		       00 2d	   LEVEL_SIZE__1R7X_Alison =	* - LEVEL_START
      2  4aa0				  -	      IF	LEVEL_SIZE__1R7X_Alison > MAX_LEVEL_SIZE
      3  4aa0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1R7X_Alison
      4  4aa0					      ENDIF
    129  4aa0
      0  4aa0					      START_LEVEL	_1KWD_Cecile_Clayworth
      1  4aa0				   LEVEL_START SET	*
      2  4aa0		       00 09	   BANK_LEVEL__1KWD_Cecile_Clayworth =	_CURRENT_BANK
      3  4aa0				   LEVEL__1KWD_Cecile_Clayworth SUBROUTINE
      4  4aa0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4aa0
    131  4aa0		       38 23 7c 33*	      .byte.b	"8#|3#.2-.#|#-$4-#|#-*2#2$#|#3-$-+#|#-*.-*-#|#6-#|8#",0
      0  4ad4					      END_LEVEL	_1KWD_Cecile_Clayworth
      1  4ad4		       00 34	   LEVEL_SIZE__1KWD_Cecile_Clayworth =	* - LEVEL_START
      2  4ad4				  -	      IF	LEVEL_SIZE__1KWD_Cecile_Clayworth > MAX_LEVEL_SIZE
      3  4ad4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1KWD_Cecile_Clayworth
      4  4ad4					      ENDIF
    133  4ad4
      0  4ad4					      START_LEVEL	_1EKT_Samantha_Gelson
      1  4ad4				   LEVEL_START SET	*
      2  4ad4		       00 09	   BANK_LEVEL__1EKT_Samantha_Gelson =	_CURRENT_BANK
      3  4ad4				   LEVEL__1EKT_Samantha_Gelson SUBROUTINE
      4  4ad4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4ad4
    135  4ad4		       38 23 7c 23*	      .byte.b	"8#|#-*3-.#|#2-$-*-#|#-.$-$-#|#*-*2-*#|#.#-#2-#|#4-@-#|8#",0
      0  4b0d					      END_LEVEL	_1EKT_Samantha_Gelson
      1  4b0d		       00 39	   LEVEL_SIZE__1EKT_Samantha_Gelson =	* - LEVEL_START
      2  4b0d				  -	      IF	LEVEL_SIZE__1EKT_Samantha_Gelson > MAX_LEVEL_SIZE
      3  4b0d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1EKT_Samantha_Gelson
      4  4b0d					      ENDIF
    137  4b0d
      0  4b0d					      START_LEVEL	_0VM5_Andrea_Wadd
      1  4b0d				   LEVEL_START SET	*
      2  4b0d		       00 09	   BANK_LEVEL__0VM5_Andrea_Wadd =	_CURRENT_BANK
      3  4b0d				   LEVEL__0VM5_Andrea_Wadd SUBROUTINE
      4  4b0d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b0d
    139  4b0d		       37 23 7c 23*	      .byte.b	"7#|#3-#-#|#-$*2-#|#-.-+-#|#-*2$-#|2#2-.-#|7#",0
      0  4b3a					      END_LEVEL	_0VM5_Andrea_Wadd
      1  4b3a		       00 2d	   LEVEL_SIZE__0VM5_Andrea_Wadd =	* - LEVEL_START
      2  4b3a				  -	      IF	LEVEL_SIZE__0VM5_Andrea_Wadd > MAX_LEVEL_SIZE
      3  4b3a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0VM5_Andrea_Wadd
      4  4b3a					      ENDIF
    141  4b3a
      0  4b3a					      START_LEVEL	_0PAL_Jill_Leatherby
      1  4b3a				   LEVEL_START SET	*
      2  4b3a		       00 09	   BANK_LEVEL__0PAL_Jill_Leatherby =	_CURRENT_BANK
      3  4b3a				   LEVEL__0PAL_Jill_Leatherby SUBROUTINE
      4  4b3a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b3a
    143  4b3a		       37 23 7c 23*	      .byte.b	"7#|#3-3#|#2-2*-#|#3-$-#|#2-$2.#|3#@2-#|7#",0
      0  4b64					      END_LEVEL	_0PAL_Jill_Leatherby
      1  4b64		       00 2a	   LEVEL_SIZE__0PAL_Jill_Leatherby =	* - LEVEL_START
      2  4b64				  -	      IF	LEVEL_SIZE__0PAL_Jill_Leatherby > MAX_LEVEL_SIZE
      3  4b64				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0PAL_Jill_Leatherby
      4  4b64					      ENDIF
    145  4b64
      0  4b64					      START_LEVEL	_0IZ1_Sophia
      1  4b64				   LEVEL_START SET	*
      2  4b64		       00 09	   BANK_LEVEL__0IZ1_Sophia =	_CURRENT_BANK
      3  4b64				   LEVEL__0IZ1_Sophia SUBROUTINE
      4  4b64				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b64
    147  4b64		       37 23 7c 23*	      .byte.b	"7#|#5-#|#@$.#-#|#*$2-.#|#-2$2-#|#-.-.-#|7#",0
      0  4b8f					      END_LEVEL	_0IZ1_Sophia
      1  4b8f		       00 2b	   LEVEL_SIZE__0IZ1_Sophia =	* - LEVEL_START
      2  4b8f				  -	      IF	LEVEL_SIZE__0IZ1_Sophia > MAX_LEVEL_SIZE
      3  4b8f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0IZ1_Sophia
      4  4b8f					      ENDIF
    149  4b8f
      0  4b8f					      START_LEVEL	_0CNH_Alice
      1  4b8f				   LEVEL_START SET	*
      2  4b8f		       00 09	   BANK_LEVEL__0CNH_Alice =	_CURRENT_BANK
      3  4b8f				   LEVEL__0CNH_Alice SUBROUTINE
      4  4b8f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b8f
    151  4b8f		       37 23 7c 23*	      .byte.b	"7#|#.4-#|#$*-#-#|#.2-$*#|#-.$2-#|#@-*2-#|7#",0
      0  4bbb					      END_LEVEL	_0CNH_Alice
      1  4bbb		       00 2c	   LEVEL_SIZE__0CNH_Alice =	* - LEVEL_START
      2  4bbb				  -	      IF	LEVEL_SIZE__0CNH_Alice > MAX_LEVEL_SIZE
      3  4bbb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0CNH_Alice
      4  4bbb					      ENDIF
    153  4bbb
    154  4bbb							;  START_LEVEL TowC
    155  4bbb							;   .byte "4-5#|4-#3-#|4-#$2-#|2-3#2-$2#|2-#2-$-$-#|3#-#-2#-#3-6#|#3-#-2#-5#2-2.#|#-$2-$10-2.#|5#-3#-#@2#2-2.#|4-#5-9#|4-7#",0
    156  4bbb							;  END_LEVEL TowC
    157  4bbb
    158  4bbb							;  START_LEVEL SimpleC
    159  4bbb							;  .byte "7#|#.@-#-#|#$*-$-#|#3-$-#|#-..--#|#--*--#|7#",0
    160  4bbb							;  END_LEVEL SimpleC
    161  4bbb
      0  4bbb					      START_LEVEL	bAlfa_DrFogh
      1  4bbb				   LEVEL_START SET	*
      2  4bbb		       00 09	   BANK_LEVEL_bAlfa_DrFogh =	_CURRENT_BANK
      3  4bbb				   LEVEL_bAlfa_DrFogh SUBROUTINE
      4  4bbb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4bbb
    163  4bbb		       32 2d 34 23*	      .byte.b	"2-4#2-4#|-2#2-2#-#2-#|-#4-3#2-2#|2#2-2*2-#.2-2#|#2-*2-*-#*#2-#|#-*4-2*2-#-#|#-*-2#-*3-#-#|2#-*2-*#*#-#-#|-#$-2*-#-*-#-#|-#@#2-2#5-#|-2#2-4#2-3#|2-#2-#2-4#|2-#2-#|2-4#",0
      0  4c62					      END_LEVEL	bAlfa_DrFogh
      1  4c62		       00 a7	   LEVEL_SIZE_bAlfa_DrFogh =	* - LEVEL_START
      2  4c62					      IF	LEVEL_SIZE_bAlfa_DrFogh > MAX_LEVEL_SIZE
      3  4c62				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAlfa_DrFogh
      4  4c62					      ENDIF
    165  4c62
      0  4c62					      START_LEVEL	b51X_Sharpen
      1  4c62				   LEVEL_START SET	*
      2  4c62		       00 09	   BANK_LEVEL_b51X_Sharpen =	_CURRENT_BANK
      3  4c62				   LEVEL_b51X_Sharpen SUBROUTINE
      4  4c62				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4c62
    167  4c62		       2d 39 23 33*	      .byte.b	"-9#3-|-#7-#3-|-#-$-2$-$#3-|3#$#2-$-#3-|#.#3-2$-2#2-|#.3#3-$-#2-|#.#.-$-2#-3#|#3.$-$2#-$-#|#3.$3-$2-@#|#2.3#$3#-2#|#4.#5-#-|12#-",0
      0  4ce2					      END_LEVEL	b51X_Sharpen
      1  4ce2		       00 80	   LEVEL_SIZE_b51X_Sharpen =	* - LEVEL_START
      2  4ce2				  -	      IF	LEVEL_SIZE_b51X_Sharpen > MAX_LEVEL_SIZE
      3  4ce2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_b51X_Sharpen
      4  4ce2					      ENDIF
    169  4ce2
      0  4ce2					      START_LEVEL	bDarcy_Burnsell101
      1  4ce2				   LEVEL_START SET	*
      2  4ce2		       00 09	   BANK_LEVEL_bDarcy_Burnsell101 =	_CURRENT_BANK
      3  4ce2				   LEVEL_bDarcy_Burnsell101 SUBROUTINE
      4  4ce2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4ce2
    171  4ce2		       38 23 7c 23*	      .byte.b	"8#|#2-.-$@#|#.#$*2$#|#2-.-*-#|#2$-2$.#|#.#-#2-#|#.2-.-.#|8#",0
      0  4d1e					      END_LEVEL	bDarcy_Burnsell101
      1  4d1e		       00 3c	   LEVEL_SIZE_bDarcy_Burnsell101 =	* - LEVEL_START
      2  4d1e				  -	      IF	LEVEL_SIZE_bDarcy_Burnsell101 > MAX_LEVEL_SIZE
      3  4d1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bDarcy_Burnsell101
      4  4d1e					      ENDIF
    173  4d1e
      0  4d1e					      START_LEVEL	bAislin101
      1  4d1e				   LEVEL_START SET	*
      2  4d1e		       00 09	   BANK_LEVEL_bAislin101 =	_CURRENT_BANK
      3  4d1e				   LEVEL_bAislin101 SUBROUTINE
      4  4d1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4d1e
    175  4d1e		       38 23 7c 32*	      .byte.b	"8#|2#-*-*.#|#2.$-$*#|#-.#-*.#|2#-$-$2#|#-#$-$-#|#2.2-$@#|8#",0
      0  4d5a					      END_LEVEL	bAislin101
      1  4d5a		       00 3c	   LEVEL_SIZE_bAislin101 =	* - LEVEL_START
      2  4d5a				  -	      IF	LEVEL_SIZE_bAislin101 > MAX_LEVEL_SIZE
      3  4d5a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAislin101
      4  4d5a					      ENDIF
    177  4d5a
    178  4d5a							;  START_LEVEL b82X_Sharpen
    179  4d5a							;  .byte "-11#8-|-#5-#3-2#7-|-#-$-$-$-#2-5#3-|-3#2-5#5-#3-|-#4.#5-3#-#3-|-#.4#2-4#3-#3-|-#4.4-#2-$-2#3-|-#-3.#3-#-3$5#|3#.7#2-$@$3-#|#-$3-5#-$-2#3-#|#-#.#-$6-$3#$-#|#-#.8#2-#2-$-#|#-#3.7-2#-2$-#|#3-7#-$-#-#2-#|5#5-#7-2#|10-9#-",0
    180  4d5a							;  END_LEVEL b82X_Sharpen
    181  4d5a
      0  4d5a					      START_LEVEL	Thomas_Reinke16
      1  4d5a				   LEVEL_START SET	*
      2  4d5a		       00 09	   BANK_LEVEL_Thomas_Reinke16 =	_CURRENT_BANK
      3  4d5a				   LEVEL_Thomas_Reinke16 SUBROUTINE
      4  4d5a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4d5a
    183  4d5a		       2d 35 23 7c*	      .byte.b	"-5#|2#3-3#|#6-2#|#-#-2#2-#|#2.*2-#-#|#2-*2-#-#|3#*2$2-#|2-#@-4#|2-4#",0
      0  4d9f					      END_LEVEL	Thomas_Reinke16
      1  4d9f		       00 45	   LEVEL_SIZE_Thomas_Reinke16 =	* - LEVEL_START
      2  4d9f				  -	      IF	LEVEL_SIZE_Thomas_Reinke16 > MAX_LEVEL_SIZE
      3  4d9f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_Thomas_Reinke16
      4  4d9f					      ENDIF
    185  4d9f
    186  4d9f							;Level element	Character	ASCII Code
    187  4d9f							;Wall	#	0x23
    188  4d9f							;Player	@	0x40
    189  4d9f							;Player on goal square	+	0x2b
    190  4d9f							;Box	$	0x24
    191  4d9f							;Box on goal square	*	0x2a
    192  4d9f							;Goal square	.	0x2e
    193  4d9f							;Floor	(Space)	0x20 or underscore
    194  4d9f
    195  4d9f							;This level ("Claire", by Lee J Haywood):
    196  4d9f
    197  4d9f							;#######
    198  4d9f							;#.@ # #
    199  4d9f							;#$* $ #
    200  4d9f							;#   $ #
    201  4d9f							;# ..	#
    202  4d9f							;#  *	#
    203  4d9f							;#######
    204  4d9f							;runlength encoded looks like this:
    205  4d9f
    206  4d9f							;The rows of the level are separated by "|"s. There has been a discussion in the Yahoo Group about what character should represent an empty square in May 2006. Finally the hyphen has been elected to be the standard character for an empty square. Nevertheless, programs are encouraged to support both, hyphens and underscores.
    207  4d9f
    208  4d9f							;If only two level elements are grouped together they may be run length encoded, but needn't to. Example:
    209  4d9f
    210  4d9f
      0  4d9f					      CHECK_BANK_SIZE	"LEVELS6 -- full 2K"
      1  4d9f		       05 9f	   .TEMP      =	* - BANK_START
 LEVELS6 -- full 2K (2K) SIZE =  $59f , FREE= $261
      2  4d9f					      ECHO	"LEVELS6 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4d9f				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4d9f				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4d9f				  -	      ERR
      6  4d9f					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_PlayerFrames.asm LEVEL 2 PASS 3
      0  4d9f					      include	"BANK_PlayerFrames.asm"
      1  4d9f							;    Sokoboo - a Sokoban implementation
      2  4d9f							;    using a generic tile-based display engine for the Atari 2600
      3  4d9f							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  4d9f							;
      5  4d9f							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  4d9f							;
      7  4d9f							;    Code related to the generic tile-based display engine was developed by
      8  4d9f							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  4d9f							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  4d9f							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  4d9f							;
     12  4d9f							;    Code related to music and sound effects uses the TIATracker music player
     13  4d9f							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  4d9f							;    directory for Apache licensing details.
     15  4d9f							;
     16  4d9f							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  4d9f							;    See the copyright notices in the License directory for a list of level
     18  4d9f							;    contributors.
     19  4d9f							;
     20  4d9f							;    Except where otherwise indicated, this software is released under the
     21  4d9f							;    following licensing arrangement...
     22  4d9f							;
     23  4d9f							;    This program is free software: you can redistribute it and/or modify
     24  4d9f							;    it under the terms of the GNU General Public License as published by
     25  4d9f							;    the Free Software Foundation, either version 3 of the License, or
     26  4d9f							;    (at your option) any later version.
     27  4d9f							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  4d9f
     29  4d9f							;    This program is distributed in the hope that it will be useful,
     30  4d9f							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  4d9f							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  4d9f							;    GNU General Public License for more details.
     33  4d9f
      0  4d9f					      NEWBANK	PLAYER_FRAMES
      1  54e8 ????				      SEG	PLAYER_FRAMES
      2  5000					      ORG	ORIGIN
      3  5000					      RORG	$F000
      4  5000				   BANK_START SET	*
      5  5000				   PLAYER_FRAMES SET	ORIGIN / 2048
      6  5000				   ORIGIN     SET	ORIGIN + 2048
      7  5000				   _CURRENT_BANK SET	PLAYER_FRAMES
     35  5000
     36  5000							;CL0	  = $0
     37  5000							;CL1	  = $4C   ;yellow
     38  5000							;CL2	  = $68
     39  5000							;CL3	  = $0C   ; cuffs/trim
     40  5000							;CL4	  = $B8   ; jumper
     41  5000							;CL5	  = $b2
     42  5000							;CL6	  = $66
     43  5000
     44  5000		       00 00	   CL0	      =	$0
     45  5000		       00 01	   CL1	      =	1	;$2C	;yellow
     46  5000		       00 02	   CL2	      =	2	;$24
     47  5000		       00 03	   CL3	      =	3	;$6A	; cuffs/trim
     48  5000		       00 04	   CL4	      =	4	;$44
     49  5000		       00 05	   CL5	      =	5	;$B6	; pants
     50  5000		       00 06	   CL6	      =	6	;$64
     51  5000
     52  5000
     53  5000
     54  5000		       00 80	   JUMP       =	$80
     55  5000		       00 40	   FLIP       =	$40
     56  5000
     57  5000
     58  5000							;ANIMATION_WALK_ID = JUMP+0
     59  5000							;ANIMATION_IDLE_ID = JUMP+2
     60  5000							;ANIMATION_WIN_ID = JUMP+4
     61  5000							;ANIMATION_PUSH_ID = JUMP+6
     62  5000							;ANIMATION_PUSHTRY_ID = JUMP+8
     63  5000							;ANIMATION_PUSHUP_ID = JUMP+10
     64  5000
     65  5000				   ANIM_INDEX SET	0
     66  5000					      MAC	insert_animation
     67  5000				   ANIMATION_{1}_ID =	ANIM_INDEX
     68  5000					      .word	Animation_{1}
     69  5000				   ANIM_INDEX SET	ANIM_INDEX + 2
     70  5000					      ENDM		; {animation address}
     71  5000
     72  5000				   ANIM_TABLE
      0  5000					      INSERT_ANIMATION	WALK
      1  5000		       00 00	   ANIMATION_WALK_ID =	ANIM_INDEX
      2  5000		       0e f0		      .word.w	Animation_WALK
      3  5000				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5002					      INSERT_ANIMATION	IDLE
      1  5002		       00 02	   ANIMATION_IDLE_ID =	ANIM_INDEX
      2  5002		       36 f0		      .word.w	Animation_IDLE
      3  5002				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5004					      INSERT_ANIMATION	WIN
      1  5004		       00 04	   ANIMATION_WIN_ID =	ANIM_INDEX
      2  5004		       20 f0		      .word.w	Animation_WIN
      3  5004				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5006					      INSERT_ANIMATION	PUSH
      1  5006		       00 06	   ANIMATION_PUSH_ID =	ANIM_INDEX
      2  5006		       90 f0		      .word.w	Animation_PUSH
      3  5006				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5008					      INSERT_ANIMATION	PUSHTRY
      1  5008		       00 08	   ANIMATION_PUSHTRY_ID =	ANIM_INDEX
      2  5008		       8a f0		      .word.w	Animation_PUSHTRY
      3  5008				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  500a					      INSERT_ANIMATION	PUSHUP
      1  500a		       00 0a	   ANIMATION_PUSHUP_ID =	ANIM_INDEX
      2  500a		       9a f0		      .word.w	Animation_PUSHUP
      3  500a				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  500c					      INSERT_ANIMATION	WALK2
      1  500c		       00 0c	   ANIMATION_WALK2_ID =	ANIM_INDEX
      2  500c		       16 f0		      .word.w	Animation_WALK2
      3  500c				   ANIM_INDEX SET	ANIM_INDEX + 2
     80  500e
     81  500e				   Animation_WALK
     82  500e		       01 01		      .byte.b	FRAME_WALK1,1
     83  5010		       02 02		      .byte.b	FRAME_WALK2,2
     84  5012		       05 03		      .byte.b	FRAME_WALK3,3
     85  5014		       02 08		      .byte.b	FRAME_WALK2,8
     86  5016				   Animation_WALK2
     87  5016		       01 08		      .byte.b	FRAME_WALK1,8
     88  5018		       02 08		      .byte.b	FRAME_WALK2,8
     89  501a		       05 08		      .byte.b	FRAME_WALK3,8
     90  501c		       02 08		      .byte.b	FRAME_WALK2,8
     91  501e		       80 0c		      .byte.b	JUMP,ANIMATION_WALK2_ID
     92  5020
     93  5020				   Animation_WIN
     94  5020
     95  5020				  -	      if	0
     96  5020				  -	      REPEAT	2
     97  5020				  -	      .byte	FRAME_PUSH1, 10
     98  5020				  -	      .byte	FRAME_PUSH2, 10
     99  5020				  -	      .byte	FRAME_PUSH3, 10
    100  5020				  -	      .byte	FRAME_PUSH2, 10
    101  5020				  -	      REPEND
    102  5020				  -
    103  5020				  -			;    .byte FRAME_WALK2,10
    104  5020				  -
    105  5020				  -	      REPEAT	1
    106  5020				  -	      .byte	FRAME_LOOK3, 2
    107  5020				  -	      .byte	FRAME_LOOK2, 3
    108  5020				  -	      .byte	FRAME_LOOK1, 3
    109  5020				  -	      .byte	FLIP, 0
    110  5020				  -	      .byte	FRAME_WALK2, 5
    111  5020				  -	      REPEND
    112  5020				  -
    113  5020				  -	      .byte	JUMP, ANIMATION_WIN_ID
    114  5020					      endif
    115  5020
    116  5020		       0d 0a		      .byte.b	FRAME_IDLE1,10
    117  5022		       0b 0a		      .byte.b	FRAME_IDLE2,10
    118  5024							;    .byte FRAME_IDLE3,10
    119  5024		       0d 0a		      .byte.b	FRAME_IDLE1,10
    120  5026		       0b 0f		      .byte.b	FRAME_IDLE2,15
    121  5028		       0a 0a		      .byte.b	FRAME_IDLE3,10
    122  502a
    123  502a					      REPEAT	1
    124  502a		       12 02		      .byte.b	FRAME_LOOK3, 2
    125  502c		       11 03		      .byte.b	FRAME_LOOK2, 3
    126  502e		       13 03		      .byte.b	FRAME_LOOK1, 3
    127  5030		       40 00		      .byte.b	FLIP, 0
    128  5032		       02 03		      .byte.b	FRAME_WALK2, 3
    129  5034					      REPEND
    130  5034
    131  5034		       80 04		      .byte.b	JUMP,ANIMATION_WIN_ID
    132  5036
    133  5036				   Animation_IDLE
    134  5036
    135  5036							;    .byte FRAME_LOOK2, 3
    136  5036							;    .byte FRAME_LOOK3, 2
    137  5036							;    .byte FRAME_WALK2, 20
    138  5036
    139  5036
    140  5036
    141  5036
    142  5036
    143  5036
    144  5036					      REPEAT	2
    145  5036		       02 64		      .byte.b	FRAME_WALK2,100
    146  5038		       0f 02		      .byte.b	FRAME_BLINK,2
    144  5038					      REPEND
    145  503a		       02 64		      .byte.b	FRAME_WALK2,100
    146  503c		       0f 02		      .byte.b	FRAME_BLINK,2
    147  503e					      REPEND
    148  503e
    149  503e					      REPEAT	3
    150  503e		       14 0a		      .byte.b	FRAME_TAPFOOT,10
    151  5040		       02 05		      .byte.b	FRAME_WALK2,5
    149  5040					      REPEND
    150  5042		       14 0a		      .byte.b	FRAME_TAPFOOT,10
    151  5044		       02 05		      .byte.b	FRAME_WALK2,5
    149  5044					      REPEND
    150  5046		       14 0a		      .byte.b	FRAME_TAPFOOT,10
    151  5048		       02 05		      .byte.b	FRAME_WALK2,5
    152  504a					      REPEND
    153  504a
    154  504a		       12 03		      .byte.b	FRAME_LOOK3,3
    155  504c		       11 1e		      .byte.b	FRAME_LOOK2,30
    156  504e		       12 03		      .byte.b	FRAME_LOOK3,3
    157  5050
    158  5050					      REPEAT	2
    159  5050		       02 64		      .byte.b	FRAME_WALK2,100
    160  5052		       0f 02		      .byte.b	FRAME_BLINK,2
    158  5052					      REPEND
    159  5054		       02 64		      .byte.b	FRAME_WALK2,100
    160  5056		       0f 02		      .byte.b	FRAME_BLINK,2
    161  5058					      REPEND
    162  5058		       04 28		      .byte.b	FRAME_LOOKUP,40
    163  505a		       02 14		      .byte.b	FRAME_WALK2,20
    164  505c
    165  505c				   Animation_TURNAROUND
    166  505c
    167  505c					      REPEAT	3
    168  505c		       12 03		      .byte.b	FRAME_LOOK3, 3
    169  505e		       11 03		      .byte.b	FRAME_LOOK2, 3
    170  5060		       13 05		      .byte.b	FRAME_LOOK1, 5
    171  5062		       40 00		      .byte.b	FLIP, 0
    172  5064		       02 0a		      .byte.b	FRAME_WALK2, 10
    167  5064					      REPEND
    168  5066		       12 03		      .byte.b	FRAME_LOOK3, 3
    169  5068		       11 03		      .byte.b	FRAME_LOOK2, 3
    170  506a		       13 05		      .byte.b	FRAME_LOOK1, 5
    171  506c		       40 00		      .byte.b	FLIP, 0
    172  506e		       02 0a		      .byte.b	FRAME_WALK2, 10
    167  506e					      REPEND
    168  5070		       12 03		      .byte.b	FRAME_LOOK3, 3
    169  5072		       11 03		      .byte.b	FRAME_LOOK2, 3
    170  5074		       13 05		      .byte.b	FRAME_LOOK1, 5
    171  5076		       40 00		      .byte.b	FLIP, 0
    172  5078		       02 0a		      .byte.b	FRAME_WALK2, 10
    173  507a					      REPEND
    174  507a							;    .byte FRAME_BLINK,1
    175  507a							;    .byte FRAME_WALK2, 2
    176  507a
    177  507a		       80 02		      .byte.b	JUMP,ANIMATION_IDLE_ID
    178  507c
    179  507c
    180  507c				   Animation_YAWN
    181  507c
    182  507c		       03 28		      .byte.b	FRAME_HANDLIP,40
    183  507e		       02 32		      .byte.b	FRAME_WALK2,50
    184  5080		       0d 0a		      .byte.b	FRAME_IDLE1,10
    185  5082		       0b 0a		      .byte.b	FRAME_IDLE2,10
    186  5084		       0a 3c		      .byte.b	FRAME_IDLE3,60
    187  5086		       0b 1e		      .byte.b	FRAME_IDLE2,30
    188  5088		       80 02		      .byte.b	JUMP,ANIMATION_IDLE_ID
    189  508a
    190  508a
    191  508a
    192  508a
    193  508a				   Animation_PUSHTRY
    194  508a		       0e 1e		      .byte.b	FRAME_PUSH1,30
    195  508c		       0e 1e		      .byte.b	FRAME_PUSH1,30
    196  508e		       80 02		      .byte.b	JUMP,ANIMATION_IDLE_ID
    197  5090
    198  5090				   Animation_PUSH
    199  5090		       0e 14		      .byte.b	FRAME_PUSH1,20
    200  5092		       0c 14		      .byte.b	FRAME_PUSH2,20
    201  5094		       09 14		      .byte.b	FRAME_PUSH3,20
    202  5096		       0c 14		      .byte.b	FRAME_PUSH2,20
    203  5098		       80 06		      .byte.b	JUMP,ANIMATION_PUSH_ID
    204  509a
    205  509a				   Animation_PUSHUP
    206  509a		       06 0a		      .byte.b	FRAME_PUSH_UP_1, 10
    207  509c		       08 0a		      .byte.b	FRAME_PUSH_UP_2,10
    208  509e		       07 0a		      .byte.b	FRAME_PUSH_UP_3,10
    209  50a0		       08 0a		      .byte.b	FRAME_PUSH_UP_2,10
    210  50a2		       80 0a		      .byte.b	JUMP,ANIMATION_PUSHUP_ID
    211  50a4
    212  50a4
------- FILE sprites/spriteData.asm LEVEL 3 PASS 3
      0  50a4					      include	"sprites/spriteData.asm"
      1  50a4				   FRAMEDATA_crouch1
      2  50a4		       26		      .byte.b	38	; 23
      3  50a5		       12		      .byte.b	18	; 20
      4  50a6		       5a		      .byte.b	90	; 17
      5  50a7		       fc		      .byte.b	252	; 14
      6  50a8		       18		      .byte.b	24	; 11
      7  50a9		       18		      .byte.b	24	; 8
      8  50aa		       04		      .byte.b	4	; 5
      9  50ab		       00		      .byte.b	0	; 2
     10  50ac		       40		      .byte.b	64	; 22
     11  50ad		       3e		      .byte.b	62	; 19
     12  50ae		       ba		      .byte.b	186	; 16
     13  50af		       7c		      .byte.b	124	; 13
     14  50b0		       18		      .byte.b	24	; 10
     15  50b1		       0c		      .byte.b	12	; 7
     16  50b2		       1e		      .byte.b	30	; 4
     17  50b3		       00		      .byte.b	0	; 1
     18  50b4		       34		      .byte.b	52	; 21
     19  50b5		       52		      .byte.b	82	; 18
     20  50b6		       be		      .byte.b	190	; 15
     21  50b7		       38		      .byte.b	56	; 12
     22  50b8		       1c		      .byte.b	28	; 9
     23  50b9		       0a		      .byte.b	10	; 6
     24  50ba		       1d		      .byte.b	29	; 3
     25  50bb		       00		      .byte.b	0	; 0
     26  50bc
     27  50bc				   COLOURDATA_crouch1
     28  50bc		       06		      .byte.b	CL6	; 23
     29  50bd		       05		      .byte.b	CL5	; 20
     30  50be		       03		      .byte.b	CL3	; 17
     31  50bf		       04		      .byte.b	CL4	; 14
     32  50c0		       03		      .byte.b	CL3	; 11
     33  50c1		       02		      .byte.b	CL2	; 8
     34  50c2		       02		      .byte.b	CL2	; 5
     35  50c3		       00		      .byte.b	CL0	; 2
     36  50c4		       06		      .byte.b	CL6	; 22
     37  50c5		       05		      .byte.b	CL5	; 19
     38  50c6		       04		      .byte.b	CL4	; 16
     39  50c7		       04		      .byte.b	CL4	; 13
     40  50c8		       02		      .byte.b	CL2	; 10
     41  50c9		       02		      .byte.b	CL2	; 7
     42  50ca		       01		      .byte.b	CL1	; 4
     43  50cb		       00		      .byte.b	CL0	; 1
     44  50cc		       05		      .byte.b	CL5	; 21
     45  50cd		       02		      .byte.b	CL2	; 18
     46  50ce		       04		      .byte.b	CL4	; 15
     47  50cf		       04		      .byte.b	CL4	; 12
     48  50d0		       02		      .byte.b	CL2	; 9
     49  50d1		       02		      .byte.b	CL2	; 6
     50  50d2		       01		      .byte.b	CL1	; 3
     51  50d3		       00		      .byte.b	CL0	; 0
     52  50d4
     53  50d4				   FRAMEDATA_walk1
     54  50d4		       44		      .byte.b	68	; 23
     55  50d5		       4c		      .byte.b	76	; 20
     56  50d6		       28		      .byte.b	40	; 17
     57  50d7		       ba		      .byte.b	186	; 14
     58  50d8		       7c		      .byte.b	124	; 11
     59  50d9		       18		      .byte.b	24	; 8
     60  50da		       0c		      .byte.b	12	; 5
     61  50db		       1e		      .byte.b	30	; 2
     62  50dc		       82		      .byte.b	130	; 22
     63  50dd		       1c		      .byte.b	28	; 19
     64  50de		       b2		      .byte.b	178	; 16
     65  50df		       bc		      .byte.b	188	; 13
     66  50e0		       38		      .byte.b	56	; 10
     67  50e1		       1c		      .byte.b	28	; 7
     68  50e2		       0a		      .byte.b	10	; 4
     69  50e3		       1d		      .byte.b	29	; 1
     70  50e4		       6c		      .byte.b	108	; 21
     71  50e5		       38		      .byte.b	56	; 18
     72  50e6		       ba		      .byte.b	186	; 15
     73  50e7		       fc		      .byte.b	252	; 12
     74  50e8		       18		      .byte.b	24	; 9
     75  50e9		       18		      .byte.b	24	; 6
     76  50ea		       04		      .byte.b	4	; 3
     77  50eb		       00		      .byte.b	0	; 0
     78  50ec
     79  50ec				   COLOURDATA_walk1
     80  50ec		       06		      .byte.b	CL6	; 23
     81  50ed		       05		      .byte.b	CL5	; 20
     82  50ee		       05		      .byte.b	CL5	; 17
     83  50ef		       04		      .byte.b	CL4	; 14
     84  50f0		       04		      .byte.b	CL4	; 11
     85  50f1		       02		      .byte.b	CL2	; 8
     86  50f2		       02		      .byte.b	CL2	; 5
     87  50f3		       01		      .byte.b	CL1	; 2
     88  50f4		       06		      .byte.b	CL6	; 22
     89  50f5		       05		      .byte.b	CL5	; 19
     90  50f6		       02		      .byte.b	CL2	; 16
     91  50f7		       04		      .byte.b	CL4	; 13
     92  50f8		       04		      .byte.b	CL4	; 10
     93  50f9		       02		      .byte.b	CL2	; 7
     94  50fa		       02		      .byte.b	CL2	; 4
     95  50fb		       01		      .byte.b	CL1	; 1
     96  50fc		       05		      .byte.b	CL5	; 21
     97  50fd		       05		      .byte.b	CL5	; 18
     98  50fe		       03		      .byte.b	CL3	; 15
     99  50ff		       04		      .byte.b	CL4	; 12
    100  5100		       03		      .byte.b	CL3	; 9
    101  5101		       02		      .byte.b	CL2	; 6
    102  5102		       02		      .byte.b	CL2	; 3
    103  5103		       00		      .byte.b	CL0	; 0
    104  5104
    105  5104				   FRAMEDATA_walk2
    106  5104		       34		      .byte.b	52	; 23
    107  5105		       28		      .byte.b	40	; 20
    108  5106		       38		      .byte.b	56	; 17
    109  5107		       ba		      .byte.b	186	; 14
    110  5108		       fc		      .byte.b	252	; 11
    111  5109		       18		      .byte.b	24	; 8
    112  510a		       18		      .byte.b	24	; 5
    113  510b		       04		      .byte.b	4	; 2
    114  510c		       00		      .byte.b	0	; 22
    115  510d		       28		      .byte.b	40	; 19
    116  510e		       18		      .byte.b	24	; 16
    117  510f		       ba		      .byte.b	186	; 13
    118  5110		       7c		      .byte.b	124	; 10
    119  5111		       18		      .byte.b	24	; 7
    120  5112		       0c		      .byte.b	12	; 4
    121  5113		       1e		      .byte.b	30	; 1
    122  5114		       28		      .byte.b	40	; 21
    123  5115		       28		      .byte.b	40	; 18
    124  5116		       b2		      .byte.b	178	; 15
    125  5117		       bc		      .byte.b	188	; 12
    126  5118		       38		      .byte.b	56	; 9
    127  5119		       1c		      .byte.b	28	; 6
    128  511a		       0a		      .byte.b	10	; 3
    129  511b		       1d		      .byte.b	29	; 0
    130  511c
    131  511c				   COLOURDATA_walk2
    132  511c		       06		      .byte.b	CL6	; 23
    133  511d		       05		      .byte.b	CL5	; 20
    134  511e		       05		      .byte.b	CL5	; 17
    135  511f		       03		      .byte.b	CL3	; 14
    136  5120		       04		      .byte.b	CL4	; 11
    137  5121		       03		      .byte.b	CL3	; 8
    138  5122		       02		      .byte.b	CL2	; 5
    139  5123		       02		      .byte.b	CL2	; 2
    140  5124		       00		      .byte.b	CL0	; 22
    141  5125		       05		      .byte.b	CL5	; 19
    142  5126		       05		      .byte.b	CL5	; 16
    143  5127		       04		      .byte.b	CL4	; 13
    144  5128		       04		      .byte.b	CL4	; 10
    145  5129		       02		      .byte.b	CL2	; 7
    146  512a		       02		      .byte.b	CL2	; 4
    147  512b		       01		      .byte.b	CL1	; 1
    148  512c		       05		      .byte.b	CL5	; 21
    149  512d		       05		      .byte.b	CL5	; 18
    150  512e		       02		      .byte.b	CL2	; 15
    151  512f		       04		      .byte.b	CL4	; 12
    152  5130		       04		      .byte.b	CL4	; 9
    153  5131		       02		      .byte.b	CL2	; 6
    154  5132		       02		      .byte.b	CL2	; 3
    155  5133		       01		      .byte.b	CL1	; 0
    156  5134
    157  5134				   FRAMEDATA_handlip
    158  5134		       2c		      .byte.b	44	; 23
    159  5135		       28		      .byte.b	40	; 20
    160  5136		       38		      .byte.b	56	; 17
    161  5137		       58		      .byte.b	88	; 14
    162  5138		       fc		      .byte.b	252	; 11
    163  5139		       1a		      .byte.b	26	; 8
    164  513a		       18		      .byte.b	24	; 5
    165  513b		       04		      .byte.b	4	; 2
    166  513c		       00		      .byte.b	0	; 22
    167  513d		       28		      .byte.b	40	; 19
    168  513e		       38		      .byte.b	56	; 16
    169  513f		       b8		      .byte.b	184	; 13
    170  5140		       7e		      .byte.b	126	; 10
    171  5141		       1a		      .byte.b	26	; 7
    172  5142		       0c		      .byte.b	12	; 4
    173  5143		       1e		      .byte.b	30	; 1
    174  5144		       28		      .byte.b	40	; 21
    175  5145		       28		      .byte.b	40	; 18
    176  5146		       28		      .byte.b	40	; 15
    177  5147		       b8		      .byte.b	184	; 12
    178  5148		       3a		      .byte.b	58	; 9
    179  5149		       1e		      .byte.b	30	; 6
    180  514a		       0a		      .byte.b	10	; 3
    181  514b		       1d		      .byte.b	29	; 0
    182  514c
    183  514c				   COLOURDATA_handlip
    184  514c		       01		      .byte.b	CL1	; 23
    185  514d		       02		      .byte.b	CL2	; 20
    186  514e		       02		      .byte.b	CL2	; 17
    187  514f		       06		      .byte.b	CL6	; 14
    188  5150		       03		      .byte.b	CL3	; 11
    189  5151		       06		      .byte.b	CL6	; 8
    190  5152		       04		      .byte.b	CL4	; 5
    191  5153		       04		      .byte.b	CL4	; 2
    192  5154		       00		      .byte.b	CL0	; 22
    193  5155		       02		      .byte.b	CL2	; 19
    194  5156		       02		      .byte.b	CL2	; 16
    195  5157		       03		      .byte.b	CL3	; 13
    196  5158		       03		      .byte.b	CL3	; 10
    197  5159		       04		      .byte.b	CL4	; 7
    198  515a		       04		      .byte.b	CL4	; 4
    199  515b		       05		      .byte.b	CL5	; 1
    200  515c		       02		      .byte.b	CL2	; 21
    201  515d		       02		      .byte.b	CL2	; 18
    202  515e		       04		      .byte.b	CL4	; 15
    203  515f		       03		      .byte.b	CL3	; 12
    204  5160		       03		      .byte.b	CL3	; 9
    205  5161		       04		      .byte.b	CL4	; 6
    206  5162		       04		      .byte.b	CL4	; 3
    207  5163		       05		      .byte.b	CL5	; 0
    208  5164
    209  5164				   FRAMEDATA_lookup
    210  5164		       34		      .byte.b	52	; 23
    211  5165		       28		      .byte.b	40	; 20
    212  5166		       18		      .byte.b	24	; 17
    213  5167		       b8		      .byte.b	184	; 14
    214  5168		       7e		      .byte.b	126	; 11
    215  5169		       32		      .byte.b	50	; 8
    216  516a		       70		      .byte.b	112	; 5
    217  516b		       40		      .byte.b	64	; 2
    218  516c		       00		      .byte.b	0	; 22
    219  516d		       28		      .byte.b	40	; 19
    220  516e		       b0		      .byte.b	176	; 16
    221  516f		       b8		      .byte.b	184	; 13
    222  5170		       7a		      .byte.b	122	; 10
    223  5171		       36		      .byte.b	54	; 7
    224  5172		       58		      .byte.b	88	; 4
    225  5173		       78		      .byte.b	120	; 1
    226  5174		       28		      .byte.b	40	; 21
    227  5175		       28		      .byte.b	40	; 18
    228  5176		       b8		      .byte.b	184	; 15
    229  5177		       fc		      .byte.b	252	; 12
    230  5178		       32		      .byte.b	50	; 9
    231  5179		       60		      .byte.b	96	; 6
    232  517a		       30		      .byte.b	48	; 3
    233  517b		       34		      .byte.b	52	; 0
    234  517c
    235  517c				   COLOURDATA_lookup
    236  517c		       06		      .byte.b	CL6	; 23
    237  517d		       05		      .byte.b	CL5	; 20
    238  517e		       05		      .byte.b	CL5	; 17
    239  517f		       04		      .byte.b	CL4	; 14
    240  5180		       04		      .byte.b	CL4	; 11
    241  5181		       02		      .byte.b	CL2	; 8
    242  5182		       02		      .byte.b	CL2	; 5
    243  5183		       01		      .byte.b	CL1	; 2
    244  5184		       00		      .byte.b	CL0	; 22
    245  5185		       05		      .byte.b	CL5	; 19
    246  5186		       02		      .byte.b	CL2	; 16
    247  5187		       04		      .byte.b	CL4	; 13
    248  5188		       04		      .byte.b	CL4	; 10
    249  5189		       02		      .byte.b	CL2	; 7
    250  518a		       02		      .byte.b	CL2	; 4
    251  518b		       01		      .byte.b	CL1	; 1
    252  518c		       05		      .byte.b	CL5	; 21
    253  518d		       05		      .byte.b	CL5	; 18
    254  518e		       03		      .byte.b	CL3	; 15
    255  518f		       04		      .byte.b	CL4	; 12
    256  5190		       03		      .byte.b	CL3	; 9
    257  5191		       02		      .byte.b	CL2	; 6
    258  5192		       02		      .byte.b	CL2	; 3
    259  5193		       01		      .byte.b	CL1	; 0
    260  5194
    261  5194				   FRAMEDATA_walk3
    262  5194		       44		      .byte.b	68	; 23
    263  5195		       74		      .byte.b	116	; 20
    264  5196		       28		      .byte.b	40	; 17
    265  5197		       ba		      .byte.b	186	; 14
    266  5198		       7c		      .byte.b	124	; 11
    267  5199		       18		      .byte.b	24	; 8
    268  519a		       0c		      .byte.b	12	; 5
    269  519b		       1e		      .byte.b	30	; 2
    270  519c		       82		      .byte.b	130	; 22
    271  519d		       34		      .byte.b	52	; 19
    272  519e		       b2		      .byte.b	178	; 16
    273  519f		       bc		      .byte.b	188	; 13
    274  51a0		       38		      .byte.b	56	; 10
    275  51a1		       1c		      .byte.b	28	; 7
    276  51a2		       0a		      .byte.b	10	; 4
    277  51a3		       1d		      .byte.b	29	; 1
    278  51a4		       64		      .byte.b	100	; 21
    279  51a5		       38		      .byte.b	56	; 18
    280  51a6		       ba		      .byte.b	186	; 15
    281  51a7		       fc		      .byte.b	252	; 12
    282  51a8		       18		      .byte.b	24	; 9
    283  51a9		       18		      .byte.b	24	; 6
    284  51aa		       04		      .byte.b	4	; 3
    285  51ab		       00		      .byte.b	0	; 0
    286  51ac
    287  51ac				   COLOURDATA_walk3
    288  51ac		       06		      .byte.b	CL6	; 23
    289  51ad		       05		      .byte.b	CL5	; 20
    290  51ae		       05		      .byte.b	CL5	; 17
    291  51af		       04		      .byte.b	CL4	; 14
    292  51b0		       04		      .byte.b	CL4	; 11
    293  51b1		       02		      .byte.b	CL2	; 8
    294  51b2		       02		      .byte.b	CL2	; 5
    295  51b3		       01		      .byte.b	CL1	; 2
    296  51b4		       06		      .byte.b	CL6	; 22
    297  51b5		       05		      .byte.b	CL5	; 19
    298  51b6		       02		      .byte.b	CL2	; 16
    299  51b7		       04		      .byte.b	CL4	; 13
    300  51b8		       04		      .byte.b	CL4	; 10
    301  51b9		       02		      .byte.b	CL2	; 7
    302  51ba		       02		      .byte.b	CL2	; 4
    303  51bb		       01		      .byte.b	CL1	; 1
    304  51bc		       05		      .byte.b	CL5	; 21
    305  51bd		       05		      .byte.b	CL5	; 18
    306  51be		       03		      .byte.b	CL3	; 15
    307  51bf		       04		      .byte.b	CL4	; 12
    308  51c0		       03		      .byte.b	CL3	; 9
    309  51c1		       02		      .byte.b	CL2	; 6
    310  51c2		       02		      .byte.b	CL2	; 3
    311  51c3		       00		      .byte.b	CL0	; 0
    312  51c4
    313  51c4				   FRAMEDATA_push_up_1
    314  51c4		       00		      .byte.b	0	; 23
    315  51c5		       20		      .byte.b	32	; 20
    316  51c6		       20		      .byte.b	32	; 17
    317  51c7		       20		      .byte.b	32	; 14
    318  51c8		       38		      .byte.b	56	; 11
    319  51c9		       38		      .byte.b	56	; 8
    320  51ca		       ee		      .byte.b	238	; 5
    321  51cb		       38		      .byte.b	56	; 2
    322  51cc		       00		      .byte.b	0	; 22
    323  51cd		       20		      .byte.b	32	; 19
    324  51ce		       28		      .byte.b	40	; 16
    325  51cf		       38		      .byte.b	56	; 13
    326  51d0		       38		      .byte.b	56	; 10
    327  51d1		       38		      .byte.b	56	; 7
    328  51d2		       82		      .byte.b	130	; 4
    329  51d3		       38		      .byte.b	56	; 1
    330  51d4		       00		      .byte.b	0	; 21
    331  51d5		       08		      .byte.b	8	; 18
    332  51d6		       08		      .byte.b	8	; 15
    333  51d7		       10		      .byte.b	16	; 12
    334  51d8		       38		      .byte.b	56	; 9
    335  51d9		       7c		      .byte.b	124	; 6
    336  51da		       aa		      .byte.b	170	; 3
    337  51db		       00		      .byte.b	0	; 0
    338  51dc
    339  51dc				   COLOURDATA_push_up_1
    340  51dc		       00		      .byte.b	CL0	; 23
    341  51dd		       06		      .byte.b	CL6	; 20
    342  51de		       05		      .byte.b	CL5	; 17
    343  51df		       05		      .byte.b	CL5	; 14
    344  51e0		       06		      .byte.b	CL6	; 11
    345  51e1		       04		      .byte.b	CL4	; 8
    346  51e2		       04		      .byte.b	CL4	; 5
    347  51e3		       01		      .byte.b	CL1	; 2
    348  51e4		       00		      .byte.b	CL0	; 22
    349  51e5		       06		      .byte.b	CL6	; 19
    350  51e6		       05		      .byte.b	CL5	; 16
    351  51e7		       05		      .byte.b	CL5	; 13
    352  51e8		       03		      .byte.b	CL3	; 10
    353  51e9		       04		      .byte.b	CL4	; 7
    354  51ea		       03		      .byte.b	CL3	; 4
    355  51eb		       01		      .byte.b	CL1	; 1
    356  51ec		       00		      .byte.b	CL0	; 21
    357  51ed		       06		      .byte.b	CL6	; 18
    358  51ee		       05		      .byte.b	CL5	; 15
    359  51ef		       05		      .byte.b	CL5	; 12
    360  51f0		       04		      .byte.b	CL4	; 9
    361  51f1		       04		      .byte.b	CL4	; 6
    362  51f2		       02		      .byte.b	CL2	; 3
    363  51f3		       00		      .byte.b	CL0	; 0
    364  51f4
    365  51f4				   FRAMEDATA_push_up_3
    366  51f4		       00		      .byte.b	0	; 23
    367  51f5		       08		      .byte.b	8	; 20
    368  51f6		       08		      .byte.b	8	; 17
    369  51f7		       08		      .byte.b	8	; 14
    370  51f8		       38		      .byte.b	56	; 11
    371  51f9		       38		      .byte.b	56	; 8
    372  51fa		       ee		      .byte.b	238	; 5
    373  51fb		       38		      .byte.b	56	; 2
    374  51fc		       00		      .byte.b	0	; 22
    375  51fd		       08		      .byte.b	8	; 19
    376  51fe		       28		      .byte.b	40	; 16
    377  51ff		       38		      .byte.b	56	; 13
    378  5200		       38		      .byte.b	56	; 10
    379  5201		       38		      .byte.b	56	; 7
    380  5202		       82		      .byte.b	130	; 4
    381  5203		       38		      .byte.b	56	; 1
    382  5204		       00		      .byte.b	0	; 21
    383  5205		       20		      .byte.b	32	; 18
    384  5206		       20		      .byte.b	32	; 15
    385  5207		       10		      .byte.b	16	; 12
    386  5208		       38		      .byte.b	56	; 9
    387  5209		       7c		      .byte.b	124	; 6
    388  520a		       aa		      .byte.b	170	; 3
    389  520b		       00		      .byte.b	0	; 0
    390  520c
    391  520c				   COLOURDATA_push_up_3
    392  520c		       00		      .byte.b	CL0	; 23
    393  520d		       06		      .byte.b	CL6	; 20
    394  520e		       05		      .byte.b	CL5	; 17
    395  520f		       05		      .byte.b	CL5	; 14
    396  5210		       01		      .byte.b	CL1	; 11
    397  5211		       04		      .byte.b	CL4	; 8
    398  5212		       04		      .byte.b	CL4	; 5
    399  5213		       01		      .byte.b	CL1	; 2
    400  5214		       00		      .byte.b	CL0	; 22
    401  5215		       06		      .byte.b	CL6	; 19
    402  5216		       05		      .byte.b	CL5	; 16
    403  5217		       05		      .byte.b	CL5	; 13
    404  5218		       03		      .byte.b	CL3	; 10
    405  5219		       04		      .byte.b	CL4	; 7
    406  521a		       03		      .byte.b	CL3	; 4
    407  521b		       01		      .byte.b	CL1	; 1
    408  521c		       00		      .byte.b	CL0	; 21
    409  521d		       06		      .byte.b	CL6	; 18
    410  521e		       05		      .byte.b	CL5	; 15
    411  521f		       05		      .byte.b	CL5	; 12
    412  5220		       04		      .byte.b	CL4	; 9
    413  5221		       04		      .byte.b	CL4	; 6
    414  5222		       02		      .byte.b	CL2	; 3
    415  5223		       00		      .byte.b	CL0	; 0
    416  5224
    417  5224				   FRAMEDATA_push_up_2
    418  5224		       00		      .byte.b	0	; 23
    419  5225		       00		      .byte.b	0	; 20
    420  5226		       28		      .byte.b	40	; 17
    421  5227		       28		      .byte.b	40	; 14
    422  5228		       38		      .byte.b	56	; 11
    423  5229		       38		      .byte.b	56	; 8
    424  522a		       ee		      .byte.b	238	; 5
    425  522b		       38		      .byte.b	56	; 2
    426  522c		       00		      .byte.b	0	; 22
    427  522d		       28		      .byte.b	40	; 19
    428  522e		       28		      .byte.b	40	; 16
    429  522f		       38		      .byte.b	56	; 13
    430  5230		       38		      .byte.b	56	; 10
    431  5231		       38		      .byte.b	56	; 7
    432  5232		       82		      .byte.b	130	; 4
    433  5233		       38		      .byte.b	56	; 1
    434  5234		       00		      .byte.b	0	; 21
    435  5235		       00		      .byte.b	0	; 18
    436  5236		       00		      .byte.b	0	; 15
    437  5237		       10		      .byte.b	16	; 12
    438  5238		       38		      .byte.b	56	; 9
    439  5239		       7c		      .byte.b	124	; 6
    440  523a		       aa		      .byte.b	170	; 3
    441  523b		       00		      .byte.b	0	; 0
    442  523c
    443  523c				   COLOURDATA_push_up_2
    444  523c		       00		      .byte.b	CL0	; 23
    445  523d		       00		      .byte.b	CL0	; 20
    446  523e		       05		      .byte.b	CL5	; 17
    447  523f		       05		      .byte.b	CL5	; 14
    448  5240		       06		      .byte.b	CL6	; 11
    449  5241		       04		      .byte.b	CL4	; 8
    450  5242		       04		      .byte.b	CL4	; 5
    451  5243		       01		      .byte.b	CL1	; 2
    452  5244		       00		      .byte.b	CL0	; 22
    453  5245		       06		      .byte.b	CL6	; 19
    454  5246		       05		      .byte.b	CL5	; 16
    455  5247		       05		      .byte.b	CL5	; 13
    456  5248		       03		      .byte.b	CL3	; 10
    457  5249		       04		      .byte.b	CL4	; 7
    458  524a		       03		      .byte.b	CL3	; 4
    459  524b		       01		      .byte.b	CL1	; 1
    460  524c		       00		      .byte.b	CL0	; 21
    461  524d		       00		      .byte.b	CL0	; 18
    462  524e		       00		      .byte.b	CL0	; 15
    463  524f		       05		      .byte.b	CL5	; 12
    464  5250		       04		      .byte.b	CL4	; 9
    465  5251		       04		      .byte.b	CL4	; 6
    466  5252		       02		      .byte.b	CL2	; 3
    467  5253		       00		      .byte.b	CL0	; 0
    468  5254
    469  5254				   FRAMEDATA_push3
    470  5254		       46		      .byte.b	70	; 23
    471  5255		       72		      .byte.b	114	; 20
    472  5256		       18		      .byte.b	24	; 17
    473  5257		       38		      .byte.b	56	; 14
    474  5258		       3e		      .byte.b	62	; 11
    475  5259		       19		      .byte.b	25	; 8
    476  525a		       0c		      .byte.b	12	; 5
    477  525b		       1e		      .byte.b	30	; 2
    478  525c		       80		      .byte.b	128	; 22
    479  525d		       3e		      .byte.b	62	; 19
    480  525e		       30		      .byte.b	48	; 16
    481  525f		       38		      .byte.b	56	; 13
    482  5260		       3f		      .byte.b	63	; 10
    483  5261		       1d		      .byte.b	29	; 7
    484  5262		       0a		      .byte.b	10	; 4
    485  5263		       1d		      .byte.b	29	; 1
    486  5264		       64		      .byte.b	100	; 21
    487  5265		       3c		      .byte.b	60	; 18
    488  5266		       38		      .byte.b	56	; 15
    489  5267		       3c		      .byte.b	60	; 12
    490  5268		       19		      .byte.b	25	; 9
    491  5269		       18		      .byte.b	24	; 6
    492  526a		       04		      .byte.b	4	; 3
    493  526b		       00		      .byte.b	0	; 0
    494  526c
    495  526c				   COLOURDATA_push3
    496  526c		       06		      .byte.b	CL6	; 23
    497  526d		       05		      .byte.b	CL5	; 20
    498  526e		       05		      .byte.b	CL5	; 17
    499  526f		       04		      .byte.b	CL4	; 14
    500  5270		       04		      .byte.b	CL4	; 11
    501  5271		       02		      .byte.b	CL2	; 8
    502  5272		       02		      .byte.b	CL2	; 5
    503  5273		       01		      .byte.b	CL1	; 2
    504  5274		       06		      .byte.b	CL6	; 22
    505  5275		       05		      .byte.b	CL5	; 19
    506  5276		       05		      .byte.b	CL5	; 16
    507  5277		       04		      .byte.b	CL4	; 13
    508  5278		       04		      .byte.b	CL4	; 10
    509  5279		       02		      .byte.b	CL2	; 7
    510  527a		       02		      .byte.b	CL2	; 4
    511  527b		       01		      .byte.b	CL1	; 1
    512  527c		       05		      .byte.b	CL5	; 21
    513  527d		       05		      .byte.b	CL5	; 18
    514  527e		       03		      .byte.b	CL3	; 15
    515  527f		       04		      .byte.b	CL4	; 12
    516  5280		       03		      .byte.b	CL3	; 9
    517  5281		       02		      .byte.b	CL2	; 6
    518  5282		       02		      .byte.b	CL2	; 3
    519  5283		       00		      .byte.b	CL0	; 0
    520  5284
    521  5284				   FRAMEDATA_idle3
    522  5284		       2c		      .byte.b	44	; 23
    523  5285		       28		      .byte.b	40	; 20
    524  5286		       38		      .byte.b	56	; 17
    525  5287		       38		      .byte.b	56	; 14
    526  5288		       38		      .byte.b	56	; 11
    527  5289		       b2		      .byte.b	178	; 8
    528  528a		       30		      .byte.b	48	; 5
    529  528b		       08		      .byte.b	8	; 2
    530  528c		       00		      .byte.b	0	; 22
    531  528d		       28		      .byte.b	40	; 19
    532  528e		       38		      .byte.b	56	; 16
    533  528f		       38		      .byte.b	56	; 13
    534  5290		       fe		      .byte.b	254	; 10
    535  5291		       ba		      .byte.b	186	; 7
    536  5292		       18		      .byte.b	24	; 4
    537  5293		       3c		      .byte.b	60	; 1
    538  5294		       28		      .byte.b	40	; 21
    539  5295		       28		      .byte.b	40	; 18
    540  5296		       28		      .byte.b	40	; 15
    541  5297		       38		      .byte.b	56	; 12
    542  5298		       fe		      .byte.b	254	; 9
    543  5299		       b2		      .byte.b	178	; 6
    544  529a		       14		      .byte.b	20	; 3
    545  529b		       3a		      .byte.b	58	; 0
    546  529c
    547  529c				   COLOURDATA_idle3
    548  529c		       06		      .byte.b	CL6	; 23
    549  529d		       05		      .byte.b	CL5	; 20
    550  529e		       05		      .byte.b	CL5	; 17
    551  529f		       03		      .byte.b	CL3	; 14
    552  52a0		       04		      .byte.b	CL4	; 11
    553  52a1		       03		      .byte.b	CL3	; 8
    554  52a2		       02		      .byte.b	CL2	; 5
    555  52a3		       02		      .byte.b	CL2	; 2
    556  52a4		       00		      .byte.b	CL0	; 22
    557  52a5		       05		      .byte.b	CL5	; 19
    558  52a6		       05		      .byte.b	CL5	; 16
    559  52a7		       04		      .byte.b	CL4	; 13
    560  52a8		       04		      .byte.b	CL4	; 10
    561  52a9		       02		      .byte.b	CL2	; 7
    562  52aa		       02		      .byte.b	CL2	; 4
    563  52ab		       01		      .byte.b	CL1	; 1
    564  52ac		       05		      .byte.b	CL5	; 21
    565  52ad		       05		      .byte.b	CL5	; 18
    566  52ae		       06		      .byte.b	CL6	; 15
    567  52af		       04		      .byte.b	CL4	; 12
    568  52b0		       04		      .byte.b	CL4	; 9
    569  52b1		       02		      .byte.b	CL2	; 6
    570  52b2		       02		      .byte.b	CL2	; 3
    571  52b3		       01		      .byte.b	CL1	; 0
    572  52b4
    573  52b4				   FRAMEDATA_idle2
    574  52b4		       2c		      .byte.b	44	; 23
    575  52b5		       28		      .byte.b	40	; 20
    576  52b6		       38		      .byte.b	56	; 17
    577  52b7		       38		      .byte.b	56	; 14
    578  52b8		       fe		      .byte.b	254	; 11
    579  52b9		       b2		      .byte.b	178	; 8
    580  52ba		       30		      .byte.b	48	; 5
    581  52bb		       08		      .byte.b	8	; 2
    582  52bc		       00		      .byte.b	0	; 22
    583  52bd		       28		      .byte.b	40	; 19
    584  52be		       38		      .byte.b	56	; 16
    585  52bf		       38		      .byte.b	56	; 13
    586  52c0		       fe		      .byte.b	254	; 10
    587  52c1		       ba		      .byte.b	186	; 7
    588  52c2		       18		      .byte.b	24	; 4
    589  52c3		       3c		      .byte.b	60	; 1
    590  52c4		       28		      .byte.b	40	; 21
    591  52c5		       28		      .byte.b	40	; 18
    592  52c6		       28		      .byte.b	40	; 15
    593  52c7		       38		      .byte.b	56	; 12
    594  52c8		       ba		      .byte.b	186	; 9
    595  52c9		       30		      .byte.b	48	; 6
    596  52ca		       14		      .byte.b	20	; 3
    597  52cb		       3a		      .byte.b	58	; 0
    598  52cc
    599  52cc				   COLOURDATA_idle2
    600  52cc		       06		      .byte.b	CL6	; 23
    601  52cd		       05		      .byte.b	CL5	; 20
    602  52ce		       05		      .byte.b	CL5	; 17
    603  52cf		       03		      .byte.b	CL3	; 14
    604  52d0		       04		      .byte.b	CL4	; 11
    605  52d1		       03		      .byte.b	CL3	; 8
    606  52d2		       02		      .byte.b	CL2	; 5
    607  52d3		       02		      .byte.b	CL2	; 2
    608  52d4		       00		      .byte.b	CL0	; 22
    609  52d5		       05		      .byte.b	CL5	; 19
    610  52d6		       05		      .byte.b	CL5	; 16
    611  52d7		       04		      .byte.b	CL4	; 13
    612  52d8		       04		      .byte.b	CL4	; 10
    613  52d9		       02		      .byte.b	CL2	; 7
    614  52da		       02		      .byte.b	CL2	; 4
    615  52db		       01		      .byte.b	CL1	; 1
    616  52dc		       05		      .byte.b	CL5	; 21
    617  52dd		       05		      .byte.b	CL5	; 18
    618  52de		       06		      .byte.b	CL6	; 15
    619  52df		       04		      .byte.b	CL4	; 12
    620  52e0		       04		      .byte.b	CL4	; 9
    621  52e1		       02		      .byte.b	CL2	; 6
    622  52e2		       02		      .byte.b	CL2	; 3
    623  52e3		       01		      .byte.b	CL1	; 0
    624  52e4
    625  52e4				   FRAMEDATA_push2
    626  52e4		       26		      .byte.b	38	; 23
    627  52e5		       14		      .byte.b	20	; 20
    628  52e6		       3c		      .byte.b	60	; 17
    629  52e7		       38		      .byte.b	56	; 14
    630  52e8		       3c		      .byte.b	60	; 11
    631  52e9		       19		      .byte.b	25	; 8
    632  52ea		       18		      .byte.b	24	; 5
    633  52eb		       04		      .byte.b	4	; 2
    634  52ec		       40		      .byte.b	64	; 22
    635  52ed		       14		      .byte.b	20	; 19
    636  52ee		       28		      .byte.b	40	; 16
    637  52ef		       38		      .byte.b	56	; 13
    638  52f0		       3e		      .byte.b	62	; 10
    639  52f1		       19		      .byte.b	25	; 7
    640  52f2		       0c		      .byte.b	12	; 4
    641  52f3		       1e		      .byte.b	30	; 1
    642  52f4		       34		      .byte.b	52	; 21
    643  52f5		       3c		      .byte.b	60	; 18
    644  52f6		       30		      .byte.b	48	; 15
    645  52f7		       38		      .byte.b	56	; 12
    646  52f8		       3f		      .byte.b	63	; 9
    647  52f9		       1d		      .byte.b	29	; 6
    648  52fa		       0a		      .byte.b	10	; 3
    649  52fb		       1d		      .byte.b	29	; 0
    650  52fc
    651  52fc				   COLOURDATA_push2
    652  52fc		       06		      .byte.b	CL6	; 23
    653  52fd		       05		      .byte.b	CL5	; 20
    654  52fe		       05		      .byte.b	CL5	; 17
    655  52ff		       03		      .byte.b	CL3	; 14
    656  5300		       04		      .byte.b	CL4	; 11
    657  5301		       03		      .byte.b	CL3	; 8
    658  5302		       02		      .byte.b	CL2	; 5
    659  5303		       02		      .byte.b	CL2	; 2
    660  5304		       06		      .byte.b	CL6	; 22
    661  5305		       05		      .byte.b	CL5	; 19
    662  5306		       05		      .byte.b	CL5	; 16
    663  5307		       04		      .byte.b	CL4	; 13
    664  5308		       04		      .byte.b	CL4	; 10
    665  5309		       02		      .byte.b	CL2	; 7
    666  530a		       02		      .byte.b	CL2	; 4
    667  530b		       01		      .byte.b	CL1	; 1
    668  530c		       05		      .byte.b	CL5	; 21
    669  530d		       05		      .byte.b	CL5	; 18
    670  530e		       01		      .byte.b	CL1	; 15
    671  530f		       04		      .byte.b	CL4	; 12
    672  5310		       04		      .byte.b	CL4	; 9
    673  5311		       02		      .byte.b	CL2	; 6
    674  5312		       02		      .byte.b	CL2	; 3
    675  5313		       01		      .byte.b	CL1	; 0
    676  5314
    677  5314				   FRAMEDATA_idle1
    678  5314		       2c		      .byte.b	44	; 23
    679  5315		       28		      .byte.b	40	; 20
    680  5316		       38		      .byte.b	56	; 17
    681  5317		       ba		      .byte.b	186	; 14
    682  5318		       fc		      .byte.b	252	; 11
    683  5319		       18		      .byte.b	24	; 8
    684  531a		       18		      .byte.b	24	; 5
    685  531b		       04		      .byte.b	4	; 2
    686  531c		       00		      .byte.b	0	; 22
    687  531d		       28		      .byte.b	40	; 19
    688  531e		       38		      .byte.b	56	; 16
    689  531f		       ba		      .byte.b	186	; 13
    690  5320		       7c		      .byte.b	124	; 10
    691  5321		       18		      .byte.b	24	; 7
    692  5322		       0c		      .byte.b	12	; 4
    693  5323		       1e		      .byte.b	30	; 1
    694  5324		       28		      .byte.b	40	; 21
    695  5325		       28		      .byte.b	40	; 18
    696  5326		       aa		      .byte.b	170	; 15
    697  5327		       bc		      .byte.b	188	; 12
    698  5328		       38		      .byte.b	56	; 9
    699  5329		       1c		      .byte.b	28	; 6
    700  532a		       0a		      .byte.b	10	; 3
    701  532b		       1d		      .byte.b	29	; 0
    702  532c
    703  532c				   COLOURDATA_idle1
    704  532c		       06		      .byte.b	CL6	; 23
    705  532d		       05		      .byte.b	CL5	; 20
    706  532e		       05		      .byte.b	CL5	; 17
    707  532f		       03		      .byte.b	CL3	; 14
    708  5330		       04		      .byte.b	CL4	; 11
    709  5331		       03		      .byte.b	CL3	; 8
    710  5332		       02		      .byte.b	CL2	; 5
    711  5333		       02		      .byte.b	CL2	; 2
    712  5334		       00		      .byte.b	CL0	; 22
    713  5335		       05		      .byte.b	CL5	; 19
    714  5336		       05		      .byte.b	CL5	; 16
    715  5337		       04		      .byte.b	CL4	; 13
    716  5338		       04		      .byte.b	CL4	; 10
    717  5339		       02		      .byte.b	CL2	; 7
    718  533a		       02		      .byte.b	CL2	; 4
    719  533b		       01		      .byte.b	CL1	; 1
    720  533c		       05		      .byte.b	CL5	; 21
    721  533d		       05		      .byte.b	CL5	; 18
    722  533e		       02		      .byte.b	CL2	; 15
    723  533f		       04		      .byte.b	CL4	; 12
    724  5340		       04		      .byte.b	CL4	; 9
    725  5341		       02		      .byte.b	CL2	; 6
    726  5342		       02		      .byte.b	CL2	; 3
    727  5343		       01		      .byte.b	CL1	; 0
    728  5344
    729  5344				   FRAMEDATA_push1
    730  5344		       46		      .byte.b	70	; 23
    731  5345		       62		      .byte.b	98	; 20
    732  5346		       28		      .byte.b	40	; 17
    733  5347		       38		      .byte.b	56	; 14
    734  5348		       3e		      .byte.b	62	; 11
    735  5349		       19		      .byte.b	25	; 8
    736  534a		       0c		      .byte.b	12	; 5
    737  534b		       1e		      .byte.b	30	; 2
    738  534c		       80		      .byte.b	128	; 22
    739  534d		       1e		      .byte.b	30	; 19
    740  534e		       30		      .byte.b	48	; 16
    741  534f		       38		      .byte.b	56	; 13
    742  5350		       3f		      .byte.b	63	; 10
    743  5351		       1d		      .byte.b	29	; 7
    744  5352		       0a		      .byte.b	10	; 4
    745  5353		       1d		      .byte.b	29	; 1
    746  5354		       64		      .byte.b	100	; 21
    747  5355		       3c		      .byte.b	60	; 18
    748  5356		       38		      .byte.b	56	; 15
    749  5357		       3c		      .byte.b	60	; 12
    750  5358		       19		      .byte.b	25	; 9
    751  5359		       18		      .byte.b	24	; 6
    752  535a		       04		      .byte.b	4	; 3
    753  535b		       00		      .byte.b	0	; 0
    754  535c
    755  535c				   COLOURDATA_push1
    756  535c		       06		      .byte.b	CL6	; 23
    757  535d		       05		      .byte.b	CL5	; 20
    758  535e		       05		      .byte.b	CL5	; 17
    759  535f		       04		      .byte.b	CL4	; 14
    760  5360		       04		      .byte.b	CL4	; 11
    761  5361		       02		      .byte.b	CL2	; 8
    762  5362		       02		      .byte.b	CL2	; 5
    763  5363		       01		      .byte.b	CL1	; 2
    764  5364		       06		      .byte.b	CL6	; 22
    765  5365		       05		      .byte.b	CL5	; 19
    766  5366		       06		      .byte.b	CL6	; 16
    767  5367		       04		      .byte.b	CL4	; 13
    768  5368		       04		      .byte.b	CL4	; 10
    769  5369		       02		      .byte.b	CL2	; 7
    770  536a		       02		      .byte.b	CL2	; 4
    771  536b		       01		      .byte.b	CL1	; 1
    772  536c		       05		      .byte.b	CL5	; 21
    773  536d		       05		      .byte.b	CL5	; 18
    774  536e		       03		      .byte.b	CL3	; 15
    775  536f		       04		      .byte.b	CL4	; 12
    776  5370		       03		      .byte.b	CL3	; 9
    777  5371		       02		      .byte.b	CL2	; 6
    778  5372		       02		      .byte.b	CL2	; 3
    779  5373		       00		      .byte.b	CL0	; 0
    780  5374
    781  5374				   FRAMEDATA_blink
    782  5374		       34		      .byte.b	52	; 23
    783  5375		       28		      .byte.b	40	; 20
    784  5376		       38		      .byte.b	56	; 17
    785  5377		       ba		      .byte.b	186	; 14
    786  5378		       fc		      .byte.b	252	; 11
    787  5379		       18		      .byte.b	24	; 8
    788  537a		       18		      .byte.b	24	; 5
    789  537b		       04		      .byte.b	4	; 2
    790  537c		       00		      .byte.b	0	; 22
    791  537d		       28		      .byte.b	40	; 19
    792  537e		       18		      .byte.b	24	; 16
    793  537f		       ba		      .byte.b	186	; 13
    794  5380		       7c		      .byte.b	124	; 10
    795  5381		       18		      .byte.b	24	; 7
    796  5382		       0c		      .byte.b	12	; 4
    797  5383		       1e		      .byte.b	30	; 1
    798  5384		       28		      .byte.b	40	; 21
    799  5385		       28		      .byte.b	40	; 18
    800  5386		       b2		      .byte.b	178	; 15
    801  5387		       bc		      .byte.b	188	; 12
    802  5388		       38		      .byte.b	56	; 9
    803  5389		       1c		      .byte.b	28	; 6
    804  538a		       0e		      .byte.b	14	; 3
    805  538b		       1d		      .byte.b	29	; 0
    806  538c
    807  538c				   COLOURDATA_blink
    808  538c		       06		      .byte.b	CL6	; 23
    809  538d		       05		      .byte.b	CL5	; 20
    810  538e		       05		      .byte.b	CL5	; 17
    811  538f		       03		      .byte.b	CL3	; 14
    812  5390		       04		      .byte.b	CL4	; 11
    813  5391		       03		      .byte.b	CL3	; 8
    814  5392		       02		      .byte.b	CL2	; 5
    815  5393		       02		      .byte.b	CL2	; 2
    816  5394		       00		      .byte.b	CL0	; 22
    817  5395		       05		      .byte.b	CL5	; 19
    818  5396		       05		      .byte.b	CL5	; 16
    819  5397		       04		      .byte.b	CL4	; 13
    820  5398		       04		      .byte.b	CL4	; 10
    821  5399		       02		      .byte.b	CL2	; 7
    822  539a		       02		      .byte.b	CL2	; 4
    823  539b		       01		      .byte.b	CL1	; 1
    824  539c		       05		      .byte.b	CL5	; 21
    825  539d		       05		      .byte.b	CL5	; 18
    826  539e		       02		      .byte.b	CL2	; 15
    827  539f		       04		      .byte.b	CL4	; 12
    828  53a0		       04		      .byte.b	CL4	; 9
    829  53a1		       02		      .byte.b	CL2	; 6
    830  53a2		       02		      .byte.b	CL2	; 3
    831  53a3		       01		      .byte.b	CL1	; 0
    832  53a4
    833  53a4				   FRAMEDATA_yell
    834  53a4		       34		      .byte.b	52	; 23
    835  53a5		       28		      .byte.b	40	; 20
    836  53a6		       18		      .byte.b	24	; 17
    837  53a7		       b8		      .byte.b	184	; 14
    838  53a8		       7e		      .byte.b	126	; 11
    839  53a9		       32		      .byte.b	50	; 8
    840  53aa		       72		      .byte.b	114	; 5
    841  53ab		       40		      .byte.b	64	; 2
    842  53ac		       00		      .byte.b	0	; 22
    843  53ad		       28		      .byte.b	40	; 19
    844  53ae		       b0		      .byte.b	176	; 16
    845  53af		       b8		      .byte.b	184	; 13
    846  53b0		       7a		      .byte.b	122	; 10
    847  53b1		       36		      .byte.b	54	; 7
    848  53b2		       58		      .byte.b	88	; 4
    849  53b3		       78		      .byte.b	120	; 1
    850  53b4		       28		      .byte.b	40	; 21
    851  53b5		       28		      .byte.b	40	; 18
    852  53b6		       b8		      .byte.b	184	; 15
    853  53b7		       fc		      .byte.b	252	; 12
    854  53b8		       32		      .byte.b	50	; 9
    855  53b9		       62		      .byte.b	98	; 6
    856  53ba		       30		      .byte.b	48	; 3
    857  53bb		       34		      .byte.b	52	; 0
    858  53bc
    859  53bc				   COLOURDATA_yell
    860  53bc		       06		      .byte.b	CL6	; 23
    861  53bd		       05		      .byte.b	CL5	; 20
    862  53be		       05		      .byte.b	CL5	; 17
    863  53bf		       04		      .byte.b	CL4	; 14
    864  53c0		       04		      .byte.b	CL4	; 11
    865  53c1		       02		      .byte.b	CL2	; 8
    866  53c2		       02		      .byte.b	CL2	; 5
    867  53c3		       01		      .byte.b	CL1	; 2
    868  53c4		       00		      .byte.b	CL0	; 22
    869  53c5		       05		      .byte.b	CL5	; 19
    870  53c6		       02		      .byte.b	CL2	; 16
    871  53c7		       04		      .byte.b	CL4	; 13
    872  53c8		       04		      .byte.b	CL4	; 10
    873  53c9		       02		      .byte.b	CL2	; 7
    874  53ca		       02		      .byte.b	CL2	; 4
    875  53cb		       01		      .byte.b	CL1	; 1
    876  53cc		       05		      .byte.b	CL5	; 21
    877  53cd		       05		      .byte.b	CL5	; 18
    878  53ce		       03		      .byte.b	CL3	; 15
    879  53cf		       04		      .byte.b	CL4	; 12
    880  53d0		       03		      .byte.b	CL3	; 9
    881  53d1		       02		      .byte.b	CL2	; 6
    882  53d2		       02		      .byte.b	CL2	; 3
    883  53d3		       01		      .byte.b	CL1	; 0
    884  53d4
    885  53d4				   FRAMEDATA_look2
    886  53d4		       34		      .byte.b	52	; 23
    887  53d5		       28		      .byte.b	40	; 20
    888  53d6		       38		      .byte.b	56	; 17
    889  53d7		       ba		      .byte.b	186	; 14
    890  53d8		       fc		      .byte.b	252	; 11
    891  53d9		       30		      .byte.b	48	; 8
    892  53da		       10		      .byte.b	16	; 5
    893  53db		       70		      .byte.b	112	; 2
    894  53dc		       00		      .byte.b	0	; 22
    895  53dd		       28		      .byte.b	40	; 19
    896  53de		       18		      .byte.b	24	; 16
    897  53df		       ba		      .byte.b	186	; 13
    898  53e0		       7c		      .byte.b	124	; 10
    899  53e1		       30		      .byte.b	48	; 7
    900  53e2		       78		      .byte.b	120	; 4
    901  53e3		       78		      .byte.b	120	; 1
    902  53e4		       28		      .byte.b	40	; 21
    903  53e5		       28		      .byte.b	40	; 18
    904  53e6		       b2		      .byte.b	178	; 15
    905  53e7		       bc		      .byte.b	188	; 12
    906  53e8		       38		      .byte.b	56	; 9
    907  53e9		       30		      .byte.b	48	; 6
    908  53ea		       28		      .byte.b	40	; 3
    909  53eb		       b8		      .byte.b	184	; 0
    910  53ec
    911  53ec				   COLOURDATA_look2
    912  53ec		       06		      .byte.b	CL6	; 23
    913  53ed		       05		      .byte.b	CL5	; 20
    914  53ee		       05		      .byte.b	CL5	; 17
    915  53ef		       03		      .byte.b	CL3	; 14
    916  53f0		       04		      .byte.b	CL4	; 11
    917  53f1		       03		      .byte.b	CL3	; 8
    918  53f2		       02		      .byte.b	CL2	; 5
    919  53f3		       02		      .byte.b	CL2	; 2
    920  53f4		       00		      .byte.b	CL0	; 22
    921  53f5		       05		      .byte.b	CL5	; 19
    922  53f6		       05		      .byte.b	CL5	; 16
    923  53f7		       04		      .byte.b	CL4	; 13
    924  53f8		       04		      .byte.b	CL4	; 10
    925  53f9		       02		      .byte.b	CL2	; 7
    926  53fa		       02		      .byte.b	CL2	; 4
    927  53fb		       01		      .byte.b	CL1	; 1
    928  53fc		       05		      .byte.b	CL5	; 21
    929  53fd		       05		      .byte.b	CL5	; 18
    930  53fe		       02		      .byte.b	CL2	; 15
    931  53ff		       04		      .byte.b	CL4	; 12
    932  5400		       04		      .byte.b	CL4	; 9
    933  5401		       02		      .byte.b	CL2	; 6
    934  5402		       02		      .byte.b	CL2	; 3
    935  5403		       01		      .byte.b	CL1	; 0
    936  5404
    937  5404				   FRAMEDATA_look3
    938  5404		       34		      .byte.b	52	; 23
    939  5405		       28		      .byte.b	40	; 20
    940  5406		       38		      .byte.b	56	; 17
    941  5407		       ba		      .byte.b	186	; 14
    942  5408		       fc		      .byte.b	252	; 11
    943  5409		       18		      .byte.b	24	; 8
    944  540a		       10		      .byte.b	16	; 5
    945  540b		       1c		      .byte.b	28	; 2
    946  540c		       00		      .byte.b	0	; 22
    947  540d		       28		      .byte.b	40	; 19
    948  540e		       18		      .byte.b	24	; 16
    949  540f		       ba		      .byte.b	186	; 13
    950  5410		       7c		      .byte.b	124	; 10
    951  5411		       18		      .byte.b	24	; 7
    952  5412		       3c		      .byte.b	60	; 4
    953  5413		       3c		      .byte.b	60	; 1
    954  5414		       28		      .byte.b	40	; 21
    955  5415		       28		      .byte.b	40	; 18
    956  5416		       b2		      .byte.b	178	; 15
    957  5417		       bc		      .byte.b	188	; 12
    958  5418		       38		      .byte.b	56	; 9
    959  5419		       18		      .byte.b	24	; 6
    960  541a		       28		      .byte.b	40	; 3
    961  541b		       3a		      .byte.b	58	; 0
    962  541c
    963  541c				   COLOURDATA_look3
    964  541c		       06		      .byte.b	CL6	; 23
    965  541d		       05		      .byte.b	CL5	; 20
    966  541e		       05		      .byte.b	CL5	; 17
    967  541f		       03		      .byte.b	CL3	; 14
    968  5420		       04		      .byte.b	CL4	; 11
    969  5421		       03		      .byte.b	CL3	; 8
    970  5422		       02		      .byte.b	CL2	; 5
    971  5423		       02		      .byte.b	CL2	; 2
    972  5424		       00		      .byte.b	CL0	; 22
    973  5425		       05		      .byte.b	CL5	; 19
    974  5426		       05		      .byte.b	CL5	; 16
    975  5427		       04		      .byte.b	CL4	; 13
    976  5428		       04		      .byte.b	CL4	; 10
    977  5429		       02		      .byte.b	CL2	; 7
    978  542a		       02		      .byte.b	CL2	; 4
    979  542b		       01		      .byte.b	CL1	; 1
    980  542c		       05		      .byte.b	CL5	; 21
    981  542d		       05		      .byte.b	CL5	; 18
    982  542e		       02		      .byte.b	CL2	; 15
    983  542f		       04		      .byte.b	CL4	; 12
    984  5430		       04		      .byte.b	CL4	; 9
    985  5431		       02		      .byte.b	CL2	; 6
    986  5432		       02		      .byte.b	CL2	; 3
    987  5433		       01		      .byte.b	CL1	; 0
    988  5434
    989  5434				   FRAMEDATA_look1
    990  5434		       34		      .byte.b	52	; 23
    991  5435		       14		      .byte.b	20	; 20
    992  5436		       18		      .byte.b	24	; 17
    993  5437		       59		      .byte.b	89	; 14
    994  5438		       7c		      .byte.b	124	; 11
    995  5439		       18		      .byte.b	24	; 8
    996  543a		       18		      .byte.b	24	; 5
    997  543b		       20		      .byte.b	32	; 2
    998  543c		       00		      .byte.b	0	; 22
    999  543d		       14		      .byte.b	20	; 19
   1000  543e		       18		      .byte.b	24	; 16
   1001  543f		       5a		      .byte.b	90	; 13
   1002  5440		       3c		      .byte.b	60	; 10
   1003  5441		       18		      .byte.b	24	; 7
   1004  5442		       30		      .byte.b	48	; 4
   1005  5443		       78		      .byte.b	120	; 1
   1006  5444		       14		      .byte.b	20	; 21
   1007  5445		       14		      .byte.b	20	; 18
   1008  5446		       31		      .byte.b	49	; 15
   1009  5447		       7e		      .byte.b	126	; 12
   1010  5448		       18		      .byte.b	24	; 9
   1011  5449		       38		      .byte.b	56	; 6
   1012  544a		       50		      .byte.b	80	; 3
   1013  544b		       b8		      .byte.b	184	; 0
   1014  544c
   1015  544c				   COLOURDATA_look1
   1016  544c		       06		      .byte.b	CL6	; 23
   1017  544d		       05		      .byte.b	CL5	; 20
   1018  544e		       05		      .byte.b	CL5	; 17
   1019  544f		       03		      .byte.b	CL3	; 14
   1020  5450		       04		      .byte.b	CL4	; 11
   1021  5451		       03		      .byte.b	CL3	; 8
   1022  5452		       02		      .byte.b	CL2	; 5
   1023  5453		       02		      .byte.b	CL2	; 2
   1024  5454		       00		      .byte.b	CL0	; 22
   1025  5455		       05		      .byte.b	CL5	; 19
   1026  5456		       05		      .byte.b	CL5	; 16
   1027  5457		       04		      .byte.b	CL4	; 13
   1028  5458		       04		      .byte.b	CL4	; 10
   1029  5459		       02		      .byte.b	CL2	; 7
   1030  545a		       02		      .byte.b	CL2	; 4
   1031  545b		       01		      .byte.b	CL1	; 1
   1032  545c		       05		      .byte.b	CL5	; 21
   1033  545d		       05		      .byte.b	CL5	; 18
   1034  545e		       02		      .byte.b	CL2	; 15
   1035  545f		       04		      .byte.b	CL4	; 12
   1036  5460		       04		      .byte.b	CL4	; 9
   1037  5461		       02		      .byte.b	CL2	; 6
   1038  5462		       02		      .byte.b	CL2	; 3
   1039  5463		       01		      .byte.b	CL1	; 0
   1040  5464
   1041  5464				   FRAMEDATA_tapfoot
   1042  5464		       24		      .byte.b	36	; 23
   1043  5465		       28		      .byte.b	40	; 20
   1044  5466		       38		      .byte.b	56	; 17
   1045  5467		       ba		      .byte.b	186	; 14
   1046  5468		       fc		      .byte.b	252	; 11
   1047  5469		       18		      .byte.b	24	; 8
   1048  546a		       18		      .byte.b	24	; 5
   1049  546b		       04		      .byte.b	4	; 2
   1050  546c		       10		      .byte.b	16	; 22
   1051  546d		       28		      .byte.b	40	; 19
   1052  546e		       18		      .byte.b	24	; 16
   1053  546f		       ba		      .byte.b	186	; 13
   1054  5470		       7c		      .byte.b	124	; 10
   1055  5471		       18		      .byte.b	24	; 7
   1056  5472		       0c		      .byte.b	12	; 4
   1057  5473		       1e		      .byte.b	30	; 1
   1058  5474		       28		      .byte.b	40	; 21
   1059  5475		       28		      .byte.b	40	; 18
   1060  5476		       b2		      .byte.b	178	; 15
   1061  5477		       bc		      .byte.b	188	; 12
   1062  5478		       38		      .byte.b	56	; 9
   1063  5479		       1c		      .byte.b	28	; 6
   1064  547a		       0a		      .byte.b	10	; 3
   1065  547b		       1d		      .byte.b	29	; 0
   1066  547c
   1067  547c				   COLOURDATA_tapfoot
   1068  547c		       06		      .byte.b	CL6	; 23
   1069  547d		       05		      .byte.b	CL5	; 20
   1070  547e		       05		      .byte.b	CL5	; 17
   1071  547f		       03		      .byte.b	CL3	; 14
   1072  5480		       04		      .byte.b	CL4	; 11
   1073  5481		       03		      .byte.b	CL3	; 8
   1074  5482		       02		      .byte.b	CL2	; 5
   1075  5483		       02		      .byte.b	CL2	; 2
   1076  5484		       06		      .byte.b	CL6	; 22
   1077  5485		       05		      .byte.b	CL5	; 19
   1078  5486		       05		      .byte.b	CL5	; 16
   1079  5487		       04		      .byte.b	CL4	; 13
   1080  5488		       04		      .byte.b	CL4	; 10
   1081  5489		       02		      .byte.b	CL2	; 7
   1082  548a		       02		      .byte.b	CL2	; 4
   1083  548b		       01		      .byte.b	CL1	; 1
   1084  548c		       05		      .byte.b	CL5	; 21
   1085  548d		       05		      .byte.b	CL5	; 18
   1086  548e		       02		      .byte.b	CL2	; 15
   1087  548f		       04		      .byte.b	CL4	; 12
   1088  5490		       04		      .byte.b	CL4	; 9
   1089  5491		       02		      .byte.b	CL2	; 6
   1090  5492		       02		      .byte.b	CL2	; 3
   1091  5493		       01		      .byte.b	CL1	; 0
   1092  5494
   1093  5494
   1094  5494				   __FNUM     SET	0
   1095  5494					      MAC	deframe
   1096  5494				   FRAME_{1}  =	__FNUM
   1097  5494				   __FNUM     SET	__FNUM + 1
   1098  5494					      ENDM		;{name}
   1099  5494
      0  5494					      DEFRAME	CROUCH1
      1  5494		       00 00	   FRAME_CROUCH1 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	WALK1
      1  5494		       00 01	   FRAME_WALK1 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	WALK2
      1  5494		       00 02	   FRAME_WALK2 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	HANDLIP
      1  5494		       00 03	   FRAME_HANDLIP =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	LOOKUP
      1  5494		       00 04	   FRAME_LOOKUP =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	WALK3
      1  5494		       00 05	   FRAME_WALK3 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	PUSH_UP_1
      1  5494		       00 06	   FRAME_PUSH_UP_1 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	PUSH_UP_3
      1  5494		       00 07	   FRAME_PUSH_UP_3 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	PUSH_UP_2
      1  5494		       00 08	   FRAME_PUSH_UP_2 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	PUSH3
      1  5494		       00 09	   FRAME_PUSH3 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	IDLE3
      1  5494		       00 0a	   FRAME_IDLE3 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	IDLE2
      1  5494		       00 0b	   FRAME_IDLE2 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	PUSH2
      1  5494		       00 0c	   FRAME_PUSH2 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	IDLE1
      1  5494		       00 0d	   FRAME_IDLE1 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	PUSH1
      1  5494		       00 0e	   FRAME_PUSH1 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	BLINK
      1  5494		       00 0f	   FRAME_BLINK =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	YELL
      1  5494		       00 10	   FRAME_YELL =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	LOOK2
      1  5494		       00 11	   FRAME_LOOK2 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	LOOK3
      1  5494		       00 12	   FRAME_LOOK3 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	LOOK1
      1  5494		       00 13	   FRAME_LOOK1 =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
      0  5494					      DEFRAME	TAPFOOT
      1  5494		       00 14	   FRAME_TAPFOOT =	__FNUM
      2  5494				   __FNUM     SET	__FNUM + 1
   1121  5494
   1122  5494				   FRAME_PTR_LO
   1123  5494		       a4		      .byte.b	<FRAMEDATA_crouch1
   1124  5495		       d4		      .byte.b	<FRAMEDATA_walk1
   1125  5496		       04		      .byte.b	<FRAMEDATA_walk2
   1126  5497		       34		      .byte.b	<FRAMEDATA_handlip
   1127  5498		       64		      .byte.b	<FRAMEDATA_lookup
   1128  5499		       94		      .byte.b	<FRAMEDATA_walk3
   1129  549a		       c4		      .byte.b	<FRAMEDATA_push_up_1
   1130  549b		       f4		      .byte.b	<FRAMEDATA_push_up_3
   1131  549c		       24		      .byte.b	<FRAMEDATA_push_up_2
   1132  549d		       54		      .byte.b	<FRAMEDATA_push3
   1133  549e		       84		      .byte.b	<FRAMEDATA_idle3
   1134  549f		       b4		      .byte.b	<FRAMEDATA_idle2
   1135  54a0		       e4		      .byte.b	<FRAMEDATA_push2
   1136  54a1		       14		      .byte.b	<FRAMEDATA_idle1
   1137  54a2		       44		      .byte.b	<FRAMEDATA_push1
   1138  54a3		       74		      .byte.b	<FRAMEDATA_blink
   1139  54a4		       a4		      .byte.b	<FRAMEDATA_yell
   1140  54a5		       d4		      .byte.b	<FRAMEDATA_look2
   1141  54a6		       04		      .byte.b	<FRAMEDATA_look3
   1142  54a7		       34		      .byte.b	<FRAMEDATA_look1
   1143  54a8		       64		      .byte.b	<FRAMEDATA_tapfoot
   1144  54a9
   1145  54a9				   FRAME_PTR_HI
   1146  54a9		       f0		      .byte.b	>FRAMEDATA_crouch1
   1147  54aa		       f0		      .byte.b	>FRAMEDATA_walk1
   1148  54ab		       f1		      .byte.b	>FRAMEDATA_walk2
   1149  54ac		       f1		      .byte.b	>FRAMEDATA_handlip
   1150  54ad		       f1		      .byte.b	>FRAMEDATA_lookup
   1151  54ae		       f1		      .byte.b	>FRAMEDATA_walk3
   1152  54af		       f1		      .byte.b	>FRAMEDATA_push_up_1
   1153  54b0		       f1		      .byte.b	>FRAMEDATA_push_up_3
   1154  54b1		       f2		      .byte.b	>FRAMEDATA_push_up_2
   1155  54b2		       f2		      .byte.b	>FRAMEDATA_push3
   1156  54b3		       f2		      .byte.b	>FRAMEDATA_idle3
   1157  54b4		       f2		      .byte.b	>FRAMEDATA_idle2
   1158  54b5		       f2		      .byte.b	>FRAMEDATA_push2
   1159  54b6		       f3		      .byte.b	>FRAMEDATA_idle1
   1160  54b7		       f3		      .byte.b	>FRAMEDATA_push1
   1161  54b8		       f3		      .byte.b	>FRAMEDATA_blink
   1162  54b9		       f3		      .byte.b	>FRAMEDATA_yell
   1163  54ba		       f3		      .byte.b	>FRAMEDATA_look2
   1164  54bb		       f4		      .byte.b	>FRAMEDATA_look3
   1165  54bc		       f4		      .byte.b	>FRAMEDATA_look1
   1166  54bd		       f4		      .byte.b	>FRAMEDATA_tapfoot
   1167  54be
   1168  54be				   COLOUR_PTR_LO
   1169  54be		       bc		      .byte.b	<COLOURDATA_crouch1
   1170  54bf		       ec		      .byte.b	<COLOURDATA_walk1
   1171  54c0		       1c		      .byte.b	<COLOURDATA_walk2
   1172  54c1		       4c		      .byte.b	<COLOURDATA_handlip
   1173  54c2		       7c		      .byte.b	<COLOURDATA_lookup
   1174  54c3		       ac		      .byte.b	<COLOURDATA_walk3
   1175  54c4		       dc		      .byte.b	<COLOURDATA_push_up_1
   1176  54c5		       0c		      .byte.b	<COLOURDATA_push_up_3
   1177  54c6		       3c		      .byte.b	<COLOURDATA_push_up_2
   1178  54c7		       6c		      .byte.b	<COLOURDATA_push3
   1179  54c8		       9c		      .byte.b	<COLOURDATA_idle3
   1180  54c9		       cc		      .byte.b	<COLOURDATA_idle2
   1181  54ca		       fc		      .byte.b	<COLOURDATA_push2
   1182  54cb		       2c		      .byte.b	<COLOURDATA_idle1
   1183  54cc		       5c		      .byte.b	<COLOURDATA_push1
   1184  54cd		       8c		      .byte.b	<COLOURDATA_blink
   1185  54ce		       bc		      .byte.b	<COLOURDATA_yell
   1186  54cf		       ec		      .byte.b	<COLOURDATA_look2
   1187  54d0		       1c		      .byte.b	<COLOURDATA_look3
   1188  54d1		       4c		      .byte.b	<COLOURDATA_look1
   1189  54d2		       7c		      .byte.b	<COLOURDATA_tapfoot
   1190  54d3
   1191  54d3				   COLOUR_PTR_HI
   1192  54d3		       f0		      .byte.b	>COLOURDATA_crouch1
   1193  54d4		       f0		      .byte.b	>COLOURDATA_walk1
   1194  54d5		       f1		      .byte.b	>COLOURDATA_walk2
   1195  54d6		       f1		      .byte.b	>COLOURDATA_handlip
   1196  54d7		       f1		      .byte.b	>COLOURDATA_lookup
   1197  54d8		       f1		      .byte.b	>COLOURDATA_walk3
   1198  54d9		       f1		      .byte.b	>COLOURDATA_push_up_1
   1199  54da		       f2		      .byte.b	>COLOURDATA_push_up_3
   1200  54db		       f2		      .byte.b	>COLOURDATA_push_up_2
   1201  54dc		       f2		      .byte.b	>COLOURDATA_push3
   1202  54dd		       f2		      .byte.b	>COLOURDATA_idle3
   1203  54de		       f2		      .byte.b	>COLOURDATA_idle2
   1204  54df		       f2		      .byte.b	>COLOURDATA_push2
   1205  54e0		       f3		      .byte.b	>COLOURDATA_idle1
   1206  54e1		       f3		      .byte.b	>COLOURDATA_push1
   1207  54e2		       f3		      .byte.b	>COLOURDATA_blink
   1208  54e3		       f3		      .byte.b	>COLOURDATA_yell
   1209  54e4		       f3		      .byte.b	>COLOURDATA_look2
   1210  54e5		       f4		      .byte.b	>COLOURDATA_look3
   1211  54e6		       f4		      .byte.b	>COLOURDATA_look1
   1212  54e7		       f4		      .byte.b	>COLOURDATA_tapfoot
------- FILE BANK_PlayerFrames.asm
    214  54e8
      0  54e8					      CHECK_BANK_SIZE	"PLAYER_FRAMES"
      1  54e8		       04 e8	   .TEMP      =	* - BANK_START
 PLAYER_FRAMES (2K) SIZE =  $4e8 , FREE= $318
      2  54e8					      ECHO	"PLAYER_FRAMES", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  54e8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  54e8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  54e8				  -	      ERR
      6  54e8					      endif
------- FILE ./sokoboo.asm
------- FILE titleScreen.asm LEVEL 2 PASS 3
      0  54e8					      include	"titleScreen.asm"
      0  54e8					      NEWBANK	TITLESCREEN
      1  5c6b ????				      SEG	TITLESCREEN
      2  5800					      ORG	ORIGIN
      3  5800					      RORG	$F000
      4  5800				   BANK_START SET	*
      5  5800				   TITLESCREEN SET	ORIGIN / 2048
      6  5800				   ORIGIN     SET	ORIGIN + 2048
      7  5800				   _CURRENT_BANK SET	TITLESCREEN
      0  5800					      DEFINE_SUBROUTINE	TitleScreen
      1  5800		       00 0b	   BANK_TitleScreen =	_CURRENT_BANK
      2  5800					      SUBROUTINE
      3  5800				   TitleScreen
      3  5800
      4  5800							; Start of new frame
      5  5800
      6  5800							; Start of vertical blank processing
      7  5800
      8  5800				   TitleSequence
      9  5800
     10  5800		       a9 00		      lda	#%00000000
     11  5802		       85 4a		      sta	CTRLPF
     12  5804		       85 49		      sta	COLUBK
     13  5806
     14  5806		       a6 80		      ldx	Platform
     15  5808		       bd a7 f0 	      lda	colvec,x
     16  580b		       85 db		      sta	colour_table
     17  580d		       bd a8 f0 	      lda	colvec+1,x
     18  5810		       85 dc		      sta	colour_table+1
     19  5812
      0  5812					      RESYNC
      1  5812
      2  5812		       a9 02		      lda	#%10
      3  5814		       85 41		      sta	VBLANK
      4  5816
      5  5816		       a2 08		      ldx	#8
      6  5818				   .loopResync
      0  5818					      VERTICAL_SYNC
      1  5818		       a9 0e		      lda	#%1110
      2  581a		       85 42	   .VSLP1     sta	WSYNC
      3  581c		       85 40		      sta	VSYNC
      4  581e		       4a		      lsr
      5  581f		       d0 f9		      bne	.VSLP1
      8  5821
      9  5821		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  5823		       a5 80		      lda	Platform
     11  5825		       49 02		      eor	#PAL_50
     12  5827		       d0 02		      bne	.ntsc
     13  5829		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  582b				   .ntsc
     15  582b				   .loopWait
     16  582b		       85 42		      sta	WSYNC
     17  582d		       85 42		      sta	WSYNC
     18  582f		       88		      dey
     19  5830		       d0 f9		      bne	.loopWait
     20  5832		       ca		      dex
     21  5833		       d0 e3		      bne	.loopResync
     21  5835
      0  5835					      DEFINE_SUBROUTINE	RestartFrame
      1  5835		       00 0b	   BANK_RestartFrame =	_CURRENT_BANK
      2  5835					      SUBROUTINE
      3  5835				   RestartFrame
     23  5835		       a9 0e		      lda	#%1110	; VSYNC ON
     24  5837		       85 42	   .loopVSync2 sta	WSYNC
     25  5839		       85 40		      sta	VSYNC
     26  583b		       4a		      lsr
     27  583c		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     28  583e
     29  583e							;------------------------------------------------------------------
     30  583e
     31  583e		       a6 80		      ldx	Platform
     32  5840		       bc 94 fc 	      ldy	VBlankTime,x
     33  5843		       8c 96 02 	      sty	TIM64T
     34  5846
     35  5846		       85 42	   VerticalBlank sta	WSYNC
     36  5848		       ad 84 02 	      lda	INTIM
     37  584b		       d0 f9		      bne	VerticalBlank
     38  584d		       85 41		      sta	VBLANK
     39  584f
     40  584f
     41  584f							;------------------------------------------------------------------
     42  584f
     43  584f							; Do X scanlines of color-changing (our picture)
     44  584f
     45  584f		       a0 77		      ldy	#119	; this counts our scanline number
     46  5851		       a2 03	   SokoLogo   ldx	#3
     47  5853		       b1 db	   triplet    lda	(colour_table),y
     48  5855		       85 42		      sta	WSYNC
     49  5857		       85 48		      sta	COLUPF	; 3
     50  5859
     51  5859		       b9 9b f1 	      lda	COL_0,y	; 5
     52  585c		       85 4d		      sta	PF0	; 3   @11
     53  585e		       b9 13 f2 	      lda	COL_1,y	; 5
     54  5861		       85 4e		      sta	PF1	; 3   @19
     55  5863		       b9 8b f2 	      lda	COL_2,y	; 5
     56  5866		       85 4f		      sta	PF2	; 3   @27
     57  5868
     58  5868		       b9 03 f3 	      lda	COL_3,y	; 5
     59  586b		       85 4d		      sta	PF0	; 3   @35
      0  586d					      SLEEP	2	; @37
      1  586d				   .CYCLES    SET	2
      2  586d
      3  586d				  -	      IF	.CYCLES < 2
      4  586d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  586d				  -	      ERR
      6  586d					      ENDIF
      7  586d
      8  586d				  -	      IF	.CYCLES & 1
      9  586d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  586d				  -	      nop	0
     11  586d				  -	      ELSE
     12  586d				  -	      bit	VSYNC
     13  586d				  -	      ENDIF
     14  586d				  -.CYCLES    SET	.CYCLES - 3
     15  586d					      ENDIF
     16  586d
     17  586d					      REPEAT	.CYCLES / 2
     18  586d		       ea		      nop
     19  586e					      REPEND
     61  586e		       b9 7b f3 	      lda	COL_4,y	; 5
     62  5871		       85 4e		      sta	PF1	; 3   @45
      0  5873					      SLEEP	3	; @45
      1  5873				   .CYCLES    SET	3
      2  5873
      3  5873				  -	      IF	.CYCLES < 2
      4  5873				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  5873				  -	      ERR
      6  5873					      ENDIF
      7  5873
      8  5873					      IF	.CYCLES & 1
      9  5873					      IFNCONST	NO_ILLEGAL_OPCODES
     10  5873		       04 00		      nop	0
     11  5875				  -	      ELSE
     12  5875				  -	      bit	VSYNC
     13  5875					      ENDIF
     14  5875				   .CYCLES    SET	.CYCLES - 3
     15  5875					      ENDIF
     16  5875
     17  5875				  -	      REPEAT	.CYCLES / 2
     18  5875				  -	      nop
     19  5875					      REPEND
     64  5875		       b9 f3 f3 	      lda	COL_5,y	; 5
     65  5878		       85 4f		      sta	PF2	; 3
     66  587a
     67  587a		       88		      dey		; 2
     68  587b		       ca		      dex		; 2
     69  587c		       d0 d5		      bne	triplet	; 2(3)
     70  587e
     71  587e		       c0 ff		      cpy	#-1	; 2
     72  5880		       d0 cf		      bne	SokoLogo	; 2(3)
     73  5882
     74  5882		       a9 00		      lda	#0
     75  5884		       85 4d		      sta	PF0
     76  5886		       85 4e		      sta	PF1
     77  5888		       85 4f		      sta	PF2
     78  588a
     79  588a		       a6 80		      ldx	Platform
     80  588c		       bd a3 f0 	      lda	OverscanTime2,x
     81  588f		       8d 96 02 	      sta	TIM64T
     82  5892
     83  5892				  -	      if	0
     84  5892				  -	      sta	WSYNC
     85  5892				  -	      sta	WSYNC
     86  5892				  -	      sta	WSYNC
     87  5892				  -	      sta	WSYNC
     88  5892				  -	      sta	WSYNC
     89  5892				  -	      SLEEP	8
     90  5892				  -	      jsr	SokoScreen
     91  5892				  -
     92  5892				  -	      lda	#0
     93  5892				  -	      sta	BoardScrollX
     94  5892				  -	      sta	BoardScrollY
     95  5892					      endif
     96  5892
     97  5892							;		ldy #63
     98  5892							;bot2		 sta WSYNC
     99  5892							;		dey
    100  5892							;		bpl bot2
    101  5892
    102  5892							;--------------------------------------------------------------------------
    103  5892
    104  5892							;		lda #0
    105  5892							;		sta PF0
    106  5892							;		sta PF1
    107  5892							;		sta PF2
    108  5892
    109  5892
    110  5892
    111  5892							; D1 VBLANK turns off beam
    112  5892							; It needs to be turned on 37 scanlines later
    113  5892
    114  5892				   oscan
    115  5892		       ad 84 02 	      lda	INTIM
    116  5895		       d0 fb		      bne	oscan
    117  5897
    118  5897		       a9 42		      lda	#%01000010	; bit6 is not required
    119  5899		       85 41		      sta	VBLANK	; end of screen - enter blanking
    120  589b
    121  589b		       a5 4c		      lda	INPT4
    122  589d		       10 03		      bpl	ret
    123  589f
    124  589f		       4c 35 f0 	      jmp	RestartFrame
    125  58a2
    126  58a2		       60	   ret	      rts
    127  58a3
    128  58a3				   OverscanTime2
    129  58a3		       85 85		      .byte.b	133, 133
    130  58a5		       8b 8b		      .byte.b	139, 139
    131  58a7
    132  58a7				   colvec
    133  58a7		       23 f1 ab f0	      .word.w	colr_ntsc, colr_pal
    134  58ab
    135  58ab
    136  58ab					      MAC	lumtable
    137  58ab							; {4} MIN LUM 1
    138  58ab							; {5} MIN LUM 2
    139  58ab							; {6} MIN LUM 3
    140  58ab
    141  58ab				   .LUM1      SET	{4}*256
    142  58ab				   .LUM2      SET	{5}*256
    143  58ab				   .LUM3      SET	{6}*256
    144  58ab
    145  58ab				   .STEP1     =	(256*({7}-{4}))/40
    146  58ab				   .STEP2     =	(256*({8}-{5}))/40
    147  58ab				   .STEP3     =	(256*({9}-{6}))/40
    148  58ab
    149  58ab					      REPEAT	40
    150  58ab					      .byte	{1}+(.LUM1/256)
    151  58ab					      .byte	{2}+(.LUM2/256)
    152  58ab					      .byte	{3}+(.LUM3/256)
    153  58ab				   .LUM1      SET	.LUM1 + .STEP1
    154  58ab				   .LUM2      SET	.LUM2 + .STEP2
    155  58ab				   .LUM3      SET	.LUM3 + .STEP3
    156  58ab					      REPEND
    157  58ab					      ENDM		;{1}{2}{3} base colours
    158  58ab
    159  58ab							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
      0  58ab				   colr_pal   LUMTABLE	$b0, $70, $40, 6,7,8, $C,$E,$E
      1  58ab
      2  58ab
      3  58ab
      4  58ab
      5  58ab				   .LUM1      SET	6*256
      6  58ab				   .LUM2      SET	7*256
      7  58ab				   .LUM3      SET	8*256
      8  58ab
      9  58ab		       00 26	   .STEP1     =	(256*($C-6))/40
     10  58ab		       00 2c	   .STEP2     =	(256*($E-7))/40
     11  58ab		       00 26	   .STEP3     =	(256*($E-8))/40
     12  58ab
     13  58ab					      REPEAT	40
     14  58ab		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58ac		       77		      .byte.b	$70+(.LUM2/256)
     16  58ad		       48		      .byte.b	$40+(.LUM3/256)
     17  58ad				   .LUM1      SET	.LUM1 + .STEP1
     18  58ad				   .LUM2      SET	.LUM2 + .STEP2
     19  58ad				   .LUM3      SET	.LUM3 + .STEP3
     13  58ad					      REPEND
     14  58ae		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58af		       77		      .byte.b	$70+(.LUM2/256)
     16  58b0		       48		      .byte.b	$40+(.LUM3/256)
     17  58b0				   .LUM1      SET	.LUM1 + .STEP1
     18  58b0				   .LUM2      SET	.LUM2 + .STEP2
     19  58b0				   .LUM3      SET	.LUM3 + .STEP3
     13  58b0					      REPEND
     14  58b1		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58b2		       77		      .byte.b	$70+(.LUM2/256)
     16  58b3		       48		      .byte.b	$40+(.LUM3/256)
     17  58b3				   .LUM1      SET	.LUM1 + .STEP1
     18  58b3				   .LUM2      SET	.LUM2 + .STEP2
     19  58b3				   .LUM3      SET	.LUM3 + .STEP3
     13  58b3					      REPEND
     14  58b4		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58b5		       77		      .byte.b	$70+(.LUM2/256)
     16  58b6		       48		      .byte.b	$40+(.LUM3/256)
     17  58b6				   .LUM1      SET	.LUM1 + .STEP1
     18  58b6				   .LUM2      SET	.LUM2 + .STEP2
     19  58b6				   .LUM3      SET	.LUM3 + .STEP3
     13  58b6					      REPEND
     14  58b7		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58b8		       77		      .byte.b	$70+(.LUM2/256)
     16  58b9		       48		      .byte.b	$40+(.LUM3/256)
     17  58b9				   .LUM1      SET	.LUM1 + .STEP1
     18  58b9				   .LUM2      SET	.LUM2 + .STEP2
     19  58b9				   .LUM3      SET	.LUM3 + .STEP3
     13  58b9					      REPEND
     14  58ba		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58bb		       77		      .byte.b	$70+(.LUM2/256)
     16  58bc		       48		      .byte.b	$40+(.LUM3/256)
     17  58bc				   .LUM1      SET	.LUM1 + .STEP1
     18  58bc				   .LUM2      SET	.LUM2 + .STEP2
     19  58bc				   .LUM3      SET	.LUM3 + .STEP3
     13  58bc					      REPEND
     14  58bd		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58be		       78		      .byte.b	$70+(.LUM2/256)
     16  58bf		       48		      .byte.b	$40+(.LUM3/256)
     17  58bf				   .LUM1      SET	.LUM1 + .STEP1
     18  58bf				   .LUM2      SET	.LUM2 + .STEP2
     19  58bf				   .LUM3      SET	.LUM3 + .STEP3
     13  58bf					      REPEND
     14  58c0		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58c1		       78		      .byte.b	$70+(.LUM2/256)
     16  58c2		       49		      .byte.b	$40+(.LUM3/256)
     17  58c2				   .LUM1      SET	.LUM1 + .STEP1
     18  58c2				   .LUM2      SET	.LUM2 + .STEP2
     19  58c2				   .LUM3      SET	.LUM3 + .STEP3
     13  58c2					      REPEND
     14  58c3		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58c4		       78		      .byte.b	$70+(.LUM2/256)
     16  58c5		       49		      .byte.b	$40+(.LUM3/256)
     17  58c5				   .LUM1      SET	.LUM1 + .STEP1
     18  58c5				   .LUM2      SET	.LUM2 + .STEP2
     19  58c5				   .LUM3      SET	.LUM3 + .STEP3
     13  58c5					      REPEND
     14  58c6		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58c7		       78		      .byte.b	$70+(.LUM2/256)
     16  58c8		       49		      .byte.b	$40+(.LUM3/256)
     17  58c8				   .LUM1      SET	.LUM1 + .STEP1
     18  58c8				   .LUM2      SET	.LUM2 + .STEP2
     19  58c8				   .LUM3      SET	.LUM3 + .STEP3
     13  58c8					      REPEND
     14  58c9		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58ca		       78		      .byte.b	$70+(.LUM2/256)
     16  58cb		       49		      .byte.b	$40+(.LUM3/256)
     17  58cb				   .LUM1      SET	.LUM1 + .STEP1
     18  58cb				   .LUM2      SET	.LUM2 + .STEP2
     19  58cb				   .LUM3      SET	.LUM3 + .STEP3
     13  58cb					      REPEND
     14  58cc		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58cd		       78		      .byte.b	$70+(.LUM2/256)
     16  58ce		       49		      .byte.b	$40+(.LUM3/256)
     17  58ce				   .LUM1      SET	.LUM1 + .STEP1
     18  58ce				   .LUM2      SET	.LUM2 + .STEP2
     19  58ce				   .LUM3      SET	.LUM3 + .STEP3
     13  58ce					      REPEND
     14  58cf		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58d0		       79		      .byte.b	$70+(.LUM2/256)
     16  58d1		       49		      .byte.b	$40+(.LUM3/256)
     17  58d1				   .LUM1      SET	.LUM1 + .STEP1
     18  58d1				   .LUM2      SET	.LUM2 + .STEP2
     19  58d1				   .LUM3      SET	.LUM3 + .STEP3
     13  58d1					      REPEND
     14  58d2		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58d3		       79		      .byte.b	$70+(.LUM2/256)
     16  58d4		       49		      .byte.b	$40+(.LUM3/256)
     17  58d4				   .LUM1      SET	.LUM1 + .STEP1
     18  58d4				   .LUM2      SET	.LUM2 + .STEP2
     19  58d4				   .LUM3      SET	.LUM3 + .STEP3
     13  58d4					      REPEND
     14  58d5		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58d6		       79		      .byte.b	$70+(.LUM2/256)
     16  58d7		       4a		      .byte.b	$40+(.LUM3/256)
     17  58d7				   .LUM1      SET	.LUM1 + .STEP1
     18  58d7				   .LUM2      SET	.LUM2 + .STEP2
     19  58d7				   .LUM3      SET	.LUM3 + .STEP3
     13  58d7					      REPEND
     14  58d8		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58d9		       79		      .byte.b	$70+(.LUM2/256)
     16  58da		       4a		      .byte.b	$40+(.LUM3/256)
     17  58da				   .LUM1      SET	.LUM1 + .STEP1
     18  58da				   .LUM2      SET	.LUM2 + .STEP2
     19  58da				   .LUM3      SET	.LUM3 + .STEP3
     13  58da					      REPEND
     14  58db		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58dc		       79		      .byte.b	$70+(.LUM2/256)
     16  58dd		       4a		      .byte.b	$40+(.LUM3/256)
     17  58dd				   .LUM1      SET	.LUM1 + .STEP1
     18  58dd				   .LUM2      SET	.LUM2 + .STEP2
     19  58dd				   .LUM3      SET	.LUM3 + .STEP3
     13  58dd					      REPEND
     14  58de		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58df		       79		      .byte.b	$70+(.LUM2/256)
     16  58e0		       4a		      .byte.b	$40+(.LUM3/256)
     17  58e0				   .LUM1      SET	.LUM1 + .STEP1
     18  58e0				   .LUM2      SET	.LUM2 + .STEP2
     19  58e0				   .LUM3      SET	.LUM3 + .STEP3
     13  58e0					      REPEND
     14  58e1		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58e2		       7a		      .byte.b	$70+(.LUM2/256)
     16  58e3		       4a		      .byte.b	$40+(.LUM3/256)
     17  58e3				   .LUM1      SET	.LUM1 + .STEP1
     18  58e3				   .LUM2      SET	.LUM2 + .STEP2
     19  58e3				   .LUM3      SET	.LUM3 + .STEP3
     13  58e3					      REPEND
     14  58e4		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58e5		       7a		      .byte.b	$70+(.LUM2/256)
     16  58e6		       4a		      .byte.b	$40+(.LUM3/256)
     17  58e6				   .LUM1      SET	.LUM1 + .STEP1
     18  58e6				   .LUM2      SET	.LUM2 + .STEP2
     19  58e6				   .LUM3      SET	.LUM3 + .STEP3
     13  58e6					      REPEND
     14  58e7		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58e8		       7a		      .byte.b	$70+(.LUM2/256)
     16  58e9		       4a		      .byte.b	$40+(.LUM3/256)
     17  58e9				   .LUM1      SET	.LUM1 + .STEP1
     18  58e9				   .LUM2      SET	.LUM2 + .STEP2
     19  58e9				   .LUM3      SET	.LUM3 + .STEP3
     13  58e9					      REPEND
     14  58ea		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58eb		       7a		      .byte.b	$70+(.LUM2/256)
     16  58ec		       4b		      .byte.b	$40+(.LUM3/256)
     17  58ec				   .LUM1      SET	.LUM1 + .STEP1
     18  58ec				   .LUM2      SET	.LUM2 + .STEP2
     19  58ec				   .LUM3      SET	.LUM3 + .STEP3
     13  58ec					      REPEND
     14  58ed		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58ee		       7a		      .byte.b	$70+(.LUM2/256)
     16  58ef		       4b		      .byte.b	$40+(.LUM3/256)
     17  58ef				   .LUM1      SET	.LUM1 + .STEP1
     18  58ef				   .LUM2      SET	.LUM2 + .STEP2
     19  58ef				   .LUM3      SET	.LUM3 + .STEP3
     13  58ef					      REPEND
     14  58f0		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58f1		       7a		      .byte.b	$70+(.LUM2/256)
     16  58f2		       4b		      .byte.b	$40+(.LUM3/256)
     17  58f2				   .LUM1      SET	.LUM1 + .STEP1
     18  58f2				   .LUM2      SET	.LUM2 + .STEP2
     19  58f2				   .LUM3      SET	.LUM3 + .STEP3
     13  58f2					      REPEND
     14  58f3		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58f4		       7b		      .byte.b	$70+(.LUM2/256)
     16  58f5		       4b		      .byte.b	$40+(.LUM3/256)
     17  58f5				   .LUM1      SET	.LUM1 + .STEP1
     18  58f5				   .LUM2      SET	.LUM2 + .STEP2
     19  58f5				   .LUM3      SET	.LUM3 + .STEP3
     13  58f5					      REPEND
     14  58f6		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58f7		       7b		      .byte.b	$70+(.LUM2/256)
     16  58f8		       4b		      .byte.b	$40+(.LUM3/256)
     17  58f8				   .LUM1      SET	.LUM1 + .STEP1
     18  58f8				   .LUM2      SET	.LUM2 + .STEP2
     19  58f8				   .LUM3      SET	.LUM3 + .STEP3
     13  58f8					      REPEND
     14  58f9		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58fa		       7b		      .byte.b	$70+(.LUM2/256)
     16  58fb		       4b		      .byte.b	$40+(.LUM3/256)
     17  58fb				   .LUM1      SET	.LUM1 + .STEP1
     18  58fb				   .LUM2      SET	.LUM2 + .STEP2
     19  58fb				   .LUM3      SET	.LUM3 + .STEP3
     13  58fb					      REPEND
     14  58fc		       ba		      .byte.b	$b0+(.LUM1/256)
     15  58fd		       7b		      .byte.b	$70+(.LUM2/256)
     16  58fe		       4c		      .byte.b	$40+(.LUM3/256)
     17  58fe				   .LUM1      SET	.LUM1 + .STEP1
     18  58fe				   .LUM2      SET	.LUM2 + .STEP2
     19  58fe				   .LUM3      SET	.LUM3 + .STEP3
     13  58fe					      REPEND
     14  58ff		       ba		      .byte.b	$b0+(.LUM1/256)
     15  5900		       7b		      .byte.b	$70+(.LUM2/256)
     16  5901		       4c		      .byte.b	$40+(.LUM3/256)
     17  5901				   .LUM1      SET	.LUM1 + .STEP1
     18  5901				   .LUM2      SET	.LUM2 + .STEP2
     19  5901				   .LUM3      SET	.LUM3 + .STEP3
     13  5901					      REPEND
     14  5902		       ba		      .byte.b	$b0+(.LUM1/256)
     15  5903		       7b		      .byte.b	$70+(.LUM2/256)
     16  5904		       4c		      .byte.b	$40+(.LUM3/256)
     17  5904				   .LUM1      SET	.LUM1 + .STEP1
     18  5904				   .LUM2      SET	.LUM2 + .STEP2
     19  5904				   .LUM3      SET	.LUM3 + .STEP3
     13  5904					      REPEND
     14  5905		       ba		      .byte.b	$b0+(.LUM1/256)
     15  5906		       7c		      .byte.b	$70+(.LUM2/256)
     16  5907		       4c		      .byte.b	$40+(.LUM3/256)
     17  5907				   .LUM1      SET	.LUM1 + .STEP1
     18  5907				   .LUM2      SET	.LUM2 + .STEP2
     19  5907				   .LUM3      SET	.LUM3 + .STEP3
     13  5907					      REPEND
     14  5908		       ba		      .byte.b	$b0+(.LUM1/256)
     15  5909		       7c		      .byte.b	$70+(.LUM2/256)
     16  590a		       4c		      .byte.b	$40+(.LUM3/256)
     17  590a				   .LUM1      SET	.LUM1 + .STEP1
     18  590a				   .LUM2      SET	.LUM2 + .STEP2
     19  590a				   .LUM3      SET	.LUM3 + .STEP3
     13  590a					      REPEND
     14  590b		       ba		      .byte.b	$b0+(.LUM1/256)
     15  590c		       7c		      .byte.b	$70+(.LUM2/256)
     16  590d		       4c		      .byte.b	$40+(.LUM3/256)
     17  590d				   .LUM1      SET	.LUM1 + .STEP1
     18  590d				   .LUM2      SET	.LUM2 + .STEP2
     19  590d				   .LUM3      SET	.LUM3 + .STEP3
     13  590d					      REPEND
     14  590e		       ba		      .byte.b	$b0+(.LUM1/256)
     15  590f		       7c		      .byte.b	$70+(.LUM2/256)
     16  5910		       4c		      .byte.b	$40+(.LUM3/256)
     17  5910				   .LUM1      SET	.LUM1 + .STEP1
     18  5910				   .LUM2      SET	.LUM2 + .STEP2
     19  5910				   .LUM3      SET	.LUM3 + .STEP3
     13  5910					      REPEND
     14  5911		       bb		      .byte.b	$b0+(.LUM1/256)
     15  5912		       7c		      .byte.b	$70+(.LUM2/256)
     16  5913		       4d		      .byte.b	$40+(.LUM3/256)
     17  5913				   .LUM1      SET	.LUM1 + .STEP1
     18  5913				   .LUM2      SET	.LUM2 + .STEP2
     19  5913				   .LUM3      SET	.LUM3 + .STEP3
     13  5913					      REPEND
     14  5914		       bb		      .byte.b	$b0+(.LUM1/256)
     15  5915		       7d		      .byte.b	$70+(.LUM2/256)
     16  5916		       4d		      .byte.b	$40+(.LUM3/256)
     17  5916				   .LUM1      SET	.LUM1 + .STEP1
     18  5916				   .LUM2      SET	.LUM2 + .STEP2
     19  5916				   .LUM3      SET	.LUM3 + .STEP3
     13  5916					      REPEND
     14  5917		       bb		      .byte.b	$b0+(.LUM1/256)
     15  5918		       7d		      .byte.b	$70+(.LUM2/256)
     16  5919		       4d		      .byte.b	$40+(.LUM3/256)
     17  5919				   .LUM1      SET	.LUM1 + .STEP1
     18  5919				   .LUM2      SET	.LUM2 + .STEP2
     19  5919				   .LUM3      SET	.LUM3 + .STEP3
     13  5919					      REPEND
     14  591a		       bb		      .byte.b	$b0+(.LUM1/256)
     15  591b		       7d		      .byte.b	$70+(.LUM2/256)
     16  591c		       4d		      .byte.b	$40+(.LUM3/256)
     17  591c				   .LUM1      SET	.LUM1 + .STEP1
     18  591c				   .LUM2      SET	.LUM2 + .STEP2
     19  591c				   .LUM3      SET	.LUM3 + .STEP3
     13  591c					      REPEND
     14  591d		       bb		      .byte.b	$b0+(.LUM1/256)
     15  591e		       7d		      .byte.b	$70+(.LUM2/256)
     16  591f		       4d		      .byte.b	$40+(.LUM3/256)
     17  591f				   .LUM1      SET	.LUM1 + .STEP1
     18  591f				   .LUM2      SET	.LUM2 + .STEP2
     19  591f				   .LUM3      SET	.LUM3 + .STEP3
     13  591f					      REPEND
     14  5920		       bb		      .byte.b	$b0+(.LUM1/256)
     15  5921		       7d		      .byte.b	$70+(.LUM2/256)
     16  5922		       4d		      .byte.b	$40+(.LUM3/256)
     17  5922				   .LUM1      SET	.LUM1 + .STEP1
     18  5922				   .LUM2      SET	.LUM2 + .STEP2
     19  5922				   .LUM3      SET	.LUM3 + .STEP3
     20  5923					      REPEND
      0  5923				   colr_ntsc  LUMTABLE	$90,$B0,$20,5,6,7,$C,$E,$E
      1  5923
      2  5923
      3  5923
      4  5923
      5  5923				   .LUM1      SET	5*256
      6  5923				   .LUM2      SET	6*256
      7  5923				   .LUM3      SET	7*256
      8  5923
      9  5923		       00 2c	   .STEP1     =	(256*($C-5))/40
     10  5923		       00 33	   .STEP2     =	(256*($E-6))/40
     11  5923		       00 2c	   .STEP3     =	(256*($E-7))/40
     12  5923
     13  5923					      REPEAT	40
     14  5923		       95		      .byte.b	$90+(.LUM1/256)
     15  5924		       b6		      .byte.b	$B0+(.LUM2/256)
     16  5925		       27		      .byte.b	$20+(.LUM3/256)
     17  5925				   .LUM1      SET	.LUM1 + .STEP1
     18  5925				   .LUM2      SET	.LUM2 + .STEP2
     19  5925				   .LUM3      SET	.LUM3 + .STEP3
     13  5925					      REPEND
     14  5926		       95		      .byte.b	$90+(.LUM1/256)
     15  5927		       b6		      .byte.b	$B0+(.LUM2/256)
     16  5928		       27		      .byte.b	$20+(.LUM3/256)
     17  5928				   .LUM1      SET	.LUM1 + .STEP1
     18  5928				   .LUM2      SET	.LUM2 + .STEP2
     19  5928				   .LUM3      SET	.LUM3 + .STEP3
     13  5928					      REPEND
     14  5929		       95		      .byte.b	$90+(.LUM1/256)
     15  592a		       b6		      .byte.b	$B0+(.LUM2/256)
     16  592b		       27		      .byte.b	$20+(.LUM3/256)
     17  592b				   .LUM1      SET	.LUM1 + .STEP1
     18  592b				   .LUM2      SET	.LUM2 + .STEP2
     19  592b				   .LUM3      SET	.LUM3 + .STEP3
     13  592b					      REPEND
     14  592c		       95		      .byte.b	$90+(.LUM1/256)
     15  592d		       b6		      .byte.b	$B0+(.LUM2/256)
     16  592e		       27		      .byte.b	$20+(.LUM3/256)
     17  592e				   .LUM1      SET	.LUM1 + .STEP1
     18  592e				   .LUM2      SET	.LUM2 + .STEP2
     19  592e				   .LUM3      SET	.LUM3 + .STEP3
     13  592e					      REPEND
     14  592f		       95		      .byte.b	$90+(.LUM1/256)
     15  5930		       b6		      .byte.b	$B0+(.LUM2/256)
     16  5931		       27		      .byte.b	$20+(.LUM3/256)
     17  5931				   .LUM1      SET	.LUM1 + .STEP1
     18  5931				   .LUM2      SET	.LUM2 + .STEP2
     19  5931				   .LUM3      SET	.LUM3 + .STEP3
     13  5931					      REPEND
     14  5932		       95		      .byte.b	$90+(.LUM1/256)
     15  5933		       b6		      .byte.b	$B0+(.LUM2/256)
     16  5934		       27		      .byte.b	$20+(.LUM3/256)
     17  5934				   .LUM1      SET	.LUM1 + .STEP1
     18  5934				   .LUM2      SET	.LUM2 + .STEP2
     19  5934				   .LUM3      SET	.LUM3 + .STEP3
     13  5934					      REPEND
     14  5935		       96		      .byte.b	$90+(.LUM1/256)
     15  5936		       b7		      .byte.b	$B0+(.LUM2/256)
     16  5937		       28		      .byte.b	$20+(.LUM3/256)
     17  5937				   .LUM1      SET	.LUM1 + .STEP1
     18  5937				   .LUM2      SET	.LUM2 + .STEP2
     19  5937				   .LUM3      SET	.LUM3 + .STEP3
     13  5937					      REPEND
     14  5938		       96		      .byte.b	$90+(.LUM1/256)
     15  5939		       b7		      .byte.b	$B0+(.LUM2/256)
     16  593a		       28		      .byte.b	$20+(.LUM3/256)
     17  593a				   .LUM1      SET	.LUM1 + .STEP1
     18  593a				   .LUM2      SET	.LUM2 + .STEP2
     19  593a				   .LUM3      SET	.LUM3 + .STEP3
     13  593a					      REPEND
     14  593b		       96		      .byte.b	$90+(.LUM1/256)
     15  593c		       b7		      .byte.b	$B0+(.LUM2/256)
     16  593d		       28		      .byte.b	$20+(.LUM3/256)
     17  593d				   .LUM1      SET	.LUM1 + .STEP1
     18  593d				   .LUM2      SET	.LUM2 + .STEP2
     19  593d				   .LUM3      SET	.LUM3 + .STEP3
     13  593d					      REPEND
     14  593e		       96		      .byte.b	$90+(.LUM1/256)
     15  593f		       b7		      .byte.b	$B0+(.LUM2/256)
     16  5940		       28		      .byte.b	$20+(.LUM3/256)
     17  5940				   .LUM1      SET	.LUM1 + .STEP1
     18  5940				   .LUM2      SET	.LUM2 + .STEP2
     19  5940				   .LUM3      SET	.LUM3 + .STEP3
     13  5940					      REPEND
     14  5941		       96		      .byte.b	$90+(.LUM1/256)
     15  5942		       b7		      .byte.b	$B0+(.LUM2/256)
     16  5943		       28		      .byte.b	$20+(.LUM3/256)
     17  5943				   .LUM1      SET	.LUM1 + .STEP1
     18  5943				   .LUM2      SET	.LUM2 + .STEP2
     19  5943				   .LUM3      SET	.LUM3 + .STEP3
     13  5943					      REPEND
     14  5944		       96		      .byte.b	$90+(.LUM1/256)
     15  5945		       b8		      .byte.b	$B0+(.LUM2/256)
     16  5946		       28		      .byte.b	$20+(.LUM3/256)
     17  5946				   .LUM1      SET	.LUM1 + .STEP1
     18  5946				   .LUM2      SET	.LUM2 + .STEP2
     19  5946				   .LUM3      SET	.LUM3 + .STEP3
     13  5946					      REPEND
     14  5947		       97		      .byte.b	$90+(.LUM1/256)
     15  5948		       b8		      .byte.b	$B0+(.LUM2/256)
     16  5949		       29		      .byte.b	$20+(.LUM3/256)
     17  5949				   .LUM1      SET	.LUM1 + .STEP1
     18  5949				   .LUM2      SET	.LUM2 + .STEP2
     19  5949				   .LUM3      SET	.LUM3 + .STEP3
     13  5949					      REPEND
     14  594a		       97		      .byte.b	$90+(.LUM1/256)
     15  594b		       b8		      .byte.b	$B0+(.LUM2/256)
     16  594c		       29		      .byte.b	$20+(.LUM3/256)
     17  594c				   .LUM1      SET	.LUM1 + .STEP1
     18  594c				   .LUM2      SET	.LUM2 + .STEP2
     19  594c				   .LUM3      SET	.LUM3 + .STEP3
     13  594c					      REPEND
     14  594d		       97		      .byte.b	$90+(.LUM1/256)
     15  594e		       b8		      .byte.b	$B0+(.LUM2/256)
     16  594f		       29		      .byte.b	$20+(.LUM3/256)
     17  594f				   .LUM1      SET	.LUM1 + .STEP1
     18  594f				   .LUM2      SET	.LUM2 + .STEP2
     19  594f				   .LUM3      SET	.LUM3 + .STEP3
     13  594f					      REPEND
     14  5950		       97		      .byte.b	$90+(.LUM1/256)
     15  5951		       b8		      .byte.b	$B0+(.LUM2/256)
     16  5952		       29		      .byte.b	$20+(.LUM3/256)
     17  5952				   .LUM1      SET	.LUM1 + .STEP1
     18  5952				   .LUM2      SET	.LUM2 + .STEP2
     19  5952				   .LUM3      SET	.LUM3 + .STEP3
     13  5952					      REPEND
     14  5953		       97		      .byte.b	$90+(.LUM1/256)
     15  5954		       b9		      .byte.b	$B0+(.LUM2/256)
     16  5955		       29		      .byte.b	$20+(.LUM3/256)
     17  5955				   .LUM1      SET	.LUM1 + .STEP1
     18  5955				   .LUM2      SET	.LUM2 + .STEP2
     19  5955				   .LUM3      SET	.LUM3 + .STEP3
     13  5955					      REPEND
     14  5956		       97		      .byte.b	$90+(.LUM1/256)
     15  5957		       b9		      .byte.b	$B0+(.LUM2/256)
     16  5958		       29		      .byte.b	$20+(.LUM3/256)
     17  5958				   .LUM1      SET	.LUM1 + .STEP1
     18  5958				   .LUM2      SET	.LUM2 + .STEP2
     19  5958				   .LUM3      SET	.LUM3 + .STEP3
     13  5958					      REPEND
     14  5959		       98		      .byte.b	$90+(.LUM1/256)
     15  595a		       b9		      .byte.b	$B0+(.LUM2/256)
     16  595b		       2a		      .byte.b	$20+(.LUM3/256)
     17  595b				   .LUM1      SET	.LUM1 + .STEP1
     18  595b				   .LUM2      SET	.LUM2 + .STEP2
     19  595b				   .LUM3      SET	.LUM3 + .STEP3
     13  595b					      REPEND
     14  595c		       98		      .byte.b	$90+(.LUM1/256)
     15  595d		       b9		      .byte.b	$B0+(.LUM2/256)
     16  595e		       2a		      .byte.b	$20+(.LUM3/256)
     17  595e				   .LUM1      SET	.LUM1 + .STEP1
     18  595e				   .LUM2      SET	.LUM2 + .STEP2
     19  595e				   .LUM3      SET	.LUM3 + .STEP3
     13  595e					      REPEND
     14  595f		       98		      .byte.b	$90+(.LUM1/256)
     15  5960		       b9		      .byte.b	$B0+(.LUM2/256)
     16  5961		       2a		      .byte.b	$20+(.LUM3/256)
     17  5961				   .LUM1      SET	.LUM1 + .STEP1
     18  5961				   .LUM2      SET	.LUM2 + .STEP2
     19  5961				   .LUM3      SET	.LUM3 + .STEP3
     13  5961					      REPEND
     14  5962		       98		      .byte.b	$90+(.LUM1/256)
     15  5963		       ba		      .byte.b	$B0+(.LUM2/256)
     16  5964		       2a		      .byte.b	$20+(.LUM3/256)
     17  5964				   .LUM1      SET	.LUM1 + .STEP1
     18  5964				   .LUM2      SET	.LUM2 + .STEP2
     19  5964				   .LUM3      SET	.LUM3 + .STEP3
     13  5964					      REPEND
     14  5965		       98		      .byte.b	$90+(.LUM1/256)
     15  5966		       ba		      .byte.b	$B0+(.LUM2/256)
     16  5967		       2a		      .byte.b	$20+(.LUM3/256)
     17  5967				   .LUM1      SET	.LUM1 + .STEP1
     18  5967				   .LUM2      SET	.LUM2 + .STEP2
     19  5967				   .LUM3      SET	.LUM3 + .STEP3
     13  5967					      REPEND
     14  5968		       98		      .byte.b	$90+(.LUM1/256)
     15  5969		       ba		      .byte.b	$B0+(.LUM2/256)
     16  596a		       2a		      .byte.b	$20+(.LUM3/256)
     17  596a				   .LUM1      SET	.LUM1 + .STEP1
     18  596a				   .LUM2      SET	.LUM2 + .STEP2
     19  596a				   .LUM3      SET	.LUM3 + .STEP3
     13  596a					      REPEND
     14  596b		       99		      .byte.b	$90+(.LUM1/256)
     15  596c		       ba		      .byte.b	$B0+(.LUM2/256)
     16  596d		       2b		      .byte.b	$20+(.LUM3/256)
     17  596d				   .LUM1      SET	.LUM1 + .STEP1
     18  596d				   .LUM2      SET	.LUM2 + .STEP2
     19  596d				   .LUM3      SET	.LUM3 + .STEP3
     13  596d					      REPEND
     14  596e		       99		      .byte.b	$90+(.LUM1/256)
     15  596f		       ba		      .byte.b	$B0+(.LUM2/256)
     16  5970		       2b		      .byte.b	$20+(.LUM3/256)
     17  5970				   .LUM1      SET	.LUM1 + .STEP1
     18  5970				   .LUM2      SET	.LUM2 + .STEP2
     19  5970				   .LUM3      SET	.LUM3 + .STEP3
     13  5970					      REPEND
     14  5971		       99		      .byte.b	$90+(.LUM1/256)
     15  5972		       bb		      .byte.b	$B0+(.LUM2/256)
     16  5973		       2b		      .byte.b	$20+(.LUM3/256)
     17  5973				   .LUM1      SET	.LUM1 + .STEP1
     18  5973				   .LUM2      SET	.LUM2 + .STEP2
     19  5973				   .LUM3      SET	.LUM3 + .STEP3
     13  5973					      REPEND
     14  5974		       99		      .byte.b	$90+(.LUM1/256)
     15  5975		       bb		      .byte.b	$B0+(.LUM2/256)
     16  5976		       2b		      .byte.b	$20+(.LUM3/256)
     17  5976				   .LUM1      SET	.LUM1 + .STEP1
     18  5976				   .LUM2      SET	.LUM2 + .STEP2
     19  5976				   .LUM3      SET	.LUM3 + .STEP3
     13  5976					      REPEND
     14  5977		       99		      .byte.b	$90+(.LUM1/256)
     15  5978		       bb		      .byte.b	$B0+(.LUM2/256)
     16  5979		       2b		      .byte.b	$20+(.LUM3/256)
     17  5979				   .LUM1      SET	.LUM1 + .STEP1
     18  5979				   .LUM2      SET	.LUM2 + .STEP2
     19  5979				   .LUM3      SET	.LUM3 + .STEP3
     13  5979					      REPEND
     14  597a		       99		      .byte.b	$90+(.LUM1/256)
     15  597b		       bb		      .byte.b	$B0+(.LUM2/256)
     16  597c		       2b		      .byte.b	$20+(.LUM3/256)
     17  597c				   .LUM1      SET	.LUM1 + .STEP1
     18  597c				   .LUM2      SET	.LUM2 + .STEP2
     19  597c				   .LUM3      SET	.LUM3 + .STEP3
     13  597c					      REPEND
     14  597d		       9a		      .byte.b	$90+(.LUM1/256)
     15  597e		       bb		      .byte.b	$B0+(.LUM2/256)
     16  597f		       2c		      .byte.b	$20+(.LUM3/256)
     17  597f				   .LUM1      SET	.LUM1 + .STEP1
     18  597f				   .LUM2      SET	.LUM2 + .STEP2
     19  597f				   .LUM3      SET	.LUM3 + .STEP3
     13  597f					      REPEND
     14  5980		       9a		      .byte.b	$90+(.LUM1/256)
     15  5981		       bc		      .byte.b	$B0+(.LUM2/256)
     16  5982		       2c		      .byte.b	$20+(.LUM3/256)
     17  5982				   .LUM1      SET	.LUM1 + .STEP1
     18  5982				   .LUM2      SET	.LUM2 + .STEP2
     19  5982				   .LUM3      SET	.LUM3 + .STEP3
     13  5982					      REPEND
     14  5983		       9a		      .byte.b	$90+(.LUM1/256)
     15  5984		       bc		      .byte.b	$B0+(.LUM2/256)
     16  5985		       2c		      .byte.b	$20+(.LUM3/256)
     17  5985				   .LUM1      SET	.LUM1 + .STEP1
     18  5985				   .LUM2      SET	.LUM2 + .STEP2
     19  5985				   .LUM3      SET	.LUM3 + .STEP3
     13  5985					      REPEND
     14  5986		       9a		      .byte.b	$90+(.LUM1/256)
     15  5987		       bc		      .byte.b	$B0+(.LUM2/256)
     16  5988		       2c		      .byte.b	$20+(.LUM3/256)
     17  5988				   .LUM1      SET	.LUM1 + .STEP1
     18  5988				   .LUM2      SET	.LUM2 + .STEP2
     19  5988				   .LUM3      SET	.LUM3 + .STEP3
     13  5988					      REPEND
     14  5989		       9a		      .byte.b	$90+(.LUM1/256)
     15  598a		       bc		      .byte.b	$B0+(.LUM2/256)
     16  598b		       2c		      .byte.b	$20+(.LUM3/256)
     17  598b				   .LUM1      SET	.LUM1 + .STEP1
     18  598b				   .LUM2      SET	.LUM2 + .STEP2
     19  598b				   .LUM3      SET	.LUM3 + .STEP3
     13  598b					      REPEND
     14  598c		       9b		      .byte.b	$90+(.LUM1/256)
     15  598d		       bc		      .byte.b	$B0+(.LUM2/256)
     16  598e		       2d		      .byte.b	$20+(.LUM3/256)
     17  598e				   .LUM1      SET	.LUM1 + .STEP1
     18  598e				   .LUM2      SET	.LUM2 + .STEP2
     19  598e				   .LUM3      SET	.LUM3 + .STEP3
     13  598e					      REPEND
     14  598f		       9b		      .byte.b	$90+(.LUM1/256)
     15  5990		       bd		      .byte.b	$B0+(.LUM2/256)
     16  5991		       2d		      .byte.b	$20+(.LUM3/256)
     17  5991				   .LUM1      SET	.LUM1 + .STEP1
     18  5991				   .LUM2      SET	.LUM2 + .STEP2
     19  5991				   .LUM3      SET	.LUM3 + .STEP3
     13  5991					      REPEND
     14  5992		       9b		      .byte.b	$90+(.LUM1/256)
     15  5993		       bd		      .byte.b	$B0+(.LUM2/256)
     16  5994		       2d		      .byte.b	$20+(.LUM3/256)
     17  5994				   .LUM1      SET	.LUM1 + .STEP1
     18  5994				   .LUM2      SET	.LUM2 + .STEP2
     19  5994				   .LUM3      SET	.LUM3 + .STEP3
     13  5994					      REPEND
     14  5995		       9b		      .byte.b	$90+(.LUM1/256)
     15  5996		       bd		      .byte.b	$B0+(.LUM2/256)
     16  5997		       2d		      .byte.b	$20+(.LUM3/256)
     17  5997				   .LUM1      SET	.LUM1 + .STEP1
     18  5997				   .LUM2      SET	.LUM2 + .STEP2
     19  5997				   .LUM3      SET	.LUM3 + .STEP3
     13  5997					      REPEND
     14  5998		       9b		      .byte.b	$90+(.LUM1/256)
     15  5999		       bd		      .byte.b	$B0+(.LUM2/256)
     16  599a		       2d		      .byte.b	$20+(.LUM3/256)
     17  599a				   .LUM1      SET	.LUM1 + .STEP1
     18  599a				   .LUM2      SET	.LUM2 + .STEP2
     19  599a				   .LUM3      SET	.LUM3 + .STEP3
     20  599b					      REPEND
    162  599b
------- FILE titleData.asm LEVEL 3 PASS 3
      0  599b					      include	"titleData.asm"
      1  599b				   COL_0
      2  599b		       c0		      .byte.b	192	;R (39)
      3  599c		       c0		      .byte.b	192	;G
      4  599d		       c0		      .byte.b	192	;B
      5  599e		       e0		      .byte.b	224	;R (38)
      6  599f		       e0		      .byte.b	224	;G
      7  59a0		       e0		      .byte.b	224	;B
      8  59a1		       20		      .byte.b	32	;R (37)
      9  59a2		       e0		      .byte.b	224	;G
     10  59a3		       e0		      .byte.b	224	;B
     11  59a4		       30		      .byte.b	48	;R (36)
     12  59a5		       30		      .byte.b	48	;G
     13  59a6		       30		      .byte.b	48	;B
     14  59a7		       f0		      .byte.b	240	;R (35)
     15  59a8		       10		      .byte.b	16	;G
     16  59a9		       d0		      .byte.b	208	;B
     17  59aa		       f0		      .byte.b	240	;R (34)
     18  59ab		       10		      .byte.b	16	;G
     19  59ac		       d0		      .byte.b	208	;B
     20  59ad		       f0		      .byte.b	240	;R (33)
     21  59ae		       10		      .byte.b	16	;G
     22  59af		       d0		      .byte.b	208	;B
     23  59b0		       f0		      .byte.b	240	;R (32)
     24  59b1		       10		      .byte.b	16	;G
     25  59b2		       d0		      .byte.b	208	;B
     26  59b3		       f0		      .byte.b	240	;R (31)
     27  59b4		       10		      .byte.b	16	;G
     28  59b5		       d0		      .byte.b	208	;B
     29  59b6		       f0		      .byte.b	240	;R (30)
     30  59b7		       10		      .byte.b	16	;G
     31  59b8		       10		      .byte.b	16	;B
     32  59b9		       f0		      .byte.b	240	;R (29)
     33  59ba		       10		      .byte.b	16	;G
     34  59bb		       10		      .byte.b	16	;B
     35  59bc		       f0		      .byte.b	240	;R (28)
     36  59bd		       10		      .byte.b	16	;G
     37  59be		       10		      .byte.b	16	;B
     38  59bf		       f0		      .byte.b	240	;R (27)
     39  59c0		       10		      .byte.b	16	;G
     40  59c1		       10		      .byte.b	16	;B
     41  59c2		       f0		      .byte.b	240	;R (26)
     42  59c3		       10		      .byte.b	16	;G
     43  59c4		       10		      .byte.b	16	;B
     44  59c5		       f0		      .byte.b	240	;R (25)
     45  59c6		       10		      .byte.b	16	;G
     46  59c7		       10		      .byte.b	16	;B
     47  59c8		       f0		      .byte.b	240	;R (24)
     48  59c9		       10		      .byte.b	16	;G
     49  59ca		       10		      .byte.b	16	;B
     50  59cb		       f0		      .byte.b	240	;R (23)
     51  59cc		       10		      .byte.b	16	;G
     52  59cd		       10		      .byte.b	16	;B
     53  59ce		       90		      .byte.b	144	;R (22)
     54  59cf		       70		      .byte.b	112	;G
     55  59d0		       10		      .byte.b	16	;B
     56  59d1		       10		      .byte.b	16	;R (21)
     57  59d2		       f0		      .byte.b	240	;G
     58  59d3		       10		      .byte.b	16	;B
     59  59d4		       90		      .byte.b	144	;R (20)
     60  59d5		       70		      .byte.b	112	;G
     61  59d6		       90		      .byte.b	144	;B
     62  59d7		       90		      .byte.b	144	;R (19)
     63  59d8		       70		      .byte.b	112	;G
     64  59d9		       90		      .byte.b	144	;B
     65  59da		       d0		      .byte.b	208	;R (18)
     66  59db		       30		      .byte.b	48	;G
     67  59dc		       d0		      .byte.b	208	;B
     68  59dd		       d0		      .byte.b	208	;R (17)
     69  59de		       30		      .byte.b	48	;G
     70  59df		       d0		      .byte.b	208	;B
     71  59e0		       50		      .byte.b	80	;R (16)
     72  59e1		       30		      .byte.b	48	;G
     73  59e2		       50		      .byte.b	80	;B
     74  59e3		       50		      .byte.b	80	;R (15)
     75  59e4		       30		      .byte.b	48	;G
     76  59e5		       50		      .byte.b	80	;B
     77  59e6		       50		      .byte.b	80	;R (14)
     78  59e7		       30		      .byte.b	48	;G
     79  59e8		       50		      .byte.b	80	;B
     80  59e9		       50		      .byte.b	80	;R (13)
     81  59ea		       30		      .byte.b	48	;G
     82  59eb		       50		      .byte.b	80	;B
     83  59ec		       d0		      .byte.b	208	;R (12)
     84  59ed		       30		      .byte.b	48	;G
     85  59ee		       d0		      .byte.b	208	;B
     86  59ef		       d0		      .byte.b	208	;R (11)
     87  59f0		       30		      .byte.b	48	;G
     88  59f1		       d0		      .byte.b	208	;B
     89  59f2		       d0		      .byte.b	208	;R (10)
     90  59f3		       30		      .byte.b	48	;G
     91  59f4		       d0		      .byte.b	208	;B
     92  59f5		       d0		      .byte.b	208	;R (9)
     93  59f6		       30		      .byte.b	48	;G
     94  59f7		       d0		      .byte.b	208	;B
     95  59f8		       90		      .byte.b	144	;R (8)
     96  59f9		       70		      .byte.b	112	;G
     97  59fa		       90		      .byte.b	144	;B
     98  59fb		       90		      .byte.b	144	;R (7)
     99  59fc		       70		      .byte.b	112	;G
    100  59fd		       90		      .byte.b	144	;B
    101  59fe		       10		      .byte.b	16	;R (6)
    102  59ff		       f0		      .byte.b	240	;G
    103  5a00		       10		      .byte.b	16	;B
    104  5a01		       10		      .byte.b	16	;R (5)
    105  5a02		       f0		      .byte.b	240	;G
    106  5a03		       10		      .byte.b	16	;B
    107  5a04		       10		      .byte.b	16	;R (4)
    108  5a05		       f0		      .byte.b	240	;G
    109  5a06		       10		      .byte.b	16	;B
    110  5a07		       20		      .byte.b	32	;R (3)
    111  5a08		       e0		      .byte.b	224	;G
    112  5a09		       20		      .byte.b	32	;B
    113  5a0a		       20		      .byte.b	32	;R (2)
    114  5a0b		       e0		      .byte.b	224	;G
    115  5a0c		       20		      .byte.b	32	;B
    116  5a0d		       e0		      .byte.b	224	;R (1)
    117  5a0e		       e0		      .byte.b	224	;G
    118  5a0f		       e0		      .byte.b	224	;B
    119  5a10		       c0		      .byte.b	192	;R (0)
    120  5a11		       c0		      .byte.b	192	;G
    121  5a12		       c0		      .byte.b	192	;B
    122  5a13				   COL_1
    123  5a13		       ff		      .byte.b	255	;R (39)
    124  5a14		       ff		      .byte.b	255	;G
    125  5a15		       ff		      .byte.b	255	;B
    126  5a16		       ff		      .byte.b	255	;R (38)
    127  5a17		       ff		      .byte.b	255	;G
    128  5a18		       ff		      .byte.b	255	;B
    129  5a19		       00		      .byte.b	0	;R (37)
    130  5a1a		       ff		      .byte.b	255	;G
    131  5a1b		       ff		      .byte.b	255	;B
    132  5a1c		       00		      .byte.b	0	;R (36)
    133  5a1d		       f3		      .byte.b	243	;G
    134  5a1e		       f3		      .byte.b	243	;B
    135  5a1f		       0c		      .byte.b	12	;R (35)
    136  5a20		       7d		      .byte.b	125	;G
    137  5a21		       71		      .byte.b	113	;B
    138  5a22		       0c		      .byte.b	12	;R (34)
    139  5a23		       7d		      .byte.b	125	;G
    140  5a24		       71		      .byte.b	113	;B
    141  5a25		       9c		      .byte.b	156	;R (33)
    142  5a26		       3d		      .byte.b	61	;G
    143  5a27		       a1		      .byte.b	161	;B
    144  5a28		       9c		      .byte.b	156	;R (32)
    145  5a29		       3d		      .byte.b	61	;G
    146  5a2a		       a1		      .byte.b	161	;B
    147  5a2b		       9e		      .byte.b	158	;R (31)
    148  5a2c		       3e		      .byte.b	62	;G
    149  5a2d		       a0		      .byte.b	160	;B
    150  5a2e		       de		      .byte.b	222	;R (30)
    151  5a2f		       1e		      .byte.b	30	;G
    152  5a30		       c0		      .byte.b	192	;B
    153  5a31		       d2		      .byte.b	210	;R (29)
    154  5a32		       12		      .byte.b	18	;G
    155  5a33		       c0		      .byte.b	192	;B
    156  5a34		       d6		      .byte.b	214	;R (28)
    157  5a35		       12		      .byte.b	18	;G
    158  5a36		       c0		      .byte.b	192	;B
    159  5a37		       d6		      .byte.b	214	;R (27)
    160  5a38		       12		      .byte.b	18	;G
    161  5a39		       c0		      .byte.b	192	;B
    162  5a3a		       d6		      .byte.b	214	;R (26)
    163  5a3b		       12		      .byte.b	18	;G
    164  5a3c		       c0		      .byte.b	192	;B
    165  5a3d		       d6		      .byte.b	214	;R (25)
    166  5a3e		       12		      .byte.b	18	;G
    167  5a3f		       c0		      .byte.b	192	;B
    168  5a40		       d6		      .byte.b	214	;R (24)
    169  5a41		       12		      .byte.b	18	;G
    170  5a42		       c0		      .byte.b	192	;B
    171  5a43		       d6		      .byte.b	214	;R (23)
    172  5a44		       12		      .byte.b	18	;G
    173  5a45		       c0		      .byte.b	192	;B
    174  5a46		       d6		      .byte.b	214	;R (22)
    175  5a47		       12		      .byte.b	18	;G
    176  5a48		       c0		      .byte.b	192	;B
    177  5a49		       d6		      .byte.b	214	;R (21)
    178  5a4a		       12		      .byte.b	18	;G
    179  5a4b		       c0		      .byte.b	192	;B
    180  5a4c		       d6		      .byte.b	214	;R (20)
    181  5a4d		       12		      .byte.b	18	;G
    182  5a4e		       c0		      .byte.b	192	;B
    183  5a4f		       d6		      .byte.b	214	;R (19)
    184  5a50		       12		      .byte.b	18	;G
    185  5a51		       c0		      .byte.b	192	;B
    186  5a52		       96		      .byte.b	150	;R (18)
    187  5a53		       32		      .byte.b	50	;G
    188  5a54		       80		      .byte.b	128	;B
    189  5a55		       12		      .byte.b	18	;R (17)
    190  5a56		       76		      .byte.b	118	;G
    191  5a57		       00		      .byte.b	0	;B
    192  5a58		       12		      .byte.b	18	;R (16)
    193  5a59		       f6		      .byte.b	246	;G
    194  5a5a		       00		      .byte.b	0	;B
    195  5a5b		       12		      .byte.b	18	;R (15)
    196  5a5c		       f6		      .byte.b	246	;G
    197  5a5d		       00		      .byte.b	0	;B
    198  5a5e		       12		      .byte.b	18	;R (14)
    199  5a5f		       f6		      .byte.b	246	;G
    200  5a60		       00		      .byte.b	0	;B
    201  5a61		       12		      .byte.b	18	;R (13)
    202  5a62		       f6		      .byte.b	246	;G
    203  5a63		       00		      .byte.b	0	;B
    204  5a64		       12		      .byte.b	18	;R (12)
    205  5a65		       76		      .byte.b	118	;G
    206  5a66		       00		      .byte.b	0	;B
    207  5a67		       12		      .byte.b	18	;R (11)
    208  5a68		       76		      .byte.b	118	;G
    209  5a69		       00		      .byte.b	0	;B
    210  5a6a		       12		      .byte.b	18	;R (10)
    211  5a6b		       76		      .byte.b	118	;G
    212  5a6c		       00		      .byte.b	0	;B
    213  5a6d		       9a		      .byte.b	154	;R (9)
    214  5a6e		       3a		      .byte.b	58	;G
    215  5a6f		       80		      .byte.b	128	;B
    216  5a70		       da		      .byte.b	218	;R (8)
    217  5a71		       1a		      .byte.b	26	;G
    218  5a72		       c0		      .byte.b	192	;B
    219  5a73		       fe		      .byte.b	254	;R (7)
    220  5a74		       1e		      .byte.b	30	;G
    221  5a75		       e0		      .byte.b	224	;B
    222  5a76		       ee		      .byte.b	238	;R (6)
    223  5a77		       0e		      .byte.b	14	;G
    224  5a78		       e0		      .byte.b	224	;B
    225  5a79		       6e		      .byte.b	110	;R (5)
    226  5a7a		       8e		      .byte.b	142	;G
    227  5a7b		       60		      .byte.b	96	;B
    228  5a7c		       24		      .byte.b	36	;R (4)
    229  5a7d		       cd		      .byte.b	205	;G
    230  5a7e		       20		      .byte.b	32	;B
    231  5a7f		       00		      .byte.b	0	;R (3)
    232  5a80		       ff		      .byte.b	255	;G
    233  5a81		       00		      .byte.b	0	;B
    234  5a82		       00		      .byte.b	0	;R (2)
    235  5a83		       ff		      .byte.b	255	;G
    236  5a84		       00		      .byte.b	0	;B
    237  5a85		       ff		      .byte.b	255	;R (1)
    238  5a86		       ff		      .byte.b	255	;G
    239  5a87		       ff		      .byte.b	255	;B
    240  5a88		       ff		      .byte.b	255	;R (0)
    241  5a89		       ff		      .byte.b	255	;G
    242  5a8a		       ff		      .byte.b	255	;B
    243  5a8b				   COL_2
    244  5a8b		       ff		      .byte.b	255	;R (39)
    245  5a8c		       ff		      .byte.b	255	;G
    246  5a8d		       ff		      .byte.b	255	;B
    247  5a8e		       ff		      .byte.b	255	;R (38)
    248  5a8f		       ff		      .byte.b	255	;G
    249  5a90		       ff		      .byte.b	255	;B
    250  5a91		       00		      .byte.b	0	;R (37)
    251  5a92		       ff		      .byte.b	255	;G
    252  5a93		       ff		      .byte.b	255	;B
    253  5a94		       00		      .byte.b	0	;R (36)
    254  5a95		       26		      .byte.b	38	;G
    255  5a96		       26		      .byte.b	38	;B
    256  5a97		       c0		      .byte.b	192	;R (35)
    257  5a98		       04		      .byte.b	4	;G
    258  5a99		       dd		      .byte.b	221	;B
    259  5a9a		       c0		      .byte.b	192	;R (34)
    260  5a9b		       04		      .byte.b	4	;G
    261  5a9c		       dd		      .byte.b	221	;B
    262  5a9d		       e0		      .byte.b	224	;R (33)
    263  5a9e		       04		      .byte.b	4	;G
    264  5a9f		       ed		      .byte.b	237	;B
    265  5aa0		       e0		      .byte.b	224	;R (32)
    266  5aa1		       04		      .byte.b	4	;G
    267  5aa2		       ed		      .byte.b	237	;B
    268  5aa3		       e0		      .byte.b	224	;R (31)
    269  5aa4		       04		      .byte.b	4	;G
    270  5aa5		       ed		      .byte.b	237	;B
    271  5aa6		       e0		      .byte.b	224	;R (30)
    272  5aa7		       00		      .byte.b	0	;G
    273  5aa8		       ed		      .byte.b	237	;B
    274  5aa9		       20		      .byte.b	32	;R (29)
    275  5aaa		       80		      .byte.b	128	;G
    276  5aab		       af		      .byte.b	175	;B
    277  5aac		       20		      .byte.b	32	;R (28)
    278  5aad		       80		      .byte.b	128	;G
    279  5aae		       af		      .byte.b	175	;B
    280  5aaf		       20		      .byte.b	32	;R (27)
    281  5ab0		       80		      .byte.b	128	;G
    282  5ab1		       af		      .byte.b	175	;B
    283  5ab2		       20		      .byte.b	32	;R (26)
    284  5ab3		       90		      .byte.b	144	;G
    285  5ab4		       b7		      .byte.b	183	;B
    286  5ab5		       20		      .byte.b	32	;R (25)
    287  5ab6		       90		      .byte.b	144	;G
    288  5ab7		       b7		      .byte.b	183	;B
    289  5ab8		       20		      .byte.b	32	;R (24)
    290  5ab9		       90		      .byte.b	144	;G
    291  5aba		       b7		      .byte.b	183	;B
    292  5abb		       38		      .byte.b	56	;R (23)
    293  5abc		       80		      .byte.b	128	;G
    294  5abd		       a3		      .byte.b	163	;B
    295  5abe		       38		      .byte.b	56	;R (22)
    296  5abf		       80		      .byte.b	128	;G
    297  5ac0		       a3		      .byte.b	163	;B
    298  5ac1		       b0		      .byte.b	176	;R (21)
    299  5ac2		       00		      .byte.b	0	;G
    300  5ac3		       27		      .byte.b	39	;B
    301  5ac4		       b0		      .byte.b	176	;R (20)
    302  5ac5		       00		      .byte.b	0	;G
    303  5ac6		       27		      .byte.b	39	;B
    304  5ac7		       b0		      .byte.b	176	;R (19)
    305  5ac8		       00		      .byte.b	0	;G
    306  5ac9		       27		      .byte.b	39	;B
    307  5aca		       b0		      .byte.b	176	;R (18)
    308  5acb		       00		      .byte.b	0	;G
    309  5acc		       27		      .byte.b	39	;B
    310  5acd		       a0		      .byte.b	160	;R (17)
    311  5ace		       00		      .byte.b	0	;G
    312  5acf		       2f		      .byte.b	47	;B
    313  5ad0		       a0		      .byte.b	160	;R (16)
    314  5ad1		       00		      .byte.b	0	;G
    315  5ad2		       2f		      .byte.b	47	;B
    316  5ad3		       a0		      .byte.b	160	;R (15)
    317  5ad4		       00		      .byte.b	0	;G
    318  5ad5		       2d		      .byte.b	45	;B
    319  5ad6		       a0		      .byte.b	160	;R (14)
    320  5ad7		       00		      .byte.b	0	;G
    321  5ad8		       2d		      .byte.b	45	;B
    322  5ad9		       a0		      .byte.b	160	;R (13)
    323  5ada		       00		      .byte.b	0	;G
    324  5adb		       2d		      .byte.b	45	;B
    325  5adc		       a0		      .byte.b	160	;R (12)
    326  5add		       04		      .byte.b	4	;G
    327  5ade		       29		      .byte.b	41	;B
    328  5adf		       a0		      .byte.b	160	;R (11)
    329  5ae0		       04		      .byte.b	4	;G
    330  5ae1		       29		      .byte.b	41	;B
    331  5ae2		       a0		      .byte.b	160	;R (10)
    332  5ae3		       04		      .byte.b	4	;G
    333  5ae4		       29		      .byte.b	41	;B
    334  5ae5		       60		      .byte.b	96	;R (9)
    335  5ae6		       04		      .byte.b	4	;G
    336  5ae7		       69		      .byte.b	105	;B
    337  5ae8		       60		      .byte.b	96	;R (8)
    338  5ae9		       04		      .byte.b	4	;G
    339  5aea		       79		      .byte.b	121	;B
    340  5aeb		       e0		      .byte.b	224	;R (7)
    341  5aec		       04		      .byte.b	4	;G
    342  5aed		       f9		      .byte.b	249	;B
    343  5aee		       c0		      .byte.b	192	;R (6)
    344  5aef		       04		      .byte.b	4	;G
    345  5af0		       d9		      .byte.b	217	;B
    346  5af1		       c0		      .byte.b	192	;R (5)
    347  5af2		       04		      .byte.b	4	;G
    348  5af3		       d9		      .byte.b	217	;B
    349  5af4		       80		      .byte.b	128	;R (4)
    350  5af5		       44		      .byte.b	68	;G
    351  5af6		       99		      .byte.b	153	;B
    352  5af7		       00		      .byte.b	0	;R (3)
    353  5af8		       ff		      .byte.b	255	;G
    354  5af9		       00		      .byte.b	0	;B
    355  5afa		       00		      .byte.b	0	;R (2)
    356  5afb		       ff		      .byte.b	255	;G
    357  5afc		       00		      .byte.b	0	;B
    358  5afd		       ff		      .byte.b	255	;R (1)
    359  5afe		       ff		      .byte.b	255	;G
    360  5aff		       ff		      .byte.b	255	;B
    361  5b00		       ff		      .byte.b	255	;R (0)
    362  5b01		       ff		      .byte.b	255	;G
    363  5b02		       ff		      .byte.b	255	;B
    364  5b03				   COL_3
    365  5b03		       f0		      .byte.b	240	;R (39)
    366  5b04		       f0		      .byte.b	240	;G
    367  5b05		       f0		      .byte.b	240	;B
    368  5b06		       f0		      .byte.b	240	;R (38)
    369  5b07		       f0		      .byte.b	240	;G
    370  5b08		       f0		      .byte.b	240	;B
    371  5b09		       00		      .byte.b	0	;R (37)
    372  5b0a		       f0		      .byte.b	240	;G
    373  5b0b		       f0		      .byte.b	240	;B
    374  5b0c		       00		      .byte.b	0	;R (36)
    375  5b0d		       30		      .byte.b	48	;G
    376  5b0e		       30		      .byte.b	48	;B
    377  5b0f		       00		      .byte.b	0	;R (35)
    378  5b10		       20		      .byte.b	32	;G
    379  5b11		       e0		      .byte.b	224	;B
    380  5b12		       00		      .byte.b	0	;R (34)
    381  5b13		       20		      .byte.b	32	;G
    382  5b14		       e0		      .byte.b	224	;B
    383  5b15		       00		      .byte.b	0	;R (33)
    384  5b16		       20		      .byte.b	32	;G
    385  5b17		       e0		      .byte.b	224	;B
    386  5b18		       00		      .byte.b	0	;R (32)
    387  5b19		       20		      .byte.b	32	;G
    388  5b1a		       e0		      .byte.b	224	;B
    389  5b1b		       10		      .byte.b	16	;R (31)
    390  5b1c		       00		      .byte.b	0	;G
    391  5b1d		       d0		      .byte.b	208	;B
    392  5b1e		       10		      .byte.b	16	;R (30)
    393  5b1f		       00		      .byte.b	0	;G
    394  5b20		       50		      .byte.b	80	;B
    395  5b21		       10		      .byte.b	16	;R (29)
    396  5b22		       00		      .byte.b	0	;G
    397  5b23		       50		      .byte.b	80	;B
    398  5b24		       10		      .byte.b	16	;R (28)
    399  5b25		       00		      .byte.b	0	;G
    400  5b26		       50		      .byte.b	80	;B
    401  5b27		       10		      .byte.b	16	;R (27)
    402  5b28		       00		      .byte.b	0	;G
    403  5b29		       50		      .byte.b	80	;B
    404  5b2a		       10		      .byte.b	16	;R (26)
    405  5b2b		       00		      .byte.b	0	;G
    406  5b2c		       50		      .byte.b	80	;B
    407  5b2d		       10		      .byte.b	16	;R (25)
    408  5b2e		       00		      .byte.b	0	;G
    409  5b2f		       50		      .byte.b	80	;B
    410  5b30		       10		      .byte.b	16	;R (24)
    411  5b31		       00		      .byte.b	0	;G
    412  5b32		       50		      .byte.b	80	;B
    413  5b33		       10		      .byte.b	16	;R (23)
    414  5b34		       00		      .byte.b	0	;G
    415  5b35		       d0		      .byte.b	208	;B
    416  5b36		       10		      .byte.b	16	;R (22)
    417  5b37		       00		      .byte.b	0	;G
    418  5b38		       d0		      .byte.b	208	;B
    419  5b39		       10		      .byte.b	16	;R (21)
    420  5b3a		       00		      .byte.b	0	;G
    421  5b3b		       d0		      .byte.b	208	;B
    422  5b3c		       10		      .byte.b	16	;R (20)
    423  5b3d		       00		      .byte.b	0	;G
    424  5b3e		       d0		      .byte.b	208	;B
    425  5b3f		       10		      .byte.b	16	;R (19)
    426  5b40		       00		      .byte.b	0	;G
    427  5b41		       d0		      .byte.b	208	;B
    428  5b42		       10		      .byte.b	16	;R (18)
    429  5b43		       00		      .byte.b	0	;G
    430  5b44		       d0		      .byte.b	208	;B
    431  5b45		       10		      .byte.b	16	;R (17)
    432  5b46		       00		      .byte.b	0	;G
    433  5b47		       50		      .byte.b	80	;B
    434  5b48		       10		      .byte.b	16	;R (16)
    435  5b49		       00		      .byte.b	0	;G
    436  5b4a		       50		      .byte.b	80	;B
    437  5b4b		       10		      .byte.b	16	;R (15)
    438  5b4c		       00		      .byte.b	0	;G
    439  5b4d		       50		      .byte.b	80	;B
    440  5b4e		       10		      .byte.b	16	;R (14)
    441  5b4f		       00		      .byte.b	0	;G
    442  5b50		       50		      .byte.b	80	;B
    443  5b51		       10		      .byte.b	16	;R (13)
    444  5b52		       00		      .byte.b	0	;G
    445  5b53		       50		      .byte.b	80	;B
    446  5b54		       10		      .byte.b	16	;R (12)
    447  5b55		       00		      .byte.b	0	;G
    448  5b56		       50		      .byte.b	80	;B
    449  5b57		       10		      .byte.b	16	;R (11)
    450  5b58		       00		      .byte.b	0	;G
    451  5b59		       50		      .byte.b	80	;B
    452  5b5a		       10		      .byte.b	16	;R (10)
    453  5b5b		       00		      .byte.b	0	;G
    454  5b5c		       50		      .byte.b	80	;B
    455  5b5d		       10		      .byte.b	16	;R (9)
    456  5b5e		       00		      .byte.b	0	;G
    457  5b5f		       50		      .byte.b	80	;B
    458  5b60		       10		      .byte.b	16	;R (8)
    459  5b61		       00		      .byte.b	0	;G
    460  5b62		       d0		      .byte.b	208	;B
    461  5b63		       10		      .byte.b	16	;R (7)
    462  5b64		       00		      .byte.b	0	;G
    463  5b65		       d0		      .byte.b	208	;B
    464  5b66		       10		      .byte.b	16	;R (6)
    465  5b67		       00		      .byte.b	0	;G
    466  5b68		       d0		      .byte.b	208	;B
    467  5b69		       10		      .byte.b	16	;R (5)
    468  5b6a		       00		      .byte.b	0	;G
    469  5b6b		       d0		      .byte.b	208	;B
    470  5b6c		       00		      .byte.b	0	;R (4)
    471  5b6d		       20		      .byte.b	32	;G
    472  5b6e		       c0		      .byte.b	192	;B
    473  5b6f		       00		      .byte.b	0	;R (3)
    474  5b70		       f0		      .byte.b	240	;G
    475  5b71		       00		      .byte.b	0	;B
    476  5b72		       00		      .byte.b	0	;R (2)
    477  5b73		       f0		      .byte.b	240	;G
    478  5b74		       00		      .byte.b	0	;B
    479  5b75		       f0		      .byte.b	240	;R (1)
    480  5b76		       f0		      .byte.b	240	;G
    481  5b77		       f0		      .byte.b	240	;B
    482  5b78		       f0		      .byte.b	240	;R (0)
    483  5b79		       f0		      .byte.b	240	;G
    484  5b7a		       f0		      .byte.b	240	;B
    485  5b7b				   COL_4
    486  5b7b		       ff		      .byte.b	255	;R (39)
    487  5b7c		       ff		      .byte.b	255	;G
    488  5b7d		       ff		      .byte.b	255	;B
    489  5b7e		       ff		      .byte.b	255	;R (38)
    490  5b7f		       ff		      .byte.b	255	;G
    491  5b80		       ff		      .byte.b	255	;B
    492  5b81		       00		      .byte.b	0	;R (37)
    493  5b82		       ff		      .byte.b	255	;G
    494  5b83		       ff		      .byte.b	255	;B
    495  5b84		       00		      .byte.b	0	;R (36)
    496  5b85		       79		      .byte.b	121	;G
    497  5b86		       79		      .byte.b	121	;B
    498  5b87		       00		      .byte.b	0	;R (35)
    499  5b88		       3e		      .byte.b	62	;G
    500  5b89		       b8		      .byte.b	184	;B
    501  5b8a		       00		      .byte.b	0	;R (34)
    502  5b8b		       3e		      .byte.b	62	;G
    503  5b8c		       b8		      .byte.b	184	;B
    504  5b8d		       00		      .byte.b	0	;R (33)
    505  5b8e		       1e		      .byte.b	30	;G
    506  5b8f		       d0		      .byte.b	208	;B
    507  5b90		       00		      .byte.b	0	;R (32)
    508  5b91		       0e		      .byte.b	14	;G
    509  5b92		       e0		      .byte.b	224	;B
    510  5b93		       00		      .byte.b	0	;R (31)
    511  5b94		       0f		      .byte.b	15	;G
    512  5b95		       e0		      .byte.b	224	;B
    513  5b96		       00		      .byte.b	0	;R (30)
    514  5b97		       8f		      .byte.b	143	;G
    515  5b98		       e0		      .byte.b	224	;B
    516  5b99		       00		      .byte.b	0	;R (29)
    517  5b9a		       c9		      .byte.b	201	;G
    518  5b9b		       e2		      .byte.b	226	;B
    519  5b9c		       00		      .byte.b	0	;R (28)
    520  5b9d		       c9		      .byte.b	201	;G
    521  5b9e		       e2		      .byte.b	226	;B
    522  5b9f		       00		      .byte.b	0	;R (27)
    523  5ba0		       c9		      .byte.b	201	;G
    524  5ba1		       e2		      .byte.b	226	;B
    525  5ba2		       00		      .byte.b	0	;R (26)
    526  5ba3		       c9		      .byte.b	201	;G
    527  5ba4		       e2		      .byte.b	226	;B
    528  5ba5		       00		      .byte.b	0	;R (25)
    529  5ba6		       89		      .byte.b	137	;G
    530  5ba7		       e2		      .byte.b	226	;B
    531  5ba8		       00		      .byte.b	0	;R (24)
    532  5ba9		       89		      .byte.b	137	;G
    533  5baa		       e2		      .byte.b	226	;B
    534  5bab		       00		      .byte.b	0	;R (23)
    535  5bac		       09		      .byte.b	9	;G
    536  5bad		       62		      .byte.b	98	;B
    537  5bae		       00		      .byte.b	0	;R (22)
    538  5baf		       09		      .byte.b	9	;G
    539  5bb0		       e2		      .byte.b	226	;B
    540  5bb1		       00		      .byte.b	0	;R (21)
    541  5bb2		       09		      .byte.b	9	;G
    542  5bb3		       d2		      .byte.b	210	;B
    543  5bb4		       00		      .byte.b	0	;R (20)
    544  5bb5		       09		      .byte.b	9	;G
    545  5bb6		       d2		      .byte.b	210	;B
    546  5bb7		       00		      .byte.b	0	;R (19)
    547  5bb8		       09		      .byte.b	9	;G
    548  5bb9		       d2		      .byte.b	210	;B
    549  5bba		       00		      .byte.b	0	;R (18)
    550  5bbb		       09		      .byte.b	9	;G
    551  5bbc		       52		      .byte.b	82	;B
    552  5bbd		       c0		      .byte.b	192	;R (17)
    553  5bbe		       09		      .byte.b	9	;G
    554  5bbf		       22		      .byte.b	34	;B
    555  5bc0		       c0		      .byte.b	192	;R (16)
    556  5bc1		       09		      .byte.b	9	;G
    557  5bc2		       22		      .byte.b	34	;B
    558  5bc3		       c0		      .byte.b	192	;R (15)
    559  5bc4		       09		      .byte.b	9	;G
    560  5bc5		       22		      .byte.b	34	;B
    561  5bc6		       c0		      .byte.b	192	;R (14)
    562  5bc7		       09		      .byte.b	9	;G
    563  5bc8		       22		      .byte.b	34	;B
    564  5bc9		       c0		      .byte.b	192	;R (13)
    565  5bca		       09		      .byte.b	9	;G
    566  5bcb		       22		      .byte.b	34	;B
    567  5bcc		       c0		      .byte.b	192	;R (12)
    568  5bcd		       09		      .byte.b	9	;G
    569  5bce		       22		      .byte.b	34	;B
    570  5bcf		       80		      .byte.b	128	;R (11)
    571  5bd0		       09		      .byte.b	9	;G
    572  5bd1		       62		      .byte.b	98	;B
    573  5bd2		       80		      .byte.b	128	;R (10)
    574  5bd3		       09		      .byte.b	9	;G
    575  5bd4		       62		      .byte.b	98	;B
    576  5bd5		       00		      .byte.b	0	;R (9)
    577  5bd6		       0d		      .byte.b	13	;G
    578  5bd7		       60		      .byte.b	96	;B
    579  5bd8		       10		      .byte.b	16	;R (8)
    580  5bd9		       0d		      .byte.b	13	;G
    581  5bda		       c0		      .byte.b	192	;B
    582  5bdb		       10		      .byte.b	16	;R (7)
    583  5bdc		       0f		      .byte.b	15	;G
    584  5bdd		       c0		      .byte.b	192	;B
    585  5bde		       18		      .byte.b	24	;R (6)
    586  5bdf		       07		      .byte.b	7	;G
    587  5be0		       c0		      .byte.b	192	;B
    588  5be1		       18		      .byte.b	24	;R (5)
    589  5be2		       07		      .byte.b	7	;G
    590  5be3		       80		      .byte.b	128	;B
    591  5be4		       3c		      .byte.b	60	;R (4)
    592  5be5		       02		      .byte.b	2	;G
    593  5be6		       80		      .byte.b	128	;B
    594  5be7		       3f		      .byte.b	63	;R (3)
    595  5be8		       c0		      .byte.b	192	;G
    596  5be9		       00		      .byte.b	0	;B
    597  5bea		       1f		      .byte.b	31	;R (2)
    598  5beb		       e0		      .byte.b	224	;G
    599  5bec		       00		      .byte.b	0	;B
    600  5bed		       ff		      .byte.b	255	;R (1)
    601  5bee		       ff		      .byte.b	255	;G
    602  5bef		       ff		      .byte.b	255	;B
    603  5bf0		       ff		      .byte.b	255	;R (0)
    604  5bf1		       ff		      .byte.b	255	;G
    605  5bf2		       ff		      .byte.b	255	;B
    606  5bf3				   COL_5
    607  5bf3		       3f		      .byte.b	63	;R (39)
    608  5bf4		       3f		      .byte.b	63	;G
    609  5bf5		       3f		      .byte.b	63	;B
    610  5bf6		       7f		      .byte.b	127	;R (38)
    611  5bf7		       7f		      .byte.b	127	;G
    612  5bf8		       7f		      .byte.b	127	;B
    613  5bf9		       40		      .byte.b	64	;R (37)
    614  5bfa		       7f		      .byte.b	127	;G
    615  5bfb		       7f		      .byte.b	127	;B
    616  5bfc		       c0		      .byte.b	192	;R (36)
    617  5bfd		       f3		      .byte.b	243	;G
    618  5bfe		       f3		      .byte.b	243	;B
    619  5bff		       8c		      .byte.b	140	;R (35)
    620  5c00		       ef		      .byte.b	239	;G
    621  5c01		       e3		      .byte.b	227	;B
    622  5c02		       8c		      .byte.b	140	;R (34)
    623  5c03		       ef		      .byte.b	239	;G
    624  5c04		       e3		      .byte.b	227	;B
    625  5c05		       8e		      .byte.b	142	;R (33)
    626  5c06		       ef		      .byte.b	239	;G
    627  5c07		       e1		      .byte.b	225	;B
    628  5c08		       8e		      .byte.b	142	;R (32)
    629  5c09		       ef		      .byte.b	239	;G
    630  5c0a		       e1		      .byte.b	225	;B
    631  5c0b		       9e		      .byte.b	158	;R (31)
    632  5c0c		       9e		      .byte.b	158	;G
    633  5c0d		       c0		      .byte.b	192	;B
    634  5c0e		       9e		      .byte.b	158	;R (30)
    635  5c0f		       9e		      .byte.b	158	;G
    636  5c10		       c0		      .byte.b	192	;B
    637  5c11		       92		      .byte.b	146	;R (29)
    638  5c12		       92		      .byte.b	146	;G
    639  5c13		       c8		      .byte.b	200	;B
    640  5c14		       92		      .byte.b	146	;R (28)
    641  5c15		       92		      .byte.b	146	;G
    642  5c16		       c8		      .byte.b	200	;B
    643  5c17		       92		      .byte.b	146	;R (27)
    644  5c18		       92		      .byte.b	146	;G
    645  5c19		       c8		      .byte.b	200	;B
    646  5c1a		       92		      .byte.b	146	;R (26)
    647  5c1b		       92		      .byte.b	146	;G
    648  5c1c		       c8		      .byte.b	200	;B
    649  5c1d		       92		      .byte.b	146	;R (25)
    650  5c1e		       92		      .byte.b	146	;G
    651  5c1f		       c8		      .byte.b	200	;B
    652  5c20		       92		      .byte.b	146	;R (24)
    653  5c21		       92		      .byte.b	146	;G
    654  5c22		       c8		      .byte.b	200	;B
    655  5c23		       92		      .byte.b	146	;R (23)
    656  5c24		       92		      .byte.b	146	;G
    657  5c25		       c8		      .byte.b	200	;B
    658  5c26		       92		      .byte.b	146	;R (22)
    659  5c27		       92		      .byte.b	146	;G
    660  5c28		       c8		      .byte.b	200	;B
    661  5c29		       92		      .byte.b	146	;R (21)
    662  5c2a		       92		      .byte.b	146	;G
    663  5c2b		       c8		      .byte.b	200	;B
    664  5c2c		       92		      .byte.b	146	;R (20)
    665  5c2d		       92		      .byte.b	146	;G
    666  5c2e		       c8		      .byte.b	200	;B
    667  5c2f		       92		      .byte.b	146	;R (19)
    668  5c30		       92		      .byte.b	146	;G
    669  5c31		       c8		      .byte.b	200	;B
    670  5c32		       92		      .byte.b	146	;R (18)
    671  5c33		       92		      .byte.b	146	;G
    672  5c34		       c8		      .byte.b	200	;B
    673  5c35		       92		      .byte.b	146	;R (17)
    674  5c36		       92		      .byte.b	146	;G
    675  5c37		       c8		      .byte.b	200	;B
    676  5c38		       92		      .byte.b	146	;R (16)
    677  5c39		       92		      .byte.b	146	;G
    678  5c3a		       c8		      .byte.b	200	;B
    679  5c3b		       92		      .byte.b	146	;R (15)
    680  5c3c		       92		      .byte.b	146	;G
    681  5c3d		       c8		      .byte.b	200	;B
    682  5c3e		       92		      .byte.b	146	;R (14)
    683  5c3f		       92		      .byte.b	146	;G
    684  5c40		       c8		      .byte.b	200	;B
    685  5c41		       92		      .byte.b	146	;R (13)
    686  5c42		       92		      .byte.b	146	;G
    687  5c43		       c8		      .byte.b	200	;B
    688  5c44		       92		      .byte.b	146	;R (12)
    689  5c45		       92		      .byte.b	146	;G
    690  5c46		       c8		      .byte.b	200	;B
    691  5c47		       92		      .byte.b	146	;R (11)
    692  5c48		       92		      .byte.b	146	;G
    693  5c49		       c8		      .byte.b	200	;B
    694  5c4a		       92		      .byte.b	146	;R (10)
    695  5c4b		       92		      .byte.b	146	;G
    696  5c4c		       c8		      .byte.b	200	;B
    697  5c4d		       96		      .byte.b	150	;R (9)
    698  5c4e		       96		      .byte.b	150	;G
    699  5c4f		       c0		      .byte.b	192	;B
    700  5c50		       96		      .byte.b	150	;R (8)
    701  5c51		       96		      .byte.b	150	;G
    702  5c52		       c0		      .byte.b	192	;B
    703  5c53		       9e		      .byte.b	158	;R (7)
    704  5c54		       9e		      .byte.b	158	;G
    705  5c55		       c0		      .byte.b	192	;B
    706  5c56		       9e		      .byte.b	158	;R (6)
    707  5c57		       9c		      .byte.b	156	;G
    708  5c58		       c0		      .byte.b	192	;B
    709  5c59		       9e		      .byte.b	158	;R (5)
    710  5c5a		       9c		      .byte.b	156	;G
    711  5c5b		       c0		      .byte.b	192	;B
    712  5c5c		       ef		      .byte.b	239	;R (4)
    713  5c5d		       88		      .byte.b	136	;G
    714  5c5e		       80		      .byte.b	128	;B
    715  5c5f		       7f		      .byte.b	127	;R (3)
    716  5c60		       40		      .byte.b	64	;G
    717  5c61		       40		      .byte.b	64	;B
    718  5c62		       7f		      .byte.b	127	;R (2)
    719  5c63		       40		      .byte.b	64	;G
    720  5c64		       40		      .byte.b	64	;B
    721  5c65		       7f		      .byte.b	127	;R (1)
    722  5c66		       7f		      .byte.b	127	;G
    723  5c67		       7f		      .byte.b	127	;B
    724  5c68		       3f		      .byte.b	63	;R (0)
    725  5c69		       3f		      .byte.b	63	;G
    726  5c6a		       3f		      .byte.b	63	;B
------- FILE titleScreen.asm
    164  5c6b							;    include "pizza.asm"
    165  5c6b
      0  5c6b					      CHECK_BANK_SIZE	"TITLESCREEN"
      1  5c6b		       04 6b	   .TEMP      =	* - BANK_START
 TITLESCREEN (2K) SIZE =  $46b , FREE= $395
      2  5c6b					      ECHO	"TITLESCREEN", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5c6b				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  5c6b				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5c6b				  -	      ERR
      6  5c6b					      endif
------- FILE ./sokoboo.asm
------- FILE levelScreen.asm LEVEL 2 PASS 3
      0  5c6b					      include	"levelScreen.asm"
      0  5c6b					      NEWBANK	LEVELSCREEN
      1  677b ????				      SEG	LEVELSCREEN
      2  6000					      ORG	ORIGIN
      3  6000					      RORG	$F000
      4  6000				   BANK_START SET	*
      5  6000				   LEVELSCREEN SET	ORIGIN / 2048
      6  6000				   ORIGIN     SET	ORIGIN + 2048
      7  6000				   _CURRENT_BANK SET	LEVELSCREEN
      0  6000					      DEFINE_SUBROUTINE	LevelScreen
      1  6000		       00 0c	   BANK_LevelScreen =	_CURRENT_BANK
      2  6000					      SUBROUTINE
      3  6000				   LevelScreen
      3  6000
      4  6000							; Start of new frame
      5  6000
      6  6000							; Start of vertical blank processing
      7  6000
      8  6000				   LevelSequence
      9  6000
      0  6000					      RESYNC		; uses overlay
      1  6000
      2  6000		       a9 02		      lda	#%10
      3  6002		       85 41		      sta	VBLANK
      4  6004
      5  6004		       a2 08		      ldx	#8
      6  6006				   .loopResync
      0  6006					      VERTICAL_SYNC
      1  6006		       a9 0e		      lda	#%1110
      2  6008		       85 42	   .VSLP1     sta	WSYNC
      3  600a		       85 40		      sta	VSYNC
      4  600c		       4a		      lsr
      5  600d		       d0 f9		      bne	.VSLP1
      8  600f
      9  600f		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  6011		       a5 80		      lda	Platform
     11  6013		       49 02		      eor	#PAL_50
     12  6015		       d0 02		      bne	.ntsc
     13  6017		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  6019				   .ntsc
     15  6019				   .loopWait
     16  6019		       85 42		      sta	WSYNC
     17  601b		       85 42		      sta	WSYNC
     18  601d		       88		      dey
     19  601e		       d0 f9		      bne	.loopWait
     20  6020		       ca		      dex
     21  6021		       d0 e3		      bne	.loopResync
     11  6023
     12  6023		       a9 00		      lda	#%00000000
     13  6025		       85 49		      sta	COLUBK
     14  6027		       85 4a		      sta	CTRLPF
     15  6029
     16  6029		       a9 80		      lda	#$80
     17  602b		       85 e7		      sta	digitick
     18  602d		       a9 ff		      lda	#-1
     19  602f		       85 ec		      sta	endwait
     20  6031
     21  6031		       a9 0a		      lda	#10
     22  6033		       85 eb		      sta	initialdelay
     23  6035
     24  6035
     25  6035		       a9 ff		      lda	#-1
     26  6037		       85 e8		      sta	targetDigit
     27  6039		       85 e9		      sta	targetDigit+1
     28  603b		       85 ea		      sta	targetDigit+2
     29  603d
     30  603d		       a9 00		      lda	#0
     31  603f		       85 e4		      sta	digit
     32  6041		       85 e5		      sta	digit+1
     33  6043		       85 e6		      sta	digit+2
     34  6045
     35  6045							; convert to 3 digits decimal
     36  6045
     37  6045		       18		      clc
     38  6046		       a5 b3		      lda	levelX
     39  6048		       69 01		      adc	#1
     40  604a							;		  adc #96
     41  604a							;    lda #1
     42  604a		       38		      sec
     43  604b		       e9 64	   m100       sbc	#100
     44  604d		       e6 ea		      inc	targetDigit+2
     45  604f		       b0 fa		      bcs	m100
     46  6051		       69 64		      adc	#100
     47  6053		       e9 0a	   m10	      sbc	#10
     48  6055		       e6 e9		      inc	targetDigit+1
     49  6057		       b0 fa		      bcs	m10
     50  6059		       69 0a		      adc	#10
     51  605b		       85 e8		      sta	targetDigit
     52  605d
     53  605d
     54  605d		       a5 ea		      lda	targetDigit+2
     55  605f		       d0 06		      bne	hunds
     56  6061		       a9 0a		      lda	#10
     57  6063		       85 ea		      sta	targetDigit+2
     58  6065		       85 e6		      sta	digit+2
     59  6067				   hunds
     60  6067
     61  6067
     62  6067
     63  6067				   RestartFrameX
     64  6067		       a9 0e		      lda	#%1110	; VSYNC ON
     65  6069		       85 42	   .loopVSync3 sta	WSYNC
     66  606b		       85 40		      sta	VSYNC
     67  606d		       4a		      lsr
     68  606e		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
     69  6070
     70  6070		       a6 80		      ldx	Platform
     71  6072		       bc d9 f1 	      ldy	VBlankTime2x,x
     72  6075		       8c 96 02 	      sty	TIM64T
     73  6078
     74  6078
     75  6078		       a5 e6		      lda	digit+2	; hundreds
     76  607a		       0a		      asl
     77  607b		       aa		      tax
     78  607c		       bd 33 f3 	      lda	DIGITHUND,x
     79  607f		       85 ee		      sta	digitHundreds
     80  6081		       bd 34 f3 	      lda	DIGITHUND+1,x
     81  6084		       85 ef		      sta	digitHundreds+1
     82  6086
     83  6086		       a5 e5		      lda	digit+1	; tens
     84  6088		       0a		      asl
     85  6089		       aa		      tax
     86  608a		       bd 0b f3 	      lda	LDIGIT,x
     87  608d		       85 dd		      sta	digit1
     88  608f		       bd 0c f3 	      lda	LDIGIT+1,x
     89  6092		       85 de		      sta	digit1+1
     90  6094
     91  6094		       a5 e4		      lda	digit	; units
     92  6096		       0a		      asl
     93  6097		       aa		      tax
     94  6098		       bd 1f f3 	      lda	RDIGIT,x
     95  609b		       85 df		      sta	digit2
     96  609d		       bd 20 f3 	      lda	RDIGIT+1,x
     97  60a0		       85 e0		      sta	digit2+1
     98  60a2
     99  60a2
    100  60a2
    101  60a2		       a9 2a		      lda	#<LEFT_star	; question mark
    102  60a4		       85 e2		      sta	digitstar
    103  60a6		       a9 f7		      lda	#>LEFT_star
    104  60a8		       85 e3		      sta	digitstar+1
    105  60aa
    106  60aa
    107  60aa
    108  60aa							;------------------------------------------------------------------
    109  60aa
    110  60aa
    111  60aa				   VerticalBlankX		;sta WSYNC
    112  60aa		       ad 84 02 	      lda	INTIM
    113  60ad		       d0 fb		      bne	VerticalBlankX
    114  60af		       85 41		      sta	VBLANK
    115  60b1
    116  60b1		       a9 00		      lda	#0
    117  60b3		       85 4d		      sta	PF0
    118  60b5		       85 4e		      sta	PF1
    119  60b7		       85 4f		      sta	PF2
    120  60b9
    121  60b9		       a6 80		      ldx	Platform
    122  60bb		       bd e1 f1 	      lda	colvecX,x
    123  60be		       aa		      tax
    124  60bf		       a2 00		      ldx	#0
    125  60c1
    126  60c1							;------------------------------------------------------------------
    127  60c1
    128  60c1							; Do X scanlines of color-changing (our picture)
    129  60c1
    130  60c1		       a0 1a		      ldy	#26	; #lines in characters-1
    131  60c3				   LevelNumberDigits
    132  60c3					      REPEAT	3
    133  60c3
    134  60c3		       a9 00		      lda	#0	; 2
    135  60c5		       85 4d		      sta	PF0	; 3
    136  60c7
    137  60c7		       85 42		      sta	WSYNC	; 3
    138  60c9
    139  60c9		       bd 00 f2 	      lda	COLOUR_TABLE,x	; 4
    140  60cc		       85 48		      sta	COLUPF	; 3
    141  60ce		       ea		      nop		;inx			  ; 2
    142  60cf
    143  60cf		       b1 ee		      lda	(digitHundreds),y	; 5
    144  60d1		       85 4e		      sta	PF1	; 3
    145  60d3
    146  60d3		       b1 dd		      lda	(digit1),y	; 5
    147  60d5		       8d 4f 00 	      sta.w	PF2	; 3 @ 26 OK
    148  60d8
    149  60d8							; RHS
    150  60d8
    151  60d8		       b1 df		      lda	(digit2),y	; 5
    152  60da		       85 4d		      sta	PF0	; 3 @ 34 OK	    D7D6D5D4 <--- mirrored
    153  60dc
    154  60dc		       0a		      asl		; 2
    155  60dd		       0a		      asl		; 2
    156  60de		       0a		      asl		; 2
    157  60df		       0a		      asl		; 2
    158  60e0		       85 4e		      sta	PF1	; 3 @40 OK	   NOT MIRRORED, D7D6D5D4 -->
    159  60e2
    160  60e2
    161  60e2		       b1 e2		      lda	(digitstar),y	; 5
    162  60e4		       85 4f		      sta	PF2	; 3
    163  60e6
    164  60e6		       ea		      nop
    165  60e7		       a9 00		      lda	#0	;$44
    166  60e9		       85 48		      sta	COLUPF
    167  60eb
    168  60eb
    132  60eb					      REPEND
    133  60eb
    134  60eb		       a9 00		      lda	#0	; 2
    135  60ed		       85 4d		      sta	PF0	; 3
    136  60ef
    137  60ef		       85 42		      sta	WSYNC	; 3
    138  60f1
    139  60f1		       bd 00 f2 	      lda	COLOUR_TABLE,x	; 4
    140  60f4		       85 48		      sta	COLUPF	; 3
    141  60f6		       ea		      nop		;inx			  ; 2
    142  60f7
    143  60f7		       b1 ee		      lda	(digitHundreds),y	; 5
    144  60f9		       85 4e		      sta	PF1	; 3
    145  60fb
    146  60fb		       b1 dd		      lda	(digit1),y	; 5
    147  60fd		       8d 4f 00 	      sta.w	PF2	; 3 @ 26 OK
    148  6100
    149  6100							; RHS
    150  6100
    151  6100		       b1 df		      lda	(digit2),y	; 5
    152  6102		       85 4d		      sta	PF0	; 3 @ 34 OK	    D7D6D5D4 <--- mirrored
    153  6104
    154  6104		       0a		      asl		; 2
    155  6105		       0a		      asl		; 2
    156  6106		       0a		      asl		; 2
    157  6107		       0a		      asl		; 2
    158  6108		       85 4e		      sta	PF1	; 3 @40 OK	   NOT MIRRORED, D7D6D5D4 -->
    159  610a
    160  610a
    161  610a		       b1 e2		      lda	(digitstar),y	; 5
    162  610c		       85 4f		      sta	PF2	; 3
    163  610e
    164  610e		       ea		      nop
    165  610f		       a9 00		      lda	#0	;$44
    166  6111		       85 48		      sta	COLUPF
    167  6113
    168  6113
    132  6113					      REPEND
    133  6113
    134  6113		       a9 00		      lda	#0	; 2
    135  6115		       85 4d		      sta	PF0	; 3
    136  6117
    137  6117		       85 42		      sta	WSYNC	; 3
    138  6119
    139  6119		       bd 00 f2 	      lda	COLOUR_TABLE,x	; 4
    140  611c		       85 48		      sta	COLUPF	; 3
    141  611e		       ea		      nop		;inx			  ; 2
    142  611f
    143  611f		       b1 ee		      lda	(digitHundreds),y	; 5
    144  6121		       85 4e		      sta	PF1	; 3
    145  6123
    146  6123		       b1 dd		      lda	(digit1),y	; 5
    147  6125		       8d 4f 00 	      sta.w	PF2	; 3 @ 26 OK
    148  6128
    149  6128							; RHS
    150  6128
    151  6128		       b1 df		      lda	(digit2),y	; 5
    152  612a		       85 4d		      sta	PF0	; 3 @ 34 OK	    D7D6D5D4 <--- mirrored
    153  612c
    154  612c		       0a		      asl		; 2
    155  612d		       0a		      asl		; 2
    156  612e		       0a		      asl		; 2
    157  612f		       0a		      asl		; 2
    158  6130		       85 4e		      sta	PF1	; 3 @40 OK	   NOT MIRRORED, D7D6D5D4 -->
    159  6132
    160  6132
    161  6132		       b1 e2		      lda	(digitstar),y	; 5
    162  6134		       85 4f		      sta	PF2	; 3
    163  6136
    164  6136		       ea		      nop
    165  6137		       a9 00		      lda	#0	;$44
    166  6139		       85 48		      sta	COLUPF
    167  613b
    168  613b
    169  613b					      REPEND
    170  613b		       e8		      inx
    171  613c
    172  613c		       88		      dey
    173  613d		       30 03		      bmi	exss
    174  613f		       4c c3 f0 	      jmp	LevelNumberDigits	; 2(3)
    175  6142				   exss
    176  6142		       a9 00		      lda	#0
    177  6144		       85 4d		      sta	PF0
    178  6146		       85 4e		      sta	PF1
    179  6148		       85 4f		      sta	PF2
    180  614a
    181  614a		       a4 80		      ldy	Platform
    182  614c		       b9 dd f1 	      lda	OverscanTime2X,y
    183  614f		       8d 96 02 	      sta	TIM64T
    184  6152
    185  6152							;--------------------------------------------------------------------------
    186  6152
    187  6152
    188  6152		       a5 eb		      lda	initialdelay
    189  6154		       f0 05		      beq	canchange
    190  6156		       c6 eb		      dec	initialdelay
    191  6158		       4c 84 f1 	      jmp	nodigchange
    192  615b
    193  615b				   canchange
    194  615b		       e6 e7		      inc	digitick
    195  615d		       a5 e7		      lda	digitick
    196  615f		       c9 08		      cmp	#8
    197  6161		       90 21		      bcc	nodigchange
    198  6163		       a9 00		      lda	#0
    199  6165		       85 e7		      sta	digitick
    200  6167
    201  6167
    202  6167
    203  6167		       a2 02		      ldx	#2
    204  6169		       b5 e4	   scanner    lda	digit,x
    205  616b		       d5 e8		      cmp	targetDigit,x
    206  616d		       f0 12		      beq	scanOK
    207  616f
    208  616f		       18		      clc
    209  6170		       69 01		      adc	#1
    210  6172		       c9 0a		      cmp	#10
    211  6174		       90 02		      bcc	scanOK2
    212  6176		       a9 00		      lda	#0
    213  6178		       95 e4	   scanOK2    sta	digit,x
    214  617a
    215  617a		       a9 32		      lda	#50
    216  617c		       85 ec		      sta	endwait
    217  617e
    218  617e		       4c 84 f1 	      jmp	donedig
    219  6181
    220  6181		       ca	   scanOK     dex
    221  6182		       10 e5		      bpl	scanner
    222  6184
    223  6184
    224  6184				   donedig
    225  6184
    226  6184
    227  6184				   digok
    228  6184				   nodigchange
    229  6184
    230  6184		       a5 ec		      lda	endwait
    231  6186		       30 04		      bmi	neverend
    232  6188
    233  6188		       c6 ec		      dec	endwait
    234  618a		       f0 30		      beq	retX
    235  618c
    236  618c		       a5 4c	   neverend   lda	INPT4
    237  618e		       30 0d		      bmi	noret
    238  6190
    239  6190		       a2 02		      ldx	#2
    240  6192		       b5 e8	   copyDigits lda	targetDigit,x
    241  6194		       95 e4		      sta	digit,x
    242  6196		       ca		      dex
    243  6197		       10 f9		      bpl	copyDigits
    244  6199
    245  6199		       a9 32		      lda	#50
    246  619b		       85 ec		      sta	endwait
    247  619d
    248  619d		       4c b0 f1    noret      jmp	oscanX
    249  61a0							;bpl retX
    250  61a0
    251  61a0		       ad 80 02 	      lda	SWCHA
    252  61a3		       4a		      lsr
    253  61a4		       4a		      lsr
    254  61a5		       4a		      lsr
    255  61a6		       4a		      lsr
    256  61a7		       a8		      tay
    257  61a8
    258  61a8		       18		      clc
    259  61a9		       b9 bd f1 	      lda	xJoyMoveX,y
    260  61ac		       65 e4		      adc	digit
    261  61ae		       85 e4		      sta	digit
    262  61b0
    263  61b0							;nowY		      clc
    264  61b0							;		  adc xJoyMoveX,y
    265  61b0							;		  cmp #100
    266  61b0							;		  bcc lt100
    267  61b0							;		  lda #0
    268  61b0							;lt100 	  sta targetDigit
    269  61b0
    270  61b0
    271  61b0				   oscanX
    272  61b0		       ad 84 02 	      lda	INTIM
    273  61b3		       d0 fb		      bne	oscanX
    274  61b5
    275  61b5		       a9 42		      lda	#%01000010	; bit6 is not required
    276  61b7		       85 41		      sta	VBLANK	; end of screen - enter blanking
    277  61b9
    278  61b9
    279  61b9		       4c 67 f0 	      jmp	RestartFrameX
    280  61bc
    281  61bc		       60	   retX       rts
    282  61bd
    283  61bd		       00 00 00 00*xJoyMoveX  .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1	;,0, 0,0,0
    284  61c9		       00 00 00 00*xJoyMoveY  .byte.b	0,0,0,0,0,1,-1,0,0, 1,-1,0,0,0,0,0	;, 0,0,1,-1,0
    285  61d9
    286  61d9				   VBlankTime2x
    287  61d9		       6e 6e		      .byte.b	110,110
    288  61db		       96 96		      .byte.b	150,150
    289  61dd				   OverscanTime2X
    290  61dd		       57 57		      .byte.b	87, 87
    291  61df		       59 59		      .byte.b	89, 89
    292  61e1
    293  61e1		       00 1b	   COLOUR_LINES =	27
    294  61e1				   colvecX
    295  61e1		       00 00 51 51	      .byte.b	0, 0, COLOUR_LINES*3, COLOUR_LINES*3
    296  61e5
    297  61e5
    298  61e5		       00 00 00 00*blankDig   ds	COLOUR_LINES,0
    299  6200
    300  6200					      MAC	lumtable
    301  6200							; {4} MIN LUM 1
    302  6200							; {5} MIN LUM 2
    303  6200							; {6} MIN LUM 3
    304  6200
    305  6200				   .LUM1      SET	{4}*256
    306  6200				   .LUM2      SET	{5}*256
    307  6200				   .LUM3      SET	{6}*256
    308  6200
    309  6200				   .STEP1     =	(256*({7}-{4}))/{10}
    310  6200				   .STEP2     =	(256*({8}-{5}))/{10}
    311  6200				   .STEP3     =	(256*({9}-{6}))/{10}
    312  6200
    313  6200					      REPEAT	COLOUR_LINES
    314  6200					      .byte	$44	;{1}+(.LUM1/256)
    315  6200					      .byte	$56	;{2}+(.LUM2/256)
    316  6200					      .byte	$78	;{3}+(.LUM3/256)
    317  6200				   .LUM1      SET	.LUM1 + .STEP1
    318  6200				   .LUM2      SET	.LUM2 + .STEP2
    319  6200				   .LUM3      SET	.LUM3 + .STEP3
    320  6200					      REPEND
    321  6200					      ENDM		;{1}{2}{3} base colours
    322  6200
    323  6200					      ALIGN	256
    324  6200				   COLOUR_TABLE
      0  6200					      LUMTABLE	$90,$B0,$20,$C,$B,$A,0, 0,0, COLOUR_LINES	; NTSC
      1  6200
      2  6200
      3  6200
      4  6200
      5  6200				   .LUM1      SET	$C*256
      6  6200				   .LUM2      SET	$B*256
      7  6200				   .LUM3      SET	$A*256
      8  6200
      9  6200		       ff ff ff b4 .STEP1     =	(256*(0-$C))/40
     10  6200		       ff ff ff ba .STEP2     =	(256*(0-$B))/40
     11  6200		       ff ff ff c0 .STEP3     =	(256*(0-$A))/40
     12  6200
     13  6200					      REPEAT	40
     14  6200		       9c		      .byte.b	$90+(.LUM1/256)
     15  6201		       bb		      .byte.b	$B0+(.LUM2/256)
     16  6202		       2a		      .byte.b	$20+(.LUM3/256)
     17  6202				   .LUM1      SET	.LUM1 + .STEP1
     18  6202				   .LUM2      SET	.LUM2 + .STEP2
     19  6202				   .LUM3      SET	.LUM3 + .STEP3
     13  6202					      REPEND
     14  6203		       9b		      .byte.b	$90+(.LUM1/256)
     15  6204		       ba		      .byte.b	$B0+(.LUM2/256)
     16  6205		       29		      .byte.b	$20+(.LUM3/256)
     17  6205				   .LUM1      SET	.LUM1 + .STEP1
     18  6205				   .LUM2      SET	.LUM2 + .STEP2
     19  6205				   .LUM3      SET	.LUM3 + .STEP3
     13  6205					      REPEND
     14  6206		       9b		      .byte.b	$90+(.LUM1/256)
     15  6207		       ba		      .byte.b	$B0+(.LUM2/256)
     16  6208		       29		      .byte.b	$20+(.LUM3/256)
     17  6208				   .LUM1      SET	.LUM1 + .STEP1
     18  6208				   .LUM2      SET	.LUM2 + .STEP2
     19  6208				   .LUM3      SET	.LUM3 + .STEP3
     13  6208					      REPEND
     14  6209		       9b		      .byte.b	$90+(.LUM1/256)
     15  620a		       ba		      .byte.b	$B0+(.LUM2/256)
     16  620b		       29		      .byte.b	$20+(.LUM3/256)
     17  620b				   .LUM1      SET	.LUM1 + .STEP1
     18  620b				   .LUM2      SET	.LUM2 + .STEP2
     19  620b				   .LUM3      SET	.LUM3 + .STEP3
     13  620b					      REPEND
     14  620c		       9a		      .byte.b	$90+(.LUM1/256)
     15  620d		       b9		      .byte.b	$B0+(.LUM2/256)
     16  620e		       29		      .byte.b	$20+(.LUM3/256)
     17  620e				   .LUM1      SET	.LUM1 + .STEP1
     18  620e				   .LUM2      SET	.LUM2 + .STEP2
     19  620e				   .LUM3      SET	.LUM3 + .STEP3
     13  620e					      REPEND
     14  620f		       9a		      .byte.b	$90+(.LUM1/256)
     15  6210		       b9		      .byte.b	$B0+(.LUM2/256)
     16  6211		       28		      .byte.b	$20+(.LUM3/256)
     17  6211				   .LUM1      SET	.LUM1 + .STEP1
     18  6211				   .LUM2      SET	.LUM2 + .STEP2
     19  6211				   .LUM3      SET	.LUM3 + .STEP3
     13  6211					      REPEND
     14  6212		       9a		      .byte.b	$90+(.LUM1/256)
     15  6213		       b9		      .byte.b	$B0+(.LUM2/256)
     16  6214		       28		      .byte.b	$20+(.LUM3/256)
     17  6214				   .LUM1      SET	.LUM1 + .STEP1
     18  6214				   .LUM2      SET	.LUM2 + .STEP2
     19  6214				   .LUM3      SET	.LUM3 + .STEP3
     13  6214					      REPEND
     14  6215		       99		      .byte.b	$90+(.LUM1/256)
     15  6216		       b9		      .byte.b	$B0+(.LUM2/256)
     16  6217		       28		      .byte.b	$20+(.LUM3/256)
     17  6217				   .LUM1      SET	.LUM1 + .STEP1
     18  6217				   .LUM2      SET	.LUM2 + .STEP2
     19  6217				   .LUM3      SET	.LUM3 + .STEP3
     13  6217					      REPEND
     14  6218		       99		      .byte.b	$90+(.LUM1/256)
     15  6219		       b8		      .byte.b	$B0+(.LUM2/256)
     16  621a		       28		      .byte.b	$20+(.LUM3/256)
     17  621a				   .LUM1      SET	.LUM1 + .STEP1
     18  621a				   .LUM2      SET	.LUM2 + .STEP2
     19  621a				   .LUM3      SET	.LUM3 + .STEP3
     13  621a					      REPEND
     14  621b		       99		      .byte.b	$90+(.LUM1/256)
     15  621c		       b8		      .byte.b	$B0+(.LUM2/256)
     16  621d		       27		      .byte.b	$20+(.LUM3/256)
     17  621d				   .LUM1      SET	.LUM1 + .STEP1
     18  621d				   .LUM2      SET	.LUM2 + .STEP2
     19  621d				   .LUM3      SET	.LUM3 + .STEP3
     13  621d					      REPEND
     14  621e		       99		      .byte.b	$90+(.LUM1/256)
     15  621f		       b8		      .byte.b	$B0+(.LUM2/256)
     16  6220		       27		      .byte.b	$20+(.LUM3/256)
     17  6220				   .LUM1      SET	.LUM1 + .STEP1
     18  6220				   .LUM2      SET	.LUM2 + .STEP2
     19  6220				   .LUM3      SET	.LUM3 + .STEP3
     13  6220					      REPEND
     14  6221		       98		      .byte.b	$90+(.LUM1/256)
     15  6222		       b7		      .byte.b	$B0+(.LUM2/256)
     16  6223		       27		      .byte.b	$20+(.LUM3/256)
     17  6223				   .LUM1      SET	.LUM1 + .STEP1
     18  6223				   .LUM2      SET	.LUM2 + .STEP2
     19  6223				   .LUM3      SET	.LUM3 + .STEP3
     13  6223					      REPEND
     14  6224		       98		      .byte.b	$90+(.LUM1/256)
     15  6225		       b7		      .byte.b	$B0+(.LUM2/256)
     16  6226		       27		      .byte.b	$20+(.LUM3/256)
     17  6226				   .LUM1      SET	.LUM1 + .STEP1
     18  6226				   .LUM2      SET	.LUM2 + .STEP2
     19  6226				   .LUM3      SET	.LUM3 + .STEP3
     13  6226					      REPEND
     14  6227		       98		      .byte.b	$90+(.LUM1/256)
     15  6228		       b7		      .byte.b	$B0+(.LUM2/256)
     16  6229		       26		      .byte.b	$20+(.LUM3/256)
     17  6229				   .LUM1      SET	.LUM1 + .STEP1
     18  6229				   .LUM2      SET	.LUM2 + .STEP2
     19  6229				   .LUM3      SET	.LUM3 + .STEP3
     13  6229					      REPEND
     14  622a		       97		      .byte.b	$90+(.LUM1/256)
     15  622b		       b7		      .byte.b	$B0+(.LUM2/256)
     16  622c		       26		      .byte.b	$20+(.LUM3/256)
     17  622c				   .LUM1      SET	.LUM1 + .STEP1
     18  622c				   .LUM2      SET	.LUM2 + .STEP2
     19  622c				   .LUM3      SET	.LUM3 + .STEP3
     13  622c					      REPEND
     14  622d		       97		      .byte.b	$90+(.LUM1/256)
     15  622e		       b6		      .byte.b	$B0+(.LUM2/256)
     16  622f		       26		      .byte.b	$20+(.LUM3/256)
     17  622f				   .LUM1      SET	.LUM1 + .STEP1
     18  622f				   .LUM2      SET	.LUM2 + .STEP2
     19  622f				   .LUM3      SET	.LUM3 + .STEP3
     13  622f					      REPEND
     14  6230		       97		      .byte.b	$90+(.LUM1/256)
     15  6231		       b6		      .byte.b	$B0+(.LUM2/256)
     16  6232		       26		      .byte.b	$20+(.LUM3/256)
     17  6232				   .LUM1      SET	.LUM1 + .STEP1
     18  6232				   .LUM2      SET	.LUM2 + .STEP2
     19  6232				   .LUM3      SET	.LUM3 + .STEP3
     13  6232					      REPEND
     14  6233		       96		      .byte.b	$90+(.LUM1/256)
     15  6234		       b6		      .byte.b	$B0+(.LUM2/256)
     16  6235		       25		      .byte.b	$20+(.LUM3/256)
     17  6235				   .LUM1      SET	.LUM1 + .STEP1
     18  6235				   .LUM2      SET	.LUM2 + .STEP2
     19  6235				   .LUM3      SET	.LUM3 + .STEP3
     13  6235					      REPEND
     14  6236		       96		      .byte.b	$90+(.LUM1/256)
     15  6237		       b6		      .byte.b	$B0+(.LUM2/256)
     16  6238		       25		      .byte.b	$20+(.LUM3/256)
     17  6238				   .LUM1      SET	.LUM1 + .STEP1
     18  6238				   .LUM2      SET	.LUM2 + .STEP2
     19  6238				   .LUM3      SET	.LUM3 + .STEP3
     13  6238					      REPEND
     14  6239		       96		      .byte.b	$90+(.LUM1/256)
     15  623a		       b5		      .byte.b	$B0+(.LUM2/256)
     16  623b		       25		      .byte.b	$20+(.LUM3/256)
     17  623b				   .LUM1      SET	.LUM1 + .STEP1
     18  623b				   .LUM2      SET	.LUM2 + .STEP2
     19  623b				   .LUM3      SET	.LUM3 + .STEP3
     13  623b					      REPEND
     14  623c		       96		      .byte.b	$90+(.LUM1/256)
     15  623d		       b5		      .byte.b	$B0+(.LUM2/256)
     16  623e		       25		      .byte.b	$20+(.LUM3/256)
     17  623e				   .LUM1      SET	.LUM1 + .STEP1
     18  623e				   .LUM2      SET	.LUM2 + .STEP2
     19  623e				   .LUM3      SET	.LUM3 + .STEP3
     13  623e					      REPEND
     14  623f		       95		      .byte.b	$90+(.LUM1/256)
     15  6240		       b5		      .byte.b	$B0+(.LUM2/256)
     16  6241		       24		      .byte.b	$20+(.LUM3/256)
     17  6241				   .LUM1      SET	.LUM1 + .STEP1
     18  6241				   .LUM2      SET	.LUM2 + .STEP2
     19  6241				   .LUM3      SET	.LUM3 + .STEP3
     13  6241					      REPEND
     14  6242		       95		      .byte.b	$90+(.LUM1/256)
     15  6243		       b4		      .byte.b	$B0+(.LUM2/256)
     16  6244		       24		      .byte.b	$20+(.LUM3/256)
     17  6244				   .LUM1      SET	.LUM1 + .STEP1
     18  6244				   .LUM2      SET	.LUM2 + .STEP2
     19  6244				   .LUM3      SET	.LUM3 + .STEP3
     13  6244					      REPEND
     14  6245		       95		      .byte.b	$90+(.LUM1/256)
     15  6246		       b4		      .byte.b	$B0+(.LUM2/256)
     16  6247		       24		      .byte.b	$20+(.LUM3/256)
     17  6247				   .LUM1      SET	.LUM1 + .STEP1
     18  6247				   .LUM2      SET	.LUM2 + .STEP2
     19  6247				   .LUM3      SET	.LUM3 + .STEP3
     13  6247					      REPEND
     14  6248		       94		      .byte.b	$90+(.LUM1/256)
     15  6249		       b4		      .byte.b	$B0+(.LUM2/256)
     16  624a		       24		      .byte.b	$20+(.LUM3/256)
     17  624a				   .LUM1      SET	.LUM1 + .STEP1
     18  624a				   .LUM2      SET	.LUM2 + .STEP2
     19  624a				   .LUM3      SET	.LUM3 + .STEP3
     13  624a					      REPEND
     14  624b		       94		      .byte.b	$90+(.LUM1/256)
     15  624c		       b4		      .byte.b	$B0+(.LUM2/256)
     16  624d		       23		      .byte.b	$20+(.LUM3/256)
     17  624d				   .LUM1      SET	.LUM1 + .STEP1
     18  624d				   .LUM2      SET	.LUM2 + .STEP2
     19  624d				   .LUM3      SET	.LUM3 + .STEP3
     13  624d					      REPEND
     14  624e		       94		      .byte.b	$90+(.LUM1/256)
     15  624f		       b3		      .byte.b	$B0+(.LUM2/256)
     16  6250		       23		      .byte.b	$20+(.LUM3/256)
     17  6250				   .LUM1      SET	.LUM1 + .STEP1
     18  6250				   .LUM2      SET	.LUM2 + .STEP2
     19  6250				   .LUM3      SET	.LUM3 + .STEP3
     13  6250					      REPEND
     14  6251		       93		      .byte.b	$90+(.LUM1/256)
     15  6252		       b3		      .byte.b	$B0+(.LUM2/256)
     16  6253		       23		      .byte.b	$20+(.LUM3/256)
     17  6253				   .LUM1      SET	.LUM1 + .STEP1
     18  6253				   .LUM2      SET	.LUM2 + .STEP2
     19  6253				   .LUM3      SET	.LUM3 + .STEP3
     13  6253					      REPEND
     14  6254		       93		      .byte.b	$90+(.LUM1/256)
     15  6255		       b3		      .byte.b	$B0+(.LUM2/256)
     16  6256		       23		      .byte.b	$20+(.LUM3/256)
     17  6256				   .LUM1      SET	.LUM1 + .STEP1
     18  6256				   .LUM2      SET	.LUM2 + .STEP2
     19  6256				   .LUM3      SET	.LUM3 + .STEP3
     13  6256					      REPEND
     14  6257		       93		      .byte.b	$90+(.LUM1/256)
     15  6258		       b3		      .byte.b	$B0+(.LUM2/256)
     16  6259		       22		      .byte.b	$20+(.LUM3/256)
     17  6259				   .LUM1      SET	.LUM1 + .STEP1
     18  6259				   .LUM2      SET	.LUM2 + .STEP2
     19  6259				   .LUM3      SET	.LUM3 + .STEP3
     13  6259					      REPEND
     14  625a		       93		      .byte.b	$90+(.LUM1/256)
     15  625b		       b2		      .byte.b	$B0+(.LUM2/256)
     16  625c		       22		      .byte.b	$20+(.LUM3/256)
     17  625c				   .LUM1      SET	.LUM1 + .STEP1
     18  625c				   .LUM2      SET	.LUM2 + .STEP2
     19  625c				   .LUM3      SET	.LUM3 + .STEP3
     13  625c					      REPEND
     14  625d		       92		      .byte.b	$90+(.LUM1/256)
     15  625e		       b2		      .byte.b	$B0+(.LUM2/256)
     16  625f		       22		      .byte.b	$20+(.LUM3/256)
     17  625f				   .LUM1      SET	.LUM1 + .STEP1
     18  625f				   .LUM2      SET	.LUM2 + .STEP2
     19  625f				   .LUM3      SET	.LUM3 + .STEP3
     13  625f					      REPEND
     14  6260		       92		      .byte.b	$90+(.LUM1/256)
     15  6261		       b2		      .byte.b	$B0+(.LUM2/256)
     16  6262		       22		      .byte.b	$20+(.LUM3/256)
     17  6262				   .LUM1      SET	.LUM1 + .STEP1
     18  6262				   .LUM2      SET	.LUM2 + .STEP2
     19  6262				   .LUM3      SET	.LUM3 + .STEP3
     13  6262					      REPEND
     14  6263		       92		      .byte.b	$90+(.LUM1/256)
     15  6264		       b1		      .byte.b	$B0+(.LUM2/256)
     16  6265		       21		      .byte.b	$20+(.LUM3/256)
     17  6265				   .LUM1      SET	.LUM1 + .STEP1
     18  6265				   .LUM2      SET	.LUM2 + .STEP2
     19  6265				   .LUM3      SET	.LUM3 + .STEP3
     13  6265					      REPEND
     14  6266		       91		      .byte.b	$90+(.LUM1/256)
     15  6267		       b1		      .byte.b	$B0+(.LUM2/256)
     16  6268		       21		      .byte.b	$20+(.LUM3/256)
     17  6268				   .LUM1      SET	.LUM1 + .STEP1
     18  6268				   .LUM2      SET	.LUM2 + .STEP2
     19  6268				   .LUM3      SET	.LUM3 + .STEP3
     13  6268					      REPEND
     14  6269		       91		      .byte.b	$90+(.LUM1/256)
     15  626a		       b1		      .byte.b	$B0+(.LUM2/256)
     16  626b		       21		      .byte.b	$20+(.LUM3/256)
     17  626b				   .LUM1      SET	.LUM1 + .STEP1
     18  626b				   .LUM2      SET	.LUM2 + .STEP2
     19  626b				   .LUM3      SET	.LUM3 + .STEP3
     13  626b					      REPEND
     14  626c		       91		      .byte.b	$90+(.LUM1/256)
     15  626d		       b1		      .byte.b	$B0+(.LUM2/256)
     16  626e		       21		      .byte.b	$20+(.LUM3/256)
     17  626e				   .LUM1      SET	.LUM1 + .STEP1
     18  626e				   .LUM2      SET	.LUM2 + .STEP2
     19  626e				   .LUM3      SET	.LUM3 + .STEP3
     13  626e					      REPEND
     14  626f		       91		      .byte.b	$90+(.LUM1/256)
     15  6270		       b0		      .byte.b	$B0+(.LUM2/256)
     16  6271		       20		      .byte.b	$20+(.LUM3/256)
     17  6271				   .LUM1      SET	.LUM1 + .STEP1
     18  6271				   .LUM2      SET	.LUM2 + .STEP2
     19  6271				   .LUM3      SET	.LUM3 + .STEP3
     13  6271					      REPEND
     14  6272		       90		      .byte.b	$90+(.LUM1/256)
     15  6273		       b0		      .byte.b	$B0+(.LUM2/256)
     16  6274		       20		      .byte.b	$20+(.LUM3/256)
     17  6274				   .LUM1      SET	.LUM1 + .STEP1
     18  6274				   .LUM2      SET	.LUM2 + .STEP2
     19  6274				   .LUM3      SET	.LUM3 + .STEP3
     13  6274					      REPEND
     14  6275		       90		      .byte.b	$90+(.LUM1/256)
     15  6276		       b0		      .byte.b	$B0+(.LUM2/256)
     16  6277		       20		      .byte.b	$20+(.LUM3/256)
     17  6277				   .LUM1      SET	.LUM1 + .STEP1
     18  6277				   .LUM2      SET	.LUM2 + .STEP2
     19  6277				   .LUM3      SET	.LUM3 + .STEP3
     20  6278					      REPEND
      0  6278					      LUMTABLE	$90, $70, $0, $A,$A,$0, $0,$0,$0, COLOUR_LINES	; PAL
      1  6278
      2  6278
      3  6278
      4  6278
      5  6278				   .LUM1      SET	$A*256
      6  6278				   .LUM2      SET	$A*256
      7  6278				   .LUM3      SET	$0*256
      8  6278
      9  6278		       ff ff ff c0 .STEP1     =	(256*($0-$A))/40
     10  6278		       ff ff ff c0 .STEP2     =	(256*($0-$A))/40
     11  6278		       00 00	   .STEP3     =	(256*($0-$0))/40
     12  6278
     13  6278					      REPEAT	40
     14  6278		       9a		      .byte.b	$90+(.LUM1/256)
     15  6279		       7a		      .byte.b	$70+(.LUM2/256)
     16  627a		       00		      .byte.b	$0+(.LUM3/256)
     17  627a				   .LUM1      SET	.LUM1 + .STEP1
     18  627a				   .LUM2      SET	.LUM2 + .STEP2
     19  627a				   .LUM3      SET	.LUM3 + .STEP3
     13  627a					      REPEND
     14  627b		       99		      .byte.b	$90+(.LUM1/256)
     15  627c		       79		      .byte.b	$70+(.LUM2/256)
     16  627d		       00		      .byte.b	$0+(.LUM3/256)
     17  627d				   .LUM1      SET	.LUM1 + .STEP1
     18  627d				   .LUM2      SET	.LUM2 + .STEP2
     19  627d				   .LUM3      SET	.LUM3 + .STEP3
     13  627d					      REPEND
     14  627e		       99		      .byte.b	$90+(.LUM1/256)
     15  627f		       79		      .byte.b	$70+(.LUM2/256)
     16  6280		       00		      .byte.b	$0+(.LUM3/256)
     17  6280				   .LUM1      SET	.LUM1 + .STEP1
     18  6280				   .LUM2      SET	.LUM2 + .STEP2
     19  6280				   .LUM3      SET	.LUM3 + .STEP3
     13  6280					      REPEND
     14  6281		       99		      .byte.b	$90+(.LUM1/256)
     15  6282		       79		      .byte.b	$70+(.LUM2/256)
     16  6283		       00		      .byte.b	$0+(.LUM3/256)
     17  6283				   .LUM1      SET	.LUM1 + .STEP1
     18  6283				   .LUM2      SET	.LUM2 + .STEP2
     19  6283				   .LUM3      SET	.LUM3 + .STEP3
     13  6283					      REPEND
     14  6284		       99		      .byte.b	$90+(.LUM1/256)
     15  6285		       79		      .byte.b	$70+(.LUM2/256)
     16  6286		       00		      .byte.b	$0+(.LUM3/256)
     17  6286				   .LUM1      SET	.LUM1 + .STEP1
     18  6286				   .LUM2      SET	.LUM2 + .STEP2
     19  6286				   .LUM3      SET	.LUM3 + .STEP3
     13  6286					      REPEND
     14  6287		       98		      .byte.b	$90+(.LUM1/256)
     15  6288		       78		      .byte.b	$70+(.LUM2/256)
     16  6289		       00		      .byte.b	$0+(.LUM3/256)
     17  6289				   .LUM1      SET	.LUM1 + .STEP1
     18  6289				   .LUM2      SET	.LUM2 + .STEP2
     19  6289				   .LUM3      SET	.LUM3 + .STEP3
     13  6289					      REPEND
     14  628a		       98		      .byte.b	$90+(.LUM1/256)
     15  628b		       78		      .byte.b	$70+(.LUM2/256)
     16  628c		       00		      .byte.b	$0+(.LUM3/256)
     17  628c				   .LUM1      SET	.LUM1 + .STEP1
     18  628c				   .LUM2      SET	.LUM2 + .STEP2
     19  628c				   .LUM3      SET	.LUM3 + .STEP3
     13  628c					      REPEND
     14  628d		       98		      .byte.b	$90+(.LUM1/256)
     15  628e		       78		      .byte.b	$70+(.LUM2/256)
     16  628f		       00		      .byte.b	$0+(.LUM3/256)
     17  628f				   .LUM1      SET	.LUM1 + .STEP1
     18  628f				   .LUM2      SET	.LUM2 + .STEP2
     19  628f				   .LUM3      SET	.LUM3 + .STEP3
     13  628f					      REPEND
     14  6290		       98		      .byte.b	$90+(.LUM1/256)
     15  6291		       78		      .byte.b	$70+(.LUM2/256)
     16  6292		       00		      .byte.b	$0+(.LUM3/256)
     17  6292				   .LUM1      SET	.LUM1 + .STEP1
     18  6292				   .LUM2      SET	.LUM2 + .STEP2
     19  6292				   .LUM3      SET	.LUM3 + .STEP3
     13  6292					      REPEND
     14  6293		       97		      .byte.b	$90+(.LUM1/256)
     15  6294		       77		      .byte.b	$70+(.LUM2/256)
     16  6295		       00		      .byte.b	$0+(.LUM3/256)
     17  6295				   .LUM1      SET	.LUM1 + .STEP1
     18  6295				   .LUM2      SET	.LUM2 + .STEP2
     19  6295				   .LUM3      SET	.LUM3 + .STEP3
     13  6295					      REPEND
     14  6296		       97		      .byte.b	$90+(.LUM1/256)
     15  6297		       77		      .byte.b	$70+(.LUM2/256)
     16  6298		       00		      .byte.b	$0+(.LUM3/256)
     17  6298				   .LUM1      SET	.LUM1 + .STEP1
     18  6298				   .LUM2      SET	.LUM2 + .STEP2
     19  6298				   .LUM3      SET	.LUM3 + .STEP3
     13  6298					      REPEND
     14  6299		       97		      .byte.b	$90+(.LUM1/256)
     15  629a		       77		      .byte.b	$70+(.LUM2/256)
     16  629b		       00		      .byte.b	$0+(.LUM3/256)
     17  629b				   .LUM1      SET	.LUM1 + .STEP1
     18  629b				   .LUM2      SET	.LUM2 + .STEP2
     19  629b				   .LUM3      SET	.LUM3 + .STEP3
     13  629b					      REPEND
     14  629c		       97		      .byte.b	$90+(.LUM1/256)
     15  629d		       77		      .byte.b	$70+(.LUM2/256)
     16  629e		       00		      .byte.b	$0+(.LUM3/256)
     17  629e				   .LUM1      SET	.LUM1 + .STEP1
     18  629e				   .LUM2      SET	.LUM2 + .STEP2
     19  629e				   .LUM3      SET	.LUM3 + .STEP3
     13  629e					      REPEND
     14  629f		       96		      .byte.b	$90+(.LUM1/256)
     15  62a0		       76		      .byte.b	$70+(.LUM2/256)
     16  62a1		       00		      .byte.b	$0+(.LUM3/256)
     17  62a1				   .LUM1      SET	.LUM1 + .STEP1
     18  62a1				   .LUM2      SET	.LUM2 + .STEP2
     19  62a1				   .LUM3      SET	.LUM3 + .STEP3
     13  62a1					      REPEND
     14  62a2		       96		      .byte.b	$90+(.LUM1/256)
     15  62a3		       76		      .byte.b	$70+(.LUM2/256)
     16  62a4		       00		      .byte.b	$0+(.LUM3/256)
     17  62a4				   .LUM1      SET	.LUM1 + .STEP1
     18  62a4				   .LUM2      SET	.LUM2 + .STEP2
     19  62a4				   .LUM3      SET	.LUM3 + .STEP3
     13  62a4					      REPEND
     14  62a5		       96		      .byte.b	$90+(.LUM1/256)
     15  62a6		       76		      .byte.b	$70+(.LUM2/256)
     16  62a7		       00		      .byte.b	$0+(.LUM3/256)
     17  62a7				   .LUM1      SET	.LUM1 + .STEP1
     18  62a7				   .LUM2      SET	.LUM2 + .STEP2
     19  62a7				   .LUM3      SET	.LUM3 + .STEP3
     13  62a7					      REPEND
     14  62a8		       96		      .byte.b	$90+(.LUM1/256)
     15  62a9		       76		      .byte.b	$70+(.LUM2/256)
     16  62aa		       00		      .byte.b	$0+(.LUM3/256)
     17  62aa				   .LUM1      SET	.LUM1 + .STEP1
     18  62aa				   .LUM2      SET	.LUM2 + .STEP2
     19  62aa				   .LUM3      SET	.LUM3 + .STEP3
     13  62aa					      REPEND
     14  62ab		       95		      .byte.b	$90+(.LUM1/256)
     15  62ac		       75		      .byte.b	$70+(.LUM2/256)
     16  62ad		       00		      .byte.b	$0+(.LUM3/256)
     17  62ad				   .LUM1      SET	.LUM1 + .STEP1
     18  62ad				   .LUM2      SET	.LUM2 + .STEP2
     19  62ad				   .LUM3      SET	.LUM3 + .STEP3
     13  62ad					      REPEND
     14  62ae		       95		      .byte.b	$90+(.LUM1/256)
     15  62af		       75		      .byte.b	$70+(.LUM2/256)
     16  62b0		       00		      .byte.b	$0+(.LUM3/256)
     17  62b0				   .LUM1      SET	.LUM1 + .STEP1
     18  62b0				   .LUM2      SET	.LUM2 + .STEP2
     19  62b0				   .LUM3      SET	.LUM3 + .STEP3
     13  62b0					      REPEND
     14  62b1		       95		      .byte.b	$90+(.LUM1/256)
     15  62b2		       75		      .byte.b	$70+(.LUM2/256)
     16  62b3		       00		      .byte.b	$0+(.LUM3/256)
     17  62b3				   .LUM1      SET	.LUM1 + .STEP1
     18  62b3				   .LUM2      SET	.LUM2 + .STEP2
     19  62b3				   .LUM3      SET	.LUM3 + .STEP3
     13  62b3					      REPEND
     14  62b4		       95		      .byte.b	$90+(.LUM1/256)
     15  62b5		       75		      .byte.b	$70+(.LUM2/256)
     16  62b6		       00		      .byte.b	$0+(.LUM3/256)
     17  62b6				   .LUM1      SET	.LUM1 + .STEP1
     18  62b6				   .LUM2      SET	.LUM2 + .STEP2
     19  62b6				   .LUM3      SET	.LUM3 + .STEP3
     13  62b6					      REPEND
     14  62b7		       94		      .byte.b	$90+(.LUM1/256)
     15  62b8		       74		      .byte.b	$70+(.LUM2/256)
     16  62b9		       00		      .byte.b	$0+(.LUM3/256)
     17  62b9				   .LUM1      SET	.LUM1 + .STEP1
     18  62b9				   .LUM2      SET	.LUM2 + .STEP2
     19  62b9				   .LUM3      SET	.LUM3 + .STEP3
     13  62b9					      REPEND
     14  62ba		       94		      .byte.b	$90+(.LUM1/256)
     15  62bb		       74		      .byte.b	$70+(.LUM2/256)
     16  62bc		       00		      .byte.b	$0+(.LUM3/256)
     17  62bc				   .LUM1      SET	.LUM1 + .STEP1
     18  62bc				   .LUM2      SET	.LUM2 + .STEP2
     19  62bc				   .LUM3      SET	.LUM3 + .STEP3
     13  62bc					      REPEND
     14  62bd		       94		      .byte.b	$90+(.LUM1/256)
     15  62be		       74		      .byte.b	$70+(.LUM2/256)
     16  62bf		       00		      .byte.b	$0+(.LUM3/256)
     17  62bf				   .LUM1      SET	.LUM1 + .STEP1
     18  62bf				   .LUM2      SET	.LUM2 + .STEP2
     19  62bf				   .LUM3      SET	.LUM3 + .STEP3
     13  62bf					      REPEND
     14  62c0		       94		      .byte.b	$90+(.LUM1/256)
     15  62c1		       74		      .byte.b	$70+(.LUM2/256)
     16  62c2		       00		      .byte.b	$0+(.LUM3/256)
     17  62c2				   .LUM1      SET	.LUM1 + .STEP1
     18  62c2				   .LUM2      SET	.LUM2 + .STEP2
     19  62c2				   .LUM3      SET	.LUM3 + .STEP3
     13  62c2					      REPEND
     14  62c3		       93		      .byte.b	$90+(.LUM1/256)
     15  62c4		       73		      .byte.b	$70+(.LUM2/256)
     16  62c5		       00		      .byte.b	$0+(.LUM3/256)
     17  62c5				   .LUM1      SET	.LUM1 + .STEP1
     18  62c5				   .LUM2      SET	.LUM2 + .STEP2
     19  62c5				   .LUM3      SET	.LUM3 + .STEP3
     13  62c5					      REPEND
     14  62c6		       93		      .byte.b	$90+(.LUM1/256)
     15  62c7		       73		      .byte.b	$70+(.LUM2/256)
     16  62c8		       00		      .byte.b	$0+(.LUM3/256)
     17  62c8				   .LUM1      SET	.LUM1 + .STEP1
     18  62c8				   .LUM2      SET	.LUM2 + .STEP2
     19  62c8				   .LUM3      SET	.LUM3 + .STEP3
     13  62c8					      REPEND
     14  62c9		       93		      .byte.b	$90+(.LUM1/256)
     15  62ca		       73		      .byte.b	$70+(.LUM2/256)
     16  62cb		       00		      .byte.b	$0+(.LUM3/256)
     17  62cb				   .LUM1      SET	.LUM1 + .STEP1
     18  62cb				   .LUM2      SET	.LUM2 + .STEP2
     19  62cb				   .LUM3      SET	.LUM3 + .STEP3
     13  62cb					      REPEND
     14  62cc		       93		      .byte.b	$90+(.LUM1/256)
     15  62cd		       73		      .byte.b	$70+(.LUM2/256)
     16  62ce		       00		      .byte.b	$0+(.LUM3/256)
     17  62ce				   .LUM1      SET	.LUM1 + .STEP1
     18  62ce				   .LUM2      SET	.LUM2 + .STEP2
     19  62ce				   .LUM3      SET	.LUM3 + .STEP3
     13  62ce					      REPEND
     14  62cf		       92		      .byte.b	$90+(.LUM1/256)
     15  62d0		       72		      .byte.b	$70+(.LUM2/256)
     16  62d1		       00		      .byte.b	$0+(.LUM3/256)
     17  62d1				   .LUM1      SET	.LUM1 + .STEP1
     18  62d1				   .LUM2      SET	.LUM2 + .STEP2
     19  62d1				   .LUM3      SET	.LUM3 + .STEP3
     13  62d1					      REPEND
     14  62d2		       92		      .byte.b	$90+(.LUM1/256)
     15  62d3		       72		      .byte.b	$70+(.LUM2/256)
     16  62d4		       00		      .byte.b	$0+(.LUM3/256)
     17  62d4				   .LUM1      SET	.LUM1 + .STEP1
     18  62d4				   .LUM2      SET	.LUM2 + .STEP2
     19  62d4				   .LUM3      SET	.LUM3 + .STEP3
     13  62d4					      REPEND
     14  62d5		       92		      .byte.b	$90+(.LUM1/256)
     15  62d6		       72		      .byte.b	$70+(.LUM2/256)
     16  62d7		       00		      .byte.b	$0+(.LUM3/256)
     17  62d7				   .LUM1      SET	.LUM1 + .STEP1
     18  62d7				   .LUM2      SET	.LUM2 + .STEP2
     19  62d7				   .LUM3      SET	.LUM3 + .STEP3
     13  62d7					      REPEND
     14  62d8		       92		      .byte.b	$90+(.LUM1/256)
     15  62d9		       72		      .byte.b	$70+(.LUM2/256)
     16  62da		       00		      .byte.b	$0+(.LUM3/256)
     17  62da				   .LUM1      SET	.LUM1 + .STEP1
     18  62da				   .LUM2      SET	.LUM2 + .STEP2
     19  62da				   .LUM3      SET	.LUM3 + .STEP3
     13  62da					      REPEND
     14  62db		       91		      .byte.b	$90+(.LUM1/256)
     15  62dc		       71		      .byte.b	$70+(.LUM2/256)
     16  62dd		       00		      .byte.b	$0+(.LUM3/256)
     17  62dd				   .LUM1      SET	.LUM1 + .STEP1
     18  62dd				   .LUM2      SET	.LUM2 + .STEP2
     19  62dd				   .LUM3      SET	.LUM3 + .STEP3
     13  62dd					      REPEND
     14  62de		       91		      .byte.b	$90+(.LUM1/256)
     15  62df		       71		      .byte.b	$70+(.LUM2/256)
     16  62e0		       00		      .byte.b	$0+(.LUM3/256)
     17  62e0				   .LUM1      SET	.LUM1 + .STEP1
     18  62e0				   .LUM2      SET	.LUM2 + .STEP2
     19  62e0				   .LUM3      SET	.LUM3 + .STEP3
     13  62e0					      REPEND
     14  62e1		       91		      .byte.b	$90+(.LUM1/256)
     15  62e2		       71		      .byte.b	$70+(.LUM2/256)
     16  62e3		       00		      .byte.b	$0+(.LUM3/256)
     17  62e3				   .LUM1      SET	.LUM1 + .STEP1
     18  62e3				   .LUM2      SET	.LUM2 + .STEP2
     19  62e3				   .LUM3      SET	.LUM3 + .STEP3
     13  62e3					      REPEND
     14  62e4		       91		      .byte.b	$90+(.LUM1/256)
     15  62e5		       71		      .byte.b	$70+(.LUM2/256)
     16  62e6		       00		      .byte.b	$0+(.LUM3/256)
     17  62e6				   .LUM1      SET	.LUM1 + .STEP1
     18  62e6				   .LUM2      SET	.LUM2 + .STEP2
     19  62e6				   .LUM3      SET	.LUM3 + .STEP3
     13  62e6					      REPEND
     14  62e7		       90		      .byte.b	$90+(.LUM1/256)
     15  62e8		       70		      .byte.b	$70+(.LUM2/256)
     16  62e9		       00		      .byte.b	$0+(.LUM3/256)
     17  62e9				   .LUM1      SET	.LUM1 + .STEP1
     18  62e9				   .LUM2      SET	.LUM2 + .STEP2
     19  62e9				   .LUM3      SET	.LUM3 + .STEP3
     13  62e9					      REPEND
     14  62ea		       90		      .byte.b	$90+(.LUM1/256)
     15  62eb		       70		      .byte.b	$70+(.LUM2/256)
     16  62ec		       00		      .byte.b	$0+(.LUM3/256)
     17  62ec				   .LUM1      SET	.LUM1 + .STEP1
     18  62ec				   .LUM2      SET	.LUM2 + .STEP2
     19  62ec				   .LUM3      SET	.LUM3 + .STEP3
     13  62ec					      REPEND
     14  62ed		       90		      .byte.b	$90+(.LUM1/256)
     15  62ee		       70		      .byte.b	$70+(.LUM2/256)
     16  62ef		       00		      .byte.b	$0+(.LUM3/256)
     17  62ef				   .LUM1      SET	.LUM1 + .STEP1
     18  62ef				   .LUM2      SET	.LUM2 + .STEP2
     19  62ef				   .LUM3      SET	.LUM3 + .STEP3
     20  62f0					      REPEND
    327  62f0
    328  62f0				   quest
    329  62f0					      REPEAT	9
    330  62f0		       60 60 00 	      .byte.b	$60,$60,$0
    329  62f0					      REPEND
    330  62f3		       60 60 00 	      .byte.b	$60,$60,$0
    329  62f3					      REPEND
    330  62f6		       60 60 00 	      .byte.b	$60,$60,$0
    329  62f6					      REPEND
    330  62f9		       60 60 00 	      .byte.b	$60,$60,$0
    329  62f9					      REPEND
    330  62fc		       60 60 00 	      .byte.b	$60,$60,$0
    329  62fc					      REPEND
    330  62ff		       60 60 00 	      .byte.b	$60,$60,$0
    329  62ff					      REPEND
    330  6302		       60 60 00 	      .byte.b	$60,$60,$0
    329  6302					      REPEND
    330  6305		       60 60 00 	      .byte.b	$60,$60,$0
    329  6305					      REPEND
    330  6308		       60 60 00 	      .byte.b	$60,$60,$0
    331  630b					      REPEND
    332  630b
    333  630b				   LDIGIT
    334  630b							;.word blankDig
    335  630b		       00 f4		      .word.w	LEFT_0
    336  630d		       51 f4		      .word.w	LEFT_1
    337  630f		       a2 f4		      .word.w	LEFT_2
    338  6311		       f3 f4		      .word.w	LEFT_3
    339  6313		       44 f5		      .word.w	LEFT_4
    340  6315		       95 f5		      .word.w	LEFT_5
    341  6317		       e6 f5		      .word.w	LEFT_6
    342  6319		       37 f6		      .word.w	LEFT_7
    343  631b		       88 f6		      .word.w	LEFT_8
    344  631d		       d9 f6		      .word.w	LEFT_9
    345  631f
    346  631f				   RDIGIT
    347  631f							;.word blankDig
    348  631f		       1b f4		      .word.w	RIGHT_0
    349  6321		       6c f4		      .word.w	RIGHT_1
    350  6323		       bd f4		      .word.w	RIGHT_2
    351  6325		       0e f5		      .word.w	RIGHT_3
    352  6327		       5f f5		      .word.w	RIGHT_4
    353  6329		       b0 f5		      .word.w	RIGHT_5
    354  632b		       01 f6		      .word.w	RIGHT_6
    355  632d		       52 f6		      .word.w	RIGHT_7
    356  632f		       a3 f6		      .word.w	RIGHT_8
    357  6331		       f4 f6		      .word.w	RIGHT_9
    358  6333
    359  6333				   DIGITHUND
    360  6333							;.word blankDig
    361  6333		       36 f4		      .word.w	HUNDPF1_0
    362  6335		       87 f4		      .word.w	HUNDPF1_1
    363  6337		       d8 f4		      .word.w	HUNDPF1_2
    364  6339		       29 f5		      .word.w	HUNDPF1_3
    365  633b		       7a f5		      .word.w	HUNDPF1_4
    366  633d		       cb f5		      .word.w	HUNDPF1_5
    367  633f		       1c f6		      .word.w	HUNDPF1_6
    368  6341		       6d f6		      .word.w	HUNDPF1_7
    369  6343		       be f6		      .word.w	HUNDPF1_8
    370  6345		       0f f7		      .word.w	HUNDPF1_9
    371  6347		       e5 f1		      .word.w	blankDig
    372  6349
    373  6349
------- FILE bigDigits.asm LEVEL 3 PASS 3
      0  6349					      include	"bigDigits.asm"
      1  6400		       00 00 00 00*	      align	256
      2  6400				   LEFT_0
      3  6400		       38		      .byte.b	56
      4  6401		       7c		      .byte.b	124
      5  6402		       7c		      .byte.b	124
      6  6403		       fe		      .byte.b	254
      7  6404		       ee		      .byte.b	238
      8  6405		       c6		      .byte.b	198
      9  6406		       c6		      .byte.b	198
     10  6407		       c6		      .byte.b	198
     11  6408		       c6		      .byte.b	198
     12  6409		       c6		      .byte.b	198
     13  640a		       c6		      .byte.b	198
     14  640b		       c6		      .byte.b	198
     15  640c		       c6		      .byte.b	198
     16  640d		       c6		      .byte.b	198
     17  640e		       c6		      .byte.b	198
     18  640f		       c6		      .byte.b	198
     19  6410		       c6		      .byte.b	198
     20  6411		       c6		      .byte.b	198
     21  6412		       c6		      .byte.b	198
     22  6413		       c6		      .byte.b	198
     23  6414		       c6		      .byte.b	198
     24  6415		       c6		      .byte.b	198
     25  6416		       ee		      .byte.b	238
     26  6417		       fe		      .byte.b	254
     27  6418		       7c		      .byte.b	124
     28  6419		       7c		      .byte.b	124
     29  641a		       38		      .byte.b	56
     30  641b				   RIGHT_0
     31  641b		       8c		      .byte.b	140
     32  641c		       ce		      .byte.b	206
     33  641d		       ce		      .byte.b	206
     34  641e		       ef		      .byte.b	239
     35  641f		       e7		      .byte.b	231
     36  6420		       63		      .byte.b	99
     37  6421		       63		      .byte.b	99
     38  6422		       63		      .byte.b	99
     39  6423		       63		      .byte.b	99
     40  6424		       63		      .byte.b	99
     41  6425		       63		      .byte.b	99
     42  6426		       63		      .byte.b	99
     43  6427		       63		      .byte.b	99
     44  6428		       63		      .byte.b	99
     45  6429		       63		      .byte.b	99
     46  642a		       63		      .byte.b	99
     47  642b		       63		      .byte.b	99
     48  642c		       63		      .byte.b	99
     49  642d		       63		      .byte.b	99
     50  642e		       63		      .byte.b	99
     51  642f		       63		      .byte.b	99
     52  6430		       63		      .byte.b	99
     53  6431		       e7		      .byte.b	231
     54  6432		       ef		      .byte.b	239
     55  6433		       ce		      .byte.b	206
     56  6434		       ce		      .byte.b	206
     57  6435		       8c		      .byte.b	140
     58  6436				   HUNDPF1_0
     59  6436		       1c		      .byte.b	28
     60  6437		       3e		      .byte.b	62
     61  6438		       3e		      .byte.b	62
     62  6439		       7f		      .byte.b	127
     63  643a		       77		      .byte.b	119
     64  643b		       63		      .byte.b	99
     65  643c		       63		      .byte.b	99
     66  643d		       63		      .byte.b	99
     67  643e		       63		      .byte.b	99
     68  643f		       63		      .byte.b	99
     69  6440		       63		      .byte.b	99
     70  6441		       63		      .byte.b	99
     71  6442		       63		      .byte.b	99
     72  6443		       63		      .byte.b	99
     73  6444		       63		      .byte.b	99
     74  6445		       63		      .byte.b	99
     75  6446		       63		      .byte.b	99
     76  6447		       63		      .byte.b	99
     77  6448		       63		      .byte.b	99
     78  6449		       63		      .byte.b	99
     79  644a		       63		      .byte.b	99
     80  644b		       63		      .byte.b	99
     81  644c		       77		      .byte.b	119
     82  644d		       7f		      .byte.b	127
     83  644e		       3e		      .byte.b	62
     84  644f		       3e		      .byte.b	62
     85  6450		       1c		      .byte.b	28
     86  6451				   LEFT_1
     87  6451		       30		      .byte.b	48
     88  6452		       30		      .byte.b	48
     89  6453		       30		      .byte.b	48
     90  6454		       30		      .byte.b	48
     91  6455		       30		      .byte.b	48
     92  6456		       30		      .byte.b	48
     93  6457		       30		      .byte.b	48
     94  6458		       30		      .byte.b	48
     95  6459		       30		      .byte.b	48
     96  645a		       30		      .byte.b	48
     97  645b		       30		      .byte.b	48
     98  645c		       30		      .byte.b	48
     99  645d		       30		      .byte.b	48
    100  645e		       30		      .byte.b	48
    101  645f		       30		      .byte.b	48
    102  6460		       30		      .byte.b	48
    103  6461		       30		      .byte.b	48
    104  6462		       30		      .byte.b	48
    105  6463		       30		      .byte.b	48
    106  6464		       30		      .byte.b	48
    107  6465		       38		      .byte.b	56
    108  6466		       38		      .byte.b	56
    109  6467		       38		      .byte.b	56
    110  6468		       38		      .byte.b	56
    111  6469		       38		      .byte.b	56
    112  646a		       30		      .byte.b	48
    113  646b		       30		      .byte.b	48
    114  646c				   RIGHT_1
    115  646c		       0c		      .byte.b	12
    116  646d		       0c		      .byte.b	12
    117  646e		       0c		      .byte.b	12
    118  646f		       0c		      .byte.b	12
    119  6470		       0c		      .byte.b	12
    120  6471		       0c		      .byte.b	12
    121  6472		       0c		      .byte.b	12
    122  6473		       0c		      .byte.b	12
    123  6474		       0c		      .byte.b	12
    124  6475		       0c		      .byte.b	12
    125  6476		       0c		      .byte.b	12
    126  6477		       0c		      .byte.b	12
    127  6478		       0c		      .byte.b	12
    128  6479		       0c		      .byte.b	12
    129  647a		       0c		      .byte.b	12
    130  647b		       0c		      .byte.b	12
    131  647c		       0c		      .byte.b	12
    132  647d		       0c		      .byte.b	12
    133  647e		       0c		      .byte.b	12
    134  647f		       0c		      .byte.b	12
    135  6480		       8c		      .byte.b	140
    136  6481		       8c		      .byte.b	140
    137  6482		       8c		      .byte.b	140
    138  6483		       8c		      .byte.b	140
    139  6484		       8c		      .byte.b	140
    140  6485		       0c		      .byte.b	12
    141  6486		       0c		      .byte.b	12
    142  6487				   HUNDPF1_1
    143  6487		       0c		      .byte.b	12
    144  6488		       0c		      .byte.b	12
    145  6489		       0c		      .byte.b	12
    146  648a		       0c		      .byte.b	12
    147  648b		       0c		      .byte.b	12
    148  648c		       0c		      .byte.b	12
    149  648d		       0c		      .byte.b	12
    150  648e		       0c		      .byte.b	12
    151  648f		       0c		      .byte.b	12
    152  6490		       0c		      .byte.b	12
    153  6491		       0c		      .byte.b	12
    154  6492		       0c		      .byte.b	12
    155  6493		       0c		      .byte.b	12
    156  6494		       0c		      .byte.b	12
    157  6495		       0c		      .byte.b	12
    158  6496		       0c		      .byte.b	12
    159  6497		       0c		      .byte.b	12
    160  6498		       0c		      .byte.b	12
    161  6499		       0c		      .byte.b	12
    162  649a		       0c		      .byte.b	12
    163  649b		       1c		      .byte.b	28
    164  649c		       1c		      .byte.b	28
    165  649d		       1c		      .byte.b	28
    166  649e		       1c		      .byte.b	28
    167  649f		       1c		      .byte.b	28
    168  64a0		       0c		      .byte.b	12
    169  64a1		       0c		      .byte.b	12
    170  64a2				   LEFT_2
    171  64a2		       fe		      .byte.b	254
    172  64a3		       fe		      .byte.b	254
    173  64a4		       fe		      .byte.b	254
    174  64a5		       fe		      .byte.b	254
    175  64a6		       c6		      .byte.b	198
    176  64a7		       06		      .byte.b	6
    177  64a8		       06		      .byte.b	6
    178  64a9		       06		      .byte.b	6
    179  64aa		       0e		      .byte.b	14
    180  64ab		       0e		      .byte.b	14
    181  64ac		       1c		      .byte.b	28
    182  64ad		       3c		      .byte.b	60
    183  64ae		       78		      .byte.b	120
    184  64af		       70		      .byte.b	112
    185  64b0		       e0		      .byte.b	224
    186  64b1		       e0		      .byte.b	224
    187  64b2		       c0		      .byte.b	192
    188  64b3		       c0		      .byte.b	192
    189  64b4		       c0		      .byte.b	192
    190  64b5		       c6		      .byte.b	198
    191  64b6		       c6		      .byte.b	198
    192  64b7		       c6		      .byte.b	198
    193  64b8		       ee		      .byte.b	238
    194  64b9		       fe		      .byte.b	254
    195  64ba		       7c		      .byte.b	124
    196  64bb		       7c		      .byte.b	124
    197  64bc		       38		      .byte.b	56
    198  64bd				   RIGHT_2
    199  64bd		       ef		      .byte.b	239
    200  64be		       ef		      .byte.b	239
    201  64bf		       ef		      .byte.b	239
    202  64c0		       ef		      .byte.b	239
    203  64c1		       63		      .byte.b	99
    204  64c2		       60		      .byte.b	96
    205  64c3		       60		      .byte.b	96
    206  64c4		       60		      .byte.b	96
    207  64c5		       e0		      .byte.b	224
    208  64c6		       e0		      .byte.b	224
    209  64c7		       c8		      .byte.b	200
    210  64c8		       cc		      .byte.b	204
    211  64c9		       8e		      .byte.b	142
    212  64ca		       0e		      .byte.b	14
    213  64cb		       07		      .byte.b	7
    214  64cc		       07		      .byte.b	7
    215  64cd		       03		      .byte.b	3
    216  64ce		       03		      .byte.b	3
    217  64cf		       03		      .byte.b	3
    218  64d0		       63		      .byte.b	99
    219  64d1		       63		      .byte.b	99
    220  64d2		       63		      .byte.b	99
    221  64d3		       e7		      .byte.b	231
    222  64d4		       ef		      .byte.b	239
    223  64d5		       ce		      .byte.b	206
    224  64d6		       ce		      .byte.b	206
    225  64d7		       8c		      .byte.b	140
    226  64d8				   HUNDPF1_2
    227  64d8		       7f		      .byte.b	127
    228  64d9		       7f		      .byte.b	127
    229  64da		       7f		      .byte.b	127
    230  64db		       7f		      .byte.b	127
    231  64dc		       63		      .byte.b	99
    232  64dd		       60		      .byte.b	96
    233  64de		       60		      .byte.b	96
    234  64df		       60		      .byte.b	96
    235  64e0		       70		      .byte.b	112
    236  64e1		       70		      .byte.b	112
    237  64e2		       38		      .byte.b	56
    238  64e3		       3c		      .byte.b	60
    239  64e4		       1e		      .byte.b	30
    240  64e5		       0e		      .byte.b	14
    241  64e6		       07		      .byte.b	7
    242  64e7		       07		      .byte.b	7
    243  64e8		       03		      .byte.b	3
    244  64e9		       03		      .byte.b	3
    245  64ea		       03		      .byte.b	3
    246  64eb		       63		      .byte.b	99
    247  64ec		       63		      .byte.b	99
    248  64ed		       63		      .byte.b	99
    249  64ee		       77		      .byte.b	119
    250  64ef		       7f		      .byte.b	127
    251  64f0		       3e		      .byte.b	62
    252  64f1		       3e		      .byte.b	62
    253  64f2		       1c		      .byte.b	28
    254  64f3				   LEFT_3
    255  64f3		       38		      .byte.b	56
    256  64f4		       7c		      .byte.b	124
    257  64f5		       7c		      .byte.b	124
    258  64f6		       fe		      .byte.b	254
    259  64f7		       ee		      .byte.b	238
    260  64f8		       c6		      .byte.b	198
    261  64f9		       c6		      .byte.b	198
    262  64fa		       c6		      .byte.b	198
    263  64fb		       c0		      .byte.b	192
    264  64fc		       c0		      .byte.b	192
    265  64fd		       c0		      .byte.b	192
    266  64fe		       e0		      .byte.b	224
    267  64ff		       f8		      .byte.b	248
    268  6500		       78		      .byte.b	120
    269  6501		       78		      .byte.b	120
    270  6502		       f8		      .byte.b	248
    271  6503		       e0		      .byte.b	224
    272  6504		       c0		      .byte.b	192
    273  6505		       c0		      .byte.b	192
    274  6506		       c6		      .byte.b	198
    275  6507		       c6		      .byte.b	198
    276  6508		       c6		      .byte.b	198
    277  6509		       ee		      .byte.b	238
    278  650a		       fe		      .byte.b	254
    279  650b		       7c		      .byte.b	124
    280  650c		       7c		      .byte.b	124
    281  650d		       38		      .byte.b	56
    282  650e				   RIGHT_3
    283  650e		       8c		      .byte.b	140
    284  650f		       ce		      .byte.b	206
    285  6510		       ce		      .byte.b	206
    286  6511		       ef		      .byte.b	239
    287  6512		       e7		      .byte.b	231
    288  6513		       63		      .byte.b	99
    289  6514		       63		      .byte.b	99
    290  6515		       63		      .byte.b	99
    291  6516		       03		      .byte.b	3
    292  6517		       03		      .byte.b	3
    293  6518		       03		      .byte.b	3
    294  6519		       07		      .byte.b	7
    295  651a		       8f		      .byte.b	143
    296  651b		       8e		      .byte.b	142
    297  651c		       8e		      .byte.b	142
    298  651d		       8f		      .byte.b	143
    299  651e		       07		      .byte.b	7
    300  651f		       03		      .byte.b	3
    301  6520		       03		      .byte.b	3
    302  6521		       63		      .byte.b	99
    303  6522		       63		      .byte.b	99
    304  6523		       63		      .byte.b	99
    305  6524		       e7		      .byte.b	231
    306  6525		       ef		      .byte.b	239
    307  6526		       ce		      .byte.b	206
    308  6527		       ce		      .byte.b	206
    309  6528		       8c		      .byte.b	140
    310  6529				   HUNDPF1_3
    311  6529		       1c		      .byte.b	28
    312  652a		       3e		      .byte.b	62
    313  652b		       3e		      .byte.b	62
    314  652c		       7f		      .byte.b	127
    315  652d		       77		      .byte.b	119
    316  652e		       63		      .byte.b	99
    317  652f		       63		      .byte.b	99
    318  6530		       63		      .byte.b	99
    319  6531		       03		      .byte.b	3
    320  6532		       03		      .byte.b	3
    321  6533		       03		      .byte.b	3
    322  6534		       07		      .byte.b	7
    323  6535		       1f		      .byte.b	31
    324  6536		       1e		      .byte.b	30
    325  6537		       1e		      .byte.b	30
    326  6538		       1f		      .byte.b	31
    327  6539		       07		      .byte.b	7
    328  653a		       03		      .byte.b	3
    329  653b		       03		      .byte.b	3
    330  653c		       63		      .byte.b	99
    331  653d		       63		      .byte.b	99
    332  653e		       63		      .byte.b	99
    333  653f		       77		      .byte.b	119
    334  6540		       7f		      .byte.b	127
    335  6541		       3e		      .byte.b	62
    336  6542		       3e		      .byte.b	62
    337  6543		       1c		      .byte.b	28
    338  6544				   LEFT_4
    339  6544		       60		      .byte.b	96
    340  6545		       60		      .byte.b	96
    341  6546		       60		      .byte.b	96
    342  6547		       60		      .byte.b	96
    343  6548		       60		      .byte.b	96
    344  6549		       fe		      .byte.b	254
    345  654a		       fe		      .byte.b	254
    346  654b		       fe		      .byte.b	254
    347  654c		       fe		      .byte.b	254
    348  654d		       66		      .byte.b	102
    349  654e		       66		      .byte.b	102
    350  654f		       66		      .byte.b	102
    351  6550		       66		      .byte.b	102
    352  6551		       6c		      .byte.b	108
    353  6552		       6c		      .byte.b	108
    354  6553		       6c		      .byte.b	108
    355  6554		       6c		      .byte.b	108
    356  6555		       78		      .byte.b	120
    357  6556		       78		      .byte.b	120
    358  6557		       78		      .byte.b	120
    359  6558		       78		      .byte.b	120
    360  6559		       70		      .byte.b	112
    361  655a		       70		      .byte.b	112
    362  655b		       70		      .byte.b	112
    363  655c		       70		      .byte.b	112
    364  655d		       60		      .byte.b	96
    365  655e		       60		      .byte.b	96
    366  655f				   RIGHT_4
    367  655f		       06		      .byte.b	6
    368  6560		       06		      .byte.b	6
    369  6561		       06		      .byte.b	6
    370  6562		       06		      .byte.b	6
    371  6563		       06		      .byte.b	6
    372  6564		       ef		      .byte.b	239
    373  6565		       ef		      .byte.b	239
    374  6566		       ef		      .byte.b	239
    375  6567		       ef		      .byte.b	239
    376  6568		       66		      .byte.b	102
    377  6569		       66		      .byte.b	102
    378  656a		       66		      .byte.b	102
    379  656b		       66		      .byte.b	102
    380  656c		       c6		      .byte.b	198
    381  656d		       c6		      .byte.b	198
    382  656e		       c6		      .byte.b	198
    383  656f		       c6		      .byte.b	198
    384  6570		       8e		      .byte.b	142
    385  6571		       8e		      .byte.b	142
    386  6572		       8e		      .byte.b	142
    387  6573		       8e		      .byte.b	142
    388  6574		       0e		      .byte.b	14
    389  6575		       0e		      .byte.b	14
    390  6576		       0e		      .byte.b	14
    391  6577		       0e		      .byte.b	14
    392  6578		       06		      .byte.b	6
    393  6579		       06		      .byte.b	6
    394  657a				   HUNDPF1_4
    395  657a		       06		      .byte.b	6
    396  657b		       06		      .byte.b	6
    397  657c		       06		      .byte.b	6
    398  657d		       06		      .byte.b	6
    399  657e		       06		      .byte.b	6
    400  657f		       7f		      .byte.b	127
    401  6580		       7f		      .byte.b	127
    402  6581		       7f		      .byte.b	127
    403  6582		       7f		      .byte.b	127
    404  6583		       66		      .byte.b	102
    405  6584		       66		      .byte.b	102
    406  6585		       66		      .byte.b	102
    407  6586		       66		      .byte.b	102
    408  6587		       36		      .byte.b	54
    409  6588		       36		      .byte.b	54
    410  6589		       36		      .byte.b	54
    411  658a		       36		      .byte.b	54
    412  658b		       1e		      .byte.b	30
    413  658c		       1e		      .byte.b	30
    414  658d		       1e		      .byte.b	30
    415  658e		       1e		      .byte.b	30
    416  658f		       0e		      .byte.b	14
    417  6590		       0e		      .byte.b	14
    418  6591		       0e		      .byte.b	14
    419  6592		       0e		      .byte.b	14
    420  6593		       06		      .byte.b	6
    421  6594		       06		      .byte.b	6
    422  6595				   LEFT_5
    423  6595		       38		      .byte.b	56
    424  6596		       7c		      .byte.b	124
    425  6597		       7c		      .byte.b	124
    426  6598		       fe		      .byte.b	254
    427  6599		       ee		      .byte.b	238
    428  659a		       c6		      .byte.b	198
    429  659b		       c6		      .byte.b	198
    430  659c		       c6		      .byte.b	198
    431  659d		       c0		      .byte.b	192
    432  659e		       c0		      .byte.b	192
    433  659f		       c0		      .byte.b	192
    434  65a0		       c0		      .byte.b	192
    435  65a1		       c0		      .byte.b	192
    436  65a2		       c0		      .byte.b	192
    437  65a3		       e6		      .byte.b	230
    438  65a4		       fe		      .byte.b	254
    439  65a5		       7e		      .byte.b	126
    440  65a6		       7e		      .byte.b	126
    441  65a7		       36		      .byte.b	54
    442  65a8		       06		      .byte.b	6
    443  65a9		       06		      .byte.b	6
    444  65aa		       06		      .byte.b	6
    445  65ab		       c6		      .byte.b	198
    446  65ac		       fe		      .byte.b	254
    447  65ad		       fe		      .byte.b	254
    448  65ae		       fe		      .byte.b	254
    449  65af		       fe		      .byte.b	254
    450  65b0				   RIGHT_5
    451  65b0		       8c		      .byte.b	140
    452  65b1		       ce		      .byte.b	206
    453  65b2		       ce		      .byte.b	206
    454  65b3		       ef		      .byte.b	239
    455  65b4		       e7		      .byte.b	231
    456  65b5		       63		      .byte.b	99
    457  65b6		       63		      .byte.b	99
    458  65b7		       63		      .byte.b	99
    459  65b8		       03		      .byte.b	3
    460  65b9		       03		      .byte.b	3
    461  65ba		       03		      .byte.b	3
    462  65bb		       03		      .byte.b	3
    463  65bc		       03		      .byte.b	3
    464  65bd		       03		      .byte.b	3
    465  65be		       67		      .byte.b	103
    466  65bf		       ef		      .byte.b	239
    467  65c0		       ee		      .byte.b	238
    468  65c1		       ee		      .byte.b	238
    469  65c2		       6c		      .byte.b	108
    470  65c3		       60		      .byte.b	96
    471  65c4		       60		      .byte.b	96
    472  65c5		       60		      .byte.b	96
    473  65c6		       63		      .byte.b	99
    474  65c7		       ef		      .byte.b	239
    475  65c8		       ef		      .byte.b	239
    476  65c9		       ef		      .byte.b	239
    477  65ca		       ef		      .byte.b	239
    478  65cb				   HUNDPF1_5
    479  65cb		       1c		      .byte.b	28
    480  65cc		       3e		      .byte.b	62
    481  65cd		       3e		      .byte.b	62
    482  65ce		       7f		      .byte.b	127
    483  65cf		       77		      .byte.b	119
    484  65d0		       63		      .byte.b	99
    485  65d1		       63		      .byte.b	99
    486  65d2		       63		      .byte.b	99
    487  65d3		       03		      .byte.b	3
    488  65d4		       03		      .byte.b	3
    489  65d5		       03		      .byte.b	3
    490  65d6		       03		      .byte.b	3
    491  65d7		       03		      .byte.b	3
    492  65d8		       03		      .byte.b	3
    493  65d9		       67		      .byte.b	103
    494  65da		       7f		      .byte.b	127
    495  65db		       7e		      .byte.b	126
    496  65dc		       7e		      .byte.b	126
    497  65dd		       6c		      .byte.b	108
    498  65de		       60		      .byte.b	96
    499  65df		       60		      .byte.b	96
    500  65e0		       60		      .byte.b	96
    501  65e1		       63		      .byte.b	99
    502  65e2		       7f		      .byte.b	127
    503  65e3		       7f		      .byte.b	127
    504  65e4		       7f		      .byte.b	127
    505  65e5		       7f		      .byte.b	127
    506  65e6				   LEFT_6
    507  65e6		       38		      .byte.b	56
    508  65e7		       7c		      .byte.b	124
    509  65e8		       7c		      .byte.b	124
    510  65e9		       fe		      .byte.b	254
    511  65ea		       ee		      .byte.b	238
    512  65eb		       c6		      .byte.b	198
    513  65ec		       c6		      .byte.b	198
    514  65ed		       c6		      .byte.b	198
    515  65ee		       c6		      .byte.b	198
    516  65ef		       c6		      .byte.b	198
    517  65f0		       c6		      .byte.b	198
    518  65f1		       ee		      .byte.b	238
    519  65f2		       fe		      .byte.b	254
    520  65f3		       7e		      .byte.b	126
    521  65f4		       7e		      .byte.b	126
    522  65f5		       36		      .byte.b	54
    523  65f6		       06		      .byte.b	6
    524  65f7		       06		      .byte.b	6
    525  65f8		       0e		      .byte.b	14
    526  65f9		       0c		      .byte.b	12
    527  65fa		       0c		      .byte.b	12
    528  65fb		       1c		      .byte.b	28
    529  65fc		       1c		      .byte.b	28
    530  65fd		       78		      .byte.b	120
    531  65fe		       78		      .byte.b	120
    532  65ff		       70		      .byte.b	112
    533  6600		       60		      .byte.b	96
    534  6601				   RIGHT_6
    535  6601		       8c		      .byte.b	140
    536  6602		       ce		      .byte.b	206
    537  6603		       ce		      .byte.b	206
    538  6604		       ef		      .byte.b	239
    539  6605		       e7		      .byte.b	231
    540  6606		       63		      .byte.b	99
    541  6607		       63		      .byte.b	99
    542  6608		       63		      .byte.b	99
    543  6609		       63		      .byte.b	99
    544  660a		       63		      .byte.b	99
    545  660b		       63		      .byte.b	99
    546  660c		       e7		      .byte.b	231
    547  660d		       ef		      .byte.b	239
    548  660e		       ee		      .byte.b	238
    549  660f		       ee		      .byte.b	238
    550  6610		       6c		      .byte.b	108
    551  6611		       60		      .byte.b	96
    552  6612		       60		      .byte.b	96
    553  6613		       e0		      .byte.b	224
    554  6614		       c0		      .byte.b	192
    555  6615		       c0		      .byte.b	192
    556  6616		       c8		      .byte.b	200
    557  6617		       c8		      .byte.b	200
    558  6618		       8e		      .byte.b	142
    559  6619		       8e		      .byte.b	142
    560  661a		       0e		      .byte.b	14
    561  661b		       06		      .byte.b	6
    562  661c				   HUNDPF1_6
    563  661c		       1c		      .byte.b	28
    564  661d		       3e		      .byte.b	62
    565  661e		       3e		      .byte.b	62
    566  661f		       7f		      .byte.b	127
    567  6620		       77		      .byte.b	119
    568  6621		       63		      .byte.b	99
    569  6622		       63		      .byte.b	99
    570  6623		       63		      .byte.b	99
    571  6624		       63		      .byte.b	99
    572  6625		       63		      .byte.b	99
    573  6626		       63		      .byte.b	99
    574  6627		       77		      .byte.b	119
    575  6628		       7f		      .byte.b	127
    576  6629		       7e		      .byte.b	126
    577  662a		       7e		      .byte.b	126
    578  662b		       6c		      .byte.b	108
    579  662c		       60		      .byte.b	96
    580  662d		       60		      .byte.b	96
    581  662e		       70		      .byte.b	112
    582  662f		       30		      .byte.b	48
    583  6630		       30		      .byte.b	48
    584  6631		       38		      .byte.b	56
    585  6632		       38		      .byte.b	56
    586  6633		       1e		      .byte.b	30
    587  6634		       1e		      .byte.b	30
    588  6635		       0e		      .byte.b	14
    589  6636		       06		      .byte.b	6
    590  6637				   LEFT_7
    591  6637		       18		      .byte.b	24
    592  6638		       18		      .byte.b	24
    593  6639		       18		      .byte.b	24
    594  663a		       18		      .byte.b	24
    595  663b		       18		      .byte.b	24
    596  663c		       18		      .byte.b	24
    597  663d		       18		      .byte.b	24
    598  663e		       18		      .byte.b	24
    599  663f		       18		      .byte.b	24
    600  6640		       18		      .byte.b	24
    601  6641		       18		      .byte.b	24
    602  6642		       30		      .byte.b	48
    603  6643		       30		      .byte.b	48
    604  6644		       30		      .byte.b	48
    605  6645		       30		      .byte.b	48
    606  6646		       60		      .byte.b	96
    607  6647		       60		      .byte.b	96
    608  6648		       60		      .byte.b	96
    609  6649		       60		      .byte.b	96
    610  664a		       c0		      .byte.b	192
    611  664b		       c0		      .byte.b	192
    612  664c		       c0		      .byte.b	192
    613  664d		       c6		      .byte.b	198
    614  664e		       fe		      .byte.b	254
    615  664f		       fe		      .byte.b	254
    616  6650		       fe		      .byte.b	254
    617  6651		       fe		      .byte.b	254
    618  6652				   RIGHT_7
    619  6652		       88		      .byte.b	136
    620  6653		       88		      .byte.b	136
    621  6654		       88		      .byte.b	136
    622  6655		       88		      .byte.b	136
    623  6656		       88		      .byte.b	136
    624  6657		       88		      .byte.b	136
    625  6658		       88		      .byte.b	136
    626  6659		       88		      .byte.b	136
    627  665a		       88		      .byte.b	136
    628  665b		       88		      .byte.b	136
    629  665c		       88		      .byte.b	136
    630  665d		       0c		      .byte.b	12
    631  665e		       0c		      .byte.b	12
    632  665f		       0c		      .byte.b	12
    633  6660		       0c		      .byte.b	12
    634  6661		       06		      .byte.b	6
    635  6662		       06		      .byte.b	6
    636  6663		       06		      .byte.b	6
    637  6664		       06		      .byte.b	6
    638  6665		       03		      .byte.b	3
    639  6666		       03		      .byte.b	3
    640  6667		       03		      .byte.b	3
    641  6668		       63		      .byte.b	99
    642  6669		       ef		      .byte.b	239
    643  666a		       ef		      .byte.b	239
    644  666b		       ef		      .byte.b	239
    645  666c		       ef		      .byte.b	239
    646  666d				   HUNDPF1_7
    647  666d		       18		      .byte.b	24
    648  666e		       18		      .byte.b	24
    649  666f		       18		      .byte.b	24
    650  6670		       18		      .byte.b	24
    651  6671		       18		      .byte.b	24
    652  6672		       18		      .byte.b	24
    653  6673		       18		      .byte.b	24
    654  6674		       18		      .byte.b	24
    655  6675		       18		      .byte.b	24
    656  6676		       18		      .byte.b	24
    657  6677		       18		      .byte.b	24
    658  6678		       0c		      .byte.b	12
    659  6679		       0c		      .byte.b	12
    660  667a		       0c		      .byte.b	12
    661  667b		       0c		      .byte.b	12
    662  667c		       06		      .byte.b	6
    663  667d		       06		      .byte.b	6
    664  667e		       06		      .byte.b	6
    665  667f		       06		      .byte.b	6
    666  6680		       03		      .byte.b	3
    667  6681		       03		      .byte.b	3
    668  6682		       03		      .byte.b	3
    669  6683		       63		      .byte.b	99
    670  6684		       7f		      .byte.b	127
    671  6685		       7f		      .byte.b	127
    672  6686		       7f		      .byte.b	127
    673  6687		       7f		      .byte.b	127
    674  6688				   LEFT_8
    675  6688		       38		      .byte.b	56
    676  6689		       7c		      .byte.b	124
    677  668a		       7c		      .byte.b	124
    678  668b		       fe		      .byte.b	254
    679  668c		       ee		      .byte.b	238
    680  668d		       c6		      .byte.b	198
    681  668e		       c6		      .byte.b	198
    682  668f		       c6		      .byte.b	198
    683  6690		       c6		      .byte.b	198
    684  6691		       c6		      .byte.b	198
    685  6692		       c6		      .byte.b	198
    686  6693		       ee		      .byte.b	238
    687  6694		       fc		      .byte.b	252
    688  6695		       7c		      .byte.b	124
    689  6696		       7e		      .byte.b	126
    690  6697		       ee		      .byte.b	238
    691  6698		       c6		      .byte.b	198
    692  6699		       c6		      .byte.b	198
    693  669a		       c6		      .byte.b	198
    694  669b		       c6		      .byte.b	198
    695  669c		       c6		      .byte.b	198
    696  669d		       c6		      .byte.b	198
    697  669e		       ee		      .byte.b	238
    698  669f		       fe		      .byte.b	254
    699  66a0		       7c		      .byte.b	124
    700  66a1		       7c		      .byte.b	124
    701  66a2		       38		      .byte.b	56
    702  66a3				   RIGHT_8
    703  66a3		       8c		      .byte.b	140
    704  66a4		       ce		      .byte.b	206
    705  66a5		       ce		      .byte.b	206
    706  66a6		       ef		      .byte.b	239
    707  66a7		       e7		      .byte.b	231
    708  66a8		       63		      .byte.b	99
    709  66a9		       63		      .byte.b	99
    710  66aa		       63		      .byte.b	99
    711  66ab		       63		      .byte.b	99
    712  66ac		       63		      .byte.b	99
    713  66ad		       63		      .byte.b	99
    714  66ae		       e7		      .byte.b	231
    715  66af		       cf		      .byte.b	207
    716  66b0		       ce		      .byte.b	206
    717  66b1		       ee		      .byte.b	238
    718  66b2		       e7		      .byte.b	231
    719  66b3		       63		      .byte.b	99
    720  66b4		       63		      .byte.b	99
    721  66b5		       63		      .byte.b	99
    722  66b6		       63		      .byte.b	99
    723  66b7		       63		      .byte.b	99
    724  66b8		       63		      .byte.b	99
    725  66b9		       e7		      .byte.b	231
    726  66ba		       ef		      .byte.b	239
    727  66bb		       ce		      .byte.b	206
    728  66bc		       ce		      .byte.b	206
    729  66bd		       8c		      .byte.b	140
    730  66be				   HUNDPF1_8
    731  66be		       1c		      .byte.b	28
    732  66bf		       3e		      .byte.b	62
    733  66c0		       3e		      .byte.b	62
    734  66c1		       7f		      .byte.b	127
    735  66c2		       77		      .byte.b	119
    736  66c3		       63		      .byte.b	99
    737  66c4		       63		      .byte.b	99
    738  66c5		       63		      .byte.b	99
    739  66c6		       63		      .byte.b	99
    740  66c7		       63		      .byte.b	99
    741  66c8		       63		      .byte.b	99
    742  66c9		       77		      .byte.b	119
    743  66ca		       3f		      .byte.b	63
    744  66cb		       3e		      .byte.b	62
    745  66cc		       7e		      .byte.b	126
    746  66cd		       77		      .byte.b	119
    747  66ce		       63		      .byte.b	99
    748  66cf		       63		      .byte.b	99
    749  66d0		       63		      .byte.b	99
    750  66d1		       63		      .byte.b	99
    751  66d2		       63		      .byte.b	99
    752  66d3		       63		      .byte.b	99
    753  66d4		       77		      .byte.b	119
    754  66d5		       7f		      .byte.b	127
    755  66d6		       3e		      .byte.b	62
    756  66d7		       3e		      .byte.b	62
    757  66d8		       1c		      .byte.b	28
    758  66d9				   LEFT_9
    759  66d9		       0c		      .byte.b	12
    760  66da		       1c		      .byte.b	28
    761  66db		       3c		      .byte.b	60
    762  66dc		       3c		      .byte.b	60
    763  66dd		       70		      .byte.b	112
    764  66de		       70		      .byte.b	112
    765  66df		       60		      .byte.b	96
    766  66e0		       e0		      .byte.b	224
    767  66e1		       e0		      .byte.b	224
    768  66e2		       c0		      .byte.b	192
    769  66e3		       c0		      .byte.b	192
    770  66e4		       d8		      .byte.b	216
    771  66e5		       fc		      .byte.b	252
    772  66e6		       fc		      .byte.b	252
    773  66e7		       fe		      .byte.b	254
    774  66e8		       ee		      .byte.b	238
    775  66e9		       c6		      .byte.b	198
    776  66ea		       c6		      .byte.b	198
    777  66eb		       c6		      .byte.b	198
    778  66ec		       c6		      .byte.b	198
    779  66ed		       c6		      .byte.b	198
    780  66ee		       c6		      .byte.b	198
    781  66ef		       ee		      .byte.b	238
    782  66f0		       fe		      .byte.b	254
    783  66f1		       7c		      .byte.b	124
    784  66f2		       7c		      .byte.b	124
    785  66f3		       38		      .byte.b	56
    786  66f4				   RIGHT_9
    787  66f4		       c0		      .byte.b	192
    788  66f5		       c8		      .byte.b	200
    789  66f6		       cc		      .byte.b	204
    790  66f7		       cc		      .byte.b	204
    791  66f8		       0e		      .byte.b	14
    792  66f9		       0e		      .byte.b	14
    793  66fa		       06		      .byte.b	6
    794  66fb		       07		      .byte.b	7
    795  66fc		       07		      .byte.b	7
    796  66fd		       03		      .byte.b	3
    797  66fe		       03		      .byte.b	3
    798  66ff		       8b		      .byte.b	139
    799  6700		       cf		      .byte.b	207
    800  6701		       cf		      .byte.b	207
    801  6702		       ef		      .byte.b	239
    802  6703		       e7		      .byte.b	231
    803  6704		       63		      .byte.b	99
    804  6705		       63		      .byte.b	99
    805  6706		       63		      .byte.b	99
    806  6707		       63		      .byte.b	99
    807  6708		       63		      .byte.b	99
    808  6709		       63		      .byte.b	99
    809  670a		       e7		      .byte.b	231
    810  670b		       ef		      .byte.b	239
    811  670c		       ce		      .byte.b	206
    812  670d		       ce		      .byte.b	206
    813  670e		       8c		      .byte.b	140
    814  670f				   HUNDPF1_9
    815  670f		       30		      .byte.b	48
    816  6710		       38		      .byte.b	56
    817  6711		       3c		      .byte.b	60
    818  6712		       3c		      .byte.b	60
    819  6713		       0e		      .byte.b	14
    820  6714		       0e		      .byte.b	14
    821  6715		       06		      .byte.b	6
    822  6716		       07		      .byte.b	7
    823  6717		       07		      .byte.b	7
    824  6718		       03		      .byte.b	3
    825  6719		       03		      .byte.b	3
    826  671a		       1b		      .byte.b	27
    827  671b		       3f		      .byte.b	63
    828  671c		       3f		      .byte.b	63
    829  671d		       7f		      .byte.b	127
    830  671e		       77		      .byte.b	119
    831  671f		       63		      .byte.b	99
    832  6720		       63		      .byte.b	99
    833  6721		       63		      .byte.b	99
    834  6722		       63		      .byte.b	99
    835  6723		       63		      .byte.b	99
    836  6724		       63		      .byte.b	99
    837  6725		       77		      .byte.b	119
    838  6726		       7f		      .byte.b	127
    839  6727		       3e		      .byte.b	62
    840  6728		       3e		      .byte.b	62
    841  6729		       1c		      .byte.b	28
    842  672a				   LEFT_star
    843  672a		       0c		      .byte.b	12
    844  672b		       0c		      .byte.b	12
    845  672c		       0c		      .byte.b	12
    846  672d		       0c		      .byte.b	12
    847  672e		       00		      .byte.b	0
    848  672f		       00		      .byte.b	0
    849  6730		       0c		      .byte.b	12
    850  6731		       0c		      .byte.b	12
    851  6732		       0c		      .byte.b	12
    852  6733		       0c		      .byte.b	12
    853  6734		       0c		      .byte.b	12
    854  6735		       0c		      .byte.b	12
    855  6736		       1c		      .byte.b	28
    856  6737		       1c		      .byte.b	28
    857  6738		       38		      .byte.b	56
    858  6739		       38		      .byte.b	56
    859  673a		       70		      .byte.b	112
    860  673b		       70		      .byte.b	112
    861  673c		       60		      .byte.b	96
    862  673d		       63		      .byte.b	99
    863  673e		       63		      .byte.b	99
    864  673f		       63		      .byte.b	99
    865  6740		       77		      .byte.b	119
    866  6741		       77		      .byte.b	119
    867  6742		       3e		      .byte.b	62
    868  6743		       3e		      .byte.b	62
    869  6744		       1c		      .byte.b	28
    870  6745				   RIGHT_star
    871  6745		       c0		      .byte.b	192
    872  6746		       c0		      .byte.b	192
    873  6747		       c0		      .byte.b	192
    874  6748		       c0		      .byte.b	192
    875  6749		       00		      .byte.b	0
    876  674a		       00		      .byte.b	0
    877  674b		       c0		      .byte.b	192
    878  674c		       c0		      .byte.b	192
    879  674d		       c0		      .byte.b	192
    880  674e		       c0		      .byte.b	192
    881  674f		       c0		      .byte.b	192
    882  6750		       c0		      .byte.b	192
    883  6751		       c8		      .byte.b	200
    884  6752		       c8		      .byte.b	200
    885  6753		       8c		      .byte.b	140
    886  6754		       8c		      .byte.b	140
    887  6755		       0e		      .byte.b	14
    888  6756		       0e		      .byte.b	14
    889  6757		       06		      .byte.b	6
    890  6758		       36		      .byte.b	54
    891  6759		       36		      .byte.b	54
    892  675a		       36		      .byte.b	54
    893  675b		       7e		      .byte.b	126
    894  675c		       7e		      .byte.b	126
    895  675d		       ec		      .byte.b	236
    896  675e		       ec		      .byte.b	236
    897  675f		       c8		      .byte.b	200
    898  6760				   HUNDPF1_star
    899  6760		       30		      .byte.b	48
    900  6761		       30		      .byte.b	48
    901  6762		       30		      .byte.b	48
    902  6763		       30		      .byte.b	48
    903  6764		       00		      .byte.b	0
    904  6765		       00		      .byte.b	0
    905  6766		       30		      .byte.b	48
    906  6767		       30		      .byte.b	48
    907  6768		       30		      .byte.b	48
    908  6769		       30		      .byte.b	48
    909  676a		       30		      .byte.b	48
    910  676b		       30		      .byte.b	48
    911  676c		       38		      .byte.b	56
    912  676d		       38		      .byte.b	56
    913  676e		       1c		      .byte.b	28
    914  676f		       1c		      .byte.b	28
    915  6770		       0e		      .byte.b	14
    916  6771		       0e		      .byte.b	14
    917  6772		       06		      .byte.b	6
    918  6773		       c6		      .byte.b	198
    919  6774		       c6		      .byte.b	198
    920  6775		       c6		      .byte.b	198
    921  6776		       ee		      .byte.b	238
    922  6777		       ee		      .byte.b	238
    923  6778		       7c		      .byte.b	124
    924  6779		       7c		      .byte.b	124
    925  677a		       38		      .byte.b	56
------- FILE levelScreen.asm
    375  677b
      0  677b					      CHECK_BANK_SIZE	"LEVELSCREEN"
      1  677b		       07 7b	   .TEMP      =	* - BANK_START
 LEVELSCREEN (2K) SIZE =  $77b , FREE= $85
      2  677b					      ECHO	"LEVELSCREEN", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  677b				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  677b				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  677b				  -	      ERR
      6  677b					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 3
      0  677b					      include	"BANK_INITBANK.asm"	; MUST be after banks that include levels -- otherwise MAX_LEVELBANK is not calculated properly
      1  677b							;    Sokoboo - a Sokoban implementation
      2  677b							;    using a generic tile-based display engine for the Atari 2600
      3  677b							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  677b							;
      5  677b							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  677b							;
      7  677b							;    Code related to the generic tile-based display engine was developed by
      8  677b							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  677b							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  677b							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  677b							;
     12  677b							;    Code related to music and sound effects uses the TIATracker music player
     13  677b							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  677b							;    directory for Apache licensing details.
     15  677b							;
     16  677b							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  677b							;    See the copyright notices in the License directory for a list of level
     18  677b							;    contributors.
     19  677b							;
     20  677b							;    Except where otherwise indicated, this software is released under the
     21  677b							;    following licensing arrangement...
     22  677b							;
     23  677b							;    This program is free software: you can redistribute it and/or modify
     24  677b							;    it under the terms of the GNU General Public License as published by
     25  677b							;    the Free Software Foundation, either version 3 of the License, or
     26  677b							;    (at your option) any later version.
     27  677b							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  677b
     29  677b							;    This program is distributed in the hope that it will be useful,
     30  677b							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  677b							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  677b							;    GNU General Public License for more details.
     33  677b
      0  677b					      NEWBANK	INITBANK
      1  6d95 ????				      SEG	INITBANK
      2  6800					      ORG	ORIGIN
      3  6800					      RORG	$F000
      4  6800				   BANK_START SET	*
      5  6800				   INITBANK   SET	ORIGIN / 2048
      6  6800				   ORIGIN     SET	ORIGIN + 2048
      7  6800				   _CURRENT_BANK SET	INITBANK
     35  6800
     36  6800		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
     37  6801
      0  6801					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  6801		       00 0d	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  6801					      SUBROUTINE
      3  6801				   BoardLineStartLO
     39  6801
     40  6801							; Gives the start address (LO) of each board line
     41  6801					      if	1
     42  6801				   .BOARD_LOCATION SET	Board
     43  6801					      REPEAT	SIZE_BOARD_Y
     44  6801				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6801				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6801					      ENDIF
     47  6801		       00		      .byte.b	<.BOARD_LOCATION
     48  6801				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6801					      REPEND
     44  6802				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6802				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6802					      ENDIF
     47  6802		       18		      .byte.b	<.BOARD_LOCATION
     48  6802				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6802					      REPEND
     44  6803				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6803				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6803					      ENDIF
     47  6803		       30		      .byte.b	<.BOARD_LOCATION
     48  6803				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6803					      REPEND
     44  6804				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6804				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6804					      ENDIF
     47  6804		       48		      .byte.b	<.BOARD_LOCATION
     48  6804				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6804					      REPEND
     44  6805				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6805				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6805					      ENDIF
     47  6805		       60		      .byte.b	<.BOARD_LOCATION
     48  6805				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6805					      REPEND
     44  6806				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6806				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6806					      ENDIF
     47  6806		       78		      .byte.b	<.BOARD_LOCATION
     48  6806				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6806					      REPEND
     44  6807				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6807				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6807					      ENDIF
     47  6807		       90		      .byte.b	<.BOARD_LOCATION
     48  6807				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6807					      REPEND
     44  6808				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6808				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6808					      ENDIF
     47  6808		       a8		      .byte.b	<.BOARD_LOCATION
     48  6808				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6808					      REPEND
     44  6809				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6809				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6809					      ENDIF
     47  6809		       c0		      .byte.b	<.BOARD_LOCATION
     48  6809				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6809					      REPEND
     44  680a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680a					      ENDIF
     47  680a		       d8		      .byte.b	<.BOARD_LOCATION
     48  680a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680a					      REPEND
     44  680b					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680b				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680b					      ENDIF
     47  680b		       00		      .byte.b	<.BOARD_LOCATION
     48  680b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680b					      REPEND
     44  680c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680c					      ENDIF
     47  680c		       18		      .byte.b	<.BOARD_LOCATION
     48  680c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680c					      REPEND
     44  680d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680d					      ENDIF
     47  680d		       30		      .byte.b	<.BOARD_LOCATION
     48  680d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680d					      REPEND
     44  680e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680e					      ENDIF
     47  680e		       48		      .byte.b	<.BOARD_LOCATION
     48  680e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680e					      REPEND
     44  680f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680f					      ENDIF
     47  680f		       60		      .byte.b	<.BOARD_LOCATION
     48  680f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680f					      REPEND
     44  6810				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6810				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6810					      ENDIF
     47  6810		       78		      .byte.b	<.BOARD_LOCATION
     48  6810				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6810					      REPEND
     44  6811				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6811				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6811					      ENDIF
     47  6811		       90		      .byte.b	<.BOARD_LOCATION
     48  6811				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6811					      REPEND
     44  6812				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6812				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6812					      ENDIF
     47  6812		       a8		      .byte.b	<.BOARD_LOCATION
     48  6812				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6812					      REPEND
     44  6813				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6813				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6813					      ENDIF
     47  6813		       c0		      .byte.b	<.BOARD_LOCATION
     48  6813				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6813					      REPEND
     44  6814				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6814				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6814					      ENDIF
     47  6814		       d8		      .byte.b	<.BOARD_LOCATION
     48  6814				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     49  6815					      REPEND
      0  6815					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  6815					      LIST	ON
     51  6815
     52  6815		       01 f0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     53  6815					      endif
     54  6815
     55  6815							;------------------------------------------------------------------------------
     56  6815
     57  6815				   BoardLineStartHiR
     58  6815
     59  6815							; Gives the start address (HI) of each board line
     60  6815							; Note this caters for the memory wrapping when we go from bank to bank, as
     61  6815							; the board overlays multiple banks!
     62  6815
     63  6815				   .BOARD_LOCATION SET	Board
     64  6815					      REPEAT	SIZE_BOARD_Y
     65  6815				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6815				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6815					      ENDIF
     68  6815		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6815				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6815					      REPEND
     65  6816				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6816				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6816					      ENDIF
     68  6816		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6816				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6816					      REPEND
     65  6817				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6817				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6817					      ENDIF
     68  6817		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6817				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6817					      REPEND
     65  6818				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6818				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6818					      ENDIF
     68  6818		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6818				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6818					      REPEND
     65  6819				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6819				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6819					      ENDIF
     68  6819		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6819				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6819					      REPEND
     65  681a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681a					      ENDIF
     68  681a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681a					      REPEND
     65  681b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681b					      ENDIF
     68  681b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681b					      REPEND
     65  681c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681c					      ENDIF
     68  681c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681c					      REPEND
     65  681d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681d					      ENDIF
     68  681d		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681d					      REPEND
     65  681e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681e					      ENDIF
     68  681e		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681e					      REPEND
     65  681f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681f					      ENDIF
     68  681f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681f					      REPEND
     65  6820				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6820				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6820					      ENDIF
     68  6820		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6820				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6820					      REPEND
     65  6821				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6821				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6821					      ENDIF
     68  6821		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6821				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6821					      REPEND
     65  6822				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6822				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6822					      ENDIF
     68  6822		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6822				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6822					      REPEND
     65  6823				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6823				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6823					      ENDIF
     68  6823		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6823				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6823					      REPEND
     65  6824				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6824				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6824					      ENDIF
     68  6824		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6824				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6824					      REPEND
     65  6825				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6825				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6825					      ENDIF
     68  6825		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6825				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6825					      REPEND
     65  6826				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6826				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6826					      ENDIF
     68  6826		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6826				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6826					      REPEND
     65  6827				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6827				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6827					      ENDIF
     68  6827		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6827				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6827					      REPEND
     65  6828				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6828				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6828					      ENDIF
     68  6828		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6828				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     70  6829					      REPEND
      0  6829					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  6829					      LIST	ON
     72  6829							;------------------------------------------------------------------------------
     73  6829
     74  6829				   BoardLineStartHiW
     75  6829
     76  6829							; Gives the start address (HI) of each board line
     77  6829							; Note this caters for the memory wrapping when we go from bank to bank, as
     78  6829							; the board overlays multiple banks!
     79  6829
     80  6829				   .BOARD_LOCATION SET	Board
     81  6829					      REPEAT	SIZE_BOARD_Y
     82  6829				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6829				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6829					      ENDIF
     85  6829		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6829				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6829					      REPEND
     82  682a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  682a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  682a					      ENDIF
     85  682a		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  682a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  682a					      REPEND
     82  682b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  682b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  682b					      ENDIF
     85  682b		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  682b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  682b					      REPEND
     82  682c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  682c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  682c					      ENDIF
     85  682c		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  682c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  682c					      REPEND
     82  682d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  682d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  682d					      ENDIF
     85  682d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  682d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  682d					      REPEND
     82  682e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  682e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  682e					      ENDIF
     85  682e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  682e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  682e					      REPEND
     82  682f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  682f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  682f					      ENDIF
     85  682f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  682f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  682f					      REPEND
     82  6830				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6830				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6830					      ENDIF
     85  6830		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6830				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6830					      REPEND
     82  6831				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6831				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6831					      ENDIF
     85  6831		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6831				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6831					      REPEND
     82  6832				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6832				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6832					      ENDIF
     85  6832		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6832				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6832					      REPEND
     82  6833					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6833				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6833					      ENDIF
     85  6833		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6833				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6833					      REPEND
     82  6834				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6834				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6834					      ENDIF
     85  6834		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6834				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6834					      REPEND
     82  6835				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6835				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6835					      ENDIF
     85  6835		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6835				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6835					      REPEND
     82  6836				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6836				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6836					      ENDIF
     85  6836		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6836				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6836					      REPEND
     82  6837				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6837				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6837					      ENDIF
     85  6837		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6837				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6837					      REPEND
     82  6838				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6838				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6838					      ENDIF
     85  6838		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6838				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6838					      REPEND
     82  6839				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6839				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6839					      ENDIF
     85  6839		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6839				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6839					      REPEND
     82  683a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683a					      ENDIF
     85  683a		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683a					      REPEND
     82  683b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683b					      ENDIF
     85  683b		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683b					      REPEND
     82  683c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683c					      ENDIF
     85  683c		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     87  683d					      REPEND
      0  683d					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  683d					      LIST	ON
     89  683d
     90  683d							;------------------------------------------------------------------------------
     91  683d							;    IF MULTI_BANK_BOARD = YES
     92  683d							;BoardBank
     93  683d							;    ENDIF
     94  683d							; Gives the RAM bank of the start of the board row for a given row.
     95  683d
     96  683d				   .BOARD_LOCATION SET	Board - RAM_3E
     97  683d					      REPEAT	SIZE_BOARD_Y
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  683d					      REPEND
     98  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  683d					      ENDIF
    101  683d							;    IF MULTI_BANK_BOARD = YES
    102  683d							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  683d							;    ENDIF
    104  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
    105  683d					      REPEND
    106  683d							;    IF MULTI_BANK_BOARD = YES
    107  683d							;    CHECKPAGEX BoardBank, "BoardBank in BANK_INITBANK.asm"
    108  683d							;    ENDIF
    109  683d
    110  683d
    111  683d							;------------------------------------------------------------------------------
    112  683d
    113  683d				   CopyROMShadowToRAM_F000
    114  683d		       a9 f0		      lda	#>$F000
    115  683f
      0  683f					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  683f		       00 0d	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  683f					      SUBROUTINE
      3  683f				   CopyROMShadowToRAM
    117  683f
    118  683f							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
    119  683f							; the variable definitions are in the ROM shadow because this allows auto-initialisation
    120  683f							; of the variable contents from ROM declarations, but still allows access to them as
    121  683f							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
    122  683f							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
    123  683f							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
    124  683f							; code co-lives in all banks and may run even as bankswitching occurs between those
    125  683f							; banks -- by the very code itself.
    126  683f
    127  683f							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
    128  683f		       85 c1		      sta	Board_AddressR+1
    129  6841		       86 dc		      stx	O_ROM_Source_Bank	; source bank
    130  6843		       84 c5		      sty	RAM_Bank	; destination bank
    131  6845
    132  6845		       a0 00		      ldy	#0
    133  6847		       84 c0		      sty	Board_AddressR
    134  6849		       84 c2		      sty	Board_AddressW
    135  684b		       a9 14		      lda	#>($1000+RAM_WRITE)
    136  684d		       85 c3		      sta	Board_AddressW+1
    137  684f
    138  684f							; Iterate 4 pages (1K) for complete bank copy
    139  684f
    140  684f		       a9 04		      lda	#4
    141  6851		       85 db		      sta	O_CopyCount
    142  6853
    143  6853		       84 dd	   CopyPage   sty	O_Index
    144  6855		       a5 dc		      lda	O_ROM_Source_Bank
    145  6857		       20 0f f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    146  685a							;tax
    147  685a		       a4 dd		      ldy	O_Index
    148  685c		       a6 c5		      ldx	RAM_Bank
    149  685e		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    150  6861
    151  6861		       a4 dd		      ldy	O_Index
    152  6863		       c8		      iny
    153  6864		       d0 ed		      bne	CopyPage
    154  6866
    155  6866		       e6 c1		      inc	Board_AddressR+1
    156  6868		       e6 c3		      inc	Board_AddressW+1
    157  686a
    158  686a		       c6 db		      dec	O_CopyCount
    159  686c		       d0 e5		      bne	CopyPage
    160  686e
    161  686e		       a4 c5		      ldy	RAM_Bank	; TODO: remove!?
    162  6870		       60		      rts
    163  6871
    164  6871
    165  6871							;------------------------------------------------------------------------------
      0  6871					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  6871		       00 0d	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  6871					      SUBROUTINE
      3  6871				   SetPlatformColours
    167  6871
    168  6871							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    169  6871							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    170  6871							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    171  6871							; addressing will not violate the page-crossing restriction of 3E.
    172  6871
    173  6871							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    174  6871
    175  6871		       a9 00		      lda	#<DrawTheScreen	; = 0
    176  6873		       85 c2		      sta	Board_AddressW
    177  6875		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    178  6877		       85 c3		      sta	Board_AddressW+1
    179  6879
    180  6879							; first, set the x index (with last one being a RTS ($60))
    181  6879
    182  6879		       a6 c5		      ldx	RAM_Bank
    183  687b		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    184  687d		       d0 07		      bne	.skipPatch
    185  687f		       a9 60		      lda	#$60	; rts
    186  6881		       a0 41		      ldy	#<SELFMOD_X
    187  6883		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    188  6886				   .skipPatch
    189  6886
    190  6886		       a2 02		      ldx	#3-1
    191  6888				   .loopColor
    192  6888		       86 db		      stx	colorIdx
    193  688a							; set PF colors
    194  688a		       b5 bd		      lda	color,x
    195  688c		       bc a9 f0 	      ldy	SelfModColOfsTbl,x
    196  688f							;tax
    197  688f		       a6 c5		      ldx	RAM_Bank
    198  6891		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy PF colour RED/GREEN/BLUE to self-modifying RAM
    199  6894							; set player colors
    200  6894		       a6 db		      ldx	colorIdx
    201  6896		       bd ac f0 	      lda	SelfModePlayerTbl,x
    202  6899		       a4 80		      ldy	Platform
    203  689b		       c0 02		      cpy	#PAL
    204  689d		       90 02		      bcc	.platform0
    205  689f		       69 17		      adc	#LINES_PER_CHAR-1	; C==1!
    206  68a1				   .platform0
    207  68a1							;ldy SelfModPlayerColOfsTbl,x
    208  68a1							;tax
    209  68a1							;ldx RAM_Bank
    210  68a1							;jsr PutBoardCharacter 	  ;6+21(A)	  copy player colour RED/GREEN/BLUE to self-modifying RAM
    211  68a1							; loop
    212  68a1		       a6 db		      ldx	colorIdx
    213  68a3		       ca		      dex
    214  68a4		       10 e2		      bpl	.loopColor
    215  68a6
    216  68a6		       a4 c5		      ldy	RAM_Bank
    217  68a8		       60		      rts
    218  68a9
    219  68a9				   SelfModColOfsTbl
    220  68a9		       53 86 1c 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    221  68ac				   SelfModePlayerTbl
    222  68ac		       bf b7 af 	      .byte.b	<SpriteColourBLUE, <SpriteColourGREEN, <SpriteColourRED
    223  68af							;SelfModPlayerColOfsTbl:
    224  68af							;    .byte   <(SELFMOD_PLAYERCOL_BLUE+1), <(SELFMOD_PLAYERCOL_GREEN+1), <(SELFMOD_PLAYERCOL_RED+1)
    225  68af
    226  68af
    227  68af				   DrawLineStartLO
    228  68af
    229  68af							; Gives the start address of each line in the draw flags buffer
    230  68af
    231  68af				   .DRAW_LOCATION SET	DrawFlag
    232  68af					      REPEAT	SCREEN_LINES
    233  68af		       50		      .byte.b	<.DRAW_LOCATION
    234  68af				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  68af					      REPEND
    233  68b0		       5a		      .byte.b	<.DRAW_LOCATION
    234  68b0				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  68b0					      REPEND
    233  68b1		       64		      .byte.b	<.DRAW_LOCATION
    234  68b1				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  68b1					      REPEND
    233  68b2		       6e		      .byte.b	<.DRAW_LOCATION
    234  68b2				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  68b2					      REPEND
    233  68b3		       78		      .byte.b	<.DRAW_LOCATION
    234  68b3				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  68b3					      REPEND
    233  68b4		       82		      .byte.b	<.DRAW_LOCATION
    234  68b4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  68b4					      REPEND
    233  68b5		       8c		      .byte.b	<.DRAW_LOCATION
    234  68b5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  68b5					      REPEND
    233  68b6		       96		      .byte.b	<.DRAW_LOCATION
    234  68b6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    235  68b7					      REPEND
    236  68b7
    237  68b7
    238  68b7							;------------------------------------------------------------------------------
    239  68b7
      0  68b7					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  68b7		       00 0d	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  68b7					      SUBROUTINE
      3  68b7				   GetBoardAddressRW
    241  68b7							; Must share same bank as BoardLineStart tables
    242  68b7
    243  68b7		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    244  68ba		       85 c0		      sta	Board_AddressR	; 3
    245  68bc		       85 c2		      sta	Board_AddressW	; 3
    246  68be		       b9 15 f0 	      lda	BoardLineStartHiR,y	; 4
    247  68c1		       85 c1		      sta	Board_AddressR+1	; 3	     READ address
    248  68c3		       09 04		      ora	#>RAM_WRITE	; 2
    249  68c5		       85 c3		      sta	Board_AddressW+1	; 3	     WRITE address
    250  68c7							;    IF MULTI_BANK_BOARD = YES
    251  68c7							;		  ldx BoardBank,y		  ; 4 = 26    switch this on return
    252  68c7							;    ELSE
    253  68c7		       a2 0d		      ldx	#BANK_BOARD	; 2
    254  68c9							;    ENDIF
    255  68c9		       60		      rts		; 6 = 32[-2]
    256  68ca
    257  68ca							;------------------------------------------------------------------------------
    258  68ca
      0  68ca					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  68ca		       00 0d	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  68ca					      SUBROUTINE
      3  68ca				   GetBoardAddressR
    260  68ca
    261  68ca		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    262  68cd		       85 c0		      sta	Board_AddressR	; 3
    263  68cf		       b9 15 f0 	      lda	BoardLineStartHiR,y	; 4
    264  68d2		       85 c1		      sta	Board_AddressR+1	; 3	 READ address
    265  68d4							;    IF MULTI_BANK_BOARD = YES
    266  68d4							;		  lda BoardBank,y		  ; 4	  switch this on return
    267  68d4							;    ELSE
    268  68d4		       a9 0d		      lda	#BANK_BOARD	; 2
    269  68d6							;    ENDIF
    270  68d6		       60		      rts		; 6[-2]
    271  68d7
    272  68d7							;------------------------------------------------------------------------------
    273  68d7
      0  68d7					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  68d7		       00 0d	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  68d7					      SUBROUTINE
      3  68d7				   GetBoardAddressW
    275  68d7
    276  68d7							; Must share same bank as BoardLineStart tables
    277  68d7
    278  68d7		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    279  68da		       85 c2		      sta	Board_AddressW	;3
    280  68dc		       b9 29 f0 	      lda	BoardLineStartHiW,y	;4
    281  68df		       85 c3		      sta	Board_AddressW+1	;3 WRITE address
    282  68e1							;    IF MULTI_BANK_BOARD = YES
    283  68e1							;		  ldx BoardBank,y		  ;4 switch this on return
    284  68e1							;    ELSE
    285  68e1		       a2 0d		      ldx	#BANK_BOARD	;2
    286  68e3							;    ENDIF
    287  68e3		       60	   QRet       rts		;6
    288  68e4
    289  68e4							;-------------------------------------------------------------------------------
    290  68e4
    291  68e4
    292  68e4							;------------------------------------------------------------------------------
    293  68e4
    294  68e4		       e6 a6	   cannotPush inc	ManPushCounter
    295  68e6		       60		      rts
    296  68e7
      0  68e7					      DEFINE_SUBROUTINE	PushBox	; in INITBANK
      1  68e7		       00 0d	   BANK_PushBox =	_CURRENT_BANK
      2  68e7					      SUBROUTINE
      3  68e7				   PushBox
    298  68e7
    299  68e7							; X = restoration character for square we are moving TO
    300  68e7							; so, if X = CHARACTER_TARGET AND we move, THEN we are pushing a box off a target
    301  68e7							; A = this bank!
    302  68e7
    303  68e7		       85 c4		      sta	ROM_Bank
    304  68e9
    305  68e9		       a5 a8		      lda	ManAnimationID
    306  68eb		       c9 06		      cmp	#ANIMATION_PUSH_ID
    307  68ed		       f0 14		      beq	alreadyAnimPush
    308  68ef		       c9 08		      cmp	#ANIMATION_PUSHTRY_ID
    309  68f1		       f0 10		      beq	alreadyAnimPush
    310  68f3
      0  68f3					      LOAD_ANIMATION	Animation_PUSHTRY
      1  68f3		       a9 8a		      lda	#<Animation_PUSHTRY
      2  68f5		       85 9c		      sta	animation
      3  68f7		       a9 f0		      lda	#>Animation_PUSHTRY
      4  68f9		       85 9d		      sta	animation+1
      5  68fb		       a9 00		      lda	#0
      6  68fd		       85 9e		      sta	animation_delay
    312  68ff
    313  68ff		       a9 08		      lda	#ANIMATION_PUSHTRY_ID
    314  6901		       85 a8		      sta	ManAnimationID
    315  6903
    316  6903				   alreadyAnimPush
    317  6903
    318  6903		       a5 a6		      lda	ManPushCounter
    319  6905		       c9 02		      cmp	#PUSH_LIMIT
    320  6907		       90 db		      bcc	cannotPush
    321  6909
    322  6909		       a9 06		      lda	#ANIMATION_PUSH_ID
    323  690b		       c5 a8		      cmp	ManAnimationID
    324  690d		       f0 0e		      beq	alreadyPushing
    325  690f		       85 a8		      sta	ManAnimationID
    326  6911
      0  6911					      LOAD_ANIMATION	Animation_PUSH
      1  6911		       a9 90		      lda	#<Animation_PUSH
      2  6913		       85 9c		      sta	animation
      3  6915		       a9 f0		      lda	#>Animation_PUSH
      4  6917		       85 9d		      sta	animation+1
      5  6919		       a9 00		      lda	#0
      6  691b		       85 9e		      sta	animation_delay
    328  691d
    329  691d				   alreadyPushing
    330  691d
    331  691d		       86 dd		      stx	restorationCharacter	; players new location's restore
    332  691f
    333  691f							; Determine if the box is pushable
    334  691f							; we use the joystick to calculate the subsequent square
    335  691f
    336  691f		       a5 92		      lda	BufferedJoystick
    337  6921		       4a		      lsr
    338  6922		       4a		      lsr
    339  6923		       4a		      lsr
    340  6924		       4a		      lsr
    341  6925		       48		      pha
    342  6926		       a8		      tay
    343  6927
    344  6927		       18		      clc
    345  6928		       a5 8a		      lda	POS_Y_NEW
    346  692a		       79 cc f2 	      adc	JoyMoveY,y
    347  692d		       85 88		      sta	POS_Y	; the box's pushed-to square
    348  692f		       a8		      tay
    349  6930		       20 b7 f0 	      jsr	GetBoardAddressRW
    350  6933
    351  6933		       68		      pla
    352  6934		       a8		      tay
    353  6935
    354  6935		       18		      clc
    355  6936		       a5 89		      lda	POS_X_NEW
    356  6938		       79 c0 f2 	      adc	JoyMoveX,y
    357  693b		       85 87		      sta	POS_X	; the box's pushed-to square
    358  693d		       48		      pha
    359  693e		       a8		      tay
    360  693f
    361  693f							;    IF MULTI_BANK_BOARD = YES
    362  693f							;		  lda RAM_Bank
    363  693f							;    ELSE
    364  693f		       a9 0d		      lda	#BANK_BOARD	; 2
    365  6941							;    ENDIF
    366  6941		       20 14 f8 	      jsr	GetBoardCharacter	;6+20(A)
    367  6944		       68		      pla
    368  6945		       a8		      tay
    369  6946
    370  6946		       a9 02		      lda	#CHARACTER_BOX
    371  6948		       e0 00		      cpx	#CHARACTER_BLANK
    372  694a		       f0 0d		      beq	canPushTarget
    373  694c
    374  694c		       e0 03		      cpx	#CHARACTER_TARGET
    375  694e		       f0 04		      beq	decreaseTargets
    376  6950		       e0 04		      cpx	#CHARACTER_TARGET2
    377  6952		       d0 90		      bne	cannotPush
    378  6954
    379  6954							; Box is now on a target - so decrease the remaining targets
    380  6954
    381  6954		       20 cd fc    decreaseTargets jsr	DeRegisterTarget
    382  6957		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    383  6959		       48	   canPushTarget pha
    384  695a
    385  695a							; If the box *WAS* on a target (restoration character = CHARACTER_TARGET)
    386  695a							; then we increase targets (as there is one more to get)
    387  695a
    388  695a		       a5 dd		      lda	restorationCharacter
    389  695c		       c9 03		      cmp	#CHARACTER_TARGET
    390  695e		       d0 03		      bne	notOnTargetAlready
    391  6960
    392  6960							; increase the required targets as box is leaving one
    393  6960
    394  6960		       20 c3 fc 	      jsr	RegisterTarget
    395  6963
    396  6963				   notOnTargetAlready
    397  6963
    398  6963							; record the box takeback params for the player move to use
    399  6963
    400  6963		       86 91		      stx	TB_CHAR
    401  6965		       a5 87		      lda	POS_X
    402  6967		       85 8f		      sta	TB_PUSHX
    403  6969		       a5 88		      lda	POS_Y
    404  696b		       85 90		      sta	TB_PUSHY
    405  696d
    406  696d		       68		      pla		; new char to go on board in box's new position
    407  696e
    408  696e
    409  696e							;  IF MULTI_BANK_BOARD = YES
    410  696e							;		ldx RAM_Bank			  ; <-- this will never work calling from INITBANK!!!
    411  696e							;  ELSE
    412  696e		       a2 0d		      ldx	#BANK_BOARD	; 2
    413  6970							;  ENDIF
    414  6970		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)
    415  6973
    416  6973		       a5 8c		      lda	POS_VAR	; player's restoration character
    417  6975		       48		      pha
    418  6976
    419  6976							; Before the player moves to the new position, take away the box and replace with the
    420  6976							; character the box was sitting on (BLANK or TARGET). Then the player moves in "next"
    421  6976
    422  6976		       a5 8a		      lda	POS_Y_NEW
    423  6978		       85 88		      sta	POS_Y
    424  697a		       a5 89		      lda	POS_X_NEW
    425  697c		       85 87		      sta	POS_X
    426  697e		       a5 dd		      lda	restorationCharacter
    427  6980		       85 8c		      sta	POS_VAR
    428  6982		       20 e9 f8 	      jsr	PutCharacterAtXY	; put back BOX's restoration character
    429  6985
    430  6985		       68		      pla
    431  6986		       85 8c		      sta	POS_VAR
    432  6988
    433  6988							;START_SOUND SOUND_BOX
    434  6988
    435  6988							; Note: MovePlayer expects new position to be POS_X_NEW, POS_Y_NEW
    436  6988							; AND the current man's square to be ManX, ManY
    437  6988
    438  6988		       4c 3d f9 	      jmp	MovePlayer	; now there's a gap, player should move in
    439  698b
    440  698b
    441  698b							;------------------------------------------------------------------------------
    442  698b
    443  698b							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    444  698b							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    445  698b
    446  698b							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    447  698b
    448  698b							; if the creature dies then jump NextObject
    449  698b
    450  698b
    451  698b
    452  698b		       ff	   RDirY      .byte.b	-1	;,0,1,0
    453  698c		       00 01	   RDirX      .byte.b	0,1	;,0,-1
    454  698e		       00 ff 01 00 DirPushModX .byte.b	0,-1,1,0
    455  6992		       ff 00 00 01 DirPushModY .byte.b	-1,0,0,1
    456  6996		       01 02 03 00*Directional .byte.b	1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    457  69a4
    458  69a4
    459  69a4							;------------------------------------------------------------------------------
    460  69a4
    461  69a4							; the auto-calculation of these was causing DASM to get confused and abort assembling.
    462  69a4							; I don't particularly know why; probably because of the level variable-size array and the values
    463  69a4							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    464  69a4
    465  69a4		       00 00	   MANMODE_STARTUP =	0
    466  69a4		       00 01	   MANMODE_NORMAL =	1
    467  69a4		       00 02	   MANMODE_DEAD =	2
    468  69a4		       00 03	   MANMODE_WAITING =	3
    469  69a4		       00 04	   MANMODE_WAITING2 =	4
    470  69a4		       00 05	   MANMODE_WAITING_NT =	5
    471  69a4		       00 06	   MANMODE_WAITING_NT2 =	6
    472  69a4		       00 07	   MANMODE_NEXTLEVEL =	7
    473  69a4		       00 08	   MANMODE_NEXTLEVEL2 =	8
    474  69a4		       00 09	   MANMODE_SWITCH =	9
    475  69a4		       00 0a	   MANMODE_TURNAROUND =	10
    476  69a4		       00 0b	   MANMODE_TURNAROUND2 =	11
    477  69a4
    478  69a4
      0  69a4					      DEFINE_SUBROUTINE	ManProcess
      1  69a4		       00 0d	   BANK_ManProcess =	_CURRENT_BANK
      2  69a4					      SUBROUTINE
      3  69a4				   ManProcess
    480  69a4
    481  69a4							; ManMode tells the player what it is currently doing.  State machine.
    482  69a4
    483  69a4							; Check the switches....
    484  69a4							; RESET to restart this level
    485  69a4							; SELECT to start next level
    486  69a4
    487  69a4		       ad 82 02 	      lda	SWCHB
    488  69a7		       29 03		      and	#3
    489  69a9		       aa		      tax
    490  69aa		       bd c3 f1 	      lda	newMode,x
    491  69ad		       30 02		      bmi	skipModeChange
    492  69af		       85 a3		      sta	ManMode
    493  69b1				   skipModeChange
    494  69b1
    495  69b1		       20 00 f8 	      jsr	DrawTimeFromROM	; Z-flag == 0!
    496  69b4
    497  69b4		       a4 a3		      ldy	ManMode
    498  69b6		       b9 c7 f1 	      lda	ManActionLO,y
    499  69b9		       85 db		      sta	actionVector
    500  69bb		       b9 d3 f1 	      lda	ManActionHI,y
    501  69be		       85 dc		      sta	actionVector+1
    502  69c0		       6c db 00 	      jmp	(actionVector)
    503  69c3
    504  69c3		       ff 09 04 ff newMode    .byte.b	-1, MANMODE_SWITCH, MANMODE_WAITING2, -1
    505  69c7
    506  69c7				   ManActionLO
    507  69c7		       ff		      .byte.b	<manStartup	; 0		 no timer
    508  69c8		       1b		      .byte.b	<normalMan	; 1		 timer
    509  69c9		       00		      .byte.b	<0	; 2		 timer
    510  69ca		       14		      .byte.b	<waitingMan	; 3		 timer
    511  69cb		       14		      .byte.b	<waitingManPress	; 4		 timer
    512  69cc		       14		      .byte.b	<waitingMan	; 5		 no timer
    513  69cd		       14		      .byte.b	<waitingManPress	; 6		 no timer
    514  69ce		       98		      .byte.b	<nextLevelMan	; 7		 no timer
    515  69cf		       9f		      .byte.b	<nextLevelMan2	; 8		 no timer
    516  69d0		       a7		      .byte.b	<switchLevels	; 9		 no timer
    517  69d1		       df		      .byte.b	<TurnAround	; 10
    518  69d2		       f4		      .byte.b	<TurnAround2	; 10
    519  69d3
    520  69d3				   ManActionHI
    521  69d3		       f1		      .byte.b	>manStartup	; no timer
    522  69d4		       f2		      .byte.b	>normalMan	; timer
    523  69d5		       00		      .byte.b	>0	; timer
    524  69d6		       f2		      .byte.b	>waitingMan	; timer
    525  69d7		       f2		      .byte.b	>waitingManPress	; timer
    526  69d8		       f2		      .byte.b	>waitingMan	; no timer
    527  69d9		       f2		      .byte.b	>waitingManPress	; no timer
    528  69da		       fc		      .byte.b	>nextLevelMan	; no timer
    529  69db		       fc		      .byte.b	>nextLevelMan2	; no timer
    530  69dc		       fc		      .byte.b	>switchLevels	;9  no timer
    531  69dd		       f1		      .byte.b	>TurnAround	; 10
    532  69de		       f1		      .byte.b	>TurnAround2	; 10
    533  69df
    534  69df
      0  69df					      DEFINE_SUBROUTINE	TurnAround
      1  69df		       00 0d	   BANK_TurnAround =	_CURRENT_BANK
      2  69df					      SUBROUTINE
      3  69df				   TurnAround
    536  69df
    537  69df
      0  69df					      LOAD_ANIMATION	Animation_TURNAROUND
      1  69df		       a9 5c		      lda	#<Animation_TURNAROUND
      2  69e1		       85 9c		      sta	animation
      3  69e3		       a9 f0		      lda	#>Animation_TURNAROUND
      4  69e5		       85 9d		      sta	animation+1
      5  69e7		       a9 00		      lda	#0
      6  69e9		       85 9e		      sta	animation_delay
    539  69eb
    540  69eb		       a5 a4		      lda	ManLastDirection
    541  69ed		       85 a5		      sta	ManTurnStart
    542  69ef
    543  69ef		       a9 0b		      lda	#MANMODE_TURNAROUND2
    544  69f1		       85 a3		      sta	ManMode
    545  69f3		       60		      rts
    546  69f4
      0  69f4					      DEFINE_SUBROUTINE	TurnAround2
      1  69f4		       00 0d	   BANK_TurnAround2 =	_CURRENT_BANK
      2  69f4					      SUBROUTINE
      3  69f4				   TurnAround2
    548  69f4
    549  69f4		       a5 a5		      lda	ManTurnStart
    550  69f6		       c5 a4		      cmp	ManLastDirection
    551  69f8		       f0 04		      beq	notTurnedYet
    552  69fa
    553  69fa		       a9 01		      lda	#MANMODE_NORMAL
    554  69fc		       85 a3		      sta	ManMode
    555  69fe
    556  69fe
    557  69fe		       60	   notTurnedYet rts
    558  69ff
    559  69ff
    560  69ff							;------------------------------------------------------------------------------
      0  69ff					      DEFINE_SUBROUTINE	manStartup
      1  69ff		       00 0d	   BANK_manStartup =	_CURRENT_BANK
      2  69ff					      SUBROUTINE
      3  69ff				   manStartup
    562  69ff
    563  69ff					      IF	WAIT_FOR_INITIAL_DRAW
    564  69ff							; Delay turning on the visible screen until the background has completed drawing.
    565  69ff							; This is simple - is there anything still in the draw stack?
    566  69ff		       a5 81		      lda	DrawStackPointer
    567  6a01		       10 04		      bpl	midDraw
    568  6a03		       a9 00		      lda	#0
    569  6a05		       85 ae		      sta	blankState
    570  6a07				   midDraw
    571  6a07					      ENDIF
    572  6a07
    573  6a07		       a5 9f		      lda	ManX
    574  6a09		       85 89		      sta	POS_X_NEW
    575  6a0b		       a5 a0		      lda	ManY
    576  6a0d		       85 8a		      sta	POS_Y_NEW
    577  6a0f
    578  6a0f		       a9 01		      lda	#MANMODE_NORMAL
    579  6a11		       85 a3		      sta	ManMode
    580  6a13
    581  6a13				   RTS_CF
    582  6a13		       60		      rts
    583  6a14
    584  6a14							;------------------------------------------------------------------------------
    585  6a14
    586  6a14				   waitingMan
    587  6a14				   waitingManPress
    588  6a14
    589  6a14							;		  lda #50
    590  6a14							;		  sta ColourTimer
    591  6a14
    592  6a14
    593  6a14		       a5 cb		      lda	NextLevelTrigger
    594  6a16		       09 40		      ora	#BIT_NEXTLIFE
    595  6a18		       85 cb		      sta	NextLevelTrigger
    596  6a1a		       60		      rts
    597  6a1b
    598  6a1b
    599  6a1b							;------------------------------------------------------------------------------
    600  6a1b							; Normal man state
    601  6a1b
      0  6a1b					      DEFINE_SUBROUTINE	normalMan
      1  6a1b		       00 0d	   BANK_normalMan =	_CURRENT_BANK
      2  6a1b					      SUBROUTINE
      3  6a1b				   normalMan
    603  6a1b
    604  6a1b							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    605  6a1b							; before exiting via (for example) look-around option :)
    606  6a1b
    607  6a1b		       a5 9f		      lda	ManX
    608  6a1d		       85 89		      sta	POS_X_NEW
    609  6a1f		       a5 a0		      lda	ManY
    610  6a21		       85 8a		      sta	POS_Y_NEW
    611  6a23
    612  6a23							;------------------------------------------------------------------------------
    613  6a23							; Look around is triggered by holding down the fire button for a while, without any other
    614  6a23							; joystick directions chosen. The variable LookingAround has a negative value ($FF) when looking
    615  6a23							; is active. Otherwise, it is counting down to the time where it will trigger.
    616  6a23
    617  6a23		       00 00	   LOOK_DELAY =	0
    618  6a23
    619  6a23							;------------------------------------------------------------------------------
    620  6a23							; Take-back is a press/release of the button, with the press being limited in duratino
    621  6a23							; to allow the action to be "cancelled". Meanwhile, a button press + direction triggers
    622  6a23							; "look-around mode"
    623  6a23
    624  6a23		       a5 94		      lda	BufferedButton
    625  6a25		       30 36		      bmi	noLook	; button?
    626  6a27
    627  6a27							; button pressed, so in looking-around mode
    628  6a27
    629  6a27		       a2 ff		      ldx	#$FF
    630  6a29		       86 94		      stx	BufferedButton	; "release" button
    631  6a2b
    632  6a2b		       a5 a7		      lda	LookingAround
    633  6a2d		       30 02		      bmi	LookAround
    634  6a2f		       86 a7		      stx	LookingAround
    635  6a31				   LookAround
    636  6a31
    637  6a31							; Use the joystick as a window-scroller to change the viewport
    638  6a31
    639  6a31		       a5 92		      lda	BufferedJoystick
    640  6a33		       4a		      lsr
    641  6a34		       4a		      lsr
    642  6a35		       4a		      lsr
    643  6a36		       4a		      lsr
    644  6a37		       a8		      tay
    645  6a38
    646  6a38		       b9 c0 f2 	      lda	JoyMoveX,y
    647  6a3b		       19 cc f2 	      ora	JoyMoveY,y
    648  6a3e		       f0 1c		      beq	AbandonY
    649  6a40
    650  6a40		       a9 fe		      lda	#$FE
    651  6a42		       85 a7		      sta	LookingAround
    652  6a44
    653  6a44		       b9 c0 f2 	      lda	JoyMoveX,y
    654  6a47							;asl
    655  6a47		       18		      clc
    656  6a48		       65 99		      adc	BoardScrollX
    657  6a4a		       c5 96		      cmp	BoardEdge_Right
    658  6a4c		       b0 02		      bcs	AbandonX
    659  6a4e		       85 99		      sta	BoardScrollX
    660  6a50
    661  6a50		       b9 cc f2    AbandonX   lda	JoyMoveY,y
    662  6a53							;asl
    663  6a53		       18		      clc
    664  6a54		       65 98		      adc	BoardScrollY
    665  6a56		       c5 97		      cmp	BoardEdge_Bottom
    666  6a58		       b0 02		      bcs	AbandonY
    667  6a5a		       85 98		      sta	BoardScrollY
    668  6a5c
    669  6a5c		       60	   AbandonY   rts
    670  6a5d
    671  6a5d		       a2 00	   noLook     ldx	#0
    672  6a5f		       a5 a7		      lda	LookingAround
    673  6a61		       c9 ff		      cmp	#$FF
    674  6a63		       86 a7		      stx	LookingAround
    675  6a65		       d0 03		      bne	bProcComp	; $FE means there was a lookaround, so skip
    676  6a67
    677  6a67							; button was presssed and now released and we didn't actually look around
    678  6a67							; so we do a take-back
    679  6a67
    680  6a67		       4c f9 f9 	      jmp	takebackRestoreEarlierPosition	;.. and rts
    681  6a6a							;rts
    682  6a6a
    683  6a6a				   bProcComp
    684  6a6a							;------------------------------------------------------------------------------
    685  6a6a
    686  6a6a							; control the scrolling via the joystick
    687  6a6a
    688  6a6a		       a5 a4		      lda	ManLastDirection
    689  6a6c		       29 07		      and	#DIRECTION_BITS
    690  6a6e		       a8		      tay
    691  6a6f
    692  6a6f		       a5 92		      lda	BufferedJoystick	; joystick
    693  6a71		       25 93		      and	BufferedJoystick+1
    694  6a73
    695  6a73		       a2 00		      ldx	#0
    696  6a75		       0a	   .loopDirs  asl
    697  6a76		       90 1a		      bcc	.dirFound
    698  6a78		       88		      dey
    699  6a79		       e8		      inx
    700  6a7a		       e0 04		      cpx	#4
    701  6a7c		       d0 f7		      bne	.loopDirs
    702  6a7e
    703  6a7e							; no direction!
    704  6a7e
    705  6a7e		       a9 02		      lda	#ANIMATION_IDLE_ID
    706  6a80		       c5 a8		      cmp	ManAnimationID
    707  6a82		       f0 0e		      beq	alreadyIdling
    708  6a84		       85 a8		      sta	ManAnimationID
      0  6a86					      LOAD_ANIMATION	Animation_IDLE
      1  6a86		       a9 36		      lda	#<Animation_IDLE
      2  6a88		       85 9c		      sta	animation
      3  6a8a		       a9 f0		      lda	#>Animation_IDLE
      4  6a8c		       85 9d		      sta	animation+1
      5  6a8e		       a9 00		      lda	#0
      6  6a90		       85 9e		      sta	animation_delay
    710  6a92				   alreadyIdling
    711  6a92
    712  6a92
    713  6a92
    714  6a92
    715  6a92				   .dirFound
    716  6a92
    717  6a92		       bd de f2 	      lda	anim_direction,x
    718  6a95		       30 0c		      bmi	dontChange
    719  6a97		       45 a4		      eor	ManLastDirection
    720  6a99		       29 08		      and	#%1000
    721  6a9b		       f0 06		      beq	dontChange
    722  6a9d
    723  6a9d							;LOAD_ANIMATION Animation_TURNAROUND
    724  6a9d		       bd de f2 	      lda	anim_direction,x
    725  6aa0		       85 a4		      sta	ManLastDirection
    726  6aa2
    727  6aa2							; at this point we want to activate the stand/turn animation before continuing
    728  6aa2
    729  6aa2							;lda #MANMODE_TURNAROUND
    730  6aa2							;sta ManMode
    731  6aa2		       60		      rts
    732  6aa3
    733  6aa3
    734  6aa3
    735  6aa3
    736  6aa3							;bne noMovement ;kipMove
    737  6aa3				   dontChange
    738  6aa3
    739  6aa3		       18		      clc
    740  6aa4		       a5 89		      lda	POS_X_NEW
    741  6aa6		       7d d9 f2 	      adc	JoyDirX,x
    742  6aa9		       85 89		      sta	POS_X_NEW
    743  6aab
    744  6aab		       18		      clc
    745  6aac		       a5 8a		      lda	POS_Y_NEW
    746  6aae		       7d d7 f2 	      adc	JoyDirY,x
    747  6ab1		       85 8a		      sta	POS_Y_NEW
    748  6ab3
    749  6ab3		       98	   skipMove   tya
    750  6ab4		       f0 09		      beq	noMovement	; animation OK
    751  6ab6
    752  6ab6		       8a		      txa
    753  6ab7		       45 a4		      eor	ManLastDirection
    754  6ab9		       29 07		      and	#DIRECTION_BITS
    755  6abb		       45 a4		      eor	ManLastDirection
    756  6abd		       85 a4		      sta	ManLastDirection
    757  6abf
    758  6abf				   noMovement
    759  6abf		       60	   DFS_rts    rts
    760  6ac0
    761  6ac0
    762  6ac0
    763  6ac0		       00 00 00 00*JoyMoveX   .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1	;,0, 0,0,0
    764  6acc		       00 00 00 00*JoyMoveY   .byte.b	0,0,0,0,0,1,-1,0,0, 1,-1	;, 0,0,1,-1,0
    765  6ad7
    766  6ad7				   JoyDirY
    767  6ad7		       00 00		      .byte.b	0,0	;,1,-1,0
    768  6ad9				   JoyDirX
    769  6ad9		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
    770  6ade
    771  6ade							;Data Bit  Direction Player
    772  6ade							;		 D7	   right	  P0  D4
    773  6ade							;		 D6	   left      P0  D3
    774  6ade							;		 D5	   down      P0  D2
    775  6ade							;		 D4	   up	     P0  D1
    776  6ade							;     A "0" in a data bit indicates the joystick has been moved
    777  6ade							;     to close that switch.  All "1's" in a player's nibble
    778  6ade							;     indicates that joystick is not moving.
    779  6ade
    780  6ade							;0  0000 x
    781  6ade							;1  0001 x
    782  6ade							;2  0010 x
    783  6ade							;3  0011 x
    784  6ade							;4  0100 x
    785  6ade							;5  0101 right down
    786  6ade							;6  0110 right up
    787  6ade							;7  0111 right
    788  6ade							;8  1000 x
    789  6ade							;9  1001 left down
    790  6ade							;10  1010 left up
    791  6ade							;11  1011 left
    792  6ade							;12  1100 x
    793  6ade							;13  1101 down
    794  6ade							;14  1110 up
    795  6ade							;15  1111 none
    796  6ade
    797  6ade		       00 08 80 80*anim_direction .byte.b	0,%1000,128,128,128
    798  6ae3
    799  6ae3							;------------------------------------------------------------------------------
    800  6ae3
    801  6ae3
      0  6ae3					      DEFINE_SUBROUTINE	DrawFullScreen	; @31✅
      1  6ae3		       00 0d	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  6ae3					      SUBROUTINE
      3  6ae3				   DrawFullScreen
    803  6ae3
    804  6ae3		       ad 84 02 	      lda	INTIM	; 4
    805  6ae6		       c9 27		      cmp	#SEGTIME_BDF	; 2
    806  6ae8		       90 d5		      bcc	DFS_rts	; 2/3 ==> [31]+(9)+6rts = 46✅ on abort
    807  6aea
    808  6aea		       a9 f4		      lda	#>( DrawFlag + RAM_WRITE )	; 2
    809  6aec		       85 dc		      sta	BDF_DrawFlagAddress+1	; 3
    810  6aee		       85 de		      sta	BDF_DrawFlagAddress2+1	; 3
    811  6af0
    812  6af0		       ba		      tsx		; 2
    813  6af1		       86 e5		      stx	DHS_Stack	; 3
    814  6af3
    815  6af3		       e6 86		      inc	ScreenDrawPhase	; 5
    816  6af5
    817  6af5		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
    818  6af6		       a2 08		      ldx	#SCREEN_LINES	; 2
    819  6af8		       8a		      txa		; 2 = *32
    820  6af9
    821  6af9							; fall through
    822  6af9
    823  6af9							;------------------------------------------------------------------------------
    824  6af9
      0  6af9					      DEFINE_SUBROUTINE	DrawScreenRowPreparation	; = *59[-7 if not multi-bank-board]
      1  6af9		       00 0d	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  6af9					      SUBROUTINE
      3  6af9				   DrawScreenRowPreparation
    826  6af9
    827  6af9							;clc
    828  6af9		       ca		      dex		; 2
    829  6afa		       86 e4		      stx	DHS_Line	; 3
    830  6afc		       65 98		      adc	BoardScrollY	; 3	     the Y offset of screen into board
    831  6afe		       a8		      tay		; 2 = 10
    832  6aff
    833  6aff							;clc
    834  6aff		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
    835  6b02		       65 99		      adc	BoardScrollX	; 3	     the X offset of screen into board
    836  6b04		       85 df		      sta	BDF_BoardAddress	; 3
    837  6b06		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    838  6b08		       85 e1		      sta	BDF_BoardAddress2	; 3
    839  6b0a
    840  6b0a		       b9 14 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
    841  6b0d		       85 e0		      sta	BDF_BoardAddress+1	; 3
    842  6b0f		       85 e2		      sta	BDF_BoardAddress2+1	; 3 = 25
    843  6b11
    844  6b11		       bd af f0 	      lda	DrawLineStartLO,x	; 4
    845  6b14		       85 db		      sta	BDF_DrawFlagAddress	; 3
    846  6b16		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    847  6b18		       85 dd		      sta	BDF_DrawFlagAddress2	; 3 = 12
    848  6b1a
    849  6b1a							;    IF MULTI_BANK_BOARD = YES
    850  6b1a							;		  lda BoardBank-1,y		  ; 4
    851  6b1a							;		  sta BDF_BoardBank		  ; 3
    852  6b1a							;    ENDIF
    853  6b1a		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
    854  6b1c		       4c 65 fb 	      jmp	CopyRow2	; 3 = 12[-7]
    855  6b1f
    856  6b1f							;------------------------------------------------------------------------------
    857  6b1f
      0  6b1f					      DEFINE_SUBROUTINE	EndOfLevel
      1  6b1f		       00 0d	   BANK_EndOfLevel =	_CURRENT_BANK
      2  6b1f					      SUBROUTINE
      3  6b1f				   EndOfLevel
    859  6b1f
    860  6b1f		       a9 14		      lda	#20
    861  6b21		       85 a9		      sta	DelayEndOfLevel
    862  6b23		       a5 80		      lda	Platform
    863  6b25		       85 c7		      sta	ColourFlash	; green
    864  6b27		       a9 06		      lda	#6
    865  6b29		       85 c6		      sta	ColourTimer
    866  6b2b
      0  6b2b					      LOAD_ANIMATION	Animation_WIN
      1  6b2b		       a9 20		      lda	#<Animation_WIN
      2  6b2d		       85 9c		      sta	animation
      3  6b2f		       a9 f0		      lda	#>Animation_WIN
      4  6b31		       85 9d		      sta	animation+1
      5  6b33		       a9 00		      lda	#0
      6  6b35		       85 9e		      sta	animation_delay
    868  6b37
    869  6b37		       a9 08		      lda	#MANMODE_NEXTLEVEL2
    870  6b39		       85 a3		      sta	ManMode
    871  6b3b		       60		      rts
    872  6b3c
    873  6b3c
      0  6b3c					      DEFINE_SUBROUTINE	IMC
      1  6b3c		       00 0d	   BANK_IMC   =	_CURRENT_BANK
      2  6b3c					      SUBROUTINE
      3  6b3c				   IMC
    875  6b3c
    876  6b3c		       18		      clc
    877  6b3d		       a5 ba		      lda	takebackIndex
    878  6b3f		       69 01		      adc	#1
    879  6b41		       29 3f		      and	#TAKEBACK_MASK
    880  6b43		       85 ba		      sta	takebackIndex
    881  6b45		       c5 bb		      cmp	takebackBaseIndex
    882  6b47		       d0 06		      bne	baseOK
    883  6b49		       69 00		      adc	#0
    884  6b4b		       29 3f		      and	#TAKEBACK_MASK
    885  6b4d		       85 bb		      sta	takebackBaseIndex
    886  6b4f				   baseOK
    887  6b4f
    888  6b4f		       f8		      sed
    889  6b50		       18		      clc
    890  6b51		       a5 b8		      lda	BCD_moveCounter
    891  6b53		       69 01		      adc	#1
    892  6b55		       85 b8		      sta	BCD_moveCounter
    893  6b57		       a5 b9		      lda	BCD_moveCounter+1
    894  6b59		       69 00		      adc	#0
    895  6b5b		       85 b9		      sta	BCD_moveCounter+1
    896  6b5d		       d8		      cld
    897  6b5e
    898  6b5e		       60		      rts
    899  6b5f
    900  6b5f							;------------------------------------------------------------------------------
    901  6b5f
      0  6b5f					      DEFINE_SUBROUTINE	VectorProcess	;=19 + 13, = 31✅ minimum
      1  6b5f		       00 0d	   BANK_VectorProcess =	_CURRENT_BANK
      2  6b5f					      SUBROUTINE
      3  6b5f				   VectorProcess
    903  6b5f
    904  6b5f		       bd 6d f3 	      lda	OSPointerHI,x	; 4
    905  6b62		       85 dc		      sta	POS_Vector+1	; 3
    906  6b64		       bd 6c f3 	      lda	OSPointerLO,x	; 4
    907  6b67		       85 db		      sta	POS_Vector	; 3
    908  6b69
    909  6b69		       6c db 00 	      jmp	(POS_Vector)	; 5 = 19	  vector to processor for particular object type
    910  6b6c
    911  6b6c							; earliest abort from process = +13
    912  6b6c
    913  6b6c							;		 NOTE: Bank is either INITBANK or FIXED.
    914  6b6c							;------------------------------------------------------------------------------
    915  6b6c
    916  6b6c
    917  6b6c				   OBJTYPE    SET	0
    918  6b6c					      MAC	define
    919  6b6c				   TYPE_{1}   =	OBJTYPE
    920  6b6c				   OBJTYPE    .SET	OBJTYPE + 1
    921  6b6c					      ENDM
    922  6b6c
    923  6b6c							; If adding/removing types, the following must also be updated...
    924  6b6c							;   InitialFace[...]		     in UnpackLevel.asm
    925  6b6c							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
    926  6b6c							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
    927  6b6c							;   OSPointerLO[...]		     in BANK_INITBANK.asm
    928  6b6c							;   OSPointerHI[...]		     in BANK_INITBANK.asm
    929  6b6c							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
    930  6b6c							;   Sortable[...]		     in BANK_FIXED.asm
    931  6b6c
    932  6b6c
      0  6b6c					      DEFINE	MAN
      1  6b6c		       00 00	   TYPE_MAN   =	OBJTYPE
      2  6b6c				   OBJTYPE    .SET	OBJTYPE + 1
    934  6b6c							;DEFINE CIRCLE
    935  6b6c							;DEFINE CIRCLE_HELPER
    936  6b6c							;DEFINE CIRCLE_DRAWER
    937  6b6c
      0  6b6c					      DEFINE	MAXIMUM
      1  6b6c		       00 01	   TYPE_MAXIMUM =	OBJTYPE
      2  6b6c				   OBJTYPE    .SET	OBJTYPE + 1
    939  6b6c
    940  6b6c
      0  6b6c					      DEFINE_SUBROUTINE	OSPointerLO
      1  6b6c		       00 0d	   BANK_OSPointerLO =	_CURRENT_BANK
      2  6b6c					      SUBROUTINE
      3  6b6c				   OSPointerLO
    942  6b6c		       b3		      .byte.b	<PROCESS_MAN
    943  6b6d							;.byte <PROCESS_CIRCLE
    944  6b6d							;.byte <PROCESS_CIRCLE_HELPER
    945  6b6d
    946  6b6d				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
    947  6b6d				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
    948  6b6d				  -	      ERR
    949  6b6d					      ENDIF
    950  6b6d
    951  6b6d
      0  6b6d					      DEFINE_SUBROUTINE	OSPointerHI
      1  6b6d		       00 0d	   BANK_OSPointerHI =	_CURRENT_BANK
      2  6b6d					      SUBROUTINE
      3  6b6d				   OSPointerHI
    953  6b6d		       f8		      .byte.b	>PROCESS_MAN
    954  6b6e							;.byte >PROCESS_CIRCLE
    955  6b6e							;.byte >PROCESS_CIRCLE_HELPER
    956  6b6e
    957  6b6e				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
    958  6b6e				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
    959  6b6e				  -	      ERR
    960  6b6e					      ENDIF
    961  6b6e
    962  6b6e							;------------------------------------------------------------------------------
    963  6b6e
      0  6b6e					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  6b6e		       00 0d	   BANK_MoveVecLO =	_CURRENT_BANK
      2  6b6e					      SUBROUTINE
      3  6b6e				   MoveVecLO
    965  6b6e
    966  6b6e		       98		      .byte.b	<MOVE_BLANK
    967  6b6f		       98		      .byte.b	<MOVE_SOIL
    968  6b70		       e7		      .byte.b	<MOVE_BOX
    969  6b71		       98		      .byte.b	<MOVE_TARGET
    970  6b72		       98		      .byte.b	<MOVE_TARGET
    971  6b73		       d6		      .byte.b	<MOVE_GENERIC	;man occupied
    972  6b74		       d6		      .byte.b	<MOVE_GENERIC	;steel
    973  6b75		       d6		      .byte.b	<MOVE_GENERIC	;wall
    974  6b76		       f0		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
    975  6b77		       f0		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
    976  6b78		       d6		      .byte.b	<MOVE_GENERIC	;nogo
    977  6b79		       98		      .byte.b	<MOVE_TARGET	;1
    978  6b7a		       98		      .byte.b	<MOVE_TARGET	;3
    979  6b7b		       98		      .byte.b	<MOVE_TARGET	;5
    980  6b7c		       98		      .byte.b	<MOVE_TARGET	;7
    981  6b7d
    982  6b7d				  -	      if	DIGITS
    983  6b7d				  -	      REPEAT	10	; DIGITS 0-9
    984  6b7d				  -	      .byte	<MOVE_BLANK
    985  6b7d				  -	      REPEND
    986  6b7d					      endif
    987  6b7d
    988  6b7d				  -	      IF	* - MoveVecLO != CHARACTER_MAXIMUM
    989  6b7d				  -	      ECHO	"ERROR: Incorrect number of entries in MoveVecLO table!"
    990  6b7d				  -	      ERR
    991  6b7d					      ENDIF
    992  6b7d
    993  6b7d
      0  6b7d					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  6b7d		       00 0d	   BANK_MoveVecHI =	_CURRENT_BANK
      2  6b7d					      SUBROUTINE
      3  6b7d				   MoveVecHI
    995  6b7d
    996  6b7d		       f9		      .byte.b	>MOVE_BLANK
    997  6b7e		       f9		      .byte.b	>MOVE_SOIL
    998  6b7f		       f9		      .byte.b	>MOVE_BOX
    999  6b80		       f9		      .byte.b	>MOVE_TARGET
   1000  6b81		       f9		      .byte.b	>MOVE_TARGET
   1001  6b82		       f9		      .byte.b	>MOVE_GENERIC	;man occupied
   1002  6b83		       f9		      .byte.b	>MOVE_GENERIC	;steel
   1003  6b84		       f9		      .byte.b	>MOVE_GENERIC	;wall
   1004  6b85		       f9		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
   1005  6b86		       f9		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
   1006  6b87		       f9		      .byte.b	>MOVE_GENERIC	;nogo
   1007  6b88		       f9		      .byte.b	>MOVE_TARGET	;1
   1008  6b89		       f9		      .byte.b	>MOVE_TARGET	;3
   1009  6b8a		       f9		      .byte.b	>MOVE_TARGET	;5
   1010  6b8b		       f9		      .byte.b	>MOVE_TARGET	; 7
   1011  6b8c
   1012  6b8c				  -	      if	DIGITS
   1013  6b8c				  -	      REPEAT	10	; DIGITS 0-9
   1014  6b8c				  -	      .byte	>MOVE_BLANK
   1015  6b8c				  -	      REPEND
   1016  6b8c					      endif
   1017  6b8c
   1018  6b8c				  -	      IF	* - MoveVecHI != CHARACTER_MAXIMUM
   1019  6b8c				  -	      ECHO	"ERROR: Incorrect number of entries in MoveVecHI table!"
   1020  6b8c				  -	      ERR
   1021  6b8c					      ENDIF
   1022  6b8c
   1023  6b8c							;------------------------------------------------------------------------------
   1024  6b8c
      0  6b8c					      DEFINE_SUBROUTINE	SoundFX
      1  6b8c		       00 0d	   BANK_SoundFX =	_CURRENT_BANK
      2  6b8c					      SUBROUTINE
      3  6b8c				   SoundFX
------- FILE sound/intro1_player.asm LEVEL 3 PASS 3
      0  6b8c					      include	"sound/intro1_player.asm"
      1  6b8c							; TIATracker music player
      2  6b8c							; Copyright 2016 Andre "Kylearan" Wichmann
      3  6b8c							; Website: https://bitbucket.org/kylearan/tiatracker
      4  6b8c							; Email: andre.wichmann@gmx.de
      5  6b8c							;
      6  6b8c							; Licensed under the Apache License, Version 2.0 (the "License");
      7  6b8c							; you may not use this file except in compliance with the License.
      8  6b8c							; You may obtain a copy of the License at
      9  6b8c							;
     10  6b8c							;   http://www.apache.org/licenses/LICENSE-2.0
     11  6b8c							;
     12  6b8c							; Unless required by applicable law or agreed to in writing, software
     13  6b8c							; distributed under the License is distributed on an "AS IS" BASIS,
     14  6b8c							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  6b8c							; See the License for the specific language governing permissions and
     16  6b8c							; limitations under the License.
     17  6b8c
     18  6b8c							; Song author:
     19  6b8c							; Song name:
     20  6b8c
     21  6b8c							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  6b8c
     23  6b8c							; =====================================================================
     24  6b8c							; TIATracker Player
     25  6b8c							; =====================================================================
     26  6b8c				   tt_PlayerStart
     27  6b8c
     28  6b8c							; PLANNED PLAYER VARIANTS:
     29  6b8c							; - RAM, speed, player ROM: c0/c1 patterns have same length
     30  6b8c							; - RAM: Pack 2 values (out of cur_pat_index, cur_note_index, envelope_index)
     31  6b8c							;	 into one and use lsr/asl to unpack them, allowing only ranges of
     32  6b8c							;	 16/16 or 32/8 for them, depending on number of patterns, max
     33  6b8c							;	 pattern size and max ADSR size
     34  6b8c							; - ROM: Check if tt_SequenceTable can hold ptrs directly without indexing
     35  6b8c							;	 tt_PatternPtrLo/Hi. Can be smaller if not many patterns get repeated
     36  6b8c							;	 (saves table and decode routine)
     37  6b8c							; - Speed: Inline tt_CalcInsIndex
     38  6b8c							; - Speed: Store ptr to current note in RAM instead of reconstructing it?
     39  6b8c							;	 Might also save the need for cur_note_index
     40  6b8c
     41  6b8c
     42  6b8c							; ---------------------------------------------------------------------
     43  6b8c							; Helper macro: Retrieves current note. May advance pattern if needed.
     44  6b8c							; Becomes a subroutine if TT_USE_OVERLAY is used.
     45  6b8c							; ---------------------------------------------------------------------
     46  6b8c					      MAC	tt_fetch_current_note
     47  6b8c							; construct ptr to pattern
     48  6b8c				   .constructPatPtr
     49  6b8c					      ldy	tt_cur_pat_index_c0,x	; get current pattern (index into tt_SequenceTable)
     50  6b8c					      lda	tt_SequenceTable,y
     51  6b8c					      IF	TT_USE_GOTO = 1
     52  6b8c					      bpl	.noPatternGoto
     53  6b8c					      and	#%01111111	; mask out goto bit to get pattern number
     54  6b8c					      sta	tt_cur_pat_index_c0,x	; store goto'ed pattern index
     55  6b8c					      bpl	.constructPatPtr	; unconditional
     56  6b8c				   .noPatternGoto
     57  6b8c					      ENDIF
     58  6b8c					      tay
     59  6b8c					      lda	tt_PatternPtrLo,y
     60  6b8c					      sta	tt_ptr
     61  6b8c					      lda	tt_PatternPtrHi,y
     62  6b8c					      sta	tt_ptr+1
     63  6b8c							; get new note
     64  6b8c					      IF	TT_USE_OVERLAY = 0
     65  6b8c					      ldy	tt_cur_note_index_c0,x
     66  6b8c					      ELSE
     67  6b8c							; If the V flag is set and if the new note is an instrument,
     68  6b8c							; it means it got pre-fetched by an overlay percussion, it has
     69  6b8c							; to remain in sustain.
     70  6b8c					      clv
     71  6b8c							; check if note had been pre-fetched by overlay perc already
     72  6b8c					      lda	tt_cur_note_index_c0,x
     73  6b8c					      bpl	.notPrefetched
     74  6b8c							; If so, remove flag
     75  6b8c					      and	#%01111111
     76  6b8c					      sta	tt_cur_note_index_c0,x
     77  6b8c							; Set V flag for later
     78  6b8c					      bit	tt_Bit6Set
     79  6b8c				   .notPrefetched
     80  6b8c					      tay
     81  6b8c					      ENDIF
     82  6b8c					      lda	(tt_ptr),y
     83  6b8c							; pre-process new note
     84  6b8c							; 7..5: instrument (1..7), 4..0 (0..31): frequency
     85  6b8c							; 0/0: End of pattern
     86  6b8c					      bne	.noEndOfPattern
     87  6b8c							; End of pattern: Advance to next pattern
     88  6b8c					      sta	tt_cur_note_index_c0,x	; a is 0
     89  6b8c					      inc	tt_cur_pat_index_c0,x
     90  6b8c					      bne	.constructPatPtr	; unconditional
     91  6b8c				   .noEndOfPattern
     92  6b8c					      ENDM
     93  6b8c
     94  6b8c
     95  6b8c							; ---------------------------------------------------------------------
     96  6b8c							; Music player entry. Call once per frame.
     97  6b8c							; ---------------------------------------------------------------------
     98  6b8c				   tt_Player  SUBROUTINE
     99  6b8c							; ==================== Sequencer ====================
    100  6b8c							; Decrease speed timer
    101  6b8c		       c6 d0		      dec	tt_timer
    102  6b8e		       10 6e		      bpl	.noNewNote
    103  6b90
    104  6b90							; Timer ran out: Do sequencer
    105  6b90							; Advance to next note
    106  6b90		       a2 01		      ldx	#1	; 2 channels
    107  6b92				   .advanceLoop
    108  6b92					      IF	TT_USE_OVERLAY = 1
    109  6b92		       20 a8 f3 	      jsr	tt_FetchNote
    110  6b95				  -	      ELSE
    111  6b95				  -	      TT_FETCH_CURRENT_NOTE
    112  6b95					      ENDIF
    113  6b95							; Parse new note from pattern
    114  6b95		       c9 10		      cmp	#TT_INS_PAUSE
    115  6b97					      IF	TT_USE_SLIDE = 0
    116  6b97		       90 55		      bcc	.finishedNewNote
    117  6b99		       d0 3d		      bne	.newNote
    118  6b9b				  -	      ELSE
    119  6b9b				  -	      beq	.pause
    120  6b9b				  -	      bcs	.newNote
    121  6b9b				  -
    122  6b9b				  -			; --- slide/hold ---
    123  6b9b				  -			; Adjust frequency and hold note in sustain.
    124  6b9b				  -			; composer/tracker has to make sure that no unwanted
    125  6b9b				  -			; under/overflow happens.
    126  6b9b				  -			; Note: f = f + (8-(16-x)) = x + f - 8
    127  6b9b				  -	      adc	tt_cur_ins_c0,x	; carry is clear after cmp
    128  6b9b				  -	      sec
    129  6b9b				  -	      sbc	#8
    130  6b9b				  -	      sta	tt_cur_ins_c0,x
    131  6b9b				  -	      bcs	.finishedNewNote	; unconditional, since legally no underflow can happen (ins>0 or HOLD for ins=0)
    132  6b9b					      ENDIF
    133  6b9b
    134  6b9b							; --- pause ---
    135  6b9b				   .pause
    136  6b9b							; Get release index for current instrument. Since a pause can
    137  6b9b							; only follow an instrument, we don't need to handle percussion
    138  6b9b							; or commands.
    139  6b9b		       b5 d7		      lda	tt_cur_ins_c0,x
    140  6b9d		       20 36 f4 	      jsr	tt_CalcInsIndex
    141  6ba0		       b9 78 f4 	      lda	tt_InsReleaseIndexes-1,y	; -1 b/c instruments start at #1
    142  6ba3							; Put it into release. Skip junk byte so index no longer indicates
    143  6ba3							; sustain phase.
    144  6ba3		       18		      clc
    145  6ba4		       69 01		      adc	#1
    146  6ba6		       90 44		      bcc	.storeADIndex	; unconditional
    147  6ba8
    148  6ba8							; ---------------------------------------------------------------------
    149  6ba8							; Helper subroutine to minimize ROM footprint. Will be inlined if
    150  6ba8							; TT_USE_OVERLAY is not used.
    151  6ba8							; Interleaved here so player can be inlined.
    152  6ba8							; ---------------------------------------------------------------------
    153  6ba8					      IF	TT_USE_OVERLAY = 1
    154  6ba8				   tt_FetchNote
      0  6ba8					      TT_FETCH_CURRENT_NOTE
      1  6ba8
      2  6ba8				   .constructPatPtr
      3  6ba8		       b4 d1		      ldy	tt_cur_pat_index_c0,x
      4  6baa		       b9 8b f5 	      lda	tt_SequenceTable,y
      5  6bad					      IF	TT_USE_GOTO = 1
      6  6bad		       10 06		      bpl	.noPatternGoto
      7  6baf		       29 7f		      and	#%01111111
      8  6bb1		       95 d1		      sta	tt_cur_pat_index_c0,x
      9  6bb3		       10 f3		      bpl	.constructPatPtr
     10  6bb5				   .noPatternGoto
     11  6bb5					      ENDIF
     12  6bb5		       a8		      tay
     13  6bb6		       b9 81 f5 	      lda	tt_PatternPtrLo,y
     14  6bb9		       85 d9		      sta	tt_ptr
     15  6bbb		       b9 86 f5 	      lda	tt_PatternPtrHi,y
     16  6bbe		       85 da		      sta	tt_ptr+1
     17  6bc0
     18  6bc0				  -	      IF	TT_USE_OVERLAY = 0
     19  6bc0				  -	      ldy	tt_cur_note_index_c0,x
     20  6bc0					      ELSE
     21  6bc0
     22  6bc0
     23  6bc0
     24  6bc0		       b8		      clv
     25  6bc1
     26  6bc1		       b5 d3		      lda	tt_cur_note_index_c0,x
     27  6bc3		       10 07		      bpl	.notPrefetched
     28  6bc5
     29  6bc5		       29 7f		      and	#%01111111
     30  6bc7		       95 d3		      sta	tt_cur_note_index_c0,x
     31  6bc9
     32  6bc9		       2c 3c f4 	      bit	tt_Bit6Set
     33  6bcc				   .notPrefetched
     34  6bcc		       a8		      tay
     35  6bcd					      ENDIF
     36  6bcd		       b1 d9		      lda	(tt_ptr),y
     37  6bcf
     38  6bcf
     39  6bcf
     40  6bcf		       d0 06		      bne	.noEndOfPattern
     41  6bd1
     42  6bd1		       95 d3		      sta	tt_cur_note_index_c0,x
     43  6bd3		       f6 d1		      inc	tt_cur_pat_index_c0,x
     44  6bd5		       d0 d1		      bne	.constructPatPtr
     45  6bd7				   .noEndOfPattern
    156  6bd7		       60		      rts
    157  6bd8					      ENDIF
    158  6bd8
    159  6bd8
    160  6bd8							; --- start instrument or percussion ---
    161  6bd8				   .newNote
    162  6bd8		       95 d7		      sta	tt_cur_ins_c0,x	; set new instrument
    163  6bda							; Instrument or percussion?
    164  6bda		       c9 20		      cmp	#TT_FREQ_MASK+1
    165  6bdc		       b0 06		      bcs	.startInstrument
    166  6bde
    167  6bde							; --- start percussion ---
    168  6bde							; Get index of envelope
    169  6bde		       a8		      tay
    170  6bdf							; -TT_FIRST_PERC because percussion start with TT_FIRST_PERC
    171  6bdf		       b9 9c f4 	      lda	tt_PercIndexes-TT_FIRST_PERC,y
    172  6be2		       d0 08		      bne	.storeADIndex	; unconditional, since index values are >0
    173  6be4
    174  6be4							; --- start instrument ---
    175  6be4				   .startInstrument
    176  6be4					      IF	TT_USE_OVERLAY = 1
    177  6be4							; If V flag is set, this note had been pre-fetched. That means
    178  6be4							; it should remain in sustain.
    179  6be4		       70 08		      bvs	.finishedNewNote
    180  6be6					      ENDIF
    181  6be6							; Put note into attack/decay
    182  6be6		       20 36 f4 	      jsr	tt_CalcInsIndex
    183  6be9		       b9 6e f4 	      lda	tt_InsADIndexes-1,y	; -1 because instruments start at #1
    184  6bec				   .storeADIndex
    185  6bec		       95 d5		      sta	tt_envelope_index_c0,x
    186  6bee
    187  6bee							; --- Finished parsing new note ---
    188  6bee				   .finishedNewNote
    189  6bee							; increase note index into pattern
    190  6bee		       f6 d3		      inc	tt_cur_note_index_c0,x
    191  6bf0							; loop over channels
    192  6bf0				   .sequencerNextChannel
    193  6bf0		       ca		      dex
    194  6bf1		       10 9f		      bpl	.advanceLoop
    195  6bf3
    196  6bf3							; Reset timer value
    197  6bf3				  -	      IF	TT_GLOBAL_SPEED = 0
    198  6bf3				  -			; Get timer value for current pattern in channel 0
    199  6bf3				  -	      ldx	tt_cur_pat_index_c0	; get current pattern (index into tt_SequenceTable)
    200  6bf3				  -	      ldy	tt_SequenceTable,x	; Current pattern index now in y
    201  6bf3				  -	      IF	TT_USE_FUNKTEMPO = 0
    202  6bf3				  -	      lda	tt_PatternSpeeds,y
    203  6bf3				  -	      sta	tt_timer
    204  6bf3				  -	      ELSE
    205  6bf3				  -			; Test for odd/even frame
    206  6bf3				  -	      lda	tt_cur_note_index_c0
    207  6bf3				  -	      lsr
    208  6bf3				  -	      lda	tt_PatternSpeeds,y	; does not affect carry flag
    209  6bf3				  -	      bcc	.evenFrame
    210  6bf3				  -	      and	#$0f	; does not affect carry flag
    211  6bf3				  -	      bcs	.storeFunkTempo
    212  6bf3				  -.evenFrame
    213  6bf3				  -	      lsr
    214  6bf3				  -	      lsr
    215  6bf3				  -	      lsr
    216  6bf3				  -	      lsr
    217  6bf3				  -.storeFunkTempo
    218  6bf3				  -	      sta	tt_timer
    219  6bf3				  -	      ENDIF		; TT_USE_FUNKTEMPO = 0
    220  6bf3				  -
    221  6bf3					      ELSE
    222  6bf3							; Global tempo
    223  6bf3		       a2 04		      ldx	#TT_SPEED-1
    224  6bf5					      IF	TT_USE_FUNKTEMPO = 1
    225  6bf5		       a5 d3		      lda	tt_cur_note_index_c0
    226  6bf7		       4a		      lsr
    227  6bf8		       90 02		      bcc	.noOddFrame
    228  6bfa		       a2 03		      ldx	#TT_ODD_SPEED-1
    229  6bfc				   .noOddFrame
    230  6bfc					      ENDIF		; TT_USE_FUNKTEMPO = 1
    231  6bfc		       86 d0		      stx	tt_timer
    232  6bfe					      ENDIF		; TT_GLOBAL_SPEED = 0
    233  6bfe
    234  6bfe							; No new note to process
    235  6bfe				   .noNewNote
    236  6bfe
    237  6bfe							; ==================== Update registers ====================
    238  6bfe		       a2 01		      ldx	#1	; 2 channels
    239  6c00				   .updateLoop
    240  6c00							; Percussion or melodic instrument?
    241  6c00		       b5 d7		      lda	tt_cur_ins_c0,x
    242  6c02				  -	      IF	TT_STARTS_WITH_NOTES = 0
    243  6c02				  -			; This branch can be removed if track starts with a note in each channel
    244  6c02				  -	      beq	.afterAudioUpdate
    245  6c02					      ENDIF
    246  6c02		       c9 20		      cmp	#TT_FREQ_MASK+1
    247  6c04		       b0 37		      bcs	.instrument	; Melodic instrument
    248  6c06
    249  6c06							; --- Percussion: Get envelope index ---
    250  6c06		       b4 d5		      ldy	tt_envelope_index_c0,x
    251  6c08							; Set AUDC and AUDV value from envelope
    252  6c08		       b9 c5 f4 	      lda	tt_PercCtrlVolTable-1,y	; -1 because values are stored +1
    253  6c0b		       f0 02		      beq	.endOfPercussion	; 0 means end of percussion data
    254  6c0d		       f6 d5		      inc	tt_envelope_index_c0,x	; if end not reached: advance index
    255  6c0f				   .endOfPercussion
    256  6c0f		       95 59		      sta	AUDV0,x
    257  6c11		       4a		      lsr
    258  6c12		       4a		      lsr
    259  6c13		       4a		      lsr
    260  6c14		       4a		      lsr
    261  6c15		       95 55		      sta	AUDC0,x
    262  6c17							; Set AUDF
    263  6c17		       b9 af f4 	      lda	tt_PercFreqTable-1,y	; -1 because values are stored +1
    264  6c1a							; Bit 7 (overlay) might be set, but is unused in AUDF
    265  6c1a		       95 57		      sta	AUDF0,x
    266  6c1c					      IF	TT_USE_OVERLAY = 1
    267  6c1c		       10 48		      bpl	.afterAudioUpdate
    268  6c1e							; Overlay percussion: Fetch next note out of order
    269  6c1e		       20 a8 f3 	      jsr	tt_FetchNote
    270  6c21							; Only do something if it's a melodic instrument
    271  6c21		       c9 20		      cmp	#TT_FREQ_MASK+1
    272  6c23		       90 41		      bcc	.afterAudioUpdate
    273  6c25							; Instrument: Put into sustain
    274  6c25		       95 d7		      sta	tt_cur_ins_c0,x	; set new instrument
    275  6c27		       20 36 f4 	      jsr	tt_CalcInsIndex
    276  6c2a		       b9 73 f4 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start at #1
    277  6c2d		       95 d5		      sta	tt_envelope_index_c0,x
    278  6c2f							; Set prefetch flag. asl-sec-ror is smaller than lda-ora #128-sta
    279  6c2f		       16 d3		      asl	tt_cur_note_index_c0,x
    280  6c31		       38		      sec
    281  6c32		       76 d3		      ror	tt_cur_note_index_c0,x
    282  6c34		       30 30		      bmi	.afterAudioUpdate	; unconditional
    283  6c36				  -	      ELSE
    284  6c36				  -	      jmp	.afterAudioUpdate
    285  6c36					      ENDIF
    286  6c36
    287  6c36
    288  6c36							; ---------------------------------------------------------------------
    289  6c36							; Helper subroutine to minimize ROM footprint.
    290  6c36							; Interleaved here so player routine can be inlined.
    291  6c36							; ---------------------------------------------------------------------
    292  6c36				   tt_CalcInsIndex
    293  6c36							; move upper 3 bits to lower 3
    294  6c36		       4a		      lsr
    295  6c37		       4a		      lsr
    296  6c38		       4a		      lsr
    297  6c39		       4a		      lsr
    298  6c3a		       4a		      lsr
    299  6c3b		       a8		      tay
    300  6c3c				   tt_Bit6Set		; This opcode has bit #6 set, for use with bit instruction
    301  6c3c		       60		      rts
    302  6c3d
    303  6c3d
    304  6c3d				   .instrument
    305  6c3d							; --- Melodic instrument ---
    306  6c3d							; Compute index into ADSR indexes and master Ctrl tables
    307  6c3d		       20 36 f4 	      jsr	tt_CalcInsIndex
    308  6c40							; Set AUDC with master value for this instrument, while we are at it
    309  6c40		       b9 69 f4 	      lda	tt_InsCtrlTable-1,y	; -1 because instruments start with #1
    310  6c43		       95 55		      sta	AUDC0,x
    311  6c45							; advance ADSR counter and compare to end of Sustain
    312  6c45		       b5 d5		      lda	tt_envelope_index_c0,x
    313  6c47		       d9 78 f4 	      cmp	tt_InsReleaseIndexes-1,y	; -1 because instruments start with #1
    314  6c4a		       d0 03		      bne	.noEndOfSustain
    315  6c4c							; End of sustain: Go back to start of sustain
    316  6c4c		       b9 73 f4 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start with #1
    317  6c4f				   .noEndOfSustain
    318  6c4f		       a8		      tay
    319  6c50							; Set volume from envelope
    320  6c50		       b9 7e f4 	      lda	tt_InsFreqVolTable,y
    321  6c53		       f0 01		      beq	.endOfEnvelope	; 0 means end of release has been reached:
    322  6c55		       c8		      iny		; advance index otherwise
    323  6c56				   .endOfEnvelope
    324  6c56		       94 d5		      sty	tt_envelope_index_c0,x
    325  6c58		       95 59		      sta	AUDV0,x
    326  6c5a							; Now adjust frequency with ADSR value from envelope
    327  6c5a		       4a		      lsr
    328  6c5b		       4a		      lsr
    329  6c5c		       4a		      lsr
    330  6c5d		       4a		      lsr
    331  6c5e		       18		      clc
    332  6c5f		       75 d7		      adc	tt_cur_ins_c0,x
    333  6c61		       38		      sec
    334  6c62		       e9 08		      sbc	#8
    335  6c64		       95 57		      sta	AUDF0,x
    336  6c66
    337  6c66				   .afterAudioUpdate
    338  6c66							; loop over channels
    339  6c66		       ca		      dex
    340  6c67		       10 97		      bpl	.updateLoop
    341  6c69
 Music player size:  $dd
    342  6c69					      echo	"Music player size: ", *-tt_PlayerStart
------- FILE BANK_INITBANK.asm
   1027  6c69		       60		      rts
   1028  6c6a
------- FILE sound/intro1_trackdata.asm LEVEL 3 PASS 3
      0  6c6a					      include	"sound/intro1_trackdata.asm"
      1  6c6a							; TIATracker music player
      2  6c6a							; Copyright 2016 Andre "Kylearan" Wichmann
      3  6c6a							; Website: https://bitbucket.org/kylearan/tiatracker
      4  6c6a							; Email: andre.wichmann@gmx.de
      5  6c6a							;
      6  6c6a							; Licensed under the Apache License, Version 2.0 (the "License");
      7  6c6a							; you may not use this file except in compliance with the License.
      8  6c6a							; You may obtain a copy of the License at
      9  6c6a							;
     10  6c6a							;   http://www.apache.org/licenses/LICENSE-2.0
     11  6c6a							;
     12  6c6a							; Unless required by applicable law or agreed to in writing, software
     13  6c6a							; distributed under the License is distributed on an "AS IS" BASIS,
     14  6c6a							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  6c6a							; See the License for the specific language governing permissions and
     16  6c6a							; limitations under the License.
     17  6c6a
     18  6c6a							; Song author: 
     19  6c6a							; Song name: 
     20  6c6a
     21  6c6a							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  6c6a
     23  6c6a							; =====================================================================
     24  6c6a							; TIATracker melodic and percussion instruments, patterns and sequencer
     25  6c6a							; data.
     26  6c6a							; =====================================================================
     27  6c6a				   tt_TrackDataStart
     28  6c6a
     29  6c6a							; =====================================================================
     30  6c6a							; Melodic instrument definitions (up to 7). tt_envelope_index_c0/1 hold
     31  6c6a							; the index values into these tables for the current instruments played
     32  6c6a							; in channel 0 and 1.
     33  6c6a							; 
     34  6c6a							; Each instrument is defined by:
     35  6c6a							; - tt_InsCtrlTable: the AUDC value
     36  6c6a							; - tt_InsADIndexes: the index of the start of the ADSR envelope as
     37  6c6a							;	 defined in tt_InsFreqVolTable
     38  6c6a							; - tt_InsSustainIndexes: the index of the start of the Sustain phase
     39  6c6a							;	 of the envelope
     40  6c6a							; - tt_InsReleaseIndexes: the index of the start of the Release phase
     41  6c6a							; - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
     42  6c6a							;	 the envelope
     43  6c6a							; =====================================================================
     44  6c6a
     45  6c6a							; Instrument master CTRL values
     46  6c6a				   tt_InsCtrlTable
     47  6c6a		       07 04 0c 04*	      dc.b	$07, $04, $0c, $04, $0c
     48  6c6f
     49  6c6f
     50  6c6f							; Instrument Attack/Decay start indexes into ADSR tables.
     51  6c6f				   tt_InsADIndexes
     52  6c6f		       00 0e 0e 1e*	      dc.b	$00, $0e, $0e, $1e, $1e
     53  6c74
     54  6c74
     55  6c74							; Instrument Sustain start indexes into ADSR tables
     56  6c74				   tt_InsSustainIndexes
     57  6c74		       08 19 19 2b*	      dc.b	$08, $19, $19, $2b, $2b
     58  6c79
     59  6c79
     60  6c79							; Instrument Release start indexes into ADSR tables
     61  6c79							; Caution: Values are stored with an implicit -1 modifier! To get the
     62  6c79							; real index, add 1.
     63  6c79				   tt_InsReleaseIndexes
     64  6c79		       09 1b 1b 2c*	      dc.b	$09, $1b, $1b, $2c, $2c
     65  6c7e
     66  6c7e
     67  6c7e							; AUDVx and AUDFx ADSR envelope values.
     68  6c7e							; Each byte encodes the frequency and volume:
     69  6c7e							; - Bits 7..4: Freqency modifier for the current note ([-8..7]),
     70  6c7e							;	 8 means no change. Bit 7 is the sign bit.
     71  6c7e							; - Bits 3..0: Volume
     72  6c7e							; Between sustain and release is one byte that is not used and
     73  6c7e							; can be any value.
     74  6c7e							; The end of the release phase is encoded by a 0.
     75  6c7e				   tt_InsFreqVolTable
     76  6c7e							; 0: Pizzicato bassb
     77  6c7e		       8a 8a 89 88*	      dc.b	$8a, $8a, $89, $88, $86, $85, $85, $84
     78  6c86		       83 00 83 83*	      dc.b	$83, $00, $83, $83, $83, $00
     79  6c8c							; 1+2: Square2
     80  6c8c		       8c 8c 8b 89*	      dc.b	$8c, $8c, $8b, $89, $87, $85, $84, $83
     81  6c94		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $00, $81, $00
     82  6c9c							; 3+4: Square
     83  6c9c		       85 85 85 85*	      dc.b	$85, $85, $85, $85, $84, $83, $83, $82
     84  6ca4		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $81, $00, $80
     85  6cac		       00		      dc.b	$00
     86  6cad
     87  6cad
     88  6cad
     89  6cad							; =====================================================================
     90  6cad							; Percussion instrument definitions (up to 15)
     91  6cad							;
     92  6cad							; Each percussion instrument is defined by:
     93  6cad							; - tt_PercIndexes: The index of the first percussion frame as defined
     94  6cad							;	 in tt_PercFreqTable and tt_PercCtrlVolTable
     95  6cad							; - tt_PercFreqTable: The AUDF frequency value
     96  6cad							; - tt_PercCtrlVolTable: The AUDV volume and AUDC values
     97  6cad							; =====================================================================
     98  6cad
     99  6cad							; Indexes into percussion definitions signifying the first frame for
    100  6cad							; each percussion in tt_PercFreqTable.
    101  6cad							; Caution: Values are stored with an implicit +1 modifier! To get the
    102  6cad							; real index, subtract 1.
    103  6cad				   tt_PercIndexes
    104  6cad		       01 0a 0c 	      dc.b	$01, $0a, $0c
    105  6cb0
    106  6cb0
    107  6cb0							; The AUDF frequency values for the percussion instruments.
    108  6cb0							; If the second to last value is negative (>=128), it means it's an
    109  6cb0							; "overlay" percussion, i.e. the player fetches the next instrument note
    110  6cb0							; immediately and starts it in the sustain phase next frame. (Needs
    111  6cb0							; TT_USE_OVERLAY)
    112  6cb0				   tt_PercFreqTable
    113  6cb0							; 0: Kick
    114  6cb0		       00 01 02 03*	      dc.b	$00, $01, $02, $03, $04, $05, $06, $87
    115  6cb8		       00		      dc.b	$00
    116  6cb9							; 1: HH
    117  6cb9		       80 00		      dc.b	$80, $00
    118  6cbb							; 2: Snare
    119  6cbb		       01 03 06 0e*	      dc.b	$01, $03, $06, $0e, $13, $11, $15, $14
    120  6cc3		       17 1b 00 	      dc.b	$17, $1b, $00
    121  6cc6
    122  6cc6
    123  6cc6							; The AUDCx and AUDVx volume values for the percussion instruments.
    124  6cc6							; - Bits 7..4: AUDC value
    125  6cc6							; - Bits 3..0: AUDV value
    126  6cc6							; 0 means end of percussion data.
    127  6cc6				   tt_PercCtrlVolTable
    128  6cc6							; 0: Kick
    129  6cc6		       ee ed ed eb*	      dc.b	$ee, $ed, $ed, $eb, $e9, $e8, $e8, $e6
    130  6cce		       00		      dc.b	$00
    131  6ccf							; 1: HH
    132  6ccf		       87 00		      dc.b	$87, $00
    133  6cd1							; 2: Snare
    134  6cd1		       8b 8a 8a 8a*	      dc.b	$8b, $8a, $8a, $8a, $8a, $8a, $89, $88
    135  6cd9		       87 86 00 	      dc.b	$87, $86, $00
    136  6cdc
    137  6cdc
    138  6cdc
    139  6cdc							; =====================================================================
    140  6cdc							; Track definition
    141  6cdc							; The track is defined by:
    142  6cdc							; - tt_PatternX (X=0, 1, ...): Pattern definitions
    143  6cdc							; - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
    144  6cdc							;	 as index values
    145  6cdc							; - tt_SequenceTable: The order in which the patterns should be played,
    146  6cdc							;	 i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
    147  6cdc							;	 for all channels and sub-tracks. The variables
    148  6cdc							;	 tt_cur_pat_index_c0/1 hold an index into tt_SequenceTable for
    149  6cdc							;	 each channel.
    150  6cdc							;
    151  6cdc							; So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
    152  6cdc							; in turn point to pattern definitions (tt_PatternX) in which the notes
    153  6cdc							; to play are specified.
    154  6cdc							; =====================================================================
    155  6cdc
    156  6cdc							; ---------------------------------------------------------------------
    157  6cdc							; Pattern definitions, one table per pattern. tt_cur_note_index_c0/1
    158  6cdc							; hold the index values into these tables for the current pattern
    159  6cdc							; played in channel 0 and 1.
    160  6cdc							;
    161  6cdc							; A pattern is a sequence of notes (one byte per note) ending with a 0.
    162  6cdc							; A note can be either:
    163  6cdc							; - Pause: Put melodic instrument into release. Must only follow a
    164  6cdc							;	 melodic instrument.
    165  6cdc							; - Hold: Continue to play last note (or silence). Default "empty" note.
    166  6cdc							; - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
    167  6cdc							;	 by -7..+7 and keep playing it
    168  6cdc							; - Play new note with melodic instrument
    169  6cdc							; - Play new note with percussion instrument
    170  6cdc							; - End of pattern
    171  6cdc							;
    172  6cdc							; A note is defined by:
    173  6cdc							; - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
    174  6cdc							;	 and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
    175  6cdc							;	 defined as:
    176  6cdc							;	 - 0: End of pattern
    177  6cdc							;	 - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
    178  6cdc							;	 - 8: Hold
    179  6cdc							;	 - 16: Pause
    180  6cdc							;	 - [17..31]: Play percussion instrument 1..15
    181  6cdc							;
    182  6cdc							; The tracker must ensure that a pause only follows a melodic
    183  6cdc							; instrument or a hold/slide.
    184  6cdc							; ---------------------------------------------------------------------
    185  6cdc		       00 1f	   TT_FREQ_MASK =	%00011111
    186  6cdc		       00 08	   TT_INS_HOLD =	8
    187  6cdc		       00 10	   TT_INS_PAUSE =	16
    188  6cdc		       00 11	   TT_FIRST_PERC =	17
    189  6cdc
    190  6cdc							; Intro left
    191  6cdc				   tt_pattern0
    192  6cdc		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $3e, $08
    193  6ce4		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $3e, $08
    194  6cec		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $12, $3e
    195  6cf4		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $13, $08
    196  6cfc		       00		      dc.b	$00
    197  6cfd
    198  6cfd							; Intro2 L
    199  6cfd				   tt_pattern1
    200  6cfd		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    201  6d05		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    202  6d0d		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    203  6d15		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    204  6d1d		       00		      dc.b	$00
    205  6d1e
    206  6d1e							; Intro2-fill L
    207  6d1e				   tt_pattern2
    208  6d1e		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    209  6d26		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    210  6d2e		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    211  6d36		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    212  6d3e		       00		      dc.b	$00
    213  6d3f
    214  6d3f							; Intro right
    215  6d3f				   tt_pattern3
    216  6d3f		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $73, $08
    217  6d47		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $73, $08, $73, $08
    218  6d4f		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $b3, $08
    219  6d57		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    220  6d5f		       00		      dc.b	$00
    221  6d60
    222  6d60							; Intro2 R
    223  6d60				   tt_pattern4
    224  6d60		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    225  6d68		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    226  6d70		       b3 08 73 08*	      dc.b	$b3, $08, $73, $08, $b3, $08, $73, $08
    227  6d78		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    228  6d80		       00		      dc.b	$00
    229  6d81
    230  6d81
    231  6d81
    232  6d81
    233  6d81							; Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
    234  6d81							; Each byte encodes the speed of one pattern in the order
    235  6d81							; of the tt_PatternPtr tables below.
    236  6d81							; If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
    237  6d81							; the even speed and the high nibble the odd speed.
    238  6d81				  -	      IF	TT_GLOBAL_SPEED = 0
    239  6d81				  -tt_PatternSpeeds
    240  6d81				  -%%PATTERNSPEEDS%%
    241  6d81					      ENDIF
    242  6d81
    243  6d81
    244  6d81							; ---------------------------------------------------------------------
    245  6d81							; Pattern pointers look-up table.
    246  6d81							; ---------------------------------------------------------------------
    247  6d81				   tt_PatternPtrLo
    248  6d81		       dc fd 1e 3f	      dc.b	<tt_pattern0, <tt_pattern1, <tt_pattern2, <tt_pattern3
    249  6d85		       60		      dc.b	<tt_pattern4
    250  6d86				   tt_PatternPtrHi
    251  6d86		       f4 f4 f5 f5	      dc.b	>tt_pattern0, >tt_pattern1, >tt_pattern2, >tt_pattern3
    252  6d8a		       f5		      dc.b	>tt_pattern4
    253  6d8b
    254  6d8b
    255  6d8b							; ---------------------------------------------------------------------
    256  6d8b							; Pattern sequence table. Each byte is an index into the
    257  6d8b							; tt_PatternPtrLo/Hi tables where the pointers to the pattern
    258  6d8b							; definitions can be found. When a pattern has been played completely,
    259  6d8b							; the next byte from this table is used to get the address of the next
    260  6d8b							; pattern to play. tt_cur_pat_index_c0/1 hold the current index values
    261  6d8b							; into this table for channels 0 and 1.
    262  6d8b							; If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
    263  6d8b							; number encoded in bits 6..0 (i.e. value AND %01111111).
    264  6d8b							; ---------------------------------------------------------------------
    265  6d8b				   tt_SequenceTable
    266  6d8b							; ---------- Channel 0 ----------
    267  6d8b		       00 00 01 02*	      dc.b	$00, $00, $01, $02, $80
    268  6d90
    269  6d90
    270  6d90							; ---------- Channel 1 ----------
    271  6d90		       03 04 03 04*	      dc.b	$03, $04, $03, $04, $85
    272  6d95
    273  6d95
 Track size:  $12b
    274  6d95					      echo	"Track size: ", *-tt_TrackDataStart
------- FILE BANK_INITBANK.asm
   1030  6d95
   1031  6d95							;------------------------------------------------------------------------------
   1032  6d95
      0  6d95					      CHECK_BANK_SIZE	"INITBANK"
      1  6d95		       05 95	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $595 , FREE= $26b
      2  6d95					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  6d95				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  6d95				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  6d95				  -	      ERR
      6  6d95					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_FIXED.asm LEVEL 2 PASS 3
      0  6d95					      include	"BANK_FIXED.asm"
      1  6d95							;    Sokoboo - a Sokoban implementation
      2  6d95							;    using a generic tile-based display engine for the Atari 2600
      3  6d95							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  6d95							;
      5  6d95							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  6d95							;
      7  6d95							;    Code related to the generic tile-based display engine was developed by
      8  6d95							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  6d95							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  6d95							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  6d95							;
     12  6d95							;    Code related to music and sound effects uses the TIATracker music player
     13  6d95							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  6d95							;    directory for Apache licensing details.
     15  6d95							;
     16  6d95							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  6d95							;    See the copyright notices in the License directory for a list of level
     18  6d95							;    contributors.
     19  6d95							;
     20  6d95							;    Except where otherwise indicated, this software is released under the
     21  6d95							;    following licensing arrangement...
     22  6d95							;
     23  6d95							;    This program is free software: you can redistribute it and/or modify
     24  6d95							;    it under the terms of the GNU General Public License as published by
     25  6d95							;    the Free Software Foundation, either version 3 of the License, or
     26  6d95							;    (at your option) any later version.
     27  6d95							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  6d95
     29  6d95							;    This program is distributed in the hope that it will be useful,
     30  6d95							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  6d95							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  6d95							;    GNU General Public License for more details.
     33  6d95
     34  6d95							;------------------------------------------------------------------------------
     35  6d95							;###############################  FIXED BANK  #################################
     36  6d95							;------------------------------------------------------------------------------
     37  6d95
     38  6d95
     39  6d95				   ORIGIN     SET	FIXED_BANK
     40  6d95
      0  6d95					      NEWBANK	THE_FIXED_BANK
      1  7ef0 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
     42  7800					      RORG	$f800
     43  7800
     44  7800
     45  7800
     46  7800							;------------------------------------------------------------------------------
     47  7800
      0  7800					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  7800		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  7800					      SUBROUTINE
      3  7800				   DrawTimeFromROM
     49  7800
     50  7800		       a9 09		      lda	#BANK_SCORING
     51  7802		       85 3e		      sta	SET_BANK_RAM
     52  7804		       20 c1 f2 	      jsr	DrawTime
     53  7807		       20 ac f2 	      jsr	DrawBCD_targetsRequired
     54  780a		       a5 c4		      lda	ROM_Bank
     55  780c		       85 3f		      sta	SET_BANK
     56  780e		       60		      rts
     57  780f
     58  780f							;------------------------------------------------------------------------------
     59  780f
      0  780f					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  780f		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  780f					      SUBROUTINE
      3  780f				   GetROMByte
     61  780f
     62  780f							; a = ROM bank to retrieve
     63  780f							; y = page index
     64  780f							; ROM_Bank = bank to return to
     65  780f							; (Board_AddressR) = page
     66  780f							; out a = byte from (Board_AddressR)
     67  780f
     68  780f		       85 3f		      sta	SET_BANK	;3
     69  7811		       4c 16 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
     70  7814
     71  7814							;------------------------------------------------------------------------------
     72  7814
      0  7814					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7814		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7814					      SUBROUTINE
      3  7814				   GetBoardCharacter
     74  7814
     75  7814							; call from ROM bank
     76  7814							; switches back to ROM_Bank on exit
     77  7814
     78  7814							; pass A = bank containing character
     79  7814							; Y = x character position
     80  7814							; (Board_AddressR) points to character position
     81  7814							; returns character from board
     82  7814
     83  7814
     84  7814		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
     85  7816
     86  7816				   GetBoardCharacter2		;=17(A)
     87  7816
     88  7816		       b3 c0		      lax	(Board_AddressR),y	;5
     89  7818		       a4 c4		      ldy	ROM_Bank	;3
     90  781a		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
     91  781c		       60		      rts		;6   and go back
     92  781d
     93  781d							;---------------------------------------------------------------------------
     94  781d
      0  781d					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  781d		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  781d					      SUBROUTINE
      3  781d				   PutBoardCharacter
     96  781d
     97  781d		       86 3e		      stx	SET_BANK_RAM	; 3
     98  781f
     99  781f				   PutBoardCharacterSB		; =18
    100  781f		       91 c2		      sta	(Board_AddressW),y	; 6
    101  7821		       a5 c4		      lda	ROM_Bank	; 3
    102  7823		       85 3f		      sta	SET_BANK	; 3
    103  7825		       60		      rts		; 6 = 21
    104  7826
    105  7826							;---------------------------------------------------------------------------
    106  7826
      0  7826					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  7826		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  7826					      SUBROUTINE
      3  7826				   GetBoardCharacter__CALL_FROM_RAM__
    108  7826
    109  7826		       a4 88		      ldy	POS_Y	;3
    110  7828
    111  7828		       a9 0d		      lda	#BANK_GetBoardAddressR	;
    112  782a		       85 3f		      sta	SET_BANK	;
    113  782c		       20 ca f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    114  782f
    115  782f
    116  782f							;DEFINE_SUBROUTINE PartialGetBoardCharacter ;=23
    117  782f
    118  782f		       85 3e		      sta	SET_BANK_RAM	;3
    119  7831		       a4 87		      ldy	POS_X	;3
    120  7833		       b3 c0		      lax	(Board_AddressR),y	;5
    121  7835		       a4 c5		      ldy	RAM_Bank	;3
    122  7837		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    123  7839		       60		      rts		;6		 and go back
    124  783a
    125  783a							;---------------------------------------------------------------------------
    126  783a
      0  783a					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  783a		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  783a					      SUBROUTINE
      3  783a				   PutBoardCharacterFromRAM
    128  783a
    129  783a							; POS_Y  = row
    130  783a							; POS_Type = character to write
    131  783a							; POS_X     = column
    132  783a							; RAM_Bank = caller's bank
    133  783a
    134  783a		       a4 88		      ldy	POS_Y	;3
    135  783c
    136  783c		       a9 0d		      lda	#BANK_GetBoardAddressW	;
    137  783e		       85 3f		      sta	SET_BANK	;
    138  7840		       20 d7 f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
    139  7843
    140  7843		       86 3e		      stx	SET_BANK_RAM	;3
    141  7845
    142  7845		       a4 87		      ldy	POS_X	;3
    143  7847		       a5 8b		      lda	POS_Type	;3
    144  7849		       91 c2		      sta	(Board_AddressW),y	;6
    145  784b		       a4 c5		      ldy	RAM_Bank	;3
    146  784d		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    147  784f		       60		      rts		;6
    148  7850
    149  7850
      0  7850					      DEFINE_SUBROUTINE	PutBoardCharacterFromROM
      1  7850		       00 0f	   BANK_PutBoardCharacterFromROM =	_CURRENT_BANK
      2  7850					      SUBROUTINE
      3  7850				   PutBoardCharacterFromROM
    151  7850		       48		      pha
    152  7851		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    153  7854		       68		      pla
    154  7855		       85 3f		      sta	SET_BANK
    155  7857		       60		      rts
    156  7858
    157  7858							;---------------------------------------------------------------------------
    158  7858
      0  7858					      DEFINE_SUBROUTINE	ProcessObjStack	; @31✅ called from Vector
      1  7858		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  7858					      SUBROUTINE
      3  7858				   ProcessObjStack
    160  7858							; 15 minimum segtime abort
    161  7858
    162  7858		       ad 84 02 	      lda	INTIM	; 4
    163  785b		       c9 02		      cmp	#MINIMUM_SEGTIME	; 2
    164  785d		       90 31		      bcc	EarlyAbort	; 2(3)= 8
    165  785f							; => [31]+9+6rts = 46✅ on abort
    166  785f							; @0✅
    167  785f
    168  785f		       a5 82		      lda	ObjStackNum	; 3
    169  7861		       49 01		      eor	#1	; 2
    170  7863		       aa		      tax		; 2 = 7✅
    171  7864
    172  7864		       a5 cc		      lda	ObjIterator	; 3
    173  7866		       d5 83		      cmp	ObjStackPtr,x	; 5
    174  7868		       b0 24		      bcs	nextPhase	; 2/3 = 10/11[+11] ==> @22✅ on exit
    175  786a
    176  786a							; @17✅
    177  786a							; Process an object...
    178  786a							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    179  786a
    180  786a		       bc 3b f9 	      ldy	BankObjStack,x	; 4
    181  786d		       84 3e		      sty	SET_BANK_RAM	; 3 = 7
    182  786f
    183  786f		       aa		      tax		; 2
    184  7870		       bc 80 11 	      ldy	SortedObjPtr,x	; 4 = 6	      indirect object pointer list (sorted)
    185  7873
    186  7873		       b9 00 10 	      lda	ObjStackX,y	; 4
    187  7876		       85 87		      sta	POS_X	; 3
    188  7878		       b9 80 10 	      lda	ObjStackY,y	; 4
    189  787b		       85 88		      sta	POS_Y	; 3
    190  787d		       b9 00 11 	      lda	ObjStackVar,y	; 4
    191  7880		       85 8c		      sta	POS_VAR	; 3
    192  7882		       be 00 12 	      ldx	ObjStackType,y	; 4
    193  7885		       86 8b		      stx	POS_Type	; 3 = 28
    194  7887
    195  7887		       a9 0d		      lda	#BANK_VectorProcess	; 2
    196  7889		       85 3f		      sta	SET_BANK	; 3
    197  788b		       4c 5f f3 	      jmp	VectorProcess	; 3 = 8
    198  788e
    199  788e							; => [17]+7+6+28+8 = @64 entry to VectorProcess
    200  788e							; + 31 minimum timeout return
    201  788e							; = 95✅
    202  788e
    203  788e							;---------------------------------------------------------------------------
    204  788e							; Now process the blank stack.  This stack holds all the recently blanked squares
    205  788e							; and determines (and moves) BOXs or TARGETs into these squares.  The space vacated
    206  788e							; by these objects are added again to the blank stack.
    207  788e
    208  788e				   nextPhase		; +11✅ for exit from here
    209  788e
    210  788e		       e6 86		      inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    211  7890		       60	   EarlyAbort rts		;6
    212  7891
    213  7891							;---------------------------------------------------------------------------
    214  7891
      0  7891					      DEFINE_SUBROUTINE	SwitchObjects	; = 31 ✅
      1  7891		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  7891					      SUBROUTINE
      3  7891				   SwitchObjects
    216  7891
    217  7891							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    218  7891							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    219  7891							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    220  7891
    221  7891		       ad 84 02 	      lda	INTIM	; 4
    222  7894		       c9 01		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    223  7896		       90 f8		      bcc	EarlyAbort	; 2(3) => [31]+(9)+6rts = 46✅ on abort
    224  7898
    225  7898							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    226  7898							; we're at the throttle cutoff do we switch game-frames.
    227  7898
    228  7898							;sec
    229  7898		       a5 b5		      lda	Throttle	;3
    230  789a		       e9 a0		      sbc	#MAX_THROTTLE	;2
    231  789c		       90 f2		      bcc	EarlyAbort	;2/3		 plenty of time left!
    232  789e		       85 b5		      sta	Throttle	;3 = 10	 save fractional 'left over' bit
    233  78a0
    234  78a0		       e6 cf		      inc	animate_char_index	; 5
    235  78a2
    236  78a2							; Now that we have completed processing the object stack, we switch
    237  78a2							; the stack bank pointers for the next time around.
    238  78a2
    239  78a2		       a5 82		      lda	ObjStackNum	;3
    240  78a4		       49 01		      eor	#1	;2
    241  78a6		       aa		      tax		;2
    242  78a7		       86 82		      stx	ObjStackNum	;3 = 10	 swap stacks @here
    243  78a9
    244  78a9							; Initialise the iterator and stack pointer for next time around.
    245  78a9							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    246  78a9							; necessary to initialise both.
    247  78a9
    248  78a9		       a0 00		      ldy	#0	;2
    249  78ab		       84 cc		      sty	ObjIterator	;3
    250  78ad		       94 83		      sty	ObjStackPtr,x	;4
    251  78af
    252  78af		       84 86		      sty	ScreenDrawPhase	;3
    253  78b1		       60		      rts		;6
    254  78b2
    255  78b2							;---------------------------------------------------------------------------
    256  78b2
    257  78b2				  -	      if	0
    258  78b2				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE_DRAWER
    259  78b2				  -
    260  78b2				  -	      ldy	#CHARACTER_BLANK
    261  78b2				  -	      lda	circle_d+1
    262  78b2				  -			;jsr DrawCircle
    263  78b2				  -			;bcc finCircle
    264  78b2				  -			;lda #TYPE_CIRCLE_DRAWER
    265  78b2				  -			;sta POS_Type
    266  78b2				  -			;jsr InsertObjectStack
    267  78b2				  -finCircle  jmp	NextObject
    268  78b2				  -
    269  78b2				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE_HELPER
    270  78b2				  -
    271  78b2				  -	      lda	INTIM
    272  78b2				  -	      cmp	#SEGTIME_CIRCLE_HELPER
    273  78b2				  -	      bcc	EarlyAbort
    274  78b2				  -
    275  78b2				  -
    276  78b2				  -	      jmp	NextObject	; and die
    277  78b2				  -
    278  78b2				  -
    279  78b2				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE
    280  78b2				  -
    281  78b2				  -	      lda	INTIM
    282  78b2				  -	      cmp	#SEGTIME_CIRCLE
    283  78b2				  -	      bcc	EarlyAbort
    284  78b2				  -
    285  78b2				  -	      clc
    286  78b2				  -	      lda	circle_d
    287  78b2				  -	      adc	#255
    288  78b2				  -	      sta	circle_d
    289  78b2				  -	      bcc	inactiveCircle
    290  78b2				  -
    291  78b2				  -	      inc	circle_d+1
    292  78b2				  -	      lda	circle_d+1
    293  78b2				  -	      cmp	#20
    294  78b2				  -	      beq	circleComplete
    295  78b2				  -			; time to fire off another "ring" of the clearing circle
    296  78b2				  -
    297  78b2				  -			;sta POS_VAR		    ; diameter for helper to use
    298  78b2				  -			;lda #TYPE_CIRCLE_HELPER
    299  78b2				  -			;sta POS_Type
    300  78b2				  -			;jsr InsertObjectStack
    301  78b2				  -
    302  78b2				  -
    303  78b2				  -			; a = radius
    304  78b2				  -
    305  78b2				  -	      ldy	#CHARACTER_BLANK
    306  78b2				  -	      sty	circ_char
    307  78b2				  -
    308  78b2				  -	      lda	circle_d+1
    309  78b2				  -	      sec
    310  78b2				  -	      sbc	#1
    311  78b2				  -	      sta	circ_x
    312  78b2				  -	      eor	#255
    313  78b2				  -	      clc
    314  78b2				  -	      adc	#1
    315  78b2				  -	      sta	circ_scratch	; "d" --> "1-r" in unit terms
    316  78b2				  -
    317  78b2				  -	      lda	#0
    318  78b2				  -	      sta	circ_y
    319  78b2				  -
    320  78b2				  -			;lda circle_d+1		     ; radius
    321  78b2				  -			;lda #TYPE_CIRCLE_DRAWER
    322  78b2				  -			;sta POS_Type
    323  78b2				  -			;jsr InsertObjectStack
    324  78b2				  -
    325  78b2				  -	      ldy	#CHARACTER_BLANK
    326  78b2				  -	      lda	circle_d+1
    327  78b2				  -			;	      sec
    328  78b2				  -			;	      sbc #1
    329  78b2				  -	      jsr	DrawCircle
    330  78b2				  -
    331  78b2				  -			;	      ldy #CHARACTER_STEEL
    332  78b2				  -			;		sty circ_char
    333  78b2				  -	      lda	circle_d+1
    334  78b2				  -	      sta	circ_x
    335  78b2				  -	      eor	#255
    336  78b2				  -	      clc
    337  78b2				  -	      adc	#1
    338  78b2				  -	      sta	circ_scratch	; "d" --> "1-r" in unit terms
    339  78b2				  -
    340  78b2				  -	      lda	#0
    341  78b2				  -	      sta	circ_y
    342  78b2				  -
    343  78b2				  -			;lda circle_d+1		     ; radius
    344  78b2				  -			;lda #TYPE_CIRCLE_DRAWER
    345  78b2				  -			;sta POS_Type
    346  78b2				  -			;jsr InsertObjectStack
    347  78b2				  -
    348  78b2				  -			;	      ldy #CHARACTER_BLANK
    349  78b2				  -			;	      lda circle_d+1
    350  78b2				  -			;	      ;jsr DrawCircle
    351  78b2				  -
    352  78b2				  -
    353  78b2				  -
    354  78b2				  -			;			      inc circle_d+1
    355  78b2				  -			;			      ldy #CHARACTER_STEEL
    356  78b2				  -			;			      lda circle_d+1
    357  78b2				  -			;			      jsr DrawCircle
    358  78b2				  -
    359  78b2				  -inactiveCircle lda	#TYPE_CIRCLE
    360  78b2				  -	      sta	POS_Type
    361  78b2				  -	      jsr	InsertObjectStack
    362  78b2				  -
    363  78b2				  -circleComplete jmp	NextObject
    364  78b2					      endif
    365  78b2
    366  78b2							;---------------------------------------------------------------------------
    367  78b2
    368  78b2		       60	   EarlyAbort4 rts
    369  78b3
      0  78b3					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  78b3		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  78b3					      SUBROUTINE
      3  78b3				   PROCESS_MAN
    371  78b3
    372  78b3		       ad 84 02 	      lda	INTIM	; 3
    373  78b6		       c9 0a		      cmp	#SEGTIME_MAN	; 2
    374  78b8		       90 f8		      bcc	EarlyAbort4	; 2/3 = 7 + 6rts = 13✅ on abort
    375  78ba
    376  78ba		       a9 0d		      lda	#BANK_ManProcess
    377  78bc		       85 c4		      sta	ROM_Bank
    378  78be		       85 3f		      sta	SET_BANK
    379  78c0		       20 a4 f1 	      jsr	ManProcess
    380  78c3
    381  78c3		       a9 ff		      lda	#-1
    382  78c5		       85 91		      sta	TB_CHAR	; pre-set box takeback to NONE
    383  78c7
    384  78c7		       20 3d f9 	      jsr	MovePlayer
    385  78ca
    386  78ca		       a5 a3		      lda	ManMode
    387  78cc		       c9 07		      cmp	#MANMODE_NEXTLEVEL	; kludge
    388  78ce		       b0 08		      bcs	notComplete
    389  78d0		       a5 b7		      lda	BCD_targetsRequired
    390  78d2		       d0 04		      bne	notComplete
    391  78d4		       a9 07		      lda	#MANMODE_NEXTLEVEL
    392  78d6		       85 a3		      sta	ManMode
    393  78d8				   notComplete
    394  78d8
    395  78d8		       a9 03		      lda	#BANK_TrackPlayer	;
    396  78da		       85 3f		      sta	SET_BANK	;
    397  78dc		       20 9d f4 	      jsr	TrackPlayer	;11+145
    398  78df
    399  78df		       a9 00		      lda	#TYPE_MAN	; 2
    400  78e1		       85 8b		      sta	POS_Type	; 3
    401  78e3
    402  78e3		       20 0d f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    403  78e6		       4c 02 f9    gnobj      jmp	NextObject
    404  78e9
    405  78e9							;---------------------------------------------------------------------------
    406  78e9
      0  78e9					      DEFINE_SUBROUTINE	PutCharacterAtXY
      1  78e9		       00 0f	   BANK_PutCharacterAtXY =	_CURRENT_BANK
      2  78e9					      SUBROUTINE
      3  78e9				   PutCharacterAtXY
    408  78e9
    409  78e9							; POS_X	 character location
    410  78e9							; POS_Y
    411  78e9							; POS_VAR	 character to put on board
    412  78e9							; ROM_Bank	 ROM bank to return to
    413  78e9
    414  78e9		       a4 88		      ldy	POS_Y
    415  78eb
    416  78eb		       a9 0d		      lda	#BANK_GetBoardAddressW
    417  78ed		       85 3f		      sta	SET_BANK
    418  78ef		       20 d7 f0 	      jsr	GetBoardAddressW
    419  78f2		       86 3e		      stx	SET_BANK_RAM
    420  78f4
    421  78f4		       a4 87		      ldy	POS_X
    422  78f6		       a5 8c		      lda	POS_VAR
    423  78f8		       91 c2		      sta	(Board_AddressW),y
    424  78fa
    425  78fa		       a5 c4		      lda	ROM_Bank
    426  78fc		       85 3f		      sta	SET_BANK
    427  78fe		       60		      rts
    428  78ff
    429  78ff							;---------------------------------------------------------------------------
    430  78ff
    431  78ff							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    432  78ff							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    433  78ff
    434  78ff							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    435  78ff
    436  78ff							; if the creature dies then jump NextObject
    437  78ff
    438  78ff
    439  78ff		       20 0d f9    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    440  7902
    441  7902		       e6 cc	   NextObject inc	ObjIterator	; 5
    442  7904							;		  dec ObjStackPtr,x		  ; 6
    443  7904		       60		      rts		;jmp ProcessObjStack		  ; 3 = 16	 ; DON'T chain, instead return
    444  7905							; let the segtime stuff do its job!
    445  7905
    446  7905							;---------------------------------------------------------------------------
    447  7905
      0  7905					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  7905		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  7905					      SUBROUTINE
      3  7905				   InsertObjectStackFromRAM
    449  7905
    450  7905		       20 0d f9 	      jsr	InsertObjectStack	;6+76(B)
    451  7908		       a5 c5		      lda	RAM_Bank	;3
    452  790a		       85 3e		      sta	SET_BANK_RAM	;3
    453  790c
    454  790c		       60	   NotEnoughTime rts		;6
    455  790d
    456  790d							;---------------------------------------------------------------------------
    457  790d
      0  790d					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  790d		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  790d					      SUBROUTINE
      3  790d				   InsertObjectStack
    459  790d							; POS_X     x position
    460  790d							; POS_Y     y position
    461  790d							; POS_VAR   direction or other variable
    462  790d							; POS_Type  type of object
    463  790d
    464  790d		       a6 82		      ldx	ObjStackNum	; 3
    465  790f		       bc 3b f9 	      ldy	BankObjStack,x	; 4
    466  7912		       84 3e		      sty	SET_BANK_RAM	; 3
    467  7914		       b4 83		      ldy	ObjStackPtr,x	; 4 = 14
    468  7916
    469  7916
    470  7916		       a5 88		      lda	POS_Y	; 3
    471  7918		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    472  791b		       a5 87		      lda	POS_X	; 3
    473  791d		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    474  7920		       a5 8c		      lda	POS_VAR	; 3
    475  7922		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    476  7925		       a5 8b		      lda	POS_Type	; 3
    477  7927		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    478  792a
    479  792a							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    480  792a							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    481  792a							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    482  792a
    483  792a
    484  792a				  -	      IF	TYPE_MAN != 0
    485  792a				  -	      cmp	#TYPE_MAN	; 2
    486  792a					      ENDIF
    487  792a		       f0 04		      beq	alwaysAllowMan	; 2/3
    488  792c
    489  792c		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    490  792e		       b0 06		      bcs	insertDone	; 2/3= 6    no room -- drop object
    491  7930				   alwaysAllowMan
    492  7930
    493  7930		       98		      tya		; 2
    494  7931		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    495  7934
    496  7934		       f6 83		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    497  7936
    498  7936		       a4 c4	   insertDone ldy	ROM_Bank	; 3
    499  7938		       84 3f		      sty	SET_BANK	; 3
    500  793a
    501  793a				   ManIsDead2
    502  793a
    503  793a
    504  793a
    505  793a		       60		      rts		; 6 = 29
    506  793b
    507  793b							;---------------------------------------------------------------------------
    508  793b
    509  793b		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    510  793d
    511  793d							;---------------------------------------------------------------------------
    512  793d
      0  793d					      DEFINE_SUBROUTINE	MovePlayer
      1  793d		       00 0f	   BANK_MovePlayer =	_CURRENT_BANK
      2  793d					      SUBROUTINE
      3  793d				   MovePlayer
    514  793d
    515  793d		       a4 8a		      ldy	POS_Y_NEW
    516  793f
    517  793f		       a9 0d		      lda	#BANK_GetBoardAddressRW	;2
    518  7941		       85 3f		      sta	SET_BANK	;3
    519  7943		       20 b7 f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    520  7946							;    IF MULTI_BANK_BOARD = YES
    521  7946							;		  stx RAM_Bank
    522  7946							;    ENDIF
    523  7946		       86 3e		      stx	SET_BANK_RAM	; 3
    524  7948
    525  7948		       a4 89		      ldy	POS_X_NEW
    526  794a		       b3 c0		      lax	(Board_AddressR),y
    527  794c
    528  794c		       a9 0d		      lda	#BANK_MoveVecLO
    529  794e		       85 3f		      sta	SET_BANK
    530  7950
    531  7950		       bd 6e f3 	      lda	MoveVecLO,x
    532  7953		       85 db		      sta	MAN_Move
    533  7955		       bd 7d f3 	      lda	MoveVecHI,x
    534  7958		       85 dc		      sta	MAN_Move+1
    535  795a
    536  795a							;    IF MULTI_BANK_BOARD = YES
    537  795a							;		  lda RAM_Bank
    538  795a							;    ELSE
    539  795a		       a9 0d		      lda	#BANK_BOARD
    540  795c							;    ENDIF
    541  795c		       85 3e		      sta	SET_BANK_RAM
    542  795e		       6c db 00 	      jmp	(MAN_Move)
    543  7961
    544  7961							;---------------------------------------------------------------------------
    545  7961
      0  7961					      DEFINE_SUBROUTINE	RecordTakeBackPosition
      1  7961		       00 0f	   BANK_RecordTakeBackPosition =	_CURRENT_BANK
      2  7961					      SUBROUTINE
      3  7961				   RecordTakeBackPosition
    547  7961
    548  7961							; Pass...
    549  7961							; TB_X 	 the man's position before he moved
    550  7961							; TB_Y
    551  7961							; TB_CHAR	 if -1 then there is no box push involved, else..
    552  7961							;		 holds the character that was under the box in its new position
    553  7961							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    554  7961							; TB_PUSHY
    555  7961
    556  7961							; On making a move,
    557  7961							; man's position before move --> TB_X,TB_Y
    558  7961							; TB_CHAR = -1
    559  7961							; IF a box was pushed,
    560  7961							;   TB_CHAR = character under the box's new position (i.e., restoration char)
    561  7961							;   box's new position --> TB_PUSHX, TB_PUSHY
    562  7961							; ENDIF
    563  7961							; BCD_moveCounter++
    564  7961
    565  7961		       a5 bc		      lda	TakebackInhibit
    566  7963		       d0 2e		      bne	noLog
    567  7965
    568  7965		       a9 0e		      lda	#BANK_TAKEBACK
    569  7967		       85 3e		      sta	SET_BANK_RAM
    570  7969
    571  7969		       a6 ba		      ldx	takebackIndex
    572  796b
    573  796b		       a5 8d		      lda	TB_X
    574  796d		       9d 00 14 	      sta	RAM_WRITE+TakeBackPreviousX,x
    575  7970		       a5 8e		      lda	TB_Y
    576  7972		       9d 40 14 	      sta	RAM_WRITE+TakeBackPreviousY,x
    577  7975		       a5 91		      lda	TB_CHAR
    578  7977		       9d 00 15 	      sta	RAM_WRITE+TakeBackPushChar,x
    579  797a
    580  797a							; if TB_CHAR is -1 that means there is no box component, and the following values are random
    581  797a
    582  797a		       a5 8f		      lda	TB_PUSHX
    583  797c		       9d 80 14 	      sta	RAM_WRITE+TakeBackPushX,x
    584  797f		       a5 90		      lda	TB_PUSHY
    585  7981		       9d c0 14 	      sta	RAM_WRITE+TakeBackPushY,x
    586  7984
    587  7984		       a5 c4		      lda	ROM_Bank
    588  7986		       85 3f		      sta	SET_BANK
    589  7988
    590  7988							; fall through
    591  7988
      0  7988					      DEFINE_SUBROUTINE	IncrementMoveCount
      1  7988		       00 0f	   BANK_IncrementMoveCount =	_CURRENT_BANK
      2  7988					      SUBROUTINE
      3  7988				   IncrementMoveCount
    593  7988		       a9 0d		      lda	#BANK_IMC
    594  798a		       85 3f		      sta	SET_BANK
    595  798c		       20 3c f3 	      jsr	IMC
    596  798f		       a5 c4		      lda	ROM_Bank
    597  7991		       85 3f		      sta	SET_BANK
    598  7993
    599  7993		       a9 00	   noLog      lda	#0
    600  7995		       85 bc		      sta	TakebackInhibit
    601  7997		       60		      rts
    602  7998
    603  7998							;---------------------------------------------------------------------------
    604  7998
      0  7998					      DEFINE_SUBROUTINE	MOVE_BLANK
      1  7998		       00 0f	   BANK_MOVE_BLANK =	_CURRENT_BANK
      2  7998					      SUBROUTINE
      3  7998				   MOVE_BLANK
      0  7998					      DEFINE_SUBROUTINE	MOVE_SOIL
      1  7998		       00 0f	   BANK_MOVE_SOIL =	_CURRENT_BANK
      2  7998					      SUBROUTINE
      3  7998				   MOVE_SOIL
      0  7998					      DEFINE_SUBROUTINE	MOVE_TARGET
      1  7998		       00 0f	   BANK_MOVE_TARGET =	_CURRENT_BANK
      2  7998					      SUBROUTINE
      3  7998				   MOVE_TARGET
    608  7998
    609  7998		       8a		      txa		; character man will be standing on
    610  7999		       48		      pha
    611  799a
    612  799a		       a9 00		      lda	#ANIMATION_WALK_ID
    613  799c		       c5 a8		      cmp	ManAnimationID
    614  799e		       f0 0e		      beq	walkingOK
    615  79a0		       85 a8		      sta	ManAnimationID
      0  79a2					      LOAD_ANIMATION	Animation_WALK
      1  79a2		       a9 0e		      lda	#<Animation_WALK
      2  79a4		       85 9c		      sta	animation
      3  79a6		       a9 f0		      lda	#>Animation_WALK
      4  79a8		       85 9d		      sta	animation+1
      5  79aa		       a9 00		      lda	#0
      6  79ac		       85 9e		      sta	animation_delay
    617  79ae				   walkingOK
    618  79ae
    619  79ae		       a5 9f		      lda	ManX
    620  79b0		       85 87		      sta	POS_X
    621  79b2		       85 8d		      sta	TB_X
    622  79b4		       a5 a0		      lda	ManY
    623  79b6		       85 88		      sta	POS_Y
    624  79b8		       85 8e		      sta	TB_Y
    625  79ba		       20 e9 f8 	      jsr	PutCharacterAtXY	; RESTORE (previous XY) under-man character
    626  79bd
    627  79bd		       a5 89		      lda	POS_X_NEW
    628  79bf		       85 9f		      sta	ManX
    629  79c1		       85 87		      sta	POS_X
    630  79c3		       a5 8a		      lda	POS_Y_NEW
    631  79c5		       85 a0		      sta	ManY
    632  79c7		       85 88		      sta	POS_Y
    633  79c9		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    634  79cb		       85 8c		      sta	POS_VAR
    635  79cd		       20 e9 f8 	      jsr	PutCharacterAtXY
    636  79d0
    637  79d0							; TB_X 	 the man's position before he moved
    638  79d0							; TB_Y
    639  79d0							; TB_CHAR	 if -1 then there is no box push involved, else..
    640  79d0							;		 holds the character that was under the box in its new position
    641  79d0							;		 this can be inferred by the box character (ONTARGET)
    642  79d0							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    643  79d0							; TB_PUSHY
    644  79d0
    645  79d0		       20 61 f9 	      jsr	RecordTakeBackPosition
    646  79d3
    647  79d3		       68		      pla
    648  79d4		       85 8c		      sta	POS_VAR	; save 'restore' character
    649  79d6
    650  79d6		       a9 00	   MOVE_GENERIC lda	#0	; 2
    651  79d8		       85 a6		      sta	ManPushCounter	; 3
    652  79da		       60		      rts		; 6 = 11
    653  79db
    654  79db							;---------------------------------------------------------------------------
    655  79db							; takeback buffer empty - flash red
    656  79db
    657  79db		       a5 80	   noMovesToTake lda	Platform
    658  79dd		       18		      clc
    659  79de		       69 04		      adc	#4	; reds
    660  79e0		       85 c7		      sta	ColourFlash
    661  79e2		       a9 06		      lda	#6
    662  79e4		       85 c6		      sta	ColourTimer
    663  79e6		       60		      rts
    664  79e7
    665  79e7							;---------------------------------------------------------------------------
    666  79e7
      0  79e7					      DEFINE_SUBROUTINE	MOVE_BOX
      1  79e7		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  79e7					      SUBROUTINE
      3  79e7				   MOVE_BOX
    668  79e7
    669  79e7		       a2 00		      ldx	#CHARACTER_BLANK	; restoration character
    670  79e9		       a9 0d		      lda	#BANK_PushBox
    671  79eb		       85 3f		      sta	SET_BANK
    672  79ed		       4c e7 f0 	      jmp	PushBox
    673  79f0
      0  79f0					      DEFINE_SUBROUTINE	MOVE_BOX_ON_TARGET
      1  79f0		       00 0f	   BANK_MOVE_BOX_ON_TARGET =	_CURRENT_BANK
      2  79f0					      SUBROUTINE
      3  79f0				   MOVE_BOX_ON_TARGET
    675  79f0
    676  79f0		       a2 03		      ldx	#CHARACTER_TARGET	; restoration character
    677  79f2		       a9 0d		      lda	#BANK_PushBox
    678  79f4		       85 3f		      sta	SET_BANK
    679  79f6		       4c e7 f0 	      jmp	PushBox
    680  79f9
    681  79f9							;---------------------------------------------------------------------------
    682  79f9
      0  79f9					      DEFINE_SUBROUTINE	takebackRestoreEarlierPosition
      1  79f9		       00 0f	   BANK_takebackRestoreEarlierPosition =	_CURRENT_BANK
      2  79f9					      SUBROUTINE
      3  79f9				   takebackRestoreEarlierPosition
    684  79f9
    685  79f9		       e6 bc		      inc	TakebackInhibit	; non-zero
    686  79fb
    687  79fb							; on reverting a move
    688  79fb							; IF BCD_moveCounter > 0
    689  79fb							;   BCD_moveCounter--
    690  79fb							;   IF TakeBackPushChar != -1
    691  79fb							;	 //restore the character under box (and remove box)
    692  79fb							;	 board[TakeBackPreviousX,TakeBackPreviousY] = TakeBackPushChar
    693  79fb							;   ENDIF
    694  79fb							; // We will "fix" any box going back on the board through the man's restoration char
    695  79fb							; board[ManX,ManY] = POS_VAR
    696  79fb							; POS_VAR = board[TakeBackX,TakeBackY]
    697  79fb							; board[TakeBackX,TakeBackY] = MANOCCUPIED
    698  79fb							; ManX,ManY = TakeBackX, TakeBackY
    699  79fb
    700  79fb		       a6 ba		      ldx	takebackIndex
    701  79fd		       e4 bb		      cpx	takebackBaseIndex
    702  79ff		       f0 da		      beq	noMovesToTake
    703  7a01
    704  7a01		       ca		      dex
    705  7a02		       8a		      txa
    706  7a03		       29 3f		      and	#TAKEBACK_MASK
    707  7a05		       85 ba		      sta	takebackIndex
    708  7a07		       aa		      tax
    709  7a08
    710  7a08		       f8		      sed
    711  7a09		       38		      sec
    712  7a0a		       a5 b8		      lda	BCD_moveCounter
    713  7a0c		       e9 01		      sbc	#1
    714  7a0e		       85 b8		      sta	BCD_moveCounter
    715  7a10		       a5 b9		      lda	BCD_moveCounter+1
    716  7a12		       e9 00		      sbc	#0
    717  7a14		       85 b9		      sta	BCD_moveCounter+1
    718  7a16		       d8		      cld
    719  7a17
    720  7a17				  -	      if	0
    721  7a17				  -	      lda	Platform
    722  7a17				  -	      clc
    723  7a17				  -	      adc	#8
    724  7a17				  -	      sta	ColourFlash	; yellow flash
    725  7a17				  -	      lda	#3
    726  7a17				  -	      sta	ColourTimer
    727  7a17					      endif
    728  7a17
    729  7a17		       a9 0e		      lda	#BANK_TAKEBACK
    730  7a19		       85 3e		      sta	SET_BANK_RAM
    731  7a1b
    732  7a1b							; TB_X 	 the man's position before he moved
    733  7a1b							; TB_Y
    734  7a1b							; TB_CHAR	 if -1 then there is no box push involved, else..
    735  7a1b							;		 holds the character that was under the box in its new position
    736  7a1b							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    737  7a1b							; TB_PUSHY
    738  7a1b
    739  7a1b							;	 //restore the character under box (and remove box)
    740  7a1b							;	 board[TakeBackPreviousX,TakeBackPreviousY] = TakeBackPushChar
    741  7a1b
    742  7a1b		       a5 8c		      lda	POS_VAR
    743  7a1d		       48		      pha
    744  7a1e
    745  7a1e		       a6 ba		      ldx	takebackIndex
    746  7a20		       bd 00 11 	      lda	TakeBackPushChar,x
    747  7a23		       30 29		      bmi	noPushInvolved	; -1 = no box
    748  7a25
    749  7a25		       85 8c		      sta	POS_VAR
    750  7a27		       c9 03		      cmp	#CHARACTER_TARGET
    751  7a29		       f0 04		      beq	isaTarget
    752  7a2b		       c9 04		      cmp	#CHARACTER_TARGET2
    753  7a2d		       d0 03		      bne	notTarget1
    754  7a2f		       20 c3 fc    isaTarget  jsr	RegisterTarget
    755  7a32				   notTarget1
    756  7a32
    757  7a32
    758  7a32		       bd 80 10 	      lda	TakeBackPushX,x
    759  7a35		       85 87		      sta	POS_X
    760  7a37		       bd c0 10 	      lda	TakeBackPushY,x
    761  7a3a		       85 88		      sta	POS_Y
    762  7a3c
    763  7a3c		       20 e9 f8 	      jsr	PutCharacterAtXY	; fixup BOX!
    764  7a3f
    765  7a3f		       68		      pla
    766  7a40		       f0 07		      beq	blnkre
    767  7a42		       20 cd fc 	      jsr	DeRegisterTarget
    768  7a45		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    769  7a47		       d0 02		      bne	skls
    770  7a49		       a9 02	   blnkre     lda	#CHARACTER_BOX
    771  7a4b		       85 8c	   skls       sta	POS_VAR
    772  7a4d
    773  7a4d		       48		      pha
    774  7a4e
    775  7a4e		       68	   noPushInvolved pla		; man's replacement char
    776  7a4f		       85 8c		      sta	POS_VAR
    777  7a51
    778  7a51							; // We will "fix" any box going back on the board through the man's restoration char
    779  7a51							; board[ManX,ManY] = POS_VAR
    780  7a51							; POS_VAR = board[TakeBackX,TakeBackY]
    781  7a51							; board[TakeBackX,TakeBackY] = MANOCCUPIED
    782  7a51							; ManX,ManY = TakeBackX, TakeBackY
    783  7a51
    784  7a51		       a5 9f		      lda	ManX
    785  7a53		       85 87		      sta	POS_X
    786  7a55		       a5 a0		      lda	ManY
    787  7a57		       85 88		      sta	POS_Y
    788  7a59		       20 e9 f8 	      jsr	PutCharacterAtXY	; put what man was on... back
    789  7a5c
    790  7a5c
    791  7a5c		       a9 0e		      lda	#BANK_TAKEBACK
    792  7a5e		       85 3e		      sta	SET_BANK_RAM
    793  7a60
    794  7a60		       a6 ba		      ldx	takebackIndex
    795  7a62		       bd 00 10 	      lda	TakeBackPreviousX,x
    796  7a65		       85 89		      sta	POS_X_NEW
    797  7a67		       85 9f		      sta	ManX
    798  7a69		       bd 40 10 	      lda	TakeBackPreviousY,x
    799  7a6c		       85 8a		      sta	POS_Y_NEW
    800  7a6e		       85 a0		      sta	ManY
    801  7a70
    802  7a70							; Grab the character from the board at man's location and use as "restore character" for man
    803  7a70							; POS_VAR = board[takebackx,takebacky]
    804  7a70
    805  7a70		       a9 0d		      lda	#BANK_GetBoardAddressR
    806  7a72		       85 3f		      sta	SET_BANK
    807  7a74		       a4 8a		      ldy	POS_Y_NEW
    808  7a76		       20 ca f0 	      jsr	GetBoardAddressR
    809  7a79		       85 3e		      sta	SET_BANK_RAM
    810  7a7b
    811  7a7b		       a4 89		      ldy	POS_X_NEW
    812  7a7d		       b1 c0		      lda	(Board_AddressR),y
    813  7a7f							;pha
    814  7a7f							;lda #CHARACTER_MANOCCUPIED
    815  7a7f							;sta POS_VAR
    816  7a7f							;jsr PutCharacterAtXY		 ????
    817  7a7f							;pla
    818  7a7f		       85 8c		      sta	POS_VAR
    819  7a81
    820  7a81		       a5 c4		      lda	ROM_Bank
    821  7a83		       85 3f		      sta	SET_BANK
    822  7a85
    823  7a85		       60	   timeExit   rts
    824  7a86
    825  7a86							;---------------------------------------------------------------------------
    826  7a86
      0  7a86					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7a86		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7a86					      SUBROUTINE
      3  7a86				   StealCharDraw
    828  7a86
    829  7a86		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    830  7a88		       85 3e		      sta	SET_BANK_RAM	; 3
    831  7a8a		       a4 81		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    832  7a8c		       10 35		      bpl	EnterStealCharDraw	; 2(3) = 10(11)
    833  7a8e
    834  7a8e				   ExitStealCharDraw
    835  7a8e
    836  7a8e							; fall through...
    837  7a8e
    838  7a8e							;---------------------------------------------------------------------------
    839  7a8e
      0  7a8e					      DEFINE_SUBROUTINE	TimeSlice
      1  7a8e		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7a8e					      SUBROUTINE
      3  7a8e				   TimeSlice
    841  7a8e
    842  7a8e							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    843  7a8e							; going ahead if there's insufficient time. This allows the previous character drawing to
    844  7a8e							; be much smaller in time, as they don't have to include the timeslice code overhead.
    845  7a8e
    846  7a8e		       ad 84 02 	      lda	INTIM	; 4
    847  7a91		       c9 02		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    848  7a93		       90 f0		      bcc	timeExit	; 2(3)
    849  7a95							; @0✅
    850  7a95
    851  7a95							; Uses the phase variable to vector to the correct processing code for the given timeslice
    852  7a95							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    853  7a95							; it should increment ScreenDrawPhase.
    854  7a95
    855  7a95							; Switched-in bank(s) are undefined after this function is called!
    856  7a95
    857  7a95		       a9 03		      lda	#BANK_TS_PhaseVectorLO	; 2
    858  7a97		       85 3f		      sta	SET_BANK	; 3 = 5
    859  7a99
    860  7a99		       a6 86		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    861  7a9b		       bd 24 f5 	      lda	TS_PhaseVectorLO,x	; 4
    862  7a9e		       85 db		      sta	TS_Vector	; 3
    863  7aa0		       bd 29 f5 	      lda	TS_PhaseVectorHI,x	; 4
    864  7aa3		       85 dc		      sta	TS_Vector+1	; 3 = 17
    865  7aa5
    866  7aa5		       bd 2e f5 	      lda	TS_PhaseBank,x	; 4
    867  7aa8		       85 3f		      sta	SET_BANK	; 3 = 7	 switch bank
    868  7aaa
    869  7aaa		       6c db 00 	      jmp	(TS_Vector)	; 5 = 31✅	  vector to timeslice handler
    870  7aad
    871  7aad							;---------------------------------------------------------------------------
    872  7aad
    873  7aad
    874  7aad				   DrawAnother		;344✅SCD_QUICK
    875  7aad							;676✅SCD_SLOW
    876  7aad
    877  7aad
    878  7aad							; add 44✅ cycles for the following in the case where there is something to draw
    879  7aad							; but no time to do it. As this is executed after EVERY type of draw, then this
    880  7aad							; is the base "extra" cost to add to each draw
    881  7aad
    882  7aad		       00 35	   CYCLES_DRAWANOTHER =	53	;✅
    883  7aad
    884  7aad		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    885  7aaf		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    886  7ab1
    887  7ab1		       a4 81		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    888  7ab3
    889  7ab3		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    890  7ab6		       bd a0 f0 	      lda	ScreenBuffer,x	; 4	     new character to draw
    891  7ab9		       29 7f		      and	#~128	; 2
    892  7abb		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    893  7abe
    894  7abe		       88		      dey		; 2
    895  7abf		       84 81		      sty	DrawStackPointer	; 3	     one less to draw
    896  7ac1		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7    NOTE1: (3)+(15exit) -->45✅ <CYCLES_DRAWANOTHER)
    897  7ac3							; => 29
    898  7ac3
    899  7ac3				   EnterStealCharDraw		; @11✅ from initial StealCharDraw call
    900  7ac3							; RAM bank MUST be at BANK_DRAW_BUFFERS
    901  7ac3
    902  7ac3		       ad 84 02 	      lda	INTIM	; 4
    903  7ac6		       c9 03		      cmp	#SEGTIME_SCD_MIN	; 2
    904  7ac8		       90 c4		      bcc	ExitStealCharDraw	; 2(3) = 8    ((9)+(15exit) IF EXITING HERE, from DrawAnother... 53✅)
    905  7aca							;		else exit from StealCharDraw ... 26✅
    906  7aca							; @0✅
    907  7aca
    908  7aca		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    909  7acd		       bc a0 f0 	      ldy	ScreenBuffer,x	; 4 =	8✅  new character to draw
    910  7ad0
    911  7ad0		       bd 00 f2 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
    912  7ad3		       85 3e		      sta	SET_BANK_RAM	; 3
    913  7ad5		       4c 41 f1 	      jmp	StealPart3	; 3 = 10✅  --> 18✅ cycles after check for SEGTIME_SCD_MIN
    914  7ad8
    915  7ad8							;---------------------------------------------------------------------------
    916  7ad8
    917  7ad8		       60	   skipOffscreen rts
    918  7ad9
      0  7ad9					      DEFINE_SUBROUTINE	writePlayerFrame
      1  7ad9		       00 0f	   BANK_writePlayerFrame =	_CURRENT_BANK
      2  7ad9					      SUBROUTINE
      3  7ad9				   writePlayerFrame
    920  7ad9
    921  7ad9		       38		      sec
    922  7ada		       a5 a0		      lda	ManY
    923  7adc		       e5 98		      sbc	BoardScrollY
    924  7ade		       c9 08		      cmp	#SCREEN_LINES	; todo - use const
    925  7ae0		       b0 f6		      bcs	skipOffscreen
    926  7ae2		       85 df		      sta	bank	; character line (and hence bank) of player position
    927  7ae4
    928  7ae4		       a5 80		      lda	Platform
    929  7ae6		       29 02		      and	#%10
    930  7ae8		       0a		      asl
    931  7ae9		       0a		      asl
    932  7aea		       65 ce		      adc	ethnic
    933  7aec		       85 e0		      sta	ethnicity
    934  7aee
    935  7aee
    936  7aee							; todo - compare with last + frame and skip if same
    937  7aee
    938  7aee		       a9 0a		      lda	#PLAYER_FRAMES
    939  7af0		       85 3f		      sta	SET_BANK
    940  7af2
    941  7af2		       a5 9e		      lda	animation_delay
    942  7af4		       f0 0f		      beq	getDelay	; FIRST usage
    943  7af6		       c6 9e		      dec	animation_delay
    944  7af8		       d0 11		      bne	nextAnimation2	; just get shape
    945  7afa
    946  7afa		       18	   nextAptr   clc
    947  7afb		       a5 9c		      lda	animation
    948  7afd		       69 02		      adc	#2
    949  7aff		       85 9c		      sta	animation
    950  7b01		       90 02		      bcc	ahiok
    951  7b03		       e6 9d		      inc	animation+1
    952  7b05				   ahiok
    953  7b05		       a0 01	   getDelay   ldy	#1
    954  7b07		       b1 9c		      lda	(animation),y
    955  7b09		       85 9e		      sta	animation_delay
    956  7b0b		       a0 00	   nextAnimation2 ldy	#0
    957  7b0d		       b1 9c		      lda	(animation),y
    958  7b0f		       c9 80		      cmp	#JUMP
    959  7b11		       f0 0d		      beq	aJump
    960  7b13		       c9 40		      cmp	#FLIP
    961  7b15		       d0 18		      bne	notFlip
    962  7b17
    963  7b17		       a5 a4		      lda	ManLastDirection
    964  7b19		       49 08		      eor	#%1000
    965  7b1b		       85 a4		      sta	ManLastDirection
    966  7b1d		       4c fa fa 	      jmp	nextAptr
    967  7b20
    968  7b20							; it's a jump
    969  7b20		       a4 9e	   aJump      ldy	animation_delay	; actually animation ID :)
    970  7b22		       b9 00 f0 	      lda	ANIM_TABLE,y
    971  7b25		       85 9c		      sta	animation
    972  7b27		       b9 01 f0 	      lda	ANIM_TABLE+1,y
    973  7b2a		       85 9d		      sta	animation+1
    974  7b2c		       4c 05 fb 	      jmp	getDelay
    975  7b2f
    976  7b2f		       a8	   notFlip    tay
    977  7b30		       b9 94 f4 	      lda	FRAME_PTR_LO,y
    978  7b33		       85 db		      sta	frame_ptr
    979  7b35		       b9 a9 f4 	      lda	FRAME_PTR_HI,y
    980  7b38		       85 dc		      sta	frame_ptr+1
    981  7b3a
    982  7b3a		       b9 be f4 	      lda	COLOUR_PTR_LO,y
    983  7b3d		       85 dd		      sta	colour_ptr
    984  7b3f		       b9 d3 f4 	      lda	COLOUR_PTR_HI,y
    985  7b42		       85 de		      sta	colour_ptr+1
    986  7b44
    987  7b44		       18		      clc
    988  7b45		       a0 17		      ldy	#23
    989  7b47				   CopySpriteToBank
    990  7b47		       a9 0a		      lda	#PLAYER_FRAMES
    991  7b49		       85 3f		      sta	SET_BANK
    992  7b4b		       b1 db		      lda	(frame_ptr),y
    993  7b4d		       48		      pha
    994  7b4e
    995  7b4e							; The colours for the sprites are copied to the row bank's colour data. The frames contain
    996  7b4e							; colour *indexes*. These indexes are modified by the *base* which indicates both the
    997  7b4e							; system NTSC/PAL along with the "visual identity" (i.e., colour/race). That is used to
    998  7b4e							; lookup a colour conversion which FINALLY gives us the correct colour to use for the line.
    999  7b4e
   1000  7b4e							; ethnicity * 16 + PALNTSC * 8
   1001  7b4e
   1002  7b4e		       b1 dd		      lda	(colour_ptr),y
   1003  7b50		       65 e0		      adc	ethnicity	; colour base
   1004  7b52		       aa		      tax
   1005  7b53		       a5 df		      lda	bank
   1006  7b55		       85 3e		      sta	SET_BANK_RAM
   1007  7b57		       bd e6 f2 	      lda	EthnicityColourPalette,x
   1008  7b5a		       99 af f4 	      sta	SpriteColourRED+RAM_WRITE,y
   1009  7b5d		       68		      pla
   1010  7b5e		       99 ce f6 	      sta	PLAYER_RIGHT0+RAM_WRITE,y
   1011  7b61		       88		      dey
   1012  7b62		       10 e3		      bpl	CopySpriteToBank
   1013  7b64
   1014  7b64		       60		      rts
   1015  7b65
   1016  7b65							;---------------------------------------------------------------------------
   1017  7b65
      0  7b65					      DEFINE_SUBROUTINE	DrawFullScreenMain	;=2484[-89]
      1  7b65		       00 0f	   BANK_DrawFullScreenMain =	_CURRENT_BANK
      2  7b65					      SUBROUTINE
      3  7b65				   DrawFullScreenMain
   1019  7b65
   1020  7b65							; Check the screen for all those characters that need to be redrawn
   1021  7b65							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
   1022  7b65							; the drawflags array is different to the ScreenBuffer array entry, then the
   1023  7b65							; screenbuffer will need redrawing.
   1024  7b65
   1025  7b65				   CopyRow2
   1026  7b65
   1027  7b65							;    IF MULTI_BANK_BOARD = YES
   1028  7b65							;		  lda BDF_BoardBank		  ; 3
   1029  7b65							;    ELSE
   1030  7b65		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
   1031  7b67							;    ENDIF
   1032  7b67		       85 3e		      sta	SET_BANK_RAM	; 3
   1033  7b69		       b3 df		      lax	(BDF_BoardAddress),y	; 5
   1034  7b6b		       9a		      txs		; 2
   1035  7b6c		       b3 e1		      lax	(BDF_BoardAddress2),y	; 5(= 18[-1])
   1036  7b6e
   1037  7b6e		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
   1038  7b70		       85 3e		      sta	SET_BANK_RAM	; 3
   1039  7b72		       bd cc f1 	      lda	CharReplacement,x	; 4
   1040  7b75		       91 dd		      sta	(BDF_DrawFlagAddress2),y	; 6
   1041  7b77		       ba		      tsx		; 2
   1042  7b78		       bd cc f1 	      lda	CharReplacement,x	; 4
   1043  7b7b		       91 db		      sta	(BDF_DrawFlagAddress),y	; 6(= 27)
   1044  7b7d
   1045  7b7d		       88		      dey		; 2
   1046  7b7e		       10 e5		      bpl	CopyRow2	; 2/3=49/50[-1]
   1047  7b80							; total: 5*(50[-1])-1 = 244 *OR*  249 (MB)
   1048  7b80
   1049  7b80		       a7 e4		      lax	DHS_Line	; 3
   1050  7b82		       f0 07		      beq	.exitCopy	; 2/3= 5/6
   1051  7b84
   1052  7b84		       a0 0d		      ldy	#BANK_DrawScreenRowPreparation	;2
   1053  7b86		       84 3f		      sty	SET_BANK	; 3
   1054  7b88		       4c f9 f2 	      jmp	DrawScreenRowPreparation	;55[-7] = 60[-7]
   1055  7b8b
   1056  7b8b							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
   1057  7b8b
   1058  7b8b
      0  7b8b					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7b8b					      LIST	ON
   1060  7b8b
   1061  7b8b		       a6 e5	   .exitCopy  ldx	DHS_Stack	; 3
   1062  7b8d		       9a		      txs		; 2
   1063  7b8e
   1064  7b8e							; fall through
   1065  7b8e
      0  7b8e					      DEFINE_SUBROUTINE	BuildDrawStack	; @31✅
      1  7b8e		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7b8e					      SUBROUTINE
      3  7b8e				   BuildDrawStack
   1067  7b8e
   1068  7b8e		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
   1069  7b90		       85 3e		      sta	SET_BANK_RAM	; 3
   1070  7b92		       4c f1 f0 	      jmp	DrawStackUpdate	; 3
   1071  7b95
   1072  7b95							; => @39 at DrawStackUpdate
   1073  7b95
   1074  7b95							;---------------------------------------------------------------------------
   1075  7b95
      0  7b95					      DEFINE_SUBROUTINE	DrawAIntoStack	; @31✅
      1  7b95		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7b95					      SUBROUTINE
      3  7b95				   DrawAIntoStack
   1077  7b95
   1078  7b95		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
   1079  7b97		       85 3e		      sta	SET_BANK_RAM	; 3
   1080  7b99		       4c 19 f1 	      jmp	DrawIntoStack	; 3
   1081  7b9c
   1082  7b9c							; ==>39✅ @DrawIntoStack
   1083  7b9c
   1084  7b9c
   1085  7b9c
   1086  7b9c
   1087  7b9c							;---------------------------------------------------------------------------
   1088  7b9c
   1089  7b9c
      0  7b9c					      DEFINE_SUBROUTINE	Reset
      1  7b9c		       00 0f	   BANK_Reset =	_CURRENT_BANK
      2  7b9c					      SUBROUTINE
      3  7b9c				   Reset
   1091  7b9c
      0  7b9c					      CLEAN_START
      1  7b9c		       78		      sei
      2  7b9d		       d8		      cld
      3  7b9e
      4  7b9e		       a2 00		      ldx	#0
      5  7ba0		       8a		      txa
      6  7ba1		       a8		      tay
      7  7ba2		       ca	   .CLEAR_STACK dex
      8  7ba3		       9a		      txs
      9  7ba4		       48		      pha
     10  7ba5		       d0 fb		      bne	.CLEAR_STACK
     11  7ba7
   1093  7ba7
   1094  7ba7							;lda #2
   1095  7ba7							;sta VSYNC
   1096  7ba7							;lda #%01000010		  ; bit6 is not required
   1097  7ba7							;sta VBLANK			  ; end of screen - enter blanking
   1098  7ba7
   1099  7ba7							; Scoring bank is copied once (not per game, not per level...)
   1100  7ba7							; otherwise non-SaveKey high score gets zapped
   1101  7ba7
   1102  7ba7		       a2 02		      ldx	#ROM_SHADOW_OF_BANK_SCORING
   1103  7ba9		       a0 09		      ldy	#BANK_SCORING
   1104  7bab		       20 ba fc 	      jsr	CopyROM2RAM_F000
   1105  7bae
   1106  7bae				   Restart		; go here on RESET + SELECT
   1107  7bae
   1108  7bae							; breakpoint was not hit/detected!!!
   1109  7bae
      0  7bae					      DEFINE_SUBROUTINE	Title
      1  7bae		       00 0f	   BANK_Title =	_CURRENT_BANK
      2  7bae					      SUBROUTINE
      3  7bae				   Title
   1111  7bae		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
   1112  7bb0		       9a		      txs
   1113  7bb1
   1114  7bb1							; temporary vars from title screen are used to init level
   1115  7bb1		       a9 03		      lda	#BANK_Cart_Init	; 2
   1116  7bb3		       85 3f		      sta	SET_BANK	; 3
   1117  7bb5		       20 c8 f3 	      jsr	Cart_Init	; 6+x
   1118  7bb8
   1119  7bb8
   1120  7bb8							;---------------------------------------------------------------------------
   1121  7bb8
   1122  7bb8
   1123  7bb8		       f0 00	   SEGMENT_DECODE_LEVEL_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
   1124  7bb8
   1125  7bb8		       a2 03		      ldx	#BANK_DECODE_LEVEL_SHADOW
   1126  7bba		       a0 0a		      ldy	#BANK_DECODE_LEVEL
   1127  7bbc		       20 ba fc 	      jsr	CopyROM2RAM_F000
   1128  7bbf
   1129  7bbf
   1130  7bbf							;---------------------------------------------------------------------------
   1131  7bbf							; Once-only game initialisation goes here...
   1132  7bbf							; now we have two players so things get a bit tricky
   1133  7bbf
   1134  7bbf		       a9 09		      lda	#BANK_SCORING
   1135  7bc1		       85 3e		      sta	SET_BANK_RAM
   1136  7bc3		       20 63 f3 	      jsr	GameInitialise
   1137  7bc6
   1138  7bc6
   1139  7bc6							;---------------------------------------------------------------------------
   1140  7bc6
------- FILE sound/intro1_init.asm LEVEL 3 PASS 3
      0  7bc6					      include	"sound/intro1_init.asm"
      1  7bc6							; TIATracker music player
      2  7bc6							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7bc6							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7bc6							; Email: andre.wichmann@gmx.de
      5  7bc6							;
      6  7bc6							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7bc6							; you may not use this file except in compliance with the License.
      8  7bc6							; You may obtain a copy of the License at
      9  7bc6							;
     10  7bc6							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7bc6							;
     12  7bc6							; Unless required by applicable law or agreed to in writing, software
     13  7bc6							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7bc6							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7bc6							; See the License for the specific language governing permissions and
     16  7bc6							; limitations under the License.
     17  7bc6
     18  7bc6							; Song author: 
     19  7bc6							; Song name: 
     20  7bc6
     21  7bc6							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7bc6
     23  7bc6							; =====================================================================
     24  7bc6							; Initialize music.
     25  7bc6							; Set tt_cur_pat_index_c0/1 to the indexes of the first patterns from
     26  7bc6							; tt_SequenceTable for each channel.
     27  7bc6							; Set tt_timer and tt_cur_note_index_c0/1 to 0.
     28  7bc6							; All other variables can start with any value.
     29  7bc6							; =====================================================================
     30  7bc6		       a9 00		      lda	#0
     31  7bc8		       85 d1		      sta	tt_cur_pat_index_c0
     32  7bca		       a9 05		      lda	#5
     33  7bcc		       85 d2		      sta	tt_cur_pat_index_c1
     34  7bce							; the rest should be 0 already from startup code. If not,
     35  7bce							; set the following variables to 0 manually:
     36  7bce							; - tt_timer
     37  7bce							; - tt_cur_pat_index_c0
     38  7bce							; - tt_cur_pat_index_c1
     39  7bce							; - tt_cur_note_index_c0
     40  7bce							; - tt_cur_note_index_c1
     41  7bce
------- FILE BANK_FIXED.asm
   1142  7bce
      0  7bce					      SET_PLATFORM
      1  7bce
      2  7bce
      3  7bce
      4  7bce
      5  7bce		       ad 82 02 	      lda	SWCHB
      6  7bd1		       2a		      rol
      7  7bd2		       2a		      rol
      8  7bd3		       2a		      rol
      9  7bd4		       29 03		      and	#%11
     10  7bd6		       49 02		      eor	#PAL
     11  7bd8		       85 80		      sta	Platform
   1144  7bda
   1145  7bda		       a9 0b		      lda	#BANK_TitleScreen
   1146  7bdc		       85 3f		      sta	SET_BANK
   1147  7bde		       20 00 f0 	      jsr	TitleSequence
   1148  7be1
   1149  7be1				   RestartLevelNextPlayer
   1150  7be1
   1151  7be1
   1152  7be1
   1153  7be1							; a player has lost a life.
   1154  7be1							; store his vars, swap to other player, continue
   1155  7be1
   1156  7be1							;lda #BANK_SCORING
   1157  7be1							;sta SET_BANK_RAM
   1158  7be1							;jsr SwapPlayers
   1159  7be1
   1160  7be1		       a9 03		      lda	#BANK_SwapPlayersGeneric
   1161  7be3		       85 3f		      sta	SET_BANK
   1162  7be5		       20 0b f4 	      jsr	SwapPlayersGeneric
   1163  7be8
   1164  7be8				   NextLevelLevel
   1165  7be8				   skipDemoCheck
   1166  7be8
   1167  7be8		       a9 0c		      lda	#BANK_LevelScreen
   1168  7bea		       85 3f		      sta	SET_BANK
   1169  7bec		       20 00 f0 	      jsr	LevelSequence
   1170  7bef
   1171  7bef							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
   1172  7bef							; including those for general systems function. But NOT those which do not need re-initialising between
   1173  7bef							; levels.
   1174  7bef		       a9 03		      lda	#BANK_LevelInit	; 2
   1175  7bf1		       85 3f		      sta	SET_BANK	; 3
   1176  7bf3		       20 4b f4 	      jsr	LevelInit	; 6+x
   1177  7bf6
   1178  7bf6		       a9 0a		      lda	#BANK_DECODE_LEVEL
   1179  7bf8		       85 3e		      sta	SET_BANK_RAM
   1180  7bfa		       20 58 f2 	      jsr	UnpackLevel
   1181  7bfd
   1182  7bfd							; TODO now we KNOW the width, we can set the top left accordingly and re-unpack
   1183  7bfd
   1184  7bfd		       a9 18		      lda	#SIZE_BOARD_X
   1185  7bff		       85 96		      sta	BoardLimit_Width
   1186  7c01		       a9 14		      lda	#SIZE_BOARD_Y
   1187  7c03		       85 97		      sta	BoardLimit_Height
   1188  7c05
   1189  7c05							; Setup player animation and scroll limits.
   1190  7c05							; Mangle the board colours based on level
   1191  7c05
   1192  7c05		       a9 03		      lda	#BANK_CreateCreatures	; 2
   1193  7c07		       85 3f		      sta	SET_BANK	; 3
   1194  7c09		       20 14 f4 	      jsr	CreateCreatures	; 6+x
   1195  7c0c
   1196  7c0c							; Setup the various digit and display pointers
   1197  7c0c							; Grab current player's score/level from backup
   1198  7c0c
   1199  7c0c		       a9 09		      lda	#BANK_SCORING
   1200  7c0e		       85 3e		      sta	SET_BANK_RAM
   1201  7c10		       20 87 f2 	      jsr	GeneralScoringSetups
   1202  7c13							;lda ROM_Bank
   1203  7c13							;sta SET_BANK
   1204  7c13
   1205  7c13							; copy the screen draw ROM shadow to RAM
   1206  7c13
   1207  7c13		       a0 07		      ldy	#SCREEN_LINES-1
   1208  7c15		       a2 00	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
   1209  7c17		       20 ba fc 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
   1210  7c1a		       20 71 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
   1211  7c1d		       88		      dey
   1212  7c1e		       10 f5		      bpl	CopyScreenBanks
   1213  7c20
   1214  7c20		       a2 01		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
   1215  7c22		       a0 08		      ldy	#BANK_DRAW_BUFFERS
   1216  7c24		       20 3d f0 	      jsr	CopyROMShadowToRAM_F000
   1217  7c27
   1218  7c27							;---------------------------------------------------------------------------
   1219  7c27
   1220  7c27					      IF	WAIT_FOR_INITIAL_DRAW
   1221  7c27		       a9 02		      lda	#%10
   1222  7c29		       85 ae		      sta	blankState
   1223  7c2b					      ENDIF
   1224  7c2b
   1225  7c2b		       a9 03		      lda	#BANK_Resync	; 2
   1226  7c2d		       85 3f		      sta	SET_BANK	; 3
   1227  7c2f		       20 79 f4 	      jsr	Resync	; 6+x
   1228  7c32
   1229  7c32				   NewFrameStart
   1230  7c32
   1231  7c32		       24 cb		      bit	NextLevelTrigger
   1232  7c34		       10 b2		      bpl	NextLevelLevel	; game-triggered next level
   1233  7c36		       70 a9		      bvs	RestartLevelNextPlayer	; loss of life
   1234  7c38
   1235  7c38							; Note: VSYNC must NOT be on when starting a new level! Else you get annoying TV signals.
   1236  7c38
   1237  7c38		       a9 0e		      lda	#%1110	; VSYNC ON
   1238  7c3a		       85 42	   .loopVSync sta	WSYNC
   1239  7c3c		       85 40		      sta	VSYNC
   1240  7c3e		       4a		      lsr
   1241  7c3f		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
   1242  7c41
   1243  7c41							; moved *after* the loop since this allows to *increase* timer values by 1!
   1244  7c41
   1245  7c41		       a6 80		      ldx	Platform
   1246  7c43		       bc 94 fc 	      ldy	VBlankTime,x
   1247  7c46		       8c 96 02 	      sty	TIM64T
   1248  7c49
   1249  7c49		       a9 0d		      lda	#BANK_SoundFX
   1250  7c4b		       85 3f		      sta	SET_BANK
   1251  7c4d		       20 8c f3 	      jsr	SoundFX
   1252  7c50
   1253  7c50		       20 86 fa 	      jsr	StealCharDraw	; 6 NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
   1254  7c53
   1255  7c53							;---------------------------------------------------------------------------
   1256  7c53
   1257  7c53		       a9 09		      lda	#BANK_SCORING	; 2
   1258  7c55		       85 3e		      sta	SET_BANK_RAM	; 3
   1259  7c57		       20 d5 f1 	      jsr	DrawDigits	; 6 = 11
   1260  7c5a
   1261  7c5a							;---------------------------------------------------------------------------
   1262  7c5a							; A 42-cycle timing window in the screen draw code.  Perform any general
   1263  7c5a							; per-frame code here, provided it takes exactly 42 cycles to execute.
   1264  7c5a							; TJ: Well, not exactly 42 cycles, but it works! :)
   1265  7c5a							;	 @09
   1266  7c5a							;sta COLUBK		      ; 3     value comes from subroutine
   1267  7c5a							; + the 'black' left-side of top screen colour change when look-around is actually a HMOVE bar, so we can't fix it :)
   1268  7c5a
   1269  7c5a							;		  inc Throttle		      ; 5     speed limiter
      0  7c5a					      SLEEP	2	;	 TODO: optimize for space
      1  7c5a				   .CYCLES    SET	2
      2  7c5a
      3  7c5a				  -	      IF	.CYCLES < 2
      4  7c5a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c5a				  -	      ERR
      6  7c5a					      ENDIF
      7  7c5a
      8  7c5a				  -	      IF	.CYCLES & 1
      9  7c5a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c5a				  -	      nop	0
     11  7c5a				  -	      ELSE
     12  7c5a				  -	      bit	VSYNC
     13  7c5a				  -	      ENDIF
     14  7c5a				  -.CYCLES    SET	.CYCLES - 3
     15  7c5a					      ENDIF
     16  7c5a
     17  7c5a					      REPEAT	.CYCLES / 2
     18  7c5a		       ea		      nop
     19  7c5b					      REPEND
   1271  7c5b
   1272  7c5b		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
   1273  7c5d		       ca		      dex		; 2	 = $6f, stars effect!
   1274  7c5e		       86 62		      stx	HMM0	; 3	 @24, exactly 21 cycles after the HMOVE
   1275  7c60
   1276  7c60		       85 44		      sta	NUSIZ0	; 3
   1277  7c62		       84 65		      sty	VDELP0	; 3	 y = 0!
   1278  7c64
   1279  7c64		       c8		      iny		; 2	 this relies on Y == 0 before...
   1280  7c65		       c4 c8		      cpy	extraLifeTimer	; 3	 ..,and bit 0 is set in A
   1281  7c67		       69 02		      adc	#2	; 2
   1282  7c69		       85 5d		      sta	ENAM0	; 3	 dis/enable Cosmic Ark star effect
   1283  7c6b
   1284  7c6b		       a5 a4		      lda	ManLastDirection	; 3
   1285  7c6d		       85 4b		      sta	REFP0	; 3
   1286  7c6f
   1287  7c6f		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
   1288  7c71		       85 3f		      sta	SET_BANK	; testing
   1289  7c73		       85 3e		      sta	SET_BANK_RAM	; 3
   1290  7c75		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1291  7c78							;	 @66
   1292  7c78		       a9 03		      lda	#BANK_PostScreenCleanup	; 2
   1293  7c7a		       85 3f		      sta	SET_BANK	; 3
   1294  7c7c		       20 47 f5 	      jsr	PostScreenCleanup	; 6+x
   1295  7c7f
   1296  7c7f		       a9 00		      lda	#BANK_SelfModDrawPlayers	; 2
   1297  7c81		       85 3f		      sta	SET_BANK	; 3
   1298  7c83		       20 8c f2 	      jsr	SelfModDrawPlayers	; 6+x
   1299  7c86
   1300  7c86				   SkipSc
   1301  7c86		       20 d9 fa 	      jsr	writePlayerFrame
   1302  7c89		       20 86 fa 	      jsr	StealCharDraw	; 6
   1303  7c8c
   1304  7c8c		       ad 84 02    OverscanBD lda	INTIM	;4
   1305  7c8f		       d0 fb		      bne	OverscanBD	;2/3
   1306  7c91
   1307  7c91		       4c 32 fc 	      jmp	NewFrameStart
   1308  7c94				   VBlankTime
   1309  7c94		       30 30		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
   1310  7c96		       55 55		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_PAL
   1311  7c98
   1312  7c98							;---------------------------------------------------------------------------
   1313  7c98
      0  7c98					      DEFINE_SUBROUTINE	nextLevelMan
      1  7c98		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7c98					      SUBROUTINE
      3  7c98				   nextLevelMan
   1315  7c98
   1316  7c98		       a9 0d		      lda	#BANK_EndOfLevel
   1317  7c9a		       85 3f		      sta	SET_BANK
   1318  7c9c		       4c 1f f3 	      jmp	EndOfLevel
   1319  7c9f
   1320  7c9f
      0  7c9f					      DEFINE_SUBROUTINE	nextLevelMan2
      1  7c9f		       00 0f	   BANK_nextLevelMan2 =	_CURRENT_BANK
      2  7c9f					      SUBROUTINE
      3  7c9f				   nextLevelMan2
   1322  7c9f
   1323  7c9f		       c6 a9		      dec	DelayEndOfLevel
   1324  7ca1		       d0 29		      bne	genericRTS
   1325  7ca3
   1326  7ca3		       a9 09		      lda	#MANMODE_SWITCH
   1327  7ca5		       85 a3		      sta	ManMode
   1328  7ca7
      0  7ca7					      DEFINE_SUBROUTINE	switchLevels
      1  7ca7		       00 0f	   BANK_switchLevels =	_CURRENT_BANK
      2  7ca7					      SUBROUTINE
      3  7ca7				   switchLevels
   1330  7ca7
   1331  7ca7							; Now do the actual switching
   1332  7ca7
   1333  7ca7		       a5 cb		      lda	NextLevelTrigger
   1334  7ca9		       29 7f		      and	#<(~BIT_NEXTLEVEL)
   1335  7cab		       85 cb		      sta	NextLevelTrigger
   1336  7cad
   1337  7cad							; Next level is due. Point to the next level, but if we're at the end of playable levels,
   1338  7cad							; then increment the level number. This is completely circular, so we eventually wrap
   1339  7cad							; the level back to 0 and start afresh.
   1340  7cad
   1341  7cad		       e6 b3		      inc	levelX
   1342  7caf		       a5 b3		      lda	levelX
   1343  7cb1		       c9 9e		      cmp	#MAX_LEVEL_NUMBER
   1344  7cb3		       90 02		      bcc	.level_ok
   1345  7cb5		       a9 00		      lda	#0
   1346  7cb7		       85 b3	   .level_ok  sta	levelX
   1347  7cb9		       60		      rts
   1348  7cba
   1349  7cba							;---------------------------------------------------------------------------
   1350  7cba
   1351  7cba
      0  7cba					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7cba		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7cba					      SUBROUTINE
      3  7cba				   CopyROM2RAM_F000
   1353  7cba
   1354  7cba		       a9 0d		      lda	#BANK_CopyROMShadowToRAM
   1355  7cbc		       85 3f		      sta	SET_BANK
   1356  7cbe		       85 c4		      sta	ROM_Bank
   1357  7cc0		       4c 3d f0 	      jmp	CopyROMShadowToRAM_F000
   1358  7cc3
   1359  7cc3
   1360  7cc3							;---------------------------------------------------------------------------
   1361  7cc3
      0  7cc3					      DEFINE_SUBROUTINE	RegisterTarget
      1  7cc3		       00 0f	   BANK_RegisterTarget =	_CURRENT_BANK
      2  7cc3					      SUBROUTINE
      3  7cc3				   RegisterTarget
   1363  7cc3
   1364  7cc3		       f8		      sed
   1365  7cc4		       18		      clc
   1366  7cc5		       a5 b7		      lda	BCD_targetsRequired
   1367  7cc7		       69 01		      adc	#1
   1368  7cc9		       85 b7		      sta	BCD_targetsRequired
   1369  7ccb		       d8		      cld
   1370  7ccc		       60	   genericRTS rts
   1371  7ccd
      0  7ccd					      DEFINE_SUBROUTINE	DeRegisterTarget
      1  7ccd		       00 0f	   BANK_DeRegisterTarget =	_CURRENT_BANK
      2  7ccd					      SUBROUTINE
      3  7ccd				   DeRegisterTarget
   1373  7ccd
   1374  7ccd		       f8		      sed
   1375  7cce		       38		      sec
   1376  7ccf		       a5 b7		      lda	BCD_targetsRequired
   1377  7cd1		       e9 01		      sbc	#1
   1378  7cd3		       85 b7		      sta	BCD_targetsRequired
   1379  7cd5		       d8		      cld
   1380  7cd6		       60		      rts
   1381  7cd7
   1382  7cd7							;---------------------------------------------------------------------------
   1383  7cd7
   1384  7cd7							;include "circle.asm"
   1385  7cd7
------- FILE charset/CHARACTERSHAPE_TARGET.asm LEVEL 3 PASS 3
      0  7cd7					      include	"charset/CHARACTERSHAPE_TARGET.asm"
      0  7cd7					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET", LINES_PER_CHAR
     10  7cd7					      LIST	ON
      2  7cd7				   CHARACTERSHAPE_TARGET
      3  7cd7		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      4  7cdf		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      5  7ce7		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      0  7cef					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET_MIRRORED", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_TARGET_MIRRORED
 REQUESTED SIZE =  $18
 WASTED SPACE =  $11
 PAGEBREAK LOCATION =  $fd00
     10  7d00					      LIST	ON
      7  7d00				   CHARACTERSHAPE_TARGET_MIRRORED
      8  7d00		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      9  7d08		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
     10  7d10		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET1.asm LEVEL 3 PASS 3
      0  7d18					      include	"charset/CHARACTERSHAPE_TARGET1.asm"
      0  7d18					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET1", LINES_PER_CHAR
     10  7d18					      LIST	ON
      2  7d18				   CHARACTERSHAPE_TARGET1
      3  7d18		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      4  7d20		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      5  7d28		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      0  7d30					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET1_MIRRORED", LINES_PER_CHAR
     10  7d30					      LIST	ON
      7  7d30				   CHARACTERSHAPE_TARGET1_MIRRORED
      8  7d30		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      9  7d38		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     10  7d40		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET3.asm LEVEL 3 PASS 3
      0  7d48					      include	"charset/CHARACTERSHAPE_TARGET3.asm"
      0  7d48					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET3", LINES_PER_CHAR
     10  7d48					      LIST	ON
      2  7d48				   CHARACTERSHAPE_TARGET3
      3  7d48		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      4  7d50		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      5  7d58		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      0  7d60					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET3_MIRRORED", LINES_PER_CHAR
     10  7d60					      LIST	ON
      7  7d60				   CHARACTERSHAPE_TARGET3_MIRRORED
      8  7d60		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      9  7d68		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
     10  7d70		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET5.asm LEVEL 3 PASS 3
      0  7d78					      include	"charset/CHARACTERSHAPE_TARGET5.asm"
      0  7d78					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET5", LINES_PER_CHAR
     10  7d78					      LIST	ON
      2  7d78				   CHARACTERSHAPE_TARGET5
      3  7d78		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      4  7d80		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      5  7d88		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      0  7d90					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET5_MIRRORED", LINES_PER_CHAR
     10  7d90					      LIST	ON
      7  7d90				   CHARACTERSHAPE_TARGET5_MIRRORED
      8  7d90		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      9  7d98		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     10  7da0		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET7.asm LEVEL 3 PASS 3
      0  7da8					      include	"charset/CHARACTERSHAPE_TARGET7.asm"
      0  7da8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET7", LINES_PER_CHAR
     10  7da8					      LIST	ON
      2  7da8				   CHARACTERSHAPE_TARGET7
      3  7da8		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      4  7db0		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      5  7db8		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      0  7dc0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET7_MIRRORED", LINES_PER_CHAR
     10  7dc0					      LIST	ON
      7  7dc0				   CHARACTERSHAPE_TARGET7_MIRRORED
      8  7dc0		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      9  7dc8		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
     10  7dd0		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_STEEL.asm LEVEL 3 PASS 3
      0  7dd8					      include	"charset/CHARACTERSHAPE_STEEL.asm"
      0  7dd8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
     10  7dd8					      LIST	ON
      2  7dd8				   CHARACTERSHAPE_STEEL
      3  7dd8		       00 00 88 00*	      .byte.b	0,0,136,0,0,0,34,0
      4  7de0		       77 77 ff ff*	      .byte.b	119,119,255,255,221,221,255,255
      5  7de8		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
      0  7df0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_STEEL_MIRRORED
 REQUESTED SIZE =  $18
 WASTED SPACE =  $10
 PAGEBREAK LOCATION =  $fe00
     10  7e00					      LIST	ON
      7  7e00				   CHARACTERSHAPE_STEEL_MIRRORED
      8  7e00		       00 00 11 00*	      .byte.b	0,0,17,0,0,0,68,0
      9  7e08		       ee ee ff ff*	      .byte.b	238,238,255,255,187,187,255,255
     10  7e10		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
------- FILE BANK_FIXED.asm
------- FILE characterset/character_SOIL.asm LEVEL 3 PASS 3
      0  7e18					      include	"characterset/character_SOIL.asm"
      1  7e18							;    Sokoboo - a Sokoban implementation
      2  7e18							;    using a generic tile-based display engine for the Atari 2600
      3  7e18							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7e18							;
      5  7e18							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7e18							;
      7  7e18							;    Code related to the generic tile-based display engine was developed by
      8  7e18							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7e18							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7e18							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7e18							;
     12  7e18							;    Code related to music and sound effects uses the TIATracker music player
     13  7e18							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7e18							;    directory for Apache licensing details.
     15  7e18							;
     16  7e18							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7e18							;    See the copyright notices in the License directory for a list of level
     18  7e18							;    contributors.
     19  7e18							;
     20  7e18							;    Except where otherwise indicated, this software is released under the
     21  7e18							;    following licensing arrangement...
     22  7e18							;
     23  7e18							;    This program is free software: you can redistribute it and/or modify
     24  7e18							;    it under the terms of the GNU General Public License as published by
     25  7e18							;    the Free Software Foundation, either version 3 of the License, or
     26  7e18							;    (at your option) any later version.
     27  7e18							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7e18
     29  7e18							;    This program is distributed in the hope that it will be useful,
     30  7e18							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7e18							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7e18							;    GNU General Public License for more details.
     33  7e18
      0  7e18					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  7e18					      LIST	ON
     35  7e18				   CHARACTERSHAPE_SOIL
     36  7e18				   CHARACTERSHAPE_SOIL_MIRRORED
     37  7e18		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     38  7e20		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
     39  7e28		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_BOX.asm LEVEL 3 PASS 3
      0  7e30					      include	"charset/CHARACTERSHAPE_BOX.asm"
      0  7e30					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  7e30					      LIST	ON
      2  7e30				   CHARACTERSHAPE_BOX
      3  7e30		       ff ff 99 99*	      .byte.b	255,255,153,153,153,255,255,0
      4  7e38		       ff ff 99 99*	      .byte.b	255,255,153,153,153,0,0,0
      5  7e40		       00 00 00 00*	      .byte.b	0,0,0,0,0,255,255,0
      0  7e48					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
     10  7e48					      LIST	ON
      7  7e48				   CHARACTERSHAPE_BOX_MIRRORED
      8  7e48		       ff ff 99 99*	      .byte.b	255,255,153,153,153,255,255,0
      9  7e50		       ff ff 99 99*	      .byte.b	255,255,153,153,153,0,0,0
     10  7e58		       00 00 00 00*	      .byte.b	0,0,0,0,0,255,255,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_BOX_ON_TARGET.asm LEVEL 3 PASS 3
      0  7e60					      include	"charset/CHARACTERSHAPE_BOX_ON_TARGET.asm"
      0  7e60					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET", LINES_PER_CHAR
     10  7e60					      LIST	ON
      2  7e60				   CHARACTERSHAPE_BOX_ON_TARGET
      3  7e60		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,0
      4  7e68		       ff ff ff ff*	      .byte.b	255,255,255,255,255,0,0,0
      5  7e70		       00 00 66 66*	      .byte.b	0,0,102,102,102,255,255,0
      0  7e78					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED", LINES_PER_CHAR
     10  7e78					      LIST	ON
      7  7e78				   CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
      8  7e78		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,0
      9  7e80		       ff ff ff ff*	      .byte.b	255,255,255,255,255,0,0,0
     10  7e88		       00 00 66 66*	      .byte.b	0,0,102,102,102,255,255,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_BOX_ON_TARGET2.asm LEVEL 3 PASS 3
      0  7e90					      include	"charset/CHARACTERSHAPE_BOX_ON_TARGET2.asm"
      0  7e90					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET2", LINES_PER_CHAR
     10  7e90					      LIST	ON
      2  7e90				   CHARACTERSHAPE_BOX_ON_TARGET2
      3  7e90		       ff ff 99 99*	      .byte.b	255,255,153,153,153,255,255,0
      4  7e98		       ff ff ff ff*	      .byte.b	255,255,255,255,153,0,0,0
      5  7ea0		       00 00 66 66*	      .byte.b	0,0,102,102,0,255,255,0
      0  7ea8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED", LINES_PER_CHAR
     10  7ea8					      LIST	ON
      7  7ea8				   CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED
      8  7ea8		       ff ff 99 99*	      .byte.b	255,255,153,153,153,255,255,0
      9  7eb0		       ff ff ff ff*	      .byte.b	255,255,255,255,153,0,0,0
     10  7eb8		       00 00 66 66*	      .byte.b	0,0,102,102,0,255,255,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_WALL.asm LEVEL 3 PASS 3
      0  7ec0					      include	"charset/CHARACTERSHAPE_WALL.asm"
      0  7ec0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  7ec0					      LIST	ON
      2  7ec0				   CHARACTERSHAPE_WALL
      3  7ec0		       77 77 77 00*	      .byte.b	119,119,119,0,221,221,221,0
      4  7ec8		       77 77 77 00*	      .byte.b	119,119,119,0,221,221,221,0
      5  7ed0		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
      0  7ed8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  7ed8					      LIST	ON
      7  7ed8				   CHARACTERSHAPE_WALL_MIRRORED
      8  7ed8		       ee ee ee 00*	      .byte.b	238,238,238,0,187,187,187,0
      9  7ee0		       ee ee ee 00*	      .byte.b	238,238,238,0,187,187,187,0
     10  7ee8		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
------- FILE BANK_FIXED.asm
   1397  7ef0
   1398  7ef0				  -	      if	DIGITS
   1399  7ef0				  -	      include	"characterset/character_9.asm"
   1400  7ef0				  -	      include	"characterset/character_8.asm"
   1401  7ef0				  -	      include	"characterset/character_7.asm"
   1402  7ef0				  -	      include	"characterset/character_6.asm"
   1403  7ef0				  -	      include	"characterset/character_5.asm"
   1404  7ef0				  -	      include	"characterset/character_4.asm"
   1405  7ef0				  -	      include	"characterset/character_3.asm"
   1406  7ef0				  -	      include	"characterset/character_2.asm"
   1407  7ef0				  -	      include	"characterset/character_1.asm"
   1408  7ef0				  -	      include	"characterset/character_0.asm"
   1409  7ef0					      endif
   1410  7ef0
   1411  7ef0
 FREE BYTES IN FIXED BANK =  $10b
   1412  7ef0					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1413  7ef0
   1414  7ef0							;---------------------------------------------------------------------------
   1415  7ef0							; The reset vectors
   1416  7ef0							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1417  7ef0
   1418  8000 ????				      SEG	InterruptVectors
   1419  7ffc					      ORG	FIXED_BANK + $7FC
   1420  7ffc					      RORG	$7ffC
   1421  7ffc
   1422  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1423  7ffc		       9c fb		      .word.w	Reset	; RESET
   1424  7ffe		       9c fb		      .word.w	Reset	; IRQ	      (not used)
   1425  8000
   1426  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
    894  8000
    895  8000							;END
