------- FILE ./sokoboo.asm LEVEL 1 PASS 3
      1  8000 ????						;    Sokoboo - a Sokoban implementation
      2  8000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  8000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  8000 ????						;
      5  8000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  8000 ????						;
      7  8000 ????						;    Code related to the generic tile-based display engine was developed by
      8  8000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  8000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  8000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  8000 ????						;
     12  8000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  8000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  8000 ????						;    directory for Apache licensing details.
     15  8000 ????						;
     16  8000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  8000 ????						;    See the copyright notices in the License directory for a list of level
     18  8000 ????						;    contributors.
     19  8000 ????						;
     20  8000 ????						;    Except where otherwise indicated, this software is released under the
     21  8000 ????						;    following licensing arrangement...
     22  8000 ????						;
     23  8000 ????						;    This program is free software: you can redistribute it and/or modify
     24  8000 ????						;    it under the terms of the GNU General Public License as published by
     25  8000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  8000 ????						;    (at your option) any later version.
     27  8000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  8000 ????
     29  8000 ????						;    This program is distributed in the hope that it will be useful,
     30  8000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  8000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  8000 ????						;    GNU General Public License for more details.
     33  8000 ????
     34  8000 ????
     35  8000 ????
     36  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     37  8000 ????
     38  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./sokoboo.asm
     41  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	segtime_c
     89  0000 ????			   {1}	      SET	({2}+32)/64 + 2
     90  0000 ????			   TEST_{1}   =	0
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_DIRECT, 361 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	(361 + CYCLES_DRAWANOTHER+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_QUICK, 344 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_QUICK SET	(344 + CYCLES_DRAWANOTHER+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_SLOW, 676 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_SLOW SET	(676 + CYCLES_DRAWANOTHER+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_PF0, 88 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019 ??
      1  0000 ????			   SEGTIME_SCD_PF0 SET	(88 + CYCLES_DRAWANOTHER+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
     98  0000 ????
     99  0000 ????						;---------------------------------------------------------------------------------------------------
    100  0000 ????						; Pathways
    101  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
    102  0000 ????						; if QuickDraw does immediate exit, 58✅
    103  0000 ????
    104  0000 ????
    105  0000 ????	       00 04	   SEGTIME_SCD_MIN =	SEGTIME_SCD_PF0
    106  0000 ????
    107  0000 ????						;    SEGTIME_C SEGTIME_SCD_MIN, SEGTIME_SCD_PF0
    108  0000 ????						;---------------------------------------------------------------------------------------------------
    109  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_BDF, 2512	;✅
      1  0000 ????			   SEGTIME_BDF SET	(2512+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_BDS, 68	;✅
      1  0000 ????			   SEGTIME_BDS SET	(68+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_DSL, 127	;✅
      1  0000 ????			   SEGTIME_DSL SET	(127+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SWITCHOBJECTS,46	;✅
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	(46+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
    114  0000 ????
      0  0000 ????				      SEGTIME_C	MINIMUM_SEGTIME, 95	;✅ processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	(95+32)/64 + 2
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    117  0000 ????
    118  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    119  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    120  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    121  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    122  0000 ????						; uses ...
    123  0000 ????
    124  0000 ????
    125  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    126  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    127  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    128  0000 ????
    129  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    130  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    131  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,16	;12	      ;NFI
      1  0000 ????			   SEGTIME_MAN SET	16
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
------- FILE ./sokoboo.asm
     43  0000 ????
     44  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     45  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     46  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     47  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     48  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     49  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     50  0000 ????
     51  0000 ????	       00 01	   YES	      =	1
     52  0000 ????	       00 00	   NO	      =	0
     53  0000 ????
     54  0000 ????						;===================================
     55  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     56  0000 ????						;===================================
     57  0000 ????
     58  0000 ????						;-------------------------------------------------------------------------------
     59  0000 ????						; The following are optional YES/NO depending on phase of the moon
     60  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     61  0000 ????						;-------------------------------------------------------------------------------
     62  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     63  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     64  0000 ????			  -	      IF	FINAL_VERSION = YES
     65  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     66  0000 ????				      ENDIF
     67  0000 ????
     68  0000 ????						;-------------------------------------------------------------------------------
     69  0000 ????
     70  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     71  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
     72  0000 ????
     73  0000 ????
     74  0000 ????	       00 06	   PUSH_LIMIT =	6	; slowdown when pushing on a BOX
     75  0000 ????
     76  0000 ????						; time bonus countdown constants:
     77  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
     78  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
     79  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
     80  0000 ????
     81  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
     82  0000 ????
     83  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
     84  0000 ????
     85  0000 ????						;scoring flags contants:
     86  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
     87  0000 ????	       00 00	   DISPLAY_TIME =	%00
     88  0000 ????	       00 01	   DISPLAY_SCORE =	%01
     89  0000 ????	       00 02	   DISPLAY_LIVES =	%10
     90  0000 ????	       00 03	   DISPLAY_HIGH =	%11
     91  0000 ????
     92  0000 ????						;------------------------------------------------------------------------------
     93  0000 ????
     94  0000 ????	       00 00	   DIGITS     =	NO
     95  0000 ????	       00 01	   WAIT_FOR_INITIAL_DRAW =	YES	; blank until all initial tiles drawn
     96  0000 ????
     97  0000 ????						;------------------------------------------------------------------------------
     98  0000 ????
     99  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    100  0000 ????
    101  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    102  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    103  0000 ????
    104  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    105  0000 ????
    106  0000 ????
    107  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    108  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    109  0000 ????
    110  0000 ????
    111  0000 ????						; color constants:
    112  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    113  0000 ????
    114  0000 ????	       10 00	   RAM_3E     =	$1000
    115  0000 ????	       04 00	   RAM_SIZE   =	$400
    116  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    117  0000 ????
    118  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    119  0000 ????
    120  0000 ????
    121  0000 ????						; Platform constants:
    122  0000 ????	       00 02	   PAL	      =	%10
    123  0000 ????	       00 02	   PAL_50     =	PAL|0
    124  0000 ????	       00 03	   PAL_60     =	PAL|1
    125  0000 ????
    126  0000 ????
    127  0000 ????				      IF	L276
    128  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    129  0000 ????			  -	      ELSE
    130  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    131  0000 ????				      ENDIF
    132  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    133  0000 ????
    134  0000 ????				      IF	L276
    135  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    136  0000 ????			  -	      ELSE
    137  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    138  0000 ????				      ENDIF
    139  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    140  0000 ????
    141  0000 ????				      IF	L276
    142  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    143  0000 ????			  -	      ELSE
    144  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    145  0000 ????				      ENDIF
    146  0000 ????	       01 38	   SCANLINES_PAL =	312
    147  0000 ????
    148  0000 ????
    149  0000 ????						;------------------------------------------------------------------------------
    150  0000 ????						; MACRO definitions
    151  0000 ????
------- FILE macro2.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro2.h"
      1  0000 ????						; macros
      2  0000 ????
      3  0000 ????				      MAC	ntsc_to_pal
      4  0000 ????				      IF	{1} = 0
      5  0000 ????				      .byte	{1}+{2}
      6  0000 ????				      ENDIF
      7  0000 ????				      IF	{1} = $10
      8  0000 ????				      .byte	$20+{2}
      9  0000 ????				      ENDIF
     10  0000 ????				      IF	{1} = $20
     11  0000 ????				      .byte	$40+{2}
     12  0000 ????				      ENDIF
     13  0000 ????				      IF	{1} = $30
     14  0000 ????				      .byte	$40+{2}
     15  0000 ????				      ENDIF
     16  0000 ????				      IF	{1} = $40
     17  0000 ????				      .byte	$60+{2}
     18  0000 ????				      ENDIF
     19  0000 ????				      IF	{1} = $50
     20  0000 ????				      .byte	$80+{2}
     21  0000 ????				      ENDIF
     22  0000 ????				      IF	{1} = $60
     23  0000 ????				      .byte	$C0+{2}
     24  0000 ????				      ENDIF
     25  0000 ????				      IF	{1} = $70
     26  0000 ????				      .byte	$D0+{2}
     27  0000 ????				      ENDIF
     28  0000 ????				      IF	{1} = $80
     29  0000 ????				      .byte	$B0+{2}
     30  0000 ????				      ENDIF
     31  0000 ????				      IF	{1} = $90
     32  0000 ????				      .byte	$90+{2}
     33  0000 ????				      ENDIF
     34  0000 ????				      IF	{1} = $A0
     35  0000 ????				      .byte	$70+{2}
     36  0000 ????				      ENDIF
     37  0000 ????				      IF	{1} = $B0
     38  0000 ????				      .byte	$50+{2}
     39  0000 ????				      ENDIF
     40  0000 ????				      IF	{1} = $C0
     41  0000 ????				      .byte	$30+{2}
     42  0000 ????				      ENDIF
     43  0000 ????				      IF	{1} = $D0
     44  0000 ????				      .byte	$30+{2}
     45  0000 ????				      ENDIF
     46  0000 ????				      IF	{1} = $E0
     47  0000 ????				      .byte	$20+{2}
     48  0000 ????				      ENDIF
     49  0000 ????				      IF	{1} = $F0
     50  0000 ????				      .byte	$40+{2}
     51  0000 ????				      ENDIF
     52  0000 ????				      ENDM		; {col} {intensity}
------- FILE ./sokoboo.asm
    153  0000 ????
    154  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    155  0000 ????
    156  0000 ????				      MAC	newbank
    157  0000 ????				      SEG	{1}
    158  0000 ????				      ORG	ORIGIN
    159  0000 ????				      RORG	$F000
    160  0000 ????			   BANK_START SET	*
    161  0000 ????			   {1}	      SET	ORIGIN / 2048
    162  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    163  0000 ????			   _CURRENT_BANK SET	{1}
    164  0000 ????				      ENDM		; bank name
    165  0000 ????
    166  0000 ????				      MAC	define_1k_segment
    167  0000 ????				      ALIGN	$400
    168  0000 ????			   SEGMENT_{1} SET	*
    169  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    170  0000 ????				      ENDM		; {seg name}
    171  0000 ????
    172  0000 ????				      MAC	check_bank_size
    173  0000 ????			   .TEMP      =	* - BANK_START
    174  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    175  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    176  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    177  0000 ????				      ERR
    178  0000 ????				      endif
    179  0000 ????				      ENDM		; name
    180  0000 ????
    181  0000 ????
    182  0000 ????				      MAC	check_half_bank_size
    183  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    184  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    185  0000 ????			   .TEMP      =	* - BANK_START
    186  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    187  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    188  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    189  0000 ????				      ERR
    190  0000 ????				      endif
    191  0000 ????				      ENDM		; name
    192  0000 ????
    193  0000 ????
    194  0000 ????				      MAC	overlay
    195  0000 ????				      SEG.U	OVERLAY_{1}
    196  0000 ????				      org	Overlay
    197  0000 ????				      ENDM		; {name}
    198  0000 ????
    199  0000 ????						;--------------------------------------------------------------------------
    200  0000 ????
    201  0000 ????				      MAC	validate_overlay
    202  0000 ????				      LIST	OFF
    203  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    204  0000 ????				      ECHO	"Overlay ", {1}, "too big"
    205  0000 ????				      ERR
    206  0000 ????				      endif
    207  0000 ????				      LIST	ON
    208  0000 ????				      ENDM
    209  0000 ????
    210  0000 ????						;--------------------------------------------------------------------------
    211  0000 ????						; Macro inserts a page break if the object would overlap a page
    212  0000 ????
    213  0000 ????				      MAC	optional_pagebreak
    214  0000 ????				      LIST	OFF
    215  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    216  0000 ????			   EARLY_LOCATION SET	*
    217  0000 ????				      ALIGN	256
    218  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    219  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    220  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    221  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    222  0000 ????				      ENDIF
    223  0000 ????				      LIST	ON
    224  0000 ????				      ENDM		; { string, size }
    225  0000 ????
    226  0000 ????
    227  0000 ????				      MAC	check_page_crossing
    228  0000 ????				      LIST	OFF
    229  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    230  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    231  0000 ????				      endif
    232  0000 ????				      LIST	ON
    233  0000 ????				      ENDM
    234  0000 ????
    235  0000 ????				      MAC	checkpage
    236  0000 ????				      LIST	OFF
    237  0000 ????				      IF	>. != >{1}
    238  0000 ????				      ECHO	""
    239  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    240  0000 ????				      ECHO	""
    241  0000 ????				      ERR
    242  0000 ????				      ENDIF
    243  0000 ????				      LIST	ON
    244  0000 ????				      ENDM
    245  0000 ????
    246  0000 ????				      MAC	checkpagex
    247  0000 ????				      LIST	OFF
    248  0000 ????				      IF	>. != >{1}
    249  0000 ????				      ECHO	""
    250  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    251  0000 ????				      ECHO	{2}
    252  0000 ????				      ECHO	""
    253  0000 ????				      ERR
    254  0000 ????				      ENDIF
    255  0000 ????				      LIST	ON
    256  0000 ????				      ENDM
    257  0000 ????
    258  0000 ????
    259  0000 ????				      MAC	checkpage_bne
    260  0000 ????				      LIST	OFF
    261  0000 ????				      IF	0	;>(. + 2) != >{1}
    262  0000 ????				      ECHO	""
    263  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    264  0000 ????				      ECHO	""
    265  0000 ????				      ERR
    266  0000 ????				      ENDIF
    267  0000 ????				      LIST	ON
    268  0000 ????				      bne	{1}
    269  0000 ????				      ENDM
    270  0000 ????
    271  0000 ????				      MAC	checkpage_bpl
    272  0000 ????				      LIST	OFF
    273  0000 ????				      IF	(>(.+2 )) != >{1}
    274  0000 ????				      ECHO	""
    275  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    276  0000 ????				      ECHO	""
    277  0000 ????				      ERR
    278  0000 ????				      ENDIF
    279  0000 ????				      LIST	ON
    280  0000 ????				      bpl	{1}
    281  0000 ????				      ENDM
    282  0000 ????
    283  0000 ????				      MAC	align_free
    284  0000 ????			   FREE       SET	FREE - .
    285  0000 ????				      align	{1}
    286  0000 ????			   FREE       SET	FREE + .
    287  0000 ????				      echo	"@", ., ":", FREE
    288  0000 ????				      ENDM
    289  0000 ????
    290  0000 ????						;--------------------------------------------------------------------------
    291  0000 ????
    292  0000 ????				      MAC	vector
    293  0000 ????				      .word	{1}
    294  0000 ????				      ENDM		; just a word pointer to code
    295  0000 ????
    296  0000 ????
    297  0000 ????				      MAC	define_subroutine
    298  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    299  0000 ????				      SUBROUTINE		; keep everything local
    300  0000 ????			   {1}			; entry point
    301  0000 ????				      ENDM		; name of subroutine
    302  0000 ????
    303  0000 ????
    304  0000 ????
    305  0000 ????						;--------------------------------------------------------------------------
    306  0000 ????
    307  0000 ????				      MAC	newrambank
    308  0000 ????				      SEG.U	{1}
    309  0000 ????				      ORG	ORIGIN
    310  0000 ????				      RORG	RAM_3E
    311  0000 ????			   BANK_START SET	*
    312  0000 ????			   {1}	      SET	ORIGIN / RAM_SIZE
    313  0000 ????			   ORIGIN     SET	ORIGIN + RAM_SIZE
    314  0000 ????				      ENDM		; bank name
    315  0000 ????
    316  0000 ????				      MAC	validate_ram_size
    317  0000 ????				      if	* - RAM_3E > RAM_SIZE
    318  0000 ????				      ERR
    319  0000 ????				      endif
    320  0000 ????				      ENDM
    321  0000 ????
    322  0000 ????				      MAC	next_random
    323  0000 ????						; update random value:
    324  0000 ????				      lda	rnd	; 3
    325  0000 ????				      lsr		; 2
    326  0000 ????				      IFCONST	rndHi
    327  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    328  0000 ????				      ENDIF
    329  0000 ????				      bcc	.skipEOR	; 2/3
    330  0000 ????				      eor	#RND_EOR_VAL	; 2
    331  0000 ????			   .skipEOR
    332  0000 ????				      sta	rnd	; 3 = 14/19
    333  0000 ????				      ENDM
    334  0000 ????
    335  0000 ????				      MAC	resync
    336  0000 ????						; resync screen, X and Y == 0 afterwards
    337  0000 ????				      lda	#%10	; make sure VBLANK is ON
    338  0000 ????				      sta	VBLANK
    339  0000 ????
    340  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    341  0000 ????			   .loopResync
    342  0000 ????				      VERTICAL_SYNC
    343  0000 ????
    344  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    345  0000 ????				      lda	Platform
    346  0000 ????				      eor	#PAL_50	; PAL-50?
    347  0000 ????				      bne	.ntsc
    348  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    349  0000 ????			   .ntsc
    350  0000 ????			   .loopWait
    351  0000 ????				      sta	WSYNC
    352  0000 ????				      sta	WSYNC
    353  0000 ????				      dey
    354  0000 ????				      bne	.loopWait
    355  0000 ????				      dex
    356  0000 ????				      bne	.loopResync
    357  0000 ????				      ENDM
    358  0000 ????
    359  0000 ????				      MAC	set_platform
    360  0000 ????						; 00 = NTSC
    361  0000 ????						; 01 = NTSC
    362  0000 ????						; 10 = PAL-50
    363  0000 ????						; 11 = PAL-60
    364  0000 ????				      lda	SWCHB
    365  0000 ????				      rol
    366  0000 ????				      rol
    367  0000 ????				      rol
    368  0000 ????				      and	#%11
    369  0000 ????				      eor	#PAL
    370  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    371  0000 ????				      ENDM
    372  0000 ????
    373  0000 ????				      MAC	load_animation
    374  0000 ????				      lda	#<Animation_{1}
    375  0000 ????				      sta	animation
    376  0000 ????				      lda	#>Animation_{1}
    377  0000 ????				      sta	animation+1
    378  0000 ????				      lda	#0
    379  0000 ????				      sta	animation_delay
    380  0000 ????				      lda	#ANIMATION_{1}_ID
    381  0000 ????				      sta	ManAnimationID
    382  0000 ????
    383  0000 ????				      ENDM
    384  0000 ????
    385  0000 ????
    386  0000 ????						;------------------------------------------------------------------------------
    387  0000 ????
    388  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34 U00f7 ????				      SEG.U	variables
     35 U0080					      ORG	$80
     36 U0080
     37 U0080
     38 U0080		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     39 U0081
     40 U0081		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     41 U0082		       00	   ObjStackNum ds	1	; which stack in use
     42 U0083		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     43 U0085		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     44 U0086		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     45 U0087
     46 U0087		       00	   POS_X      ds	1
     47 U0088		       00	   POS_Y      ds	1
     48 U0089		       00	   POS_X_NEW  ds	1
     49 U008a		       00	   POS_Y_NEW  ds	1
     50 U008b		       00	   POS_Type   ds	1
     51 U008c		       00	   POS_VAR    ds	1
     52 U008d
     53 U008d		       00	   TB_X       ds	1
     54 U008e		       00	   TB_Y       ds	1
     55 U008f		       00	   TB_PUSHX   ds	1
     56 U0090		       00	   TB_PUSHY   ds	1
     57 U0091		       00	   TB_CHAR    ds	1
     58 U0092
     59 U0092		       00	   BufferedJoystick ds	1	; player joystick input
     60 U0093		       00	   PreviousJoystick ds	1
     61 U0094
     62 U0094							; Scrolling is limited to only show board within the following area...
     63 U0094		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in UnpackLevel)
     64 U0095		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in UnpackLevel)
     65 U0096		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     66 U0097		       00	   BoardScrollX ds	1	; scroll position in board (X)
     67 U0097		       00 94	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     68 U0097		       00 95	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     69 U0098		       00	   scrollBits ds	1
     70 U0099
     71 U0099		       00	   animation_index ds	1	; new
     72 U009a		       00 00	   animation  ds	2
     73 U009c		       00	   animation_delay ds	1
     74 U009d		       00	   ManX       ds	1
     75 U009e		       00	   ManY       ds	1
     76 U009f		       00	   ManDrawX   ds	1
     77 U00a0		       00	   ManDrawY   ds	1
     78 U00a1		       00	   ManMode    ds	1
     79 U00a2		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     80 U00a3		       00	   ManTurnStart ds	1
     81 U00a4		       00	   ManPushCounter ds	1
     82 U00a5		       00	   LookingAround ds	1
     83 U00a6		       00	   ManAnimationID ds	1
     84 U00a7		       00	   ManNextAnimationID ds	1	; -1 for nothing
     85 U00a8		       00	   idleCount  ds	1
     86 U00a9
     87 U00a9		       00	   DelayEndOfLevel ds	1
     88 U00aa		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     89 U00ab
     90 U00ab		       00	   LEVEL_bank ds	1
     91 U00ac		       00 00	   levelPtr   ds	2
     92 U00ae
     93 U00ae					      IF	WAIT_FOR_INITIAL_DRAW
     94 U00ae		       00	   blankState ds	1
     95 U00af					      ENDIF
     96 U00af
     97 U00af							;---------------------------------------------------------------------------
     98 U00af							; 2 (shared) demo mode variables:
     99 U00af							;demoMode			  = jtoggle	  ; bit 7==1 => demo mode
    100 U00af							;moveLen			  = jtoggle	  ; bits 0..6
    101 U00af							;moveIdx			 ds 1
    102 U00af
    103 U00af		       00	   LastSpriteY ds	1
    104 U00b0
    105 U00b0		       00	   timer      ds	1
    106 U00b1
    107 U00b1		       00	   BGColour   ds	1
    108 U00b2
    109 U00b2							; levelx and level have to be consecutive variables!
    110 U00b2		       00	   levelX     ds	1	; current player's level (other in scoring bank)
    111 U00b3		       00	   level      ds	1	; current player's level (other in scoring bank)
    112 U00b4							;levelDisplay			   ds 1 	   ; what to display as the level ID
    113 U00b4		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
    114 U00b5							;ThrottleSpeed 		  ds 1		  ; system-dependant throttle speed
    115 U00b5
    116 U00b5		       00	   BCD_targetsRequired ds	1	; number of un-targeted left to go
    117 U00b6		       00	   BCD_moveCounter ds	1	; BCD seconds for level
    118 U00b7		       00	   BCD_moveCounterHi ds	1
    119 U00b8
    120 U00b8		       00	   takebackIndex ds	1
    121 U00b9		       00	   takebackBaseIndex ds	1
    122 U00ba		       00	   TakebackInhibit ds	1
    123 U00bb
    124 U00bb		       00 00	   Board_AddressR ds	2
    125 U00bd		       00 00	   Board_AddressW ds	2
    126 U00bf		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
    127 U00c0		       00	   RAM_Bank   ds	1
    128 U00c1
    129 U00c1		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
    130 U00c2							;ColourFlash			  ds 1		   ; colour of flash
    131 U00c2							;extraLifeTimer		  ds 1		  ; should be 5 seconds!
    132 U00c2
    133 U00c2							; extraLifeTimer:
    134 U00c2							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    135 U00c2
    136 U00c2							;scoringTimer			  ds 1		  ; times the various score displays
    137 U00c2							;scoringFlags			  ds 1		  ; scoring flags are stored here
    138 U00c2
    139 U00c2							; scoringFlags:
    140 U00c2							; D7		 Extra TARGETs in effect (TARGETs collected over requirement score more) ASSUMED BPL/BMI usage
    141 U00c2							; D6		 unused
    142 U00c2							; D5		 unused
    143 U00c2							; D4		 unused
    144 U00c2							; D3		 unused
    145 U00c2							; D2		 unused
    146 U00c2							; D1	 D1-D0	 Which display kernel to use for scoring
    147 U00c2							; D0		 0 = 2x4     used for TARGETs/time
    148 U00c2							;		 1 = 1x6     used for score
    149 U00c2							;		 2 = 3x2     used for level/lives/player
    150 U00c2
    151 U00c2		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    152 U00c2		       00 80	   BIT_NEXTLEVEL =	128
    153 U00c2		       00 40	   BIT_NEXTLIFE =	64
    154 U00c3
    155 U00c3							;------------------------------------------------------------------------------
    156 U00c3
    157 U00c3		       00	   ObjIterator ds	1	; count UP iterator over objects
    158 U00c4		       00	   DSL	      ds	1	; stack line counter
    159 U00c5
    160 U00c5		       00	   ethnic     ds	1
    161 U00c6		       00	   animate_char_index ds	1
    162 U00c7
    163 U00c7
    164 U00c7
------- FILE sound/intro1_variables.asm LEVEL 3 PASS 3
      0 U00c7					      include	"sound/intro1_variables.asm"
      1 U00c7							; TIATracker music player
      2 U00c7							; Copyright 2016 Andre "Kylearan" Wichmann
      3 U00c7							; Website: https://bitbucket.org/kylearan/tiatracker
      4 U00c7							; Email: andre.wichmann@gmx.de
      5 U00c7							;
      6 U00c7							; Licensed under the Apache License, Version 2.0 (the "License");
      7 U00c7							; you may not use this file except in compliance with the License.
      8 U00c7							; You may obtain a copy of the License at
      9 U00c7							;
     10 U00c7							;   http://www.apache.org/licenses/LICENSE-2.0
     11 U00c7							;
     12 U00c7							; Unless required by applicable law or agreed to in writing, software
     13 U00c7							; distributed under the License is distributed on an "AS IS" BASIS,
     14 U00c7							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15 U00c7							; See the License for the specific language governing permissions and
     16 U00c7							; limitations under the License.
     17 U00c7
     18 U00c7							; Song author: 
     19 U00c7							; Song name: 
     20 U00c7
     21 U00c7							; @com.wudsn.ide.asm.hardware=ATARI2600
     22 U00c7
     23 U00c7							; =====================================================================
     24 U00c7							; Flags
     25 U00c7							; =====================================================================
     26 U00c7
     27 U00c7							; 1: Global song speed, 0: Each pattern has individual speed
     28 U00c7		       00 01	   TT_GLOBAL_SPEED =	1
     29 U00c7							; duration (number of TV frames) of a note
     30 U00c7		       00 05	   TT_SPEED   =	5
     31 U00c7							; duration of odd frames (needs TT_USE_FUNKTEMPO)
     32 U00c7		       00 04	   TT_ODD_SPEED =	4
     33 U00c7
     34 U00c7							; 1: Overlay percussion, +40 bytes
     35 U00c7		       00 01	   TT_USE_OVERLAY =	1
     36 U00c7							; 1: Melodic instrument slide, +9 bytes
     37 U00c7		       00 00	   TT_USE_SLIDE =	0
     38 U00c7							; 1: Goto pattern, +8 bytes
     39 U00c7		       00 01	   TT_USE_GOTO =	1
     40 U00c7							; 1: Odd/even rows have different SPEED values, +7 bytes
     41 U00c7		       00 01	   TT_USE_FUNKTEMPO =	1
     42 U00c7							; If the very first notes played on each channel are not PAUSE, HOLD or
     43 U00c7							; SLIDE, i.e. if they start with an instrument or percussion, then set
     44 U00c7							; this flag to 0 to save 2 bytes.
     45 U00c7							; 0: +2 bytes
     46 U00c7		       00 01	   TT_STARTS_WITH_NOTES =	1
     47 U00c7
     48 U00c7
     49 U00c7							; =====================================================================
     50 U00c7							; Permanent variables. These are states needed by the player.
     51 U00c7							; =====================================================================
     52 U00c7		       00	   tt_timer   ds	1	; current music timer value
     53 U00c8		       00	   tt_cur_pat_index_c0 ds	1	; current pattern index into tt_SequenceTable
     54 U00c9		       00	   tt_cur_pat_index_c1 ds	1
     55 U00ca		       00	   tt_cur_note_index_c0 ds	1	; note index into current pattern
     56 U00cb		       00	   tt_cur_note_index_c1 ds	1
     57 U00cc		       00	   tt_envelope_index_c0 ds	1	; index into ADSR envelope
     58 U00cd		       00	   tt_envelope_index_c1 ds	1
     59 U00ce		       00	   tt_cur_ins_c0 ds	1	; current instrument
     60 U00cf		       00	   tt_cur_ins_c1 ds	1
     61 U00d0
     62 U00d0
     63 U00d0							; =====================================================================
     64 U00d0							; Temporary variables. These will be overwritten during a call to the
     65 U00d0							; player routine, but can be used between calls for other things.
     66 U00d0							; =====================================================================
     67 U00d0		       00 00	   tt_ptr     ds	2
------- FILE zeropage.asm
    166 U00d2
    167 U00d2
    168 U00d2
    169 U00d2				   OVERLAY_SIZE SET	25
    170 U00d2
    171 U00d2
    172 U00d2
    173 U00d2							; This overlay variable is used for the overlay variables.  That's OK.
    174 U00d2							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    175 U00d2							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    176 U00d2							; (especially the latter ones) are only used in rare occasions.
    177 U00d2
    178 U00d2							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    179 U00d2							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    180 U00d2
    181 U00d2		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00eb					      VALIDATE_OVERLAY	"DEFINITION"
      6 U00eb					      LIST	ON
    183 U00eb
    184 U00eb
    185 U00eb		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    186 U00f7
 FREE BYTES IN ZERO PAGE =  $8
    187 U00f7					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    188 U00f7				  -	      IF	* > $FF
    189 U00f7				  -	      ERR
    190 U00f7					      ENDIF
------- FILE ./sokoboo.asm
    390 U00f7
    391 U00f7
    392 U00f7							;------------------------------------------------------------------------------
    393 U00f7							; OVERLAYS!
    394 U00f7							; These variables are overlays, and should be managed with care
    395 U00f7							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    396 U00f7
    397 U00f7							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    398 U00f7							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    399 U00f7
    400 U00f7							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    401 U00f7
    402 U00f7
    403 U00f7
    404 U00f7							;------------------------------------------------------------------------------
      0 U00f7					      OVERLAY	BuildDrawFlags
      1 U00dd ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00d2					      org	Overlay
    406 U00d2
    407 U00d2		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    408 U00d4		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    409 U00d6		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    410 U00d8		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    411 U00da							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    412 U00da		       00	   BDF_BoardBank ds	1	; holds bank of current line
    413 U00db							;  ENDIF
    414 U00db		       00	   DHS_Line   ds	1
    415 U00dc		       00	   DHS_Stack  ds	1	; for restoring SP
    416 U00dd							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dd					      VALIDATE_OVERLAY	"BuildDrawFlags"
      6 U00dd					      LIST	ON
    418 U00dd
    419 U00dd							;------------------------------------------------------------------------------
    420 U00dd
      0 U00dd					      OVERLAY	Animator
      1 U00d8 ????				      SEG.U	OVERLAY_Animator
      2 U00d2					      org	Overlay
    422 U00d2		       00 00	   frame_ptr  ds	2
    423 U00d4		       00 00	   colour_ptr ds	2
    424 U00d6		       00	   bank       ds	1
    425 U00d7		       00	   ethnicity  ds	1
      0 U00d8					      VALIDATE_OVERLAY	"Animator"
      6 U00d8					      LIST	ON
    427 U00d8
    428 U00d8
      0 U00d8					      OVERLAY	Process
      1 U00d5 ????				      SEG.U	OVERLAY_Process
      2 U00d2					      org	Overlay
    430 U00d2
    431 U00d2		       00	   BOXLeft    ds	1
    432 U00d3		       00	   BOXRight   ds	1
    433 U00d4		       00	   restorationCharacter ds	1
    434 U00d5
      0 U00d5					      VALIDATE_OVERLAY	"Process"
      6 U00d5					      LIST	ON
    436 U00d5
    437 U00d5							;------------------------------------------------------------------------------
    438 U00d5
    439 U00d5
      0 U00d5					      OVERLAY	Animate
      1 U00d3 ????				      SEG.U	OVERLAY_Animate
      2 U00d2					      org	Overlay
    441 U00d2		       00	   halftimer  ds	1
      0 U00d3					      VALIDATE_OVERLAY	"Animate"
      6 U00d3					      LIST	ON
    443 U00d3
    444 U00d3							;------------------------------------------------------------------------------
    445 U00d3
      0 U00d3					      OVERLAY	TitleScreen
      1 U00eb ????				      SEG.U	OVERLAY_TitleScreen
      2 U00d2					      org	Overlay
    447 U00d2		       00 00	   colour_table ds	2
    448 U00d4		       00 00	   digit1     ds	2
    449 U00d6		       00 00 00    digit2     ds	3
    450 U00d9		       00 00	   digitstar  ds	2
    451 U00db		       00 00 00    digit      ds	3
    452 U00de		       00	   digitick   ds	1
    453 U00df		       00 00 00    targetDigit ds	3
    454 U00e2		       00	   initialdelay ds	1
    455 U00e3		       00	   endwait    ds	1
    456 U00e4		       00	   colourindex ds	1
    457 U00e5		       00 00	   digitHundreds ds	2
    458 U00e7		       00	   selector   ds	1
    459 U00e8		       00	   walkSpeed  ds	1
    460 U00e9		       00 00	   manc       ds	2
      0 U00eb					      VALIDATE_OVERLAY	"TitleScreen"
      6 U00eb					      LIST	ON
    462 U00eb
    463 U00eb							;------------------------------------------------------------------------------
    464 U00eb
      0 U00eb					      OVERLAY	TimeSlice
      1 U00d4 ????				      SEG.U	OVERLAY_TimeSlice
      2 U00d2					      org	Overlay
    466 U00d2
    467 U00d2		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    468 U00d4							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00d4					      VALIDATE_OVERLAY	"TimeSlice"
      6 U00d4					      LIST	ON
    470 U00d4
    471 U00d4							;------------------------------------------------------------------------------
    472 U00d4
      0 U00d4					      OVERLAY	CopyROMShadowToRAM
      1 U00d5 ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00d2					      org	Overlay
    474 U00d2
    475 U00d2		       00	   O_CopyCount ds	1
    476 U00d3		       00	   O_ROM_Source_Bank ds	1
    477 U00d4		       00	   O_Index    ds	1
    478 U00d5							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00d5					      VALIDATE_OVERLAY	"CopyROMShadowToRAM"
      6 U00d5					      LIST	ON
    480 U00d5
    481 U00d5							;------------------------------------------------------------------------------
    482 U00d5
      0 U00d5					      OVERLAY	Scoring
      1 U00d3 ????				      SEG.U	OVERLAY_Scoring
      2 U00d2					      org	Overlay
    484 U00d2		       00	   tmpStack   ds	1
    485 U00d2		       00 d2	   newDisplay =	tmpStack
    486 U00d3							; also for UpdateTimer
    487 U00d3		       00 d2	   tmpSound   =	tmpStack
      0 U00d3					      VALIDATE_OVERLAY	"Scoring"
      6 U00d3					      LIST	ON
    489 U00d3
    490 U00d3
    491 U00d3							;------------------------------------------------------------------------------
    492 U00d3
      0 U00d3					      OVERLAY	SaveKey
      1 U00db ????				      SEG.U	OVERLAY_SaveKey
      2 U00d2					      org	Overlay
    494 U00d2
    495 U00d2		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    496 U00d5		       00 00 00    highScoreSK ds	3
    497 U00d8		       00	   startingLevel ds	1	; levelx * 5
    498 U00d9		       00	   startLevel ds	1
    499 U00da		       00	   offsetSK   ds	1	; for calculating the SK slot address
    500 U00db
      0 U00db					      VALIDATE_OVERLAY	"SaveKey"
      6 U00db					      LIST	ON
    502 U00db
    503 U00db							;------------------------------------------------------------------------------
    504 U00db
      0 U00db					      OVERLAY	DrawMan
      1 U00d4 ????				      SEG.U	OVERLAY_DrawMan
      2 U00d2					      org	Overlay
    506 U00d2
    507 U00d2		       00 00	   MAN_Move   ds	2
    508 U00d4
    509 U00d4							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00d4					      VALIDATE_OVERLAY	"DrawMan"
      6 U00d4					      LIST	ON
    511 U00d4
    512 U00d4							;------------------------------------------------------------------------------
    513 U00d4
      0 U00d4					      OVERLAY	ProcessObjStack
      1 U00d4 ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00d2					      org	Overlay
    515 U00d2
    516 U00d2		       00 00	   POS_Vector ds	2
    517 U00d4
    518 U00d4							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00d4					      VALIDATE_OVERLAY	"ProcessObjStack"
      6 U00d4					      LIST	ON
    520 U00d4
    521 U00d4							;------------------------------------------------------------------------------
    522 U00d4
      0 U00d4					      OVERLAY	ScoreLineOverlay
      1 U00e1 ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00d2					      org	Overlay
    524 U00d2
    525 U00d2		       00 00	   S0	      ds	2	; used for addressing digits of score
    526 U00d4		       00 00	   S1	      ds	2
    527 U00d6		       00 00	   S2	      ds	2
    528 U00d8		       00 00	   S3	      ds	2
    529 U00da		       00 00	   S4	      ds	2
    530 U00dc		       00 00	   S5	      ds	2
    531 U00de
    532 U00de		       00	   stkp       ds	1
    533 U00df		       00	   sreg       ds	1
    534 U00e0		       00	   loop       ds	1
    535 U00e1
    536 U00e1							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e1					      VALIDATE_OVERLAY	"ScoreLineOverlay"
      6 U00e1					      LIST	ON
    538 U00e1
    539 U00e1							;------------------------------------------------------------------------------
    540 U00e1
    541 U00e1
      0 U00e1					      OVERLAY	UnpackLevelOverlay
      1 U00da ????				      SEG.U	OVERLAY_UnpackLevelOverlay
      2 U00d2					      org	Overlay
    543 U00d2
    544 U00d2		       00	   base_x     ds	1
    545 U00d3		       00	   base_y     ds	1
    546 U00d4		       00	   upk_length ds	1
    547 U00d5		       00	   upk_column ds	1
    548 U00d6		       00	   upk_temp   ds	1
    549 U00d7		       00 00 00    icc_colour ds	3
    550 U00da
    551 U00da							;ECHO "FREE BYTES IN UnpackLevelOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00da					      VALIDATE_OVERLAY	"UnpackLevelOverlay"
      6 U00da					      LIST	ON
    553 U00da
    554 U00da							;------------------------------------------------------------------------------
    555 U00da
      0 U00da					      OVERLAY	ManProcessing
      1 U00d4 ????				      SEG.U	OVERLAY_ManProcessing
      2 U00d2					      org	Overlay
    557 U00d2		       00 00	   actionVector ds	2
      0 U00d4					      VALIDATE_OVERLAY	"ManProcessing"
      6 U00d4					      LIST	ON
    559 U00d4
      0 U00d4					      OVERLAY	DrawIntoStack
      1 U00d3 ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00d2					      org	Overlay
    561 U00d2		       00	   save_SP    ds	1
      0 U00d3					      VALIDATE_OVERLAY	"DrawIntoStack"
      6 U00d3					      LIST	ON
    563 U00d3
    564 U00d3							;------------------------------------------------------------------------------
    565 U00d3							;##############################################################################
    566 U00d3							;------------------------------------------------------------------------------
    567 U00d3
    568 U00d3							; NOW THE VERY INTERESTING '3E' RAM BANKS
    569 U00d3							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    570 U00d3
    571 U00d3				   ORIGIN     SET	0
      0 U00d3					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN / RAM_SIZE
      6 U0000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    573 U0000
    574 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    575 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    576 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    577 U0000
    578 U0000		       00 60	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    579 U0000
    580 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    581 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    582 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    583 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    584 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    585 U0000
    586 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    587 U0000							; is that we can use that code to switch between banks, and the system will happily
    588 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    589 U0000
    590 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    591 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    592 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    593 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    594 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    595 U0000
    596 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    597 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    598 U0000							; part of the draw routine *every* scanline (though the system currently uses
    599 U0000							; one colour shared between both players).
    600 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    602 U0000
    603 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    604 U0000							; accessed via the above labels but with the appropriate bank switched in.
    605 U0000
    606 U0000							;------------------------------------------------------------------------------
    607 U0000
    608 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    608 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    608 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    608 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1000				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    608 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    608 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    608 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    611 U1c00					      REPEND
    612 U1c00
    613 U1c00							;------------------------------------------------------------------------------
    614 U1c00							;##############################################################################
    615 U1c00							;------------------------------------------------------------------------------
    616 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN / RAM_SIZE
      6 U2000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    618 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    619 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    621 U2000
    622 U2000							;------------------------------------------------------------------------------
    623 U2000							;##############################################################################
    624 U2000							;------------------------------------------------------------------------------
    625 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN / RAM_SIZE
      6 U2400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    627 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    628 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    630 U2400
    631 U2400							;------------------------------------------------------------------------------
    632 U2400							;##############################################################################
    633 U2400							;------------------------------------------------------------------------------
    634 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_LEVEL
      1 U2800 ????				      SEG.U	BANK_DECODE_LEVEL
      2 U2800					      ORG	ORIGIN
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_LEVEL SET	ORIGIN / RAM_SIZE
      6 U2800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    636 U2800							; VARS DEFINED IN BANK_DECODE_LEVEL_SHADOW
    637 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    639 U2800
    640 U2800							;------------------------------------------------------------------------------
    641 U2800							;##############################################################################
    642 U2800							;------------------------------------------------------------------------------
    643 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN / RAM_SIZE
      6 U2c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
    645 U2c00
    646 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    647 U2c00							; position of something that needs to be processed.  These things include anything
    648 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    649 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    650 U2c00							; one for the next processing iteration.
    651 U2c00
    652 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    653 U2c00
    654 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    655 U2c00
    656 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    657 U2c00
    658 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    659 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    660 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    661 U2d80
    662 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    663 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    664 U2e00
    665 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    666 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    667 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    668 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    670 U2e80
    671 U2e80							;------------------------------------------------------------------------------
    672 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN / RAM_SIZE
      6 U3000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    674 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    676 U3000
    677 U3000							;------------------------------------------------------------------------------
    678 U3000							;##############################################################################
    679 U3000							;------------------------------------------------------------------------------
    680 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U37a0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN / RAM_SIZE
      6 U3400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    682 U3400
    683 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    684 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    685 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    686 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    687 U3400							; when accessing.
    688 U3400
    689 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    690 U3400							; automatically based on the sizes set in these constants. The board may overlay
    691 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    692 U3400							; we're doing OK.
    693 U3400
    694 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    695 U3400
    696 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    697 U3400
    698 U3400		       00 28	   SIZE_BOARD_X =	40	;
    699 U3400		       00 16	   SIZE_BOARD_Y =	22
    700 U3400
    701 U3400
    702 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    703 U3400				  -MULTI_BANK_BOARD =	YES
    704 U3400					      ELSE
    705 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    706 U3400					      ENDIF
    707 U3400
    708 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    709 U37a0							; 1024 byte chunks, switching RAM
    710 U37a0							; banks as we go.  In other words,
    711 U37a0							; this overlaps multiple banks!
    712 U37a0
      0 U37a0					      NEWRAMBANK	BANK_TAKEBACK
      1 U3940 ????				      SEG.U	BANK_TAKEBACK
      2 U3800					      ORG	ORIGIN
      3 U3800					      RORG	RAM_3E
      4 U3800				   BANK_START SET	*
      5 U3800				   BANK_TAKEBACK SET	ORIGIN / RAM_SIZE
      6 U3800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    714 U3800
    715 U3800		       00 3f	   TAKEBACK_MASK =	$3F
    716 U3800
    717 U3800		       00 00 00 00*TakeBackPreviousX ds	$40
    718 U3840		       00 00 00 00*TakeBackPreviousY ds	$40
    719 U3880		       00 00 00 00*TakeBackPushX ds	$40
    720 U38c0		       00 00 00 00*TakeBackPushY ds	$40
    721 U3900		       00 00 00 00*TakeBackPushChar ds	$40
    722 U3940
    723 U3940							; reverting...
    724 U3940							; A prevoius position
    725 U3940							;	     POS_VAR = board
    726 U3940							;	     board = MANOCCUPIED
    727 U3940							;	     manx,y = x,y
    728 U3940							; B current position (MANX,Y)
    729 U3940							;	     board = POS_VAR
    730 U3940							; C push position
    731 U3940							;	     BOARD = PREV_BOARD
    732 U3940							; TAKEBACK_PREV_X, TAKEBACK_PREV_Y, TAKEBACK_PUSH_X,PUSH_Y,TAKEBACK_PUSH_PREV
    733 U3940							;
    734 U3940
    735 U3940
    736 U3940							; free space here (but hard to use)
    737 U3940							; So we need to calculate where the next free bank is!
    738 U3940							; TODO: This looks dodgy.  Check..
    739 U3940
    740 U3940				   ORIGIN     SET	( * + RAM_SIZE - 1 ) / RAM_SIZE
    741 U3940				   ORIGIN     SET	ORIGIN * RAM_SIZE
    742 U3940
    743 U3940
    744 U3940
    745 U3940							;------------------------------------------------------------------------------
    746 U3940							;##############################################################################
    747 U3940							;------------------------------------------------------------------------------
    748 U3940
    749 U3940							;------------------------------------------------------------------------------
    750 U3940
    751 U3940							;    IFNCONST MAX_LEVEL_SIZE
    752 U3940				   MAX_LEVEL_SIZE SET	0
    753 U3940							;    ENDIF
    754 U3940
    755 U3940
    756 U3940				   MAX_LEVEL_NUMBER SET	0
    757 U3940					      MAC	start_level
    758 U3940				   LEVEL_START SET	*
    759 U3940				   BANK_LEVEL_{1} =	_CURRENT_BANK
    760 U3940				   LEVEL_{1}  SUBROUTINE
    761 U3940				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
    762 U3940							; ECHO "current MAX_LEVEL_NUMBER = ", MAX_LEVEL_NUMBER
    763 U3940					      ENDM		; {name}
    764 U3940
    765 U3940
    766 U3940					      MAC	end_level
    767 U3940				   LEVEL_SIZE_{1} =	* - LEVEL_START
    768 U3940					      IF	LEVEL_SIZE_{1} > MAX_LEVEL_SIZE
    769 U3940				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_{1}
    770 U3940					      ENDIF
    771 U3940					      ENDM		; {name}
    772 U3940
    773 U3940
    774 U3940					      MAC	defl
    775 U3940					      START_LEVEL	{1}
    776 U3940					      .byte	{2},0
    777 U3940					      END_LEVEL	{1}
    778 U3940					      ENDM
    779 U3940
    780 U3940							;--------------------------------------------------------------------------------
    781 U3940
    782 U3940				   ORIGIN     SET	$00000
    783 U3940
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 3
      0 U3940					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1 U3940							;    Sokoboo - a Sokoban implementation
      2 U3940							;    using a generic tile-based display engine for the Atari 2600
      3 U3940							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4 U3940							;
      5 U3940							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6 U3940							;
      7 U3940							;    Code related to the generic tile-based display engine was developed by
      8 U3940							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9 U3940							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10 U3940							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11 U3940							;
     12 U3940							;    Code related to music and sound effects uses the TIATracker music player
     13 U3940							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14 U3940							;    directory for Apache licensing details.
     15 U3940							;
     16 U3940							;    Some level data incorporated in this program were created by Lee J Haywood.
     17 U3940							;    See the copyright notices in the License directory for a list of level
     18 U3940							;    contributors.
     19 U3940							;
     20 U3940							;    Except where otherwise indicated, this software is released under the
     21 U3940							;    following licensing arrangement...
     22 U3940							;
     23 U3940							;    This program is free software: you can redistribute it and/or modify
     24 U3940							;    it under the terms of the GNU General Public License as published by
     25 U3940							;    the Free Software Foundation, either version 3 of the License, or
     26 U3940							;    (at your option) any later version.
     27 U3940							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28 U3940
     29 U3940							;    This program is distributed in the hope that it will be useful,
     30 U3940							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31 U3940							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32 U3940							;    GNU General Public License for more details.
     33 U3940
     34 U3940							;------------------------------------------------------------------------------
     35 U3940							;##############################################################################
     36 U3940							;------------------------------------------------------------------------------
      0 U3940					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  036a ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
     38  0000
     39  0000							; This is essentially a ROM mirror of a RAM bank.
     40  0000							; The contents of this bank are copied to each of the ROW banks on startup, and
     41  0000							; this gives a 1:1 correspondence between the data/addresses defined here, and
     42  0000							; the addresses in the switched-in RAM bank.
     43  0000
     44  0000							; Note: Bankswitching code between any of these banks guarantees the code can
     45  0000							; continue to run -- because, of course, the same code is still at the same
     46  0000							; memory address.
     47  0000
      0  0000					      DEFINE_SUBROUTINE	DrawTheScreen
      1  0000		       00 00	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  0000					      SUBROUTINE
      3  0000				   DrawTheScreen
     49  0000
     50  0000							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     51  0000							; A refactor of the kernel to improve the timing.
     52  0000							; Experimental refactor to remove the blank line...
     53  0000
     54  0000							; adjust here so that the first line of the kernel starts exactly at cycle 67
     55  0000							; (since TJ said it could start up to 5 cycles earlier than #67).
     56  0000
     57  0000							; TODO: remove GRP1 and COLUP1 access (or use higher resolution player)
     58  0000							;	     @57
      0  0000					      SLEEP	6	; 3
      1  0000				   .CYCLES    SET	6
      2  0000
      3  0000				  -	      IF	.CYCLES < 2
      4  0000				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0000				  -	      ERR
      6  0000					      ENDIF
      7  0000
      8  0000				  -	      IF	.CYCLES & 1
      9  0000				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0000				  -	      nop	0
     11  0000				  -	      ELSE
     12  0000				  -	      bit	VSYNC
     13  0000				  -	      ENDIF
     14  0000				  -.CYCLES    SET	.CYCLES - 3
     15  0000					      ENDIF
     16  0000
     17  0000					      REPEAT	.CYCLES / 2
     18  0000		       ea		      nop
     17  0000					      REPEND
     18  0001		       ea		      nop
     17  0001					      REPEND
     18  0002		       ea		      nop
     19  0003					      REPEND
     60  0003
     61  0003		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     62  0005		       10 3d		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     63  0007
     64  0007				   Proc2		; 5
      0  0007					      SLEEP	3	; 3	     @64
      1  0007				   .CYCLES    SET	3
      2  0007
      3  0007				  -	      IF	.CYCLES < 2
      4  0007				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0007				  -	      ERR
      6  0007					      ENDIF
      7  0007
      8  0007					      IF	.CYCLES & 1
      9  0007					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0007		       04 00		      nop	0
     11  0009				  -	      ELSE
     12  0009				  -	      bit	VSYNC
     13  0009					      ENDIF
     14  0009				   .CYCLES    SET	.CYCLES - 3
     15  0009					      ENDIF
     16  0009
     17  0009				  -	      REPEAT	.CYCLES / 2
     18  0009				  -	      nop
     19  0009					      REPEND
     66  0009		       10 3b		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     67  000b
     68  000b				   ScanRED		;	     @60
     69  000b		       b9 21 f3    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     70  000e		       85 4d		      sta	PF0	; 3	     @67
     71  0010		       b9 14 f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     72  0013		       85 4e		      sta	PF1	; 3 = 14    @74
     73  0015							;SELFMOD_PLAYERCOL_RED
     74  0015		       b9 51 f3 	      lda	PLAYER0_COLOUR,y	; 4
     75  0018							;lda #$66
     76  0018							;nop
     77  0018		       85 46		      sta	COLUP0	; 3	     @05
      0  001a					      SLEEP	3
      1  001a				   .CYCLES    SET	3
      2  001a
      3  001a				  -	      IF	.CYCLES < 2
      4  001a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  001a				  -	      ERR
      6  001a					      ENDIF
      7  001a
      8  001a					      IF	.CYCLES & 1
      9  001a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  001a		       04 00		      nop	0
     11  001c				  -	      ELSE
     12  001c				  -	      bit	VSYNC
     13  001c					      ENDIF
     14  001c				   .CYCLES    SET	.CYCLES - 3
     15  001c					      ENDIF
     16  001c
     17  001c				  -	      REPEAT	.CYCLES / 2
     18  001c				  -	      nop
     19  001c					      REPEND
     79  001c							;sta COLUP1				      ; 3 = 10	  @08
     80  001c
     81  001c							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     82  001c
     83  001c				   SELFMOD_RED
     84  001c		       a9 00		      lda	#0	; 2
     85  001e		       85 48		      sta	COLUPF	; 3 =	5    @13
     86  0020
     87  0020				   SELFMOD_PLAYER0_RED
     88  0020		       b9 39 f3 	      lda	ShapePlayerRED,y	; 4
     89  0023		       85 5b		      sta	GRP0	; 3 =	7    @20
     90  0025
     91  0025		       b9 2c f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
     92  0028		       85 4f		      sta	PF2	; 3 =	7    @27
     93  002a
     94  002a		       b9 21 f3    SM_PF0_REDr lda	CHARACTERSHAPE_BLANK,y	; 4
     95  002d		       85 4d		      sta	PF0	; 3	     @34
     96  002f		       b9 44 f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
     97  0032		       85 4e		      sta	PF1	; 3	     @41
     98  0034		       b9 5c f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
     99  0037		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
    100  0039
    101  0039				   SELFMOD_PLAYER1_RED
    102  0039		       b9 39 f3 	      lda	ShapePlayerRED,y	; 4
    103  003c							;sta.w GRP1				      ; 4 =  8	  @56	VDELed!
      0  003c					      SLEEP	4
      1  003c				   .CYCLES    SET	4
      2  003c
      3  003c				  -	      IF	.CYCLES < 2
      4  003c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  003c				  -	      ERR
      6  003c					      ENDIF
      7  003c
      8  003c				  -	      IF	.CYCLES & 1
      9  003c				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  003c				  -	      nop	0
     11  003c				  -	      ELSE
     12  003c				  -	      bit	VSYNC
     13  003c				  -	      ENDIF
     14  003c				  -.CYCLES    SET	.CYCLES - 3
     15  003c					      ENDIF
     16  003c
     17  003c					      REPEAT	.CYCLES / 2
     18  003c		       ea		      nop
     17  003c					      REPEND
     18  003d		       ea		      nop
     19  003e					      REPEND
    105  003e
    106  003e		       88		      dey		; 2
    107  003f		       10 c6		      bpl	Proc2	; 2(3)      --> 61 if taken
    108  0041
    109  0041		       e8	   SELFMOD_X  inx		; 2
    110  0042		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
    111  0044							;EXIT_RETURN_HERE
    112  0044				   NextALineStart
    113  0044		       a0 07		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
    114  0046				   ScanBLUEBD		;	     @67     let's start as late as possible
    115  0046
    116  0046							;------------------------------------------------------------------------------
    117  0046
    118  0046		       b9 21 f3    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
    119  0049		       85 4d		      sta	PF0	; 3 =	7    @74
    120  004b							;SELFMOD_PLAYERCOL_BLUE
    121  004b		       b9 61 f3 	      lda	PLAYER0_COLOUR+2*LINES_PER_CHAR/3,y	; 4
    122  004e							;lda #$66
    123  004e							;nop
    124  004e							;sta COLUP1				      ; 3	  @05
      0  004e					      SLEEP	3
      1  004e				   .CYCLES    SET	3
      2  004e
      3  004e				  -	      IF	.CYCLES < 2
      4  004e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  004e				  -	      ERR
      6  004e					      ENDIF
      7  004e
      8  004e					      IF	.CYCLES & 1
      9  004e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  004e		       04 00		      nop	0
     11  0050				  -	      ELSE
     12  0050				  -	      bit	VSYNC
     13  0050					      ENDIF
     14  0050				   .CYCLES    SET	.CYCLES - 3
     15  0050					      ENDIF
     16  0050
     17  0050				  -	      REPEAT	.CYCLES / 2
     18  0050				  -	      nop
     19  0050					      REPEND
    126  0050		       85 46		      sta	COLUP0	; 3 = 10    @08
    127  0052
    128  0052				   SELFMOD_BLUE
    129  0052		       a9 00		      lda	#0	; 2
    130  0054		       85 48		      sta	COLUPF	; 3 =	5    @13
    131  0056
    132  0056				   SELFMOD_PLAYER0_BLUE
    133  0056		       b9 39 f3 	      lda	ShapePlayerBLUE,y	; 4
    134  0059		       85 5b		      sta	GRP0	; 3 =	7    @20
    135  005b
    136  005b		       b9 24 f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    137  005e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    138  0060		       b9 3c f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    139  0063		       85 4f		      sta	PF2	; 3 = 14    @34
    140  0065
    141  0065		       b9 21 f3    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    142  0068		       85 4d		      sta	PF0	; 3	     @41
    143  006a		       b9 54 f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    144  006d		       85 4e		      sta	PF1	; 3	     @48
    145  006f		       b9 6c f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    146  0072		       85 4f		      sta	PF2	; 3 = 21    @55
    147  0074
    148  0074				   SELFMOD_PLAYER1_BLUE
    149  0074		       b9 39 f3 	      lda	ShapePlayerBLUE,y	; 4
    150  0077							;sta GRP1				      ; 3 =  7	  VDELed! @62
      0  0077					      SLEEP	3
      1  0077				   .CYCLES    SET	3
      2  0077
      3  0077				  -	      IF	.CYCLES < 2
      4  0077				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0077				  -	      ERR
      6  0077					      ENDIF
      7  0077
      8  0077					      IF	.CYCLES & 1
      9  0077					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0077		       04 00		      nop	0
     11  0079				  -	      ELSE
     12  0079				  -	      bit	VSYNC
     13  0079					      ENDIF
     14  0079				   .CYCLES    SET	.CYCLES - 3
     15  0079					      ENDIF
     16  0079
     17  0079				  -	      REPEAT	.CYCLES / 2
     18  0079				  -	      nop
     19  0079					      REPEND
    152  0079
    153  0079							;------------------------------------------------------------------------------
    154  0079
    155  0079				   ScanGREEN		;	     @62
    156  0079		       b9 21 f3    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    157  007c		       85 4d		      sta	PF0	; 3 =	7    @69
    158  007e							;SELFMOD_PLAYERCOL_GREEN
    159  007e		       b9 59 f3 	      lda	PLAYER0_COLOUR+LINES_PER_CHAR/3,y	; 4
    160  0081							;lda #$66
    161  0081							;nop
    162  0081							;sta COLUP1				      ; 3	  @00
      0  0081					      SLEEP	3
      1  0081				   .CYCLES    SET	3
      2  0081
      3  0081				  -	      IF	.CYCLES < 2
      4  0081				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0081				  -	      ERR
      6  0081					      ENDIF
      7  0081
      8  0081					      IF	.CYCLES & 1
      9  0081					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0081		       04 00		      nop	0
     11  0083				  -	      ELSE
     12  0083				  -	      bit	VSYNC
     13  0083					      ENDIF
     14  0083				   .CYCLES    SET	.CYCLES - 3
     15  0083					      ENDIF
     16  0083
     17  0083				  -	      REPEAT	.CYCLES / 2
     18  0083				  -	      nop
     19  0083					      REPEND
    164  0083		       85 46		      sta	COLUP0	; 3 = 10    @03
    165  0085
    166  0085				   SELFMOD_GREEN
    167  0085		       a9 00		      lda	#0	; 2
    168  0087		       85 48		      sta	COLUPF	; 3 =	5    @08
    169  0089
    170  0089				   SELFMOD_PLAYER0_GREEN
    171  0089		       b9 39 f3 	      lda	ShapePlayerGREEN,y	; 4
    172  008c		       85 5b		      sta	GRP0	; 3 =	7    @15
    173  008e
    174  008e		       b9 1c f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    175  0091		       85 4e		      sta	PF1	; 3	     @22
    176  0093		       b9 34 f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    177  0096		       85 4f		      sta	PF2	; 3 = 14    @29
    178  0098
    179  0098		       b9 21 f3    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    180  009b		       85 4d		      sta	PF0	; 3	     @36
    181  009d		       b9 4c f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    182  00a0		       85 4e		      sta	PF1	; 3	     @43
    183  00a2		       b9 64 f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    184  00a5		       85 4f		      sta	PF2	; 3 = 21    @50
    185  00a7
    186  00a7				   SELFMOD_PLAYER1_GREEN
    187  00a7		       b9 39 f3 	      lda	ShapePlayerGREEN,y	; 4
    188  00aa							;sta GRP1				      ; 3 =  7	  @57	  VDELed!
      0  00aa					      SLEEP	3
      1  00aa				   .CYCLES    SET	3
      2  00aa
      3  00aa				  -	      IF	.CYCLES < 2
      4  00aa				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  00aa				  -	      ERR
      6  00aa					      ENDIF
      7  00aa
      8  00aa					      IF	.CYCLES & 1
      9  00aa					      IFNCONST	NO_ILLEGAL_OPCODES
     10  00aa		       04 00		      nop	0
     11  00ac				  -	      ELSE
     12  00ac				  -	      bit	VSYNC
     13  00ac					      ENDIF
     14  00ac				   .CYCLES    SET	.CYCLES - 3
     15  00ac					      ENDIF
     16  00ac
     17  00ac				  -	      REPEAT	.CYCLES / 2
     18  00ac				  -	      nop
     19  00ac					      REPEND
    190  00ac
    191  00ac		       4c 0b f0 	      jmp	ScanRED	; 3	     @60
    192  00af
    193  00af							;------------------------------------------------------------------------------
    194  00af
    195  00af							;------------------------------------------------------------------------------
    196  00af
    197  00af							;*** Ideas: ***
    198  00af							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    199  00af							;   13.5% on average), also unrolling would be more effective than now
    200  00af							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    201  00af							;   see EXPERIMENTAL)
    202  00af							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    203  00af							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    204  00af							;   bidirectional linked list instead)
    205  00af							; - calculate mirrored gfx data into RAM (saves ROM)
    206  00af
    207  00af							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    208  00af							;currently:
    209  00af							; 72%*539 (!unrolled)
    210  00af							;+ 8%*304 (unrolled)
    211  00af							;+20%*269 (unrolled)
    212  00af							;--------
    213  00af							;=   ~466.2 cycles on average
    214  00af
    215  00af							;alternative #1:
    216  00af							; 72%*522 (unrolled)
    217  00af							;+ 8%*352 (!unrolled)
    218  00af							;+20%*307 (!unrolled)
    219  00af							;--------
    220  00af							;=   ~465.4 cycles on average
    221  00af
    222  00af
    223  00af		       00 01	   MIRROR     =	1
    224  00af		       00 80	   DIRECT     =	$80
    225  00af
    226  00af							;------------------------------------------------------------------------------
    227  00af							; Here we don't draw into a buffer, but directly patch the kernel
    228  00af							; VERY fast!
    229  00af							;
    230  00af							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    231  00af							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    232  00af
    233  00af				   PF0Draw		; 25✅ cycles until here
    234  00af
    235  00af		       ae 84 02 	      ldx	INTIM	; 4
    236  00b2		       e0 04		      cpx	#SEGTIME_SCD_PF0	; 2
    237  00b4		       90 72		      bcc	ExitDraw	; 2(3)=8✅
    238  00b6
    239  00b6		       29 7f		      and	#<(~DIRECT)	; 2
    240  00b8		       aa		      tax		; 2 =	4✅
    241  00b9
    242  00b9		       98		      tya		; 2
    243  00ba		       0a		      asl		; 2	     no mirrored chars in PF0
    244  00bb		       a8		      tay		; 2 =	6✅
    245  00bc							;		  clc				  ; 2
    246  00bc
    247  00bc		       b9 03 f3 	      lda	CharacterDataVecHI,y	; 4
    248  00bf		       9d 0d f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    249  00c2		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    250  00c5		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19✅
    251  00c8
    252  00c8		       b9 e5 f2 	      lda	CharacterDataVecLO,y	; 4
    253  00cb		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    254  00ce		       69 07		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    255  00d0		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    256  00d3		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    257  00d5		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23✅
    258  00d8
    259  00d8		       4c c3 fa 	      jmp	DrawAnother	; 3 =	[25]+8+4+6+19+24+3 = 88✅ entering DrawAnother
    260  00db
    261  00db							; Timing for PF0Draw
    262  00db							; 88
    263  00db							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    264  00db
    265  00db
    266  00db							;------------------------------------------------------------------------------
    267  00db							; Direct draw draws to PF0, which only has one active member of the character
    268  00db							; pair -- so it can be a direct copy.	Quicker still!
    269  00db
    270  00db				   DirectDraw		; 37✅ cycles until here
    271  00db
    272  00db		       ad 84 02 	      lda	INTIM	; 4
    273  00de		       c9 08		      cmp	#SEGTIME_SCD_DIRECT	; 2
    274  00e0		       90 46		      bcc	ExitDraw	; 2(3)=8
    275  00e2							; => [37]+(9)+6rts = 51 cycles if draw exits
    276  00e2
    277  00e2							; @ [37]+8 =45✅
    278  00e2
    279  00e2		       b9 03 f3 	      lda	CharacterDataVecHI,y	; 4
    280  00e5		       8d 12 f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    281  00e8		       8d 18 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    282  00eb		       8d 1e f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    283  00ee
    284  00ee		       b9 e5 f2 	      lda	CharacterDataVecLO,y	; 4
    285  00f1		       8d 11 f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    286  00f4		       69 07		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    287  00f6		       8d 17 f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    288  00f9		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    289  00fb		       8d 1d f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    290  00fe
    291  00fe		       bd b2 f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    292  0101		       8d 14 f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    293  0104		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    294  0106		       8d 1a f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    295  0109		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    296  010b		       8d 20 f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    297  010e
    298  010e		       a0 07		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    299  0110
    300  0110							; @45+16+20+20+2 = @103
    301  0110				   TSFill3		; 8*{...
    302  0110		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    303  0113		       99 14 f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    304  0116		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    305  0119		       99 14 f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    306  011c		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    307  011f		       99 14 f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    308  0122
    309  0122		       88		      dey		; 2
      0  0123					      CHECKPAGE_BPL	TSFill3	; 3(2)=5 ...32✅} = 8*32-1 = 255
      8  0123					      LIST	ON
      9  0123		       10 eb		      bpl	TSFill3
    311  0125
    312  0125		       4c c3 fa 	      jmp	DrawAnother	; 3
    313  0128							; => @103+255+3 = 361✅ entering DrawAnother
    314  0128
    315  0128		       60	   ExitDraw   rts		; 6
    316  0129
    317  0129							;------------------------------------------------------------------------------
    318  0129
      0  0129					      DEFINE_SUBROUTINE	StealPart3	; [18]✅ CYCLES TO HERE
      1  0129		       00 00	   BANK_StealPart3 =	_CURRENT_BANK
      2  0129					      SUBROUTINE
      3  0129				   StealPart3
    320  0129
    321  0129		       bd c4 f1 	      lda	MOD10,x	; 4
    322  012c		       30 81		      bmi	PF0Draw	; 2/3 --> 25 cycles entering PF0Draw
    323  012e
    324  012e		       4a		      lsr		; 2
    325  012f		       aa		      tax		; 2
    326  0130		       98		      tya		; 2
    327  0131		       2a		      rol		; 2	       allows for mirrored char = * | 1
    328  0132		       a8		      tay		; 2
    329  0133		       b0 a6		      bcs	DirectDraw	; 2(3) = 18✅ when draw stack was built, bit 7 flags direct-drawn character
    330  0135							; ==> [18]+{19) = 37 @ start of DirectDraw
    331  0135
    332  0135		       b9 03 f3 	      lda	CharacterDataVecHI,y	; 4
    333  0138		       10 38		      bpl	QuickDraw	; 2(3) = 6(7)	 special-case blank characters for extra speed
    334  013a							; => [18]+18+(7) = 43✅ starting QuickDraw
    335  013a							; +15 => 58✅ if QuickDraw exits
    336  013a
    337  013a							; @ 24
    338  013a
    339  013a		       8d 63 f5 	      sta	SMEOR1+RAM_WRITE+2	; 4
    340  013d
    341  013d		       ad 84 02 	      lda	INTIM	; 4
    342  0140		       c9 0d		      cmp	#SEGTIME_SCD_SLOW	; 2
    343  0142		       90 e4		      bcc	ExitDraw	; 2(3) = 8
    344  0144							; => [18]+55+6rts=79✅ cycles if we decline
    345  0144
    346  0144							; @36
    347  0144							; [18]+36 = @54
    348  0144
    349  0144		       b9 e5 f2 	      lda	CharacterDataVecLO,y	; 4
    350  0147		       8d 62 f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    351  014a
    352  014a		       bd b2 f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    353  014d		       8d 5f f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    354  0150		       8d 67 f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    355  0153		       8d 6a f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    356  0156
    357  0156		       bd bc f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    358  0159		       8d 65 f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    359  015c
    360  015c		       a0 17	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2 => @88+
    361  015e
    362  015e							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    363  015e							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    364  015e
    365  015e				   TSFill		; 24*{...✅
    366  015e
    367  015e		       b9 14 f2    SMLOAD     lda	ScreenBitmap,y	; 4
    368  0161		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    369  0164		       29 00	   SMMASK     and	#0	; 2
    370  0166		       59 14 f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    371  0169		       99 14 f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    372  016c
    373  016c		       88		      dey		; 2
      0  016d					      CHECKPAGE_BPL	TSFill	; 3(2)=5  ...24}-1 = 575✅
      8  016d					      LIST	ON
      9  016d		       10 ef		      bpl	TSFill
    375  016f
    376  016f		       4c c3 fa 	      jmp	DrawAnother	; 3 = @88+575+3 = @676✅
    377  0172
    378  0172
    379  0172							;------------------------------------------------------------------------------
    380  0172							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    381  0172							; existing character data, so can be special-cased from the normal character
    382  0172							; draw, saving roughly 230 cycles.
    383  0172
    384  0172				   QuickDraw		; [43]✅ cycles until here
    385  0172
    386  0172		       ad 84 02 	      lda	INTIM	; 4
    387  0175		       c9 08		      cmp	#SEGTIME_SCD_QUICK	; 2
    388  0177		       90 af		      bcc	ExitDraw	; 2(3)=8(9)
    389  0179							; =>[43]+(9)+6rts =58✅ if exit
    390  0179							;@[43]+8=51✅
    391  0179
    392  0179		       bd b2 f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    393  017c		       8d 99 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    394  017f		       8d 9c f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    395  0182		       69 07		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    396  0184		       8d a0 f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    397  0187		       8d a3 f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    398  018a		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    399  018c		       8d a7 f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    400  018f		       8d aa f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32✅
    401  0192
    402  0192		       bc ba f1 	      ldy	CharMask,x	; 4	     masks out left or right
    403  0195
    404  0195		       a2 07		      ldx	#LINES_PER_CHAR/3 - 1	; 2	     =32+4+2+8*{...✅
    405  0197				   TSFill2
    406  0197		       98		      tya		; 2
    407  0198		       3d 14 f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    408  019b		       9d 14 f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    409  019e		       98		      tya		; 2
    410  019f		       3d 14 f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    411  01a2		       9d 14 f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    412  01a5		       98		      tya		; 2
    413  01a6		       3d 14 f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    414  01a9		       9d 14 f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33✅
    415  01ac
    416  01ac		       ca		      dex		; 2
      0  01ad					      CHECKPAGE_BPL	TSFill2	; 3(2) = 5  ...} = 32+4+2+8*38-1
      8  01ad					      LIST	ON
      9  01ad		       10 e8		      bpl	TSFill2
    418  01af							;		  => 341✅
    419  01af
    420  01af		       4c c3 fa 	      jmp	DrawAnother	; 3 = 344
    421  01b2
    422  01b2							;------------------------------------------------------------------------------
    423  01b2
    424  01b2
    425  01b2				   CharAddressLO		;[abs char location % 10]
    426  01b2
    427  01b2							; Gives the absolute screen buffer address of the first line of the given character
    428  01b2							; Where character number is 0-9
    429  01b2
    430  01b2		       14		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    431  01b3		       14		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    432  01b4		       2c		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    433  01b5		       2c		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    434  01b6		       44		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    435  01b7		       44		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    436  01b8		       5c		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    437  01b9		       5c		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    438  01ba							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    439  01ba							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    440  01ba
    441  01ba				   CharMask		; [abs char location % 10]
    442  01ba
    443  01ba							; Gives the mask for any char of the screen (per row)
    444  01ba							; Note, this is hardwired to the screen format of 6 bytes/line
    445  01ba
    446  01ba		       0f		      .byte.b	$0F	; 1
    447  01bb		       f0		      .byte.b	$F0	; 2
    448  01bc				   CharMaskNeg
    449  01bc		       f0		      .byte.b	$F0	; 3/1
    450  01bd		       0f		      .byte.b	$0F	; 4/2
    451  01be		       0f		      .byte.b	$0F	; 6/3
    452  01bf		       f0		      .byte.b	$F0	; 7/4
    453  01c0		       f0		      .byte.b	$F0	; 8/6
    454  01c1		       0f		      .byte.b	$0F	; 9/7
    455  01c2		       0f		      .byte.b	$0F	; -/8
    456  01c3		       f0		      .byte.b	$F0	; -/9
    457  01c4				   MOD10
    458  01c4					      REPEAT	SCREEN_LINES
    459  01c4							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  01c4							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  01c4		       80		      .byte.b	DIRECT
    462  01c5		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  01c9		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  01ca		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  01ca					      REPEND
    459  01ce							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  01ce							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  01ce		       80		      .byte.b	DIRECT
    462  01cf		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  01d3		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  01d4		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  01d4					      REPEND
    459  01d8							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  01d8							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  01d8		       80		      .byte.b	DIRECT
    462  01d9		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  01dd		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  01de		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  01de					      REPEND
    459  01e2							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  01e2							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  01e2		       80		      .byte.b	DIRECT
    462  01e3		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  01e7		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  01e8		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  01e8					      REPEND
    459  01ec							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  01ec							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  01ec		       80		      .byte.b	DIRECT
    462  01ed		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  01f1		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  01f2		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  01f2					      REPEND
    459  01f6							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  01f6							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  01f6		       80		      .byte.b	DIRECT
    462  01f7		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  01fb		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  01fc		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  01fc					      REPEND
    459  0200							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  0200							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  0200		       80		      .byte.b	DIRECT
    462  0201		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  0205		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  0206		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  0206					      REPEND
    459  020a							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  020a							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  020a		       80		      .byte.b	DIRECT
    462  020b		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  020f		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  0210		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    465  0214					      REPEND
    466  0214
    467  0214							;------------------------------------------------------------------------------
    468  0214
      0  0214					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  0214					      LIST	ON
    470  0214
    471  0214		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,0	; character bitmap row (10 chars wide)
    472  0214		       f2 14	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    473  0214		       f2 1c	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    474  0214		       f2 24	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    475  0274
      0  0274					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  0274					      LIST	ON
    477  0274
    478  0274
    479  0274							;--------------------------------------------------------------------------
    480  0274
      0  0274					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  0274		       00 00	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  0274					      SUBROUTINE
      3  0274				   SelfModDrawPlayers
    482  0274
    483  0274							; Update the appropriate shape pointers in the draw code.
    484  0274							; First, set the shape to a blank player -- effectively erasing
    485  0274
    486  0274		       a6 af		      ldx	LastSpriteY
    487  0276		       30 15		      bmi	erased	; offscreen
    488  0278		       e4 a0		      cpx	ManDrawY
    489  027a		       f0 28		      beq	NoMod	; same line, so all should be OK already
    490  027c
    491  027c		       86 3e		      stx	SET_BANK_RAM	; switch old bank in (this code too!!!!)
    492  027e
    493  027e		       a9 21		      lda	#<PLAYER_BLANK	; "erase"
    494  0280		       8d 21 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1
    495  0283		       a9 29		      lda	#<PLAYER_BLANK + LINES_PER_CHAR/3
    496  0285		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    497  0288		       a9 31		      lda	#<PLAYER_BLANK + 2*LINES_PER_CHAR/3
    498  028a		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    499  028d
    500  028d							; Now we've erased, we write the new shape
    501  028d
    502  028d		       a6 a0	   erased     ldx	ManDrawY
    503  028f		       86 af		      stx	LastSpriteY
    504  0291		       30 11		      bmi	NoMod
    505  0293
    506  0293		       86 3e		      stx	SET_BANK_RAM	; switch new bank in (this code too!!!!)
    507  0295
    508  0295		       a9 39		      lda	#<PLAYER0_SHAPE	; draw buffer holding the new frame shape
    509  0297		       8d 21 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1
    510  029a		       a9 41		      lda	#<PLAYER0_SHAPE + LINES_PER_CHAR/3
    511  029c		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    512  029f		       a9 49		      lda	#<PLAYER0_SHAPE + 2*LINES_PER_CHAR/3
    513  02a1		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    514  02a4
    515  02a4		       60	   NoMod      rts
    516  02a5
      0  02a5					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  02a5
      2  02a5
      3  02a5		       02 a5	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $2a5 , FREE= $15b
      4  02a5					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  02a5				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  02a5				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  02a5				  -	      ERR
      8  02a5					      endif
    518  02a5
    519  02a5							;------------------------------------------------------------------------------
    520  02a5
    521  02a5							; The acutal colour palette to use for the player. The player may be any "ethnicity" which refers
    522  02a5							; to the colours for a frame. The skin could be asian/black/caucasian, the cloting could be anything.
    523  02a5							; Each ethnicity is defined as first 8 bytes for NTSC and then 8 bytes for PAL. The 8 bytes refer
    524  02a5							; to the "CL#" index values defined in the player COLOUR frames. So, an index is grabbed from the
    525  02a5							; player frame, it is adjusted to add the base ethnicity and the NTSC/PAL, and that gives the base
    526  02a5							; for reading 8 successive bytes for CL0..CL7 from the frame definitions.
    527  02a5
    528  02a5				   EthnicityColourPalette
    529  02a5
    530  02a5							; CL0	   = BLACK
    531  02a5							; CL1	   = HAT
    532  02a5							; CL2	   = SKIN
    533  02a5							; CL3	   = CUFFS/TRIM
    534  02a5							; CL4	   = JUMPER
    535  02a5							; CL5	   = PANTS
    536  02a5							; CL6	   = SHOES
    537  02a5							; CL7	   = UNUSED
    538  02a5
    539  02a5							; CL7 = NOT USABLE
    540  02a5
    541  02a5							; (*) = unchecked/converted
    542  02a5
    543  02a5					      MAC	colour_group
    544  02a5							; NTSC...
    545  02a5					      .byte	0
    546  02a5					      .byte	{1}+{2}
    547  02a5					      .byte	{3}+{4}
    548  02a5					      .byte	{5}+{6}
    549  02a5					      .byte	{7}+{8}
    550  02a5					      .byte	{9}+{10}
    551  02a5					      .byte	{11}+{12}
    552  02a5					      .byte	0
    553  02a5
    554  02a5							; PAL...
    555  02a5					      .byte	0
    556  02a5					      NTSC_TO_PAL	{1}, {2}
    557  02a5					      NTSC_TO_PAL	{3}, {4}
    558  02a5					      NTSC_TO_PAL	{5}, {6}
    559  02a5					      NTSC_TO_PAL	{7}, {8}
    560  02a5					      NTSC_TO_PAL	{9}, {10}
    561  02a5					      NTSC_TO_PAL	{11}, {12}
    562  02a5					      .byte	0
    563  02a5					      ENDM
    564  02a5
    565  02a5							; USE NTSC COLOUR+INTENSITY. WILL AUTO-ADD PAL EQUIVALENT...
    566  02a5							;		 HAT	 FACE	 TRIM	 JUMPER  PANTS	SHOES
      0  02a5					      COLOUR_GROUP	$10,$A, $40,$8, $00,$C, $80,$8, $90,6, $10,6	; 0
      1  02a5
      2  02a5		       00		      .byte.b	0
      3  02a6		       1a		      .byte.b	$10+$A
      4  02a7		       48		      .byte.b	$40+$8
      5  02a8		       0c		      .byte.b	$00+$C
      6  02a9		       88		      .byte.b	$80+$8
      7  02aa		       96		      .byte.b	$90+6
      8  02ab		       16		      .byte.b	$10+6
      9  02ac		       00		      .byte.b	0
     10  02ad
     11  02ad
     12  02ad		       00		      .byte.b	0
      0  02ae					      NTSC_TO_PAL	$10, $A
      1  02ae				  -	      IF	$10 = 0
      2  02ae				  -	      .byte	$10+$A
      3  02ae					      ENDIF
      4  02ae					      IF	$10 = $10
      5  02ae		       2a		      .byte.b	$20+$A
      6  02af					      ENDIF
      7  02af				  -	      IF	$10 = $20
      8  02af				  -	      .byte	$40+$A
      9  02af					      ENDIF
     10  02af				  -	      IF	$10 = $30
     11  02af				  -	      .byte	$40+$A
     12  02af					      ENDIF
     13  02af				  -	      IF	$10 = $40
     14  02af				  -	      .byte	$60+$A
     15  02af					      ENDIF
     16  02af				  -	      IF	$10 = $50
     17  02af				  -	      .byte	$80+$A
     18  02af					      ENDIF
     19  02af				  -	      IF	$10 = $60
     20  02af				  -	      .byte	$C0+$A
     21  02af					      ENDIF
     22  02af				  -	      IF	$10 = $70
     23  02af				  -	      .byte	$D0+$A
     24  02af					      ENDIF
     25  02af				  -	      IF	$10 = $80
     26  02af				  -	      .byte	$B0+$A
     27  02af					      ENDIF
     28  02af				  -	      IF	$10 = $90
     29  02af				  -	      .byte	$90+$A
     30  02af					      ENDIF
     31  02af				  -	      IF	$10 = $A0
     32  02af				  -	      .byte	$70+$A
     33  02af					      ENDIF
     34  02af				  -	      IF	$10 = $B0
     35  02af				  -	      .byte	$50+$A
     36  02af					      ENDIF
     37  02af				  -	      IF	$10 = $C0
     38  02af				  -	      .byte	$30+$A
     39  02af					      ENDIF
     40  02af				  -	      IF	$10 = $D0
     41  02af				  -	      .byte	$30+$A
     42  02af					      ENDIF
     43  02af				  -	      IF	$10 = $E0
     44  02af				  -	      .byte	$20+$A
     45  02af					      ENDIF
     46  02af				  -	      IF	$10 = $F0
     47  02af				  -	      .byte	$40+$A
     48  02af					      ENDIF
      0  02af					      NTSC_TO_PAL	$40, $8
      1  02af				  -	      IF	$40 = 0
      2  02af				  -	      .byte	$40+$8
      3  02af					      ENDIF
      4  02af				  -	      IF	$40 = $10
      5  02af				  -	      .byte	$20+$8
      6  02af					      ENDIF
      7  02af				  -	      IF	$40 = $20
      8  02af				  -	      .byte	$40+$8
      9  02af					      ENDIF
     10  02af				  -	      IF	$40 = $30
     11  02af				  -	      .byte	$40+$8
     12  02af					      ENDIF
     13  02af					      IF	$40 = $40
     14  02af		       68		      .byte.b	$60+$8
     15  02b0					      ENDIF
     16  02b0				  -	      IF	$40 = $50
     17  02b0				  -	      .byte	$80+$8
     18  02b0					      ENDIF
     19  02b0				  -	      IF	$40 = $60
     20  02b0				  -	      .byte	$C0+$8
     21  02b0					      ENDIF
     22  02b0				  -	      IF	$40 = $70
     23  02b0				  -	      .byte	$D0+$8
     24  02b0					      ENDIF
     25  02b0				  -	      IF	$40 = $80
     26  02b0				  -	      .byte	$B0+$8
     27  02b0					      ENDIF
     28  02b0				  -	      IF	$40 = $90
     29  02b0				  -	      .byte	$90+$8
     30  02b0					      ENDIF
     31  02b0				  -	      IF	$40 = $A0
     32  02b0				  -	      .byte	$70+$8
     33  02b0					      ENDIF
     34  02b0				  -	      IF	$40 = $B0
     35  02b0				  -	      .byte	$50+$8
     36  02b0					      ENDIF
     37  02b0				  -	      IF	$40 = $C0
     38  02b0				  -	      .byte	$30+$8
     39  02b0					      ENDIF
     40  02b0				  -	      IF	$40 = $D0
     41  02b0				  -	      .byte	$30+$8
     42  02b0					      ENDIF
     43  02b0				  -	      IF	$40 = $E0
     44  02b0				  -	      .byte	$20+$8
     45  02b0					      ENDIF
     46  02b0				  -	      IF	$40 = $F0
     47  02b0				  -	      .byte	$40+$8
     48  02b0					      ENDIF
      0  02b0					      NTSC_TO_PAL	$00, $C
      1  02b0					      IF	$00 = 0
      2  02b0		       0c		      .byte.b	$00+$C
      3  02b1					      ENDIF
      4  02b1				  -	      IF	$00 = $10
      5  02b1				  -	      .byte	$20+$C
      6  02b1					      ENDIF
      7  02b1				  -	      IF	$00 = $20
      8  02b1				  -	      .byte	$40+$C
      9  02b1					      ENDIF
     10  02b1				  -	      IF	$00 = $30
     11  02b1				  -	      .byte	$40+$C
     12  02b1					      ENDIF
     13  02b1				  -	      IF	$00 = $40
     14  02b1				  -	      .byte	$60+$C
     15  02b1					      ENDIF
     16  02b1				  -	      IF	$00 = $50
     17  02b1				  -	      .byte	$80+$C
     18  02b1					      ENDIF
     19  02b1				  -	      IF	$00 = $60
     20  02b1				  -	      .byte	$C0+$C
     21  02b1					      ENDIF
     22  02b1				  -	      IF	$00 = $70
     23  02b1				  -	      .byte	$D0+$C
     24  02b1					      ENDIF
     25  02b1				  -	      IF	$00 = $80
     26  02b1				  -	      .byte	$B0+$C
     27  02b1					      ENDIF
     28  02b1				  -	      IF	$00 = $90
     29  02b1				  -	      .byte	$90+$C
     30  02b1					      ENDIF
     31  02b1				  -	      IF	$00 = $A0
     32  02b1				  -	      .byte	$70+$C
     33  02b1					      ENDIF
     34  02b1				  -	      IF	$00 = $B0
     35  02b1				  -	      .byte	$50+$C
     36  02b1					      ENDIF
     37  02b1				  -	      IF	$00 = $C0
     38  02b1				  -	      .byte	$30+$C
     39  02b1					      ENDIF
     40  02b1				  -	      IF	$00 = $D0
     41  02b1				  -	      .byte	$30+$C
     42  02b1					      ENDIF
     43  02b1				  -	      IF	$00 = $E0
     44  02b1				  -	      .byte	$20+$C
     45  02b1					      ENDIF
     46  02b1				  -	      IF	$00 = $F0
     47  02b1				  -	      .byte	$40+$C
     48  02b1					      ENDIF
      0  02b1					      NTSC_TO_PAL	$80, $8
      1  02b1				  -	      IF	$80 = 0
      2  02b1				  -	      .byte	$80+$8
      3  02b1					      ENDIF
      4  02b1				  -	      IF	$80 = $10
      5  02b1				  -	      .byte	$20+$8
      6  02b1					      ENDIF
      7  02b1				  -	      IF	$80 = $20
      8  02b1				  -	      .byte	$40+$8
      9  02b1					      ENDIF
     10  02b1				  -	      IF	$80 = $30
     11  02b1				  -	      .byte	$40+$8
     12  02b1					      ENDIF
     13  02b1				  -	      IF	$80 = $40
     14  02b1				  -	      .byte	$60+$8
     15  02b1					      ENDIF
     16  02b1				  -	      IF	$80 = $50
     17  02b1				  -	      .byte	$80+$8
     18  02b1					      ENDIF
     19  02b1				  -	      IF	$80 = $60
     20  02b1				  -	      .byte	$C0+$8
     21  02b1					      ENDIF
     22  02b1				  -	      IF	$80 = $70
     23  02b1				  -	      .byte	$D0+$8
     24  02b1					      ENDIF
     25  02b1					      IF	$80 = $80
     26  02b1		       b8		      .byte.b	$B0+$8
     27  02b2					      ENDIF
     28  02b2				  -	      IF	$80 = $90
     29  02b2				  -	      .byte	$90+$8
     30  02b2					      ENDIF
     31  02b2				  -	      IF	$80 = $A0
     32  02b2				  -	      .byte	$70+$8
     33  02b2					      ENDIF
     34  02b2				  -	      IF	$80 = $B0
     35  02b2				  -	      .byte	$50+$8
     36  02b2					      ENDIF
     37  02b2				  -	      IF	$80 = $C0
     38  02b2				  -	      .byte	$30+$8
     39  02b2					      ENDIF
     40  02b2				  -	      IF	$80 = $D0
     41  02b2				  -	      .byte	$30+$8
     42  02b2					      ENDIF
     43  02b2				  -	      IF	$80 = $E0
     44  02b2				  -	      .byte	$20+$8
     45  02b2					      ENDIF
     46  02b2				  -	      IF	$80 = $F0
     47  02b2				  -	      .byte	$40+$8
     48  02b2					      ENDIF
      0  02b2					      NTSC_TO_PAL	$90, 6
      1  02b2				  -	      IF	$90 = 0
      2  02b2				  -	      .byte	$90+6
      3  02b2					      ENDIF
      4  02b2				  -	      IF	$90 = $10
      5  02b2				  -	      .byte	$20+6
      6  02b2					      ENDIF
      7  02b2				  -	      IF	$90 = $20
      8  02b2				  -	      .byte	$40+6
      9  02b2					      ENDIF
     10  02b2				  -	      IF	$90 = $30
     11  02b2				  -	      .byte	$40+6
     12  02b2					      ENDIF
     13  02b2				  -	      IF	$90 = $40
     14  02b2				  -	      .byte	$60+6
     15  02b2					      ENDIF
     16  02b2				  -	      IF	$90 = $50
     17  02b2				  -	      .byte	$80+6
     18  02b2					      ENDIF
     19  02b2				  -	      IF	$90 = $60
     20  02b2				  -	      .byte	$C0+6
     21  02b2					      ENDIF
     22  02b2				  -	      IF	$90 = $70
     23  02b2				  -	      .byte	$D0+6
     24  02b2					      ENDIF
     25  02b2				  -	      IF	$90 = $80
     26  02b2				  -	      .byte	$B0+6
     27  02b2					      ENDIF
     28  02b2					      IF	$90 = $90
     29  02b2		       96		      .byte.b	$90+6
     30  02b3					      ENDIF
     31  02b3				  -	      IF	$90 = $A0
     32  02b3				  -	      .byte	$70+6
     33  02b3					      ENDIF
     34  02b3				  -	      IF	$90 = $B0
     35  02b3				  -	      .byte	$50+6
     36  02b3					      ENDIF
     37  02b3				  -	      IF	$90 = $C0
     38  02b3				  -	      .byte	$30+6
     39  02b3					      ENDIF
     40  02b3				  -	      IF	$90 = $D0
     41  02b3				  -	      .byte	$30+6
     42  02b3					      ENDIF
     43  02b3				  -	      IF	$90 = $E0
     44  02b3				  -	      .byte	$20+6
     45  02b3					      ENDIF
     46  02b3				  -	      IF	$90 = $F0
     47  02b3				  -	      .byte	$40+6
     48  02b3					      ENDIF
      0  02b3					      NTSC_TO_PAL	$10, 6
      1  02b3				  -	      IF	$10 = 0
      2  02b3				  -	      .byte	$10+6
      3  02b3					      ENDIF
      4  02b3					      IF	$10 = $10
      5  02b3		       26		      .byte.b	$20+6
      6  02b4					      ENDIF
      7  02b4				  -	      IF	$10 = $20
      8  02b4				  -	      .byte	$40+6
      9  02b4					      ENDIF
     10  02b4				  -	      IF	$10 = $30
     11  02b4				  -	      .byte	$40+6
     12  02b4					      ENDIF
     13  02b4				  -	      IF	$10 = $40
     14  02b4				  -	      .byte	$60+6
     15  02b4					      ENDIF
     16  02b4				  -	      IF	$10 = $50
     17  02b4				  -	      .byte	$80+6
     18  02b4					      ENDIF
     19  02b4				  -	      IF	$10 = $60
     20  02b4				  -	      .byte	$C0+6
     21  02b4					      ENDIF
     22  02b4				  -	      IF	$10 = $70
     23  02b4				  -	      .byte	$D0+6
     24  02b4					      ENDIF
     25  02b4				  -	      IF	$10 = $80
     26  02b4				  -	      .byte	$B0+6
     27  02b4					      ENDIF
     28  02b4				  -	      IF	$10 = $90
     29  02b4				  -	      .byte	$90+6
     30  02b4					      ENDIF
     31  02b4				  -	      IF	$10 = $A0
     32  02b4				  -	      .byte	$70+6
     33  02b4					      ENDIF
     34  02b4				  -	      IF	$10 = $B0
     35  02b4				  -	      .byte	$50+6
     36  02b4					      ENDIF
     37  02b4				  -	      IF	$10 = $C0
     38  02b4				  -	      .byte	$30+6
     39  02b4					      ENDIF
     40  02b4				  -	      IF	$10 = $D0
     41  02b4				  -	      .byte	$30+6
     42  02b4					      ENDIF
     43  02b4				  -	      IF	$10 = $E0
     44  02b4				  -	      .byte	$20+6
     45  02b4					      ENDIF
     46  02b4				  -	      IF	$10 = $F0
     47  02b4				  -	      .byte	$40+6
     48  02b4					      ENDIF
     19  02b4		       00		      .byte.b	0
      0  02b5					      COLOUR_GROUP	$10,$A, $F0,$8, $60,$C, $50,$4, $70,6, $40,6	; 1
      1  02b5
      2  02b5		       00		      .byte.b	0
      3  02b6		       1a		      .byte.b	$10+$A
      4  02b7		       f8		      .byte.b	$F0+$8
      5  02b8		       6c		      .byte.b	$60+$C
      6  02b9		       54		      .byte.b	$50+$4
      7  02ba		       76		      .byte.b	$70+6
      8  02bb		       46		      .byte.b	$40+6
      9  02bc		       00		      .byte.b	0
     10  02bd
     11  02bd
     12  02bd		       00		      .byte.b	0
      0  02be					      NTSC_TO_PAL	$10, $A
      1  02be				  -	      IF	$10 = 0
      2  02be				  -	      .byte	$10+$A
      3  02be					      ENDIF
      4  02be					      IF	$10 = $10
      5  02be		       2a		      .byte.b	$20+$A
      6  02bf					      ENDIF
      7  02bf				  -	      IF	$10 = $20
      8  02bf				  -	      .byte	$40+$A
      9  02bf					      ENDIF
     10  02bf				  -	      IF	$10 = $30
     11  02bf				  -	      .byte	$40+$A
     12  02bf					      ENDIF
     13  02bf				  -	      IF	$10 = $40
     14  02bf				  -	      .byte	$60+$A
     15  02bf					      ENDIF
     16  02bf				  -	      IF	$10 = $50
     17  02bf				  -	      .byte	$80+$A
     18  02bf					      ENDIF
     19  02bf				  -	      IF	$10 = $60
     20  02bf				  -	      .byte	$C0+$A
     21  02bf					      ENDIF
     22  02bf				  -	      IF	$10 = $70
     23  02bf				  -	      .byte	$D0+$A
     24  02bf					      ENDIF
     25  02bf				  -	      IF	$10 = $80
     26  02bf				  -	      .byte	$B0+$A
     27  02bf					      ENDIF
     28  02bf				  -	      IF	$10 = $90
     29  02bf				  -	      .byte	$90+$A
     30  02bf					      ENDIF
     31  02bf				  -	      IF	$10 = $A0
     32  02bf				  -	      .byte	$70+$A
     33  02bf					      ENDIF
     34  02bf				  -	      IF	$10 = $B0
     35  02bf				  -	      .byte	$50+$A
     36  02bf					      ENDIF
     37  02bf				  -	      IF	$10 = $C0
     38  02bf				  -	      .byte	$30+$A
     39  02bf					      ENDIF
     40  02bf				  -	      IF	$10 = $D0
     41  02bf				  -	      .byte	$30+$A
     42  02bf					      ENDIF
     43  02bf				  -	      IF	$10 = $E0
     44  02bf				  -	      .byte	$20+$A
     45  02bf					      ENDIF
     46  02bf				  -	      IF	$10 = $F0
     47  02bf				  -	      .byte	$40+$A
     48  02bf					      ENDIF
      0  02bf					      NTSC_TO_PAL	$F0, $8
      1  02bf				  -	      IF	$F0 = 0
      2  02bf				  -	      .byte	$F0+$8
      3  02bf					      ENDIF
      4  02bf				  -	      IF	$F0 = $10
      5  02bf				  -	      .byte	$20+$8
      6  02bf					      ENDIF
      7  02bf				  -	      IF	$F0 = $20
      8  02bf				  -	      .byte	$40+$8
      9  02bf					      ENDIF
     10  02bf				  -	      IF	$F0 = $30
     11  02bf				  -	      .byte	$40+$8
     12  02bf					      ENDIF
     13  02bf				  -	      IF	$F0 = $40
     14  02bf				  -	      .byte	$60+$8
     15  02bf					      ENDIF
     16  02bf				  -	      IF	$F0 = $50
     17  02bf				  -	      .byte	$80+$8
     18  02bf					      ENDIF
     19  02bf				  -	      IF	$F0 = $60
     20  02bf				  -	      .byte	$C0+$8
     21  02bf					      ENDIF
     22  02bf				  -	      IF	$F0 = $70
     23  02bf				  -	      .byte	$D0+$8
     24  02bf					      ENDIF
     25  02bf				  -	      IF	$F0 = $80
     26  02bf				  -	      .byte	$B0+$8
     27  02bf					      ENDIF
     28  02bf				  -	      IF	$F0 = $90
     29  02bf				  -	      .byte	$90+$8
     30  02bf					      ENDIF
     31  02bf				  -	      IF	$F0 = $A0
     32  02bf				  -	      .byte	$70+$8
     33  02bf					      ENDIF
     34  02bf				  -	      IF	$F0 = $B0
     35  02bf				  -	      .byte	$50+$8
     36  02bf					      ENDIF
     37  02bf				  -	      IF	$F0 = $C0
     38  02bf				  -	      .byte	$30+$8
     39  02bf					      ENDIF
     40  02bf				  -	      IF	$F0 = $D0
     41  02bf				  -	      .byte	$30+$8
     42  02bf					      ENDIF
     43  02bf				  -	      IF	$F0 = $E0
     44  02bf				  -	      .byte	$20+$8
     45  02bf					      ENDIF
     46  02bf					      IF	$F0 = $F0
     47  02bf		       48		      .byte.b	$40+$8
     48  02c0					      ENDIF
      0  02c0					      NTSC_TO_PAL	$60, $C
      1  02c0				  -	      IF	$60 = 0
      2  02c0				  -	      .byte	$60+$C
      3  02c0					      ENDIF
      4  02c0				  -	      IF	$60 = $10
      5  02c0				  -	      .byte	$20+$C
      6  02c0					      ENDIF
      7  02c0				  -	      IF	$60 = $20
      8  02c0				  -	      .byte	$40+$C
      9  02c0					      ENDIF
     10  02c0				  -	      IF	$60 = $30
     11  02c0				  -	      .byte	$40+$C
     12  02c0					      ENDIF
     13  02c0				  -	      IF	$60 = $40
     14  02c0				  -	      .byte	$60+$C
     15  02c0					      ENDIF
     16  02c0				  -	      IF	$60 = $50
     17  02c0				  -	      .byte	$80+$C
     18  02c0					      ENDIF
     19  02c0					      IF	$60 = $60
     20  02c0		       cc		      .byte.b	$C0+$C
     21  02c1					      ENDIF
     22  02c1				  -	      IF	$60 = $70
     23  02c1				  -	      .byte	$D0+$C
     24  02c1					      ENDIF
     25  02c1				  -	      IF	$60 = $80
     26  02c1				  -	      .byte	$B0+$C
     27  02c1					      ENDIF
     28  02c1				  -	      IF	$60 = $90
     29  02c1				  -	      .byte	$90+$C
     30  02c1					      ENDIF
     31  02c1				  -	      IF	$60 = $A0
     32  02c1				  -	      .byte	$70+$C
     33  02c1					      ENDIF
     34  02c1				  -	      IF	$60 = $B0
     35  02c1				  -	      .byte	$50+$C
     36  02c1					      ENDIF
     37  02c1				  -	      IF	$60 = $C0
     38  02c1				  -	      .byte	$30+$C
     39  02c1					      ENDIF
     40  02c1				  -	      IF	$60 = $D0
     41  02c1				  -	      .byte	$30+$C
     42  02c1					      ENDIF
     43  02c1				  -	      IF	$60 = $E0
     44  02c1				  -	      .byte	$20+$C
     45  02c1					      ENDIF
     46  02c1				  -	      IF	$60 = $F0
     47  02c1				  -	      .byte	$40+$C
     48  02c1					      ENDIF
      0  02c1					      NTSC_TO_PAL	$50, $4
      1  02c1				  -	      IF	$50 = 0
      2  02c1				  -	      .byte	$50+$4
      3  02c1					      ENDIF
      4  02c1				  -	      IF	$50 = $10
      5  02c1				  -	      .byte	$20+$4
      6  02c1					      ENDIF
      7  02c1				  -	      IF	$50 = $20
      8  02c1				  -	      .byte	$40+$4
      9  02c1					      ENDIF
     10  02c1				  -	      IF	$50 = $30
     11  02c1				  -	      .byte	$40+$4
     12  02c1					      ENDIF
     13  02c1				  -	      IF	$50 = $40
     14  02c1				  -	      .byte	$60+$4
     15  02c1					      ENDIF
     16  02c1					      IF	$50 = $50
     17  02c1		       84		      .byte.b	$80+$4
     18  02c2					      ENDIF
     19  02c2				  -	      IF	$50 = $60
     20  02c2				  -	      .byte	$C0+$4
     21  02c2					      ENDIF
     22  02c2				  -	      IF	$50 = $70
     23  02c2				  -	      .byte	$D0+$4
     24  02c2					      ENDIF
     25  02c2				  -	      IF	$50 = $80
     26  02c2				  -	      .byte	$B0+$4
     27  02c2					      ENDIF
     28  02c2				  -	      IF	$50 = $90
     29  02c2				  -	      .byte	$90+$4
     30  02c2					      ENDIF
     31  02c2				  -	      IF	$50 = $A0
     32  02c2				  -	      .byte	$70+$4
     33  02c2					      ENDIF
     34  02c2				  -	      IF	$50 = $B0
     35  02c2				  -	      .byte	$50+$4
     36  02c2					      ENDIF
     37  02c2				  -	      IF	$50 = $C0
     38  02c2				  -	      .byte	$30+$4
     39  02c2					      ENDIF
     40  02c2				  -	      IF	$50 = $D0
     41  02c2				  -	      .byte	$30+$4
     42  02c2					      ENDIF
     43  02c2				  -	      IF	$50 = $E0
     44  02c2				  -	      .byte	$20+$4
     45  02c2					      ENDIF
     46  02c2				  -	      IF	$50 = $F0
     47  02c2				  -	      .byte	$40+$4
     48  02c2					      ENDIF
      0  02c2					      NTSC_TO_PAL	$70, 6
      1  02c2				  -	      IF	$70 = 0
      2  02c2				  -	      .byte	$70+6
      3  02c2					      ENDIF
      4  02c2				  -	      IF	$70 = $10
      5  02c2				  -	      .byte	$20+6
      6  02c2					      ENDIF
      7  02c2				  -	      IF	$70 = $20
      8  02c2				  -	      .byte	$40+6
      9  02c2					      ENDIF
     10  02c2				  -	      IF	$70 = $30
     11  02c2				  -	      .byte	$40+6
     12  02c2					      ENDIF
     13  02c2				  -	      IF	$70 = $40
     14  02c2				  -	      .byte	$60+6
     15  02c2					      ENDIF
     16  02c2				  -	      IF	$70 = $50
     17  02c2				  -	      .byte	$80+6
     18  02c2					      ENDIF
     19  02c2				  -	      IF	$70 = $60
     20  02c2				  -	      .byte	$C0+6
     21  02c2					      ENDIF
     22  02c2					      IF	$70 = $70
     23  02c2		       d6		      .byte.b	$D0+6
     24  02c3					      ENDIF
     25  02c3				  -	      IF	$70 = $80
     26  02c3				  -	      .byte	$B0+6
     27  02c3					      ENDIF
     28  02c3				  -	      IF	$70 = $90
     29  02c3				  -	      .byte	$90+6
     30  02c3					      ENDIF
     31  02c3				  -	      IF	$70 = $A0
     32  02c3				  -	      .byte	$70+6
     33  02c3					      ENDIF
     34  02c3				  -	      IF	$70 = $B0
     35  02c3				  -	      .byte	$50+6
     36  02c3					      ENDIF
     37  02c3				  -	      IF	$70 = $C0
     38  02c3				  -	      .byte	$30+6
     39  02c3					      ENDIF
     40  02c3				  -	      IF	$70 = $D0
     41  02c3				  -	      .byte	$30+6
     42  02c3					      ENDIF
     43  02c3				  -	      IF	$70 = $E0
     44  02c3				  -	      .byte	$20+6
     45  02c3					      ENDIF
     46  02c3				  -	      IF	$70 = $F0
     47  02c3				  -	      .byte	$40+6
     48  02c3					      ENDIF
      0  02c3					      NTSC_TO_PAL	$40, 6
      1  02c3				  -	      IF	$40 = 0
      2  02c3				  -	      .byte	$40+6
      3  02c3					      ENDIF
      4  02c3				  -	      IF	$40 = $10
      5  02c3				  -	      .byte	$20+6
      6  02c3					      ENDIF
      7  02c3				  -	      IF	$40 = $20
      8  02c3				  -	      .byte	$40+6
      9  02c3					      ENDIF
     10  02c3				  -	      IF	$40 = $30
     11  02c3				  -	      .byte	$40+6
     12  02c3					      ENDIF
     13  02c3					      IF	$40 = $40
     14  02c3		       66		      .byte.b	$60+6
     15  02c4					      ENDIF
     16  02c4				  -	      IF	$40 = $50
     17  02c4				  -	      .byte	$80+6
     18  02c4					      ENDIF
     19  02c4				  -	      IF	$40 = $60
     20  02c4				  -	      .byte	$C0+6
     21  02c4					      ENDIF
     22  02c4				  -	      IF	$40 = $70
     23  02c4				  -	      .byte	$D0+6
     24  02c4					      ENDIF
     25  02c4				  -	      IF	$40 = $80
     26  02c4				  -	      .byte	$B0+6
     27  02c4					      ENDIF
     28  02c4				  -	      IF	$40 = $90
     29  02c4				  -	      .byte	$90+6
     30  02c4					      ENDIF
     31  02c4				  -	      IF	$40 = $A0
     32  02c4				  -	      .byte	$70+6
     33  02c4					      ENDIF
     34  02c4				  -	      IF	$40 = $B0
     35  02c4				  -	      .byte	$50+6
     36  02c4					      ENDIF
     37  02c4				  -	      IF	$40 = $C0
     38  02c4				  -	      .byte	$30+6
     39  02c4					      ENDIF
     40  02c4				  -	      IF	$40 = $D0
     41  02c4				  -	      .byte	$30+6
     42  02c4					      ENDIF
     43  02c4				  -	      IF	$40 = $E0
     44  02c4				  -	      .byte	$20+6
     45  02c4					      ENDIF
     46  02c4				  -	      IF	$40 = $F0
     47  02c4				  -	      .byte	$40+6
     48  02c4					      ENDIF
     19  02c4		       00		      .byte.b	0
      0  02c5					      COLOUR_GROUP	$40,$6, $E0,$8, $00,$C, $C0,$4, $90,6, $20,6	; 2
      1  02c5
      2  02c5		       00		      .byte.b	0
      3  02c6		       46		      .byte.b	$40+$6
      4  02c7		       e8		      .byte.b	$E0+$8
      5  02c8		       0c		      .byte.b	$00+$C
      6  02c9		       c4		      .byte.b	$C0+$4
      7  02ca		       96		      .byte.b	$90+6
      8  02cb		       26		      .byte.b	$20+6
      9  02cc		       00		      .byte.b	0
     10  02cd
     11  02cd
     12  02cd		       00		      .byte.b	0
      0  02ce					      NTSC_TO_PAL	$40, $6
      1  02ce				  -	      IF	$40 = 0
      2  02ce				  -	      .byte	$40+$6
      3  02ce					      ENDIF
      4  02ce				  -	      IF	$40 = $10
      5  02ce				  -	      .byte	$20+$6
      6  02ce					      ENDIF
      7  02ce				  -	      IF	$40 = $20
      8  02ce				  -	      .byte	$40+$6
      9  02ce					      ENDIF
     10  02ce				  -	      IF	$40 = $30
     11  02ce				  -	      .byte	$40+$6
     12  02ce					      ENDIF
     13  02ce					      IF	$40 = $40
     14  02ce		       66		      .byte.b	$60+$6
     15  02cf					      ENDIF
     16  02cf				  -	      IF	$40 = $50
     17  02cf				  -	      .byte	$80+$6
     18  02cf					      ENDIF
     19  02cf				  -	      IF	$40 = $60
     20  02cf				  -	      .byte	$C0+$6
     21  02cf					      ENDIF
     22  02cf				  -	      IF	$40 = $70
     23  02cf				  -	      .byte	$D0+$6
     24  02cf					      ENDIF
     25  02cf				  -	      IF	$40 = $80
     26  02cf				  -	      .byte	$B0+$6
     27  02cf					      ENDIF
     28  02cf				  -	      IF	$40 = $90
     29  02cf				  -	      .byte	$90+$6
     30  02cf					      ENDIF
     31  02cf				  -	      IF	$40 = $A0
     32  02cf				  -	      .byte	$70+$6
     33  02cf					      ENDIF
     34  02cf				  -	      IF	$40 = $B0
     35  02cf				  -	      .byte	$50+$6
     36  02cf					      ENDIF
     37  02cf				  -	      IF	$40 = $C0
     38  02cf				  -	      .byte	$30+$6
     39  02cf					      ENDIF
     40  02cf				  -	      IF	$40 = $D0
     41  02cf				  -	      .byte	$30+$6
     42  02cf					      ENDIF
     43  02cf				  -	      IF	$40 = $E0
     44  02cf				  -	      .byte	$20+$6
     45  02cf					      ENDIF
     46  02cf				  -	      IF	$40 = $F0
     47  02cf				  -	      .byte	$40+$6
     48  02cf					      ENDIF
      0  02cf					      NTSC_TO_PAL	$E0, $8
      1  02cf				  -	      IF	$E0 = 0
      2  02cf				  -	      .byte	$E0+$8
      3  02cf					      ENDIF
      4  02cf				  -	      IF	$E0 = $10
      5  02cf				  -	      .byte	$20+$8
      6  02cf					      ENDIF
      7  02cf				  -	      IF	$E0 = $20
      8  02cf				  -	      .byte	$40+$8
      9  02cf					      ENDIF
     10  02cf				  -	      IF	$E0 = $30
     11  02cf				  -	      .byte	$40+$8
     12  02cf					      ENDIF
     13  02cf				  -	      IF	$E0 = $40
     14  02cf				  -	      .byte	$60+$8
     15  02cf					      ENDIF
     16  02cf				  -	      IF	$E0 = $50
     17  02cf				  -	      .byte	$80+$8
     18  02cf					      ENDIF
     19  02cf				  -	      IF	$E0 = $60
     20  02cf				  -	      .byte	$C0+$8
     21  02cf					      ENDIF
     22  02cf				  -	      IF	$E0 = $70
     23  02cf				  -	      .byte	$D0+$8
     24  02cf					      ENDIF
     25  02cf				  -	      IF	$E0 = $80
     26  02cf				  -	      .byte	$B0+$8
     27  02cf					      ENDIF
     28  02cf				  -	      IF	$E0 = $90
     29  02cf				  -	      .byte	$90+$8
     30  02cf					      ENDIF
     31  02cf				  -	      IF	$E0 = $A0
     32  02cf				  -	      .byte	$70+$8
     33  02cf					      ENDIF
     34  02cf				  -	      IF	$E0 = $B0
     35  02cf				  -	      .byte	$50+$8
     36  02cf					      ENDIF
     37  02cf				  -	      IF	$E0 = $C0
     38  02cf				  -	      .byte	$30+$8
     39  02cf					      ENDIF
     40  02cf				  -	      IF	$E0 = $D0
     41  02cf				  -	      .byte	$30+$8
     42  02cf					      ENDIF
     43  02cf					      IF	$E0 = $E0
     44  02cf		       28		      .byte.b	$20+$8
     45  02d0					      ENDIF
     46  02d0				  -	      IF	$E0 = $F0
     47  02d0				  -	      .byte	$40+$8
     48  02d0					      ENDIF
      0  02d0					      NTSC_TO_PAL	$00, $C
      1  02d0					      IF	$00 = 0
      2  02d0		       0c		      .byte.b	$00+$C
      3  02d1					      ENDIF
      4  02d1				  -	      IF	$00 = $10
      5  02d1				  -	      .byte	$20+$C
      6  02d1					      ENDIF
      7  02d1				  -	      IF	$00 = $20
      8  02d1				  -	      .byte	$40+$C
      9  02d1					      ENDIF
     10  02d1				  -	      IF	$00 = $30
     11  02d1				  -	      .byte	$40+$C
     12  02d1					      ENDIF
     13  02d1				  -	      IF	$00 = $40
     14  02d1				  -	      .byte	$60+$C
     15  02d1					      ENDIF
     16  02d1				  -	      IF	$00 = $50
     17  02d1				  -	      .byte	$80+$C
     18  02d1					      ENDIF
     19  02d1				  -	      IF	$00 = $60
     20  02d1				  -	      .byte	$C0+$C
     21  02d1					      ENDIF
     22  02d1				  -	      IF	$00 = $70
     23  02d1				  -	      .byte	$D0+$C
     24  02d1					      ENDIF
     25  02d1				  -	      IF	$00 = $80
     26  02d1				  -	      .byte	$B0+$C
     27  02d1					      ENDIF
     28  02d1				  -	      IF	$00 = $90
     29  02d1				  -	      .byte	$90+$C
     30  02d1					      ENDIF
     31  02d1				  -	      IF	$00 = $A0
     32  02d1				  -	      .byte	$70+$C
     33  02d1					      ENDIF
     34  02d1				  -	      IF	$00 = $B0
     35  02d1				  -	      .byte	$50+$C
     36  02d1					      ENDIF
     37  02d1				  -	      IF	$00 = $C0
     38  02d1				  -	      .byte	$30+$C
     39  02d1					      ENDIF
     40  02d1				  -	      IF	$00 = $D0
     41  02d1				  -	      .byte	$30+$C
     42  02d1					      ENDIF
     43  02d1				  -	      IF	$00 = $E0
     44  02d1				  -	      .byte	$20+$C
     45  02d1					      ENDIF
     46  02d1				  -	      IF	$00 = $F0
     47  02d1				  -	      .byte	$40+$C
     48  02d1					      ENDIF
      0  02d1					      NTSC_TO_PAL	$C0, $4
      1  02d1				  -	      IF	$C0 = 0
      2  02d1				  -	      .byte	$C0+$4
      3  02d1					      ENDIF
      4  02d1				  -	      IF	$C0 = $10
      5  02d1				  -	      .byte	$20+$4
      6  02d1					      ENDIF
      7  02d1				  -	      IF	$C0 = $20
      8  02d1				  -	      .byte	$40+$4
      9  02d1					      ENDIF
     10  02d1				  -	      IF	$C0 = $30
     11  02d1				  -	      .byte	$40+$4
     12  02d1					      ENDIF
     13  02d1				  -	      IF	$C0 = $40
     14  02d1				  -	      .byte	$60+$4
     15  02d1					      ENDIF
     16  02d1				  -	      IF	$C0 = $50
     17  02d1				  -	      .byte	$80+$4
     18  02d1					      ENDIF
     19  02d1				  -	      IF	$C0 = $60
     20  02d1				  -	      .byte	$C0+$4
     21  02d1					      ENDIF
     22  02d1				  -	      IF	$C0 = $70
     23  02d1				  -	      .byte	$D0+$4
     24  02d1					      ENDIF
     25  02d1				  -	      IF	$C0 = $80
     26  02d1				  -	      .byte	$B0+$4
     27  02d1					      ENDIF
     28  02d1				  -	      IF	$C0 = $90
     29  02d1				  -	      .byte	$90+$4
     30  02d1					      ENDIF
     31  02d1				  -	      IF	$C0 = $A0
     32  02d1				  -	      .byte	$70+$4
     33  02d1					      ENDIF
     34  02d1				  -	      IF	$C0 = $B0
     35  02d1				  -	      .byte	$50+$4
     36  02d1					      ENDIF
     37  02d1					      IF	$C0 = $C0
     38  02d1		       34		      .byte.b	$30+$4
     39  02d2					      ENDIF
     40  02d2				  -	      IF	$C0 = $D0
     41  02d2				  -	      .byte	$30+$4
     42  02d2					      ENDIF
     43  02d2				  -	      IF	$C0 = $E0
     44  02d2				  -	      .byte	$20+$4
     45  02d2					      ENDIF
     46  02d2				  -	      IF	$C0 = $F0
     47  02d2				  -	      .byte	$40+$4
     48  02d2					      ENDIF
      0  02d2					      NTSC_TO_PAL	$90, 6
      1  02d2				  -	      IF	$90 = 0
      2  02d2				  -	      .byte	$90+6
      3  02d2					      ENDIF
      4  02d2				  -	      IF	$90 = $10
      5  02d2				  -	      .byte	$20+6
      6  02d2					      ENDIF
      7  02d2				  -	      IF	$90 = $20
      8  02d2				  -	      .byte	$40+6
      9  02d2					      ENDIF
     10  02d2				  -	      IF	$90 = $30
     11  02d2				  -	      .byte	$40+6
     12  02d2					      ENDIF
     13  02d2				  -	      IF	$90 = $40
     14  02d2				  -	      .byte	$60+6
     15  02d2					      ENDIF
     16  02d2				  -	      IF	$90 = $50
     17  02d2				  -	      .byte	$80+6
     18  02d2					      ENDIF
     19  02d2				  -	      IF	$90 = $60
     20  02d2				  -	      .byte	$C0+6
     21  02d2					      ENDIF
     22  02d2				  -	      IF	$90 = $70
     23  02d2				  -	      .byte	$D0+6
     24  02d2					      ENDIF
     25  02d2				  -	      IF	$90 = $80
     26  02d2				  -	      .byte	$B0+6
     27  02d2					      ENDIF
     28  02d2					      IF	$90 = $90
     29  02d2		       96		      .byte.b	$90+6
     30  02d3					      ENDIF
     31  02d3				  -	      IF	$90 = $A0
     32  02d3				  -	      .byte	$70+6
     33  02d3					      ENDIF
     34  02d3				  -	      IF	$90 = $B0
     35  02d3				  -	      .byte	$50+6
     36  02d3					      ENDIF
     37  02d3				  -	      IF	$90 = $C0
     38  02d3				  -	      .byte	$30+6
     39  02d3					      ENDIF
     40  02d3				  -	      IF	$90 = $D0
     41  02d3				  -	      .byte	$30+6
     42  02d3					      ENDIF
     43  02d3				  -	      IF	$90 = $E0
     44  02d3				  -	      .byte	$20+6
     45  02d3					      ENDIF
     46  02d3				  -	      IF	$90 = $F0
     47  02d3				  -	      .byte	$40+6
     48  02d3					      ENDIF
      0  02d3					      NTSC_TO_PAL	$20, 6
      1  02d3				  -	      IF	$20 = 0
      2  02d3				  -	      .byte	$20+6
      3  02d3					      ENDIF
      4  02d3				  -	      IF	$20 = $10
      5  02d3				  -	      .byte	$20+6
      6  02d3					      ENDIF
      7  02d3					      IF	$20 = $20
      8  02d3		       46		      .byte.b	$40+6
      9  02d4					      ENDIF
     10  02d4				  -	      IF	$20 = $30
     11  02d4				  -	      .byte	$40+6
     12  02d4					      ENDIF
     13  02d4				  -	      IF	$20 = $40
     14  02d4				  -	      .byte	$60+6
     15  02d4					      ENDIF
     16  02d4				  -	      IF	$20 = $50
     17  02d4				  -	      .byte	$80+6
     18  02d4					      ENDIF
     19  02d4				  -	      IF	$20 = $60
     20  02d4				  -	      .byte	$C0+6
     21  02d4					      ENDIF
     22  02d4				  -	      IF	$20 = $70
     23  02d4				  -	      .byte	$D0+6
     24  02d4					      ENDIF
     25  02d4				  -	      IF	$20 = $80
     26  02d4				  -	      .byte	$B0+6
     27  02d4					      ENDIF
     28  02d4				  -	      IF	$20 = $90
     29  02d4				  -	      .byte	$90+6
     30  02d4					      ENDIF
     31  02d4				  -	      IF	$20 = $A0
     32  02d4				  -	      .byte	$70+6
     33  02d4					      ENDIF
     34  02d4				  -	      IF	$20 = $B0
     35  02d4				  -	      .byte	$50+6
     36  02d4					      ENDIF
     37  02d4				  -	      IF	$20 = $C0
     38  02d4				  -	      .byte	$30+6
     39  02d4					      ENDIF
     40  02d4				  -	      IF	$20 = $D0
     41  02d4				  -	      .byte	$30+6
     42  02d4					      ENDIF
     43  02d4				  -	      IF	$20 = $E0
     44  02d4				  -	      .byte	$20+6
     45  02d4					      ENDIF
     46  02d4				  -	      IF	$20 = $F0
     47  02d4				  -	      .byte	$40+6
     48  02d4					      ENDIF
     19  02d4		       00		      .byte.b	0
      0  02d5					      COLOUR_GROUP	$30,$A, $50,$8, $10,$C, $40,$4, $60,6, $50,8	; 3
      1  02d5
      2  02d5		       00		      .byte.b	0
      3  02d6		       3a		      .byte.b	$30+$A
      4  02d7		       58		      .byte.b	$50+$8
      5  02d8		       1c		      .byte.b	$10+$C
      6  02d9		       44		      .byte.b	$40+$4
      7  02da		       66		      .byte.b	$60+6
      8  02db		       58		      .byte.b	$50+8
      9  02dc		       00		      .byte.b	0
     10  02dd
     11  02dd
     12  02dd		       00		      .byte.b	0
      0  02de					      NTSC_TO_PAL	$30, $A
      1  02de				  -	      IF	$30 = 0
      2  02de				  -	      .byte	$30+$A
      3  02de					      ENDIF
      4  02de				  -	      IF	$30 = $10
      5  02de				  -	      .byte	$20+$A
      6  02de					      ENDIF
      7  02de				  -	      IF	$30 = $20
      8  02de				  -	      .byte	$40+$A
      9  02de					      ENDIF
     10  02de					      IF	$30 = $30
     11  02de		       4a		      .byte.b	$40+$A
     12  02df					      ENDIF
     13  02df				  -	      IF	$30 = $40
     14  02df				  -	      .byte	$60+$A
     15  02df					      ENDIF
     16  02df				  -	      IF	$30 = $50
     17  02df				  -	      .byte	$80+$A
     18  02df					      ENDIF
     19  02df				  -	      IF	$30 = $60
     20  02df				  -	      .byte	$C0+$A
     21  02df					      ENDIF
     22  02df				  -	      IF	$30 = $70
     23  02df				  -	      .byte	$D0+$A
     24  02df					      ENDIF
     25  02df				  -	      IF	$30 = $80
     26  02df				  -	      .byte	$B0+$A
     27  02df					      ENDIF
     28  02df				  -	      IF	$30 = $90
     29  02df				  -	      .byte	$90+$A
     30  02df					      ENDIF
     31  02df				  -	      IF	$30 = $A0
     32  02df				  -	      .byte	$70+$A
     33  02df					      ENDIF
     34  02df				  -	      IF	$30 = $B0
     35  02df				  -	      .byte	$50+$A
     36  02df					      ENDIF
     37  02df				  -	      IF	$30 = $C0
     38  02df				  -	      .byte	$30+$A
     39  02df					      ENDIF
     40  02df				  -	      IF	$30 = $D0
     41  02df				  -	      .byte	$30+$A
     42  02df					      ENDIF
     43  02df				  -	      IF	$30 = $E0
     44  02df				  -	      .byte	$20+$A
     45  02df					      ENDIF
     46  02df				  -	      IF	$30 = $F0
     47  02df				  -	      .byte	$40+$A
     48  02df					      ENDIF
      0  02df					      NTSC_TO_PAL	$50, $8
      1  02df				  -	      IF	$50 = 0
      2  02df				  -	      .byte	$50+$8
      3  02df					      ENDIF
      4  02df				  -	      IF	$50 = $10
      5  02df				  -	      .byte	$20+$8
      6  02df					      ENDIF
      7  02df				  -	      IF	$50 = $20
      8  02df				  -	      .byte	$40+$8
      9  02df					      ENDIF
     10  02df				  -	      IF	$50 = $30
     11  02df				  -	      .byte	$40+$8
     12  02df					      ENDIF
     13  02df				  -	      IF	$50 = $40
     14  02df				  -	      .byte	$60+$8
     15  02df					      ENDIF
     16  02df					      IF	$50 = $50
     17  02df		       88		      .byte.b	$80+$8
     18  02e0					      ENDIF
     19  02e0				  -	      IF	$50 = $60
     20  02e0				  -	      .byte	$C0+$8
     21  02e0					      ENDIF
     22  02e0				  -	      IF	$50 = $70
     23  02e0				  -	      .byte	$D0+$8
     24  02e0					      ENDIF
     25  02e0				  -	      IF	$50 = $80
     26  02e0				  -	      .byte	$B0+$8
     27  02e0					      ENDIF
     28  02e0				  -	      IF	$50 = $90
     29  02e0				  -	      .byte	$90+$8
     30  02e0					      ENDIF
     31  02e0				  -	      IF	$50 = $A0
     32  02e0				  -	      .byte	$70+$8
     33  02e0					      ENDIF
     34  02e0				  -	      IF	$50 = $B0
     35  02e0				  -	      .byte	$50+$8
     36  02e0					      ENDIF
     37  02e0				  -	      IF	$50 = $C0
     38  02e0				  -	      .byte	$30+$8
     39  02e0					      ENDIF
     40  02e0				  -	      IF	$50 = $D0
     41  02e0				  -	      .byte	$30+$8
     42  02e0					      ENDIF
     43  02e0				  -	      IF	$50 = $E0
     44  02e0				  -	      .byte	$20+$8
     45  02e0					      ENDIF
     46  02e0				  -	      IF	$50 = $F0
     47  02e0				  -	      .byte	$40+$8
     48  02e0					      ENDIF
      0  02e0					      NTSC_TO_PAL	$10, $C
      1  02e0				  -	      IF	$10 = 0
      2  02e0				  -	      .byte	$10+$C
      3  02e0					      ENDIF
      4  02e0					      IF	$10 = $10
      5  02e0		       2c		      .byte.b	$20+$C
      6  02e1					      ENDIF
      7  02e1				  -	      IF	$10 = $20
      8  02e1				  -	      .byte	$40+$C
      9  02e1					      ENDIF
     10  02e1				  -	      IF	$10 = $30
     11  02e1				  -	      .byte	$40+$C
     12  02e1					      ENDIF
     13  02e1				  -	      IF	$10 = $40
     14  02e1				  -	      .byte	$60+$C
     15  02e1					      ENDIF
     16  02e1				  -	      IF	$10 = $50
     17  02e1				  -	      .byte	$80+$C
     18  02e1					      ENDIF
     19  02e1				  -	      IF	$10 = $60
     20  02e1				  -	      .byte	$C0+$C
     21  02e1					      ENDIF
     22  02e1				  -	      IF	$10 = $70
     23  02e1				  -	      .byte	$D0+$C
     24  02e1					      ENDIF
     25  02e1				  -	      IF	$10 = $80
     26  02e1				  -	      .byte	$B0+$C
     27  02e1					      ENDIF
     28  02e1				  -	      IF	$10 = $90
     29  02e1				  -	      .byte	$90+$C
     30  02e1					      ENDIF
     31  02e1				  -	      IF	$10 = $A0
     32  02e1				  -	      .byte	$70+$C
     33  02e1					      ENDIF
     34  02e1				  -	      IF	$10 = $B0
     35  02e1				  -	      .byte	$50+$C
     36  02e1					      ENDIF
     37  02e1				  -	      IF	$10 = $C0
     38  02e1				  -	      .byte	$30+$C
     39  02e1					      ENDIF
     40  02e1				  -	      IF	$10 = $D0
     41  02e1				  -	      .byte	$30+$C
     42  02e1					      ENDIF
     43  02e1				  -	      IF	$10 = $E0
     44  02e1				  -	      .byte	$20+$C
     45  02e1					      ENDIF
     46  02e1				  -	      IF	$10 = $F0
     47  02e1				  -	      .byte	$40+$C
     48  02e1					      ENDIF
      0  02e1					      NTSC_TO_PAL	$40, $4
      1  02e1				  -	      IF	$40 = 0
      2  02e1				  -	      .byte	$40+$4
      3  02e1					      ENDIF
      4  02e1				  -	      IF	$40 = $10
      5  02e1				  -	      .byte	$20+$4
      6  02e1					      ENDIF
      7  02e1				  -	      IF	$40 = $20
      8  02e1				  -	      .byte	$40+$4
      9  02e1					      ENDIF
     10  02e1				  -	      IF	$40 = $30
     11  02e1				  -	      .byte	$40+$4
     12  02e1					      ENDIF
     13  02e1					      IF	$40 = $40
     14  02e1		       64		      .byte.b	$60+$4
     15  02e2					      ENDIF
     16  02e2				  -	      IF	$40 = $50
     17  02e2				  -	      .byte	$80+$4
     18  02e2					      ENDIF
     19  02e2				  -	      IF	$40 = $60
     20  02e2				  -	      .byte	$C0+$4
     21  02e2					      ENDIF
     22  02e2				  -	      IF	$40 = $70
     23  02e2				  -	      .byte	$D0+$4
     24  02e2					      ENDIF
     25  02e2				  -	      IF	$40 = $80
     26  02e2				  -	      .byte	$B0+$4
     27  02e2					      ENDIF
     28  02e2				  -	      IF	$40 = $90
     29  02e2				  -	      .byte	$90+$4
     30  02e2					      ENDIF
     31  02e2				  -	      IF	$40 = $A0
     32  02e2				  -	      .byte	$70+$4
     33  02e2					      ENDIF
     34  02e2				  -	      IF	$40 = $B0
     35  02e2				  -	      .byte	$50+$4
     36  02e2					      ENDIF
     37  02e2				  -	      IF	$40 = $C0
     38  02e2				  -	      .byte	$30+$4
     39  02e2					      ENDIF
     40  02e2				  -	      IF	$40 = $D0
     41  02e2				  -	      .byte	$30+$4
     42  02e2					      ENDIF
     43  02e2				  -	      IF	$40 = $E0
     44  02e2				  -	      .byte	$20+$4
     45  02e2					      ENDIF
     46  02e2				  -	      IF	$40 = $F0
     47  02e2				  -	      .byte	$40+$4
     48  02e2					      ENDIF
      0  02e2					      NTSC_TO_PAL	$60, 6
      1  02e2				  -	      IF	$60 = 0
      2  02e2				  -	      .byte	$60+6
      3  02e2					      ENDIF
      4  02e2				  -	      IF	$60 = $10
      5  02e2				  -	      .byte	$20+6
      6  02e2					      ENDIF
      7  02e2				  -	      IF	$60 = $20
      8  02e2				  -	      .byte	$40+6
      9  02e2					      ENDIF
     10  02e2				  -	      IF	$60 = $30
     11  02e2				  -	      .byte	$40+6
     12  02e2					      ENDIF
     13  02e2				  -	      IF	$60 = $40
     14  02e2				  -	      .byte	$60+6
     15  02e2					      ENDIF
     16  02e2				  -	      IF	$60 = $50
     17  02e2				  -	      .byte	$80+6
     18  02e2					      ENDIF
     19  02e2					      IF	$60 = $60
     20  02e2		       c6		      .byte.b	$C0+6
     21  02e3					      ENDIF
     22  02e3				  -	      IF	$60 = $70
     23  02e3				  -	      .byte	$D0+6
     24  02e3					      ENDIF
     25  02e3				  -	      IF	$60 = $80
     26  02e3				  -	      .byte	$B0+6
     27  02e3					      ENDIF
     28  02e3				  -	      IF	$60 = $90
     29  02e3				  -	      .byte	$90+6
     30  02e3					      ENDIF
     31  02e3				  -	      IF	$60 = $A0
     32  02e3				  -	      .byte	$70+6
     33  02e3					      ENDIF
     34  02e3				  -	      IF	$60 = $B0
     35  02e3				  -	      .byte	$50+6
     36  02e3					      ENDIF
     37  02e3				  -	      IF	$60 = $C0
     38  02e3				  -	      .byte	$30+6
     39  02e3					      ENDIF
     40  02e3				  -	      IF	$60 = $D0
     41  02e3				  -	      .byte	$30+6
     42  02e3					      ENDIF
     43  02e3				  -	      IF	$60 = $E0
     44  02e3				  -	      .byte	$20+6
     45  02e3					      ENDIF
     46  02e3				  -	      IF	$60 = $F0
     47  02e3				  -	      .byte	$40+6
     48  02e3					      ENDIF
      0  02e3					      NTSC_TO_PAL	$50, 8
      1  02e3				  -	      IF	$50 = 0
      2  02e3				  -	      .byte	$50+8
      3  02e3					      ENDIF
      4  02e3				  -	      IF	$50 = $10
      5  02e3				  -	      .byte	$20+8
      6  02e3					      ENDIF
      7  02e3				  -	      IF	$50 = $20
      8  02e3				  -	      .byte	$40+8
      9  02e3					      ENDIF
     10  02e3				  -	      IF	$50 = $30
     11  02e3				  -	      .byte	$40+8
     12  02e3					      ENDIF
     13  02e3				  -	      IF	$50 = $40
     14  02e3				  -	      .byte	$60+8
     15  02e3					      ENDIF
     16  02e3					      IF	$50 = $50
     17  02e3		       88		      .byte.b	$80+8
     18  02e4					      ENDIF
     19  02e4				  -	      IF	$50 = $60
     20  02e4				  -	      .byte	$C0+8
     21  02e4					      ENDIF
     22  02e4				  -	      IF	$50 = $70
     23  02e4				  -	      .byte	$D0+8
     24  02e4					      ENDIF
     25  02e4				  -	      IF	$50 = $80
     26  02e4				  -	      .byte	$B0+8
     27  02e4					      ENDIF
     28  02e4				  -	      IF	$50 = $90
     29  02e4				  -	      .byte	$90+8
     30  02e4					      ENDIF
     31  02e4				  -	      IF	$50 = $A0
     32  02e4				  -	      .byte	$70+8
     33  02e4					      ENDIF
     34  02e4				  -	      IF	$50 = $B0
     35  02e4				  -	      .byte	$50+8
     36  02e4					      ENDIF
     37  02e4				  -	      IF	$50 = $C0
     38  02e4				  -	      .byte	$30+8
     39  02e4					      ENDIF
     40  02e4				  -	      IF	$50 = $D0
     41  02e4				  -	      .byte	$30+8
     42  02e4					      ENDIF
     43  02e4				  -	      IF	$50 = $E0
     44  02e4				  -	      .byte	$20+8
     45  02e4					      ENDIF
     46  02e4				  -	      IF	$50 = $F0
     47  02e4				  -	      .byte	$40+8
     48  02e4					      ENDIF
     19  02e4		       00		      .byte.b	0
    571  02e5
    572  02e5							;------------------------------------------------------------------------------
    573  02e5
    574  02e5							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    575  02e5
    576  02e5							;------------------------------------------------------------------------------
    577  02e5
    578  02e5
    579  02e5
    580  02e5
    581  02e5				   OBJTYPE    SET	0
    582  02e5					      MAC	define_character
    583  02e5				   CHARACTER_{1} =	OBJTYPE
    584  02e5				   OBJTYPE    .SET	OBJTYPE + 1
    585  02e5					      ENDM
    586  02e5
    587  02e5							; Modifications to character #/order must also ensure the following are correct...
    588  02e5							;   CharacterDataVecLO/HI	   in this file
    589  02e5							;   MoveVecLO/HI		   in BANK_INITBANK
    590  02e5							;   CharReplacement		   in BANK_ROM_SHADOW_DRAWBUFFERS
    591  02e5
      0  02e5					      DEFINE_CHARACTER	BLANK
      1  02e5		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	SOIL
      1  02e5		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	BOX
      1  02e5		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	TARGET
      1  02e5		       00 03	   CHARACTER_TARGET =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	TARGET2
      1  02e5		       00 04	   CHARACTER_TARGET2 =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	MANOCCUPIED
      1  02e5		       00 05	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	STEEL
      1  02e5		       00 06	   CHARACTER_STEEL =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	WALL
      1  02e5		       00 07	   CHARACTER_WALL =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	BOX_ON_TARGET
      1  02e5		       00 08	   CHARACTER_BOX_ON_TARGET =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	BOX_ON_TARGET2
      1  02e5		       00 09	   CHARACTER_BOX_ON_TARGET2 =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	NOGO
      1  02e5		       00 0a	   CHARACTER_NOGO =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	TARGET1
      1  02e5		       00 0b	   CHARACTER_TARGET1 =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	TARGET3
      1  02e5		       00 0c	   CHARACTER_TARGET3 =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	TARGET5
      1  02e5		       00 0d	   CHARACTER_TARGET5 =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	TARGET7
      1  02e5		       00 0e	   CHARACTER_TARGET7 =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
    607  02e5
    608  02e5				  -	      if	DIGITS
    609  02e5				  -	      DEFINE_CHARACTER	0
    610  02e5				  -	      DEFINE_CHARACTER	1
    611  02e5				  -	      DEFINE_CHARACTER	2
    612  02e5				  -	      DEFINE_CHARACTER	3
    613  02e5				  -	      DEFINE_CHARACTER	4
    614  02e5				  -	      DEFINE_CHARACTER	5
    615  02e5				  -	      DEFINE_CHARACTER	6
    616  02e5				  -	      DEFINE_CHARACTER	7
    617  02e5				  -	      DEFINE_CHARACTER	8
    618  02e5				  -	      DEFINE_CHARACTER	9
    619  02e5					      endif
    620  02e5
      0  02e5					      DEFINE_CHARACTER	MAXIMUM
      1  02e5		       00 0f	   CHARACTER_MAXIMUM =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
    622  02e5
    623  02e5
    624  02e5				   CharacterDataVecLO
    625  02e5
    626  02e5							; Two entries per character.  2nd is ptr to mirrored character
    627  02e5							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
    628  02e5
    629  02e5		       21		      .byte.b	<CHARACTERSHAPE_BLANK
    630  02e6		       21		      .byte.b	<CHARACTERSHAPE_BLANK
    631  02e7		       30		      .byte.b	<CHARACTERSHAPE_SOIL
    632  02e8		       30		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
    633  02e9		       48		      .byte.b	<CHARACTERSHAPE_BOX
    634  02ea		       60		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
    635  02eb		       01		      .byte.b	<CHARACTERSHAPE_TARGET
    636  02ec		       19		      .byte.b	<CHARACTERSHAPE_TARGET_MIRRORED
    637  02ed		       21		      .byte.b	<CHARACTERSHAPE_BLANK
    638  02ee		       21		      .byte.b	<CHARACTERSHAPE_BLANK
    639  02ef		       21		      .byte.b	<CHARACTERSHAPE_BLANK	; man occupied
    640  02f0		       21		      .byte.b	<CHARACTERSHAPE_BLANK
    641  02f1		       00		      .byte.b	<CHARACTERSHAPE_STEEL
    642  02f2		       18		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
    643  02f3		       d8		      .byte.b	<CHARACTERSHAPE_WALL
    644  02f4		       00		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
    645  02f5		       78		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET
    646  02f6		       90		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    647  02f7		       a8		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET2
    648  02f8		       c0		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED
    649  02f9		       21		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    650  02fa		       21		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    651  02fb		       31		      .byte.b	<CHARACTERSHAPE_TARGET1
    652  02fc		       49		      .byte.b	<CHARACTERSHAPE_TARGET1_MIRRORED
    653  02fd		       61		      .byte.b	<CHARACTERSHAPE_TARGET3
    654  02fe		       79		      .byte.b	<CHARACTERSHAPE_TARGET3_MIRRORED
    655  02ff		       91		      .byte.b	<CHARACTERSHAPE_TARGET5
    656  0300		       a9		      .byte.b	<CHARACTERSHAPE_TARGET5_MIRRORED
    657  0301		       c1		      .byte.b	<CHARACTERSHAPE_TARGET7
    658  0302		       d9		      .byte.b	<CHARACTERSHAPE_TARGET7_MIRRORED
    659  0303
    660  0303				  -	      if	DIGITS
    661  0303				  -	      .byte	<CHARACTERSHAPE_0, <CHARACTERSHAPE_0_MIRRORED
    662  0303				  -	      .byte	<CHARACTERSHAPE_1, <CHARACTERSHAPE_1_MIRRORED
    663  0303				  -	      .byte	<CHARACTERSHAPE_2, <CHARACTERSHAPE_2_MIRRORED
    664  0303				  -	      .byte	<CHARACTERSHAPE_3, <CHARACTERSHAPE_3_MIRRORED
    665  0303				  -	      .byte	<CHARACTERSHAPE_4, <CHARACTERSHAPE_4_MIRRORED
    666  0303				  -	      .byte	<CHARACTERSHAPE_5, <CHARACTERSHAPE_5_MIRRORED
    667  0303				  -	      .byte	<CHARACTERSHAPE_6, <CHARACTERSHAPE_6_MIRRORED
    668  0303				  -	      .byte	<CHARACTERSHAPE_7, <CHARACTERSHAPE_7_MIRRORED
    669  0303				  -	      .byte	<CHARACTERSHAPE_8, <CHARACTERSHAPE_8_MIRRORED
    670  0303				  -	      .byte	<CHARACTERSHAPE_9, <CHARACTERSHAPE_9_MIRRORED
    671  0303					      endif
    672  0303
    673  0303
    674  0303				  -	      IF	* - CharacterDataVecLO != CHARACTER_MAXIMUM*2
    675  0303				  -	      ECHO	"ERROR: Incorrect CharacterDataVecLO table!"
    676  0303				  -	      ERR
    677  0303					      ENDIF
    678  0303
    679  0303
    680  0303							;ds 20,0
    681  0303
    682  0303							;---------------------------------------------------------------------------
    683  0303
    684  0303				   CharacterDataVecHI
    685  0303
    686  0303		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    687  0304		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    688  0305		       fe		      .byte.b	>CHARACTERSHAPE_SOIL
    689  0306		       fe		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
    690  0307		       fe		      .byte.b	>CHARACTERSHAPE_BOX
    691  0308		       fe		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
    692  0309		       fd		      .byte.b	>CHARACTERSHAPE_TARGET
    693  030a		       fd		      .byte.b	>CHARACTERSHAPE_TARGET_MIRRORED
    694  030b		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    695  030c		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    696  030d		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; man occupied
    697  030e		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    698  030f		       fe		      .byte.b	>CHARACTERSHAPE_STEEL
    699  0310		       fe		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
    700  0311		       fe		      .byte.b	>CHARACTERSHAPE_WALL
    701  0312		       ff		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
    702  0313		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET
    703  0314		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    704  0315		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET2
    705  0316		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED
    706  0317		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    707  0318		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    708  0319		       fd		      .byte.b	>CHARACTERSHAPE_TARGET1
    709  031a		       fd		      .byte.b	>CHARACTERSHAPE_TARGET1_MIRRORED
    710  031b		       fd		      .byte.b	>CHARACTERSHAPE_TARGET3
    711  031c		       fd		      .byte.b	>CHARACTERSHAPE_TARGET3_MIRRORED
    712  031d		       fd		      .byte.b	>CHARACTERSHAPE_TARGET5
    713  031e		       fd		      .byte.b	>CHARACTERSHAPE_TARGET5_MIRRORED
    714  031f		       fd		      .byte.b	>CHARACTERSHAPE_TARGET7
    715  0320		       fd		      .byte.b	>CHARACTERSHAPE_TARGET7_MIRRORED
    716  0321
    717  0321				  -	      if	DIGITS
    718  0321				  -	      .byte	>CHARACTERSHAPE_0, >CHARACTERSHAPE_0_MIRRORED
    719  0321				  -	      .byte	>CHARACTERSHAPE_1, >CHARACTERSHAPE_1_MIRRORED
    720  0321				  -	      .byte	>CHARACTERSHAPE_2, >CHARACTERSHAPE_2_MIRRORED
    721  0321				  -	      .byte	>CHARACTERSHAPE_3, >CHARACTERSHAPE_3_MIRRORED
    722  0321				  -	      .byte	>CHARACTERSHAPE_4, >CHARACTERSHAPE_4_MIRRORED
    723  0321				  -	      .byte	>CHARACTERSHAPE_5, >CHARACTERSHAPE_5_MIRRORED
    724  0321				  -	      .byte	>CHARACTERSHAPE_6, >CHARACTERSHAPE_6_MIRRORED
    725  0321				  -	      .byte	>CHARACTERSHAPE_7, >CHARACTERSHAPE_7_MIRRORED
    726  0321				  -	      .byte	>CHARACTERSHAPE_8, >CHARACTERSHAPE_8_MIRRORED
    727  0321				  -	      .byte	>CHARACTERSHAPE_9, >CHARACTERSHAPE_9_MIRRORED
    728  0321					      endif
    729  0321
    730  0321
    731  0321				  -	      IF	* - CharacterDataVecHI != CHARACTER_MAXIMUM*2
    732  0321				  -	      ECHO	"ERROR: Incorrect CharacterDataVecHI table!"
    733  0321				  -	      ERR
    734  0321					      ENDIF
    735  0321
    736  0321
    737  0321							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    738  0321
    739  0321		       f3 39	   ShapePlayer =	PLAYER0_SHAPE	;BLANK
    740  0321		       f3 39	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    741  0321		       f3 39	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    742  0321		       f3 39	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    743  0321
    744  0321		       f3 21	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    745  0321		       f3 21	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    746  0321
    747  0321
    748  0321							; The following are the RAM buffers into which the player shape and colour data are copied
    749  0321							; The self-mod draw vectors point to this OR to a **blank** shape.
    750  0321
      0  0321					      OPTIONAL_PAGEBREAK	"PLAYER_BLANK", LINES_PER_CHAR
     10  0321					      LIST	ON
    752  0321				   PLAYER_BLANK
    753  0321		       00 00 00 00*	      ds	LINES_PER_CHAR, 0	; P1
      0  0339					      CHECKPAGEX	PLAYER_BLANK, "PLAYER_BLANK in BANK_ROM_SHADOW_RAMBANK.asm"
      9  0339					      LIST	ON
    755  0339
      0  0339					      OPTIONAL_PAGEBREAK	"PLAYER0_SHAPE", LINES_PER_CHAR
     10  0339					      LIST	ON
    757  0339				   PLAYER0_SHAPE
    758  0339		       00 00 00 00*	      ds	LINES_PER_CHAR,0
      0  0351					      CHECKPAGEX	PLAYER0_SHAPE, "PLAYER0_SHAPE in BANK_ROM_SHADOW_RAMBANK.asm"
      9  0351					      LIST	ON
    760  0351
      0  0351					      OPTIONAL_PAGEBREAK	"PLAYER0_COLOUR", LINES_PER_CHAR	; BOTH on same page
     10  0351					      LIST	ON
    762  0351				   PLAYER0_COLOUR
    763  0351		       00 00 00 00*	      ds	LINES_PER_CHAR,0
      0  0369					      CHECKPAGEX	PLAYER0_COLOUR, "PLAYER0_COLOUR in BANK_ROM_SHADOW_RAMBANK.asm"
      9  0369					      LIST	ON
    765  0369
    766  0369		       ff	   ExistingFrame .byte.b	-1
    767  036a
      0  036a					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- 1K"
      1  036a
      2  036a
      3  036a		       03 6a	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- 1K (1K) SIZE =  $36a , FREE= $96
      4  036a					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  036a				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  036a				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  036a				  -	      ERR
      8  036a					      endif
    769  036a
    770  036a							; Here there's another 1K of usable ROM....
    771  036a							; Anything here is ONLY accessible if the bank is switched in as a ROM bank
    772  036a							; WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    773  036a
      0  036a					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  036a		       03 6a	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $36a , FREE= $496
      2  036a					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  036a				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  036a				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  036a				  -	      ERR
      6  036a					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 3
      0  036a					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  036a							;    Sokoboo - a Sokoban implementation
      2  036a							;    using a generic tile-based display engine for the Atari 2600
      3  036a							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  036a							;
      5  036a							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  036a							;
      7  036a							;    Code related to the generic tile-based display engine was developed by
      8  036a							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  036a							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  036a							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  036a							;
     12  036a							;    Code related to music and sound effects uses the TIATracker music player
     13  036a							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  036a							;    directory for Apache licensing details.
     15  036a							;
     16  036a							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  036a							;    See the copyright notices in the License directory for a list of level
     18  036a							;    contributors.
     19  036a							;
     20  036a							;    Except where otherwise indicated, this software is released under the
     21  036a							;    following licensing arrangement...
     22  036a							;
     23  036a							;    This program is free software: you can redistribute it and/or modify
     24  036a							;    it under the terms of the GNU General Public License as published by
     25  036a							;    the Free Software Foundation, either version 3 of the License, or
     26  036a							;    (at your option) any later version.
     27  036a							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  036a
     29  036a							;    This program is distributed in the hope that it will be useful,
     30  036a							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  036a							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  036a							;    GNU General Public License for more details.
     33  036a
     34  036a							;------------------------------------------------------------------------------
     35  036a							;##############################################################################
     36  036a							;------------------------------------------------------------------------------
     37  036a
      0  036a					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  0a50 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
     39  0800
     40  0800							; NOTE: Access to these buffers must NOT overlap pages...
     41  0800							; NOTE: We get auto-initialisation of these variables from the ROM values by
     42  0800							; copying the whole bank into the RAM bank.  Neato.
     43  0800
     44  0800		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     45  0800
     46  0800
     47  0800
     48  0800		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     49  0850		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     50  08a0
      0  08a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  08a0					      LIST	ON
     52  08a0
     53  08a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     54  08a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     55  08a0							; what we want to happen!
     56  08a0
     57  08a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
      0  08f0					      CHECKPAGEX	ScreenBuffer, "ScreenBuffer"
      9  08f0					      LIST	ON
     59  08f0
     60  08f0							;------------------------------------------------------------------------------
     61  08f0							; RAM-BASED SUBROUTINES...
     62  08f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     63  08f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     64  08f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     65  08f0							; the RAM-based routine.
     66  08f0
     67  08f0
     68  08f0
     69  08f0							;------------------------------------------------------------------------------
     70  08f0
     71  08f0
     72  08f0		       60	   waitForDraw rts		; 6
     73  08f1
     74  08f1							;------------------------------------------------------------------------------
     75  08f1
      0  08f1					      DEFINE_SUBROUTINE	DrawStackUpdate	; @39✅
      1  08f1		       00 01	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  08f1					      SUBROUTINE
      3  08f1				   DrawStackUpdate
     77  08f1
     78  08f1							; Parse the DrawFlags buffer and create a draw stack
     79  08f1							; so that the actual draw doesn't need to scan for characters to draw.
     80  08f1
     81  08f1
     82  08f1							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     83  08f1							; symptoms would be missing parts of screen when scrolling.
     84  08f1							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     85  08f1							; disabled for sokoban 27/7/2019
     86  08f1
     87  08f1							;lda DrawStackPointer
     88  08f1							;bpl waitForDraw		  ; Wait for previously not-drawn characters to be drawn
     89  08f1
     90  08f1		       ad 84 02 	      lda	INTIM	;4
     91  08f4		       c9 03		      cmp	#SEGTIME_BDS	;2
     92  08f6		       90 f8		      bcc	waitForDraw	;2/3
     93  08f8							; =>[39]+(9)+6rts = 54✅ when exit
     94  08f8
     95  08f8							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
     96  08f8							; moving into the middle of dirt, or BOXs when pushing, or TARGETs when grabbing.
     97  08f8
     98  08f8							;		  sec		 already set
     99  08f8		       a5 9e		      lda	ManY	;3
    100  08fa		       e5 96		      sbc	BoardScrollY	;3
    101  08fc		       c9 08		      cmp	#SCREEN_LINES
    102  08fe		       b0 0b		      bcs	offy
    103  0900		       85 a0		      sta	ManDrawY	;3 = 9✅
    104  0902
    105  0902		       38		      sec		;2
    106  0903		       a5 9d		      lda	ManX	;3
    107  0905		       e5 97		      sbc	BoardScrollX	;3
    108  0907		       c9 0a		      cmp	#SCREEN_WIDTH	;2
    109  0909		       90 06		      bcc	onsc	;2/3 = 12(13)✅
    110  090b
    111  090b							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
    112  090b							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
    113  090b							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
    114  090b
    115  090b		       a9 ff	   offy       lda	#-1	;SCREEN_LINES		     ;2
    116  090d		       85 a0		      sta	ManDrawY	;3
    117  090f		       d0 02		      bne	offsc
    118  0911
    119  0911		       85 9f	   onsc       sta	ManDrawX	;3
    120  0913				   offsc
    121  0913
    122  0913							;32✅ worst
    123  0913
      0  0913					      DEFINE_SUBROUTINE	AnimateCharReplacements2	; =32
      1  0913		       00 01	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  0913					      SUBROUTINE
      3  0913				   AnimateCharReplacements2
    125  0913
    126  0913							; This manages character animation on a per-object basis.  Morph/animate these characters
    127  0913							; individually or as required.  Change will affect all characters of the same type in the
    128  0913							; visible display.
    129  0913
    130  0913		       e6 c6		      inc	animate_char_index	; 5
    131  0915		       a5 c6		      lda	animate_char_index	; 3
    132  0917		       29 07		      and	#7	; 2
    133  0919		       aa		      tax		; 2 = 12
    134  091a
    135  091a		       bd e9 f1 	      lda	targetReplaceChar,x	; 4
    136  091d		       8d dd f5 	      sta	ANIM_TARGET + RAM_WRITE	; 4 = 8
    137  0920							;lda targetReplaceChar2,x	      ; 4
    138  0920							;sta ANIM_TARGET2 + RAM_WRITE	      ; 4
    139  0920
    140  0920							;@52 worst
    141  0920
    142  0920		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
    143  0922		       85 c4		      sta	DSL	;3
    144  0924
    145  0924		       e6 86		      inc	ScreenDrawPhase	;5
    146  0926		       60		      rts		; 6 TEST allows segtime test to be smaller on next part
    147  0927							; ==> @68 worst
    148  0927
    149  0927							;---------------------------------------------------------------------------
    150  0927
      0  0927					      DEFINE_SUBROUTINE	DrawIntoStack	; @39✅
      1  0927		       00 01	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  0927					      SUBROUTINE
      3  0927				   DrawIntoStack
    152  0927
    153  0927		       ba		      tsx		; 2
    154  0928		       86 d2		      stx	save_SP	; 3
    155  092a		       a6 81		      ldx	DrawStackPointer	; 3
    156  092c		       9a		      txs		; 2 = 10
    157  092d
    158  092d		       a4 c4		      ldy	DSL	; 3
    159  092f
    160  092f							; @ 52✅
    161  092f
    162  092f							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    163  092f							; + exit cost which is +10 cycles
    164  092f							; TJ: I count 63
    165  092f							;   + 14 for the wtf2 exit
    166  092f							;   + 22 for the end of loop exit
    167  092f
    168  092f							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    169  092f							; For 80 iterations that is 640 cycles, just for checking INTIM
    170  092f							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    171  092f							; it also will require a lot of CPU time for updating the screen data.
    172  092f
    173  092f							; TODO: optimize!
    174  092f							;
    175  092f							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    176  092f							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    177  092f							; costs some detection time here, but saves ~240 cylces for drawing the two
    178  092f
    179  092f				   .loopDrawStack		; @100✅ from bottom of loop
    180  092f
    181  092f		       ad 84 02 	      lda	INTIM	; 4
    182  0932		       c9 04		      cmp	#SEGTIME_DSL	; 2
    183  0934		       90 4b		      bcc	.exitDrawStack	; 2(3)  + [costs 18 more to exit fully at .exit..]
    184  0936							; => full exit on 1st pass = 78✅ cycles
    185  0936							; => full exit on a single loop = 127✅ cycles
    186  0936
    187  0936							; @0✅
    188  0936
    189  0936		       b9 50 f0 	      lda	DrawFlag,y	; 4
    190  0939		       d9 a0 f0 	      cmp	ScreenBuffer,y	; 4		  Is the character already there the same as the new one?
    191  093c		       f0 16		      beq	.next0	; 2/3=10/11	  yes, so we don't draw anything
    192  093e							; @10✅
    193  093e
    194  093e							; Character is NOT the same. Figure out how it should be drawn.
    195  093e							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    196  093e							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    197  093e							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    198  093e
    199  093e		       be 8a f1 	      ldx	PairedCharacter,y	; 4		  the "paired" character for this one
    200  0941		       dd 50 f0 	      cmp	DrawFlag,x	; 4		  same as partner character in new drawn screen?
    201  0944		       d0 05		      bne	.notPaired0	; 2(3)
    202  0946							; @20✅
    203  0946
    204  0946							; Consider two 'paired' characters. Either A:A or A:B
    205  0946							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    206  0946							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    207  0946							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    208  0946							; on the comparison, so the character will not be added to the draw stack. So our first character will
    209  0946							; do the job of drawing BOTH characters to the screen.
    210  0946
    211  0946		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 5		  mark paired character as drawn already (!!)
    212  0949		       09 80		      ora	#$80	; 2 =	7	  DirectDraw this character 'pair'
    213  094b							; @27✅
    214  094b							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    215  094b							; the last write(below) marks the character as to be direct-drawn.
    216  094b
    217  094b				   .notPaired0		; @27✅ worst
    218  094b
    219  094b		       99 a0 f4 	      sta	ScreenBuffer+RAM_WRITE,y	; 5		  NEW character to draw + DirectDraw flag (128)
    220  094e
    221  094e							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    222  094e
    223  094e		       68		      pla		; 4		  ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    224  094f		       98		      tya		; 2
    225  0950		       ba		      tsx		; 2		  << now X holds drawstackpointer
    226  0951		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	; 5 = 18	  index of character to draw
    227  0954
    228  0954		       88	   .next0     dey		; 2
    229  0955		       30 21		      bmi	.finishedDrawStack	; 2(3)= 4/5
    230  0957							; @50✅
    231  0957							; unrolled 2nd loop:
    232  0957		       b9 50 f0 	      lda	DrawFlag,y	; 4
    233  095a		       d9 a0 f0 	      cmp	ScreenBuffer,y	; 4		  Is the character already there the same as the new one?
    234  095d		       f0 16		      beq	.next1	; 2(3) 	  yes, so we don't draw anything
    235  095f
    236  095f		       be 8a f1 	      ldx	PairedCharacter,y	; 4		  the "paired" character for this one
    237  0962		       dd 50 f0 	      cmp	DrawFlag,x	; 4		  same as partner character in new drawn screen?
    238  0965		       d0 05		      bne	.notPaired1	; 2(3)
    239  0967
    240  0967		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 5		  mark paired character as drawn already (!!)
    241  096a		       09 80		      ora	#$80	; 2 =	7	  DirectDraw this character 'pair'
    242  096c
    243  096c				   .notPaired1		; @77✅ worst
    244  096c
    245  096c		       99 a0 f4 	      sta	ScreenBuffer+RAM_WRITE,y	; 5		  NEW character to draw + DirectDraw flag (128)
    246  096f
    247  096f		       68		      pla		; 4		  ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    248  0970		       98		      tya		; 2
    249  0971		       ba		      tsx		; 2
    250  0972		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	; 5 = 18	  index of character to draw
    251  0975							; @95✅
    252  0975
    253  0975		       88	   .next1     dey		; 2
    254  0976		       10 b7		      bpl	.loopDrawStack	; 2(3)
    255  0978							; @100✅ --> @.loopDrawStack
    256  0978
    257  0978							;worst case: 111-4
    258  0978							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    259  0978
    260  0978							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    261  0978
    262  0978				   .finishedDrawStack
    263  0978		       e6 86		      inc	ScreenDrawPhase	;5 =  5
    264  097a		       ba		      tsx		;2
    265  097b		       86 81		      stx	DrawStackPointer	;3
    266  097d
    267  097d		       a6 d2		      ldx	save_SP	;3
    268  097f		       9a		      txs		;2 = 10
    269  0980		       60		      rts		;6 =  6
    270  0981
    271  0981				   .exitDrawStack
    272  0981		       84 c4		      sty	DSL	;3 =  3
    273  0983		       ba		      tsx		;2
    274  0984		       86 81		      stx	DrawStackPointer	;3
    275  0986		       a6 d2		      ldx	save_SP	;3
    276  0988		       9a		      txs		;2 = 10
    277  0989		       60		      rts		;6 =  6
    278  098a
    279  098a				   PairedCharacter
    280  098a
    281  098a				   SOFF       SET	0
    282  098a					      REPEAT	SCREEN_LINES
    283  098a		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    284  098a				   SOFF       SET	SOFF + SCREEN_WIDTH
    282  098a					      REPEND
    283  0994		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    284  0994				   SOFF       SET	SOFF + SCREEN_WIDTH
    282  0994					      REPEND
    283  099e		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    284  099e				   SOFF       SET	SOFF + SCREEN_WIDTH
    282  099e					      REPEND
    283  09a8		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    284  09a8				   SOFF       SET	SOFF + SCREEN_WIDTH
    282  09a8					      REPEND
    283  09b2		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    284  09b2				   SOFF       SET	SOFF + SCREEN_WIDTH
    282  09b2					      REPEND
    283  09bc		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    284  09bc				   SOFF       SET	SOFF + SCREEN_WIDTH
    282  09bc					      REPEND
    283  09c6		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    284  09c6				   SOFF       SET	SOFF + SCREEN_WIDTH
    282  09c6					      REPEND
    283  09d0		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    284  09d0				   SOFF       SET	SOFF + SCREEN_WIDTH
    285  09da					      REPEND
    286  09da
    287  09da							;------------------------------------------------------------------------------
    288  09da							; Gives character replacements used during screen drawing.
    289  09da							; The character from the board is morphed via this array into an actual character
    290  09da							; to draw.  This allows global animation and replacment of characters without
    291  09da							; individual objects needing to do this.  Note, the draw-time replacement happens,
    292  09da							; not board-time.
    293  09da
    294  09da				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    295  09da
    296  09da							; Converts a character # to an animated creature type
    297  09da							; The array is indexed by CHARACTER_...
    298  09da
    299  09da		       00		      .byte.b	CHARACTER_BLANK	;  0
    300  09db		       01		      .byte.b	CHARACTER_SOIL	;  1
    301  09dc		       02		      .byte.b	CHARACTER_BOX	;  2
    302  09dd		       03	   ANIM_TARGET .byte.b	CHARACTER_TARGET	;  3  XOR'd to give flashing target squares
    303  09de		       04		      .byte.b	CHARACTER_TARGET2	;  4
    304  09df		       05		      .byte.b	CHARACTER_MANOCCUPIED	;  5
    305  09e0		       06		      .byte.b	CHARACTER_STEEL	;  6
    306  09e1		       07		      .byte.b	CHARACTER_WALL	;  7
    307  09e2		       08	   ANIM_TARGET2 .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    308  09e3		       09		      .byte.b	CHARACTER_BOX_ON_TARGET2
    309  09e4		       00		      .byte.b	CHARACTER_BLANK	;  9
    310  09e5		       0b		      .byte.b	CHARACTER_TARGET1
    311  09e6		       0c		      .byte.b	CHARACTER_TARGET3
    312  09e7		       0d		      .byte.b	CHARACTER_TARGET5
    313  09e8		       0e		      .byte.b	CHARACTER_TARGET7
    314  09e9
    315  09e9				  -	      if	DIGITS
    316  09e9				  -	      .byte	CHARACTER_0
    317  09e9				  -	      .byte	CHARACTER_1
    318  09e9				  -	      .byte	CHARACTER_2
    319  09e9				  -	      .byte	CHARACTER_3
    320  09e9				  -	      .byte	CHARACTER_4
    321  09e9				  -	      .byte	CHARACTER_5
    322  09e9				  -	      .byte	CHARACTER_6
    323  09e9				  -	      .byte	CHARACTER_7
    324  09e9				  -	      .byte	CHARACTER_8
    325  09e9				  -	      .byte	CHARACTER_9
    326  09e9					      endif
    327  09e9
    328  09e9				  -	      IF	(* - CharReplacement != CHARACTER_MAXIMUM)
    329  09e9				  -	      ECHO	"ERROR: Incorrect CharReplacement table!"
    330  09e9				  -	      ERR
    331  09e9					      ENDIF
      0  09e9					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  09e9					      LIST	ON
    333  09e9
    334  09e9
    335  09e9
    336  09e9				   targetReplaceChar
    337  09e9		       03		      .byte.b	CHARACTER_TARGET
    338  09ea		       03		      .byte.b	CHARACTER_TARGET
    339  09eb		       0b		      .byte.b	CHARACTER_TARGET1
    340  09ec		       0b		      .byte.b	CHARACTER_TARGET1
    341  09ed		       04		      .byte.b	CHARACTER_TARGET2
    342  09ee		       04		      .byte.b	CHARACTER_TARGET2
    343  09ef		       0c		      .byte.b	CHARACTER_TARGET3
    344  09f0		       0c		      .byte.b	CHARACTER_TARGET3
    345  09f1
    346  09f1							;targetReplaceChar2
    347  09f1							;    .byte CHARACTER_BOX
    348  09f1							;    .byte CHARACTER_BOX
    349  09f1							;    .byte CHARACTER_BOX_ON_TARGET
    350  09f1							;    .byte CHARACTER_BOX_ON_TARGET
    351  09f1
    352  09f1							;------------------------------------------------------------------------------
    353  09f1
    354  09f1
      0  09f1					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
 PAGE BREAK INSERTED FOR  ROW_BankChar
 REQUESTED SIZE =  $50
 WASTED SPACE =  $f
 PAGEBREAK LOCATION =  $f200
     10  0a00					      LIST	ON
      0  0a00					      DEFINE_SUBROUTINE	ROW_BankChar
      1  0a00		       00 01	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  0a00					      SUBROUTINE
      3  0a00				   ROW_BankChar
    357  0a00
    358  0a00				   .BANK      SET	BANK_SCREENMARKII1
    359  0a00					      REPEAT	SCREEN_LINES
    360  0a00					      REPEAT	SCREEN_WIDTH
    361  0a00		       00		      .byte.b	.BANK
    360  0a00					      REPEND
    361  0a01		       00		      .byte.b	.BANK
    360  0a01					      REPEND
    361  0a02		       00		      .byte.b	.BANK
    360  0a02					      REPEND
    361  0a03		       00		      .byte.b	.BANK
    360  0a03					      REPEND
    361  0a04		       00		      .byte.b	.BANK
    360  0a04					      REPEND
    361  0a05		       00		      .byte.b	.BANK
    360  0a05					      REPEND
    361  0a06		       00		      .byte.b	.BANK
    360  0a06					      REPEND
    361  0a07		       00		      .byte.b	.BANK
    360  0a07					      REPEND
    361  0a08		       00		      .byte.b	.BANK
    360  0a08					      REPEND
    361  0a09		       00		      .byte.b	.BANK
    362  0a0a					      REPEND
    363  0a0a				   .BANK      SET	.BANK + 1
    359  0a0a					      REPEND
    360  0a0a					      REPEAT	SCREEN_WIDTH
    361  0a0a		       01		      .byte.b	.BANK
    360  0a0a					      REPEND
    361  0a0b		       01		      .byte.b	.BANK
    360  0a0b					      REPEND
    361  0a0c		       01		      .byte.b	.BANK
    360  0a0c					      REPEND
    361  0a0d		       01		      .byte.b	.BANK
    360  0a0d					      REPEND
    361  0a0e		       01		      .byte.b	.BANK
    360  0a0e					      REPEND
    361  0a0f		       01		      .byte.b	.BANK
    360  0a0f					      REPEND
    361  0a10		       01		      .byte.b	.BANK
    360  0a10					      REPEND
    361  0a11		       01		      .byte.b	.BANK
    360  0a11					      REPEND
    361  0a12		       01		      .byte.b	.BANK
    360  0a12					      REPEND
    361  0a13		       01		      .byte.b	.BANK
    362  0a14					      REPEND
    363  0a14				   .BANK      SET	.BANK + 1
    359  0a14					      REPEND
    360  0a14					      REPEAT	SCREEN_WIDTH
    361  0a14		       02		      .byte.b	.BANK
    360  0a14					      REPEND
    361  0a15		       02		      .byte.b	.BANK
    360  0a15					      REPEND
    361  0a16		       02		      .byte.b	.BANK
    360  0a16					      REPEND
    361  0a17		       02		      .byte.b	.BANK
    360  0a17					      REPEND
    361  0a18		       02		      .byte.b	.BANK
    360  0a18					      REPEND
    361  0a19		       02		      .byte.b	.BANK
    360  0a19					      REPEND
    361  0a1a		       02		      .byte.b	.BANK
    360  0a1a					      REPEND
    361  0a1b		       02		      .byte.b	.BANK
    360  0a1b					      REPEND
    361  0a1c		       02		      .byte.b	.BANK
    360  0a1c					      REPEND
    361  0a1d		       02		      .byte.b	.BANK
    362  0a1e					      REPEND
    363  0a1e				   .BANK      SET	.BANK + 1
    359  0a1e					      REPEND
    360  0a1e					      REPEAT	SCREEN_WIDTH
    361  0a1e		       03		      .byte.b	.BANK
    360  0a1e					      REPEND
    361  0a1f		       03		      .byte.b	.BANK
    360  0a1f					      REPEND
    361  0a20		       03		      .byte.b	.BANK
    360  0a20					      REPEND
    361  0a21		       03		      .byte.b	.BANK
    360  0a21					      REPEND
    361  0a22		       03		      .byte.b	.BANK
    360  0a22					      REPEND
    361  0a23		       03		      .byte.b	.BANK
    360  0a23					      REPEND
    361  0a24		       03		      .byte.b	.BANK
    360  0a24					      REPEND
    361  0a25		       03		      .byte.b	.BANK
    360  0a25					      REPEND
    361  0a26		       03		      .byte.b	.BANK
    360  0a26					      REPEND
    361  0a27		       03		      .byte.b	.BANK
    362  0a28					      REPEND
    363  0a28				   .BANK      SET	.BANK + 1
    359  0a28					      REPEND
    360  0a28					      REPEAT	SCREEN_WIDTH
    361  0a28		       04		      .byte.b	.BANK
    360  0a28					      REPEND
    361  0a29		       04		      .byte.b	.BANK
    360  0a29					      REPEND
    361  0a2a		       04		      .byte.b	.BANK
    360  0a2a					      REPEND
    361  0a2b		       04		      .byte.b	.BANK
    360  0a2b					      REPEND
    361  0a2c		       04		      .byte.b	.BANK
    360  0a2c					      REPEND
    361  0a2d		       04		      .byte.b	.BANK
    360  0a2d					      REPEND
    361  0a2e		       04		      .byte.b	.BANK
    360  0a2e					      REPEND
    361  0a2f		       04		      .byte.b	.BANK
    360  0a2f					      REPEND
    361  0a30		       04		      .byte.b	.BANK
    360  0a30					      REPEND
    361  0a31		       04		      .byte.b	.BANK
    362  0a32					      REPEND
    363  0a32				   .BANK      SET	.BANK + 1
    359  0a32					      REPEND
    360  0a32					      REPEAT	SCREEN_WIDTH
    361  0a32		       05		      .byte.b	.BANK
    360  0a32					      REPEND
    361  0a33		       05		      .byte.b	.BANK
    360  0a33					      REPEND
    361  0a34		       05		      .byte.b	.BANK
    360  0a34					      REPEND
    361  0a35		       05		      .byte.b	.BANK
    360  0a35					      REPEND
    361  0a36		       05		      .byte.b	.BANK
    360  0a36					      REPEND
    361  0a37		       05		      .byte.b	.BANK
    360  0a37					      REPEND
    361  0a38		       05		      .byte.b	.BANK
    360  0a38					      REPEND
    361  0a39		       05		      .byte.b	.BANK
    360  0a39					      REPEND
    361  0a3a		       05		      .byte.b	.BANK
    360  0a3a					      REPEND
    361  0a3b		       05		      .byte.b	.BANK
    362  0a3c					      REPEND
    363  0a3c				   .BANK      SET	.BANK + 1
    359  0a3c					      REPEND
    360  0a3c					      REPEAT	SCREEN_WIDTH
    361  0a3c		       06		      .byte.b	.BANK
    360  0a3c					      REPEND
    361  0a3d		       06		      .byte.b	.BANK
    360  0a3d					      REPEND
    361  0a3e		       06		      .byte.b	.BANK
    360  0a3e					      REPEND
    361  0a3f		       06		      .byte.b	.BANK
    360  0a3f					      REPEND
    361  0a40		       06		      .byte.b	.BANK
    360  0a40					      REPEND
    361  0a41		       06		      .byte.b	.BANK
    360  0a41					      REPEND
    361  0a42		       06		      .byte.b	.BANK
    360  0a42					      REPEND
    361  0a43		       06		      .byte.b	.BANK
    360  0a43					      REPEND
    361  0a44		       06		      .byte.b	.BANK
    360  0a44					      REPEND
    361  0a45		       06		      .byte.b	.BANK
    362  0a46					      REPEND
    363  0a46				   .BANK      SET	.BANK + 1
    359  0a46					      REPEND
    360  0a46					      REPEAT	SCREEN_WIDTH
    361  0a46		       07		      .byte.b	.BANK
    360  0a46					      REPEND
    361  0a47		       07		      .byte.b	.BANK
    360  0a47					      REPEND
    361  0a48		       07		      .byte.b	.BANK
    360  0a48					      REPEND
    361  0a49		       07		      .byte.b	.BANK
    360  0a49					      REPEND
    361  0a4a		       07		      .byte.b	.BANK
    360  0a4a					      REPEND
    361  0a4b		       07		      .byte.b	.BANK
    360  0a4b					      REPEND
    361  0a4c		       07		      .byte.b	.BANK
    360  0a4c					      REPEND
    361  0a4d		       07		      .byte.b	.BANK
    360  0a4d					      REPEND
    361  0a4e		       07		      .byte.b	.BANK
    360  0a4e					      REPEND
    361  0a4f		       07		      .byte.b	.BANK
    362  0a50					      REPEND
    363  0a50				   .BANK      SET	.BANK + 1
    364  0a50					      REPEND
    365  0a50
      0  0a50					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  0a50
      2  0a50
      3  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $250 , FREE= $1b0
      4  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0a50				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0a50				  -	      ERR
      8  0a50					      endif
    367  0a50
    368  0a50
      0  0a50					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $250 , FREE= $5b0
      2  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0a50				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0a50				  -	      ERR
      6  0a50					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 3
      0  0a50					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  0a50							;    Sokoboo - a Sokoban implementation
      2  0a50							;    using a generic tile-based display engine for the Atari 2600
      3  0a50							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0a50							;
      5  0a50							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0a50							;
      7  0a50							;    Code related to the generic tile-based display engine was developed by
      8  0a50							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0a50							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0a50							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0a50							;
     12  0a50							;    Code related to music and sound effects uses the TIATracker music player
     13  0a50							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0a50							;    directory for Apache licensing details.
     15  0a50							;
     16  0a50							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0a50							;    See the copyright notices in the License directory for a list of level
     18  0a50							;    contributors.
     19  0a50							;
     20  0a50							;    Except where otherwise indicated, this software is released under the
     21  0a50							;    following licensing arrangement...
     22  0a50							;
     23  0a50							;    This program is free software: you can redistribute it and/or modify
     24  0a50							;    it under the terms of the GNU General Public License as published by
     25  0a50							;    the Free Software Foundation, either version 3 of the License, or
     26  0a50							;    (at your option) any later version.
     27  0a50							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0a50
     29  0a50							;    This program is distributed in the hope that it will be useful,
     30  0a50							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0a50							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0a50							;    GNU General Public License for more details.
     33  0a50
     34  0a50							;------------------------------------------------------------------------------
     35  0a50							;##############################################################################
     36  0a50							;------------------------------------------------------------------------------
      0  0a50					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  139d ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
     38  1000
     39  1000
     40  1000		       00 9a	   SCORE_COL  =	$9a	;WHITE ;-2
     41  1000		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     42  1000		       00 66	   SCORE_COL_HIGH_PAL =	$66
     43  1000
     44  1000
     45  1000				   DigitVectorLOr
     46  1000		       31 3f 4d 38*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     47  100a		       00 07 0e 15	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     48  100e				   DigitVectorLO
     49  100e		       53 61 6e 5a*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     50  1018		       37		      .byte.b	<BLANKL-1
     51  1019
     52  1019
     53  1019		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     54  1019		       00 0b	   ID_TARGET  =	11
     55  1019		       00 0c	   ID_EXTRA   =	12
     56  1019		       00 0d	   ID_CLOCK   =	13
     57  1019		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     58  1019
     59  1019							; score patch adresses:
     60  1019				   SMTblLSB
     61  1019				   SMTblTargets
     62  1019		       52 48		      .byte.b	SM_TARGET0+1-SM_BASE, SM_TARGET2+1-SM_BASE
     63  101b				   SMTblTime
     64  101b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     65  101d				   SMTblScore
     66  101d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     67  1020				   SMTblMSB
     68  1020		       4d 43		      .byte.b	SM_TARGET1+1-SM_BASE, SM_TARGET3+1-SM_BASE
     69  1022		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     70  1024		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     71  1027
     72  1027		       00 00	   SM_OFS_TARGETS =	SMTblTargets - SMTblLSB
     73  1027		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     74  1027		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     75  1027
     76  1027				   CharVectorLO
     77  1027		       37		      .byte.b	<BLANKL-1
     78  1028		       ad ad ad ad	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     79  102c		       ad ad ad ad	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     80  1030		       ad ad ad ad	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     81  1034		       ad ad ad ad	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     82  1038							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     83  1038
     84  1038							; Digit shape definitions are at start of bank so that we don't have page boundary
     85  1038							; crossing issues.
     86  1038
     87  1038							;	  .byte 0	      ; required!
     88  1038
     89  1038		       00 07	   DIGIT_H    =	7	; height of a score digit
     90  1038
     91  1038		       00 00 00 00*BLANKL     ds	7,0
     92  103f
     93  103f
     94  103f
     95  103f				   NineL
     96  103f		       1e		      .byte.b	%00011110
     97  1040		       02		      .byte.b	%00000010
     98  1041		       02		      .byte.b	%00000010
     99  1042		       fe		      .byte.b	%11111110
    100  1043		       82		      .byte.b	%10000010
    101  1044		       82		      .byte.b	%10000010
    102  1045		       fe		      .byte.b	%11111110
    103  1046
    104  1046				   SixL
    105  1046		       fe		      .byte.b	%11111110
    106  1047		       82		      .byte.b	%10000010
    107  1048		       82		      .byte.b	%10000010
    108  1049		       fe		      .byte.b	%11111110
    109  104a		       80		      .byte.b	%10000000
    110  104b		       80		      .byte.b	%10000000
    111  104c		       f0		      .byte.b	%11110000
    112  104d
    113  104d							;    .byte %01111100
    114  104d							;    .byte %11000010
    115  104d							;    .byte %11000010
    116  104d							;    .byte %11111100
    117  104d							;    .byte %11000000
    118  104d							;    .byte %01100000
    119  104d							;    .byte %00111000
    120  104d				   EightL
    121  104d
    122  104d
    123  104d		       fe		      .byte.b	%11111110
    124  104e		       82		      .byte.b	%10000010
    125  104f		       82		      .byte.b	%10000010
    126  1050		       fe		      .byte.b	%11111110
    127  1051		       82		      .byte.b	%10000010
    128  1052		       82		      .byte.b	%10000010
    129  1053		       fe		      .byte.b	%11111110
    130  1054
    131  1054							;  .byte %01111100
    132  1054							;  .byte %10000110
    133  1054							;  .byte %10000110
    134  1054							;  .byte %01111100
    135  1054							;  .byte %01000110
    136  1054							;  .byte %01000110
    137  1054							;  .byte %00111100
    138  1054				   ZeroL
    139  1054							;  .byte %01111100
    140  1054							;  .byte %10000110
    141  1054							;  .byte %10000110
    142  1054							;  .byte %10000110
    143  1054							;  .byte %10000110
    144  1054							;  .byte %01000110
    145  1054							;  .byte %00111100
    146  1054
    147  1054		       fe		      .byte.b	%11111110
    148  1055		       82		      .byte.b	%10000010
    149  1056		       82		      .byte.b	%10000010
    150  1057		       82		      .byte.b	%10000010
    151  1058		       82		      .byte.b	%10000010
    152  1059		       82		      .byte.b	%10000010
    153  105a		       fe		      .byte.b	%11111110
    154  105b
    155  105b				   ThreeL
    156  105b		       fe		      .byte.b	%11111110
    157  105c		       02		      .byte.b	%00000010
    158  105d		       02		      .byte.b	%00000010
    159  105e		       1e		      .byte.b	%00011110
    160  105f		       02		      .byte.b	%00000010
    161  1060		       02		      .byte.b	%00000010
    162  1061		       fe		      .byte.b	%11111110
    163  1062				   OneL
    164  1062		       10		      .byte.b	%00010000
    165  1063		       10		      .byte.b	%00010000
    166  1064		       10		      .byte.b	%00010000
    167  1065		       10		      .byte.b	%00010000
    168  1066		       10		      .byte.b	%00010000
    169  1067		       10		      .byte.b	%00010000
    170  1068		       10		      .byte.b	%00010000
    171  1069
    172  1069				   SevenL
    173  1069
    174  1069		       10		      .byte.b	%00010000
    175  106a		       10		      .byte.b	%00010000
    176  106b		       10		      .byte.b	%00010000
    177  106c		       1e		      .byte.b	%00011110
    178  106d		       02		      .byte.b	%00000010
    179  106e		       02		      .byte.b	%00000010
    180  106f							;  .byte %11111110
    181  106f
    182  106f							;    .byte %00010000
    183  106f							;    .byte %00010000
    184  106f							;    .byte %00010000
    185  106f							;    .byte %00011000
    186  106f							;    .byte %00001100
    187  106f							;    .byte %10000110
    188  106f							;    ;.byte %11111110
    189  106f				   TwoL
    190  106f		       fe		      .byte.b	%11111110
    191  1070		       80		      .byte.b	%10000000
    192  1071		       80		      .byte.b	%10000000
    193  1072		       fe		      .byte.b	%11111110
    194  1073		       02		      .byte.b	%00000010
    195  1074		       02		      .byte.b	%00000010
    196  1075		       fe		      .byte.b	%11111110
    197  1076
    198  1076				   FiveL
    199  1076		       fe		      .byte.b	%11111110
    200  1077		       02		      .byte.b	%00000010
    201  1078		       02		      .byte.b	%00000010
    202  1079		       fe		      .byte.b	%11111110
    203  107a		       80		      .byte.b	%10000000
    204  107b		       80		      .byte.b	%10000000
    205  107c		       f0		      .byte.b	%11110000
    206  107d
    207  107d				   FourL
    208  107d		       10		      .byte.b	%00010000
    209  107e		       10		      .byte.b	%00010000
    210  107f		       10		      .byte.b	%00010000
    211  1080		       fe		      .byte.b	%11111110
    212  1081		       90		      .byte.b	%10010000
    213  1082		       90		      .byte.b	%10010000
    214  1083		       90		      .byte.b	%10010000
    215  1084
    216  1084
    217  1084				   ZL
    218  1084		       7f		      .byte.b	%01111111
    219  1085		       40		      .byte.b	%01000000
    220  1086		       40		      .byte.b	%01000000
    221  1087		       7f		      .byte.b	%01111111
    222  1088		       01		      .byte.b	%00000001
    223  1089		       01		      .byte.b	%00000001
    224  108a		       0f		      .byte.b	%00001111
    225  108b
    226  108b				   EL
    227  108b		       7f		      .byte.b	%01111111
    228  108c		       40		      .byte.b	%01000000
    229  108d		       40		      .byte.b	%01000000
    230  108e		       78		      .byte.b	%01111000
    231  108f		       40		      .byte.b	%01000000
    232  1090		       40		      .byte.b	%01000000
    233  1091		       7f		      .byte.b	%01111111
    234  1092
    235  1092				   RL
    236  1092		       48		      .byte.b	%01001000
    237  1093		       48		      .byte.b	%01001000
    238  1094		       48		      .byte.b	%01001000
    239  1095		       7f		      .byte.b	%01111111
    240  1096		       41		      .byte.b	%01000001
    241  1097		       41		      .byte.b	%01000001
    242  1098		       7f		      .byte.b	%01111111
    243  1099
    244  1099				   PL
    245  1099		       40		      .byte.b	%01000000
    246  109a		       40		      .byte.b	%01000000
    247  109b		       40		      .byte.b	%01000000
    248  109c		       7f		      .byte.b	%01111111
    249  109d		       41		      .byte.b	%01000001
    250  109e		       41		      .byte.b	%01000001
    251  109f		       7f		      .byte.b	%01111111
    252  10a0
    253  10a0				   AL
    254  10a0		       41		      .byte.b	%01000001
    255  10a1		       41		      .byte.b	%01000001
    256  10a2		       41		      .byte.b	%01000001
    257  10a3		       7f		      .byte.b	%01111111
    258  10a4		       41		      .byte.b	%01000001
    259  10a5		       41		      .byte.b	%01000001
    260  10a6		       7f		      .byte.b	%01111111
    261  10a7
    262  10a7				   GL
    263  10a7		       7f		      .byte.b	%01111111
    264  10a8		       41		      .byte.b	%01000001
    265  10a9		       41		      .byte.b	%01000001
    266  10aa		       4f		      .byte.b	%01001111
    267  10ab		       40		      .byte.b	%01000000
    268  10ac		       40		      .byte.b	%01000000
    269  10ad		       7f		      .byte.b	%01111111
    270  10ae
    271  10ae
    272  10ae							; level "name" characters (left only!):
    273  10ae
    274  10ae				   CharN
    275  10ae				   CharK
    276  10ae				   CharH
    277  10ae				   CharA
    278  10ae				   CharJ
    279  10ae				   CharP
    280  10ae				   CharB
    281  10ae				   CharO
    282  10ae				   CharC
    283  10ae				   CharI
    284  10ae				   CharD
    285  10ae				   CharG
    286  10ae				   CharE
    287  10ae				   CharL
    288  10ae				   CharF
    289  10ae				   CharM
    290  10ae		       00 00 00 00*	      ds	7,0
    291  10b5
    292  10b5				   charPlace
    293  10b5		       0c		      .byte.b	%00001100
    294  10b6		       0c		      .byte.b	%00001100
    295  10b7		       0c		      .byte.b	%00001100
    296  10b8		       0c		      .byte.b	%00001100
    297  10b9		       0c		      .byte.b	%00001100
    298  10ba		       00		      .byte.b	%00000000
    299  10bb		       0c		      .byte.b	%00001100
    300  10bc
    301  10bc							;-------------------------------------------------------------------------------------
    302  10bc				   PosTbl
    303  10bc		       40		      .byte.b	$40
    304  10bd		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    305  10c5		       b9		      .byte.b	$b9
    306  10c6
    307  10c6
    308  10c6							;------------------------------------------------------------------------------
    309  10c6							; RAM-BASED SUBROUTINES...
    310  10c6							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    311  10c6							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    312  10c6							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    313  10c6							; the RAM-based routine.
    314  10c6
    315  1100		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    316  1100
    317  1100		       f1 00	   SM_BASE    =	.
    318  1100
    319  1100							;#IF 0 ;{
    320  1100							;    DEFINE_SUBROUTINE Score3x3
    321  1100							;
    322  1100							;	  sta	  RESP0
    323  1100							;	   sta	   RESP1
    324  1100							;	   lda	   #$$000
    325  1100							;	    sta     GRP0
    326  1100							;	    lda     #$$009
    327  1100							;	    sta     GRP1
    328  1100							;	    lda     #$$202
    329  1100							;	    sta     ENABL
    330  1100							;	    nop
    331  1100							;	    nop
    332  1100							;	    nop
    333  1100							;	    lda     #$$016
    334  1100							;	    ldy     #$$100
    335  1100							;	    ldx     #$$109
    336  1100							;	    sta     GRP0    ; Critical time is right here
    337  1100							;	    stx     GRP1
    338  1100							;	    sty     GRP0
    339  1100							;	    sta     RESP0
    340  1100							;	    sta     RESP1
    341  1100							;	    ldx     #$$116
    342  1100							;	    lda     #$$209
    343  1100							;	    stx     GRP0
    344  1100							;	    sta     GRP1
    345  1100							;	    lda     #$$200
    346  1100							;	    sta     GRP0
    347  1100							;	    sta     RESP0
    348  1100							;	    sta     RESP1
    349  1100							;	    lda     #$$216
    350  1100							;	    nop
    351  1100							;	    sta     GRP0
    352  1100							;
    353  1100							;	      rts
    354  1100							;#ENDIF ;}
    355  1100
    356  1100
    357  1100							;------------------------------------------------------------------------------
    358  1100				   Score1x6Fix SUBROUTINE
      0  1100					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  1100		       00 02	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  1100					      SUBROUTINE
      3  1100				   DrawDigits1x6
    360  1100							;					     @07
    361  1100		       ba		      tsx		; 2
    362  1101
    363  1101		       20 fe f1 	      jsr	PrepareDrawDigits	;56 = 58    @65
    364  1104
    365  1104		       86 d2		      stx	tmpStack	; 3 =	3
    366  1106
    367  1106				   LoopDraw1x6		;
    368  1106				   SMDIGIT0
    369  1106		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    370  1109		       85 42		      sta	WSYNC	; 3
    371  110b							;---------------------------------------------------------------
    372  110b		       85 6a		      sta	HMOVE	; 3
      0  110d					      SLEEP	3	; 3 =	6
      1  110d				   .CYCLES    SET	3
      2  110d
      3  110d				  -	      IF	.CYCLES < 2
      4  110d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  110d				  -	      ERR
      6  110d					      ENDIF
      7  110d
      8  110d					      IF	.CYCLES & 1
      9  110d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  110d		       04 00		      nop	0
     11  110f				  -	      ELSE
     12  110f				  -	      bit	VSYNC
     13  110f					      ENDIF
     14  110f				   .CYCLES    SET	.CYCLES - 3
     15  110f					      ENDIF
     16  110f
     17  110f				  -	      REPEAT	.CYCLES / 2
     18  110f				  -	      nop
     19  110f					      REPEND
    374  110f		       85 5b		      sta	GRP0	; 3
    375  1111				   SMDIGIT1
    376  1111		       b9 53 f0 	      lda	ZeroL-1,y	; 4
    377  1114		       85 5c		      sta	GRP1	; 3
    378  1116				   SMDIGIT2
    379  1116		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    380  1119		       85 5b		      sta	GRP0	; 3 = 17
    381  111b				   SMDIGIT5
    382  111b		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    383  111e		       9a		      txs		; 2
    384  111f				   SMDIGIT3
    385  111f		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    386  1122				   SMDIGIT4
    387  1122		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    388  1125		       85 6b		      sta	HMCLR	; 3
    389  1127		       86 5c		      stx	GRP1	; 3
    390  1129		       85 5b		      sta	GRP0	; 3 = 23
    391  112b
    392  112b		       ba		      tsx		; 2
    393  112c		       86 5c		      stx	GRP1	; 3
    394  112e		       85 5b		      sta	GRP0	; 3 =	8
    395  1130
    396  1130		       88		      dey		; 2
      0  1131					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  1131					      LIST	ON
      9  1131		       d0 d3		      bne	LoopDraw1x6
    398  1133
    399  1133		       a6 d2		      ldx	tmpStack	; 3
    400  1135		       9a		      txs		; 2
    401  1136				   ExitDigitKernel6
      0  1136					      SLEEP	3	; 3
      1  1136				   .CYCLES    SET	3
      2  1136
      3  1136				  -	      IF	.CYCLES < 2
      4  1136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1136				  -	      ERR
      6  1136					      ENDIF
      7  1136
      8  1136					      IF	.CYCLES & 1
      9  1136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1136		       04 00		      nop	0
     11  1138				  -	      ELSE
     12  1138				  -	      bit	VSYNC
     13  1138					      ENDIF
     14  1138				   .CYCLES    SET	.CYCLES - 3
     15  1138					      ENDIF
     16  1138
     17  1138				  -	      REPEAT	.CYCLES / 2
     18  1138				  -	      nop
     19  1138					      REPEND
    403  1138		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    404  113b
    405  113b
    406  113b							;------------------------------------------------------------------------------
    407  113b				   Score2x4Fix SUBROUTINE
      0  113b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  113b		       00 02	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  113b					      SUBROUTINE
      3  113b				   DrawDigits2x4
    409  113b
    410  113b
    411  113b							; Subroutine by Thomas Jentzsch.  Magic!
    412  113b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    413  113b
    414  113b							;sta COLUBK
    415  113b
    416  113b		       20 fe f1 	      jsr	PrepareDrawDigits	;56 = 56    @63
    417  113e
    418  113e		       85 6a		      sta	HMOVE	; 3
      0  1140					      SLEEP	4	; 4  =  7
      1  1140				   .CYCLES    SET	4
      2  1140
      3  1140				  -	      IF	.CYCLES < 2
      4  1140				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1140				  -	      ERR
      6  1140					      ENDIF
      7  1140
      8  1140				  -	      IF	.CYCLES & 1
      9  1140				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1140				  -	      nop	0
     11  1140				  -	      ELSE
     12  1140				  -	      bit	VSYNC
     13  1140				  -	      ENDIF
     14  1140				  -.CYCLES    SET	.CYCLES - 3
     15  1140					      ENDIF
     16  1140
     17  1140					      REPEAT	.CYCLES / 2
     18  1140		       ea		      nop
     17  1140					      REPEND
     18  1141		       ea		      nop
     19  1142					      REPEND
    420  1142
    421  1142				   LoopDraw2x4		;	     @70
    422  1142				   SM_TARGET3
    423  1142		       b9 07 f3 	      lda	DequalsR-1,y	; 4		     G
    424  1145							;---------------------------------------------------------------
    425  1145		       85 5b		      sta	GRP0	; 3
    426  1147				   SM_TARGET2
    427  1147		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     A
    428  114a		       85 5c		      sta	GRP1	; 3
    429  114c				   SM_TARGET1
    430  114c		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     M
    431  114f		       85 5b		      sta	GRP0	; 3
    432  1151				   SM_TARGET0
    433  1151		       be 53 f0 	      ldx	ZeroL-1,y	; 4		     E
    434  1154		       85 50		      sta	RESP0	; 3 = 28    @22
    435  1156		       85 51		      sta	RESP1	; 3 =	3    @25
    436  1158				   SM_Time3
    437  1158		       b9 15 f3 	      lda	ClockR-1,y	; 4		     O
    438  115b		       86 5c		      stx	GRP1	; 3
    439  115d		       85 5b		      sta	GRP0	; 3
    440  115f				   SM_Time2
    441  115f		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     V
    442  1162		       85 5c		      sta	GRP1	; 3
    443  1164				   SM_Time1
    444  1164		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     E
    445  1167		       85 5b		      sta	GRP0	; 3
    446  1169		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    447  116b		       85 51		      sta	RESP1	; 3 =	3    @55
    448  116d				   SM_Time0
    449  116d		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     R
    450  1170		       85 5c		      sta	GRP1	; 3
    451  1172		       85 5b		      sta	GRP0	; 3
    452  1174		       88		      dey		; 2
      0  1175					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  1175					      LIST	ON
      9  1175		       d0 cb		      bne	LoopDraw2x4
    454  1177
    455  1177				   ExitDigitKernel		;	     @69
    456  1177		       84 5b		      sty	GRP0	; 3
    457  1179		       84 5c		      sty	GRP1	; 3
    458  117b							;---------------------------------------------------------------
    459  117b		       84 5b		      sty	GRP0	; 3	     @02
    460  117d
    461  117d							; Contribution by Thomas Jentzsch
    462  117d							; Rewrite/Optimised for single sprite AD
    463  117d
    464  117d		       a6 9f		      ldx	ManDrawX	; 3
    465  117f		       bd bc f0 	      lda	PosTbl,x	; 4
    466  1182		       85 60		      sta	HMP0	; 3
    467  1184		       29 0f		      and	#$0f	; 2
    468  1186		       f0 04		      beq	.zeroPos	; 2/3=15
    469  1188		       aa		      tax		; 2
    470  1189				   .loopWait
    471  1189		       ca		      dex		; 2
    472  118a		       d0 fd		      bne	.loopWait	; 2/3= 6
    473  118c				   .zeroPos
    474  118c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    475  118e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    476  1190
    477  1190		       85 42		      sta	WSYNC
    478  1192		       85 6a		      sta	HMOVE	; 3
    479  1194
    480  1194		       a5 b1		      lda	BGColour	; 3
    481  1196		       85 49		      sta	COLUBK	;3
    482  1198
    483  1198		       86 62		      stx	HMM0	; 3	     for extra life stars!
    484  119a
    485  119a		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
    486  119c		       85 44		      sta	NUSIZ0	; 3
    487  119e		       85 45		      sta	NUSIZ1
    488  11a0		       84 65		      sty	VDELP0	; 3	 y = 0!
    489  11a2
      0  11a2					      SLEEP	5
      1  11a2				   .CYCLES    SET	5
      2  11a2
      3  11a2				  -	      IF	.CYCLES < 2
      4  11a2				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11a2				  -	      ERR
      6  11a2					      ENDIF
      7  11a2
      8  11a2					      IF	.CYCLES & 1
      9  11a2					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11a2		       04 00		      nop	0
     11  11a4				  -	      ELSE
     12  11a4				  -	      bit	VSYNC
     13  11a4					      ENDIF
     14  11a4				   .CYCLES    SET	.CYCLES - 3
     15  11a4					      ENDIF
     16  11a4
     17  11a4					      REPEAT	.CYCLES / 2
     18  11a4		       ea		      nop
     19  11a5					      REPEND
    491  11a5
    492  11a5		       a5 a2		      lda	ManLastDirection	; 3
    493  11a7		       85 4b		      sta	REFP0	; 3
    494  11a9
    495  11a9							;sta WSYNC		  ; 3
    496  11a9		       60		      rts		; 6	     @21
    497  11aa
    498  11aa							;------------------------------------------------------------------------------
    499  11aa				   Score3x2Fix SUBROUTINE
      0  11aa					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  11aa		       00 02	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  11aa					      SUBROUTINE
      3  11aa				   DrawDigits3x2
    501  11aa							;					     @07
    502  11aa		       a9 16		      lda	#%010110	; 2
    503  11ac		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    504  11ae		       20 04 f2 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    505  11b1
    506  11b1		       a9 00		      lda	#0
    507  11b3		       85 66		      sta	VDELP1
    508  11b5				   LoopDraw3x2		;
    509  11b5		       85 42		      sta	WSYNC	; 3
    510  11b7							;---------------------------------------------------------------
    511  11b7		       85 6a		      sta	HMOVE	; 3 =	3
    512  11b9		       b9 ad f0 	      lda	CharP-1,y	; 4
    513  11bc		       85 5b		      sta	GRP0	; 3
    514  11be				   SMPLAYER
    515  11be		       b9 3f f3 	      lda	OneR-1,y	; 4
    516  11c1		       85 5c		      sta	GRP1	; 3 = 14    @17
    517  11c3		       b9 b4 f0 	      lda	charPlace-1,y	; 4
    518  11c6				   SMMEN
    519  11c6		       be 38 f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  11c9					      SLEEP	5	;   =	5
      1  11c9				   .CYCLES    SET	5
      2  11c9
      3  11c9				  -	      IF	.CYCLES < 2
      4  11c9				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11c9				  -	      ERR
      6  11c9					      ENDIF
      7  11c9
      8  11c9					      IF	.CYCLES & 1
      9  11c9					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11c9		       04 00		      nop	0
     11  11cb				  -	      ELSE
     12  11cb				  -	      bit	VSYNC
     13  11cb					      ENDIF
     14  11cb				   .CYCLES    SET	.CYCLES - 3
     15  11cb					      ENDIF
     16  11cb
     17  11cb					      REPEAT	.CYCLES / 2
     18  11cb		       ea		      nop
     19  11cc					      REPEND
    521  11cc		       85 5b		      sta	GRP0	; 3
    522  11ce				   SMLEVELX
    523  11ce		       b9 ad f0 	      lda	CharA-1,y	; 4
    524  11d1		       85 6b		      sta	HMCLR	; 3 = 10    @40
    525  11d3		       86 5c		      stx	GRP1	; 3 =	3    @43
    526  11d5		       85 5b		      sta	GRP0	; 3
    527  11d7				   SMLEVEL
    528  11d7		       b9 3f f3 	      lda	OneR-1,y	; 4
    529  11da		       85 5c		      sta	GRP1	; 3 = 10    @53
    530  11dc
    531  11dc		       88		      dey		; 2
      0  11dd					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  11dd					      LIST	ON
      9  11dd		       d0 d6		      bne	LoopDraw3x2
    533  11df							;					     @57
      0  11df					      SLEEP	3	; 3
      1  11df				   .CYCLES    SET	3
      2  11df
      3  11df				  -	      IF	.CYCLES < 2
      4  11df				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11df				  -	      ERR
      6  11df					      ENDIF
      7  11df
      8  11df					      IF	.CYCLES & 1
      9  11df					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11df		       04 00		      nop	0
     11  11e1				  -	      ELSE
     12  11e1				  -	      bit	VSYNC
     13  11e1					      ENDIF
     14  11e1				   .CYCLES    SET	.CYCLES - 3
     15  11e1					      ENDIF
     16  11e1
     17  11e1				  -	      REPEAT	.CYCLES / 2
     18  11e1				  -	      nop
     19  11e1					      REPEND
    535  11e1		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    536  11e4
    537  11e4
    538  11e4							;------------------------------------------------------------------------------
      0  11e4					      DEFINE_SUBROUTINE	DrawDigits
      1  11e4		       00 02	   BANK_DrawDigits =	_CURRENT_BANK
      2  11e4					      SUBROUTINE
      3  11e4				   DrawDigits
    540  11e4
    541  11e4				   VblankLoopGame
    542  11e4		       ac 84 02 	      ldy	INTIM
    543  11e7		       d0 fb		      bne	VblankLoopGame
    544  11e9
    545  11e9					      IF	WAIT_FOR_INITIAL_DRAW
    546  11e9		       a4 ae		      ldy	blankState
    547  11eb					      ENDIF
    548  11eb		       84 41		      sty	VBLANK	; 3	     <-- 0
    549  11ed							;lda scoringFlags	  ; 3
    550  11ed							;and #DISPLAY_FLAGS		    ; 2
    551  11ed							;tax			  ; 2
    552  11ed
    553  11ed		       a2 00		      ldx	#0
    554  11ef
    555  11ef							;    DEFINE_SUBROUTINE DrawDigit2
    556  11ef							;
    557  11ef							;    ; Generic interface to scoring routine
    558  11ef
    559  11ef		       bd fa f1 	      lda	ScoreKernelLo,x	; 4
    560  11f2
    561  11f2		       85 42		      sta	WSYNC	; 3
    562  11f4							;---------------------------------------------------------------
    563  11f4		       8d f8 f5 	      sta	SMJUMP+1+RAM_WRITE	; 4
    564  11f7				   SMJUMP
    565  11f7		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    566  11fa
    567  11fa				   ScoreKernelLo
    568  11fa		       3b		      .byte.b	<Score2x4Fix	; TARGETs, time
    569  11fb		       00		      .byte.b	<Score1x6Fix	; score
    570  11fc		       aa		      .byte.b	<Score3x2Fix	; player, lives, level
    571  11fd		       00		      .byte.b	<Score1x6Fix	; high score
    572  11fe
      0  11fe					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  11fe					      LIST	ON
    574  11fe
    575  11fe							;------------------------------------------------------------------------------
      0  11fe					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  11fe		       00 02	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  11fe					      SUBROUTINE
      3  11fe				   PrepareDrawDigits
    577  11fe							;					     @13
    578  11fe		       a0 d1		      ldy	#$d1	; 2
    579  1200		       a9 13		      lda	#%010011	; 2
    580  1202		       85 66		      sta	VDELP1	; 3 =	7
    581  1204				   PrepareDrawDigits2		;	    @17/20
    582  1204		       84 65		      sty	VDELP0	; 3 =	3
    583  1206
    584  1206		       85 45		      sta	NUSIZ1	; 3
    585  1208		       85 44		      sta	NUSIZ0	; 3 =	6
    586  120a
    587  120a		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    588  120d		       85 50		      sta	RESP0	; 3	     @33/36
    589  120f		       85 51		      sta	RESP1	; 3 = 10    @36/39
    590  1211
    591  1211		       84 60		      sty	HMP0	; 3
    592  1213		       c8		      iny		; 2
    593  1214		       84 61		      sty	HMP1	; 3 =	8
    594  1216				   SMCOLOR
    595  1216		       a0 9a		      ldy	#SCORE_COL	; 2
    596  1218		       84 46		      sty	COLUP0	; 3
    597  121a		       84 47		      sty	COLUP1	; 3 =	8
    598  121c
    599  121c		       a0 07		      ldy	#DIGIT_H	; 2
    600  121e		       60		      rts		; 6 =	8
    601  121f							; total: 27
    602  121f
    603  121f
    604  121f							;------------------------------------------------------------------------------
      0  121f					      DEFINE_SUBROUTINE	UpdateScore
      1  121f		       00 02	   BANK_UpdateScore =	_CURRENT_BANK
      2  121f					      SUBROUTINE
      3  121f				   UpdateScore
    606  121f							; a = added score value
    607  121f
    608  121f							; initially switch to score:
    609  121f		       a0 01		      ldy	#DISPLAY_SCORE
    610  1221		       84 d2		      sty	newDisplay
    611  1223
    612  1223		       18		      clc
    613  1224		       f8		      sed
    614  1225		       a0 04		      ldy	#SM_OFS_SCORE
    615  1227				   .loopScore
    616  1227		       79 8a f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    617  122a		       99 8a f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    618  122d		       08		      php
    619  122e							; *** bonus life every 500 points: ***
    620  122e							;	  cpy #SM_OFS_SCORE+1
    621  122e							;	  bne .skipBonusLife
    622  122e							;	  tax
    623  122e
    624  122e							;	  and #$0f
    625  122e							;	  beq .bonusLife		      ; 000?
    626  122e							;	  cmp #$05
    627  122e							;	  bne .noBonusLife		      ; 500?
    628  122e							;.bonusLife:
    629  122e							; add extra life, limited to 9
    630  122e
    631  122e							;	  lda ManCount
    632  122e							;	  and #$0f
    633  122e							;	  cmp #9
    634  122e							;	  bcs .noBonusLife
    635  122e							;	  inc ManCount
    636  122e
    637  122e							; bonus life has priority over score:
    638  122e							;	  lda #DISPLAY_LIVES
    639  122e							;	  sta newDisplay
    640  122e							;lda #EXTRA_LIFE_TIMER
    641  122e							;sta extraLifeTimer
    642  122e
    643  122e				   .noBonusLife
    644  122e		       8a		      txa
    645  122f				   .skipBonusLife
    646  122f		       20 aa f2 	      jsr	SetupBCDPtr
    647  1232		       28		      plp
    648  1233		       a9 00		      lda	#0
    649  1235		       b0 f0		      bcs	.loopScore
    650  1237		       d8		      cld
    651  1238
    652  1238							; switch display
    653  1238							;lda scoringFlags
    654  1238							;and #DISPLAY_FLAGS
    655  1238							;cmp newDisplay		      ; lower priority than current?
    656  1238							;beq .restartTime
    657  1238							;bcs .skipNew
    658  1238							;eor scoringFlags		      ; remove existing score mode
    659  1238							;ora newDisplay		      ; switch to new score mode
    660  1238							;sta scoringFlags
    661  1238				   .restartTime
    662  1238							;lda #SCORING_TIMER		      ; maybe always restart timer?
    663  1238							;sta scoringTimer
    664  1238				   .skipNew
    665  1238
    666  1238		       60		      rts
    667  1239
    668  1239							;---------------------------------------------------------------------------
    669  1239
      0  1239					      DEFINE_SUBROUTINE	SwapPlayers
      1  1239		       00 02	   BANK_SwapPlayers =	_CURRENT_BANK
      2  1239					      SUBROUTINE
      3  1239				   SwapPlayers
    671  1239
    672  1239							; assume no new high score:
    673  1239		       a0 ff		      ldy	#-1
    674  123b		       84 d5		      sty	highScoreSK
    675  123d
    676  123d							; update highscore after last live:
    677  123d							;lda ManCount
    678  123d							;and #$0f			      ; player has lives left?
    679  123d							;bne .playerAlive		      ; YES, so we don't check high score
    680  123d
    681  123d							; check for a new high score:
    682  123d							;	  ldy #-1
    683  123d		       18		      clc		; score has to be at least 1 bigger!
    684  123e				   .loopCheckHighScore
    685  123e		       c8		      iny
    686  123f		       b9 8e f3 	      lda	ScoreCurrent,y
    687  1242		       f9 98 f3 	      sbc	HighScore,y
    688  1245		       98		      tya
    689  1246		       49 02		      eor	#2
    690  1248		       d0 f4		      bne	.loopCheckHighScore
    691  124a		       90 0d		      bcc	.noHighScore
    692  124c
    693  124c							; new high score, update:
    694  124c		       a2 04		      ldx	#5-1
    695  124e				   .loopSetHighScore
    696  124e		       bd 8e f3 	      lda	ScoreCurrent,x
    697  1251		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
    698  1254		       95 d5		      sta	highScoreSK,x
    699  1256		       ca		      dex
    700  1257		       10 f5		      bpl	.loopSetHighScore
    701  1259				   .noHighScore
    702  1259
    703  1259				   .playerAlive
    704  1259							;lda ManCount
    705  1259							;and #$f0			      ; other player has lives left?
    706  1259							;beq .otherPlayerDead		      ; NO, so we don't swap scores
    707  1259
    708  1259							; save the current player variables to the player's backup:
    709  1259		       a0 02		      ldy	#3-1
    710  125b				   .swapScore
    711  125b		       be 93 f3 	      ldx	PlayerScores,y
    712  125e		       b9 8e f3 	      lda	ScoreCurrent,y
    713  1261		       99 93 f7 	      sta	PlayerScores+RAM_WRITE,y
    714  1264		       8a		      txa
    715  1265		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
    716  1268		       88		      dey
    717  1269		       10 f0		      bpl	.swapScore
    718  126b
    719  126b							; swap levelx and level:
    720  126b		       a2 01		      ldx	#1
    721  126d				   .loopLevelXLevel
    722  126d		       bc 96 f3 	      ldy	PlayerLevelX,x
    723  1270		       b5 b2		      lda	levelX,x
    724  1272		       9d 96 f7 	      sta	PlayerLevelX+RAM_WRITE,x
    725  1275		       94 b2		      sty	levelX,x
    726  1277		       ca		      dex
    727  1278		       10 f3		      bpl	.loopLevelXLevel
    728  127a
    729  127a				   .otherPlayerDead
    730  127a		       60		      rts
    731  127b
    732  127b							;---------------------------------------------------------------------------
    733  127b
    734  127b				   HighScoreColTbl
    735  127b		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    736  127d		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    737  127f
      0  127f					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  127f		       00 02	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  127f					      SUBROUTINE
      3  127f				   GeneralScoringSetups
    739  127f
    740  127f		       a0 04		      ldy	#SM_OFS_SCORE
    741  1281				   .loopScore2
    742  1281							;lda scoringFlags
    743  1281							;and #DISPLAY_FLAGS
    744  1281							;cmp #DISPLAY_HIGH
    745  1281							;ldx Platform
    746  1281							;lda HighScoreColTbl,x
    747  1281							;tax
    748  1281							;lda HighScore-SM_OFS_SCORE,y
    749  1281							;bcs .showHighScore
    750  1281		       a2 9a		      ldx	#SCORE_COL
    751  1283		       b9 8a f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    752  1286				   .showHighScore
    753  1286		       8e 17 f6 	      stx	SMCOLOR+1+RAM_WRITE
    754  1289		       20 aa f2 	      jsr	SetupBCDPtr
    755  128c		       c0 07		      cpy	#SM_OFS_SCORE+3
    756  128e		       90 f1		      bcc	.loopScore2
    757  1290
    758  1290							; display number of lives in leftmost digit of middle score XX nX XX
    759  1290
    760  1290							;lda ManCount
    761  1290							;and #$0f
    762  1290							;tay
    763  1290							;lda DigitVectorLOr,y
    764  1290							;sta SMMEN+1+RAM_WRITE
    765  1290
    766  1290							; modify player number pointer (Xp XX XX)
    767  1290
    768  1290							;ldy whichPlayer
    769  1290							;lda DigitVectorLOr+1,y
    770  1290							;sta SMPLAYER+1+RAM_WRITE
    771  1290
    772  1290							; fall through
    773  1290
    774  1290							;    ;---------------------------------------------------------------------------
    775  1290
    776  1290							; modify levelx character pointer (XX XX cX)
    777  1290
    778  1290							;ldx #<charPlace-1
    779  1290							;lda levelDisplay
    780  1290							;cmp #$80
    781  1290							;and #$1f
    782  1290							;tay
    783  1290							;bcs .intermission
    784  1290							;ldx CharVectorLO,y
    785  1290							;ldy level
    786  1290							;.intermission
    787  1290							;stx SMLEVELX+1+RAM_WRITE
    788  1290
    789  1290							; modify level number pointer (XX XX Xl)
    790  1290
    791  1290							;lda DigitVectorLOr+1,y
    792  1290							;sta SMLEVEL+1+RAM_WRITE
    793  1290
    794  1290							;---------------------------------------------------------------------------
    795  1290
    796  1290		       4c a1 f2 	      jmp	SetupTimePtr	; modify time pointers
    797  1293
    798  1293							;------------------------------------------------------------------------------
    799  1293							;    DEFINE_SUBROUTINE SetupGameOverPtr
    800  1293
    801  1293							;		  ldy #8-1
    802  1293							;.loopGameOver:
    803  1293							;		  ldx SMGameOverOfs,y
    804  1293							;		  lda SMGameOverPtr,y
    805  1293							;		  sta SM_BASE+1+RAM_WRITE,x
    806  1293							;		  dey
    807  1293							;		  bpl .loopGameOver
    808  1293
    809  1293							;		  rts
    810  1293
    811  1293							;SMGameOverOfs:
    812  1293							;		  .byte <SM_TARGET3-SM_BASE, <SM_TARGET2-SM_BASE
    813  1293							;		  .byte <SM_TARGET1-SM_BASE, <SM_TARGET0-SM_BASE
    814  1293							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    815  1293							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    816  1293							;SMGameOverPtr:
    817  1293							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    818  1293							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    819  1293
    820  1293							;------------------------------------------------------------------------------
    821  1293
      0  1293					      DEFINE_SUBROUTINE	DrawBCD_targetsRequired
      1  1293		       00 02	   BANK_DrawBCD_targetsRequired =	_CURRENT_BANK
      2  1293					      SUBROUTINE
      3  1293				   DrawBCD_targetsRequired
    823  1293							; Show current TARGET counter in the top left
    824  1293
    825  1293		       a0 00		      ldy	#SM_OFS_TARGETS
    826  1295		       a5 b5		      lda	BCD_targetsRequired
    827  1297		       20 aa f2 	      jsr	SetupBCDPtr
    828  129a
    829  129a		       a9 b0		      lda	#ID_TARGET<<4	; if no extra targets, display the normal icon
    830  129c							;bit scoringFlags		      ;
    831  129c		       4c aa f2 	      jmp	SetupBCDPtr
    832  129f							;lda #ID_EXTRA<<4		      ; otherwise, display the extra icon
    833  129f							;bvc SetupBCDPtr
    834  129f							;ora #1			      ; display 1xx targets
    835  129f							;bne SetupBCDPtr		      ; unconditional
    836  129f
    837  129f							;------------------------------------------------------------------------------
      0  129f					      DEFINE_SUBROUTINE	DrawTime
      1  129f		       00 02	   BANK_DrawTime =	_CURRENT_BANK
      2  129f					      SUBROUTINE
      3  129f				   DrawTime
    839  129f
    840  129f							; mid-digit-change, but we may be required to flash/display
    841  129f		       a0 02		      ldy	#SM_OFS_TIME
    842  12a1							;------------------------------------------------------------------------------
      0  12a1					      DEFINE_SUBROUTINE	SetupTimePtr
      1  12a1		       00 02	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  12a1					      SUBROUTINE
      3  12a1				   SetupTimePtr
    844  12a1
    845  12a1		       a5 b6		      lda	BCD_moveCounter
    846  12a3		       20 aa f2 	      jsr	SetupBCDPtr
    847  12a6		       a5 b7		      lda	BCD_moveCounter+1
    848  12a8		       09 d0		      ora	#ID_CLOCK<<4
    849  12aa
    850  12aa							; fall through
    851  12aa
    852  12aa							;------------------------------------------------------------------------------
      0  12aa					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  12aa		       00 02	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  12aa					      SUBROUTINE
      3  12aa				   SetupBCDPtr
    854  12aa
    855  12aa							; a = BCD value
    856  12aa							; y = SM table offset
    857  12aa
    858  12aa		       48		      pha
    859  12ab		       29 0f		      and	#$0f
    860  12ad		       aa		      tax
    861  12ae		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    862  12b1		       be 19 f0 	      ldx	SMTblLSB,y
    863  12b4		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    864  12b7		       68		      pla
    865  12b8		       4a		      lsr
    866  12b9		       4a		      lsr
    867  12ba		       4a		      lsr
    868  12bb		       4a		      lsr
    869  12bc		       aa		      tax
    870  12bd		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    871  12c0		       be 20 f0 	      ldx	SMTblMSB,y
    872  12c3		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    873  12c6
    874  12c6		       c8		      iny
    875  12c7
    876  12c7		       a5 bf		      lda	ROM_Bank
    877  12c9				   RTS
    878  12c9		       60		      rts
    879  12ca
      0  12ca					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
 PAGE BREAK INSERTED FOR  LeftDigits
 REQUESTED SIZE =  $5b
 WASTED SPACE =  $36
 PAGEBREAK LOCATION =  $f300
     10  1300					      LIST	ON
    881  1300
    882  1300					      IF	<. = 0
    883  1300		       00		      .byte.b	0	; required!
    884  1301					      ENDIF
    885  1301
    886  1301				   BLANKR
    887  1301		       00 00 00 00*	      .ds	DIGIT_H, 0
    888  1308
    889  1308				   DequalsR
    890  1308		       00		      .byte.b	%00000000
    891  1309		       00		      .byte.b	%00000000
    892  130a		       f0		      .byte.b	%11110000
    893  130b		       00		      .byte.b	%00000000
    894  130c		       f0		      .byte.b	%11110000
    895  130d		       00		      .byte.b	%00000000
    896  130e		       f0		      .byte.b	%11110000
    897  130f				   DplusR
    898  130f		       10		      .byte.b	%00010000
    899  1310		       28		      .byte.b	%00101000
    900  1311		       6c		      .byte.b	%01101100
    901  1312		       c6		      .byte.b	%11000110
    902  1313		       6c		      .byte.b	%01101100
    903  1314		       28		      .byte.b	%00101000
    904  1315		       10		      .byte.b	%00010000
    905  1316
    906  1316				   ClockR
    907  1316		       00		      .byte.b	%00000000
    908  1317		       48		      .byte.b	%01001000
    909  1318		       fc		      .byte.b	%11111100
    910  1319		       48		      .byte.b	%01001000
    911  131a		       48		      .byte.b	%01001000
    912  131b		       fc		      .byte.b	%11111100
    913  131c		       48		      .byte.b	%01001000
    914  131d				   NineR
    915  131d		       0f		      .byte.b	%00001111
    916  131e		       01		      .byte.b	%00000001
    917  131f		       01		      .byte.b	%00000001
    918  1320		       7f		      .byte.b	%01111111
    919  1321		       41		      .byte.b	%01000001
    920  1322		       41		      .byte.b	%01000001
    921  1323		       7f		      .byte.b	%01111111
    922  1324				   SixR
    923  1324		       7f		      .byte.b	%01111111
    924  1325		       41		      .byte.b	%01000001
    925  1326		       41		      .byte.b	%01000001
    926  1327		       7f		      .byte.b	%01111111
    927  1328		       40		      .byte.b	%01000000
    928  1329		       40		      .byte.b	%01000000
    929  132a		       78		      .byte.b	%01111000
    930  132b				   EightR
    931  132b							;  .byte %00111110
    932  132b							;  .byte %01000011
    933  132b							;  .byte %01000011
    934  132b							;  .byte %00111110
    935  132b							;  .byte %00100011
    936  132b							;  .byte %00100011
    937  132b							;  .byte %00011110
    938  132b
    939  132b
    940  132b		       7f		      .byte.b	%01111111
    941  132c		       41		      .byte.b	%01000001
    942  132d		       41		      .byte.b	%01000001
    943  132e		       7f		      .byte.b	%01111111
    944  132f		       41		      .byte.b	%01000001
    945  1330		       41		      .byte.b	%01000001
    946  1331		       7f		      .byte.b	%01111111
    947  1332
    948  1332				   ZeroR
    949  1332		       7f		      .byte.b	%01111111
    950  1333		       41		      .byte.b	%01000001
    951  1334		       41		      .byte.b	%01000001
    952  1335		       41		      .byte.b	%01000001
    953  1336		       41		      .byte.b	%01000001
    954  1337		       41		      .byte.b	%01000001
    955  1338		       7f		      .byte.b	%01111111
    956  1339
    957  1339							;	  .byte %00111110
    958  1339							;	  .byte %01000011
    959  1339							;	  .byte %01000011
    960  1339							;	  .byte %01000011
    961  1339							;	  .byte %01000011
    962  1339							;	  .byte %00100011
    963  1339							;	  .byte %00011110
    964  1339				   ThreeR
    965  1339		       7f		      .byte.b	%01111111
    966  133a		       01		      .byte.b	%00000001
    967  133b		       01		      .byte.b	%00000001
    968  133c		       0f		      .byte.b	%00001111
    969  133d		       01		      .byte.b	%00000001
    970  133e		       01		      .byte.b	%00000001
    971  133f		       7f		      .byte.b	%01111111
    972  1340				   OneR
    973  1340		       08		      .byte.b	%00001000
    974  1341		       08		      .byte.b	%00001000
    975  1342		       08		      .byte.b	%00001000
    976  1343		       08		      .byte.b	%00001000
    977  1344		       08		      .byte.b	%00001000
    978  1345		       08		      .byte.b	%00001000
    979  1346		       08		      .byte.b	%00001000
    980  1347
    981  1347				   SevenR
    982  1347		       08		      .byte.b	%00001000
    983  1348		       08		      .byte.b	%00001000
    984  1349		       08		      .byte.b	%00001000
    985  134a		       0f		      .byte.b	%00001111
    986  134b		       01		      .byte.b	%00000001
    987  134c		       01		      .byte.b	%00000001
    988  134d		       7f		      .byte.b	%01111111
    989  134e
    990  134e				   TwoR
    991  134e		       7f		      .byte.b	%01111111
    992  134f		       40		      .byte.b	%01000000
    993  1350		       40		      .byte.b	%01000000
    994  1351		       7f		      .byte.b	%01111111
    995  1352		       01		      .byte.b	%00000001
    996  1353		       01		      .byte.b	%00000001
    997  1354		       7f		      .byte.b	%01111111
    998  1355				   FiveR
    999  1355		       7f		      .byte.b	%01111111
   1000  1356		       01		      .byte.b	%00000001
   1001  1357		       01		      .byte.b	%00000001
   1002  1358		       7f		      .byte.b	%01111111
   1003  1359		       40		      .byte.b	%01000000
   1004  135a		       40		      .byte.b	%01000000
   1005  135b		       78		      .byte.b	%01111000
   1006  135c				   FourR
   1007  135c		       08		      .byte.b	%00001000
   1008  135d		       08		      .byte.b	%00001000
   1009  135e		       08		      .byte.b	%00001000
   1010  135f		       7f		      .byte.b	%01111111
   1011  1360		       48		      .byte.b	%01001000
   1012  1361		       48		      .byte.b	%01001000
   1013  1362		       48		      .byte.b	%01001000
   1014  1363
   1015  1363							;CharAL:
   1016  1363							;    .byte %11100110
   1017  1363							;    .byte %11100110
   1018  1363							;    .byte %11111110
   1019  1363							;    .byte %11100110
   1020  1363							;    .byte %11100110
   1021  1363							;    .byte %01111100
   1022  1363							;    .byte %00111000
   1023  1363							;CharEL:
   1024  1363							;    .byte %11111110
   1025  1363							;    .byte %11111110
   1026  1363							;    .byte %11100000
   1027  1363							;    .byte %11100000
   1028  1363							;    .byte %11111100
   1029  1363							;    .byte %11100000
   1030  1363							;    .byte %11111110
   1031  1363							;CharRL:
   1032  1363							;    .byte %11100110
   1033  1363							;    .byte %11100110
   1034  1363							;    .byte %11111100
   1035  1363							;    .byte %11111100
   1036  1363							;    .byte %11100110
   1037  1363							;    .byte %11100110
   1038  1363							;    .byte %11111100
   1039  1363							;CharVL:
   1040  1363							;    .byte %00111000
   1041  1363							;    .byte %01111100
   1042  1363							;    .byte %11100110
   1043  1363							;    .byte %11100110
   1044  1363							;    .byte %11100110
   1045  1363							;    .byte %11100110
   1046  1363							;    .byte %11100110
   1047  1363
      0  1363					      CHECKPAGE	BLANKR
      8  1363					      LIST	ON
   1049  1363
   1050  1363							;---------------------------------------------------------------------------
   1051  1363
      0  1363					      DEFINE_SUBROUTINE	GameInitialise
      1  1363		       00 02	   BANK_GameInitialise =	_CURRENT_BANK
      2  1363					      SUBROUTINE
      3  1363				   GameInitialise
   1053  1363
   1054  1363							; copy loaded SK high score into scoring RAM:
   1055  1363		       a2 02		      ldx	#3-1
   1056  1365				   .loopCopyHighScore
   1057  1365		       b5 d5		      lda	highScoreSK,x
   1058  1367		       c9 ff		      cmp	#$ff
   1059  1369		       f0 06		      beq	.noSaveKey
   1060  136b		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
   1061  136e		       ca		      dex
   1062  136f		       10 f4		      bpl	.loopCopyHighScore
   1063  1371				   .noSaveKey
   1064  1371
   1065  1371							; clear both players scores
   1066  1371		       a0 05		      ldy	#2*3-1
   1067  1373		       a9 00		      lda	#0
   1068  1375				   .loopClearScore
   1069  1375		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
   1070  1378		       88		      dey
   1071  1379		       10 fa		      bpl	.loopClearScore
   1072  137b
   1073  137b							; copy levelX and level for other player and SaveKey:
   1074  137b		       a5 b2		      lda	levelX
   1075  137d		       8d 96 f7 	      sta	PlayerLevelX+RAM_WRITE
   1076  1380		       a5 d8		      lda	startingLevel
   1077  1382		       8d 91 f7 	      sta	StartLevelX+RAM_WRITE
   1078  1385		       a5 b3		      lda	level
   1079  1387		       8d 97 f7 	      sta	PlayerLevel+RAM_WRITE
   1080  138a		       8d 92 f7 	      sta	StartLevel+RAM_WRITE
   1081  138d		       60		      rts
   1082  138e
   1083  138e							;---------------------------------------------------------------------------
   1084  138e
   1085  138e		       00 00 00    ScoreCurrent ds	3, 0
   1086  1391							; start levelx and level have to be after ScoreCurrent!
   1087  1391		       00	   StartLevelX .byte.b	0
   1088  1392		       00	   StartLevel .byte.b	0
   1089  1393		       00 00 00    PlayerScores ds	3, 0
   1090  1396							; levelx and level have to be consecutive variables!
   1091  1396		       00	   PlayerLevelX .byte.b	0
   1092  1397		       00	   PlayerLevel .byte.b	0
   1093  1398		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1094  139d
   1095  139d
   1096  139d
   1097  139d							;------------------------------------------------------------------------------
   1098  139d
      0  139d					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  139d
      2  139d
      3  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $39d , FREE= $63
      4  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  139d				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  139d				  -	      ERR
      8  139d					      endif
   1100  139d
   1101  139d							;------------------------------------------------------------------------------
   1102  139d
   1103  139d							; LEVEL DATA banks can go anywhere - *EXCEPT* for the same bank as the level
   1104  139d							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_LEVEL_SIZE
   1105  139d							; which is used as a buffer size inside UnpackLevel.  It's not important if
   1106  139d							; this is defined before or after, as once the levels have processed it will be
   1107  139d							; correct. Note, that levels should all be defined BEFORE *OR* AFTER the
   1108  139d							; UnpackLevel code -- but that they should not be both, nor in the same bank.
   1109  139d							; TODO: verify above is still valid
   1110  139d
   1111  139d
      0  139d					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $39d , FREE= $463
      2  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  139d				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  139d				  -	      ERR
      6  139d					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 3
      0  139d					      include	"BANK_GENERIC.asm"
      1  139d							;    Sokoboo - a Sokoban implementation
      2  139d							;    using a generic tile-based display engine for the Atari 2600
      3  139d							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  139d							;
      5  139d							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  139d							;
      7  139d							;    Code related to the generic tile-based display engine was developed by
      8  139d							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  139d							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  139d							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  139d							;
     12  139d							;    Code related to music and sound effects uses the TIATracker music player
     13  139d							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  139d							;    directory for Apache licensing details.
     15  139d							;
     16  139d							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  139d							;    See the copyright notices in the License directory for a list of level
     18  139d							;    contributors.
     19  139d							;
     20  139d							;    Except where otherwise indicated, this software is released under the
     21  139d							;    following licensing arrangement...
     22  139d							;
     23  139d							;    This program is free software: you can redistribute it and/or modify
     24  139d							;    it under the terms of the GNU General Public License as published by
     25  139d							;    the Free Software Foundation, either version 3 of the License, or
     26  139d							;    (at your option) any later version.
     27  139d							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  139d
     29  139d							;    This program is distributed in the hope that it will be useful,
     30  139d							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  139d							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  139d							;    GNU General Public License for more details.
     33  139d
     34  139d							;------------------------------------------------------------------------------
     35  139d							;##############################################################################
     36  139d							;------------------------------------------------------------------------------
     37  139d
      0  139d					      NEWBANK	GENERIC_BANK_1
      1  1e22 ????				      SEG	GENERIC_BANK_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	GENERIC_BANK_1
     39  1800
     40  1800
     41  1800
      0  1800					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  1800					      ALIGN	$400
      2  1800				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  1800				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
------- FILE DecodeLevel.asm LEVEL 3 PASS 3
      0  1800					      include	"DecodeLevel.asm"
      1  1800							;    Sokoboo - a Sokoban implementation
      2  1800							;    using a generic tile-based display engine for the Atari 2600
      3  1800							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1800							;
      5  1800							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1800							;
      7  1800							;    Code related to the generic tile-based display engine was developed by
      8  1800							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1800							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1800							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1800							;
     12  1800							;    Code related to music and sound effects uses the TIATracker music player
     13  1800							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1800							;    directory for Apache licensing details.
     15  1800							;
     16  1800							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1800							;    See the copyright notices in the License directory for a list of level
     18  1800							;    contributors.
     19  1800							;
     20  1800							;    Except where otherwise indicated, this software is released under the
     21  1800							;    following licensing arrangement...
     22  1800							;
     23  1800							;    This program is free software: you can redistribute it and/or modify
     24  1800							;    it under the terms of the GNU General Public License as published by
     25  1800							;    the Free Software Foundation, either version 3 of the License, or
     26  1800							;    (at your option) any later version.
     27  1800							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1800
     29  1800							;    This program is distributed in the hope that it will be useful,
     30  1800							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1800							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1800							;    GNU General Public License for more details.
     33  1800
     34  1800							; The ordering here corresponds to the ordering when playing...
     35  1800
     36  1800				   LevelInfoLO
     37  1800		       ff		      .byte.b	<(LEVEL__001_L-1)
     38  1801		       11		      .byte.b	<(LEVEL__001_R-1)
     39  1802		       1d		      .byte.b	<(LEVEL__002_L-1)
     40  1803		       36		      .byte.b	<(LEVEL__002_R-1)
     41  1804		       5e		      .byte.b	<(LEVEL__003_L-1)
     42  1805		       8a		      .byte.b	<(LEVEL__003_R-1)
     43  1806		       b4		      .byte.b	<(LEVEL__004_L-1)
     44  1807		       d7		      .byte.b	<(LEVEL__004_R-1)
     45  1808		       f3		      .byte.b	<(LEVEL__005_L-1)
     46  1809		       25		      .byte.b	<(LEVEL__005_R-1)
     47  180a		       64		      .byte.b	<(LEVEL__006_L-1)
     48  180b		       9f		      .byte.b	<(LEVEL__006_R-1)
     49  180c		       dd		      .byte.b	<(LEVEL__007_L-1)
     50  180d		       0a		      .byte.b	<(LEVEL__007_R-1)
     51  180e		       3d		      .byte.b	<(LEVEL__008_L-1)
     52  180f		       73		      .byte.b	<(LEVEL__008_R-1)
     53  1810		       a4		      .byte.b	<(LEVEL__009_L-1)
     54  1811		       d6		      .byte.b	<(LEVEL__009_R-1)
     55  1812		       06		      .byte.b	<(LEVEL__010_L-1)
     56  1813		       40		      .byte.b	<(LEVEL__010_R-1)
     57  1814		       73		      .byte.b	<(LEVEL__011_L-1)
     58  1815		       a6		      .byte.b	<(LEVEL__011_R-1)
     59  1816		       e0		      .byte.b	<(LEVEL__012_L-1)
     60  1817		       10		      .byte.b	<(LEVEL__012_R-1)
     61  1818		       4c		      .byte.b	<(LEVEL__013_L-1)
     62  1819		       8b		      .byte.b	<(LEVEL__013_R-1)
     63  181a		       be		      .byte.b	<(LEVEL__014_L-1)
     64  181b		       01		      .byte.b	<(LEVEL__014_R-1)
     65  181c		       44		      .byte.b	<(LEVEL__015_L-1)
     66  181d		       79		      .byte.b	<(LEVEL__015_R-1)
     67  181e		       be		      .byte.b	<(LEVEL__016_L-1)
     68  181f		       f5		      .byte.b	<(LEVEL__016_R-1)
     69  1820		       28		      .byte.b	<(LEVEL__017_L-1)
     70  1821		       72		      .byte.b	<(LEVEL__017_R-1)
     71  1822		       b5		      .byte.b	<(LEVEL__018_L-1)
     72  1823		       e9		      .byte.b	<(LEVEL__018_R-1)
     73  1824		       25		      .byte.b	<(LEVEL__019_L-1)
     74  1825		       60		      .byte.b	<(LEVEL__019_R-1)
     75  1826		       ff		      .byte.b	<(LEVEL__020_L-1)
     76  1827		       3e		      .byte.b	<(LEVEL__020_R-1)
     77  1828		       7e		      .byte.b	<(LEVEL__021_L-1)
     78  1829		       d4		      .byte.b	<(LEVEL__021_R-1)
     79  182a		       08		      .byte.b	<(LEVEL__022_L-1)
     80  182b		       4e		      .byte.b	<(LEVEL__022_R-1)
     81  182c		       8a		      .byte.b	<(LEVEL__023_L-1)
     82  182d		       cb		      .byte.b	<(LEVEL__023_R-1)
     83  182e		       0d		      .byte.b	<(LEVEL__024_L-1)
     84  182f		       5d		      .byte.b	<(LEVEL__024_R-1)
     85  1830		       a5		      .byte.b	<(LEVEL__025_L-1)
     86  1831		       e8		      .byte.b	<(LEVEL__025_R-1)
     87  1832		       27		      .byte.b	<(LEVEL__026_L-1)
     88  1833		       60		      .byte.b	<(LEVEL__026_R-1)
     89  1834		       a1		      .byte.b	<(LEVEL__027_L-1)
     90  1835		       df		      .byte.b	<(LEVEL__027_R-1)
     91  1836		       1d		      .byte.b	<(LEVEL__028_L-1)
     92  1837		       69		      .byte.b	<(LEVEL__028_R-1)
     93  1838		       b7		      .byte.b	<(LEVEL__029_L-1)
     94  1839		       fc		      .byte.b	<(LEVEL__029_R-1)
     95  183a		       40		      .byte.b	<(LEVEL__030_L-1)
     96  183b		       90		      .byte.b	<(LEVEL__030_R-1)
     97  183c		       e3		      .byte.b	<(LEVEL__031_L-1)
     98  183d		       29		      .byte.b	<(LEVEL__031_R-1)
     99  183e		       68		      .byte.b	<(LEVEL__032_L-1)
    100  183f		       a0		      .byte.b	<(LEVEL__032_R-1)
    101  1840		       e4		      .byte.b	<(LEVEL__033_L-1)
    102  1841		       2e		      .byte.b	<(LEVEL__033_R-1)
    103  1842		       6e		      .byte.b	<(LEVEL__034_L-1)
    104  1843		       ff		      .byte.b	<(LEVEL__034_R-1)
    105  1844		       48		      .byte.b	<(LEVEL__035_L-1)
    106  1845		       8d		      .byte.b	<(LEVEL__035_R-1)
    107  1846		       cd		      .byte.b	<(LEVEL__036_L-1)
    108  1847		       03		      .byte.b	<(LEVEL__036_R-1)
    109  1848		       49		      .byte.b	<(LEVEL__037_L-1)
    110  1849		       86		      .byte.b	<(LEVEL__037_R-1)
    111  184a		       cf		      .byte.b	<(LEVEL__038_L-1)
    112  184b		       17		      .byte.b	<(LEVEL__038_R-1)
    113  184c		       66		      .byte.b	<(LEVEL__039_L-1)
    114  184d		       b5		      .byte.b	<(LEVEL__039_R-1)
    115  184e		       0f		      .byte.b	<(LEVEL__040_L-1)
    116  184f		       56		      .byte.b	<(LEVEL__040_R-1)
    117  1850
    118  1850		       9d		      .byte.b	<(LEVEL__041_L-1)
    119  1851		       e7		      .byte.b	<(LEVEL__041_R-1)
    120  1852		       2e		      .byte.b	<(LEVEL__042_L-1)
    121  1853		       7c		      .byte.b	<(LEVEL__042_R-1)
    122  1854		       d4		      .byte.b	<(LEVEL__043_L-1)
    123  1855		       21		      .byte.b	<(LEVEL__043_R-1)
    124  1856		       6d		      .byte.b	<(LEVEL__044_L-1)
    125  1857		       a5		      .byte.b	<(LEVEL__044_R-1)
    126  1858		       f5		      .byte.b	<(LEVEL__045_L-1)
    127  1859		       43		      .byte.b	<(LEVEL__045_R-1)
    128  185a		       8d		      .byte.b	<(LEVEL__046_L-1)
    129  185b		       da		      .byte.b	<(LEVEL__046_R-1)
    130  185c		       1f		      .byte.b	<(LEVEL__047_L-1)
    131  185d		       75		      .byte.b	<(LEVEL__047_R-1)
    132  185e		       ff		      .byte.b	<(LEVEL__048_L-1)
    133  185f		       4b		      .byte.b	<(LEVEL__048_R-1)
    134  1860		       96		      .byte.b	<(LEVEL__049_L-1)
    135  1861		       e8		      .byte.b	<(LEVEL__049_R-1)
    136  1862
    137  1862		       2b		      .byte.b	<(LEVEL__050_L-1)
    138  1863		       78		      .byte.b	<(LEVEL__050_R-1)
    139  1864		       b1		      .byte.b	<(LEVEL__051_L-1)
    140  1865		       04		      .byte.b	<(LEVEL__051_R-1)
    141  1866		       55		      .byte.b	<(LEVEL__052_L-1)
    142  1867		       8f		      .byte.b	<(LEVEL__052_R-1)
    143  1868		       d7		      .byte.b	<(LEVEL__053_L-1)
    144  1869		       2c		      .byte.b	<(LEVEL__053_R-1)
    145  186a		       79		      .byte.b	<(LEVEL__054_L-1)
    146  186b		       c5		      .byte.b	<(LEVEL__054_R-1)
    147  186c		       0e		      .byte.b	<(LEVEL__055_L-1)
    148  186d		       68		      .byte.b	<(LEVEL__055_R-1)
    149  186e		       bd		      .byte.b	<(LEVEL__056_L-1)
    150  186f		       17		      .byte.b	<(LEVEL__056_R-1)
    151  1870		       72		      .byte.b	<(LEVEL__057_L-1)
    152  1871		       c8		      .byte.b	<(LEVEL__057_R-1)
    153  1872		       11		      .byte.b	<(LEVEL__058_L-1)
    154  1873		       56		      .byte.b	<(LEVEL__058_R-1)
    155  1874		       a6		      .byte.b	<(LEVEL__059_L-1)
    156  1875		       f8		      .byte.b	<(LEVEL__059_R-1)
    157  1876
    158  1876		       ff		      .byte.b	<(LEVEL__060_R-1)
    159  1877		       9b		      .byte.b	<(LEVEL__061_R-1)
    160  1878		       47		      .byte.b	<(LEVEL__061_L-1)
    161  1879		       e4		      .byte.b	<(LEVEL__062_L-1)
    162  187a		       3b		      .byte.b	<(LEVEL__062_R-1)
    163  187b		       87		      .byte.b	<(LEVEL__063_L-1)
    164  187c		       d7		      .byte.b	<(LEVEL__063_R-1)
    165  187d		       84		      .byte.b	<(LEVEL__064_R-1)
    166  187e		       29		      .byte.b	<(LEVEL__064_L-1)
    167  187f		       28		      .byte.b	<(LEVEL__065_R-1)
    168  1880		       d0		      .byte.b	<(LEVEL__065_L-1)
    169  1881		       ca		      .byte.b	<(LEVEL__066_R-1)
    170  1882		       70		      .byte.b	<(LEVEL__066_L-1)
    171  1883		       6d		      .byte.b	<(LEVEL__067_R-1)
    172  1884		       20		      .byte.b	<(LEVEL__067_L-1)
    173  1885		       26		      .byte.b	<(LEVEL__068_R-1)
    174  1886		       d2		      .byte.b	<(LEVEL__068_L-1)
    175  1887		       ca		      .byte.b	<(LEVEL__069_R-1)
    176  1888		       7c		      .byte.b	<(LEVEL__069_L-1)
    177  1889
    178  1889		       e8		      .byte.b	<(LEVEL__103_Arielle-1)
    179  188a		       a1		      .byte.b	<(LEVEL__103_Ajalae-1)
    180  188b		       56		      .byte.b	<(LEVEL__103_Adin-1)
    181  188c		       e8		      .byte.b	<(LEVEL__102_Raven-1)
    182  188d		       a4		      .byte.b	<(LEVEL__102_Oralia-1)
    183  188e		       ff		      .byte.b	<(LEVEL__102_Natalie-1)
    184  188f		       45		      .byte.b	<(LEVEL__102_Mirabel-1)
    185  1890		       38		      .byte.b	<(LEVEL__1XJH_Tara_Gelson-1)
    186  1891		       72		      .byte.b	<(LEVEL__1R7X_Alison-1)
    187  1892		       9f		      .byte.b	<(LEVEL__1KWD_Cecile_Clayworth-1)
    188  1893		       d3		      .byte.b	<(LEVEL__1EKT_Samantha_Gelson-1)
    189  1894		       0c		      .byte.b	<(LEVEL__0VM5_Andrea_Wadd-1)
    190  1895		       39		      .byte.b	<(LEVEL__0PAL_Jill_Leatherby-1)
    191  1896		       63		      .byte.b	<(LEVEL__0IZ1_Sophia-1)
    192  1897		       8e		      .byte.b	<(LEVEL__0CNH_Alice-1)
    193  1898		       18		      .byte.b	<(LEVEL__122_Maya-1)
    194  1899
    195  1899		       00 99	   MAX_LEVEL  =	* - LevelInfoLO
 $99 LEVELS INSTALLED
    196  1899					      ECHO	MAX_LEVEL, "LEVELS INSTALLED"
    197  1899				   LevelInfoHI
    198  1899
    199  1899		       ef		      .byte.b	>(LEVEL__001_L-1)
    200  189a		       f0		      .byte.b	>(LEVEL__001_R-1)
    201  189b		       f0		      .byte.b	>(LEVEL__002_L-1)
    202  189c		       f0		      .byte.b	>(LEVEL__002_R-1)
    203  189d		       f0		      .byte.b	>(LEVEL__003_L-1)
    204  189e		       f0		      .byte.b	>(LEVEL__003_R-1)
    205  189f		       f0		      .byte.b	>(LEVEL__004_L-1)
    206  18a0		       f0		      .byte.b	>(LEVEL__004_R-1)
    207  18a1		       f0		      .byte.b	>(LEVEL__005_L-1)
    208  18a2		       f1		      .byte.b	>(LEVEL__005_R-1)
    209  18a3		       f1		      .byte.b	>(LEVEL__006_L-1)
    210  18a4		       f1		      .byte.b	>(LEVEL__006_R-1)
    211  18a5		       f1		      .byte.b	>(LEVEL__007_L-1)
    212  18a6		       f2		      .byte.b	>(LEVEL__007_R-1)
    213  18a7		       f2		      .byte.b	>(LEVEL__008_L-1)
    214  18a8		       f2		      .byte.b	>(LEVEL__008_R-1)
    215  18a9		       f2		      .byte.b	>(LEVEL__009_L-1)
    216  18aa		       f2		      .byte.b	>(LEVEL__009_R-1)
    217  18ab		       f3		      .byte.b	>(LEVEL__010_L-1)
    218  18ac		       f3		      .byte.b	>(LEVEL__010_R-1)
    219  18ad		       f3		      .byte.b	>(LEVEL__011_L-1)
    220  18ae		       f3		      .byte.b	>(LEVEL__011_R-1)
    221  18af		       f3		      .byte.b	>(LEVEL__012_L-1)
    222  18b0		       f4		      .byte.b	>(LEVEL__012_R-1)
    223  18b1		       f4		      .byte.b	>(LEVEL__013_L-1)
    224  18b2		       f4		      .byte.b	>(LEVEL__013_R-1)
    225  18b3		       f4		      .byte.b	>(LEVEL__014_L-1)
    226  18b4		       f5		      .byte.b	>(LEVEL__014_R-1)
    227  18b5		       f5		      .byte.b	>(LEVEL__015_L-1)
    228  18b6		       f5		      .byte.b	>(LEVEL__015_R-1)
    229  18b7		       f5		      .byte.b	>(LEVEL__016_L-1)
    230  18b8		       f5		      .byte.b	>(LEVEL__016_R-1)
    231  18b9		       f6		      .byte.b	>(LEVEL__017_L-1)
    232  18ba		       f6		      .byte.b	>(LEVEL__017_R-1)
    233  18bb		       f6		      .byte.b	>(LEVEL__018_L-1)
    234  18bc		       f6		      .byte.b	>(LEVEL__018_R-1)
    235  18bd		       f7		      .byte.b	>(LEVEL__019_L-1)
    236  18be		       f7		      .byte.b	>(LEVEL__019_R-1)
    237  18bf		       ef		      .byte.b	>(LEVEL__020_L-1)
    238  18c0		       f0		      .byte.b	>(LEVEL__020_R-1)
    239  18c1		       f0		      .byte.b	>(LEVEL__021_L-1)
    240  18c2		       f0		      .byte.b	>(LEVEL__021_R-1)
    241  18c3		       f1		      .byte.b	>(LEVEL__022_L-1)
    242  18c4		       f1		      .byte.b	>(LEVEL__022_R-1)
    243  18c5		       f1		      .byte.b	>(LEVEL__023_L-1)
    244  18c6		       f1		      .byte.b	>(LEVEL__023_R-1)
    245  18c7		       f2		      .byte.b	>(LEVEL__024_L-1)
    246  18c8		       f2		      .byte.b	>(LEVEL__024_R-1)
    247  18c9		       f2		      .byte.b	>(LEVEL__025_L-1)
    248  18ca		       f2		      .byte.b	>(LEVEL__025_R-1)
    249  18cb		       f3		      .byte.b	>(LEVEL__026_L-1)
    250  18cc		       f3		      .byte.b	>(LEVEL__026_R-1)
    251  18cd		       f3		      .byte.b	>(LEVEL__027_L-1)
    252  18ce		       f3		      .byte.b	>(LEVEL__027_R-1)
    253  18cf		       f4		      .byte.b	>(LEVEL__028_L-1)
    254  18d0		       f4		      .byte.b	>(LEVEL__028_R-1)
    255  18d1		       f4		      .byte.b	>(LEVEL__029_L-1)
    256  18d2		       f4		      .byte.b	>(LEVEL__029_R-1)
    257  18d3		       f5		      .byte.b	>(LEVEL__030_L-1)
    258  18d4		       f5		      .byte.b	>(LEVEL__030_R-1)
    259  18d5		       f5		      .byte.b	>(LEVEL__031_L-1)
    260  18d6		       f6		      .byte.b	>(LEVEL__031_R-1)
    261  18d7		       f6		      .byte.b	>(LEVEL__032_L-1)
    262  18d8		       f6		      .byte.b	>(LEVEL__032_R-1)
    263  18d9		       f6		      .byte.b	>(LEVEL__033_L-1)
    264  18da		       f7		      .byte.b	>(LEVEL__033_R-1)
    265  18db		       f7		      .byte.b	>(LEVEL__034_L-1)
    266  18dc		       ef		      .byte.b	>(LEVEL__034_R-1)
    267  18dd		       f0		      .byte.b	>(LEVEL__035_L-1)
    268  18de		       f0		      .byte.b	>(LEVEL__035_R-1)
    269  18df		       f0		      .byte.b	>(LEVEL__036_L-1)
    270  18e0		       f1		      .byte.b	>(LEVEL__036_R-1)
    271  18e1		       f1		      .byte.b	>(LEVEL__037_L-1)
    272  18e2		       f1		      .byte.b	>(LEVEL__037_R-1)
    273  18e3		       f1		      .byte.b	>(LEVEL__038_L-1)
    274  18e4		       f2		      .byte.b	>(LEVEL__038_R-1)
    275  18e5		       f2		      .byte.b	>(LEVEL__039_L-1)
    276  18e6		       f2		      .byte.b	>(LEVEL__039_R-1)
    277  18e7		       f3		      .byte.b	>(LEVEL__040_L-1)
    278  18e8		       f3		      .byte.b	>(LEVEL__040_R-1)
    279  18e9
    280  18e9		       f3		      .byte.b	>(LEVEL__041_L-1)
    281  18ea		       f3		      .byte.b	>(LEVEL__041_R-1)
    282  18eb		       f4		      .byte.b	>(LEVEL__042_L-1)
    283  18ec		       f4		      .byte.b	>(LEVEL__042_R-1)
    284  18ed		       f4		      .byte.b	>(LEVEL__043_L-1)
    285  18ee		       f5		      .byte.b	>(LEVEL__043_R-1)
    286  18ef		       f5		      .byte.b	>(LEVEL__044_L-1)
    287  18f0		       f5		      .byte.b	>(LEVEL__044_R-1)
    288  18f1		       f5		      .byte.b	>(LEVEL__045_L-1)
    289  18f2		       f6		      .byte.b	>(LEVEL__045_R-1)
    290  18f3		       f6		      .byte.b	>(LEVEL__046_L-1)
    291  18f4		       f6		      .byte.b	>(LEVEL__046_R-1)
    292  18f5		       f7		      .byte.b	>(LEVEL__047_L-1)
    293  18f6		       f7		      .byte.b	>(LEVEL__047_R-1)
    294  18f7		       ef		      .byte.b	>(LEVEL__048_L-1)
    295  18f8		       f0		      .byte.b	>(LEVEL__048_R-1)
    296  18f9		       f0		      .byte.b	>(LEVEL__049_L-1)
    297  18fa		       f0		      .byte.b	>(LEVEL__049_R-1)
    298  18fb
    299  18fb		       f1		      .byte.b	>(LEVEL__050_L-1)
    300  18fc		       f1		      .byte.b	>(LEVEL__050_R-1)
    301  18fd		       f1		      .byte.b	>(LEVEL__051_L-1)
    302  18fe		       f2		      .byte.b	>(LEVEL__051_R-1)
    303  18ff		       f2		      .byte.b	>(LEVEL__052_L-1)
    304  1900		       f2		      .byte.b	>(LEVEL__052_R-1)
    305  1901		       f2		      .byte.b	>(LEVEL__053_L-1)
    306  1902		       f3		      .byte.b	>(LEVEL__053_R-1)
    307  1903		       f3		      .byte.b	>(LEVEL__054_L-1)
    308  1904		       f3		      .byte.b	>(LEVEL__054_R-1)
    309  1905		       f4		      .byte.b	>(LEVEL__055_L-1)
    310  1906		       f4		      .byte.b	>(LEVEL__055_R-1)
    311  1907		       f4		      .byte.b	>(LEVEL__056_L-1)
    312  1908		       f5		      .byte.b	>(LEVEL__056_R-1)
    313  1909		       f5		      .byte.b	>(LEVEL__057_L-1)
    314  190a		       f5		      .byte.b	>(LEVEL__057_R-1)
    315  190b		       f6		      .byte.b	>(LEVEL__058_L-1)
    316  190c		       f6		      .byte.b	>(LEVEL__058_R-1)
    317  190d		       f6		      .byte.b	>(LEVEL__059_L-1)
    318  190e		       f6		      .byte.b	>(LEVEL__059_R-1)
    319  190f
    320  190f		       ef		      .byte.b	>(LEVEL__060_R-1)
    321  1910		       f0		      .byte.b	>(LEVEL__061_R-1)
    322  1911		       f0		      .byte.b	>(LEVEL__061_L-1)
    323  1912		       f0		      .byte.b	>(LEVEL__062_L-1)
    324  1913		       f1		      .byte.b	>(LEVEL__062_R-1)
    325  1914		       f1		      .byte.b	>(LEVEL__063_L-1)
    326  1915		       f1		      .byte.b	>(LEVEL__063_R-1)
    327  1916		       f2		      .byte.b	>(LEVEL__064_R-1)
    328  1917		       f2		      .byte.b	>(LEVEL__064_L-1)
    329  1918		       f3		      .byte.b	>(LEVEL__065_R-1)
    330  1919		       f2		      .byte.b	>(LEVEL__065_L-1)
    331  191a		       f3		      .byte.b	>(LEVEL__066_R-1)
    332  191b		       f3		      .byte.b	>(LEVEL__066_L-1)
    333  191c		       f4		      .byte.b	>(LEVEL__067_R-1)
    334  191d		       f4		      .byte.b	>(LEVEL__067_L-1)
    335  191e		       f5		      .byte.b	>(LEVEL__068_R-1)
    336  191f		       f4		      .byte.b	>(LEVEL__068_L-1)
    337  1920		       f5		      .byte.b	>(LEVEL__069_R-1)
    338  1921		       f5		      .byte.b	>(LEVEL__069_L-1)
    339  1922
    340  1922		       f1		      .byte.b	>(LEVEL__103_Arielle-1)
    341  1923		       f1		      .byte.b	>(LEVEL__103_Ajalae-1)
    342  1924		       f1		      .byte.b	>(LEVEL__103_Adin-1)
    343  1925		       f0		      .byte.b	>(LEVEL__102_Raven-1)
    344  1926		       f0		      .byte.b	>(LEVEL__102_Oralia-1)
    345  1927		       ef		      .byte.b	>(LEVEL__102_Natalie-1)
    346  1928		       f0		      .byte.b	>(LEVEL__102_Mirabel-1)
    347  1929		       f2		      .byte.b	>(LEVEL__1XJH_Tara_Gelson-1)
    348  192a		       f2		      .byte.b	>(LEVEL__1R7X_Alison-1)
    349  192b		       f2		      .byte.b	>(LEVEL__1KWD_Cecile_Clayworth-1)
    350  192c		       f2		      .byte.b	>(LEVEL__1EKT_Samantha_Gelson-1)
    351  192d		       f3		      .byte.b	>(LEVEL__0VM5_Andrea_Wadd-1)
    352  192e		       f3		      .byte.b	>(LEVEL__0PAL_Jill_Leatherby-1)
    353  192f		       f3		      .byte.b	>(LEVEL__0IZ1_Sophia-1)
    354  1930		       f3		      .byte.b	>(LEVEL__0CNH_Alice-1)
    355  1931		       f6		      .byte.b	>(LEVEL__122_Maya-1)
    356  1932
    357  1932				  -	      IF	(* - LevelInfoHI != MAX_LEVEL)
    358  1932				  -	      ECHO	"ERROR: Incorrect LevelInfoHI table!"
    359  1932				  -	      ERR
    360  1932					      ENDIF
    361  1932
    362  1932				   LevelInfoBANK
    363  1932
    364  1932		       04		      .byte.b	BANK_LEVEL__001_L
    365  1933		       04		      .byte.b	BANK_LEVEL__001_R
    366  1934		       04		      .byte.b	BANK_LEVEL__002_L
    367  1935		       04		      .byte.b	BANK_LEVEL__002_R
    368  1936		       04		      .byte.b	BANK_LEVEL__003_L
    369  1937		       04		      .byte.b	BANK_LEVEL__003_R
    370  1938		       04		      .byte.b	BANK_LEVEL__004_L
    371  1939		       04		      .byte.b	BANK_LEVEL__004_R
    372  193a		       04		      .byte.b	BANK_LEVEL__005_L
    373  193b		       04		      .byte.b	BANK_LEVEL__005_R
    374  193c		       04		      .byte.b	BANK_LEVEL__006_L
    375  193d		       04		      .byte.b	BANK_LEVEL__006_R
    376  193e		       04		      .byte.b	BANK_LEVEL__007_L
    377  193f		       04		      .byte.b	BANK_LEVEL__007_R
    378  1940		       04		      .byte.b	BANK_LEVEL__008_L
    379  1941		       04		      .byte.b	BANK_LEVEL__008_R
    380  1942		       04		      .byte.b	BANK_LEVEL__009_L
    381  1943		       04		      .byte.b	BANK_LEVEL__009_R
    382  1944		       04		      .byte.b	BANK_LEVEL__010_L
    383  1945		       04		      .byte.b	BANK_LEVEL__010_R
    384  1946		       04		      .byte.b	BANK_LEVEL__011_L
    385  1947		       04		      .byte.b	BANK_LEVEL__011_R
    386  1948		       04		      .byte.b	BANK_LEVEL__012_L
    387  1949		       04		      .byte.b	BANK_LEVEL__012_R
    388  194a		       04		      .byte.b	BANK_LEVEL__013_L
    389  194b		       04		      .byte.b	BANK_LEVEL__013_R
    390  194c		       04		      .byte.b	BANK_LEVEL__014_L
    391  194d		       04		      .byte.b	BANK_LEVEL__014_R
    392  194e		       04		      .byte.b	BANK_LEVEL__015_L
    393  194f		       04		      .byte.b	BANK_LEVEL__015_R
    394  1950		       04		      .byte.b	BANK_LEVEL__016_L
    395  1951		       04		      .byte.b	BANK_LEVEL__016_R
    396  1952		       04		      .byte.b	BANK_LEVEL__017_L
    397  1953		       04		      .byte.b	BANK_LEVEL__017_R
    398  1954		       04		      .byte.b	BANK_LEVEL__018_L
    399  1955		       04		      .byte.b	BANK_LEVEL__018_R
    400  1956		       04		      .byte.b	BANK_LEVEL__019_L
    401  1957		       04		      .byte.b	BANK_LEVEL__019_R
    402  1958		       05		      .byte.b	BANK_LEVEL__020_L
    403  1959		       05		      .byte.b	BANK_LEVEL__020_R
    404  195a		       05		      .byte.b	BANK_LEVEL__021_L
    405  195b		       05		      .byte.b	BANK_LEVEL__021_R
    406  195c		       05		      .byte.b	BANK_LEVEL__022_L
    407  195d		       05		      .byte.b	BANK_LEVEL__022_R
    408  195e		       05		      .byte.b	BANK_LEVEL__023_L
    409  195f		       05		      .byte.b	BANK_LEVEL__023_R
    410  1960		       05		      .byte.b	BANK_LEVEL__024_L
    411  1961		       05		      .byte.b	BANK_LEVEL__024_R
    412  1962		       05		      .byte.b	BANK_LEVEL__025_L
    413  1963		       05		      .byte.b	BANK_LEVEL__025_R
    414  1964		       05		      .byte.b	BANK_LEVEL__026_L
    415  1965		       05		      .byte.b	BANK_LEVEL__026_R
    416  1966		       05		      .byte.b	BANK_LEVEL__027_L
    417  1967		       05		      .byte.b	BANK_LEVEL__027_R
    418  1968		       05		      .byte.b	BANK_LEVEL__028_L
    419  1969		       05		      .byte.b	BANK_LEVEL__028_R
    420  196a		       05		      .byte.b	BANK_LEVEL__029_L
    421  196b		       05		      .byte.b	BANK_LEVEL__029_R
    422  196c		       05		      .byte.b	BANK_LEVEL__030_L
    423  196d		       05		      .byte.b	BANK_LEVEL__030_R
    424  196e		       05		      .byte.b	BANK_LEVEL__031_L
    425  196f		       05		      .byte.b	BANK_LEVEL__031_R
    426  1970		       05		      .byte.b	BANK_LEVEL__032_L
    427  1971		       05		      .byte.b	BANK_LEVEL__032_R
    428  1972		       05		      .byte.b	BANK_LEVEL__033_L
    429  1973		       05		      .byte.b	BANK_LEVEL__033_R
    430  1974		       05		      .byte.b	BANK_LEVEL__034_L
    431  1975		       06		      .byte.b	BANK_LEVEL__034_R
    432  1976		       06		      .byte.b	BANK_LEVEL__035_L
    433  1977		       06		      .byte.b	BANK_LEVEL__035_R
    434  1978		       06		      .byte.b	BANK_LEVEL__036_L
    435  1979		       06		      .byte.b	BANK_LEVEL__036_R
    436  197a		       06		      .byte.b	BANK_LEVEL__037_L
    437  197b		       06		      .byte.b	BANK_LEVEL__037_R
    438  197c		       06		      .byte.b	BANK_LEVEL__038_L
    439  197d		       06		      .byte.b	BANK_LEVEL__038_R
    440  197e		       06		      .byte.b	BANK_LEVEL__039_L
    441  197f		       06		      .byte.b	BANK_LEVEL__039_R
    442  1980		       06		      .byte.b	BANK_LEVEL__040_L
    443  1981		       06		      .byte.b	BANK_LEVEL__040_R
    444  1982
    445  1982		       06		      .byte.b	BANK_LEVEL__041_L
    446  1983		       06		      .byte.b	BANK_LEVEL__041_R
    447  1984		       06		      .byte.b	BANK_LEVEL__042_L
    448  1985		       06		      .byte.b	BANK_LEVEL__042_R
    449  1986		       06		      .byte.b	BANK_LEVEL__043_L
    450  1987		       06		      .byte.b	BANK_LEVEL__043_R
    451  1988		       06		      .byte.b	BANK_LEVEL__044_L
    452  1989		       06		      .byte.b	BANK_LEVEL__044_R
    453  198a		       06		      .byte.b	BANK_LEVEL__045_L
    454  198b		       06		      .byte.b	BANK_LEVEL__045_R
    455  198c		       06		      .byte.b	BANK_LEVEL__046_L
    456  198d		       06		      .byte.b	BANK_LEVEL__046_R
    457  198e		       06		      .byte.b	BANK_LEVEL__047_L
    458  198f		       06		      .byte.b	BANK_LEVEL__047_R
    459  1990		       07		      .byte.b	BANK_LEVEL__048_L
    460  1991		       07		      .byte.b	BANK_LEVEL__048_R
    461  1992		       07		      .byte.b	BANK_LEVEL__049_L
    462  1993		       07		      .byte.b	BANK_LEVEL__049_R
    463  1994
    464  1994		       07		      .byte.b	BANK_LEVEL__050_L
    465  1995		       07		      .byte.b	BANK_LEVEL__050_R
    466  1996		       07		      .byte.b	BANK_LEVEL__051_L
    467  1997		       07		      .byte.b	BANK_LEVEL__051_R
    468  1998		       07		      .byte.b	BANK_LEVEL__052_L
    469  1999		       07		      .byte.b	BANK_LEVEL__052_R
    470  199a		       07		      .byte.b	BANK_LEVEL__053_L
    471  199b		       07		      .byte.b	BANK_LEVEL__053_R
    472  199c		       07		      .byte.b	BANK_LEVEL__054_L
    473  199d		       07		      .byte.b	BANK_LEVEL__054_R
    474  199e		       07		      .byte.b	BANK_LEVEL__055_L
    475  199f		       07		      .byte.b	BANK_LEVEL__055_R
    476  19a0		       07		      .byte.b	BANK_LEVEL__056_L
    477  19a1		       07		      .byte.b	BANK_LEVEL__056_R
    478  19a2		       07		      .byte.b	BANK_LEVEL__057_L
    479  19a3		       07		      .byte.b	BANK_LEVEL__057_R
    480  19a4		       07		      .byte.b	BANK_LEVEL__058_L
    481  19a5		       07		      .byte.b	BANK_LEVEL__058_R
    482  19a6		       07		      .byte.b	BANK_LEVEL__059_L
    483  19a7		       07		      .byte.b	BANK_LEVEL__059_R
    484  19a8
    485  19a8		       08		      .byte.b	BANK_LEVEL__060_R
    486  19a9		       08		      .byte.b	BANK_LEVEL__061_R
    487  19aa		       08		      .byte.b	BANK_LEVEL__061_L
    488  19ab		       08		      .byte.b	BANK_LEVEL__062_L
    489  19ac		       08		      .byte.b	BANK_LEVEL__062_R
    490  19ad		       08		      .byte.b	BANK_LEVEL__063_L
    491  19ae		       08		      .byte.b	BANK_LEVEL__063_R
    492  19af		       08		      .byte.b	BANK_LEVEL__064_R
    493  19b0		       08		      .byte.b	BANK_LEVEL__064_L
    494  19b1		       08		      .byte.b	BANK_LEVEL__065_R
    495  19b2		       08		      .byte.b	BANK_LEVEL__065_L
    496  19b3		       08		      .byte.b	BANK_LEVEL__066_R
    497  19b4		       08		      .byte.b	BANK_LEVEL__066_L
    498  19b5		       08		      .byte.b	BANK_LEVEL__067_R
    499  19b6		       08		      .byte.b	BANK_LEVEL__067_L
    500  19b7		       08		      .byte.b	BANK_LEVEL__068_R
    501  19b8		       08		      .byte.b	BANK_LEVEL__068_L
    502  19b9		       08		      .byte.b	BANK_LEVEL__069_R
    503  19ba		       08		      .byte.b	BANK_LEVEL__069_L
    504  19bb
    505  19bb		       09		      .byte.b	BANK_LEVEL__103_Arielle
    506  19bc		       09		      .byte.b	BANK_LEVEL__103_Ajalae
    507  19bd		       09		      .byte.b	BANK_LEVEL__103_Adin
    508  19be		       09		      .byte.b	BANK_LEVEL__102_Raven
    509  19bf		       09		      .byte.b	BANK_LEVEL__102_Oralia
    510  19c0		       09		      .byte.b	BANK_LEVEL__102_Natalie
    511  19c1		       09		      .byte.b	BANK_LEVEL__102_Mirabel
    512  19c2		       09		      .byte.b	BANK_LEVEL__1XJH_Tara_Gelson
    513  19c3		       09		      .byte.b	BANK_LEVEL__1R7X_Alison
    514  19c4		       09		      .byte.b	BANK_LEVEL__1KWD_Cecile_Clayworth
    515  19c5		       09		      .byte.b	BANK_LEVEL__1EKT_Samantha_Gelson
    516  19c6		       09		      .byte.b	BANK_LEVEL__0VM5_Andrea_Wadd
    517  19c7		       09		      .byte.b	BANK_LEVEL__0PAL_Jill_Leatherby
    518  19c8		       09		      .byte.b	BANK_LEVEL__0IZ1_Sophia
    519  19c9		       09		      .byte.b	BANK_LEVEL__0CNH_Alice
    520  19ca
    521  19ca		       08		      .byte.b	BANK_LEVEL__122_Maya
    522  19cb
    523  19cb				  -	      IF	(* - LevelInfoBANK != MAX_LEVEL)
    524  19cb				  -	      ECHO	"ERROR: Incorrect LevelInfoBANK table!"
    525  19cb				  -	      ERR
    526  19cb					      ENDIF
    527  19cb
    528  19cb
    529  19cb
    530  19cb				   finX
    531  19cb							; now put the soil in - fill from the outsides
    532  19cb
    533  19cb		       a9 01		      lda	#CHARACTER_SOIL
    534  19cd		       85 8b		      sta	POS_Type
    535  19cf
    536  19cf		       a9 15		      lda	#SIZE_BOARD_Y-1
    537  19d1		       85 88		      sta	POS_Y
    538  19d3
    539  19d3		       a9 27	   xlin       lda	#SIZE_BOARD_X-1
    540  19d5		       85 87		      sta	POS_X
    541  19d7		       20 26 f8    zap1       jsr	GetBoardCharacter__CALL_FROM_RAM__
    542  19da		       c9 01		      cmp	#CHARACTER_SOIL
    543  19dc		       f0 07		      beq	kg2a
    544  19de		       c9 00		      cmp	#0
    545  19e0		       d0 07		      bne	endzap1
    546  19e2		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    547  19e5		       c6 87	   kg2a       dec	POS_X
    548  19e7		       10 ee		      bpl	zap1
    549  19e9
    550  19e9		       a9 00	   endzap1    lda	#0
    551  19eb		       85 87		      sta	POS_X
    552  19ed		       20 26 f8    zap2       jsr	GetBoardCharacter__CALL_FROM_RAM__
    553  19f0		       c9 01		      cmp	#CHARACTER_SOIL
    554  19f2		       f0 07		      beq	kg2
    555  19f4		       c9 00		      cmp	#0
    556  19f6		       d0 0b		      bne	endzap2
    557  19f8		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    558  19fb		       e6 87	   kg2	      inc	POS_X
    559  19fd		       a5 87		      lda	POS_X
    560  19ff		       c9 28		      cmp	#SIZE_BOARD_X
    561  1a01		       d0 ea		      bne	zap2
    562  1a03
    563  1a03		       c6 88	   endzap2    dec	POS_Y
    564  1a05		       10 cc		      bpl	xlin
    565  1a07
    566  1a07
    567  1a07		       a9 27		      lda	#SIZE_BOARD_X-1
    568  1a09		       85 87		      sta	POS_X
    569  1a0b
    570  1a0b		       a9 15	   ylin       lda	#SIZE_BOARD_Y-1
    571  1a0d		       85 88		      sta	POS_Y
    572  1a0f		       20 26 f8    zapy1      jsr	GetBoardCharacter__CALL_FROM_RAM__
    573  1a12		       c9 01		      cmp	#CHARACTER_SOIL
    574  1a14		       f0 07		      beq	kg3
    575  1a16		       c9 00		      cmp	#0
    576  1a18		       d0 07		      bne	endzapy1
    577  1a1a		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    578  1a1d		       c6 88	   kg3	      dec	POS_Y
    579  1a1f		       10 ee		      bpl	zapy1
    580  1a21
    581  1a21		       a9 00	   endzapy1   lda	#0
    582  1a23		       85 88		      sta	POS_Y
    583  1a25		       20 26 f8    zapy2      jsr	GetBoardCharacter__CALL_FROM_RAM__
    584  1a28		       c9 01		      cmp	#CHARACTER_SOIL
    585  1a2a		       f0 07		      beq	kg3b
    586  1a2c		       c9 00		      cmp	#0
    587  1a2e		       d0 0b		      bne	endzapy2
    588  1a30		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    589  1a33		       e6 88	   kg3b       inc	POS_Y
    590  1a35		       a5 88		      lda	POS_Y
    591  1a37		       c9 16		      cmp	#SIZE_BOARD_Y
    592  1a39		       d0 ea		      bne	zapy2
    593  1a3b
    594  1a3b		       c6 87	   endzapy2   dec	POS_X
    595  1a3d		       10 cc		      bpl	ylin
    596  1a3f		       60		      rts
    597  1a40
    598  1a40							;A	 steel wall
    599  1a40							;B	 soil (surround)
    600  1a40							;C	 box
    601  1a40
    602  1a40					      MAC	ntscpal
    603  1a40					      .byte	{1}+{2}
    604  1a40					      NTSC_TO_PAL	{1},{2}
    605  1a40					      ENDM		; {col} {intensity}
    606  1a40
    607  1a40				   C1			;
    608  1a40							; mortar for bricks
      0  1a40					      NTSCPAL	$C0,$8	;ok blue soil aqua walls grey box
      1  1a40		       c8		      .byte.b	$C0+$8
      0  1a41					      NTSC_TO_PAL	$C0,$8
      1  1a41				  -	      IF	$C0 = 0
      2  1a41				  -	      .byte	$C0+$8
      3  1a41					      ENDIF
      4  1a41				  -	      IF	$C0 = $10
      5  1a41				  -	      .byte	$20+$8
      6  1a41					      ENDIF
      7  1a41				  -	      IF	$C0 = $20
      8  1a41				  -	      .byte	$40+$8
      9  1a41					      ENDIF
     10  1a41				  -	      IF	$C0 = $30
     11  1a41				  -	      .byte	$40+$8
     12  1a41					      ENDIF
     13  1a41				  -	      IF	$C0 = $40
     14  1a41				  -	      .byte	$60+$8
     15  1a41					      ENDIF
     16  1a41				  -	      IF	$C0 = $50
     17  1a41				  -	      .byte	$80+$8
     18  1a41					      ENDIF
     19  1a41				  -	      IF	$C0 = $60
     20  1a41				  -	      .byte	$C0+$8
     21  1a41					      ENDIF
     22  1a41				  -	      IF	$C0 = $70
     23  1a41				  -	      .byte	$D0+$8
     24  1a41					      ENDIF
     25  1a41				  -	      IF	$C0 = $80
     26  1a41				  -	      .byte	$B0+$8
     27  1a41					      ENDIF
     28  1a41				  -	      IF	$C0 = $90
     29  1a41				  -	      .byte	$90+$8
     30  1a41					      ENDIF
     31  1a41				  -	      IF	$C0 = $A0
     32  1a41				  -	      .byte	$70+$8
     33  1a41					      ENDIF
     34  1a41				  -	      IF	$C0 = $B0
     35  1a41				  -	      .byte	$50+$8
     36  1a41					      ENDIF
     37  1a41					      IF	$C0 = $C0
     38  1a41		       38		      .byte.b	$30+$8
     39  1a42					      ENDIF
     40  1a42				  -	      IF	$C0 = $D0
     41  1a42				  -	      .byte	$30+$8
     42  1a42					      ENDIF
     43  1a42				  -	      IF	$C0 = $E0
     44  1a42				  -	      .byte	$20+$8
     45  1a42					      ENDIF
     46  1a42				  -	      IF	$C0 = $F0
     47  1a42				  -	      .byte	$40+$8
     48  1a42					      ENDIF
      0  1a42					      NTSCPAL	$60,$8	;ok red soil purple walls orange box
      1  1a42		       68		      .byte.b	$60+$8
      0  1a43					      NTSC_TO_PAL	$60,$8
      1  1a43				  -	      IF	$60 = 0
      2  1a43				  -	      .byte	$60+$8
      3  1a43					      ENDIF
      4  1a43				  -	      IF	$60 = $10
      5  1a43				  -	      .byte	$20+$8
      6  1a43					      ENDIF
      7  1a43				  -	      IF	$60 = $20
      8  1a43				  -	      .byte	$40+$8
      9  1a43					      ENDIF
     10  1a43				  -	      IF	$60 = $30
     11  1a43				  -	      .byte	$40+$8
     12  1a43					      ENDIF
     13  1a43				  -	      IF	$60 = $40
     14  1a43				  -	      .byte	$60+$8
     15  1a43					      ENDIF
     16  1a43				  -	      IF	$60 = $50
     17  1a43				  -	      .byte	$80+$8
     18  1a43					      ENDIF
     19  1a43					      IF	$60 = $60
     20  1a43		       c8		      .byte.b	$C0+$8
     21  1a44					      ENDIF
     22  1a44				  -	      IF	$60 = $70
     23  1a44				  -	      .byte	$D0+$8
     24  1a44					      ENDIF
     25  1a44				  -	      IF	$60 = $80
     26  1a44				  -	      .byte	$B0+$8
     27  1a44					      ENDIF
     28  1a44				  -	      IF	$60 = $90
     29  1a44				  -	      .byte	$90+$8
     30  1a44					      ENDIF
     31  1a44				  -	      IF	$60 = $A0
     32  1a44				  -	      .byte	$70+$8
     33  1a44					      ENDIF
     34  1a44				  -	      IF	$60 = $B0
     35  1a44				  -	      .byte	$50+$8
     36  1a44					      ENDIF
     37  1a44				  -	      IF	$60 = $C0
     38  1a44				  -	      .byte	$30+$8
     39  1a44					      ENDIF
     40  1a44				  -	      IF	$60 = $D0
     41  1a44				  -	      .byte	$30+$8
     42  1a44					      ENDIF
     43  1a44				  -	      IF	$60 = $E0
     44  1a44				  -	      .byte	$20+$8
     45  1a44					      ENDIF
     46  1a44				  -	      IF	$60 = $F0
     47  1a44				  -	      .byte	$40+$8
     48  1a44					      ENDIF
      0  1a44					      NTSCPAL	$40,$8	;ok both     green soil, yellow wall, blue box purple top
      1  1a44		       48		      .byte.b	$40+$8
      0  1a45					      NTSC_TO_PAL	$40,$8
      1  1a45				  -	      IF	$40 = 0
      2  1a45				  -	      .byte	$40+$8
      3  1a45					      ENDIF
      4  1a45				  -	      IF	$40 = $10
      5  1a45				  -	      .byte	$20+$8
      6  1a45					      ENDIF
      7  1a45				  -	      IF	$40 = $20
      8  1a45				  -	      .byte	$40+$8
      9  1a45					      ENDIF
     10  1a45				  -	      IF	$40 = $30
     11  1a45				  -	      .byte	$40+$8
     12  1a45					      ENDIF
     13  1a45					      IF	$40 = $40
     14  1a45		       68		      .byte.b	$60+$8
     15  1a46					      ENDIF
     16  1a46				  -	      IF	$40 = $50
     17  1a46				  -	      .byte	$80+$8
     18  1a46					      ENDIF
     19  1a46				  -	      IF	$40 = $60
     20  1a46				  -	      .byte	$C0+$8
     21  1a46					      ENDIF
     22  1a46				  -	      IF	$40 = $70
     23  1a46				  -	      .byte	$D0+$8
     24  1a46					      ENDIF
     25  1a46				  -	      IF	$40 = $80
     26  1a46				  -	      .byte	$B0+$8
     27  1a46					      ENDIF
     28  1a46				  -	      IF	$40 = $90
     29  1a46				  -	      .byte	$90+$8
     30  1a46					      ENDIF
     31  1a46				  -	      IF	$40 = $A0
     32  1a46				  -	      .byte	$70+$8
     33  1a46					      ENDIF
     34  1a46				  -	      IF	$40 = $B0
     35  1a46				  -	      .byte	$50+$8
     36  1a46					      ENDIF
     37  1a46				  -	      IF	$40 = $C0
     38  1a46				  -	      .byte	$30+$8
     39  1a46					      ENDIF
     40  1a46				  -	      IF	$40 = $D0
     41  1a46				  -	      .byte	$30+$8
     42  1a46					      ENDIF
     43  1a46				  -	      IF	$40 = $E0
     44  1a46				  -	      .byte	$20+$8
     45  1a46					      ENDIF
     46  1a46				  -	      IF	$40 = $F0
     47  1a46				  -	      .byte	$40+$8
     48  1a46					      ENDIF
      0  1a46					      NTSCPAL	$F0,$8	;ok both   blue soil, grey box/wall
      1  1a46		       f8		      .byte.b	$F0+$8
      0  1a47					      NTSC_TO_PAL	$F0,$8
      1  1a47				  -	      IF	$F0 = 0
      2  1a47				  -	      .byte	$F0+$8
      3  1a47					      ENDIF
      4  1a47				  -	      IF	$F0 = $10
      5  1a47				  -	      .byte	$20+$8
      6  1a47					      ENDIF
      7  1a47				  -	      IF	$F0 = $20
      8  1a47				  -	      .byte	$40+$8
      9  1a47					      ENDIF
     10  1a47				  -	      IF	$F0 = $30
     11  1a47				  -	      .byte	$40+$8
     12  1a47					      ENDIF
     13  1a47				  -	      IF	$F0 = $40
     14  1a47				  -	      .byte	$60+$8
     15  1a47					      ENDIF
     16  1a47				  -	      IF	$F0 = $50
     17  1a47				  -	      .byte	$80+$8
     18  1a47					      ENDIF
     19  1a47				  -	      IF	$F0 = $60
     20  1a47				  -	      .byte	$C0+$8
     21  1a47					      ENDIF
     22  1a47				  -	      IF	$F0 = $70
     23  1a47				  -	      .byte	$D0+$8
     24  1a47					      ENDIF
     25  1a47				  -	      IF	$F0 = $80
     26  1a47				  -	      .byte	$B0+$8
     27  1a47					      ENDIF
     28  1a47				  -	      IF	$F0 = $90
     29  1a47				  -	      .byte	$90+$8
     30  1a47					      ENDIF
     31  1a47				  -	      IF	$F0 = $A0
     32  1a47				  -	      .byte	$70+$8
     33  1a47					      ENDIF
     34  1a47				  -	      IF	$F0 = $B0
     35  1a47				  -	      .byte	$50+$8
     36  1a47					      ENDIF
     37  1a47				  -	      IF	$F0 = $C0
     38  1a47				  -	      .byte	$30+$8
     39  1a47					      ENDIF
     40  1a47				  -	      IF	$F0 = $D0
     41  1a47				  -	      .byte	$30+$8
     42  1a47					      ENDIF
     43  1a47				  -	      IF	$F0 = $E0
     44  1a47				  -	      .byte	$20+$8
     45  1a47					      ENDIF
     46  1a47					      IF	$F0 = $F0
     47  1a47		       48		      .byte.b	$40+$8
     48  1a48					      ENDIF
      0  1a48					      NTSCPAL	$30,$8
      1  1a48		       38		      .byte.b	$30+$8
      0  1a49					      NTSC_TO_PAL	$30,$8
      1  1a49				  -	      IF	$30 = 0
      2  1a49				  -	      .byte	$30+$8
      3  1a49					      ENDIF
      4  1a49				  -	      IF	$30 = $10
      5  1a49				  -	      .byte	$20+$8
      6  1a49					      ENDIF
      7  1a49				  -	      IF	$30 = $20
      8  1a49				  -	      .byte	$40+$8
      9  1a49					      ENDIF
     10  1a49					      IF	$30 = $30
     11  1a49		       48		      .byte.b	$40+$8
     12  1a4a					      ENDIF
     13  1a4a				  -	      IF	$30 = $40
     14  1a4a				  -	      .byte	$60+$8
     15  1a4a					      ENDIF
     16  1a4a				  -	      IF	$30 = $50
     17  1a4a				  -	      .byte	$80+$8
     18  1a4a					      ENDIF
     19  1a4a				  -	      IF	$30 = $60
     20  1a4a				  -	      .byte	$C0+$8
     21  1a4a					      ENDIF
     22  1a4a				  -	      IF	$30 = $70
     23  1a4a				  -	      .byte	$D0+$8
     24  1a4a					      ENDIF
     25  1a4a				  -	      IF	$30 = $80
     26  1a4a				  -	      .byte	$B0+$8
     27  1a4a					      ENDIF
     28  1a4a				  -	      IF	$30 = $90
     29  1a4a				  -	      .byte	$90+$8
     30  1a4a					      ENDIF
     31  1a4a				  -	      IF	$30 = $A0
     32  1a4a				  -	      .byte	$70+$8
     33  1a4a					      ENDIF
     34  1a4a				  -	      IF	$30 = $B0
     35  1a4a				  -	      .byte	$50+$8
     36  1a4a					      ENDIF
     37  1a4a				  -	      IF	$30 = $C0
     38  1a4a				  -	      .byte	$30+$8
     39  1a4a					      ENDIF
     40  1a4a				  -	      IF	$30 = $D0
     41  1a4a				  -	      .byte	$30+$8
     42  1a4a					      ENDIF
     43  1a4a				  -	      IF	$30 = $E0
     44  1a4a				  -	      .byte	$20+$8
     45  1a4a					      ENDIF
     46  1a4a				  -	      IF	$30 = $F0
     47  1a4a				  -	      .byte	$40+$8
     48  1a4a					      ENDIF
      0  1a4a					      NTSCPAL	$90,$8
      1  1a4a		       98		      .byte.b	$90+$8
      0  1a4b					      NTSC_TO_PAL	$90,$8
      1  1a4b				  -	      IF	$90 = 0
      2  1a4b				  -	      .byte	$90+$8
      3  1a4b					      ENDIF
      4  1a4b				  -	      IF	$90 = $10
      5  1a4b				  -	      .byte	$20+$8
      6  1a4b					      ENDIF
      7  1a4b				  -	      IF	$90 = $20
      8  1a4b				  -	      .byte	$40+$8
      9  1a4b					      ENDIF
     10  1a4b				  -	      IF	$90 = $30
     11  1a4b				  -	      .byte	$40+$8
     12  1a4b					      ENDIF
     13  1a4b				  -	      IF	$90 = $40
     14  1a4b				  -	      .byte	$60+$8
     15  1a4b					      ENDIF
     16  1a4b				  -	      IF	$90 = $50
     17  1a4b				  -	      .byte	$80+$8
     18  1a4b					      ENDIF
     19  1a4b				  -	      IF	$90 = $60
     20  1a4b				  -	      .byte	$C0+$8
     21  1a4b					      ENDIF
     22  1a4b				  -	      IF	$90 = $70
     23  1a4b				  -	      .byte	$D0+$8
     24  1a4b					      ENDIF
     25  1a4b				  -	      IF	$90 = $80
     26  1a4b				  -	      .byte	$B0+$8
     27  1a4b					      ENDIF
     28  1a4b					      IF	$90 = $90
     29  1a4b		       98		      .byte.b	$90+$8
     30  1a4c					      ENDIF
     31  1a4c				  -	      IF	$90 = $A0
     32  1a4c				  -	      .byte	$70+$8
     33  1a4c					      ENDIF
     34  1a4c				  -	      IF	$90 = $B0
     35  1a4c				  -	      .byte	$50+$8
     36  1a4c					      ENDIF
     37  1a4c				  -	      IF	$90 = $C0
     38  1a4c				  -	      .byte	$30+$8
     39  1a4c					      ENDIF
     40  1a4c				  -	      IF	$90 = $D0
     41  1a4c				  -	      .byte	$30+$8
     42  1a4c					      ENDIF
     43  1a4c				  -	      IF	$90 = $E0
     44  1a4c				  -	      .byte	$20+$8
     45  1a4c					      ENDIF
     46  1a4c				  -	      IF	$90 = $F0
     47  1a4c				  -	      .byte	$40+$8
     48  1a4c					      ENDIF
      0  1a4c					      NTSCPAL	$20,$8	; lovely????
      1  1a4c		       28		      .byte.b	$20+$8
      0  1a4d					      NTSC_TO_PAL	$20,$8
      1  1a4d				  -	      IF	$20 = 0
      2  1a4d				  -	      .byte	$20+$8
      3  1a4d					      ENDIF
      4  1a4d				  -	      IF	$20 = $10
      5  1a4d				  -	      .byte	$20+$8
      6  1a4d					      ENDIF
      7  1a4d					      IF	$20 = $20
      8  1a4d		       48		      .byte.b	$40+$8
      9  1a4e					      ENDIF
     10  1a4e				  -	      IF	$20 = $30
     11  1a4e				  -	      .byte	$40+$8
     12  1a4e					      ENDIF
     13  1a4e				  -	      IF	$20 = $40
     14  1a4e				  -	      .byte	$60+$8
     15  1a4e					      ENDIF
     16  1a4e				  -	      IF	$20 = $50
     17  1a4e				  -	      .byte	$80+$8
     18  1a4e					      ENDIF
     19  1a4e				  -	      IF	$20 = $60
     20  1a4e				  -	      .byte	$C0+$8
     21  1a4e					      ENDIF
     22  1a4e				  -	      IF	$20 = $70
     23  1a4e				  -	      .byte	$D0+$8
     24  1a4e					      ENDIF
     25  1a4e				  -	      IF	$20 = $80
     26  1a4e				  -	      .byte	$B0+$8
     27  1a4e					      ENDIF
     28  1a4e				  -	      IF	$20 = $90
     29  1a4e				  -	      .byte	$90+$8
     30  1a4e					      ENDIF
     31  1a4e				  -	      IF	$20 = $A0
     32  1a4e				  -	      .byte	$70+$8
     33  1a4e					      ENDIF
     34  1a4e				  -	      IF	$20 = $B0
     35  1a4e				  -	      .byte	$50+$8
     36  1a4e					      ENDIF
     37  1a4e				  -	      IF	$20 = $C0
     38  1a4e				  -	      .byte	$30+$8
     39  1a4e					      ENDIF
     40  1a4e				  -	      IF	$20 = $D0
     41  1a4e				  -	      .byte	$30+$8
     42  1a4e					      ENDIF
     43  1a4e				  -	      IF	$20 = $E0
     44  1a4e				  -	      .byte	$20+$8
     45  1a4e					      ENDIF
     46  1a4e				  -	      IF	$20 = $F0
     47  1a4e				  -	      .byte	$40+$8
     48  1a4e					      ENDIF
      0  1a4e					      NTSCPAL	$70,$8
      1  1a4e		       78		      .byte.b	$70+$8
      0  1a4f					      NTSC_TO_PAL	$70,$8
      1  1a4f				  -	      IF	$70 = 0
      2  1a4f				  -	      .byte	$70+$8
      3  1a4f					      ENDIF
      4  1a4f				  -	      IF	$70 = $10
      5  1a4f				  -	      .byte	$20+$8
      6  1a4f					      ENDIF
      7  1a4f				  -	      IF	$70 = $20
      8  1a4f				  -	      .byte	$40+$8
      9  1a4f					      ENDIF
     10  1a4f				  -	      IF	$70 = $30
     11  1a4f				  -	      .byte	$40+$8
     12  1a4f					      ENDIF
     13  1a4f				  -	      IF	$70 = $40
     14  1a4f				  -	      .byte	$60+$8
     15  1a4f					      ENDIF
     16  1a4f				  -	      IF	$70 = $50
     17  1a4f				  -	      .byte	$80+$8
     18  1a4f					      ENDIF
     19  1a4f				  -	      IF	$70 = $60
     20  1a4f				  -	      .byte	$C0+$8
     21  1a4f					      ENDIF
     22  1a4f					      IF	$70 = $70
     23  1a4f		       d8		      .byte.b	$D0+$8
     24  1a50					      ENDIF
     25  1a50				  -	      IF	$70 = $80
     26  1a50				  -	      .byte	$B0+$8
     27  1a50					      ENDIF
     28  1a50				  -	      IF	$70 = $90
     29  1a50				  -	      .byte	$90+$8
     30  1a50					      ENDIF
     31  1a50				  -	      IF	$70 = $A0
     32  1a50				  -	      .byte	$70+$8
     33  1a50					      ENDIF
     34  1a50				  -	      IF	$70 = $B0
     35  1a50				  -	      .byte	$50+$8
     36  1a50					      ENDIF
     37  1a50				  -	      IF	$70 = $C0
     38  1a50				  -	      .byte	$30+$8
     39  1a50					      ENDIF
     40  1a50				  -	      IF	$70 = $D0
     41  1a50				  -	      .byte	$30+$8
     42  1a50					      ENDIF
     43  1a50				  -	      IF	$70 = $E0
     44  1a50				  -	      .byte	$20+$8
     45  1a50					      ENDIF
     46  1a50				  -	      IF	$70 = $F0
     47  1a50				  -	      .byte	$40+$8
     48  1a50					      ENDIF
    617  1a50							;    NTSCPAL $40,$A
    618  1a50							;    NTSCPAL $C0,$8
    619  1a50				   C2			; soil stripes
      0  1a50					      NTSCPAL	$90,$6	; ok v nice
      1  1a50		       96		      .byte.b	$90+$6
      0  1a51					      NTSC_TO_PAL	$90,$6
      1  1a51				  -	      IF	$90 = 0
      2  1a51				  -	      .byte	$90+$6
      3  1a51					      ENDIF
      4  1a51				  -	      IF	$90 = $10
      5  1a51				  -	      .byte	$20+$6
      6  1a51					      ENDIF
      7  1a51				  -	      IF	$90 = $20
      8  1a51				  -	      .byte	$40+$6
      9  1a51					      ENDIF
     10  1a51				  -	      IF	$90 = $30
     11  1a51				  -	      .byte	$40+$6
     12  1a51					      ENDIF
     13  1a51				  -	      IF	$90 = $40
     14  1a51				  -	      .byte	$60+$6
     15  1a51					      ENDIF
     16  1a51				  -	      IF	$90 = $50
     17  1a51				  -	      .byte	$80+$6
     18  1a51					      ENDIF
     19  1a51				  -	      IF	$90 = $60
     20  1a51				  -	      .byte	$C0+$6
     21  1a51					      ENDIF
     22  1a51				  -	      IF	$90 = $70
     23  1a51				  -	      .byte	$D0+$6
     24  1a51					      ENDIF
     25  1a51				  -	      IF	$90 = $80
     26  1a51				  -	      .byte	$B0+$6
     27  1a51					      ENDIF
     28  1a51					      IF	$90 = $90
     29  1a51		       96		      .byte.b	$90+$6
     30  1a52					      ENDIF
     31  1a52				  -	      IF	$90 = $A0
     32  1a52				  -	      .byte	$70+$6
     33  1a52					      ENDIF
     34  1a52				  -	      IF	$90 = $B0
     35  1a52				  -	      .byte	$50+$6
     36  1a52					      ENDIF
     37  1a52				  -	      IF	$90 = $C0
     38  1a52				  -	      .byte	$30+$6
     39  1a52					      ENDIF
     40  1a52				  -	      IF	$90 = $D0
     41  1a52				  -	      .byte	$30+$6
     42  1a52					      ENDIF
     43  1a52				  -	      IF	$90 = $E0
     44  1a52				  -	      .byte	$20+$6
     45  1a52					      ENDIF
     46  1a52				  -	      IF	$90 = $F0
     47  1a52				  -	      .byte	$40+$6
     48  1a52					      ENDIF
      0  1a52					      NTSCPAL	$0,$6	; ok v nice brick
      1  1a52		       06		      .byte.b	$0+$6
      0  1a53					      NTSC_TO_PAL	$0,$6
      1  1a53					      IF	$0 = 0
      2  1a53		       06		      .byte.b	$0+$6
      3  1a54					      ENDIF
      4  1a54				  -	      IF	$0 = $10
      5  1a54				  -	      .byte	$20+$6
      6  1a54					      ENDIF
      7  1a54				  -	      IF	$0 = $20
      8  1a54				  -	      .byte	$40+$6
      9  1a54					      ENDIF
     10  1a54				  -	      IF	$0 = $30
     11  1a54				  -	      .byte	$40+$6
     12  1a54					      ENDIF
     13  1a54				  -	      IF	$0 = $40
     14  1a54				  -	      .byte	$60+$6
     15  1a54					      ENDIF
     16  1a54				  -	      IF	$0 = $50
     17  1a54				  -	      .byte	$80+$6
     18  1a54					      ENDIF
     19  1a54				  -	      IF	$0 = $60
     20  1a54				  -	      .byte	$C0+$6
     21  1a54					      ENDIF
     22  1a54				  -	      IF	$0 = $70
     23  1a54				  -	      .byte	$D0+$6
     24  1a54					      ENDIF
     25  1a54				  -	      IF	$0 = $80
     26  1a54				  -	      .byte	$B0+$6
     27  1a54					      ENDIF
     28  1a54				  -	      IF	$0 = $90
     29  1a54				  -	      .byte	$90+$6
     30  1a54					      ENDIF
     31  1a54				  -	      IF	$0 = $A0
     32  1a54				  -	      .byte	$70+$6
     33  1a54					      ENDIF
     34  1a54				  -	      IF	$0 = $B0
     35  1a54				  -	      .byte	$50+$6
     36  1a54					      ENDIF
     37  1a54				  -	      IF	$0 = $C0
     38  1a54				  -	      .byte	$30+$6
     39  1a54					      ENDIF
     40  1a54				  -	      IF	$0 = $D0
     41  1a54				  -	      .byte	$30+$6
     42  1a54					      ENDIF
     43  1a54				  -	      IF	$0 = $E0
     44  1a54				  -	      .byte	$20+$6
     45  1a54					      ENDIF
     46  1a54				  -	      IF	$0 = $F0
     47  1a54				  -	      .byte	$40+$6
     48  1a54					      ENDIF
      0  1a54					      NTSCPAL	$D0,$6	;ok both
      1  1a54		       d6		      .byte.b	$D0+$6
      0  1a55					      NTSC_TO_PAL	$D0,$6
      1  1a55				  -	      IF	$D0 = 0
      2  1a55				  -	      .byte	$D0+$6
      3  1a55					      ENDIF
      4  1a55				  -	      IF	$D0 = $10
      5  1a55				  -	      .byte	$20+$6
      6  1a55					      ENDIF
      7  1a55				  -	      IF	$D0 = $20
      8  1a55				  -	      .byte	$40+$6
      9  1a55					      ENDIF
     10  1a55				  -	      IF	$D0 = $30
     11  1a55				  -	      .byte	$40+$6
     12  1a55					      ENDIF
     13  1a55				  -	      IF	$D0 = $40
     14  1a55				  -	      .byte	$60+$6
     15  1a55					      ENDIF
     16  1a55				  -	      IF	$D0 = $50
     17  1a55				  -	      .byte	$80+$6
     18  1a55					      ENDIF
     19  1a55				  -	      IF	$D0 = $60
     20  1a55				  -	      .byte	$C0+$6
     21  1a55					      ENDIF
     22  1a55				  -	      IF	$D0 = $70
     23  1a55				  -	      .byte	$D0+$6
     24  1a55					      ENDIF
     25  1a55				  -	      IF	$D0 = $80
     26  1a55				  -	      .byte	$B0+$6
     27  1a55					      ENDIF
     28  1a55				  -	      IF	$D0 = $90
     29  1a55				  -	      .byte	$90+$6
     30  1a55					      ENDIF
     31  1a55				  -	      IF	$D0 = $A0
     32  1a55				  -	      .byte	$70+$6
     33  1a55					      ENDIF
     34  1a55				  -	      IF	$D0 = $B0
     35  1a55				  -	      .byte	$50+$6
     36  1a55					      ENDIF
     37  1a55				  -	      IF	$D0 = $C0
     38  1a55				  -	      .byte	$30+$6
     39  1a55					      ENDIF
     40  1a55					      IF	$D0 = $D0
     41  1a55		       36		      .byte.b	$30+$6
     42  1a56					      ENDIF
     43  1a56				  -	      IF	$D0 = $E0
     44  1a56				  -	      .byte	$20+$6
     45  1a56					      ENDIF
     46  1a56				  -	      IF	$D0 = $F0
     47  1a56				  -	      .byte	$40+$6
     48  1a56					      ENDIF
      0  1a56					      NTSCPAL	$D0,$6	;ok both
      1  1a56		       d6		      .byte.b	$D0+$6
      0  1a57					      NTSC_TO_PAL	$D0,$6
      1  1a57				  -	      IF	$D0 = 0
      2  1a57				  -	      .byte	$D0+$6
      3  1a57					      ENDIF
      4  1a57				  -	      IF	$D0 = $10
      5  1a57				  -	      .byte	$20+$6
      6  1a57					      ENDIF
      7  1a57				  -	      IF	$D0 = $20
      8  1a57				  -	      .byte	$40+$6
      9  1a57					      ENDIF
     10  1a57				  -	      IF	$D0 = $30
     11  1a57				  -	      .byte	$40+$6
     12  1a57					      ENDIF
     13  1a57				  -	      IF	$D0 = $40
     14  1a57				  -	      .byte	$60+$6
     15  1a57					      ENDIF
     16  1a57				  -	      IF	$D0 = $50
     17  1a57				  -	      .byte	$80+$6
     18  1a57					      ENDIF
     19  1a57				  -	      IF	$D0 = $60
     20  1a57				  -	      .byte	$C0+$6
     21  1a57					      ENDIF
     22  1a57				  -	      IF	$D0 = $70
     23  1a57				  -	      .byte	$D0+$6
     24  1a57					      ENDIF
     25  1a57				  -	      IF	$D0 = $80
     26  1a57				  -	      .byte	$B0+$6
     27  1a57					      ENDIF
     28  1a57				  -	      IF	$D0 = $90
     29  1a57				  -	      .byte	$90+$6
     30  1a57					      ENDIF
     31  1a57				  -	      IF	$D0 = $A0
     32  1a57				  -	      .byte	$70+$6
     33  1a57					      ENDIF
     34  1a57				  -	      IF	$D0 = $B0
     35  1a57				  -	      .byte	$50+$6
     36  1a57					      ENDIF
     37  1a57				  -	      IF	$D0 = $C0
     38  1a57				  -	      .byte	$30+$6
     39  1a57					      ENDIF
     40  1a57					      IF	$D0 = $D0
     41  1a57		       36		      .byte.b	$30+$6
     42  1a58					      ENDIF
     43  1a58				  -	      IF	$D0 = $E0
     44  1a58				  -	      .byte	$20+$6
     45  1a58					      ENDIF
     46  1a58				  -	      IF	$D0 = $F0
     47  1a58				  -	      .byte	$40+$6
     48  1a58					      ENDIF
      0  1a58					      NTSCPAL	$60,$6
      1  1a58		       66		      .byte.b	$60+$6
      0  1a59					      NTSC_TO_PAL	$60,$6
      1  1a59				  -	      IF	$60 = 0
      2  1a59				  -	      .byte	$60+$6
      3  1a59					      ENDIF
      4  1a59				  -	      IF	$60 = $10
      5  1a59				  -	      .byte	$20+$6
      6  1a59					      ENDIF
      7  1a59				  -	      IF	$60 = $20
      8  1a59				  -	      .byte	$40+$6
      9  1a59					      ENDIF
     10  1a59				  -	      IF	$60 = $30
     11  1a59				  -	      .byte	$40+$6
     12  1a59					      ENDIF
     13  1a59				  -	      IF	$60 = $40
     14  1a59				  -	      .byte	$60+$6
     15  1a59					      ENDIF
     16  1a59				  -	      IF	$60 = $50
     17  1a59				  -	      .byte	$80+$6
     18  1a59					      ENDIF
     19  1a59					      IF	$60 = $60
     20  1a59		       c6		      .byte.b	$C0+$6
     21  1a5a					      ENDIF
     22  1a5a				  -	      IF	$60 = $70
     23  1a5a				  -	      .byte	$D0+$6
     24  1a5a					      ENDIF
     25  1a5a				  -	      IF	$60 = $80
     26  1a5a				  -	      .byte	$B0+$6
     27  1a5a					      ENDIF
     28  1a5a				  -	      IF	$60 = $90
     29  1a5a				  -	      .byte	$90+$6
     30  1a5a					      ENDIF
     31  1a5a				  -	      IF	$60 = $A0
     32  1a5a				  -	      .byte	$70+$6
     33  1a5a					      ENDIF
     34  1a5a				  -	      IF	$60 = $B0
     35  1a5a				  -	      .byte	$50+$6
     36  1a5a					      ENDIF
     37  1a5a				  -	      IF	$60 = $C0
     38  1a5a				  -	      .byte	$30+$6
     39  1a5a					      ENDIF
     40  1a5a				  -	      IF	$60 = $D0
     41  1a5a				  -	      .byte	$30+$6
     42  1a5a					      ENDIF
     43  1a5a				  -	      IF	$60 = $E0
     44  1a5a				  -	      .byte	$20+$6
     45  1a5a					      ENDIF
     46  1a5a				  -	      IF	$60 = $F0
     47  1a5a				  -	      .byte	$40+$6
     48  1a5a					      ENDIF
      0  1a5a					      NTSCPAL	$40,$6	; lovely
      1  1a5a		       46		      .byte.b	$40+$6
      0  1a5b					      NTSC_TO_PAL	$40,$6
      1  1a5b				  -	      IF	$40 = 0
      2  1a5b				  -	      .byte	$40+$6
      3  1a5b					      ENDIF
      4  1a5b				  -	      IF	$40 = $10
      5  1a5b				  -	      .byte	$20+$6
      6  1a5b					      ENDIF
      7  1a5b				  -	      IF	$40 = $20
      8  1a5b				  -	      .byte	$40+$6
      9  1a5b					      ENDIF
     10  1a5b				  -	      IF	$40 = $30
     11  1a5b				  -	      .byte	$40+$6
     12  1a5b					      ENDIF
     13  1a5b					      IF	$40 = $40
     14  1a5b		       66		      .byte.b	$60+$6
     15  1a5c					      ENDIF
     16  1a5c				  -	      IF	$40 = $50
     17  1a5c				  -	      .byte	$80+$6
     18  1a5c					      ENDIF
     19  1a5c				  -	      IF	$40 = $60
     20  1a5c				  -	      .byte	$C0+$6
     21  1a5c					      ENDIF
     22  1a5c				  -	      IF	$40 = $70
     23  1a5c				  -	      .byte	$D0+$6
     24  1a5c					      ENDIF
     25  1a5c				  -	      IF	$40 = $80
     26  1a5c				  -	      .byte	$B0+$6
     27  1a5c					      ENDIF
     28  1a5c				  -	      IF	$40 = $90
     29  1a5c				  -	      .byte	$90+$6
     30  1a5c					      ENDIF
     31  1a5c				  -	      IF	$40 = $A0
     32  1a5c				  -	      .byte	$70+$6
     33  1a5c					      ENDIF
     34  1a5c				  -	      IF	$40 = $B0
     35  1a5c				  -	      .byte	$50+$6
     36  1a5c					      ENDIF
     37  1a5c				  -	      IF	$40 = $C0
     38  1a5c				  -	      .byte	$30+$6
     39  1a5c					      ENDIF
     40  1a5c				  -	      IF	$40 = $D0
     41  1a5c				  -	      .byte	$30+$6
     42  1a5c					      ENDIF
     43  1a5c				  -	      IF	$40 = $E0
     44  1a5c				  -	      .byte	$20+$6
     45  1a5c					      ENDIF
     46  1a5c				  -	      IF	$40 = $F0
     47  1a5c				  -	      .byte	$40+$6
     48  1a5c					      ENDIF
      0  1a5c					      NTSCPAL	$90,$6	;ok
      1  1a5c		       96		      .byte.b	$90+$6
      0  1a5d					      NTSC_TO_PAL	$90,$6
      1  1a5d				  -	      IF	$90 = 0
      2  1a5d				  -	      .byte	$90+$6
      3  1a5d					      ENDIF
      4  1a5d				  -	      IF	$90 = $10
      5  1a5d				  -	      .byte	$20+$6
      6  1a5d					      ENDIF
      7  1a5d				  -	      IF	$90 = $20
      8  1a5d				  -	      .byte	$40+$6
      9  1a5d					      ENDIF
     10  1a5d				  -	      IF	$90 = $30
     11  1a5d				  -	      .byte	$40+$6
     12  1a5d					      ENDIF
     13  1a5d				  -	      IF	$90 = $40
     14  1a5d				  -	      .byte	$60+$6
     15  1a5d					      ENDIF
     16  1a5d				  -	      IF	$90 = $50
     17  1a5d				  -	      .byte	$80+$6
     18  1a5d					      ENDIF
     19  1a5d				  -	      IF	$90 = $60
     20  1a5d				  -	      .byte	$C0+$6
     21  1a5d					      ENDIF
     22  1a5d				  -	      IF	$90 = $70
     23  1a5d				  -	      .byte	$D0+$6
     24  1a5d					      ENDIF
     25  1a5d				  -	      IF	$90 = $80
     26  1a5d				  -	      .byte	$B0+$6
     27  1a5d					      ENDIF
     28  1a5d					      IF	$90 = $90
     29  1a5d		       96		      .byte.b	$90+$6
     30  1a5e					      ENDIF
     31  1a5e				  -	      IF	$90 = $A0
     32  1a5e				  -	      .byte	$70+$6
     33  1a5e					      ENDIF
     34  1a5e				  -	      IF	$90 = $B0
     35  1a5e				  -	      .byte	$50+$6
     36  1a5e					      ENDIF
     37  1a5e				  -	      IF	$90 = $C0
     38  1a5e				  -	      .byte	$30+$6
     39  1a5e					      ENDIF
     40  1a5e				  -	      IF	$90 = $D0
     41  1a5e				  -	      .byte	$30+$6
     42  1a5e					      ENDIF
     43  1a5e				  -	      IF	$90 = $E0
     44  1a5e				  -	      .byte	$20+$6
     45  1a5e					      ENDIF
     46  1a5e				  -	      IF	$90 = $F0
     47  1a5e				  -	      .byte	$40+$6
     48  1a5e					      ENDIF
      0  1a5e					      NTSCPAL	$10,$6
      1  1a5e		       16		      .byte.b	$10+$6
      0  1a5f					      NTSC_TO_PAL	$10,$6
      1  1a5f				  -	      IF	$10 = 0
      2  1a5f				  -	      .byte	$10+$6
      3  1a5f					      ENDIF
      4  1a5f					      IF	$10 = $10
      5  1a5f		       26		      .byte.b	$20+$6
      6  1a60					      ENDIF
      7  1a60				  -	      IF	$10 = $20
      8  1a60				  -	      .byte	$40+$6
      9  1a60					      ENDIF
     10  1a60				  -	      IF	$10 = $30
     11  1a60				  -	      .byte	$40+$6
     12  1a60					      ENDIF
     13  1a60				  -	      IF	$10 = $40
     14  1a60				  -	      .byte	$60+$6
     15  1a60					      ENDIF
     16  1a60				  -	      IF	$10 = $50
     17  1a60				  -	      .byte	$80+$6
     18  1a60					      ENDIF
     19  1a60				  -	      IF	$10 = $60
     20  1a60				  -	      .byte	$C0+$6
     21  1a60					      ENDIF
     22  1a60				  -	      IF	$10 = $70
     23  1a60				  -	      .byte	$D0+$6
     24  1a60					      ENDIF
     25  1a60				  -	      IF	$10 = $80
     26  1a60				  -	      .byte	$B0+$6
     27  1a60					      ENDIF
     28  1a60				  -	      IF	$10 = $90
     29  1a60				  -	      .byte	$90+$6
     30  1a60					      ENDIF
     31  1a60				  -	      IF	$10 = $A0
     32  1a60				  -	      .byte	$70+$6
     33  1a60					      ENDIF
     34  1a60				  -	      IF	$10 = $B0
     35  1a60				  -	      .byte	$50+$6
     36  1a60					      ENDIF
     37  1a60				  -	      IF	$10 = $C0
     38  1a60				  -	      .byte	$30+$6
     39  1a60					      ENDIF
     40  1a60				  -	      IF	$10 = $D0
     41  1a60				  -	      .byte	$30+$6
     42  1a60					      ENDIF
     43  1a60				  -	      IF	$10 = $E0
     44  1a60				  -	      .byte	$20+$6
     45  1a60					      ENDIF
     46  1a60				  -	      IF	$10 = $F0
     47  1a60				  -	      .byte	$40+$6
     48  1a60					      ENDIF
    628  1a60							;    NTSCPAL $40,$A
    629  1a60							;    NTSCPAL $C0,$8
    630  1a60				   C3			;
      0  1a60					      NTSCPAL	$40,$8	;ok
      1  1a60		       48		      .byte.b	$40+$8
      0  1a61					      NTSC_TO_PAL	$40,$8
      1  1a61				  -	      IF	$40 = 0
      2  1a61				  -	      .byte	$40+$8
      3  1a61					      ENDIF
      4  1a61				  -	      IF	$40 = $10
      5  1a61				  -	      .byte	$20+$8
      6  1a61					      ENDIF
      7  1a61				  -	      IF	$40 = $20
      8  1a61				  -	      .byte	$40+$8
      9  1a61					      ENDIF
     10  1a61				  -	      IF	$40 = $30
     11  1a61				  -	      .byte	$40+$8
     12  1a61					      ENDIF
     13  1a61					      IF	$40 = $40
     14  1a61		       68		      .byte.b	$60+$8
     15  1a62					      ENDIF
     16  1a62				  -	      IF	$40 = $50
     17  1a62				  -	      .byte	$80+$8
     18  1a62					      ENDIF
     19  1a62				  -	      IF	$40 = $60
     20  1a62				  -	      .byte	$C0+$8
     21  1a62					      ENDIF
     22  1a62				  -	      IF	$40 = $70
     23  1a62				  -	      .byte	$D0+$8
     24  1a62					      ENDIF
     25  1a62				  -	      IF	$40 = $80
     26  1a62				  -	      .byte	$B0+$8
     27  1a62					      ENDIF
     28  1a62				  -	      IF	$40 = $90
     29  1a62				  -	      .byte	$90+$8
     30  1a62					      ENDIF
     31  1a62				  -	      IF	$40 = $A0
     32  1a62				  -	      .byte	$70+$8
     33  1a62					      ENDIF
     34  1a62				  -	      IF	$40 = $B0
     35  1a62				  -	      .byte	$50+$8
     36  1a62					      ENDIF
     37  1a62				  -	      IF	$40 = $C0
     38  1a62				  -	      .byte	$30+$8
     39  1a62					      ENDIF
     40  1a62				  -	      IF	$40 = $D0
     41  1a62				  -	      .byte	$30+$8
     42  1a62					      ENDIF
     43  1a62				  -	      IF	$40 = $E0
     44  1a62				  -	      .byte	$20+$8
     45  1a62					      ENDIF
     46  1a62				  -	      IF	$40 = $F0
     47  1a62				  -	      .byte	$40+$8
     48  1a62					      ENDIF
      0  1a62					      NTSCPAL	$90,$8	;ok
      1  1a62		       98		      .byte.b	$90+$8
      0  1a63					      NTSC_TO_PAL	$90,$8
      1  1a63				  -	      IF	$90 = 0
      2  1a63				  -	      .byte	$90+$8
      3  1a63					      ENDIF
      4  1a63				  -	      IF	$90 = $10
      5  1a63				  -	      .byte	$20+$8
      6  1a63					      ENDIF
      7  1a63				  -	      IF	$90 = $20
      8  1a63				  -	      .byte	$40+$8
      9  1a63					      ENDIF
     10  1a63				  -	      IF	$90 = $30
     11  1a63				  -	      .byte	$40+$8
     12  1a63					      ENDIF
     13  1a63				  -	      IF	$90 = $40
     14  1a63				  -	      .byte	$60+$8
     15  1a63					      ENDIF
     16  1a63				  -	      IF	$90 = $50
     17  1a63				  -	      .byte	$80+$8
     18  1a63					      ENDIF
     19  1a63				  -	      IF	$90 = $60
     20  1a63				  -	      .byte	$C0+$8
     21  1a63					      ENDIF
     22  1a63				  -	      IF	$90 = $70
     23  1a63				  -	      .byte	$D0+$8
     24  1a63					      ENDIF
     25  1a63				  -	      IF	$90 = $80
     26  1a63				  -	      .byte	$B0+$8
     27  1a63					      ENDIF
     28  1a63					      IF	$90 = $90
     29  1a63		       98		      .byte.b	$90+$8
     30  1a64					      ENDIF
     31  1a64				  -	      IF	$90 = $A0
     32  1a64				  -	      .byte	$70+$8
     33  1a64					      ENDIF
     34  1a64				  -	      IF	$90 = $B0
     35  1a64				  -	      .byte	$50+$8
     36  1a64					      ENDIF
     37  1a64				  -	      IF	$90 = $C0
     38  1a64				  -	      .byte	$30+$8
     39  1a64					      ENDIF
     40  1a64				  -	      IF	$90 = $D0
     41  1a64				  -	      .byte	$30+$8
     42  1a64					      ENDIF
     43  1a64				  -	      IF	$90 = $E0
     44  1a64				  -	      .byte	$20+$8
     45  1a64					      ENDIF
     46  1a64				  -	      IF	$90 = $F0
     47  1a64				  -	      .byte	$40+$8
     48  1a64					      ENDIF
      0  1a64					      NTSCPAL	$90,$8	;ok both
      1  1a64		       98		      .byte.b	$90+$8
      0  1a65					      NTSC_TO_PAL	$90,$8
      1  1a65				  -	      IF	$90 = 0
      2  1a65				  -	      .byte	$90+$8
      3  1a65					      ENDIF
      4  1a65				  -	      IF	$90 = $10
      5  1a65				  -	      .byte	$20+$8
      6  1a65					      ENDIF
      7  1a65				  -	      IF	$90 = $20
      8  1a65				  -	      .byte	$40+$8
      9  1a65					      ENDIF
     10  1a65				  -	      IF	$90 = $30
     11  1a65				  -	      .byte	$40+$8
     12  1a65					      ENDIF
     13  1a65				  -	      IF	$90 = $40
     14  1a65				  -	      .byte	$60+$8
     15  1a65					      ENDIF
     16  1a65				  -	      IF	$90 = $50
     17  1a65				  -	      .byte	$80+$8
     18  1a65					      ENDIF
     19  1a65				  -	      IF	$90 = $60
     20  1a65				  -	      .byte	$C0+$8
     21  1a65					      ENDIF
     22  1a65				  -	      IF	$90 = $70
     23  1a65				  -	      .byte	$D0+$8
     24  1a65					      ENDIF
     25  1a65				  -	      IF	$90 = $80
     26  1a65				  -	      .byte	$B0+$8
     27  1a65					      ENDIF
     28  1a65					      IF	$90 = $90
     29  1a65		       98		      .byte.b	$90+$8
     30  1a66					      ENDIF
     31  1a66				  -	      IF	$90 = $A0
     32  1a66				  -	      .byte	$70+$8
     33  1a66					      ENDIF
     34  1a66				  -	      IF	$90 = $B0
     35  1a66				  -	      .byte	$50+$8
     36  1a66					      ENDIF
     37  1a66				  -	      IF	$90 = $C0
     38  1a66				  -	      .byte	$30+$8
     39  1a66					      ENDIF
     40  1a66				  -	      IF	$90 = $D0
     41  1a66				  -	      .byte	$30+$8
     42  1a66					      ENDIF
     43  1a66				  -	      IF	$90 = $E0
     44  1a66				  -	      .byte	$20+$8
     45  1a66					      ENDIF
     46  1a66				  -	      IF	$90 = $F0
     47  1a66				  -	      .byte	$40+$8
     48  1a66					      ENDIF
      0  1a66					      NTSCPAL	$70,$8	;ok both
      1  1a66		       78		      .byte.b	$70+$8
      0  1a67					      NTSC_TO_PAL	$70,$8
      1  1a67				  -	      IF	$70 = 0
      2  1a67				  -	      .byte	$70+$8
      3  1a67					      ENDIF
      4  1a67				  -	      IF	$70 = $10
      5  1a67				  -	      .byte	$20+$8
      6  1a67					      ENDIF
      7  1a67				  -	      IF	$70 = $20
      8  1a67				  -	      .byte	$40+$8
      9  1a67					      ENDIF
     10  1a67				  -	      IF	$70 = $30
     11  1a67				  -	      .byte	$40+$8
     12  1a67					      ENDIF
     13  1a67				  -	      IF	$70 = $40
     14  1a67				  -	      .byte	$60+$8
     15  1a67					      ENDIF
     16  1a67				  -	      IF	$70 = $50
     17  1a67				  -	      .byte	$80+$8
     18  1a67					      ENDIF
     19  1a67				  -	      IF	$70 = $60
     20  1a67				  -	      .byte	$C0+$8
     21  1a67					      ENDIF
     22  1a67					      IF	$70 = $70
     23  1a67		       d8		      .byte.b	$D0+$8
     24  1a68					      ENDIF
     25  1a68				  -	      IF	$70 = $80
     26  1a68				  -	      .byte	$B0+$8
     27  1a68					      ENDIF
     28  1a68				  -	      IF	$70 = $90
     29  1a68				  -	      .byte	$90+$8
     30  1a68					      ENDIF
     31  1a68				  -	      IF	$70 = $A0
     32  1a68				  -	      .byte	$70+$8
     33  1a68					      ENDIF
     34  1a68				  -	      IF	$70 = $B0
     35  1a68				  -	      .byte	$50+$8
     36  1a68					      ENDIF
     37  1a68				  -	      IF	$70 = $C0
     38  1a68				  -	      .byte	$30+$8
     39  1a68					      ENDIF
     40  1a68				  -	      IF	$70 = $D0
     41  1a68				  -	      .byte	$30+$8
     42  1a68					      ENDIF
     43  1a68				  -	      IF	$70 = $E0
     44  1a68				  -	      .byte	$20+$8
     45  1a68					      ENDIF
     46  1a68				  -	      IF	$70 = $F0
     47  1a68				  -	      .byte	$40+$8
     48  1a68					      ENDIF
      0  1a68					      NTSCPAL	$B0,$8
      1  1a68		       b8		      .byte.b	$B0+$8
      0  1a69					      NTSC_TO_PAL	$B0,$8
      1  1a69				  -	      IF	$B0 = 0
      2  1a69				  -	      .byte	$B0+$8
      3  1a69					      ENDIF
      4  1a69				  -	      IF	$B0 = $10
      5  1a69				  -	      .byte	$20+$8
      6  1a69					      ENDIF
      7  1a69				  -	      IF	$B0 = $20
      8  1a69				  -	      .byte	$40+$8
      9  1a69					      ENDIF
     10  1a69				  -	      IF	$B0 = $30
     11  1a69				  -	      .byte	$40+$8
     12  1a69					      ENDIF
     13  1a69				  -	      IF	$B0 = $40
     14  1a69				  -	      .byte	$60+$8
     15  1a69					      ENDIF
     16  1a69				  -	      IF	$B0 = $50
     17  1a69				  -	      .byte	$80+$8
     18  1a69					      ENDIF
     19  1a69				  -	      IF	$B0 = $60
     20  1a69				  -	      .byte	$C0+$8
     21  1a69					      ENDIF
     22  1a69				  -	      IF	$B0 = $70
     23  1a69				  -	      .byte	$D0+$8
     24  1a69					      ENDIF
     25  1a69				  -	      IF	$B0 = $80
     26  1a69				  -	      .byte	$B0+$8
     27  1a69					      ENDIF
     28  1a69				  -	      IF	$B0 = $90
     29  1a69				  -	      .byte	$90+$8
     30  1a69					      ENDIF
     31  1a69				  -	      IF	$B0 = $A0
     32  1a69				  -	      .byte	$70+$8
     33  1a69					      ENDIF
     34  1a69					      IF	$B0 = $B0
     35  1a69		       58		      .byte.b	$50+$8
     36  1a6a					      ENDIF
     37  1a6a				  -	      IF	$B0 = $C0
     38  1a6a				  -	      .byte	$30+$8
     39  1a6a					      ENDIF
     40  1a6a				  -	      IF	$B0 = $D0
     41  1a6a				  -	      .byte	$30+$8
     42  1a6a					      ENDIF
     43  1a6a				  -	      IF	$B0 = $E0
     44  1a6a				  -	      .byte	$20+$8
     45  1a6a					      ENDIF
     46  1a6a				  -	      IF	$B0 = $F0
     47  1a6a				  -	      .byte	$40+$8
     48  1a6a					      ENDIF
      0  1a6a					      NTSCPAL	$20,$8
      1  1a6a		       28		      .byte.b	$20+$8
      0  1a6b					      NTSC_TO_PAL	$20,$8
      1  1a6b				  -	      IF	$20 = 0
      2  1a6b				  -	      .byte	$20+$8
      3  1a6b					      ENDIF
      4  1a6b				  -	      IF	$20 = $10
      5  1a6b				  -	      .byte	$20+$8
      6  1a6b					      ENDIF
      7  1a6b					      IF	$20 = $20
      8  1a6b		       48		      .byte.b	$40+$8
      9  1a6c					      ENDIF
     10  1a6c				  -	      IF	$20 = $30
     11  1a6c				  -	      .byte	$40+$8
     12  1a6c					      ENDIF
     13  1a6c				  -	      IF	$20 = $40
     14  1a6c				  -	      .byte	$60+$8
     15  1a6c					      ENDIF
     16  1a6c				  -	      IF	$20 = $50
     17  1a6c				  -	      .byte	$80+$8
     18  1a6c					      ENDIF
     19  1a6c				  -	      IF	$20 = $60
     20  1a6c				  -	      .byte	$C0+$8
     21  1a6c					      ENDIF
     22  1a6c				  -	      IF	$20 = $70
     23  1a6c				  -	      .byte	$D0+$8
     24  1a6c					      ENDIF
     25  1a6c				  -	      IF	$20 = $80
     26  1a6c				  -	      .byte	$B0+$8
     27  1a6c					      ENDIF
     28  1a6c				  -	      IF	$20 = $90
     29  1a6c				  -	      .byte	$90+$8
     30  1a6c					      ENDIF
     31  1a6c				  -	      IF	$20 = $A0
     32  1a6c				  -	      .byte	$70+$8
     33  1a6c					      ENDIF
     34  1a6c				  -	      IF	$20 = $B0
     35  1a6c				  -	      .byte	$50+$8
     36  1a6c					      ENDIF
     37  1a6c				  -	      IF	$20 = $C0
     38  1a6c				  -	      .byte	$30+$8
     39  1a6c					      ENDIF
     40  1a6c				  -	      IF	$20 = $D0
     41  1a6c				  -	      .byte	$30+$8
     42  1a6c					      ENDIF
     43  1a6c				  -	      IF	$20 = $E0
     44  1a6c				  -	      .byte	$20+$8
     45  1a6c					      ENDIF
     46  1a6c				  -	      IF	$20 = $F0
     47  1a6c				  -	      .byte	$40+$8
     48  1a6c					      ENDIF
      0  1a6c					      NTSCPAL	$60,$8	; lovely
      1  1a6c		       68		      .byte.b	$60+$8
      0  1a6d					      NTSC_TO_PAL	$60,$8
      1  1a6d				  -	      IF	$60 = 0
      2  1a6d				  -	      .byte	$60+$8
      3  1a6d					      ENDIF
      4  1a6d				  -	      IF	$60 = $10
      5  1a6d				  -	      .byte	$20+$8
      6  1a6d					      ENDIF
      7  1a6d				  -	      IF	$60 = $20
      8  1a6d				  -	      .byte	$40+$8
      9  1a6d					      ENDIF
     10  1a6d				  -	      IF	$60 = $30
     11  1a6d				  -	      .byte	$40+$8
     12  1a6d					      ENDIF
     13  1a6d				  -	      IF	$60 = $40
     14  1a6d				  -	      .byte	$60+$8
     15  1a6d					      ENDIF
     16  1a6d				  -	      IF	$60 = $50
     17  1a6d				  -	      .byte	$80+$8
     18  1a6d					      ENDIF
     19  1a6d					      IF	$60 = $60
     20  1a6d		       c8		      .byte.b	$C0+$8
     21  1a6e					      ENDIF
     22  1a6e				  -	      IF	$60 = $70
     23  1a6e				  -	      .byte	$D0+$8
     24  1a6e					      ENDIF
     25  1a6e				  -	      IF	$60 = $80
     26  1a6e				  -	      .byte	$B0+$8
     27  1a6e					      ENDIF
     28  1a6e				  -	      IF	$60 = $90
     29  1a6e				  -	      .byte	$90+$8
     30  1a6e					      ENDIF
     31  1a6e				  -	      IF	$60 = $A0
     32  1a6e				  -	      .byte	$70+$8
     33  1a6e					      ENDIF
     34  1a6e				  -	      IF	$60 = $B0
     35  1a6e				  -	      .byte	$50+$8
     36  1a6e					      ENDIF
     37  1a6e				  -	      IF	$60 = $C0
     38  1a6e				  -	      .byte	$30+$8
     39  1a6e					      ENDIF
     40  1a6e				  -	      IF	$60 = $D0
     41  1a6e				  -	      .byte	$30+$8
     42  1a6e					      ENDIF
     43  1a6e				  -	      IF	$60 = $E0
     44  1a6e				  -	      .byte	$20+$8
     45  1a6e					      ENDIF
     46  1a6e				  -	      IF	$60 = $F0
     47  1a6e				  -	      .byte	$40+$8
     48  1a6e					      ENDIF
      0  1a6e					      NTSCPAL	$C0,$8
      1  1a6e		       c8		      .byte.b	$C0+$8
      0  1a6f					      NTSC_TO_PAL	$C0,$8
      1  1a6f				  -	      IF	$C0 = 0
      2  1a6f				  -	      .byte	$C0+$8
      3  1a6f					      ENDIF
      4  1a6f				  -	      IF	$C0 = $10
      5  1a6f				  -	      .byte	$20+$8
      6  1a6f					      ENDIF
      7  1a6f				  -	      IF	$C0 = $20
      8  1a6f				  -	      .byte	$40+$8
      9  1a6f					      ENDIF
     10  1a6f				  -	      IF	$C0 = $30
     11  1a6f				  -	      .byte	$40+$8
     12  1a6f					      ENDIF
     13  1a6f				  -	      IF	$C0 = $40
     14  1a6f				  -	      .byte	$60+$8
     15  1a6f					      ENDIF
     16  1a6f				  -	      IF	$C0 = $50
     17  1a6f				  -	      .byte	$80+$8
     18  1a6f					      ENDIF
     19  1a6f				  -	      IF	$C0 = $60
     20  1a6f				  -	      .byte	$C0+$8
     21  1a6f					      ENDIF
     22  1a6f				  -	      IF	$C0 = $70
     23  1a6f				  -	      .byte	$D0+$8
     24  1a6f					      ENDIF
     25  1a6f				  -	      IF	$C0 = $80
     26  1a6f				  -	      .byte	$B0+$8
     27  1a6f					      ENDIF
     28  1a6f				  -	      IF	$C0 = $90
     29  1a6f				  -	      .byte	$90+$8
     30  1a6f					      ENDIF
     31  1a6f				  -	      IF	$C0 = $A0
     32  1a6f				  -	      .byte	$70+$8
     33  1a6f					      ENDIF
     34  1a6f				  -	      IF	$C0 = $B0
     35  1a6f				  -	      .byte	$50+$8
     36  1a6f					      ENDIF
     37  1a6f					      IF	$C0 = $C0
     38  1a6f		       38		      .byte.b	$30+$8
     39  1a70					      ENDIF
     40  1a70				  -	      IF	$C0 = $D0
     41  1a70				  -	      .byte	$30+$8
     42  1a70					      ENDIF
     43  1a70				  -	      IF	$C0 = $E0
     44  1a70				  -	      .byte	$20+$8
     45  1a70					      ENDIF
     46  1a70				  -	      IF	$C0 = $F0
     47  1a70				  -	      .byte	$40+$8
     48  1a70					      ENDIF
    639  1a70							;    NTSCPAL $40,$A
    640  1a70							;    NTSCPAL $C0,$8
    641  1a70
    642  1a70
    643  1a70							;good...
    644  1a70							;walls
    645  1a70							; C6/36/16
    646  1a70							; 4a/a4/7a
    647  1a70							;bricks
    648  1a70							; 44/28/C6
    649  1a70
    650  1a70
      0  1a70					      DEFINE_SUBROUTINE	UnpackLevel
      1  1a70		       00 03	   BANK_UnpackLevel =	_CURRENT_BANK
      2  1a70					      SUBROUTINE
      3  1a70				   UnpackLevel
    652  1a70
    653  1a70		       85 c0		      sta	RAM_Bank
    654  1a72
    655  1a72							; has to be done before decoding the level to have the platform right:
    656  1a72							;	    SET_PLATFORM
    657  1a72
    658  1a72		       a9 01		      lda	#CHARACTER_SOIL
    659  1a74		       85 8b		      sta	POS_Type
    660  1a76
    661  1a76		       a9 15		      lda	#SIZE_BOARD_Y-1
    662  1a78		       85 88		      sta	POS_Y
    663  1a7a		       a9 27	   xyLine     lda	#SIZE_BOARD_X-1
    664  1a7c		       85 87		      sta	POS_X
    665  1a7e		       20 3a f8    xyClear    jsr	PutBoardCharacterFromRAM
    666  1a81		       c6 87		      dec	POS_X
    667  1a83		       10 f9		      bpl	xyClear
    668  1a85		       c6 88		      dec	POS_Y
    669  1a87		       10 f1		      bpl	xyLine
    670  1a89
    671  1a89		       a9 0c		      lda	#12	;todo - crashes @12 ... why?
    672  1a8b		       85 d2		      sta	base_x
    673  1a8d		       a9 06		      lda	#6
    674  1a8f		       85 d3		      sta	base_y
    675  1a91
    676  1a91		       a5 c2		      lda	NextLevelTrigger
    677  1a93		       09 80		      ora	#BIT_NEXTLEVEL
    678  1a95		       85 c2		      sta	NextLevelTrigger
    679  1a97
    680  1a97		       a6 b2		      ldx	levelX
    681  1a99		       bd 00 f0 	      lda	LevelInfoLO,x
    682  1a9c		       85 bb		      sta	Board_AddressR
    683  1a9e		       bd 99 f0 	      lda	LevelInfoHI,x
    684  1aa1		       85 bc		      sta	Board_AddressR+1
    685  1aa3		       bd 32 f1 	      lda	LevelInfoBANK,x
    686  1aa6		       85 ab		      sta	LEVEL_bank
    687  1aa8
    688  1aa8		       a9 03		      lda	#BANK_UnpackLevel	; the *ROM* bank of this routine (NOT RAM)
    689  1aaa		       85 bf		      sta	ROM_Bank	; GetROMByte returns to this bank
    690  1aac
    691  1aac		       a5 b2		      lda	levelX
    692  1aae		       29 07		      and	#7
    693  1ab0		       0a		      asl
    694  1ab1		       0a		      asl
    695  1ab2		       05 80		      ora	Platform	; NTSC/PAL
    696  1ab4		       4a		      lsr
    697  1ab5		       aa		      tax
    698  1ab6
    699  1ab6		       bd 40 f2 	      lda	C1,x
    700  1ab9		       85 d7		      sta	icc_colour
    701  1abb		       bd 50 f2 	      lda	C2,x
    702  1abe		       85 d8		      sta	icc_colour+1
    703  1ac0		       bd 60 f2 	      lda	C3,x
    704  1ac3		       85 d9		      sta	icc_colour+2
    705  1ac5
    706  1ac5							; Update the level colours (self-modifying) in each of the character line banks
    707  1ac5
    708  1ac5		       a2 07		      ldx	#SCREEN_LINES-1
    709  1ac7				   setPlat
    710  1ac7		       a5 d7		      lda	icc_colour
    711  1ac9		       a0 53		      ldy	#<SELFMOD_BLUE+1
    712  1acb		       20 1d f8 	      jsr	PutBoardCharacter
    713  1ace
    714  1ace		       a5 d8		      lda	icc_colour+1
    715  1ad0		       a0 86		      ldy	#<SELFMOD_GREEN+1
    716  1ad2		       20 1d f8 	      jsr	PutBoardCharacter
    717  1ad5
    718  1ad5		       a5 d9		      lda	icc_colour+2
    719  1ad7		       a0 1d		      ldy	#<SELFMOD_RED+1
    720  1ad9		       20 1d f8 	      jsr	PutBoardCharacter
    721  1adc
    722  1adc		       ca		      dex
    723  1add		       10 e8		      bpl	setPlat
    724  1adf
    725  1adf
    726  1adf		       a9 00		      lda	#$00
    727  1ae1		       85 b6		      sta	BCD_moveCounter
    728  1ae3		       85 b7		      sta	BCD_moveCounterHi
    729  1ae5		       85 b8		      sta	takebackIndex
    730  1ae7		       85 b9		      sta	takebackBaseIndex
    731  1ae9
    732  1ae9		       a9 00		      lda	#$00	; BCD reminder!
    733  1aeb		       85 b5		      sta	BCD_targetsRequired	; # of targets that do NOT have boxes on them
    734  1aed
    735  1aed							;		ldx Platform
    736  1aed							;		lda theThrottler,x
    737  1aed							;		sta ThrottleSpeed
    738  1aed
    739  1aed							; first fill bg with character_soil
    740  1aed							; then rle unpack level
    741  1aed							; change level colours
    742  1aed
    743  1aed		       a9 00		      lda	#0
    744  1aef		       85 87		      sta	POS_X
    745  1af1		       85 88		      sta	POS_Y
    746  1af3		       85 94		      sta	BoardLimit_Width
    747  1af5		       85 95		      sta	BoardLimit_Height
    748  1af7
    749  1af7				   GetNextItem
    750  1af7
    751  1af7		       a9 01		      lda	#1
    752  1af9		       85 d4		      sta	upk_length
    753  1afb		       a9 00		      lda	#0
    754  1afd		       85 d5		      sta	upk_column	; reuse var - this flags a digit already
    755  1aff
    756  1aff		       e6 bb	   Get2       inc	Board_AddressR
    757  1b01		       d0 02		      bne	addrOK
    758  1b03		       e6 bc		      inc	Board_AddressR+1
    759  1b05				   addrOK
    760  1b05
    761  1b05		       a5 ab		      lda	LEVEL_bank
    762  1b07		       a0 00		      ldy	#0
    763  1b09		       20 0f f8 	      jsr	GetROMByte
    764  1b0c		       85 d6		      sta	upk_temp	;scratch
    765  1b0e
    766  1b0e
    767  1b0e		       c9 00		      cmp	#0
    768  1b10		       d0 03		      bne	parse
    769  1b12		       4c cb f1 	      jmp	finX
    770  1b15				   parse
    771  1b15		       c9 3a		      cmp	#"9"+1
    772  1b17		       b0 1e		      bcs	notDigit
    773  1b19		       c9 30		      cmp	#"0"
    774  1b1b		       90 1a		      bcc	notDigit
    775  1b1d
    776  1b1d		       a5 d5		      lda	upk_column
    777  1b1f		       f0 09		      beq	firstDig
    778  1b21
    779  1b21		       a5 d4		      lda	upk_length
    780  1b23		       0a		      asl
    781  1b24		       0a		      asl
    782  1b25		       0a		      asl
    783  1b26		       65 d4		      adc	upk_length
    784  1b28		       65 d4		      adc	upk_length
    785  1b2a
    786  1b2a		       18	   firstDig   clc
    787  1b2b		       65 d6		      adc	upk_temp
    788  1b2d		       38		      sec
    789  1b2e		       e9 30		      sbc	#"0"
    790  1b30		       85 d4		      sta	upk_length
    791  1b32		       e6 d5		      inc	upk_column	; flag we have seen a digit
    792  1b34		       4c ff f2 	      jmp	Get2
    793  1b37
    794  1b37		       c9 7c	   notDigit   cmp	#"|"	; newline
    795  1b39		       d0 11		      bne	checkWall
    796  1b3b
    797  1b3b							; Handle new-line
    798  1b3b		       a9 00		      lda	#0
    799  1b3d		       85 87		      sta	POS_X
    800  1b3f		       e6 88		      inc	POS_Y
    801  1b41
    802  1b41
    803  1b41		       a5 88		      lda	POS_Y
    804  1b43		       c5 95		      cmp	BoardLimit_Height
    805  1b45		       90 02		      bcc	wOK2
    806  1b47		       85 95		      sta	BoardLimit_Height	;???^^^
    807  1b49				   wOK2
    808  1b49
    809  1b49		       4c f7 f2 	      jmp	GetNextItem
    810  1b4c
    811  1b4c		       c9 23	   checkWall  cmp	#"#"	; wall
    812  1b4e		       d0 09		      bne	checkForGap
    813  1b50		       a5 b2		      lda	levelX
    814  1b52		       29 01		      and	#1
    815  1b54		       18		      clc
    816  1b55		       69 06		      adc	#CHARACTER_STEEL
    817  1b57		       d0 62		      bne	WriteChars
    818  1b59
    819  1b59		       c9 20	   checkForGap cmp	#32
    820  1b5b		       f0 08		      beq	writeGap
    821  1b5d		       c9 2d		      cmp	#"-"
    822  1b5f		       f0 04		      beq	writeGap
    823  1b61		       c9 5f		      cmp	#"_"
    824  1b63		       d0 05		      bne	checkForMan
    825  1b65
    826  1b65		       a9 00	   writeGap   lda	#CHARACTER_BLANK
    827  1b67		       4c bb f3 	      jmp	WriteChars
    828  1b6a
    829  1b6a				   checkForMan
    830  1b6a		       c9 2b		      cmp	#"+"	; player on goal square
    831  1b6c		       d0 07		      bne	notPlayerGoal
    832  1b6e
    833  1b6e		       20 ed fc 	      jsr	RegisterTarget
    834  1b71
    835  1b71							; put goal square, init player with POS_VAR = CHARACTER_TARGET
    836  1b71
    837  1b71		       a9 03		      lda	#CHARACTER_TARGET
    838  1b73		       d0 06		      bne	genPlayer
    839  1b75
    840  1b75				   notPlayerGoal
    841  1b75		       c9 40		      cmp	#"@"	; player on normal square
    842  1b77		       d0 29		      bne	checkBox
    843  1b79
    844  1b79		       a9 00		      lda	#CHARACTER_BLANK
    845  1b7b
    846  1b7b				   genPlayer
    847  1b7b
    848  1b7b		       85 8c		      sta	POS_VAR	; character man is on
    849  1b7d
    850  1b7d		       18		      clc
    851  1b7e		       a5 87		      lda	POS_X
    852  1b80		       48		      pha
    853  1b81		       65 d2		      adc	base_x
    854  1b83		       85 87		      sta	POS_X
    855  1b85		       85 9d		      sta	ManX
    856  1b87
    857  1b87		       a5 88		      lda	POS_Y
    858  1b89		       48		      pha
    859  1b8a		       65 d3		      adc	base_y
    860  1b8c		       85 88		      sta	POS_Y
    861  1b8e		       85 9e		      sta	ManY
    862  1b90
    863  1b90							; POS_X     x position
    864  1b90							; POS_Y     y position
    865  1b90							; POS_VAR   CHARACTER UNDER MAN TO RESTORE
    866  1b90							; POS_Type  type of object
    867  1b90
    868  1b90		       a9 00		      lda	#TYPE_MAN
    869  1b92		       85 8b		      sta	POS_Type	;	 creature TYPE
    870  1b94		       20 fb f8 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    871  1b97
    872  1b97		       68		      pla
    873  1b98		       85 88		      sta	POS_Y
    874  1b9a		       68		      pla
    875  1b9b		       85 87		      sta	POS_X
    876  1b9d
    877  1b9d		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    878  1b9f		       4c bb f3 	      jmp	WriteChars
    879  1ba2
    880  1ba2		       c9 24	   checkBox   cmp	#"$"
    881  1ba4		       d0 04		      bne	checkBoxTarget
    882  1ba6
    883  1ba6		       a9 02		      lda	#CHARACTER_BOX
    884  1ba8		       d0 11		      bne	WriteChars
    885  1baa
    886  1baa		       c9 2a	   checkBoxTarget cmp	#"*"
    887  1bac		       d0 04		      bne	checkTarget
    888  1bae
    889  1bae		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    890  1bb0		       d0 09		      bne	WriteChars
    891  1bb2
    892  1bb2		       c9 2e	   checkTarget cmp	#"."
    893  1bb4		       f0 03		      beq	targ
    894  1bb6		       4c f7 f2 	      jmp	GetNextItem
    895  1bb9				   targ
    896  1bb9
    897  1bb9		       a9 03		      lda	#CHARACTER_TARGET
    898  1bbb
    899  1bbb		       85 8b	   WriteChars sta	POS_Type
    900  1bbd
    901  1bbd		       18	   Wc2x       clc
    902  1bbe		       a5 87		      lda	POS_X
    903  1bc0		       48		      pha
    904  1bc1		       65 d2		      adc	base_x
    905  1bc3		       85 87		      sta	POS_X
    906  1bc5
    907  1bc5		       a5 88		      lda	POS_Y
    908  1bc7		       48		      pha
    909  1bc8		       65 d3		      adc	base_y
    910  1bca		       85 88		      sta	POS_Y
    911  1bcc
    912  1bcc		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    913  1bcf
    914  1bcf		       a5 8b		      lda	POS_Type
    915  1bd1		       c9 03		      cmp	#CHARACTER_TARGET
    916  1bd3		       d0 03		      bne	notargdet
    917  1bd5		       20 ed fc 	      jsr	RegisterTarget
    918  1bd8				   notargdet
    919  1bd8
    920  1bd8		       68		      pla
    921  1bd9		       85 88		      sta	POS_Y
    922  1bdb		       68		      pla
    923  1bdc		       85 87		      sta	POS_X
    924  1bde
    925  1bde		       18		      clc
    926  1bdf		       69 01		      adc	#1
    927  1be1		       85 87		      sta	POS_X
    928  1be3
    929  1be3		       c5 94		      cmp	BoardLimit_Width
    930  1be5		       90 02		      bcc	wOK
    931  1be7		       85 94		      sta	BoardLimit_Width
    932  1be9				   wOK
    933  1be9
    934  1be9		       c6 d4		      dec	upk_length
    935  1beb		       d0 d0		      bne	Wc2x
    936  1bed		       4c f7 f2 	      jmp	GetNextItem
    937  1bf0
    938  1bf0				   finishedUnpack
    939  1bf0
    940  1bf0		       60		      rts
    941  1bf0					      endif
------- FILE BANK_GENERIC.asm
     44  1bf1
      0  1bf1					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_LEVEL)"
      1  1bf1
      2  1bf1
      3  1bf1		       03 f1	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_LEVEL) (1K) SIZE =  $3f1 , FREE= $f
      4  1bf1					      ECHO	"GENERIC_BANK_1 (DECODE_LEVEL)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1bf1				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1bf1				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1bf1				  -	      ERR
      8  1bf1					      endif
     46  1bf1
     47  1bf1							;------------------------------------------------------------------------------
     48  1bf1							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     49  1bf1							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     50  1bf1							; bank finishes.  Just continue on from where it left off...
     51  1bf1							;------------------------------------------------------------------------------
     52  1bf1
      0  1bf1					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  1bf1		       00 03	   BANK_Cart_Init =	_CURRENT_BANK
      2  1bf1					      SUBROUTINE
      3  1bf1				   Cart_Init
     54  1bf1
     55  1bf1							; Note the variables from the title selection are incredibly transient an can be stomped
     56  1bf1							; at any time.  So they need to be used immediately.
     57  1bf1
     58  1bf1
     59  1bf1							; odd usage below is to prevent any possibility of variable stomping/assumptions
     60  1bf1
     61  1bf1		       a9 01		      lda	#1
     62  1bf3		       a2 00		      ldx	#0	;sLevel				      ; level # from title select
     63  1bf5		       a0 00		      ldy	#0	;sJoysticks
     64  1bf7		       84 aa		      sty	jtoggle
     65  1bf9		       86 b3		      stx	level
     66  1bfb		       a9 00		      lda	#0
     67  1bfd							;sta levelX					    ; make an immediate copy to safe variables!
     68  1bfd		       85 d8		      sta	startingLevel
     69  1bff
     70  1bff							; multiply with LEVEL_DEFINITION_SIZE (5):
     71  1bff		       0a		      asl
     72  1c00		       0a		      asl
     73  1c01		       85 b2		      sta	levelX
     74  1c03
      0  1c03					      LOAD_ANIMATION	IDLE
      1  1c03		       a9 3e		      lda	#<Animation_IDLE
      2  1c05		       85 9a		      sta	animation
      3  1c07		       a9 f0		      lda	#>Animation_IDLE
      4  1c09		       85 9b		      sta	animation+1
      5  1c0b		       a9 00		      lda	#0
      6  1c0d		       85 9c		      sta	animation_delay
      7  1c0f		       a9 02		      lda	#ANIMATION_IDLE_ID
      8  1c11		       85 a6		      sta	ManAnimationID
      9  1c13
     76  1c13
     77  1c13		       a9 00		      lda	#0
     78  1c15		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     79  1c18		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     80  1c1b		       85 6b		      sta	HMCLR
     81  1c1d
     82  1c1d							; cleanup remains of title screen
     83  1c1d		       85 5b		      sta	GRP0
     84  1c1f		       85 5c		      sta	GRP1
     85  1c21							;?		   sta GRP0
     86  1c21
     87  1c21		       a9 10		      lda	#%00010000	; 2	 double width missile, double width player
     88  1c23		       85 44		      sta	NUSIZ0	; 3
     89  1c25		       85 45		      sta	NUSIZ1
     90  1c27
     91  1c27		       85 86		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     92  1c29		       85 c5		      sta	ethnic
     93  1c2b
     94  1c2b		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     95  1c2d		       85 4a		      sta	CTRLPF
     96  1c2f
     97  1c2f		       a9 ff		      lda	#$FF
     98  1c31		       85 81		      sta	DrawStackPointer
     99  1c33		       85 92		      sta	BufferedJoystick
    100  1c35
    101  1c35							;lda #DIRECTION_BITS		  ;???
    102  1c35							;sta ManLastDirection
    103  1c35
    104  1c35							;lda #0
    105  1c35							;		  sta ObjStackPtr		  ; object stack index of last entry
    106  1c35							;		  sta ObjStackPtr+1
    107  1c35							;		  sta ObjStackNum
    108  1c35							;		  sta ObjIterator
    109  1c35
    110  1c35							;sta sortPtr
    111  1c35							;lda #<(-1)
    112  1c35							;sta sortRequired
    113  1c35
    114  1c35							; read high score from SaveKey and store in highScoreSK,
    115  1c35							; which is transferred to high score variable in RAM by GeneralScoringSetups
    116  1c35		       4c c2 f5 	      jmp	ReadSaveKey
    117  1c38
    118  1c38							;------------------------------------------------------------------------------
    119  1c38
      0  1c38					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  1c38		       00 03	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  1c38					      SUBROUTINE
      3  1c38				   SwapPlayersGeneric
    121  1c38
    122  1c38							; at the start of a level (or player, doesn't matter) we grab the current state of the colour/B&W switch
    123  1c38							; into the gameMode variable.
    124  1c38
    125  1c38							;		  lda gameMode
    126  1c38							;		  and #~(BW_SWITCH|GAMEMODE_PAUSED)
    127  1c38							;		  sta gameMode
    128  1c38							;		  lda SWCHB
    129  1c38							;		  and #BW_SWITCH
    130  1c38							;		  ora gameMode			  ; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    131  1c38							;		  sta gameMode			  ; also, BIT7=0 -- system is NOT paused
    132  1c38
    133  1c38
    134  1c38							; restart level
    135  1c38		       a5 c2		      lda	NextLevelTrigger
    136  1c3a		       29 bf		      and	#<(~BIT_NEXTLIFE)
    137  1c3c		       85 c2		      sta	NextLevelTrigger
    138  1c3e
    139  1c3e							; if new high score was set by SwapPlayers, update it:
    140  1c3e
    141  1c3e		       4c e8 f5 	      jmp	WriteSaveKey
    142  1c41
    143  1c41
    144  1c41							;------------------------------------------------------------------------------
    145  1c41
      0  1c41					      DEFINE_SUBROUTINE	CreateCreatures
      1  1c41		       00 03	   BANK_CreateCreatures =	_CURRENT_BANK
      2  1c41					      SUBROUTINE
      3  1c41				   CreateCreatures
    147  1c41
    148  1c41							; Calculate rightmost value for scrolling edge.  .
    149  1c41
    150  1c41		       85 bf		      sta	ROM_Bank
    151  1c43
    152  1c43		       38		      sec
    153  1c44		       a5 94		      lda	BoardLimit_Width
    154  1c46		       e9 09		      sbc	#SCREEN_WIDTH-1
    155  1c48		       85 94		      sta	BoardEdge_Right	; absolute rightmost scroll value
    156  1c4a
    157  1c4a							;		  sec			     already set
    158  1c4a		       a5 95		      lda	BoardLimit_Height
    159  1c4c		       e9 07		      sbc	#SCREEN_LINES-1
    160  1c4e		       85 95		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    161  1c50
    162  1c50							; kludge position scroll roughly at player
    163  1c50
    164  1c50							;		  sec			 already set
    165  1c50		       a5 9d		      lda	ManX
    166  1c52		       e9 05		      sbc	#5
    167  1c54		       b0 02		      bcs	notL0
    168  1c56		       a9 00		      lda	#0
    169  1c58		       85 97	   notL0      sta	BoardScrollX
    170  1c5a
    171  1c5a		       38		      sec
    172  1c5b		       a5 9e		      lda	ManY
    173  1c5d		       e9 04		      sbc	#4
    174  1c5f		       b0 02		      bcs	notU0
    175  1c61		       a9 00		      lda	#0
    176  1c63		       85 96	   notU0      sta	BoardScrollY
    177  1c65
    178  1c65		       a9 00		      lda	#0
    179  1c67		       85 a1		      sta	ManMode
    180  1c69							;sta ManDelayCount
    181  1c69		       85 ba		      sta	TakebackInhibit
    182  1c6b		       85 d2		      sta	base_x
    183  1c6d		       85 d3		      sta	base_y
    184  1c6f		       85 a4		      sta	ManPushCounter
    185  1c71
    186  1c71		       a9 ff		      lda	#$FF
    187  1c73		       85 af		      sta	LastSpriteY
    188  1c75		       85 a6		      sta	ManAnimationID
    189  1c77
    190  1c77							;lda #DIRECTION_BITS		  ;????
    191  1c77							;sta ManLastDirection		  ; duplicate?
    192  1c77
    193  1c77		       60		      rts
    194  1c78
    195  1c78							;-------------------------------------------------------------------------------------
    196  1c78
      0  1c78					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  1c78		       00 03	   BANK_LevelInit =	_CURRENT_BANK
      2  1c78					      SUBROUTINE
      3  1c78				   LevelInit
    198  1c78
    199  1c78		       a9 00		      lda	#0
    200  1c7a		       85 83		      sta	ObjStackPtr
    201  1c7c		       85 84		      sta	ObjStackPtr+1	; kill all creatures
    202  1c7e		       85 82		      sta	ObjStackNum
    203  1c80		       85 c3		      sta	ObjIterator
    204  1c82
    205  1c82		       85 98		      sta	scrollBits
    206  1c84		       85 86		      sta	ScreenDrawPhase
    207  1c86
    208  1c86		       85 b1		      sta	BGColour
    209  1c88		       85 c1		      sta	ColourTimer
    210  1c8a		       85 a5		      sta	LookingAround
    211  1c8c
    212  1c8c		       a9 ff		      lda	#255
    213  1c8e		       85 b4		      sta	Throttle
    214  1c90		       85 92		      sta	BufferedJoystick
    215  1c92
    216  1c92		       85 59		      sta	AUDV0
    217  1c94		       85 5a		      sta	AUDV1	; turn off music while levels init
    218  1c96							;		  sta AUDC0
    219  1c96
    220  1c96							;sta ManLastDirection
    221  1c96							;sta ManPushCounter
    222  1c96
    223  1c96							;sta sortPtr			  ; sort stopped
    224  1c96							;lda #<(-1)
    225  1c96							;sta sortRequired		  ; nothing needed
    226  1c96		       85 81		      sta	DrawStackPointer
    227  1c98
    228  1c98							;lda #DISPLAY_TIME ;DISPLAY_SCORE
    229  1c98							;sta scoringFlags
    230  1c98							;lda #0 ;SCORING_TIMER_FIRST		      ; We want the first timer display to be long, to show level and lives
    231  1c98							;sta scoringTimer
    232  1c98
    233  1c98		       18		      clc
    234  1c99		       a5 c5		      lda	ethnic
    235  1c9b		       69 10		      adc	#16
    236  1c9d		       c9 40		      cmp	#4*16
    237  1c9f		       90 02		      bcc	ethOK
    238  1ca1		       a9 00		      lda	#0
    239  1ca3		       85 c5	   ethOK      sta	ethnic
    240  1ca5
    241  1ca5		       60		      rts
    242  1ca6
    243  1ca6							;-------------------------------------------------------------------------------------
    244  1ca6
      0  1ca6					      DEFINE_SUBROUTINE	Resync
      1  1ca6		       00 03	   BANK_Resync =	_CURRENT_BANK
      2  1ca6					      SUBROUTINE
      3  1ca6				   Resync
      0  1ca6					      RESYNC
      1  1ca6
      2  1ca6		       a9 02		      lda	#%10
      3  1ca8		       85 41		      sta	VBLANK
      4  1caa
      5  1caa		       a2 08		      ldx	#8
      6  1cac				   .loopResync
      0  1cac					      VERTICAL_SYNC
      1  1cac		       a9 0e		      lda	#%1110
      2  1cae		       85 42	   .VSLP1     sta	WSYNC
      3  1cb0		       85 40		      sta	VSYNC
      4  1cb2		       4a		      lsr
      5  1cb3		       d0 f9		      bne	.VSLP1
      8  1cb5
      9  1cb5		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  1cb7		       a5 80		      lda	Platform
     11  1cb9		       49 02		      eor	#PAL_50
     12  1cbb		       d0 02		      bne	.ntsc
     13  1cbd		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  1cbf				   .ntsc
     15  1cbf				   .loopWait
     16  1cbf		       85 42		      sta	WSYNC
     17  1cc1		       85 42		      sta	WSYNC
     18  1cc3		       88		      dey
     19  1cc4		       d0 f9		      bne	.loopWait
     20  1cc6		       ca		      dex
     21  1cc7		       d0 e3		      bne	.loopResync
    247  1cc9		       60	   Ret	      rts
    248  1cca
    249  1cca							;---------------------------------------------------------------------------
    250  1cca
      0  1cca					      DEFINE_SUBROUTINE	TrackPlayer	; =76
      1  1cca		       00 03	   BANK_TrackPlayer =	_CURRENT_BANK
      2  1cca					      SUBROUTINE
      3  1cca				   TrackPlayer
    252  1cca
    253  1cca		       a5 a5		      lda	LookingAround	; 3
    254  1ccc		       d0 36		      bne	EarlyAbortx	; 2/3	     don't track when looking around
    255  1cce
    256  1cce		       00 02	   .SCRL_START_LEFT =	2
    257  1cce		       00 08	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT
    258  1cce		       00 02	   .SCRL_START_UP =	2
    259  1cce		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP
    260  1cce
    261  1cce		       a5 9d		      lda	ManX	; 3
    262  1cd0		       38		      sec		; 2
    263  1cd1		       e5 97		      sbc	BoardScrollX	; 3
    264  1cd3		       a8		      tay		; 2 = 10	  for later use
    265  1cd4
    266  1cd4		       a9 ff		      lda	#-1	; 2
    267  1cd6		       c0 02		      cpy	#.SCRL_START_LEFT	; 2
    268  1cd8		       30 06		      bmi	.startXScroll	; 2/3
    269  1cda		       c0 08		      cpy	#.SCRL_START_RIGHT	; 2
    270  1cdc		       30 0b		      bmi	.skipXScroll	; 2/3
    271  1cde		       a9 01		      lda	#1	; 2 = 12
    272  1ce0
    273  1ce0		       18	   .startXScroll clc		; 2
    274  1ce1		       65 97		      adc	BoardScrollX	; 3
    275  1ce3		       c5 94		      cmp	BoardEdge_Right	; 3
    276  1ce5		       b0 02		      bcs	.skipXScroll	; 2/3
    277  1ce7		       85 97		      sta	BoardScrollX	; 3 = 13
    278  1ce9
    279  1ce9				   .skipXScroll
    280  1ce9
    281  1ce9							; = 35 worst
    282  1ce9
    283  1ce9		       a5 9e		      lda	ManY	; 3
    284  1ceb		       38		      sec		; 2
    285  1cec		       e5 96		      sbc	BoardScrollY	; 3
    286  1cee		       a8		      tay		; 2 = 10	  for later use
    287  1cef
    288  1cef		       a9 ff		      lda	#-1	; 2
    289  1cf1		       c0 02		      cpy	#.SCRL_START_UP	; 2
    290  1cf3		       30 06		      bmi	.startYScroll	; 2/3
    291  1cf5		       c0 06		      cpy	#.SCRL_START_DOWN	; 2
    292  1cf7		       30 0b		      bmi	.skipYScroll	; 2/3
    293  1cf9		       a9 01		      lda	#1	; 2 = 12
    294  1cfb
    295  1cfb		       18	   .startYScroll clc		; 2
    296  1cfc		       65 96		      adc	BoardScrollY	; 3
    297  1cfe		       c5 95		      cmp	BoardEdge_Bottom	; 3
    298  1d00		       b0 02		      bcs	.skipYScroll	; 2/3
    299  1d02		       85 96		      sta	BoardScrollY	; 3 = 13
    300  1d04
    301  1d04				   .skipYScroll
    302  1d04
    303  1d04							; = 35 worst
    304  1d04
    305  1d04		       60	   EarlyAbortx rts		; 6 =	6
    306  1d05
    307  1d05
    308  1d05							;------------------------------------------------------------------------------
    309  1d05
    310  1d05							; This is a GOOD home for these tables.
    311  1d05
      0  1d05					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  1d05		       00 03	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  1d05					      SUBROUTINE
      3  1d05				   TS_PhaseVectorLO
    313  1d05
    314  1d05							; Gives LO byte of addresses of subroutines for timeslice processing
    315  1d05							; note +31✅ cycles at start of the function called
    316  1d05
    317  1d05		       58		      .byte.b	<ProcessObjStack	; abort = 46✅
    318  1d06		       ea		      .byte.b	<DrawFullScreen	; abort = 46✅
    319  1d07		       ac		      .byte.b	<BuildDrawStack	; abort = 54✅
    320  1d08		       b3		      .byte.b	<DrawAIntoStack	; abort = 54✅
    321  1d09		       91		      .byte.b	<SwitchObjects	; abort = 46✅
    322  1d0a
    323  1d0a				   TS_PhaseVectorHI
    324  1d0a
    325  1d0a							; Gives HI byte of addresses of subroutines for timeslice processing
    326  1d0a
    327  1d0a		       f8		      .byte.b	>ProcessObjStack
    328  1d0b		       f2		      .byte.b	>DrawFullScreen
    329  1d0c		       fb		      .byte.b	>BuildDrawStack
    330  1d0d		       fb		      .byte.b	>DrawAIntoStack
    331  1d0e		       f8		      .byte.b	>SwitchObjects
    332  1d0f
    333  1d0f				   TS_PhaseBank
    334  1d0f
    335  1d0f							; Gives bank of subroutines for timeslice processing
    336  1d0f
    337  1d0f		       0f		      .byte.b	BANK_ProcessObjStack
    338  1d10		       0d		      .byte.b	BANK_DrawFullScreen
    339  1d11		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    340  1d12		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    341  1d13		       0f		      .byte.b	BANK_SwitchObjects
    342  1d14
    343  1d14							;------------------------------------------------------------------------------
    344  1d14
    345  1d14				   OverscanTime
    346  1d14		       23 23		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    347  1d16		       29 23		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    348  1d18
    349  1d18
    350  1d18		       00 14	   THROT_BASE =	20
    351  1d18				   theThrottler
    352  1d18		       14 14 18 14	      .byte.b	THROT_BASE, THROT_BASE, THROT_BASE*60/50, THROT_BASE
    353  1d1c
      0  1d1c					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  1d1c		       00 03	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  1d1c					      SUBROUTINE
      3  1d1c				   PostScreenCleanup
    355  1d1c
    356  1d1c		       c8		      iny		; --> 0
    357  1d1d
    358  1d1d		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    359  1d1f							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    360  1d1f
    361  1d1f		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    362  1d21							; TJ: no idea why, but you had removed it in revision 758 ;)
    363  1d21							; completely accidental -- one of our cats may have deleted it.
    364  1d21		       84 4e		      sty	PF1
    365  1d23		       84 4f		      sty	PF2
    366  1d25		       84 5d		      sty	ENAM0
    367  1d27		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    368  1d29		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    369  1d2b
    370  1d2b							; D1 VBLANK turns off beam
    371  1d2b
    372  1d2b		       a9 42		      lda	#%01000010	; bit6 is not required
    373  1d2d		       85 41		      sta	VBLANK	; end of screen - enter blanking
    374  1d2f
    375  1d2f							;------------------------------------------------------------------------------
    376  1d2f							; This is where the PAL system has a bit of extra time on a per-frame basis.
    377  1d2f
    378  1d2f		       a6 80		      ldx	Platform
    379  1d31		       bd 14 f5 	      lda	OverscanTime,x
    380  1d34		       8d 96 02 	      sta	TIM64T
    381  1d37
    382  1d37							; Background colour priorities. Increasing order of priority...
    383  1d37							;	black -- nothing happening
    384  1d37							;	looking around			     lookingAround<0		     BLUE
    385  1d37							;	when paused			     gameMode... BIT7		     RED
    386  1d37							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    387  1d37
    388  1d37		       a6 80		      ldx	Platform
    389  1d39		       bd 18 f5 	      lda	theThrottler,x
    390  1d3c		       18		      clc
    391  1d3d		       65 b4		      adc	Throttle
    392  1d3f		       b0 02		      bcs	noVerflo
    393  1d41		       85 b4		      sta	Throttle
    394  1d43				   noVerflo
    395  1d43
    396  1d43							;----------------------------------------------------------------------------------------------
    397  1d43
    398  1d43							; has to be done AFTER screen display, because it disables the effect!
    399  1d43							;SLEEP 6
    400  1d43							;lda rnd		      ; 3     randomly reposition the Cosmic Ark missile
    401  1d43							;sta HMM0		      ; 3     this assumes that HMOVE is called at least once/frame
    402  1d43
    403  1d43							; "Flash" has highest BG colour priority
    404  1d43
    405  1d43		       a5 c1		      lda	ColourTimer
    406  1d45		       f0 08		      beq	noFlashBG
    407  1d47		       c6 c1		      dec	ColourTimer
    408  1d49		       d0 04		      bne	noFlashBG
    409  1d4b		       a9 00		      lda	#0
    410  1d4d		       85 b1		      sta	BGColour
    411  1d4f							;lda ColourFlash
    412  1d4f							;lda FlashColour,x
    413  1d4f				   noFlashBG
    414  1d4f							;	 sta BGColour
    415  1d4f
    416  1d4f							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    417  1d4f
    418  1d4f		       ad 80 02 	      lda	SWCHA
    419  1d52		       25 92		      and	BufferedJoystick
    420  1d54		       85 92		      sta	BufferedJoystick
    421  1d56
    422  1d56		       60		      rts
    423  1d57
    424  1d57							;------------------------------------------------------------------------------
    425  1d57
------- FILE i2c_v2.2.inc LEVEL 3 PASS 3
      0  1d57					      include	"i2c_v2.2.inc"
      1  1d57							;
      2  1d57							; i2c_v2.2.inc
      3  1d57							;
      4  1d57							;
      5  1d57							; AtariVox EEPROM Driver
      6  1d57							;
      7  1d57							; By Alex Herbert, 2004
      8  1d57							;
      9  1d57							; Optimisations by Thomas Jentzsch, 2006/2008
     10  1d57							;
     11  1d57
     12  1d57
     13  1d57							; I/O Constants
     14  1d57
     15  1d57		       00 04	   I2C_SDA_MASK equ	$04
     16  1d57		       00 08	   I2C_SCL_MASK equ	$08
     17  1d57
     18  1d57
     19  1d57							; Signalling Macros
     20  1d57
     21  1d57							;  MAC     I2C_SCL_0
     22  1d57							;    lda     #$00
     23  1d57							;    sta     SWCHA
     24  1d57							;  ENDM
     25  1d57
     26  1d57							;  MAC     I2C_SCL_1
     27  1d57							;    lda     #I2C_SCL_MASK
     28  1d57							;    sta     SWCHA
     29  1d57							;  ENDM
     30  1d57
     31  1d57							;  MAC     I2C_SDA_IN
     32  1d57							;    lda     #I2C_SCL_MASK
     33  1d57							;    sta     SWACNT
     34  1d57							;  ENDM
     35  1d57
     36  1d57							;  MAC     I2C_SDA_OUT
     37  1d57							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  1d57							;    sta     SWACNT
     39  1d57							;  ENDM
     40  1d57
     41  1d57
     42  1d57					      MAC	i2c_start
     43  1d57							; I2C_SCL_1
     44  1d57					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  1d57					      sta	SWCHA	; 4
     46  1d57							; I2C_SDA_OUT
     47  1d57					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  1d57					      sta	SWACNT	; 4
     49  1d57							; total: 12 cycles
     50  1d57					      ENDM
     51  1d57
     52  1d57
     53  1d57					      MAC	i2c_txbit
     54  1d57							; I2C_SCL_0
     55  1d57					      lda	#%0011	; 2
     56  1d57					      sta	SWCHA	; 4
     57  1d57							; set bit
     58  1d57					      adc	#%1000	; 2
     59  1d57					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  1d57							; I2C_SCL_1
     61  1d57					      lda	#I2C_SCL_MASK	; 2
     62  1d57					      sta	SWCHA	; 4
     63  1d57							; total: 18 cycles
     64  1d57					      ENDM
     65  1d57
     66  1d57
     67  1d57					      MAC	i2c_txnack
     68  1d57							; I2C_SCL_0
     69  1d57					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  1d57					      sta	SWCHA	; 4
     71  1d57							; I2C_SDA_IN
     72  1d57					      lsr		; 2	     I2C_SCL_MASK
     73  1d57					      sta	SWACNT	; 4
     74  1d57							; I2C_SCL_1
     75  1d57					      nop		; 2	     required for timing!
     76  1d57					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  1d57							; total: 18 cycles
     78  1d57					      ENDM
     79  1d57
     80  1d57
     81  1d57							; Subroutine Macros
     82  1d57
     83  1d57					      MAC	i2c_subs
     84  1d57
     85  1d57				   i2c_startread
     86  1d57							; use V to flag if previous byte needs ACK
     87  1d57					      ldy	#%10100001	; 2	     eeprom read command
     88  1d57					      .byte	$2c	; 2
     89  1d57				   i2c_startwrite
     90  1d57					      ldy	#%10100000	; 2	     eeprom write command
     91  1d57					      I2C_START		;12	     start signal (clears V flag)
     92  1d57					      tya		; 2 = 16
     93  1d57				   i2c_txbyte
     94  1d57					      eor	#$ff	; 2	     invert data byte
     95  1d57					      sec		; 2
     96  1d57					      rol		; 2 =	6    shift loop bit into a
     97  1d57				   i2c_txbyteloop
     98  1d57					      tay		; 2
     99  1d57					      I2C_TXBIT		;18	     transmit
    100  1d57					      tya		; 2
    101  1d57					      asl		; 2	     shift next bit into C
    102  1d57					      bne	i2c_txbyteloop	; 2= 26/27
    103  1d57
    104  1d57							; receive acknowledge bit
    105  1d57
    106  1d57					      beq	i2c_rxbit	;43 = 43
    107  1d57							; i2c_txbyte: 264 cycles
    108  1d57							;-------------------------------------------------------------------------------
    109  1d57
    110  1d57				   i2c_rxbyte
    111  1d57					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  1d57					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  1d57
    114  1d57				   i2c_rxskipack
    115  1d57					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  1d57
    117  1d57					      lda	#1	; 2
    118  1d57				   i2c_rxbyteloop
    119  1d57					      tay		; 2 =	2
    120  1d57				   i2c_rxbit		;	     receive bit in C
    121  1d57					      I2C_TXNACK		;18 = 18
    122  1d57
    123  1d57					      lda	SWCHA	; 4
    124  1d57					      lsr		; 2
    125  1d57					      lsr		; 2
    126  1d57					      lsr		; 2 = 10    C = SDA
    127  1d57
    128  1d57					      tya		; 2
    129  1d57					      rol		; 2	     rotate into Y
    130  1d57					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  1d57
    132  1d57							; received byte in A
    133  1d57					      rts		; 6 =	6
    134  1d57							; i2c_rxbit:  40 cycles
    135  1d57							; i2c_rxbyte: 310/333 cycles
    136  1d57							;-------------------------------------------------------------------------------
    137  1d57
    138  1d57				   i2c_stopread
    139  1d57					      bvc	i2c_stopwrite	; 2
    140  1d57					      ldy	#$80	; 2
    141  1d57					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  1d57
    143  1d57				   i2c_stopwrite
    144  1d57					      jsr	i2c_txack	;30
    145  1d57
    146  1d57							; return port to input mode
    147  1d57					      lda	#0	; 2	     0
    148  1d57					      sta	SWACNT	; 4
    149  1d57					      rts		; 6 = 12
    150  1d57							; i2c_stopread:  45/92
    151  1d57							; i2c_stopwrite: 42
    152  1d57							;-------------------------------------------------------------------------------
    153  1d57
    154  1d57				   i2c_txack
    155  1d57							; I2C_SCL_0
    156  1d57					      lda	#0	; 2	     $00
    157  1d57					      sta	SWCHA	; 4
    158  1d57							; I2C_SDA_OUT
    159  1d57					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  1d57					      sta	SWACNT	; 4
    161  1d57							; I2C_SCL_1
    162  1d57					      asl		; 2	     I2C_SCL_MASK
    163  1d57					      sta	SWCHA	; 4
    164  1d57
    165  1d57					      rts		; 6
    166  1d57							; total: 24 cycles
    167  1d57							;-------------------------------------------------------------------------------
    168  1d57
    169  1d57					      ENDM
    170  1d57
    171  1d57
    172  1d57
------- FILE BANK_GENERIC.asm
    427  1d57
      0  1d57					      i2c_subs
      1  1d57
      2  1d57				   i2c_startread
      3  1d57
      4  1d57		       a0 a1		      ldy	#%10100001
      5  1d59		       2c		      .byte.b	$2c
      6  1d5a				   i2c_startwrite
      7  1d5a		       a0 a0		      ldy	#%10100000
      0  1d5c					      I2C_START
      1  1d5c
      2  1d5c		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  1d5e		       8d 80 02 	      sta	SWCHA
      4  1d61
      5  1d61		       4a		      lsr
      6  1d62		       8d 81 02 	      sta	SWACNT
      7  1d65
      9  1d65		       98		      tya
     10  1d66				   i2c_txbyte
     11  1d66		       49 ff		      eor	#$ff
     12  1d68		       38		      sec
     13  1d69		       2a		      rol
     14  1d6a				   i2c_txbyteloop
     15  1d6a		       a8		      tay
      0  1d6b					      I2C_TXBIT
      1  1d6b
      2  1d6b		       a9 03		      lda	#%0011
      3  1d6d		       8d 80 02 	      sta	SWCHA
      4  1d70
      5  1d70		       69 08		      adc	#%1000
      6  1d72		       8d 81 02 	      sta	SWACNT
      7  1d75
      8  1d75		       a9 08		      lda	#I2C_SCL_MASK
      9  1d77		       8d 80 02 	      sta	SWCHA
     10  1d7a
     17  1d7a		       98		      tya
     18  1d7b		       0a		      asl
     19  1d7c		       d0 ec		      bne	i2c_txbyteloop
     20  1d7e
     21  1d7e
     22  1d7e
     23  1d7e		       f0 0b		      beq	i2c_rxbit
     24  1d80
     25  1d80
     26  1d80
     27  1d80				   i2c_rxbyte
     28  1d80		       50 03		      bvc	i2c_rxskipack
     29  1d82		       20 b3 f5 	      jsr	i2c_txack
     30  1d85
     31  1d85				   i2c_rxskipack
     32  1d85		       2c 80 f5 	      bit	i2c_rxbyte
     33  1d88
     34  1d88		       a9 01		      lda	#1
     35  1d8a				   i2c_rxbyteloop
     36  1d8a		       a8		      tay
     37  1d8b				   i2c_rxbit
      0  1d8b					      I2C_TXNACK
      1  1d8b
      2  1d8b		       a9 10		      lda	#I2C_SCL_MASK*2
      3  1d8d		       8d 80 02 	      sta	SWCHA
      4  1d90
      5  1d90		       4a		      lsr
      6  1d91		       8d 81 02 	      sta	SWACNT
      7  1d94
      8  1d94		       ea		      nop
      9  1d95		       8d 80 02 	      sta	SWCHA
     10  1d98
     39  1d98
     40  1d98		       ad 80 02 	      lda	SWCHA
     41  1d9b		       4a		      lsr
     42  1d9c		       4a		      lsr
     43  1d9d		       4a		      lsr
     44  1d9e
     45  1d9e		       98		      tya
     46  1d9f		       2a		      rol
     47  1da0		       90 e8		      bcc	i2c_rxbyteloop
     48  1da2
     49  1da2
     50  1da2		       60		      rts
     51  1da3
     52  1da3
     53  1da3
     54  1da3
     55  1da3				   i2c_stopread
     56  1da3		       50 05		      bvc	i2c_stopwrite
     57  1da5		       a0 80		      ldy	#$80
     58  1da7		       20 8b f5 	      jsr	i2c_rxbit
     59  1daa
     60  1daa				   i2c_stopwrite
     61  1daa		       20 b3 f5 	      jsr	i2c_txack
     62  1dad
     63  1dad
     64  1dad		       a9 00		      lda	#0
     65  1daf		       8d 81 02 	      sta	SWACNT
     66  1db2		       60		      rts
     67  1db3
     68  1db3
     69  1db3
     70  1db3
     71  1db3				   i2c_txack
     72  1db3
     73  1db3		       a9 00		      lda	#0
     74  1db5		       8d 80 02 	      sta	SWCHA
     75  1db8
     76  1db8		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  1dba		       8d 81 02 	      sta	SWACNT
     78  1dbd
     79  1dbd		       0a		      asl
     80  1dbe		       8d 80 02 	      sta	SWCHA
     81  1dc1
     82  1dc1		       60		      rts
     83  1dc2
     84  1dc2
     85  1dc2
    429  1dc2
    430  1dc2				   HandleSaveKey SUBROUTINE
    431  1dc2
    432  1dc2		       2f 00	   SAVEKEY_ADR =	$2F00	;	     tentative address for Sokoban (64 bytes)
    433  1dc2
    434  1dc2							;------------------------------------------------------------------------------
      0  1dc2					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  1dc2		       00 03	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  1dc2					      SUBROUTINE
      3  1dc2				   ReadSaveKey
    436  1dc2
    437  1dc2							; assume no SaveKey found:
    438  1dc2		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    439  1dc4		       85 d7		      sta	highScoreSK+2	; 3
    440  1dc6
    441  1dc6							; setup SaveKey:
    442  1dc6		       a5 d8		      lda	startingLevel	; 3	     load start levelX*5 and level
    443  1dc8		       a6 b3		      ldx	level	; 3
    444  1dca		       20 03 f6 	      jsr	SetupSaveKey	;6+853
    445  1dcd		       90 52		      bcc	NoSKfound	; 2/3
    446  1dcf
    447  1dcf							;    lda     #$34
    448  1dcf							;    sta     COLUBK
    449  1dcf
    450  1dcf							; start read
    451  1dcf		       20 aa f5 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    452  1dd2		       20 57 f5 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    453  1dd5
    454  1dd5							; read high score:
    455  1dd5		       a2 02		      ldx	#3-1	; 2 = 1187
    456  1dd7				   .loopRead
    457  1dd7		       20 80 f5 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    458  1dda		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    459  1ddc		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    460  1dde		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    461  1de0				   .skipEmpty
    462  1de0		       95 d5		      sta	highScoreSK,x	; 4
    463  1de2		       ca		      dex		; 2
    464  1de3		       10 f2		      bpl	.loopRead	; 2/3= 354
    465  1de5
    466  1de5							; stop read:
    467  1de5		       4c a3 f5 	      jmp	i2c_stopread	;3+92=95    terminate read
    468  1de8
    469  1de8							;------------------------------------------------------------------------------
      0  1de8					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  1de8		       00 03	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  1de8					      SUBROUTINE
      3  1de8				   WriteSaveKey
    471  1de8
    472  1de8							; check if new high score:
    473  1de8		       a6 d5		      ldx	highScoreSK	; 3
    474  1dea		       e8		      inx		; 2
    475  1deb		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    476  1ded
    477  1ded							; setup SaveKey:
    478  1ded		       a5 d8		      lda	startingLevel	; 3	     load start levelX*5 and level
    479  1def		       a6 d9		      ldx	startLevel	; 3
    480  1df1		       20 03 f6 	      jsr	SetupSaveKey	; 6+853
    481  1df4		       90 2b		      bcc	NoSKfound	; 2/3
    482  1df6
    483  1df6							;    lda     #$64
    484  1df6							;    sta     COLUBK
    485  1df6
    486  1df6							; write high score:
    487  1df6		       a2 02		      ldx	#3-1	; 2 = 841
    488  1df8				   .loopWrite
    489  1df8		       b5 d5		      lda	highScoreSK,x	; 4
    490  1dfa		       20 66 f5 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    491  1dfd		       ca		      dex		; 2
    492  1dfe		       10 f8		      bpl	.loopWrite	; 2/3= 837
    493  1e00
    494  1e00							; stop write:
    495  1e00		       4c aa f5 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    496  1e03
    497  1e03
    498  1e03							;------------------------------------------------------------------------------
    499  1e03
      0  1e03					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  1e03		       00 03	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  1e03					      SUBROUTINE
      3  1e03				   SetupSaveKey
    501  1e03
    502  1e03							; calculate slot;
    503  1e03							; a = levelX
    504  1e03							; x = level (0..4)
    505  1e03		       85 da		      sta	offsetSK	; 3
    506  1e05		       8a		      txa		; 2
    507  1e06		       18		      clc		; 2
    508  1e07		       65 da		      adc	offsetSK	; 3
    509  1e09		       85 da		      sta	offsetSK	; 3
    510  1e0b		       0a		      asl		; 2	     multiply by 3
    511  1e0c		       65 da		      adc	offsetSK	; 3
    512  1e0e		       69 00		      adc	#<SAVEKEY_ADR	; 2
    513  1e10		       aa		      tax		; 2 = 22
    514  1e11							; detect SaveKey:
    515  1e11		       20 5a f5 	      jsr	i2c_startwrite	;6+280
    516  1e14		       d0 0a		      bne	.exitSK	; 2/3
    517  1e16
    518  1e16							; setup address:
    519  1e16		       b8		      clv		; 2
    520  1e17		       a9 2f		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    521  1e19		       20 66 f5 	      jsr	i2c_txbyte	;6+264
    522  1e1c		       8a		      txa		; 2	     x = lower byte offset
    523  1e1d		       4c 66 f5 	      jmp	i2c_txbyte	;3+264      returns C==1
    524  1e20
    525  1e20				   .exitSK
    526  1e20		       18		      clc
    527  1e21				   NoSKfound
    528  1e21		       60		      rts
    529  1e21					      ENDIF
    530  1e22
    531  1e22
      0  1e22					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  1e22		       06 22	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $622 , FREE= $1de
      2  1e22					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1e22				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1e22				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1e22				  -	      ERR
      6  1e22					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS1.asm LEVEL 2 PASS 3
      0  1e22					      include	"BANK_LEVELS1.asm"
      1  1e22							;    Sokoboo - a Sokoban implementation
      2  1e22							;    using a generic tile-based display engine for the Atari 2600
      3  1e22							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1e22							;
      5  1e22							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1e22							;
      7  1e22							;    Code related to the generic tile-based display engine was developed by
      8  1e22							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1e22							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1e22							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1e22							;
     12  1e22							;    Code related to music and sound effects uses the TIATracker music player
     13  1e22							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1e22							;    directory for Apache licensing details.
     15  1e22							;
     16  1e22							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1e22							;    See the copyright notices in the License directory for a list of level
     18  1e22							;    contributors.
     19  1e22							;
     20  1e22							;    Except where otherwise indicated, this software is released under the
     21  1e22							;    following licensing arrangement...
     22  1e22							;
     23  1e22							;    This program is free software: you can redistribute it and/or modify
     24  1e22							;    it under the terms of the GNU General Public License as published by
     25  1e22							;    the Free Software Foundation, either version 3 of the License, or
     26  1e22							;    (at your option) any later version.
     27  1e22							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1e22
     29  1e22							;    This program is distributed in the hope that it will be useful,
     30  1e22							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1e22							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1e22							;    GNU General Public License for more details.
     33  1e22
      0  1e22					      NEWBANK	LEVELS1
      1  27b5 ????				      SEG	LEVELS1
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   LEVELS1    SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	LEVELS1
     35  2000
     36  2000
     37  2000							;  DEFL _000_SELECT, "12#|#@3-5$.#|10-|10-|12#"
     38  2000
     39  2000							; "SOKWHOLE" collection...
     40  2000
     41  2000
      0  2000					      DEFL	_001_L, "3#|#@#|#$#|#.#|3#"
      0  2000					      START_LEVEL	_001_L
      1  2000				   LEVEL_START SET	*
      2  2000		       00 04	   BANK_LEVEL__001_L =	_CURRENT_BANK
      3  2000				   LEVEL__001_L SUBROUTINE
      4  2000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2000
      2  2000		       33 23 7c 23*	      .byte.b	"3#|#@#|#$#|#.#|3#",0
      0  2012					      END_LEVEL	_001_L
      1  2012		       00 12	   LEVEL_SIZE__001_L =	* - LEVEL_START
      2  2012					      IF	LEVEL_SIZE__001_L > MAX_LEVEL_SIZE
      3  2012				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_L
      4  2012					      ENDIF
      0  2012					      DEFL	_001_R, "5#|#.$@#|5#"
      0  2012					      START_LEVEL	_001_R
      1  2012				   LEVEL_START SET	*
      2  2012		       00 04	   BANK_LEVEL__001_R =	_CURRENT_BANK
      3  2012				   LEVEL__001_R SUBROUTINE
      4  2012				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2012
      2  2012		       35 23 7c 23*	      .byte.b	"5#|#.$@#|5#",0
      0  201e					      END_LEVEL	_001_R
      1  201e		       00 0c	   LEVEL_SIZE__001_R =	* - LEVEL_START
      2  201e				  -	      IF	LEVEL_SIZE__001_R > MAX_LEVEL_SIZE
      3  201e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_R
      4  201e					      ENDIF
      0  201e					      DEFL	_002_L, "3#2-|#.3#|#*$-#|#2-@#|5#"
      0  201e					      START_LEVEL	_002_L
      1  201e				   LEVEL_START SET	*
      2  201e		       00 04	   BANK_LEVEL__002_L =	_CURRENT_BANK
      3  201e				   LEVEL__002_L SUBROUTINE
      4  201e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  201e
      2  201e		       33 23 32 2d*	      .byte.b	"3#2-|#.3#|#*$-#|#2-@#|5#",0
      0  2037					      END_LEVEL	_002_L
      1  2037		       00 19	   LEVEL_SIZE__002_L =	* - LEVEL_START
      2  2037					      IF	LEVEL_SIZE__002_L > MAX_LEVEL_SIZE
      3  2037				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_L
      4  2037					      ENDIF
      0  2037					      DEFL	_002_R, "2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#"
      0  2037					      START_LEVEL	_002_R
      1  2037				   LEVEL_START SET	*
      2  2037		       00 04	   BANK_LEVEL__002_R =	_CURRENT_BANK
      3  2037				   LEVEL__002_R SUBROUTINE
      4  2037				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2037
      2  2037		       32 2d 35 23*	      .byte.b	"2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#",0
      0  205f					      END_LEVEL	_002_R
      1  205f		       00 28	   LEVEL_SIZE__002_R =	* - LEVEL_START
      2  205f					      IF	LEVEL_SIZE__002_R > MAX_LEVEL_SIZE
      3  205f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_R
      4  205f					      ENDIF
      0  205f					      DEFL	_003_L, "4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-"
      0  205f					      START_LEVEL	_003_L
      1  205f				   LEVEL_START SET	*
      2  205f		       00 04	   BANK_LEVEL__003_L =	_CURRENT_BANK
      3  205f				   LEVEL__003_L SUBROUTINE
      4  205f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  205f
      2  205f		       34 2d 35 23*	      .byte.b	"4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-",0
      0  208b					      END_LEVEL	_003_L
      1  208b		       00 2c	   LEVEL_SIZE__003_L =	* - LEVEL_START
      2  208b					      IF	LEVEL_SIZE__003_L > MAX_LEVEL_SIZE
      3  208b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_L
      4  208b					      ENDIF
      0  208b					      DEFL	_003_R, "9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-"
      0  208b					      START_LEVEL	_003_R
      1  208b				   LEVEL_START SET	*
      2  208b		       00 04	   BANK_LEVEL__003_R =	_CURRENT_BANK
      3  208b				   LEVEL__003_R SUBROUTINE
      4  208b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  208b
      2  208b		       39 23 7c 23*	      .byte.b	"9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-",0
      0  20b5					      END_LEVEL	_003_R
      1  20b5		       00 2a	   LEVEL_SIZE__003_R =	* - LEVEL_START
      2  20b5				  -	      IF	LEVEL_SIZE__003_R > MAX_LEVEL_SIZE
      3  20b5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_R
      4  20b5					      ENDIF
      0  20b5					      DEFL	_004_L, "5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-"
      0  20b5					      START_LEVEL	_004_L
      1  20b5				   LEVEL_START SET	*
      2  20b5		       00 04	   BANK_LEVEL__004_L =	_CURRENT_BANK
      3  20b5				   LEVEL__004_L SUBROUTINE
      4  20b5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20b5
      2  20b5		       35 23 2d 7c*	      .byte.b	"5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-",0
      0  20d8					      END_LEVEL	_004_L
      1  20d8		       00 23	   LEVEL_SIZE__004_L =	* - LEVEL_START
      2  20d8				  -	      IF	LEVEL_SIZE__004_L > MAX_LEVEL_SIZE
      3  20d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_L
      4  20d8					      ENDIF
      0  20d8					      DEFL	_004_R, "-6#|-#4-#|2#-$*$#|#@$3.#|7#"
      0  20d8					      START_LEVEL	_004_R
      1  20d8				   LEVEL_START SET	*
      2  20d8		       00 04	   BANK_LEVEL__004_R =	_CURRENT_BANK
      3  20d8				   LEVEL__004_R SUBROUTINE
      4  20d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20d8
      2  20d8		       2d 36 23 7c*	      .byte.b	"-6#|-#4-#|2#-$*$#|#@$3.#|7#",0
      0  20f4					      END_LEVEL	_004_R
      1  20f4		       00 1c	   LEVEL_SIZE__004_R =	* - LEVEL_START
      2  20f4				  -	      IF	LEVEL_SIZE__004_R > MAX_LEVEL_SIZE
      3  20f4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_R
      4  20f4					      ENDIF
      0  20f4					      DEFL	_005_L, "3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-"
      0  20f4					      START_LEVEL	_005_L
      1  20f4				   LEVEL_START SET	*
      2  20f4		       00 04	   BANK_LEVEL__005_L =	_CURRENT_BANK
      3  20f4				   LEVEL__005_L SUBROUTINE
      4  20f4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20f4
      2  20f4		       33 2d 35 23*	      .byte.b	"3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-",0
      0  2126					      END_LEVEL	_005_L
      1  2126		       00 32	   LEVEL_SIZE__005_L =	* - LEVEL_START
      2  2126					      IF	LEVEL_SIZE__005_L > MAX_LEVEL_SIZE
      3  2126				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_L
      4  2126					      ENDIF
      0  2126					      DEFL	_005_R, "6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-"
      0  2126					      START_LEVEL	_005_R
      1  2126				   LEVEL_START SET	*
      2  2126		       00 04	   BANK_LEVEL__005_R =	_CURRENT_BANK
      3  2126				   LEVEL__005_R SUBROUTINE
      4  2126				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2126
      2  2126		       36 23 32 2d*	      .byte.b	"6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-",0
      0  2165					      END_LEVEL	_005_R
      1  2165		       00 3f	   LEVEL_SIZE__005_R =	* - LEVEL_START
      2  2165					      IF	LEVEL_SIZE__005_R > MAX_LEVEL_SIZE
      3  2165				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_R
      4  2165					      ENDIF
      0  2165					      DEFL	_006_L, "5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-"
      0  2165					      START_LEVEL	_006_L
      1  2165				   LEVEL_START SET	*
      2  2165		       00 04	   BANK_LEVEL__006_L =	_CURRENT_BANK
      3  2165				   LEVEL__006_L SUBROUTINE
      4  2165				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2165
      2  2165		       35 23 33 2d*	      .byte.b	"5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-",0
      0  21a0					      END_LEVEL	_006_L
      1  21a0		       00 3b	   LEVEL_SIZE__006_L =	* - LEVEL_START
      2  21a0				  -	      IF	LEVEL_SIZE__006_L > MAX_LEVEL_SIZE
      3  21a0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_L
      4  21a0					      ENDIF
      0  21a0					      DEFL	_006_R, "3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-"
      0  21a0					      START_LEVEL	_006_R
      1  21a0				   LEVEL_START SET	*
      2  21a0		       00 04	   BANK_LEVEL__006_R =	_CURRENT_BANK
      3  21a0				   LEVEL__006_R SUBROUTINE
      4  21a0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21a0
      2  21a0		       33 23 34 2d*	      .byte.b	"3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-",0
      0  21de					      END_LEVEL	_006_R
      1  21de		       00 3e	   LEVEL_SIZE__006_R =	* - LEVEL_START
      2  21de				  -	      IF	LEVEL_SIZE__006_R > MAX_LEVEL_SIZE
      3  21de				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_R
      4  21de					      ENDIF
      0  21de					      DEFL	_007_L, "6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#"
      0  21de					      START_LEVEL	_007_L
      1  21de				   LEVEL_START SET	*
      2  21de		       00 04	   BANK_LEVEL__007_L =	_CURRENT_BANK
      3  21de				   LEVEL__007_L SUBROUTINE
      4  21de				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21de
      2  21de		       36 23 2d 7c*	      .byte.b	"6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#",0
      0  220b					      END_LEVEL	_007_L
      1  220b		       00 2d	   LEVEL_SIZE__007_L =	* - LEVEL_START
      2  220b				  -	      IF	LEVEL_SIZE__007_L > MAX_LEVEL_SIZE
      3  220b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_L
      4  220b					      ENDIF
      0  220b					      DEFL	_007_R, "4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#"
      0  220b					      START_LEVEL	_007_R
      1  220b				   LEVEL_START SET	*
      2  220b		       00 04	   BANK_LEVEL__007_R =	_CURRENT_BANK
      3  220b				   LEVEL__007_R SUBROUTINE
      4  220b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  220b
      2  220b		       34 23 34 2d*	      .byte.b	"4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#",0
      0  223e					      END_LEVEL	_007_R
      1  223e		       00 33	   LEVEL_SIZE__007_R =	* - LEVEL_START
      2  223e				  -	      IF	LEVEL_SIZE__007_R > MAX_LEVEL_SIZE
      3  223e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_R
      4  223e					      ENDIF
      0  223e					      DEFL	_008_L, "2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-"
      0  223e					      START_LEVEL	_008_L
      1  223e				   LEVEL_START SET	*
      2  223e		       00 04	   BANK_LEVEL__008_L =	_CURRENT_BANK
      3  223e				   LEVEL__008_L SUBROUTINE
      4  223e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  223e
      2  223e		       32 2d 35 23*	      .byte.b	"2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-",0
      0  2274					      END_LEVEL	_008_L
      1  2274		       00 36	   LEVEL_SIZE__008_L =	* - LEVEL_START
      2  2274				  -	      IF	LEVEL_SIZE__008_L > MAX_LEVEL_SIZE
      3  2274				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_L
      4  2274					      ENDIF
      0  2274					      DEFL	_008_R, "-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#"
      0  2274					      START_LEVEL	_008_R
      1  2274				   LEVEL_START SET	*
      2  2274		       00 04	   BANK_LEVEL__008_R =	_CURRENT_BANK
      3  2274				   LEVEL__008_R SUBROUTINE
      4  2274				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2274
      2  2274		       2d 35 23 33*	      .byte.b	"-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#",0
      0  22a5					      END_LEVEL	_008_R
      1  22a5		       00 31	   LEVEL_SIZE__008_R =	* - LEVEL_START
      2  22a5				  -	      IF	LEVEL_SIZE__008_R > MAX_LEVEL_SIZE
      3  22a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_R
      4  22a5					      ENDIF
      0  22a5					      DEFL	_009_L, "-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#"
      0  22a5					      START_LEVEL	_009_L
      1  22a5				   LEVEL_START SET	*
      2  22a5		       00 04	   BANK_LEVEL__009_L =	_CURRENT_BANK
      3  22a5				   LEVEL__009_L SUBROUTINE
      4  22a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22a5
      2  22a5		       2d 35 23 2d*	      .byte.b	"-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#",0
      0  22d7					      END_LEVEL	_009_L
      1  22d7		       00 32	   LEVEL_SIZE__009_L =	* - LEVEL_START
      2  22d7				  -	      IF	LEVEL_SIZE__009_L > MAX_LEVEL_SIZE
      3  22d7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_L
      4  22d7					      ENDIF
      0  22d7					      DEFL	_009_R, "-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#"
      0  22d7					      START_LEVEL	_009_R
      1  22d7				   LEVEL_START SET	*
      2  22d7		       00 04	   BANK_LEVEL__009_R =	_CURRENT_BANK
      3  22d7				   LEVEL__009_R SUBROUTINE
      4  22d7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22d7
      2  22d7		       2d 33 23 33*	      .byte.b	"-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#",0
      0  2307					      END_LEVEL	_009_R
      1  2307		       00 30	   LEVEL_SIZE__009_R =	* - LEVEL_START
      2  2307				  -	      IF	LEVEL_SIZE__009_R > MAX_LEVEL_SIZE
      3  2307				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_R
      4  2307					      ENDIF
      0  2307					      DEFL	_010_L, "2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-"
      0  2307					      START_LEVEL	_010_L
      1  2307				   LEVEL_START SET	*
      2  2307		       00 04	   BANK_LEVEL__010_L =	_CURRENT_BANK
      3  2307				   LEVEL__010_L SUBROUTINE
      4  2307				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2307
      2  2307		       32 2d 33 23*	      .byte.b	"2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-",0
      0  2341					      END_LEVEL	_010_L
      1  2341		       00 3a	   LEVEL_SIZE__010_L =	* - LEVEL_START
      2  2341				  -	      IF	LEVEL_SIZE__010_L > MAX_LEVEL_SIZE
      3  2341				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_L
      4  2341					      ENDIF
      0  2341					      DEFL	_010_R, "4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-"
      0  2341					      START_LEVEL	_010_R
      1  2341				   LEVEL_START SET	*
      2  2341		       00 04	   BANK_LEVEL__010_R =	_CURRENT_BANK
      3  2341				   LEVEL__010_R SUBROUTINE
      4  2341				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2341
      2  2341		       34 23 32 2d*	      .byte.b	"4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-",0
      0  2374					      END_LEVEL	_010_R
      1  2374		       00 33	   LEVEL_SIZE__010_R =	* - LEVEL_START
      2  2374				  -	      IF	LEVEL_SIZE__010_R > MAX_LEVEL_SIZE
      3  2374				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_R
      4  2374					      ENDIF
      0  2374					      DEFL	_011_L, "-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-"
      0  2374					      START_LEVEL	_011_L
      1  2374				   LEVEL_START SET	*
      2  2374		       00 04	   BANK_LEVEL__011_L =	_CURRENT_BANK
      3  2374				   LEVEL__011_L SUBROUTINE
      4  2374				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2374
      2  2374		       2d 34 23 32*	      .byte.b	"-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-",0
      0  23a7					      END_LEVEL	_011_L
      1  23a7		       00 33	   LEVEL_SIZE__011_L =	* - LEVEL_START
      2  23a7				  -	      IF	LEVEL_SIZE__011_L > MAX_LEVEL_SIZE
      3  23a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_L
      4  23a7					      ENDIF
      0  23a7					      DEFL	_011_R, "2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#"
      0  23a7					      START_LEVEL	_011_R
      1  23a7				   LEVEL_START SET	*
      2  23a7		       00 04	   BANK_LEVEL__011_R =	_CURRENT_BANK
      3  23a7				   LEVEL__011_R SUBROUTINE
      4  23a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23a7
      2  23a7		       32 2d 33 23*	      .byte.b	"2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#",0
      0  23e1					      END_LEVEL	_011_R
      1  23e1		       00 3a	   LEVEL_SIZE__011_R =	* - LEVEL_START
      2  23e1				  -	      IF	LEVEL_SIZE__011_R > MAX_LEVEL_SIZE
      3  23e1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_R
      4  23e1					      ENDIF
      0  23e1					      DEFL	_012_L, "7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#"
      0  23e1					      START_LEVEL	_012_L
      1  23e1				   LEVEL_START SET	*
      2  23e1		       00 04	   BANK_LEVEL__012_L =	_CURRENT_BANK
      3  23e1				   LEVEL__012_L SUBROUTINE
      4  23e1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23e1
      2  23e1		       37 23 33 2d*	      .byte.b	"7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#",0
      0  2411					      END_LEVEL	_012_L
      1  2411		       00 30	   LEVEL_SIZE__012_L =	* - LEVEL_START
      2  2411				  -	      IF	LEVEL_SIZE__012_L > MAX_LEVEL_SIZE
      3  2411				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_L
      4  2411					      ENDIF
      0  2411					      DEFL	_012_R, "-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-"
      0  2411					      START_LEVEL	_012_R
      1  2411				   LEVEL_START SET	*
      2  2411		       00 04	   BANK_LEVEL__012_R =	_CURRENT_BANK
      3  2411				   LEVEL__012_R SUBROUTINE
      4  2411				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2411
      2  2411		       2d 36 23 32*	      .byte.b	"-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-",0
      0  244d					      END_LEVEL	_012_R
      1  244d		       00 3c	   LEVEL_SIZE__012_R =	* - LEVEL_START
      2  244d				  -	      IF	LEVEL_SIZE__012_R > MAX_LEVEL_SIZE
      3  244d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_R
      4  244d					      ENDIF
      0  244d					      DEFL	_013_L, "2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-"
      0  244d					      START_LEVEL	_013_L
      1  244d				   LEVEL_START SET	*
      2  244d		       00 04	   BANK_LEVEL__013_L =	_CURRENT_BANK
      3  244d				   LEVEL__013_L SUBROUTINE
      4  244d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  244d
      2  244d		       32 2d 35 23*	      .byte.b	"2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-",0
      0  248c					      END_LEVEL	_013_L
      1  248c		       00 3f	   LEVEL_SIZE__013_L =	* - LEVEL_START
      2  248c				  -	      IF	LEVEL_SIZE__013_L > MAX_LEVEL_SIZE
      3  248c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_L
      4  248c					      ENDIF
      0  248c					      DEFL	_013_R, "-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-"
      0  248c					      START_LEVEL	_013_R
      1  248c				   LEVEL_START SET	*
      2  248c		       00 04	   BANK_LEVEL__013_R =	_CURRENT_BANK
      3  248c				   LEVEL__013_R SUBROUTINE
      4  248c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  248c
      2  248c		       2d 35 23 32*	      .byte.b	"-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-",0
      0  24bf					      END_LEVEL	_013_R
      1  24bf		       00 33	   LEVEL_SIZE__013_R =	* - LEVEL_START
      2  24bf				  -	      IF	LEVEL_SIZE__013_R > MAX_LEVEL_SIZE
      3  24bf				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_R
      4  24bf					      ENDIF
      0  24bf					      DEFL	_014_L, "6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#"
      0  24bf					      START_LEVEL	_014_L
      1  24bf				   LEVEL_START SET	*
      2  24bf		       00 04	   BANK_LEVEL__014_L =	_CURRENT_BANK
      3  24bf				   LEVEL__014_L SUBROUTINE
      4  24bf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24bf
      2  24bf		       36 23 34 2d*	      .byte.b	"6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#",0
      0  2502					      END_LEVEL	_014_L
      1  2502		       00 43	   LEVEL_SIZE__014_L =	* - LEVEL_START
      2  2502					      IF	LEVEL_SIZE__014_L > MAX_LEVEL_SIZE
      3  2502				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_L
      4  2502					      ENDIF
      0  2502					      DEFL	_014_R, "6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-"
      0  2502					      START_LEVEL	_014_R
      1  2502				   LEVEL_START SET	*
      2  2502		       00 04	   BANK_LEVEL__014_R =	_CURRENT_BANK
      3  2502				   LEVEL__014_R SUBROUTINE
      4  2502				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2502
      2  2502		       36 23 33 2d*	      .byte.b	"6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-",0
      0  2545					      END_LEVEL	_014_R
      1  2545		       00 43	   LEVEL_SIZE__014_R =	* - LEVEL_START
      2  2545				  -	      IF	LEVEL_SIZE__014_R > MAX_LEVEL_SIZE
      3  2545				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_R
      4  2545					      ENDIF
      0  2545					      DEFL	_015_L, "2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#"
      0  2545					      START_LEVEL	_015_L
      1  2545				   LEVEL_START SET	*
      2  2545		       00 04	   BANK_LEVEL__015_L =	_CURRENT_BANK
      3  2545				   LEVEL__015_L SUBROUTINE
      4  2545				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2545
      2  2545		       32 2d 35 23*	      .byte.b	"2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#",0
      0  257a					      END_LEVEL	_015_L
      1  257a		       00 35	   LEVEL_SIZE__015_L =	* - LEVEL_START
      2  257a				  -	      IF	LEVEL_SIZE__015_L > MAX_LEVEL_SIZE
      3  257a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_L
      4  257a					      ENDIF
      0  257a					      DEFL	_015_R, "3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-"
      0  257a					      START_LEVEL	_015_R
      1  257a				   LEVEL_START SET	*
      2  257a		       00 04	   BANK_LEVEL__015_R =	_CURRENT_BANK
      3  257a				   LEVEL__015_R SUBROUTINE
      4  257a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  257a
      2  257a		       33 2d 35 23*	      .byte.b	"3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-",0
      0  25bf					      END_LEVEL	_015_R
      1  25bf		       00 45	   LEVEL_SIZE__015_R =	* - LEVEL_START
      2  25bf					      IF	LEVEL_SIZE__015_R > MAX_LEVEL_SIZE
      3  25bf				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_R
      4  25bf					      ENDIF
      0  25bf					      DEFL	_016_L, "4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-"
      0  25bf					      START_LEVEL	_016_L
      1  25bf				   LEVEL_START SET	*
      2  25bf		       00 04	   BANK_LEVEL__016_L =	_CURRENT_BANK
      3  25bf				   LEVEL__016_L SUBROUTINE
      4  25bf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25bf
      2  25bf		       34 2d 33 23*	      .byte.b	"4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-",0
      0  25f6					      END_LEVEL	_016_L
      1  25f6		       00 37	   LEVEL_SIZE__016_L =	* - LEVEL_START
      2  25f6				  -	      IF	LEVEL_SIZE__016_L > MAX_LEVEL_SIZE
      3  25f6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_L
      4  25f6					      ENDIF
      0  25f6					      DEFL	_016_R, "5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-"
      0  25f6					      START_LEVEL	_016_R
      1  25f6				   LEVEL_START SET	*
      2  25f6		       00 04	   BANK_LEVEL__016_R =	_CURRENT_BANK
      3  25f6				   LEVEL__016_R SUBROUTINE
      4  25f6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25f6
      2  25f6		       35 23 2d 7c*	      .byte.b	"5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-",0
      0  2629					      END_LEVEL	_016_R
      1  2629		       00 33	   LEVEL_SIZE__016_R =	* - LEVEL_START
      2  2629				  -	      IF	LEVEL_SIZE__016_R > MAX_LEVEL_SIZE
      3  2629				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_R
      4  2629					      ENDIF
      0  2629					      DEFL	_017_L, "5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-"
      0  2629					      START_LEVEL	_017_L
      1  2629				   LEVEL_START SET	*
      2  2629		       00 04	   BANK_LEVEL__017_L =	_CURRENT_BANK
      3  2629				   LEVEL__017_L SUBROUTINE
      4  2629				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2629
      2  2629		       35 23 34 2d*	      .byte.b	"5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-",0
      0  2673					      END_LEVEL	_017_L
      1  2673		       00 4a	   LEVEL_SIZE__017_L =	* - LEVEL_START
      2  2673					      IF	LEVEL_SIZE__017_L > MAX_LEVEL_SIZE
      3  2673				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_L
      4  2673					      ENDIF
      0  2673					      DEFL	_017_R, "3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-"
      0  2673					      START_LEVEL	_017_R
      1  2673				   LEVEL_START SET	*
      2  2673		       00 04	   BANK_LEVEL__017_R =	_CURRENT_BANK
      3  2673				   LEVEL__017_R SUBROUTINE
      4  2673				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2673
      2  2673		       33 2d 34 23*	      .byte.b	"3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-",0
      0  26b6					      END_LEVEL	_017_R
      1  26b6		       00 43	   LEVEL_SIZE__017_R =	* - LEVEL_START
      2  26b6				  -	      IF	LEVEL_SIZE__017_R > MAX_LEVEL_SIZE
      3  26b6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_R
      4  26b6					      ENDIF
      0  26b6					      DEFL	_018_L, "6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#"
      0  26b6					      START_LEVEL	_018_L
      1  26b6				   LEVEL_START SET	*
      2  26b6		       00 04	   BANK_LEVEL__018_L =	_CURRENT_BANK
      3  26b6				   LEVEL__018_L SUBROUTINE
      4  26b6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26b6
      2  26b6		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#",0
      0  26ea					      END_LEVEL	_018_L
      1  26ea		       00 34	   LEVEL_SIZE__018_L =	* - LEVEL_START
      2  26ea				  -	      IF	LEVEL_SIZE__018_L > MAX_LEVEL_SIZE
      3  26ea				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_L
      4  26ea					      ENDIF
      0  26ea					      DEFL	_018_R, "-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#"
      0  26ea					      START_LEVEL	_018_R
      1  26ea				   LEVEL_START SET	*
      2  26ea		       00 04	   BANK_LEVEL__018_R =	_CURRENT_BANK
      3  26ea				   LEVEL__018_R SUBROUTINE
      4  26ea				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26ea
      2  26ea		       2d 34 23 33*	      .byte.b	"-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#",0
      0  2726					      END_LEVEL	_018_R
      1  2726		       00 3c	   LEVEL_SIZE__018_R =	* - LEVEL_START
      2  2726				  -	      IF	LEVEL_SIZE__018_R > MAX_LEVEL_SIZE
      3  2726				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_R
      4  2726					      ENDIF
      0  2726					      DEFL	_019_L, "4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#"
      0  2726					      START_LEVEL	_019_L
      1  2726				   LEVEL_START SET	*
      2  2726		       00 04	   BANK_LEVEL__019_L =	_CURRENT_BANK
      3  2726				   LEVEL__019_L SUBROUTINE
      4  2726				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2726
      2  2726		       34 2d 35 23*	      .byte.b	"4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#",0
      0  2761					      END_LEVEL	_019_L
      1  2761		       00 3b	   LEVEL_SIZE__019_L =	* - LEVEL_START
      2  2761				  -	      IF	LEVEL_SIZE__019_L > MAX_LEVEL_SIZE
      3  2761				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_L
      4  2761					      ENDIF
      0  2761					      DEFL	_019_R, "2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#"
      0  2761					      START_LEVEL	_019_R
      1  2761				   LEVEL_START SET	*
      2  2761		       00 04	   BANK_LEVEL__019_R =	_CURRENT_BANK
      3  2761				   LEVEL__019_R SUBROUTINE
      4  2761				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2761
      2  2761		       32 2d 37 23*	      .byte.b	"2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#",0
      0  27b1					      END_LEVEL	_019_R
      1  27b1		       00 50	   LEVEL_SIZE__019_R =	* - LEVEL_START
      2  27b1					      IF	LEVEL_SIZE__019_R > MAX_LEVEL_SIZE
      3  27b1				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_R
      4  27b1					      ENDIF
     80  27b1
     81  27b1							;-----------------------------------------------------------
     82  27b1							; Stella 3E autodetect signature, can live anywhere
     83  27b1		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
     84  27b5							;-----------------------------------------------------------
     85  27b5
      0  27b5					      CHECK_BANK_SIZE	"LEVELS1"
      1  27b5		       07 b5	   .TEMP      =	* - BANK_START
 LEVELS1 (2K) SIZE =  $7b5 , FREE= $4b
      2  27b5					      ECHO	"LEVELS1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27b5				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  27b5				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27b5				  -	      ERR
      6  27b5					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS2.asm LEVEL 2 PASS 3
      0  27b5					      include	"BANK_LEVELS2.asm"
      1  27b5							;    Sokoboo - a Sokoban implementation
      2  27b5							;    using a generic tile-based display engine for the Atari 2600
      3  27b5							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  27b5							;
      5  27b5							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  27b5							;
      7  27b5							;    Code related to the generic tile-based display engine was developed by
      8  27b5							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  27b5							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  27b5							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  27b5							;
     12  27b5							;    Code related to music and sound effects uses the TIATracker music player
     13  27b5							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  27b5							;    directory for Apache licensing details.
     15  27b5							;
     16  27b5							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  27b5							;    See the copyright notices in the License directory for a list of level
     18  27b5							;    contributors.
     19  27b5							;
     20  27b5							;    Except where otherwise indicated, this software is released under the
     21  27b5							;    following licensing arrangement...
     22  27b5							;
     23  27b5							;    This program is free software: you can redistribute it and/or modify
     24  27b5							;    it under the terms of the GNU General Public License as published by
     25  27b5							;    the Free Software Foundation, either version 3 of the License, or
     26  27b5							;    (at your option) any later version.
     27  27b5							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  27b5
     29  27b5							;    This program is distributed in the hope that it will be useful,
     30  27b5							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  27b5							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  27b5							;    GNU General Public License for more details.
     33  27b5
      0  27b5					      NEWBANK	LEVELS2
      1  2fbe ????				      SEG	LEVELS2
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   LEVELS2    SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	LEVELS2
     35  2800
      0  2800					      DEFL	_020_L, "-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-"
      0  2800					      START_LEVEL	_020_L
      1  2800				   LEVEL_START SET	*
      2  2800		       00 05	   BANK_LEVEL__020_L =	_CURRENT_BANK
      3  2800				   LEVEL__020_L SUBROUTINE
      4  2800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2800
      2  2800		       2d 36 23 2d*	      .byte.b	"-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-",0
      0  283f					      END_LEVEL	_020_L
      1  283f		       00 3f	   LEVEL_SIZE__020_L =	* - LEVEL_START
      2  283f				  -	      IF	LEVEL_SIZE__020_L > MAX_LEVEL_SIZE
      3  283f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_L
      4  283f					      ENDIF
      0  283f					      DEFL	_020_R, "5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-"
      0  283f					      START_LEVEL	_020_R
      1  283f				   LEVEL_START SET	*
      2  283f		       00 05	   BANK_LEVEL__020_R =	_CURRENT_BANK
      3  283f				   LEVEL__020_R SUBROUTINE
      4  283f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  283f
      2  283f		       35 2d 34 23*	      .byte.b	"5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-",0
      0  287f					      END_LEVEL	_020_R
      1  287f		       00 40	   LEVEL_SIZE__020_R =	* - LEVEL_START
      2  287f				  -	      IF	LEVEL_SIZE__020_R > MAX_LEVEL_SIZE
      3  287f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_R
      4  287f					      ENDIF
      0  287f					      DEFL	_021_L, "4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-"
      0  287f					      START_LEVEL	_021_L
      1  287f				   LEVEL_START SET	*
      2  287f		       00 05	   BANK_LEVEL__021_L =	_CURRENT_BANK
      3  287f				   LEVEL__021_L SUBROUTINE
      4  287f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  287f
      2  287f		       34 2d 34 23*	      .byte.b	"4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-",0
      0  28d5					      END_LEVEL	_021_L
      1  28d5		       00 56	   LEVEL_SIZE__021_L =	* - LEVEL_START
      2  28d5					      IF	LEVEL_SIZE__021_L > MAX_LEVEL_SIZE
      3  28d5				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_L
      4  28d5					      ENDIF
      0  28d5					      DEFL	_021_R, "-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-"
      0  28d5					      START_LEVEL	_021_R
      1  28d5				   LEVEL_START SET	*
      2  28d5		       00 05	   BANK_LEVEL__021_R =	_CURRENT_BANK
      3  28d5				   LEVEL__021_R SUBROUTINE
      4  28d5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  28d5
      2  28d5		       2d 34 23 33*	      .byte.b	"-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-",0
      0  2909					      END_LEVEL	_021_R
      1  2909		       00 34	   LEVEL_SIZE__021_R =	* - LEVEL_START
      2  2909				  -	      IF	LEVEL_SIZE__021_R > MAX_LEVEL_SIZE
      3  2909				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_R
      4  2909					      ENDIF
      0  2909					      DEFL	_022_L, "3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-"
      0  2909					      START_LEVEL	_022_L
      1  2909				   LEVEL_START SET	*
      2  2909		       00 05	   BANK_LEVEL__022_L =	_CURRENT_BANK
      3  2909				   LEVEL__022_L SUBROUTINE
      4  2909				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2909
      2  2909		       33 2d 33 23*	      .byte.b	"3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-",0
      0  294f					      END_LEVEL	_022_L
      1  294f		       00 46	   LEVEL_SIZE__022_L =	* - LEVEL_START
      2  294f				  -	      IF	LEVEL_SIZE__022_L > MAX_LEVEL_SIZE
      3  294f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_L
      4  294f					      ENDIF
      0  294f					      DEFL	_022_R, "-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-"
      0  294f					      START_LEVEL	_022_R
      1  294f				   LEVEL_START SET	*
      2  294f		       00 05	   BANK_LEVEL__022_R =	_CURRENT_BANK
      3  294f				   LEVEL__022_R SUBROUTINE
      4  294f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  294f
      2  294f		       2d 33 23 34*	      .byte.b	"-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-",0
      0  298b					      END_LEVEL	_022_R
      1  298b		       00 3c	   LEVEL_SIZE__022_R =	* - LEVEL_START
      2  298b				  -	      IF	LEVEL_SIZE__022_R > MAX_LEVEL_SIZE
      3  298b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_R
      4  298b					      ENDIF
      0  298b					      DEFL	_023_L, "6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#"
      0  298b					      START_LEVEL	_023_L
      1  298b				   LEVEL_START SET	*
      2  298b		       00 05	   BANK_LEVEL__023_L =	_CURRENT_BANK
      3  298b				   LEVEL__023_L SUBROUTINE
      4  298b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  298b
      2  298b		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#",0
      0  29cc					      END_LEVEL	_023_L
      1  29cc		       00 41	   LEVEL_SIZE__023_L =	* - LEVEL_START
      2  29cc				  -	      IF	LEVEL_SIZE__023_L > MAX_LEVEL_SIZE
      3  29cc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_L
      4  29cc					      ENDIF
      0  29cc					      DEFL	_023_R, "7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-"
      0  29cc					      START_LEVEL	_023_R
      1  29cc				   LEVEL_START SET	*
      2  29cc		       00 05	   BANK_LEVEL__023_R =	_CURRENT_BANK
      3  29cc				   LEVEL__023_R SUBROUTINE
      4  29cc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  29cc
      2  29cc		       37 23 32 2d*	      .byte.b	"7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-",0
      0  2a0e					      END_LEVEL	_023_R
      1  2a0e		       00 42	   LEVEL_SIZE__023_R =	* - LEVEL_START
      2  2a0e				  -	      IF	LEVEL_SIZE__023_R > MAX_LEVEL_SIZE
      3  2a0e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_R
      4  2a0e					      ENDIF
      0  2a0e					      DEFL	_024_L, "-9#|-#7-#|-#-#2-$#-#|-#-#.*.#-#|2#2-.*-#-#|#3-.2$2-#|#-$2#2-3#|2#@2#2-#2-|-7#2-"
      0  2a0e					      START_LEVEL	_024_L
      1  2a0e				   LEVEL_START SET	*
      2  2a0e		       00 05	   BANK_LEVEL__024_L =	_CURRENT_BANK
      3  2a0e				   LEVEL__024_L SUBROUTINE
      4  2a0e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a0e
      2  2a0e		       2d 39 23 7c*	      .byte.b	"-9#|-#7-#|-#-#2-$#-#|-#-#.*.#-#|2#2-.*-#-#|#3-.2$2-#|#-$2#2-3#|2#@2#2-#2-|-7#2-",0
      0  2a5e					      END_LEVEL	_024_L
      1  2a5e		       00 50	   LEVEL_SIZE__024_L =	* - LEVEL_START
      2  2a5e				  -	      IF	LEVEL_SIZE__024_L > MAX_LEVEL_SIZE
      3  2a5e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__024_L
      4  2a5e					      ENDIF
      0  2a5e					      DEFL	_024_R, "-8#|2#6-#|#-$-*-#-#|#-3.*$-#|#2-*.*.2#|#2-#$-$-#|4#-$2-#|3-2#@3#|4-3#2-"
      0  2a5e					      START_LEVEL	_024_R
      1  2a5e				   LEVEL_START SET	*
      2  2a5e		       00 05	   BANK_LEVEL__024_R =	_CURRENT_BANK
      3  2a5e				   LEVEL__024_R SUBROUTINE
      4  2a5e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a5e
      2  2a5e		       2d 38 23 7c*	      .byte.b	"-8#|2#6-#|#-$-*-#-#|#-3.*$-#|#2-*.*.2#|#2-#$-$-#|4#-$2-#|3-2#@3#|4-3#2-",0
      0  2aa6					      END_LEVEL	_024_R
      1  2aa6		       00 48	   LEVEL_SIZE__024_R =	* - LEVEL_START
      2  2aa6				  -	      IF	LEVEL_SIZE__024_R > MAX_LEVEL_SIZE
      3  2aa6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__024_R
      4  2aa6					      ENDIF
      0  2aa6					      DEFL	_025_L, "4-4#2-|5#@-2#-|#4-2$-2#|#-3#2-$-#|#-3.2*.-#|#-2$*$2.2#|2#6-#-|-8#-"
      0  2aa6					      START_LEVEL	_025_L
      1  2aa6				   LEVEL_START SET	*
      2  2aa6		       00 05	   BANK_LEVEL__025_L =	_CURRENT_BANK
      3  2aa6				   LEVEL__025_L SUBROUTINE
      4  2aa6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2aa6
      2  2aa6		       34 2d 34 23*	      .byte.b	"4-4#2-|5#@-2#-|#4-2$-2#|#-3#2-$-#|#-3.2*.-#|#-2$*$2.2#|2#6-#-|-8#-",0
      0  2ae9					      END_LEVEL	_025_L
      1  2ae9		       00 43	   LEVEL_SIZE__025_L =	* - LEVEL_START
      2  2ae9				  -	      IF	LEVEL_SIZE__025_L > MAX_LEVEL_SIZE
      3  2ae9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__025_L
      4  2ae9					      ENDIF
      0  2ae9					      DEFL	_025_R, "-6#-|2#.-$-#-|#.*$*-2#|#.*2.$-#|2#3-#@#|-#-$-$-#|-3#2-2#|3-4#-"
      0  2ae9					      START_LEVEL	_025_R
      1  2ae9				   LEVEL_START SET	*
      2  2ae9		       00 05	   BANK_LEVEL__025_R =	_CURRENT_BANK
      3  2ae9				   LEVEL__025_R SUBROUTINE
      4  2ae9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ae9
      2  2ae9		       2d 36 23 2d*	      .byte.b	"-6#-|2#.-$-#-|#.*$*-2#|#.*2.$-#|2#3-#@#|-#-$-$-#|-3#2-2#|3-4#-",0
      0  2b28					      END_LEVEL	_025_R
      1  2b28		       00 3f	   LEVEL_SIZE__025_R =	* - LEVEL_START
      2  2b28				  -	      IF	LEVEL_SIZE__025_R > MAX_LEVEL_SIZE
      3  2b28				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__025_R
      4  2b28					      ENDIF
      0  2b28					      DEFL	_026_L, "-6#2-|2#-3.3#|#-$-2*.-#|#2-$-2*-#|#-$-$.$-#|#2-#-@2-#|9#"
      0  2b28					      START_LEVEL	_026_L
      1  2b28				   LEVEL_START SET	*
      2  2b28		       00 05	   BANK_LEVEL__026_L =	_CURRENT_BANK
      3  2b28				   LEVEL__026_L SUBROUTINE
      4  2b28				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b28
      2  2b28		       2d 36 23 32*	      .byte.b	"-6#2-|2#-3.3#|#-$-2*.-#|#2-$-2*-#|#-$-$.$-#|#2-#-@2-#|9#",0
      0  2b61					      END_LEVEL	_026_L
      1  2b61		       00 39	   LEVEL_SIZE__026_L =	* - LEVEL_START
      2  2b61				  -	      IF	LEVEL_SIZE__026_L > MAX_LEVEL_SIZE
      3  2b61				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__026_L
      4  2b61					      ENDIF
      0  2b61					      DEFL	_026_R, "5-4#|4-2#2-#|-4#3-#|2#2.-$2-#|#.3*$-2#|2#.$-$-#-|-3#-@2#-|3-4#2-"
      0  2b61					      START_LEVEL	_026_R
      1  2b61				   LEVEL_START SET	*
      2  2b61		       00 05	   BANK_LEVEL__026_R =	_CURRENT_BANK
      3  2b61				   LEVEL__026_R SUBROUTINE
      4  2b61				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b61
      2  2b61		       35 2d 34 23*	      .byte.b	"5-4#|4-2#2-#|-4#3-#|2#2.-$2-#|#.3*$-2#|2#.$-$-#-|-3#-@2#-|3-4#2-",0
      0  2ba2					      END_LEVEL	_026_R
      1  2ba2		       00 41	   LEVEL_SIZE__026_R =	* - LEVEL_START
      2  2ba2				  -	      IF	LEVEL_SIZE__026_R > MAX_LEVEL_SIZE
      3  2ba2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__026_R
      4  2ba2					      ENDIF
      0  2ba2					      DEFL	_027_L, "8#-|#3-@2-#-|#-*4$2#|2#*.#3-#|-#3.$2-#|-3#*.$-#|3-#.4#|3-3#3-"
      0  2ba2					      START_LEVEL	_027_L
      1  2ba2				   LEVEL_START SET	*
      2  2ba2		       00 05	   BANK_LEVEL__027_L =	_CURRENT_BANK
      3  2ba2				   LEVEL__027_L SUBROUTINE
      4  2ba2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ba2
      2  2ba2		       38 23 2d 7c*	      .byte.b	"8#-|#3-@2-#-|#-*4$2#|2#*.#3-#|-#3.$2-#|-3#*.$-#|3-#.4#|3-3#3-",0
      0  2be0					      END_LEVEL	_027_L
      1  2be0		       00 3e	   LEVEL_SIZE__027_L =	* - LEVEL_START
      2  2be0				  -	      IF	LEVEL_SIZE__027_L > MAX_LEVEL_SIZE
      3  2be0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__027_L
      4  2be0					      ENDIF
      0  2be0					      DEFL	_027_R, "7#2-|#5-2#-|#$2*-$-#-|#-*2.2-2#|#2.*3$-#|3#.#3-#|2-4#-@#|5-4#"
      0  2be0					      START_LEVEL	_027_R
      1  2be0				   LEVEL_START SET	*
      2  2be0		       00 05	   BANK_LEVEL__027_R =	_CURRENT_BANK
      3  2be0				   LEVEL__027_R SUBROUTINE
      4  2be0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2be0
      2  2be0		       37 23 32 2d*	      .byte.b	"7#2-|#5-2#-|#$2*-$-#-|#-*2.2-2#|#2.*3$-#|3#.#3-#|2-4#-@#|5-4#",0
      0  2c1e					      END_LEVEL	_027_R
      1  2c1e		       00 3e	   LEVEL_SIZE__027_R =	* - LEVEL_START
      2  2c1e				  -	      IF	LEVEL_SIZE__027_R > MAX_LEVEL_SIZE
      3  2c1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__027_R
      4  2c1e					      ENDIF
      0  2c1e					      DEFL	_028_L, "3-3#4-|4#.#4-|#-$-.#4-|#@#.*5#|#-$.*.3-#|#-2$-*$#-#|#2-#-.$2-#|4#4-2#|3-6#-"
      0  2c1e					      START_LEVEL	_028_L
      1  2c1e				   LEVEL_START SET	*
      2  2c1e		       00 05	   BANK_LEVEL__028_L =	_CURRENT_BANK
      3  2c1e				   LEVEL__028_L SUBROUTINE
      4  2c1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c1e
      2  2c1e		       33 2d 33 23*	      .byte.b	"3-3#4-|4#.#4-|#-$-.#4-|#@#.*5#|#-$.*.3-#|#-2$-*$#-#|#2-#-.$2-#|4#4-2#|3-6#-",0
      0  2c6a					      END_LEVEL	_028_L
      1  2c6a		       00 4c	   LEVEL_SIZE__028_L =	* - LEVEL_START
      2  2c6a				  -	      IF	LEVEL_SIZE__028_L > MAX_LEVEL_SIZE
      3  2c6a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__028_L
      4  2c6a					      ENDIF
      0  2c6a					      DEFL	_028_R, "9#-|#4-2#@#-|#-2#$#-$2#|#-.-.2$2-#|#-.*.2-#-#|#-#.#$3-#|#-#2*3-2#|#4-4#-|6#4-"
      0  2c6a					      START_LEVEL	_028_R
      1  2c6a				   LEVEL_START SET	*
      2  2c6a		       00 05	   BANK_LEVEL__028_R =	_CURRENT_BANK
      3  2c6a				   LEVEL__028_R SUBROUTINE
      4  2c6a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c6a
      2  2c6a		       39 23 2d 7c*	      .byte.b	"9#-|#4-2#@#-|#-2#$#-$2#|#-.-.2$2-#|#-.*.2-#-#|#-#.#$3-#|#-#2*3-2#|#4-4#-|6#4-",0
      0  2cb8					      END_LEVEL	_028_R
      1  2cb8		       00 4e	   LEVEL_SIZE__028_R =	* - LEVEL_START
      2  2cb8				  -	      IF	LEVEL_SIZE__028_R > MAX_LEVEL_SIZE
      3  2cb8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__028_R
      4  2cb8					      ENDIF
      0  2cb8					      DEFL	_029_L, "-5#3-|-#-@-2#2-|2#$*$-3#|#2.*.$2-#|#.*.$3-#|2#2-$-3#|-3#2-#2-|3-4#2-"
      0  2cb8					      START_LEVEL	_029_L
      1  2cb8				   LEVEL_START SET	*
      2  2cb8		       00 05	   BANK_LEVEL__029_L =	_CURRENT_BANK
      3  2cb8				   LEVEL__029_L SUBROUTINE
      4  2cb8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cb8
      2  2cb8		       2d 35 23 33*	      .byte.b	"-5#3-|-#-@-2#2-|2#$*$-3#|#2.*.$2-#|#.*.$3-#|2#2-$-3#|-3#2-#2-|3-4#2-",0
      0  2cfd					      END_LEVEL	_029_L
      1  2cfd		       00 45	   LEVEL_SIZE__029_L =	* - LEVEL_START
      2  2cfd				  -	      IF	LEVEL_SIZE__029_L > MAX_LEVEL_SIZE
      3  2cfd				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__029_L
      4  2cfd					      ENDIF
      0  2cfd					      DEFL	_029_R, "-4#4-|-#@-4#-|2#$-$2-2#|#2.3$2-#|#.2*.*$-#|3#2-2.-#|2-#2-$.2#|2-6#-"
      0  2cfd					      START_LEVEL	_029_R
      1  2cfd				   LEVEL_START SET	*
      2  2cfd		       00 05	   BANK_LEVEL__029_R =	_CURRENT_BANK
      3  2cfd				   LEVEL__029_R SUBROUTINE
      4  2cfd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cfd
      2  2cfd		       2d 34 23 34*	      .byte.b	"-4#4-|-#@-4#-|2#$-$2-2#|#2.3$2-#|#.2*.*$-#|3#2-2.-#|2-#2-$.2#|2-6#-",0
      0  2d41					      END_LEVEL	_029_R
      1  2d41		       00 44	   LEVEL_SIZE__029_R =	* - LEVEL_START
      2  2d41				  -	      IF	LEVEL_SIZE__029_R > MAX_LEVEL_SIZE
      3  2d41				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__029_R
      4  2d41					      ENDIF
      0  2d41					      DEFL	_030_L, "6-5#|5#-#2-@#|#3-3#2$-#|#2-$-2.-$2#|3#-.*.*-2#|2-3#-.$2-#|4-#3-#-#|4-2#4-#|5-6#"
      0  2d41					      START_LEVEL	_030_L
      1  2d41				   LEVEL_START SET	*
      2  2d41		       00 05	   BANK_LEVEL__030_L =	_CURRENT_BANK
      3  2d41				   LEVEL__030_L SUBROUTINE
      4  2d41				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d41
      2  2d41		       36 2d 35 23*	      .byte.b	"6-5#|5#-#2-@#|#3-3#2$-#|#2-$-2.-$2#|3#-.*.*-2#|2-3#-.$2-#|4-#3-#-#|4-2#4-#|5-6#",0
      0  2d91					      END_LEVEL	_030_L
      1  2d91		       00 50	   LEVEL_SIZE__030_L =	* - LEVEL_START
      2  2d91				  -	      IF	LEVEL_SIZE__030_L > MAX_LEVEL_SIZE
      3  2d91				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__030_L
      4  2d91					      ENDIF
      0  2d91					      DEFL	_030_R, "-7#2-|2#-$2-.#2-|#-$-$#.#2-|#-#.$2.#2-|#-#3.$2#-|#2-$#*2-2#|3#2-*2$-#|2-#@5-#|2-8#"
      0  2d91					      START_LEVEL	_030_R
      1  2d91				   LEVEL_START SET	*
      2  2d91		       00 05	   BANK_LEVEL__030_R =	_CURRENT_BANK
      3  2d91				   LEVEL__030_R SUBROUTINE
      4  2d91				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d91
      2  2d91		       2d 37 23 32*	      .byte.b	"-7#2-|2#-$2-.#2-|#-$-$#.#2-|#-#.$2.#2-|#-#3.$2#-|#2-$#*2-2#|3#2-*2$-#|2-#@5-#|2-8#",0
      0  2de4					      END_LEVEL	_030_R
      1  2de4		       00 53	   LEVEL_SIZE__030_R =	* - LEVEL_START
      2  2de4				  -	      IF	LEVEL_SIZE__030_R > MAX_LEVEL_SIZE
      3  2de4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__030_R
      4  2de4					      ENDIF
      0  2de4					      DEFL	_031_L, "-7#2-|-#3-@-3#|-#-2$*2$-#|3#2-*.2-#|#2.2*.*2-#|#$#2-.2-2#|#3-5#-|5#5-"
      0  2de4					      START_LEVEL	_031_L
      1  2de4				   LEVEL_START SET	*
      2  2de4		       00 05	   BANK_LEVEL__031_L =	_CURRENT_BANK
      3  2de4				   LEVEL__031_L SUBROUTINE
      4  2de4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2de4
      2  2de4		       2d 37 23 32*	      .byte.b	"-7#2-|-#3-@-3#|-#-2$*2$-#|3#2-*.2-#|#2.2*.*2-#|#$#2-.2-2#|#3-5#-|5#5-",0
      0  2e2a					      END_LEVEL	_031_L
      1  2e2a		       00 46	   LEVEL_SIZE__031_L =	* - LEVEL_START
      2  2e2a				  -	      IF	LEVEL_SIZE__031_L > MAX_LEVEL_SIZE
      3  2e2a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__031_L
      4  2e2a					      ENDIF
      0  2e2a					      DEFL	_031_R, "6#-|#2-#+#-|#2-$.2#|#2-2*.#|#-$-.$#|#-$-*.#|#-2$.-#|#-$-.-#|7#"
      0  2e2a					      START_LEVEL	_031_R
      1  2e2a				   LEVEL_START SET	*
      2  2e2a		       00 05	   BANK_LEVEL__031_R =	_CURRENT_BANK
      3  2e2a				   LEVEL__031_R SUBROUTINE
      4  2e2a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e2a
      2  2e2a		       36 23 2d 7c*	      .byte.b	"6#-|#2-#+#-|#2-$.2#|#2-2*.#|#-$-.$#|#-$-*.#|#-2$.-#|#-$-.-#|7#",0
      0  2e69					      END_LEVEL	_031_R
      1  2e69		       00 3f	   LEVEL_SIZE__031_R =	* - LEVEL_START
      2  2e69				  -	      IF	LEVEL_SIZE__031_R > MAX_LEVEL_SIZE
      3  2e69				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__031_R
      4  2e69					      ENDIF
      0  2e69					      DEFL	_032_L, "-4#2-|-#2-3#|2#2-2.#|#@2$*.#|#-$2-.#|#-$-#*#|3#3-#|2-5#"
      0  2e69					      START_LEVEL	_032_L
      1  2e69				   LEVEL_START SET	*
      2  2e69		       00 05	   BANK_LEVEL__032_L =	_CURRENT_BANK
      3  2e69				   LEVEL__032_L SUBROUTINE
      4  2e69				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e69
      2  2e69		       2d 34 23 32*	      .byte.b	"-4#2-|-#2-3#|2#2-2.#|#@2$*.#|#-$2-.#|#-$-#*#|3#3-#|2-5#",0
      0  2ea1					      END_LEVEL	_032_L
      1  2ea1		       00 38	   LEVEL_SIZE__032_L =	* - LEVEL_START
      2  2ea1				  -	      IF	LEVEL_SIZE__032_L > MAX_LEVEL_SIZE
      3  2ea1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__032_L
      4  2ea1					      ENDIF
      0  2ea1					      DEFL	_032_R, "9#-|#7-2#|#-$3#-$@#|#2-2.#.$-#|#-.*.2*$-#|#-$.*2-$-#|#2-#.$-3#|8#2-"
      0  2ea1					      START_LEVEL	_032_R
      1  2ea1				   LEVEL_START SET	*
      2  2ea1		       00 05	   BANK_LEVEL__032_R =	_CURRENT_BANK
      3  2ea1				   LEVEL__032_R SUBROUTINE
      4  2ea1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ea1
      2  2ea1		       39 23 2d 7c*	      .byte.b	"9#-|#7-2#|#-$3#-$@#|#2-2.#.$-#|#-.*.2*$-#|#-$.*2-$-#|#2-#.$-3#|8#2-",0
      0  2ee5					      END_LEVEL	_032_R
      1  2ee5		       00 44	   LEVEL_SIZE__032_R =	* - LEVEL_START
      2  2ee5				  -	      IF	LEVEL_SIZE__032_R > MAX_LEVEL_SIZE
      3  2ee5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__032_R
      4  2ee5					      ENDIF
      0  2ee5					      DEFL	_033_L, "2-7#-|-2#2-#2-2#|-#2-.*-$-#|-#-$.$-$@#|2#$-2*-3#|#2-$*.*.#-|#3-2.3#-|7#3-"
      0  2ee5					      START_LEVEL	_033_L
      1  2ee5				   LEVEL_START SET	*
      2  2ee5		       00 05	   BANK_LEVEL__033_L =	_CURRENT_BANK
      3  2ee5				   LEVEL__033_L SUBROUTINE
      4  2ee5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ee5
      2  2ee5		       32 2d 37 23*	      .byte.b	"2-7#-|-2#2-#2-2#|-#2-.*-$-#|-#-$.$-$@#|2#$-2*-3#|#2-$*.*.#-|#3-2.3#-|7#3-",0
      0  2f2f					      END_LEVEL	_033_L
      1  2f2f		       00 4a	   LEVEL_SIZE__033_L =	* - LEVEL_START
      2  2f2f				  -	      IF	LEVEL_SIZE__033_L > MAX_LEVEL_SIZE
      3  2f2f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__033_L
      4  2f2f					      ENDIF
      0  2f2f					      DEFL	_033_R, "-7#2-|2#2-#@-2#-|#-$-#3-2#|#-$2-$*$-#|#2-*.*.2-#|2#.*2.-$-#|-9#"
      0  2f2f					      START_LEVEL	_033_R
      1  2f2f				   LEVEL_START SET	*
      2  2f2f		       00 05	   BANK_LEVEL__033_R =	_CURRENT_BANK
      3  2f2f				   LEVEL__033_R SUBROUTINE
      4  2f2f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2f2f
      2  2f2f		       2d 37 23 32*	      .byte.b	"-7#2-|2#2-#@-2#-|#-$-#3-2#|#-$2-$*$-#|#2-*.*.2-#|2#.*2.-$-#|-9#",0
      0  2f6f					      END_LEVEL	_033_R
      1  2f6f		       00 40	   LEVEL_SIZE__033_R =	* - LEVEL_START
      2  2f6f				  -	      IF	LEVEL_SIZE__033_R > MAX_LEVEL_SIZE
      3  2f6f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__033_R
      4  2f6f					      ENDIF
      0  2f6f					      DEFL	_034_L, "5-4#-|-5#2-#-|-#-$@$2-#-|2#-#*$.*2#|#3-.2*2.#|#2-$2-4#|4#2-#3-|3-#2-#3-|3-4#3-"
      0  2f6f					      START_LEVEL	_034_L
      1  2f6f				   LEVEL_START SET	*
      2  2f6f		       00 05	   BANK_LEVEL__034_L =	_CURRENT_BANK
      3  2f6f				   LEVEL__034_L SUBROUTINE
      4  2f6f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2f6f
      2  2f6f		       35 2d 34 23*	      .byte.b	"5-4#-|-5#2-#-|-#-$@$2-#-|2#-#*$.*2#|#3-.2*2.#|#2-$2-4#|4#2-#3-|3-#2-#3-|3-4#3-",0
      0  2fbe					      END_LEVEL	_034_L
      1  2fbe		       00 4f	   LEVEL_SIZE__034_L =	* - LEVEL_START
      2  2fbe				  -	      IF	LEVEL_SIZE__034_L > MAX_LEVEL_SIZE
      3  2fbe				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__034_L
      4  2fbe					      ENDIF
     65  2fbe
      0  2fbe					      CHECK_BANK_SIZE	"LEVELS2"
      1  2fbe		       07 be	   .TEMP      =	* - BANK_START
 LEVELS2 (2K) SIZE =  $7be , FREE= $42
      2  2fbe					      ECHO	"LEVELS2", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2fbe				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2fbe				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2fbe				  -	      ERR
      6  2fbe					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS3.asm LEVEL 2 PASS 3
      0  2fbe					      include	"BANK_LEVELS3.asm"
      1  2fbe							;    Sokoboo - a Sokoban implementation
      2  2fbe							;    using a generic tile-based display engine for the Atari 2600
      3  2fbe							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  2fbe							;
      5  2fbe							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  2fbe							;
      7  2fbe							;    Code related to the generic tile-based display engine was developed by
      8  2fbe							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  2fbe							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  2fbe							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  2fbe							;
     12  2fbe							;    Code related to music and sound effects uses the TIATracker music player
     13  2fbe							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  2fbe							;    directory for Apache licensing details.
     15  2fbe							;
     16  2fbe							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  2fbe							;    See the copyright notices in the License directory for a list of level
     18  2fbe							;    contributors.
     19  2fbe							;
     20  2fbe							;    Except where otherwise indicated, this software is released under the
     21  2fbe							;    following licensing arrangement...
     22  2fbe							;
     23  2fbe							;    This program is free software: you can redistribute it and/or modify
     24  2fbe							;    it under the terms of the GNU General Public License as published by
     25  2fbe							;    the Free Software Foundation, either version 3 of the License, or
     26  2fbe							;    (at your option) any later version.
     27  2fbe							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  2fbe
     29  2fbe							;    This program is distributed in the hope that it will be useful,
     30  2fbe							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  2fbe							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  2fbe							;    GNU General Public License for more details.
     33  2fbe
      0  2fbe					      NEWBANK	LEVELS3
      1  37c7 ????				      SEG	LEVELS3
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   LEVELS3    SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	LEVELS3
     35  3000
      0  3000					      DEFL	_034_R, "-6#3-|-#4-#3-|2#-$.-3#-|#-2$*.$@#-|#-3.#2$2#|4#.4-#|3-3#-#-#|5-#3-#|5-5#"
      0  3000					      START_LEVEL	_034_R
      1  3000				   LEVEL_START SET	*
      2  3000		       00 06	   BANK_LEVEL__034_R =	_CURRENT_BANK
      3  3000				   LEVEL__034_R SUBROUTINE
      4  3000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3000
      2  3000		       2d 36 23 33*	      .byte.b	"-6#3-|-#4-#3-|2#-$.-3#-|#-2$*.$@#-|#-3.#2$2#|4#.4-#|3-3#-#-#|5-#3-#|5-5#",0
      0  3049					      END_LEVEL	_034_R
      1  3049		       00 49	   LEVEL_SIZE__034_R =	* - LEVEL_START
      2  3049				  -	      IF	LEVEL_SIZE__034_R > MAX_LEVEL_SIZE
      3  3049				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__034_R
      4  3049					      ENDIF
      0  3049					      DEFL	_035_L, "5-3#2-|6#.2#-|#@2-2#*.#-|#-3$2.-#-|2#2-$*.$2#|-#-$2-.2-#|-5#3-#|5-5#"
      0  3049					      START_LEVEL	_035_L
      1  3049				   LEVEL_START SET	*
      2  3049		       00 06	   BANK_LEVEL__035_L =	_CURRENT_BANK
      3  3049				   LEVEL__035_L SUBROUTINE
      4  3049				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3049
      2  3049		       35 2d 33 23*	      .byte.b	"5-3#2-|6#.2#-|#@2-2#*.#-|#-3$2.-#-|2#2-$*.$2#|-#-$2-.2-#|-5#3-#|5-5#",0
      0  308e					      END_LEVEL	_035_L
      1  308e		       00 45	   LEVEL_SIZE__035_L =	* - LEVEL_START
      2  308e				  -	      IF	LEVEL_SIZE__035_L > MAX_LEVEL_SIZE
      3  308e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__035_L
      4  308e					      ENDIF
      0  308e					      DEFL	_035_R, "-11#|-#4-@4-#|-#-2$3*$#-#|3#-*.$.-$-#|#3-.*.-4#|#3-2#.2#3-|8#4-"
      0  308e					      START_LEVEL	_035_R
      1  308e				   LEVEL_START SET	*
      2  308e		       00 06	   BANK_LEVEL__035_R =	_CURRENT_BANK
      3  308e				   LEVEL__035_R SUBROUTINE
      4  308e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  308e
      2  308e		       2d 31 31 23*	      .byte.b	"-11#|-#4-@4-#|-#-2$3*$#-#|3#-*.$.-$-#|#3-.*.-4#|#3-2#.2#3-|8#4-",0
      0  30ce					      END_LEVEL	_035_R
      1  30ce		       00 40	   LEVEL_SIZE__035_R =	* - LEVEL_START
      2  30ce				  -	      IF	LEVEL_SIZE__035_R > MAX_LEVEL_SIZE
      3  30ce				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__035_R
      4  30ce					      ENDIF
      0  30ce					      DEFL	_036_L, "5#2-|#3-3#|#*#-$@#|#.2-$-#|#.*2$-#|#2.#2-#|4#2-#|3-4#"
      0  30ce					      START_LEVEL	_036_L
      1  30ce				   LEVEL_START SET	*
      2  30ce		       00 06	   BANK_LEVEL__036_L =	_CURRENT_BANK
      3  30ce				   LEVEL__036_L SUBROUTINE
      4  30ce				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  30ce
      2  30ce		       35 23 32 2d*	      .byte.b	"5#2-|#3-3#|#*#-$@#|#.2-$-#|#.*2$-#|#2.#2-#|4#2-#|3-4#",0
      0  3104					      END_LEVEL	_036_L
      1  3104		       00 36	   LEVEL_SIZE__036_L =	* - LEVEL_START
      2  3104				  -	      IF	LEVEL_SIZE__036_L > MAX_LEVEL_SIZE
      3  3104				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__036_L
      4  3104					      ENDIF
      0  3104					      DEFL	_036_R, "2-5#2-|-2#.2-2#-|-#.*-$-2#|2#2.$-$-#|#.2*.-$@#|#2-$2-$2#|3#4-#-|2-6#-"
      0  3104					      START_LEVEL	_036_R
      1  3104				   LEVEL_START SET	*
      2  3104		       00 06	   BANK_LEVEL__036_R =	_CURRENT_BANK
      3  3104				   LEVEL__036_R SUBROUTINE
      4  3104				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3104
      2  3104		       32 2d 35 23*	      .byte.b	"2-5#2-|-2#.2-2#-|-#.*-$-2#|2#2.$-$-#|#.2*.-$@#|#2-$2-$2#|3#4-#-|2-6#-",0
      0  314a					      END_LEVEL	_036_R
      1  314a		       00 46	   LEVEL_SIZE__036_R =	* - LEVEL_START
      2  314a				  -	      IF	LEVEL_SIZE__036_R > MAX_LEVEL_SIZE
      3  314a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__036_R
      4  314a					      ENDIF
      0  314a					      DEFL	_037_L, "5-6#|6#4-#|#2-#@2.2$-#|#2-$.3*.-#|#3-$.$-$-#|2#2-#.3-2#|-9#-"
      0  314a					      START_LEVEL	_037_L
      1  314a				   LEVEL_START SET	*
      2  314a		       00 06	   BANK_LEVEL__037_L =	_CURRENT_BANK
      3  314a				   LEVEL__037_L SUBROUTINE
      4  314a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  314a
      2  314a		       35 2d 36 23*	      .byte.b	"5-6#|6#4-#|#2-#@2.2$-#|#2-$.3*.-#|#3-$.$-$-#|2#2-#.3-2#|-9#-",0
      0  3187					      END_LEVEL	_037_L
      1  3187		       00 3d	   LEVEL_SIZE__037_L =	* - LEVEL_START
      2  3187				  -	      IF	LEVEL_SIZE__037_L > MAX_LEVEL_SIZE
      3  3187				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__037_L
      4  3187					      ENDIF
      0  3187					      DEFL	_037_R, "9#2-|#7-3#|#-$2-.2*.-#|2#-*.*$3-#|-2#-2*.#2-#|2-2#@$-$-2#|3-3#3-#-|5-5#-"
      0  3187					      START_LEVEL	_037_R
      1  3187				   LEVEL_START SET	*
      2  3187		       00 06	   BANK_LEVEL__037_R =	_CURRENT_BANK
      3  3187				   LEVEL__037_R SUBROUTINE
      4  3187				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3187
      2  3187		       39 23 32 2d*	      .byte.b	"9#2-|#7-3#|#-$2-.2*.-#|2#-*.*$3-#|-2#-2*.#2-#|2-2#@$-$-2#|3-3#3-#-|5-5#-",0
      0  31d0					      END_LEVEL	_037_R
      1  31d0		       00 49	   LEVEL_SIZE__037_R =	* - LEVEL_START
      2  31d0				  -	      IF	LEVEL_SIZE__037_R > MAX_LEVEL_SIZE
      3  31d0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__037_R
      4  31d0					      ENDIF
      0  31d0					      DEFL	_038_L, "6-4#2-|4-3#@-3#|3-2#2.*$2-#|4#.*.*3-#|#2-2$3-$2-#|#5-6#|3#2-2#5-|2-4#6-"
      0  31d0					      START_LEVEL	_038_L
      1  31d0				   LEVEL_START SET	*
      2  31d0		       00 06	   BANK_LEVEL__038_L =	_CURRENT_BANK
      3  31d0				   LEVEL__038_L SUBROUTINE
      4  31d0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  31d0
      2  31d0		       36 2d 34 23*	      .byte.b	"6-4#2-|4-3#@-3#|3-2#2.*$2-#|4#.*.*3-#|#2-2$3-$2-#|#5-6#|3#2-2#5-|2-4#6-",0
      0  3218					      END_LEVEL	_038_L
      1  3218		       00 48	   LEVEL_SIZE__038_L =	* - LEVEL_START
      2  3218				  -	      IF	LEVEL_SIZE__038_L > MAX_LEVEL_SIZE
      3  3218				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__038_L
      4  3218					      ENDIF
      0  3218					      DEFL	_038_R, "6-6#|4-3#.#-@#|2-3#2.*#$-#|3#-.*2.-$-#|#2-2$2-#-3#|#-$2-#-$-#2-|2#5-3#2-|-7#4-"
      0  3218					      START_LEVEL	_038_R
      1  3218				   LEVEL_START SET	*
      2  3218		       00 06	   BANK_LEVEL__038_R =	_CURRENT_BANK
      3  3218				   LEVEL__038_R SUBROUTINE
      4  3218				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3218
      2  3218		       36 2d 36 23*	      .byte.b	"6-6#|4-3#.#-@#|2-3#2.*#$-#|3#-.*2.-$-#|#2-2$2-#-3#|#-$2-#-$-#2-|2#5-3#2-|-7#4-",0
      0  3267					      END_LEVEL	_038_R
      1  3267		       00 4f	   LEVEL_SIZE__038_R =	* - LEVEL_START
      2  3267				  -	      IF	LEVEL_SIZE__038_R > MAX_LEVEL_SIZE
      3  3267				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__038_R
      4  3267					      ENDIF
      0  3267					      DEFL	_039_L, "-7#2-|-#5-#2-|2#-#-$-#2-|#.2*.-3#-|2#@3*2-2#|-2#-2.$2-#|2-2#$#-$-#|3-#5-#|3-7#"
      0  3267					      START_LEVEL	_039_L
      1  3267				   LEVEL_START SET	*
      2  3267		       00 06	   BANK_LEVEL__039_L =	_CURRENT_BANK
      3  3267				   LEVEL__039_L SUBROUTINE
      4  3267				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3267
      2  3267		       2d 37 23 32*	      .byte.b	"-7#2-|-#5-#2-|2#-#-$-#2-|#.2*.-3#-|2#@3*2-2#|-2#-2.$2-#|2-2#$#-$-#|3-#5-#|3-7#",0
      0  32b6					      END_LEVEL	_039_L
      1  32b6		       00 4f	   LEVEL_SIZE__039_L =	* - LEVEL_START
      2  32b6				  -	      IF	LEVEL_SIZE__039_L > MAX_LEVEL_SIZE
      3  32b6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__039_L
      4  32b6					      ENDIF
      0  32b6					      DEFL	_039_R, "4-4#4-|3-2#2-3#2-|2-2#-$.2-#2-|3#-.2*-$3#|#-$-4.3-#|#@$3#-#-#-#|2#4-$2-$-#|-5#3-3#|5-5#2-"
      0  32b6					      START_LEVEL	_039_R
      1  32b6				   LEVEL_START SET	*
      2  32b6		       00 06	   BANK_LEVEL__039_R =	_CURRENT_BANK
      3  32b6				   LEVEL__039_R SUBROUTINE
      4  32b6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  32b6
      2  32b6		       34 2d 34 23*	      .byte.b	"4-4#4-|3-2#2-3#2-|2-2#-$.2-#2-|3#-.2*-$3#|#-$-4.3-#|#@$3#-#-#-#|2#4-$2-$-#|-5#3-3#|5-5#2-",0
      0  3310					      END_LEVEL	_039_R
      1  3310		       00 5a	   LEVEL_SIZE__039_R =	* - LEVEL_START
      2  3310					      IF	LEVEL_SIZE__039_R > MAX_LEVEL_SIZE
      3  3310				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__039_R
      4  3310					      ENDIF
      0  3310					      DEFL	_040_L, "6#3-|#3-@#3-|#2-$.3#-|3#$*$.2#|3#-.2*.#|#2-$-.3#|#2-$3-#-|4#3-#-|3-5#-"
      0  3310					      START_LEVEL	_040_L
      1  3310				   LEVEL_START SET	*
      2  3310		       00 06	   BANK_LEVEL__040_L =	_CURRENT_BANK
      3  3310				   LEVEL__040_L SUBROUTINE
      4  3310				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3310
      2  3310		       36 23 33 2d*	      .byte.b	"6#3-|#3-@#3-|#2-$.3#-|3#$*$.2#|3#-.2*.#|#2-$-.3#|#2-$3-#-|4#3-#-|3-5#-",0
      0  3357					      END_LEVEL	_040_L
      1  3357		       00 47	   LEVEL_SIZE__040_L =	* - LEVEL_START
      2  3357				  -	      IF	LEVEL_SIZE__040_L > MAX_LEVEL_SIZE
      3  3357				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__040_L
      4  3357					      ENDIF
      0  3357					      DEFL	_040_R, "5-4#-|-5#2-2#|2#.-$2-$-#|#-2.*.$#@#|#-*-.2-$-#|2#-$*-4#|-#3-2#3-|-5#4-"
      0  3357					      START_LEVEL	_040_R
      1  3357				   LEVEL_START SET	*
      2  3357		       00 06	   BANK_LEVEL__040_R =	_CURRENT_BANK
      3  3357				   LEVEL__040_R SUBROUTINE
      4  3357				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3357
      2  3357		       35 2d 34 23*	      .byte.b	"5-4#-|-5#2-2#|2#.-$2-$-#|#-2.*.$#@#|#-*-.2-$-#|2#-$*-4#|-#3-2#3-|-5#4-",0
      0  339e					      END_LEVEL	_040_R
      1  339e		       00 47	   LEVEL_SIZE__040_R =	* - LEVEL_START
      2  339e				  -	      IF	LEVEL_SIZE__040_R > MAX_LEVEL_SIZE
      3  339e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__040_R
      4  339e					      ENDIF
     49  339e
      0  339e					      DEFL	_041_L, "4-3#5-|4-#.4#2-|5#*.$-#2-|#4-3.-3#|#-3$-*.$2-#|2#-@2#.$-$-#|-5#4-2#|5-6#-"
      0  339e					      START_LEVEL	_041_L
      1  339e				   LEVEL_START SET	*
      2  339e		       00 06	   BANK_LEVEL__041_L =	_CURRENT_BANK
      3  339e				   LEVEL__041_L SUBROUTINE
      4  339e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  339e
      2  339e		       34 2d 33 23*	      .byte.b	"4-3#5-|4-#.4#2-|5#*.$-#2-|#4-3.-3#|#-3$-*.$2-#|2#-@2#.$-$-#|-5#4-2#|5-6#-",0
      0  33e8					      END_LEVEL	_041_L
      1  33e8		       00 4a	   LEVEL_SIZE__041_L =	* - LEVEL_START
      2  33e8				  -	      IF	LEVEL_SIZE__041_L > MAX_LEVEL_SIZE
      3  33e8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__041_L
      4  33e8					      ENDIF
      0  33e8					      DEFL	_041_R, "-4#3-|2#2-3#-|#-@2$-#-|#-$-#.#-|2#$-2.2#|#2-$*2.#|#2-$-*2#|#3-#.#-|7#-"
      0  33e8					      START_LEVEL	_041_R
      1  33e8				   LEVEL_START SET	*
      2  33e8		       00 06	   BANK_LEVEL__041_R =	_CURRENT_BANK
      3  33e8				   LEVEL__041_R SUBROUTINE
      4  33e8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  33e8
      2  33e8		       2d 34 23 33*	      .byte.b	"-4#3-|2#2-3#-|#-@2$-#-|#-$-#.#-|2#$-2.2#|#2-$*2.#|#2-$-*2#|#3-#.#-|7#-",0
      0  342f					      END_LEVEL	_041_R
      1  342f		       00 47	   LEVEL_SIZE__041_R =	* - LEVEL_START
      2  342f				  -	      IF	LEVEL_SIZE__041_R > MAX_LEVEL_SIZE
      3  342f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__041_R
      4  342f					      ENDIF
      0  342f					      DEFL	_042_L, "8#4-|#6-#4-|#-#-$*-#4-|#-#-#.3#3-|#3-#2.-3#-|#3-2*4-2#|5#.-3$-#|4-4#2-@#|7-5#"
      0  342f					      START_LEVEL	_042_L
      1  342f				   LEVEL_START SET	*
      2  342f		       00 06	   BANK_LEVEL__042_L =	_CURRENT_BANK
      3  342f				   LEVEL__042_L SUBROUTINE
      4  342f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  342f
      2  342f		       38 23 34 2d*	      .byte.b	"8#4-|#6-#4-|#-#-$*-#4-|#-#-#.3#3-|#3-#2.-3#-|#3-2*4-2#|5#.-3$-#|4-4#2-@#|7-5#",0
      0  347d					      END_LEVEL	_042_L
      1  347d		       00 4e	   LEVEL_SIZE__042_L =	* - LEVEL_START
      2  347d				  -	      IF	LEVEL_SIZE__042_L > MAX_LEVEL_SIZE
      3  347d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__042_L
      4  347d					      ENDIF
      0  347d					      DEFL	_042_R, "3-5#4-|2-2#3-#4-|2-#-$-$#4-|3#-*.-2#3-|#@$-#.$-2#2-|#-$2-.*.-3#|3#2.*-$3-#|2-6#3-#|7-5#"
      0  347d					      START_LEVEL	_042_R
      1  347d				   LEVEL_START SET	*
      2  347d		       00 06	   BANK_LEVEL__042_R =	_CURRENT_BANK
      3  347d				   LEVEL__042_R SUBROUTINE
      4  347d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  347d
      2  347d		       33 2d 35 23*	      .byte.b	"3-5#4-|2-2#3-#4-|2-#-$-$#4-|3#-*.-2#3-|#@$-#.$-2#2-|#-$2-.*.-3#|3#2.*-$3-#|2-6#3-#|7-5#",0
      0  34d5					      END_LEVEL	_042_R
      1  34d5		       00 58	   LEVEL_SIZE__042_R =	* - LEVEL_START
      2  34d5				  -	      IF	LEVEL_SIZE__042_R > MAX_LEVEL_SIZE
      3  34d5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__042_R
      4  34d5					      ENDIF
      0  34d5					      DEFL	_043_L, "-8#4-|-#@$.-.-5#|-#2$*.2*.3-#|2#2-$-.2-#$-#|#-$-2#.#3-2#|#3-8#-|#2-2#8-|4#9-"
      0  34d5					      START_LEVEL	_043_L
      1  34d5				   LEVEL_START SET	*
      2  34d5		       00 06	   BANK_LEVEL__043_L =	_CURRENT_BANK
      3  34d5				   LEVEL__043_L SUBROUTINE
      4  34d5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  34d5
      2  34d5		       2d 38 23 34*	      .byte.b	"-8#4-|-#@$.-.-5#|-#2$*.2*.3-#|2#2-$-.2-#$-#|#-$-2#.#3-2#|#3-8#-|#2-2#8-|4#9-",0
      0  3522					      END_LEVEL	_043_L
      1  3522		       00 4d	   LEVEL_SIZE__043_L =	* - LEVEL_START
      2  3522				  -	      IF	LEVEL_SIZE__043_L > MAX_LEVEL_SIZE
      3  3522				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__043_L
      4  3522					      ENDIF
      0  3522					      DEFL	_043_R, "2-6#-|-2#4-#-|2#@$-#-#-|#-$#$2.#-|#*.*2.*2#|#-$2-$2.#|#-$-$2-2#|#4-3#-|6#3-"
      0  3522					      START_LEVEL	_043_R
      1  3522				   LEVEL_START SET	*
      2  3522		       00 06	   BANK_LEVEL__043_R =	_CURRENT_BANK
      3  3522				   LEVEL__043_R SUBROUTINE
      4  3522				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3522
      2  3522		       32 2d 36 23*	      .byte.b	"2-6#-|-2#4-#-|2#@$-#-#-|#-$#$2.#-|#*.*2.*2#|#-$2-$2.#|#-$-$2-2#|#4-3#-|6#3-",0
      0  356e					      END_LEVEL	_043_R
      1  356e		       00 4c	   LEVEL_SIZE__043_R =	* - LEVEL_START
      2  356e				  -	      IF	LEVEL_SIZE__043_R > MAX_LEVEL_SIZE
      3  356e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__043_R
      4  356e					      ENDIF
      0  356e					      DEFL	_044_L, "7#-|#@4-#-|#$-.2$#-|#3.*-2#|#*$2*2-#|#3-#2-#|#3-#2-#|8#"
      0  356e					      START_LEVEL	_044_L
      1  356e				   LEVEL_START SET	*
      2  356e		       00 06	   BANK_LEVEL__044_L =	_CURRENT_BANK
      3  356e				   LEVEL__044_L SUBROUTINE
      4  356e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  356e
      2  356e		       37 23 2d 7c*	      .byte.b	"7#-|#@4-#-|#$-.2$#-|#3.*-2#|#*$2*2-#|#3-#2-#|#3-#2-#|8#",0
      0  35a6					      END_LEVEL	_044_L
      1  35a6		       00 38	   LEVEL_SIZE__044_L =	* - LEVEL_START
      2  35a6				  -	      IF	LEVEL_SIZE__044_L > MAX_LEVEL_SIZE
      3  35a6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__044_L
      4  35a6					      ENDIF
      0  35a6					      DEFL	_044_R, "4#-4#-|#2-3#2-#-|#@$2-#-$2#|#$*$5-#|#-*2.$2#-#|#3.#4-#|2#-.-$4#|-3#2-#3-|3-4#3-"
      0  35a6					      START_LEVEL	_044_R
      1  35a6				   LEVEL_START SET	*
      2  35a6		       00 06	   BANK_LEVEL__044_R =	_CURRENT_BANK
      3  35a6				   LEVEL__044_R SUBROUTINE
      4  35a6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35a6
      2  35a6		       34 23 2d 34*	      .byte.b	"4#-4#-|#2-3#2-#-|#@$2-#-$2#|#$*$5-#|#-*2.$2#-#|#3.#4-#|2#-.-$4#|-3#2-#3-|3-4#3-",0
      0  35f6					      END_LEVEL	_044_R
      1  35f6		       00 50	   LEVEL_SIZE__044_R =	* - LEVEL_START
      2  35f6				  -	      IF	LEVEL_SIZE__044_R > MAX_LEVEL_SIZE
      3  35f6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__044_R
      4  35f6					      ENDIF
      0  35f6					      DEFL	_045_L, "3-4#2-|3-#2.3#|4#$.$-#|#@-#-.*-#|#-$2-2*.#|2#-$-*2-#|-2#-$3-#|2-2#2-3#|3-4#2-"
      0  35f6					      START_LEVEL	_045_L
      1  35f6				   LEVEL_START SET	*
      2  35f6		       00 06	   BANK_LEVEL__045_L =	_CURRENT_BANK
      3  35f6				   LEVEL__045_L SUBROUTINE
      4  35f6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35f6
      2  35f6		       33 2d 34 23*	      .byte.b	"3-4#2-|3-#2.3#|4#$.$-#|#@-#-.*-#|#-$2-2*.#|2#-$-*2-#|-2#-$3-#|2-2#2-3#|3-4#2-",0
      0  3644					      END_LEVEL	_045_L
      1  3644		       00 4e	   LEVEL_SIZE__045_L =	* - LEVEL_START
      2  3644				  -	      IF	LEVEL_SIZE__045_L > MAX_LEVEL_SIZE
      3  3644				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__045_L
      4  3644					      ENDIF
      0  3644					      DEFL	_045_R, "3-6#2-|4#4-#2-|#-$-$2#-3#|#-2$-$-$2-#|#-5.#$-#|#-.*#$2.2-#|2#.-$@5#|-6#4-"
      0  3644					      START_LEVEL	_045_R
      1  3644				   LEVEL_START SET	*
      2  3644		       00 06	   BANK_LEVEL__045_R =	_CURRENT_BANK
      3  3644				   LEVEL__045_R SUBROUTINE
      4  3644				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3644
      2  3644		       33 2d 36 23*	      .byte.b	"3-6#2-|4#4-#2-|#-$-$2#-3#|#-2$-$-$2-#|#-5.#$-#|#-.*#$2.2-#|2#.-$@5#|-6#4-",0
      0  368e					      END_LEVEL	_045_R
      1  368e		       00 4a	   LEVEL_SIZE__045_R =	* - LEVEL_START
      2  368e				  -	      IF	LEVEL_SIZE__045_R > MAX_LEVEL_SIZE
      3  368e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__045_R
      4  368e					      ENDIF
      0  368e					      DEFL	_046_L, "10#-|#@3-#3-2#|#-#*$2-2$-#|#-*.$-$3-#|3#.*$-#2-#|2-#.*.-4#|2-#2.-2#3-|2-5#4-"
      0  368e					      START_LEVEL	_046_L
      1  368e				   LEVEL_START SET	*
      2  368e		       00 06	   BANK_LEVEL__046_L =	_CURRENT_BANK
      3  368e				   LEVEL__046_L SUBROUTINE
      4  368e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  368e
      2  368e		       31 30 23 2d*	      .byte.b	"10#-|#@3-#3-2#|#-#*$2-2$-#|#-*.$-$3-#|3#.*$-#2-#|2-#.*.-4#|2-#2.-2#3-|2-5#4-",0
      0  36db					      END_LEVEL	_046_L
      1  36db		       00 4d	   LEVEL_SIZE__046_L =	* - LEVEL_START
      2  36db				  -	      IF	LEVEL_SIZE__046_L > MAX_LEVEL_SIZE
      3  36db				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__046_L
      4  36db					      ENDIF
      0  36db					      DEFL	_046_R, "8#3-|#3-4#3-|#-$2-$@3#-|#2-5$-#-|3#3.*2.2#|2-2#2-$3.#|3-#2-5#|3-4#4-"
      0  36db					      START_LEVEL	_046_R
      1  36db				   LEVEL_START SET	*
      2  36db		       00 06	   BANK_LEVEL__046_R =	_CURRENT_BANK
      3  36db				   LEVEL__046_R SUBROUTINE
      4  36db				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  36db
      2  36db		       38 23 33 2d*	      .byte.b	"8#3-|#3-4#3-|#-$2-$@3#-|#2-5$-#-|3#3.*2.2#|2-2#2-$3.#|3-#2-5#|3-4#4-",0
      0  3720					      END_LEVEL	_046_R
      1  3720		       00 45	   LEVEL_SIZE__046_R =	* - LEVEL_START
      2  3720				  -	      IF	LEVEL_SIZE__046_R > MAX_LEVEL_SIZE
      3  3720				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__046_R
      4  3720					      ENDIF
      0  3720					      DEFL	_047_L, "5-3#5-|3-3#.#5-|2-2#2-.#5-|2-#-$#.6#|3#3-.2#3-#|#-$@2*.$-$#-#|#4-2#-$3-#|8#3-2#|7-5#-"
      0  3720					      START_LEVEL	_047_L
      1  3720				   LEVEL_START SET	*
      2  3720		       00 06	   BANK_LEVEL__047_L =	_CURRENT_BANK
      3  3720				   LEVEL__047_L SUBROUTINE
      4  3720				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3720
      2  3720		       35 2d 33 23*	      .byte.b	"5-3#5-|3-3#.#5-|2-2#2-.#5-|2-#-$#.6#|3#3-.2#3-#|#-$@2*.$-$#-#|#4-2#-$3-#|8#3-2#|7-5#-",0
      0  3776					      END_LEVEL	_047_L
      1  3776		       00 56	   LEVEL_SIZE__047_L =	* - LEVEL_START
      2  3776				  -	      IF	LEVEL_SIZE__047_L > MAX_LEVEL_SIZE
      3  3776				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__047_L
      4  3776					      ENDIF
      0  3776					      DEFL	_047_R, "4-6#|3-2#3-@#|-3#-3$-#|-#.2-#-$-#|2#.*2-$2-#|#2.-2$#-2#|2#2.#-3#-|-#.3-#3-|-6#3-"
      0  3776					      START_LEVEL	_047_R
      1  3776				   LEVEL_START SET	*
      2  3776		       00 06	   BANK_LEVEL__047_R =	_CURRENT_BANK
      3  3776				   LEVEL__047_R SUBROUTINE
      4  3776				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3776
      2  3776		       34 2d 36 23*	      .byte.b	"4-6#|3-2#3-@#|-3#-3$-#|-#.2-#-$-#|2#.*2-$2-#|#2.-2$#-2#|2#2.#-3#-|-#.3-#3-|-6#3-",0
      0  37c7					      END_LEVEL	_047_R
      1  37c7		       00 51	   LEVEL_SIZE__047_R =	* - LEVEL_START
      2  37c7				  -	      IF	LEVEL_SIZE__047_R > MAX_LEVEL_SIZE
      3  37c7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__047_R
      4  37c7					      ENDIF
     64  37c7
     65  37c7
     66  37c7
      0  37c7					      CHECK_BANK_SIZE	"LEVELS3 -- full 2K"
      1  37c7		       07 c7	   .TEMP      =	* - BANK_START
 LEVELS3 -- full 2K (2K) SIZE =  $7c7 , FREE= $39
      2  37c7					      ECHO	"LEVELS3 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  37c7				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  37c7				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  37c7				  -	      ERR
      6  37c7					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS4.asm LEVEL 2 PASS 3
      0  37c7					      include	"BANK_LEVELS4.asm"
      1  37c7							;    Sokoboo - a Sokoban implementation
      2  37c7							;    using a generic tile-based display engine for the Atari 2600
      3  37c7							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  37c7							;
      5  37c7							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  37c7							;
      7  37c7							;    Code related to the generic tile-based display engine was developed by
      8  37c7							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  37c7							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  37c7							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  37c7							;
     12  37c7							;    Code related to music and sound effects uses the TIATracker music player
     13  37c7							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  37c7							;    directory for Apache licensing details.
     15  37c7							;
     16  37c7							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  37c7							;    See the copyright notices in the License directory for a list of level
     18  37c7							;    contributors.
     19  37c7							;
     20  37c7							;    Except where otherwise indicated, this software is released under the
     21  37c7							;    following licensing arrangement...
     22  37c7							;
     23  37c7							;    This program is free software: you can redistribute it and/or modify
     24  37c7							;    it under the terms of the GNU General Public License as published by
     25  37c7							;    the Free Software Foundation, either version 3 of the License, or
     26  37c7							;    (at your option) any later version.
     27  37c7							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  37c7
     29  37c7							;    This program is distributed in the hope that it will be useful,
     30  37c7							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  37c7							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  37c7							;    GNU General Public License for more details.
     33  37c7
     34  37c7							; level definitions
     35  37c7							; Sample level definitions.
     36  37c7							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  37c7							; have as many banks as you like.
     38  37c7
      0  37c7					      NEWBANK	LEVELS4
      1  3f4a ????				      SEG	LEVELS4
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   LEVELS4    SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	LEVELS4
     40  3800
      0  3800					      DEFL	_048_L, "2-7#-|2-#5-2#|3#$2-#2-#|#-$.3-$-#|#.2*2-4#|#+.#-2#3-|2#$3-#3-|-#4-#3-|-6#3-"
      0  3800					      START_LEVEL	_048_L
      1  3800				   LEVEL_START SET	*
      2  3800		       00 07	   BANK_LEVEL__048_L =	_CURRENT_BANK
      3  3800				   LEVEL__048_L SUBROUTINE
      4  3800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3800
      2  3800		       32 2d 37 23*	      .byte.b	"2-7#-|2-#5-2#|3#$2-#2-#|#-$.3-$-#|#.2*2-4#|#+.#-2#3-|2#$3-#3-|-#4-#3-|-6#3-",0
      0  384c					      END_LEVEL	_048_L
      1  384c		       00 4c	   LEVEL_SIZE__048_L =	* - LEVEL_START
      2  384c				  -	      IF	LEVEL_SIZE__048_L > MAX_LEVEL_SIZE
      3  384c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__048_L
      4  384c					      ENDIF
      0  384c					      DEFL	_048_R, "5-5#|2-4#3-#|3#-.$-$-#|#2-*3.3#|#2-*.-4#|2#2$*$3-#|-#@$.4-#|-4#2-3#|4-4#2-"
      0  384c					      START_LEVEL	_048_R
      1  384c				   LEVEL_START SET	*
      2  384c		       00 07	   BANK_LEVEL__048_R =	_CURRENT_BANK
      3  384c				   LEVEL__048_R SUBROUTINE
      4  384c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  384c
      2  384c		       35 2d 35 23*	      .byte.b	"5-5#|2-4#3-#|3#-.$-$-#|#2-*3.3#|#2-*.-4#|2#2$*$3-#|-#@$.4-#|-4#2-3#|4-4#2-",0
      0  3897					      END_LEVEL	_048_R
      1  3897		       00 4b	   LEVEL_SIZE__048_R =	* - LEVEL_START
      2  3897				  -	      IF	LEVEL_SIZE__048_R > MAX_LEVEL_SIZE
      3  3897				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__048_R
      4  3897					      ENDIF
      0  3897					      DEFL	_049_L, "4#7-|#2-4#4-|#2-$2-5#|#-$-#-4.#|2#-2$-.-.2#|-#$-#-*#-#-|-#-@#$-#-#-|-4#4-#-|4-6#-"
      0  3897					      START_LEVEL	_049_L
      1  3897				   LEVEL_START SET	*
      2  3897		       00 07	   BANK_LEVEL__049_L =	_CURRENT_BANK
      3  3897				   LEVEL__049_L SUBROUTINE
      4  3897				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3897
      2  3897		       34 23 37 2d*	      .byte.b	"4#7-|#2-4#4-|#2-$2-5#|#-$-#-4.#|2#-2$-.-.2#|-#$-#-*#-#-|-#-@#$-#-#-|-4#4-#-|4-6#-",0
      0  38e9					      END_LEVEL	_049_L
      1  38e9		       00 52	   LEVEL_SIZE__049_L =	* - LEVEL_START
      2  38e9				  -	      IF	LEVEL_SIZE__049_L > MAX_LEVEL_SIZE
      3  38e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__049_L
      4  38e9					      ENDIF
      0  38e9					      DEFL	_049_R, "8#2-|#6-3#|#-$2#$.*-#|#-$-$2.*+#|#3-#2.$-#|#-2$#-.3#|2#5-#2-|-7#2-"
      0  38e9					      START_LEVEL	_049_R
      1  38e9				   LEVEL_START SET	*
      2  38e9		       00 07	   BANK_LEVEL__049_R =	_CURRENT_BANK
      3  38e9				   LEVEL__049_R SUBROUTINE
      4  38e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  38e9
      2  38e9		       38 23 32 2d*	      .byte.b	"8#2-|#6-3#|#-$2#$.*-#|#-$-$2.*+#|#3-#2.$-#|#-2$#-.3#|2#5-#2-|-7#2-",0
      0  392c					      END_LEVEL	_049_R
      1  392c		       00 43	   LEVEL_SIZE__049_R =	* - LEVEL_START
      2  392c				  -	      IF	LEVEL_SIZE__049_R > MAX_LEVEL_SIZE
      3  392c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__049_R
      4  392c					      ENDIF
     45  392c
      0  392c					      DEFL	_050_L, "4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#"
      0  392c					      START_LEVEL	_050_L
      1  392c				   LEVEL_START SET	*
      2  392c		       00 07	   BANK_LEVEL__050_L =	_CURRENT_BANK
      3  392c				   LEVEL__050_L SUBROUTINE
      4  392c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  392c
      2  392c		       34 2d 35 23*	      .byte.b	"4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#",0
      0  3979					      END_LEVEL	_050_L
      1  3979		       00 4d	   LEVEL_SIZE__050_L =	* - LEVEL_START
      2  3979				  -	      IF	LEVEL_SIZE__050_L > MAX_LEVEL_SIZE
      3  3979				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_L
      4  3979					      ENDIF
      0  3979					      DEFL	_050_R, "8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#"
      0  3979					      START_LEVEL	_050_R
      1  3979				   LEVEL_START SET	*
      2  3979		       00 07	   BANK_LEVEL__050_R =	_CURRENT_BANK
      3  3979				   LEVEL__050_R SUBROUTINE
      4  3979				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3979
      2  3979		       38 23 7c 23*	      .byte.b	"8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#",0
      0  39b2					      END_LEVEL	_050_R
      1  39b2		       00 39	   LEVEL_SIZE__050_R =	* - LEVEL_START
      2  39b2				  -	      IF	LEVEL_SIZE__050_R > MAX_LEVEL_SIZE
      3  39b2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_R
      4  39b2					      ENDIF
      0  39b2					      DEFL	_051_L, "-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#"
      0  39b2					      START_LEVEL	_051_L
      1  39b2				   LEVEL_START SET	*
      2  39b2		       00 07	   BANK_LEVEL__051_L =	_CURRENT_BANK
      3  39b2				   LEVEL__051_L SUBROUTINE
      4  39b2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  39b2
      2  39b2		       2d 36 23 34*	      .byte.b	"-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#",0
      0  3a05					      END_LEVEL	_051_L
      1  3a05		       00 53	   LEVEL_SIZE__051_L =	* - LEVEL_START
      2  3a05				  -	      IF	LEVEL_SIZE__051_L > MAX_LEVEL_SIZE
      3  3a05				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_L
      4  3a05					      ENDIF
      0  3a05					      DEFL	_051_R, "-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-"
      0  3a05					      START_LEVEL	_051_R
      1  3a05				   LEVEL_START SET	*
      2  3a05		       00 07	   BANK_LEVEL__051_R =	_CURRENT_BANK
      3  3a05				   LEVEL__051_R SUBROUTINE
      4  3a05				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a05
      2  3a05		       2d 38 23 2d*	      .byte.b	"-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-",0
      0  3a56					      END_LEVEL	_051_R
      1  3a56		       00 51	   LEVEL_SIZE__051_R =	* - LEVEL_START
      2  3a56				  -	      IF	LEVEL_SIZE__051_R > MAX_LEVEL_SIZE
      3  3a56				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_R
      4  3a56					      ENDIF
      0  3a56					      DEFL	_052_L, "5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-"
      0  3a56					      START_LEVEL	_052_L
      1  3a56				   LEVEL_START SET	*
      2  3a56		       00 07	   BANK_LEVEL__052_L =	_CURRENT_BANK
      3  3a56				   LEVEL__052_L SUBROUTINE
      4  3a56				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a56
      2  3a56		       35 23 36 2d*	      .byte.b	"5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-",0
      0  3a90					      END_LEVEL	_052_L
      1  3a90		       00 3a	   LEVEL_SIZE__052_L =	* - LEVEL_START
      2  3a90				  -	      IF	LEVEL_SIZE__052_L > MAX_LEVEL_SIZE
      3  3a90				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_L
      4  3a90					      ENDIF
      0  3a90					      DEFL	_052_R, "2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-"
      0  3a90					      START_LEVEL	_052_R
      1  3a90				   LEVEL_START SET	*
      2  3a90		       00 07	   BANK_LEVEL__052_R =	_CURRENT_BANK
      3  3a90				   LEVEL__052_R SUBROUTINE
      4  3a90				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a90
      2  3a90		       32 2d 37 23*	      .byte.b	"2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-",0
      0  3ad8					      END_LEVEL	_052_R
      1  3ad8		       00 48	   LEVEL_SIZE__052_R =	* - LEVEL_START
      2  3ad8				  -	      IF	LEVEL_SIZE__052_R > MAX_LEVEL_SIZE
      3  3ad8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_R
      4  3ad8					      ENDIF
      0  3ad8					      DEFL	_053_L, "6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-"
      0  3ad8					      START_LEVEL	_053_L
      1  3ad8				   LEVEL_START SET	*
      2  3ad8		       00 07	   BANK_LEVEL__053_L =	_CURRENT_BANK
      3  3ad8				   LEVEL__053_L SUBROUTINE
      4  3ad8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ad8
      2  3ad8		       36 23 36 2d*	      .byte.b	"6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-",0
      0  3b2d					      END_LEVEL	_053_L
      1  3b2d		       00 55	   LEVEL_SIZE__053_L =	* - LEVEL_START
      2  3b2d				  -	      IF	LEVEL_SIZE__053_L > MAX_LEVEL_SIZE
      3  3b2d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_L
      4  3b2d					      ENDIF
      0  3b2d					      DEFL	_053_R, "5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-"
      0  3b2d					      START_LEVEL	_053_R
      1  3b2d				   LEVEL_START SET	*
      2  3b2d		       00 07	   BANK_LEVEL__053_R =	_CURRENT_BANK
      3  3b2d				   LEVEL__053_R SUBROUTINE
      4  3b2d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b2d
      2  3b2d		       35 2d 35 23*	      .byte.b	"5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-",0
      0  3b7a					      END_LEVEL	_053_R
      1  3b7a		       00 4d	   LEVEL_SIZE__053_R =	* - LEVEL_START
      2  3b7a				  -	      IF	LEVEL_SIZE__053_R > MAX_LEVEL_SIZE
      3  3b7a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_R
      4  3b7a					      ENDIF
      0  3b7a					      DEFL	_054_L, "-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-"
      0  3b7a					      START_LEVEL	_054_L
      1  3b7a				   LEVEL_START SET	*
      2  3b7a		       00 07	   BANK_LEVEL__054_L =	_CURRENT_BANK
      3  3b7a				   LEVEL__054_L SUBROUTINE
      4  3b7a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b7a
      2  3b7a		       2d 38 23 32*	      .byte.b	"-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-",0
      0  3bc6					      END_LEVEL	_054_L
      1  3bc6		       00 4c	   LEVEL_SIZE__054_L =	* - LEVEL_START
      2  3bc6				  -	      IF	LEVEL_SIZE__054_L > MAX_LEVEL_SIZE
      3  3bc6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_L
      4  3bc6					      ENDIF
      0  3bc6					      DEFL	_054_R, "2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-"
      0  3bc6					      START_LEVEL	_054_R
      1  3bc6				   LEVEL_START SET	*
      2  3bc6		       00 07	   BANK_LEVEL__054_R =	_CURRENT_BANK
      3  3bc6				   LEVEL__054_R SUBROUTINE
      4  3bc6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3bc6
      2  3bc6		       32 2d 34 23*	      .byte.b	"2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-",0
      0  3c0f					      END_LEVEL	_054_R
      1  3c0f		       00 49	   LEVEL_SIZE__054_R =	* - LEVEL_START
      2  3c0f				  -	      IF	LEVEL_SIZE__054_R > MAX_LEVEL_SIZE
      3  3c0f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_R
      4  3c0f					      ENDIF
      0  3c0f					      DEFL	_055_L, "2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-"
      0  3c0f					      START_LEVEL	_055_L
      1  3c0f				   LEVEL_START SET	*
      2  3c0f		       00 07	   BANK_LEVEL__055_L =	_CURRENT_BANK
      3  3c0f				   LEVEL__055_L SUBROUTINE
      4  3c0f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c0f
      2  3c0f		       32 2d 34 23*	      .byte.b	"2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-",0
      0  3c69					      END_LEVEL	_055_L
      1  3c69		       00 5a	   LEVEL_SIZE__055_L =	* - LEVEL_START
      2  3c69				  -	      IF	LEVEL_SIZE__055_L > MAX_LEVEL_SIZE
      3  3c69				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_L
      4  3c69					      ENDIF
      0  3c69					      DEFL	_055_R, "5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-"
      0  3c69					      START_LEVEL	_055_R
      1  3c69				   LEVEL_START SET	*
      2  3c69		       00 07	   BANK_LEVEL__055_R =	_CURRENT_BANK
      3  3c69				   LEVEL__055_R SUBROUTINE
      4  3c69				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c69
      2  3c69		       35 2d 34 23*	      .byte.b	"5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-",0
      0  3cbe					      END_LEVEL	_055_R
      1  3cbe		       00 55	   LEVEL_SIZE__055_R =	* - LEVEL_START
      2  3cbe				  -	      IF	LEVEL_SIZE__055_R > MAX_LEVEL_SIZE
      3  3cbe				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_R
      4  3cbe					      ENDIF
      0  3cbe					      DEFL	_056_L, "6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#"
      0  3cbe					      START_LEVEL	_056_L
      1  3cbe				   LEVEL_START SET	*
      2  3cbe		       00 07	   BANK_LEVEL__056_L =	_CURRENT_BANK
      3  3cbe				   LEVEL__056_L SUBROUTINE
      4  3cbe				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3cbe
      2  3cbe		       36 2d 35 23*	      .byte.b	"6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#",0
      0  3d18					      END_LEVEL	_056_L
      1  3d18		       00 5a	   LEVEL_SIZE__056_L =	* - LEVEL_START
      2  3d18				  -	      IF	LEVEL_SIZE__056_L > MAX_LEVEL_SIZE
      3  3d18				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_L
      4  3d18					      ENDIF
      0  3d18					      DEFL	_056_R, "-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-"
      0  3d18					      START_LEVEL	_056_R
      1  3d18				   LEVEL_START SET	*
      2  3d18		       00 07	   BANK_LEVEL__056_R =	_CURRENT_BANK
      3  3d18				   LEVEL__056_R SUBROUTINE
      4  3d18				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d18
      2  3d18		       2d 34 23 2d*	      .byte.b	"-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-",0
      0  3d73					      END_LEVEL	_056_R
      1  3d73		       00 5b	   LEVEL_SIZE__056_R =	* - LEVEL_START
      2  3d73					      IF	LEVEL_SIZE__056_R > MAX_LEVEL_SIZE
      3  3d73				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_R
      4  3d73					      ENDIF
      0  3d73					      DEFL	_057_L, "5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-"
      0  3d73					      START_LEVEL	_057_L
      1  3d73				   LEVEL_START SET	*
      2  3d73		       00 07	   BANK_LEVEL__057_L =	_CURRENT_BANK
      3  3d73				   LEVEL__057_L SUBROUTINE
      4  3d73				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d73
      2  3d73		       35 2d 36 23*	      .byte.b	"5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-",0
      0  3dc9					      END_LEVEL	_057_L
      1  3dc9		       00 56	   LEVEL_SIZE__057_L =	* - LEVEL_START
      2  3dc9				  -	      IF	LEVEL_SIZE__057_L > MAX_LEVEL_SIZE
      3  3dc9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_L
      4  3dc9					      ENDIF
      0  3dc9					      DEFL	_057_R, "5#4-|#3-3#2-|#+2.2-3#|#.#*$-$-#|#.#.-#$-#|#-$2-$2-#|2#$2#3-#|-#5-2#|-7#-"
      0  3dc9					      START_LEVEL	_057_R
      1  3dc9				   LEVEL_START SET	*
      2  3dc9		       00 07	   BANK_LEVEL__057_R =	_CURRENT_BANK
      3  3dc9				   LEVEL__057_R SUBROUTINE
      4  3dc9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3dc9
      2  3dc9		       35 23 34 2d*	      .byte.b	"5#4-|#3-3#2-|#+2.2-3#|#.#*$-$-#|#.#.-#$-#|#-$2-$2-#|2#$2#3-#|-#5-2#|-7#-",0
      0  3e12					      END_LEVEL	_057_R
      1  3e12		       00 49	   LEVEL_SIZE__057_R =	* - LEVEL_START
      2  3e12				  -	      IF	LEVEL_SIZE__057_R > MAX_LEVEL_SIZE
      3  3e12				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_R
      4  3e12					      ENDIF
      0  3e12					      DEFL	_058_L, "-6#4-|-#-3.5#|-#-#.*2#2-#|2#-.*$4-#|#-2$*-$-$-#|#@2-2#4-#|7#3-#|6-5#"
      0  3e12					      START_LEVEL	_058_L
      1  3e12				   LEVEL_START SET	*
      2  3e12		       00 07	   BANK_LEVEL__058_L =	_CURRENT_BANK
      3  3e12				   LEVEL__058_L SUBROUTINE
      4  3e12				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3e12
      2  3e12		       2d 36 23 34*	      .byte.b	"-6#4-|-#-3.5#|-#-#.*2#2-#|2#-.*$4-#|#-2$*-$-$-#|#@2-2#4-#|7#3-#|6-5#",0
      0  3e57					      END_LEVEL	_058_L
      1  3e57		       00 45	   LEVEL_SIZE__058_L =	* - LEVEL_START
      2  3e57				  -	      IF	LEVEL_SIZE__058_L > MAX_LEVEL_SIZE
      3  3e57				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__058_L
      4  3e57					      ENDIF
      0  3e57					      DEFL	_058_R, "4-5#-|3-2#3-#-|4#-.#$#-|#-$2-.#-#-|#@-3*.-2#|#-$.2-*2-#|3#*$#3-#|2-#4-3#|2-6#2-"
      0  3e57					      START_LEVEL	_058_R
      1  3e57				   LEVEL_START SET	*
      2  3e57		       00 07	   BANK_LEVEL__058_R =	_CURRENT_BANK
      3  3e57				   LEVEL__058_R SUBROUTINE
      4  3e57				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3e57
      2  3e57		       34 2d 35 23*	      .byte.b	"4-5#-|3-2#3-#-|4#-.#$#-|#-$2-.#-#-|#@-3*.-2#|#-$.2-*2-#|3#*$#3-#|2-#4-3#|2-6#2-",0
      0  3ea7					      END_LEVEL	_058_R
      1  3ea7		       00 50	   LEVEL_SIZE__058_R =	* - LEVEL_START
      2  3ea7				  -	      IF	LEVEL_SIZE__058_R > MAX_LEVEL_SIZE
      3  3ea7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__058_R
      4  3ea7					      ENDIF
      0  3ea7					      DEFL	_059_L, "6#5-|#4-#5-|#-$#-5#-|#4-.-$@#-|#-#-2*-#$2#|#-$.*-$3-#|2#$#.-2#2-#|-#-3.2#2-#|-10#"
      0  3ea7					      START_LEVEL	_059_L
      1  3ea7				   LEVEL_START SET	*
      2  3ea7		       00 07	   BANK_LEVEL__059_L =	_CURRENT_BANK
      3  3ea7				   LEVEL__059_L SUBROUTINE
      4  3ea7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ea7
      2  3ea7		       36 23 35 2d*	      .byte.b	"6#5-|#4-#5-|#-$#-5#-|#4-.-$@#-|#-#-2*-#$2#|#-$.*-$3-#|2#$#.-2#2-#|-#-3.2#2-#|-10#",0
      0  3ef9					      END_LEVEL	_059_L
      1  3ef9		       00 52	   LEVEL_SIZE__059_L =	* - LEVEL_START
      2  3ef9				  -	      IF	LEVEL_SIZE__059_L > MAX_LEVEL_SIZE
      3  3ef9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__059_L
      4  3ef9					      ENDIF
      0  3ef9					      DEFL	_059_R, "7-3#-|8#.#-|#4-#-2.2#|#-#-2$*.$-#|#5-2.#-#|2#2-2#-2#-#|#2-$-2$2#-#|#3-2#3-@#|11#"
      0  3ef9					      START_LEVEL	_059_R
      1  3ef9				   LEVEL_START SET	*
      2  3ef9		       00 07	   BANK_LEVEL__059_R =	_CURRENT_BANK
      3  3ef9				   LEVEL__059_R SUBROUTINE
      4  3ef9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ef9
      2  3ef9		       37 2d 33 23*	      .byte.b	"7-3#-|8#.#-|#4-#-2.2#|#-#-2$*.$-#|#5-2.#-#|2#2-2#-2#-#|#2-$-2$2#-#|#3-2#3-@#|11#",0
      0  3f4a					      END_LEVEL	_059_R
      1  3f4a		       00 51	   LEVEL_SIZE__059_R =	* - LEVEL_START
      2  3f4a				  -	      IF	LEVEL_SIZE__059_R > MAX_LEVEL_SIZE
      3  3f4a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__059_R
      4  3f4a					      ENDIF
     66  3f4a
      0  3f4a					      CHECK_BANK_SIZE	"LEVELS4 -- full 2K"
      1  3f4a		       07 4a	   .TEMP      =	* - BANK_START
 LEVELS4 -- full 2K (2K) SIZE =  $74a , FREE= $b6
      2  3f4a					      ECHO	"LEVELS4 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3f4a				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3f4a				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3f4a				  -	      ERR
      6  3f4a					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS5.asm LEVEL 2 PASS 3
      0  3f4a					      include	"BANK_LEVELS5.asm"
      1  3f4a							;    Sokoboo - a Sokoban implementation
      2  3f4a							;    using a generic tile-based display engine for the Atari 2600
      3  3f4a							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  3f4a							;
      5  3f4a							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  3f4a							;
      7  3f4a							;    Code related to the generic tile-based display engine was developed by
      8  3f4a							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  3f4a							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  3f4a							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  3f4a							;
     12  3f4a							;    Code related to music and sound effects uses the TIATracker music player
     13  3f4a							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  3f4a							;    directory for Apache licensing details.
     15  3f4a							;
     16  3f4a							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  3f4a							;    See the copyright notices in the License directory for a list of level
     18  3f4a							;    contributors.
     19  3f4a							;
     20  3f4a							;    Except where otherwise indicated, this software is released under the
     21  3f4a							;    following licensing arrangement...
     22  3f4a							;
     23  3f4a							;    This program is free software: you can redistribute it and/or modify
     24  3f4a							;    it under the terms of the GNU General Public License as published by
     25  3f4a							;    the Free Software Foundation, either version 3 of the License, or
     26  3f4a							;    (at your option) any later version.
     27  3f4a							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  3f4a
     29  3f4a							;    This program is distributed in the hope that it will be useful,
     30  3f4a							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  3f4a							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  3f4a							;    GNU General Public License for more details.
     33  3f4a
     34  3f4a							; level definitions
     35  3f4a							; Sample level definitions.
     36  3f4a							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  3f4a							; have as many banks as you like.
     38  3f4a
      0  3f4a					      NEWBANK	LEVELS5
      1  4675 ????				      SEG	LEVELS5
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   LEVELS5    SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	LEVELS5
     40  4000
      0  4000					      DEFL	_060_R, "3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#"
      0  4000					      START_LEVEL	_060_R
      1  4000				   LEVEL_START SET	*
      2  4000		       00 08	   BANK_LEVEL__060_R =	_CURRENT_BANK
      3  4000				   LEVEL__060_R SUBROUTINE
      4  4000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4000
      2  4000		       33 2d 36 23*	      .byte.b	"3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#",0
      0  4048					      END_LEVEL	_060_R
      1  4048		       00 48	   LEVEL_SIZE__060_R =	* - LEVEL_START
      2  4048				  -	      IF	LEVEL_SIZE__060_R > MAX_LEVEL_SIZE
      3  4048				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__060_R
      4  4048					      ENDIF
      0  4048					      DEFL	_061_L, "10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#"
      0  4048					      START_LEVEL	_061_L
      1  4048				   LEVEL_START SET	*
      2  4048		       00 08	   BANK_LEVEL__061_L =	_CURRENT_BANK
      3  4048				   LEVEL__061_L SUBROUTINE
      4  4048				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4048
      2  4048		       31 30 23 2d*	      .byte.b	"10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#",0
      0  409c					      END_LEVEL	_061_L
      1  409c		       00 54	   LEVEL_SIZE__061_L =	* - LEVEL_START
      2  409c				  -	      IF	LEVEL_SIZE__061_L > MAX_LEVEL_SIZE
      3  409c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_L
      4  409c					      ENDIF
      0  409c					      DEFL	_061_R, "4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#"
      0  409c					      START_LEVEL	_061_R
      1  409c				   LEVEL_START SET	*
      2  409c		       00 08	   BANK_LEVEL__061_R =	_CURRENT_BANK
      3  409c				   LEVEL__061_R SUBROUTINE
      4  409c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  409c
      2  409c		       34 2d 35 23*	      .byte.b	"4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#",0
      0  40e5					      END_LEVEL	_061_R
      1  40e5		       00 49	   LEVEL_SIZE__061_R =	* - LEVEL_START
      2  40e5				  -	      IF	LEVEL_SIZE__061_R > MAX_LEVEL_SIZE
      3  40e5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_R
      4  40e5					      ENDIF
      0  40e5					      DEFL	_062_L, "-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#"
      0  40e5					      START_LEVEL	_062_L
      1  40e5				   LEVEL_START SET	*
      2  40e5		       00 08	   BANK_LEVEL__062_L =	_CURRENT_BANK
      3  40e5				   LEVEL__062_L SUBROUTINE
      4  40e5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  40e5
      2  40e5		       2d 35 23 36*	      .byte.b	"-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#",0
      0  413c					      END_LEVEL	_062_L
      1  413c		       00 57	   LEVEL_SIZE__062_L =	* - LEVEL_START
      2  413c				  -	      IF	LEVEL_SIZE__062_L > MAX_LEVEL_SIZE
      3  413c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_L
      4  413c					      ENDIF
      0  413c					      DEFL	_062_R, "5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-"
      0  413c					      START_LEVEL	_062_R
      1  413c				   LEVEL_START SET	*
      2  413c		       00 08	   BANK_LEVEL__062_R =	_CURRENT_BANK
      3  413c				   LEVEL__062_R SUBROUTINE
      4  413c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  413c
      2  413c		       35 2d 35 23*	      .byte.b	"5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-",0
      0  4188					      END_LEVEL	_062_R
      1  4188		       00 4c	   LEVEL_SIZE__062_R =	* - LEVEL_START
      2  4188				  -	      IF	LEVEL_SIZE__062_R > MAX_LEVEL_SIZE
      3  4188				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_R
      4  4188					      ENDIF
      0  4188					      DEFL	_063_L, "2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#"
      0  4188					      START_LEVEL	_063_L
      1  4188				   LEVEL_START SET	*
      2  4188		       00 08	   BANK_LEVEL__063_L =	_CURRENT_BANK
      3  4188				   LEVEL__063_L SUBROUTINE
      4  4188				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4188
      2  4188		       32 2d 35 23*	      .byte.b	"2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#",0
      0  41d8					      END_LEVEL	_063_L
      1  41d8		       00 50	   LEVEL_SIZE__063_L =	* - LEVEL_START
      2  41d8				  -	      IF	LEVEL_SIZE__063_L > MAX_LEVEL_SIZE
      3  41d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_L
      4  41d8					      ENDIF
      0  41d8					      DEFL	_063_R, "2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-"
      0  41d8					      START_LEVEL	_063_R
      1  41d8				   LEVEL_START SET	*
      2  41d8		       00 08	   BANK_LEVEL__063_R =	_CURRENT_BANK
      3  41d8				   LEVEL__063_R SUBROUTINE
      4  41d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  41d8
      2  41d8		       32 2d 36 23*	      .byte.b	"2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-",0
      0  422a					      END_LEVEL	_063_R
      1  422a		       00 52	   LEVEL_SIZE__063_R =	* - LEVEL_START
      2  422a				  -	      IF	LEVEL_SIZE__063_R > MAX_LEVEL_SIZE
      3  422a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_R
      4  422a					      ENDIF
      0  422a					      DEFL	_064_L, "-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-"
      0  422a					      START_LEVEL	_064_L
      1  422a				   LEVEL_START SET	*
      2  422a		       00 08	   BANK_LEVEL__064_L =	_CURRENT_BANK
      3  422a				   LEVEL__064_L SUBROUTINE
      4  422a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  422a
      2  422a		       2d 38 23 33*	      .byte.b	"-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-",0
      0  4285					      END_LEVEL	_064_L
      1  4285		       00 5b	   LEVEL_SIZE__064_L =	* - LEVEL_START
      2  4285				  -	      IF	LEVEL_SIZE__064_L > MAX_LEVEL_SIZE
      3  4285				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_L
      4  4285					      ENDIF
      0  4285					      DEFL	_064_R, "4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-"
      0  4285					      START_LEVEL	_064_R
      1  4285				   LEVEL_START SET	*
      2  4285		       00 08	   BANK_LEVEL__064_R =	_CURRENT_BANK
      3  4285				   LEVEL__064_R SUBROUTINE
      4  4285				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4285
      2  4285		       34 23 2d 36*	      .byte.b	"4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-",0
      0  42d1					      END_LEVEL	_064_R
      1  42d1		       00 4c	   LEVEL_SIZE__064_R =	* - LEVEL_START
      2  42d1				  -	      IF	LEVEL_SIZE__064_R > MAX_LEVEL_SIZE
      3  42d1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_R
      4  42d1					      ENDIF
      0  42d1					      DEFL	_065_L, "2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-"
      0  42d1					      START_LEVEL	_065_L
      1  42d1				   LEVEL_START SET	*
      2  42d1		       00 08	   BANK_LEVEL__065_L =	_CURRENT_BANK
      3  42d1				   LEVEL__065_L SUBROUTINE
      4  42d1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  42d1
      2  42d1		       32 2d 35 23*	      .byte.b	"2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-",0
      0  4329					      END_LEVEL	_065_L
      1  4329		       00 58	   LEVEL_SIZE__065_L =	* - LEVEL_START
      2  4329				  -	      IF	LEVEL_SIZE__065_L > MAX_LEVEL_SIZE
      3  4329				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_L
      4  4329					      ENDIF
      0  4329					      DEFL	_065_R, "3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#"
      0  4329					      START_LEVEL	_065_R
      1  4329				   LEVEL_START SET	*
      2  4329		       00 08	   BANK_LEVEL__065_R =	_CURRENT_BANK
      3  4329				   LEVEL__065_R SUBROUTINE
      4  4329				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4329
      2  4329		       33 2d 35 23*	      .byte.b	"3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#",0
      0  4371					      END_LEVEL	_065_R
      1  4371		       00 48	   LEVEL_SIZE__065_R =	* - LEVEL_START
      2  4371				  -	      IF	LEVEL_SIZE__065_R > MAX_LEVEL_SIZE
      3  4371				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_R
      4  4371					      ENDIF
      0  4371					      DEFL	_066_L, "10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-"
      0  4371					      START_LEVEL	_066_L
      1  4371				   LEVEL_START SET	*
      2  4371		       00 08	   BANK_LEVEL__066_L =	_CURRENT_BANK
      3  4371				   LEVEL__066_L SUBROUTINE
      4  4371				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4371
      2  4371		       31 30 23 33*	      .byte.b	"10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-",0
      0  43cb					      END_LEVEL	_066_L
      1  43cb		       00 5a	   LEVEL_SIZE__066_L =	* - LEVEL_START
      2  43cb				  -	      IF	LEVEL_SIZE__066_L > MAX_LEVEL_SIZE
      3  43cb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_L
      4  43cb					      ENDIF
      0  43cb					      DEFL	_066_R, "2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#"
      0  43cb					      START_LEVEL	_066_R
      1  43cb				   LEVEL_START SET	*
      2  43cb		       00 08	   BANK_LEVEL__066_R =	_CURRENT_BANK
      3  43cb				   LEVEL__066_R SUBROUTINE
      4  43cb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  43cb
      2  43cb		       32 2d 35 23*	      .byte.b	"2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#",0
      0  4421					      END_LEVEL	_066_R
      1  4421		       00 56	   LEVEL_SIZE__066_R =	* - LEVEL_START
      2  4421				  -	      IF	LEVEL_SIZE__066_R > MAX_LEVEL_SIZE
      3  4421				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_R
      4  4421					      ENDIF
      0  4421					      DEFL	_067_L, "8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#"
      0  4421					      START_LEVEL	_067_L
      1  4421				   LEVEL_START SET	*
      2  4421		       00 08	   BANK_LEVEL__067_L =	_CURRENT_BANK
      3  4421				   LEVEL__067_L SUBROUTINE
      4  4421				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4421
      2  4421		       38 23 33 2d*	      .byte.b	"8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#",0
      0  446e					      END_LEVEL	_067_L
      1  446e		       00 4d	   LEVEL_SIZE__067_L =	* - LEVEL_START
      2  446e				  -	      IF	LEVEL_SIZE__067_L > MAX_LEVEL_SIZE
      3  446e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_L
      4  446e					      ENDIF
      0  446e					      DEFL	_067_R, "7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-"
      0  446e					      START_LEVEL	_067_R
      1  446e				   LEVEL_START SET	*
      2  446e		       00 08	   BANK_LEVEL__067_R =	_CURRENT_BANK
      3  446e				   LEVEL__067_R SUBROUTINE
      4  446e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  446e
      2  446e		       37 23 32 2d*	      .byte.b	"7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-",0
      0  44d3					      END_LEVEL	_067_R
      1  44d3		       00 65	   LEVEL_SIZE__067_R =	* - LEVEL_START
      2  44d3					      IF	LEVEL_SIZE__067_R > MAX_LEVEL_SIZE
      3  44d3				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_R
      4  44d3					      ENDIF
      0  44d3					      DEFL	_068_L, "10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-"
      0  44d3					      START_LEVEL	_068_L
      1  44d3				   LEVEL_START SET	*
      2  44d3		       00 08	   BANK_LEVEL__068_L =	_CURRENT_BANK
      3  44d3				   LEVEL__068_L SUBROUTINE
      4  44d3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  44d3
      2  44d3		       31 30 23 7c*	      .byte.b	"10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-",0
      0  4527					      END_LEVEL	_068_L
      1  4527		       00 54	   LEVEL_SIZE__068_L =	* - LEVEL_START
      2  4527				  -	      IF	LEVEL_SIZE__068_L > MAX_LEVEL_SIZE
      3  4527				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_L
      4  4527					      ENDIF
      0  4527					      DEFL	_068_R, "5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-"
      0  4527					      START_LEVEL	_068_R
      1  4527				   LEVEL_START SET	*
      2  4527		       00 08	   BANK_LEVEL__068_R =	_CURRENT_BANK
      3  4527				   LEVEL__068_R SUBROUTINE
      4  4527				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4527
      2  4527		       35 2d 35 23*	      .byte.b	"5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-",0
      0  457d					      END_LEVEL	_068_R
      1  457d		       00 56	   LEVEL_SIZE__068_R =	* - LEVEL_START
      2  457d				  -	      IF	LEVEL_SIZE__068_R > MAX_LEVEL_SIZE
      3  457d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_R
      4  457d					      ENDIF
      0  457d					      DEFL	_069_L, "-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#"
      0  457d					      START_LEVEL	_069_L
      1  457d				   LEVEL_START SET	*
      2  457d		       00 08	   BANK_LEVEL__069_L =	_CURRENT_BANK
      3  457d				   LEVEL__069_L SUBROUTINE
      4  457d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  457d
      2  457d		       2d 36 23 33*	      .byte.b	"-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#",0
      0  45cb					      END_LEVEL	_069_L
      1  45cb		       00 4e	   LEVEL_SIZE__069_L =	* - LEVEL_START
      2  45cb				  -	      IF	LEVEL_SIZE__069_L > MAX_LEVEL_SIZE
      3  45cb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_L
      4  45cb					      ENDIF
      0  45cb					      DEFL	_069_R, "2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-"
      0  45cb					      START_LEVEL	_069_R
      1  45cb				   LEVEL_START SET	*
      2  45cb		       00 08	   BANK_LEVEL__069_R =	_CURRENT_BANK
      3  45cb				   LEVEL__069_R SUBROUTINE
      4  45cb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  45cb
      2  45cb		       32 2d 35 23*	      .byte.b	"2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-",0
      0  4619					      END_LEVEL	_069_R
      1  4619		       00 4e	   LEVEL_SIZE__069_R =	* - LEVEL_START
      2  4619				  -	      IF	LEVEL_SIZE__069_R > MAX_LEVEL_SIZE
      3  4619				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_R
      4  4619					      ENDIF
     60  4619
      0  4619					      DEFL	_122_Maya, "14#|4#3-3#2-2#|#-$-$2-2#3-2#|#.2-$4#$2-2#|#.*2-$3-$-3#|#*.#$*.$-#2$-#|#6.*-#-@-#|2#4-8#|14#"
      0  4619					      START_LEVEL	_122_Maya
      1  4619				   LEVEL_START SET	*
      2  4619		       00 08	   BANK_LEVEL__122_Maya =	_CURRENT_BANK
      3  4619				   LEVEL__122_Maya SUBROUTINE
      4  4619				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4619
      2  4619		       31 34 23 7c*	      .byte.b	"14#|4#3-3#2-2#|#-$-$2-2#3-2#|#.2-$4#$2-2#|#.*2-$3-$-3#|#*.#$*.$-#2$-#|#6.*-#-@-#|2#4-8#|14#",0
      0  4675					      END_LEVEL	_122_Maya
      1  4675		       00 5c	   LEVEL_SIZE__122_Maya =	* - LEVEL_START
      2  4675				  -	      IF	LEVEL_SIZE__122_Maya > MAX_LEVEL_SIZE
      3  4675				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__122_Maya
      4  4675					      ENDIF
     62  4675
      0  4675					      CHECK_BANK_SIZE	"LEVELS5 -- full 2K"
      1  4675		       06 75	   .TEMP      =	* - BANK_START
 LEVELS5 -- full 2K (2K) SIZE =  $675 , FREE= $18b
      2  4675					      ECHO	"LEVELS5 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4675				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4675				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4675				  -	      ERR
      6  4675					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS6.asm LEVEL 2 PASS 3
      0  4675					      include	"BANK_LEVELS6.asm"
      1  4675							;    Sokoboo - a Sokoban implementation
      2  4675							;    using a generic tile-based display engine for the Atari 2600
      3  4675							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  4675							;
      5  4675							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  4675							;
      7  4675							;    Code related to the generic tile-based display engine was developed by
      8  4675							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  4675							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  4675							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  4675							;
     12  4675							;    Code related to music and sound effects uses the TIATracker music player
     13  4675							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  4675							;    directory for Apache licensing details.
     15  4675							;
     16  4675							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  4675							;    See the copyright notices in the License directory for a list of level
     18  4675							;    contributors.
     19  4675							;
     20  4675							;    Except where otherwise indicated, this software is released under the
     21  4675							;    following licensing arrangement...
     22  4675							;
     23  4675							;    This program is free software: you can redistribute it and/or modify
     24  4675							;    it under the terms of the GNU General Public License as published by
     25  4675							;    the Free Software Foundation, either version 3 of the License, or
     26  4675							;    (at your option) any later version.
     27  4675							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  4675
     29  4675							;    This program is distributed in the hope that it will be useful,
     30  4675							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  4675							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  4675							;    GNU General Public License for more details.
     33  4675
     34  4675							; level definitions
     35  4675							; Sample level definitions.
     36  4675							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  4675							; have as many banks as you like.
     38  4675
      0  4675					      NEWBANK	LEVELS6
      1  4d9f ????				      SEG	LEVELS6
      2  4800					      ORG	ORIGIN
      3  4800					      RORG	$F000
      4  4800				   BANK_START SET	*
      5  4800				   LEVELS6    SET	ORIGIN / 2048
      6  4800				   ORIGIN     SET	ORIGIN + 2048
      7  4800				   _CURRENT_BANK SET	LEVELS6
     40  4800
     41  4800
     42  4800							; Level definitions
     43  4800
     44  4800							; "sokhard" collection
     45  4800
      0  4800					      START_LEVEL	_102_Natalie
      1  4800				   LEVEL_START SET	*
      2  4800		       00 09	   BANK_LEVEL__102_Natalie =	_CURRENT_BANK
      3  4800				   LEVEL__102_Natalie SUBROUTINE
      4  4800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4800
     47  4800		       31 31 23 7c*	      .byte.b	"11#|2#2-#@4.#|2#3-2$.2*#|2#-$2-2$#.#|#2-$#-#2-.#|#2-$-#-2#-#|#9-#|11#",0
      0  4846					      END_LEVEL	_102_Natalie
      1  4846		       00 46	   LEVEL_SIZE__102_Natalie =	* - LEVEL_START
      2  4846				  -	      IF	LEVEL_SIZE__102_Natalie > MAX_LEVEL_SIZE
      3  4846				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Natalie
      4  4846					      ENDIF
     49  4846
      0  4846					      START_LEVEL	_102_Mirabel
      1  4846				   LEVEL_START SET	*
      2  4846		       00 09	   BANK_LEVEL__102_Mirabel =	_CURRENT_BANK
      3  4846				   LEVEL__102_Mirabel SUBROUTINE
      4  4846				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4846
     51  4846		       31 31 23 7c*	      .byte.b	"11#|6#3-2#|2#2-2#$2-2#|2#2-#-2$-2#|#7-3#|#.-#$-#-3#|#.#.-#2-$-#|#3.#-2$#@#|#-2.4-$-#|#2-8#|11#",0
      0  48a5					      END_LEVEL	_102_Mirabel
      1  48a5		       00 5f	   LEVEL_SIZE__102_Mirabel =	* - LEVEL_START
      2  48a5				  -	      IF	LEVEL_SIZE__102_Mirabel > MAX_LEVEL_SIZE
      3  48a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Mirabel
      4  48a5					      ENDIF
     53  48a5
      0  48a5					      START_LEVEL	_102_Oralia
      1  48a5				   LEVEL_START SET	*
      2  48a5		       00 09	   BANK_LEVEL__102_Oralia =	_CURRENT_BANK
      3  48a5				   LEVEL__102_Oralia SUBROUTINE
      4  48a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  48a5
     55  48a5		       39 23 7c 23*	      .byte.b	"9#|#2.$.#2-#|#4.2*-#|#-$.2#2-#|2#-$2-$-#|4#$-$-#|#-$3-$-#|#5-#@#|9#",0
      0  48e9					      END_LEVEL	_102_Oralia
      1  48e9		       00 44	   LEVEL_SIZE__102_Oralia =	* - LEVEL_START
      2  48e9				  -	      IF	LEVEL_SIZE__102_Oralia > MAX_LEVEL_SIZE
      3  48e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Oralia
      4  48e9					      ENDIF
     57  48e9
     58  48e9
     59  48e9							;---------------------------------------------------------------------------------------------------
     60  48e9							; IMAGE IS ABOVE DEFINITION
     61  48e9
     62  48e9							;  ###########
     63  48e9							;  #  #      #
     64  48e9							;  # $# $ $$ #
     65  48e9							;  #  ##$#$  #
     66  48e9							;  #  $    #@#
     67  48e9							;  # $## #  ##
     68  48e9							;  ##	# .## #
     69  48e9							;  ##$ #.*. ##
     70  48e9							;  # ..*. *. #
     71  48e9							;  # # .. #  #
     72  48e9							;  ###########
     73  48e9
      0  48e9					      START_LEVEL	_102_Raven
      1  48e9				   LEVEL_START SET	*
      2  48e9		       00 09	   BANK_LEVEL__102_Raven =	_CURRENT_BANK
      3  48e9				   LEVEL__102_Raven SUBROUTINE
      4  48e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  48e9
     75  48e9		       31 31 23 7c*	      .byte.b	"11#|#2-#6-#|#-$#-$-2$-#|#2-2#$#$2-#|#2-$4-#@#|#-$2#-#2-2#|2#2-#-.2#-#|2#$-#.*.-2#|#-2.*.-*.-#|#-#-2.-#2-#|11#",0
      0  4957					      END_LEVEL	_102_Raven
      1  4957		       00 6e	   LEVEL_SIZE__102_Raven =	* - LEVEL_START
      2  4957					      IF	LEVEL_SIZE__102_Raven > MAX_LEVEL_SIZE
      3  4957				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Raven
      4  4957					      ENDIF
     77  4957
     78  4957							;  ############
     79  4957							;  #@##. #  # #
     80  4957							;  #**..$#    #
     81  4957							;  #. $..#  # #
     82  4957							;  # $#.$#$$$ #
     83  4957							;  #	      ##
     84  4957							;  #  ##  #   #
     85  4957							;  ############
     86  4957
      0  4957					      START_LEVEL	_103_Adin
      1  4957				   LEVEL_START SET	*
      2  4957		       00 09	   BANK_LEVEL__103_Adin =	_CURRENT_BANK
      3  4957				   LEVEL__103_Adin SUBROUTINE
      4  4957				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4957
     88  4957		       31 32 23 7c*	      .byte.b	"12#|#@2#.-#2-#-#|#2*2.$#4-#|#.-$2.#2-#-#|#-$#.$#3$-#|#9-2#|#2-2#2-#3-#|12#",0
      0  49a2					      END_LEVEL	_103_Adin
      1  49a2		       00 4b	   LEVEL_SIZE__103_Adin =	* - LEVEL_START
      2  49a2				  -	      IF	LEVEL_SIZE__103_Adin > MAX_LEVEL_SIZE
      3  49a2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Adin
      4  49a2					      ENDIF
     90  49a2
     91  49a2							;  #######___
     92  49a2							;  #	  #___
     93  49a2							;  #	$$#___
     94  49a2							;  #.*  .#___
     95  49a2							;  #$*$#*###_
     96  49a2							;  #@*... .#_
     97  49a2							;  #####$ .##
     98  49a2							;  ___# $ $ #
     99  49a2							;  ___#     #
    100  49a2							;  ___#######	(_ = modified by boo from wall)
    101  49a2
      0  49a2					      START_LEVEL	_103_Ajalae
      1  49a2				   LEVEL_START SET	*
      2  49a2		       00 09	   BANK_LEVEL__103_Ajalae =	_CURRENT_BANK
      3  49a2				   LEVEL__103_Ajalae SUBROUTINE
      4  49a2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  49a2
    103  49a2		       37 23 7c 23*	      .byte.b	"7#|#5-#|#3-2$#|#.*2-.#|#$*$#*3#|#@*3.-.#|5#$-.2#|3-#-$-$-#|3-#5-#|3-7#",0
      0  49e9					      END_LEVEL	_103_Ajalae
      1  49e9		       00 47	   LEVEL_SIZE__103_Ajalae =	* - LEVEL_START
      2  49e9				  -	      IF	LEVEL_SIZE__103_Ajalae > MAX_LEVEL_SIZE
      3  49e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Ajalae
      4  49e9					      ENDIF
    105  49e9
    106  49e9							;  ############
    107  49e9							;  #@#  #     #
    108  49e9							;  #  # #$#$# #
    109  49e9							;  # *$       #
    110  49e9							;  #..##$#$   #
    111  49e9							;  #..#. #  $ #
    112  49e9							;  #....# $$$##
    113  49e9							;  #	       #
    114  49e9							;  ############
    115  49e9
      0  49e9					      START_LEVEL	_103_Arielle
      1  49e9				   LEVEL_START SET	*
      2  49e9		       00 09	   BANK_LEVEL__103_Arielle =	_CURRENT_BANK
      3  49e9				   LEVEL__103_Arielle SUBROUTINE
      4  49e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  49e9
    117  49e9		       31 32 23 7c*	      .byte.b	"12#|#@#2-#5-#|#2-#-#$#$#-#|#-*$7-#|#2.2#$#$3-#|#2.#.-#2-$-#|#4.#-3$2#|#10-#|12#",0
      0  4a39					      END_LEVEL	_103_Arielle
      1  4a39		       00 50	   LEVEL_SIZE__103_Arielle =	* - LEVEL_START
      2  4a39				  -	      IF	LEVEL_SIZE__103_Arielle > MAX_LEVEL_SIZE
      3  4a39				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Arielle
      4  4a39					      ENDIF
    119  4a39
    120  4a39
    121  4a39
      0  4a39					      START_LEVEL	_1XJH_Tara_Gelson
      1  4a39				   LEVEL_START SET	*
      2  4a39		       00 09	   BANK_LEVEL__1XJH_Tara_Gelson =	_CURRENT_BANK
      3  4a39				   LEVEL__1XJH_Tara_Gelson SUBROUTINE
      4  4a39				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4a39
    123  4a39		       38 23 7c 23*	      .byte.b	"8#|#2-#2-*#|#2-*-*-#|#-*$-$-#|#2-.#.-#|#3-#-*#|2#-@3-#|8#",0
      0  4a73					      END_LEVEL	_1XJH_Tara_Gelson
      1  4a73		       00 3a	   LEVEL_SIZE__1XJH_Tara_Gelson =	* - LEVEL_START
      2  4a73				  -	      IF	LEVEL_SIZE__1XJH_Tara_Gelson > MAX_LEVEL_SIZE
      3  4a73				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1XJH_Tara_Gelson
      4  4a73					      ENDIF
    125  4a73
      0  4a73					      START_LEVEL	_1R7X_Alison
      1  4a73				   LEVEL_START SET	*
      2  4a73		       00 09	   BANK_LEVEL__1R7X_Alison =	_CURRENT_BANK
      3  4a73				   LEVEL__1R7X_Alison SUBROUTINE
      4  4a73				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4a73
    127  4a73		       37 23 7c 23*	      .byte.b	"7#|#2-.2-#|#-$*2$#|#-2.$.#|#@*-$-#|2#.3-#|7#",0
      0  4aa0					      END_LEVEL	_1R7X_Alison
      1  4aa0		       00 2d	   LEVEL_SIZE__1R7X_Alison =	* - LEVEL_START
      2  4aa0				  -	      IF	LEVEL_SIZE__1R7X_Alison > MAX_LEVEL_SIZE
      3  4aa0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1R7X_Alison
      4  4aa0					      ENDIF
    129  4aa0
      0  4aa0					      START_LEVEL	_1KWD_Cecile_Clayworth
      1  4aa0				   LEVEL_START SET	*
      2  4aa0		       00 09	   BANK_LEVEL__1KWD_Cecile_Clayworth =	_CURRENT_BANK
      3  4aa0				   LEVEL__1KWD_Cecile_Clayworth SUBROUTINE
      4  4aa0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4aa0
    131  4aa0		       38 23 7c 33*	      .byte.b	"8#|3#.2-.#|#-$4-#|#-*2#2$#|#3-$-+#|#-*.-*-#|#6-#|8#",0
      0  4ad4					      END_LEVEL	_1KWD_Cecile_Clayworth
      1  4ad4		       00 34	   LEVEL_SIZE__1KWD_Cecile_Clayworth =	* - LEVEL_START
      2  4ad4				  -	      IF	LEVEL_SIZE__1KWD_Cecile_Clayworth > MAX_LEVEL_SIZE
      3  4ad4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1KWD_Cecile_Clayworth
      4  4ad4					      ENDIF
    133  4ad4
      0  4ad4					      START_LEVEL	_1EKT_Samantha_Gelson
      1  4ad4				   LEVEL_START SET	*
      2  4ad4		       00 09	   BANK_LEVEL__1EKT_Samantha_Gelson =	_CURRENT_BANK
      3  4ad4				   LEVEL__1EKT_Samantha_Gelson SUBROUTINE
      4  4ad4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4ad4
    135  4ad4		       38 23 7c 23*	      .byte.b	"8#|#-*3-.#|#2-$-*-#|#-.$-$-#|#*-*2-*#|#.#-#2-#|#4-@-#|8#",0
      0  4b0d					      END_LEVEL	_1EKT_Samantha_Gelson
      1  4b0d		       00 39	   LEVEL_SIZE__1EKT_Samantha_Gelson =	* - LEVEL_START
      2  4b0d				  -	      IF	LEVEL_SIZE__1EKT_Samantha_Gelson > MAX_LEVEL_SIZE
      3  4b0d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1EKT_Samantha_Gelson
      4  4b0d					      ENDIF
    137  4b0d
      0  4b0d					      START_LEVEL	_0VM5_Andrea_Wadd
      1  4b0d				   LEVEL_START SET	*
      2  4b0d		       00 09	   BANK_LEVEL__0VM5_Andrea_Wadd =	_CURRENT_BANK
      3  4b0d				   LEVEL__0VM5_Andrea_Wadd SUBROUTINE
      4  4b0d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b0d
    139  4b0d		       37 23 7c 23*	      .byte.b	"7#|#3-#-#|#-$*2-#|#-.-+-#|#-*2$-#|2#2-.-#|7#",0
      0  4b3a					      END_LEVEL	_0VM5_Andrea_Wadd
      1  4b3a		       00 2d	   LEVEL_SIZE__0VM5_Andrea_Wadd =	* - LEVEL_START
      2  4b3a				  -	      IF	LEVEL_SIZE__0VM5_Andrea_Wadd > MAX_LEVEL_SIZE
      3  4b3a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0VM5_Andrea_Wadd
      4  4b3a					      ENDIF
    141  4b3a
      0  4b3a					      START_LEVEL	_0PAL_Jill_Leatherby
      1  4b3a				   LEVEL_START SET	*
      2  4b3a		       00 09	   BANK_LEVEL__0PAL_Jill_Leatherby =	_CURRENT_BANK
      3  4b3a				   LEVEL__0PAL_Jill_Leatherby SUBROUTINE
      4  4b3a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b3a
    143  4b3a		       37 23 7c 23*	      .byte.b	"7#|#3-3#|#2-2*-#|#3-$-#|#2-$2.#|3#@2-#|7#",0
      0  4b64					      END_LEVEL	_0PAL_Jill_Leatherby
      1  4b64		       00 2a	   LEVEL_SIZE__0PAL_Jill_Leatherby =	* - LEVEL_START
      2  4b64				  -	      IF	LEVEL_SIZE__0PAL_Jill_Leatherby > MAX_LEVEL_SIZE
      3  4b64				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0PAL_Jill_Leatherby
      4  4b64					      ENDIF
    145  4b64
      0  4b64					      START_LEVEL	_0IZ1_Sophia
      1  4b64				   LEVEL_START SET	*
      2  4b64		       00 09	   BANK_LEVEL__0IZ1_Sophia =	_CURRENT_BANK
      3  4b64				   LEVEL__0IZ1_Sophia SUBROUTINE
      4  4b64				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b64
    147  4b64		       37 23 7c 23*	      .byte.b	"7#|#5-#|#@$.#-#|#*$2-.#|#-2$2-#|#-.-.-#|7#",0
      0  4b8f					      END_LEVEL	_0IZ1_Sophia
      1  4b8f		       00 2b	   LEVEL_SIZE__0IZ1_Sophia =	* - LEVEL_START
      2  4b8f				  -	      IF	LEVEL_SIZE__0IZ1_Sophia > MAX_LEVEL_SIZE
      3  4b8f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0IZ1_Sophia
      4  4b8f					      ENDIF
    149  4b8f
      0  4b8f					      START_LEVEL	_0CNH_Alice
      1  4b8f				   LEVEL_START SET	*
      2  4b8f		       00 09	   BANK_LEVEL__0CNH_Alice =	_CURRENT_BANK
      3  4b8f				   LEVEL__0CNH_Alice SUBROUTINE
      4  4b8f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b8f
    151  4b8f		       37 23 7c 23*	      .byte.b	"7#|#.4-#|#$*-#-#|#.2-$*#|#-.$2-#|#@-*2-#|7#",0
      0  4bbb					      END_LEVEL	_0CNH_Alice
      1  4bbb		       00 2c	   LEVEL_SIZE__0CNH_Alice =	* - LEVEL_START
      2  4bbb				  -	      IF	LEVEL_SIZE__0CNH_Alice > MAX_LEVEL_SIZE
      3  4bbb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0CNH_Alice
      4  4bbb					      ENDIF
    153  4bbb
    154  4bbb							;  START_LEVEL TowC
    155  4bbb							;   .byte "4-5#|4-#3-#|4-#$2-#|2-3#2-$2#|2-#2-$-$-#|3#-#-2#-#3-6#|#3-#-2#-5#2-2.#|#-$2-$10-2.#|5#-3#-#@2#2-2.#|4-#5-9#|4-7#",0
    156  4bbb							;  END_LEVEL TowC
    157  4bbb
    158  4bbb							;  START_LEVEL SimpleC
    159  4bbb							;  .byte "7#|#.@-#-#|#$*-$-#|#3-$-#|#-..--#|#--*--#|7#",0
    160  4bbb							;  END_LEVEL SimpleC
    161  4bbb
      0  4bbb					      START_LEVEL	bAlfa_DrFogh
      1  4bbb				   LEVEL_START SET	*
      2  4bbb		       00 09	   BANK_LEVEL_bAlfa_DrFogh =	_CURRENT_BANK
      3  4bbb				   LEVEL_bAlfa_DrFogh SUBROUTINE
      4  4bbb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4bbb
    163  4bbb		       32 2d 34 23*	      .byte.b	"2-4#2-4#|-2#2-2#-#2-#|-#4-3#2-2#|2#2-2*2-#.2-2#|#2-*2-*-#*#2-#|#-*4-2*2-#-#|#-*-2#-*3-#-#|2#-*2-*#*#-#-#|-#$-2*-#-*-#-#|-#@#2-2#5-#|-2#2-4#2-3#|2-#2-#2-4#|2-#2-#|2-4#",0
      0  4c62					      END_LEVEL	bAlfa_DrFogh
      1  4c62		       00 a7	   LEVEL_SIZE_bAlfa_DrFogh =	* - LEVEL_START
      2  4c62					      IF	LEVEL_SIZE_bAlfa_DrFogh > MAX_LEVEL_SIZE
      3  4c62				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAlfa_DrFogh
      4  4c62					      ENDIF
    165  4c62
      0  4c62					      START_LEVEL	b51X_Sharpen
      1  4c62				   LEVEL_START SET	*
      2  4c62		       00 09	   BANK_LEVEL_b51X_Sharpen =	_CURRENT_BANK
      3  4c62				   LEVEL_b51X_Sharpen SUBROUTINE
      4  4c62				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4c62
    167  4c62		       2d 39 23 33*	      .byte.b	"-9#3-|-#7-#3-|-#-$-2$-$#3-|3#$#2-$-#3-|#.#3-2$-2#2-|#.3#3-$-#2-|#.#.-$-2#-3#|#3.$-$2#-$-#|#3.$3-$2-@#|#2.3#$3#-2#|#4.#5-#-|12#-",0
      0  4ce2					      END_LEVEL	b51X_Sharpen
      1  4ce2		       00 80	   LEVEL_SIZE_b51X_Sharpen =	* - LEVEL_START
      2  4ce2				  -	      IF	LEVEL_SIZE_b51X_Sharpen > MAX_LEVEL_SIZE
      3  4ce2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_b51X_Sharpen
      4  4ce2					      ENDIF
    169  4ce2
      0  4ce2					      START_LEVEL	bDarcy_Burnsell101
      1  4ce2				   LEVEL_START SET	*
      2  4ce2		       00 09	   BANK_LEVEL_bDarcy_Burnsell101 =	_CURRENT_BANK
      3  4ce2				   LEVEL_bDarcy_Burnsell101 SUBROUTINE
      4  4ce2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4ce2
    171  4ce2		       38 23 7c 23*	      .byte.b	"8#|#2-.-$@#|#.#$*2$#|#2-.-*-#|#2$-2$.#|#.#-#2-#|#.2-.-.#|8#",0
      0  4d1e					      END_LEVEL	bDarcy_Burnsell101
      1  4d1e		       00 3c	   LEVEL_SIZE_bDarcy_Burnsell101 =	* - LEVEL_START
      2  4d1e				  -	      IF	LEVEL_SIZE_bDarcy_Burnsell101 > MAX_LEVEL_SIZE
      3  4d1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bDarcy_Burnsell101
      4  4d1e					      ENDIF
    173  4d1e
      0  4d1e					      START_LEVEL	bAislin101
      1  4d1e				   LEVEL_START SET	*
      2  4d1e		       00 09	   BANK_LEVEL_bAislin101 =	_CURRENT_BANK
      3  4d1e				   LEVEL_bAislin101 SUBROUTINE
      4  4d1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4d1e
    175  4d1e		       38 23 7c 32*	      .byte.b	"8#|2#-*-*.#|#2.$-$*#|#-.#-*.#|2#-$-$2#|#-#$-$-#|#2.2-$@#|8#",0
      0  4d5a					      END_LEVEL	bAislin101
      1  4d5a		       00 3c	   LEVEL_SIZE_bAislin101 =	* - LEVEL_START
      2  4d5a				  -	      IF	LEVEL_SIZE_bAislin101 > MAX_LEVEL_SIZE
      3  4d5a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAislin101
      4  4d5a					      ENDIF
    177  4d5a
    178  4d5a							;  START_LEVEL b82X_Sharpen
    179  4d5a							;  .byte "-11#8-|-#5-#3-2#7-|-#-$-$-$-#2-5#3-|-3#2-5#5-#3-|-#4.#5-3#-#3-|-#.4#2-4#3-#3-|-#4.4-#2-$-2#3-|-#-3.#3-#-3$5#|3#.7#2-$@$3-#|#-$3-5#-$-2#3-#|#-#.#-$6-$3#$-#|#-#.8#2-#2-$-#|#-#3.7-2#-2$-#|#3-7#-$-#-#2-#|5#5-#7-2#|10-9#-",0
    180  4d5a							;  END_LEVEL b82X_Sharpen
    181  4d5a
      0  4d5a					      START_LEVEL	Thomas_Reinke16
      1  4d5a				   LEVEL_START SET	*
      2  4d5a		       00 09	   BANK_LEVEL_Thomas_Reinke16 =	_CURRENT_BANK
      3  4d5a				   LEVEL_Thomas_Reinke16 SUBROUTINE
      4  4d5a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4d5a
    183  4d5a		       2d 35 23 7c*	      .byte.b	"-5#|2#3-3#|#6-2#|#-#-2#2-#|#2.*2-#-#|#2-*2-#-#|3#*2$2-#|2-#@-4#|2-4#",0
      0  4d9f					      END_LEVEL	Thomas_Reinke16
      1  4d9f		       00 45	   LEVEL_SIZE_Thomas_Reinke16 =	* - LEVEL_START
      2  4d9f				  -	      IF	LEVEL_SIZE_Thomas_Reinke16 > MAX_LEVEL_SIZE
      3  4d9f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_Thomas_Reinke16
      4  4d9f					      ENDIF
    185  4d9f
    186  4d9f							;Level element	Character	ASCII Code
    187  4d9f							;Wall	#	0x23
    188  4d9f							;Player	@	0x40
    189  4d9f							;Player on goal square	+	0x2b
    190  4d9f							;Box	$	0x24
    191  4d9f							;Box on goal square	*	0x2a
    192  4d9f							;Goal square	.	0x2e
    193  4d9f							;Floor	(Space)	0x20 or underscore
    194  4d9f
    195  4d9f							;This level ("Claire", by Lee J Haywood):
    196  4d9f
    197  4d9f							;#######
    198  4d9f							;#.@ # #
    199  4d9f							;#$* $ #
    200  4d9f							;#   $ #
    201  4d9f							;# ..	#
    202  4d9f							;#  *	#
    203  4d9f							;#######
    204  4d9f							;runlength encoded looks like this:
    205  4d9f
    206  4d9f							;The rows of the level are separated by "|"s. There has been a discussion in the Yahoo Group about what character should represent an empty square in May 2006. Finally the hyphen has been elected to be the standard character for an empty square. Nevertheless, programs are encouraged to support both, hyphens and underscores.
    207  4d9f
    208  4d9f							;If only two level elements are grouped together they may be run length encoded, but needn't to. Example:
    209  4d9f
    210  4d9f
      0  4d9f					      CHECK_BANK_SIZE	"LEVELS6 -- full 2K"
      1  4d9f		       05 9f	   .TEMP      =	* - BANK_START
 LEVELS6 -- full 2K (2K) SIZE =  $59f , FREE= $261
      2  4d9f					      ECHO	"LEVELS6 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4d9f				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4d9f				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4d9f				  -	      ERR
      6  4d9f					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_PlayerFrames.asm LEVEL 2 PASS 3
      0  4d9f					      include	"BANK_PlayerFrames.asm"
      1  4d9f							;    Sokoboo - a Sokoban implementation
      2  4d9f							;    using a generic tile-based display engine for the Atari 2600
      3  4d9f							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  4d9f							;
      5  4d9f							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  4d9f							;
      7  4d9f							;    Code related to the generic tile-based display engine was developed by
      8  4d9f							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  4d9f							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  4d9f							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  4d9f							;
     12  4d9f							;    Code related to music and sound effects uses the TIATracker music player
     13  4d9f							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  4d9f							;    directory for Apache licensing details.
     15  4d9f							;
     16  4d9f							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  4d9f							;    See the copyright notices in the License directory for a list of level
     18  4d9f							;    contributors.
     19  4d9f							;
     20  4d9f							;    Except where otherwise indicated, this software is released under the
     21  4d9f							;    following licensing arrangement...
     22  4d9f							;
     23  4d9f							;    This program is free software: you can redistribute it and/or modify
     24  4d9f							;    it under the terms of the GNU General Public License as published by
     25  4d9f							;    the Free Software Foundation, either version 3 of the License, or
     26  4d9f							;    (at your option) any later version.
     27  4d9f							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  4d9f
     29  4d9f							;    This program is distributed in the hope that it will be useful,
     30  4d9f							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  4d9f							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  4d9f							;    GNU General Public License for more details.
     33  4d9f
      0  4d9f					      NEWBANK	PLAYER_FRAMES
      1  5684 ????				      SEG	PLAYER_FRAMES
      2  5000					      ORG	ORIGIN
      3  5000					      RORG	$F000
      4  5000				   BANK_START SET	*
      5  5000				   PLAYER_FRAMES SET	ORIGIN / 2048
      6  5000				   ORIGIN     SET	ORIGIN + 2048
      7  5000				   _CURRENT_BANK SET	PLAYER_FRAMES
     35  5000
     36  5000							;CL0	  = $0
     37  5000							;CL1	  = $4C   ;yellow
     38  5000							;CL2	  = $68
     39  5000							;CL3	  = $0C   ; cuffs/trim
     40  5000							;CL4	  = $B8   ; jumper
     41  5000							;CL5	  = $b2
     42  5000							;CL6	  = $66
     43  5000
     44  5000		       00 00	   CL0	      =	$0
     45  5000		       00 01	   CL1	      =	1	;$2C	;yellow
     46  5000		       00 02	   CL2	      =	2	;$24
     47  5000		       00 03	   CL3	      =	3	;$6A	; cuffs/trim
     48  5000		       00 04	   CL4	      =	4	;$44
     49  5000		       00 05	   CL5	      =	5	;$B6	; pants
     50  5000		       00 06	   CL6	      =	6	;$64
     51  5000
     52  5000
     53  5000
     54  5000		       00 ff	   JUMP       =	$FF
     55  5000		       00 fe	   FLIP       =	$FE
     56  5000
     57  5000					      MAC	flip
     58  5000					      .byte	FLIP,0
     59  5000					      ENDM
     60  5000
     61  5000					      MAC	goto
     62  5000					      .byte	JUMP
     63  5000					      .byte	ANIMATION_{1}_ID
     64  5000					      ENDM
     65  5000
     66  5000					      MAC	show
     67  5000					      .byte	FRAME_{1},{2}
     68  5000					      ENDM
     69  5000
     70  5000
     71  5000				   ANIM_INDEX SET	0
     72  5000					      MAC	insert_animation
     73  5000				   ANIMATION_{1}_ID =	ANIM_INDEX
     74  5000					      .word	Animation_{1}
     75  5000				   ANIM_INDEX SET	ANIM_INDEX + 2
     76  5000					      ENDM		; {animation address}
     77  5000
     78  5000				   ANIM_TABLE
      0  5000					      INSERT_ANIMATION	WALK
      1  5000		       00 00	   ANIMATION_WALK_ID =	ANIM_INDEX
      2  5000		       12 f0		      .word.w	Animation_WALK
      3  5000				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5002					      INSERT_ANIMATION	IDLE
      1  5002		       00 02	   ANIMATION_IDLE_ID =	ANIM_INDEX
      2  5002		       3e f0		      .word.w	Animation_IDLE
      3  5002				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5004					      INSERT_ANIMATION	WIN
      1  5004		       00 04	   ANIMATION_WIN_ID =	ANIM_INDEX
      2  5004		       1c f0		      .word.w	Animation_WIN
      3  5004				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5006					      INSERT_ANIMATION	WIN2
      1  5006		       00 06	   ANIMATION_WIN2_ID =	ANIM_INDEX
      2  5006		       1e f0		      .word.w	Animation_WIN2
      3  5006				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5008					      INSERT_ANIMATION	PUSH
      1  5008		       00 08	   ANIMATION_PUSH_ID =	ANIM_INDEX
      2  5008		       2c f2		      .word.w	Animation_PUSH
      3  5008				   ANIM_INDEX SET	ANIM_INDEX + 2
     84  500a							;    INSERT_ANIMATION PUSHTRY
      0  500a					      INSERT_ANIMATION	PUSHUP
      1  500a		       00 0a	   ANIMATION_PUSHUP_ID =	ANIM_INDEX
      2  500a		       36 f2		      .word.w	Animation_PUSHUP
      3  500a				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  500c					      INSERT_ANIMATION	WALK2
      1  500c		       00 0c	   ANIMATION_WALK2_ID =	ANIM_INDEX
      2  500c		       12 f0		      .word.w	Animation_WALK2
      3  500c				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  500e					      INSERT_ANIMATION	TURNAROUND
      1  500e		       00 0e	   ANIMATION_TURNAROUND_ID =	ANIM_INDEX
      2  500e		       12 f2		      .word.w	Animation_TURNAROUND
      3  500e				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5010					      INSERT_ANIMATION	YAWN
      1  5010		       00 10	   ANIMATION_YAWN_ID =	ANIM_INDEX
      2  5010		       1c f2		      .word.w	Animation_YAWN
      3  5010				   ANIM_INDEX SET	ANIM_INDEX + 2
     89  5012							;    INSERT_ANIMATION PUSH_START
     90  5012
     91  5012
     92  5012				   Animation_WALK
     93  5012				   Animation_WALK2
      0  5012					      SHOW	WALK1, 8
      1  5012		       01 08		      .byte.b	FRAME_WALK1,8
      0  5014					      SHOW	WALK2, 8
      1  5014		       02 08		      .byte.b	FRAME_WALK2,8
      0  5016					      SHOW	WALK3, 8
      1  5016		       05 08		      .byte.b	FRAME_WALK3,8
      0  5018					      SHOW	WALK2, 8
      1  5018		       02 08		      .byte.b	FRAME_WALK2,8
      0  501a					      GOTO	WALK2
      1  501a		       ff		      .byte.b	JUMP
      2  501b		       0c		      .byte.b	ANIMATION_WALK2_ID
     99  501c
    100  501c
    101  501c				   Animation_WIN
    102  501c
      0  501c					      SHOW	IDLE1, 10
      1  501c		       0d 0a		      .byte.b	FRAME_IDLE1,10
    104  501e
    105  501e				   Animation_WIN2
      0  501e					      SHOW	IDLE2, 10
      1  501e		       0b 0a		      .byte.b	FRAME_IDLE2,10
      0  5020					      SHOW	IDLE3, 20
      1  5020		       0a 14		      .byte.b	FRAME_IDLE3,20
      0  5022					      GOTO	WIN2
      1  5022		       ff		      .byte.b	JUMP
      2  5023		       06		      .byte.b	ANIMATION_WIN2_ID
    109  5024
    110  5024				   Animation_WOBBLE
    111  5024
    112  5024							; pretty cool little wobble
    113  5024					      REPEAT	4
      0  5024					      SHOW	WALK2, 10
      1  5024		       02 0a		      .byte.b	FRAME_WALK2,10
      0  5026					      FLIP
      1  5026		       fe 00		      .byte.b	FLIP,0
      0  5028					      SHOW	LOOK2, 10
      1  5028		       11 0a		      .byte.b	FRAME_LOOK2,10
    113  5028					      REPEND
      0  502a					      SHOW	WALK2, 10
      1  502a		       02 0a		      .byte.b	FRAME_WALK2,10
      0  502c					      FLIP
      1  502c		       fe 00		      .byte.b	FLIP,0
      0  502e					      SHOW	LOOK2, 10
      1  502e		       11 0a		      .byte.b	FRAME_LOOK2,10
    113  502e					      REPEND
      0  5030					      SHOW	WALK2, 10
      1  5030		       02 0a		      .byte.b	FRAME_WALK2,10
      0  5032					      FLIP
      1  5032		       fe 00		      .byte.b	FLIP,0
      0  5034					      SHOW	LOOK2, 10
      1  5034		       11 0a		      .byte.b	FRAME_LOOK2,10
    113  5034					      REPEND
      0  5036					      SHOW	WALK2, 10
      1  5036		       02 0a		      .byte.b	FRAME_WALK2,10
      0  5038					      FLIP
      1  5038		       fe 00		      .byte.b	FLIP,0
      0  503a					      SHOW	LOOK2, 10
      1  503a		       11 0a		      .byte.b	FRAME_LOOK2,10
    117  503c					      REPEND
      0  503c					      GOTO	IDLE
      1  503c		       ff		      .byte.b	JUMP
      2  503d		       02		      .byte.b	ANIMATION_IDLE_ID
    119  503e
    120  503e
    121  503e
    122  503e				   Animation_IDLE
    123  503e
    124  503e					      REPEAT	5
    125  503e					      REPEAT	20
      0  503e					      SHOW	WALK2, 255
      1  503e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5040					      SHOW	BLINK, 2
      1  5040		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5040					      REPEND
      0  5042					      SHOW	WALK2, 255
      1  5042		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5044					      SHOW	BLINK, 2
      1  5044		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5044					      REPEND
      0  5046					      SHOW	WALK2, 255
      1  5046		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5048					      SHOW	BLINK, 2
      1  5048		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5048					      REPEND
      0  504a					      SHOW	WALK2, 255
      1  504a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  504c					      SHOW	BLINK, 2
      1  504c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  504c					      REPEND
      0  504e					      SHOW	WALK2, 255
      1  504e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5050					      SHOW	BLINK, 2
      1  5050		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5050					      REPEND
      0  5052					      SHOW	WALK2, 255
      1  5052		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5054					      SHOW	BLINK, 2
      1  5054		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5054					      REPEND
      0  5056					      SHOW	WALK2, 255
      1  5056		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5058					      SHOW	BLINK, 2
      1  5058		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5058					      REPEND
      0  505a					      SHOW	WALK2, 255
      1  505a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  505c					      SHOW	BLINK, 2
      1  505c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  505c					      REPEND
      0  505e					      SHOW	WALK2, 255
      1  505e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5060					      SHOW	BLINK, 2
      1  5060		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5060					      REPEND
      0  5062					      SHOW	WALK2, 255
      1  5062		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5064					      SHOW	BLINK, 2
      1  5064		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5064					      REPEND
      0  5066					      SHOW	WALK2, 255
      1  5066		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5068					      SHOW	BLINK, 2
      1  5068		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5068					      REPEND
      0  506a					      SHOW	WALK2, 255
      1  506a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  506c					      SHOW	BLINK, 2
      1  506c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  506c					      REPEND
      0  506e					      SHOW	WALK2, 255
      1  506e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5070					      SHOW	BLINK, 2
      1  5070		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5070					      REPEND
      0  5072					      SHOW	WALK2, 255
      1  5072		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5074					      SHOW	BLINK, 2
      1  5074		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5074					      REPEND
      0  5076					      SHOW	WALK2, 255
      1  5076		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5078					      SHOW	BLINK, 2
      1  5078		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5078					      REPEND
      0  507a					      SHOW	WALK2, 255
      1  507a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  507c					      SHOW	BLINK, 2
      1  507c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  507c					      REPEND
      0  507e					      SHOW	WALK2, 255
      1  507e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5080					      SHOW	BLINK, 2
      1  5080		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5080					      REPEND
      0  5082					      SHOW	WALK2, 255
      1  5082		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5084					      SHOW	BLINK, 2
      1  5084		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5084					      REPEND
      0  5086					      SHOW	WALK2, 255
      1  5086		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5088					      SHOW	BLINK, 2
      1  5088		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5088					      REPEND
      0  508a					      SHOW	WALK2, 255
      1  508a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  508c					      SHOW	BLINK, 2
      1  508c		       0f 02		      .byte.b	FRAME_BLINK,2
    128  508e					      REPEND
    129  508e
    130  508e					      REPEAT	3
      0  508e					      SHOW	TAPFOOT, 10
      1  508e		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  5090					      SHOW	WALK2, 5
      1  5090		       02 05		      .byte.b	FRAME_WALK2,5
    130  5090					      REPEND
      0  5092					      SHOW	TAPFOOT, 10
      1  5092		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  5094					      SHOW	WALK2, 5
      1  5094		       02 05		      .byte.b	FRAME_WALK2,5
    130  5094					      REPEND
      0  5096					      SHOW	TAPFOOT, 10
      1  5096		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  5098					      SHOW	WALK2, 5
      1  5098		       02 05		      .byte.b	FRAME_WALK2,5
    133  509a					      REPEND
    124  509a					      REPEND
    125  509a					      REPEAT	20
      0  509a					      SHOW	WALK2, 255
      1  509a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  509c					      SHOW	BLINK, 2
      1  509c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  509c					      REPEND
      0  509e					      SHOW	WALK2, 255
      1  509e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50a0					      SHOW	BLINK, 2
      1  50a0		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50a0					      REPEND
      0  50a2					      SHOW	WALK2, 255
      1  50a2		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50a4					      SHOW	BLINK, 2
      1  50a4		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50a4					      REPEND
      0  50a6					      SHOW	WALK2, 255
      1  50a6		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50a8					      SHOW	BLINK, 2
      1  50a8		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50a8					      REPEND
      0  50aa					      SHOW	WALK2, 255
      1  50aa		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50ac					      SHOW	BLINK, 2
      1  50ac		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50ac					      REPEND
      0  50ae					      SHOW	WALK2, 255
      1  50ae		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50b0					      SHOW	BLINK, 2
      1  50b0		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50b0					      REPEND
      0  50b2					      SHOW	WALK2, 255
      1  50b2		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50b4					      SHOW	BLINK, 2
      1  50b4		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50b4					      REPEND
      0  50b6					      SHOW	WALK2, 255
      1  50b6		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50b8					      SHOW	BLINK, 2
      1  50b8		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50b8					      REPEND
      0  50ba					      SHOW	WALK2, 255
      1  50ba		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50bc					      SHOW	BLINK, 2
      1  50bc		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50bc					      REPEND
      0  50be					      SHOW	WALK2, 255
      1  50be		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50c0					      SHOW	BLINK, 2
      1  50c0		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50c0					      REPEND
      0  50c2					      SHOW	WALK2, 255
      1  50c2		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50c4					      SHOW	BLINK, 2
      1  50c4		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50c4					      REPEND
      0  50c6					      SHOW	WALK2, 255
      1  50c6		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50c8					      SHOW	BLINK, 2
      1  50c8		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50c8					      REPEND
      0  50ca					      SHOW	WALK2, 255
      1  50ca		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50cc					      SHOW	BLINK, 2
      1  50cc		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50cc					      REPEND
      0  50ce					      SHOW	WALK2, 255
      1  50ce		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50d0					      SHOW	BLINK, 2
      1  50d0		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50d0					      REPEND
      0  50d2					      SHOW	WALK2, 255
      1  50d2		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50d4					      SHOW	BLINK, 2
      1  50d4		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50d4					      REPEND
      0  50d6					      SHOW	WALK2, 255
      1  50d6		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50d8					      SHOW	BLINK, 2
      1  50d8		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50d8					      REPEND
      0  50da					      SHOW	WALK2, 255
      1  50da		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50dc					      SHOW	BLINK, 2
      1  50dc		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50dc					      REPEND
      0  50de					      SHOW	WALK2, 255
      1  50de		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50e0					      SHOW	BLINK, 2
      1  50e0		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50e0					      REPEND
      0  50e2					      SHOW	WALK2, 255
      1  50e2		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50e4					      SHOW	BLINK, 2
      1  50e4		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50e4					      REPEND
      0  50e6					      SHOW	WALK2, 255
      1  50e6		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50e8					      SHOW	BLINK, 2
      1  50e8		       0f 02		      .byte.b	FRAME_BLINK,2
    128  50ea					      REPEND
    129  50ea
    130  50ea					      REPEAT	3
      0  50ea					      SHOW	TAPFOOT, 10
      1  50ea		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  50ec					      SHOW	WALK2, 5
      1  50ec		       02 05		      .byte.b	FRAME_WALK2,5
    130  50ec					      REPEND
      0  50ee					      SHOW	TAPFOOT, 10
      1  50ee		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  50f0					      SHOW	WALK2, 5
      1  50f0		       02 05		      .byte.b	FRAME_WALK2,5
    130  50f0					      REPEND
      0  50f2					      SHOW	TAPFOOT, 10
      1  50f2		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  50f4					      SHOW	WALK2, 5
      1  50f4		       02 05		      .byte.b	FRAME_WALK2,5
    133  50f6					      REPEND
    124  50f6					      REPEND
    125  50f6					      REPEAT	20
      0  50f6					      SHOW	WALK2, 255
      1  50f6		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50f8					      SHOW	BLINK, 2
      1  50f8		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50f8					      REPEND
      0  50fa					      SHOW	WALK2, 255
      1  50fa		       02 ff		      .byte.b	FRAME_WALK2,255
      0  50fc					      SHOW	BLINK, 2
      1  50fc		       0f 02		      .byte.b	FRAME_BLINK,2
    125  50fc					      REPEND
      0  50fe					      SHOW	WALK2, 255
      1  50fe		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5100					      SHOW	BLINK, 2
      1  5100		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5100					      REPEND
      0  5102					      SHOW	WALK2, 255
      1  5102		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5104					      SHOW	BLINK, 2
      1  5104		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5104					      REPEND
      0  5106					      SHOW	WALK2, 255
      1  5106		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5108					      SHOW	BLINK, 2
      1  5108		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5108					      REPEND
      0  510a					      SHOW	WALK2, 255
      1  510a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  510c					      SHOW	BLINK, 2
      1  510c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  510c					      REPEND
      0  510e					      SHOW	WALK2, 255
      1  510e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5110					      SHOW	BLINK, 2
      1  5110		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5110					      REPEND
      0  5112					      SHOW	WALK2, 255
      1  5112		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5114					      SHOW	BLINK, 2
      1  5114		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5114					      REPEND
      0  5116					      SHOW	WALK2, 255
      1  5116		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5118					      SHOW	BLINK, 2
      1  5118		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5118					      REPEND
      0  511a					      SHOW	WALK2, 255
      1  511a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  511c					      SHOW	BLINK, 2
      1  511c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  511c					      REPEND
      0  511e					      SHOW	WALK2, 255
      1  511e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5120					      SHOW	BLINK, 2
      1  5120		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5120					      REPEND
      0  5122					      SHOW	WALK2, 255
      1  5122		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5124					      SHOW	BLINK, 2
      1  5124		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5124					      REPEND
      0  5126					      SHOW	WALK2, 255
      1  5126		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5128					      SHOW	BLINK, 2
      1  5128		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5128					      REPEND
      0  512a					      SHOW	WALK2, 255
      1  512a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  512c					      SHOW	BLINK, 2
      1  512c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  512c					      REPEND
      0  512e					      SHOW	WALK2, 255
      1  512e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5130					      SHOW	BLINK, 2
      1  5130		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5130					      REPEND
      0  5132					      SHOW	WALK2, 255
      1  5132		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5134					      SHOW	BLINK, 2
      1  5134		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5134					      REPEND
      0  5136					      SHOW	WALK2, 255
      1  5136		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5138					      SHOW	BLINK, 2
      1  5138		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5138					      REPEND
      0  513a					      SHOW	WALK2, 255
      1  513a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  513c					      SHOW	BLINK, 2
      1  513c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  513c					      REPEND
      0  513e					      SHOW	WALK2, 255
      1  513e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5140					      SHOW	BLINK, 2
      1  5140		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5140					      REPEND
      0  5142					      SHOW	WALK2, 255
      1  5142		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5144					      SHOW	BLINK, 2
      1  5144		       0f 02		      .byte.b	FRAME_BLINK,2
    128  5146					      REPEND
    129  5146
    130  5146					      REPEAT	3
      0  5146					      SHOW	TAPFOOT, 10
      1  5146		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  5148					      SHOW	WALK2, 5
      1  5148		       02 05		      .byte.b	FRAME_WALK2,5
    130  5148					      REPEND
      0  514a					      SHOW	TAPFOOT, 10
      1  514a		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  514c					      SHOW	WALK2, 5
      1  514c		       02 05		      .byte.b	FRAME_WALK2,5
    130  514c					      REPEND
      0  514e					      SHOW	TAPFOOT, 10
      1  514e		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  5150					      SHOW	WALK2, 5
      1  5150		       02 05		      .byte.b	FRAME_WALK2,5
    133  5152					      REPEND
    124  5152					      REPEND
    125  5152					      REPEAT	20
      0  5152					      SHOW	WALK2, 255
      1  5152		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5154					      SHOW	BLINK, 2
      1  5154		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5154					      REPEND
      0  5156					      SHOW	WALK2, 255
      1  5156		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5158					      SHOW	BLINK, 2
      1  5158		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5158					      REPEND
      0  515a					      SHOW	WALK2, 255
      1  515a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  515c					      SHOW	BLINK, 2
      1  515c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  515c					      REPEND
      0  515e					      SHOW	WALK2, 255
      1  515e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5160					      SHOW	BLINK, 2
      1  5160		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5160					      REPEND
      0  5162					      SHOW	WALK2, 255
      1  5162		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5164					      SHOW	BLINK, 2
      1  5164		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5164					      REPEND
      0  5166					      SHOW	WALK2, 255
      1  5166		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5168					      SHOW	BLINK, 2
      1  5168		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5168					      REPEND
      0  516a					      SHOW	WALK2, 255
      1  516a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  516c					      SHOW	BLINK, 2
      1  516c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  516c					      REPEND
      0  516e					      SHOW	WALK2, 255
      1  516e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5170					      SHOW	BLINK, 2
      1  5170		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5170					      REPEND
      0  5172					      SHOW	WALK2, 255
      1  5172		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5174					      SHOW	BLINK, 2
      1  5174		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5174					      REPEND
      0  5176					      SHOW	WALK2, 255
      1  5176		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5178					      SHOW	BLINK, 2
      1  5178		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5178					      REPEND
      0  517a					      SHOW	WALK2, 255
      1  517a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  517c					      SHOW	BLINK, 2
      1  517c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  517c					      REPEND
      0  517e					      SHOW	WALK2, 255
      1  517e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5180					      SHOW	BLINK, 2
      1  5180		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5180					      REPEND
      0  5182					      SHOW	WALK2, 255
      1  5182		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5184					      SHOW	BLINK, 2
      1  5184		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5184					      REPEND
      0  5186					      SHOW	WALK2, 255
      1  5186		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5188					      SHOW	BLINK, 2
      1  5188		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5188					      REPEND
      0  518a					      SHOW	WALK2, 255
      1  518a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  518c					      SHOW	BLINK, 2
      1  518c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  518c					      REPEND
      0  518e					      SHOW	WALK2, 255
      1  518e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5190					      SHOW	BLINK, 2
      1  5190		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5190					      REPEND
      0  5192					      SHOW	WALK2, 255
      1  5192		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5194					      SHOW	BLINK, 2
      1  5194		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5194					      REPEND
      0  5196					      SHOW	WALK2, 255
      1  5196		       02 ff		      .byte.b	FRAME_WALK2,255
      0  5198					      SHOW	BLINK, 2
      1  5198		       0f 02		      .byte.b	FRAME_BLINK,2
    125  5198					      REPEND
      0  519a					      SHOW	WALK2, 255
      1  519a		       02 ff		      .byte.b	FRAME_WALK2,255
      0  519c					      SHOW	BLINK, 2
      1  519c		       0f 02		      .byte.b	FRAME_BLINK,2
    125  519c					      REPEND
      0  519e					      SHOW	WALK2, 255
      1  519e		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51a0					      SHOW	BLINK, 2
      1  51a0		       0f 02		      .byte.b	FRAME_BLINK,2
    128  51a2					      REPEND
    129  51a2
    130  51a2					      REPEAT	3
      0  51a2					      SHOW	TAPFOOT, 10
      1  51a2		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  51a4					      SHOW	WALK2, 5
      1  51a4		       02 05		      .byte.b	FRAME_WALK2,5
    130  51a4					      REPEND
      0  51a6					      SHOW	TAPFOOT, 10
      1  51a6		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  51a8					      SHOW	WALK2, 5
      1  51a8		       02 05		      .byte.b	FRAME_WALK2,5
    130  51a8					      REPEND
      0  51aa					      SHOW	TAPFOOT, 10
      1  51aa		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  51ac					      SHOW	WALK2, 5
      1  51ac		       02 05		      .byte.b	FRAME_WALK2,5
    133  51ae					      REPEND
    124  51ae					      REPEND
    125  51ae					      REPEAT	20
      0  51ae					      SHOW	WALK2, 255
      1  51ae		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51b0					      SHOW	BLINK, 2
      1  51b0		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51b0					      REPEND
      0  51b2					      SHOW	WALK2, 255
      1  51b2		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51b4					      SHOW	BLINK, 2
      1  51b4		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51b4					      REPEND
      0  51b6					      SHOW	WALK2, 255
      1  51b6		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51b8					      SHOW	BLINK, 2
      1  51b8		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51b8					      REPEND
      0  51ba					      SHOW	WALK2, 255
      1  51ba		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51bc					      SHOW	BLINK, 2
      1  51bc		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51bc					      REPEND
      0  51be					      SHOW	WALK2, 255
      1  51be		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51c0					      SHOW	BLINK, 2
      1  51c0		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51c0					      REPEND
      0  51c2					      SHOW	WALK2, 255
      1  51c2		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51c4					      SHOW	BLINK, 2
      1  51c4		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51c4					      REPEND
      0  51c6					      SHOW	WALK2, 255
      1  51c6		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51c8					      SHOW	BLINK, 2
      1  51c8		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51c8					      REPEND
      0  51ca					      SHOW	WALK2, 255
      1  51ca		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51cc					      SHOW	BLINK, 2
      1  51cc		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51cc					      REPEND
      0  51ce					      SHOW	WALK2, 255
      1  51ce		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51d0					      SHOW	BLINK, 2
      1  51d0		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51d0					      REPEND
      0  51d2					      SHOW	WALK2, 255
      1  51d2		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51d4					      SHOW	BLINK, 2
      1  51d4		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51d4					      REPEND
      0  51d6					      SHOW	WALK2, 255
      1  51d6		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51d8					      SHOW	BLINK, 2
      1  51d8		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51d8					      REPEND
      0  51da					      SHOW	WALK2, 255
      1  51da		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51dc					      SHOW	BLINK, 2
      1  51dc		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51dc					      REPEND
      0  51de					      SHOW	WALK2, 255
      1  51de		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51e0					      SHOW	BLINK, 2
      1  51e0		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51e0					      REPEND
      0  51e2					      SHOW	WALK2, 255
      1  51e2		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51e4					      SHOW	BLINK, 2
      1  51e4		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51e4					      REPEND
      0  51e6					      SHOW	WALK2, 255
      1  51e6		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51e8					      SHOW	BLINK, 2
      1  51e8		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51e8					      REPEND
      0  51ea					      SHOW	WALK2, 255
      1  51ea		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51ec					      SHOW	BLINK, 2
      1  51ec		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51ec					      REPEND
      0  51ee					      SHOW	WALK2, 255
      1  51ee		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51f0					      SHOW	BLINK, 2
      1  51f0		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51f0					      REPEND
      0  51f2					      SHOW	WALK2, 255
      1  51f2		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51f4					      SHOW	BLINK, 2
      1  51f4		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51f4					      REPEND
      0  51f6					      SHOW	WALK2, 255
      1  51f6		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51f8					      SHOW	BLINK, 2
      1  51f8		       0f 02		      .byte.b	FRAME_BLINK,2
    125  51f8					      REPEND
      0  51fa					      SHOW	WALK2, 255
      1  51fa		       02 ff		      .byte.b	FRAME_WALK2,255
      0  51fc					      SHOW	BLINK, 2
      1  51fc		       0f 02		      .byte.b	FRAME_BLINK,2
    128  51fe					      REPEND
    129  51fe
    130  51fe					      REPEAT	3
      0  51fe					      SHOW	TAPFOOT, 10
      1  51fe		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  5200					      SHOW	WALK2, 5
      1  5200		       02 05		      .byte.b	FRAME_WALK2,5
    130  5200					      REPEND
      0  5202					      SHOW	TAPFOOT, 10
      1  5202		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  5204					      SHOW	WALK2, 5
      1  5204		       02 05		      .byte.b	FRAME_WALK2,5
    130  5204					      REPEND
      0  5206					      SHOW	TAPFOOT, 10
      1  5206		       14 0a		      .byte.b	FRAME_TAPFOOT,10
      0  5208					      SHOW	WALK2, 5
      1  5208		       02 05		      .byte.b	FRAME_WALK2,5
    133  520a					      REPEND
    134  520a					      REPEND
    135  520a
      0  520a					      SHOW	LOOK3, 3
      1  520a		       12 03		      .byte.b	FRAME_LOOK3,3
      0  520c					      SHOW	LOOK2, 30
      1  520c		       11 1e		      .byte.b	FRAME_LOOK2,30
      0  520e					      SHOW	LOOK3, 3
      1  520e		       12 03		      .byte.b	FRAME_LOOK3,3
    139  5210
      0  5210					      GOTO	YAWN
      1  5210		       ff		      .byte.b	JUMP
      2  5211		       10		      .byte.b	ANIMATION_YAWN_ID
    141  5212
    142  5212
    143  5212				   Animation_TURNAROUND
    144  5212
      0  5212					      SHOW	LOOK3, 1
      1  5212		       12 01		      .byte.b	FRAME_LOOK3,1
      0  5214					      SHOW	LOOK2, 1
      1  5214		       11 01		      .byte.b	FRAME_LOOK2,1
      0  5216					      SHOW	LOOK1, 1
      1  5216		       13 01		      .byte.b	FRAME_LOOK1,1
      0  5218					      FLIP
      1  5218		       fe 00		      .byte.b	FLIP,0
      0  521a					      GOTO	IDLE
      1  521a		       ff		      .byte.b	JUMP
      2  521b		       02		      .byte.b	ANIMATION_IDLE_ID
    150  521c
    151  521c				   Animation_YAWN
    152  521c
      0  521c					      SHOW	WALK2, 50
      1  521c		       02 32		      .byte.b	FRAME_WALK2,50
      0  521e					      SHOW	IDLE1, 10
      1  521e		       0d 0a		      .byte.b	FRAME_IDLE1,10
      0  5220					      SHOW	IDLE2, 10
      1  5220		       0b 0a		      .byte.b	FRAME_IDLE2,10
      0  5222					      SHOW	IDLE3, 100
      1  5222		       0a 64		      .byte.b	FRAME_IDLE3,100
      0  5224					      SHOW	IDLE2, 30
      1  5224		       0b 1e		      .byte.b	FRAME_IDLE2,30
      0  5226					      SHOW	IDLE3, 100
      1  5226		       0a 64		      .byte.b	FRAME_IDLE3,100
      0  5228					      SHOW	IDLE2, 10
      1  5228		       0b 0a		      .byte.b	FRAME_IDLE2,10
      0  522a					      GOTO	IDLE
      1  522a		       ff		      .byte.b	JUMP
      2  522b		       02		      .byte.b	ANIMATION_IDLE_ID
    161  522c
    162  522c
    163  522c							;Animation_PUSHTRY
    164  522c							;    .byte FRAME_PUSH1,20
    165  522c							;    .byte FRAME_PUSH2,20
    166  522c							;    .byte JUMP,ANIMATION_PUSHTRY_ID
    167  522c
    168  522c							;Animation_PUSH_START
    169  522c
    170  522c							;    .byte FRAME_WALK2,2
    171  522c
    172  522c				   Animation_PUSH
    173  522c
      0  522c					      SHOW	PUSH1, 20
      1  522c		       0e 14		      .byte.b	FRAME_PUSH1,20
      0  522e					      SHOW	PUSH2, 20
      1  522e		       0c 14		      .byte.b	FRAME_PUSH2,20
      0  5230					      SHOW	PUSH3, 20
      1  5230		       09 14		      .byte.b	FRAME_PUSH3,20
      0  5232					      SHOW	PUSH2, 20
      1  5232		       0c 14		      .byte.b	FRAME_PUSH2,20
      0  5234					      GOTO	PUSH
      1  5234		       ff		      .byte.b	JUMP
      2  5235		       08		      .byte.b	ANIMATION_PUSH_ID
    179  5236
    180  5236				   Animation_PUSHUP
      0  5236					      SHOW	PUSH_UP_1, 10
      1  5236		       06 0a		      .byte.b	FRAME_PUSH_UP_1,10
      0  5238					      SHOW	PUSH_UP_2, 10
      1  5238		       08 0a		      .byte.b	FRAME_PUSH_UP_2,10
      0  523a					      SHOW	PUSH_UP_3, 10
      1  523a		       07 0a		      .byte.b	FRAME_PUSH_UP_3,10
      0  523c					      SHOW	PUSH_UP_2, 10
      1  523c		       08 0a		      .byte.b	FRAME_PUSH_UP_2,10
      0  523e					      GOTO	PUSHUP
      1  523e		       ff		      .byte.b	JUMP
      2  523f		       0a		      .byte.b	ANIMATION_PUSHUP_ID
    186  5240
    187  5240
------- FILE sprites/spriteData.asm LEVEL 3 PASS 3
      0  5240					      include	"sprites/spriteData.asm"
      1  5240				   FRAMEDATA_crouch1
      2  5240		       26		      .byte.b	38	; 23
      3  5241		       12		      .byte.b	18	; 20
      4  5242		       5a		      .byte.b	90	; 17
      5  5243		       fc		      .byte.b	252	; 14
      6  5244		       18		      .byte.b	24	; 11
      7  5245		       18		      .byte.b	24	; 8
      8  5246		       04		      .byte.b	4	; 5
      9  5247		       00		      .byte.b	0	; 2
     10  5248		       40		      .byte.b	64	; 22
     11  5249		       3e		      .byte.b	62	; 19
     12  524a		       ba		      .byte.b	186	; 16
     13  524b		       7c		      .byte.b	124	; 13
     14  524c		       18		      .byte.b	24	; 10
     15  524d		       0c		      .byte.b	12	; 7
     16  524e		       1e		      .byte.b	30	; 4
     17  524f		       00		      .byte.b	0	; 1
     18  5250		       34		      .byte.b	52	; 21
     19  5251		       52		      .byte.b	82	; 18
     20  5252		       be		      .byte.b	190	; 15
     21  5253		       38		      .byte.b	56	; 12
     22  5254		       1c		      .byte.b	28	; 9
     23  5255		       0a		      .byte.b	10	; 6
     24  5256		       1d		      .byte.b	29	; 3
     25  5257		       00		      .byte.b	0	; 0
     26  5258
     27  5258				   COLOURDATA_crouch1
     28  5258		       06		      .byte.b	CL6	; 23
     29  5259		       05		      .byte.b	CL5	; 20
     30  525a		       03		      .byte.b	CL3	; 17
     31  525b		       04		      .byte.b	CL4	; 14
     32  525c		       03		      .byte.b	CL3	; 11
     33  525d		       02		      .byte.b	CL2	; 8
     34  525e		       02		      .byte.b	CL2	; 5
     35  525f		       00		      .byte.b	CL0	; 2
     36  5260		       06		      .byte.b	CL6	; 22
     37  5261		       05		      .byte.b	CL5	; 19
     38  5262		       04		      .byte.b	CL4	; 16
     39  5263		       04		      .byte.b	CL4	; 13
     40  5264		       02		      .byte.b	CL2	; 10
     41  5265		       02		      .byte.b	CL2	; 7
     42  5266		       01		      .byte.b	CL1	; 4
     43  5267		       00		      .byte.b	CL0	; 1
     44  5268		       05		      .byte.b	CL5	; 21
     45  5269		       02		      .byte.b	CL2	; 18
     46  526a		       04		      .byte.b	CL4	; 15
     47  526b		       04		      .byte.b	CL4	; 12
     48  526c		       02		      .byte.b	CL2	; 9
     49  526d		       02		      .byte.b	CL2	; 6
     50  526e		       01		      .byte.b	CL1	; 3
     51  526f		       00		      .byte.b	CL0	; 0
     52  5270
     53  5270				   FRAMEDATA_walk1
     54  5270		       44		      .byte.b	68	; 23
     55  5271		       4c		      .byte.b	76	; 20
     56  5272		       28		      .byte.b	40	; 17
     57  5273		       ba		      .byte.b	186	; 14
     58  5274		       7c		      .byte.b	124	; 11
     59  5275		       18		      .byte.b	24	; 8
     60  5276		       0c		      .byte.b	12	; 5
     61  5277		       1e		      .byte.b	30	; 2
     62  5278		       82		      .byte.b	130	; 22
     63  5279		       1c		      .byte.b	28	; 19
     64  527a		       b2		      .byte.b	178	; 16
     65  527b		       bc		      .byte.b	188	; 13
     66  527c		       38		      .byte.b	56	; 10
     67  527d		       1c		      .byte.b	28	; 7
     68  527e		       0a		      .byte.b	10	; 4
     69  527f		       1d		      .byte.b	29	; 1
     70  5280		       6c		      .byte.b	108	; 21
     71  5281		       38		      .byte.b	56	; 18
     72  5282		       ba		      .byte.b	186	; 15
     73  5283		       fc		      .byte.b	252	; 12
     74  5284		       18		      .byte.b	24	; 9
     75  5285		       18		      .byte.b	24	; 6
     76  5286		       04		      .byte.b	4	; 3
     77  5287		       00		      .byte.b	0	; 0
     78  5288
     79  5288				   COLOURDATA_walk1
     80  5288		       06		      .byte.b	CL6	; 23
     81  5289		       05		      .byte.b	CL5	; 20
     82  528a		       05		      .byte.b	CL5	; 17
     83  528b		       04		      .byte.b	CL4	; 14
     84  528c		       04		      .byte.b	CL4	; 11
     85  528d		       02		      .byte.b	CL2	; 8
     86  528e		       02		      .byte.b	CL2	; 5
     87  528f		       01		      .byte.b	CL1	; 2
     88  5290		       06		      .byte.b	CL6	; 22
     89  5291		       05		      .byte.b	CL5	; 19
     90  5292		       02		      .byte.b	CL2	; 16
     91  5293		       04		      .byte.b	CL4	; 13
     92  5294		       04		      .byte.b	CL4	; 10
     93  5295		       02		      .byte.b	CL2	; 7
     94  5296		       02		      .byte.b	CL2	; 4
     95  5297		       01		      .byte.b	CL1	; 1
     96  5298		       05		      .byte.b	CL5	; 21
     97  5299		       05		      .byte.b	CL5	; 18
     98  529a		       03		      .byte.b	CL3	; 15
     99  529b		       04		      .byte.b	CL4	; 12
    100  529c		       03		      .byte.b	CL3	; 9
    101  529d		       02		      .byte.b	CL2	; 6
    102  529e		       02		      .byte.b	CL2	; 3
    103  529f		       00		      .byte.b	CL0	; 0
    104  52a0
    105  52a0				   FRAMEDATA_walk2
    106  52a0		       34		      .byte.b	52	; 23
    107  52a1		       28		      .byte.b	40	; 20
    108  52a2		       38		      .byte.b	56	; 17
    109  52a3		       ba		      .byte.b	186	; 14
    110  52a4		       fc		      .byte.b	252	; 11
    111  52a5		       18		      .byte.b	24	; 8
    112  52a6		       18		      .byte.b	24	; 5
    113  52a7		       04		      .byte.b	4	; 2
    114  52a8		       00		      .byte.b	0	; 22
    115  52a9		       28		      .byte.b	40	; 19
    116  52aa		       18		      .byte.b	24	; 16
    117  52ab		       ba		      .byte.b	186	; 13
    118  52ac		       7c		      .byte.b	124	; 10
    119  52ad		       18		      .byte.b	24	; 7
    120  52ae		       0c		      .byte.b	12	; 4
    121  52af		       1e		      .byte.b	30	; 1
    122  52b0		       28		      .byte.b	40	; 21
    123  52b1		       28		      .byte.b	40	; 18
    124  52b2		       b2		      .byte.b	178	; 15
    125  52b3		       bc		      .byte.b	188	; 12
    126  52b4		       38		      .byte.b	56	; 9
    127  52b5		       1c		      .byte.b	28	; 6
    128  52b6		       0a		      .byte.b	10	; 3
    129  52b7		       1d		      .byte.b	29	; 0
    130  52b8
    131  52b8				   COLOURDATA_walk2
    132  52b8		       06		      .byte.b	CL6	; 23
    133  52b9		       05		      .byte.b	CL5	; 20
    134  52ba		       05		      .byte.b	CL5	; 17
    135  52bb		       03		      .byte.b	CL3	; 14
    136  52bc		       04		      .byte.b	CL4	; 11
    137  52bd		       03		      .byte.b	CL3	; 8
    138  52be		       02		      .byte.b	CL2	; 5
    139  52bf		       02		      .byte.b	CL2	; 2
    140  52c0		       00		      .byte.b	CL0	; 22
    141  52c1		       05		      .byte.b	CL5	; 19
    142  52c2		       05		      .byte.b	CL5	; 16
    143  52c3		       04		      .byte.b	CL4	; 13
    144  52c4		       04		      .byte.b	CL4	; 10
    145  52c5		       02		      .byte.b	CL2	; 7
    146  52c6		       02		      .byte.b	CL2	; 4
    147  52c7		       01		      .byte.b	CL1	; 1
    148  52c8		       05		      .byte.b	CL5	; 21
    149  52c9		       05		      .byte.b	CL5	; 18
    150  52ca		       02		      .byte.b	CL2	; 15
    151  52cb		       04		      .byte.b	CL4	; 12
    152  52cc		       04		      .byte.b	CL4	; 9
    153  52cd		       02		      .byte.b	CL2	; 6
    154  52ce		       02		      .byte.b	CL2	; 3
    155  52cf		       01		      .byte.b	CL1	; 0
    156  52d0
    157  52d0				   FRAMEDATA_handlip
    158  52d0		       2c		      .byte.b	44	; 23
    159  52d1		       28		      .byte.b	40	; 20
    160  52d2		       38		      .byte.b	56	; 17
    161  52d3		       58		      .byte.b	88	; 14
    162  52d4		       fc		      .byte.b	252	; 11
    163  52d5		       1a		      .byte.b	26	; 8
    164  52d6		       18		      .byte.b	24	; 5
    165  52d7		       04		      .byte.b	4	; 2
    166  52d8		       00		      .byte.b	0	; 22
    167  52d9		       28		      .byte.b	40	; 19
    168  52da		       38		      .byte.b	56	; 16
    169  52db		       b8		      .byte.b	184	; 13
    170  52dc		       7e		      .byte.b	126	; 10
    171  52dd		       1a		      .byte.b	26	; 7
    172  52de		       0c		      .byte.b	12	; 4
    173  52df		       1e		      .byte.b	30	; 1
    174  52e0		       28		      .byte.b	40	; 21
    175  52e1		       28		      .byte.b	40	; 18
    176  52e2		       28		      .byte.b	40	; 15
    177  52e3		       b8		      .byte.b	184	; 12
    178  52e4		       3a		      .byte.b	58	; 9
    179  52e5		       1e		      .byte.b	30	; 6
    180  52e6		       0a		      .byte.b	10	; 3
    181  52e7		       1d		      .byte.b	29	; 0
    182  52e8
    183  52e8				   COLOURDATA_handlip
    184  52e8		       01		      .byte.b	CL1	; 23
    185  52e9		       02		      .byte.b	CL2	; 20
    186  52ea		       02		      .byte.b	CL2	; 17
    187  52eb		       06		      .byte.b	CL6	; 14
    188  52ec		       03		      .byte.b	CL3	; 11
    189  52ed		       06		      .byte.b	CL6	; 8
    190  52ee		       04		      .byte.b	CL4	; 5
    191  52ef		       04		      .byte.b	CL4	; 2
    192  52f0		       00		      .byte.b	CL0	; 22
    193  52f1		       02		      .byte.b	CL2	; 19
    194  52f2		       02		      .byte.b	CL2	; 16
    195  52f3		       03		      .byte.b	CL3	; 13
    196  52f4		       03		      .byte.b	CL3	; 10
    197  52f5		       04		      .byte.b	CL4	; 7
    198  52f6		       04		      .byte.b	CL4	; 4
    199  52f7		       05		      .byte.b	CL5	; 1
    200  52f8		       02		      .byte.b	CL2	; 21
    201  52f9		       02		      .byte.b	CL2	; 18
    202  52fa		       04		      .byte.b	CL4	; 15
    203  52fb		       03		      .byte.b	CL3	; 12
    204  52fc		       03		      .byte.b	CL3	; 9
    205  52fd		       04		      .byte.b	CL4	; 6
    206  52fe		       04		      .byte.b	CL4	; 3
    207  52ff		       05		      .byte.b	CL5	; 0
    208  5300
    209  5300				   FRAMEDATA_lookup
    210  5300		       34		      .byte.b	52	; 23
    211  5301		       28		      .byte.b	40	; 20
    212  5302		       18		      .byte.b	24	; 17
    213  5303		       b8		      .byte.b	184	; 14
    214  5304		       7e		      .byte.b	126	; 11
    215  5305		       32		      .byte.b	50	; 8
    216  5306		       70		      .byte.b	112	; 5
    217  5307		       40		      .byte.b	64	; 2
    218  5308		       00		      .byte.b	0	; 22
    219  5309		       28		      .byte.b	40	; 19
    220  530a		       b0		      .byte.b	176	; 16
    221  530b		       b8		      .byte.b	184	; 13
    222  530c		       7a		      .byte.b	122	; 10
    223  530d		       36		      .byte.b	54	; 7
    224  530e		       58		      .byte.b	88	; 4
    225  530f		       78		      .byte.b	120	; 1
    226  5310		       28		      .byte.b	40	; 21
    227  5311		       28		      .byte.b	40	; 18
    228  5312		       b8		      .byte.b	184	; 15
    229  5313		       fc		      .byte.b	252	; 12
    230  5314		       32		      .byte.b	50	; 9
    231  5315		       60		      .byte.b	96	; 6
    232  5316		       30		      .byte.b	48	; 3
    233  5317		       34		      .byte.b	52	; 0
    234  5318
    235  5318				   COLOURDATA_lookup
    236  5318		       06		      .byte.b	CL6	; 23
    237  5319		       05		      .byte.b	CL5	; 20
    238  531a		       05		      .byte.b	CL5	; 17
    239  531b		       04		      .byte.b	CL4	; 14
    240  531c		       04		      .byte.b	CL4	; 11
    241  531d		       02		      .byte.b	CL2	; 8
    242  531e		       02		      .byte.b	CL2	; 5
    243  531f		       01		      .byte.b	CL1	; 2
    244  5320		       00		      .byte.b	CL0	; 22
    245  5321		       05		      .byte.b	CL5	; 19
    246  5322		       02		      .byte.b	CL2	; 16
    247  5323		       04		      .byte.b	CL4	; 13
    248  5324		       04		      .byte.b	CL4	; 10
    249  5325		       02		      .byte.b	CL2	; 7
    250  5326		       02		      .byte.b	CL2	; 4
    251  5327		       01		      .byte.b	CL1	; 1
    252  5328		       05		      .byte.b	CL5	; 21
    253  5329		       05		      .byte.b	CL5	; 18
    254  532a		       03		      .byte.b	CL3	; 15
    255  532b		       04		      .byte.b	CL4	; 12
    256  532c		       03		      .byte.b	CL3	; 9
    257  532d		       02		      .byte.b	CL2	; 6
    258  532e		       02		      .byte.b	CL2	; 3
    259  532f		       01		      .byte.b	CL1	; 0
    260  5330
    261  5330				   FRAMEDATA_walk3
    262  5330		       44		      .byte.b	68	; 23
    263  5331		       74		      .byte.b	116	; 20
    264  5332		       28		      .byte.b	40	; 17
    265  5333		       ba		      .byte.b	186	; 14
    266  5334		       7c		      .byte.b	124	; 11
    267  5335		       18		      .byte.b	24	; 8
    268  5336		       0c		      .byte.b	12	; 5
    269  5337		       1e		      .byte.b	30	; 2
    270  5338		       82		      .byte.b	130	; 22
    271  5339		       34		      .byte.b	52	; 19
    272  533a		       b2		      .byte.b	178	; 16
    273  533b		       bc		      .byte.b	188	; 13
    274  533c		       38		      .byte.b	56	; 10
    275  533d		       1c		      .byte.b	28	; 7
    276  533e		       0a		      .byte.b	10	; 4
    277  533f		       1d		      .byte.b	29	; 1
    278  5340		       64		      .byte.b	100	; 21
    279  5341		       38		      .byte.b	56	; 18
    280  5342		       ba		      .byte.b	186	; 15
    281  5343		       fc		      .byte.b	252	; 12
    282  5344		       18		      .byte.b	24	; 9
    283  5345		       18		      .byte.b	24	; 6
    284  5346		       04		      .byte.b	4	; 3
    285  5347		       00		      .byte.b	0	; 0
    286  5348
    287  5348				   COLOURDATA_walk3
    288  5348		       06		      .byte.b	CL6	; 23
    289  5349		       05		      .byte.b	CL5	; 20
    290  534a		       05		      .byte.b	CL5	; 17
    291  534b		       04		      .byte.b	CL4	; 14
    292  534c		       04		      .byte.b	CL4	; 11
    293  534d		       02		      .byte.b	CL2	; 8
    294  534e		       02		      .byte.b	CL2	; 5
    295  534f		       01		      .byte.b	CL1	; 2
    296  5350		       06		      .byte.b	CL6	; 22
    297  5351		       05		      .byte.b	CL5	; 19
    298  5352		       02		      .byte.b	CL2	; 16
    299  5353		       04		      .byte.b	CL4	; 13
    300  5354		       04		      .byte.b	CL4	; 10
    301  5355		       02		      .byte.b	CL2	; 7
    302  5356		       02		      .byte.b	CL2	; 4
    303  5357		       01		      .byte.b	CL1	; 1
    304  5358		       05		      .byte.b	CL5	; 21
    305  5359		       05		      .byte.b	CL5	; 18
    306  535a		       03		      .byte.b	CL3	; 15
    307  535b		       04		      .byte.b	CL4	; 12
    308  535c		       03		      .byte.b	CL3	; 9
    309  535d		       02		      .byte.b	CL2	; 6
    310  535e		       02		      .byte.b	CL2	; 3
    311  535f		       00		      .byte.b	CL0	; 0
    312  5360
    313  5360				   FRAMEDATA_push_up_1
    314  5360		       00		      .byte.b	0	; 23
    315  5361		       20		      .byte.b	32	; 20
    316  5362		       20		      .byte.b	32	; 17
    317  5363		       20		      .byte.b	32	; 14
    318  5364		       38		      .byte.b	56	; 11
    319  5365		       38		      .byte.b	56	; 8
    320  5366		       ee		      .byte.b	238	; 5
    321  5367		       38		      .byte.b	56	; 2
    322  5368		       00		      .byte.b	0	; 22
    323  5369		       20		      .byte.b	32	; 19
    324  536a		       28		      .byte.b	40	; 16
    325  536b		       38		      .byte.b	56	; 13
    326  536c		       38		      .byte.b	56	; 10
    327  536d		       38		      .byte.b	56	; 7
    328  536e		       82		      .byte.b	130	; 4
    329  536f		       38		      .byte.b	56	; 1
    330  5370		       00		      .byte.b	0	; 21
    331  5371		       08		      .byte.b	8	; 18
    332  5372		       08		      .byte.b	8	; 15
    333  5373		       10		      .byte.b	16	; 12
    334  5374		       38		      .byte.b	56	; 9
    335  5375		       7c		      .byte.b	124	; 6
    336  5376		       aa		      .byte.b	170	; 3
    337  5377		       00		      .byte.b	0	; 0
    338  5378
    339  5378				   COLOURDATA_push_up_1
    340  5378		       00		      .byte.b	CL0	; 23
    341  5379		       06		      .byte.b	CL6	; 20
    342  537a		       05		      .byte.b	CL5	; 17
    343  537b		       05		      .byte.b	CL5	; 14
    344  537c		       06		      .byte.b	CL6	; 11
    345  537d		       04		      .byte.b	CL4	; 8
    346  537e		       04		      .byte.b	CL4	; 5
    347  537f		       01		      .byte.b	CL1	; 2
    348  5380		       00		      .byte.b	CL0	; 22
    349  5381		       06		      .byte.b	CL6	; 19
    350  5382		       05		      .byte.b	CL5	; 16
    351  5383		       05		      .byte.b	CL5	; 13
    352  5384		       03		      .byte.b	CL3	; 10
    353  5385		       04		      .byte.b	CL4	; 7
    354  5386		       03		      .byte.b	CL3	; 4
    355  5387		       01		      .byte.b	CL1	; 1
    356  5388		       00		      .byte.b	CL0	; 21
    357  5389		       06		      .byte.b	CL6	; 18
    358  538a		       05		      .byte.b	CL5	; 15
    359  538b		       05		      .byte.b	CL5	; 12
    360  538c		       04		      .byte.b	CL4	; 9
    361  538d		       04		      .byte.b	CL4	; 6
    362  538e		       02		      .byte.b	CL2	; 3
    363  538f		       00		      .byte.b	CL0	; 0
    364  5390
    365  5390				   FRAMEDATA_push_up_3
    366  5390		       00		      .byte.b	0	; 23
    367  5391		       08		      .byte.b	8	; 20
    368  5392		       08		      .byte.b	8	; 17
    369  5393		       08		      .byte.b	8	; 14
    370  5394		       38		      .byte.b	56	; 11
    371  5395		       38		      .byte.b	56	; 8
    372  5396		       ee		      .byte.b	238	; 5
    373  5397		       38		      .byte.b	56	; 2
    374  5398		       00		      .byte.b	0	; 22
    375  5399		       08		      .byte.b	8	; 19
    376  539a		       28		      .byte.b	40	; 16
    377  539b		       38		      .byte.b	56	; 13
    378  539c		       38		      .byte.b	56	; 10
    379  539d		       38		      .byte.b	56	; 7
    380  539e		       82		      .byte.b	130	; 4
    381  539f		       38		      .byte.b	56	; 1
    382  53a0		       00		      .byte.b	0	; 21
    383  53a1		       20		      .byte.b	32	; 18
    384  53a2		       20		      .byte.b	32	; 15
    385  53a3		       10		      .byte.b	16	; 12
    386  53a4		       38		      .byte.b	56	; 9
    387  53a5		       7c		      .byte.b	124	; 6
    388  53a6		       aa		      .byte.b	170	; 3
    389  53a7		       00		      .byte.b	0	; 0
    390  53a8
    391  53a8				   COLOURDATA_push_up_3
    392  53a8		       00		      .byte.b	CL0	; 23
    393  53a9		       06		      .byte.b	CL6	; 20
    394  53aa		       05		      .byte.b	CL5	; 17
    395  53ab		       05		      .byte.b	CL5	; 14
    396  53ac		       01		      .byte.b	CL1	; 11
    397  53ad		       04		      .byte.b	CL4	; 8
    398  53ae		       04		      .byte.b	CL4	; 5
    399  53af		       01		      .byte.b	CL1	; 2
    400  53b0		       00		      .byte.b	CL0	; 22
    401  53b1		       06		      .byte.b	CL6	; 19
    402  53b2		       05		      .byte.b	CL5	; 16
    403  53b3		       05		      .byte.b	CL5	; 13
    404  53b4		       03		      .byte.b	CL3	; 10
    405  53b5		       04		      .byte.b	CL4	; 7
    406  53b6		       03		      .byte.b	CL3	; 4
    407  53b7		       01		      .byte.b	CL1	; 1
    408  53b8		       00		      .byte.b	CL0	; 21
    409  53b9		       06		      .byte.b	CL6	; 18
    410  53ba		       05		      .byte.b	CL5	; 15
    411  53bb		       05		      .byte.b	CL5	; 12
    412  53bc		       04		      .byte.b	CL4	; 9
    413  53bd		       04		      .byte.b	CL4	; 6
    414  53be		       02		      .byte.b	CL2	; 3
    415  53bf		       00		      .byte.b	CL0	; 0
    416  53c0
    417  53c0				   FRAMEDATA_push_up_2
    418  53c0		       00		      .byte.b	0	; 23
    419  53c1		       00		      .byte.b	0	; 20
    420  53c2		       28		      .byte.b	40	; 17
    421  53c3		       28		      .byte.b	40	; 14
    422  53c4		       38		      .byte.b	56	; 11
    423  53c5		       38		      .byte.b	56	; 8
    424  53c6		       ee		      .byte.b	238	; 5
    425  53c7		       38		      .byte.b	56	; 2
    426  53c8		       00		      .byte.b	0	; 22
    427  53c9		       28		      .byte.b	40	; 19
    428  53ca		       28		      .byte.b	40	; 16
    429  53cb		       38		      .byte.b	56	; 13
    430  53cc		       38		      .byte.b	56	; 10
    431  53cd		       38		      .byte.b	56	; 7
    432  53ce		       82		      .byte.b	130	; 4
    433  53cf		       38		      .byte.b	56	; 1
    434  53d0		       00		      .byte.b	0	; 21
    435  53d1		       00		      .byte.b	0	; 18
    436  53d2		       00		      .byte.b	0	; 15
    437  53d3		       10		      .byte.b	16	; 12
    438  53d4		       38		      .byte.b	56	; 9
    439  53d5		       7c		      .byte.b	124	; 6
    440  53d6		       aa		      .byte.b	170	; 3
    441  53d7		       00		      .byte.b	0	; 0
    442  53d8
    443  53d8				   COLOURDATA_push_up_2
    444  53d8		       00		      .byte.b	CL0	; 23
    445  53d9		       00		      .byte.b	CL0	; 20
    446  53da		       05		      .byte.b	CL5	; 17
    447  53db		       05		      .byte.b	CL5	; 14
    448  53dc		       06		      .byte.b	CL6	; 11
    449  53dd		       04		      .byte.b	CL4	; 8
    450  53de		       04		      .byte.b	CL4	; 5
    451  53df		       01		      .byte.b	CL1	; 2
    452  53e0		       00		      .byte.b	CL0	; 22
    453  53e1		       06		      .byte.b	CL6	; 19
    454  53e2		       05		      .byte.b	CL5	; 16
    455  53e3		       05		      .byte.b	CL5	; 13
    456  53e4		       03		      .byte.b	CL3	; 10
    457  53e5		       04		      .byte.b	CL4	; 7
    458  53e6		       03		      .byte.b	CL3	; 4
    459  53e7		       01		      .byte.b	CL1	; 1
    460  53e8		       00		      .byte.b	CL0	; 21
    461  53e9		       00		      .byte.b	CL0	; 18
    462  53ea		       00		      .byte.b	CL0	; 15
    463  53eb		       05		      .byte.b	CL5	; 12
    464  53ec		       04		      .byte.b	CL4	; 9
    465  53ed		       04		      .byte.b	CL4	; 6
    466  53ee		       02		      .byte.b	CL2	; 3
    467  53ef		       00		      .byte.b	CL0	; 0
    468  53f0
    469  53f0				   FRAMEDATA_push3
    470  53f0		       46		      .byte.b	70	; 23
    471  53f1		       72		      .byte.b	114	; 20
    472  53f2		       18		      .byte.b	24	; 17
    473  53f3		       38		      .byte.b	56	; 14
    474  53f4		       3e		      .byte.b	62	; 11
    475  53f5		       19		      .byte.b	25	; 8
    476  53f6		       0c		      .byte.b	12	; 5
    477  53f7		       1e		      .byte.b	30	; 2
    478  53f8		       80		      .byte.b	128	; 22
    479  53f9		       3e		      .byte.b	62	; 19
    480  53fa		       30		      .byte.b	48	; 16
    481  53fb		       38		      .byte.b	56	; 13
    482  53fc		       3f		      .byte.b	63	; 10
    483  53fd		       1d		      .byte.b	29	; 7
    484  53fe		       0a		      .byte.b	10	; 4
    485  53ff		       1d		      .byte.b	29	; 1
    486  5400		       64		      .byte.b	100	; 21
    487  5401		       3c		      .byte.b	60	; 18
    488  5402		       38		      .byte.b	56	; 15
    489  5403		       3c		      .byte.b	60	; 12
    490  5404		       19		      .byte.b	25	; 9
    491  5405		       18		      .byte.b	24	; 6
    492  5406		       04		      .byte.b	4	; 3
    493  5407		       00		      .byte.b	0	; 0
    494  5408
    495  5408				   COLOURDATA_push3
    496  5408		       06		      .byte.b	CL6	; 23
    497  5409		       05		      .byte.b	CL5	; 20
    498  540a		       05		      .byte.b	CL5	; 17
    499  540b		       04		      .byte.b	CL4	; 14
    500  540c		       04		      .byte.b	CL4	; 11
    501  540d		       02		      .byte.b	CL2	; 8
    502  540e		       02		      .byte.b	CL2	; 5
    503  540f		       01		      .byte.b	CL1	; 2
    504  5410		       06		      .byte.b	CL6	; 22
    505  5411		       05		      .byte.b	CL5	; 19
    506  5412		       05		      .byte.b	CL5	; 16
    507  5413		       04		      .byte.b	CL4	; 13
    508  5414		       04		      .byte.b	CL4	; 10
    509  5415		       02		      .byte.b	CL2	; 7
    510  5416		       02		      .byte.b	CL2	; 4
    511  5417		       01		      .byte.b	CL1	; 1
    512  5418		       05		      .byte.b	CL5	; 21
    513  5419		       05		      .byte.b	CL5	; 18
    514  541a		       03		      .byte.b	CL3	; 15
    515  541b		       04		      .byte.b	CL4	; 12
    516  541c		       03		      .byte.b	CL3	; 9
    517  541d		       02		      .byte.b	CL2	; 6
    518  541e		       02		      .byte.b	CL2	; 3
    519  541f		       00		      .byte.b	CL0	; 0
    520  5420
    521  5420				   FRAMEDATA_idle3
    522  5420		       2c		      .byte.b	44	; 23
    523  5421		       28		      .byte.b	40	; 20
    524  5422		       38		      .byte.b	56	; 17
    525  5423		       38		      .byte.b	56	; 14
    526  5424		       38		      .byte.b	56	; 11
    527  5425		       b2		      .byte.b	178	; 8
    528  5426		       30		      .byte.b	48	; 5
    529  5427		       08		      .byte.b	8	; 2
    530  5428		       00		      .byte.b	0	; 22
    531  5429		       28		      .byte.b	40	; 19
    532  542a		       38		      .byte.b	56	; 16
    533  542b		       38		      .byte.b	56	; 13
    534  542c		       fe		      .byte.b	254	; 10
    535  542d		       ba		      .byte.b	186	; 7
    536  542e		       18		      .byte.b	24	; 4
    537  542f		       3c		      .byte.b	60	; 1
    538  5430		       28		      .byte.b	40	; 21
    539  5431		       28		      .byte.b	40	; 18
    540  5432		       28		      .byte.b	40	; 15
    541  5433		       38		      .byte.b	56	; 12
    542  5434		       fe		      .byte.b	254	; 9
    543  5435		       b2		      .byte.b	178	; 6
    544  5436		       14		      .byte.b	20	; 3
    545  5437		       3a		      .byte.b	58	; 0
    546  5438
    547  5438				   COLOURDATA_idle3
    548  5438		       06		      .byte.b	CL6	; 23
    549  5439		       05		      .byte.b	CL5	; 20
    550  543a		       05		      .byte.b	CL5	; 17
    551  543b		       03		      .byte.b	CL3	; 14
    552  543c		       04		      .byte.b	CL4	; 11
    553  543d		       03		      .byte.b	CL3	; 8
    554  543e		       02		      .byte.b	CL2	; 5
    555  543f		       02		      .byte.b	CL2	; 2
    556  5440		       00		      .byte.b	CL0	; 22
    557  5441		       05		      .byte.b	CL5	; 19
    558  5442		       05		      .byte.b	CL5	; 16
    559  5443		       04		      .byte.b	CL4	; 13
    560  5444		       04		      .byte.b	CL4	; 10
    561  5445		       02		      .byte.b	CL2	; 7
    562  5446		       02		      .byte.b	CL2	; 4
    563  5447		       01		      .byte.b	CL1	; 1
    564  5448		       05		      .byte.b	CL5	; 21
    565  5449		       05		      .byte.b	CL5	; 18
    566  544a		       02		      .byte.b	CL2	; 15
    567  544b		       04		      .byte.b	CL4	; 12
    568  544c		       04		      .byte.b	CL4	; 9
    569  544d		       02		      .byte.b	CL2	; 6
    570  544e		       02		      .byte.b	CL2	; 3
    571  544f		       01		      .byte.b	CL1	; 0
    572  5450
    573  5450				   FRAMEDATA_idle2
    574  5450		       2c		      .byte.b	44	; 23
    575  5451		       28		      .byte.b	40	; 20
    576  5452		       38		      .byte.b	56	; 17
    577  5453		       38		      .byte.b	56	; 14
    578  5454		       fe		      .byte.b	254	; 11
    579  5455		       b2		      .byte.b	178	; 8
    580  5456		       30		      .byte.b	48	; 5
    581  5457		       08		      .byte.b	8	; 2
    582  5458		       00		      .byte.b	0	; 22
    583  5459		       28		      .byte.b	40	; 19
    584  545a		       38		      .byte.b	56	; 16
    585  545b		       38		      .byte.b	56	; 13
    586  545c		       fe		      .byte.b	254	; 10
    587  545d		       ba		      .byte.b	186	; 7
    588  545e		       18		      .byte.b	24	; 4
    589  545f		       3c		      .byte.b	60	; 1
    590  5460		       28		      .byte.b	40	; 21
    591  5461		       28		      .byte.b	40	; 18
    592  5462		       28		      .byte.b	40	; 15
    593  5463		       38		      .byte.b	56	; 12
    594  5464		       ba		      .byte.b	186	; 9
    595  5465		       30		      .byte.b	48	; 6
    596  5466		       14		      .byte.b	20	; 3
    597  5467		       3a		      .byte.b	58	; 0
    598  5468
    599  5468				   COLOURDATA_idle2
    600  5468		       06		      .byte.b	CL6	; 23
    601  5469		       05		      .byte.b	CL5	; 20
    602  546a		       05		      .byte.b	CL5	; 17
    603  546b		       03		      .byte.b	CL3	; 14
    604  546c		       04		      .byte.b	CL4	; 11
    605  546d		       03		      .byte.b	CL3	; 8
    606  546e		       02		      .byte.b	CL2	; 5
    607  546f		       02		      .byte.b	CL2	; 2
    608  5470		       00		      .byte.b	CL0	; 22
    609  5471		       05		      .byte.b	CL5	; 19
    610  5472		       05		      .byte.b	CL5	; 16
    611  5473		       04		      .byte.b	CL4	; 13
    612  5474		       04		      .byte.b	CL4	; 10
    613  5475		       02		      .byte.b	CL2	; 7
    614  5476		       02		      .byte.b	CL2	; 4
    615  5477		       01		      .byte.b	CL1	; 1
    616  5478		       05		      .byte.b	CL5	; 21
    617  5479		       05		      .byte.b	CL5	; 18
    618  547a		       02		      .byte.b	CL2	; 15
    619  547b		       04		      .byte.b	CL4	; 12
    620  547c		       04		      .byte.b	CL4	; 9
    621  547d		       02		      .byte.b	CL2	; 6
    622  547e		       02		      .byte.b	CL2	; 3
    623  547f		       01		      .byte.b	CL1	; 0
    624  5480
    625  5480				   FRAMEDATA_push2
    626  5480		       26		      .byte.b	38	; 23
    627  5481		       14		      .byte.b	20	; 20
    628  5482		       3c		      .byte.b	60	; 17
    629  5483		       38		      .byte.b	56	; 14
    630  5484		       3c		      .byte.b	60	; 11
    631  5485		       19		      .byte.b	25	; 8
    632  5486		       18		      .byte.b	24	; 5
    633  5487		       04		      .byte.b	4	; 2
    634  5488		       40		      .byte.b	64	; 22
    635  5489		       14		      .byte.b	20	; 19
    636  548a		       28		      .byte.b	40	; 16
    637  548b		       38		      .byte.b	56	; 13
    638  548c		       3e		      .byte.b	62	; 10
    639  548d		       19		      .byte.b	25	; 7
    640  548e		       0c		      .byte.b	12	; 4
    641  548f		       1e		      .byte.b	30	; 1
    642  5490		       34		      .byte.b	52	; 21
    643  5491		       3c		      .byte.b	60	; 18
    644  5492		       30		      .byte.b	48	; 15
    645  5493		       38		      .byte.b	56	; 12
    646  5494		       3f		      .byte.b	63	; 9
    647  5495		       1d		      .byte.b	29	; 6
    648  5496		       0a		      .byte.b	10	; 3
    649  5497		       1d		      .byte.b	29	; 0
    650  5498
    651  5498				   COLOURDATA_push2
    652  5498		       06		      .byte.b	CL6	; 23
    653  5499		       05		      .byte.b	CL5	; 20
    654  549a		       05		      .byte.b	CL5	; 17
    655  549b		       03		      .byte.b	CL3	; 14
    656  549c		       04		      .byte.b	CL4	; 11
    657  549d		       03		      .byte.b	CL3	; 8
    658  549e		       02		      .byte.b	CL2	; 5
    659  549f		       02		      .byte.b	CL2	; 2
    660  54a0		       06		      .byte.b	CL6	; 22
    661  54a1		       05		      .byte.b	CL5	; 19
    662  54a2		       05		      .byte.b	CL5	; 16
    663  54a3		       04		      .byte.b	CL4	; 13
    664  54a4		       04		      .byte.b	CL4	; 10
    665  54a5		       02		      .byte.b	CL2	; 7
    666  54a6		       02		      .byte.b	CL2	; 4
    667  54a7		       01		      .byte.b	CL1	; 1
    668  54a8		       05		      .byte.b	CL5	; 21
    669  54a9		       05		      .byte.b	CL5	; 18
    670  54aa		       01		      .byte.b	CL1	; 15
    671  54ab		       04		      .byte.b	CL4	; 12
    672  54ac		       04		      .byte.b	CL4	; 9
    673  54ad		       02		      .byte.b	CL2	; 6
    674  54ae		       02		      .byte.b	CL2	; 3
    675  54af		       01		      .byte.b	CL1	; 0
    676  54b0
    677  54b0				   FRAMEDATA_idle1
    678  54b0		       2c		      .byte.b	44	; 23
    679  54b1		       28		      .byte.b	40	; 20
    680  54b2		       38		      .byte.b	56	; 17
    681  54b3		       ba		      .byte.b	186	; 14
    682  54b4		       fc		      .byte.b	252	; 11
    683  54b5		       18		      .byte.b	24	; 8
    684  54b6		       18		      .byte.b	24	; 5
    685  54b7		       04		      .byte.b	4	; 2
    686  54b8		       00		      .byte.b	0	; 22
    687  54b9		       28		      .byte.b	40	; 19
    688  54ba		       38		      .byte.b	56	; 16
    689  54bb		       ba		      .byte.b	186	; 13
    690  54bc		       7c		      .byte.b	124	; 10
    691  54bd		       18		      .byte.b	24	; 7
    692  54be		       0c		      .byte.b	12	; 4
    693  54bf		       1e		      .byte.b	30	; 1
    694  54c0		       28		      .byte.b	40	; 21
    695  54c1		       28		      .byte.b	40	; 18
    696  54c2		       aa		      .byte.b	170	; 15
    697  54c3		       bc		      .byte.b	188	; 12
    698  54c4		       38		      .byte.b	56	; 9
    699  54c5		       1c		      .byte.b	28	; 6
    700  54c6		       0a		      .byte.b	10	; 3
    701  54c7		       1d		      .byte.b	29	; 0
    702  54c8
    703  54c8				   COLOURDATA_idle1
    704  54c8		       06		      .byte.b	CL6	; 23
    705  54c9		       05		      .byte.b	CL5	; 20
    706  54ca		       05		      .byte.b	CL5	; 17
    707  54cb		       03		      .byte.b	CL3	; 14
    708  54cc		       04		      .byte.b	CL4	; 11
    709  54cd		       03		      .byte.b	CL3	; 8
    710  54ce		       02		      .byte.b	CL2	; 5
    711  54cf		       02		      .byte.b	CL2	; 2
    712  54d0		       00		      .byte.b	CL0	; 22
    713  54d1		       05		      .byte.b	CL5	; 19
    714  54d2		       05		      .byte.b	CL5	; 16
    715  54d3		       04		      .byte.b	CL4	; 13
    716  54d4		       04		      .byte.b	CL4	; 10
    717  54d5		       02		      .byte.b	CL2	; 7
    718  54d6		       02		      .byte.b	CL2	; 4
    719  54d7		       01		      .byte.b	CL1	; 1
    720  54d8		       05		      .byte.b	CL5	; 21
    721  54d9		       05		      .byte.b	CL5	; 18
    722  54da		       02		      .byte.b	CL2	; 15
    723  54db		       04		      .byte.b	CL4	; 12
    724  54dc		       04		      .byte.b	CL4	; 9
    725  54dd		       02		      .byte.b	CL2	; 6
    726  54de		       02		      .byte.b	CL2	; 3
    727  54df		       01		      .byte.b	CL1	; 0
    728  54e0
    729  54e0				   FRAMEDATA_push1
    730  54e0		       46		      .byte.b	70	; 23
    731  54e1		       62		      .byte.b	98	; 20
    732  54e2		       28		      .byte.b	40	; 17
    733  54e3		       38		      .byte.b	56	; 14
    734  54e4		       3e		      .byte.b	62	; 11
    735  54e5		       19		      .byte.b	25	; 8
    736  54e6		       0c		      .byte.b	12	; 5
    737  54e7		       1e		      .byte.b	30	; 2
    738  54e8		       80		      .byte.b	128	; 22
    739  54e9		       1e		      .byte.b	30	; 19
    740  54ea		       30		      .byte.b	48	; 16
    741  54eb		       38		      .byte.b	56	; 13
    742  54ec		       3f		      .byte.b	63	; 10
    743  54ed		       1d		      .byte.b	29	; 7
    744  54ee		       0a		      .byte.b	10	; 4
    745  54ef		       1d		      .byte.b	29	; 1
    746  54f0		       64		      .byte.b	100	; 21
    747  54f1		       3c		      .byte.b	60	; 18
    748  54f2		       38		      .byte.b	56	; 15
    749  54f3		       3c		      .byte.b	60	; 12
    750  54f4		       19		      .byte.b	25	; 9
    751  54f5		       18		      .byte.b	24	; 6
    752  54f6		       04		      .byte.b	4	; 3
    753  54f7		       00		      .byte.b	0	; 0
    754  54f8
    755  54f8				   COLOURDATA_push1
    756  54f8		       06		      .byte.b	CL6	; 23
    757  54f9		       05		      .byte.b	CL5	; 20
    758  54fa		       05		      .byte.b	CL5	; 17
    759  54fb		       04		      .byte.b	CL4	; 14
    760  54fc		       04		      .byte.b	CL4	; 11
    761  54fd		       02		      .byte.b	CL2	; 8
    762  54fe		       02		      .byte.b	CL2	; 5
    763  54ff		       01		      .byte.b	CL1	; 2
    764  5500		       06		      .byte.b	CL6	; 22
    765  5501		       05		      .byte.b	CL5	; 19
    766  5502		       06		      .byte.b	CL6	; 16
    767  5503		       04		      .byte.b	CL4	; 13
    768  5504		       04		      .byte.b	CL4	; 10
    769  5505		       02		      .byte.b	CL2	; 7
    770  5506		       02		      .byte.b	CL2	; 4
    771  5507		       01		      .byte.b	CL1	; 1
    772  5508		       05		      .byte.b	CL5	; 21
    773  5509		       05		      .byte.b	CL5	; 18
    774  550a		       03		      .byte.b	CL3	; 15
    775  550b		       04		      .byte.b	CL4	; 12
    776  550c		       03		      .byte.b	CL3	; 9
    777  550d		       02		      .byte.b	CL2	; 6
    778  550e		       02		      .byte.b	CL2	; 3
    779  550f		       00		      .byte.b	CL0	; 0
    780  5510
    781  5510				   FRAMEDATA_blink
    782  5510		       34		      .byte.b	52	; 23
    783  5511		       28		      .byte.b	40	; 20
    784  5512		       38		      .byte.b	56	; 17
    785  5513		       ba		      .byte.b	186	; 14
    786  5514		       fc		      .byte.b	252	; 11
    787  5515		       18		      .byte.b	24	; 8
    788  5516		       18		      .byte.b	24	; 5
    789  5517		       04		      .byte.b	4	; 2
    790  5518		       00		      .byte.b	0	; 22
    791  5519		       28		      .byte.b	40	; 19
    792  551a		       18		      .byte.b	24	; 16
    793  551b		       ba		      .byte.b	186	; 13
    794  551c		       7c		      .byte.b	124	; 10
    795  551d		       18		      .byte.b	24	; 7
    796  551e		       0c		      .byte.b	12	; 4
    797  551f		       1e		      .byte.b	30	; 1
    798  5520		       28		      .byte.b	40	; 21
    799  5521		       28		      .byte.b	40	; 18
    800  5522		       b2		      .byte.b	178	; 15
    801  5523		       bc		      .byte.b	188	; 12
    802  5524		       38		      .byte.b	56	; 9
    803  5525		       1c		      .byte.b	28	; 6
    804  5526		       0e		      .byte.b	14	; 3
    805  5527		       1d		      .byte.b	29	; 0
    806  5528
    807  5528				   COLOURDATA_blink
    808  5528		       06		      .byte.b	CL6	; 23
    809  5529		       05		      .byte.b	CL5	; 20
    810  552a		       05		      .byte.b	CL5	; 17
    811  552b		       03		      .byte.b	CL3	; 14
    812  552c		       04		      .byte.b	CL4	; 11
    813  552d		       03		      .byte.b	CL3	; 8
    814  552e		       02		      .byte.b	CL2	; 5
    815  552f		       02		      .byte.b	CL2	; 2
    816  5530		       00		      .byte.b	CL0	; 22
    817  5531		       05		      .byte.b	CL5	; 19
    818  5532		       05		      .byte.b	CL5	; 16
    819  5533		       04		      .byte.b	CL4	; 13
    820  5534		       04		      .byte.b	CL4	; 10
    821  5535		       02		      .byte.b	CL2	; 7
    822  5536		       02		      .byte.b	CL2	; 4
    823  5537		       01		      .byte.b	CL1	; 1
    824  5538		       05		      .byte.b	CL5	; 21
    825  5539		       05		      .byte.b	CL5	; 18
    826  553a		       02		      .byte.b	CL2	; 15
    827  553b		       04		      .byte.b	CL4	; 12
    828  553c		       04		      .byte.b	CL4	; 9
    829  553d		       02		      .byte.b	CL2	; 6
    830  553e		       02		      .byte.b	CL2	; 3
    831  553f		       01		      .byte.b	CL1	; 0
    832  5540
    833  5540				   FRAMEDATA_yell
    834  5540		       34		      .byte.b	52	; 23
    835  5541		       28		      .byte.b	40	; 20
    836  5542		       18		      .byte.b	24	; 17
    837  5543		       b8		      .byte.b	184	; 14
    838  5544		       7e		      .byte.b	126	; 11
    839  5545		       32		      .byte.b	50	; 8
    840  5546		       72		      .byte.b	114	; 5
    841  5547		       40		      .byte.b	64	; 2
    842  5548		       00		      .byte.b	0	; 22
    843  5549		       28		      .byte.b	40	; 19
    844  554a		       b0		      .byte.b	176	; 16
    845  554b		       b8		      .byte.b	184	; 13
    846  554c		       7a		      .byte.b	122	; 10
    847  554d		       36		      .byte.b	54	; 7
    848  554e		       58		      .byte.b	88	; 4
    849  554f		       78		      .byte.b	120	; 1
    850  5550		       28		      .byte.b	40	; 21
    851  5551		       28		      .byte.b	40	; 18
    852  5552		       b8		      .byte.b	184	; 15
    853  5553		       fc		      .byte.b	252	; 12
    854  5554		       32		      .byte.b	50	; 9
    855  5555		       62		      .byte.b	98	; 6
    856  5556		       30		      .byte.b	48	; 3
    857  5557		       34		      .byte.b	52	; 0
    858  5558
    859  5558				   COLOURDATA_yell
    860  5558		       06		      .byte.b	CL6	; 23
    861  5559		       05		      .byte.b	CL5	; 20
    862  555a		       05		      .byte.b	CL5	; 17
    863  555b		       04		      .byte.b	CL4	; 14
    864  555c		       04		      .byte.b	CL4	; 11
    865  555d		       02		      .byte.b	CL2	; 8
    866  555e		       02		      .byte.b	CL2	; 5
    867  555f		       01		      .byte.b	CL1	; 2
    868  5560		       00		      .byte.b	CL0	; 22
    869  5561		       05		      .byte.b	CL5	; 19
    870  5562		       02		      .byte.b	CL2	; 16
    871  5563		       04		      .byte.b	CL4	; 13
    872  5564		       04		      .byte.b	CL4	; 10
    873  5565		       02		      .byte.b	CL2	; 7
    874  5566		       02		      .byte.b	CL2	; 4
    875  5567		       01		      .byte.b	CL1	; 1
    876  5568		       05		      .byte.b	CL5	; 21
    877  5569		       05		      .byte.b	CL5	; 18
    878  556a		       03		      .byte.b	CL3	; 15
    879  556b		       04		      .byte.b	CL4	; 12
    880  556c		       03		      .byte.b	CL3	; 9
    881  556d		       02		      .byte.b	CL2	; 6
    882  556e		       02		      .byte.b	CL2	; 3
    883  556f		       01		      .byte.b	CL1	; 0
    884  5570
    885  5570				   FRAMEDATA_look2
    886  5570		       34		      .byte.b	52	; 23
    887  5571		       28		      .byte.b	40	; 20
    888  5572		       38		      .byte.b	56	; 17
    889  5573		       ba		      .byte.b	186	; 14
    890  5574		       7c		      .byte.b	124	; 11
    891  5575		       30		      .byte.b	48	; 8
    892  5576		       10		      .byte.b	16	; 5
    893  5577		       70		      .byte.b	112	; 2
    894  5578		       00		      .byte.b	0	; 22
    895  5579		       28		      .byte.b	40	; 19
    896  557a		       18		      .byte.b	24	; 16
    897  557b		       be		      .byte.b	190	; 13
    898  557c		       78		      .byte.b	120	; 10
    899  557d		       30		      .byte.b	48	; 7
    900  557e		       78		      .byte.b	120	; 4
    901  557f		       78		      .byte.b	120	; 1
    902  5580		       28		      .byte.b	40	; 21
    903  5581		       28		      .byte.b	40	; 18
    904  5582		       b2		      .byte.b	178	; 15
    905  5583		       fc		      .byte.b	252	; 12
    906  5584		       38		      .byte.b	56	; 9
    907  5585		       30		      .byte.b	48	; 6
    908  5586		       28		      .byte.b	40	; 3
    909  5587		       b8		      .byte.b	184	; 0
    910  5588
    911  5588				   COLOURDATA_look2
    912  5588		       06		      .byte.b	CL6	; 23
    913  5589		       05		      .byte.b	CL5	; 20
    914  558a		       05		      .byte.b	CL5	; 17
    915  558b		       03		      .byte.b	CL3	; 14
    916  558c		       04		      .byte.b	CL4	; 11
    917  558d		       03		      .byte.b	CL3	; 8
    918  558e		       02		      .byte.b	CL2	; 5
    919  558f		       02		      .byte.b	CL2	; 2
    920  5590		       00		      .byte.b	CL0	; 22
    921  5591		       05		      .byte.b	CL5	; 19
    922  5592		       05		      .byte.b	CL5	; 16
    923  5593		       04		      .byte.b	CL4	; 13
    924  5594		       04		      .byte.b	CL4	; 10
    925  5595		       02		      .byte.b	CL2	; 7
    926  5596		       02		      .byte.b	CL2	; 4
    927  5597		       01		      .byte.b	CL1	; 1
    928  5598		       05		      .byte.b	CL5	; 21
    929  5599		       05		      .byte.b	CL5	; 18
    930  559a		       02		      .byte.b	CL2	; 15
    931  559b		       04		      .byte.b	CL4	; 12
    932  559c		       04		      .byte.b	CL4	; 9
    933  559d		       02		      .byte.b	CL2	; 6
    934  559e		       02		      .byte.b	CL2	; 3
    935  559f		       01		      .byte.b	CL1	; 0
    936  55a0
    937  55a0				   FRAMEDATA_look3
    938  55a0		       34		      .byte.b	52	; 23
    939  55a1		       28		      .byte.b	40	; 20
    940  55a2		       38		      .byte.b	56	; 17
    941  55a3		       ba		      .byte.b	186	; 14
    942  55a4		       fc		      .byte.b	252	; 11
    943  55a5		       18		      .byte.b	24	; 8
    944  55a6		       10		      .byte.b	16	; 5
    945  55a7		       1c		      .byte.b	28	; 2
    946  55a8		       00		      .byte.b	0	; 22
    947  55a9		       28		      .byte.b	40	; 19
    948  55aa		       18		      .byte.b	24	; 16
    949  55ab		       ba		      .byte.b	186	; 13
    950  55ac		       7c		      .byte.b	124	; 10
    951  55ad		       18		      .byte.b	24	; 7
    952  55ae		       3c		      .byte.b	60	; 4
    953  55af		       3c		      .byte.b	60	; 1
    954  55b0		       28		      .byte.b	40	; 21
    955  55b1		       28		      .byte.b	40	; 18
    956  55b2		       b2		      .byte.b	178	; 15
    957  55b3		       bc		      .byte.b	188	; 12
    958  55b4		       38		      .byte.b	56	; 9
    959  55b5		       18		      .byte.b	24	; 6
    960  55b6		       28		      .byte.b	40	; 3
    961  55b7		       3a		      .byte.b	58	; 0
    962  55b8
    963  55b8				   COLOURDATA_look3
    964  55b8		       06		      .byte.b	CL6	; 23
    965  55b9		       05		      .byte.b	CL5	; 20
    966  55ba		       05		      .byte.b	CL5	; 17
    967  55bb		       03		      .byte.b	CL3	; 14
    968  55bc		       04		      .byte.b	CL4	; 11
    969  55bd		       03		      .byte.b	CL3	; 8
    970  55be		       02		      .byte.b	CL2	; 5
    971  55bf		       02		      .byte.b	CL2	; 2
    972  55c0		       00		      .byte.b	CL0	; 22
    973  55c1		       05		      .byte.b	CL5	; 19
    974  55c2		       05		      .byte.b	CL5	; 16
    975  55c3		       04		      .byte.b	CL4	; 13
    976  55c4		       04		      .byte.b	CL4	; 10
    977  55c5		       02		      .byte.b	CL2	; 7
    978  55c6		       02		      .byte.b	CL2	; 4
    979  55c7		       01		      .byte.b	CL1	; 1
    980  55c8		       05		      .byte.b	CL5	; 21
    981  55c9		       05		      .byte.b	CL5	; 18
    982  55ca		       02		      .byte.b	CL2	; 15
    983  55cb		       04		      .byte.b	CL4	; 12
    984  55cc		       04		      .byte.b	CL4	; 9
    985  55cd		       02		      .byte.b	CL2	; 6
    986  55ce		       02		      .byte.b	CL2	; 3
    987  55cf		       01		      .byte.b	CL1	; 0
    988  55d0
    989  55d0				   FRAMEDATA_look1
    990  55d0		       28		      .byte.b	40	; 23
    991  55d1		       28		      .byte.b	40	; 20
    992  55d2		       38		      .byte.b	56	; 17
    993  55d3		       59		      .byte.b	89	; 14
    994  55d4		       7c		      .byte.b	124	; 11
    995  55d5		       18		      .byte.b	24	; 8
    996  55d6		       18		      .byte.b	24	; 5
    997  55d7		       20		      .byte.b	32	; 2
    998  55d8		       00		      .byte.b	0	; 22
    999  55d9		       28		      .byte.b	40	; 19
   1000  55da		       38		      .byte.b	56	; 16
   1001  55db		       5a		      .byte.b	90	; 13
   1002  55dc		       3c		      .byte.b	60	; 10
   1003  55dd		       18		      .byte.b	24	; 7
   1004  55de		       30		      .byte.b	48	; 4
   1005  55df		       78		      .byte.b	120	; 1
   1006  55e0		       28		      .byte.b	40	; 21
   1007  55e1		       28		      .byte.b	40	; 18
   1008  55e2		       49		      .byte.b	73	; 15
   1009  55e3		       7e		      .byte.b	126	; 12
   1010  55e4		       18		      .byte.b	24	; 9
   1011  55e5		       38		      .byte.b	56	; 6
   1012  55e6		       50		      .byte.b	80	; 3
   1013  55e7		       b8		      .byte.b	184	; 0
   1014  55e8
   1015  55e8				   COLOURDATA_look1
   1016  55e8		       06		      .byte.b	CL6	; 23
   1017  55e9		       05		      .byte.b	CL5	; 20
   1018  55ea		       05		      .byte.b	CL5	; 17
   1019  55eb		       03		      .byte.b	CL3	; 14
   1020  55ec		       04		      .byte.b	CL4	; 11
   1021  55ed		       03		      .byte.b	CL3	; 8
   1022  55ee		       02		      .byte.b	CL2	; 5
   1023  55ef		       02		      .byte.b	CL2	; 2
   1024  55f0		       00		      .byte.b	CL0	; 22
   1025  55f1		       05		      .byte.b	CL5	; 19
   1026  55f2		       05		      .byte.b	CL5	; 16
   1027  55f3		       04		      .byte.b	CL4	; 13
   1028  55f4		       04		      .byte.b	CL4	; 10
   1029  55f5		       02		      .byte.b	CL2	; 7
   1030  55f6		       02		      .byte.b	CL2	; 4
   1031  55f7		       01		      .byte.b	CL1	; 1
   1032  55f8		       05		      .byte.b	CL5	; 21
   1033  55f9		       05		      .byte.b	CL5	; 18
   1034  55fa		       02		      .byte.b	CL2	; 15
   1035  55fb		       04		      .byte.b	CL4	; 12
   1036  55fc		       04		      .byte.b	CL4	; 9
   1037  55fd		       02		      .byte.b	CL2	; 6
   1038  55fe		       02		      .byte.b	CL2	; 3
   1039  55ff		       01		      .byte.b	CL1	; 0
   1040  5600
   1041  5600				   FRAMEDATA_tapfoot
   1042  5600		       24		      .byte.b	36	; 23
   1043  5601		       28		      .byte.b	40	; 20
   1044  5602		       38		      .byte.b	56	; 17
   1045  5603		       ba		      .byte.b	186	; 14
   1046  5604		       fc		      .byte.b	252	; 11
   1047  5605		       18		      .byte.b	24	; 8
   1048  5606		       18		      .byte.b	24	; 5
   1049  5607		       04		      .byte.b	4	; 2
   1050  5608		       10		      .byte.b	16	; 22
   1051  5609		       28		      .byte.b	40	; 19
   1052  560a		       18		      .byte.b	24	; 16
   1053  560b		       ba		      .byte.b	186	; 13
   1054  560c		       7c		      .byte.b	124	; 10
   1055  560d		       18		      .byte.b	24	; 7
   1056  560e		       0c		      .byte.b	12	; 4
   1057  560f		       1e		      .byte.b	30	; 1
   1058  5610		       28		      .byte.b	40	; 21
   1059  5611		       28		      .byte.b	40	; 18
   1060  5612		       b2		      .byte.b	178	; 15
   1061  5613		       bc		      .byte.b	188	; 12
   1062  5614		       38		      .byte.b	56	; 9
   1063  5615		       1c		      .byte.b	28	; 6
   1064  5616		       0a		      .byte.b	10	; 3
   1065  5617		       1d		      .byte.b	29	; 0
   1066  5618
   1067  5618				   COLOURDATA_tapfoot
   1068  5618		       06		      .byte.b	CL6	; 23
   1069  5619		       05		      .byte.b	CL5	; 20
   1070  561a		       05		      .byte.b	CL5	; 17
   1071  561b		       03		      .byte.b	CL3	; 14
   1072  561c		       04		      .byte.b	CL4	; 11
   1073  561d		       03		      .byte.b	CL3	; 8
   1074  561e		       02		      .byte.b	CL2	; 5
   1075  561f		       02		      .byte.b	CL2	; 2
   1076  5620		       06		      .byte.b	CL6	; 22
   1077  5621		       05		      .byte.b	CL5	; 19
   1078  5622		       05		      .byte.b	CL5	; 16
   1079  5623		       04		      .byte.b	CL4	; 13
   1080  5624		       04		      .byte.b	CL4	; 10
   1081  5625		       02		      .byte.b	CL2	; 7
   1082  5626		       02		      .byte.b	CL2	; 4
   1083  5627		       01		      .byte.b	CL1	; 1
   1084  5628		       05		      .byte.b	CL5	; 21
   1085  5629		       05		      .byte.b	CL5	; 18
   1086  562a		       02		      .byte.b	CL2	; 15
   1087  562b		       04		      .byte.b	CL4	; 12
   1088  562c		       04		      .byte.b	CL4	; 9
   1089  562d		       02		      .byte.b	CL2	; 6
   1090  562e		       02		      .byte.b	CL2	; 3
   1091  562f		       01		      .byte.b	CL1	; 0
   1092  5630
   1093  5630
   1094  5630				   __FNUM     SET	0
   1095  5630					      MAC	deframe
   1096  5630				   FRAME_{1}  =	__FNUM
   1097  5630				   __FNUM     SET	__FNUM + 1
   1098  5630					      ENDM		;{name}
   1099  5630
      0  5630					      DEFRAME	CROUCH1
      1  5630		       00 00	   FRAME_CROUCH1 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	WALK1
      1  5630		       00 01	   FRAME_WALK1 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	WALK2
      1  5630		       00 02	   FRAME_WALK2 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	HANDLIP
      1  5630		       00 03	   FRAME_HANDLIP =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	LOOKUP
      1  5630		       00 04	   FRAME_LOOKUP =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	WALK3
      1  5630		       00 05	   FRAME_WALK3 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	PUSH_UP_1
      1  5630		       00 06	   FRAME_PUSH_UP_1 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	PUSH_UP_3
      1  5630		       00 07	   FRAME_PUSH_UP_3 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	PUSH_UP_2
      1  5630		       00 08	   FRAME_PUSH_UP_2 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	PUSH3
      1  5630		       00 09	   FRAME_PUSH3 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	IDLE3
      1  5630		       00 0a	   FRAME_IDLE3 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	IDLE2
      1  5630		       00 0b	   FRAME_IDLE2 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	PUSH2
      1  5630		       00 0c	   FRAME_PUSH2 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	IDLE1
      1  5630		       00 0d	   FRAME_IDLE1 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	PUSH1
      1  5630		       00 0e	   FRAME_PUSH1 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	BLINK
      1  5630		       00 0f	   FRAME_BLINK =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	YELL
      1  5630		       00 10	   FRAME_YELL =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	LOOK2
      1  5630		       00 11	   FRAME_LOOK2 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	LOOK3
      1  5630		       00 12	   FRAME_LOOK3 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	LOOK1
      1  5630		       00 13	   FRAME_LOOK1 =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
      0  5630					      DEFRAME	TAPFOOT
      1  5630		       00 14	   FRAME_TAPFOOT =	__FNUM
      2  5630				   __FNUM     SET	__FNUM + 1
   1121  5630
   1122  5630				   FRAME_PTR_LO
   1123  5630		       40		      .byte.b	<FRAMEDATA_crouch1
   1124  5631		       70		      .byte.b	<FRAMEDATA_walk1
   1125  5632		       a0		      .byte.b	<FRAMEDATA_walk2
   1126  5633		       d0		      .byte.b	<FRAMEDATA_handlip
   1127  5634		       00		      .byte.b	<FRAMEDATA_lookup
   1128  5635		       30		      .byte.b	<FRAMEDATA_walk3
   1129  5636		       60		      .byte.b	<FRAMEDATA_push_up_1
   1130  5637		       90		      .byte.b	<FRAMEDATA_push_up_3
   1131  5638		       c0		      .byte.b	<FRAMEDATA_push_up_2
   1132  5639		       f0		      .byte.b	<FRAMEDATA_push3
   1133  563a		       20		      .byte.b	<FRAMEDATA_idle3
   1134  563b		       50		      .byte.b	<FRAMEDATA_idle2
   1135  563c		       80		      .byte.b	<FRAMEDATA_push2
   1136  563d		       b0		      .byte.b	<FRAMEDATA_idle1
   1137  563e		       e0		      .byte.b	<FRAMEDATA_push1
   1138  563f		       10		      .byte.b	<FRAMEDATA_blink
   1139  5640		       40		      .byte.b	<FRAMEDATA_yell
   1140  5641		       70		      .byte.b	<FRAMEDATA_look2
   1141  5642		       a0		      .byte.b	<FRAMEDATA_look3
   1142  5643		       d0		      .byte.b	<FRAMEDATA_look1
   1143  5644		       00		      .byte.b	<FRAMEDATA_tapfoot
   1144  5645
   1145  5645				   FRAME_PTR_HI
   1146  5645		       f2		      .byte.b	>FRAMEDATA_crouch1
   1147  5646		       f2		      .byte.b	>FRAMEDATA_walk1
   1148  5647		       f2		      .byte.b	>FRAMEDATA_walk2
   1149  5648		       f2		      .byte.b	>FRAMEDATA_handlip
   1150  5649		       f3		      .byte.b	>FRAMEDATA_lookup
   1151  564a		       f3		      .byte.b	>FRAMEDATA_walk3
   1152  564b		       f3		      .byte.b	>FRAMEDATA_push_up_1
   1153  564c		       f3		      .byte.b	>FRAMEDATA_push_up_3
   1154  564d		       f3		      .byte.b	>FRAMEDATA_push_up_2
   1155  564e		       f3		      .byte.b	>FRAMEDATA_push3
   1156  564f		       f4		      .byte.b	>FRAMEDATA_idle3
   1157  5650		       f4		      .byte.b	>FRAMEDATA_idle2
   1158  5651		       f4		      .byte.b	>FRAMEDATA_push2
   1159  5652		       f4		      .byte.b	>FRAMEDATA_idle1
   1160  5653		       f4		      .byte.b	>FRAMEDATA_push1
   1161  5654		       f5		      .byte.b	>FRAMEDATA_blink
   1162  5655		       f5		      .byte.b	>FRAMEDATA_yell
   1163  5656		       f5		      .byte.b	>FRAMEDATA_look2
   1164  5657		       f5		      .byte.b	>FRAMEDATA_look3
   1165  5658		       f5		      .byte.b	>FRAMEDATA_look1
   1166  5659		       f6		      .byte.b	>FRAMEDATA_tapfoot
   1167  565a
   1168  565a				   COLOUR_PTR_LO
   1169  565a		       58		      .byte.b	<COLOURDATA_crouch1
   1170  565b		       88		      .byte.b	<COLOURDATA_walk1
   1171  565c		       b8		      .byte.b	<COLOURDATA_walk2
   1172  565d		       e8		      .byte.b	<COLOURDATA_handlip
   1173  565e		       18		      .byte.b	<COLOURDATA_lookup
   1174  565f		       48		      .byte.b	<COLOURDATA_walk3
   1175  5660		       78		      .byte.b	<COLOURDATA_push_up_1
   1176  5661		       a8		      .byte.b	<COLOURDATA_push_up_3
   1177  5662		       d8		      .byte.b	<COLOURDATA_push_up_2
   1178  5663		       08		      .byte.b	<COLOURDATA_push3
   1179  5664		       38		      .byte.b	<COLOURDATA_idle3
   1180  5665		       68		      .byte.b	<COLOURDATA_idle2
   1181  5666		       98		      .byte.b	<COLOURDATA_push2
   1182  5667		       c8		      .byte.b	<COLOURDATA_idle1
   1183  5668		       f8		      .byte.b	<COLOURDATA_push1
   1184  5669		       28		      .byte.b	<COLOURDATA_blink
   1185  566a		       58		      .byte.b	<COLOURDATA_yell
   1186  566b		       88		      .byte.b	<COLOURDATA_look2
   1187  566c		       b8		      .byte.b	<COLOURDATA_look3
   1188  566d		       e8		      .byte.b	<COLOURDATA_look1
   1189  566e		       18		      .byte.b	<COLOURDATA_tapfoot
   1190  566f
   1191  566f				   COLOUR_PTR_HI
   1192  566f		       f2		      .byte.b	>COLOURDATA_crouch1
   1193  5670		       f2		      .byte.b	>COLOURDATA_walk1
   1194  5671		       f2		      .byte.b	>COLOURDATA_walk2
   1195  5672		       f2		      .byte.b	>COLOURDATA_handlip
   1196  5673		       f3		      .byte.b	>COLOURDATA_lookup
   1197  5674		       f3		      .byte.b	>COLOURDATA_walk3
   1198  5675		       f3		      .byte.b	>COLOURDATA_push_up_1
   1199  5676		       f3		      .byte.b	>COLOURDATA_push_up_3
   1200  5677		       f3		      .byte.b	>COLOURDATA_push_up_2
   1201  5678		       f4		      .byte.b	>COLOURDATA_push3
   1202  5679		       f4		      .byte.b	>COLOURDATA_idle3
   1203  567a		       f4		      .byte.b	>COLOURDATA_idle2
   1204  567b		       f4		      .byte.b	>COLOURDATA_push2
   1205  567c		       f4		      .byte.b	>COLOURDATA_idle1
   1206  567d		       f4		      .byte.b	>COLOURDATA_push1
   1207  567e		       f5		      .byte.b	>COLOURDATA_blink
   1208  567f		       f5		      .byte.b	>COLOURDATA_yell
   1209  5680		       f5		      .byte.b	>COLOURDATA_look2
   1210  5681		       f5		      .byte.b	>COLOURDATA_look3
   1211  5682		       f5		      .byte.b	>COLOURDATA_look1
   1212  5683		       f6		      .byte.b	>COLOURDATA_tapfoot
------- FILE BANK_PlayerFrames.asm
    189  5684
      0  5684					      CHECK_BANK_SIZE	"PLAYER_FRAMES"
      1  5684		       06 84	   .TEMP      =	* - BANK_START
 PLAYER_FRAMES (2K) SIZE =  $684 , FREE= $17c
      2  5684					      ECHO	"PLAYER_FRAMES", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5684				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  5684				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5684				  -	      ERR
      6  5684					      endif
------- FILE ./sokoboo.asm
------- FILE titleScreen.asm LEVEL 2 PASS 3
      0  5684					      include	"titleScreen.asm"
      0  5684					      NEWBANK	TITLESCREEN
      1  5c6b ????				      SEG	TITLESCREEN
      2  5800					      ORG	ORIGIN
      3  5800					      RORG	$F000
      4  5800				   BANK_START SET	*
      5  5800				   TITLESCREEN SET	ORIGIN / 2048
      6  5800				   ORIGIN     SET	ORIGIN + 2048
      7  5800				   _CURRENT_BANK SET	TITLESCREEN
      0  5800					      DEFINE_SUBROUTINE	TitleScreen
      1  5800		       00 0b	   BANK_TitleScreen =	_CURRENT_BANK
      2  5800					      SUBROUTINE
      3  5800				   TitleScreen
      3  5800
      4  5800							; Start of new frame
      5  5800
      6  5800							; Start of vertical blank processing
      7  5800
      8  5800				   TitleSequence
      9  5800
     10  5800		       a9 00		      lda	#%00000000
     11  5802		       85 4a		      sta	CTRLPF
     12  5804		       85 49		      sta	COLUBK
     13  5806
     14  5806		       a6 80		      ldx	Platform
     15  5808		       bd a7 f0 	      lda	colvec,x
     16  580b		       85 d2		      sta	colour_table
     17  580d		       bd a8 f0 	      lda	colvec+1,x
     18  5810		       85 d3		      sta	colour_table+1
     19  5812
      0  5812					      RESYNC
      1  5812
      2  5812		       a9 02		      lda	#%10
      3  5814		       85 41		      sta	VBLANK
      4  5816
      5  5816		       a2 08		      ldx	#8
      6  5818				   .loopResync
      0  5818					      VERTICAL_SYNC
      1  5818		       a9 0e		      lda	#%1110
      2  581a		       85 42	   .VSLP1     sta	WSYNC
      3  581c		       85 40		      sta	VSYNC
      4  581e		       4a		      lsr
      5  581f		       d0 f9		      bne	.VSLP1
      8  5821
      9  5821		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  5823		       a5 80		      lda	Platform
     11  5825		       49 02		      eor	#PAL_50
     12  5827		       d0 02		      bne	.ntsc
     13  5829		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  582b				   .ntsc
     15  582b				   .loopWait
     16  582b		       85 42		      sta	WSYNC
     17  582d		       85 42		      sta	WSYNC
     18  582f		       88		      dey
     19  5830		       d0 f9		      bne	.loopWait
     20  5832		       ca		      dex
     21  5833		       d0 e3		      bne	.loopResync
     21  5835
      0  5835					      DEFINE_SUBROUTINE	RestartFrame
      1  5835		       00 0b	   BANK_RestartFrame =	_CURRENT_BANK
      2  5835					      SUBROUTINE
      3  5835				   RestartFrame
     23  5835		       a9 0e		      lda	#%1110	; VSYNC ON
     24  5837		       85 42	   .loopVSync2 sta	WSYNC
     25  5839		       85 40		      sta	VSYNC
     26  583b		       4a		      lsr
     27  583c		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     28  583e
     29  583e							;------------------------------------------------------------------
     30  583e
     31  583e		       a6 80		      ldx	Platform
     32  5840		       bc aa fc 	      ldy	VBlankTime,x
     33  5843		       8c 96 02 	      sty	TIM64T
     34  5846
     35  5846		       85 42	   VerticalBlank sta	WSYNC
     36  5848		       ad 84 02 	      lda	INTIM
     37  584b		       d0 f9		      bne	VerticalBlank
     38  584d		       85 41		      sta	VBLANK
     39  584f
     40  584f
     41  584f							;------------------------------------------------------------------
     42  584f
     43  584f							; Do X scanlines of color-changing (our picture)
     44  584f
     45  584f		       a0 77		      ldy	#119	; this counts our scanline number
     46  5851		       a2 03	   SokoLogo   ldx	#3
     47  5853		       b1 d2	   triplet    lda	(colour_table),y
     48  5855		       85 42		      sta	WSYNC
     49  5857		       85 48		      sta	COLUPF	; 3
     50  5859
     51  5859		       b9 9b f1 	      lda	COL_0,y	; 5
     52  585c		       85 4d		      sta	PF0	; 3   @11
     53  585e		       b9 13 f2 	      lda	COL_1,y	; 5
     54  5861		       85 4e		      sta	PF1	; 3   @19
     55  5863		       b9 8b f2 	      lda	COL_2,y	; 5
     56  5866		       85 4f		      sta	PF2	; 3   @27
     57  5868
     58  5868		       b9 03 f3 	      lda	COL_3,y	; 5
     59  586b		       85 4d		      sta	PF0	; 3   @35
      0  586d					      SLEEP	2	; @37
      1  586d				   .CYCLES    SET	2
      2  586d
      3  586d				  -	      IF	.CYCLES < 2
      4  586d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  586d				  -	      ERR
      6  586d					      ENDIF
      7  586d
      8  586d				  -	      IF	.CYCLES & 1
      9  586d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  586d				  -	      nop	0
     11  586d				  -	      ELSE
     12  586d				  -	      bit	VSYNC
     13  586d				  -	      ENDIF
     14  586d				  -.CYCLES    SET	.CYCLES - 3
     15  586d					      ENDIF
     16  586d
     17  586d					      REPEAT	.CYCLES / 2
     18  586d		       ea		      nop
     19  586e					      REPEND
     61  586e		       b9 7b f3 	      lda	COL_4,y	; 5
     62  5871		       85 4e		      sta	PF1	; 3   @45
      0  5873					      SLEEP	3	; @45
      1  5873				   .CYCLES    SET	3
      2  5873
      3  5873				  -	      IF	.CYCLES < 2
      4  5873				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  5873				  -	      ERR
      6  5873					      ENDIF
      7  5873
      8  5873					      IF	.CYCLES & 1
      9  5873					      IFNCONST	NO_ILLEGAL_OPCODES
     10  5873		       04 00		      nop	0
     11  5875				  -	      ELSE
     12  5875				  -	      bit	VSYNC
     13  5875					      ENDIF
     14  5875				   .CYCLES    SET	.CYCLES - 3
     15  5875					      ENDIF
     16  5875
     17  5875				  -	      REPEAT	.CYCLES / 2
     18  5875				  -	      nop
     19  5875					      REPEND
     64  5875		       b9 f3 f3 	      lda	COL_5,y	; 5
     65  5878		       85 4f		      sta	PF2	; 3
     66  587a
     67  587a		       88		      dey		; 2
     68  587b		       ca		      dex		; 2
     69  587c		       d0 d5		      bne	triplet	; 2(3)
     70  587e
     71  587e		       c0 ff		      cpy	#-1	; 2
     72  5880		       d0 cf		      bne	SokoLogo	; 2(3)
     73  5882
     74  5882		       a9 00		      lda	#0
     75  5884		       85 4d		      sta	PF0
     76  5886		       85 4e		      sta	PF1
     77  5888		       85 4f		      sta	PF2
     78  588a
     79  588a		       a6 80		      ldx	Platform
     80  588c		       bd a3 f0 	      lda	OverscanTime2,x
     81  588f		       8d 96 02 	      sta	TIM64T
     82  5892
     83  5892				  -	      if	0
     84  5892				  -	      sta	WSYNC
     85  5892				  -	      sta	WSYNC
     86  5892				  -	      sta	WSYNC
     87  5892				  -	      sta	WSYNC
     88  5892				  -	      sta	WSYNC
     89  5892				  -	      SLEEP	8
     90  5892				  -	      jsr	SokoScreen
     91  5892				  -
     92  5892				  -	      lda	#0
     93  5892				  -	      sta	BoardScrollX
     94  5892				  -	      sta	BoardScrollY
     95  5892					      endif
     96  5892
     97  5892							;		ldy #63
     98  5892							;bot2		 sta WSYNC
     99  5892							;		dey
    100  5892							;		bpl bot2
    101  5892
    102  5892							;--------------------------------------------------------------------------
    103  5892
    104  5892							;		lda #0
    105  5892							;		sta PF0
    106  5892							;		sta PF1
    107  5892							;		sta PF2
    108  5892
    109  5892
    110  5892
    111  5892							; D1 VBLANK turns off beam
    112  5892							; It needs to be turned on 37 scanlines later
    113  5892
    114  5892				   oscan
    115  5892		       ad 84 02 	      lda	INTIM
    116  5895		       d0 fb		      bne	oscan
    117  5897
    118  5897		       a9 42		      lda	#%01000010	; bit6 is not required
    119  5899		       85 41		      sta	VBLANK	; end of screen - enter blanking
    120  589b
    121  589b		       a5 4c		      lda	INPT4
    122  589d		       10 03		      bpl	ret
    123  589f
    124  589f		       4c 35 f0 	      jmp	RestartFrame
    125  58a2
    126  58a2		       60	   ret	      rts
    127  58a3
    128  58a3				   OverscanTime2
    129  58a3		       85 85		      .byte.b	133, 133
    130  58a5		       8b 8b		      .byte.b	139, 139
    131  58a7
    132  58a7				   colvec
    133  58a7		       23 f1 ab f0	      .word.w	colr_ntsc, colr_pal
    134  58ab
    135  58ab
    136  58ab					      MAC	lumtable
    137  58ab							; {4} MIN LUM 1
    138  58ab							; {5} MIN LUM 2
    139  58ab							; {6} MIN LUM 3
    140  58ab
    141  58ab				   .LUM1      SET	{4}*256
    142  58ab				   .LUM2      SET	{5}*256
    143  58ab				   .LUM3      SET	{6}*256
    144  58ab
    145  58ab				   .STEP1     =	(256*({7}-{4}))/40
    146  58ab				   .STEP2     =	(256*({8}-{5}))/40
    147  58ab				   .STEP3     =	(256*({9}-{6}))/40
    148  58ab
    149  58ab					      REPEAT	40
    150  58ab					      .byte	{1}+(.LUM1/256)
    151  58ab					      .byte	{2}+(.LUM2/256)
    152  58ab					      .byte	{3}+(.LUM3/256)
    153  58ab				   .LUM1      SET	.LUM1 + .STEP1
    154  58ab				   .LUM2      SET	.LUM2 + .STEP2
    155  58ab				   .LUM3      SET	.LUM3 + .STEP3
    156  58ab					      REPEND
    157  58ab					      ENDM		;{1}{2}{3} base colours
    158  58ab
    159  58ab							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
      0  58ab				   colr_pal   LUMTABLE	$b0, $70, $40, 6,7,8, $C,$E,$E
      1  58ab
      2  58ab
      3  58ab
      4  58ab
      5  58ab				   .LUM1      SET	6*256
      6  58ab				   .LUM2      SET	7*256
      7  58ab				   .LUM3      SET	8*256
      8  58ab
      9  58ab		       00 26	   .STEP1     =	(256*($C-6))/40
     10  58ab		       00 2c	   .STEP2     =	(256*($E-7))/40
     11  58ab		       00 26	   .STEP3     =	(256*($E-8))/40
     12  58ab
     13  58ab					      REPEAT	40
     14  58ab		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58ac		       77		      .byte.b	$70+(.LUM2/256)
     16  58ad		       48		      .byte.b	$40+(.LUM3/256)
     17  58ad				   .LUM1      SET	.LUM1 + .STEP1
     18  58ad				   .LUM2      SET	.LUM2 + .STEP2
     19  58ad				   .LUM3      SET	.LUM3 + .STEP3
     13  58ad					      REPEND
     14  58ae		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58af		       77		      .byte.b	$70+(.LUM2/256)
     16  58b0		       48		      .byte.b	$40+(.LUM3/256)
     17  58b0				   .LUM1      SET	.LUM1 + .STEP1
     18  58b0				   .LUM2      SET	.LUM2 + .STEP2
     19  58b0				   .LUM3      SET	.LUM3 + .STEP3
     13  58b0					      REPEND
     14  58b1		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58b2		       77		      .byte.b	$70+(.LUM2/256)
     16  58b3		       48		      .byte.b	$40+(.LUM3/256)
     17  58b3				   .LUM1      SET	.LUM1 + .STEP1
     18  58b3				   .LUM2      SET	.LUM2 + .STEP2
     19  58b3				   .LUM3      SET	.LUM3 + .STEP3
     13  58b3					      REPEND
     14  58b4		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58b5		       77		      .byte.b	$70+(.LUM2/256)
     16  58b6		       48		      .byte.b	$40+(.LUM3/256)
     17  58b6				   .LUM1      SET	.LUM1 + .STEP1
     18  58b6				   .LUM2      SET	.LUM2 + .STEP2
     19  58b6				   .LUM3      SET	.LUM3 + .STEP3
     13  58b6					      REPEND
     14  58b7		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58b8		       77		      .byte.b	$70+(.LUM2/256)
     16  58b9		       48		      .byte.b	$40+(.LUM3/256)
     17  58b9				   .LUM1      SET	.LUM1 + .STEP1
     18  58b9				   .LUM2      SET	.LUM2 + .STEP2
     19  58b9				   .LUM3      SET	.LUM3 + .STEP3
     13  58b9					      REPEND
     14  58ba		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58bb		       77		      .byte.b	$70+(.LUM2/256)
     16  58bc		       48		      .byte.b	$40+(.LUM3/256)
     17  58bc				   .LUM1      SET	.LUM1 + .STEP1
     18  58bc				   .LUM2      SET	.LUM2 + .STEP2
     19  58bc				   .LUM3      SET	.LUM3 + .STEP3
     13  58bc					      REPEND
     14  58bd		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58be		       78		      .byte.b	$70+(.LUM2/256)
     16  58bf		       48		      .byte.b	$40+(.LUM3/256)
     17  58bf				   .LUM1      SET	.LUM1 + .STEP1
     18  58bf				   .LUM2      SET	.LUM2 + .STEP2
     19  58bf				   .LUM3      SET	.LUM3 + .STEP3
     13  58bf					      REPEND
     14  58c0		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58c1		       78		      .byte.b	$70+(.LUM2/256)
     16  58c2		       49		      .byte.b	$40+(.LUM3/256)
     17  58c2				   .LUM1      SET	.LUM1 + .STEP1
     18  58c2				   .LUM2      SET	.LUM2 + .STEP2
     19  58c2				   .LUM3      SET	.LUM3 + .STEP3
     13  58c2					      REPEND
     14  58c3		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58c4		       78		      .byte.b	$70+(.LUM2/256)
     16  58c5		       49		      .byte.b	$40+(.LUM3/256)
     17  58c5				   .LUM1      SET	.LUM1 + .STEP1
     18  58c5				   .LUM2      SET	.LUM2 + .STEP2
     19  58c5				   .LUM3      SET	.LUM3 + .STEP3
     13  58c5					      REPEND
     14  58c6		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58c7		       78		      .byte.b	$70+(.LUM2/256)
     16  58c8		       49		      .byte.b	$40+(.LUM3/256)
     17  58c8				   .LUM1      SET	.LUM1 + .STEP1
     18  58c8				   .LUM2      SET	.LUM2 + .STEP2
     19  58c8				   .LUM3      SET	.LUM3 + .STEP3
     13  58c8					      REPEND
     14  58c9		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58ca		       78		      .byte.b	$70+(.LUM2/256)
     16  58cb		       49		      .byte.b	$40+(.LUM3/256)
     17  58cb				   .LUM1      SET	.LUM1 + .STEP1
     18  58cb				   .LUM2      SET	.LUM2 + .STEP2
     19  58cb				   .LUM3      SET	.LUM3 + .STEP3
     13  58cb					      REPEND
     14  58cc		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58cd		       78		      .byte.b	$70+(.LUM2/256)
     16  58ce		       49		      .byte.b	$40+(.LUM3/256)
     17  58ce				   .LUM1      SET	.LUM1 + .STEP1
     18  58ce				   .LUM2      SET	.LUM2 + .STEP2
     19  58ce				   .LUM3      SET	.LUM3 + .STEP3
     13  58ce					      REPEND
     14  58cf		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58d0		       79		      .byte.b	$70+(.LUM2/256)
     16  58d1		       49		      .byte.b	$40+(.LUM3/256)
     17  58d1				   .LUM1      SET	.LUM1 + .STEP1
     18  58d1				   .LUM2      SET	.LUM2 + .STEP2
     19  58d1				   .LUM3      SET	.LUM3 + .STEP3
     13  58d1					      REPEND
     14  58d2		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58d3		       79		      .byte.b	$70+(.LUM2/256)
     16  58d4		       49		      .byte.b	$40+(.LUM3/256)
     17  58d4				   .LUM1      SET	.LUM1 + .STEP1
     18  58d4				   .LUM2      SET	.LUM2 + .STEP2
     19  58d4				   .LUM3      SET	.LUM3 + .STEP3
     13  58d4					      REPEND
     14  58d5		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58d6		       79		      .byte.b	$70+(.LUM2/256)
     16  58d7		       4a		      .byte.b	$40+(.LUM3/256)
     17  58d7				   .LUM1      SET	.LUM1 + .STEP1
     18  58d7				   .LUM2      SET	.LUM2 + .STEP2
     19  58d7				   .LUM3      SET	.LUM3 + .STEP3
     13  58d7					      REPEND
     14  58d8		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58d9		       79		      .byte.b	$70+(.LUM2/256)
     16  58da		       4a		      .byte.b	$40+(.LUM3/256)
     17  58da				   .LUM1      SET	.LUM1 + .STEP1
     18  58da				   .LUM2      SET	.LUM2 + .STEP2
     19  58da				   .LUM3      SET	.LUM3 + .STEP3
     13  58da					      REPEND
     14  58db		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58dc		       79		      .byte.b	$70+(.LUM2/256)
     16  58dd		       4a		      .byte.b	$40+(.LUM3/256)
     17  58dd				   .LUM1      SET	.LUM1 + .STEP1
     18  58dd				   .LUM2      SET	.LUM2 + .STEP2
     19  58dd				   .LUM3      SET	.LUM3 + .STEP3
     13  58dd					      REPEND
     14  58de		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58df		       79		      .byte.b	$70+(.LUM2/256)
     16  58e0		       4a		      .byte.b	$40+(.LUM3/256)
     17  58e0				   .LUM1      SET	.LUM1 + .STEP1
     18  58e0				   .LUM2      SET	.LUM2 + .STEP2
     19  58e0				   .LUM3      SET	.LUM3 + .STEP3
     13  58e0					      REPEND
     14  58e1		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58e2		       7a		      .byte.b	$70+(.LUM2/256)
     16  58e3		       4a		      .byte.b	$40+(.LUM3/256)
     17  58e3				   .LUM1      SET	.LUM1 + .STEP1
     18  58e3				   .LUM2      SET	.LUM2 + .STEP2
     19  58e3				   .LUM3      SET	.LUM3 + .STEP3
     13  58e3					      REPEND
     14  58e4		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58e5		       7a		      .byte.b	$70+(.LUM2/256)
     16  58e6		       4a		      .byte.b	$40+(.LUM3/256)
     17  58e6				   .LUM1      SET	.LUM1 + .STEP1
     18  58e6				   .LUM2      SET	.LUM2 + .STEP2
     19  58e6				   .LUM3      SET	.LUM3 + .STEP3
     13  58e6					      REPEND
     14  58e7		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58e8		       7a		      .byte.b	$70+(.LUM2/256)
     16  58e9		       4a		      .byte.b	$40+(.LUM3/256)
     17  58e9				   .LUM1      SET	.LUM1 + .STEP1
     18  58e9				   .LUM2      SET	.LUM2 + .STEP2
     19  58e9				   .LUM3      SET	.LUM3 + .STEP3
     13  58e9					      REPEND
     14  58ea		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58eb		       7a		      .byte.b	$70+(.LUM2/256)
     16  58ec		       4b		      .byte.b	$40+(.LUM3/256)
     17  58ec				   .LUM1      SET	.LUM1 + .STEP1
     18  58ec				   .LUM2      SET	.LUM2 + .STEP2
     19  58ec				   .LUM3      SET	.LUM3 + .STEP3
     13  58ec					      REPEND
     14  58ed		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58ee		       7a		      .byte.b	$70+(.LUM2/256)
     16  58ef		       4b		      .byte.b	$40+(.LUM3/256)
     17  58ef				   .LUM1      SET	.LUM1 + .STEP1
     18  58ef				   .LUM2      SET	.LUM2 + .STEP2
     19  58ef				   .LUM3      SET	.LUM3 + .STEP3
     13  58ef					      REPEND
     14  58f0		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58f1		       7a		      .byte.b	$70+(.LUM2/256)
     16  58f2		       4b		      .byte.b	$40+(.LUM3/256)
     17  58f2				   .LUM1      SET	.LUM1 + .STEP1
     18  58f2				   .LUM2      SET	.LUM2 + .STEP2
     19  58f2				   .LUM3      SET	.LUM3 + .STEP3
     13  58f2					      REPEND
     14  58f3		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58f4		       7b		      .byte.b	$70+(.LUM2/256)
     16  58f5		       4b		      .byte.b	$40+(.LUM3/256)
     17  58f5				   .LUM1      SET	.LUM1 + .STEP1
     18  58f5				   .LUM2      SET	.LUM2 + .STEP2
     19  58f5				   .LUM3      SET	.LUM3 + .STEP3
     13  58f5					      REPEND
     14  58f6		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58f7		       7b		      .byte.b	$70+(.LUM2/256)
     16  58f8		       4b		      .byte.b	$40+(.LUM3/256)
     17  58f8				   .LUM1      SET	.LUM1 + .STEP1
     18  58f8				   .LUM2      SET	.LUM2 + .STEP2
     19  58f8				   .LUM3      SET	.LUM3 + .STEP3
     13  58f8					      REPEND
     14  58f9		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58fa		       7b		      .byte.b	$70+(.LUM2/256)
     16  58fb		       4b		      .byte.b	$40+(.LUM3/256)
     17  58fb				   .LUM1      SET	.LUM1 + .STEP1
     18  58fb				   .LUM2      SET	.LUM2 + .STEP2
     19  58fb				   .LUM3      SET	.LUM3 + .STEP3
     13  58fb					      REPEND
     14  58fc		       ba		      .byte.b	$b0+(.LUM1/256)
     15  58fd		       7b		      .byte.b	$70+(.LUM2/256)
     16  58fe		       4c		      .byte.b	$40+(.LUM3/256)
     17  58fe				   .LUM1      SET	.LUM1 + .STEP1
     18  58fe				   .LUM2      SET	.LUM2 + .STEP2
     19  58fe				   .LUM3      SET	.LUM3 + .STEP3
     13  58fe					      REPEND
     14  58ff		       ba		      .byte.b	$b0+(.LUM1/256)
     15  5900		       7b		      .byte.b	$70+(.LUM2/256)
     16  5901		       4c		      .byte.b	$40+(.LUM3/256)
     17  5901				   .LUM1      SET	.LUM1 + .STEP1
     18  5901				   .LUM2      SET	.LUM2 + .STEP2
     19  5901				   .LUM3      SET	.LUM3 + .STEP3
     13  5901					      REPEND
     14  5902		       ba		      .byte.b	$b0+(.LUM1/256)
     15  5903		       7b		      .byte.b	$70+(.LUM2/256)
     16  5904		       4c		      .byte.b	$40+(.LUM3/256)
     17  5904				   .LUM1      SET	.LUM1 + .STEP1
     18  5904				   .LUM2      SET	.LUM2 + .STEP2
     19  5904				   .LUM3      SET	.LUM3 + .STEP3
     13  5904					      REPEND
     14  5905		       ba		      .byte.b	$b0+(.LUM1/256)
     15  5906		       7c		      .byte.b	$70+(.LUM2/256)
     16  5907		       4c		      .byte.b	$40+(.LUM3/256)
     17  5907				   .LUM1      SET	.LUM1 + .STEP1
     18  5907				   .LUM2      SET	.LUM2 + .STEP2
     19  5907				   .LUM3      SET	.LUM3 + .STEP3
     13  5907					      REPEND
     14  5908		       ba		      .byte.b	$b0+(.LUM1/256)
     15  5909		       7c		      .byte.b	$70+(.LUM2/256)
     16  590a		       4c		      .byte.b	$40+(.LUM3/256)
     17  590a				   .LUM1      SET	.LUM1 + .STEP1
     18  590a				   .LUM2      SET	.LUM2 + .STEP2
     19  590a				   .LUM3      SET	.LUM3 + .STEP3
     13  590a					      REPEND
     14  590b		       ba		      .byte.b	$b0+(.LUM1/256)
     15  590c		       7c		      .byte.b	$70+(.LUM2/256)
     16  590d		       4c		      .byte.b	$40+(.LUM3/256)
     17  590d				   .LUM1      SET	.LUM1 + .STEP1
     18  590d				   .LUM2      SET	.LUM2 + .STEP2
     19  590d				   .LUM3      SET	.LUM3 + .STEP3
     13  590d					      REPEND
     14  590e		       ba		      .byte.b	$b0+(.LUM1/256)
     15  590f		       7c		      .byte.b	$70+(.LUM2/256)
     16  5910		       4c		      .byte.b	$40+(.LUM3/256)
     17  5910				   .LUM1      SET	.LUM1 + .STEP1
     18  5910				   .LUM2      SET	.LUM2 + .STEP2
     19  5910				   .LUM3      SET	.LUM3 + .STEP3
     13  5910					      REPEND
     14  5911		       bb		      .byte.b	$b0+(.LUM1/256)
     15  5912		       7c		      .byte.b	$70+(.LUM2/256)
     16  5913		       4d		      .byte.b	$40+(.LUM3/256)
     17  5913				   .LUM1      SET	.LUM1 + .STEP1
     18  5913				   .LUM2      SET	.LUM2 + .STEP2
     19  5913				   .LUM3      SET	.LUM3 + .STEP3
     13  5913					      REPEND
     14  5914		       bb		      .byte.b	$b0+(.LUM1/256)
     15  5915		       7d		      .byte.b	$70+(.LUM2/256)
     16  5916		       4d		      .byte.b	$40+(.LUM3/256)
     17  5916				   .LUM1      SET	.LUM1 + .STEP1
     18  5916				   .LUM2      SET	.LUM2 + .STEP2
     19  5916				   .LUM3      SET	.LUM3 + .STEP3
     13  5916					      REPEND
     14  5917		       bb		      .byte.b	$b0+(.LUM1/256)
     15  5918		       7d		      .byte.b	$70+(.LUM2/256)
     16  5919		       4d		      .byte.b	$40+(.LUM3/256)
     17  5919				   .LUM1      SET	.LUM1 + .STEP1
     18  5919				   .LUM2      SET	.LUM2 + .STEP2
     19  5919				   .LUM3      SET	.LUM3 + .STEP3
     13  5919					      REPEND
     14  591a		       bb		      .byte.b	$b0+(.LUM1/256)
     15  591b		       7d		      .byte.b	$70+(.LUM2/256)
     16  591c		       4d		      .byte.b	$40+(.LUM3/256)
     17  591c				   .LUM1      SET	.LUM1 + .STEP1
     18  591c				   .LUM2      SET	.LUM2 + .STEP2
     19  591c				   .LUM3      SET	.LUM3 + .STEP3
     13  591c					      REPEND
     14  591d		       bb		      .byte.b	$b0+(.LUM1/256)
     15  591e		       7d		      .byte.b	$70+(.LUM2/256)
     16  591f		       4d		      .byte.b	$40+(.LUM3/256)
     17  591f				   .LUM1      SET	.LUM1 + .STEP1
     18  591f				   .LUM2      SET	.LUM2 + .STEP2
     19  591f				   .LUM3      SET	.LUM3 + .STEP3
     13  591f					      REPEND
     14  5920		       bb		      .byte.b	$b0+(.LUM1/256)
     15  5921		       7d		      .byte.b	$70+(.LUM2/256)
     16  5922		       4d		      .byte.b	$40+(.LUM3/256)
     17  5922				   .LUM1      SET	.LUM1 + .STEP1
     18  5922				   .LUM2      SET	.LUM2 + .STEP2
     19  5922				   .LUM3      SET	.LUM3 + .STEP3
     20  5923					      REPEND
      0  5923				   colr_ntsc  LUMTABLE	$90,$B0,$20,5,6,7,$C,$E,$E
      1  5923
      2  5923
      3  5923
      4  5923
      5  5923				   .LUM1      SET	5*256
      6  5923				   .LUM2      SET	6*256
      7  5923				   .LUM3      SET	7*256
      8  5923
      9  5923		       00 2c	   .STEP1     =	(256*($C-5))/40
     10  5923		       00 33	   .STEP2     =	(256*($E-6))/40
     11  5923		       00 2c	   .STEP3     =	(256*($E-7))/40
     12  5923
     13  5923					      REPEAT	40
     14  5923		       95		      .byte.b	$90+(.LUM1/256)
     15  5924		       b6		      .byte.b	$B0+(.LUM2/256)
     16  5925		       27		      .byte.b	$20+(.LUM3/256)
     17  5925				   .LUM1      SET	.LUM1 + .STEP1
     18  5925				   .LUM2      SET	.LUM2 + .STEP2
     19  5925				   .LUM3      SET	.LUM3 + .STEP3
     13  5925					      REPEND
     14  5926		       95		      .byte.b	$90+(.LUM1/256)
     15  5927		       b6		      .byte.b	$B0+(.LUM2/256)
     16  5928		       27		      .byte.b	$20+(.LUM3/256)
     17  5928				   .LUM1      SET	.LUM1 + .STEP1
     18  5928				   .LUM2      SET	.LUM2 + .STEP2
     19  5928				   .LUM3      SET	.LUM3 + .STEP3
     13  5928					      REPEND
     14  5929		       95		      .byte.b	$90+(.LUM1/256)
     15  592a		       b6		      .byte.b	$B0+(.LUM2/256)
     16  592b		       27		      .byte.b	$20+(.LUM3/256)
     17  592b				   .LUM1      SET	.LUM1 + .STEP1
     18  592b				   .LUM2      SET	.LUM2 + .STEP2
     19  592b				   .LUM3      SET	.LUM3 + .STEP3
     13  592b					      REPEND
     14  592c		       95		      .byte.b	$90+(.LUM1/256)
     15  592d		       b6		      .byte.b	$B0+(.LUM2/256)
     16  592e		       27		      .byte.b	$20+(.LUM3/256)
     17  592e				   .LUM1      SET	.LUM1 + .STEP1
     18  592e				   .LUM2      SET	.LUM2 + .STEP2
     19  592e				   .LUM3      SET	.LUM3 + .STEP3
     13  592e					      REPEND
     14  592f		       95		      .byte.b	$90+(.LUM1/256)
     15  5930		       b6		      .byte.b	$B0+(.LUM2/256)
     16  5931		       27		      .byte.b	$20+(.LUM3/256)
     17  5931				   .LUM1      SET	.LUM1 + .STEP1
     18  5931				   .LUM2      SET	.LUM2 + .STEP2
     19  5931				   .LUM3      SET	.LUM3 + .STEP3
     13  5931					      REPEND
     14  5932		       95		      .byte.b	$90+(.LUM1/256)
     15  5933		       b6		      .byte.b	$B0+(.LUM2/256)
     16  5934		       27		      .byte.b	$20+(.LUM3/256)
     17  5934				   .LUM1      SET	.LUM1 + .STEP1
     18  5934				   .LUM2      SET	.LUM2 + .STEP2
     19  5934				   .LUM3      SET	.LUM3 + .STEP3
     13  5934					      REPEND
     14  5935		       96		      .byte.b	$90+(.LUM1/256)
     15  5936		       b7		      .byte.b	$B0+(.LUM2/256)
     16  5937		       28		      .byte.b	$20+(.LUM3/256)
     17  5937				   .LUM1      SET	.LUM1 + .STEP1
     18  5937				   .LUM2      SET	.LUM2 + .STEP2
     19  5937				   .LUM3      SET	.LUM3 + .STEP3
     13  5937					      REPEND
     14  5938		       96		      .byte.b	$90+(.LUM1/256)
     15  5939		       b7		      .byte.b	$B0+(.LUM2/256)
     16  593a		       28		      .byte.b	$20+(.LUM3/256)
     17  593a				   .LUM1      SET	.LUM1 + .STEP1
     18  593a				   .LUM2      SET	.LUM2 + .STEP2
     19  593a				   .LUM3      SET	.LUM3 + .STEP3
     13  593a					      REPEND
     14  593b		       96		      .byte.b	$90+(.LUM1/256)
     15  593c		       b7		      .byte.b	$B0+(.LUM2/256)
     16  593d		       28		      .byte.b	$20+(.LUM3/256)
     17  593d				   .LUM1      SET	.LUM1 + .STEP1
     18  593d				   .LUM2      SET	.LUM2 + .STEP2
     19  593d				   .LUM3      SET	.LUM3 + .STEP3
     13  593d					      REPEND
     14  593e		       96		      .byte.b	$90+(.LUM1/256)
     15  593f		       b7		      .byte.b	$B0+(.LUM2/256)
     16  5940		       28		      .byte.b	$20+(.LUM3/256)
     17  5940				   .LUM1      SET	.LUM1 + .STEP1
     18  5940				   .LUM2      SET	.LUM2 + .STEP2
     19  5940				   .LUM3      SET	.LUM3 + .STEP3
     13  5940					      REPEND
     14  5941		       96		      .byte.b	$90+(.LUM1/256)
     15  5942		       b7		      .byte.b	$B0+(.LUM2/256)
     16  5943		       28		      .byte.b	$20+(.LUM3/256)
     17  5943				   .LUM1      SET	.LUM1 + .STEP1
     18  5943				   .LUM2      SET	.LUM2 + .STEP2
     19  5943				   .LUM3      SET	.LUM3 + .STEP3
     13  5943					      REPEND
     14  5944		       96		      .byte.b	$90+(.LUM1/256)
     15  5945		       b8		      .byte.b	$B0+(.LUM2/256)
     16  5946		       28		      .byte.b	$20+(.LUM3/256)
     17  5946				   .LUM1      SET	.LUM1 + .STEP1
     18  5946				   .LUM2      SET	.LUM2 + .STEP2
     19  5946				   .LUM3      SET	.LUM3 + .STEP3
     13  5946					      REPEND
     14  5947		       97		      .byte.b	$90+(.LUM1/256)
     15  5948		       b8		      .byte.b	$B0+(.LUM2/256)
     16  5949		       29		      .byte.b	$20+(.LUM3/256)
     17  5949				   .LUM1      SET	.LUM1 + .STEP1
     18  5949				   .LUM2      SET	.LUM2 + .STEP2
     19  5949				   .LUM3      SET	.LUM3 + .STEP3
     13  5949					      REPEND
     14  594a		       97		      .byte.b	$90+(.LUM1/256)
     15  594b		       b8		      .byte.b	$B0+(.LUM2/256)
     16  594c		       29		      .byte.b	$20+(.LUM3/256)
     17  594c				   .LUM1      SET	.LUM1 + .STEP1
     18  594c				   .LUM2      SET	.LUM2 + .STEP2
     19  594c				   .LUM3      SET	.LUM3 + .STEP3
     13  594c					      REPEND
     14  594d		       97		      .byte.b	$90+(.LUM1/256)
     15  594e		       b8		      .byte.b	$B0+(.LUM2/256)
     16  594f		       29		      .byte.b	$20+(.LUM3/256)
     17  594f				   .LUM1      SET	.LUM1 + .STEP1
     18  594f				   .LUM2      SET	.LUM2 + .STEP2
     19  594f				   .LUM3      SET	.LUM3 + .STEP3
     13  594f					      REPEND
     14  5950		       97		      .byte.b	$90+(.LUM1/256)
     15  5951		       b8		      .byte.b	$B0+(.LUM2/256)
     16  5952		       29		      .byte.b	$20+(.LUM3/256)
     17  5952				   .LUM1      SET	.LUM1 + .STEP1
     18  5952				   .LUM2      SET	.LUM2 + .STEP2
     19  5952				   .LUM3      SET	.LUM3 + .STEP3
     13  5952					      REPEND
     14  5953		       97		      .byte.b	$90+(.LUM1/256)
     15  5954		       b9		      .byte.b	$B0+(.LUM2/256)
     16  5955		       29		      .byte.b	$20+(.LUM3/256)
     17  5955				   .LUM1      SET	.LUM1 + .STEP1
     18  5955				   .LUM2      SET	.LUM2 + .STEP2
     19  5955				   .LUM3      SET	.LUM3 + .STEP3
     13  5955					      REPEND
     14  5956		       97		      .byte.b	$90+(.LUM1/256)
     15  5957		       b9		      .byte.b	$B0+(.LUM2/256)
     16  5958		       29		      .byte.b	$20+(.LUM3/256)
     17  5958				   .LUM1      SET	.LUM1 + .STEP1
     18  5958				   .LUM2      SET	.LUM2 + .STEP2
     19  5958				   .LUM3      SET	.LUM3 + .STEP3
     13  5958					      REPEND
     14  5959		       98		      .byte.b	$90+(.LUM1/256)
     15  595a		       b9		      .byte.b	$B0+(.LUM2/256)
     16  595b		       2a		      .byte.b	$20+(.LUM3/256)
     17  595b				   .LUM1      SET	.LUM1 + .STEP1
     18  595b				   .LUM2      SET	.LUM2 + .STEP2
     19  595b				   .LUM3      SET	.LUM3 + .STEP3
     13  595b					      REPEND
     14  595c		       98		      .byte.b	$90+(.LUM1/256)
     15  595d		       b9		      .byte.b	$B0+(.LUM2/256)
     16  595e		       2a		      .byte.b	$20+(.LUM3/256)
     17  595e				   .LUM1      SET	.LUM1 + .STEP1
     18  595e				   .LUM2      SET	.LUM2 + .STEP2
     19  595e				   .LUM3      SET	.LUM3 + .STEP3
     13  595e					      REPEND
     14  595f		       98		      .byte.b	$90+(.LUM1/256)
     15  5960		       b9		      .byte.b	$B0+(.LUM2/256)
     16  5961		       2a		      .byte.b	$20+(.LUM3/256)
     17  5961				   .LUM1      SET	.LUM1 + .STEP1
     18  5961				   .LUM2      SET	.LUM2 + .STEP2
     19  5961				   .LUM3      SET	.LUM3 + .STEP3
     13  5961					      REPEND
     14  5962		       98		      .byte.b	$90+(.LUM1/256)
     15  5963		       ba		      .byte.b	$B0+(.LUM2/256)
     16  5964		       2a		      .byte.b	$20+(.LUM3/256)
     17  5964				   .LUM1      SET	.LUM1 + .STEP1
     18  5964				   .LUM2      SET	.LUM2 + .STEP2
     19  5964				   .LUM3      SET	.LUM3 + .STEP3
     13  5964					      REPEND
     14  5965		       98		      .byte.b	$90+(.LUM1/256)
     15  5966		       ba		      .byte.b	$B0+(.LUM2/256)
     16  5967		       2a		      .byte.b	$20+(.LUM3/256)
     17  5967				   .LUM1      SET	.LUM1 + .STEP1
     18  5967				   .LUM2      SET	.LUM2 + .STEP2
     19  5967				   .LUM3      SET	.LUM3 + .STEP3
     13  5967					      REPEND
     14  5968		       98		      .byte.b	$90+(.LUM1/256)
     15  5969		       ba		      .byte.b	$B0+(.LUM2/256)
     16  596a		       2a		      .byte.b	$20+(.LUM3/256)
     17  596a				   .LUM1      SET	.LUM1 + .STEP1
     18  596a				   .LUM2      SET	.LUM2 + .STEP2
     19  596a				   .LUM3      SET	.LUM3 + .STEP3
     13  596a					      REPEND
     14  596b		       99		      .byte.b	$90+(.LUM1/256)
     15  596c		       ba		      .byte.b	$B0+(.LUM2/256)
     16  596d		       2b		      .byte.b	$20+(.LUM3/256)
     17  596d				   .LUM1      SET	.LUM1 + .STEP1
     18  596d				   .LUM2      SET	.LUM2 + .STEP2
     19  596d				   .LUM3      SET	.LUM3 + .STEP3
     13  596d					      REPEND
     14  596e		       99		      .byte.b	$90+(.LUM1/256)
     15  596f		       ba		      .byte.b	$B0+(.LUM2/256)
     16  5970		       2b		      .byte.b	$20+(.LUM3/256)
     17  5970				   .LUM1      SET	.LUM1 + .STEP1
     18  5970				   .LUM2      SET	.LUM2 + .STEP2
     19  5970				   .LUM3      SET	.LUM3 + .STEP3
     13  5970					      REPEND
     14  5971		       99		      .byte.b	$90+(.LUM1/256)
     15  5972		       bb		      .byte.b	$B0+(.LUM2/256)
     16  5973		       2b		      .byte.b	$20+(.LUM3/256)
     17  5973				   .LUM1      SET	.LUM1 + .STEP1
     18  5973				   .LUM2      SET	.LUM2 + .STEP2
     19  5973				   .LUM3      SET	.LUM3 + .STEP3
     13  5973					      REPEND
     14  5974		       99		      .byte.b	$90+(.LUM1/256)
     15  5975		       bb		      .byte.b	$B0+(.LUM2/256)
     16  5976		       2b		      .byte.b	$20+(.LUM3/256)
     17  5976				   .LUM1      SET	.LUM1 + .STEP1
     18  5976				   .LUM2      SET	.LUM2 + .STEP2
     19  5976				   .LUM3      SET	.LUM3 + .STEP3
     13  5976					      REPEND
     14  5977		       99		      .byte.b	$90+(.LUM1/256)
     15  5978		       bb		      .byte.b	$B0+(.LUM2/256)
     16  5979		       2b		      .byte.b	$20+(.LUM3/256)
     17  5979				   .LUM1      SET	.LUM1 + .STEP1
     18  5979				   .LUM2      SET	.LUM2 + .STEP2
     19  5979				   .LUM3      SET	.LUM3 + .STEP3
     13  5979					      REPEND
     14  597a		       99		      .byte.b	$90+(.LUM1/256)
     15  597b		       bb		      .byte.b	$B0+(.LUM2/256)
     16  597c		       2b		      .byte.b	$20+(.LUM3/256)
     17  597c				   .LUM1      SET	.LUM1 + .STEP1
     18  597c				   .LUM2      SET	.LUM2 + .STEP2
     19  597c				   .LUM3      SET	.LUM3 + .STEP3
     13  597c					      REPEND
     14  597d		       9a		      .byte.b	$90+(.LUM1/256)
     15  597e		       bb		      .byte.b	$B0+(.LUM2/256)
     16  597f		       2c		      .byte.b	$20+(.LUM3/256)
     17  597f				   .LUM1      SET	.LUM1 + .STEP1
     18  597f				   .LUM2      SET	.LUM2 + .STEP2
     19  597f				   .LUM3      SET	.LUM3 + .STEP3
     13  597f					      REPEND
     14  5980		       9a		      .byte.b	$90+(.LUM1/256)
     15  5981		       bc		      .byte.b	$B0+(.LUM2/256)
     16  5982		       2c		      .byte.b	$20+(.LUM3/256)
     17  5982				   .LUM1      SET	.LUM1 + .STEP1
     18  5982				   .LUM2      SET	.LUM2 + .STEP2
     19  5982				   .LUM3      SET	.LUM3 + .STEP3
     13  5982					      REPEND
     14  5983		       9a		      .byte.b	$90+(.LUM1/256)
     15  5984		       bc		      .byte.b	$B0+(.LUM2/256)
     16  5985		       2c		      .byte.b	$20+(.LUM3/256)
     17  5985				   .LUM1      SET	.LUM1 + .STEP1
     18  5985				   .LUM2      SET	.LUM2 + .STEP2
     19  5985				   .LUM3      SET	.LUM3 + .STEP3
     13  5985					      REPEND
     14  5986		       9a		      .byte.b	$90+(.LUM1/256)
     15  5987		       bc		      .byte.b	$B0+(.LUM2/256)
     16  5988		       2c		      .byte.b	$20+(.LUM3/256)
     17  5988				   .LUM1      SET	.LUM1 + .STEP1
     18  5988				   .LUM2      SET	.LUM2 + .STEP2
     19  5988				   .LUM3      SET	.LUM3 + .STEP3
     13  5988					      REPEND
     14  5989		       9a		      .byte.b	$90+(.LUM1/256)
     15  598a		       bc		      .byte.b	$B0+(.LUM2/256)
     16  598b		       2c		      .byte.b	$20+(.LUM3/256)
     17  598b				   .LUM1      SET	.LUM1 + .STEP1
     18  598b				   .LUM2      SET	.LUM2 + .STEP2
     19  598b				   .LUM3      SET	.LUM3 + .STEP3
     13  598b					      REPEND
     14  598c		       9b		      .byte.b	$90+(.LUM1/256)
     15  598d		       bc		      .byte.b	$B0+(.LUM2/256)
     16  598e		       2d		      .byte.b	$20+(.LUM3/256)
     17  598e				   .LUM1      SET	.LUM1 + .STEP1
     18  598e				   .LUM2      SET	.LUM2 + .STEP2
     19  598e				   .LUM3      SET	.LUM3 + .STEP3
     13  598e					      REPEND
     14  598f		       9b		      .byte.b	$90+(.LUM1/256)
     15  5990		       bd		      .byte.b	$B0+(.LUM2/256)
     16  5991		       2d		      .byte.b	$20+(.LUM3/256)
     17  5991				   .LUM1      SET	.LUM1 + .STEP1
     18  5991				   .LUM2      SET	.LUM2 + .STEP2
     19  5991				   .LUM3      SET	.LUM3 + .STEP3
     13  5991					      REPEND
     14  5992		       9b		      .byte.b	$90+(.LUM1/256)
     15  5993		       bd		      .byte.b	$B0+(.LUM2/256)
     16  5994		       2d		      .byte.b	$20+(.LUM3/256)
     17  5994				   .LUM1      SET	.LUM1 + .STEP1
     18  5994				   .LUM2      SET	.LUM2 + .STEP2
     19  5994				   .LUM3      SET	.LUM3 + .STEP3
     13  5994					      REPEND
     14  5995		       9b		      .byte.b	$90+(.LUM1/256)
     15  5996		       bd		      .byte.b	$B0+(.LUM2/256)
     16  5997		       2d		      .byte.b	$20+(.LUM3/256)
     17  5997				   .LUM1      SET	.LUM1 + .STEP1
     18  5997				   .LUM2      SET	.LUM2 + .STEP2
     19  5997				   .LUM3      SET	.LUM3 + .STEP3
     13  5997					      REPEND
     14  5998		       9b		      .byte.b	$90+(.LUM1/256)
     15  5999		       bd		      .byte.b	$B0+(.LUM2/256)
     16  599a		       2d		      .byte.b	$20+(.LUM3/256)
     17  599a				   .LUM1      SET	.LUM1 + .STEP1
     18  599a				   .LUM2      SET	.LUM2 + .STEP2
     19  599a				   .LUM3      SET	.LUM3 + .STEP3
     20  599b					      REPEND
    162  599b
------- FILE titleData.asm LEVEL 3 PASS 3
      0  599b					      include	"titleData.asm"
      1  599b				   COL_0
      2  599b		       c0		      .byte.b	192	;R (39)
      3  599c		       c0		      .byte.b	192	;G
      4  599d		       c0		      .byte.b	192	;B
      5  599e		       e0		      .byte.b	224	;R (38)
      6  599f		       e0		      .byte.b	224	;G
      7  59a0		       e0		      .byte.b	224	;B
      8  59a1		       20		      .byte.b	32	;R (37)
      9  59a2		       e0		      .byte.b	224	;G
     10  59a3		       e0		      .byte.b	224	;B
     11  59a4		       30		      .byte.b	48	;R (36)
     12  59a5		       30		      .byte.b	48	;G
     13  59a6		       30		      .byte.b	48	;B
     14  59a7		       f0		      .byte.b	240	;R (35)
     15  59a8		       10		      .byte.b	16	;G
     16  59a9		       d0		      .byte.b	208	;B
     17  59aa		       f0		      .byte.b	240	;R (34)
     18  59ab		       10		      .byte.b	16	;G
     19  59ac		       d0		      .byte.b	208	;B
     20  59ad		       f0		      .byte.b	240	;R (33)
     21  59ae		       10		      .byte.b	16	;G
     22  59af		       d0		      .byte.b	208	;B
     23  59b0		       f0		      .byte.b	240	;R (32)
     24  59b1		       10		      .byte.b	16	;G
     25  59b2		       d0		      .byte.b	208	;B
     26  59b3		       f0		      .byte.b	240	;R (31)
     27  59b4		       10		      .byte.b	16	;G
     28  59b5		       d0		      .byte.b	208	;B
     29  59b6		       f0		      .byte.b	240	;R (30)
     30  59b7		       10		      .byte.b	16	;G
     31  59b8		       10		      .byte.b	16	;B
     32  59b9		       f0		      .byte.b	240	;R (29)
     33  59ba		       10		      .byte.b	16	;G
     34  59bb		       10		      .byte.b	16	;B
     35  59bc		       f0		      .byte.b	240	;R (28)
     36  59bd		       10		      .byte.b	16	;G
     37  59be		       10		      .byte.b	16	;B
     38  59bf		       f0		      .byte.b	240	;R (27)
     39  59c0		       10		      .byte.b	16	;G
     40  59c1		       10		      .byte.b	16	;B
     41  59c2		       f0		      .byte.b	240	;R (26)
     42  59c3		       10		      .byte.b	16	;G
     43  59c4		       10		      .byte.b	16	;B
     44  59c5		       f0		      .byte.b	240	;R (25)
     45  59c6		       10		      .byte.b	16	;G
     46  59c7		       10		      .byte.b	16	;B
     47  59c8		       f0		      .byte.b	240	;R (24)
     48  59c9		       10		      .byte.b	16	;G
     49  59ca		       10		      .byte.b	16	;B
     50  59cb		       f0		      .byte.b	240	;R (23)
     51  59cc		       10		      .byte.b	16	;G
     52  59cd		       10		      .byte.b	16	;B
     53  59ce		       90		      .byte.b	144	;R (22)
     54  59cf		       70		      .byte.b	112	;G
     55  59d0		       10		      .byte.b	16	;B
     56  59d1		       10		      .byte.b	16	;R (21)
     57  59d2		       f0		      .byte.b	240	;G
     58  59d3		       10		      .byte.b	16	;B
     59  59d4		       90		      .byte.b	144	;R (20)
     60  59d5		       70		      .byte.b	112	;G
     61  59d6		       90		      .byte.b	144	;B
     62  59d7		       90		      .byte.b	144	;R (19)
     63  59d8		       70		      .byte.b	112	;G
     64  59d9		       90		      .byte.b	144	;B
     65  59da		       d0		      .byte.b	208	;R (18)
     66  59db		       30		      .byte.b	48	;G
     67  59dc		       d0		      .byte.b	208	;B
     68  59dd		       d0		      .byte.b	208	;R (17)
     69  59de		       30		      .byte.b	48	;G
     70  59df		       d0		      .byte.b	208	;B
     71  59e0		       50		      .byte.b	80	;R (16)
     72  59e1		       30		      .byte.b	48	;G
     73  59e2		       50		      .byte.b	80	;B
     74  59e3		       50		      .byte.b	80	;R (15)
     75  59e4		       30		      .byte.b	48	;G
     76  59e5		       50		      .byte.b	80	;B
     77  59e6		       50		      .byte.b	80	;R (14)
     78  59e7		       30		      .byte.b	48	;G
     79  59e8		       50		      .byte.b	80	;B
     80  59e9		       50		      .byte.b	80	;R (13)
     81  59ea		       30		      .byte.b	48	;G
     82  59eb		       50		      .byte.b	80	;B
     83  59ec		       d0		      .byte.b	208	;R (12)
     84  59ed		       30		      .byte.b	48	;G
     85  59ee		       d0		      .byte.b	208	;B
     86  59ef		       d0		      .byte.b	208	;R (11)
     87  59f0		       30		      .byte.b	48	;G
     88  59f1		       d0		      .byte.b	208	;B
     89  59f2		       d0		      .byte.b	208	;R (10)
     90  59f3		       30		      .byte.b	48	;G
     91  59f4		       d0		      .byte.b	208	;B
     92  59f5		       d0		      .byte.b	208	;R (9)
     93  59f6		       30		      .byte.b	48	;G
     94  59f7		       d0		      .byte.b	208	;B
     95  59f8		       90		      .byte.b	144	;R (8)
     96  59f9		       70		      .byte.b	112	;G
     97  59fa		       90		      .byte.b	144	;B
     98  59fb		       90		      .byte.b	144	;R (7)
     99  59fc		       70		      .byte.b	112	;G
    100  59fd		       90		      .byte.b	144	;B
    101  59fe		       10		      .byte.b	16	;R (6)
    102  59ff		       f0		      .byte.b	240	;G
    103  5a00		       10		      .byte.b	16	;B
    104  5a01		       10		      .byte.b	16	;R (5)
    105  5a02		       f0		      .byte.b	240	;G
    106  5a03		       10		      .byte.b	16	;B
    107  5a04		       10		      .byte.b	16	;R (4)
    108  5a05		       f0		      .byte.b	240	;G
    109  5a06		       10		      .byte.b	16	;B
    110  5a07		       20		      .byte.b	32	;R (3)
    111  5a08		       e0		      .byte.b	224	;G
    112  5a09		       20		      .byte.b	32	;B
    113  5a0a		       20		      .byte.b	32	;R (2)
    114  5a0b		       e0		      .byte.b	224	;G
    115  5a0c		       20		      .byte.b	32	;B
    116  5a0d		       e0		      .byte.b	224	;R (1)
    117  5a0e		       e0		      .byte.b	224	;G
    118  5a0f		       e0		      .byte.b	224	;B
    119  5a10		       c0		      .byte.b	192	;R (0)
    120  5a11		       c0		      .byte.b	192	;G
    121  5a12		       c0		      .byte.b	192	;B
    122  5a13				   COL_1
    123  5a13		       ff		      .byte.b	255	;R (39)
    124  5a14		       ff		      .byte.b	255	;G
    125  5a15		       ff		      .byte.b	255	;B
    126  5a16		       ff		      .byte.b	255	;R (38)
    127  5a17		       ff		      .byte.b	255	;G
    128  5a18		       ff		      .byte.b	255	;B
    129  5a19		       00		      .byte.b	0	;R (37)
    130  5a1a		       ff		      .byte.b	255	;G
    131  5a1b		       ff		      .byte.b	255	;B
    132  5a1c		       00		      .byte.b	0	;R (36)
    133  5a1d		       f3		      .byte.b	243	;G
    134  5a1e		       f3		      .byte.b	243	;B
    135  5a1f		       0c		      .byte.b	12	;R (35)
    136  5a20		       7d		      .byte.b	125	;G
    137  5a21		       71		      .byte.b	113	;B
    138  5a22		       0c		      .byte.b	12	;R (34)
    139  5a23		       7d		      .byte.b	125	;G
    140  5a24		       71		      .byte.b	113	;B
    141  5a25		       9c		      .byte.b	156	;R (33)
    142  5a26		       3d		      .byte.b	61	;G
    143  5a27		       a1		      .byte.b	161	;B
    144  5a28		       9c		      .byte.b	156	;R (32)
    145  5a29		       3d		      .byte.b	61	;G
    146  5a2a		       a1		      .byte.b	161	;B
    147  5a2b		       9e		      .byte.b	158	;R (31)
    148  5a2c		       3e		      .byte.b	62	;G
    149  5a2d		       a0		      .byte.b	160	;B
    150  5a2e		       de		      .byte.b	222	;R (30)
    151  5a2f		       1e		      .byte.b	30	;G
    152  5a30		       c0		      .byte.b	192	;B
    153  5a31		       d2		      .byte.b	210	;R (29)
    154  5a32		       12		      .byte.b	18	;G
    155  5a33		       c0		      .byte.b	192	;B
    156  5a34		       d6		      .byte.b	214	;R (28)
    157  5a35		       12		      .byte.b	18	;G
    158  5a36		       c0		      .byte.b	192	;B
    159  5a37		       d6		      .byte.b	214	;R (27)
    160  5a38		       12		      .byte.b	18	;G
    161  5a39		       c0		      .byte.b	192	;B
    162  5a3a		       d6		      .byte.b	214	;R (26)
    163  5a3b		       12		      .byte.b	18	;G
    164  5a3c		       c0		      .byte.b	192	;B
    165  5a3d		       d6		      .byte.b	214	;R (25)
    166  5a3e		       12		      .byte.b	18	;G
    167  5a3f		       c0		      .byte.b	192	;B
    168  5a40		       d6		      .byte.b	214	;R (24)
    169  5a41		       12		      .byte.b	18	;G
    170  5a42		       c0		      .byte.b	192	;B
    171  5a43		       d6		      .byte.b	214	;R (23)
    172  5a44		       12		      .byte.b	18	;G
    173  5a45		       c0		      .byte.b	192	;B
    174  5a46		       d6		      .byte.b	214	;R (22)
    175  5a47		       12		      .byte.b	18	;G
    176  5a48		       c0		      .byte.b	192	;B
    177  5a49		       d6		      .byte.b	214	;R (21)
    178  5a4a		       12		      .byte.b	18	;G
    179  5a4b		       c0		      .byte.b	192	;B
    180  5a4c		       d6		      .byte.b	214	;R (20)
    181  5a4d		       12		      .byte.b	18	;G
    182  5a4e		       c0		      .byte.b	192	;B
    183  5a4f		       d6		      .byte.b	214	;R (19)
    184  5a50		       12		      .byte.b	18	;G
    185  5a51		       c0		      .byte.b	192	;B
    186  5a52		       96		      .byte.b	150	;R (18)
    187  5a53		       32		      .byte.b	50	;G
    188  5a54		       80		      .byte.b	128	;B
    189  5a55		       12		      .byte.b	18	;R (17)
    190  5a56		       76		      .byte.b	118	;G
    191  5a57		       00		      .byte.b	0	;B
    192  5a58		       12		      .byte.b	18	;R (16)
    193  5a59		       f6		      .byte.b	246	;G
    194  5a5a		       00		      .byte.b	0	;B
    195  5a5b		       12		      .byte.b	18	;R (15)
    196  5a5c		       f6		      .byte.b	246	;G
    197  5a5d		       00		      .byte.b	0	;B
    198  5a5e		       12		      .byte.b	18	;R (14)
    199  5a5f		       f6		      .byte.b	246	;G
    200  5a60		       00		      .byte.b	0	;B
    201  5a61		       12		      .byte.b	18	;R (13)
    202  5a62		       f6		      .byte.b	246	;G
    203  5a63		       00		      .byte.b	0	;B
    204  5a64		       12		      .byte.b	18	;R (12)
    205  5a65		       76		      .byte.b	118	;G
    206  5a66		       00		      .byte.b	0	;B
    207  5a67		       12		      .byte.b	18	;R (11)
    208  5a68		       76		      .byte.b	118	;G
    209  5a69		       00		      .byte.b	0	;B
    210  5a6a		       12		      .byte.b	18	;R (10)
    211  5a6b		       76		      .byte.b	118	;G
    212  5a6c		       00		      .byte.b	0	;B
    213  5a6d		       9a		      .byte.b	154	;R (9)
    214  5a6e		       3a		      .byte.b	58	;G
    215  5a6f		       80		      .byte.b	128	;B
    216  5a70		       da		      .byte.b	218	;R (8)
    217  5a71		       1a		      .byte.b	26	;G
    218  5a72		       c0		      .byte.b	192	;B
    219  5a73		       fe		      .byte.b	254	;R (7)
    220  5a74		       1e		      .byte.b	30	;G
    221  5a75		       e0		      .byte.b	224	;B
    222  5a76		       ee		      .byte.b	238	;R (6)
    223  5a77		       0e		      .byte.b	14	;G
    224  5a78		       e0		      .byte.b	224	;B
    225  5a79		       6e		      .byte.b	110	;R (5)
    226  5a7a		       8e		      .byte.b	142	;G
    227  5a7b		       60		      .byte.b	96	;B
    228  5a7c		       24		      .byte.b	36	;R (4)
    229  5a7d		       cd		      .byte.b	205	;G
    230  5a7e		       20		      .byte.b	32	;B
    231  5a7f		       00		      .byte.b	0	;R (3)
    232  5a80		       ff		      .byte.b	255	;G
    233  5a81		       00		      .byte.b	0	;B
    234  5a82		       00		      .byte.b	0	;R (2)
    235  5a83		       ff		      .byte.b	255	;G
    236  5a84		       00		      .byte.b	0	;B
    237  5a85		       ff		      .byte.b	255	;R (1)
    238  5a86		       ff		      .byte.b	255	;G
    239  5a87		       ff		      .byte.b	255	;B
    240  5a88		       ff		      .byte.b	255	;R (0)
    241  5a89		       ff		      .byte.b	255	;G
    242  5a8a		       ff		      .byte.b	255	;B
    243  5a8b				   COL_2
    244  5a8b		       ff		      .byte.b	255	;R (39)
    245  5a8c		       ff		      .byte.b	255	;G
    246  5a8d		       ff		      .byte.b	255	;B
    247  5a8e		       ff		      .byte.b	255	;R (38)
    248  5a8f		       ff		      .byte.b	255	;G
    249  5a90		       ff		      .byte.b	255	;B
    250  5a91		       00		      .byte.b	0	;R (37)
    251  5a92		       ff		      .byte.b	255	;G
    252  5a93		       ff		      .byte.b	255	;B
    253  5a94		       00		      .byte.b	0	;R (36)
    254  5a95		       26		      .byte.b	38	;G
    255  5a96		       26		      .byte.b	38	;B
    256  5a97		       c0		      .byte.b	192	;R (35)
    257  5a98		       04		      .byte.b	4	;G
    258  5a99		       dd		      .byte.b	221	;B
    259  5a9a		       c0		      .byte.b	192	;R (34)
    260  5a9b		       04		      .byte.b	4	;G
    261  5a9c		       dd		      .byte.b	221	;B
    262  5a9d		       e0		      .byte.b	224	;R (33)
    263  5a9e		       04		      .byte.b	4	;G
    264  5a9f		       ed		      .byte.b	237	;B
    265  5aa0		       e0		      .byte.b	224	;R (32)
    266  5aa1		       04		      .byte.b	4	;G
    267  5aa2		       ed		      .byte.b	237	;B
    268  5aa3		       e0		      .byte.b	224	;R (31)
    269  5aa4		       04		      .byte.b	4	;G
    270  5aa5		       ed		      .byte.b	237	;B
    271  5aa6		       e0		      .byte.b	224	;R (30)
    272  5aa7		       00		      .byte.b	0	;G
    273  5aa8		       ed		      .byte.b	237	;B
    274  5aa9		       20		      .byte.b	32	;R (29)
    275  5aaa		       80		      .byte.b	128	;G
    276  5aab		       af		      .byte.b	175	;B
    277  5aac		       20		      .byte.b	32	;R (28)
    278  5aad		       80		      .byte.b	128	;G
    279  5aae		       af		      .byte.b	175	;B
    280  5aaf		       20		      .byte.b	32	;R (27)
    281  5ab0		       80		      .byte.b	128	;G
    282  5ab1		       af		      .byte.b	175	;B
    283  5ab2		       20		      .byte.b	32	;R (26)
    284  5ab3		       90		      .byte.b	144	;G
    285  5ab4		       b7		      .byte.b	183	;B
    286  5ab5		       20		      .byte.b	32	;R (25)
    287  5ab6		       90		      .byte.b	144	;G
    288  5ab7		       b7		      .byte.b	183	;B
    289  5ab8		       20		      .byte.b	32	;R (24)
    290  5ab9		       90		      .byte.b	144	;G
    291  5aba		       b7		      .byte.b	183	;B
    292  5abb		       38		      .byte.b	56	;R (23)
    293  5abc		       80		      .byte.b	128	;G
    294  5abd		       a3		      .byte.b	163	;B
    295  5abe		       38		      .byte.b	56	;R (22)
    296  5abf		       80		      .byte.b	128	;G
    297  5ac0		       a3		      .byte.b	163	;B
    298  5ac1		       b0		      .byte.b	176	;R (21)
    299  5ac2		       00		      .byte.b	0	;G
    300  5ac3		       27		      .byte.b	39	;B
    301  5ac4		       b0		      .byte.b	176	;R (20)
    302  5ac5		       00		      .byte.b	0	;G
    303  5ac6		       27		      .byte.b	39	;B
    304  5ac7		       b0		      .byte.b	176	;R (19)
    305  5ac8		       00		      .byte.b	0	;G
    306  5ac9		       27		      .byte.b	39	;B
    307  5aca		       b0		      .byte.b	176	;R (18)
    308  5acb		       00		      .byte.b	0	;G
    309  5acc		       27		      .byte.b	39	;B
    310  5acd		       a0		      .byte.b	160	;R (17)
    311  5ace		       00		      .byte.b	0	;G
    312  5acf		       2f		      .byte.b	47	;B
    313  5ad0		       a0		      .byte.b	160	;R (16)
    314  5ad1		       00		      .byte.b	0	;G
    315  5ad2		       2f		      .byte.b	47	;B
    316  5ad3		       a0		      .byte.b	160	;R (15)
    317  5ad4		       00		      .byte.b	0	;G
    318  5ad5		       2d		      .byte.b	45	;B
    319  5ad6		       a0		      .byte.b	160	;R (14)
    320  5ad7		       00		      .byte.b	0	;G
    321  5ad8		       2d		      .byte.b	45	;B
    322  5ad9		       a0		      .byte.b	160	;R (13)
    323  5ada		       00		      .byte.b	0	;G
    324  5adb		       2d		      .byte.b	45	;B
    325  5adc		       a0		      .byte.b	160	;R (12)
    326  5add		       04		      .byte.b	4	;G
    327  5ade		       29		      .byte.b	41	;B
    328  5adf		       a0		      .byte.b	160	;R (11)
    329  5ae0		       04		      .byte.b	4	;G
    330  5ae1		       29		      .byte.b	41	;B
    331  5ae2		       a0		      .byte.b	160	;R (10)
    332  5ae3		       04		      .byte.b	4	;G
    333  5ae4		       29		      .byte.b	41	;B
    334  5ae5		       60		      .byte.b	96	;R (9)
    335  5ae6		       04		      .byte.b	4	;G
    336  5ae7		       69		      .byte.b	105	;B
    337  5ae8		       60		      .byte.b	96	;R (8)
    338  5ae9		       04		      .byte.b	4	;G
    339  5aea		       79		      .byte.b	121	;B
    340  5aeb		       e0		      .byte.b	224	;R (7)
    341  5aec		       04		      .byte.b	4	;G
    342  5aed		       f9		      .byte.b	249	;B
    343  5aee		       c0		      .byte.b	192	;R (6)
    344  5aef		       04		      .byte.b	4	;G
    345  5af0		       d9		      .byte.b	217	;B
    346  5af1		       c0		      .byte.b	192	;R (5)
    347  5af2		       04		      .byte.b	4	;G
    348  5af3		       d9		      .byte.b	217	;B
    349  5af4		       80		      .byte.b	128	;R (4)
    350  5af5		       44		      .byte.b	68	;G
    351  5af6		       99		      .byte.b	153	;B
    352  5af7		       00		      .byte.b	0	;R (3)
    353  5af8		       ff		      .byte.b	255	;G
    354  5af9		       00		      .byte.b	0	;B
    355  5afa		       00		      .byte.b	0	;R (2)
    356  5afb		       ff		      .byte.b	255	;G
    357  5afc		       00		      .byte.b	0	;B
    358  5afd		       ff		      .byte.b	255	;R (1)
    359  5afe		       ff		      .byte.b	255	;G
    360  5aff		       ff		      .byte.b	255	;B
    361  5b00		       ff		      .byte.b	255	;R (0)
    362  5b01		       ff		      .byte.b	255	;G
    363  5b02		       ff		      .byte.b	255	;B
    364  5b03				   COL_3
    365  5b03		       f0		      .byte.b	240	;R (39)
    366  5b04		       f0		      .byte.b	240	;G
    367  5b05		       f0		      .byte.b	240	;B
    368  5b06		       f0		      .byte.b	240	;R (38)
    369  5b07		       f0		      .byte.b	240	;G
    370  5b08		       f0		      .byte.b	240	;B
    371  5b09		       00		      .byte.b	0	;R (37)
    372  5b0a		       f0		      .byte.b	240	;G
    373  5b0b		       f0		      .byte.b	240	;B
    374  5b0c		       00		      .byte.b	0	;R (36)
    375  5b0d		       30		      .byte.b	48	;G
    376  5b0e		       30		      .byte.b	48	;B
    377  5b0f		       00		      .byte.b	0	;R (35)
    378  5b10		       20		      .byte.b	32	;G
    379  5b11		       e0		      .byte.b	224	;B
    380  5b12		       00		      .byte.b	0	;R (34)
    381  5b13		       20		      .byte.b	32	;G
    382  5b14		       e0		      .byte.b	224	;B
    383  5b15		       00		      .byte.b	0	;R (33)
    384  5b16		       20		      .byte.b	32	;G
    385  5b17		       e0		      .byte.b	224	;B
    386  5b18		       00		      .byte.b	0	;R (32)
    387  5b19		       20		      .byte.b	32	;G
    388  5b1a		       e0		      .byte.b	224	;B
    389  5b1b		       10		      .byte.b	16	;R (31)
    390  5b1c		       00		      .byte.b	0	;G
    391  5b1d		       d0		      .byte.b	208	;B
    392  5b1e		       10		      .byte.b	16	;R (30)
    393  5b1f		       00		      .byte.b	0	;G
    394  5b20		       50		      .byte.b	80	;B
    395  5b21		       10		      .byte.b	16	;R (29)
    396  5b22		       00		      .byte.b	0	;G
    397  5b23		       50		      .byte.b	80	;B
    398  5b24		       10		      .byte.b	16	;R (28)
    399  5b25		       00		      .byte.b	0	;G
    400  5b26		       50		      .byte.b	80	;B
    401  5b27		       10		      .byte.b	16	;R (27)
    402  5b28		       00		      .byte.b	0	;G
    403  5b29		       50		      .byte.b	80	;B
    404  5b2a		       10		      .byte.b	16	;R (26)
    405  5b2b		       00		      .byte.b	0	;G
    406  5b2c		       50		      .byte.b	80	;B
    407  5b2d		       10		      .byte.b	16	;R (25)
    408  5b2e		       00		      .byte.b	0	;G
    409  5b2f		       50		      .byte.b	80	;B
    410  5b30		       10		      .byte.b	16	;R (24)
    411  5b31		       00		      .byte.b	0	;G
    412  5b32		       50		      .byte.b	80	;B
    413  5b33		       10		      .byte.b	16	;R (23)
    414  5b34		       00		      .byte.b	0	;G
    415  5b35		       d0		      .byte.b	208	;B
    416  5b36		       10		      .byte.b	16	;R (22)
    417  5b37		       00		      .byte.b	0	;G
    418  5b38		       d0		      .byte.b	208	;B
    419  5b39		       10		      .byte.b	16	;R (21)
    420  5b3a		       00		      .byte.b	0	;G
    421  5b3b		       d0		      .byte.b	208	;B
    422  5b3c		       10		      .byte.b	16	;R (20)
    423  5b3d		       00		      .byte.b	0	;G
    424  5b3e		       d0		      .byte.b	208	;B
    425  5b3f		       10		      .byte.b	16	;R (19)
    426  5b40		       00		      .byte.b	0	;G
    427  5b41		       d0		      .byte.b	208	;B
    428  5b42		       10		      .byte.b	16	;R (18)
    429  5b43		       00		      .byte.b	0	;G
    430  5b44		       d0		      .byte.b	208	;B
    431  5b45		       10		      .byte.b	16	;R (17)
    432  5b46		       00		      .byte.b	0	;G
    433  5b47		       50		      .byte.b	80	;B
    434  5b48		       10		      .byte.b	16	;R (16)
    435  5b49		       00		      .byte.b	0	;G
    436  5b4a		       50		      .byte.b	80	;B
    437  5b4b		       10		      .byte.b	16	;R (15)
    438  5b4c		       00		      .byte.b	0	;G
    439  5b4d		       50		      .byte.b	80	;B
    440  5b4e		       10		      .byte.b	16	;R (14)
    441  5b4f		       00		      .byte.b	0	;G
    442  5b50		       50		      .byte.b	80	;B
    443  5b51		       10		      .byte.b	16	;R (13)
    444  5b52		       00		      .byte.b	0	;G
    445  5b53		       50		      .byte.b	80	;B
    446  5b54		       10		      .byte.b	16	;R (12)
    447  5b55		       00		      .byte.b	0	;G
    448  5b56		       50		      .byte.b	80	;B
    449  5b57		       10		      .byte.b	16	;R (11)
    450  5b58		       00		      .byte.b	0	;G
    451  5b59		       50		      .byte.b	80	;B
    452  5b5a		       10		      .byte.b	16	;R (10)
    453  5b5b		       00		      .byte.b	0	;G
    454  5b5c		       50		      .byte.b	80	;B
    455  5b5d		       10		      .byte.b	16	;R (9)
    456  5b5e		       00		      .byte.b	0	;G
    457  5b5f		       50		      .byte.b	80	;B
    458  5b60		       10		      .byte.b	16	;R (8)
    459  5b61		       00		      .byte.b	0	;G
    460  5b62		       d0		      .byte.b	208	;B
    461  5b63		       10		      .byte.b	16	;R (7)
    462  5b64		       00		      .byte.b	0	;G
    463  5b65		       d0		      .byte.b	208	;B
    464  5b66		       10		      .byte.b	16	;R (6)
    465  5b67		       00		      .byte.b	0	;G
    466  5b68		       d0		      .byte.b	208	;B
    467  5b69		       10		      .byte.b	16	;R (5)
    468  5b6a		       00		      .byte.b	0	;G
    469  5b6b		       d0		      .byte.b	208	;B
    470  5b6c		       00		      .byte.b	0	;R (4)
    471  5b6d		       20		      .byte.b	32	;G
    472  5b6e		       c0		      .byte.b	192	;B
    473  5b6f		       00		      .byte.b	0	;R (3)
    474  5b70		       f0		      .byte.b	240	;G
    475  5b71		       00		      .byte.b	0	;B
    476  5b72		       00		      .byte.b	0	;R (2)
    477  5b73		       f0		      .byte.b	240	;G
    478  5b74		       00		      .byte.b	0	;B
    479  5b75		       f0		      .byte.b	240	;R (1)
    480  5b76		       f0		      .byte.b	240	;G
    481  5b77		       f0		      .byte.b	240	;B
    482  5b78		       f0		      .byte.b	240	;R (0)
    483  5b79		       f0		      .byte.b	240	;G
    484  5b7a		       f0		      .byte.b	240	;B
    485  5b7b				   COL_4
    486  5b7b		       ff		      .byte.b	255	;R (39)
    487  5b7c		       ff		      .byte.b	255	;G
    488  5b7d		       ff		      .byte.b	255	;B
    489  5b7e		       ff		      .byte.b	255	;R (38)
    490  5b7f		       ff		      .byte.b	255	;G
    491  5b80		       ff		      .byte.b	255	;B
    492  5b81		       00		      .byte.b	0	;R (37)
    493  5b82		       ff		      .byte.b	255	;G
    494  5b83		       ff		      .byte.b	255	;B
    495  5b84		       00		      .byte.b	0	;R (36)
    496  5b85		       79		      .byte.b	121	;G
    497  5b86		       79		      .byte.b	121	;B
    498  5b87		       00		      .byte.b	0	;R (35)
    499  5b88		       3e		      .byte.b	62	;G
    500  5b89		       b8		      .byte.b	184	;B
    501  5b8a		       00		      .byte.b	0	;R (34)
    502  5b8b		       3e		      .byte.b	62	;G
    503  5b8c		       b8		      .byte.b	184	;B
    504  5b8d		       00		      .byte.b	0	;R (33)
    505  5b8e		       1e		      .byte.b	30	;G
    506  5b8f		       d0		      .byte.b	208	;B
    507  5b90		       00		      .byte.b	0	;R (32)
    508  5b91		       0e		      .byte.b	14	;G
    509  5b92		       e0		      .byte.b	224	;B
    510  5b93		       00		      .byte.b	0	;R (31)
    511  5b94		       0f		      .byte.b	15	;G
    512  5b95		       e0		      .byte.b	224	;B
    513  5b96		       00		      .byte.b	0	;R (30)
    514  5b97		       8f		      .byte.b	143	;G
    515  5b98		       e0		      .byte.b	224	;B
    516  5b99		       00		      .byte.b	0	;R (29)
    517  5b9a		       c9		      .byte.b	201	;G
    518  5b9b		       e2		      .byte.b	226	;B
    519  5b9c		       00		      .byte.b	0	;R (28)
    520  5b9d		       c9		      .byte.b	201	;G
    521  5b9e		       e2		      .byte.b	226	;B
    522  5b9f		       00		      .byte.b	0	;R (27)
    523  5ba0		       c9		      .byte.b	201	;G
    524  5ba1		       e2		      .byte.b	226	;B
    525  5ba2		       00		      .byte.b	0	;R (26)
    526  5ba3		       c9		      .byte.b	201	;G
    527  5ba4		       e2		      .byte.b	226	;B
    528  5ba5		       00		      .byte.b	0	;R (25)
    529  5ba6		       89		      .byte.b	137	;G
    530  5ba7		       e2		      .byte.b	226	;B
    531  5ba8		       00		      .byte.b	0	;R (24)
    532  5ba9		       89		      .byte.b	137	;G
    533  5baa		       e2		      .byte.b	226	;B
    534  5bab		       00		      .byte.b	0	;R (23)
    535  5bac		       09		      .byte.b	9	;G
    536  5bad		       62		      .byte.b	98	;B
    537  5bae		       00		      .byte.b	0	;R (22)
    538  5baf		       09		      .byte.b	9	;G
    539  5bb0		       e2		      .byte.b	226	;B
    540  5bb1		       00		      .byte.b	0	;R (21)
    541  5bb2		       09		      .byte.b	9	;G
    542  5bb3		       d2		      .byte.b	210	;B
    543  5bb4		       00		      .byte.b	0	;R (20)
    544  5bb5		       09		      .byte.b	9	;G
    545  5bb6		       d2		      .byte.b	210	;B
    546  5bb7		       00		      .byte.b	0	;R (19)
    547  5bb8		       09		      .byte.b	9	;G
    548  5bb9		       d2		      .byte.b	210	;B
    549  5bba		       00		      .byte.b	0	;R (18)
    550  5bbb		       09		      .byte.b	9	;G
    551  5bbc		       52		      .byte.b	82	;B
    552  5bbd		       c0		      .byte.b	192	;R (17)
    553  5bbe		       09		      .byte.b	9	;G
    554  5bbf		       22		      .byte.b	34	;B
    555  5bc0		       c0		      .byte.b	192	;R (16)
    556  5bc1		       09		      .byte.b	9	;G
    557  5bc2		       22		      .byte.b	34	;B
    558  5bc3		       c0		      .byte.b	192	;R (15)
    559  5bc4		       09		      .byte.b	9	;G
    560  5bc5		       22		      .byte.b	34	;B
    561  5bc6		       c0		      .byte.b	192	;R (14)
    562  5bc7		       09		      .byte.b	9	;G
    563  5bc8		       22		      .byte.b	34	;B
    564  5bc9		       c0		      .byte.b	192	;R (13)
    565  5bca		       09		      .byte.b	9	;G
    566  5bcb		       22		      .byte.b	34	;B
    567  5bcc		       c0		      .byte.b	192	;R (12)
    568  5bcd		       09		      .byte.b	9	;G
    569  5bce		       22		      .byte.b	34	;B
    570  5bcf		       80		      .byte.b	128	;R (11)
    571  5bd0		       09		      .byte.b	9	;G
    572  5bd1		       62		      .byte.b	98	;B
    573  5bd2		       80		      .byte.b	128	;R (10)
    574  5bd3		       09		      .byte.b	9	;G
    575  5bd4		       62		      .byte.b	98	;B
    576  5bd5		       00		      .byte.b	0	;R (9)
    577  5bd6		       0d		      .byte.b	13	;G
    578  5bd7		       60		      .byte.b	96	;B
    579  5bd8		       10		      .byte.b	16	;R (8)
    580  5bd9		       0d		      .byte.b	13	;G
    581  5bda		       c0		      .byte.b	192	;B
    582  5bdb		       10		      .byte.b	16	;R (7)
    583  5bdc		       0f		      .byte.b	15	;G
    584  5bdd		       c0		      .byte.b	192	;B
    585  5bde		       18		      .byte.b	24	;R (6)
    586  5bdf		       07		      .byte.b	7	;G
    587  5be0		       c0		      .byte.b	192	;B
    588  5be1		       18		      .byte.b	24	;R (5)
    589  5be2		       07		      .byte.b	7	;G
    590  5be3		       80		      .byte.b	128	;B
    591  5be4		       3c		      .byte.b	60	;R (4)
    592  5be5		       02		      .byte.b	2	;G
    593  5be6		       80		      .byte.b	128	;B
    594  5be7		       3f		      .byte.b	63	;R (3)
    595  5be8		       c0		      .byte.b	192	;G
    596  5be9		       00		      .byte.b	0	;B
    597  5bea		       1f		      .byte.b	31	;R (2)
    598  5beb		       e0		      .byte.b	224	;G
    599  5bec		       00		      .byte.b	0	;B
    600  5bed		       ff		      .byte.b	255	;R (1)
    601  5bee		       ff		      .byte.b	255	;G
    602  5bef		       ff		      .byte.b	255	;B
    603  5bf0		       ff		      .byte.b	255	;R (0)
    604  5bf1		       ff		      .byte.b	255	;G
    605  5bf2		       ff		      .byte.b	255	;B
    606  5bf3				   COL_5
    607  5bf3		       3f		      .byte.b	63	;R (39)
    608  5bf4		       3f		      .byte.b	63	;G
    609  5bf5		       3f		      .byte.b	63	;B
    610  5bf6		       7f		      .byte.b	127	;R (38)
    611  5bf7		       7f		      .byte.b	127	;G
    612  5bf8		       7f		      .byte.b	127	;B
    613  5bf9		       40		      .byte.b	64	;R (37)
    614  5bfa		       7f		      .byte.b	127	;G
    615  5bfb		       7f		      .byte.b	127	;B
    616  5bfc		       c0		      .byte.b	192	;R (36)
    617  5bfd		       f3		      .byte.b	243	;G
    618  5bfe		       f3		      .byte.b	243	;B
    619  5bff		       8c		      .byte.b	140	;R (35)
    620  5c00		       ef		      .byte.b	239	;G
    621  5c01		       e3		      .byte.b	227	;B
    622  5c02		       8c		      .byte.b	140	;R (34)
    623  5c03		       ef		      .byte.b	239	;G
    624  5c04		       e3		      .byte.b	227	;B
    625  5c05		       8e		      .byte.b	142	;R (33)
    626  5c06		       ef		      .byte.b	239	;G
    627  5c07		       e1		      .byte.b	225	;B
    628  5c08		       8e		      .byte.b	142	;R (32)
    629  5c09		       ef		      .byte.b	239	;G
    630  5c0a		       e1		      .byte.b	225	;B
    631  5c0b		       9e		      .byte.b	158	;R (31)
    632  5c0c		       9e		      .byte.b	158	;G
    633  5c0d		       c0		      .byte.b	192	;B
    634  5c0e		       9e		      .byte.b	158	;R (30)
    635  5c0f		       9e		      .byte.b	158	;G
    636  5c10		       c0		      .byte.b	192	;B
    637  5c11		       92		      .byte.b	146	;R (29)
    638  5c12		       92		      .byte.b	146	;G
    639  5c13		       c8		      .byte.b	200	;B
    640  5c14		       92		      .byte.b	146	;R (28)
    641  5c15		       92		      .byte.b	146	;G
    642  5c16		       c8		      .byte.b	200	;B
    643  5c17		       92		      .byte.b	146	;R (27)
    644  5c18		       92		      .byte.b	146	;G
    645  5c19		       c8		      .byte.b	200	;B
    646  5c1a		       92		      .byte.b	146	;R (26)
    647  5c1b		       92		      .byte.b	146	;G
    648  5c1c		       c8		      .byte.b	200	;B
    649  5c1d		       92		      .byte.b	146	;R (25)
    650  5c1e		       92		      .byte.b	146	;G
    651  5c1f		       c8		      .byte.b	200	;B
    652  5c20		       92		      .byte.b	146	;R (24)
    653  5c21		       92		      .byte.b	146	;G
    654  5c22		       c8		      .byte.b	200	;B
    655  5c23		       92		      .byte.b	146	;R (23)
    656  5c24		       92		      .byte.b	146	;G
    657  5c25		       c8		      .byte.b	200	;B
    658  5c26		       92		      .byte.b	146	;R (22)
    659  5c27		       92		      .byte.b	146	;G
    660  5c28		       c8		      .byte.b	200	;B
    661  5c29		       92		      .byte.b	146	;R (21)
    662  5c2a		       92		      .byte.b	146	;G
    663  5c2b		       c8		      .byte.b	200	;B
    664  5c2c		       92		      .byte.b	146	;R (20)
    665  5c2d		       92		      .byte.b	146	;G
    666  5c2e		       c8		      .byte.b	200	;B
    667  5c2f		       92		      .byte.b	146	;R (19)
    668  5c30		       92		      .byte.b	146	;G
    669  5c31		       c8		      .byte.b	200	;B
    670  5c32		       92		      .byte.b	146	;R (18)
    671  5c33		       92		      .byte.b	146	;G
    672  5c34		       c8		      .byte.b	200	;B
    673  5c35		       92		      .byte.b	146	;R (17)
    674  5c36		       92		      .byte.b	146	;G
    675  5c37		       c8		      .byte.b	200	;B
    676  5c38		       92		      .byte.b	146	;R (16)
    677  5c39		       92		      .byte.b	146	;G
    678  5c3a		       c8		      .byte.b	200	;B
    679  5c3b		       92		      .byte.b	146	;R (15)
    680  5c3c		       92		      .byte.b	146	;G
    681  5c3d		       c8		      .byte.b	200	;B
    682  5c3e		       92		      .byte.b	146	;R (14)
    683  5c3f		       92		      .byte.b	146	;G
    684  5c40		       c8		      .byte.b	200	;B
    685  5c41		       92		      .byte.b	146	;R (13)
    686  5c42		       92		      .byte.b	146	;G
    687  5c43		       c8		      .byte.b	200	;B
    688  5c44		       92		      .byte.b	146	;R (12)
    689  5c45		       92		      .byte.b	146	;G
    690  5c46		       c8		      .byte.b	200	;B
    691  5c47		       92		      .byte.b	146	;R (11)
    692  5c48		       92		      .byte.b	146	;G
    693  5c49		       c8		      .byte.b	200	;B
    694  5c4a		       92		      .byte.b	146	;R (10)
    695  5c4b		       92		      .byte.b	146	;G
    696  5c4c		       c8		      .byte.b	200	;B
    697  5c4d		       96		      .byte.b	150	;R (9)
    698  5c4e		       96		      .byte.b	150	;G
    699  5c4f		       c0		      .byte.b	192	;B
    700  5c50		       96		      .byte.b	150	;R (8)
    701  5c51		       96		      .byte.b	150	;G
    702  5c52		       c0		      .byte.b	192	;B
    703  5c53		       9e		      .byte.b	158	;R (7)
    704  5c54		       9e		      .byte.b	158	;G
    705  5c55		       c0		      .byte.b	192	;B
    706  5c56		       9e		      .byte.b	158	;R (6)
    707  5c57		       9c		      .byte.b	156	;G
    708  5c58		       c0		      .byte.b	192	;B
    709  5c59		       9e		      .byte.b	158	;R (5)
    710  5c5a		       9c		      .byte.b	156	;G
    711  5c5b		       c0		      .byte.b	192	;B
    712  5c5c		       ef		      .byte.b	239	;R (4)
    713  5c5d		       88		      .byte.b	136	;G
    714  5c5e		       80		      .byte.b	128	;B
    715  5c5f		       7f		      .byte.b	127	;R (3)
    716  5c60		       40		      .byte.b	64	;G
    717  5c61		       40		      .byte.b	64	;B
    718  5c62		       7f		      .byte.b	127	;R (2)
    719  5c63		       40		      .byte.b	64	;G
    720  5c64		       40		      .byte.b	64	;B
    721  5c65		       7f		      .byte.b	127	;R (1)
    722  5c66		       7f		      .byte.b	127	;G
    723  5c67		       7f		      .byte.b	127	;B
    724  5c68		       3f		      .byte.b	63	;R (0)
    725  5c69		       3f		      .byte.b	63	;G
    726  5c6a		       3f		      .byte.b	63	;B
------- FILE titleScreen.asm
    164  5c6b							;    include "pizza.asm"
    165  5c6b
      0  5c6b					      CHECK_BANK_SIZE	"TITLESCREEN"
      1  5c6b		       04 6b	   .TEMP      =	* - BANK_START
 TITLESCREEN (2K) SIZE =  $46b , FREE= $395
      2  5c6b					      ECHO	"TITLESCREEN", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5c6b				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  5c6b				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5c6b				  -	      ERR
      6  5c6b					      endif
------- FILE ./sokoboo.asm
------- FILE levelScreen.asm LEVEL 2 PASS 3
      0  5c6b					      include	"levelScreen.asm"
      0  5c6b					      NEWBANK	LEVELSCREEN
      1  67d8 ????				      SEG	LEVELSCREEN
      2  6000					      ORG	ORIGIN
      3  6000					      RORG	$F000
      4  6000				   BANK_START SET	*
      5  6000				   LEVELSCREEN SET	ORIGIN / 2048
      6  6000				   ORIGIN     SET	ORIGIN + 2048
      7  6000				   _CURRENT_BANK SET	LEVELSCREEN
      2  6000
      3  6000		       00 f0	   WALLCOLOUR =	$F0
      4  6000		       00 12	   TOPHAT     =	18
      5  6000
      0  6000					      DEFINE_SUBROUTINE	SelectionScreenInit
      1  6000		       00 0c	   BANK_SelectionScreenInit =	_CURRENT_BANK
      2  6000					      SUBROUTINE
      3  6000				   SelectionScreenInit
      7  6000
      8  6000		       a9 00		      lda	#%0
      9  6002		       85 44		      sta	NUSIZ0
     10  6004		       85 45		      sta	NUSIZ1
     11  6006		       85 65		      sta	VDELP0
     12  6008		       85 66		      sta	VDELP1
     13  600a		       85 4b		      sta	REFP0
     14  600c		       85 4c		      sta	REFP1
     15  600e
     16  600e		       a9 f0		      lda	#%11110000
     17  6010		       85 60		      sta	HMP0
     18  6012
     19  6012		       a9 d0		      lda	#%11010000
     20  6014		       85 61		      sta	HMP1
     21  6016
     22  6016		       a9 f0		      lda	#WALLCOLOUR
     23  6018		       85 46		      sta	COLUP0
     24  601a		       85 47		      sta	COLUP1
     25  601c
     26  601c		       a9 04		      lda	#%100
     27  601e		       85 4a		      sta	CTRLPF
     28  6020
     29  6020
     30  6020		       60		      rts
     31  6021
     32  6021
     33  6021
      0  6021					      DEFINE_SUBROUTINE	LevelScreen
      1  6021		       00 0c	   BANK_LevelScreen =	_CURRENT_BANK
      2  6021					      SUBROUTINE
      3  6021				   LevelScreen
     35  6021
     36  6021							; Start of new frame
     37  6021
     38  6021							; Start of vertical blank processing
     39  6021
     40  6021		       44 44 64 64 Qcolour    .byte.b	$44,$44, $64,$64
     41  6025
     42  6025				   LevelSequence
     43  6025
     44  6025		       c9 00		      cmp	#0
     45  6027		       f0 05		      beq	noQuestion
     46  6029		       a6 80		      ldx	Platform
     47  602b		       bd 21 f0 	      lda	Qcolour,x
     48  602e		       85 e7	   noQuestion sta	selector
     49  6030
     50  6030
     51  6030
      0  6030					      RESYNC		; uses overlay
      1  6030
      2  6030		       a9 02		      lda	#%10
      3  6032		       85 41		      sta	VBLANK
      4  6034
      5  6034		       a2 08		      ldx	#8
      6  6036				   .loopResync
      0  6036					      VERTICAL_SYNC
      1  6036		       a9 0e		      lda	#%1110
      2  6038		       85 42	   .VSLP1     sta	WSYNC
      3  603a		       85 40		      sta	VSYNC
      4  603c		       4a		      lsr
      5  603d		       d0 f9		      bne	.VSLP1
      8  603f
      9  603f		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  6041		       a5 80		      lda	Platform
     11  6043		       49 02		      eor	#PAL_50
     12  6045		       d0 02		      bne	.ntsc
     13  6047		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  6049				   .ntsc
     15  6049				   .loopWait
     16  6049		       85 42		      sta	WSYNC
     17  604b		       85 42		      sta	WSYNC
     18  604d		       88		      dey
     19  604e		       d0 f9		      bne	.loopWait
     20  6050		       ca		      dex
     21  6051		       d0 e3		      bne	.loopResync
     53  6053
     54  6053		       20 00 f0 	      jsr	SelectionScreenInit
     55  6056
     56  6056		       a9 00		      lda	#%00000000
     57  6058		       85 49		      sta	COLUBK
     58  605a		       85 59		      sta	AUDV0
     59  605c		       85 5a		      sta	AUDV1	; turn off music while levels init
     60  605e
     61  605e		       a9 80		      lda	#$80
     62  6060		       85 de		      sta	digitick
     63  6062		       a9 ff		      lda	#-1
     64  6064		       85 e3		      sta	endwait
     65  6066
     66  6066		       a9 0a		      lda	#10
     67  6068		       85 e2		      sta	initialdelay
     68  606a
     69  606a
     70  606a		       a9 ff		      lda	#-1
     71  606c		       85 df		      sta	targetDigit
     72  606e		       85 e0		      sta	targetDigit+1
     73  6070		       85 e1		      sta	targetDigit+2
     74  6072
     75  6072		       a9 00		      lda	#0
     76  6074		       85 db		      sta	digit
     77  6076		       85 dc		      sta	digit+1
     78  6078		       85 dd		      sta	digit+2
     79  607a		       85 e8		      sta	walkSpeed
     80  607c
     81  607c							; convert to 3 digits decimal
     82  607c		       20 d5 f2 	      jsr	dd3
     83  607f
     84  607f		       20 ee f2 	      jsr	fixWalkFrame
     85  6082
     86  6082		       a5 e7		      lda	selector
     87  6084		       f0 0c		      beq	RestartFrameX
     88  6086
     89  6086		       a5 df		      lda	targetDigit
     90  6088		       85 db		      sta	digit
     91  608a		       a5 e1		      lda	targetDigit+2
     92  608c		       85 dd		      sta	digit+2
     93  608e		       a5 e0		      lda	targetDigit+1
     94  6090		       85 dc		      sta	digit+1
     95  6092
     96  6092
     97  6092				   RestartFrameX
     98  6092		       a9 0e		      lda	#%1110	; VSYNC ON
     99  6094		       85 42	   .loopVSync3 sta	WSYNC
    100  6096		       85 40		      sta	VSYNC
    101  6098		       4a		      lsr
    102  6099		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
    103  609b
    104  609b		       a9 00		      lda	#0
    105  609d		       85 49		      sta	COLUBK
    106  609f
    107  609f
    108  609f		       a6 80		      ldx	Platform
    109  60a1		       bc 8f f3 	      ldy	VBlankTime2x,x
    110  60a4		       8c 96 02 	      sty	TIM64T
    111  60a7
    112  60a7
    113  60a7		       a5 dd		      lda	digit+2	; hundreds
    114  60a9		       0a		      asl
    115  60aa		       aa		      tax
    116  60ab		       bd d5 f3 	      lda	DIGITHUND,x
    117  60ae		       85 e5		      sta	digitHundreds
    118  60b0		       bd d6 f3 	      lda	DIGITHUND+1,x
    119  60b3		       85 e6		      sta	digitHundreds+1
    120  60b5
    121  60b5		       a5 dc		      lda	digit+1	; tens
    122  60b7		       0a		      asl
    123  60b8		       aa		      tax
    124  60b9		       bd ad f3 	      lda	LDIGIT,x
    125  60bc		       85 d4		      sta	digit1
    126  60be		       bd ae f3 	      lda	LDIGIT+1,x
    127  60c1		       85 d5		      sta	digit1+1
    128  60c3
    129  60c3		       a5 db		      lda	digit	; units
    130  60c5		       0a		      asl
    131  60c6		       aa		      tax
    132  60c7		       bd c1 f3 	      lda	RDIGIT,x
    133  60ca		       85 d6		      sta	digit2
    134  60cc		       bd c2 f3 	      lda	RDIGIT+1,x
    135  60cf		       85 d7		      sta	digit2+1
    136  60d1
    137  60d1
    138  60d1
    139  60d1							;------------------------------------------------------------------
    140  60d1
    141  60d1
    142  60d1				   VerticalBlankX
    143  60d1		       ad 84 02 	      lda	INTIM
    144  60d4		       d0 fb		      bne	VerticalBlankX
    145  60d6		       85 41		      sta	VBLANK
    146  60d8
    147  60d8		       a4 80		      ldy	Platform
    148  60da		       b9 93 f3 	      lda	OverscanTime2X,y
    149  60dd		       8d 96 02 	      sta	TIM64T
    150  60e0
    151  60e0
    152  60e0		       a9 00		      lda	#0
    153  60e2		       85 4d		      sta	PF0
    154  60e4		       85 4e		      sta	PF1
    155  60e6		       85 4f		      sta	PF2
    156  60e8		       85 49		      sta	COLUBK
    157  60ea
    158  60ea							; position the sprites for the box walls
    159  60ea
    160  60ea		       85 42		      sta	WSYNC
    161  60ec
      0  60ec					      SLEEP	17
      1  60ec				   .CYCLES    SET	17
      2  60ec
      3  60ec				  -	      IF	.CYCLES < 2
      4  60ec				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  60ec				  -	      ERR
      6  60ec					      ENDIF
      7  60ec
      8  60ec					      IF	.CYCLES & 1
      9  60ec					      IFNCONST	NO_ILLEGAL_OPCODES
     10  60ec		       04 00		      nop	0
     11  60ee				  -	      ELSE
     12  60ee				  -	      bit	VSYNC
     13  60ee					      ENDIF
     14  60ee				   .CYCLES    SET	.CYCLES - 3
     15  60ee					      ENDIF
     16  60ee
     17  60ee					      REPEAT	.CYCLES / 2
     18  60ee		       ea		      nop
     17  60ee					      REPEND
     18  60ef		       ea		      nop
     17  60ef					      REPEND
     18  60f0		       ea		      nop
     17  60f0					      REPEND
     18  60f1		       ea		      nop
     17  60f1					      REPEND
     18  60f2		       ea		      nop
     17  60f2					      REPEND
     18  60f3		       ea		      nop
     17  60f3					      REPEND
     18  60f4		       ea		      nop
     19  60f5					      REPEND
    163  60f5		       85 50		      sta	RESP0
    164  60f7
      0  60f7					      SLEEP	37
      1  60f7				   .CYCLES    SET	37
      2  60f7
      3  60f7				  -	      IF	.CYCLES < 2
      4  60f7				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  60f7				  -	      ERR
      6  60f7					      ENDIF
      7  60f7
      8  60f7					      IF	.CYCLES & 1
      9  60f7					      IFNCONST	NO_ILLEGAL_OPCODES
     10  60f7		       04 00		      nop	0
     11  60f9				  -	      ELSE
     12  60f9				  -	      bit	VSYNC
     13  60f9					      ENDIF
     14  60f9				   .CYCLES    SET	.CYCLES - 3
     15  60f9					      ENDIF
     16  60f9
     17  60f9					      REPEAT	.CYCLES / 2
     18  60f9		       ea		      nop
     17  60f9					      REPEND
     18  60fa		       ea		      nop
     17  60fa					      REPEND
     18  60fb		       ea		      nop
     17  60fb					      REPEND
     18  60fc		       ea		      nop
     17  60fc					      REPEND
     18  60fd		       ea		      nop
     17  60fd					      REPEND
     18  60fe		       ea		      nop
     17  60fe					      REPEND
     18  60ff		       ea		      nop
     17  60ff					      REPEND
     18  6100		       ea		      nop
     17  6100					      REPEND
     18  6101		       ea		      nop
     17  6101					      REPEND
     18  6102		       ea		      nop
     17  6102					      REPEND
     18  6103		       ea		      nop
     17  6103					      REPEND
     18  6104		       ea		      nop
     17  6104					      REPEND
     18  6105		       ea		      nop
     17  6105					      REPEND
     18  6106		       ea		      nop
     17  6106					      REPEND
     18  6107		       ea		      nop
     17  6107					      REPEND
     18  6108		       ea		      nop
     17  6108					      REPEND
     18  6109		       ea		      nop
     19  610a					      REPEND
    166  610a		       85 51		      sta	RESP1
    167  610c
    168  610c		       85 42		      sta	WSYNC
    169  610e		       85 6a		      sta	HMOVE
    170  6110
    171  6110
    172  6110							;===================================================================================================
    173  6110
    174  6110							; now a top for the 'box'
    175  6110
    176  6110		       a9 00		      lda	#0
    177  6112		       85 4d		      sta	PF0
    178  6114		       85 4e		      sta	PF1
    179  6116		       85 4f		      sta	PF2
    180  6118
    181  6118		       85 42		      sta	WSYNC
    182  611a		       85 42		      sta	WSYNC
    183  611c		       85 42		      sta	WSYNC
    184  611e
    185  611e
    186  611e
    187  611e
    188  611e							;		  lda #WALLCOLOUR
    189  611e							;		  sta COLUPF
    190  611e
    191  611e		       a0 11		      ldy	#TOPHAT-1
    192  6120		       85 42	   boxtop     sta	WSYNC	;@0
    193  6122		       b9 9b f3 	      lda	topcolour,y
    194  6125		       85 48		      sta	COLUPF
    195  6127		       b9 e9 f3 	      lda	lid0,y	;#%11100000
    196  612a		       85 4d		      sta	PF0
    197  612c		       b9 fb f3 	      lda	lid1,y	;#255
    198  612f							;nop
    199  612f		       85 4e		      sta	PF1
    200  6131		       b9 fb f3 	      lda	lid2,y	;#255
    201  6134							;nop
    202  6134		       85 4f		      sta	PF2	; 3 = 8 @ 19
    203  6136
    204  6136							; RHS
    205  6136		       b9 0d f4 	      lda	lid3,y	;#255
    206  6139							;nop
    207  6139		       85 4d		      sta	PF0	; 3 = 8 @ 27 OK	D7D6D5D4 <--- mirrored
    208  613b
      0  613b					      SLEEP	8
      1  613b				   .CYCLES    SET	8
      2  613b
      3  613b				  -	      IF	.CYCLES < 2
      4  613b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  613b				  -	      ERR
      6  613b					      ENDIF
      7  613b
      8  613b				  -	      IF	.CYCLES & 1
      9  613b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  613b				  -	      nop	0
     11  613b				  -	      ELSE
     12  613b				  -	      bit	VSYNC
     13  613b				  -	      ENDIF
     14  613b				  -.CYCLES    SET	.CYCLES - 3
     15  613b					      ENDIF
     16  613b
     17  613b					      REPEAT	.CYCLES / 2
     18  613b		       ea		      nop
     17  613b					      REPEND
     18  613c		       ea		      nop
     17  613c					      REPEND
     18  613d		       ea		      nop
     17  613d					      REPEND
     18  613e		       ea		      nop
     19  613f					      REPEND
    210  613f		       b9 0d f4 	      lda	lid4,y	;#255
    211  6142		       85 4e		      sta	PF1	; 3 @40		 NOT MIRRORED, D7D6D5D4 -->
    212  6144
    213  6144		       a9 00		      lda	#%00000000
    214  6146							;		  nop
    215  6146		       85 4f		      sta	PF2	; 3 = 8 @48
    216  6148
    217  6148		       a9 00		      lda	#0
    218  614a		       85 49		      sta	COLUBK
    219  614c
    220  614c
    221  614c		       88		      dey		; 2
    222  614d		       10 d1		      bpl	boxtop
    223  614f
    224  614f
    225  614f		       a9 00		      lda	#0
    226  6151		       85 4d		      sta	PF0
    227  6153		       85 4e		      sta	PF1
    228  6155		       85 4f		      sta	PF2
    229  6157							;		  sta GRP0
    230  6157							;		  sta GRP1
    231  6157
    232  6157		       a9 fc		      lda	#%11111100
    233  6159		       85 5b		      sta	GRP0
    234  615b		       a9 3f		      lda	#%00111111
    235  615d		       85 5c		      sta	GRP1
    236  615f
    237  615f
    238  615f		       85 42		      sta	WSYNC
    239  6161		       85 42		      sta	WSYNC
    240  6163		       85 42		      sta	WSYNC
    241  6165		       85 42		      sta	WSYNC
    242  6167		       85 42		      sta	WSYNC
    243  6169
    244  6169							;===================================================================================================
    245  6169
    246  6169		       a6 80		      ldx	Platform
    247  616b		       bd 97 f3 	      lda	colvecX,x
    248  616e		       aa		      tax
    249  616f
    250  616f							;------------------------------------------------------------------
    251  616f
    252  616f							; Do X scanlines of color-changing (our picture)
    253  616f
    254  616f
    255  616f		       a9 2a		      lda	#$2A	; 2
    256  6171		       85 48		      sta	COLUPF	; 3 = 5 @8
    257  6173
    258  6173		       a0 1a		      ldy	#26	; #lines in characters-1
    259  6175		       a2 00		      ldx	#0	;%01000000		     ; PF0
    260  6177
    261  6177
    262  6177		       85 42		      sta	WSYNC
    263  6179
      0  6179					      SLEEP	4
      1  6179				   .CYCLES    SET	4
      2  6179
      3  6179				  -	      IF	.CYCLES < 2
      4  6179				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  6179				  -	      ERR
      6  6179					      ENDIF
      7  6179
      8  6179				  -	      IF	.CYCLES & 1
      9  6179				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  6179				  -	      nop	0
     11  6179				  -	      ELSE
     12  6179				  -	      bit	VSYNC
     13  6179				  -	      ENDIF
     14  6179				  -.CYCLES    SET	.CYCLES - 3
     15  6179					      ENDIF
     16  6179
     17  6179					      REPEAT	.CYCLES / 2
     18  6179		       ea		      nop
     17  6179					      REPEND
     18  617a		       ea		      nop
     19  617b					      REPEND
    265  617b
    266  617b				   LevelNumberDigits
    267  617b
    268  617b				   .LOOP      SET	0
    269  617b					      REPEAT	3
    270  617b
    271  617b							;@5
    272  617b
    273  617b		       86 4d		      stx	PF0	; 3
    274  617d
    275  617d					      IF	.LOOP < 2
    276  617d		       b9 1e f3 	      lda	colbk,y	; 4
    277  6180		       85 48		      sta	COLUPF	; 3 = 7 @15
    278  6182				  -	      ELSE
    279  6182				  -	      lda	#0
    280  6182				  -	      nop
    281  6182				  -	      sta	COLUPF	; 3 = 7 @15
    282  6182				  -
    283  6182					      ENDIF
    284  6182		       b1 e5		      lda	(digitHundreds),y	; 5
    285  6184		       85 4e		      sta	PF1	; 3 = 8 @23
    286  6186
    287  6186		       b1 d4		      lda	(digit1),y	; 5
    288  6188		       85 4f		      sta	PF2	; 3 = 8 @ 31
    289  618a
    290  618a							; RHS
    291  618a
    292  618a		       b1 d6		      lda	(digit2),y	; 5
    293  618c		       85 4d		      sta	PF0	; 3 = 8 @ 39	     D7D6D5D4 <--- mirrored
    294  618e
    295  618e		       0a		      asl		; 2
    296  618f		       0a		      asl		; 2
    297  6190		       0a		      asl		; 2
    298  6191		       0a		      asl		; 2
    299  6192		       85 4e		      sta	PF1	; 3 = 11 @50	     NOT MIRRORED, D7D6D5D4 -->
    300  6194
    301  6194		       b1 d9		      lda	(digitstar),y	; 5
    302  6196		       85 4f		      sta	PF2	; 3 = 8 @56
    303  6198
    304  6198		       b1 e9		      lda	(manc),y	; 5
    305  619a		       85 48		      sta	COLUPF	; 3 = 8 @64
    306  619c
    307  619c
    308  619c		       00 0f	   SPARE      =	15
    309  619c
    310  619c
    311  619c					      IF	.LOOP < 2
      0  619c					      SLEEP	SPARE
      1  619c				   .CYCLES    SET	SPARE
      2  619c
      3  619c				  -	      IF	.CYCLES < 2
      4  619c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  619c				  -	      ERR
      6  619c					      ENDIF
      7  619c
      8  619c					      IF	.CYCLES & 1
      9  619c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  619c		       04 00		      nop	0
     11  619e				  -	      ELSE
     12  619e				  -	      bit	VSYNC
     13  619e					      ENDIF
     14  619e				   .CYCLES    SET	.CYCLES - 3
     15  619e					      ENDIF
     16  619e
     17  619e					      REPEAT	.CYCLES / 2
     18  619e		       ea		      nop
     17  619e					      REPEND
     18  619f		       ea		      nop
     17  619f					      REPEND
     18  61a0		       ea		      nop
     17  61a0					      REPEND
     18  61a1		       ea		      nop
     17  61a1					      REPEND
     18  61a2		       ea		      nop
     17  61a2					      REPEND
     18  61a3		       ea		      nop
     19  61a4					      REPEND
    313  61a4					      ENDIF
    314  61a4
    315  61a4				  -	      IF	.LOOP = 2
    316  61a4				  -	      SLEEP	SPARE-7
    317  61a4					      ENDIF
    318  61a4
    319  61a4
    320  61a4				   .LOOP      SET	.LOOP + 1
    269  61a4					      REPEND
    270  61a4
    271  61a4							;@5
    272  61a4
    273  61a4		       86 4d		      stx	PF0	; 3
    274  61a6
    275  61a6					      IF	.LOOP < 2
    276  61a6		       b9 1e f3 	      lda	colbk,y	; 4
    277  61a9		       85 48		      sta	COLUPF	; 3 = 7 @15
    278  61ab				  -	      ELSE
    279  61ab				  -	      lda	#0
    280  61ab				  -	      nop
    281  61ab				  -	      sta	COLUPF	; 3 = 7 @15
    282  61ab				  -
    283  61ab					      ENDIF
    284  61ab		       b1 e5		      lda	(digitHundreds),y	; 5
    285  61ad		       85 4e		      sta	PF1	; 3 = 8 @23
    286  61af
    287  61af		       b1 d4		      lda	(digit1),y	; 5
    288  61b1		       85 4f		      sta	PF2	; 3 = 8 @ 31
    289  61b3
    290  61b3							; RHS
    291  61b3
    292  61b3		       b1 d6		      lda	(digit2),y	; 5
    293  61b5		       85 4d		      sta	PF0	; 3 = 8 @ 39	     D7D6D5D4 <--- mirrored
    294  61b7
    295  61b7		       0a		      asl		; 2
    296  61b8		       0a		      asl		; 2
    297  61b9		       0a		      asl		; 2
    298  61ba		       0a		      asl		; 2
    299  61bb		       85 4e		      sta	PF1	; 3 = 11 @50	     NOT MIRRORED, D7D6D5D4 -->
    300  61bd
    301  61bd		       b1 d9		      lda	(digitstar),y	; 5
    302  61bf		       85 4f		      sta	PF2	; 3 = 8 @56
    303  61c1
    304  61c1		       b1 e9		      lda	(manc),y	; 5
    305  61c3		       85 48		      sta	COLUPF	; 3 = 8 @64
    306  61c5
    307  61c5
    308  61c5		       00 0f	   SPARE      =	15
    309  61c5
    310  61c5
    311  61c5					      IF	.LOOP < 2
      0  61c5					      SLEEP	SPARE
      1  61c5				   .CYCLES    SET	SPARE
      2  61c5
      3  61c5				  -	      IF	.CYCLES < 2
      4  61c5				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  61c5				  -	      ERR
      6  61c5					      ENDIF
      7  61c5
      8  61c5					      IF	.CYCLES & 1
      9  61c5					      IFNCONST	NO_ILLEGAL_OPCODES
     10  61c5		       04 00		      nop	0
     11  61c7				  -	      ELSE
     12  61c7				  -	      bit	VSYNC
     13  61c7					      ENDIF
     14  61c7				   .CYCLES    SET	.CYCLES - 3
     15  61c7					      ENDIF
     16  61c7
     17  61c7					      REPEAT	.CYCLES / 2
     18  61c7		       ea		      nop
     17  61c7					      REPEND
     18  61c8		       ea		      nop
     17  61c8					      REPEND
     18  61c9		       ea		      nop
     17  61c9					      REPEND
     18  61ca		       ea		      nop
     17  61ca					      REPEND
     18  61cb		       ea		      nop
     17  61cb					      REPEND
     18  61cc		       ea		      nop
     19  61cd					      REPEND
    313  61cd					      ENDIF
    314  61cd
    315  61cd				  -	      IF	.LOOP = 2
    316  61cd				  -	      SLEEP	SPARE-7
    317  61cd					      ENDIF
    318  61cd
    319  61cd
    320  61cd				   .LOOP      SET	.LOOP + 1
    269  61cd					      REPEND
    270  61cd
    271  61cd							;@5
    272  61cd
    273  61cd		       86 4d		      stx	PF0	; 3
    274  61cf
    275  61cf				  -	      IF	.LOOP < 2
    276  61cf				  -	      lda	colbk,y	; 4
    277  61cf				  -	      sta	COLUPF	; 3 = 7 @15
    278  61cf					      ELSE
    279  61cf		       a9 00		      lda	#0
    280  61d1		       ea		      nop
    281  61d2		       85 48		      sta	COLUPF	; 3 = 7 @15
    282  61d4
    283  61d4					      ENDIF
    284  61d4		       b1 e5		      lda	(digitHundreds),y	; 5
    285  61d6		       85 4e		      sta	PF1	; 3 = 8 @23
    286  61d8
    287  61d8		       b1 d4		      lda	(digit1),y	; 5
    288  61da		       85 4f		      sta	PF2	; 3 = 8 @ 31
    289  61dc
    290  61dc							; RHS
    291  61dc
    292  61dc		       b1 d6		      lda	(digit2),y	; 5
    293  61de		       85 4d		      sta	PF0	; 3 = 8 @ 39	     D7D6D5D4 <--- mirrored
    294  61e0
    295  61e0		       0a		      asl		; 2
    296  61e1		       0a		      asl		; 2
    297  61e2		       0a		      asl		; 2
    298  61e3		       0a		      asl		; 2
    299  61e4		       85 4e		      sta	PF1	; 3 = 11 @50	     NOT MIRRORED, D7D6D5D4 -->
    300  61e6
    301  61e6		       b1 d9		      lda	(digitstar),y	; 5
    302  61e8		       85 4f		      sta	PF2	; 3 = 8 @56
    303  61ea
    304  61ea		       b1 e9		      lda	(manc),y	; 5
    305  61ec		       85 48		      sta	COLUPF	; 3 = 8 @64
    306  61ee
    307  61ee
    308  61ee		       00 0f	   SPARE      =	15
    309  61ee
    310  61ee
    311  61ee				  -	      IF	.LOOP < 2
    312  61ee				  -	      SLEEP	SPARE
    313  61ee					      ENDIF
    314  61ee
    315  61ee					      IF	.LOOP = 2
      0  61ee					      SLEEP	SPARE-7
      1  61ee				   .CYCLES    SET	SPARE-7
      2  61ee
      3  61ee				  -	      IF	.CYCLES < 2
      4  61ee				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  61ee				  -	      ERR
      6  61ee					      ENDIF
      7  61ee
      8  61ee				  -	      IF	.CYCLES & 1
      9  61ee				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  61ee				  -	      nop	0
     11  61ee				  -	      ELSE
     12  61ee				  -	      bit	VSYNC
     13  61ee				  -	      ENDIF
     14  61ee				  -.CYCLES    SET	.CYCLES - 3
     15  61ee					      ENDIF
     16  61ee
     17  61ee					      REPEAT	.CYCLES / 2
     18  61ee		       ea		      nop
     17  61ee					      REPEND
     18  61ef		       ea		      nop
     17  61ef					      REPEND
     18  61f0		       ea		      nop
     17  61f0					      REPEND
     18  61f1		       ea		      nop
     19  61f2					      REPEND
    317  61f2					      ENDIF
    318  61f2
    319  61f2
    320  61f2				   .LOOP      SET	.LOOP + 1
    321  61f2					      REPEND
    322  61f2		       88		      dey		; 2
    323  61f3		       30 03		      bmi	ess	; 2/3
    324  61f5		       4c 7b f1 	      jmp	LevelNumberDigits	; 3 = 7 mostly @ 71
    325  61f8				   ess
    326  61f8
    327  61f8							; now a bottom for the 'box'
    328  61f8
    329  61f8		       a9 00		      lda	#0
    330  61fa		       85 4d		      sta	PF0
    331  61fc		       85 4e		      sta	PF1
    332  61fe		       85 4f		      sta	PF2
    333  6200
    334  6200		       85 42		      sta	WSYNC
    335  6202		       85 42		      sta	WSYNC
    336  6204		       85 42		      sta	WSYNC
    337  6206
    338  6206
    339  6206
    340  6206
    341  6206							;		  lda #WALLCOLOUR
    342  6206							;		  sta COLUPF
    343  6206
    344  6206		       a9 f0		      lda	#WALLCOLOUR
    345  6208		       85 48		      sta	COLUPF
    346  620a
    347  620a		       a0 08		      ldy	#8
    348  620c		       85 42	   boxbottom  sta	WSYNC	;@0
    349  620e		       b9 1f f4 	      lda	lidb0,y	;#%11100000
    350  6211		       29 c0		      and	#%11000000
    351  6213		       85 4d		      sta	PF0
    352  6215		       b9 1f f4 	      lda	lidb1,y	;#255
    353  6218		       85 4e		      sta	PF1
    354  621a		       b9 1f f4 	      lda	lidb2,y	;#255
    355  621d		       85 4f		      sta	PF2	; 3 = 8 @ 19
    356  621f
    357  621f							; RHS
    358  621f		       b9 1f f4 	      lda	lidb3,y
    359  6222		       85 4d		      sta	PF0	; 3 = 8 @ 27 OK	D7D6D5D4 <--- mirrored
    360  6224
      0  6224					      SLEEP	8
      1  6224				   .CYCLES    SET	8
      2  6224
      3  6224				  -	      IF	.CYCLES < 2
      4  6224				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  6224				  -	      ERR
      6  6224					      ENDIF
      7  6224
      8  6224				  -	      IF	.CYCLES & 1
      9  6224				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  6224				  -	      nop	0
     11  6224				  -	      ELSE
     12  6224				  -	      bit	VSYNC
     13  6224				  -	      ENDIF
     14  6224				  -.CYCLES    SET	.CYCLES - 3
     15  6224					      ENDIF
     16  6224
     17  6224					      REPEAT	.CYCLES / 2
     18  6224		       ea		      nop
     17  6224					      REPEND
     18  6225		       ea		      nop
     17  6225					      REPEND
     18  6226		       ea		      nop
     17  6226					      REPEND
     18  6227		       ea		      nop
     19  6228					      REPEND
    362  6228		       b9 1f f4 	      lda	lidb4,y
    363  622b		       85 4e		      sta	PF1	; 3 @40		 NOT MIRRORED, D7D6D5D4 -->
    364  622d
    365  622d		       a9 00		      lda	#%00000000
    366  622f							;		  nop
    367  622f		       85 4f		      sta	PF2	; 3 = 8 @48
    368  6231
    369  6231		       a9 04		      lda	#4
    370  6233		       85 49		      sta	COLUBK
    371  6235
    372  6235
    373  6235		       88		      dey		; 2
    374  6236		       10 d4		      bpl	boxbottom
    375  6238
    376  6238
    377  6238		       a9 00		      lda	#0
    378  623a		       85 4d		      sta	PF0
    379  623c		       85 4e		      sta	PF1
    380  623e		       85 4f		      sta	PF2
    381  6240		       85 5b		      sta	GRP0
    382  6242		       85 5c		      sta	GRP1
    383  6244
    384  6244							;--------------------------------------------------------------------------
    385  6244
    386  6244
    387  6244		       a5 e2		      lda	initialdelay
    388  6246		       f0 05		      beq	canchange
    389  6248		       c6 e2		      dec	initialdelay
    390  624a		       4c b2 f2 	      jmp	nodigchange
    391  624d
    392  624d				   canchange
    393  624d		       e6 de		      inc	digitick
    394  624f		       a5 de		      lda	digitick
    395  6251		       c9 08		      cmp	#8
    396  6253		       90 5d		      bcc	nodigchange
    397  6255		       a9 00		      lda	#0
    398  6257		       85 de		      sta	digitick
    399  6259
    400  6259
    401  6259
    402  6259		       a2 02		      ldx	#2
    403  625b		       b5 db	   scanner    lda	digit,x
    404  625d		       d5 df		      cmp	targetDigit,x
    405  625f		       f0 12		      beq	scanOK
    406  6261
    407  6261		       18		      clc
    408  6262		       69 01		      adc	#1
    409  6264		       c9 0a		      cmp	#10
    410  6266		       90 02		      bcc	scanOK2
    411  6268		       a9 00		      lda	#0
    412  626a		       95 db	   scanOK2    sta	digit,x
    413  626c
    414  626c		       a9 7d		      lda	#125
    415  626e		       85 e3		      sta	endwait
    416  6270
    417  6270		       4c b2 f2 	      jmp	donedig
    418  6273
    419  6273		       ca	   scanOK     dex
    420  6274		       10 e5		      bpl	scanner
    421  6276
    422  6276		       a5 e7		      lda	selector
    423  6278		       f0 38		      beq	nodigchange	; don't allow joystick selection
    424  627a
    425  627a		       a9 ff		      lda	#-1
    426  627c		       85 df		      sta	targetDigit
    427  627e		       85 e0		      sta	targetDigit+1
    428  6280		       85 e1		      sta	targetDigit+2
    429  6282
    430  6282		       ad 80 02 	      lda	SWCHA
    431  6285		       4a		      lsr
    432  6286		       4a		      lsr
    433  6287		       4a		      lsr
    434  6288		       4a		      lsr
    435  6289		       aa		      tax
    436  628a
    437  628a		       bd 7f f3 	      lda	xJoyMoveX,x
    438  628d		       f0 03		      beq	adjustLevelNum
    439  628f
    440  628f							; level is changing, so animate the man too
    441  628f
    442  628f		       20 ee f2 	      jsr	fixWalkFrame
    443  6292
    444  6292
    445  6292		       18	   adjustLevelNum clc
    446  6293		       a5 b2		      lda	levelX
    447  6295		       7d 7f f3 	      adc	xJoyMoveX,x
    448  6298		       c9 ff		      cmp	#255
    449  629a		       d0 02		      bne	nml1
    450  629c		       a9 98		      lda	#MAX_LEVEL-1
    451  629e		       c9 99	   nml1       cmp	#MAX_LEVEL
    452  62a0		       d0 02		      bne	nml2
    453  62a2		       a9 00		      lda	#0
    454  62a4				   nml2
    455  62a4
    456  62a4		       85 b2		      sta	levelX
    457  62a6		       20 d5 f2 	      jsr	dd3
    458  62a9
    459  62a9		       a2 02		      ldx	#2
    460  62ab		       b5 df	   zapper     lda	targetDigit,x
    461  62ad		       95 db		      sta	digit,x
    462  62af		       ca		      dex
    463  62b0		       10 f9		      bpl	zapper
    464  62b2
    465  62b2				   nohitd2
    466  62b2				   nojoy
    467  62b2				   donedig
    468  62b2
    469  62b2
    470  62b2				   digok
    471  62b2				   nodigchange
    472  62b2
    473  62b2		       a5 e3		      lda	endwait
    474  62b4		       30 02		      bmi	neverend
    475  62b6
    476  62b6		       c6 e3		      dec	endwait
    477  62b8							;beq retX
    478  62b8
    479  62b8				   neverend
    480  62b8		       a5 e7		      lda	selector
    481  62ba		       d0 04		      bne	waitbutton
    482  62bc		       a5 e3		      lda	endwait
    483  62be		       f0 10		      beq	retX
    484  62c0
    485  62c0
    486  62c0		       a5 4c	   waitbutton lda	INPT4
    487  62c2		       10 0c		      bpl	retX
    488  62c4
    489  62c4				   oscanX
    490  62c4		       ad 84 02 	      lda	INTIM
    491  62c7		       d0 fb		      bne	oscanX
    492  62c9
    493  62c9		       a9 42		      lda	#%01000010	; bit6 is not required
    494  62cb		       85 41		      sta	VBLANK	; end of screen - enter blanking
    495  62cd
    496  62cd
    497  62cd		       4c 92 f0 	      jmp	RestartFrameX
    498  62d0
    499  62d0		       a9 00	   retX       lda	#0
    500  62d2		       85 49		      sta	COLUBK
    501  62d4		       60		      rts
    502  62d5
    503  62d5
    504  62d5
    505  62d5				   dd3
    506  62d5		       18		      clc
    507  62d6		       a5 b2		      lda	levelX
    508  62d8		       69 01		      adc	#1
    509  62da		       38		      sec
    510  62db		       e9 64	   m100       sbc	#100
    511  62dd		       e6 e1		      inc	targetDigit+2
    512  62df		       b0 fa		      bcs	m100
    513  62e1		       69 64		      adc	#100
    514  62e3		       e9 0a	   m10	      sbc	#10
    515  62e5		       e6 e0		      inc	targetDigit+1
    516  62e7		       b0 fa		      bcs	m10
    517  62e9		       69 0a		      adc	#10
    518  62eb		       85 df		      sta	targetDigit
    519  62ed
    520  62ed
    521  62ed							; leading zero removal
    522  62ed							;lda targetDigit+2
    523  62ed							;bne hunds
    524  62ed							;lda #10
    525  62ed							;sta targetDigit+2
    526  62ed							;sta digit+2		  ; hide hundreds if 0
    527  62ed				   hunds
    528  62ed
    529  62ed		       60		      rts
    530  62ee
    531  62ee
      0  62ee					      DEFINE_SUBROUTINE	fixWalkFrame
      1  62ee		       00 0c	   BANK_fixWalkFrame =	_CURRENT_BANK
      2  62ee					      SUBROUTINE
      3  62ee				   fixWalkFrame
    533  62ee
    534  62ee
    535  62ee		       a5 e7		      lda	selector
    536  62f0		       f0 16		      beq	walk0
    537  62f2
    538  62f2		       18		      clc
    539  62f3		       a5 e8		      lda	walkSpeed
    540  62f5		       69 04		      adc	#4
    541  62f7		       c9 0c		      cmp	#4*3
    542  62f9		       90 02		      bcc	walkFrameOK
    543  62fb		       a9 00		      lda	#0
    544  62fd		       85 e8	   walkFrameOK sta	walkSpeed
    545  62ff
    546  62ff		       4a		      lsr
    547  6300		       4a		      lsr
    548  6301		       29 03		      and	#%11
    549  6303		       a8		      tay
    550  6304		       b9 3c f3 	      lda	walkOrder,y
    551  6307		       0a		      asl
    552  6308		       a8	   walk0      tay
    553  6309		       b9 40 f3 	      lda	walkFrame,y
    554  630c		       85 d9		      sta	digitstar
    555  630e		       b9 41 f3 	      lda	walkFrame+1,y
    556  6311		       85 da		      sta	digitstar+1
    557  6313
    558  6313
    559  6313		       b9 48 f3 	      lda	walkColour,y
    560  6316		       85 e9		      sta	manc
    561  6318		       b9 49 f3 	      lda	walkColour+1,y
    562  631b		       85 ea		      sta	manc+1
    563  631d		       60		      rts
    564  631e
    565  631e
    566  631e
    567  631e
    568  631e				   colbk
    569  631e
    570  631e				   .CRK       SET	256*$B2
    571  631e				   .CGK       SET	256*$B2
    572  631e				   .CBK       SET	256*$B2
    573  631e
    574  631e					      REPEAT	10
    575  631e		       b2		      .byte.b	.CRK/256
    576  631f		       b2		      .byte.b	.CBK/256
    577  6320		       b2		      .byte.b	.CGK/256
    578  6321
    579  6321				   .CRK       SET	.CRK + 180	;135
    580  6321				   .CGK       SET	.CGK + 190	;135
    581  6321				   .CBK       SET	.CBK + 200	;135
    574  6321					      REPEND
    575  6321		       b2		      .byte.b	.CRK/256
    576  6322		       b2		      .byte.b	.CBK/256
    577  6323		       b2		      .byte.b	.CGK/256
    578  6324
    579  6324				   .CRK       SET	.CRK + 180	;135
    580  6324				   .CGK       SET	.CGK + 190	;135
    581  6324				   .CBK       SET	.CBK + 200	;135
    574  6324					      REPEND
    575  6324		       b3		      .byte.b	.CRK/256
    576  6325		       b3		      .byte.b	.CBK/256
    577  6326		       b3		      .byte.b	.CGK/256
    578  6327
    579  6327				   .CRK       SET	.CRK + 180	;135
    580  6327				   .CGK       SET	.CGK + 190	;135
    581  6327				   .CBK       SET	.CBK + 200	;135
    574  6327					      REPEND
    575  6327		       b4		      .byte.b	.CRK/256
    576  6328		       b4		      .byte.b	.CBK/256
    577  6329		       b4		      .byte.b	.CGK/256
    578  632a
    579  632a				   .CRK       SET	.CRK + 180	;135
    580  632a				   .CGK       SET	.CGK + 190	;135
    581  632a				   .CBK       SET	.CBK + 200	;135
    574  632a					      REPEND
    575  632a		       b4		      .byte.b	.CRK/256
    576  632b		       b5		      .byte.b	.CBK/256
    577  632c		       b4		      .byte.b	.CGK/256
    578  632d
    579  632d				   .CRK       SET	.CRK + 180	;135
    580  632d				   .CGK       SET	.CGK + 190	;135
    581  632d				   .CBK       SET	.CBK + 200	;135
    574  632d					      REPEND
    575  632d		       b5		      .byte.b	.CRK/256
    576  632e		       b5		      .byte.b	.CBK/256
    577  632f		       b5		      .byte.b	.CGK/256
    578  6330
    579  6330				   .CRK       SET	.CRK + 180	;135
    580  6330				   .CGK       SET	.CGK + 190	;135
    581  6330				   .CBK       SET	.CBK + 200	;135
    574  6330					      REPEND
    575  6330		       b6		      .byte.b	.CRK/256
    576  6331		       b6		      .byte.b	.CBK/256
    577  6332		       b6		      .byte.b	.CGK/256
    578  6333
    579  6333				   .CRK       SET	.CRK + 180	;135
    580  6333				   .CGK       SET	.CGK + 190	;135
    581  6333				   .CBK       SET	.CBK + 200	;135
    574  6333					      REPEND
    575  6333		       b6		      .byte.b	.CRK/256
    576  6334		       b7		      .byte.b	.CBK/256
    577  6335		       b7		      .byte.b	.CGK/256
    578  6336
    579  6336				   .CRK       SET	.CRK + 180	;135
    580  6336				   .CGK       SET	.CGK + 190	;135
    581  6336				   .CBK       SET	.CBK + 200	;135
    574  6336					      REPEND
    575  6336		       b7		      .byte.b	.CRK/256
    576  6337		       b8		      .byte.b	.CBK/256
    577  6338		       b7		      .byte.b	.CGK/256
    578  6339
    579  6339				   .CRK       SET	.CRK + 180	;135
    580  6339				   .CGK       SET	.CGK + 190	;135
    581  6339				   .CBK       SET	.CBK + 200	;135
    574  6339					      REPEND
    575  6339		       b8		      .byte.b	.CRK/256
    576  633a		       b9		      .byte.b	.CBK/256
    577  633b		       b8		      .byte.b	.CGK/256
    578  633c
    579  633c				   .CRK       SET	.CRK + 180	;135
    580  633c				   .CGK       SET	.CGK + 190	;135
    581  633c				   .CBK       SET	.CBK + 200	;135
    582  633c					      REPEND
    583  633c
    584  633c		       01 02 03 02 walkOrder  .byte.b	1,2,3,2
    585  6340				   walkFrame
    586  6340		       6c f7		      .word.w	LEFT_star0
    587  6342		       87 f7		      .word.w	LEFT_star1
    588  6344		       a2 f7		      .word.w	LEFT_star2
    589  6346		       bd f7		      .word.w	LEFT_star3
    590  6348
    591  6348				   walkColour
    592  6348		       67 f3		      .word.w	mancolourPAL2
    593  634a		       50 f3		      .word.w	mancolourPAL
    594  634c		       67 f3		      .word.w	mancolourPAL2
    595  634e		       50 f3		      .word.w	mancolourPAL
    596  6350
    597  6350
    598  6350				   mancolourPAL
    599  6350							; NTSC_TO_PAL $10, 4
      0  6350					      NTSC_TO_PAL	$10, 4
      1  6350				  -	      IF	$10 = 0
      2  6350				  -	      .byte	$10+4
      3  6350					      ENDIF
      4  6350					      IF	$10 = $10
      5  6350		       24		      .byte.b	$20+4
      6  6351					      ENDIF
      7  6351				  -	      IF	$10 = $20
      8  6351				  -	      .byte	$40+4
      9  6351					      ENDIF
     10  6351				  -	      IF	$10 = $30
     11  6351				  -	      .byte	$40+4
     12  6351					      ENDIF
     13  6351				  -	      IF	$10 = $40
     14  6351				  -	      .byte	$60+4
     15  6351					      ENDIF
     16  6351				  -	      IF	$10 = $50
     17  6351				  -	      .byte	$80+4
     18  6351					      ENDIF
     19  6351				  -	      IF	$10 = $60
     20  6351				  -	      .byte	$C0+4
     21  6351					      ENDIF
     22  6351				  -	      IF	$10 = $70
     23  6351				  -	      .byte	$D0+4
     24  6351					      ENDIF
     25  6351				  -	      IF	$10 = $80
     26  6351				  -	      .byte	$B0+4
     27  6351					      ENDIF
     28  6351				  -	      IF	$10 = $90
     29  6351				  -	      .byte	$90+4
     30  6351					      ENDIF
     31  6351				  -	      IF	$10 = $A0
     32  6351				  -	      .byte	$70+4
     33  6351					      ENDIF
     34  6351				  -	      IF	$10 = $B0
     35  6351				  -	      .byte	$50+4
     36  6351					      ENDIF
     37  6351				  -	      IF	$10 = $C0
     38  6351				  -	      .byte	$30+4
     39  6351					      ENDIF
     40  6351				  -	      IF	$10 = $D0
     41  6351				  -	      .byte	$30+4
     42  6351					      ENDIF
     43  6351				  -	      IF	$10 = $E0
     44  6351				  -	      .byte	$20+4
     45  6351					      ENDIF
     46  6351				  -	      IF	$10 = $F0
     47  6351				  -	      .byte	$40+4
     48  6351					      ENDIF
      0  6351					      NTSC_TO_PAL	$30, 4
      1  6351				  -	      IF	$30 = 0
      2  6351				  -	      .byte	$30+4
      3  6351					      ENDIF
      4  6351				  -	      IF	$30 = $10
      5  6351				  -	      .byte	$20+4
      6  6351					      ENDIF
      7  6351				  -	      IF	$30 = $20
      8  6351				  -	      .byte	$40+4
      9  6351					      ENDIF
     10  6351					      IF	$30 = $30
     11  6351		       44		      .byte.b	$40+4
     12  6352					      ENDIF
     13  6352				  -	      IF	$30 = $40
     14  6352				  -	      .byte	$60+4
     15  6352					      ENDIF
     16  6352				  -	      IF	$30 = $50
     17  6352				  -	      .byte	$80+4
     18  6352					      ENDIF
     19  6352				  -	      IF	$30 = $60
     20  6352				  -	      .byte	$C0+4
     21  6352					      ENDIF
     22  6352				  -	      IF	$30 = $70
     23  6352				  -	      .byte	$D0+4
     24  6352					      ENDIF
     25  6352				  -	      IF	$30 = $80
     26  6352				  -	      .byte	$B0+4
     27  6352					      ENDIF
     28  6352				  -	      IF	$30 = $90
     29  6352				  -	      .byte	$90+4
     30  6352					      ENDIF
     31  6352				  -	      IF	$30 = $A0
     32  6352				  -	      .byte	$70+4
     33  6352					      ENDIF
     34  6352				  -	      IF	$30 = $B0
     35  6352				  -	      .byte	$50+4
     36  6352					      ENDIF
     37  6352				  -	      IF	$30 = $C0
     38  6352				  -	      .byte	$30+4
     39  6352					      ENDIF
     40  6352				  -	      IF	$30 = $D0
     41  6352				  -	      .byte	$30+4
     42  6352					      ENDIF
     43  6352				  -	      IF	$30 = $E0
     44  6352				  -	      .byte	$20+4
     45  6352					      ENDIF
     46  6352				  -	      IF	$30 = $F0
     47  6352				  -	      .byte	$40+4
     48  6352					      ENDIF
      0  6352					      NTSC_TO_PAL	$30, 4
      1  6352				  -	      IF	$30 = 0
      2  6352				  -	      .byte	$30+4
      3  6352					      ENDIF
      4  6352				  -	      IF	$30 = $10
      5  6352				  -	      .byte	$20+4
      6  6352					      ENDIF
      7  6352				  -	      IF	$30 = $20
      8  6352				  -	      .byte	$40+4
      9  6352					      ENDIF
     10  6352					      IF	$30 = $30
     11  6352		       44		      .byte.b	$40+4
     12  6353					      ENDIF
     13  6353				  -	      IF	$30 = $40
     14  6353				  -	      .byte	$60+4
     15  6353					      ENDIF
     16  6353				  -	      IF	$30 = $50
     17  6353				  -	      .byte	$80+4
     18  6353					      ENDIF
     19  6353				  -	      IF	$30 = $60
     20  6353				  -	      .byte	$C0+4
     21  6353					      ENDIF
     22  6353				  -	      IF	$30 = $70
     23  6353				  -	      .byte	$D0+4
     24  6353					      ENDIF
     25  6353				  -	      IF	$30 = $80
     26  6353				  -	      .byte	$B0+4
     27  6353					      ENDIF
     28  6353				  -	      IF	$30 = $90
     29  6353				  -	      .byte	$90+4
     30  6353					      ENDIF
     31  6353				  -	      IF	$30 = $A0
     32  6353				  -	      .byte	$70+4
     33  6353					      ENDIF
     34  6353				  -	      IF	$30 = $B0
     35  6353				  -	      .byte	$50+4
     36  6353					      ENDIF
     37  6353				  -	      IF	$30 = $C0
     38  6353				  -	      .byte	$30+4
     39  6353					      ENDIF
     40  6353				  -	      IF	$30 = $D0
     41  6353				  -	      .byte	$30+4
     42  6353					      ENDIF
     43  6353				  -	      IF	$30 = $E0
     44  6353				  -	      .byte	$20+4
     45  6353					      ENDIF
     46  6353				  -	      IF	$30 = $F0
     47  6353				  -	      .byte	$40+4
     48  6353					      ENDIF
      0  6353					      NTSC_TO_PAL	$30, 4
      1  6353				  -	      IF	$30 = 0
      2  6353				  -	      .byte	$30+4
      3  6353					      ENDIF
      4  6353				  -	      IF	$30 = $10
      5  6353				  -	      .byte	$20+4
      6  6353					      ENDIF
      7  6353				  -	      IF	$30 = $20
      8  6353				  -	      .byte	$40+4
      9  6353					      ENDIF
     10  6353					      IF	$30 = $30
     11  6353		       44		      .byte.b	$40+4
     12  6354					      ENDIF
     13  6354				  -	      IF	$30 = $40
     14  6354				  -	      .byte	$60+4
     15  6354					      ENDIF
     16  6354				  -	      IF	$30 = $50
     17  6354				  -	      .byte	$80+4
     18  6354					      ENDIF
     19  6354				  -	      IF	$30 = $60
     20  6354				  -	      .byte	$C0+4
     21  6354					      ENDIF
     22  6354				  -	      IF	$30 = $70
     23  6354				  -	      .byte	$D0+4
     24  6354					      ENDIF
     25  6354				  -	      IF	$30 = $80
     26  6354				  -	      .byte	$B0+4
     27  6354					      ENDIF
     28  6354				  -	      IF	$30 = $90
     29  6354				  -	      .byte	$90+4
     30  6354					      ENDIF
     31  6354				  -	      IF	$30 = $A0
     32  6354				  -	      .byte	$70+4
     33  6354					      ENDIF
     34  6354				  -	      IF	$30 = $B0
     35  6354				  -	      .byte	$50+4
     36  6354					      ENDIF
     37  6354				  -	      IF	$30 = $C0
     38  6354				  -	      .byte	$30+4
     39  6354					      ENDIF
     40  6354				  -	      IF	$30 = $D0
     41  6354				  -	      .byte	$30+4
     42  6354					      ENDIF
     43  6354				  -	      IF	$30 = $E0
     44  6354				  -	      .byte	$20+4
     45  6354					      ENDIF
     46  6354				  -	      IF	$30 = $F0
     47  6354				  -	      .byte	$40+4
     48  6354					      ENDIF
      0  6354					      NTSC_TO_PAL	$30, 4
      1  6354				  -	      IF	$30 = 0
      2  6354				  -	      .byte	$30+4
      3  6354					      ENDIF
      4  6354				  -	      IF	$30 = $10
      5  6354				  -	      .byte	$20+4
      6  6354					      ENDIF
      7  6354				  -	      IF	$30 = $20
      8  6354				  -	      .byte	$40+4
      9  6354					      ENDIF
     10  6354					      IF	$30 = $30
     11  6354		       44		      .byte.b	$40+4
     12  6355					      ENDIF
     13  6355				  -	      IF	$30 = $40
     14  6355				  -	      .byte	$60+4
     15  6355					      ENDIF
     16  6355				  -	      IF	$30 = $50
     17  6355				  -	      .byte	$80+4
     18  6355					      ENDIF
     19  6355				  -	      IF	$30 = $60
     20  6355				  -	      .byte	$C0+4
     21  6355					      ENDIF
     22  6355				  -	      IF	$30 = $70
     23  6355				  -	      .byte	$D0+4
     24  6355					      ENDIF
     25  6355				  -	      IF	$30 = $80
     26  6355				  -	      .byte	$B0+4
     27  6355					      ENDIF
     28  6355				  -	      IF	$30 = $90
     29  6355				  -	      .byte	$90+4
     30  6355					      ENDIF
     31  6355				  -	      IF	$30 = $A0
     32  6355				  -	      .byte	$70+4
     33  6355					      ENDIF
     34  6355				  -	      IF	$30 = $B0
     35  6355				  -	      .byte	$50+4
     36  6355					      ENDIF
     37  6355				  -	      IF	$30 = $C0
     38  6355				  -	      .byte	$30+4
     39  6355					      ENDIF
     40  6355				  -	      IF	$30 = $D0
     41  6355				  -	      .byte	$30+4
     42  6355					      ENDIF
     43  6355				  -	      IF	$30 = $E0
     44  6355				  -	      .byte	$20+4
     45  6355					      ENDIF
     46  6355				  -	      IF	$30 = $F0
     47  6355				  -	      .byte	$40+4
     48  6355					      ENDIF
      0  6355					      NTSC_TO_PAL	$30, 4
      1  6355				  -	      IF	$30 = 0
      2  6355				  -	      .byte	$30+4
      3  6355					      ENDIF
      4  6355				  -	      IF	$30 = $10
      5  6355				  -	      .byte	$20+4
      6  6355					      ENDIF
      7  6355				  -	      IF	$30 = $20
      8  6355				  -	      .byte	$40+4
      9  6355					      ENDIF
     10  6355					      IF	$30 = $30
     11  6355		       44		      .byte.b	$40+4
     12  6356					      ENDIF
     13  6356				  -	      IF	$30 = $40
     14  6356				  -	      .byte	$60+4
     15  6356					      ENDIF
     16  6356				  -	      IF	$30 = $50
     17  6356				  -	      .byte	$80+4
     18  6356					      ENDIF
     19  6356				  -	      IF	$30 = $60
     20  6356				  -	      .byte	$C0+4
     21  6356					      ENDIF
     22  6356				  -	      IF	$30 = $70
     23  6356				  -	      .byte	$D0+4
     24  6356					      ENDIF
     25  6356				  -	      IF	$30 = $80
     26  6356				  -	      .byte	$B0+4
     27  6356					      ENDIF
     28  6356				  -	      IF	$30 = $90
     29  6356				  -	      .byte	$90+4
     30  6356					      ENDIF
     31  6356				  -	      IF	$30 = $A0
     32  6356				  -	      .byte	$70+4
     33  6356					      ENDIF
     34  6356				  -	      IF	$30 = $B0
     35  6356				  -	      .byte	$50+4
     36  6356					      ENDIF
     37  6356				  -	      IF	$30 = $C0
     38  6356				  -	      .byte	$30+4
     39  6356					      ENDIF
     40  6356				  -	      IF	$30 = $D0
     41  6356				  -	      .byte	$30+4
     42  6356					      ENDIF
     43  6356				  -	      IF	$30 = $E0
     44  6356				  -	      .byte	$20+4
     45  6356					      ENDIF
     46  6356				  -	      IF	$30 = $F0
     47  6356				  -	      .byte	$40+4
     48  6356					      ENDIF
      0  6356					      NTSC_TO_PAL	$30, 4
      1  6356				  -	      IF	$30 = 0
      2  6356				  -	      .byte	$30+4
      3  6356					      ENDIF
      4  6356				  -	      IF	$30 = $10
      5  6356				  -	      .byte	$20+4
      6  6356					      ENDIF
      7  6356				  -	      IF	$30 = $20
      8  6356				  -	      .byte	$40+4
      9  6356					      ENDIF
     10  6356					      IF	$30 = $30
     11  6356		       44		      .byte.b	$40+4
     12  6357					      ENDIF
     13  6357				  -	      IF	$30 = $40
     14  6357				  -	      .byte	$60+4
     15  6357					      ENDIF
     16  6357				  -	      IF	$30 = $50
     17  6357				  -	      .byte	$80+4
     18  6357					      ENDIF
     19  6357				  -	      IF	$30 = $60
     20  6357				  -	      .byte	$C0+4
     21  6357					      ENDIF
     22  6357				  -	      IF	$30 = $70
     23  6357				  -	      .byte	$D0+4
     24  6357					      ENDIF
     25  6357				  -	      IF	$30 = $80
     26  6357				  -	      .byte	$B0+4
     27  6357					      ENDIF
     28  6357				  -	      IF	$30 = $90
     29  6357				  -	      .byte	$90+4
     30  6357					      ENDIF
     31  6357				  -	      IF	$30 = $A0
     32  6357				  -	      .byte	$70+4
     33  6357					      ENDIF
     34  6357				  -	      IF	$30 = $B0
     35  6357				  -	      .byte	$50+4
     36  6357					      ENDIF
     37  6357				  -	      IF	$30 = $C0
     38  6357				  -	      .byte	$30+4
     39  6357					      ENDIF
     40  6357				  -	      IF	$30 = $D0
     41  6357				  -	      .byte	$30+4
     42  6357					      ENDIF
     43  6357				  -	      IF	$30 = $E0
     44  6357				  -	      .byte	$20+4
     45  6357					      ENDIF
     46  6357				  -	      IF	$30 = $F0
     47  6357				  -	      .byte	$40+4
     48  6357					      ENDIF
      0  6357					      NTSC_TO_PAL	$30, 4
      1  6357				  -	      IF	$30 = 0
      2  6357				  -	      .byte	$30+4
      3  6357					      ENDIF
      4  6357				  -	      IF	$30 = $10
      5  6357				  -	      .byte	$20+4
      6  6357					      ENDIF
      7  6357				  -	      IF	$30 = $20
      8  6357				  -	      .byte	$40+4
      9  6357					      ENDIF
     10  6357					      IF	$30 = $30
     11  6357		       44		      .byte.b	$40+4
     12  6358					      ENDIF
     13  6358				  -	      IF	$30 = $40
     14  6358				  -	      .byte	$60+4
     15  6358					      ENDIF
     16  6358				  -	      IF	$30 = $50
     17  6358				  -	      .byte	$80+4
     18  6358					      ENDIF
     19  6358				  -	      IF	$30 = $60
     20  6358				  -	      .byte	$C0+4
     21  6358					      ENDIF
     22  6358				  -	      IF	$30 = $70
     23  6358				  -	      .byte	$D0+4
     24  6358					      ENDIF
     25  6358				  -	      IF	$30 = $80
     26  6358				  -	      .byte	$B0+4
     27  6358					      ENDIF
     28  6358				  -	      IF	$30 = $90
     29  6358				  -	      .byte	$90+4
     30  6358					      ENDIF
     31  6358				  -	      IF	$30 = $A0
     32  6358				  -	      .byte	$70+4
     33  6358					      ENDIF
     34  6358				  -	      IF	$30 = $B0
     35  6358				  -	      .byte	$50+4
     36  6358					      ENDIF
     37  6358				  -	      IF	$30 = $C0
     38  6358				  -	      .byte	$30+4
     39  6358					      ENDIF
     40  6358				  -	      IF	$30 = $D0
     41  6358				  -	      .byte	$30+4
     42  6358					      ENDIF
     43  6358				  -	      IF	$30 = $E0
     44  6358				  -	      .byte	$20+4
     45  6358					      ENDIF
     46  6358				  -	      IF	$30 = $F0
     47  6358				  -	      .byte	$40+4
     48  6358					      ENDIF
      0  6358					      NTSC_TO_PAL	$0, 10
      1  6358					      IF	$0 = 0
      2  6358		       0a		      .byte.b	$0+10
      3  6359					      ENDIF
      4  6359				  -	      IF	$0 = $10
      5  6359				  -	      .byte	$20+10
      6  6359					      ENDIF
      7  6359				  -	      IF	$0 = $20
      8  6359				  -	      .byte	$40+10
      9  6359					      ENDIF
     10  6359				  -	      IF	$0 = $30
     11  6359				  -	      .byte	$40+10
     12  6359					      ENDIF
     13  6359				  -	      IF	$0 = $40
     14  6359				  -	      .byte	$60+10
     15  6359					      ENDIF
     16  6359				  -	      IF	$0 = $50
     17  6359				  -	      .byte	$80+10
     18  6359					      ENDIF
     19  6359				  -	      IF	$0 = $60
     20  6359				  -	      .byte	$C0+10
     21  6359					      ENDIF
     22  6359				  -	      IF	$0 = $70
     23  6359				  -	      .byte	$D0+10
     24  6359					      ENDIF
     25  6359				  -	      IF	$0 = $80
     26  6359				  -	      .byte	$B0+10
     27  6359					      ENDIF
     28  6359				  -	      IF	$0 = $90
     29  6359				  -	      .byte	$90+10
     30  6359					      ENDIF
     31  6359				  -	      IF	$0 = $A0
     32  6359				  -	      .byte	$70+10
     33  6359					      ENDIF
     34  6359				  -	      IF	$0 = $B0
     35  6359				  -	      .byte	$50+10
     36  6359					      ENDIF
     37  6359				  -	      IF	$0 = $C0
     38  6359				  -	      .byte	$30+10
     39  6359					      ENDIF
     40  6359				  -	      IF	$0 = $D0
     41  6359				  -	      .byte	$30+10
     42  6359					      ENDIF
     43  6359				  -	      IF	$0 = $E0
     44  6359				  -	      .byte	$20+10
     45  6359					      ENDIF
     46  6359				  -	      IF	$0 = $F0
     47  6359				  -	      .byte	$40+10
     48  6359					      ENDIF
      0  6359					      NTSC_TO_PAL	$90, $a
      1  6359				  -	      IF	$90 = 0
      2  6359				  -	      .byte	$90+$a
      3  6359					      ENDIF
      4  6359				  -	      IF	$90 = $10
      5  6359				  -	      .byte	$20+$a
      6  6359					      ENDIF
      7  6359				  -	      IF	$90 = $20
      8  6359				  -	      .byte	$40+$a
      9  6359					      ENDIF
     10  6359				  -	      IF	$90 = $30
     11  6359				  -	      .byte	$40+$a
     12  6359					      ENDIF
     13  6359				  -	      IF	$90 = $40
     14  6359				  -	      .byte	$60+$a
     15  6359					      ENDIF
     16  6359				  -	      IF	$90 = $50
     17  6359				  -	      .byte	$80+$a
     18  6359					      ENDIF
     19  6359				  -	      IF	$90 = $60
     20  6359				  -	      .byte	$C0+$a
     21  6359					      ENDIF
     22  6359				  -	      IF	$90 = $70
     23  6359				  -	      .byte	$D0+$a
     24  6359					      ENDIF
     25  6359				  -	      IF	$90 = $80
     26  6359				  -	      .byte	$B0+$a
     27  6359					      ENDIF
     28  6359					      IF	$90 = $90
     29  6359		       9a		      .byte.b	$90+$a
     30  635a					      ENDIF
     31  635a				  -	      IF	$90 = $A0
     32  635a				  -	      .byte	$70+$a
     33  635a					      ENDIF
     34  635a				  -	      IF	$90 = $B0
     35  635a				  -	      .byte	$50+$a
     36  635a					      ENDIF
     37  635a				  -	      IF	$90 = $C0
     38  635a				  -	      .byte	$30+$a
     39  635a					      ENDIF
     40  635a				  -	      IF	$90 = $D0
     41  635a				  -	      .byte	$30+$a
     42  635a					      ENDIF
     43  635a				  -	      IF	$90 = $E0
     44  635a				  -	      .byte	$20+$a
     45  635a					      ENDIF
     46  635a				  -	      IF	$90 = $F0
     47  635a				  -	      .byte	$40+$a
     48  635a					      ENDIF
      0  635a					      NTSC_TO_PAL	$90, 6
      1  635a				  -	      IF	$90 = 0
      2  635a				  -	      .byte	$90+6
      3  635a					      ENDIF
      4  635a				  -	      IF	$90 = $10
      5  635a				  -	      .byte	$20+6
      6  635a					      ENDIF
      7  635a				  -	      IF	$90 = $20
      8  635a				  -	      .byte	$40+6
      9  635a					      ENDIF
     10  635a				  -	      IF	$90 = $30
     11  635a				  -	      .byte	$40+6
     12  635a					      ENDIF
     13  635a				  -	      IF	$90 = $40
     14  635a				  -	      .byte	$60+6
     15  635a					      ENDIF
     16  635a				  -	      IF	$90 = $50
     17  635a				  -	      .byte	$80+6
     18  635a					      ENDIF
     19  635a				  -	      IF	$90 = $60
     20  635a				  -	      .byte	$C0+6
     21  635a					      ENDIF
     22  635a				  -	      IF	$90 = $70
     23  635a				  -	      .byte	$D0+6
     24  635a					      ENDIF
     25  635a				  -	      IF	$90 = $80
     26  635a				  -	      .byte	$B0+6
     27  635a					      ENDIF
     28  635a					      IF	$90 = $90
     29  635a		       96		      .byte.b	$90+6
     30  635b					      ENDIF
     31  635b				  -	      IF	$90 = $A0
     32  635b				  -	      .byte	$70+6
     33  635b					      ENDIF
     34  635b				  -	      IF	$90 = $B0
     35  635b				  -	      .byte	$50+6
     36  635b					      ENDIF
     37  635b				  -	      IF	$90 = $C0
     38  635b				  -	      .byte	$30+6
     39  635b					      ENDIF
     40  635b				  -	      IF	$90 = $D0
     41  635b				  -	      .byte	$30+6
     42  635b					      ENDIF
     43  635b				  -	      IF	$90 = $E0
     44  635b				  -	      .byte	$20+6
     45  635b					      ENDIF
     46  635b				  -	      IF	$90 = $F0
     47  635b				  -	      .byte	$40+6
     48  635b					      ENDIF
      0  635b					      NTSC_TO_PAL	$90, 6
      1  635b				  -	      IF	$90 = 0
      2  635b				  -	      .byte	$90+6
      3  635b					      ENDIF
      4  635b				  -	      IF	$90 = $10
      5  635b				  -	      .byte	$20+6
      6  635b					      ENDIF
      7  635b				  -	      IF	$90 = $20
      8  635b				  -	      .byte	$40+6
      9  635b					      ENDIF
     10  635b				  -	      IF	$90 = $30
     11  635b				  -	      .byte	$40+6
     12  635b					      ENDIF
     13  635b				  -	      IF	$90 = $40
     14  635b				  -	      .byte	$60+6
     15  635b					      ENDIF
     16  635b				  -	      IF	$90 = $50
     17  635b				  -	      .byte	$80+6
     18  635b					      ENDIF
     19  635b				  -	      IF	$90 = $60
     20  635b				  -	      .byte	$C0+6
     21  635b					      ENDIF
     22  635b				  -	      IF	$90 = $70
     23  635b				  -	      .byte	$D0+6
     24  635b					      ENDIF
     25  635b				  -	      IF	$90 = $80
     26  635b				  -	      .byte	$B0+6
     27  635b					      ENDIF
     28  635b					      IF	$90 = $90
     29  635b		       96		      .byte.b	$90+6
     30  635c					      ENDIF
     31  635c				  -	      IF	$90 = $A0
     32  635c				  -	      .byte	$70+6
     33  635c					      ENDIF
     34  635c				  -	      IF	$90 = $B0
     35  635c				  -	      .byte	$50+6
     36  635c					      ENDIF
     37  635c				  -	      IF	$90 = $C0
     38  635c				  -	      .byte	$30+6
     39  635c					      ENDIF
     40  635c				  -	      IF	$90 = $D0
     41  635c				  -	      .byte	$30+6
     42  635c					      ENDIF
     43  635c				  -	      IF	$90 = $E0
     44  635c				  -	      .byte	$20+6
     45  635c					      ENDIF
     46  635c				  -	      IF	$90 = $F0
     47  635c				  -	      .byte	$40+6
     48  635c					      ENDIF
      0  635c					      NTSC_TO_PAL	$90, 6
      1  635c				  -	      IF	$90 = 0
      2  635c				  -	      .byte	$90+6
      3  635c					      ENDIF
      4  635c				  -	      IF	$90 = $10
      5  635c				  -	      .byte	$20+6
      6  635c					      ENDIF
      7  635c				  -	      IF	$90 = $20
      8  635c				  -	      .byte	$40+6
      9  635c					      ENDIF
     10  635c				  -	      IF	$90 = $30
     11  635c				  -	      .byte	$40+6
     12  635c					      ENDIF
     13  635c				  -	      IF	$90 = $40
     14  635c				  -	      .byte	$60+6
     15  635c					      ENDIF
     16  635c				  -	      IF	$90 = $50
     17  635c				  -	      .byte	$80+6
     18  635c					      ENDIF
     19  635c				  -	      IF	$90 = $60
     20  635c				  -	      .byte	$C0+6
     21  635c					      ENDIF
     22  635c				  -	      IF	$90 = $70
     23  635c				  -	      .byte	$D0+6
     24  635c					      ENDIF
     25  635c				  -	      IF	$90 = $80
     26  635c				  -	      .byte	$B0+6
     27  635c					      ENDIF
     28  635c					      IF	$90 = $90
     29  635c		       96		      .byte.b	$90+6
     30  635d					      ENDIF
     31  635d				  -	      IF	$90 = $A0
     32  635d				  -	      .byte	$70+6
     33  635d					      ENDIF
     34  635d				  -	      IF	$90 = $B0
     35  635d				  -	      .byte	$50+6
     36  635d					      ENDIF
     37  635d				  -	      IF	$90 = $C0
     38  635d				  -	      .byte	$30+6
     39  635d					      ENDIF
     40  635d				  -	      IF	$90 = $D0
     41  635d				  -	      .byte	$30+6
     42  635d					      ENDIF
     43  635d				  -	      IF	$90 = $E0
     44  635d				  -	      .byte	$20+6
     45  635d					      ENDIF
     46  635d				  -	      IF	$90 = $F0
     47  635d				  -	      .byte	$40+6
     48  635d					      ENDIF
      0  635d					      NTSC_TO_PAL	$90, 6
      1  635d				  -	      IF	$90 = 0
      2  635d				  -	      .byte	$90+6
      3  635d					      ENDIF
      4  635d				  -	      IF	$90 = $10
      5  635d				  -	      .byte	$20+6
      6  635d					      ENDIF
      7  635d				  -	      IF	$90 = $20
      8  635d				  -	      .byte	$40+6
      9  635d					      ENDIF
     10  635d				  -	      IF	$90 = $30
     11  635d				  -	      .byte	$40+6
     12  635d					      ENDIF
     13  635d				  -	      IF	$90 = $40
     14  635d				  -	      .byte	$60+6
     15  635d					      ENDIF
     16  635d				  -	      IF	$90 = $50
     17  635d				  -	      .byte	$80+6
     18  635d					      ENDIF
     19  635d				  -	      IF	$90 = $60
     20  635d				  -	      .byte	$C0+6
     21  635d					      ENDIF
     22  635d				  -	      IF	$90 = $70
     23  635d				  -	      .byte	$D0+6
     24  635d					      ENDIF
     25  635d				  -	      IF	$90 = $80
     26  635d				  -	      .byte	$B0+6
     27  635d					      ENDIF
     28  635d					      IF	$90 = $90
     29  635d		       96		      .byte.b	$90+6
     30  635e					      ENDIF
     31  635e				  -	      IF	$90 = $A0
     32  635e				  -	      .byte	$70+6
     33  635e					      ENDIF
     34  635e				  -	      IF	$90 = $B0
     35  635e				  -	      .byte	$50+6
     36  635e					      ENDIF
     37  635e				  -	      IF	$90 = $C0
     38  635e				  -	      .byte	$30+6
     39  635e					      ENDIF
     40  635e				  -	      IF	$90 = $D0
     41  635e				  -	      .byte	$30+6
     42  635e					      ENDIF
     43  635e				  -	      IF	$90 = $E0
     44  635e				  -	      .byte	$20+6
     45  635e					      ENDIF
     46  635e				  -	      IF	$90 = $F0
     47  635e				  -	      .byte	$40+6
     48  635e					      ENDIF
      0  635e					      NTSC_TO_PAL	$0, 10
      1  635e					      IF	$0 = 0
      2  635e		       0a		      .byte.b	$0+10
      3  635f					      ENDIF
      4  635f				  -	      IF	$0 = $10
      5  635f				  -	      .byte	$20+10
      6  635f					      ENDIF
      7  635f				  -	      IF	$0 = $20
      8  635f				  -	      .byte	$40+10
      9  635f					      ENDIF
     10  635f				  -	      IF	$0 = $30
     11  635f				  -	      .byte	$40+10
     12  635f					      ENDIF
     13  635f				  -	      IF	$0 = $40
     14  635f				  -	      .byte	$60+10
     15  635f					      ENDIF
     16  635f				  -	      IF	$0 = $50
     17  635f				  -	      .byte	$80+10
     18  635f					      ENDIF
     19  635f				  -	      IF	$0 = $60
     20  635f				  -	      .byte	$C0+10
     21  635f					      ENDIF
     22  635f				  -	      IF	$0 = $70
     23  635f				  -	      .byte	$D0+10
     24  635f					      ENDIF
     25  635f				  -	      IF	$0 = $80
     26  635f				  -	      .byte	$B0+10
     27  635f					      ENDIF
     28  635f				  -	      IF	$0 = $90
     29  635f				  -	      .byte	$90+10
     30  635f					      ENDIF
     31  635f				  -	      IF	$0 = $A0
     32  635f				  -	      .byte	$70+10
     33  635f					      ENDIF
     34  635f				  -	      IF	$0 = $B0
     35  635f				  -	      .byte	$50+10
     36  635f					      ENDIF
     37  635f				  -	      IF	$0 = $C0
     38  635f				  -	      .byte	$30+10
     39  635f					      ENDIF
     40  635f				  -	      IF	$0 = $D0
     41  635f				  -	      .byte	$30+10
     42  635f					      ENDIF
     43  635f				  -	      IF	$0 = $E0
     44  635f				  -	      .byte	$20+10
     45  635f					      ENDIF
     46  635f				  -	      IF	$0 = $F0
     47  635f				  -	      .byte	$40+10
     48  635f					      ENDIF
      0  635f					      NTSC_TO_PAL	$30, 10
      1  635f				  -	      IF	$30 = 0
      2  635f				  -	      .byte	$30+10
      3  635f					      ENDIF
      4  635f				  -	      IF	$30 = $10
      5  635f				  -	      .byte	$20+10
      6  635f					      ENDIF
      7  635f				  -	      IF	$30 = $20
      8  635f				  -	      .byte	$40+10
      9  635f					      ENDIF
     10  635f					      IF	$30 = $30
     11  635f		       4a		      .byte.b	$40+10
     12  6360					      ENDIF
     13  6360				  -	      IF	$30 = $40
     14  6360				  -	      .byte	$60+10
     15  6360					      ENDIF
     16  6360				  -	      IF	$30 = $50
     17  6360				  -	      .byte	$80+10
     18  6360					      ENDIF
     19  6360				  -	      IF	$30 = $60
     20  6360				  -	      .byte	$C0+10
     21  6360					      ENDIF
     22  6360				  -	      IF	$30 = $70
     23  6360				  -	      .byte	$D0+10
     24  6360					      ENDIF
     25  6360				  -	      IF	$30 = $80
     26  6360				  -	      .byte	$B0+10
     27  6360					      ENDIF
     28  6360				  -	      IF	$30 = $90
     29  6360				  -	      .byte	$90+10
     30  6360					      ENDIF
     31  6360				  -	      IF	$30 = $A0
     32  6360				  -	      .byte	$70+10
     33  6360					      ENDIF
     34  6360				  -	      IF	$30 = $B0
     35  6360				  -	      .byte	$50+10
     36  6360					      ENDIF
     37  6360				  -	      IF	$30 = $C0
     38  6360				  -	      .byte	$30+10
     39  6360					      ENDIF
     40  6360				  -	      IF	$30 = $D0
     41  6360				  -	      .byte	$30+10
     42  6360					      ENDIF
     43  6360				  -	      IF	$30 = $E0
     44  6360				  -	      .byte	$20+10
     45  6360					      ENDIF
     46  6360				  -	      IF	$30 = $F0
     47  6360				  -	      .byte	$40+10
     48  6360					      ENDIF
      0  6360					      NTSC_TO_PAL	$30, 10
      1  6360				  -	      IF	$30 = 0
      2  6360				  -	      .byte	$30+10
      3  6360					      ENDIF
      4  6360				  -	      IF	$30 = $10
      5  6360				  -	      .byte	$20+10
      6  6360					      ENDIF
      7  6360				  -	      IF	$30 = $20
      8  6360				  -	      .byte	$40+10
      9  6360					      ENDIF
     10  6360					      IF	$30 = $30
     11  6360		       4a		      .byte.b	$40+10
     12  6361					      ENDIF
     13  6361				  -	      IF	$30 = $40
     14  6361				  -	      .byte	$60+10
     15  6361					      ENDIF
     16  6361				  -	      IF	$30 = $50
     17  6361				  -	      .byte	$80+10
     18  6361					      ENDIF
     19  6361				  -	      IF	$30 = $60
     20  6361				  -	      .byte	$C0+10
     21  6361					      ENDIF
     22  6361				  -	      IF	$30 = $70
     23  6361				  -	      .byte	$D0+10
     24  6361					      ENDIF
     25  6361				  -	      IF	$30 = $80
     26  6361				  -	      .byte	$B0+10
     27  6361					      ENDIF
     28  6361				  -	      IF	$30 = $90
     29  6361				  -	      .byte	$90+10
     30  6361					      ENDIF
     31  6361				  -	      IF	$30 = $A0
     32  6361				  -	      .byte	$70+10
     33  6361					      ENDIF
     34  6361				  -	      IF	$30 = $B0
     35  6361				  -	      .byte	$50+10
     36  6361					      ENDIF
     37  6361				  -	      IF	$30 = $C0
     38  6361				  -	      .byte	$30+10
     39  6361					      ENDIF
     40  6361				  -	      IF	$30 = $D0
     41  6361				  -	      .byte	$30+10
     42  6361					      ENDIF
     43  6361				  -	      IF	$30 = $E0
     44  6361				  -	      .byte	$20+10
     45  6361					      ENDIF
     46  6361				  -	      IF	$30 = $F0
     47  6361				  -	      .byte	$40+10
     48  6361					      ENDIF
      0  6361					      NTSC_TO_PAL	$30, 10
      1  6361				  -	      IF	$30 = 0
      2  6361				  -	      .byte	$30+10
      3  6361					      ENDIF
      4  6361				  -	      IF	$30 = $10
      5  6361				  -	      .byte	$20+10
      6  6361					      ENDIF
      7  6361				  -	      IF	$30 = $20
      8  6361				  -	      .byte	$40+10
      9  6361					      ENDIF
     10  6361					      IF	$30 = $30
     11  6361		       4a		      .byte.b	$40+10
     12  6362					      ENDIF
     13  6362				  -	      IF	$30 = $40
     14  6362				  -	      .byte	$60+10
     15  6362					      ENDIF
     16  6362				  -	      IF	$30 = $50
     17  6362				  -	      .byte	$80+10
     18  6362					      ENDIF
     19  6362				  -	      IF	$30 = $60
     20  6362				  -	      .byte	$C0+10
     21  6362					      ENDIF
     22  6362				  -	      IF	$30 = $70
     23  6362				  -	      .byte	$D0+10
     24  6362					      ENDIF
     25  6362				  -	      IF	$30 = $80
     26  6362				  -	      .byte	$B0+10
     27  6362					      ENDIF
     28  6362				  -	      IF	$30 = $90
     29  6362				  -	      .byte	$90+10
     30  6362					      ENDIF
     31  6362				  -	      IF	$30 = $A0
     32  6362				  -	      .byte	$70+10
     33  6362					      ENDIF
     34  6362				  -	      IF	$30 = $B0
     35  6362				  -	      .byte	$50+10
     36  6362					      ENDIF
     37  6362				  -	      IF	$30 = $C0
     38  6362				  -	      .byte	$30+10
     39  6362					      ENDIF
     40  6362				  -	      IF	$30 = $D0
     41  6362				  -	      .byte	$30+10
     42  6362					      ENDIF
     43  6362				  -	      IF	$30 = $E0
     44  6362				  -	      .byte	$20+10
     45  6362					      ENDIF
     46  6362				  -	      IF	$30 = $F0
     47  6362				  -	      .byte	$40+10
     48  6362					      ENDIF
      0  6362					      NTSC_TO_PAL	$30, 10
      1  6362				  -	      IF	$30 = 0
      2  6362				  -	      .byte	$30+10
      3  6362					      ENDIF
      4  6362				  -	      IF	$30 = $10
      5  6362				  -	      .byte	$20+10
      6  6362					      ENDIF
      7  6362				  -	      IF	$30 = $20
      8  6362				  -	      .byte	$40+10
      9  6362					      ENDIF
     10  6362					      IF	$30 = $30
     11  6362		       4a		      .byte.b	$40+10
     12  6363					      ENDIF
     13  6363				  -	      IF	$30 = $40
     14  6363				  -	      .byte	$60+10
     15  6363					      ENDIF
     16  6363				  -	      IF	$30 = $50
     17  6363				  -	      .byte	$80+10
     18  6363					      ENDIF
     19  6363				  -	      IF	$30 = $60
     20  6363				  -	      .byte	$C0+10
     21  6363					      ENDIF
     22  6363				  -	      IF	$30 = $70
     23  6363				  -	      .byte	$D0+10
     24  6363					      ENDIF
     25  6363				  -	      IF	$30 = $80
     26  6363				  -	      .byte	$B0+10
     27  6363					      ENDIF
     28  6363				  -	      IF	$30 = $90
     29  6363				  -	      .byte	$90+10
     30  6363					      ENDIF
     31  6363				  -	      IF	$30 = $A0
     32  6363				  -	      .byte	$70+10
     33  6363					      ENDIF
     34  6363				  -	      IF	$30 = $B0
     35  6363				  -	      .byte	$50+10
     36  6363					      ENDIF
     37  6363				  -	      IF	$30 = $C0
     38  6363				  -	      .byte	$30+10
     39  6363					      ENDIF
     40  6363				  -	      IF	$30 = $D0
     41  6363				  -	      .byte	$30+10
     42  6363					      ENDIF
     43  6363				  -	      IF	$30 = $E0
     44  6363				  -	      .byte	$20+10
     45  6363					      ENDIF
     46  6363				  -	      IF	$30 = $F0
     47  6363				  -	      .byte	$40+10
     48  6363					      ENDIF
      0  6363					      NTSC_TO_PAL	$30, 10
      1  6363				  -	      IF	$30 = 0
      2  6363				  -	      .byte	$30+10
      3  6363					      ENDIF
      4  6363				  -	      IF	$30 = $10
      5  6363				  -	      .byte	$20+10
      6  6363					      ENDIF
      7  6363				  -	      IF	$30 = $20
      8  6363				  -	      .byte	$40+10
      9  6363					      ENDIF
     10  6363					      IF	$30 = $30
     11  6363		       4a		      .byte.b	$40+10
     12  6364					      ENDIF
     13  6364				  -	      IF	$30 = $40
     14  6364				  -	      .byte	$60+10
     15  6364					      ENDIF
     16  6364				  -	      IF	$30 = $50
     17  6364				  -	      .byte	$80+10
     18  6364					      ENDIF
     19  6364				  -	      IF	$30 = $60
     20  6364				  -	      .byte	$C0+10
     21  6364					      ENDIF
     22  6364				  -	      IF	$30 = $70
     23  6364				  -	      .byte	$D0+10
     24  6364					      ENDIF
     25  6364				  -	      IF	$30 = $80
     26  6364				  -	      .byte	$B0+10
     27  6364					      ENDIF
     28  6364				  -	      IF	$30 = $90
     29  6364				  -	      .byte	$90+10
     30  6364					      ENDIF
     31  6364				  -	      IF	$30 = $A0
     32  6364				  -	      .byte	$70+10
     33  6364					      ENDIF
     34  6364				  -	      IF	$30 = $B0
     35  6364				  -	      .byte	$50+10
     36  6364					      ENDIF
     37  6364				  -	      IF	$30 = $C0
     38  6364				  -	      .byte	$30+10
     39  6364					      ENDIF
     40  6364				  -	      IF	$30 = $D0
     41  6364				  -	      .byte	$30+10
     42  6364					      ENDIF
     43  6364				  -	      IF	$30 = $E0
     44  6364				  -	      .byte	$20+10
     45  6364					      ENDIF
     46  6364				  -	      IF	$30 = $F0
     47  6364				  -	      .byte	$40+10
     48  6364					      ENDIF
      0  6364					      NTSC_TO_PAL	$30, 10
      1  6364				  -	      IF	$30 = 0
      2  6364				  -	      .byte	$30+10
      3  6364					      ENDIF
      4  6364				  -	      IF	$30 = $10
      5  6364				  -	      .byte	$20+10
      6  6364					      ENDIF
      7  6364				  -	      IF	$30 = $20
      8  6364				  -	      .byte	$40+10
      9  6364					      ENDIF
     10  6364					      IF	$30 = $30
     11  6364		       4a		      .byte.b	$40+10
     12  6365					      ENDIF
     13  6365				  -	      IF	$30 = $40
     14  6365				  -	      .byte	$60+10
     15  6365					      ENDIF
     16  6365				  -	      IF	$30 = $50
     17  6365				  -	      .byte	$80+10
     18  6365					      ENDIF
     19  6365				  -	      IF	$30 = $60
     20  6365				  -	      .byte	$C0+10
     21  6365					      ENDIF
     22  6365				  -	      IF	$30 = $70
     23  6365				  -	      .byte	$D0+10
     24  6365					      ENDIF
     25  6365				  -	      IF	$30 = $80
     26  6365				  -	      .byte	$B0+10
     27  6365					      ENDIF
     28  6365				  -	      IF	$30 = $90
     29  6365				  -	      .byte	$90+10
     30  6365					      ENDIF
     31  6365				  -	      IF	$30 = $A0
     32  6365				  -	      .byte	$70+10
     33  6365					      ENDIF
     34  6365				  -	      IF	$30 = $B0
     35  6365				  -	      .byte	$50+10
     36  6365					      ENDIF
     37  6365				  -	      IF	$30 = $C0
     38  6365				  -	      .byte	$30+10
     39  6365					      ENDIF
     40  6365				  -	      IF	$30 = $D0
     41  6365				  -	      .byte	$30+10
     42  6365					      ENDIF
     43  6365				  -	      IF	$30 = $E0
     44  6365				  -	      .byte	$20+10
     45  6365					      ENDIF
     46  6365				  -	      IF	$30 = $F0
     47  6365				  -	      .byte	$40+10
     48  6365					      ENDIF
      0  6365					      NTSC_TO_PAL	$10, $C
      1  6365				  -	      IF	$10 = 0
      2  6365				  -	      .byte	$10+$C
      3  6365					      ENDIF
      4  6365					      IF	$10 = $10
      5  6365		       2c		      .byte.b	$20+$C
      6  6366					      ENDIF
      7  6366				  -	      IF	$10 = $20
      8  6366				  -	      .byte	$40+$C
      9  6366					      ENDIF
     10  6366				  -	      IF	$10 = $30
     11  6366				  -	      .byte	$40+$C
     12  6366					      ENDIF
     13  6366				  -	      IF	$10 = $40
     14  6366				  -	      .byte	$60+$C
     15  6366					      ENDIF
     16  6366				  -	      IF	$10 = $50
     17  6366				  -	      .byte	$80+$C
     18  6366					      ENDIF
     19  6366				  -	      IF	$10 = $60
     20  6366				  -	      .byte	$C0+$C
     21  6366					      ENDIF
     22  6366				  -	      IF	$10 = $70
     23  6366				  -	      .byte	$D0+$C
     24  6366					      ENDIF
     25  6366				  -	      IF	$10 = $80
     26  6366				  -	      .byte	$B0+$C
     27  6366					      ENDIF
     28  6366				  -	      IF	$10 = $90
     29  6366				  -	      .byte	$90+$C
     30  6366					      ENDIF
     31  6366				  -	      IF	$10 = $A0
     32  6366				  -	      .byte	$70+$C
     33  6366					      ENDIF
     34  6366				  -	      IF	$10 = $B0
     35  6366				  -	      .byte	$50+$C
     36  6366					      ENDIF
     37  6366				  -	      IF	$10 = $C0
     38  6366				  -	      .byte	$30+$C
     39  6366					      ENDIF
     40  6366				  -	      IF	$10 = $D0
     41  6366				  -	      .byte	$30+$C
     42  6366					      ENDIF
     43  6366				  -	      IF	$10 = $E0
     44  6366				  -	      .byte	$20+$C
     45  6366					      ENDIF
     46  6366				  -	      IF	$10 = $F0
     47  6366				  -	      .byte	$40+$C
     48  6366					      ENDIF
      0  6366					      NTSC_TO_PAL	$10, $C
      1  6366				  -	      IF	$10 = 0
      2  6366				  -	      .byte	$10+$C
      3  6366					      ENDIF
      4  6366					      IF	$10 = $10
      5  6366		       2c		      .byte.b	$20+$C
      6  6367					      ENDIF
      7  6367				  -	      IF	$10 = $20
      8  6367				  -	      .byte	$40+$C
      9  6367					      ENDIF
     10  6367				  -	      IF	$10 = $30
     11  6367				  -	      .byte	$40+$C
     12  6367					      ENDIF
     13  6367				  -	      IF	$10 = $40
     14  6367				  -	      .byte	$60+$C
     15  6367					      ENDIF
     16  6367				  -	      IF	$10 = $50
     17  6367				  -	      .byte	$80+$C
     18  6367					      ENDIF
     19  6367				  -	      IF	$10 = $60
     20  6367				  -	      .byte	$C0+$C
     21  6367					      ENDIF
     22  6367				  -	      IF	$10 = $70
     23  6367				  -	      .byte	$D0+$C
     24  6367					      ENDIF
     25  6367				  -	      IF	$10 = $80
     26  6367				  -	      .byte	$B0+$C
     27  6367					      ENDIF
     28  6367				  -	      IF	$10 = $90
     29  6367				  -	      .byte	$90+$C
     30  6367					      ENDIF
     31  6367				  -	      IF	$10 = $A0
     32  6367				  -	      .byte	$70+$C
     33  6367					      ENDIF
     34  6367				  -	      IF	$10 = $B0
     35  6367				  -	      .byte	$50+$C
     36  6367					      ENDIF
     37  6367				  -	      IF	$10 = $C0
     38  6367				  -	      .byte	$30+$C
     39  6367					      ENDIF
     40  6367				  -	      IF	$10 = $D0
     41  6367				  -	      .byte	$30+$C
     42  6367					      ENDIF
     43  6367				  -	      IF	$10 = $E0
     44  6367				  -	      .byte	$20+$C
     45  6367					      ENDIF
     46  6367				  -	      IF	$10 = $F0
     47  6367				  -	      .byte	$40+$C
     48  6367					      ENDIF
    623  6367
    624  6367				   mancolourPAL2
      0  6367					      NTSC_TO_PAL	$10, 4
      1  6367				  -	      IF	$10 = 0
      2  6367				  -	      .byte	$10+4
      3  6367					      ENDIF
      4  6367					      IF	$10 = $10
      5  6367		       24		      .byte.b	$20+4
      6  6368					      ENDIF
      7  6368				  -	      IF	$10 = $20
      8  6368				  -	      .byte	$40+4
      9  6368					      ENDIF
     10  6368				  -	      IF	$10 = $30
     11  6368				  -	      .byte	$40+4
     12  6368					      ENDIF
     13  6368				  -	      IF	$10 = $40
     14  6368				  -	      .byte	$60+4
     15  6368					      ENDIF
     16  6368				  -	      IF	$10 = $50
     17  6368				  -	      .byte	$80+4
     18  6368					      ENDIF
     19  6368				  -	      IF	$10 = $60
     20  6368				  -	      .byte	$C0+4
     21  6368					      ENDIF
     22  6368				  -	      IF	$10 = $70
     23  6368				  -	      .byte	$D0+4
     24  6368					      ENDIF
     25  6368				  -	      IF	$10 = $80
     26  6368				  -	      .byte	$B0+4
     27  6368					      ENDIF
     28  6368				  -	      IF	$10 = $90
     29  6368				  -	      .byte	$90+4
     30  6368					      ENDIF
     31  6368				  -	      IF	$10 = $A0
     32  6368				  -	      .byte	$70+4
     33  6368					      ENDIF
     34  6368				  -	      IF	$10 = $B0
     35  6368				  -	      .byte	$50+4
     36  6368					      ENDIF
     37  6368				  -	      IF	$10 = $C0
     38  6368				  -	      .byte	$30+4
     39  6368					      ENDIF
     40  6368				  -	      IF	$10 = $D0
     41  6368				  -	      .byte	$30+4
     42  6368					      ENDIF
     43  6368				  -	      IF	$10 = $E0
     44  6368				  -	      .byte	$20+4
     45  6368					      ENDIF
     46  6368				  -	      IF	$10 = $F0
     47  6368				  -	      .byte	$40+4
     48  6368					      ENDIF
      0  6368					      NTSC_TO_PAL	$10, 4
      1  6368				  -	      IF	$10 = 0
      2  6368				  -	      .byte	$10+4
      3  6368					      ENDIF
      4  6368					      IF	$10 = $10
      5  6368		       24		      .byte.b	$20+4
      6  6369					      ENDIF
      7  6369				  -	      IF	$10 = $20
      8  6369				  -	      .byte	$40+4
      9  6369					      ENDIF
     10  6369				  -	      IF	$10 = $30
     11  6369				  -	      .byte	$40+4
     12  6369					      ENDIF
     13  6369				  -	      IF	$10 = $40
     14  6369				  -	      .byte	$60+4
     15  6369					      ENDIF
     16  6369				  -	      IF	$10 = $50
     17  6369				  -	      .byte	$80+4
     18  6369					      ENDIF
     19  6369				  -	      IF	$10 = $60
     20  6369				  -	      .byte	$C0+4
     21  6369					      ENDIF
     22  6369				  -	      IF	$10 = $70
     23  6369				  -	      .byte	$D0+4
     24  6369					      ENDIF
     25  6369				  -	      IF	$10 = $80
     26  6369				  -	      .byte	$B0+4
     27  6369					      ENDIF
     28  6369				  -	      IF	$10 = $90
     29  6369				  -	      .byte	$90+4
     30  6369					      ENDIF
     31  6369				  -	      IF	$10 = $A0
     32  6369				  -	      .byte	$70+4
     33  6369					      ENDIF
     34  6369				  -	      IF	$10 = $B0
     35  6369				  -	      .byte	$50+4
     36  6369					      ENDIF
     37  6369				  -	      IF	$10 = $C0
     38  6369				  -	      .byte	$30+4
     39  6369					      ENDIF
     40  6369				  -	      IF	$10 = $D0
     41  6369				  -	      .byte	$30+4
     42  6369					      ENDIF
     43  6369				  -	      IF	$10 = $E0
     44  6369				  -	      .byte	$20+4
     45  6369					      ENDIF
     46  6369				  -	      IF	$10 = $F0
     47  6369				  -	      .byte	$40+4
     48  6369					      ENDIF
      0  6369					      NTSC_TO_PAL	$30, 4
      1  6369				  -	      IF	$30 = 0
      2  6369				  -	      .byte	$30+4
      3  6369					      ENDIF
      4  6369				  -	      IF	$30 = $10
      5  6369				  -	      .byte	$20+4
      6  6369					      ENDIF
      7  6369				  -	      IF	$30 = $20
      8  6369				  -	      .byte	$40+4
      9  6369					      ENDIF
     10  6369					      IF	$30 = $30
     11  6369		       44		      .byte.b	$40+4
     12  636a					      ENDIF
     13  636a				  -	      IF	$30 = $40
     14  636a				  -	      .byte	$60+4
     15  636a					      ENDIF
     16  636a				  -	      IF	$30 = $50
     17  636a				  -	      .byte	$80+4
     18  636a					      ENDIF
     19  636a				  -	      IF	$30 = $60
     20  636a				  -	      .byte	$C0+4
     21  636a					      ENDIF
     22  636a				  -	      IF	$30 = $70
     23  636a				  -	      .byte	$D0+4
     24  636a					      ENDIF
     25  636a				  -	      IF	$30 = $80
     26  636a				  -	      .byte	$B0+4
     27  636a					      ENDIF
     28  636a				  -	      IF	$30 = $90
     29  636a				  -	      .byte	$90+4
     30  636a					      ENDIF
     31  636a				  -	      IF	$30 = $A0
     32  636a				  -	      .byte	$70+4
     33  636a					      ENDIF
     34  636a				  -	      IF	$30 = $B0
     35  636a				  -	      .byte	$50+4
     36  636a					      ENDIF
     37  636a				  -	      IF	$30 = $C0
     38  636a				  -	      .byte	$30+4
     39  636a					      ENDIF
     40  636a				  -	      IF	$30 = $D0
     41  636a				  -	      .byte	$30+4
     42  636a					      ENDIF
     43  636a				  -	      IF	$30 = $E0
     44  636a				  -	      .byte	$20+4
     45  636a					      ENDIF
     46  636a				  -	      IF	$30 = $F0
     47  636a				  -	      .byte	$40+4
     48  636a					      ENDIF
      0  636a					      NTSC_TO_PAL	$30, 4
      1  636a				  -	      IF	$30 = 0
      2  636a				  -	      .byte	$30+4
      3  636a					      ENDIF
      4  636a				  -	      IF	$30 = $10
      5  636a				  -	      .byte	$20+4
      6  636a					      ENDIF
      7  636a				  -	      IF	$30 = $20
      8  636a				  -	      .byte	$40+4
      9  636a					      ENDIF
     10  636a					      IF	$30 = $30
     11  636a		       44		      .byte.b	$40+4
     12  636b					      ENDIF
     13  636b				  -	      IF	$30 = $40
     14  636b				  -	      .byte	$60+4
     15  636b					      ENDIF
     16  636b				  -	      IF	$30 = $50
     17  636b				  -	      .byte	$80+4
     18  636b					      ENDIF
     19  636b				  -	      IF	$30 = $60
     20  636b				  -	      .byte	$C0+4
     21  636b					      ENDIF
     22  636b				  -	      IF	$30 = $70
     23  636b				  -	      .byte	$D0+4
     24  636b					      ENDIF
     25  636b				  -	      IF	$30 = $80
     26  636b				  -	      .byte	$B0+4
     27  636b					      ENDIF
     28  636b				  -	      IF	$30 = $90
     29  636b				  -	      .byte	$90+4
     30  636b					      ENDIF
     31  636b				  -	      IF	$30 = $A0
     32  636b				  -	      .byte	$70+4
     33  636b					      ENDIF
     34  636b				  -	      IF	$30 = $B0
     35  636b				  -	      .byte	$50+4
     36  636b					      ENDIF
     37  636b				  -	      IF	$30 = $C0
     38  636b				  -	      .byte	$30+4
     39  636b					      ENDIF
     40  636b				  -	      IF	$30 = $D0
     41  636b				  -	      .byte	$30+4
     42  636b					      ENDIF
     43  636b				  -	      IF	$30 = $E0
     44  636b				  -	      .byte	$20+4
     45  636b					      ENDIF
     46  636b				  -	      IF	$30 = $F0
     47  636b				  -	      .byte	$40+4
     48  636b					      ENDIF
      0  636b					      NTSC_TO_PAL	$30, 4
      1  636b				  -	      IF	$30 = 0
      2  636b				  -	      .byte	$30+4
      3  636b					      ENDIF
      4  636b				  -	      IF	$30 = $10
      5  636b				  -	      .byte	$20+4
      6  636b					      ENDIF
      7  636b				  -	      IF	$30 = $20
      8  636b				  -	      .byte	$40+4
      9  636b					      ENDIF
     10  636b					      IF	$30 = $30
     11  636b		       44		      .byte.b	$40+4
     12  636c					      ENDIF
     13  636c				  -	      IF	$30 = $40
     14  636c				  -	      .byte	$60+4
     15  636c					      ENDIF
     16  636c				  -	      IF	$30 = $50
     17  636c				  -	      .byte	$80+4
     18  636c					      ENDIF
     19  636c				  -	      IF	$30 = $60
     20  636c				  -	      .byte	$C0+4
     21  636c					      ENDIF
     22  636c				  -	      IF	$30 = $70
     23  636c				  -	      .byte	$D0+4
     24  636c					      ENDIF
     25  636c				  -	      IF	$30 = $80
     26  636c				  -	      .byte	$B0+4
     27  636c					      ENDIF
     28  636c				  -	      IF	$30 = $90
     29  636c				  -	      .byte	$90+4
     30  636c					      ENDIF
     31  636c				  -	      IF	$30 = $A0
     32  636c				  -	      .byte	$70+4
     33  636c					      ENDIF
     34  636c				  -	      IF	$30 = $B0
     35  636c				  -	      .byte	$50+4
     36  636c					      ENDIF
     37  636c				  -	      IF	$30 = $C0
     38  636c				  -	      .byte	$30+4
     39  636c					      ENDIF
     40  636c				  -	      IF	$30 = $D0
     41  636c				  -	      .byte	$30+4
     42  636c					      ENDIF
     43  636c				  -	      IF	$30 = $E0
     44  636c				  -	      .byte	$20+4
     45  636c					      ENDIF
     46  636c				  -	      IF	$30 = $F0
     47  636c				  -	      .byte	$40+4
     48  636c					      ENDIF
      0  636c					      NTSC_TO_PAL	$30, 4
      1  636c				  -	      IF	$30 = 0
      2  636c				  -	      .byte	$30+4
      3  636c					      ENDIF
      4  636c				  -	      IF	$30 = $10
      5  636c				  -	      .byte	$20+4
      6  636c					      ENDIF
      7  636c				  -	      IF	$30 = $20
      8  636c				  -	      .byte	$40+4
      9  636c					      ENDIF
     10  636c					      IF	$30 = $30
     11  636c		       44		      .byte.b	$40+4
     12  636d					      ENDIF
     13  636d				  -	      IF	$30 = $40
     14  636d				  -	      .byte	$60+4
     15  636d					      ENDIF
     16  636d				  -	      IF	$30 = $50
     17  636d				  -	      .byte	$80+4
     18  636d					      ENDIF
     19  636d				  -	      IF	$30 = $60
     20  636d				  -	      .byte	$C0+4
     21  636d					      ENDIF
     22  636d				  -	      IF	$30 = $70
     23  636d				  -	      .byte	$D0+4
     24  636d					      ENDIF
     25  636d				  -	      IF	$30 = $80
     26  636d				  -	      .byte	$B0+4
     27  636d					      ENDIF
     28  636d				  -	      IF	$30 = $90
     29  636d				  -	      .byte	$90+4
     30  636d					      ENDIF
     31  636d				  -	      IF	$30 = $A0
     32  636d				  -	      .byte	$70+4
     33  636d					      ENDIF
     34  636d				  -	      IF	$30 = $B0
     35  636d				  -	      .byte	$50+4
     36  636d					      ENDIF
     37  636d				  -	      IF	$30 = $C0
     38  636d				  -	      .byte	$30+4
     39  636d					      ENDIF
     40  636d				  -	      IF	$30 = $D0
     41  636d				  -	      .byte	$30+4
     42  636d					      ENDIF
     43  636d				  -	      IF	$30 = $E0
     44  636d				  -	      .byte	$20+4
     45  636d					      ENDIF
     46  636d				  -	      IF	$30 = $F0
     47  636d				  -	      .byte	$40+4
     48  636d					      ENDIF
      0  636d					      NTSC_TO_PAL	$30, 4
      1  636d				  -	      IF	$30 = 0
      2  636d				  -	      .byte	$30+4
      3  636d					      ENDIF
      4  636d				  -	      IF	$30 = $10
      5  636d				  -	      .byte	$20+4
      6  636d					      ENDIF
      7  636d				  -	      IF	$30 = $20
      8  636d				  -	      .byte	$40+4
      9  636d					      ENDIF
     10  636d					      IF	$30 = $30
     11  636d		       44		      .byte.b	$40+4
     12  636e					      ENDIF
     13  636e				  -	      IF	$30 = $40
     14  636e				  -	      .byte	$60+4
     15  636e					      ENDIF
     16  636e				  -	      IF	$30 = $50
     17  636e				  -	      .byte	$80+4
     18  636e					      ENDIF
     19  636e				  -	      IF	$30 = $60
     20  636e				  -	      .byte	$C0+4
     21  636e					      ENDIF
     22  636e				  -	      IF	$30 = $70
     23  636e				  -	      .byte	$D0+4
     24  636e					      ENDIF
     25  636e				  -	      IF	$30 = $80
     26  636e				  -	      .byte	$B0+4
     27  636e					      ENDIF
     28  636e				  -	      IF	$30 = $90
     29  636e				  -	      .byte	$90+4
     30  636e					      ENDIF
     31  636e				  -	      IF	$30 = $A0
     32  636e				  -	      .byte	$70+4
     33  636e					      ENDIF
     34  636e				  -	      IF	$30 = $B0
     35  636e				  -	      .byte	$50+4
     36  636e					      ENDIF
     37  636e				  -	      IF	$30 = $C0
     38  636e				  -	      .byte	$30+4
     39  636e					      ENDIF
     40  636e				  -	      IF	$30 = $D0
     41  636e				  -	      .byte	$30+4
     42  636e					      ENDIF
     43  636e				  -	      IF	$30 = $E0
     44  636e				  -	      .byte	$20+4
     45  636e					      ENDIF
     46  636e				  -	      IF	$30 = $F0
     47  636e				  -	      .byte	$40+4
     48  636e					      ENDIF
      0  636e					      NTSC_TO_PAL	$30, 4
      1  636e				  -	      IF	$30 = 0
      2  636e				  -	      .byte	$30+4
      3  636e					      ENDIF
      4  636e				  -	      IF	$30 = $10
      5  636e				  -	      .byte	$20+4
      6  636e					      ENDIF
      7  636e				  -	      IF	$30 = $20
      8  636e				  -	      .byte	$40+4
      9  636e					      ENDIF
     10  636e					      IF	$30 = $30
     11  636e		       44		      .byte.b	$40+4
     12  636f					      ENDIF
     13  636f				  -	      IF	$30 = $40
     14  636f				  -	      .byte	$60+4
     15  636f					      ENDIF
     16  636f				  -	      IF	$30 = $50
     17  636f				  -	      .byte	$80+4
     18  636f					      ENDIF
     19  636f				  -	      IF	$30 = $60
     20  636f				  -	      .byte	$C0+4
     21  636f					      ENDIF
     22  636f				  -	      IF	$30 = $70
     23  636f				  -	      .byte	$D0+4
     24  636f					      ENDIF
     25  636f				  -	      IF	$30 = $80
     26  636f				  -	      .byte	$B0+4
     27  636f					      ENDIF
     28  636f				  -	      IF	$30 = $90
     29  636f				  -	      .byte	$90+4
     30  636f					      ENDIF
     31  636f				  -	      IF	$30 = $A0
     32  636f				  -	      .byte	$70+4
     33  636f					      ENDIF
     34  636f				  -	      IF	$30 = $B0
     35  636f				  -	      .byte	$50+4
     36  636f					      ENDIF
     37  636f				  -	      IF	$30 = $C0
     38  636f				  -	      .byte	$30+4
     39  636f					      ENDIF
     40  636f				  -	      IF	$30 = $D0
     41  636f				  -	      .byte	$30+4
     42  636f					      ENDIF
     43  636f				  -	      IF	$30 = $E0
     44  636f				  -	      .byte	$20+4
     45  636f					      ENDIF
     46  636f				  -	      IF	$30 = $F0
     47  636f				  -	      .byte	$40+4
     48  636f					      ENDIF
      0  636f					      NTSC_TO_PAL	$30, 4
      1  636f				  -	      IF	$30 = 0
      2  636f				  -	      .byte	$30+4
      3  636f					      ENDIF
      4  636f				  -	      IF	$30 = $10
      5  636f				  -	      .byte	$20+4
      6  636f					      ENDIF
      7  636f				  -	      IF	$30 = $20
      8  636f				  -	      .byte	$40+4
      9  636f					      ENDIF
     10  636f					      IF	$30 = $30
     11  636f		       44		      .byte.b	$40+4
     12  6370					      ENDIF
     13  6370				  -	      IF	$30 = $40
     14  6370				  -	      .byte	$60+4
     15  6370					      ENDIF
     16  6370				  -	      IF	$30 = $50
     17  6370				  -	      .byte	$80+4
     18  6370					      ENDIF
     19  6370				  -	      IF	$30 = $60
     20  6370				  -	      .byte	$C0+4
     21  6370					      ENDIF
     22  6370				  -	      IF	$30 = $70
     23  6370				  -	      .byte	$D0+4
     24  6370					      ENDIF
     25  6370				  -	      IF	$30 = $80
     26  6370				  -	      .byte	$B0+4
     27  6370					      ENDIF
     28  6370				  -	      IF	$30 = $90
     29  6370				  -	      .byte	$90+4
     30  6370					      ENDIF
     31  6370				  -	      IF	$30 = $A0
     32  6370				  -	      .byte	$70+4
     33  6370					      ENDIF
     34  6370				  -	      IF	$30 = $B0
     35  6370				  -	      .byte	$50+4
     36  6370					      ENDIF
     37  6370				  -	      IF	$30 = $C0
     38  6370				  -	      .byte	$30+4
     39  6370					      ENDIF
     40  6370				  -	      IF	$30 = $D0
     41  6370				  -	      .byte	$30+4
     42  6370					      ENDIF
     43  6370				  -	      IF	$30 = $E0
     44  6370				  -	      .byte	$20+4
     45  6370					      ENDIF
     46  6370				  -	      IF	$30 = $F0
     47  6370				  -	      .byte	$40+4
     48  6370					      ENDIF
      0  6370					      NTSC_TO_PAL	$0,10
      1  6370					      IF	$0 = 0
      2  6370		       0a		      .byte.b	$0+10
      3  6371					      ENDIF
      4  6371				  -	      IF	$0 = $10
      5  6371				  -	      .byte	$20+10
      6  6371					      ENDIF
      7  6371				  -	      IF	$0 = $20
      8  6371				  -	      .byte	$40+10
      9  6371					      ENDIF
     10  6371				  -	      IF	$0 = $30
     11  6371				  -	      .byte	$40+10
     12  6371					      ENDIF
     13  6371				  -	      IF	$0 = $40
     14  6371				  -	      .byte	$60+10
     15  6371					      ENDIF
     16  6371				  -	      IF	$0 = $50
     17  6371				  -	      .byte	$80+10
     18  6371					      ENDIF
     19  6371				  -	      IF	$0 = $60
     20  6371				  -	      .byte	$C0+10
     21  6371					      ENDIF
     22  6371				  -	      IF	$0 = $70
     23  6371				  -	      .byte	$D0+10
     24  6371					      ENDIF
     25  6371				  -	      IF	$0 = $80
     26  6371				  -	      .byte	$B0+10
     27  6371					      ENDIF
     28  6371				  -	      IF	$0 = $90
     29  6371				  -	      .byte	$90+10
     30  6371					      ENDIF
     31  6371				  -	      IF	$0 = $A0
     32  6371				  -	      .byte	$70+10
     33  6371					      ENDIF
     34  6371				  -	      IF	$0 = $B0
     35  6371				  -	      .byte	$50+10
     36  6371					      ENDIF
     37  6371				  -	      IF	$0 = $C0
     38  6371				  -	      .byte	$30+10
     39  6371					      ENDIF
     40  6371				  -	      IF	$0 = $D0
     41  6371				  -	      .byte	$30+10
     42  6371					      ENDIF
     43  6371				  -	      IF	$0 = $E0
     44  6371				  -	      .byte	$20+10
     45  6371					      ENDIF
     46  6371				  -	      IF	$0 = $F0
     47  6371				  -	      .byte	$40+10
     48  6371					      ENDIF
      0  6371					      NTSC_TO_PAL	$90, $a
      1  6371				  -	      IF	$90 = 0
      2  6371				  -	      .byte	$90+$a
      3  6371					      ENDIF
      4  6371				  -	      IF	$90 = $10
      5  6371				  -	      .byte	$20+$a
      6  6371					      ENDIF
      7  6371				  -	      IF	$90 = $20
      8  6371				  -	      .byte	$40+$a
      9  6371					      ENDIF
     10  6371				  -	      IF	$90 = $30
     11  6371				  -	      .byte	$40+$a
     12  6371					      ENDIF
     13  6371				  -	      IF	$90 = $40
     14  6371				  -	      .byte	$60+$a
     15  6371					      ENDIF
     16  6371				  -	      IF	$90 = $50
     17  6371				  -	      .byte	$80+$a
     18  6371					      ENDIF
     19  6371				  -	      IF	$90 = $60
     20  6371				  -	      .byte	$C0+$a
     21  6371					      ENDIF
     22  6371				  -	      IF	$90 = $70
     23  6371				  -	      .byte	$D0+$a
     24  6371					      ENDIF
     25  6371				  -	      IF	$90 = $80
     26  6371				  -	      .byte	$B0+$a
     27  6371					      ENDIF
     28  6371					      IF	$90 = $90
     29  6371		       9a		      .byte.b	$90+$a
     30  6372					      ENDIF
     31  6372				  -	      IF	$90 = $A0
     32  6372				  -	      .byte	$70+$a
     33  6372					      ENDIF
     34  6372				  -	      IF	$90 = $B0
     35  6372				  -	      .byte	$50+$a
     36  6372					      ENDIF
     37  6372				  -	      IF	$90 = $C0
     38  6372				  -	      .byte	$30+$a
     39  6372					      ENDIF
     40  6372				  -	      IF	$90 = $D0
     41  6372				  -	      .byte	$30+$a
     42  6372					      ENDIF
     43  6372				  -	      IF	$90 = $E0
     44  6372				  -	      .byte	$20+$a
     45  6372					      ENDIF
     46  6372				  -	      IF	$90 = $F0
     47  6372				  -	      .byte	$40+$a
     48  6372					      ENDIF
      0  6372					      NTSC_TO_PAL	$90, 6
      1  6372				  -	      IF	$90 = 0
      2  6372				  -	      .byte	$90+6
      3  6372					      ENDIF
      4  6372				  -	      IF	$90 = $10
      5  6372				  -	      .byte	$20+6
      6  6372					      ENDIF
      7  6372				  -	      IF	$90 = $20
      8  6372				  -	      .byte	$40+6
      9  6372					      ENDIF
     10  6372				  -	      IF	$90 = $30
     11  6372				  -	      .byte	$40+6
     12  6372					      ENDIF
     13  6372				  -	      IF	$90 = $40
     14  6372				  -	      .byte	$60+6
     15  6372					      ENDIF
     16  6372				  -	      IF	$90 = $50
     17  6372				  -	      .byte	$80+6
     18  6372					      ENDIF
     19  6372				  -	      IF	$90 = $60
     20  6372				  -	      .byte	$C0+6
     21  6372					      ENDIF
     22  6372				  -	      IF	$90 = $70
     23  6372				  -	      .byte	$D0+6
     24  6372					      ENDIF
     25  6372				  -	      IF	$90 = $80
     26  6372				  -	      .byte	$B0+6
     27  6372					      ENDIF
     28  6372					      IF	$90 = $90
     29  6372		       96		      .byte.b	$90+6
     30  6373					      ENDIF
     31  6373				  -	      IF	$90 = $A0
     32  6373				  -	      .byte	$70+6
     33  6373					      ENDIF
     34  6373				  -	      IF	$90 = $B0
     35  6373				  -	      .byte	$50+6
     36  6373					      ENDIF
     37  6373				  -	      IF	$90 = $C0
     38  6373				  -	      .byte	$30+6
     39  6373					      ENDIF
     40  6373				  -	      IF	$90 = $D0
     41  6373				  -	      .byte	$30+6
     42  6373					      ENDIF
     43  6373				  -	      IF	$90 = $E0
     44  6373				  -	      .byte	$20+6
     45  6373					      ENDIF
     46  6373				  -	      IF	$90 = $F0
     47  6373				  -	      .byte	$40+6
     48  6373					      ENDIF
      0  6373					      NTSC_TO_PAL	$90, 6
      1  6373				  -	      IF	$90 = 0
      2  6373				  -	      .byte	$90+6
      3  6373					      ENDIF
      4  6373				  -	      IF	$90 = $10
      5  6373				  -	      .byte	$20+6
      6  6373					      ENDIF
      7  6373				  -	      IF	$90 = $20
      8  6373				  -	      .byte	$40+6
      9  6373					      ENDIF
     10  6373				  -	      IF	$90 = $30
     11  6373				  -	      .byte	$40+6
     12  6373					      ENDIF
     13  6373				  -	      IF	$90 = $40
     14  6373				  -	      .byte	$60+6
     15  6373					      ENDIF
     16  6373				  -	      IF	$90 = $50
     17  6373				  -	      .byte	$80+6
     18  6373					      ENDIF
     19  6373				  -	      IF	$90 = $60
     20  6373				  -	      .byte	$C0+6
     21  6373					      ENDIF
     22  6373				  -	      IF	$90 = $70
     23  6373				  -	      .byte	$D0+6
     24  6373					      ENDIF
     25  6373				  -	      IF	$90 = $80
     26  6373				  -	      .byte	$B0+6
     27  6373					      ENDIF
     28  6373					      IF	$90 = $90
     29  6373		       96		      .byte.b	$90+6
     30  6374					      ENDIF
     31  6374				  -	      IF	$90 = $A0
     32  6374				  -	      .byte	$70+6
     33  6374					      ENDIF
     34  6374				  -	      IF	$90 = $B0
     35  6374				  -	      .byte	$50+6
     36  6374					      ENDIF
     37  6374				  -	      IF	$90 = $C0
     38  6374				  -	      .byte	$30+6
     39  6374					      ENDIF
     40  6374				  -	      IF	$90 = $D0
     41  6374				  -	      .byte	$30+6
     42  6374					      ENDIF
     43  6374				  -	      IF	$90 = $E0
     44  6374				  -	      .byte	$20+6
     45  6374					      ENDIF
     46  6374				  -	      IF	$90 = $F0
     47  6374				  -	      .byte	$40+6
     48  6374					      ENDIF
      0  6374					      NTSC_TO_PAL	$90, 6
      1  6374				  -	      IF	$90 = 0
      2  6374				  -	      .byte	$90+6
      3  6374					      ENDIF
      4  6374				  -	      IF	$90 = $10
      5  6374				  -	      .byte	$20+6
      6  6374					      ENDIF
      7  6374				  -	      IF	$90 = $20
      8  6374				  -	      .byte	$40+6
      9  6374					      ENDIF
     10  6374				  -	      IF	$90 = $30
     11  6374				  -	      .byte	$40+6
     12  6374					      ENDIF
     13  6374				  -	      IF	$90 = $40
     14  6374				  -	      .byte	$60+6
     15  6374					      ENDIF
     16  6374				  -	      IF	$90 = $50
     17  6374				  -	      .byte	$80+6
     18  6374					      ENDIF
     19  6374				  -	      IF	$90 = $60
     20  6374				  -	      .byte	$C0+6
     21  6374					      ENDIF
     22  6374				  -	      IF	$90 = $70
     23  6374				  -	      .byte	$D0+6
     24  6374					      ENDIF
     25  6374				  -	      IF	$90 = $80
     26  6374				  -	      .byte	$B0+6
     27  6374					      ENDIF
     28  6374					      IF	$90 = $90
     29  6374		       96		      .byte.b	$90+6
     30  6375					      ENDIF
     31  6375				  -	      IF	$90 = $A0
     32  6375				  -	      .byte	$70+6
     33  6375					      ENDIF
     34  6375				  -	      IF	$90 = $B0
     35  6375				  -	      .byte	$50+6
     36  6375					      ENDIF
     37  6375				  -	      IF	$90 = $C0
     38  6375				  -	      .byte	$30+6
     39  6375					      ENDIF
     40  6375				  -	      IF	$90 = $D0
     41  6375				  -	      .byte	$30+6
     42  6375					      ENDIF
     43  6375				  -	      IF	$90 = $E0
     44  6375				  -	      .byte	$20+6
     45  6375					      ENDIF
     46  6375				  -	      IF	$90 = $F0
     47  6375				  -	      .byte	$40+6
     48  6375					      ENDIF
      0  6375					      NTSC_TO_PAL	$90, 6
      1  6375				  -	      IF	$90 = 0
      2  6375				  -	      .byte	$90+6
      3  6375					      ENDIF
      4  6375				  -	      IF	$90 = $10
      5  6375				  -	      .byte	$20+6
      6  6375					      ENDIF
      7  6375				  -	      IF	$90 = $20
      8  6375				  -	      .byte	$40+6
      9  6375					      ENDIF
     10  6375				  -	      IF	$90 = $30
     11  6375				  -	      .byte	$40+6
     12  6375					      ENDIF
     13  6375				  -	      IF	$90 = $40
     14  6375				  -	      .byte	$60+6
     15  6375					      ENDIF
     16  6375				  -	      IF	$90 = $50
     17  6375				  -	      .byte	$80+6
     18  6375					      ENDIF
     19  6375				  -	      IF	$90 = $60
     20  6375				  -	      .byte	$C0+6
     21  6375					      ENDIF
     22  6375				  -	      IF	$90 = $70
     23  6375				  -	      .byte	$D0+6
     24  6375					      ENDIF
     25  6375				  -	      IF	$90 = $80
     26  6375				  -	      .byte	$B0+6
     27  6375					      ENDIF
     28  6375					      IF	$90 = $90
     29  6375		       96		      .byte.b	$90+6
     30  6376					      ENDIF
     31  6376				  -	      IF	$90 = $A0
     32  6376				  -	      .byte	$70+6
     33  6376					      ENDIF
     34  6376				  -	      IF	$90 = $B0
     35  6376				  -	      .byte	$50+6
     36  6376					      ENDIF
     37  6376				  -	      IF	$90 = $C0
     38  6376				  -	      .byte	$30+6
     39  6376					      ENDIF
     40  6376				  -	      IF	$90 = $D0
     41  6376				  -	      .byte	$30+6
     42  6376					      ENDIF
     43  6376				  -	      IF	$90 = $E0
     44  6376				  -	      .byte	$20+6
     45  6376					      ENDIF
     46  6376				  -	      IF	$90 = $F0
     47  6376				  -	      .byte	$40+6
     48  6376					      ENDIF
      0  6376					      NTSC_TO_PAL	$0, 10
      1  6376					      IF	$0 = 0
      2  6376		       0a		      .byte.b	$0+10
      3  6377					      ENDIF
      4  6377				  -	      IF	$0 = $10
      5  6377				  -	      .byte	$20+10
      6  6377					      ENDIF
      7  6377				  -	      IF	$0 = $20
      8  6377				  -	      .byte	$40+10
      9  6377					      ENDIF
     10  6377				  -	      IF	$0 = $30
     11  6377				  -	      .byte	$40+10
     12  6377					      ENDIF
     13  6377				  -	      IF	$0 = $40
     14  6377				  -	      .byte	$60+10
     15  6377					      ENDIF
     16  6377				  -	      IF	$0 = $50
     17  6377				  -	      .byte	$80+10
     18  6377					      ENDIF
     19  6377				  -	      IF	$0 = $60
     20  6377				  -	      .byte	$C0+10
     21  6377					      ENDIF
     22  6377				  -	      IF	$0 = $70
     23  6377				  -	      .byte	$D0+10
     24  6377					      ENDIF
     25  6377				  -	      IF	$0 = $80
     26  6377				  -	      .byte	$B0+10
     27  6377					      ENDIF
     28  6377				  -	      IF	$0 = $90
     29  6377				  -	      .byte	$90+10
     30  6377					      ENDIF
     31  6377				  -	      IF	$0 = $A0
     32  6377				  -	      .byte	$70+10
     33  6377					      ENDIF
     34  6377				  -	      IF	$0 = $B0
     35  6377				  -	      .byte	$50+10
     36  6377					      ENDIF
     37  6377				  -	      IF	$0 = $C0
     38  6377				  -	      .byte	$30+10
     39  6377					      ENDIF
     40  6377				  -	      IF	$0 = $D0
     41  6377				  -	      .byte	$30+10
     42  6377					      ENDIF
     43  6377				  -	      IF	$0 = $E0
     44  6377				  -	      .byte	$20+10
     45  6377					      ENDIF
     46  6377				  -	      IF	$0 = $F0
     47  6377				  -	      .byte	$40+10
     48  6377					      ENDIF
      0  6377					      NTSC_TO_PAL	$30, 10
      1  6377				  -	      IF	$30 = 0
      2  6377				  -	      .byte	$30+10
      3  6377					      ENDIF
      4  6377				  -	      IF	$30 = $10
      5  6377				  -	      .byte	$20+10
      6  6377					      ENDIF
      7  6377				  -	      IF	$30 = $20
      8  6377				  -	      .byte	$40+10
      9  6377					      ENDIF
     10  6377					      IF	$30 = $30
     11  6377		       4a		      .byte.b	$40+10
     12  6378					      ENDIF
     13  6378				  -	      IF	$30 = $40
     14  6378				  -	      .byte	$60+10
     15  6378					      ENDIF
     16  6378				  -	      IF	$30 = $50
     17  6378				  -	      .byte	$80+10
     18  6378					      ENDIF
     19  6378				  -	      IF	$30 = $60
     20  6378				  -	      .byte	$C0+10
     21  6378					      ENDIF
     22  6378				  -	      IF	$30 = $70
     23  6378				  -	      .byte	$D0+10
     24  6378					      ENDIF
     25  6378				  -	      IF	$30 = $80
     26  6378				  -	      .byte	$B0+10
     27  6378					      ENDIF
     28  6378				  -	      IF	$30 = $90
     29  6378				  -	      .byte	$90+10
     30  6378					      ENDIF
     31  6378				  -	      IF	$30 = $A0
     32  6378				  -	      .byte	$70+10
     33  6378					      ENDIF
     34  6378				  -	      IF	$30 = $B0
     35  6378				  -	      .byte	$50+10
     36  6378					      ENDIF
     37  6378				  -	      IF	$30 = $C0
     38  6378				  -	      .byte	$30+10
     39  6378					      ENDIF
     40  6378				  -	      IF	$30 = $D0
     41  6378				  -	      .byte	$30+10
     42  6378					      ENDIF
     43  6378				  -	      IF	$30 = $E0
     44  6378				  -	      .byte	$20+10
     45  6378					      ENDIF
     46  6378				  -	      IF	$30 = $F0
     47  6378				  -	      .byte	$40+10
     48  6378					      ENDIF
      0  6378					      NTSC_TO_PAL	$30, 10
      1  6378				  -	      IF	$30 = 0
      2  6378				  -	      .byte	$30+10
      3  6378					      ENDIF
      4  6378				  -	      IF	$30 = $10
      5  6378				  -	      .byte	$20+10
      6  6378					      ENDIF
      7  6378				  -	      IF	$30 = $20
      8  6378				  -	      .byte	$40+10
      9  6378					      ENDIF
     10  6378					      IF	$30 = $30
     11  6378		       4a		      .byte.b	$40+10
     12  6379					      ENDIF
     13  6379				  -	      IF	$30 = $40
     14  6379				  -	      .byte	$60+10
     15  6379					      ENDIF
     16  6379				  -	      IF	$30 = $50
     17  6379				  -	      .byte	$80+10
     18  6379					      ENDIF
     19  6379				  -	      IF	$30 = $60
     20  6379				  -	      .byte	$C0+10
     21  6379					      ENDIF
     22  6379				  -	      IF	$30 = $70
     23  6379				  -	      .byte	$D0+10
     24  6379					      ENDIF
     25  6379				  -	      IF	$30 = $80
     26  6379				  -	      .byte	$B0+10
     27  6379					      ENDIF
     28  6379				  -	      IF	$30 = $90
     29  6379				  -	      .byte	$90+10
     30  6379					      ENDIF
     31  6379				  -	      IF	$30 = $A0
     32  6379				  -	      .byte	$70+10
     33  6379					      ENDIF
     34  6379				  -	      IF	$30 = $B0
     35  6379				  -	      .byte	$50+10
     36  6379					      ENDIF
     37  6379				  -	      IF	$30 = $C0
     38  6379				  -	      .byte	$30+10
     39  6379					      ENDIF
     40  6379				  -	      IF	$30 = $D0
     41  6379				  -	      .byte	$30+10
     42  6379					      ENDIF
     43  6379				  -	      IF	$30 = $E0
     44  6379				  -	      .byte	$20+10
     45  6379					      ENDIF
     46  6379				  -	      IF	$30 = $F0
     47  6379				  -	      .byte	$40+10
     48  6379					      ENDIF
      0  6379					      NTSC_TO_PAL	$30, 10
      1  6379				  -	      IF	$30 = 0
      2  6379				  -	      .byte	$30+10
      3  6379					      ENDIF
      4  6379				  -	      IF	$30 = $10
      5  6379				  -	      .byte	$20+10
      6  6379					      ENDIF
      7  6379				  -	      IF	$30 = $20
      8  6379				  -	      .byte	$40+10
      9  6379					      ENDIF
     10  6379					      IF	$30 = $30
     11  6379		       4a		      .byte.b	$40+10
     12  637a					      ENDIF
     13  637a				  -	      IF	$30 = $40
     14  637a				  -	      .byte	$60+10
     15  637a					      ENDIF
     16  637a				  -	      IF	$30 = $50
     17  637a				  -	      .byte	$80+10
     18  637a					      ENDIF
     19  637a				  -	      IF	$30 = $60
     20  637a				  -	      .byte	$C0+10
     21  637a					      ENDIF
     22  637a				  -	      IF	$30 = $70
     23  637a				  -	      .byte	$D0+10
     24  637a					      ENDIF
     25  637a				  -	      IF	$30 = $80
     26  637a				  -	      .byte	$B0+10
     27  637a					      ENDIF
     28  637a				  -	      IF	$30 = $90
     29  637a				  -	      .byte	$90+10
     30  637a					      ENDIF
     31  637a				  -	      IF	$30 = $A0
     32  637a				  -	      .byte	$70+10
     33  637a					      ENDIF
     34  637a				  -	      IF	$30 = $B0
     35  637a				  -	      .byte	$50+10
     36  637a					      ENDIF
     37  637a				  -	      IF	$30 = $C0
     38  637a				  -	      .byte	$30+10
     39  637a					      ENDIF
     40  637a				  -	      IF	$30 = $D0
     41  637a				  -	      .byte	$30+10
     42  637a					      ENDIF
     43  637a				  -	      IF	$30 = $E0
     44  637a				  -	      .byte	$20+10
     45  637a					      ENDIF
     46  637a				  -	      IF	$30 = $F0
     47  637a				  -	      .byte	$40+10
     48  637a					      ENDIF
      0  637a					      NTSC_TO_PAL	$30, 10
      1  637a				  -	      IF	$30 = 0
      2  637a				  -	      .byte	$30+10
      3  637a					      ENDIF
      4  637a				  -	      IF	$30 = $10
      5  637a				  -	      .byte	$20+10
      6  637a					      ENDIF
      7  637a				  -	      IF	$30 = $20
      8  637a				  -	      .byte	$40+10
      9  637a					      ENDIF
     10  637a					      IF	$30 = $30
     11  637a		       4a		      .byte.b	$40+10
     12  637b					      ENDIF
     13  637b				  -	      IF	$30 = $40
     14  637b				  -	      .byte	$60+10
     15  637b					      ENDIF
     16  637b				  -	      IF	$30 = $50
     17  637b				  -	      .byte	$80+10
     18  637b					      ENDIF
     19  637b				  -	      IF	$30 = $60
     20  637b				  -	      .byte	$C0+10
     21  637b					      ENDIF
     22  637b				  -	      IF	$30 = $70
     23  637b				  -	      .byte	$D0+10
     24  637b					      ENDIF
     25  637b				  -	      IF	$30 = $80
     26  637b				  -	      .byte	$B0+10
     27  637b					      ENDIF
     28  637b				  -	      IF	$30 = $90
     29  637b				  -	      .byte	$90+10
     30  637b					      ENDIF
     31  637b				  -	      IF	$30 = $A0
     32  637b				  -	      .byte	$70+10
     33  637b					      ENDIF
     34  637b				  -	      IF	$30 = $B0
     35  637b				  -	      .byte	$50+10
     36  637b					      ENDIF
     37  637b				  -	      IF	$30 = $C0
     38  637b				  -	      .byte	$30+10
     39  637b					      ENDIF
     40  637b				  -	      IF	$30 = $D0
     41  637b				  -	      .byte	$30+10
     42  637b					      ENDIF
     43  637b				  -	      IF	$30 = $E0
     44  637b				  -	      .byte	$20+10
     45  637b					      ENDIF
     46  637b				  -	      IF	$30 = $F0
     47  637b				  -	      .byte	$40+10
     48  637b					      ENDIF
      0  637b					      NTSC_TO_PAL	$30, 10
      1  637b				  -	      IF	$30 = 0
      2  637b				  -	      .byte	$30+10
      3  637b					      ENDIF
      4  637b				  -	      IF	$30 = $10
      5  637b				  -	      .byte	$20+10
      6  637b					      ENDIF
      7  637b				  -	      IF	$30 = $20
      8  637b				  -	      .byte	$40+10
      9  637b					      ENDIF
     10  637b					      IF	$30 = $30
     11  637b		       4a		      .byte.b	$40+10
     12  637c					      ENDIF
     13  637c				  -	      IF	$30 = $40
     14  637c				  -	      .byte	$60+10
     15  637c					      ENDIF
     16  637c				  -	      IF	$30 = $50
     17  637c				  -	      .byte	$80+10
     18  637c					      ENDIF
     19  637c				  -	      IF	$30 = $60
     20  637c				  -	      .byte	$C0+10
     21  637c					      ENDIF
     22  637c				  -	      IF	$30 = $70
     23  637c				  -	      .byte	$D0+10
     24  637c					      ENDIF
     25  637c				  -	      IF	$30 = $80
     26  637c				  -	      .byte	$B0+10
     27  637c					      ENDIF
     28  637c				  -	      IF	$30 = $90
     29  637c				  -	      .byte	$90+10
     30  637c					      ENDIF
     31  637c				  -	      IF	$30 = $A0
     32  637c				  -	      .byte	$70+10
     33  637c					      ENDIF
     34  637c				  -	      IF	$30 = $B0
     35  637c				  -	      .byte	$50+10
     36  637c					      ENDIF
     37  637c				  -	      IF	$30 = $C0
     38  637c				  -	      .byte	$30+10
     39  637c					      ENDIF
     40  637c				  -	      IF	$30 = $D0
     41  637c				  -	      .byte	$30+10
     42  637c					      ENDIF
     43  637c				  -	      IF	$30 = $E0
     44  637c				  -	      .byte	$20+10
     45  637c					      ENDIF
     46  637c				  -	      IF	$30 = $F0
     47  637c				  -	      .byte	$40+10
     48  637c					      ENDIF
      0  637c					      NTSC_TO_PAL	$30, 10
      1  637c				  -	      IF	$30 = 0
      2  637c				  -	      .byte	$30+10
      3  637c					      ENDIF
      4  637c				  -	      IF	$30 = $10
      5  637c				  -	      .byte	$20+10
      6  637c					      ENDIF
      7  637c				  -	      IF	$30 = $20
      8  637c				  -	      .byte	$40+10
      9  637c					      ENDIF
     10  637c					      IF	$30 = $30
     11  637c		       4a		      .byte.b	$40+10
     12  637d					      ENDIF
     13  637d				  -	      IF	$30 = $40
     14  637d				  -	      .byte	$60+10
     15  637d					      ENDIF
     16  637d				  -	      IF	$30 = $50
     17  637d				  -	      .byte	$80+10
     18  637d					      ENDIF
     19  637d				  -	      IF	$30 = $60
     20  637d				  -	      .byte	$C0+10
     21  637d					      ENDIF
     22  637d				  -	      IF	$30 = $70
     23  637d				  -	      .byte	$D0+10
     24  637d					      ENDIF
     25  637d				  -	      IF	$30 = $80
     26  637d				  -	      .byte	$B0+10
     27  637d					      ENDIF
     28  637d				  -	      IF	$30 = $90
     29  637d				  -	      .byte	$90+10
     30  637d					      ENDIF
     31  637d				  -	      IF	$30 = $A0
     32  637d				  -	      .byte	$70+10
     33  637d					      ENDIF
     34  637d				  -	      IF	$30 = $B0
     35  637d				  -	      .byte	$50+10
     36  637d					      ENDIF
     37  637d				  -	      IF	$30 = $C0
     38  637d				  -	      .byte	$30+10
     39  637d					      ENDIF
     40  637d				  -	      IF	$30 = $D0
     41  637d				  -	      .byte	$30+10
     42  637d					      ENDIF
     43  637d				  -	      IF	$30 = $E0
     44  637d				  -	      .byte	$20+10
     45  637d					      ENDIF
     46  637d				  -	      IF	$30 = $F0
     47  637d				  -	      .byte	$40+10
     48  637d					      ENDIF
      0  637d					      NTSC_TO_PAL	$10, $C
      1  637d				  -	      IF	$10 = 0
      2  637d				  -	      .byte	$10+$C
      3  637d					      ENDIF
      4  637d					      IF	$10 = $10
      5  637d		       2c		      .byte.b	$20+$C
      6  637e					      ENDIF
      7  637e				  -	      IF	$10 = $20
      8  637e				  -	      .byte	$40+$C
      9  637e					      ENDIF
     10  637e				  -	      IF	$10 = $30
     11  637e				  -	      .byte	$40+$C
     12  637e					      ENDIF
     13  637e				  -	      IF	$10 = $40
     14  637e				  -	      .byte	$60+$C
     15  637e					      ENDIF
     16  637e				  -	      IF	$10 = $50
     17  637e				  -	      .byte	$80+$C
     18  637e					      ENDIF
     19  637e				  -	      IF	$10 = $60
     20  637e				  -	      .byte	$C0+$C
     21  637e					      ENDIF
     22  637e				  -	      IF	$10 = $70
     23  637e				  -	      .byte	$D0+$C
     24  637e					      ENDIF
     25  637e				  -	      IF	$10 = $80
     26  637e				  -	      .byte	$B0+$C
     27  637e					      ENDIF
     28  637e				  -	      IF	$10 = $90
     29  637e				  -	      .byte	$90+$C
     30  637e					      ENDIF
     31  637e				  -	      IF	$10 = $A0
     32  637e				  -	      .byte	$70+$C
     33  637e					      ENDIF
     34  637e				  -	      IF	$10 = $B0
     35  637e				  -	      .byte	$50+$C
     36  637e					      ENDIF
     37  637e				  -	      IF	$10 = $C0
     38  637e				  -	      .byte	$30+$C
     39  637e					      ENDIF
     40  637e				  -	      IF	$10 = $D0
     41  637e				  -	      .byte	$30+$C
     42  637e					      ENDIF
     43  637e				  -	      IF	$10 = $E0
     44  637e				  -	      .byte	$20+$C
     45  637e					      ENDIF
     46  637e				  -	      IF	$10 = $F0
     47  637e				  -	      .byte	$40+$C
     48  637e					      ENDIF
      0  637e					      NTSC_TO_PAL	$10, $C
      1  637e				  -	      IF	$10 = 0
      2  637e				  -	      .byte	$10+$C
      3  637e					      ENDIF
      4  637e					      IF	$10 = $10
      5  637e		       2c		      .byte.b	$20+$C
      6  637f					      ENDIF
      7  637f				  -	      IF	$10 = $20
      8  637f				  -	      .byte	$40+$C
      9  637f					      ENDIF
     10  637f				  -	      IF	$10 = $30
     11  637f				  -	      .byte	$40+$C
     12  637f					      ENDIF
     13  637f				  -	      IF	$10 = $40
     14  637f				  -	      .byte	$60+$C
     15  637f					      ENDIF
     16  637f				  -	      IF	$10 = $50
     17  637f				  -	      .byte	$80+$C
     18  637f					      ENDIF
     19  637f				  -	      IF	$10 = $60
     20  637f				  -	      .byte	$C0+$C
     21  637f					      ENDIF
     22  637f				  -	      IF	$10 = $70
     23  637f				  -	      .byte	$D0+$C
     24  637f					      ENDIF
     25  637f				  -	      IF	$10 = $80
     26  637f				  -	      .byte	$B0+$C
     27  637f					      ENDIF
     28  637f				  -	      IF	$10 = $90
     29  637f				  -	      .byte	$90+$C
     30  637f					      ENDIF
     31  637f				  -	      IF	$10 = $A0
     32  637f				  -	      .byte	$70+$C
     33  637f					      ENDIF
     34  637f				  -	      IF	$10 = $B0
     35  637f				  -	      .byte	$50+$C
     36  637f					      ENDIF
     37  637f				  -	      IF	$10 = $C0
     38  637f				  -	      .byte	$30+$C
     39  637f					      ENDIF
     40  637f				  -	      IF	$10 = $D0
     41  637f				  -	      .byte	$30+$C
     42  637f					      ENDIF
     43  637f				  -	      IF	$10 = $E0
     44  637f				  -	      .byte	$20+$C
     45  637f					      ENDIF
     46  637f				  -	      IF	$10 = $F0
     47  637f				  -	      .byte	$40+$C
     48  637f					      ENDIF
    649  637f
    650  637f
    651  637f		       00 00 00 00*xJoyMoveX  .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1,0,-1,1,0
    652  638f
    653  638f				   VBlankTime2x
    654  638f		       50 50		      .byte.b	80,80
    655  6391		       96 96		      .byte.b	150,150
    656  6393				   OverscanTime2X
    657  6393		       f5 f5		      .byte.b	245, 245
    658  6395		       78 78		      .byte.b	120, 120
    659  6397
    660  6397		       00 1b	   COLOUR_LINES =	27
    661  6397				   colvecX
    662  6397		       00 00 1b 1b	      .byte.b	0, 0, COLOUR_LINES, COLOUR_LINES
    663  639b
    664  639b
    665  639b							;blankDig ds COLOUR_LINES,0
    666  639b
    667  639b				   topcolour
    668  639b
    669  639b							;    .byte 0
    670  639b
    671  639b					      REPEAT	TOPHAT/2
    672  639b		       f2		      .byte.b	$F2
    673  639c		       f0		      .byte.b	$F0
    671  639c					      REPEND
    672  639d		       f2		      .byte.b	$F2
    673  639e		       f0		      .byte.b	$F0
    671  639e					      REPEND
    672  639f		       f2		      .byte.b	$F2
    673  63a0		       f0		      .byte.b	$F0
    671  63a0					      REPEND
    672  63a1		       f2		      .byte.b	$F2
    673  63a2		       f0		      .byte.b	$F0
    671  63a2					      REPEND
    672  63a3		       f2		      .byte.b	$F2
    673  63a4		       f0		      .byte.b	$F0
    671  63a4					      REPEND
    672  63a5		       f2		      .byte.b	$F2
    673  63a6		       f0		      .byte.b	$F0
    671  63a6					      REPEND
    672  63a7		       f2		      .byte.b	$F2
    673  63a8		       f0		      .byte.b	$F0
    671  63a8					      REPEND
    672  63a9		       f2		      .byte.b	$F2
    673  63aa		       f0		      .byte.b	$F0
    671  63aa					      REPEND
    672  63ab		       f2		      .byte.b	$F2
    673  63ac		       f0		      .byte.b	$F0
    674  63ad					      REPEND
    675  63ad
    676  63ad							;quest
    677  63ad							;    REPEAT 9
    678  63ad							;	  .byte $60,$60,$0
    679  63ad							;    REPEND
    680  63ad
    681  63ad				   LDIGIT
    682  63ad							;.word blankDig
    683  63ad		       28 f4		      .word.w	LEFT_0
    684  63af		       79 f4		      .word.w	LEFT_1
    685  63b1		       ca f4		      .word.w	LEFT_2
    686  63b3		       1b f5		      .word.w	LEFT_3
    687  63b5		       6c f5		      .word.w	LEFT_4
    688  63b7		       bd f5		      .word.w	LEFT_5
    689  63b9		       1b f6		      .word.w	LEFT_6
    690  63bb		       6c f6		      .word.w	LEFT_7
    691  63bd		       bd f6		      .word.w	LEFT_8
    692  63bf		       1b f7		      .word.w	LEFT_9
    693  63c1
    694  63c1				   RDIGIT
    695  63c1							;.word blankDig
    696  63c1		       43 f4		      .word.w	RIGHT_0
    697  63c3		       94 f4		      .word.w	RIGHT_1
    698  63c5		       e5 f4		      .word.w	RIGHT_2
    699  63c7		       36 f5		      .word.w	RIGHT_3
    700  63c9		       87 f5		      .word.w	RIGHT_4
    701  63cb		       d8 f5		      .word.w	RIGHT_5
    702  63cd		       36 f6		      .word.w	RIGHT_6
    703  63cf		       87 f6		      .word.w	RIGHT_7
    704  63d1		       d8 f6		      .word.w	RIGHT_8
    705  63d3		       36 f7		      .word.w	RIGHT_9
    706  63d5
    707  63d5				   DIGITHUND
    708  63d5							;.word blankDig
    709  63d5		       5e f4		      .word.w	HUNDPF1_0
    710  63d7		       af f4		      .word.w	HUNDPF1_1
    711  63d9		       00 f5		      .word.w	HUNDPF1_2
    712  63db		       51 f5		      .word.w	HUNDPF1_3
    713  63dd		       a2 f5		      .word.w	HUNDPF1_4
    714  63df		       00 f6		      .word.w	HUNDPF1_5
    715  63e1		       51 f6		      .word.w	HUNDPF1_6
    716  63e3		       a2 f6		      .word.w	HUNDPF1_7
    717  63e5		       00 f7		      .word.w	HUNDPF1_8
    718  63e7		       51 f7		      .word.w	HUNDPF1_9
    719  63e9							;	  .word blankDig
    720  63e9
    721  63e9
    722  63e9				   lid0
    723  63e9		       e0		      .byte.b	%11100000
    724  63ea		       e0		      .byte.b	%11100000
    725  63eb		       e0		      .byte.b	%11100000
    726  63ec		       e0		      .byte.b	%11100000
    727  63ed		       e0		      .byte.b	%11100000
    728  63ee		       e0		      .byte.b	%11100000
    729  63ef		       60		      .byte.b	%01100000
    730  63f0		       60		      .byte.b	%01100000
    731  63f1		       60		      .byte.b	%01100000
    732  63f2		       60		      .byte.b	%01100000
    733  63f3		       60		      .byte.b	%01100000
    734  63f4		       60		      .byte.b	%01100000
    735  63f5		       60		      .byte.b	%01100000
    736  63f6		       e0		      .byte.b	%11100000
    737  63f7		       e0		      .byte.b	%11100000
    738  63f8		       e0		      .byte.b	%11100000
    739  63f9		       e0		      .byte.b	%11100000
    740  63fa		       e0		      .byte.b	%11100000
    741  63fb
    742  63fb				   lid1
    743  63fb				   lid2
    744  63fb		       ff		      .byte.b	%11111111
    745  63fc		       ff		      .byte.b	%11111111
    746  63fd		       ff		      .byte.b	%11111111
    747  63fe		       ff		      .byte.b	%11111111
    748  63ff		       ff		      .byte.b	%11111111
    749  6400		       ff		      .byte.b	%11111111
    750  6401		       ff		      .byte.b	%11111111
    751  6402		       ff		      .byte.b	%11111111
    752  6403		       ff		      .byte.b	%11111111
    753  6404		       f7		      .byte.b	%11110111
    754  6405		       f7		      .byte.b	%11110111
    755  6406		       f7		      .byte.b	%11110111
    756  6407		       f7		      .byte.b	%11110111
    757  6408		       ff		      .byte.b	%11111111
    758  6409		       ff		      .byte.b	%11111111
    759  640a		       ff		      .byte.b	%11111111
    760  640b		       ff		      .byte.b	%11111111
    761  640c		       c3		      .byte.b	%11000011
    762  640d
    763  640d				   lid3
    764  640d				   lid4
    765  640d		       ff		      .byte.b	%11111111
    766  640e		       ff		      .byte.b	%11111111
    767  640f		       ff		      .byte.b	%11111111
    768  6410		       ff		      .byte.b	%11111111
    769  6411		       ff		      .byte.b	%11111111
    770  6412		       ff		      .byte.b	%11111111
    771  6413		       ff		      .byte.b	%11111111
    772  6414		       ff		      .byte.b	%11111111
    773  6415		       ff		      .byte.b	%11111111
    774  6416		       f7		      .byte.b	%11110111
    775  6417		       f7		      .byte.b	%11110111
    776  6418		       f7		      .byte.b	%11110111
    777  6419		       f7		      .byte.b	%11110111
    778  641a		       ff		      .byte.b	%11111111
    779  641b		       ff		      .byte.b	%11111111
    780  641c		       ff		      .byte.b	%11111111
    781  641d		       ff		      .byte.b	%11111111
    782  641e		       c3		      .byte.b	%11000011
    783  641f
    784  641f				  -	      if	0
    785  641f				  -	      .byte	%11111111
    786  641f				  -	      .byte	%11111111
    787  641f				  -	      .byte	%11111111
    788  641f				  -	      .byte	%11111111
    789  641f				  -	      .byte	%11111111
    790  641f				  -	      .byte	%11111111
    791  641f				  -	      .byte	%11111011
    792  641f				  -	      .byte	%11111011
    793  641f				  -	      .byte	%11111011
    794  641f				  -	      .byte	%11111011
    795  641f				  -	      .byte	%11111011
    796  641f				  -	      .byte	%11111011
    797  641f				  -	      .byte	%11111011
    798  641f				  -	      .byte	%11111111
    799  641f				  -	      .byte	%11111111
    800  641f				  -	      .byte	%11111111
    801  641f				  -	      .byte	%11111111
    802  641f				  -	      .byte	%11000011
    803  641f					      endif
    804  641f
    805  641f				   lidb0
    806  641f				   lidb1
    807  641f				   lidb2
    808  641f				   lidb3
    809  641f				   lidb4
    810  641f
    811  641f		       aa		      .byte.b	%10101010
    812  6420		       ff		      .byte.b	%11111111
    813  6421		       ff		      .byte.b	%11111111
    814  6422		       ff		      .byte.b	%11111111
    815  6423		       ff		      .byte.b	%11111111
    816  6424		       ff		      .byte.b	%11111111
    817  6425		       ff		      .byte.b	%11111111
    818  6426		       ff		      .byte.b	%11111111
    819  6427		       ff		      .byte.b	%11111111
    820  6428
    821  6428
------- FILE bigDigits.asm LEVEL 3 PASS 3
      0  6428					      include	"bigDigits.asm"
      0  6428					      OPTIONAL_PAGEBREAK	"LEFT_0", 27
     10  6428					      LIST	ON
      2  6428				   LEFT_0
      3  6428		       38		      .byte.b	56
      4  6429		       7c		      .byte.b	124
      5  642a		       7c		      .byte.b	124
      6  642b		       fe		      .byte.b	254
      7  642c		       ee		      .byte.b	238
      8  642d		       c6		      .byte.b	198
      9  642e		       c6		      .byte.b	198
     10  642f		       c6		      .byte.b	198
     11  6430		       c6		      .byte.b	198
     12  6431		       c6		      .byte.b	198
     13  6432		       c6		      .byte.b	198
     14  6433		       c6		      .byte.b	198
     15  6434		       c6		      .byte.b	198
     16  6435		       c6		      .byte.b	198
     17  6436		       c6		      .byte.b	198
     18  6437		       c6		      .byte.b	198
     19  6438		       c6		      .byte.b	198
     20  6439		       c6		      .byte.b	198
     21  643a		       c6		      .byte.b	198
     22  643b		       c6		      .byte.b	198
     23  643c		       c6		      .byte.b	198
     24  643d		       c6		      .byte.b	198
     25  643e		       ee		      .byte.b	238
     26  643f		       fe		      .byte.b	254
     27  6440		       7c		      .byte.b	124
     28  6441		       7c		      .byte.b	124
     29  6442		       38		      .byte.b	56
      0  6443					      OPTIONAL_PAGEBREAK	"RIGHT_0", 27
     10  6443					      LIST	ON
     31  6443				   RIGHT_0
     32  6443		       8c		      .byte.b	140
     33  6444		       ce		      .byte.b	206
     34  6445		       ce		      .byte.b	206
     35  6446		       ef		      .byte.b	239
     36  6447		       e7		      .byte.b	231
     37  6448		       63		      .byte.b	99
     38  6449		       63		      .byte.b	99
     39  644a		       63		      .byte.b	99
     40  644b		       63		      .byte.b	99
     41  644c		       63		      .byte.b	99
     42  644d		       63		      .byte.b	99
     43  644e		       63		      .byte.b	99
     44  644f		       63		      .byte.b	99
     45  6450		       63		      .byte.b	99
     46  6451		       63		      .byte.b	99
     47  6452		       63		      .byte.b	99
     48  6453		       63		      .byte.b	99
     49  6454		       63		      .byte.b	99
     50  6455		       63		      .byte.b	99
     51  6456		       63		      .byte.b	99
     52  6457		       63		      .byte.b	99
     53  6458		       63		      .byte.b	99
     54  6459		       e7		      .byte.b	231
     55  645a		       ef		      .byte.b	239
     56  645b		       ce		      .byte.b	206
     57  645c		       ce		      .byte.b	206
     58  645d		       8c		      .byte.b	140
      0  645e					      OPTIONAL_PAGEBREAK	"HUNDPF1_0", 27
     10  645e					      LIST	ON
     60  645e				   HUNDPF1_0
     61  645e		       1c		      .byte.b	28
     62  645f		       3e		      .byte.b	62
     63  6460		       3e		      .byte.b	62
     64  6461		       7f		      .byte.b	127
     65  6462		       77		      .byte.b	119
     66  6463		       63		      .byte.b	99
     67  6464		       63		      .byte.b	99
     68  6465		       63		      .byte.b	99
     69  6466		       63		      .byte.b	99
     70  6467		       63		      .byte.b	99
     71  6468		       63		      .byte.b	99
     72  6469		       63		      .byte.b	99
     73  646a		       63		      .byte.b	99
     74  646b		       63		      .byte.b	99
     75  646c		       63		      .byte.b	99
     76  646d		       63		      .byte.b	99
     77  646e		       63		      .byte.b	99
     78  646f		       63		      .byte.b	99
     79  6470		       63		      .byte.b	99
     80  6471		       63		      .byte.b	99
     81  6472		       63		      .byte.b	99
     82  6473		       63		      .byte.b	99
     83  6474		       77		      .byte.b	119
     84  6475		       7f		      .byte.b	127
     85  6476		       3e		      .byte.b	62
     86  6477		       3e		      .byte.b	62
     87  6478		       1c		      .byte.b	28
      0  6479					      OPTIONAL_PAGEBREAK	"LEFT_1", 27
     10  6479					      LIST	ON
     89  6479				   LEFT_1
     90  6479		       30		      .byte.b	48
     91  647a		       30		      .byte.b	48
     92  647b		       30		      .byte.b	48
     93  647c		       30		      .byte.b	48
     94  647d		       30		      .byte.b	48
     95  647e		       30		      .byte.b	48
     96  647f		       30		      .byte.b	48
     97  6480		       30		      .byte.b	48
     98  6481		       30		      .byte.b	48
     99  6482		       30		      .byte.b	48
    100  6483		       30		      .byte.b	48
    101  6484		       30		      .byte.b	48
    102  6485		       30		      .byte.b	48
    103  6486		       30		      .byte.b	48
    104  6487		       30		      .byte.b	48
    105  6488		       30		      .byte.b	48
    106  6489		       30		      .byte.b	48
    107  648a		       30		      .byte.b	48
    108  648b		       30		      .byte.b	48
    109  648c		       30		      .byte.b	48
    110  648d		       38		      .byte.b	56
    111  648e		       38		      .byte.b	56
    112  648f		       38		      .byte.b	56
    113  6490		       38		      .byte.b	56
    114  6491		       38		      .byte.b	56
    115  6492		       30		      .byte.b	48
    116  6493		       30		      .byte.b	48
      0  6494					      OPTIONAL_PAGEBREAK	"RIGHT_1", 27
     10  6494					      LIST	ON
    118  6494				   RIGHT_1
    119  6494		       0c		      .byte.b	12
    120  6495		       0c		      .byte.b	12
    121  6496		       0c		      .byte.b	12
    122  6497		       0c		      .byte.b	12
    123  6498		       0c		      .byte.b	12
    124  6499		       0c		      .byte.b	12
    125  649a		       0c		      .byte.b	12
    126  649b		       0c		      .byte.b	12
    127  649c		       0c		      .byte.b	12
    128  649d		       0c		      .byte.b	12
    129  649e		       0c		      .byte.b	12
    130  649f		       0c		      .byte.b	12
    131  64a0		       0c		      .byte.b	12
    132  64a1		       0c		      .byte.b	12
    133  64a2		       0c		      .byte.b	12
    134  64a3		       0c		      .byte.b	12
    135  64a4		       0c		      .byte.b	12
    136  64a5		       0c		      .byte.b	12
    137  64a6		       0c		      .byte.b	12
    138  64a7		       0c		      .byte.b	12
    139  64a8		       8c		      .byte.b	140
    140  64a9		       8c		      .byte.b	140
    141  64aa		       8c		      .byte.b	140
    142  64ab		       8c		      .byte.b	140
    143  64ac		       8c		      .byte.b	140
    144  64ad		       0c		      .byte.b	12
    145  64ae		       0c		      .byte.b	12
      0  64af					      OPTIONAL_PAGEBREAK	"HUNDPF1_1", 27
     10  64af					      LIST	ON
    147  64af				   HUNDPF1_1
    148  64af		       0c		      .byte.b	12
    149  64b0		       0c		      .byte.b	12
    150  64b1		       0c		      .byte.b	12
    151  64b2		       0c		      .byte.b	12
    152  64b3		       0c		      .byte.b	12
    153  64b4		       0c		      .byte.b	12
    154  64b5		       0c		      .byte.b	12
    155  64b6		       0c		      .byte.b	12
    156  64b7		       0c		      .byte.b	12
    157  64b8		       0c		      .byte.b	12
    158  64b9		       0c		      .byte.b	12
    159  64ba		       0c		      .byte.b	12
    160  64bb		       0c		      .byte.b	12
    161  64bc		       0c		      .byte.b	12
    162  64bd		       0c		      .byte.b	12
    163  64be		       0c		      .byte.b	12
    164  64bf		       0c		      .byte.b	12
    165  64c0		       0c		      .byte.b	12
    166  64c1		       0c		      .byte.b	12
    167  64c2		       0c		      .byte.b	12
    168  64c3		       1c		      .byte.b	28
    169  64c4		       1c		      .byte.b	28
    170  64c5		       1c		      .byte.b	28
    171  64c6		       1c		      .byte.b	28
    172  64c7		       1c		      .byte.b	28
    173  64c8		       0c		      .byte.b	12
    174  64c9		       0c		      .byte.b	12
      0  64ca					      OPTIONAL_PAGEBREAK	"LEFT_2", 27
     10  64ca					      LIST	ON
    176  64ca				   LEFT_2
    177  64ca		       fe		      .byte.b	254
    178  64cb		       fe		      .byte.b	254
    179  64cc		       fe		      .byte.b	254
    180  64cd		       fe		      .byte.b	254
    181  64ce		       c6		      .byte.b	198
    182  64cf		       06		      .byte.b	6
    183  64d0		       06		      .byte.b	6
    184  64d1		       06		      .byte.b	6
    185  64d2		       0e		      .byte.b	14
    186  64d3		       0e		      .byte.b	14
    187  64d4		       1c		      .byte.b	28
    188  64d5		       3c		      .byte.b	60
    189  64d6		       78		      .byte.b	120
    190  64d7		       70		      .byte.b	112
    191  64d8		       e0		      .byte.b	224
    192  64d9		       e0		      .byte.b	224
    193  64da		       c0		      .byte.b	192
    194  64db		       c0		      .byte.b	192
    195  64dc		       c0		      .byte.b	192
    196  64dd		       c6		      .byte.b	198
    197  64de		       c6		      .byte.b	198
    198  64df		       c6		      .byte.b	198
    199  64e0		       ee		      .byte.b	238
    200  64e1		       fe		      .byte.b	254
    201  64e2		       7c		      .byte.b	124
    202  64e3		       7c		      .byte.b	124
    203  64e4		       38		      .byte.b	56
      0  64e5					      OPTIONAL_PAGEBREAK	"RIGHT_2", 27
     10  64e5					      LIST	ON
    205  64e5				   RIGHT_2
    206  64e5		       ef		      .byte.b	239
    207  64e6		       ef		      .byte.b	239
    208  64e7		       ef		      .byte.b	239
    209  64e8		       ef		      .byte.b	239
    210  64e9		       63		      .byte.b	99
    211  64ea		       60		      .byte.b	96
    212  64eb		       60		      .byte.b	96
    213  64ec		       60		      .byte.b	96
    214  64ed		       e0		      .byte.b	224
    215  64ee		       e0		      .byte.b	224
    216  64ef		       c8		      .byte.b	200
    217  64f0		       cc		      .byte.b	204
    218  64f1		       8e		      .byte.b	142
    219  64f2		       0e		      .byte.b	14
    220  64f3		       07		      .byte.b	7
    221  64f4		       07		      .byte.b	7
    222  64f5		       03		      .byte.b	3
    223  64f6		       03		      .byte.b	3
    224  64f7		       03		      .byte.b	3
    225  64f8		       63		      .byte.b	99
    226  64f9		       63		      .byte.b	99
    227  64fa		       63		      .byte.b	99
    228  64fb		       e7		      .byte.b	231
    229  64fc		       ef		      .byte.b	239
    230  64fd		       ce		      .byte.b	206
    231  64fe		       ce		      .byte.b	206
    232  64ff		       8c		      .byte.b	140
      0  6500					      OPTIONAL_PAGEBREAK	"HUNDPF1_2", 27
     10  6500					      LIST	ON
    234  6500				   HUNDPF1_2
    235  6500		       7f		      .byte.b	127
    236  6501		       7f		      .byte.b	127
    237  6502		       7f		      .byte.b	127
    238  6503		       7f		      .byte.b	127
    239  6504		       63		      .byte.b	99
    240  6505		       60		      .byte.b	96
    241  6506		       60		      .byte.b	96
    242  6507		       60		      .byte.b	96
    243  6508		       70		      .byte.b	112
    244  6509		       70		      .byte.b	112
    245  650a		       38		      .byte.b	56
    246  650b		       3c		      .byte.b	60
    247  650c		       1e		      .byte.b	30
    248  650d		       0e		      .byte.b	14
    249  650e		       07		      .byte.b	7
    250  650f		       07		      .byte.b	7
    251  6510		       03		      .byte.b	3
    252  6511		       03		      .byte.b	3
    253  6512		       03		      .byte.b	3
    254  6513		       63		      .byte.b	99
    255  6514		       63		      .byte.b	99
    256  6515		       63		      .byte.b	99
    257  6516		       77		      .byte.b	119
    258  6517		       7f		      .byte.b	127
    259  6518		       3e		      .byte.b	62
    260  6519		       3e		      .byte.b	62
    261  651a		       1c		      .byte.b	28
      0  651b					      OPTIONAL_PAGEBREAK	"LEFT_3", 27
     10  651b					      LIST	ON
    263  651b				   LEFT_3
    264  651b		       38		      .byte.b	56
    265  651c		       7c		      .byte.b	124
    266  651d		       7c		      .byte.b	124
    267  651e		       fe		      .byte.b	254
    268  651f		       ee		      .byte.b	238
    269  6520		       c6		      .byte.b	198
    270  6521		       c6		      .byte.b	198
    271  6522		       c6		      .byte.b	198
    272  6523		       c0		      .byte.b	192
    273  6524		       c0		      .byte.b	192
    274  6525		       c0		      .byte.b	192
    275  6526		       e0		      .byte.b	224
    276  6527		       f8		      .byte.b	248
    277  6528		       78		      .byte.b	120
    278  6529		       78		      .byte.b	120
    279  652a		       f8		      .byte.b	248
    280  652b		       e0		      .byte.b	224
    281  652c		       c0		      .byte.b	192
    282  652d		       c0		      .byte.b	192
    283  652e		       c6		      .byte.b	198
    284  652f		       c6		      .byte.b	198
    285  6530		       c6		      .byte.b	198
    286  6531		       ee		      .byte.b	238
    287  6532		       fe		      .byte.b	254
    288  6533		       7c		      .byte.b	124
    289  6534		       7c		      .byte.b	124
    290  6535		       38		      .byte.b	56
      0  6536					      OPTIONAL_PAGEBREAK	"RIGHT_3", 27
     10  6536					      LIST	ON
    292  6536				   RIGHT_3
    293  6536		       8c		      .byte.b	140
    294  6537		       ce		      .byte.b	206
    295  6538		       ce		      .byte.b	206
    296  6539		       ef		      .byte.b	239
    297  653a		       e7		      .byte.b	231
    298  653b		       63		      .byte.b	99
    299  653c		       63		      .byte.b	99
    300  653d		       63		      .byte.b	99
    301  653e		       03		      .byte.b	3
    302  653f		       03		      .byte.b	3
    303  6540		       03		      .byte.b	3
    304  6541		       07		      .byte.b	7
    305  6542		       8f		      .byte.b	143
    306  6543		       8e		      .byte.b	142
    307  6544		       8e		      .byte.b	142
    308  6545		       8f		      .byte.b	143
    309  6546		       07		      .byte.b	7
    310  6547		       03		      .byte.b	3
    311  6548		       03		      .byte.b	3
    312  6549		       63		      .byte.b	99
    313  654a		       63		      .byte.b	99
    314  654b		       63		      .byte.b	99
    315  654c		       e7		      .byte.b	231
    316  654d		       ef		      .byte.b	239
    317  654e		       ce		      .byte.b	206
    318  654f		       ce		      .byte.b	206
    319  6550		       8c		      .byte.b	140
      0  6551					      OPTIONAL_PAGEBREAK	"HUNDPF1_3", 27
     10  6551					      LIST	ON
    321  6551				   HUNDPF1_3
    322  6551		       1c		      .byte.b	28
    323  6552		       3e		      .byte.b	62
    324  6553		       3e		      .byte.b	62
    325  6554		       7f		      .byte.b	127
    326  6555		       77		      .byte.b	119
    327  6556		       63		      .byte.b	99
    328  6557		       63		      .byte.b	99
    329  6558		       63		      .byte.b	99
    330  6559		       03		      .byte.b	3
    331  655a		       03		      .byte.b	3
    332  655b		       03		      .byte.b	3
    333  655c		       07		      .byte.b	7
    334  655d		       1f		      .byte.b	31
    335  655e		       1e		      .byte.b	30
    336  655f		       1e		      .byte.b	30
    337  6560		       1f		      .byte.b	31
    338  6561		       07		      .byte.b	7
    339  6562		       03		      .byte.b	3
    340  6563		       03		      .byte.b	3
    341  6564		       63		      .byte.b	99
    342  6565		       63		      .byte.b	99
    343  6566		       63		      .byte.b	99
    344  6567		       77		      .byte.b	119
    345  6568		       7f		      .byte.b	127
    346  6569		       3e		      .byte.b	62
    347  656a		       3e		      .byte.b	62
    348  656b		       1c		      .byte.b	28
      0  656c					      OPTIONAL_PAGEBREAK	"LEFT_4", 27
     10  656c					      LIST	ON
    350  656c				   LEFT_4
    351  656c		       60		      .byte.b	96
    352  656d		       60		      .byte.b	96
    353  656e		       60		      .byte.b	96
    354  656f		       60		      .byte.b	96
    355  6570		       60		      .byte.b	96
    356  6571		       fe		      .byte.b	254
    357  6572		       fe		      .byte.b	254
    358  6573		       fe		      .byte.b	254
    359  6574		       fe		      .byte.b	254
    360  6575		       66		      .byte.b	102
    361  6576		       66		      .byte.b	102
    362  6577		       66		      .byte.b	102
    363  6578		       66		      .byte.b	102
    364  6579		       6c		      .byte.b	108
    365  657a		       6c		      .byte.b	108
    366  657b		       6c		      .byte.b	108
    367  657c		       6c		      .byte.b	108
    368  657d		       78		      .byte.b	120
    369  657e		       78		      .byte.b	120
    370  657f		       78		      .byte.b	120
    371  6580		       78		      .byte.b	120
    372  6581		       70		      .byte.b	112
    373  6582		       70		      .byte.b	112
    374  6583		       70		      .byte.b	112
    375  6584		       70		      .byte.b	112
    376  6585		       60		      .byte.b	96
    377  6586		       60		      .byte.b	96
      0  6587					      OPTIONAL_PAGEBREAK	"RIGHT_4", 27
     10  6587					      LIST	ON
    379  6587				   RIGHT_4
    380  6587		       06		      .byte.b	6
    381  6588		       06		      .byte.b	6
    382  6589		       06		      .byte.b	6
    383  658a		       06		      .byte.b	6
    384  658b		       06		      .byte.b	6
    385  658c		       ef		      .byte.b	239
    386  658d		       ef		      .byte.b	239
    387  658e		       ef		      .byte.b	239
    388  658f		       ef		      .byte.b	239
    389  6590		       66		      .byte.b	102
    390  6591		       66		      .byte.b	102
    391  6592		       66		      .byte.b	102
    392  6593		       66		      .byte.b	102
    393  6594		       c6		      .byte.b	198
    394  6595		       c6		      .byte.b	198
    395  6596		       c6		      .byte.b	198
    396  6597		       c6		      .byte.b	198
    397  6598		       8e		      .byte.b	142
    398  6599		       8e		      .byte.b	142
    399  659a		       8e		      .byte.b	142
    400  659b		       8e		      .byte.b	142
    401  659c		       0e		      .byte.b	14
    402  659d		       0e		      .byte.b	14
    403  659e		       0e		      .byte.b	14
    404  659f		       0e		      .byte.b	14
    405  65a0		       06		      .byte.b	6
    406  65a1		       06		      .byte.b	6
      0  65a2					      OPTIONAL_PAGEBREAK	"HUNDPF1_4", 27
     10  65a2					      LIST	ON
    408  65a2				   HUNDPF1_4
    409  65a2		       06		      .byte.b	6
    410  65a3		       06		      .byte.b	6
    411  65a4		       06		      .byte.b	6
    412  65a5		       06		      .byte.b	6
    413  65a6		       06		      .byte.b	6
    414  65a7		       7f		      .byte.b	127
    415  65a8		       7f		      .byte.b	127
    416  65a9		       7f		      .byte.b	127
    417  65aa		       7f		      .byte.b	127
    418  65ab		       66		      .byte.b	102
    419  65ac		       66		      .byte.b	102
    420  65ad		       66		      .byte.b	102
    421  65ae		       66		      .byte.b	102
    422  65af		       36		      .byte.b	54
    423  65b0		       36		      .byte.b	54
    424  65b1		       36		      .byte.b	54
    425  65b2		       36		      .byte.b	54
    426  65b3		       1e		      .byte.b	30
    427  65b4		       1e		      .byte.b	30
    428  65b5		       1e		      .byte.b	30
    429  65b6		       1e		      .byte.b	30
    430  65b7		       0e		      .byte.b	14
    431  65b8		       0e		      .byte.b	14
    432  65b9		       0e		      .byte.b	14
    433  65ba		       0e		      .byte.b	14
    434  65bb		       06		      .byte.b	6
    435  65bc		       06		      .byte.b	6
      0  65bd					      OPTIONAL_PAGEBREAK	"LEFT_5", 27
     10  65bd					      LIST	ON
    437  65bd				   LEFT_5
    438  65bd		       38		      .byte.b	56
    439  65be		       7c		      .byte.b	124
    440  65bf		       7c		      .byte.b	124
    441  65c0		       fe		      .byte.b	254
    442  65c1		       ee		      .byte.b	238
    443  65c2		       c6		      .byte.b	198
    444  65c3		       c6		      .byte.b	198
    445  65c4		       c6		      .byte.b	198
    446  65c5		       c0		      .byte.b	192
    447  65c6		       c0		      .byte.b	192
    448  65c7		       c0		      .byte.b	192
    449  65c8		       c0		      .byte.b	192
    450  65c9		       c0		      .byte.b	192
    451  65ca		       c0		      .byte.b	192
    452  65cb		       e6		      .byte.b	230
    453  65cc		       fe		      .byte.b	254
    454  65cd		       7e		      .byte.b	126
    455  65ce		       7e		      .byte.b	126
    456  65cf		       36		      .byte.b	54
    457  65d0		       06		      .byte.b	6
    458  65d1		       06		      .byte.b	6
    459  65d2		       06		      .byte.b	6
    460  65d3		       c6		      .byte.b	198
    461  65d4		       fe		      .byte.b	254
    462  65d5		       fe		      .byte.b	254
    463  65d6		       fe		      .byte.b	254
    464  65d7		       fe		      .byte.b	254
      0  65d8					      OPTIONAL_PAGEBREAK	"RIGHT_5", 27
     10  65d8					      LIST	ON
    466  65d8				   RIGHT_5
    467  65d8		       8c		      .byte.b	140
    468  65d9		       ce		      .byte.b	206
    469  65da		       ce		      .byte.b	206
    470  65db		       ef		      .byte.b	239
    471  65dc		       e7		      .byte.b	231
    472  65dd		       63		      .byte.b	99
    473  65de		       63		      .byte.b	99
    474  65df		       63		      .byte.b	99
    475  65e0		       03		      .byte.b	3
    476  65e1		       03		      .byte.b	3
    477  65e2		       03		      .byte.b	3
    478  65e3		       03		      .byte.b	3
    479  65e4		       03		      .byte.b	3
    480  65e5		       03		      .byte.b	3
    481  65e6		       67		      .byte.b	103
    482  65e7		       ef		      .byte.b	239
    483  65e8		       ee		      .byte.b	238
    484  65e9		       ee		      .byte.b	238
    485  65ea		       6c		      .byte.b	108
    486  65eb		       60		      .byte.b	96
    487  65ec		       60		      .byte.b	96
    488  65ed		       60		      .byte.b	96
    489  65ee		       63		      .byte.b	99
    490  65ef		       ef		      .byte.b	239
    491  65f0		       ef		      .byte.b	239
    492  65f1		       ef		      .byte.b	239
    493  65f2		       ef		      .byte.b	239
      0  65f3					      OPTIONAL_PAGEBREAK	"HUNDPF1_5", 27
 PAGE BREAK INSERTED FOR  HUNDPF1_5
 REQUESTED SIZE =  $1b
 WASTED SPACE =  $d
 PAGEBREAK LOCATION =  $f600
     10  6600					      LIST	ON
    495  6600				   HUNDPF1_5
    496  6600		       1c		      .byte.b	28
    497  6601		       3e		      .byte.b	62
    498  6602		       3e		      .byte.b	62
    499  6603		       7f		      .byte.b	127
    500  6604		       77		      .byte.b	119
    501  6605		       63		      .byte.b	99
    502  6606		       63		      .byte.b	99
    503  6607		       63		      .byte.b	99
    504  6608		       03		      .byte.b	3
    505  6609		       03		      .byte.b	3
    506  660a		       03		      .byte.b	3
    507  660b		       03		      .byte.b	3
    508  660c		       03		      .byte.b	3
    509  660d		       03		      .byte.b	3
    510  660e		       67		      .byte.b	103
    511  660f		       7f		      .byte.b	127
    512  6610		       7e		      .byte.b	126
    513  6611		       7e		      .byte.b	126
    514  6612		       6c		      .byte.b	108
    515  6613		       60		      .byte.b	96
    516  6614		       60		      .byte.b	96
    517  6615		       60		      .byte.b	96
    518  6616		       63		      .byte.b	99
    519  6617		       7f		      .byte.b	127
    520  6618		       7f		      .byte.b	127
    521  6619		       7f		      .byte.b	127
    522  661a		       7f		      .byte.b	127
      0  661b					      OPTIONAL_PAGEBREAK	"LEFT_6", 27
     10  661b					      LIST	ON
    524  661b				   LEFT_6
    525  661b		       38		      .byte.b	56
    526  661c		       7c		      .byte.b	124
    527  661d		       7c		      .byte.b	124
    528  661e		       fe		      .byte.b	254
    529  661f		       ee		      .byte.b	238
    530  6620		       c6		      .byte.b	198
    531  6621		       c6		      .byte.b	198
    532  6622		       c6		      .byte.b	198
    533  6623		       c6		      .byte.b	198
    534  6624		       c6		      .byte.b	198
    535  6625		       c6		      .byte.b	198
    536  6626		       ee		      .byte.b	238
    537  6627		       fe		      .byte.b	254
    538  6628		       7e		      .byte.b	126
    539  6629		       7e		      .byte.b	126
    540  662a		       36		      .byte.b	54
    541  662b		       06		      .byte.b	6
    542  662c		       06		      .byte.b	6
    543  662d		       0e		      .byte.b	14
    544  662e		       0c		      .byte.b	12
    545  662f		       0c		      .byte.b	12
    546  6630		       1c		      .byte.b	28
    547  6631		       1c		      .byte.b	28
    548  6632		       78		      .byte.b	120
    549  6633		       78		      .byte.b	120
    550  6634		       70		      .byte.b	112
    551  6635		       60		      .byte.b	96
      0  6636					      OPTIONAL_PAGEBREAK	"RIGHT_6", 27
     10  6636					      LIST	ON
    553  6636				   RIGHT_6
    554  6636		       8c		      .byte.b	140
    555  6637		       ce		      .byte.b	206
    556  6638		       ce		      .byte.b	206
    557  6639		       ef		      .byte.b	239
    558  663a		       e7		      .byte.b	231
    559  663b		       63		      .byte.b	99
    560  663c		       63		      .byte.b	99
    561  663d		       63		      .byte.b	99
    562  663e		       63		      .byte.b	99
    563  663f		       63		      .byte.b	99
    564  6640		       63		      .byte.b	99
    565  6641		       e7		      .byte.b	231
    566  6642		       ef		      .byte.b	239
    567  6643		       ee		      .byte.b	238
    568  6644		       ee		      .byte.b	238
    569  6645		       6c		      .byte.b	108
    570  6646		       60		      .byte.b	96
    571  6647		       60		      .byte.b	96
    572  6648		       e0		      .byte.b	224
    573  6649		       c0		      .byte.b	192
    574  664a		       c0		      .byte.b	192
    575  664b		       c8		      .byte.b	200
    576  664c		       c8		      .byte.b	200
    577  664d		       8e		      .byte.b	142
    578  664e		       8e		      .byte.b	142
    579  664f		       0e		      .byte.b	14
    580  6650		       06		      .byte.b	6
      0  6651					      OPTIONAL_PAGEBREAK	"HUNDPF1_6", 27
     10  6651					      LIST	ON
    582  6651				   HUNDPF1_6
    583  6651		       1c		      .byte.b	28
    584  6652		       3e		      .byte.b	62
    585  6653		       3e		      .byte.b	62
    586  6654		       7f		      .byte.b	127
    587  6655		       77		      .byte.b	119
    588  6656		       63		      .byte.b	99
    589  6657		       63		      .byte.b	99
    590  6658		       63		      .byte.b	99
    591  6659		       63		      .byte.b	99
    592  665a		       63		      .byte.b	99
    593  665b		       63		      .byte.b	99
    594  665c		       77		      .byte.b	119
    595  665d		       7f		      .byte.b	127
    596  665e		       7e		      .byte.b	126
    597  665f		       7e		      .byte.b	126
    598  6660		       6c		      .byte.b	108
    599  6661		       60		      .byte.b	96
    600  6662		       60		      .byte.b	96
    601  6663		       70		      .byte.b	112
    602  6664		       30		      .byte.b	48
    603  6665		       30		      .byte.b	48
    604  6666		       38		      .byte.b	56
    605  6667		       38		      .byte.b	56
    606  6668		       1e		      .byte.b	30
    607  6669		       1e		      .byte.b	30
    608  666a		       0e		      .byte.b	14
    609  666b		       06		      .byte.b	6
      0  666c					      OPTIONAL_PAGEBREAK	"LEFT_7", 27
     10  666c					      LIST	ON
    611  666c				   LEFT_7
    612  666c		       18		      .byte.b	24
    613  666d		       18		      .byte.b	24
    614  666e		       18		      .byte.b	24
    615  666f		       18		      .byte.b	24
    616  6670		       18		      .byte.b	24
    617  6671		       18		      .byte.b	24
    618  6672		       18		      .byte.b	24
    619  6673		       18		      .byte.b	24
    620  6674		       18		      .byte.b	24
    621  6675		       18		      .byte.b	24
    622  6676		       18		      .byte.b	24
    623  6677		       30		      .byte.b	48
    624  6678		       30		      .byte.b	48
    625  6679		       30		      .byte.b	48
    626  667a		       30		      .byte.b	48
    627  667b		       60		      .byte.b	96
    628  667c		       60		      .byte.b	96
    629  667d		       60		      .byte.b	96
    630  667e		       60		      .byte.b	96
    631  667f		       c0		      .byte.b	192
    632  6680		       c0		      .byte.b	192
    633  6681		       c0		      .byte.b	192
    634  6682		       c6		      .byte.b	198
    635  6683		       fe		      .byte.b	254
    636  6684		       fe		      .byte.b	254
    637  6685		       fe		      .byte.b	254
    638  6686		       fe		      .byte.b	254
      0  6687					      OPTIONAL_PAGEBREAK	"RIGHT_7", 27
     10  6687					      LIST	ON
    640  6687				   RIGHT_7
    641  6687		       88		      .byte.b	136
    642  6688		       88		      .byte.b	136
    643  6689		       88		      .byte.b	136
    644  668a		       88		      .byte.b	136
    645  668b		       88		      .byte.b	136
    646  668c		       88		      .byte.b	136
    647  668d		       88		      .byte.b	136
    648  668e		       88		      .byte.b	136
    649  668f		       88		      .byte.b	136
    650  6690		       88		      .byte.b	136
    651  6691		       88		      .byte.b	136
    652  6692		       0c		      .byte.b	12
    653  6693		       0c		      .byte.b	12
    654  6694		       0c		      .byte.b	12
    655  6695		       0c		      .byte.b	12
    656  6696		       06		      .byte.b	6
    657  6697		       06		      .byte.b	6
    658  6698		       06		      .byte.b	6
    659  6699		       06		      .byte.b	6
    660  669a		       03		      .byte.b	3
    661  669b		       03		      .byte.b	3
    662  669c		       03		      .byte.b	3
    663  669d		       63		      .byte.b	99
    664  669e		       ef		      .byte.b	239
    665  669f		       ef		      .byte.b	239
    666  66a0		       ef		      .byte.b	239
    667  66a1		       ef		      .byte.b	239
      0  66a2					      OPTIONAL_PAGEBREAK	"HUNDPF1_7", 27
     10  66a2					      LIST	ON
    669  66a2				   HUNDPF1_7
    670  66a2		       18		      .byte.b	24
    671  66a3		       18		      .byte.b	24
    672  66a4		       18		      .byte.b	24
    673  66a5		       18		      .byte.b	24
    674  66a6		       18		      .byte.b	24
    675  66a7		       18		      .byte.b	24
    676  66a8		       18		      .byte.b	24
    677  66a9		       18		      .byte.b	24
    678  66aa		       18		      .byte.b	24
    679  66ab		       18		      .byte.b	24
    680  66ac		       18		      .byte.b	24
    681  66ad		       0c		      .byte.b	12
    682  66ae		       0c		      .byte.b	12
    683  66af		       0c		      .byte.b	12
    684  66b0		       0c		      .byte.b	12
    685  66b1		       06		      .byte.b	6
    686  66b2		       06		      .byte.b	6
    687  66b3		       06		      .byte.b	6
    688  66b4		       06		      .byte.b	6
    689  66b5		       03		      .byte.b	3
    690  66b6		       03		      .byte.b	3
    691  66b7		       03		      .byte.b	3
    692  66b8		       63		      .byte.b	99
    693  66b9		       7f		      .byte.b	127
    694  66ba		       7f		      .byte.b	127
    695  66bb		       7f		      .byte.b	127
    696  66bc		       7f		      .byte.b	127
      0  66bd					      OPTIONAL_PAGEBREAK	"LEFT_8", 27
     10  66bd					      LIST	ON
    698  66bd				   LEFT_8
    699  66bd		       38		      .byte.b	56
    700  66be		       7c		      .byte.b	124
    701  66bf		       7c		      .byte.b	124
    702  66c0		       fe		      .byte.b	254
    703  66c1		       ee		      .byte.b	238
    704  66c2		       c6		      .byte.b	198
    705  66c3		       c6		      .byte.b	198
    706  66c4		       c6		      .byte.b	198
    707  66c5		       c6		      .byte.b	198
    708  66c6		       c6		      .byte.b	198
    709  66c7		       c6		      .byte.b	198
    710  66c8		       ee		      .byte.b	238
    711  66c9		       fc		      .byte.b	252
    712  66ca		       7c		      .byte.b	124
    713  66cb		       7e		      .byte.b	126
    714  66cc		       ee		      .byte.b	238
    715  66cd		       c6		      .byte.b	198
    716  66ce		       c6		      .byte.b	198
    717  66cf		       c6		      .byte.b	198
    718  66d0		       c6		      .byte.b	198
    719  66d1		       c6		      .byte.b	198
    720  66d2		       c6		      .byte.b	198
    721  66d3		       ee		      .byte.b	238
    722  66d4		       fe		      .byte.b	254
    723  66d5		       7c		      .byte.b	124
    724  66d6		       7c		      .byte.b	124
    725  66d7		       38		      .byte.b	56
      0  66d8					      OPTIONAL_PAGEBREAK	"RIGHT_8", 27
     10  66d8					      LIST	ON
    727  66d8				   RIGHT_8
    728  66d8		       8c		      .byte.b	140
    729  66d9		       ce		      .byte.b	206
    730  66da		       ce		      .byte.b	206
    731  66db		       ef		      .byte.b	239
    732  66dc		       e7		      .byte.b	231
    733  66dd		       63		      .byte.b	99
    734  66de		       63		      .byte.b	99
    735  66df		       63		      .byte.b	99
    736  66e0		       63		      .byte.b	99
    737  66e1		       63		      .byte.b	99
    738  66e2		       63		      .byte.b	99
    739  66e3		       e7		      .byte.b	231
    740  66e4		       cf		      .byte.b	207
    741  66e5		       ce		      .byte.b	206
    742  66e6		       ee		      .byte.b	238
    743  66e7		       e7		      .byte.b	231
    744  66e8		       63		      .byte.b	99
    745  66e9		       63		      .byte.b	99
    746  66ea		       63		      .byte.b	99
    747  66eb		       63		      .byte.b	99
    748  66ec		       63		      .byte.b	99
    749  66ed		       63		      .byte.b	99
    750  66ee		       e7		      .byte.b	231
    751  66ef		       ef		      .byte.b	239
    752  66f0		       ce		      .byte.b	206
    753  66f1		       ce		      .byte.b	206
    754  66f2		       8c		      .byte.b	140
      0  66f3					      OPTIONAL_PAGEBREAK	"HUNDPF1_8", 27
 PAGE BREAK INSERTED FOR  HUNDPF1_8
 REQUESTED SIZE =  $1b
 WASTED SPACE =  $d
 PAGEBREAK LOCATION =  $f700
     10  6700					      LIST	ON
    756  6700				   HUNDPF1_8
    757  6700		       1c		      .byte.b	28
    758  6701		       3e		      .byte.b	62
    759  6702		       3e		      .byte.b	62
    760  6703		       7f		      .byte.b	127
    761  6704		       77		      .byte.b	119
    762  6705		       63		      .byte.b	99
    763  6706		       63		      .byte.b	99
    764  6707		       63		      .byte.b	99
    765  6708		       63		      .byte.b	99
    766  6709		       63		      .byte.b	99
    767  670a		       63		      .byte.b	99
    768  670b		       77		      .byte.b	119
    769  670c		       3f		      .byte.b	63
    770  670d		       3e		      .byte.b	62
    771  670e		       7e		      .byte.b	126
    772  670f		       77		      .byte.b	119
    773  6710		       63		      .byte.b	99
    774  6711		       63		      .byte.b	99
    775  6712		       63		      .byte.b	99
    776  6713		       63		      .byte.b	99
    777  6714		       63		      .byte.b	99
    778  6715		       63		      .byte.b	99
    779  6716		       77		      .byte.b	119
    780  6717		       7f		      .byte.b	127
    781  6718		       3e		      .byte.b	62
    782  6719		       3e		      .byte.b	62
    783  671a		       1c		      .byte.b	28
      0  671b					      OPTIONAL_PAGEBREAK	"LEFT_9", 27
     10  671b					      LIST	ON
    785  671b				   LEFT_9
    786  671b		       0c		      .byte.b	12
    787  671c		       1c		      .byte.b	28
    788  671d		       3c		      .byte.b	60
    789  671e		       3c		      .byte.b	60
    790  671f		       70		      .byte.b	112
    791  6720		       70		      .byte.b	112
    792  6721		       60		      .byte.b	96
    793  6722		       e0		      .byte.b	224
    794  6723		       e0		      .byte.b	224
    795  6724		       c0		      .byte.b	192
    796  6725		       c0		      .byte.b	192
    797  6726		       d8		      .byte.b	216
    798  6727		       fc		      .byte.b	252
    799  6728		       fc		      .byte.b	252
    800  6729		       fe		      .byte.b	254
    801  672a		       ee		      .byte.b	238
    802  672b		       c6		      .byte.b	198
    803  672c		       c6		      .byte.b	198
    804  672d		       c6		      .byte.b	198
    805  672e		       c6		      .byte.b	198
    806  672f		       c6		      .byte.b	198
    807  6730		       c6		      .byte.b	198
    808  6731		       ee		      .byte.b	238
    809  6732		       fe		      .byte.b	254
    810  6733		       7c		      .byte.b	124
    811  6734		       7c		      .byte.b	124
    812  6735		       38		      .byte.b	56
      0  6736					      OPTIONAL_PAGEBREAK	"RIGHT_9", 27
     10  6736					      LIST	ON
    814  6736				   RIGHT_9
    815  6736		       c0		      .byte.b	192
    816  6737		       c8		      .byte.b	200
    817  6738		       cc		      .byte.b	204
    818  6739		       cc		      .byte.b	204
    819  673a		       0e		      .byte.b	14
    820  673b		       0e		      .byte.b	14
    821  673c		       06		      .byte.b	6
    822  673d		       07		      .byte.b	7
    823  673e		       07		      .byte.b	7
    824  673f		       03		      .byte.b	3
    825  6740		       03		      .byte.b	3
    826  6741		       8b		      .byte.b	139
    827  6742		       cf		      .byte.b	207
    828  6743		       cf		      .byte.b	207
    829  6744		       ef		      .byte.b	239
    830  6745		       e7		      .byte.b	231
    831  6746		       63		      .byte.b	99
    832  6747		       63		      .byte.b	99
    833  6748		       63		      .byte.b	99
    834  6749		       63		      .byte.b	99
    835  674a		       63		      .byte.b	99
    836  674b		       63		      .byte.b	99
    837  674c		       e7		      .byte.b	231
    838  674d		       ef		      .byte.b	239
    839  674e		       ce		      .byte.b	206
    840  674f		       ce		      .byte.b	206
    841  6750		       8c		      .byte.b	140
      0  6751					      OPTIONAL_PAGEBREAK	"HUNDPF1_9", 27
     10  6751					      LIST	ON
    843  6751				   HUNDPF1_9
    844  6751		       30		      .byte.b	48
    845  6752		       38		      .byte.b	56
    846  6753		       3c		      .byte.b	60
    847  6754		       3c		      .byte.b	60
    848  6755		       0e		      .byte.b	14
    849  6756		       0e		      .byte.b	14
    850  6757		       06		      .byte.b	6
    851  6758		       07		      .byte.b	7
    852  6759		       07		      .byte.b	7
    853  675a		       03		      .byte.b	3
    854  675b		       03		      .byte.b	3
    855  675c		       1b		      .byte.b	27
    856  675d		       3f		      .byte.b	63
    857  675e		       3f		      .byte.b	63
    858  675f		       7f		      .byte.b	127
    859  6760		       77		      .byte.b	119
    860  6761		       63		      .byte.b	99
    861  6762		       63		      .byte.b	99
    862  6763		       63		      .byte.b	99
    863  6764		       63		      .byte.b	99
    864  6765		       63		      .byte.b	99
    865  6766		       63		      .byte.b	99
    866  6767		       77		      .byte.b	119
    867  6768		       7f		      .byte.b	127
    868  6769		       3e		      .byte.b	62
    869  676a		       3e		      .byte.b	62
    870  676b		       1c		      .byte.b	28
      0  676c					      OPTIONAL_PAGEBREAK	"LEFT_star0", 27
     10  676c					      LIST	ON
    872  676c				   LEFT_star0
    873  676c		       2c		      .byte.b	44
    874  676d		       00		      .byte.b	0
    875  676e		       28		      .byte.b	40
    876  676f		       28		      .byte.b	40
    877  6770		       28		      .byte.b	40
    878  6771		       28		      .byte.b	40
    879  6772		       38		      .byte.b	56
    880  6773		       38		      .byte.b	56
    881  6774		       28		      .byte.b	40
    882  6775		       38		      .byte.b	56
    883  6776		       38		      .byte.b	56
    884  6777		       38		      .byte.b	56
    885  6778		       38		      .byte.b	56
    886  6779		       fe		      .byte.b	254
    887  677a		       fe		      .byte.b	254
    888  677b		       b2		      .byte.b	178
    889  677c		       ba		      .byte.b	186
    890  677d		       b2		      .byte.b	178
    891  677e		       30		      .byte.b	48
    892  677f		       18		      .byte.b	24
    893  6780		       14		      .byte.b	20
    894  6781		       08		      .byte.b	8
    895  6782		       3c		      .byte.b	60
    896  6783		       3a		      .byte.b	58
    897  6784		       00		      .byte.b	0
    898  6785		       00		      .byte.b	0
    899  6786		       00		      .byte.b	0
      0  6787					      OPTIONAL_PAGEBREAK	"LEFT_star1", 27
     10  6787					      LIST	ON
    901  6787				   LEFT_star1
    902  6787		       46		      .byte.b	70
    903  6788		       80		      .byte.b	128
    904  6789		       64		      .byte.b	100
    905  678a		       62		      .byte.b	98
    906  678b		       1e		      .byte.b	30
    907  678c		       3c		      .byte.b	60
    908  678d		       28		      .byte.b	40
    909  678e		       30		      .byte.b	48
    910  678f		       38		      .byte.b	56
    911  6790		       38		      .byte.b	56
    912  6791		       38		      .byte.b	56
    913  6792		       3c		      .byte.b	60
    914  6793		       3e		      .byte.b	62
    915  6794		       3f		      .byte.b	63
    916  6795		       19		      .byte.b	25
    917  6796		       19		      .byte.b	25
    918  6797		       1d		      .byte.b	29
    919  6798		       18		      .byte.b	24
    920  6799		       0c		      .byte.b	12
    921  679a		       0a		      .byte.b	10
    922  679b		       04		      .byte.b	4
    923  679c		       1e		      .byte.b	30
    924  679d		       1d		      .byte.b	29
    925  679e		       00		      .byte.b	0
    926  679f		       00		      .byte.b	0
    927  67a0		       00		      .byte.b	0
    928  67a1		       00		      .byte.b	0
      0  67a2					      OPTIONAL_PAGEBREAK	"LEFT_star2", 27
     10  67a2					      LIST	ON
    930  67a2				   LEFT_star2
    931  67a2		       26		      .byte.b	38
    932  67a3		       40		      .byte.b	64
    933  67a4		       34		      .byte.b	52
    934  67a5		       14		      .byte.b	20
    935  67a6		       14		      .byte.b	20
    936  67a7		       3c		      .byte.b	60
    937  67a8		       3c		      .byte.b	60
    938  67a9		       28		      .byte.b	40
    939  67aa		       30		      .byte.b	48
    940  67ab		       38		      .byte.b	56
    941  67ac		       38		      .byte.b	56
    942  67ad		       38		      .byte.b	56
    943  67ae		       3c		      .byte.b	60
    944  67af		       3e		      .byte.b	62
    945  67b0		       3f		      .byte.b	63
    946  67b1		       19		      .byte.b	25
    947  67b2		       19		      .byte.b	25
    948  67b3		       1d		      .byte.b	29
    949  67b4		       18		      .byte.b	24
    950  67b5		       0c		      .byte.b	12
    951  67b6		       0a		      .byte.b	10
    952  67b7		       04		      .byte.b	4
    953  67b8		       1e		      .byte.b	30
    954  67b9		       1d		      .byte.b	29
    955  67ba		       00		      .byte.b	0
    956  67bb		       00		      .byte.b	0
    957  67bc		       00		      .byte.b	0
      0  67bd					      OPTIONAL_PAGEBREAK	"LEFT_star3", 27
     10  67bd					      LIST	ON
    959  67bd				   LEFT_star3
    960  67bd		       46		      .byte.b	70
    961  67be		       80		      .byte.b	128
    962  67bf		       64		      .byte.b	100
    963  67c0		       72		      .byte.b	114
    964  67c1		       3e		      .byte.b	62
    965  67c2		       3c		      .byte.b	60
    966  67c3		       18		      .byte.b	24
    967  67c4		       30		      .byte.b	48
    968  67c5		       38		      .byte.b	56
    969  67c6		       38		      .byte.b	56
    970  67c7		       38		      .byte.b	56
    971  67c8		       3c		      .byte.b	60
    972  67c9		       3e		      .byte.b	62
    973  67ca		       3f		      .byte.b	63
    974  67cb		       19		      .byte.b	25
    975  67cc		       19		      .byte.b	25
    976  67cd		       1d		      .byte.b	29
    977  67ce		       18		      .byte.b	24
    978  67cf		       0c		      .byte.b	12
    979  67d0		       0a		      .byte.b	10
    980  67d1		       04		      .byte.b	4
    981  67d2		       1e		      .byte.b	30
    982  67d3		       1d		      .byte.b	29
    983  67d4		       00		      .byte.b	0
    984  67d5		       00		      .byte.b	0
    985  67d6		       00		      .byte.b	0
    986  67d7		       00		      .byte.b	0
------- FILE levelScreen.asm
    823  67d8
      0  67d8					      CHECK_BANK_SIZE	"LEVELSCREEN"
      1  67d8		       07 d8	   .TEMP      =	* - BANK_START
 LEVELSCREEN (2K) SIZE =  $7d8 , FREE= $28
      2  67d8					      ECHO	"LEVELSCREEN", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  67d8				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  67d8				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  67d8				  -	      ERR
      6  67d8					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 3
      0  67d8					      include	"BANK_INITBANK.asm"	; MUST be after banks that include levels -- otherwise MAX_LEVELBANK is not calculated properly
      1  67d8							;    Sokoboo - a Sokoban implementation
      2  67d8							;    using a generic tile-based display engine for the Atari 2600
      3  67d8							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  67d8							;
      5  67d8							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  67d8							;
      7  67d8							;    Code related to the generic tile-based display engine was developed by
      8  67d8							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  67d8							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  67d8							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  67d8							;
     12  67d8							;    Code related to music and sound effects uses the TIATracker music player
     13  67d8							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  67d8							;    directory for Apache licensing details.
     15  67d8							;
     16  67d8							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  67d8							;    See the copyright notices in the License directory for a list of level
     18  67d8							;    contributors.
     19  67d8							;
     20  67d8							;    Except where otherwise indicated, this software is released under the
     21  67d8							;    following licensing arrangement...
     22  67d8							;
     23  67d8							;    This program is free software: you can redistribute it and/or modify
     24  67d8							;    it under the terms of the GNU General Public License as published by
     25  67d8							;    the Free Software Foundation, either version 3 of the License, or
     26  67d8							;    (at your option) any later version.
     27  67d8							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  67d8
     29  67d8							;    This program is distributed in the hope that it will be useful,
     30  67d8							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  67d8							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  67d8							;    GNU General Public License for more details.
     33  67d8
      0  67d8					      NEWBANK	INITBANK
      1  6da7 ????				      SEG	INITBANK
      2  6800					      ORG	ORIGIN
      3  6800					      RORG	$F000
      4  6800				   BANK_START SET	*
      5  6800				   INITBANK   SET	ORIGIN / 2048
      6  6800				   ORIGIN     SET	ORIGIN + 2048
      7  6800				   _CURRENT_BANK SET	INITBANK
     35  6800
     36  6800		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
     37  6801
      0  6801					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  6801		       00 0d	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  6801					      SUBROUTINE
      3  6801				   BoardLineStartLO
     39  6801
     40  6801							; Gives the start address (LO) of each board line
     41  6801					      if	1
     42  6801				   .BOARD_LOCATION SET	Board
     43  6801					      REPEAT	SIZE_BOARD_Y
     44  6801				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6801				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6801					      ENDIF
     47  6801		       00		      .byte.b	<.BOARD_LOCATION
     48  6801				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6801					      REPEND
     44  6802				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6802				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6802					      ENDIF
     47  6802		       28		      .byte.b	<.BOARD_LOCATION
     48  6802				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6802					      REPEND
     44  6803				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6803				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6803					      ENDIF
     47  6803		       50		      .byte.b	<.BOARD_LOCATION
     48  6803				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6803					      REPEND
     44  6804				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6804				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6804					      ENDIF
     47  6804		       78		      .byte.b	<.BOARD_LOCATION
     48  6804				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6804					      REPEND
     44  6805				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6805				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6805					      ENDIF
     47  6805		       a0		      .byte.b	<.BOARD_LOCATION
     48  6805				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6805					      REPEND
     44  6806				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6806				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6806					      ENDIF
     47  6806		       c8		      .byte.b	<.BOARD_LOCATION
     48  6806				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6806					      REPEND
     44  6807					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6807				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6807					      ENDIF
     47  6807		       00		      .byte.b	<.BOARD_LOCATION
     48  6807				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6807					      REPEND
     44  6808				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6808				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6808					      ENDIF
     47  6808		       28		      .byte.b	<.BOARD_LOCATION
     48  6808				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6808					      REPEND
     44  6809				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6809				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6809					      ENDIF
     47  6809		       50		      .byte.b	<.BOARD_LOCATION
     48  6809				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6809					      REPEND
     44  680a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680a					      ENDIF
     47  680a		       78		      .byte.b	<.BOARD_LOCATION
     48  680a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680a					      REPEND
     44  680b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680b					      ENDIF
     47  680b		       a0		      .byte.b	<.BOARD_LOCATION
     48  680b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680b					      REPEND
     44  680c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680c					      ENDIF
     47  680c		       c8		      .byte.b	<.BOARD_LOCATION
     48  680c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680c					      REPEND
     44  680d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680d					      ENDIF
     47  680d		       00		      .byte.b	<.BOARD_LOCATION
     48  680d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680d					      REPEND
     44  680e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680e					      ENDIF
     47  680e		       28		      .byte.b	<.BOARD_LOCATION
     48  680e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680e					      REPEND
     44  680f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680f					      ENDIF
     47  680f		       50		      .byte.b	<.BOARD_LOCATION
     48  680f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680f					      REPEND
     44  6810				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6810				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6810					      ENDIF
     47  6810		       78		      .byte.b	<.BOARD_LOCATION
     48  6810				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6810					      REPEND
     44  6811				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6811				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6811					      ENDIF
     47  6811		       a0		      .byte.b	<.BOARD_LOCATION
     48  6811				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6811					      REPEND
     44  6812				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6812				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6812					      ENDIF
     47  6812		       c8		      .byte.b	<.BOARD_LOCATION
     48  6812				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6812					      REPEND
     44  6813					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6813				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6813					      ENDIF
     47  6813		       00		      .byte.b	<.BOARD_LOCATION
     48  6813				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6813					      REPEND
     44  6814				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6814				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6814					      ENDIF
     47  6814		       28		      .byte.b	<.BOARD_LOCATION
     48  6814				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6814					      REPEND
     44  6815				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6815				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6815					      ENDIF
     47  6815		       50		      .byte.b	<.BOARD_LOCATION
     48  6815				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6815					      REPEND
     44  6816				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6816				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6816					      ENDIF
     47  6816		       78		      .byte.b	<.BOARD_LOCATION
     48  6816				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     49  6817					      REPEND
      0  6817					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  6817					      LIST	ON
     51  6817
     52  6817		       03 a0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     53  6817					      endif
     54  6817
     55  6817							;------------------------------------------------------------------------------
     56  6817
     57  6817				   BoardLineStartHiR
     58  6817
     59  6817							; Gives the start address (HI) of each board line
     60  6817							; Note this caters for the memory wrapping when we go from bank to bank, as
     61  6817							; the board overlays multiple banks!
     62  6817
     63  6817				   .BOARD_LOCATION SET	Board
     64  6817					      REPEAT	SIZE_BOARD_Y
     65  6817				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6817				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6817					      ENDIF
     68  6817		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6817				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6817					      REPEND
     65  6818				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6818				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6818					      ENDIF
     68  6818		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6818				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6818					      REPEND
     65  6819				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6819				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6819					      ENDIF
     68  6819		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6819				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6819					      REPEND
     65  681a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681a					      ENDIF
     68  681a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681a					      REPEND
     65  681b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681b					      ENDIF
     68  681b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681b					      REPEND
     65  681c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681c					      ENDIF
     68  681c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681c					      REPEND
     65  681d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681d					      ENDIF
     68  681d		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681d					      REPEND
     65  681e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681e					      ENDIF
     68  681e		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681e					      REPEND
     65  681f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681f					      ENDIF
     68  681f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681f					      REPEND
     65  6820				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6820				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6820					      ENDIF
     68  6820		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6820				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6820					      REPEND
     65  6821				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6821				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6821					      ENDIF
     68  6821		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6821				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6821					      REPEND
     65  6822				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6822				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6822					      ENDIF
     68  6822		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6822				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6822					      REPEND
     65  6823					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6823				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6823					      ENDIF
     68  6823		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6823				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6823					      REPEND
     65  6824				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6824				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6824					      ENDIF
     68  6824		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6824				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6824					      REPEND
     65  6825				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6825				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6825					      ENDIF
     68  6825		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6825				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6825					      REPEND
     65  6826				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6826				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6826					      ENDIF
     68  6826		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6826				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6826					      REPEND
     65  6827				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6827				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6827					      ENDIF
     68  6827		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6827				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6827					      REPEND
     65  6828				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6828				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6828					      ENDIF
     68  6828		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6828				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6828					      REPEND
     65  6829					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6829				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6829					      ENDIF
     68  6829		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6829				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6829					      REPEND
     65  682a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  682a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  682a					      ENDIF
     68  682a		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  682a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  682a					      REPEND
     65  682b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  682b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  682b					      ENDIF
     68  682b		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  682b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  682b					      REPEND
     65  682c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  682c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  682c					      ENDIF
     68  682c		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  682c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     70  682d					      REPEND
      0  682d					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  682d					      LIST	ON
     72  682d							;------------------------------------------------------------------------------
     73  682d
     74  682d				   BoardLineStartHiW
     75  682d
     76  682d							; Gives the start address (HI) of each board line
     77  682d							; Note this caters for the memory wrapping when we go from bank to bank, as
     78  682d							; the board overlays multiple banks!
     79  682d
     80  682d				   .BOARD_LOCATION SET	Board
     81  682d					      REPEAT	SIZE_BOARD_Y
     82  682d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  682d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  682d					      ENDIF
     85  682d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  682d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  682d					      REPEND
     82  682e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  682e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  682e					      ENDIF
     85  682e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  682e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  682e					      REPEND
     82  682f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  682f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  682f					      ENDIF
     85  682f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  682f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  682f					      REPEND
     82  6830				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6830				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6830					      ENDIF
     85  6830		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6830				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6830					      REPEND
     82  6831				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6831				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6831					      ENDIF
     85  6831		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6831				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6831					      REPEND
     82  6832				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6832				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6832					      ENDIF
     85  6832		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6832				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6832					      REPEND
     82  6833					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6833				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6833					      ENDIF
     85  6833		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6833				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6833					      REPEND
     82  6834				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6834				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6834					      ENDIF
     85  6834		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6834				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6834					      REPEND
     82  6835				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6835				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6835					      ENDIF
     85  6835		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6835				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6835					      REPEND
     82  6836				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6836				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6836					      ENDIF
     85  6836		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6836				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6836					      REPEND
     82  6837				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6837				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6837					      ENDIF
     85  6837		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6837				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6837					      REPEND
     82  6838				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6838				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6838					      ENDIF
     85  6838		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6838				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6838					      REPEND
     82  6839					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6839				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6839					      ENDIF
     85  6839		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6839				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6839					      REPEND
     82  683a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683a					      ENDIF
     85  683a		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683a					      REPEND
     82  683b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683b					      ENDIF
     85  683b		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683b					      REPEND
     82  683c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683c					      ENDIF
     85  683c		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683c					      REPEND
     82  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683d					      ENDIF
     85  683d		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683d					      REPEND
     82  683e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683e					      ENDIF
     85  683e		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683e					      REPEND
     82  683f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683f					      ENDIF
     85  683f		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683f					      REPEND
     82  6840				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6840				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6840					      ENDIF
     85  6840		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6840				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6840					      REPEND
     82  6841				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6841				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6841					      ENDIF
     85  6841		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6841				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6841					      REPEND
     82  6842				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6842				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6842					      ENDIF
     85  6842		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6842				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     87  6843					      REPEND
      0  6843					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  6843					      LIST	ON
     89  6843
     90  6843							;------------------------------------------------------------------------------
     91  6843							;    IF MULTI_BANK_BOARD = YES
     92  6843							;BoardBank
     93  6843							;    ENDIF
     94  6843							; Gives the RAM bank of the start of the board row for a given row.
     95  6843
     96  6843				   .BOARD_LOCATION SET	Board - RAM_3E
     97  6843					      REPEAT	SIZE_BOARD_Y
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
    105  6843					      REPEND
    106  6843							;    IF MULTI_BANK_BOARD = YES
    107  6843							;    CHECKPAGEX BoardBank, "BoardBank in BANK_INITBANK.asm"
    108  6843							;    ENDIF
    109  6843
    110  6843
    111  6843							;------------------------------------------------------------------------------
    112  6843
    113  6843				   CopyROMShadowToRAM_F000
    114  6843		       a9 f0		      lda	#>$F000
    115  6845
      0  6845					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  6845		       00 0d	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  6845					      SUBROUTINE
      3  6845				   CopyROMShadowToRAM
    117  6845
    118  6845							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
    119  6845							; the variable definitions are in the ROM shadow because this allows auto-initialisation
    120  6845							; of the variable contents from ROM declarations, but still allows access to them as
    121  6845							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
    122  6845							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
    123  6845							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
    124  6845							; code co-lives in all banks and may run even as bankswitching occurs between those
    125  6845							; banks -- by the very code itself.
    126  6845
    127  6845							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
    128  6845		       85 bc		      sta	Board_AddressR+1
    129  6847		       86 d3		      stx	O_ROM_Source_Bank	; source bank
    130  6849		       84 c0		      sty	RAM_Bank	; destination bank
    131  684b
    132  684b		       a0 00		      ldy	#0
    133  684d		       84 bb		      sty	Board_AddressR
    134  684f		       84 bd		      sty	Board_AddressW
    135  6851		       a9 14		      lda	#>($1000+RAM_WRITE)
    136  6853		       85 be		      sta	Board_AddressW+1
    137  6855
    138  6855							; Iterate 4 pages (1K) for complete bank copy
    139  6855
    140  6855		       a9 04		      lda	#4
    141  6857		       85 d2		      sta	O_CopyCount
    142  6859
    143  6859		       84 d4	   CopyPage   sty	O_Index
    144  685b		       a5 d3		      lda	O_ROM_Source_Bank
    145  685d		       20 0f f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    146  6860							;tax
    147  6860		       a4 d4		      ldy	O_Index
    148  6862		       a6 c0		      ldx	RAM_Bank
    149  6864		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    150  6867
    151  6867		       a4 d4		      ldy	O_Index
    152  6869		       c8		      iny
    153  686a		       d0 ed		      bne	CopyPage
    154  686c
    155  686c		       e6 bc		      inc	Board_AddressR+1
    156  686e		       e6 be		      inc	Board_AddressW+1
    157  6870
    158  6870		       c6 d2		      dec	O_CopyCount
    159  6872		       d0 e5		      bne	CopyPage
    160  6874
    161  6874		       a4 c0		      ldy	RAM_Bank	; TODO: remove!?
    162  6876		       60		      rts
    163  6877
    164  6877
    165  6877							;------------------------------------------------------------------------------
      0  6877					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  6877		       00 0d	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  6877					      SUBROUTINE
      3  6877				   SetPlatformColours
    167  6877
    168  6877							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    169  6877							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    170  6877							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    171  6877							; addressing will not violate the page-crossing restriction of 3E.
    172  6877
    173  6877							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    174  6877
    175  6877		       a9 00		      lda	#<DrawTheScreen	; = 0
    176  6879		       85 bd		      sta	Board_AddressW
    177  687b		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    178  687d		       85 be		      sta	Board_AddressW+1
    179  687f
    180  687f							; first, set the x index (with last one being a RTS ($60))
    181  687f
    182  687f		       a6 c0		      ldx	RAM_Bank
    183  6881		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    184  6883		       d0 07		      bne	.skipPatch
    185  6885		       a9 60		      lda	#$60	; rts
    186  6887		       a0 41		      ldy	#<SELFMOD_X
    187  6889		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    188  688c				   .skipPatch
    189  688c		       a4 c0		      ldy	RAM_Bank
    190  688e		       60		      rts
    191  688f
    192  688f				   SelfModColOfsTbl
    193  688f		       53 86 1d 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    194  6892
    195  6892
    196  6892
    197  6892				   DrawLineStartLO
    198  6892
    199  6892							; Gives the start address of each line in the draw flags buffer
    200  6892
    201  6892				   .DRAW_LOCATION SET	DrawFlag
    202  6892					      REPEAT	SCREEN_LINES
    203  6892		       50		      .byte.b	<.DRAW_LOCATION
    204  6892				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    202  6892					      REPEND
    203  6893		       5a		      .byte.b	<.DRAW_LOCATION
    204  6893				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    202  6893					      REPEND
    203  6894		       64		      .byte.b	<.DRAW_LOCATION
    204  6894				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    202  6894					      REPEND
    203  6895		       6e		      .byte.b	<.DRAW_LOCATION
    204  6895				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    202  6895					      REPEND
    203  6896		       78		      .byte.b	<.DRAW_LOCATION
    204  6896				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    202  6896					      REPEND
    203  6897		       82		      .byte.b	<.DRAW_LOCATION
    204  6897				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    202  6897					      REPEND
    203  6898		       8c		      .byte.b	<.DRAW_LOCATION
    204  6898				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    202  6898					      REPEND
    203  6899		       96		      .byte.b	<.DRAW_LOCATION
    204  6899				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    205  689a					      REPEND
    206  689a
    207  689a
    208  689a							;------------------------------------------------------------------------------
    209  689a
      0  689a					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  689a		       00 0d	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  689a					      SUBROUTINE
      3  689a				   GetBoardAddressRW
    211  689a							; Must share same bank as BoardLineStart tables
    212  689a
    213  689a		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    214  689d		       85 bb		      sta	Board_AddressR	; 3
    215  689f		       85 bd		      sta	Board_AddressW	; 3
    216  68a1		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    217  68a4		       85 bc		      sta	Board_AddressR+1	; 3	     READ address
    218  68a6		       09 04		      ora	#>RAM_WRITE	; 2
    219  68a8		       85 be		      sta	Board_AddressW+1	; 3	     WRITE address
    220  68aa							;    IF MULTI_BANK_BOARD = YES
    221  68aa							;		  ldx BoardBank,y		  ; 4 = 26    switch this on return
    222  68aa							;    ELSE
    223  68aa		       a2 0d		      ldx	#BANK_BOARD	; 2
    224  68ac							;    ENDIF
    225  68ac		       60		      rts		; 6 = 32[-2]
    226  68ad
    227  68ad							;------------------------------------------------------------------------------
    228  68ad
      0  68ad					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  68ad		       00 0d	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  68ad					      SUBROUTINE
      3  68ad				   GetBoardAddressR
    230  68ad
    231  68ad		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    232  68b0		       85 bb		      sta	Board_AddressR	; 3
    233  68b2		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    234  68b5		       85 bc		      sta	Board_AddressR+1	; 3	 READ address
    235  68b7							;    IF MULTI_BANK_BOARD = YES
    236  68b7							;		  lda BoardBank,y		  ; 4	  switch this on return
    237  68b7							;    ELSE
    238  68b7		       a9 0d		      lda	#BANK_BOARD	; 2
    239  68b9							;    ENDIF
    240  68b9		       60		      rts		; 6[-2]
    241  68ba
    242  68ba							;------------------------------------------------------------------------------
    243  68ba
      0  68ba					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  68ba		       00 0d	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  68ba					      SUBROUTINE
      3  68ba				   GetBoardAddressW
    245  68ba
    246  68ba							; Must share same bank as BoardLineStart tables
    247  68ba
    248  68ba		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    249  68bd		       85 bd		      sta	Board_AddressW	;3
    250  68bf		       b9 2d f0 	      lda	BoardLineStartHiW,y	;4
    251  68c2		       85 be		      sta	Board_AddressW+1	;3 WRITE address
    252  68c4							;    IF MULTI_BANK_BOARD = YES
    253  68c4							;		  ldx BoardBank,y		  ;4 switch this on return
    254  68c4							;    ELSE
    255  68c4		       a2 0d		      ldx	#BANK_BOARD	;2
    256  68c6							;    ENDIF
    257  68c6		       60	   QRet       rts		;6
    258  68c7
    259  68c7							;-------------------------------------------------------------------------------
    260  68c7
    261  68c7
    262  68c7							;------------------------------------------------------------------------------
    263  68c7
    264  68c7		       e6 a4	   cannotPush inc	ManPushCounter
    265  68c9		       60		      rts
    266  68ca
      0  68ca					      DEFINE_SUBROUTINE	PushBox	; in INITBANK
      1  68ca		       00 0d	   BANK_PushBox =	_CURRENT_BANK
      2  68ca					      SUBROUTINE
      3  68ca				   PushBox
    268  68ca
    269  68ca							; X = restoration character for square we are moving TO
    270  68ca							; so, if X = CHARACTER_TARGET AND we move, THEN we are pushing a box off a target
    271  68ca							; A = this bank!
    272  68ca
    273  68ca		       85 bf		      sta	ROM_Bank
    274  68cc
    275  68cc		       a9 08		      lda	#ANIMATION_PUSH_ID
    276  68ce		       c5 a6		      cmp	ManAnimationID
    277  68d0		       f0 14		      beq	alreadyAnimPush
    278  68d2
      0  68d2					      LOAD_ANIMATION	PUSH
      1  68d2		       a9 2c		      lda	#<Animation_PUSH
      2  68d4		       85 9a		      sta	animation
      3  68d6		       a9 f2		      lda	#>Animation_PUSH
      4  68d8		       85 9b		      sta	animation+1
      5  68da		       a9 00		      lda	#0
      6  68dc		       85 9c		      sta	animation_delay
      7  68de		       a9 08		      lda	#ANIMATION_PUSH_ID
      8  68e0		       85 a6		      sta	ManAnimationID
      9  68e2
    280  68e2
    281  68e2		       a9 00		      lda	#0
    282  68e4		       85 a8		      sta	idleCount
    283  68e6
    284  68e6				   alreadyAnimPush
    285  68e6
    286  68e6
    287  68e6		       a5 a4		      lda	ManPushCounter
    288  68e8		       c9 06		      cmp	#PUSH_LIMIT
    289  68ea		       90 db		      bcc	cannotPush
    290  68ec
    291  68ec		       86 d4		      stx	restorationCharacter	; players new location's restore
    292  68ee
    293  68ee							; Determine if the box is pushable
    294  68ee							; we use the joystick to calculate the subsequent square
    295  68ee
    296  68ee		       a5 93		      lda	PreviousJoystick
    297  68f0		       4a		      lsr
    298  68f1		       4a		      lsr
    299  68f2		       4a		      lsr
    300  68f3		       4a		      lsr
    301  68f4		       a8		      tay
    302  68f5
    303  68f5		       b9 be f2 	      lda	JoyMoveX,y
    304  68f8		       f0 05		      beq	x0
    305  68fa		       b9 ce f2 	      lda	JoyMoveY,y
    306  68fd		       d0 c8		      bne	cannotPush	; avoid diagonal pushes!
    307  68ff
    308  68ff		       98	   x0	      tya
    309  6900		       48		      pha
    310  6901
    311  6901		       18		      clc
    312  6902		       a5 8a		      lda	POS_Y_NEW
    313  6904		       79 ce f2 	      adc	JoyMoveY,y
    314  6907		       85 88		      sta	POS_Y	; the box's pushed-to square
    315  6909		       a8		      tay
    316  690a		       20 9a f0 	      jsr	GetBoardAddressRW
    317  690d
    318  690d		       68		      pla
    319  690e		       a8		      tay
    320  690f
    321  690f		       18		      clc
    322  6910		       a5 89		      lda	POS_X_NEW
    323  6912		       79 be f2 	      adc	JoyMoveX,y
    324  6915		       85 87		      sta	POS_X	; the box's pushed-to square
    325  6917		       48		      pha
    326  6918		       a8		      tay
    327  6919
    328  6919							;    IF MULTI_BANK_BOARD = YES
    329  6919							;		  lda RAM_Bank
    330  6919							;    ELSE
    331  6919		       a9 0d		      lda	#BANK_BOARD	; 2
    332  691b							;    ENDIF
    333  691b		       20 14 f8 	      jsr	GetBoardCharacter	;6+20(A)
    334  691e		       68		      pla
    335  691f		       a8		      tay
    336  6920
    337  6920		       a9 02		      lda	#CHARACTER_BOX
    338  6922		       e0 00		      cpx	#CHARACTER_BLANK
    339  6924		       f0 0d		      beq	canPushTarget
    340  6926
    341  6926		       e0 03		      cpx	#CHARACTER_TARGET
    342  6928		       f0 04		      beq	decreaseTargets
    343  692a		       e0 04		      cpx	#CHARACTER_TARGET2
    344  692c		       d0 99		      bne	cannotPush
    345  692e
    346  692e							; Box is now on a target - so decrease the remaining targets
    347  692e
    348  692e		       20 f7 fc    decreaseTargets jsr	DeRegisterTarget
    349  6931		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    350  6933		       48	   canPushTarget pha
    351  6934
    352  6934							; If the box *WAS* on a target (restoration character = CHARACTER_TARGET)
    353  6934							; then we increase targets (as there is one more to get)
    354  6934
    355  6934		       a5 d4		      lda	restorationCharacter
    356  6936		       c9 03		      cmp	#CHARACTER_TARGET
    357  6938		       d0 03		      bne	notOnTargetAlready
    358  693a
    359  693a							; increase the required targets as box is leaving one
    360  693a
    361  693a		       20 ed fc 	      jsr	RegisterTarget
    362  693d
    363  693d				   notOnTargetAlready
    364  693d
    365  693d							; record the box takeback params for the player move to use
    366  693d
    367  693d		       86 91		      stx	TB_CHAR
    368  693f		       a5 87		      lda	POS_X
    369  6941		       85 8f		      sta	TB_PUSHX
    370  6943		       a5 88		      lda	POS_Y
    371  6945		       85 90		      sta	TB_PUSHY
    372  6947
    373  6947		       68		      pla		; new char to go on board in box's new position
    374  6948
    375  6948
    376  6948							;  IF MULTI_BANK_BOARD = YES
    377  6948							;		ldx RAM_Bank			  ; <-- this will never work calling from INITBANK!!!
    378  6948							;  ELSE
    379  6948		       a2 0d		      ldx	#BANK_BOARD	; 2
    380  694a							;  ENDIF
    381  694a		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)
    382  694d
    383  694d		       a5 8c		      lda	POS_VAR	; player's restoration character
    384  694f		       48		      pha
    385  6950
    386  6950							; Before the player moves to the new position, take away the box and replace with the
    387  6950							; character the box was sitting on (BLANK or TARGET). Then the player moves in "next"
    388  6950
    389  6950		       a5 8a		      lda	POS_Y_NEW
    390  6952		       85 88		      sta	POS_Y
    391  6954		       a5 89		      lda	POS_X_NEW
    392  6956		       85 87		      sta	POS_X
    393  6958		       a5 d4		      lda	restorationCharacter
    394  695a		       85 8c		      sta	POS_VAR
    395  695c		       20 df f8 	      jsr	PutCharacterAtXY	; put back BOX's restoration character
    396  695f
    397  695f		       68		      pla
    398  6960		       85 8c		      sta	POS_VAR
    399  6962
    400  6962							;START_SOUND SOUND_BOX
    401  6962
    402  6962							; Note: MovePlayer expects new position to be POS_X_NEW, POS_Y_NEW
    403  6962							; AND the current man's square to be ManX, ManY
    404  6962
    405  6962		       4c 33 f9 	      jmp	MovePlayer	; now there's a gap, player should move in
    406  6965
    407  6965
    408  6965							;------------------------------------------------------------------------------
    409  6965
    410  6965							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    411  6965							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    412  6965
    413  6965							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    414  6965
    415  6965							; if the creature dies then jump NextObject
    416  6965
    417  6965
    418  6965
    419  6965							;RDirY 	  .byte -1    ;,0,1,0
    420  6965							;RDirX 	  .byte 0,1   ;,0,-1
    421  6965							;DirPushModX	   .byte 0,-1,1,0
    422  6965							;DirPushModY	   .byte -1,0,0,1
    423  6965							;Directional	  .byte 1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    424  6965
    425  6965
    426  6965							;------------------------------------------------------------------------------
    427  6965
    428  6965							; the auto-calculation of these was causing DASM to get confused and abort assembling.
    429  6965							; I don't particularly know why; probably because of the level variable-size array and the values
    430  6965							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    431  6965
    432  6965		       00 00	   MANMODE_STARTUP =	0
    433  6965		       00 01	   MANMODE_NORMAL =	1
    434  6965		       00 02	   MANMODE_DEAD =	2
    435  6965		       00 03	   MANMODE_WAITING =	3
    436  6965		       00 04	   MANMODE_WAITING2 =	4
    437  6965		       00 05	   MANMODE_WAITING_NT =	5
    438  6965		       00 06	   MANMODE_WAITING_NT2 =	6
    439  6965		       00 07	   MANMODE_NEXTLEVEL =	7
    440  6965		       00 08	   MANMODE_NEXTLEVEL2 =	8
    441  6965		       00 09	   MANMODE_SWITCH =	9
    442  6965		       00 0a	   MANMODE_TURNAROUND =	10
    443  6965		       00 0b	   MANMODE_TURNAROUND2 =	11
    444  6965		       00 0c	   MANMODE_SWITCH2 =	12
    445  6965		       00 0d	   MANMODE_NEXTLEVEL3 =	13
    446  6965
    447  6965
    448  6965
    449  6965
      0  6965					      DEFINE_SUBROUTINE	ManProcess
      1  6965		       00 0d	   BANK_ManProcess =	_CURRENT_BANK
      2  6965					      SUBROUTINE
      3  6965				   ManProcess
    451  6965
    452  6965							; ManMode tells the player what it is currently doing.  State machine.
    453  6965
    454  6965							; Check the switches....
    455  6965							; RESET to restart this level
    456  6965							; SELECT to start next level
    457  6965
    458  6965		       ad 82 02 	      lda	SWCHB
    459  6968		       29 03		      and	#3
    460  696a		       aa		      tax
    461  696b		       bd 8e f1 	      lda	newMode,x
    462  696e		       30 02		      bmi	skipModeChange
    463  6970		       85 a1		      sta	ManMode
    464  6972				   skipModeChange
    465  6972
    466  6972		       20 00 f8 	      jsr	DrawTimeFromROM	; Z-flag == 0!
    467  6975
    468  6975		       38		      sec
    469  6976		       a5 b4		      lda	Throttle	;3
    470  6978		       e9 a0		      sbc	#MAX_THROTTLE	;2
    471  697a		       90 11		      bcc	DoNothing2	;2/3		 plenty of time left!
    472  697c		       85 b4		      sta	Throttle	;3 = 10	 save fractional 'left over' bit
    473  697e
    474  697e
    475  697e		       a4 a1		      ldy	ManMode
    476  6980		       b9 92 f1 	      lda	ManActionLO,y
    477  6983		       85 d2		      sta	actionVector
    478  6985		       b9 a0 f1 	      lda	ManActionHI,y
    479  6988		       85 d3		      sta	actionVector+1
    480  698a		       6c d2 00 	      jmp	(actionVector)
    481  698d
    482  698d		       60	   DoNothing2 rts
    483  698e
    484  698e		       ff 0c 04 ff newMode    .byte.b	-1, MANMODE_SWITCH2, MANMODE_WAITING2, -1
    485  6992
    486  6992				   ManActionLO
    487  6992		       d5		      .byte.b	<manStartup	; 0		 no timer
    488  6993		       03		      .byte.b	<normalMan	; 1		 timer
    489  6994		       00		      .byte.b	<0	; 2		 timer
    490  6995		       fe		      .byte.b	<waitingMan	; 3		 timer
    491  6996		       fe		      .byte.b	<waitingManPress	; 4		 timer
    492  6997		       fe		      .byte.b	<waitingMan	; 5		 no timer
    493  6998		       fe		      .byte.b	<waitingManPress	; 6		 no timer
    494  6999		       ae		      .byte.b	<nextLevelMan	; 7		 no timer
    495  699a		       bc		      .byte.b	<nextLevelMan2	; 8		 no timer
    496  699b		       d3		      .byte.b	<switchLevels	; 9		 no timer
    497  699c		       ae		      .byte.b	<TurnAround	; 10
    498  699d		       c7		      .byte.b	<TurnAround2	; 10
    499  699e		       b5		      .byte.b	<switchLevels2
    500  699f		       cb		      .byte.b	<nextLevelMan3
    501  69a0
    502  69a0				   ManActionHI
    503  69a0		       f1		      .byte.b	>manStartup	; no timer
    504  69a1		       f2		      .byte.b	>normalMan	; timer
    505  69a2		       00		      .byte.b	>0	; timer
    506  69a3		       f1		      .byte.b	>waitingMan	; timer
    507  69a4		       f1		      .byte.b	>waitingManPress	; timer
    508  69a5		       f1		      .byte.b	>waitingMan	; no timer
    509  69a6		       f1		      .byte.b	>waitingManPress	; no timer
    510  69a7		       fc		      .byte.b	>nextLevelMan	; no timer
    511  69a8		       fc		      .byte.b	>nextLevelMan2	; no timer
    512  69a9		       fc		      .byte.b	>switchLevels	;9  no timer
    513  69aa		       f1		      .byte.b	>TurnAround	; 10
    514  69ab		       f1		      .byte.b	>TurnAround2	; 10
    515  69ac		       fc		      .byte.b	>switchLevels2
    516  69ad		       fc		      .byte.b	>nextLevelMan3
    517  69ae
    518  69ae
      0  69ae					      DEFINE_SUBROUTINE	TurnAround
      1  69ae		       00 0d	   BANK_TurnAround =	_CURRENT_BANK
      2  69ae					      SUBROUTINE
      3  69ae				   TurnAround
    520  69ae
      0  69ae					      LOAD_ANIMATION	TURNAROUND
      1  69ae		       a9 12		      lda	#<Animation_TURNAROUND
      2  69b0		       85 9a		      sta	animation
      3  69b2		       a9 f2		      lda	#>Animation_TURNAROUND
      4  69b4		       85 9b		      sta	animation+1
      5  69b6		       a9 00		      lda	#0
      6  69b8		       85 9c		      sta	animation_delay
      7  69ba		       a9 0e		      lda	#ANIMATION_TURNAROUND_ID
      8  69bc		       85 a6		      sta	ManAnimationID
      9  69be
    522  69be
    523  69be		       a5 a2		      lda	ManLastDirection
    524  69c0		       85 a3		      sta	ManTurnStart
    525  69c2
    526  69c2		       a9 0b		      lda	#MANMODE_TURNAROUND2
    527  69c4		       85 a1		      sta	ManMode
    528  69c6		       60		      rts
    529  69c7
      0  69c7					      DEFINE_SUBROUTINE	TurnAround2
      1  69c7		       00 0d	   BANK_TurnAround2 =	_CURRENT_BANK
      2  69c7					      SUBROUTINE
      3  69c7				   TurnAround2
    531  69c7
    532  69c7		       a5 a3		      lda	ManTurnStart
    533  69c9		       c5 a2		      cmp	ManLastDirection
    534  69cb		       f0 07		      beq	notTurnedYet
    535  69cd
    536  69cd		       a9 01		      lda	#MANMODE_NORMAL
    537  69cf		       85 a1		      sta	ManMode
    538  69d1		       4c 03 f2 	      jmp	normalMan
    539  69d4
    540  69d4
    541  69d4		       60	   notTurnedYet rts
    542  69d5
    543  69d5
    544  69d5							;------------------------------------------------------------------------------
      0  69d5					      DEFINE_SUBROUTINE	manStartup
      1  69d5		       00 0d	   BANK_manStartup =	_CURRENT_BANK
      2  69d5					      SUBROUTINE
      3  69d5				   manStartup
    546  69d5
    547  69d5					      IF	WAIT_FOR_INITIAL_DRAW
    548  69d5							; Delay turning on the visible screen until the background has completed drawing.
    549  69d5							; This is simple - is there anything still in the draw stack?
    550  69d5		       a5 81		      lda	DrawStackPointer
    551  69d7		       10 04		      bpl	midDraw
    552  69d9		       a9 00		      lda	#0
    553  69db		       85 ae		      sta	blankState
    554  69dd				   midDraw
    555  69dd					      ENDIF
    556  69dd
    557  69dd		       a5 9d		      lda	ManX
    558  69df		       85 89		      sta	POS_X_NEW
    559  69e1		       a5 9e		      lda	ManY
    560  69e3		       85 8a		      sta	POS_Y_NEW
    561  69e5
    562  69e5		       a9 01		      lda	#MANMODE_NORMAL
    563  69e7		       85 a1		      sta	ManMode
    564  69e9
    565  69e9		       a9 00		      lda	#0
    566  69eb		       85 a8		      sta	idleCount
    567  69ed
      0  69ed					      LOAD_ANIMATION	IDLE
      1  69ed		       a9 3e		      lda	#<Animation_IDLE
      2  69ef		       85 9a		      sta	animation
      3  69f1		       a9 f0		      lda	#>Animation_IDLE
      4  69f3		       85 9b		      sta	animation+1
      5  69f5		       a9 00		      lda	#0
      6  69f7		       85 9c		      sta	animation_delay
      7  69f9		       a9 02		      lda	#ANIMATION_IDLE_ID
      8  69fb		       85 a6		      sta	ManAnimationID
      9  69fd
    569  69fd
    570  69fd				   RTS_CF
    571  69fd		       60		      rts
    572  69fe
    573  69fe							;------------------------------------------------------------------------------
    574  69fe
    575  69fe				   waitingMan
    576  69fe				   waitingManPress
    577  69fe
    578  69fe							;		  lda #50
    579  69fe							;		  sta ColourTimer
    580  69fe
    581  69fe							; RESET gets here
    582  69fe
    583  69fe							;lda NextLevelTrigger
    584  69fe							;ora #BIT_NEXTLIFE
    585  69fe
    586  69fe		       a9 00		      lda	#0
    587  6a00		       85 c2		      sta	NextLevelTrigger
    588  6a02		       60		      rts
    589  6a03
    590  6a03
    591  6a03							;------------------------------------------------------------------------------
    592  6a03							; Normal man state
    593  6a03
      0  6a03					      DEFINE_SUBROUTINE	normalMan
      1  6a03		       00 0d	   BANK_normalMan =	_CURRENT_BANK
      2  6a03					      SUBROUTINE
      3  6a03				   normalMan
    595  6a03
    596  6a03							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    597  6a03							; before exiting via (for example) look-around option :)
    598  6a03
    599  6a03		       a5 9d		      lda	ManX
    600  6a05		       85 89		      sta	POS_X_NEW
    601  6a07		       a5 9e		      lda	ManY
    602  6a09		       85 8a		      sta	POS_Y_NEW
    603  6a0b
    604  6a0b							;------------------------------------------------------------------------------
    605  6a0b							; Look around is triggered by holding down the fire button for a while, without any other
    606  6a0b							; joystick directions chosen. The variable LookingAround has a negative value ($FF) when looking
    607  6a0b							; is active. Otherwise, it is counting down to the time where it will trigger.
    608  6a0b
    609  6a0b		       00 00	   LOOK_DELAY =	0
    610  6a0b
    611  6a0b							;------------------------------------------------------------------------------
    612  6a0b							; Take-back is a press/release of the button, with the press being limited in duratino
    613  6a0b							; to allow the action to be "cancelled". Meanwhile, a button press + direction triggers
    614  6a0b							; "look-around mode"
    615  6a0b
    616  6a0b		       a5 4c		      lda	INPT4
    617  6a0d		       30 39		      bmi	noLook	; button?
    618  6a0f
    619  6a0f							; button pressed, so in looking-around mode
    620  6a0f
    621  6a0f		       a5 a5		      lda	LookingAround
    622  6a11		       30 04		      bmi	LookAround
    623  6a13		       a2 ff		      ldx	#$FF
    624  6a15		       86 a5		      stx	LookingAround
    625  6a17				   LookAround
    626  6a17
    627  6a17							; Use the joystick as a window-scroller to change the viewport
    628  6a17
    629  6a17		       ad 80 02 	      lda	SWCHA	;BufferedJoystick
    630  6a1a		       4a		      lsr
    631  6a1b		       4a		      lsr
    632  6a1c		       4a		      lsr
    633  6a1d		       4a		      lsr
    634  6a1e		       a8		      tay
    635  6a1f
    636  6a1f							;lda #-1
    637  6a1f							;sta BufferedJoystick
    638  6a1f
    639  6a1f		       b9 be f2 	      lda	JoyMoveX,y
    640  6a22		       19 ce f2 	      ora	JoyMoveY,y
    641  6a25		       f0 20		      beq	AbandonY
    642  6a27
    643  6a27		       a9 fe		      lda	#$FE
    644  6a29		       85 a5		      sta	LookingAround
    645  6a2b		       a9 a1		      lda	#MAX_THROTTLE+1
    646  6a2d		       85 b4		      sta	Throttle	; IMMEDIATE reaction to any joystick!
    647  6a2f
    648  6a2f		       b9 be f2 	      lda	JoyMoveX,y
    649  6a32							;asl
    650  6a32		       18		      clc
    651  6a33		       65 97		      adc	BoardScrollX
    652  6a35		       c5 94		      cmp	BoardEdge_Right
    653  6a37		       b0 02		      bcs	AbandonX
    654  6a39		       85 97		      sta	BoardScrollX
    655  6a3b
    656  6a3b				   AbandonX
    657  6a3b							;lda JoyMoveX,y
    658  6a3b							;bne AbandonY			  ; don't allow diagonals!
    659  6a3b
    660  6a3b		       b9 ce f2 	      lda	JoyMoveY,y
    661  6a3e							;asl
    662  6a3e		       18		      clc
    663  6a3f		       65 96		      adc	BoardScrollY
    664  6a41		       c5 95		      cmp	BoardEdge_Bottom
    665  6a43		       b0 02		      bcs	AbandonY
    666  6a45		       85 96		      sta	BoardScrollY
    667  6a47
    668  6a47		       60	   AbandonY   rts
    669  6a48
    670  6a48		       a2 00	   noLook     ldx	#0
    671  6a4a		       a5 a5		      lda	LookingAround
    672  6a4c		       c9 ff		      cmp	#$FF
    673  6a4e		       86 a5		      stx	LookingAround
    674  6a50		       d0 03		      bne	bProcComp	; $FE means there was a lookaround, so skip
    675  6a52
    676  6a52							; button was presssed and now released and we didn't actually look around
    677  6a52							; so we do a take-back
    678  6a52
    679  6a52		       4c 0f fa 	      jmp	takebackRestoreEarlierPosition	;.. and rts
    680  6a55							;rts
    681  6a55
    682  6a55				   bProcComp
    683  6a55							;------------------------------------------------------------------------------
    684  6a55
    685  6a55		       a5 a2		      lda	ManLastDirection
    686  6a57		       29 07		      and	#DIRECTION_BITS
    687  6a59		       a8		      tay
    688  6a5a
    689  6a5a		       a5 92		      lda	BufferedJoystick	; joystick
    690  6a5c		       85 93		      sta	PreviousJoystick
    691  6a5e							;and BufferedJoystick+1
    692  6a5e
    693  6a5e		       a2 00		      ldx	#0
    694  6a60		       0a	   .loopDirs  asl
    695  6a61		       90 28		      bcc	.dirFound
    696  6a63		       88		      dey
    697  6a64		       e8		      inx
    698  6a65		       e0 04		      cpx	#4
    699  6a67		       d0 f7		      bne	.loopDirs
    700  6a69
    701  6a69							; no direction!
    702  6a69
    703  6a69		       a9 02		      lda	#ANIMATION_IDLE_ID
    704  6a6b		       c5 a6		      cmp	ManAnimationID
    705  6a6d		       f0 1c		      beq	alreadyIdling
    706  6a6f
    707  6a6f		       e6 a8		      inc	idleCount
    708  6a71		       a4 a8		      ldy	idleCount
    709  6a73		       c0 02		      cpy	#2
    710  6a75		       90 14		      bcc	alreadyIdling
    711  6a77
      0  6a77					      LOAD_ANIMATION	IDLE
      1  6a77		       a9 3e		      lda	#<Animation_IDLE
      2  6a79		       85 9a		      sta	animation
      3  6a7b		       a9 f0		      lda	#>Animation_IDLE
      4  6a7d		       85 9b		      sta	animation+1
      5  6a7f		       a9 00		      lda	#0
      6  6a81		       85 9c		      sta	animation_delay
      7  6a83		       a9 02		      lda	#ANIMATION_IDLE_ID
      8  6a85		       85 a6		      sta	ManAnimationID
      9  6a87
    713  6a87
    714  6a87		       a9 00		      lda	#0
    715  6a89		       85 a8		      sta	idleCount
    716  6a8b				   alreadyIdling
    717  6a8b
    718  6a8b							;lda #MAX_THROTTLE+1
    719  6a8b							;sta Throttle		     ; IMMEDIATE reaction to any joystick!
    720  6a8b
    721  6a8b				   .dirFound
    722  6a8b
    723  6a8b		       a9 ff		      lda	#-1
    724  6a8d		       85 92		      sta	BufferedJoystick
    725  6a8f
    726  6a8f		       bd e5 f2 	      lda	anim_direction,x
    727  6a92		       30 0d		      bmi	dontChange
    728  6a94		       45 a2		      eor	ManLastDirection
    729  6a96		       29 08		      and	#%1000
    730  6a98		       f0 07		      beq	dontChange
    731  6a9a
    732  6a9a							; at this point we want to activate the stand/turn animation before continuing
    733  6a9a
    734  6a9a		       a9 0a		      lda	#MANMODE_TURNAROUND
    735  6a9c		       85 a1		      sta	ManMode
    736  6a9e		       4c ae f1 	      jmp	TurnAround
    737  6aa1
    738  6aa1
    739  6aa1
    740  6aa1
    741  6aa1							;bne noMovement ;kipMove
    742  6aa1				   dontChange
    743  6aa1
    744  6aa1
    745  6aa1
    746  6aa1		       18		      clc
    747  6aa2		       a5 89		      lda	POS_X_NEW
    748  6aa4		       7d e0 f2 	      adc	JoyDirX,x
    749  6aa7		       85 89		      sta	POS_X_NEW
    750  6aa9
    751  6aa9		       18		      clc
    752  6aaa		       a5 8a		      lda	POS_Y_NEW
    753  6aac		       7d de f2 	      adc	JoyDirY,x
    754  6aaf		       85 8a		      sta	POS_Y_NEW
    755  6ab1
    756  6ab1
    757  6ab1		       98	   skipMove   tya
    758  6ab2		       f0 09		      beq	noMovement	; animation OK
    759  6ab4
    760  6ab4		       8a		      txa
    761  6ab5		       45 a2		      eor	ManLastDirection
    762  6ab7		       29 07		      and	#DIRECTION_BITS
    763  6ab9		       45 a2		      eor	ManLastDirection
    764  6abb		       85 a2		      sta	ManLastDirection
    765  6abd
    766  6abd				   noMovement
    767  6abd
    768  6abd
    769  6abd		       60	   DFS_rts    rts
    770  6abe
    771  6abe
    772  6abe							;			RLDU RLD  RL U RL   R DU R D  R  U R	 LDU  LD   L U	L     DU   D	 U
    773  6abe							;			0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    774  6abe		       00 00 00 00*JoyMoveX   .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 0, 0, 0
    775  6ace		       00 00 00 00*JoyMoveY   .byte.b	0, 0, 0, 0, 0, 1, -1, 0, 0, 1, -1, 0, 0, 1, -1, 0
    776  6ade
    777  6ade				   JoyDirY
    778  6ade		       00 00		      .byte.b	0,0	;,1,-1,0
    779  6ae0				   JoyDirX
    780  6ae0		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
    781  6ae5
    782  6ae5							;Data Bit  Direction Player
    783  6ae5							;		 D7	   right	  P0  D4
    784  6ae5							;		 D6	   left      P0  D3
    785  6ae5							;		 D5	   down      P0  D2
    786  6ae5							;		 D4	   up	     P0  D1
    787  6ae5							;     A "0" in a data bit indicates the joystick has been moved
    788  6ae5							;     to close that switch.  All "1's" in a player's nibble
    789  6ae5							;     indicates that joystick is not moving.
    790  6ae5
    791  6ae5							;0  0000 x
    792  6ae5							;1  0001 x
    793  6ae5							;2  0010 x
    794  6ae5							;3  0011 x
    795  6ae5							;4  0100 x
    796  6ae5							;5  0101 right down
    797  6ae5							;6  0110 right up
    798  6ae5							;7  0111 right
    799  6ae5							;8  1000 x
    800  6ae5							;9  1001 left down
    801  6ae5							;10  1010 left up
    802  6ae5							;11  1011 left
    803  6ae5							;12  1100 x
    804  6ae5							;13  1101 down
    805  6ae5							;14  1110 up
    806  6ae5							;15  1111 none
    807  6ae5
    808  6ae5		       00 08 80 80*anim_direction .byte.b	0,%1000,128,128,128
    809  6aea
    810  6aea							;------------------------------------------------------------------------------
    811  6aea
    812  6aea
      0  6aea					      DEFINE_SUBROUTINE	DrawFullScreen	; @31✅
      1  6aea		       00 0d	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  6aea					      SUBROUTINE
      3  6aea				   DrawFullScreen
    814  6aea
    815  6aea		       ad 84 02 	      lda	INTIM	; 4
    816  6aed		       c9 29		      cmp	#SEGTIME_BDF	; 2
    817  6aef		       90 cc		      bcc	DFS_rts	; 2/3 ==> [31]+(9)+6rts = 46✅ on abort
    818  6af1
    819  6af1		       a9 f4		      lda	#>( DrawFlag + RAM_WRITE )	; 2
    820  6af3		       85 d3		      sta	BDF_DrawFlagAddress+1	; 3
    821  6af5		       85 d5		      sta	BDF_DrawFlagAddress2+1	; 3 = 8✅
    822  6af7
    823  6af7		       ba		      tsx		; 2
    824  6af8		       86 dc		      stx	DHS_Stack	; 3
    825  6afa
    826  6afa		       e6 86		      inc	ScreenDrawPhase	; 5
    827  6afc
    828  6afc		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
    829  6afd		       a2 08		      ldx	#SCREEN_LINES	; 2
    830  6aff		       8a		      txa		; 2 = 24✅
    831  6b00
    832  6b00							; fall through
    833  6b00
    834  6b00							;------------------------------------------------------------------------------
    835  6b00
    836  6b00							; @311✅ (from loop)
    837  6b00							; @24✅ (fall through)
    838  6b00
    839  6b00							; 8 lines x 311 + (24)
    840  6b00							; = 2512
    841  6b00							; = 39 :)
    842  6b00
      0  6b00					      DEFINE_SUBROUTINE	DrawScreenRowPreparation
      1  6b00		       00 0d	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  6b00					      SUBROUTINE
      3  6b00				   DrawScreenRowPreparation
    844  6b00
    845  6b00							;clc
    846  6b00		       ca		      dex		; 2
    847  6b01		       86 db		      stx	DHS_Line	; 3
    848  6b03		       65 96		      adc	BoardScrollY	; 3	     the Y offset of screen into board
    849  6b05		       a8		      tay		; 2 = 10✅
    850  6b06
    851  6b06							;clc
    852  6b06		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
    853  6b09		       65 97		      adc	BoardScrollX	; 3	     the X offset of screen into board
    854  6b0b		       85 d6		      sta	BDF_BoardAddress	; 3
    855  6b0d		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    856  6b0f		       85 d8		      sta	BDF_BoardAddress2	; 3 = 15✅
    857  6b11
    858  6b11		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
    859  6b14		       85 d7		      sta	BDF_BoardAddress+1	; 3
    860  6b16		       85 d9		      sta	BDF_BoardAddress2+1	; 3 = 10 @35✅
    861  6b18
    862  6b18		       bd 92 f0 	      lda	DrawLineStartLO,x	; 4
    863  6b1b		       85 d2		      sta	BDF_DrawFlagAddress	; 3
    864  6b1d		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    865  6b1f		       85 d4		      sta	BDF_DrawFlagAddress2	; 3 = 12✅
    866  6b21
    867  6b21							;    IF MULTI_BANK_BOARD = YES
    868  6b21							;		  lda BoardBank-1,y		  ; 4
    869  6b21							;		  sta BDF_BoardBank		  ; 3
    870  6b21							;    ENDIF
    871  6b21		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
    872  6b23		       4c 83 fb 	      jmp	CopyRow2	; 3 = 12 @59✅
    873  6b26
    874  6b26							;------------------------------------------------------------------------------
    875  6b26
      0  6b26					      DEFINE_SUBROUTINE	EndOfLevel
      1  6b26		       00 0d	   BANK_EndOfLevel =	_CURRENT_BANK
      2  6b26					      SUBROUTINE
      3  6b26				   EndOfLevel
    877  6b26
    878  6b26		       a9 0a		      lda	#10
    879  6b28		       85 a9		      sta	DelayEndOfLevel
    880  6b2a
    881  6b2a		       a6 80		      ldx	Platform
    882  6b2c		       bd 4a f3 	      lda	FlashColour,x	;+4,x
    883  6b2f		       85 b1		      sta	BGColour	;ColourFlash		      ; green
    884  6b31		       a9 06		      lda	#6
    885  6b33		       85 c1		      sta	ColourTimer
    886  6b35
    887  6b35
      0  6b35					      LOAD_ANIMATION	WIN
      1  6b35		       a9 1c		      lda	#<Animation_WIN
      2  6b37		       85 9a		      sta	animation
      3  6b39		       a9 f0		      lda	#>Animation_WIN
      4  6b3b		       85 9b		      sta	animation+1
      5  6b3d		       a9 00		      lda	#0
      6  6b3f		       85 9c		      sta	animation_delay
      7  6b41		       a9 04		      lda	#ANIMATION_WIN_ID
      8  6b43		       85 a6		      sta	ManAnimationID
      9  6b45
    889  6b45
    890  6b45		       a9 08		      lda	#MANMODE_NEXTLEVEL2
    891  6b47		       85 a1		      sta	ManMode
    892  6b49		       60		      rts
    893  6b4a
    894  6b4a
    895  6b4a		       c4 c4 54 54 FlashColour .byte.b	$C4, $C4, $54, $54
    896  6b4e
    897  6b4e
      0  6b4e					      DEFINE_SUBROUTINE	IMC
      1  6b4e		       00 0d	   BANK_IMC   =	_CURRENT_BANK
      2  6b4e					      SUBROUTINE
      3  6b4e				   IMC
    899  6b4e
    900  6b4e		       18		      clc
    901  6b4f		       a5 b8		      lda	takebackIndex
    902  6b51		       69 01		      adc	#1
    903  6b53		       29 3f		      and	#TAKEBACK_MASK
    904  6b55		       85 b8		      sta	takebackIndex
    905  6b57		       c5 b9		      cmp	takebackBaseIndex
    906  6b59		       d0 06		      bne	baseOK
    907  6b5b		       69 00		      adc	#0
    908  6b5d		       29 3f		      and	#TAKEBACK_MASK
    909  6b5f		       85 b9		      sta	takebackBaseIndex
    910  6b61				   baseOK
    911  6b61
    912  6b61		       f8		      sed
    913  6b62		       18		      clc
    914  6b63		       a5 b6		      lda	BCD_moveCounter
    915  6b65		       69 01		      adc	#1
    916  6b67		       85 b6		      sta	BCD_moveCounter
    917  6b69		       a5 b7		      lda	BCD_moveCounter+1
    918  6b6b		       69 00		      adc	#0
    919  6b6d		       85 b7		      sta	BCD_moveCounter+1
    920  6b6f		       d8		      cld
    921  6b70
    922  6b70		       60		      rts
    923  6b71
    924  6b71							;------------------------------------------------------------------------------
    925  6b71
      0  6b71					      DEFINE_SUBROUTINE	VectorProcess	;=19 + 13, = 31✅ minimum
      1  6b71		       00 0d	   BANK_VectorProcess =	_CURRENT_BANK
      2  6b71					      SUBROUTINE
      3  6b71				   VectorProcess
    927  6b71
    928  6b71		       bd 7f f3 	      lda	OSPointerHI,x	; 4
    929  6b74		       85 d3		      sta	POS_Vector+1	; 3
    930  6b76		       bd 7e f3 	      lda	OSPointerLO,x	; 4
    931  6b79		       85 d2		      sta	POS_Vector	; 3
    932  6b7b
    933  6b7b		       6c d2 00 	      jmp	(POS_Vector)	; 5 = 19	  vector to processor for particular object type
    934  6b7e
    935  6b7e							; earliest abort from process = +13
    936  6b7e
    937  6b7e							;		 NOTE: Bank is either INITBANK or FIXED.
    938  6b7e							;------------------------------------------------------------------------------
    939  6b7e
    940  6b7e
    941  6b7e				   OBJTYPE    SET	0
    942  6b7e					      MAC	define
    943  6b7e				   TYPE_{1}   =	OBJTYPE
    944  6b7e				   OBJTYPE    .SET	OBJTYPE + 1
    945  6b7e					      ENDM
    946  6b7e
    947  6b7e							; If adding/removing types, the following must also be updated...
    948  6b7e							;   InitialFace[...]		     in UnpackLevel.asm
    949  6b7e							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
    950  6b7e							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
    951  6b7e							;   OSPointerLO[...]		     in BANK_INITBANK.asm
    952  6b7e							;   OSPointerHI[...]		     in BANK_INITBANK.asm
    953  6b7e							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
    954  6b7e							;   Sortable[...]		     in BANK_FIXED.asm
    955  6b7e
    956  6b7e
      0  6b7e					      DEFINE	MAN
      1  6b7e		       00 00	   TYPE_MAN   =	OBJTYPE
      2  6b7e				   OBJTYPE    .SET	OBJTYPE + 1
    958  6b7e							;DEFINE CIRCLE
    959  6b7e							;DEFINE CIRCLE_HELPER
    960  6b7e							;DEFINE CIRCLE_DRAWER
    961  6b7e
      0  6b7e					      DEFINE	MAXIMUM
      1  6b7e		       00 01	   TYPE_MAXIMUM =	OBJTYPE
      2  6b7e				   OBJTYPE    .SET	OBJTYPE + 1
    963  6b7e
    964  6b7e
      0  6b7e					      DEFINE_SUBROUTINE	OSPointerLO
      1  6b7e		       00 0d	   BANK_OSPointerLO =	_CURRENT_BANK
      2  6b7e					      SUBROUTINE
      3  6b7e				   OSPointerLO
    966  6b7e		       a9		      .byte.b	<PROCESS_MAN
    967  6b7f							;.byte <PROCESS_CIRCLE
    968  6b7f							;.byte <PROCESS_CIRCLE_HELPER
    969  6b7f
    970  6b7f				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
    971  6b7f				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
    972  6b7f				  -	      ERR
    973  6b7f					      ENDIF
    974  6b7f
    975  6b7f
      0  6b7f					      DEFINE_SUBROUTINE	OSPointerHI
      1  6b7f		       00 0d	   BANK_OSPointerHI =	_CURRENT_BANK
      2  6b7f					      SUBROUTINE
      3  6b7f				   OSPointerHI
    977  6b7f		       f8		      .byte.b	>PROCESS_MAN
    978  6b80							;.byte >PROCESS_CIRCLE
    979  6b80							;.byte >PROCESS_CIRCLE_HELPER
    980  6b80
    981  6b80				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
    982  6b80				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
    983  6b80				  -	      ERR
    984  6b80					      ENDIF
    985  6b80
    986  6b80							;------------------------------------------------------------------------------
    987  6b80
      0  6b80					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  6b80		       00 0d	   BANK_MoveVecLO =	_CURRENT_BANK
      2  6b80					      SUBROUTINE
      3  6b80				   MoveVecLO
    989  6b80
    990  6b80		       8e		      .byte.b	<MOVE_BLANK
    991  6b81		       8e		      .byte.b	<MOVE_SOIL
    992  6b82		       fd		      .byte.b	<MOVE_BOX
    993  6b83		       8e		      .byte.b	<MOVE_TARGET
    994  6b84		       8e		      .byte.b	<MOVE_TARGET
    995  6b85		       e8		      .byte.b	<MOVE_GENERIC	;man occupied
    996  6b86		       e8		      .byte.b	<MOVE_GENERIC	;steel
    997  6b87		       e8		      .byte.b	<MOVE_GENERIC	;wall
    998  6b88		       06		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
    999  6b89		       06		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
   1000  6b8a		       e8		      .byte.b	<MOVE_GENERIC	;nogo
   1001  6b8b		       8e		      .byte.b	<MOVE_TARGET	;1
   1002  6b8c		       8e		      .byte.b	<MOVE_TARGET	;3
   1003  6b8d		       8e		      .byte.b	<MOVE_TARGET	;5
   1004  6b8e		       8e		      .byte.b	<MOVE_TARGET	;7
   1005  6b8f
   1006  6b8f				  -	      if	DIGITS
   1007  6b8f				  -	      REPEAT	10	; DIGITS 0-9
   1008  6b8f				  -	      .byte	<MOVE_BLANK
   1009  6b8f				  -	      REPEND
   1010  6b8f					      endif
   1011  6b8f
   1012  6b8f				  -	      IF	* - MoveVecLO != CHARACTER_MAXIMUM
   1013  6b8f				  -	      ECHO	"ERROR: Incorrect number of entries in MoveVecLO table!"
   1014  6b8f				  -	      ERR
   1015  6b8f					      ENDIF
   1016  6b8f
   1017  6b8f
      0  6b8f					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  6b8f		       00 0d	   BANK_MoveVecHI =	_CURRENT_BANK
      2  6b8f					      SUBROUTINE
      3  6b8f				   MoveVecHI
   1019  6b8f
   1020  6b8f		       f9		      .byte.b	>MOVE_BLANK
   1021  6b90		       f9		      .byte.b	>MOVE_SOIL
   1022  6b91		       f9		      .byte.b	>MOVE_BOX
   1023  6b92		       f9		      .byte.b	>MOVE_TARGET
   1024  6b93		       f9		      .byte.b	>MOVE_TARGET
   1025  6b94		       f9		      .byte.b	>MOVE_GENERIC	;man occupied
   1026  6b95		       f9		      .byte.b	>MOVE_GENERIC	;steel
   1027  6b96		       f9		      .byte.b	>MOVE_GENERIC	;wall
   1028  6b97		       fa		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
   1029  6b98		       fa		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
   1030  6b99		       f9		      .byte.b	>MOVE_GENERIC	;nogo
   1031  6b9a		       f9		      .byte.b	>MOVE_TARGET	;1
   1032  6b9b		       f9		      .byte.b	>MOVE_TARGET	;3
   1033  6b9c		       f9		      .byte.b	>MOVE_TARGET	;5
   1034  6b9d		       f9		      .byte.b	>MOVE_TARGET	; 7
   1035  6b9e
   1036  6b9e				  -	      if	DIGITS
   1037  6b9e				  -	      REPEAT	10	; DIGITS 0-9
   1038  6b9e				  -	      .byte	>MOVE_BLANK
   1039  6b9e				  -	      REPEND
   1040  6b9e					      endif
   1041  6b9e
   1042  6b9e				  -	      IF	* - MoveVecHI != CHARACTER_MAXIMUM
   1043  6b9e				  -	      ECHO	"ERROR: Incorrect number of entries in MoveVecHI table!"
   1044  6b9e				  -	      ERR
   1045  6b9e					      ENDIF
   1046  6b9e
   1047  6b9e							;------------------------------------------------------------------------------
   1048  6b9e
      0  6b9e					      DEFINE_SUBROUTINE	SoundFX
      1  6b9e		       00 0d	   BANK_SoundFX =	_CURRENT_BANK
      2  6b9e					      SUBROUTINE
      3  6b9e				   SoundFX
------- FILE sound/intro1_player.asm LEVEL 3 PASS 3
      0  6b9e					      include	"sound/intro1_player.asm"
      1  6b9e							; TIATracker music player
      2  6b9e							; Copyright 2016 Andre "Kylearan" Wichmann
      3  6b9e							; Website: https://bitbucket.org/kylearan/tiatracker
      4  6b9e							; Email: andre.wichmann@gmx.de
      5  6b9e							;
      6  6b9e							; Licensed under the Apache License, Version 2.0 (the "License");
      7  6b9e							; you may not use this file except in compliance with the License.
      8  6b9e							; You may obtain a copy of the License at
      9  6b9e							;
     10  6b9e							;   http://www.apache.org/licenses/LICENSE-2.0
     11  6b9e							;
     12  6b9e							; Unless required by applicable law or agreed to in writing, software
     13  6b9e							; distributed under the License is distributed on an "AS IS" BASIS,
     14  6b9e							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  6b9e							; See the License for the specific language governing permissions and
     16  6b9e							; limitations under the License.
     17  6b9e
     18  6b9e							; Song author:
     19  6b9e							; Song name:
     20  6b9e
     21  6b9e							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  6b9e
     23  6b9e							; =====================================================================
     24  6b9e							; TIATracker Player
     25  6b9e							; =====================================================================
     26  6b9e				   tt_PlayerStart
     27  6b9e
     28  6b9e							; PLANNED PLAYER VARIANTS:
     29  6b9e							; - RAM, speed, player ROM: c0/c1 patterns have same length
     30  6b9e							; - RAM: Pack 2 values (out of cur_pat_index, cur_note_index, envelope_index)
     31  6b9e							;	 into one and use lsr/asl to unpack them, allowing only ranges of
     32  6b9e							;	 16/16 or 32/8 for them, depending on number of patterns, max
     33  6b9e							;	 pattern size and max ADSR size
     34  6b9e							; - ROM: Check if tt_SequenceTable can hold ptrs directly without indexing
     35  6b9e							;	 tt_PatternPtrLo/Hi. Can be smaller if not many patterns get repeated
     36  6b9e							;	 (saves table and decode routine)
     37  6b9e							; - Speed: Inline tt_CalcInsIndex
     38  6b9e							; - Speed: Store ptr to current note in RAM instead of reconstructing it?
     39  6b9e							;	 Might also save the need for cur_note_index
     40  6b9e
     41  6b9e
     42  6b9e							; ---------------------------------------------------------------------
     43  6b9e							; Helper macro: Retrieves current note. May advance pattern if needed.
     44  6b9e							; Becomes a subroutine if TT_USE_OVERLAY is used.
     45  6b9e							; ---------------------------------------------------------------------
     46  6b9e					      MAC	tt_fetch_current_note
     47  6b9e							; construct ptr to pattern
     48  6b9e				   .constructPatPtr
     49  6b9e					      ldy	tt_cur_pat_index_c0,x	; get current pattern (index into tt_SequenceTable)
     50  6b9e					      lda	tt_SequenceTable,y
     51  6b9e					      IF	TT_USE_GOTO = 1
     52  6b9e					      bpl	.noPatternGoto
     53  6b9e					      and	#%01111111	; mask out goto bit to get pattern number
     54  6b9e					      sta	tt_cur_pat_index_c0,x	; store goto'ed pattern index
     55  6b9e					      bpl	.constructPatPtr	; unconditional
     56  6b9e				   .noPatternGoto
     57  6b9e					      ENDIF
     58  6b9e					      tay
     59  6b9e					      lda	tt_PatternPtrLo,y
     60  6b9e					      sta	tt_ptr
     61  6b9e					      lda	tt_PatternPtrHi,y
     62  6b9e					      sta	tt_ptr+1
     63  6b9e							; get new note
     64  6b9e					      IF	TT_USE_OVERLAY = 0
     65  6b9e					      ldy	tt_cur_note_index_c0,x
     66  6b9e					      ELSE
     67  6b9e							; If the V flag is set and if the new note is an instrument,
     68  6b9e							; it means it got pre-fetched by an overlay percussion, it has
     69  6b9e							; to remain in sustain.
     70  6b9e					      clv
     71  6b9e							; check if note had been pre-fetched by overlay perc already
     72  6b9e					      lda	tt_cur_note_index_c0,x
     73  6b9e					      bpl	.notPrefetched
     74  6b9e							; If so, remove flag
     75  6b9e					      and	#%01111111
     76  6b9e					      sta	tt_cur_note_index_c0,x
     77  6b9e							; Set V flag for later
     78  6b9e					      bit	tt_Bit6Set
     79  6b9e				   .notPrefetched
     80  6b9e					      tay
     81  6b9e					      ENDIF
     82  6b9e					      lda	(tt_ptr),y
     83  6b9e							; pre-process new note
     84  6b9e							; 7..5: instrument (1..7), 4..0 (0..31): frequency
     85  6b9e							; 0/0: End of pattern
     86  6b9e					      bne	.noEndOfPattern
     87  6b9e							; End of pattern: Advance to next pattern
     88  6b9e					      sta	tt_cur_note_index_c0,x	; a is 0
     89  6b9e					      inc	tt_cur_pat_index_c0,x
     90  6b9e					      bne	.constructPatPtr	; unconditional
     91  6b9e				   .noEndOfPattern
     92  6b9e					      ENDM
     93  6b9e
     94  6b9e
     95  6b9e							; ---------------------------------------------------------------------
     96  6b9e							; Music player entry. Call once per frame.
     97  6b9e							; ---------------------------------------------------------------------
     98  6b9e				   tt_Player  SUBROUTINE
     99  6b9e							; ==================== Sequencer ====================
    100  6b9e							; Decrease speed timer
    101  6b9e		       c6 c7		      dec	tt_timer
    102  6ba0		       10 6e		      bpl	.noNewNote
    103  6ba2
    104  6ba2							; Timer ran out: Do sequencer
    105  6ba2							; Advance to next note
    106  6ba2		       a2 01		      ldx	#1	; 2 channels
    107  6ba4				   .advanceLoop
    108  6ba4					      IF	TT_USE_OVERLAY = 1
    109  6ba4		       20 ba f3 	      jsr	tt_FetchNote
    110  6ba7				  -	      ELSE
    111  6ba7				  -	      TT_FETCH_CURRENT_NOTE
    112  6ba7					      ENDIF
    113  6ba7							; Parse new note from pattern
    114  6ba7		       c9 10		      cmp	#TT_INS_PAUSE
    115  6ba9					      IF	TT_USE_SLIDE = 0
    116  6ba9		       90 55		      bcc	.finishedNewNote
    117  6bab		       d0 3d		      bne	.newNote
    118  6bad				  -	      ELSE
    119  6bad				  -	      beq	.pause
    120  6bad				  -	      bcs	.newNote
    121  6bad				  -
    122  6bad				  -			; --- slide/hold ---
    123  6bad				  -			; Adjust frequency and hold note in sustain.
    124  6bad				  -			; composer/tracker has to make sure that no unwanted
    125  6bad				  -			; under/overflow happens.
    126  6bad				  -			; Note: f = f + (8-(16-x)) = x + f - 8
    127  6bad				  -	      adc	tt_cur_ins_c0,x	; carry is clear after cmp
    128  6bad				  -	      sec
    129  6bad				  -	      sbc	#8
    130  6bad				  -	      sta	tt_cur_ins_c0,x
    131  6bad				  -	      bcs	.finishedNewNote	; unconditional, since legally no underflow can happen (ins>0 or HOLD for ins=0)
    132  6bad					      ENDIF
    133  6bad
    134  6bad							; --- pause ---
    135  6bad				   .pause
    136  6bad							; Get release index for current instrument. Since a pause can
    137  6bad							; only follow an instrument, we don't need to handle percussion
    138  6bad							; or commands.
    139  6bad		       b5 ce		      lda	tt_cur_ins_c0,x
    140  6baf		       20 48 f4 	      jsr	tt_CalcInsIndex
    141  6bb2		       b9 8a f4 	      lda	tt_InsReleaseIndexes-1,y	; -1 b/c instruments start at #1
    142  6bb5							; Put it into release. Skip junk byte so index no longer indicates
    143  6bb5							; sustain phase.
    144  6bb5		       18		      clc
    145  6bb6		       69 01		      adc	#1
    146  6bb8		       90 44		      bcc	.storeADIndex	; unconditional
    147  6bba
    148  6bba							; ---------------------------------------------------------------------
    149  6bba							; Helper subroutine to minimize ROM footprint. Will be inlined if
    150  6bba							; TT_USE_OVERLAY is not used.
    151  6bba							; Interleaved here so player can be inlined.
    152  6bba							; ---------------------------------------------------------------------
    153  6bba					      IF	TT_USE_OVERLAY = 1
    154  6bba				   tt_FetchNote
      0  6bba					      TT_FETCH_CURRENT_NOTE
      1  6bba
      2  6bba				   .constructPatPtr
      3  6bba		       b4 c8		      ldy	tt_cur_pat_index_c0,x
      4  6bbc		       b9 9d f5 	      lda	tt_SequenceTable,y
      5  6bbf					      IF	TT_USE_GOTO = 1
      6  6bbf		       10 06		      bpl	.noPatternGoto
      7  6bc1		       29 7f		      and	#%01111111
      8  6bc3		       95 c8		      sta	tt_cur_pat_index_c0,x
      9  6bc5		       10 f3		      bpl	.constructPatPtr
     10  6bc7				   .noPatternGoto
     11  6bc7					      ENDIF
     12  6bc7		       a8		      tay
     13  6bc8		       b9 93 f5 	      lda	tt_PatternPtrLo,y
     14  6bcb		       85 d0		      sta	tt_ptr
     15  6bcd		       b9 98 f5 	      lda	tt_PatternPtrHi,y
     16  6bd0		       85 d1		      sta	tt_ptr+1
     17  6bd2
     18  6bd2				  -	      IF	TT_USE_OVERLAY = 0
     19  6bd2				  -	      ldy	tt_cur_note_index_c0,x
     20  6bd2					      ELSE
     21  6bd2
     22  6bd2
     23  6bd2
     24  6bd2		       b8		      clv
     25  6bd3
     26  6bd3		       b5 ca		      lda	tt_cur_note_index_c0,x
     27  6bd5		       10 07		      bpl	.notPrefetched
     28  6bd7
     29  6bd7		       29 7f		      and	#%01111111
     30  6bd9		       95 ca		      sta	tt_cur_note_index_c0,x
     31  6bdb
     32  6bdb		       2c 4e f4 	      bit	tt_Bit6Set
     33  6bde				   .notPrefetched
     34  6bde		       a8		      tay
     35  6bdf					      ENDIF
     36  6bdf		       b1 d0		      lda	(tt_ptr),y
     37  6be1
     38  6be1
     39  6be1
     40  6be1		       d0 06		      bne	.noEndOfPattern
     41  6be3
     42  6be3		       95 ca		      sta	tt_cur_note_index_c0,x
     43  6be5		       f6 c8		      inc	tt_cur_pat_index_c0,x
     44  6be7		       d0 d1		      bne	.constructPatPtr
     45  6be9				   .noEndOfPattern
    156  6be9		       60		      rts
    157  6bea					      ENDIF
    158  6bea
    159  6bea
    160  6bea							; --- start instrument or percussion ---
    161  6bea				   .newNote
    162  6bea		       95 ce		      sta	tt_cur_ins_c0,x	; set new instrument
    163  6bec							; Instrument or percussion?
    164  6bec		       c9 20		      cmp	#TT_FREQ_MASK+1
    165  6bee		       b0 06		      bcs	.startInstrument
    166  6bf0
    167  6bf0							; --- start percussion ---
    168  6bf0							; Get index of envelope
    169  6bf0		       a8		      tay
    170  6bf1							; -TT_FIRST_PERC because percussion start with TT_FIRST_PERC
    171  6bf1		       b9 ae f4 	      lda	tt_PercIndexes-TT_FIRST_PERC,y
    172  6bf4		       d0 08		      bne	.storeADIndex	; unconditional, since index values are >0
    173  6bf6
    174  6bf6							; --- start instrument ---
    175  6bf6				   .startInstrument
    176  6bf6					      IF	TT_USE_OVERLAY = 1
    177  6bf6							; If V flag is set, this note had been pre-fetched. That means
    178  6bf6							; it should remain in sustain.
    179  6bf6		       70 08		      bvs	.finishedNewNote
    180  6bf8					      ENDIF
    181  6bf8							; Put note into attack/decay
    182  6bf8		       20 48 f4 	      jsr	tt_CalcInsIndex
    183  6bfb		       b9 80 f4 	      lda	tt_InsADIndexes-1,y	; -1 because instruments start at #1
    184  6bfe				   .storeADIndex
    185  6bfe		       95 cc		      sta	tt_envelope_index_c0,x
    186  6c00
    187  6c00							; --- Finished parsing new note ---
    188  6c00				   .finishedNewNote
    189  6c00							; increase note index into pattern
    190  6c00		       f6 ca		      inc	tt_cur_note_index_c0,x
    191  6c02							; loop over channels
    192  6c02				   .sequencerNextChannel
    193  6c02		       ca		      dex
    194  6c03		       10 9f		      bpl	.advanceLoop
    195  6c05
    196  6c05							; Reset timer value
    197  6c05				  -	      IF	TT_GLOBAL_SPEED = 0
    198  6c05				  -			; Get timer value for current pattern in channel 0
    199  6c05				  -	      ldx	tt_cur_pat_index_c0	; get current pattern (index into tt_SequenceTable)
    200  6c05				  -	      ldy	tt_SequenceTable,x	; Current pattern index now in y
    201  6c05				  -	      IF	TT_USE_FUNKTEMPO = 0
    202  6c05				  -	      lda	tt_PatternSpeeds,y
    203  6c05				  -	      sta	tt_timer
    204  6c05				  -	      ELSE
    205  6c05				  -			; Test for odd/even frame
    206  6c05				  -	      lda	tt_cur_note_index_c0
    207  6c05				  -	      lsr
    208  6c05				  -	      lda	tt_PatternSpeeds,y	; does not affect carry flag
    209  6c05				  -	      bcc	.evenFrame
    210  6c05				  -	      and	#$0f	; does not affect carry flag
    211  6c05				  -	      bcs	.storeFunkTempo
    212  6c05				  -.evenFrame
    213  6c05				  -	      lsr
    214  6c05				  -	      lsr
    215  6c05				  -	      lsr
    216  6c05				  -	      lsr
    217  6c05				  -.storeFunkTempo
    218  6c05				  -	      sta	tt_timer
    219  6c05				  -	      ENDIF		; TT_USE_FUNKTEMPO = 0
    220  6c05				  -
    221  6c05					      ELSE
    222  6c05							; Global tempo
    223  6c05		       a2 04		      ldx	#TT_SPEED-1
    224  6c07					      IF	TT_USE_FUNKTEMPO = 1
    225  6c07		       a5 ca		      lda	tt_cur_note_index_c0
    226  6c09		       4a		      lsr
    227  6c0a		       90 02		      bcc	.noOddFrame
    228  6c0c		       a2 03		      ldx	#TT_ODD_SPEED-1
    229  6c0e				   .noOddFrame
    230  6c0e					      ENDIF		; TT_USE_FUNKTEMPO = 1
    231  6c0e		       86 c7		      stx	tt_timer
    232  6c10					      ENDIF		; TT_GLOBAL_SPEED = 0
    233  6c10
    234  6c10							; No new note to process
    235  6c10				   .noNewNote
    236  6c10
    237  6c10							; ==================== Update registers ====================
    238  6c10		       a2 01		      ldx	#1	; 2 channels
    239  6c12				   .updateLoop
    240  6c12							; Percussion or melodic instrument?
    241  6c12		       b5 ce		      lda	tt_cur_ins_c0,x
    242  6c14				  -	      IF	TT_STARTS_WITH_NOTES = 0
    243  6c14				  -			; This branch can be removed if track starts with a note in each channel
    244  6c14				  -	      beq	.afterAudioUpdate
    245  6c14					      ENDIF
    246  6c14		       c9 20		      cmp	#TT_FREQ_MASK+1
    247  6c16		       b0 37		      bcs	.instrument	; Melodic instrument
    248  6c18
    249  6c18							; --- Percussion: Get envelope index ---
    250  6c18		       b4 cc		      ldy	tt_envelope_index_c0,x
    251  6c1a							; Set AUDC and AUDV value from envelope
    252  6c1a		       b9 d7 f4 	      lda	tt_PercCtrlVolTable-1,y	; -1 because values are stored +1
    253  6c1d		       f0 02		      beq	.endOfPercussion	; 0 means end of percussion data
    254  6c1f		       f6 cc		      inc	tt_envelope_index_c0,x	; if end not reached: advance index
    255  6c21				   .endOfPercussion
    256  6c21		       95 59		      sta	AUDV0,x
    257  6c23		       4a		      lsr
    258  6c24		       4a		      lsr
    259  6c25		       4a		      lsr
    260  6c26		       4a		      lsr
    261  6c27		       95 55		      sta	AUDC0,x
    262  6c29							; Set AUDF
    263  6c29		       b9 c1 f4 	      lda	tt_PercFreqTable-1,y	; -1 because values are stored +1
    264  6c2c							; Bit 7 (overlay) might be set, but is unused in AUDF
    265  6c2c		       95 57		      sta	AUDF0,x
    266  6c2e					      IF	TT_USE_OVERLAY = 1
    267  6c2e		       10 48		      bpl	.afterAudioUpdate
    268  6c30							; Overlay percussion: Fetch next note out of order
    269  6c30		       20 ba f3 	      jsr	tt_FetchNote
    270  6c33							; Only do something if it's a melodic instrument
    271  6c33		       c9 20		      cmp	#TT_FREQ_MASK+1
    272  6c35		       90 41		      bcc	.afterAudioUpdate
    273  6c37							; Instrument: Put into sustain
    274  6c37		       95 ce		      sta	tt_cur_ins_c0,x	; set new instrument
    275  6c39		       20 48 f4 	      jsr	tt_CalcInsIndex
    276  6c3c		       b9 85 f4 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start at #1
    277  6c3f		       95 cc		      sta	tt_envelope_index_c0,x
    278  6c41							; Set prefetch flag. asl-sec-ror is smaller than lda-ora #128-sta
    279  6c41		       16 ca		      asl	tt_cur_note_index_c0,x
    280  6c43		       38		      sec
    281  6c44		       76 ca		      ror	tt_cur_note_index_c0,x
    282  6c46		       30 30		      bmi	.afterAudioUpdate	; unconditional
    283  6c48				  -	      ELSE
    284  6c48				  -	      jmp	.afterAudioUpdate
    285  6c48					      ENDIF
    286  6c48
    287  6c48
    288  6c48							; ---------------------------------------------------------------------
    289  6c48							; Helper subroutine to minimize ROM footprint.
    290  6c48							; Interleaved here so player routine can be inlined.
    291  6c48							; ---------------------------------------------------------------------
    292  6c48				   tt_CalcInsIndex
    293  6c48							; move upper 3 bits to lower 3
    294  6c48		       4a		      lsr
    295  6c49		       4a		      lsr
    296  6c4a		       4a		      lsr
    297  6c4b		       4a		      lsr
    298  6c4c		       4a		      lsr
    299  6c4d		       a8		      tay
    300  6c4e				   tt_Bit6Set		; This opcode has bit #6 set, for use with bit instruction
    301  6c4e		       60		      rts
    302  6c4f
    303  6c4f
    304  6c4f				   .instrument
    305  6c4f							; --- Melodic instrument ---
    306  6c4f							; Compute index into ADSR indexes and master Ctrl tables
    307  6c4f		       20 48 f4 	      jsr	tt_CalcInsIndex
    308  6c52							; Set AUDC with master value for this instrument, while we are at it
    309  6c52		       b9 7b f4 	      lda	tt_InsCtrlTable-1,y	; -1 because instruments start with #1
    310  6c55		       95 55		      sta	AUDC0,x
    311  6c57							; advance ADSR counter and compare to end of Sustain
    312  6c57		       b5 cc		      lda	tt_envelope_index_c0,x
    313  6c59		       d9 8a f4 	      cmp	tt_InsReleaseIndexes-1,y	; -1 because instruments start with #1
    314  6c5c		       d0 03		      bne	.noEndOfSustain
    315  6c5e							; End of sustain: Go back to start of sustain
    316  6c5e		       b9 85 f4 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start with #1
    317  6c61				   .noEndOfSustain
    318  6c61		       a8		      tay
    319  6c62							; Set volume from envelope
    320  6c62		       b9 90 f4 	      lda	tt_InsFreqVolTable,y
    321  6c65		       f0 01		      beq	.endOfEnvelope	; 0 means end of release has been reached:
    322  6c67		       c8		      iny		; advance index otherwise
    323  6c68				   .endOfEnvelope
    324  6c68		       94 cc		      sty	tt_envelope_index_c0,x
    325  6c6a		       95 59		      sta	AUDV0,x
    326  6c6c							; Now adjust frequency with ADSR value from envelope
    327  6c6c		       4a		      lsr
    328  6c6d		       4a		      lsr
    329  6c6e		       4a		      lsr
    330  6c6f		       4a		      lsr
    331  6c70		       18		      clc
    332  6c71		       75 ce		      adc	tt_cur_ins_c0,x
    333  6c73		       38		      sec
    334  6c74		       e9 08		      sbc	#8
    335  6c76		       95 57		      sta	AUDF0,x
    336  6c78
    337  6c78				   .afterAudioUpdate
    338  6c78							; loop over channels
    339  6c78		       ca		      dex
    340  6c79		       10 97		      bpl	.updateLoop
    341  6c7b
 Music player size:  $dd
    342  6c7b					      echo	"Music player size: ", *-tt_PlayerStart
------- FILE BANK_INITBANK.asm
   1051  6c7b		       60		      rts
   1052  6c7c
------- FILE sound/intro1_trackdata.asm LEVEL 3 PASS 3
      0  6c7c					      include	"sound/intro1_trackdata.asm"
      1  6c7c							; TIATracker music player
      2  6c7c							; Copyright 2016 Andre "Kylearan" Wichmann
      3  6c7c							; Website: https://bitbucket.org/kylearan/tiatracker
      4  6c7c							; Email: andre.wichmann@gmx.de
      5  6c7c							;
      6  6c7c							; Licensed under the Apache License, Version 2.0 (the "License");
      7  6c7c							; you may not use this file except in compliance with the License.
      8  6c7c							; You may obtain a copy of the License at
      9  6c7c							;
     10  6c7c							;   http://www.apache.org/licenses/LICENSE-2.0
     11  6c7c							;
     12  6c7c							; Unless required by applicable law or agreed to in writing, software
     13  6c7c							; distributed under the License is distributed on an "AS IS" BASIS,
     14  6c7c							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  6c7c							; See the License for the specific language governing permissions and
     16  6c7c							; limitations under the License.
     17  6c7c
     18  6c7c							; Song author: 
     19  6c7c							; Song name: 
     20  6c7c
     21  6c7c							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  6c7c
     23  6c7c							; =====================================================================
     24  6c7c							; TIATracker melodic and percussion instruments, patterns and sequencer
     25  6c7c							; data.
     26  6c7c							; =====================================================================
     27  6c7c				   tt_TrackDataStart
     28  6c7c
     29  6c7c							; =====================================================================
     30  6c7c							; Melodic instrument definitions (up to 7). tt_envelope_index_c0/1 hold
     31  6c7c							; the index values into these tables for the current instruments played
     32  6c7c							; in channel 0 and 1.
     33  6c7c							; 
     34  6c7c							; Each instrument is defined by:
     35  6c7c							; - tt_InsCtrlTable: the AUDC value
     36  6c7c							; - tt_InsADIndexes: the index of the start of the ADSR envelope as
     37  6c7c							;	 defined in tt_InsFreqVolTable
     38  6c7c							; - tt_InsSustainIndexes: the index of the start of the Sustain phase
     39  6c7c							;	 of the envelope
     40  6c7c							; - tt_InsReleaseIndexes: the index of the start of the Release phase
     41  6c7c							; - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
     42  6c7c							;	 the envelope
     43  6c7c							; =====================================================================
     44  6c7c
     45  6c7c							; Instrument master CTRL values
     46  6c7c				   tt_InsCtrlTable
     47  6c7c		       07 04 0c 04*	      dc.b	$07, $04, $0c, $04, $0c
     48  6c81
     49  6c81
     50  6c81							; Instrument Attack/Decay start indexes into ADSR tables.
     51  6c81				   tt_InsADIndexes
     52  6c81		       00 0e 0e 1e*	      dc.b	$00, $0e, $0e, $1e, $1e
     53  6c86
     54  6c86
     55  6c86							; Instrument Sustain start indexes into ADSR tables
     56  6c86				   tt_InsSustainIndexes
     57  6c86		       08 19 19 2b*	      dc.b	$08, $19, $19, $2b, $2b
     58  6c8b
     59  6c8b
     60  6c8b							; Instrument Release start indexes into ADSR tables
     61  6c8b							; Caution: Values are stored with an implicit -1 modifier! To get the
     62  6c8b							; real index, add 1.
     63  6c8b				   tt_InsReleaseIndexes
     64  6c8b		       09 1b 1b 2c*	      dc.b	$09, $1b, $1b, $2c, $2c
     65  6c90
     66  6c90
     67  6c90							; AUDVx and AUDFx ADSR envelope values.
     68  6c90							; Each byte encodes the frequency and volume:
     69  6c90							; - Bits 7..4: Freqency modifier for the current note ([-8..7]),
     70  6c90							;	 8 means no change. Bit 7 is the sign bit.
     71  6c90							; - Bits 3..0: Volume
     72  6c90							; Between sustain and release is one byte that is not used and
     73  6c90							; can be any value.
     74  6c90							; The end of the release phase is encoded by a 0.
     75  6c90				   tt_InsFreqVolTable
     76  6c90							; 0: Pizzicato bassb
     77  6c90		       8a 8a 89 88*	      dc.b	$8a, $8a, $89, $88, $86, $85, $85, $84
     78  6c98		       83 00 83 83*	      dc.b	$83, $00, $83, $83, $83, $00
     79  6c9e							; 1+2: Square2
     80  6c9e		       8c 8c 8b 89*	      dc.b	$8c, $8c, $8b, $89, $87, $85, $84, $83
     81  6ca6		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $00, $81, $00
     82  6cae							; 3+4: Square
     83  6cae		       85 85 85 85*	      dc.b	$85, $85, $85, $85, $84, $83, $83, $82
     84  6cb6		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $81, $00, $80
     85  6cbe		       00		      dc.b	$00
     86  6cbf
     87  6cbf
     88  6cbf
     89  6cbf							; =====================================================================
     90  6cbf							; Percussion instrument definitions (up to 15)
     91  6cbf							;
     92  6cbf							; Each percussion instrument is defined by:
     93  6cbf							; - tt_PercIndexes: The index of the first percussion frame as defined
     94  6cbf							;	 in tt_PercFreqTable and tt_PercCtrlVolTable
     95  6cbf							; - tt_PercFreqTable: The AUDF frequency value
     96  6cbf							; - tt_PercCtrlVolTable: The AUDV volume and AUDC values
     97  6cbf							; =====================================================================
     98  6cbf
     99  6cbf							; Indexes into percussion definitions signifying the first frame for
    100  6cbf							; each percussion in tt_PercFreqTable.
    101  6cbf							; Caution: Values are stored with an implicit +1 modifier! To get the
    102  6cbf							; real index, subtract 1.
    103  6cbf				   tt_PercIndexes
    104  6cbf		       01 0a 0c 	      dc.b	$01, $0a, $0c
    105  6cc2
    106  6cc2
    107  6cc2							; The AUDF frequency values for the percussion instruments.
    108  6cc2							; If the second to last value is negative (>=128), it means it's an
    109  6cc2							; "overlay" percussion, i.e. the player fetches the next instrument note
    110  6cc2							; immediately and starts it in the sustain phase next frame. (Needs
    111  6cc2							; TT_USE_OVERLAY)
    112  6cc2				   tt_PercFreqTable
    113  6cc2							; 0: Kick
    114  6cc2		       00 01 02 03*	      dc.b	$00, $01, $02, $03, $04, $05, $06, $87
    115  6cca		       00		      dc.b	$00
    116  6ccb							; 1: HH
    117  6ccb		       80 00		      dc.b	$80, $00
    118  6ccd							; 2: Snare
    119  6ccd		       01 03 06 0e*	      dc.b	$01, $03, $06, $0e, $13, $11, $15, $14
    120  6cd5		       17 1b 00 	      dc.b	$17, $1b, $00
    121  6cd8
    122  6cd8
    123  6cd8							; The AUDCx and AUDVx volume values for the percussion instruments.
    124  6cd8							; - Bits 7..4: AUDC value
    125  6cd8							; - Bits 3..0: AUDV value
    126  6cd8							; 0 means end of percussion data.
    127  6cd8				   tt_PercCtrlVolTable
    128  6cd8							; 0: Kick
    129  6cd8		       ee ed ed eb*	      dc.b	$ee, $ed, $ed, $eb, $e9, $e8, $e8, $e6
    130  6ce0		       00		      dc.b	$00
    131  6ce1							; 1: HH
    132  6ce1		       87 00		      dc.b	$87, $00
    133  6ce3							; 2: Snare
    134  6ce3		       8b 8a 8a 8a*	      dc.b	$8b, $8a, $8a, $8a, $8a, $8a, $89, $88
    135  6ceb		       87 86 00 	      dc.b	$87, $86, $00
    136  6cee
    137  6cee
    138  6cee
    139  6cee							; =====================================================================
    140  6cee							; Track definition
    141  6cee							; The track is defined by:
    142  6cee							; - tt_PatternX (X=0, 1, ...): Pattern definitions
    143  6cee							; - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
    144  6cee							;	 as index values
    145  6cee							; - tt_SequenceTable: The order in which the patterns should be played,
    146  6cee							;	 i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
    147  6cee							;	 for all channels and sub-tracks. The variables
    148  6cee							;	 tt_cur_pat_index_c0/1 hold an index into tt_SequenceTable for
    149  6cee							;	 each channel.
    150  6cee							;
    151  6cee							; So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
    152  6cee							; in turn point to pattern definitions (tt_PatternX) in which the notes
    153  6cee							; to play are specified.
    154  6cee							; =====================================================================
    155  6cee
    156  6cee							; ---------------------------------------------------------------------
    157  6cee							; Pattern definitions, one table per pattern. tt_cur_note_index_c0/1
    158  6cee							; hold the index values into these tables for the current pattern
    159  6cee							; played in channel 0 and 1.
    160  6cee							;
    161  6cee							; A pattern is a sequence of notes (one byte per note) ending with a 0.
    162  6cee							; A note can be either:
    163  6cee							; - Pause: Put melodic instrument into release. Must only follow a
    164  6cee							;	 melodic instrument.
    165  6cee							; - Hold: Continue to play last note (or silence). Default "empty" note.
    166  6cee							; - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
    167  6cee							;	 by -7..+7 and keep playing it
    168  6cee							; - Play new note with melodic instrument
    169  6cee							; - Play new note with percussion instrument
    170  6cee							; - End of pattern
    171  6cee							;
    172  6cee							; A note is defined by:
    173  6cee							; - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
    174  6cee							;	 and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
    175  6cee							;	 defined as:
    176  6cee							;	 - 0: End of pattern
    177  6cee							;	 - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
    178  6cee							;	 - 8: Hold
    179  6cee							;	 - 16: Pause
    180  6cee							;	 - [17..31]: Play percussion instrument 1..15
    181  6cee							;
    182  6cee							; The tracker must ensure that a pause only follows a melodic
    183  6cee							; instrument or a hold/slide.
    184  6cee							; ---------------------------------------------------------------------
    185  6cee		       00 1f	   TT_FREQ_MASK =	%00011111
    186  6cee		       00 08	   TT_INS_HOLD =	8
    187  6cee		       00 10	   TT_INS_PAUSE =	16
    188  6cee		       00 11	   TT_FIRST_PERC =	17
    189  6cee
    190  6cee							; Intro left
    191  6cee				   tt_pattern0
    192  6cee		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $3e, $08
    193  6cf6		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $3e, $08
    194  6cfe		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $12, $3e
    195  6d06		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $13, $08
    196  6d0e		       00		      dc.b	$00
    197  6d0f
    198  6d0f							; Intro2 L
    199  6d0f				   tt_pattern1
    200  6d0f		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    201  6d17		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    202  6d1f		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    203  6d27		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    204  6d2f		       00		      dc.b	$00
    205  6d30
    206  6d30							; Intro2-fill L
    207  6d30				   tt_pattern2
    208  6d30		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    209  6d38		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    210  6d40		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    211  6d48		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    212  6d50		       00		      dc.b	$00
    213  6d51
    214  6d51							; Intro right
    215  6d51				   tt_pattern3
    216  6d51		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $73, $08
    217  6d59		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $73, $08, $73, $08
    218  6d61		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $b3, $08
    219  6d69		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    220  6d71		       00		      dc.b	$00
    221  6d72
    222  6d72							; Intro2 R
    223  6d72				   tt_pattern4
    224  6d72		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    225  6d7a		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    226  6d82		       b3 08 73 08*	      dc.b	$b3, $08, $73, $08, $b3, $08, $73, $08
    227  6d8a		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    228  6d92		       00		      dc.b	$00
    229  6d93
    230  6d93
    231  6d93
    232  6d93
    233  6d93							; Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
    234  6d93							; Each byte encodes the speed of one pattern in the order
    235  6d93							; of the tt_PatternPtr tables below.
    236  6d93							; If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
    237  6d93							; the even speed and the high nibble the odd speed.
    238  6d93				  -	      IF	TT_GLOBAL_SPEED = 0
    239  6d93				  -tt_PatternSpeeds
    240  6d93				  -%%PATTERNSPEEDS%%
    241  6d93					      ENDIF
    242  6d93
    243  6d93
    244  6d93							; ---------------------------------------------------------------------
    245  6d93							; Pattern pointers look-up table.
    246  6d93							; ---------------------------------------------------------------------
    247  6d93				   tt_PatternPtrLo
    248  6d93		       ee 0f 30 51	      dc.b	<tt_pattern0, <tt_pattern1, <tt_pattern2, <tt_pattern3
    249  6d97		       72		      dc.b	<tt_pattern4
    250  6d98				   tt_PatternPtrHi
    251  6d98		       f4 f5 f5 f5	      dc.b	>tt_pattern0, >tt_pattern1, >tt_pattern2, >tt_pattern3
    252  6d9c		       f5		      dc.b	>tt_pattern4
    253  6d9d
    254  6d9d
    255  6d9d							; ---------------------------------------------------------------------
    256  6d9d							; Pattern sequence table. Each byte is an index into the
    257  6d9d							; tt_PatternPtrLo/Hi tables where the pointers to the pattern
    258  6d9d							; definitions can be found. When a pattern has been played completely,
    259  6d9d							; the next byte from this table is used to get the address of the next
    260  6d9d							; pattern to play. tt_cur_pat_index_c0/1 hold the current index values
    261  6d9d							; into this table for channels 0 and 1.
    262  6d9d							; If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
    263  6d9d							; number encoded in bits 6..0 (i.e. value AND %01111111).
    264  6d9d							; ---------------------------------------------------------------------
    265  6d9d				   tt_SequenceTable
    266  6d9d							; ---------- Channel 0 ----------
    267  6d9d		       00 00 01 02*	      dc.b	$00, $00, $01, $02, $80
    268  6da2
    269  6da2
    270  6da2							; ---------- Channel 1 ----------
    271  6da2		       03 04 03 04*	      dc.b	$03, $04, $03, $04, $85
    272  6da7
    273  6da7
 Track size:  $12b
    274  6da7					      echo	"Track size: ", *-tt_TrackDataStart
------- FILE BANK_INITBANK.asm
   1054  6da7
   1055  6da7							;------------------------------------------------------------------------------
   1056  6da7
      0  6da7					      CHECK_BANK_SIZE	"INITBANK"
      1  6da7		       05 a7	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $5a7 , FREE= $259
      2  6da7					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  6da7				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  6da7				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  6da7				  -	      ERR
      6  6da7					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_FIXED.asm LEVEL 2 PASS 3
      0  6da7					      include	"BANK_FIXED.asm"
      1  6da7							;    Sokoboo - a Sokoban implementation
      2  6da7							;    using a generic tile-based display engine for the Atari 2600
      3  6da7							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  6da7							;
      5  6da7							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  6da7							;
      7  6da7							;    Code related to the generic tile-based display engine was developed by
      8  6da7							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  6da7							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  6da7							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  6da7							;
     12  6da7							;    Code related to music and sound effects uses the TIATracker music player
     13  6da7							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  6da7							;    directory for Apache licensing details.
     15  6da7							;
     16  6da7							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  6da7							;    See the copyright notices in the License directory for a list of level
     18  6da7							;    contributors.
     19  6da7							;
     20  6da7							;    Except where otherwise indicated, this software is released under the
     21  6da7							;    following licensing arrangement...
     22  6da7							;
     23  6da7							;    This program is free software: you can redistribute it and/or modify
     24  6da7							;    it under the terms of the GNU General Public License as published by
     25  6da7							;    the Free Software Foundation, either version 3 of the License, or
     26  6da7							;    (at your option) any later version.
     27  6da7							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  6da7
     29  6da7							;    This program is distributed in the hope that it will be useful,
     30  6da7							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  6da7							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  6da7							;    GNU General Public License for more details.
     33  6da7
     34  6da7							;------------------------------------------------------------------------------
     35  6da7							;###############################  FIXED BANK  #################################
     36  6da7							;------------------------------------------------------------------------------
     37  6da7
     38  6da7
     39  6da7				   ORIGIN     SET	FIXED_BANK
     40  6da7
      0  6da7					      NEWBANK	THE_FIXED_BANK
      1  7f18 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
     42  7800					      RORG	$f800
     43  7800
     44  7800
     45  7800
     46  7800							;------------------------------------------------------------------------------
     47  7800
      0  7800					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  7800		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  7800					      SUBROUTINE
      3  7800				   DrawTimeFromROM
     49  7800
     50  7800		       a9 09		      lda	#BANK_SCORING
     51  7802		       85 3e		      sta	SET_BANK_RAM
     52  7804		       20 9f f2 	      jsr	DrawTime
     53  7807		       20 93 f2 	      jsr	DrawBCD_targetsRequired
     54  780a		       a5 bf		      lda	ROM_Bank
     55  780c		       85 3f		      sta	SET_BANK
     56  780e		       60		      rts
     57  780f
     58  780f							;------------------------------------------------------------------------------
     59  780f
      0  780f					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  780f		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  780f					      SUBROUTINE
      3  780f				   GetROMByte
     61  780f
     62  780f							; a = ROM bank to retrieve
     63  780f							; y = page index
     64  780f							; ROM_Bank = bank to return to
     65  780f							; (Board_AddressR) = page
     66  780f							; out a = byte from (Board_AddressR)
     67  780f
     68  780f		       85 3f		      sta	SET_BANK	;3
     69  7811		       4c 16 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
     70  7814
     71  7814							;------------------------------------------------------------------------------
     72  7814
      0  7814					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7814		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7814					      SUBROUTINE
      3  7814				   GetBoardCharacter
     74  7814
     75  7814							; call from ROM bank
     76  7814							; switches back to ROM_Bank on exit
     77  7814
     78  7814							; pass A = bank containing character
     79  7814							; Y = x character position
     80  7814							; (Board_AddressR) points to character position
     81  7814							; returns character from board
     82  7814
     83  7814
     84  7814		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
     85  7816
     86  7816				   GetBoardCharacter2		;=17(A)
     87  7816
     88  7816		       b3 bb		      lax	(Board_AddressR),y	;5
     89  7818		       a4 bf		      ldy	ROM_Bank	;3
     90  781a		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
     91  781c		       60		      rts		;6   and go back
     92  781d
     93  781d							;---------------------------------------------------------------------------
     94  781d
      0  781d					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  781d		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  781d					      SUBROUTINE
      3  781d				   PutBoardCharacter
     96  781d
     97  781d		       86 3e		      stx	SET_BANK_RAM	; 3
     98  781f
     99  781f				   PutBoardCharacterSB		; =18
    100  781f		       91 bd		      sta	(Board_AddressW),y	; 6
    101  7821		       a5 bf		      lda	ROM_Bank	; 3
    102  7823		       85 3f		      sta	SET_BANK	; 3
    103  7825		       60		      rts		; 6 = 21
    104  7826
    105  7826							;---------------------------------------------------------------------------
    106  7826
      0  7826					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  7826		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  7826					      SUBROUTINE
      3  7826				   GetBoardCharacter__CALL_FROM_RAM__
    108  7826
    109  7826		       a4 88		      ldy	POS_Y	;3
    110  7828
    111  7828		       a9 0d		      lda	#BANK_GetBoardAddressR	;
    112  782a		       85 3f		      sta	SET_BANK	;
    113  782c		       20 ad f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    114  782f
    115  782f
    116  782f							;DEFINE_SUBROUTINE PartialGetBoardCharacter ;=23
    117  782f
    118  782f		       85 3e		      sta	SET_BANK_RAM	;3
    119  7831		       a4 87		      ldy	POS_X	;3
    120  7833		       b3 bb		      lax	(Board_AddressR),y	;5
    121  7835		       a4 c0		      ldy	RAM_Bank	;3
    122  7837		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    123  7839		       60		      rts		;6		 and go back
    124  783a
    125  783a							;---------------------------------------------------------------------------
    126  783a
      0  783a					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  783a		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  783a					      SUBROUTINE
      3  783a				   PutBoardCharacterFromRAM
    128  783a
    129  783a							; POS_Y  = row
    130  783a							; POS_Type = character to write
    131  783a							; POS_X     = column
    132  783a							; RAM_Bank = caller's bank
    133  783a
    134  783a		       a4 88		      ldy	POS_Y	;3
    135  783c
    136  783c		       a9 0d		      lda	#BANK_GetBoardAddressW	;
    137  783e		       85 3f		      sta	SET_BANK	;
    138  7840		       20 ba f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
    139  7843
    140  7843		       86 3e		      stx	SET_BANK_RAM	;3
    141  7845
    142  7845		       a4 87		      ldy	POS_X	;3
    143  7847		       a5 8b		      lda	POS_Type	;3
    144  7849		       91 bd		      sta	(Board_AddressW),y	;6
    145  784b		       a4 c0		      ldy	RAM_Bank	;3
    146  784d		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    147  784f		       60		      rts		;6
    148  7850
    149  7850
      0  7850					      DEFINE_SUBROUTINE	PutBoardCharacterFromROM
      1  7850		       00 0f	   BANK_PutBoardCharacterFromROM =	_CURRENT_BANK
      2  7850					      SUBROUTINE
      3  7850				   PutBoardCharacterFromROM
    151  7850		       48		      pha
    152  7851		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    153  7854		       68		      pla
    154  7855		       85 3f		      sta	SET_BANK
    155  7857		       60		      rts
    156  7858
    157  7858							;---------------------------------------------------------------------------
    158  7858
      0  7858					      DEFINE_SUBROUTINE	ProcessObjStack	; @31✅ called from Vector
      1  7858		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  7858					      SUBROUTINE
      3  7858				   ProcessObjStack
    160  7858							; 15 minimum segtime abort
    161  7858
    162  7858		       ad 84 02 	      lda	INTIM	; 4
    163  785b		       c9 03		      cmp	#MINIMUM_SEGTIME	; 2
    164  785d		       90 31		      bcc	EarlyAbort	; 2(3)= 8
    165  785f							; => [31]+9+6rts = 46✅ on abort
    166  785f							; @0✅
    167  785f
    168  785f		       a5 82		      lda	ObjStackNum	; 3
    169  7861		       49 01		      eor	#1	; 2
    170  7863		       aa		      tax		; 2 = 7✅
    171  7864
    172  7864		       a5 c3		      lda	ObjIterator	; 3
    173  7866		       d5 83		      cmp	ObjStackPtr,x	; 5
    174  7868		       b0 24		      bcs	nextPhase	; 2/3 = 10/11[+11] ==> @22✅ on exit
    175  786a
    176  786a							; @17✅
    177  786a							; Process an object...
    178  786a							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    179  786a
    180  786a		       bc 31 f9 	      ldy	BankObjStack,x	; 4
    181  786d		       84 3e		      sty	SET_BANK_RAM	; 3 = 7
    182  786f
    183  786f		       aa		      tax		; 2
    184  7870		       bc 80 11 	      ldy	SortedObjPtr,x	; 4 = 6	      indirect object pointer list (sorted)
    185  7873
    186  7873		       b9 00 10 	      lda	ObjStackX,y	; 4
    187  7876		       85 87		      sta	POS_X	; 3
    188  7878		       b9 80 10 	      lda	ObjStackY,y	; 4
    189  787b		       85 88		      sta	POS_Y	; 3
    190  787d		       b9 00 11 	      lda	ObjStackVar,y	; 4
    191  7880		       85 8c		      sta	POS_VAR	; 3
    192  7882		       be 00 12 	      ldx	ObjStackType,y	; 4
    193  7885		       86 8b		      stx	POS_Type	; 3 = 28
    194  7887
    195  7887		       a9 0d		      lda	#BANK_VectorProcess	; 2
    196  7889		       85 3f		      sta	SET_BANK	; 3
    197  788b		       4c 71 f3 	      jmp	VectorProcess	; 3 = 8
    198  788e
    199  788e							; => [17]+7+6+28+8 = @64 entry to VectorProcess
    200  788e							; + 31 minimum timeout return
    201  788e							; = 95✅
    202  788e
    203  788e							;---------------------------------------------------------------------------
    204  788e							; Now process the blank stack.  This stack holds all the recently blanked squares
    205  788e							; and determines (and moves) BOXs or TARGETs into these squares.  The space vacated
    206  788e							; by these objects are added again to the blank stack.
    207  788e
    208  788e				   nextPhase		; +11✅ for exit from here
    209  788e
    210  788e		       e6 86		      inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    211  7890		       60	   EarlyAbort rts		;6
    212  7891
    213  7891							;---------------------------------------------------------------------------
    214  7891
      0  7891					      DEFINE_SUBROUTINE	SwitchObjects	; = 31 ✅
      1  7891		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  7891					      SUBROUTINE
      3  7891				   SwitchObjects
    216  7891
    217  7891							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    218  7891							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    219  7891							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    220  7891
    221  7891		       ad 84 02 	      lda	INTIM	; 4
    222  7894		       c9 03		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    223  7896		       90 f8		      bcc	EarlyAbort	; 2(3) => [31]+(9)+6rts = 46✅ on abort
    224  7898
    225  7898							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    226  7898							; we're at the throttle cutoff do we switch game-frames.
    227  7898
    228  7898
    229  7898
    230  7898							;		  ;sec
    231  7898							;		  lda Throttle			  ;3
    232  7898							;		  sbc #MAX_THROTTLE		  ;2
    233  7898							;	      ;    bcc EarlyAbort		   ;2/3 	   plenty of time left!
    234  7898							;		  sta Throttle			  ;3 = 10	  save fractional 'left over' bit
    235  7898
    236  7898
    237  7898							; Now that we have completed processing the object stack, we switch
    238  7898							; the stack bank pointers for the next time around.
    239  7898
    240  7898		       a5 82		      lda	ObjStackNum	;3
    241  789a		       49 01		      eor	#1	;2
    242  789c		       aa		      tax		;2
    243  789d		       86 82		      stx	ObjStackNum	;3 = 10	 swap stacks @here
    244  789f
    245  789f							; Initialise the iterator and stack pointer for next time around.
    246  789f							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    247  789f							; necessary to initialise both.
    248  789f
    249  789f		       a0 00		      ldy	#0	;2
    250  78a1		       84 c3		      sty	ObjIterator	;3
    251  78a3		       94 83		      sty	ObjStackPtr,x	;4
    252  78a5
    253  78a5		       84 86		      sty	ScreenDrawPhase	;3
    254  78a7		       60		      rts		;6
    255  78a8
    256  78a8							;---------------------------------------------------------------------------
    257  78a8
    258  78a8		       60	   EarlyAbort4 rts
    259  78a9
      0  78a9					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  78a9		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  78a9					      SUBROUTINE
      3  78a9				   PROCESS_MAN
    261  78a9
    262  78a9		       ad 84 02 	      lda	INTIM	; 3
    263  78ac		       c9 10		      cmp	#SEGTIME_MAN	; 2
    264  78ae		       90 f8		      bcc	EarlyAbort4	; 2/3 = 7 + 6rts = 13✅ on abort
    265  78b0
    266  78b0		       a9 0d		      lda	#BANK_ManProcess
    267  78b2		       85 bf		      sta	ROM_Bank
    268  78b4		       85 3f		      sta	SET_BANK
    269  78b6		       20 65 f1 	      jsr	ManProcess
    270  78b9
    271  78b9
    272  78b9		       a9 ff		      lda	#-1
    273  78bb		       85 91		      sta	TB_CHAR	; pre-set box takeback to NONE
    274  78bd							;sta BufferedJoystick
    275  78bd
    276  78bd		       20 33 f9 	      jsr	MovePlayer
    277  78c0
    278  78c0		       a5 a1	   DoNothing  lda	ManMode
    279  78c2		       c9 07		      cmp	#MANMODE_NEXTLEVEL	; kludge
    280  78c4		       b0 08		      bcs	notComplete
    281  78c6		       a5 b5		      lda	BCD_targetsRequired
    282  78c8		       d0 04		      bne	notComplete
    283  78ca		       a9 07		      lda	#MANMODE_NEXTLEVEL
    284  78cc		       85 a1		      sta	ManMode
    285  78ce				   notComplete
    286  78ce
    287  78ce		       a9 03		      lda	#BANK_TrackPlayer	;
    288  78d0		       85 3f		      sta	SET_BANK	;
    289  78d2		       20 ca f4 	      jsr	TrackPlayer	;11+145
    290  78d5
    291  78d5		       a9 00		      lda	#TYPE_MAN	; 2
    292  78d7		       85 8b		      sta	POS_Type	; 3
    293  78d9
    294  78d9		       20 03 f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    295  78dc		       4c f8 f8    gnobj      jmp	NextObject
    296  78df
    297  78df							;---------------------------------------------------------------------------
    298  78df
      0  78df					      DEFINE_SUBROUTINE	PutCharacterAtXY
      1  78df		       00 0f	   BANK_PutCharacterAtXY =	_CURRENT_BANK
      2  78df					      SUBROUTINE
      3  78df				   PutCharacterAtXY
    300  78df
    301  78df							; POS_X	 character location
    302  78df							; POS_Y
    303  78df							; POS_VAR	 character to put on board
    304  78df							; ROM_Bank	 ROM bank to return to
    305  78df
    306  78df		       a4 88		      ldy	POS_Y
    307  78e1
    308  78e1		       a9 0d		      lda	#BANK_GetBoardAddressW
    309  78e3		       85 3f		      sta	SET_BANK
    310  78e5		       20 ba f0 	      jsr	GetBoardAddressW
    311  78e8		       86 3e		      stx	SET_BANK_RAM
    312  78ea
    313  78ea		       a4 87		      ldy	POS_X
    314  78ec		       a5 8c		      lda	POS_VAR
    315  78ee		       91 bd		      sta	(Board_AddressW),y
    316  78f0
    317  78f0		       a5 bf		      lda	ROM_Bank
    318  78f2		       85 3f		      sta	SET_BANK
    319  78f4		       60		      rts
    320  78f5
    321  78f5							;---------------------------------------------------------------------------
    322  78f5
    323  78f5							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    324  78f5							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    325  78f5
    326  78f5							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    327  78f5
    328  78f5							; if the creature dies then jump NextObject
    329  78f5
    330  78f5
    331  78f5		       20 03 f9    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    332  78f8
    333  78f8		       e6 c3	   NextObject inc	ObjIterator	; 5
    334  78fa							;		  dec ObjStackPtr,x		  ; 6
    335  78fa		       60		      rts		;jmp ProcessObjStack		  ; 3 = 16	 ; DON'T chain, instead return
    336  78fb							; let the segtime stuff do its job!
    337  78fb
    338  78fb							;---------------------------------------------------------------------------
    339  78fb
      0  78fb					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  78fb		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  78fb					      SUBROUTINE
      3  78fb				   InsertObjectStackFromRAM
    341  78fb
    342  78fb		       20 03 f9 	      jsr	InsertObjectStack	;6+76(B)
    343  78fe		       a5 c0		      lda	RAM_Bank	;3
    344  7900		       85 3e		      sta	SET_BANK_RAM	;3
    345  7902
    346  7902		       60	   NotEnoughTime rts		;6
    347  7903
    348  7903							;---------------------------------------------------------------------------
    349  7903
      0  7903					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  7903		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  7903					      SUBROUTINE
      3  7903				   InsertObjectStack
    351  7903							; POS_X     x position
    352  7903							; POS_Y     y position
    353  7903							; POS_VAR   direction or other variable
    354  7903							; POS_Type  type of object
    355  7903
    356  7903		       a6 82		      ldx	ObjStackNum	; 3
    357  7905		       bc 31 f9 	      ldy	BankObjStack,x	; 4
    358  7908		       84 3e		      sty	SET_BANK_RAM	; 3
    359  790a		       b4 83		      ldy	ObjStackPtr,x	; 4 = 14
    360  790c
    361  790c
    362  790c		       a5 88		      lda	POS_Y	; 3
    363  790e		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    364  7911		       a5 87		      lda	POS_X	; 3
    365  7913		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    366  7916		       a5 8c		      lda	POS_VAR	; 3
    367  7918		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    368  791b		       a5 8b		      lda	POS_Type	; 3
    369  791d		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    370  7920
    371  7920							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    372  7920							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    373  7920							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    374  7920
    375  7920
    376  7920				  -	      IF	TYPE_MAN != 0
    377  7920				  -	      cmp	#TYPE_MAN	; 2
    378  7920					      ENDIF
    379  7920		       f0 04		      beq	alwaysAllowMan	; 2/3
    380  7922
    381  7922		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    382  7924		       b0 06		      bcs	insertDone	; 2/3= 6    no room -- drop object
    383  7926				   alwaysAllowMan
    384  7926
    385  7926		       98		      tya		; 2
    386  7927		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    387  792a
    388  792a		       f6 83		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    389  792c
    390  792c		       a4 bf	   insertDone ldy	ROM_Bank	; 3
    391  792e		       84 3f		      sty	SET_BANK	; 3
    392  7930
    393  7930				   ManIsDead2
    394  7930
    395  7930
    396  7930
    397  7930		       60		      rts		; 6 = 29
    398  7931
    399  7931							;---------------------------------------------------------------------------
    400  7931
    401  7931		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    402  7933
    403  7933							;---------------------------------------------------------------------------
    404  7933
      0  7933					      DEFINE_SUBROUTINE	MovePlayer
      1  7933		       00 0f	   BANK_MovePlayer =	_CURRENT_BANK
      2  7933					      SUBROUTINE
      3  7933				   MovePlayer
    406  7933
    407  7933		       a4 8a		      ldy	POS_Y_NEW
    408  7935
    409  7935		       a9 0d		      lda	#BANK_GetBoardAddressRW	;2
    410  7937		       85 3f		      sta	SET_BANK	;3
    411  7939		       20 9a f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    412  793c							;    IF MULTI_BANK_BOARD = YES
    413  793c							;		  stx RAM_Bank
    414  793c							;    ENDIF
    415  793c		       86 3e		      stx	SET_BANK_RAM	; 3
    416  793e
    417  793e		       a4 89		      ldy	POS_X_NEW
    418  7940		       b3 bb		      lax	(Board_AddressR),y
    419  7942
    420  7942		       a9 0d		      lda	#BANK_MoveVecLO
    421  7944		       85 3f		      sta	SET_BANK
    422  7946
    423  7946		       bd 80 f3 	      lda	MoveVecLO,x
    424  7949		       85 d2		      sta	MAN_Move
    425  794b		       bd 8f f3 	      lda	MoveVecHI,x
    426  794e		       85 d3		      sta	MAN_Move+1
    427  7950
    428  7950							;    IF MULTI_BANK_BOARD = YES
    429  7950							;		  lda RAM_Bank
    430  7950							;    ELSE
    431  7950		       a9 0d		      lda	#BANK_BOARD
    432  7952							;    ENDIF
    433  7952		       85 3e		      sta	SET_BANK_RAM
    434  7954		       6c d2 00 	      jmp	(MAN_Move)
    435  7957
    436  7957							;---------------------------------------------------------------------------
    437  7957
      0  7957					      DEFINE_SUBROUTINE	RecordTakeBackPosition
      1  7957		       00 0f	   BANK_RecordTakeBackPosition =	_CURRENT_BANK
      2  7957					      SUBROUTINE
      3  7957				   RecordTakeBackPosition
    439  7957
    440  7957							; Pass...
    441  7957							; TB_X 	 the man's position before he moved
    442  7957							; TB_Y
    443  7957							; TB_CHAR	 if -1 then there is no box push involved, else..
    444  7957							;		 holds the character that was under the box in its new position
    445  7957							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    446  7957							; TB_PUSHY
    447  7957
    448  7957							; On making a move,
    449  7957							; man's position before move --> TB_X,TB_Y
    450  7957							; TB_CHAR = -1
    451  7957							; IF a box was pushed,
    452  7957							;   TB_CHAR = character under the box's new position (i.e., restoration char)
    453  7957							;   box's new position --> TB_PUSHX, TB_PUSHY
    454  7957							; ENDIF
    455  7957							; BCD_moveCounter++
    456  7957
    457  7957		       a5 ba		      lda	TakebackInhibit
    458  7959		       d0 2e		      bne	noLog
    459  795b
    460  795b		       a9 0e		      lda	#BANK_TAKEBACK
    461  795d		       85 3e		      sta	SET_BANK_RAM
    462  795f
    463  795f		       a6 b8		      ldx	takebackIndex
    464  7961
    465  7961		       a5 8d		      lda	TB_X
    466  7963		       9d 00 14 	      sta	RAM_WRITE+TakeBackPreviousX,x
    467  7966		       a5 8e		      lda	TB_Y
    468  7968		       9d 40 14 	      sta	RAM_WRITE+TakeBackPreviousY,x
    469  796b		       a5 91		      lda	TB_CHAR
    470  796d		       9d 00 15 	      sta	RAM_WRITE+TakeBackPushChar,x
    471  7970
    472  7970							; if TB_CHAR is -1 that means there is no box component, and the following values are random
    473  7970
    474  7970		       a5 8f		      lda	TB_PUSHX
    475  7972		       9d 80 14 	      sta	RAM_WRITE+TakeBackPushX,x
    476  7975		       a5 90		      lda	TB_PUSHY
    477  7977		       9d c0 14 	      sta	RAM_WRITE+TakeBackPushY,x
    478  797a
    479  797a		       a5 bf		      lda	ROM_Bank
    480  797c		       85 3f		      sta	SET_BANK
    481  797e
    482  797e							; fall through
    483  797e
      0  797e					      DEFINE_SUBROUTINE	IncrementMoveCount
      1  797e		       00 0f	   BANK_IncrementMoveCount =	_CURRENT_BANK
      2  797e					      SUBROUTINE
      3  797e				   IncrementMoveCount
    485  797e		       a9 0d		      lda	#BANK_IMC
    486  7980		       85 3f		      sta	SET_BANK
    487  7982		       20 4e f3 	      jsr	IMC
    488  7985		       a5 bf		      lda	ROM_Bank
    489  7987		       85 3f		      sta	SET_BANK
    490  7989
    491  7989		       a9 00	   noLog      lda	#0
    492  798b		       85 ba		      sta	TakebackInhibit
    493  798d		       60		      rts
    494  798e
    495  798e							;---------------------------------------------------------------------------
    496  798e
      0  798e					      DEFINE_SUBROUTINE	MOVE_BLANK
      1  798e		       00 0f	   BANK_MOVE_BLANK =	_CURRENT_BANK
      2  798e					      SUBROUTINE
      3  798e				   MOVE_BLANK
      0  798e					      DEFINE_SUBROUTINE	MOVE_SOIL
      1  798e		       00 0f	   BANK_MOVE_SOIL =	_CURRENT_BANK
      2  798e					      SUBROUTINE
      3  798e				   MOVE_SOIL
      0  798e					      DEFINE_SUBROUTINE	MOVE_TARGET
      1  798e		       00 0f	   BANK_MOVE_TARGET =	_CURRENT_BANK
      2  798e					      SUBROUTINE
      3  798e				   MOVE_TARGET
    500  798e
    501  798e		       8a		      txa		; character man will be standing on
    502  798f		       48		      pha
    503  7990
    504  7990
    505  7990		       a5 a6		      lda	ManAnimationID
    506  7992		       c9 08		      cmp	#ANIMATION_PUSH_ID
    507  7994		       d0 0c		      bne	immediate
    508  7996
    509  7996		       e6 a8		      inc	idleCount
    510  7998		       a5 a8		      lda	idleCount
    511  799a		       c9 0a		      cmp	#10
    512  799c		       90 22		      bcc	walkingOK
    513  799e		       a9 00		      lda	#0
    514  79a0		       85 a8		      sta	idleCount
    515  79a2
    516  79a2				   immediate
    517  79a2		       a5 a6		      lda	ManAnimationID
    518  79a4		       c9 00		      cmp	#ANIMATION_WALK_ID
    519  79a6		       f0 18		      beq	walkingOK
    520  79a8		       c9 0c		      cmp	#ANIMATION_WALK2_ID
    521  79aa		       f0 14		      beq	walkingOK
    522  79ac		       a9 00		      lda	#ANIMATION_WALK_ID
    523  79ae		       85 a6		      sta	ManAnimationID
      0  79b0					      LOAD_ANIMATION	WALK
      1  79b0		       a9 12		      lda	#<Animation_WALK
      2  79b2		       85 9a		      sta	animation
      3  79b4		       a9 f0		      lda	#>Animation_WALK
      4  79b6		       85 9b		      sta	animation+1
      5  79b8		       a9 00		      lda	#0
      6  79ba		       85 9c		      sta	animation_delay
      7  79bc		       a9 00		      lda	#ANIMATION_WALK_ID
      8  79be		       85 a6		      sta	ManAnimationID
      9  79c0
    525  79c0				   walkingOK
    526  79c0
    527  79c0		       a5 9d		      lda	ManX
    528  79c2		       85 87		      sta	POS_X
    529  79c4		       85 8d		      sta	TB_X
    530  79c6		       a5 9e		      lda	ManY
    531  79c8		       85 88		      sta	POS_Y
    532  79ca		       85 8e		      sta	TB_Y
    533  79cc		       20 df f8 	      jsr	PutCharacterAtXY	; RESTORE (previous XY) under-man character
    534  79cf
    535  79cf		       a5 89		      lda	POS_X_NEW
    536  79d1		       85 9d		      sta	ManX
    537  79d3		       85 87		      sta	POS_X
    538  79d5		       a5 8a		      lda	POS_Y_NEW
    539  79d7		       85 9e		      sta	ManY
    540  79d9		       85 88		      sta	POS_Y
    541  79db		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    542  79dd		       85 8c		      sta	POS_VAR
    543  79df		       20 df f8 	      jsr	PutCharacterAtXY
    544  79e2
    545  79e2							; TB_X 	 the man's position before he moved
    546  79e2							; TB_Y
    547  79e2							; TB_CHAR	 if -1 then there is no box push involved, else..
    548  79e2							;		 holds the character that was under the box in its new position
    549  79e2							;		 this can be inferred by the box character (ONTARGET)
    550  79e2							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    551  79e2							; TB_PUSHY
    552  79e2
    553  79e2		       20 57 f9 	      jsr	RecordTakeBackPosition
    554  79e5
    555  79e5		       68		      pla
    556  79e6		       85 8c		      sta	POS_VAR	; save 'restore' character
    557  79e8
    558  79e8		       a9 00	   MOVE_GENERIC lda	#0	; 2
    559  79ea		       85 a4		      sta	ManPushCounter	; 3
    560  79ec		       60		      rts		; 6 = 11
    561  79ed
    562  79ed							;---------------------------------------------------------------------------
    563  79ed							; takeback buffer empty - flash red
    564  79ed
    565  79ed		       a6 80	   noMovesToTake ldx	Platform
    566  79ef		       bd f9 f9 	      lda	redColour,x
    567  79f2		       85 b1		      sta	BGColour
    568  79f4		       a9 06		      lda	#6
    569  79f6		       85 c1		      sta	ColourTimer
    570  79f8		       60		      rts
    571  79f9
    572  79f9		       32 32 62 62 redColour  .byte.b	$32, $32, $62, $62
    573  79fd
    574  79fd							;---------------------------------------------------------------------------
    575  79fd
      0  79fd					      DEFINE_SUBROUTINE	MOVE_BOX
      1  79fd		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  79fd					      SUBROUTINE
      3  79fd				   MOVE_BOX
    577  79fd
    578  79fd		       a2 00		      ldx	#CHARACTER_BLANK	; restoration character
    579  79ff		       a9 0d		      lda	#BANK_PushBox
    580  7a01		       85 3f		      sta	SET_BANK
    581  7a03		       4c ca f0 	      jmp	PushBox
    582  7a06
      0  7a06					      DEFINE_SUBROUTINE	MOVE_BOX_ON_TARGET
      1  7a06		       00 0f	   BANK_MOVE_BOX_ON_TARGET =	_CURRENT_BANK
      2  7a06					      SUBROUTINE
      3  7a06				   MOVE_BOX_ON_TARGET
    584  7a06
    585  7a06		       a2 03		      ldx	#CHARACTER_TARGET	; restoration character
    586  7a08		       a9 0d		      lda	#BANK_PushBox
    587  7a0a		       85 3f		      sta	SET_BANK
    588  7a0c		       4c ca f0 	      jmp	PushBox
    589  7a0f
    590  7a0f							;---------------------------------------------------------------------------
    591  7a0f
      0  7a0f					      DEFINE_SUBROUTINE	takebackRestoreEarlierPosition
      1  7a0f		       00 0f	   BANK_takebackRestoreEarlierPosition =	_CURRENT_BANK
      2  7a0f					      SUBROUTINE
      3  7a0f				   takebackRestoreEarlierPosition
    593  7a0f
    594  7a0f		       e6 ba		      inc	TakebackInhibit	; non-zero
    595  7a11
    596  7a11							; on reverting a move
    597  7a11							; IF BCD_moveCounter > 0
    598  7a11							;   BCD_moveCounter--
    599  7a11							;   IF TakeBackPushChar != -1
    600  7a11							;	 //restore the character under box (and remove box)
    601  7a11							;	 board[TakeBackPreviousX,TakeBackPreviousY] = TakeBackPushChar
    602  7a11							;   ENDIF
    603  7a11							; // We will "fix" any box going back on the board through the man's restoration char
    604  7a11							; board[ManX,ManY] = POS_VAR
    605  7a11							; POS_VAR = board[TakeBackX,TakeBackY]
    606  7a11							; board[TakeBackX,TakeBackY] = MANOCCUPIED
    607  7a11							; ManX,ManY = TakeBackX, TakeBackY
    608  7a11
    609  7a11		       a6 b8		      ldx	takebackIndex
    610  7a13		       e4 b9		      cpx	takebackBaseIndex
    611  7a15		       f0 d6		      beq	noMovesToTake
    612  7a17
    613  7a17		       ca		      dex
    614  7a18		       8a		      txa
    615  7a19		       29 3f		      and	#TAKEBACK_MASK
    616  7a1b		       85 b8		      sta	takebackIndex
    617  7a1d		       aa		      tax
    618  7a1e
    619  7a1e		       f8		      sed
    620  7a1f		       38		      sec
    621  7a20		       a5 b6		      lda	BCD_moveCounter
    622  7a22		       e9 01		      sbc	#1
    623  7a24		       85 b6		      sta	BCD_moveCounter
    624  7a26		       a5 b7		      lda	BCD_moveCounter+1
    625  7a28		       e9 00		      sbc	#0
    626  7a2a		       85 b7		      sta	BCD_moveCounter+1
    627  7a2c		       d8		      cld
    628  7a2d
    629  7a2d				  -	      if	0
    630  7a2d				  -	      lda	Platform
    631  7a2d				  -	      clc
    632  7a2d				  -	      adc	#8
    633  7a2d				  -	      sta	BGColour	;ColourFlash		      ; yellow flash
    634  7a2d				  -	      lda	#3
    635  7a2d				  -	      sta	ColourTimer
    636  7a2d					      endif
    637  7a2d
    638  7a2d		       a9 0e		      lda	#BANK_TAKEBACK
    639  7a2f		       85 3e		      sta	SET_BANK_RAM
    640  7a31
    641  7a31							; TB_X 	 the man's position before he moved
    642  7a31							; TB_Y
    643  7a31							; TB_CHAR	 if -1 then there is no box push involved, else..
    644  7a31							;		 holds the character that was under the box in its new position
    645  7a31							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    646  7a31							; TB_PUSHY
    647  7a31
    648  7a31							;	 //restore the character under box (and remove box)
    649  7a31							;	 board[TakeBackPreviousX,TakeBackPreviousY] = TakeBackPushChar
    650  7a31
    651  7a31		       a5 8c		      lda	POS_VAR
    652  7a33		       48		      pha
    653  7a34
    654  7a34		       a6 b8		      ldx	takebackIndex
    655  7a36		       bd 00 11 	      lda	TakeBackPushChar,x
    656  7a39		       30 29		      bmi	noPushInvolved	; -1 = no box
    657  7a3b
    658  7a3b		       85 8c		      sta	POS_VAR
    659  7a3d		       c9 03		      cmp	#CHARACTER_TARGET
    660  7a3f		       f0 04		      beq	isaTarget
    661  7a41		       c9 04		      cmp	#CHARACTER_TARGET2
    662  7a43		       d0 03		      bne	notTarget1
    663  7a45		       20 ed fc    isaTarget  jsr	RegisterTarget
    664  7a48				   notTarget1
    665  7a48
    666  7a48
    667  7a48		       bd 80 10 	      lda	TakeBackPushX,x
    668  7a4b		       85 87		      sta	POS_X
    669  7a4d		       bd c0 10 	      lda	TakeBackPushY,x
    670  7a50		       85 88		      sta	POS_Y
    671  7a52
    672  7a52		       20 df f8 	      jsr	PutCharacterAtXY	; fixup BOX!
    673  7a55
    674  7a55		       68		      pla
    675  7a56		       f0 07		      beq	blnkre
    676  7a58		       20 f7 fc 	      jsr	DeRegisterTarget
    677  7a5b		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    678  7a5d		       d0 02		      bne	skls
    679  7a5f		       a9 02	   blnkre     lda	#CHARACTER_BOX
    680  7a61		       85 8c	   skls       sta	POS_VAR
    681  7a63
    682  7a63		       48		      pha
    683  7a64
    684  7a64		       68	   noPushInvolved pla		; man's replacement char
    685  7a65		       85 8c		      sta	POS_VAR
    686  7a67
    687  7a67							; // We will "fix" any box going back on the board through the man's restoration char
    688  7a67							; board[ManX,ManY] = POS_VAR
    689  7a67							; POS_VAR = board[TakeBackX,TakeBackY]
    690  7a67							; board[TakeBackX,TakeBackY] = MANOCCUPIED
    691  7a67							; ManX,ManY = TakeBackX, TakeBackY
    692  7a67
    693  7a67		       a5 9d		      lda	ManX
    694  7a69		       85 87		      sta	POS_X
    695  7a6b		       a5 9e		      lda	ManY
    696  7a6d		       85 88		      sta	POS_Y
    697  7a6f		       20 df f8 	      jsr	PutCharacterAtXY	; put what man was on... back
    698  7a72
    699  7a72
    700  7a72		       a9 0e		      lda	#BANK_TAKEBACK
    701  7a74		       85 3e		      sta	SET_BANK_RAM
    702  7a76
    703  7a76		       a6 b8		      ldx	takebackIndex
    704  7a78		       bd 00 10 	      lda	TakeBackPreviousX,x
    705  7a7b		       85 89		      sta	POS_X_NEW
    706  7a7d		       85 9d		      sta	ManX
    707  7a7f		       bd 40 10 	      lda	TakeBackPreviousY,x
    708  7a82		       85 8a		      sta	POS_Y_NEW
    709  7a84		       85 9e		      sta	ManY
    710  7a86
    711  7a86							; Grab the character from the board at man's location and use as "restore character" for man
    712  7a86							; POS_VAR = board[takebackx,takebacky]
    713  7a86
    714  7a86		       a9 0d		      lda	#BANK_GetBoardAddressR
    715  7a88		       85 3f		      sta	SET_BANK
    716  7a8a		       a4 8a		      ldy	POS_Y_NEW
    717  7a8c		       20 ad f0 	      jsr	GetBoardAddressR
    718  7a8f		       85 3e		      sta	SET_BANK_RAM
    719  7a91
    720  7a91		       a4 89		      ldy	POS_X_NEW
    721  7a93		       b1 bb		      lda	(Board_AddressR),y
    722  7a95							;pha
    723  7a95							;lda #CHARACTER_MANOCCUPIED
    724  7a95							;sta POS_VAR
    725  7a95							;jsr PutCharacterAtXY		 ????
    726  7a95							;pla
    727  7a95		       85 8c		      sta	POS_VAR
    728  7a97
    729  7a97		       a5 bf		      lda	ROM_Bank
    730  7a99		       85 3f		      sta	SET_BANK
    731  7a9b
    732  7a9b		       60	   timeExit   rts
    733  7a9c
    734  7a9c							;---------------------------------------------------------------------------
    735  7a9c
      0  7a9c					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7a9c		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7a9c					      SUBROUTINE
      3  7a9c				   StealCharDraw
    737  7a9c
    738  7a9c		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    739  7a9e		       85 3e		      sta	SET_BANK_RAM	; 3
    740  7aa0		       a4 81		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    741  7aa2		       10 35		      bpl	EnterStealCharDraw	; 2(3) = 10(11)
    742  7aa4
    743  7aa4				   ExitStealCharDraw
    744  7aa4
    745  7aa4							; fall through...
    746  7aa4
    747  7aa4							;---------------------------------------------------------------------------
    748  7aa4
      0  7aa4					      DEFINE_SUBROUTINE	TimeSlice
      1  7aa4		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7aa4					      SUBROUTINE
      3  7aa4				   TimeSlice
    750  7aa4
    751  7aa4							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    752  7aa4							; going ahead if there's insufficient time. This allows the previous character drawing to
    753  7aa4							; be much smaller in time, as they don't have to include the timeslice code overhead.
    754  7aa4
    755  7aa4		       ad 84 02 	      lda	INTIM	; 4
    756  7aa7		       c9 03		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    757  7aa9		       90 f0		      bcc	timeExit	; 2(3)
    758  7aab							; @0✅
    759  7aab
    760  7aab							; Uses the phase variable to vector to the correct processing code for the given timeslice
    761  7aab							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    762  7aab							; it should increment ScreenDrawPhase.
    763  7aab
    764  7aab							; Switched-in bank(s) are undefined after this function is called!
    765  7aab
    766  7aab		       a9 03		      lda	#BANK_TS_PhaseVectorLO	; 2
    767  7aad		       85 3f		      sta	SET_BANK	; 3 = 5
    768  7aaf
    769  7aaf		       a6 86		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    770  7ab1		       bd 05 f5 	      lda	TS_PhaseVectorLO,x	; 4
    771  7ab4		       85 d2		      sta	TS_Vector	; 3
    772  7ab6		       bd 0a f5 	      lda	TS_PhaseVectorHI,x	; 4
    773  7ab9		       85 d3		      sta	TS_Vector+1	; 3 = 17
    774  7abb
    775  7abb		       bd 0f f5 	      lda	TS_PhaseBank,x	; 4
    776  7abe		       85 3f		      sta	SET_BANK	; 3 = 7	 switch bank
    777  7ac0
    778  7ac0		       6c d2 00 	      jmp	(TS_Vector)	; 5 = 31✅	  vector to timeslice handler
    779  7ac3
    780  7ac3							;---------------------------------------------------------------------------
    781  7ac3
    782  7ac3
    783  7ac3				   DrawAnother		;344✅SCD_QUICK
    784  7ac3							;676✅SCD_SLOW
    785  7ac3
    786  7ac3
    787  7ac3							; add 44✅ cycles for the following in the case where there is something to draw
    788  7ac3							; but no time to do it. As this is executed after EVERY type of draw, then this
    789  7ac3							; is the base "extra" cost to add to each draw
    790  7ac3
    791  7ac3		       00 35	   CYCLES_DRAWANOTHER =	53	;✅
    792  7ac3
    793  7ac3		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    794  7ac5		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    795  7ac7
    796  7ac7		       a4 81		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    797  7ac9
    798  7ac9		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    799  7acc		       bd a0 f0 	      lda	ScreenBuffer,x	; 4	     new character to draw
    800  7acf		       29 7f		      and	#~128	; 2
    801  7ad1		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    802  7ad4
    803  7ad4		       88		      dey		; 2
    804  7ad5		       84 81		      sty	DrawStackPointer	; 3	     one less to draw
    805  7ad7		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7    NOTE1: (3)+(15exit) -->45✅ <CYCLES_DRAWANOTHER)
    806  7ad9							; => 29
    807  7ad9
    808  7ad9				   EnterStealCharDraw		; @11✅ from initial StealCharDraw call
    809  7ad9							; RAM bank MUST be at BANK_DRAW_BUFFERS
    810  7ad9
    811  7ad9		       ad 84 02 	      lda	INTIM	; 4
    812  7adc		       c9 04		      cmp	#SEGTIME_SCD_MIN	; 2
    813  7ade		       90 c4		      bcc	ExitStealCharDraw	; 2(3) = 8    ((9)+(15exit) IF EXITING HERE, from DrawAnother... 53✅)
    814  7ae0							;		else exit from StealCharDraw ... 26✅
    815  7ae0							; @0✅
    816  7ae0
    817  7ae0		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    818  7ae3		       bc a0 f0 	      ldy	ScreenBuffer,x	; 4 =	8✅  new character to draw
    819  7ae6
    820  7ae6		       bd 00 f2 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
    821  7ae9		       85 3e		      sta	SET_BANK_RAM	; 3
    822  7aeb		       4c 29 f1 	      jmp	StealPart3	; 3 = 10✅  --> 18✅ cycles after check for SEGTIME_SCD_MIN
    823  7aee
    824  7aee							;---------------------------------------------------------------------------
    825  7aee
    826  7aee
      0  7aee					      DEFINE_SUBROUTINE	writePlayerFrame
      1  7aee		       00 0f	   BANK_writePlayerFrame =	_CURRENT_BANK
      2  7aee					      SUBROUTINE
      3  7aee				   writePlayerFrame
    828  7aee
    829  7aee		       a5 80		      lda	Platform
    830  7af0		       29 02		      and	#%10
    831  7af2		       0a		      asl
    832  7af3		       0a		      asl
    833  7af4		       65 c5		      adc	ethnic
    834  7af6		       85 d7		      sta	ethnicity
    835  7af8
    836  7af8
    837  7af8							; todo - compare with last + frame and skip if same
    838  7af8
    839  7af8		       a9 0a		      lda	#PLAYER_FRAMES
    840  7afa		       85 3f		      sta	SET_BANK
    841  7afc
    842  7afc		       a5 9c		      lda	animation_delay
    843  7afe		       f0 0f		      beq	getDelay	; FIRST usage
    844  7b00		       c6 9c		      dec	animation_delay
    845  7b02		       d0 11		      bne	nextAnimation2	; just get shape
    846  7b04
    847  7b04		       18	   nextAptr   clc
    848  7b05		       a5 9a		      lda	animation
    849  7b07		       69 02		      adc	#2
    850  7b09		       85 9a		      sta	animation
    851  7b0b		       90 02		      bcc	ahiok
    852  7b0d		       e6 9b		      inc	animation+1
    853  7b0f				   ahiok
    854  7b0f		       a0 01	   getDelay   ldy	#1
    855  7b11		       b1 9a		      lda	(animation),y
    856  7b13		       85 9c		      sta	animation_delay
    857  7b15		       a0 00	   nextAnimation2 ldy	#0
    858  7b17		       b1 9a		      lda	(animation),y
    859  7b19		       c9 ff		      cmp	#JUMP
    860  7b1b		       f0 0d		      beq	aJump
    861  7b1d		       c9 fe		      cmp	#FLIP
    862  7b1f		       d0 18		      bne	notFlip
    863  7b21
    864  7b21		       a5 a2		      lda	ManLastDirection
    865  7b23		       49 08		      eor	#%1000
    866  7b25		       85 a2		      sta	ManLastDirection
    867  7b27		       4c 04 fb 	      jmp	nextAptr
    868  7b2a
    869  7b2a							; it's a jump
    870  7b2a		       a4 9c	   aJump      ldy	animation_delay	; actually animation ID :)
    871  7b2c		       b9 00 f0 	      lda	ANIM_TABLE,y
    872  7b2f		       85 9a		      sta	animation
    873  7b31		       b9 01 f0 	      lda	ANIM_TABLE+1,y
    874  7b34		       85 9b		      sta	animation+1
    875  7b36		       4c 0f fb 	      jmp	getDelay
    876  7b39
    877  7b39		       a8	   notFlip    tay
    878  7b3a
    879  7b3a		       a5 a0		      lda	ManDrawY
    880  7b3c		       30 44		      bmi	SkipFrameCopy
    881  7b3e		       85 d6		      sta	bank	; character line (and hence bank) of player position
    882  7b40		       85 3e		      sta	SET_BANK_RAM
    883  7b42
    884  7b42							; Now we have the frame #, we can see if that frame has already been drawn into
    885  7b42							; the frame buffer of the relevant bank. If it has, then we don't need to repeat
    886  7b42							; and can save the enormous cost of frame copying...
    887  7b42
    888  7b42		       cc 69 f3 	      cpy	ExistingFrame	; optimize - don't draw if same frame
    889  7b45		       f0 3b		      beq	SkipFrameCopy
    890  7b47		       8c 69 f7 	      sty	ExistingFrame + RAM_WRITE
    891  7b4a
    892  7b4a		       a9 0a		      lda	#PLAYER_FRAMES
    893  7b4c		       85 3f		      sta	SET_BANK
    894  7b4e		       b9 30 f6 	      lda	FRAME_PTR_LO,y
    895  7b51		       85 d2		      sta	frame_ptr
    896  7b53		       b9 45 f6 	      lda	FRAME_PTR_HI,y
    897  7b56		       85 d3		      sta	frame_ptr+1
    898  7b58
    899  7b58		       b9 5a f6 	      lda	COLOUR_PTR_LO,y
    900  7b5b		       85 d4		      sta	colour_ptr
    901  7b5d		       b9 6f f6 	      lda	COLOUR_PTR_HI,y
    902  7b60		       85 d5		      sta	colour_ptr+1
    903  7b62
    904  7b62
    905  7b62
    906  7b62		       a0 17		      ldy	#LINES_PER_CHAR-1
    907  7b64		       18		      clc
    908  7b65				   CopySpriteToBank		; 408
    909  7b65
    910  7b65							; The colours for the sprites are copied to the row bank's colour data. The frames contain
    911  7b65							; colour *indexes*. These indexes are modified by the *base* which indicates both the
    912  7b65							; system NTSC/PAL along with the "visual identity" (i.e., colour/race). That is used to
    913  7b65							; lookup a colour conversion which FINALLY gives us the correct colour to use for the line.
    914  7b65
    915  7b65							; ethnicity * 16 + PALNTSC * 8
    916  7b65
    917  7b65		       a9 0a		      lda	#PLAYER_FRAMES
    918  7b67		       85 3f		      sta	SET_BANK
    919  7b69
    920  7b69		       b1 d4		      lda	(colour_ptr),y
    921  7b6b		       65 d7		      adc	ethnicity	; colour base
    922  7b6d		       aa		      tax
    923  7b6e		       b1 d2		      lda	(frame_ptr),y
    924  7b70		       48		      pha
    925  7b71		       a5 d6		      lda	bank
    926  7b73		       85 3e		      sta	SET_BANK_RAM
    927  7b75		       bd a5 f2 	      lda	EthnicityColourPalette,x
    928  7b78		       99 51 f7 	      sta	PLAYER0_COLOUR+RAM_WRITE,y
    929  7b7b		       68		      pla
    930  7b7c		       99 39 f7 	      sta	PLAYER0_SHAPE+RAM_WRITE,y
    931  7b7f		       88		      dey
    932  7b80		       10 e3		      bpl	CopySpriteToBank
    933  7b82
    934  7b82				   skipOffscreen
    935  7b82		       60	   SkipFrameCopy rts
    936  7b83
    937  7b83							;---------------------------------------------------------------------------
    938  7b83
    939  7b83							;    DEFINE_SUBROUTINE DrawFullScreenMain ;=2484[-89]
    940  7b83
    941  7b83							; Check the screen for all those characters that need to be redrawn
    942  7b83							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
    943  7b83							; the drawflags array is different to the ScreenBuffer array entry, then the
    944  7b83							; screenbuffer will need redrawing.
    945  7b83
    946  7b83							; @59✅
    947  7b83
    948  7b83				   CopyRow2
    949  7b83
    950  7b83							;    IF MULTI_BANK_BOARD = YES
    951  7b83							;		  lda BDF_BoardBank		  ; 3
    952  7b83							;    ELSE
    953  7b83		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
    954  7b85							;    ENDIF
    955  7b85		       85 3e		      sta	SET_BANK_RAM	; 3
    956  7b87		       b3 d6		      lax	(BDF_BoardAddress),y	; 5
    957  7b89		       9a		      txs		; 2
    958  7b8a		       b3 d8		      lax	(BDF_BoardAddress2),y	; 5 = 17✅
    959  7b8c
    960  7b8c		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    961  7b8e		       85 3e		      sta	SET_BANK_RAM	; 3
    962  7b90		       bd da f1 	      lda	CharReplacement,x	; 4
    963  7b93		       91 d4		      sta	(BDF_DrawFlagAddress2),y	; 6
    964  7b95		       ba		      tsx		; 2
    965  7b96		       bd da f1 	      lda	CharReplacement,x	; 4
    966  7b99		       91 d2		      sta	(BDF_DrawFlagAddress),y	; 6 = 27 @44✅
    967  7b9b
    968  7b9b		       88		      dey		; 2
    969  7b9c		       10 e5		      bpl	CopyRow2	; 2/3 @48 (-1)
    970  7b9e
      0  7b9e					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED"
      9  7b9e					      LIST	ON
    972  7b9e
    973  7b9e							; cost = 5 (rows) x 48 - 1 = 239
    974  7b9e							; @ (59) + 239 = @298✅
    975  7b9e
    976  7b9e		       a7 db		      lax	DHS_Line	; 3
    977  7ba0		       f0 07		      beq	.exitCopy	; 2/3= 5/6
    978  7ba2
    979  7ba2		       a0 0d		      ldy	#BANK_DrawScreenRowPreparation	; 2
    980  7ba4		       84 3f		      sty	SET_BANK	; 3
    981  7ba6		       4c 00 f3 	      jmp	DrawScreenRowPreparation	; 3 = 8
    982  7ba9							; @298+8+5 = @311✅
    983  7ba9
    984  7ba9
    985  7ba9							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
    986  7ba9
    987  7ba9
      0  7ba9					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7ba9					      LIST	ON
    989  7ba9
    990  7ba9		       a6 dc	   .exitCopy  ldx	DHS_Stack	; 3
    991  7bab		       9a		      txs		; 2
    992  7bac
    993  7bac							; fall through
    994  7bac
      0  7bac					      DEFINE_SUBROUTINE	BuildDrawStack	; @31✅
      1  7bac		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7bac					      SUBROUTINE
      3  7bac				   BuildDrawStack
    996  7bac
    997  7bac		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    998  7bae		       85 3e		      sta	SET_BANK_RAM	; 3
    999  7bb0		       4c f1 f0 	      jmp	DrawStackUpdate	; 3
   1000  7bb3
   1001  7bb3							; => @39 at DrawStackUpdate
   1002  7bb3
   1003  7bb3							;---------------------------------------------------------------------------
   1004  7bb3
      0  7bb3					      DEFINE_SUBROUTINE	DrawAIntoStack	; @31✅
      1  7bb3		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7bb3					      SUBROUTINE
      3  7bb3				   DrawAIntoStack
   1006  7bb3
   1007  7bb3		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
   1008  7bb5		       85 3e		      sta	SET_BANK_RAM	; 3
   1009  7bb7		       4c 27 f1 	      jmp	DrawIntoStack	; 3
   1010  7bba
   1011  7bba							; ==>39✅ @DrawIntoStack
   1012  7bba
   1013  7bba							;---------------------------------------------------------------------------
   1014  7bba
   1015  7bba
      0  7bba					      DEFINE_SUBROUTINE	Reset
      1  7bba		       00 0f	   BANK_Reset =	_CURRENT_BANK
      2  7bba					      SUBROUTINE
      3  7bba				   Reset
   1017  7bba
      0  7bba					      CLEAN_START
      1  7bba		       78		      sei
      2  7bbb		       d8		      cld
      3  7bbc
      4  7bbc		       a2 00		      ldx	#0
      5  7bbe		       8a		      txa
      6  7bbf		       a8		      tay
      7  7bc0		       ca	   .CLEAR_STACK dex
      8  7bc1		       9a		      txs
      9  7bc2		       48		      pha
     10  7bc3		       d0 fb		      bne	.CLEAR_STACK
     11  7bc5
   1019  7bc5
   1020  7bc5							;lda #2
   1021  7bc5							;sta VSYNC
   1022  7bc5							;lda #%01000010		  ; bit6 is not required
   1023  7bc5							;sta VBLANK			  ; end of screen - enter blanking
   1024  7bc5
   1025  7bc5							; Scoring bank is copied once (not per game, not per level...)
   1026  7bc5							; otherwise non-SaveKey high score gets zapped
   1027  7bc5
   1028  7bc5		       a2 02		      ldx	#ROM_SHADOW_OF_BANK_SCORING
   1029  7bc7		       a0 09		      ldy	#BANK_SCORING
   1030  7bc9		       20 e4 fc 	      jsr	CopyROM2RAM_F000
   1031  7bcc
   1032  7bcc				   Restart		; go here on RESET + SELECT
   1033  7bcc
   1034  7bcc							; breakpoint was not hit/detected!!!
   1035  7bcc
      0  7bcc					      DEFINE_SUBROUTINE	Title
      1  7bcc		       00 0f	   BANK_Title =	_CURRENT_BANK
      2  7bcc					      SUBROUTINE
      3  7bcc				   Title
   1037  7bcc		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
   1038  7bce		       9a		      txs
   1039  7bcf
   1040  7bcf							; temporary vars from title screen are used to init level
   1041  7bcf		       a9 03		      lda	#BANK_Cart_Init	; 2
   1042  7bd1		       85 3f		      sta	SET_BANK	; 3
   1043  7bd3		       20 f1 f3 	      jsr	Cart_Init	; 6+x
   1044  7bd6
   1045  7bd6
   1046  7bd6							;---------------------------------------------------------------------------
   1047  7bd6
   1048  7bd6
   1049  7bd6		       f0 00	   SEGMENT_DECODE_LEVEL_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
   1050  7bd6
   1051  7bd6		       a2 03		      ldx	#BANK_DECODE_LEVEL_SHADOW
   1052  7bd8		       a0 0a		      ldy	#BANK_DECODE_LEVEL
   1053  7bda		       20 e4 fc 	      jsr	CopyROM2RAM_F000
   1054  7bdd
   1055  7bdd
   1056  7bdd							;---------------------------------------------------------------------------
   1057  7bdd							; Once-only game initialisation goes here...
   1058  7bdd							; now we have two players so things get a bit tricky
   1059  7bdd
   1060  7bdd		       a9 09		      lda	#BANK_SCORING
   1061  7bdf		       85 3e		      sta	SET_BANK_RAM
   1062  7be1		       20 63 f3 	      jsr	GameInitialise
   1063  7be4
   1064  7be4
   1065  7be4							;---------------------------------------------------------------------------
   1066  7be4
------- FILE sound/intro1_init.asm LEVEL 3 PASS 3
      0  7be4					      include	"sound/intro1_init.asm"
      1  7be4							; TIATracker music player
      2  7be4							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7be4							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7be4							; Email: andre.wichmann@gmx.de
      5  7be4							;
      6  7be4							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7be4							; you may not use this file except in compliance with the License.
      8  7be4							; You may obtain a copy of the License at
      9  7be4							;
     10  7be4							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7be4							;
     12  7be4							; Unless required by applicable law or agreed to in writing, software
     13  7be4							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7be4							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7be4							; See the License for the specific language governing permissions and
     16  7be4							; limitations under the License.
     17  7be4
     18  7be4							; Song author: 
     19  7be4							; Song name: 
     20  7be4
     21  7be4							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7be4
     23  7be4							; =====================================================================
     24  7be4							; Initialize music.
     25  7be4							; Set tt_cur_pat_index_c0/1 to the indexes of the first patterns from
     26  7be4							; tt_SequenceTable for each channel.
     27  7be4							; Set tt_timer and tt_cur_note_index_c0/1 to 0.
     28  7be4							; All other variables can start with any value.
     29  7be4							; =====================================================================
     30  7be4		       a9 00		      lda	#0
     31  7be6		       85 c8		      sta	tt_cur_pat_index_c0
     32  7be8		       a9 05		      lda	#5
     33  7bea		       85 c9		      sta	tt_cur_pat_index_c1
     34  7bec							; the rest should be 0 already from startup code. If not,
     35  7bec							; set the following variables to 0 manually:
     36  7bec							; - tt_timer
     37  7bec							; - tt_cur_pat_index_c0
     38  7bec							; - tt_cur_pat_index_c1
     39  7bec							; - tt_cur_note_index_c0
     40  7bec							; - tt_cur_note_index_c1
     41  7bec
------- FILE BANK_FIXED.asm
   1068  7bec
      0  7bec					      SET_PLATFORM
      1  7bec
      2  7bec
      3  7bec
      4  7bec
      5  7bec		       ad 82 02 	      lda	SWCHB
      6  7bef		       2a		      rol
      7  7bf0		       2a		      rol
      8  7bf1		       2a		      rol
      9  7bf2		       29 03		      and	#%11
     10  7bf4		       49 02		      eor	#PAL
     11  7bf6		       85 80		      sta	Platform
   1070  7bf8
   1071  7bf8		       a9 0b		      lda	#BANK_TitleScreen
   1072  7bfa		       85 3f		      sta	SET_BANK
   1073  7bfc		       20 00 f0 	      jsr	TitleSequence
   1074  7bff
   1075  7bff		       4c 11 fc 	      jmp	NextLevelLevel
   1076  7c02
   1077  7c02				   RestartLevelNextPlayer
   1078  7c02
   1079  7c02		       a9 03		      lda	#BANK_SwapPlayersGeneric
   1080  7c04		       85 3f		      sta	SET_BANK
   1081  7c06		       20 38 f4 	      jsr	SwapPlayersGeneric
   1082  7c09
   1083  7c09		       a2 0c		      ldx	#BANK_LevelScreen
   1084  7c0b		       86 3f		      stx	SET_BANK
   1085  7c0d		       a9 01		      lda	#1
   1086  7c0f		       d0 06		      bne	selectLeveler
   1087  7c11
   1088  7c11				   NextLevelLevel
   1089  7c11
   1090  7c11
   1091  7c11		       a2 0c		      ldx	#BANK_LevelScreen
   1092  7c13		       86 3f		      stx	SET_BANK
   1093  7c15
   1094  7c15		       a9 00		      lda	#0
   1095  7c17		       20 25 f0    selectLeveler jsr	LevelSequence
   1096  7c1a
   1097  7c1a							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
   1098  7c1a							; including those for general systems function. But NOT those which do not need re-initialising between
   1099  7c1a							; levels.
   1100  7c1a		       a9 03		      lda	#BANK_LevelInit	; 2
   1101  7c1c		       85 3f		      sta	SET_BANK	; 3
   1102  7c1e		       20 78 f4 	      jsr	LevelInit	; 6+x
   1103  7c21
   1104  7c21
   1105  7c21							; Setup the various digit and display pointers
   1106  7c21							; Grab current player's score/level from backup
   1107  7c21
   1108  7c21		       a9 09		      lda	#BANK_SCORING
   1109  7c23		       85 3e		      sta	SET_BANK_RAM
   1110  7c25		       20 7f f2 	      jsr	GeneralScoringSetups
   1111  7c28							;lda ROM_Bank
   1112  7c28							;sta SET_BANK
   1113  7c28
   1114  7c28							; copy the screen draw ROM shadow to RAM
   1115  7c28
   1116  7c28		       a0 07		      ldy	#SCREEN_LINES-1
   1117  7c2a		       a2 00	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
   1118  7c2c		       20 e4 fc 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
   1119  7c2f		       20 77 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
   1120  7c32		       88		      dey
   1121  7c33		       10 f5		      bpl	CopyScreenBanks
   1122  7c35
   1123  7c35		       a2 01		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
   1124  7c37		       a0 08		      ldy	#BANK_DRAW_BUFFERS
   1125  7c39		       20 43 f0 	      jsr	CopyROMShadowToRAM_F000
   1126  7c3c
   1127  7c3c		       a9 0a		      lda	#BANK_DECODE_LEVEL
   1128  7c3e		       85 3e		      sta	SET_BANK_RAM
   1129  7c40		       20 70 f2 	      jsr	UnpackLevel
   1130  7c43
   1131  7c43							; TODO now we KNOW the width, we can set the top left accordingly and re-unpack
   1132  7c43
   1133  7c43		       a9 28		      lda	#SIZE_BOARD_X
   1134  7c45		       85 94		      sta	BoardLimit_Width
   1135  7c47		       a9 16		      lda	#SIZE_BOARD_Y
   1136  7c49		       85 95		      sta	BoardLimit_Height
   1137  7c4b
   1138  7c4b							; Setup player animation and scroll limits.
   1139  7c4b							; Mangle the board colours based on level
   1140  7c4b
   1141  7c4b		       a9 03		      lda	#BANK_CreateCreatures	; 2
   1142  7c4d		       85 3f		      sta	SET_BANK	; 3
   1143  7c4f		       20 41 f4 	      jsr	CreateCreatures	; 6+x
   1144  7c52
   1145  7c52							;---------------------------------------------------------------------------
   1146  7c52
   1147  7c52					      IF	WAIT_FOR_INITIAL_DRAW
   1148  7c52		       a9 02		      lda	#%10
   1149  7c54		       85 ae		      sta	blankState
   1150  7c56					      ENDIF
   1151  7c56
   1152  7c56		       a9 03		      lda	#BANK_Resync	; 2
   1153  7c58		       85 3f		      sta	SET_BANK	; 3
   1154  7c5a		       20 a6 f4 	      jsr	Resync	; 6+x
   1155  7c5d
   1156  7c5d				   NewFrameStart
   1157  7c5d
   1158  7c5d		       24 c2		      bit	NextLevelTrigger
   1159  7c5f		       70 a1		      bvs	RestartLevelNextPlayer	; loss of life (=SELECT)
   1160  7c61		       10 ae		      bpl	NextLevelLevel	; game-triggered next level (=RESET/COMPLETED)
   1161  7c63
   1162  7c63							; Note: VSYNC must NOT be on when starting a new level! Else you get annoying TV signals.
   1163  7c63
   1164  7c63		       a9 0e		      lda	#%1110	; VSYNC ON
   1165  7c65		       85 42	   .loopVSync sta	WSYNC
   1166  7c67		       85 40		      sta	VSYNC
   1167  7c69		       4a		      lsr
   1168  7c6a		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
   1169  7c6c
   1170  7c6c							; moved *after* the loop since this allows to *increase* timer values by 1!
   1171  7c6c
   1172  7c6c		       a6 80		      ldx	Platform
   1173  7c6e		       bc aa fc 	      ldy	VBlankTime,x
   1174  7c71		       8c 96 02 	      sty	TIM64T
   1175  7c74
   1176  7c74		       a9 0d		      lda	#BANK_SoundFX
   1177  7c76		       85 3f		      sta	SET_BANK
   1178  7c78		       20 9e f3 	      jsr	SoundFX
   1179  7c7b
   1180  7c7b		       20 9c fa 	      jsr	StealCharDraw	; 6 NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
   1181  7c7e
   1182  7c7e							;---------------------------------------------------------------------------
   1183  7c7e
   1184  7c7e		       a9 09		      lda	#BANK_SCORING	; 2
   1185  7c80		       85 3e		      sta	SET_BANK_RAM	; 3
   1186  7c82		       20 e4 f1 	      jsr	DrawDigits	; 6 = 11
   1187  7c85
   1188  7c85							;---------------------------------------------------------------------------
   1189  7c85							; A 42-cycle timing window in the screen draw code.  Perform any general
   1190  7c85							; per-frame code here, provided it takes exactly 42 cycles to execute.
   1191  7c85							; TJ: Well, not exactly 42 cycles, but it works! :)
   1192  7c85
   1193  7c85		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
   1194  7c87		       85 3f		      sta	SET_BANK	; testing
   1195  7c89		       85 3e		      sta	SET_BANK_RAM	; 3
   1196  7c8b		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1197  7c8e							;	 @66
   1198  7c8e		       a9 03		      lda	#BANK_PostScreenCleanup	; 2
   1199  7c90		       85 3f		      sta	SET_BANK	; 3
   1200  7c92		       20 1c f5 	      jsr	PostScreenCleanup	; 6+x
   1201  7c95
   1202  7c95		       a9 00		      lda	#BANK_SelfModDrawPlayers	; 2
   1203  7c97		       85 3f		      sta	SET_BANK	; 3
   1204  7c99		       20 74 f2 	      jsr	SelfModDrawPlayers	; 6+x
   1205  7c9c
   1206  7c9c				   SkipSc
   1207  7c9c		       20 ee fa 	      jsr	writePlayerFrame
   1208  7c9f		       20 9c fa 	      jsr	StealCharDraw	; 6
   1209  7ca2
   1210  7ca2		       ad 84 02    OverscanBD lda	INTIM	;4
   1211  7ca5		       d0 fb		      bne	OverscanBD	;2/3
   1212  7ca7
   1213  7ca7		       4c 5d fc 	      jmp	NewFrameStart
   1214  7caa				   VBlankTime
   1215  7caa		       30 30		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
   1216  7cac		       55 55		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_PAL
   1217  7cae
   1218  7cae							;---------------------------------------------------------------------------
   1219  7cae
      0  7cae					      DEFINE_SUBROUTINE	nextLevelMan
      1  7cae		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7cae					      SUBROUTINE
      3  7cae				   nextLevelMan
   1221  7cae
   1222  7cae		       a9 0d		      lda	#BANK_EndOfLevel
   1223  7cb0		       85 3f		      sta	SET_BANK
   1224  7cb2		       4c 26 f3 	      jmp	EndOfLevel
   1225  7cb5
   1226  7cb5
      0  7cb5					      DEFINE_SUBROUTINE	switchLevels2
      1  7cb5		       00 0f	   BANK_switchLevels2 =	_CURRENT_BANK
      2  7cb5					      SUBROUTINE
      3  7cb5				   switchLevels2
   1228  7cb5
   1229  7cb5							; SELECT used, so we want to get back to selection
   1230  7cb5
   1231  7cb5		       a5 c2		      lda	NextLevelTrigger
   1232  7cb7		       09 40		      ora	#$40	; #<(~BIT_NEXTLEVEL)
   1233  7cb9		       85 c2		      sta	NextLevelTrigger
   1234  7cbb		       60		      rts
   1235  7cbc
      0  7cbc					      DEFINE_SUBROUTINE	nextLevelMan2
      1  7cbc		       00 0f	   BANK_nextLevelMan2 =	_CURRENT_BANK
      2  7cbc					      SUBROUTINE
      3  7cbc				   nextLevelMan2
   1237  7cbc
   1238  7cbc		       c6 a9		      dec	DelayEndOfLevel
   1239  7cbe		       d0 36		      bne	genericRTS
   1240  7cc0
   1241  7cc0		       a9 05		      lda	#5
   1242  7cc2		       85 a9		      sta	DelayEndOfLevel
   1243  7cc4
   1244  7cc4		       a9 0d		      lda	#MANMODE_NEXTLEVEL3
   1245  7cc6		       85 a1		      sta	ManMode
   1246  7cc8		       4c cb fc 	      jmp	nextLevelMan3
   1247  7ccb							;		  rts
   1248  7ccb
   1249  7ccb
      0  7ccb					      DEFINE_SUBROUTINE	nextLevelMan3
      1  7ccb		       00 0f	   BANK_nextLevelMan3 =	_CURRENT_BANK
      2  7ccb					      SUBROUTINE
      3  7ccb				   nextLevelMan3
   1251  7ccb
   1252  7ccb		       c6 a9		      dec	DelayEndOfLevel
   1253  7ccd		       d0 27		      bne	genericRTS
   1254  7ccf
   1255  7ccf		       a9 09		      lda	#MANMODE_SWITCH
   1256  7cd1		       85 a1		      sta	ManMode
   1257  7cd3
      0  7cd3					      DEFINE_SUBROUTINE	switchLevels
      1  7cd3		       00 0f	   BANK_switchLevels =	_CURRENT_BANK
      2  7cd3					      SUBROUTINE
      3  7cd3				   switchLevels
   1259  7cd3
   1260  7cd3							; Now do the actual switching
   1261  7cd3
   1262  7cd3							;		 lda NextLevelTrigger
   1263  7cd3							;		 and #<(~BIT_NEXTLEVEL)
   1264  7cd3		       a9 00		      lda	#$00
   1265  7cd5		       85 c2		      sta	NextLevelTrigger
   1266  7cd7
   1267  7cd7							; Next level is due. Point to the next level, but if we're at the end of playable levels,
   1268  7cd7							; then increment the level number. This is completely circular, so we eventually wrap
   1269  7cd7							; the level back to 0 and start afresh.
   1270  7cd7
   1271  7cd7		       e6 b2		      inc	levelX
   1272  7cd9		       a5 b2		      lda	levelX
   1273  7cdb		       c9 9e		      cmp	#MAX_LEVEL_NUMBER
   1274  7cdd		       90 02		      bcc	.level_ok
   1275  7cdf		       a9 00		      lda	#0
   1276  7ce1		       85 b2	   .level_ok  sta	levelX
   1277  7ce3		       60		      rts
   1278  7ce4
   1279  7ce4							;---------------------------------------------------------------------------
   1280  7ce4
   1281  7ce4
      0  7ce4					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7ce4		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7ce4					      SUBROUTINE
      3  7ce4				   CopyROM2RAM_F000
   1283  7ce4
   1284  7ce4		       a9 0d		      lda	#BANK_CopyROMShadowToRAM
   1285  7ce6		       85 3f		      sta	SET_BANK
   1286  7ce8		       85 bf		      sta	ROM_Bank
   1287  7cea		       4c 43 f0 	      jmp	CopyROMShadowToRAM_F000
   1288  7ced
   1289  7ced
   1290  7ced							;---------------------------------------------------------------------------
   1291  7ced
      0  7ced					      DEFINE_SUBROUTINE	RegisterTarget
      1  7ced		       00 0f	   BANK_RegisterTarget =	_CURRENT_BANK
      2  7ced					      SUBROUTINE
      3  7ced				   RegisterTarget
   1293  7ced
   1294  7ced		       f8		      sed
   1295  7cee		       18		      clc
   1296  7cef		       a5 b5		      lda	BCD_targetsRequired
   1297  7cf1		       69 01		      adc	#1
   1298  7cf3		       85 b5		      sta	BCD_targetsRequired
   1299  7cf5		       d8		      cld
   1300  7cf6		       60	   genericRTS rts
   1301  7cf7
      0  7cf7					      DEFINE_SUBROUTINE	DeRegisterTarget
      1  7cf7		       00 0f	   BANK_DeRegisterTarget =	_CURRENT_BANK
      2  7cf7					      SUBROUTINE
      3  7cf7				   DeRegisterTarget
   1303  7cf7
   1304  7cf7		       f8		      sed
   1305  7cf8		       38		      sec
   1306  7cf9		       a5 b5		      lda	BCD_targetsRequired
   1307  7cfb		       e9 01		      sbc	#1
   1308  7cfd		       85 b5		      sta	BCD_targetsRequired
   1309  7cff		       d8		      cld
   1310  7d00		       60		      rts
   1311  7d01
   1312  7d01							;---------------------------------------------------------------------------
   1313  7d01
------- FILE charset/CHARACTERSHAPE_TARGET.asm LEVEL 3 PASS 3
      0  7d01					      include	"charset/CHARACTERSHAPE_TARGET.asm"
      0  7d01					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET", LINES_PER_CHAR
     10  7d01					      LIST	ON
      2  7d01				   CHARACTERSHAPE_TARGET
      3  7d01		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      4  7d09		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      5  7d11		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      0  7d19					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET_MIRRORED", LINES_PER_CHAR
     10  7d19					      LIST	ON
      7  7d19				   CHARACTERSHAPE_TARGET_MIRRORED
      8  7d19		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      9  7d21		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
     10  7d29		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET1.asm LEVEL 3 PASS 3
      0  7d31					      include	"charset/CHARACTERSHAPE_TARGET1.asm"
      0  7d31					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET1", LINES_PER_CHAR
     10  7d31					      LIST	ON
      2  7d31				   CHARACTERSHAPE_TARGET1
      3  7d31		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      4  7d39		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      5  7d41		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      0  7d49					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET1_MIRRORED", LINES_PER_CHAR
     10  7d49					      LIST	ON
      7  7d49				   CHARACTERSHAPE_TARGET1_MIRRORED
      8  7d49		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      9  7d51		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     10  7d59		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET3.asm LEVEL 3 PASS 3
      0  7d61					      include	"charset/CHARACTERSHAPE_TARGET3.asm"
      0  7d61					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET3", LINES_PER_CHAR
     10  7d61					      LIST	ON
      2  7d61				   CHARACTERSHAPE_TARGET3
      3  7d61		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      4  7d69		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      5  7d71		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      0  7d79					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET3_MIRRORED", LINES_PER_CHAR
     10  7d79					      LIST	ON
      7  7d79				   CHARACTERSHAPE_TARGET3_MIRRORED
      8  7d79		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      9  7d81		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
     10  7d89		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET5.asm LEVEL 3 PASS 3
      0  7d91					      include	"charset/CHARACTERSHAPE_TARGET5.asm"
      0  7d91					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET5", LINES_PER_CHAR
     10  7d91					      LIST	ON
      2  7d91				   CHARACTERSHAPE_TARGET5
      3  7d91		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      4  7d99		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      5  7da1		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      0  7da9					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET5_MIRRORED", LINES_PER_CHAR
     10  7da9					      LIST	ON
      7  7da9				   CHARACTERSHAPE_TARGET5_MIRRORED
      8  7da9		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      9  7db1		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     10  7db9		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET7.asm LEVEL 3 PASS 3
      0  7dc1					      include	"charset/CHARACTERSHAPE_TARGET7.asm"
      0  7dc1					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET7", LINES_PER_CHAR
     10  7dc1					      LIST	ON
      2  7dc1				   CHARACTERSHAPE_TARGET7
      3  7dc1		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      4  7dc9		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      5  7dd1		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      0  7dd9					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET7_MIRRORED", LINES_PER_CHAR
     10  7dd9					      LIST	ON
      7  7dd9				   CHARACTERSHAPE_TARGET7_MIRRORED
      8  7dd9		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      9  7de1		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
     10  7de9		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_STEEL.asm LEVEL 3 PASS 3
      0  7df1					      include	"charset/CHARACTERSHAPE_STEEL.asm"
      0  7df1					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_STEEL
 REQUESTED SIZE =  $18
 WASTED SPACE =  $f
 PAGEBREAK LOCATION =  $fe00
     10  7e00					      LIST	ON
      2  7e00				   CHARACTERSHAPE_STEEL
      3  7e00		       00 00 88 00*	      .byte.b	0,0,136,0,0,0,34,0
      4  7e08		       77 77 ff ff*	      .byte.b	119,119,255,255,221,221,255,255
      5  7e10		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
      0  7e18					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
     10  7e18					      LIST	ON
      7  7e18				   CHARACTERSHAPE_STEEL_MIRRORED
      8  7e18		       00 00 11 00*	      .byte.b	0,0,17,0,0,0,68,0
      9  7e20		       ee ee ff ff*	      .byte.b	238,238,255,255,187,187,255,255
     10  7e28		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
------- FILE BANK_FIXED.asm
------- FILE characterset/character_SOIL.asm LEVEL 3 PASS 3
      0  7e30					      include	"characterset/character_SOIL.asm"
      1  7e30							;    Sokoboo - a Sokoban implementation
      2  7e30							;    using a generic tile-based display engine for the Atari 2600
      3  7e30							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7e30							;
      5  7e30							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7e30							;
      7  7e30							;    Code related to the generic tile-based display engine was developed by
      8  7e30							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7e30							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7e30							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7e30							;
     12  7e30							;    Code related to music and sound effects uses the TIATracker music player
     13  7e30							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7e30							;    directory for Apache licensing details.
     15  7e30							;
     16  7e30							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7e30							;    See the copyright notices in the License directory for a list of level
     18  7e30							;    contributors.
     19  7e30							;
     20  7e30							;    Except where otherwise indicated, this software is released under the
     21  7e30							;    following licensing arrangement...
     22  7e30							;
     23  7e30							;    This program is free software: you can redistribute it and/or modify
     24  7e30							;    it under the terms of the GNU General Public License as published by
     25  7e30							;    the Free Software Foundation, either version 3 of the License, or
     26  7e30							;    (at your option) any later version.
     27  7e30							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7e30
     29  7e30							;    This program is distributed in the hope that it will be useful,
     30  7e30							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7e30							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7e30							;    GNU General Public License for more details.
     33  7e30
      0  7e30					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  7e30					      LIST	ON
     35  7e30				   CHARACTERSHAPE_SOIL
     36  7e30				   CHARACTERSHAPE_SOIL_MIRRORED
     37  7e30		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     38  7e38		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
     39  7e40		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_BOX.asm LEVEL 3 PASS 3
      0  7e48					      include	"charset/CHARACTERSHAPE_BOX.asm"
      0  7e48					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  7e48					      LIST	ON
      2  7e48				   CHARACTERSHAPE_BOX
      3  7e48		       ff ff 99 99*	      .byte.b	255,255,153,153,153,255,255,0
      4  7e50		       ff ff 99 99*	      .byte.b	255,255,153,153,153,0,0,0
      5  7e58		       00 00 00 00*	      .byte.b	0,0,0,0,0,255,255,0
      0  7e60					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
     10  7e60					      LIST	ON
      7  7e60				   CHARACTERSHAPE_BOX_MIRRORED
      8  7e60		       ff ff 99 99*	      .byte.b	255,255,153,153,153,255,255,0
      9  7e68		       ff ff 99 99*	      .byte.b	255,255,153,153,153,0,0,0
     10  7e70		       00 00 00 00*	      .byte.b	0,0,0,0,0,255,255,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_BOX_ON_TARGET.asm LEVEL 3 PASS 3
      0  7e78					      include	"charset/CHARACTERSHAPE_BOX_ON_TARGET.asm"
      0  7e78					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET", LINES_PER_CHAR
     10  7e78					      LIST	ON
      2  7e78				   CHARACTERSHAPE_BOX_ON_TARGET
      3  7e78		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,0
      4  7e80		       ff ff ff ff*	      .byte.b	255,255,255,255,255,0,0,0
      5  7e88		       00 00 66 66*	      .byte.b	0,0,102,102,102,255,255,0
      0  7e90					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED", LINES_PER_CHAR
     10  7e90					      LIST	ON
      7  7e90				   CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
      8  7e90		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,0
      9  7e98		       ff ff ff ff*	      .byte.b	255,255,255,255,255,0,0,0
     10  7ea0		       00 00 66 66*	      .byte.b	0,0,102,102,102,255,255,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_BOX_ON_TARGET2.asm LEVEL 3 PASS 3
      0  7ea8					      include	"charset/CHARACTERSHAPE_BOX_ON_TARGET2.asm"
      0  7ea8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET2", LINES_PER_CHAR
     10  7ea8					      LIST	ON
      2  7ea8				   CHARACTERSHAPE_BOX_ON_TARGET2
      3  7ea8		       ff ff 99 99*	      .byte.b	255,255,153,153,153,255,255,0
      4  7eb0		       ff ff ff ff*	      .byte.b	255,255,255,255,153,0,0,0
      5  7eb8		       00 00 66 66*	      .byte.b	0,0,102,102,0,255,255,0
      0  7ec0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED", LINES_PER_CHAR
     10  7ec0					      LIST	ON
      7  7ec0				   CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED
      8  7ec0		       ff ff 99 99*	      .byte.b	255,255,153,153,153,255,255,0
      9  7ec8		       ff ff ff ff*	      .byte.b	255,255,255,255,153,0,0,0
     10  7ed0		       00 00 66 66*	      .byte.b	0,0,102,102,0,255,255,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_WALL.asm LEVEL 3 PASS 3
      0  7ed8					      include	"charset/CHARACTERSHAPE_WALL.asm"
      0  7ed8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  7ed8					      LIST	ON
      2  7ed8				   CHARACTERSHAPE_WALL
      3  7ed8		       77 77 77 00*	      .byte.b	119,119,119,0,221,221,221,0
      4  7ee0		       77 77 77 00*	      .byte.b	119,119,119,0,221,221,221,0
      5  7ee8		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
      0  7ef0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_WALL_MIRRORED
 REQUESTED SIZE =  $18
 WASTED SPACE =  $10
 PAGEBREAK LOCATION =  $ff00
     10  7f00					      LIST	ON
      7  7f00				   CHARACTERSHAPE_WALL_MIRRORED
      8  7f00		       ee ee ee 00*	      .byte.b	238,238,238,0,187,187,187,0
      9  7f08		       ee ee ee 00*	      .byte.b	238,238,238,0,187,187,187,0
     10  7f10		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
------- FILE BANK_FIXED.asm
   1325  7f18
   1326  7f18				  -	      if	DIGITS
   1327  7f18				  -	      include	"characterset/character_9.asm"
   1328  7f18				  -	      include	"characterset/character_8.asm"
   1329  7f18				  -	      include	"characterset/character_7.asm"
   1330  7f18				  -	      include	"characterset/character_6.asm"
   1331  7f18				  -	      include	"characterset/character_5.asm"
   1332  7f18				  -	      include	"characterset/character_4.asm"
   1333  7f18				  -	      include	"characterset/character_3.asm"
   1334  7f18				  -	      include	"characterset/character_2.asm"
   1335  7f18				  -	      include	"characterset/character_1.asm"
   1336  7f18				  -	      include	"characterset/character_0.asm"
   1337  7f18					      endif
   1338  7f18
   1339  7f18
 FREE BYTES IN FIXED BANK =  $e3
   1340  7f18					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1341  7f18
   1342  7f18							;---------------------------------------------------------------------------
   1343  7f18							; The reset vectors
   1344  7f18							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1345  7f18
   1346  8000 ????				      SEG	InterruptVectors
   1347  7ffc					      ORG	FIXED_BANK + $7FC
   1348  7ffc					      RORG	$7ffC
   1349  7ffc
   1350  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1351  7ffc		       ba fb		      .word.w	Reset	; RESET
   1352  7ffe		       ba fb		      .word.w	Reset	; IRQ	      (not used)
   1353  8000
   1354  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
    799  8000
    800  8000							;END
