------- FILE ./sokoboo.asm LEVEL 1 PASS 3
      1  8000 ????						;    Sokoboo - a Sokoban implementation
      2  8000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  8000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  8000 ????						;
      5  8000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  8000 ????						;
      7  8000 ????						;    Code related to the generic tile-based display engine was developed by
      8  8000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  8000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  8000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  8000 ????						;
     12  8000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  8000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  8000 ????						;    directory for Apache licensing details.
     15  8000 ????						;
     16  8000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  8000 ????						;    See the copyright notices in the License directory for a list of level
     18  8000 ????						;    contributors.
     19  8000 ????						;
     20  8000 ????						;    Except where otherwise indicated, this software is released under the
     21  8000 ????						;    following licensing arrangement...
     22  8000 ????						;
     23  8000 ????						;    This program is free software: you can redistribute it and/or modify
     24  8000 ????						;    it under the terms of the GNU General Public License as published by
     25  8000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  8000 ????						;    (at your option) any later version.
     27  8000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  8000 ????
     29  8000 ????						;    This program is distributed in the hope that it will be useful,
     30  8000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  8000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  8000 ????						;    GNU General Public License for more details.
     33  8000 ????
     34  8000 ????
     35  8000 ????
     36  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     37  8000 ????
     38  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./sokoboo.asm
     41  0000 ????
     42  0000 ????			   ORIGIN     SET	0
     43  0000 ????			   ORIGIN_RAM SET	0
     44  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	segtime_c
     89  0000 ????			   {1}	      SET	({2}+32)/64 + 2
     90  0000 ????			   TEST_{1}   =	0
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_DIRECT, 361 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	(361 + CYCLES_DRAWANOTHER+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_QUICK, 344 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_QUICK SET	(344 + CYCLES_DRAWANOTHER+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_SLOW, 676 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_SLOW SET	(676 + CYCLES_DRAWANOTHER+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_PF0, 88 + CYCLES_DRAWANOTHER	;✅ @ 4/8/2019 ??
      1  0000 ????			   SEGTIME_SCD_PF0 SET	(88 + CYCLES_DRAWANOTHER+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
     98  0000 ????
     99  0000 ????						;---------------------------------------------------------------------------------------------------
    100  0000 ????						; Pathways
    101  0000 ????						; StealPart3, not enough time for SCD_SLOW --> 79✅
    102  0000 ????						; if QuickDraw does immediate exit, 58✅
    103  0000 ????
    104  0000 ????
    105  0000 ????	       00 04	   SEGTIME_SCD_MIN =	SEGTIME_SCD_PF0
    106  0000 ????
    107  0000 ????						;    SEGTIME_C SEGTIME_SCD_MIN, SEGTIME_SCD_PF0
    108  0000 ????						;---------------------------------------------------------------------------------------------------
    109  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_BDF, 2512	;✅
      1  0000 ????			   SEGTIME_BDF SET	(2512+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_BDS, 68	;✅
      1  0000 ????			   SEGTIME_BDS SET	(68+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_DSL, 127	;✅
      1  0000 ????			   SEGTIME_DSL SET	(127+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SWITCHOBJECTS,46	;✅
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	(46+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
    114  0000 ????
      0  0000 ????				      SEGTIME_C	MINIMUM_SEGTIME, 95	;✅ processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	(95+32)/64 + 2
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_MINIMUM_TIMESLICE, 54	;✅ abort time maximum requirement for timeslice
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	(54+32)/64 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    117  0000 ????
    118  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    119  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    120  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    121  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    122  0000 ????						; uses ...
    123  0000 ????
    124  0000 ????
    125  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    126  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    127  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    128  0000 ????
    129  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    130  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    131  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,18	;12	      ;NFI
      1  0000 ????			   SEGTIME_MAN SET	18
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
------- FILE ./sokoboo.asm
     46  0000 ????
     47  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     48  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     49  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     50  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     51  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     52  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     53  0000 ????
     54  0000 ????	       00 01	   YES	      =	1
     55  0000 ????	       00 00	   NO	      =	0
     56  0000 ????
     57  0000 ????						;===================================
     58  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     59  0000 ????						;===================================
     60  0000 ????
     61  0000 ????						;-------------------------------------------------------------------------------
     62  0000 ????						; The following are optional YES/NO depending on phase of the moon
     63  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     64  0000 ????						;-------------------------------------------------------------------------------
     65  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     66  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     67  0000 ????			  -	      IF	FINAL_VERSION = YES
     68  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     69  0000 ????				      ENDIF
     70  0000 ????
     71  0000 ????						;-------------------------------------------------------------------------------
     72  0000 ????
     73  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     74  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
     75  0000 ????
     76  0000 ????
     77  0000 ????	       00 06	   PUSH_LIMIT =	6	; slowdown when pushing on a BOX
     78  0000 ????
     79  0000 ????						; time bonus countdown constants:
     80  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
     81  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
     82  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
     83  0000 ????
     84  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
     85  0000 ????
     86  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
     87  0000 ????
     88  0000 ????						;scoring flags contants:
     89  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
     90  0000 ????	       00 00	   DISPLAY_TIME =	%00
     91  0000 ????	       00 01	   DISPLAY_SCORE =	%01
     92  0000 ????	       00 02	   DISPLAY_LIVES =	%10
     93  0000 ????	       00 03	   DISPLAY_HIGH =	%11
     94  0000 ????
     95  0000 ????						;------------------------------------------------------------------------------
     96  0000 ????
     97  0000 ????	       00 00	   DIGITS     =	NO
     98  0000 ????	       00 01	   WAIT_FOR_INITIAL_DRAW =	YES	; blank until all initial tiles drawn
     99  0000 ????
    100  0000 ????						;------------------------------------------------------------------------------
    101  0000 ????
    102  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    103  0000 ????
    104  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    105  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    106  0000 ????
    107  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    108  0000 ????
    109  0000 ????
    110  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    111  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    112  0000 ????
    113  0000 ????
    114  0000 ????						; color constants:
    115  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    116  0000 ????
    117  0000 ????	       10 00	   RAM_3E     =	$1000
    118  0000 ????	       04 00	   RAM_SIZE   =	$400
    119  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    120  0000 ????
    121  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    122  0000 ????
    123  0000 ????
    124  0000 ????						; Platform constants:
    125  0000 ????	       00 02	   PAL	      =	%10
    126  0000 ????	       00 02	   PAL_50     =	PAL|0
    127  0000 ????	       00 03	   PAL_60     =	PAL|1
    128  0000 ????
    129  0000 ????
    130  0000 ????				      IF	L276
    131  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    132  0000 ????			  -	      ELSE
    133  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    134  0000 ????				      ENDIF
    135  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    136  0000 ????
    137  0000 ????				      IF	L276
    138  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    139  0000 ????			  -	      ELSE
    140  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    141  0000 ????				      ENDIF
    142  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    143  0000 ????
    144  0000 ????				      IF	L276
    145  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    146  0000 ????			  -	      ELSE
    147  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    148  0000 ????				      ENDIF
    149  0000 ????	       01 38	   SCANLINES_PAL =	312
    150  0000 ????
    151  0000 ????
    152  0000 ????						;------------------------------------------------------------------------------
    153  0000 ????						; MACRO definitions
    154  0000 ????
------- FILE macro2.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro2.h"
      1  0000 ????						; macros
      2  0000 ????
      3  0000 ????				      MAC	ntsc_to_pal
      4  0000 ????				      IF	{1} = 0
      5  0000 ????				      .byte	{1}+{2}
      6  0000 ????				      ENDIF
      7  0000 ????				      IF	{1} = $10
      8  0000 ????				      .byte	$20+{2}
      9  0000 ????				      ENDIF
     10  0000 ????				      IF	{1} = $20
     11  0000 ????				      .byte	$40+{2}
     12  0000 ????				      ENDIF
     13  0000 ????				      IF	{1} = $30
     14  0000 ????				      .byte	$40+{2}
     15  0000 ????				      ENDIF
     16  0000 ????				      IF	{1} = $40
     17  0000 ????				      .byte	$60+{2}
     18  0000 ????				      ENDIF
     19  0000 ????				      IF	{1} = $50
     20  0000 ????				      .byte	$80+{2}
     21  0000 ????				      ENDIF
     22  0000 ????				      IF	{1} = $60
     23  0000 ????				      .byte	$C0+{2}
     24  0000 ????				      ENDIF
     25  0000 ????				      IF	{1} = $70
     26  0000 ????				      .byte	$D0+{2}
     27  0000 ????				      ENDIF
     28  0000 ????				      IF	{1} = $80
     29  0000 ????				      .byte	$B0+{2}
     30  0000 ????				      ENDIF
     31  0000 ????				      IF	{1} = $90
     32  0000 ????				      .byte	$90+{2}
     33  0000 ????				      ENDIF
     34  0000 ????				      IF	{1} = $A0
     35  0000 ????				      .byte	$70+{2}
     36  0000 ????				      ENDIF
     37  0000 ????				      IF	{1} = $B0
     38  0000 ????				      .byte	$50+{2}
     39  0000 ????				      ENDIF
     40  0000 ????				      IF	{1} = $C0
     41  0000 ????				      .byte	$30+{2}
     42  0000 ????				      ENDIF
     43  0000 ????				      IF	{1} = $D0
     44  0000 ????				      .byte	$30+{2}
     45  0000 ????				      ENDIF
     46  0000 ????				      IF	{1} = $E0
     47  0000 ????				      .byte	$20+{2}
     48  0000 ????				      ENDIF
     49  0000 ????				      IF	{1} = $F0
     50  0000 ????				      .byte	$40+{2}
     51  0000 ????				      ENDIF
     52  0000 ????				      ENDM		; {col} {intensity}
------- FILE ./sokoboo.asm
    156  0000 ????
    157  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    158  0000 ????
    159  0000 ????				      MAC	newbank
    160  0000 ????				      SEG	{1}
    161  0000 ????				      ORG	ORIGIN
    162  0000 ????				      RORG	$F000
    163  0000 ????			   BANK_START SET	*
    164  0000 ????			   {1}	      SET	ORIGIN / 2048
    165  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    166  0000 ????			   _CURRENT_BANK SET	{1}
    167  0000 ????				      ENDM		; bank name
    168  0000 ????
    169  0000 ????				      MAC	define_1k_segment
    170  0000 ????				      ALIGN	$400
    171  0000 ????			   SEGMENT_{1} SET	*
    172  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    173  0000 ????				      ENDM		; {seg name}
    174  0000 ????
    175  0000 ????				      MAC	check_bank_size
    176  0000 ????			   .TEMP      =	* - BANK_START
    177  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    178  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    179  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    180  0000 ????				      ERR
    181  0000 ????				      endif
    182  0000 ????				      ENDM		; name
    183  0000 ????
    184  0000 ????
    185  0000 ????				      MAC	check_half_bank_size
    186  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    187  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    188  0000 ????			   .TEMP      =	* - BANK_START
    189  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    190  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    191  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    192  0000 ????				      ERR
    193  0000 ????				      endif
    194  0000 ????				      ENDM		; name
    195  0000 ????
    196  0000 ????
    197  0000 ????				      MAC	overlay
    198  0000 ????				      SEG.U	OVERLAY_{1}
    199  0000 ????				      org	Overlay
    200  0000 ????				      ENDM		; {name}
    201  0000 ????
    202  0000 ????						;--------------------------------------------------------------------------
    203  0000 ????
    204  0000 ????				      MAC	validate_overlay
    205  0000 ????				      LIST	OFF
    206  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    207  0000 ????				      ECHO	"Overlay ", {1}, "too big"
    208  0000 ????				      ERR
    209  0000 ????				      endif
    210  0000 ????				      LIST	ON
    211  0000 ????				      ENDM
    212  0000 ????
    213  0000 ????						;--------------------------------------------------------------------------
    214  0000 ????						; Macro inserts a page break if the object would overlap a page
    215  0000 ????
    216  0000 ????				      MAC	optional_pagebreak
    217  0000 ????				      LIST	OFF
    218  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    219  0000 ????			   EARLY_LOCATION SET	*
    220  0000 ????				      ALIGN	256
    221  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    222  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    223  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    224  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    225  0000 ????				      ENDIF
    226  0000 ????				      LIST	ON
    227  0000 ????				      ENDM		; { string, size }
    228  0000 ????
    229  0000 ????
    230  0000 ????				      MAC	check_page_crossing
    231  0000 ????				      LIST	OFF
    232  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    233  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    234  0000 ????				      endif
    235  0000 ????				      LIST	ON
    236  0000 ????				      ENDM
    237  0000 ????
    238  0000 ????				      MAC	checkpage
    239  0000 ????				      LIST	OFF
    240  0000 ????				      IF	>. != >{1}
    241  0000 ????				      ECHO	""
    242  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    243  0000 ????				      ECHO	""
    244  0000 ????				      ERR
    245  0000 ????				      ENDIF
    246  0000 ????				      LIST	ON
    247  0000 ????				      ENDM
    248  0000 ????
    249  0000 ????				      MAC	checkpagex
    250  0000 ????				      LIST	OFF
    251  0000 ????				      IF	>. != >{1}
    252  0000 ????				      ECHO	""
    253  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    254  0000 ????				      ECHO	{2}
    255  0000 ????				      ECHO	""
    256  0000 ????				      ERR
    257  0000 ????				      ENDIF
    258  0000 ????				      LIST	ON
    259  0000 ????				      ENDM
    260  0000 ????
    261  0000 ????
    262  0000 ????				      MAC	checkpage_bne
    263  0000 ????				      LIST	OFF
    264  0000 ????				      IF	0	;>(. + 2) != >{1}
    265  0000 ????				      ECHO	""
    266  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    267  0000 ????				      ECHO	""
    268  0000 ????				      ERR
    269  0000 ????				      ENDIF
    270  0000 ????				      LIST	ON
    271  0000 ????				      bne	{1}
    272  0000 ????				      ENDM
    273  0000 ????
    274  0000 ????				      MAC	checkpage_bpl
    275  0000 ????				      LIST	OFF
    276  0000 ????				      IF	(>(.+2 )) != >{1}
    277  0000 ????				      ECHO	""
    278  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    279  0000 ????				      ECHO	""
    280  0000 ????				      ERR
    281  0000 ????				      ENDIF
    282  0000 ????				      LIST	ON
    283  0000 ????				      bpl	{1}
    284  0000 ????				      ENDM
    285  0000 ????
    286  0000 ????				      MAC	align_free
    287  0000 ????			   FREE       SET	FREE - .
    288  0000 ????				      align	{1}
    289  0000 ????			   FREE       SET	FREE + .
    290  0000 ????				      echo	"@", ., ":", FREE
    291  0000 ????				      ENDM
    292  0000 ????
    293  0000 ????						;--------------------------------------------------------------------------
    294  0000 ????
    295  0000 ????				      MAC	vector
    296  0000 ????				      .word	{1}
    297  0000 ????				      ENDM		; just a word pointer to code
    298  0000 ????
    299  0000 ????
    300  0000 ????				      MAC	define_subroutine
    301  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    302  0000 ????				      SUBROUTINE		; keep everything local
    303  0000 ????			   {1}			; entry point
    304  0000 ????				      ENDM		; name of subroutine
    305  0000 ????
    306  0000 ????
    307  0000 ????
    308  0000 ????						;--------------------------------------------------------------------------
    309  0000 ????
    310  0000 ????				      MAC	newrambank
    311  0000 ????				      SEG.U	{1}
    312  0000 ????				      ORG	ORIGIN_RAM
    313  0000 ????				      RORG	RAM_3E
    314  0000 ????			   BANK_START SET	*
    315  0000 ????			   {1}	      SET	ORIGIN_RAM / RAM_SIZE
    316  0000 ????			   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    317  0000 ????				      ENDM		; bank name
    318  0000 ????
    319  0000 ????				      MAC	validate_ram_size
    320  0000 ????				      if	* - RAM_3E > RAM_SIZE
    321  0000 ????				      ERR
    322  0000 ????				      endif
    323  0000 ????				      ENDM
    324  0000 ????
    325  0000 ????				      MAC	next_random
    326  0000 ????						; update random value:
    327  0000 ????				      lda	rnd	; 3
    328  0000 ????				      lsr		; 2
    329  0000 ????				      IFCONST	rndHi
    330  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    331  0000 ????				      ENDIF
    332  0000 ????				      bcc	.skipEOR	; 2/3
    333  0000 ????				      eor	#RND_EOR_VAL	; 2
    334  0000 ????			   .skipEOR
    335  0000 ????				      sta	rnd	; 3 = 14/19
    336  0000 ????				      ENDM
    337  0000 ????
    338  0000 ????				      MAC	resync
    339  0000 ????						; resync screen, X and Y == 0 afterwards
    340  0000 ????				      lda	#%10	; make sure VBLANK is ON
    341  0000 ????				      sta	VBLANK
    342  0000 ????
    343  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    344  0000 ????			   .loopResync
    345  0000 ????				      VERTICAL_SYNC
    346  0000 ????
    347  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    348  0000 ????				      lda	Platform
    349  0000 ????				      eor	#PAL_50	; PAL-50?
    350  0000 ????				      bne	.ntsc
    351  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    352  0000 ????			   .ntsc
    353  0000 ????			   .loopWait
    354  0000 ????				      sta	WSYNC
    355  0000 ????				      sta	WSYNC
    356  0000 ????				      dey
    357  0000 ????				      bne	.loopWait
    358  0000 ????				      dex
    359  0000 ????				      bne	.loopResync
    360  0000 ????				      ENDM
    361  0000 ????
    362  0000 ????				      MAC	set_platform
    363  0000 ????						; 00 = NTSC
    364  0000 ????						; 01 = NTSC
    365  0000 ????						; 10 = PAL-50
    366  0000 ????						; 11 = PAL-60
    367  0000 ????				      lda	SWCHB
    368  0000 ????				      rol
    369  0000 ????				      rol
    370  0000 ????				      rol
    371  0000 ????				      and	#%11
    372  0000 ????				      eor	#PAL
    373  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    374  0000 ????				      ENDM
    375  0000 ????
    376  0000 ????				      MAC	load_animation
    377  0000 ????				      lda	#<Animation_{1}
    378  0000 ????				      sta	animation
    379  0000 ????				      lda	#>Animation_{1}
    380  0000 ????				      sta	animation+1
    381  0000 ????				      lda	#0
    382  0000 ????				      sta	animation_delay
    383  0000 ????				      lda	#ANIMATION_{1}_ID
    384  0000 ????				      sta	ManAnimationID
    385  0000 ????
    386  0000 ????				      ENDM
    387  0000 ????
    388  0000 ????
    389  0000 ????						;------------------------------------------------------------------------------
    390  0000 ????
    391  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34 U00fc ????				      SEG.U	variables
     35 U0080					      ORG	$80
     36 U0080
     37 U0080
     38 U0080		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     39 U0081
     40 U0081		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     41 U0082		       00	   ObjStackNum ds	1	; which stack in use
     42 U0083		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     43 U0085		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     44 U0086		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     45 U0087
     46 U0087		       00	   POS_X      ds	1
     47 U0088		       00	   POS_Y      ds	1
     48 U0089		       00	   POS_X_NEW  ds	1
     49 U008a		       00	   POS_Y_NEW  ds	1
     50 U008b		       00	   POS_Type   ds	1
     51 U008c		       00	   POS_VAR    ds	1
     52 U008d
     53 U008d		       00	   TB_X       ds	1
     54 U008e		       00	   TB_Y       ds	1
     55 U008f		       00	   TB_PUSHX   ds	1
     56 U0090		       00	   TB_PUSHY   ds	1
     57 U0091		       00	   TB_CHAR    ds	1
     58 U0092
     59 U0092		       00	   BufferedJoystick ds	1	; player joystick input
     60 U0093		       00	   PreviousJoystick ds	1
     61 U0094
     62 U0094							; Scrolling is limited to only show board within the following area...
     63 U0094		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in UnpackLevel)
     64 U0095		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in UnpackLevel)
     65 U0096		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     66 U0097		       00	   BoardScrollX ds	1	; scroll position in board (X)
     67 U0097		       00 94	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     68 U0097		       00 95	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     69 U0098		       00	   scrollBits ds	1
     70 U0099
     71 U0099		       00	   animation_index ds	1	; new
     72 U009a		       00 00	   animation  ds	2
     73 U009c		       00	   animation_delay ds	1
     74 U009d		       00	   ManX       ds	1
     75 U009e		       00	   ManY       ds	1
     76 U009f		       00	   ManDrawX   ds	1
     77 U00a0		       00	   ManDrawY   ds	1
     78 U00a1		       00	   ManMode    ds	1
     79 U00a2		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     80 U00a3		       00	   ManTurnStart ds	1
     81 U00a4		       00	   ManPushCounter ds	1
     82 U00a5		       00	   LookingAround ds	1
     83 U00a6		       00	   ManAnimationID ds	1
     84 U00a7		       00	   ManNextAnimationID ds	1	; -1 for nothing
     85 U00a8		       00	   idleCount  ds	1
     86 U00a9
     87 U00a9		       00	   DelayEndOfLevel ds	1
     88 U00aa		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     89 U00ab
     90 U00ab		       00	   LEVEL_bank ds	1
     91 U00ac		       00 00	   levelPtr   ds	2
     92 U00ae
     93 U00ae					      IF	WAIT_FOR_INITIAL_DRAW
     94 U00ae		       00	   blankState ds	1
     95 U00af					      ENDIF
     96 U00af
     97 U00af							;---------------------------------------------------------------------------
     98 U00af							; 2 (shared) demo mode variables:
     99 U00af							;demoMode			  = jtoggle	  ; bit 7==1 => demo mode
    100 U00af							;moveLen			  = jtoggle	  ; bits 0..6
    101 U00af							;moveIdx			 ds 1
    102 U00af
    103 U00af		       00	   LastSpriteY ds	1
    104 U00b0
    105 U00b0		       00	   timer      ds	1
    106 U00b1
    107 U00b1		       00	   BGColour   ds	1
    108 U00b2
    109 U00b2							; levelx and level have to be consecutive variables!
    110 U00b2		       00	   levelX     ds	1	; current player's level (other in scoring bank)
    111 U00b3		       00	   level      ds	1	; current player's level (other in scoring bank)
    112 U00b4							;levelDisplay			   ds 1 	   ; what to display as the level ID
    113 U00b4		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
    114 U00b5							;ThrottleSpeed 		  ds 1		  ; system-dependant throttle speed
    115 U00b5
    116 U00b5		       00	   BCD_targetsRequired ds	1	; number of un-targeted left to go
    117 U00b6		       00	   BCD_moveCounter ds	1	; BCD seconds for level
    118 U00b7		       00	   BCD_moveCounterHi ds	1
    119 U00b8
    120 U00b8		       00	   takebackIndex ds	1
    121 U00b9		       00	   takebackBaseIndex ds	1
    122 U00ba		       00	   TakebackInhibit ds	1
    123 U00bb
    124 U00bb		       00 00	   Board_AddressR ds	2
    125 U00bd		       00 00	   Board_AddressW ds	2
    126 U00bf		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
    127 U00c0		       00	   RAM_Bank   ds	1
    128 U00c1
    129 U00c1		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
    130 U00c2							;ColourFlash			  ds 1		   ; colour of flash
    131 U00c2							;extraLifeTimer		  ds 1		  ; should be 5 seconds!
    132 U00c2
    133 U00c2							; extraLifeTimer:
    134 U00c2							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    135 U00c2
    136 U00c2							;scoringTimer			  ds 1		  ; times the various score displays
    137 U00c2							;scoringFlags			  ds 1		  ; scoring flags are stored here
    138 U00c2
    139 U00c2							; scoringFlags:
    140 U00c2							; D7		 Extra TARGETs in effect (TARGETs collected over requirement score more) ASSUMED BPL/BMI usage
    141 U00c2							; D6		 unused
    142 U00c2							; D5		 unused
    143 U00c2							; D4		 unused
    144 U00c2							; D3		 unused
    145 U00c2							; D2		 unused
    146 U00c2							; D1	 D1-D0	 Which display kernel to use for scoring
    147 U00c2							; D0		 0 = 2x4     used for TARGETs/time
    148 U00c2							;		 1 = 1x6     used for score
    149 U00c2							;		 2 = 3x2     used for level/lives/player
    150 U00c2
    151 U00c2		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    152 U00c2		       00 80	   BIT_NEXTLEVEL =	128
    153 U00c2		       00 40	   BIT_NEXTLIFE =	64
    154 U00c3
    155 U00c3							;------------------------------------------------------------------------------
    156 U00c3
    157 U00c3		       00	   ObjIterator ds	1	; count UP iterator over objects
    158 U00c4		       00	   DSL	      ds	1	; stack line counter
    159 U00c5
    160 U00c5		       00	   ethnic     ds	1
    161 U00c6		       00	   animate_char_index ds	1
    162 U00c7
    163 U00c7		       00	   rndHi      ds	1
    164 U00c8		       00	   rnd	      ds	1
    165 U00c9		       00 00 00    icc_colour ds	3
    166 U00cc
    167 U00cc
    168 U00cc
------- FILE sound/intro1_variables.asm LEVEL 3 PASS 3
      0 U00cc					      include	"sound/intro1_variables.asm"
      1 U00cc							; TIATracker music player
      2 U00cc							; Copyright 2016 Andre "Kylearan" Wichmann
      3 U00cc							; Website: https://bitbucket.org/kylearan/tiatracker
      4 U00cc							; Email: andre.wichmann@gmx.de
      5 U00cc							;
      6 U00cc							; Licensed under the Apache License, Version 2.0 (the "License");
      7 U00cc							; you may not use this file except in compliance with the License.
      8 U00cc							; You may obtain a copy of the License at
      9 U00cc							;
     10 U00cc							;   http://www.apache.org/licenses/LICENSE-2.0
     11 U00cc							;
     12 U00cc							; Unless required by applicable law or agreed to in writing, software
     13 U00cc							; distributed under the License is distributed on an "AS IS" BASIS,
     14 U00cc							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15 U00cc							; See the License for the specific language governing permissions and
     16 U00cc							; limitations under the License.
     17 U00cc
     18 U00cc							; Song author: 
     19 U00cc							; Song name: 
     20 U00cc
     21 U00cc							; @com.wudsn.ide.asm.hardware=ATARI2600
     22 U00cc
     23 U00cc							; =====================================================================
     24 U00cc							; Flags
     25 U00cc							; =====================================================================
     26 U00cc
     27 U00cc							; 1: Global song speed, 0: Each pattern has individual speed
     28 U00cc		       00 01	   TT_GLOBAL_SPEED =	1
     29 U00cc							; duration (number of TV frames) of a note
     30 U00cc		       00 05	   TT_SPEED   =	5
     31 U00cc							; duration of odd frames (needs TT_USE_FUNKTEMPO)
     32 U00cc		       00 04	   TT_ODD_SPEED =	4
     33 U00cc
     34 U00cc							; 1: Overlay percussion, +40 bytes
     35 U00cc		       00 01	   TT_USE_OVERLAY =	1
     36 U00cc							; 1: Melodic instrument slide, +9 bytes
     37 U00cc		       00 00	   TT_USE_SLIDE =	0
     38 U00cc							; 1: Goto pattern, +8 bytes
     39 U00cc		       00 01	   TT_USE_GOTO =	1
     40 U00cc							; 1: Odd/even rows have different SPEED values, +7 bytes
     41 U00cc		       00 01	   TT_USE_FUNKTEMPO =	1
     42 U00cc							; If the very first notes played on each channel are not PAUSE, HOLD or
     43 U00cc							; SLIDE, i.e. if they start with an instrument or percussion, then set
     44 U00cc							; this flag to 0 to save 2 bytes.
     45 U00cc							; 0: +2 bytes
     46 U00cc		       00 01	   TT_STARTS_WITH_NOTES =	1
     47 U00cc
     48 U00cc
     49 U00cc							; =====================================================================
     50 U00cc							; Permanent variables. These are states needed by the player.
     51 U00cc							; =====================================================================
     52 U00cc		       00	   tt_timer   ds	1	; current music timer value
     53 U00cd		       00	   tt_cur_pat_index_c0 ds	1	; current pattern index into tt_SequenceTable
     54 U00ce		       00	   tt_cur_pat_index_c1 ds	1
     55 U00cf		       00	   tt_cur_note_index_c0 ds	1	; note index into current pattern
     56 U00d0		       00	   tt_cur_note_index_c1 ds	1
     57 U00d1		       00	   tt_envelope_index_c0 ds	1	; index into ADSR envelope
     58 U00d2		       00	   tt_envelope_index_c1 ds	1
     59 U00d3		       00	   tt_cur_ins_c0 ds	1	; current instrument
     60 U00d4		       00	   tt_cur_ins_c1 ds	1
     61 U00d5
     62 U00d5
     63 U00d5							; =====================================================================
     64 U00d5							; Temporary variables. These will be overwritten during a call to the
     65 U00d5							; player routine, but can be used between calls for other things.
     66 U00d5							; =====================================================================
     67 U00d5		       00 00	   tt_ptr     ds	2
------- FILE zeropage.asm
    170 U00d7
    171 U00d7
    172 U00d7
    173 U00d7				   OVERLAY_SIZE SET	25
    174 U00d7
    175 U00d7
    176 U00d7
    177 U00d7							; This overlay variable is used for the overlay variables.  That's OK.
    178 U00d7							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    179 U00d7							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    180 U00d7							; (especially the latter ones) are only used in rare occasions.
    181 U00d7
    182 U00d7							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    183 U00d7							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    184 U00d7
    185 U00d7		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00f0					      VALIDATE_OVERLAY	"DEFINITION"
      6 U00f0					      LIST	ON
    187 U00f0
    188 U00f0
    189 U00f0		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    190 U00fc
 FREE BYTES IN ZERO PAGE =  $3
    191 U00fc					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    192 U00fc				  -	      IF	* > $FF
    193 U00fc				  -	      ERR
    194 U00fc					      ENDIF
------- FILE ./sokoboo.asm
    393 U00fc
    394 U00fc
    395 U00fc							;------------------------------------------------------------------------------
    396 U00fc							; OVERLAYS!
    397 U00fc							; These variables are overlays, and should be managed with care
    398 U00fc							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    399 U00fc
    400 U00fc							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    401 U00fc							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    402 U00fc
    403 U00fc							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    404 U00fc
    405 U00fc
    406 U00fc
    407 U00fc							;------------------------------------------------------------------------------
      0 U00fc					      OVERLAY	BuildDrawFlags
      1 U00e2 ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00d7					      org	Overlay
    409 U00d7
    410 U00d7		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    411 U00d9		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    412 U00db		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    413 U00dd		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    414 U00df							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    415 U00df		       00	   BDF_BoardBank ds	1	; holds bank of current line
    416 U00e0							;  ENDIF
    417 U00e0		       00	   DHS_Line   ds	1
    418 U00e1		       00	   DHS_Stack  ds	1	; for restoring SP
    419 U00e2							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e2					      VALIDATE_OVERLAY	"BuildDrawFlags"
      6 U00e2					      LIST	ON
    421 U00e2
    422 U00e2							;------------------------------------------------------------------------------
    423 U00e2
      0 U00e2					      OVERLAY	Animator
      1 U00dd ????				      SEG.U	OVERLAY_Animator
      2 U00d7					      org	Overlay
    425 U00d7		       00 00	   frame_ptr  ds	2
    426 U00d9		       00 00	   colour_ptr ds	2
    427 U00db		       00	   bank       ds	1
    428 U00dc		       00	   ethnicity  ds	1
      0 U00dd					      VALIDATE_OVERLAY	"Animator"
      6 U00dd					      LIST	ON
    430 U00dd
    431 U00dd
      0 U00dd					      OVERLAY	Process
      1 U00da ????				      SEG.U	OVERLAY_Process
      2 U00d7					      org	Overlay
    433 U00d7
    434 U00d7		       00	   BOXLeft    ds	1
    435 U00d8		       00	   BOXRight   ds	1
    436 U00d9		       00	   restorationCharacter ds	1
    437 U00da
      0 U00da					      VALIDATE_OVERLAY	"Process"
      6 U00da					      LIST	ON
    439 U00da
    440 U00da							;------------------------------------------------------------------------------
    441 U00da
    442 U00da
      0 U00da					      OVERLAY	Animate
      1 U00d8 ????				      SEG.U	OVERLAY_Animate
      2 U00d7					      org	Overlay
    444 U00d7		       00	   halftimer  ds	1
      0 U00d8					      VALIDATE_OVERLAY	"Animate"
      6 U00d8					      LIST	ON
    446 U00d8
    447 U00d8							;------------------------------------------------------------------------------
    448 U00d8
      0 U00d8					      OVERLAY	TitleScreen
      1 U00f0 ????				      SEG.U	OVERLAY_TitleScreen
      2 U00d7					      org	Overlay
    450 U00d7		       00 00	   colour_table ds	2
    451 U00d9		       00 00	   digit1     ds	2
    452 U00db		       00 00	   digit2     ds	2
    453 U00dd		       00 00	   digitstar  ds	2
    454 U00df		       00 00 00    digit      ds	3
    455 U00e2		       00	   digitick   ds	1
    456 U00e3		       00 00 00    targetDigit ds	3
    457 U00e6		       00	   endwait    ds	1
    458 U00e7		       00	   colourindex ds	1
    459 U00e8		       00 00	   digitHundreds ds	2
    460 U00ea		       00	   selector   ds	1
    461 U00eb		       00	   walkSpeed  ds	1
    462 U00ec		       00 00	   manc       ds	2
    463 U00ee		       00	   wallColour ds	1
    464 U00ef		       00	   adjustColour ds	1
      0 U00f0					      VALIDATE_OVERLAY	"TitleScreen"
      6 U00f0					      LIST	ON
    466 U00f0
    467 U00f0							;------------------------------------------------------------------------------
    468 U00f0
      0 U00f0					      OVERLAY	TimeSlice
      1 U00d9 ????				      SEG.U	OVERLAY_TimeSlice
      2 U00d7					      org	Overlay
    470 U00d7
    471 U00d7		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    472 U00d9							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00d9					      VALIDATE_OVERLAY	"TimeSlice"
      6 U00d9					      LIST	ON
    474 U00d9
    475 U00d9							;------------------------------------------------------------------------------
    476 U00d9
      0 U00d9					      OVERLAY	CopyROMShadowToRAM
      1 U00da ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00d7					      org	Overlay
    478 U00d7
    479 U00d7		       00	   O_CopyCount ds	1
    480 U00d8		       00	   O_ROM_Source_Bank ds	1
    481 U00d9		       00	   O_Index    ds	1
    482 U00da							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00da					      VALIDATE_OVERLAY	"CopyROMShadowToRAM"
      6 U00da					      LIST	ON
    484 U00da
    485 U00da							;------------------------------------------------------------------------------
    486 U00da
      0 U00da					      OVERLAY	Scoring
      1 U00d8 ????				      SEG.U	OVERLAY_Scoring
      2 U00d7					      org	Overlay
    488 U00d7		       00	   tmpStack   ds	1
    489 U00d7		       00 d7	   newDisplay =	tmpStack
    490 U00d8							; also for UpdateTimer
    491 U00d8		       00 d7	   tmpSound   =	tmpStack
      0 U00d8					      VALIDATE_OVERLAY	"Scoring"
      6 U00d8					      LIST	ON
    493 U00d8
    494 U00d8
    495 U00d8							;------------------------------------------------------------------------------
    496 U00d8
      0 U00d8					      OVERLAY	SaveKey
      1 U00e0 ????				      SEG.U	OVERLAY_SaveKey
      2 U00d7					      org	Overlay
    498 U00d7
    499 U00d7		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    500 U00da		       00 00 00    highScoreSK ds	3
    501 U00dd		       00	   startingLevel ds	1	; levelx * 5
    502 U00de		       00	   startLevel ds	1
    503 U00df		       00	   offsetSK   ds	1	; for calculating the SK slot address
    504 U00e0
      0 U00e0					      VALIDATE_OVERLAY	"SaveKey"
      6 U00e0					      LIST	ON
    506 U00e0
    507 U00e0							;------------------------------------------------------------------------------
    508 U00e0
      0 U00e0					      OVERLAY	DrawMan
      1 U00d9 ????				      SEG.U	OVERLAY_DrawMan
      2 U00d7					      org	Overlay
    510 U00d7
    511 U00d7		       00 00	   MAN_Move   ds	2
    512 U00d9
    513 U00d9							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00d9					      VALIDATE_OVERLAY	"DrawMan"
      6 U00d9					      LIST	ON
    515 U00d9
    516 U00d9							;------------------------------------------------------------------------------
    517 U00d9
      0 U00d9					      OVERLAY	ProcessObjStack
      1 U00d9 ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00d7					      org	Overlay
    519 U00d7
    520 U00d7		       00 00	   POS_Vector ds	2
    521 U00d9
    522 U00d9							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00d9					      VALIDATE_OVERLAY	"ProcessObjStack"
      6 U00d9					      LIST	ON
    524 U00d9
    525 U00d9							;------------------------------------------------------------------------------
    526 U00d9
      0 U00d9					      OVERLAY	ScoreLineOverlay
      1 U00e6 ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00d7					      org	Overlay
    528 U00d7
    529 U00d7		       00 00	   S0	      ds	2	; used for addressing digits of score
    530 U00d9		       00 00	   S1	      ds	2
    531 U00db		       00 00	   S2	      ds	2
    532 U00dd		       00 00	   S3	      ds	2
    533 U00df		       00 00	   S4	      ds	2
    534 U00e1		       00 00	   S5	      ds	2
    535 U00e3
    536 U00e3		       00	   stkp       ds	1
    537 U00e4		       00	   sreg       ds	1
    538 U00e5		       00	   loop       ds	1
    539 U00e6
    540 U00e6							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e6					      VALIDATE_OVERLAY	"ScoreLineOverlay"
      6 U00e6					      LIST	ON
    542 U00e6
    543 U00e6							;------------------------------------------------------------------------------
    544 U00e6
    545 U00e6
      0 U00e6					      OVERLAY	UnpackLevelOverlay
      1 U00dc ????				      SEG.U	OVERLAY_UnpackLevelOverlay
      2 U00d7					      org	Overlay
    547 U00d7
    548 U00d7		       00	   base_x     ds	1
    549 U00d8		       00	   base_y     ds	1
    550 U00d9		       00	   upk_length ds	1
    551 U00da		       00	   upk_column ds	1
    552 U00db		       00	   upk_temp   ds	1
    553 U00dc							;icc_colour		  ds 3
    554 U00dc
    555 U00dc							;ECHO "FREE BYTES IN UnpackLevelOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dc					      VALIDATE_OVERLAY	"UnpackLevelOverlay"
      6 U00dc					      LIST	ON
    557 U00dc
    558 U00dc							;------------------------------------------------------------------------------
    559 U00dc
      0 U00dc					      OVERLAY	ManProcessing
      1 U00d9 ????				      SEG.U	OVERLAY_ManProcessing
      2 U00d7					      org	Overlay
    561 U00d7		       00 00	   actionVector ds	2
      0 U00d9					      VALIDATE_OVERLAY	"ManProcessing"
      6 U00d9					      LIST	ON
    563 U00d9
      0 U00d9					      OVERLAY	DrawIntoStack
      1 U00d8 ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00d7					      org	Overlay
    565 U00d7		       00	   save_SP    ds	1
      0 U00d8					      VALIDATE_OVERLAY	"DrawIntoStack"
      6 U00d8					      LIST	ON
    567 U00d8
    568 U00d8							;------------------------------------------------------------------------------
    569 U00d8							;##############################################################################
    570 U00d8							;------------------------------------------------------------------------------
    571 U00d8
    572 U00d8							; NOW THE VERY INTERESTING '3E' RAM BANKS
    573 U00d8							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    574 U00d8
      0 U00d8					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN_RAM
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN_RAM / RAM_SIZE
      6 U0000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    576 U0000
    577 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    578 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    579 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    580 U0000
    581 U0000		       00 60	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    582 U0000
    583 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    584 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    585 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    586 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    587 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    588 U0000
    589 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    590 U0000							; is that we can use that code to switch between banks, and the system will happily
    591 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    592 U0000
    593 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    594 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    595 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    596 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    597 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    598 U0000
    599 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    600 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    601 U0000							; part of the draw routine *every* scanline (though the system currently uses
    602 U0000							; one colour shared between both players).
    603 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    605 U0000
    606 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    607 U0000							; accessed via the above labels but with the appropriate bank switched in.
    608 U0000
    609 U0000							;------------------------------------------------------------------------------
    610 U0000
    611 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN_RAM
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U0400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    611 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN_RAM
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U0800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    611 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN_RAM
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U0c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    611 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN_RAM
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U1000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    611 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN_RAM
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U1400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    611 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN_RAM
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U1800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    611 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN_RAM
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN_RAM / RAM_SIZE
      6 U1c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    614 U1c00					      REPEND
    615 U1c00
    616 U1c00							;------------------------------------------------------------------------------
    617 U1c00							;##############################################################################
    618 U1c00							;------------------------------------------------------------------------------
    619 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN_RAM
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN_RAM / RAM_SIZE
      6 U2000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    621 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    622 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    624 U2000
    625 U2000							;------------------------------------------------------------------------------
    626 U2000							;##############################################################################
    627 U2000							;------------------------------------------------------------------------------
    628 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN_RAM
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN_RAM / RAM_SIZE
      6 U2400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    630 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    631 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    633 U2400
    634 U2400							;------------------------------------------------------------------------------
    635 U2400							;##############################################################################
    636 U2400							;------------------------------------------------------------------------------
    637 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_LEVEL
      1 U2800 ????				      SEG.U	BANK_DECODE_LEVEL
      2 U2800					      ORG	ORIGIN_RAM
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_LEVEL SET	ORIGIN_RAM / RAM_SIZE
      6 U2800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    639 U2800							; VARS DEFINED IN BANK_DECODE_LEVEL_SHADOW
    640 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    642 U2800
    643 U2800							;------------------------------------------------------------------------------
    644 U2800							;##############################################################################
    645 U2800							;------------------------------------------------------------------------------
    646 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN_RAM
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN_RAM / RAM_SIZE
      6 U2c00				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    648 U2c00
    649 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    650 U2c00							; position of something that needs to be processed.  These things include anything
    651 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    652 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    653 U2c00							; one for the next processing iteration.
    654 U2c00
    655 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    656 U2c00
    657 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    658 U2c00
    659 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    660 U2c00
    661 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    662 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    663 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    664 U2d80
    665 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    666 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    667 U2e00
    668 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    669 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    670 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    671 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    673 U2e80
    674 U2e80							;------------------------------------------------------------------------------
    675 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN_RAM
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN_RAM / RAM_SIZE
      6 U3000				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    677 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    679 U3000
    680 U3000							;------------------------------------------------------------------------------
    681 U3000							;##############################################################################
    682 U3000							;------------------------------------------------------------------------------
    683 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U37a0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN_RAM
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN_RAM / RAM_SIZE
      6 U3400				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    685 U3400
    686 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    687 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    688 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    689 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    690 U3400							; when accessing.
    691 U3400
    692 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    693 U3400							; automatically based on the sizes set in these constants. The board may overlay
    694 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    695 U3400							; we're doing OK.
    696 U3400
    697 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    698 U3400
    699 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    700 U3400
    701 U3400		       00 28	   SIZE_BOARD_X =	40	;
    702 U3400		       00 16	   SIZE_BOARD_Y =	22
    703 U3400
    704 U3400
    705 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    706 U3400				  -MULTI_BANK_BOARD =	YES
    707 U3400					      ELSE
    708 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    709 U3400					      ENDIF
    710 U3400
    711 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    712 U37a0							; 1024 byte chunks, switching RAM
    713 U37a0							; banks as we go.  In other words,
    714 U37a0							; this overlaps multiple banks!
    715 U37a0
      0 U37a0					      NEWRAMBANK	BANK_TAKEBACK
      1 U3940 ????				      SEG.U	BANK_TAKEBACK
      2 U3800					      ORG	ORIGIN_RAM
      3 U3800					      RORG	RAM_3E
      4 U3800				   BANK_START SET	*
      5 U3800				   BANK_TAKEBACK SET	ORIGIN_RAM / RAM_SIZE
      6 U3800				   ORIGIN_RAM SET	ORIGIN_RAM + RAM_SIZE
    717 U3800
    718 U3800		       00 3f	   TAKEBACK_MASK =	$3F
    719 U3800
    720 U3800		       00 00 00 00*TakeBackPreviousX ds	$40
    721 U3840		       00 00 00 00*TakeBackPreviousY ds	$40
    722 U3880		       00 00 00 00*TakeBackPushX ds	$40
    723 U38c0		       00 00 00 00*TakeBackPushY ds	$40
    724 U3900		       00 00 00 00*TakeBackPushChar ds	$40
    725 U3940
    726 U3940							; reverting...
    727 U3940							; A prevoius position
    728 U3940							;	     POS_VAR = board
    729 U3940							;	     board = MANOCCUPIED
    730 U3940							;	     manx,y = x,y
    731 U3940							; B current position (MANX,Y)
    732 U3940							;	     board = POS_VAR
    733 U3940							; C push position
    734 U3940							;	     BOARD = PREV_BOARD
    735 U3940							; TAKEBACK_PREV_X, TAKEBACK_PREV_Y, TAKEBACK_PUSH_X,PUSH_Y,TAKEBACK_PUSH_PREV
    736 U3940							;
    737 U3940
    738 U3940
    739 U3940							; free space here (but hard to use)
    740 U3940							; So we need to calculate where the next free bank is!
    741 U3940							; TODO: This looks dodgy.  Check..
    742 U3940
    743 U3940							;ORIGIN	  SET ( * + RAM_SIZE - 1 ) / RAM_SIZE
    744 U3940							;ORIGIN	  SET ORIGIN * RAM_SIZE
    745 U3940
    746 U3940
    747 U3940
    748 U3940							;------------------------------------------------------------------------------
    749 U3940							;##############################################################################
    750 U3940							;------------------------------------------------------------------------------
    751 U3940
    752 U3940							;------------------------------------------------------------------------------
    753 U3940
    754 U3940							;    IFNCONST MAX_LEVEL_SIZE
    755 U3940				   MAX_LEVEL_SIZE SET	0
    756 U3940							;    ENDIF
    757 U3940
    758 U3940
    759 U3940				   MAX_LEVEL_NUMBER SET	0
    760 U3940					      MAC	start_level
    761 U3940				   LEVEL_START SET	*
    762 U3940				   BANK_LEVEL_{1} =	_CURRENT_BANK
    763 U3940				   LEVEL_{1}  SUBROUTINE
    764 U3940				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
    765 U3940							; ECHO "current MAX_LEVEL_NUMBER = ", MAX_LEVEL_NUMBER
    766 U3940					      ENDM		; {name}
    767 U3940
    768 U3940
    769 U3940					      MAC	end_level
    770 U3940				   LEVEL_SIZE_{1} =	* - LEVEL_START
    771 U3940					      IF	LEVEL_SIZE_{1} > MAX_LEVEL_SIZE
    772 U3940				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_{1}
    773 U3940					      ENDIF
    774 U3940					      ENDM		; {name}
    775 U3940
    776 U3940
    777 U3940					      MAC	defl
    778 U3940					      START_LEVEL	{1}
    779 U3940					      .byte	{2},0
    780 U3940					      END_LEVEL	{1}
    781 U3940					      ENDM
    782 U3940
    783 U3940							;--------------------------------------------------------------------------------
    784 U3940
    785 U3940							;ORIGIN      SET 0
    786 U3940
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 3
      0 U3940					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1 U3940							;    Sokoboo - a Sokoban implementation
      2 U3940							;    using a generic tile-based display engine for the Atari 2600
      3 U3940							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4 U3940							;
      5 U3940							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6 U3940							;
      7 U3940							;    Code related to the generic tile-based display engine was developed by
      8 U3940							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9 U3940							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10 U3940							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11 U3940							;
     12 U3940							;    Code related to music and sound effects uses the TIATracker music player
     13 U3940							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14 U3940							;    directory for Apache licensing details.
     15 U3940							;
     16 U3940							;    Some level data incorporated in this program were created by Lee J Haywood.
     17 U3940							;    See the copyright notices in the License directory for a list of level
     18 U3940							;    contributors.
     19 U3940							;
     20 U3940							;    Except where otherwise indicated, this software is released under the
     21 U3940							;    following licensing arrangement...
     22 U3940							;
     23 U3940							;    This program is free software: you can redistribute it and/or modify
     24 U3940							;    it under the terms of the GNU General Public License as published by
     25 U3940							;    the Free Software Foundation, either version 3 of the License, or
     26 U3940							;    (at your option) any later version.
     27 U3940							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28 U3940
     29 U3940							;    This program is distributed in the hope that it will be useful,
     30 U3940							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31 U3940							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32 U3940							;    GNU General Public License for more details.
     33 U3940
     34 U3940							;------------------------------------------------------------------------------
     35 U3940							;##############################################################################
     36 U3940							;------------------------------------------------------------------------------
      0 U3940					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  03eb ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
     38  0000
     39  0000							; This is essentially a ROM mirror of a RAM bank.
     40  0000							; The contents of this bank are copied to each of the ROW banks on startup, and
     41  0000							; this gives a 1:1 correspondence between the data/addresses defined here, and
     42  0000							; the addresses in the switched-in RAM bank.
     43  0000
     44  0000							; Note: Bankswitching code between any of these banks guarantees the code can
     45  0000							; continue to run -- because, of course, the same code is still at the same
     46  0000							; memory address.
     47  0000
      0  0000					      DEFINE_SUBROUTINE	DrawTheScreen
      1  0000		       00 00	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  0000					      SUBROUTINE
      3  0000				   DrawTheScreen
     49  0000
     50  0000							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     51  0000							; A refactor of the kernel to improve the timing.
     52  0000							; Experimental refactor to remove the blank line...
     53  0000
     54  0000							; adjust here so that the first line of the kernel starts exactly at cycle 67
     55  0000							; (since TJ said it could start up to 5 cycles earlier than #67).
     56  0000
     57  0000							; TODO: remove GRP1 and COLUP1 access (or use higher resolution player)
     58  0000							;	     @57
      0  0000					      SLEEP	6	; 3
      1  0000				   .CYCLES    SET	6
      2  0000
      3  0000				  -	      IF	.CYCLES < 2
      4  0000				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0000				  -	      ERR
      6  0000					      ENDIF
      7  0000
      8  0000				  -	      IF	.CYCLES & 1
      9  0000				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0000				  -	      nop	0
     11  0000				  -	      ELSE
     12  0000				  -	      bit	VSYNC
     13  0000				  -	      ENDIF
     14  0000				  -.CYCLES    SET	.CYCLES - 3
     15  0000					      ENDIF
     16  0000
     17  0000					      REPEAT	.CYCLES / 2
     18  0000		       ea		      nop
     17  0000					      REPEND
     18  0001		       ea		      nop
     17  0001					      REPEND
     18  0002		       ea		      nop
     19  0003					      REPEND
     60  0003
     61  0003		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     62  0005		       10 3d		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     63  0007
     64  0007				   Proc2		; 5
      0  0007					      SLEEP	3	; 3	     @64
      1  0007				   .CYCLES    SET	3
      2  0007
      3  0007				  -	      IF	.CYCLES < 2
      4  0007				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0007				  -	      ERR
      6  0007					      ENDIF
      7  0007
      8  0007					      IF	.CYCLES & 1
      9  0007					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0007		       04 00		      nop	0
     11  0009				  -	      ELSE
     12  0009				  -	      bit	VSYNC
     13  0009					      ENDIF
     14  0009				   .CYCLES    SET	.CYCLES - 3
     15  0009					      ENDIF
     16  0009
     17  0009				  -	      REPEAT	.CYCLES / 2
     18  0009				  -	      nop
     19  0009					      REPEND
     66  0009		       10 3b		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     67  000b
      0  000b					      DEFINE_SUBROUTINE	ScanRED	;	     @60
      1  000b		       00 00	   BANK_ScanRED =	_CURRENT_BANK
      2  000b					      SUBROUTINE
      3  000b				   ScanRED
     69  000b		       b9 21 f3    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     70  000e		       85 4d		      sta	PF0	; 3	     @67
     71  0010		       b9 14 f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     72  0013		       85 4e		      sta	PF1	; 3 = 14    @74
     73  0015							;SELFMOD_PLAYERCOL_RED
     74  0015		       b9 51 f3 	      lda	PLAYER0_COLOUR,y	; 4
     75  0018							;lda #$66
     76  0018							;nop
     77  0018		       85 46		      sta	COLUP0	; 3	     @05
      0  001a					      SLEEP	3
      1  001a				   .CYCLES    SET	3
      2  001a
      3  001a				  -	      IF	.CYCLES < 2
      4  001a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  001a				  -	      ERR
      6  001a					      ENDIF
      7  001a
      8  001a					      IF	.CYCLES & 1
      9  001a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  001a		       04 00		      nop	0
     11  001c				  -	      ELSE
     12  001c				  -	      bit	VSYNC
     13  001c					      ENDIF
     14  001c				   .CYCLES    SET	.CYCLES - 3
     15  001c					      ENDIF
     16  001c
     17  001c				  -	      REPEAT	.CYCLES / 2
     18  001c				  -	      nop
     19  001c					      REPEND
     79  001c							;sta COLUP1				      ; 3 = 10	  @08
     80  001c
     81  001c							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     82  001c
     83  001c				   SELFMOD_RED
     84  001c		       a9 00		      lda	#0	; 2
     85  001e		       85 48		      sta	COLUPF	; 3 =	5    @13
     86  0020
     87  0020				   SELFMOD_PLAYER0_RED
     88  0020		       b9 39 f3 	      lda	ShapePlayerRED,y	; 4
     89  0023		       85 5b		      sta	GRP0	; 3 =	7    @20
     90  0025
     91  0025		       b9 2c f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
     92  0028		       85 4f		      sta	PF2	; 3 =	7    @27
     93  002a
     94  002a		       b9 21 f3    SM_PF0_REDr lda	#CHARACTERSHAPE_BLANK,y	; 4
     95  002d		       85 4d		      sta	PF0	; 3	     @34
     96  002f		       b9 44 f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
     97  0032		       85 4e		      sta	PF1	; 3	     @41
     98  0034		       b9 5c f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
     99  0037		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
    100  0039
    101  0039				   SELFMOD_PLAYER1_RED
    102  0039		       b9 39 f3 	      lda	ShapePlayerRED,y	; 4
    103  003c							;sta.w GRP1				      ; 4 =  8	  @56	VDELed!
      0  003c					      SLEEP	4
      1  003c				   .CYCLES    SET	4
      2  003c
      3  003c				  -	      IF	.CYCLES < 2
      4  003c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  003c				  -	      ERR
      6  003c					      ENDIF
      7  003c
      8  003c				  -	      IF	.CYCLES & 1
      9  003c				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  003c				  -	      nop	0
     11  003c				  -	      ELSE
     12  003c				  -	      bit	VSYNC
     13  003c				  -	      ENDIF
     14  003c				  -.CYCLES    SET	.CYCLES - 3
     15  003c					      ENDIF
     16  003c
     17  003c					      REPEAT	.CYCLES / 2
     18  003c		       ea		      nop
     17  003c					      REPEND
     18  003d		       ea		      nop
     19  003e					      REPEND
    105  003e
    106  003e		       88		      dey		; 2
    107  003f		       10 c6		      bpl	Proc2	; 2(3)      --> 61 if taken
    108  0041
    109  0041		       e8	   SELFMOD_X  inx		; 2
    110  0042		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
    111  0044							;EXIT_RETURN_HERE
    112  0044				   NextALineStart
    113  0044		       a0 07		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
    114  0046				   ScanBLUEBD		;	     @67     let's start as late as possible
    115  0046
    116  0046							;------------------------------------------------------------------------------
    117  0046
    118  0046		       b9 21 f3    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
    119  0049		       85 4d		      sta	PF0	; 3 =	7    @74
    120  004b							;SELFMOD_PLAYERCOL_BLUE
    121  004b		       b9 61 f3 	      lda	PLAYER0_COLOUR+2*LINES_PER_CHAR/3,y	; 4
    122  004e							;lda #$66
    123  004e							;nop
    124  004e							;sta COLUP1				      ; 3	  @05
      0  004e					      SLEEP	3
      1  004e				   .CYCLES    SET	3
      2  004e
      3  004e				  -	      IF	.CYCLES < 2
      4  004e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  004e				  -	      ERR
      6  004e					      ENDIF
      7  004e
      8  004e					      IF	.CYCLES & 1
      9  004e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  004e		       04 00		      nop	0
     11  0050				  -	      ELSE
     12  0050				  -	      bit	VSYNC
     13  0050					      ENDIF
     14  0050				   .CYCLES    SET	.CYCLES - 3
     15  0050					      ENDIF
     16  0050
     17  0050				  -	      REPEAT	.CYCLES / 2
     18  0050				  -	      nop
     19  0050					      REPEND
    126  0050		       85 46		      sta	COLUP0	; 3 = 10    @08
    127  0052
    128  0052				   SELFMOD_BLUE
    129  0052		       a9 00		      lda	#0	; 2
    130  0054		       85 48		      sta	COLUPF	; 3 =	5    @13
    131  0056
    132  0056				   SELFMOD_PLAYER0_BLUE
    133  0056		       b9 39 f3 	      lda	ShapePlayerBLUE,y	; 4
    134  0059		       85 5b		      sta	GRP0	; 3 =	7    @20
    135  005b
    136  005b		       b9 24 f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    137  005e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    138  0060		       b9 3c f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    139  0063		       85 4f		      sta	PF2	; 3 = 14    @34
    140  0065
    141  0065		       b9 21 f3    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    142  0068		       85 4d		      sta	PF0	; 3	     @41
    143  006a		       b9 54 f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    144  006d		       85 4e		      sta	PF1	; 3	     @48
    145  006f		       b9 6c f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    146  0072		       85 4f		      sta	PF2	; 3 = 21    @55
    147  0074
    148  0074				   SELFMOD_PLAYER1_BLUE
    149  0074		       b9 39 f3 	      lda	ShapePlayerBLUE,y	; 4
    150  0077							;sta GRP1				      ; 3 =  7	  VDELed! @62
      0  0077					      SLEEP	3
      1  0077				   .CYCLES    SET	3
      2  0077
      3  0077				  -	      IF	.CYCLES < 2
      4  0077				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0077				  -	      ERR
      6  0077					      ENDIF
      7  0077
      8  0077					      IF	.CYCLES & 1
      9  0077					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0077		       04 00		      nop	0
     11  0079				  -	      ELSE
     12  0079				  -	      bit	VSYNC
     13  0079					      ENDIF
     14  0079				   .CYCLES    SET	.CYCLES - 3
     15  0079					      ENDIF
     16  0079
     17  0079				  -	      REPEAT	.CYCLES / 2
     18  0079				  -	      nop
     19  0079					      REPEND
    152  0079
    153  0079							;------------------------------------------------------------------------------
    154  0079
    155  0079				   ScanGREEN		;	     @62
    156  0079		       b9 21 f3    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    157  007c		       85 4d		      sta	PF0	; 3 =	7    @69
    158  007e							;SELFMOD_PLAYERCOL_GREEN
    159  007e		       b9 59 f3 	      lda	PLAYER0_COLOUR+LINES_PER_CHAR/3,y	; 4
    160  0081							;lda #$66
    161  0081							;nop
    162  0081							;sta COLUP1				      ; 3	  @00
      0  0081					      SLEEP	3
      1  0081				   .CYCLES    SET	3
      2  0081
      3  0081				  -	      IF	.CYCLES < 2
      4  0081				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0081				  -	      ERR
      6  0081					      ENDIF
      7  0081
      8  0081					      IF	.CYCLES & 1
      9  0081					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0081		       04 00		      nop	0
     11  0083				  -	      ELSE
     12  0083				  -	      bit	VSYNC
     13  0083					      ENDIF
     14  0083				   .CYCLES    SET	.CYCLES - 3
     15  0083					      ENDIF
     16  0083
     17  0083				  -	      REPEAT	.CYCLES / 2
     18  0083				  -	      nop
     19  0083					      REPEND
    164  0083		       85 46		      sta	COLUP0	; 3 = 10    @03
    165  0085
    166  0085				   SELFMOD_GREEN
    167  0085		       a9 00		      lda	#0	; 2
    168  0087		       85 48		      sta	COLUPF	; 3 =	5    @08
    169  0089
    170  0089				   SELFMOD_PLAYER0_GREEN
    171  0089		       b9 39 f3 	      lda	ShapePlayerGREEN,y	; 4
    172  008c		       85 5b		      sta	GRP0	; 3 =	7    @15
    173  008e
    174  008e		       b9 1c f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    175  0091		       85 4e		      sta	PF1	; 3	     @22
    176  0093		       b9 34 f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    177  0096		       85 4f		      sta	PF2	; 3 = 14    @29
    178  0098
    179  0098		       b9 21 f3    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    180  009b		       85 4d		      sta	PF0	; 3	     @36
    181  009d		       b9 4c f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    182  00a0		       85 4e		      sta	PF1	; 3	     @43
    183  00a2		       b9 64 f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    184  00a5		       85 4f		      sta	PF2	; 3 = 21    @50
    185  00a7
    186  00a7				   SELFMOD_PLAYER1_GREEN
    187  00a7		       b9 39 f3 	      lda	ShapePlayerGREEN,y	; 4
    188  00aa							;sta GRP1				      ; 3 =  7	  @57	  VDELed!
      0  00aa					      SLEEP	3
      1  00aa				   .CYCLES    SET	3
      2  00aa
      3  00aa				  -	      IF	.CYCLES < 2
      4  00aa				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  00aa				  -	      ERR
      6  00aa					      ENDIF
      7  00aa
      8  00aa					      IF	.CYCLES & 1
      9  00aa					      IFNCONST	NO_ILLEGAL_OPCODES
     10  00aa		       04 00		      nop	0
     11  00ac				  -	      ELSE
     12  00ac				  -	      bit	VSYNC
     13  00ac					      ENDIF
     14  00ac				   .CYCLES    SET	.CYCLES - 3
     15  00ac					      ENDIF
     16  00ac
     17  00ac				  -	      REPEAT	.CYCLES / 2
     18  00ac				  -	      nop
     19  00ac					      REPEND
    190  00ac
    191  00ac		       4c 0b f0 	      jmp	ScanRED	; 3	     @60
    192  00af
    193  00af							;------------------------------------------------------------------------------
    194  00af
    195  00af							;------------------------------------------------------------------------------
    196  00af
    197  00af							;*** Ideas: ***
    198  00af							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    199  00af							;   13.5% on average), also unrolling would be more effective than now
    200  00af							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    201  00af							;   see EXPERIMENTAL)
    202  00af							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    203  00af							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    204  00af							;   bidirectional linked list instead)
    205  00af							; - calculate mirrored gfx data into RAM (saves ROM)
    206  00af
    207  00af							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    208  00af							;currently:
    209  00af							; 72%*539 (!unrolled)
    210  00af							;+ 8%*304 (unrolled)
    211  00af							;+20%*269 (unrolled)
    212  00af							;--------
    213  00af							;=   ~466.2 cycles on average
    214  00af
    215  00af							;alternative #1:
    216  00af							; 72%*522 (unrolled)
    217  00af							;+ 8%*352 (!unrolled)
    218  00af							;+20%*307 (!unrolled)
    219  00af							;--------
    220  00af							;=   ~465.4 cycles on average
    221  00af
    222  00af
    223  00af		       00 01	   MIRROR     =	1
    224  00af		       00 80	   DIRECT     =	$80
    225  00af
    226  00af							;------------------------------------------------------------------------------
    227  00af							; Here we don't draw into a buffer, but directly patch the kernel
    228  00af							; VERY fast!
    229  00af							;
    230  00af							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    231  00af							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    232  00af
    233  00af				   PF0Draw		; 25✅ cycles until here
    234  00af
    235  00af		       ae 84 02 	      ldx	INTIM	; 4
    236  00b2		       e0 04		      cpx	#SEGTIME_SCD_PF0	; 2
    237  00b4		       90 72		      bcc	ExitDraw	; 2(3)=8✅
    238  00b6
    239  00b6		       29 7f		      and	#<(~DIRECT)	; 2
    240  00b8		       aa		      tax		; 2 =	4✅
    241  00b9
    242  00b9		       98		      tya		; 2
    243  00ba		       0a		      asl		; 2	     no mirrored chars in PF0
    244  00bb		       a8		      tay		; 2 =	6✅
    245  00bc							;		  clc				  ; 2
    246  00bc
    247  00bc		       b9 03 f3 	      lda	CharacterDataVecHI,y	; 4
    248  00bf		       9d 0d f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    249  00c2		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    250  00c5		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19✅
    251  00c8
    252  00c8		       b9 e5 f2 	      lda	CharacterDataVecLO,y	; 4
    253  00cb		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    254  00ce		       69 07		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    255  00d0		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    256  00d3		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    257  00d5		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23✅
    258  00d8
    259  00d8		       4c c7 fa 	      jmp	DrawAnother	; 3 =	[25]+8+4+6+19+24+3 = 88✅ entering DrawAnother
    260  00db
    261  00db							; Timing for PF0Draw
    262  00db							; 88
    263  00db							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    264  00db
    265  00db
    266  00db							;------------------------------------------------------------------------------
    267  00db							; Direct draw draws to PF0, which only has one active member of the character
    268  00db							; pair -- so it can be a direct copy.	Quicker still!
    269  00db
    270  00db				   DirectDraw		; 37✅ cycles until here
    271  00db
    272  00db		       ad 84 02 	      lda	INTIM	; 4
    273  00de		       c9 08		      cmp	#SEGTIME_SCD_DIRECT	; 2
    274  00e0		       90 46		      bcc	ExitDraw	; 2(3)=8
    275  00e2							; => [37]+(9)+6rts = 51 cycles if draw exits
    276  00e2
    277  00e2							; @ [37]+8 =45✅
    278  00e2
    279  00e2		       b9 03 f3 	      lda	CharacterDataVecHI,y	; 4
    280  00e5		       8d 12 f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    281  00e8		       8d 18 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    282  00eb		       8d 1e f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    283  00ee
    284  00ee		       b9 e5 f2 	      lda	CharacterDataVecLO,y	; 4
    285  00f1		       8d 11 f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    286  00f4		       69 07		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    287  00f6		       8d 17 f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    288  00f9		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    289  00fb		       8d 1d f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    290  00fe
    291  00fe		       bd b2 f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    292  0101		       8d 14 f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    293  0104		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    294  0106		       8d 1a f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    295  0109		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    296  010b		       8d 20 f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    297  010e
    298  010e		       a0 07		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    299  0110
    300  0110							; @45+16+20+20+2 = @103
    301  0110				   TSFill3		; 8*{...
    302  0110		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    303  0113		       99 14 f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    304  0116		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    305  0119		       99 14 f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    306  011c		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    307  011f		       99 14 f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    308  0122
    309  0122		       88		      dey		; 2
      0  0123					      CHECKPAGE_BPL	TSFill3	; 3(2)=5 ...32✅} = 8*32-1 = 255
      8  0123					      LIST	ON
      9  0123		       10 eb		      bpl	TSFill3
    311  0125
    312  0125		       4c c7 fa 	      jmp	DrawAnother	; 3
    313  0128							; => @103+255+3 = 361✅ entering DrawAnother
    314  0128
    315  0128		       60	   ExitDraw   rts		; 6
    316  0129
    317  0129							;------------------------------------------------------------------------------
    318  0129
      0  0129					      DEFINE_SUBROUTINE	StealPart3	; [18]✅ CYCLES TO HERE
      1  0129		       00 00	   BANK_StealPart3 =	_CURRENT_BANK
      2  0129					      SUBROUTINE
      3  0129				   StealPart3
    320  0129
    321  0129		       bd c4 f1 	      lda	MOD10,x	; 4
    322  012c		       30 81		      bmi	PF0Draw	; 2/3 --> 25 cycles entering PF0Draw
    323  012e
    324  012e		       4a		      lsr		; 2
    325  012f		       aa		      tax		; 2
    326  0130		       98		      tya		; 2
    327  0131		       2a		      rol		; 2	       allows for mirrored char = * | 1
    328  0132		       a8		      tay		; 2
    329  0133		       b0 a6		      bcs	DirectDraw	; 2(3) = 18✅ when draw stack was built, bit 7 flags direct-drawn character
    330  0135							; ==> [18]+{19) = 37 @ start of DirectDraw
    331  0135
    332  0135		       b9 03 f3 	      lda	CharacterDataVecHI,y	; 4
    333  0138		       10 38		      bpl	QuickDraw	; 2(3) = 6(7)	 special-case blank characters for extra speed
    334  013a							; => [18]+18+(7) = 43✅ starting QuickDraw
    335  013a							; +15 => 58✅ if QuickDraw exits
    336  013a
    337  013a							; @ 24
    338  013a
    339  013a		       8d 63 f5 	      sta	SMEOR1+RAM_WRITE+2	; 4
    340  013d
    341  013d		       ad 84 02 	      lda	INTIM	; 4
    342  0140		       c9 0d		      cmp	#SEGTIME_SCD_SLOW	; 2
    343  0142		       90 e4		      bcc	ExitDraw	; 2(3) = 8
    344  0144							; => [18]+55+6rts=79✅ cycles if we decline
    345  0144
    346  0144							; @36
    347  0144							; [18]+36 = @54
    348  0144
    349  0144		       b9 e5 f2 	      lda	CharacterDataVecLO,y	; 4
    350  0147		       8d 62 f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    351  014a
    352  014a		       bd b2 f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    353  014d		       8d 5f f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    354  0150		       8d 67 f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    355  0153		       8d 6a f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    356  0156
    357  0156		       bd bc f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    358  0159		       8d 65 f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    359  015c
    360  015c		       a0 17	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2 => @88+
    361  015e
    362  015e							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    363  015e							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    364  015e
    365  015e				   TSFill		; 24*{...✅
    366  015e
    367  015e		       b9 14 f2    SMLOAD     lda	ScreenBitmap,y	; 4
    368  0161		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    369  0164		       29 00	   SMMASK     and	#0	; 2
    370  0166		       59 14 f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    371  0169		       99 14 f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    372  016c
    373  016c		       88		      dey		; 2
      0  016d					      CHECKPAGE_BPL	TSFill	; 3(2)=5  ...24}-1 = 575✅
      8  016d					      LIST	ON
      9  016d		       10 ef		      bpl	TSFill
    375  016f
    376  016f		       4c c7 fa 	      jmp	DrawAnother	; 3 = @88+575+3 = @676✅
    377  0172
    378  0172
    379  0172							;------------------------------------------------------------------------------
    380  0172							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    381  0172							; existing character data, so can be special-cased from the normal character
    382  0172							; draw, saving roughly 230 cycles.
    383  0172
    384  0172				   QuickDraw		; [43]✅ cycles until here
    385  0172
    386  0172		       ad 84 02 	      lda	INTIM	; 4
    387  0175		       c9 08		      cmp	#SEGTIME_SCD_QUICK	; 2
    388  0177		       90 af		      bcc	ExitDraw	; 2(3)=8(9)
    389  0179							; =>[43]+(9)+6rts =58✅ if exit
    390  0179							;@[43]+8=51✅
    391  0179
    392  0179		       bd b2 f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    393  017c		       8d 99 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    394  017f		       8d 9c f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    395  0182		       69 07		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    396  0184		       8d a0 f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    397  0187		       8d a3 f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    398  018a		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    399  018c		       8d a7 f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    400  018f		       8d aa f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32✅
    401  0192
    402  0192		       bc ba f1 	      ldy	CharMask,x	; 4	     masks out left or right
    403  0195
    404  0195		       a2 07		      ldx	#LINES_PER_CHAR/3 - 1	; 2	     =32+4+2+8*{...✅
    405  0197				   TSFill2
    406  0197		       98		      tya		; 2
    407  0198		       3d 14 f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    408  019b		       9d 14 f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    409  019e		       98		      tya		; 2
    410  019f		       3d 14 f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    411  01a2		       9d 14 f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    412  01a5		       98		      tya		; 2
    413  01a6		       3d 14 f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    414  01a9		       9d 14 f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33✅
    415  01ac
    416  01ac		       ca		      dex		; 2
      0  01ad					      CHECKPAGE_BPL	TSFill2	; 3(2) = 5  ...} = 32+4+2+8*38-1
      8  01ad					      LIST	ON
      9  01ad		       10 e8		      bpl	TSFill2
    418  01af							;		  => 341✅
    419  01af
    420  01af		       4c c7 fa 	      jmp	DrawAnother	; 3 = 344
    421  01b2
    422  01b2							;------------------------------------------------------------------------------
    423  01b2
    424  01b2
    425  01b2				   CharAddressLO		;[abs char location % 10]
    426  01b2
    427  01b2							; Gives the absolute screen buffer address of the first line of the given character
    428  01b2							; Where character number is 0-9
    429  01b2
    430  01b2		       14		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    431  01b3		       14		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    432  01b4		       2c		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    433  01b5		       2c		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    434  01b6		       44		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    435  01b7		       44		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    436  01b8		       5c		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    437  01b9		       5c		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    438  01ba							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    439  01ba							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    440  01ba
    441  01ba				   CharMask		; [abs char location % 10]
    442  01ba
    443  01ba							; Gives the mask for any char of the screen (per row)
    444  01ba							; Note, this is hardwired to the screen format of 6 bytes/line
    445  01ba
    446  01ba		       0f		      .byte.b	$0F	; 1
    447  01bb		       f0		      .byte.b	$F0	; 2
    448  01bc				   CharMaskNeg
    449  01bc		       f0		      .byte.b	$F0	; 3/1
    450  01bd		       0f		      .byte.b	$0F	; 4/2
    451  01be		       0f		      .byte.b	$0F	; 6/3
    452  01bf		       f0		      .byte.b	$F0	; 7/4
    453  01c0		       f0		      .byte.b	$F0	; 8/6
    454  01c1		       0f		      .byte.b	$0F	; 9/7
    455  01c2		       0f		      .byte.b	$0F	; -/8
    456  01c3		       f0		      .byte.b	$F0	; -/9
    457  01c4				   MOD10
    458  01c4					      REPEAT	SCREEN_LINES
    459  01c4							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  01c4							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  01c4		       80		      .byte.b	DIRECT
    462  01c5		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  01c9		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  01ca		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  01ca					      REPEND
    459  01ce							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  01ce							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  01ce		       80		      .byte.b	DIRECT
    462  01cf		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  01d3		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  01d4		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  01d4					      REPEND
    459  01d8							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  01d8							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  01d8		       80		      .byte.b	DIRECT
    462  01d9		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  01dd		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  01de		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  01de					      REPEND
    459  01e2							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  01e2							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  01e2		       80		      .byte.b	DIRECT
    462  01e3		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  01e7		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  01e8		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  01e8					      REPEND
    459  01ec							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  01ec							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  01ec		       80		      .byte.b	DIRECT
    462  01ed		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  01f1		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  01f2		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  01f2					      REPEND
    459  01f6							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  01f6							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  01f6		       80		      .byte.b	DIRECT
    462  01f7		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  01fb		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  01fc		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  01fc					      REPEND
    459  0200							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  0200							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  0200		       80		      .byte.b	DIRECT
    462  0201		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  0205		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  0206		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    458  0206					      REPEND
    459  020a							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    460  020a							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    461  020a		       80		      .byte.b	DIRECT
    462  020b		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    463  020f		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    464  0210		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    465  0214					      REPEND
    466  0214
    467  0214							;------------------------------------------------------------------------------
    468  0214
      0  0214					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  0214					      LIST	ON
    470  0214
    471  0214		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,0	; character bitmap row (10 chars wide)
    472  0214		       f2 14	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    473  0214		       f2 1c	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    474  0214		       f2 24	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    475  0274
      0  0274					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  0274					      LIST	ON
    477  0274
    478  0274
    479  0274							;--------------------------------------------------------------------------
    480  0274
      0  0274					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  0274		       00 00	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  0274					      SUBROUTINE
      3  0274				   SelfModDrawPlayers
    482  0274
    483  0274							; Update the appropriate shape pointers in the draw code.
    484  0274							; First, set the shape to a blank player -- effectively erasing
    485  0274
    486  0274		       a6 af		      ldx	LastSpriteY
    487  0276		       30 15		      bmi	erased	; offscreen
    488  0278		       e4 a0		      cpx	ManDrawY
    489  027a		       f0 28		      beq	NoMod	; same line, so all should be OK already
    490  027c
    491  027c		       86 3e		      stx	SET_BANK_RAM	; switch old bank in (this code too!!!!)
    492  027e
    493  027e		       a9 21		      lda	#<PLAYER_BLANK	; "erase"
    494  0280		       8d 21 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1
    495  0283		       a9 29		      lda	#<PLAYER_BLANK + LINES_PER_CHAR/3
    496  0285		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    497  0288		       a9 31		      lda	#<PLAYER_BLANK + 2*LINES_PER_CHAR/3
    498  028a		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    499  028d
    500  028d							; Now we've erased, we write the new shape
    501  028d
    502  028d		       a6 a0	   erased     ldx	ManDrawY
    503  028f		       86 af		      stx	LastSpriteY
    504  0291		       30 11		      bmi	NoMod
    505  0293
    506  0293		       86 3e		      stx	SET_BANK_RAM	; switch new bank in (this code too!!!!)
    507  0295
    508  0295		       a9 39		      lda	#<PLAYER0_SHAPE	; draw buffer holding the new frame shape
    509  0297		       8d 21 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1
    510  029a		       a9 41		      lda	#<PLAYER0_SHAPE + LINES_PER_CHAR/3
    511  029c		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    512  029f		       a9 49		      lda	#<PLAYER0_SHAPE + 2*LINES_PER_CHAR/3
    513  02a1		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    514  02a4
    515  02a4		       60	   NoMod      rts
    516  02a5
      0  02a5					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  02a5
      2  02a5
      3  02a5		       02 a5	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $2a5 , FREE= $15b
      4  02a5					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  02a5				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  02a5				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  02a5				  -	      ERR
      8  02a5					      endif
    518  02a5
    519  02a5							;------------------------------------------------------------------------------
    520  02a5
    521  02a5							; The acutal colour palette to use for the player. The player may be any "ethnicity" which refers
    522  02a5							; to the colours for a frame. The skin could be asian/black/caucasian, the cloting could be anything.
    523  02a5							; Each ethnicity is defined as first 8 bytes for NTSC and then 8 bytes for PAL. The 8 bytes refer
    524  02a5							; to the "CL#" index values defined in the player COLOUR frames. So, an index is grabbed from the
    525  02a5							; player frame, it is adjusted to add the base ethnicity and the NTSC/PAL, and that gives the base
    526  02a5							; for reading 8 successive bytes for CL0..CL7 from the frame definitions.
    527  02a5
    528  02a5				   EthnicityColourPalette
    529  02a5
    530  02a5							; CL0	   = BLACK
    531  02a5							; CL1	   = HAT
    532  02a5							; CL2	   = SKIN
    533  02a5							; CL3	   = CUFFS/TRIM
    534  02a5							; CL4	   = JUMPER
    535  02a5							; CL5	   = PANTS
    536  02a5							; CL6	   = SHOES
    537  02a5							; CL7	   = UNUSED
    538  02a5
    539  02a5							; CL7 = NOT USABLE
    540  02a5
    541  02a5							; (*) = unchecked/converted
    542  02a5
    543  02a5					      MAC	colour_group
    544  02a5							; NTSC...
    545  02a5					      .byte	0
    546  02a5					      .byte	{1}+{2}
    547  02a5					      .byte	{3}+{4}
    548  02a5					      .byte	{5}+{6}
    549  02a5					      .byte	{7}+{8}
    550  02a5					      .byte	{9}+{10}
    551  02a5					      .byte	{11}+{12}
    552  02a5					      .byte	0
    553  02a5
    554  02a5							; PAL...
    555  02a5					      .byte	0
    556  02a5					      NTSC_TO_PAL	{1}, {2}
    557  02a5					      NTSC_TO_PAL	{3}, {4}
    558  02a5					      NTSC_TO_PAL	{5}, {6}
    559  02a5					      NTSC_TO_PAL	{7}, {8}
    560  02a5					      NTSC_TO_PAL	{9}, {10}
    561  02a5					      NTSC_TO_PAL	{11}, {12}
    562  02a5					      .byte	0
    563  02a5					      ENDM
    564  02a5
    565  02a5							; USE NTSC COLOUR+INTENSITY. WILL AUTO-ADD PAL EQUIVALENT...
    566  02a5							;		 HAT	 FACE	 TRIM	 JUMPER  PANTS	SHOES
      0  02a5					      COLOUR_GROUP	$10,$A, $40,$8, $00,$C, $80,$8, $90,6, $10,6	; 0
      1  02a5
      2  02a5		       00		      .byte.b	0
      3  02a6		       1a		      .byte.b	$10+$A
      4  02a7		       48		      .byte.b	$40+$8
      5  02a8		       0c		      .byte.b	$00+$C
      6  02a9		       88		      .byte.b	$80+$8
      7  02aa		       96		      .byte.b	$90+6
      8  02ab		       16		      .byte.b	$10+6
      9  02ac		       00		      .byte.b	0
     10  02ad
     11  02ad
     12  02ad		       00		      .byte.b	0
      0  02ae					      NTSC_TO_PAL	$10, $A
      1  02ae				  -	      IF	$10 = 0
      2  02ae				  -	      .byte	$10+$A
      3  02ae					      ENDIF
      4  02ae					      IF	$10 = $10
      5  02ae		       2a		      .byte.b	$20+$A
      6  02af					      ENDIF
      7  02af				  -	      IF	$10 = $20
      8  02af				  -	      .byte	$40+$A
      9  02af					      ENDIF
     10  02af				  -	      IF	$10 = $30
     11  02af				  -	      .byte	$40+$A
     12  02af					      ENDIF
     13  02af				  -	      IF	$10 = $40
     14  02af				  -	      .byte	$60+$A
     15  02af					      ENDIF
     16  02af				  -	      IF	$10 = $50
     17  02af				  -	      .byte	$80+$A
     18  02af					      ENDIF
     19  02af				  -	      IF	$10 = $60
     20  02af				  -	      .byte	$C0+$A
     21  02af					      ENDIF
     22  02af				  -	      IF	$10 = $70
     23  02af				  -	      .byte	$D0+$A
     24  02af					      ENDIF
     25  02af				  -	      IF	$10 = $80
     26  02af				  -	      .byte	$B0+$A
     27  02af					      ENDIF
     28  02af				  -	      IF	$10 = $90
     29  02af				  -	      .byte	$90+$A
     30  02af					      ENDIF
     31  02af				  -	      IF	$10 = $A0
     32  02af				  -	      .byte	$70+$A
     33  02af					      ENDIF
     34  02af				  -	      IF	$10 = $B0
     35  02af				  -	      .byte	$50+$A
     36  02af					      ENDIF
     37  02af				  -	      IF	$10 = $C0
     38  02af				  -	      .byte	$30+$A
     39  02af					      ENDIF
     40  02af				  -	      IF	$10 = $D0
     41  02af				  -	      .byte	$30+$A
     42  02af					      ENDIF
     43  02af				  -	      IF	$10 = $E0
     44  02af				  -	      .byte	$20+$A
     45  02af					      ENDIF
     46  02af				  -	      IF	$10 = $F0
     47  02af				  -	      .byte	$40+$A
     48  02af					      ENDIF
      0  02af					      NTSC_TO_PAL	$40, $8
      1  02af				  -	      IF	$40 = 0
      2  02af				  -	      .byte	$40+$8
      3  02af					      ENDIF
      4  02af				  -	      IF	$40 = $10
      5  02af				  -	      .byte	$20+$8
      6  02af					      ENDIF
      7  02af				  -	      IF	$40 = $20
      8  02af				  -	      .byte	$40+$8
      9  02af					      ENDIF
     10  02af				  -	      IF	$40 = $30
     11  02af				  -	      .byte	$40+$8
     12  02af					      ENDIF
     13  02af					      IF	$40 = $40
     14  02af		       68		      .byte.b	$60+$8
     15  02b0					      ENDIF
     16  02b0				  -	      IF	$40 = $50
     17  02b0				  -	      .byte	$80+$8
     18  02b0					      ENDIF
     19  02b0				  -	      IF	$40 = $60
     20  02b0				  -	      .byte	$C0+$8
     21  02b0					      ENDIF
     22  02b0				  -	      IF	$40 = $70
     23  02b0				  -	      .byte	$D0+$8
     24  02b0					      ENDIF
     25  02b0				  -	      IF	$40 = $80
     26  02b0				  -	      .byte	$B0+$8
     27  02b0					      ENDIF
     28  02b0				  -	      IF	$40 = $90
     29  02b0				  -	      .byte	$90+$8
     30  02b0					      ENDIF
     31  02b0				  -	      IF	$40 = $A0
     32  02b0				  -	      .byte	$70+$8
     33  02b0					      ENDIF
     34  02b0				  -	      IF	$40 = $B0
     35  02b0				  -	      .byte	$50+$8
     36  02b0					      ENDIF
     37  02b0				  -	      IF	$40 = $C0
     38  02b0				  -	      .byte	$30+$8
     39  02b0					      ENDIF
     40  02b0				  -	      IF	$40 = $D0
     41  02b0				  -	      .byte	$30+$8
     42  02b0					      ENDIF
     43  02b0				  -	      IF	$40 = $E0
     44  02b0				  -	      .byte	$20+$8
     45  02b0					      ENDIF
     46  02b0				  -	      IF	$40 = $F0
     47  02b0				  -	      .byte	$40+$8
     48  02b0					      ENDIF
      0  02b0					      NTSC_TO_PAL	$00, $C
      1  02b0					      IF	$00 = 0
      2  02b0		       0c		      .byte.b	$00+$C
      3  02b1					      ENDIF
      4  02b1				  -	      IF	$00 = $10
      5  02b1				  -	      .byte	$20+$C
      6  02b1					      ENDIF
      7  02b1				  -	      IF	$00 = $20
      8  02b1				  -	      .byte	$40+$C
      9  02b1					      ENDIF
     10  02b1				  -	      IF	$00 = $30
     11  02b1				  -	      .byte	$40+$C
     12  02b1					      ENDIF
     13  02b1				  -	      IF	$00 = $40
     14  02b1				  -	      .byte	$60+$C
     15  02b1					      ENDIF
     16  02b1				  -	      IF	$00 = $50
     17  02b1				  -	      .byte	$80+$C
     18  02b1					      ENDIF
     19  02b1				  -	      IF	$00 = $60
     20  02b1				  -	      .byte	$C0+$C
     21  02b1					      ENDIF
     22  02b1				  -	      IF	$00 = $70
     23  02b1				  -	      .byte	$D0+$C
     24  02b1					      ENDIF
     25  02b1				  -	      IF	$00 = $80
     26  02b1				  -	      .byte	$B0+$C
     27  02b1					      ENDIF
     28  02b1				  -	      IF	$00 = $90
     29  02b1				  -	      .byte	$90+$C
     30  02b1					      ENDIF
     31  02b1				  -	      IF	$00 = $A0
     32  02b1				  -	      .byte	$70+$C
     33  02b1					      ENDIF
     34  02b1				  -	      IF	$00 = $B0
     35  02b1				  -	      .byte	$50+$C
     36  02b1					      ENDIF
     37  02b1				  -	      IF	$00 = $C0
     38  02b1				  -	      .byte	$30+$C
     39  02b1					      ENDIF
     40  02b1				  -	      IF	$00 = $D0
     41  02b1				  -	      .byte	$30+$C
     42  02b1					      ENDIF
     43  02b1				  -	      IF	$00 = $E0
     44  02b1				  -	      .byte	$20+$C
     45  02b1					      ENDIF
     46  02b1				  -	      IF	$00 = $F0
     47  02b1				  -	      .byte	$40+$C
     48  02b1					      ENDIF
      0  02b1					      NTSC_TO_PAL	$80, $8
      1  02b1				  -	      IF	$80 = 0
      2  02b1				  -	      .byte	$80+$8
      3  02b1					      ENDIF
      4  02b1				  -	      IF	$80 = $10
      5  02b1				  -	      .byte	$20+$8
      6  02b1					      ENDIF
      7  02b1				  -	      IF	$80 = $20
      8  02b1				  -	      .byte	$40+$8
      9  02b1					      ENDIF
     10  02b1				  -	      IF	$80 = $30
     11  02b1				  -	      .byte	$40+$8
     12  02b1					      ENDIF
     13  02b1				  -	      IF	$80 = $40
     14  02b1				  -	      .byte	$60+$8
     15  02b1					      ENDIF
     16  02b1				  -	      IF	$80 = $50
     17  02b1				  -	      .byte	$80+$8
     18  02b1					      ENDIF
     19  02b1				  -	      IF	$80 = $60
     20  02b1				  -	      .byte	$C0+$8
     21  02b1					      ENDIF
     22  02b1				  -	      IF	$80 = $70
     23  02b1				  -	      .byte	$D0+$8
     24  02b1					      ENDIF
     25  02b1					      IF	$80 = $80
     26  02b1		       b8		      .byte.b	$B0+$8
     27  02b2					      ENDIF
     28  02b2				  -	      IF	$80 = $90
     29  02b2				  -	      .byte	$90+$8
     30  02b2					      ENDIF
     31  02b2				  -	      IF	$80 = $A0
     32  02b2				  -	      .byte	$70+$8
     33  02b2					      ENDIF
     34  02b2				  -	      IF	$80 = $B0
     35  02b2				  -	      .byte	$50+$8
     36  02b2					      ENDIF
     37  02b2				  -	      IF	$80 = $C0
     38  02b2				  -	      .byte	$30+$8
     39  02b2					      ENDIF
     40  02b2				  -	      IF	$80 = $D0
     41  02b2				  -	      .byte	$30+$8
     42  02b2					      ENDIF
     43  02b2				  -	      IF	$80 = $E0
     44  02b2				  -	      .byte	$20+$8
     45  02b2					      ENDIF
     46  02b2				  -	      IF	$80 = $F0
     47  02b2				  -	      .byte	$40+$8
     48  02b2					      ENDIF
      0  02b2					      NTSC_TO_PAL	$90, 6
      1  02b2				  -	      IF	$90 = 0
      2  02b2				  -	      .byte	$90+6
      3  02b2					      ENDIF
      4  02b2				  -	      IF	$90 = $10
      5  02b2				  -	      .byte	$20+6
      6  02b2					      ENDIF
      7  02b2				  -	      IF	$90 = $20
      8  02b2				  -	      .byte	$40+6
      9  02b2					      ENDIF
     10  02b2				  -	      IF	$90 = $30
     11  02b2				  -	      .byte	$40+6
     12  02b2					      ENDIF
     13  02b2				  -	      IF	$90 = $40
     14  02b2				  -	      .byte	$60+6
     15  02b2					      ENDIF
     16  02b2				  -	      IF	$90 = $50
     17  02b2				  -	      .byte	$80+6
     18  02b2					      ENDIF
     19  02b2				  -	      IF	$90 = $60
     20  02b2				  -	      .byte	$C0+6
     21  02b2					      ENDIF
     22  02b2				  -	      IF	$90 = $70
     23  02b2				  -	      .byte	$D0+6
     24  02b2					      ENDIF
     25  02b2				  -	      IF	$90 = $80
     26  02b2				  -	      .byte	$B0+6
     27  02b2					      ENDIF
     28  02b2					      IF	$90 = $90
     29  02b2		       96		      .byte.b	$90+6
     30  02b3					      ENDIF
     31  02b3				  -	      IF	$90 = $A0
     32  02b3				  -	      .byte	$70+6
     33  02b3					      ENDIF
     34  02b3				  -	      IF	$90 = $B0
     35  02b3				  -	      .byte	$50+6
     36  02b3					      ENDIF
     37  02b3				  -	      IF	$90 = $C0
     38  02b3				  -	      .byte	$30+6
     39  02b3					      ENDIF
     40  02b3				  -	      IF	$90 = $D0
     41  02b3				  -	      .byte	$30+6
     42  02b3					      ENDIF
     43  02b3				  -	      IF	$90 = $E0
     44  02b3				  -	      .byte	$20+6
     45  02b3					      ENDIF
     46  02b3				  -	      IF	$90 = $F0
     47  02b3				  -	      .byte	$40+6
     48  02b3					      ENDIF
      0  02b3					      NTSC_TO_PAL	$10, 6
      1  02b3				  -	      IF	$10 = 0
      2  02b3				  -	      .byte	$10+6
      3  02b3					      ENDIF
      4  02b3					      IF	$10 = $10
      5  02b3		       26		      .byte.b	$20+6
      6  02b4					      ENDIF
      7  02b4				  -	      IF	$10 = $20
      8  02b4				  -	      .byte	$40+6
      9  02b4					      ENDIF
     10  02b4				  -	      IF	$10 = $30
     11  02b4				  -	      .byte	$40+6
     12  02b4					      ENDIF
     13  02b4				  -	      IF	$10 = $40
     14  02b4				  -	      .byte	$60+6
     15  02b4					      ENDIF
     16  02b4				  -	      IF	$10 = $50
     17  02b4				  -	      .byte	$80+6
     18  02b4					      ENDIF
     19  02b4				  -	      IF	$10 = $60
     20  02b4				  -	      .byte	$C0+6
     21  02b4					      ENDIF
     22  02b4				  -	      IF	$10 = $70
     23  02b4				  -	      .byte	$D0+6
     24  02b4					      ENDIF
     25  02b4				  -	      IF	$10 = $80
     26  02b4				  -	      .byte	$B0+6
     27  02b4					      ENDIF
     28  02b4				  -	      IF	$10 = $90
     29  02b4				  -	      .byte	$90+6
     30  02b4					      ENDIF
     31  02b4				  -	      IF	$10 = $A0
     32  02b4				  -	      .byte	$70+6
     33  02b4					      ENDIF
     34  02b4				  -	      IF	$10 = $B0
     35  02b4				  -	      .byte	$50+6
     36  02b4					      ENDIF
     37  02b4				  -	      IF	$10 = $C0
     38  02b4				  -	      .byte	$30+6
     39  02b4					      ENDIF
     40  02b4				  -	      IF	$10 = $D0
     41  02b4				  -	      .byte	$30+6
     42  02b4					      ENDIF
     43  02b4				  -	      IF	$10 = $E0
     44  02b4				  -	      .byte	$20+6
     45  02b4					      ENDIF
     46  02b4				  -	      IF	$10 = $F0
     47  02b4				  -	      .byte	$40+6
     48  02b4					      ENDIF
     19  02b4		       00		      .byte.b	0
      0  02b5					      COLOUR_GROUP	$10,$A, $F0,$8, $60,$C, $50,$4, $70,6, $40,6	; 1
      1  02b5
      2  02b5		       00		      .byte.b	0
      3  02b6		       1a		      .byte.b	$10+$A
      4  02b7		       f8		      .byte.b	$F0+$8
      5  02b8		       6c		      .byte.b	$60+$C
      6  02b9		       54		      .byte.b	$50+$4
      7  02ba		       76		      .byte.b	$70+6
      8  02bb		       46		      .byte.b	$40+6
      9  02bc		       00		      .byte.b	0
     10  02bd
     11  02bd
     12  02bd		       00		      .byte.b	0
      0  02be					      NTSC_TO_PAL	$10, $A
      1  02be				  -	      IF	$10 = 0
      2  02be				  -	      .byte	$10+$A
      3  02be					      ENDIF
      4  02be					      IF	$10 = $10
      5  02be		       2a		      .byte.b	$20+$A
      6  02bf					      ENDIF
      7  02bf				  -	      IF	$10 = $20
      8  02bf				  -	      .byte	$40+$A
      9  02bf					      ENDIF
     10  02bf				  -	      IF	$10 = $30
     11  02bf				  -	      .byte	$40+$A
     12  02bf					      ENDIF
     13  02bf				  -	      IF	$10 = $40
     14  02bf				  -	      .byte	$60+$A
     15  02bf					      ENDIF
     16  02bf				  -	      IF	$10 = $50
     17  02bf				  -	      .byte	$80+$A
     18  02bf					      ENDIF
     19  02bf				  -	      IF	$10 = $60
     20  02bf				  -	      .byte	$C0+$A
     21  02bf					      ENDIF
     22  02bf				  -	      IF	$10 = $70
     23  02bf				  -	      .byte	$D0+$A
     24  02bf					      ENDIF
     25  02bf				  -	      IF	$10 = $80
     26  02bf				  -	      .byte	$B0+$A
     27  02bf					      ENDIF
     28  02bf				  -	      IF	$10 = $90
     29  02bf				  -	      .byte	$90+$A
     30  02bf					      ENDIF
     31  02bf				  -	      IF	$10 = $A0
     32  02bf				  -	      .byte	$70+$A
     33  02bf					      ENDIF
     34  02bf				  -	      IF	$10 = $B0
     35  02bf				  -	      .byte	$50+$A
     36  02bf					      ENDIF
     37  02bf				  -	      IF	$10 = $C0
     38  02bf				  -	      .byte	$30+$A
     39  02bf					      ENDIF
     40  02bf				  -	      IF	$10 = $D0
     41  02bf				  -	      .byte	$30+$A
     42  02bf					      ENDIF
     43  02bf				  -	      IF	$10 = $E0
     44  02bf				  -	      .byte	$20+$A
     45  02bf					      ENDIF
     46  02bf				  -	      IF	$10 = $F0
     47  02bf				  -	      .byte	$40+$A
     48  02bf					      ENDIF
      0  02bf					      NTSC_TO_PAL	$F0, $8
      1  02bf				  -	      IF	$F0 = 0
      2  02bf				  -	      .byte	$F0+$8
      3  02bf					      ENDIF
      4  02bf				  -	      IF	$F0 = $10
      5  02bf				  -	      .byte	$20+$8
      6  02bf					      ENDIF
      7  02bf				  -	      IF	$F0 = $20
      8  02bf				  -	      .byte	$40+$8
      9  02bf					      ENDIF
     10  02bf				  -	      IF	$F0 = $30
     11  02bf				  -	      .byte	$40+$8
     12  02bf					      ENDIF
     13  02bf				  -	      IF	$F0 = $40
     14  02bf				  -	      .byte	$60+$8
     15  02bf					      ENDIF
     16  02bf				  -	      IF	$F0 = $50
     17  02bf				  -	      .byte	$80+$8
     18  02bf					      ENDIF
     19  02bf				  -	      IF	$F0 = $60
     20  02bf				  -	      .byte	$C0+$8
     21  02bf					      ENDIF
     22  02bf				  -	      IF	$F0 = $70
     23  02bf				  -	      .byte	$D0+$8
     24  02bf					      ENDIF
     25  02bf				  -	      IF	$F0 = $80
     26  02bf				  -	      .byte	$B0+$8
     27  02bf					      ENDIF
     28  02bf				  -	      IF	$F0 = $90
     29  02bf				  -	      .byte	$90+$8
     30  02bf					      ENDIF
     31  02bf				  -	      IF	$F0 = $A0
     32  02bf				  -	      .byte	$70+$8
     33  02bf					      ENDIF
     34  02bf				  -	      IF	$F0 = $B0
     35  02bf				  -	      .byte	$50+$8
     36  02bf					      ENDIF
     37  02bf				  -	      IF	$F0 = $C0
     38  02bf				  -	      .byte	$30+$8
     39  02bf					      ENDIF
     40  02bf				  -	      IF	$F0 = $D0
     41  02bf				  -	      .byte	$30+$8
     42  02bf					      ENDIF
     43  02bf				  -	      IF	$F0 = $E0
     44  02bf				  -	      .byte	$20+$8
     45  02bf					      ENDIF
     46  02bf					      IF	$F0 = $F0
     47  02bf		       48		      .byte.b	$40+$8
     48  02c0					      ENDIF
      0  02c0					      NTSC_TO_PAL	$60, $C
      1  02c0				  -	      IF	$60 = 0
      2  02c0				  -	      .byte	$60+$C
      3  02c0					      ENDIF
      4  02c0				  -	      IF	$60 = $10
      5  02c0				  -	      .byte	$20+$C
      6  02c0					      ENDIF
      7  02c0				  -	      IF	$60 = $20
      8  02c0				  -	      .byte	$40+$C
      9  02c0					      ENDIF
     10  02c0				  -	      IF	$60 = $30
     11  02c0				  -	      .byte	$40+$C
     12  02c0					      ENDIF
     13  02c0				  -	      IF	$60 = $40
     14  02c0				  -	      .byte	$60+$C
     15  02c0					      ENDIF
     16  02c0				  -	      IF	$60 = $50
     17  02c0				  -	      .byte	$80+$C
     18  02c0					      ENDIF
     19  02c0					      IF	$60 = $60
     20  02c0		       cc		      .byte.b	$C0+$C
     21  02c1					      ENDIF
     22  02c1				  -	      IF	$60 = $70
     23  02c1				  -	      .byte	$D0+$C
     24  02c1					      ENDIF
     25  02c1				  -	      IF	$60 = $80
     26  02c1				  -	      .byte	$B0+$C
     27  02c1					      ENDIF
     28  02c1				  -	      IF	$60 = $90
     29  02c1				  -	      .byte	$90+$C
     30  02c1					      ENDIF
     31  02c1				  -	      IF	$60 = $A0
     32  02c1				  -	      .byte	$70+$C
     33  02c1					      ENDIF
     34  02c1				  -	      IF	$60 = $B0
     35  02c1				  -	      .byte	$50+$C
     36  02c1					      ENDIF
     37  02c1				  -	      IF	$60 = $C0
     38  02c1				  -	      .byte	$30+$C
     39  02c1					      ENDIF
     40  02c1				  -	      IF	$60 = $D0
     41  02c1				  -	      .byte	$30+$C
     42  02c1					      ENDIF
     43  02c1				  -	      IF	$60 = $E0
     44  02c1				  -	      .byte	$20+$C
     45  02c1					      ENDIF
     46  02c1				  -	      IF	$60 = $F0
     47  02c1				  -	      .byte	$40+$C
     48  02c1					      ENDIF
      0  02c1					      NTSC_TO_PAL	$50, $4
      1  02c1				  -	      IF	$50 = 0
      2  02c1				  -	      .byte	$50+$4
      3  02c1					      ENDIF
      4  02c1				  -	      IF	$50 = $10
      5  02c1				  -	      .byte	$20+$4
      6  02c1					      ENDIF
      7  02c1				  -	      IF	$50 = $20
      8  02c1				  -	      .byte	$40+$4
      9  02c1					      ENDIF
     10  02c1				  -	      IF	$50 = $30
     11  02c1				  -	      .byte	$40+$4
     12  02c1					      ENDIF
     13  02c1				  -	      IF	$50 = $40
     14  02c1				  -	      .byte	$60+$4
     15  02c1					      ENDIF
     16  02c1					      IF	$50 = $50
     17  02c1		       84		      .byte.b	$80+$4
     18  02c2					      ENDIF
     19  02c2				  -	      IF	$50 = $60
     20  02c2				  -	      .byte	$C0+$4
     21  02c2					      ENDIF
     22  02c2				  -	      IF	$50 = $70
     23  02c2				  -	      .byte	$D0+$4
     24  02c2					      ENDIF
     25  02c2				  -	      IF	$50 = $80
     26  02c2				  -	      .byte	$B0+$4
     27  02c2					      ENDIF
     28  02c2				  -	      IF	$50 = $90
     29  02c2				  -	      .byte	$90+$4
     30  02c2					      ENDIF
     31  02c2				  -	      IF	$50 = $A0
     32  02c2				  -	      .byte	$70+$4
     33  02c2					      ENDIF
     34  02c2				  -	      IF	$50 = $B0
     35  02c2				  -	      .byte	$50+$4
     36  02c2					      ENDIF
     37  02c2				  -	      IF	$50 = $C0
     38  02c2				  -	      .byte	$30+$4
     39  02c2					      ENDIF
     40  02c2				  -	      IF	$50 = $D0
     41  02c2				  -	      .byte	$30+$4
     42  02c2					      ENDIF
     43  02c2				  -	      IF	$50 = $E0
     44  02c2				  -	      .byte	$20+$4
     45  02c2					      ENDIF
     46  02c2				  -	      IF	$50 = $F0
     47  02c2				  -	      .byte	$40+$4
     48  02c2					      ENDIF
      0  02c2					      NTSC_TO_PAL	$70, 6
      1  02c2				  -	      IF	$70 = 0
      2  02c2				  -	      .byte	$70+6
      3  02c2					      ENDIF
      4  02c2				  -	      IF	$70 = $10
      5  02c2				  -	      .byte	$20+6
      6  02c2					      ENDIF
      7  02c2				  -	      IF	$70 = $20
      8  02c2				  -	      .byte	$40+6
      9  02c2					      ENDIF
     10  02c2				  -	      IF	$70 = $30
     11  02c2				  -	      .byte	$40+6
     12  02c2					      ENDIF
     13  02c2				  -	      IF	$70 = $40
     14  02c2				  -	      .byte	$60+6
     15  02c2					      ENDIF
     16  02c2				  -	      IF	$70 = $50
     17  02c2				  -	      .byte	$80+6
     18  02c2					      ENDIF
     19  02c2				  -	      IF	$70 = $60
     20  02c2				  -	      .byte	$C0+6
     21  02c2					      ENDIF
     22  02c2					      IF	$70 = $70
     23  02c2		       d6		      .byte.b	$D0+6
     24  02c3					      ENDIF
     25  02c3				  -	      IF	$70 = $80
     26  02c3				  -	      .byte	$B0+6
     27  02c3					      ENDIF
     28  02c3				  -	      IF	$70 = $90
     29  02c3				  -	      .byte	$90+6
     30  02c3					      ENDIF
     31  02c3				  -	      IF	$70 = $A0
     32  02c3				  -	      .byte	$70+6
     33  02c3					      ENDIF
     34  02c3				  -	      IF	$70 = $B0
     35  02c3				  -	      .byte	$50+6
     36  02c3					      ENDIF
     37  02c3				  -	      IF	$70 = $C0
     38  02c3				  -	      .byte	$30+6
     39  02c3					      ENDIF
     40  02c3				  -	      IF	$70 = $D0
     41  02c3				  -	      .byte	$30+6
     42  02c3					      ENDIF
     43  02c3				  -	      IF	$70 = $E0
     44  02c3				  -	      .byte	$20+6
     45  02c3					      ENDIF
     46  02c3				  -	      IF	$70 = $F0
     47  02c3				  -	      .byte	$40+6
     48  02c3					      ENDIF
      0  02c3					      NTSC_TO_PAL	$40, 6
      1  02c3				  -	      IF	$40 = 0
      2  02c3				  -	      .byte	$40+6
      3  02c3					      ENDIF
      4  02c3				  -	      IF	$40 = $10
      5  02c3				  -	      .byte	$20+6
      6  02c3					      ENDIF
      7  02c3				  -	      IF	$40 = $20
      8  02c3				  -	      .byte	$40+6
      9  02c3					      ENDIF
     10  02c3				  -	      IF	$40 = $30
     11  02c3				  -	      .byte	$40+6
     12  02c3					      ENDIF
     13  02c3					      IF	$40 = $40
     14  02c3		       66		      .byte.b	$60+6
     15  02c4					      ENDIF
     16  02c4				  -	      IF	$40 = $50
     17  02c4				  -	      .byte	$80+6
     18  02c4					      ENDIF
     19  02c4				  -	      IF	$40 = $60
     20  02c4				  -	      .byte	$C0+6
     21  02c4					      ENDIF
     22  02c4				  -	      IF	$40 = $70
     23  02c4				  -	      .byte	$D0+6
     24  02c4					      ENDIF
     25  02c4				  -	      IF	$40 = $80
     26  02c4				  -	      .byte	$B0+6
     27  02c4					      ENDIF
     28  02c4				  -	      IF	$40 = $90
     29  02c4				  -	      .byte	$90+6
     30  02c4					      ENDIF
     31  02c4				  -	      IF	$40 = $A0
     32  02c4				  -	      .byte	$70+6
     33  02c4					      ENDIF
     34  02c4				  -	      IF	$40 = $B0
     35  02c4				  -	      .byte	$50+6
     36  02c4					      ENDIF
     37  02c4				  -	      IF	$40 = $C0
     38  02c4				  -	      .byte	$30+6
     39  02c4					      ENDIF
     40  02c4				  -	      IF	$40 = $D0
     41  02c4				  -	      .byte	$30+6
     42  02c4					      ENDIF
     43  02c4				  -	      IF	$40 = $E0
     44  02c4				  -	      .byte	$20+6
     45  02c4					      ENDIF
     46  02c4				  -	      IF	$40 = $F0
     47  02c4				  -	      .byte	$40+6
     48  02c4					      ENDIF
     19  02c4		       00		      .byte.b	0
      0  02c5					      COLOUR_GROUP	$40,$6, $E0,$8, $00,$C, $C0,$4, $90,6, $20,6	; 2
      1  02c5
      2  02c5		       00		      .byte.b	0
      3  02c6		       46		      .byte.b	$40+$6
      4  02c7		       e8		      .byte.b	$E0+$8
      5  02c8		       0c		      .byte.b	$00+$C
      6  02c9		       c4		      .byte.b	$C0+$4
      7  02ca		       96		      .byte.b	$90+6
      8  02cb		       26		      .byte.b	$20+6
      9  02cc		       00		      .byte.b	0
     10  02cd
     11  02cd
     12  02cd		       00		      .byte.b	0
      0  02ce					      NTSC_TO_PAL	$40, $6
      1  02ce				  -	      IF	$40 = 0
      2  02ce				  -	      .byte	$40+$6
      3  02ce					      ENDIF
      4  02ce				  -	      IF	$40 = $10
      5  02ce				  -	      .byte	$20+$6
      6  02ce					      ENDIF
      7  02ce				  -	      IF	$40 = $20
      8  02ce				  -	      .byte	$40+$6
      9  02ce					      ENDIF
     10  02ce				  -	      IF	$40 = $30
     11  02ce				  -	      .byte	$40+$6
     12  02ce					      ENDIF
     13  02ce					      IF	$40 = $40
     14  02ce		       66		      .byte.b	$60+$6
     15  02cf					      ENDIF
     16  02cf				  -	      IF	$40 = $50
     17  02cf				  -	      .byte	$80+$6
     18  02cf					      ENDIF
     19  02cf				  -	      IF	$40 = $60
     20  02cf				  -	      .byte	$C0+$6
     21  02cf					      ENDIF
     22  02cf				  -	      IF	$40 = $70
     23  02cf				  -	      .byte	$D0+$6
     24  02cf					      ENDIF
     25  02cf				  -	      IF	$40 = $80
     26  02cf				  -	      .byte	$B0+$6
     27  02cf					      ENDIF
     28  02cf				  -	      IF	$40 = $90
     29  02cf				  -	      .byte	$90+$6
     30  02cf					      ENDIF
     31  02cf				  -	      IF	$40 = $A0
     32  02cf				  -	      .byte	$70+$6
     33  02cf					      ENDIF
     34  02cf				  -	      IF	$40 = $B0
     35  02cf				  -	      .byte	$50+$6
     36  02cf					      ENDIF
     37  02cf				  -	      IF	$40 = $C0
     38  02cf				  -	      .byte	$30+$6
     39  02cf					      ENDIF
     40  02cf				  -	      IF	$40 = $D0
     41  02cf				  -	      .byte	$30+$6
     42  02cf					      ENDIF
     43  02cf				  -	      IF	$40 = $E0
     44  02cf				  -	      .byte	$20+$6
     45  02cf					      ENDIF
     46  02cf				  -	      IF	$40 = $F0
     47  02cf				  -	      .byte	$40+$6
     48  02cf					      ENDIF
      0  02cf					      NTSC_TO_PAL	$E0, $8
      1  02cf				  -	      IF	$E0 = 0
      2  02cf				  -	      .byte	$E0+$8
      3  02cf					      ENDIF
      4  02cf				  -	      IF	$E0 = $10
      5  02cf				  -	      .byte	$20+$8
      6  02cf					      ENDIF
      7  02cf				  -	      IF	$E0 = $20
      8  02cf				  -	      .byte	$40+$8
      9  02cf					      ENDIF
     10  02cf				  -	      IF	$E0 = $30
     11  02cf				  -	      .byte	$40+$8
     12  02cf					      ENDIF
     13  02cf				  -	      IF	$E0 = $40
     14  02cf				  -	      .byte	$60+$8
     15  02cf					      ENDIF
     16  02cf				  -	      IF	$E0 = $50
     17  02cf				  -	      .byte	$80+$8
     18  02cf					      ENDIF
     19  02cf				  -	      IF	$E0 = $60
     20  02cf				  -	      .byte	$C0+$8
     21  02cf					      ENDIF
     22  02cf				  -	      IF	$E0 = $70
     23  02cf				  -	      .byte	$D0+$8
     24  02cf					      ENDIF
     25  02cf				  -	      IF	$E0 = $80
     26  02cf				  -	      .byte	$B0+$8
     27  02cf					      ENDIF
     28  02cf				  -	      IF	$E0 = $90
     29  02cf				  -	      .byte	$90+$8
     30  02cf					      ENDIF
     31  02cf				  -	      IF	$E0 = $A0
     32  02cf				  -	      .byte	$70+$8
     33  02cf					      ENDIF
     34  02cf				  -	      IF	$E0 = $B0
     35  02cf				  -	      .byte	$50+$8
     36  02cf					      ENDIF
     37  02cf				  -	      IF	$E0 = $C0
     38  02cf				  -	      .byte	$30+$8
     39  02cf					      ENDIF
     40  02cf				  -	      IF	$E0 = $D0
     41  02cf				  -	      .byte	$30+$8
     42  02cf					      ENDIF
     43  02cf					      IF	$E0 = $E0
     44  02cf		       28		      .byte.b	$20+$8
     45  02d0					      ENDIF
     46  02d0				  -	      IF	$E0 = $F0
     47  02d0				  -	      .byte	$40+$8
     48  02d0					      ENDIF
      0  02d0					      NTSC_TO_PAL	$00, $C
      1  02d0					      IF	$00 = 0
      2  02d0		       0c		      .byte.b	$00+$C
      3  02d1					      ENDIF
      4  02d1				  -	      IF	$00 = $10
      5  02d1				  -	      .byte	$20+$C
      6  02d1					      ENDIF
      7  02d1				  -	      IF	$00 = $20
      8  02d1				  -	      .byte	$40+$C
      9  02d1					      ENDIF
     10  02d1				  -	      IF	$00 = $30
     11  02d1				  -	      .byte	$40+$C
     12  02d1					      ENDIF
     13  02d1				  -	      IF	$00 = $40
     14  02d1				  -	      .byte	$60+$C
     15  02d1					      ENDIF
     16  02d1				  -	      IF	$00 = $50
     17  02d1				  -	      .byte	$80+$C
     18  02d1					      ENDIF
     19  02d1				  -	      IF	$00 = $60
     20  02d1				  -	      .byte	$C0+$C
     21  02d1					      ENDIF
     22  02d1				  -	      IF	$00 = $70
     23  02d1				  -	      .byte	$D0+$C
     24  02d1					      ENDIF
     25  02d1				  -	      IF	$00 = $80
     26  02d1				  -	      .byte	$B0+$C
     27  02d1					      ENDIF
     28  02d1				  -	      IF	$00 = $90
     29  02d1				  -	      .byte	$90+$C
     30  02d1					      ENDIF
     31  02d1				  -	      IF	$00 = $A0
     32  02d1				  -	      .byte	$70+$C
     33  02d1					      ENDIF
     34  02d1				  -	      IF	$00 = $B0
     35  02d1				  -	      .byte	$50+$C
     36  02d1					      ENDIF
     37  02d1				  -	      IF	$00 = $C0
     38  02d1				  -	      .byte	$30+$C
     39  02d1					      ENDIF
     40  02d1				  -	      IF	$00 = $D0
     41  02d1				  -	      .byte	$30+$C
     42  02d1					      ENDIF
     43  02d1				  -	      IF	$00 = $E0
     44  02d1				  -	      .byte	$20+$C
     45  02d1					      ENDIF
     46  02d1				  -	      IF	$00 = $F0
     47  02d1				  -	      .byte	$40+$C
     48  02d1					      ENDIF
      0  02d1					      NTSC_TO_PAL	$C0, $4
      1  02d1				  -	      IF	$C0 = 0
      2  02d1				  -	      .byte	$C0+$4
      3  02d1					      ENDIF
      4  02d1				  -	      IF	$C0 = $10
      5  02d1				  -	      .byte	$20+$4
      6  02d1					      ENDIF
      7  02d1				  -	      IF	$C0 = $20
      8  02d1				  -	      .byte	$40+$4
      9  02d1					      ENDIF
     10  02d1				  -	      IF	$C0 = $30
     11  02d1				  -	      .byte	$40+$4
     12  02d1					      ENDIF
     13  02d1				  -	      IF	$C0 = $40
     14  02d1				  -	      .byte	$60+$4
     15  02d1					      ENDIF
     16  02d1				  -	      IF	$C0 = $50
     17  02d1				  -	      .byte	$80+$4
     18  02d1					      ENDIF
     19  02d1				  -	      IF	$C0 = $60
     20  02d1				  -	      .byte	$C0+$4
     21  02d1					      ENDIF
     22  02d1				  -	      IF	$C0 = $70
     23  02d1				  -	      .byte	$D0+$4
     24  02d1					      ENDIF
     25  02d1				  -	      IF	$C0 = $80
     26  02d1				  -	      .byte	$B0+$4
     27  02d1					      ENDIF
     28  02d1				  -	      IF	$C0 = $90
     29  02d1				  -	      .byte	$90+$4
     30  02d1					      ENDIF
     31  02d1				  -	      IF	$C0 = $A0
     32  02d1				  -	      .byte	$70+$4
     33  02d1					      ENDIF
     34  02d1				  -	      IF	$C0 = $B0
     35  02d1				  -	      .byte	$50+$4
     36  02d1					      ENDIF
     37  02d1					      IF	$C0 = $C0
     38  02d1		       34		      .byte.b	$30+$4
     39  02d2					      ENDIF
     40  02d2				  -	      IF	$C0 = $D0
     41  02d2				  -	      .byte	$30+$4
     42  02d2					      ENDIF
     43  02d2				  -	      IF	$C0 = $E0
     44  02d2				  -	      .byte	$20+$4
     45  02d2					      ENDIF
     46  02d2				  -	      IF	$C0 = $F0
     47  02d2				  -	      .byte	$40+$4
     48  02d2					      ENDIF
      0  02d2					      NTSC_TO_PAL	$90, 6
      1  02d2				  -	      IF	$90 = 0
      2  02d2				  -	      .byte	$90+6
      3  02d2					      ENDIF
      4  02d2				  -	      IF	$90 = $10
      5  02d2				  -	      .byte	$20+6
      6  02d2					      ENDIF
      7  02d2				  -	      IF	$90 = $20
      8  02d2				  -	      .byte	$40+6
      9  02d2					      ENDIF
     10  02d2				  -	      IF	$90 = $30
     11  02d2				  -	      .byte	$40+6
     12  02d2					      ENDIF
     13  02d2				  -	      IF	$90 = $40
     14  02d2				  -	      .byte	$60+6
     15  02d2					      ENDIF
     16  02d2				  -	      IF	$90 = $50
     17  02d2				  -	      .byte	$80+6
     18  02d2					      ENDIF
     19  02d2				  -	      IF	$90 = $60
     20  02d2				  -	      .byte	$C0+6
     21  02d2					      ENDIF
     22  02d2				  -	      IF	$90 = $70
     23  02d2				  -	      .byte	$D0+6
     24  02d2					      ENDIF
     25  02d2				  -	      IF	$90 = $80
     26  02d2				  -	      .byte	$B0+6
     27  02d2					      ENDIF
     28  02d2					      IF	$90 = $90
     29  02d2		       96		      .byte.b	$90+6
     30  02d3					      ENDIF
     31  02d3				  -	      IF	$90 = $A0
     32  02d3				  -	      .byte	$70+6
     33  02d3					      ENDIF
     34  02d3				  -	      IF	$90 = $B0
     35  02d3				  -	      .byte	$50+6
     36  02d3					      ENDIF
     37  02d3				  -	      IF	$90 = $C0
     38  02d3				  -	      .byte	$30+6
     39  02d3					      ENDIF
     40  02d3				  -	      IF	$90 = $D0
     41  02d3				  -	      .byte	$30+6
     42  02d3					      ENDIF
     43  02d3				  -	      IF	$90 = $E0
     44  02d3				  -	      .byte	$20+6
     45  02d3					      ENDIF
     46  02d3				  -	      IF	$90 = $F0
     47  02d3				  -	      .byte	$40+6
     48  02d3					      ENDIF
      0  02d3					      NTSC_TO_PAL	$20, 6
      1  02d3				  -	      IF	$20 = 0
      2  02d3				  -	      .byte	$20+6
      3  02d3					      ENDIF
      4  02d3				  -	      IF	$20 = $10
      5  02d3				  -	      .byte	$20+6
      6  02d3					      ENDIF
      7  02d3					      IF	$20 = $20
      8  02d3		       46		      .byte.b	$40+6
      9  02d4					      ENDIF
     10  02d4				  -	      IF	$20 = $30
     11  02d4				  -	      .byte	$40+6
     12  02d4					      ENDIF
     13  02d4				  -	      IF	$20 = $40
     14  02d4				  -	      .byte	$60+6
     15  02d4					      ENDIF
     16  02d4				  -	      IF	$20 = $50
     17  02d4				  -	      .byte	$80+6
     18  02d4					      ENDIF
     19  02d4				  -	      IF	$20 = $60
     20  02d4				  -	      .byte	$C0+6
     21  02d4					      ENDIF
     22  02d4				  -	      IF	$20 = $70
     23  02d4				  -	      .byte	$D0+6
     24  02d4					      ENDIF
     25  02d4				  -	      IF	$20 = $80
     26  02d4				  -	      .byte	$B0+6
     27  02d4					      ENDIF
     28  02d4				  -	      IF	$20 = $90
     29  02d4				  -	      .byte	$90+6
     30  02d4					      ENDIF
     31  02d4				  -	      IF	$20 = $A0
     32  02d4				  -	      .byte	$70+6
     33  02d4					      ENDIF
     34  02d4				  -	      IF	$20 = $B0
     35  02d4				  -	      .byte	$50+6
     36  02d4					      ENDIF
     37  02d4				  -	      IF	$20 = $C0
     38  02d4				  -	      .byte	$30+6
     39  02d4					      ENDIF
     40  02d4				  -	      IF	$20 = $D0
     41  02d4				  -	      .byte	$30+6
     42  02d4					      ENDIF
     43  02d4				  -	      IF	$20 = $E0
     44  02d4				  -	      .byte	$20+6
     45  02d4					      ENDIF
     46  02d4				  -	      IF	$20 = $F0
     47  02d4				  -	      .byte	$40+6
     48  02d4					      ENDIF
     19  02d4		       00		      .byte.b	0
      0  02d5					      COLOUR_GROUP	$30,$A, $50,$8, $10,$C, $40,$4, $60,6, $E0,8	; 3
      1  02d5
      2  02d5		       00		      .byte.b	0
      3  02d6		       3a		      .byte.b	$30+$A
      4  02d7		       58		      .byte.b	$50+$8
      5  02d8		       1c		      .byte.b	$10+$C
      6  02d9		       44		      .byte.b	$40+$4
      7  02da		       66		      .byte.b	$60+6
      8  02db		       e8		      .byte.b	$E0+8
      9  02dc		       00		      .byte.b	0
     10  02dd
     11  02dd
     12  02dd		       00		      .byte.b	0
      0  02de					      NTSC_TO_PAL	$30, $A
      1  02de				  -	      IF	$30 = 0
      2  02de				  -	      .byte	$30+$A
      3  02de					      ENDIF
      4  02de				  -	      IF	$30 = $10
      5  02de				  -	      .byte	$20+$A
      6  02de					      ENDIF
      7  02de				  -	      IF	$30 = $20
      8  02de				  -	      .byte	$40+$A
      9  02de					      ENDIF
     10  02de					      IF	$30 = $30
     11  02de		       4a		      .byte.b	$40+$A
     12  02df					      ENDIF
     13  02df				  -	      IF	$30 = $40
     14  02df				  -	      .byte	$60+$A
     15  02df					      ENDIF
     16  02df				  -	      IF	$30 = $50
     17  02df				  -	      .byte	$80+$A
     18  02df					      ENDIF
     19  02df				  -	      IF	$30 = $60
     20  02df				  -	      .byte	$C0+$A
     21  02df					      ENDIF
     22  02df				  -	      IF	$30 = $70
     23  02df				  -	      .byte	$D0+$A
     24  02df					      ENDIF
     25  02df				  -	      IF	$30 = $80
     26  02df				  -	      .byte	$B0+$A
     27  02df					      ENDIF
     28  02df				  -	      IF	$30 = $90
     29  02df				  -	      .byte	$90+$A
     30  02df					      ENDIF
     31  02df				  -	      IF	$30 = $A0
     32  02df				  -	      .byte	$70+$A
     33  02df					      ENDIF
     34  02df				  -	      IF	$30 = $B0
     35  02df				  -	      .byte	$50+$A
     36  02df					      ENDIF
     37  02df				  -	      IF	$30 = $C0
     38  02df				  -	      .byte	$30+$A
     39  02df					      ENDIF
     40  02df				  -	      IF	$30 = $D0
     41  02df				  -	      .byte	$30+$A
     42  02df					      ENDIF
     43  02df				  -	      IF	$30 = $E0
     44  02df				  -	      .byte	$20+$A
     45  02df					      ENDIF
     46  02df				  -	      IF	$30 = $F0
     47  02df				  -	      .byte	$40+$A
     48  02df					      ENDIF
      0  02df					      NTSC_TO_PAL	$50, $8
      1  02df				  -	      IF	$50 = 0
      2  02df				  -	      .byte	$50+$8
      3  02df					      ENDIF
      4  02df				  -	      IF	$50 = $10
      5  02df				  -	      .byte	$20+$8
      6  02df					      ENDIF
      7  02df				  -	      IF	$50 = $20
      8  02df				  -	      .byte	$40+$8
      9  02df					      ENDIF
     10  02df				  -	      IF	$50 = $30
     11  02df				  -	      .byte	$40+$8
     12  02df					      ENDIF
     13  02df				  -	      IF	$50 = $40
     14  02df				  -	      .byte	$60+$8
     15  02df					      ENDIF
     16  02df					      IF	$50 = $50
     17  02df		       88		      .byte.b	$80+$8
     18  02e0					      ENDIF
     19  02e0				  -	      IF	$50 = $60
     20  02e0				  -	      .byte	$C0+$8
     21  02e0					      ENDIF
     22  02e0				  -	      IF	$50 = $70
     23  02e0				  -	      .byte	$D0+$8
     24  02e0					      ENDIF
     25  02e0				  -	      IF	$50 = $80
     26  02e0				  -	      .byte	$B0+$8
     27  02e0					      ENDIF
     28  02e0				  -	      IF	$50 = $90
     29  02e0				  -	      .byte	$90+$8
     30  02e0					      ENDIF
     31  02e0				  -	      IF	$50 = $A0
     32  02e0				  -	      .byte	$70+$8
     33  02e0					      ENDIF
     34  02e0				  -	      IF	$50 = $B0
     35  02e0				  -	      .byte	$50+$8
     36  02e0					      ENDIF
     37  02e0				  -	      IF	$50 = $C0
     38  02e0				  -	      .byte	$30+$8
     39  02e0					      ENDIF
     40  02e0				  -	      IF	$50 = $D0
     41  02e0				  -	      .byte	$30+$8
     42  02e0					      ENDIF
     43  02e0				  -	      IF	$50 = $E0
     44  02e0				  -	      .byte	$20+$8
     45  02e0					      ENDIF
     46  02e0				  -	      IF	$50 = $F0
     47  02e0				  -	      .byte	$40+$8
     48  02e0					      ENDIF
      0  02e0					      NTSC_TO_PAL	$10, $C
      1  02e0				  -	      IF	$10 = 0
      2  02e0				  -	      .byte	$10+$C
      3  02e0					      ENDIF
      4  02e0					      IF	$10 = $10
      5  02e0		       2c		      .byte.b	$20+$C
      6  02e1					      ENDIF
      7  02e1				  -	      IF	$10 = $20
      8  02e1				  -	      .byte	$40+$C
      9  02e1					      ENDIF
     10  02e1				  -	      IF	$10 = $30
     11  02e1				  -	      .byte	$40+$C
     12  02e1					      ENDIF
     13  02e1				  -	      IF	$10 = $40
     14  02e1				  -	      .byte	$60+$C
     15  02e1					      ENDIF
     16  02e1				  -	      IF	$10 = $50
     17  02e1				  -	      .byte	$80+$C
     18  02e1					      ENDIF
     19  02e1				  -	      IF	$10 = $60
     20  02e1				  -	      .byte	$C0+$C
     21  02e1					      ENDIF
     22  02e1				  -	      IF	$10 = $70
     23  02e1				  -	      .byte	$D0+$C
     24  02e1					      ENDIF
     25  02e1				  -	      IF	$10 = $80
     26  02e1				  -	      .byte	$B0+$C
     27  02e1					      ENDIF
     28  02e1				  -	      IF	$10 = $90
     29  02e1				  -	      .byte	$90+$C
     30  02e1					      ENDIF
     31  02e1				  -	      IF	$10 = $A0
     32  02e1				  -	      .byte	$70+$C
     33  02e1					      ENDIF
     34  02e1				  -	      IF	$10 = $B0
     35  02e1				  -	      .byte	$50+$C
     36  02e1					      ENDIF
     37  02e1				  -	      IF	$10 = $C0
     38  02e1				  -	      .byte	$30+$C
     39  02e1					      ENDIF
     40  02e1				  -	      IF	$10 = $D0
     41  02e1				  -	      .byte	$30+$C
     42  02e1					      ENDIF
     43  02e1				  -	      IF	$10 = $E0
     44  02e1				  -	      .byte	$20+$C
     45  02e1					      ENDIF
     46  02e1				  -	      IF	$10 = $F0
     47  02e1				  -	      .byte	$40+$C
     48  02e1					      ENDIF
      0  02e1					      NTSC_TO_PAL	$40, $4
      1  02e1				  -	      IF	$40 = 0
      2  02e1				  -	      .byte	$40+$4
      3  02e1					      ENDIF
      4  02e1				  -	      IF	$40 = $10
      5  02e1				  -	      .byte	$20+$4
      6  02e1					      ENDIF
      7  02e1				  -	      IF	$40 = $20
      8  02e1				  -	      .byte	$40+$4
      9  02e1					      ENDIF
     10  02e1				  -	      IF	$40 = $30
     11  02e1				  -	      .byte	$40+$4
     12  02e1					      ENDIF
     13  02e1					      IF	$40 = $40
     14  02e1		       64		      .byte.b	$60+$4
     15  02e2					      ENDIF
     16  02e2				  -	      IF	$40 = $50
     17  02e2				  -	      .byte	$80+$4
     18  02e2					      ENDIF
     19  02e2				  -	      IF	$40 = $60
     20  02e2				  -	      .byte	$C0+$4
     21  02e2					      ENDIF
     22  02e2				  -	      IF	$40 = $70
     23  02e2				  -	      .byte	$D0+$4
     24  02e2					      ENDIF
     25  02e2				  -	      IF	$40 = $80
     26  02e2				  -	      .byte	$B0+$4
     27  02e2					      ENDIF
     28  02e2				  -	      IF	$40 = $90
     29  02e2				  -	      .byte	$90+$4
     30  02e2					      ENDIF
     31  02e2				  -	      IF	$40 = $A0
     32  02e2				  -	      .byte	$70+$4
     33  02e2					      ENDIF
     34  02e2				  -	      IF	$40 = $B0
     35  02e2				  -	      .byte	$50+$4
     36  02e2					      ENDIF
     37  02e2				  -	      IF	$40 = $C0
     38  02e2				  -	      .byte	$30+$4
     39  02e2					      ENDIF
     40  02e2				  -	      IF	$40 = $D0
     41  02e2				  -	      .byte	$30+$4
     42  02e2					      ENDIF
     43  02e2				  -	      IF	$40 = $E0
     44  02e2				  -	      .byte	$20+$4
     45  02e2					      ENDIF
     46  02e2				  -	      IF	$40 = $F0
     47  02e2				  -	      .byte	$40+$4
     48  02e2					      ENDIF
      0  02e2					      NTSC_TO_PAL	$60, 6
      1  02e2				  -	      IF	$60 = 0
      2  02e2				  -	      .byte	$60+6
      3  02e2					      ENDIF
      4  02e2				  -	      IF	$60 = $10
      5  02e2				  -	      .byte	$20+6
      6  02e2					      ENDIF
      7  02e2				  -	      IF	$60 = $20
      8  02e2				  -	      .byte	$40+6
      9  02e2					      ENDIF
     10  02e2				  -	      IF	$60 = $30
     11  02e2				  -	      .byte	$40+6
     12  02e2					      ENDIF
     13  02e2				  -	      IF	$60 = $40
     14  02e2				  -	      .byte	$60+6
     15  02e2					      ENDIF
     16  02e2				  -	      IF	$60 = $50
     17  02e2				  -	      .byte	$80+6
     18  02e2					      ENDIF
     19  02e2					      IF	$60 = $60
     20  02e2		       c6		      .byte.b	$C0+6
     21  02e3					      ENDIF
     22  02e3				  -	      IF	$60 = $70
     23  02e3				  -	      .byte	$D0+6
     24  02e3					      ENDIF
     25  02e3				  -	      IF	$60 = $80
     26  02e3				  -	      .byte	$B0+6
     27  02e3					      ENDIF
     28  02e3				  -	      IF	$60 = $90
     29  02e3				  -	      .byte	$90+6
     30  02e3					      ENDIF
     31  02e3				  -	      IF	$60 = $A0
     32  02e3				  -	      .byte	$70+6
     33  02e3					      ENDIF
     34  02e3				  -	      IF	$60 = $B0
     35  02e3				  -	      .byte	$50+6
     36  02e3					      ENDIF
     37  02e3				  -	      IF	$60 = $C0
     38  02e3				  -	      .byte	$30+6
     39  02e3					      ENDIF
     40  02e3				  -	      IF	$60 = $D0
     41  02e3				  -	      .byte	$30+6
     42  02e3					      ENDIF
     43  02e3				  -	      IF	$60 = $E0
     44  02e3				  -	      .byte	$20+6
     45  02e3					      ENDIF
     46  02e3				  -	      IF	$60 = $F0
     47  02e3				  -	      .byte	$40+6
     48  02e3					      ENDIF
      0  02e3					      NTSC_TO_PAL	$E0, 8
      1  02e3				  -	      IF	$E0 = 0
      2  02e3				  -	      .byte	$E0+8
      3  02e3					      ENDIF
      4  02e3				  -	      IF	$E0 = $10
      5  02e3				  -	      .byte	$20+8
      6  02e3					      ENDIF
      7  02e3				  -	      IF	$E0 = $20
      8  02e3				  -	      .byte	$40+8
      9  02e3					      ENDIF
     10  02e3				  -	      IF	$E0 = $30
     11  02e3				  -	      .byte	$40+8
     12  02e3					      ENDIF
     13  02e3				  -	      IF	$E0 = $40
     14  02e3				  -	      .byte	$60+8
     15  02e3					      ENDIF
     16  02e3				  -	      IF	$E0 = $50
     17  02e3				  -	      .byte	$80+8
     18  02e3					      ENDIF
     19  02e3				  -	      IF	$E0 = $60
     20  02e3				  -	      .byte	$C0+8
     21  02e3					      ENDIF
     22  02e3				  -	      IF	$E0 = $70
     23  02e3				  -	      .byte	$D0+8
     24  02e3					      ENDIF
     25  02e3				  -	      IF	$E0 = $80
     26  02e3				  -	      .byte	$B0+8
     27  02e3					      ENDIF
     28  02e3				  -	      IF	$E0 = $90
     29  02e3				  -	      .byte	$90+8
     30  02e3					      ENDIF
     31  02e3				  -	      IF	$E0 = $A0
     32  02e3				  -	      .byte	$70+8
     33  02e3					      ENDIF
     34  02e3				  -	      IF	$E0 = $B0
     35  02e3				  -	      .byte	$50+8
     36  02e3					      ENDIF
     37  02e3				  -	      IF	$E0 = $C0
     38  02e3				  -	      .byte	$30+8
     39  02e3					      ENDIF
     40  02e3				  -	      IF	$E0 = $D0
     41  02e3				  -	      .byte	$30+8
     42  02e3					      ENDIF
     43  02e3					      IF	$E0 = $E0
     44  02e3		       28		      .byte.b	$20+8
     45  02e4					      ENDIF
     46  02e4				  -	      IF	$E0 = $F0
     47  02e4				  -	      .byte	$40+8
     48  02e4					      ENDIF
     19  02e4		       00		      .byte.b	0
    571  02e5
    572  02e5							;------------------------------------------------------------------------------
    573  02e5
    574  02e5							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    575  02e5
    576  02e5							;------------------------------------------------------------------------------
    577  02e5
    578  02e5
    579  02e5
    580  02e5
    581  02e5				   OBJTYPE    SET	0
    582  02e5					      MAC	define_character
    583  02e5				   CHARACTER_{1} =	OBJTYPE
    584  02e5				   OBJTYPE    .SET	OBJTYPE + 1
    585  02e5					      ENDM
    586  02e5
    587  02e5							; Modifications to character #/order must also ensure the following are correct...
    588  02e5							;   CharacterDataVecLO/HI	   in this file
    589  02e5							;   MoveVecLO/HI		   in BANK_INITBANK
    590  02e5							;   CharReplacement		   in BANK_ROM_SHADOW_DRAWBUFFERS
    591  02e5
      0  02e5					      DEFINE_CHARACTER	BLANK
      1  02e5		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	SOIL
      1  02e5		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	BOX
      1  02e5		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	TARGET
      1  02e5		       00 03	   CHARACTER_TARGET =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	TARGET2
      1  02e5		       00 04	   CHARACTER_TARGET2 =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	MANOCCUPIED
      1  02e5		       00 05	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	STEEL
      1  02e5		       00 06	   CHARACTER_STEEL =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	WALL
      1  02e5		       00 07	   CHARACTER_WALL =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	BOX_ON_TARGET
      1  02e5		       00 08	   CHARACTER_BOX_ON_TARGET =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	BOX_ON_TARGET2
      1  02e5		       00 09	   CHARACTER_BOX_ON_TARGET2 =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	NOGO
      1  02e5		       00 0a	   CHARACTER_NOGO =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	TARGET1
      1  02e5		       00 0b	   CHARACTER_TARGET1 =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	TARGET3
      1  02e5		       00 0c	   CHARACTER_TARGET3 =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	TARGET5
      1  02e5		       00 0d	   CHARACTER_TARGET5 =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e5					      DEFINE_CHARACTER	TARGET7
      1  02e5		       00 0e	   CHARACTER_TARGET7 =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
    607  02e5
    608  02e5				  -	      if	DIGITS
    609  02e5				  -	      DEFINE_CHARACTER	0
    610  02e5				  -	      DEFINE_CHARACTER	1
    611  02e5				  -	      DEFINE_CHARACTER	2
    612  02e5				  -	      DEFINE_CHARACTER	3
    613  02e5				  -	      DEFINE_CHARACTER	4
    614  02e5				  -	      DEFINE_CHARACTER	5
    615  02e5				  -	      DEFINE_CHARACTER	6
    616  02e5				  -	      DEFINE_CHARACTER	7
    617  02e5				  -	      DEFINE_CHARACTER	8
    618  02e5				  -	      DEFINE_CHARACTER	9
    619  02e5					      endif
    620  02e5
      0  02e5					      DEFINE_CHARACTER	MAXIMUM
      1  02e5		       00 0f	   CHARACTER_MAXIMUM =	OBJTYPE
      2  02e5				   OBJTYPE    .SET	OBJTYPE + 1
    622  02e5
    623  02e5
    624  02e5				   CharacterDataVecLO
    625  02e5
    626  02e5							; Two entries per character.  2nd is ptr to mirrored character
    627  02e5							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
    628  02e5
    629  02e5		       21		      .byte.b	<CHARACTERSHAPE_BLANK
    630  02e6		       21		      .byte.b	<CHARACTERSHAPE_BLANK
    631  02e7		       48		      .byte.b	<CHARACTERSHAPE_SOIL
    632  02e8		       48		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
    633  02e9		       60		      .byte.b	<CHARACTERSHAPE_BOX
    634  02ea		       78		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
    635  02eb		       18		      .byte.b	<CHARACTERSHAPE_TARGET
    636  02ec		       30		      .byte.b	<CHARACTERSHAPE_TARGET_MIRRORED
    637  02ed		       21		      .byte.b	<CHARACTERSHAPE_BLANK
    638  02ee		       21		      .byte.b	<CHARACTERSHAPE_BLANK
    639  02ef		       21		      .byte.b	<CHARACTERSHAPE_BLANK	; man occupied
    640  02f0		       21		      .byte.b	<CHARACTERSHAPE_BLANK
    641  02f1		       18		      .byte.b	<CHARACTERSHAPE_STEEL
    642  02f2		       30		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
    643  02f3		       00		      .byte.b	<CHARACTERSHAPE_WALL
    644  02f4		       18		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
    645  02f5		       90		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET
    646  02f6		       a8		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    647  02f7		       c0		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET2
    648  02f8		       d8		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED
    649  02f9		       21		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    650  02fa		       21		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    651  02fb		       48		      .byte.b	<CHARACTERSHAPE_TARGET1
    652  02fc		       60		      .byte.b	<CHARACTERSHAPE_TARGET1_MIRRORED
    653  02fd		       78		      .byte.b	<CHARACTERSHAPE_TARGET3
    654  02fe		       90		      .byte.b	<CHARACTERSHAPE_TARGET3_MIRRORED
    655  02ff		       a8		      .byte.b	<CHARACTERSHAPE_TARGET5
    656  0300		       c0		      .byte.b	<CHARACTERSHAPE_TARGET5_MIRRORED
    657  0301		       d8		      .byte.b	<CHARACTERSHAPE_TARGET7
    658  0302		       00		      .byte.b	<CHARACTERSHAPE_TARGET7_MIRRORED
    659  0303
    660  0303				  -	      if	DIGITS
    661  0303				  -	      .byte	<CHARACTERSHAPE_0, <CHARACTERSHAPE_0_MIRRORED
    662  0303				  -	      .byte	<CHARACTERSHAPE_1, <CHARACTERSHAPE_1_MIRRORED
    663  0303				  -	      .byte	<CHARACTERSHAPE_2, <CHARACTERSHAPE_2_MIRRORED
    664  0303				  -	      .byte	<CHARACTERSHAPE_3, <CHARACTERSHAPE_3_MIRRORED
    665  0303				  -	      .byte	<CHARACTERSHAPE_4, <CHARACTERSHAPE_4_MIRRORED
    666  0303				  -	      .byte	<CHARACTERSHAPE_5, <CHARACTERSHAPE_5_MIRRORED
    667  0303				  -	      .byte	<CHARACTERSHAPE_6, <CHARACTERSHAPE_6_MIRRORED
    668  0303				  -	      .byte	<CHARACTERSHAPE_7, <CHARACTERSHAPE_7_MIRRORED
    669  0303				  -	      .byte	<CHARACTERSHAPE_8, <CHARACTERSHAPE_8_MIRRORED
    670  0303				  -	      .byte	<CHARACTERSHAPE_9, <CHARACTERSHAPE_9_MIRRORED
    671  0303					      endif
    672  0303
    673  0303
    674  0303				  -	      IF	* - CharacterDataVecLO != CHARACTER_MAXIMUM*2
    675  0303				  -	      ECHO	"ERROR: Incorrect CharacterDataVecLO table!"
    676  0303				  -	      ERR
    677  0303					      ENDIF
    678  0303
    679  0303
    680  0303							;ds 20,0
    681  0303
    682  0303							;---------------------------------------------------------------------------
    683  0303
    684  0303				   CharacterDataVecHI
    685  0303
    686  0303		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    687  0304		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    688  0305		       fe		      .byte.b	>CHARACTERSHAPE_SOIL
    689  0306		       fe		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
    690  0307		       fe		      .byte.b	>CHARACTERSHAPE_BOX
    691  0308		       fe		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
    692  0309		       fd		      .byte.b	>CHARACTERSHAPE_TARGET
    693  030a		       fd		      .byte.b	>CHARACTERSHAPE_TARGET_MIRRORED
    694  030b		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    695  030c		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    696  030d		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; man occupied
    697  030e		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    698  030f		       fe		      .byte.b	>CHARACTERSHAPE_STEEL
    699  0310		       fe		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
    700  0311		       ff		      .byte.b	>CHARACTERSHAPE_WALL
    701  0312		       ff		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
    702  0313		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET
    703  0314		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    704  0315		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET2
    705  0316		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED
    706  0317		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    707  0318		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    708  0319		       fd		      .byte.b	>CHARACTERSHAPE_TARGET1
    709  031a		       fd		      .byte.b	>CHARACTERSHAPE_TARGET1_MIRRORED
    710  031b		       fd		      .byte.b	>CHARACTERSHAPE_TARGET3
    711  031c		       fd		      .byte.b	>CHARACTERSHAPE_TARGET3_MIRRORED
    712  031d		       fd		      .byte.b	>CHARACTERSHAPE_TARGET5
    713  031e		       fd		      .byte.b	>CHARACTERSHAPE_TARGET5_MIRRORED
    714  031f		       fd		      .byte.b	>CHARACTERSHAPE_TARGET7
    715  0320		       fe		      .byte.b	>CHARACTERSHAPE_TARGET7_MIRRORED
    716  0321
    717  0321				  -	      if	DIGITS
    718  0321				  -	      .byte	>CHARACTERSHAPE_0, >CHARACTERSHAPE_0_MIRRORED
    719  0321				  -	      .byte	>CHARACTERSHAPE_1, >CHARACTERSHAPE_1_MIRRORED
    720  0321				  -	      .byte	>CHARACTERSHAPE_2, >CHARACTERSHAPE_2_MIRRORED
    721  0321				  -	      .byte	>CHARACTERSHAPE_3, >CHARACTERSHAPE_3_MIRRORED
    722  0321				  -	      .byte	>CHARACTERSHAPE_4, >CHARACTERSHAPE_4_MIRRORED
    723  0321				  -	      .byte	>CHARACTERSHAPE_5, >CHARACTERSHAPE_5_MIRRORED
    724  0321				  -	      .byte	>CHARACTERSHAPE_6, >CHARACTERSHAPE_6_MIRRORED
    725  0321				  -	      .byte	>CHARACTERSHAPE_7, >CHARACTERSHAPE_7_MIRRORED
    726  0321				  -	      .byte	>CHARACTERSHAPE_8, >CHARACTERSHAPE_8_MIRRORED
    727  0321				  -	      .byte	>CHARACTERSHAPE_9, >CHARACTERSHAPE_9_MIRRORED
    728  0321					      endif
    729  0321
    730  0321
    731  0321				  -	      IF	* - CharacterDataVecHI != CHARACTER_MAXIMUM*2
    732  0321				  -	      ECHO	"ERROR: Incorrect CharacterDataVecHI table!"
    733  0321				  -	      ERR
    734  0321					      ENDIF
    735  0321
    736  0321
    737  0321							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    738  0321
    739  0321		       f3 39	   ShapePlayer =	PLAYER0_SHAPE	;BLANK
    740  0321		       f3 39	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    741  0321		       f3 39	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    742  0321		       f3 39	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    743  0321
    744  0321		       f3 21	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    745  0321		       f3 21	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    746  0321
    747  0321
    748  0321							; The following are the RAM buffers into which the player shape and colour data are copied
    749  0321							; The self-mod draw vectors point to this OR to a **blank** shape.
    750  0321
      0  0321					      OPTIONAL_PAGEBREAK	"PLAYER_BLANK", LINES_PER_CHAR
     10  0321					      LIST	ON
    752  0321				   PLAYER_BLANK
    753  0321		       00 00 00 00*	      ds	LINES_PER_CHAR, 0	; P1
      0  0339					      CHECKPAGEX	PLAYER_BLANK, "PLAYER_BLANK in BANK_ROM_SHADOW_RAMBANK.asm"
      9  0339					      LIST	ON
    755  0339
      0  0339					      OPTIONAL_PAGEBREAK	"PLAYER0_SHAPE", LINES_PER_CHAR
     10  0339					      LIST	ON
    757  0339				   PLAYER0_SHAPE
    758  0339		       00 00 00 00*	      ds	LINES_PER_CHAR,0
      0  0351					      CHECKPAGEX	PLAYER0_SHAPE, "PLAYER0_SHAPE in BANK_ROM_SHADOW_RAMBANK.asm"
      9  0351					      LIST	ON
    760  0351
      0  0351					      OPTIONAL_PAGEBREAK	"PLAYER0_COLOUR", LINES_PER_CHAR	; BOTH on same page
     10  0351					      LIST	ON
    762  0351				   PLAYER0_COLOUR
    763  0351		       00 00 00 00*	      ds	LINES_PER_CHAR,0
      0  0369					      CHECKPAGEX	PLAYER0_COLOUR, "PLAYER0_COLOUR in BANK_ROM_SHADOW_RAMBANK.asm"
      9  0369					      LIST	ON
    765  0369
    766  0369		       ff	   ExistingFrame .byte.b	-1
    767  036a		       ff	   LastYScroll .byte.b	-1
    768  036b		       14	   BandOffset .byte.b	20
    769  036c		       00	   PlatformBase .byte.b	0
    770  036d
    771  036d				   ColourBandsGreen
    772  036d
    773  036d							; NTSC...
    774  036d
    775  036d		       16 16		      ds	2,$16
    776  036f		       28 28		      ds	2,$28
    777  0371		       36 36 36 	      ds	3,$36
    778  0374		       48 48		      ds	2,$48
    779  0376		       58 58		      ds	2,$58
    780  0378		       68 68 68 	      ds	3,$68
    781  037b		       7a 7a		      ds	2,$7A
    782  037d		       8c 8c 8c 	      ds	3,$8C
    783  0380		       9a 9a		      ds	2,$9A
    784  0382		       aa aa		      ds	2,$AA
    785  0384		       b8 b8		      ds	2,$B8
    786  0386		       c8 c8		      ds	2,$C8
    787  0388		       d8 d8		      ds	2,$D8
    788  038a		       e8 e8 e8 	      ds	3,$E8
    789  038d							;ds 3,$F8
    790  038d
    791  038d							; PAL...
    792  038d
    793  038d		       28 28 28 	      ds	3,$28
    794  0390		       48 48		      ds	2,$48
    795  0392		       68 68 68 	      ds	3,$68
    796  0395		       88 88		      ds	2,$88
    797  0397		       a8 a8 a8 	      ds	3,$A8
    798  039a		       c8 c8 c8 	      ds	3,$C8
    799  039d		       d8 d8		      ds	2,$D8
    800  039f		       b8 b8 b8 	      ds	3,$B8
    801  03a2		       98 98 98 	      ds	3,$98
    802  03a5		       78 78		      ds	2,$78
    803  03a7		       58 58 58 	      ds	3,$58
    804  03aa		       38 38 38 	      ds	3,$38
    805  03ad
    806  03ad
    807  03ad
      0  03ad					      DEFINE_SUBROUTINE	FixColours
      1  03ad		       00 00	   BANK_FixColours =	_CURRENT_BANK
      2  03ad					      SUBROUTINE
      3  03ad				   FixColours
    809  03ad
    810  03ad
    811  03ad
    812  03ad		       a4 96		      ldy	BoardScrollY
    813  03af		       cc 6a f3 	      cpy	LastYScroll
    814  03b2		       f0 36		      beq	BandsNotChanged
    815  03b4		       8c 6a f7 	      sty	LastYScroll+RAM_WRITE
    816  03b7
    817  03b7		       a5 80		      lda	Platform
    818  03b9		       29 02		      and	#%10
    819  03bb		       0a		      asl
    820  03bc		       0a		      asl
    821  03bd		       0a		      asl
    822  03be		       0a		      asl
    823  03bf		       8d 6c f7 	      sta	PlatformBase+RAM_WRITE
    824  03c2
    825  03c2		       98		      tya
    826  03c3		       18		      clc
    827  03c4		       6d 6b f3 	      adc	BandOffset
    828  03c7		       29 1f		      and	#31
    829  03c9		       0d 6c f3 	      ora	PlatformBase
    830  03cc		       a8		      tay
    831  03cd
    832  03cd		       a2 00		      ldx	#0
    833  03cf		       ad 6c f3    LoopBankLines lda	PlatformBase
    834  03d2		       86 3e		      stx	SET_BANK_RAM
    835  03d4		       8d 6c f7 	      sta	PlatformBase+RAM_WRITE
    836  03d7
    837  03d7		       b9 6d f3 	      lda	ColourBandsGreen,y
    838  03da		       8d 86 f4 	      sta	SELFMOD_GREEN+RAM_WRITE+1
    839  03dd
    840  03dd		       c8		      iny
    841  03de		       98		      tya
    842  03df		       29 1f		      and	#31
    843  03e1		       0d 6c f3 	      ora	PlatformBase
    844  03e4		       a8		      tay
    845  03e5
    846  03e5		       e8		      inx
    847  03e6		       e0 08		      cpx	#SCREEN_LINES
    848  03e8		       90 e5		      bcc	LoopBankLines
    849  03ea
    850  03ea		       60	   BandsNotChanged rts
    851  03eb
    852  03eb
      0  03eb					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- 1K"
      1  03eb
      2  03eb
      3  03eb		       03 eb	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- 1K (1K) SIZE =  $3eb , FREE= $15
      4  03eb					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  03eb				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  03eb				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  03eb				  -	      ERR
      8  03eb					      endif
    854  03eb
    855  03eb							; Here there's another 1K of usable ROM....
    856  03eb							; Anything here is ONLY accessible if the bank is switched in as a ROM bank
    857  03eb							; WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    858  03eb
      0  03eb					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  03eb		       03 eb	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $3eb , FREE= $415
      2  03eb					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  03eb				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  03eb				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  03eb				  -	      ERR
      6  03eb					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 3
      0  03eb					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  03eb							;    Sokoboo - a Sokoban implementation
      2  03eb							;    using a generic tile-based display engine for the Atari 2600
      3  03eb							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  03eb							;
      5  03eb							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  03eb							;
      7  03eb							;    Code related to the generic tile-based display engine was developed by
      8  03eb							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  03eb							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  03eb							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  03eb							;
     12  03eb							;    Code related to music and sound effects uses the TIATracker music player
     13  03eb							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  03eb							;    directory for Apache licensing details.
     15  03eb							;
     16  03eb							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  03eb							;    See the copyright notices in the License directory for a list of level
     18  03eb							;    contributors.
     19  03eb							;
     20  03eb							;    Except where otherwise indicated, this software is released under the
     21  03eb							;    following licensing arrangement...
     22  03eb							;
     23  03eb							;    This program is free software: you can redistribute it and/or modify
     24  03eb							;    it under the terms of the GNU General Public License as published by
     25  03eb							;    the Free Software Foundation, either version 3 of the License, or
     26  03eb							;    (at your option) any later version.
     27  03eb							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  03eb
     29  03eb							;    This program is distributed in the hope that it will be useful,
     30  03eb							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  03eb							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  03eb							;    GNU General Public License for more details.
     33  03eb
     34  03eb							;------------------------------------------------------------------------------
     35  03eb							;##############################################################################
     36  03eb							;------------------------------------------------------------------------------
     37  03eb
      0  03eb					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  0a50 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
     39  0800
     40  0800							; NOTE: Access to these buffers must NOT overlap pages...
     41  0800							; NOTE: We get auto-initialisation of these variables from the ROM values by
     42  0800							; copying the whole bank into the RAM bank.  Neato.
     43  0800
     44  0800		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     45  0800
     46  0800
     47  0800
     48  0800		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     49  0850		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     50  08a0
      0  08a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  08a0					      LIST	ON
     52  08a0
     53  08a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     54  08a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     55  08a0							; what we want to happen!
     56  08a0
     57  08a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
      0  08f0					      CHECKPAGEX	ScreenBuffer, "ScreenBuffer"
      9  08f0					      LIST	ON
     59  08f0
     60  08f0							;------------------------------------------------------------------------------
     61  08f0							; RAM-BASED SUBROUTINES...
     62  08f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     63  08f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     64  08f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     65  08f0							; the RAM-based routine.
     66  08f0
     67  08f0
     68  08f0
     69  08f0							;------------------------------------------------------------------------------
     70  08f0
     71  08f0
     72  08f0		       60	   waitForDraw rts		; 6
     73  08f1
     74  08f1							;------------------------------------------------------------------------------
     75  08f1
      0  08f1					      DEFINE_SUBROUTINE	DrawStackUpdate	; @39✅
      1  08f1		       00 01	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  08f1					      SUBROUTINE
      3  08f1				   DrawStackUpdate
     77  08f1
     78  08f1							; Parse the DrawFlags buffer and create a draw stack
     79  08f1							; so that the actual draw doesn't need to scan for characters to draw.
     80  08f1
     81  08f1
     82  08f1							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     83  08f1							; symptoms would be missing parts of screen when scrolling.
     84  08f1							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     85  08f1							; disabled for sokoban 27/7/2019
     86  08f1
     87  08f1							;lda DrawStackPointer
     88  08f1							;bpl waitForDraw		  ; Wait for previously not-drawn characters to be drawn
     89  08f1
     90  08f1		       ad 84 02 	      lda	INTIM	;4
     91  08f4		       c9 03		      cmp	#SEGTIME_BDS	;2
     92  08f6		       90 f8		      bcc	waitForDraw	;2/3
     93  08f8							; =>[39]+(9)+6rts = 54✅ when exit
     94  08f8
     95  08f8							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
     96  08f8							; moving into the middle of dirt, or BOXs when pushing, or TARGETs when grabbing.
     97  08f8
     98  08f8							;		  sec		 already set
     99  08f8		       a5 9e		      lda	ManY	;3
    100  08fa		       e5 96		      sbc	BoardScrollY	;3
    101  08fc		       c9 08		      cmp	#SCREEN_LINES
    102  08fe		       b0 0b		      bcs	offy
    103  0900		       85 a0		      sta	ManDrawY	;3 = 9✅
    104  0902
    105  0902		       38		      sec		;2
    106  0903		       a5 9d		      lda	ManX	;3
    107  0905		       e5 97		      sbc	BoardScrollX	;3
    108  0907		       c9 0a		      cmp	#SCREEN_WIDTH	;2
    109  0909		       90 06		      bcc	onsc	;2/3 = 12(13)✅
    110  090b
    111  090b							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
    112  090b							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
    113  090b							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
    114  090b
    115  090b		       a9 ff	   offy       lda	#-1	;SCREEN_LINES		     ;2
    116  090d		       85 a0		      sta	ManDrawY	;3
    117  090f		       d0 02		      bne	offsc
    118  0911
    119  0911		       85 9f	   onsc       sta	ManDrawX	;3
    120  0913				   offsc
    121  0913
    122  0913							;32✅ worst
    123  0913
      0  0913					      DEFINE_SUBROUTINE	AnimateCharReplacements2	; =38
      1  0913		       00 01	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  0913					      SUBROUTINE
      3  0913				   AnimateCharReplacements2
    125  0913
    126  0913							; This manages character animation on a per-object basis.  Morph/animate these characters
    127  0913							; individually or as required.  Change will affect all characters of the same type in the
    128  0913							; visible display.
    129  0913
    130  0913		       e6 c6		      inc	animate_char_index	; 5
    131  0915		       a5 c6		      lda	animate_char_index	; 3
    132  0917		       4a		      lsr		; 2
    133  0918		       29 03		      and	#3	; 2
    134  091a		       aa		      tax		; 2 = 14
    135  091b
    136  091b		       bd ea f1 	      lda	targetReplaceChar,x	; 4
    137  091e		       8d de f5 	      sta	ANIM_TARGET + RAM_WRITE	; 4 = 8
    138  0921							;lda targetReplaceChar2,x	      ; 4
    139  0921							;sta ANIM_TARGET2 + RAM_WRITE	      ; 4
    140  0921
    141  0921							;@54 worst
    142  0921
    143  0921		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
    144  0923		       85 c4		      sta	DSL	;3
    145  0925
    146  0925		       e6 86		      inc	ScreenDrawPhase	;5
    147  0927		       60		      rts		; 6 TEST allows segtime test to be smaller on next part
    148  0928							; ==> @70 worst
    149  0928
    150  0928							;---------------------------------------------------------------------------
    151  0928
      0  0928					      DEFINE_SUBROUTINE	DrawIntoStack	; @39✅
      1  0928		       00 01	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  0928					      SUBROUTINE
      3  0928				   DrawIntoStack
    153  0928
    154  0928		       ba		      tsx		; 2
    155  0929		       86 d7		      stx	save_SP	; 3
    156  092b		       a6 81		      ldx	DrawStackPointer	; 3
    157  092d		       9a		      txs		; 2 = 10
    158  092e
    159  092e		       a4 c4		      ldy	DSL	; 3
    160  0930
    161  0930							; @ 52✅
    162  0930
    163  0930							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    164  0930							; + exit cost which is +10 cycles
    165  0930							; TJ: I count 63
    166  0930							;   + 14 for the wtf2 exit
    167  0930							;   + 22 for the end of loop exit
    168  0930
    169  0930							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    170  0930							; For 80 iterations that is 640 cycles, just for checking INTIM
    171  0930							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    172  0930							; it also will require a lot of CPU time for updating the screen data.
    173  0930
    174  0930							; TODO: optimize!
    175  0930							;
    176  0930							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    177  0930							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    178  0930							; costs some detection time here, but saves ~240 cylces for drawing the two
    179  0930
    180  0930				   .loopDrawStack		; @100✅ from bottom of loop
    181  0930
    182  0930		       ad 84 02 	      lda	INTIM	; 4
    183  0933		       c9 04		      cmp	#SEGTIME_DSL	; 2
    184  0935		       90 4b		      bcc	.exitDrawStack	; 2(3)  + [costs 18 more to exit fully at .exit..]
    185  0937							; => full exit on 1st pass = 78✅ cycles
    186  0937							; => full exit on a single loop = 127✅ cycles
    187  0937
    188  0937							; @0✅
    189  0937
    190  0937		       b9 50 f0 	      lda	DrawFlag,y	; 4
    191  093a		       d9 a0 f0 	      cmp	ScreenBuffer,y	; 4		  Is the character already there the same as the new one?
    192  093d		       f0 16		      beq	.next0	; 2/3=10/11	  yes, so we don't draw anything
    193  093f							; @10✅
    194  093f
    195  093f							; Character is NOT the same. Figure out how it should be drawn.
    196  093f							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    197  093f							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    198  093f							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    199  093f
    200  093f		       be 8b f1 	      ldx	PairedCharacter,y	; 4		  the "paired" character for this one
    201  0942		       dd 50 f0 	      cmp	DrawFlag,x	; 4		  same as partner character in new drawn screen?
    202  0945		       d0 05		      bne	.notPaired0	; 2(3)
    203  0947							; @20✅
    204  0947
    205  0947							; Consider two 'paired' characters. Either A:A or A:B
    206  0947							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    207  0947							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    208  0947							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    209  0947							; on the comparison, so the character will not be added to the draw stack. So our first character will
    210  0947							; do the job of drawing BOTH characters to the screen.
    211  0947
    212  0947		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 5		  mark paired character as drawn already (!!)
    213  094a		       09 80		      ora	#$80	; 2 =	7	  DirectDraw this character 'pair'
    214  094c							; @27✅
    215  094c							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    216  094c							; the last write(below) marks the character as to be direct-drawn.
    217  094c
    218  094c				   .notPaired0		; @27✅ worst
    219  094c
    220  094c		       99 a0 f4 	      sta	ScreenBuffer+RAM_WRITE,y	; 5		  NEW character to draw + DirectDraw flag (128)
    221  094f
    222  094f							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    223  094f
    224  094f		       68		      pla		; 4		  ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    225  0950		       98		      tya		; 2
    226  0951		       ba		      tsx		; 2		  << now X holds drawstackpointer
    227  0952		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	; 5 = 18	  index of character to draw
    228  0955
    229  0955		       88	   .next0     dey		; 2
    230  0956		       30 21		      bmi	.finishedDrawStack	; 2(3)= 4/5
    231  0958							; @50✅
    232  0958							; unrolled 2nd loop:
    233  0958		       b9 50 f0 	      lda	DrawFlag,y	; 4
    234  095b		       d9 a0 f0 	      cmp	ScreenBuffer,y	; 4		  Is the character already there the same as the new one?
    235  095e		       f0 16		      beq	.next1	; 2(3) 	  yes, so we don't draw anything
    236  0960
    237  0960		       be 8b f1 	      ldx	PairedCharacter,y	; 4		  the "paired" character for this one
    238  0963		       dd 50 f0 	      cmp	DrawFlag,x	; 4		  same as partner character in new drawn screen?
    239  0966		       d0 05		      bne	.notPaired1	; 2(3)
    240  0968
    241  0968		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 5		  mark paired character as drawn already (!!)
    242  096b		       09 80		      ora	#$80	; 2 =	7	  DirectDraw this character 'pair'
    243  096d
    244  096d				   .notPaired1		; @77✅ worst
    245  096d
    246  096d		       99 a0 f4 	      sta	ScreenBuffer+RAM_WRITE,y	; 5		  NEW character to draw + DirectDraw flag (128)
    247  0970
    248  0970		       68		      pla		; 4		  ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    249  0971		       98		      tya		; 2
    250  0972		       ba		      tsx		; 2
    251  0973		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	; 5 = 18	  index of character to draw
    252  0976							; @95✅
    253  0976
    254  0976		       88	   .next1     dey		; 2
    255  0977		       10 b7		      bpl	.loopDrawStack	; 2(3)
    256  0979							; @100✅ --> @.loopDrawStack
    257  0979
    258  0979							;worst case: 111-4
    259  0979							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    260  0979
    261  0979							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    262  0979
    263  0979				   .finishedDrawStack
    264  0979		       e6 86		      inc	ScreenDrawPhase	;5 =  5
    265  097b		       ba		      tsx		;2
    266  097c		       86 81		      stx	DrawStackPointer	;3
    267  097e
    268  097e		       a6 d7		      ldx	save_SP	;3
    269  0980		       9a		      txs		;2 = 10
    270  0981		       60		      rts		;6 =  6
    271  0982
    272  0982				   .exitDrawStack
    273  0982		       84 c4		      sty	DSL	;3 =  3
    274  0984		       ba		      tsx		;2
    275  0985		       86 81		      stx	DrawStackPointer	;3
    276  0987		       a6 d7		      ldx	save_SP	;3
    277  0989		       9a		      txs		;2 = 10
    278  098a		       60		      rts		;6 =  6
    279  098b
    280  098b				   PairedCharacter
    281  098b
    282  098b				   SOFF       SET	0
    283  098b					      REPEAT	SCREEN_LINES
    284  098b		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    285  098b				   SOFF       SET	SOFF + SCREEN_WIDTH
    283  098b					      REPEND
    284  0995		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    285  0995				   SOFF       SET	SOFF + SCREEN_WIDTH
    283  0995					      REPEND
    284  099f		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    285  099f				   SOFF       SET	SOFF + SCREEN_WIDTH
    283  099f					      REPEND
    284  09a9		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    285  09a9				   SOFF       SET	SOFF + SCREEN_WIDTH
    283  09a9					      REPEND
    284  09b3		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    285  09b3				   SOFF       SET	SOFF + SCREEN_WIDTH
    283  09b3					      REPEND
    284  09bd		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    285  09bd				   SOFF       SET	SOFF + SCREEN_WIDTH
    283  09bd					      REPEND
    284  09c7		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    285  09c7				   SOFF       SET	SOFF + SCREEN_WIDTH
    283  09c7					      REPEND
    284  09d1		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    285  09d1				   SOFF       SET	SOFF + SCREEN_WIDTH
    286  09db					      REPEND
    287  09db
    288  09db							;------------------------------------------------------------------------------
    289  09db							; Gives character replacements used during screen drawing.
    290  09db							; The character from the board is morphed via this array into an actual character
    291  09db							; to draw.  This allows global animation and replacment of characters without
    292  09db							; individual objects needing to do this.  Note, the draw-time replacement happens,
    293  09db							; not board-time.
    294  09db
    295  09db				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    296  09db
    297  09db							; Converts a character # to an animated creature type
    298  09db							; The array is indexed by CHARACTER_...
    299  09db
    300  09db		       00		      .byte.b	CHARACTER_BLANK	;  0
    301  09dc		       01		      .byte.b	CHARACTER_SOIL	;  1
    302  09dd		       02		      .byte.b	CHARACTER_BOX	;  2
    303  09de		       03	   ANIM_TARGET .byte.b	CHARACTER_TARGET	;  3  XOR'd to give flashing target squares
    304  09df		       04		      .byte.b	CHARACTER_TARGET2	;  4
    305  09e0		       05		      .byte.b	CHARACTER_MANOCCUPIED	;  5
    306  09e1		       06		      .byte.b	CHARACTER_STEEL	;  6
    307  09e2		       07		      .byte.b	CHARACTER_WALL	;  7
    308  09e3		       08	   ANIM_TARGET2 .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    309  09e4		       09		      .byte.b	CHARACTER_BOX_ON_TARGET2
    310  09e5		       00		      .byte.b	CHARACTER_BLANK	;  9
    311  09e6		       0b		      .byte.b	CHARACTER_TARGET1
    312  09e7		       0c		      .byte.b	CHARACTER_TARGET3
    313  09e8		       0d		      .byte.b	CHARACTER_TARGET5
    314  09e9		       0e		      .byte.b	CHARACTER_TARGET7
    315  09ea
    316  09ea				  -	      if	DIGITS
    317  09ea				  -	      .byte	CHARACTER_0
    318  09ea				  -	      .byte	CHARACTER_1
    319  09ea				  -	      .byte	CHARACTER_2
    320  09ea				  -	      .byte	CHARACTER_3
    321  09ea				  -	      .byte	CHARACTER_4
    322  09ea				  -	      .byte	CHARACTER_5
    323  09ea				  -	      .byte	CHARACTER_6
    324  09ea				  -	      .byte	CHARACTER_7
    325  09ea				  -	      .byte	CHARACTER_8
    326  09ea				  -	      .byte	CHARACTER_9
    327  09ea					      endif
    328  09ea
    329  09ea				  -	      IF	(* - CharReplacement != CHARACTER_MAXIMUM)
    330  09ea				  -	      ECHO	"ERROR: Incorrect CharReplacement table!"
    331  09ea				  -	      ERR
    332  09ea					      ENDIF
      0  09ea					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  09ea					      LIST	ON
    334  09ea
    335  09ea
    336  09ea
    337  09ea				   targetReplaceChar
    338  09ea		       03		      .byte.b	CHARACTER_TARGET
    339  09eb		       0b		      .byte.b	CHARACTER_TARGET1
    340  09ec		       04		      .byte.b	CHARACTER_TARGET2
    341  09ed		       0c		      .byte.b	CHARACTER_TARGET3
    342  09ee
    343  09ee							;targetReplaceChar2
    344  09ee							;    .byte CHARACTER_BOX
    345  09ee							;    .byte CHARACTER_BOX
    346  09ee							;    .byte CHARACTER_BOX_ON_TARGET
    347  09ee							;    .byte CHARACTER_BOX_ON_TARGET
    348  09ee
    349  09ee							;------------------------------------------------------------------------------
    350  09ee
    351  09ee
      0  09ee					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
 PAGE BREAK INSERTED FOR  ROW_BankChar
 REQUESTED SIZE =  $50
 WASTED SPACE =  $12
 PAGEBREAK LOCATION =  $f200
     10  0a00					      LIST	ON
      0  0a00					      DEFINE_SUBROUTINE	ROW_BankChar
      1  0a00		       00 01	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  0a00					      SUBROUTINE
      3  0a00				   ROW_BankChar
    354  0a00
    355  0a00				   .BANK      SET	BANK_SCREENMARKII1
    356  0a00					      REPEAT	SCREEN_LINES
    357  0a00					      REPEAT	SCREEN_WIDTH
    358  0a00		       00		      .byte.b	.BANK
    357  0a00					      REPEND
    358  0a01		       00		      .byte.b	.BANK
    357  0a01					      REPEND
    358  0a02		       00		      .byte.b	.BANK
    357  0a02					      REPEND
    358  0a03		       00		      .byte.b	.BANK
    357  0a03					      REPEND
    358  0a04		       00		      .byte.b	.BANK
    357  0a04					      REPEND
    358  0a05		       00		      .byte.b	.BANK
    357  0a05					      REPEND
    358  0a06		       00		      .byte.b	.BANK
    357  0a06					      REPEND
    358  0a07		       00		      .byte.b	.BANK
    357  0a07					      REPEND
    358  0a08		       00		      .byte.b	.BANK
    357  0a08					      REPEND
    358  0a09		       00		      .byte.b	.BANK
    359  0a0a					      REPEND
    360  0a0a				   .BANK      SET	.BANK + 1
    356  0a0a					      REPEND
    357  0a0a					      REPEAT	SCREEN_WIDTH
    358  0a0a		       01		      .byte.b	.BANK
    357  0a0a					      REPEND
    358  0a0b		       01		      .byte.b	.BANK
    357  0a0b					      REPEND
    358  0a0c		       01		      .byte.b	.BANK
    357  0a0c					      REPEND
    358  0a0d		       01		      .byte.b	.BANK
    357  0a0d					      REPEND
    358  0a0e		       01		      .byte.b	.BANK
    357  0a0e					      REPEND
    358  0a0f		       01		      .byte.b	.BANK
    357  0a0f					      REPEND
    358  0a10		       01		      .byte.b	.BANK
    357  0a10					      REPEND
    358  0a11		       01		      .byte.b	.BANK
    357  0a11					      REPEND
    358  0a12		       01		      .byte.b	.BANK
    357  0a12					      REPEND
    358  0a13		       01		      .byte.b	.BANK
    359  0a14					      REPEND
    360  0a14				   .BANK      SET	.BANK + 1
    356  0a14					      REPEND
    357  0a14					      REPEAT	SCREEN_WIDTH
    358  0a14		       02		      .byte.b	.BANK
    357  0a14					      REPEND
    358  0a15		       02		      .byte.b	.BANK
    357  0a15					      REPEND
    358  0a16		       02		      .byte.b	.BANK
    357  0a16					      REPEND
    358  0a17		       02		      .byte.b	.BANK
    357  0a17					      REPEND
    358  0a18		       02		      .byte.b	.BANK
    357  0a18					      REPEND
    358  0a19		       02		      .byte.b	.BANK
    357  0a19					      REPEND
    358  0a1a		       02		      .byte.b	.BANK
    357  0a1a					      REPEND
    358  0a1b		       02		      .byte.b	.BANK
    357  0a1b					      REPEND
    358  0a1c		       02		      .byte.b	.BANK
    357  0a1c					      REPEND
    358  0a1d		       02		      .byte.b	.BANK
    359  0a1e					      REPEND
    360  0a1e				   .BANK      SET	.BANK + 1
    356  0a1e					      REPEND
    357  0a1e					      REPEAT	SCREEN_WIDTH
    358  0a1e		       03		      .byte.b	.BANK
    357  0a1e					      REPEND
    358  0a1f		       03		      .byte.b	.BANK
    357  0a1f					      REPEND
    358  0a20		       03		      .byte.b	.BANK
    357  0a20					      REPEND
    358  0a21		       03		      .byte.b	.BANK
    357  0a21					      REPEND
    358  0a22		       03		      .byte.b	.BANK
    357  0a22					      REPEND
    358  0a23		       03		      .byte.b	.BANK
    357  0a23					      REPEND
    358  0a24		       03		      .byte.b	.BANK
    357  0a24					      REPEND
    358  0a25		       03		      .byte.b	.BANK
    357  0a25					      REPEND
    358  0a26		       03		      .byte.b	.BANK
    357  0a26					      REPEND
    358  0a27		       03		      .byte.b	.BANK
    359  0a28					      REPEND
    360  0a28				   .BANK      SET	.BANK + 1
    356  0a28					      REPEND
    357  0a28					      REPEAT	SCREEN_WIDTH
    358  0a28		       04		      .byte.b	.BANK
    357  0a28					      REPEND
    358  0a29		       04		      .byte.b	.BANK
    357  0a29					      REPEND
    358  0a2a		       04		      .byte.b	.BANK
    357  0a2a					      REPEND
    358  0a2b		       04		      .byte.b	.BANK
    357  0a2b					      REPEND
    358  0a2c		       04		      .byte.b	.BANK
    357  0a2c					      REPEND
    358  0a2d		       04		      .byte.b	.BANK
    357  0a2d					      REPEND
    358  0a2e		       04		      .byte.b	.BANK
    357  0a2e					      REPEND
    358  0a2f		       04		      .byte.b	.BANK
    357  0a2f					      REPEND
    358  0a30		       04		      .byte.b	.BANK
    357  0a30					      REPEND
    358  0a31		       04		      .byte.b	.BANK
    359  0a32					      REPEND
    360  0a32				   .BANK      SET	.BANK + 1
    356  0a32					      REPEND
    357  0a32					      REPEAT	SCREEN_WIDTH
    358  0a32		       05		      .byte.b	.BANK
    357  0a32					      REPEND
    358  0a33		       05		      .byte.b	.BANK
    357  0a33					      REPEND
    358  0a34		       05		      .byte.b	.BANK
    357  0a34					      REPEND
    358  0a35		       05		      .byte.b	.BANK
    357  0a35					      REPEND
    358  0a36		       05		      .byte.b	.BANK
    357  0a36					      REPEND
    358  0a37		       05		      .byte.b	.BANK
    357  0a37					      REPEND
    358  0a38		       05		      .byte.b	.BANK
    357  0a38					      REPEND
    358  0a39		       05		      .byte.b	.BANK
    357  0a39					      REPEND
    358  0a3a		       05		      .byte.b	.BANK
    357  0a3a					      REPEND
    358  0a3b		       05		      .byte.b	.BANK
    359  0a3c					      REPEND
    360  0a3c				   .BANK      SET	.BANK + 1
    356  0a3c					      REPEND
    357  0a3c					      REPEAT	SCREEN_WIDTH
    358  0a3c		       06		      .byte.b	.BANK
    357  0a3c					      REPEND
    358  0a3d		       06		      .byte.b	.BANK
    357  0a3d					      REPEND
    358  0a3e		       06		      .byte.b	.BANK
    357  0a3e					      REPEND
    358  0a3f		       06		      .byte.b	.BANK
    357  0a3f					      REPEND
    358  0a40		       06		      .byte.b	.BANK
    357  0a40					      REPEND
    358  0a41		       06		      .byte.b	.BANK
    357  0a41					      REPEND
    358  0a42		       06		      .byte.b	.BANK
    357  0a42					      REPEND
    358  0a43		       06		      .byte.b	.BANK
    357  0a43					      REPEND
    358  0a44		       06		      .byte.b	.BANK
    357  0a44					      REPEND
    358  0a45		       06		      .byte.b	.BANK
    359  0a46					      REPEND
    360  0a46				   .BANK      SET	.BANK + 1
    356  0a46					      REPEND
    357  0a46					      REPEAT	SCREEN_WIDTH
    358  0a46		       07		      .byte.b	.BANK
    357  0a46					      REPEND
    358  0a47		       07		      .byte.b	.BANK
    357  0a47					      REPEND
    358  0a48		       07		      .byte.b	.BANK
    357  0a48					      REPEND
    358  0a49		       07		      .byte.b	.BANK
    357  0a49					      REPEND
    358  0a4a		       07		      .byte.b	.BANK
    357  0a4a					      REPEND
    358  0a4b		       07		      .byte.b	.BANK
    357  0a4b					      REPEND
    358  0a4c		       07		      .byte.b	.BANK
    357  0a4c					      REPEND
    358  0a4d		       07		      .byte.b	.BANK
    357  0a4d					      REPEND
    358  0a4e		       07		      .byte.b	.BANK
    357  0a4e					      REPEND
    358  0a4f		       07		      .byte.b	.BANK
    359  0a50					      REPEND
    360  0a50				   .BANK      SET	.BANK + 1
    361  0a50					      REPEND
    362  0a50
      0  0a50					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  0a50
      2  0a50
      3  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $250 , FREE= $1b0
      4  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0a50				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0a50				  -	      ERR
      8  0a50					      endif
    364  0a50
    365  0a50
      0  0a50					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $250 , FREE= $5b0
      2  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0a50				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0a50				  -	      ERR
      6  0a50					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 3
      0  0a50					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  0a50							;    Sokoboo - a Sokoban implementation
      2  0a50							;    using a generic tile-based display engine for the Atari 2600
      3  0a50							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0a50							;
      5  0a50							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0a50							;
      7  0a50							;    Code related to the generic tile-based display engine was developed by
      8  0a50							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0a50							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0a50							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0a50							;
     12  0a50							;    Code related to music and sound effects uses the TIATracker music player
     13  0a50							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0a50							;    directory for Apache licensing details.
     15  0a50							;
     16  0a50							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0a50							;    See the copyright notices in the License directory for a list of level
     18  0a50							;    contributors.
     19  0a50							;
     20  0a50							;    Except where otherwise indicated, this software is released under the
     21  0a50							;    following licensing arrangement...
     22  0a50							;
     23  0a50							;    This program is free software: you can redistribute it and/or modify
     24  0a50							;    it under the terms of the GNU General Public License as published by
     25  0a50							;    the Free Software Foundation, either version 3 of the License, or
     26  0a50							;    (at your option) any later version.
     27  0a50							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0a50
     29  0a50							;    This program is distributed in the hope that it will be useful,
     30  0a50							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0a50							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0a50							;    GNU General Public License for more details.
     33  0a50
     34  0a50							;------------------------------------------------------------------------------
     35  0a50							;##############################################################################
     36  0a50							;------------------------------------------------------------------------------
      0  0a50					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  139d ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
     38  1000
     39  1000
     40  1000		       00 9a	   SCORE_COL  =	$9a	;WHITE ;-2
     41  1000		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     42  1000		       00 66	   SCORE_COL_HIGH_PAL =	$66
     43  1000
     44  1000
     45  1000				   DigitVectorLOr
     46  1000		       31 3f 4d 38*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     47  100a		       00 07 0e 15	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     48  100e				   DigitVectorLO
     49  100e		       53 61 6e 5a*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     50  1018		       37		      .byte.b	<BLANKL-1
     51  1019
     52  1019
     53  1019		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     54  1019		       00 0b	   ID_TARGET  =	11
     55  1019		       00 0c	   ID_EXTRA   =	12
     56  1019		       00 0d	   ID_CLOCK   =	13
     57  1019		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     58  1019
     59  1019							; score patch adresses:
     60  1019				   SMTblLSB
     61  1019				   SMTblTargets
     62  1019		       52 48		      .byte.b	SM_TARGET0+1-SM_BASE, SM_TARGET2+1-SM_BASE
     63  101b				   SMTblTime
     64  101b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     65  101d				   SMTblScore
     66  101d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     67  1020				   SMTblMSB
     68  1020		       4d 43		      .byte.b	SM_TARGET1+1-SM_BASE, SM_TARGET3+1-SM_BASE
     69  1022		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     70  1024		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     71  1027
     72  1027		       00 00	   SM_OFS_TARGETS =	SMTblTargets - SMTblLSB
     73  1027		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     74  1027		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     75  1027
     76  1027				   CharVectorLO
     77  1027		       37		      .byte.b	<BLANKL-1
     78  1028		       ad ad ad ad	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     79  102c		       ad ad ad ad	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     80  1030		       ad ad ad ad	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     81  1034		       ad ad ad ad	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     82  1038							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     83  1038
     84  1038							; Digit shape definitions are at start of bank so that we don't have page boundary
     85  1038							; crossing issues.
     86  1038
     87  1038							;	  .byte 0	      ; required!
     88  1038
     89  1038		       00 07	   DIGIT_H    =	7	; height of a score digit
     90  1038
     91  1038		       00 00 00 00*BLANKL     ds	7,0
     92  103f
     93  103f
     94  103f
     95  103f				   NineL
     96  103f		       1e		      .byte.b	%00011110
     97  1040		       02		      .byte.b	%00000010
     98  1041		       02		      .byte.b	%00000010
     99  1042		       fe		      .byte.b	%11111110
    100  1043		       82		      .byte.b	%10000010
    101  1044		       82		      .byte.b	%10000010
    102  1045		       fe		      .byte.b	%11111110
    103  1046
    104  1046				   SixL
    105  1046		       fe		      .byte.b	%11111110
    106  1047		       82		      .byte.b	%10000010
    107  1048		       82		      .byte.b	%10000010
    108  1049		       fe		      .byte.b	%11111110
    109  104a		       80		      .byte.b	%10000000
    110  104b		       80		      .byte.b	%10000000
    111  104c		       f0		      .byte.b	%11110000
    112  104d
    113  104d							;    .byte %01111100
    114  104d							;    .byte %11000010
    115  104d							;    .byte %11000010
    116  104d							;    .byte %11111100
    117  104d							;    .byte %11000000
    118  104d							;    .byte %01100000
    119  104d							;    .byte %00111000
    120  104d				   EightL
    121  104d
    122  104d
    123  104d		       fe		      .byte.b	%11111110
    124  104e		       82		      .byte.b	%10000010
    125  104f		       82		      .byte.b	%10000010
    126  1050		       fe		      .byte.b	%11111110
    127  1051		       82		      .byte.b	%10000010
    128  1052		       82		      .byte.b	%10000010
    129  1053		       fe		      .byte.b	%11111110
    130  1054
    131  1054							;  .byte %01111100
    132  1054							;  .byte %10000110
    133  1054							;  .byte %10000110
    134  1054							;  .byte %01111100
    135  1054							;  .byte %01000110
    136  1054							;  .byte %01000110
    137  1054							;  .byte %00111100
    138  1054				   ZeroL
    139  1054							;  .byte %01111100
    140  1054							;  .byte %10000110
    141  1054							;  .byte %10000110
    142  1054							;  .byte %10000110
    143  1054							;  .byte %10000110
    144  1054							;  .byte %01000110
    145  1054							;  .byte %00111100
    146  1054
    147  1054		       fe		      .byte.b	%11111110
    148  1055		       82		      .byte.b	%10000010
    149  1056		       82		      .byte.b	%10000010
    150  1057		       82		      .byte.b	%10000010
    151  1058		       82		      .byte.b	%10000010
    152  1059		       82		      .byte.b	%10000010
    153  105a		       fe		      .byte.b	%11111110
    154  105b
    155  105b				   ThreeL
    156  105b		       fe		      .byte.b	%11111110
    157  105c		       02		      .byte.b	%00000010
    158  105d		       02		      .byte.b	%00000010
    159  105e		       1e		      .byte.b	%00011110
    160  105f		       02		      .byte.b	%00000010
    161  1060		       02		      .byte.b	%00000010
    162  1061		       fe		      .byte.b	%11111110
    163  1062				   OneL
    164  1062		       10		      .byte.b	%00010000
    165  1063		       10		      .byte.b	%00010000
    166  1064		       10		      .byte.b	%00010000
    167  1065		       10		      .byte.b	%00010000
    168  1066		       10		      .byte.b	%00010000
    169  1067		       10		      .byte.b	%00010000
    170  1068		       10		      .byte.b	%00010000
    171  1069
    172  1069				   SevenL
    173  1069
    174  1069		       10		      .byte.b	%00010000
    175  106a		       10		      .byte.b	%00010000
    176  106b		       10		      .byte.b	%00010000
    177  106c		       1e		      .byte.b	%00011110
    178  106d		       02		      .byte.b	%00000010
    179  106e		       02		      .byte.b	%00000010
    180  106f							;  .byte %11111110
    181  106f
    182  106f							;    .byte %00010000
    183  106f							;    .byte %00010000
    184  106f							;    .byte %00010000
    185  106f							;    .byte %00011000
    186  106f							;    .byte %00001100
    187  106f							;    .byte %10000110
    188  106f							;    ;.byte %11111110
    189  106f				   TwoL
    190  106f		       fe		      .byte.b	%11111110
    191  1070		       80		      .byte.b	%10000000
    192  1071		       80		      .byte.b	%10000000
    193  1072		       fe		      .byte.b	%11111110
    194  1073		       02		      .byte.b	%00000010
    195  1074		       02		      .byte.b	%00000010
    196  1075		       fe		      .byte.b	%11111110
    197  1076
    198  1076				   FiveL
    199  1076		       fe		      .byte.b	%11111110
    200  1077		       02		      .byte.b	%00000010
    201  1078		       02		      .byte.b	%00000010
    202  1079		       fe		      .byte.b	%11111110
    203  107a		       80		      .byte.b	%10000000
    204  107b		       80		      .byte.b	%10000000
    205  107c		       f0		      .byte.b	%11110000
    206  107d
    207  107d				   FourL
    208  107d		       10		      .byte.b	%00010000
    209  107e		       10		      .byte.b	%00010000
    210  107f		       10		      .byte.b	%00010000
    211  1080		       fe		      .byte.b	%11111110
    212  1081		       90		      .byte.b	%10010000
    213  1082		       90		      .byte.b	%10010000
    214  1083		       90		      .byte.b	%10010000
    215  1084
    216  1084
    217  1084				   ZL
    218  1084		       7f		      .byte.b	%01111111
    219  1085		       40		      .byte.b	%01000000
    220  1086		       40		      .byte.b	%01000000
    221  1087		       7f		      .byte.b	%01111111
    222  1088		       01		      .byte.b	%00000001
    223  1089		       01		      .byte.b	%00000001
    224  108a		       0f		      .byte.b	%00001111
    225  108b
    226  108b				   EL
    227  108b		       7f		      .byte.b	%01111111
    228  108c		       40		      .byte.b	%01000000
    229  108d		       40		      .byte.b	%01000000
    230  108e		       78		      .byte.b	%01111000
    231  108f		       40		      .byte.b	%01000000
    232  1090		       40		      .byte.b	%01000000
    233  1091		       7f		      .byte.b	%01111111
    234  1092
    235  1092				   RL
    236  1092		       48		      .byte.b	%01001000
    237  1093		       48		      .byte.b	%01001000
    238  1094		       48		      .byte.b	%01001000
    239  1095		       7f		      .byte.b	%01111111
    240  1096		       41		      .byte.b	%01000001
    241  1097		       41		      .byte.b	%01000001
    242  1098		       7f		      .byte.b	%01111111
    243  1099
    244  1099				   PL
    245  1099		       40		      .byte.b	%01000000
    246  109a		       40		      .byte.b	%01000000
    247  109b		       40		      .byte.b	%01000000
    248  109c		       7f		      .byte.b	%01111111
    249  109d		       41		      .byte.b	%01000001
    250  109e		       41		      .byte.b	%01000001
    251  109f		       7f		      .byte.b	%01111111
    252  10a0
    253  10a0				   AL
    254  10a0		       41		      .byte.b	%01000001
    255  10a1		       41		      .byte.b	%01000001
    256  10a2		       41		      .byte.b	%01000001
    257  10a3		       7f		      .byte.b	%01111111
    258  10a4		       41		      .byte.b	%01000001
    259  10a5		       41		      .byte.b	%01000001
    260  10a6		       7f		      .byte.b	%01111111
    261  10a7
    262  10a7				   GL
    263  10a7		       7f		      .byte.b	%01111111
    264  10a8		       41		      .byte.b	%01000001
    265  10a9		       41		      .byte.b	%01000001
    266  10aa		       4f		      .byte.b	%01001111
    267  10ab		       40		      .byte.b	%01000000
    268  10ac		       40		      .byte.b	%01000000
    269  10ad		       7f		      .byte.b	%01111111
    270  10ae
    271  10ae
    272  10ae							; level "name" characters (left only!):
    273  10ae
    274  10ae				   CharN
    275  10ae				   CharK
    276  10ae				   CharH
    277  10ae				   CharA
    278  10ae				   CharJ
    279  10ae				   CharP
    280  10ae				   CharB
    281  10ae				   CharO
    282  10ae				   CharC
    283  10ae				   CharI
    284  10ae				   CharD
    285  10ae				   CharG
    286  10ae				   CharE
    287  10ae				   CharL
    288  10ae				   CharF
    289  10ae				   CharM
    290  10ae		       00 00 00 00*	      ds	7,0
    291  10b5
    292  10b5				   charPlace
    293  10b5		       0c		      .byte.b	%00001100
    294  10b6		       0c		      .byte.b	%00001100
    295  10b7		       0c		      .byte.b	%00001100
    296  10b8		       0c		      .byte.b	%00001100
    297  10b9		       0c		      .byte.b	%00001100
    298  10ba		       00		      .byte.b	%00000000
    299  10bb		       0c		      .byte.b	%00001100
    300  10bc
    301  10bc							;-------------------------------------------------------------------------------------
    302  10bc				   PosTbl
    303  10bc		       40		      .byte.b	$40
    304  10bd		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    305  10c5		       b9		      .byte.b	$b9
    306  10c6
    307  10c6
    308  10c6							;------------------------------------------------------------------------------
    309  10c6							; RAM-BASED SUBROUTINES...
    310  10c6							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    311  10c6							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    312  10c6							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    313  10c6							; the RAM-based routine.
    314  10c6
    315  1100		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    316  1100
    317  1100		       f1 00	   SM_BASE    =	.
    318  1100
    319  1100							;#IF 0 ;{
    320  1100							;    DEFINE_SUBROUTINE Score3x3
    321  1100							;
    322  1100							;	  sta	  RESP0
    323  1100							;	   sta	   RESP1
    324  1100							;	   lda	   #$$000
    325  1100							;	    sta     GRP0
    326  1100							;	    lda     #$$009
    327  1100							;	    sta     GRP1
    328  1100							;	    lda     #$$202
    329  1100							;	    sta     ENABL
    330  1100							;	    nop
    331  1100							;	    nop
    332  1100							;	    nop
    333  1100							;	    lda     #$$016
    334  1100							;	    ldy     #$$100
    335  1100							;	    ldx     #$$109
    336  1100							;	    sta     GRP0    ; Critical time is right here
    337  1100							;	    stx     GRP1
    338  1100							;	    sty     GRP0
    339  1100							;	    sta     RESP0
    340  1100							;	    sta     RESP1
    341  1100							;	    ldx     #$$116
    342  1100							;	    lda     #$$209
    343  1100							;	    stx     GRP0
    344  1100							;	    sta     GRP1
    345  1100							;	    lda     #$$200
    346  1100							;	    sta     GRP0
    347  1100							;	    sta     RESP0
    348  1100							;	    sta     RESP1
    349  1100							;	    lda     #$$216
    350  1100							;	    nop
    351  1100							;	    sta     GRP0
    352  1100							;
    353  1100							;	      rts
    354  1100							;#ENDIF ;}
    355  1100
    356  1100
    357  1100							;------------------------------------------------------------------------------
    358  1100				   Score1x6Fix SUBROUTINE
      0  1100					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  1100		       00 02	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  1100					      SUBROUTINE
      3  1100				   DrawDigits1x6
    360  1100							;					     @07
    361  1100		       ba		      tsx		; 2
    362  1101
    363  1101		       20 02 f2 	      jsr	PrepareDrawDigits	;56 = 58    @65
    364  1104
    365  1104		       86 d7		      stx	tmpStack	; 3 =	3
    366  1106
    367  1106				   LoopDraw1x6		;
    368  1106				   SMDIGIT0
    369  1106		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    370  1109		       85 42		      sta	WSYNC	; 3
    371  110b							;---------------------------------------------------------------
    372  110b		       85 6a		      sta	HMOVE	; 3
      0  110d					      SLEEP	3	; 3 =	6
      1  110d				   .CYCLES    SET	3
      2  110d
      3  110d				  -	      IF	.CYCLES < 2
      4  110d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  110d				  -	      ERR
      6  110d					      ENDIF
      7  110d
      8  110d					      IF	.CYCLES & 1
      9  110d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  110d		       04 00		      nop	0
     11  110f				  -	      ELSE
     12  110f				  -	      bit	VSYNC
     13  110f					      ENDIF
     14  110f				   .CYCLES    SET	.CYCLES - 3
     15  110f					      ENDIF
     16  110f
     17  110f				  -	      REPEAT	.CYCLES / 2
     18  110f				  -	      nop
     19  110f					      REPEND
    374  110f		       85 5b		      sta	GRP0	; 3
    375  1111				   SMDIGIT1
    376  1111		       b9 53 f0 	      lda	ZeroL-1,y	; 4
    377  1114		       85 5c		      sta	GRP1	; 3
    378  1116				   SMDIGIT2
    379  1116		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    380  1119		       85 5b		      sta	GRP0	; 3 = 17
    381  111b				   SMDIGIT5
    382  111b		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    383  111e		       9a		      txs		; 2
    384  111f				   SMDIGIT3
    385  111f		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    386  1122				   SMDIGIT4
    387  1122		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    388  1125		       85 6b		      sta	HMCLR	; 3
    389  1127		       86 5c		      stx	GRP1	; 3
    390  1129		       85 5b		      sta	GRP0	; 3 = 23
    391  112b
    392  112b		       ba		      tsx		; 2
    393  112c		       86 5c		      stx	GRP1	; 3
    394  112e		       85 5b		      sta	GRP0	; 3 =	8
    395  1130
    396  1130		       88		      dey		; 2
      0  1131					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  1131					      LIST	ON
      9  1131		       d0 d3		      bne	LoopDraw1x6
    398  1133
    399  1133		       a6 d7		      ldx	tmpStack	; 3
    400  1135		       9a		      txs		; 2
    401  1136				   ExitDigitKernel6
      0  1136					      SLEEP	3	; 3
      1  1136				   .CYCLES    SET	3
      2  1136
      3  1136				  -	      IF	.CYCLES < 2
      4  1136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1136				  -	      ERR
      6  1136					      ENDIF
      7  1136
      8  1136					      IF	.CYCLES & 1
      9  1136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1136		       04 00		      nop	0
     11  1138				  -	      ELSE
     12  1138				  -	      bit	VSYNC
     13  1138					      ENDIF
     14  1138				   .CYCLES    SET	.CYCLES - 3
     15  1138					      ENDIF
     16  1138
     17  1138				  -	      REPEAT	.CYCLES / 2
     18  1138				  -	      nop
     19  1138					      REPEND
    403  1138		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    404  113b
    405  113b
    406  113b							;------------------------------------------------------------------------------
    407  113b				   Score2x4Fix SUBROUTINE
      0  113b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  113b		       00 02	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  113b					      SUBROUTINE
      3  113b				   DrawDigits2x4
    409  113b
    410  113b
    411  113b							; Subroutine by Thomas Jentzsch.  Magic!
    412  113b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    413  113b
    414  113b							;sta COLUBK
    415  113b
    416  113b		       20 02 f2 	      jsr	PrepareDrawDigits	;56 = 56    @63
    417  113e
    418  113e		       85 6a		      sta	HMOVE	; 3
      0  1140					      SLEEP	4	; 4  =  7
      1  1140				   .CYCLES    SET	4
      2  1140
      3  1140				  -	      IF	.CYCLES < 2
      4  1140				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1140				  -	      ERR
      6  1140					      ENDIF
      7  1140
      8  1140				  -	      IF	.CYCLES & 1
      9  1140				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1140				  -	      nop	0
     11  1140				  -	      ELSE
     12  1140				  -	      bit	VSYNC
     13  1140				  -	      ENDIF
     14  1140				  -.CYCLES    SET	.CYCLES - 3
     15  1140					      ENDIF
     16  1140
     17  1140					      REPEAT	.CYCLES / 2
     18  1140		       ea		      nop
     17  1140					      REPEND
     18  1141		       ea		      nop
     19  1142					      REPEND
    420  1142
    421  1142				   LoopDraw2x4		;	     @70
    422  1142				   SM_TARGET3
    423  1142		       b9 07 f3 	      lda	DequalsR-1,y	; 4		     G
    424  1145							;---------------------------------------------------------------
    425  1145		       85 5b		      sta	GRP0	; 3
    426  1147				   SM_TARGET2
    427  1147		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     A
    428  114a		       85 5c		      sta	GRP1	; 3
    429  114c				   SM_TARGET1
    430  114c		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     M
    431  114f		       85 5b		      sta	GRP0	; 3
    432  1151				   SM_TARGET0
    433  1151		       be 53 f0 	      ldx	ZeroL-1,y	; 4		     E
    434  1154		       85 50		      sta	RESP0	; 3 = 28    @22
    435  1156		       85 51		      sta	RESP1	; 3 =	3    @25
    436  1158				   SM_Time3
    437  1158		       b9 15 f3 	      lda	ClockR-1,y	; 4		     O
    438  115b		       86 5c		      stx	GRP1	; 3
    439  115d		       85 5b		      sta	GRP0	; 3
    440  115f				   SM_Time2
    441  115f		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     V
    442  1162		       85 5c		      sta	GRP1	; 3
    443  1164				   SM_Time1
    444  1164		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     E
    445  1167		       85 5b		      sta	GRP0	; 3
    446  1169		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    447  116b		       85 51		      sta	RESP1	; 3 =	3    @55
    448  116d				   SM_Time0
    449  116d		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     R
    450  1170		       85 5c		      sta	GRP1	; 3
    451  1172		       85 5b		      sta	GRP0	; 3
    452  1174		       88		      dey		; 2
      0  1175					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  1175					      LIST	ON
      9  1175		       d0 cb		      bne	LoopDraw2x4
    454  1177
    455  1177				   ExitDigitKernel		;	     @69
    456  1177		       84 5b		      sty	GRP0	; 3
    457  1179		       84 5c		      sty	GRP1	; 3
    458  117b							;---------------------------------------------------------------
    459  117b		       84 5b		      sty	GRP0	; 3	     @02
    460  117d
    461  117d							; Contribution by Thomas Jentzsch
    462  117d							; Rewrite/Optimised for single sprite AD
    463  117d
    464  117d		       a6 9f		      ldx	ManDrawX	; 3
    465  117f		       bd bc f0 	      lda	PosTbl,x	; 4
    466  1182		       85 60		      sta	HMP0	; 3
    467  1184		       29 0f		      and	#$0f	; 2
    468  1186		       f0 04		      beq	.zeroPos	; 2/3=15
    469  1188		       aa		      tax		; 2
    470  1189				   .loopWait
    471  1189		       ca		      dex		; 2
    472  118a		       d0 fd		      bne	.loopWait	; 2/3= 6
    473  118c				   .zeroPos
    474  118c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    475  118e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    476  1190
    477  1190		       85 42		      sta	WSYNC
    478  1192		       85 6a		      sta	HMOVE	; 3
    479  1194
    480  1194		       a5 b1		      lda	BGColour	; 3
    481  1196		       85 49		      sta	COLUBK	;3
    482  1198
    483  1198		       86 62		      stx	HMM0	; 3	     for extra life stars!
    484  119a
    485  119a		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
    486  119c		       85 44		      sta	NUSIZ0	; 3
    487  119e		       85 45		      sta	NUSIZ1
    488  11a0		       84 65		      sty	VDELP0	; 3	 y = 0!
    489  11a2
      0  11a2					      SLEEP	5
      1  11a2				   .CYCLES    SET	5
      2  11a2
      3  11a2				  -	      IF	.CYCLES < 2
      4  11a2				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11a2				  -	      ERR
      6  11a2					      ENDIF
      7  11a2
      8  11a2					      IF	.CYCLES & 1
      9  11a2					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11a2		       04 00		      nop	0
     11  11a4				  -	      ELSE
     12  11a4				  -	      bit	VSYNC
     13  11a4					      ENDIF
     14  11a4				   .CYCLES    SET	.CYCLES - 3
     15  11a4					      ENDIF
     16  11a4
     17  11a4					      REPEAT	.CYCLES / 2
     18  11a4		       ea		      nop
     19  11a5					      REPEND
    491  11a5
    492  11a5		       a5 a2		      lda	ManLastDirection	; 3
    493  11a7		       85 4b		      sta	REFP0	; 3
    494  11a9
    495  11a9							;sta WSYNC		  ; 3
    496  11a9		       60		      rts		; 6	     @21
    497  11aa
    498  11aa							;------------------------------------------------------------------------------
    499  11aa				   Score3x2Fix SUBROUTINE
      0  11aa					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  11aa		       00 02	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  11aa					      SUBROUTINE
      3  11aa				   DrawDigits3x2
    501  11aa							;					     @07
    502  11aa		       a9 16		      lda	#%010110	; 2
    503  11ac		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    504  11ae		       20 08 f2 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    505  11b1
    506  11b1		       a9 00		      lda	#0
    507  11b3		       85 66		      sta	VDELP1
    508  11b5				   LoopDraw3x2		;
    509  11b5		       85 42		      sta	WSYNC	; 3
    510  11b7							;---------------------------------------------------------------
    511  11b7		       85 6a		      sta	HMOVE	; 3 =	3
    512  11b9		       b9 ad f0 	      lda	CharP-1,y	; 4
    513  11bc		       85 5b		      sta	GRP0	; 3
    514  11be				   SMPLAYER
    515  11be		       b9 3f f3 	      lda	OneR-1,y	; 4
    516  11c1		       85 5c		      sta	GRP1	; 3 = 14    @17
    517  11c3		       b9 b4 f0 	      lda	charPlace-1,y	; 4
    518  11c6				   SMMEN
    519  11c6		       be 38 f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  11c9					      SLEEP	5	;   =	5
      1  11c9				   .CYCLES    SET	5
      2  11c9
      3  11c9				  -	      IF	.CYCLES < 2
      4  11c9				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11c9				  -	      ERR
      6  11c9					      ENDIF
      7  11c9
      8  11c9					      IF	.CYCLES & 1
      9  11c9					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11c9		       04 00		      nop	0
     11  11cb				  -	      ELSE
     12  11cb				  -	      bit	VSYNC
     13  11cb					      ENDIF
     14  11cb				   .CYCLES    SET	.CYCLES - 3
     15  11cb					      ENDIF
     16  11cb
     17  11cb					      REPEAT	.CYCLES / 2
     18  11cb		       ea		      nop
     19  11cc					      REPEND
    521  11cc		       85 5b		      sta	GRP0	; 3
    522  11ce				   SMLEVELX
    523  11ce		       b9 ad f0 	      lda	CharA-1,y	; 4
    524  11d1		       85 6b		      sta	HMCLR	; 3 = 10    @40
    525  11d3		       86 5c		      stx	GRP1	; 3 =	3    @43
    526  11d5		       85 5b		      sta	GRP0	; 3
    527  11d7				   SMLEVEL
    528  11d7		       b9 3f f3 	      lda	OneR-1,y	; 4
    529  11da		       85 5c		      sta	GRP1	; 3 = 10    @53
    530  11dc
    531  11dc		       88		      dey		; 2
      0  11dd					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  11dd					      LIST	ON
      9  11dd		       d0 d6		      bne	LoopDraw3x2
    533  11df							;					     @57
      0  11df					      SLEEP	3	; 3
      1  11df				   .CYCLES    SET	3
      2  11df
      3  11df				  -	      IF	.CYCLES < 2
      4  11df				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11df				  -	      ERR
      6  11df					      ENDIF
      7  11df
      8  11df					      IF	.CYCLES & 1
      9  11df					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11df		       04 00		      nop	0
     11  11e1				  -	      ELSE
     12  11e1				  -	      bit	VSYNC
     13  11e1					      ENDIF
     14  11e1				   .CYCLES    SET	.CYCLES - 3
     15  11e1					      ENDIF
     16  11e1
     17  11e1				  -	      REPEAT	.CYCLES / 2
     18  11e1				  -	      nop
     19  11e1					      REPEND
    535  11e1		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    536  11e4
    537  11e4
    538  11e4							;------------------------------------------------------------------------------
    539  11e4
    540  11e4				   ScoreKernelLo
    541  11e4		       3b		      .byte.b	<Score2x4Fix	; TARGETs, time
    542  11e5		       00		      .byte.b	<Score1x6Fix	; score
    543  11e6		       aa		      .byte.b	<Score3x2Fix	; player, lives, level
    544  11e7		       00		      .byte.b	<Score1x6Fix	; high score
    545  11e8
      0  11e8					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  11e8					      LIST	ON
    547  11e8
    548  11e8							;------------------------------------------------------------------------------
    549  11e8
      0  11e8					      DEFINE_SUBROUTINE	DrawDigits
      1  11e8		       00 02	   BANK_DrawDigits =	_CURRENT_BANK
      2  11e8					      SUBROUTINE
      3  11e8				   DrawDigits
    551  11e8
    552  11e8				   VblankLoopGame
    553  11e8		       ac 84 02 	      ldy	INTIM
    554  11eb		       d0 fb		      bne	VblankLoopGame
    555  11ed
    556  11ed					      IF	WAIT_FOR_INITIAL_DRAW
    557  11ed		       a4 ae		      ldy	blankState
    558  11ef		       f0 02		      beq	state0
    559  11f1		       a0 02		      ldy	#2
    560  11f3				   state0
    561  11f3					      ENDIF
    562  11f3		       84 41		      sty	VBLANK	; 3	     <-- 0
    563  11f5							;lda scoringFlags	  ; 3
    564  11f5							;and #DISPLAY_FLAGS		    ; 2
    565  11f5							;tax			  ; 2
    566  11f5
    567  11f5		       a2 00		      ldx	#0
    568  11f7
    569  11f7							;    DEFINE_SUBROUTINE DrawDigit2
    570  11f7							;
    571  11f7							;    ; Generic interface to scoring routine
    572  11f7
    573  11f7		       bd e4 f1 	      lda	ScoreKernelLo,x	; 4
    574  11fa
    575  11fa		       85 42		      sta	WSYNC	; 3
    576  11fc		       8d 00 f6 	      sta	SMJUMP+1+RAM_WRITE	; 4
    577  11ff				   SMJUMP
    578  11ff		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    579  1202
    580  1202							;---------------------------------------------------------------
    581  1202
      0  1202					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  1202		       00 02	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  1202					      SUBROUTINE
      3  1202				   PrepareDrawDigits
    583  1202							;					     @13
    584  1202		       a0 d1		      ldy	#$d1	; 2
    585  1204		       a9 13		      lda	#%010011	; 2
    586  1206		       85 66		      sta	VDELP1	; 3 =	7
    587  1208				   PrepareDrawDigits2		;	    @17/20
    588  1208		       84 65		      sty	VDELP0	; 3 =	3
    589  120a
    590  120a		       85 45		      sta	NUSIZ1	; 3
    591  120c		       85 44		      sta	NUSIZ0	; 3 =	6
    592  120e
    593  120e		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    594  1211		       85 50		      sta	RESP0	; 3	     @33/36
    595  1213		       85 51		      sta	RESP1	; 3 = 10    @36/39
    596  1215
    597  1215		       84 60		      sty	HMP0	; 3
    598  1217		       c8		      iny		; 2
    599  1218		       84 61		      sty	HMP1	; 3 =	8
    600  121a				   SMCOLOR
    601  121a		       a0 9a		      ldy	#SCORE_COL	; 2
    602  121c		       84 46		      sty	COLUP0	; 3
    603  121e		       84 47		      sty	COLUP1	; 3 =	8
    604  1220
    605  1220		       a0 07		      ldy	#DIGIT_H	; 2
    606  1222		       60		      rts		; 6 =	8
    607  1223							; total: 27
    608  1223
    609  1223
    610  1223							;------------------------------------------------------------------------------
      0  1223					      DEFINE_SUBROUTINE	UpdateScore
      1  1223		       00 02	   BANK_UpdateScore =	_CURRENT_BANK
      2  1223					      SUBROUTINE
      3  1223				   UpdateScore
    612  1223							; a = added score value
    613  1223
    614  1223							; initially switch to score:
    615  1223		       a0 01		      ldy	#DISPLAY_SCORE
    616  1225		       84 d7		      sty	newDisplay
    617  1227
    618  1227		       18		      clc
    619  1228		       f8		      sed
    620  1229		       a0 04		      ldy	#SM_OFS_SCORE
    621  122b				   .loopScore
    622  122b		       79 8a f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    623  122e		       99 8a f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    624  1231		       08		      php
    625  1232							; *** bonus life every 500 points: ***
    626  1232							;	  cpy #SM_OFS_SCORE+1
    627  1232							;	  bne .skipBonusLife
    628  1232							;	  tax
    629  1232
    630  1232							;	  and #$0f
    631  1232							;	  beq .bonusLife		      ; 000?
    632  1232							;	  cmp #$05
    633  1232							;	  bne .noBonusLife		      ; 500?
    634  1232							;.bonusLife:
    635  1232							; add extra life, limited to 9
    636  1232
    637  1232							;	  lda ManCount
    638  1232							;	  and #$0f
    639  1232							;	  cmp #9
    640  1232							;	  bcs .noBonusLife
    641  1232							;	  inc ManCount
    642  1232
    643  1232							; bonus life has priority over score:
    644  1232							;	  lda #DISPLAY_LIVES
    645  1232							;	  sta newDisplay
    646  1232							;lda #EXTRA_LIFE_TIMER
    647  1232							;sta extraLifeTimer
    648  1232
    649  1232				   .noBonusLife
    650  1232		       8a		      txa
    651  1233				   .skipBonusLife
    652  1233		       20 ae f2 	      jsr	SetupBCDPtr
    653  1236		       28		      plp
    654  1237		       a9 00		      lda	#0
    655  1239		       b0 f0		      bcs	.loopScore
    656  123b		       d8		      cld
    657  123c
    658  123c							; switch display
    659  123c							;lda scoringFlags
    660  123c							;and #DISPLAY_FLAGS
    661  123c							;cmp newDisplay		      ; lower priority than current?
    662  123c							;beq .restartTime
    663  123c							;bcs .skipNew
    664  123c							;eor scoringFlags		      ; remove existing score mode
    665  123c							;ora newDisplay		      ; switch to new score mode
    666  123c							;sta scoringFlags
    667  123c				   .restartTime
    668  123c							;lda #SCORING_TIMER		      ; maybe always restart timer?
    669  123c							;sta scoringTimer
    670  123c				   .skipNew
    671  123c
    672  123c		       60		      rts
    673  123d
    674  123d							;---------------------------------------------------------------------------
    675  123d
      0  123d					      DEFINE_SUBROUTINE	SwapPlayers
      1  123d		       00 02	   BANK_SwapPlayers =	_CURRENT_BANK
      2  123d					      SUBROUTINE
      3  123d				   SwapPlayers
    677  123d
    678  123d							; assume no new high score:
    679  123d		       a0 ff		      ldy	#-1
    680  123f		       84 da		      sty	highScoreSK
    681  1241
    682  1241							; update highscore after last live:
    683  1241							;lda ManCount
    684  1241							;and #$0f			      ; player has lives left?
    685  1241							;bne .playerAlive		      ; YES, so we don't check high score
    686  1241
    687  1241							; check for a new high score:
    688  1241							;	  ldy #-1
    689  1241		       18		      clc		; score has to be at least 1 bigger!
    690  1242				   .loopCheckHighScore
    691  1242		       c8		      iny
    692  1243		       b9 8e f3 	      lda	ScoreCurrent,y
    693  1246		       f9 98 f3 	      sbc	HighScore,y
    694  1249		       98		      tya
    695  124a		       49 02		      eor	#2
    696  124c		       d0 f4		      bne	.loopCheckHighScore
    697  124e		       90 0d		      bcc	.noHighScore
    698  1250
    699  1250							; new high score, update:
    700  1250		       a2 04		      ldx	#5-1
    701  1252				   .loopSetHighScore
    702  1252		       bd 8e f3 	      lda	ScoreCurrent,x
    703  1255		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
    704  1258		       95 da		      sta	highScoreSK,x
    705  125a		       ca		      dex
    706  125b		       10 f5		      bpl	.loopSetHighScore
    707  125d				   .noHighScore
    708  125d
    709  125d				   .playerAlive
    710  125d							;lda ManCount
    711  125d							;and #$f0			      ; other player has lives left?
    712  125d							;beq .otherPlayerDead		      ; NO, so we don't swap scores
    713  125d
    714  125d							; save the current player variables to the player's backup:
    715  125d		       a0 02		      ldy	#3-1
    716  125f				   .swapScore
    717  125f		       be 93 f3 	      ldx	PlayerScores,y
    718  1262		       b9 8e f3 	      lda	ScoreCurrent,y
    719  1265		       99 93 f7 	      sta	PlayerScores+RAM_WRITE,y
    720  1268		       8a		      txa
    721  1269		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
    722  126c		       88		      dey
    723  126d		       10 f0		      bpl	.swapScore
    724  126f
    725  126f							; swap levelx and level:
    726  126f		       a2 01		      ldx	#1
    727  1271				   .loopLevelXLevel
    728  1271		       bc 96 f3 	      ldy	PlayerLevelX,x
    729  1274		       b5 b2		      lda	levelX,x
    730  1276		       9d 96 f7 	      sta	PlayerLevelX+RAM_WRITE,x
    731  1279		       94 b2		      sty	levelX,x
    732  127b		       ca		      dex
    733  127c		       10 f3		      bpl	.loopLevelXLevel
    734  127e
    735  127e				   .otherPlayerDead
    736  127e		       60		      rts
    737  127f
    738  127f							;---------------------------------------------------------------------------
    739  127f
    740  127f				   HighScoreColTbl
    741  127f		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    742  1281		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    743  1283
      0  1283					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  1283		       00 02	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  1283					      SUBROUTINE
      3  1283				   GeneralScoringSetups
    745  1283
    746  1283		       a0 04		      ldy	#SM_OFS_SCORE
    747  1285				   .loopScore2
    748  1285							;lda scoringFlags
    749  1285							;and #DISPLAY_FLAGS
    750  1285							;cmp #DISPLAY_HIGH
    751  1285							;ldx Platform
    752  1285							;lda HighScoreColTbl,x
    753  1285							;tax
    754  1285							;lda HighScore-SM_OFS_SCORE,y
    755  1285							;bcs .showHighScore
    756  1285		       a2 9a		      ldx	#SCORE_COL
    757  1287		       b9 8a f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    758  128a				   .showHighScore
    759  128a		       8e 1b f6 	      stx	SMCOLOR+1+RAM_WRITE
    760  128d		       20 ae f2 	      jsr	SetupBCDPtr
    761  1290		       c0 07		      cpy	#SM_OFS_SCORE+3
    762  1292		       90 f1		      bcc	.loopScore2
    763  1294
    764  1294							; display number of lives in leftmost digit of middle score XX nX XX
    765  1294
    766  1294							;lda ManCount
    767  1294							;and #$0f
    768  1294							;tay
    769  1294							;lda DigitVectorLOr,y
    770  1294							;sta SMMEN+1+RAM_WRITE
    771  1294
    772  1294							; modify player number pointer (Xp XX XX)
    773  1294
    774  1294							;ldy whichPlayer
    775  1294							;lda DigitVectorLOr+1,y
    776  1294							;sta SMPLAYER+1+RAM_WRITE
    777  1294
    778  1294							; fall through
    779  1294
    780  1294							;    ;---------------------------------------------------------------------------
    781  1294
    782  1294							; modify levelx character pointer (XX XX cX)
    783  1294
    784  1294							;ldx #<charPlace-1
    785  1294							;lda levelDisplay
    786  1294							;cmp #$80
    787  1294							;and #$1f
    788  1294							;tay
    789  1294							;bcs .intermission
    790  1294							;ldx CharVectorLO,y
    791  1294							;ldy level
    792  1294							;.intermission
    793  1294							;stx SMLEVELX+1+RAM_WRITE
    794  1294
    795  1294							; modify level number pointer (XX XX Xl)
    796  1294
    797  1294							;lda DigitVectorLOr+1,y
    798  1294							;sta SMLEVEL+1+RAM_WRITE
    799  1294
    800  1294							;---------------------------------------------------------------------------
    801  1294
    802  1294		       4c a5 f2 	      jmp	SetupTimePtr	; modify time pointers
    803  1297
    804  1297							;------------------------------------------------------------------------------
    805  1297							;    DEFINE_SUBROUTINE SetupGameOverPtr
    806  1297
    807  1297							;		  ldy #8-1
    808  1297							;.loopGameOver:
    809  1297							;		  ldx SMGameOverOfs,y
    810  1297							;		  lda SMGameOverPtr,y
    811  1297							;		  sta SM_BASE+1+RAM_WRITE,x
    812  1297							;		  dey
    813  1297							;		  bpl .loopGameOver
    814  1297
    815  1297							;		  rts
    816  1297
    817  1297							;SMGameOverOfs:
    818  1297							;		  .byte <SM_TARGET3-SM_BASE, <SM_TARGET2-SM_BASE
    819  1297							;		  .byte <SM_TARGET1-SM_BASE, <SM_TARGET0-SM_BASE
    820  1297							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    821  1297							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    822  1297							;SMGameOverPtr:
    823  1297							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    824  1297							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    825  1297
    826  1297							;------------------------------------------------------------------------------
    827  1297
      0  1297					      DEFINE_SUBROUTINE	DrawBCD_targetsRequired
      1  1297		       00 02	   BANK_DrawBCD_targetsRequired =	_CURRENT_BANK
      2  1297					      SUBROUTINE
      3  1297				   DrawBCD_targetsRequired
    829  1297							; Show current TARGET counter in the top left
    830  1297
    831  1297		       a0 00		      ldy	#SM_OFS_TARGETS
    832  1299		       a5 b5		      lda	BCD_targetsRequired
    833  129b		       20 ae f2 	      jsr	SetupBCDPtr
    834  129e
    835  129e		       a9 b0		      lda	#ID_TARGET<<4	; if no extra targets, display the normal icon
    836  12a0							;bit scoringFlags		      ;
    837  12a0		       4c ae f2 	      jmp	SetupBCDPtr
    838  12a3							;lda #ID_EXTRA<<4		      ; otherwise, display the extra icon
    839  12a3							;bvc SetupBCDPtr
    840  12a3							;ora #1			      ; display 1xx targets
    841  12a3							;bne SetupBCDPtr		      ; unconditional
    842  12a3
    843  12a3							;------------------------------------------------------------------------------
      0  12a3					      DEFINE_SUBROUTINE	DrawTime
      1  12a3		       00 02	   BANK_DrawTime =	_CURRENT_BANK
      2  12a3					      SUBROUTINE
      3  12a3				   DrawTime
    845  12a3
    846  12a3							; mid-digit-change, but we may be required to flash/display
    847  12a3		       a0 02		      ldy	#SM_OFS_TIME
    848  12a5							;------------------------------------------------------------------------------
      0  12a5					      DEFINE_SUBROUTINE	SetupTimePtr
      1  12a5		       00 02	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  12a5					      SUBROUTINE
      3  12a5				   SetupTimePtr
    850  12a5
    851  12a5		       a5 b6		      lda	BCD_moveCounter
    852  12a7		       20 ae f2 	      jsr	SetupBCDPtr
    853  12aa		       a5 b7		      lda	BCD_moveCounter+1
    854  12ac		       09 d0		      ora	#ID_CLOCK<<4
    855  12ae
    856  12ae							; fall through
    857  12ae
    858  12ae							;------------------------------------------------------------------------------
      0  12ae					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  12ae		       00 02	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  12ae					      SUBROUTINE
      3  12ae				   SetupBCDPtr
    860  12ae
    861  12ae							; a = BCD value
    862  12ae							; y = SM table offset
    863  12ae
    864  12ae		       48		      pha
    865  12af		       29 0f		      and	#$0f
    866  12b1		       aa		      tax
    867  12b2		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    868  12b5		       be 19 f0 	      ldx	SMTblLSB,y
    869  12b8		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    870  12bb		       68		      pla
    871  12bc		       4a		      lsr
    872  12bd		       4a		      lsr
    873  12be		       4a		      lsr
    874  12bf		       4a		      lsr
    875  12c0		       aa		      tax
    876  12c1		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    877  12c4		       be 20 f0 	      ldx	SMTblMSB,y
    878  12c7		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    879  12ca
    880  12ca		       c8		      iny
    881  12cb
    882  12cb		       a5 bf		      lda	ROM_Bank
    883  12cd				   RTS
    884  12cd		       60		      rts
    885  12ce
      0  12ce					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
 PAGE BREAK INSERTED FOR  LeftDigits
 REQUESTED SIZE =  $5b
 WASTED SPACE =  $32
 PAGEBREAK LOCATION =  $f300
     10  1300					      LIST	ON
    887  1300
    888  1300					      IF	<. = 0
    889  1300		       00		      .byte.b	0	; required!
    890  1301					      ENDIF
    891  1301
    892  1301				   BLANKR
    893  1301		       00 00 00 00*	      .ds	DIGIT_H, 0
    894  1308
    895  1308				   DequalsR
    896  1308		       00		      .byte.b	%00000000
    897  1309		       00		      .byte.b	%00000000
    898  130a		       f0		      .byte.b	%11110000
    899  130b		       00		      .byte.b	%00000000
    900  130c		       f0		      .byte.b	%11110000
    901  130d		       00		      .byte.b	%00000000
    902  130e		       f0		      .byte.b	%11110000
    903  130f				   DplusR
    904  130f		       10		      .byte.b	%00010000
    905  1310		       28		      .byte.b	%00101000
    906  1311		       6c		      .byte.b	%01101100
    907  1312		       c6		      .byte.b	%11000110
    908  1313		       6c		      .byte.b	%01101100
    909  1314		       28		      .byte.b	%00101000
    910  1315		       10		      .byte.b	%00010000
    911  1316
    912  1316				   ClockR
    913  1316		       00		      .byte.b	%00000000
    914  1317		       48		      .byte.b	%01001000
    915  1318		       fc		      .byte.b	%11111100
    916  1319		       48		      .byte.b	%01001000
    917  131a		       48		      .byte.b	%01001000
    918  131b		       fc		      .byte.b	%11111100
    919  131c		       48		      .byte.b	%01001000
    920  131d				   NineR
    921  131d		       0f		      .byte.b	%00001111
    922  131e		       01		      .byte.b	%00000001
    923  131f		       01		      .byte.b	%00000001
    924  1320		       7f		      .byte.b	%01111111
    925  1321		       41		      .byte.b	%01000001
    926  1322		       41		      .byte.b	%01000001
    927  1323		       7f		      .byte.b	%01111111
    928  1324				   SixR
    929  1324		       7f		      .byte.b	%01111111
    930  1325		       41		      .byte.b	%01000001
    931  1326		       41		      .byte.b	%01000001
    932  1327		       7f		      .byte.b	%01111111
    933  1328		       40		      .byte.b	%01000000
    934  1329		       40		      .byte.b	%01000000
    935  132a		       78		      .byte.b	%01111000
    936  132b				   EightR
    937  132b							;  .byte %00111110
    938  132b							;  .byte %01000011
    939  132b							;  .byte %01000011
    940  132b							;  .byte %00111110
    941  132b							;  .byte %00100011
    942  132b							;  .byte %00100011
    943  132b							;  .byte %00011110
    944  132b
    945  132b
    946  132b		       7f		      .byte.b	%01111111
    947  132c		       41		      .byte.b	%01000001
    948  132d		       41		      .byte.b	%01000001
    949  132e		       7f		      .byte.b	%01111111
    950  132f		       41		      .byte.b	%01000001
    951  1330		       41		      .byte.b	%01000001
    952  1331		       7f		      .byte.b	%01111111
    953  1332
    954  1332				   ZeroR
    955  1332		       7f		      .byte.b	%01111111
    956  1333		       41		      .byte.b	%01000001
    957  1334		       41		      .byte.b	%01000001
    958  1335		       41		      .byte.b	%01000001
    959  1336		       41		      .byte.b	%01000001
    960  1337		       41		      .byte.b	%01000001
    961  1338		       7f		      .byte.b	%01111111
    962  1339
    963  1339							;	  .byte %00111110
    964  1339							;	  .byte %01000011
    965  1339							;	  .byte %01000011
    966  1339							;	  .byte %01000011
    967  1339							;	  .byte %01000011
    968  1339							;	  .byte %00100011
    969  1339							;	  .byte %00011110
    970  1339				   ThreeR
    971  1339		       7f		      .byte.b	%01111111
    972  133a		       01		      .byte.b	%00000001
    973  133b		       01		      .byte.b	%00000001
    974  133c		       0f		      .byte.b	%00001111
    975  133d		       01		      .byte.b	%00000001
    976  133e		       01		      .byte.b	%00000001
    977  133f		       7f		      .byte.b	%01111111
    978  1340				   OneR
    979  1340		       08		      .byte.b	%00001000
    980  1341		       08		      .byte.b	%00001000
    981  1342		       08		      .byte.b	%00001000
    982  1343		       08		      .byte.b	%00001000
    983  1344		       08		      .byte.b	%00001000
    984  1345		       08		      .byte.b	%00001000
    985  1346		       08		      .byte.b	%00001000
    986  1347
    987  1347				   SevenR
    988  1347		       08		      .byte.b	%00001000
    989  1348		       08		      .byte.b	%00001000
    990  1349		       08		      .byte.b	%00001000
    991  134a		       0f		      .byte.b	%00001111
    992  134b		       01		      .byte.b	%00000001
    993  134c		       01		      .byte.b	%00000001
    994  134d		       7f		      .byte.b	%01111111
    995  134e
    996  134e				   TwoR
    997  134e		       7f		      .byte.b	%01111111
    998  134f		       40		      .byte.b	%01000000
    999  1350		       40		      .byte.b	%01000000
   1000  1351		       7f		      .byte.b	%01111111
   1001  1352		       01		      .byte.b	%00000001
   1002  1353		       01		      .byte.b	%00000001
   1003  1354		       7f		      .byte.b	%01111111
   1004  1355				   FiveR
   1005  1355		       7f		      .byte.b	%01111111
   1006  1356		       01		      .byte.b	%00000001
   1007  1357		       01		      .byte.b	%00000001
   1008  1358		       7f		      .byte.b	%01111111
   1009  1359		       40		      .byte.b	%01000000
   1010  135a		       40		      .byte.b	%01000000
   1011  135b		       78		      .byte.b	%01111000
   1012  135c				   FourR
   1013  135c		       08		      .byte.b	%00001000
   1014  135d		       08		      .byte.b	%00001000
   1015  135e		       08		      .byte.b	%00001000
   1016  135f		       7f		      .byte.b	%01111111
   1017  1360		       48		      .byte.b	%01001000
   1018  1361		       48		      .byte.b	%01001000
   1019  1362		       48		      .byte.b	%01001000
   1020  1363
   1021  1363							;CharAL:
   1022  1363							;    .byte %11100110
   1023  1363							;    .byte %11100110
   1024  1363							;    .byte %11111110
   1025  1363							;    .byte %11100110
   1026  1363							;    .byte %11100110
   1027  1363							;    .byte %01111100
   1028  1363							;    .byte %00111000
   1029  1363							;CharEL:
   1030  1363							;    .byte %11111110
   1031  1363							;    .byte %11111110
   1032  1363							;    .byte %11100000
   1033  1363							;    .byte %11100000
   1034  1363							;    .byte %11111100
   1035  1363							;    .byte %11100000
   1036  1363							;    .byte %11111110
   1037  1363							;CharRL:
   1038  1363							;    .byte %11100110
   1039  1363							;    .byte %11100110
   1040  1363							;    .byte %11111100
   1041  1363							;    .byte %11111100
   1042  1363							;    .byte %11100110
   1043  1363							;    .byte %11100110
   1044  1363							;    .byte %11111100
   1045  1363							;CharVL:
   1046  1363							;    .byte %00111000
   1047  1363							;    .byte %01111100
   1048  1363							;    .byte %11100110
   1049  1363							;    .byte %11100110
   1050  1363							;    .byte %11100110
   1051  1363							;    .byte %11100110
   1052  1363							;    .byte %11100110
   1053  1363
      0  1363					      CHECKPAGE	BLANKR
      8  1363					      LIST	ON
   1055  1363
   1056  1363							;---------------------------------------------------------------------------
   1057  1363
      0  1363					      DEFINE_SUBROUTINE	GameInitialise
      1  1363		       00 02	   BANK_GameInitialise =	_CURRENT_BANK
      2  1363					      SUBROUTINE
      3  1363				   GameInitialise
   1059  1363
   1060  1363							; copy loaded SK high score into scoring RAM:
   1061  1363		       a2 02		      ldx	#3-1
   1062  1365				   .loopCopyHighScore
   1063  1365		       b5 da		      lda	highScoreSK,x
   1064  1367		       c9 ff		      cmp	#$ff
   1065  1369		       f0 06		      beq	.noSaveKey
   1066  136b		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
   1067  136e		       ca		      dex
   1068  136f		       10 f4		      bpl	.loopCopyHighScore
   1069  1371				   .noSaveKey
   1070  1371
   1071  1371							; clear both players scores
   1072  1371		       a0 05		      ldy	#2*3-1
   1073  1373		       a9 00		      lda	#0
   1074  1375				   .loopClearScore
   1075  1375		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
   1076  1378		       88		      dey
   1077  1379		       10 fa		      bpl	.loopClearScore
   1078  137b
   1079  137b							; copy levelX and level for other player and SaveKey:
   1080  137b		       a5 b2		      lda	levelX
   1081  137d		       8d 96 f7 	      sta	PlayerLevelX+RAM_WRITE
   1082  1380		       a5 dd		      lda	startingLevel
   1083  1382		       8d 91 f7 	      sta	StartLevelX+RAM_WRITE
   1084  1385		       a5 b3		      lda	level
   1085  1387		       8d 97 f7 	      sta	PlayerLevel+RAM_WRITE
   1086  138a		       8d 92 f7 	      sta	StartLevel+RAM_WRITE
   1087  138d		       60		      rts
   1088  138e
   1089  138e							;---------------------------------------------------------------------------
   1090  138e
   1091  138e		       00 00 00    ScoreCurrent ds	3, 0
   1092  1391							; start levelx and level have to be after ScoreCurrent!
   1093  1391		       00	   StartLevelX .byte.b	0
   1094  1392		       00	   StartLevel .byte.b	0
   1095  1393		       00 00 00    PlayerScores ds	3, 0
   1096  1396							; levelx and level have to be consecutive variables!
   1097  1396		       00	   PlayerLevelX .byte.b	0
   1098  1397		       00	   PlayerLevel .byte.b	0
   1099  1398		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1100  139d
   1101  139d
   1102  139d
   1103  139d							;------------------------------------------------------------------------------
   1104  139d
      0  139d					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  139d
      2  139d
      3  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $39d , FREE= $63
      4  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  139d				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  139d				  -	      ERR
      8  139d					      endif
   1106  139d
   1107  139d							;------------------------------------------------------------------------------
   1108  139d
   1109  139d							; LEVEL DATA banks can go anywhere - *EXCEPT* for the same bank as the level
   1110  139d							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_LEVEL_SIZE
   1111  139d							; which is used as a buffer size inside UnpackLevel.  It's not important if
   1112  139d							; this is defined before or after, as once the levels have processed it will be
   1113  139d							; correct. Note, that levels should all be defined BEFORE *OR* AFTER the
   1114  139d							; UnpackLevel code -- but that they should not be both, nor in the same bank.
   1115  139d							; TODO: verify above is still valid
   1116  139d
   1117  139d
      0  139d					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $39d , FREE= $463
      2  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  139d				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  139d				  -	      ERR
      6  139d					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 3
      0  139d					      include	"BANK_GENERIC.asm"
      1  139d							;    Sokoboo - a Sokoban implementation
      2  139d							;    using a generic tile-based display engine for the Atari 2600
      3  139d							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  139d							;
      5  139d							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  139d							;
      7  139d							;    Code related to the generic tile-based display engine was developed by
      8  139d							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  139d							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  139d							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  139d							;
     12  139d							;    Code related to music and sound effects uses the TIATracker music player
     13  139d							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  139d							;    directory for Apache licensing details.
     15  139d							;
     16  139d							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  139d							;    See the copyright notices in the License directory for a list of level
     18  139d							;    contributors.
     19  139d							;
     20  139d							;    Except where otherwise indicated, this software is released under the
     21  139d							;    following licensing arrangement...
     22  139d							;
     23  139d							;    This program is free software: you can redistribute it and/or modify
     24  139d							;    it under the terms of the GNU General Public License as published by
     25  139d							;    the Free Software Foundation, either version 3 of the License, or
     26  139d							;    (at your option) any later version.
     27  139d							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  139d
     29  139d							;    This program is distributed in the hope that it will be useful,
     30  139d							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  139d							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  139d							;    GNU General Public License for more details.
     33  139d
     34  139d							;------------------------------------------------------------------------------
     35  139d							;##############################################################################
     36  139d							;------------------------------------------------------------------------------
     37  139d
      0  139d					      NEWBANK	GENERIC_BANK_1
      1  1e1c ????				      SEG	GENERIC_BANK_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	GENERIC_BANK_1
     39  1800
     40  1800
     41  1800
      0  1800					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  1800					      ALIGN	$400
      2  1800				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  1800				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
------- FILE DecodeLevel.asm LEVEL 3 PASS 3
      0  1800					      include	"DecodeLevel.asm"
      1  1800							;    Sokoboo - a Sokoban implementation
      2  1800							;    using a generic tile-based display engine for the Atari 2600
      3  1800							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1800							;
      5  1800							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1800							;
      7  1800							;    Code related to the generic tile-based display engine was developed by
      8  1800							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1800							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1800							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1800							;
     12  1800							;    Code related to music and sound effects uses the TIATracker music player
     13  1800							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1800							;    directory for Apache licensing details.
     15  1800							;
     16  1800							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1800							;    See the copyright notices in the License directory for a list of level
     18  1800							;    contributors.
     19  1800							;
     20  1800							;    Except where otherwise indicated, this software is released under the
     21  1800							;    following licensing arrangement...
     22  1800							;
     23  1800							;    This program is free software: you can redistribute it and/or modify
     24  1800							;    it under the terms of the GNU General Public License as published by
     25  1800							;    the Free Software Foundation, either version 3 of the License, or
     26  1800							;    (at your option) any later version.
     27  1800							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1800
     29  1800							;    This program is distributed in the hope that it will be useful,
     30  1800							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1800							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1800							;    GNU General Public License for more details.
     33  1800
     34  1800							; The ordering here corresponds to the ordering when playing...
     35  1800
     36  1800				   LevelInfoLO
     37  1800		       ff		      .byte.b	<(LEVEL__001_L-1)
     38  1801		       11		      .byte.b	<(LEVEL__001_R-1)
     39  1802		       1d		      .byte.b	<(LEVEL__002_L-1)
     40  1803		       36		      .byte.b	<(LEVEL__002_R-1)
     41  1804		       5e		      .byte.b	<(LEVEL__003_L-1)
     42  1805		       8a		      .byte.b	<(LEVEL__003_R-1)
     43  1806		       b4		      .byte.b	<(LEVEL__004_L-1)
     44  1807		       d7		      .byte.b	<(LEVEL__004_R-1)
     45  1808		       f3		      .byte.b	<(LEVEL__005_L-1)
     46  1809		       25		      .byte.b	<(LEVEL__005_R-1)
     47  180a		       64		      .byte.b	<(LEVEL__006_L-1)
     48  180b		       9f		      .byte.b	<(LEVEL__006_R-1)
     49  180c		       dd		      .byte.b	<(LEVEL__007_L-1)
     50  180d		       0a		      .byte.b	<(LEVEL__007_R-1)
     51  180e		       3d		      .byte.b	<(LEVEL__008_L-1)
     52  180f		       73		      .byte.b	<(LEVEL__008_R-1)
     53  1810		       a4		      .byte.b	<(LEVEL__009_L-1)
     54  1811		       d6		      .byte.b	<(LEVEL__009_R-1)
     55  1812		       06		      .byte.b	<(LEVEL__010_L-1)
     56  1813		       40		      .byte.b	<(LEVEL__010_R-1)
     57  1814		       73		      .byte.b	<(LEVEL__011_L-1)
     58  1815		       a6		      .byte.b	<(LEVEL__011_R-1)
     59  1816		       e0		      .byte.b	<(LEVEL__012_L-1)
     60  1817		       10		      .byte.b	<(LEVEL__012_R-1)
     61  1818		       4c		      .byte.b	<(LEVEL__013_L-1)
     62  1819		       8b		      .byte.b	<(LEVEL__013_R-1)
     63  181a		       be		      .byte.b	<(LEVEL__014_L-1)
     64  181b		       01		      .byte.b	<(LEVEL__014_R-1)
     65  181c		       44		      .byte.b	<(LEVEL__015_L-1)
     66  181d		       79		      .byte.b	<(LEVEL__015_R-1)
     67  181e		       be		      .byte.b	<(LEVEL__016_L-1)
     68  181f		       f5		      .byte.b	<(LEVEL__016_R-1)
     69  1820		       28		      .byte.b	<(LEVEL__017_L-1)
     70  1821		       72		      .byte.b	<(LEVEL__017_R-1)
     71  1822		       b5		      .byte.b	<(LEVEL__018_L-1)
     72  1823		       e9		      .byte.b	<(LEVEL__018_R-1)
     73  1824		       25		      .byte.b	<(LEVEL__019_L-1)
     74  1825		       60		      .byte.b	<(LEVEL__019_R-1)
     75  1826		       ff		      .byte.b	<(LEVEL__020_L-1)
     76  1827		       3e		      .byte.b	<(LEVEL__020_R-1)
     77  1828		       7e		      .byte.b	<(LEVEL__021_L-1)
     78  1829		       d4		      .byte.b	<(LEVEL__021_R-1)
     79  182a		       08		      .byte.b	<(LEVEL__022_L-1)
     80  182b		       4e		      .byte.b	<(LEVEL__022_R-1)
     81  182c		       8a		      .byte.b	<(LEVEL__023_L-1)
     82  182d		       cb		      .byte.b	<(LEVEL__023_R-1)
     83  182e		       0d		      .byte.b	<(LEVEL__024_L-1)
     84  182f		       5d		      .byte.b	<(LEVEL__024_R-1)
     85  1830		       a5		      .byte.b	<(LEVEL__025_L-1)
     86  1831		       e8		      .byte.b	<(LEVEL__025_R-1)
     87  1832		       27		      .byte.b	<(LEVEL__026_L-1)
     88  1833		       60		      .byte.b	<(LEVEL__026_R-1)
     89  1834		       a1		      .byte.b	<(LEVEL__027_L-1)
     90  1835		       df		      .byte.b	<(LEVEL__027_R-1)
     91  1836		       1d		      .byte.b	<(LEVEL__028_L-1)
     92  1837		       69		      .byte.b	<(LEVEL__028_R-1)
     93  1838		       b7		      .byte.b	<(LEVEL__029_L-1)
     94  1839		       fc		      .byte.b	<(LEVEL__029_R-1)
     95  183a		       40		      .byte.b	<(LEVEL__030_L-1)
     96  183b		       90		      .byte.b	<(LEVEL__030_R-1)
     97  183c		       e3		      .byte.b	<(LEVEL__031_L-1)
     98  183d		       29		      .byte.b	<(LEVEL__031_R-1)
     99  183e		       68		      .byte.b	<(LEVEL__032_L-1)
    100  183f		       a0		      .byte.b	<(LEVEL__032_R-1)
    101  1840		       e4		      .byte.b	<(LEVEL__033_L-1)
    102  1841		       2e		      .byte.b	<(LEVEL__033_R-1)
    103  1842		       6e		      .byte.b	<(LEVEL__034_L-1)
    104  1843		       ff		      .byte.b	<(LEVEL__034_R-1)
    105  1844		       48		      .byte.b	<(LEVEL__035_L-1)
    106  1845		       8d		      .byte.b	<(LEVEL__035_R-1)
    107  1846		       cd		      .byte.b	<(LEVEL__036_L-1)
    108  1847		       03		      .byte.b	<(LEVEL__036_R-1)
    109  1848		       49		      .byte.b	<(LEVEL__037_L-1)
    110  1849		       86		      .byte.b	<(LEVEL__037_R-1)
    111  184a		       cf		      .byte.b	<(LEVEL__038_L-1)
    112  184b		       17		      .byte.b	<(LEVEL__038_R-1)
    113  184c		       66		      .byte.b	<(LEVEL__039_L-1)
    114  184d		       b5		      .byte.b	<(LEVEL__039_R-1)
    115  184e		       0f		      .byte.b	<(LEVEL__040_L-1)
    116  184f		       56		      .byte.b	<(LEVEL__040_R-1)
    117  1850
    118  1850		       9d		      .byte.b	<(LEVEL__041_L-1)
    119  1851		       e7		      .byte.b	<(LEVEL__041_R-1)
    120  1852		       2e		      .byte.b	<(LEVEL__042_L-1)
    121  1853		       7c		      .byte.b	<(LEVEL__042_R-1)
    122  1854		       d4		      .byte.b	<(LEVEL__043_L-1)
    123  1855		       21		      .byte.b	<(LEVEL__043_R-1)
    124  1856		       6d		      .byte.b	<(LEVEL__044_L-1)
    125  1857		       a5		      .byte.b	<(LEVEL__044_R-1)
    126  1858		       f5		      .byte.b	<(LEVEL__045_L-1)
    127  1859		       43		      .byte.b	<(LEVEL__045_R-1)
    128  185a		       8d		      .byte.b	<(LEVEL__046_L-1)
    129  185b		       da		      .byte.b	<(LEVEL__046_R-1)
    130  185c		       1f		      .byte.b	<(LEVEL__047_L-1)
    131  185d		       75		      .byte.b	<(LEVEL__047_R-1)
    132  185e		       ff		      .byte.b	<(LEVEL__048_L-1)
    133  185f		       4b		      .byte.b	<(LEVEL__048_R-1)
    134  1860		       96		      .byte.b	<(LEVEL__049_L-1)
    135  1861		       e8		      .byte.b	<(LEVEL__049_R-1)
    136  1862
    137  1862		       2b		      .byte.b	<(LEVEL__050_L-1)
    138  1863		       78		      .byte.b	<(LEVEL__050_R-1)
    139  1864		       b1		      .byte.b	<(LEVEL__051_L-1)
    140  1865		       04		      .byte.b	<(LEVEL__051_R-1)
    141  1866		       55		      .byte.b	<(LEVEL__052_L-1)
    142  1867		       8f		      .byte.b	<(LEVEL__052_R-1)
    143  1868		       d7		      .byte.b	<(LEVEL__053_L-1)
    144  1869		       2c		      .byte.b	<(LEVEL__053_R-1)
    145  186a		       79		      .byte.b	<(LEVEL__054_L-1)
    146  186b		       c5		      .byte.b	<(LEVEL__054_R-1)
    147  186c		       0e		      .byte.b	<(LEVEL__055_L-1)
    148  186d		       68		      .byte.b	<(LEVEL__055_R-1)
    149  186e		       bd		      .byte.b	<(LEVEL__056_L-1)
    150  186f		       17		      .byte.b	<(LEVEL__056_R-1)
    151  1870		       72		      .byte.b	<(LEVEL__057_L-1)
    152  1871		       c8		      .byte.b	<(LEVEL__057_R-1)
    153  1872		       11		      .byte.b	<(LEVEL__058_L-1)
    154  1873		       56		      .byte.b	<(LEVEL__058_R-1)
    155  1874		       a6		      .byte.b	<(LEVEL__059_L-1)
    156  1875		       f8		      .byte.b	<(LEVEL__059_R-1)
    157  1876
    158  1876		       ff		      .byte.b	<(LEVEL__060_R-1)
    159  1877		       9b		      .byte.b	<(LEVEL__061_R-1)
    160  1878		       47		      .byte.b	<(LEVEL__061_L-1)
    161  1879		       e4		      .byte.b	<(LEVEL__062_L-1)
    162  187a		       3b		      .byte.b	<(LEVEL__062_R-1)
    163  187b		       87		      .byte.b	<(LEVEL__063_L-1)
    164  187c		       d7		      .byte.b	<(LEVEL__063_R-1)
    165  187d		       84		      .byte.b	<(LEVEL__064_R-1)
    166  187e		       29		      .byte.b	<(LEVEL__064_L-1)
    167  187f		       28		      .byte.b	<(LEVEL__065_R-1)
    168  1880		       d0		      .byte.b	<(LEVEL__065_L-1)
    169  1881		       ca		      .byte.b	<(LEVEL__066_R-1)
    170  1882		       70		      .byte.b	<(LEVEL__066_L-1)
    171  1883		       6d		      .byte.b	<(LEVEL__067_R-1)
    172  1884		       20		      .byte.b	<(LEVEL__067_L-1)
    173  1885		       26		      .byte.b	<(LEVEL__068_R-1)
    174  1886		       d2		      .byte.b	<(LEVEL__068_L-1)
    175  1887		       ca		      .byte.b	<(LEVEL__069_R-1)
    176  1888		       7c		      .byte.b	<(LEVEL__069_L-1)
    177  1889
    178  1889		       e8		      .byte.b	<(LEVEL__103_Arielle-1)
    179  188a		       a1		      .byte.b	<(LEVEL__103_Ajalae-1)
    180  188b		       56		      .byte.b	<(LEVEL__103_Adin-1)
    181  188c		       e8		      .byte.b	<(LEVEL__102_Raven-1)
    182  188d		       a4		      .byte.b	<(LEVEL__102_Oralia-1)
    183  188e		       ff		      .byte.b	<(LEVEL__102_Natalie-1)
    184  188f		       45		      .byte.b	<(LEVEL__102_Mirabel-1)
    185  1890		       38		      .byte.b	<(LEVEL__1XJH_Tara_Gelson-1)
    186  1891		       72		      .byte.b	<(LEVEL__1R7X_Alison-1)
    187  1892		       9f		      .byte.b	<(LEVEL__1KWD_Cecile_Clayworth-1)
    188  1893		       d3		      .byte.b	<(LEVEL__1EKT_Samantha_Gelson-1)
    189  1894		       0c		      .byte.b	<(LEVEL__0VM5_Andrea_Wadd-1)
    190  1895		       39		      .byte.b	<(LEVEL__0PAL_Jill_Leatherby-1)
    191  1896		       63		      .byte.b	<(LEVEL__0IZ1_Sophia-1)
    192  1897		       8e		      .byte.b	<(LEVEL__0CNH_Alice-1)
    193  1898		       18		      .byte.b	<(LEVEL__122_Maya-1)
    194  1899
    195  1899		       00 99	   MAX_LEVEL  =	* - LevelInfoLO
 $99 LEVELS INSTALLED
    196  1899					      ECHO	MAX_LEVEL, "LEVELS INSTALLED"
    197  1899				   LevelInfoHI
    198  1899
    199  1899		       ef		      .byte.b	>(LEVEL__001_L-1)
    200  189a		       f0		      .byte.b	>(LEVEL__001_R-1)
    201  189b		       f0		      .byte.b	>(LEVEL__002_L-1)
    202  189c		       f0		      .byte.b	>(LEVEL__002_R-1)
    203  189d		       f0		      .byte.b	>(LEVEL__003_L-1)
    204  189e		       f0		      .byte.b	>(LEVEL__003_R-1)
    205  189f		       f0		      .byte.b	>(LEVEL__004_L-1)
    206  18a0		       f0		      .byte.b	>(LEVEL__004_R-1)
    207  18a1		       f0		      .byte.b	>(LEVEL__005_L-1)
    208  18a2		       f1		      .byte.b	>(LEVEL__005_R-1)
    209  18a3		       f1		      .byte.b	>(LEVEL__006_L-1)
    210  18a4		       f1		      .byte.b	>(LEVEL__006_R-1)
    211  18a5		       f1		      .byte.b	>(LEVEL__007_L-1)
    212  18a6		       f2		      .byte.b	>(LEVEL__007_R-1)
    213  18a7		       f2		      .byte.b	>(LEVEL__008_L-1)
    214  18a8		       f2		      .byte.b	>(LEVEL__008_R-1)
    215  18a9		       f2		      .byte.b	>(LEVEL__009_L-1)
    216  18aa		       f2		      .byte.b	>(LEVEL__009_R-1)
    217  18ab		       f3		      .byte.b	>(LEVEL__010_L-1)
    218  18ac		       f3		      .byte.b	>(LEVEL__010_R-1)
    219  18ad		       f3		      .byte.b	>(LEVEL__011_L-1)
    220  18ae		       f3		      .byte.b	>(LEVEL__011_R-1)
    221  18af		       f3		      .byte.b	>(LEVEL__012_L-1)
    222  18b0		       f4		      .byte.b	>(LEVEL__012_R-1)
    223  18b1		       f4		      .byte.b	>(LEVEL__013_L-1)
    224  18b2		       f4		      .byte.b	>(LEVEL__013_R-1)
    225  18b3		       f4		      .byte.b	>(LEVEL__014_L-1)
    226  18b4		       f5		      .byte.b	>(LEVEL__014_R-1)
    227  18b5		       f5		      .byte.b	>(LEVEL__015_L-1)
    228  18b6		       f5		      .byte.b	>(LEVEL__015_R-1)
    229  18b7		       f5		      .byte.b	>(LEVEL__016_L-1)
    230  18b8		       f5		      .byte.b	>(LEVEL__016_R-1)
    231  18b9		       f6		      .byte.b	>(LEVEL__017_L-1)
    232  18ba		       f6		      .byte.b	>(LEVEL__017_R-1)
    233  18bb		       f6		      .byte.b	>(LEVEL__018_L-1)
    234  18bc		       f6		      .byte.b	>(LEVEL__018_R-1)
    235  18bd		       f7		      .byte.b	>(LEVEL__019_L-1)
    236  18be		       f7		      .byte.b	>(LEVEL__019_R-1)
    237  18bf		       ef		      .byte.b	>(LEVEL__020_L-1)
    238  18c0		       f0		      .byte.b	>(LEVEL__020_R-1)
    239  18c1		       f0		      .byte.b	>(LEVEL__021_L-1)
    240  18c2		       f0		      .byte.b	>(LEVEL__021_R-1)
    241  18c3		       f1		      .byte.b	>(LEVEL__022_L-1)
    242  18c4		       f1		      .byte.b	>(LEVEL__022_R-1)
    243  18c5		       f1		      .byte.b	>(LEVEL__023_L-1)
    244  18c6		       f1		      .byte.b	>(LEVEL__023_R-1)
    245  18c7		       f2		      .byte.b	>(LEVEL__024_L-1)
    246  18c8		       f2		      .byte.b	>(LEVEL__024_R-1)
    247  18c9		       f2		      .byte.b	>(LEVEL__025_L-1)
    248  18ca		       f2		      .byte.b	>(LEVEL__025_R-1)
    249  18cb		       f3		      .byte.b	>(LEVEL__026_L-1)
    250  18cc		       f3		      .byte.b	>(LEVEL__026_R-1)
    251  18cd		       f3		      .byte.b	>(LEVEL__027_L-1)
    252  18ce		       f3		      .byte.b	>(LEVEL__027_R-1)
    253  18cf		       f4		      .byte.b	>(LEVEL__028_L-1)
    254  18d0		       f4		      .byte.b	>(LEVEL__028_R-1)
    255  18d1		       f4		      .byte.b	>(LEVEL__029_L-1)
    256  18d2		       f4		      .byte.b	>(LEVEL__029_R-1)
    257  18d3		       f5		      .byte.b	>(LEVEL__030_L-1)
    258  18d4		       f5		      .byte.b	>(LEVEL__030_R-1)
    259  18d5		       f5		      .byte.b	>(LEVEL__031_L-1)
    260  18d6		       f6		      .byte.b	>(LEVEL__031_R-1)
    261  18d7		       f6		      .byte.b	>(LEVEL__032_L-1)
    262  18d8		       f6		      .byte.b	>(LEVEL__032_R-1)
    263  18d9		       f6		      .byte.b	>(LEVEL__033_L-1)
    264  18da		       f7		      .byte.b	>(LEVEL__033_R-1)
    265  18db		       f7		      .byte.b	>(LEVEL__034_L-1)
    266  18dc		       ef		      .byte.b	>(LEVEL__034_R-1)
    267  18dd		       f0		      .byte.b	>(LEVEL__035_L-1)
    268  18de		       f0		      .byte.b	>(LEVEL__035_R-1)
    269  18df		       f0		      .byte.b	>(LEVEL__036_L-1)
    270  18e0		       f1		      .byte.b	>(LEVEL__036_R-1)
    271  18e1		       f1		      .byte.b	>(LEVEL__037_L-1)
    272  18e2		       f1		      .byte.b	>(LEVEL__037_R-1)
    273  18e3		       f1		      .byte.b	>(LEVEL__038_L-1)
    274  18e4		       f2		      .byte.b	>(LEVEL__038_R-1)
    275  18e5		       f2		      .byte.b	>(LEVEL__039_L-1)
    276  18e6		       f2		      .byte.b	>(LEVEL__039_R-1)
    277  18e7		       f3		      .byte.b	>(LEVEL__040_L-1)
    278  18e8		       f3		      .byte.b	>(LEVEL__040_R-1)
    279  18e9
    280  18e9		       f3		      .byte.b	>(LEVEL__041_L-1)
    281  18ea		       f3		      .byte.b	>(LEVEL__041_R-1)
    282  18eb		       f4		      .byte.b	>(LEVEL__042_L-1)
    283  18ec		       f4		      .byte.b	>(LEVEL__042_R-1)
    284  18ed		       f4		      .byte.b	>(LEVEL__043_L-1)
    285  18ee		       f5		      .byte.b	>(LEVEL__043_R-1)
    286  18ef		       f5		      .byte.b	>(LEVEL__044_L-1)
    287  18f0		       f5		      .byte.b	>(LEVEL__044_R-1)
    288  18f1		       f5		      .byte.b	>(LEVEL__045_L-1)
    289  18f2		       f6		      .byte.b	>(LEVEL__045_R-1)
    290  18f3		       f6		      .byte.b	>(LEVEL__046_L-1)
    291  18f4		       f6		      .byte.b	>(LEVEL__046_R-1)
    292  18f5		       f7		      .byte.b	>(LEVEL__047_L-1)
    293  18f6		       f7		      .byte.b	>(LEVEL__047_R-1)
    294  18f7		       ef		      .byte.b	>(LEVEL__048_L-1)
    295  18f8		       f0		      .byte.b	>(LEVEL__048_R-1)
    296  18f9		       f0		      .byte.b	>(LEVEL__049_L-1)
    297  18fa		       f0		      .byte.b	>(LEVEL__049_R-1)
    298  18fb
    299  18fb		       f1		      .byte.b	>(LEVEL__050_L-1)
    300  18fc		       f1		      .byte.b	>(LEVEL__050_R-1)
    301  18fd		       f1		      .byte.b	>(LEVEL__051_L-1)
    302  18fe		       f2		      .byte.b	>(LEVEL__051_R-1)
    303  18ff		       f2		      .byte.b	>(LEVEL__052_L-1)
    304  1900		       f2		      .byte.b	>(LEVEL__052_R-1)
    305  1901		       f2		      .byte.b	>(LEVEL__053_L-1)
    306  1902		       f3		      .byte.b	>(LEVEL__053_R-1)
    307  1903		       f3		      .byte.b	>(LEVEL__054_L-1)
    308  1904		       f3		      .byte.b	>(LEVEL__054_R-1)
    309  1905		       f4		      .byte.b	>(LEVEL__055_L-1)
    310  1906		       f4		      .byte.b	>(LEVEL__055_R-1)
    311  1907		       f4		      .byte.b	>(LEVEL__056_L-1)
    312  1908		       f5		      .byte.b	>(LEVEL__056_R-1)
    313  1909		       f5		      .byte.b	>(LEVEL__057_L-1)
    314  190a		       f5		      .byte.b	>(LEVEL__057_R-1)
    315  190b		       f6		      .byte.b	>(LEVEL__058_L-1)
    316  190c		       f6		      .byte.b	>(LEVEL__058_R-1)
    317  190d		       f6		      .byte.b	>(LEVEL__059_L-1)
    318  190e		       f6		      .byte.b	>(LEVEL__059_R-1)
    319  190f
    320  190f		       ef		      .byte.b	>(LEVEL__060_R-1)
    321  1910		       f0		      .byte.b	>(LEVEL__061_R-1)
    322  1911		       f0		      .byte.b	>(LEVEL__061_L-1)
    323  1912		       f0		      .byte.b	>(LEVEL__062_L-1)
    324  1913		       f1		      .byte.b	>(LEVEL__062_R-1)
    325  1914		       f1		      .byte.b	>(LEVEL__063_L-1)
    326  1915		       f1		      .byte.b	>(LEVEL__063_R-1)
    327  1916		       f2		      .byte.b	>(LEVEL__064_R-1)
    328  1917		       f2		      .byte.b	>(LEVEL__064_L-1)
    329  1918		       f3		      .byte.b	>(LEVEL__065_R-1)
    330  1919		       f2		      .byte.b	>(LEVEL__065_L-1)
    331  191a		       f3		      .byte.b	>(LEVEL__066_R-1)
    332  191b		       f3		      .byte.b	>(LEVEL__066_L-1)
    333  191c		       f4		      .byte.b	>(LEVEL__067_R-1)
    334  191d		       f4		      .byte.b	>(LEVEL__067_L-1)
    335  191e		       f5		      .byte.b	>(LEVEL__068_R-1)
    336  191f		       f4		      .byte.b	>(LEVEL__068_L-1)
    337  1920		       f5		      .byte.b	>(LEVEL__069_R-1)
    338  1921		       f5		      .byte.b	>(LEVEL__069_L-1)
    339  1922
    340  1922		       f1		      .byte.b	>(LEVEL__103_Arielle-1)
    341  1923		       f1		      .byte.b	>(LEVEL__103_Ajalae-1)
    342  1924		       f1		      .byte.b	>(LEVEL__103_Adin-1)
    343  1925		       f0		      .byte.b	>(LEVEL__102_Raven-1)
    344  1926		       f0		      .byte.b	>(LEVEL__102_Oralia-1)
    345  1927		       ef		      .byte.b	>(LEVEL__102_Natalie-1)
    346  1928		       f0		      .byte.b	>(LEVEL__102_Mirabel-1)
    347  1929		       f2		      .byte.b	>(LEVEL__1XJH_Tara_Gelson-1)
    348  192a		       f2		      .byte.b	>(LEVEL__1R7X_Alison-1)
    349  192b		       f2		      .byte.b	>(LEVEL__1KWD_Cecile_Clayworth-1)
    350  192c		       f2		      .byte.b	>(LEVEL__1EKT_Samantha_Gelson-1)
    351  192d		       f3		      .byte.b	>(LEVEL__0VM5_Andrea_Wadd-1)
    352  192e		       f3		      .byte.b	>(LEVEL__0PAL_Jill_Leatherby-1)
    353  192f		       f3		      .byte.b	>(LEVEL__0IZ1_Sophia-1)
    354  1930		       f3		      .byte.b	>(LEVEL__0CNH_Alice-1)
    355  1931		       f6		      .byte.b	>(LEVEL__122_Maya-1)
    356  1932
    357  1932				  -	      IF	(* - LevelInfoHI != MAX_LEVEL)
    358  1932				  -	      ECHO	"ERROR: Incorrect LevelInfoHI table!"
    359  1932				  -	      ERR
    360  1932					      ENDIF
    361  1932
    362  1932				   LevelInfoBANK
    363  1932
    364  1932		       04		      .byte.b	BANK_LEVEL__001_L
    365  1933		       04		      .byte.b	BANK_LEVEL__001_R
    366  1934		       04		      .byte.b	BANK_LEVEL__002_L
    367  1935		       04		      .byte.b	BANK_LEVEL__002_R
    368  1936		       04		      .byte.b	BANK_LEVEL__003_L
    369  1937		       04		      .byte.b	BANK_LEVEL__003_R
    370  1938		       04		      .byte.b	BANK_LEVEL__004_L
    371  1939		       04		      .byte.b	BANK_LEVEL__004_R
    372  193a		       04		      .byte.b	BANK_LEVEL__005_L
    373  193b		       04		      .byte.b	BANK_LEVEL__005_R
    374  193c		       04		      .byte.b	BANK_LEVEL__006_L
    375  193d		       04		      .byte.b	BANK_LEVEL__006_R
    376  193e		       04		      .byte.b	BANK_LEVEL__007_L
    377  193f		       04		      .byte.b	BANK_LEVEL__007_R
    378  1940		       04		      .byte.b	BANK_LEVEL__008_L
    379  1941		       04		      .byte.b	BANK_LEVEL__008_R
    380  1942		       04		      .byte.b	BANK_LEVEL__009_L
    381  1943		       04		      .byte.b	BANK_LEVEL__009_R
    382  1944		       04		      .byte.b	BANK_LEVEL__010_L
    383  1945		       04		      .byte.b	BANK_LEVEL__010_R
    384  1946		       04		      .byte.b	BANK_LEVEL__011_L
    385  1947		       04		      .byte.b	BANK_LEVEL__011_R
    386  1948		       04		      .byte.b	BANK_LEVEL__012_L
    387  1949		       04		      .byte.b	BANK_LEVEL__012_R
    388  194a		       04		      .byte.b	BANK_LEVEL__013_L
    389  194b		       04		      .byte.b	BANK_LEVEL__013_R
    390  194c		       04		      .byte.b	BANK_LEVEL__014_L
    391  194d		       04		      .byte.b	BANK_LEVEL__014_R
    392  194e		       04		      .byte.b	BANK_LEVEL__015_L
    393  194f		       04		      .byte.b	BANK_LEVEL__015_R
    394  1950		       04		      .byte.b	BANK_LEVEL__016_L
    395  1951		       04		      .byte.b	BANK_LEVEL__016_R
    396  1952		       04		      .byte.b	BANK_LEVEL__017_L
    397  1953		       04		      .byte.b	BANK_LEVEL__017_R
    398  1954		       04		      .byte.b	BANK_LEVEL__018_L
    399  1955		       04		      .byte.b	BANK_LEVEL__018_R
    400  1956		       04		      .byte.b	BANK_LEVEL__019_L
    401  1957		       04		      .byte.b	BANK_LEVEL__019_R
    402  1958		       05		      .byte.b	BANK_LEVEL__020_L
    403  1959		       05		      .byte.b	BANK_LEVEL__020_R
    404  195a		       05		      .byte.b	BANK_LEVEL__021_L
    405  195b		       05		      .byte.b	BANK_LEVEL__021_R
    406  195c		       05		      .byte.b	BANK_LEVEL__022_L
    407  195d		       05		      .byte.b	BANK_LEVEL__022_R
    408  195e		       05		      .byte.b	BANK_LEVEL__023_L
    409  195f		       05		      .byte.b	BANK_LEVEL__023_R
    410  1960		       05		      .byte.b	BANK_LEVEL__024_L
    411  1961		       05		      .byte.b	BANK_LEVEL__024_R
    412  1962		       05		      .byte.b	BANK_LEVEL__025_L
    413  1963		       05		      .byte.b	BANK_LEVEL__025_R
    414  1964		       05		      .byte.b	BANK_LEVEL__026_L
    415  1965		       05		      .byte.b	BANK_LEVEL__026_R
    416  1966		       05		      .byte.b	BANK_LEVEL__027_L
    417  1967		       05		      .byte.b	BANK_LEVEL__027_R
    418  1968		       05		      .byte.b	BANK_LEVEL__028_L
    419  1969		       05		      .byte.b	BANK_LEVEL__028_R
    420  196a		       05		      .byte.b	BANK_LEVEL__029_L
    421  196b		       05		      .byte.b	BANK_LEVEL__029_R
    422  196c		       05		      .byte.b	BANK_LEVEL__030_L
    423  196d		       05		      .byte.b	BANK_LEVEL__030_R
    424  196e		       05		      .byte.b	BANK_LEVEL__031_L
    425  196f		       05		      .byte.b	BANK_LEVEL__031_R
    426  1970		       05		      .byte.b	BANK_LEVEL__032_L
    427  1971		       05		      .byte.b	BANK_LEVEL__032_R
    428  1972		       05		      .byte.b	BANK_LEVEL__033_L
    429  1973		       05		      .byte.b	BANK_LEVEL__033_R
    430  1974		       05		      .byte.b	BANK_LEVEL__034_L
    431  1975		       06		      .byte.b	BANK_LEVEL__034_R
    432  1976		       06		      .byte.b	BANK_LEVEL__035_L
    433  1977		       06		      .byte.b	BANK_LEVEL__035_R
    434  1978		       06		      .byte.b	BANK_LEVEL__036_L
    435  1979		       06		      .byte.b	BANK_LEVEL__036_R
    436  197a		       06		      .byte.b	BANK_LEVEL__037_L
    437  197b		       06		      .byte.b	BANK_LEVEL__037_R
    438  197c		       06		      .byte.b	BANK_LEVEL__038_L
    439  197d		       06		      .byte.b	BANK_LEVEL__038_R
    440  197e		       06		      .byte.b	BANK_LEVEL__039_L
    441  197f		       06		      .byte.b	BANK_LEVEL__039_R
    442  1980		       06		      .byte.b	BANK_LEVEL__040_L
    443  1981		       06		      .byte.b	BANK_LEVEL__040_R
    444  1982
    445  1982		       06		      .byte.b	BANK_LEVEL__041_L
    446  1983		       06		      .byte.b	BANK_LEVEL__041_R
    447  1984		       06		      .byte.b	BANK_LEVEL__042_L
    448  1985		       06		      .byte.b	BANK_LEVEL__042_R
    449  1986		       06		      .byte.b	BANK_LEVEL__043_L
    450  1987		       06		      .byte.b	BANK_LEVEL__043_R
    451  1988		       06		      .byte.b	BANK_LEVEL__044_L
    452  1989		       06		      .byte.b	BANK_LEVEL__044_R
    453  198a		       06		      .byte.b	BANK_LEVEL__045_L
    454  198b		       06		      .byte.b	BANK_LEVEL__045_R
    455  198c		       06		      .byte.b	BANK_LEVEL__046_L
    456  198d		       06		      .byte.b	BANK_LEVEL__046_R
    457  198e		       06		      .byte.b	BANK_LEVEL__047_L
    458  198f		       06		      .byte.b	BANK_LEVEL__047_R
    459  1990		       07		      .byte.b	BANK_LEVEL__048_L
    460  1991		       07		      .byte.b	BANK_LEVEL__048_R
    461  1992		       07		      .byte.b	BANK_LEVEL__049_L
    462  1993		       07		      .byte.b	BANK_LEVEL__049_R
    463  1994
    464  1994		       07		      .byte.b	BANK_LEVEL__050_L
    465  1995		       07		      .byte.b	BANK_LEVEL__050_R
    466  1996		       07		      .byte.b	BANK_LEVEL__051_L
    467  1997		       07		      .byte.b	BANK_LEVEL__051_R
    468  1998		       07		      .byte.b	BANK_LEVEL__052_L
    469  1999		       07		      .byte.b	BANK_LEVEL__052_R
    470  199a		       07		      .byte.b	BANK_LEVEL__053_L
    471  199b		       07		      .byte.b	BANK_LEVEL__053_R
    472  199c		       07		      .byte.b	BANK_LEVEL__054_L
    473  199d		       07		      .byte.b	BANK_LEVEL__054_R
    474  199e		       07		      .byte.b	BANK_LEVEL__055_L
    475  199f		       07		      .byte.b	BANK_LEVEL__055_R
    476  19a0		       07		      .byte.b	BANK_LEVEL__056_L
    477  19a1		       07		      .byte.b	BANK_LEVEL__056_R
    478  19a2		       07		      .byte.b	BANK_LEVEL__057_L
    479  19a3		       07		      .byte.b	BANK_LEVEL__057_R
    480  19a4		       07		      .byte.b	BANK_LEVEL__058_L
    481  19a5		       07		      .byte.b	BANK_LEVEL__058_R
    482  19a6		       07		      .byte.b	BANK_LEVEL__059_L
    483  19a7		       07		      .byte.b	BANK_LEVEL__059_R
    484  19a8
    485  19a8		       08		      .byte.b	BANK_LEVEL__060_R
    486  19a9		       08		      .byte.b	BANK_LEVEL__061_R
    487  19aa		       08		      .byte.b	BANK_LEVEL__061_L
    488  19ab		       08		      .byte.b	BANK_LEVEL__062_L
    489  19ac		       08		      .byte.b	BANK_LEVEL__062_R
    490  19ad		       08		      .byte.b	BANK_LEVEL__063_L
    491  19ae		       08		      .byte.b	BANK_LEVEL__063_R
    492  19af		       08		      .byte.b	BANK_LEVEL__064_R
    493  19b0		       08		      .byte.b	BANK_LEVEL__064_L
    494  19b1		       08		      .byte.b	BANK_LEVEL__065_R
    495  19b2		       08		      .byte.b	BANK_LEVEL__065_L
    496  19b3		       08		      .byte.b	BANK_LEVEL__066_R
    497  19b4		       08		      .byte.b	BANK_LEVEL__066_L
    498  19b5		       08		      .byte.b	BANK_LEVEL__067_R
    499  19b6		       08		      .byte.b	BANK_LEVEL__067_L
    500  19b7		       08		      .byte.b	BANK_LEVEL__068_R
    501  19b8		       08		      .byte.b	BANK_LEVEL__068_L
    502  19b9		       08		      .byte.b	BANK_LEVEL__069_R
    503  19ba		       08		      .byte.b	BANK_LEVEL__069_L
    504  19bb
    505  19bb		       09		      .byte.b	BANK_LEVEL__103_Arielle
    506  19bc		       09		      .byte.b	BANK_LEVEL__103_Ajalae
    507  19bd		       09		      .byte.b	BANK_LEVEL__103_Adin
    508  19be		       09		      .byte.b	BANK_LEVEL__102_Raven
    509  19bf		       09		      .byte.b	BANK_LEVEL__102_Oralia
    510  19c0		       09		      .byte.b	BANK_LEVEL__102_Natalie
    511  19c1		       09		      .byte.b	BANK_LEVEL__102_Mirabel
    512  19c2		       09		      .byte.b	BANK_LEVEL__1XJH_Tara_Gelson
    513  19c3		       09		      .byte.b	BANK_LEVEL__1R7X_Alison
    514  19c4		       09		      .byte.b	BANK_LEVEL__1KWD_Cecile_Clayworth
    515  19c5		       09		      .byte.b	BANK_LEVEL__1EKT_Samantha_Gelson
    516  19c6		       09		      .byte.b	BANK_LEVEL__0VM5_Andrea_Wadd
    517  19c7		       09		      .byte.b	BANK_LEVEL__0PAL_Jill_Leatherby
    518  19c8		       09		      .byte.b	BANK_LEVEL__0IZ1_Sophia
    519  19c9		       09		      .byte.b	BANK_LEVEL__0CNH_Alice
    520  19ca
    521  19ca		       08		      .byte.b	BANK_LEVEL__122_Maya
    522  19cb
    523  19cb				  -	      IF	(* - LevelInfoBANK != MAX_LEVEL)
    524  19cb				  -	      ECHO	"ERROR: Incorrect LevelInfoBANK table!"
    525  19cb				  -	      ERR
    526  19cb					      ENDIF
    527  19cb
    528  19cb
    529  19cb
    530  19cb				   finX
    531  19cb							; now put the soil in - fill from the outsides
    532  19cb
    533  19cb		       a9 01		      lda	#CHARACTER_SOIL
    534  19cd		       85 8b		      sta	POS_Type
    535  19cf
    536  19cf		       a9 15		      lda	#SIZE_BOARD_Y-1
    537  19d1		       85 88		      sta	POS_Y
    538  19d3
    539  19d3		       a9 27	   xlin       lda	#SIZE_BOARD_X-1
    540  19d5		       85 87		      sta	POS_X
    541  19d7		       20 26 f8    zap1       jsr	GetBoardCharacter__CALL_FROM_RAM__
    542  19da		       c9 01		      cmp	#CHARACTER_SOIL
    543  19dc		       f0 07		      beq	kg2a
    544  19de		       c9 00		      cmp	#0
    545  19e0		       d0 07		      bne	endzap1
    546  19e2		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    547  19e5		       c6 87	   kg2a       dec	POS_X
    548  19e7		       10 ee		      bpl	zap1
    549  19e9
    550  19e9		       a9 00	   endzap1    lda	#0
    551  19eb		       85 87		      sta	POS_X
    552  19ed		       20 26 f8    zap2       jsr	GetBoardCharacter__CALL_FROM_RAM__
    553  19f0		       c9 01		      cmp	#CHARACTER_SOIL
    554  19f2		       f0 07		      beq	kg2
    555  19f4		       c9 00		      cmp	#0
    556  19f6		       d0 0b		      bne	endzap2
    557  19f8		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    558  19fb		       e6 87	   kg2	      inc	POS_X
    559  19fd		       a5 87		      lda	POS_X
    560  19ff		       c9 28		      cmp	#SIZE_BOARD_X
    561  1a01		       d0 ea		      bne	zap2
    562  1a03
    563  1a03		       c6 88	   endzap2    dec	POS_Y
    564  1a05		       10 cc		      bpl	xlin
    565  1a07
    566  1a07
    567  1a07		       a9 27		      lda	#SIZE_BOARD_X-1
    568  1a09		       85 87		      sta	POS_X
    569  1a0b
    570  1a0b		       a9 15	   ylin       lda	#SIZE_BOARD_Y-1
    571  1a0d		       85 88		      sta	POS_Y
    572  1a0f		       20 26 f8    zapy1      jsr	GetBoardCharacter__CALL_FROM_RAM__
    573  1a12		       c9 01		      cmp	#CHARACTER_SOIL
    574  1a14		       f0 07		      beq	kg3
    575  1a16		       c9 00		      cmp	#0
    576  1a18		       d0 07		      bne	endzapy1
    577  1a1a		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    578  1a1d		       c6 88	   kg3	      dec	POS_Y
    579  1a1f		       10 ee		      bpl	zapy1
    580  1a21
    581  1a21		       a9 00	   endzapy1   lda	#0
    582  1a23		       85 88		      sta	POS_Y
    583  1a25		       20 26 f8    zapy2      jsr	GetBoardCharacter__CALL_FROM_RAM__
    584  1a28		       c9 01		      cmp	#CHARACTER_SOIL
    585  1a2a		       f0 07		      beq	kg3b
    586  1a2c		       c9 00		      cmp	#0
    587  1a2e		       d0 0b		      bne	endzapy2
    588  1a30		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    589  1a33		       e6 88	   kg3b       inc	POS_Y
    590  1a35		       a5 88		      lda	POS_Y
    591  1a37		       c9 16		      cmp	#SIZE_BOARD_Y
    592  1a39		       d0 ea		      bne	zapy2
    593  1a3b
    594  1a3b		       c6 87	   endzapy2   dec	POS_X
    595  1a3d		       10 cc		      bpl	ylin
    596  1a3f		       60		      rts
    597  1a40
    598  1a40							;A	 steel wall
    599  1a40							;B	 soil (surround)
    600  1a40							;C	 box
    601  1a40
    602  1a40					      MAC	ntscpal
    603  1a40					      .byte	{1}+{2}
    604  1a40					      NTSC_TO_PAL	{1},{2}
    605  1a40					      ENDM		; {col} {intensity}
    606  1a40
    607  1a40
    608  1a40							; NTSC Colour names...
    609  1a40
    610  1a40
    611  1a40		       00 00	   GREY       =	0
    612  1a40		       00 10	   YELLOW     =	$10
    613  1a40		       00 20	   ORANGE     =	$20
    614  1a40		       00 30	   RED	      =	$30
    615  1a40		       00 40	   PINK       =	$40
    616  1a40		       00 50	   PURPLE     =	$50
    617  1a40		       00 60	   VIOLET     =	$60
    618  1a40		       00 70	   BLUE       =	$70
    619  1a40		       00 80	   AQUA       =	$80
    620  1a40		       00 90	   SKYBLUE    =	$90
    621  1a40		       00 a0	   TEAL       =	$A0
    622  1a40		       00 b0	   GREEN      =	$B0
    623  1a40		       00 c0	   LIME       =	$C0
    624  1a40		       00 d0	   OLIVE      =	$D0
    625  1a40		       00 e0	   TAN	      =	$E0
    626  1a40		       00 f0	   BROWN      =	$F0
    627  1a40
    628  1a40
    629  1a40
    630  1a40
    631  1a40							;c0d4de greens
    632  1a40							;7b3daa
    633  1a40							;559e4f very nice
    634  1a40							;a6e773
    635  1a40							;8d4697
    636  1a40							;ffcb65
    637  1a40							;ca6532
    638  1a40							;190cb2
    639  1a40							;a75329
    640  1a40							;b85c2e
    641  1a40							;110804
    642  1a40							;1dba5d
    643  1a40							;9af9c8 nice
    644  1a40							;2914be
    645  1a40							;a9549e
    646  1a40							;ab552a
    647  1a40							;bd5e2f
    648  1a40							;92fdca
    649  1a40
    650  1a40
    651  1a40				   C1			;
    652  1a40							; mortar for bricks
      0  1a40					      NTSCPAL	LIME,$8
      1  1a40		       c8		      .byte.b	LIME+$8
      0  1a41					      NTSC_TO_PAL	LIME,$8
      1  1a41				  -	      IF	LIME = 0
      2  1a41				  -	      .byte	LIME+$8
      3  1a41					      ENDIF
      4  1a41				  -	      IF	LIME = $10
      5  1a41				  -	      .byte	$20+$8
      6  1a41					      ENDIF
      7  1a41				  -	      IF	LIME = $20
      8  1a41				  -	      .byte	$40+$8
      9  1a41					      ENDIF
     10  1a41				  -	      IF	LIME = $30
     11  1a41				  -	      .byte	$40+$8
     12  1a41					      ENDIF
     13  1a41				  -	      IF	LIME = $40
     14  1a41				  -	      .byte	$60+$8
     15  1a41					      ENDIF
     16  1a41				  -	      IF	LIME = $50
     17  1a41				  -	      .byte	$80+$8
     18  1a41					      ENDIF
     19  1a41				  -	      IF	LIME = $60
     20  1a41				  -	      .byte	$C0+$8
     21  1a41					      ENDIF
     22  1a41				  -	      IF	LIME = $70
     23  1a41				  -	      .byte	$D0+$8
     24  1a41					      ENDIF
     25  1a41				  -	      IF	LIME = $80
     26  1a41				  -	      .byte	$B0+$8
     27  1a41					      ENDIF
     28  1a41				  -	      IF	LIME = $90
     29  1a41				  -	      .byte	$90+$8
     30  1a41					      ENDIF
     31  1a41				  -	      IF	LIME = $A0
     32  1a41				  -	      .byte	$70+$8
     33  1a41					      ENDIF
     34  1a41				  -	      IF	LIME = $B0
     35  1a41				  -	      .byte	$50+$8
     36  1a41					      ENDIF
     37  1a41					      IF	LIME = $C0
     38  1a41		       38		      .byte.b	$30+$8
     39  1a42					      ENDIF
     40  1a42				  -	      IF	LIME = $D0
     41  1a42				  -	      .byte	$30+$8
     42  1a42					      ENDIF
     43  1a42				  -	      IF	LIME = $E0
     44  1a42				  -	      .byte	$20+$8
     45  1a42					      ENDIF
     46  1a42				  -	      IF	LIME = $F0
     47  1a42				  -	      .byte	$40+$8
     48  1a42					      ENDIF
      0  1a42					      NTSCPAL	VIOLET,$8
      1  1a42		       68		      .byte.b	VIOLET+$8
      0  1a43					      NTSC_TO_PAL	VIOLET,$8
      1  1a43				  -	      IF	VIOLET = 0
      2  1a43				  -	      .byte	VIOLET+$8
      3  1a43					      ENDIF
      4  1a43				  -	      IF	VIOLET = $10
      5  1a43				  -	      .byte	$20+$8
      6  1a43					      ENDIF
      7  1a43				  -	      IF	VIOLET = $20
      8  1a43				  -	      .byte	$40+$8
      9  1a43					      ENDIF
     10  1a43				  -	      IF	VIOLET = $30
     11  1a43				  -	      .byte	$40+$8
     12  1a43					      ENDIF
     13  1a43				  -	      IF	VIOLET = $40
     14  1a43				  -	      .byte	$60+$8
     15  1a43					      ENDIF
     16  1a43				  -	      IF	VIOLET = $50
     17  1a43				  -	      .byte	$80+$8
     18  1a43					      ENDIF
     19  1a43					      IF	VIOLET = $60
     20  1a43		       c8		      .byte.b	$C0+$8
     21  1a44					      ENDIF
     22  1a44				  -	      IF	VIOLET = $70
     23  1a44				  -	      .byte	$D0+$8
     24  1a44					      ENDIF
     25  1a44				  -	      IF	VIOLET = $80
     26  1a44				  -	      .byte	$B0+$8
     27  1a44					      ENDIF
     28  1a44				  -	      IF	VIOLET = $90
     29  1a44				  -	      .byte	$90+$8
     30  1a44					      ENDIF
     31  1a44				  -	      IF	VIOLET = $A0
     32  1a44				  -	      .byte	$70+$8
     33  1a44					      ENDIF
     34  1a44				  -	      IF	VIOLET = $B0
     35  1a44				  -	      .byte	$50+$8
     36  1a44					      ENDIF
     37  1a44				  -	      IF	VIOLET = $C0
     38  1a44				  -	      .byte	$30+$8
     39  1a44					      ENDIF
     40  1a44				  -	      IF	VIOLET = $D0
     41  1a44				  -	      .byte	$30+$8
     42  1a44					      ENDIF
     43  1a44				  -	      IF	VIOLET = $E0
     44  1a44				  -	      .byte	$20+$8
     45  1a44					      ENDIF
     46  1a44				  -	      IF	VIOLET = $F0
     47  1a44				  -	      .byte	$40+$8
     48  1a44					      ENDIF
      0  1a44					      NTSCPAL	BLUE,$8
      1  1a44		       78		      .byte.b	BLUE+$8
      0  1a45					      NTSC_TO_PAL	BLUE,$8
      1  1a45				  -	      IF	BLUE = 0
      2  1a45				  -	      .byte	BLUE+$8
      3  1a45					      ENDIF
      4  1a45				  -	      IF	BLUE = $10
      5  1a45				  -	      .byte	$20+$8
      6  1a45					      ENDIF
      7  1a45				  -	      IF	BLUE = $20
      8  1a45				  -	      .byte	$40+$8
      9  1a45					      ENDIF
     10  1a45				  -	      IF	BLUE = $30
     11  1a45				  -	      .byte	$40+$8
     12  1a45					      ENDIF
     13  1a45				  -	      IF	BLUE = $40
     14  1a45				  -	      .byte	$60+$8
     15  1a45					      ENDIF
     16  1a45				  -	      IF	BLUE = $50
     17  1a45				  -	      .byte	$80+$8
     18  1a45					      ENDIF
     19  1a45				  -	      IF	BLUE = $60
     20  1a45				  -	      .byte	$C0+$8
     21  1a45					      ENDIF
     22  1a45					      IF	BLUE = $70
     23  1a45		       d8		      .byte.b	$D0+$8
     24  1a46					      ENDIF
     25  1a46				  -	      IF	BLUE = $80
     26  1a46				  -	      .byte	$B0+$8
     27  1a46					      ENDIF
     28  1a46				  -	      IF	BLUE = $90
     29  1a46				  -	      .byte	$90+$8
     30  1a46					      ENDIF
     31  1a46				  -	      IF	BLUE = $A0
     32  1a46				  -	      .byte	$70+$8
     33  1a46					      ENDIF
     34  1a46				  -	      IF	BLUE = $B0
     35  1a46				  -	      .byte	$50+$8
     36  1a46					      ENDIF
     37  1a46				  -	      IF	BLUE = $C0
     38  1a46				  -	      .byte	$30+$8
     39  1a46					      ENDIF
     40  1a46				  -	      IF	BLUE = $D0
     41  1a46				  -	      .byte	$30+$8
     42  1a46					      ENDIF
     43  1a46				  -	      IF	BLUE = $E0
     44  1a46				  -	      .byte	$20+$8
     45  1a46					      ENDIF
     46  1a46				  -	      IF	BLUE = $F0
     47  1a46				  -	      .byte	$40+$8
     48  1a46					      ENDIF
      0  1a46					      NTSCPAL	PINK,$8
      1  1a46		       48		      .byte.b	PINK+$8
      0  1a47					      NTSC_TO_PAL	PINK,$8
      1  1a47				  -	      IF	PINK = 0
      2  1a47				  -	      .byte	PINK+$8
      3  1a47					      ENDIF
      4  1a47				  -	      IF	PINK = $10
      5  1a47				  -	      .byte	$20+$8
      6  1a47					      ENDIF
      7  1a47				  -	      IF	PINK = $20
      8  1a47				  -	      .byte	$40+$8
      9  1a47					      ENDIF
     10  1a47				  -	      IF	PINK = $30
     11  1a47				  -	      .byte	$40+$8
     12  1a47					      ENDIF
     13  1a47					      IF	PINK = $40
     14  1a47		       68		      .byte.b	$60+$8
     15  1a48					      ENDIF
     16  1a48				  -	      IF	PINK = $50
     17  1a48				  -	      .byte	$80+$8
     18  1a48					      ENDIF
     19  1a48				  -	      IF	PINK = $60
     20  1a48				  -	      .byte	$C0+$8
     21  1a48					      ENDIF
     22  1a48				  -	      IF	PINK = $70
     23  1a48				  -	      .byte	$D0+$8
     24  1a48					      ENDIF
     25  1a48				  -	      IF	PINK = $80
     26  1a48				  -	      .byte	$B0+$8
     27  1a48					      ENDIF
     28  1a48				  -	      IF	PINK = $90
     29  1a48				  -	      .byte	$90+$8
     30  1a48					      ENDIF
     31  1a48				  -	      IF	PINK = $A0
     32  1a48				  -	      .byte	$70+$8
     33  1a48					      ENDIF
     34  1a48				  -	      IF	PINK = $B0
     35  1a48				  -	      .byte	$50+$8
     36  1a48					      ENDIF
     37  1a48				  -	      IF	PINK = $C0
     38  1a48				  -	      .byte	$30+$8
     39  1a48					      ENDIF
     40  1a48				  -	      IF	PINK = $D0
     41  1a48				  -	      .byte	$30+$8
     42  1a48					      ENDIF
     43  1a48				  -	      IF	PINK = $E0
     44  1a48				  -	      .byte	$20+$8
     45  1a48					      ENDIF
     46  1a48				  -	      IF	PINK = $F0
     47  1a48				  -	      .byte	$40+$8
     48  1a48					      ENDIF
      0  1a48					      NTSCPAL	VIOLET,$a
      1  1a48		       6a		      .byte.b	VIOLET+$a
      0  1a49					      NTSC_TO_PAL	VIOLET,$a
      1  1a49				  -	      IF	VIOLET = 0
      2  1a49				  -	      .byte	VIOLET+$a
      3  1a49					      ENDIF
      4  1a49				  -	      IF	VIOLET = $10
      5  1a49				  -	      .byte	$20+$a
      6  1a49					      ENDIF
      7  1a49				  -	      IF	VIOLET = $20
      8  1a49				  -	      .byte	$40+$a
      9  1a49					      ENDIF
     10  1a49				  -	      IF	VIOLET = $30
     11  1a49				  -	      .byte	$40+$a
     12  1a49					      ENDIF
     13  1a49				  -	      IF	VIOLET = $40
     14  1a49				  -	      .byte	$60+$a
     15  1a49					      ENDIF
     16  1a49				  -	      IF	VIOLET = $50
     17  1a49				  -	      .byte	$80+$a
     18  1a49					      ENDIF
     19  1a49					      IF	VIOLET = $60
     20  1a49		       ca		      .byte.b	$C0+$a
     21  1a4a					      ENDIF
     22  1a4a				  -	      IF	VIOLET = $70
     23  1a4a				  -	      .byte	$D0+$a
     24  1a4a					      ENDIF
     25  1a4a				  -	      IF	VIOLET = $80
     26  1a4a				  -	      .byte	$B0+$a
     27  1a4a					      ENDIF
     28  1a4a				  -	      IF	VIOLET = $90
     29  1a4a				  -	      .byte	$90+$a
     30  1a4a					      ENDIF
     31  1a4a				  -	      IF	VIOLET = $A0
     32  1a4a				  -	      .byte	$70+$a
     33  1a4a					      ENDIF
     34  1a4a				  -	      IF	VIOLET = $B0
     35  1a4a				  -	      .byte	$50+$a
     36  1a4a					      ENDIF
     37  1a4a				  -	      IF	VIOLET = $C0
     38  1a4a				  -	      .byte	$30+$a
     39  1a4a					      ENDIF
     40  1a4a				  -	      IF	VIOLET = $D0
     41  1a4a				  -	      .byte	$30+$a
     42  1a4a					      ENDIF
     43  1a4a				  -	      IF	VIOLET = $E0
     44  1a4a				  -	      .byte	$20+$a
     45  1a4a					      ENDIF
     46  1a4a				  -	      IF	VIOLET = $F0
     47  1a4a				  -	      .byte	$40+$a
     48  1a4a					      ENDIF
      0  1a4a					      NTSCPAL	SKYBLUE,$8
      1  1a4a		       98		      .byte.b	SKYBLUE+$8
      0  1a4b					      NTSC_TO_PAL	SKYBLUE,$8
      1  1a4b				  -	      IF	SKYBLUE = 0
      2  1a4b				  -	      .byte	SKYBLUE+$8
      3  1a4b					      ENDIF
      4  1a4b				  -	      IF	SKYBLUE = $10
      5  1a4b				  -	      .byte	$20+$8
      6  1a4b					      ENDIF
      7  1a4b				  -	      IF	SKYBLUE = $20
      8  1a4b				  -	      .byte	$40+$8
      9  1a4b					      ENDIF
     10  1a4b				  -	      IF	SKYBLUE = $30
     11  1a4b				  -	      .byte	$40+$8
     12  1a4b					      ENDIF
     13  1a4b				  -	      IF	SKYBLUE = $40
     14  1a4b				  -	      .byte	$60+$8
     15  1a4b					      ENDIF
     16  1a4b				  -	      IF	SKYBLUE = $50
     17  1a4b				  -	      .byte	$80+$8
     18  1a4b					      ENDIF
     19  1a4b				  -	      IF	SKYBLUE = $60
     20  1a4b				  -	      .byte	$C0+$8
     21  1a4b					      ENDIF
     22  1a4b				  -	      IF	SKYBLUE = $70
     23  1a4b				  -	      .byte	$D0+$8
     24  1a4b					      ENDIF
     25  1a4b				  -	      IF	SKYBLUE = $80
     26  1a4b				  -	      .byte	$B0+$8
     27  1a4b					      ENDIF
     28  1a4b					      IF	SKYBLUE = $90
     29  1a4b		       98		      .byte.b	$90+$8
     30  1a4c					      ENDIF
     31  1a4c				  -	      IF	SKYBLUE = $A0
     32  1a4c				  -	      .byte	$70+$8
     33  1a4c					      ENDIF
     34  1a4c				  -	      IF	SKYBLUE = $B0
     35  1a4c				  -	      .byte	$50+$8
     36  1a4c					      ENDIF
     37  1a4c				  -	      IF	SKYBLUE = $C0
     38  1a4c				  -	      .byte	$30+$8
     39  1a4c					      ENDIF
     40  1a4c				  -	      IF	SKYBLUE = $D0
     41  1a4c				  -	      .byte	$30+$8
     42  1a4c					      ENDIF
     43  1a4c				  -	      IF	SKYBLUE = $E0
     44  1a4c				  -	      .byte	$20+$8
     45  1a4c					      ENDIF
     46  1a4c				  -	      IF	SKYBLUE = $F0
     47  1a4c				  -	      .byte	$40+$8
     48  1a4c					      ENDIF
      0  1a4c					      NTSCPAL	ORANGE,$8
      1  1a4c		       28		      .byte.b	ORANGE+$8
      0  1a4d					      NTSC_TO_PAL	ORANGE,$8
      1  1a4d				  -	      IF	ORANGE = 0
      2  1a4d				  -	      .byte	ORANGE+$8
      3  1a4d					      ENDIF
      4  1a4d				  -	      IF	ORANGE = $10
      5  1a4d				  -	      .byte	$20+$8
      6  1a4d					      ENDIF
      7  1a4d					      IF	ORANGE = $20
      8  1a4d		       48		      .byte.b	$40+$8
      9  1a4e					      ENDIF
     10  1a4e				  -	      IF	ORANGE = $30
     11  1a4e				  -	      .byte	$40+$8
     12  1a4e					      ENDIF
     13  1a4e				  -	      IF	ORANGE = $40
     14  1a4e				  -	      .byte	$60+$8
     15  1a4e					      ENDIF
     16  1a4e				  -	      IF	ORANGE = $50
     17  1a4e				  -	      .byte	$80+$8
     18  1a4e					      ENDIF
     19  1a4e				  -	      IF	ORANGE = $60
     20  1a4e				  -	      .byte	$C0+$8
     21  1a4e					      ENDIF
     22  1a4e				  -	      IF	ORANGE = $70
     23  1a4e				  -	      .byte	$D0+$8
     24  1a4e					      ENDIF
     25  1a4e				  -	      IF	ORANGE = $80
     26  1a4e				  -	      .byte	$B0+$8
     27  1a4e					      ENDIF
     28  1a4e				  -	      IF	ORANGE = $90
     29  1a4e				  -	      .byte	$90+$8
     30  1a4e					      ENDIF
     31  1a4e				  -	      IF	ORANGE = $A0
     32  1a4e				  -	      .byte	$70+$8
     33  1a4e					      ENDIF
     34  1a4e				  -	      IF	ORANGE = $B0
     35  1a4e				  -	      .byte	$50+$8
     36  1a4e					      ENDIF
     37  1a4e				  -	      IF	ORANGE = $C0
     38  1a4e				  -	      .byte	$30+$8
     39  1a4e					      ENDIF
     40  1a4e				  -	      IF	ORANGE = $D0
     41  1a4e				  -	      .byte	$30+$8
     42  1a4e					      ENDIF
     43  1a4e				  -	      IF	ORANGE = $E0
     44  1a4e				  -	      .byte	$20+$8
     45  1a4e					      ENDIF
     46  1a4e				  -	      IF	ORANGE = $F0
     47  1a4e				  -	      .byte	$40+$8
     48  1a4e					      ENDIF
      0  1a4e					      NTSCPAL	VIOLET,$8
      1  1a4e		       68		      .byte.b	VIOLET+$8
      0  1a4f					      NTSC_TO_PAL	VIOLET,$8
      1  1a4f				  -	      IF	VIOLET = 0
      2  1a4f				  -	      .byte	VIOLET+$8
      3  1a4f					      ENDIF
      4  1a4f				  -	      IF	VIOLET = $10
      5  1a4f				  -	      .byte	$20+$8
      6  1a4f					      ENDIF
      7  1a4f				  -	      IF	VIOLET = $20
      8  1a4f				  -	      .byte	$40+$8
      9  1a4f					      ENDIF
     10  1a4f				  -	      IF	VIOLET = $30
     11  1a4f				  -	      .byte	$40+$8
     12  1a4f					      ENDIF
     13  1a4f				  -	      IF	VIOLET = $40
     14  1a4f				  -	      .byte	$60+$8
     15  1a4f					      ENDIF
     16  1a4f				  -	      IF	VIOLET = $50
     17  1a4f				  -	      .byte	$80+$8
     18  1a4f					      ENDIF
     19  1a4f					      IF	VIOLET = $60
     20  1a4f		       c8		      .byte.b	$C0+$8
     21  1a50					      ENDIF
     22  1a50				  -	      IF	VIOLET = $70
     23  1a50				  -	      .byte	$D0+$8
     24  1a50					      ENDIF
     25  1a50				  -	      IF	VIOLET = $80
     26  1a50				  -	      .byte	$B0+$8
     27  1a50					      ENDIF
     28  1a50				  -	      IF	VIOLET = $90
     29  1a50				  -	      .byte	$90+$8
     30  1a50					      ENDIF
     31  1a50				  -	      IF	VIOLET = $A0
     32  1a50				  -	      .byte	$70+$8
     33  1a50					      ENDIF
     34  1a50				  -	      IF	VIOLET = $B0
     35  1a50				  -	      .byte	$50+$8
     36  1a50					      ENDIF
     37  1a50				  -	      IF	VIOLET = $C0
     38  1a50				  -	      .byte	$30+$8
     39  1a50					      ENDIF
     40  1a50				  -	      IF	VIOLET = $D0
     41  1a50				  -	      .byte	$30+$8
     42  1a50					      ENDIF
     43  1a50				  -	      IF	VIOLET = $E0
     44  1a50				  -	      .byte	$20+$8
     45  1a50					      ENDIF
     46  1a50				  -	      IF	VIOLET = $F0
     47  1a50				  -	      .byte	$40+$8
     48  1a50					      ENDIF
    661  1a50
    662  1a50				   C2			; soil stripes
      0  1a50					      NTSCPAL	SKYBLUE,$6
      1  1a50		       96		      .byte.b	SKYBLUE+$6
      0  1a51					      NTSC_TO_PAL	SKYBLUE,$6
      1  1a51				  -	      IF	SKYBLUE = 0
      2  1a51				  -	      .byte	SKYBLUE+$6
      3  1a51					      ENDIF
      4  1a51				  -	      IF	SKYBLUE = $10
      5  1a51				  -	      .byte	$20+$6
      6  1a51					      ENDIF
      7  1a51				  -	      IF	SKYBLUE = $20
      8  1a51				  -	      .byte	$40+$6
      9  1a51					      ENDIF
     10  1a51				  -	      IF	SKYBLUE = $30
     11  1a51				  -	      .byte	$40+$6
     12  1a51					      ENDIF
     13  1a51				  -	      IF	SKYBLUE = $40
     14  1a51				  -	      .byte	$60+$6
     15  1a51					      ENDIF
     16  1a51				  -	      IF	SKYBLUE = $50
     17  1a51				  -	      .byte	$80+$6
     18  1a51					      ENDIF
     19  1a51				  -	      IF	SKYBLUE = $60
     20  1a51				  -	      .byte	$C0+$6
     21  1a51					      ENDIF
     22  1a51				  -	      IF	SKYBLUE = $70
     23  1a51				  -	      .byte	$D0+$6
     24  1a51					      ENDIF
     25  1a51				  -	      IF	SKYBLUE = $80
     26  1a51				  -	      .byte	$B0+$6
     27  1a51					      ENDIF
     28  1a51					      IF	SKYBLUE = $90
     29  1a51		       96		      .byte.b	$90+$6
     30  1a52					      ENDIF
     31  1a52				  -	      IF	SKYBLUE = $A0
     32  1a52				  -	      .byte	$70+$6
     33  1a52					      ENDIF
     34  1a52				  -	      IF	SKYBLUE = $B0
     35  1a52				  -	      .byte	$50+$6
     36  1a52					      ENDIF
     37  1a52				  -	      IF	SKYBLUE = $C0
     38  1a52				  -	      .byte	$30+$6
     39  1a52					      ENDIF
     40  1a52				  -	      IF	SKYBLUE = $D0
     41  1a52				  -	      .byte	$30+$6
     42  1a52					      ENDIF
     43  1a52				  -	      IF	SKYBLUE = $E0
     44  1a52				  -	      .byte	$20+$6
     45  1a52					      ENDIF
     46  1a52				  -	      IF	SKYBLUE = $F0
     47  1a52				  -	      .byte	$40+$6
     48  1a52					      ENDIF
      0  1a52					      NTSCPAL	ORANGE,$6
      1  1a52		       26		      .byte.b	ORANGE+$6
      0  1a53					      NTSC_TO_PAL	ORANGE,$6
      1  1a53				  -	      IF	ORANGE = 0
      2  1a53				  -	      .byte	ORANGE+$6
      3  1a53					      ENDIF
      4  1a53				  -	      IF	ORANGE = $10
      5  1a53				  -	      .byte	$20+$6
      6  1a53					      ENDIF
      7  1a53					      IF	ORANGE = $20
      8  1a53		       46		      .byte.b	$40+$6
      9  1a54					      ENDIF
     10  1a54				  -	      IF	ORANGE = $30
     11  1a54				  -	      .byte	$40+$6
     12  1a54					      ENDIF
     13  1a54				  -	      IF	ORANGE = $40
     14  1a54				  -	      .byte	$60+$6
     15  1a54					      ENDIF
     16  1a54				  -	      IF	ORANGE = $50
     17  1a54				  -	      .byte	$80+$6
     18  1a54					      ENDIF
     19  1a54				  -	      IF	ORANGE = $60
     20  1a54				  -	      .byte	$C0+$6
     21  1a54					      ENDIF
     22  1a54				  -	      IF	ORANGE = $70
     23  1a54				  -	      .byte	$D0+$6
     24  1a54					      ENDIF
     25  1a54				  -	      IF	ORANGE = $80
     26  1a54				  -	      .byte	$B0+$6
     27  1a54					      ENDIF
     28  1a54				  -	      IF	ORANGE = $90
     29  1a54				  -	      .byte	$90+$6
     30  1a54					      ENDIF
     31  1a54				  -	      IF	ORANGE = $A0
     32  1a54				  -	      .byte	$70+$6
     33  1a54					      ENDIF
     34  1a54				  -	      IF	ORANGE = $B0
     35  1a54				  -	      .byte	$50+$6
     36  1a54					      ENDIF
     37  1a54				  -	      IF	ORANGE = $C0
     38  1a54				  -	      .byte	$30+$6
     39  1a54					      ENDIF
     40  1a54				  -	      IF	ORANGE = $D0
     41  1a54				  -	      .byte	$30+$6
     42  1a54					      ENDIF
     43  1a54				  -	      IF	ORANGE = $E0
     44  1a54				  -	      .byte	$20+$6
     45  1a54					      ENDIF
     46  1a54				  -	      IF	ORANGE = $F0
     47  1a54				  -	      .byte	$40+$6
     48  1a54					      ENDIF
      0  1a54					      NTSCPAL	PINK,$6
      1  1a54		       46		      .byte.b	PINK+$6
      0  1a55					      NTSC_TO_PAL	PINK,$6
      1  1a55				  -	      IF	PINK = 0
      2  1a55				  -	      .byte	PINK+$6
      3  1a55					      ENDIF
      4  1a55				  -	      IF	PINK = $10
      5  1a55				  -	      .byte	$20+$6
      6  1a55					      ENDIF
      7  1a55				  -	      IF	PINK = $20
      8  1a55				  -	      .byte	$40+$6
      9  1a55					      ENDIF
     10  1a55				  -	      IF	PINK = $30
     11  1a55				  -	      .byte	$40+$6
     12  1a55					      ENDIF
     13  1a55					      IF	PINK = $40
     14  1a55		       66		      .byte.b	$60+$6
     15  1a56					      ENDIF
     16  1a56				  -	      IF	PINK = $50
     17  1a56				  -	      .byte	$80+$6
     18  1a56					      ENDIF
     19  1a56				  -	      IF	PINK = $60
     20  1a56				  -	      .byte	$C0+$6
     21  1a56					      ENDIF
     22  1a56				  -	      IF	PINK = $70
     23  1a56				  -	      .byte	$D0+$6
     24  1a56					      ENDIF
     25  1a56				  -	      IF	PINK = $80
     26  1a56				  -	      .byte	$B0+$6
     27  1a56					      ENDIF
     28  1a56				  -	      IF	PINK = $90
     29  1a56				  -	      .byte	$90+$6
     30  1a56					      ENDIF
     31  1a56				  -	      IF	PINK = $A0
     32  1a56				  -	      .byte	$70+$6
     33  1a56					      ENDIF
     34  1a56				  -	      IF	PINK = $B0
     35  1a56				  -	      .byte	$50+$6
     36  1a56					      ENDIF
     37  1a56				  -	      IF	PINK = $C0
     38  1a56				  -	      .byte	$30+$6
     39  1a56					      ENDIF
     40  1a56				  -	      IF	PINK = $D0
     41  1a56				  -	      .byte	$30+$6
     42  1a56					      ENDIF
     43  1a56				  -	      IF	PINK = $E0
     44  1a56				  -	      .byte	$20+$6
     45  1a56					      ENDIF
     46  1a56				  -	      IF	PINK = $F0
     47  1a56				  -	      .byte	$40+$6
     48  1a56					      ENDIF
      0  1a56					      NTSCPAL	SKYBLUE,$8
      1  1a56		       98		      .byte.b	SKYBLUE+$8
      0  1a57					      NTSC_TO_PAL	SKYBLUE,$8
      1  1a57				  -	      IF	SKYBLUE = 0
      2  1a57				  -	      .byte	SKYBLUE+$8
      3  1a57					      ENDIF
      4  1a57				  -	      IF	SKYBLUE = $10
      5  1a57				  -	      .byte	$20+$8
      6  1a57					      ENDIF
      7  1a57				  -	      IF	SKYBLUE = $20
      8  1a57				  -	      .byte	$40+$8
      9  1a57					      ENDIF
     10  1a57				  -	      IF	SKYBLUE = $30
     11  1a57				  -	      .byte	$40+$8
     12  1a57					      ENDIF
     13  1a57				  -	      IF	SKYBLUE = $40
     14  1a57				  -	      .byte	$60+$8
     15  1a57					      ENDIF
     16  1a57				  -	      IF	SKYBLUE = $50
     17  1a57				  -	      .byte	$80+$8
     18  1a57					      ENDIF
     19  1a57				  -	      IF	SKYBLUE = $60
     20  1a57				  -	      .byte	$C0+$8
     21  1a57					      ENDIF
     22  1a57				  -	      IF	SKYBLUE = $70
     23  1a57				  -	      .byte	$D0+$8
     24  1a57					      ENDIF
     25  1a57				  -	      IF	SKYBLUE = $80
     26  1a57				  -	      .byte	$B0+$8
     27  1a57					      ENDIF
     28  1a57					      IF	SKYBLUE = $90
     29  1a57		       98		      .byte.b	$90+$8
     30  1a58					      ENDIF
     31  1a58				  -	      IF	SKYBLUE = $A0
     32  1a58				  -	      .byte	$70+$8
     33  1a58					      ENDIF
     34  1a58				  -	      IF	SKYBLUE = $B0
     35  1a58				  -	      .byte	$50+$8
     36  1a58					      ENDIF
     37  1a58				  -	      IF	SKYBLUE = $C0
     38  1a58				  -	      .byte	$30+$8
     39  1a58					      ENDIF
     40  1a58				  -	      IF	SKYBLUE = $D0
     41  1a58				  -	      .byte	$30+$8
     42  1a58					      ENDIF
     43  1a58				  -	      IF	SKYBLUE = $E0
     44  1a58				  -	      .byte	$20+$8
     45  1a58					      ENDIF
     46  1a58				  -	      IF	SKYBLUE = $F0
     47  1a58				  -	      .byte	$40+$8
     48  1a58					      ENDIF
      0  1a58					      NTSCPAL	LIME,$6
      1  1a58		       c6		      .byte.b	LIME+$6
      0  1a59					      NTSC_TO_PAL	LIME,$6
      1  1a59				  -	      IF	LIME = 0
      2  1a59				  -	      .byte	LIME+$6
      3  1a59					      ENDIF
      4  1a59				  -	      IF	LIME = $10
      5  1a59				  -	      .byte	$20+$6
      6  1a59					      ENDIF
      7  1a59				  -	      IF	LIME = $20
      8  1a59				  -	      .byte	$40+$6
      9  1a59					      ENDIF
     10  1a59				  -	      IF	LIME = $30
     11  1a59				  -	      .byte	$40+$6
     12  1a59					      ENDIF
     13  1a59				  -	      IF	LIME = $40
     14  1a59				  -	      .byte	$60+$6
     15  1a59					      ENDIF
     16  1a59				  -	      IF	LIME = $50
     17  1a59				  -	      .byte	$80+$6
     18  1a59					      ENDIF
     19  1a59				  -	      IF	LIME = $60
     20  1a59				  -	      .byte	$C0+$6
     21  1a59					      ENDIF
     22  1a59				  -	      IF	LIME = $70
     23  1a59				  -	      .byte	$D0+$6
     24  1a59					      ENDIF
     25  1a59				  -	      IF	LIME = $80
     26  1a59				  -	      .byte	$B0+$6
     27  1a59					      ENDIF
     28  1a59				  -	      IF	LIME = $90
     29  1a59				  -	      .byte	$90+$6
     30  1a59					      ENDIF
     31  1a59				  -	      IF	LIME = $A0
     32  1a59				  -	      .byte	$70+$6
     33  1a59					      ENDIF
     34  1a59				  -	      IF	LIME = $B0
     35  1a59				  -	      .byte	$50+$6
     36  1a59					      ENDIF
     37  1a59					      IF	LIME = $C0
     38  1a59		       36		      .byte.b	$30+$6
     39  1a5a					      ENDIF
     40  1a5a				  -	      IF	LIME = $D0
     41  1a5a				  -	      .byte	$30+$6
     42  1a5a					      ENDIF
     43  1a5a				  -	      IF	LIME = $E0
     44  1a5a				  -	      .byte	$20+$6
     45  1a5a					      ENDIF
     46  1a5a				  -	      IF	LIME = $F0
     47  1a5a				  -	      .byte	$40+$6
     48  1a5a					      ENDIF
      0  1a5a					      NTSCPAL	PINK,$6
      1  1a5a		       46		      .byte.b	PINK+$6
      0  1a5b					      NTSC_TO_PAL	PINK,$6
      1  1a5b				  -	      IF	PINK = 0
      2  1a5b				  -	      .byte	PINK+$6
      3  1a5b					      ENDIF
      4  1a5b				  -	      IF	PINK = $10
      5  1a5b				  -	      .byte	$20+$6
      6  1a5b					      ENDIF
      7  1a5b				  -	      IF	PINK = $20
      8  1a5b				  -	      .byte	$40+$6
      9  1a5b					      ENDIF
     10  1a5b				  -	      IF	PINK = $30
     11  1a5b				  -	      .byte	$40+$6
     12  1a5b					      ENDIF
     13  1a5b					      IF	PINK = $40
     14  1a5b		       66		      .byte.b	$60+$6
     15  1a5c					      ENDIF
     16  1a5c				  -	      IF	PINK = $50
     17  1a5c				  -	      .byte	$80+$6
     18  1a5c					      ENDIF
     19  1a5c				  -	      IF	PINK = $60
     20  1a5c				  -	      .byte	$C0+$6
     21  1a5c					      ENDIF
     22  1a5c				  -	      IF	PINK = $70
     23  1a5c				  -	      .byte	$D0+$6
     24  1a5c					      ENDIF
     25  1a5c				  -	      IF	PINK = $80
     26  1a5c				  -	      .byte	$B0+$6
     27  1a5c					      ENDIF
     28  1a5c				  -	      IF	PINK = $90
     29  1a5c				  -	      .byte	$90+$6
     30  1a5c					      ENDIF
     31  1a5c				  -	      IF	PINK = $A0
     32  1a5c				  -	      .byte	$70+$6
     33  1a5c					      ENDIF
     34  1a5c				  -	      IF	PINK = $B0
     35  1a5c				  -	      .byte	$50+$6
     36  1a5c					      ENDIF
     37  1a5c				  -	      IF	PINK = $C0
     38  1a5c				  -	      .byte	$30+$6
     39  1a5c					      ENDIF
     40  1a5c				  -	      IF	PINK = $D0
     41  1a5c				  -	      .byte	$30+$6
     42  1a5c					      ENDIF
     43  1a5c				  -	      IF	PINK = $E0
     44  1a5c				  -	      .byte	$20+$6
     45  1a5c					      ENDIF
     46  1a5c				  -	      IF	PINK = $F0
     47  1a5c				  -	      .byte	$40+$6
     48  1a5c					      ENDIF
      0  1a5c					      NTSCPAL	TEAL,$6
      1  1a5c		       a6		      .byte.b	TEAL+$6
      0  1a5d					      NTSC_TO_PAL	TEAL,$6
      1  1a5d				  -	      IF	TEAL = 0
      2  1a5d				  -	      .byte	TEAL+$6
      3  1a5d					      ENDIF
      4  1a5d				  -	      IF	TEAL = $10
      5  1a5d				  -	      .byte	$20+$6
      6  1a5d					      ENDIF
      7  1a5d				  -	      IF	TEAL = $20
      8  1a5d				  -	      .byte	$40+$6
      9  1a5d					      ENDIF
     10  1a5d				  -	      IF	TEAL = $30
     11  1a5d				  -	      .byte	$40+$6
     12  1a5d					      ENDIF
     13  1a5d				  -	      IF	TEAL = $40
     14  1a5d				  -	      .byte	$60+$6
     15  1a5d					      ENDIF
     16  1a5d				  -	      IF	TEAL = $50
     17  1a5d				  -	      .byte	$80+$6
     18  1a5d					      ENDIF
     19  1a5d				  -	      IF	TEAL = $60
     20  1a5d				  -	      .byte	$C0+$6
     21  1a5d					      ENDIF
     22  1a5d				  -	      IF	TEAL = $70
     23  1a5d				  -	      .byte	$D0+$6
     24  1a5d					      ENDIF
     25  1a5d				  -	      IF	TEAL = $80
     26  1a5d				  -	      .byte	$B0+$6
     27  1a5d					      ENDIF
     28  1a5d				  -	      IF	TEAL = $90
     29  1a5d				  -	      .byte	$90+$6
     30  1a5d					      ENDIF
     31  1a5d					      IF	TEAL = $A0
     32  1a5d		       76		      .byte.b	$70+$6
     33  1a5e					      ENDIF
     34  1a5e				  -	      IF	TEAL = $B0
     35  1a5e				  -	      .byte	$50+$6
     36  1a5e					      ENDIF
     37  1a5e				  -	      IF	TEAL = $C0
     38  1a5e				  -	      .byte	$30+$6
     39  1a5e					      ENDIF
     40  1a5e				  -	      IF	TEAL = $D0
     41  1a5e				  -	      .byte	$30+$6
     42  1a5e					      ENDIF
     43  1a5e				  -	      IF	TEAL = $E0
     44  1a5e				  -	      .byte	$20+$6
     45  1a5e					      ENDIF
     46  1a5e				  -	      IF	TEAL = $F0
     47  1a5e				  -	      .byte	$40+$6
     48  1a5e					      ENDIF
      0  1a5e					      NTSCPAL	TEAL,$6
      1  1a5e		       a6		      .byte.b	TEAL+$6
      0  1a5f					      NTSC_TO_PAL	TEAL,$6
      1  1a5f				  -	      IF	TEAL = 0
      2  1a5f				  -	      .byte	TEAL+$6
      3  1a5f					      ENDIF
      4  1a5f				  -	      IF	TEAL = $10
      5  1a5f				  -	      .byte	$20+$6
      6  1a5f					      ENDIF
      7  1a5f				  -	      IF	TEAL = $20
      8  1a5f				  -	      .byte	$40+$6
      9  1a5f					      ENDIF
     10  1a5f				  -	      IF	TEAL = $30
     11  1a5f				  -	      .byte	$40+$6
     12  1a5f					      ENDIF
     13  1a5f				  -	      IF	TEAL = $40
     14  1a5f				  -	      .byte	$60+$6
     15  1a5f					      ENDIF
     16  1a5f				  -	      IF	TEAL = $50
     17  1a5f				  -	      .byte	$80+$6
     18  1a5f					      ENDIF
     19  1a5f				  -	      IF	TEAL = $60
     20  1a5f				  -	      .byte	$C0+$6
     21  1a5f					      ENDIF
     22  1a5f				  -	      IF	TEAL = $70
     23  1a5f				  -	      .byte	$D0+$6
     24  1a5f					      ENDIF
     25  1a5f				  -	      IF	TEAL = $80
     26  1a5f				  -	      .byte	$B0+$6
     27  1a5f					      ENDIF
     28  1a5f				  -	      IF	TEAL = $90
     29  1a5f				  -	      .byte	$90+$6
     30  1a5f					      ENDIF
     31  1a5f					      IF	TEAL = $A0
     32  1a5f		       76		      .byte.b	$70+$6
     33  1a60					      ENDIF
     34  1a60				  -	      IF	TEAL = $B0
     35  1a60				  -	      .byte	$50+$6
     36  1a60					      ENDIF
     37  1a60				  -	      IF	TEAL = $C0
     38  1a60				  -	      .byte	$30+$6
     39  1a60					      ENDIF
     40  1a60				  -	      IF	TEAL = $D0
     41  1a60				  -	      .byte	$30+$6
     42  1a60					      ENDIF
     43  1a60				  -	      IF	TEAL = $E0
     44  1a60				  -	      .byte	$20+$6
     45  1a60					      ENDIF
     46  1a60				  -	      IF	TEAL = $F0
     47  1a60				  -	      .byte	$40+$6
     48  1a60					      ENDIF
    671  1a60
    672  1a60				   C3			;
      0  1a60					      NTSCPAL	PINK,$8
      1  1a60		       48		      .byte.b	PINK+$8
      0  1a61					      NTSC_TO_PAL	PINK,$8
      1  1a61				  -	      IF	PINK = 0
      2  1a61				  -	      .byte	PINK+$8
      3  1a61					      ENDIF
      4  1a61				  -	      IF	PINK = $10
      5  1a61				  -	      .byte	$20+$8
      6  1a61					      ENDIF
      7  1a61				  -	      IF	PINK = $20
      8  1a61				  -	      .byte	$40+$8
      9  1a61					      ENDIF
     10  1a61				  -	      IF	PINK = $30
     11  1a61				  -	      .byte	$40+$8
     12  1a61					      ENDIF
     13  1a61					      IF	PINK = $40
     14  1a61		       68		      .byte.b	$60+$8
     15  1a62					      ENDIF
     16  1a62				  -	      IF	PINK = $50
     17  1a62				  -	      .byte	$80+$8
     18  1a62					      ENDIF
     19  1a62				  -	      IF	PINK = $60
     20  1a62				  -	      .byte	$C0+$8
     21  1a62					      ENDIF
     22  1a62				  -	      IF	PINK = $70
     23  1a62				  -	      .byte	$D0+$8
     24  1a62					      ENDIF
     25  1a62				  -	      IF	PINK = $80
     26  1a62				  -	      .byte	$B0+$8
     27  1a62					      ENDIF
     28  1a62				  -	      IF	PINK = $90
     29  1a62				  -	      .byte	$90+$8
     30  1a62					      ENDIF
     31  1a62				  -	      IF	PINK = $A0
     32  1a62				  -	      .byte	$70+$8
     33  1a62					      ENDIF
     34  1a62				  -	      IF	PINK = $B0
     35  1a62				  -	      .byte	$50+$8
     36  1a62					      ENDIF
     37  1a62				  -	      IF	PINK = $C0
     38  1a62				  -	      .byte	$30+$8
     39  1a62					      ENDIF
     40  1a62				  -	      IF	PINK = $D0
     41  1a62				  -	      .byte	$30+$8
     42  1a62					      ENDIF
     43  1a62				  -	      IF	PINK = $E0
     44  1a62				  -	      .byte	$20+$8
     45  1a62					      ENDIF
     46  1a62				  -	      IF	PINK = $F0
     47  1a62				  -	      .byte	$40+$8
     48  1a62					      ENDIF
      0  1a62					      NTSCPAL	LIME,$8
      1  1a62		       c8		      .byte.b	LIME+$8
      0  1a63					      NTSC_TO_PAL	LIME,$8
      1  1a63				  -	      IF	LIME = 0
      2  1a63				  -	      .byte	LIME+$8
      3  1a63					      ENDIF
      4  1a63				  -	      IF	LIME = $10
      5  1a63				  -	      .byte	$20+$8
      6  1a63					      ENDIF
      7  1a63				  -	      IF	LIME = $20
      8  1a63				  -	      .byte	$40+$8
      9  1a63					      ENDIF
     10  1a63				  -	      IF	LIME = $30
     11  1a63				  -	      .byte	$40+$8
     12  1a63					      ENDIF
     13  1a63				  -	      IF	LIME = $40
     14  1a63				  -	      .byte	$60+$8
     15  1a63					      ENDIF
     16  1a63				  -	      IF	LIME = $50
     17  1a63				  -	      .byte	$80+$8
     18  1a63					      ENDIF
     19  1a63				  -	      IF	LIME = $60
     20  1a63				  -	      .byte	$C0+$8
     21  1a63					      ENDIF
     22  1a63				  -	      IF	LIME = $70
     23  1a63				  -	      .byte	$D0+$8
     24  1a63					      ENDIF
     25  1a63				  -	      IF	LIME = $80
     26  1a63				  -	      .byte	$B0+$8
     27  1a63					      ENDIF
     28  1a63				  -	      IF	LIME = $90
     29  1a63				  -	      .byte	$90+$8
     30  1a63					      ENDIF
     31  1a63				  -	      IF	LIME = $A0
     32  1a63				  -	      .byte	$70+$8
     33  1a63					      ENDIF
     34  1a63				  -	      IF	LIME = $B0
     35  1a63				  -	      .byte	$50+$8
     36  1a63					      ENDIF
     37  1a63					      IF	LIME = $C0
     38  1a63		       38		      .byte.b	$30+$8
     39  1a64					      ENDIF
     40  1a64				  -	      IF	LIME = $D0
     41  1a64				  -	      .byte	$30+$8
     42  1a64					      ENDIF
     43  1a64				  -	      IF	LIME = $E0
     44  1a64				  -	      .byte	$20+$8
     45  1a64					      ENDIF
     46  1a64				  -	      IF	LIME = $F0
     47  1a64				  -	      .byte	$40+$8
     48  1a64					      ENDIF
      0  1a64					      NTSCPAL	LIME,$8
      1  1a64		       c8		      .byte.b	LIME+$8
      0  1a65					      NTSC_TO_PAL	LIME,$8
      1  1a65				  -	      IF	LIME = 0
      2  1a65				  -	      .byte	LIME+$8
      3  1a65					      ENDIF
      4  1a65				  -	      IF	LIME = $10
      5  1a65				  -	      .byte	$20+$8
      6  1a65					      ENDIF
      7  1a65				  -	      IF	LIME = $20
      8  1a65				  -	      .byte	$40+$8
      9  1a65					      ENDIF
     10  1a65				  -	      IF	LIME = $30
     11  1a65				  -	      .byte	$40+$8
     12  1a65					      ENDIF
     13  1a65				  -	      IF	LIME = $40
     14  1a65				  -	      .byte	$60+$8
     15  1a65					      ENDIF
     16  1a65				  -	      IF	LIME = $50
     17  1a65				  -	      .byte	$80+$8
     18  1a65					      ENDIF
     19  1a65				  -	      IF	LIME = $60
     20  1a65				  -	      .byte	$C0+$8
     21  1a65					      ENDIF
     22  1a65				  -	      IF	LIME = $70
     23  1a65				  -	      .byte	$D0+$8
     24  1a65					      ENDIF
     25  1a65				  -	      IF	LIME = $80
     26  1a65				  -	      .byte	$B0+$8
     27  1a65					      ENDIF
     28  1a65				  -	      IF	LIME = $90
     29  1a65				  -	      .byte	$90+$8
     30  1a65					      ENDIF
     31  1a65				  -	      IF	LIME = $A0
     32  1a65				  -	      .byte	$70+$8
     33  1a65					      ENDIF
     34  1a65				  -	      IF	LIME = $B0
     35  1a65				  -	      .byte	$50+$8
     36  1a65					      ENDIF
     37  1a65					      IF	LIME = $C0
     38  1a65		       38		      .byte.b	$30+$8
     39  1a66					      ENDIF
     40  1a66				  -	      IF	LIME = $D0
     41  1a66				  -	      .byte	$30+$8
     42  1a66					      ENDIF
     43  1a66				  -	      IF	LIME = $E0
     44  1a66				  -	      .byte	$20+$8
     45  1a66					      ENDIF
     46  1a66				  -	      IF	LIME = $F0
     47  1a66				  -	      .byte	$40+$8
     48  1a66					      ENDIF
      0  1a66					      NTSCPAL	ORANGE,$8
      1  1a66		       28		      .byte.b	ORANGE+$8
      0  1a67					      NTSC_TO_PAL	ORANGE,$8
      1  1a67				  -	      IF	ORANGE = 0
      2  1a67				  -	      .byte	ORANGE+$8
      3  1a67					      ENDIF
      4  1a67				  -	      IF	ORANGE = $10
      5  1a67				  -	      .byte	$20+$8
      6  1a67					      ENDIF
      7  1a67					      IF	ORANGE = $20
      8  1a67		       48		      .byte.b	$40+$8
      9  1a68					      ENDIF
     10  1a68				  -	      IF	ORANGE = $30
     11  1a68				  -	      .byte	$40+$8
     12  1a68					      ENDIF
     13  1a68				  -	      IF	ORANGE = $40
     14  1a68				  -	      .byte	$60+$8
     15  1a68					      ENDIF
     16  1a68				  -	      IF	ORANGE = $50
     17  1a68				  -	      .byte	$80+$8
     18  1a68					      ENDIF
     19  1a68				  -	      IF	ORANGE = $60
     20  1a68				  -	      .byte	$C0+$8
     21  1a68					      ENDIF
     22  1a68				  -	      IF	ORANGE = $70
     23  1a68				  -	      .byte	$D0+$8
     24  1a68					      ENDIF
     25  1a68				  -	      IF	ORANGE = $80
     26  1a68				  -	      .byte	$B0+$8
     27  1a68					      ENDIF
     28  1a68				  -	      IF	ORANGE = $90
     29  1a68				  -	      .byte	$90+$8
     30  1a68					      ENDIF
     31  1a68				  -	      IF	ORANGE = $A0
     32  1a68				  -	      .byte	$70+$8
     33  1a68					      ENDIF
     34  1a68				  -	      IF	ORANGE = $B0
     35  1a68				  -	      .byte	$50+$8
     36  1a68					      ENDIF
     37  1a68				  -	      IF	ORANGE = $C0
     38  1a68				  -	      .byte	$30+$8
     39  1a68					      ENDIF
     40  1a68				  -	      IF	ORANGE = $D0
     41  1a68				  -	      .byte	$30+$8
     42  1a68					      ENDIF
     43  1a68				  -	      IF	ORANGE = $E0
     44  1a68				  -	      .byte	$20+$8
     45  1a68					      ENDIF
     46  1a68				  -	      IF	ORANGE = $F0
     47  1a68				  -	      .byte	$40+$8
     48  1a68					      ENDIF
      0  1a68					      NTSCPAL	GREEN,$8
      1  1a68		       b8		      .byte.b	GREEN+$8
      0  1a69					      NTSC_TO_PAL	GREEN,$8
      1  1a69				  -	      IF	GREEN = 0
      2  1a69				  -	      .byte	GREEN+$8
      3  1a69					      ENDIF
      4  1a69				  -	      IF	GREEN = $10
      5  1a69				  -	      .byte	$20+$8
      6  1a69					      ENDIF
      7  1a69				  -	      IF	GREEN = $20
      8  1a69				  -	      .byte	$40+$8
      9  1a69					      ENDIF
     10  1a69				  -	      IF	GREEN = $30
     11  1a69				  -	      .byte	$40+$8
     12  1a69					      ENDIF
     13  1a69				  -	      IF	GREEN = $40
     14  1a69				  -	      .byte	$60+$8
     15  1a69					      ENDIF
     16  1a69				  -	      IF	GREEN = $50
     17  1a69				  -	      .byte	$80+$8
     18  1a69					      ENDIF
     19  1a69				  -	      IF	GREEN = $60
     20  1a69				  -	      .byte	$C0+$8
     21  1a69					      ENDIF
     22  1a69				  -	      IF	GREEN = $70
     23  1a69				  -	      .byte	$D0+$8
     24  1a69					      ENDIF
     25  1a69				  -	      IF	GREEN = $80
     26  1a69				  -	      .byte	$B0+$8
     27  1a69					      ENDIF
     28  1a69				  -	      IF	GREEN = $90
     29  1a69				  -	      .byte	$90+$8
     30  1a69					      ENDIF
     31  1a69				  -	      IF	GREEN = $A0
     32  1a69				  -	      .byte	$70+$8
     33  1a69					      ENDIF
     34  1a69					      IF	GREEN = $B0
     35  1a69		       58		      .byte.b	$50+$8
     36  1a6a					      ENDIF
     37  1a6a				  -	      IF	GREEN = $C0
     38  1a6a				  -	      .byte	$30+$8
     39  1a6a					      ENDIF
     40  1a6a				  -	      IF	GREEN = $D0
     41  1a6a				  -	      .byte	$30+$8
     42  1a6a					      ENDIF
     43  1a6a				  -	      IF	GREEN = $E0
     44  1a6a				  -	      .byte	$20+$8
     45  1a6a					      ENDIF
     46  1a6a				  -	      IF	GREEN = $F0
     47  1a6a				  -	      .byte	$40+$8
     48  1a6a					      ENDIF
      0  1a6a					      NTSCPAL	ORANGE,$8
      1  1a6a		       28		      .byte.b	ORANGE+$8
      0  1a6b					      NTSC_TO_PAL	ORANGE,$8
      1  1a6b				  -	      IF	ORANGE = 0
      2  1a6b				  -	      .byte	ORANGE+$8
      3  1a6b					      ENDIF
      4  1a6b				  -	      IF	ORANGE = $10
      5  1a6b				  -	      .byte	$20+$8
      6  1a6b					      ENDIF
      7  1a6b					      IF	ORANGE = $20
      8  1a6b		       48		      .byte.b	$40+$8
      9  1a6c					      ENDIF
     10  1a6c				  -	      IF	ORANGE = $30
     11  1a6c				  -	      .byte	$40+$8
     12  1a6c					      ENDIF
     13  1a6c				  -	      IF	ORANGE = $40
     14  1a6c				  -	      .byte	$60+$8
     15  1a6c					      ENDIF
     16  1a6c				  -	      IF	ORANGE = $50
     17  1a6c				  -	      .byte	$80+$8
     18  1a6c					      ENDIF
     19  1a6c				  -	      IF	ORANGE = $60
     20  1a6c				  -	      .byte	$C0+$8
     21  1a6c					      ENDIF
     22  1a6c				  -	      IF	ORANGE = $70
     23  1a6c				  -	      .byte	$D0+$8
     24  1a6c					      ENDIF
     25  1a6c				  -	      IF	ORANGE = $80
     26  1a6c				  -	      .byte	$B0+$8
     27  1a6c					      ENDIF
     28  1a6c				  -	      IF	ORANGE = $90
     29  1a6c				  -	      .byte	$90+$8
     30  1a6c					      ENDIF
     31  1a6c				  -	      IF	ORANGE = $A0
     32  1a6c				  -	      .byte	$70+$8
     33  1a6c					      ENDIF
     34  1a6c				  -	      IF	ORANGE = $B0
     35  1a6c				  -	      .byte	$50+$8
     36  1a6c					      ENDIF
     37  1a6c				  -	      IF	ORANGE = $C0
     38  1a6c				  -	      .byte	$30+$8
     39  1a6c					      ENDIF
     40  1a6c				  -	      IF	ORANGE = $D0
     41  1a6c				  -	      .byte	$30+$8
     42  1a6c					      ENDIF
     43  1a6c				  -	      IF	ORANGE = $E0
     44  1a6c				  -	      .byte	$20+$8
     45  1a6c					      ENDIF
     46  1a6c				  -	      IF	ORANGE = $F0
     47  1a6c				  -	      .byte	$40+$8
     48  1a6c					      ENDIF
      0  1a6c					      NTSCPAL	VIOLET,$8
      1  1a6c		       68		      .byte.b	VIOLET+$8
      0  1a6d					      NTSC_TO_PAL	VIOLET,$8
      1  1a6d				  -	      IF	VIOLET = 0
      2  1a6d				  -	      .byte	VIOLET+$8
      3  1a6d					      ENDIF
      4  1a6d				  -	      IF	VIOLET = $10
      5  1a6d				  -	      .byte	$20+$8
      6  1a6d					      ENDIF
      7  1a6d				  -	      IF	VIOLET = $20
      8  1a6d				  -	      .byte	$40+$8
      9  1a6d					      ENDIF
     10  1a6d				  -	      IF	VIOLET = $30
     11  1a6d				  -	      .byte	$40+$8
     12  1a6d					      ENDIF
     13  1a6d				  -	      IF	VIOLET = $40
     14  1a6d				  -	      .byte	$60+$8
     15  1a6d					      ENDIF
     16  1a6d				  -	      IF	VIOLET = $50
     17  1a6d				  -	      .byte	$80+$8
     18  1a6d					      ENDIF
     19  1a6d					      IF	VIOLET = $60
     20  1a6d		       c8		      .byte.b	$C0+$8
     21  1a6e					      ENDIF
     22  1a6e				  -	      IF	VIOLET = $70
     23  1a6e				  -	      .byte	$D0+$8
     24  1a6e					      ENDIF
     25  1a6e				  -	      IF	VIOLET = $80
     26  1a6e				  -	      .byte	$B0+$8
     27  1a6e					      ENDIF
     28  1a6e				  -	      IF	VIOLET = $90
     29  1a6e				  -	      .byte	$90+$8
     30  1a6e					      ENDIF
     31  1a6e				  -	      IF	VIOLET = $A0
     32  1a6e				  -	      .byte	$70+$8
     33  1a6e					      ENDIF
     34  1a6e				  -	      IF	VIOLET = $B0
     35  1a6e				  -	      .byte	$50+$8
     36  1a6e					      ENDIF
     37  1a6e				  -	      IF	VIOLET = $C0
     38  1a6e				  -	      .byte	$30+$8
     39  1a6e					      ENDIF
     40  1a6e				  -	      IF	VIOLET = $D0
     41  1a6e				  -	      .byte	$30+$8
     42  1a6e					      ENDIF
     43  1a6e				  -	      IF	VIOLET = $E0
     44  1a6e				  -	      .byte	$20+$8
     45  1a6e					      ENDIF
     46  1a6e				  -	      IF	VIOLET = $F0
     47  1a6e				  -	      .byte	$40+$8
     48  1a6e					      ENDIF
      0  1a6e					      NTSCPAL	ORANGE,$8
      1  1a6e		       28		      .byte.b	ORANGE+$8
      0  1a6f					      NTSC_TO_PAL	ORANGE,$8
      1  1a6f				  -	      IF	ORANGE = 0
      2  1a6f				  -	      .byte	ORANGE+$8
      3  1a6f					      ENDIF
      4  1a6f				  -	      IF	ORANGE = $10
      5  1a6f				  -	      .byte	$20+$8
      6  1a6f					      ENDIF
      7  1a6f					      IF	ORANGE = $20
      8  1a6f		       48		      .byte.b	$40+$8
      9  1a70					      ENDIF
     10  1a70				  -	      IF	ORANGE = $30
     11  1a70				  -	      .byte	$40+$8
     12  1a70					      ENDIF
     13  1a70				  -	      IF	ORANGE = $40
     14  1a70				  -	      .byte	$60+$8
     15  1a70					      ENDIF
     16  1a70				  -	      IF	ORANGE = $50
     17  1a70				  -	      .byte	$80+$8
     18  1a70					      ENDIF
     19  1a70				  -	      IF	ORANGE = $60
     20  1a70				  -	      .byte	$C0+$8
     21  1a70					      ENDIF
     22  1a70				  -	      IF	ORANGE = $70
     23  1a70				  -	      .byte	$D0+$8
     24  1a70					      ENDIF
     25  1a70				  -	      IF	ORANGE = $80
     26  1a70				  -	      .byte	$B0+$8
     27  1a70					      ENDIF
     28  1a70				  -	      IF	ORANGE = $90
     29  1a70				  -	      .byte	$90+$8
     30  1a70					      ENDIF
     31  1a70				  -	      IF	ORANGE = $A0
     32  1a70				  -	      .byte	$70+$8
     33  1a70					      ENDIF
     34  1a70				  -	      IF	ORANGE = $B0
     35  1a70				  -	      .byte	$50+$8
     36  1a70					      ENDIF
     37  1a70				  -	      IF	ORANGE = $C0
     38  1a70				  -	      .byte	$30+$8
     39  1a70					      ENDIF
     40  1a70				  -	      IF	ORANGE = $D0
     41  1a70				  -	      .byte	$30+$8
     42  1a70					      ENDIF
     43  1a70				  -	      IF	ORANGE = $E0
     44  1a70				  -	      .byte	$20+$8
     45  1a70					      ENDIF
     46  1a70				  -	      IF	ORANGE = $F0
     47  1a70				  -	      .byte	$40+$8
     48  1a70					      ENDIF
    681  1a70
    682  1a70
      0  1a70					      DEFINE_SUBROUTINE	UnpackLevel
      1  1a70		       00 03	   BANK_UnpackLevel =	_CURRENT_BANK
      2  1a70					      SUBROUTINE
      3  1a70				   UnpackLevel
    684  1a70
    685  1a70		       85 c0		      sta	RAM_Bank
    686  1a72
    687  1a72							; has to be done before decoding the level to have the platform right:
    688  1a72							;	    SET_PLATFORM
    689  1a72
    690  1a72		       a9 03		      lda	#BANK_UnpackLevel	; the *ROM* bank of this routine (NOT RAM)
    691  1a74		       85 bf		      sta	ROM_Bank	; GetROMByte returns to this bank
    692  1a76
    693  1a76
    694  1a76
    695  1a76		       a9 01		      lda	#CHARACTER_SOIL
    696  1a78		       85 8b		      sta	POS_Type
    697  1a7a
    698  1a7a		       a9 15		      lda	#SIZE_BOARD_Y-1
    699  1a7c		       85 88		      sta	POS_Y
    700  1a7e		       a9 27	   xyLine     lda	#SIZE_BOARD_X-1
    701  1a80		       85 87		      sta	POS_X
    702  1a82		       20 3a f8    xyClear    jsr	PutBoardCharacterFromRAM
    703  1a85		       c6 87		      dec	POS_X
    704  1a87		       10 f9		      bpl	xyClear
    705  1a89		       c6 88		      dec	POS_Y
    706  1a8b		       10 f1		      bpl	xyLine
    707  1a8d
    708  1a8d		       a9 0c		      lda	#12	;todo - crashes @12 ... why?
    709  1a8f		       85 d7		      sta	base_x
    710  1a91		       a9 06		      lda	#6
    711  1a93		       85 d8		      sta	base_y
    712  1a95
    713  1a95		       a5 c2		      lda	NextLevelTrigger
    714  1a97		       09 80		      ora	#BIT_NEXTLEVEL
    715  1a99		       85 c2		      sta	NextLevelTrigger
    716  1a9b
    717  1a9b		       a6 b2		      ldx	levelX
    718  1a9d		       bd 00 f0 	      lda	LevelInfoLO,x
    719  1aa0		       85 bb		      sta	Board_AddressR
    720  1aa2		       bd 99 f0 	      lda	LevelInfoHI,x
    721  1aa5		       85 bc		      sta	Board_AddressR+1
    722  1aa7		       bd 32 f1 	      lda	LevelInfoBANK,x
    723  1aaa		       85 ab		      sta	LEVEL_bank
    724  1aac
    725  1aac
    726  1aac							;		  NEXT_RANDOM
    727  1aac							;		  lda levelX
    728  1aac							;		  and #7
    729  1aac							;		  asl
    730  1aac							;		  asl
    731  1aac							;		  ora Platform		    ; NTSC/PAL
    732  1aac							;		  lsr
    733  1aac							;		  tax
    734  1aac
    735  1aac							;		  lda C1,x
    736  1aac		       20 0c fd 	      jsr	Random
    737  1aaf		       29 f0		      and	#$F0
    738  1ab1		       09 08		      ora	#$8
    739  1ab3		       85 c9		      sta	icc_colour
    740  1ab5							;		  lda C2,x
    741  1ab5							;    NEXT_RANDOM
    742  1ab5							;	      and #$F0
    743  1ab5							;	      ora #6
    744  1ab5							;		  sta icc_colour+1
    745  1ab5							;		  lda C3,x
    746  1ab5		       20 0c fd 	      jsr	Random
    747  1ab8				   ranother
    748  1ab8		       69 10		      adc	#$10
    749  1aba		       29 f0		      and	#$F0
    750  1abc		       09 08		      ora	#$8
    751  1abe		       c5 c9		      cmp	icc_colour
    752  1ac0		       f0 f6		      beq	ranother
    753  1ac2		       85 cb		      sta	icc_colour+2
    754  1ac4
    755  1ac4							; Update the level colours (self-modifying) in each of the character line banks
    756  1ac4
    757  1ac4		       a2 07		      ldx	#SCREEN_LINES-1
    758  1ac6				   setPlat
    759  1ac6		       a5 c9		      lda	icc_colour
    760  1ac8							;		      NEXT_RANDOM
    761  1ac8							;    ora #8
    762  1ac8		       a0 53		      ldy	#<SELFMOD_BLUE+1
    763  1aca		       20 1d f8 	      jsr	PutBoardCharacter
    764  1acd
    765  1acd							;		  lda icc_colour+1
    766  1acd							;		      NEXT_RANDOM
    767  1acd							;		  ldy #<SELFMOD_GREEN+1
    768  1acd							;		  jsr PutBoardCharacter
    769  1acd
    770  1acd							;		      NEXT_RANDOM
    771  1acd							;    ora #4
    772  1acd		       a5 cb		      lda	icc_colour+2
    773  1acf		       a0 1d		      ldy	#<SELFMOD_RED+1
    774  1ad1		       20 1d f8 	      jsr	PutBoardCharacter
    775  1ad4
    776  1ad4		       ca		      dex
    777  1ad5		       10 ef		      bpl	setPlat
    778  1ad7
    779  1ad7
    780  1ad7		       a9 00		      lda	#$00
    781  1ad9		       85 b6		      sta	BCD_moveCounter
    782  1adb		       85 b7		      sta	BCD_moveCounterHi
    783  1add		       85 b8		      sta	takebackIndex
    784  1adf		       85 b9		      sta	takebackBaseIndex
    785  1ae1
    786  1ae1		       a9 00		      lda	#$00	; BCD reminder!
    787  1ae3		       85 b5		      sta	BCD_targetsRequired	; # of targets that do NOT have boxes on them
    788  1ae5
    789  1ae5							;		ldx Platform
    790  1ae5							;		lda theThrottler,x
    791  1ae5							;		sta ThrottleSpeed
    792  1ae5
    793  1ae5							; first fill bg with character_soil
    794  1ae5							; then rle unpack level
    795  1ae5							; change level colours
    796  1ae5
    797  1ae5		       a9 00		      lda	#0
    798  1ae7		       85 87		      sta	POS_X
    799  1ae9		       85 88		      sta	POS_Y
    800  1aeb		       85 94		      sta	BoardLimit_Width
    801  1aed		       85 95		      sta	BoardLimit_Height
    802  1aef
    803  1aef				   GetNextItem
    804  1aef
    805  1aef		       a9 01		      lda	#1
    806  1af1		       85 d9		      sta	upk_length
    807  1af3		       a9 00		      lda	#0
    808  1af5		       85 da		      sta	upk_column	; reuse var - this flags a digit already
    809  1af7
    810  1af7		       e6 bb	   Get2       inc	Board_AddressR
    811  1af9		       d0 02		      bne	addrOK
    812  1afb		       e6 bc		      inc	Board_AddressR+1
    813  1afd				   addrOK
    814  1afd
    815  1afd		       a5 ab		      lda	LEVEL_bank
    816  1aff		       a0 00		      ldy	#0
    817  1b01		       20 0f f8 	      jsr	GetROMByte
    818  1b04		       85 db		      sta	upk_temp	;scratch
    819  1b06
    820  1b06
    821  1b06		       c9 00		      cmp	#0
    822  1b08		       d0 03		      bne	parse
    823  1b0a		       4c cb f1 	      jmp	finX
    824  1b0d				   parse
    825  1b0d		       c9 3a		      cmp	#"9"+1
    826  1b0f		       b0 1e		      bcs	notDigit
    827  1b11		       c9 30		      cmp	#"0"
    828  1b13		       90 1a		      bcc	notDigit
    829  1b15
    830  1b15		       a5 da		      lda	upk_column
    831  1b17		       f0 09		      beq	firstDig
    832  1b19
    833  1b19		       a5 d9		      lda	upk_length
    834  1b1b		       0a		      asl
    835  1b1c		       0a		      asl
    836  1b1d		       0a		      asl
    837  1b1e		       65 d9		      adc	upk_length
    838  1b20		       65 d9		      adc	upk_length
    839  1b22
    840  1b22		       18	   firstDig   clc
    841  1b23		       65 db		      adc	upk_temp
    842  1b25		       38		      sec
    843  1b26		       e9 30		      sbc	#"0"
    844  1b28		       85 d9		      sta	upk_length
    845  1b2a		       e6 da		      inc	upk_column	; flag we have seen a digit
    846  1b2c		       4c f7 f2 	      jmp	Get2
    847  1b2f
    848  1b2f		       c9 7c	   notDigit   cmp	#"|"	; newline
    849  1b31		       d0 11		      bne	checkWall
    850  1b33
    851  1b33							; Handle new-line
    852  1b33		       a9 00		      lda	#0
    853  1b35		       85 87		      sta	POS_X
    854  1b37		       e6 88		      inc	POS_Y
    855  1b39
    856  1b39
    857  1b39		       a5 88		      lda	POS_Y
    858  1b3b		       c5 95		      cmp	BoardLimit_Height
    859  1b3d		       90 02		      bcc	wOK2
    860  1b3f		       85 95		      sta	BoardLimit_Height	;???^^^
    861  1b41				   wOK2
    862  1b41
    863  1b41		       4c ef f2 	      jmp	GetNextItem
    864  1b44
    865  1b44		       c9 23	   checkWall  cmp	#"#"	; wall
    866  1b46		       d0 09		      bne	checkForGap
    867  1b48							;		  NEXT_RANDOM
    868  1b48		       a5 c8		      lda	rnd
    869  1b4a		       29 01		      and	#1
    870  1b4c		       18		      clc
    871  1b4d		       69 06		      adc	#CHARACTER_STEEL
    872  1b4f		       d0 62		      bne	WriteChars
    873  1b51
    874  1b51		       c9 20	   checkForGap cmp	#32
    875  1b53		       f0 08		      beq	writeGap
    876  1b55		       c9 2d		      cmp	#"-"
    877  1b57		       f0 04		      beq	writeGap
    878  1b59		       c9 5f		      cmp	#"_"
    879  1b5b		       d0 05		      bne	checkForMan
    880  1b5d
    881  1b5d		       a9 00	   writeGap   lda	#CHARACTER_BLANK
    882  1b5f		       4c b3 f3 	      jmp	WriteChars
    883  1b62
    884  1b62				   checkForMan
    885  1b62		       c9 2b		      cmp	#"+"	; player on goal square
    886  1b64		       d0 07		      bne	notPlayerGoal
    887  1b66
    888  1b66		       20 f8 fc 	      jsr	RegisterTarget
    889  1b69
    890  1b69							; put goal square, init player with POS_VAR = CHARACTER_TARGET
    891  1b69
    892  1b69		       a9 03		      lda	#CHARACTER_TARGET
    893  1b6b		       d0 06		      bne	genPlayer
    894  1b6d
    895  1b6d				   notPlayerGoal
    896  1b6d		       c9 40		      cmp	#"@"	; player on normal square
    897  1b6f		       d0 29		      bne	checkBox
    898  1b71
    899  1b71		       a9 00		      lda	#CHARACTER_BLANK
    900  1b73
    901  1b73				   genPlayer
    902  1b73
    903  1b73		       85 8c		      sta	POS_VAR	; character man is on
    904  1b75
    905  1b75		       18		      clc
    906  1b76		       a5 87		      lda	POS_X
    907  1b78		       48		      pha
    908  1b79		       65 d7		      adc	base_x
    909  1b7b		       85 87		      sta	POS_X
    910  1b7d		       85 9d		      sta	ManX
    911  1b7f
    912  1b7f		       a5 88		      lda	POS_Y
    913  1b81		       48		      pha
    914  1b82		       65 d8		      adc	base_y
    915  1b84		       85 88		      sta	POS_Y
    916  1b86		       85 9e		      sta	ManY
    917  1b88
    918  1b88							; POS_X     x position
    919  1b88							; POS_Y     y position
    920  1b88							; POS_VAR   CHARACTER UNDER MAN TO RESTORE
    921  1b88							; POS_Type  type of object
    922  1b88
    923  1b88		       a9 00		      lda	#TYPE_MAN
    924  1b8a		       85 8b		      sta	POS_Type	;	 creature TYPE
    925  1b8c		       20 fb f8 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    926  1b8f
    927  1b8f		       68		      pla
    928  1b90		       85 88		      sta	POS_Y
    929  1b92		       68		      pla
    930  1b93		       85 87		      sta	POS_X
    931  1b95
    932  1b95		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    933  1b97		       4c b3 f3 	      jmp	WriteChars
    934  1b9a
    935  1b9a		       c9 24	   checkBox   cmp	#"$"
    936  1b9c		       d0 04		      bne	checkBoxTarget
    937  1b9e
    938  1b9e		       a9 02		      lda	#CHARACTER_BOX
    939  1ba0		       d0 11		      bne	WriteChars
    940  1ba2
    941  1ba2		       c9 2a	   checkBoxTarget cmp	#"*"
    942  1ba4		       d0 04		      bne	checkTarget
    943  1ba6
    944  1ba6		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    945  1ba8		       d0 09		      bne	WriteChars
    946  1baa
    947  1baa		       c9 2e	   checkTarget cmp	#"."
    948  1bac		       f0 03		      beq	targ
    949  1bae		       4c ef f2 	      jmp	GetNextItem
    950  1bb1				   targ
    951  1bb1
    952  1bb1		       a9 03		      lda	#CHARACTER_TARGET
    953  1bb3
    954  1bb3		       85 8b	   WriteChars sta	POS_Type
    955  1bb5
    956  1bb5		       18	   Wc2x       clc
    957  1bb6		       a5 87		      lda	POS_X
    958  1bb8		       48		      pha
    959  1bb9		       65 d7		      adc	base_x
    960  1bbb		       85 87		      sta	POS_X
    961  1bbd
    962  1bbd		       a5 88		      lda	POS_Y
    963  1bbf		       48		      pha
    964  1bc0		       65 d8		      adc	base_y
    965  1bc2		       85 88		      sta	POS_Y
    966  1bc4
    967  1bc4		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    968  1bc7
    969  1bc7		       a5 8b		      lda	POS_Type
    970  1bc9		       c9 03		      cmp	#CHARACTER_TARGET
    971  1bcb		       d0 03		      bne	notargdet
    972  1bcd		       20 f8 fc 	      jsr	RegisterTarget
    973  1bd0				   notargdet
    974  1bd0
    975  1bd0		       68		      pla
    976  1bd1		       85 88		      sta	POS_Y
    977  1bd3		       68		      pla
    978  1bd4		       85 87		      sta	POS_X
    979  1bd6
    980  1bd6		       18		      clc
    981  1bd7		       69 01		      adc	#1
    982  1bd9		       85 87		      sta	POS_X
    983  1bdb
    984  1bdb		       c5 94		      cmp	BoardLimit_Width
    985  1bdd		       90 02		      bcc	wOK
    986  1bdf		       85 94		      sta	BoardLimit_Width
    987  1be1				   wOK
    988  1be1
    989  1be1		       c6 d9		      dec	upk_length
    990  1be3		       d0 d0		      bne	Wc2x
    991  1be5		       4c ef f2 	      jmp	GetNextItem
    992  1be8
    993  1be8				   finishedUnpack
    994  1be8
    995  1be8		       60		      rts
    996  1be8					      endif
------- FILE BANK_GENERIC.asm
     44  1be9
      0  1be9					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_LEVEL)"
      1  1be9
      2  1be9
      3  1be9		       03 e9	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_LEVEL) (1K) SIZE =  $3e9 , FREE= $17
      4  1be9					      ECHO	"GENERIC_BANK_1 (DECODE_LEVEL)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1be9				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1be9				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1be9				  -	      ERR
      8  1be9					      endif
     46  1be9
     47  1be9							;------------------------------------------------------------------------------
     48  1be9							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     49  1be9							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     50  1be9							; bank finishes.  Just continue on from where it left off...
     51  1be9							;------------------------------------------------------------------------------
     52  1be9
      0  1be9					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  1be9		       00 03	   BANK_Cart_Init =	_CURRENT_BANK
      2  1be9					      SUBROUTINE
      3  1be9				   Cart_Init
     54  1be9
     55  1be9							; Note the variables from the title selection are incredibly transient an can be stomped
     56  1be9							; at any time.  So they need to be used immediately.
     57  1be9
     58  1be9
     59  1be9							; odd usage below is to prevent any possibility of variable stomping/assumptions
     60  1be9
     61  1be9		       a9 01		      lda	#1
     62  1beb		       a2 00		      ldx	#0	;sLevel				      ; level # from title select
     63  1bed		       a0 00		      ldy	#0	;sJoysticks
     64  1bef		       84 aa		      sty	jtoggle
     65  1bf1		       86 b3		      stx	level
     66  1bf3		       a9 00		      lda	#0
     67  1bf5							;sta levelX					    ; make an immediate copy to safe variables!
     68  1bf5		       85 dd		      sta	startingLevel
     69  1bf7
     70  1bf7							; multiply with LEVEL_DEFINITION_SIZE (5):
     71  1bf7		       0a		      asl
     72  1bf8		       0a		      asl
     73  1bf9		       85 b2		      sta	levelX
     74  1bfb
      0  1bfb					      LOAD_ANIMATION	IDLE
      1  1bfb		       a9 42		      lda	#<Animation_IDLE
      2  1bfd		       85 9a		      sta	animation
      3  1bff		       a9 f0		      lda	#>Animation_IDLE
      4  1c01		       85 9b		      sta	animation+1
      5  1c03		       a9 00		      lda	#0
      6  1c05		       85 9c		      sta	animation_delay
      7  1c07		       a9 02		      lda	#ANIMATION_IDLE_ID
      8  1c09		       85 a6		      sta	ManAnimationID
      9  1c0b
     76  1c0b
     77  1c0b		       a9 00		      lda	#0
     78  1c0d		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     79  1c10		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     80  1c13		       85 6b		      sta	HMCLR
     81  1c15
     82  1c15							; cleanup remains of title screen
     83  1c15		       85 5b		      sta	GRP0
     84  1c17		       85 5c		      sta	GRP1
     85  1c19							;?		   sta GRP0
     86  1c19
     87  1c19		       a9 10		      lda	#%00010000	; 2	 double width missile, double width player
     88  1c1b		       85 44		      sta	NUSIZ0	; 3
     89  1c1d		       85 45		      sta	NUSIZ1
     90  1c1f
     91  1c1f		       85 86		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     92  1c21		       85 c5		      sta	ethnic
     93  1c23
     94  1c23		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     95  1c25		       85 4a		      sta	CTRLPF
     96  1c27
     97  1c27		       a9 ff		      lda	#$FF
     98  1c29		       85 81		      sta	DrawStackPointer
     99  1c2b		       85 92		      sta	BufferedJoystick
    100  1c2d
    101  1c2d							;lda #DIRECTION_BITS		  ;???
    102  1c2d							;sta ManLastDirection
    103  1c2d
    104  1c2d							;lda #0
    105  1c2d							;		  sta ObjStackPtr		  ; object stack index of last entry
    106  1c2d							;		  sta ObjStackPtr+1
    107  1c2d							;		  sta ObjStackNum
    108  1c2d							;		  sta ObjIterator
    109  1c2d
    110  1c2d							;sta sortPtr
    111  1c2d							;lda #<(-1)
    112  1c2d							;sta sortRequired
    113  1c2d
    114  1c2d							; read high score from SaveKey and store in highScoreSK,
    115  1c2d							; which is transferred to high score variable in RAM by GeneralScoringSetups
    116  1c2d
    117  1c2d		       4c bc f5 	      jmp	ReadSaveKey
    118  1c30
    119  1c30							;------------------------------------------------------------------------------
    120  1c30
      0  1c30					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  1c30		       00 03	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  1c30					      SUBROUTINE
      3  1c30				   SwapPlayersGeneric
    122  1c30
    123  1c30							; at the start of a level (or player, doesn't matter) we grab the current state of the colour/B&W switch
    124  1c30							; into the gameMode variable.
    125  1c30
    126  1c30							;		  lda gameMode
    127  1c30							;		  and #~(BW_SWITCH|GAMEMODE_PAUSED)
    128  1c30							;		  sta gameMode
    129  1c30							;		  lda SWCHB
    130  1c30							;		  and #BW_SWITCH
    131  1c30							;		  ora gameMode			  ; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    132  1c30							;		  sta gameMode			  ; also, BIT7=0 -- system is NOT paused
    133  1c30
    134  1c30
    135  1c30							; restart level
    136  1c30		       a5 c2		      lda	NextLevelTrigger
    137  1c32		       29 bf		      and	#<(~BIT_NEXTLIFE)
    138  1c34		       85 c2		      sta	NextLevelTrigger
    139  1c36
    140  1c36							; if new high score was set by SwapPlayers, update it:
    141  1c36
    142  1c36		       4c e2 f5 	      jmp	WriteSaveKey
    143  1c39
    144  1c39
    145  1c39							;------------------------------------------------------------------------------
    146  1c39
      0  1c39					      DEFINE_SUBROUTINE	CreateCreatures
      1  1c39		       00 03	   BANK_CreateCreatures =	_CURRENT_BANK
      2  1c39					      SUBROUTINE
      3  1c39				   CreateCreatures
    148  1c39
    149  1c39							; Calculate rightmost value for scrolling edge.  .
    150  1c39
    151  1c39		       85 bf		      sta	ROM_Bank
    152  1c3b
    153  1c3b		       38		      sec
    154  1c3c		       a5 94		      lda	BoardLimit_Width
    155  1c3e		       e9 09		      sbc	#SCREEN_WIDTH-1
    156  1c40		       85 94		      sta	BoardEdge_Right	; absolute rightmost scroll value
    157  1c42
    158  1c42							;		  sec			     already set
    159  1c42		       a5 95		      lda	BoardLimit_Height
    160  1c44		       e9 07		      sbc	#SCREEN_LINES-1
    161  1c46		       85 95		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    162  1c48
    163  1c48							; kludge position scroll roughly at player
    164  1c48
    165  1c48							;		  sec			 already set
    166  1c48		       a5 9d		      lda	ManX
    167  1c4a		       e9 05		      sbc	#5
    168  1c4c		       b0 02		      bcs	notL0
    169  1c4e		       a9 00		      lda	#0
    170  1c50		       85 97	   notL0      sta	BoardScrollX
    171  1c52
    172  1c52		       38		      sec
    173  1c53		       a5 9e		      lda	ManY
    174  1c55		       e9 04		      sbc	#4
    175  1c57		       b0 02		      bcs	notU0
    176  1c59		       a9 00		      lda	#0
    177  1c5b		       85 96	   notU0      sta	BoardScrollY
    178  1c5d
    179  1c5d		       a9 00		      lda	#0
    180  1c5f		       85 a1		      sta	ManMode
    181  1c61							;sta ManDelayCount
    182  1c61		       85 ba		      sta	TakebackInhibit
    183  1c63		       85 d7		      sta	base_x
    184  1c65		       85 d8		      sta	base_y
    185  1c67		       85 a4		      sta	ManPushCounter
    186  1c69
    187  1c69		       a9 ff		      lda	#$FF
    188  1c6b		       85 af		      sta	LastSpriteY
    189  1c6d		       85 a6		      sta	ManAnimationID
    190  1c6f
    191  1c6f							;lda #DIRECTION_BITS		  ;????
    192  1c6f							;sta ManLastDirection		  ; duplicate?
    193  1c6f
    194  1c6f		       60		      rts
    195  1c70
    196  1c70							;-------------------------------------------------------------------------------------
    197  1c70
      0  1c70					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  1c70		       00 03	   BANK_LevelInit =	_CURRENT_BANK
      2  1c70					      SUBROUTINE
      3  1c70				   LevelInit
    199  1c70
    200  1c70		       a9 00		      lda	#0
    201  1c72		       85 83		      sta	ObjStackPtr
    202  1c74		       85 84		      sta	ObjStackPtr+1	; kill all creatures
    203  1c76		       85 82		      sta	ObjStackNum
    204  1c78		       85 c3		      sta	ObjIterator
    205  1c7a
    206  1c7a		       85 98		      sta	scrollBits
    207  1c7c		       85 86		      sta	ScreenDrawPhase
    208  1c7e
    209  1c7e		       85 b1		      sta	BGColour
    210  1c80		       85 c1		      sta	ColourTimer
    211  1c82		       85 a5		      sta	LookingAround
    212  1c84
    213  1c84		       a9 ff		      lda	#255
    214  1c86		       85 b4		      sta	Throttle
    215  1c88		       85 92		      sta	BufferedJoystick
    216  1c8a
    217  1c8a		       a9 00		      lda	#0
    218  1c8c		       85 59		      sta	AUDV0
    219  1c8e		       85 5a		      sta	AUDV1	; turn off music while levels init
    220  1c90							;		  sta AUDC0
    221  1c90
    222  1c90							;		  sta VBLANK
    223  1c90
    224  1c90
    225  1c90		       85 81		      sta	DrawStackPointer
    226  1c92
    227  1c92							;lda #DISPLAY_TIME ;DISPLAY_SCORE
    228  1c92							;sta scoringFlags
    229  1c92							;lda #0 ;SCORING_TIMER_FIRST		      ; We want the first timer display to be long, to show level and lives
    230  1c92							;sta scoringTimer
    231  1c92
    232  1c92		       18		      clc
    233  1c93		       a5 c5		      lda	ethnic
    234  1c95		       69 10		      adc	#16
    235  1c97		       c9 40		      cmp	#4*16
    236  1c99		       90 02		      bcc	ethOK
    237  1c9b		       a9 00		      lda	#0
    238  1c9d		       85 c5	   ethOK      sta	ethnic
    239  1c9f
    240  1c9f		       60		      rts
    241  1ca0
    242  1ca0							;-------------------------------------------------------------------------------------
    243  1ca0
      0  1ca0					      DEFINE_SUBROUTINE	Resync
      1  1ca0		       00 03	   BANK_Resync =	_CURRENT_BANK
      2  1ca0					      SUBROUTINE
      3  1ca0				   Resync
      0  1ca0					      RESYNC
      1  1ca0
      2  1ca0		       a9 02		      lda	#%10
      3  1ca2		       85 41		      sta	VBLANK
      4  1ca4
      5  1ca4		       a2 08		      ldx	#8
      6  1ca6				   .loopResync
      0  1ca6					      VERTICAL_SYNC
      1  1ca6		       a9 0e		      lda	#%1110
      2  1ca8		       85 42	   .VSLP1     sta	WSYNC
      3  1caa		       85 40		      sta	VSYNC
      4  1cac		       4a		      lsr
      5  1cad		       d0 f9		      bne	.VSLP1
      8  1caf
      9  1caf		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  1cb1		       a5 80		      lda	Platform
     11  1cb3		       49 02		      eor	#PAL_50
     12  1cb5		       d0 02		      bne	.ntsc
     13  1cb7		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  1cb9				   .ntsc
     15  1cb9				   .loopWait
     16  1cb9		       85 42		      sta	WSYNC
     17  1cbb		       85 42		      sta	WSYNC
     18  1cbd		       88		      dey
     19  1cbe		       d0 f9		      bne	.loopWait
     20  1cc0		       ca		      dex
     21  1cc1		       d0 e3		      bne	.loopResync
    246  1cc3		       60	   Ret	      rts
    247  1cc4
    248  1cc4							;---------------------------------------------------------------------------
    249  1cc4
      0  1cc4					      DEFINE_SUBROUTINE	TrackPlayer	; =76
      1  1cc4		       00 03	   BANK_TrackPlayer =	_CURRENT_BANK
      2  1cc4					      SUBROUTINE
      3  1cc4				   TrackPlayer
    251  1cc4
    252  1cc4		       a5 a5		      lda	LookingAround	; 3
    253  1cc6		       d0 36		      bne	EarlyAbortx	; 2/3	     don't track when looking around
    254  1cc8
    255  1cc8		       00 02	   .SCRL_START_LEFT =	2
    256  1cc8		       00 08	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT
    257  1cc8		       00 02	   .SCRL_START_UP =	2
    258  1cc8		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP
    259  1cc8
    260  1cc8		       a5 9d		      lda	ManX	; 3
    261  1cca		       38		      sec		; 2
    262  1ccb		       e5 97		      sbc	BoardScrollX	; 3
    263  1ccd		       a8		      tay		; 2 = 10	  for later use
    264  1cce
    265  1cce		       a9 ff		      lda	#-1	; 2
    266  1cd0		       c0 02		      cpy	#.SCRL_START_LEFT	; 2
    267  1cd2		       30 06		      bmi	.startXScroll	; 2/3
    268  1cd4		       c0 08		      cpy	#.SCRL_START_RIGHT	; 2
    269  1cd6		       30 0b		      bmi	.skipXScroll	; 2/3
    270  1cd8		       a9 01		      lda	#1	; 2 = 12
    271  1cda
    272  1cda		       18	   .startXScroll clc		; 2
    273  1cdb		       65 97		      adc	BoardScrollX	; 3
    274  1cdd		       c5 94		      cmp	BoardEdge_Right	; 3
    275  1cdf		       b0 02		      bcs	.skipXScroll	; 2/3
    276  1ce1		       85 97		      sta	BoardScrollX	; 3 = 13
    277  1ce3
    278  1ce3				   .skipXScroll
    279  1ce3
    280  1ce3							; = 35 worst
    281  1ce3
    282  1ce3		       a5 9e		      lda	ManY	; 3
    283  1ce5		       38		      sec		; 2
    284  1ce6		       e5 96		      sbc	BoardScrollY	; 3
    285  1ce8		       a8		      tay		; 2 = 10	  for later use
    286  1ce9
    287  1ce9		       a9 ff		      lda	#-1	; 2
    288  1ceb		       c0 02		      cpy	#.SCRL_START_UP	; 2
    289  1ced		       30 06		      bmi	.startYScroll	; 2/3
    290  1cef		       c0 06		      cpy	#.SCRL_START_DOWN	; 2
    291  1cf1		       30 0b		      bmi	.skipYScroll	; 2/3
    292  1cf3		       a9 01		      lda	#1	; 2 = 12
    293  1cf5
    294  1cf5		       18	   .startYScroll clc		; 2
    295  1cf6		       65 96		      adc	BoardScrollY	; 3
    296  1cf8		       c5 95		      cmp	BoardEdge_Bottom	; 3
    297  1cfa		       b0 02		      bcs	.skipYScroll	; 2/3
    298  1cfc		       85 96		      sta	BoardScrollY	; 3 = 13
    299  1cfe
    300  1cfe				   .skipYScroll
    301  1cfe
    302  1cfe							; = 35 worst
    303  1cfe
    304  1cfe		       60	   EarlyAbortx rts		; 6 =	6
    305  1cff
    306  1cff
    307  1cff							;------------------------------------------------------------------------------
    308  1cff
    309  1cff							; This is a GOOD home for these tables.
    310  1cff
      0  1cff					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  1cff		       00 03	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  1cff					      SUBROUTINE
      3  1cff				   TS_PhaseVectorLO
    312  1cff
    313  1cff							; Gives LO byte of addresses of subroutines for timeslice processing
    314  1cff							; note +31✅ cycles at start of the function called
    315  1cff
    316  1cff		       58		      .byte.b	<ProcessObjStack	; abort = 46✅
    317  1d00		       fc		      .byte.b	<DrawFullScreen	; abort = 46✅
    318  1d01		       b0		      .byte.b	<BuildDrawStack	; abort = 54✅
    319  1d02		       b7		      .byte.b	<DrawAIntoStack	; abort = 54✅
    320  1d03		       91		      .byte.b	<SwitchObjects	; abort = 46✅
    321  1d04
    322  1d04				   TS_PhaseVectorHI
    323  1d04
    324  1d04							; Gives HI byte of addresses of subroutines for timeslice processing
    325  1d04
    326  1d04		       f8		      .byte.b	>ProcessObjStack
    327  1d05		       f2		      .byte.b	>DrawFullScreen
    328  1d06		       fb		      .byte.b	>BuildDrawStack
    329  1d07		       fb		      .byte.b	>DrawAIntoStack
    330  1d08		       f8		      .byte.b	>SwitchObjects
    331  1d09
    332  1d09				   TS_PhaseBank
    333  1d09
    334  1d09							; Gives bank of subroutines for timeslice processing
    335  1d09
    336  1d09		       0f		      .byte.b	BANK_ProcessObjStack
    337  1d0a		       0d		      .byte.b	BANK_DrawFullScreen
    338  1d0b		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    339  1d0c		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    340  1d0d		       0f		      .byte.b	BANK_SwitchObjects
    341  1d0e
    342  1d0e							;------------------------------------------------------------------------------
    343  1d0e
    344  1d0e				   OverscanTime
    345  1d0e		       23 23		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    346  1d10		       29 23		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    347  1d12
    348  1d12
    349  1d12		       00 12	   THROT_BASE =	18
    350  1d12				   theThrottler
    351  1d12		       12 12 15 12	      .byte.b	THROT_BASE, THROT_BASE, THROT_BASE*60/50, THROT_BASE
    352  1d16
      0  1d16					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  1d16		       00 03	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  1d16					      SUBROUTINE
      3  1d16				   PostScreenCleanup
    354  1d16
    355  1d16		       c8		      iny		; --> 0
    356  1d17
    357  1d17		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    358  1d19							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    359  1d19
    360  1d19		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    361  1d1b							; TJ: no idea why, but you had removed it in revision 758 ;)
    362  1d1b							; completely accidental -- one of our cats may have deleted it.
    363  1d1b		       84 4e		      sty	PF1
    364  1d1d		       84 4f		      sty	PF2
    365  1d1f		       84 5d		      sty	ENAM0
    366  1d21		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    367  1d23		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    368  1d25
    369  1d25							; D1 VBLANK turns off beam
    370  1d25
    371  1d25		       a9 42		      lda	#%01000010	; bit6 is not required
    372  1d27		       85 41		      sta	VBLANK	; end of screen - enter blanking
    373  1d29
    374  1d29							;------------------------------------------------------------------------------
    375  1d29							; This is where the PAL system has a bit of extra time on a per-frame basis.
    376  1d29
    377  1d29		       a6 80		      ldx	Platform
    378  1d2b		       bd 0e f5 	      lda	OverscanTime,x
    379  1d2e		       8d 96 02 	      sta	TIM64T
    380  1d31
    381  1d31							; Background colour priorities. Increasing order of priority...
    382  1d31							;	black -- nothing happening
    383  1d31							;	looking around			     lookingAround<0		     BLUE
    384  1d31							;	when paused			     gameMode... BIT7		     RED
    385  1d31							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    386  1d31
    387  1d31		       a6 80		      ldx	Platform
    388  1d33		       bd 12 f5 	      lda	theThrottler,x
    389  1d36		       18		      clc
    390  1d37		       65 b4		      adc	Throttle
    391  1d39		       b0 02		      bcs	noVerflo
    392  1d3b		       85 b4		      sta	Throttle
    393  1d3d				   noVerflo
    394  1d3d
    395  1d3d							;----------------------------------------------------------------------------------------------
    396  1d3d
    397  1d3d							; has to be done AFTER screen display, because it disables the effect!
    398  1d3d							;SLEEP 6
    399  1d3d							;lda rnd		      ; 3     randomly reposition the Cosmic Ark missile
    400  1d3d							;sta HMM0		      ; 3     this assumes that HMOVE is called at least once/frame
    401  1d3d
    402  1d3d							; "Flash" has highest BG colour priority
    403  1d3d
    404  1d3d		       a5 c1		      lda	ColourTimer
    405  1d3f		       f0 08		      beq	noFlashBG
    406  1d41		       c6 c1		      dec	ColourTimer
    407  1d43		       d0 04		      bne	noFlashBG
    408  1d45		       a9 00		      lda	#0
    409  1d47		       85 b1		      sta	BGColour
    410  1d49							;lda ColourFlash
    411  1d49							;lda FlashColour,x
    412  1d49				   noFlashBG
    413  1d49							;	 sta BGColour
    414  1d49
    415  1d49							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    416  1d49
    417  1d49		       ad 80 02 	      lda	SWCHA
    418  1d4c		       25 92		      and	BufferedJoystick
    419  1d4e		       85 92		      sta	BufferedJoystick
    420  1d50
    421  1d50		       60		      rts
    422  1d51
    423  1d51							;------------------------------------------------------------------------------
    424  1d51
------- FILE i2c_v2.2.inc LEVEL 3 PASS 3
      0  1d51					      include	"i2c_v2.2.inc"
      1  1d51							;
      2  1d51							; i2c_v2.2.inc
      3  1d51							;
      4  1d51							;
      5  1d51							; AtariVox EEPROM Driver
      6  1d51							;
      7  1d51							; By Alex Herbert, 2004
      8  1d51							;
      9  1d51							; Optimisations by Thomas Jentzsch, 2006/2008
     10  1d51							;
     11  1d51
     12  1d51
     13  1d51							; I/O Constants
     14  1d51
     15  1d51		       00 04	   I2C_SDA_MASK equ	$04
     16  1d51		       00 08	   I2C_SCL_MASK equ	$08
     17  1d51
     18  1d51
     19  1d51							; Signalling Macros
     20  1d51
     21  1d51							;  MAC     I2C_SCL_0
     22  1d51							;    lda     #$00
     23  1d51							;    sta     SWCHA
     24  1d51							;  ENDM
     25  1d51
     26  1d51							;  MAC     I2C_SCL_1
     27  1d51							;    lda     #I2C_SCL_MASK
     28  1d51							;    sta     SWCHA
     29  1d51							;  ENDM
     30  1d51
     31  1d51							;  MAC     I2C_SDA_IN
     32  1d51							;    lda     #I2C_SCL_MASK
     33  1d51							;    sta     SWACNT
     34  1d51							;  ENDM
     35  1d51
     36  1d51							;  MAC     I2C_SDA_OUT
     37  1d51							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  1d51							;    sta     SWACNT
     39  1d51							;  ENDM
     40  1d51
     41  1d51
     42  1d51					      MAC	i2c_start
     43  1d51							; I2C_SCL_1
     44  1d51					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  1d51					      sta	SWCHA	; 4
     46  1d51							; I2C_SDA_OUT
     47  1d51					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  1d51					      sta	SWACNT	; 4
     49  1d51							; total: 12 cycles
     50  1d51					      ENDM
     51  1d51
     52  1d51
     53  1d51					      MAC	i2c_txbit
     54  1d51							; I2C_SCL_0
     55  1d51					      lda	#%0011	; 2
     56  1d51					      sta	SWCHA	; 4
     57  1d51							; set bit
     58  1d51					      adc	#%1000	; 2
     59  1d51					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  1d51							; I2C_SCL_1
     61  1d51					      lda	#I2C_SCL_MASK	; 2
     62  1d51					      sta	SWCHA	; 4
     63  1d51							; total: 18 cycles
     64  1d51					      ENDM
     65  1d51
     66  1d51
     67  1d51					      MAC	i2c_txnack
     68  1d51							; I2C_SCL_0
     69  1d51					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  1d51					      sta	SWCHA	; 4
     71  1d51							; I2C_SDA_IN
     72  1d51					      lsr		; 2	     I2C_SCL_MASK
     73  1d51					      sta	SWACNT	; 4
     74  1d51							; I2C_SCL_1
     75  1d51					      nop		; 2	     required for timing!
     76  1d51					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  1d51							; total: 18 cycles
     78  1d51					      ENDM
     79  1d51
     80  1d51
     81  1d51							; Subroutine Macros
     82  1d51
     83  1d51					      MAC	i2c_subs
     84  1d51
     85  1d51				   i2c_startread
     86  1d51							; use V to flag if previous byte needs ACK
     87  1d51					      ldy	#%10100001	; 2	     eeprom read command
     88  1d51					      .byte	$2c	; 2
     89  1d51				   i2c_startwrite
     90  1d51					      ldy	#%10100000	; 2	     eeprom write command
     91  1d51					      I2C_START		;12	     start signal (clears V flag)
     92  1d51					      tya		; 2 = 16
     93  1d51				   i2c_txbyte
     94  1d51					      eor	#$ff	; 2	     invert data byte
     95  1d51					      sec		; 2
     96  1d51					      rol		; 2 =	6    shift loop bit into a
     97  1d51				   i2c_txbyteloop
     98  1d51					      tay		; 2
     99  1d51					      I2C_TXBIT		;18	     transmit
    100  1d51					      tya		; 2
    101  1d51					      asl		; 2	     shift next bit into C
    102  1d51					      bne	i2c_txbyteloop	; 2= 26/27
    103  1d51
    104  1d51							; receive acknowledge bit
    105  1d51
    106  1d51					      beq	i2c_rxbit	;43 = 43
    107  1d51							; i2c_txbyte: 264 cycles
    108  1d51							;-------------------------------------------------------------------------------
    109  1d51
    110  1d51				   i2c_rxbyte
    111  1d51					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  1d51					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  1d51
    114  1d51				   i2c_rxskipack
    115  1d51					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  1d51
    117  1d51					      lda	#1	; 2
    118  1d51				   i2c_rxbyteloop
    119  1d51					      tay		; 2 =	2
    120  1d51				   i2c_rxbit		;	     receive bit in C
    121  1d51					      I2C_TXNACK		;18 = 18
    122  1d51
    123  1d51					      lda	SWCHA	; 4
    124  1d51					      lsr		; 2
    125  1d51					      lsr		; 2
    126  1d51					      lsr		; 2 = 10    C = SDA
    127  1d51
    128  1d51					      tya		; 2
    129  1d51					      rol		; 2	     rotate into Y
    130  1d51					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  1d51
    132  1d51							; received byte in A
    133  1d51					      rts		; 6 =	6
    134  1d51							; i2c_rxbit:  40 cycles
    135  1d51							; i2c_rxbyte: 310/333 cycles
    136  1d51							;-------------------------------------------------------------------------------
    137  1d51
    138  1d51				   i2c_stopread
    139  1d51					      bvc	i2c_stopwrite	; 2
    140  1d51					      ldy	#$80	; 2
    141  1d51					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  1d51
    143  1d51				   i2c_stopwrite
    144  1d51					      jsr	i2c_txack	;30
    145  1d51
    146  1d51							; return port to input mode
    147  1d51					      lda	#0	; 2	     0
    148  1d51					      sta	SWACNT	; 4
    149  1d51					      rts		; 6 = 12
    150  1d51							; i2c_stopread:  45/92
    151  1d51							; i2c_stopwrite: 42
    152  1d51							;-------------------------------------------------------------------------------
    153  1d51
    154  1d51				   i2c_txack
    155  1d51							; I2C_SCL_0
    156  1d51					      lda	#0	; 2	     $00
    157  1d51					      sta	SWCHA	; 4
    158  1d51							; I2C_SDA_OUT
    159  1d51					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  1d51					      sta	SWACNT	; 4
    161  1d51							; I2C_SCL_1
    162  1d51					      asl		; 2	     I2C_SCL_MASK
    163  1d51					      sta	SWCHA	; 4
    164  1d51
    165  1d51					      rts		; 6
    166  1d51							; total: 24 cycles
    167  1d51							;-------------------------------------------------------------------------------
    168  1d51
    169  1d51					      ENDM
    170  1d51
    171  1d51
    172  1d51
------- FILE BANK_GENERIC.asm
    426  1d51
      0  1d51					      i2c_subs
      1  1d51
      2  1d51				   i2c_startread
      3  1d51
      4  1d51		       a0 a1		      ldy	#%10100001
      5  1d53		       2c		      .byte.b	$2c
      6  1d54				   i2c_startwrite
      7  1d54		       a0 a0		      ldy	#%10100000
      0  1d56					      I2C_START
      1  1d56
      2  1d56		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  1d58		       8d 80 02 	      sta	SWCHA
      4  1d5b
      5  1d5b		       4a		      lsr
      6  1d5c		       8d 81 02 	      sta	SWACNT
      7  1d5f
      9  1d5f		       98		      tya
     10  1d60				   i2c_txbyte
     11  1d60		       49 ff		      eor	#$ff
     12  1d62		       38		      sec
     13  1d63		       2a		      rol
     14  1d64				   i2c_txbyteloop
     15  1d64		       a8		      tay
      0  1d65					      I2C_TXBIT
      1  1d65
      2  1d65		       a9 03		      lda	#%0011
      3  1d67		       8d 80 02 	      sta	SWCHA
      4  1d6a
      5  1d6a		       69 08		      adc	#%1000
      6  1d6c		       8d 81 02 	      sta	SWACNT
      7  1d6f
      8  1d6f		       a9 08		      lda	#I2C_SCL_MASK
      9  1d71		       8d 80 02 	      sta	SWCHA
     10  1d74
     17  1d74		       98		      tya
     18  1d75		       0a		      asl
     19  1d76		       d0 ec		      bne	i2c_txbyteloop
     20  1d78
     21  1d78
     22  1d78
     23  1d78		       f0 0b		      beq	i2c_rxbit
     24  1d7a
     25  1d7a
     26  1d7a
     27  1d7a				   i2c_rxbyte
     28  1d7a		       50 03		      bvc	i2c_rxskipack
     29  1d7c		       20 ad f5 	      jsr	i2c_txack
     30  1d7f
     31  1d7f				   i2c_rxskipack
     32  1d7f		       2c 7a f5 	      bit	i2c_rxbyte
     33  1d82
     34  1d82		       a9 01		      lda	#1
     35  1d84				   i2c_rxbyteloop
     36  1d84		       a8		      tay
     37  1d85				   i2c_rxbit
      0  1d85					      I2C_TXNACK
      1  1d85
      2  1d85		       a9 10		      lda	#I2C_SCL_MASK*2
      3  1d87		       8d 80 02 	      sta	SWCHA
      4  1d8a
      5  1d8a		       4a		      lsr
      6  1d8b		       8d 81 02 	      sta	SWACNT
      7  1d8e
      8  1d8e		       ea		      nop
      9  1d8f		       8d 80 02 	      sta	SWCHA
     10  1d92
     39  1d92
     40  1d92		       ad 80 02 	      lda	SWCHA
     41  1d95		       4a		      lsr
     42  1d96		       4a		      lsr
     43  1d97		       4a		      lsr
     44  1d98
     45  1d98		       98		      tya
     46  1d99		       2a		      rol
     47  1d9a		       90 e8		      bcc	i2c_rxbyteloop
     48  1d9c
     49  1d9c
     50  1d9c		       60		      rts
     51  1d9d
     52  1d9d
     53  1d9d
     54  1d9d
     55  1d9d				   i2c_stopread
     56  1d9d		       50 05		      bvc	i2c_stopwrite
     57  1d9f		       a0 80		      ldy	#$80
     58  1da1		       20 85 f5 	      jsr	i2c_rxbit
     59  1da4
     60  1da4				   i2c_stopwrite
     61  1da4		       20 ad f5 	      jsr	i2c_txack
     62  1da7
     63  1da7
     64  1da7		       a9 00		      lda	#0
     65  1da9		       8d 81 02 	      sta	SWACNT
     66  1dac		       60		      rts
     67  1dad
     68  1dad
     69  1dad
     70  1dad
     71  1dad				   i2c_txack
     72  1dad
     73  1dad		       a9 00		      lda	#0
     74  1daf		       8d 80 02 	      sta	SWCHA
     75  1db2
     76  1db2		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  1db4		       8d 81 02 	      sta	SWACNT
     78  1db7
     79  1db7		       0a		      asl
     80  1db8		       8d 80 02 	      sta	SWCHA
     81  1dbb
     82  1dbb		       60		      rts
     83  1dbc
     84  1dbc
     85  1dbc
    428  1dbc
    429  1dbc				   HandleSaveKey SUBROUTINE
    430  1dbc
    431  1dbc		       2f 00	   SAVEKEY_ADR =	$2F00	;	     tentative address for Sokoban (64 bytes)
    432  1dbc
    433  1dbc							;------------------------------------------------------------------------------
      0  1dbc					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  1dbc		       00 03	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  1dbc					      SUBROUTINE
      3  1dbc				   ReadSaveKey
    435  1dbc
    436  1dbc							; assume no SaveKey found:
    437  1dbc		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    438  1dbe		       85 dc		      sta	highScoreSK+2	; 3
    439  1dc0
    440  1dc0							; setup SaveKey:
    441  1dc0		       a5 dd		      lda	startingLevel	; 3	     load start levelX*5 and level
    442  1dc2		       a6 b3		      ldx	level	; 3
    443  1dc4		       20 fd f5 	      jsr	SetupSaveKey	;6+853
    444  1dc7		       90 52		      bcc	NoSKfound	; 2/3
    445  1dc9
    446  1dc9							;    lda     #$34
    447  1dc9							;    sta     COLUBK
    448  1dc9
    449  1dc9							; start read
    450  1dc9		       20 a4 f5 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    451  1dcc		       20 51 f5 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    452  1dcf
    453  1dcf							; read high score:
    454  1dcf		       a2 02		      ldx	#3-1	; 2 = 1187
    455  1dd1				   .loopRead
    456  1dd1		       20 7a f5 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    457  1dd4		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    458  1dd6		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    459  1dd8		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    460  1dda				   .skipEmpty
    461  1dda		       95 da		      sta	highScoreSK,x	; 4
    462  1ddc		       ca		      dex		; 2
    463  1ddd		       10 f2		      bpl	.loopRead	; 2/3= 354
    464  1ddf
    465  1ddf							; stop read:
    466  1ddf		       4c 9d f5 	      jmp	i2c_stopread	;3+92=95    terminate read
    467  1de2
    468  1de2							;------------------------------------------------------------------------------
      0  1de2					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  1de2		       00 03	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  1de2					      SUBROUTINE
      3  1de2				   WriteSaveKey
    470  1de2
    471  1de2							; check if new high score:
    472  1de2		       a6 da		      ldx	highScoreSK	; 3
    473  1de4		       e8		      inx		; 2
    474  1de5		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    475  1de7
    476  1de7							; setup SaveKey:
    477  1de7		       a5 dd		      lda	startingLevel	; 3	     load start levelX*5 and level
    478  1de9		       a6 de		      ldx	startLevel	; 3
    479  1deb		       20 fd f5 	      jsr	SetupSaveKey	; 6+853
    480  1dee		       90 2b		      bcc	NoSKfound	; 2/3
    481  1df0
    482  1df0							;    lda     #$64
    483  1df0							;    sta     COLUBK
    484  1df0
    485  1df0							; write high score:
    486  1df0		       a2 02		      ldx	#3-1	; 2 = 841
    487  1df2				   .loopWrite
    488  1df2		       b5 da		      lda	highScoreSK,x	; 4
    489  1df4		       20 60 f5 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    490  1df7		       ca		      dex		; 2
    491  1df8		       10 f8		      bpl	.loopWrite	; 2/3= 837
    492  1dfa
    493  1dfa							; stop write:
    494  1dfa		       4c a4 f5 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    495  1dfd
    496  1dfd
    497  1dfd							;------------------------------------------------------------------------------
    498  1dfd
      0  1dfd					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  1dfd		       00 03	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  1dfd					      SUBROUTINE
      3  1dfd				   SetupSaveKey
    500  1dfd
    501  1dfd							; calculate slot;
    502  1dfd							; a = levelX
    503  1dfd							; x = level (0..4)
    504  1dfd		       85 df		      sta	offsetSK	; 3
    505  1dff		       8a		      txa		; 2
    506  1e00		       18		      clc		; 2
    507  1e01		       65 df		      adc	offsetSK	; 3
    508  1e03		       85 df		      sta	offsetSK	; 3
    509  1e05		       0a		      asl		; 2	     multiply by 3
    510  1e06		       65 df		      adc	offsetSK	; 3
    511  1e08		       69 00		      adc	#<SAVEKEY_ADR	; 2
    512  1e0a		       aa		      tax		; 2 = 22
    513  1e0b							; detect SaveKey:
    514  1e0b		       20 54 f5 	      jsr	i2c_startwrite	;6+280
    515  1e0e		       d0 0a		      bne	.exitSK	; 2/3
    516  1e10
    517  1e10							; setup address:
    518  1e10		       b8		      clv		; 2
    519  1e11		       a9 2f		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    520  1e13		       20 60 f5 	      jsr	i2c_txbyte	;6+264
    521  1e16		       8a		      txa		; 2	     x = lower byte offset
    522  1e17		       4c 60 f5 	      jmp	i2c_txbyte	;3+264      returns C==1
    523  1e1a
    524  1e1a				   .exitSK
    525  1e1a		       18		      clc
    526  1e1b				   NoSKfound
    527  1e1b		       60		      rts
    528  1e1b					      ENDIF
    529  1e1c
    530  1e1c
      0  1e1c					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  1e1c		       06 1c	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $61c , FREE= $1e4
      2  1e1c					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1e1c				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1e1c				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1e1c				  -	      ERR
      6  1e1c					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS1.asm LEVEL 2 PASS 3
      0  1e1c					      include	"BANK_LEVELS1.asm"
      1  1e1c							;    Sokoboo - a Sokoban implementation
      2  1e1c							;    using a generic tile-based display engine for the Atari 2600
      3  1e1c							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1e1c							;
      5  1e1c							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1e1c							;
      7  1e1c							;    Code related to the generic tile-based display engine was developed by
      8  1e1c							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1e1c							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1e1c							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1e1c							;
     12  1e1c							;    Code related to music and sound effects uses the TIATracker music player
     13  1e1c							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1e1c							;    directory for Apache licensing details.
     15  1e1c							;
     16  1e1c							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1e1c							;    See the copyright notices in the License directory for a list of level
     18  1e1c							;    contributors.
     19  1e1c							;
     20  1e1c							;    Except where otherwise indicated, this software is released under the
     21  1e1c							;    following licensing arrangement...
     22  1e1c							;
     23  1e1c							;    This program is free software: you can redistribute it and/or modify
     24  1e1c							;    it under the terms of the GNU General Public License as published by
     25  1e1c							;    the Free Software Foundation, either version 3 of the License, or
     26  1e1c							;    (at your option) any later version.
     27  1e1c							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1e1c
     29  1e1c							;    This program is distributed in the hope that it will be useful,
     30  1e1c							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1e1c							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1e1c							;    GNU General Public License for more details.
     33  1e1c
      0  1e1c					      NEWBANK	LEVELS1
      1  27b5 ????				      SEG	LEVELS1
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   LEVELS1    SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	LEVELS1
     35  2000
     36  2000
     37  2000							;  DEFL _000_SELECT, "12#|#@3-5$.#|10-|10-|12#"
     38  2000
     39  2000							; "SOKWHOLE" collection...
     40  2000
     41  2000
      0  2000					      DEFL	_001_L, "3#|#@#|#$#|#.#|3#"
      0  2000					      START_LEVEL	_001_L
      1  2000				   LEVEL_START SET	*
      2  2000		       00 04	   BANK_LEVEL__001_L =	_CURRENT_BANK
      3  2000				   LEVEL__001_L SUBROUTINE
      4  2000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2000
      2  2000		       33 23 7c 23*	      .byte.b	"3#|#@#|#$#|#.#|3#",0
      0  2012					      END_LEVEL	_001_L
      1  2012		       00 12	   LEVEL_SIZE__001_L =	* - LEVEL_START
      2  2012					      IF	LEVEL_SIZE__001_L > MAX_LEVEL_SIZE
      3  2012				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_L
      4  2012					      ENDIF
      0  2012					      DEFL	_001_R, "5#|#.$@#|5#"
      0  2012					      START_LEVEL	_001_R
      1  2012				   LEVEL_START SET	*
      2  2012		       00 04	   BANK_LEVEL__001_R =	_CURRENT_BANK
      3  2012				   LEVEL__001_R SUBROUTINE
      4  2012				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2012
      2  2012		       35 23 7c 23*	      .byte.b	"5#|#.$@#|5#",0
      0  201e					      END_LEVEL	_001_R
      1  201e		       00 0c	   LEVEL_SIZE__001_R =	* - LEVEL_START
      2  201e				  -	      IF	LEVEL_SIZE__001_R > MAX_LEVEL_SIZE
      3  201e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_R
      4  201e					      ENDIF
      0  201e					      DEFL	_002_L, "3#2-|#.3#|#*$-#|#2-@#|5#"
      0  201e					      START_LEVEL	_002_L
      1  201e				   LEVEL_START SET	*
      2  201e		       00 04	   BANK_LEVEL__002_L =	_CURRENT_BANK
      3  201e				   LEVEL__002_L SUBROUTINE
      4  201e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  201e
      2  201e		       33 23 32 2d*	      .byte.b	"3#2-|#.3#|#*$-#|#2-@#|5#",0
      0  2037					      END_LEVEL	_002_L
      1  2037		       00 19	   LEVEL_SIZE__002_L =	* - LEVEL_START
      2  2037					      IF	LEVEL_SIZE__002_L > MAX_LEVEL_SIZE
      3  2037				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_L
      4  2037					      ENDIF
      0  2037					      DEFL	_002_R, "2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#"
      0  2037					      START_LEVEL	_002_R
      1  2037				   LEVEL_START SET	*
      2  2037		       00 04	   BANK_LEVEL__002_R =	_CURRENT_BANK
      3  2037				   LEVEL__002_R SUBROUTINE
      4  2037				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2037
      2  2037		       32 2d 35 23*	      .byte.b	"2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#",0
      0  205f					      END_LEVEL	_002_R
      1  205f		       00 28	   LEVEL_SIZE__002_R =	* - LEVEL_START
      2  205f					      IF	LEVEL_SIZE__002_R > MAX_LEVEL_SIZE
      3  205f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_R
      4  205f					      ENDIF
      0  205f					      DEFL	_003_L, "4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-"
      0  205f					      START_LEVEL	_003_L
      1  205f				   LEVEL_START SET	*
      2  205f		       00 04	   BANK_LEVEL__003_L =	_CURRENT_BANK
      3  205f				   LEVEL__003_L SUBROUTINE
      4  205f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  205f
      2  205f		       34 2d 35 23*	      .byte.b	"4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-",0
      0  208b					      END_LEVEL	_003_L
      1  208b		       00 2c	   LEVEL_SIZE__003_L =	* - LEVEL_START
      2  208b					      IF	LEVEL_SIZE__003_L > MAX_LEVEL_SIZE
      3  208b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_L
      4  208b					      ENDIF
      0  208b					      DEFL	_003_R, "9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-"
      0  208b					      START_LEVEL	_003_R
      1  208b				   LEVEL_START SET	*
      2  208b		       00 04	   BANK_LEVEL__003_R =	_CURRENT_BANK
      3  208b				   LEVEL__003_R SUBROUTINE
      4  208b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  208b
      2  208b		       39 23 7c 23*	      .byte.b	"9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-",0
      0  20b5					      END_LEVEL	_003_R
      1  20b5		       00 2a	   LEVEL_SIZE__003_R =	* - LEVEL_START
      2  20b5				  -	      IF	LEVEL_SIZE__003_R > MAX_LEVEL_SIZE
      3  20b5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_R
      4  20b5					      ENDIF
      0  20b5					      DEFL	_004_L, "5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-"
      0  20b5					      START_LEVEL	_004_L
      1  20b5				   LEVEL_START SET	*
      2  20b5		       00 04	   BANK_LEVEL__004_L =	_CURRENT_BANK
      3  20b5				   LEVEL__004_L SUBROUTINE
      4  20b5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20b5
      2  20b5		       35 23 2d 7c*	      .byte.b	"5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-",0
      0  20d8					      END_LEVEL	_004_L
      1  20d8		       00 23	   LEVEL_SIZE__004_L =	* - LEVEL_START
      2  20d8				  -	      IF	LEVEL_SIZE__004_L > MAX_LEVEL_SIZE
      3  20d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_L
      4  20d8					      ENDIF
      0  20d8					      DEFL	_004_R, "-6#|-#4-#|2#-$*$#|#@$3.#|7#"
      0  20d8					      START_LEVEL	_004_R
      1  20d8				   LEVEL_START SET	*
      2  20d8		       00 04	   BANK_LEVEL__004_R =	_CURRENT_BANK
      3  20d8				   LEVEL__004_R SUBROUTINE
      4  20d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20d8
      2  20d8		       2d 36 23 7c*	      .byte.b	"-6#|-#4-#|2#-$*$#|#@$3.#|7#",0
      0  20f4					      END_LEVEL	_004_R
      1  20f4		       00 1c	   LEVEL_SIZE__004_R =	* - LEVEL_START
      2  20f4				  -	      IF	LEVEL_SIZE__004_R > MAX_LEVEL_SIZE
      3  20f4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_R
      4  20f4					      ENDIF
      0  20f4					      DEFL	_005_L, "3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-"
      0  20f4					      START_LEVEL	_005_L
      1  20f4				   LEVEL_START SET	*
      2  20f4		       00 04	   BANK_LEVEL__005_L =	_CURRENT_BANK
      3  20f4				   LEVEL__005_L SUBROUTINE
      4  20f4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20f4
      2  20f4		       33 2d 35 23*	      .byte.b	"3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-",0
      0  2126					      END_LEVEL	_005_L
      1  2126		       00 32	   LEVEL_SIZE__005_L =	* - LEVEL_START
      2  2126					      IF	LEVEL_SIZE__005_L > MAX_LEVEL_SIZE
      3  2126				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_L
      4  2126					      ENDIF
      0  2126					      DEFL	_005_R, "6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-"
      0  2126					      START_LEVEL	_005_R
      1  2126				   LEVEL_START SET	*
      2  2126		       00 04	   BANK_LEVEL__005_R =	_CURRENT_BANK
      3  2126				   LEVEL__005_R SUBROUTINE
      4  2126				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2126
      2  2126		       36 23 32 2d*	      .byte.b	"6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-",0
      0  2165					      END_LEVEL	_005_R
      1  2165		       00 3f	   LEVEL_SIZE__005_R =	* - LEVEL_START
      2  2165					      IF	LEVEL_SIZE__005_R > MAX_LEVEL_SIZE
      3  2165				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_R
      4  2165					      ENDIF
      0  2165					      DEFL	_006_L, "5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-"
      0  2165					      START_LEVEL	_006_L
      1  2165				   LEVEL_START SET	*
      2  2165		       00 04	   BANK_LEVEL__006_L =	_CURRENT_BANK
      3  2165				   LEVEL__006_L SUBROUTINE
      4  2165				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2165
      2  2165		       35 23 33 2d*	      .byte.b	"5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-",0
      0  21a0					      END_LEVEL	_006_L
      1  21a0		       00 3b	   LEVEL_SIZE__006_L =	* - LEVEL_START
      2  21a0				  -	      IF	LEVEL_SIZE__006_L > MAX_LEVEL_SIZE
      3  21a0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_L
      4  21a0					      ENDIF
      0  21a0					      DEFL	_006_R, "3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-"
      0  21a0					      START_LEVEL	_006_R
      1  21a0				   LEVEL_START SET	*
      2  21a0		       00 04	   BANK_LEVEL__006_R =	_CURRENT_BANK
      3  21a0				   LEVEL__006_R SUBROUTINE
      4  21a0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21a0
      2  21a0		       33 23 34 2d*	      .byte.b	"3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-",0
      0  21de					      END_LEVEL	_006_R
      1  21de		       00 3e	   LEVEL_SIZE__006_R =	* - LEVEL_START
      2  21de				  -	      IF	LEVEL_SIZE__006_R > MAX_LEVEL_SIZE
      3  21de				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_R
      4  21de					      ENDIF
      0  21de					      DEFL	_007_L, "6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#"
      0  21de					      START_LEVEL	_007_L
      1  21de				   LEVEL_START SET	*
      2  21de		       00 04	   BANK_LEVEL__007_L =	_CURRENT_BANK
      3  21de				   LEVEL__007_L SUBROUTINE
      4  21de				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21de
      2  21de		       36 23 2d 7c*	      .byte.b	"6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#",0
      0  220b					      END_LEVEL	_007_L
      1  220b		       00 2d	   LEVEL_SIZE__007_L =	* - LEVEL_START
      2  220b				  -	      IF	LEVEL_SIZE__007_L > MAX_LEVEL_SIZE
      3  220b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_L
      4  220b					      ENDIF
      0  220b					      DEFL	_007_R, "4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#"
      0  220b					      START_LEVEL	_007_R
      1  220b				   LEVEL_START SET	*
      2  220b		       00 04	   BANK_LEVEL__007_R =	_CURRENT_BANK
      3  220b				   LEVEL__007_R SUBROUTINE
      4  220b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  220b
      2  220b		       34 23 34 2d*	      .byte.b	"4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#",0
      0  223e					      END_LEVEL	_007_R
      1  223e		       00 33	   LEVEL_SIZE__007_R =	* - LEVEL_START
      2  223e				  -	      IF	LEVEL_SIZE__007_R > MAX_LEVEL_SIZE
      3  223e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_R
      4  223e					      ENDIF
      0  223e					      DEFL	_008_L, "2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-"
      0  223e					      START_LEVEL	_008_L
      1  223e				   LEVEL_START SET	*
      2  223e		       00 04	   BANK_LEVEL__008_L =	_CURRENT_BANK
      3  223e				   LEVEL__008_L SUBROUTINE
      4  223e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  223e
      2  223e		       32 2d 35 23*	      .byte.b	"2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-",0
      0  2274					      END_LEVEL	_008_L
      1  2274		       00 36	   LEVEL_SIZE__008_L =	* - LEVEL_START
      2  2274				  -	      IF	LEVEL_SIZE__008_L > MAX_LEVEL_SIZE
      3  2274				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_L
      4  2274					      ENDIF
      0  2274					      DEFL	_008_R, "-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#"
      0  2274					      START_LEVEL	_008_R
      1  2274				   LEVEL_START SET	*
      2  2274		       00 04	   BANK_LEVEL__008_R =	_CURRENT_BANK
      3  2274				   LEVEL__008_R SUBROUTINE
      4  2274				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2274
      2  2274		       2d 35 23 33*	      .byte.b	"-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#",0
      0  22a5					      END_LEVEL	_008_R
      1  22a5		       00 31	   LEVEL_SIZE__008_R =	* - LEVEL_START
      2  22a5				  -	      IF	LEVEL_SIZE__008_R > MAX_LEVEL_SIZE
      3  22a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_R
      4  22a5					      ENDIF
      0  22a5					      DEFL	_009_L, "-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#"
      0  22a5					      START_LEVEL	_009_L
      1  22a5				   LEVEL_START SET	*
      2  22a5		       00 04	   BANK_LEVEL__009_L =	_CURRENT_BANK
      3  22a5				   LEVEL__009_L SUBROUTINE
      4  22a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22a5
      2  22a5		       2d 35 23 2d*	      .byte.b	"-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#",0
      0  22d7					      END_LEVEL	_009_L
      1  22d7		       00 32	   LEVEL_SIZE__009_L =	* - LEVEL_START
      2  22d7				  -	      IF	LEVEL_SIZE__009_L > MAX_LEVEL_SIZE
      3  22d7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_L
      4  22d7					      ENDIF
      0  22d7					      DEFL	_009_R, "-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#"
      0  22d7					      START_LEVEL	_009_R
      1  22d7				   LEVEL_START SET	*
      2  22d7		       00 04	   BANK_LEVEL__009_R =	_CURRENT_BANK
      3  22d7				   LEVEL__009_R SUBROUTINE
      4  22d7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22d7
      2  22d7		       2d 33 23 33*	      .byte.b	"-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#",0
      0  2307					      END_LEVEL	_009_R
      1  2307		       00 30	   LEVEL_SIZE__009_R =	* - LEVEL_START
      2  2307				  -	      IF	LEVEL_SIZE__009_R > MAX_LEVEL_SIZE
      3  2307				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_R
      4  2307					      ENDIF
      0  2307					      DEFL	_010_L, "2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-"
      0  2307					      START_LEVEL	_010_L
      1  2307				   LEVEL_START SET	*
      2  2307		       00 04	   BANK_LEVEL__010_L =	_CURRENT_BANK
      3  2307				   LEVEL__010_L SUBROUTINE
      4  2307				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2307
      2  2307		       32 2d 33 23*	      .byte.b	"2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-",0
      0  2341					      END_LEVEL	_010_L
      1  2341		       00 3a	   LEVEL_SIZE__010_L =	* - LEVEL_START
      2  2341				  -	      IF	LEVEL_SIZE__010_L > MAX_LEVEL_SIZE
      3  2341				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_L
      4  2341					      ENDIF
      0  2341					      DEFL	_010_R, "4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-"
      0  2341					      START_LEVEL	_010_R
      1  2341				   LEVEL_START SET	*
      2  2341		       00 04	   BANK_LEVEL__010_R =	_CURRENT_BANK
      3  2341				   LEVEL__010_R SUBROUTINE
      4  2341				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2341
      2  2341		       34 23 32 2d*	      .byte.b	"4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-",0
      0  2374					      END_LEVEL	_010_R
      1  2374		       00 33	   LEVEL_SIZE__010_R =	* - LEVEL_START
      2  2374				  -	      IF	LEVEL_SIZE__010_R > MAX_LEVEL_SIZE
      3  2374				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_R
      4  2374					      ENDIF
      0  2374					      DEFL	_011_L, "-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-"
      0  2374					      START_LEVEL	_011_L
      1  2374				   LEVEL_START SET	*
      2  2374		       00 04	   BANK_LEVEL__011_L =	_CURRENT_BANK
      3  2374				   LEVEL__011_L SUBROUTINE
      4  2374				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2374
      2  2374		       2d 34 23 32*	      .byte.b	"-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-",0
      0  23a7					      END_LEVEL	_011_L
      1  23a7		       00 33	   LEVEL_SIZE__011_L =	* - LEVEL_START
      2  23a7				  -	      IF	LEVEL_SIZE__011_L > MAX_LEVEL_SIZE
      3  23a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_L
      4  23a7					      ENDIF
      0  23a7					      DEFL	_011_R, "2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#"
      0  23a7					      START_LEVEL	_011_R
      1  23a7				   LEVEL_START SET	*
      2  23a7		       00 04	   BANK_LEVEL__011_R =	_CURRENT_BANK
      3  23a7				   LEVEL__011_R SUBROUTINE
      4  23a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23a7
      2  23a7		       32 2d 33 23*	      .byte.b	"2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#",0
      0  23e1					      END_LEVEL	_011_R
      1  23e1		       00 3a	   LEVEL_SIZE__011_R =	* - LEVEL_START
      2  23e1				  -	      IF	LEVEL_SIZE__011_R > MAX_LEVEL_SIZE
      3  23e1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_R
      4  23e1					      ENDIF
      0  23e1					      DEFL	_012_L, "7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#"
      0  23e1					      START_LEVEL	_012_L
      1  23e1				   LEVEL_START SET	*
      2  23e1		       00 04	   BANK_LEVEL__012_L =	_CURRENT_BANK
      3  23e1				   LEVEL__012_L SUBROUTINE
      4  23e1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23e1
      2  23e1		       37 23 33 2d*	      .byte.b	"7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#",0
      0  2411					      END_LEVEL	_012_L
      1  2411		       00 30	   LEVEL_SIZE__012_L =	* - LEVEL_START
      2  2411				  -	      IF	LEVEL_SIZE__012_L > MAX_LEVEL_SIZE
      3  2411				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_L
      4  2411					      ENDIF
      0  2411					      DEFL	_012_R, "-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-"
      0  2411					      START_LEVEL	_012_R
      1  2411				   LEVEL_START SET	*
      2  2411		       00 04	   BANK_LEVEL__012_R =	_CURRENT_BANK
      3  2411				   LEVEL__012_R SUBROUTINE
      4  2411				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2411
      2  2411		       2d 36 23 32*	      .byte.b	"-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-",0
      0  244d					      END_LEVEL	_012_R
      1  244d		       00 3c	   LEVEL_SIZE__012_R =	* - LEVEL_START
      2  244d				  -	      IF	LEVEL_SIZE__012_R > MAX_LEVEL_SIZE
      3  244d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_R
      4  244d					      ENDIF
      0  244d					      DEFL	_013_L, "2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-"
      0  244d					      START_LEVEL	_013_L
      1  244d				   LEVEL_START SET	*
      2  244d		       00 04	   BANK_LEVEL__013_L =	_CURRENT_BANK
      3  244d				   LEVEL__013_L SUBROUTINE
      4  244d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  244d
      2  244d		       32 2d 35 23*	      .byte.b	"2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-",0
      0  248c					      END_LEVEL	_013_L
      1  248c		       00 3f	   LEVEL_SIZE__013_L =	* - LEVEL_START
      2  248c				  -	      IF	LEVEL_SIZE__013_L > MAX_LEVEL_SIZE
      3  248c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_L
      4  248c					      ENDIF
      0  248c					      DEFL	_013_R, "-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-"
      0  248c					      START_LEVEL	_013_R
      1  248c				   LEVEL_START SET	*
      2  248c		       00 04	   BANK_LEVEL__013_R =	_CURRENT_BANK
      3  248c				   LEVEL__013_R SUBROUTINE
      4  248c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  248c
      2  248c		       2d 35 23 32*	      .byte.b	"-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-",0
      0  24bf					      END_LEVEL	_013_R
      1  24bf		       00 33	   LEVEL_SIZE__013_R =	* - LEVEL_START
      2  24bf				  -	      IF	LEVEL_SIZE__013_R > MAX_LEVEL_SIZE
      3  24bf				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_R
      4  24bf					      ENDIF
      0  24bf					      DEFL	_014_L, "6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#"
      0  24bf					      START_LEVEL	_014_L
      1  24bf				   LEVEL_START SET	*
      2  24bf		       00 04	   BANK_LEVEL__014_L =	_CURRENT_BANK
      3  24bf				   LEVEL__014_L SUBROUTINE
      4  24bf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24bf
      2  24bf		       36 23 34 2d*	      .byte.b	"6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#",0
      0  2502					      END_LEVEL	_014_L
      1  2502		       00 43	   LEVEL_SIZE__014_L =	* - LEVEL_START
      2  2502					      IF	LEVEL_SIZE__014_L > MAX_LEVEL_SIZE
      3  2502				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_L
      4  2502					      ENDIF
      0  2502					      DEFL	_014_R, "6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-"
      0  2502					      START_LEVEL	_014_R
      1  2502				   LEVEL_START SET	*
      2  2502		       00 04	   BANK_LEVEL__014_R =	_CURRENT_BANK
      3  2502				   LEVEL__014_R SUBROUTINE
      4  2502				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2502
      2  2502		       36 23 33 2d*	      .byte.b	"6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-",0
      0  2545					      END_LEVEL	_014_R
      1  2545		       00 43	   LEVEL_SIZE__014_R =	* - LEVEL_START
      2  2545				  -	      IF	LEVEL_SIZE__014_R > MAX_LEVEL_SIZE
      3  2545				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_R
      4  2545					      ENDIF
      0  2545					      DEFL	_015_L, "2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#"
      0  2545					      START_LEVEL	_015_L
      1  2545				   LEVEL_START SET	*
      2  2545		       00 04	   BANK_LEVEL__015_L =	_CURRENT_BANK
      3  2545				   LEVEL__015_L SUBROUTINE
      4  2545				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2545
      2  2545		       32 2d 35 23*	      .byte.b	"2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#",0
      0  257a					      END_LEVEL	_015_L
      1  257a		       00 35	   LEVEL_SIZE__015_L =	* - LEVEL_START
      2  257a				  -	      IF	LEVEL_SIZE__015_L > MAX_LEVEL_SIZE
      3  257a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_L
      4  257a					      ENDIF
      0  257a					      DEFL	_015_R, "3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-"
      0  257a					      START_LEVEL	_015_R
      1  257a				   LEVEL_START SET	*
      2  257a		       00 04	   BANK_LEVEL__015_R =	_CURRENT_BANK
      3  257a				   LEVEL__015_R SUBROUTINE
      4  257a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  257a
      2  257a		       33 2d 35 23*	      .byte.b	"3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-",0
      0  25bf					      END_LEVEL	_015_R
      1  25bf		       00 45	   LEVEL_SIZE__015_R =	* - LEVEL_START
      2  25bf					      IF	LEVEL_SIZE__015_R > MAX_LEVEL_SIZE
      3  25bf				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_R
      4  25bf					      ENDIF
      0  25bf					      DEFL	_016_L, "4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-"
      0  25bf					      START_LEVEL	_016_L
      1  25bf				   LEVEL_START SET	*
      2  25bf		       00 04	   BANK_LEVEL__016_L =	_CURRENT_BANK
      3  25bf				   LEVEL__016_L SUBROUTINE
      4  25bf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25bf
      2  25bf		       34 2d 33 23*	      .byte.b	"4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-",0
      0  25f6					      END_LEVEL	_016_L
      1  25f6		       00 37	   LEVEL_SIZE__016_L =	* - LEVEL_START
      2  25f6				  -	      IF	LEVEL_SIZE__016_L > MAX_LEVEL_SIZE
      3  25f6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_L
      4  25f6					      ENDIF
      0  25f6					      DEFL	_016_R, "5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-"
      0  25f6					      START_LEVEL	_016_R
      1  25f6				   LEVEL_START SET	*
      2  25f6		       00 04	   BANK_LEVEL__016_R =	_CURRENT_BANK
      3  25f6				   LEVEL__016_R SUBROUTINE
      4  25f6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25f6
      2  25f6		       35 23 2d 7c*	      .byte.b	"5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-",0
      0  2629					      END_LEVEL	_016_R
      1  2629		       00 33	   LEVEL_SIZE__016_R =	* - LEVEL_START
      2  2629				  -	      IF	LEVEL_SIZE__016_R > MAX_LEVEL_SIZE
      3  2629				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_R
      4  2629					      ENDIF
      0  2629					      DEFL	_017_L, "5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-"
      0  2629					      START_LEVEL	_017_L
      1  2629				   LEVEL_START SET	*
      2  2629		       00 04	   BANK_LEVEL__017_L =	_CURRENT_BANK
      3  2629				   LEVEL__017_L SUBROUTINE
      4  2629				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2629
      2  2629		       35 23 34 2d*	      .byte.b	"5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-",0
      0  2673					      END_LEVEL	_017_L
      1  2673		       00 4a	   LEVEL_SIZE__017_L =	* - LEVEL_START
      2  2673					      IF	LEVEL_SIZE__017_L > MAX_LEVEL_SIZE
      3  2673				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_L
      4  2673					      ENDIF
      0  2673					      DEFL	_017_R, "3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-"
      0  2673					      START_LEVEL	_017_R
      1  2673				   LEVEL_START SET	*
      2  2673		       00 04	   BANK_LEVEL__017_R =	_CURRENT_BANK
      3  2673				   LEVEL__017_R SUBROUTINE
      4  2673				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2673
      2  2673		       33 2d 34 23*	      .byte.b	"3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-",0
      0  26b6					      END_LEVEL	_017_R
      1  26b6		       00 43	   LEVEL_SIZE__017_R =	* - LEVEL_START
      2  26b6				  -	      IF	LEVEL_SIZE__017_R > MAX_LEVEL_SIZE
      3  26b6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_R
      4  26b6					      ENDIF
      0  26b6					      DEFL	_018_L, "6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#"
      0  26b6					      START_LEVEL	_018_L
      1  26b6				   LEVEL_START SET	*
      2  26b6		       00 04	   BANK_LEVEL__018_L =	_CURRENT_BANK
      3  26b6				   LEVEL__018_L SUBROUTINE
      4  26b6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26b6
      2  26b6		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#",0
      0  26ea					      END_LEVEL	_018_L
      1  26ea		       00 34	   LEVEL_SIZE__018_L =	* - LEVEL_START
      2  26ea				  -	      IF	LEVEL_SIZE__018_L > MAX_LEVEL_SIZE
      3  26ea				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_L
      4  26ea					      ENDIF
      0  26ea					      DEFL	_018_R, "-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#"
      0  26ea					      START_LEVEL	_018_R
      1  26ea				   LEVEL_START SET	*
      2  26ea		       00 04	   BANK_LEVEL__018_R =	_CURRENT_BANK
      3  26ea				   LEVEL__018_R SUBROUTINE
      4  26ea				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26ea
      2  26ea		       2d 34 23 33*	      .byte.b	"-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#",0
      0  2726					      END_LEVEL	_018_R
      1  2726		       00 3c	   LEVEL_SIZE__018_R =	* - LEVEL_START
      2  2726				  -	      IF	LEVEL_SIZE__018_R > MAX_LEVEL_SIZE
      3  2726				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_R
      4  2726					      ENDIF
      0  2726					      DEFL	_019_L, "4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#"
      0  2726					      START_LEVEL	_019_L
      1  2726				   LEVEL_START SET	*
      2  2726		       00 04	   BANK_LEVEL__019_L =	_CURRENT_BANK
      3  2726				   LEVEL__019_L SUBROUTINE
      4  2726				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2726
      2  2726		       34 2d 35 23*	      .byte.b	"4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#",0
      0  2761					      END_LEVEL	_019_L
      1  2761		       00 3b	   LEVEL_SIZE__019_L =	* - LEVEL_START
      2  2761				  -	      IF	LEVEL_SIZE__019_L > MAX_LEVEL_SIZE
      3  2761				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_L
      4  2761					      ENDIF
      0  2761					      DEFL	_019_R, "2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#"
      0  2761					      START_LEVEL	_019_R
      1  2761				   LEVEL_START SET	*
      2  2761		       00 04	   BANK_LEVEL__019_R =	_CURRENT_BANK
      3  2761				   LEVEL__019_R SUBROUTINE
      4  2761				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2761
      2  2761		       32 2d 37 23*	      .byte.b	"2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#",0
      0  27b1					      END_LEVEL	_019_R
      1  27b1		       00 50	   LEVEL_SIZE__019_R =	* - LEVEL_START
      2  27b1					      IF	LEVEL_SIZE__019_R > MAX_LEVEL_SIZE
      3  27b1				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_R
      4  27b1					      ENDIF
     80  27b1
     81  27b1							;-----------------------------------------------------------
     82  27b1							; Stella 3E autodetect signature, can live anywhere
     83  27b1		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
     84  27b5							;-----------------------------------------------------------
     85  27b5
      0  27b5					      CHECK_BANK_SIZE	"LEVELS1"
      1  27b5		       07 b5	   .TEMP      =	* - BANK_START
 LEVELS1 (2K) SIZE =  $7b5 , FREE= $4b
      2  27b5					      ECHO	"LEVELS1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27b5				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  27b5				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27b5				  -	      ERR
      6  27b5					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS2.asm LEVEL 2 PASS 3
      0  27b5					      include	"BANK_LEVELS2.asm"
      1  27b5							;    Sokoboo - a Sokoban implementation
      2  27b5							;    using a generic tile-based display engine for the Atari 2600
      3  27b5							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  27b5							;
      5  27b5							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  27b5							;
      7  27b5							;    Code related to the generic tile-based display engine was developed by
      8  27b5							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  27b5							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  27b5							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  27b5							;
     12  27b5							;    Code related to music and sound effects uses the TIATracker music player
     13  27b5							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  27b5							;    directory for Apache licensing details.
     15  27b5							;
     16  27b5							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  27b5							;    See the copyright notices in the License directory for a list of level
     18  27b5							;    contributors.
     19  27b5							;
     20  27b5							;    Except where otherwise indicated, this software is released under the
     21  27b5							;    following licensing arrangement...
     22  27b5							;
     23  27b5							;    This program is free software: you can redistribute it and/or modify
     24  27b5							;    it under the terms of the GNU General Public License as published by
     25  27b5							;    the Free Software Foundation, either version 3 of the License, or
     26  27b5							;    (at your option) any later version.
     27  27b5							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  27b5
     29  27b5							;    This program is distributed in the hope that it will be useful,
     30  27b5							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  27b5							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  27b5							;    GNU General Public License for more details.
     33  27b5
      0  27b5					      NEWBANK	LEVELS2
      1  2fbe ????				      SEG	LEVELS2
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   LEVELS2    SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	LEVELS2
     35  2800
      0  2800					      DEFL	_020_L, "-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-"
      0  2800					      START_LEVEL	_020_L
      1  2800				   LEVEL_START SET	*
      2  2800		       00 05	   BANK_LEVEL__020_L =	_CURRENT_BANK
      3  2800				   LEVEL__020_L SUBROUTINE
      4  2800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2800
      2  2800		       2d 36 23 2d*	      .byte.b	"-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-",0
      0  283f					      END_LEVEL	_020_L
      1  283f		       00 3f	   LEVEL_SIZE__020_L =	* - LEVEL_START
      2  283f				  -	      IF	LEVEL_SIZE__020_L > MAX_LEVEL_SIZE
      3  283f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_L
      4  283f					      ENDIF
      0  283f					      DEFL	_020_R, "5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-"
      0  283f					      START_LEVEL	_020_R
      1  283f				   LEVEL_START SET	*
      2  283f		       00 05	   BANK_LEVEL__020_R =	_CURRENT_BANK
      3  283f				   LEVEL__020_R SUBROUTINE
      4  283f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  283f
      2  283f		       35 2d 34 23*	      .byte.b	"5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-",0
      0  287f					      END_LEVEL	_020_R
      1  287f		       00 40	   LEVEL_SIZE__020_R =	* - LEVEL_START
      2  287f				  -	      IF	LEVEL_SIZE__020_R > MAX_LEVEL_SIZE
      3  287f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_R
      4  287f					      ENDIF
      0  287f					      DEFL	_021_L, "4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-"
      0  287f					      START_LEVEL	_021_L
      1  287f				   LEVEL_START SET	*
      2  287f		       00 05	   BANK_LEVEL__021_L =	_CURRENT_BANK
      3  287f				   LEVEL__021_L SUBROUTINE
      4  287f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  287f
      2  287f		       34 2d 34 23*	      .byte.b	"4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-",0
      0  28d5					      END_LEVEL	_021_L
      1  28d5		       00 56	   LEVEL_SIZE__021_L =	* - LEVEL_START
      2  28d5					      IF	LEVEL_SIZE__021_L > MAX_LEVEL_SIZE
      3  28d5				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_L
      4  28d5					      ENDIF
      0  28d5					      DEFL	_021_R, "-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-"
      0  28d5					      START_LEVEL	_021_R
      1  28d5				   LEVEL_START SET	*
      2  28d5		       00 05	   BANK_LEVEL__021_R =	_CURRENT_BANK
      3  28d5				   LEVEL__021_R SUBROUTINE
      4  28d5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  28d5
      2  28d5		       2d 34 23 33*	      .byte.b	"-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-",0
      0  2909					      END_LEVEL	_021_R
      1  2909		       00 34	   LEVEL_SIZE__021_R =	* - LEVEL_START
      2  2909				  -	      IF	LEVEL_SIZE__021_R > MAX_LEVEL_SIZE
      3  2909				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_R
      4  2909					      ENDIF
      0  2909					      DEFL	_022_L, "3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-"
      0  2909					      START_LEVEL	_022_L
      1  2909				   LEVEL_START SET	*
      2  2909		       00 05	   BANK_LEVEL__022_L =	_CURRENT_BANK
      3  2909				   LEVEL__022_L SUBROUTINE
      4  2909				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2909
      2  2909		       33 2d 33 23*	      .byte.b	"3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-",0
      0  294f					      END_LEVEL	_022_L
      1  294f		       00 46	   LEVEL_SIZE__022_L =	* - LEVEL_START
      2  294f				  -	      IF	LEVEL_SIZE__022_L > MAX_LEVEL_SIZE
      3  294f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_L
      4  294f					      ENDIF
      0  294f					      DEFL	_022_R, "-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-"
      0  294f					      START_LEVEL	_022_R
      1  294f				   LEVEL_START SET	*
      2  294f		       00 05	   BANK_LEVEL__022_R =	_CURRENT_BANK
      3  294f				   LEVEL__022_R SUBROUTINE
      4  294f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  294f
      2  294f		       2d 33 23 34*	      .byte.b	"-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-",0
      0  298b					      END_LEVEL	_022_R
      1  298b		       00 3c	   LEVEL_SIZE__022_R =	* - LEVEL_START
      2  298b				  -	      IF	LEVEL_SIZE__022_R > MAX_LEVEL_SIZE
      3  298b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_R
      4  298b					      ENDIF
      0  298b					      DEFL	_023_L, "6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#"
      0  298b					      START_LEVEL	_023_L
      1  298b				   LEVEL_START SET	*
      2  298b		       00 05	   BANK_LEVEL__023_L =	_CURRENT_BANK
      3  298b				   LEVEL__023_L SUBROUTINE
      4  298b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  298b
      2  298b		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#",0
      0  29cc					      END_LEVEL	_023_L
      1  29cc		       00 41	   LEVEL_SIZE__023_L =	* - LEVEL_START
      2  29cc				  -	      IF	LEVEL_SIZE__023_L > MAX_LEVEL_SIZE
      3  29cc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_L
      4  29cc					      ENDIF
      0  29cc					      DEFL	_023_R, "7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-"
      0  29cc					      START_LEVEL	_023_R
      1  29cc				   LEVEL_START SET	*
      2  29cc		       00 05	   BANK_LEVEL__023_R =	_CURRENT_BANK
      3  29cc				   LEVEL__023_R SUBROUTINE
      4  29cc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  29cc
      2  29cc		       37 23 32 2d*	      .byte.b	"7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-",0
      0  2a0e					      END_LEVEL	_023_R
      1  2a0e		       00 42	   LEVEL_SIZE__023_R =	* - LEVEL_START
      2  2a0e				  -	      IF	LEVEL_SIZE__023_R > MAX_LEVEL_SIZE
      3  2a0e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_R
      4  2a0e					      ENDIF
      0  2a0e					      DEFL	_024_L, "-9#|-#7-#|-#-#2-$#-#|-#-#.*.#-#|2#2-.*-#-#|#3-.2$2-#|#-$2#2-3#|2#@2#2-#2-|-7#2-"
      0  2a0e					      START_LEVEL	_024_L
      1  2a0e				   LEVEL_START SET	*
      2  2a0e		       00 05	   BANK_LEVEL__024_L =	_CURRENT_BANK
      3  2a0e				   LEVEL__024_L SUBROUTINE
      4  2a0e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a0e
      2  2a0e		       2d 39 23 7c*	      .byte.b	"-9#|-#7-#|-#-#2-$#-#|-#-#.*.#-#|2#2-.*-#-#|#3-.2$2-#|#-$2#2-3#|2#@2#2-#2-|-7#2-",0
      0  2a5e					      END_LEVEL	_024_L
      1  2a5e		       00 50	   LEVEL_SIZE__024_L =	* - LEVEL_START
      2  2a5e				  -	      IF	LEVEL_SIZE__024_L > MAX_LEVEL_SIZE
      3  2a5e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__024_L
      4  2a5e					      ENDIF
      0  2a5e					      DEFL	_024_R, "-8#|2#6-#|#-$-*-#-#|#-3.*$-#|#2-*.*.2#|#2-#$-$-#|4#-$2-#|3-2#@3#|4-3#2-"
      0  2a5e					      START_LEVEL	_024_R
      1  2a5e				   LEVEL_START SET	*
      2  2a5e		       00 05	   BANK_LEVEL__024_R =	_CURRENT_BANK
      3  2a5e				   LEVEL__024_R SUBROUTINE
      4  2a5e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a5e
      2  2a5e		       2d 38 23 7c*	      .byte.b	"-8#|2#6-#|#-$-*-#-#|#-3.*$-#|#2-*.*.2#|#2-#$-$-#|4#-$2-#|3-2#@3#|4-3#2-",0
      0  2aa6					      END_LEVEL	_024_R
      1  2aa6		       00 48	   LEVEL_SIZE__024_R =	* - LEVEL_START
      2  2aa6				  -	      IF	LEVEL_SIZE__024_R > MAX_LEVEL_SIZE
      3  2aa6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__024_R
      4  2aa6					      ENDIF
      0  2aa6					      DEFL	_025_L, "4-4#2-|5#@-2#-|#4-2$-2#|#-3#2-$-#|#-3.2*.-#|#-2$*$2.2#|2#6-#-|-8#-"
      0  2aa6					      START_LEVEL	_025_L
      1  2aa6				   LEVEL_START SET	*
      2  2aa6		       00 05	   BANK_LEVEL__025_L =	_CURRENT_BANK
      3  2aa6				   LEVEL__025_L SUBROUTINE
      4  2aa6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2aa6
      2  2aa6		       34 2d 34 23*	      .byte.b	"4-4#2-|5#@-2#-|#4-2$-2#|#-3#2-$-#|#-3.2*.-#|#-2$*$2.2#|2#6-#-|-8#-",0
      0  2ae9					      END_LEVEL	_025_L
      1  2ae9		       00 43	   LEVEL_SIZE__025_L =	* - LEVEL_START
      2  2ae9				  -	      IF	LEVEL_SIZE__025_L > MAX_LEVEL_SIZE
      3  2ae9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__025_L
      4  2ae9					      ENDIF
      0  2ae9					      DEFL	_025_R, "-6#-|2#.-$-#-|#.*$*-2#|#.*2.$-#|2#3-#@#|-#-$-$-#|-3#2-2#|3-4#-"
      0  2ae9					      START_LEVEL	_025_R
      1  2ae9				   LEVEL_START SET	*
      2  2ae9		       00 05	   BANK_LEVEL__025_R =	_CURRENT_BANK
      3  2ae9				   LEVEL__025_R SUBROUTINE
      4  2ae9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ae9
      2  2ae9		       2d 36 23 2d*	      .byte.b	"-6#-|2#.-$-#-|#.*$*-2#|#.*2.$-#|2#3-#@#|-#-$-$-#|-3#2-2#|3-4#-",0
      0  2b28					      END_LEVEL	_025_R
      1  2b28		       00 3f	   LEVEL_SIZE__025_R =	* - LEVEL_START
      2  2b28				  -	      IF	LEVEL_SIZE__025_R > MAX_LEVEL_SIZE
      3  2b28				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__025_R
      4  2b28					      ENDIF
      0  2b28					      DEFL	_026_L, "-6#2-|2#-3.3#|#-$-2*.-#|#2-$-2*-#|#-$-$.$-#|#2-#-@2-#|9#"
      0  2b28					      START_LEVEL	_026_L
      1  2b28				   LEVEL_START SET	*
      2  2b28		       00 05	   BANK_LEVEL__026_L =	_CURRENT_BANK
      3  2b28				   LEVEL__026_L SUBROUTINE
      4  2b28				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b28
      2  2b28		       2d 36 23 32*	      .byte.b	"-6#2-|2#-3.3#|#-$-2*.-#|#2-$-2*-#|#-$-$.$-#|#2-#-@2-#|9#",0
      0  2b61					      END_LEVEL	_026_L
      1  2b61		       00 39	   LEVEL_SIZE__026_L =	* - LEVEL_START
      2  2b61				  -	      IF	LEVEL_SIZE__026_L > MAX_LEVEL_SIZE
      3  2b61				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__026_L
      4  2b61					      ENDIF
      0  2b61					      DEFL	_026_R, "5-4#|4-2#2-#|-4#3-#|2#2.-$2-#|#.3*$-2#|2#.$-$-#-|-3#-@2#-|3-4#2-"
      0  2b61					      START_LEVEL	_026_R
      1  2b61				   LEVEL_START SET	*
      2  2b61		       00 05	   BANK_LEVEL__026_R =	_CURRENT_BANK
      3  2b61				   LEVEL__026_R SUBROUTINE
      4  2b61				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b61
      2  2b61		       35 2d 34 23*	      .byte.b	"5-4#|4-2#2-#|-4#3-#|2#2.-$2-#|#.3*$-2#|2#.$-$-#-|-3#-@2#-|3-4#2-",0
      0  2ba2					      END_LEVEL	_026_R
      1  2ba2		       00 41	   LEVEL_SIZE__026_R =	* - LEVEL_START
      2  2ba2				  -	      IF	LEVEL_SIZE__026_R > MAX_LEVEL_SIZE
      3  2ba2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__026_R
      4  2ba2					      ENDIF
      0  2ba2					      DEFL	_027_L, "8#-|#3-@2-#-|#-*4$2#|2#*.#3-#|-#3.$2-#|-3#*.$-#|3-#.4#|3-3#3-"
      0  2ba2					      START_LEVEL	_027_L
      1  2ba2				   LEVEL_START SET	*
      2  2ba2		       00 05	   BANK_LEVEL__027_L =	_CURRENT_BANK
      3  2ba2				   LEVEL__027_L SUBROUTINE
      4  2ba2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ba2
      2  2ba2		       38 23 2d 7c*	      .byte.b	"8#-|#3-@2-#-|#-*4$2#|2#*.#3-#|-#3.$2-#|-3#*.$-#|3-#.4#|3-3#3-",0
      0  2be0					      END_LEVEL	_027_L
      1  2be0		       00 3e	   LEVEL_SIZE__027_L =	* - LEVEL_START
      2  2be0				  -	      IF	LEVEL_SIZE__027_L > MAX_LEVEL_SIZE
      3  2be0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__027_L
      4  2be0					      ENDIF
      0  2be0					      DEFL	_027_R, "7#2-|#5-2#-|#$2*-$-#-|#-*2.2-2#|#2.*3$-#|3#.#3-#|2-4#-@#|5-4#"
      0  2be0					      START_LEVEL	_027_R
      1  2be0				   LEVEL_START SET	*
      2  2be0		       00 05	   BANK_LEVEL__027_R =	_CURRENT_BANK
      3  2be0				   LEVEL__027_R SUBROUTINE
      4  2be0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2be0
      2  2be0		       37 23 32 2d*	      .byte.b	"7#2-|#5-2#-|#$2*-$-#-|#-*2.2-2#|#2.*3$-#|3#.#3-#|2-4#-@#|5-4#",0
      0  2c1e					      END_LEVEL	_027_R
      1  2c1e		       00 3e	   LEVEL_SIZE__027_R =	* - LEVEL_START
      2  2c1e				  -	      IF	LEVEL_SIZE__027_R > MAX_LEVEL_SIZE
      3  2c1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__027_R
      4  2c1e					      ENDIF
      0  2c1e					      DEFL	_028_L, "3-3#4-|4#.#4-|#-$-.#4-|#@#.*5#|#-$.*.3-#|#-2$-*$#-#|#2-#-.$2-#|4#4-2#|3-6#-"
      0  2c1e					      START_LEVEL	_028_L
      1  2c1e				   LEVEL_START SET	*
      2  2c1e		       00 05	   BANK_LEVEL__028_L =	_CURRENT_BANK
      3  2c1e				   LEVEL__028_L SUBROUTINE
      4  2c1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c1e
      2  2c1e		       33 2d 33 23*	      .byte.b	"3-3#4-|4#.#4-|#-$-.#4-|#@#.*5#|#-$.*.3-#|#-2$-*$#-#|#2-#-.$2-#|4#4-2#|3-6#-",0
      0  2c6a					      END_LEVEL	_028_L
      1  2c6a		       00 4c	   LEVEL_SIZE__028_L =	* - LEVEL_START
      2  2c6a				  -	      IF	LEVEL_SIZE__028_L > MAX_LEVEL_SIZE
      3  2c6a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__028_L
      4  2c6a					      ENDIF
      0  2c6a					      DEFL	_028_R, "9#-|#4-2#@#-|#-2#$#-$2#|#-.-.2$2-#|#-.*.2-#-#|#-#.#$3-#|#-#2*3-2#|#4-4#-|6#4-"
      0  2c6a					      START_LEVEL	_028_R
      1  2c6a				   LEVEL_START SET	*
      2  2c6a		       00 05	   BANK_LEVEL__028_R =	_CURRENT_BANK
      3  2c6a				   LEVEL__028_R SUBROUTINE
      4  2c6a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c6a
      2  2c6a		       39 23 2d 7c*	      .byte.b	"9#-|#4-2#@#-|#-2#$#-$2#|#-.-.2$2-#|#-.*.2-#-#|#-#.#$3-#|#-#2*3-2#|#4-4#-|6#4-",0
      0  2cb8					      END_LEVEL	_028_R
      1  2cb8		       00 4e	   LEVEL_SIZE__028_R =	* - LEVEL_START
      2  2cb8				  -	      IF	LEVEL_SIZE__028_R > MAX_LEVEL_SIZE
      3  2cb8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__028_R
      4  2cb8					      ENDIF
      0  2cb8					      DEFL	_029_L, "-5#3-|-#-@-2#2-|2#$*$-3#|#2.*.$2-#|#.*.$3-#|2#2-$-3#|-3#2-#2-|3-4#2-"
      0  2cb8					      START_LEVEL	_029_L
      1  2cb8				   LEVEL_START SET	*
      2  2cb8		       00 05	   BANK_LEVEL__029_L =	_CURRENT_BANK
      3  2cb8				   LEVEL__029_L SUBROUTINE
      4  2cb8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cb8
      2  2cb8		       2d 35 23 33*	      .byte.b	"-5#3-|-#-@-2#2-|2#$*$-3#|#2.*.$2-#|#.*.$3-#|2#2-$-3#|-3#2-#2-|3-4#2-",0
      0  2cfd					      END_LEVEL	_029_L
      1  2cfd		       00 45	   LEVEL_SIZE__029_L =	* - LEVEL_START
      2  2cfd				  -	      IF	LEVEL_SIZE__029_L > MAX_LEVEL_SIZE
      3  2cfd				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__029_L
      4  2cfd					      ENDIF
      0  2cfd					      DEFL	_029_R, "-4#4-|-#@-4#-|2#$-$2-2#|#2.3$2-#|#.2*.*$-#|3#2-2.-#|2-#2-$.2#|2-6#-"
      0  2cfd					      START_LEVEL	_029_R
      1  2cfd				   LEVEL_START SET	*
      2  2cfd		       00 05	   BANK_LEVEL__029_R =	_CURRENT_BANK
      3  2cfd				   LEVEL__029_R SUBROUTINE
      4  2cfd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cfd
      2  2cfd		       2d 34 23 34*	      .byte.b	"-4#4-|-#@-4#-|2#$-$2-2#|#2.3$2-#|#.2*.*$-#|3#2-2.-#|2-#2-$.2#|2-6#-",0
      0  2d41					      END_LEVEL	_029_R
      1  2d41		       00 44	   LEVEL_SIZE__029_R =	* - LEVEL_START
      2  2d41				  -	      IF	LEVEL_SIZE__029_R > MAX_LEVEL_SIZE
      3  2d41				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__029_R
      4  2d41					      ENDIF
      0  2d41					      DEFL	_030_L, "6-5#|5#-#2-@#|#3-3#2$-#|#2-$-2.-$2#|3#-.*.*-2#|2-3#-.$2-#|4-#3-#-#|4-2#4-#|5-6#"
      0  2d41					      START_LEVEL	_030_L
      1  2d41				   LEVEL_START SET	*
      2  2d41		       00 05	   BANK_LEVEL__030_L =	_CURRENT_BANK
      3  2d41				   LEVEL__030_L SUBROUTINE
      4  2d41				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d41
      2  2d41		       36 2d 35 23*	      .byte.b	"6-5#|5#-#2-@#|#3-3#2$-#|#2-$-2.-$2#|3#-.*.*-2#|2-3#-.$2-#|4-#3-#-#|4-2#4-#|5-6#",0
      0  2d91					      END_LEVEL	_030_L
      1  2d91		       00 50	   LEVEL_SIZE__030_L =	* - LEVEL_START
      2  2d91				  -	      IF	LEVEL_SIZE__030_L > MAX_LEVEL_SIZE
      3  2d91				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__030_L
      4  2d91					      ENDIF
      0  2d91					      DEFL	_030_R, "-7#2-|2#-$2-.#2-|#-$-$#.#2-|#-#.$2.#2-|#-#3.$2#-|#2-$#*2-2#|3#2-*2$-#|2-#@5-#|2-8#"
      0  2d91					      START_LEVEL	_030_R
      1  2d91				   LEVEL_START SET	*
      2  2d91		       00 05	   BANK_LEVEL__030_R =	_CURRENT_BANK
      3  2d91				   LEVEL__030_R SUBROUTINE
      4  2d91				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d91
      2  2d91		       2d 37 23 32*	      .byte.b	"-7#2-|2#-$2-.#2-|#-$-$#.#2-|#-#.$2.#2-|#-#3.$2#-|#2-$#*2-2#|3#2-*2$-#|2-#@5-#|2-8#",0
      0  2de4					      END_LEVEL	_030_R
      1  2de4		       00 53	   LEVEL_SIZE__030_R =	* - LEVEL_START
      2  2de4				  -	      IF	LEVEL_SIZE__030_R > MAX_LEVEL_SIZE
      3  2de4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__030_R
      4  2de4					      ENDIF
      0  2de4					      DEFL	_031_L, "-7#2-|-#3-@-3#|-#-2$*2$-#|3#2-*.2-#|#2.2*.*2-#|#$#2-.2-2#|#3-5#-|5#5-"
      0  2de4					      START_LEVEL	_031_L
      1  2de4				   LEVEL_START SET	*
      2  2de4		       00 05	   BANK_LEVEL__031_L =	_CURRENT_BANK
      3  2de4				   LEVEL__031_L SUBROUTINE
      4  2de4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2de4
      2  2de4		       2d 37 23 32*	      .byte.b	"-7#2-|-#3-@-3#|-#-2$*2$-#|3#2-*.2-#|#2.2*.*2-#|#$#2-.2-2#|#3-5#-|5#5-",0
      0  2e2a					      END_LEVEL	_031_L
      1  2e2a		       00 46	   LEVEL_SIZE__031_L =	* - LEVEL_START
      2  2e2a				  -	      IF	LEVEL_SIZE__031_L > MAX_LEVEL_SIZE
      3  2e2a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__031_L
      4  2e2a					      ENDIF
      0  2e2a					      DEFL	_031_R, "6#-|#2-#+#-|#2-$.2#|#2-2*.#|#-$-.$#|#-$-*.#|#-2$.-#|#-$-.-#|7#"
      0  2e2a					      START_LEVEL	_031_R
      1  2e2a				   LEVEL_START SET	*
      2  2e2a		       00 05	   BANK_LEVEL__031_R =	_CURRENT_BANK
      3  2e2a				   LEVEL__031_R SUBROUTINE
      4  2e2a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e2a
      2  2e2a		       36 23 2d 7c*	      .byte.b	"6#-|#2-#+#-|#2-$.2#|#2-2*.#|#-$-.$#|#-$-*.#|#-2$.-#|#-$-.-#|7#",0
      0  2e69					      END_LEVEL	_031_R
      1  2e69		       00 3f	   LEVEL_SIZE__031_R =	* - LEVEL_START
      2  2e69				  -	      IF	LEVEL_SIZE__031_R > MAX_LEVEL_SIZE
      3  2e69				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__031_R
      4  2e69					      ENDIF
      0  2e69					      DEFL	_032_L, "-4#2-|-#2-3#|2#2-2.#|#@2$*.#|#-$2-.#|#-$-#*#|3#3-#|2-5#"
      0  2e69					      START_LEVEL	_032_L
      1  2e69				   LEVEL_START SET	*
      2  2e69		       00 05	   BANK_LEVEL__032_L =	_CURRENT_BANK
      3  2e69				   LEVEL__032_L SUBROUTINE
      4  2e69				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e69
      2  2e69		       2d 34 23 32*	      .byte.b	"-4#2-|-#2-3#|2#2-2.#|#@2$*.#|#-$2-.#|#-$-#*#|3#3-#|2-5#",0
      0  2ea1					      END_LEVEL	_032_L
      1  2ea1		       00 38	   LEVEL_SIZE__032_L =	* - LEVEL_START
      2  2ea1				  -	      IF	LEVEL_SIZE__032_L > MAX_LEVEL_SIZE
      3  2ea1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__032_L
      4  2ea1					      ENDIF
      0  2ea1					      DEFL	_032_R, "9#-|#7-2#|#-$3#-$@#|#2-2.#.$-#|#-.*.2*$-#|#-$.*2-$-#|#2-#.$-3#|8#2-"
      0  2ea1					      START_LEVEL	_032_R
      1  2ea1				   LEVEL_START SET	*
      2  2ea1		       00 05	   BANK_LEVEL__032_R =	_CURRENT_BANK
      3  2ea1				   LEVEL__032_R SUBROUTINE
      4  2ea1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ea1
      2  2ea1		       39 23 2d 7c*	      .byte.b	"9#-|#7-2#|#-$3#-$@#|#2-2.#.$-#|#-.*.2*$-#|#-$.*2-$-#|#2-#.$-3#|8#2-",0
      0  2ee5					      END_LEVEL	_032_R
      1  2ee5		       00 44	   LEVEL_SIZE__032_R =	* - LEVEL_START
      2  2ee5				  -	      IF	LEVEL_SIZE__032_R > MAX_LEVEL_SIZE
      3  2ee5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__032_R
      4  2ee5					      ENDIF
      0  2ee5					      DEFL	_033_L, "2-7#-|-2#2-#2-2#|-#2-.*-$-#|-#-$.$-$@#|2#$-2*-3#|#2-$*.*.#-|#3-2.3#-|7#3-"
      0  2ee5					      START_LEVEL	_033_L
      1  2ee5				   LEVEL_START SET	*
      2  2ee5		       00 05	   BANK_LEVEL__033_L =	_CURRENT_BANK
      3  2ee5				   LEVEL__033_L SUBROUTINE
      4  2ee5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ee5
      2  2ee5		       32 2d 37 23*	      .byte.b	"2-7#-|-2#2-#2-2#|-#2-.*-$-#|-#-$.$-$@#|2#$-2*-3#|#2-$*.*.#-|#3-2.3#-|7#3-",0
      0  2f2f					      END_LEVEL	_033_L
      1  2f2f		       00 4a	   LEVEL_SIZE__033_L =	* - LEVEL_START
      2  2f2f				  -	      IF	LEVEL_SIZE__033_L > MAX_LEVEL_SIZE
      3  2f2f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__033_L
      4  2f2f					      ENDIF
      0  2f2f					      DEFL	_033_R, "-7#2-|2#2-#@-2#-|#-$-#3-2#|#-$2-$*$-#|#2-*.*.2-#|2#.*2.-$-#|-9#"
      0  2f2f					      START_LEVEL	_033_R
      1  2f2f				   LEVEL_START SET	*
      2  2f2f		       00 05	   BANK_LEVEL__033_R =	_CURRENT_BANK
      3  2f2f				   LEVEL__033_R SUBROUTINE
      4  2f2f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2f2f
      2  2f2f		       2d 37 23 32*	      .byte.b	"-7#2-|2#2-#@-2#-|#-$-#3-2#|#-$2-$*$-#|#2-*.*.2-#|2#.*2.-$-#|-9#",0
      0  2f6f					      END_LEVEL	_033_R
      1  2f6f		       00 40	   LEVEL_SIZE__033_R =	* - LEVEL_START
      2  2f6f				  -	      IF	LEVEL_SIZE__033_R > MAX_LEVEL_SIZE
      3  2f6f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__033_R
      4  2f6f					      ENDIF
      0  2f6f					      DEFL	_034_L, "5-4#-|-5#2-#-|-#-$@$2-#-|2#-#*$.*2#|#3-.2*2.#|#2-$2-4#|4#2-#3-|3-#2-#3-|3-4#3-"
      0  2f6f					      START_LEVEL	_034_L
      1  2f6f				   LEVEL_START SET	*
      2  2f6f		       00 05	   BANK_LEVEL__034_L =	_CURRENT_BANK
      3  2f6f				   LEVEL__034_L SUBROUTINE
      4  2f6f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2f6f
      2  2f6f		       35 2d 34 23*	      .byte.b	"5-4#-|-5#2-#-|-#-$@$2-#-|2#-#*$.*2#|#3-.2*2.#|#2-$2-4#|4#2-#3-|3-#2-#3-|3-4#3-",0
      0  2fbe					      END_LEVEL	_034_L
      1  2fbe		       00 4f	   LEVEL_SIZE__034_L =	* - LEVEL_START
      2  2fbe				  -	      IF	LEVEL_SIZE__034_L > MAX_LEVEL_SIZE
      3  2fbe				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__034_L
      4  2fbe					      ENDIF
     65  2fbe
      0  2fbe					      CHECK_BANK_SIZE	"LEVELS2"
      1  2fbe		       07 be	   .TEMP      =	* - BANK_START
 LEVELS2 (2K) SIZE =  $7be , FREE= $42
      2  2fbe					      ECHO	"LEVELS2", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2fbe				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2fbe				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2fbe				  -	      ERR
      6  2fbe					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS3.asm LEVEL 2 PASS 3
      0  2fbe					      include	"BANK_LEVELS3.asm"
      1  2fbe							;    Sokoboo - a Sokoban implementation
      2  2fbe							;    using a generic tile-based display engine for the Atari 2600
      3  2fbe							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  2fbe							;
      5  2fbe							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  2fbe							;
      7  2fbe							;    Code related to the generic tile-based display engine was developed by
      8  2fbe							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  2fbe							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  2fbe							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  2fbe							;
     12  2fbe							;    Code related to music and sound effects uses the TIATracker music player
     13  2fbe							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  2fbe							;    directory for Apache licensing details.
     15  2fbe							;
     16  2fbe							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  2fbe							;    See the copyright notices in the License directory for a list of level
     18  2fbe							;    contributors.
     19  2fbe							;
     20  2fbe							;    Except where otherwise indicated, this software is released under the
     21  2fbe							;    following licensing arrangement...
     22  2fbe							;
     23  2fbe							;    This program is free software: you can redistribute it and/or modify
     24  2fbe							;    it under the terms of the GNU General Public License as published by
     25  2fbe							;    the Free Software Foundation, either version 3 of the License, or
     26  2fbe							;    (at your option) any later version.
     27  2fbe							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  2fbe
     29  2fbe							;    This program is distributed in the hope that it will be useful,
     30  2fbe							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  2fbe							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  2fbe							;    GNU General Public License for more details.
     33  2fbe
      0  2fbe					      NEWBANK	LEVELS3
      1  37c7 ????				      SEG	LEVELS3
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   LEVELS3    SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	LEVELS3
     35  3000
      0  3000					      DEFL	_034_R, "-6#3-|-#4-#3-|2#-$.-3#-|#-2$*.$@#-|#-3.#2$2#|4#.4-#|3-3#-#-#|5-#3-#|5-5#"
      0  3000					      START_LEVEL	_034_R
      1  3000				   LEVEL_START SET	*
      2  3000		       00 06	   BANK_LEVEL__034_R =	_CURRENT_BANK
      3  3000				   LEVEL__034_R SUBROUTINE
      4  3000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3000
      2  3000		       2d 36 23 33*	      .byte.b	"-6#3-|-#4-#3-|2#-$.-3#-|#-2$*.$@#-|#-3.#2$2#|4#.4-#|3-3#-#-#|5-#3-#|5-5#",0
      0  3049					      END_LEVEL	_034_R
      1  3049		       00 49	   LEVEL_SIZE__034_R =	* - LEVEL_START
      2  3049				  -	      IF	LEVEL_SIZE__034_R > MAX_LEVEL_SIZE
      3  3049				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__034_R
      4  3049					      ENDIF
      0  3049					      DEFL	_035_L, "5-3#2-|6#.2#-|#@2-2#*.#-|#-3$2.-#-|2#2-$*.$2#|-#-$2-.2-#|-5#3-#|5-5#"
      0  3049					      START_LEVEL	_035_L
      1  3049				   LEVEL_START SET	*
      2  3049		       00 06	   BANK_LEVEL__035_L =	_CURRENT_BANK
      3  3049				   LEVEL__035_L SUBROUTINE
      4  3049				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3049
      2  3049		       35 2d 33 23*	      .byte.b	"5-3#2-|6#.2#-|#@2-2#*.#-|#-3$2.-#-|2#2-$*.$2#|-#-$2-.2-#|-5#3-#|5-5#",0
      0  308e					      END_LEVEL	_035_L
      1  308e		       00 45	   LEVEL_SIZE__035_L =	* - LEVEL_START
      2  308e				  -	      IF	LEVEL_SIZE__035_L > MAX_LEVEL_SIZE
      3  308e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__035_L
      4  308e					      ENDIF
      0  308e					      DEFL	_035_R, "-11#|-#4-@4-#|-#-2$3*$#-#|3#-*.$.-$-#|#3-.*.-4#|#3-2#.2#3-|8#4-"
      0  308e					      START_LEVEL	_035_R
      1  308e				   LEVEL_START SET	*
      2  308e		       00 06	   BANK_LEVEL__035_R =	_CURRENT_BANK
      3  308e				   LEVEL__035_R SUBROUTINE
      4  308e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  308e
      2  308e		       2d 31 31 23*	      .byte.b	"-11#|-#4-@4-#|-#-2$3*$#-#|3#-*.$.-$-#|#3-.*.-4#|#3-2#.2#3-|8#4-",0
      0  30ce					      END_LEVEL	_035_R
      1  30ce		       00 40	   LEVEL_SIZE__035_R =	* - LEVEL_START
      2  30ce				  -	      IF	LEVEL_SIZE__035_R > MAX_LEVEL_SIZE
      3  30ce				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__035_R
      4  30ce					      ENDIF
      0  30ce					      DEFL	_036_L, "5#2-|#3-3#|#*#-$@#|#.2-$-#|#.*2$-#|#2.#2-#|4#2-#|3-4#"
      0  30ce					      START_LEVEL	_036_L
      1  30ce				   LEVEL_START SET	*
      2  30ce		       00 06	   BANK_LEVEL__036_L =	_CURRENT_BANK
      3  30ce				   LEVEL__036_L SUBROUTINE
      4  30ce				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  30ce
      2  30ce		       35 23 32 2d*	      .byte.b	"5#2-|#3-3#|#*#-$@#|#.2-$-#|#.*2$-#|#2.#2-#|4#2-#|3-4#",0
      0  3104					      END_LEVEL	_036_L
      1  3104		       00 36	   LEVEL_SIZE__036_L =	* - LEVEL_START
      2  3104				  -	      IF	LEVEL_SIZE__036_L > MAX_LEVEL_SIZE
      3  3104				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__036_L
      4  3104					      ENDIF
      0  3104					      DEFL	_036_R, "2-5#2-|-2#.2-2#-|-#.*-$-2#|2#2.$-$-#|#.2*.-$@#|#2-$2-$2#|3#4-#-|2-6#-"
      0  3104					      START_LEVEL	_036_R
      1  3104				   LEVEL_START SET	*
      2  3104		       00 06	   BANK_LEVEL__036_R =	_CURRENT_BANK
      3  3104				   LEVEL__036_R SUBROUTINE
      4  3104				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3104
      2  3104		       32 2d 35 23*	      .byte.b	"2-5#2-|-2#.2-2#-|-#.*-$-2#|2#2.$-$-#|#.2*.-$@#|#2-$2-$2#|3#4-#-|2-6#-",0
      0  314a					      END_LEVEL	_036_R
      1  314a		       00 46	   LEVEL_SIZE__036_R =	* - LEVEL_START
      2  314a				  -	      IF	LEVEL_SIZE__036_R > MAX_LEVEL_SIZE
      3  314a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__036_R
      4  314a					      ENDIF
      0  314a					      DEFL	_037_L, "5-6#|6#4-#|#2-#@2.2$-#|#2-$.3*.-#|#3-$.$-$-#|2#2-#.3-2#|-9#-"
      0  314a					      START_LEVEL	_037_L
      1  314a				   LEVEL_START SET	*
      2  314a		       00 06	   BANK_LEVEL__037_L =	_CURRENT_BANK
      3  314a				   LEVEL__037_L SUBROUTINE
      4  314a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  314a
      2  314a		       35 2d 36 23*	      .byte.b	"5-6#|6#4-#|#2-#@2.2$-#|#2-$.3*.-#|#3-$.$-$-#|2#2-#.3-2#|-9#-",0
      0  3187					      END_LEVEL	_037_L
      1  3187		       00 3d	   LEVEL_SIZE__037_L =	* - LEVEL_START
      2  3187				  -	      IF	LEVEL_SIZE__037_L > MAX_LEVEL_SIZE
      3  3187				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__037_L
      4  3187					      ENDIF
      0  3187					      DEFL	_037_R, "9#2-|#7-3#|#-$2-.2*.-#|2#-*.*$3-#|-2#-2*.#2-#|2-2#@$-$-2#|3-3#3-#-|5-5#-"
      0  3187					      START_LEVEL	_037_R
      1  3187				   LEVEL_START SET	*
      2  3187		       00 06	   BANK_LEVEL__037_R =	_CURRENT_BANK
      3  3187				   LEVEL__037_R SUBROUTINE
      4  3187				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3187
      2  3187		       39 23 32 2d*	      .byte.b	"9#2-|#7-3#|#-$2-.2*.-#|2#-*.*$3-#|-2#-2*.#2-#|2-2#@$-$-2#|3-3#3-#-|5-5#-",0
      0  31d0					      END_LEVEL	_037_R
      1  31d0		       00 49	   LEVEL_SIZE__037_R =	* - LEVEL_START
      2  31d0				  -	      IF	LEVEL_SIZE__037_R > MAX_LEVEL_SIZE
      3  31d0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__037_R
      4  31d0					      ENDIF
      0  31d0					      DEFL	_038_L, "6-4#2-|4-3#@-3#|3-2#2.*$2-#|4#.*.*3-#|#2-2$3-$2-#|#5-6#|3#2-2#5-|2-4#6-"
      0  31d0					      START_LEVEL	_038_L
      1  31d0				   LEVEL_START SET	*
      2  31d0		       00 06	   BANK_LEVEL__038_L =	_CURRENT_BANK
      3  31d0				   LEVEL__038_L SUBROUTINE
      4  31d0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  31d0
      2  31d0		       36 2d 34 23*	      .byte.b	"6-4#2-|4-3#@-3#|3-2#2.*$2-#|4#.*.*3-#|#2-2$3-$2-#|#5-6#|3#2-2#5-|2-4#6-",0
      0  3218					      END_LEVEL	_038_L
      1  3218		       00 48	   LEVEL_SIZE__038_L =	* - LEVEL_START
      2  3218				  -	      IF	LEVEL_SIZE__038_L > MAX_LEVEL_SIZE
      3  3218				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__038_L
      4  3218					      ENDIF
      0  3218					      DEFL	_038_R, "6-6#|4-3#.#-@#|2-3#2.*#$-#|3#-.*2.-$-#|#2-2$2-#-3#|#-$2-#-$-#2-|2#5-3#2-|-7#4-"
      0  3218					      START_LEVEL	_038_R
      1  3218				   LEVEL_START SET	*
      2  3218		       00 06	   BANK_LEVEL__038_R =	_CURRENT_BANK
      3  3218				   LEVEL__038_R SUBROUTINE
      4  3218				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3218
      2  3218		       36 2d 36 23*	      .byte.b	"6-6#|4-3#.#-@#|2-3#2.*#$-#|3#-.*2.-$-#|#2-2$2-#-3#|#-$2-#-$-#2-|2#5-3#2-|-7#4-",0
      0  3267					      END_LEVEL	_038_R
      1  3267		       00 4f	   LEVEL_SIZE__038_R =	* - LEVEL_START
      2  3267				  -	      IF	LEVEL_SIZE__038_R > MAX_LEVEL_SIZE
      3  3267				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__038_R
      4  3267					      ENDIF
      0  3267					      DEFL	_039_L, "-7#2-|-#5-#2-|2#-#-$-#2-|#.2*.-3#-|2#@3*2-2#|-2#-2.$2-#|2-2#$#-$-#|3-#5-#|3-7#"
      0  3267					      START_LEVEL	_039_L
      1  3267				   LEVEL_START SET	*
      2  3267		       00 06	   BANK_LEVEL__039_L =	_CURRENT_BANK
      3  3267				   LEVEL__039_L SUBROUTINE
      4  3267				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3267
      2  3267		       2d 37 23 32*	      .byte.b	"-7#2-|-#5-#2-|2#-#-$-#2-|#.2*.-3#-|2#@3*2-2#|-2#-2.$2-#|2-2#$#-$-#|3-#5-#|3-7#",0
      0  32b6					      END_LEVEL	_039_L
      1  32b6		       00 4f	   LEVEL_SIZE__039_L =	* - LEVEL_START
      2  32b6				  -	      IF	LEVEL_SIZE__039_L > MAX_LEVEL_SIZE
      3  32b6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__039_L
      4  32b6					      ENDIF
      0  32b6					      DEFL	_039_R, "4-4#4-|3-2#2-3#2-|2-2#-$.2-#2-|3#-.2*-$3#|#-$-4.3-#|#@$3#-#-#-#|2#4-$2-$-#|-5#3-3#|5-5#2-"
      0  32b6					      START_LEVEL	_039_R
      1  32b6				   LEVEL_START SET	*
      2  32b6		       00 06	   BANK_LEVEL__039_R =	_CURRENT_BANK
      3  32b6				   LEVEL__039_R SUBROUTINE
      4  32b6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  32b6
      2  32b6		       34 2d 34 23*	      .byte.b	"4-4#4-|3-2#2-3#2-|2-2#-$.2-#2-|3#-.2*-$3#|#-$-4.3-#|#@$3#-#-#-#|2#4-$2-$-#|-5#3-3#|5-5#2-",0
      0  3310					      END_LEVEL	_039_R
      1  3310		       00 5a	   LEVEL_SIZE__039_R =	* - LEVEL_START
      2  3310					      IF	LEVEL_SIZE__039_R > MAX_LEVEL_SIZE
      3  3310				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__039_R
      4  3310					      ENDIF
      0  3310					      DEFL	_040_L, "6#3-|#3-@#3-|#2-$.3#-|3#$*$.2#|3#-.2*.#|#2-$-.3#|#2-$3-#-|4#3-#-|3-5#-"
      0  3310					      START_LEVEL	_040_L
      1  3310				   LEVEL_START SET	*
      2  3310		       00 06	   BANK_LEVEL__040_L =	_CURRENT_BANK
      3  3310				   LEVEL__040_L SUBROUTINE
      4  3310				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3310
      2  3310		       36 23 33 2d*	      .byte.b	"6#3-|#3-@#3-|#2-$.3#-|3#$*$.2#|3#-.2*.#|#2-$-.3#|#2-$3-#-|4#3-#-|3-5#-",0
      0  3357					      END_LEVEL	_040_L
      1  3357		       00 47	   LEVEL_SIZE__040_L =	* - LEVEL_START
      2  3357				  -	      IF	LEVEL_SIZE__040_L > MAX_LEVEL_SIZE
      3  3357				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__040_L
      4  3357					      ENDIF
      0  3357					      DEFL	_040_R, "5-4#-|-5#2-2#|2#.-$2-$-#|#-2.*.$#@#|#-*-.2-$-#|2#-$*-4#|-#3-2#3-|-5#4-"
      0  3357					      START_LEVEL	_040_R
      1  3357				   LEVEL_START SET	*
      2  3357		       00 06	   BANK_LEVEL__040_R =	_CURRENT_BANK
      3  3357				   LEVEL__040_R SUBROUTINE
      4  3357				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3357
      2  3357		       35 2d 34 23*	      .byte.b	"5-4#-|-5#2-2#|2#.-$2-$-#|#-2.*.$#@#|#-*-.2-$-#|2#-$*-4#|-#3-2#3-|-5#4-",0
      0  339e					      END_LEVEL	_040_R
      1  339e		       00 47	   LEVEL_SIZE__040_R =	* - LEVEL_START
      2  339e				  -	      IF	LEVEL_SIZE__040_R > MAX_LEVEL_SIZE
      3  339e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__040_R
      4  339e					      ENDIF
     49  339e
      0  339e					      DEFL	_041_L, "4-3#5-|4-#.4#2-|5#*.$-#2-|#4-3.-3#|#-3$-*.$2-#|2#-@2#.$-$-#|-5#4-2#|5-6#-"
      0  339e					      START_LEVEL	_041_L
      1  339e				   LEVEL_START SET	*
      2  339e		       00 06	   BANK_LEVEL__041_L =	_CURRENT_BANK
      3  339e				   LEVEL__041_L SUBROUTINE
      4  339e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  339e
      2  339e		       34 2d 33 23*	      .byte.b	"4-3#5-|4-#.4#2-|5#*.$-#2-|#4-3.-3#|#-3$-*.$2-#|2#-@2#.$-$-#|-5#4-2#|5-6#-",0
      0  33e8					      END_LEVEL	_041_L
      1  33e8		       00 4a	   LEVEL_SIZE__041_L =	* - LEVEL_START
      2  33e8				  -	      IF	LEVEL_SIZE__041_L > MAX_LEVEL_SIZE
      3  33e8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__041_L
      4  33e8					      ENDIF
      0  33e8					      DEFL	_041_R, "-4#3-|2#2-3#-|#-@2$-#-|#-$-#.#-|2#$-2.2#|#2-$*2.#|#2-$-*2#|#3-#.#-|7#-"
      0  33e8					      START_LEVEL	_041_R
      1  33e8				   LEVEL_START SET	*
      2  33e8		       00 06	   BANK_LEVEL__041_R =	_CURRENT_BANK
      3  33e8				   LEVEL__041_R SUBROUTINE
      4  33e8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  33e8
      2  33e8		       2d 34 23 33*	      .byte.b	"-4#3-|2#2-3#-|#-@2$-#-|#-$-#.#-|2#$-2.2#|#2-$*2.#|#2-$-*2#|#3-#.#-|7#-",0
      0  342f					      END_LEVEL	_041_R
      1  342f		       00 47	   LEVEL_SIZE__041_R =	* - LEVEL_START
      2  342f				  -	      IF	LEVEL_SIZE__041_R > MAX_LEVEL_SIZE
      3  342f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__041_R
      4  342f					      ENDIF
      0  342f					      DEFL	_042_L, "8#4-|#6-#4-|#-#-$*-#4-|#-#-#.3#3-|#3-#2.-3#-|#3-2*4-2#|5#.-3$-#|4-4#2-@#|7-5#"
      0  342f					      START_LEVEL	_042_L
      1  342f				   LEVEL_START SET	*
      2  342f		       00 06	   BANK_LEVEL__042_L =	_CURRENT_BANK
      3  342f				   LEVEL__042_L SUBROUTINE
      4  342f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  342f
      2  342f		       38 23 34 2d*	      .byte.b	"8#4-|#6-#4-|#-#-$*-#4-|#-#-#.3#3-|#3-#2.-3#-|#3-2*4-2#|5#.-3$-#|4-4#2-@#|7-5#",0
      0  347d					      END_LEVEL	_042_L
      1  347d		       00 4e	   LEVEL_SIZE__042_L =	* - LEVEL_START
      2  347d				  -	      IF	LEVEL_SIZE__042_L > MAX_LEVEL_SIZE
      3  347d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__042_L
      4  347d					      ENDIF
      0  347d					      DEFL	_042_R, "3-5#4-|2-2#3-#4-|2-#-$-$#4-|3#-*.-2#3-|#@$-#.$-2#2-|#-$2-.*.-3#|3#2.*-$3-#|2-6#3-#|7-5#"
      0  347d					      START_LEVEL	_042_R
      1  347d				   LEVEL_START SET	*
      2  347d		       00 06	   BANK_LEVEL__042_R =	_CURRENT_BANK
      3  347d				   LEVEL__042_R SUBROUTINE
      4  347d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  347d
      2  347d		       33 2d 35 23*	      .byte.b	"3-5#4-|2-2#3-#4-|2-#-$-$#4-|3#-*.-2#3-|#@$-#.$-2#2-|#-$2-.*.-3#|3#2.*-$3-#|2-6#3-#|7-5#",0
      0  34d5					      END_LEVEL	_042_R
      1  34d5		       00 58	   LEVEL_SIZE__042_R =	* - LEVEL_START
      2  34d5				  -	      IF	LEVEL_SIZE__042_R > MAX_LEVEL_SIZE
      3  34d5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__042_R
      4  34d5					      ENDIF
      0  34d5					      DEFL	_043_L, "-8#4-|-#@$.-.-5#|-#2$*.2*.3-#|2#2-$-.2-#$-#|#-$-2#.#3-2#|#3-8#-|#2-2#8-|4#9-"
      0  34d5					      START_LEVEL	_043_L
      1  34d5				   LEVEL_START SET	*
      2  34d5		       00 06	   BANK_LEVEL__043_L =	_CURRENT_BANK
      3  34d5				   LEVEL__043_L SUBROUTINE
      4  34d5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  34d5
      2  34d5		       2d 38 23 34*	      .byte.b	"-8#4-|-#@$.-.-5#|-#2$*.2*.3-#|2#2-$-.2-#$-#|#-$-2#.#3-2#|#3-8#-|#2-2#8-|4#9-",0
      0  3522					      END_LEVEL	_043_L
      1  3522		       00 4d	   LEVEL_SIZE__043_L =	* - LEVEL_START
      2  3522				  -	      IF	LEVEL_SIZE__043_L > MAX_LEVEL_SIZE
      3  3522				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__043_L
      4  3522					      ENDIF
      0  3522					      DEFL	_043_R, "2-6#-|-2#4-#-|2#@$-#-#-|#-$#$2.#-|#*.*2.*2#|#-$2-$2.#|#-$-$2-2#|#4-3#-|6#3-"
      0  3522					      START_LEVEL	_043_R
      1  3522				   LEVEL_START SET	*
      2  3522		       00 06	   BANK_LEVEL__043_R =	_CURRENT_BANK
      3  3522				   LEVEL__043_R SUBROUTINE
      4  3522				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3522
      2  3522		       32 2d 36 23*	      .byte.b	"2-6#-|-2#4-#-|2#@$-#-#-|#-$#$2.#-|#*.*2.*2#|#-$2-$2.#|#-$-$2-2#|#4-3#-|6#3-",0
      0  356e					      END_LEVEL	_043_R
      1  356e		       00 4c	   LEVEL_SIZE__043_R =	* - LEVEL_START
      2  356e				  -	      IF	LEVEL_SIZE__043_R > MAX_LEVEL_SIZE
      3  356e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__043_R
      4  356e					      ENDIF
      0  356e					      DEFL	_044_L, "7#-|#@4-#-|#$-.2$#-|#3.*-2#|#*$2*2-#|#3-#2-#|#3-#2-#|8#"
      0  356e					      START_LEVEL	_044_L
      1  356e				   LEVEL_START SET	*
      2  356e		       00 06	   BANK_LEVEL__044_L =	_CURRENT_BANK
      3  356e				   LEVEL__044_L SUBROUTINE
      4  356e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  356e
      2  356e		       37 23 2d 7c*	      .byte.b	"7#-|#@4-#-|#$-.2$#-|#3.*-2#|#*$2*2-#|#3-#2-#|#3-#2-#|8#",0
      0  35a6					      END_LEVEL	_044_L
      1  35a6		       00 38	   LEVEL_SIZE__044_L =	* - LEVEL_START
      2  35a6				  -	      IF	LEVEL_SIZE__044_L > MAX_LEVEL_SIZE
      3  35a6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__044_L
      4  35a6					      ENDIF
      0  35a6					      DEFL	_044_R, "4#-4#-|#2-3#2-#-|#@$2-#-$2#|#$*$5-#|#-*2.$2#-#|#3.#4-#|2#-.-$4#|-3#2-#3-|3-4#3-"
      0  35a6					      START_LEVEL	_044_R
      1  35a6				   LEVEL_START SET	*
      2  35a6		       00 06	   BANK_LEVEL__044_R =	_CURRENT_BANK
      3  35a6				   LEVEL__044_R SUBROUTINE
      4  35a6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35a6
      2  35a6		       34 23 2d 34*	      .byte.b	"4#-4#-|#2-3#2-#-|#@$2-#-$2#|#$*$5-#|#-*2.$2#-#|#3.#4-#|2#-.-$4#|-3#2-#3-|3-4#3-",0
      0  35f6					      END_LEVEL	_044_R
      1  35f6		       00 50	   LEVEL_SIZE__044_R =	* - LEVEL_START
      2  35f6				  -	      IF	LEVEL_SIZE__044_R > MAX_LEVEL_SIZE
      3  35f6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__044_R
      4  35f6					      ENDIF
      0  35f6					      DEFL	_045_L, "3-4#2-|3-#2.3#|4#$.$-#|#@-#-.*-#|#-$2-2*.#|2#-$-*2-#|-2#-$3-#|2-2#2-3#|3-4#2-"
      0  35f6					      START_LEVEL	_045_L
      1  35f6				   LEVEL_START SET	*
      2  35f6		       00 06	   BANK_LEVEL__045_L =	_CURRENT_BANK
      3  35f6				   LEVEL__045_L SUBROUTINE
      4  35f6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35f6
      2  35f6		       33 2d 34 23*	      .byte.b	"3-4#2-|3-#2.3#|4#$.$-#|#@-#-.*-#|#-$2-2*.#|2#-$-*2-#|-2#-$3-#|2-2#2-3#|3-4#2-",0
      0  3644					      END_LEVEL	_045_L
      1  3644		       00 4e	   LEVEL_SIZE__045_L =	* - LEVEL_START
      2  3644				  -	      IF	LEVEL_SIZE__045_L > MAX_LEVEL_SIZE
      3  3644				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__045_L
      4  3644					      ENDIF
      0  3644					      DEFL	_045_R, "3-6#2-|4#4-#2-|#-$-$2#-3#|#-2$-$-$2-#|#-5.#$-#|#-.*#$2.2-#|2#.-$@5#|-6#4-"
      0  3644					      START_LEVEL	_045_R
      1  3644				   LEVEL_START SET	*
      2  3644		       00 06	   BANK_LEVEL__045_R =	_CURRENT_BANK
      3  3644				   LEVEL__045_R SUBROUTINE
      4  3644				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3644
      2  3644		       33 2d 36 23*	      .byte.b	"3-6#2-|4#4-#2-|#-$-$2#-3#|#-2$-$-$2-#|#-5.#$-#|#-.*#$2.2-#|2#.-$@5#|-6#4-",0
      0  368e					      END_LEVEL	_045_R
      1  368e		       00 4a	   LEVEL_SIZE__045_R =	* - LEVEL_START
      2  368e				  -	      IF	LEVEL_SIZE__045_R > MAX_LEVEL_SIZE
      3  368e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__045_R
      4  368e					      ENDIF
      0  368e					      DEFL	_046_L, "10#-|#@3-#3-2#|#-#*$2-2$-#|#-*.$-$3-#|3#.*$-#2-#|2-#.*.-4#|2-#2.-2#3-|2-5#4-"
      0  368e					      START_LEVEL	_046_L
      1  368e				   LEVEL_START SET	*
      2  368e		       00 06	   BANK_LEVEL__046_L =	_CURRENT_BANK
      3  368e				   LEVEL__046_L SUBROUTINE
      4  368e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  368e
      2  368e		       31 30 23 2d*	      .byte.b	"10#-|#@3-#3-2#|#-#*$2-2$-#|#-*.$-$3-#|3#.*$-#2-#|2-#.*.-4#|2-#2.-2#3-|2-5#4-",0
      0  36db					      END_LEVEL	_046_L
      1  36db		       00 4d	   LEVEL_SIZE__046_L =	* - LEVEL_START
      2  36db				  -	      IF	LEVEL_SIZE__046_L > MAX_LEVEL_SIZE
      3  36db				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__046_L
      4  36db					      ENDIF
      0  36db					      DEFL	_046_R, "8#3-|#3-4#3-|#-$2-$@3#-|#2-5$-#-|3#3.*2.2#|2-2#2-$3.#|3-#2-5#|3-4#4-"
      0  36db					      START_LEVEL	_046_R
      1  36db				   LEVEL_START SET	*
      2  36db		       00 06	   BANK_LEVEL__046_R =	_CURRENT_BANK
      3  36db				   LEVEL__046_R SUBROUTINE
      4  36db				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  36db
      2  36db		       38 23 33 2d*	      .byte.b	"8#3-|#3-4#3-|#-$2-$@3#-|#2-5$-#-|3#3.*2.2#|2-2#2-$3.#|3-#2-5#|3-4#4-",0
      0  3720					      END_LEVEL	_046_R
      1  3720		       00 45	   LEVEL_SIZE__046_R =	* - LEVEL_START
      2  3720				  -	      IF	LEVEL_SIZE__046_R > MAX_LEVEL_SIZE
      3  3720				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__046_R
      4  3720					      ENDIF
      0  3720					      DEFL	_047_L, "5-3#5-|3-3#.#5-|2-2#2-.#5-|2-#-$#.6#|3#3-.2#3-#|#-$@2*.$-$#-#|#4-2#-$3-#|8#3-2#|7-5#-"
      0  3720					      START_LEVEL	_047_L
      1  3720				   LEVEL_START SET	*
      2  3720		       00 06	   BANK_LEVEL__047_L =	_CURRENT_BANK
      3  3720				   LEVEL__047_L SUBROUTINE
      4  3720				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3720
      2  3720		       35 2d 33 23*	      .byte.b	"5-3#5-|3-3#.#5-|2-2#2-.#5-|2-#-$#.6#|3#3-.2#3-#|#-$@2*.$-$#-#|#4-2#-$3-#|8#3-2#|7-5#-",0
      0  3776					      END_LEVEL	_047_L
      1  3776		       00 56	   LEVEL_SIZE__047_L =	* - LEVEL_START
      2  3776				  -	      IF	LEVEL_SIZE__047_L > MAX_LEVEL_SIZE
      3  3776				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__047_L
      4  3776					      ENDIF
      0  3776					      DEFL	_047_R, "4-6#|3-2#3-@#|-3#-3$-#|-#.2-#-$-#|2#.*2-$2-#|#2.-2$#-2#|2#2.#-3#-|-#.3-#3-|-6#3-"
      0  3776					      START_LEVEL	_047_R
      1  3776				   LEVEL_START SET	*
      2  3776		       00 06	   BANK_LEVEL__047_R =	_CURRENT_BANK
      3  3776				   LEVEL__047_R SUBROUTINE
      4  3776				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3776
      2  3776		       34 2d 36 23*	      .byte.b	"4-6#|3-2#3-@#|-3#-3$-#|-#.2-#-$-#|2#.*2-$2-#|#2.-2$#-2#|2#2.#-3#-|-#.3-#3-|-6#3-",0
      0  37c7					      END_LEVEL	_047_R
      1  37c7		       00 51	   LEVEL_SIZE__047_R =	* - LEVEL_START
      2  37c7				  -	      IF	LEVEL_SIZE__047_R > MAX_LEVEL_SIZE
      3  37c7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__047_R
      4  37c7					      ENDIF
     64  37c7
     65  37c7
     66  37c7
      0  37c7					      CHECK_BANK_SIZE	"LEVELS3 -- full 2K"
      1  37c7		       07 c7	   .TEMP      =	* - BANK_START
 LEVELS3 -- full 2K (2K) SIZE =  $7c7 , FREE= $39
      2  37c7					      ECHO	"LEVELS3 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  37c7				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  37c7				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  37c7				  -	      ERR
      6  37c7					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS4.asm LEVEL 2 PASS 3
      0  37c7					      include	"BANK_LEVELS4.asm"
      1  37c7							;    Sokoboo - a Sokoban implementation
      2  37c7							;    using a generic tile-based display engine for the Atari 2600
      3  37c7							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  37c7							;
      5  37c7							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  37c7							;
      7  37c7							;    Code related to the generic tile-based display engine was developed by
      8  37c7							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  37c7							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  37c7							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  37c7							;
     12  37c7							;    Code related to music and sound effects uses the TIATracker music player
     13  37c7							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  37c7							;    directory for Apache licensing details.
     15  37c7							;
     16  37c7							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  37c7							;    See the copyright notices in the License directory for a list of level
     18  37c7							;    contributors.
     19  37c7							;
     20  37c7							;    Except where otherwise indicated, this software is released under the
     21  37c7							;    following licensing arrangement...
     22  37c7							;
     23  37c7							;    This program is free software: you can redistribute it and/or modify
     24  37c7							;    it under the terms of the GNU General Public License as published by
     25  37c7							;    the Free Software Foundation, either version 3 of the License, or
     26  37c7							;    (at your option) any later version.
     27  37c7							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  37c7
     29  37c7							;    This program is distributed in the hope that it will be useful,
     30  37c7							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  37c7							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  37c7							;    GNU General Public License for more details.
     33  37c7
     34  37c7							; level definitions
     35  37c7							; Sample level definitions.
     36  37c7							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  37c7							; have as many banks as you like.
     38  37c7
      0  37c7					      NEWBANK	LEVELS4
      1  3f4a ????				      SEG	LEVELS4
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   LEVELS4    SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	LEVELS4
     40  3800
      0  3800					      DEFL	_048_L, "2-7#-|2-#5-2#|3#$2-#2-#|#-$.3-$-#|#.2*2-4#|#+.#-2#3-|2#$3-#3-|-#4-#3-|-6#3-"
      0  3800					      START_LEVEL	_048_L
      1  3800				   LEVEL_START SET	*
      2  3800		       00 07	   BANK_LEVEL__048_L =	_CURRENT_BANK
      3  3800				   LEVEL__048_L SUBROUTINE
      4  3800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3800
      2  3800		       32 2d 37 23*	      .byte.b	"2-7#-|2-#5-2#|3#$2-#2-#|#-$.3-$-#|#.2*2-4#|#+.#-2#3-|2#$3-#3-|-#4-#3-|-6#3-",0
      0  384c					      END_LEVEL	_048_L
      1  384c		       00 4c	   LEVEL_SIZE__048_L =	* - LEVEL_START
      2  384c				  -	      IF	LEVEL_SIZE__048_L > MAX_LEVEL_SIZE
      3  384c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__048_L
      4  384c					      ENDIF
      0  384c					      DEFL	_048_R, "5-5#|2-4#3-#|3#-.$-$-#|#2-*3.3#|#2-*.-4#|2#2$*$3-#|-#@$.4-#|-4#2-3#|4-4#2-"
      0  384c					      START_LEVEL	_048_R
      1  384c				   LEVEL_START SET	*
      2  384c		       00 07	   BANK_LEVEL__048_R =	_CURRENT_BANK
      3  384c				   LEVEL__048_R SUBROUTINE
      4  384c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  384c
      2  384c		       35 2d 35 23*	      .byte.b	"5-5#|2-4#3-#|3#-.$-$-#|#2-*3.3#|#2-*.-4#|2#2$*$3-#|-#@$.4-#|-4#2-3#|4-4#2-",0
      0  3897					      END_LEVEL	_048_R
      1  3897		       00 4b	   LEVEL_SIZE__048_R =	* - LEVEL_START
      2  3897				  -	      IF	LEVEL_SIZE__048_R > MAX_LEVEL_SIZE
      3  3897				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__048_R
      4  3897					      ENDIF
      0  3897					      DEFL	_049_L, "4#7-|#2-4#4-|#2-$2-5#|#-$-#-4.#|2#-2$-.-.2#|-#$-#-*#-#-|-#-@#$-#-#-|-4#4-#-|4-6#-"
      0  3897					      START_LEVEL	_049_L
      1  3897				   LEVEL_START SET	*
      2  3897		       00 07	   BANK_LEVEL__049_L =	_CURRENT_BANK
      3  3897				   LEVEL__049_L SUBROUTINE
      4  3897				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3897
      2  3897		       34 23 37 2d*	      .byte.b	"4#7-|#2-4#4-|#2-$2-5#|#-$-#-4.#|2#-2$-.-.2#|-#$-#-*#-#-|-#-@#$-#-#-|-4#4-#-|4-6#-",0
      0  38e9					      END_LEVEL	_049_L
      1  38e9		       00 52	   LEVEL_SIZE__049_L =	* - LEVEL_START
      2  38e9				  -	      IF	LEVEL_SIZE__049_L > MAX_LEVEL_SIZE
      3  38e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__049_L
      4  38e9					      ENDIF
      0  38e9					      DEFL	_049_R, "8#2-|#6-3#|#-$2#$.*-#|#-$-$2.*+#|#3-#2.$-#|#-2$#-.3#|2#5-#2-|-7#2-"
      0  38e9					      START_LEVEL	_049_R
      1  38e9				   LEVEL_START SET	*
      2  38e9		       00 07	   BANK_LEVEL__049_R =	_CURRENT_BANK
      3  38e9				   LEVEL__049_R SUBROUTINE
      4  38e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  38e9
      2  38e9		       38 23 32 2d*	      .byte.b	"8#2-|#6-3#|#-$2#$.*-#|#-$-$2.*+#|#3-#2.$-#|#-2$#-.3#|2#5-#2-|-7#2-",0
      0  392c					      END_LEVEL	_049_R
      1  392c		       00 43	   LEVEL_SIZE__049_R =	* - LEVEL_START
      2  392c				  -	      IF	LEVEL_SIZE__049_R > MAX_LEVEL_SIZE
      3  392c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__049_R
      4  392c					      ENDIF
     45  392c
      0  392c					      DEFL	_050_L, "4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#"
      0  392c					      START_LEVEL	_050_L
      1  392c				   LEVEL_START SET	*
      2  392c		       00 07	   BANK_LEVEL__050_L =	_CURRENT_BANK
      3  392c				   LEVEL__050_L SUBROUTINE
      4  392c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  392c
      2  392c		       34 2d 35 23*	      .byte.b	"4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#",0
      0  3979					      END_LEVEL	_050_L
      1  3979		       00 4d	   LEVEL_SIZE__050_L =	* - LEVEL_START
      2  3979				  -	      IF	LEVEL_SIZE__050_L > MAX_LEVEL_SIZE
      3  3979				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_L
      4  3979					      ENDIF
      0  3979					      DEFL	_050_R, "8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#"
      0  3979					      START_LEVEL	_050_R
      1  3979				   LEVEL_START SET	*
      2  3979		       00 07	   BANK_LEVEL__050_R =	_CURRENT_BANK
      3  3979				   LEVEL__050_R SUBROUTINE
      4  3979				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3979
      2  3979		       38 23 7c 23*	      .byte.b	"8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#",0
      0  39b2					      END_LEVEL	_050_R
      1  39b2		       00 39	   LEVEL_SIZE__050_R =	* - LEVEL_START
      2  39b2				  -	      IF	LEVEL_SIZE__050_R > MAX_LEVEL_SIZE
      3  39b2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_R
      4  39b2					      ENDIF
      0  39b2					      DEFL	_051_L, "-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#"
      0  39b2					      START_LEVEL	_051_L
      1  39b2				   LEVEL_START SET	*
      2  39b2		       00 07	   BANK_LEVEL__051_L =	_CURRENT_BANK
      3  39b2				   LEVEL__051_L SUBROUTINE
      4  39b2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  39b2
      2  39b2		       2d 36 23 34*	      .byte.b	"-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#",0
      0  3a05					      END_LEVEL	_051_L
      1  3a05		       00 53	   LEVEL_SIZE__051_L =	* - LEVEL_START
      2  3a05				  -	      IF	LEVEL_SIZE__051_L > MAX_LEVEL_SIZE
      3  3a05				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_L
      4  3a05					      ENDIF
      0  3a05					      DEFL	_051_R, "-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-"
      0  3a05					      START_LEVEL	_051_R
      1  3a05				   LEVEL_START SET	*
      2  3a05		       00 07	   BANK_LEVEL__051_R =	_CURRENT_BANK
      3  3a05				   LEVEL__051_R SUBROUTINE
      4  3a05				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a05
      2  3a05		       2d 38 23 2d*	      .byte.b	"-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-",0
      0  3a56					      END_LEVEL	_051_R
      1  3a56		       00 51	   LEVEL_SIZE__051_R =	* - LEVEL_START
      2  3a56				  -	      IF	LEVEL_SIZE__051_R > MAX_LEVEL_SIZE
      3  3a56				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_R
      4  3a56					      ENDIF
      0  3a56					      DEFL	_052_L, "5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-"
      0  3a56					      START_LEVEL	_052_L
      1  3a56				   LEVEL_START SET	*
      2  3a56		       00 07	   BANK_LEVEL__052_L =	_CURRENT_BANK
      3  3a56				   LEVEL__052_L SUBROUTINE
      4  3a56				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a56
      2  3a56		       35 23 36 2d*	      .byte.b	"5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-",0
      0  3a90					      END_LEVEL	_052_L
      1  3a90		       00 3a	   LEVEL_SIZE__052_L =	* - LEVEL_START
      2  3a90				  -	      IF	LEVEL_SIZE__052_L > MAX_LEVEL_SIZE
      3  3a90				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_L
      4  3a90					      ENDIF
      0  3a90					      DEFL	_052_R, "2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-"
      0  3a90					      START_LEVEL	_052_R
      1  3a90				   LEVEL_START SET	*
      2  3a90		       00 07	   BANK_LEVEL__052_R =	_CURRENT_BANK
      3  3a90				   LEVEL__052_R SUBROUTINE
      4  3a90				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a90
      2  3a90		       32 2d 37 23*	      .byte.b	"2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-",0
      0  3ad8					      END_LEVEL	_052_R
      1  3ad8		       00 48	   LEVEL_SIZE__052_R =	* - LEVEL_START
      2  3ad8				  -	      IF	LEVEL_SIZE__052_R > MAX_LEVEL_SIZE
      3  3ad8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_R
      4  3ad8					      ENDIF
      0  3ad8					      DEFL	_053_L, "6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-"
      0  3ad8					      START_LEVEL	_053_L
      1  3ad8				   LEVEL_START SET	*
      2  3ad8		       00 07	   BANK_LEVEL__053_L =	_CURRENT_BANK
      3  3ad8				   LEVEL__053_L SUBROUTINE
      4  3ad8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ad8
      2  3ad8		       36 23 36 2d*	      .byte.b	"6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-",0
      0  3b2d					      END_LEVEL	_053_L
      1  3b2d		       00 55	   LEVEL_SIZE__053_L =	* - LEVEL_START
      2  3b2d				  -	      IF	LEVEL_SIZE__053_L > MAX_LEVEL_SIZE
      3  3b2d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_L
      4  3b2d					      ENDIF
      0  3b2d					      DEFL	_053_R, "5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-"
      0  3b2d					      START_LEVEL	_053_R
      1  3b2d				   LEVEL_START SET	*
      2  3b2d		       00 07	   BANK_LEVEL__053_R =	_CURRENT_BANK
      3  3b2d				   LEVEL__053_R SUBROUTINE
      4  3b2d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b2d
      2  3b2d		       35 2d 35 23*	      .byte.b	"5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-",0
      0  3b7a					      END_LEVEL	_053_R
      1  3b7a		       00 4d	   LEVEL_SIZE__053_R =	* - LEVEL_START
      2  3b7a				  -	      IF	LEVEL_SIZE__053_R > MAX_LEVEL_SIZE
      3  3b7a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_R
      4  3b7a					      ENDIF
      0  3b7a					      DEFL	_054_L, "-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-"
      0  3b7a					      START_LEVEL	_054_L
      1  3b7a				   LEVEL_START SET	*
      2  3b7a		       00 07	   BANK_LEVEL__054_L =	_CURRENT_BANK
      3  3b7a				   LEVEL__054_L SUBROUTINE
      4  3b7a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b7a
      2  3b7a		       2d 38 23 32*	      .byte.b	"-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-",0
      0  3bc6					      END_LEVEL	_054_L
      1  3bc6		       00 4c	   LEVEL_SIZE__054_L =	* - LEVEL_START
      2  3bc6				  -	      IF	LEVEL_SIZE__054_L > MAX_LEVEL_SIZE
      3  3bc6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_L
      4  3bc6					      ENDIF
      0  3bc6					      DEFL	_054_R, "2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-"
      0  3bc6					      START_LEVEL	_054_R
      1  3bc6				   LEVEL_START SET	*
      2  3bc6		       00 07	   BANK_LEVEL__054_R =	_CURRENT_BANK
      3  3bc6				   LEVEL__054_R SUBROUTINE
      4  3bc6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3bc6
      2  3bc6		       32 2d 34 23*	      .byte.b	"2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-",0
      0  3c0f					      END_LEVEL	_054_R
      1  3c0f		       00 49	   LEVEL_SIZE__054_R =	* - LEVEL_START
      2  3c0f				  -	      IF	LEVEL_SIZE__054_R > MAX_LEVEL_SIZE
      3  3c0f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_R
      4  3c0f					      ENDIF
      0  3c0f					      DEFL	_055_L, "2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-"
      0  3c0f					      START_LEVEL	_055_L
      1  3c0f				   LEVEL_START SET	*
      2  3c0f		       00 07	   BANK_LEVEL__055_L =	_CURRENT_BANK
      3  3c0f				   LEVEL__055_L SUBROUTINE
      4  3c0f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c0f
      2  3c0f		       32 2d 34 23*	      .byte.b	"2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-",0
      0  3c69					      END_LEVEL	_055_L
      1  3c69		       00 5a	   LEVEL_SIZE__055_L =	* - LEVEL_START
      2  3c69				  -	      IF	LEVEL_SIZE__055_L > MAX_LEVEL_SIZE
      3  3c69				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_L
      4  3c69					      ENDIF
      0  3c69					      DEFL	_055_R, "5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-"
      0  3c69					      START_LEVEL	_055_R
      1  3c69				   LEVEL_START SET	*
      2  3c69		       00 07	   BANK_LEVEL__055_R =	_CURRENT_BANK
      3  3c69				   LEVEL__055_R SUBROUTINE
      4  3c69				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c69
      2  3c69		       35 2d 34 23*	      .byte.b	"5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-",0
      0  3cbe					      END_LEVEL	_055_R
      1  3cbe		       00 55	   LEVEL_SIZE__055_R =	* - LEVEL_START
      2  3cbe				  -	      IF	LEVEL_SIZE__055_R > MAX_LEVEL_SIZE
      3  3cbe				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_R
      4  3cbe					      ENDIF
      0  3cbe					      DEFL	_056_L, "6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#"
      0  3cbe					      START_LEVEL	_056_L
      1  3cbe				   LEVEL_START SET	*
      2  3cbe		       00 07	   BANK_LEVEL__056_L =	_CURRENT_BANK
      3  3cbe				   LEVEL__056_L SUBROUTINE
      4  3cbe				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3cbe
      2  3cbe		       36 2d 35 23*	      .byte.b	"6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#",0
      0  3d18					      END_LEVEL	_056_L
      1  3d18		       00 5a	   LEVEL_SIZE__056_L =	* - LEVEL_START
      2  3d18				  -	      IF	LEVEL_SIZE__056_L > MAX_LEVEL_SIZE
      3  3d18				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_L
      4  3d18					      ENDIF
      0  3d18					      DEFL	_056_R, "-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-"
      0  3d18					      START_LEVEL	_056_R
      1  3d18				   LEVEL_START SET	*
      2  3d18		       00 07	   BANK_LEVEL__056_R =	_CURRENT_BANK
      3  3d18				   LEVEL__056_R SUBROUTINE
      4  3d18				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d18
      2  3d18		       2d 34 23 2d*	      .byte.b	"-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-",0
      0  3d73					      END_LEVEL	_056_R
      1  3d73		       00 5b	   LEVEL_SIZE__056_R =	* - LEVEL_START
      2  3d73					      IF	LEVEL_SIZE__056_R > MAX_LEVEL_SIZE
      3  3d73				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_R
      4  3d73					      ENDIF
      0  3d73					      DEFL	_057_L, "5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-"
      0  3d73					      START_LEVEL	_057_L
      1  3d73				   LEVEL_START SET	*
      2  3d73		       00 07	   BANK_LEVEL__057_L =	_CURRENT_BANK
      3  3d73				   LEVEL__057_L SUBROUTINE
      4  3d73				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d73
      2  3d73		       35 2d 36 23*	      .byte.b	"5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-",0
      0  3dc9					      END_LEVEL	_057_L
      1  3dc9		       00 56	   LEVEL_SIZE__057_L =	* - LEVEL_START
      2  3dc9				  -	      IF	LEVEL_SIZE__057_L > MAX_LEVEL_SIZE
      3  3dc9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_L
      4  3dc9					      ENDIF
      0  3dc9					      DEFL	_057_R, "5#4-|#3-3#2-|#+2.2-3#|#.#*$-$-#|#.#.-#$-#|#-$2-$2-#|2#$2#3-#|-#5-2#|-7#-"
      0  3dc9					      START_LEVEL	_057_R
      1  3dc9				   LEVEL_START SET	*
      2  3dc9		       00 07	   BANK_LEVEL__057_R =	_CURRENT_BANK
      3  3dc9				   LEVEL__057_R SUBROUTINE
      4  3dc9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3dc9
      2  3dc9		       35 23 34 2d*	      .byte.b	"5#4-|#3-3#2-|#+2.2-3#|#.#*$-$-#|#.#.-#$-#|#-$2-$2-#|2#$2#3-#|-#5-2#|-7#-",0
      0  3e12					      END_LEVEL	_057_R
      1  3e12		       00 49	   LEVEL_SIZE__057_R =	* - LEVEL_START
      2  3e12				  -	      IF	LEVEL_SIZE__057_R > MAX_LEVEL_SIZE
      3  3e12				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_R
      4  3e12					      ENDIF
      0  3e12					      DEFL	_058_L, "-6#4-|-#-3.5#|-#-#.*2#2-#|2#-.*$4-#|#-2$*-$-$-#|#@2-2#4-#|7#3-#|6-5#"
      0  3e12					      START_LEVEL	_058_L
      1  3e12				   LEVEL_START SET	*
      2  3e12		       00 07	   BANK_LEVEL__058_L =	_CURRENT_BANK
      3  3e12				   LEVEL__058_L SUBROUTINE
      4  3e12				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3e12
      2  3e12		       2d 36 23 34*	      .byte.b	"-6#4-|-#-3.5#|-#-#.*2#2-#|2#-.*$4-#|#-2$*-$-$-#|#@2-2#4-#|7#3-#|6-5#",0
      0  3e57					      END_LEVEL	_058_L
      1  3e57		       00 45	   LEVEL_SIZE__058_L =	* - LEVEL_START
      2  3e57				  -	      IF	LEVEL_SIZE__058_L > MAX_LEVEL_SIZE
      3  3e57				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__058_L
      4  3e57					      ENDIF
      0  3e57					      DEFL	_058_R, "4-5#-|3-2#3-#-|4#-.#$#-|#-$2-.#-#-|#@-3*.-2#|#-$.2-*2-#|3#*$#3-#|2-#4-3#|2-6#2-"
      0  3e57					      START_LEVEL	_058_R
      1  3e57				   LEVEL_START SET	*
      2  3e57		       00 07	   BANK_LEVEL__058_R =	_CURRENT_BANK
      3  3e57				   LEVEL__058_R SUBROUTINE
      4  3e57				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3e57
      2  3e57		       34 2d 35 23*	      .byte.b	"4-5#-|3-2#3-#-|4#-.#$#-|#-$2-.#-#-|#@-3*.-2#|#-$.2-*2-#|3#*$#3-#|2-#4-3#|2-6#2-",0
      0  3ea7					      END_LEVEL	_058_R
      1  3ea7		       00 50	   LEVEL_SIZE__058_R =	* - LEVEL_START
      2  3ea7				  -	      IF	LEVEL_SIZE__058_R > MAX_LEVEL_SIZE
      3  3ea7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__058_R
      4  3ea7					      ENDIF
      0  3ea7					      DEFL	_059_L, "6#5-|#4-#5-|#-$#-5#-|#4-.-$@#-|#-#-2*-#$2#|#-$.*-$3-#|2#$#.-2#2-#|-#-3.2#2-#|-10#"
      0  3ea7					      START_LEVEL	_059_L
      1  3ea7				   LEVEL_START SET	*
      2  3ea7		       00 07	   BANK_LEVEL__059_L =	_CURRENT_BANK
      3  3ea7				   LEVEL__059_L SUBROUTINE
      4  3ea7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ea7
      2  3ea7		       36 23 35 2d*	      .byte.b	"6#5-|#4-#5-|#-$#-5#-|#4-.-$@#-|#-#-2*-#$2#|#-$.*-$3-#|2#$#.-2#2-#|-#-3.2#2-#|-10#",0
      0  3ef9					      END_LEVEL	_059_L
      1  3ef9		       00 52	   LEVEL_SIZE__059_L =	* - LEVEL_START
      2  3ef9				  -	      IF	LEVEL_SIZE__059_L > MAX_LEVEL_SIZE
      3  3ef9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__059_L
      4  3ef9					      ENDIF
      0  3ef9					      DEFL	_059_R, "7-3#-|8#.#-|#4-#-2.2#|#-#-2$*.$-#|#5-2.#-#|2#2-2#-2#-#|#2-$-2$2#-#|#3-2#3-@#|11#"
      0  3ef9					      START_LEVEL	_059_R
      1  3ef9				   LEVEL_START SET	*
      2  3ef9		       00 07	   BANK_LEVEL__059_R =	_CURRENT_BANK
      3  3ef9				   LEVEL__059_R SUBROUTINE
      4  3ef9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ef9
      2  3ef9		       37 2d 33 23*	      .byte.b	"7-3#-|8#.#-|#4-#-2.2#|#-#-2$*.$-#|#5-2.#-#|2#2-2#-2#-#|#2-$-2$2#-#|#3-2#3-@#|11#",0
      0  3f4a					      END_LEVEL	_059_R
      1  3f4a		       00 51	   LEVEL_SIZE__059_R =	* - LEVEL_START
      2  3f4a				  -	      IF	LEVEL_SIZE__059_R > MAX_LEVEL_SIZE
      3  3f4a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__059_R
      4  3f4a					      ENDIF
     66  3f4a
      0  3f4a					      CHECK_BANK_SIZE	"LEVELS4 -- full 2K"
      1  3f4a		       07 4a	   .TEMP      =	* - BANK_START
 LEVELS4 -- full 2K (2K) SIZE =  $74a , FREE= $b6
      2  3f4a					      ECHO	"LEVELS4 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3f4a				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3f4a				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3f4a				  -	      ERR
      6  3f4a					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS5.asm LEVEL 2 PASS 3
      0  3f4a					      include	"BANK_LEVELS5.asm"
      1  3f4a							;    Sokoboo - a Sokoban implementation
      2  3f4a							;    using a generic tile-based display engine for the Atari 2600
      3  3f4a							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  3f4a							;
      5  3f4a							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  3f4a							;
      7  3f4a							;    Code related to the generic tile-based display engine was developed by
      8  3f4a							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  3f4a							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  3f4a							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  3f4a							;
     12  3f4a							;    Code related to music and sound effects uses the TIATracker music player
     13  3f4a							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  3f4a							;    directory for Apache licensing details.
     15  3f4a							;
     16  3f4a							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  3f4a							;    See the copyright notices in the License directory for a list of level
     18  3f4a							;    contributors.
     19  3f4a							;
     20  3f4a							;    Except where otherwise indicated, this software is released under the
     21  3f4a							;    following licensing arrangement...
     22  3f4a							;
     23  3f4a							;    This program is free software: you can redistribute it and/or modify
     24  3f4a							;    it under the terms of the GNU General Public License as published by
     25  3f4a							;    the Free Software Foundation, either version 3 of the License, or
     26  3f4a							;    (at your option) any later version.
     27  3f4a							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  3f4a
     29  3f4a							;    This program is distributed in the hope that it will be useful,
     30  3f4a							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  3f4a							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  3f4a							;    GNU General Public License for more details.
     33  3f4a
     34  3f4a							; level definitions
     35  3f4a							; Sample level definitions.
     36  3f4a							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  3f4a							; have as many banks as you like.
     38  3f4a
      0  3f4a					      NEWBANK	LEVELS5
      1  4675 ????				      SEG	LEVELS5
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   LEVELS5    SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	LEVELS5
     40  4000
      0  4000					      DEFL	_060_R, "3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#"
      0  4000					      START_LEVEL	_060_R
      1  4000				   LEVEL_START SET	*
      2  4000		       00 08	   BANK_LEVEL__060_R =	_CURRENT_BANK
      3  4000				   LEVEL__060_R SUBROUTINE
      4  4000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4000
      2  4000		       33 2d 36 23*	      .byte.b	"3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#",0
      0  4048					      END_LEVEL	_060_R
      1  4048		       00 48	   LEVEL_SIZE__060_R =	* - LEVEL_START
      2  4048				  -	      IF	LEVEL_SIZE__060_R > MAX_LEVEL_SIZE
      3  4048				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__060_R
      4  4048					      ENDIF
      0  4048					      DEFL	_061_L, "10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#"
      0  4048					      START_LEVEL	_061_L
      1  4048				   LEVEL_START SET	*
      2  4048		       00 08	   BANK_LEVEL__061_L =	_CURRENT_BANK
      3  4048				   LEVEL__061_L SUBROUTINE
      4  4048				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4048
      2  4048		       31 30 23 2d*	      .byte.b	"10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#",0
      0  409c					      END_LEVEL	_061_L
      1  409c		       00 54	   LEVEL_SIZE__061_L =	* - LEVEL_START
      2  409c				  -	      IF	LEVEL_SIZE__061_L > MAX_LEVEL_SIZE
      3  409c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_L
      4  409c					      ENDIF
      0  409c					      DEFL	_061_R, "4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#"
      0  409c					      START_LEVEL	_061_R
      1  409c				   LEVEL_START SET	*
      2  409c		       00 08	   BANK_LEVEL__061_R =	_CURRENT_BANK
      3  409c				   LEVEL__061_R SUBROUTINE
      4  409c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  409c
      2  409c		       34 2d 35 23*	      .byte.b	"4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#",0
      0  40e5					      END_LEVEL	_061_R
      1  40e5		       00 49	   LEVEL_SIZE__061_R =	* - LEVEL_START
      2  40e5				  -	      IF	LEVEL_SIZE__061_R > MAX_LEVEL_SIZE
      3  40e5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_R
      4  40e5					      ENDIF
      0  40e5					      DEFL	_062_L, "-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#"
      0  40e5					      START_LEVEL	_062_L
      1  40e5				   LEVEL_START SET	*
      2  40e5		       00 08	   BANK_LEVEL__062_L =	_CURRENT_BANK
      3  40e5				   LEVEL__062_L SUBROUTINE
      4  40e5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  40e5
      2  40e5		       2d 35 23 36*	      .byte.b	"-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#",0
      0  413c					      END_LEVEL	_062_L
      1  413c		       00 57	   LEVEL_SIZE__062_L =	* - LEVEL_START
      2  413c				  -	      IF	LEVEL_SIZE__062_L > MAX_LEVEL_SIZE
      3  413c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_L
      4  413c					      ENDIF
      0  413c					      DEFL	_062_R, "5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-"
      0  413c					      START_LEVEL	_062_R
      1  413c				   LEVEL_START SET	*
      2  413c		       00 08	   BANK_LEVEL__062_R =	_CURRENT_BANK
      3  413c				   LEVEL__062_R SUBROUTINE
      4  413c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  413c
      2  413c		       35 2d 35 23*	      .byte.b	"5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-",0
      0  4188					      END_LEVEL	_062_R
      1  4188		       00 4c	   LEVEL_SIZE__062_R =	* - LEVEL_START
      2  4188				  -	      IF	LEVEL_SIZE__062_R > MAX_LEVEL_SIZE
      3  4188				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_R
      4  4188					      ENDIF
      0  4188					      DEFL	_063_L, "2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#"
      0  4188					      START_LEVEL	_063_L
      1  4188				   LEVEL_START SET	*
      2  4188		       00 08	   BANK_LEVEL__063_L =	_CURRENT_BANK
      3  4188				   LEVEL__063_L SUBROUTINE
      4  4188				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4188
      2  4188		       32 2d 35 23*	      .byte.b	"2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#",0
      0  41d8					      END_LEVEL	_063_L
      1  41d8		       00 50	   LEVEL_SIZE__063_L =	* - LEVEL_START
      2  41d8				  -	      IF	LEVEL_SIZE__063_L > MAX_LEVEL_SIZE
      3  41d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_L
      4  41d8					      ENDIF
      0  41d8					      DEFL	_063_R, "2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-"
      0  41d8					      START_LEVEL	_063_R
      1  41d8				   LEVEL_START SET	*
      2  41d8		       00 08	   BANK_LEVEL__063_R =	_CURRENT_BANK
      3  41d8				   LEVEL__063_R SUBROUTINE
      4  41d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  41d8
      2  41d8		       32 2d 36 23*	      .byte.b	"2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-",0
      0  422a					      END_LEVEL	_063_R
      1  422a		       00 52	   LEVEL_SIZE__063_R =	* - LEVEL_START
      2  422a				  -	      IF	LEVEL_SIZE__063_R > MAX_LEVEL_SIZE
      3  422a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_R
      4  422a					      ENDIF
      0  422a					      DEFL	_064_L, "-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-"
      0  422a					      START_LEVEL	_064_L
      1  422a				   LEVEL_START SET	*
      2  422a		       00 08	   BANK_LEVEL__064_L =	_CURRENT_BANK
      3  422a				   LEVEL__064_L SUBROUTINE
      4  422a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  422a
      2  422a		       2d 38 23 33*	      .byte.b	"-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-",0
      0  4285					      END_LEVEL	_064_L
      1  4285		       00 5b	   LEVEL_SIZE__064_L =	* - LEVEL_START
      2  4285				  -	      IF	LEVEL_SIZE__064_L > MAX_LEVEL_SIZE
      3  4285				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_L
      4  4285					      ENDIF
      0  4285					      DEFL	_064_R, "4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-"
      0  4285					      START_LEVEL	_064_R
      1  4285				   LEVEL_START SET	*
      2  4285		       00 08	   BANK_LEVEL__064_R =	_CURRENT_BANK
      3  4285				   LEVEL__064_R SUBROUTINE
      4  4285				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4285
      2  4285		       34 23 2d 36*	      .byte.b	"4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-",0
      0  42d1					      END_LEVEL	_064_R
      1  42d1		       00 4c	   LEVEL_SIZE__064_R =	* - LEVEL_START
      2  42d1				  -	      IF	LEVEL_SIZE__064_R > MAX_LEVEL_SIZE
      3  42d1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_R
      4  42d1					      ENDIF
      0  42d1					      DEFL	_065_L, "2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-"
      0  42d1					      START_LEVEL	_065_L
      1  42d1				   LEVEL_START SET	*
      2  42d1		       00 08	   BANK_LEVEL__065_L =	_CURRENT_BANK
      3  42d1				   LEVEL__065_L SUBROUTINE
      4  42d1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  42d1
      2  42d1		       32 2d 35 23*	      .byte.b	"2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-",0
      0  4329					      END_LEVEL	_065_L
      1  4329		       00 58	   LEVEL_SIZE__065_L =	* - LEVEL_START
      2  4329				  -	      IF	LEVEL_SIZE__065_L > MAX_LEVEL_SIZE
      3  4329				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_L
      4  4329					      ENDIF
      0  4329					      DEFL	_065_R, "3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#"
      0  4329					      START_LEVEL	_065_R
      1  4329				   LEVEL_START SET	*
      2  4329		       00 08	   BANK_LEVEL__065_R =	_CURRENT_BANK
      3  4329				   LEVEL__065_R SUBROUTINE
      4  4329				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4329
      2  4329		       33 2d 35 23*	      .byte.b	"3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#",0
      0  4371					      END_LEVEL	_065_R
      1  4371		       00 48	   LEVEL_SIZE__065_R =	* - LEVEL_START
      2  4371				  -	      IF	LEVEL_SIZE__065_R > MAX_LEVEL_SIZE
      3  4371				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_R
      4  4371					      ENDIF
      0  4371					      DEFL	_066_L, "10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-"
      0  4371					      START_LEVEL	_066_L
      1  4371				   LEVEL_START SET	*
      2  4371		       00 08	   BANK_LEVEL__066_L =	_CURRENT_BANK
      3  4371				   LEVEL__066_L SUBROUTINE
      4  4371				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4371
      2  4371		       31 30 23 33*	      .byte.b	"10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-",0
      0  43cb					      END_LEVEL	_066_L
      1  43cb		       00 5a	   LEVEL_SIZE__066_L =	* - LEVEL_START
      2  43cb				  -	      IF	LEVEL_SIZE__066_L > MAX_LEVEL_SIZE
      3  43cb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_L
      4  43cb					      ENDIF
      0  43cb					      DEFL	_066_R, "2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#"
      0  43cb					      START_LEVEL	_066_R
      1  43cb				   LEVEL_START SET	*
      2  43cb		       00 08	   BANK_LEVEL__066_R =	_CURRENT_BANK
      3  43cb				   LEVEL__066_R SUBROUTINE
      4  43cb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  43cb
      2  43cb		       32 2d 35 23*	      .byte.b	"2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#",0
      0  4421					      END_LEVEL	_066_R
      1  4421		       00 56	   LEVEL_SIZE__066_R =	* - LEVEL_START
      2  4421				  -	      IF	LEVEL_SIZE__066_R > MAX_LEVEL_SIZE
      3  4421				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_R
      4  4421					      ENDIF
      0  4421					      DEFL	_067_L, "8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#"
      0  4421					      START_LEVEL	_067_L
      1  4421				   LEVEL_START SET	*
      2  4421		       00 08	   BANK_LEVEL__067_L =	_CURRENT_BANK
      3  4421				   LEVEL__067_L SUBROUTINE
      4  4421				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4421
      2  4421		       38 23 33 2d*	      .byte.b	"8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#",0
      0  446e					      END_LEVEL	_067_L
      1  446e		       00 4d	   LEVEL_SIZE__067_L =	* - LEVEL_START
      2  446e				  -	      IF	LEVEL_SIZE__067_L > MAX_LEVEL_SIZE
      3  446e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_L
      4  446e					      ENDIF
      0  446e					      DEFL	_067_R, "7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-"
      0  446e					      START_LEVEL	_067_R
      1  446e				   LEVEL_START SET	*
      2  446e		       00 08	   BANK_LEVEL__067_R =	_CURRENT_BANK
      3  446e				   LEVEL__067_R SUBROUTINE
      4  446e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  446e
      2  446e		       37 23 32 2d*	      .byte.b	"7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-",0
      0  44d3					      END_LEVEL	_067_R
      1  44d3		       00 65	   LEVEL_SIZE__067_R =	* - LEVEL_START
      2  44d3					      IF	LEVEL_SIZE__067_R > MAX_LEVEL_SIZE
      3  44d3				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_R
      4  44d3					      ENDIF
      0  44d3					      DEFL	_068_L, "10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-"
      0  44d3					      START_LEVEL	_068_L
      1  44d3				   LEVEL_START SET	*
      2  44d3		       00 08	   BANK_LEVEL__068_L =	_CURRENT_BANK
      3  44d3				   LEVEL__068_L SUBROUTINE
      4  44d3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  44d3
      2  44d3		       31 30 23 7c*	      .byte.b	"10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-",0
      0  4527					      END_LEVEL	_068_L
      1  4527		       00 54	   LEVEL_SIZE__068_L =	* - LEVEL_START
      2  4527				  -	      IF	LEVEL_SIZE__068_L > MAX_LEVEL_SIZE
      3  4527				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_L
      4  4527					      ENDIF
      0  4527					      DEFL	_068_R, "5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-"
      0  4527					      START_LEVEL	_068_R
      1  4527				   LEVEL_START SET	*
      2  4527		       00 08	   BANK_LEVEL__068_R =	_CURRENT_BANK
      3  4527				   LEVEL__068_R SUBROUTINE
      4  4527				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4527
      2  4527		       35 2d 35 23*	      .byte.b	"5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-",0
      0  457d					      END_LEVEL	_068_R
      1  457d		       00 56	   LEVEL_SIZE__068_R =	* - LEVEL_START
      2  457d				  -	      IF	LEVEL_SIZE__068_R > MAX_LEVEL_SIZE
      3  457d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_R
      4  457d					      ENDIF
      0  457d					      DEFL	_069_L, "-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#"
      0  457d					      START_LEVEL	_069_L
      1  457d				   LEVEL_START SET	*
      2  457d		       00 08	   BANK_LEVEL__069_L =	_CURRENT_BANK
      3  457d				   LEVEL__069_L SUBROUTINE
      4  457d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  457d
      2  457d		       2d 36 23 33*	      .byte.b	"-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#",0
      0  45cb					      END_LEVEL	_069_L
      1  45cb		       00 4e	   LEVEL_SIZE__069_L =	* - LEVEL_START
      2  45cb				  -	      IF	LEVEL_SIZE__069_L > MAX_LEVEL_SIZE
      3  45cb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_L
      4  45cb					      ENDIF
      0  45cb					      DEFL	_069_R, "2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-"
      0  45cb					      START_LEVEL	_069_R
      1  45cb				   LEVEL_START SET	*
      2  45cb		       00 08	   BANK_LEVEL__069_R =	_CURRENT_BANK
      3  45cb				   LEVEL__069_R SUBROUTINE
      4  45cb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  45cb
      2  45cb		       32 2d 35 23*	      .byte.b	"2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-",0
      0  4619					      END_LEVEL	_069_R
      1  4619		       00 4e	   LEVEL_SIZE__069_R =	* - LEVEL_START
      2  4619				  -	      IF	LEVEL_SIZE__069_R > MAX_LEVEL_SIZE
      3  4619				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_R
      4  4619					      ENDIF
     60  4619
      0  4619					      DEFL	_122_Maya, "14#|4#3-3#2-2#|#-$-$2-2#3-2#|#.2-$4#$2-2#|#.*2-$3-$-3#|#*.#$*.$-#2$-#|#6.*-#-@-#|2#4-8#|14#"
      0  4619					      START_LEVEL	_122_Maya
      1  4619				   LEVEL_START SET	*
      2  4619		       00 08	   BANK_LEVEL__122_Maya =	_CURRENT_BANK
      3  4619				   LEVEL__122_Maya SUBROUTINE
      4  4619				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4619
      2  4619		       31 34 23 7c*	      .byte.b	"14#|4#3-3#2-2#|#-$-$2-2#3-2#|#.2-$4#$2-2#|#.*2-$3-$-3#|#*.#$*.$-#2$-#|#6.*-#-@-#|2#4-8#|14#",0
      0  4675					      END_LEVEL	_122_Maya
      1  4675		       00 5c	   LEVEL_SIZE__122_Maya =	* - LEVEL_START
      2  4675				  -	      IF	LEVEL_SIZE__122_Maya > MAX_LEVEL_SIZE
      3  4675				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__122_Maya
      4  4675					      ENDIF
     62  4675
      0  4675					      CHECK_BANK_SIZE	"LEVELS5 -- full 2K"
      1  4675		       06 75	   .TEMP      =	* - BANK_START
 LEVELS5 -- full 2K (2K) SIZE =  $675 , FREE= $18b
      2  4675					      ECHO	"LEVELS5 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4675				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4675				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4675				  -	      ERR
      6  4675					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS6.asm LEVEL 2 PASS 3
      0  4675					      include	"BANK_LEVELS6.asm"
      1  4675							;    Sokoboo - a Sokoban implementation
      2  4675							;    using a generic tile-based display engine for the Atari 2600
      3  4675							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  4675							;
      5  4675							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  4675							;
      7  4675							;    Code related to the generic tile-based display engine was developed by
      8  4675							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  4675							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  4675							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  4675							;
     12  4675							;    Code related to music and sound effects uses the TIATracker music player
     13  4675							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  4675							;    directory for Apache licensing details.
     15  4675							;
     16  4675							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  4675							;    See the copyright notices in the License directory for a list of level
     18  4675							;    contributors.
     19  4675							;
     20  4675							;    Except where otherwise indicated, this software is released under the
     21  4675							;    following licensing arrangement...
     22  4675							;
     23  4675							;    This program is free software: you can redistribute it and/or modify
     24  4675							;    it under the terms of the GNU General Public License as published by
     25  4675							;    the Free Software Foundation, either version 3 of the License, or
     26  4675							;    (at your option) any later version.
     27  4675							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  4675
     29  4675							;    This program is distributed in the hope that it will be useful,
     30  4675							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  4675							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  4675							;    GNU General Public License for more details.
     33  4675
     34  4675							; level definitions
     35  4675							; Sample level definitions.
     36  4675							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  4675							; have as many banks as you like.
     38  4675
      0  4675					      NEWBANK	LEVELS6
      1  4d9f ????				      SEG	LEVELS6
      2  4800					      ORG	ORIGIN
      3  4800					      RORG	$F000
      4  4800				   BANK_START SET	*
      5  4800				   LEVELS6    SET	ORIGIN / 2048
      6  4800				   ORIGIN     SET	ORIGIN + 2048
      7  4800				   _CURRENT_BANK SET	LEVELS6
     40  4800
     41  4800
     42  4800							; Level definitions
     43  4800
     44  4800							; "sokhard" collection
     45  4800
      0  4800					      START_LEVEL	_102_Natalie
      1  4800				   LEVEL_START SET	*
      2  4800		       00 09	   BANK_LEVEL__102_Natalie =	_CURRENT_BANK
      3  4800				   LEVEL__102_Natalie SUBROUTINE
      4  4800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4800
     47  4800		       31 31 23 7c*	      .byte.b	"11#|2#2-#@4.#|2#3-2$.2*#|2#-$2-2$#.#|#2-$#-#2-.#|#2-$-#-2#-#|#9-#|11#",0
      0  4846					      END_LEVEL	_102_Natalie
      1  4846		       00 46	   LEVEL_SIZE__102_Natalie =	* - LEVEL_START
      2  4846				  -	      IF	LEVEL_SIZE__102_Natalie > MAX_LEVEL_SIZE
      3  4846				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Natalie
      4  4846					      ENDIF
     49  4846
      0  4846					      START_LEVEL	_102_Mirabel
      1  4846				   LEVEL_START SET	*
      2  4846		       00 09	   BANK_LEVEL__102_Mirabel =	_CURRENT_BANK
      3  4846				   LEVEL__102_Mirabel SUBROUTINE
      4  4846				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4846
     51  4846		       31 31 23 7c*	      .byte.b	"11#|6#3-2#|2#2-2#$2-2#|2#2-#-2$-2#|#7-3#|#.-#$-#-3#|#.#.-#2-$-#|#3.#-2$#@#|#-2.4-$-#|#2-8#|11#",0
      0  48a5					      END_LEVEL	_102_Mirabel
      1  48a5		       00 5f	   LEVEL_SIZE__102_Mirabel =	* - LEVEL_START
      2  48a5				  -	      IF	LEVEL_SIZE__102_Mirabel > MAX_LEVEL_SIZE
      3  48a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Mirabel
      4  48a5					      ENDIF
     53  48a5
      0  48a5					      START_LEVEL	_102_Oralia
      1  48a5				   LEVEL_START SET	*
      2  48a5		       00 09	   BANK_LEVEL__102_Oralia =	_CURRENT_BANK
      3  48a5				   LEVEL__102_Oralia SUBROUTINE
      4  48a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  48a5
     55  48a5		       39 23 7c 23*	      .byte.b	"9#|#2.$.#2-#|#4.2*-#|#-$.2#2-#|2#-$2-$-#|4#$-$-#|#-$3-$-#|#5-#@#|9#",0
      0  48e9					      END_LEVEL	_102_Oralia
      1  48e9		       00 44	   LEVEL_SIZE__102_Oralia =	* - LEVEL_START
      2  48e9				  -	      IF	LEVEL_SIZE__102_Oralia > MAX_LEVEL_SIZE
      3  48e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Oralia
      4  48e9					      ENDIF
     57  48e9
     58  48e9
     59  48e9							;---------------------------------------------------------------------------------------------------
     60  48e9							; IMAGE IS ABOVE DEFINITION
     61  48e9
     62  48e9							;  ###########
     63  48e9							;  #  #      #
     64  48e9							;  # $# $ $$ #
     65  48e9							;  #  ##$#$  #
     66  48e9							;  #  $    #@#
     67  48e9							;  # $## #  ##
     68  48e9							;  ##	# .## #
     69  48e9							;  ##$ #.*. ##
     70  48e9							;  # ..*. *. #
     71  48e9							;  # # .. #  #
     72  48e9							;  ###########
     73  48e9
      0  48e9					      START_LEVEL	_102_Raven
      1  48e9				   LEVEL_START SET	*
      2  48e9		       00 09	   BANK_LEVEL__102_Raven =	_CURRENT_BANK
      3  48e9				   LEVEL__102_Raven SUBROUTINE
      4  48e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  48e9
     75  48e9		       31 31 23 7c*	      .byte.b	"11#|#2-#6-#|#-$#-$-2$-#|#2-2#$#$2-#|#2-$4-#@#|#-$2#-#2-2#|2#2-#-.2#-#|2#$-#.*.-2#|#-2.*.-*.-#|#-#-2.-#2-#|11#",0
      0  4957					      END_LEVEL	_102_Raven
      1  4957		       00 6e	   LEVEL_SIZE__102_Raven =	* - LEVEL_START
      2  4957					      IF	LEVEL_SIZE__102_Raven > MAX_LEVEL_SIZE
      3  4957				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Raven
      4  4957					      ENDIF
     77  4957
     78  4957							;  ############
     79  4957							;  #@##. #  # #
     80  4957							;  #**..$#    #
     81  4957							;  #. $..#  # #
     82  4957							;  # $#.$#$$$ #
     83  4957							;  #	      ##
     84  4957							;  #  ##  #   #
     85  4957							;  ############
     86  4957
      0  4957					      START_LEVEL	_103_Adin
      1  4957				   LEVEL_START SET	*
      2  4957		       00 09	   BANK_LEVEL__103_Adin =	_CURRENT_BANK
      3  4957				   LEVEL__103_Adin SUBROUTINE
      4  4957				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4957
     88  4957		       31 32 23 7c*	      .byte.b	"12#|#@2#.-#2-#-#|#2*2.$#4-#|#.-$2.#2-#-#|#-$#.$#3$-#|#9-2#|#2-2#2-#3-#|12#",0
      0  49a2					      END_LEVEL	_103_Adin
      1  49a2		       00 4b	   LEVEL_SIZE__103_Adin =	* - LEVEL_START
      2  49a2				  -	      IF	LEVEL_SIZE__103_Adin > MAX_LEVEL_SIZE
      3  49a2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Adin
      4  49a2					      ENDIF
     90  49a2
     91  49a2							;  #######___
     92  49a2							;  #	  #___
     93  49a2							;  #	$$#___
     94  49a2							;  #.*  .#___
     95  49a2							;  #$*$#*###_
     96  49a2							;  #@*... .#_
     97  49a2							;  #####$ .##
     98  49a2							;  ___# $ $ #
     99  49a2							;  ___#     #
    100  49a2							;  ___#######	(_ = modified by boo from wall)
    101  49a2
      0  49a2					      START_LEVEL	_103_Ajalae
      1  49a2				   LEVEL_START SET	*
      2  49a2		       00 09	   BANK_LEVEL__103_Ajalae =	_CURRENT_BANK
      3  49a2				   LEVEL__103_Ajalae SUBROUTINE
      4  49a2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  49a2
    103  49a2		       37 23 7c 23*	      .byte.b	"7#|#5-#|#3-2$#|#.*2-.#|#$*$#*3#|#@*3.-.#|5#$-.2#|3-#-$-$-#|3-#5-#|3-7#",0
      0  49e9					      END_LEVEL	_103_Ajalae
      1  49e9		       00 47	   LEVEL_SIZE__103_Ajalae =	* - LEVEL_START
      2  49e9				  -	      IF	LEVEL_SIZE__103_Ajalae > MAX_LEVEL_SIZE
      3  49e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Ajalae
      4  49e9					      ENDIF
    105  49e9
    106  49e9							;  ############
    107  49e9							;  #@#  #     #
    108  49e9							;  #  # #$#$# #
    109  49e9							;  # *$       #
    110  49e9							;  #..##$#$   #
    111  49e9							;  #..#. #  $ #
    112  49e9							;  #....# $$$##
    113  49e9							;  #	       #
    114  49e9							;  ############
    115  49e9
      0  49e9					      START_LEVEL	_103_Arielle
      1  49e9				   LEVEL_START SET	*
      2  49e9		       00 09	   BANK_LEVEL__103_Arielle =	_CURRENT_BANK
      3  49e9				   LEVEL__103_Arielle SUBROUTINE
      4  49e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  49e9
    117  49e9		       31 32 23 7c*	      .byte.b	"12#|#@#2-#5-#|#2-#-#$#$#-#|#-*$7-#|#2.2#$#$3-#|#2.#.-#2-$-#|#4.#-3$2#|#10-#|12#",0
      0  4a39					      END_LEVEL	_103_Arielle
      1  4a39		       00 50	   LEVEL_SIZE__103_Arielle =	* - LEVEL_START
      2  4a39				  -	      IF	LEVEL_SIZE__103_Arielle > MAX_LEVEL_SIZE
      3  4a39				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Arielle
      4  4a39					      ENDIF
    119  4a39
    120  4a39
    121  4a39
      0  4a39					      START_LEVEL	_1XJH_Tara_Gelson
      1  4a39				   LEVEL_START SET	*
      2  4a39		       00 09	   BANK_LEVEL__1XJH_Tara_Gelson =	_CURRENT_BANK
      3  4a39				   LEVEL__1XJH_Tara_Gelson SUBROUTINE
      4  4a39				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4a39
    123  4a39		       38 23 7c 23*	      .byte.b	"8#|#2-#2-*#|#2-*-*-#|#-*$-$-#|#2-.#.-#|#3-#-*#|2#-@3-#|8#",0
      0  4a73					      END_LEVEL	_1XJH_Tara_Gelson
      1  4a73		       00 3a	   LEVEL_SIZE__1XJH_Tara_Gelson =	* - LEVEL_START
      2  4a73				  -	      IF	LEVEL_SIZE__1XJH_Tara_Gelson > MAX_LEVEL_SIZE
      3  4a73				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1XJH_Tara_Gelson
      4  4a73					      ENDIF
    125  4a73
      0  4a73					      START_LEVEL	_1R7X_Alison
      1  4a73				   LEVEL_START SET	*
      2  4a73		       00 09	   BANK_LEVEL__1R7X_Alison =	_CURRENT_BANK
      3  4a73				   LEVEL__1R7X_Alison SUBROUTINE
      4  4a73				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4a73
    127  4a73		       37 23 7c 23*	      .byte.b	"7#|#2-.2-#|#-$*2$#|#-2.$.#|#@*-$-#|2#.3-#|7#",0
      0  4aa0					      END_LEVEL	_1R7X_Alison
      1  4aa0		       00 2d	   LEVEL_SIZE__1R7X_Alison =	* - LEVEL_START
      2  4aa0				  -	      IF	LEVEL_SIZE__1R7X_Alison > MAX_LEVEL_SIZE
      3  4aa0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1R7X_Alison
      4  4aa0					      ENDIF
    129  4aa0
      0  4aa0					      START_LEVEL	_1KWD_Cecile_Clayworth
      1  4aa0				   LEVEL_START SET	*
      2  4aa0		       00 09	   BANK_LEVEL__1KWD_Cecile_Clayworth =	_CURRENT_BANK
      3  4aa0				   LEVEL__1KWD_Cecile_Clayworth SUBROUTINE
      4  4aa0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4aa0
    131  4aa0		       38 23 7c 33*	      .byte.b	"8#|3#.2-.#|#-$4-#|#-*2#2$#|#3-$-+#|#-*.-*-#|#6-#|8#",0
      0  4ad4					      END_LEVEL	_1KWD_Cecile_Clayworth
      1  4ad4		       00 34	   LEVEL_SIZE__1KWD_Cecile_Clayworth =	* - LEVEL_START
      2  4ad4				  -	      IF	LEVEL_SIZE__1KWD_Cecile_Clayworth > MAX_LEVEL_SIZE
      3  4ad4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1KWD_Cecile_Clayworth
      4  4ad4					      ENDIF
    133  4ad4
      0  4ad4					      START_LEVEL	_1EKT_Samantha_Gelson
      1  4ad4				   LEVEL_START SET	*
      2  4ad4		       00 09	   BANK_LEVEL__1EKT_Samantha_Gelson =	_CURRENT_BANK
      3  4ad4				   LEVEL__1EKT_Samantha_Gelson SUBROUTINE
      4  4ad4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4ad4
    135  4ad4		       38 23 7c 23*	      .byte.b	"8#|#-*3-.#|#2-$-*-#|#-.$-$-#|#*-*2-*#|#.#-#2-#|#4-@-#|8#",0
      0  4b0d					      END_LEVEL	_1EKT_Samantha_Gelson
      1  4b0d		       00 39	   LEVEL_SIZE__1EKT_Samantha_Gelson =	* - LEVEL_START
      2  4b0d				  -	      IF	LEVEL_SIZE__1EKT_Samantha_Gelson > MAX_LEVEL_SIZE
      3  4b0d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1EKT_Samantha_Gelson
      4  4b0d					      ENDIF
    137  4b0d
      0  4b0d					      START_LEVEL	_0VM5_Andrea_Wadd
      1  4b0d				   LEVEL_START SET	*
      2  4b0d		       00 09	   BANK_LEVEL__0VM5_Andrea_Wadd =	_CURRENT_BANK
      3  4b0d				   LEVEL__0VM5_Andrea_Wadd SUBROUTINE
      4  4b0d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b0d
    139  4b0d		       37 23 7c 23*	      .byte.b	"7#|#3-#-#|#-$*2-#|#-.-+-#|#-*2$-#|2#2-.-#|7#",0
      0  4b3a					      END_LEVEL	_0VM5_Andrea_Wadd
      1  4b3a		       00 2d	   LEVEL_SIZE__0VM5_Andrea_Wadd =	* - LEVEL_START
      2  4b3a				  -	      IF	LEVEL_SIZE__0VM5_Andrea_Wadd > MAX_LEVEL_SIZE
      3  4b3a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0VM5_Andrea_Wadd
      4  4b3a					      ENDIF
    141  4b3a
      0  4b3a					      START_LEVEL	_0PAL_Jill_Leatherby
      1  4b3a				   LEVEL_START SET	*
      2  4b3a		       00 09	   BANK_LEVEL__0PAL_Jill_Leatherby =	_CURRENT_BANK
      3  4b3a				   LEVEL__0PAL_Jill_Leatherby SUBROUTINE
      4  4b3a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b3a
    143  4b3a		       37 23 7c 23*	      .byte.b	"7#|#3-3#|#2-2*-#|#3-$-#|#2-$2.#|3#@2-#|7#",0
      0  4b64					      END_LEVEL	_0PAL_Jill_Leatherby
      1  4b64		       00 2a	   LEVEL_SIZE__0PAL_Jill_Leatherby =	* - LEVEL_START
      2  4b64				  -	      IF	LEVEL_SIZE__0PAL_Jill_Leatherby > MAX_LEVEL_SIZE
      3  4b64				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0PAL_Jill_Leatherby
      4  4b64					      ENDIF
    145  4b64
      0  4b64					      START_LEVEL	_0IZ1_Sophia
      1  4b64				   LEVEL_START SET	*
      2  4b64		       00 09	   BANK_LEVEL__0IZ1_Sophia =	_CURRENT_BANK
      3  4b64				   LEVEL__0IZ1_Sophia SUBROUTINE
      4  4b64				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b64
    147  4b64		       37 23 7c 23*	      .byte.b	"7#|#5-#|#@$.#-#|#*$2-.#|#-2$2-#|#-.-.-#|7#",0
      0  4b8f					      END_LEVEL	_0IZ1_Sophia
      1  4b8f		       00 2b	   LEVEL_SIZE__0IZ1_Sophia =	* - LEVEL_START
      2  4b8f				  -	      IF	LEVEL_SIZE__0IZ1_Sophia > MAX_LEVEL_SIZE
      3  4b8f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0IZ1_Sophia
      4  4b8f					      ENDIF
    149  4b8f
      0  4b8f					      START_LEVEL	_0CNH_Alice
      1  4b8f				   LEVEL_START SET	*
      2  4b8f		       00 09	   BANK_LEVEL__0CNH_Alice =	_CURRENT_BANK
      3  4b8f				   LEVEL__0CNH_Alice SUBROUTINE
      4  4b8f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b8f
    151  4b8f		       37 23 7c 23*	      .byte.b	"7#|#.4-#|#$*-#-#|#.2-$*#|#-.$2-#|#@-*2-#|7#",0
      0  4bbb					      END_LEVEL	_0CNH_Alice
      1  4bbb		       00 2c	   LEVEL_SIZE__0CNH_Alice =	* - LEVEL_START
      2  4bbb				  -	      IF	LEVEL_SIZE__0CNH_Alice > MAX_LEVEL_SIZE
      3  4bbb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0CNH_Alice
      4  4bbb					      ENDIF
    153  4bbb
    154  4bbb							;  START_LEVEL TowC
    155  4bbb							;   .byte "4-5#|4-#3-#|4-#$2-#|2-3#2-$2#|2-#2-$-$-#|3#-#-2#-#3-6#|#3-#-2#-5#2-2.#|#-$2-$10-2.#|5#-3#-#@2#2-2.#|4-#5-9#|4-7#",0
    156  4bbb							;  END_LEVEL TowC
    157  4bbb
    158  4bbb							;  START_LEVEL SimpleC
    159  4bbb							;  .byte "7#|#.@-#-#|#$*-$-#|#3-$-#|#-..--#|#--*--#|7#",0
    160  4bbb							;  END_LEVEL SimpleC
    161  4bbb
      0  4bbb					      START_LEVEL	bAlfa_DrFogh
      1  4bbb				   LEVEL_START SET	*
      2  4bbb		       00 09	   BANK_LEVEL_bAlfa_DrFogh =	_CURRENT_BANK
      3  4bbb				   LEVEL_bAlfa_DrFogh SUBROUTINE
      4  4bbb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4bbb
    163  4bbb		       32 2d 34 23*	      .byte.b	"2-4#2-4#|-2#2-2#-#2-#|-#4-3#2-2#|2#2-2*2-#.2-2#|#2-*2-*-#*#2-#|#-*4-2*2-#-#|#-*-2#-*3-#-#|2#-*2-*#*#-#-#|-#$-2*-#-*-#-#|-#@#2-2#5-#|-2#2-4#2-3#|2-#2-#2-4#|2-#2-#|2-4#",0
      0  4c62					      END_LEVEL	bAlfa_DrFogh
      1  4c62		       00 a7	   LEVEL_SIZE_bAlfa_DrFogh =	* - LEVEL_START
      2  4c62					      IF	LEVEL_SIZE_bAlfa_DrFogh > MAX_LEVEL_SIZE
      3  4c62				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAlfa_DrFogh
      4  4c62					      ENDIF
    165  4c62
      0  4c62					      START_LEVEL	b51X_Sharpen
      1  4c62				   LEVEL_START SET	*
      2  4c62		       00 09	   BANK_LEVEL_b51X_Sharpen =	_CURRENT_BANK
      3  4c62				   LEVEL_b51X_Sharpen SUBROUTINE
      4  4c62				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4c62
    167  4c62		       2d 39 23 33*	      .byte.b	"-9#3-|-#7-#3-|-#-$-2$-$#3-|3#$#2-$-#3-|#.#3-2$-2#2-|#.3#3-$-#2-|#.#.-$-2#-3#|#3.$-$2#-$-#|#3.$3-$2-@#|#2.3#$3#-2#|#4.#5-#-|12#-",0
      0  4ce2					      END_LEVEL	b51X_Sharpen
      1  4ce2		       00 80	   LEVEL_SIZE_b51X_Sharpen =	* - LEVEL_START
      2  4ce2				  -	      IF	LEVEL_SIZE_b51X_Sharpen > MAX_LEVEL_SIZE
      3  4ce2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_b51X_Sharpen
      4  4ce2					      ENDIF
    169  4ce2
      0  4ce2					      START_LEVEL	bDarcy_Burnsell101
      1  4ce2				   LEVEL_START SET	*
      2  4ce2		       00 09	   BANK_LEVEL_bDarcy_Burnsell101 =	_CURRENT_BANK
      3  4ce2				   LEVEL_bDarcy_Burnsell101 SUBROUTINE
      4  4ce2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4ce2
    171  4ce2		       38 23 7c 23*	      .byte.b	"8#|#2-.-$@#|#.#$*2$#|#2-.-*-#|#2$-2$.#|#.#-#2-#|#.2-.-.#|8#",0
      0  4d1e					      END_LEVEL	bDarcy_Burnsell101
      1  4d1e		       00 3c	   LEVEL_SIZE_bDarcy_Burnsell101 =	* - LEVEL_START
      2  4d1e				  -	      IF	LEVEL_SIZE_bDarcy_Burnsell101 > MAX_LEVEL_SIZE
      3  4d1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bDarcy_Burnsell101
      4  4d1e					      ENDIF
    173  4d1e
      0  4d1e					      START_LEVEL	bAislin101
      1  4d1e				   LEVEL_START SET	*
      2  4d1e		       00 09	   BANK_LEVEL_bAislin101 =	_CURRENT_BANK
      3  4d1e				   LEVEL_bAislin101 SUBROUTINE
      4  4d1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4d1e
    175  4d1e		       38 23 7c 32*	      .byte.b	"8#|2#-*-*.#|#2.$-$*#|#-.#-*.#|2#-$-$2#|#-#$-$-#|#2.2-$@#|8#",0
      0  4d5a					      END_LEVEL	bAislin101
      1  4d5a		       00 3c	   LEVEL_SIZE_bAislin101 =	* - LEVEL_START
      2  4d5a				  -	      IF	LEVEL_SIZE_bAislin101 > MAX_LEVEL_SIZE
      3  4d5a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAislin101
      4  4d5a					      ENDIF
    177  4d5a
    178  4d5a							;  START_LEVEL b82X_Sharpen
    179  4d5a							;  .byte "-11#8-|-#5-#3-2#7-|-#-$-$-$-#2-5#3-|-3#2-5#5-#3-|-#4.#5-3#-#3-|-#.4#2-4#3-#3-|-#4.4-#2-$-2#3-|-#-3.#3-#-3$5#|3#.7#2-$@$3-#|#-$3-5#-$-2#3-#|#-#.#-$6-$3#$-#|#-#.8#2-#2-$-#|#-#3.7-2#-2$-#|#3-7#-$-#-#2-#|5#5-#7-2#|10-9#-",0
    180  4d5a							;  END_LEVEL b82X_Sharpen
    181  4d5a
      0  4d5a					      START_LEVEL	Thomas_Reinke16
      1  4d5a				   LEVEL_START SET	*
      2  4d5a		       00 09	   BANK_LEVEL_Thomas_Reinke16 =	_CURRENT_BANK
      3  4d5a				   LEVEL_Thomas_Reinke16 SUBROUTINE
      4  4d5a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4d5a
    183  4d5a		       2d 35 23 7c*	      .byte.b	"-5#|2#3-3#|#6-2#|#-#-2#2-#|#2.*2-#-#|#2-*2-#-#|3#*2$2-#|2-#@-4#|2-4#",0
      0  4d9f					      END_LEVEL	Thomas_Reinke16
      1  4d9f		       00 45	   LEVEL_SIZE_Thomas_Reinke16 =	* - LEVEL_START
      2  4d9f				  -	      IF	LEVEL_SIZE_Thomas_Reinke16 > MAX_LEVEL_SIZE
      3  4d9f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_Thomas_Reinke16
      4  4d9f					      ENDIF
    185  4d9f
    186  4d9f							;Level element	Character	ASCII Code
    187  4d9f							;Wall	#	0x23
    188  4d9f							;Player	@	0x40
    189  4d9f							;Player on goal square	+	0x2b
    190  4d9f							;Box	$	0x24
    191  4d9f							;Box on goal square	*	0x2a
    192  4d9f							;Goal square	.	0x2e
    193  4d9f							;Floor	(Space)	0x20 or underscore
    194  4d9f
    195  4d9f							;This level ("Claire", by Lee J Haywood):
    196  4d9f
    197  4d9f							;#######
    198  4d9f							;#.@ # #
    199  4d9f							;#$* $ #
    200  4d9f							;#   $ #
    201  4d9f							;# ..	#
    202  4d9f							;#  *	#
    203  4d9f							;#######
    204  4d9f							;runlength encoded looks like this:
    205  4d9f
    206  4d9f							;The rows of the level are separated by "|"s. There has been a discussion in the Yahoo Group about what character should represent an empty square in May 2006. Finally the hyphen has been elected to be the standard character for an empty square. Nevertheless, programs are encouraged to support both, hyphens and underscores.
    207  4d9f
    208  4d9f							;If only two level elements are grouped together they may be run length encoded, but needn't to. Example:
    209  4d9f
    210  4d9f
      0  4d9f					      CHECK_BANK_SIZE	"LEVELS6 -- full 2K"
      1  4d9f		       05 9f	   .TEMP      =	* - BANK_START
 LEVELS6 -- full 2K (2K) SIZE =  $59f , FREE= $261
      2  4d9f					      ECHO	"LEVELS6 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4d9f				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4d9f				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4d9f				  -	      ERR
      6  4d9f					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_PlayerFrames.asm LEVEL 2 PASS 3
      0  4d9f					      include	"BANK_PlayerFrames.asm"
      1  4d9f							;    Sokoboo - a Sokoban implementation
      2  4d9f							;    using a generic tile-based display engine for the Atari 2600
      3  4d9f							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  4d9f							;
      5  4d9f							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  4d9f							;
      7  4d9f							;    Code related to the generic tile-based display engine was developed by
      8  4d9f							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  4d9f							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  4d9f							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  4d9f							;
     12  4d9f							;    Code related to music and sound effects uses the TIATracker music player
     13  4d9f							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  4d9f							;    directory for Apache licensing details.
     15  4d9f							;
     16  4d9f							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  4d9f							;    See the copyright notices in the License directory for a list of level
     18  4d9f							;    contributors.
     19  4d9f							;
     20  4d9f							;    Except where otherwise indicated, this software is released under the
     21  4d9f							;    following licensing arrangement...
     22  4d9f							;
     23  4d9f							;    This program is free software: you can redistribute it and/or modify
     24  4d9f							;    it under the terms of the GNU General Public License as published by
     25  4d9f							;    the Free Software Foundation, either version 3 of the License, or
     26  4d9f							;    (at your option) any later version.
     27  4d9f							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  4d9f
     29  4d9f							;    This program is distributed in the hope that it will be useful,
     30  4d9f							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  4d9f							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  4d9f							;    GNU General Public License for more details.
     33  4d9f
      0  4d9f					      NEWBANK	PLAYER_FRAMES
      1  5586 ????				      SEG	PLAYER_FRAMES
      2  5000					      ORG	ORIGIN
      3  5000					      RORG	$F000
      4  5000				   BANK_START SET	*
      5  5000				   PLAYER_FRAMES SET	ORIGIN / 2048
      6  5000				   ORIGIN     SET	ORIGIN + 2048
      7  5000				   _CURRENT_BANK SET	PLAYER_FRAMES
     35  5000
     36  5000							;CL0	  = $0
     37  5000							;CL1	  = $4C   ;yellow
     38  5000							;CL2	  = $68
     39  5000							;CL3	  = $0C   ; cuffs/trim
     40  5000							;CL4	  = $B8   ; jumper
     41  5000							;CL5	  = $b2
     42  5000							;CL6	  = $66
     43  5000
     44  5000		       00 00	   CL0	      =	$0
     45  5000		       00 01	   CL1	      =	1	;$2C	;yellow
     46  5000		       00 02	   CL2	      =	2	;$24
     47  5000		       00 03	   CL3	      =	3	;$6A	; cuffs/trim
     48  5000		       00 04	   CL4	      =	4	;$44
     49  5000		       00 05	   CL5	      =	5	;$B6	; pants
     50  5000		       00 06	   CL6	      =	6	;$64
     51  5000
     52  5000
     53  5000
     54  5000		       00 ff	   JUMP       =	$FF
     55  5000		       00 fe	   FLIP       =	$FE
     56  5000
     57  5000					      MAC	flip
     58  5000					      .byte	FLIP,0
     59  5000					      ENDM
     60  5000
     61  5000					      MAC	goto
     62  5000					      .byte	JUMP
     63  5000					      .byte	ANIMATION_{1}_ID
     64  5000					      ENDM
     65  5000
     66  5000					      MAC	show
     67  5000					      .byte	FRAME_{1},{2}
     68  5000					      ENDM
     69  5000
     70  5000
     71  5000				   ANIM_INDEX SET	0
     72  5000					      MAC	insert_animation
     73  5000				   ANIMATION_{1}_ID =	ANIM_INDEX
     74  5000					      .word	Animation_{1}
     75  5000				   ANIM_INDEX SET	ANIM_INDEX + 2
     76  5000					      ENDM		; {animation address}
     77  5000
     78  5000				   ANIM_TABLE
      0  5000					      INSERT_ANIMATION	WALK
      1  5000		       00 00	   ANIMATION_WALK_ID =	ANIM_INDEX
      2  5000		       12 f0		      .word.w	Animation_WALK
      3  5000				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5002					      INSERT_ANIMATION	IDLE
      1  5002		       00 02	   ANIMATION_IDLE_ID =	ANIM_INDEX
      2  5002		       42 f0		      .word.w	Animation_IDLE
      3  5002				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5004					      INSERT_ANIMATION	WIN
      1  5004		       00 04	   ANIMATION_WIN_ID =	ANIM_INDEX
      2  5004		       1c f0		      .word.w	Animation_WIN
      3  5004				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5006					      INSERT_ANIMATION	WIN2
      1  5006		       00 06	   ANIMATION_WIN2_ID =	ANIM_INDEX
      2  5006		       1c f0		      .word.w	Animation_WIN2
      3  5006				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5008					      INSERT_ANIMATION	PUSH
      1  5008		       00 08	   ANIMATION_PUSH_ID =	ANIM_INDEX
      2  5008		       c6 f0		      .word.w	Animation_PUSH
      3  5008				   ANIM_INDEX SET	ANIM_INDEX + 2
     84  500a							;    INSERT_ANIMATION PUSHTRY
      0  500a					      INSERT_ANIMATION	PUSHUP
      1  500a		       00 0a	   ANIMATION_PUSHUP_ID =	ANIM_INDEX
      2  500a		       d0 f0		      .word.w	Animation_PUSHUP
      3  500a				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  500c					      INSERT_ANIMATION	WALK2
      1  500c		       00 0c	   ANIMATION_WALK2_ID =	ANIM_INDEX
      2  500c		       12 f0		      .word.w	Animation_WALK2
      3  500c				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  500e					      INSERT_ANIMATION	TURNAROUND
      1  500e		       00 0e	   ANIMATION_TURNAROUND_ID =	ANIM_INDEX
      2  500e		       b2 f0		      .word.w	Animation_TURNAROUND
      3  500e				   ANIM_INDEX SET	ANIM_INDEX + 2
      0  5010					      INSERT_ANIMATION	YAWN
      1  5010		       00 10	   ANIMATION_YAWN_ID =	ANIM_INDEX
      2  5010		       bc f0		      .word.w	Animation_YAWN
      3  5010				   ANIM_INDEX SET	ANIM_INDEX + 2
     89  5012							;    INSERT_ANIMATION PUSH_START
     90  5012
     91  5012
     92  5012				   Animation_WALK
     93  5012				   Animation_WALK2
      0  5012					      SHOW	WALK1, 8
      1  5012		       01 08		      .byte.b	FRAME_WALK1,8
      0  5014					      SHOW	WALK2, 8
      1  5014		       02 08		      .byte.b	FRAME_WALK2,8
      0  5016					      SHOW	WALK3, 8
      1  5016		       05 08		      .byte.b	FRAME_WALK3,8
      0  5018					      SHOW	WALK2, 8
      1  5018		       02 08		      .byte.b	FRAME_WALK2,8
      0  501a					      GOTO	WALK2
      1  501a		       ff		      .byte.b	JUMP
      2  501b		       0c		      .byte.b	ANIMATION_WALK2_ID
     99  501c
    100  501c
    101  501c				   Animation_WIN
    102  501c
    103  501c				   Animation_WIN2
    104  501c
      0  501c					      SHOW	IDLE1,10
      1  501c		       0d 0a		      .byte.b	FRAME_IDLE1,10
      0  501e					      SHOW	IDLE2,10
      1  501e		       0b 0a		      .byte.b	FRAME_IDLE2,10
      0  5020					      SHOW	IDLE1,10
      1  5020		       0d 0a		      .byte.b	FRAME_IDLE1,10
      0  5022					      SHOW	IDLE2,15
      1  5022		       0b 0f		      .byte.b	FRAME_IDLE2,15
      0  5024					      SHOW	IDLE3,15
      1  5024		       0a 0f		      .byte.b	FRAME_IDLE3,15
      0  5026					      GOTO	WIN2
      1  5026		       ff		      .byte.b	JUMP
      2  5027		       06		      .byte.b	ANIMATION_WIN2_ID
    111  5028
    112  5028
    113  5028
    114  5028
    115  5028				   Animation_WOBBLE
    116  5028
    117  5028							; pretty cool little wobble
    118  5028					      REPEAT	4
      0  5028					      SHOW	WALK2, 10
      1  5028		       02 0a		      .byte.b	FRAME_WALK2,10
      0  502a					      FLIP
      1  502a		       fe 00		      .byte.b	FLIP,0
      0  502c					      SHOW	LOOK2, 10
      1  502c		       11 0a		      .byte.b	FRAME_LOOK2,10
    118  502c					      REPEND
      0  502e					      SHOW	WALK2, 10
      1  502e		       02 0a		      .byte.b	FRAME_WALK2,10
      0  5030					      FLIP
      1  5030		       fe 00		      .byte.b	FLIP,0
      0  5032					      SHOW	LOOK2, 10
      1  5032		       11 0a		      .byte.b	FRAME_LOOK2,10
    118  5032					      REPEND
      0  5034					      SHOW	WALK2, 10
      1  5034		       02 0a		      .byte.b	FRAME_WALK2,10
      0  5036					      FLIP
      1  5036		       fe 00		      .byte.b	FLIP,0
      0  5038					      SHOW	LOOK2, 10
      1  5038		       11 0a		      .byte.b	FRAME_LOOK2,10
    118  5038					      REPEND
      0  503a					      SHOW	WALK2, 10
      1  503a		       02 0a		      .byte.b	FRAME_WALK2,10
      0  503c					      FLIP
      1  503c		       fe 00		      .byte.b	FLIP,0
      0  503e					      SHOW	LOOK2, 10
      1  503e		       11 0a		      .byte.b	FRAME_LOOK2,10
    122  5040					      REPEND
      0  5040					      GOTO	IDLE
      1  5040		       ff		      .byte.b	JUMP
      2  5041		       02		      .byte.b	ANIMATION_IDLE_ID
    124  5042
    125  5042
    126  5042
    127  5042				   Animation_IDLE
    128  5042
    129  5042					      REPEAT	2
    130  5042					      REPEAT	2
      0  5042					      SHOW	BLINK, 2
      1  5042		       0f 02		      .byte.b	FRAME_BLINK,2
      0  5044					      SHOW	WALK2, 255
      1  5044		       02 ff		      .byte.b	FRAME_WALK2,255
    130  5044					      REPEND
      0  5046					      SHOW	BLINK, 2
      1  5046		       0f 02		      .byte.b	FRAME_BLINK,2
      0  5048					      SHOW	WALK2, 255
      1  5048		       02 ff		      .byte.b	FRAME_WALK2,255
    133  504a					      REPEND
    134  504a					      REPEAT	6
      0  504a					      SHOW	HANDLIP1, 20
      1  504a		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  504c					      SHOW	HANDLIP2, 20
      1  504c		       14 14		      .byte.b	FRAME_HANDLIP2,20
    134  504c					      REPEND
      0  504e					      SHOW	HANDLIP1, 20
      1  504e		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  5050					      SHOW	HANDLIP2, 20
      1  5050		       14 14		      .byte.b	FRAME_HANDLIP2,20
    134  5050					      REPEND
      0  5052					      SHOW	HANDLIP1, 20
      1  5052		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  5054					      SHOW	HANDLIP2, 20
      1  5054		       14 14		      .byte.b	FRAME_HANDLIP2,20
    134  5054					      REPEND
      0  5056					      SHOW	HANDLIP1, 20
      1  5056		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  5058					      SHOW	HANDLIP2, 20
      1  5058		       14 14		      .byte.b	FRAME_HANDLIP2,20
    134  5058					      REPEND
      0  505a					      SHOW	HANDLIP1, 20
      1  505a		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  505c					      SHOW	HANDLIP2, 20
      1  505c		       14 14		      .byte.b	FRAME_HANDLIP2,20
    134  505c					      REPEND
      0  505e					      SHOW	HANDLIP1, 20
      1  505e		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  5060					      SHOW	HANDLIP2, 20
      1  5060		       14 14		      .byte.b	FRAME_HANDLIP2,20
    137  5062					      REPEND
    138  5062					      REPEAT	2
      0  5062					      SHOW	BLINK, 2
      1  5062		       0f 02		      .byte.b	FRAME_BLINK,2
      0  5064					      SHOW	WALK2, 255
      1  5064		       02 ff		      .byte.b	FRAME_WALK2,255
    138  5064					      REPEND
      0  5066					      SHOW	BLINK, 2
      1  5066		       0f 02		      .byte.b	FRAME_BLINK,2
      0  5068					      SHOW	WALK2, 255
      1  5068		       02 ff		      .byte.b	FRAME_WALK2,255
    141  506a					      REPEND
    142  506a					      REPEAT	3
      0  506a					      SHOW	TAPFOOT, 10
      1  506a		       15 0a		      .byte.b	FRAME_TAPFOOT,10
      0  506c					      SHOW	WALK2, 5
      1  506c		       02 05		      .byte.b	FRAME_WALK2,5
    142  506c					      REPEND
      0  506e					      SHOW	TAPFOOT, 10
      1  506e		       15 0a		      .byte.b	FRAME_TAPFOOT,10
      0  5070					      SHOW	WALK2, 5
      1  5070		       02 05		      .byte.b	FRAME_WALK2,5
    142  5070					      REPEND
      0  5072					      SHOW	TAPFOOT, 10
      1  5072		       15 0a		      .byte.b	FRAME_TAPFOOT,10
      0  5074					      SHOW	WALK2, 5
      1  5074		       02 05		      .byte.b	FRAME_WALK2,5
    145  5076					      REPEND
    129  5076					      REPEND
    130  5076					      REPEAT	2
      0  5076					      SHOW	BLINK, 2
      1  5076		       0f 02		      .byte.b	FRAME_BLINK,2
      0  5078					      SHOW	WALK2, 255
      1  5078		       02 ff		      .byte.b	FRAME_WALK2,255
    130  5078					      REPEND
      0  507a					      SHOW	BLINK, 2
      1  507a		       0f 02		      .byte.b	FRAME_BLINK,2
      0  507c					      SHOW	WALK2, 255
      1  507c		       02 ff		      .byte.b	FRAME_WALK2,255
    133  507e					      REPEND
    134  507e					      REPEAT	6
      0  507e					      SHOW	HANDLIP1, 20
      1  507e		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  5080					      SHOW	HANDLIP2, 20
      1  5080		       14 14		      .byte.b	FRAME_HANDLIP2,20
    134  5080					      REPEND
      0  5082					      SHOW	HANDLIP1, 20
      1  5082		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  5084					      SHOW	HANDLIP2, 20
      1  5084		       14 14		      .byte.b	FRAME_HANDLIP2,20
    134  5084					      REPEND
      0  5086					      SHOW	HANDLIP1, 20
      1  5086		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  5088					      SHOW	HANDLIP2, 20
      1  5088		       14 14		      .byte.b	FRAME_HANDLIP2,20
    134  5088					      REPEND
      0  508a					      SHOW	HANDLIP1, 20
      1  508a		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  508c					      SHOW	HANDLIP2, 20
      1  508c		       14 14		      .byte.b	FRAME_HANDLIP2,20
    134  508c					      REPEND
      0  508e					      SHOW	HANDLIP1, 20
      1  508e		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  5090					      SHOW	HANDLIP2, 20
      1  5090		       14 14		      .byte.b	FRAME_HANDLIP2,20
    134  5090					      REPEND
      0  5092					      SHOW	HANDLIP1, 20
      1  5092		       16 14		      .byte.b	FRAME_HANDLIP1,20
      0  5094					      SHOW	HANDLIP2, 20
      1  5094		       14 14		      .byte.b	FRAME_HANDLIP2,20
    137  5096					      REPEND
    138  5096					      REPEAT	2
      0  5096					      SHOW	BLINK, 2
      1  5096		       0f 02		      .byte.b	FRAME_BLINK,2
      0  5098					      SHOW	WALK2, 255
      1  5098		       02 ff		      .byte.b	FRAME_WALK2,255
    138  5098					      REPEND
      0  509a					      SHOW	BLINK, 2
      1  509a		       0f 02		      .byte.b	FRAME_BLINK,2
      0  509c					      SHOW	WALK2, 255
      1  509c		       02 ff		      .byte.b	FRAME_WALK2,255
    141  509e					      REPEND
    142  509e					      REPEAT	3
      0  509e					      SHOW	TAPFOOT, 10
      1  509e		       15 0a		      .byte.b	FRAME_TAPFOOT,10
      0  50a0					      SHOW	WALK2, 5
      1  50a0		       02 05		      .byte.b	FRAME_WALK2,5
    142  50a0					      REPEND
      0  50a2					      SHOW	TAPFOOT, 10
      1  50a2		       15 0a		      .byte.b	FRAME_TAPFOOT,10
      0  50a4					      SHOW	WALK2, 5
      1  50a4		       02 05		      .byte.b	FRAME_WALK2,5
    142  50a4					      REPEND
      0  50a6					      SHOW	TAPFOOT, 10
      1  50a6		       15 0a		      .byte.b	FRAME_TAPFOOT,10
      0  50a8					      SHOW	WALK2, 5
      1  50a8		       02 05		      .byte.b	FRAME_WALK2,5
    145  50aa					      REPEND
    146  50aa					      REPEND
    147  50aa
      0  50aa					      SHOW	LOOK3, 3
      1  50aa		       12 03		      .byte.b	FRAME_LOOK3,3
      0  50ac					      SHOW	LOOK2, 30
      1  50ac		       11 1e		      .byte.b	FRAME_LOOK2,30
      0  50ae					      SHOW	LOOK3, 3
      1  50ae		       12 03		      .byte.b	FRAME_LOOK3,3
    151  50b0
      0  50b0					      GOTO	YAWN
      1  50b0		       ff		      .byte.b	JUMP
      2  50b1		       10		      .byte.b	ANIMATION_YAWN_ID
    153  50b2
    154  50b2
    155  50b2				   Animation_TURNAROUND
    156  50b2
      0  50b2					      SHOW	LOOK3, 1
      1  50b2		       12 01		      .byte.b	FRAME_LOOK3,1
      0  50b4					      SHOW	LOOK2, 1
      1  50b4		       11 01		      .byte.b	FRAME_LOOK2,1
      0  50b6					      SHOW	LOOK1, 1
      1  50b6		       13 01		      .byte.b	FRAME_LOOK1,1
      0  50b8					      FLIP
      1  50b8		       fe 00		      .byte.b	FLIP,0
      0  50ba					      GOTO	IDLE
      1  50ba		       ff		      .byte.b	JUMP
      2  50bb		       02		      .byte.b	ANIMATION_IDLE_ID
    162  50bc
    163  50bc				   Animation_YAWN
    164  50bc
    165  50bc							;    SHOW WALK2, 50
      0  50bc					      SHOW	IDLE1, 10
      1  50bc		       0d 0a		      .byte.b	FRAME_IDLE1,10
      0  50be					      SHOW	IDLE2, 10
      1  50be		       0b 0a		      .byte.b	FRAME_IDLE2,10
      0  50c0					      SHOW	IDLE3, 150
      1  50c0		       0a 96		      .byte.b	FRAME_IDLE3,150
      0  50c2					      SHOW	IDLE2, 20
      1  50c2		       0b 14		      .byte.b	FRAME_IDLE2,20
      0  50c4					      GOTO	IDLE
      1  50c4		       ff		      .byte.b	JUMP
      2  50c5		       02		      .byte.b	ANIMATION_IDLE_ID
    171  50c6
    172  50c6
    173  50c6							;Animation_PUSHTRY
    174  50c6							;    .byte FRAME_PUSH1,20
    175  50c6							;    .byte FRAME_PUSH2,20
    176  50c6							;    .byte JUMP,ANIMATION_PUSHTRY_ID
    177  50c6
    178  50c6							;Animation_PUSH_START
    179  50c6
    180  50c6							;    .byte FRAME_WALK2,2
    181  50c6
    182  50c6				   Animation_PUSH
    183  50c6
      0  50c6					      SHOW	PUSH1, 10
      1  50c6		       0e 0a		      .byte.b	FRAME_PUSH1,10
      0  50c8					      SHOW	PUSH2, 10
      1  50c8		       0c 0a		      .byte.b	FRAME_PUSH2,10
      0  50ca					      SHOW	PUSH3, 10
      1  50ca		       09 0a		      .byte.b	FRAME_PUSH3,10
      0  50cc					      SHOW	PUSH2, 10
      1  50cc		       0c 0a		      .byte.b	FRAME_PUSH2,10
      0  50ce					      GOTO	PUSH
      1  50ce		       ff		      .byte.b	JUMP
      2  50cf		       08		      .byte.b	ANIMATION_PUSH_ID
    189  50d0
    190  50d0				   Animation_PUSHUP
      0  50d0					      SHOW	PUSH_UP_1, 10
      1  50d0		       06 0a		      .byte.b	FRAME_PUSH_UP_1,10
      0  50d2					      SHOW	PUSH_UP_2, 10
      1  50d2		       08 0a		      .byte.b	FRAME_PUSH_UP_2,10
      0  50d4					      SHOW	PUSH_UP_3, 10
      1  50d4		       07 0a		      .byte.b	FRAME_PUSH_UP_3,10
      0  50d6					      SHOW	PUSH_UP_2, 10
      1  50d6		       08 0a		      .byte.b	FRAME_PUSH_UP_2,10
      0  50d8					      GOTO	PUSHUP
      1  50d8		       ff		      .byte.b	JUMP
      2  50d9		       0a		      .byte.b	ANIMATION_PUSHUP_ID
    196  50da
    197  50da
------- FILE sprites/spriteData.asm LEVEL 3 PASS 3
      0  50da					      include	"sprites/spriteData.asm"
      1  50da				   FRAMEDATA_crouch1
      2  50da		       26		      .byte.b	38	; 23
      3  50db		       12		      .byte.b	18	; 20
      4  50dc		       5a		      .byte.b	90	; 17
      5  50dd		       fc		      .byte.b	252	; 14
      6  50de		       18		      .byte.b	24	; 11
      7  50df		       18		      .byte.b	24	; 8
      8  50e0		       04		      .byte.b	4	; 5
      9  50e1		       00		      .byte.b	0	; 2
     10  50e2		       40		      .byte.b	64	; 22
     11  50e3		       3e		      .byte.b	62	; 19
     12  50e4		       ba		      .byte.b	186	; 16
     13  50e5		       7c		      .byte.b	124	; 13
     14  50e6		       18		      .byte.b	24	; 10
     15  50e7		       0c		      .byte.b	12	; 7
     16  50e8		       1e		      .byte.b	30	; 4
     17  50e9		       00		      .byte.b	0	; 1
     18  50ea		       34		      .byte.b	52	; 21
     19  50eb		       52		      .byte.b	82	; 18
     20  50ec		       be		      .byte.b	190	; 15
     21  50ed		       38		      .byte.b	56	; 12
     22  50ee		       1c		      .byte.b	28	; 9
     23  50ef		       0a		      .byte.b	10	; 6
     24  50f0		       1d		      .byte.b	29	; 3
     25  50f1		       00		      .byte.b	0	; 0
     26  50f2
     27  50f2				   COLOURDATA_crouch1
     28  50f2		       06		      .byte.b	CL6	; 23
     29  50f3		       05		      .byte.b	CL5	; 20
     30  50f4		       03		      .byte.b	CL3	; 17
     31  50f5		       04		      .byte.b	CL4	; 14
     32  50f6		       03		      .byte.b	CL3	; 11
     33  50f7		       02		      .byte.b	CL2	; 8
     34  50f8		       02		      .byte.b	CL2	; 5
     35  50f9		       00		      .byte.b	CL0	; 2
     36  50fa		       06		      .byte.b	CL6	; 22
     37  50fb		       05		      .byte.b	CL5	; 19
     38  50fc		       04		      .byte.b	CL4	; 16
     39  50fd		       04		      .byte.b	CL4	; 13
     40  50fe		       02		      .byte.b	CL2	; 10
     41  50ff		       02		      .byte.b	CL2	; 7
     42  5100		       01		      .byte.b	CL1	; 4
     43  5101		       00		      .byte.b	CL0	; 1
     44  5102		       05		      .byte.b	CL5	; 21
     45  5103		       02		      .byte.b	CL2	; 18
     46  5104		       04		      .byte.b	CL4	; 15
     47  5105		       04		      .byte.b	CL4	; 12
     48  5106		       02		      .byte.b	CL2	; 9
     49  5107		       02		      .byte.b	CL2	; 6
     50  5108		       01		      .byte.b	CL1	; 3
     51  5109		       00		      .byte.b	CL0	; 0
     52  510a
     53  510a				   FRAMEDATA_walk1
     54  510a		       44		      .byte.b	68	; 23
     55  510b		       4c		      .byte.b	76	; 20
     56  510c		       28		      .byte.b	40	; 17
     57  510d		       ba		      .byte.b	186	; 14
     58  510e		       7c		      .byte.b	124	; 11
     59  510f		       18		      .byte.b	24	; 8
     60  5110		       0c		      .byte.b	12	; 5
     61  5111		       1e		      .byte.b	30	; 2
     62  5112		       82		      .byte.b	130	; 22
     63  5113		       1c		      .byte.b	28	; 19
     64  5114		       b2		      .byte.b	178	; 16
     65  5115		       bc		      .byte.b	188	; 13
     66  5116		       38		      .byte.b	56	; 10
     67  5117		       1c		      .byte.b	28	; 7
     68  5118		       0a		      .byte.b	10	; 4
     69  5119		       1d		      .byte.b	29	; 1
     70  511a		       6c		      .byte.b	108	; 21
     71  511b		       38		      .byte.b	56	; 18
     72  511c		       ba		      .byte.b	186	; 15
     73  511d		       fc		      .byte.b	252	; 12
     74  511e		       18		      .byte.b	24	; 9
     75  511f		       18		      .byte.b	24	; 6
     76  5120		       04		      .byte.b	4	; 3
     77  5121		       00		      .byte.b	0	; 0
     78  5122
     79  5122				   COLOURDATA_walk1
     80  5122		       06		      .byte.b	CL6	; 23
     81  5123		       05		      .byte.b	CL5	; 20
     82  5124		       05		      .byte.b	CL5	; 17
     83  5125		       04		      .byte.b	CL4	; 14
     84  5126		       04		      .byte.b	CL4	; 11
     85  5127		       02		      .byte.b	CL2	; 8
     86  5128		       02		      .byte.b	CL2	; 5
     87  5129		       01		      .byte.b	CL1	; 2
     88  512a		       06		      .byte.b	CL6	; 22
     89  512b		       05		      .byte.b	CL5	; 19
     90  512c		       02		      .byte.b	CL2	; 16
     91  512d		       04		      .byte.b	CL4	; 13
     92  512e		       04		      .byte.b	CL4	; 10
     93  512f		       02		      .byte.b	CL2	; 7
     94  5130		       02		      .byte.b	CL2	; 4
     95  5131		       01		      .byte.b	CL1	; 1
     96  5132		       05		      .byte.b	CL5	; 21
     97  5133		       05		      .byte.b	CL5	; 18
     98  5134		       03		      .byte.b	CL3	; 15
     99  5135		       04		      .byte.b	CL4	; 12
    100  5136		       03		      .byte.b	CL3	; 9
    101  5137		       02		      .byte.b	CL2	; 6
    102  5138		       02		      .byte.b	CL2	; 3
    103  5139		       00		      .byte.b	CL0	; 0
    104  513a
    105  513a				   FRAMEDATA_walk2
    106  513a		       34		      .byte.b	52	; 23
    107  513b		       28		      .byte.b	40	; 20
    108  513c		       38		      .byte.b	56	; 17
    109  513d		       ba		      .byte.b	186	; 14
    110  513e		       fc		      .byte.b	252	; 11
    111  513f		       18		      .byte.b	24	; 8
    112  5140		       18		      .byte.b	24	; 5
    113  5141		       04		      .byte.b	4	; 2
    114  5142		       00		      .byte.b	0	; 22
    115  5143		       28		      .byte.b	40	; 19
    116  5144		       18		      .byte.b	24	; 16
    117  5145		       ba		      .byte.b	186	; 13
    118  5146		       7c		      .byte.b	124	; 10
    119  5147		       18		      .byte.b	24	; 7
    120  5148		       0c		      .byte.b	12	; 4
    121  5149		       1e		      .byte.b	30	; 1
    122  514a		       28		      .byte.b	40	; 21
    123  514b		       28		      .byte.b	40	; 18
    124  514c		       b2		      .byte.b	178	; 15
    125  514d		       bc		      .byte.b	188	; 12
    126  514e		       38		      .byte.b	56	; 9
    127  514f		       1c		      .byte.b	28	; 6
    128  5150		       0a		      .byte.b	10	; 3
    129  5151		       1d		      .byte.b	29	; 0
    130  5152
    131  5152				   COLOURDATA_walk2
    132  5152		       06		      .byte.b	CL6	; 23
    133  5153		       05		      .byte.b	CL5	; 20
    134  5154		       05		      .byte.b	CL5	; 17
    135  5155		       03		      .byte.b	CL3	; 14
    136  5156		       04		      .byte.b	CL4	; 11
    137  5157		       03		      .byte.b	CL3	; 8
    138  5158		       02		      .byte.b	CL2	; 5
    139  5159		       02		      .byte.b	CL2	; 2
    140  515a		       00		      .byte.b	CL0	; 22
    141  515b		       05		      .byte.b	CL5	; 19
    142  515c		       05		      .byte.b	CL5	; 16
    143  515d		       04		      .byte.b	CL4	; 13
    144  515e		       04		      .byte.b	CL4	; 10
    145  515f		       02		      .byte.b	CL2	; 7
    146  5160		       02		      .byte.b	CL2	; 4
    147  5161		       01		      .byte.b	CL1	; 1
    148  5162		       05		      .byte.b	CL5	; 21
    149  5163		       05		      .byte.b	CL5	; 18
    150  5164		       02		      .byte.b	CL2	; 15
    151  5165		       04		      .byte.b	CL4	; 12
    152  5166		       04		      .byte.b	CL4	; 9
    153  5167		       02		      .byte.b	CL2	; 6
    154  5168		       02		      .byte.b	CL2	; 3
    155  5169		       01		      .byte.b	CL1	; 0
    156  516a
    157  516a				   FRAMEDATA_handlip
    158  516a		       2c		      .byte.b	44	; 23
    159  516b		       28		      .byte.b	40	; 20
    160  516c		       38		      .byte.b	56	; 17
    161  516d		       58		      .byte.b	88	; 14
    162  516e		       fc		      .byte.b	252	; 11
    163  516f		       1a		      .byte.b	26	; 8
    164  5170		       18		      .byte.b	24	; 5
    165  5171		       04		      .byte.b	4	; 2
    166  5172		       00		      .byte.b	0	; 22
    167  5173		       28		      .byte.b	40	; 19
    168  5174		       38		      .byte.b	56	; 16
    169  5175		       b8		      .byte.b	184	; 13
    170  5176		       7e		      .byte.b	126	; 10
    171  5177		       1a		      .byte.b	26	; 7
    172  5178		       0c		      .byte.b	12	; 4
    173  5179		       1e		      .byte.b	30	; 1
    174  517a		       28		      .byte.b	40	; 21
    175  517b		       28		      .byte.b	40	; 18
    176  517c		       28		      .byte.b	40	; 15
    177  517d		       b8		      .byte.b	184	; 12
    178  517e		       3a		      .byte.b	58	; 9
    179  517f		       1e		      .byte.b	30	; 6
    180  5180		       0a		      .byte.b	10	; 3
    181  5181		       1d		      .byte.b	29	; 0
    182  5182
    183  5182				   COLOURDATA_handlip
    184  5182		       01		      .byte.b	CL1	; 23
    185  5183		       02		      .byte.b	CL2	; 20
    186  5184		       02		      .byte.b	CL2	; 17
    187  5185		       06		      .byte.b	CL6	; 14
    188  5186		       03		      .byte.b	CL3	; 11
    189  5187		       06		      .byte.b	CL6	; 8
    190  5188		       04		      .byte.b	CL4	; 5
    191  5189		       04		      .byte.b	CL4	; 2
    192  518a		       00		      .byte.b	CL0	; 22
    193  518b		       02		      .byte.b	CL2	; 19
    194  518c		       02		      .byte.b	CL2	; 16
    195  518d		       03		      .byte.b	CL3	; 13
    196  518e		       03		      .byte.b	CL3	; 10
    197  518f		       04		      .byte.b	CL4	; 7
    198  5190		       04		      .byte.b	CL4	; 4
    199  5191		       05		      .byte.b	CL5	; 1
    200  5192		       02		      .byte.b	CL2	; 21
    201  5193		       02		      .byte.b	CL2	; 18
    202  5194		       04		      .byte.b	CL4	; 15
    203  5195		       03		      .byte.b	CL3	; 12
    204  5196		       03		      .byte.b	CL3	; 9
    205  5197		       04		      .byte.b	CL4	; 6
    206  5198		       04		      .byte.b	CL4	; 3
    207  5199		       05		      .byte.b	CL5	; 0
    208  519a
    209  519a				   FRAMEDATA_lookup
    210  519a		       34		      .byte.b	52	; 23
    211  519b		       28		      .byte.b	40	; 20
    212  519c		       18		      .byte.b	24	; 17
    213  519d		       b8		      .byte.b	184	; 14
    214  519e		       7e		      .byte.b	126	; 11
    215  519f		       32		      .byte.b	50	; 8
    216  51a0		       70		      .byte.b	112	; 5
    217  51a1		       40		      .byte.b	64	; 2
    218  51a2		       00		      .byte.b	0	; 22
    219  51a3		       28		      .byte.b	40	; 19
    220  51a4		       b0		      .byte.b	176	; 16
    221  51a5		       b8		      .byte.b	184	; 13
    222  51a6		       7a		      .byte.b	122	; 10
    223  51a7		       36		      .byte.b	54	; 7
    224  51a8		       58		      .byte.b	88	; 4
    225  51a9		       78		      .byte.b	120	; 1
    226  51aa		       28		      .byte.b	40	; 21
    227  51ab		       28		      .byte.b	40	; 18
    228  51ac		       b8		      .byte.b	184	; 15
    229  51ad		       fc		      .byte.b	252	; 12
    230  51ae		       32		      .byte.b	50	; 9
    231  51af		       60		      .byte.b	96	; 6
    232  51b0		       30		      .byte.b	48	; 3
    233  51b1		       34		      .byte.b	52	; 0
    234  51b2
    235  51b2				   COLOURDATA_lookup
    236  51b2		       06		      .byte.b	CL6	; 23
    237  51b3		       05		      .byte.b	CL5	; 20
    238  51b4		       05		      .byte.b	CL5	; 17
    239  51b5		       04		      .byte.b	CL4	; 14
    240  51b6		       04		      .byte.b	CL4	; 11
    241  51b7		       02		      .byte.b	CL2	; 8
    242  51b8		       02		      .byte.b	CL2	; 5
    243  51b9		       01		      .byte.b	CL1	; 2
    244  51ba		       00		      .byte.b	CL0	; 22
    245  51bb		       05		      .byte.b	CL5	; 19
    246  51bc		       02		      .byte.b	CL2	; 16
    247  51bd		       04		      .byte.b	CL4	; 13
    248  51be		       04		      .byte.b	CL4	; 10
    249  51bf		       02		      .byte.b	CL2	; 7
    250  51c0		       02		      .byte.b	CL2	; 4
    251  51c1		       01		      .byte.b	CL1	; 1
    252  51c2		       05		      .byte.b	CL5	; 21
    253  51c3		       05		      .byte.b	CL5	; 18
    254  51c4		       03		      .byte.b	CL3	; 15
    255  51c5		       04		      .byte.b	CL4	; 12
    256  51c6		       03		      .byte.b	CL3	; 9
    257  51c7		       02		      .byte.b	CL2	; 6
    258  51c8		       02		      .byte.b	CL2	; 3
    259  51c9		       01		      .byte.b	CL1	; 0
    260  51ca
    261  51ca				   FRAMEDATA_walk3
    262  51ca		       44		      .byte.b	68	; 23
    263  51cb		       74		      .byte.b	116	; 20
    264  51cc		       28		      .byte.b	40	; 17
    265  51cd		       ba		      .byte.b	186	; 14
    266  51ce		       7c		      .byte.b	124	; 11
    267  51cf		       18		      .byte.b	24	; 8
    268  51d0		       0c		      .byte.b	12	; 5
    269  51d1		       1e		      .byte.b	30	; 2
    270  51d2		       82		      .byte.b	130	; 22
    271  51d3		       34		      .byte.b	52	; 19
    272  51d4		       b2		      .byte.b	178	; 16
    273  51d5		       bc		      .byte.b	188	; 13
    274  51d6		       38		      .byte.b	56	; 10
    275  51d7		       1c		      .byte.b	28	; 7
    276  51d8		       0a		      .byte.b	10	; 4
    277  51d9		       1d		      .byte.b	29	; 1
    278  51da		       64		      .byte.b	100	; 21
    279  51db		       38		      .byte.b	56	; 18
    280  51dc		       ba		      .byte.b	186	; 15
    281  51dd		       fc		      .byte.b	252	; 12
    282  51de		       18		      .byte.b	24	; 9
    283  51df		       18		      .byte.b	24	; 6
    284  51e0		       04		      .byte.b	4	; 3
    285  51e1		       00		      .byte.b	0	; 0
    286  51e2
    287  51e2				   COLOURDATA_walk3
    288  51e2		       06		      .byte.b	CL6	; 23
    289  51e3		       05		      .byte.b	CL5	; 20
    290  51e4		       05		      .byte.b	CL5	; 17
    291  51e5		       04		      .byte.b	CL4	; 14
    292  51e6		       04		      .byte.b	CL4	; 11
    293  51e7		       02		      .byte.b	CL2	; 8
    294  51e8		       02		      .byte.b	CL2	; 5
    295  51e9		       01		      .byte.b	CL1	; 2
    296  51ea		       06		      .byte.b	CL6	; 22
    297  51eb		       05		      .byte.b	CL5	; 19
    298  51ec		       02		      .byte.b	CL2	; 16
    299  51ed		       04		      .byte.b	CL4	; 13
    300  51ee		       04		      .byte.b	CL4	; 10
    301  51ef		       02		      .byte.b	CL2	; 7
    302  51f0		       02		      .byte.b	CL2	; 4
    303  51f1		       01		      .byte.b	CL1	; 1
    304  51f2		       05		      .byte.b	CL5	; 21
    305  51f3		       05		      .byte.b	CL5	; 18
    306  51f4		       03		      .byte.b	CL3	; 15
    307  51f5		       04		      .byte.b	CL4	; 12
    308  51f6		       03		      .byte.b	CL3	; 9
    309  51f7		       02		      .byte.b	CL2	; 6
    310  51f8		       02		      .byte.b	CL2	; 3
    311  51f9		       00		      .byte.b	CL0	; 0
    312  51fa
    313  51fa				   FRAMEDATA_push_up_1
    314  51fa		       00		      .byte.b	0	; 23
    315  51fb		       20		      .byte.b	32	; 20
    316  51fc		       20		      .byte.b	32	; 17
    317  51fd		       20		      .byte.b	32	; 14
    318  51fe		       38		      .byte.b	56	; 11
    319  51ff		       38		      .byte.b	56	; 8
    320  5200		       ee		      .byte.b	238	; 5
    321  5201		       38		      .byte.b	56	; 2
    322  5202		       00		      .byte.b	0	; 22
    323  5203		       20		      .byte.b	32	; 19
    324  5204		       28		      .byte.b	40	; 16
    325  5205		       38		      .byte.b	56	; 13
    326  5206		       38		      .byte.b	56	; 10
    327  5207		       38		      .byte.b	56	; 7
    328  5208		       82		      .byte.b	130	; 4
    329  5209		       38		      .byte.b	56	; 1
    330  520a		       00		      .byte.b	0	; 21
    331  520b		       08		      .byte.b	8	; 18
    332  520c		       08		      .byte.b	8	; 15
    333  520d		       10		      .byte.b	16	; 12
    334  520e		       38		      .byte.b	56	; 9
    335  520f		       7c		      .byte.b	124	; 6
    336  5210		       aa		      .byte.b	170	; 3
    337  5211		       00		      .byte.b	0	; 0
    338  5212
    339  5212				   COLOURDATA_push_up_1
    340  5212		       00		      .byte.b	CL0	; 23
    341  5213		       06		      .byte.b	CL6	; 20
    342  5214		       05		      .byte.b	CL5	; 17
    343  5215		       05		      .byte.b	CL5	; 14
    344  5216		       06		      .byte.b	CL6	; 11
    345  5217		       04		      .byte.b	CL4	; 8
    346  5218		       04		      .byte.b	CL4	; 5
    347  5219		       01		      .byte.b	CL1	; 2
    348  521a		       00		      .byte.b	CL0	; 22
    349  521b		       06		      .byte.b	CL6	; 19
    350  521c		       05		      .byte.b	CL5	; 16
    351  521d		       05		      .byte.b	CL5	; 13
    352  521e		       03		      .byte.b	CL3	; 10
    353  521f		       04		      .byte.b	CL4	; 7
    354  5220		       03		      .byte.b	CL3	; 4
    355  5221		       01		      .byte.b	CL1	; 1
    356  5222		       00		      .byte.b	CL0	; 21
    357  5223		       06		      .byte.b	CL6	; 18
    358  5224		       05		      .byte.b	CL5	; 15
    359  5225		       05		      .byte.b	CL5	; 12
    360  5226		       04		      .byte.b	CL4	; 9
    361  5227		       04		      .byte.b	CL4	; 6
    362  5228		       02		      .byte.b	CL2	; 3
    363  5229		       00		      .byte.b	CL0	; 0
    364  522a
    365  522a				   FRAMEDATA_push_up_3
    366  522a		       00		      .byte.b	0	; 23
    367  522b		       08		      .byte.b	8	; 20
    368  522c		       08		      .byte.b	8	; 17
    369  522d		       08		      .byte.b	8	; 14
    370  522e		       38		      .byte.b	56	; 11
    371  522f		       38		      .byte.b	56	; 8
    372  5230		       ee		      .byte.b	238	; 5
    373  5231		       38		      .byte.b	56	; 2
    374  5232		       00		      .byte.b	0	; 22
    375  5233		       08		      .byte.b	8	; 19
    376  5234		       28		      .byte.b	40	; 16
    377  5235		       38		      .byte.b	56	; 13
    378  5236		       38		      .byte.b	56	; 10
    379  5237		       38		      .byte.b	56	; 7
    380  5238		       82		      .byte.b	130	; 4
    381  5239		       38		      .byte.b	56	; 1
    382  523a		       00		      .byte.b	0	; 21
    383  523b		       20		      .byte.b	32	; 18
    384  523c		       20		      .byte.b	32	; 15
    385  523d		       10		      .byte.b	16	; 12
    386  523e		       38		      .byte.b	56	; 9
    387  523f		       7c		      .byte.b	124	; 6
    388  5240		       aa		      .byte.b	170	; 3
    389  5241		       00		      .byte.b	0	; 0
    390  5242
    391  5242				   COLOURDATA_push_up_3
    392  5242		       00		      .byte.b	CL0	; 23
    393  5243		       06		      .byte.b	CL6	; 20
    394  5244		       05		      .byte.b	CL5	; 17
    395  5245		       05		      .byte.b	CL5	; 14
    396  5246		       01		      .byte.b	CL1	; 11
    397  5247		       04		      .byte.b	CL4	; 8
    398  5248		       04		      .byte.b	CL4	; 5
    399  5249		       01		      .byte.b	CL1	; 2
    400  524a		       00		      .byte.b	CL0	; 22
    401  524b		       06		      .byte.b	CL6	; 19
    402  524c		       05		      .byte.b	CL5	; 16
    403  524d		       05		      .byte.b	CL5	; 13
    404  524e		       03		      .byte.b	CL3	; 10
    405  524f		       04		      .byte.b	CL4	; 7
    406  5250		       03		      .byte.b	CL3	; 4
    407  5251		       01		      .byte.b	CL1	; 1
    408  5252		       00		      .byte.b	CL0	; 21
    409  5253		       06		      .byte.b	CL6	; 18
    410  5254		       05		      .byte.b	CL5	; 15
    411  5255		       05		      .byte.b	CL5	; 12
    412  5256		       04		      .byte.b	CL4	; 9
    413  5257		       04		      .byte.b	CL4	; 6
    414  5258		       02		      .byte.b	CL2	; 3
    415  5259		       00		      .byte.b	CL0	; 0
    416  525a
    417  525a				   FRAMEDATA_push_up_2
    418  525a		       00		      .byte.b	0	; 23
    419  525b		       00		      .byte.b	0	; 20
    420  525c		       28		      .byte.b	40	; 17
    421  525d		       28		      .byte.b	40	; 14
    422  525e		       38		      .byte.b	56	; 11
    423  525f		       38		      .byte.b	56	; 8
    424  5260		       ee		      .byte.b	238	; 5
    425  5261		       38		      .byte.b	56	; 2
    426  5262		       00		      .byte.b	0	; 22
    427  5263		       28		      .byte.b	40	; 19
    428  5264		       28		      .byte.b	40	; 16
    429  5265		       38		      .byte.b	56	; 13
    430  5266		       38		      .byte.b	56	; 10
    431  5267		       38		      .byte.b	56	; 7
    432  5268		       82		      .byte.b	130	; 4
    433  5269		       38		      .byte.b	56	; 1
    434  526a		       00		      .byte.b	0	; 21
    435  526b		       00		      .byte.b	0	; 18
    436  526c		       00		      .byte.b	0	; 15
    437  526d		       10		      .byte.b	16	; 12
    438  526e		       38		      .byte.b	56	; 9
    439  526f		       7c		      .byte.b	124	; 6
    440  5270		       aa		      .byte.b	170	; 3
    441  5271		       00		      .byte.b	0	; 0
    442  5272
    443  5272				   COLOURDATA_push_up_2
    444  5272		       00		      .byte.b	CL0	; 23
    445  5273		       00		      .byte.b	CL0	; 20
    446  5274		       05		      .byte.b	CL5	; 17
    447  5275		       05		      .byte.b	CL5	; 14
    448  5276		       06		      .byte.b	CL6	; 11
    449  5277		       04		      .byte.b	CL4	; 8
    450  5278		       04		      .byte.b	CL4	; 5
    451  5279		       01		      .byte.b	CL1	; 2
    452  527a		       00		      .byte.b	CL0	; 22
    453  527b		       06		      .byte.b	CL6	; 19
    454  527c		       05		      .byte.b	CL5	; 16
    455  527d		       05		      .byte.b	CL5	; 13
    456  527e		       03		      .byte.b	CL3	; 10
    457  527f		       04		      .byte.b	CL4	; 7
    458  5280		       03		      .byte.b	CL3	; 4
    459  5281		       01		      .byte.b	CL1	; 1
    460  5282		       00		      .byte.b	CL0	; 21
    461  5283		       00		      .byte.b	CL0	; 18
    462  5284		       00		      .byte.b	CL0	; 15
    463  5285		       05		      .byte.b	CL5	; 12
    464  5286		       04		      .byte.b	CL4	; 9
    465  5287		       04		      .byte.b	CL4	; 6
    466  5288		       02		      .byte.b	CL2	; 3
    467  5289		       00		      .byte.b	CL0	; 0
    468  528a
    469  528a				   FRAMEDATA_push3
    470  528a		       46		      .byte.b	70	; 23
    471  528b		       72		      .byte.b	114	; 20
    472  528c		       18		      .byte.b	24	; 17
    473  528d		       38		      .byte.b	56	; 14
    474  528e		       3e		      .byte.b	62	; 11
    475  528f		       19		      .byte.b	25	; 8
    476  5290		       0c		      .byte.b	12	; 5
    477  5291		       1e		      .byte.b	30	; 2
    478  5292		       80		      .byte.b	128	; 22
    479  5293		       3e		      .byte.b	62	; 19
    480  5294		       30		      .byte.b	48	; 16
    481  5295		       38		      .byte.b	56	; 13
    482  5296		       3f		      .byte.b	63	; 10
    483  5297		       1d		      .byte.b	29	; 7
    484  5298		       0a		      .byte.b	10	; 4
    485  5299		       1d		      .byte.b	29	; 1
    486  529a		       64		      .byte.b	100	; 21
    487  529b		       3c		      .byte.b	60	; 18
    488  529c		       38		      .byte.b	56	; 15
    489  529d		       3c		      .byte.b	60	; 12
    490  529e		       19		      .byte.b	25	; 9
    491  529f		       18		      .byte.b	24	; 6
    492  52a0		       04		      .byte.b	4	; 3
    493  52a1		       00		      .byte.b	0	; 0
    494  52a2
    495  52a2				   COLOURDATA_push3
    496  52a2		       06		      .byte.b	CL6	; 23
    497  52a3		       05		      .byte.b	CL5	; 20
    498  52a4		       05		      .byte.b	CL5	; 17
    499  52a5		       04		      .byte.b	CL4	; 14
    500  52a6		       04		      .byte.b	CL4	; 11
    501  52a7		       02		      .byte.b	CL2	; 8
    502  52a8		       02		      .byte.b	CL2	; 5
    503  52a9		       01		      .byte.b	CL1	; 2
    504  52aa		       06		      .byte.b	CL6	; 22
    505  52ab		       05		      .byte.b	CL5	; 19
    506  52ac		       06		      .byte.b	CL6	; 16
    507  52ad		       04		      .byte.b	CL4	; 13
    508  52ae		       04		      .byte.b	CL4	; 10
    509  52af		       02		      .byte.b	CL2	; 7
    510  52b0		       02		      .byte.b	CL2	; 4
    511  52b1		       01		      .byte.b	CL1	; 1
    512  52b2		       05		      .byte.b	CL5	; 21
    513  52b3		       05		      .byte.b	CL5	; 18
    514  52b4		       03		      .byte.b	CL3	; 15
    515  52b5		       04		      .byte.b	CL4	; 12
    516  52b6		       03		      .byte.b	CL3	; 9
    517  52b7		       02		      .byte.b	CL2	; 6
    518  52b8		       02		      .byte.b	CL2	; 3
    519  52b9		       00		      .byte.b	CL0	; 0
    520  52ba
    521  52ba				   FRAMEDATA_idle3
    522  52ba		       2c		      .byte.b	44	; 23
    523  52bb		       28		      .byte.b	40	; 20
    524  52bc		       38		      .byte.b	56	; 17
    525  52bd		       38		      .byte.b	56	; 14
    526  52be		       38		      .byte.b	56	; 11
    527  52bf		       b2		      .byte.b	178	; 8
    528  52c0		       30		      .byte.b	48	; 5
    529  52c1		       08		      .byte.b	8	; 2
    530  52c2		       00		      .byte.b	0	; 22
    531  52c3		       28		      .byte.b	40	; 19
    532  52c4		       38		      .byte.b	56	; 16
    533  52c5		       38		      .byte.b	56	; 13
    534  52c6		       fe		      .byte.b	254	; 10
    535  52c7		       ba		      .byte.b	186	; 7
    536  52c8		       18		      .byte.b	24	; 4
    537  52c9		       3c		      .byte.b	60	; 1
    538  52ca		       28		      .byte.b	40	; 21
    539  52cb		       28		      .byte.b	40	; 18
    540  52cc		       28		      .byte.b	40	; 15
    541  52cd		       38		      .byte.b	56	; 12
    542  52ce		       fe		      .byte.b	254	; 9
    543  52cf		       b2		      .byte.b	178	; 6
    544  52d0		       14		      .byte.b	20	; 3
    545  52d1		       3a		      .byte.b	58	; 0
    546  52d2
    547  52d2				   COLOURDATA_idle3
    548  52d2		       06		      .byte.b	CL6	; 23
    549  52d3		       05		      .byte.b	CL5	; 20
    550  52d4		       05		      .byte.b	CL5	; 17
    551  52d5		       03		      .byte.b	CL3	; 14
    552  52d6		       04		      .byte.b	CL4	; 11
    553  52d7		       03		      .byte.b	CL3	; 8
    554  52d8		       02		      .byte.b	CL2	; 5
    555  52d9		       02		      .byte.b	CL2	; 2
    556  52da		       00		      .byte.b	CL0	; 22
    557  52db		       05		      .byte.b	CL5	; 19
    558  52dc		       05		      .byte.b	CL5	; 16
    559  52dd		       04		      .byte.b	CL4	; 13
    560  52de		       04		      .byte.b	CL4	; 10
    561  52df		       02		      .byte.b	CL2	; 7
    562  52e0		       02		      .byte.b	CL2	; 4
    563  52e1		       01		      .byte.b	CL1	; 1
    564  52e2		       05		      .byte.b	CL5	; 21
    565  52e3		       05		      .byte.b	CL5	; 18
    566  52e4		       02		      .byte.b	CL2	; 15
    567  52e5		       04		      .byte.b	CL4	; 12
    568  52e6		       04		      .byte.b	CL4	; 9
    569  52e7		       02		      .byte.b	CL2	; 6
    570  52e8		       02		      .byte.b	CL2	; 3
    571  52e9		       01		      .byte.b	CL1	; 0
    572  52ea
    573  52ea				   FRAMEDATA_idle2
    574  52ea		       2c		      .byte.b	44	; 23
    575  52eb		       28		      .byte.b	40	; 20
    576  52ec		       38		      .byte.b	56	; 17
    577  52ed		       38		      .byte.b	56	; 14
    578  52ee		       fe		      .byte.b	254	; 11
    579  52ef		       b2		      .byte.b	178	; 8
    580  52f0		       30		      .byte.b	48	; 5
    581  52f1		       08		      .byte.b	8	; 2
    582  52f2		       00		      .byte.b	0	; 22
    583  52f3		       28		      .byte.b	40	; 19
    584  52f4		       38		      .byte.b	56	; 16
    585  52f5		       38		      .byte.b	56	; 13
    586  52f6		       fe		      .byte.b	254	; 10
    587  52f7		       ba		      .byte.b	186	; 7
    588  52f8		       18		      .byte.b	24	; 4
    589  52f9		       3c		      .byte.b	60	; 1
    590  52fa		       28		      .byte.b	40	; 21
    591  52fb		       28		      .byte.b	40	; 18
    592  52fc		       28		      .byte.b	40	; 15
    593  52fd		       38		      .byte.b	56	; 12
    594  52fe		       ba		      .byte.b	186	; 9
    595  52ff		       30		      .byte.b	48	; 6
    596  5300		       14		      .byte.b	20	; 3
    597  5301		       3a		      .byte.b	58	; 0
    598  5302
    599  5302				   COLOURDATA_idle2
    600  5302		       06		      .byte.b	CL6	; 23
    601  5303		       05		      .byte.b	CL5	; 20
    602  5304		       05		      .byte.b	CL5	; 17
    603  5305		       03		      .byte.b	CL3	; 14
    604  5306		       04		      .byte.b	CL4	; 11
    605  5307		       03		      .byte.b	CL3	; 8
    606  5308		       02		      .byte.b	CL2	; 5
    607  5309		       02		      .byte.b	CL2	; 2
    608  530a		       00		      .byte.b	CL0	; 22
    609  530b		       05		      .byte.b	CL5	; 19
    610  530c		       05		      .byte.b	CL5	; 16
    611  530d		       04		      .byte.b	CL4	; 13
    612  530e		       04		      .byte.b	CL4	; 10
    613  530f		       02		      .byte.b	CL2	; 7
    614  5310		       02		      .byte.b	CL2	; 4
    615  5311		       01		      .byte.b	CL1	; 1
    616  5312		       05		      .byte.b	CL5	; 21
    617  5313		       05		      .byte.b	CL5	; 18
    618  5314		       02		      .byte.b	CL2	; 15
    619  5315		       04		      .byte.b	CL4	; 12
    620  5316		       04		      .byte.b	CL4	; 9
    621  5317		       02		      .byte.b	CL2	; 6
    622  5318		       02		      .byte.b	CL2	; 3
    623  5319		       01		      .byte.b	CL1	; 0
    624  531a
    625  531a				   FRAMEDATA_push2
    626  531a		       26		      .byte.b	38	; 23
    627  531b		       14		      .byte.b	20	; 20
    628  531c		       3c		      .byte.b	60	; 17
    629  531d		       38		      .byte.b	56	; 14
    630  531e		       3c		      .byte.b	60	; 11
    631  531f		       19		      .byte.b	25	; 8
    632  5320		       18		      .byte.b	24	; 5
    633  5321		       04		      .byte.b	4	; 2
    634  5322		       40		      .byte.b	64	; 22
    635  5323		       14		      .byte.b	20	; 19
    636  5324		       28		      .byte.b	40	; 16
    637  5325		       38		      .byte.b	56	; 13
    638  5326		       3e		      .byte.b	62	; 10
    639  5327		       19		      .byte.b	25	; 7
    640  5328		       0c		      .byte.b	12	; 4
    641  5329		       1e		      .byte.b	30	; 1
    642  532a		       34		      .byte.b	52	; 21
    643  532b		       3c		      .byte.b	60	; 18
    644  532c		       30		      .byte.b	48	; 15
    645  532d		       38		      .byte.b	56	; 12
    646  532e		       3f		      .byte.b	63	; 9
    647  532f		       1d		      .byte.b	29	; 6
    648  5330		       0a		      .byte.b	10	; 3
    649  5331		       1d		      .byte.b	29	; 0
    650  5332
    651  5332				   COLOURDATA_push2
    652  5332		       06		      .byte.b	CL6	; 23
    653  5333		       05		      .byte.b	CL5	; 20
    654  5334		       05		      .byte.b	CL5	; 17
    655  5335		       03		      .byte.b	CL3	; 14
    656  5336		       04		      .byte.b	CL4	; 11
    657  5337		       03		      .byte.b	CL3	; 8
    658  5338		       02		      .byte.b	CL2	; 5
    659  5339		       02		      .byte.b	CL2	; 2
    660  533a		       06		      .byte.b	CL6	; 22
    661  533b		       05		      .byte.b	CL5	; 19
    662  533c		       05		      .byte.b	CL5	; 16
    663  533d		       04		      .byte.b	CL4	; 13
    664  533e		       04		      .byte.b	CL4	; 10
    665  533f		       02		      .byte.b	CL2	; 7
    666  5340		       02		      .byte.b	CL2	; 4
    667  5341		       01		      .byte.b	CL1	; 1
    668  5342		       05		      .byte.b	CL5	; 21
    669  5343		       05		      .byte.b	CL5	; 18
    670  5344		       06		      .byte.b	CL6	; 15
    671  5345		       04		      .byte.b	CL4	; 12
    672  5346		       04		      .byte.b	CL4	; 9
    673  5347		       02		      .byte.b	CL2	; 6
    674  5348		       02		      .byte.b	CL2	; 3
    675  5349		       01		      .byte.b	CL1	; 0
    676  534a
    677  534a				   FRAMEDATA_idle1
    678  534a		       34		      .byte.b	52	; 23
    679  534b		       28		      .byte.b	40	; 20
    680  534c		       38		      .byte.b	56	; 17
    681  534d		       ba		      .byte.b	186	; 14
    682  534e		       fc		      .byte.b	252	; 11
    683  534f		       18		      .byte.b	24	; 8
    684  5350		       18		      .byte.b	24	; 5
    685  5351		       04		      .byte.b	4	; 2
    686  5352		       00		      .byte.b	0	; 22
    687  5353		       28		      .byte.b	40	; 19
    688  5354		       18		      .byte.b	24	; 16
    689  5355		       ba		      .byte.b	186	; 13
    690  5356		       7c		      .byte.b	124	; 10
    691  5357		       18		      .byte.b	24	; 7
    692  5358		       0c		      .byte.b	12	; 4
    693  5359		       1e		      .byte.b	30	; 1
    694  535a		       28		      .byte.b	40	; 21
    695  535b		       28		      .byte.b	40	; 18
    696  535c		       b2		      .byte.b	178	; 15
    697  535d		       bc		      .byte.b	188	; 12
    698  535e		       38		      .byte.b	56	; 9
    699  535f		       1c		      .byte.b	28	; 6
    700  5360		       0a		      .byte.b	10	; 3
    701  5361		       1d		      .byte.b	29	; 0
    702  5362
    703  5362				   COLOURDATA_idle1
    704  5362		       06		      .byte.b	CL6	; 23
    705  5363		       05		      .byte.b	CL5	; 20
    706  5364		       05		      .byte.b	CL5	; 17
    707  5365		       03		      .byte.b	CL3	; 14
    708  5366		       04		      .byte.b	CL4	; 11
    709  5367		       03		      .byte.b	CL3	; 8
    710  5368		       02		      .byte.b	CL2	; 5
    711  5369		       02		      .byte.b	CL2	; 2
    712  536a		       00		      .byte.b	CL0	; 22
    713  536b		       05		      .byte.b	CL5	; 19
    714  536c		       05		      .byte.b	CL5	; 16
    715  536d		       04		      .byte.b	CL4	; 13
    716  536e		       04		      .byte.b	CL4	; 10
    717  536f		       02		      .byte.b	CL2	; 7
    718  5370		       02		      .byte.b	CL2	; 4
    719  5371		       01		      .byte.b	CL1	; 1
    720  5372		       05		      .byte.b	CL5	; 21
    721  5373		       05		      .byte.b	CL5	; 18
    722  5374		       02		      .byte.b	CL2	; 15
    723  5375		       04		      .byte.b	CL4	; 12
    724  5376		       04		      .byte.b	CL4	; 9
    725  5377		       02		      .byte.b	CL2	; 6
    726  5378		       02		      .byte.b	CL2	; 3
    727  5379		       01		      .byte.b	CL1	; 0
    728  537a
    729  537a				   FRAMEDATA_push1
    730  537a		       46		      .byte.b	70	; 23
    731  537b		       62		      .byte.b	98	; 20
    732  537c		       28		      .byte.b	40	; 17
    733  537d		       38		      .byte.b	56	; 14
    734  537e		       3e		      .byte.b	62	; 11
    735  537f		       19		      .byte.b	25	; 8
    736  5380		       0c		      .byte.b	12	; 5
    737  5381		       1e		      .byte.b	30	; 2
    738  5382		       80		      .byte.b	128	; 22
    739  5383		       1e		      .byte.b	30	; 19
    740  5384		       30		      .byte.b	48	; 16
    741  5385		       38		      .byte.b	56	; 13
    742  5386		       3f		      .byte.b	63	; 10
    743  5387		       1d		      .byte.b	29	; 7
    744  5388		       0a		      .byte.b	10	; 4
    745  5389		       1d		      .byte.b	29	; 1
    746  538a		       64		      .byte.b	100	; 21
    747  538b		       3c		      .byte.b	60	; 18
    748  538c		       38		      .byte.b	56	; 15
    749  538d		       3c		      .byte.b	60	; 12
    750  538e		       19		      .byte.b	25	; 9
    751  538f		       18		      .byte.b	24	; 6
    752  5390		       04		      .byte.b	4	; 3
    753  5391		       00		      .byte.b	0	; 0
    754  5392
    755  5392				   COLOURDATA_push1
    756  5392		       06		      .byte.b	CL6	; 23
    757  5393		       05		      .byte.b	CL5	; 20
    758  5394		       05		      .byte.b	CL5	; 17
    759  5395		       04		      .byte.b	CL4	; 14
    760  5396		       04		      .byte.b	CL4	; 11
    761  5397		       02		      .byte.b	CL2	; 8
    762  5398		       02		      .byte.b	CL2	; 5
    763  5399		       01		      .byte.b	CL1	; 2
    764  539a		       06		      .byte.b	CL6	; 22
    765  539b		       05		      .byte.b	CL5	; 19
    766  539c		       06		      .byte.b	CL6	; 16
    767  539d		       04		      .byte.b	CL4	; 13
    768  539e		       04		      .byte.b	CL4	; 10
    769  539f		       02		      .byte.b	CL2	; 7
    770  53a0		       02		      .byte.b	CL2	; 4
    771  53a1		       01		      .byte.b	CL1	; 1
    772  53a2		       05		      .byte.b	CL5	; 21
    773  53a3		       05		      .byte.b	CL5	; 18
    774  53a4		       03		      .byte.b	CL3	; 15
    775  53a5		       04		      .byte.b	CL4	; 12
    776  53a6		       03		      .byte.b	CL3	; 9
    777  53a7		       02		      .byte.b	CL2	; 6
    778  53a8		       02		      .byte.b	CL2	; 3
    779  53a9		       00		      .byte.b	CL0	; 0
    780  53aa
    781  53aa				   FRAMEDATA_blink
    782  53aa		       34		      .byte.b	52	; 23
    783  53ab		       28		      .byte.b	40	; 20
    784  53ac		       38		      .byte.b	56	; 17
    785  53ad		       ba		      .byte.b	186	; 14
    786  53ae		       fc		      .byte.b	252	; 11
    787  53af		       18		      .byte.b	24	; 8
    788  53b0		       18		      .byte.b	24	; 5
    789  53b1		       04		      .byte.b	4	; 2
    790  53b2		       00		      .byte.b	0	; 22
    791  53b3		       28		      .byte.b	40	; 19
    792  53b4		       18		      .byte.b	24	; 16
    793  53b5		       ba		      .byte.b	186	; 13
    794  53b6		       7c		      .byte.b	124	; 10
    795  53b7		       18		      .byte.b	24	; 7
    796  53b8		       0c		      .byte.b	12	; 4
    797  53b9		       1e		      .byte.b	30	; 1
    798  53ba		       28		      .byte.b	40	; 21
    799  53bb		       28		      .byte.b	40	; 18
    800  53bc		       b2		      .byte.b	178	; 15
    801  53bd		       bc		      .byte.b	188	; 12
    802  53be		       38		      .byte.b	56	; 9
    803  53bf		       1c		      .byte.b	28	; 6
    804  53c0		       0e		      .byte.b	14	; 3
    805  53c1		       1d		      .byte.b	29	; 0
    806  53c2
    807  53c2				   COLOURDATA_blink
    808  53c2		       06		      .byte.b	CL6	; 23
    809  53c3		       05		      .byte.b	CL5	; 20
    810  53c4		       05		      .byte.b	CL5	; 17
    811  53c5		       03		      .byte.b	CL3	; 14
    812  53c6		       04		      .byte.b	CL4	; 11
    813  53c7		       03		      .byte.b	CL3	; 8
    814  53c8		       02		      .byte.b	CL2	; 5
    815  53c9		       02		      .byte.b	CL2	; 2
    816  53ca		       00		      .byte.b	CL0	; 22
    817  53cb		       05		      .byte.b	CL5	; 19
    818  53cc		       05		      .byte.b	CL5	; 16
    819  53cd		       04		      .byte.b	CL4	; 13
    820  53ce		       04		      .byte.b	CL4	; 10
    821  53cf		       02		      .byte.b	CL2	; 7
    822  53d0		       02		      .byte.b	CL2	; 4
    823  53d1		       01		      .byte.b	CL1	; 1
    824  53d2		       05		      .byte.b	CL5	; 21
    825  53d3		       05		      .byte.b	CL5	; 18
    826  53d4		       02		      .byte.b	CL2	; 15
    827  53d5		       04		      .byte.b	CL4	; 12
    828  53d6		       04		      .byte.b	CL4	; 9
    829  53d7		       02		      .byte.b	CL2	; 6
    830  53d8		       02		      .byte.b	CL2	; 3
    831  53d9		       01		      .byte.b	CL1	; 0
    832  53da
    833  53da				   FRAMEDATA_yell
    834  53da		       34		      .byte.b	52	; 23
    835  53db		       28		      .byte.b	40	; 20
    836  53dc		       18		      .byte.b	24	; 17
    837  53dd		       b8		      .byte.b	184	; 14
    838  53de		       7e		      .byte.b	126	; 11
    839  53df		       32		      .byte.b	50	; 8
    840  53e0		       72		      .byte.b	114	; 5
    841  53e1		       40		      .byte.b	64	; 2
    842  53e2		       00		      .byte.b	0	; 22
    843  53e3		       28		      .byte.b	40	; 19
    844  53e4		       b0		      .byte.b	176	; 16
    845  53e5		       b8		      .byte.b	184	; 13
    846  53e6		       7a		      .byte.b	122	; 10
    847  53e7		       36		      .byte.b	54	; 7
    848  53e8		       58		      .byte.b	88	; 4
    849  53e9		       78		      .byte.b	120	; 1
    850  53ea		       28		      .byte.b	40	; 21
    851  53eb		       28		      .byte.b	40	; 18
    852  53ec		       b8		      .byte.b	184	; 15
    853  53ed		       fc		      .byte.b	252	; 12
    854  53ee		       32		      .byte.b	50	; 9
    855  53ef		       62		      .byte.b	98	; 6
    856  53f0		       30		      .byte.b	48	; 3
    857  53f1		       34		      .byte.b	52	; 0
    858  53f2
    859  53f2				   COLOURDATA_yell
    860  53f2		       06		      .byte.b	CL6	; 23
    861  53f3		       05		      .byte.b	CL5	; 20
    862  53f4		       05		      .byte.b	CL5	; 17
    863  53f5		       04		      .byte.b	CL4	; 14
    864  53f6		       04		      .byte.b	CL4	; 11
    865  53f7		       02		      .byte.b	CL2	; 8
    866  53f8		       02		      .byte.b	CL2	; 5
    867  53f9		       01		      .byte.b	CL1	; 2
    868  53fa		       00		      .byte.b	CL0	; 22
    869  53fb		       05		      .byte.b	CL5	; 19
    870  53fc		       02		      .byte.b	CL2	; 16
    871  53fd		       04		      .byte.b	CL4	; 13
    872  53fe		       04		      .byte.b	CL4	; 10
    873  53ff		       02		      .byte.b	CL2	; 7
    874  5400		       02		      .byte.b	CL2	; 4
    875  5401		       01		      .byte.b	CL1	; 1
    876  5402		       05		      .byte.b	CL5	; 21
    877  5403		       05		      .byte.b	CL5	; 18
    878  5404		       03		      .byte.b	CL3	; 15
    879  5405		       04		      .byte.b	CL4	; 12
    880  5406		       03		      .byte.b	CL3	; 9
    881  5407		       02		      .byte.b	CL2	; 6
    882  5408		       02		      .byte.b	CL2	; 3
    883  5409		       01		      .byte.b	CL1	; 0
    884  540a
    885  540a				   FRAMEDATA_look2
    886  540a		       34		      .byte.b	52	; 23
    887  540b		       28		      .byte.b	40	; 20
    888  540c		       38		      .byte.b	56	; 17
    889  540d		       ba		      .byte.b	186	; 14
    890  540e		       7c		      .byte.b	124	; 11
    891  540f		       30		      .byte.b	48	; 8
    892  5410		       10		      .byte.b	16	; 5
    893  5411		       70		      .byte.b	112	; 2
    894  5412		       00		      .byte.b	0	; 22
    895  5413		       28		      .byte.b	40	; 19
    896  5414		       18		      .byte.b	24	; 16
    897  5415		       be		      .byte.b	190	; 13
    898  5416		       78		      .byte.b	120	; 10
    899  5417		       30		      .byte.b	48	; 7
    900  5418		       78		      .byte.b	120	; 4
    901  5419		       78		      .byte.b	120	; 1
    902  541a		       28		      .byte.b	40	; 21
    903  541b		       28		      .byte.b	40	; 18
    904  541c		       b2		      .byte.b	178	; 15
    905  541d		       fc		      .byte.b	252	; 12
    906  541e		       38		      .byte.b	56	; 9
    907  541f		       30		      .byte.b	48	; 6
    908  5420		       28		      .byte.b	40	; 3
    909  5421		       b8		      .byte.b	184	; 0
    910  5422
    911  5422				   COLOURDATA_look2
    912  5422		       06		      .byte.b	CL6	; 23
    913  5423		       05		      .byte.b	CL5	; 20
    914  5424		       05		      .byte.b	CL5	; 17
    915  5425		       03		      .byte.b	CL3	; 14
    916  5426		       04		      .byte.b	CL4	; 11
    917  5427		       03		      .byte.b	CL3	; 8
    918  5428		       02		      .byte.b	CL2	; 5
    919  5429		       02		      .byte.b	CL2	; 2
    920  542a		       00		      .byte.b	CL0	; 22
    921  542b		       05		      .byte.b	CL5	; 19
    922  542c		       05		      .byte.b	CL5	; 16
    923  542d		       04		      .byte.b	CL4	; 13
    924  542e		       04		      .byte.b	CL4	; 10
    925  542f		       02		      .byte.b	CL2	; 7
    926  5430		       02		      .byte.b	CL2	; 4
    927  5431		       01		      .byte.b	CL1	; 1
    928  5432		       05		      .byte.b	CL5	; 21
    929  5433		       05		      .byte.b	CL5	; 18
    930  5434		       02		      .byte.b	CL2	; 15
    931  5435		       04		      .byte.b	CL4	; 12
    932  5436		       04		      .byte.b	CL4	; 9
    933  5437		       02		      .byte.b	CL2	; 6
    934  5438		       02		      .byte.b	CL2	; 3
    935  5439		       01		      .byte.b	CL1	; 0
    936  543a
    937  543a				   FRAMEDATA_look3
    938  543a		       34		      .byte.b	52	; 23
    939  543b		       28		      .byte.b	40	; 20
    940  543c		       38		      .byte.b	56	; 17
    941  543d		       ba		      .byte.b	186	; 14
    942  543e		       fc		      .byte.b	252	; 11
    943  543f		       18		      .byte.b	24	; 8
    944  5440		       10		      .byte.b	16	; 5
    945  5441		       1c		      .byte.b	28	; 2
    946  5442		       00		      .byte.b	0	; 22
    947  5443		       28		      .byte.b	40	; 19
    948  5444		       18		      .byte.b	24	; 16
    949  5445		       ba		      .byte.b	186	; 13
    950  5446		       7c		      .byte.b	124	; 10
    951  5447		       18		      .byte.b	24	; 7
    952  5448		       3c		      .byte.b	60	; 4
    953  5449		       3c		      .byte.b	60	; 1
    954  544a		       28		      .byte.b	40	; 21
    955  544b		       28		      .byte.b	40	; 18
    956  544c		       b2		      .byte.b	178	; 15
    957  544d		       bc		      .byte.b	188	; 12
    958  544e		       38		      .byte.b	56	; 9
    959  544f		       18		      .byte.b	24	; 6
    960  5450		       28		      .byte.b	40	; 3
    961  5451		       3a		      .byte.b	58	; 0
    962  5452
    963  5452				   COLOURDATA_look3
    964  5452		       06		      .byte.b	CL6	; 23
    965  5453		       05		      .byte.b	CL5	; 20
    966  5454		       05		      .byte.b	CL5	; 17
    967  5455		       03		      .byte.b	CL3	; 14
    968  5456		       04		      .byte.b	CL4	; 11
    969  5457		       03		      .byte.b	CL3	; 8
    970  5458		       02		      .byte.b	CL2	; 5
    971  5459		       02		      .byte.b	CL2	; 2
    972  545a		       00		      .byte.b	CL0	; 22
    973  545b		       05		      .byte.b	CL5	; 19
    974  545c		       05		      .byte.b	CL5	; 16
    975  545d		       04		      .byte.b	CL4	; 13
    976  545e		       04		      .byte.b	CL4	; 10
    977  545f		       02		      .byte.b	CL2	; 7
    978  5460		       02		      .byte.b	CL2	; 4
    979  5461		       01		      .byte.b	CL1	; 1
    980  5462		       05		      .byte.b	CL5	; 21
    981  5463		       05		      .byte.b	CL5	; 18
    982  5464		       02		      .byte.b	CL2	; 15
    983  5465		       04		      .byte.b	CL4	; 12
    984  5466		       04		      .byte.b	CL4	; 9
    985  5467		       02		      .byte.b	CL2	; 6
    986  5468		       02		      .byte.b	CL2	; 3
    987  5469		       01		      .byte.b	CL1	; 0
    988  546a
    989  546a				   FRAMEDATA_look1
    990  546a		       28		      .byte.b	40	; 23
    991  546b		       28		      .byte.b	40	; 20
    992  546c		       38		      .byte.b	56	; 17
    993  546d		       59		      .byte.b	89	; 14
    994  546e		       7c		      .byte.b	124	; 11
    995  546f		       18		      .byte.b	24	; 8
    996  5470		       18		      .byte.b	24	; 5
    997  5471		       20		      .byte.b	32	; 2
    998  5472		       00		      .byte.b	0	; 22
    999  5473		       28		      .byte.b	40	; 19
   1000  5474		       38		      .byte.b	56	; 16
   1001  5475		       5a		      .byte.b	90	; 13
   1002  5476		       3c		      .byte.b	60	; 10
   1003  5477		       18		      .byte.b	24	; 7
   1004  5478		       30		      .byte.b	48	; 4
   1005  5479		       78		      .byte.b	120	; 1
   1006  547a		       28		      .byte.b	40	; 21
   1007  547b		       28		      .byte.b	40	; 18
   1008  547c		       49		      .byte.b	73	; 15
   1009  547d		       7e		      .byte.b	126	; 12
   1010  547e		       18		      .byte.b	24	; 9
   1011  547f		       38		      .byte.b	56	; 6
   1012  5480		       50		      .byte.b	80	; 3
   1013  5481		       b8		      .byte.b	184	; 0
   1014  5482
   1015  5482				   COLOURDATA_look1
   1016  5482		       06		      .byte.b	CL6	; 23
   1017  5483		       05		      .byte.b	CL5	; 20
   1018  5484		       05		      .byte.b	CL5	; 17
   1019  5485		       03		      .byte.b	CL3	; 14
   1020  5486		       04		      .byte.b	CL4	; 11
   1021  5487		       03		      .byte.b	CL3	; 8
   1022  5488		       02		      .byte.b	CL2	; 5
   1023  5489		       02		      .byte.b	CL2	; 2
   1024  548a		       00		      .byte.b	CL0	; 22
   1025  548b		       05		      .byte.b	CL5	; 19
   1026  548c		       05		      .byte.b	CL5	; 16
   1027  548d		       04		      .byte.b	CL4	; 13
   1028  548e		       04		      .byte.b	CL4	; 10
   1029  548f		       02		      .byte.b	CL2	; 7
   1030  5490		       02		      .byte.b	CL2	; 4
   1031  5491		       01		      .byte.b	CL1	; 1
   1032  5492		       05		      .byte.b	CL5	; 21
   1033  5493		       05		      .byte.b	CL5	; 18
   1034  5494		       02		      .byte.b	CL2	; 15
   1035  5495		       04		      .byte.b	CL4	; 12
   1036  5496		       04		      .byte.b	CL4	; 9
   1037  5497		       02		      .byte.b	CL2	; 6
   1038  5498		       02		      .byte.b	CL2	; 3
   1039  5499		       01		      .byte.b	CL1	; 0
   1040  549a
   1041  549a				   FRAMEDATA_handlip2
   1042  549a		       28		      .byte.b	40	; 23
   1043  549b		       28		      .byte.b	40	; 20
   1044  549c		       38		      .byte.b	56	; 17
   1045  549d		       58		      .byte.b	88	; 14
   1046  549e		       fc		      .byte.b	252	; 11
   1047  549f		       1a		      .byte.b	26	; 8
   1048  54a0		       18		      .byte.b	24	; 5
   1049  54a1		       04		      .byte.b	4	; 2
   1050  54a2		       04		      .byte.b	4	; 22
   1051  54a3		       28		      .byte.b	40	; 19
   1052  54a4		       38		      .byte.b	56	; 16
   1053  54a5		       b8		      .byte.b	184	; 13
   1054  54a6		       7e		      .byte.b	126	; 10
   1055  54a7		       1a		      .byte.b	26	; 7
   1056  54a8		       0c		      .byte.b	12	; 4
   1057  54a9		       1e		      .byte.b	30	; 1
   1058  54aa		       28		      .byte.b	40	; 21
   1059  54ab		       28		      .byte.b	40	; 18
   1060  54ac		       28		      .byte.b	40	; 15
   1061  54ad		       b8		      .byte.b	184	; 12
   1062  54ae		       3a		      .byte.b	58	; 9
   1063  54af		       1e		      .byte.b	30	; 6
   1064  54b0		       0a		      .byte.b	10	; 3
   1065  54b1		       1d		      .byte.b	29	; 0
   1066  54b2
   1067  54b2				   COLOURDATA_handlip2
   1068  54b2		       06		      .byte.b	CL6	; 23
   1069  54b3		       05		      .byte.b	CL5	; 20
   1070  54b4		       05		      .byte.b	CL5	; 17
   1071  54b5		       03		      .byte.b	CL3	; 14
   1072  54b6		       04		      .byte.b	CL4	; 11
   1073  54b7		       03		      .byte.b	CL3	; 8
   1074  54b8		       02		      .byte.b	CL2	; 5
   1075  54b9		       02		      .byte.b	CL2	; 2
   1076  54ba		       06		      .byte.b	CL6	; 22
   1077  54bb		       05		      .byte.b	CL5	; 19
   1078  54bc		       05		      .byte.b	CL5	; 16
   1079  54bd		       04		      .byte.b	CL4	; 13
   1080  54be		       04		      .byte.b	CL4	; 10
   1081  54bf		       02		      .byte.b	CL2	; 7
   1082  54c0		       02		      .byte.b	CL2	; 4
   1083  54c1		       01		      .byte.b	CL1	; 1
   1084  54c2		       05		      .byte.b	CL5	; 21
   1085  54c3		       05		      .byte.b	CL5	; 18
   1086  54c4		       02		      .byte.b	CL2	; 15
   1087  54c5		       04		      .byte.b	CL4	; 12
   1088  54c6		       04		      .byte.b	CL4	; 9
   1089  54c7		       02		      .byte.b	CL2	; 6
   1090  54c8		       02		      .byte.b	CL2	; 3
   1091  54c9		       01		      .byte.b	CL1	; 0
   1092  54ca
   1093  54ca				   FRAMEDATA_tapfoot
   1094  54ca		       24		      .byte.b	36	; 23
   1095  54cb		       28		      .byte.b	40	; 20
   1096  54cc		       38		      .byte.b	56	; 17
   1097  54cd		       ba		      .byte.b	186	; 14
   1098  54ce		       fc		      .byte.b	252	; 11
   1099  54cf		       18		      .byte.b	24	; 8
   1100  54d0		       18		      .byte.b	24	; 5
   1101  54d1		       04		      .byte.b	4	; 2
   1102  54d2		       10		      .byte.b	16	; 22
   1103  54d3		       28		      .byte.b	40	; 19
   1104  54d4		       18		      .byte.b	24	; 16
   1105  54d5		       ba		      .byte.b	186	; 13
   1106  54d6		       7c		      .byte.b	124	; 10
   1107  54d7		       18		      .byte.b	24	; 7
   1108  54d8		       0c		      .byte.b	12	; 4
   1109  54d9		       1e		      .byte.b	30	; 1
   1110  54da		       28		      .byte.b	40	; 21
   1111  54db		       28		      .byte.b	40	; 18
   1112  54dc		       b2		      .byte.b	178	; 15
   1113  54dd		       bc		      .byte.b	188	; 12
   1114  54de		       38		      .byte.b	56	; 9
   1115  54df		       1c		      .byte.b	28	; 6
   1116  54e0		       0a		      .byte.b	10	; 3
   1117  54e1		       1d		      .byte.b	29	; 0
   1118  54e2
   1119  54e2				   COLOURDATA_tapfoot
   1120  54e2		       06		      .byte.b	CL6	; 23
   1121  54e3		       05		      .byte.b	CL5	; 20
   1122  54e4		       05		      .byte.b	CL5	; 17
   1123  54e5		       03		      .byte.b	CL3	; 14
   1124  54e6		       04		      .byte.b	CL4	; 11
   1125  54e7		       03		      .byte.b	CL3	; 8
   1126  54e8		       02		      .byte.b	CL2	; 5
   1127  54e9		       02		      .byte.b	CL2	; 2
   1128  54ea		       06		      .byte.b	CL6	; 22
   1129  54eb		       05		      .byte.b	CL5	; 19
   1130  54ec		       05		      .byte.b	CL5	; 16
   1131  54ed		       04		      .byte.b	CL4	; 13
   1132  54ee		       04		      .byte.b	CL4	; 10
   1133  54ef		       02		      .byte.b	CL2	; 7
   1134  54f0		       02		      .byte.b	CL2	; 4
   1135  54f1		       01		      .byte.b	CL1	; 1
   1136  54f2		       05		      .byte.b	CL5	; 21
   1137  54f3		       05		      .byte.b	CL5	; 18
   1138  54f4		       02		      .byte.b	CL2	; 15
   1139  54f5		       04		      .byte.b	CL4	; 12
   1140  54f6		       04		      .byte.b	CL4	; 9
   1141  54f7		       02		      .byte.b	CL2	; 6
   1142  54f8		       02		      .byte.b	CL2	; 3
   1143  54f9		       01		      .byte.b	CL1	; 0
   1144  54fa
   1145  54fa				   FRAMEDATA_handlip1
   1146  54fa		       2c		      .byte.b	44	; 23
   1147  54fb		       28		      .byte.b	40	; 20
   1148  54fc		       38		      .byte.b	56	; 17
   1149  54fd		       58		      .byte.b	88	; 14
   1150  54fe		       fc		      .byte.b	252	; 11
   1151  54ff		       1a		      .byte.b	26	; 8
   1152  5500		       18		      .byte.b	24	; 5
   1153  5501		       04		      .byte.b	4	; 2
   1154  5502		       00		      .byte.b	0	; 22
   1155  5503		       28		      .byte.b	40	; 19
   1156  5504		       38		      .byte.b	56	; 16
   1157  5505		       b8		      .byte.b	184	; 13
   1158  5506		       7e		      .byte.b	126	; 10
   1159  5507		       1a		      .byte.b	26	; 7
   1160  5508		       0c		      .byte.b	12	; 4
   1161  5509		       1e		      .byte.b	30	; 1
   1162  550a		       28		      .byte.b	40	; 21
   1163  550b		       28		      .byte.b	40	; 18
   1164  550c		       28		      .byte.b	40	; 15
   1165  550d		       b8		      .byte.b	184	; 12
   1166  550e		       3a		      .byte.b	58	; 9
   1167  550f		       1e		      .byte.b	30	; 6
   1168  5510		       0a		      .byte.b	10	; 3
   1169  5511		       1d		      .byte.b	29	; 0
   1170  5512
   1171  5512				   COLOURDATA_handlip1
   1172  5512		       06		      .byte.b	CL6	; 23
   1173  5513		       05		      .byte.b	CL5	; 20
   1174  5514		       05		      .byte.b	CL5	; 17
   1175  5515		       03		      .byte.b	CL3	; 14
   1176  5516		       04		      .byte.b	CL4	; 11
   1177  5517		       03		      .byte.b	CL3	; 8
   1178  5518		       02		      .byte.b	CL2	; 5
   1179  5519		       02		      .byte.b	CL2	; 2
   1180  551a		       00		      .byte.b	CL0	; 22
   1181  551b		       05		      .byte.b	CL5	; 19
   1182  551c		       05		      .byte.b	CL5	; 16
   1183  551d		       04		      .byte.b	CL4	; 13
   1184  551e		       04		      .byte.b	CL4	; 10
   1185  551f		       02		      .byte.b	CL2	; 7
   1186  5520		       02		      .byte.b	CL2	; 4
   1187  5521		       01		      .byte.b	CL1	; 1
   1188  5522		       05		      .byte.b	CL5	; 21
   1189  5523		       05		      .byte.b	CL5	; 18
   1190  5524		       02		      .byte.b	CL2	; 15
   1191  5525		       04		      .byte.b	CL4	; 12
   1192  5526		       04		      .byte.b	CL4	; 9
   1193  5527		       02		      .byte.b	CL2	; 6
   1194  5528		       02		      .byte.b	CL2	; 3
   1195  5529		       01		      .byte.b	CL1	; 0
   1196  552a
   1197  552a
   1198  552a				   __FNUM     SET	0
   1199  552a					      MAC	deframe
   1200  552a				   FRAME_{1}  =	__FNUM
   1201  552a				   __FNUM     SET	__FNUM + 1
   1202  552a					      ENDM		;{name}
   1203  552a
      0  552a					      DEFRAME	CROUCH1
      1  552a		       00 00	   FRAME_CROUCH1 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	WALK1
      1  552a		       00 01	   FRAME_WALK1 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	WALK2
      1  552a		       00 02	   FRAME_WALK2 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	HANDLIP
      1  552a		       00 03	   FRAME_HANDLIP =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	LOOKUP
      1  552a		       00 04	   FRAME_LOOKUP =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	WALK3
      1  552a		       00 05	   FRAME_WALK3 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	PUSH_UP_1
      1  552a		       00 06	   FRAME_PUSH_UP_1 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	PUSH_UP_3
      1  552a		       00 07	   FRAME_PUSH_UP_3 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	PUSH_UP_2
      1  552a		       00 08	   FRAME_PUSH_UP_2 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	PUSH3
      1  552a		       00 09	   FRAME_PUSH3 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	IDLE3
      1  552a		       00 0a	   FRAME_IDLE3 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	IDLE2
      1  552a		       00 0b	   FRAME_IDLE2 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	PUSH2
      1  552a		       00 0c	   FRAME_PUSH2 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	IDLE1
      1  552a		       00 0d	   FRAME_IDLE1 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	PUSH1
      1  552a		       00 0e	   FRAME_PUSH1 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	BLINK
      1  552a		       00 0f	   FRAME_BLINK =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	YELL
      1  552a		       00 10	   FRAME_YELL =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	LOOK2
      1  552a		       00 11	   FRAME_LOOK2 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	LOOK3
      1  552a		       00 12	   FRAME_LOOK3 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	LOOK1
      1  552a		       00 13	   FRAME_LOOK1 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	HANDLIP2
      1  552a		       00 14	   FRAME_HANDLIP2 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	TAPFOOT
      1  552a		       00 15	   FRAME_TAPFOOT =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
      0  552a					      DEFRAME	HANDLIP1
      1  552a		       00 16	   FRAME_HANDLIP1 =	__FNUM
      2  552a				   __FNUM     SET	__FNUM + 1
   1227  552a
   1228  552a				   FRAME_PTR_LO
   1229  552a		       da		      .byte.b	<FRAMEDATA_crouch1
   1230  552b		       0a		      .byte.b	<FRAMEDATA_walk1
   1231  552c		       3a		      .byte.b	<FRAMEDATA_walk2
   1232  552d		       6a		      .byte.b	<FRAMEDATA_handlip
   1233  552e		       9a		      .byte.b	<FRAMEDATA_lookup
   1234  552f		       ca		      .byte.b	<FRAMEDATA_walk3
   1235  5530		       fa		      .byte.b	<FRAMEDATA_push_up_1
   1236  5531		       2a		      .byte.b	<FRAMEDATA_push_up_3
   1237  5532		       5a		      .byte.b	<FRAMEDATA_push_up_2
   1238  5533		       8a		      .byte.b	<FRAMEDATA_push3
   1239  5534		       ba		      .byte.b	<FRAMEDATA_idle3
   1240  5535		       ea		      .byte.b	<FRAMEDATA_idle2
   1241  5536		       1a		      .byte.b	<FRAMEDATA_push2
   1242  5537		       4a		      .byte.b	<FRAMEDATA_idle1
   1243  5538		       7a		      .byte.b	<FRAMEDATA_push1
   1244  5539		       aa		      .byte.b	<FRAMEDATA_blink
   1245  553a		       da		      .byte.b	<FRAMEDATA_yell
   1246  553b		       0a		      .byte.b	<FRAMEDATA_look2
   1247  553c		       3a		      .byte.b	<FRAMEDATA_look3
   1248  553d		       6a		      .byte.b	<FRAMEDATA_look1
   1249  553e		       9a		      .byte.b	<FRAMEDATA_handlip2
   1250  553f		       ca		      .byte.b	<FRAMEDATA_tapfoot
   1251  5540		       fa		      .byte.b	<FRAMEDATA_handlip1
   1252  5541
   1253  5541				   FRAME_PTR_HI
   1254  5541		       f0		      .byte.b	>FRAMEDATA_crouch1
   1255  5542		       f1		      .byte.b	>FRAMEDATA_walk1
   1256  5543		       f1		      .byte.b	>FRAMEDATA_walk2
   1257  5544		       f1		      .byte.b	>FRAMEDATA_handlip
   1258  5545		       f1		      .byte.b	>FRAMEDATA_lookup
   1259  5546		       f1		      .byte.b	>FRAMEDATA_walk3
   1260  5547		       f1		      .byte.b	>FRAMEDATA_push_up_1
   1261  5548		       f2		      .byte.b	>FRAMEDATA_push_up_3
   1262  5549		       f2		      .byte.b	>FRAMEDATA_push_up_2
   1263  554a		       f2		      .byte.b	>FRAMEDATA_push3
   1264  554b		       f2		      .byte.b	>FRAMEDATA_idle3
   1265  554c		       f2		      .byte.b	>FRAMEDATA_idle2
   1266  554d		       f3		      .byte.b	>FRAMEDATA_push2
   1267  554e		       f3		      .byte.b	>FRAMEDATA_idle1
   1268  554f		       f3		      .byte.b	>FRAMEDATA_push1
   1269  5550		       f3		      .byte.b	>FRAMEDATA_blink
   1270  5551		       f3		      .byte.b	>FRAMEDATA_yell
   1271  5552		       f4		      .byte.b	>FRAMEDATA_look2
   1272  5553		       f4		      .byte.b	>FRAMEDATA_look3
   1273  5554		       f4		      .byte.b	>FRAMEDATA_look1
   1274  5555		       f4		      .byte.b	>FRAMEDATA_handlip2
   1275  5556		       f4		      .byte.b	>FRAMEDATA_tapfoot
   1276  5557		       f4		      .byte.b	>FRAMEDATA_handlip1
   1277  5558
   1278  5558				   COLOUR_PTR_LO
   1279  5558		       f2		      .byte.b	<COLOURDATA_crouch1
   1280  5559		       22		      .byte.b	<COLOURDATA_walk1
   1281  555a		       52		      .byte.b	<COLOURDATA_walk2
   1282  555b		       82		      .byte.b	<COLOURDATA_handlip
   1283  555c		       b2		      .byte.b	<COLOURDATA_lookup
   1284  555d		       e2		      .byte.b	<COLOURDATA_walk3
   1285  555e		       12		      .byte.b	<COLOURDATA_push_up_1
   1286  555f		       42		      .byte.b	<COLOURDATA_push_up_3
   1287  5560		       72		      .byte.b	<COLOURDATA_push_up_2
   1288  5561		       a2		      .byte.b	<COLOURDATA_push3
   1289  5562		       d2		      .byte.b	<COLOURDATA_idle3
   1290  5563		       02		      .byte.b	<COLOURDATA_idle2
   1291  5564		       32		      .byte.b	<COLOURDATA_push2
   1292  5565		       62		      .byte.b	<COLOURDATA_idle1
   1293  5566		       92		      .byte.b	<COLOURDATA_push1
   1294  5567		       c2		      .byte.b	<COLOURDATA_blink
   1295  5568		       f2		      .byte.b	<COLOURDATA_yell
   1296  5569		       22		      .byte.b	<COLOURDATA_look2
   1297  556a		       52		      .byte.b	<COLOURDATA_look3
   1298  556b		       82		      .byte.b	<COLOURDATA_look1
   1299  556c		       b2		      .byte.b	<COLOURDATA_handlip2
   1300  556d		       e2		      .byte.b	<COLOURDATA_tapfoot
   1301  556e		       12		      .byte.b	<COLOURDATA_handlip1
   1302  556f
   1303  556f				   COLOUR_PTR_HI
   1304  556f		       f0		      .byte.b	>COLOURDATA_crouch1
   1305  5570		       f1		      .byte.b	>COLOURDATA_walk1
   1306  5571		       f1		      .byte.b	>COLOURDATA_walk2
   1307  5572		       f1		      .byte.b	>COLOURDATA_handlip
   1308  5573		       f1		      .byte.b	>COLOURDATA_lookup
   1309  5574		       f1		      .byte.b	>COLOURDATA_walk3
   1310  5575		       f2		      .byte.b	>COLOURDATA_push_up_1
   1311  5576		       f2		      .byte.b	>COLOURDATA_push_up_3
   1312  5577		       f2		      .byte.b	>COLOURDATA_push_up_2
   1313  5578		       f2		      .byte.b	>COLOURDATA_push3
   1314  5579		       f2		      .byte.b	>COLOURDATA_idle3
   1315  557a		       f3		      .byte.b	>COLOURDATA_idle2
   1316  557b		       f3		      .byte.b	>COLOURDATA_push2
   1317  557c		       f3		      .byte.b	>COLOURDATA_idle1
   1318  557d		       f3		      .byte.b	>COLOURDATA_push1
   1319  557e		       f3		      .byte.b	>COLOURDATA_blink
   1320  557f		       f3		      .byte.b	>COLOURDATA_yell
   1321  5580		       f4		      .byte.b	>COLOURDATA_look2
   1322  5581		       f4		      .byte.b	>COLOURDATA_look3
   1323  5582		       f4		      .byte.b	>COLOURDATA_look1
   1324  5583		       f4		      .byte.b	>COLOURDATA_handlip2
   1325  5584		       f4		      .byte.b	>COLOURDATA_tapfoot
   1326  5585		       f5		      .byte.b	>COLOURDATA_handlip1
------- FILE BANK_PlayerFrames.asm
    199  5586
      0  5586					      CHECK_BANK_SIZE	"PLAYER_FRAMES"
      1  5586		       05 86	   .TEMP      =	* - BANK_START
 PLAYER_FRAMES (2K) SIZE =  $586 , FREE= $27a
      2  5586					      ECHO	"PLAYER_FRAMES", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5586				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  5586				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5586				  -	      ERR
      6  5586					      endif
------- FILE ./sokoboo.asm
------- FILE titleScreen.asm LEVEL 2 PASS 3
      0  5586					      include	"titleScreen.asm"
      0  5586					      NEWBANK	TITLESCREEN
      1  5f4a ????				      SEG	TITLESCREEN
      2  5800					      ORG	ORIGIN
      3  5800					      RORG	$F000
      4  5800				   BANK_START SET	*
      5  5800				   TITLESCREEN SET	ORIGIN / 2048
      6  5800				   ORIGIN     SET	ORIGIN + 2048
      7  5800				   _CURRENT_BANK SET	TITLESCREEN
      0  5800					      DEFINE_SUBROUTINE	TitleScreen
      1  5800		       00 0b	   BANK_TitleScreen =	_CURRENT_BANK
      2  5800					      SUBROUTINE
      3  5800				   TitleScreen
      3  5800
      4  5800							; Start of new frame
      5  5800
      6  5800							; Start of vertical blank processing
      7  5800
      8  5800				   TitleSequence
      9  5800
     10  5800		       a9 00		      lda	#%00000000
     11  5802		       85 4a		      sta	CTRLPF
     12  5804		       85 49		      sta	COLUBK
     13  5806
     14  5806		       a6 80		      ldx	Platform
     15  5808		       bd b6 f0 	      lda	colvec,x
     16  580b		       85 d7		      sta	colour_table
     17  580d		       bd b7 f0 	      lda	colvec+1,x
     18  5810		       85 d8		      sta	colour_table+1
     19  5812
     20  5812		       85 c7		      sta	rndHi
     21  5814		       85 c8		      sta	rnd
     22  5816
     23  5816
      0  5816					      RESYNC
      1  5816
      2  5816		       a9 02		      lda	#%10
      3  5818		       85 41		      sta	VBLANK
      4  581a
      5  581a		       a2 08		      ldx	#8
      6  581c				   .loopResync
      0  581c					      VERTICAL_SYNC
      1  581c		       a9 0e		      lda	#%1110
      2  581e		       85 42	   .VSLP1     sta	WSYNC
      3  5820		       85 40		      sta	VSYNC
      4  5822		       4a		      lsr
      5  5823		       d0 f9		      bne	.VSLP1
      8  5825
      9  5825		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  5827		       a5 80		      lda	Platform
     11  5829		       49 02		      eor	#PAL_50
     12  582b		       d0 02		      bne	.ntsc
     13  582d		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  582f				   .ntsc
     15  582f				   .loopWait
     16  582f		       85 42		      sta	WSYNC
     17  5831		       85 42		      sta	WSYNC
     18  5833		       88		      dey
     19  5834		       d0 f9		      bne	.loopWait
     20  5836		       ca		      dex
     21  5837		       d0 e3		      bne	.loopResync
     25  5839
      0  5839					      DEFINE_SUBROUTINE	RestartFrame
      1  5839		       00 0b	   BANK_RestartFrame =	_CURRENT_BANK
      2  5839					      SUBROUTINE
      3  5839				   RestartFrame
     27  5839		       a9 0e		      lda	#%1110	; VSYNC ON
     28  583b		       85 42	   .loopVSync2 sta	WSYNC
     29  583d		       85 40		      sta	VSYNC
     30  583f		       4a		      lsr
     31  5840		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     32  5842
     33  5842							;------------------------------------------------------------------
     34  5842
     35  5842		       a6 80		      ldx	Platform
     36  5844		       bc b5 fc 	      ldy	VBlankTime,x
     37  5847		       8c 96 02 	      sty	TIM64T
     38  584a
     39  584a		       85 42	   VerticalBlank sta	WSYNC
     40  584c		       ad 84 02 	      lda	INTIM
     41  584f		       d0 f9		      bne	VerticalBlank
     42  5851		       85 41		      sta	VBLANK
     43  5853
     44  5853
     45  5853							;------------------------------------------------------------------
     46  5853
     47  5853							; Do X scanlines of color-changing (our picture)
     48  5853
     49  5853		       a0 77		      ldy	#119	; this counts our scanline number
     50  5855		       a2 03	   SokoLogo   ldx	#3
     51  5857		       b1 d7	   triplet    lda	(colour_table),y
     52  5859		       85 42		      sta	WSYNC
     53  585b		       85 48		      sta	COLUPF	; 3
     54  585d
     55  585d		       b9 aa f1 	      lda	COL_0,y	; 5
     56  5860		       85 4d		      sta	PF0	; 3   @11
     57  5862		       b9 9a f2 	      lda	COL_1,y	; 5
     58  5865		       85 4e		      sta	PF1	; 3   @19
     59  5867		       b9 8a f3 	      lda	COL_2,y	; 5
     60  586a		       85 4f		      sta	PF2	; 3   @27
     61  586c
     62  586c		       b9 7a f4 	      lda	COL_3,y	; 5
     63  586f		       85 4d		      sta	PF0	; 3   @35
      0  5871					      SLEEP	2	; @37
      1  5871				   .CYCLES    SET	2
      2  5871
      3  5871				  -	      IF	.CYCLES < 2
      4  5871				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  5871				  -	      ERR
      6  5871					      ENDIF
      7  5871
      8  5871				  -	      IF	.CYCLES & 1
      9  5871				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  5871				  -	      nop	0
     11  5871				  -	      ELSE
     12  5871				  -	      bit	VSYNC
     13  5871				  -	      ENDIF
     14  5871				  -.CYCLES    SET	.CYCLES - 3
     15  5871					      ENDIF
     16  5871
     17  5871					      REPEAT	.CYCLES / 2
     18  5871		       ea		      nop
     19  5872					      REPEND
     65  5872		       b9 6a f5 	      lda	COL_4,y	; 5
     66  5875		       85 4e		      sta	PF1	; 3   @45
      0  5877					      SLEEP	3	; @45
      1  5877				   .CYCLES    SET	3
      2  5877
      3  5877				  -	      IF	.CYCLES < 2
      4  5877				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  5877				  -	      ERR
      6  5877					      ENDIF
      7  5877
      8  5877					      IF	.CYCLES & 1
      9  5877					      IFNCONST	NO_ILLEGAL_OPCODES
     10  5877		       04 00		      nop	0
     11  5879				  -	      ELSE
     12  5879				  -	      bit	VSYNC
     13  5879					      ENDIF
     14  5879				   .CYCLES    SET	.CYCLES - 3
     15  5879					      ENDIF
     16  5879
     17  5879				  -	      REPEAT	.CYCLES / 2
     18  5879				  -	      nop
     19  5879					      REPEND
     68  5879		       b9 5a f6 	      lda	COL_5,y	; 5
     69  587c		       85 4f		      sta	PF2	; 3
     70  587e
     71  587e		       88		      dey		; 2
     72  587f		       ca		      dex		; 2
     73  5880		       d0 d5		      bne	triplet	; 2(3)
     74  5882
     75  5882		       c0 ff		      cpy	#-1	; 2
     76  5884		       d0 cf		      bne	SokoLogo	; 2(3)
     77  5886
     78  5886		       a9 00		      lda	#0
     79  5888		       85 4d		      sta	PF0
     80  588a		       85 4e		      sta	PF1
     81  588c		       85 4f		      sta	PF2
     82  588e
     83  588e		       a6 80		      ldx	Platform
     84  5890		       bd b2 f0 	      lda	OverscanTime2,x
     85  5893		       8d 96 02 	      sta	TIM64T
     86  5896
     87  5896				  -	      if	0
     88  5896				  -	      sta	WSYNC
     89  5896				  -	      sta	WSYNC
     90  5896				  -	      sta	WSYNC
     91  5896				  -	      sta	WSYNC
     92  5896				  -	      sta	WSYNC
     93  5896				  -	      SLEEP	8
     94  5896				  -	      jsr	SokoScreen
     95  5896				  -
     96  5896				  -	      lda	#0
     97  5896				  -	      sta	BoardScrollX
     98  5896				  -	      sta	BoardScrollY
     99  5896					      endif
    100  5896
    101  5896							;		ldy #63
    102  5896							;bot2		 sta WSYNC
    103  5896							;		dey
    104  5896							;		bpl bot2
    105  5896
    106  5896							;--------------------------------------------------------------------------
    107  5896
    108  5896							;		lda #0
    109  5896							;		sta PF0
    110  5896							;		sta PF1
    111  5896							;		sta PF2
    112  5896
    113  5896
      0  5896					      NEXT_RANDOM
      1  5896
      2  5896		       a5 c8		      lda	rnd
      3  5898		       4a		      lsr
      4  5899					      IFCONST	rndHi
      5  5899		       66 c7		      ror	rndHi
      6  589b					      ENDIF
      7  589b		       90 02		      bcc	.skipEOR
      8  589d		       49 b4		      eor	#RND_EOR_VAL
      9  589f				   .skipEOR
     10  589f		       85 c8		      sta	rnd
    115  58a1
    116  58a1							; D1 VBLANK turns off beam
    117  58a1							; It needs to be turned on 37 scanlines later
    118  58a1
    119  58a1				   oscan
    120  58a1		       ad 84 02 	      lda	INTIM
    121  58a4		       d0 fb		      bne	oscan
    122  58a6
    123  58a6		       a9 42		      lda	#%01000010	; bit6 is not required
    124  58a8		       85 41		      sta	VBLANK	; end of screen - enter blanking
    125  58aa
    126  58aa		       a5 4c		      lda	INPT4
    127  58ac		       10 03		      bpl	ret
    128  58ae
    129  58ae		       4c 39 f0 	      jmp	RestartFrame
    130  58b1
    131  58b1		       60	   ret	      rts
    132  58b2
    133  58b2				   OverscanTime2
    134  58b2		       85 85		      .byte.b	133, 133
    135  58b4		       8b 8b		      .byte.b	139, 139
    136  58b6
    137  58b6				   colvec
    138  58b6		       32 f1 ba f0	      .word.w	colr_ntsc, colr_pal
    139  58ba
    140  58ba
    141  58ba					      MAC	lumtable
    142  58ba							; {4} MIN LUM 1
    143  58ba							; {5} MIN LUM 2
    144  58ba							; {6} MIN LUM 3
    145  58ba
    146  58ba				   .LUM1      SET	{4}*256
    147  58ba				   .LUM2      SET	{5}*256
    148  58ba				   .LUM3      SET	{6}*256
    149  58ba
    150  58ba				   .STEP1     =	(256*({7}-{4}))/40
    151  58ba				   .STEP2     =	(256*({8}-{5}))/40
    152  58ba				   .STEP3     =	(256*({9}-{6}))/40
    153  58ba
    154  58ba					      REPEAT	40
    155  58ba					      .byte	{1}+(.LUM1/256)
    156  58ba					      .byte	{2}+(.LUM2/256)
    157  58ba					      .byte	{3}+(.LUM3/256)
    158  58ba				   .LUM1      SET	.LUM1 + .STEP1
    159  58ba				   .LUM2      SET	.LUM2 + .STEP2
    160  58ba				   .LUM3      SET	.LUM3 + .STEP3
    161  58ba					      REPEND
    162  58ba					      ENDM		;{1}{2}{3} base colours
    163  58ba
    164  58ba							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
      0  58ba				   colr_pal   LUMTABLE	$b0, $70, $40, 6,7,8, $C,$E,$E
      1  58ba
      2  58ba
      3  58ba
      4  58ba
      5  58ba				   .LUM1      SET	6*256
      6  58ba				   .LUM2      SET	7*256
      7  58ba				   .LUM3      SET	8*256
      8  58ba
      9  58ba		       00 26	   .STEP1     =	(256*($C-6))/40
     10  58ba		       00 2c	   .STEP2     =	(256*($E-7))/40
     11  58ba		       00 26	   .STEP3     =	(256*($E-8))/40
     12  58ba
     13  58ba					      REPEAT	40
     14  58ba		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58bb		       77		      .byte.b	$70+(.LUM2/256)
     16  58bc		       48		      .byte.b	$40+(.LUM3/256)
     17  58bc				   .LUM1      SET	.LUM1 + .STEP1
     18  58bc				   .LUM2      SET	.LUM2 + .STEP2
     19  58bc				   .LUM3      SET	.LUM3 + .STEP3
     13  58bc					      REPEND
     14  58bd		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58be		       77		      .byte.b	$70+(.LUM2/256)
     16  58bf		       48		      .byte.b	$40+(.LUM3/256)
     17  58bf				   .LUM1      SET	.LUM1 + .STEP1
     18  58bf				   .LUM2      SET	.LUM2 + .STEP2
     19  58bf				   .LUM3      SET	.LUM3 + .STEP3
     13  58bf					      REPEND
     14  58c0		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58c1		       77		      .byte.b	$70+(.LUM2/256)
     16  58c2		       48		      .byte.b	$40+(.LUM3/256)
     17  58c2				   .LUM1      SET	.LUM1 + .STEP1
     18  58c2				   .LUM2      SET	.LUM2 + .STEP2
     19  58c2				   .LUM3      SET	.LUM3 + .STEP3
     13  58c2					      REPEND
     14  58c3		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58c4		       77		      .byte.b	$70+(.LUM2/256)
     16  58c5		       48		      .byte.b	$40+(.LUM3/256)
     17  58c5				   .LUM1      SET	.LUM1 + .STEP1
     18  58c5				   .LUM2      SET	.LUM2 + .STEP2
     19  58c5				   .LUM3      SET	.LUM3 + .STEP3
     13  58c5					      REPEND
     14  58c6		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58c7		       77		      .byte.b	$70+(.LUM2/256)
     16  58c8		       48		      .byte.b	$40+(.LUM3/256)
     17  58c8				   .LUM1      SET	.LUM1 + .STEP1
     18  58c8				   .LUM2      SET	.LUM2 + .STEP2
     19  58c8				   .LUM3      SET	.LUM3 + .STEP3
     13  58c8					      REPEND
     14  58c9		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58ca		       77		      .byte.b	$70+(.LUM2/256)
     16  58cb		       48		      .byte.b	$40+(.LUM3/256)
     17  58cb				   .LUM1      SET	.LUM1 + .STEP1
     18  58cb				   .LUM2      SET	.LUM2 + .STEP2
     19  58cb				   .LUM3      SET	.LUM3 + .STEP3
     13  58cb					      REPEND
     14  58cc		       b6		      .byte.b	$b0+(.LUM1/256)
     15  58cd		       78		      .byte.b	$70+(.LUM2/256)
     16  58ce		       48		      .byte.b	$40+(.LUM3/256)
     17  58ce				   .LUM1      SET	.LUM1 + .STEP1
     18  58ce				   .LUM2      SET	.LUM2 + .STEP2
     19  58ce				   .LUM3      SET	.LUM3 + .STEP3
     13  58ce					      REPEND
     14  58cf		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58d0		       78		      .byte.b	$70+(.LUM2/256)
     16  58d1		       49		      .byte.b	$40+(.LUM3/256)
     17  58d1				   .LUM1      SET	.LUM1 + .STEP1
     18  58d1				   .LUM2      SET	.LUM2 + .STEP2
     19  58d1				   .LUM3      SET	.LUM3 + .STEP3
     13  58d1					      REPEND
     14  58d2		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58d3		       78		      .byte.b	$70+(.LUM2/256)
     16  58d4		       49		      .byte.b	$40+(.LUM3/256)
     17  58d4				   .LUM1      SET	.LUM1 + .STEP1
     18  58d4				   .LUM2      SET	.LUM2 + .STEP2
     19  58d4				   .LUM3      SET	.LUM3 + .STEP3
     13  58d4					      REPEND
     14  58d5		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58d6		       78		      .byte.b	$70+(.LUM2/256)
     16  58d7		       49		      .byte.b	$40+(.LUM3/256)
     17  58d7				   .LUM1      SET	.LUM1 + .STEP1
     18  58d7				   .LUM2      SET	.LUM2 + .STEP2
     19  58d7				   .LUM3      SET	.LUM3 + .STEP3
     13  58d7					      REPEND
     14  58d8		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58d9		       78		      .byte.b	$70+(.LUM2/256)
     16  58da		       49		      .byte.b	$40+(.LUM3/256)
     17  58da				   .LUM1      SET	.LUM1 + .STEP1
     18  58da				   .LUM2      SET	.LUM2 + .STEP2
     19  58da				   .LUM3      SET	.LUM3 + .STEP3
     13  58da					      REPEND
     14  58db		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58dc		       78		      .byte.b	$70+(.LUM2/256)
     16  58dd		       49		      .byte.b	$40+(.LUM3/256)
     17  58dd				   .LUM1      SET	.LUM1 + .STEP1
     18  58dd				   .LUM2      SET	.LUM2 + .STEP2
     19  58dd				   .LUM3      SET	.LUM3 + .STEP3
     13  58dd					      REPEND
     14  58de		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58df		       79		      .byte.b	$70+(.LUM2/256)
     16  58e0		       49		      .byte.b	$40+(.LUM3/256)
     17  58e0				   .LUM1      SET	.LUM1 + .STEP1
     18  58e0				   .LUM2      SET	.LUM2 + .STEP2
     19  58e0				   .LUM3      SET	.LUM3 + .STEP3
     13  58e0					      REPEND
     14  58e1		       b7		      .byte.b	$b0+(.LUM1/256)
     15  58e2		       79		      .byte.b	$70+(.LUM2/256)
     16  58e3		       49		      .byte.b	$40+(.LUM3/256)
     17  58e3				   .LUM1      SET	.LUM1 + .STEP1
     18  58e3				   .LUM2      SET	.LUM2 + .STEP2
     19  58e3				   .LUM3      SET	.LUM3 + .STEP3
     13  58e3					      REPEND
     14  58e4		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58e5		       79		      .byte.b	$70+(.LUM2/256)
     16  58e6		       4a		      .byte.b	$40+(.LUM3/256)
     17  58e6				   .LUM1      SET	.LUM1 + .STEP1
     18  58e6				   .LUM2      SET	.LUM2 + .STEP2
     19  58e6				   .LUM3      SET	.LUM3 + .STEP3
     13  58e6					      REPEND
     14  58e7		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58e8		       79		      .byte.b	$70+(.LUM2/256)
     16  58e9		       4a		      .byte.b	$40+(.LUM3/256)
     17  58e9				   .LUM1      SET	.LUM1 + .STEP1
     18  58e9				   .LUM2      SET	.LUM2 + .STEP2
     19  58e9				   .LUM3      SET	.LUM3 + .STEP3
     13  58e9					      REPEND
     14  58ea		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58eb		       79		      .byte.b	$70+(.LUM2/256)
     16  58ec		       4a		      .byte.b	$40+(.LUM3/256)
     17  58ec				   .LUM1      SET	.LUM1 + .STEP1
     18  58ec				   .LUM2      SET	.LUM2 + .STEP2
     19  58ec				   .LUM3      SET	.LUM3 + .STEP3
     13  58ec					      REPEND
     14  58ed		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58ee		       79		      .byte.b	$70+(.LUM2/256)
     16  58ef		       4a		      .byte.b	$40+(.LUM3/256)
     17  58ef				   .LUM1      SET	.LUM1 + .STEP1
     18  58ef				   .LUM2      SET	.LUM2 + .STEP2
     19  58ef				   .LUM3      SET	.LUM3 + .STEP3
     13  58ef					      REPEND
     14  58f0		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58f1		       7a		      .byte.b	$70+(.LUM2/256)
     16  58f2		       4a		      .byte.b	$40+(.LUM3/256)
     17  58f2				   .LUM1      SET	.LUM1 + .STEP1
     18  58f2				   .LUM2      SET	.LUM2 + .STEP2
     19  58f2				   .LUM3      SET	.LUM3 + .STEP3
     13  58f2					      REPEND
     14  58f3		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58f4		       7a		      .byte.b	$70+(.LUM2/256)
     16  58f5		       4a		      .byte.b	$40+(.LUM3/256)
     17  58f5				   .LUM1      SET	.LUM1 + .STEP1
     18  58f5				   .LUM2      SET	.LUM2 + .STEP2
     19  58f5				   .LUM3      SET	.LUM3 + .STEP3
     13  58f5					      REPEND
     14  58f6		       b8		      .byte.b	$b0+(.LUM1/256)
     15  58f7		       7a		      .byte.b	$70+(.LUM2/256)
     16  58f8		       4a		      .byte.b	$40+(.LUM3/256)
     17  58f8				   .LUM1      SET	.LUM1 + .STEP1
     18  58f8				   .LUM2      SET	.LUM2 + .STEP2
     19  58f8				   .LUM3      SET	.LUM3 + .STEP3
     13  58f8					      REPEND
     14  58f9		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58fa		       7a		      .byte.b	$70+(.LUM2/256)
     16  58fb		       4b		      .byte.b	$40+(.LUM3/256)
     17  58fb				   .LUM1      SET	.LUM1 + .STEP1
     18  58fb				   .LUM2      SET	.LUM2 + .STEP2
     19  58fb				   .LUM3      SET	.LUM3 + .STEP3
     13  58fb					      REPEND
     14  58fc		       b9		      .byte.b	$b0+(.LUM1/256)
     15  58fd		       7a		      .byte.b	$70+(.LUM2/256)
     16  58fe		       4b		      .byte.b	$40+(.LUM3/256)
     17  58fe				   .LUM1      SET	.LUM1 + .STEP1
     18  58fe				   .LUM2      SET	.LUM2 + .STEP2
     19  58fe				   .LUM3      SET	.LUM3 + .STEP3
     13  58fe					      REPEND
     14  58ff		       b9		      .byte.b	$b0+(.LUM1/256)
     15  5900		       7a		      .byte.b	$70+(.LUM2/256)
     16  5901		       4b		      .byte.b	$40+(.LUM3/256)
     17  5901				   .LUM1      SET	.LUM1 + .STEP1
     18  5901				   .LUM2      SET	.LUM2 + .STEP2
     19  5901				   .LUM3      SET	.LUM3 + .STEP3
     13  5901					      REPEND
     14  5902		       b9		      .byte.b	$b0+(.LUM1/256)
     15  5903		       7b		      .byte.b	$70+(.LUM2/256)
     16  5904		       4b		      .byte.b	$40+(.LUM3/256)
     17  5904				   .LUM1      SET	.LUM1 + .STEP1
     18  5904				   .LUM2      SET	.LUM2 + .STEP2
     19  5904				   .LUM3      SET	.LUM3 + .STEP3
     13  5904					      REPEND
     14  5905		       b9		      .byte.b	$b0+(.LUM1/256)
     15  5906		       7b		      .byte.b	$70+(.LUM2/256)
     16  5907		       4b		      .byte.b	$40+(.LUM3/256)
     17  5907				   .LUM1      SET	.LUM1 + .STEP1
     18  5907				   .LUM2      SET	.LUM2 + .STEP2
     19  5907				   .LUM3      SET	.LUM3 + .STEP3
     13  5907					      REPEND
     14  5908		       b9		      .byte.b	$b0+(.LUM1/256)
     15  5909		       7b		      .byte.b	$70+(.LUM2/256)
     16  590a		       4b		      .byte.b	$40+(.LUM3/256)
     17  590a				   .LUM1      SET	.LUM1 + .STEP1
     18  590a				   .LUM2      SET	.LUM2 + .STEP2
     19  590a				   .LUM3      SET	.LUM3 + .STEP3
     13  590a					      REPEND
     14  590b		       ba		      .byte.b	$b0+(.LUM1/256)
     15  590c		       7b		      .byte.b	$70+(.LUM2/256)
     16  590d		       4c		      .byte.b	$40+(.LUM3/256)
     17  590d				   .LUM1      SET	.LUM1 + .STEP1
     18  590d				   .LUM2      SET	.LUM2 + .STEP2
     19  590d				   .LUM3      SET	.LUM3 + .STEP3
     13  590d					      REPEND
     14  590e		       ba		      .byte.b	$b0+(.LUM1/256)
     15  590f		       7b		      .byte.b	$70+(.LUM2/256)
     16  5910		       4c		      .byte.b	$40+(.LUM3/256)
     17  5910				   .LUM1      SET	.LUM1 + .STEP1
     18  5910				   .LUM2      SET	.LUM2 + .STEP2
     19  5910				   .LUM3      SET	.LUM3 + .STEP3
     13  5910					      REPEND
     14  5911		       ba		      .byte.b	$b0+(.LUM1/256)
     15  5912		       7b		      .byte.b	$70+(.LUM2/256)
     16  5913		       4c		      .byte.b	$40+(.LUM3/256)
     17  5913				   .LUM1      SET	.LUM1 + .STEP1
     18  5913				   .LUM2      SET	.LUM2 + .STEP2
     19  5913				   .LUM3      SET	.LUM3 + .STEP3
     13  5913					      REPEND
     14  5914		       ba		      .byte.b	$b0+(.LUM1/256)
     15  5915		       7c		      .byte.b	$70+(.LUM2/256)
     16  5916		       4c		      .byte.b	$40+(.LUM3/256)
     17  5916				   .LUM1      SET	.LUM1 + .STEP1
     18  5916				   .LUM2      SET	.LUM2 + .STEP2
     19  5916				   .LUM3      SET	.LUM3 + .STEP3
     13  5916					      REPEND
     14  5917		       ba		      .byte.b	$b0+(.LUM1/256)
     15  5918		       7c		      .byte.b	$70+(.LUM2/256)
     16  5919		       4c		      .byte.b	$40+(.LUM3/256)
     17  5919				   .LUM1      SET	.LUM1 + .STEP1
     18  5919				   .LUM2      SET	.LUM2 + .STEP2
     19  5919				   .LUM3      SET	.LUM3 + .STEP3
     13  5919					      REPEND
     14  591a		       ba		      .byte.b	$b0+(.LUM1/256)
     15  591b		       7c		      .byte.b	$70+(.LUM2/256)
     16  591c		       4c		      .byte.b	$40+(.LUM3/256)
     17  591c				   .LUM1      SET	.LUM1 + .STEP1
     18  591c				   .LUM2      SET	.LUM2 + .STEP2
     19  591c				   .LUM3      SET	.LUM3 + .STEP3
     13  591c					      REPEND
     14  591d		       ba		      .byte.b	$b0+(.LUM1/256)
     15  591e		       7c		      .byte.b	$70+(.LUM2/256)
     16  591f		       4c		      .byte.b	$40+(.LUM3/256)
     17  591f				   .LUM1      SET	.LUM1 + .STEP1
     18  591f				   .LUM2      SET	.LUM2 + .STEP2
     19  591f				   .LUM3      SET	.LUM3 + .STEP3
     13  591f					      REPEND
     14  5920		       bb		      .byte.b	$b0+(.LUM1/256)
     15  5921		       7c		      .byte.b	$70+(.LUM2/256)
     16  5922		       4d		      .byte.b	$40+(.LUM3/256)
     17  5922				   .LUM1      SET	.LUM1 + .STEP1
     18  5922				   .LUM2      SET	.LUM2 + .STEP2
     19  5922				   .LUM3      SET	.LUM3 + .STEP3
     13  5922					      REPEND
     14  5923		       bb		      .byte.b	$b0+(.LUM1/256)
     15  5924		       7d		      .byte.b	$70+(.LUM2/256)
     16  5925		       4d		      .byte.b	$40+(.LUM3/256)
     17  5925				   .LUM1      SET	.LUM1 + .STEP1
     18  5925				   .LUM2      SET	.LUM2 + .STEP2
     19  5925				   .LUM3      SET	.LUM3 + .STEP3
     13  5925					      REPEND
     14  5926		       bb		      .byte.b	$b0+(.LUM1/256)
     15  5927		       7d		      .byte.b	$70+(.LUM2/256)
     16  5928		       4d		      .byte.b	$40+(.LUM3/256)
     17  5928				   .LUM1      SET	.LUM1 + .STEP1
     18  5928				   .LUM2      SET	.LUM2 + .STEP2
     19  5928				   .LUM3      SET	.LUM3 + .STEP3
     13  5928					      REPEND
     14  5929		       bb		      .byte.b	$b0+(.LUM1/256)
     15  592a		       7d		      .byte.b	$70+(.LUM2/256)
     16  592b		       4d		      .byte.b	$40+(.LUM3/256)
     17  592b				   .LUM1      SET	.LUM1 + .STEP1
     18  592b				   .LUM2      SET	.LUM2 + .STEP2
     19  592b				   .LUM3      SET	.LUM3 + .STEP3
     13  592b					      REPEND
     14  592c		       bb		      .byte.b	$b0+(.LUM1/256)
     15  592d		       7d		      .byte.b	$70+(.LUM2/256)
     16  592e		       4d		      .byte.b	$40+(.LUM3/256)
     17  592e				   .LUM1      SET	.LUM1 + .STEP1
     18  592e				   .LUM2      SET	.LUM2 + .STEP2
     19  592e				   .LUM3      SET	.LUM3 + .STEP3
     13  592e					      REPEND
     14  592f		       bb		      .byte.b	$b0+(.LUM1/256)
     15  5930		       7d		      .byte.b	$70+(.LUM2/256)
     16  5931		       4d		      .byte.b	$40+(.LUM3/256)
     17  5931				   .LUM1      SET	.LUM1 + .STEP1
     18  5931				   .LUM2      SET	.LUM2 + .STEP2
     19  5931				   .LUM3      SET	.LUM3 + .STEP3
     20  5932					      REPEND
      0  5932				   colr_ntsc  LUMTABLE	$90,$B0,$20,5,6,7,$C,$E,$E
      1  5932
      2  5932
      3  5932
      4  5932
      5  5932				   .LUM1      SET	5*256
      6  5932				   .LUM2      SET	6*256
      7  5932				   .LUM3      SET	7*256
      8  5932
      9  5932		       00 2c	   .STEP1     =	(256*($C-5))/40
     10  5932		       00 33	   .STEP2     =	(256*($E-6))/40
     11  5932		       00 2c	   .STEP3     =	(256*($E-7))/40
     12  5932
     13  5932					      REPEAT	40
     14  5932		       95		      .byte.b	$90+(.LUM1/256)
     15  5933		       b6		      .byte.b	$B0+(.LUM2/256)
     16  5934		       27		      .byte.b	$20+(.LUM3/256)
     17  5934				   .LUM1      SET	.LUM1 + .STEP1
     18  5934				   .LUM2      SET	.LUM2 + .STEP2
     19  5934				   .LUM3      SET	.LUM3 + .STEP3
     13  5934					      REPEND
     14  5935		       95		      .byte.b	$90+(.LUM1/256)
     15  5936		       b6		      .byte.b	$B0+(.LUM2/256)
     16  5937		       27		      .byte.b	$20+(.LUM3/256)
     17  5937				   .LUM1      SET	.LUM1 + .STEP1
     18  5937				   .LUM2      SET	.LUM2 + .STEP2
     19  5937				   .LUM3      SET	.LUM3 + .STEP3
     13  5937					      REPEND
     14  5938		       95		      .byte.b	$90+(.LUM1/256)
     15  5939		       b6		      .byte.b	$B0+(.LUM2/256)
     16  593a		       27		      .byte.b	$20+(.LUM3/256)
     17  593a				   .LUM1      SET	.LUM1 + .STEP1
     18  593a				   .LUM2      SET	.LUM2 + .STEP2
     19  593a				   .LUM3      SET	.LUM3 + .STEP3
     13  593a					      REPEND
     14  593b		       95		      .byte.b	$90+(.LUM1/256)
     15  593c		       b6		      .byte.b	$B0+(.LUM2/256)
     16  593d		       27		      .byte.b	$20+(.LUM3/256)
     17  593d				   .LUM1      SET	.LUM1 + .STEP1
     18  593d				   .LUM2      SET	.LUM2 + .STEP2
     19  593d				   .LUM3      SET	.LUM3 + .STEP3
     13  593d					      REPEND
     14  593e		       95		      .byte.b	$90+(.LUM1/256)
     15  593f		       b6		      .byte.b	$B0+(.LUM2/256)
     16  5940		       27		      .byte.b	$20+(.LUM3/256)
     17  5940				   .LUM1      SET	.LUM1 + .STEP1
     18  5940				   .LUM2      SET	.LUM2 + .STEP2
     19  5940				   .LUM3      SET	.LUM3 + .STEP3
     13  5940					      REPEND
     14  5941		       95		      .byte.b	$90+(.LUM1/256)
     15  5942		       b6		      .byte.b	$B0+(.LUM2/256)
     16  5943		       27		      .byte.b	$20+(.LUM3/256)
     17  5943				   .LUM1      SET	.LUM1 + .STEP1
     18  5943				   .LUM2      SET	.LUM2 + .STEP2
     19  5943				   .LUM3      SET	.LUM3 + .STEP3
     13  5943					      REPEND
     14  5944		       96		      .byte.b	$90+(.LUM1/256)
     15  5945		       b7		      .byte.b	$B0+(.LUM2/256)
     16  5946		       28		      .byte.b	$20+(.LUM3/256)
     17  5946				   .LUM1      SET	.LUM1 + .STEP1
     18  5946				   .LUM2      SET	.LUM2 + .STEP2
     19  5946				   .LUM3      SET	.LUM3 + .STEP3
     13  5946					      REPEND
     14  5947		       96		      .byte.b	$90+(.LUM1/256)
     15  5948		       b7		      .byte.b	$B0+(.LUM2/256)
     16  5949		       28		      .byte.b	$20+(.LUM3/256)
     17  5949				   .LUM1      SET	.LUM1 + .STEP1
     18  5949				   .LUM2      SET	.LUM2 + .STEP2
     19  5949				   .LUM3      SET	.LUM3 + .STEP3
     13  5949					      REPEND
     14  594a		       96		      .byte.b	$90+(.LUM1/256)
     15  594b		       b7		      .byte.b	$B0+(.LUM2/256)
     16  594c		       28		      .byte.b	$20+(.LUM3/256)
     17  594c				   .LUM1      SET	.LUM1 + .STEP1
     18  594c				   .LUM2      SET	.LUM2 + .STEP2
     19  594c				   .LUM3      SET	.LUM3 + .STEP3
     13  594c					      REPEND
     14  594d		       96		      .byte.b	$90+(.LUM1/256)
     15  594e		       b7		      .byte.b	$B0+(.LUM2/256)
     16  594f		       28		      .byte.b	$20+(.LUM3/256)
     17  594f				   .LUM1      SET	.LUM1 + .STEP1
     18  594f				   .LUM2      SET	.LUM2 + .STEP2
     19  594f				   .LUM3      SET	.LUM3 + .STEP3
     13  594f					      REPEND
     14  5950		       96		      .byte.b	$90+(.LUM1/256)
     15  5951		       b7		      .byte.b	$B0+(.LUM2/256)
     16  5952		       28		      .byte.b	$20+(.LUM3/256)
     17  5952				   .LUM1      SET	.LUM1 + .STEP1
     18  5952				   .LUM2      SET	.LUM2 + .STEP2
     19  5952				   .LUM3      SET	.LUM3 + .STEP3
     13  5952					      REPEND
     14  5953		       96		      .byte.b	$90+(.LUM1/256)
     15  5954		       b8		      .byte.b	$B0+(.LUM2/256)
     16  5955		       28		      .byte.b	$20+(.LUM3/256)
     17  5955				   .LUM1      SET	.LUM1 + .STEP1
     18  5955				   .LUM2      SET	.LUM2 + .STEP2
     19  5955				   .LUM3      SET	.LUM3 + .STEP3
     13  5955					      REPEND
     14  5956		       97		      .byte.b	$90+(.LUM1/256)
     15  5957		       b8		      .byte.b	$B0+(.LUM2/256)
     16  5958		       29		      .byte.b	$20+(.LUM3/256)
     17  5958				   .LUM1      SET	.LUM1 + .STEP1
     18  5958				   .LUM2      SET	.LUM2 + .STEP2
     19  5958				   .LUM3      SET	.LUM3 + .STEP3
     13  5958					      REPEND
     14  5959		       97		      .byte.b	$90+(.LUM1/256)
     15  595a		       b8		      .byte.b	$B0+(.LUM2/256)
     16  595b		       29		      .byte.b	$20+(.LUM3/256)
     17  595b				   .LUM1      SET	.LUM1 + .STEP1
     18  595b				   .LUM2      SET	.LUM2 + .STEP2
     19  595b				   .LUM3      SET	.LUM3 + .STEP3
     13  595b					      REPEND
     14  595c		       97		      .byte.b	$90+(.LUM1/256)
     15  595d		       b8		      .byte.b	$B0+(.LUM2/256)
     16  595e		       29		      .byte.b	$20+(.LUM3/256)
     17  595e				   .LUM1      SET	.LUM1 + .STEP1
     18  595e				   .LUM2      SET	.LUM2 + .STEP2
     19  595e				   .LUM3      SET	.LUM3 + .STEP3
     13  595e					      REPEND
     14  595f		       97		      .byte.b	$90+(.LUM1/256)
     15  5960		       b8		      .byte.b	$B0+(.LUM2/256)
     16  5961		       29		      .byte.b	$20+(.LUM3/256)
     17  5961				   .LUM1      SET	.LUM1 + .STEP1
     18  5961				   .LUM2      SET	.LUM2 + .STEP2
     19  5961				   .LUM3      SET	.LUM3 + .STEP3
     13  5961					      REPEND
     14  5962		       97		      .byte.b	$90+(.LUM1/256)
     15  5963		       b9		      .byte.b	$B0+(.LUM2/256)
     16  5964		       29		      .byte.b	$20+(.LUM3/256)
     17  5964				   .LUM1      SET	.LUM1 + .STEP1
     18  5964				   .LUM2      SET	.LUM2 + .STEP2
     19  5964				   .LUM3      SET	.LUM3 + .STEP3
     13  5964					      REPEND
     14  5965		       97		      .byte.b	$90+(.LUM1/256)
     15  5966		       b9		      .byte.b	$B0+(.LUM2/256)
     16  5967		       29		      .byte.b	$20+(.LUM3/256)
     17  5967				   .LUM1      SET	.LUM1 + .STEP1
     18  5967				   .LUM2      SET	.LUM2 + .STEP2
     19  5967				   .LUM3      SET	.LUM3 + .STEP3
     13  5967					      REPEND
     14  5968		       98		      .byte.b	$90+(.LUM1/256)
     15  5969		       b9		      .byte.b	$B0+(.LUM2/256)
     16  596a		       2a		      .byte.b	$20+(.LUM3/256)
     17  596a				   .LUM1      SET	.LUM1 + .STEP1
     18  596a				   .LUM2      SET	.LUM2 + .STEP2
     19  596a				   .LUM3      SET	.LUM3 + .STEP3
     13  596a					      REPEND
     14  596b		       98		      .byte.b	$90+(.LUM1/256)
     15  596c		       b9		      .byte.b	$B0+(.LUM2/256)
     16  596d		       2a		      .byte.b	$20+(.LUM3/256)
     17  596d				   .LUM1      SET	.LUM1 + .STEP1
     18  596d				   .LUM2      SET	.LUM2 + .STEP2
     19  596d				   .LUM3      SET	.LUM3 + .STEP3
     13  596d					      REPEND
     14  596e		       98		      .byte.b	$90+(.LUM1/256)
     15  596f		       b9		      .byte.b	$B0+(.LUM2/256)
     16  5970		       2a		      .byte.b	$20+(.LUM3/256)
     17  5970				   .LUM1      SET	.LUM1 + .STEP1
     18  5970				   .LUM2      SET	.LUM2 + .STEP2
     19  5970				   .LUM3      SET	.LUM3 + .STEP3
     13  5970					      REPEND
     14  5971		       98		      .byte.b	$90+(.LUM1/256)
     15  5972		       ba		      .byte.b	$B0+(.LUM2/256)
     16  5973		       2a		      .byte.b	$20+(.LUM3/256)
     17  5973				   .LUM1      SET	.LUM1 + .STEP1
     18  5973				   .LUM2      SET	.LUM2 + .STEP2
     19  5973				   .LUM3      SET	.LUM3 + .STEP3
     13  5973					      REPEND
     14  5974		       98		      .byte.b	$90+(.LUM1/256)
     15  5975		       ba		      .byte.b	$B0+(.LUM2/256)
     16  5976		       2a		      .byte.b	$20+(.LUM3/256)
     17  5976				   .LUM1      SET	.LUM1 + .STEP1
     18  5976				   .LUM2      SET	.LUM2 + .STEP2
     19  5976				   .LUM3      SET	.LUM3 + .STEP3
     13  5976					      REPEND
     14  5977		       98		      .byte.b	$90+(.LUM1/256)
     15  5978		       ba		      .byte.b	$B0+(.LUM2/256)
     16  5979		       2a		      .byte.b	$20+(.LUM3/256)
     17  5979				   .LUM1      SET	.LUM1 + .STEP1
     18  5979				   .LUM2      SET	.LUM2 + .STEP2
     19  5979				   .LUM3      SET	.LUM3 + .STEP3
     13  5979					      REPEND
     14  597a		       99		      .byte.b	$90+(.LUM1/256)
     15  597b		       ba		      .byte.b	$B0+(.LUM2/256)
     16  597c		       2b		      .byte.b	$20+(.LUM3/256)
     17  597c				   .LUM1      SET	.LUM1 + .STEP1
     18  597c				   .LUM2      SET	.LUM2 + .STEP2
     19  597c				   .LUM3      SET	.LUM3 + .STEP3
     13  597c					      REPEND
     14  597d		       99		      .byte.b	$90+(.LUM1/256)
     15  597e		       ba		      .byte.b	$B0+(.LUM2/256)
     16  597f		       2b		      .byte.b	$20+(.LUM3/256)
     17  597f				   .LUM1      SET	.LUM1 + .STEP1
     18  597f				   .LUM2      SET	.LUM2 + .STEP2
     19  597f				   .LUM3      SET	.LUM3 + .STEP3
     13  597f					      REPEND
     14  5980		       99		      .byte.b	$90+(.LUM1/256)
     15  5981		       bb		      .byte.b	$B0+(.LUM2/256)
     16  5982		       2b		      .byte.b	$20+(.LUM3/256)
     17  5982				   .LUM1      SET	.LUM1 + .STEP1
     18  5982				   .LUM2      SET	.LUM2 + .STEP2
     19  5982				   .LUM3      SET	.LUM3 + .STEP3
     13  5982					      REPEND
     14  5983		       99		      .byte.b	$90+(.LUM1/256)
     15  5984		       bb		      .byte.b	$B0+(.LUM2/256)
     16  5985		       2b		      .byte.b	$20+(.LUM3/256)
     17  5985				   .LUM1      SET	.LUM1 + .STEP1
     18  5985				   .LUM2      SET	.LUM2 + .STEP2
     19  5985				   .LUM3      SET	.LUM3 + .STEP3
     13  5985					      REPEND
     14  5986		       99		      .byte.b	$90+(.LUM1/256)
     15  5987		       bb		      .byte.b	$B0+(.LUM2/256)
     16  5988		       2b		      .byte.b	$20+(.LUM3/256)
     17  5988				   .LUM1      SET	.LUM1 + .STEP1
     18  5988				   .LUM2      SET	.LUM2 + .STEP2
     19  5988				   .LUM3      SET	.LUM3 + .STEP3
     13  5988					      REPEND
     14  5989		       99		      .byte.b	$90+(.LUM1/256)
     15  598a		       bb		      .byte.b	$B0+(.LUM2/256)
     16  598b		       2b		      .byte.b	$20+(.LUM3/256)
     17  598b				   .LUM1      SET	.LUM1 + .STEP1
     18  598b				   .LUM2      SET	.LUM2 + .STEP2
     19  598b				   .LUM3      SET	.LUM3 + .STEP3
     13  598b					      REPEND
     14  598c		       9a		      .byte.b	$90+(.LUM1/256)
     15  598d		       bb		      .byte.b	$B0+(.LUM2/256)
     16  598e		       2c		      .byte.b	$20+(.LUM3/256)
     17  598e				   .LUM1      SET	.LUM1 + .STEP1
     18  598e				   .LUM2      SET	.LUM2 + .STEP2
     19  598e				   .LUM3      SET	.LUM3 + .STEP3
     13  598e					      REPEND
     14  598f		       9a		      .byte.b	$90+(.LUM1/256)
     15  5990		       bc		      .byte.b	$B0+(.LUM2/256)
     16  5991		       2c		      .byte.b	$20+(.LUM3/256)
     17  5991				   .LUM1      SET	.LUM1 + .STEP1
     18  5991				   .LUM2      SET	.LUM2 + .STEP2
     19  5991				   .LUM3      SET	.LUM3 + .STEP3
     13  5991					      REPEND
     14  5992		       9a		      .byte.b	$90+(.LUM1/256)
     15  5993		       bc		      .byte.b	$B0+(.LUM2/256)
     16  5994		       2c		      .byte.b	$20+(.LUM3/256)
     17  5994				   .LUM1      SET	.LUM1 + .STEP1
     18  5994				   .LUM2      SET	.LUM2 + .STEP2
     19  5994				   .LUM3      SET	.LUM3 + .STEP3
     13  5994					      REPEND
     14  5995		       9a		      .byte.b	$90+(.LUM1/256)
     15  5996		       bc		      .byte.b	$B0+(.LUM2/256)
     16  5997		       2c		      .byte.b	$20+(.LUM3/256)
     17  5997				   .LUM1      SET	.LUM1 + .STEP1
     18  5997				   .LUM2      SET	.LUM2 + .STEP2
     19  5997				   .LUM3      SET	.LUM3 + .STEP3
     13  5997					      REPEND
     14  5998		       9a		      .byte.b	$90+(.LUM1/256)
     15  5999		       bc		      .byte.b	$B0+(.LUM2/256)
     16  599a		       2c		      .byte.b	$20+(.LUM3/256)
     17  599a				   .LUM1      SET	.LUM1 + .STEP1
     18  599a				   .LUM2      SET	.LUM2 + .STEP2
     19  599a				   .LUM3      SET	.LUM3 + .STEP3
     13  599a					      REPEND
     14  599b		       9b		      .byte.b	$90+(.LUM1/256)
     15  599c		       bc		      .byte.b	$B0+(.LUM2/256)
     16  599d		       2d		      .byte.b	$20+(.LUM3/256)
     17  599d				   .LUM1      SET	.LUM1 + .STEP1
     18  599d				   .LUM2      SET	.LUM2 + .STEP2
     19  599d				   .LUM3      SET	.LUM3 + .STEP3
     13  599d					      REPEND
     14  599e		       9b		      .byte.b	$90+(.LUM1/256)
     15  599f		       bd		      .byte.b	$B0+(.LUM2/256)
     16  59a0		       2d		      .byte.b	$20+(.LUM3/256)
     17  59a0				   .LUM1      SET	.LUM1 + .STEP1
     18  59a0				   .LUM2      SET	.LUM2 + .STEP2
     19  59a0				   .LUM3      SET	.LUM3 + .STEP3
     13  59a0					      REPEND
     14  59a1		       9b		      .byte.b	$90+(.LUM1/256)
     15  59a2		       bd		      .byte.b	$B0+(.LUM2/256)
     16  59a3		       2d		      .byte.b	$20+(.LUM3/256)
     17  59a3				   .LUM1      SET	.LUM1 + .STEP1
     18  59a3				   .LUM2      SET	.LUM2 + .STEP2
     19  59a3				   .LUM3      SET	.LUM3 + .STEP3
     13  59a3					      REPEND
     14  59a4		       9b		      .byte.b	$90+(.LUM1/256)
     15  59a5		       bd		      .byte.b	$B0+(.LUM2/256)
     16  59a6		       2d		      .byte.b	$20+(.LUM3/256)
     17  59a6				   .LUM1      SET	.LUM1 + .STEP1
     18  59a6				   .LUM2      SET	.LUM2 + .STEP2
     19  59a6				   .LUM3      SET	.LUM3 + .STEP3
     13  59a6					      REPEND
     14  59a7		       9b		      .byte.b	$90+(.LUM1/256)
     15  59a8		       bd		      .byte.b	$B0+(.LUM2/256)
     16  59a9		       2d		      .byte.b	$20+(.LUM3/256)
     17  59a9				   .LUM1      SET	.LUM1 + .STEP1
     18  59a9				   .LUM2      SET	.LUM2 + .STEP2
     19  59a9				   .LUM3      SET	.LUM3 + .STEP3
     20  59aa					      REPEND
    167  59aa
------- FILE titleData.asm LEVEL 3 PASS 3
      0  59aa					      include	"titleData.asm"
      1  59aa				   COL_0
      2  59aa		       00		      .byte.b	0	;R (79)
      3  59ab		       00		      .byte.b	0	;G
      4  59ac		       00		      .byte.b	0	;B
      5  59ad		       c0		      .byte.b	192	;R (78)
      6  59ae		       c0		      .byte.b	192	;G
      7  59af		       c0		      .byte.b	192	;B
      8  59b0		       e0		      .byte.b	224	;R (77)
      9  59b1		       e0		      .byte.b	224	;G
     10  59b2		       e0		      .byte.b	224	;B
     11  59b3		       20		      .byte.b	32	;R (76)
     12  59b4		       e0		      .byte.b	224	;G
     13  59b5		       e0		      .byte.b	224	;B
     14  59b6		       30		      .byte.b	48	;R (75)
     15  59b7		       30		      .byte.b	48	;G
     16  59b8		       30		      .byte.b	48	;B
     17  59b9		       f0		      .byte.b	240	;R (74)
     18  59ba		       10		      .byte.b	16	;G
     19  59bb		       d0		      .byte.b	208	;B
     20  59bc		       f0		      .byte.b	240	;R (73)
     21  59bd		       10		      .byte.b	16	;G
     22  59be		       d0		      .byte.b	208	;B
     23  59bf		       f0		      .byte.b	240	;R (72)
     24  59c0		       10		      .byte.b	16	;G
     25  59c1		       d0		      .byte.b	208	;B
     26  59c2		       f0		      .byte.b	240	;R (71)
     27  59c3		       10		      .byte.b	16	;G
     28  59c4		       d0		      .byte.b	208	;B
     29  59c5		       f0		      .byte.b	240	;R (70)
     30  59c6		       10		      .byte.b	16	;G
     31  59c7		       d0		      .byte.b	208	;B
     32  59c8		       f0		      .byte.b	240	;R (69)
     33  59c9		       10		      .byte.b	16	;G
     34  59ca		       10		      .byte.b	16	;B
     35  59cb		       f0		      .byte.b	240	;R (68)
     36  59cc		       10		      .byte.b	16	;G
     37  59cd		       10		      .byte.b	16	;B
     38  59ce		       f0		      .byte.b	240	;R (67)
     39  59cf		       10		      .byte.b	16	;G
     40  59d0		       10		      .byte.b	16	;B
     41  59d1		       f0		      .byte.b	240	;R (66)
     42  59d2		       10		      .byte.b	16	;G
     43  59d3		       10		      .byte.b	16	;B
     44  59d4		       f0		      .byte.b	240	;R (65)
     45  59d5		       10		      .byte.b	16	;G
     46  59d6		       10		      .byte.b	16	;B
     47  59d7		       f0		      .byte.b	240	;R (64)
     48  59d8		       10		      .byte.b	16	;G
     49  59d9		       10		      .byte.b	16	;B
     50  59da		       f0		      .byte.b	240	;R (63)
     51  59db		       10		      .byte.b	16	;G
     52  59dc		       10		      .byte.b	16	;B
     53  59dd		       f0		      .byte.b	240	;R (62)
     54  59de		       10		      .byte.b	16	;G
     55  59df		       10		      .byte.b	16	;B
     56  59e0		       90		      .byte.b	144	;R (61)
     57  59e1		       70		      .byte.b	112	;G
     58  59e2		       10		      .byte.b	16	;B
     59  59e3		       10		      .byte.b	16	;R (60)
     60  59e4		       f0		      .byte.b	240	;G
     61  59e5		       10		      .byte.b	16	;B
     62  59e6		       90		      .byte.b	144	;R (59)
     63  59e7		       70		      .byte.b	112	;G
     64  59e8		       90		      .byte.b	144	;B
     65  59e9		       90		      .byte.b	144	;R (58)
     66  59ea		       70		      .byte.b	112	;G
     67  59eb		       90		      .byte.b	144	;B
     68  59ec		       d0		      .byte.b	208	;R (57)
     69  59ed		       30		      .byte.b	48	;G
     70  59ee		       d0		      .byte.b	208	;B
     71  59ef		       d0		      .byte.b	208	;R (56)
     72  59f0		       30		      .byte.b	48	;G
     73  59f1		       d0		      .byte.b	208	;B
     74  59f2		       50		      .byte.b	80	;R (55)
     75  59f3		       30		      .byte.b	48	;G
     76  59f4		       50		      .byte.b	80	;B
     77  59f5		       50		      .byte.b	80	;R (54)
     78  59f6		       30		      .byte.b	48	;G
     79  59f7		       50		      .byte.b	80	;B
     80  59f8		       50		      .byte.b	80	;R (53)
     81  59f9		       30		      .byte.b	48	;G
     82  59fa		       50		      .byte.b	80	;B
     83  59fb		       50		      .byte.b	80	;R (52)
     84  59fc		       30		      .byte.b	48	;G
     85  59fd		       50		      .byte.b	80	;B
     86  59fe		       d0		      .byte.b	208	;R (51)
     87  59ff		       30		      .byte.b	48	;G
     88  5a00		       d0		      .byte.b	208	;B
     89  5a01		       d0		      .byte.b	208	;R (50)
     90  5a02		       30		      .byte.b	48	;G
     91  5a03		       d0		      .byte.b	208	;B
     92  5a04		       d0		      .byte.b	208	;R (49)
     93  5a05		       30		      .byte.b	48	;G
     94  5a06		       d0		      .byte.b	208	;B
     95  5a07		       d0		      .byte.b	208	;R (48)
     96  5a08		       30		      .byte.b	48	;G
     97  5a09		       d0		      .byte.b	208	;B
     98  5a0a		       90		      .byte.b	144	;R (47)
     99  5a0b		       70		      .byte.b	112	;G
    100  5a0c		       90		      .byte.b	144	;B
    101  5a0d		       90		      .byte.b	144	;R (46)
    102  5a0e		       70		      .byte.b	112	;G
    103  5a0f		       90		      .byte.b	144	;B
    104  5a10		       10		      .byte.b	16	;R (45)
    105  5a11		       f0		      .byte.b	240	;G
    106  5a12		       10		      .byte.b	16	;B
    107  5a13		       10		      .byte.b	16	;R (44)
    108  5a14		       f0		      .byte.b	240	;G
    109  5a15		       10		      .byte.b	16	;B
    110  5a16		       10		      .byte.b	16	;R (43)
    111  5a17		       f0		      .byte.b	240	;G
    112  5a18		       10		      .byte.b	16	;B
    113  5a19		       20		      .byte.b	32	;R (42)
    114  5a1a		       e0		      .byte.b	224	;G
    115  5a1b		       20		      .byte.b	32	;B
    116  5a1c		       20		      .byte.b	32	;R (41)
    117  5a1d		       e0		      .byte.b	224	;G
    118  5a1e		       20		      .byte.b	32	;B
    119  5a1f		       e0		      .byte.b	224	;R (40)
    120  5a20		       e0		      .byte.b	224	;G
    121  5a21		       e0		      .byte.b	224	;B
    122  5a22		       c0		      .byte.b	192	;R (39)
    123  5a23		       c0		      .byte.b	192	;G
    124  5a24		       c0		      .byte.b	192	;B
    125  5a25		       e0		      .byte.b	224	;R (38)
    126  5a26		       e0		      .byte.b	224	;G
    127  5a27		       e0		      .byte.b	224	;B
    128  5a28		       20		      .byte.b	32	;R (37)
    129  5a29		       e0		      .byte.b	224	;G
    130  5a2a		       e0		      .byte.b	224	;B
    131  5a2b		       30		      .byte.b	48	;R (36)
    132  5a2c		       30		      .byte.b	48	;G
    133  5a2d		       30		      .byte.b	48	;B
    134  5a2e		       f0		      .byte.b	240	;R (35)
    135  5a2f		       10		      .byte.b	16	;G
    136  5a30		       d0		      .byte.b	208	;B
    137  5a31		       f0		      .byte.b	240	;R (34)
    138  5a32		       10		      .byte.b	16	;G
    139  5a33		       d0		      .byte.b	208	;B
    140  5a34		       f0		      .byte.b	240	;R (33)
    141  5a35		       10		      .byte.b	16	;G
    142  5a36		       d0		      .byte.b	208	;B
    143  5a37		       f0		      .byte.b	240	;R (32)
    144  5a38		       10		      .byte.b	16	;G
    145  5a39		       d0		      .byte.b	208	;B
    146  5a3a		       f0		      .byte.b	240	;R (31)
    147  5a3b		       10		      .byte.b	16	;G
    148  5a3c		       d0		      .byte.b	208	;B
    149  5a3d		       f0		      .byte.b	240	;R (30)
    150  5a3e		       10		      .byte.b	16	;G
    151  5a3f		       10		      .byte.b	16	;B
    152  5a40		       f0		      .byte.b	240	;R (29)
    153  5a41		       10		      .byte.b	16	;G
    154  5a42		       10		      .byte.b	16	;B
    155  5a43		       f0		      .byte.b	240	;R (28)
    156  5a44		       10		      .byte.b	16	;G
    157  5a45		       10		      .byte.b	16	;B
    158  5a46		       f0		      .byte.b	240	;R (27)
    159  5a47		       10		      .byte.b	16	;G
    160  5a48		       10		      .byte.b	16	;B
    161  5a49		       f0		      .byte.b	240	;R (26)
    162  5a4a		       10		      .byte.b	16	;G
    163  5a4b		       10		      .byte.b	16	;B
    164  5a4c		       f0		      .byte.b	240	;R (25)
    165  5a4d		       10		      .byte.b	16	;G
    166  5a4e		       10		      .byte.b	16	;B
    167  5a4f		       f0		      .byte.b	240	;R (24)
    168  5a50		       10		      .byte.b	16	;G
    169  5a51		       10		      .byte.b	16	;B
    170  5a52		       f0		      .byte.b	240	;R (23)
    171  5a53		       10		      .byte.b	16	;G
    172  5a54		       10		      .byte.b	16	;B
    173  5a55		       90		      .byte.b	144	;R (22)
    174  5a56		       70		      .byte.b	112	;G
    175  5a57		       10		      .byte.b	16	;B
    176  5a58		       10		      .byte.b	16	;R (21)
    177  5a59		       f0		      .byte.b	240	;G
    178  5a5a		       10		      .byte.b	16	;B
    179  5a5b		       90		      .byte.b	144	;R (20)
    180  5a5c		       70		      .byte.b	112	;G
    181  5a5d		       90		      .byte.b	144	;B
    182  5a5e		       90		      .byte.b	144	;R (19)
    183  5a5f		       70		      .byte.b	112	;G
    184  5a60		       90		      .byte.b	144	;B
    185  5a61		       d0		      .byte.b	208	;R (18)
    186  5a62		       30		      .byte.b	48	;G
    187  5a63		       d0		      .byte.b	208	;B
    188  5a64		       d0		      .byte.b	208	;R (17)
    189  5a65		       30		      .byte.b	48	;G
    190  5a66		       d0		      .byte.b	208	;B
    191  5a67		       50		      .byte.b	80	;R (16)
    192  5a68		       30		      .byte.b	48	;G
    193  5a69		       50		      .byte.b	80	;B
    194  5a6a		       50		      .byte.b	80	;R (15)
    195  5a6b		       30		      .byte.b	48	;G
    196  5a6c		       50		      .byte.b	80	;B
    197  5a6d		       50		      .byte.b	80	;R (14)
    198  5a6e		       30		      .byte.b	48	;G
    199  5a6f		       50		      .byte.b	80	;B
    200  5a70		       50		      .byte.b	80	;R (13)
    201  5a71		       30		      .byte.b	48	;G
    202  5a72		       50		      .byte.b	80	;B
    203  5a73		       d0		      .byte.b	208	;R (12)
    204  5a74		       30		      .byte.b	48	;G
    205  5a75		       d0		      .byte.b	208	;B
    206  5a76		       d0		      .byte.b	208	;R (11)
    207  5a77		       30		      .byte.b	48	;G
    208  5a78		       d0		      .byte.b	208	;B
    209  5a79		       d0		      .byte.b	208	;R (10)
    210  5a7a		       30		      .byte.b	48	;G
    211  5a7b		       d0		      .byte.b	208	;B
    212  5a7c		       d0		      .byte.b	208	;R (9)
    213  5a7d		       30		      .byte.b	48	;G
    214  5a7e		       d0		      .byte.b	208	;B
    215  5a7f		       90		      .byte.b	144	;R (8)
    216  5a80		       70		      .byte.b	112	;G
    217  5a81		       90		      .byte.b	144	;B
    218  5a82		       90		      .byte.b	144	;R (7)
    219  5a83		       70		      .byte.b	112	;G
    220  5a84		       90		      .byte.b	144	;B
    221  5a85		       10		      .byte.b	16	;R (6)
    222  5a86		       f0		      .byte.b	240	;G
    223  5a87		       10		      .byte.b	16	;B
    224  5a88		       10		      .byte.b	16	;R (5)
    225  5a89		       f0		      .byte.b	240	;G
    226  5a8a		       10		      .byte.b	16	;B
    227  5a8b		       10		      .byte.b	16	;R (4)
    228  5a8c		       f0		      .byte.b	240	;G
    229  5a8d		       10		      .byte.b	16	;B
    230  5a8e		       20		      .byte.b	32	;R (3)
    231  5a8f		       e0		      .byte.b	224	;G
    232  5a90		       20		      .byte.b	32	;B
    233  5a91		       20		      .byte.b	32	;R (2)
    234  5a92		       e0		      .byte.b	224	;G
    235  5a93		       20		      .byte.b	32	;B
    236  5a94		       e0		      .byte.b	224	;R (1)
    237  5a95		       e0		      .byte.b	224	;G
    238  5a96		       e0		      .byte.b	224	;B
    239  5a97		       c0		      .byte.b	192	;R (0)
    240  5a98		       c0		      .byte.b	192	;G
    241  5a99		       c0		      .byte.b	192	;B
    242  5a9a				   COL_1
    243  5a9a		       00		      .byte.b	0	;R (79)
    244  5a9b		       00		      .byte.b	0	;G
    245  5a9c		       00		      .byte.b	0	;B
    246  5a9d		       ff		      .byte.b	255	;R (78)
    247  5a9e		       ff		      .byte.b	255	;G
    248  5a9f		       ff		      .byte.b	255	;B
    249  5aa0		       ff		      .byte.b	255	;R (77)
    250  5aa1		       ff		      .byte.b	255	;G
    251  5aa2		       ff		      .byte.b	255	;B
    252  5aa3		       00		      .byte.b	0	;R (76)
    253  5aa4		       ff		      .byte.b	255	;G
    254  5aa5		       ff		      .byte.b	255	;B
    255  5aa6		       00		      .byte.b	0	;R (75)
    256  5aa7		       f3		      .byte.b	243	;G
    257  5aa8		       f3		      .byte.b	243	;B
    258  5aa9		       0c		      .byte.b	12	;R (74)
    259  5aaa		       7d		      .byte.b	125	;G
    260  5aab		       71		      .byte.b	113	;B
    261  5aac		       0c		      .byte.b	12	;R (73)
    262  5aad		       7d		      .byte.b	125	;G
    263  5aae		       71		      .byte.b	113	;B
    264  5aaf		       9c		      .byte.b	156	;R (72)
    265  5ab0		       3d		      .byte.b	61	;G
    266  5ab1		       a1		      .byte.b	161	;B
    267  5ab2		       9c		      .byte.b	156	;R (71)
    268  5ab3		       3d		      .byte.b	61	;G
    269  5ab4		       a1		      .byte.b	161	;B
    270  5ab5		       9e		      .byte.b	158	;R (70)
    271  5ab6		       3e		      .byte.b	62	;G
    272  5ab7		       a0		      .byte.b	160	;B
    273  5ab8		       de		      .byte.b	222	;R (69)
    274  5ab9		       1e		      .byte.b	30	;G
    275  5aba		       c0		      .byte.b	192	;B
    276  5abb		       d2		      .byte.b	210	;R (68)
    277  5abc		       12		      .byte.b	18	;G
    278  5abd		       c0		      .byte.b	192	;B
    279  5abe		       d6		      .byte.b	214	;R (67)
    280  5abf		       12		      .byte.b	18	;G
    281  5ac0		       c0		      .byte.b	192	;B
    282  5ac1		       d6		      .byte.b	214	;R (66)
    283  5ac2		       12		      .byte.b	18	;G
    284  5ac3		       c0		      .byte.b	192	;B
    285  5ac4		       d6		      .byte.b	214	;R (65)
    286  5ac5		       12		      .byte.b	18	;G
    287  5ac6		       c0		      .byte.b	192	;B
    288  5ac7		       d6		      .byte.b	214	;R (64)
    289  5ac8		       12		      .byte.b	18	;G
    290  5ac9		       c0		      .byte.b	192	;B
    291  5aca		       d6		      .byte.b	214	;R (63)
    292  5acb		       12		      .byte.b	18	;G
    293  5acc		       c0		      .byte.b	192	;B
    294  5acd		       d6		      .byte.b	214	;R (62)
    295  5ace		       12		      .byte.b	18	;G
    296  5acf		       c0		      .byte.b	192	;B
    297  5ad0		       d6		      .byte.b	214	;R (61)
    298  5ad1		       12		      .byte.b	18	;G
    299  5ad2		       c0		      .byte.b	192	;B
    300  5ad3		       d6		      .byte.b	214	;R (60)
    301  5ad4		       12		      .byte.b	18	;G
    302  5ad5		       c0		      .byte.b	192	;B
    303  5ad6		       d6		      .byte.b	214	;R (59)
    304  5ad7		       12		      .byte.b	18	;G
    305  5ad8		       c0		      .byte.b	192	;B
    306  5ad9		       d6		      .byte.b	214	;R (58)
    307  5ada		       12		      .byte.b	18	;G
    308  5adb		       c0		      .byte.b	192	;B
    309  5adc		       96		      .byte.b	150	;R (57)
    310  5add		       32		      .byte.b	50	;G
    311  5ade		       80		      .byte.b	128	;B
    312  5adf		       12		      .byte.b	18	;R (56)
    313  5ae0		       76		      .byte.b	118	;G
    314  5ae1		       00		      .byte.b	0	;B
    315  5ae2		       12		      .byte.b	18	;R (55)
    316  5ae3		       f6		      .byte.b	246	;G
    317  5ae4		       00		      .byte.b	0	;B
    318  5ae5		       12		      .byte.b	18	;R (54)
    319  5ae6		       f6		      .byte.b	246	;G
    320  5ae7		       00		      .byte.b	0	;B
    321  5ae8		       12		      .byte.b	18	;R (53)
    322  5ae9		       f6		      .byte.b	246	;G
    323  5aea		       00		      .byte.b	0	;B
    324  5aeb		       12		      .byte.b	18	;R (52)
    325  5aec		       f6		      .byte.b	246	;G
    326  5aed		       00		      .byte.b	0	;B
    327  5aee		       12		      .byte.b	18	;R (51)
    328  5aef		       76		      .byte.b	118	;G
    329  5af0		       00		      .byte.b	0	;B
    330  5af1		       12		      .byte.b	18	;R (50)
    331  5af2		       76		      .byte.b	118	;G
    332  5af3		       00		      .byte.b	0	;B
    333  5af4		       12		      .byte.b	18	;R (49)
    334  5af5		       76		      .byte.b	118	;G
    335  5af6		       00		      .byte.b	0	;B
    336  5af7		       9a		      .byte.b	154	;R (48)
    337  5af8		       3a		      .byte.b	58	;G
    338  5af9		       80		      .byte.b	128	;B
    339  5afa		       da		      .byte.b	218	;R (47)
    340  5afb		       1a		      .byte.b	26	;G
    341  5afc		       c0		      .byte.b	192	;B
    342  5afd		       fe		      .byte.b	254	;R (46)
    343  5afe		       1e		      .byte.b	30	;G
    344  5aff		       e0		      .byte.b	224	;B
    345  5b00		       ee		      .byte.b	238	;R (45)
    346  5b01		       0e		      .byte.b	14	;G
    347  5b02		       e0		      .byte.b	224	;B
    348  5b03		       6e		      .byte.b	110	;R (44)
    349  5b04		       8e		      .byte.b	142	;G
    350  5b05		       60		      .byte.b	96	;B
    351  5b06		       24		      .byte.b	36	;R (43)
    352  5b07		       cd		      .byte.b	205	;G
    353  5b08		       20		      .byte.b	32	;B
    354  5b09		       00		      .byte.b	0	;R (42)
    355  5b0a		       ff		      .byte.b	255	;G
    356  5b0b		       00		      .byte.b	0	;B
    357  5b0c		       00		      .byte.b	0	;R (41)
    358  5b0d		       ff		      .byte.b	255	;G
    359  5b0e		       00		      .byte.b	0	;B
    360  5b0f		       ff		      .byte.b	255	;R (40)
    361  5b10		       ff		      .byte.b	255	;G
    362  5b11		       ff		      .byte.b	255	;B
    363  5b12		       ff		      .byte.b	255	;R (39)
    364  5b13		       ff		      .byte.b	255	;G
    365  5b14		       ff		      .byte.b	255	;B
    366  5b15		       ff		      .byte.b	255	;R (38)
    367  5b16		       ff		      .byte.b	255	;G
    368  5b17		       ff		      .byte.b	255	;B
    369  5b18		       00		      .byte.b	0	;R (37)
    370  5b19		       ff		      .byte.b	255	;G
    371  5b1a		       ff		      .byte.b	255	;B
    372  5b1b		       00		      .byte.b	0	;R (36)
    373  5b1c		       ff		      .byte.b	255	;G
    374  5b1d		       ff		      .byte.b	255	;B
    375  5b1e		       00		      .byte.b	0	;R (35)
    376  5b1f		       7f		      .byte.b	127	;G
    377  5b20		       7f		      .byte.b	127	;B
    378  5b21		       00		      .byte.b	0	;R (34)
    379  5b22		       7f		      .byte.b	127	;G
    380  5b23		       7f		      .byte.b	127	;B
    381  5b24		       9f		      .byte.b	159	;R (33)
    382  5b25		       3f		      .byte.b	63	;G
    383  5b26		       a0		      .byte.b	160	;B
    384  5b27		       9f		      .byte.b	159	;R (32)
    385  5b28		       3f		      .byte.b	63	;G
    386  5b29		       a0		      .byte.b	160	;B
    387  5b2a		       9f		      .byte.b	159	;R (31)
    388  5b2b		       3f		      .byte.b	63	;G
    389  5b2c		       a0		      .byte.b	160	;B
    390  5b2d		       df		      .byte.b	223	;R (30)
    391  5b2e		       1f		      .byte.b	31	;G
    392  5b2f		       c0		      .byte.b	192	;B
    393  5b30		       df		      .byte.b	223	;R (29)
    394  5b31		       1f		      .byte.b	31	;G
    395  5b32		       c0		      .byte.b	192	;B
    396  5b33		       df		      .byte.b	223	;R (28)
    397  5b34		       1f		      .byte.b	31	;G
    398  5b35		       c0		      .byte.b	192	;B
    399  5b36		       df		      .byte.b	223	;R (27)
    400  5b37		       1f		      .byte.b	31	;G
    401  5b38		       c0		      .byte.b	192	;B
    402  5b39		       df		      .byte.b	223	;R (26)
    403  5b3a		       1f		      .byte.b	31	;G
    404  5b3b		       c0		      .byte.b	192	;B
    405  5b3c		       df		      .byte.b	223	;R (25)
    406  5b3d		       1f		      .byte.b	31	;G
    407  5b3e		       c0		      .byte.b	192	;B
    408  5b3f		       df		      .byte.b	223	;R (24)
    409  5b40		       1f		      .byte.b	31	;G
    410  5b41		       c0		      .byte.b	192	;B
    411  5b42		       df		      .byte.b	223	;R (23)
    412  5b43		       1f		      .byte.b	31	;G
    413  5b44		       c0		      .byte.b	192	;B
    414  5b45		       df		      .byte.b	223	;R (22)
    415  5b46		       1f		      .byte.b	31	;G
    416  5b47		       c0		      .byte.b	192	;B
    417  5b48		       df		      .byte.b	223	;R (21)
    418  5b49		       1f		      .byte.b	31	;G
    419  5b4a		       c0		      .byte.b	192	;B
    420  5b4b		       df		      .byte.b	223	;R (20)
    421  5b4c		       1f		      .byte.b	31	;G
    422  5b4d		       c0		      .byte.b	192	;B
    423  5b4e		       df		      .byte.b	223	;R (19)
    424  5b4f		       1f		      .byte.b	31	;G
    425  5b50		       c0		      .byte.b	192	;B
    426  5b51		       9f		      .byte.b	159	;R (18)
    427  5b52		       3f		      .byte.b	63	;G
    428  5b53		       80		      .byte.b	128	;B
    429  5b54		       1f		      .byte.b	31	;R (17)
    430  5b55		       7f		      .byte.b	127	;G
    431  5b56		       00		      .byte.b	0	;B
    432  5b57		       1f		      .byte.b	31	;R (16)
    433  5b58		       ff		      .byte.b	255	;G
    434  5b59		       00		      .byte.b	0	;B
    435  5b5a		       1f		      .byte.b	31	;R (15)
    436  5b5b		       ff		      .byte.b	255	;G
    437  5b5c		       00		      .byte.b	0	;B
    438  5b5d		       1f		      .byte.b	31	;R (14)
    439  5b5e		       ff		      .byte.b	255	;G
    440  5b5f		       00		      .byte.b	0	;B
    441  5b60		       1f		      .byte.b	31	;R (13)
    442  5b61		       ff		      .byte.b	255	;G
    443  5b62		       00		      .byte.b	0	;B
    444  5b63		       1f		      .byte.b	31	;R (12)
    445  5b64		       7f		      .byte.b	127	;G
    446  5b65		       00		      .byte.b	0	;B
    447  5b66		       1f		      .byte.b	31	;R (11)
    448  5b67		       7f		      .byte.b	127	;G
    449  5b68		       00		      .byte.b	0	;B
    450  5b69		       1f		      .byte.b	31	;R (10)
    451  5b6a		       7f		      .byte.b	127	;G
    452  5b6b		       00		      .byte.b	0	;B
    453  5b6c		       9f		      .byte.b	159	;R (9)
    454  5b6d		       3f		      .byte.b	63	;G
    455  5b6e		       80		      .byte.b	128	;B
    456  5b6f		       df		      .byte.b	223	;R (8)
    457  5b70		       1f		      .byte.b	31	;G
    458  5b71		       c0		      .byte.b	192	;B
    459  5b72		       ff		      .byte.b	255	;R (7)
    460  5b73		       1f		      .byte.b	31	;G
    461  5b74		       e0		      .byte.b	224	;B
    462  5b75		       e0		      .byte.b	224	;R (6)
    463  5b76		       00		      .byte.b	0	;G
    464  5b77		       e0		      .byte.b	224	;B
    465  5b78		       60		      .byte.b	96	;R (5)
    466  5b79		       80		      .byte.b	128	;G
    467  5b7a		       60		      .byte.b	96	;B
    468  5b7b		       20		      .byte.b	32	;R (4)
    469  5b7c		       c0		      .byte.b	192	;G
    470  5b7d		       20		      .byte.b	32	;B
    471  5b7e		       00		      .byte.b	0	;R (3)
    472  5b7f		       ff		      .byte.b	255	;G
    473  5b80		       00		      .byte.b	0	;B
    474  5b81		       00		      .byte.b	0	;R (2)
    475  5b82		       ff		      .byte.b	255	;G
    476  5b83		       00		      .byte.b	0	;B
    477  5b84		       ff		      .byte.b	255	;R (1)
    478  5b85		       ff		      .byte.b	255	;G
    479  5b86		       ff		      .byte.b	255	;B
    480  5b87		       ff		      .byte.b	255	;R (0)
    481  5b88		       ff		      .byte.b	255	;G
    482  5b89		       ff		      .byte.b	255	;B
    483  5b8a				   COL_2
    484  5b8a		       00		      .byte.b	0	;R (79)
    485  5b8b		       00		      .byte.b	0	;G
    486  5b8c		       00		      .byte.b	0	;B
    487  5b8d		       ff		      .byte.b	255	;R (78)
    488  5b8e		       ff		      .byte.b	255	;G
    489  5b8f		       ff		      .byte.b	255	;B
    490  5b90		       ff		      .byte.b	255	;R (77)
    491  5b91		       ff		      .byte.b	255	;G
    492  5b92		       ff		      .byte.b	255	;B
    493  5b93		       00		      .byte.b	0	;R (76)
    494  5b94		       ff		      .byte.b	255	;G
    495  5b95		       ff		      .byte.b	255	;B
    496  5b96		       00		      .byte.b	0	;R (75)
    497  5b97		       26		      .byte.b	38	;G
    498  5b98		       26		      .byte.b	38	;B
    499  5b99		       c0		      .byte.b	192	;R (74)
    500  5b9a		       04		      .byte.b	4	;G
    501  5b9b		       dd		      .byte.b	221	;B
    502  5b9c		       c0		      .byte.b	192	;R (73)
    503  5b9d		       04		      .byte.b	4	;G
    504  5b9e		       dd		      .byte.b	221	;B
    505  5b9f		       e0		      .byte.b	224	;R (72)
    506  5ba0		       04		      .byte.b	4	;G
    507  5ba1		       ed		      .byte.b	237	;B
    508  5ba2		       e0		      .byte.b	224	;R (71)
    509  5ba3		       04		      .byte.b	4	;G
    510  5ba4		       ed		      .byte.b	237	;B
    511  5ba5		       e0		      .byte.b	224	;R (70)
    512  5ba6		       04		      .byte.b	4	;G
    513  5ba7		       ed		      .byte.b	237	;B
    514  5ba8		       e0		      .byte.b	224	;R (69)
    515  5ba9		       00		      .byte.b	0	;G
    516  5baa		       ed		      .byte.b	237	;B
    517  5bab		       20		      .byte.b	32	;R (68)
    518  5bac		       80		      .byte.b	128	;G
    519  5bad		       af		      .byte.b	175	;B
    520  5bae		       20		      .byte.b	32	;R (67)
    521  5baf		       80		      .byte.b	128	;G
    522  5bb0		       af		      .byte.b	175	;B
    523  5bb1		       20		      .byte.b	32	;R (66)
    524  5bb2		       80		      .byte.b	128	;G
    525  5bb3		       af		      .byte.b	175	;B
    526  5bb4		       20		      .byte.b	32	;R (65)
    527  5bb5		       90		      .byte.b	144	;G
    528  5bb6		       b7		      .byte.b	183	;B
    529  5bb7		       20		      .byte.b	32	;R (64)
    530  5bb8		       90		      .byte.b	144	;G
    531  5bb9		       b7		      .byte.b	183	;B
    532  5bba		       20		      .byte.b	32	;R (63)
    533  5bbb		       90		      .byte.b	144	;G
    534  5bbc		       b7		      .byte.b	183	;B
    535  5bbd		       38		      .byte.b	56	;R (62)
    536  5bbe		       80		      .byte.b	128	;G
    537  5bbf		       a3		      .byte.b	163	;B
    538  5bc0		       38		      .byte.b	56	;R (61)
    539  5bc1		       80		      .byte.b	128	;G
    540  5bc2		       a3		      .byte.b	163	;B
    541  5bc3		       b0		      .byte.b	176	;R (60)
    542  5bc4		       00		      .byte.b	0	;G
    543  5bc5		       27		      .byte.b	39	;B
    544  5bc6		       b0		      .byte.b	176	;R (59)
    545  5bc7		       00		      .byte.b	0	;G
    546  5bc8		       27		      .byte.b	39	;B
    547  5bc9		       b0		      .byte.b	176	;R (58)
    548  5bca		       00		      .byte.b	0	;G
    549  5bcb		       27		      .byte.b	39	;B
    550  5bcc		       b0		      .byte.b	176	;R (57)
    551  5bcd		       00		      .byte.b	0	;G
    552  5bce		       27		      .byte.b	39	;B
    553  5bcf		       a0		      .byte.b	160	;R (56)
    554  5bd0		       00		      .byte.b	0	;G
    555  5bd1		       2f		      .byte.b	47	;B
    556  5bd2		       a0		      .byte.b	160	;R (55)
    557  5bd3		       00		      .byte.b	0	;G
    558  5bd4		       2f		      .byte.b	47	;B
    559  5bd5		       a0		      .byte.b	160	;R (54)
    560  5bd6		       00		      .byte.b	0	;G
    561  5bd7		       2d		      .byte.b	45	;B
    562  5bd8		       a0		      .byte.b	160	;R (53)
    563  5bd9		       00		      .byte.b	0	;G
    564  5bda		       2d		      .byte.b	45	;B
    565  5bdb		       a0		      .byte.b	160	;R (52)
    566  5bdc		       00		      .byte.b	0	;G
    567  5bdd		       2d		      .byte.b	45	;B
    568  5bde		       a0		      .byte.b	160	;R (51)
    569  5bdf		       04		      .byte.b	4	;G
    570  5be0		       29		      .byte.b	41	;B
    571  5be1		       a0		      .byte.b	160	;R (50)
    572  5be2		       04		      .byte.b	4	;G
    573  5be3		       29		      .byte.b	41	;B
    574  5be4		       a0		      .byte.b	160	;R (49)
    575  5be5		       04		      .byte.b	4	;G
    576  5be6		       29		      .byte.b	41	;B
    577  5be7		       60		      .byte.b	96	;R (48)
    578  5be8		       04		      .byte.b	4	;G
    579  5be9		       69		      .byte.b	105	;B
    580  5bea		       60		      .byte.b	96	;R (47)
    581  5beb		       04		      .byte.b	4	;G
    582  5bec		       79		      .byte.b	121	;B
    583  5bed		       e0		      .byte.b	224	;R (46)
    584  5bee		       04		      .byte.b	4	;G
    585  5bef		       f9		      .byte.b	249	;B
    586  5bf0		       c0		      .byte.b	192	;R (45)
    587  5bf1		       04		      .byte.b	4	;G
    588  5bf2		       d9		      .byte.b	217	;B
    589  5bf3		       c0		      .byte.b	192	;R (44)
    590  5bf4		       04		      .byte.b	4	;G
    591  5bf5		       d9		      .byte.b	217	;B
    592  5bf6		       80		      .byte.b	128	;R (43)
    593  5bf7		       44		      .byte.b	68	;G
    594  5bf8		       99		      .byte.b	153	;B
    595  5bf9		       00		      .byte.b	0	;R (42)
    596  5bfa		       ff		      .byte.b	255	;G
    597  5bfb		       00		      .byte.b	0	;B
    598  5bfc		       00		      .byte.b	0	;R (41)
    599  5bfd		       ff		      .byte.b	255	;G
    600  5bfe		       00		      .byte.b	0	;B
    601  5bff		       ff		      .byte.b	255	;R (40)
    602  5c00		       ff		      .byte.b	255	;G
    603  5c01		       ff		      .byte.b	255	;B
    604  5c02		       ff		      .byte.b	255	;R (39)
    605  5c03		       ff		      .byte.b	255	;G
    606  5c04		       ff		      .byte.b	255	;B
    607  5c05		       ff		      .byte.b	255	;R (38)
    608  5c06		       ff		      .byte.b	255	;G
    609  5c07		       ff		      .byte.b	255	;B
    610  5c08		       00		      .byte.b	0	;R (37)
    611  5c09		       ff		      .byte.b	255	;G
    612  5c0a		       ff		      .byte.b	255	;B
    613  5c0b		       00		      .byte.b	0	;R (36)
    614  5c0c		       f9		      .byte.b	249	;G
    615  5c0d		       f9		      .byte.b	249	;B
    616  5c0e		       06		      .byte.b	6	;R (35)
    617  5c0f		       07		      .byte.b	7	;G
    618  5c10		       01		      .byte.b	1	;B
    619  5c11		       06		      .byte.b	6	;R (34)
    620  5c12		       07		      .byte.b	7	;G
    621  5c13		       01		      .byte.b	1	;B
    622  5c14		       07		      .byte.b	7	;R (33)
    623  5c15		       07		      .byte.b	7	;G
    624  5c16		       00		      .byte.b	0	;B
    625  5c17		       07		      .byte.b	7	;R (32)
    626  5c18		       07		      .byte.b	7	;G
    627  5c19		       00		      .byte.b	0	;B
    628  5c1a		       ff		      .byte.b	255	;R (31)
    629  5c1b		       ff		      .byte.b	255	;G
    630  5c1c		       00		      .byte.b	0	;B
    631  5c1d		       ff		      .byte.b	255	;R (30)
    632  5c1e		       ff		      .byte.b	255	;G
    633  5c1f		       00		      .byte.b	0	;B
    634  5c20		       f9		      .byte.b	249	;R (29)
    635  5c21		       f9		      .byte.b	249	;G
    636  5c22		       00		      .byte.b	0	;B
    637  5c23		       fd		      .byte.b	253	;R (28)
    638  5c24		       f9		      .byte.b	249	;G
    639  5c25		       00		      .byte.b	0	;B
    640  5c26		       fd		      .byte.b	253	;R (27)
    641  5c27		       f9		      .byte.b	249	;G
    642  5c28		       00		      .byte.b	0	;B
    643  5c29		       fd		      .byte.b	253	;R (26)
    644  5c2a		       f9		      .byte.b	249	;G
    645  5c2b		       00		      .byte.b	0	;B
    646  5c2c		       fd		      .byte.b	253	;R (25)
    647  5c2d		       f9		      .byte.b	249	;G
    648  5c2e		       00		      .byte.b	0	;B
    649  5c2f		       fd		      .byte.b	253	;R (24)
    650  5c30		       f9		      .byte.b	249	;G
    651  5c31		       00		      .byte.b	0	;B
    652  5c32		       fd		      .byte.b	253	;R (23)
    653  5c33		       f9		      .byte.b	249	;G
    654  5c34		       00		      .byte.b	0	;B
    655  5c35		       fd		      .byte.b	253	;R (22)
    656  5c36		       f9		      .byte.b	249	;G
    657  5c37		       00		      .byte.b	0	;B
    658  5c38		       fd		      .byte.b	253	;R (21)
    659  5c39		       f9		      .byte.b	249	;G
    660  5c3a		       00		      .byte.b	0	;B
    661  5c3b		       fd		      .byte.b	253	;R (20)
    662  5c3c		       f9		      .byte.b	249	;G
    663  5c3d		       00		      .byte.b	0	;B
    664  5c3e		       fd		      .byte.b	253	;R (19)
    665  5c3f		       f9		      .byte.b	249	;G
    666  5c40		       00		      .byte.b	0	;B
    667  5c41		       fd		      .byte.b	253	;R (18)
    668  5c42		       f9		      .byte.b	249	;G
    669  5c43		       00		      .byte.b	0	;B
    670  5c44		       f9		      .byte.b	249	;R (17)
    671  5c45		       fd		      .byte.b	253	;G
    672  5c46		       00		      .byte.b	0	;B
    673  5c47		       f9		      .byte.b	249	;R (16)
    674  5c48		       fd		      .byte.b	253	;G
    675  5c49		       00		      .byte.b	0	;B
    676  5c4a		       f9		      .byte.b	249	;R (15)
    677  5c4b		       fd		      .byte.b	253	;G
    678  5c4c		       00		      .byte.b	0	;B
    679  5c4d		       f9		      .byte.b	249	;R (14)
    680  5c4e		       fd		      .byte.b	253	;G
    681  5c4f		       00		      .byte.b	0	;B
    682  5c50		       f9		      .byte.b	249	;R (13)
    683  5c51		       fd		      .byte.b	253	;G
    684  5c52		       00		      .byte.b	0	;B
    685  5c53		       f9		      .byte.b	249	;R (12)
    686  5c54		       fd		      .byte.b	253	;G
    687  5c55		       00		      .byte.b	0	;B
    688  5c56		       f9		      .byte.b	249	;R (11)
    689  5c57		       fd		      .byte.b	253	;G
    690  5c58		       00		      .byte.b	0	;B
    691  5c59		       f9		      .byte.b	249	;R (10)
    692  5c5a		       fd		      .byte.b	253	;G
    693  5c5b		       00		      .byte.b	0	;B
    694  5c5c		       fb		      .byte.b	251	;R (9)
    695  5c5d		       fb		      .byte.b	251	;G
    696  5c5e		       00		      .byte.b	0	;B
    697  5c5f		       fb		      .byte.b	251	;R (8)
    698  5c60		       fb		      .byte.b	251	;G
    699  5c61		       00		      .byte.b	0	;B
    700  5c62		       ff		      .byte.b	255	;R (7)
    701  5c63		       ff		      .byte.b	255	;G
    702  5c64		       00		      .byte.b	0	;B
    703  5c65		       fe		      .byte.b	254	;R (6)
    704  5c66		       fe		      .byte.b	254	;G
    705  5c67		       00		      .byte.b	0	;B
    706  5c68		       fe		      .byte.b	254	;R (5)
    707  5c69		       fe		      .byte.b	254	;G
    708  5c6a		       00		      .byte.b	0	;B
    709  5c6b		       04		      .byte.b	4	;R (4)
    710  5c6c		       06		      .byte.b	6	;G
    711  5c6d		       00		      .byte.b	0	;B
    712  5c6e		       00		      .byte.b	0	;R (3)
    713  5c6f		       ff		      .byte.b	255	;G
    714  5c70		       00		      .byte.b	0	;B
    715  5c71		       00		      .byte.b	0	;R (2)
    716  5c72		       ff		      .byte.b	255	;G
    717  5c73		       00		      .byte.b	0	;B
    718  5c74		       ff		      .byte.b	255	;R (1)
    719  5c75		       ff		      .byte.b	255	;G
    720  5c76		       ff		      .byte.b	255	;B
    721  5c77		       ff		      .byte.b	255	;R (0)
    722  5c78		       ff		      .byte.b	255	;G
    723  5c79		       ff		      .byte.b	255	;B
    724  5c7a				   COL_3
    725  5c7a		       00		      .byte.b	0	;R (79)
    726  5c7b		       00		      .byte.b	0	;G
    727  5c7c		       00		      .byte.b	0	;B
    728  5c7d		       f0		      .byte.b	240	;R (78)
    729  5c7e		       f0		      .byte.b	240	;G
    730  5c7f		       f0		      .byte.b	240	;B
    731  5c80		       f0		      .byte.b	240	;R (77)
    732  5c81		       f0		      .byte.b	240	;G
    733  5c82		       f0		      .byte.b	240	;B
    734  5c83		       00		      .byte.b	0	;R (76)
    735  5c84		       f0		      .byte.b	240	;G
    736  5c85		       f0		      .byte.b	240	;B
    737  5c86		       00		      .byte.b	0	;R (75)
    738  5c87		       30		      .byte.b	48	;G
    739  5c88		       30		      .byte.b	48	;B
    740  5c89		       00		      .byte.b	0	;R (74)
    741  5c8a		       20		      .byte.b	32	;G
    742  5c8b		       e0		      .byte.b	224	;B
    743  5c8c		       00		      .byte.b	0	;R (73)
    744  5c8d		       20		      .byte.b	32	;G
    745  5c8e		       e0		      .byte.b	224	;B
    746  5c8f		       00		      .byte.b	0	;R (72)
    747  5c90		       20		      .byte.b	32	;G
    748  5c91		       e0		      .byte.b	224	;B
    749  5c92		       00		      .byte.b	0	;R (71)
    750  5c93		       20		      .byte.b	32	;G
    751  5c94		       e0		      .byte.b	224	;B
    752  5c95		       10		      .byte.b	16	;R (70)
    753  5c96		       00		      .byte.b	0	;G
    754  5c97		       d0		      .byte.b	208	;B
    755  5c98		       10		      .byte.b	16	;R (69)
    756  5c99		       00		      .byte.b	0	;G
    757  5c9a		       50		      .byte.b	80	;B
    758  5c9b		       10		      .byte.b	16	;R (68)
    759  5c9c		       00		      .byte.b	0	;G
    760  5c9d		       50		      .byte.b	80	;B
    761  5c9e		       10		      .byte.b	16	;R (67)
    762  5c9f		       00		      .byte.b	0	;G
    763  5ca0		       50		      .byte.b	80	;B
    764  5ca1		       10		      .byte.b	16	;R (66)
    765  5ca2		       00		      .byte.b	0	;G
    766  5ca3		       50		      .byte.b	80	;B
    767  5ca4		       10		      .byte.b	16	;R (65)
    768  5ca5		       00		      .byte.b	0	;G
    769  5ca6		       50		      .byte.b	80	;B
    770  5ca7		       10		      .byte.b	16	;R (64)
    771  5ca8		       00		      .byte.b	0	;G
    772  5ca9		       50		      .byte.b	80	;B
    773  5caa		       10		      .byte.b	16	;R (63)
    774  5cab		       00		      .byte.b	0	;G
    775  5cac		       50		      .byte.b	80	;B
    776  5cad		       10		      .byte.b	16	;R (62)
    777  5cae		       00		      .byte.b	0	;G
    778  5caf		       d0		      .byte.b	208	;B
    779  5cb0		       10		      .byte.b	16	;R (61)
    780  5cb1		       00		      .byte.b	0	;G
    781  5cb2		       d0		      .byte.b	208	;B
    782  5cb3		       10		      .byte.b	16	;R (60)
    783  5cb4		       00		      .byte.b	0	;G
    784  5cb5		       d0		      .byte.b	208	;B
    785  5cb6		       10		      .byte.b	16	;R (59)
    786  5cb7		       00		      .byte.b	0	;G
    787  5cb8		       d0		      .byte.b	208	;B
    788  5cb9		       10		      .byte.b	16	;R (58)
    789  5cba		       00		      .byte.b	0	;G
    790  5cbb		       d0		      .byte.b	208	;B
    791  5cbc		       10		      .byte.b	16	;R (57)
    792  5cbd		       00		      .byte.b	0	;G
    793  5cbe		       d0		      .byte.b	208	;B
    794  5cbf		       10		      .byte.b	16	;R (56)
    795  5cc0		       00		      .byte.b	0	;G
    796  5cc1		       50		      .byte.b	80	;B
    797  5cc2		       10		      .byte.b	16	;R (55)
    798  5cc3		       00		      .byte.b	0	;G
    799  5cc4		       50		      .byte.b	80	;B
    800  5cc5		       10		      .byte.b	16	;R (54)
    801  5cc6		       00		      .byte.b	0	;G
    802  5cc7		       50		      .byte.b	80	;B
    803  5cc8		       10		      .byte.b	16	;R (53)
    804  5cc9		       00		      .byte.b	0	;G
    805  5cca		       50		      .byte.b	80	;B
    806  5ccb		       10		      .byte.b	16	;R (52)
    807  5ccc		       00		      .byte.b	0	;G
    808  5ccd		       50		      .byte.b	80	;B
    809  5cce		       10		      .byte.b	16	;R (51)
    810  5ccf		       00		      .byte.b	0	;G
    811  5cd0		       50		      .byte.b	80	;B
    812  5cd1		       10		      .byte.b	16	;R (50)
    813  5cd2		       00		      .byte.b	0	;G
    814  5cd3		       50		      .byte.b	80	;B
    815  5cd4		       10		      .byte.b	16	;R (49)
    816  5cd5		       00		      .byte.b	0	;G
    817  5cd6		       50		      .byte.b	80	;B
    818  5cd7		       10		      .byte.b	16	;R (48)
    819  5cd8		       00		      .byte.b	0	;G
    820  5cd9		       50		      .byte.b	80	;B
    821  5cda		       10		      .byte.b	16	;R (47)
    822  5cdb		       00		      .byte.b	0	;G
    823  5cdc		       d0		      .byte.b	208	;B
    824  5cdd		       10		      .byte.b	16	;R (46)
    825  5cde		       00		      .byte.b	0	;G
    826  5cdf		       d0		      .byte.b	208	;B
    827  5ce0		       10		      .byte.b	16	;R (45)
    828  5ce1		       00		      .byte.b	0	;G
    829  5ce2		       d0		      .byte.b	208	;B
    830  5ce3		       10		      .byte.b	16	;R (44)
    831  5ce4		       00		      .byte.b	0	;G
    832  5ce5		       d0		      .byte.b	208	;B
    833  5ce6		       00		      .byte.b	0	;R (43)
    834  5ce7		       20		      .byte.b	32	;G
    835  5ce8		       c0		      .byte.b	192	;B
    836  5ce9		       00		      .byte.b	0	;R (42)
    837  5cea		       f0		      .byte.b	240	;G
    838  5ceb		       00		      .byte.b	0	;B
    839  5cec		       00		      .byte.b	0	;R (41)
    840  5ced		       f0		      .byte.b	240	;G
    841  5cee		       00		      .byte.b	0	;B
    842  5cef		       f0		      .byte.b	240	;R (40)
    843  5cf0		       f0		      .byte.b	240	;G
    844  5cf1		       f0		      .byte.b	240	;B
    845  5cf2		       f0		      .byte.b	240	;R (39)
    846  5cf3		       f0		      .byte.b	240	;G
    847  5cf4		       f0		      .byte.b	240	;B
    848  5cf5		       f0		      .byte.b	240	;R (38)
    849  5cf6		       f0		      .byte.b	240	;G
    850  5cf7		       f0		      .byte.b	240	;B
    851  5cf8		       00		      .byte.b	0	;R (37)
    852  5cf9		       f0		      .byte.b	240	;G
    853  5cfa		       f0		      .byte.b	240	;B
    854  5cfb		       00		      .byte.b	0	;R (36)
    855  5cfc		       d0		      .byte.b	208	;G
    856  5cfd		       d0		      .byte.b	208	;B
    857  5cfe		       00		      .byte.b	0	;R (35)
    858  5cff		       90		      .byte.b	144	;G
    859  5d00		       b0		      .byte.b	176	;B
    860  5d01		       00		      .byte.b	0	;R (34)
    861  5d02		       90		      .byte.b	144	;G
    862  5d03		       b0		      .byte.b	176	;B
    863  5d04		       00		      .byte.b	0	;R (33)
    864  5d05		       90		      .byte.b	144	;G
    865  5d06		       b0		      .byte.b	176	;B
    866  5d07		       00		      .byte.b	0	;R (32)
    867  5d08		       90		      .byte.b	144	;G
    868  5d09		       b0		      .byte.b	176	;B
    869  5d0a		       00		      .byte.b	0	;R (31)
    870  5d0b		       80		      .byte.b	128	;G
    871  5d0c		       a0		      .byte.b	160	;B
    872  5d0d		       00		      .byte.b	0	;R (30)
    873  5d0e		       00		      .byte.b	0	;G
    874  5d0f		       a0		      .byte.b	160	;B
    875  5d10		       00		      .byte.b	0	;R (29)
    876  5d11		       00		      .byte.b	0	;G
    877  5d12		       e0		      .byte.b	224	;B
    878  5d13		       00		      .byte.b	0	;R (28)
    879  5d14		       00		      .byte.b	0	;G
    880  5d15		       e0		      .byte.b	224	;B
    881  5d16		       00		      .byte.b	0	;R (27)
    882  5d17		       00		      .byte.b	0	;G
    883  5d18		       e0		      .byte.b	224	;B
    884  5d19		       00		      .byte.b	0	;R (26)
    885  5d1a		       00		      .byte.b	0	;G
    886  5d1b		       e0		      .byte.b	224	;B
    887  5d1c		       00		      .byte.b	0	;R (25)
    888  5d1d		       00		      .byte.b	0	;G
    889  5d1e		       e0		      .byte.b	224	;B
    890  5d1f		       00		      .byte.b	0	;R (24)
    891  5d20		       00		      .byte.b	0	;G
    892  5d21		       e0		      .byte.b	224	;B
    893  5d22		       00		      .byte.b	0	;R (23)
    894  5d23		       00		      .byte.b	0	;G
    895  5d24		       60		      .byte.b	96	;B
    896  5d25		       00		      .byte.b	0	;R (22)
    897  5d26		       00		      .byte.b	0	;G
    898  5d27		       60		      .byte.b	96	;B
    899  5d28		       00		      .byte.b	0	;R (21)
    900  5d29		       00		      .byte.b	0	;G
    901  5d2a		       e0		      .byte.b	224	;B
    902  5d2b		       00		      .byte.b	0	;R (20)
    903  5d2c		       00		      .byte.b	0	;G
    904  5d2d		       e0		      .byte.b	224	;B
    905  5d2e		       00		      .byte.b	0	;R (19)
    906  5d2f		       00		      .byte.b	0	;G
    907  5d30		       e0		      .byte.b	224	;B
    908  5d31		       00		      .byte.b	0	;R (18)
    909  5d32		       00		      .byte.b	0	;G
    910  5d33		       e0		      .byte.b	224	;B
    911  5d34		       00		      .byte.b	0	;R (17)
    912  5d35		       00		      .byte.b	0	;G
    913  5d36		       e0		      .byte.b	224	;B
    914  5d37		       00		      .byte.b	0	;R (16)
    915  5d38		       00		      .byte.b	0	;G
    916  5d39		       e0		      .byte.b	224	;B
    917  5d3a		       00		      .byte.b	0	;R (15)
    918  5d3b		       00		      .byte.b	0	;G
    919  5d3c		       a0		      .byte.b	160	;B
    920  5d3d		       00		      .byte.b	0	;R (14)
    921  5d3e		       00		      .byte.b	0	;G
    922  5d3f		       a0		      .byte.b	160	;B
    923  5d40		       00		      .byte.b	0	;R (13)
    924  5d41		       00		      .byte.b	0	;G
    925  5d42		       a0		      .byte.b	160	;B
    926  5d43		       00		      .byte.b	0	;R (12)
    927  5d44		       80		      .byte.b	128	;G
    928  5d45		       20		      .byte.b	32	;B
    929  5d46		       00		      .byte.b	0	;R (11)
    930  5d47		       80		      .byte.b	128	;G
    931  5d48		       20		      .byte.b	32	;B
    932  5d49		       00		      .byte.b	0	;R (10)
    933  5d4a		       80		      .byte.b	128	;G
    934  5d4b		       20		      .byte.b	32	;B
    935  5d4c		       00		      .byte.b	0	;R (9)
    936  5d4d		       80		      .byte.b	128	;G
    937  5d4e		       20		      .byte.b	32	;B
    938  5d4f		       00		      .byte.b	0	;R (8)
    939  5d50		       80		      .byte.b	128	;G
    940  5d51		       20		      .byte.b	32	;B
    941  5d52		       00		      .byte.b	0	;R (7)
    942  5d53		       80		      .byte.b	128	;G
    943  5d54		       20		      .byte.b	32	;B
    944  5d55		       00		      .byte.b	0	;R (6)
    945  5d56		       80		      .byte.b	128	;G
    946  5d57		       20		      .byte.b	32	;B
    947  5d58		       00		      .byte.b	0	;R (5)
    948  5d59		       80		      .byte.b	128	;G
    949  5d5a		       20		      .byte.b	32	;B
    950  5d5b		       00		      .byte.b	0	;R (4)
    951  5d5c		       90		      .byte.b	144	;G
    952  5d5d		       20		      .byte.b	32	;B
    953  5d5e		       00		      .byte.b	0	;R (3)
    954  5d5f		       f0		      .byte.b	240	;G
    955  5d60		       00		      .byte.b	0	;B
    956  5d61		       00		      .byte.b	0	;R (2)
    957  5d62		       f0		      .byte.b	240	;G
    958  5d63		       00		      .byte.b	0	;B
    959  5d64		       f0		      .byte.b	240	;R (1)
    960  5d65		       f0		      .byte.b	240	;G
    961  5d66		       f0		      .byte.b	240	;B
    962  5d67		       f0		      .byte.b	240	;R (0)
    963  5d68		       f0		      .byte.b	240	;G
    964  5d69		       f0		      .byte.b	240	;B
    965  5d6a				   COL_4
    966  5d6a		       00		      .byte.b	0	;R (79)
    967  5d6b		       00		      .byte.b	0	;G
    968  5d6c		       00		      .byte.b	0	;B
    969  5d6d		       ff		      .byte.b	255	;R (78)
    970  5d6e		       ff		      .byte.b	255	;G
    971  5d6f		       ff		      .byte.b	255	;B
    972  5d70		       ff		      .byte.b	255	;R (77)
    973  5d71		       ff		      .byte.b	255	;G
    974  5d72		       ff		      .byte.b	255	;B
    975  5d73		       00		      .byte.b	0	;R (76)
    976  5d74		       ff		      .byte.b	255	;G
    977  5d75		       ff		      .byte.b	255	;B
    978  5d76		       00		      .byte.b	0	;R (75)
    979  5d77		       79		      .byte.b	121	;G
    980  5d78		       79		      .byte.b	121	;B
    981  5d79		       00		      .byte.b	0	;R (74)
    982  5d7a		       3e		      .byte.b	62	;G
    983  5d7b		       b8		      .byte.b	184	;B
    984  5d7c		       00		      .byte.b	0	;R (73)
    985  5d7d		       3e		      .byte.b	62	;G
    986  5d7e		       b8		      .byte.b	184	;B
    987  5d7f		       00		      .byte.b	0	;R (72)
    988  5d80		       1e		      .byte.b	30	;G
    989  5d81		       d0		      .byte.b	208	;B
    990  5d82		       00		      .byte.b	0	;R (71)
    991  5d83		       0e		      .byte.b	14	;G
    992  5d84		       e0		      .byte.b	224	;B
    993  5d85		       00		      .byte.b	0	;R (70)
    994  5d86		       0f		      .byte.b	15	;G
    995  5d87		       e0		      .byte.b	224	;B
    996  5d88		       00		      .byte.b	0	;R (69)
    997  5d89		       8f		      .byte.b	143	;G
    998  5d8a		       e0		      .byte.b	224	;B
    999  5d8b		       00		      .byte.b	0	;R (68)
   1000  5d8c		       c9		      .byte.b	201	;G
   1001  5d8d		       e2		      .byte.b	226	;B
   1002  5d8e		       00		      .byte.b	0	;R (67)
   1003  5d8f		       c9		      .byte.b	201	;G
   1004  5d90		       e2		      .byte.b	226	;B
   1005  5d91		       00		      .byte.b	0	;R (66)
   1006  5d92		       c9		      .byte.b	201	;G
   1007  5d93		       e2		      .byte.b	226	;B
   1008  5d94		       00		      .byte.b	0	;R (65)
   1009  5d95		       c9		      .byte.b	201	;G
   1010  5d96		       e2		      .byte.b	226	;B
   1011  5d97		       00		      .byte.b	0	;R (64)
   1012  5d98		       89		      .byte.b	137	;G
   1013  5d99		       e2		      .byte.b	226	;B
   1014  5d9a		       00		      .byte.b	0	;R (63)
   1015  5d9b		       89		      .byte.b	137	;G
   1016  5d9c		       e2		      .byte.b	226	;B
   1017  5d9d		       00		      .byte.b	0	;R (62)
   1018  5d9e		       09		      .byte.b	9	;G
   1019  5d9f		       62		      .byte.b	98	;B
   1020  5da0		       00		      .byte.b	0	;R (61)
   1021  5da1		       09		      .byte.b	9	;G
   1022  5da2		       e2		      .byte.b	226	;B
   1023  5da3		       00		      .byte.b	0	;R (60)
   1024  5da4		       09		      .byte.b	9	;G
   1025  5da5		       d2		      .byte.b	210	;B
   1026  5da6		       00		      .byte.b	0	;R (59)
   1027  5da7		       09		      .byte.b	9	;G
   1028  5da8		       d2		      .byte.b	210	;B
   1029  5da9		       00		      .byte.b	0	;R (58)
   1030  5daa		       09		      .byte.b	9	;G
   1031  5dab		       d2		      .byte.b	210	;B
   1032  5dac		       00		      .byte.b	0	;R (57)
   1033  5dad		       09		      .byte.b	9	;G
   1034  5dae		       52		      .byte.b	82	;B
   1035  5daf		       c0		      .byte.b	192	;R (56)
   1036  5db0		       09		      .byte.b	9	;G
   1037  5db1		       22		      .byte.b	34	;B
   1038  5db2		       c0		      .byte.b	192	;R (55)
   1039  5db3		       09		      .byte.b	9	;G
   1040  5db4		       22		      .byte.b	34	;B
   1041  5db5		       c0		      .byte.b	192	;R (54)
   1042  5db6		       09		      .byte.b	9	;G
   1043  5db7		       22		      .byte.b	34	;B
   1044  5db8		       c0		      .byte.b	192	;R (53)
   1045  5db9		       09		      .byte.b	9	;G
   1046  5dba		       22		      .byte.b	34	;B
   1047  5dbb		       c0		      .byte.b	192	;R (52)
   1048  5dbc		       09		      .byte.b	9	;G
   1049  5dbd		       22		      .byte.b	34	;B
   1050  5dbe		       c0		      .byte.b	192	;R (51)
   1051  5dbf		       09		      .byte.b	9	;G
   1052  5dc0		       22		      .byte.b	34	;B
   1053  5dc1		       80		      .byte.b	128	;R (50)
   1054  5dc2		       09		      .byte.b	9	;G
   1055  5dc3		       62		      .byte.b	98	;B
   1056  5dc4		       80		      .byte.b	128	;R (49)
   1057  5dc5		       09		      .byte.b	9	;G
   1058  5dc6		       62		      .byte.b	98	;B
   1059  5dc7		       00		      .byte.b	0	;R (48)
   1060  5dc8		       0d		      .byte.b	13	;G
   1061  5dc9		       60		      .byte.b	96	;B
   1062  5dca		       10		      .byte.b	16	;R (47)
   1063  5dcb		       0d		      .byte.b	13	;G
   1064  5dcc		       c0		      .byte.b	192	;B
   1065  5dcd		       10		      .byte.b	16	;R (46)
   1066  5dce		       0f		      .byte.b	15	;G
   1067  5dcf		       c0		      .byte.b	192	;B
   1068  5dd0		       18		      .byte.b	24	;R (45)
   1069  5dd1		       07		      .byte.b	7	;G
   1070  5dd2		       c0		      .byte.b	192	;B
   1071  5dd3		       18		      .byte.b	24	;R (44)
   1072  5dd4		       07		      .byte.b	7	;G
   1073  5dd5		       80		      .byte.b	128	;B
   1074  5dd6		       3c		      .byte.b	60	;R (43)
   1075  5dd7		       02		      .byte.b	2	;G
   1076  5dd8		       80		      .byte.b	128	;B
   1077  5dd9		       3f		      .byte.b	63	;R (42)
   1078  5dda		       c0		      .byte.b	192	;G
   1079  5ddb		       00		      .byte.b	0	;B
   1080  5ddc		       1f		      .byte.b	31	;R (41)
   1081  5ddd		       e0		      .byte.b	224	;G
   1082  5dde		       00		      .byte.b	0	;B
   1083  5ddf		       ff		      .byte.b	255	;R (40)
   1084  5de0		       ff		      .byte.b	255	;G
   1085  5de1		       ff		      .byte.b	255	;B
   1086  5de2		       ff		      .byte.b	255	;R (39)
   1087  5de3		       ff		      .byte.b	255	;G
   1088  5de4		       ff		      .byte.b	255	;B
   1089  5de5		       ff		      .byte.b	255	;R (38)
   1090  5de6		       ff		      .byte.b	255	;G
   1091  5de7		       ff		      .byte.b	255	;B
   1092  5de8		       00		      .byte.b	0	;R (37)
   1093  5de9		       ff		      .byte.b	255	;G
   1094  5dea		       ff		      .byte.b	255	;B
   1095  5deb		       00		      .byte.b	0	;R (36)
   1096  5dec		       00		      .byte.b	0	;G
   1097  5ded		       00		      .byte.b	0	;B
   1098  5dee		       00		      .byte.b	0	;R (35)
   1099  5def		       00		      .byte.b	0	;G
   1100  5df0		       ff		      .byte.b	255	;B
   1101  5df1		       00		      .byte.b	0	;R (34)
   1102  5df2		       00		      .byte.b	0	;G
   1103  5df3		       ff		      .byte.b	255	;B
   1104  5df4		       00		      .byte.b	0	;R (33)
   1105  5df5		       00		      .byte.b	0	;G
   1106  5df6		       80		      .byte.b	128	;B
   1107  5df7		       00		      .byte.b	0	;R (32)
   1108  5df8		       00		      .byte.b	0	;G
   1109  5df9		       80		      .byte.b	128	;B
   1110  5dfa		       00		      .byte.b	0	;R (31)
   1111  5dfb		       00		      .byte.b	0	;G
   1112  5dfc		       80		      .byte.b	128	;B
   1113  5dfd		       00		      .byte.b	0	;R (30)
   1114  5dfe		       00		      .byte.b	0	;G
   1115  5dff		       80		      .byte.b	128	;B
   1116  5e00		       00		      .byte.b	0	;R (29)
   1117  5e01		       00		      .byte.b	0	;G
   1118  5e02		       80		      .byte.b	128	;B
   1119  5e03		       00		      .byte.b	0	;R (28)
   1120  5e04		       00		      .byte.b	0	;G
   1121  5e05		       80		      .byte.b	128	;B
   1122  5e06		       00		      .byte.b	0	;R (27)
   1123  5e07		       00		      .byte.b	0	;G
   1124  5e08		       80		      .byte.b	128	;B
   1125  5e09		       00		      .byte.b	0	;R (26)
   1126  5e0a		       7f		      .byte.b	127	;G
   1127  5e0b		       7f		      .byte.b	127	;B
   1128  5e0c		       00		      .byte.b	0	;R (25)
   1129  5e0d		       7f		      .byte.b	127	;G
   1130  5e0e		       7f		      .byte.b	127	;B
   1131  5e0f		       00		      .byte.b	0	;R (24)
   1132  5e10		       7f		      .byte.b	127	;G
   1133  5e11		       7f		      .byte.b	127	;B
   1134  5e12		       ff		      .byte.b	255	;R (23)
   1135  5e13		       00		      .byte.b	0	;G
   1136  5e14		       00		      .byte.b	0	;B
   1137  5e15		       ff		      .byte.b	255	;R (22)
   1138  5e16		       00		      .byte.b	0	;G
   1139  5e17		       00		      .byte.b	0	;B
   1140  5e18		       7f		      .byte.b	127	;R (21)
   1141  5e19		       00		      .byte.b	0	;G
   1142  5e1a		       00		      .byte.b	0	;B
   1143  5e1b		       7f		      .byte.b	127	;R (20)
   1144  5e1c		       00		      .byte.b	0	;G
   1145  5e1d		       00		      .byte.b	0	;B
   1146  5e1e		       7f		      .byte.b	127	;R (19)
   1147  5e1f		       00		      .byte.b	0	;G
   1148  5e20		       00		      .byte.b	0	;B
   1149  5e21		       7f		      .byte.b	127	;R (18)
   1150  5e22		       00		      .byte.b	0	;G
   1151  5e23		       00		      .byte.b	0	;B
   1152  5e24		       00		      .byte.b	0	;R (17)
   1153  5e25		       00		      .byte.b	0	;G
   1154  5e26		       80		      .byte.b	128	;B
   1155  5e27		       00		      .byte.b	0	;R (16)
   1156  5e28		       00		      .byte.b	0	;G
   1157  5e29		       80		      .byte.b	128	;B
   1158  5e2a		       00		      .byte.b	0	;R (15)
   1159  5e2b		       00		      .byte.b	0	;G
   1160  5e2c		       80		      .byte.b	128	;B
   1161  5e2d		       00		      .byte.b	0	;R (14)
   1162  5e2e		       00		      .byte.b	0	;G
   1163  5e2f		       80		      .byte.b	128	;B
   1164  5e30		       00		      .byte.b	0	;R (13)
   1165  5e31		       00		      .byte.b	0	;G
   1166  5e32		       80		      .byte.b	128	;B
   1167  5e33		       00		      .byte.b	0	;R (12)
   1168  5e34		       00		      .byte.b	0	;G
   1169  5e35		       80		      .byte.b	128	;B
   1170  5e36		       00		      .byte.b	0	;R (11)
   1171  5e37		       00		      .byte.b	0	;G
   1172  5e38		       80		      .byte.b	128	;B
   1173  5e39		       00		      .byte.b	0	;R (10)
   1174  5e3a		       00		      .byte.b	0	;G
   1175  5e3b		       80		      .byte.b	128	;B
   1176  5e3c		       00		      .byte.b	0	;R (9)
   1177  5e3d		       00		      .byte.b	0	;G
   1178  5e3e		       80		      .byte.b	128	;B
   1179  5e3f		       00		      .byte.b	0	;R (8)
   1180  5e40		       00		      .byte.b	0	;G
   1181  5e41		       ff		      .byte.b	255	;B
   1182  5e42		       00		      .byte.b	0	;R (7)
   1183  5e43		       00		      .byte.b	0	;G
   1184  5e44		       ff		      .byte.b	255	;B
   1185  5e45		       00		      .byte.b	0	;R (6)
   1186  5e46		       00		      .byte.b	0	;G
   1187  5e47		       ff		      .byte.b	255	;B
   1188  5e48		       00		      .byte.b	0	;R (5)
   1189  5e49		       00		      .byte.b	0	;G
   1190  5e4a		       ff		      .byte.b	255	;B
   1191  5e4b		       00		      .byte.b	0	;R (4)
   1192  5e4c		       00		      .byte.b	0	;G
   1193  5e4d		       ff		      .byte.b	255	;B
   1194  5e4e		       00		      .byte.b	0	;R (3)
   1195  5e4f		       ff		      .byte.b	255	;G
   1196  5e50		       00		      .byte.b	0	;B
   1197  5e51		       00		      .byte.b	0	;R (2)
   1198  5e52		       ff		      .byte.b	255	;G
   1199  5e53		       00		      .byte.b	0	;B
   1200  5e54		       ff		      .byte.b	255	;R (1)
   1201  5e55		       ff		      .byte.b	255	;G
   1202  5e56		       ff		      .byte.b	255	;B
   1203  5e57		       ff		      .byte.b	255	;R (0)
   1204  5e58		       ff		      .byte.b	255	;G
   1205  5e59		       ff		      .byte.b	255	;B
   1206  5e5a				   COL_5
   1207  5e5a		       00		      .byte.b	0	;R (79)
   1208  5e5b		       00		      .byte.b	0	;G
   1209  5e5c		       00		      .byte.b	0	;B
   1210  5e5d		       3f		      .byte.b	63	;R (78)
   1211  5e5e		       3f		      .byte.b	63	;G
   1212  5e5f		       3f		      .byte.b	63	;B
   1213  5e60		       7f		      .byte.b	127	;R (77)
   1214  5e61		       7f		      .byte.b	127	;G
   1215  5e62		       7f		      .byte.b	127	;B
   1216  5e63		       40		      .byte.b	64	;R (76)
   1217  5e64		       7f		      .byte.b	127	;G
   1218  5e65		       7f		      .byte.b	127	;B
   1219  5e66		       c0		      .byte.b	192	;R (75)
   1220  5e67		       f3		      .byte.b	243	;G
   1221  5e68		       f3		      .byte.b	243	;B
   1222  5e69		       8c		      .byte.b	140	;R (74)
   1223  5e6a		       ef		      .byte.b	239	;G
   1224  5e6b		       e3		      .byte.b	227	;B
   1225  5e6c		       8c		      .byte.b	140	;R (73)
   1226  5e6d		       ef		      .byte.b	239	;G
   1227  5e6e		       e3		      .byte.b	227	;B
   1228  5e6f		       8e		      .byte.b	142	;R (72)
   1229  5e70		       ef		      .byte.b	239	;G
   1230  5e71		       e1		      .byte.b	225	;B
   1231  5e72		       8e		      .byte.b	142	;R (71)
   1232  5e73		       ef		      .byte.b	239	;G
   1233  5e74		       e1		      .byte.b	225	;B
   1234  5e75		       9e		      .byte.b	158	;R (70)
   1235  5e76		       9e		      .byte.b	158	;G
   1236  5e77		       c0		      .byte.b	192	;B
   1237  5e78		       9e		      .byte.b	158	;R (69)
   1238  5e79		       9e		      .byte.b	158	;G
   1239  5e7a		       c0		      .byte.b	192	;B
   1240  5e7b		       92		      .byte.b	146	;R (68)
   1241  5e7c		       92		      .byte.b	146	;G
   1242  5e7d		       c8		      .byte.b	200	;B
   1243  5e7e		       92		      .byte.b	146	;R (67)
   1244  5e7f		       92		      .byte.b	146	;G
   1245  5e80		       c8		      .byte.b	200	;B
   1246  5e81		       92		      .byte.b	146	;R (66)
   1247  5e82		       92		      .byte.b	146	;G
   1248  5e83		       c8		      .byte.b	200	;B
   1249  5e84		       92		      .byte.b	146	;R (65)
   1250  5e85		       92		      .byte.b	146	;G
   1251  5e86		       c8		      .byte.b	200	;B
   1252  5e87		       92		      .byte.b	146	;R (64)
   1253  5e88		       92		      .byte.b	146	;G
   1254  5e89		       c8		      .byte.b	200	;B
   1255  5e8a		       92		      .byte.b	146	;R (63)
   1256  5e8b		       92		      .byte.b	146	;G
   1257  5e8c		       c8		      .byte.b	200	;B
   1258  5e8d		       92		      .byte.b	146	;R (62)
   1259  5e8e		       92		      .byte.b	146	;G
   1260  5e8f		       c8		      .byte.b	200	;B
   1261  5e90		       92		      .byte.b	146	;R (61)
   1262  5e91		       92		      .byte.b	146	;G
   1263  5e92		       c8		      .byte.b	200	;B
   1264  5e93		       92		      .byte.b	146	;R (60)
   1265  5e94		       92		      .byte.b	146	;G
   1266  5e95		       c8		      .byte.b	200	;B
   1267  5e96		       92		      .byte.b	146	;R (59)
   1268  5e97		       92		      .byte.b	146	;G
   1269  5e98		       c8		      .byte.b	200	;B
   1270  5e99		       92		      .byte.b	146	;R (58)
   1271  5e9a		       92		      .byte.b	146	;G
   1272  5e9b		       c8		      .byte.b	200	;B
   1273  5e9c		       92		      .byte.b	146	;R (57)
   1274  5e9d		       92		      .byte.b	146	;G
   1275  5e9e		       c8		      .byte.b	200	;B
   1276  5e9f		       92		      .byte.b	146	;R (56)
   1277  5ea0		       92		      .byte.b	146	;G
   1278  5ea1		       c8		      .byte.b	200	;B
   1279  5ea2		       92		      .byte.b	146	;R (55)
   1280  5ea3		       92		      .byte.b	146	;G
   1281  5ea4		       c8		      .byte.b	200	;B
   1282  5ea5		       92		      .byte.b	146	;R (54)
   1283  5ea6		       92		      .byte.b	146	;G
   1284  5ea7		       c8		      .byte.b	200	;B
   1285  5ea8		       92		      .byte.b	146	;R (53)
   1286  5ea9		       92		      .byte.b	146	;G
   1287  5eaa		       c8		      .byte.b	200	;B
   1288  5eab		       92		      .byte.b	146	;R (52)
   1289  5eac		       92		      .byte.b	146	;G
   1290  5ead		       c8		      .byte.b	200	;B
   1291  5eae		       92		      .byte.b	146	;R (51)
   1292  5eaf		       92		      .byte.b	146	;G
   1293  5eb0		       c8		      .byte.b	200	;B
   1294  5eb1		       92		      .byte.b	146	;R (50)
   1295  5eb2		       92		      .byte.b	146	;G
   1296  5eb3		       c8		      .byte.b	200	;B
   1297  5eb4		       92		      .byte.b	146	;R (49)
   1298  5eb5		       92		      .byte.b	146	;G
   1299  5eb6		       c8		      .byte.b	200	;B
   1300  5eb7		       96		      .byte.b	150	;R (48)
   1301  5eb8		       96		      .byte.b	150	;G
   1302  5eb9		       c0		      .byte.b	192	;B
   1303  5eba		       96		      .byte.b	150	;R (47)
   1304  5ebb		       96		      .byte.b	150	;G
   1305  5ebc		       c0		      .byte.b	192	;B
   1306  5ebd		       9e		      .byte.b	158	;R (46)
   1307  5ebe		       9e		      .byte.b	158	;G
   1308  5ebf		       c0		      .byte.b	192	;B
   1309  5ec0		       9e		      .byte.b	158	;R (45)
   1310  5ec1		       9c		      .byte.b	156	;G
   1311  5ec2		       c0		      .byte.b	192	;B
   1312  5ec3		       9e		      .byte.b	158	;R (44)
   1313  5ec4		       9c		      .byte.b	156	;G
   1314  5ec5		       c0		      .byte.b	192	;B
   1315  5ec6		       ef		      .byte.b	239	;R (43)
   1316  5ec7		       88		      .byte.b	136	;G
   1317  5ec8		       80		      .byte.b	128	;B
   1318  5ec9		       7f		      .byte.b	127	;R (42)
   1319  5eca		       40		      .byte.b	64	;G
   1320  5ecb		       40		      .byte.b	64	;B
   1321  5ecc		       7f		      .byte.b	127	;R (41)
   1322  5ecd		       40		      .byte.b	64	;G
   1323  5ece		       40		      .byte.b	64	;B
   1324  5ecf		       7f		      .byte.b	127	;R (40)
   1325  5ed0		       7f		      .byte.b	127	;G
   1326  5ed1		       7f		      .byte.b	127	;B
   1327  5ed2		       3f		      .byte.b	63	;R (39)
   1328  5ed3		       3f		      .byte.b	63	;G
   1329  5ed4		       3f		      .byte.b	63	;B
   1330  5ed5		       7f		      .byte.b	127	;R (38)
   1331  5ed6		       7f		      .byte.b	127	;G
   1332  5ed7		       7f		      .byte.b	127	;B
   1333  5ed8		       40		      .byte.b	64	;R (37)
   1334  5ed9		       7f		      .byte.b	127	;G
   1335  5eda		       7f		      .byte.b	127	;B
   1336  5edb		       c0		      .byte.b	192	;R (36)
   1337  5edc		       f9		      .byte.b	249	;G
   1338  5edd		       f9		      .byte.b	249	;B
   1339  5ede		       86		      .byte.b	134	;R (35)
   1340  5edf		       f0		      .byte.b	240	;G
   1341  5ee0		       f6		      .byte.b	246	;B
   1342  5ee1		       86		      .byte.b	134	;R (34)
   1343  5ee2		       f0		      .byte.b	240	;G
   1344  5ee3		       f6		      .byte.b	246	;B
   1345  5ee4		       87		      .byte.b	135	;R (33)
   1346  5ee5		       f0		      .byte.b	240	;G
   1347  5ee6		       f7		      .byte.b	247	;B
   1348  5ee7		       87		      .byte.b	135	;R (32)
   1349  5ee8		       f0		      .byte.b	240	;G
   1350  5ee9		       f7		      .byte.b	247	;B
   1351  5eea		       8f		      .byte.b	143	;R (31)
   1352  5eeb		       80		      .byte.b	128	;G
   1353  5eec		       cf		      .byte.b	207	;B
   1354  5eed		       8f		      .byte.b	143	;R (30)
   1355  5eee		       80		      .byte.b	128	;G
   1356  5eef		       cf		      .byte.b	207	;B
   1357  5ef0		       89		      .byte.b	137	;R (29)
   1358  5ef1		       84		      .byte.b	132	;G
   1359  5ef2		       cd		      .byte.b	205	;B
   1360  5ef3		       89		      .byte.b	137	;R (28)
   1361  5ef4		       84		      .byte.b	132	;G
   1362  5ef5		       cd		      .byte.b	205	;B
   1363  5ef6		       89		      .byte.b	137	;R (27)
   1364  5ef7		       84		      .byte.b	132	;G
   1365  5ef8		       cd		      .byte.b	205	;B
   1366  5ef9		       89		      .byte.b	137	;R (26)
   1367  5efa		       84		      .byte.b	132	;G
   1368  5efb		       cd		      .byte.b	205	;B
   1369  5efc		       89		      .byte.b	137	;R (25)
   1370  5efd		       84		      .byte.b	132	;G
   1371  5efe		       cd		      .byte.b	205	;B
   1372  5eff		       89		      .byte.b	137	;R (24)
   1373  5f00		       84		      .byte.b	132	;G
   1374  5f01		       cd		      .byte.b	205	;B
   1375  5f02		       89		      .byte.b	137	;R (23)
   1376  5f03		       84		      .byte.b	132	;G
   1377  5f04		       cd		      .byte.b	205	;B
   1378  5f05		       89		      .byte.b	137	;R (22)
   1379  5f06		       84		      .byte.b	132	;G
   1380  5f07		       cd		      .byte.b	205	;B
   1381  5f08		       8d		      .byte.b	141	;R (21)
   1382  5f09		       80		      .byte.b	128	;G
   1383  5f0a		       c9		      .byte.b	201	;B
   1384  5f0b		       8d		      .byte.b	141	;R (20)
   1385  5f0c		       80		      .byte.b	128	;G
   1386  5f0d		       c9		      .byte.b	201	;B
   1387  5f0e		       8d		      .byte.b	141	;R (19)
   1388  5f0f		       80		      .byte.b	128	;G
   1389  5f10		       c9		      .byte.b	201	;B
   1390  5f11		       8d		      .byte.b	141	;R (18)
   1391  5f12		       80		      .byte.b	128	;G
   1392  5f13		       c9		      .byte.b	201	;B
   1393  5f14		       8d		      .byte.b	141	;R (17)
   1394  5f15		       80		      .byte.b	128	;G
   1395  5f16		       c9		      .byte.b	201	;B
   1396  5f17		       8d		      .byte.b	141	;R (16)
   1397  5f18		       80		      .byte.b	128	;G
   1398  5f19		       c9		      .byte.b	201	;B
   1399  5f1a		       8d		      .byte.b	141	;R (15)
   1400  5f1b		       80		      .byte.b	128	;G
   1401  5f1c		       c9		      .byte.b	201	;B
   1402  5f1d		       8d		      .byte.b	141	;R (14)
   1403  5f1e		       80		      .byte.b	128	;G
   1404  5f1f		       c9		      .byte.b	201	;B
   1405  5f20		       8d		      .byte.b	141	;R (13)
   1406  5f21		       80		      .byte.b	128	;G
   1407  5f22		       c9		      .byte.b	201	;B
   1408  5f23		       8d		      .byte.b	141	;R (12)
   1409  5f24		       80		      .byte.b	128	;G
   1410  5f25		       c9		      .byte.b	201	;B
   1411  5f26		       8d		      .byte.b	141	;R (11)
   1412  5f27		       80		      .byte.b	128	;G
   1413  5f28		       c9		      .byte.b	201	;B
   1414  5f29		       8d		      .byte.b	141	;R (10)
   1415  5f2a		       80		      .byte.b	128	;G
   1416  5f2b		       c9		      .byte.b	201	;B
   1417  5f2c		       8b		      .byte.b	139	;R (9)
   1418  5f2d		       80		      .byte.b	128	;G
   1419  5f2e		       cb		      .byte.b	203	;B
   1420  5f2f		       8b		      .byte.b	139	;R (8)
   1421  5f30		       80		      .byte.b	128	;G
   1422  5f31		       cb		      .byte.b	203	;B
   1423  5f32		       8f		      .byte.b	143	;R (7)
   1424  5f33		       80		      .byte.b	128	;G
   1425  5f34		       cf		      .byte.b	207	;B
   1426  5f35		       8e		      .byte.b	142	;R (6)
   1427  5f36		       80		      .byte.b	128	;G
   1428  5f37		       ce		      .byte.b	206	;B
   1429  5f38		       8e		      .byte.b	142	;R (5)
   1430  5f39		       80		      .byte.b	128	;G
   1431  5f3a		       ce		      .byte.b	206	;B
   1432  5f3b		       e4		      .byte.b	228	;R (4)
   1433  5f3c		       92		      .byte.b	146	;G
   1434  5f3d		       84		      .byte.b	132	;B
   1435  5f3e		       60		      .byte.b	96	;R (3)
   1436  5f3f		       5f		      .byte.b	95	;G
   1437  5f40		       40		      .byte.b	64	;B
   1438  5f41		       60		      .byte.b	96	;R (2)
   1439  5f42		       5f		      .byte.b	95	;G
   1440  5f43		       40		      .byte.b	64	;B
   1441  5f44		       7f		      .byte.b	127	;R (1)
   1442  5f45		       7f		      .byte.b	127	;G
   1443  5f46		       7f		      .byte.b	127	;B
   1444  5f47		       3f		      .byte.b	63	;R (0)
   1445  5f48		       3f		      .byte.b	63	;G
   1446  5f49		       3f		      .byte.b	63	;B
------- FILE titleScreen.asm
    169  5f4a							;    include "pizza.asm"
    170  5f4a
      0  5f4a					      CHECK_BANK_SIZE	"TITLESCREEN"
      1  5f4a		       07 4a	   .TEMP      =	* - BANK_START
 TITLESCREEN (2K) SIZE =  $74a , FREE= $b6
      2  5f4a					      ECHO	"TITLESCREEN", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5f4a				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  5f4a				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5f4a				  -	      ERR
      6  5f4a					      endif
------- FILE ./sokoboo.asm
------- FILE levelScreen.asm LEVEL 2 PASS 3
      0  5f4a					      include	"levelScreen.asm"
      0  5f4a					      NEWBANK	LEVELSCREEN
      1  67a0 ????				      SEG	LEVELSCREEN
      2  6000					      ORG	ORIGIN
      3  6000					      RORG	$F000
      4  6000				   BANK_START SET	*
      5  6000				   LEVELSCREEN SET	ORIGIN / 2048
      6  6000				   ORIGIN     SET	ORIGIN + 2048
      7  6000				   _CURRENT_BANK SET	LEVELSCREEN
      2  6000
      3  6000		       00 12	   TOPHAT     =	18
      4  6000		       00 20	   BIGDIG_SIZE =	32
      5  6000
      6  6000
      0  6000					      DEFINE_SUBROUTINE	SelectionScreenInit
      1  6000		       00 0c	   BANK_SelectionScreenInit =	_CURRENT_BANK
      2  6000					      SUBROUTINE
      3  6000				   SelectionScreenInit
      8  6000
      9  6000		       a9 00		      lda	#%0
     10  6002		       85 44		      sta	NUSIZ0
     11  6004		       85 45		      sta	NUSIZ1
     12  6006		       85 65		      sta	VDELP0
     13  6008		       85 66		      sta	VDELP1
     14  600a		       85 4b		      sta	REFP0
     15  600c		       85 4c		      sta	REFP1
     16  600e							;		  sta COLUBK
     17  600e		       85 59		      sta	AUDV0
     18  6010		       85 5a		      sta	AUDV1	; turn off music while levels init
     19  6012
     20  6012		       a9 14		      lda	#20
     21  6014		       85 e2		      sta	digitick
     22  6016
     23  6016		       a9 f0		      lda	#%11110000
     24  6018		       85 60		      sta	HMP0
     25  601a
     26  601a		       a9 d0		      lda	#%11010000
     27  601c		       85 61		      sta	HMP1
     28  601e
     29  601e
     30  601e		       a9 04		      lda	#%100
     31  6020		       85 4a		      sta	CTRLPF
     32  6022
     33  6022		       a6 80		      ldx	Platform
     34  6024							;		  lda PlatformAdjustColour,x
      0  6024					      NEXT_RANDOM
      1  6024
      2  6024		       a5 c8		      lda	rnd
      3  6026		       4a		      lsr
      4  6027					      IFCONST	rndHi
      5  6027		       66 c7		      ror	rndHi
      6  6029					      ENDIF
      7  6029		       90 02		      bcc	.skipEOR
      8  602b		       49 b4		      eor	#RND_EOR_VAL
      9  602d				   .skipEOR
     10  602d		       85 c8		      sta	rnd
     36  602f		       29 f0		      and	#$F0
     37  6031		       85 ef		      sta	adjustColour
     38  6033							;		  lda PlatformWallColour,x
      0  6033					      NEXT_RANDOM
      1  6033
      2  6033		       a5 c8		      lda	rnd
      3  6035		       4a		      lsr
      4  6036					      IFCONST	rndHi
      5  6036		       66 c7		      ror	rndHi
      6  6038					      ENDIF
      7  6038		       90 02		      bcc	.skipEOR
      8  603a		       49 b4		      eor	#RND_EOR_VAL
      9  603c				   .skipEOR
     10  603c		       85 c8		      sta	rnd
     40  603e		       29 f0		      and	#$F0
     41  6040		       d0 02		      bne	n00
     42  6042		       a9 02		      lda	#2
     43  6044				   n00
     44  6044		       85 ee		      sta	wallColour
     45  6046
     46  6046		       85 46		      sta	COLUP0
     47  6048		       85 47		      sta	COLUP1
     48  604a
     49  604a		       60		      rts
     50  604b
     51  604b				   PlatformWallColour
     52  604b		       f0 f0 22 22	      .byte.b	$F0, $F0, $22, $22
     53  604f				   PlatformAdjustColour
     54  604f		       00 00 c0 c0	      .byte.b	0,0, $c0, $c0
     55  6053
      0  6053					      DEFINE_SUBROUTINE	LevelScreen
      1  6053		       00 0c	   BANK_LevelScreen =	_CURRENT_BANK
      2  6053					      SUBROUTINE
      3  6053				   LevelScreen
     57  6053
     58  6053		       85 ea		      sta	selector
     59  6055
     60  6055							;    lda #%10
     61  6055							;    sta VBLANK
     62  6055
     63  6055
     64  6055		       20 00 f0 	      jsr	SelectionScreenInit
     65  6058
     66  6058		       a9 ff		      lda	#-1
     67  605a		       85 e6		      sta	endwait
     68  605c
     69  605c		       a9 ff		      lda	#-1
     70  605e		       85 e3		      sta	targetDigit
     71  6060		       85 e4		      sta	targetDigit+1
     72  6062		       85 e5		      sta	targetDigit+2
     73  6064
     74  6064		       a9 00		      lda	#0
     75  6066		       85 df		      sta	digit
     76  6068		       85 e0		      sta	digit+1
     77  606a		       85 e1		      sta	digit+2
     78  606c		       85 eb		      sta	walkSpeed
     79  606e
     80  606e							; convert to 3 digits decimal
     81  606e		       20 04 f3 	      jsr	dd3
     82  6071
     83  6071		       20 1d f3 	      jsr	fixWalkFrame
     84  6074
      0  6074					      RESYNC		; uses overlay
      1  6074
      2  6074		       a9 02		      lda	#%10
      3  6076		       85 41		      sta	VBLANK
      4  6078
      5  6078		       a2 08		      ldx	#8
      6  607a				   .loopResync
      0  607a					      VERTICAL_SYNC
      1  607a		       a9 0e		      lda	#%1110
      2  607c		       85 42	   .VSLP1     sta	WSYNC
      3  607e		       85 40		      sta	VSYNC
      4  6080		       4a		      lsr
      5  6081		       d0 f9		      bne	.VSLP1
      8  6083
      9  6083		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  6085		       a5 80		      lda	Platform
     11  6087		       49 02		      eor	#PAL_50
     12  6089		       d0 02		      bne	.ntsc
     13  608b		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  608d				   .ntsc
     15  608d				   .loopWait
     16  608d		       85 42		      sta	WSYNC
     17  608f		       85 42		      sta	WSYNC
     18  6091		       88		      dey
     19  6092		       d0 f9		      bne	.loopWait
     20  6094		       ca		      dex
     21  6095		       d0 e3		      bne	.loopResync
     86  6097
     87  6097		       a5 ea		      lda	selector
     88  6099		       f0 0c		      beq	RestartFrameX
     89  609b
     90  609b		       a5 e3		      lda	targetDigit
     91  609d		       85 df		      sta	digit
     92  609f		       a5 e5		      lda	targetDigit+2
     93  60a1		       85 e1		      sta	digit+2
     94  60a3		       a5 e4		      lda	targetDigit+1
     95  60a5		       85 e0		      sta	digit+1
     96  60a7
     97  60a7
     98  60a7				   RestartFrameX
     99  60a7		       a9 0e		      lda	#%1110	; VSYNC ON
    100  60a9		       85 42	   .loopVSync3 sta	WSYNC
    101  60ab		       85 40		      sta	VSYNC
    102  60ad		       4a		      lsr
    103  60ae		       d0 f9		      bne	.loopVSync3	; branch until VYSNC has been reset
    104  60b0
    105  60b0		       a6 80		      ldx	Platform
    106  60b2		       bd ba f3 	      lda	VBlankTime2x,x
    107  60b5		       8d 96 02 	      sta	TIM64T
    108  60b8
    109  60b8		       a9 02		      lda	#2
    110  60ba		       85 41		      sta	VBLANK
    111  60bc		       a2 25		      ldx	#37
    112  60be		       85 42	   toplines   sta	WSYNC
    113  60c0		       ca		      dex
    114  60c1		       d0 fb		      bne	toplines
    115  60c3		       86 41		      stx	VBLANK
    116  60c5
    117  60c5		       a9 00		      lda	#0
    118  60c7		       85 49		      sta	COLUBK
    119  60c9
    120  60c9		       ad 84 02    topsync    lda	INTIM
    121  60cc		       d0 fb		      bne	topsync
    122  60ce
    123  60ce							;		  ldx Platform
    124  60ce							;		  ldy VBlankTime2x,x
    125  60ce							;		  sty TIM64T
    126  60ce
    127  60ce		       a5 e1		      lda	digit+2	; hundreds
    128  60d0		       0a		      asl
    129  60d1		       aa		      tax
    130  60d2		       bd ee f3 	      lda	DIGITHUND,x
    131  60d5		       85 e8		      sta	digitHundreds
    132  60d7		       bd ef f3 	      lda	DIGITHUND+1,x
    133  60da		       85 e9		      sta	digitHundreds+1
    134  60dc
    135  60dc		       a5 e0		      lda	digit+1	; tens
    136  60de		       0a		      asl
    137  60df		       aa		      tax
    138  60e0		       bd c6 f3 	      lda	LDIGIT,x
    139  60e3		       85 d9		      sta	digit1
    140  60e5		       bd c7 f3 	      lda	LDIGIT+1,x
    141  60e8		       85 da		      sta	digit1+1
    142  60ea
    143  60ea		       a5 df		      lda	digit	; units
    144  60ec		       0a		      asl
    145  60ed		       aa		      tax
    146  60ee		       bd da f3 	      lda	RDIGIT,x
    147  60f1		       85 db		      sta	digit2
    148  60f3		       bd db f3 	      lda	RDIGIT+1,x
    149  60f6		       85 dc		      sta	digit2+1
    150  60f8
    151  60f8
    152  60f8
    153  60f8							;------------------------------------------------------------------
    154  60f8
    155  60f8
    156  60f8							;VerticalBlankX;
    157  60f8							;		  lda INTIM
    158  60f8							;		  bne VerticalBlankX
    159  60f8
    160  60f8
    161  60f8		       a9 00		      lda	#0
    162  60fa		       85 4d		      sta	PF0
    163  60fc		       85 4e		      sta	PF1
    164  60fe		       85 4f		      sta	PF2
    165  6100		       85 49		      sta	COLUBK
    166  6102
    167  6102							; position the sprites for the box walls
    168  6102
    169  6102		       85 42		      sta	WSYNC
    170  6104
      0  6104					      SLEEP	17
      1  6104				   .CYCLES    SET	17
      2  6104
      3  6104				  -	      IF	.CYCLES < 2
      4  6104				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  6104				  -	      ERR
      6  6104					      ENDIF
      7  6104
      8  6104					      IF	.CYCLES & 1
      9  6104					      IFNCONST	NO_ILLEGAL_OPCODES
     10  6104		       04 00		      nop	0
     11  6106				  -	      ELSE
     12  6106				  -	      bit	VSYNC
     13  6106					      ENDIF
     14  6106				   .CYCLES    SET	.CYCLES - 3
     15  6106					      ENDIF
     16  6106
     17  6106					      REPEAT	.CYCLES / 2
     18  6106		       ea		      nop
     17  6106					      REPEND
     18  6107		       ea		      nop
     17  6107					      REPEND
     18  6108		       ea		      nop
     17  6108					      REPEND
     18  6109		       ea		      nop
     17  6109					      REPEND
     18  610a		       ea		      nop
     17  610a					      REPEND
     18  610b		       ea		      nop
     17  610b					      REPEND
     18  610c		       ea		      nop
     19  610d					      REPEND
    172  610d		       85 50		      sta	RESP0
    173  610f
      0  610f					      SLEEP	37
      1  610f				   .CYCLES    SET	37
      2  610f
      3  610f				  -	      IF	.CYCLES < 2
      4  610f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  610f				  -	      ERR
      6  610f					      ENDIF
      7  610f
      8  610f					      IF	.CYCLES & 1
      9  610f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  610f		       04 00		      nop	0
     11  6111				  -	      ELSE
     12  6111				  -	      bit	VSYNC
     13  6111					      ENDIF
     14  6111				   .CYCLES    SET	.CYCLES - 3
     15  6111					      ENDIF
     16  6111
     17  6111					      REPEAT	.CYCLES / 2
     18  6111		       ea		      nop
     17  6111					      REPEND
     18  6112		       ea		      nop
     17  6112					      REPEND
     18  6113		       ea		      nop
     17  6113					      REPEND
     18  6114		       ea		      nop
     17  6114					      REPEND
     18  6115		       ea		      nop
     17  6115					      REPEND
     18  6116		       ea		      nop
     17  6116					      REPEND
     18  6117		       ea		      nop
     17  6117					      REPEND
     18  6118		       ea		      nop
     17  6118					      REPEND
     18  6119		       ea		      nop
     17  6119					      REPEND
     18  611a		       ea		      nop
     17  611a					      REPEND
     18  611b		       ea		      nop
     17  611b					      REPEND
     18  611c		       ea		      nop
     17  611c					      REPEND
     18  611d		       ea		      nop
     17  611d					      REPEND
     18  611e		       ea		      nop
     17  611e					      REPEND
     18  611f		       ea		      nop
     17  611f					      REPEND
     18  6120		       ea		      nop
     17  6120					      REPEND
     18  6121		       ea		      nop
     19  6122					      REPEND
    175  6122		       85 51		      sta	RESP1
    176  6124
    177  6124		       85 42		      sta	WSYNC
    178  6126		       85 6a		      sta	HMOVE
    179  6128
    180  6128
    181  6128							;===================================================================================================
    182  6128
    183  6128							; now a top for the 'box'
    184  6128
    185  6128		       a9 00		      lda	#0
    186  612a		       85 4d		      sta	PF0
    187  612c		       85 4e		      sta	PF1
    188  612e		       85 4f		      sta	PF2
    189  6130
    190  6130		       a0 11		      ldy	#TOPHAT-1
    191  6132		       85 42	   boxtop     sta	WSYNC	;@0
    192  6134
    193  6134		       98		      tya
    194  6135		       0a		      asl
    195  6136		       29 06		      and	#%110
    196  6138		       05 ee		      ora	wallColour
    197  613a		       85 48		      sta	COLUPF
    198  613c		       b9 02 f4 	      lda	lid0,y	;#%11100000
    199  613f		       85 4d		      sta	PF0
    200  6141		       b9 14 f4 	      lda	lid1,y	;#255
    201  6144							;nop
    202  6144		       85 4e		      sta	PF1
    203  6146		       b9 14 f4 	      lda	lid2,y	;#255
    204  6149							;nop
    205  6149		       85 4f		      sta	PF2	; 3 = 8 @ 19
    206  614b
    207  614b							; RHS
    208  614b		       b9 26 f4 	      lda	lid3,y	;#255
    209  614e							;nop
    210  614e		       85 4d		      sta	PF0	; 3 = 8 @ 27 OK	D7D6D5D4 <--- mirrored
    211  6150
      0  6150					      SLEEP	8
      1  6150				   .CYCLES    SET	8
      2  6150
      3  6150				  -	      IF	.CYCLES < 2
      4  6150				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  6150				  -	      ERR
      6  6150					      ENDIF
      7  6150
      8  6150				  -	      IF	.CYCLES & 1
      9  6150				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  6150				  -	      nop	0
     11  6150				  -	      ELSE
     12  6150				  -	      bit	VSYNC
     13  6150				  -	      ENDIF
     14  6150				  -.CYCLES    SET	.CYCLES - 3
     15  6150					      ENDIF
     16  6150
     17  6150					      REPEAT	.CYCLES / 2
     18  6150		       ea		      nop
     17  6150					      REPEND
     18  6151		       ea		      nop
     17  6151					      REPEND
     18  6152		       ea		      nop
     17  6152					      REPEND
     18  6153		       ea		      nop
     19  6154					      REPEND
    213  6154		       b9 26 f4 	      lda	lid4,y	;#255
    214  6157		       85 4e		      sta	PF1	; 3 @40		 NOT MIRRORED, D7D6D5D4 -->
    215  6159
    216  6159		       a9 00		      lda	#%00000000
    217  615b							;		  nop
    218  615b		       85 4f		      sta	PF2	; 3 = 8 @48
    219  615d
    220  615d		       a9 00		      lda	#0
    221  615f		       85 49		      sta	COLUBK
    222  6161
    223  6161
    224  6161		       88		      dey		; 2
    225  6162		       10 ce		      bpl	boxtop
    226  6164
    227  6164
    228  6164		       a9 00		      lda	#0
    229  6166		       85 4d		      sta	PF0
    230  6168		       85 4e		      sta	PF1
    231  616a		       85 4f		      sta	PF2
    232  616c							;		  sta GRP0
    233  616c							;		  sta GRP1
    234  616c
    235  616c		       a9 fc		      lda	#%11111100
    236  616e		       85 5b		      sta	GRP0
    237  6170		       a9 3f		      lda	#%00111111
    238  6172		       85 5c		      sta	GRP1
    239  6174
    240  6174
    241  6174		       85 42		      sta	WSYNC
    242  6176							;		  sta WSYNC
    243  6176							;		  sta WSYNC
    244  6176							;		  sta WSYNC
    245  6176							;		  sta WSYNC
    246  6176
    247  6176							;===================================================================================================
    248  6176
    249  6176		       a6 80		      ldx	Platform
    250  6178		       bd c2 f3 	      lda	colvecX,x
    251  617b		       aa		      tax
    252  617c
    253  617c							;------------------------------------------------------------------
    254  617c
    255  617c							; Do X scanlines of color-changing (our picture)
    256  617c
    257  617c
    258  617c		       a9 2a		      lda	#$2A	; 2
    259  617e		       85 48		      sta	COLUPF	; 3 = 5 @8
    260  6180
    261  6180		       a0 1f		      ldy	#BIGDIG_SIZE-1	; #lines in characters-1
    262  6182
    263  6182		       a2 00		      ldx	#0	; used as a generic "0" during the kernel
    264  6184		       85 42		      sta	WSYNC
    265  6186
    266  6186
    267  6186		       00 04	   DUPES      =	4
    268  6186				   LevelNumberDigits
    269  6186
    270  6186				   .LOOP      SET	0
    271  6186					      REPEAT	DUPES
    272  6186
    273  6186		       86 4d		      stx	PF0	; 3
    274  6188
    275  6188					      IF	.LOOP < DUPES-1
    276  6188		       b9 47 f3 	      lda	colbk,y	; 4
    277  618b		       65 ef		      adc	adjustColour	; 3
    278  618d		       85 48		      sta	COLUPF	; 3 = 10 @13
    279  618f				  -	      ELSE
    280  618f				  -	      lda	#0	;wallColour	      ; 3
    281  618f				  -	      sta	COLUPF	; 3 = 7
    282  618f				  -	      SLEEP	5	; 4 = 10 @13
    283  618f				  -
    284  618f					      ENDIF
    285  618f		       b1 e8		      lda	(digitHundreds),y	; 5
    286  6191		       85 4e		      sta	PF1	; 3 = 8 @21
    287  6193
    288  6193		       b1 d9		      lda	(digit1),y	; 5
    289  6195		       85 4f		      sta	PF2	; 3 = 8 @29
    290  6197
    291  6197							; RHS
    292  6197
    293  6197		       b1 db		      lda	(digit2),y	; 5
    294  6199		       85 4d		      sta	PF0	; 3 = 8 @ 37	     D7D6D5D4 <--- mirrored
    295  619b
    296  619b		       0a		      asl		; 2
    297  619c		       0a		      asl		; 2
    298  619d		       0a		      asl		; 2
    299  619e		       0a		      asl		; 2
    300  619f		       85 4e		      sta	PF1	; 3 = 11 @48	     NOT MIRRORED, D7D6D5D4 -->
    301  61a1
    302  61a1		       b1 dd		      lda	(digitstar),y	; 5
    303  61a3		       85 4f		      sta	PF2	; 3 = 8 @56
    304  61a5
    305  61a5		       b1 ec		      lda	(manc),y	; 5
    306  61a7		       85 48		      sta	COLUPF	; 3 = 8 @64
    307  61a9
    308  61a9		       00 0c	   SPARE      =	12
    309  61a9
    310  61a9					      IF	.LOOP < DUPES-1
      0  61a9					      SLEEP	SPARE
      1  61a9				   .CYCLES    SET	SPARE
      2  61a9
      3  61a9				  -	      IF	.CYCLES < 2
      4  61a9				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  61a9				  -	      ERR
      6  61a9					      ENDIF
      7  61a9
      8  61a9				  -	      IF	.CYCLES & 1
      9  61a9				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  61a9				  -	      nop	0
     11  61a9				  -	      ELSE
     12  61a9				  -	      bit	VSYNC
     13  61a9				  -	      ENDIF
     14  61a9				  -.CYCLES    SET	.CYCLES - 3
     15  61a9					      ENDIF
     16  61a9
     17  61a9					      REPEAT	.CYCLES / 2
     18  61a9		       ea		      nop
     17  61a9					      REPEND
     18  61aa		       ea		      nop
     17  61aa					      REPEND
     18  61ab		       ea		      nop
     17  61ab					      REPEND
     18  61ac		       ea		      nop
     17  61ac					      REPEND
     18  61ad		       ea		      nop
     17  61ad					      REPEND
     18  61ae		       ea		      nop
     19  61af					      REPEND
    312  61af					      ENDIF
    313  61af
    314  61af				  -	      IF	.LOOP = DUPES-1
    315  61af				  -	      SLEEP	SPARE-7
    316  61af					      ENDIF
    317  61af
    318  61af
    319  61af				   .LOOP      SET	.LOOP + 1
    271  61af					      REPEND
    272  61af
    273  61af		       86 4d		      stx	PF0	; 3
    274  61b1
    275  61b1					      IF	.LOOP < DUPES-1
    276  61b1		       b9 47 f3 	      lda	colbk,y	; 4
    277  61b4		       65 ef		      adc	adjustColour	; 3
    278  61b6		       85 48		      sta	COLUPF	; 3 = 10 @13
    279  61b8				  -	      ELSE
    280  61b8				  -	      lda	#0	;wallColour	      ; 3
    281  61b8				  -	      sta	COLUPF	; 3 = 7
    282  61b8				  -	      SLEEP	5	; 4 = 10 @13
    283  61b8				  -
    284  61b8					      ENDIF
    285  61b8		       b1 e8		      lda	(digitHundreds),y	; 5
    286  61ba		       85 4e		      sta	PF1	; 3 = 8 @21
    287  61bc
    288  61bc		       b1 d9		      lda	(digit1),y	; 5
    289  61be		       85 4f		      sta	PF2	; 3 = 8 @29
    290  61c0
    291  61c0							; RHS
    292  61c0
    293  61c0		       b1 db		      lda	(digit2),y	; 5
    294  61c2		       85 4d		      sta	PF0	; 3 = 8 @ 37	     D7D6D5D4 <--- mirrored
    295  61c4
    296  61c4		       0a		      asl		; 2
    297  61c5		       0a		      asl		; 2
    298  61c6		       0a		      asl		; 2
    299  61c7		       0a		      asl		; 2
    300  61c8		       85 4e		      sta	PF1	; 3 = 11 @48	     NOT MIRRORED, D7D6D5D4 -->
    301  61ca
    302  61ca		       b1 dd		      lda	(digitstar),y	; 5
    303  61cc		       85 4f		      sta	PF2	; 3 = 8 @56
    304  61ce
    305  61ce		       b1 ec		      lda	(manc),y	; 5
    306  61d0		       85 48		      sta	COLUPF	; 3 = 8 @64
    307  61d2
    308  61d2		       00 0c	   SPARE      =	12
    309  61d2
    310  61d2					      IF	.LOOP < DUPES-1
      0  61d2					      SLEEP	SPARE
      1  61d2				   .CYCLES    SET	SPARE
      2  61d2
      3  61d2				  -	      IF	.CYCLES < 2
      4  61d2				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  61d2				  -	      ERR
      6  61d2					      ENDIF
      7  61d2
      8  61d2				  -	      IF	.CYCLES & 1
      9  61d2				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  61d2				  -	      nop	0
     11  61d2				  -	      ELSE
     12  61d2				  -	      bit	VSYNC
     13  61d2				  -	      ENDIF
     14  61d2				  -.CYCLES    SET	.CYCLES - 3
     15  61d2					      ENDIF
     16  61d2
     17  61d2					      REPEAT	.CYCLES / 2
     18  61d2		       ea		      nop
     17  61d2					      REPEND
     18  61d3		       ea		      nop
     17  61d3					      REPEND
     18  61d4		       ea		      nop
     17  61d4					      REPEND
     18  61d5		       ea		      nop
     17  61d5					      REPEND
     18  61d6		       ea		      nop
     17  61d6					      REPEND
     18  61d7		       ea		      nop
     19  61d8					      REPEND
    312  61d8					      ENDIF
    313  61d8
    314  61d8				  -	      IF	.LOOP = DUPES-1
    315  61d8				  -	      SLEEP	SPARE-7
    316  61d8					      ENDIF
    317  61d8
    318  61d8
    319  61d8				   .LOOP      SET	.LOOP + 1
    271  61d8					      REPEND
    272  61d8
    273  61d8		       86 4d		      stx	PF0	; 3
    274  61da
    275  61da					      IF	.LOOP < DUPES-1
    276  61da		       b9 47 f3 	      lda	colbk,y	; 4
    277  61dd		       65 ef		      adc	adjustColour	; 3
    278  61df		       85 48		      sta	COLUPF	; 3 = 10 @13
    279  61e1				  -	      ELSE
    280  61e1				  -	      lda	#0	;wallColour	      ; 3
    281  61e1				  -	      sta	COLUPF	; 3 = 7
    282  61e1				  -	      SLEEP	5	; 4 = 10 @13
    283  61e1				  -
    284  61e1					      ENDIF
    285  61e1		       b1 e8		      lda	(digitHundreds),y	; 5
    286  61e3		       85 4e		      sta	PF1	; 3 = 8 @21
    287  61e5
    288  61e5		       b1 d9		      lda	(digit1),y	; 5
    289  61e7		       85 4f		      sta	PF2	; 3 = 8 @29
    290  61e9
    291  61e9							; RHS
    292  61e9
    293  61e9		       b1 db		      lda	(digit2),y	; 5
    294  61eb		       85 4d		      sta	PF0	; 3 = 8 @ 37	     D7D6D5D4 <--- mirrored
    295  61ed
    296  61ed		       0a		      asl		; 2
    297  61ee		       0a		      asl		; 2
    298  61ef		       0a		      asl		; 2
    299  61f0		       0a		      asl		; 2
    300  61f1		       85 4e		      sta	PF1	; 3 = 11 @48	     NOT MIRRORED, D7D6D5D4 -->
    301  61f3
    302  61f3		       b1 dd		      lda	(digitstar),y	; 5
    303  61f5		       85 4f		      sta	PF2	; 3 = 8 @56
    304  61f7
    305  61f7		       b1 ec		      lda	(manc),y	; 5
    306  61f9		       85 48		      sta	COLUPF	; 3 = 8 @64
    307  61fb
    308  61fb		       00 0c	   SPARE      =	12
    309  61fb
    310  61fb					      IF	.LOOP < DUPES-1
      0  61fb					      SLEEP	SPARE
      1  61fb				   .CYCLES    SET	SPARE
      2  61fb
      3  61fb				  -	      IF	.CYCLES < 2
      4  61fb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  61fb				  -	      ERR
      6  61fb					      ENDIF
      7  61fb
      8  61fb				  -	      IF	.CYCLES & 1
      9  61fb				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  61fb				  -	      nop	0
     11  61fb				  -	      ELSE
     12  61fb				  -	      bit	VSYNC
     13  61fb				  -	      ENDIF
     14  61fb				  -.CYCLES    SET	.CYCLES - 3
     15  61fb					      ENDIF
     16  61fb
     17  61fb					      REPEAT	.CYCLES / 2
     18  61fb		       ea		      nop
     17  61fb					      REPEND
     18  61fc		       ea		      nop
     17  61fc					      REPEND
     18  61fd		       ea		      nop
     17  61fd					      REPEND
     18  61fe		       ea		      nop
     17  61fe					      REPEND
     18  61ff		       ea		      nop
     17  61ff					      REPEND
     18  6200		       ea		      nop
     19  6201					      REPEND
    312  6201					      ENDIF
    313  6201
    314  6201				  -	      IF	.LOOP = DUPES-1
    315  6201				  -	      SLEEP	SPARE-7
    316  6201					      ENDIF
    317  6201
    318  6201
    319  6201				   .LOOP      SET	.LOOP + 1
    271  6201					      REPEND
    272  6201
    273  6201		       86 4d		      stx	PF0	; 3
    274  6203
    275  6203				  -	      IF	.LOOP < DUPES-1
    276  6203				  -	      lda	colbk,y	; 4
    277  6203				  -	      adc	adjustColour	; 3
    278  6203				  -	      sta	COLUPF	; 3 = 10 @13
    279  6203					      ELSE
    280  6203		       a9 00		      lda	#0	;wallColour	      ; 3
    281  6205		       85 48		      sta	COLUPF	; 3 = 7
      0  6207					      SLEEP	5	; 4 = 10 @13
      1  6207				   .CYCLES    SET	5
      2  6207
      3  6207				  -	      IF	.CYCLES < 2
      4  6207				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  6207				  -	      ERR
      6  6207					      ENDIF
      7  6207
      8  6207					      IF	.CYCLES & 1
      9  6207					      IFNCONST	NO_ILLEGAL_OPCODES
     10  6207		       04 00		      nop	0
     11  6209				  -	      ELSE
     12  6209				  -	      bit	VSYNC
     13  6209					      ENDIF
     14  6209				   .CYCLES    SET	.CYCLES - 3
     15  6209					      ENDIF
     16  6209
     17  6209					      REPEAT	.CYCLES / 2
     18  6209		       ea		      nop
     19  620a					      REPEND
    283  620a
    284  620a					      ENDIF
    285  620a		       b1 e8		      lda	(digitHundreds),y	; 5
    286  620c		       85 4e		      sta	PF1	; 3 = 8 @21
    287  620e
    288  620e		       b1 d9		      lda	(digit1),y	; 5
    289  6210		       85 4f		      sta	PF2	; 3 = 8 @29
    290  6212
    291  6212							; RHS
    292  6212
    293  6212		       b1 db		      lda	(digit2),y	; 5
    294  6214		       85 4d		      sta	PF0	; 3 = 8 @ 37	     D7D6D5D4 <--- mirrored
    295  6216
    296  6216		       0a		      asl		; 2
    297  6217		       0a		      asl		; 2
    298  6218		       0a		      asl		; 2
    299  6219		       0a		      asl		; 2
    300  621a		       85 4e		      sta	PF1	; 3 = 11 @48	     NOT MIRRORED, D7D6D5D4 -->
    301  621c
    302  621c		       b1 dd		      lda	(digitstar),y	; 5
    303  621e		       85 4f		      sta	PF2	; 3 = 8 @56
    304  6220
    305  6220		       b1 ec		      lda	(manc),y	; 5
    306  6222		       85 48		      sta	COLUPF	; 3 = 8 @64
    307  6224
    308  6224		       00 0c	   SPARE      =	12
    309  6224
    310  6224				  -	      IF	.LOOP < DUPES-1
    311  6224				  -	      SLEEP	SPARE
    312  6224					      ENDIF
    313  6224
    314  6224					      IF	.LOOP = DUPES-1
      0  6224					      SLEEP	SPARE-7
      1  6224				   .CYCLES    SET	SPARE-7
      2  6224
      3  6224				  -	      IF	.CYCLES < 2
      4  6224				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  6224				  -	      ERR
      6  6224					      ENDIF
      7  6224
      8  6224					      IF	.CYCLES & 1
      9  6224					      IFNCONST	NO_ILLEGAL_OPCODES
     10  6224		       04 00		      nop	0
     11  6226				  -	      ELSE
     12  6226				  -	      bit	VSYNC
     13  6226					      ENDIF
     14  6226				   .CYCLES    SET	.CYCLES - 3
     15  6226					      ENDIF
     16  6226
     17  6226					      REPEAT	.CYCLES / 2
     18  6226		       ea		      nop
     19  6227					      REPEND
    316  6227					      ENDIF
    317  6227
    318  6227
    319  6227				   .LOOP      SET	.LOOP + 1
    320  6227					      REPEND
    321  6227		       88		      dey		; 2
    322  6228		       30 03		      bmi	ess	; 2/3
    323  622a		       4c 86 f1 	      jmp	LevelNumberDigits	; 3 = 7 mostly @ 71
    324  622d
    325  622d
    326  622d				   ess
    327  622d
    328  622d							;		  sta WSYNC
    329  622d
    330  622d
    331  622d							; now a bottom for the 'box'
    332  622d
    333  622d		       a9 00		      lda	#0
    334  622f		       85 4d		      sta	PF0
    335  6231		       85 4e		      sta	PF1
    336  6233		       85 4f		      sta	PF2
    337  6235
    338  6235		       a5 ee		      lda	wallColour
    339  6237		       85 48		      sta	COLUPF
    340  6239
    341  6239		       a0 08		      ldy	#8
    342  623b		       85 42	   boxbottom  sta	WSYNC	;@0
    343  623d		       b9 38 f4 	      lda	lidb0,y	;#%11100000
    344  6240		       29 c0		      and	#%11000000
    345  6242		       85 4d		      sta	PF0
    346  6244		       b9 38 f4 	      lda	lidb1,y	;#255
    347  6247		       85 4e		      sta	PF1
    348  6249		       b9 38 f4 	      lda	lidb2,y	;#255
    349  624c		       85 4f		      sta	PF2	; 3 = 8 @ 19
    350  624e
    351  624e							; RHS
    352  624e		       b9 38 f4 	      lda	lidb3,y
    353  6251		       85 4d		      sta	PF0	; 3 = 8 @ 27 OK	D7D6D5D4 <--- mirrored
    354  6253
      0  6253					      SLEEP	8
      1  6253				   .CYCLES    SET	8
      2  6253
      3  6253				  -	      IF	.CYCLES < 2
      4  6253				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  6253				  -	      ERR
      6  6253					      ENDIF
      7  6253
      8  6253				  -	      IF	.CYCLES & 1
      9  6253				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  6253				  -	      nop	0
     11  6253				  -	      ELSE
     12  6253				  -	      bit	VSYNC
     13  6253				  -	      ENDIF
     14  6253				  -.CYCLES    SET	.CYCLES - 3
     15  6253					      ENDIF
     16  6253
     17  6253					      REPEAT	.CYCLES / 2
     18  6253		       ea		      nop
     17  6253					      REPEND
     18  6254		       ea		      nop
     17  6254					      REPEND
     18  6255		       ea		      nop
     17  6255					      REPEND
     18  6256		       ea		      nop
     19  6257					      REPEND
    356  6257		       b9 38 f4 	      lda	lidb4,y
    357  625a		       85 4e		      sta	PF1	; 3 @40		 NOT MIRRORED, D7D6D5D4 -->
    358  625c
    359  625c		       a9 00		      lda	#%00000000
    360  625e							;		  nop
    361  625e		       85 4f		      sta	PF2	; 3 = 8 @48
    362  6260
    363  6260		       a9 06		      lda	#6
    364  6262		       85 49		      sta	COLUBK
    365  6264
    366  6264
    367  6264		       88		      dey		; 2
    368  6265		       10 d4		      bpl	boxbottom
    369  6267
    370  6267
    371  6267		       a9 00		      lda	#0
    372  6269		       85 4d		      sta	PF0
    373  626b		       85 4e		      sta	PF1
    374  626d		       85 4f		      sta	PF2
    375  626f		       85 5b		      sta	GRP0
    376  6271		       85 5c		      sta	GRP1
    377  6273
    378  6273		       a4 80		      ldy	Platform
    379  6275		       b9 be f3 	      lda	OverscanTime2X,y
    380  6278		       8d 96 02 	      sta	TIM64T
    381  627b
    382  627b		       85 42		      sta	WSYNC
    383  627d
    384  627d							;--------------------------------------------------------------------------
    385  627d
    386  627d		       c6 e2		      dec	digitick
    387  627f		       10 59		      bpl	donedig
    388  6281		       a9 07		      lda	#7
    389  6283		       85 e2		      sta	digitick
    390  6285
    391  6285		       a2 02		      ldx	#2
    392  6287		       b5 df	   scanner    lda	digit,x
    393  6289		       d5 e3		      cmp	targetDigit,x
    394  628b		       f0 0e		      beq	scanOK
    395  628d
    396  628d		       f8		      sed
    397  628e		       69 01		      adc	#1
    398  6290		       29 0f		      and	#$F
    399  6292		       95 df		      sta	digit,x
    400  6294		       d8		      cld
    401  6295
    402  6295		       a9 64		      lda	#100
    403  6297		       85 e6		      sta	endwait
    404  6299		       d0 3f		      bne	donedig
    405  629b
    406  629b		       ca	   scanOK     dex
    407  629c		       10 e9		      bpl	scanner
    408  629e
    409  629e		       a5 ea		      lda	selector
    410  62a0		       f0 38		      beq	donedig	; don't allow joystick selection
    411  62a2
    412  62a2		       a9 ff		      lda	#-1
    413  62a4		       85 e3		      sta	targetDigit
    414  62a6		       85 e4		      sta	targetDigit+1
    415  62a8		       85 e5		      sta	targetDigit+2
    416  62aa
    417  62aa		       ad 80 02 	      lda	SWCHA
    418  62ad		       4a		      lsr
    419  62ae		       4a		      lsr
    420  62af		       4a		      lsr
    421  62b0		       4a		      lsr
    422  62b1		       aa		      tax
    423  62b2
    424  62b2		       bd aa f3 	      lda	xJoyMoveX,x
    425  62b5		       f0 03		      beq	adjustLevelNum
    426  62b7
    427  62b7							; level is changing, so animate the man too
    428  62b7
    429  62b7		       20 1d f3 	      jsr	fixWalkFrame
    430  62ba
    431  62ba
    432  62ba		       18	   adjustLevelNum clc
    433  62bb		       a5 b2		      lda	levelX
    434  62bd		       7d aa f3 	      adc	xJoyMoveX,x
    435  62c0		       c9 ff		      cmp	#255
    436  62c2		       d0 02		      bne	nml1
    437  62c4		       a9 98		      lda	#MAX_LEVEL-1
    438  62c6		       c9 99	   nml1       cmp	#MAX_LEVEL
    439  62c8		       d0 02		      bne	nml2
    440  62ca		       a9 00		      lda	#0
    441  62cc		       85 b2	   nml2       sta	levelX
    442  62ce
    443  62ce		       20 04 f3 	      jsr	dd3
    444  62d1
    445  62d1		       a2 02		      ldx	#2
    446  62d3		       b5 e3	   zapper     lda	targetDigit,x
    447  62d5		       95 df		      sta	digit,x
    448  62d7		       ca		      dex
    449  62d8		       10 f9		      bpl	zapper
    450  62da
    451  62da				   donedig
    452  62da
      0  62da					      NEXT_RANDOM
      1  62da
      2  62da		       a5 c8		      lda	rnd
      3  62dc		       4a		      lsr
      4  62dd					      IFCONST	rndHi
      5  62dd		       66 c7		      ror	rndHi
      6  62df					      ENDIF
      7  62df		       90 02		      bcc	.skipEOR
      8  62e1		       49 b4		      eor	#RND_EOR_VAL
      9  62e3				   .skipEOR
     10  62e3		       85 c8		      sta	rnd
    454  62e5
    455  62e5		       ad 84 02    oscanX     lda	INTIM
    456  62e8		       d0 fb		      bne	oscanX
    457  62ea
    458  62ea		       85 49		      sta	COLUBK
    459  62ec		       a9 42		      lda	#%01000010	; bit6 is not required
    460  62ee		       85 41		      sta	VBLANK	; end of screen - enter blanking
    461  62f0
    462  62f0		       a9 00		      lda	#0
    463  62f2		       85 40		      sta	VSYNC
    464  62f4
    465  62f4
    466  62f4		       a5 ea		      lda	selector
    467  62f6		       d0 04		      bne	waitbutton
    468  62f8		       c6 e6		      dec	endwait
    469  62fa		       f0 07		      beq	retX
    470  62fc
    471  62fc		       a5 4c	   waitbutton lda	INPT4
    472  62fe		       10 03		      bpl	retX
    473  6300
    474  6300		       4c a7 f0 	      jmp	RestartFrameX
    475  6303
    476  6303		       60	   retX       rts
    477  6304
    478  6304
    479  6304
    480  6304				   dd3
    481  6304		       18		      clc
    482  6305		       a5 b2		      lda	levelX
    483  6307		       69 01		      adc	#1
    484  6309		       38		      sec
    485  630a		       e9 64	   m100       sbc	#100
    486  630c		       e6 e5		      inc	targetDigit+2
    487  630e		       b0 fa		      bcs	m100
    488  6310		       69 64		      adc	#100
    489  6312		       e9 0a	   m10	      sbc	#10
    490  6314		       e6 e4		      inc	targetDigit+1
    491  6316		       b0 fa		      bcs	m10
    492  6318		       69 0a		      adc	#10
    493  631a		       85 e3		      sta	targetDigit
    494  631c
    495  631c
    496  631c							; leading zero removal
    497  631c							;lda targetDigit+2
    498  631c							;bne hunds
    499  631c							;lda #10
    500  631c							;sta targetDigit+2
    501  631c							;sta digit+2		  ; hide hundreds if 0
    502  631c				   hunds
    503  631c
    504  631c		       60		      rts
    505  631d
    506  631d
      0  631d					      DEFINE_SUBROUTINE	fixWalkFrame
      1  631d		       00 0c	   BANK_fixWalkFrame =	_CURRENT_BANK
      2  631d					      SUBROUTINE
      3  631d				   fixWalkFrame
    508  631d
    509  631d
    510  631d		       a5 ea		      lda	selector
    511  631f		       f0 10		      beq	walk0
    512  6321
    513  6321		       18		      clc
    514  6322		       a5 eb		      lda	walkSpeed
    515  6324		       69 04		      adc	#4
    516  6326		       85 eb		      sta	walkSpeed
    517  6328
    518  6328		       4a		      lsr
    519  6329		       4a		      lsr
    520  632a		       29 03		      and	#%11
    521  632c		       a8		      tay
    522  632d		       b9 67 f3 	      lda	walkOrder,y
    523  6330		       0a		      asl
    524  6331		       a8	   walk0      tay
    525  6332		       b9 6b f3 	      lda	walkFrame,y
    526  6335		       85 dd		      sta	digitstar
    527  6337		       b9 6c f3 	      lda	walkFrame+1,y
    528  633a		       85 de		      sta	digitstar+1
    529  633c
    530  633c
    531  633c		       b9 73 f3 	      lda	walkColour,y
    532  633f		       85 ec		      sta	manc
    533  6341		       b9 74 f3 	      lda	walkColour+1,y
    534  6344		       85 ed		      sta	manc+1
    535  6346		       60		      rts
    536  6347
    537  6347
    538  6347
      0  6347					      OPTIONAL_PAGEBREAK	"colbk @levelScreen.asm", BIGDIG_SIZE
     10  6347					      LIST	ON
    540  6347
    541  6347				   colbk		; hardwired for 32 - will need manual changing
    542  6347
    543  6347				   .CRK       SET	256*$B2
    544  6347				   .CGK       SET	256*$B2
    545  6347				   .CBK       SET	256*$B2
    546  6347
    547  6347					      REPEAT	10
    548  6347		       b2		      .byte.b	.CRK/256
    549  6348		       b2		      .byte.b	.CBK/256
    550  6349		       b2		      .byte.b	.CGK/256
    551  634a
    552  634a				   .CRK       SET	.CRK + 280	;135
    553  634a				   .CGK       SET	.CGK + 280	;135
    554  634a				   .CBK       SET	.CBK + 280	;135
    547  634a					      REPEND
    548  634a		       b3		      .byte.b	.CRK/256
    549  634b		       b3		      .byte.b	.CBK/256
    550  634c		       b3		      .byte.b	.CGK/256
    551  634d
    552  634d				   .CRK       SET	.CRK + 280	;135
    553  634d				   .CGK       SET	.CGK + 280	;135
    554  634d				   .CBK       SET	.CBK + 280	;135
    547  634d					      REPEND
    548  634d		       b4		      .byte.b	.CRK/256
    549  634e		       b4		      .byte.b	.CBK/256
    550  634f		       b4		      .byte.b	.CGK/256
    551  6350
    552  6350				   .CRK       SET	.CRK + 280	;135
    553  6350				   .CGK       SET	.CGK + 280	;135
    554  6350				   .CBK       SET	.CBK + 280	;135
    547  6350					      REPEND
    548  6350		       b5		      .byte.b	.CRK/256
    549  6351		       b5		      .byte.b	.CBK/256
    550  6352		       b5		      .byte.b	.CGK/256
    551  6353
    552  6353				   .CRK       SET	.CRK + 280	;135
    553  6353				   .CGK       SET	.CGK + 280	;135
    554  6353				   .CBK       SET	.CBK + 280	;135
    547  6353					      REPEND
    548  6353		       b6		      .byte.b	.CRK/256
    549  6354		       b6		      .byte.b	.CBK/256
    550  6355		       b6		      .byte.b	.CGK/256
    551  6356
    552  6356				   .CRK       SET	.CRK + 280	;135
    553  6356				   .CGK       SET	.CGK + 280	;135
    554  6356				   .CBK       SET	.CBK + 280	;135
    547  6356					      REPEND
    548  6356		       b7		      .byte.b	.CRK/256
    549  6357		       b7		      .byte.b	.CBK/256
    550  6358		       b7		      .byte.b	.CGK/256
    551  6359
    552  6359				   .CRK       SET	.CRK + 280	;135
    553  6359				   .CGK       SET	.CGK + 280	;135
    554  6359				   .CBK       SET	.CBK + 280	;135
    547  6359					      REPEND
    548  6359		       b8		      .byte.b	.CRK/256
    549  635a		       b8		      .byte.b	.CBK/256
    550  635b		       b8		      .byte.b	.CGK/256
    551  635c
    552  635c				   .CRK       SET	.CRK + 280	;135
    553  635c				   .CGK       SET	.CGK + 280	;135
    554  635c				   .CBK       SET	.CBK + 280	;135
    547  635c					      REPEND
    548  635c		       b9		      .byte.b	.CRK/256
    549  635d		       b9		      .byte.b	.CBK/256
    550  635e		       b9		      .byte.b	.CGK/256
    551  635f
    552  635f				   .CRK       SET	.CRK + 280	;135
    553  635f				   .CGK       SET	.CGK + 280	;135
    554  635f				   .CBK       SET	.CBK + 280	;135
    547  635f					      REPEND
    548  635f		       ba		      .byte.b	.CRK/256
    549  6360		       ba		      .byte.b	.CBK/256
    550  6361		       ba		      .byte.b	.CGK/256
    551  6362
    552  6362				   .CRK       SET	.CRK + 280	;135
    553  6362				   .CGK       SET	.CGK + 280	;135
    554  6362				   .CBK       SET	.CBK + 280	;135
    547  6362					      REPEND
    548  6362		       bb		      .byte.b	.CRK/256
    549  6363		       bb		      .byte.b	.CBK/256
    550  6364		       bb		      .byte.b	.CGK/256
    551  6365
    552  6365				   .CRK       SET	.CRK + 280	;135
    553  6365				   .CGK       SET	.CGK + 280	;135
    554  6365				   .CBK       SET	.CBK + 280	;135
    555  6365					      REPEND
    556  6365		       bc		      .byte.b	.CRK/256
    557  6366		       bc		      .byte.b	.CBK/256
    558  6367
      0  6367					      CHECKPAGEX	colbk, "WARNING: colbk crosses page @levelScreen.asm"
      9  6367					      LIST	ON
    560  6367
    561  6367
    562  6367
    563  6367		       01 02 03 02 walkOrder  .byte.b	1,2,3,2
    564  636b				   walkFrame
    565  636b		       20 f7		      .word.w	LEFT_star0
    566  636d		       40 f7		      .word.w	LEFT_star1
    567  636f		       60 f7		      .word.w	LEFT_star2
    568  6371		       80 f7		      .word.w	LEFT_star3
    569  6373
    570  6373				   walkColour
    571  6373		       92 f3		      .word.w	mancolourPAL2
    572  6375		       7b f3		      .word.w	mancolourPAL
    573  6377		       92 f3		      .word.w	mancolourPAL2
    574  6379		       7b f3		      .word.w	mancolourPAL
    575  637b
    576  637b
    577  637b				   mancolourPAL
    578  637b							; NTSC_TO_PAL $10, 4
      0  637b					      NTSC_TO_PAL	$10, 4
      1  637b				  -	      IF	$10 = 0
      2  637b				  -	      .byte	$10+4
      3  637b					      ENDIF
      4  637b					      IF	$10 = $10
      5  637b		       24		      .byte.b	$20+4
      6  637c					      ENDIF
      7  637c				  -	      IF	$10 = $20
      8  637c				  -	      .byte	$40+4
      9  637c					      ENDIF
     10  637c				  -	      IF	$10 = $30
     11  637c				  -	      .byte	$40+4
     12  637c					      ENDIF
     13  637c				  -	      IF	$10 = $40
     14  637c				  -	      .byte	$60+4
     15  637c					      ENDIF
     16  637c				  -	      IF	$10 = $50
     17  637c				  -	      .byte	$80+4
     18  637c					      ENDIF
     19  637c				  -	      IF	$10 = $60
     20  637c				  -	      .byte	$C0+4
     21  637c					      ENDIF
     22  637c				  -	      IF	$10 = $70
     23  637c				  -	      .byte	$D0+4
     24  637c					      ENDIF
     25  637c				  -	      IF	$10 = $80
     26  637c				  -	      .byte	$B0+4
     27  637c					      ENDIF
     28  637c				  -	      IF	$10 = $90
     29  637c				  -	      .byte	$90+4
     30  637c					      ENDIF
     31  637c				  -	      IF	$10 = $A0
     32  637c				  -	      .byte	$70+4
     33  637c					      ENDIF
     34  637c				  -	      IF	$10 = $B0
     35  637c				  -	      .byte	$50+4
     36  637c					      ENDIF
     37  637c				  -	      IF	$10 = $C0
     38  637c				  -	      .byte	$30+4
     39  637c					      ENDIF
     40  637c				  -	      IF	$10 = $D0
     41  637c				  -	      .byte	$30+4
     42  637c					      ENDIF
     43  637c				  -	      IF	$10 = $E0
     44  637c				  -	      .byte	$20+4
     45  637c					      ENDIF
     46  637c				  -	      IF	$10 = $F0
     47  637c				  -	      .byte	$40+4
     48  637c					      ENDIF
      0  637c					      NTSC_TO_PAL	$10, 4
      1  637c				  -	      IF	$10 = 0
      2  637c				  -	      .byte	$10+4
      3  637c					      ENDIF
      4  637c					      IF	$10 = $10
      5  637c		       24		      .byte.b	$20+4
      6  637d					      ENDIF
      7  637d				  -	      IF	$10 = $20
      8  637d				  -	      .byte	$40+4
      9  637d					      ENDIF
     10  637d				  -	      IF	$10 = $30
     11  637d				  -	      .byte	$40+4
     12  637d					      ENDIF
     13  637d				  -	      IF	$10 = $40
     14  637d				  -	      .byte	$60+4
     15  637d					      ENDIF
     16  637d				  -	      IF	$10 = $50
     17  637d				  -	      .byte	$80+4
     18  637d					      ENDIF
     19  637d				  -	      IF	$10 = $60
     20  637d				  -	      .byte	$C0+4
     21  637d					      ENDIF
     22  637d				  -	      IF	$10 = $70
     23  637d				  -	      .byte	$D0+4
     24  637d					      ENDIF
     25  637d				  -	      IF	$10 = $80
     26  637d				  -	      .byte	$B0+4
     27  637d					      ENDIF
     28  637d				  -	      IF	$10 = $90
     29  637d				  -	      .byte	$90+4
     30  637d					      ENDIF
     31  637d				  -	      IF	$10 = $A0
     32  637d				  -	      .byte	$70+4
     33  637d					      ENDIF
     34  637d				  -	      IF	$10 = $B0
     35  637d				  -	      .byte	$50+4
     36  637d					      ENDIF
     37  637d				  -	      IF	$10 = $C0
     38  637d				  -	      .byte	$30+4
     39  637d					      ENDIF
     40  637d				  -	      IF	$10 = $D0
     41  637d				  -	      .byte	$30+4
     42  637d					      ENDIF
     43  637d				  -	      IF	$10 = $E0
     44  637d				  -	      .byte	$20+4
     45  637d					      ENDIF
     46  637d				  -	      IF	$10 = $F0
     47  637d				  -	      .byte	$40+4
     48  637d					      ENDIF
      0  637d					      NTSC_TO_PAL	$90, 4
      1  637d				  -	      IF	$90 = 0
      2  637d				  -	      .byte	$90+4
      3  637d					      ENDIF
      4  637d				  -	      IF	$90 = $10
      5  637d				  -	      .byte	$20+4
      6  637d					      ENDIF
      7  637d				  -	      IF	$90 = $20
      8  637d				  -	      .byte	$40+4
      9  637d					      ENDIF
     10  637d				  -	      IF	$90 = $30
     11  637d				  -	      .byte	$40+4
     12  637d					      ENDIF
     13  637d				  -	      IF	$90 = $40
     14  637d				  -	      .byte	$60+4
     15  637d					      ENDIF
     16  637d				  -	      IF	$90 = $50
     17  637d				  -	      .byte	$80+4
     18  637d					      ENDIF
     19  637d				  -	      IF	$90 = $60
     20  637d				  -	      .byte	$C0+4
     21  637d					      ENDIF
     22  637d				  -	      IF	$90 = $70
     23  637d				  -	      .byte	$D0+4
     24  637d					      ENDIF
     25  637d				  -	      IF	$90 = $80
     26  637d				  -	      .byte	$B0+4
     27  637d					      ENDIF
     28  637d					      IF	$90 = $90
     29  637d		       94		      .byte.b	$90+4
     30  637e					      ENDIF
     31  637e				  -	      IF	$90 = $A0
     32  637e				  -	      .byte	$70+4
     33  637e					      ENDIF
     34  637e				  -	      IF	$90 = $B0
     35  637e				  -	      .byte	$50+4
     36  637e					      ENDIF
     37  637e				  -	      IF	$90 = $C0
     38  637e				  -	      .byte	$30+4
     39  637e					      ENDIF
     40  637e				  -	      IF	$90 = $D0
     41  637e				  -	      .byte	$30+4
     42  637e					      ENDIF
     43  637e				  -	      IF	$90 = $E0
     44  637e				  -	      .byte	$20+4
     45  637e					      ENDIF
     46  637e				  -	      IF	$90 = $F0
     47  637e				  -	      .byte	$40+4
     48  637e					      ENDIF
      0  637e					      NTSC_TO_PAL	$90, 4
      1  637e				  -	      IF	$90 = 0
      2  637e				  -	      .byte	$90+4
      3  637e					      ENDIF
      4  637e				  -	      IF	$90 = $10
      5  637e				  -	      .byte	$20+4
      6  637e					      ENDIF
      7  637e				  -	      IF	$90 = $20
      8  637e				  -	      .byte	$40+4
      9  637e					      ENDIF
     10  637e				  -	      IF	$90 = $30
     11  637e				  -	      .byte	$40+4
     12  637e					      ENDIF
     13  637e				  -	      IF	$90 = $40
     14  637e				  -	      .byte	$60+4
     15  637e					      ENDIF
     16  637e				  -	      IF	$90 = $50
     17  637e				  -	      .byte	$80+4
     18  637e					      ENDIF
     19  637e				  -	      IF	$90 = $60
     20  637e				  -	      .byte	$C0+4
     21  637e					      ENDIF
     22  637e				  -	      IF	$90 = $70
     23  637e				  -	      .byte	$D0+4
     24  637e					      ENDIF
     25  637e				  -	      IF	$90 = $80
     26  637e				  -	      .byte	$B0+4
     27  637e					      ENDIF
     28  637e					      IF	$90 = $90
     29  637e		       94		      .byte.b	$90+4
     30  637f					      ENDIF
     31  637f				  -	      IF	$90 = $A0
     32  637f				  -	      .byte	$70+4
     33  637f					      ENDIF
     34  637f				  -	      IF	$90 = $B0
     35  637f				  -	      .byte	$50+4
     36  637f					      ENDIF
     37  637f				  -	      IF	$90 = $C0
     38  637f				  -	      .byte	$30+4
     39  637f					      ENDIF
     40  637f				  -	      IF	$90 = $D0
     41  637f				  -	      .byte	$30+4
     42  637f					      ENDIF
     43  637f				  -	      IF	$90 = $E0
     44  637f				  -	      .byte	$20+4
     45  637f					      ENDIF
     46  637f				  -	      IF	$90 = $F0
     47  637f				  -	      .byte	$40+4
     48  637f					      ENDIF
      0  637f					      NTSC_TO_PAL	$90, 4
      1  637f				  -	      IF	$90 = 0
      2  637f				  -	      .byte	$90+4
      3  637f					      ENDIF
      4  637f				  -	      IF	$90 = $10
      5  637f				  -	      .byte	$20+4
      6  637f					      ENDIF
      7  637f				  -	      IF	$90 = $20
      8  637f				  -	      .byte	$40+4
      9  637f					      ENDIF
     10  637f				  -	      IF	$90 = $30
     11  637f				  -	      .byte	$40+4
     12  637f					      ENDIF
     13  637f				  -	      IF	$90 = $40
     14  637f				  -	      .byte	$60+4
     15  637f					      ENDIF
     16  637f				  -	      IF	$90 = $50
     17  637f				  -	      .byte	$80+4
     18  637f					      ENDIF
     19  637f				  -	      IF	$90 = $60
     20  637f				  -	      .byte	$C0+4
     21  637f					      ENDIF
     22  637f				  -	      IF	$90 = $70
     23  637f				  -	      .byte	$D0+4
     24  637f					      ENDIF
     25  637f				  -	      IF	$90 = $80
     26  637f				  -	      .byte	$B0+4
     27  637f					      ENDIF
     28  637f					      IF	$90 = $90
     29  637f		       94		      .byte.b	$90+4
     30  6380					      ENDIF
     31  6380				  -	      IF	$90 = $A0
     32  6380				  -	      .byte	$70+4
     33  6380					      ENDIF
     34  6380				  -	      IF	$90 = $B0
     35  6380				  -	      .byte	$50+4
     36  6380					      ENDIF
     37  6380				  -	      IF	$90 = $C0
     38  6380				  -	      .byte	$30+4
     39  6380					      ENDIF
     40  6380				  -	      IF	$90 = $D0
     41  6380				  -	      .byte	$30+4
     42  6380					      ENDIF
     43  6380				  -	      IF	$90 = $E0
     44  6380				  -	      .byte	$20+4
     45  6380					      ENDIF
     46  6380				  -	      IF	$90 = $F0
     47  6380				  -	      .byte	$40+4
     48  6380					      ENDIF
      0  6380					      NTSC_TO_PAL	$90, 4
      1  6380				  -	      IF	$90 = 0
      2  6380				  -	      .byte	$90+4
      3  6380					      ENDIF
      4  6380				  -	      IF	$90 = $10
      5  6380				  -	      .byte	$20+4
      6  6380					      ENDIF
      7  6380				  -	      IF	$90 = $20
      8  6380				  -	      .byte	$40+4
      9  6380					      ENDIF
     10  6380				  -	      IF	$90 = $30
     11  6380				  -	      .byte	$40+4
     12  6380					      ENDIF
     13  6380				  -	      IF	$90 = $40
     14  6380				  -	      .byte	$60+4
     15  6380					      ENDIF
     16  6380				  -	      IF	$90 = $50
     17  6380				  -	      .byte	$80+4
     18  6380					      ENDIF
     19  6380				  -	      IF	$90 = $60
     20  6380				  -	      .byte	$C0+4
     21  6380					      ENDIF
     22  6380				  -	      IF	$90 = $70
     23  6380				  -	      .byte	$D0+4
     24  6380					      ENDIF
     25  6380				  -	      IF	$90 = $80
     26  6380				  -	      .byte	$B0+4
     27  6380					      ENDIF
     28  6380					      IF	$90 = $90
     29  6380		       94		      .byte.b	$90+4
     30  6381					      ENDIF
     31  6381				  -	      IF	$90 = $A0
     32  6381				  -	      .byte	$70+4
     33  6381					      ENDIF
     34  6381				  -	      IF	$90 = $B0
     35  6381				  -	      .byte	$50+4
     36  6381					      ENDIF
     37  6381				  -	      IF	$90 = $C0
     38  6381				  -	      .byte	$30+4
     39  6381					      ENDIF
     40  6381				  -	      IF	$90 = $D0
     41  6381				  -	      .byte	$30+4
     42  6381					      ENDIF
     43  6381				  -	      IF	$90 = $E0
     44  6381				  -	      .byte	$20+4
     45  6381					      ENDIF
     46  6381				  -	      IF	$90 = $F0
     47  6381				  -	      .byte	$40+4
     48  6381					      ENDIF
      0  6381					      NTSC_TO_PAL	$90, 4
      1  6381				  -	      IF	$90 = 0
      2  6381				  -	      .byte	$90+4
      3  6381					      ENDIF
      4  6381				  -	      IF	$90 = $10
      5  6381				  -	      .byte	$20+4
      6  6381					      ENDIF
      7  6381				  -	      IF	$90 = $20
      8  6381				  -	      .byte	$40+4
      9  6381					      ENDIF
     10  6381				  -	      IF	$90 = $30
     11  6381				  -	      .byte	$40+4
     12  6381					      ENDIF
     13  6381				  -	      IF	$90 = $40
     14  6381				  -	      .byte	$60+4
     15  6381					      ENDIF
     16  6381				  -	      IF	$90 = $50
     17  6381				  -	      .byte	$80+4
     18  6381					      ENDIF
     19  6381				  -	      IF	$90 = $60
     20  6381				  -	      .byte	$C0+4
     21  6381					      ENDIF
     22  6381				  -	      IF	$90 = $70
     23  6381				  -	      .byte	$D0+4
     24  6381					      ENDIF
     25  6381				  -	      IF	$90 = $80
     26  6381				  -	      .byte	$B0+4
     27  6381					      ENDIF
     28  6381					      IF	$90 = $90
     29  6381		       94		      .byte.b	$90+4
     30  6382					      ENDIF
     31  6382				  -	      IF	$90 = $A0
     32  6382				  -	      .byte	$70+4
     33  6382					      ENDIF
     34  6382				  -	      IF	$90 = $B0
     35  6382				  -	      .byte	$50+4
     36  6382					      ENDIF
     37  6382				  -	      IF	$90 = $C0
     38  6382				  -	      .byte	$30+4
     39  6382					      ENDIF
     40  6382				  -	      IF	$90 = $D0
     41  6382				  -	      .byte	$30+4
     42  6382					      ENDIF
     43  6382				  -	      IF	$90 = $E0
     44  6382				  -	      .byte	$20+4
     45  6382					      ENDIF
     46  6382				  -	      IF	$90 = $F0
     47  6382				  -	      .byte	$40+4
     48  6382					      ENDIF
      0  6382					      NTSC_TO_PAL	$30, 4
      1  6382				  -	      IF	$30 = 0
      2  6382				  -	      .byte	$30+4
      3  6382					      ENDIF
      4  6382				  -	      IF	$30 = $10
      5  6382				  -	      .byte	$20+4
      6  6382					      ENDIF
      7  6382				  -	      IF	$30 = $20
      8  6382				  -	      .byte	$40+4
      9  6382					      ENDIF
     10  6382					      IF	$30 = $30
     11  6382		       44		      .byte.b	$40+4
     12  6383					      ENDIF
     13  6383				  -	      IF	$30 = $40
     14  6383				  -	      .byte	$60+4
     15  6383					      ENDIF
     16  6383				  -	      IF	$30 = $50
     17  6383				  -	      .byte	$80+4
     18  6383					      ENDIF
     19  6383				  -	      IF	$30 = $60
     20  6383				  -	      .byte	$C0+4
     21  6383					      ENDIF
     22  6383				  -	      IF	$30 = $70
     23  6383				  -	      .byte	$D0+4
     24  6383					      ENDIF
     25  6383				  -	      IF	$30 = $80
     26  6383				  -	      .byte	$B0+4
     27  6383					      ENDIF
     28  6383				  -	      IF	$30 = $90
     29  6383				  -	      .byte	$90+4
     30  6383					      ENDIF
     31  6383				  -	      IF	$30 = $A0
     32  6383				  -	      .byte	$70+4
     33  6383					      ENDIF
     34  6383				  -	      IF	$30 = $B0
     35  6383				  -	      .byte	$50+4
     36  6383					      ENDIF
     37  6383				  -	      IF	$30 = $C0
     38  6383				  -	      .byte	$30+4
     39  6383					      ENDIF
     40  6383				  -	      IF	$30 = $D0
     41  6383				  -	      .byte	$30+4
     42  6383					      ENDIF
     43  6383				  -	      IF	$30 = $E0
     44  6383				  -	      .byte	$20+4
     45  6383					      ENDIF
     46  6383				  -	      IF	$30 = $F0
     47  6383				  -	      .byte	$40+4
     48  6383					      ENDIF
      0  6383					      NTSC_TO_PAL	$0, 12
      1  6383					      IF	$0 = 0
      2  6383		       0c		      .byte.b	$0+12
      3  6384					      ENDIF
      4  6384				  -	      IF	$0 = $10
      5  6384				  -	      .byte	$20+12
      6  6384					      ENDIF
      7  6384				  -	      IF	$0 = $20
      8  6384				  -	      .byte	$40+12
      9  6384					      ENDIF
     10  6384				  -	      IF	$0 = $30
     11  6384				  -	      .byte	$40+12
     12  6384					      ENDIF
     13  6384				  -	      IF	$0 = $40
     14  6384				  -	      .byte	$60+12
     15  6384					      ENDIF
     16  6384				  -	      IF	$0 = $50
     17  6384				  -	      .byte	$80+12
     18  6384					      ENDIF
     19  6384				  -	      IF	$0 = $60
     20  6384				  -	      .byte	$C0+12
     21  6384					      ENDIF
     22  6384				  -	      IF	$0 = $70
     23  6384				  -	      .byte	$D0+12
     24  6384					      ENDIF
     25  6384				  -	      IF	$0 = $80
     26  6384				  -	      .byte	$B0+12
     27  6384					      ENDIF
     28  6384				  -	      IF	$0 = $90
     29  6384				  -	      .byte	$90+12
     30  6384					      ENDIF
     31  6384				  -	      IF	$0 = $A0
     32  6384				  -	      .byte	$70+12
     33  6384					      ENDIF
     34  6384				  -	      IF	$0 = $B0
     35  6384				  -	      .byte	$50+12
     36  6384					      ENDIF
     37  6384				  -	      IF	$0 = $C0
     38  6384				  -	      .byte	$30+12
     39  6384					      ENDIF
     40  6384				  -	      IF	$0 = $D0
     41  6384				  -	      .byte	$30+12
     42  6384					      ENDIF
     43  6384				  -	      IF	$0 = $E0
     44  6384				  -	      .byte	$20+12
     45  6384					      ENDIF
     46  6384				  -	      IF	$0 = $F0
     47  6384				  -	      .byte	$40+12
     48  6384					      ENDIF
      0  6384					      NTSC_TO_PAL	$90, 6
      1  6384				  -	      IF	$90 = 0
      2  6384				  -	      .byte	$90+6
      3  6384					      ENDIF
      4  6384				  -	      IF	$90 = $10
      5  6384				  -	      .byte	$20+6
      6  6384					      ENDIF
      7  6384				  -	      IF	$90 = $20
      8  6384				  -	      .byte	$40+6
      9  6384					      ENDIF
     10  6384				  -	      IF	$90 = $30
     11  6384				  -	      .byte	$40+6
     12  6384					      ENDIF
     13  6384				  -	      IF	$90 = $40
     14  6384				  -	      .byte	$60+6
     15  6384					      ENDIF
     16  6384				  -	      IF	$90 = $50
     17  6384				  -	      .byte	$80+6
     18  6384					      ENDIF
     19  6384				  -	      IF	$90 = $60
     20  6384				  -	      .byte	$C0+6
     21  6384					      ENDIF
     22  6384				  -	      IF	$90 = $70
     23  6384				  -	      .byte	$D0+6
     24  6384					      ENDIF
     25  6384				  -	      IF	$90 = $80
     26  6384				  -	      .byte	$B0+6
     27  6384					      ENDIF
     28  6384					      IF	$90 = $90
     29  6384		       96		      .byte.b	$90+6
     30  6385					      ENDIF
     31  6385				  -	      IF	$90 = $A0
     32  6385				  -	      .byte	$70+6
     33  6385					      ENDIF
     34  6385				  -	      IF	$90 = $B0
     35  6385				  -	      .byte	$50+6
     36  6385					      ENDIF
     37  6385				  -	      IF	$90 = $C0
     38  6385				  -	      .byte	$30+6
     39  6385					      ENDIF
     40  6385				  -	      IF	$90 = $D0
     41  6385				  -	      .byte	$30+6
     42  6385					      ENDIF
     43  6385				  -	      IF	$90 = $E0
     44  6385				  -	      .byte	$20+6
     45  6385					      ENDIF
     46  6385				  -	      IF	$90 = $F0
     47  6385				  -	      .byte	$40+6
     48  6385					      ENDIF
      0  6385					      NTSC_TO_PAL	$90, 6
      1  6385				  -	      IF	$90 = 0
      2  6385				  -	      .byte	$90+6
      3  6385					      ENDIF
      4  6385				  -	      IF	$90 = $10
      5  6385				  -	      .byte	$20+6
      6  6385					      ENDIF
      7  6385				  -	      IF	$90 = $20
      8  6385				  -	      .byte	$40+6
      9  6385					      ENDIF
     10  6385				  -	      IF	$90 = $30
     11  6385				  -	      .byte	$40+6
     12  6385					      ENDIF
     13  6385				  -	      IF	$90 = $40
     14  6385				  -	      .byte	$60+6
     15  6385					      ENDIF
     16  6385				  -	      IF	$90 = $50
     17  6385				  -	      .byte	$80+6
     18  6385					      ENDIF
     19  6385				  -	      IF	$90 = $60
     20  6385				  -	      .byte	$C0+6
     21  6385					      ENDIF
     22  6385				  -	      IF	$90 = $70
     23  6385				  -	      .byte	$D0+6
     24  6385					      ENDIF
     25  6385				  -	      IF	$90 = $80
     26  6385				  -	      .byte	$B0+6
     27  6385					      ENDIF
     28  6385					      IF	$90 = $90
     29  6385		       96		      .byte.b	$90+6
     30  6386					      ENDIF
     31  6386				  -	      IF	$90 = $A0
     32  6386				  -	      .byte	$70+6
     33  6386					      ENDIF
     34  6386				  -	      IF	$90 = $B0
     35  6386				  -	      .byte	$50+6
     36  6386					      ENDIF
     37  6386				  -	      IF	$90 = $C0
     38  6386				  -	      .byte	$30+6
     39  6386					      ENDIF
     40  6386				  -	      IF	$90 = $D0
     41  6386				  -	      .byte	$30+6
     42  6386					      ENDIF
     43  6386				  -	      IF	$90 = $E0
     44  6386				  -	      .byte	$20+6
     45  6386					      ENDIF
     46  6386				  -	      IF	$90 = $F0
     47  6386				  -	      .byte	$40+6
     48  6386					      ENDIF
      0  6386					      NTSC_TO_PAL	$90, 6
      1  6386				  -	      IF	$90 = 0
      2  6386				  -	      .byte	$90+6
      3  6386					      ENDIF
      4  6386				  -	      IF	$90 = $10
      5  6386				  -	      .byte	$20+6
      6  6386					      ENDIF
      7  6386				  -	      IF	$90 = $20
      8  6386				  -	      .byte	$40+6
      9  6386					      ENDIF
     10  6386				  -	      IF	$90 = $30
     11  6386				  -	      .byte	$40+6
     12  6386					      ENDIF
     13  6386				  -	      IF	$90 = $40
     14  6386				  -	      .byte	$60+6
     15  6386					      ENDIF
     16  6386				  -	      IF	$90 = $50
     17  6386				  -	      .byte	$80+6
     18  6386					      ENDIF
     19  6386				  -	      IF	$90 = $60
     20  6386				  -	      .byte	$C0+6
     21  6386					      ENDIF
     22  6386				  -	      IF	$90 = $70
     23  6386				  -	      .byte	$D0+6
     24  6386					      ENDIF
     25  6386				  -	      IF	$90 = $80
     26  6386				  -	      .byte	$B0+6
     27  6386					      ENDIF
     28  6386					      IF	$90 = $90
     29  6386		       96		      .byte.b	$90+6
     30  6387					      ENDIF
     31  6387				  -	      IF	$90 = $A0
     32  6387				  -	      .byte	$70+6
     33  6387					      ENDIF
     34  6387				  -	      IF	$90 = $B0
     35  6387				  -	      .byte	$50+6
     36  6387					      ENDIF
     37  6387				  -	      IF	$90 = $C0
     38  6387				  -	      .byte	$30+6
     39  6387					      ENDIF
     40  6387				  -	      IF	$90 = $D0
     41  6387				  -	      .byte	$30+6
     42  6387					      ENDIF
     43  6387				  -	      IF	$90 = $E0
     44  6387				  -	      .byte	$20+6
     45  6387					      ENDIF
     46  6387				  -	      IF	$90 = $F0
     47  6387				  -	      .byte	$40+6
     48  6387					      ENDIF
      0  6387					      NTSC_TO_PAL	$90, 6
      1  6387				  -	      IF	$90 = 0
      2  6387				  -	      .byte	$90+6
      3  6387					      ENDIF
      4  6387				  -	      IF	$90 = $10
      5  6387				  -	      .byte	$20+6
      6  6387					      ENDIF
      7  6387				  -	      IF	$90 = $20
      8  6387				  -	      .byte	$40+6
      9  6387					      ENDIF
     10  6387				  -	      IF	$90 = $30
     11  6387				  -	      .byte	$40+6
     12  6387					      ENDIF
     13  6387				  -	      IF	$90 = $40
     14  6387				  -	      .byte	$60+6
     15  6387					      ENDIF
     16  6387				  -	      IF	$90 = $50
     17  6387				  -	      .byte	$80+6
     18  6387					      ENDIF
     19  6387				  -	      IF	$90 = $60
     20  6387				  -	      .byte	$C0+6
     21  6387					      ENDIF
     22  6387				  -	      IF	$90 = $70
     23  6387				  -	      .byte	$D0+6
     24  6387					      ENDIF
     25  6387				  -	      IF	$90 = $80
     26  6387				  -	      .byte	$B0+6
     27  6387					      ENDIF
     28  6387					      IF	$90 = $90
     29  6387		       96		      .byte.b	$90+6
     30  6388					      ENDIF
     31  6388				  -	      IF	$90 = $A0
     32  6388				  -	      .byte	$70+6
     33  6388					      ENDIF
     34  6388				  -	      IF	$90 = $B0
     35  6388				  -	      .byte	$50+6
     36  6388					      ENDIF
     37  6388				  -	      IF	$90 = $C0
     38  6388				  -	      .byte	$30+6
     39  6388					      ENDIF
     40  6388				  -	      IF	$90 = $D0
     41  6388				  -	      .byte	$30+6
     42  6388					      ENDIF
     43  6388				  -	      IF	$90 = $E0
     44  6388				  -	      .byte	$20+6
     45  6388					      ENDIF
     46  6388				  -	      IF	$90 = $F0
     47  6388				  -	      .byte	$40+6
     48  6388					      ENDIF
      0  6388					      NTSC_TO_PAL	$90, 6
      1  6388				  -	      IF	$90 = 0
      2  6388				  -	      .byte	$90+6
      3  6388					      ENDIF
      4  6388				  -	      IF	$90 = $10
      5  6388				  -	      .byte	$20+6
      6  6388					      ENDIF
      7  6388				  -	      IF	$90 = $20
      8  6388				  -	      .byte	$40+6
      9  6388					      ENDIF
     10  6388				  -	      IF	$90 = $30
     11  6388				  -	      .byte	$40+6
     12  6388					      ENDIF
     13  6388				  -	      IF	$90 = $40
     14  6388				  -	      .byte	$60+6
     15  6388					      ENDIF
     16  6388				  -	      IF	$90 = $50
     17  6388				  -	      .byte	$80+6
     18  6388					      ENDIF
     19  6388				  -	      IF	$90 = $60
     20  6388				  -	      .byte	$C0+6
     21  6388					      ENDIF
     22  6388				  -	      IF	$90 = $70
     23  6388				  -	      .byte	$D0+6
     24  6388					      ENDIF
     25  6388				  -	      IF	$90 = $80
     26  6388				  -	      .byte	$B0+6
     27  6388					      ENDIF
     28  6388					      IF	$90 = $90
     29  6388		       96		      .byte.b	$90+6
     30  6389					      ENDIF
     31  6389				  -	      IF	$90 = $A0
     32  6389				  -	      .byte	$70+6
     33  6389					      ENDIF
     34  6389				  -	      IF	$90 = $B0
     35  6389				  -	      .byte	$50+6
     36  6389					      ENDIF
     37  6389				  -	      IF	$90 = $C0
     38  6389				  -	      .byte	$30+6
     39  6389					      ENDIF
     40  6389				  -	      IF	$90 = $D0
     41  6389				  -	      .byte	$30+6
     42  6389					      ENDIF
     43  6389				  -	      IF	$90 = $E0
     44  6389				  -	      .byte	$20+6
     45  6389					      ENDIF
     46  6389				  -	      IF	$90 = $F0
     47  6389				  -	      .byte	$40+6
     48  6389					      ENDIF
      0  6389					      NTSC_TO_PAL	$0, 12
      1  6389					      IF	$0 = 0
      2  6389		       0c		      .byte.b	$0+12
      3  638a					      ENDIF
      4  638a				  -	      IF	$0 = $10
      5  638a				  -	      .byte	$20+12
      6  638a					      ENDIF
      7  638a				  -	      IF	$0 = $20
      8  638a				  -	      .byte	$40+12
      9  638a					      ENDIF
     10  638a				  -	      IF	$0 = $30
     11  638a				  -	      .byte	$40+12
     12  638a					      ENDIF
     13  638a				  -	      IF	$0 = $40
     14  638a				  -	      .byte	$60+12
     15  638a					      ENDIF
     16  638a				  -	      IF	$0 = $50
     17  638a				  -	      .byte	$80+12
     18  638a					      ENDIF
     19  638a				  -	      IF	$0 = $60
     20  638a				  -	      .byte	$C0+12
     21  638a					      ENDIF
     22  638a				  -	      IF	$0 = $70
     23  638a				  -	      .byte	$D0+12
     24  638a					      ENDIF
     25  638a				  -	      IF	$0 = $80
     26  638a				  -	      .byte	$B0+12
     27  638a					      ENDIF
     28  638a				  -	      IF	$0 = $90
     29  638a				  -	      .byte	$90+12
     30  638a					      ENDIF
     31  638a				  -	      IF	$0 = $A0
     32  638a				  -	      .byte	$70+12
     33  638a					      ENDIF
     34  638a				  -	      IF	$0 = $B0
     35  638a				  -	      .byte	$50+12
     36  638a					      ENDIF
     37  638a				  -	      IF	$0 = $C0
     38  638a				  -	      .byte	$30+12
     39  638a					      ENDIF
     40  638a				  -	      IF	$0 = $D0
     41  638a				  -	      .byte	$30+12
     42  638a					      ENDIF
     43  638a				  -	      IF	$0 = $E0
     44  638a				  -	      .byte	$20+12
     45  638a					      ENDIF
     46  638a				  -	      IF	$0 = $F0
     47  638a				  -	      .byte	$40+12
     48  638a					      ENDIF
      0  638a					      NTSC_TO_PAL	$30, 8
      1  638a				  -	      IF	$30 = 0
      2  638a				  -	      .byte	$30+8
      3  638a					      ENDIF
      4  638a				  -	      IF	$30 = $10
      5  638a				  -	      .byte	$20+8
      6  638a					      ENDIF
      7  638a				  -	      IF	$30 = $20
      8  638a				  -	      .byte	$40+8
      9  638a					      ENDIF
     10  638a					      IF	$30 = $30
     11  638a		       48		      .byte.b	$40+8
     12  638b					      ENDIF
     13  638b				  -	      IF	$30 = $40
     14  638b				  -	      .byte	$60+8
     15  638b					      ENDIF
     16  638b				  -	      IF	$30 = $50
     17  638b				  -	      .byte	$80+8
     18  638b					      ENDIF
     19  638b				  -	      IF	$30 = $60
     20  638b				  -	      .byte	$C0+8
     21  638b					      ENDIF
     22  638b				  -	      IF	$30 = $70
     23  638b				  -	      .byte	$D0+8
     24  638b					      ENDIF
     25  638b				  -	      IF	$30 = $80
     26  638b				  -	      .byte	$B0+8
     27  638b					      ENDIF
     28  638b				  -	      IF	$30 = $90
     29  638b				  -	      .byte	$90+8
     30  638b					      ENDIF
     31  638b				  -	      IF	$30 = $A0
     32  638b				  -	      .byte	$70+8
     33  638b					      ENDIF
     34  638b				  -	      IF	$30 = $B0
     35  638b				  -	      .byte	$50+8
     36  638b					      ENDIF
     37  638b				  -	      IF	$30 = $C0
     38  638b				  -	      .byte	$30+8
     39  638b					      ENDIF
     40  638b				  -	      IF	$30 = $D0
     41  638b				  -	      .byte	$30+8
     42  638b					      ENDIF
     43  638b				  -	      IF	$30 = $E0
     44  638b				  -	      .byte	$20+8
     45  638b					      ENDIF
     46  638b				  -	      IF	$30 = $F0
     47  638b				  -	      .byte	$40+8
     48  638b					      ENDIF
      0  638b					      NTSC_TO_PAL	$30, 8
      1  638b				  -	      IF	$30 = 0
      2  638b				  -	      .byte	$30+8
      3  638b					      ENDIF
      4  638b				  -	      IF	$30 = $10
      5  638b				  -	      .byte	$20+8
      6  638b					      ENDIF
      7  638b				  -	      IF	$30 = $20
      8  638b				  -	      .byte	$40+8
      9  638b					      ENDIF
     10  638b					      IF	$30 = $30
     11  638b		       48		      .byte.b	$40+8
     12  638c					      ENDIF
     13  638c				  -	      IF	$30 = $40
     14  638c				  -	      .byte	$60+8
     15  638c					      ENDIF
     16  638c				  -	      IF	$30 = $50
     17  638c				  -	      .byte	$80+8
     18  638c					      ENDIF
     19  638c				  -	      IF	$30 = $60
     20  638c				  -	      .byte	$C0+8
     21  638c					      ENDIF
     22  638c				  -	      IF	$30 = $70
     23  638c				  -	      .byte	$D0+8
     24  638c					      ENDIF
     25  638c				  -	      IF	$30 = $80
     26  638c				  -	      .byte	$B0+8
     27  638c					      ENDIF
     28  638c				  -	      IF	$30 = $90
     29  638c				  -	      .byte	$90+8
     30  638c					      ENDIF
     31  638c				  -	      IF	$30 = $A0
     32  638c				  -	      .byte	$70+8
     33  638c					      ENDIF
     34  638c				  -	      IF	$30 = $B0
     35  638c				  -	      .byte	$50+8
     36  638c					      ENDIF
     37  638c				  -	      IF	$30 = $C0
     38  638c				  -	      .byte	$30+8
     39  638c					      ENDIF
     40  638c				  -	      IF	$30 = $D0
     41  638c				  -	      .byte	$30+8
     42  638c					      ENDIF
     43  638c				  -	      IF	$30 = $E0
     44  638c				  -	      .byte	$20+8
     45  638c					      ENDIF
     46  638c				  -	      IF	$30 = $F0
     47  638c				  -	      .byte	$40+8
     48  638c					      ENDIF
      0  638c					      NTSC_TO_PAL	$30, 8
      1  638c				  -	      IF	$30 = 0
      2  638c				  -	      .byte	$30+8
      3  638c					      ENDIF
      4  638c				  -	      IF	$30 = $10
      5  638c				  -	      .byte	$20+8
      6  638c					      ENDIF
      7  638c				  -	      IF	$30 = $20
      8  638c				  -	      .byte	$40+8
      9  638c					      ENDIF
     10  638c					      IF	$30 = $30
     11  638c		       48		      .byte.b	$40+8
     12  638d					      ENDIF
     13  638d				  -	      IF	$30 = $40
     14  638d				  -	      .byte	$60+8
     15  638d					      ENDIF
     16  638d				  -	      IF	$30 = $50
     17  638d				  -	      .byte	$80+8
     18  638d					      ENDIF
     19  638d				  -	      IF	$30 = $60
     20  638d				  -	      .byte	$C0+8
     21  638d					      ENDIF
     22  638d				  -	      IF	$30 = $70
     23  638d				  -	      .byte	$D0+8
     24  638d					      ENDIF
     25  638d				  -	      IF	$30 = $80
     26  638d				  -	      .byte	$B0+8
     27  638d					      ENDIF
     28  638d				  -	      IF	$30 = $90
     29  638d				  -	      .byte	$90+8
     30  638d					      ENDIF
     31  638d				  -	      IF	$30 = $A0
     32  638d				  -	      .byte	$70+8
     33  638d					      ENDIF
     34  638d				  -	      IF	$30 = $B0
     35  638d				  -	      .byte	$50+8
     36  638d					      ENDIF
     37  638d				  -	      IF	$30 = $C0
     38  638d				  -	      .byte	$30+8
     39  638d					      ENDIF
     40  638d				  -	      IF	$30 = $D0
     41  638d				  -	      .byte	$30+8
     42  638d					      ENDIF
     43  638d				  -	      IF	$30 = $E0
     44  638d				  -	      .byte	$20+8
     45  638d					      ENDIF
     46  638d				  -	      IF	$30 = $F0
     47  638d				  -	      .byte	$40+8
     48  638d					      ENDIF
      0  638d					      NTSC_TO_PAL	$30, 8
      1  638d				  -	      IF	$30 = 0
      2  638d				  -	      .byte	$30+8
      3  638d					      ENDIF
      4  638d				  -	      IF	$30 = $10
      5  638d				  -	      .byte	$20+8
      6  638d					      ENDIF
      7  638d				  -	      IF	$30 = $20
      8  638d				  -	      .byte	$40+8
      9  638d					      ENDIF
     10  638d					      IF	$30 = $30
     11  638d		       48		      .byte.b	$40+8
     12  638e					      ENDIF
     13  638e				  -	      IF	$30 = $40
     14  638e				  -	      .byte	$60+8
     15  638e					      ENDIF
     16  638e				  -	      IF	$30 = $50
     17  638e				  -	      .byte	$80+8
     18  638e					      ENDIF
     19  638e				  -	      IF	$30 = $60
     20  638e				  -	      .byte	$C0+8
     21  638e					      ENDIF
     22  638e				  -	      IF	$30 = $70
     23  638e				  -	      .byte	$D0+8
     24  638e					      ENDIF
     25  638e				  -	      IF	$30 = $80
     26  638e				  -	      .byte	$B0+8
     27  638e					      ENDIF
     28  638e				  -	      IF	$30 = $90
     29  638e				  -	      .byte	$90+8
     30  638e					      ENDIF
     31  638e				  -	      IF	$30 = $A0
     32  638e				  -	      .byte	$70+8
     33  638e					      ENDIF
     34  638e				  -	      IF	$30 = $B0
     35  638e				  -	      .byte	$50+8
     36  638e					      ENDIF
     37  638e				  -	      IF	$30 = $C0
     38  638e				  -	      .byte	$30+8
     39  638e					      ENDIF
     40  638e				  -	      IF	$30 = $D0
     41  638e				  -	      .byte	$30+8
     42  638e					      ENDIF
     43  638e				  -	      IF	$30 = $E0
     44  638e				  -	      .byte	$20+8
     45  638e					      ENDIF
     46  638e				  -	      IF	$30 = $F0
     47  638e				  -	      .byte	$40+8
     48  638e					      ENDIF
      0  638e					      NTSC_TO_PAL	$30, 8
      1  638e				  -	      IF	$30 = 0
      2  638e				  -	      .byte	$30+8
      3  638e					      ENDIF
      4  638e				  -	      IF	$30 = $10
      5  638e				  -	      .byte	$20+8
      6  638e					      ENDIF
      7  638e				  -	      IF	$30 = $20
      8  638e				  -	      .byte	$40+8
      9  638e					      ENDIF
     10  638e					      IF	$30 = $30
     11  638e		       48		      .byte.b	$40+8
     12  638f					      ENDIF
     13  638f				  -	      IF	$30 = $40
     14  638f				  -	      .byte	$60+8
     15  638f					      ENDIF
     16  638f				  -	      IF	$30 = $50
     17  638f				  -	      .byte	$80+8
     18  638f					      ENDIF
     19  638f				  -	      IF	$30 = $60
     20  638f				  -	      .byte	$C0+8
     21  638f					      ENDIF
     22  638f				  -	      IF	$30 = $70
     23  638f				  -	      .byte	$D0+8
     24  638f					      ENDIF
     25  638f				  -	      IF	$30 = $80
     26  638f				  -	      .byte	$B0+8
     27  638f					      ENDIF
     28  638f				  -	      IF	$30 = $90
     29  638f				  -	      .byte	$90+8
     30  638f					      ENDIF
     31  638f				  -	      IF	$30 = $A0
     32  638f				  -	      .byte	$70+8
     33  638f					      ENDIF
     34  638f				  -	      IF	$30 = $B0
     35  638f				  -	      .byte	$50+8
     36  638f					      ENDIF
     37  638f				  -	      IF	$30 = $C0
     38  638f				  -	      .byte	$30+8
     39  638f					      ENDIF
     40  638f				  -	      IF	$30 = $D0
     41  638f				  -	      .byte	$30+8
     42  638f					      ENDIF
     43  638f				  -	      IF	$30 = $E0
     44  638f				  -	      .byte	$20+8
     45  638f					      ENDIF
     46  638f				  -	      IF	$30 = $F0
     47  638f				  -	      .byte	$40+8
     48  638f					      ENDIF
      0  638f					      NTSC_TO_PAL	$30, 8
      1  638f				  -	      IF	$30 = 0
      2  638f				  -	      .byte	$30+8
      3  638f					      ENDIF
      4  638f				  -	      IF	$30 = $10
      5  638f				  -	      .byte	$20+8
      6  638f					      ENDIF
      7  638f				  -	      IF	$30 = $20
      8  638f				  -	      .byte	$40+8
      9  638f					      ENDIF
     10  638f					      IF	$30 = $30
     11  638f		       48		      .byte.b	$40+8
     12  6390					      ENDIF
     13  6390				  -	      IF	$30 = $40
     14  6390				  -	      .byte	$60+8
     15  6390					      ENDIF
     16  6390				  -	      IF	$30 = $50
     17  6390				  -	      .byte	$80+8
     18  6390					      ENDIF
     19  6390				  -	      IF	$30 = $60
     20  6390				  -	      .byte	$C0+8
     21  6390					      ENDIF
     22  6390				  -	      IF	$30 = $70
     23  6390				  -	      .byte	$D0+8
     24  6390					      ENDIF
     25  6390				  -	      IF	$30 = $80
     26  6390				  -	      .byte	$B0+8
     27  6390					      ENDIF
     28  6390				  -	      IF	$30 = $90
     29  6390				  -	      .byte	$90+8
     30  6390					      ENDIF
     31  6390				  -	      IF	$30 = $A0
     32  6390				  -	      .byte	$70+8
     33  6390					      ENDIF
     34  6390				  -	      IF	$30 = $B0
     35  6390				  -	      .byte	$50+8
     36  6390					      ENDIF
     37  6390				  -	      IF	$30 = $C0
     38  6390				  -	      .byte	$30+8
     39  6390					      ENDIF
     40  6390				  -	      IF	$30 = $D0
     41  6390				  -	      .byte	$30+8
     42  6390					      ENDIF
     43  6390				  -	      IF	$30 = $E0
     44  6390				  -	      .byte	$20+8
     45  6390					      ENDIF
     46  6390				  -	      IF	$30 = $F0
     47  6390				  -	      .byte	$40+8
     48  6390					      ENDIF
      0  6390					      NTSC_TO_PAL	$10, $C
      1  6390				  -	      IF	$10 = 0
      2  6390				  -	      .byte	$10+$C
      3  6390					      ENDIF
      4  6390					      IF	$10 = $10
      5  6390		       2c		      .byte.b	$20+$C
      6  6391					      ENDIF
      7  6391				  -	      IF	$10 = $20
      8  6391				  -	      .byte	$40+$C
      9  6391					      ENDIF
     10  6391				  -	      IF	$10 = $30
     11  6391				  -	      .byte	$40+$C
     12  6391					      ENDIF
     13  6391				  -	      IF	$10 = $40
     14  6391				  -	      .byte	$60+$C
     15  6391					      ENDIF
     16  6391				  -	      IF	$10 = $50
     17  6391				  -	      .byte	$80+$C
     18  6391					      ENDIF
     19  6391				  -	      IF	$10 = $60
     20  6391				  -	      .byte	$C0+$C
     21  6391					      ENDIF
     22  6391				  -	      IF	$10 = $70
     23  6391				  -	      .byte	$D0+$C
     24  6391					      ENDIF
     25  6391				  -	      IF	$10 = $80
     26  6391				  -	      .byte	$B0+$C
     27  6391					      ENDIF
     28  6391				  -	      IF	$10 = $90
     29  6391				  -	      .byte	$90+$C
     30  6391					      ENDIF
     31  6391				  -	      IF	$10 = $A0
     32  6391				  -	      .byte	$70+$C
     33  6391					      ENDIF
     34  6391				  -	      IF	$10 = $B0
     35  6391				  -	      .byte	$50+$C
     36  6391					      ENDIF
     37  6391				  -	      IF	$10 = $C0
     38  6391				  -	      .byte	$30+$C
     39  6391					      ENDIF
     40  6391				  -	      IF	$10 = $D0
     41  6391				  -	      .byte	$30+$C
     42  6391					      ENDIF
     43  6391				  -	      IF	$10 = $E0
     44  6391				  -	      .byte	$20+$C
     45  6391					      ENDIF
     46  6391				  -	      IF	$10 = $F0
     47  6391				  -	      .byte	$40+$C
     48  6391					      ENDIF
      0  6391					      NTSC_TO_PAL	$10, $C
      1  6391				  -	      IF	$10 = 0
      2  6391				  -	      .byte	$10+$C
      3  6391					      ENDIF
      4  6391					      IF	$10 = $10
      5  6391		       2c		      .byte.b	$20+$C
      6  6392					      ENDIF
      7  6392				  -	      IF	$10 = $20
      8  6392				  -	      .byte	$40+$C
      9  6392					      ENDIF
     10  6392				  -	      IF	$10 = $30
     11  6392				  -	      .byte	$40+$C
     12  6392					      ENDIF
     13  6392				  -	      IF	$10 = $40
     14  6392				  -	      .byte	$60+$C
     15  6392					      ENDIF
     16  6392				  -	      IF	$10 = $50
     17  6392				  -	      .byte	$80+$C
     18  6392					      ENDIF
     19  6392				  -	      IF	$10 = $60
     20  6392				  -	      .byte	$C0+$C
     21  6392					      ENDIF
     22  6392				  -	      IF	$10 = $70
     23  6392				  -	      .byte	$D0+$C
     24  6392					      ENDIF
     25  6392				  -	      IF	$10 = $80
     26  6392				  -	      .byte	$B0+$C
     27  6392					      ENDIF
     28  6392				  -	      IF	$10 = $90
     29  6392				  -	      .byte	$90+$C
     30  6392					      ENDIF
     31  6392				  -	      IF	$10 = $A0
     32  6392				  -	      .byte	$70+$C
     33  6392					      ENDIF
     34  6392				  -	      IF	$10 = $B0
     35  6392				  -	      .byte	$50+$C
     36  6392					      ENDIF
     37  6392				  -	      IF	$10 = $C0
     38  6392				  -	      .byte	$30+$C
     39  6392					      ENDIF
     40  6392				  -	      IF	$10 = $D0
     41  6392				  -	      .byte	$30+$C
     42  6392					      ENDIF
     43  6392				  -	      IF	$10 = $E0
     44  6392				  -	      .byte	$20+$C
     45  6392					      ENDIF
     46  6392				  -	      IF	$10 = $F0
     47  6392				  -	      .byte	$40+$C
     48  6392					      ENDIF
    602  6392
    603  6392				   mancolourPAL2
      0  6392					      NTSC_TO_PAL	$10, 4
      1  6392				  -	      IF	$10 = 0
      2  6392				  -	      .byte	$10+4
      3  6392					      ENDIF
      4  6392					      IF	$10 = $10
      5  6392		       24		      .byte.b	$20+4
      6  6393					      ENDIF
      7  6393				  -	      IF	$10 = $20
      8  6393				  -	      .byte	$40+4
      9  6393					      ENDIF
     10  6393				  -	      IF	$10 = $30
     11  6393				  -	      .byte	$40+4
     12  6393					      ENDIF
     13  6393				  -	      IF	$10 = $40
     14  6393				  -	      .byte	$60+4
     15  6393					      ENDIF
     16  6393				  -	      IF	$10 = $50
     17  6393				  -	      .byte	$80+4
     18  6393					      ENDIF
     19  6393				  -	      IF	$10 = $60
     20  6393				  -	      .byte	$C0+4
     21  6393					      ENDIF
     22  6393				  -	      IF	$10 = $70
     23  6393				  -	      .byte	$D0+4
     24  6393					      ENDIF
     25  6393				  -	      IF	$10 = $80
     26  6393				  -	      .byte	$B0+4
     27  6393					      ENDIF
     28  6393				  -	      IF	$10 = $90
     29  6393				  -	      .byte	$90+4
     30  6393					      ENDIF
     31  6393				  -	      IF	$10 = $A0
     32  6393				  -	      .byte	$70+4
     33  6393					      ENDIF
     34  6393				  -	      IF	$10 = $B0
     35  6393				  -	      .byte	$50+4
     36  6393					      ENDIF
     37  6393				  -	      IF	$10 = $C0
     38  6393				  -	      .byte	$30+4
     39  6393					      ENDIF
     40  6393				  -	      IF	$10 = $D0
     41  6393				  -	      .byte	$30+4
     42  6393					      ENDIF
     43  6393				  -	      IF	$10 = $E0
     44  6393				  -	      .byte	$20+4
     45  6393					      ENDIF
     46  6393				  -	      IF	$10 = $F0
     47  6393				  -	      .byte	$40+4
     48  6393					      ENDIF
      0  6393					      NTSC_TO_PAL	$10, 4
      1  6393				  -	      IF	$10 = 0
      2  6393				  -	      .byte	$10+4
      3  6393					      ENDIF
      4  6393					      IF	$10 = $10
      5  6393		       24		      .byte.b	$20+4
      6  6394					      ENDIF
      7  6394				  -	      IF	$10 = $20
      8  6394				  -	      .byte	$40+4
      9  6394					      ENDIF
     10  6394				  -	      IF	$10 = $30
     11  6394				  -	      .byte	$40+4
     12  6394					      ENDIF
     13  6394				  -	      IF	$10 = $40
     14  6394				  -	      .byte	$60+4
     15  6394					      ENDIF
     16  6394				  -	      IF	$10 = $50
     17  6394				  -	      .byte	$80+4
     18  6394					      ENDIF
     19  6394				  -	      IF	$10 = $60
     20  6394				  -	      .byte	$C0+4
     21  6394					      ENDIF
     22  6394				  -	      IF	$10 = $70
     23  6394				  -	      .byte	$D0+4
     24  6394					      ENDIF
     25  6394				  -	      IF	$10 = $80
     26  6394				  -	      .byte	$B0+4
     27  6394					      ENDIF
     28  6394				  -	      IF	$10 = $90
     29  6394				  -	      .byte	$90+4
     30  6394					      ENDIF
     31  6394				  -	      IF	$10 = $A0
     32  6394				  -	      .byte	$70+4
     33  6394					      ENDIF
     34  6394				  -	      IF	$10 = $B0
     35  6394				  -	      .byte	$50+4
     36  6394					      ENDIF
     37  6394				  -	      IF	$10 = $C0
     38  6394				  -	      .byte	$30+4
     39  6394					      ENDIF
     40  6394				  -	      IF	$10 = $D0
     41  6394				  -	      .byte	$30+4
     42  6394					      ENDIF
     43  6394				  -	      IF	$10 = $E0
     44  6394				  -	      .byte	$20+4
     45  6394					      ENDIF
     46  6394				  -	      IF	$10 = $F0
     47  6394				  -	      .byte	$40+4
     48  6394					      ENDIF
      0  6394					      NTSC_TO_PAL	$90, 4
      1  6394				  -	      IF	$90 = 0
      2  6394				  -	      .byte	$90+4
      3  6394					      ENDIF
      4  6394				  -	      IF	$90 = $10
      5  6394				  -	      .byte	$20+4
      6  6394					      ENDIF
      7  6394				  -	      IF	$90 = $20
      8  6394				  -	      .byte	$40+4
      9  6394					      ENDIF
     10  6394				  -	      IF	$90 = $30
     11  6394				  -	      .byte	$40+4
     12  6394					      ENDIF
     13  6394				  -	      IF	$90 = $40
     14  6394				  -	      .byte	$60+4
     15  6394					      ENDIF
     16  6394				  -	      IF	$90 = $50
     17  6394				  -	      .byte	$80+4
     18  6394					      ENDIF
     19  6394				  -	      IF	$90 = $60
     20  6394				  -	      .byte	$C0+4
     21  6394					      ENDIF
     22  6394				  -	      IF	$90 = $70
     23  6394				  -	      .byte	$D0+4
     24  6394					      ENDIF
     25  6394				  -	      IF	$90 = $80
     26  6394				  -	      .byte	$B0+4
     27  6394					      ENDIF
     28  6394					      IF	$90 = $90
     29  6394		       94		      .byte.b	$90+4
     30  6395					      ENDIF
     31  6395				  -	      IF	$90 = $A0
     32  6395				  -	      .byte	$70+4
     33  6395					      ENDIF
     34  6395				  -	      IF	$90 = $B0
     35  6395				  -	      .byte	$50+4
     36  6395					      ENDIF
     37  6395				  -	      IF	$90 = $C0
     38  6395				  -	      .byte	$30+4
     39  6395					      ENDIF
     40  6395				  -	      IF	$90 = $D0
     41  6395				  -	      .byte	$30+4
     42  6395					      ENDIF
     43  6395				  -	      IF	$90 = $E0
     44  6395				  -	      .byte	$20+4
     45  6395					      ENDIF
     46  6395				  -	      IF	$90 = $F0
     47  6395				  -	      .byte	$40+4
     48  6395					      ENDIF
      0  6395					      NTSC_TO_PAL	$90, 4
      1  6395				  -	      IF	$90 = 0
      2  6395				  -	      .byte	$90+4
      3  6395					      ENDIF
      4  6395				  -	      IF	$90 = $10
      5  6395				  -	      .byte	$20+4
      6  6395					      ENDIF
      7  6395				  -	      IF	$90 = $20
      8  6395				  -	      .byte	$40+4
      9  6395					      ENDIF
     10  6395				  -	      IF	$90 = $30
     11  6395				  -	      .byte	$40+4
     12  6395					      ENDIF
     13  6395				  -	      IF	$90 = $40
     14  6395				  -	      .byte	$60+4
     15  6395					      ENDIF
     16  6395				  -	      IF	$90 = $50
     17  6395				  -	      .byte	$80+4
     18  6395					      ENDIF
     19  6395				  -	      IF	$90 = $60
     20  6395				  -	      .byte	$C0+4
     21  6395					      ENDIF
     22  6395				  -	      IF	$90 = $70
     23  6395				  -	      .byte	$D0+4
     24  6395					      ENDIF
     25  6395				  -	      IF	$90 = $80
     26  6395				  -	      .byte	$B0+4
     27  6395					      ENDIF
     28  6395					      IF	$90 = $90
     29  6395		       94		      .byte.b	$90+4
     30  6396					      ENDIF
     31  6396				  -	      IF	$90 = $A0
     32  6396				  -	      .byte	$70+4
     33  6396					      ENDIF
     34  6396				  -	      IF	$90 = $B0
     35  6396				  -	      .byte	$50+4
     36  6396					      ENDIF
     37  6396				  -	      IF	$90 = $C0
     38  6396				  -	      .byte	$30+4
     39  6396					      ENDIF
     40  6396				  -	      IF	$90 = $D0
     41  6396				  -	      .byte	$30+4
     42  6396					      ENDIF
     43  6396				  -	      IF	$90 = $E0
     44  6396				  -	      .byte	$20+4
     45  6396					      ENDIF
     46  6396				  -	      IF	$90 = $F0
     47  6396				  -	      .byte	$40+4
     48  6396					      ENDIF
      0  6396					      NTSC_TO_PAL	$90, 4
      1  6396				  -	      IF	$90 = 0
      2  6396				  -	      .byte	$90+4
      3  6396					      ENDIF
      4  6396				  -	      IF	$90 = $10
      5  6396				  -	      .byte	$20+4
      6  6396					      ENDIF
      7  6396				  -	      IF	$90 = $20
      8  6396				  -	      .byte	$40+4
      9  6396					      ENDIF
     10  6396				  -	      IF	$90 = $30
     11  6396				  -	      .byte	$40+4
     12  6396					      ENDIF
     13  6396				  -	      IF	$90 = $40
     14  6396				  -	      .byte	$60+4
     15  6396					      ENDIF
     16  6396				  -	      IF	$90 = $50
     17  6396				  -	      .byte	$80+4
     18  6396					      ENDIF
     19  6396				  -	      IF	$90 = $60
     20  6396				  -	      .byte	$C0+4
     21  6396					      ENDIF
     22  6396				  -	      IF	$90 = $70
     23  6396				  -	      .byte	$D0+4
     24  6396					      ENDIF
     25  6396				  -	      IF	$90 = $80
     26  6396				  -	      .byte	$B0+4
     27  6396					      ENDIF
     28  6396					      IF	$90 = $90
     29  6396		       94		      .byte.b	$90+4
     30  6397					      ENDIF
     31  6397				  -	      IF	$90 = $A0
     32  6397				  -	      .byte	$70+4
     33  6397					      ENDIF
     34  6397				  -	      IF	$90 = $B0
     35  6397				  -	      .byte	$50+4
     36  6397					      ENDIF
     37  6397				  -	      IF	$90 = $C0
     38  6397				  -	      .byte	$30+4
     39  6397					      ENDIF
     40  6397				  -	      IF	$90 = $D0
     41  6397				  -	      .byte	$30+4
     42  6397					      ENDIF
     43  6397				  -	      IF	$90 = $E0
     44  6397				  -	      .byte	$20+4
     45  6397					      ENDIF
     46  6397				  -	      IF	$90 = $F0
     47  6397				  -	      .byte	$40+4
     48  6397					      ENDIF
      0  6397					      NTSC_TO_PAL	$90, 4
      1  6397				  -	      IF	$90 = 0
      2  6397				  -	      .byte	$90+4
      3  6397					      ENDIF
      4  6397				  -	      IF	$90 = $10
      5  6397				  -	      .byte	$20+4
      6  6397					      ENDIF
      7  6397				  -	      IF	$90 = $20
      8  6397				  -	      .byte	$40+4
      9  6397					      ENDIF
     10  6397				  -	      IF	$90 = $30
     11  6397				  -	      .byte	$40+4
     12  6397					      ENDIF
     13  6397				  -	      IF	$90 = $40
     14  6397				  -	      .byte	$60+4
     15  6397					      ENDIF
     16  6397				  -	      IF	$90 = $50
     17  6397				  -	      .byte	$80+4
     18  6397					      ENDIF
     19  6397				  -	      IF	$90 = $60
     20  6397				  -	      .byte	$C0+4
     21  6397					      ENDIF
     22  6397				  -	      IF	$90 = $70
     23  6397				  -	      .byte	$D0+4
     24  6397					      ENDIF
     25  6397				  -	      IF	$90 = $80
     26  6397				  -	      .byte	$B0+4
     27  6397					      ENDIF
     28  6397					      IF	$90 = $90
     29  6397		       94		      .byte.b	$90+4
     30  6398					      ENDIF
     31  6398				  -	      IF	$90 = $A0
     32  6398				  -	      .byte	$70+4
     33  6398					      ENDIF
     34  6398				  -	      IF	$90 = $B0
     35  6398				  -	      .byte	$50+4
     36  6398					      ENDIF
     37  6398				  -	      IF	$90 = $C0
     38  6398				  -	      .byte	$30+4
     39  6398					      ENDIF
     40  6398				  -	      IF	$90 = $D0
     41  6398				  -	      .byte	$30+4
     42  6398					      ENDIF
     43  6398				  -	      IF	$90 = $E0
     44  6398				  -	      .byte	$20+4
     45  6398					      ENDIF
     46  6398				  -	      IF	$90 = $F0
     47  6398				  -	      .byte	$40+4
     48  6398					      ENDIF
      0  6398					      NTSC_TO_PAL	$90, 4
      1  6398				  -	      IF	$90 = 0
      2  6398				  -	      .byte	$90+4
      3  6398					      ENDIF
      4  6398				  -	      IF	$90 = $10
      5  6398				  -	      .byte	$20+4
      6  6398					      ENDIF
      7  6398				  -	      IF	$90 = $20
      8  6398				  -	      .byte	$40+4
      9  6398					      ENDIF
     10  6398				  -	      IF	$90 = $30
     11  6398				  -	      .byte	$40+4
     12  6398					      ENDIF
     13  6398				  -	      IF	$90 = $40
     14  6398				  -	      .byte	$60+4
     15  6398					      ENDIF
     16  6398				  -	      IF	$90 = $50
     17  6398				  -	      .byte	$80+4
     18  6398					      ENDIF
     19  6398				  -	      IF	$90 = $60
     20  6398				  -	      .byte	$C0+4
     21  6398					      ENDIF
     22  6398				  -	      IF	$90 = $70
     23  6398				  -	      .byte	$D0+4
     24  6398					      ENDIF
     25  6398				  -	      IF	$90 = $80
     26  6398				  -	      .byte	$B0+4
     27  6398					      ENDIF
     28  6398					      IF	$90 = $90
     29  6398		       94		      .byte.b	$90+4
     30  6399					      ENDIF
     31  6399				  -	      IF	$90 = $A0
     32  6399				  -	      .byte	$70+4
     33  6399					      ENDIF
     34  6399				  -	      IF	$90 = $B0
     35  6399				  -	      .byte	$50+4
     36  6399					      ENDIF
     37  6399				  -	      IF	$90 = $C0
     38  6399				  -	      .byte	$30+4
     39  6399					      ENDIF
     40  6399				  -	      IF	$90 = $D0
     41  6399				  -	      .byte	$30+4
     42  6399					      ENDIF
     43  6399				  -	      IF	$90 = $E0
     44  6399				  -	      .byte	$20+4
     45  6399					      ENDIF
     46  6399				  -	      IF	$90 = $F0
     47  6399				  -	      .byte	$40+4
     48  6399					      ENDIF
      0  6399					      NTSC_TO_PAL	$90, 4
      1  6399				  -	      IF	$90 = 0
      2  6399				  -	      .byte	$90+4
      3  6399					      ENDIF
      4  6399				  -	      IF	$90 = $10
      5  6399				  -	      .byte	$20+4
      6  6399					      ENDIF
      7  6399				  -	      IF	$90 = $20
      8  6399				  -	      .byte	$40+4
      9  6399					      ENDIF
     10  6399				  -	      IF	$90 = $30
     11  6399				  -	      .byte	$40+4
     12  6399					      ENDIF
     13  6399				  -	      IF	$90 = $40
     14  6399				  -	      .byte	$60+4
     15  6399					      ENDIF
     16  6399				  -	      IF	$90 = $50
     17  6399				  -	      .byte	$80+4
     18  6399					      ENDIF
     19  6399				  -	      IF	$90 = $60
     20  6399				  -	      .byte	$C0+4
     21  6399					      ENDIF
     22  6399				  -	      IF	$90 = $70
     23  6399				  -	      .byte	$D0+4
     24  6399					      ENDIF
     25  6399				  -	      IF	$90 = $80
     26  6399				  -	      .byte	$B0+4
     27  6399					      ENDIF
     28  6399					      IF	$90 = $90
     29  6399		       94		      .byte.b	$90+4
     30  639a					      ENDIF
     31  639a				  -	      IF	$90 = $A0
     32  639a				  -	      .byte	$70+4
     33  639a					      ENDIF
     34  639a				  -	      IF	$90 = $B0
     35  639a				  -	      .byte	$50+4
     36  639a					      ENDIF
     37  639a				  -	      IF	$90 = $C0
     38  639a				  -	      .byte	$30+4
     39  639a					      ENDIF
     40  639a				  -	      IF	$90 = $D0
     41  639a				  -	      .byte	$30+4
     42  639a					      ENDIF
     43  639a				  -	      IF	$90 = $E0
     44  639a				  -	      .byte	$20+4
     45  639a					      ENDIF
     46  639a				  -	      IF	$90 = $F0
     47  639a				  -	      .byte	$40+4
     48  639a					      ENDIF
      0  639a					      NTSC_TO_PAL	$30, 4
      1  639a				  -	      IF	$30 = 0
      2  639a				  -	      .byte	$30+4
      3  639a					      ENDIF
      4  639a				  -	      IF	$30 = $10
      5  639a				  -	      .byte	$20+4
      6  639a					      ENDIF
      7  639a				  -	      IF	$30 = $20
      8  639a				  -	      .byte	$40+4
      9  639a					      ENDIF
     10  639a					      IF	$30 = $30
     11  639a		       44		      .byte.b	$40+4
     12  639b					      ENDIF
     13  639b				  -	      IF	$30 = $40
     14  639b				  -	      .byte	$60+4
     15  639b					      ENDIF
     16  639b				  -	      IF	$30 = $50
     17  639b				  -	      .byte	$80+4
     18  639b					      ENDIF
     19  639b				  -	      IF	$30 = $60
     20  639b				  -	      .byte	$C0+4
     21  639b					      ENDIF
     22  639b				  -	      IF	$30 = $70
     23  639b				  -	      .byte	$D0+4
     24  639b					      ENDIF
     25  639b				  -	      IF	$30 = $80
     26  639b				  -	      .byte	$B0+4
     27  639b					      ENDIF
     28  639b				  -	      IF	$30 = $90
     29  639b				  -	      .byte	$90+4
     30  639b					      ENDIF
     31  639b				  -	      IF	$30 = $A0
     32  639b				  -	      .byte	$70+4
     33  639b					      ENDIF
     34  639b				  -	      IF	$30 = $B0
     35  639b				  -	      .byte	$50+4
     36  639b					      ENDIF
     37  639b				  -	      IF	$30 = $C0
     38  639b				  -	      .byte	$30+4
     39  639b					      ENDIF
     40  639b				  -	      IF	$30 = $D0
     41  639b				  -	      .byte	$30+4
     42  639b					      ENDIF
     43  639b				  -	      IF	$30 = $E0
     44  639b				  -	      .byte	$20+4
     45  639b					      ENDIF
     46  639b				  -	      IF	$30 = $F0
     47  639b				  -	      .byte	$40+4
     48  639b					      ENDIF
      0  639b					      NTSC_TO_PAL	$0,12
      1  639b					      IF	$0 = 0
      2  639b		       0c		      .byte.b	$0+12
      3  639c					      ENDIF
      4  639c				  -	      IF	$0 = $10
      5  639c				  -	      .byte	$20+12
      6  639c					      ENDIF
      7  639c				  -	      IF	$0 = $20
      8  639c				  -	      .byte	$40+12
      9  639c					      ENDIF
     10  639c				  -	      IF	$0 = $30
     11  639c				  -	      .byte	$40+12
     12  639c					      ENDIF
     13  639c				  -	      IF	$0 = $40
     14  639c				  -	      .byte	$60+12
     15  639c					      ENDIF
     16  639c				  -	      IF	$0 = $50
     17  639c				  -	      .byte	$80+12
     18  639c					      ENDIF
     19  639c				  -	      IF	$0 = $60
     20  639c				  -	      .byte	$C0+12
     21  639c					      ENDIF
     22  639c				  -	      IF	$0 = $70
     23  639c				  -	      .byte	$D0+12
     24  639c					      ENDIF
     25  639c				  -	      IF	$0 = $80
     26  639c				  -	      .byte	$B0+12
     27  639c					      ENDIF
     28  639c				  -	      IF	$0 = $90
     29  639c				  -	      .byte	$90+12
     30  639c					      ENDIF
     31  639c				  -	      IF	$0 = $A0
     32  639c				  -	      .byte	$70+12
     33  639c					      ENDIF
     34  639c				  -	      IF	$0 = $B0
     35  639c				  -	      .byte	$50+12
     36  639c					      ENDIF
     37  639c				  -	      IF	$0 = $C0
     38  639c				  -	      .byte	$30+12
     39  639c					      ENDIF
     40  639c				  -	      IF	$0 = $D0
     41  639c				  -	      .byte	$30+12
     42  639c					      ENDIF
     43  639c				  -	      IF	$0 = $E0
     44  639c				  -	      .byte	$20+12
     45  639c					      ENDIF
     46  639c				  -	      IF	$0 = $F0
     47  639c				  -	      .byte	$40+12
     48  639c					      ENDIF
      0  639c					      NTSC_TO_PAL	$90, 6
      1  639c				  -	      IF	$90 = 0
      2  639c				  -	      .byte	$90+6
      3  639c					      ENDIF
      4  639c				  -	      IF	$90 = $10
      5  639c				  -	      .byte	$20+6
      6  639c					      ENDIF
      7  639c				  -	      IF	$90 = $20
      8  639c				  -	      .byte	$40+6
      9  639c					      ENDIF
     10  639c				  -	      IF	$90 = $30
     11  639c				  -	      .byte	$40+6
     12  639c					      ENDIF
     13  639c				  -	      IF	$90 = $40
     14  639c				  -	      .byte	$60+6
     15  639c					      ENDIF
     16  639c				  -	      IF	$90 = $50
     17  639c				  -	      .byte	$80+6
     18  639c					      ENDIF
     19  639c				  -	      IF	$90 = $60
     20  639c				  -	      .byte	$C0+6
     21  639c					      ENDIF
     22  639c				  -	      IF	$90 = $70
     23  639c				  -	      .byte	$D0+6
     24  639c					      ENDIF
     25  639c				  -	      IF	$90 = $80
     26  639c				  -	      .byte	$B0+6
     27  639c					      ENDIF
     28  639c					      IF	$90 = $90
     29  639c		       96		      .byte.b	$90+6
     30  639d					      ENDIF
     31  639d				  -	      IF	$90 = $A0
     32  639d				  -	      .byte	$70+6
     33  639d					      ENDIF
     34  639d				  -	      IF	$90 = $B0
     35  639d				  -	      .byte	$50+6
     36  639d					      ENDIF
     37  639d				  -	      IF	$90 = $C0
     38  639d				  -	      .byte	$30+6
     39  639d					      ENDIF
     40  639d				  -	      IF	$90 = $D0
     41  639d				  -	      .byte	$30+6
     42  639d					      ENDIF
     43  639d				  -	      IF	$90 = $E0
     44  639d				  -	      .byte	$20+6
     45  639d					      ENDIF
     46  639d				  -	      IF	$90 = $F0
     47  639d				  -	      .byte	$40+6
     48  639d					      ENDIF
      0  639d					      NTSC_TO_PAL	$90, 6
      1  639d				  -	      IF	$90 = 0
      2  639d				  -	      .byte	$90+6
      3  639d					      ENDIF
      4  639d				  -	      IF	$90 = $10
      5  639d				  -	      .byte	$20+6
      6  639d					      ENDIF
      7  639d				  -	      IF	$90 = $20
      8  639d				  -	      .byte	$40+6
      9  639d					      ENDIF
     10  639d				  -	      IF	$90 = $30
     11  639d				  -	      .byte	$40+6
     12  639d					      ENDIF
     13  639d				  -	      IF	$90 = $40
     14  639d				  -	      .byte	$60+6
     15  639d					      ENDIF
     16  639d				  -	      IF	$90 = $50
     17  639d				  -	      .byte	$80+6
     18  639d					      ENDIF
     19  639d				  -	      IF	$90 = $60
     20  639d				  -	      .byte	$C0+6
     21  639d					      ENDIF
     22  639d				  -	      IF	$90 = $70
     23  639d				  -	      .byte	$D0+6
     24  639d					      ENDIF
     25  639d				  -	      IF	$90 = $80
     26  639d				  -	      .byte	$B0+6
     27  639d					      ENDIF
     28  639d					      IF	$90 = $90
     29  639d		       96		      .byte.b	$90+6
     30  639e					      ENDIF
     31  639e				  -	      IF	$90 = $A0
     32  639e				  -	      .byte	$70+6
     33  639e					      ENDIF
     34  639e				  -	      IF	$90 = $B0
     35  639e				  -	      .byte	$50+6
     36  639e					      ENDIF
     37  639e				  -	      IF	$90 = $C0
     38  639e				  -	      .byte	$30+6
     39  639e					      ENDIF
     40  639e				  -	      IF	$90 = $D0
     41  639e				  -	      .byte	$30+6
     42  639e					      ENDIF
     43  639e				  -	      IF	$90 = $E0
     44  639e				  -	      .byte	$20+6
     45  639e					      ENDIF
     46  639e				  -	      IF	$90 = $F0
     47  639e				  -	      .byte	$40+6
     48  639e					      ENDIF
      0  639e					      NTSC_TO_PAL	$90, 6
      1  639e				  -	      IF	$90 = 0
      2  639e				  -	      .byte	$90+6
      3  639e					      ENDIF
      4  639e				  -	      IF	$90 = $10
      5  639e				  -	      .byte	$20+6
      6  639e					      ENDIF
      7  639e				  -	      IF	$90 = $20
      8  639e				  -	      .byte	$40+6
      9  639e					      ENDIF
     10  639e				  -	      IF	$90 = $30
     11  639e				  -	      .byte	$40+6
     12  639e					      ENDIF
     13  639e				  -	      IF	$90 = $40
     14  639e				  -	      .byte	$60+6
     15  639e					      ENDIF
     16  639e				  -	      IF	$90 = $50
     17  639e				  -	      .byte	$80+6
     18  639e					      ENDIF
     19  639e				  -	      IF	$90 = $60
     20  639e				  -	      .byte	$C0+6
     21  639e					      ENDIF
     22  639e				  -	      IF	$90 = $70
     23  639e				  -	      .byte	$D0+6
     24  639e					      ENDIF
     25  639e				  -	      IF	$90 = $80
     26  639e				  -	      .byte	$B0+6
     27  639e					      ENDIF
     28  639e					      IF	$90 = $90
     29  639e		       96		      .byte.b	$90+6
     30  639f					      ENDIF
     31  639f				  -	      IF	$90 = $A0
     32  639f				  -	      .byte	$70+6
     33  639f					      ENDIF
     34  639f				  -	      IF	$90 = $B0
     35  639f				  -	      .byte	$50+6
     36  639f					      ENDIF
     37  639f				  -	      IF	$90 = $C0
     38  639f				  -	      .byte	$30+6
     39  639f					      ENDIF
     40  639f				  -	      IF	$90 = $D0
     41  639f				  -	      .byte	$30+6
     42  639f					      ENDIF
     43  639f				  -	      IF	$90 = $E0
     44  639f				  -	      .byte	$20+6
     45  639f					      ENDIF
     46  639f				  -	      IF	$90 = $F0
     47  639f				  -	      .byte	$40+6
     48  639f					      ENDIF
      0  639f					      NTSC_TO_PAL	$90, 6
      1  639f				  -	      IF	$90 = 0
      2  639f				  -	      .byte	$90+6
      3  639f					      ENDIF
      4  639f				  -	      IF	$90 = $10
      5  639f				  -	      .byte	$20+6
      6  639f					      ENDIF
      7  639f				  -	      IF	$90 = $20
      8  639f				  -	      .byte	$40+6
      9  639f					      ENDIF
     10  639f				  -	      IF	$90 = $30
     11  639f				  -	      .byte	$40+6
     12  639f					      ENDIF
     13  639f				  -	      IF	$90 = $40
     14  639f				  -	      .byte	$60+6
     15  639f					      ENDIF
     16  639f				  -	      IF	$90 = $50
     17  639f				  -	      .byte	$80+6
     18  639f					      ENDIF
     19  639f				  -	      IF	$90 = $60
     20  639f				  -	      .byte	$C0+6
     21  639f					      ENDIF
     22  639f				  -	      IF	$90 = $70
     23  639f				  -	      .byte	$D0+6
     24  639f					      ENDIF
     25  639f				  -	      IF	$90 = $80
     26  639f				  -	      .byte	$B0+6
     27  639f					      ENDIF
     28  639f					      IF	$90 = $90
     29  639f		       96		      .byte.b	$90+6
     30  63a0					      ENDIF
     31  63a0				  -	      IF	$90 = $A0
     32  63a0				  -	      .byte	$70+6
     33  63a0					      ENDIF
     34  63a0				  -	      IF	$90 = $B0
     35  63a0				  -	      .byte	$50+6
     36  63a0					      ENDIF
     37  63a0				  -	      IF	$90 = $C0
     38  63a0				  -	      .byte	$30+6
     39  63a0					      ENDIF
     40  63a0				  -	      IF	$90 = $D0
     41  63a0				  -	      .byte	$30+6
     42  63a0					      ENDIF
     43  63a0				  -	      IF	$90 = $E0
     44  63a0				  -	      .byte	$20+6
     45  63a0					      ENDIF
     46  63a0				  -	      IF	$90 = $F0
     47  63a0				  -	      .byte	$40+6
     48  63a0					      ENDIF
      0  63a0					      NTSC_TO_PAL	$90, 6
      1  63a0				  -	      IF	$90 = 0
      2  63a0				  -	      .byte	$90+6
      3  63a0					      ENDIF
      4  63a0				  -	      IF	$90 = $10
      5  63a0				  -	      .byte	$20+6
      6  63a0					      ENDIF
      7  63a0				  -	      IF	$90 = $20
      8  63a0				  -	      .byte	$40+6
      9  63a0					      ENDIF
     10  63a0				  -	      IF	$90 = $30
     11  63a0				  -	      .byte	$40+6
     12  63a0					      ENDIF
     13  63a0				  -	      IF	$90 = $40
     14  63a0				  -	      .byte	$60+6
     15  63a0					      ENDIF
     16  63a0				  -	      IF	$90 = $50
     17  63a0				  -	      .byte	$80+6
     18  63a0					      ENDIF
     19  63a0				  -	      IF	$90 = $60
     20  63a0				  -	      .byte	$C0+6
     21  63a0					      ENDIF
     22  63a0				  -	      IF	$90 = $70
     23  63a0				  -	      .byte	$D0+6
     24  63a0					      ENDIF
     25  63a0				  -	      IF	$90 = $80
     26  63a0				  -	      .byte	$B0+6
     27  63a0					      ENDIF
     28  63a0					      IF	$90 = $90
     29  63a0		       96		      .byte.b	$90+6
     30  63a1					      ENDIF
     31  63a1				  -	      IF	$90 = $A0
     32  63a1				  -	      .byte	$70+6
     33  63a1					      ENDIF
     34  63a1				  -	      IF	$90 = $B0
     35  63a1				  -	      .byte	$50+6
     36  63a1					      ENDIF
     37  63a1				  -	      IF	$90 = $C0
     38  63a1				  -	      .byte	$30+6
     39  63a1					      ENDIF
     40  63a1				  -	      IF	$90 = $D0
     41  63a1				  -	      .byte	$30+6
     42  63a1					      ENDIF
     43  63a1				  -	      IF	$90 = $E0
     44  63a1				  -	      .byte	$20+6
     45  63a1					      ENDIF
     46  63a1				  -	      IF	$90 = $F0
     47  63a1				  -	      .byte	$40+6
     48  63a1					      ENDIF
      0  63a1					      NTSC_TO_PAL	$0, 12
      1  63a1					      IF	$0 = 0
      2  63a1		       0c		      .byte.b	$0+12
      3  63a2					      ENDIF
      4  63a2				  -	      IF	$0 = $10
      5  63a2				  -	      .byte	$20+12
      6  63a2					      ENDIF
      7  63a2				  -	      IF	$0 = $20
      8  63a2				  -	      .byte	$40+12
      9  63a2					      ENDIF
     10  63a2				  -	      IF	$0 = $30
     11  63a2				  -	      .byte	$40+12
     12  63a2					      ENDIF
     13  63a2				  -	      IF	$0 = $40
     14  63a2				  -	      .byte	$60+12
     15  63a2					      ENDIF
     16  63a2				  -	      IF	$0 = $50
     17  63a2				  -	      .byte	$80+12
     18  63a2					      ENDIF
     19  63a2				  -	      IF	$0 = $60
     20  63a2				  -	      .byte	$C0+12
     21  63a2					      ENDIF
     22  63a2				  -	      IF	$0 = $70
     23  63a2				  -	      .byte	$D0+12
     24  63a2					      ENDIF
     25  63a2				  -	      IF	$0 = $80
     26  63a2				  -	      .byte	$B0+12
     27  63a2					      ENDIF
     28  63a2				  -	      IF	$0 = $90
     29  63a2				  -	      .byte	$90+12
     30  63a2					      ENDIF
     31  63a2				  -	      IF	$0 = $A0
     32  63a2				  -	      .byte	$70+12
     33  63a2					      ENDIF
     34  63a2				  -	      IF	$0 = $B0
     35  63a2				  -	      .byte	$50+12
     36  63a2					      ENDIF
     37  63a2				  -	      IF	$0 = $C0
     38  63a2				  -	      .byte	$30+12
     39  63a2					      ENDIF
     40  63a2				  -	      IF	$0 = $D0
     41  63a2				  -	      .byte	$30+12
     42  63a2					      ENDIF
     43  63a2				  -	      IF	$0 = $E0
     44  63a2				  -	      .byte	$20+12
     45  63a2					      ENDIF
     46  63a2				  -	      IF	$0 = $F0
     47  63a2				  -	      .byte	$40+12
     48  63a2					      ENDIF
      0  63a2					      NTSC_TO_PAL	$30, 8
      1  63a2				  -	      IF	$30 = 0
      2  63a2				  -	      .byte	$30+8
      3  63a2					      ENDIF
      4  63a2				  -	      IF	$30 = $10
      5  63a2				  -	      .byte	$20+8
      6  63a2					      ENDIF
      7  63a2				  -	      IF	$30 = $20
      8  63a2				  -	      .byte	$40+8
      9  63a2					      ENDIF
     10  63a2					      IF	$30 = $30
     11  63a2		       48		      .byte.b	$40+8
     12  63a3					      ENDIF
     13  63a3				  -	      IF	$30 = $40
     14  63a3				  -	      .byte	$60+8
     15  63a3					      ENDIF
     16  63a3				  -	      IF	$30 = $50
     17  63a3				  -	      .byte	$80+8
     18  63a3					      ENDIF
     19  63a3				  -	      IF	$30 = $60
     20  63a3				  -	      .byte	$C0+8
     21  63a3					      ENDIF
     22  63a3				  -	      IF	$30 = $70
     23  63a3				  -	      .byte	$D0+8
     24  63a3					      ENDIF
     25  63a3				  -	      IF	$30 = $80
     26  63a3				  -	      .byte	$B0+8
     27  63a3					      ENDIF
     28  63a3				  -	      IF	$30 = $90
     29  63a3				  -	      .byte	$90+8
     30  63a3					      ENDIF
     31  63a3				  -	      IF	$30 = $A0
     32  63a3				  -	      .byte	$70+8
     33  63a3					      ENDIF
     34  63a3				  -	      IF	$30 = $B0
     35  63a3				  -	      .byte	$50+8
     36  63a3					      ENDIF
     37  63a3				  -	      IF	$30 = $C0
     38  63a3				  -	      .byte	$30+8
     39  63a3					      ENDIF
     40  63a3				  -	      IF	$30 = $D0
     41  63a3				  -	      .byte	$30+8
     42  63a3					      ENDIF
     43  63a3				  -	      IF	$30 = $E0
     44  63a3				  -	      .byte	$20+8
     45  63a3					      ENDIF
     46  63a3				  -	      IF	$30 = $F0
     47  63a3				  -	      .byte	$40+8
     48  63a3					      ENDIF
      0  63a3					      NTSC_TO_PAL	$30, 8
      1  63a3				  -	      IF	$30 = 0
      2  63a3				  -	      .byte	$30+8
      3  63a3					      ENDIF
      4  63a3				  -	      IF	$30 = $10
      5  63a3				  -	      .byte	$20+8
      6  63a3					      ENDIF
      7  63a3				  -	      IF	$30 = $20
      8  63a3				  -	      .byte	$40+8
      9  63a3					      ENDIF
     10  63a3					      IF	$30 = $30
     11  63a3		       48		      .byte.b	$40+8
     12  63a4					      ENDIF
     13  63a4				  -	      IF	$30 = $40
     14  63a4				  -	      .byte	$60+8
     15  63a4					      ENDIF
     16  63a4				  -	      IF	$30 = $50
     17  63a4				  -	      .byte	$80+8
     18  63a4					      ENDIF
     19  63a4				  -	      IF	$30 = $60
     20  63a4				  -	      .byte	$C0+8
     21  63a4					      ENDIF
     22  63a4				  -	      IF	$30 = $70
     23  63a4				  -	      .byte	$D0+8
     24  63a4					      ENDIF
     25  63a4				  -	      IF	$30 = $80
     26  63a4				  -	      .byte	$B0+8
     27  63a4					      ENDIF
     28  63a4				  -	      IF	$30 = $90
     29  63a4				  -	      .byte	$90+8
     30  63a4					      ENDIF
     31  63a4				  -	      IF	$30 = $A0
     32  63a4				  -	      .byte	$70+8
     33  63a4					      ENDIF
     34  63a4				  -	      IF	$30 = $B0
     35  63a4				  -	      .byte	$50+8
     36  63a4					      ENDIF
     37  63a4				  -	      IF	$30 = $C0
     38  63a4				  -	      .byte	$30+8
     39  63a4					      ENDIF
     40  63a4				  -	      IF	$30 = $D0
     41  63a4				  -	      .byte	$30+8
     42  63a4					      ENDIF
     43  63a4				  -	      IF	$30 = $E0
     44  63a4				  -	      .byte	$20+8
     45  63a4					      ENDIF
     46  63a4				  -	      IF	$30 = $F0
     47  63a4				  -	      .byte	$40+8
     48  63a4					      ENDIF
      0  63a4					      NTSC_TO_PAL	$30, 8
      1  63a4				  -	      IF	$30 = 0
      2  63a4				  -	      .byte	$30+8
      3  63a4					      ENDIF
      4  63a4				  -	      IF	$30 = $10
      5  63a4				  -	      .byte	$20+8
      6  63a4					      ENDIF
      7  63a4				  -	      IF	$30 = $20
      8  63a4				  -	      .byte	$40+8
      9  63a4					      ENDIF
     10  63a4					      IF	$30 = $30
     11  63a4		       48		      .byte.b	$40+8
     12  63a5					      ENDIF
     13  63a5				  -	      IF	$30 = $40
     14  63a5				  -	      .byte	$60+8
     15  63a5					      ENDIF
     16  63a5				  -	      IF	$30 = $50
     17  63a5				  -	      .byte	$80+8
     18  63a5					      ENDIF
     19  63a5				  -	      IF	$30 = $60
     20  63a5				  -	      .byte	$C0+8
     21  63a5					      ENDIF
     22  63a5				  -	      IF	$30 = $70
     23  63a5				  -	      .byte	$D0+8
     24  63a5					      ENDIF
     25  63a5				  -	      IF	$30 = $80
     26  63a5				  -	      .byte	$B0+8
     27  63a5					      ENDIF
     28  63a5				  -	      IF	$30 = $90
     29  63a5				  -	      .byte	$90+8
     30  63a5					      ENDIF
     31  63a5				  -	      IF	$30 = $A0
     32  63a5				  -	      .byte	$70+8
     33  63a5					      ENDIF
     34  63a5				  -	      IF	$30 = $B0
     35  63a5				  -	      .byte	$50+8
     36  63a5					      ENDIF
     37  63a5				  -	      IF	$30 = $C0
     38  63a5				  -	      .byte	$30+8
     39  63a5					      ENDIF
     40  63a5				  -	      IF	$30 = $D0
     41  63a5				  -	      .byte	$30+8
     42  63a5					      ENDIF
     43  63a5				  -	      IF	$30 = $E0
     44  63a5				  -	      .byte	$20+8
     45  63a5					      ENDIF
     46  63a5				  -	      IF	$30 = $F0
     47  63a5				  -	      .byte	$40+8
     48  63a5					      ENDIF
      0  63a5					      NTSC_TO_PAL	$30, 8
      1  63a5				  -	      IF	$30 = 0
      2  63a5				  -	      .byte	$30+8
      3  63a5					      ENDIF
      4  63a5				  -	      IF	$30 = $10
      5  63a5				  -	      .byte	$20+8
      6  63a5					      ENDIF
      7  63a5				  -	      IF	$30 = $20
      8  63a5				  -	      .byte	$40+8
      9  63a5					      ENDIF
     10  63a5					      IF	$30 = $30
     11  63a5		       48		      .byte.b	$40+8
     12  63a6					      ENDIF
     13  63a6				  -	      IF	$30 = $40
     14  63a6				  -	      .byte	$60+8
     15  63a6					      ENDIF
     16  63a6				  -	      IF	$30 = $50
     17  63a6				  -	      .byte	$80+8
     18  63a6					      ENDIF
     19  63a6				  -	      IF	$30 = $60
     20  63a6				  -	      .byte	$C0+8
     21  63a6					      ENDIF
     22  63a6				  -	      IF	$30 = $70
     23  63a6				  -	      .byte	$D0+8
     24  63a6					      ENDIF
     25  63a6				  -	      IF	$30 = $80
     26  63a6				  -	      .byte	$B0+8
     27  63a6					      ENDIF
     28  63a6				  -	      IF	$30 = $90
     29  63a6				  -	      .byte	$90+8
     30  63a6					      ENDIF
     31  63a6				  -	      IF	$30 = $A0
     32  63a6				  -	      .byte	$70+8
     33  63a6					      ENDIF
     34  63a6				  -	      IF	$30 = $B0
     35  63a6				  -	      .byte	$50+8
     36  63a6					      ENDIF
     37  63a6				  -	      IF	$30 = $C0
     38  63a6				  -	      .byte	$30+8
     39  63a6					      ENDIF
     40  63a6				  -	      IF	$30 = $D0
     41  63a6				  -	      .byte	$30+8
     42  63a6					      ENDIF
     43  63a6				  -	      IF	$30 = $E0
     44  63a6				  -	      .byte	$20+8
     45  63a6					      ENDIF
     46  63a6				  -	      IF	$30 = $F0
     47  63a6				  -	      .byte	$40+8
     48  63a6					      ENDIF
      0  63a6					      NTSC_TO_PAL	$30, 8
      1  63a6				  -	      IF	$30 = 0
      2  63a6				  -	      .byte	$30+8
      3  63a6					      ENDIF
      4  63a6				  -	      IF	$30 = $10
      5  63a6				  -	      .byte	$20+8
      6  63a6					      ENDIF
      7  63a6				  -	      IF	$30 = $20
      8  63a6				  -	      .byte	$40+8
      9  63a6					      ENDIF
     10  63a6					      IF	$30 = $30
     11  63a6		       48		      .byte.b	$40+8
     12  63a7					      ENDIF
     13  63a7				  -	      IF	$30 = $40
     14  63a7				  -	      .byte	$60+8
     15  63a7					      ENDIF
     16  63a7				  -	      IF	$30 = $50
     17  63a7				  -	      .byte	$80+8
     18  63a7					      ENDIF
     19  63a7				  -	      IF	$30 = $60
     20  63a7				  -	      .byte	$C0+8
     21  63a7					      ENDIF
     22  63a7				  -	      IF	$30 = $70
     23  63a7				  -	      .byte	$D0+8
     24  63a7					      ENDIF
     25  63a7				  -	      IF	$30 = $80
     26  63a7				  -	      .byte	$B0+8
     27  63a7					      ENDIF
     28  63a7				  -	      IF	$30 = $90
     29  63a7				  -	      .byte	$90+8
     30  63a7					      ENDIF
     31  63a7				  -	      IF	$30 = $A0
     32  63a7				  -	      .byte	$70+8
     33  63a7					      ENDIF
     34  63a7				  -	      IF	$30 = $B0
     35  63a7				  -	      .byte	$50+8
     36  63a7					      ENDIF
     37  63a7				  -	      IF	$30 = $C0
     38  63a7				  -	      .byte	$30+8
     39  63a7					      ENDIF
     40  63a7				  -	      IF	$30 = $D0
     41  63a7				  -	      .byte	$30+8
     42  63a7					      ENDIF
     43  63a7				  -	      IF	$30 = $E0
     44  63a7				  -	      .byte	$20+8
     45  63a7					      ENDIF
     46  63a7				  -	      IF	$30 = $F0
     47  63a7				  -	      .byte	$40+8
     48  63a7					      ENDIF
      0  63a7					      NTSC_TO_PAL	$30, 8
      1  63a7				  -	      IF	$30 = 0
      2  63a7				  -	      .byte	$30+8
      3  63a7					      ENDIF
      4  63a7				  -	      IF	$30 = $10
      5  63a7				  -	      .byte	$20+8
      6  63a7					      ENDIF
      7  63a7				  -	      IF	$30 = $20
      8  63a7				  -	      .byte	$40+8
      9  63a7					      ENDIF
     10  63a7					      IF	$30 = $30
     11  63a7		       48		      .byte.b	$40+8
     12  63a8					      ENDIF
     13  63a8				  -	      IF	$30 = $40
     14  63a8				  -	      .byte	$60+8
     15  63a8					      ENDIF
     16  63a8				  -	      IF	$30 = $50
     17  63a8				  -	      .byte	$80+8
     18  63a8					      ENDIF
     19  63a8				  -	      IF	$30 = $60
     20  63a8				  -	      .byte	$C0+8
     21  63a8					      ENDIF
     22  63a8				  -	      IF	$30 = $70
     23  63a8				  -	      .byte	$D0+8
     24  63a8					      ENDIF
     25  63a8				  -	      IF	$30 = $80
     26  63a8				  -	      .byte	$B0+8
     27  63a8					      ENDIF
     28  63a8				  -	      IF	$30 = $90
     29  63a8				  -	      .byte	$90+8
     30  63a8					      ENDIF
     31  63a8				  -	      IF	$30 = $A0
     32  63a8				  -	      .byte	$70+8
     33  63a8					      ENDIF
     34  63a8				  -	      IF	$30 = $B0
     35  63a8				  -	      .byte	$50+8
     36  63a8					      ENDIF
     37  63a8				  -	      IF	$30 = $C0
     38  63a8				  -	      .byte	$30+8
     39  63a8					      ENDIF
     40  63a8				  -	      IF	$30 = $D0
     41  63a8				  -	      .byte	$30+8
     42  63a8					      ENDIF
     43  63a8				  -	      IF	$30 = $E0
     44  63a8				  -	      .byte	$20+8
     45  63a8					      ENDIF
     46  63a8				  -	      IF	$30 = $F0
     47  63a8				  -	      .byte	$40+8
     48  63a8					      ENDIF
      0  63a8					      NTSC_TO_PAL	$10, $C
      1  63a8				  -	      IF	$10 = 0
      2  63a8				  -	      .byte	$10+$C
      3  63a8					      ENDIF
      4  63a8					      IF	$10 = $10
      5  63a8		       2c		      .byte.b	$20+$C
      6  63a9					      ENDIF
      7  63a9				  -	      IF	$10 = $20
      8  63a9				  -	      .byte	$40+$C
      9  63a9					      ENDIF
     10  63a9				  -	      IF	$10 = $30
     11  63a9				  -	      .byte	$40+$C
     12  63a9					      ENDIF
     13  63a9				  -	      IF	$10 = $40
     14  63a9				  -	      .byte	$60+$C
     15  63a9					      ENDIF
     16  63a9				  -	      IF	$10 = $50
     17  63a9				  -	      .byte	$80+$C
     18  63a9					      ENDIF
     19  63a9				  -	      IF	$10 = $60
     20  63a9				  -	      .byte	$C0+$C
     21  63a9					      ENDIF
     22  63a9				  -	      IF	$10 = $70
     23  63a9				  -	      .byte	$D0+$C
     24  63a9					      ENDIF
     25  63a9				  -	      IF	$10 = $80
     26  63a9				  -	      .byte	$B0+$C
     27  63a9					      ENDIF
     28  63a9				  -	      IF	$10 = $90
     29  63a9				  -	      .byte	$90+$C
     30  63a9					      ENDIF
     31  63a9				  -	      IF	$10 = $A0
     32  63a9				  -	      .byte	$70+$C
     33  63a9					      ENDIF
     34  63a9				  -	      IF	$10 = $B0
     35  63a9				  -	      .byte	$50+$C
     36  63a9					      ENDIF
     37  63a9				  -	      IF	$10 = $C0
     38  63a9				  -	      .byte	$30+$C
     39  63a9					      ENDIF
     40  63a9				  -	      IF	$10 = $D0
     41  63a9				  -	      .byte	$30+$C
     42  63a9					      ENDIF
     43  63a9				  -	      IF	$10 = $E0
     44  63a9				  -	      .byte	$20+$C
     45  63a9					      ENDIF
     46  63a9				  -	      IF	$10 = $F0
     47  63a9				  -	      .byte	$40+$C
     48  63a9					      ENDIF
      0  63a9					      NTSC_TO_PAL	$10, $C
      1  63a9				  -	      IF	$10 = 0
      2  63a9				  -	      .byte	$10+$C
      3  63a9					      ENDIF
      4  63a9					      IF	$10 = $10
      5  63a9		       2c		      .byte.b	$20+$C
      6  63aa					      ENDIF
      7  63aa				  -	      IF	$10 = $20
      8  63aa				  -	      .byte	$40+$C
      9  63aa					      ENDIF
     10  63aa				  -	      IF	$10 = $30
     11  63aa				  -	      .byte	$40+$C
     12  63aa					      ENDIF
     13  63aa				  -	      IF	$10 = $40
     14  63aa				  -	      .byte	$60+$C
     15  63aa					      ENDIF
     16  63aa				  -	      IF	$10 = $50
     17  63aa				  -	      .byte	$80+$C
     18  63aa					      ENDIF
     19  63aa				  -	      IF	$10 = $60
     20  63aa				  -	      .byte	$C0+$C
     21  63aa					      ENDIF
     22  63aa				  -	      IF	$10 = $70
     23  63aa				  -	      .byte	$D0+$C
     24  63aa					      ENDIF
     25  63aa				  -	      IF	$10 = $80
     26  63aa				  -	      .byte	$B0+$C
     27  63aa					      ENDIF
     28  63aa				  -	      IF	$10 = $90
     29  63aa				  -	      .byte	$90+$C
     30  63aa					      ENDIF
     31  63aa				  -	      IF	$10 = $A0
     32  63aa				  -	      .byte	$70+$C
     33  63aa					      ENDIF
     34  63aa				  -	      IF	$10 = $B0
     35  63aa				  -	      .byte	$50+$C
     36  63aa					      ENDIF
     37  63aa				  -	      IF	$10 = $C0
     38  63aa				  -	      .byte	$30+$C
     39  63aa					      ENDIF
     40  63aa				  -	      IF	$10 = $D0
     41  63aa				  -	      .byte	$30+$C
     42  63aa					      ENDIF
     43  63aa				  -	      IF	$10 = $E0
     44  63aa				  -	      .byte	$20+$C
     45  63aa					      ENDIF
     46  63aa				  -	      IF	$10 = $F0
     47  63aa				  -	      .byte	$40+$C
     48  63aa					      ENDIF
    628  63aa
    629  63aa
    630  63aa		       00 00 00 00*xJoyMoveX  .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1,0,-1,1,0
    631  63ba
    632  63ba				   VBlankTime2x
    633  63ba		       46 46		      .byte.b	70,70
    634  63bc		       62 62		      .byte.b	98,98
    635  63be				   OverscanTime2X
    636  63be		       3f 3f		      .byte.b	63, 63
    637  63c0		       4d 4d		      .byte.b	77, 77
    638  63c2
    639  63c2		       00 20	   COLOUR_LINES =	32
    640  63c2				   colvecX
    641  63c2		       00 00 20 20	      .byte.b	0, 0, COLOUR_LINES, COLOUR_LINES
    642  63c6
    643  63c6
    644  63c6							;blankDig ds COLOUR_LINES,0
    645  63c6
    646  63c6							;topcolour
    647  63c6
    648  63c6							;    .byte 0
    649  63c6
    650  63c6							;    REPEAT TOPHAT/2
    651  63c6							;    .byte $F2
    652  63c6							;    .byte $F0
    653  63c6							;    REPEND
    654  63c6
    655  63c6							;quest
    656  63c6							;    REPEAT 9
    657  63c6							;	  .byte $60,$60,$0
    658  63c6							;    REPEND
    659  63c6
    660  63c6				   LDIGIT
    661  63c6							;.word blankDig
    662  63c6		       41 f4		      .word.w	LEFT_0
    663  63c8		       a1 f4		      .word.w	LEFT_1
    664  63ca		       20 f5		      .word.w	LEFT_2
    665  63cc		       60 f5		      .word.w	LEFT_3
    666  63ce		       a0 f5		      .word.w	LEFT_4
    667  63d0		       e0 f5		      .word.w	LEFT_5
    668  63d2		       20 f6		      .word.w	LEFT_6
    669  63d4		       60 f6		      .word.w	LEFT_7
    670  63d6		       a0 f6		      .word.w	LEFT_8
    671  63d8		       e0 f6		      .word.w	LEFT_9
    672  63da
    673  63da				   RDIGIT
    674  63da							;.word blankDig
    675  63da		       61 f4		      .word.w	RIGHT_0
    676  63dc		       c1 f4		      .word.w	RIGHT_1
    677  63de		       40 f5		      .word.w	RIGHT_2
    678  63e0		       80 f5		      .word.w	RIGHT_3
    679  63e2		       c0 f5		      .word.w	RIGHT_4
    680  63e4		       00 f6		      .word.w	RIGHT_5
    681  63e6		       40 f6		      .word.w	RIGHT_6
    682  63e8		       80 f6		      .word.w	RIGHT_7
    683  63ea		       c0 f6		      .word.w	RIGHT_8
    684  63ec		       00 f7		      .word.w	RIGHT_9
    685  63ee
    686  63ee				   DIGITHUND
    687  63ee							;.word blankDig
    688  63ee		       81 f4		      .word.w	HUNDPF1_0
    689  63f0		       00 f5		      .word.w	HUNDPF1_1
    690  63f2		       60 f5		      .word.w	HUNDPF1_2
    691  63f4		       a0 f5		      .word.w	HUNDPF1_3
    692  63f6		       e0 f5		      .word.w	HUNDPF1_4
    693  63f8		       20 f6		      .word.w	HUNDPF1_5
    694  63fa		       60 f6		      .word.w	HUNDPF1_6
    695  63fc		       a0 f6		      .word.w	HUNDPF1_7
    696  63fe		       e0 f6		      .word.w	HUNDPF1_8
    697  6400		       20 f7		      .word.w	HUNDPF1_9
    698  6402							;	  .word blankDig
    699  6402
    700  6402
    701  6402				   lid0
    702  6402		       e0		      .byte.b	%11100000
    703  6403		       e0		      .byte.b	%11100000
    704  6404		       e0		      .byte.b	%11100000
    705  6405		       e0		      .byte.b	%11100000
    706  6406		       e0		      .byte.b	%11100000
    707  6407		       e0		      .byte.b	%11100000
    708  6408		       60		      .byte.b	%01100000
    709  6409		       60		      .byte.b	%01100000
    710  640a		       60		      .byte.b	%01100000
    711  640b		       60		      .byte.b	%01100000
    712  640c		       60		      .byte.b	%01100000
    713  640d		       60		      .byte.b	%01100000
    714  640e		       60		      .byte.b	%01100000
    715  640f		       e0		      .byte.b	%11100000
    716  6410		       e0		      .byte.b	%11100000
    717  6411		       e0		      .byte.b	%11100000
    718  6412		       e0		      .byte.b	%11100000
    719  6413		       e0		      .byte.b	%11100000
    720  6414
    721  6414				   lid1
    722  6414				   lid2
    723  6414		       ff		      .byte.b	%11111111
    724  6415		       ff		      .byte.b	%11111111
    725  6416		       ff		      .byte.b	%11111111
    726  6417		       ff		      .byte.b	%11111111
    727  6418		       ff		      .byte.b	%11111111
    728  6419		       ff		      .byte.b	%11111111
    729  641a		       ff		      .byte.b	%11111111
    730  641b		       ff		      .byte.b	%11111111
    731  641c		       ff		      .byte.b	%11111111
    732  641d		       f7		      .byte.b	%11110111
    733  641e		       f7		      .byte.b	%11110111
    734  641f		       f7		      .byte.b	%11110111
    735  6420		       f7		      .byte.b	%11110111
    736  6421		       ff		      .byte.b	%11111111
    737  6422		       ff		      .byte.b	%11111111
    738  6423		       ff		      .byte.b	%11111111
    739  6424		       ff		      .byte.b	%11111111
    740  6425		       c3		      .byte.b	%11000011
    741  6426
    742  6426				   lid3
    743  6426				   lid4
    744  6426		       ff		      .byte.b	%11111111
    745  6427		       ff		      .byte.b	%11111111
    746  6428		       ff		      .byte.b	%11111111
    747  6429		       ff		      .byte.b	%11111111
    748  642a		       ff		      .byte.b	%11111111
    749  642b		       ff		      .byte.b	%11111111
    750  642c		       ff		      .byte.b	%11111111
    751  642d		       ff		      .byte.b	%11111111
    752  642e		       ff		      .byte.b	%11111111
    753  642f		       f7		      .byte.b	%11110111
    754  6430		       f7		      .byte.b	%11110111
    755  6431		       f7		      .byte.b	%11110111
    756  6432		       f7		      .byte.b	%11110111
    757  6433		       ff		      .byte.b	%11111111
    758  6434		       ff		      .byte.b	%11111111
    759  6435		       ff		      .byte.b	%11111111
    760  6436		       ff		      .byte.b	%11111111
    761  6437		       c3		      .byte.b	%11000011
    762  6438
    763  6438				  -	      if	0
    764  6438				  -	      .byte	%11111111
    765  6438				  -	      .byte	%11111111
    766  6438				  -	      .byte	%11111111
    767  6438				  -	      .byte	%11111111
    768  6438				  -	      .byte	%11111111
    769  6438				  -	      .byte	%11111111
    770  6438				  -	      .byte	%11111011
    771  6438				  -	      .byte	%11111011
    772  6438				  -	      .byte	%11111011
    773  6438				  -	      .byte	%11111011
    774  6438				  -	      .byte	%11111011
    775  6438				  -	      .byte	%11111011
    776  6438				  -	      .byte	%11111011
    777  6438				  -	      .byte	%11111111
    778  6438				  -	      .byte	%11111111
    779  6438				  -	      .byte	%11111111
    780  6438				  -	      .byte	%11111111
    781  6438				  -	      .byte	%11000011
    782  6438					      endif
    783  6438
    784  6438				   lidb0
    785  6438				   lidb1
    786  6438				   lidb2
    787  6438				   lidb3
    788  6438				   lidb4
    789  6438
    790  6438		       aa		      .byte.b	%10101010
    791  6439		       ff		      .byte.b	%11111111
    792  643a		       ff		      .byte.b	%11111111
    793  643b		       ff		      .byte.b	%11111111
    794  643c		       ff		      .byte.b	%11111111
    795  643d		       ff		      .byte.b	%11111111
    796  643e		       ff		      .byte.b	%11111111
    797  643f		       ff		      .byte.b	%11111111
    798  6440		       ff		      .byte.b	%11111111
    799  6441
    800  6441
------- FILE bigDigits.asm LEVEL 3 PASS 3
      0  6441					      include	"bigDigits.asm"
      0  6441					      OPTIONAL_PAGEBREAK	"LEFT_0", 32
     10  6441					      LIST	ON
      2  6441				   LEFT_0
      3  6441		       00		      .byte.b	0
      4  6442		       00		      .byte.b	0
      5  6443		       00		      .byte.b	0
      6  6444		       38		      .byte.b	56
      7  6445		       7c		      .byte.b	124
      8  6446		       7c		      .byte.b	124
      9  6447		       fe		      .byte.b	254
     10  6448		       ee		      .byte.b	238
     11  6449		       c6		      .byte.b	198
     12  644a		       c6		      .byte.b	198
     13  644b		       c6		      .byte.b	198
     14  644c		       c6		      .byte.b	198
     15  644d		       c6		      .byte.b	198
     16  644e		       c6		      .byte.b	198
     17  644f		       c6		      .byte.b	198
     18  6450		       c6		      .byte.b	198
     19  6451		       c6		      .byte.b	198
     20  6452		       c6		      .byte.b	198
     21  6453		       c6		      .byte.b	198
     22  6454		       c6		      .byte.b	198
     23  6455		       c6		      .byte.b	198
     24  6456		       c6		      .byte.b	198
     25  6457		       c6		      .byte.b	198
     26  6458		       c6		      .byte.b	198
     27  6459		       c6		      .byte.b	198
     28  645a		       ee		      .byte.b	238
     29  645b		       fe		      .byte.b	254
     30  645c		       7c		      .byte.b	124
     31  645d		       7c		      .byte.b	124
     32  645e		       38		      .byte.b	56
     33  645f		       00		      .byte.b	0
     34  6460		       00		      .byte.b	0
      0  6461					      OPTIONAL_PAGEBREAK	"RIGHT_0", 32
     10  6461					      LIST	ON
     36  6461				   RIGHT_0
     37  6461		       00		      .byte.b	0
     38  6462		       00		      .byte.b	0
     39  6463		       00		      .byte.b	0
     40  6464		       8c		      .byte.b	140
     41  6465		       ce		      .byte.b	206
     42  6466		       ce		      .byte.b	206
     43  6467		       ef		      .byte.b	239
     44  6468		       e7		      .byte.b	231
     45  6469		       63		      .byte.b	99
     46  646a		       63		      .byte.b	99
     47  646b		       63		      .byte.b	99
     48  646c		       63		      .byte.b	99
     49  646d		       63		      .byte.b	99
     50  646e		       63		      .byte.b	99
     51  646f		       63		      .byte.b	99
     52  6470		       63		      .byte.b	99
     53  6471		       63		      .byte.b	99
     54  6472		       63		      .byte.b	99
     55  6473		       63		      .byte.b	99
     56  6474		       63		      .byte.b	99
     57  6475		       63		      .byte.b	99
     58  6476		       63		      .byte.b	99
     59  6477		       63		      .byte.b	99
     60  6478		       63		      .byte.b	99
     61  6479		       63		      .byte.b	99
     62  647a		       e7		      .byte.b	231
     63  647b		       ef		      .byte.b	239
     64  647c		       ce		      .byte.b	206
     65  647d		       ce		      .byte.b	206
     66  647e		       8c		      .byte.b	140
     67  647f		       00		      .byte.b	0
     68  6480		       00		      .byte.b	0
      0  6481					      OPTIONAL_PAGEBREAK	"HUNDPF1_0", 32
     10  6481					      LIST	ON
     70  6481				   HUNDPF1_0
     71  6481		       00		      .byte.b	0
     72  6482		       00		      .byte.b	0
     73  6483		       00		      .byte.b	0
     74  6484		       1c		      .byte.b	28
     75  6485		       3e		      .byte.b	62
     76  6486		       3e		      .byte.b	62
     77  6487		       7f		      .byte.b	127
     78  6488		       77		      .byte.b	119
     79  6489		       63		      .byte.b	99
     80  648a		       63		      .byte.b	99
     81  648b		       63		      .byte.b	99
     82  648c		       63		      .byte.b	99
     83  648d		       63		      .byte.b	99
     84  648e		       63		      .byte.b	99
     85  648f		       63		      .byte.b	99
     86  6490		       63		      .byte.b	99
     87  6491		       63		      .byte.b	99
     88  6492		       63		      .byte.b	99
     89  6493		       63		      .byte.b	99
     90  6494		       63		      .byte.b	99
     91  6495		       63		      .byte.b	99
     92  6496		       63		      .byte.b	99
     93  6497		       63		      .byte.b	99
     94  6498		       63		      .byte.b	99
     95  6499		       63		      .byte.b	99
     96  649a		       77		      .byte.b	119
     97  649b		       7f		      .byte.b	127
     98  649c		       3e		      .byte.b	62
     99  649d		       3e		      .byte.b	62
    100  649e		       1c		      .byte.b	28
    101  649f		       00		      .byte.b	0
    102  64a0		       00		      .byte.b	0
      0  64a1					      OPTIONAL_PAGEBREAK	"LEFT_1", 32
     10  64a1					      LIST	ON
    104  64a1				   LEFT_1
    105  64a1		       00		      .byte.b	0
    106  64a2		       00		      .byte.b	0
    107  64a3		       00		      .byte.b	0
    108  64a4		       30		      .byte.b	48
    109  64a5		       30		      .byte.b	48
    110  64a6		       30		      .byte.b	48
    111  64a7		       30		      .byte.b	48
    112  64a8		       30		      .byte.b	48
    113  64a9		       30		      .byte.b	48
    114  64aa		       30		      .byte.b	48
    115  64ab		       30		      .byte.b	48
    116  64ac		       30		      .byte.b	48
    117  64ad		       30		      .byte.b	48
    118  64ae		       30		      .byte.b	48
    119  64af		       30		      .byte.b	48
    120  64b0		       30		      .byte.b	48
    121  64b1		       30		      .byte.b	48
    122  64b2		       30		      .byte.b	48
    123  64b3		       30		      .byte.b	48
    124  64b4		       30		      .byte.b	48
    125  64b5		       30		      .byte.b	48
    126  64b6		       30		      .byte.b	48
    127  64b7		       30		      .byte.b	48
    128  64b8		       38		      .byte.b	56
    129  64b9		       38		      .byte.b	56
    130  64ba		       38		      .byte.b	56
    131  64bb		       38		      .byte.b	56
    132  64bc		       38		      .byte.b	56
    133  64bd		       30		      .byte.b	48
    134  64be		       30		      .byte.b	48
    135  64bf		       00		      .byte.b	0
    136  64c0		       00		      .byte.b	0
      0  64c1					      OPTIONAL_PAGEBREAK	"RIGHT_1", 32
     10  64c1					      LIST	ON
    138  64c1				   RIGHT_1
    139  64c1		       00		      .byte.b	0
    140  64c2		       00		      .byte.b	0
    141  64c3		       00		      .byte.b	0
    142  64c4		       0c		      .byte.b	12
    143  64c5		       0c		      .byte.b	12
    144  64c6		       0c		      .byte.b	12
    145  64c7		       0c		      .byte.b	12
    146  64c8		       0c		      .byte.b	12
    147  64c9		       0c		      .byte.b	12
    148  64ca		       0c		      .byte.b	12
    149  64cb		       0c		      .byte.b	12
    150  64cc		       0c		      .byte.b	12
    151  64cd		       0c		      .byte.b	12
    152  64ce		       0c		      .byte.b	12
    153  64cf		       0c		      .byte.b	12
    154  64d0		       0c		      .byte.b	12
    155  64d1		       0c		      .byte.b	12
    156  64d2		       0c		      .byte.b	12
    157  64d3		       0c		      .byte.b	12
    158  64d4		       0c		      .byte.b	12
    159  64d5		       0c		      .byte.b	12
    160  64d6		       0c		      .byte.b	12
    161  64d7		       0c		      .byte.b	12
    162  64d8		       8c		      .byte.b	140
    163  64d9		       8c		      .byte.b	140
    164  64da		       8c		      .byte.b	140
    165  64db		       8c		      .byte.b	140
    166  64dc		       8c		      .byte.b	140
    167  64dd		       0c		      .byte.b	12
    168  64de		       0c		      .byte.b	12
    169  64df		       00		      .byte.b	0
    170  64e0		       00		      .byte.b	0
      0  64e1					      OPTIONAL_PAGEBREAK	"HUNDPF1_1", 32
 PAGE BREAK INSERTED FOR  HUNDPF1_1
 REQUESTED SIZE =  $20
 WASTED SPACE =  $1f
 PAGEBREAK LOCATION =  $f500
     10  6500					      LIST	ON
    172  6500				   HUNDPF1_1
    173  6500		       00		      .byte.b	0
    174  6501		       00		      .byte.b	0
    175  6502		       00		      .byte.b	0
    176  6503		       0c		      .byte.b	12
    177  6504		       0c		      .byte.b	12
    178  6505		       0c		      .byte.b	12
    179  6506		       0c		      .byte.b	12
    180  6507		       0c		      .byte.b	12
    181  6508		       0c		      .byte.b	12
    182  6509		       0c		      .byte.b	12
    183  650a		       0c		      .byte.b	12
    184  650b		       0c		      .byte.b	12
    185  650c		       0c		      .byte.b	12
    186  650d		       0c		      .byte.b	12
    187  650e		       0c		      .byte.b	12
    188  650f		       0c		      .byte.b	12
    189  6510		       0c		      .byte.b	12
    190  6511		       0c		      .byte.b	12
    191  6512		       0c		      .byte.b	12
    192  6513		       0c		      .byte.b	12
    193  6514		       0c		      .byte.b	12
    194  6515		       0c		      .byte.b	12
    195  6516		       0c		      .byte.b	12
    196  6517		       1c		      .byte.b	28
    197  6518		       1c		      .byte.b	28
    198  6519		       1c		      .byte.b	28
    199  651a		       1c		      .byte.b	28
    200  651b		       1c		      .byte.b	28
    201  651c		       0c		      .byte.b	12
    202  651d		       0c		      .byte.b	12
    203  651e		       00		      .byte.b	0
    204  651f		       00		      .byte.b	0
      0  6520					      OPTIONAL_PAGEBREAK	"LEFT_2", 32
     10  6520					      LIST	ON
    206  6520				   LEFT_2
    207  6520		       00		      .byte.b	0
    208  6521		       00		      .byte.b	0
    209  6522		       00		      .byte.b	0
    210  6523		       fe		      .byte.b	254
    211  6524		       fe		      .byte.b	254
    212  6525		       fe		      .byte.b	254
    213  6526		       fe		      .byte.b	254
    214  6527		       c6		      .byte.b	198
    215  6528		       06		      .byte.b	6
    216  6529		       06		      .byte.b	6
    217  652a		       06		      .byte.b	6
    218  652b		       0e		      .byte.b	14
    219  652c		       0e		      .byte.b	14
    220  652d		       1c		      .byte.b	28
    221  652e		       3c		      .byte.b	60
    222  652f		       78		      .byte.b	120
    223  6530		       70		      .byte.b	112
    224  6531		       e0		      .byte.b	224
    225  6532		       e0		      .byte.b	224
    226  6533		       c0		      .byte.b	192
    227  6534		       c0		      .byte.b	192
    228  6535		       c0		      .byte.b	192
    229  6536		       c6		      .byte.b	198
    230  6537		       c6		      .byte.b	198
    231  6538		       c6		      .byte.b	198
    232  6539		       ee		      .byte.b	238
    233  653a		       fe		      .byte.b	254
    234  653b		       7c		      .byte.b	124
    235  653c		       7c		      .byte.b	124
    236  653d		       38		      .byte.b	56
    237  653e		       00		      .byte.b	0
    238  653f		       00		      .byte.b	0
      0  6540					      OPTIONAL_PAGEBREAK	"RIGHT_2", 32
     10  6540					      LIST	ON
    240  6540				   RIGHT_2
    241  6540		       00		      .byte.b	0
    242  6541		       00		      .byte.b	0
    243  6542		       00		      .byte.b	0
    244  6543		       ef		      .byte.b	239
    245  6544		       ef		      .byte.b	239
    246  6545		       ef		      .byte.b	239
    247  6546		       ef		      .byte.b	239
    248  6547		       63		      .byte.b	99
    249  6548		       60		      .byte.b	96
    250  6549		       60		      .byte.b	96
    251  654a		       60		      .byte.b	96
    252  654b		       e0		      .byte.b	224
    253  654c		       e0		      .byte.b	224
    254  654d		       c8		      .byte.b	200
    255  654e		       cc		      .byte.b	204
    256  654f		       8e		      .byte.b	142
    257  6550		       0e		      .byte.b	14
    258  6551		       07		      .byte.b	7
    259  6552		       07		      .byte.b	7
    260  6553		       03		      .byte.b	3
    261  6554		       03		      .byte.b	3
    262  6555		       03		      .byte.b	3
    263  6556		       63		      .byte.b	99
    264  6557		       63		      .byte.b	99
    265  6558		       63		      .byte.b	99
    266  6559		       e7		      .byte.b	231
    267  655a		       ef		      .byte.b	239
    268  655b		       ce		      .byte.b	206
    269  655c		       ce		      .byte.b	206
    270  655d		       8c		      .byte.b	140
    271  655e		       00		      .byte.b	0
    272  655f		       00		      .byte.b	0
      0  6560					      OPTIONAL_PAGEBREAK	"HUNDPF1_2", 0
     10  6560					      LIST	ON
    274  6560				   HUNDPF1_2
      0  6560					      OPTIONAL_PAGEBREAK	"LEFT_3", 32
     10  6560					      LIST	ON
    276  6560				   LEFT_3
    277  6560		       00		      .byte.b	0
    278  6561		       00		      .byte.b	0
    279  6562		       00		      .byte.b	0
    280  6563		       38		      .byte.b	56
    281  6564		       7c		      .byte.b	124
    282  6565		       7c		      .byte.b	124
    283  6566		       fe		      .byte.b	254
    284  6567		       ee		      .byte.b	238
    285  6568		       c6		      .byte.b	198
    286  6569		       c6		      .byte.b	198
    287  656a		       c6		      .byte.b	198
    288  656b		       c0		      .byte.b	192
    289  656c		       c0		      .byte.b	192
    290  656d		       c0		      .byte.b	192
    291  656e		       e0		      .byte.b	224
    292  656f		       f8		      .byte.b	248
    293  6570		       78		      .byte.b	120
    294  6571		       78		      .byte.b	120
    295  6572		       f8		      .byte.b	248
    296  6573		       e0		      .byte.b	224
    297  6574		       c0		      .byte.b	192
    298  6575		       c0		      .byte.b	192
    299  6576		       c6		      .byte.b	198
    300  6577		       c6		      .byte.b	198
    301  6578		       c6		      .byte.b	198
    302  6579		       ee		      .byte.b	238
    303  657a		       fe		      .byte.b	254
    304  657b		       7c		      .byte.b	124
    305  657c		       7c		      .byte.b	124
    306  657d		       38		      .byte.b	56
    307  657e		       00		      .byte.b	0
    308  657f		       00		      .byte.b	0
      0  6580					      OPTIONAL_PAGEBREAK	"RIGHT_3", 32
     10  6580					      LIST	ON
    310  6580				   RIGHT_3
    311  6580		       00		      .byte.b	0
    312  6581		       00		      .byte.b	0
    313  6582		       00		      .byte.b	0
    314  6583		       8c		      .byte.b	140
    315  6584		       ce		      .byte.b	206
    316  6585		       ce		      .byte.b	206
    317  6586		       ef		      .byte.b	239
    318  6587		       e7		      .byte.b	231
    319  6588		       63		      .byte.b	99
    320  6589		       63		      .byte.b	99
    321  658a		       63		      .byte.b	99
    322  658b		       03		      .byte.b	3
    323  658c		       03		      .byte.b	3
    324  658d		       03		      .byte.b	3
    325  658e		       07		      .byte.b	7
    326  658f		       8f		      .byte.b	143
    327  6590		       8e		      .byte.b	142
    328  6591		       8e		      .byte.b	142
    329  6592		       8f		      .byte.b	143
    330  6593		       07		      .byte.b	7
    331  6594		       03		      .byte.b	3
    332  6595		       03		      .byte.b	3
    333  6596		       63		      .byte.b	99
    334  6597		       63		      .byte.b	99
    335  6598		       63		      .byte.b	99
    336  6599		       e7		      .byte.b	231
    337  659a		       ef		      .byte.b	239
    338  659b		       ce		      .byte.b	206
    339  659c		       ce		      .byte.b	206
    340  659d		       8c		      .byte.b	140
    341  659e		       00		      .byte.b	0
    342  659f		       00		      .byte.b	0
      0  65a0					      OPTIONAL_PAGEBREAK	"HUNDPF1_3", 0
     10  65a0					      LIST	ON
    344  65a0				   HUNDPF1_3
      0  65a0					      OPTIONAL_PAGEBREAK	"LEFT_4", 32
     10  65a0					      LIST	ON
    346  65a0				   LEFT_4
    347  65a0		       00		      .byte.b	0
    348  65a1		       00		      .byte.b	0
    349  65a2		       00		      .byte.b	0
    350  65a3		       60		      .byte.b	96
    351  65a4		       60		      .byte.b	96
    352  65a5		       60		      .byte.b	96
    353  65a6		       60		      .byte.b	96
    354  65a7		       60		      .byte.b	96
    355  65a8		       fe		      .byte.b	254
    356  65a9		       fe		      .byte.b	254
    357  65aa		       fe		      .byte.b	254
    358  65ab		       fe		      .byte.b	254
    359  65ac		       66		      .byte.b	102
    360  65ad		       66		      .byte.b	102
    361  65ae		       66		      .byte.b	102
    362  65af		       66		      .byte.b	102
    363  65b0		       6c		      .byte.b	108
    364  65b1		       6c		      .byte.b	108
    365  65b2		       6c		      .byte.b	108
    366  65b3		       6c		      .byte.b	108
    367  65b4		       78		      .byte.b	120
    368  65b5		       78		      .byte.b	120
    369  65b6		       78		      .byte.b	120
    370  65b7		       78		      .byte.b	120
    371  65b8		       70		      .byte.b	112
    372  65b9		       70		      .byte.b	112
    373  65ba		       70		      .byte.b	112
    374  65bb		       70		      .byte.b	112
    375  65bc		       60		      .byte.b	96
    376  65bd		       60		      .byte.b	96
    377  65be		       00		      .byte.b	0
    378  65bf		       00		      .byte.b	0
      0  65c0					      OPTIONAL_PAGEBREAK	"RIGHT_4", 32
     10  65c0					      LIST	ON
    380  65c0				   RIGHT_4
    381  65c0		       00		      .byte.b	0
    382  65c1		       00		      .byte.b	0
    383  65c2		       00		      .byte.b	0
    384  65c3		       06		      .byte.b	6
    385  65c4		       06		      .byte.b	6
    386  65c5		       06		      .byte.b	6
    387  65c6		       06		      .byte.b	6
    388  65c7		       06		      .byte.b	6
    389  65c8		       ef		      .byte.b	239
    390  65c9		       ef		      .byte.b	239
    391  65ca		       ef		      .byte.b	239
    392  65cb		       ef		      .byte.b	239
    393  65cc		       66		      .byte.b	102
    394  65cd		       66		      .byte.b	102
    395  65ce		       66		      .byte.b	102
    396  65cf		       66		      .byte.b	102
    397  65d0		       c6		      .byte.b	198
    398  65d1		       c6		      .byte.b	198
    399  65d2		       c6		      .byte.b	198
    400  65d3		       c6		      .byte.b	198
    401  65d4		       8e		      .byte.b	142
    402  65d5		       8e		      .byte.b	142
    403  65d6		       8e		      .byte.b	142
    404  65d7		       8e		      .byte.b	142
    405  65d8		       0e		      .byte.b	14
    406  65d9		       0e		      .byte.b	14
    407  65da		       0e		      .byte.b	14
    408  65db		       0e		      .byte.b	14
    409  65dc		       06		      .byte.b	6
    410  65dd		       06		      .byte.b	6
    411  65de		       00		      .byte.b	0
    412  65df		       00		      .byte.b	0
      0  65e0					      OPTIONAL_PAGEBREAK	"HUNDPF1_4", 0
     10  65e0					      LIST	ON
    414  65e0				   HUNDPF1_4
      0  65e0					      OPTIONAL_PAGEBREAK	"LEFT_5", 32
     10  65e0					      LIST	ON
    416  65e0				   LEFT_5
    417  65e0		       00		      .byte.b	0
    418  65e1		       00		      .byte.b	0
    419  65e2		       00		      .byte.b	0
    420  65e3		       38		      .byte.b	56
    421  65e4		       7c		      .byte.b	124
    422  65e5		       7c		      .byte.b	124
    423  65e6		       fe		      .byte.b	254
    424  65e7		       ee		      .byte.b	238
    425  65e8		       c6		      .byte.b	198
    426  65e9		       c6		      .byte.b	198
    427  65ea		       c6		      .byte.b	198
    428  65eb		       c0		      .byte.b	192
    429  65ec		       c0		      .byte.b	192
    430  65ed		       c0		      .byte.b	192
    431  65ee		       c0		      .byte.b	192
    432  65ef		       c0		      .byte.b	192
    433  65f0		       c0		      .byte.b	192
    434  65f1		       e6		      .byte.b	230
    435  65f2		       fe		      .byte.b	254
    436  65f3		       7e		      .byte.b	126
    437  65f4		       7e		      .byte.b	126
    438  65f5		       36		      .byte.b	54
    439  65f6		       06		      .byte.b	6
    440  65f7		       06		      .byte.b	6
    441  65f8		       06		      .byte.b	6
    442  65f9		       c6		      .byte.b	198
    443  65fa		       fe		      .byte.b	254
    444  65fb		       fe		      .byte.b	254
    445  65fc		       fe		      .byte.b	254
    446  65fd		       fe		      .byte.b	254
    447  65fe		       00		      .byte.b	0
    448  65ff		       00		      .byte.b	0
      0  6600					      OPTIONAL_PAGEBREAK	"RIGHT_5", 32
     10  6600					      LIST	ON
    450  6600				   RIGHT_5
    451  6600		       00		      .byte.b	0
    452  6601		       00		      .byte.b	0
    453  6602		       00		      .byte.b	0
    454  6603		       8c		      .byte.b	140
    455  6604		       ce		      .byte.b	206
    456  6605		       ce		      .byte.b	206
    457  6606		       ef		      .byte.b	239
    458  6607		       e7		      .byte.b	231
    459  6608		       63		      .byte.b	99
    460  6609		       63		      .byte.b	99
    461  660a		       63		      .byte.b	99
    462  660b		       03		      .byte.b	3
    463  660c		       03		      .byte.b	3
    464  660d		       03		      .byte.b	3
    465  660e		       03		      .byte.b	3
    466  660f		       03		      .byte.b	3
    467  6610		       03		      .byte.b	3
    468  6611		       67		      .byte.b	103
    469  6612		       ef		      .byte.b	239
    470  6613		       ee		      .byte.b	238
    471  6614		       ee		      .byte.b	238
    472  6615		       6c		      .byte.b	108
    473  6616		       60		      .byte.b	96
    474  6617		       60		      .byte.b	96
    475  6618		       60		      .byte.b	96
    476  6619		       63		      .byte.b	99
    477  661a		       ef		      .byte.b	239
    478  661b		       ef		      .byte.b	239
    479  661c		       ef		      .byte.b	239
    480  661d		       ef		      .byte.b	239
    481  661e		       00		      .byte.b	0
    482  661f		       00		      .byte.b	0
      0  6620					      OPTIONAL_PAGEBREAK	"HUNDPF1_5", 0
     10  6620					      LIST	ON
    484  6620				   HUNDPF1_5
      0  6620					      OPTIONAL_PAGEBREAK	"LEFT_6", 32
     10  6620					      LIST	ON
    486  6620				   LEFT_6
    487  6620		       00		      .byte.b	0
    488  6621		       00		      .byte.b	0
    489  6622		       00		      .byte.b	0
    490  6623		       38		      .byte.b	56
    491  6624		       7c		      .byte.b	124
    492  6625		       7c		      .byte.b	124
    493  6626		       fe		      .byte.b	254
    494  6627		       ee		      .byte.b	238
    495  6628		       c6		      .byte.b	198
    496  6629		       c6		      .byte.b	198
    497  662a		       c6		      .byte.b	198
    498  662b		       c6		      .byte.b	198
    499  662c		       c6		      .byte.b	198
    500  662d		       c6		      .byte.b	198
    501  662e		       ee		      .byte.b	238
    502  662f		       fe		      .byte.b	254
    503  6630		       7e		      .byte.b	126
    504  6631		       7e		      .byte.b	126
    505  6632		       36		      .byte.b	54
    506  6633		       06		      .byte.b	6
    507  6634		       06		      .byte.b	6
    508  6635		       0e		      .byte.b	14
    509  6636		       0c		      .byte.b	12
    510  6637		       0c		      .byte.b	12
    511  6638		       1c		      .byte.b	28
    512  6639		       1c		      .byte.b	28
    513  663a		       78		      .byte.b	120
    514  663b		       78		      .byte.b	120
    515  663c		       70		      .byte.b	112
    516  663d		       60		      .byte.b	96
    517  663e		       00		      .byte.b	0
    518  663f		       00		      .byte.b	0
      0  6640					      OPTIONAL_PAGEBREAK	"RIGHT_6", 32
     10  6640					      LIST	ON
    520  6640				   RIGHT_6
    521  6640		       00		      .byte.b	0
    522  6641		       00		      .byte.b	0
    523  6642		       00		      .byte.b	0
    524  6643		       8c		      .byte.b	140
    525  6644		       ce		      .byte.b	206
    526  6645		       ce		      .byte.b	206
    527  6646		       ef		      .byte.b	239
    528  6647		       e7		      .byte.b	231
    529  6648		       63		      .byte.b	99
    530  6649		       63		      .byte.b	99
    531  664a		       63		      .byte.b	99
    532  664b		       63		      .byte.b	99
    533  664c		       63		      .byte.b	99
    534  664d		       63		      .byte.b	99
    535  664e		       e7		      .byte.b	231
    536  664f		       ef		      .byte.b	239
    537  6650		       ee		      .byte.b	238
    538  6651		       ee		      .byte.b	238
    539  6652		       6c		      .byte.b	108
    540  6653		       60		      .byte.b	96
    541  6654		       60		      .byte.b	96
    542  6655		       e0		      .byte.b	224
    543  6656		       c0		      .byte.b	192
    544  6657		       c0		      .byte.b	192
    545  6658		       c8		      .byte.b	200
    546  6659		       c8		      .byte.b	200
    547  665a		       8e		      .byte.b	142
    548  665b		       8e		      .byte.b	142
    549  665c		       0e		      .byte.b	14
    550  665d		       06		      .byte.b	6
    551  665e		       00		      .byte.b	0
    552  665f		       00		      .byte.b	0
      0  6660					      OPTIONAL_PAGEBREAK	"HUNDPF1_6", 0
     10  6660					      LIST	ON
    554  6660				   HUNDPF1_6
      0  6660					      OPTIONAL_PAGEBREAK	"LEFT_7", 32
     10  6660					      LIST	ON
    556  6660				   LEFT_7
    557  6660		       00		      .byte.b	0
    558  6661		       00		      .byte.b	0
    559  6662		       00		      .byte.b	0
    560  6663		       18		      .byte.b	24
    561  6664		       18		      .byte.b	24
    562  6665		       18		      .byte.b	24
    563  6666		       18		      .byte.b	24
    564  6667		       18		      .byte.b	24
    565  6668		       18		      .byte.b	24
    566  6669		       18		      .byte.b	24
    567  666a		       18		      .byte.b	24
    568  666b		       18		      .byte.b	24
    569  666c		       18		      .byte.b	24
    570  666d		       18		      .byte.b	24
    571  666e		       30		      .byte.b	48
    572  666f		       30		      .byte.b	48
    573  6670		       30		      .byte.b	48
    574  6671		       30		      .byte.b	48
    575  6672		       60		      .byte.b	96
    576  6673		       60		      .byte.b	96
    577  6674		       60		      .byte.b	96
    578  6675		       60		      .byte.b	96
    579  6676		       c0		      .byte.b	192
    580  6677		       c0		      .byte.b	192
    581  6678		       c0		      .byte.b	192
    582  6679		       c6		      .byte.b	198
    583  667a		       fe		      .byte.b	254
    584  667b		       fe		      .byte.b	254
    585  667c		       fe		      .byte.b	254
    586  667d		       fe		      .byte.b	254
    587  667e		       00		      .byte.b	0
    588  667f		       00		      .byte.b	0
      0  6680					      OPTIONAL_PAGEBREAK	"RIGHT_7", 32
     10  6680					      LIST	ON
    590  6680				   RIGHT_7
    591  6680		       00		      .byte.b	0
    592  6681		       00		      .byte.b	0
    593  6682		       00		      .byte.b	0
    594  6683		       88		      .byte.b	136
    595  6684		       88		      .byte.b	136
    596  6685		       88		      .byte.b	136
    597  6686		       88		      .byte.b	136
    598  6687		       88		      .byte.b	136
    599  6688		       88		      .byte.b	136
    600  6689		       88		      .byte.b	136
    601  668a		       88		      .byte.b	136
    602  668b		       88		      .byte.b	136
    603  668c		       88		      .byte.b	136
    604  668d		       88		      .byte.b	136
    605  668e		       0c		      .byte.b	12
    606  668f		       0c		      .byte.b	12
    607  6690		       0c		      .byte.b	12
    608  6691		       0c		      .byte.b	12
    609  6692		       06		      .byte.b	6
    610  6693		       06		      .byte.b	6
    611  6694		       06		      .byte.b	6
    612  6695		       06		      .byte.b	6
    613  6696		       03		      .byte.b	3
    614  6697		       03		      .byte.b	3
    615  6698		       03		      .byte.b	3
    616  6699		       63		      .byte.b	99
    617  669a		       ef		      .byte.b	239
    618  669b		       ef		      .byte.b	239
    619  669c		       ef		      .byte.b	239
    620  669d		       ef		      .byte.b	239
    621  669e		       00		      .byte.b	0
    622  669f		       00		      .byte.b	0
      0  66a0					      OPTIONAL_PAGEBREAK	"HUNDPF1_7", 0
     10  66a0					      LIST	ON
    624  66a0				   HUNDPF1_7
      0  66a0					      OPTIONAL_PAGEBREAK	"LEFT_8", 32
     10  66a0					      LIST	ON
    626  66a0				   LEFT_8
    627  66a0		       00		      .byte.b	0
    628  66a1		       00		      .byte.b	0
    629  66a2		       00		      .byte.b	0
    630  66a3		       38		      .byte.b	56
    631  66a4		       7c		      .byte.b	124
    632  66a5		       7c		      .byte.b	124
    633  66a6		       fe		      .byte.b	254
    634  66a7		       ee		      .byte.b	238
    635  66a8		       c6		      .byte.b	198
    636  66a9		       c6		      .byte.b	198
    637  66aa		       c6		      .byte.b	198
    638  66ab		       c6		      .byte.b	198
    639  66ac		       c6		      .byte.b	198
    640  66ad		       c6		      .byte.b	198
    641  66ae		       ee		      .byte.b	238
    642  66af		       fc		      .byte.b	252
    643  66b0		       7c		      .byte.b	124
    644  66b1		       7e		      .byte.b	126
    645  66b2		       ee		      .byte.b	238
    646  66b3		       c6		      .byte.b	198
    647  66b4		       c6		      .byte.b	198
    648  66b5		       c6		      .byte.b	198
    649  66b6		       c6		      .byte.b	198
    650  66b7		       c6		      .byte.b	198
    651  66b8		       c6		      .byte.b	198
    652  66b9		       ee		      .byte.b	238
    653  66ba		       fe		      .byte.b	254
    654  66bb		       7c		      .byte.b	124
    655  66bc		       7c		      .byte.b	124
    656  66bd		       38		      .byte.b	56
    657  66be		       00		      .byte.b	0
    658  66bf		       00		      .byte.b	0
      0  66c0					      OPTIONAL_PAGEBREAK	"RIGHT_8", 32
     10  66c0					      LIST	ON
    660  66c0				   RIGHT_8
    661  66c0		       00		      .byte.b	0
    662  66c1		       00		      .byte.b	0
    663  66c2		       00		      .byte.b	0
    664  66c3		       8c		      .byte.b	140
    665  66c4		       ce		      .byte.b	206
    666  66c5		       ce		      .byte.b	206
    667  66c6		       ef		      .byte.b	239
    668  66c7		       e7		      .byte.b	231
    669  66c8		       63		      .byte.b	99
    670  66c9		       63		      .byte.b	99
    671  66ca		       63		      .byte.b	99
    672  66cb		       63		      .byte.b	99
    673  66cc		       63		      .byte.b	99
    674  66cd		       63		      .byte.b	99
    675  66ce		       e7		      .byte.b	231
    676  66cf		       cf		      .byte.b	207
    677  66d0		       ce		      .byte.b	206
    678  66d1		       ee		      .byte.b	238
    679  66d2		       e7		      .byte.b	231
    680  66d3		       63		      .byte.b	99
    681  66d4		       63		      .byte.b	99
    682  66d5		       63		      .byte.b	99
    683  66d6		       63		      .byte.b	99
    684  66d7		       63		      .byte.b	99
    685  66d8		       63		      .byte.b	99
    686  66d9		       e7		      .byte.b	231
    687  66da		       ef		      .byte.b	239
    688  66db		       ce		      .byte.b	206
    689  66dc		       ce		      .byte.b	206
    690  66dd		       8c		      .byte.b	140
    691  66de		       00		      .byte.b	0
    692  66df		       00		      .byte.b	0
      0  66e0					      OPTIONAL_PAGEBREAK	"HUNDPF1_8", 0
     10  66e0					      LIST	ON
    694  66e0				   HUNDPF1_8
      0  66e0					      OPTIONAL_PAGEBREAK	"LEFT_9", 32
     10  66e0					      LIST	ON
    696  66e0				   LEFT_9
    697  66e0		       00		      .byte.b	0
    698  66e1		       00		      .byte.b	0
    699  66e2		       00		      .byte.b	0
    700  66e3		       0c		      .byte.b	12
    701  66e4		       1c		      .byte.b	28
    702  66e5		       3c		      .byte.b	60
    703  66e6		       3c		      .byte.b	60
    704  66e7		       70		      .byte.b	112
    705  66e8		       70		      .byte.b	112
    706  66e9		       60		      .byte.b	96
    707  66ea		       e0		      .byte.b	224
    708  66eb		       e0		      .byte.b	224
    709  66ec		       c0		      .byte.b	192
    710  66ed		       c0		      .byte.b	192
    711  66ee		       d8		      .byte.b	216
    712  66ef		       fc		      .byte.b	252
    713  66f0		       fc		      .byte.b	252
    714  66f1		       fe		      .byte.b	254
    715  66f2		       ee		      .byte.b	238
    716  66f3		       c6		      .byte.b	198
    717  66f4		       c6		      .byte.b	198
    718  66f5		       c6		      .byte.b	198
    719  66f6		       c6		      .byte.b	198
    720  66f7		       c6		      .byte.b	198
    721  66f8		       c6		      .byte.b	198
    722  66f9		       ee		      .byte.b	238
    723  66fa		       fe		      .byte.b	254
    724  66fb		       7c		      .byte.b	124
    725  66fc		       7c		      .byte.b	124
    726  66fd		       38		      .byte.b	56
    727  66fe		       00		      .byte.b	0
    728  66ff		       00		      .byte.b	0
      0  6700					      OPTIONAL_PAGEBREAK	"RIGHT_9", 32
     10  6700					      LIST	ON
    730  6700				   RIGHT_9
    731  6700		       00		      .byte.b	0
    732  6701		       00		      .byte.b	0
    733  6702		       00		      .byte.b	0
    734  6703		       c0		      .byte.b	192
    735  6704		       c8		      .byte.b	200
    736  6705		       cc		      .byte.b	204
    737  6706		       cc		      .byte.b	204
    738  6707		       0e		      .byte.b	14
    739  6708		       0e		      .byte.b	14
    740  6709		       06		      .byte.b	6
    741  670a		       07		      .byte.b	7
    742  670b		       07		      .byte.b	7
    743  670c		       03		      .byte.b	3
    744  670d		       03		      .byte.b	3
    745  670e		       8b		      .byte.b	139
    746  670f		       cf		      .byte.b	207
    747  6710		       cf		      .byte.b	207
    748  6711		       ef		      .byte.b	239
    749  6712		       e7		      .byte.b	231
    750  6713		       63		      .byte.b	99
    751  6714		       63		      .byte.b	99
    752  6715		       63		      .byte.b	99
    753  6716		       63		      .byte.b	99
    754  6717		       63		      .byte.b	99
    755  6718		       63		      .byte.b	99
    756  6719		       e7		      .byte.b	231
    757  671a		       ef		      .byte.b	239
    758  671b		       ce		      .byte.b	206
    759  671c		       ce		      .byte.b	206
    760  671d		       8c		      .byte.b	140
    761  671e		       00		      .byte.b	0
    762  671f		       00		      .byte.b	0
      0  6720					      OPTIONAL_PAGEBREAK	"HUNDPF1_9", 0
     10  6720					      LIST	ON
    764  6720				   HUNDPF1_9
      0  6720					      OPTIONAL_PAGEBREAK	"LEFT_star0", 32
     10  6720					      LIST	ON
    766  6720				   LEFT_star0
    767  6720		       2c		      .byte.b	44
    768  6721		       00		      .byte.b	0
    769  6722		       28		      .byte.b	40
    770  6723		       28		      .byte.b	40
    771  6724		       28		      .byte.b	40
    772  6725		       28		      .byte.b	40
    773  6726		       38		      .byte.b	56
    774  6727		       38		      .byte.b	56
    775  6728		       28		      .byte.b	40
    776  6729		       38		      .byte.b	56
    777  672a		       38		      .byte.b	56
    778  672b		       38		      .byte.b	56
    779  672c		       38		      .byte.b	56
    780  672d		       fe		      .byte.b	254
    781  672e		       fe		      .byte.b	254
    782  672f		       b2		      .byte.b	178
    783  6730		       ba		      .byte.b	186
    784  6731		       b2		      .byte.b	178
    785  6732		       30		      .byte.b	48
    786  6733		       18		      .byte.b	24
    787  6734		       14		      .byte.b	20
    788  6735		       08		      .byte.b	8
    789  6736		       3c		      .byte.b	60
    790  6737		       3a		      .byte.b	58
    791  6738		       00		      .byte.b	0
    792  6739		       00		      .byte.b	0
    793  673a		       00		      .byte.b	0
    794  673b		       00		      .byte.b	0
    795  673c		       00		      .byte.b	0
    796  673d		       00		      .byte.b	0
    797  673e		       00		      .byte.b	0
    798  673f		       00		      .byte.b	0
      0  6740					      OPTIONAL_PAGEBREAK	"LEFT_star1", 32
     10  6740					      LIST	ON
    800  6740				   LEFT_star1
    801  6740		       46		      .byte.b	70
    802  6741		       80		      .byte.b	128
    803  6742		       64		      .byte.b	100
    804  6743		       62		      .byte.b	98
    805  6744		       1e		      .byte.b	30
    806  6745		       3c		      .byte.b	60
    807  6746		       28		      .byte.b	40
    808  6747		       30		      .byte.b	48
    809  6748		       38		      .byte.b	56
    810  6749		       38		      .byte.b	56
    811  674a		       38		      .byte.b	56
    812  674b		       3c		      .byte.b	60
    813  674c		       3e		      .byte.b	62
    814  674d		       3f		      .byte.b	63
    815  674e		       19		      .byte.b	25
    816  674f		       19		      .byte.b	25
    817  6750		       1d		      .byte.b	29
    818  6751		       18		      .byte.b	24
    819  6752		       0c		      .byte.b	12
    820  6753		       0a		      .byte.b	10
    821  6754		       04		      .byte.b	4
    822  6755		       1e		      .byte.b	30
    823  6756		       1d		      .byte.b	29
    824  6757		       00		      .byte.b	0
    825  6758		       00		      .byte.b	0
    826  6759		       00		      .byte.b	0
    827  675a		       00		      .byte.b	0
    828  675b		       00		      .byte.b	0
    829  675c		       00		      .byte.b	0
    830  675d		       00		      .byte.b	0
    831  675e		       00		      .byte.b	0
    832  675f		       00		      .byte.b	0
      0  6760					      OPTIONAL_PAGEBREAK	"LEFT_star2", 32
     10  6760					      LIST	ON
    834  6760				   LEFT_star2
    835  6760		       26		      .byte.b	38
    836  6761		       40		      .byte.b	64
    837  6762		       34		      .byte.b	52
    838  6763		       14		      .byte.b	20
    839  6764		       14		      .byte.b	20
    840  6765		       3c		      .byte.b	60
    841  6766		       3c		      .byte.b	60
    842  6767		       28		      .byte.b	40
    843  6768		       30		      .byte.b	48
    844  6769		       38		      .byte.b	56
    845  676a		       38		      .byte.b	56
    846  676b		       38		      .byte.b	56
    847  676c		       3c		      .byte.b	60
    848  676d		       3e		      .byte.b	62
    849  676e		       3f		      .byte.b	63
    850  676f		       19		      .byte.b	25
    851  6770		       19		      .byte.b	25
    852  6771		       1d		      .byte.b	29
    853  6772		       18		      .byte.b	24
    854  6773		       0c		      .byte.b	12
    855  6774		       0a		      .byte.b	10
    856  6775		       04		      .byte.b	4
    857  6776		       1e		      .byte.b	30
    858  6777		       1d		      .byte.b	29
    859  6778		       00		      .byte.b	0
    860  6779		       00		      .byte.b	0
    861  677a		       00		      .byte.b	0
    862  677b		       00		      .byte.b	0
    863  677c		       00		      .byte.b	0
    864  677d		       00		      .byte.b	0
    865  677e		       00		      .byte.b	0
    866  677f		       00		      .byte.b	0
      0  6780					      OPTIONAL_PAGEBREAK	"LEFT_star3", 32
     10  6780					      LIST	ON
    868  6780				   LEFT_star3
    869  6780		       46		      .byte.b	70
    870  6781		       80		      .byte.b	128
    871  6782		       64		      .byte.b	100
    872  6783		       72		      .byte.b	114
    873  6784		       3e		      .byte.b	62
    874  6785		       3c		      .byte.b	60
    875  6786		       18		      .byte.b	24
    876  6787		       30		      .byte.b	48
    877  6788		       38		      .byte.b	56
    878  6789		       38		      .byte.b	56
    879  678a		       38		      .byte.b	56
    880  678b		       3c		      .byte.b	60
    881  678c		       3e		      .byte.b	62
    882  678d		       3f		      .byte.b	63
    883  678e		       19		      .byte.b	25
    884  678f		       19		      .byte.b	25
    885  6790		       1d		      .byte.b	29
    886  6791		       18		      .byte.b	24
    887  6792		       0c		      .byte.b	12
    888  6793		       0a		      .byte.b	10
    889  6794		       04		      .byte.b	4
    890  6795		       1e		      .byte.b	30
    891  6796		       1d		      .byte.b	29
    892  6797		       00		      .byte.b	0
    893  6798		       00		      .byte.b	0
    894  6799		       00		      .byte.b	0
    895  679a		       00		      .byte.b	0
    896  679b		       00		      .byte.b	0
    897  679c		       00		      .byte.b	0
    898  679d		       00		      .byte.b	0
    899  679e		       00		      .byte.b	0
    900  679f		       00		      .byte.b	0
------- FILE levelScreen.asm
    802  67a0
      0  67a0					      CHECK_BANK_SIZE	"LEVELSCREEN"
      1  67a0		       07 a0	   .TEMP      =	* - BANK_START
 LEVELSCREEN (2K) SIZE =  $7a0 , FREE= $60
      2  67a0					      ECHO	"LEVELSCREEN", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  67a0				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  67a0				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  67a0				  -	      ERR
      6  67a0					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 3
      0  67a0					      include	"BANK_INITBANK.asm"	; MUST be after banks that include levels -- otherwise MAX_LEVELBANK is not calculated properly
      1  67a0							;    Sokoboo - a Sokoban implementation
      2  67a0							;    using a generic tile-based display engine for the Atari 2600
      3  67a0							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  67a0							;
      5  67a0							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  67a0							;
      7  67a0							;    Code related to the generic tile-based display engine was developed by
      8  67a0							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  67a0							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  67a0							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  67a0							;
     12  67a0							;    Code related to music and sound effects uses the TIATracker music player
     13  67a0							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  67a0							;    directory for Apache licensing details.
     15  67a0							;
     16  67a0							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  67a0							;    See the copyright notices in the License directory for a list of level
     18  67a0							;    contributors.
     19  67a0							;
     20  67a0							;    Except where otherwise indicated, this software is released under the
     21  67a0							;    following licensing arrangement...
     22  67a0							;
     23  67a0							;    This program is free software: you can redistribute it and/or modify
     24  67a0							;    it under the terms of the GNU General Public License as published by
     25  67a0							;    the Free Software Foundation, either version 3 of the License, or
     26  67a0							;    (at your option) any later version.
     27  67a0							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  67a0
     29  67a0							;    This program is distributed in the hope that it will be useful,
     30  67a0							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  67a0							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  67a0							;    GNU General Public License for more details.
     33  67a0
      0  67a0					      NEWBANK	INITBANK
      1  6db9 ????				      SEG	INITBANK
      2  6800					      ORG	ORIGIN
      3  6800					      RORG	$F000
      4  6800				   BANK_START SET	*
      5  6800				   INITBANK   SET	ORIGIN / 2048
      6  6800				   ORIGIN     SET	ORIGIN + 2048
      7  6800				   _CURRENT_BANK SET	INITBANK
     35  6800
     36  6800		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
     37  6801
      0  6801					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  6801		       00 0d	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  6801					      SUBROUTINE
      3  6801				   BoardLineStartLO
     39  6801
     40  6801							; Gives the start address (LO) of each board line
     41  6801					      if	1
     42  6801				   .BOARD_LOCATION SET	Board
     43  6801					      REPEAT	SIZE_BOARD_Y
     44  6801				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6801				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6801					      ENDIF
     47  6801		       00		      .byte.b	<.BOARD_LOCATION
     48  6801				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6801					      REPEND
     44  6802				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6802				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6802					      ENDIF
     47  6802		       28		      .byte.b	<.BOARD_LOCATION
     48  6802				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6802					      REPEND
     44  6803				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6803				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6803					      ENDIF
     47  6803		       50		      .byte.b	<.BOARD_LOCATION
     48  6803				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6803					      REPEND
     44  6804				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6804				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6804					      ENDIF
     47  6804		       78		      .byte.b	<.BOARD_LOCATION
     48  6804				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6804					      REPEND
     44  6805				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6805				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6805					      ENDIF
     47  6805		       a0		      .byte.b	<.BOARD_LOCATION
     48  6805				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6805					      REPEND
     44  6806				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6806				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6806					      ENDIF
     47  6806		       c8		      .byte.b	<.BOARD_LOCATION
     48  6806				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6806					      REPEND
     44  6807					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6807				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6807					      ENDIF
     47  6807		       00		      .byte.b	<.BOARD_LOCATION
     48  6807				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6807					      REPEND
     44  6808				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6808				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6808					      ENDIF
     47  6808		       28		      .byte.b	<.BOARD_LOCATION
     48  6808				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6808					      REPEND
     44  6809				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6809				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6809					      ENDIF
     47  6809		       50		      .byte.b	<.BOARD_LOCATION
     48  6809				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6809					      REPEND
     44  680a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680a					      ENDIF
     47  680a		       78		      .byte.b	<.BOARD_LOCATION
     48  680a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680a					      REPEND
     44  680b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680b					      ENDIF
     47  680b		       a0		      .byte.b	<.BOARD_LOCATION
     48  680b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680b					      REPEND
     44  680c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680c					      ENDIF
     47  680c		       c8		      .byte.b	<.BOARD_LOCATION
     48  680c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680c					      REPEND
     44  680d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680d					      ENDIF
     47  680d		       00		      .byte.b	<.BOARD_LOCATION
     48  680d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680d					      REPEND
     44  680e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680e					      ENDIF
     47  680e		       28		      .byte.b	<.BOARD_LOCATION
     48  680e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680e					      REPEND
     44  680f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  680f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  680f					      ENDIF
     47  680f		       50		      .byte.b	<.BOARD_LOCATION
     48  680f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  680f					      REPEND
     44  6810				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6810				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6810					      ENDIF
     47  6810		       78		      .byte.b	<.BOARD_LOCATION
     48  6810				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6810					      REPEND
     44  6811				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6811				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6811					      ENDIF
     47  6811		       a0		      .byte.b	<.BOARD_LOCATION
     48  6811				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6811					      REPEND
     44  6812				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6812				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6812					      ENDIF
     47  6812		       c8		      .byte.b	<.BOARD_LOCATION
     48  6812				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6812					      REPEND
     44  6813					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6813				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6813					      ENDIF
     47  6813		       00		      .byte.b	<.BOARD_LOCATION
     48  6813				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6813					      REPEND
     44  6814				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6814				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6814					      ENDIF
     47  6814		       28		      .byte.b	<.BOARD_LOCATION
     48  6814				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6814					      REPEND
     44  6815				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6815				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6815					      ENDIF
     47  6815		       50		      .byte.b	<.BOARD_LOCATION
     48  6815				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6815					      REPEND
     44  6816				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6816				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6816					      ENDIF
     47  6816		       78		      .byte.b	<.BOARD_LOCATION
     48  6816				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     49  6817					      REPEND
      0  6817					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  6817					      LIST	ON
     51  6817
     52  6817		       03 a0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     53  6817					      endif
     54  6817
     55  6817							;------------------------------------------------------------------------------
     56  6817
     57  6817				   BoardLineStartHiR
     58  6817
     59  6817							; Gives the start address (HI) of each board line
     60  6817							; Note this caters for the memory wrapping when we go from bank to bank, as
     61  6817							; the board overlays multiple banks!
     62  6817
     63  6817				   .BOARD_LOCATION SET	Board
     64  6817					      REPEAT	SIZE_BOARD_Y
     65  6817				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6817				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6817					      ENDIF
     68  6817		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6817				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6817					      REPEND
     65  6818				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6818				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6818					      ENDIF
     68  6818		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6818				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6818					      REPEND
     65  6819				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6819				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6819					      ENDIF
     68  6819		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6819				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6819					      REPEND
     65  681a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681a					      ENDIF
     68  681a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681a					      REPEND
     65  681b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681b					      ENDIF
     68  681b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681b					      REPEND
     65  681c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681c					      ENDIF
     68  681c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681c					      REPEND
     65  681d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681d					      ENDIF
     68  681d		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681d					      REPEND
     65  681e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681e					      ENDIF
     68  681e		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681e					      REPEND
     65  681f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  681f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  681f					      ENDIF
     68  681f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  681f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  681f					      REPEND
     65  6820				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6820				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6820					      ENDIF
     68  6820		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6820				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6820					      REPEND
     65  6821				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6821				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6821					      ENDIF
     68  6821		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6821				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6821					      REPEND
     65  6822				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6822				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6822					      ENDIF
     68  6822		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6822				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6822					      REPEND
     65  6823					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6823				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6823					      ENDIF
     68  6823		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6823				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6823					      REPEND
     65  6824				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6824				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6824					      ENDIF
     68  6824		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6824				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6824					      REPEND
     65  6825				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6825				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6825					      ENDIF
     68  6825		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6825				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6825					      REPEND
     65  6826				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6826				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6826					      ENDIF
     68  6826		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6826				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6826					      REPEND
     65  6827				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6827				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6827					      ENDIF
     68  6827		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6827				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6827					      REPEND
     65  6828				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6828				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6828					      ENDIF
     68  6828		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6828				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6828					      REPEND
     65  6829					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6829				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6829					      ENDIF
     68  6829		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6829				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6829					      REPEND
     65  682a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  682a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  682a					      ENDIF
     68  682a		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  682a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  682a					      REPEND
     65  682b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  682b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  682b					      ENDIF
     68  682b		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  682b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  682b					      REPEND
     65  682c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  682c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  682c					      ENDIF
     68  682c		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  682c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     70  682d					      REPEND
      0  682d					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  682d					      LIST	ON
     72  682d							;------------------------------------------------------------------------------
     73  682d
     74  682d				   BoardLineStartHiW
     75  682d
     76  682d							; Gives the start address (HI) of each board line
     77  682d							; Note this caters for the memory wrapping when we go from bank to bank, as
     78  682d							; the board overlays multiple banks!
     79  682d
     80  682d				   .BOARD_LOCATION SET	Board
     81  682d					      REPEAT	SIZE_BOARD_Y
     82  682d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  682d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  682d					      ENDIF
     85  682d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  682d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  682d					      REPEND
     82  682e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  682e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  682e					      ENDIF
     85  682e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  682e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  682e					      REPEND
     82  682f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  682f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  682f					      ENDIF
     85  682f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  682f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  682f					      REPEND
     82  6830				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6830				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6830					      ENDIF
     85  6830		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6830				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6830					      REPEND
     82  6831				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6831				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6831					      ENDIF
     85  6831		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6831				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6831					      REPEND
     82  6832				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6832				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6832					      ENDIF
     85  6832		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6832				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6832					      REPEND
     82  6833					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6833				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6833					      ENDIF
     85  6833		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6833				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6833					      REPEND
     82  6834				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6834				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6834					      ENDIF
     85  6834		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6834				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6834					      REPEND
     82  6835				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6835				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6835					      ENDIF
     85  6835		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6835				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6835					      REPEND
     82  6836				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6836				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6836					      ENDIF
     85  6836		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6836				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6836					      REPEND
     82  6837				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6837				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6837					      ENDIF
     85  6837		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6837				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6837					      REPEND
     82  6838				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6838				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6838					      ENDIF
     85  6838		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6838				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6838					      REPEND
     82  6839					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6839				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6839					      ENDIF
     85  6839		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6839				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6839					      REPEND
     82  683a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683a					      ENDIF
     85  683a		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683a					      REPEND
     82  683b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683b					      ENDIF
     85  683b		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683b					      REPEND
     82  683c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683c					      ENDIF
     85  683c		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683c					      REPEND
     82  683d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683d					      ENDIF
     85  683d		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683d					      REPEND
     82  683e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683e					      ENDIF
     85  683e		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683e					      REPEND
     82  683f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  683f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  683f					      ENDIF
     85  683f		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  683f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  683f					      REPEND
     82  6840				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6840				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6840					      ENDIF
     85  6840		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6840				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6840					      REPEND
     82  6841				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6841				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6841					      ENDIF
     85  6841		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6841				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6841					      REPEND
     82  6842				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6842				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6842					      ENDIF
     85  6842		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6842				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     87  6843					      REPEND
      0  6843					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  6843					      LIST	ON
     89  6843
     90  6843							;------------------------------------------------------------------------------
     91  6843							;    IF MULTI_BANK_BOARD = YES
     92  6843							;BoardBank
     93  6843							;    ENDIF
     94  6843							; Gives the RAM bank of the start of the board row for a given row.
     95  6843
     96  6843				   .BOARD_LOCATION SET	Board - RAM_3E
     97  6843					      REPEAT	SIZE_BOARD_Y
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  6843					      REPEND
     98  6843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  6843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  6843					      ENDIF
    101  6843							;    IF MULTI_BANK_BOARD = YES
    102  6843							;		  .byte BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	     ; actual bank #
    103  6843							;    ENDIF
    104  6843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
    105  6843					      REPEND
    106  6843							;    IF MULTI_BANK_BOARD = YES
    107  6843							;    CHECKPAGEX BoardBank, "BoardBank in BANK_INITBANK.asm"
    108  6843							;    ENDIF
    109  6843
    110  6843
    111  6843							;------------------------------------------------------------------------------
    112  6843
    113  6843				   CopyROMShadowToRAM_F000
    114  6843		       a9 f0		      lda	#>$F000
    115  6845
      0  6845					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  6845		       00 0d	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  6845					      SUBROUTINE
      3  6845				   CopyROMShadowToRAM
    117  6845
    118  6845							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
    119  6845							; the variable definitions are in the ROM shadow because this allows auto-initialisation
    120  6845							; of the variable contents from ROM declarations, but still allows access to them as
    121  6845							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
    122  6845							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
    123  6845							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
    124  6845							; code co-lives in all banks and may run even as bankswitching occurs between those
    125  6845							; banks -- by the very code itself.
    126  6845
    127  6845							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
    128  6845		       85 bc		      sta	Board_AddressR+1
    129  6847		       86 d8		      stx	O_ROM_Source_Bank	; source bank
    130  6849		       84 c0		      sty	RAM_Bank	; destination bank
    131  684b
    132  684b		       a0 00		      ldy	#0
    133  684d		       84 bb		      sty	Board_AddressR
    134  684f		       84 bd		      sty	Board_AddressW
    135  6851		       a9 14		      lda	#>($1000+RAM_WRITE)
    136  6853		       85 be		      sta	Board_AddressW+1
    137  6855
    138  6855							; Iterate 4 pages (1K) for complete bank copy
    139  6855
    140  6855		       a9 04		      lda	#4
    141  6857		       85 d7		      sta	O_CopyCount
    142  6859
    143  6859		       84 d9	   CopyPage   sty	O_Index
    144  685b		       a5 d8		      lda	O_ROM_Source_Bank
    145  685d		       20 0f f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    146  6860							;tax
    147  6860		       a4 d9		      ldy	O_Index
    148  6862		       a6 c0		      ldx	RAM_Bank
    149  6864		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    150  6867
    151  6867		       a4 d9		      ldy	O_Index
    152  6869		       c8		      iny
    153  686a		       d0 ed		      bne	CopyPage
    154  686c
    155  686c		       e6 bc		      inc	Board_AddressR+1
    156  686e		       e6 be		      inc	Board_AddressW+1
    157  6870
    158  6870		       c6 d7		      dec	O_CopyCount
    159  6872		       d0 e5		      bne	CopyPage
    160  6874
    161  6874		       a4 c0		      ldy	RAM_Bank	; TODO: remove!?
    162  6876		       60		      rts
    163  6877
    164  6877
    165  6877							;------------------------------------------------------------------------------
      0  6877					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  6877		       00 0d	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  6877					      SUBROUTINE
      3  6877				   SetPlatformColours
    167  6877
    168  6877							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    169  6877							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    170  6877							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    171  6877							; addressing will not violate the page-crossing restriction of 3E.
    172  6877
    173  6877							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    174  6877
    175  6877		       a9 00		      lda	#<DrawTheScreen	; = 0
    176  6879		       85 bd		      sta	Board_AddressW
    177  687b		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    178  687d		       85 be		      sta	Board_AddressW+1
    179  687f
    180  687f							; first, set the x index (with last one being a RTS ($60))
    181  687f
    182  687f		       a6 c0		      ldx	RAM_Bank
    183  6881		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    184  6883		       d0 07		      bne	.skipPatch
    185  6885		       a9 60		      lda	#$60	; rts
    186  6887		       a0 41		      ldy	#<SELFMOD_X
    187  6889		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    188  688c				   .skipPatch
    189  688c
    190  688c
    191  688c							; randomise the rainbow band starting point. Technically we only need
    192  688c							; to do this on the FIRST bank
    193  688c
    194  688c		       a9 6b		      lda	#<(BandOffset+RAM_WRITE)
    195  688e		       85 bd		      sta	Board_AddressW
    196  6890		       a9 f7		      lda	#>(BandOffset+RAM_WRITE)
    197  6892		       85 be		      sta	Board_AddressW+1
    198  6894		       20 0c fd 	      jsr	Random
    199  6897		       29 1f		      and	#31
    200  6899		       a0 00		      ldy	#0	; offset from address
    201  689b		       20 1d f8 	      jsr	PutBoardCharacter
    202  689e
    203  689e
    204  689e
    205  689e		       a4 c0		      ldy	RAM_Bank
    206  68a0		       60		      rts
    207  68a1
    208  68a1				   SelfModColOfsTbl
    209  68a1		       53 86 1d 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    210  68a4
    211  68a4
    212  68a4
    213  68a4				   DrawLineStartLO
    214  68a4
    215  68a4							; Gives the start address of each line in the draw flags buffer
    216  68a4
    217  68a4				   .DRAW_LOCATION SET	DrawFlag
    218  68a4					      REPEAT	SCREEN_LINES
    219  68a4		       50		      .byte.b	<.DRAW_LOCATION
    220  68a4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  68a4					      REPEND
    219  68a5		       5a		      .byte.b	<.DRAW_LOCATION
    220  68a5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  68a5					      REPEND
    219  68a6		       64		      .byte.b	<.DRAW_LOCATION
    220  68a6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  68a6					      REPEND
    219  68a7		       6e		      .byte.b	<.DRAW_LOCATION
    220  68a7				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  68a7					      REPEND
    219  68a8		       78		      .byte.b	<.DRAW_LOCATION
    220  68a8				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  68a8					      REPEND
    219  68a9		       82		      .byte.b	<.DRAW_LOCATION
    220  68a9				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  68a9					      REPEND
    219  68aa		       8c		      .byte.b	<.DRAW_LOCATION
    220  68aa				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    218  68aa					      REPEND
    219  68ab		       96		      .byte.b	<.DRAW_LOCATION
    220  68ab				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    221  68ac					      REPEND
    222  68ac
    223  68ac
    224  68ac							;------------------------------------------------------------------------------
    225  68ac
      0  68ac					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  68ac		       00 0d	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  68ac					      SUBROUTINE
      3  68ac				   GetBoardAddressRW
    227  68ac							; Must share same bank as BoardLineStart tables
    228  68ac
    229  68ac		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    230  68af		       85 bb		      sta	Board_AddressR	; 3
    231  68b1		       85 bd		      sta	Board_AddressW	; 3
    232  68b3		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    233  68b6		       85 bc		      sta	Board_AddressR+1	; 3	     READ address
    234  68b8		       09 04		      ora	#>RAM_WRITE	; 2
    235  68ba		       85 be		      sta	Board_AddressW+1	; 3	     WRITE address
    236  68bc							;    IF MULTI_BANK_BOARD = YES
    237  68bc							;		  ldx BoardBank,y		  ; 4 = 26    switch this on return
    238  68bc							;    ELSE
    239  68bc		       a2 0d		      ldx	#BANK_BOARD	; 2
    240  68be							;    ENDIF
    241  68be		       60		      rts		; 6 = 32[-2]
    242  68bf
    243  68bf							;------------------------------------------------------------------------------
    244  68bf
      0  68bf					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  68bf		       00 0d	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  68bf					      SUBROUTINE
      3  68bf				   GetBoardAddressR
    246  68bf
    247  68bf		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    248  68c2		       85 bb		      sta	Board_AddressR	; 3
    249  68c4		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    250  68c7		       85 bc		      sta	Board_AddressR+1	; 3	 READ address
    251  68c9							;    IF MULTI_BANK_BOARD = YES
    252  68c9							;		  lda BoardBank,y		  ; 4	  switch this on return
    253  68c9							;    ELSE
    254  68c9		       a9 0d		      lda	#BANK_BOARD	; 2
    255  68cb							;    ENDIF
    256  68cb		       60		      rts		; 6[-2]
    257  68cc
    258  68cc							;------------------------------------------------------------------------------
    259  68cc
      0  68cc					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  68cc		       00 0d	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  68cc					      SUBROUTINE
      3  68cc				   GetBoardAddressW
    261  68cc
    262  68cc							; Must share same bank as BoardLineStart tables
    263  68cc
    264  68cc		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    265  68cf		       85 bd		      sta	Board_AddressW	;3
    266  68d1		       b9 2d f0 	      lda	BoardLineStartHiW,y	;4
    267  68d4		       85 be		      sta	Board_AddressW+1	;3 WRITE address
    268  68d6							;    IF MULTI_BANK_BOARD = YES
    269  68d6							;		  ldx BoardBank,y		  ;4 switch this on return
    270  68d6							;    ELSE
    271  68d6		       a2 0d		      ldx	#BANK_BOARD	;2
    272  68d8							;    ENDIF
    273  68d8		       60	   QRet       rts		;6
    274  68d9
    275  68d9							;-------------------------------------------------------------------------------
    276  68d9
    277  68d9
    278  68d9							;------------------------------------------------------------------------------
    279  68d9
    280  68d9		       e6 a4	   cannotPush inc	ManPushCounter
    281  68db		       60		      rts
    282  68dc
      0  68dc					      DEFINE_SUBROUTINE	PushBox
      1  68dc		       00 0d	   BANK_PushBox =	_CURRENT_BANK
      2  68dc					      SUBROUTINE
      3  68dc				   PushBox
    284  68dc
    285  68dc							; X = restoration character for square we are moving TO
    286  68dc							; so, if X = CHARACTER_TARGET AND we move, THEN we are pushing a box off a target
    287  68dc							; A = this bank!
    288  68dc
    289  68dc		       85 bf		      sta	ROM_Bank
    290  68de
    291  68de		       a9 08		      lda	#ANIMATION_PUSH_ID
    292  68e0		       c5 a6		      cmp	ManAnimationID
    293  68e2		       f0 10		      beq	alreadyAnimPush
    294  68e4
      0  68e4					      LOAD_ANIMATION	PUSH
      1  68e4		       a9 c6		      lda	#<Animation_PUSH
      2  68e6		       85 9a		      sta	animation
      3  68e8		       a9 f0		      lda	#>Animation_PUSH
      4  68ea		       85 9b		      sta	animation+1
      5  68ec		       a9 00		      lda	#0
      6  68ee		       85 9c		      sta	animation_delay
      7  68f0		       a9 08		      lda	#ANIMATION_PUSH_ID
      8  68f2		       85 a6		      sta	ManAnimationID
      9  68f4
    296  68f4
    297  68f4							;lda #0
    298  68f4							;sta idleCount
    299  68f4
    300  68f4				   alreadyAnimPush
    301  68f4
    302  68f4
    303  68f4		       a5 a4		      lda	ManPushCounter
    304  68f6		       c9 06		      cmp	#PUSH_LIMIT
    305  68f8		       90 df		      bcc	cannotPush
    306  68fa
    307  68fa		       86 d9		      stx	restorationCharacter	; players new location's restore
    308  68fc
    309  68fc							; Determine if the box is pushable
    310  68fc							; we use the joystick to calculate the subsequent square
    311  68fc
    312  68fc		       a5 93		      lda	PreviousJoystick
    313  68fe		       4a		      lsr
    314  68ff		       4a		      lsr
    315  6900		       4a		      lsr
    316  6901		       4a		      lsr
    317  6902		       a8		      tay
    318  6903
    319  6903		       b9 d0 f2 	      lda	JoyMoveX,y
    320  6906		       f0 05		      beq	x0
    321  6908		       b9 e0 f2 	      lda	JoyMoveY,y
    322  690b		       d0 cc		      bne	cannotPush	; avoid diagonal pushes!
    323  690d
    324  690d		       98	   x0	      tya
    325  690e		       48		      pha
    326  690f
    327  690f		       18		      clc
    328  6910		       a5 8a		      lda	POS_Y_NEW
    329  6912		       79 e0 f2 	      adc	JoyMoveY,y
    330  6915		       85 88		      sta	POS_Y	; the box's pushed-to square
    331  6917		       a8		      tay
    332  6918		       20 ac f0 	      jsr	GetBoardAddressRW
    333  691b
    334  691b		       68		      pla
    335  691c		       a8		      tay
    336  691d
    337  691d		       18		      clc
    338  691e		       a5 89		      lda	POS_X_NEW
    339  6920		       79 d0 f2 	      adc	JoyMoveX,y
    340  6923		       85 87		      sta	POS_X	; the box's pushed-to square
    341  6925		       48		      pha
    342  6926		       a8		      tay
    343  6927
    344  6927							;    IF MULTI_BANK_BOARD = YES
    345  6927							;		  lda RAM_Bank
    346  6927							;    ELSE
    347  6927		       a9 0d		      lda	#BANK_BOARD	; 2
    348  6929							;    ENDIF
    349  6929		       20 14 f8 	      jsr	GetBoardCharacter	;6+20(A)
    350  692c		       68		      pla
    351  692d		       a8		      tay
    352  692e
    353  692e		       a9 02		      lda	#CHARACTER_BOX
    354  6930		       e0 00		      cpx	#CHARACTER_BLANK
    355  6932		       f0 0d		      beq	canPushTarget
    356  6934
    357  6934		       e0 03		      cpx	#CHARACTER_TARGET
    358  6936		       f0 04		      beq	decreaseTargets
    359  6938		       e0 04		      cpx	#CHARACTER_TARGET2
    360  693a		       d0 9d		      bne	cannotPush
    361  693c
    362  693c							; Box is now on a target - so decrease the remaining targets
    363  693c
    364  693c		       20 02 fd    decreaseTargets jsr	DeRegisterTarget
    365  693f		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    366  6941		       48	   canPushTarget pha
    367  6942
    368  6942							; If the box *WAS* on a target (restoration character = CHARACTER_TARGET)
    369  6942							; then we increase targets (as there is one more to get)
    370  6942
    371  6942		       a5 d9		      lda	restorationCharacter
    372  6944		       c9 03		      cmp	#CHARACTER_TARGET
    373  6946		       d0 03		      bne	notOnTargetAlready
    374  6948
    375  6948							; increase the required targets as box is leaving one
    376  6948
    377  6948		       20 f8 fc 	      jsr	RegisterTarget
    378  694b
    379  694b				   notOnTargetAlready
    380  694b
    381  694b							; record the box takeback params for the player move to use
    382  694b
    383  694b		       86 91		      stx	TB_CHAR
    384  694d		       a5 87		      lda	POS_X
    385  694f		       85 8f		      sta	TB_PUSHX
    386  6951		       a5 88		      lda	POS_Y
    387  6953		       85 90		      sta	TB_PUSHY
    388  6955
    389  6955		       68		      pla		; new char to go on board in box's new position
    390  6956
    391  6956
    392  6956							;  IF MULTI_BANK_BOARD = YES
    393  6956							;		ldx RAM_Bank			  ; <-- this will never work calling from INITBANK!!!
    394  6956							;  ELSE
    395  6956		       a2 0d		      ldx	#BANK_BOARD	; 2
    396  6958							;  ENDIF
    397  6958		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)
    398  695b
    399  695b		       a5 8c		      lda	POS_VAR	; player's restoration character
    400  695d		       48		      pha
    401  695e
    402  695e							; Before the player moves to the new position, take away the box and replace with the
    403  695e							; character the box was sitting on (BLANK or TARGET). Then the player moves in "next"
    404  695e
    405  695e		       a5 8a		      lda	POS_Y_NEW
    406  6960		       85 88		      sta	POS_Y
    407  6962		       a5 89		      lda	POS_X_NEW
    408  6964		       85 87		      sta	POS_X
    409  6966		       a5 d9		      lda	restorationCharacter
    410  6968		       85 8c		      sta	POS_VAR
    411  696a		       20 df f8 	      jsr	PutCharacterAtXY	; put back BOX's restoration character
    412  696d
    413  696d		       68		      pla
    414  696e		       85 8c		      sta	POS_VAR
    415  6970
    416  6970							;START_SOUND SOUND_BOX
    417  6970
    418  6970							; Note: MovePlayer expects new position to be POS_X_NEW, POS_Y_NEW
    419  6970							; AND the current man's square to be ManX, ManY
    420  6970
    421  6970		       4c 33 f9 	      jmp	MovePlayer	; now there's a gap, player should move in
    422  6973
    423  6973
    424  6973							;------------------------------------------------------------------------------
    425  6973
    426  6973							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    427  6973							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    428  6973
    429  6973							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    430  6973
    431  6973							; if the creature dies then jump NextObject
    432  6973
    433  6973
    434  6973
    435  6973							;RDirY 	  .byte -1    ;,0,1,0
    436  6973							;RDirX 	  .byte 0,1   ;,0,-1
    437  6973							;DirPushModX	   .byte 0,-1,1,0
    438  6973							;DirPushModY	   .byte -1,0,0,1
    439  6973							;Directional	  .byte 1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    440  6973
    441  6973
    442  6973							;------------------------------------------------------------------------------
    443  6973
    444  6973							; the auto-calculation of these was causing DASM to get confused and abort assembling.
    445  6973							; I don't particularly know why; probably because of the level variable-size array and the values
    446  6973							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    447  6973
    448  6973		       00 00	   MANMODE_STARTUP =	0
    449  6973		       00 01	   MANMODE_NORMAL =	1
    450  6973		       00 02	   MANMODE_DEAD =	2
    451  6973		       00 03	   MANMODE_WAITING =	3
    452  6973		       00 04	   MANMODE_WAITING2 =	4
    453  6973		       00 05	   MANMODE_WAITING_NT =	5
    454  6973		       00 06	   MANMODE_WAITING_NT2 =	6
    455  6973		       00 07	   MANMODE_NEXTLEVEL =	7
    456  6973		       00 08	   MANMODE_NEXTLEVEL2 =	8
    457  6973		       00 09	   MANMODE_SWITCH =	9
    458  6973		       00 0a	   MANMODE_TURNAROUND =	10
    459  6973		       00 0b	   MANMODE_TURNAROUND2 =	11
    460  6973		       00 0c	   MANMODE_SWITCH2 =	12
    461  6973		       00 0d	   MANMODE_NEXTLEVEL3 =	13
    462  6973
    463  6973
    464  6973
    465  6973
      0  6973					      DEFINE_SUBROUTINE	ManProcess
      1  6973		       00 0d	   BANK_ManProcess =	_CURRENT_BANK
      2  6973					      SUBROUTINE
      3  6973				   ManProcess
    467  6973
    468  6973							; ManMode tells the player what it is currently doing.  State machine.
    469  6973
    470  6973							; Check the switches....
    471  6973							; RESET to restart this level
    472  6973							; SELECT to start next level
    473  6973
    474  6973		       ad 82 02 	      lda	SWCHB
    475  6976		       29 03		      and	#3
    476  6978		       aa		      tax
    477  6979		       bd 9c f1 	      lda	newMode,x
    478  697c		       30 02		      bmi	skipModeChange
    479  697e		       85 a1		      sta	ManMode
    480  6980				   skipModeChange
    481  6980
    482  6980		       20 00 f8 	      jsr	DrawTimeFromROM	; Z-flag == 0!
    483  6983
    484  6983		       38		      sec
    485  6984		       a5 b4		      lda	Throttle	;3
    486  6986		       e9 a0		      sbc	#MAX_THROTTLE	;2
    487  6988		       90 11		      bcc	DoNothing2	;2/3		 plenty of time left!
    488  698a		       85 b4		      sta	Throttle	;3 = 10	 save fractional 'left over' bit
    489  698c
    490  698c
    491  698c		       a4 a1		      ldy	ManMode
    492  698e		       b9 a0 f1 	      lda	ManActionLO,y
    493  6991		       85 d7		      sta	actionVector
    494  6993		       b9 ae f1 	      lda	ManActionHI,y
    495  6996		       85 d8		      sta	actionVector+1
    496  6998		       6c d7 00 	      jmp	(actionVector)
    497  699b
    498  699b		       60	   DoNothing2 rts
    499  699c
    500  699c		       ff 0c 04 ff newMode    .byte.b	-1, MANMODE_SWITCH2, MANMODE_WAITING2, -1
    501  69a0
    502  69a0				   ManActionLO
    503  69a0		       e3		      .byte.b	<manStartup	; 0		 no timer
    504  69a1		       11		      .byte.b	<normalMan	; 1		 timer
    505  69a2		       00		      .byte.b	<0	; 2		 timer
    506  69a3		       0c		      .byte.b	<waitingMan	; 3		 timer
    507  69a4		       0c		      .byte.b	<waitingManPress	; 4		 timer
    508  69a5		       0c		      .byte.b	<waitingMan	; 5		 no timer
    509  69a6		       0c		      .byte.b	<waitingManPress	; 6		 no timer
    510  69a7		       b9		      .byte.b	<nextLevelMan	; 7		 no timer
    511  69a8		       c7		      .byte.b	<nextLevelMan2	; 8		 no timer
    512  69a9		       de		      .byte.b	<switchLevels	; 9		 no timer
    513  69aa		       bc		      .byte.b	<TurnAround	; 10
    514  69ab		       d5		      .byte.b	<TurnAround2	; 10
    515  69ac		       c0		      .byte.b	<switchLevels2
    516  69ad		       d6		      .byte.b	<nextLevelMan3
    517  69ae
    518  69ae				   ManActionHI
    519  69ae		       f1		      .byte.b	>manStartup	; no timer
    520  69af		       f2		      .byte.b	>normalMan	; timer
    521  69b0		       00		      .byte.b	>0	; timer
    522  69b1		       f2		      .byte.b	>waitingMan	; timer
    523  69b2		       f2		      .byte.b	>waitingManPress	; timer
    524  69b3		       f2		      .byte.b	>waitingMan	; no timer
    525  69b4		       f2		      .byte.b	>waitingManPress	; no timer
    526  69b5		       fc		      .byte.b	>nextLevelMan	; no timer
    527  69b6		       fc		      .byte.b	>nextLevelMan2	; no timer
    528  69b7		       fc		      .byte.b	>switchLevels	;9  no timer
    529  69b8		       f1		      .byte.b	>TurnAround	; 10
    530  69b9		       f1		      .byte.b	>TurnAround2	; 10
    531  69ba		       fc		      .byte.b	>switchLevels2
    532  69bb		       fc		      .byte.b	>nextLevelMan3
    533  69bc
    534  69bc
      0  69bc					      DEFINE_SUBROUTINE	TurnAround
      1  69bc		       00 0d	   BANK_TurnAround =	_CURRENT_BANK
      2  69bc					      SUBROUTINE
      3  69bc				   TurnAround
    536  69bc
      0  69bc					      LOAD_ANIMATION	TURNAROUND
      1  69bc		       a9 b2		      lda	#<Animation_TURNAROUND
      2  69be		       85 9a		      sta	animation
      3  69c0		       a9 f0		      lda	#>Animation_TURNAROUND
      4  69c2		       85 9b		      sta	animation+1
      5  69c4		       a9 00		      lda	#0
      6  69c6		       85 9c		      sta	animation_delay
      7  69c8		       a9 0e		      lda	#ANIMATION_TURNAROUND_ID
      8  69ca		       85 a6		      sta	ManAnimationID
      9  69cc
    538  69cc
    539  69cc		       a5 a2		      lda	ManLastDirection
    540  69ce		       85 a3		      sta	ManTurnStart
    541  69d0
    542  69d0		       a9 0b		      lda	#MANMODE_TURNAROUND2
    543  69d2		       85 a1		      sta	ManMode
    544  69d4		       60		      rts
    545  69d5
      0  69d5					      DEFINE_SUBROUTINE	TurnAround2
      1  69d5		       00 0d	   BANK_TurnAround2 =	_CURRENT_BANK
      2  69d5					      SUBROUTINE
      3  69d5				   TurnAround2
    547  69d5
    548  69d5		       a5 a3		      lda	ManTurnStart
    549  69d7		       c5 a2		      cmp	ManLastDirection
    550  69d9		       f0 07		      beq	notTurnedYet
    551  69db
    552  69db		       a9 01		      lda	#MANMODE_NORMAL
    553  69dd		       85 a1		      sta	ManMode
    554  69df		       4c 11 f2 	      jmp	normalMan
    555  69e2
    556  69e2
    557  69e2		       60	   notTurnedYet rts
    558  69e3
    559  69e3
    560  69e3							;------------------------------------------------------------------------------
      0  69e3					      DEFINE_SUBROUTINE	manStartup
      1  69e3		       00 0d	   BANK_manStartup =	_CURRENT_BANK
      2  69e3					      SUBROUTINE
      3  69e3				   manStartup
    562  69e3
    563  69e3					      IF	WAIT_FOR_INITIAL_DRAW
    564  69e3							; Delay turning on the visible screen until the background has completed drawing.
    565  69e3							; This is simple - is there anything still in the draw stack?
    566  69e3		       a5 81		      lda	DrawStackPointer
    567  69e5		       10 04		      bpl	midDraw
    568  69e7		       a9 00		      lda	#0
    569  69e9		       85 ae		      sta	blankState
    570  69eb				   midDraw
    571  69eb					      ENDIF
    572  69eb
    573  69eb		       a5 9d		      lda	ManX
    574  69ed		       85 89		      sta	POS_X_NEW
    575  69ef		       a5 9e		      lda	ManY
    576  69f1		       85 8a		      sta	POS_Y_NEW
    577  69f3
    578  69f3		       a9 01		      lda	#MANMODE_NORMAL
    579  69f5		       85 a1		      sta	ManMode
    580  69f7
    581  69f7		       a9 00		      lda	#0
    582  69f9		       85 a8		      sta	idleCount
    583  69fb
      0  69fb					      LOAD_ANIMATION	IDLE
      1  69fb		       a9 42		      lda	#<Animation_IDLE
      2  69fd		       85 9a		      sta	animation
      3  69ff		       a9 f0		      lda	#>Animation_IDLE
      4  6a01		       85 9b		      sta	animation+1
      5  6a03		       a9 00		      lda	#0
      6  6a05		       85 9c		      sta	animation_delay
      7  6a07		       a9 02		      lda	#ANIMATION_IDLE_ID
      8  6a09		       85 a6		      sta	ManAnimationID
      9  6a0b
    585  6a0b
    586  6a0b				   RTS_CF
    587  6a0b		       60		      rts
    588  6a0c
    589  6a0c							;------------------------------------------------------------------------------
    590  6a0c
    591  6a0c				   waitingMan
    592  6a0c				   waitingManPress
    593  6a0c
    594  6a0c							;		  lda #50
    595  6a0c							;		  sta ColourTimer
    596  6a0c
    597  6a0c							; RESET gets here
    598  6a0c
    599  6a0c							;lda NextLevelTrigger
    600  6a0c							;ora #BIT_NEXTLIFE
    601  6a0c
    602  6a0c		       a9 00		      lda	#0
    603  6a0e		       85 c2		      sta	NextLevelTrigger
    604  6a10		       60		      rts
    605  6a11
    606  6a11
    607  6a11							;------------------------------------------------------------------------------
    608  6a11							; Normal man state
    609  6a11
      0  6a11					      DEFINE_SUBROUTINE	normalMan
      1  6a11		       00 0d	   BANK_normalMan =	_CURRENT_BANK
      2  6a11					      SUBROUTINE
      3  6a11				   normalMan
    611  6a11
    612  6a11							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    613  6a11							; before exiting via (for example) look-around option :)
    614  6a11
    615  6a11		       a5 9d		      lda	ManX
    616  6a13		       85 89		      sta	POS_X_NEW
    617  6a15		       a5 9e		      lda	ManY
    618  6a17		       85 8a		      sta	POS_Y_NEW
    619  6a19
    620  6a19							;------------------------------------------------------------------------------
    621  6a19							; Take-back is a press/release of the button, with the press being limited in duratino
    622  6a19							; to allow the action to be "cancelled". Meanwhile, a button press + direction triggers
    623  6a19							; "look-around mode"
    624  6a19
    625  6a19		       a5 4c		      lda	INPT4
    626  6a1b		       30 39		      bmi	noLook	; button?
    627  6a1d
    628  6a1d							; button pressed, so in looking-around mode
    629  6a1d
    630  6a1d		       a5 a5		      lda	LookingAround
    631  6a1f		       30 04		      bmi	LookAround
    632  6a21		       a2 ff		      ldx	#$FF
    633  6a23		       86 a5		      stx	LookingAround
    634  6a25				   LookAround
    635  6a25
    636  6a25							; Use the joystick as a window-scroller to change the viewport
    637  6a25
    638  6a25		       ad 80 02 	      lda	SWCHA	;BufferedJoystick
    639  6a28		       4a		      lsr
    640  6a29		       4a		      lsr
    641  6a2a		       4a		      lsr
    642  6a2b		       4a		      lsr
    643  6a2c		       a8		      tay
    644  6a2d
    645  6a2d							;lda #-1
    646  6a2d							;sta BufferedJoystick
    647  6a2d
    648  6a2d		       b9 d0 f2 	      lda	JoyMoveX,y
    649  6a30		       19 e0 f2 	      ora	JoyMoveY,y
    650  6a33		       f0 20		      beq	AbandonY
    651  6a35
    652  6a35		       a9 fe		      lda	#$FE
    653  6a37		       85 a5		      sta	LookingAround
    654  6a39		       a9 a1		      lda	#MAX_THROTTLE+1
    655  6a3b		       85 b4		      sta	Throttle	; IMMEDIATE reaction to any joystick!
    656  6a3d
    657  6a3d		       b9 d0 f2 	      lda	JoyMoveX,y
    658  6a40							;asl
    659  6a40		       18		      clc
    660  6a41		       65 97		      adc	BoardScrollX
    661  6a43		       c5 94		      cmp	BoardEdge_Right
    662  6a45		       b0 02		      bcs	AbandonX
    663  6a47		       85 97		      sta	BoardScrollX
    664  6a49
    665  6a49				   AbandonX
    666  6a49							;lda JoyMoveX,y
    667  6a49							;bne AbandonY			  ; don't allow diagonals!
    668  6a49
    669  6a49		       b9 e0 f2 	      lda	JoyMoveY,y
    670  6a4c							;asl
    671  6a4c		       18		      clc
    672  6a4d		       65 96		      adc	BoardScrollY
    673  6a4f		       c5 95		      cmp	BoardEdge_Bottom
    674  6a51		       b0 02		      bcs	AbandonY
    675  6a53		       85 96		      sta	BoardScrollY
    676  6a55
    677  6a55		       60	   AbandonY   rts
    678  6a56
    679  6a56		       a2 00	   noLook     ldx	#0
    680  6a58		       a5 a5		      lda	LookingAround
    681  6a5a		       c9 ff		      cmp	#$FF
    682  6a5c		       86 a5		      stx	LookingAround
    683  6a5e		       d0 03		      bne	bProcComp	; $FE means there was a lookaround, so skip
    684  6a60
    685  6a60							; button was presssed and now released and we didn't actually look around
    686  6a60							; so we do a take-back
    687  6a60
    688  6a60		       4c 13 fa 	      jmp	takebackRestoreEarlierPosition	;.. and rts
    689  6a63							;rts
    690  6a63
    691  6a63				   bProcComp
    692  6a63							;------------------------------------------------------------------------------
    693  6a63
    694  6a63		       a9 02		      lda	#ANIMATION_IDLE_ID
    695  6a65		       c5 a6		      cmp	ManAnimationID
    696  6a67		       f0 20		      beq	alreadyIdling
    697  6a69
    698  6a69		       a5 a4		      lda	ManPushCounter
    699  6a6b		       d0 1c		      bne	alreadyIdling
    700  6a6d
    701  6a6d		       e6 a8		      inc	idleCount
    702  6a6f		       a4 a8		      ldy	idleCount
    703  6a71		       c0 02		      cpy	#2
    704  6a73		       90 14		      bcc	alreadyIdling
    705  6a75
      0  6a75					      LOAD_ANIMATION	IDLE
      1  6a75		       a9 42		      lda	#<Animation_IDLE
      2  6a77		       85 9a		      sta	animation
      3  6a79		       a9 f0		      lda	#>Animation_IDLE
      4  6a7b		       85 9b		      sta	animation+1
      5  6a7d		       a9 00		      lda	#0
      6  6a7f		       85 9c		      sta	animation_delay
      7  6a81		       a9 02		      lda	#ANIMATION_IDLE_ID
      8  6a83		       85 a6		      sta	ManAnimationID
      9  6a85
    707  6a85
    708  6a85		       a9 00		      lda	#0
    709  6a87		       85 a8		      sta	idleCount
    710  6a89				   alreadyIdling
    711  6a89
    712  6a89		       a5 a2		      lda	ManLastDirection
    713  6a8b		       29 07		      and	#DIRECTION_BITS
    714  6a8d		       a8		      tay
    715  6a8e
    716  6a8e		       a5 92		      lda	BufferedJoystick	; joystick
    717  6a90		       85 93		      sta	PreviousJoystick
    718  6a92							;and BufferedJoystick+1
    719  6a92
    720  6a92		       a2 00		      ldx	#0
    721  6a94		       0a	   .loopDirs  asl
    722  6a95		       90 06		      bcc	.dirFound
    723  6a97		       88		      dey
    724  6a98		       e8		      inx
    725  6a99		       e0 04		      cpx	#4
    726  6a9b		       d0 f7		      bne	.loopDirs
    727  6a9d
    728  6a9d							; no direction!
    729  6a9d
    730  6a9d							;inc BGColour
    731  6a9d
    732  6a9d
    733  6a9d							;lda #MAX_THROTTLE+1
    734  6a9d							;sta Throttle		     ; IMMEDIATE reaction to any joystick!
    735  6a9d
    736  6a9d				   .dirFound
    737  6a9d
    738  6a9d		       a9 ff		      lda	#-1
    739  6a9f		       85 92		      sta	BufferedJoystick
    740  6aa1
    741  6aa1		       bd f7 f2 	      lda	anim_direction,x
    742  6aa4		       30 0d		      bmi	dontChange
    743  6aa6		       45 a2		      eor	ManLastDirection
    744  6aa8		       29 08		      and	#%1000
    745  6aaa		       f0 07		      beq	dontChange
    746  6aac
    747  6aac							; at this point we want to activate the stand/turn animation before continuing
    748  6aac
    749  6aac		       a9 0a		      lda	#MANMODE_TURNAROUND
    750  6aae		       85 a1		      sta	ManMode
    751  6ab0		       4c bc f1 	      jmp	TurnAround
    752  6ab3
    753  6ab3
    754  6ab3
    755  6ab3
    756  6ab3							;bne noMovement ;kipMove
    757  6ab3				   dontChange
    758  6ab3
    759  6ab3
    760  6ab3
    761  6ab3		       18		      clc
    762  6ab4		       a5 89		      lda	POS_X_NEW
    763  6ab6		       7d f2 f2 	      adc	JoyDirX,x
    764  6ab9		       85 89		      sta	POS_X_NEW
    765  6abb
    766  6abb		       18		      clc
    767  6abc		       a5 8a		      lda	POS_Y_NEW
    768  6abe		       7d f0 f2 	      adc	JoyDirY,x
    769  6ac1		       85 8a		      sta	POS_Y_NEW
    770  6ac3
    771  6ac3
    772  6ac3		       98	   skipMove   tya
    773  6ac4		       f0 09		      beq	noMovement	; animation OK
    774  6ac6
    775  6ac6		       8a		      txa
    776  6ac7		       45 a2		      eor	ManLastDirection
    777  6ac9		       29 07		      and	#DIRECTION_BITS
    778  6acb		       45 a2		      eor	ManLastDirection
    779  6acd		       85 a2		      sta	ManLastDirection
    780  6acf
    781  6acf				   noMovement
    782  6acf
    783  6acf
    784  6acf		       60	   DFS_rts    rts
    785  6ad0
    786  6ad0
    787  6ad0							;			RLDU RLD  RL U RL   R DU R D  R  U R	 LDU  LD   L U	L     DU   D	 U
    788  6ad0							;			0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
    789  6ad0		       00 00 00 00*JoyMoveX   .byte.b	0, 0, 0, 0, 0, 1, 1, 1, 0, -1, -1, -1, 0, 0, 0, 0
    790  6ae0		       00 00 00 00*JoyMoveY   .byte.b	0, 0, 0, 0, 0, 1, -1, 0, 0, 1, -1, 0, 0, 1, -1, 0
    791  6af0
    792  6af0				   JoyDirY
    793  6af0		       00 00		      .byte.b	0,0	;,1,-1,0
    794  6af2				   JoyDirX
    795  6af2		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
    796  6af7
    797  6af7							;Data Bit  Direction Player
    798  6af7							;		 D7	   right	  P0  D4
    799  6af7							;		 D6	   left      P0  D3
    800  6af7							;		 D5	   down      P0  D2
    801  6af7							;		 D4	   up	     P0  D1
    802  6af7							;     A "0" in a data bit indicates the joystick has been moved
    803  6af7							;     to close that switch.  All "1's" in a player's nibble
    804  6af7							;     indicates that joystick is not moving.
    805  6af7
    806  6af7							;0  0000 x
    807  6af7							;1  0001 x
    808  6af7							;2  0010 x
    809  6af7							;3  0011 x
    810  6af7							;4  0100 x
    811  6af7							;5  0101 right down
    812  6af7							;6  0110 right up
    813  6af7							;7  0111 right
    814  6af7							;8  1000 x
    815  6af7							;9  1001 left down
    816  6af7							;10  1010 left up
    817  6af7							;11  1011 left
    818  6af7							;12  1100 x
    819  6af7							;13  1101 down
    820  6af7							;14  1110 up
    821  6af7							;15  1111 none
    822  6af7
    823  6af7		       00 08 80 80*anim_direction .byte.b	0,%1000,128,128,128
    824  6afc
    825  6afc							;------------------------------------------------------------------------------
    826  6afc
    827  6afc
      0  6afc					      DEFINE_SUBROUTINE	DrawFullScreen	; @31✅
      1  6afc		       00 0d	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  6afc					      SUBROUTINE
      3  6afc				   DrawFullScreen
    829  6afc
    830  6afc		       ad 84 02 	      lda	INTIM	; 4
    831  6aff		       c9 29		      cmp	#SEGTIME_BDF	; 2
    832  6b01		       90 cc		      bcc	DFS_rts	; 2/3 ==> [31]+(9)+6rts = 46✅ on abort
    833  6b03
    834  6b03		       a9 f4		      lda	#>( DrawFlag + RAM_WRITE )	; 2
    835  6b05		       85 d8		      sta	BDF_DrawFlagAddress+1	; 3
    836  6b07		       85 da		      sta	BDF_DrawFlagAddress2+1	; 3 = 8✅
    837  6b09
    838  6b09		       ba		      tsx		; 2
    839  6b0a		       86 e1		      stx	DHS_Stack	; 3
    840  6b0c
    841  6b0c		       e6 86		      inc	ScreenDrawPhase	; 5
    842  6b0e
    843  6b0e		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
    844  6b0f		       a2 08		      ldx	#SCREEN_LINES	; 2
    845  6b11		       8a		      txa		; 2 = 24✅
    846  6b12
    847  6b12							; fall through
    848  6b12
    849  6b12							;------------------------------------------------------------------------------
    850  6b12
    851  6b12							; @311✅ (from loop)
    852  6b12							; @24✅ (fall through)
    853  6b12
    854  6b12							; 8 lines x 311 + (24)
    855  6b12							; = 2512
    856  6b12							; = 39 :)
    857  6b12
      0  6b12					      DEFINE_SUBROUTINE	DrawScreenRowPreparation
      1  6b12		       00 0d	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  6b12					      SUBROUTINE
      3  6b12				   DrawScreenRowPreparation
    859  6b12
    860  6b12							;clc
    861  6b12		       ca		      dex		; 2
    862  6b13		       86 e0		      stx	DHS_Line	; 3
    863  6b15		       65 96		      adc	BoardScrollY	; 3	     the Y offset of screen into board
    864  6b17		       a8		      tay		; 2 = 10✅
    865  6b18
    866  6b18							;clc
    867  6b18		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
    868  6b1b		       65 97		      adc	BoardScrollX	; 3	     the X offset of screen into board
    869  6b1d		       85 db		      sta	BDF_BoardAddress	; 3
    870  6b1f		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    871  6b21		       85 dd		      sta	BDF_BoardAddress2	; 3 = 15✅
    872  6b23
    873  6b23		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
    874  6b26		       85 dc		      sta	BDF_BoardAddress+1	; 3
    875  6b28		       85 de		      sta	BDF_BoardAddress2+1	; 3 = 10 @35✅
    876  6b2a
    877  6b2a		       bd a4 f0 	      lda	DrawLineStartLO,x	; 4
    878  6b2d		       85 d7		      sta	BDF_DrawFlagAddress	; 3
    879  6b2f		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    880  6b31		       85 d9		      sta	BDF_DrawFlagAddress2	; 3 = 12✅
    881  6b33
    882  6b33							;    IF MULTI_BANK_BOARD = YES
    883  6b33							;		  lda BoardBank-1,y		  ; 4
    884  6b33							;		  sta BDF_BoardBank		  ; 3
    885  6b33							;    ENDIF
    886  6b33		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
    887  6b35		       4c 87 fb 	      jmp	CopyRow2	; 3 = 12 @59✅
    888  6b38
    889  6b38							;------------------------------------------------------------------------------
    890  6b38
      0  6b38					      DEFINE_SUBROUTINE	EndOfLevel
      1  6b38		       00 0d	   BANK_EndOfLevel =	_CURRENT_BANK
      2  6b38					      SUBROUTINE
      3  6b38				   EndOfLevel
    892  6b38
    893  6b38		       a9 0a		      lda	#10
    894  6b3a		       85 a9		      sta	DelayEndOfLevel
    895  6b3c
    896  6b3c		       a6 80		      ldx	Platform
    897  6b3e		       bd 5c f3 	      lda	FlashColour,x	;+4,x
    898  6b41		       85 b1		      sta	BGColour	;ColourFlash		      ; green
    899  6b43		       a9 06		      lda	#6
    900  6b45		       85 c1		      sta	ColourTimer
    901  6b47
    902  6b47
      0  6b47					      LOAD_ANIMATION	WIN
      1  6b47		       a9 1c		      lda	#<Animation_WIN
      2  6b49		       85 9a		      sta	animation
      3  6b4b		       a9 f0		      lda	#>Animation_WIN
      4  6b4d		       85 9b		      sta	animation+1
      5  6b4f		       a9 00		      lda	#0
      6  6b51		       85 9c		      sta	animation_delay
      7  6b53		       a9 04		      lda	#ANIMATION_WIN_ID
      8  6b55		       85 a6		      sta	ManAnimationID
      9  6b57
    904  6b57
    905  6b57		       a9 08		      lda	#MANMODE_NEXTLEVEL2
    906  6b59		       85 a1		      sta	ManMode
    907  6b5b		       60		      rts
    908  6b5c
    909  6b5c
    910  6b5c		       c4 c4 54 54 FlashColour .byte.b	$C4, $C4, $54, $54
    911  6b60
    912  6b60
      0  6b60					      DEFINE_SUBROUTINE	IMC
      1  6b60		       00 0d	   BANK_IMC   =	_CURRENT_BANK
      2  6b60					      SUBROUTINE
      3  6b60				   IMC
    914  6b60
    915  6b60		       18		      clc
    916  6b61		       a5 b8		      lda	takebackIndex
    917  6b63		       69 01		      adc	#1
    918  6b65		       29 3f		      and	#TAKEBACK_MASK
    919  6b67		       85 b8		      sta	takebackIndex
    920  6b69		       c5 b9		      cmp	takebackBaseIndex
    921  6b6b		       d0 06		      bne	baseOK
    922  6b6d		       69 00		      adc	#0
    923  6b6f		       29 3f		      and	#TAKEBACK_MASK
    924  6b71		       85 b9		      sta	takebackBaseIndex
    925  6b73				   baseOK
    926  6b73
    927  6b73		       f8		      sed
    928  6b74		       18		      clc
    929  6b75		       a5 b6		      lda	BCD_moveCounter
    930  6b77		       69 01		      adc	#1
    931  6b79		       85 b6		      sta	BCD_moveCounter
    932  6b7b		       a5 b7		      lda	BCD_moveCounter+1
    933  6b7d		       69 00		      adc	#0
    934  6b7f		       85 b7		      sta	BCD_moveCounter+1
    935  6b81		       d8		      cld
    936  6b82
    937  6b82		       60		      rts
    938  6b83
    939  6b83							;------------------------------------------------------------------------------
    940  6b83
      0  6b83					      DEFINE_SUBROUTINE	VectorProcess	;=19 + 13, = 31✅ minimum
      1  6b83		       00 0d	   BANK_VectorProcess =	_CURRENT_BANK
      2  6b83					      SUBROUTINE
      3  6b83				   VectorProcess
    942  6b83
    943  6b83		       bd 91 f3 	      lda	OSPointerHI,x	; 4
    944  6b86		       85 d8		      sta	POS_Vector+1	; 3
    945  6b88		       bd 90 f3 	      lda	OSPointerLO,x	; 4
    946  6b8b		       85 d7		      sta	POS_Vector	; 3
    947  6b8d
    948  6b8d		       6c d7 00 	      jmp	(POS_Vector)	; 5 = 19	  vector to processor for particular object type
    949  6b90
    950  6b90							; earliest abort from process = +13
    951  6b90
    952  6b90							;		 NOTE: Bank is either INITBANK or FIXED.
    953  6b90							;------------------------------------------------------------------------------
    954  6b90
    955  6b90
    956  6b90				   OBJTYPE    SET	0
    957  6b90					      MAC	define
    958  6b90				   TYPE_{1}   =	OBJTYPE
    959  6b90				   OBJTYPE    .SET	OBJTYPE + 1
    960  6b90					      ENDM
    961  6b90
    962  6b90							; If adding/removing types, the following must also be updated...
    963  6b90							;   InitialFace[...]		     in UnpackLevel.asm
    964  6b90							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
    965  6b90							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
    966  6b90							;   OSPointerLO[...]		     in BANK_INITBANK.asm
    967  6b90							;   OSPointerHI[...]		     in BANK_INITBANK.asm
    968  6b90							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
    969  6b90							;   Sortable[...]		     in BANK_FIXED.asm
    970  6b90
    971  6b90
      0  6b90					      DEFINE	MAN
      1  6b90		       00 00	   TYPE_MAN   =	OBJTYPE
      2  6b90				   OBJTYPE    .SET	OBJTYPE + 1
    973  6b90							;DEFINE CIRCLE
    974  6b90							;DEFINE CIRCLE_HELPER
    975  6b90							;DEFINE CIRCLE_DRAWER
    976  6b90
      0  6b90					      DEFINE	MAXIMUM
      1  6b90		       00 01	   TYPE_MAXIMUM =	OBJTYPE
      2  6b90				   OBJTYPE    .SET	OBJTYPE + 1
    978  6b90
    979  6b90
      0  6b90					      DEFINE_SUBROUTINE	OSPointerLO
      1  6b90		       00 0d	   BANK_OSPointerLO =	_CURRENT_BANK
      2  6b90					      SUBROUTINE
      3  6b90				   OSPointerLO
    981  6b90		       a9		      .byte.b	<PROCESS_MAN
    982  6b91							;.byte <PROCESS_CIRCLE
    983  6b91							;.byte <PROCESS_CIRCLE_HELPER
    984  6b91
    985  6b91				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
    986  6b91				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
    987  6b91				  -	      ERR
    988  6b91					      ENDIF
    989  6b91
    990  6b91
      0  6b91					      DEFINE_SUBROUTINE	OSPointerHI
      1  6b91		       00 0d	   BANK_OSPointerHI =	_CURRENT_BANK
      2  6b91					      SUBROUTINE
      3  6b91				   OSPointerHI
    992  6b91		       f8		      .byte.b	>PROCESS_MAN
    993  6b92							;.byte >PROCESS_CIRCLE
    994  6b92							;.byte >PROCESS_CIRCLE_HELPER
    995  6b92
    996  6b92				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
    997  6b92				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
    998  6b92				  -	      ERR
    999  6b92					      ENDIF
   1000  6b92
   1001  6b92							;------------------------------------------------------------------------------
   1002  6b92
      0  6b92					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  6b92		       00 0d	   BANK_MoveVecLO =	_CURRENT_BANK
      2  6b92					      SUBROUTINE
      3  6b92				   MoveVecLO
   1004  6b92
   1005  6b92		       8e		      .byte.b	<MOVE_BLANK
   1006  6b93		       8e		      .byte.b	<MOVE_SOIL
   1007  6b94		       01		      .byte.b	<MOVE_BOX
   1008  6b95		       8e		      .byte.b	<MOVE_TARGET
   1009  6b96		       8e		      .byte.b	<MOVE_TARGET
   1010  6b97		       ec		      .byte.b	<MOVE_GENERIC	;man occupied
   1011  6b98		       ec		      .byte.b	<MOVE_GENERIC	;steel
   1012  6b99		       ec		      .byte.b	<MOVE_GENERIC	;wall
   1013  6b9a		       0a		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
   1014  6b9b		       0a		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
   1015  6b9c		       ec		      .byte.b	<MOVE_GENERIC	;nogo
   1016  6b9d		       8e		      .byte.b	<MOVE_TARGET	;1
   1017  6b9e		       8e		      .byte.b	<MOVE_TARGET	;3
   1018  6b9f		       8e		      .byte.b	<MOVE_TARGET	;5
   1019  6ba0		       8e		      .byte.b	<MOVE_TARGET	;7
   1020  6ba1
   1021  6ba1				  -	      if	DIGITS
   1022  6ba1				  -	      REPEAT	10	; DIGITS 0-9
   1023  6ba1				  -	      .byte	<MOVE_BLANK
   1024  6ba1				  -	      REPEND
   1025  6ba1					      endif
   1026  6ba1
   1027  6ba1				  -	      IF	* - MoveVecLO != CHARACTER_MAXIMUM
   1028  6ba1				  -	      ECHO	"ERROR: Incorrect number of entries in MoveVecLO table!"
   1029  6ba1				  -	      ERR
   1030  6ba1					      ENDIF
   1031  6ba1
   1032  6ba1
      0  6ba1					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  6ba1		       00 0d	   BANK_MoveVecHI =	_CURRENT_BANK
      2  6ba1					      SUBROUTINE
      3  6ba1				   MoveVecHI
   1034  6ba1
   1035  6ba1		       f9		      .byte.b	>MOVE_BLANK
   1036  6ba2		       f9		      .byte.b	>MOVE_SOIL
   1037  6ba3		       fa		      .byte.b	>MOVE_BOX
   1038  6ba4		       f9		      .byte.b	>MOVE_TARGET
   1039  6ba5		       f9		      .byte.b	>MOVE_TARGET
   1040  6ba6		       f9		      .byte.b	>MOVE_GENERIC	;man occupied
   1041  6ba7		       f9		      .byte.b	>MOVE_GENERIC	;steel
   1042  6ba8		       f9		      .byte.b	>MOVE_GENERIC	;wall
   1043  6ba9		       fa		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
   1044  6baa		       fa		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
   1045  6bab		       f9		      .byte.b	>MOVE_GENERIC	;nogo
   1046  6bac		       f9		      .byte.b	>MOVE_TARGET	;1
   1047  6bad		       f9		      .byte.b	>MOVE_TARGET	;3
   1048  6bae		       f9		      .byte.b	>MOVE_TARGET	;5
   1049  6baf		       f9		      .byte.b	>MOVE_TARGET	; 7
   1050  6bb0
   1051  6bb0				  -	      if	DIGITS
   1052  6bb0				  -	      REPEAT	10	; DIGITS 0-9
   1053  6bb0				  -	      .byte	>MOVE_BLANK
   1054  6bb0				  -	      REPEND
   1055  6bb0					      endif
   1056  6bb0
   1057  6bb0				  -	      IF	* - MoveVecHI != CHARACTER_MAXIMUM
   1058  6bb0				  -	      ECHO	"ERROR: Incorrect number of entries in MoveVecHI table!"
   1059  6bb0				  -	      ERR
   1060  6bb0					      ENDIF
   1061  6bb0
   1062  6bb0							;------------------------------------------------------------------------------
   1063  6bb0
      0  6bb0					      DEFINE_SUBROUTINE	SoundFX
      1  6bb0		       00 0d	   BANK_SoundFX =	_CURRENT_BANK
      2  6bb0					      SUBROUTINE
      3  6bb0				   SoundFX
------- FILE sound/intro1_player.asm LEVEL 3 PASS 3
      0  6bb0					      include	"sound/intro1_player.asm"
      1  6bb0							; TIATracker music player
      2  6bb0							; Copyright 2016 Andre "Kylearan" Wichmann
      3  6bb0							; Website: https://bitbucket.org/kylearan/tiatracker
      4  6bb0							; Email: andre.wichmann@gmx.de
      5  6bb0							;
      6  6bb0							; Licensed under the Apache License, Version 2.0 (the "License");
      7  6bb0							; you may not use this file except in compliance with the License.
      8  6bb0							; You may obtain a copy of the License at
      9  6bb0							;
     10  6bb0							;   http://www.apache.org/licenses/LICENSE-2.0
     11  6bb0							;
     12  6bb0							; Unless required by applicable law or agreed to in writing, software
     13  6bb0							; distributed under the License is distributed on an "AS IS" BASIS,
     14  6bb0							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  6bb0							; See the License for the specific language governing permissions and
     16  6bb0							; limitations under the License.
     17  6bb0
     18  6bb0							; Song author:
     19  6bb0							; Song name:
     20  6bb0
     21  6bb0							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  6bb0
     23  6bb0							; =====================================================================
     24  6bb0							; TIATracker Player
     25  6bb0							; =====================================================================
     26  6bb0				   tt_PlayerStart
     27  6bb0
     28  6bb0							; PLANNED PLAYER VARIANTS:
     29  6bb0							; - RAM, speed, player ROM: c0/c1 patterns have same length
     30  6bb0							; - RAM: Pack 2 values (out of cur_pat_index, cur_note_index, envelope_index)
     31  6bb0							;	 into one and use lsr/asl to unpack them, allowing only ranges of
     32  6bb0							;	 16/16 or 32/8 for them, depending on number of patterns, max
     33  6bb0							;	 pattern size and max ADSR size
     34  6bb0							; - ROM: Check if tt_SequenceTable can hold ptrs directly without indexing
     35  6bb0							;	 tt_PatternPtrLo/Hi. Can be smaller if not many patterns get repeated
     36  6bb0							;	 (saves table and decode routine)
     37  6bb0							; - Speed: Inline tt_CalcInsIndex
     38  6bb0							; - Speed: Store ptr to current note in RAM instead of reconstructing it?
     39  6bb0							;	 Might also save the need for cur_note_index
     40  6bb0
     41  6bb0
     42  6bb0							; ---------------------------------------------------------------------
     43  6bb0							; Helper macro: Retrieves current note. May advance pattern if needed.
     44  6bb0							; Becomes a subroutine if TT_USE_OVERLAY is used.
     45  6bb0							; ---------------------------------------------------------------------
     46  6bb0					      MAC	tt_fetch_current_note
     47  6bb0							; construct ptr to pattern
     48  6bb0				   .constructPatPtr
     49  6bb0					      ldy	tt_cur_pat_index_c0,x	; get current pattern (index into tt_SequenceTable)
     50  6bb0					      lda	tt_SequenceTable,y
     51  6bb0					      IF	TT_USE_GOTO = 1
     52  6bb0					      bpl	.noPatternGoto
     53  6bb0					      and	#%01111111	; mask out goto bit to get pattern number
     54  6bb0					      sta	tt_cur_pat_index_c0,x	; store goto'ed pattern index
     55  6bb0					      bpl	.constructPatPtr	; unconditional
     56  6bb0				   .noPatternGoto
     57  6bb0					      ENDIF
     58  6bb0					      tay
     59  6bb0					      lda	tt_PatternPtrLo,y
     60  6bb0					      sta	tt_ptr
     61  6bb0					      lda	tt_PatternPtrHi,y
     62  6bb0					      sta	tt_ptr+1
     63  6bb0							; get new note
     64  6bb0					      IF	TT_USE_OVERLAY = 0
     65  6bb0					      ldy	tt_cur_note_index_c0,x
     66  6bb0					      ELSE
     67  6bb0							; If the V flag is set and if the new note is an instrument,
     68  6bb0							; it means it got pre-fetched by an overlay percussion, it has
     69  6bb0							; to remain in sustain.
     70  6bb0					      clv
     71  6bb0							; check if note had been pre-fetched by overlay perc already
     72  6bb0					      lda	tt_cur_note_index_c0,x
     73  6bb0					      bpl	.notPrefetched
     74  6bb0							; If so, remove flag
     75  6bb0					      and	#%01111111
     76  6bb0					      sta	tt_cur_note_index_c0,x
     77  6bb0							; Set V flag for later
     78  6bb0					      bit	tt_Bit6Set
     79  6bb0				   .notPrefetched
     80  6bb0					      tay
     81  6bb0					      ENDIF
     82  6bb0					      lda	(tt_ptr),y
     83  6bb0							; pre-process new note
     84  6bb0							; 7..5: instrument (1..7), 4..0 (0..31): frequency
     85  6bb0							; 0/0: End of pattern
     86  6bb0					      bne	.noEndOfPattern
     87  6bb0							; End of pattern: Advance to next pattern
     88  6bb0					      sta	tt_cur_note_index_c0,x	; a is 0
     89  6bb0					      inc	tt_cur_pat_index_c0,x
     90  6bb0					      bne	.constructPatPtr	; unconditional
     91  6bb0				   .noEndOfPattern
     92  6bb0					      ENDM
     93  6bb0
     94  6bb0
     95  6bb0							; ---------------------------------------------------------------------
     96  6bb0							; Music player entry. Call once per frame.
     97  6bb0							; ---------------------------------------------------------------------
     98  6bb0				   tt_Player  SUBROUTINE
     99  6bb0							; ==================== Sequencer ====================
    100  6bb0							; Decrease speed timer
    101  6bb0		       c6 cc		      dec	tt_timer
    102  6bb2		       10 6e		      bpl	.noNewNote
    103  6bb4
    104  6bb4							; Timer ran out: Do sequencer
    105  6bb4							; Advance to next note
    106  6bb4		       a2 01		      ldx	#1	; 2 channels
    107  6bb6				   .advanceLoop
    108  6bb6					      IF	TT_USE_OVERLAY = 1
    109  6bb6		       20 cc f3 	      jsr	tt_FetchNote
    110  6bb9				  -	      ELSE
    111  6bb9				  -	      TT_FETCH_CURRENT_NOTE
    112  6bb9					      ENDIF
    113  6bb9							; Parse new note from pattern
    114  6bb9		       c9 10		      cmp	#TT_INS_PAUSE
    115  6bbb					      IF	TT_USE_SLIDE = 0
    116  6bbb		       90 55		      bcc	.finishedNewNote
    117  6bbd		       d0 3d		      bne	.newNote
    118  6bbf				  -	      ELSE
    119  6bbf				  -	      beq	.pause
    120  6bbf				  -	      bcs	.newNote
    121  6bbf				  -
    122  6bbf				  -			; --- slide/hold ---
    123  6bbf				  -			; Adjust frequency and hold note in sustain.
    124  6bbf				  -			; composer/tracker has to make sure that no unwanted
    125  6bbf				  -			; under/overflow happens.
    126  6bbf				  -			; Note: f = f + (8-(16-x)) = x + f - 8
    127  6bbf				  -	      adc	tt_cur_ins_c0,x	; carry is clear after cmp
    128  6bbf				  -	      sec
    129  6bbf				  -	      sbc	#8
    130  6bbf				  -	      sta	tt_cur_ins_c0,x
    131  6bbf				  -	      bcs	.finishedNewNote	; unconditional, since legally no underflow can happen (ins>0 or HOLD for ins=0)
    132  6bbf					      ENDIF
    133  6bbf
    134  6bbf							; --- pause ---
    135  6bbf				   .pause
    136  6bbf							; Get release index for current instrument. Since a pause can
    137  6bbf							; only follow an instrument, we don't need to handle percussion
    138  6bbf							; or commands.
    139  6bbf		       b5 d3		      lda	tt_cur_ins_c0,x
    140  6bc1		       20 5a f4 	      jsr	tt_CalcInsIndex
    141  6bc4		       b9 9c f4 	      lda	tt_InsReleaseIndexes-1,y	; -1 b/c instruments start at #1
    142  6bc7							; Put it into release. Skip junk byte so index no longer indicates
    143  6bc7							; sustain phase.
    144  6bc7		       18		      clc
    145  6bc8		       69 01		      adc	#1
    146  6bca		       90 44		      bcc	.storeADIndex	; unconditional
    147  6bcc
    148  6bcc							; ---------------------------------------------------------------------
    149  6bcc							; Helper subroutine to minimize ROM footprint. Will be inlined if
    150  6bcc							; TT_USE_OVERLAY is not used.
    151  6bcc							; Interleaved here so player can be inlined.
    152  6bcc							; ---------------------------------------------------------------------
    153  6bcc					      IF	TT_USE_OVERLAY = 1
    154  6bcc				   tt_FetchNote
      0  6bcc					      TT_FETCH_CURRENT_NOTE
      1  6bcc
      2  6bcc				   .constructPatPtr
      3  6bcc		       b4 cd		      ldy	tt_cur_pat_index_c0,x
      4  6bce		       b9 af f5 	      lda	tt_SequenceTable,y
      5  6bd1					      IF	TT_USE_GOTO = 1
      6  6bd1		       10 06		      bpl	.noPatternGoto
      7  6bd3		       29 7f		      and	#%01111111
      8  6bd5		       95 cd		      sta	tt_cur_pat_index_c0,x
      9  6bd7		       10 f3		      bpl	.constructPatPtr
     10  6bd9				   .noPatternGoto
     11  6bd9					      ENDIF
     12  6bd9		       a8		      tay
     13  6bda		       b9 a5 f5 	      lda	tt_PatternPtrLo,y
     14  6bdd		       85 d5		      sta	tt_ptr
     15  6bdf		       b9 aa f5 	      lda	tt_PatternPtrHi,y
     16  6be2		       85 d6		      sta	tt_ptr+1
     17  6be4
     18  6be4				  -	      IF	TT_USE_OVERLAY = 0
     19  6be4				  -	      ldy	tt_cur_note_index_c0,x
     20  6be4					      ELSE
     21  6be4
     22  6be4
     23  6be4
     24  6be4		       b8		      clv
     25  6be5
     26  6be5		       b5 cf		      lda	tt_cur_note_index_c0,x
     27  6be7		       10 07		      bpl	.notPrefetched
     28  6be9
     29  6be9		       29 7f		      and	#%01111111
     30  6beb		       95 cf		      sta	tt_cur_note_index_c0,x
     31  6bed
     32  6bed		       2c 60 f4 	      bit	tt_Bit6Set
     33  6bf0				   .notPrefetched
     34  6bf0		       a8		      tay
     35  6bf1					      ENDIF
     36  6bf1		       b1 d5		      lda	(tt_ptr),y
     37  6bf3
     38  6bf3
     39  6bf3
     40  6bf3		       d0 06		      bne	.noEndOfPattern
     41  6bf5
     42  6bf5		       95 cf		      sta	tt_cur_note_index_c0,x
     43  6bf7		       f6 cd		      inc	tt_cur_pat_index_c0,x
     44  6bf9		       d0 d1		      bne	.constructPatPtr
     45  6bfb				   .noEndOfPattern
    156  6bfb		       60		      rts
    157  6bfc					      ENDIF
    158  6bfc
    159  6bfc
    160  6bfc							; --- start instrument or percussion ---
    161  6bfc				   .newNote
    162  6bfc		       95 d3		      sta	tt_cur_ins_c0,x	; set new instrument
    163  6bfe							; Instrument or percussion?
    164  6bfe		       c9 20		      cmp	#TT_FREQ_MASK+1
    165  6c00		       b0 06		      bcs	.startInstrument
    166  6c02
    167  6c02							; --- start percussion ---
    168  6c02							; Get index of envelope
    169  6c02		       a8		      tay
    170  6c03							; -TT_FIRST_PERC because percussion start with TT_FIRST_PERC
    171  6c03		       b9 c0 f4 	      lda	tt_PercIndexes-TT_FIRST_PERC,y
    172  6c06		       d0 08		      bne	.storeADIndex	; unconditional, since index values are >0
    173  6c08
    174  6c08							; --- start instrument ---
    175  6c08				   .startInstrument
    176  6c08					      IF	TT_USE_OVERLAY = 1
    177  6c08							; If V flag is set, this note had been pre-fetched. That means
    178  6c08							; it should remain in sustain.
    179  6c08		       70 08		      bvs	.finishedNewNote
    180  6c0a					      ENDIF
    181  6c0a							; Put note into attack/decay
    182  6c0a		       20 5a f4 	      jsr	tt_CalcInsIndex
    183  6c0d		       b9 92 f4 	      lda	tt_InsADIndexes-1,y	; -1 because instruments start at #1
    184  6c10				   .storeADIndex
    185  6c10		       95 d1		      sta	tt_envelope_index_c0,x
    186  6c12
    187  6c12							; --- Finished parsing new note ---
    188  6c12				   .finishedNewNote
    189  6c12							; increase note index into pattern
    190  6c12		       f6 cf		      inc	tt_cur_note_index_c0,x
    191  6c14							; loop over channels
    192  6c14				   .sequencerNextChannel
    193  6c14		       ca		      dex
    194  6c15		       10 9f		      bpl	.advanceLoop
    195  6c17
    196  6c17							; Reset timer value
    197  6c17				  -	      IF	TT_GLOBAL_SPEED = 0
    198  6c17				  -			; Get timer value for current pattern in channel 0
    199  6c17				  -	      ldx	tt_cur_pat_index_c0	; get current pattern (index into tt_SequenceTable)
    200  6c17				  -	      ldy	tt_SequenceTable,x	; Current pattern index now in y
    201  6c17				  -	      IF	TT_USE_FUNKTEMPO = 0
    202  6c17				  -	      lda	tt_PatternSpeeds,y
    203  6c17				  -	      sta	tt_timer
    204  6c17				  -	      ELSE
    205  6c17				  -			; Test for odd/even frame
    206  6c17				  -	      lda	tt_cur_note_index_c0
    207  6c17				  -	      lsr
    208  6c17				  -	      lda	tt_PatternSpeeds,y	; does not affect carry flag
    209  6c17				  -	      bcc	.evenFrame
    210  6c17				  -	      and	#$0f	; does not affect carry flag
    211  6c17				  -	      bcs	.storeFunkTempo
    212  6c17				  -.evenFrame
    213  6c17				  -	      lsr
    214  6c17				  -	      lsr
    215  6c17				  -	      lsr
    216  6c17				  -	      lsr
    217  6c17				  -.storeFunkTempo
    218  6c17				  -	      sta	tt_timer
    219  6c17				  -	      ENDIF		; TT_USE_FUNKTEMPO = 0
    220  6c17				  -
    221  6c17					      ELSE
    222  6c17							; Global tempo
    223  6c17		       a2 04		      ldx	#TT_SPEED-1
    224  6c19					      IF	TT_USE_FUNKTEMPO = 1
    225  6c19		       a5 cf		      lda	tt_cur_note_index_c0
    226  6c1b		       4a		      lsr
    227  6c1c		       90 02		      bcc	.noOddFrame
    228  6c1e		       a2 03		      ldx	#TT_ODD_SPEED-1
    229  6c20				   .noOddFrame
    230  6c20					      ENDIF		; TT_USE_FUNKTEMPO = 1
    231  6c20		       86 cc		      stx	tt_timer
    232  6c22					      ENDIF		; TT_GLOBAL_SPEED = 0
    233  6c22
    234  6c22							; No new note to process
    235  6c22				   .noNewNote
    236  6c22
    237  6c22							; ==================== Update registers ====================
    238  6c22		       a2 01		      ldx	#1	; 2 channels
    239  6c24				   .updateLoop
    240  6c24							; Percussion or melodic instrument?
    241  6c24		       b5 d3		      lda	tt_cur_ins_c0,x
    242  6c26				  -	      IF	TT_STARTS_WITH_NOTES = 0
    243  6c26				  -			; This branch can be removed if track starts with a note in each channel
    244  6c26				  -	      beq	.afterAudioUpdate
    245  6c26					      ENDIF
    246  6c26		       c9 20		      cmp	#TT_FREQ_MASK+1
    247  6c28		       b0 37		      bcs	.instrument	; Melodic instrument
    248  6c2a
    249  6c2a							; --- Percussion: Get envelope index ---
    250  6c2a		       b4 d1		      ldy	tt_envelope_index_c0,x
    251  6c2c							; Set AUDC and AUDV value from envelope
    252  6c2c		       b9 e9 f4 	      lda	tt_PercCtrlVolTable-1,y	; -1 because values are stored +1
    253  6c2f		       f0 02		      beq	.endOfPercussion	; 0 means end of percussion data
    254  6c31		       f6 d1		      inc	tt_envelope_index_c0,x	; if end not reached: advance index
    255  6c33				   .endOfPercussion
    256  6c33		       95 59		      sta	AUDV0,x
    257  6c35		       4a		      lsr
    258  6c36		       4a		      lsr
    259  6c37		       4a		      lsr
    260  6c38		       4a		      lsr
    261  6c39		       95 55		      sta	AUDC0,x
    262  6c3b							; Set AUDF
    263  6c3b		       b9 d3 f4 	      lda	tt_PercFreqTable-1,y	; -1 because values are stored +1
    264  6c3e							; Bit 7 (overlay) might be set, but is unused in AUDF
    265  6c3e		       95 57		      sta	AUDF0,x
    266  6c40					      IF	TT_USE_OVERLAY = 1
    267  6c40		       10 48		      bpl	.afterAudioUpdate
    268  6c42							; Overlay percussion: Fetch next note out of order
    269  6c42		       20 cc f3 	      jsr	tt_FetchNote
    270  6c45							; Only do something if it's a melodic instrument
    271  6c45		       c9 20		      cmp	#TT_FREQ_MASK+1
    272  6c47		       90 41		      bcc	.afterAudioUpdate
    273  6c49							; Instrument: Put into sustain
    274  6c49		       95 d3		      sta	tt_cur_ins_c0,x	; set new instrument
    275  6c4b		       20 5a f4 	      jsr	tt_CalcInsIndex
    276  6c4e		       b9 97 f4 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start at #1
    277  6c51		       95 d1		      sta	tt_envelope_index_c0,x
    278  6c53							; Set prefetch flag. asl-sec-ror is smaller than lda-ora #128-sta
    279  6c53		       16 cf		      asl	tt_cur_note_index_c0,x
    280  6c55		       38		      sec
    281  6c56		       76 cf		      ror	tt_cur_note_index_c0,x
    282  6c58		       30 30		      bmi	.afterAudioUpdate	; unconditional
    283  6c5a				  -	      ELSE
    284  6c5a				  -	      jmp	.afterAudioUpdate
    285  6c5a					      ENDIF
    286  6c5a
    287  6c5a
    288  6c5a							; ---------------------------------------------------------------------
    289  6c5a							; Helper subroutine to minimize ROM footprint.
    290  6c5a							; Interleaved here so player routine can be inlined.
    291  6c5a							; ---------------------------------------------------------------------
    292  6c5a				   tt_CalcInsIndex
    293  6c5a							; move upper 3 bits to lower 3
    294  6c5a		       4a		      lsr
    295  6c5b		       4a		      lsr
    296  6c5c		       4a		      lsr
    297  6c5d		       4a		      lsr
    298  6c5e		       4a		      lsr
    299  6c5f		       a8		      tay
    300  6c60				   tt_Bit6Set		; This opcode has bit #6 set, for use with bit instruction
    301  6c60		       60		      rts
    302  6c61
    303  6c61
    304  6c61				   .instrument
    305  6c61							; --- Melodic instrument ---
    306  6c61							; Compute index into ADSR indexes and master Ctrl tables
    307  6c61		       20 5a f4 	      jsr	tt_CalcInsIndex
    308  6c64							; Set AUDC with master value for this instrument, while we are at it
    309  6c64		       b9 8d f4 	      lda	tt_InsCtrlTable-1,y	; -1 because instruments start with #1
    310  6c67		       95 55		      sta	AUDC0,x
    311  6c69							; advance ADSR counter and compare to end of Sustain
    312  6c69		       b5 d1		      lda	tt_envelope_index_c0,x
    313  6c6b		       d9 9c f4 	      cmp	tt_InsReleaseIndexes-1,y	; -1 because instruments start with #1
    314  6c6e		       d0 03		      bne	.noEndOfSustain
    315  6c70							; End of sustain: Go back to start of sustain
    316  6c70		       b9 97 f4 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start with #1
    317  6c73				   .noEndOfSustain
    318  6c73		       a8		      tay
    319  6c74							; Set volume from envelope
    320  6c74		       b9 a2 f4 	      lda	tt_InsFreqVolTable,y
    321  6c77		       f0 01		      beq	.endOfEnvelope	; 0 means end of release has been reached:
    322  6c79		       c8		      iny		; advance index otherwise
    323  6c7a				   .endOfEnvelope
    324  6c7a		       94 d1		      sty	tt_envelope_index_c0,x
    325  6c7c		       95 59		      sta	AUDV0,x
    326  6c7e							; Now adjust frequency with ADSR value from envelope
    327  6c7e		       4a		      lsr
    328  6c7f		       4a		      lsr
    329  6c80		       4a		      lsr
    330  6c81		       4a		      lsr
    331  6c82		       18		      clc
    332  6c83		       75 d3		      adc	tt_cur_ins_c0,x
    333  6c85		       38		      sec
    334  6c86		       e9 08		      sbc	#8
    335  6c88		       95 57		      sta	AUDF0,x
    336  6c8a
    337  6c8a				   .afterAudioUpdate
    338  6c8a							; loop over channels
    339  6c8a		       ca		      dex
    340  6c8b		       10 97		      bpl	.updateLoop
    341  6c8d
 Music player size:  $dd
    342  6c8d					      echo	"Music player size: ", *-tt_PlayerStart
------- FILE BANK_INITBANK.asm
   1066  6c8d		       60		      rts
   1067  6c8e
------- FILE sound/intro1_trackdata.asm LEVEL 3 PASS 3
      0  6c8e					      include	"sound/intro1_trackdata.asm"
      1  6c8e							; TIATracker music player
      2  6c8e							; Copyright 2016 Andre "Kylearan" Wichmann
      3  6c8e							; Website: https://bitbucket.org/kylearan/tiatracker
      4  6c8e							; Email: andre.wichmann@gmx.de
      5  6c8e							;
      6  6c8e							; Licensed under the Apache License, Version 2.0 (the "License");
      7  6c8e							; you may not use this file except in compliance with the License.
      8  6c8e							; You may obtain a copy of the License at
      9  6c8e							;
     10  6c8e							;   http://www.apache.org/licenses/LICENSE-2.0
     11  6c8e							;
     12  6c8e							; Unless required by applicable law or agreed to in writing, software
     13  6c8e							; distributed under the License is distributed on an "AS IS" BASIS,
     14  6c8e							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  6c8e							; See the License for the specific language governing permissions and
     16  6c8e							; limitations under the License.
     17  6c8e
     18  6c8e							; Song author: 
     19  6c8e							; Song name: 
     20  6c8e
     21  6c8e							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  6c8e
     23  6c8e							; =====================================================================
     24  6c8e							; TIATracker melodic and percussion instruments, patterns and sequencer
     25  6c8e							; data.
     26  6c8e							; =====================================================================
     27  6c8e				   tt_TrackDataStart
     28  6c8e
     29  6c8e							; =====================================================================
     30  6c8e							; Melodic instrument definitions (up to 7). tt_envelope_index_c0/1 hold
     31  6c8e							; the index values into these tables for the current instruments played
     32  6c8e							; in channel 0 and 1.
     33  6c8e							; 
     34  6c8e							; Each instrument is defined by:
     35  6c8e							; - tt_InsCtrlTable: the AUDC value
     36  6c8e							; - tt_InsADIndexes: the index of the start of the ADSR envelope as
     37  6c8e							;	 defined in tt_InsFreqVolTable
     38  6c8e							; - tt_InsSustainIndexes: the index of the start of the Sustain phase
     39  6c8e							;	 of the envelope
     40  6c8e							; - tt_InsReleaseIndexes: the index of the start of the Release phase
     41  6c8e							; - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
     42  6c8e							;	 the envelope
     43  6c8e							; =====================================================================
     44  6c8e
     45  6c8e							; Instrument master CTRL values
     46  6c8e				   tt_InsCtrlTable
     47  6c8e		       07 04 0c 04*	      dc.b	$07, $04, $0c, $04, $0c
     48  6c93
     49  6c93
     50  6c93							; Instrument Attack/Decay start indexes into ADSR tables.
     51  6c93				   tt_InsADIndexes
     52  6c93		       00 0e 0e 1e*	      dc.b	$00, $0e, $0e, $1e, $1e
     53  6c98
     54  6c98
     55  6c98							; Instrument Sustain start indexes into ADSR tables
     56  6c98				   tt_InsSustainIndexes
     57  6c98		       08 19 19 2b*	      dc.b	$08, $19, $19, $2b, $2b
     58  6c9d
     59  6c9d
     60  6c9d							; Instrument Release start indexes into ADSR tables
     61  6c9d							; Caution: Values are stored with an implicit -1 modifier! To get the
     62  6c9d							; real index, add 1.
     63  6c9d				   tt_InsReleaseIndexes
     64  6c9d		       09 1b 1b 2c*	      dc.b	$09, $1b, $1b, $2c, $2c
     65  6ca2
     66  6ca2
     67  6ca2							; AUDVx and AUDFx ADSR envelope values.
     68  6ca2							; Each byte encodes the frequency and volume:
     69  6ca2							; - Bits 7..4: Freqency modifier for the current note ([-8..7]),
     70  6ca2							;	 8 means no change. Bit 7 is the sign bit.
     71  6ca2							; - Bits 3..0: Volume
     72  6ca2							; Between sustain and release is one byte that is not used and
     73  6ca2							; can be any value.
     74  6ca2							; The end of the release phase is encoded by a 0.
     75  6ca2				   tt_InsFreqVolTable
     76  6ca2							; 0: Pizzicato bassb
     77  6ca2		       8a 8a 89 88*	      dc.b	$8a, $8a, $89, $88, $86, $85, $85, $84
     78  6caa		       83 00 83 83*	      dc.b	$83, $00, $83, $83, $83, $00
     79  6cb0							; 1+2: Square2
     80  6cb0		       8c 8c 8b 89*	      dc.b	$8c, $8c, $8b, $89, $87, $85, $84, $83
     81  6cb8		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $00, $81, $00
     82  6cc0							; 3+4: Square
     83  6cc0		       85 85 85 85*	      dc.b	$85, $85, $85, $85, $84, $83, $83, $82
     84  6cc8		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $81, $00, $80
     85  6cd0		       00		      dc.b	$00
     86  6cd1
     87  6cd1
     88  6cd1
     89  6cd1							; =====================================================================
     90  6cd1							; Percussion instrument definitions (up to 15)
     91  6cd1							;
     92  6cd1							; Each percussion instrument is defined by:
     93  6cd1							; - tt_PercIndexes: The index of the first percussion frame as defined
     94  6cd1							;	 in tt_PercFreqTable and tt_PercCtrlVolTable
     95  6cd1							; - tt_PercFreqTable: The AUDF frequency value
     96  6cd1							; - tt_PercCtrlVolTable: The AUDV volume and AUDC values
     97  6cd1							; =====================================================================
     98  6cd1
     99  6cd1							; Indexes into percussion definitions signifying the first frame for
    100  6cd1							; each percussion in tt_PercFreqTable.
    101  6cd1							; Caution: Values are stored with an implicit +1 modifier! To get the
    102  6cd1							; real index, subtract 1.
    103  6cd1				   tt_PercIndexes
    104  6cd1		       01 0a 0c 	      dc.b	$01, $0a, $0c
    105  6cd4
    106  6cd4
    107  6cd4							; The AUDF frequency values for the percussion instruments.
    108  6cd4							; If the second to last value is negative (>=128), it means it's an
    109  6cd4							; "overlay" percussion, i.e. the player fetches the next instrument note
    110  6cd4							; immediately and starts it in the sustain phase next frame. (Needs
    111  6cd4							; TT_USE_OVERLAY)
    112  6cd4				   tt_PercFreqTable
    113  6cd4							; 0: Kick
    114  6cd4		       00 01 02 03*	      dc.b	$00, $01, $02, $03, $04, $05, $06, $87
    115  6cdc		       00		      dc.b	$00
    116  6cdd							; 1: HH
    117  6cdd		       80 00		      dc.b	$80, $00
    118  6cdf							; 2: Snare
    119  6cdf		       01 03 06 0e*	      dc.b	$01, $03, $06, $0e, $13, $11, $15, $14
    120  6ce7		       17 1b 00 	      dc.b	$17, $1b, $00
    121  6cea
    122  6cea
    123  6cea							; The AUDCx and AUDVx volume values for the percussion instruments.
    124  6cea							; - Bits 7..4: AUDC value
    125  6cea							; - Bits 3..0: AUDV value
    126  6cea							; 0 means end of percussion data.
    127  6cea				   tt_PercCtrlVolTable
    128  6cea							; 0: Kick
    129  6cea		       ee ed ed eb*	      dc.b	$ee, $ed, $ed, $eb, $e9, $e8, $e8, $e6
    130  6cf2		       00		      dc.b	$00
    131  6cf3							; 1: HH
    132  6cf3		       87 00		      dc.b	$87, $00
    133  6cf5							; 2: Snare
    134  6cf5		       8b 8a 8a 8a*	      dc.b	$8b, $8a, $8a, $8a, $8a, $8a, $89, $88
    135  6cfd		       87 86 00 	      dc.b	$87, $86, $00
    136  6d00
    137  6d00
    138  6d00
    139  6d00							; =====================================================================
    140  6d00							; Track definition
    141  6d00							; The track is defined by:
    142  6d00							; - tt_PatternX (X=0, 1, ...): Pattern definitions
    143  6d00							; - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
    144  6d00							;	 as index values
    145  6d00							; - tt_SequenceTable: The order in which the patterns should be played,
    146  6d00							;	 i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
    147  6d00							;	 for all channels and sub-tracks. The variables
    148  6d00							;	 tt_cur_pat_index_c0/1 hold an index into tt_SequenceTable for
    149  6d00							;	 each channel.
    150  6d00							;
    151  6d00							; So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
    152  6d00							; in turn point to pattern definitions (tt_PatternX) in which the notes
    153  6d00							; to play are specified.
    154  6d00							; =====================================================================
    155  6d00
    156  6d00							; ---------------------------------------------------------------------
    157  6d00							; Pattern definitions, one table per pattern. tt_cur_note_index_c0/1
    158  6d00							; hold the index values into these tables for the current pattern
    159  6d00							; played in channel 0 and 1.
    160  6d00							;
    161  6d00							; A pattern is a sequence of notes (one byte per note) ending with a 0.
    162  6d00							; A note can be either:
    163  6d00							; - Pause: Put melodic instrument into release. Must only follow a
    164  6d00							;	 melodic instrument.
    165  6d00							; - Hold: Continue to play last note (or silence). Default "empty" note.
    166  6d00							; - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
    167  6d00							;	 by -7..+7 and keep playing it
    168  6d00							; - Play new note with melodic instrument
    169  6d00							; - Play new note with percussion instrument
    170  6d00							; - End of pattern
    171  6d00							;
    172  6d00							; A note is defined by:
    173  6d00							; - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
    174  6d00							;	 and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
    175  6d00							;	 defined as:
    176  6d00							;	 - 0: End of pattern
    177  6d00							;	 - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
    178  6d00							;	 - 8: Hold
    179  6d00							;	 - 16: Pause
    180  6d00							;	 - [17..31]: Play percussion instrument 1..15
    181  6d00							;
    182  6d00							; The tracker must ensure that a pause only follows a melodic
    183  6d00							; instrument or a hold/slide.
    184  6d00							; ---------------------------------------------------------------------
    185  6d00		       00 1f	   TT_FREQ_MASK =	%00011111
    186  6d00		       00 08	   TT_INS_HOLD =	8
    187  6d00		       00 10	   TT_INS_PAUSE =	16
    188  6d00		       00 11	   TT_FIRST_PERC =	17
    189  6d00
    190  6d00							; Intro left
    191  6d00				   tt_pattern0
    192  6d00		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $3e, $08
    193  6d08		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $3e, $08
    194  6d10		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $12, $3e
    195  6d18		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $13, $08
    196  6d20		       00		      dc.b	$00
    197  6d21
    198  6d21							; Intro2 L
    199  6d21				   tt_pattern1
    200  6d21		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    201  6d29		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    202  6d31		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    203  6d39		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    204  6d41		       00		      dc.b	$00
    205  6d42
    206  6d42							; Intro2-fill L
    207  6d42				   tt_pattern2
    208  6d42		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    209  6d4a		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    210  6d52		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    211  6d5a		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    212  6d62		       00		      dc.b	$00
    213  6d63
    214  6d63							; Intro right
    215  6d63				   tt_pattern3
    216  6d63		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $73, $08
    217  6d6b		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $73, $08, $73, $08
    218  6d73		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $b3, $08
    219  6d7b		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    220  6d83		       00		      dc.b	$00
    221  6d84
    222  6d84							; Intro2 R
    223  6d84				   tt_pattern4
    224  6d84		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    225  6d8c		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    226  6d94		       b3 08 73 08*	      dc.b	$b3, $08, $73, $08, $b3, $08, $73, $08
    227  6d9c		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    228  6da4		       00		      dc.b	$00
    229  6da5
    230  6da5
    231  6da5
    232  6da5
    233  6da5							; Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
    234  6da5							; Each byte encodes the speed of one pattern in the order
    235  6da5							; of the tt_PatternPtr tables below.
    236  6da5							; If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
    237  6da5							; the even speed and the high nibble the odd speed.
    238  6da5				  -	      IF	TT_GLOBAL_SPEED = 0
    239  6da5				  -tt_PatternSpeeds
    240  6da5				  -%%PATTERNSPEEDS%%
    241  6da5					      ENDIF
    242  6da5
    243  6da5
    244  6da5							; ---------------------------------------------------------------------
    245  6da5							; Pattern pointers look-up table.
    246  6da5							; ---------------------------------------------------------------------
    247  6da5				   tt_PatternPtrLo
    248  6da5		       00 21 42 63	      dc.b	<tt_pattern0, <tt_pattern1, <tt_pattern2, <tt_pattern3
    249  6da9		       84		      dc.b	<tt_pattern4
    250  6daa				   tt_PatternPtrHi
    251  6daa		       f5 f5 f5 f5	      dc.b	>tt_pattern0, >tt_pattern1, >tt_pattern2, >tt_pattern3
    252  6dae		       f5		      dc.b	>tt_pattern4
    253  6daf
    254  6daf
    255  6daf							; ---------------------------------------------------------------------
    256  6daf							; Pattern sequence table. Each byte is an index into the
    257  6daf							; tt_PatternPtrLo/Hi tables where the pointers to the pattern
    258  6daf							; definitions can be found. When a pattern has been played completely,
    259  6daf							; the next byte from this table is used to get the address of the next
    260  6daf							; pattern to play. tt_cur_pat_index_c0/1 hold the current index values
    261  6daf							; into this table for channels 0 and 1.
    262  6daf							; If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
    263  6daf							; number encoded in bits 6..0 (i.e. value AND %01111111).
    264  6daf							; ---------------------------------------------------------------------
    265  6daf				   tt_SequenceTable
    266  6daf							; ---------- Channel 0 ----------
    267  6daf		       00 00 01 02*	      dc.b	$00, $00, $01, $02, $80
    268  6db4
    269  6db4
    270  6db4							; ---------- Channel 1 ----------
    271  6db4		       03 04 03 04*	      dc.b	$03, $04, $03, $04, $85
    272  6db9
    273  6db9
 Track size:  $12b
    274  6db9					      echo	"Track size: ", *-tt_TrackDataStart
------- FILE BANK_INITBANK.asm
   1069  6db9
   1070  6db9							;------------------------------------------------------------------------------
   1071  6db9
      0  6db9					      CHECK_BANK_SIZE	"INITBANK"
      1  6db9		       05 b9	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $5b9 , FREE= $247
      2  6db9					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  6db9				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  6db9				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  6db9				  -	      ERR
      6  6db9					      endif
------- FILE ./sokoboo.asm
    801  6db9
    802  6db9							; MUST BE LAST...
------- FILE BANK_FIXED.asm LEVEL 2 PASS 3
      0  6db9					      include	"BANK_FIXED.asm"
      1  6db9							;    Sokoboo - a Sokoban implementation
      2  6db9							;    using a generic tile-based display engine for the Atari 2600
      3  6db9							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  6db9							;
      5  6db9							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  6db9							;
      7  6db9							;    Code related to the generic tile-based display engine was developed by
      8  6db9							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  6db9							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  6db9							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  6db9							;
     12  6db9							;    Code related to music and sound effects uses the TIATracker music player
     13  6db9							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  6db9							;    directory for Apache licensing details.
     15  6db9							;
     16  6db9							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  6db9							;    See the copyright notices in the License directory for a list of level
     18  6db9							;    contributors.
     19  6db9							;
     20  6db9							;    Except where otherwise indicated, this software is released under the
     21  6db9							;    following licensing arrangement...
     22  6db9							;
     23  6db9							;    This program is free software: you can redistribute it and/or modify
     24  6db9							;    it under the terms of the GNU General Public License as published by
     25  6db9							;    the Free Software Foundation, either version 3 of the License, or
     26  6db9							;    (at your option) any later version.
     27  6db9							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  6db9
     29  6db9							;    This program is distributed in the hope that it will be useful,
     30  6db9							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  6db9							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  6db9							;    GNU General Public License for more details.
     33  6db9
     34  6db9							;------------------------------------------------------------------------------
     35  6db9							;###############################  FIXED BANK  #################################
     36  6db9							;------------------------------------------------------------------------------
     37  6db9
     38  6db9
     39  6db9				   ORIGIN     SET	FIXED_BANK
     40  6db9
      0  6db9					      NEWBANK	THE_FIXED_BANK
      1  7f30 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
     42  7800					      RORG	$f800
     43  7800
     44  7800							;------------------------------------------------------------------------------
     45  7800
      0  7800					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  7800		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  7800					      SUBROUTINE
      3  7800				   DrawTimeFromROM
     47  7800
     48  7800		       a9 09		      lda	#BANK_SCORING
     49  7802		       85 3e		      sta	SET_BANK_RAM
     50  7804		       20 a3 f2 	      jsr	DrawTime
     51  7807		       20 97 f2 	      jsr	DrawBCD_targetsRequired
     52  780a		       a5 bf		      lda	ROM_Bank
     53  780c		       85 3f		      sta	SET_BANK
     54  780e		       60		      rts
     55  780f
     56  780f							;------------------------------------------------------------------------------
     57  780f
      0  780f					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  780f		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  780f					      SUBROUTINE
      3  780f				   GetROMByte
     59  780f
     60  780f							; a = ROM bank to retrieve
     61  780f							; y = page index
     62  780f							; ROM_Bank = bank to return to
     63  780f							; (Board_AddressR) = page
     64  780f							; out a = byte from (Board_AddressR)
     65  780f
     66  780f		       85 3f		      sta	SET_BANK	;3
     67  7811		       4c 16 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
     68  7814
     69  7814							;------------------------------------------------------------------------------
     70  7814
      0  7814					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7814		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7814					      SUBROUTINE
      3  7814				   GetBoardCharacter
     72  7814
     73  7814							; call from ROM bank
     74  7814							; switches back to ROM_Bank on exit
     75  7814
     76  7814							; pass A = bank containing character
     77  7814							; Y = x character position
     78  7814							; (Board_AddressR) points to character position
     79  7814							; returns character from board
     80  7814
     81  7814
     82  7814		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
     83  7816
     84  7816				   GetBoardCharacter2		;=17(A)
     85  7816
     86  7816		       b3 bb		      lax	(Board_AddressR),y	;5
     87  7818		       a4 bf		      ldy	ROM_Bank	;3
     88  781a		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
     89  781c		       60		      rts		;6   and go back
     90  781d
     91  781d							;---------------------------------------------------------------------------
     92  781d
      0  781d					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  781d		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  781d					      SUBROUTINE
      3  781d				   PutBoardCharacter
     94  781d
     95  781d		       86 3e		      stx	SET_BANK_RAM	; 3
     96  781f
     97  781f				   PutBoardCharacterSB		; =18
     98  781f		       91 bd		      sta	(Board_AddressW),y	; 6
     99  7821		       a5 bf		      lda	ROM_Bank	; 3
    100  7823		       85 3f		      sta	SET_BANK	; 3
    101  7825		       60		      rts		; 6 = 21
    102  7826
    103  7826							;---------------------------------------------------------------------------
    104  7826
      0  7826					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  7826		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  7826					      SUBROUTINE
      3  7826				   GetBoardCharacter__CALL_FROM_RAM__
    106  7826
    107  7826		       a4 88		      ldy	POS_Y	;3
    108  7828
    109  7828		       a9 0d		      lda	#BANK_GetBoardAddressR	;
    110  782a		       85 3f		      sta	SET_BANK	;
    111  782c		       20 bf f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    112  782f
    113  782f
    114  782f							;DEFINE_SUBROUTINE PartialGetBoardCharacter ;=23
    115  782f
    116  782f		       85 3e		      sta	SET_BANK_RAM	;3
    117  7831		       a4 87		      ldy	POS_X	;3
    118  7833		       b3 bb		      lax	(Board_AddressR),y	;5
    119  7835		       a4 c0		      ldy	RAM_Bank	;3
    120  7837		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    121  7839		       60		      rts		;6		 and go back
    122  783a
    123  783a							;---------------------------------------------------------------------------
    124  783a
      0  783a					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  783a		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  783a					      SUBROUTINE
      3  783a				   PutBoardCharacterFromRAM
    126  783a
    127  783a							; POS_Y  = row
    128  783a							; POS_Type = character to write
    129  783a							; POS_X     = column
    130  783a							; RAM_Bank = caller's bank
    131  783a
    132  783a		       a4 88		      ldy	POS_Y	;3
    133  783c
    134  783c		       a9 0d		      lda	#BANK_GetBoardAddressW	;
    135  783e		       85 3f		      sta	SET_BANK	;
    136  7840		       20 cc f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
    137  7843
    138  7843		       86 3e		      stx	SET_BANK_RAM	;3
    139  7845
    140  7845		       a4 87		      ldy	POS_X	;3
    141  7847		       a5 8b		      lda	POS_Type	;3
    142  7849		       91 bd		      sta	(Board_AddressW),y	;6
    143  784b		       a4 c0		      ldy	RAM_Bank	;3
    144  784d		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    145  784f		       60		      rts		;6
    146  7850
    147  7850
      0  7850					      DEFINE_SUBROUTINE	PutBoardCharacterFromROM
      1  7850		       00 0f	   BANK_PutBoardCharacterFromROM =	_CURRENT_BANK
      2  7850					      SUBROUTINE
      3  7850				   PutBoardCharacterFromROM
    149  7850		       48		      pha
    150  7851		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    151  7854		       68		      pla
    152  7855		       85 3f		      sta	SET_BANK
    153  7857		       60		      rts
    154  7858
    155  7858							;---------------------------------------------------------------------------
    156  7858
      0  7858					      DEFINE_SUBROUTINE	ProcessObjStack	; @31✅ called from Vector
      1  7858		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  7858					      SUBROUTINE
      3  7858				   ProcessObjStack
    158  7858							; 15 minimum segtime abort
    159  7858
    160  7858		       ad 84 02 	      lda	INTIM	; 4
    161  785b		       c9 03		      cmp	#MINIMUM_SEGTIME	; 2
    162  785d		       90 31		      bcc	EarlyAbort	; 2(3)= 8
    163  785f							; => [31]+9+6rts = 46✅ on abort
    164  785f							; @0✅
    165  785f
    166  785f		       a5 82		      lda	ObjStackNum	; 3
    167  7861		       49 01		      eor	#1	; 2
    168  7863		       aa		      tax		; 2 = 7✅
    169  7864
    170  7864		       a5 c3		      lda	ObjIterator	; 3
    171  7866		       d5 83		      cmp	ObjStackPtr,x	; 5
    172  7868		       b0 24		      bcs	nextPhase	; 2/3 = 10/11[+11] ==> @22✅ on exit
    173  786a
    174  786a							; @17✅
    175  786a							; Process an object...
    176  786a							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    177  786a
    178  786a		       bc 31 f9 	      ldy	BankObjStack,x	; 4
    179  786d		       84 3e		      sty	SET_BANK_RAM	; 3 = 7
    180  786f
    181  786f		       aa		      tax		; 2
    182  7870		       bc 80 11 	      ldy	SortedObjPtr,x	; 4 = 6	      indirect object pointer list (sorted)
    183  7873
    184  7873		       b9 00 10 	      lda	ObjStackX,y	; 4
    185  7876		       85 87		      sta	POS_X	; 3
    186  7878		       b9 80 10 	      lda	ObjStackY,y	; 4
    187  787b		       85 88		      sta	POS_Y	; 3
    188  787d		       b9 00 11 	      lda	ObjStackVar,y	; 4
    189  7880		       85 8c		      sta	POS_VAR	; 3
    190  7882		       be 00 12 	      ldx	ObjStackType,y	; 4
    191  7885		       86 8b		      stx	POS_Type	; 3 = 28
    192  7887
    193  7887		       a9 0d		      lda	#BANK_VectorProcess	; 2
    194  7889		       85 3f		      sta	SET_BANK	; 3
    195  788b		       4c 83 f3 	      jmp	VectorProcess	; 3 = 8
    196  788e
    197  788e							; => [17]+7+6+28+8 = @64 entry to VectorProcess
    198  788e							; + 31 minimum timeout return
    199  788e							; = 95✅
    200  788e
    201  788e							;---------------------------------------------------------------------------
    202  788e							; Now process the blank stack.  This stack holds all the recently blanked squares
    203  788e							; and determines (and moves) BOXs or TARGETs into these squares.  The space vacated
    204  788e							; by these objects are added again to the blank stack.
    205  788e
    206  788e				   nextPhase		; +11✅ for exit from here
    207  788e
    208  788e		       e6 86		      inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    209  7890		       60	   EarlyAbort rts		;6
    210  7891
    211  7891							;---------------------------------------------------------------------------
    212  7891
      0  7891					      DEFINE_SUBROUTINE	SwitchObjects	; = 31 ✅
      1  7891		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  7891					      SUBROUTINE
      3  7891				   SwitchObjects
    214  7891
    215  7891							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    216  7891							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    217  7891							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    218  7891
    219  7891		       ad 84 02 	      lda	INTIM	; 4
    220  7894		       c9 03		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    221  7896		       90 f8		      bcc	EarlyAbort	; 2(3) => [31]+(9)+6rts = 46✅ on abort
    222  7898
    223  7898							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    224  7898							; we're at the throttle cutoff do we switch game-frames.
    225  7898
    226  7898
    227  7898
    228  7898							;		  ;sec
    229  7898							;		  lda Throttle			  ;3
    230  7898							;		  sbc #MAX_THROTTLE		  ;2
    231  7898							;	      ;    bcc EarlyAbort		   ;2/3 	   plenty of time left!
    232  7898							;		  sta Throttle			  ;3 = 10	  save fractional 'left over' bit
    233  7898
    234  7898
    235  7898							; Now that we have completed processing the object stack, we switch
    236  7898							; the stack bank pointers for the next time around.
    237  7898
    238  7898		       a5 82		      lda	ObjStackNum	;3
    239  789a		       49 01		      eor	#1	;2
    240  789c		       aa		      tax		;2
    241  789d		       86 82		      stx	ObjStackNum	;3 = 10	 swap stacks @here
    242  789f
    243  789f							; Initialise the iterator and stack pointer for next time around.
    244  789f							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    245  789f							; necessary to initialise both.
    246  789f
    247  789f		       a0 00		      ldy	#0	;2
    248  78a1		       84 c3		      sty	ObjIterator	;3
    249  78a3		       94 83		      sty	ObjStackPtr,x	;4
    250  78a5
    251  78a5		       84 86		      sty	ScreenDrawPhase	;3
    252  78a7		       60		      rts		;6
    253  78a8
    254  78a8							;---------------------------------------------------------------------------
    255  78a8
    256  78a8		       60	   EarlyAbort4 rts
    257  78a9
      0  78a9					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  78a9		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  78a9					      SUBROUTINE
      3  78a9				   PROCESS_MAN
    259  78a9
    260  78a9		       ad 84 02 	      lda	INTIM	; 3
    261  78ac		       c9 12		      cmp	#SEGTIME_MAN	; 2
    262  78ae		       90 f8		      bcc	EarlyAbort4	; 2/3 = 7 + 6rts = 13✅ on abort
    263  78b0
    264  78b0		       a9 0d		      lda	#BANK_ManProcess
    265  78b2		       85 bf		      sta	ROM_Bank
    266  78b4		       85 3f		      sta	SET_BANK
    267  78b6		       20 73 f1 	      jsr	ManProcess
    268  78b9
    269  78b9
    270  78b9		       a9 ff		      lda	#-1
    271  78bb		       85 91		      sta	TB_CHAR	; pre-set box takeback to NONE
    272  78bd							;sta BufferedJoystick
    273  78bd
    274  78bd		       20 33 f9 	      jsr	MovePlayer
    275  78c0
    276  78c0		       a5 a1	   DoNothing  lda	ManMode
    277  78c2		       c9 07		      cmp	#MANMODE_NEXTLEVEL	; kludge
    278  78c4		       b0 08		      bcs	notComplete
    279  78c6		       a5 b5		      lda	BCD_targetsRequired
    280  78c8		       d0 04		      bne	notComplete
    281  78ca		       a9 07		      lda	#MANMODE_NEXTLEVEL
    282  78cc		       85 a1		      sta	ManMode
    283  78ce				   notComplete
    284  78ce
    285  78ce		       a9 03		      lda	#BANK_TrackPlayer	;
    286  78d0		       85 3f		      sta	SET_BANK	;
    287  78d2		       20 c4 f4 	      jsr	TrackPlayer	;11+145
    288  78d5
    289  78d5		       a9 00		      lda	#TYPE_MAN	; 2
    290  78d7		       85 8b		      sta	POS_Type	; 3
    291  78d9
    292  78d9		       20 03 f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    293  78dc		       4c f8 f8    gnobj      jmp	NextObject
    294  78df
    295  78df							;---------------------------------------------------------------------------
    296  78df
      0  78df					      DEFINE_SUBROUTINE	PutCharacterAtXY
      1  78df		       00 0f	   BANK_PutCharacterAtXY =	_CURRENT_BANK
      2  78df					      SUBROUTINE
      3  78df				   PutCharacterAtXY
    298  78df
    299  78df							; POS_X	 character location
    300  78df							; POS_Y
    301  78df							; POS_VAR	 character to put on board
    302  78df							; ROM_Bank	 ROM bank to return to
    303  78df
    304  78df		       a4 88		      ldy	POS_Y
    305  78e1
    306  78e1		       a9 0d		      lda	#BANK_GetBoardAddressW
    307  78e3		       85 3f		      sta	SET_BANK
    308  78e5		       20 cc f0 	      jsr	GetBoardAddressW
    309  78e8		       86 3e		      stx	SET_BANK_RAM
    310  78ea
    311  78ea		       a4 87		      ldy	POS_X
    312  78ec		       a5 8c		      lda	POS_VAR
    313  78ee		       91 bd		      sta	(Board_AddressW),y
    314  78f0
    315  78f0		       a5 bf		      lda	ROM_Bank
    316  78f2		       85 3f		      sta	SET_BANK
    317  78f4		       60		      rts
    318  78f5
    319  78f5							;---------------------------------------------------------------------------
    320  78f5
    321  78f5							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    322  78f5							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    323  78f5
    324  78f5							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    325  78f5
    326  78f5							; if the creature dies then jump NextObject
    327  78f5
    328  78f5
    329  78f5		       20 03 f9    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    330  78f8
    331  78f8		       e6 c3	   NextObject inc	ObjIterator	; 5
    332  78fa							;		  dec ObjStackPtr,x		  ; 6
    333  78fa		       60		      rts		;jmp ProcessObjStack		  ; 3 = 16	 ; DON'T chain, instead return
    334  78fb							; let the segtime stuff do its job!
    335  78fb
    336  78fb							;---------------------------------------------------------------------------
    337  78fb
      0  78fb					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  78fb		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  78fb					      SUBROUTINE
      3  78fb				   InsertObjectStackFromRAM
    339  78fb
    340  78fb		       20 03 f9 	      jsr	InsertObjectStack	;6+76(B)
    341  78fe		       a5 c0		      lda	RAM_Bank	;3
    342  7900		       85 3e		      sta	SET_BANK_RAM	;3
    343  7902
    344  7902		       60	   NotEnoughTime rts		;6
    345  7903
    346  7903							;---------------------------------------------------------------------------
    347  7903
      0  7903					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  7903		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  7903					      SUBROUTINE
      3  7903				   InsertObjectStack
    349  7903							; POS_X     x position
    350  7903							; POS_Y     y position
    351  7903							; POS_VAR   direction or other variable
    352  7903							; POS_Type  type of object
    353  7903
    354  7903		       a6 82		      ldx	ObjStackNum	; 3
    355  7905		       bc 31 f9 	      ldy	BankObjStack,x	; 4
    356  7908		       84 3e		      sty	SET_BANK_RAM	; 3
    357  790a		       b4 83		      ldy	ObjStackPtr,x	; 4 = 14
    358  790c
    359  790c
    360  790c		       a5 88		      lda	POS_Y	; 3
    361  790e		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    362  7911		       a5 87		      lda	POS_X	; 3
    363  7913		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    364  7916		       a5 8c		      lda	POS_VAR	; 3
    365  7918		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    366  791b		       a5 8b		      lda	POS_Type	; 3
    367  791d		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    368  7920
    369  7920							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    370  7920							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    371  7920							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    372  7920
    373  7920
    374  7920				  -	      IF	TYPE_MAN != 0
    375  7920				  -	      cmp	#TYPE_MAN	; 2
    376  7920					      ENDIF
    377  7920		       f0 04		      beq	alwaysAllowMan	; 2/3
    378  7922
    379  7922		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    380  7924		       b0 06		      bcs	insertDone	; 2/3= 6    no room -- drop object
    381  7926				   alwaysAllowMan
    382  7926
    383  7926		       98		      tya		; 2
    384  7927		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    385  792a
    386  792a		       f6 83		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    387  792c
    388  792c		       a4 bf	   insertDone ldy	ROM_Bank	; 3
    389  792e		       84 3f		      sty	SET_BANK	; 3
    390  7930
    391  7930				   ManIsDead2
    392  7930
    393  7930
    394  7930
    395  7930		       60		      rts		; 6 = 29
    396  7931
    397  7931							;---------------------------------------------------------------------------
    398  7931
    399  7931		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    400  7933
    401  7933							;---------------------------------------------------------------------------
    402  7933
      0  7933					      DEFINE_SUBROUTINE	MovePlayer
      1  7933		       00 0f	   BANK_MovePlayer =	_CURRENT_BANK
      2  7933					      SUBROUTINE
      3  7933				   MovePlayer
    404  7933
    405  7933		       a4 8a		      ldy	POS_Y_NEW
    406  7935
    407  7935		       a9 0d		      lda	#BANK_GetBoardAddressRW	;2
    408  7937		       85 3f		      sta	SET_BANK	;3
    409  7939		       20 ac f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    410  793c							;    IF MULTI_BANK_BOARD = YES
    411  793c							;		  stx RAM_Bank
    412  793c							;    ENDIF
    413  793c		       86 3e		      stx	SET_BANK_RAM	; 3
    414  793e
    415  793e		       a4 89		      ldy	POS_X_NEW
    416  7940		       b3 bb		      lax	(Board_AddressR),y
    417  7942
    418  7942		       a9 0d		      lda	#BANK_MoveVecLO
    419  7944		       85 3f		      sta	SET_BANK
    420  7946
    421  7946		       bd 92 f3 	      lda	MoveVecLO,x
    422  7949		       85 d7		      sta	MAN_Move
    423  794b		       bd a1 f3 	      lda	MoveVecHI,x
    424  794e		       85 d8		      sta	MAN_Move+1
    425  7950
    426  7950							;    IF MULTI_BANK_BOARD = YES
    427  7950							;		  lda RAM_Bank
    428  7950							;    ELSE
    429  7950		       a9 0d		      lda	#BANK_BOARD
    430  7952							;    ENDIF
    431  7952		       85 3e		      sta	SET_BANK_RAM
    432  7954		       6c d7 00 	      jmp	(MAN_Move)
    433  7957
    434  7957							;---------------------------------------------------------------------------
    435  7957
      0  7957					      DEFINE_SUBROUTINE	RecordTakeBackPosition
      1  7957		       00 0f	   BANK_RecordTakeBackPosition =	_CURRENT_BANK
      2  7957					      SUBROUTINE
      3  7957				   RecordTakeBackPosition
    437  7957
    438  7957							; Pass...
    439  7957							; TB_X 	 the man's position before he moved
    440  7957							; TB_Y
    441  7957							; TB_CHAR	 if -1 then there is no box push involved, else..
    442  7957							;		 holds the character that was under the box in its new position
    443  7957							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    444  7957							; TB_PUSHY
    445  7957
    446  7957							; On making a move,
    447  7957							; man's position before move --> TB_X,TB_Y
    448  7957							; TB_CHAR = -1
    449  7957							; IF a box was pushed,
    450  7957							;   TB_CHAR = character under the box's new position (i.e., restoration char)
    451  7957							;   box's new position --> TB_PUSHX, TB_PUSHY
    452  7957							; ENDIF
    453  7957							; BCD_moveCounter++
    454  7957
    455  7957		       a5 ba		      lda	TakebackInhibit
    456  7959		       d0 2e		      bne	noLog
    457  795b
    458  795b		       a9 0e		      lda	#BANK_TAKEBACK
    459  795d		       85 3e		      sta	SET_BANK_RAM
    460  795f
    461  795f		       a6 b8		      ldx	takebackIndex
    462  7961
    463  7961		       a5 8d		      lda	TB_X
    464  7963		       9d 00 14 	      sta	RAM_WRITE+TakeBackPreviousX,x
    465  7966		       a5 8e		      lda	TB_Y
    466  7968		       9d 40 14 	      sta	RAM_WRITE+TakeBackPreviousY,x
    467  796b		       a5 91		      lda	TB_CHAR
    468  796d		       9d 00 15 	      sta	RAM_WRITE+TakeBackPushChar,x
    469  7970
    470  7970							; if TB_CHAR is -1 that means there is no box component, and the following values are random
    471  7970
    472  7970		       a5 8f		      lda	TB_PUSHX
    473  7972		       9d 80 14 	      sta	RAM_WRITE+TakeBackPushX,x
    474  7975		       a5 90		      lda	TB_PUSHY
    475  7977		       9d c0 14 	      sta	RAM_WRITE+TakeBackPushY,x
    476  797a
    477  797a		       a5 bf		      lda	ROM_Bank
    478  797c		       85 3f		      sta	SET_BANK
    479  797e
    480  797e							; fall through
    481  797e
      0  797e					      DEFINE_SUBROUTINE	IncrementMoveCount
      1  797e		       00 0f	   BANK_IncrementMoveCount =	_CURRENT_BANK
      2  797e					      SUBROUTINE
      3  797e				   IncrementMoveCount
    483  797e		       a9 0d		      lda	#BANK_IMC
    484  7980		       85 3f		      sta	SET_BANK
    485  7982		       20 60 f3 	      jsr	IMC
    486  7985		       a5 bf		      lda	ROM_Bank
    487  7987		       85 3f		      sta	SET_BANK
    488  7989
    489  7989		       a9 00	   noLog      lda	#0
    490  798b		       85 ba		      sta	TakebackInhibit
    491  798d		       60		      rts
    492  798e
    493  798e							;---------------------------------------------------------------------------
    494  798e
      0  798e					      DEFINE_SUBROUTINE	MOVE_BLANK
      1  798e		       00 0f	   BANK_MOVE_BLANK =	_CURRENT_BANK
      2  798e					      SUBROUTINE
      3  798e				   MOVE_BLANK
      0  798e					      DEFINE_SUBROUTINE	MOVE_SOIL
      1  798e		       00 0f	   BANK_MOVE_SOIL =	_CURRENT_BANK
      2  798e					      SUBROUTINE
      3  798e				   MOVE_SOIL
      0  798e					      DEFINE_SUBROUTINE	MOVE_TARGET
      1  798e		       00 0f	   BANK_MOVE_TARGET =	_CURRENT_BANK
      2  798e					      SUBROUTINE
      3  798e				   MOVE_TARGET
    498  798e
    499  798e		       8a		      txa		; character man will be standing on
    500  798f		       48		      pha
    501  7990
    502  7990		       a9 ff		      lda	#$FF
    503  7992		       85 92		      sta	BufferedJoystick
    504  7994
    505  7994
    506  7994		       a5 a6		      lda	ManAnimationID
    507  7996		       c9 08		      cmp	#ANIMATION_PUSH_ID
    508  7998		       d0 0c		      bne	immediate
    509  799a
    510  799a		       e6 a8		      inc	idleCount
    511  799c		       a5 a8		      lda	idleCount
    512  799e		       c9 0a		      cmp	#10
    513  79a0		       90 22		      bcc	walkingOK
    514  79a2		       a9 00		      lda	#0
    515  79a4		       85 a8		      sta	idleCount
    516  79a6
    517  79a6				   immediate
    518  79a6		       a5 a6		      lda	ManAnimationID
    519  79a8		       c9 00		      cmp	#ANIMATION_WALK_ID
    520  79aa		       f0 18		      beq	walkingOK
    521  79ac		       c9 0c		      cmp	#ANIMATION_WALK2_ID
    522  79ae		       f0 14		      beq	walkingOK
    523  79b0		       a9 00		      lda	#ANIMATION_WALK_ID
    524  79b2		       85 a6		      sta	ManAnimationID
      0  79b4					      LOAD_ANIMATION	WALK
      1  79b4		       a9 12		      lda	#<Animation_WALK
      2  79b6		       85 9a		      sta	animation
      3  79b8		       a9 f0		      lda	#>Animation_WALK
      4  79ba		       85 9b		      sta	animation+1
      5  79bc		       a9 00		      lda	#0
      6  79be		       85 9c		      sta	animation_delay
      7  79c0		       a9 00		      lda	#ANIMATION_WALK_ID
      8  79c2		       85 a6		      sta	ManAnimationID
      9  79c4
    526  79c4				   walkingOK
    527  79c4
    528  79c4		       a5 9d		      lda	ManX
    529  79c6		       85 87		      sta	POS_X
    530  79c8		       85 8d		      sta	TB_X
    531  79ca		       a5 9e		      lda	ManY
    532  79cc		       85 88		      sta	POS_Y
    533  79ce		       85 8e		      sta	TB_Y
    534  79d0		       20 df f8 	      jsr	PutCharacterAtXY	; RESTORE (previous XY) under-man character
    535  79d3
    536  79d3		       a5 89		      lda	POS_X_NEW
    537  79d5		       85 9d		      sta	ManX
    538  79d7		       85 87		      sta	POS_X
    539  79d9		       a5 8a		      lda	POS_Y_NEW
    540  79db		       85 9e		      sta	ManY
    541  79dd		       85 88		      sta	POS_Y
    542  79df		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    543  79e1		       85 8c		      sta	POS_VAR
    544  79e3		       20 df f8 	      jsr	PutCharacterAtXY
    545  79e6
    546  79e6							; TB_X 	 the man's position before he moved
    547  79e6							; TB_Y
    548  79e6							; TB_CHAR	 if -1 then there is no box push involved, else..
    549  79e6							;		 holds the character that was under the box in its new position
    550  79e6							;		 this can be inferred by the box character (ONTARGET)
    551  79e6							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    552  79e6							; TB_PUSHY
    553  79e6
    554  79e6		       20 57 f9 	      jsr	RecordTakeBackPosition
    555  79e9
    556  79e9		       68		      pla
    557  79ea		       85 8c		      sta	POS_VAR	; save 'restore' character
    558  79ec
    559  79ec		       a9 00	   MOVE_GENERIC lda	#0	; 2
    560  79ee		       85 a4		      sta	ManPushCounter	; 3
    561  79f0		       60		      rts		; 6 = 11
    562  79f1
    563  79f1							;---------------------------------------------------------------------------
    564  79f1							; takeback buffer empty - flash red
    565  79f1
    566  79f1		       a6 80	   noMovesToTake ldx	Platform
    567  79f3		       bd fd f9 	      lda	redColour,x
    568  79f6		       85 b1		      sta	BGColour
    569  79f8		       a9 06		      lda	#6
    570  79fa		       85 c1		      sta	ColourTimer
    571  79fc		       60		      rts
    572  79fd
    573  79fd		       32 32 62 62 redColour  .byte.b	$32, $32, $62, $62
    574  7a01
    575  7a01							;---------------------------------------------------------------------------
    576  7a01
      0  7a01					      DEFINE_SUBROUTINE	MOVE_BOX
      1  7a01		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  7a01					      SUBROUTINE
      3  7a01				   MOVE_BOX
    578  7a01
    579  7a01		       a2 00		      ldx	#CHARACTER_BLANK	; restoration character
    580  7a03		       a9 0d		      lda	#BANK_PushBox
    581  7a05		       85 3f		      sta	SET_BANK
    582  7a07		       4c dc f0 	      jmp	PushBox
    583  7a0a
      0  7a0a					      DEFINE_SUBROUTINE	MOVE_BOX_ON_TARGET
      1  7a0a		       00 0f	   BANK_MOVE_BOX_ON_TARGET =	_CURRENT_BANK
      2  7a0a					      SUBROUTINE
      3  7a0a				   MOVE_BOX_ON_TARGET
    585  7a0a
    586  7a0a		       a2 03		      ldx	#CHARACTER_TARGET	; restoration character
    587  7a0c		       a9 0d		      lda	#BANK_PushBox
    588  7a0e		       85 3f		      sta	SET_BANK
    589  7a10		       4c dc f0 	      jmp	PushBox
    590  7a13
    591  7a13							;---------------------------------------------------------------------------
    592  7a13
      0  7a13					      DEFINE_SUBROUTINE	takebackRestoreEarlierPosition
      1  7a13		       00 0f	   BANK_takebackRestoreEarlierPosition =	_CURRENT_BANK
      2  7a13					      SUBROUTINE
      3  7a13				   takebackRestoreEarlierPosition
    594  7a13
    595  7a13		       e6 ba		      inc	TakebackInhibit	; non-zero
    596  7a15
    597  7a15							; on reverting a move
    598  7a15							; IF BCD_moveCounter > 0
    599  7a15							;   BCD_moveCounter--
    600  7a15							;   IF TakeBackPushChar != -1
    601  7a15							;	 //restore the character under box (and remove box)
    602  7a15							;	 board[TakeBackPreviousX,TakeBackPreviousY] = TakeBackPushChar
    603  7a15							;   ENDIF
    604  7a15							; // We will "fix" any box going back on the board through the man's restoration char
    605  7a15							; board[ManX,ManY] = POS_VAR
    606  7a15							; POS_VAR = board[TakeBackX,TakeBackY]
    607  7a15							; board[TakeBackX,TakeBackY] = MANOCCUPIED
    608  7a15							; ManX,ManY = TakeBackX, TakeBackY
    609  7a15
    610  7a15		       a6 b8		      ldx	takebackIndex
    611  7a17		       e4 b9		      cpx	takebackBaseIndex
    612  7a19		       f0 d6		      beq	noMovesToTake
    613  7a1b
    614  7a1b		       ca		      dex
    615  7a1c		       8a		      txa
    616  7a1d		       29 3f		      and	#TAKEBACK_MASK
    617  7a1f		       85 b8		      sta	takebackIndex
    618  7a21		       aa		      tax
    619  7a22
    620  7a22		       f8		      sed
    621  7a23		       38		      sec
    622  7a24		       a5 b6		      lda	BCD_moveCounter
    623  7a26		       e9 01		      sbc	#1
    624  7a28		       85 b6		      sta	BCD_moveCounter
    625  7a2a		       a5 b7		      lda	BCD_moveCounter+1
    626  7a2c		       e9 00		      sbc	#0
    627  7a2e		       85 b7		      sta	BCD_moveCounter+1
    628  7a30		       d8		      cld
    629  7a31
    630  7a31				  -	      if	0
    631  7a31				  -	      lda	Platform
    632  7a31				  -	      clc
    633  7a31				  -	      adc	#8
    634  7a31				  -	      sta	BGColour	;ColourFlash		      ; yellow flash
    635  7a31				  -	      lda	#3
    636  7a31				  -	      sta	ColourTimer
    637  7a31					      endif
    638  7a31
    639  7a31		       a9 0e		      lda	#BANK_TAKEBACK
    640  7a33		       85 3e		      sta	SET_BANK_RAM
    641  7a35
    642  7a35							; TB_X 	 the man's position before he moved
    643  7a35							; TB_Y
    644  7a35							; TB_CHAR	 if -1 then there is no box push involved, else..
    645  7a35							;		 holds the character that was under the box in its new position
    646  7a35							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    647  7a35							; TB_PUSHY
    648  7a35
    649  7a35							;	 //restore the character under box (and remove box)
    650  7a35							;	 board[TakeBackPreviousX,TakeBackPreviousY] = TakeBackPushChar
    651  7a35
    652  7a35		       a5 8c		      lda	POS_VAR
    653  7a37		       48		      pha
    654  7a38
    655  7a38		       a6 b8		      ldx	takebackIndex
    656  7a3a		       bd 00 11 	      lda	TakeBackPushChar,x
    657  7a3d		       30 29		      bmi	noPushInvolved	; -1 = no box
    658  7a3f
    659  7a3f		       85 8c		      sta	POS_VAR
    660  7a41		       c9 03		      cmp	#CHARACTER_TARGET
    661  7a43		       f0 04		      beq	isaTarget
    662  7a45		       c9 04		      cmp	#CHARACTER_TARGET2
    663  7a47		       d0 03		      bne	notTarget1
    664  7a49		       20 f8 fc    isaTarget  jsr	RegisterTarget
    665  7a4c				   notTarget1
    666  7a4c
    667  7a4c
    668  7a4c		       bd 80 10 	      lda	TakeBackPushX,x
    669  7a4f		       85 87		      sta	POS_X
    670  7a51		       bd c0 10 	      lda	TakeBackPushY,x
    671  7a54		       85 88		      sta	POS_Y
    672  7a56
    673  7a56		       20 df f8 	      jsr	PutCharacterAtXY	; fixup BOX!
    674  7a59
    675  7a59		       68		      pla
    676  7a5a		       f0 07		      beq	blnkre
    677  7a5c		       20 02 fd 	      jsr	DeRegisterTarget
    678  7a5f		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    679  7a61		       d0 02		      bne	skls
    680  7a63		       a9 02	   blnkre     lda	#CHARACTER_BOX
    681  7a65		       85 8c	   skls       sta	POS_VAR
    682  7a67
    683  7a67		       48		      pha
    684  7a68
    685  7a68		       68	   noPushInvolved pla		; man's replacement char
    686  7a69		       85 8c		      sta	POS_VAR
    687  7a6b
    688  7a6b							; // We will "fix" any box going back on the board through the man's restoration char
    689  7a6b							; board[ManX,ManY] = POS_VAR
    690  7a6b							; POS_VAR = board[TakeBackX,TakeBackY]
    691  7a6b							; board[TakeBackX,TakeBackY] = MANOCCUPIED
    692  7a6b							; ManX,ManY = TakeBackX, TakeBackY
    693  7a6b
    694  7a6b		       a5 9d		      lda	ManX
    695  7a6d		       85 87		      sta	POS_X
    696  7a6f		       a5 9e		      lda	ManY
    697  7a71		       85 88		      sta	POS_Y
    698  7a73		       20 df f8 	      jsr	PutCharacterAtXY	; put what man was on... back
    699  7a76
    700  7a76
    701  7a76		       a9 0e		      lda	#BANK_TAKEBACK
    702  7a78		       85 3e		      sta	SET_BANK_RAM
    703  7a7a
    704  7a7a		       a6 b8		      ldx	takebackIndex
    705  7a7c		       bd 00 10 	      lda	TakeBackPreviousX,x
    706  7a7f		       85 89		      sta	POS_X_NEW
    707  7a81		       85 9d		      sta	ManX
    708  7a83		       bd 40 10 	      lda	TakeBackPreviousY,x
    709  7a86		       85 8a		      sta	POS_Y_NEW
    710  7a88		       85 9e		      sta	ManY
    711  7a8a
    712  7a8a							; Grab the character from the board at man's location and use as "restore character" for man
    713  7a8a							; POS_VAR = board[takebackx,takebacky]
    714  7a8a
    715  7a8a		       a9 0d		      lda	#BANK_GetBoardAddressR
    716  7a8c		       85 3f		      sta	SET_BANK
    717  7a8e		       a4 8a		      ldy	POS_Y_NEW
    718  7a90		       20 bf f0 	      jsr	GetBoardAddressR
    719  7a93		       85 3e		      sta	SET_BANK_RAM
    720  7a95
    721  7a95		       a4 89		      ldy	POS_X_NEW
    722  7a97		       b1 bb		      lda	(Board_AddressR),y
    723  7a99							;pha
    724  7a99							;lda #CHARACTER_MANOCCUPIED
    725  7a99							;sta POS_VAR
    726  7a99							;jsr PutCharacterAtXY		 ????
    727  7a99							;pla
    728  7a99		       85 8c		      sta	POS_VAR
    729  7a9b
    730  7a9b		       a5 bf		      lda	ROM_Bank
    731  7a9d		       85 3f		      sta	SET_BANK
    732  7a9f
    733  7a9f		       60	   timeExit   rts
    734  7aa0
    735  7aa0							;---------------------------------------------------------------------------
    736  7aa0
      0  7aa0					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7aa0		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7aa0					      SUBROUTINE
      3  7aa0				   StealCharDraw
    738  7aa0
    739  7aa0		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    740  7aa2		       85 3e		      sta	SET_BANK_RAM	; 3
    741  7aa4		       a4 81		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    742  7aa6		       10 35		      bpl	EnterStealCharDraw	; 2(3) = 10(11)
    743  7aa8
    744  7aa8				   ExitStealCharDraw
    745  7aa8
    746  7aa8							; fall through...
    747  7aa8
    748  7aa8							;---------------------------------------------------------------------------
    749  7aa8
      0  7aa8					      DEFINE_SUBROUTINE	TimeSlice
      1  7aa8		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7aa8					      SUBROUTINE
      3  7aa8				   TimeSlice
    751  7aa8
    752  7aa8							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    753  7aa8							; going ahead if there's insufficient time. This allows the previous character drawing to
    754  7aa8							; be much smaller in time, as they don't have to include the timeslice code overhead.
    755  7aa8
    756  7aa8		       ad 84 02 	      lda	INTIM	; 4
    757  7aab		       c9 03		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    758  7aad		       90 f0		      bcc	timeExit	; 2(3)
    759  7aaf							; @0✅
    760  7aaf
    761  7aaf							; Uses the phase variable to vector to the correct processing code for the given timeslice
    762  7aaf							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    763  7aaf							; it should increment ScreenDrawPhase.
    764  7aaf
    765  7aaf							; Switched-in bank(s) are undefined after this function is called!
    766  7aaf
    767  7aaf		       a9 03		      lda	#BANK_TS_PhaseVectorLO	; 2
    768  7ab1		       85 3f		      sta	SET_BANK	; 3 = 5
    769  7ab3
    770  7ab3		       a6 86		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    771  7ab5		       bd ff f4 	      lda	TS_PhaseVectorLO,x	; 4
    772  7ab8		       85 d7		      sta	TS_Vector	; 3
    773  7aba		       bd 04 f5 	      lda	TS_PhaseVectorHI,x	; 4
    774  7abd		       85 d8		      sta	TS_Vector+1	; 3 = 17
    775  7abf
    776  7abf		       bd 09 f5 	      lda	TS_PhaseBank,x	; 4
    777  7ac2		       85 3f		      sta	SET_BANK	; 3 = 7	 switch bank
    778  7ac4
    779  7ac4		       6c d7 00 	      jmp	(TS_Vector)	; 5 = 31✅	  vector to timeslice handler
    780  7ac7
    781  7ac7							;---------------------------------------------------------------------------
    782  7ac7
    783  7ac7
    784  7ac7				   DrawAnother		;344✅SCD_QUICK
    785  7ac7							;676✅SCD_SLOW
    786  7ac7
    787  7ac7
    788  7ac7							; add 44✅ cycles for the following in the case where there is something to draw
    789  7ac7							; but no time to do it. As this is executed after EVERY type of draw, then this
    790  7ac7							; is the base "extra" cost to add to each draw
    791  7ac7
    792  7ac7		       00 35	   CYCLES_DRAWANOTHER =	53	;✅
    793  7ac7
    794  7ac7		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    795  7ac9		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    796  7acb
    797  7acb		       a4 81		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    798  7acd
    799  7acd		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    800  7ad0		       bd a0 f0 	      lda	ScreenBuffer,x	; 4	     new character to draw
    801  7ad3		       29 7f		      and	#~128	; 2
    802  7ad5		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    803  7ad8
    804  7ad8		       88		      dey		; 2
    805  7ad9		       84 81		      sty	DrawStackPointer	; 3	     one less to draw
    806  7adb		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7    NOTE1: (3)+(15exit) -->45✅ <CYCLES_DRAWANOTHER)
    807  7add							; => 29
    808  7add
    809  7add				   EnterStealCharDraw		; @11✅ from initial StealCharDraw call
    810  7add							; RAM bank MUST be at BANK_DRAW_BUFFERS
    811  7add
    812  7add		       ad 84 02 	      lda	INTIM	; 4
    813  7ae0		       c9 04		      cmp	#SEGTIME_SCD_MIN	; 2
    814  7ae2		       90 c4		      bcc	ExitStealCharDraw	; 2(3) = 8    ((9)+(15exit) IF EXITING HERE, from DrawAnother... 53✅)
    815  7ae4							;		else exit from StealCharDraw ... 26✅
    816  7ae4							; @0✅
    817  7ae4
    818  7ae4		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    819  7ae7		       bc a0 f0 	      ldy	ScreenBuffer,x	; 4 =	8✅  new character to draw
    820  7aea
    821  7aea		       bd 00 f2 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
    822  7aed		       85 3e		      sta	SET_BANK_RAM	; 3
    823  7aef		       4c 29 f1 	      jmp	StealPart3	; 3 = 10✅  --> 18✅ cycles after check for SEGTIME_SCD_MIN
    824  7af2
    825  7af2							;---------------------------------------------------------------------------
    826  7af2
    827  7af2
      0  7af2					      DEFINE_SUBROUTINE	writePlayerFrame
      1  7af2		       00 0f	   BANK_writePlayerFrame =	_CURRENT_BANK
      2  7af2					      SUBROUTINE
      3  7af2				   writePlayerFrame
    829  7af2
    830  7af2		       a5 80		      lda	Platform
    831  7af4		       29 02		      and	#%10
    832  7af6		       0a		      asl
    833  7af7		       0a		      asl
    834  7af8		       65 c5		      adc	ethnic
    835  7afa		       85 dc		      sta	ethnicity
    836  7afc
    837  7afc
    838  7afc							; todo - compare with last + frame and skip if same
    839  7afc
    840  7afc		       a9 0a		      lda	#PLAYER_FRAMES
    841  7afe		       85 3f		      sta	SET_BANK
    842  7b00
    843  7b00		       a5 9c		      lda	animation_delay
    844  7b02		       f0 0f		      beq	getDelay	; FIRST usage
    845  7b04		       c6 9c		      dec	animation_delay
    846  7b06		       d0 11		      bne	nextAnimation2	; just get shape
    847  7b08
    848  7b08		       18	   nextAptr   clc
    849  7b09		       a5 9a		      lda	animation
    850  7b0b		       69 02		      adc	#2
    851  7b0d		       85 9a		      sta	animation
    852  7b0f		       90 02		      bcc	ahiok
    853  7b11		       e6 9b		      inc	animation+1
    854  7b13				   ahiok
    855  7b13		       a0 01	   getDelay   ldy	#1
    856  7b15		       b1 9a		      lda	(animation),y
    857  7b17		       85 9c		      sta	animation_delay
    858  7b19		       a0 00	   nextAnimation2 ldy	#0
    859  7b1b		       b1 9a		      lda	(animation),y
    860  7b1d		       c9 ff		      cmp	#JUMP
    861  7b1f		       f0 0d		      beq	aJump
    862  7b21		       c9 fe		      cmp	#FLIP
    863  7b23		       d0 18		      bne	notFlip
    864  7b25
    865  7b25		       a5 a2		      lda	ManLastDirection
    866  7b27		       49 08		      eor	#%1000
    867  7b29		       85 a2		      sta	ManLastDirection
    868  7b2b		       4c 08 fb 	      jmp	nextAptr
    869  7b2e
    870  7b2e							; it's a jump
    871  7b2e		       a4 9c	   aJump      ldy	animation_delay	; actually animation ID :)
    872  7b30		       b9 00 f0 	      lda	ANIM_TABLE,y
    873  7b33		       85 9a		      sta	animation
    874  7b35		       b9 01 f0 	      lda	ANIM_TABLE+1,y
    875  7b38		       85 9b		      sta	animation+1
    876  7b3a		       4c 13 fb 	      jmp	getDelay
    877  7b3d
    878  7b3d		       a8	   notFlip    tay
    879  7b3e
    880  7b3e		       a5 a0		      lda	ManDrawY
    881  7b40		       30 44		      bmi	SkipFrameCopy
    882  7b42		       85 db		      sta	bank	; character line (and hence bank) of player position
    883  7b44		       85 3e		      sta	SET_BANK_RAM
    884  7b46
    885  7b46							; Now we have the frame #, we can see if that frame has already been drawn into
    886  7b46							; the frame buffer of the relevant bank. If it has, then we don't need to repeat
    887  7b46							; and can save the enormous cost of frame copying...
    888  7b46
    889  7b46		       cc 69 f3 	      cpy	ExistingFrame	; optimize - don't draw if same frame
    890  7b49		       f0 3b		      beq	SkipFrameCopy
    891  7b4b		       8c 69 f7 	      sty	ExistingFrame + RAM_WRITE
    892  7b4e
    893  7b4e		       a9 0a		      lda	#PLAYER_FRAMES
    894  7b50		       85 3f		      sta	SET_BANK
    895  7b52		       b9 2a f5 	      lda	FRAME_PTR_LO,y
    896  7b55		       85 d7		      sta	frame_ptr
    897  7b57		       b9 41 f5 	      lda	FRAME_PTR_HI,y
    898  7b5a		       85 d8		      sta	frame_ptr+1
    899  7b5c
    900  7b5c		       b9 58 f5 	      lda	COLOUR_PTR_LO,y
    901  7b5f		       85 d9		      sta	colour_ptr
    902  7b61		       b9 6f f5 	      lda	COLOUR_PTR_HI,y
    903  7b64		       85 da		      sta	colour_ptr+1
    904  7b66
    905  7b66
    906  7b66
    907  7b66		       a0 17		      ldy	#LINES_PER_CHAR-1
    908  7b68		       18		      clc
    909  7b69				   CopySpriteToBank		; 408
    910  7b69
    911  7b69							; The colours for the sprites are copied to the row bank's colour data. The frames contain
    912  7b69							; colour *indexes*. These indexes are modified by the *base* which indicates both the
    913  7b69							; system NTSC/PAL along with the "visual identity" (i.e., colour/race). That is used to
    914  7b69							; lookup a colour conversion which FINALLY gives us the correct colour to use for the line.
    915  7b69
    916  7b69							; ethnicity * 16 + PALNTSC * 8
    917  7b69
    918  7b69		       a9 0a		      lda	#PLAYER_FRAMES
    919  7b6b		       85 3f		      sta	SET_BANK
    920  7b6d
    921  7b6d		       b1 d9		      lda	(colour_ptr),y
    922  7b6f		       65 dc		      adc	ethnicity	; colour base
    923  7b71		       aa		      tax
    924  7b72		       b1 d7		      lda	(frame_ptr),y
    925  7b74		       48		      pha
    926  7b75		       a5 db		      lda	bank
    927  7b77		       85 3e		      sta	SET_BANK_RAM
    928  7b79		       bd a5 f2 	      lda	EthnicityColourPalette,x
    929  7b7c		       99 51 f7 	      sta	PLAYER0_COLOUR+RAM_WRITE,y
    930  7b7f		       68		      pla
    931  7b80		       99 39 f7 	      sta	PLAYER0_SHAPE+RAM_WRITE,y
    932  7b83		       88		      dey
    933  7b84		       10 e3		      bpl	CopySpriteToBank
    934  7b86
    935  7b86				   skipOffscreen
    936  7b86		       60	   SkipFrameCopy rts
    937  7b87
    938  7b87							;---------------------------------------------------------------------------
    939  7b87
    940  7b87							;    DEFINE_SUBROUTINE DrawFullScreenMain ;=2484[-89]
    941  7b87
    942  7b87							; Check the screen for all those characters that need to be redrawn
    943  7b87							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
    944  7b87							; the drawflags array is different to the ScreenBuffer array entry, then the
    945  7b87							; screenbuffer will need redrawing.
    946  7b87
    947  7b87							; @59✅
    948  7b87
    949  7b87				   CopyRow2
    950  7b87
    951  7b87							;    IF MULTI_BANK_BOARD = YES
    952  7b87							;		  lda BDF_BoardBank		  ; 3
    953  7b87							;    ELSE
    954  7b87		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
    955  7b89							;    ENDIF
    956  7b89		       85 3e		      sta	SET_BANK_RAM	; 3
    957  7b8b		       b3 db		      lax	(BDF_BoardAddress),y	; 5
    958  7b8d		       9a		      txs		; 2
    959  7b8e		       b3 dd		      lax	(BDF_BoardAddress2),y	; 5 = 17✅
    960  7b90
    961  7b90		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    962  7b92		       85 3e		      sta	SET_BANK_RAM	; 3
    963  7b94		       bd db f1 	      lda	CharReplacement,x	; 4
    964  7b97		       91 d9		      sta	(BDF_DrawFlagAddress2),y	; 6
    965  7b99		       ba		      tsx		; 2
    966  7b9a		       bd db f1 	      lda	CharReplacement,x	; 4
    967  7b9d		       91 d7		      sta	(BDF_DrawFlagAddress),y	; 6 = 27 @44✅
    968  7b9f
    969  7b9f		       88		      dey		; 2
    970  7ba0		       10 e5		      bpl	CopyRow2	; 2/3 @48 (-1)
    971  7ba2
      0  7ba2					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED"
      9  7ba2					      LIST	ON
    973  7ba2
    974  7ba2							; cost = 5 (rows) x 48 - 1 = 239
    975  7ba2							; @ (59) + 239 = @298✅
    976  7ba2
    977  7ba2		       a7 e0		      lax	DHS_Line	; 3
    978  7ba4		       f0 07		      beq	.exitCopy	; 2/3= 5/6
    979  7ba6
    980  7ba6		       a0 0d		      ldy	#BANK_DrawScreenRowPreparation	; 2
    981  7ba8		       84 3f		      sty	SET_BANK	; 3
    982  7baa		       4c 12 f3 	      jmp	DrawScreenRowPreparation	; 3 = 8
    983  7bad							; @298+8+5 = @311✅
    984  7bad
    985  7bad
    986  7bad							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
    987  7bad
    988  7bad
      0  7bad					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7bad					      LIST	ON
    990  7bad
    991  7bad		       a6 e1	   .exitCopy  ldx	DHS_Stack	; 3
    992  7baf		       9a		      txs		; 2
    993  7bb0
    994  7bb0							; fall through
    995  7bb0
      0  7bb0					      DEFINE_SUBROUTINE	BuildDrawStack	; @31✅
      1  7bb0		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7bb0					      SUBROUTINE
      3  7bb0				   BuildDrawStack
    997  7bb0
    998  7bb0		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    999  7bb2		       85 3e		      sta	SET_BANK_RAM	; 3
   1000  7bb4		       4c f1 f0 	      jmp	DrawStackUpdate	; 3
   1001  7bb7
   1002  7bb7							; => @39 at DrawStackUpdate
   1003  7bb7
   1004  7bb7							;---------------------------------------------------------------------------
   1005  7bb7
      0  7bb7					      DEFINE_SUBROUTINE	DrawAIntoStack	; @31✅
      1  7bb7		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7bb7					      SUBROUTINE
      3  7bb7				   DrawAIntoStack
   1007  7bb7
   1008  7bb7		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
   1009  7bb9		       85 3e		      sta	SET_BANK_RAM	; 3
   1010  7bbb		       4c 28 f1 	      jmp	DrawIntoStack	; 3
   1011  7bbe
   1012  7bbe							; ==>39✅ @DrawIntoStack
   1013  7bbe
   1014  7bbe							;---------------------------------------------------------------------------
   1015  7bbe
   1016  7bbe
      0  7bbe					      DEFINE_SUBROUTINE	Reset
      1  7bbe		       00 0f	   BANK_Reset =	_CURRENT_BANK
      2  7bbe					      SUBROUTINE
      3  7bbe				   Reset
   1018  7bbe
      0  7bbe					      CLEAN_START
      1  7bbe		       78		      sei
      2  7bbf		       d8		      cld
      3  7bc0
      4  7bc0		       a2 00		      ldx	#0
      5  7bc2		       8a		      txa
      6  7bc3		       a8		      tay
      7  7bc4		       ca	   .CLEAR_STACK dex
      8  7bc5		       9a		      txs
      9  7bc6		       48		      pha
     10  7bc7		       d0 fb		      bne	.CLEAR_STACK
     11  7bc9
   1020  7bc9
   1021  7bc9							;lda #2
   1022  7bc9							;sta VSYNC
   1023  7bc9							;lda #%01000010		  ; bit6 is not required
   1024  7bc9							;sta VBLANK			  ; end of screen - enter blanking
   1025  7bc9
   1026  7bc9							; Scoring bank is copied once (not per game, not per level...)
   1027  7bc9							; otherwise non-SaveKey high score gets zapped
   1028  7bc9
   1029  7bc9		       a2 02		      ldx	#ROM_SHADOW_OF_BANK_SCORING
   1030  7bcb		       a0 09		      ldy	#BANK_SCORING
   1031  7bcd		       20 ef fc 	      jsr	CopyROM2RAM_F000
   1032  7bd0
   1033  7bd0				   Restart		; go here on RESET + SELECT
   1034  7bd0
   1035  7bd0							; breakpoint was not hit/detected!!!
   1036  7bd0
      0  7bd0					      DEFINE_SUBROUTINE	Title
      1  7bd0		       00 0f	   BANK_Title =	_CURRENT_BANK
      2  7bd0					      SUBROUTINE
      3  7bd0				   Title
   1038  7bd0		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
   1039  7bd2		       9a		      txs
   1040  7bd3
   1041  7bd3							; temporary vars from title screen are used to init level
   1042  7bd3		       a9 03		      lda	#BANK_Cart_Init	; 2
   1043  7bd5		       85 3f		      sta	SET_BANK	; 3
   1044  7bd7		       20 e9 f3 	      jsr	Cart_Init	; 6+x
   1045  7bda
   1046  7bda
   1047  7bda							;---------------------------------------------------------------------------
   1048  7bda
   1049  7bda
   1050  7bda		       f0 00	   SEGMENT_DECODE_LEVEL_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
   1051  7bda
   1052  7bda		       a2 03		      ldx	#BANK_DECODE_LEVEL_SHADOW
   1053  7bdc		       a0 0a		      ldy	#BANK_DECODE_LEVEL
   1054  7bde		       20 ef fc 	      jsr	CopyROM2RAM_F000
   1055  7be1
   1056  7be1
   1057  7be1							;---------------------------------------------------------------------------
   1058  7be1							; Once-only game initialisation goes here...
   1059  7be1							; now we have two players so things get a bit tricky
   1060  7be1
   1061  7be1		       a9 09		      lda	#BANK_SCORING
   1062  7be3		       85 3e		      sta	SET_BANK_RAM
   1063  7be5		       20 63 f3 	      jsr	GameInitialise
   1064  7be8
   1065  7be8
   1066  7be8							;---------------------------------------------------------------------------
   1067  7be8
------- FILE sound/intro1_init.asm LEVEL 3 PASS 3
      0  7be8					      include	"sound/intro1_init.asm"
      1  7be8							; TIATracker music player
      2  7be8							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7be8							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7be8							; Email: andre.wichmann@gmx.de
      5  7be8							;
      6  7be8							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7be8							; you may not use this file except in compliance with the License.
      8  7be8							; You may obtain a copy of the License at
      9  7be8							;
     10  7be8							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7be8							;
     12  7be8							; Unless required by applicable law or agreed to in writing, software
     13  7be8							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7be8							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7be8							; See the License for the specific language governing permissions and
     16  7be8							; limitations under the License.
     17  7be8
     18  7be8							; Song author: 
     19  7be8							; Song name: 
     20  7be8
     21  7be8							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7be8
     23  7be8							; =====================================================================
     24  7be8							; Initialize music.
     25  7be8							; Set tt_cur_pat_index_c0/1 to the indexes of the first patterns from
     26  7be8							; tt_SequenceTable for each channel.
     27  7be8							; Set tt_timer and tt_cur_note_index_c0/1 to 0.
     28  7be8							; All other variables can start with any value.
     29  7be8							; =====================================================================
     30  7be8		       a9 00		      lda	#0
     31  7bea		       85 cd		      sta	tt_cur_pat_index_c0
     32  7bec		       a9 05		      lda	#5
     33  7bee		       85 ce		      sta	tt_cur_pat_index_c1
     34  7bf0							; the rest should be 0 already from startup code. If not,
     35  7bf0							; set the following variables to 0 manually:
     36  7bf0							; - tt_timer
     37  7bf0							; - tt_cur_pat_index_c0
     38  7bf0							; - tt_cur_pat_index_c1
     39  7bf0							; - tt_cur_note_index_c0
     40  7bf0							; - tt_cur_note_index_c1
     41  7bf0
------- FILE BANK_FIXED.asm
   1069  7bf0
      0  7bf0					      SET_PLATFORM
      1  7bf0
      2  7bf0
      3  7bf0
      4  7bf0
      5  7bf0		       ad 82 02 	      lda	SWCHB
      6  7bf3		       2a		      rol
      7  7bf4		       2a		      rol
      8  7bf5		       2a		      rol
      9  7bf6		       29 03		      and	#%11
     10  7bf8		       49 02		      eor	#PAL
     11  7bfa		       85 80		      sta	Platform
   1071  7bfc
   1072  7bfc		       a9 0b		      lda	#BANK_TitleScreen
   1073  7bfe		       85 3f		      sta	SET_BANK
   1074  7c00		       20 00 f0 	      jsr	TitleSequence
   1075  7c03
   1076  7c03		       4c 15 fc 	      jmp	NextLevelLevel
   1077  7c06
   1078  7c06				   RestartLevelNextPlayer
   1079  7c06
   1080  7c06		       a9 03		      lda	#BANK_SwapPlayersGeneric
   1081  7c08		       85 3f		      sta	SET_BANK
   1082  7c0a		       20 30 f4 	      jsr	SwapPlayersGeneric
   1083  7c0d
   1084  7c0d
   1085  7c0d		       a2 0c		      ldx	#BANK_LevelScreen
   1086  7c0f		       86 3f		      stx	SET_BANK
   1087  7c11
   1088  7c11		       a9 01		      lda	#1
   1089  7c13		       d0 06		      bne	selectLeveler
   1090  7c15
      0  7c15					      DEFINE_SUBROUTINE	NextLevelLevel
      1  7c15		       00 0f	   BANK_NextLevelLevel =	_CURRENT_BANK
      2  7c15					      SUBROUTINE
      3  7c15				   NextLevelLevel
   1092  7c15
   1093  7c15
   1094  7c15		       a2 0c		      ldx	#BANK_LevelScreen
   1095  7c17		       86 3f		      stx	SET_BANK
   1096  7c19
   1097  7c19		       a9 00		      lda	#0
   1098  7c1b		       20 53 f0    selectLeveler jsr	LevelScreen
   1099  7c1e
   1100  7c1e							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
   1101  7c1e							; including those for general systems function. But NOT those which do not need re-initialising between
   1102  7c1e							; levels.
   1103  7c1e		       a9 03		      lda	#BANK_LevelInit	; 2
   1104  7c20		       85 3f		      sta	SET_BANK	; 3
   1105  7c22		       20 70 f4 	      jsr	LevelInit	; 6+x
   1106  7c25
   1107  7c25
   1108  7c25							; Setup the various digit and display pointers
   1109  7c25							; Grab current player's score/level from backup
   1110  7c25
   1111  7c25		       a9 09		      lda	#BANK_SCORING
   1112  7c27		       85 3e		      sta	SET_BANK_RAM
   1113  7c29		       20 83 f2 	      jsr	GeneralScoringSetups
   1114  7c2c
   1115  7c2c							; copy the screen draw ROM shadow to RAM
   1116  7c2c
   1117  7c2c		       a0 07		      ldy	#SCREEN_LINES-1
   1118  7c2e		       a2 00	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
   1119  7c30		       20 ef fc 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
   1120  7c33		       20 77 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
   1121  7c36		       88		      dey
   1122  7c37		       10 f5		      bpl	CopyScreenBanks
   1123  7c39
   1124  7c39		       a2 01		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
   1125  7c3b		       a0 08		      ldy	#BANK_DRAW_BUFFERS
   1126  7c3d		       20 43 f0 	      jsr	CopyROMShadowToRAM_F000
   1127  7c40
   1128  7c40
   1129  7c40		       a9 0a		      lda	#BANK_DECODE_LEVEL
   1130  7c42		       85 3e		      sta	SET_BANK_RAM
   1131  7c44		       20 70 f2 	      jsr	UnpackLevel
   1132  7c47
   1133  7c47		       a9 28		      lda	#SIZE_BOARD_X
   1134  7c49		       85 94		      sta	BoardLimit_Width
   1135  7c4b		       a9 16		      lda	#SIZE_BOARD_Y
   1136  7c4d		       85 95		      sta	BoardLimit_Height
   1137  7c4f
   1138  7c4f							; Setup player animation and scroll limits.
   1139  7c4f							; Mangle the board colours based on level
   1140  7c4f
   1141  7c4f		       a9 03		      lda	#BANK_CreateCreatures	; 2
   1142  7c51		       85 3f		      sta	SET_BANK	; 3
   1143  7c53		       20 39 f4 	      jsr	CreateCreatures	; 6+x
   1144  7c56
   1145  7c56							;---------------------------------------------------------------------------
   1146  7c56
   1147  7c56					      IF	WAIT_FOR_INITIAL_DRAW
   1148  7c56		       a9 02		      lda	#%10
   1149  7c58		       85 ae		      sta	blankState
   1150  7c5a					      ENDIF
   1151  7c5a
   1152  7c5a		       a9 03		      lda	#BANK_Resync	; 2
   1153  7c5c		       85 3f		      sta	SET_BANK	; 3
   1154  7c5e		       20 a0 f4 	      jsr	Resync	; 6+x
   1155  7c61
   1156  7c61				   NewFrameStart
   1157  7c61
   1158  7c61		       24 c2		      bit	NextLevelTrigger
   1159  7c63		       70 a1		      bvs	RestartLevelNextPlayer	; loss of life (=SELECT)
   1160  7c65		       10 ae		      bpl	NextLevelLevel	; game-triggered next level (=RESET/COMPLETED)
   1161  7c67
   1162  7c67							; Note: VSYNC must NOT be on when starting a new level! Else you get annoying TV signals.
   1163  7c67
   1164  7c67		       a9 0e		      lda	#%1110	; VSYNC ON
   1165  7c69		       85 42	   .loopVSync sta	WSYNC
   1166  7c6b		       85 40		      sta	VSYNC
   1167  7c6d		       4a		      lsr
   1168  7c6e		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
   1169  7c70
   1170  7c70							; moved *after* the loop since this allows to *increase* timer values by 1!
   1171  7c70
   1172  7c70		       a6 80		      ldx	Platform
   1173  7c72		       bc b5 fc 	      ldy	VBlankTime,x
   1174  7c75		       8c 96 02 	      sty	TIM64T
   1175  7c78
   1176  7c78		       a9 0d		      lda	#BANK_SoundFX
   1177  7c7a		       85 3f		      sta	SET_BANK
   1178  7c7c		       20 b0 f3 	      jsr	SoundFX
   1179  7c7f
   1180  7c7f		       20 a0 fa 	      jsr	StealCharDraw	; 6 NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
   1181  7c82
   1182  7c82							;---------------------------------------------------------------------------
   1183  7c82
   1184  7c82		       a9 09		      lda	#BANK_SCORING	; 2
   1185  7c84		       85 3e		      sta	SET_BANK_RAM	; 3
   1186  7c86		       20 e8 f1 	      jsr	DrawDigits	; 6 = 11
   1187  7c89
   1188  7c89							;---------------------------------------------------------------------------
   1189  7c89							; A 42-cycle timing window in the screen draw code.  Perform any general
   1190  7c89							; per-frame code here, provided it takes exactly 42 cycles to execute.
   1191  7c89							; TJ: Well, not exactly 42 cycles, but it works! :)
   1192  7c89
   1193  7c89		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
   1194  7c8b		       85 3f		      sta	SET_BANK	; testing
   1195  7c8d		       85 3e		      sta	SET_BANK_RAM	; 3
   1196  7c8f		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1197  7c92							;	 @66
   1198  7c92		       a9 03		      lda	#BANK_PostScreenCleanup	; 2
   1199  7c94		       85 3f		      sta	SET_BANK	; 3
   1200  7c96		       20 16 f5 	      jsr	PostScreenCleanup	; 6+x
   1201  7c99
   1202  7c99		       a9 00		      lda	#BANK_SelfModDrawPlayers	; 2
   1203  7c9b		       85 3f		      sta	SET_BANK	; 3
   1204  7c9d		       20 74 f2 	      jsr	SelfModDrawPlayers	; 6+x
   1205  7ca0
   1206  7ca0				   SkipSc
   1207  7ca0
   1208  7ca0		       a9 00		      lda	#0
   1209  7ca2		       85 3e		      sta	SET_BANK_RAM
   1210  7ca4		       20 ad f3 	      jsr	FixColours
   1211  7ca7
   1212  7ca7		       20 f2 fa 	      jsr	writePlayerFrame
   1213  7caa		       20 a0 fa 	      jsr	StealCharDraw	; 6
   1214  7cad
   1215  7cad		       ad 84 02    OverscanBD lda	INTIM	;4
   1216  7cb0		       d0 fb		      bne	OverscanBD	;2/3
   1217  7cb2
   1218  7cb2		       4c 61 fc 	      jmp	NewFrameStart
   1219  7cb5				   VBlankTime
   1220  7cb5		       30 30		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
   1221  7cb7		       55 55		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_PAL
   1222  7cb9
   1223  7cb9							;---------------------------------------------------------------------------
   1224  7cb9
      0  7cb9					      DEFINE_SUBROUTINE	nextLevelMan
      1  7cb9		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7cb9					      SUBROUTINE
      3  7cb9				   nextLevelMan
   1226  7cb9
   1227  7cb9		       a9 0d		      lda	#BANK_EndOfLevel
   1228  7cbb		       85 3f		      sta	SET_BANK
   1229  7cbd		       4c 38 f3 	      jmp	EndOfLevel
   1230  7cc0
   1231  7cc0
      0  7cc0					      DEFINE_SUBROUTINE	switchLevels2
      1  7cc0		       00 0f	   BANK_switchLevels2 =	_CURRENT_BANK
      2  7cc0					      SUBROUTINE
      3  7cc0				   switchLevels2
   1233  7cc0
   1234  7cc0							; SELECT used, so we want to get back to selection
   1235  7cc0
   1236  7cc0		       a5 c2		      lda	NextLevelTrigger
   1237  7cc2		       09 40		      ora	#$40	; #<(~BIT_NEXTLEVEL)
   1238  7cc4		       85 c2		      sta	NextLevelTrigger
   1239  7cc6		       60		      rts
   1240  7cc7
      0  7cc7					      DEFINE_SUBROUTINE	nextLevelMan2
      1  7cc7		       00 0f	   BANK_nextLevelMan2 =	_CURRENT_BANK
      2  7cc7					      SUBROUTINE
      3  7cc7				   nextLevelMan2
   1242  7cc7
   1243  7cc7		       c6 a9		      dec	DelayEndOfLevel
   1244  7cc9		       d0 36		      bne	genericRTS
   1245  7ccb
   1246  7ccb		       a9 05		      lda	#5
   1247  7ccd		       85 a9		      sta	DelayEndOfLevel
   1248  7ccf
   1249  7ccf		       a9 0d		      lda	#MANMODE_NEXTLEVEL3
   1250  7cd1		       85 a1		      sta	ManMode
   1251  7cd3		       4c d6 fc 	      jmp	nextLevelMan3
   1252  7cd6							;		  rts
   1253  7cd6
   1254  7cd6
      0  7cd6					      DEFINE_SUBROUTINE	nextLevelMan3
      1  7cd6		       00 0f	   BANK_nextLevelMan3 =	_CURRENT_BANK
      2  7cd6					      SUBROUTINE
      3  7cd6				   nextLevelMan3
   1256  7cd6
   1257  7cd6		       c6 a9		      dec	DelayEndOfLevel
   1258  7cd8		       d0 27		      bne	genericRTS
   1259  7cda
   1260  7cda		       a9 09		      lda	#MANMODE_SWITCH
   1261  7cdc		       85 a1		      sta	ManMode
   1262  7cde
      0  7cde					      DEFINE_SUBROUTINE	switchLevels
      1  7cde		       00 0f	   BANK_switchLevels =	_CURRENT_BANK
      2  7cde					      SUBROUTINE
      3  7cde				   switchLevels
   1264  7cde
   1265  7cde							; Now do the actual switching
   1266  7cde
   1267  7cde							;		 lda NextLevelTrigger
   1268  7cde							;		 and #<(~BIT_NEXTLEVEL)
   1269  7cde		       a9 00		      lda	#$00
   1270  7ce0		       85 c2		      sta	NextLevelTrigger
   1271  7ce2
   1272  7ce2							; Next level is due. Point to the next level, but if we're at the end of playable levels,
   1273  7ce2							; then increment the level number. This is completely circular, so we eventually wrap
   1274  7ce2							; the level back to 0 and start afresh.
   1275  7ce2
   1276  7ce2		       e6 b2		      inc	levelX
   1277  7ce4		       a5 b2		      lda	levelX
   1278  7ce6		       c9 9e		      cmp	#MAX_LEVEL_NUMBER
   1279  7ce8		       90 02		      bcc	.level_ok
   1280  7cea		       a9 00		      lda	#0
   1281  7cec		       85 b2	   .level_ok  sta	levelX
   1282  7cee		       60		      rts
   1283  7cef
   1284  7cef							;---------------------------------------------------------------------------
   1285  7cef
   1286  7cef
      0  7cef					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7cef		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7cef					      SUBROUTINE
      3  7cef				   CopyROM2RAM_F000
   1288  7cef
   1289  7cef		       a9 0d		      lda	#BANK_CopyROMShadowToRAM
   1290  7cf1		       85 3f		      sta	SET_BANK
   1291  7cf3		       85 bf		      sta	ROM_Bank
   1292  7cf5		       4c 43 f0 	      jmp	CopyROMShadowToRAM_F000
   1293  7cf8
   1294  7cf8
   1295  7cf8							;---------------------------------------------------------------------------
   1296  7cf8
      0  7cf8					      DEFINE_SUBROUTINE	RegisterTarget
      1  7cf8		       00 0f	   BANK_RegisterTarget =	_CURRENT_BANK
      2  7cf8					      SUBROUTINE
      3  7cf8				   RegisterTarget
   1298  7cf8
   1299  7cf8		       f8		      sed
   1300  7cf9		       18		      clc
   1301  7cfa		       a5 b5		      lda	BCD_targetsRequired
   1302  7cfc		       69 01		      adc	#1
   1303  7cfe		       85 b5		      sta	BCD_targetsRequired
   1304  7d00		       d8		      cld
   1305  7d01		       60	   genericRTS rts
   1306  7d02
      0  7d02					      DEFINE_SUBROUTINE	DeRegisterTarget
      1  7d02		       00 0f	   BANK_DeRegisterTarget =	_CURRENT_BANK
      2  7d02					      SUBROUTINE
      3  7d02				   DeRegisterTarget
   1308  7d02
   1309  7d02		       f8		      sed
   1310  7d03		       38		      sec
   1311  7d04		       a5 b5		      lda	BCD_targetsRequired
   1312  7d06		       e9 01		      sbc	#1
   1313  7d08		       85 b5		      sta	BCD_targetsRequired
   1314  7d0a		       d8		      cld
   1315  7d0b		       60		      rts
   1316  7d0c
   1317  7d0c
      0  7d0c					      DEFINE_SUBROUTINE	Random
      1  7d0c		       00 0f	   BANK_Random =	_CURRENT_BANK
      2  7d0c					      SUBROUTINE
      3  7d0c				   Random
      0  7d0c					      NEXT_RANDOM
      1  7d0c
      2  7d0c		       a5 c8		      lda	rnd
      3  7d0e		       4a		      lsr
      4  7d0f					      IFCONST	rndHi
      5  7d0f		       66 c7		      ror	rndHi
      6  7d11					      ENDIF
      7  7d11		       90 02		      bcc	.skipEOR
      8  7d13		       49 b4		      eor	#RND_EOR_VAL
      9  7d15				   .skipEOR
     10  7d15		       85 c8		      sta	rnd
   1320  7d17		       60		      rts
   1321  7d18
   1322  7d18							;---------------------------------------------------------------------------
   1323  7d18
------- FILE charset/CHARACTERSHAPE_TARGET.asm LEVEL 3 PASS 3
      0  7d18					      include	"charset/CHARACTERSHAPE_TARGET.asm"
      0  7d18					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET", LINES_PER_CHAR
     10  7d18					      LIST	ON
      2  7d18				   CHARACTERSHAPE_TARGET
      3  7d18		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      4  7d20		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      5  7d28		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      0  7d30					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET_MIRRORED", LINES_PER_CHAR
     10  7d30					      LIST	ON
      7  7d30				   CHARACTERSHAPE_TARGET_MIRRORED
      8  7d30		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      9  7d38		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
     10  7d40		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET1.asm LEVEL 3 PASS 3
      0  7d48					      include	"charset/CHARACTERSHAPE_TARGET1.asm"
      0  7d48					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET1", LINES_PER_CHAR
     10  7d48					      LIST	ON
      2  7d48				   CHARACTERSHAPE_TARGET1
      3  7d48		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      4  7d50		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      5  7d58		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      0  7d60					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET1_MIRRORED", LINES_PER_CHAR
     10  7d60					      LIST	ON
      7  7d60				   CHARACTERSHAPE_TARGET1_MIRRORED
      8  7d60		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      9  7d68		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     10  7d70		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET3.asm LEVEL 3 PASS 3
      0  7d78					      include	"charset/CHARACTERSHAPE_TARGET3.asm"
      0  7d78					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET3", LINES_PER_CHAR
     10  7d78					      LIST	ON
      2  7d78				   CHARACTERSHAPE_TARGET3
      3  7d78		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      4  7d80		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      5  7d88		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      0  7d90					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET3_MIRRORED", LINES_PER_CHAR
     10  7d90					      LIST	ON
      7  7d90				   CHARACTERSHAPE_TARGET3_MIRRORED
      8  7d90		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      9  7d98		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
     10  7da0		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET5.asm LEVEL 3 PASS 3
      0  7da8					      include	"charset/CHARACTERSHAPE_TARGET5.asm"
      0  7da8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET5", LINES_PER_CHAR
     10  7da8					      LIST	ON
      2  7da8				   CHARACTERSHAPE_TARGET5
      3  7da8		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      4  7db0		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      5  7db8		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      0  7dc0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET5_MIRRORED", LINES_PER_CHAR
     10  7dc0					      LIST	ON
      7  7dc0				   CHARACTERSHAPE_TARGET5_MIRRORED
      8  7dc0		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
      9  7dc8		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     10  7dd0		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_TARGET7.asm LEVEL 3 PASS 3
      0  7dd8					      include	"charset/CHARACTERSHAPE_TARGET7.asm"
      0  7dd8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET7", LINES_PER_CHAR
     10  7dd8					      LIST	ON
      2  7dd8				   CHARACTERSHAPE_TARGET7
      3  7dd8		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      4  7de0		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      5  7de8		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      0  7df0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET7_MIRRORED", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_TARGET7_MIRRORED
 REQUESTED SIZE =  $18
 WASTED SPACE =  $10
 PAGEBREAK LOCATION =  $fe00
     10  7e00					      LIST	ON
      7  7e00				   CHARACTERSHAPE_TARGET7_MIRRORED
      8  7e00		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
      9  7e08		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
     10  7e10		       00 00 66 66*	      .byte.b	0,0,102,102,102,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_STEEL.asm LEVEL 3 PASS 3
      0  7e18					      include	"charset/CHARACTERSHAPE_STEEL.asm"
      0  7e18					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
     10  7e18					      LIST	ON
      2  7e18				   CHARACTERSHAPE_STEEL
      3  7e18		       00 00 88 00*	      .byte.b	0,0,136,0,0,0,34,0
      4  7e20		       77 77 ff ff*	      .byte.b	119,119,255,255,221,221,255,255
      5  7e28		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
      0  7e30					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
     10  7e30					      LIST	ON
      7  7e30				   CHARACTERSHAPE_STEEL_MIRRORED
      8  7e30		       00 00 11 00*	      .byte.b	0,0,17,0,0,0,68,0
      9  7e38		       ee ee ff ff*	      .byte.b	238,238,255,255,187,187,255,255
     10  7e40		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
------- FILE BANK_FIXED.asm
------- FILE characterset/character_SOIL.asm LEVEL 3 PASS 3
      0  7e48					      include	"characterset/character_SOIL.asm"
      1  7e48							;    Sokoboo - a Sokoban implementation
      2  7e48							;    using a generic tile-based display engine for the Atari 2600
      3  7e48							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7e48							;
      5  7e48							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7e48							;
      7  7e48							;    Code related to the generic tile-based display engine was developed by
      8  7e48							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7e48							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7e48							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7e48							;
     12  7e48							;    Code related to music and sound effects uses the TIATracker music player
     13  7e48							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7e48							;    directory for Apache licensing details.
     15  7e48							;
     16  7e48							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7e48							;    See the copyright notices in the License directory for a list of level
     18  7e48							;    contributors.
     19  7e48							;
     20  7e48							;    Except where otherwise indicated, this software is released under the
     21  7e48							;    following licensing arrangement...
     22  7e48							;
     23  7e48							;    This program is free software: you can redistribute it and/or modify
     24  7e48							;    it under the terms of the GNU General Public License as published by
     25  7e48							;    the Free Software Foundation, either version 3 of the License, or
     26  7e48							;    (at your option) any later version.
     27  7e48							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7e48
     29  7e48							;    This program is distributed in the hope that it will be useful,
     30  7e48							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7e48							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7e48							;    GNU General Public License for more details.
     33  7e48
      0  7e48					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  7e48					      LIST	ON
     35  7e48				   CHARACTERSHAPE_SOIL
     36  7e48				   CHARACTERSHAPE_SOIL_MIRRORED
     37  7e48		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     38  7e50		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
     39  7e58		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_BOX.asm LEVEL 3 PASS 3
      0  7e60					      include	"charset/CHARACTERSHAPE_BOX.asm"
      0  7e60					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  7e60					      LIST	ON
      2  7e60				   CHARACTERSHAPE_BOX
      3  7e60		       ff ff 99 99*	      .byte.b	255,255,153,153,153,255,255,0
      4  7e68		       ff ff 99 99*	      .byte.b	255,255,153,153,153,0,0,0
      5  7e70		       00 00 00 00*	      .byte.b	0,0,0,0,0,255,255,0
      0  7e78					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
     10  7e78					      LIST	ON
      7  7e78				   CHARACTERSHAPE_BOX_MIRRORED
      8  7e78		       ff ff 99 99*	      .byte.b	255,255,153,153,153,255,255,0
      9  7e80		       ff ff 99 99*	      .byte.b	255,255,153,153,153,0,0,0
     10  7e88		       00 00 00 00*	      .byte.b	0,0,0,0,0,255,255,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_BOX_ON_TARGET.asm LEVEL 3 PASS 3
      0  7e90					      include	"charset/CHARACTERSHAPE_BOX_ON_TARGET.asm"
      0  7e90					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET", LINES_PER_CHAR
     10  7e90					      LIST	ON
      2  7e90				   CHARACTERSHAPE_BOX_ON_TARGET
      3  7e90		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,0
      4  7e98		       ff ff ff ff*	      .byte.b	255,255,255,255,255,0,0,0
      5  7ea0		       00 00 66 66*	      .byte.b	0,0,102,102,102,255,255,0
      0  7ea8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED", LINES_PER_CHAR
     10  7ea8					      LIST	ON
      7  7ea8				   CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
      8  7ea8		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,0
      9  7eb0		       ff ff ff ff*	      .byte.b	255,255,255,255,255,0,0,0
     10  7eb8		       00 00 66 66*	      .byte.b	0,0,102,102,102,255,255,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_BOX_ON_TARGET2.asm LEVEL 3 PASS 3
      0  7ec0					      include	"charset/CHARACTERSHAPE_BOX_ON_TARGET2.asm"
      0  7ec0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET2", LINES_PER_CHAR
     10  7ec0					      LIST	ON
      2  7ec0				   CHARACTERSHAPE_BOX_ON_TARGET2
      3  7ec0		       ff ff 99 99*	      .byte.b	255,255,153,153,153,255,255,0
      4  7ec8		       ff ff ff ff*	      .byte.b	255,255,255,255,153,0,0,0
      5  7ed0		       00 00 66 66*	      .byte.b	0,0,102,102,0,255,255,0
      0  7ed8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED", LINES_PER_CHAR
     10  7ed8					      LIST	ON
      7  7ed8				   CHARACTERSHAPE_BOX_ON_TARGET2_MIRRORED
      8  7ed8		       ff ff 99 99*	      .byte.b	255,255,153,153,153,255,255,0
      9  7ee0		       ff ff ff ff*	      .byte.b	255,255,255,255,153,0,0,0
     10  7ee8		       00 00 66 66*	      .byte.b	0,0,102,102,0,255,255,0
------- FILE BANK_FIXED.asm
------- FILE charset/CHARACTERSHAPE_WALL.asm LEVEL 3 PASS 3
      0  7ef0					      include	"charset/CHARACTERSHAPE_WALL.asm"
      0  7ef0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_WALL
 REQUESTED SIZE =  $18
 WASTED SPACE =  $10
 PAGEBREAK LOCATION =  $ff00
     10  7f00					      LIST	ON
      2  7f00				   CHARACTERSHAPE_WALL
      3  7f00		       77 77 77 00*	      .byte.b	119,119,119,0,221,221,221,0
      4  7f08		       77 77 77 00*	      .byte.b	119,119,119,0,221,221,221,0
      5  7f10		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
      0  7f18					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  7f18					      LIST	ON
      7  7f18				   CHARACTERSHAPE_WALL_MIRRORED
      8  7f18		       ee ee ee 00*	      .byte.b	238,238,238,0,187,187,187,0
      9  7f20		       ee ee ee 00*	      .byte.b	238,238,238,0,187,187,187,0
     10  7f28		       ff ff ff ff*	      .byte.b	255,255,255,255,255,255,255,255
------- FILE BANK_FIXED.asm
   1335  7f30
   1336  7f30				  -	      if	DIGITS
   1337  7f30				  -	      include	"characterset/character_9.asm"
   1338  7f30				  -	      include	"characterset/character_8.asm"
   1339  7f30				  -	      include	"characterset/character_7.asm"
   1340  7f30				  -	      include	"characterset/character_6.asm"
   1341  7f30				  -	      include	"characterset/character_5.asm"
   1342  7f30				  -	      include	"characterset/character_4.asm"
   1343  7f30				  -	      include	"characterset/character_3.asm"
   1344  7f30				  -	      include	"characterset/character_2.asm"
   1345  7f30				  -	      include	"characterset/character_1.asm"
   1346  7f30				  -	      include	"characterset/character_0.asm"
   1347  7f30					      endif
   1348  7f30
   1349  7f30
 FREE BYTES IN FIXED BANK =  $cb
   1350  7f30					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1351  7f30
   1352  7f30							;---------------------------------------------------------------------------
   1353  7f30							; The reset vectors
   1354  7f30							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1355  7f30
   1356  8000 ????				      SEG	InterruptVectors
   1357  7ffc					      ORG	FIXED_BANK + $7FC
   1358  7ffc					      RORG	$7ffC
   1359  7ffc
   1360  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1361  7ffc		       be fb		      .word.w	Reset	; RESET
   1362  7ffe		       be fb		      .word.w	Reset	; IRQ	      (not used)
   1363  8000
   1364  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
    804  8000
    805  8000							;END
