------- FILE ./sokoboo.asm LEVEL 1 PASS 4
      1  8000 ????						;    Sokoboo - a Sokoban implementation
      2  8000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  8000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  8000 ????						;
      5  8000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  8000 ????						;
      7  8000 ????						;    Code related to the generic tile-based display engine was developed by
      8  8000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  8000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  8000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  8000 ????						;
     12  8000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  8000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  8000 ????						;    directory for Apache licensing details.
     15  8000 ????						;
     16  8000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  8000 ????						;    See the copyright notices in the License directory for a list of level
     18  8000 ????						;    contributors.
     19  8000 ????						;
     20  8000 ????						;    Except where otherwise indicated, this software is released under the
     21  8000 ????						;    following licensing arrangement...
     22  8000 ????						;
     23  8000 ????						;    This program is free software: you can redistribute it and/or modify
     24  8000 ????						;    it under the terms of the GNU General Public License as published by
     25  8000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  8000 ????						;    (at your option) any later version.
     27  8000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  8000 ????
     29  8000 ????						;    This program is distributed in the hope that it will be useful,
     30  8000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  8000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  8000 ????						;    GNU General Public License for more details.
     33  8000 ????
     34  8000 ????
     35  8000 ????
     36  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     37  8000 ????
     38  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./sokoboo.asm
     41  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	xsegtime
     89  0000 ????			   {1}	      SET	{2}-1
     90  0000 ????			   TEST_{1}   =	1
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????				      MAC	segtime_c
     94  0000 ????			   {1}	      SET	({2}+32)/64 + 1
     95  0000 ????			   TEST_{1}   =	0
     96  0000 ????				      ENDM
     97  0000 ????
     98  0000 ????						;@TJ -- SIMPLY PUT AN X IN FRONT OF THE LINE(S) YOU WANT TO TEST
     99  0000 ????						; eg: XSEGTIME SEGTIME_BOX1,5
    100  0000 ????						; No other action required.  All code enables/disables automatically.
    101  0000 ????
    102  0000 ????						; 2012/02/11 -- experimental reduction in times (but not stress tested)
    103  0000 ????						; due to separation of timeslice overhead to separate check
    104  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_DIRECT, 355	; @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	(355+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_QUICK, 386	; @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_QUICK SET	(386+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_SLOW, 651	; @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_SLOW SET	(651+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_PF0, 88	; @ 4/8/2019 ??
      1  0000 ????			   SEGTIME_SCD_PF0 SET	(88+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
    109  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_SCD_MIN,SEGTIME_SCD_PF0+1	; * MINIMUM TIME OF THE ABOVE + 1
      1  0000 ????			   SEGTIME_SCD_MIN SET	SEGTIME_SCD_PF0+1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_MIN =	0
    111  0000 ????
    112  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
    113  0000 ????			  -	      SEGTIME	SEGTIME_BDF,42 +4 +5	; * 5/8/11 stress tested DHS->DS
    114  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BDF,38 +2	; glitches on 37 - 10/8/2019
      1  0000 ????			   SEGTIME_BDF SET	38 +2
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
    116  0000 ????				      ENDIF
    117  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BDS, 2 +1	; *AD 11/8/11
      1  0000 ????			   SEGTIME_BDS SET	2 +1
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_DSL, 125	; * 9/8/11 unrolled once
      1  0000 ????			   SEGTIME_DSL SET	(125+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
    120  0000 ????
    121  0000 ????
    122  0000 ????						;following will lock-up system if used as 'XSEGTIME'.
      0  0000 ????				      SEGTIME_C	MINIMUM_SEGTIME, 87	; processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	(87+32)/64 + 1
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
      0  0000 ????				      SEGTIME	SEGTIME_MINIMUM_TIMESLICE,MINIMUM_SEGTIME+1	; MINIMUM of the TIMESLICE segments listed above
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	MINIMUM_SEGTIME+1
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    125  0000 ????
    126  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    127  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    128  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    129  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    130  0000 ????						; uses ...
    131  0000 ????
    132  0000 ????
    133  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    134  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    135  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    136  0000 ????
    137  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    138  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    139  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,10 +6	;24 ;<< using this as XSEGTIME stops player working ...?!
      1  0000 ????			   SEGTIME_MAN SET	10 +6
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE, 10	; drawing circle creature
      1  0000 ????			   SEGTIME_CIRCLE SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE_HELPER, 10	; drawing circle creature's helper
      1  0000 ????			   SEGTIME_CIRCLE_HELPER SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE_HELPER =	0
    143  0000 ????
    144  0000 ????						; TJ: I should only prevent processes with an extra check (e.g. get TARGET)
    145  0000 ????
    146  0000 ????						; push BOX is slowest (besides get TARGET which has an extra timer check)
    147  0000 ????						; if we add another check for it, SEGTIME_MAN reduces by ~5
    148  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_SWITCHOBJECTS,74	; 16/8/11 by calculation. 72 cycles -->  ceil(72/64)+1 --> 3 Object stack switchover
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	(74+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
------- FILE ./sokoboo.asm
     43  0000 ????
     44  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     45  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     46  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     47  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     48  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     49  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     50  0000 ????
     51  0000 ????	       00 01	   YES	      =	1
     52  0000 ????	       00 00	   NO	      =	0
     53  0000 ????
     54  0000 ????	       00 00	   DEBUG      =	NO
     55  0000 ????
     56  0000 ????	       00 00	   TJ_MODE    =	NO	; some changes which TJ prefers
     57  0000 ????	       00 01	   AD_MODE    =	YES	; some changes which AD prefers
     58  0000 ????
     59  0000 ????			  -	      IF	TJ_MODE && AD_MODE
     60  0000 ????			  -	      ECHO	"ERROR: Both TJ_MODE and AD_MODE set. Can't do both TJ and AD at the same time!"
     61  0000 ????			  -	      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????
     65  0000 ????						; Note: you may also need to change the emulator "-format" switch in the Makefile.
     66  0000 ????
     67  0000 ????
     68  0000 ????						;===================================
     69  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     70  0000 ????						;===================================
     71  0000 ????
     72  0000 ????						;-------------------------------------------------------------------------------
     73  0000 ????						; The following should be YES for the final or DEMO version
     74  0000 ????			   EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
     75  0000 ????
     76  0000 ????						;-------------------------------------------------------------------------------
     77  0000 ????						; The following are optional YES/NO depending on phase of the moon
     78  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????
     81  0000 ????	       00 01	   NUMPLAYERS =	1	; 1-indexed
     82  0000 ????	       00 05	   NUM_LEVELS =	5
     83  0000 ????			   NUM_LIVES  SET	3	; use -1 for unlimited lives
     84  0000 ????
     85  0000 ????						;-------------------------------------------------------------------------------
     86  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     87  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     88  0000 ????			  -	      IF	FINAL_VERSION = YES
     89  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     90  0000 ????			  -
     91  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
     92  0000 ????				      ENDIF
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????
     96  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     97  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
     98  0000 ????
     99  0000 ????
    100  0000 ????	       00 02	   PUSH_LIMIT =	2	; slowdown when pushing on a BOX
    101  0000 ????
    102  0000 ????						; time bonus countdown constants:
    103  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
    104  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
    105  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
    106  0000 ????
    107  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    108  0000 ????
    109  0000 ????	       00 03	   FACE_LEFT  =	3
    110  0000 ????
    111  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
    112  0000 ????
    113  0000 ????						;scoring flags contants:
    114  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
    115  0000 ????	       00 00	   DISPLAY_TIME =	%00
    116  0000 ????	       00 01	   DISPLAY_SCORE =	%01
    117  0000 ????	       00 02	   DISPLAY_LIVES =	%10
    118  0000 ????	       00 03	   DISPLAY_HIGH =	%11
    119  0000 ????
    120  0000 ????						;------------------------------------------------------------------------------
    121  0000 ????
    122  0000 ????	       00 01	   MIRRORED_BOX =	YES
    123  0000 ????	       00 01	   MIRRORED_STEEL =	YES
    124  0000 ????	       00 01	   MIRRORED_WALL =	YES
    125  0000 ????
    126  0000 ????	       00 00	   TROPHY     =	NO
    127  0000 ????	       00 00	   DIGITS     =	NO
    128  0000 ????	       00 01	   WAIT_FOR_INITIAL_DRAW =	YES	; blank until all initial tiles drawn
    129  0000 ????
    130  0000 ????						;------------------------------------------------------------------------------
    131  0000 ????
    132  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    133  0000 ????
    134  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    135  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    136  0000 ????
    137  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    138  0000 ????
    139  0000 ????
    140  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    141  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    142  0000 ????
    143  0000 ????
    144  0000 ????						; color constants:
    145  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    146  0000 ????
    147  0000 ????	       00 10	   YELLOW_NTSC =	$10
    148  0000 ????	       00 20	   YELLOW_PAL =	$20
    149  0000 ????
    150  0000 ????
    151  0000 ????	       10 00	   RAM_3E     =	$1000
    152  0000 ????	       04 00	   RAM_SIZE   =	$400
    153  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    154  0000 ????
    155  0000 ????
    156  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    157  0000 ????
    158  0000 ????
    159  0000 ????						; Platform constants:
    160  0000 ????	       00 02	   PAL	      =	%10
    161  0000 ????	       00 02	   PAL_50     =	PAL|0
    162  0000 ????	       00 03	   PAL_60     =	PAL|1
    163  0000 ????
    164  0000 ????
    165  0000 ????				      IF	L276
    166  0000 ????	       00 30	   VBLANK_TIM_NTSC =	48	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    167  0000 ????			  -	      ELSE
    168  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    169  0000 ????				      ENDIF
    170  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    171  0000 ????
    172  0000 ????				      IF	L276
    173  0000 ????	       00 23	   OVERSCAN_TIM_NTSC =	35	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    174  0000 ????			  -	      ELSE
    175  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    176  0000 ????				      ENDIF
    177  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    178  0000 ????
    179  0000 ????				      IF	L276
    180  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    181  0000 ????			  -	      ELSE
    182  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    183  0000 ????				      ENDIF
    184  0000 ????	       01 38	   SCANLINES_PAL =	312
    185  0000 ????
    186  0000 ????
    187  0000 ????						;------------------------------------------------------------------------------
    188  0000 ????						; MACRO definitions
    189  0000 ????
    190  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    191  0000 ????
    192  0000 ????				      MAC	newbank
    193  0000 ????				      SEG	{1}
    194  0000 ????				      ORG	ORIGIN
    195  0000 ????				      RORG	$F000
    196  0000 ????			   BANK_START SET	*
    197  0000 ????			   {1}	      SET	ORIGIN / 2048
    198  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    199  0000 ????			   _CURRENT_BANK SET	{1}
    200  0000 ????				      ENDM		; bank name
    201  0000 ????
    202  0000 ????				      MAC	define_1k_segment
    203  0000 ????				      ALIGN	$400
    204  0000 ????			   SEGMENT_{1} SET	*
    205  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    206  0000 ????				      ENDM		; {seg name}
    207  0000 ????
    208  0000 ????				      MAC	check_bank_size
    209  0000 ????			   .TEMP      =	* - BANK_START
    210  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    211  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    212  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    213  0000 ????				      ERR
    214  0000 ????				      endif
    215  0000 ????				      ENDM		; name
    216  0000 ????
    217  0000 ????
    218  0000 ????				      MAC	check_half_bank_size
    219  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    220  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    221  0000 ????			   .TEMP      =	* - BANK_START
    222  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    223  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    224  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    225  0000 ????				      ERR
    226  0000 ????				      endif
    227  0000 ????				      ENDM		; name
    228  0000 ????
    229  0000 ????
    230  0000 ????				      MAC	overlay
    231  0000 ????				      SEG.U	OVERLAY_{1}
    232  0000 ????				      org	Overlay
    233  0000 ????				      ENDM		; {name}
    234  0000 ????
    235  0000 ????						;--------------------------------------------------------------------------
    236  0000 ????
    237  0000 ????				      MAC	validate_overlay
    238  0000 ????				      LIST	OFF
    239  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    240  0000 ????				      ERR
    241  0000 ????				      endif
    242  0000 ????				      LIST	ON
    243  0000 ????				      ENDM
    244  0000 ????
    245  0000 ????						;--------------------------------------------------------------------------
    246  0000 ????						; Macro inserts a page break if the object would overlap a page
    247  0000 ????
    248  0000 ????				      MAC	optional_pagebreak
    249  0000 ????				      LIST	OFF
    250  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    251  0000 ????			   EARLY_LOCATION SET	*
    252  0000 ????				      ALIGN	256
    253  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    254  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    255  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    256  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    257  0000 ????				      ENDIF
    258  0000 ????				      LIST	ON
    259  0000 ????				      ENDM		; { string, size }
    260  0000 ????
    261  0000 ????
    262  0000 ????				      MAC	check_page_crossing
    263  0000 ????				      LIST	OFF
    264  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    265  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    266  0000 ????				      endif
    267  0000 ????				      LIST	ON
    268  0000 ????				      ENDM
    269  0000 ????
    270  0000 ????				      MAC	checkpage
    271  0000 ????				      LIST	OFF
    272  0000 ????				      IF	>. != >{1}
    273  0000 ????				      ECHO	""
    274  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    275  0000 ????				      ECHO	""
    276  0000 ????				      ERR
    277  0000 ????				      ENDIF
    278  0000 ????				      LIST	ON
    279  0000 ????				      ENDM
    280  0000 ????
    281  0000 ????				      MAC	checkpagex
    282  0000 ????				      LIST	OFF
    283  0000 ????				      IF	>. != >{1}
    284  0000 ????				      ECHO	""
    285  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    286  0000 ????				      ECHO	{2}
    287  0000 ????				      ECHO	""
    288  0000 ????				      ERR
    289  0000 ????				      ENDIF
    290  0000 ????				      LIST	ON
    291  0000 ????				      ENDM
    292  0000 ????
    293  0000 ????
    294  0000 ????				      MAC	checkpage_bne
    295  0000 ????				      LIST	OFF
    296  0000 ????				      IF	0	;>(. + 2) != >{1}
    297  0000 ????				      ECHO	""
    298  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    299  0000 ????				      ECHO	""
    300  0000 ????				      ERR
    301  0000 ????				      ENDIF
    302  0000 ????				      LIST	ON
    303  0000 ????				      bne	{1}
    304  0000 ????				      ENDM
    305  0000 ????
    306  0000 ????				      MAC	checkpage_bpl
    307  0000 ????				      LIST	OFF
    308  0000 ????				      IF	(>(.+2 )) != >{1}
    309  0000 ????				      ECHO	""
    310  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    311  0000 ????				      ECHO	""
    312  0000 ????				      ERR
    313  0000 ????				      ENDIF
    314  0000 ????				      LIST	ON
    315  0000 ????				      bpl	{1}
    316  0000 ????				      ENDM
    317  0000 ????
    318  0000 ????				      MAC	align_free
    319  0000 ????			   FREE       SET	FREE - .
    320  0000 ????				      align	{1}
    321  0000 ????			   FREE       SET	FREE + .
    322  0000 ????				      echo	"@", ., ":", FREE
    323  0000 ????				      ENDM
    324  0000 ????
    325  0000 ????				      MAC	stress_time
    326  0000 ????				      IF	TEST_{1} = 1
    327  0000 ????
    328  0000 ????
    329  0000 ????						;LIST OFF
    330  0000 ????						; has to be put *directly* after cmp #SEGTIME_... , bcc abort
    331  0000 ????						;LIST ON
    332  0000 ????				      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
    333  0000 ????				      bne	. - 7	; branches to lda INTIM
    334  0000 ????				      ENDIF
    335  0000 ????				      ENDM
    336  0000 ????
    337  0000 ????			   IDENTITY   SET	0
    338  0000 ????				      MAC	ident
    339  0000 ????				      if	DEBUG=YES
    340  0000 ????				      lda	#IDENTITY
    341  0000 ????				      sta	debug_ident
    342  0000 ????				      lda	{1}
    343  0000 ????				      sta	debug_object
    344  0000 ????				      endif
    345  0000 ????			   IDENTITY   SET	IDENTITY + 1
    346  0000 ????				      ENDM		; {object}
    347  0000 ????
    348  0000 ????						;--------------------------------------------------------------------------
    349  0000 ????
    350  0000 ????				      MAC	vector
    351  0000 ????				      .word	{1}
    352  0000 ????				      ENDM		; just a word pointer to code
    353  0000 ????
    354  0000 ????
    355  0000 ????				      MAC	define_subroutine
    356  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    357  0000 ????				      SUBROUTINE		; keep everything local
    358  0000 ????			   {1}			; entry point
    359  0000 ????				      ENDM		; name of subroutine
    360  0000 ????
    361  0000 ????
    362  0000 ????
    363  0000 ????						;--------------------------------------------------------------------------
    364  0000 ????
    365  0000 ????				      MAC	newrambank
    366  0000 ????				      SEG.U	{1}
    367  0000 ????				      ORG	ORIGIN
    368  0000 ????				      RORG	RAM_3E
    369  0000 ????			   BANK_START SET	*
    370  0000 ????			   {1}	      SET	ORIGIN / RAM_SIZE
    371  0000 ????			   ORIGIN     SET	ORIGIN + RAM_SIZE
    372  0000 ????				      ENDM		; bank name
    373  0000 ????
    374  0000 ????				      MAC	validate_ram_size
    375  0000 ????				      if	* - RAM_3E > RAM_SIZE
    376  0000 ????				      ERR
    377  0000 ????				      endif
    378  0000 ????				      ENDM
    379  0000 ????
    380  0000 ????				      MAC	next_random
    381  0000 ????						; update random value:
    382  0000 ????				      lda	rnd	; 3
    383  0000 ????				      lsr		; 2
    384  0000 ????				      IFCONST	rndHi
    385  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    386  0000 ????				      ENDIF
    387  0000 ????				      bcc	.skipEOR	; 2/3
    388  0000 ????				      eor	#RND_EOR_VAL	; 2
    389  0000 ????			   .skipEOR
    390  0000 ????				      sta	rnd	; 3 = 14/19
    391  0000 ????				      ENDM
    392  0000 ????
    393  0000 ????				      MAC	resync
    394  0000 ????						; resync screen, X and Y == 0 afterwards
    395  0000 ????				      lda	#%10	; make sure VBLANK is ON
    396  0000 ????				      sta	VBLANK
    397  0000 ????
    398  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    399  0000 ????			   .loopResync
    400  0000 ????				      VERTICAL_SYNC
    401  0000 ????
    402  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    403  0000 ????				      lda	Platform
    404  0000 ????				      eor	#PAL_50	; PAL-50?
    405  0000 ????				      bne	.ntsc
    406  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    407  0000 ????			   .ntsc
    408  0000 ????			   .loopWait
    409  0000 ????				      sta	WSYNC
    410  0000 ????				      sta	WSYNC
    411  0000 ????				      dey
    412  0000 ????				      bne	.loopWait
    413  0000 ????				      dex
    414  0000 ????				      bne	.loopResync
    415  0000 ????				      ENDM
    416  0000 ????
    417  0000 ????				      MAC	set_platform
    418  0000 ????						; 00 = NTSC
    419  0000 ????						; 01 = NTSC
    420  0000 ????						; 10 = PAL-50
    421  0000 ????						; 11 = PAL-60
    422  0000 ????				      lda	SWCHB
    423  0000 ????				      rol
    424  0000 ????				      rol
    425  0000 ????				      rol
    426  0000 ????				      and	#%11
    427  0000 ????				      eor	#PAL
    428  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    429  0000 ????				      ENDM
    430  0000 ????
    431  0000 ????						;  IF TJ_MODE
    432  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM ; = 29
    433  0000 ????						;	  ldy #{1}			  ; 2	  read bank
    434  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    435  0000 ????						;	  jsr GetRAMByteFromRAM 	  ;25
    436  0000 ????						;    ENDM
    437  0000 ????						;
    438  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM ; = 30
    439  0000 ????						;	  ldy #{1}			  ; 2	  write bank
    440  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    441  0000 ????						;	  jsr PutRAMByteFromRAM 	  ;26
    442  0000 ????						;    ENDM
    443  0000 ????						;
    444  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM_ADR ; = 39
    445  0000 ????						;	  ldx #<{1}			  ; 2
    446  0000 ????						;	  stx addressR			  ; 3
    447  0000 ????						;	  ldx #>{1}			  ; 2
    448  0000 ????						;	  stx addressR+1		  ; 3
    449  0000 ????						;	  GET_RAM_BYTE_FROM_RAM {2}, {3}  ;29
    450  0000 ????						;    ENDM
    451  0000 ????						;
    452  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM_ADR ; = 40
    453  0000 ????						;	  ldx #<{1}			  ; 2
    454  0000 ????						;	  stx addressW			  ; 3
    455  0000 ????						;	  ldx #>({1}+RAM_WRITE) 	  ; 2
    456  0000 ????						;	  stx addressW+1		  ; 3
    457  0000 ????						;	  PUT_RAM_BYTE_FROM_RAM {2}, {3}  ;30
    458  0000 ????						;    ENDM
    459  0000 ????						;  ENDIF
    460  0000 ????
    461  0000 ????				      MAC	nop_b
    462  0000 ????				      .byte	$82
    463  0000 ????				      ENDM		; unused
    464  0000 ????
    465  0000 ????				      MAC	nop_w
    466  0000 ????				      .byte	$0c
    467  0000 ????				      ENDM
    468  0000 ????
    469  0000 ????				      MAC	load_animation
    470  0000 ????				      lda	#<{1}
    471  0000 ????				      sta	animation
    472  0000 ????				      lda	#>{1}
    473  0000 ????				      sta	animation+1
    474  0000 ????				      lda	#-1
    475  0000 ????				      sta	animation_delay
    476  0000 ????				      ENDM
    477  0000 ????
    478  0000 ????
    479  0000 ????						;------------------------------------------------------------------------------
    480  0000 ????
    481  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34 U00fe ????				      SEG.U	variables
     35 U0080					      ORG	$80
     36 U0080
     37 U0080
     38 U0080		       00 40	   GAMEMODE_2600 =	64
     39 U0080		       00 80	   GAMEMODE_PAUSED =	128
     40 U0080
     41 U0080		       00	   gameMode   ds	1	; bit7=0: 7800; bit7=1: 2600.	bit 6=1: paused: bit3: toggle bit for B/W
     42 U0081		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U0082							; above variables are preserved ALL the time!
     44 U0082
     45 U0082							;rnd				  ds 1
     46 U0082							;rndHi 			  ds 1	      ; to get better random values
     47 U0082
     48 U0082		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     49 U0083		       00	   ObjStackNum ds	1	; which stack in use
     50 U0084		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     51 U0086		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     52 U0087		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     53 U0088
     54 U0088		       00	   POS_X      ds	1
     55 U0089		       00	   POS_Y      ds	1
     56 U008a		       00	   POS_X_NEW  ds	1
     57 U008b		       00	   POS_Y_NEW  ds	1
     58 U008c		       00	   POS_Type   ds	1
     59 U008d		       00	   POS_VAR    ds	1
     60 U008e
     61 U008e		       00	   TB_X       ds	1
     62 U008f		       00	   TB_Y       ds	1
     63 U0090		       00	   TB_PUSHX   ds	1
     64 U0091		       00	   TB_PUSHY   ds	1
     65 U0092		       00	   TB_CHAR    ds	1
     66 U0093
     67 U0093		       00 00	   BufferedJoystick ds	2	; player joystick input
     68 U0095		       00 00	   BufferedButton ds	2	; player button press
     69 U0097
     70 U0097							; Scrolling is limited to only show board within the following area...
     71 U0097		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in UnpackLevel)
     72 U0098		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in UnpackLevel)
     73 U0099		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     74 U009a		       00	   BoardScrollX ds	1	; scroll position in board (X)
     75 U009a		       00 97	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     76 U009a		       00 98	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     77 U009b		       00	   scrollBits ds	1
     78 U009c
     79 U009c		       00	   whichPlayer ds	1	; 0 = P1, 1 = P2
     80 U009d		       00	   manAnimationIndex ds	1	; old
     81 U009e		       00	   animation_index ds	1	; new
     82 U009f		       00 00	   animation  ds	2
     83 U00a1		       00	   animation_delay ds	1
     84 U00a2		       00	   ManX       ds	1
     85 U00a3		       00	   ManY       ds	1
     86 U00a4		       00	   ManDrawX   ds	1
     87 U00a5		       00	   ManDrawY   ds	1
     88 U00a6		       00	   ManMode    ds	1
     89 U00a7		       00	   ManDelayCount ds	1
     90 U00a8		       00 00	   ManAnimation ds	2
     91 U00aa		       00	   ManAnimationFrameLO ds	1
     92 U00ab		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     93 U00ac		       00	   ManPushCounter ds	1
     94 U00ad		       00	   LookingAround ds	1
     95 U00ae		       00	   ManAnimationID ds	1
     96 U00af							;ManCount			ds 1		; player life counter
     97 U00af		       00	   DelayEndOfLevel ds	1
     98 U00b0		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     99 U00b1							;circle_d			  ds 2
    100 U00b1
    101 U00b1				  -	      if	0
    102 U00b1				  -circ_x     ds	1
    103 U00b1				  -circ_y     ds	1
    104 U00b1				  -circ_char  ds	1
    105 U00b1				  -circ_scratch ds	1
    106 U00b1					      endif
    107 U00b1		       00	   LEVEL_bank ds	1
    108 U00b2		       00 00	   levelPtr   ds	2
    109 U00b4
    110 U00b4					      IF	WAIT_FOR_INITIAL_DRAW
    111 U00b4		       00	   blankState ds	1
    112 U00b5					      ENDIF
    113 U00b5
    114 U00b5							;---------------------------------------------------------------------------
    115 U00b5							; 2 (shared) demo mode variables:
    116 U00b5		       00 b0	   demoMode   =	jtoggle	; bit 7==1 => demo mode
    117 U00b5		       00 b0	   moveLen    =	jtoggle	; bits 0..6
    118 U00b5		       00 9c	   moveIdx    =	whichPlayer
    119 U00b5
    120 U00b5		       00	   LastSpriteY ds	1
    121 U00b6
    122 U00b6		       00	   timer      ds	1
    123 U00b7
    124 U00b7		       00	   BGColour   ds	1
    125 U00b8
    126 U00b8							; levelx and level have to be consecutive variables!
    127 U00b8		       00	   levelX     ds	1	; current player's level (other in scoring bank)
    128 U00b9		       00	   level      ds	1	; current player's level (other in scoring bank)
    129 U00ba		       00	   levelDisplay ds	1	; what to display as the level ID
    130 U00bb		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
    131 U00bc		       00	   ThrottleSpeed ds	1	; system-dependant throttle speed
    132 U00bd
    133 U00bd		       00	   BCD_targetsRequired ds	1	; number of un-targeted left to go
    134 U00be		       00	   BCD_moveCounter ds	1	; BCD seconds for level
    135 U00bf		       00	   BCD_moveCounterHi ds	1
    136 U00c0
    137 U00c0		       00	   takebackIndex ds	1
    138 U00c1		       00	   takebackBaseIndex ds	1
    139 U00c2
    140 U00c2		       00 00 00    color      ds	3	; RGB for NTSC, RGB for PAL
    141 U00c5		       00 00	   Board_AddressR ds	2
    142 U00c7		       00 00	   Board_AddressW ds	2
    143 U00c9		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
    144 U00ca		       00	   RAM_Bank   ds	1
    145 U00cb
    146 U00cb		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
    147 U00cc		       00	   ColourFlash ds	1	; colour of flash
    148 U00cd		       00	   extraLifeTimer ds	1	; should be 5 seconds!
    149 U00ce
    150 U00ce							; extraLifeTimer:
    151 U00ce							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    152 U00ce
    153 U00ce		       00	   scoringTimer ds	1	; times the various score displays
    154 U00cf		       00	   scoringFlags ds	1	; scoring flags are stored here
    155 U00d0
    156 U00d0							; scoringFlags:
    157 U00d0							; D7		 Extra TARGETs in effect (TARGETs collected over requirement score more) ASSUMED BPL/BMI usage
    158 U00d0							; D6		 unused
    159 U00d0							; D5		 unused
    160 U00d0							; D4		 unused
    161 U00d0							; D3		 unused
    162 U00d0							; D2		 unused
    163 U00d0							; D1	 D1-D0	 Which display kernel to use for scoring
    164 U00d0							; D0		 0 = 2x4     used for TARGETs/time
    165 U00d0							;		 1 = 1x6     used for score
    166 U00d0							;		 2 = 3x2     used for level/lives/player
    167 U00d0
    168 U00d0		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    169 U00d0		       00 80	   BIT_NEXTLEVEL =	128
    170 U00d0		       00 40	   BIT_NEXTLIFE =	64
    171 U00d1
    172 U00d1							;---------------------------------------------------------------------------
    173 U00d1
    174 U00d1		       00	   sortRequired ds	1
    175 U00d2		       00	   sortPtr    ds	1
    176 U00d3
    177 U00d3							;------------------------------------------------------------------------------
    178 U00d3
    179 U00d3		       00	   ObjIterator ds	1	; count UP iterator over objects
    180 U00d4		       00	   DSL	      ds	1	; stack line counter
    181 U00d5		       00	   TakebackInhibit ds	1
    182 U00d6
    183 U00d6		       00	   ethnic     ds	1
    184 U00d7
    185 U00d7
------- FILE sound/intro1_variables.asm LEVEL 3 PASS 4
      0 U00d7					      include	"sound/intro1_variables.asm"
      1 U00d7							; TIATracker music player
      2 U00d7							; Copyright 2016 Andre "Kylearan" Wichmann
      3 U00d7							; Website: https://bitbucket.org/kylearan/tiatracker
      4 U00d7							; Email: andre.wichmann@gmx.de
      5 U00d7							;
      6 U00d7							; Licensed under the Apache License, Version 2.0 (the "License");
      7 U00d7							; you may not use this file except in compliance with the License.
      8 U00d7							; You may obtain a copy of the License at
      9 U00d7							;
     10 U00d7							;   http://www.apache.org/licenses/LICENSE-2.0
     11 U00d7							;
     12 U00d7							; Unless required by applicable law or agreed to in writing, software
     13 U00d7							; distributed under the License is distributed on an "AS IS" BASIS,
     14 U00d7							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15 U00d7							; See the License for the specific language governing permissions and
     16 U00d7							; limitations under the License.
     17 U00d7
     18 U00d7							; Song author: 
     19 U00d7							; Song name: 
     20 U00d7
     21 U00d7							; @com.wudsn.ide.asm.hardware=ATARI2600
     22 U00d7
     23 U00d7							; =====================================================================
     24 U00d7							; Flags
     25 U00d7							; =====================================================================
     26 U00d7
     27 U00d7							; 1: Global song speed, 0: Each pattern has individual speed
     28 U00d7		       00 01	   TT_GLOBAL_SPEED =	1
     29 U00d7							; duration (number of TV frames) of a note
     30 U00d7		       00 05	   TT_SPEED   =	5
     31 U00d7							; duration of odd frames (needs TT_USE_FUNKTEMPO)
     32 U00d7		       00 04	   TT_ODD_SPEED =	4
     33 U00d7
     34 U00d7							; 1: Overlay percussion, +40 bytes
     35 U00d7		       00 01	   TT_USE_OVERLAY =	1
     36 U00d7							; 1: Melodic instrument slide, +9 bytes
     37 U00d7		       00 00	   TT_USE_SLIDE =	0
     38 U00d7							; 1: Goto pattern, +8 bytes
     39 U00d7		       00 01	   TT_USE_GOTO =	1
     40 U00d7							; 1: Odd/even rows have different SPEED values, +7 bytes
     41 U00d7		       00 01	   TT_USE_FUNKTEMPO =	1
     42 U00d7							; If the very first notes played on each channel are not PAUSE, HOLD or
     43 U00d7							; SLIDE, i.e. if they start with an instrument or percussion, then set
     44 U00d7							; this flag to 0 to save 2 bytes.
     45 U00d7							; 0: +2 bytes
     46 U00d7		       00 01	   TT_STARTS_WITH_NOTES =	1
     47 U00d7
     48 U00d7
     49 U00d7							; =====================================================================
     50 U00d7							; Permanent variables. These are states needed by the player.
     51 U00d7							; =====================================================================
     52 U00d7		       00	   tt_timer   ds	1	; current music timer value
     53 U00d8		       00	   tt_cur_pat_index_c0 ds	1	; current pattern index into tt_SequenceTable
     54 U00d9		       00	   tt_cur_pat_index_c1 ds	1
     55 U00da		       00	   tt_cur_note_index_c0 ds	1	; note index into current pattern
     56 U00db		       00	   tt_cur_note_index_c1 ds	1
     57 U00dc		       00	   tt_envelope_index_c0 ds	1	; index into ADSR envelope
     58 U00dd		       00	   tt_envelope_index_c1 ds	1
     59 U00de		       00	   tt_cur_ins_c0 ds	1	; current instrument
     60 U00df		       00	   tt_cur_ins_c1 ds	1
     61 U00e0
     62 U00e0
     63 U00e0							; =====================================================================
     64 U00e0							; Temporary variables. These will be overwritten during a call to the
     65 U00e0							; player routine, but can be used between calls for other things.
     66 U00e0							; =====================================================================
     67 U00e0		       00 00	   tt_ptr     ds	2
------- FILE zeropage.asm
    187 U00e2
    188 U00e2
    189 U00e2
    190 U00e2				   OVERLAY_SIZE SET	16
    191 U00e2
    192 U00e2
    193 U00e2
    194 U00e2							; This overlay variable is used for the overlay variables.  That's OK.
    195 U00e2							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    196 U00e2							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    197 U00e2							; (especially the latter ones) are only used in rare occasions.
    198 U00e2
    199 U00e2							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    200 U00e2							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    201 U00e2
    202 U00e2		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00f2					      VALIDATE_OVERLAY
      5 U00f2					      LIST	ON
    204 U00f2
    205 U00f2
    206 U00f2		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    207 U00fe
 FREE BYTES IN ZERO PAGE =  $1
    208 U00fe					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    209 U00fe				  -	      IF	* > $FF
    210 U00fe				  -	      ERR
    211 U00fe					      ENDIF
------- FILE ./sokoboo.asm
    483 U00fe
    484 U00fe
    485 U00fe							;------------------------------------------------------------------------------
    486 U00fe							; OVERLAYS!
    487 U00fe							; These variables are overlays, and should be managed with care
    488 U00fe							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    489 U00fe
    490 U00fe							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    491 U00fe							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    492 U00fe
    493 U00fe							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    494 U00fe
    495 U00fe
    496 U00fe
    497 U00fe							;------------------------------------------------------------------------------
      0 U00fe					      OVERLAY	BuildDrawFlags
      1 U00ed ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00e2					      org	Overlay
    499 U00e2
    500 U00e2		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    501 U00e4		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    502 U00e6		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    503 U00e8		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    504 U00ea							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    505 U00ea		       00	   BDF_BoardBank ds	1	; holds bank of current line
    506 U00eb							;  ENDIF
    507 U00eb		       00	   DHS_Line   ds	1
    508 U00ec		       00	   DHS_Stack  ds	1	; for restoring SP
    509 U00ed							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00ed					      VALIDATE_OVERLAY
      5 U00ed					      LIST	ON
    511 U00ed
    512 U00ed							;------------------------------------------------------------------------------
    513 U00ed
      0 U00ed					      OVERLAY	Animator
      1 U00e8 ????				      SEG.U	OVERLAY_Animator
      2 U00e2					      org	Overlay
    515 U00e2		       00 00	   frame_ptr  ds	2
    516 U00e4		       00 00	   colour_ptr ds	2
    517 U00e6		       00	   bank       ds	1
    518 U00e7		       00	   ethnicity  ds	1
      0 U00e8					      VALIDATE_OVERLAY
      5 U00e8					      LIST	ON
    520 U00e8
    521 U00e8
      0 U00e8					      OVERLAY	Process
      1 U00e5 ????				      SEG.U	OVERLAY_Process
      2 U00e2					      org	Overlay
    523 U00e2
    524 U00e2		       00	   BOXLeft    ds	1
    525 U00e3		       00	   BOXRight   ds	1
    526 U00e4		       00	   restorationCharacter ds	1
    527 U00e5
      0 U00e5					      VALIDATE_OVERLAY
      5 U00e5					      LIST	ON
    529 U00e5
    530 U00e5							;------------------------------------------------------------------------------
    531 U00e5
    532 U00e5
      0 U00e5					      OVERLAY	Animate
      1 U00e3 ????				      SEG.U	OVERLAY_Animate
      2 U00e2					      org	Overlay
    534 U00e2		       00	   halftimer  ds	1
      0 U00e3					      VALIDATE_OVERLAY
      5 U00e3					      LIST	ON
    536 U00e3
    537 U00e3							;------------------------------------------------------------------------------
    538 U00e3
      0 U00e3					      OVERLAY	TitleScreen
      1 U00e4 ????				      SEG.U	OVERLAY_TitleScreen
      2 U00e2					      org	Overlay
    540 U00e2		       00 00	   colour_table ds	2
      0 U00e4					      VALIDATE_OVERLAY
      5 U00e4					      LIST	ON
    542 U00e4
    543 U00e4							;------------------------------------------------------------------------------
    544 U00e4
      0 U00e4					      OVERLAY	TimeSlice
      1 U00e4 ????				      SEG.U	OVERLAY_TimeSlice
      2 U00e2					      org	Overlay
    546 U00e2
    547 U00e2		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    548 U00e4							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e4					      VALIDATE_OVERLAY
      5 U00e4					      LIST	ON
    550 U00e4
    551 U00e4							;------------------------------------------------------------------------------
    552 U00e4
      0 U00e4					      OVERLAY	CopyROMShadowToRAM
      1 U00e5 ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00e2					      org	Overlay
    554 U00e2
    555 U00e2		       00	   O_CopyCount ds	1
    556 U00e3		       00	   O_ROM_Source_Bank ds	1
    557 U00e4		       00	   O_Index    ds	1
    558 U00e5							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e5					      VALIDATE_OVERLAY
      5 U00e5					      LIST	ON
    560 U00e5
    561 U00e5							;------------------------------------------------------------------------------
    562 U00e5
      0 U00e5					      OVERLAY	Scoring
      1 U00e3 ????				      SEG.U	OVERLAY_Scoring
      2 U00e2					      org	Overlay
    564 U00e2		       00	   tmpStack   ds	1
    565 U00e2		       00 e2	   newDisplay =	tmpStack
    566 U00e3							; also for UpdateTimer
    567 U00e3		       00 e2	   tmpSound   =	tmpStack
      0 U00e3					      VALIDATE_OVERLAY
      5 U00e3					      LIST	ON
    569 U00e3
    570 U00e3
    571 U00e3							;------------------------------------------------------------------------------
    572 U00e3
      0 U00e3					      OVERLAY	SaveKey
      1 U00eb ????				      SEG.U	OVERLAY_SaveKey
      2 U00e2					      org	Overlay
    574 U00e2
    575 U00e2		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    576 U00e5		       00 00 00    highScoreSK ds	3
    577 U00e8		       00	   startingLevel ds	1	; levelx * 5
    578 U00e9		       00	   startLevel ds	1
    579 U00ea		       00	   offsetSK   ds	1	; for calculating the SK slot address
    580 U00eb
      0 U00eb					      VALIDATE_OVERLAY
      5 U00eb					      LIST	ON
    582 U00eb
    583 U00eb							;------------------------------------------------------------------------------
    584 U00eb
      0 U00eb					      OVERLAY	DrawMan
      1 U00e4 ????				      SEG.U	OVERLAY_DrawMan
      2 U00e2					      org	Overlay
    586 U00e2
    587 U00e2		       00 00	   MAN_Move   ds	2
    588 U00e4
    589 U00e4							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e4					      VALIDATE_OVERLAY
      5 U00e4					      LIST	ON
    591 U00e4
    592 U00e4							;------------------------------------------------------------------------------
    593 U00e4
      0 U00e4					      OVERLAY	ProcessObjStack
      1 U00e4 ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00e2					      org	Overlay
    595 U00e2
    596 U00e2		       00 00	   POS_Vector ds	2
    597 U00e4
    598 U00e4							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e4					      VALIDATE_OVERLAY
      5 U00e4					      LIST	ON
    600 U00e4
    601 U00e4							;------------------------------------------------------------------------------
    602 U00e4
      0 U00e4					      OVERLAY	ScoreLineOverlay
      1 U00f1 ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00e2					      org	Overlay
    604 U00e2
    605 U00e2		       00 00	   S0	      ds	2	; used for addressing digits of score
    606 U00e4		       00 00	   S1	      ds	2
    607 U00e6		       00 00	   S2	      ds	2
    608 U00e8		       00 00	   S3	      ds	2
    609 U00ea		       00 00	   S4	      ds	2
    610 U00ec		       00 00	   S5	      ds	2
    611 U00ee
    612 U00ee		       00	   stkp       ds	1
    613 U00ef		       00	   sreg       ds	1
    614 U00f0		       00	   loop       ds	1
    615 U00f1
    616 U00f1							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00f1					      VALIDATE_OVERLAY
      5 U00f1					      LIST	ON
    618 U00f1
    619 U00f1							;------------------------------------------------------------------------------
    620 U00f1
    621 U00f1
      0 U00f1					      OVERLAY	UnpackLevelOverlay
      1 U00e7 ????				      SEG.U	OVERLAY_UnpackLevelOverlay
      2 U00e2					      org	Overlay
    623 U00e2
    624 U00e2		       00	   base_x     ds	1
    625 U00e3		       00	   base_y     ds	1
    626 U00e4		       00	   upk_length ds	1
    627 U00e5		       00	   upk_column ds	1
    628 U00e6		       00	   upk_temp   ds	1
    629 U00e7
    630 U00e7							;ECHO "FREE BYTES IN UnpackLevelOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e7					      VALIDATE_OVERLAY
      5 U00e7					      LIST	ON
    632 U00e7
    633 U00e7							;------------------------------------------------------------------------------
    634 U00e7
      0 U00e7					      OVERLAY	ManProcessing
      1 U00e4 ????				      SEG.U	OVERLAY_ManProcessing
      2 U00e2					      org	Overlay
    636 U00e2		       00 00	   actionVector ds	2
      0 U00e4					      VALIDATE_OVERLAY
      5 U00e4					      LIST	ON
    638 U00e4
      0 U00e4					      OVERLAY	SetPlatformColours
      1 U00e3 ????				      SEG.U	OVERLAY_SetPlatformColours
      2 U00e2					      org	Overlay
    640 U00e2		       00	   colorIdx   ds	1
      0 U00e3					      VALIDATE_OVERLAY
      5 U00e3					      LIST	ON
    642 U00e3
      0 U00e3					      OVERLAY	DrawIntoStack
      1 U00e3 ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00e2					      org	Overlay
    644 U00e2		       00	   save_SP    ds	1
      0 U00e3					      VALIDATE_OVERLAY
      5 U00e3					      LIST	ON
    646 U00e3
    647 U00e3							;------------------------------------------------------------------------------
    648 U00e3							;##############################################################################
    649 U00e3							;------------------------------------------------------------------------------
    650 U00e3
    651 U00e3							; NOW THE VERY INTERESTING '3E' RAM BANKS
    652 U00e3							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    653 U00e3
    654 U00e3				   ORIGIN     SET	0
      0 U00e3					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN / RAM_SIZE
      6 U0000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    656 U0000
    657 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    658 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    659 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    660 U0000
    661 U0000		       00 60	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    662 U0000
    663 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    664 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    665 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    666 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    667 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    668 U0000
    669 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    670 U0000							; is that we can use that code to switch between banks, and the system will happily
    671 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    672 U0000
    673 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    674 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    675 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    676 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    677 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    678 U0000
    679 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    680 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    681 U0000							; part of the draw routine *every* scanline (though the system currently uses
    682 U0000							; one colour shared between both players).
    683 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    685 U0000
    686 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    687 U0000							; accessed via the above labels but with the appropriate bank switched in.
    688 U0000
    689 U0000							;------------------------------------------------------------------------------
    690 U0000
    691 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    691 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    691 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    691 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1000				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    691 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    691 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    691 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    694 U1c00					      REPEND
    695 U1c00
    696 U1c00							;------------------------------------------------------------------------------
    697 U1c00							;##############################################################################
    698 U1c00							;------------------------------------------------------------------------------
    699 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN / RAM_SIZE
      6 U2000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    701 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    702 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    704 U2000
    705 U2000							;------------------------------------------------------------------------------
    706 U2000							;##############################################################################
    707 U2000							;------------------------------------------------------------------------------
    708 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN / RAM_SIZE
      6 U2400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    710 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    711 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    713 U2400
    714 U2400							;------------------------------------------------------------------------------
    715 U2400							;##############################################################################
    716 U2400							;------------------------------------------------------------------------------
    717 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_LEVEL
      1 U2800 ????				      SEG.U	BANK_DECODE_LEVEL
      2 U2800					      ORG	ORIGIN
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_LEVEL SET	ORIGIN / RAM_SIZE
      6 U2800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    719 U2800							; VARS DEFINED IN BANK_DECODE_LEVEL_SHADOW
    720 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    722 U2800
    723 U2800							;------------------------------------------------------------------------------
    724 U2800							;##############################################################################
    725 U2800							;------------------------------------------------------------------------------
    726 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN / RAM_SIZE
      6 U2c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
    728 U2c00
    729 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    730 U2c00							; position of something that needs to be processed.  These things include anything
    731 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    732 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    733 U2c00							; one for the next processing iteration.
    734 U2c00
    735 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    736 U2c00
    737 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    738 U2c00
    739 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    740 U2c00
    741 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    742 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    743 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    744 U2d80
    745 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    746 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    747 U2e00
    748 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    749 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    750 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    751 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    753 U2e80
    754 U2e80							;------------------------------------------------------------------------------
    755 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN / RAM_SIZE
      6 U3000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    757 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    759 U3000
    760 U3000							;------------------------------------------------------------------------------
    761 U3000							;##############################################################################
    762 U3000							;------------------------------------------------------------------------------
    763 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U35f0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN / RAM_SIZE
      6 U3400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    765 U3400
    766 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    767 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    768 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    769 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    770 U3400							; when accessing.
    771 U3400
    772 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    773 U3400							; automatically based on the sizes set in these constants. The board may overlay
    774 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    775 U3400							; we're doing OK.
    776 U3400
    777 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    778 U3400
    779 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    780 U3400
    781 U3400		       00 18	   SIZE_BOARD_X =	24	;
    782 U3400		       00 14	   SIZE_BOARD_Y =	20	;22
    783 U3400				  -	      if	0
    784 U3400				  -			; have to precalculate it here, else DASM freaks out:
    785 U3400				  -.BOARD_SIZE SET	0
    786 U3400				  -.BOARD_LOCATION SET	0
    787 U3400				  -	      REPEAT	SIZE_BOARD_Y
    788 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    789 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    790 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    791 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    792 U3400				  -	      ENDIF
    793 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    794 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    795 U3400				  -	      REPEND
    796 U3400				  -
    797 U3400				  -SIZE_BOARD =	.BOARD_SIZE
    798 U3400					      endif
    799 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    800 U3400				  -MULTI_BANK_BOARD =	YES
    801 U3400					      ELSE
    802 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    803 U3400					      ENDIF
    804 U3400
    805 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    806 U35f0							; 1024 byte chunks, switching RAM
    807 U35f0							; banks as we go.  In other words,
    808 U35f0							; this overlaps multiple banks!
    809 U35f0
      0 U35f0					      NEWRAMBANK	BANK_TAKEBACK
      1 U3940 ????				      SEG.U	BANK_TAKEBACK
      2 U3800					      ORG	ORIGIN
      3 U3800					      RORG	RAM_3E
      4 U3800				   BANK_START SET	*
      5 U3800				   BANK_TAKEBACK SET	ORIGIN / RAM_SIZE
      6 U3800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    811 U3800
    812 U3800		       00 3f	   TAKEBACK_MASK =	$3F
    813 U3800
    814 U3800		       00 00 00 00*TakeBackPreviousX ds	$40
    815 U3840		       00 00 00 00*TakeBackPreviousY ds	$40
    816 U3880		       00 00 00 00*TakeBackPushX ds	$40
    817 U38c0		       00 00 00 00*TakeBackPushY ds	$40
    818 U3900		       00 00 00 00*TakeBackPushChar ds	$40
    819 U3940
    820 U3940							; reverting...
    821 U3940							; A prevoius position
    822 U3940							;	     POS_VAR = board
    823 U3940							;	     board = MANOCCUPIED
    824 U3940							;	     manx,y = x,y
    825 U3940							; B current position (MANX,Y)
    826 U3940							;	     board = POS_VAR
    827 U3940							; C push position
    828 U3940							;	     BOARD = PREV_BOARD
    829 U3940							; TAKEBACK_PREV_X, TAKEBACK_PREV_Y, TAKEBACK_PUSH_X,PUSH_Y,TAKEBACK_PUSH_PREV
    830 U3940							;
    831 U3940
    832 U3940
    833 U3940							; free space here (but hard to use)
    834 U3940							; So we need to calculate where the next free bank is!
    835 U3940							; TODO: This looks dodgy.  Check..
    836 U3940
    837 U3940				   ORIGIN     SET	( * + RAM_SIZE - 1 ) / RAM_SIZE
    838 U3940				   ORIGIN     SET	ORIGIN * RAM_SIZE
    839 U3940
    840 U3940
    841 U3940
    842 U3940							;------------------------------------------------------------------------------
    843 U3940							;##############################################################################
    844 U3940							;------------------------------------------------------------------------------
    845 U3940
    846 U3940							;------------------------------------------------------------------------------
    847 U3940
    848 U3940							;    IFNCONST MAX_LEVEL_SIZE
    849 U3940				   MAX_LEVEL_SIZE SET	0
    850 U3940							;    ENDIF
    851 U3940
    852 U3940
    853 U3940				   MAX_LEVEL_NUMBER SET	0
    854 U3940					      MAC	start_level
    855 U3940				   LEVEL_START SET	*
    856 U3940				   BANK_LEVEL_{1} =	_CURRENT_BANK
    857 U3940				   LEVEL_{1}  SUBROUTINE
    858 U3940				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
    859 U3940							; ECHO "current MAX_LEVEL_NUMBER = ", MAX_LEVEL_NUMBER
    860 U3940					      ENDM		; {name}
    861 U3940
    862 U3940
    863 U3940					      MAC	end_level
    864 U3940				   LEVEL_SIZE_{1} =	* - LEVEL_START
    865 U3940					      IF	LEVEL_SIZE_{1} > MAX_LEVEL_SIZE
    866 U3940				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_{1}
    867 U3940					      ENDIF
    868 U3940					      ENDM		; {name}
    869 U3940
    870 U3940
    871 U3940					      MAC	defl
    872 U3940					      START_LEVEL	{1}
    873 U3940					      .byte	{2},0
    874 U3940					      END_LEVEL	{1}
    875 U3940					      ENDM
    876 U3940
    877 U3940							;--------------------------------------------------------------------------------
    878 U3940
    879 U3940				   ORIGIN     SET	$00000
    880 U3940
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 4
      0 U3940					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1 U3940							;    Sokoboo - a Sokoban implementation
      2 U3940							;    using a generic tile-based display engine for the Atari 2600
      3 U3940							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4 U3940							;
      5 U3940							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6 U3940							;
      7 U3940							;    Code related to the generic tile-based display engine was developed by
      8 U3940							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9 U3940							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10 U3940							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11 U3940							;
     12 U3940							;    Code related to music and sound effects uses the TIATracker music player
     13 U3940							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14 U3940							;    directory for Apache licensing details.
     15 U3940							;
     16 U3940							;    Some level data incorporated in this program were created by Lee J Haywood.
     17 U3940							;    See the copyright notices in the License directory for a list of level
     18 U3940							;    contributors.
     19 U3940							;
     20 U3940							;    Except where otherwise indicated, this software is released under the
     21 U3940							;    following licensing arrangement...
     22 U3940							;
     23 U3940							;    This program is free software: you can redistribute it and/or modify
     24 U3940							;    it under the terms of the GNU General Public License as published by
     25 U3940							;    the Free Software Foundation, either version 3 of the License, or
     26 U3940							;    (at your option) any later version.
     27 U3940							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28 U3940
     29 U3940							;    This program is distributed in the hope that it will be useful,
     30 U3940							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31 U3940							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32 U3940							;    GNU General Public License for more details.
     33 U3940
     34 U3940							;------------------------------------------------------------------------------
     35 U3940							;##############################################################################
     36 U3940							;------------------------------------------------------------------------------
      0 U3940					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  034e ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
     38  0000
     39  0000							; This is essentially a ROM mirror of a RAM bank.
     40  0000							; The contents of this bank are copied to each of the ROW banks on startup, and
     41  0000							; this gives a 1:1 correspondence between the data/addresses defined here, and
     42  0000							; the addresses in the switched-in RAM bank.
     43  0000
     44  0000							; Note: Bankswitching code between any of these banks guarantees the code can
     45  0000							; continue to run -- because, of course, the same code is still at the same
     46  0000							; memory address.
     47  0000
     48  0000		       00 01	   _PROFILE_DRAW =	YES
     49  0000
     50  0000					      MAC	profile_draw
     51  0000					      IF	_PROFILE_DRAW
     52  0000					      inc	Profile{1}
     53  0000					      bne	$skip
     54  0000					      inc	Profile{1}+1
     55  0000				   $skip
     56  0000					      ENDIF
     57  0000					      ENDM		; {label}
     58  0000
     59  0000
      0  0000					      DEFINE_SUBROUTINE	DrawTheScreen
      1  0000		       00 00	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  0000					      SUBROUTINE
      3  0000				   DrawTheScreen
     61  0000
     62  0000							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     63  0000							; A refactor of the kernel to improve the timing.
     64  0000							; Experimental refactor to remove the blank line...
     65  0000
     66  0000							; adjust here so that the first line of the kernel starts exactly at cycle 67
     67  0000							; (since TJ said it could start up to 5 cycles earlier than #67).
     68  0000
     69  0000							; TODO: remove GRP1 and COLUP1 access (or use higher resolution player)
     70  0000							;	     @57
      0  0000					      SLEEP	3	; 3
      1  0000				   .CYCLES    SET	3
      2  0000
      3  0000				  -	      IF	.CYCLES < 2
      4  0000				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0000				  -	      ERR
      6  0000					      ENDIF
      7  0000
      8  0000					      IF	.CYCLES & 1
      9  0000					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0000		       04 00		      nop	0
     11  0002				  -	      ELSE
     12  0002				  -	      bit	VSYNC
     13  0002					      ENDIF
     14  0002				   .CYCLES    SET	.CYCLES - 3
     15  0002					      ENDIF
     16  0002
     17  0002				  -	      REPEAT	.CYCLES / 2
     18  0002				  -	      nop
     19  0002					      REPEND
     72  0002
     73  0002		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     74  0004		       10 3e		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     75  0006
     76  0006				   Proc2		; 5
      0  0006					      SLEEP	3	; 3	     @64
      1  0006				   .CYCLES    SET	3
      2  0006
      3  0006				  -	      IF	.CYCLES < 2
      4  0006				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0006				  -	      ERR
      6  0006					      ENDIF
      7  0006
      8  0006					      IF	.CYCLES & 1
      9  0006					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0006		       04 00		      nop	0
     11  0008				  -	      ELSE
     12  0008				  -	      bit	VSYNC
     13  0008					      ENDIF
     14  0008				   .CYCLES    SET	.CYCLES - 3
     15  0008					      ENDIF
     16  0008
     17  0008				  -	      REPEAT	.CYCLES / 2
     18  0008				  -	      nop
     19  0008					      REPEND
     78  0008		       10 3c		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     79  000a
     80  000a				   ScanRED		;	     @60
     81  000a		       b9 b6 f2    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     82  000d		       85 4d		      sta	PF0	; 3	     @67
     83  000f		       b9 2c f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     84  0012		       85 4e		      sta	PF1	; 3 = 14    @74
     85  0014							;SELFMOD_PLAYERCOL_RED
     86  0014		       b9 af f0 	      lda	SpriteColourRED,y	; 4
     87  0017							;lda #$66
     88  0017							;nop
     89  0017		       85 46		      sta	COLUP0	; 3	     @05
     90  0019		       85 47		      sta	COLUP1	; 3 = 10    @08
     91  001b
     92  001b							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     93  001b
     94  001b				   SELFMOD_RED
     95  001b		       a9 00		      lda	#0	; 2
     96  001d		       85 48		      sta	COLUPF	; 3 =	5    @13
     97  001f
     98  001f				   SELFMOD_PLAYER0_RED
     99  001f		       b9 b6 f2 	      lda	ShapePlayerRED,y	; 4
    100  0022		       85 5b		      sta	GRP0	; 3 =	7    @20
    101  0024
    102  0024		       b9 44 f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
    103  0027		       85 4f		      sta	PF2	; 3 =	7    @27
    104  0029
    105  0029		       b9 b6 f2    SM_PF0_REDr lda	CHARACTERSHAPE_BLANK,y	; 4
    106  002c		       85 4d		      sta	PF0	; 3	     @34
    107  002e		       b9 5c f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
    108  0031		       85 4e		      sta	PF1	; 3	     @41
    109  0033		       b9 74 f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
    110  0036		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
    111  0038
    112  0038				   SELFMOD_PLAYER1_RED
    113  0038		       b9 b6 f2 	      lda	ShapePlayerRED,y	; 4
    114  003b		       8d 5c 00 	      sta.w	GRP1	; 4 =	8    @56   VDELed!
    115  003e
    116  003e		       88		      dey		; 2
    117  003f		       10 c5		      bpl	Proc2	; 2(3)      --> 61 if taken
    118  0041
    119  0041		       e8	   SELFMOD_X  inx		; 2
    120  0042		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
    121  0044							;EXIT_RETURN_HERE
    122  0044				   NextALineStart
    123  0044		       a0 07		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
    124  0046				   ScanBLUEBD		;	     @67     let's start as late as possible
    125  0046
    126  0046							;------------------------------------------------------------------------------
    127  0046
    128  0046		       b9 b6 f2    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
    129  0049		       85 4d		      sta	PF0	; 3 =	7    @74
    130  004b							;SELFMOD_PLAYERCOL_BLUE
    131  004b		       b9 bf f0 	      lda	SpriteColourBLUE,y	; 4
    132  004e							;lda #$66
    133  004e							;nop
    134  004e		       85 47		      sta	COLUP1	; 3	     @05
    135  0050		       85 46		      sta	COLUP0	; 3 = 10    @08
    136  0052
    137  0052				   SELFMOD_BLUE
    138  0052		       a9 00		      lda	#0	; 2
    139  0054		       85 48		      sta	COLUPF	; 3 =	5    @13
    140  0056
    141  0056				   SELFMOD_PLAYER0_BLUE
    142  0056		       b9 b6 f2 	      lda	ShapePlayerBLUE,y	; 4
    143  0059		       85 5b		      sta	GRP0	; 3 =	7    @20
    144  005b
    145  005b		       b9 3c f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    146  005e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    147  0060		       b9 54 f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    148  0063		       85 4f		      sta	PF2	; 3 = 14    @34
    149  0065
    150  0065		       b9 b6 f2    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    151  0068		       85 4d		      sta	PF0	; 3	     @41
    152  006a		       b9 6c f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    153  006d		       85 4e		      sta	PF1	; 3	     @48
    154  006f		       b9 84 f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    155  0072		       85 4f		      sta	PF2	; 3 = 21    @55
    156  0074
    157  0074				   SELFMOD_PLAYER1_BLUE
    158  0074		       b9 b6 f2 	      lda	ShapePlayerBLUE,y	; 4
    159  0077		       85 5c		      sta	GRP1	; 3 =	7    VDELed! @62
    160  0079
    161  0079							;------------------------------------------------------------------------------
    162  0079
    163  0079				   ScanGREEN		;	     @62
    164  0079		       b9 b6 f2    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    165  007c		       85 4d		      sta	PF0	; 3 =	7    @69
    166  007e							;SELFMOD_PLAYERCOL_GREEN
    167  007e		       b9 b7 f0 	      lda	SpriteColourGREEN,y	; 4
    168  0081							;lda #$66
    169  0081							;nop
    170  0081		       85 47		      sta	COLUP1	; 3	     @00
    171  0083		       85 46		      sta	COLUP0	; 3 = 10    @03
    172  0085
    173  0085				   SELFMOD_GREEN
    174  0085		       a9 00		      lda	#0	; 2
    175  0087		       85 48		      sta	COLUPF	; 3 =	5    @08
    176  0089
    177  0089				   SELFMOD_PLAYER0_GREEN
    178  0089		       b9 b6 f2 	      lda	ShapePlayerGREEN,y	; 4
    179  008c		       85 5b		      sta	GRP0	; 3 =	7    @15
    180  008e
    181  008e		       b9 34 f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    182  0091		       85 4e		      sta	PF1	; 3	     @22
    183  0093		       b9 4c f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    184  0096		       85 4f		      sta	PF2	; 3 = 14    @29
    185  0098
    186  0098		       b9 b6 f2    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    187  009b		       85 4d		      sta	PF0	; 3	     @36
    188  009d		       b9 64 f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    189  00a0		       85 4e		      sta	PF1	; 3	     @43
    190  00a2		       b9 7c f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    191  00a5		       85 4f		      sta	PF2	; 3 = 21    @50
    192  00a7
    193  00a7				   SELFMOD_PLAYER1_GREEN
    194  00a7		       b9 b6 f2 	      lda	ShapePlayerGREEN,y	; 4
    195  00aa		       85 5c		      sta	GRP1	; 3 =	7    @57     VDELed!
    196  00ac
    197  00ac		       4c 0a f0 	      jmp	ScanRED	; 3	     @60
    198  00af
    199  00af							;------------------------------------------------------------------------------
    200  00af
    201  00af							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    202  00af
    203  00af		       f2 b6	   ShapePlayer =	PLAYER_BLANK
    204  00af		       f2 b6	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    205  00af		       f2 b6	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    206  00af		       f2 b6	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    207  00af
    208  00af		       f2 b6	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    209  00af		       f2 b6	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    210  00af
    211  00af
    212  00af				   PLAYER_COLOUR
    213  00af				   SpriteColourRED
    214  00af					      REPEAT	LINES_PER_CHAR/3
    215  00af		       24		      .byte.b	$24
    214  00af					      REPEND
    215  00b0		       24		      .byte.b	$24
    214  00b0					      REPEND
    215  00b1		       24		      .byte.b	$24
    214  00b1					      REPEND
    215  00b2		       24		      .byte.b	$24
    214  00b2					      REPEND
    215  00b3		       24		      .byte.b	$24
    214  00b3					      REPEND
    215  00b4		       24		      .byte.b	$24
    214  00b4					      REPEND
    215  00b5		       24		      .byte.b	$24
    214  00b5					      REPEND
    215  00b6		       24		      .byte.b	$24
    216  00b7					      REPEND
    217  00b7				   SpriteColourGREEN
    218  00b7					      REPEAT	LINES_PER_CHAR/3
    219  00b7		       24		      .byte.b	$24
    218  00b7					      REPEND
    219  00b8		       24		      .byte.b	$24
    218  00b8					      REPEND
    219  00b9		       24		      .byte.b	$24
    218  00b9					      REPEND
    219  00ba		       24		      .byte.b	$24
    218  00ba					      REPEND
    219  00bb		       24		      .byte.b	$24
    218  00bb					      REPEND
    219  00bc		       24		      .byte.b	$24
    218  00bc					      REPEND
    219  00bd		       24		      .byte.b	$24
    218  00bd					      REPEND
    219  00be		       24		      .byte.b	$24
    220  00bf					      REPEND
    221  00bf				   SpriteColourBLUE
    222  00bf					      REPEAT	LINES_PER_CHAR/3
    223  00bf		       24		      .byte.b	$24
    222  00bf					      REPEND
    223  00c0		       24		      .byte.b	$24
    222  00c0					      REPEND
    223  00c1		       24		      .byte.b	$24
    222  00c1					      REPEND
    223  00c2		       24		      .byte.b	$24
    222  00c2					      REPEND
    223  00c3		       24		      .byte.b	$24
    222  00c3					      REPEND
    223  00c4		       24		      .byte.b	$24
    222  00c4					      REPEND
    223  00c5		       24		      .byte.b	$24
    222  00c5					      REPEND
    223  00c6		       24		      .byte.b	$24
    224  00c7					      REPEND
    225  00c7
    226  00c7
    227  00c7							;------------------------------------------------------------------------------
    228  00c7
    229  00c7							;*** Ideas: ***
    230  00c7							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    231  00c7							;   13.5% on average), also unrolling would be more effective than now
    232  00c7							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    233  00c7							;   see EXPERIMENTAL)
    234  00c7							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    235  00c7							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    236  00c7							;   bidirectional linked list instead)
    237  00c7							; - calculate mirrored gfx data into RAM (saves ROM)
    238  00c7
    239  00c7							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    240  00c7							;currently:
    241  00c7							; 72%*539 (!unrolled)
    242  00c7							;+ 8%*304 (unrolled)
    243  00c7							;+20%*269 (unrolled)
    244  00c7							;--------
    245  00c7							;=   ~466.2 cycles on average
    246  00c7
    247  00c7							;alternative #1:
    248  00c7							; 72%*522 (unrolled)
    249  00c7							;+ 8%*352 (!unrolled)
    250  00c7							;+20%*307 (!unrolled)
    251  00c7							;--------
    252  00c7							;=   ~465.4 cycles on average
    253  00c7
    254  00c7
    255  00c7		       00 01	   MIRROR     =	1
    256  00c7		       00 80	   DIRECT     =	$80
    257  00c7
    258  00c7							;------------------------------------------------------------------------------
    259  00c7							; Here we don't draw into a buffer, but directly patch the kernel
    260  00c7							; VERY fast!
    261  00c7							;
    262  00c7							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    263  00c7							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    264  00c7
    265  00c7				   PF0Draw		; 25 cycles until here
    266  00c7
    267  00c7		       ae 84 02 	      ldx	INTIM	; 4
    268  00ca		       e0 02		      cpx	#SEGTIME_SCD_PF0	; 2
    269  00cc		       90 72		      bcc	ExitDraw	; 2(3)=8
      0  00ce					      STRESS_TIME	SEGTIME_SCD_PF0	; ok!
      1  00ce				  -	      IF	TEST_SEGTIME_SCD_PF0 = 1
      2  00ce				  -
      3  00ce				  -
      4  00ce				  -
      5  00ce				  -
      6  00ce				  -
      7  00ce				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  00ce				  -	      bne	. - 7
      9  00ce					      ENDIF
    271  00ce
    272  00ce		       29 7f		      and	#<(~DIRECT)	; 2
    273  00d0		       aa		      tax		; 2 =	4
    274  00d1
    275  00d1		       98		      tya		; 2
    276  00d2		       0a		      asl		; 2	     no mirrored chars in PF0
    277  00d3		       a8		      tay		; 2 =	6
    278  00d4							;		  clc				  ; 2
    279  00d4
    280  00d4		       b9 3a f3 	      lda	CharacterDataVecHI,y	; 4
    281  00d7		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    282  00da		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    283  00dd		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19
    284  00e0
    285  00e0		       b9 26 f3 	      lda	CharacterDataVecLO,y	; 4
    286  00e3		       9d 0b f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    287  00e6		       69 07		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    288  00e8		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    289  00eb		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    290  00ed		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23
    291  00f0
    292  00f0		       4c ce fa 	      jmp	DrawAnother	; 3 =	3
    293  00f3
    294  00f3							; Timing for PF0Draw
    295  00f3							; 88
    296  00f3							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    297  00f3
    298  00f3
    299  00f3							;------------------------------------------------------------------------------
    300  00f3							; Direct draw draws to PF0, which only has one active member of the character
    301  00f3							; pair -- so it can be a direct copy.	Quicker still!
    302  00f3
    303  00f3				   DirectDraw		; 37 cycles until here
    304  00f3
    305  00f3							;ldy #16
    306  00f3		       ad 84 02 	      lda	INTIM	; 4
    307  00f6		       c9 07		      cmp	#SEGTIME_SCD_DIRECT	; 2
    308  00f8		       90 46		      bcc	ExitDraw	; 2(3)=8
      0  00fa					      STRESS_TIME	SEGTIME_SCD_DIRECT	; ok!
      1  00fa				  -	      IF	TEST_SEGTIME_SCD_DIRECT = 1
      2  00fa				  -
      3  00fa				  -
      4  00fa				  -
      5  00fa				  -
      6  00fa				  -
      7  00fa				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  00fa				  -	      bne	. - 7
      9  00fa					      ENDIF
    310  00fa
    311  00fa							; TIME REQUIRED FROM HERE (9/JAN)
    312  00fa							; 16 + 20 + 20 + 2 + ( 8 * 32 ) - 1  + (42 SUFFIX)
    313  00fa							; = 323 --> /64 = 5.04 USE 7
    314  00fa
    315  00fa		       b9 3a f3 	      lda	CharacterDataVecHI,y	; 4
    316  00fd		       8d 2a f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    317  0100		       8d 30 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    318  0103		       8d 36 f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    319  0106
    320  0106		       b9 26 f3 	      lda	CharacterDataVecLO,y	; 4
    321  0109		       8d 29 f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    322  010c		       69 07		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    323  010e		       8d 2f f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    324  0111		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    325  0113		       8d 35 f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    326  0116
    327  0116		       bd ca f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    328  0119		       8d 2c f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    329  011c		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    330  011e		       8d 32 f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    331  0121		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    332  0123		       8d 38 f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    333  0126
    334  0126		       a0 07		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    335  0128				   TSFill3
    336  0128		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    337  012b		       99 2c f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    338  012e		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    339  0131		       99 2c f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    340  0134		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    341  0137		       99 2c f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    342  013a
    343  013a		       88		      dey		; 2
      0  013b					      CHECKPAGE_BPL	TSFill3	; 3(2)=5
      8  013b					      LIST	ON
      9  013b		       10 eb		      bpl	TSFill3
    345  013d
    346  013d		       4c ce fa 	      jmp	DrawAnother	; 3
    347  0140
    348  0140							; Timing for DirectDraw
    349  0140							; 17+8+16+20+20+2+(32*7)-1+3 = 309 (was: 302 + 3)
    350  0140							; total: 37+309+6 = 352 => 352/64 + 1.4 = 6.90 = 7 (= SEGTIME_SLOWDRAW-5)
    351  0140
    352  0140				   ExitDraw
    353  0140		       60		      rts
    354  0141
    355  0141							;------------------------------------------------------------------------------
      0  0141					      DEFINE_SUBROUTINE	StealPart3	; 18 CYCLES HERE
      1  0141		       00 00	   BANK_StealPart3 =	_CURRENT_BANK
      2  0141					      SUBROUTINE
      3  0141				   StealPart3
    357  0141
    358  0141		       bd dc f1 	      lda	MOD10,x	; 4
    359  0144		       30 81		      bmi	PF0Draw	; 2/3
    360  0146		       4a		      lsr		; 2
    361  0147		       aa		      tax		; 2
    362  0148		       98		      tya		; 2
    363  0149		       2a		      rol		; 2	     allows for mirrored char = * | 1
    364  014a		       a8		      tay		; 2
    365  014b		       b0 a6		      bcs	DirectDraw	; 2(3)      when draw stack was built, bit 7 flags direct-drawn character
    366  014d							;	     => +19 starting DirectDraw BUT WHO CARES AS IT'S ONLY AFTER THAT COUNTS
    367  014d
    368  014d		       b9 3a f3 	      lda	CharacterDataVecHI,y	; 4
    369  0150		       10 38		      bpl	QuickDraw	; 2(3)=42   special-case blank characters for extra speed
    370  0152							;	     => 42 starting QuickDraw
    371  0152		       8d 7b f5 	      sta	SMEOR1+RAM_WRITE+2	; 4 =	4
    372  0155
    373  0155		       ad 84 02 	      lda	INTIM	; 4
    374  0158		       c9 0b		      cmp	#SEGTIME_SCD_SLOW	; 2
    375  015a		       90 e4		      bcc	ExitDraw	; 2(3)=8
      0  015c					      STRESS_TIME	SEGTIME_SCD_SLOW	; ok!
      1  015c				  -	      IF	TEST_SEGTIME_SCD_SLOW = 1
      2  015c				  -
      3  015c				  -
      4  015c				  -
      5  015c				  -
      6  015c				  -
      7  015c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  015c				  -	      bne	. - 7
      9  015c					      ENDIF
    377  015c
    378  015c							; TIME REQUIRED FROM HERE (9/JAN)
    379  015c							; 8 + 16 + 8 + 2 + (24 * 24) -1 + (42 OVERHEAD WHEN RETURNING)
    380  015c							; = 651
    381  015c
    382  015c		       b9 26 f3 	      lda	CharacterDataVecLO,y	; 4
    383  015f		       8d 7a f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    384  0162
    385  0162		       bd ca f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    386  0165		       8d 77 f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    387  0168		       8d 7f f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    388  016b		       8d 82 f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    389  016e
    390  016e		       bd d4 f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    391  0171		       8d 7d f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    392  0174
    393  0174		       a0 17	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2
    394  0176
    395  0176							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    396  0176							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    397  0176
    398  0176				   TSFill
    399  0176
    400  0176		       b9 2c f2    SMLOAD     lda	ScreenBitmap,y	; 4
    401  0179		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    402  017c		       29 00	   SMMASK     and	#0	; 2
    403  017e		       59 2c f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    404  0181		       99 2c f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    405  0184
    406  0184		       88		      dey		; 2
      0  0185					      CHECKPAGE_BPL	TSFill	; 3(2)=5
      8  0185					      LIST	ON
      9  0185		       10 ef		      bpl	TSFill
    408  0187
    409  0187		       4c ce fa 	      jmp	DrawAnother	; 3
    410  018a
    411  018a							; Timing for "SLOW" draw
    412  018a							; 22+4+8+8+16+8+2+(21*24)-1+3 = 574 (was: 566 + 3)
    413  018a							; total: 37+574+6 = 617 => 628/64 + 1.4 = 11.04 = 12 (= SEGTIME_SLOWDRAW)
    414  018a
    415  018a
    416  018a							;------------------------------------------------------------------------------
    417  018a							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    418  018a							; existing character data, so can be special-cased from the normal character
    419  018a							; draw, saving roughly 230 cycles.
    420  018a
    421  018a				   QuickDraw		; 42 cycles until here
    422  018a
    423  018a		       ad 84 02 	      lda	INTIM	; 4
    424  018d		       c9 07		      cmp	#SEGTIME_SCD_QUICK	; 2	     SEE TIMING CALCS BELOW
    425  018f		       90 af		      bcc	ExitDraw	; 2(3)=8
      0  0191					      STRESS_TIME	SEGTIME_SCD_QUICK	; ok!
      1  0191				  -	      IF	TEST_SEGTIME_SCD_QUICK = 1
      2  0191				  -
      3  0191				  -
      4  0191				  -
      5  0191				  -
      6  0191				  -
      7  0191				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  0191				  -	      bne	. - 7
      9  0191					      ENDIF
    427  0191
    428  0191							; TIME REQUIRED FROM HERE (9/JAN)
    429  0191							;   = 32 + 4 + 2 + ( 8 * 38 ) - 1 + 3	+ (42 SUFFIX)
    430  0191							;   = 386 --> /64 = 5.43. USE 7
    431  0191
    432  0191		       bd ca f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    433  0194		       8d b1 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    434  0197		       8d b4 f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    435  019a		       69 07		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    436  019c		       8d b8 f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    437  019f		       8d bb f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    438  01a2		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    439  01a4		       8d bf f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    440  01a7		       8d c2 f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32
    441  01aa
    442  01aa		       bc d2 f1 	      ldy	CharMask,x	; 4 =	4    masks out left or right
    443  01ad
    444  01ad		       a2 07		      ldx	#LINES_PER_CHAR/3 - 1	; 2 =	2
    445  01af				   TSFill2
    446  01af		       98		      tya		; 2
    447  01b0		       3d 2c f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    448  01b3		       9d 2c f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    449  01b6		       98		      tya		; 2
    450  01b7		       3d 2c f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    451  01ba		       9d 2c f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    452  01bd		       98		      tya		; 2
    453  01be		       3d 2c f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    454  01c1		       9d 2c f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33
    455  01c4
    456  01c4		       ca		      dex		; 2
      0  01c5					      CHECKPAGE_BPL	TSFill2	; 3(2)=5
      8  01c5					      LIST	ON
      9  01c5		       10 e8		      bpl	TSFill2
    458  01c7
    459  01c7		       4c ce fa 	      jmp	DrawAnother	; 3
    460  01ca
    461  01ca							; Timing for QuickDraw
    462  01ca							; 23+8+32+4+2+(7*38)-1+3 = 337 (was: 330 + 3)
    463  01ca							; total: 37+337+6 = 380 => 380/64 + 1.4 = 7.34 = 8 (= SEGTIME_SLOWDRAW-4)
    464  01ca
    465  01ca
    466  01ca							;------------------------------------------------------------------------------
    467  01ca
    468  01ca
    469  01ca				   CharAddressLO		;[abs char location % 10]
    470  01ca
    471  01ca							; Gives the absolute screen buffer address of the first line of the given character
    472  01ca							; Where character number is 0-9
    473  01ca
    474  01ca		       2c		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    475  01cb		       2c		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    476  01cc		       44		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    477  01cd		       44		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    478  01ce		       5c		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    479  01cf		       5c		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    480  01d0		       74		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    481  01d1		       74		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    482  01d2							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    483  01d2							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    484  01d2
    485  01d2				   CharMask		; [abs char location % 10]
    486  01d2
    487  01d2							; Gives the mask for any char of the screen (per row)
    488  01d2							; Note, this is hardwired to the screen format of 6 bytes/line
    489  01d2
    490  01d2		       0f		      .byte.b	$0F	; 1
    491  01d3		       f0		      .byte.b	$F0	; 2
    492  01d4				   CharMaskNeg
    493  01d4		       f0		      .byte.b	$F0	; 3/1
    494  01d5		       0f		      .byte.b	$0F	; 4/2
    495  01d6		       0f		      .byte.b	$0F	; 6/3
    496  01d7		       f0		      .byte.b	$F0	; 7/4
    497  01d8		       f0		      .byte.b	$F0	; 8/6
    498  01d9		       0f		      .byte.b	$0F	; 9/7
    499  01da		       0f		      .byte.b	$0F	; -/8
    500  01db		       f0		      .byte.b	$F0	; -/9
    501  01dc				   MOD10
    502  01dc					      REPEAT	SCREEN_LINES
    503  01dc							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    504  01dc							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    505  01dc		       80		      .byte.b	DIRECT
    506  01dd		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    507  01e1		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    508  01e2		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    502  01e2					      REPEND
    503  01e6							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    504  01e6							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    505  01e6		       80		      .byte.b	DIRECT
    506  01e7		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    507  01eb		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    508  01ec		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    502  01ec					      REPEND
    503  01f0							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    504  01f0							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    505  01f0		       80		      .byte.b	DIRECT
    506  01f1		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    507  01f5		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    508  01f6		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    502  01f6					      REPEND
    503  01fa							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    504  01fa							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    505  01fa		       80		      .byte.b	DIRECT
    506  01fb		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    507  01ff		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    508  0200		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    502  0200					      REPEND
    503  0204							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    504  0204							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    505  0204		       80		      .byte.b	DIRECT
    506  0205		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    507  0209		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    508  020a		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    502  020a					      REPEND
    503  020e							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    504  020e							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    505  020e		       80		      .byte.b	DIRECT
    506  020f		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    507  0213		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    508  0214		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    502  0214					      REPEND
    503  0218							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    504  0218							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    505  0218		       80		      .byte.b	DIRECT
    506  0219		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    507  021d		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    508  021e		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    502  021e					      REPEND
    503  0222							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    504  0222							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    505  0222		       80		      .byte.b	DIRECT
    506  0223		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    507  0227		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    508  0228		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    509  022c					      REPEND
    510  022c
    511  022c							;------------------------------------------------------------------------------
    512  022c
      0  022c					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  022c					      LIST	ON
    514  022c
    515  022c		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,0	; character bitmap row (10 chars wide)
    516  022c		       f2 2c	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    517  022c		       f2 34	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    518  022c		       f2 3c	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    519  028c
      0  028c					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  028c					      LIST	ON
    521  028c
    522  028c
    523  028c							;--------------------------------------------------------------------------
    524  028c
      0  028c					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  028c		       00 00	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  028c					      SUBROUTINE
      3  028c				   SelfModDrawPlayers
    526  028c
    527  028c							; Now the player(s) have animated, update the appropriate shape pointers
    528  028c							; in the draw code.
    529  028c
    530  028c							; Sets the shapes to a blank player -- effectively erasing
    531  028c
    532  028c		       a5 b5		      lda	LastSpriteY
    533  028e		       a2 b6		      ldx	#<PLAYER_BLANK
    534  0290		       20 9f f2 	      jsr	SetSelfModPlayer
    535  0293
    536  0293							; Now we've erased, we write the new shape
    537  0293
    538  0293		       a5 a4		      lda	ManDrawX
    539  0295		       c9 0a		      cmp	#SCREEN_WIDTH
    540  0297		       b0 1c		      bcs	NoMod	; skip if off visible screen
    541  0299
    542  0299		       a5 a5		      lda	ManDrawY
    543  029b		       85 b5		      sta	LastSpriteY
    544  029d
    545  029d		       a6 aa		      ldx	ManAnimationFrameLO
    546  029f
    547  029f				   SetSelfModPlayer
    548  029f		       c9 08		      cmp	#SCREEN_LINES	; only erase/draw if was/is onscreen
    549  02a1		       b0 12		      bcs	NoMod
    550  02a3		       69 00		      adc	#BANK_SCREENMARKII1
    551  02a5		       85 3e		      sta	SET_BANK_RAM	; switch old/new bank in
    552  02a7
    553  02a7		       8a		      txa
    554  02a8		       8d 20 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1	; lo of frame
    555  02ab		       69 08		      adc	#LINES_PER_CHAR/3
    556  02ad		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    557  02b0		       69 08		      adc	#LINES_PER_CHAR/3
    558  02b2		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    559  02b5
    560  02b5		       60	   NoMod      rts
    561  02b6
      0  02b6					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  02b6
      2  02b6
      3  02b6		       02 b6	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $2b6 , FREE= $14a
      4  02b6					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  02b6				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  02b6				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  02b6				  -	      ERR
      8  02b6					      endif
    563  02b6
------- FILE player.asm LEVEL 3 PASS 4
      0  02b6					      include	"player.asm"	; 6 * LINES_PER_CHAR	       MUST FOLLOW DIRT.ASM as data is shared
      1  02b6							;    Sokoboo - a Sokoban implementation
      2  02b6							;    using a generic tile-based display engine for the Atari 2600
      3  02b6							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  02b6							;
      5  02b6							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  02b6							;
      7  02b6							;    Code related to the generic tile-based display engine was developed by
      8  02b6							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  02b6							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  02b6							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  02b6							;
     12  02b6							;    Code related to music and sound effects uses the TIATracker music player
     13  02b6							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  02b6							;    directory for Apache licensing details.
     15  02b6							;
     16  02b6							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  02b6							;    See the copyright notices in the License directory for a list of level
     18  02b6							;    contributors.
     19  02b6							;
     20  02b6							;    Except where otherwise indicated, this software is released under the
     21  02b6							;    following licensing arrangement...
     22  02b6							;
     23  02b6							;    This program is free software: you can redistribute it and/or modify
     24  02b6							;    it under the terms of the GNU General Public License as published by
     25  02b6							;    the Free Software Foundation, either version 3 of the License, or
     26  02b6							;    (at your option) any later version.
     27  02b6							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  02b6
     29  02b6							;    This program is distributed in the hope that it will be useful,
     30  02b6							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  02b6							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  02b6							;    GNU General Public License for more details.
     33  02b6
     34  02b6							;    OPTIONAL_PAGEBREAK "PLAYER", LINES_PER_CHAR * 6 - 1
     35  02b6
     36  02b6
     37  02b6				   PLAYER_BLANK
     38  02b6					      REPEAT	LINES_PER_CHAR	;-1  ; as we have a "0" in the line below
     39  02b6		       00		      .byte.b	0
     38  02b6					      REPEND
     39  02b7		       00		      .byte.b	0
     38  02b7					      REPEND
     39  02b8		       00		      .byte.b	0
     38  02b8					      REPEND
     39  02b9		       00		      .byte.b	0
     38  02b9					      REPEND
     39  02ba		       00		      .byte.b	0
     38  02ba					      REPEND
     39  02bb		       00		      .byte.b	0
     38  02bb					      REPEND
     39  02bc		       00		      .byte.b	0
     38  02bc					      REPEND
     39  02bd		       00		      .byte.b	0
     38  02bd					      REPEND
     39  02be		       00		      .byte.b	0
     38  02be					      REPEND
     39  02bf		       00		      .byte.b	0
     38  02bf					      REPEND
     39  02c0		       00		      .byte.b	0
     38  02c0					      REPEND
     39  02c1		       00		      .byte.b	0
     38  02c1					      REPEND
     39  02c2		       00		      .byte.b	0
     38  02c2					      REPEND
     39  02c3		       00		      .byte.b	0
     38  02c3					      REPEND
     39  02c4		       00		      .byte.b	0
     38  02c4					      REPEND
     39  02c5		       00		      .byte.b	0
     38  02c5					      REPEND
     39  02c6		       00		      .byte.b	0
     38  02c6					      REPEND
     39  02c7		       00		      .byte.b	0
     38  02c7					      REPEND
     39  02c8		       00		      .byte.b	0
     38  02c8					      REPEND
     39  02c9		       00		      .byte.b	0
     38  02c9					      REPEND
     39  02ca		       00		      .byte.b	0
     38  02ca					      REPEND
     39  02cb		       00		      .byte.b	0
     38  02cb					      REPEND
     39  02cc		       00		      .byte.b	0
     38  02cc					      REPEND
     39  02cd		       00		      .byte.b	0
     40  02ce					      REPEND
     41  02ce
     42  02ce				   PLAYER_RIGHT0
     43  02ce
     44  02ce		       18		      .byte.b	%00011000	;20
     45  02cf		       18		      .byte.b	%00011000	;20
     46  02d0		       7e		      .byte.b	%01111110	;20
     47  02d1		       7e		      .byte.b	%01111110	;20
     48  02d2		       7e		      .byte.b	%01111110	;20
     49  02d3		       18		      .byte.b	%00011000	;20
     50  02d4		       18		      .byte.b	%00011000	;20
     51  02d5		       00		      .byte.b	%00000000	;20
     52  02d6
     53  02d6		       18		      .byte.b	%00011000	;20
     54  02d7		       18		      .byte.b	%00011000	;20
     55  02d8		       7e		      .byte.b	%01111110	;20
     56  02d9		       7e		      .byte.b	%01111110	;20
     57  02da		       7e		      .byte.b	%01111110	;20
     58  02db		       18		      .byte.b	%00011000	;20
     59  02dc		       18		      .byte.b	%00011000	;20
     60  02dd		       00		      .byte.b	%00000000	;20
     61  02de
     62  02de		       18		      .byte.b	%00011000	;20
     63  02df		       18		      .byte.b	%00011000	;20
     64  02e0		       7e		      .byte.b	%01111110	;20
     65  02e1		       7e		      .byte.b	%01111110	;20
     66  02e2		       7e		      .byte.b	%01111110	;20
     67  02e3		       18		      .byte.b	%00011000	;20
     68  02e4		       18		      .byte.b	%00011000	;20
     69  02e5		       00		      .byte.b	%00000000	;20
     70  02e6
     71  02e6				   PLAYER_RIGHT1
     72  02e6				   PLAYER_STAND
     73  02e6				   PLAYER_BLINK
     74  02e6				   PLAYER_TAP0
     75  02e6				   PLAYER_TAP1
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    565  02e6
    566  02e6							;------------------------------------------------------------------------------
    567  02e6
    568  02e6							; The acutal colour palette to use for the player. The player may be any "ethnicity" which refers
    569  02e6							; to the colours for a frame. The skin could be asian/black/caucasian, the cloting could be anything.
    570  02e6							; Each ethnicity is defined as first 8 bytes for NTSC and then 8 bytes for PAL. The 8 bytes refer
    571  02e6							; to the "CL#" index values defined in the player COLOUR frames. So, an index is grabbed from the
    572  02e6							; player frame, it is adjusted to add the base ethnicity and the NTSC/PAL, and that gives the base
    573  02e6							; for reading 8 successive bytes for CL0..CL7 from the frame definitions.
    574  02e6
    575  02e6				   EthnicityColourPalette
    576  02e6
    577  02e6							; CL0	   = BLACK
    578  02e6							; CL1	   = HAT
    579  02e6							; CL2	   = SKIN
    580  02e6							; CL3	   = CUFFS/TRIM
    581  02e6							; CL4	   = JUMPER
    582  02e6							; CL5	   = PANTS
    583  02e6							; CL6	   = SHOES
    584  02e6							; CL7	   = UNUSED
    585  02e6
    586  02e6							; ETHNICITY 0 - a caucasian guy with blue shirt and pants, yellow cap
    587  02e6		       00 1c 4c 0a*	      .byte.b	$00, $1C,$4C,$0A,$88,$96,$14, $00	; NTSC
    588  02ee		       00 2c 6c 0a*	      .byte.b	$00, $2C,$6C,$0A,$78,$96,$24, $00	; PAL
    589  02f6
    590  02f6							; ETHNICITY 1	pink clothes, brown face
    591  02f6		       00 46 f4 08*	      .byte.b	$0, $46,$F4,$08,$A2,$74,$44, $00	; NTSC
    592  02fe		       00 66 24 08*	      .byte.b	$0, $66,$24,$08,$92,$D4,$64, $00	; PAL
    593  0306
    594  0306							; ETHNICITY 2
    595  0306		       00 2a e8 ea*	      .byte.b	$0, $2A,$E8,$EA,$64,$34,$84, $00	; NTSC
    596  030e		       00 4a 28 2a*	      .byte.b	$0, $4A,$28,$2A,$A4,$64,$D4, $00	; PAL
    597  0316
    598  0316							; ETHNICITY 2
    599  0316		       00 34 5a 1c*	      .byte.b	$0, $34,$5A,$1C,$B4,$86,$58, $00	; NTSC
    600  031e		       00 64 8a 2c*	      .byte.b	$0, $64,$8A,$2C,$74,$B6,$88, $00	; PAL
    601  0326
    602  0326							;------------------------------------------------------------------------------
    603  0326
    604  0326							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    605  0326
    606  0326							;------------------------------------------------------------------------------
    607  0326
    608  0326
    609  0326
    610  0326
    611  0326				   OBJTYPE    SET	0
    612  0326					      MAC	define_character
    613  0326				   CHARACTER_{1} =	OBJTYPE
    614  0326				   OBJTYPE    .SET	OBJTYPE + 1
    615  0326					      ENDM
    616  0326
    617  0326							; Modifications to character #/order must also ensure the following are correct...
    618  0326							;   CharacterDataVecLO/HI	   in this file
    619  0326							;   MoveVecLO/HI		   in BANK_INITBANK
    620  0326							;   CharReplacement		   in BANK_ROM_SHADOW_DRAWBUFFERS
    621  0326
      0  0326					      DEFINE_CHARACTER	BLANK
      1  0326		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	SOIL
      1  0326		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	BOX
      1  0326		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	TARGET
      1  0326		       00 03	   CHARACTER_TARGET =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	TARGET2
      1  0326		       00 04	   CHARACTER_TARGET2 =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	MANOCCUPIED
      1  0326		       00 05	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	STEEL
      1  0326		       00 06	   CHARACTER_STEEL =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	WALL
      1  0326		       00 07	   CHARACTER_WALL =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	BOX_ON_TARGET
      1  0326		       00 08	   CHARACTER_BOX_ON_TARGET =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
      0  0326					      DEFINE_CHARACTER	NOGO
      1  0326		       00 09	   CHARACTER_NOGO =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
    632  0326
    633  0326				  -	      if	DIGITS
    634  0326				  -	      DEFINE_CHARACTER	0
    635  0326				  -	      DEFINE_CHARACTER	1
    636  0326				  -	      DEFINE_CHARACTER	2
    637  0326				  -	      DEFINE_CHARACTER	3
    638  0326				  -	      DEFINE_CHARACTER	4
    639  0326				  -	      DEFINE_CHARACTER	5
    640  0326				  -	      DEFINE_CHARACTER	6
    641  0326				  -	      DEFINE_CHARACTER	7
    642  0326				  -	      DEFINE_CHARACTER	8
    643  0326				  -	      DEFINE_CHARACTER	9
    644  0326					      endif
    645  0326
    646  0326				  -	      if	TROPHY
    647  0326				  -
    648  0326				  -	      DEFINE_CHARACTER	TROPHY_0_0
    649  0326				  -	      DEFINE_CHARACTER	TROPHY_1_0
    650  0326				  -	      DEFINE_CHARACTER	TROPHY_2_0
    651  0326				  -	      DEFINE_CHARACTER	TROPHY_3_0
    652  0326				  -
    653  0326				  -	      DEFINE_CHARACTER	TROPHY_0_1
    654  0326				  -	      DEFINE_CHARACTER	TROPHY_1_1
    655  0326				  -	      DEFINE_CHARACTER	TROPHY_2_1
    656  0326				  -	      DEFINE_CHARACTER	TROPHY_3_1
    657  0326				  -
    658  0326				  -	      DEFINE_CHARACTER	TROPHY_0_2
    659  0326				  -	      DEFINE_CHARACTER	TROPHY_1_2
    660  0326				  -	      DEFINE_CHARACTER	TROPHY_2_2
    661  0326				  -	      DEFINE_CHARACTER	TROPHY_3_2
    662  0326				  -
    663  0326				  -	      DEFINE_CHARACTER	TROPHY_0_3
    664  0326				  -	      DEFINE_CHARACTER	TROPHY_1_3
    665  0326				  -	      DEFINE_CHARACTER	TROPHY_2_3
    666  0326				  -	      DEFINE_CHARACTER	TROPHY_3_3
    667  0326				  -
    668  0326				  -	      DEFINE_CHARACTER	TROPHY_0_4
    669  0326				  -	      DEFINE_CHARACTER	TROPHY_1_4
    670  0326				  -	      DEFINE_CHARACTER	TROPHY_2_4
    671  0326				  -	      DEFINE_CHARACTER	TROPHY_3_4
    672  0326					      endif
    673  0326
      0  0326					      DEFINE_CHARACTER	MAXIMUM
      1  0326		       00 0a	   CHARACTER_MAXIMUM =	OBJTYPE
      2  0326				   OBJTYPE    .SET	OBJTYPE + 1
    675  0326
    676  0326
    677  0326				   CharacterDataVecLO
    678  0326
    679  0326							; Two entries per character.  2nd is ptr to mirrored character
    680  0326							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
    681  0326
    682  0326		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    683  0327		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    684  0328		       30		      .byte.b	<CHARACTERSHAPE_SOIL
    685  0329		       30		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
    686  032a		       48		      .byte.b	<CHARACTERSHAPE_BOX
    687  032b		       60		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
    688  032c		       e6		      .byte.b	<CHARACTERSHAPE_TARGET
    689  032d		       e6		      .byte.b	<CHARACTERSHAPE_TARGET_MIRRORED
    690  032e		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    691  032f		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    692  0330		       b6		      .byte.b	<CHARACTERSHAPE_BLANK	; man occupied
    693  0331		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    694  0332		       00		      .byte.b	<CHARACTERSHAPE_STEEL
    695  0333		       18		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
    696  0334		       a8		      .byte.b	<CHARACTERSHAPE_WALL
    697  0335		       c0		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
    698  0336		       78		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET
    699  0337		       90		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    700  0338		       b6		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    701  0339		       b6		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    702  033a
    703  033a				  -	      if	DIGITS
    704  033a				  -	      .byte	<CHARACTERSHAPE_0, <CHARACTERSHAPE_0_MIRRORED
    705  033a				  -	      .byte	<CHARACTERSHAPE_1, <CHARACTERSHAPE_1_MIRRORED
    706  033a				  -	      .byte	<CHARACTERSHAPE_2, <CHARACTERSHAPE_2_MIRRORED
    707  033a				  -	      .byte	<CHARACTERSHAPE_3, <CHARACTERSHAPE_3_MIRRORED
    708  033a				  -	      .byte	<CHARACTERSHAPE_4, <CHARACTERSHAPE_4_MIRRORED
    709  033a				  -	      .byte	<CHARACTERSHAPE_5, <CHARACTERSHAPE_5_MIRRORED
    710  033a				  -	      .byte	<CHARACTERSHAPE_6, <CHARACTERSHAPE_6_MIRRORED
    711  033a				  -	      .byte	<CHARACTERSHAPE_7, <CHARACTERSHAPE_7_MIRRORED
    712  033a				  -	      .byte	<CHARACTERSHAPE_8, <CHARACTERSHAPE_8_MIRRORED
    713  033a				  -	      .byte	<CHARACTERSHAPE_9, <CHARACTERSHAPE_9_MIRRORED
    714  033a					      endif
    715  033a
    716  033a				  -	      if	TROPHY
    717  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_0_0, <CHARACTERSHAPE_TROPHY_0_0
    718  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_1_0, <CHARACTERSHAPE_TROPHY_1_0
    719  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_2_0, <CHARACTERSHAPE_TROPHY_2_0
    720  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_3_0, <CHARACTERSHAPE_TROPHY_3_0
    721  033a				  -
    722  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_0_1, <CHARACTERSHAPE_TROPHY_0_1
    723  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_1_1, <CHARACTERSHAPE_TROPHY_1_1
    724  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_2_1, <CHARACTERSHAPE_TROPHY_2_1
    725  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_3_1, <CHARACTERSHAPE_TROPHY_3_1
    726  033a				  -
    727  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_0_2, <CHARACTERSHAPE_TROPHY_0_2
    728  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_1_2, <CHARACTERSHAPE_TROPHY_1_2
    729  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_2_2, <CHARACTERSHAPE_TROPHY_2_2
    730  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_3_2, <CHARACTERSHAPE_TROPHY_3_2
    731  033a				  -
    732  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_0_3, <CHARACTERSHAPE_TROPHY_0_3
    733  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_1_3, <CHARACTERSHAPE_TROPHY_1_3
    734  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_2_3, <CHARACTERSHAPE_TROPHY_2_3
    735  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_3_3, <CHARACTERSHAPE_TROPHY_3_3
    736  033a				  -
    737  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_0_4, <CHARACTERSHAPE_TROPHY_0_4
    738  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_1_4, <CHARACTERSHAPE_TROPHY_1_4
    739  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_2_4, <CHARACTERSHAPE_TROPHY_2_4
    740  033a				  -	      .byte	<CHARACTERSHAPE_TROPHY_3_4, <CHARACTERSHAPE_TROPHY_3_4
    741  033a					      endif
    742  033a
    743  033a				  -	      IF	* - CharacterDataVecLO != CHARACTER_MAXIMUM*2
    744  033a				  -	      ECHO	"ERROR: Incorrect CharacterDataVecLO table!"
    745  033a				  -	      ERR
    746  033a					      ENDIF
    747  033a
    748  033a
    749  033a							;ds 20,0
    750  033a
    751  033a							;---------------------------------------------------------------------------
    752  033a
    753  033a				   CharacterDataVecHI
    754  033a
    755  033a		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    756  033b		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    757  033c		       ff		      .byte.b	>CHARACTERSHAPE_SOIL
    758  033d		       ff		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
    759  033e		       ff		      .byte.b	>CHARACTERSHAPE_BOX
    760  033f		       ff		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
    761  0340		       fe		      .byte.b	>CHARACTERSHAPE_TARGET
    762  0341		       fe		      .byte.b	>CHARACTERSHAPE_TARGET_MIRRORED
    763  0342		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    764  0343		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    765  0344		       f2		      .byte.b	>CHARACTERSHAPE_BLANK	; man occupied
    766  0345		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    767  0346		       ff		      .byte.b	>CHARACTERSHAPE_STEEL
    768  0347		       ff		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
    769  0348		       ff		      .byte.b	>CHARACTERSHAPE_WALL
    770  0349		       ff		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
    771  034a		       ff		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET
    772  034b		       ff		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    773  034c		       f2		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    774  034d		       f2		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    775  034e
    776  034e				  -	      if	DIGITS
    777  034e				  -	      .byte	>CHARACTERSHAPE_0, >CHARACTERSHAPE_0_MIRRORED
    778  034e				  -	      .byte	>CHARACTERSHAPE_1, >CHARACTERSHAPE_1_MIRRORED
    779  034e				  -	      .byte	>CHARACTERSHAPE_2, >CHARACTERSHAPE_2_MIRRORED
    780  034e				  -	      .byte	>CHARACTERSHAPE_3, >CHARACTERSHAPE_3_MIRRORED
    781  034e				  -	      .byte	>CHARACTERSHAPE_4, >CHARACTERSHAPE_4_MIRRORED
    782  034e				  -	      .byte	>CHARACTERSHAPE_5, >CHARACTERSHAPE_5_MIRRORED
    783  034e				  -	      .byte	>CHARACTERSHAPE_6, >CHARACTERSHAPE_6_MIRRORED
    784  034e				  -	      .byte	>CHARACTERSHAPE_7, >CHARACTERSHAPE_7_MIRRORED
    785  034e				  -	      .byte	>CHARACTERSHAPE_8, >CHARACTERSHAPE_8_MIRRORED
    786  034e				  -	      .byte	>CHARACTERSHAPE_9, >CHARACTERSHAPE_9_MIRRORED
    787  034e					      endif
    788  034e
    789  034e				  -	      if	TROPHY
    790  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_0_0, >CHARACTERSHAPE_TROPHY_0_0
    791  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_1_0, >CHARACTERSHAPE_TROPHY_1_0
    792  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_2_0, >CHARACTERSHAPE_TROPHY_2_0
    793  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_3_0, >CHARACTERSHAPE_TROPHY_3_0
    794  034e				  -
    795  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_0_1, >CHARACTERSHAPE_TROPHY_0_1
    796  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_1_1, >CHARACTERSHAPE_TROPHY_1_1
    797  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_2_1, >CHARACTERSHAPE_TROPHY_2_1
    798  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_3_1, >CHARACTERSHAPE_TROPHY_3_1
    799  034e				  -
    800  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_0_2, >CHARACTERSHAPE_TROPHY_0_2
    801  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_1_2, >CHARACTERSHAPE_TROPHY_1_2
    802  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_2_2, >CHARACTERSHAPE_TROPHY_2_2
    803  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_3_2, >CHARACTERSHAPE_TROPHY_3_2
    804  034e				  -
    805  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_0_3, >CHARACTERSHAPE_TROPHY_0_3
    806  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_1_3, >CHARACTERSHAPE_TROPHY_1_3
    807  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_2_3, >CHARACTERSHAPE_TROPHY_2_3
    808  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_3_3, >CHARACTERSHAPE_TROPHY_3_3
    809  034e				  -
    810  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_0_4, >CHARACTERSHAPE_TROPHY_0_4
    811  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_1_4, >CHARACTERSHAPE_TROPHY_1_4
    812  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_2_4, >CHARACTERSHAPE_TROPHY_2_4
    813  034e				  -	      .byte	>CHARACTERSHAPE_TROPHY_3_4, >CHARACTERSHAPE_TROPHY_3_4
    814  034e					      endif
    815  034e
    816  034e
    817  034e				  -	      IF	* - CharacterDataVecHI != CHARACTER_MAXIMUM*2
    818  034e				  -	      ECHO	"ERROR: Incorrect CharacterDataVecHI table!"
    819  034e				  -	      ERR
    820  034e					      ENDIF
    821  034e
      0  034e					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- 1K"
      1  034e
      2  034e
      3  034e		       03 4e	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- 1K (1K) SIZE =  $34e , FREE= $b2
      4  034e					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  034e				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  034e				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  034e				  -	      ERR
      8  034e					      endif
    823  034e
    824  034e							; Here there's another 1K of usable ROM....
    825  034e							; Anything here is ONLY accessible if the bank is switched in as a ROM bank
    826  034e							; WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    827  034e
      0  034e					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  034e		       03 4e	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $34e , FREE= $4b2
      2  034e					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  034e				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  034e				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  034e				  -	      ERR
      6  034e					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 4
      0  034e					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  034e							;    Sokoboo - a Sokoban implementation
      2  034e							;    using a generic tile-based display engine for the Atari 2600
      3  034e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  034e							;
      5  034e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  034e							;
      7  034e							;    Code related to the generic tile-based display engine was developed by
      8  034e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  034e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  034e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  034e							;
     12  034e							;    Code related to music and sound effects uses the TIATracker music player
     13  034e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  034e							;    directory for Apache licensing details.
     15  034e							;
     16  034e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  034e							;    See the copyright notices in the License directory for a list of level
     18  034e							;    contributors.
     19  034e							;
     20  034e							;    Except where otherwise indicated, this software is released under the
     21  034e							;    following licensing arrangement...
     22  034e							;
     23  034e							;    This program is free software: you can redistribute it and/or modify
     24  034e							;    it under the terms of the GNU General Public License as published by
     25  034e							;    the Free Software Foundation, either version 3 of the License, or
     26  034e							;    (at your option) any later version.
     27  034e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  034e
     29  034e							;    This program is distributed in the hope that it will be useful,
     30  034e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  034e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  034e							;    GNU General Public License for more details.
     33  034e
     34  034e							;------------------------------------------------------------------------------
     35  034e							;##############################################################################
     36  034e							;------------------------------------------------------------------------------
     37  034e
      0  034e					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  0a50 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
     39  0800
     40  0800							; NOTE: Access to these buffers must NOT overlap pages...
     41  0800							; NOTE: We get auto-initialisation of these variables from the ROM values by
     42  0800							; copying the whole bank into the RAM bank.  Neato.
     43  0800
     44  0800		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     45  0800
     46  0800
     47  0800
     48  0800		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     49  0850		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     50  08a0
      0  08a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  08a0					      LIST	ON
     52  08a0
     53  08a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     54  08a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     55  08a0							; what we want to happen!
     56  08a0
     57  08a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
     58  08f0
     59  08f0
     60  08f0							;------------------------------------------------------------------------------
     61  08f0							; RAM-BASED SUBROUTINES...
     62  08f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     63  08f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     64  08f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     65  08f0							; the RAM-based routine.
     66  08f0
     67  08f0
     68  08f0
     69  08f0							;------------------------------------------------------------------------------
     70  08f0
     71  08f0
     72  08f0		       60	   waitForDraw rts		; 6
     73  08f1
     74  08f1							;------------------------------------------------------------------------------
     75  08f1
      0  08f1					      DEFINE_SUBROUTINE	DrawStackUpdate	;=196 (+13 for fall-through bit)
      1  08f1		       00 01	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  08f1					      SUBROUTINE
      3  08f1				   DrawStackUpdate
     77  08f1
     78  08f1							; Parse the DrawFlags buffer and create a draw stack
     79  08f1							; so that the actual draw doesn't need to scan for characters to draw.
     80  08f1
     81  08f1
     82  08f1							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     83  08f1							; symptoms would be missing parts of screen when scrolling.
     84  08f1							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     85  08f1							; disabled for sokoban 27/7/2019
     86  08f1
     87  08f1							;lda DrawStackPointer
     88  08f1							;bpl waitForDraw		  ; Wait for previously not-drawn characters to be drawn
     89  08f1
     90  08f1		       ad 84 02 	      lda	INTIM	;4
     91  08f4		       c9 03		      cmp	#SEGTIME_BDS	;2
     92  08f6		       90 f8		      bcc	waitForDraw	;2/3
      0  08f8					      STRESS_TIME	SEGTIME_BDS
      1  08f8				  -	      IF	TEST_SEGTIME_BDS = 1
      2  08f8				  -
      3  08f8				  -
      4  08f8				  -
      5  08f8				  -
      6  08f8				  -
      7  08f8				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  08f8				  -	      bne	. - 7
      9  08f8					      ENDIF
     94  08f8
     95  08f8
     96  08f8							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
     97  08f8							; moving into the middle of dirt, or BOXs when pushing, or TARGETs when grabbing.
     98  08f8
     99  08f8							;		  sec		 already set
    100  08f8		       a5 a3		      lda	ManY	;3
    101  08fa		       e5 99		      sbc	BoardScrollY	;3
    102  08fc		       85 a5		      sta	ManDrawY	;3
    103  08fe
    104  08fe		       38		      sec		;2
    105  08ff		       a5 a2		      lda	ManX	;3
    106  0901		       e5 9a		      sbc	BoardScrollX	;3
    107  0903		       c9 0a		      cmp	#SCREEN_WIDTH	;2
    108  0905		       90 06		      bcc	onsc	;2/3
    109  0907
    110  0907							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
    111  0907							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
    112  0907							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
    113  0907
    114  0907		       a9 08		      lda	#SCREEN_LINES	;2
    115  0909		       85 a5		      sta	ManDrawY	;3
    116  090b		       d0 02		      bne	skipsc	;3		  unconditional
    117  090d
    118  090d		       85 a4	   onsc       sta	ManDrawX	;3
    119  090f				   skipsc
    120  090f
    121  090f		       e6 b6		      inc	timer	;5
    122  0911		       20 d7 f1 	      jsr	AnimateCharReplacements2	;3+28
    123  0914
    124  0914		       e6 87		      inc	ScreenDrawPhase	;5
    125  0916
    126  0916		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
    127  0918		       85 d4		      sta	DSL	;3
    128  091a
    129  091a							; fall through...
    130  091a							;---------------------------------------------------------------------------
    131  091a
      0  091a					      DEFINE_SUBROUTINE	DrawIntoStack
      1  091a		       00 01	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  091a					      SUBROUTINE
      3  091a				   DrawIntoStack
    133  091a
    134  091a		       ba		      tsx		;2
    135  091b		       86 e2		      stx	save_SP	;3
    136  091d		       a6 82		      ldx	DrawStackPointer	;3
    137  091f		       9a		      txs		;2 = 10
    138  0920
    139  0920		       a4 d4		      ldy	DSL	;3
    140  0922
    141  0922							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    142  0922							; + exit cost which is +10 cycles
    143  0922							; TJ: I count 63
    144  0922							;   + 14 for the wtf2 exit
    145  0922							;   + 22 for the end of loop exit
    146  0922
    147  0922							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    148  0922							; For 80 iterations that is 640 cycles, just for checking INTIM
    149  0922							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    150  0922							; it also will require a lot of CPU time for updating the screen data.
    151  0922
    152  0922							; TODO: optimize!
    153  0922							;
    154  0922							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    155  0922							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    156  0922							; costs some detection time here, but saves ~240 cylces for drawing the two
    157  0922
    158  0922		       ad 84 02    .loopDrawStack lda	INTIM	;4
    159  0925		       c9 03		      cmp	#SEGTIME_DSL	;2
    160  0927		       90 4b		      bcc	.exitDrawStack	;2/3= 8/9
      0  0929					      STRESS_TIME	SEGTIME_DSL
      1  0929				  -	      IF	TEST_SEGTIME_DSL = 1
      2  0929				  -
      3  0929				  -
      4  0929				  -
      5  0929				  -
      6  0929				  -
      7  0929				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  0929				  -	      bne	. - 7
      9  0929					      ENDIF
    162  0929
    163  0929		       b9 50 f0 	      lda	DrawFlag,y	;4
    164  092c		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    165  092f		       f0 16		      beq	.next0	;2/3=10/11	 yes, so we don't draw anything
    166  0931
    167  0931							; Character is NOT the same. Figure out how it should be drawn.
    168  0931							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    169  0931							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    170  0931							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    171  0931
    172  0931		       be 7d f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    173  0934		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    174  0937		       d0 05		      bne	.notPaired0	;2/3=10/11
    175  0939
    176  0939							; Consider two 'paired' characters. Either A:A or A:B
    177  0939							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    178  0939							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    179  0939							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    180  0939							; on the comparison, so the character will not be added to the draw stack. So our first character will
    181  0939							; do the job of drawing BOTH characters to the screen.
    182  0939
    183  0939		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    184  093c		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    185  093e
    186  093e							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    187  093e							; the last write(below) marks the character as to be direct-drawn.
    188  093e
    189  093e		       99 a0 f4    .notPaired0 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    190  0941
    191  0941							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    192  0941
    193  0941		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    194  0942		       98		      tya		;2
    195  0943		       ba		      tsx		;2		 << now X holds drawstackpointer
    196  0944		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    197  0947
    198  0947		       88	   .next0     dey		;2
    199  0948		       30 21		      bmi	.finishedDrawStack	;2/3= 4/5
    200  094a
    201  094a							; unrolled 2nd loop:
    202  094a		       b9 50 f0 	      lda	DrawFlag,y	;4
    203  094d		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    204  0950		       f0 16		      beq	.next1	;2/3=10/11	 yes, so we don't draw anything
    205  0952
    206  0952		       be 7d f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    207  0955		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    208  0958		       d0 05		      bne	.notPaired1	;2/3=10/11
    209  095a
    210  095a		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    211  095d		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    212  095f
    213  095f		       99 a0 f4    .notPaired1 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    214  0962
    215  0962		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    216  0963		       98		      tya		;2
    217  0964		       ba		      tsx		;2
    218  0965		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    219  0968
    220  0968		       88	   .next1     dey		;2
    221  0969		       10 b7		      bpl	.loopDrawStack	;2/3= 4/5
    222  096b							;worst case: 111-4
    223  096b							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    224  096b
    225  096b							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    226  096b
    227  096b				   .finishedDrawStack
    228  096b		       e6 87		      inc	ScreenDrawPhase	;5 =  5
    229  096d		       ba		      tsx		;2
    230  096e		       86 82		      stx	DrawStackPointer	;3
    231  0970
    232  0970		       a6 e2		      ldx	save_SP	;3
    233  0972		       9a		      txs		;2 = 10
    234  0973
    235  0973							;jmp SwitchObjects
    236  0973
    237  0973		       60		      rts		;6 =  6
    238  0974
    239  0974				   .exitDrawStack
    240  0974		       84 d4		      sty	DSL	;3 =  3
    241  0976		       ba		      tsx		;2
    242  0977		       86 82		      stx	DrawStackPointer	;3
    243  0979		       a6 e2		      ldx	save_SP	;3
    244  097b		       9a		      txs		;2 = 10
    245  097c		       60		      rts		;6 =  6
    246  097d
    247  097d				   PairedCharacter
    248  097d
    249  097d				   SOFF       SET	0
    250  097d					      REPEAT	SCREEN_LINES
    251  097d		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  097d				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  097d					      REPEND
    251  0987		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  0987				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  0987					      REPEND
    251  0991		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  0991				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  0991					      REPEND
    251  099b		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  099b				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  099b					      REPEND
    251  09a5		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  09a5				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  09a5					      REPEND
    251  09af		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  09af				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  09af					      REPEND
    251  09b9		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  09b9				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  09b9					      REPEND
    251  09c3		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  09c3				   SOFF       SET	SOFF + SCREEN_WIDTH
    253  09cd					      REPEND
    254  09cd
    255  09cd							;------------------------------------------------------------------------------
    256  09cd							; Gives character replacements used during screen drawing.
    257  09cd							; The character from the board is morphed via this array into an actual character
    258  09cd							; to draw.  This allows global animation and replacment of characters without
    259  09cd							; individual objects needing to do this.  Note, the draw-time replacement happens,
    260  09cd							; not board-time.
    261  09cd
    262  09cd				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    263  09cd
    264  09cd							; Converts a character # to an animated creature type
    265  09cd							; The array is indexed by CHARACTER_...
    266  09cd
    267  09cd		       00		      .byte.b	CHARACTER_BLANK	;  0
    268  09ce		       01		      .byte.b	CHARACTER_SOIL	;  1
    269  09cf		       02		      .byte.b	CHARACTER_BOX	;  2
    270  09d0		       03	   ANIM_TARGET .byte.b	CHARACTER_TARGET	;  3  XOR'd to give flashing target squares
    271  09d1		       04		      .byte.b	CHARACTER_TARGET2	;  4
    272  09d2		       05		      .byte.b	CHARACTER_MANOCCUPIED	;  5
    273  09d3		       06		      .byte.b	CHARACTER_STEEL	;  6
    274  09d4		       07		      .byte.b	CHARACTER_WALL	;  7
    275  09d5		       08		      .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    276  09d6		       00		      .byte.b	CHARACTER_BLANK	;  9
    277  09d7
    278  09d7				  -	      if	DIGITS
    279  09d7				  -	      .byte	CHARACTER_0
    280  09d7				  -	      .byte	CHARACTER_1
    281  09d7				  -	      .byte	CHARACTER_2
    282  09d7				  -	      .byte	CHARACTER_3
    283  09d7				  -	      .byte	CHARACTER_4
    284  09d7				  -	      .byte	CHARACTER_5
    285  09d7				  -	      .byte	CHARACTER_6
    286  09d7				  -	      .byte	CHARACTER_7
    287  09d7				  -	      .byte	CHARACTER_8
    288  09d7				  -	      .byte	CHARACTER_9
    289  09d7					      endif
    290  09d7
    291  09d7				  -	      if	TROPHY
    292  09d7				  -	      .byte	CHARACTER_TROPHY_0_0, CHARACTER_TROPHY_1_0, CHARACTER_TROPHY_2_0, CHARACTER_TROPHY_3_0
    293  09d7				  -	      .byte	CHARACTER_TROPHY_0_1, CHARACTER_TROPHY_1_1, CHARACTER_TROPHY_2_1, CHARACTER_TROPHY_3_1
    294  09d7				  -	      .byte	CHARACTER_TROPHY_0_2, CHARACTER_TROPHY_1_2, CHARACTER_TROPHY_2_2, CHARACTER_TROPHY_3_2
    295  09d7				  -	      .byte	CHARACTER_TROPHY_0_3, CHARACTER_TROPHY_1_3, CHARACTER_TROPHY_2_3, CHARACTER_TROPHY_3_3
    296  09d7				  -	      .byte	CHARACTER_TROPHY_0_4, CHARACTER_TROPHY_1_4, CHARACTER_TROPHY_2_4, CHARACTER_TROPHY_3_4
    297  09d7					      endif
    298  09d7
    299  09d7				  -	      IF	(* - CharReplacement != CHARACTER_MAXIMUM)
    300  09d7				  -	      ECHO	"ERROR: Incorrect CharReplacement table!"
    301  09d7				  -	      ERR
    302  09d7					      ENDIF
      0  09d7					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  09d7					      LIST	ON
    304  09d7
    305  09d7
      0  09d7					      DEFINE_SUBROUTINE	AnimateCharReplacements2	;139
      1  09d7		       00 01	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  09d7					      SUBROUTINE
      3  09d7				   AnimateCharReplacements2
    307  09d7
    308  09d7							; This manages character animation on a per-object basis.  Morph/animate these
    309  09d7							; characters individually or as required.  Change will affect all characters
    310  09d7							; of the same type in the visible display.
    311  09d7
    312  09d7							; -------------------------------------------
    313  09d7
    314  09d7							; handle the non-mandatory animating things
    315  09d7
    316  09d7		       a5 b6		      lda	timer	;3
    317  09d9		       29 01		      and	#1	;2
    318  09db		       d0 0c		      bne	nothingAnimates	;2/3
    319  09dd
    320  09dd		       a5 9b		      lda	scrollBits	;3
    321  09df		       d0 08		      bne	nothingAnimates	;2/3		 DON'T animate if we scrolled
    322  09e1
    323  09e1		       ad d0 f1 	      lda	ANIM_TARGET	;4
    324  09e4		       49 07		      eor	#CHARACTER_TARGET^CHARACTER_TARGET2	;2
    325  09e6		       8d d0 f5 	      sta	ANIM_TARGET + RAM_WRITE	;4 = 22	 TARGET
    326  09e9
    327  09e9		       60	   nothingAnimates rts		;6 = 28 if animating, less if not
    328  09ea
    329  09ea							;------------------------------------------------------------------------------
    330  09ea
    331  09ea
      0  09ea					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
 PAGE BREAK INSERTED FOR  ROW_BankChar
 REQUESTED SIZE =  $50
 WASTED SPACE =  $16
 PAGEBREAK LOCATION =  $f200
     10  0a00					      LIST	ON
      0  0a00					      DEFINE_SUBROUTINE	ROW_BankChar
      1  0a00		       00 01	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  0a00					      SUBROUTINE
      3  0a00				   ROW_BankChar
    334  0a00
    335  0a00				   .BANK      SET	BANK_SCREENMARKII1
    336  0a00					      REPEAT	SCREEN_LINES
    337  0a00					      REPEAT	SCREEN_WIDTH
    338  0a00		       00		      .byte.b	.BANK
    337  0a00					      REPEND
    338  0a01		       00		      .byte.b	.BANK
    337  0a01					      REPEND
    338  0a02		       00		      .byte.b	.BANK
    337  0a02					      REPEND
    338  0a03		       00		      .byte.b	.BANK
    337  0a03					      REPEND
    338  0a04		       00		      .byte.b	.BANK
    337  0a04					      REPEND
    338  0a05		       00		      .byte.b	.BANK
    337  0a05					      REPEND
    338  0a06		       00		      .byte.b	.BANK
    337  0a06					      REPEND
    338  0a07		       00		      .byte.b	.BANK
    337  0a07					      REPEND
    338  0a08		       00		      .byte.b	.BANK
    337  0a08					      REPEND
    338  0a09		       00		      .byte.b	.BANK
    339  0a0a					      REPEND
    340  0a0a				   .BANK      SET	.BANK + 1
    336  0a0a					      REPEND
    337  0a0a					      REPEAT	SCREEN_WIDTH
    338  0a0a		       01		      .byte.b	.BANK
    337  0a0a					      REPEND
    338  0a0b		       01		      .byte.b	.BANK
    337  0a0b					      REPEND
    338  0a0c		       01		      .byte.b	.BANK
    337  0a0c					      REPEND
    338  0a0d		       01		      .byte.b	.BANK
    337  0a0d					      REPEND
    338  0a0e		       01		      .byte.b	.BANK
    337  0a0e					      REPEND
    338  0a0f		       01		      .byte.b	.BANK
    337  0a0f					      REPEND
    338  0a10		       01		      .byte.b	.BANK
    337  0a10					      REPEND
    338  0a11		       01		      .byte.b	.BANK
    337  0a11					      REPEND
    338  0a12		       01		      .byte.b	.BANK
    337  0a12					      REPEND
    338  0a13		       01		      .byte.b	.BANK
    339  0a14					      REPEND
    340  0a14				   .BANK      SET	.BANK + 1
    336  0a14					      REPEND
    337  0a14					      REPEAT	SCREEN_WIDTH
    338  0a14		       02		      .byte.b	.BANK
    337  0a14					      REPEND
    338  0a15		       02		      .byte.b	.BANK
    337  0a15					      REPEND
    338  0a16		       02		      .byte.b	.BANK
    337  0a16					      REPEND
    338  0a17		       02		      .byte.b	.BANK
    337  0a17					      REPEND
    338  0a18		       02		      .byte.b	.BANK
    337  0a18					      REPEND
    338  0a19		       02		      .byte.b	.BANK
    337  0a19					      REPEND
    338  0a1a		       02		      .byte.b	.BANK
    337  0a1a					      REPEND
    338  0a1b		       02		      .byte.b	.BANK
    337  0a1b					      REPEND
    338  0a1c		       02		      .byte.b	.BANK
    337  0a1c					      REPEND
    338  0a1d		       02		      .byte.b	.BANK
    339  0a1e					      REPEND
    340  0a1e				   .BANK      SET	.BANK + 1
    336  0a1e					      REPEND
    337  0a1e					      REPEAT	SCREEN_WIDTH
    338  0a1e		       03		      .byte.b	.BANK
    337  0a1e					      REPEND
    338  0a1f		       03		      .byte.b	.BANK
    337  0a1f					      REPEND
    338  0a20		       03		      .byte.b	.BANK
    337  0a20					      REPEND
    338  0a21		       03		      .byte.b	.BANK
    337  0a21					      REPEND
    338  0a22		       03		      .byte.b	.BANK
    337  0a22					      REPEND
    338  0a23		       03		      .byte.b	.BANK
    337  0a23					      REPEND
    338  0a24		       03		      .byte.b	.BANK
    337  0a24					      REPEND
    338  0a25		       03		      .byte.b	.BANK
    337  0a25					      REPEND
    338  0a26		       03		      .byte.b	.BANK
    337  0a26					      REPEND
    338  0a27		       03		      .byte.b	.BANK
    339  0a28					      REPEND
    340  0a28				   .BANK      SET	.BANK + 1
    336  0a28					      REPEND
    337  0a28					      REPEAT	SCREEN_WIDTH
    338  0a28		       04		      .byte.b	.BANK
    337  0a28					      REPEND
    338  0a29		       04		      .byte.b	.BANK
    337  0a29					      REPEND
    338  0a2a		       04		      .byte.b	.BANK
    337  0a2a					      REPEND
    338  0a2b		       04		      .byte.b	.BANK
    337  0a2b					      REPEND
    338  0a2c		       04		      .byte.b	.BANK
    337  0a2c					      REPEND
    338  0a2d		       04		      .byte.b	.BANK
    337  0a2d					      REPEND
    338  0a2e		       04		      .byte.b	.BANK
    337  0a2e					      REPEND
    338  0a2f		       04		      .byte.b	.BANK
    337  0a2f					      REPEND
    338  0a30		       04		      .byte.b	.BANK
    337  0a30					      REPEND
    338  0a31		       04		      .byte.b	.BANK
    339  0a32					      REPEND
    340  0a32				   .BANK      SET	.BANK + 1
    336  0a32					      REPEND
    337  0a32					      REPEAT	SCREEN_WIDTH
    338  0a32		       05		      .byte.b	.BANK
    337  0a32					      REPEND
    338  0a33		       05		      .byte.b	.BANK
    337  0a33					      REPEND
    338  0a34		       05		      .byte.b	.BANK
    337  0a34					      REPEND
    338  0a35		       05		      .byte.b	.BANK
    337  0a35					      REPEND
    338  0a36		       05		      .byte.b	.BANK
    337  0a36					      REPEND
    338  0a37		       05		      .byte.b	.BANK
    337  0a37					      REPEND
    338  0a38		       05		      .byte.b	.BANK
    337  0a38					      REPEND
    338  0a39		       05		      .byte.b	.BANK
    337  0a39					      REPEND
    338  0a3a		       05		      .byte.b	.BANK
    337  0a3a					      REPEND
    338  0a3b		       05		      .byte.b	.BANK
    339  0a3c					      REPEND
    340  0a3c				   .BANK      SET	.BANK + 1
    336  0a3c					      REPEND
    337  0a3c					      REPEAT	SCREEN_WIDTH
    338  0a3c		       06		      .byte.b	.BANK
    337  0a3c					      REPEND
    338  0a3d		       06		      .byte.b	.BANK
    337  0a3d					      REPEND
    338  0a3e		       06		      .byte.b	.BANK
    337  0a3e					      REPEND
    338  0a3f		       06		      .byte.b	.BANK
    337  0a3f					      REPEND
    338  0a40		       06		      .byte.b	.BANK
    337  0a40					      REPEND
    338  0a41		       06		      .byte.b	.BANK
    337  0a41					      REPEND
    338  0a42		       06		      .byte.b	.BANK
    337  0a42					      REPEND
    338  0a43		       06		      .byte.b	.BANK
    337  0a43					      REPEND
    338  0a44		       06		      .byte.b	.BANK
    337  0a44					      REPEND
    338  0a45		       06		      .byte.b	.BANK
    339  0a46					      REPEND
    340  0a46				   .BANK      SET	.BANK + 1
    336  0a46					      REPEND
    337  0a46					      REPEAT	SCREEN_WIDTH
    338  0a46		       07		      .byte.b	.BANK
    337  0a46					      REPEND
    338  0a47		       07		      .byte.b	.BANK
    337  0a47					      REPEND
    338  0a48		       07		      .byte.b	.BANK
    337  0a48					      REPEND
    338  0a49		       07		      .byte.b	.BANK
    337  0a49					      REPEND
    338  0a4a		       07		      .byte.b	.BANK
    337  0a4a					      REPEND
    338  0a4b		       07		      .byte.b	.BANK
    337  0a4b					      REPEND
    338  0a4c		       07		      .byte.b	.BANK
    337  0a4c					      REPEND
    338  0a4d		       07		      .byte.b	.BANK
    337  0a4d					      REPEND
    338  0a4e		       07		      .byte.b	.BANK
    337  0a4e					      REPEND
    338  0a4f		       07		      .byte.b	.BANK
    339  0a50					      REPEND
    340  0a50				   .BANK      SET	.BANK + 1
    341  0a50					      REPEND
    342  0a50
      0  0a50					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  0a50
      2  0a50
      3  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $250 , FREE= $1b0
      4  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0a50				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0a50				  -	      ERR
      8  0a50					      endif
    344  0a50
    345  0a50
      0  0a50					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $250 , FREE= $5b0
      2  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0a50				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0a50				  -	      ERR
      6  0a50					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 4
      0  0a50					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  0a50							;    Sokoboo - a Sokoban implementation
      2  0a50							;    using a generic tile-based display engine for the Atari 2600
      3  0a50							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0a50							;
      5  0a50							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0a50							;
      7  0a50							;    Code related to the generic tile-based display engine was developed by
      8  0a50							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0a50							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0a50							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0a50							;
     12  0a50							;    Code related to music and sound effects uses the TIATracker music player
     13  0a50							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0a50							;    directory for Apache licensing details.
     15  0a50							;
     16  0a50							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0a50							;    See the copyright notices in the License directory for a list of level
     18  0a50							;    contributors.
     19  0a50							;
     20  0a50							;    Except where otherwise indicated, this software is released under the
     21  0a50							;    following licensing arrangement...
     22  0a50							;
     23  0a50							;    This program is free software: you can redistribute it and/or modify
     24  0a50							;    it under the terms of the GNU General Public License as published by
     25  0a50							;    the Free Software Foundation, either version 3 of the License, or
     26  0a50							;    (at your option) any later version.
     27  0a50							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0a50
     29  0a50							;    This program is distributed in the hope that it will be useful,
     30  0a50							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0a50							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0a50							;    GNU General Public License for more details.
     33  0a50
     34  0a50							;------------------------------------------------------------------------------
     35  0a50							;##############################################################################
     36  0a50							;------------------------------------------------------------------------------
      0  0a50					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  139d ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
     38  1000
     39  1000
     40  1000		       00 9a	   SCORE_COL  =	$9a	;WHITE ;-2
     41  1000		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     42  1000		       00 66	   SCORE_COL_HIGH_PAL =	$66
     43  1000
     44  1000
     45  1000				   DigitVectorLOr
     46  1000		       31 3f 4d 38*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     47  100a		       00 07 0e 15	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     48  100e				   DigitVectorLO
     49  100e		       53 61 6e 5a*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     50  1018		       37		      .byte.b	<BLANKL-1
     51  1019
     52  1019
     53  1019		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     54  1019		       00 0b	   ID_TARGET  =	11
     55  1019		       00 0c	   ID_EXTRA   =	12
     56  1019		       00 0d	   ID_CLOCK   =	13
     57  1019		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     58  1019
     59  1019							; score patch adresses:
     60  1019				   SMTblLSB
     61  1019				   SMTblTargets
     62  1019		       52 48		      .byte.b	SM_TARGET0+1-SM_BASE, SM_TARGET2+1-SM_BASE
     63  101b				   SMTblTime
     64  101b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     65  101d				   SMTblScore
     66  101d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     67  1020				   SMTblMSB
     68  1020		       4d 43		      .byte.b	SM_TARGET1+1-SM_BASE, SM_TARGET3+1-SM_BASE
     69  1022		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     70  1024		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     71  1027
     72  1027		       00 00	   SM_OFS_TARGETS =	SMTblTargets - SMTblLSB
     73  1027		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     74  1027		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     75  1027
     76  1027				   CharVectorLO
     77  1027		       37		      .byte.b	<BLANKL-1
     78  1028		       ad ad ad ad	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     79  102c		       ad ad ad ad	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     80  1030		       ad ad ad ad	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     81  1034		       ad ad ad ad	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     82  1038							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     83  1038
     84  1038							; Digit shape definitions are at start of bank so that we don't have page boundary
     85  1038							; crossing issues.
     86  1038
     87  1038							;	  .byte 0	      ; required!
     88  1038
     89  1038		       00 07	   DIGIT_H    =	7	; height of a score digit
     90  1038
     91  1038		       00 00 00 00*BLANKL     ds	7,0
     92  103f
     93  103f
     94  103f
     95  103f				   NineL
     96  103f		       1e		      .byte.b	%00011110
     97  1040		       02		      .byte.b	%00000010
     98  1041		       02		      .byte.b	%00000010
     99  1042		       fe		      .byte.b	%11111110
    100  1043		       82		      .byte.b	%10000010
    101  1044		       82		      .byte.b	%10000010
    102  1045		       fe		      .byte.b	%11111110
    103  1046
    104  1046				   SixL
    105  1046		       fe		      .byte.b	%11111110
    106  1047		       82		      .byte.b	%10000010
    107  1048		       82		      .byte.b	%10000010
    108  1049		       fe		      .byte.b	%11111110
    109  104a		       80		      .byte.b	%10000000
    110  104b		       80		      .byte.b	%10000000
    111  104c		       f0		      .byte.b	%11110000
    112  104d
    113  104d							;    .byte %01111100
    114  104d							;    .byte %11000010
    115  104d							;    .byte %11000010
    116  104d							;    .byte %11111100
    117  104d							;    .byte %11000000
    118  104d							;    .byte %01100000
    119  104d							;    .byte %00111000
    120  104d				   EightL
    121  104d
    122  104d
    123  104d		       fe		      .byte.b	%11111110
    124  104e		       82		      .byte.b	%10000010
    125  104f		       82		      .byte.b	%10000010
    126  1050		       fe		      .byte.b	%11111110
    127  1051		       82		      .byte.b	%10000010
    128  1052		       82		      .byte.b	%10000010
    129  1053		       fe		      .byte.b	%11111110
    130  1054
    131  1054							;  .byte %01111100
    132  1054							;  .byte %10000110
    133  1054							;  .byte %10000110
    134  1054							;  .byte %01111100
    135  1054							;  .byte %01000110
    136  1054							;  .byte %01000110
    137  1054							;  .byte %00111100
    138  1054				   ZeroL
    139  1054							;  .byte %01111100
    140  1054							;  .byte %10000110
    141  1054							;  .byte %10000110
    142  1054							;  .byte %10000110
    143  1054							;  .byte %10000110
    144  1054							;  .byte %01000110
    145  1054							;  .byte %00111100
    146  1054
    147  1054		       fe		      .byte.b	%11111110
    148  1055		       82		      .byte.b	%10000010
    149  1056		       82		      .byte.b	%10000010
    150  1057		       82		      .byte.b	%10000010
    151  1058		       82		      .byte.b	%10000010
    152  1059		       82		      .byte.b	%10000010
    153  105a		       fe		      .byte.b	%11111110
    154  105b
    155  105b				   ThreeL
    156  105b		       fe		      .byte.b	%11111110
    157  105c		       02		      .byte.b	%00000010
    158  105d		       02		      .byte.b	%00000010
    159  105e		       1e		      .byte.b	%00011110
    160  105f		       02		      .byte.b	%00000010
    161  1060		       02		      .byte.b	%00000010
    162  1061		       fe		      .byte.b	%11111110
    163  1062				   OneL
    164  1062		       10		      .byte.b	%00010000
    165  1063		       10		      .byte.b	%00010000
    166  1064		       10		      .byte.b	%00010000
    167  1065		       10		      .byte.b	%00010000
    168  1066		       10		      .byte.b	%00010000
    169  1067		       10		      .byte.b	%00010000
    170  1068		       10		      .byte.b	%00010000
    171  1069
    172  1069				   SevenL
    173  1069
    174  1069		       10		      .byte.b	%00010000
    175  106a		       10		      .byte.b	%00010000
    176  106b		       10		      .byte.b	%00010000
    177  106c		       1e		      .byte.b	%00011110
    178  106d		       02		      .byte.b	%00000010
    179  106e		       02		      .byte.b	%00000010
    180  106f							;  .byte %11111110
    181  106f
    182  106f							;    .byte %00010000
    183  106f							;    .byte %00010000
    184  106f							;    .byte %00010000
    185  106f							;    .byte %00011000
    186  106f							;    .byte %00001100
    187  106f							;    .byte %10000110
    188  106f							;    ;.byte %11111110
    189  106f				   TwoL
    190  106f		       fe		      .byte.b	%11111110
    191  1070		       80		      .byte.b	%10000000
    192  1071		       80		      .byte.b	%10000000
    193  1072		       fe		      .byte.b	%11111110
    194  1073		       02		      .byte.b	%00000010
    195  1074		       02		      .byte.b	%00000010
    196  1075		       fe		      .byte.b	%11111110
    197  1076
    198  1076				   FiveL
    199  1076		       fe		      .byte.b	%11111110
    200  1077		       02		      .byte.b	%00000010
    201  1078		       02		      .byte.b	%00000010
    202  1079		       fe		      .byte.b	%11111110
    203  107a		       80		      .byte.b	%10000000
    204  107b		       80		      .byte.b	%10000000
    205  107c		       f0		      .byte.b	%11110000
    206  107d
    207  107d				   FourL
    208  107d		       10		      .byte.b	%00010000
    209  107e		       10		      .byte.b	%00010000
    210  107f		       10		      .byte.b	%00010000
    211  1080		       fe		      .byte.b	%11111110
    212  1081		       90		      .byte.b	%10010000
    213  1082		       90		      .byte.b	%10010000
    214  1083		       90		      .byte.b	%10010000
    215  1084
    216  1084
    217  1084				   ZL
    218  1084		       7f		      .byte.b	%01111111
    219  1085		       40		      .byte.b	%01000000
    220  1086		       40		      .byte.b	%01000000
    221  1087		       7f		      .byte.b	%01111111
    222  1088		       01		      .byte.b	%00000001
    223  1089		       01		      .byte.b	%00000001
    224  108a		       0f		      .byte.b	%00001111
    225  108b
    226  108b				   EL
    227  108b		       7f		      .byte.b	%01111111
    228  108c		       40		      .byte.b	%01000000
    229  108d		       40		      .byte.b	%01000000
    230  108e		       78		      .byte.b	%01111000
    231  108f		       40		      .byte.b	%01000000
    232  1090		       40		      .byte.b	%01000000
    233  1091		       7f		      .byte.b	%01111111
    234  1092
    235  1092				   RL
    236  1092		       48		      .byte.b	%01001000
    237  1093		       48		      .byte.b	%01001000
    238  1094		       48		      .byte.b	%01001000
    239  1095		       7f		      .byte.b	%01111111
    240  1096		       41		      .byte.b	%01000001
    241  1097		       41		      .byte.b	%01000001
    242  1098		       7f		      .byte.b	%01111111
    243  1099
    244  1099				   PL
    245  1099		       40		      .byte.b	%01000000
    246  109a		       40		      .byte.b	%01000000
    247  109b		       40		      .byte.b	%01000000
    248  109c		       7f		      .byte.b	%01111111
    249  109d		       41		      .byte.b	%01000001
    250  109e		       41		      .byte.b	%01000001
    251  109f		       7f		      .byte.b	%01111111
    252  10a0
    253  10a0				   AL
    254  10a0		       41		      .byte.b	%01000001
    255  10a1		       41		      .byte.b	%01000001
    256  10a2		       41		      .byte.b	%01000001
    257  10a3		       7f		      .byte.b	%01111111
    258  10a4		       41		      .byte.b	%01000001
    259  10a5		       41		      .byte.b	%01000001
    260  10a6		       7f		      .byte.b	%01111111
    261  10a7
    262  10a7				   GL
    263  10a7		       7f		      .byte.b	%01111111
    264  10a8		       41		      .byte.b	%01000001
    265  10a9		       41		      .byte.b	%01000001
    266  10aa		       4f		      .byte.b	%01001111
    267  10ab		       40		      .byte.b	%01000000
    268  10ac		       40		      .byte.b	%01000000
    269  10ad		       7f		      .byte.b	%01111111
    270  10ae
    271  10ae
    272  10ae							; level "name" characters (left only!):
    273  10ae
    274  10ae				   CharN
    275  10ae				   CharK
    276  10ae				   CharH
    277  10ae				   CharA
    278  10ae				   CharJ
    279  10ae				   CharP
    280  10ae				   CharB
    281  10ae				   CharO
    282  10ae				   CharC
    283  10ae				   CharI
    284  10ae				   CharD
    285  10ae				   CharG
    286  10ae				   CharE
    287  10ae				   CharL
    288  10ae				   CharF
    289  10ae				   CharM
    290  10ae		       00 00 00 00*	      ds	7,0
    291  10b5
    292  10b5				   charPlace
    293  10b5		       0c		      .byte.b	%00001100
    294  10b6		       0c		      .byte.b	%00001100
    295  10b7		       0c		      .byte.b	%00001100
    296  10b8		       0c		      .byte.b	%00001100
    297  10b9		       0c		      .byte.b	%00001100
    298  10ba		       00		      .byte.b	%00000000
    299  10bb		       0c		      .byte.b	%00001100
    300  10bc
    301  10bc							;-------------------------------------------------------------------------------------
    302  10bc				   PosTbl
    303  10bc		       40		      .byte.b	$40
    304  10bd		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    305  10c5		       b9		      .byte.b	$b9
    306  10c6
    307  10c6
    308  10c6							;------------------------------------------------------------------------------
    309  10c6							; RAM-BASED SUBROUTINES...
    310  10c6							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    311  10c6							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    312  10c6							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    313  10c6							; the RAM-based routine.
    314  10c6
    315  1100		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    316  1100
    317  1100		       f1 00	   SM_BASE    =	.
    318  1100
    319  1100							;#IF 0 ;{
    320  1100							;    DEFINE_SUBROUTINE Score3x3
    321  1100							;
    322  1100							;	  sta	  RESP0
    323  1100							;	   sta	   RESP1
    324  1100							;	   lda	   #$$000
    325  1100							;	    sta     GRP0
    326  1100							;	    lda     #$$009
    327  1100							;	    sta     GRP1
    328  1100							;	    lda     #$$202
    329  1100							;	    sta     ENABL
    330  1100							;	    nop
    331  1100							;	    nop
    332  1100							;	    nop
    333  1100							;	    lda     #$$016
    334  1100							;	    ldy     #$$100
    335  1100							;	    ldx     #$$109
    336  1100							;	    sta     GRP0    ; Critical time is right here
    337  1100							;	    stx     GRP1
    338  1100							;	    sty     GRP0
    339  1100							;	    sta     RESP0
    340  1100							;	    sta     RESP1
    341  1100							;	    ldx     #$$116
    342  1100							;	    lda     #$$209
    343  1100							;	    stx     GRP0
    344  1100							;	    sta     GRP1
    345  1100							;	    lda     #$$200
    346  1100							;	    sta     GRP0
    347  1100							;	    sta     RESP0
    348  1100							;	    sta     RESP1
    349  1100							;	    lda     #$$216
    350  1100							;	    nop
    351  1100							;	    sta     GRP0
    352  1100							;
    353  1100							;	      rts
    354  1100							;#ENDIF ;}
    355  1100
    356  1100
    357  1100							;------------------------------------------------------------------------------
    358  1100				   Score1x6Fix SUBROUTINE
      0  1100					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  1100		       00 02	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  1100					      SUBROUTINE
      3  1100				   DrawDigits1x6
    360  1100							;					     @07
    361  1100		       ba		      tsx		; 2
    362  1101
    363  1101		       20 f2 f1 	      jsr	PrepareDrawDigits	;56 = 58    @65
    364  1104
    365  1104		       86 e2		      stx	tmpStack	; 3 =	3
    366  1106
    367  1106				   LoopDraw1x6		;
    368  1106				   SMDIGIT0
    369  1106		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    370  1109		       85 42		      sta	WSYNC	; 3
    371  110b							;---------------------------------------------------------------
    372  110b		       85 6a		      sta	HMOVE	; 3
      0  110d					      SLEEP	3	; 3 =	6
      1  110d				   .CYCLES    SET	3
      2  110d
      3  110d				  -	      IF	.CYCLES < 2
      4  110d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  110d				  -	      ERR
      6  110d					      ENDIF
      7  110d
      8  110d					      IF	.CYCLES & 1
      9  110d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  110d		       04 00		      nop	0
     11  110f				  -	      ELSE
     12  110f				  -	      bit	VSYNC
     13  110f					      ENDIF
     14  110f				   .CYCLES    SET	.CYCLES - 3
     15  110f					      ENDIF
     16  110f
     17  110f				  -	      REPEAT	.CYCLES / 2
     18  110f				  -	      nop
     19  110f					      REPEND
    374  110f		       85 5b		      sta	GRP0	; 3
    375  1111				   SMDIGIT1
    376  1111		       b9 53 f0 	      lda	ZeroL-1,y	; 4
    377  1114		       85 5c		      sta	GRP1	; 3
    378  1116				   SMDIGIT2
    379  1116		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    380  1119		       85 5b		      sta	GRP0	; 3 = 17
    381  111b				   SMDIGIT5
    382  111b		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    383  111e		       9a		      txs		; 2
    384  111f				   SMDIGIT3
    385  111f		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    386  1122				   SMDIGIT4
    387  1122		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    388  1125		       85 6b		      sta	HMCLR	; 3
    389  1127		       86 5c		      stx	GRP1	; 3
    390  1129		       85 5b		      sta	GRP0	; 3 = 23
    391  112b
    392  112b		       ba		      tsx		; 2
    393  112c		       86 5c		      stx	GRP1	; 3
    394  112e		       85 5b		      sta	GRP0	; 3 =	8
    395  1130
    396  1130		       88		      dey		; 2
      0  1131					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  1131					      LIST	ON
      9  1131		       d0 d3		      bne	LoopDraw1x6
    398  1133
    399  1133		       a6 e2		      ldx	tmpStack	; 3
    400  1135		       9a		      txs		; 2
    401  1136				   ExitDigitKernel6
      0  1136					      SLEEP	3	; 3
      1  1136				   .CYCLES    SET	3
      2  1136
      3  1136				  -	      IF	.CYCLES < 2
      4  1136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1136				  -	      ERR
      6  1136					      ENDIF
      7  1136
      8  1136					      IF	.CYCLES & 1
      9  1136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1136		       04 00		      nop	0
     11  1138				  -	      ELSE
     12  1138				  -	      bit	VSYNC
     13  1138					      ENDIF
     14  1138				   .CYCLES    SET	.CYCLES - 3
     15  1138					      ENDIF
     16  1138
     17  1138				  -	      REPEAT	.CYCLES / 2
     18  1138				  -	      nop
     19  1138					      REPEND
    403  1138		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    404  113b
    405  113b
    406  113b							;------------------------------------------------------------------------------
    407  113b				   Score2x4Fix SUBROUTINE
      0  113b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  113b		       00 02	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  113b					      SUBROUTINE
      3  113b				   DrawDigits2x4
    409  113b
    410  113b
    411  113b							; Subroutine by Thomas Jentzsch.  Magic!
    412  113b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    413  113b
    414  113b							;sta COLUBK
    415  113b
    416  113b		       20 f2 f1 	      jsr	PrepareDrawDigits	;56 = 56    @63
    417  113e
    418  113e		       85 6a		      sta	HMOVE	; 3
      0  1140					      SLEEP	4	; 4  =  7
      1  1140				   .CYCLES    SET	4
      2  1140
      3  1140				  -	      IF	.CYCLES < 2
      4  1140				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1140				  -	      ERR
      6  1140					      ENDIF
      7  1140
      8  1140				  -	      IF	.CYCLES & 1
      9  1140				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1140				  -	      nop	0
     11  1140				  -	      ELSE
     12  1140				  -	      bit	VSYNC
     13  1140				  -	      ENDIF
     14  1140				  -.CYCLES    SET	.CYCLES - 3
     15  1140					      ENDIF
     16  1140
     17  1140					      REPEAT	.CYCLES / 2
     18  1140		       ea		      nop
     17  1140					      REPEND
     18  1141		       ea		      nop
     19  1142					      REPEND
    420  1142
    421  1142				   LoopDraw2x4		;	     @70
    422  1142				   SM_TARGET3
    423  1142		       b9 07 f3 	      lda	DequalsR-1,y	; 4		     G
    424  1145							;---------------------------------------------------------------
    425  1145		       85 5b		      sta	GRP0	; 3
    426  1147				   SM_TARGET2
    427  1147		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     A
    428  114a		       85 5c		      sta	GRP1	; 3
    429  114c				   SM_TARGET1
    430  114c		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     M
    431  114f		       85 5b		      sta	GRP0	; 3
    432  1151				   SM_TARGET0
    433  1151		       be 53 f0 	      ldx	ZeroL-1,y	; 4		     E
    434  1154		       85 50		      sta	RESP0	; 3 = 28    @22
    435  1156		       85 51		      sta	RESP1	; 3 =	3    @25
    436  1158				   SM_Time3
    437  1158		       b9 15 f3 	      lda	ClockR-1,y	; 4		     O
    438  115b		       86 5c		      stx	GRP1	; 3
    439  115d		       85 5b		      sta	GRP0	; 3
    440  115f				   SM_Time2
    441  115f		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     V
    442  1162		       85 5c		      sta	GRP1	; 3
    443  1164				   SM_Time1
    444  1164		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     E
    445  1167		       85 5b		      sta	GRP0	; 3
    446  1169		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    447  116b		       85 51		      sta	RESP1	; 3 =	3    @55
    448  116d				   SM_Time0
    449  116d		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     R
    450  1170		       85 5c		      sta	GRP1	; 3
    451  1172		       85 5b		      sta	GRP0	; 3
    452  1174		       88		      dey		; 2
      0  1175					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  1175					      LIST	ON
      9  1175		       d0 cb		      bne	LoopDraw2x4
    454  1177
    455  1177				   ExitDigitKernel		;	     @69
    456  1177		       84 5b		      sty	GRP0	; 3
    457  1179		       84 5c		      sty	GRP1	; 3
    458  117b							;---------------------------------------------------------------
    459  117b		       84 5b		      sty	GRP0	; 3	     @02
    460  117d
    461  117d							; Contribution by Thomas Jentzsch
    462  117d							; Rewrite/Optimised for single sprite AD
    463  117d
    464  117d		       a6 a4		      ldx	ManDrawX	; 3
    465  117f		       bd bc f0 	      lda	PosTbl,x	; 4
    466  1182		       85 60		      sta	HMP0	; 3
    467  1184		       29 0f		      and	#$0f	; 2
    468  1186		       f0 04		      beq	.zeroPos	; 2/3=15
    469  1188		       aa		      tax		; 2
    470  1189				   .loopWait
    471  1189		       ca		      dex		; 2
    472  118a		       d0 fd		      bne	.loopWait	; 2/3= 6
    473  118c				   .zeroPos
    474  118c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    475  118e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    476  1190		       a5 b7		      lda	BGColour	; 3
    477  1192		       86 62		      stx	HMM0	; 3	     for extra life stars!
    478  1194		       85 42		      sta	WSYNC	; 3
    479  1196							;    sta WSYNC
    480  1196							;    sta WSYNC
    481  1196							;---------------------------------------------------------------
    482  1196		       85 6a		      sta	HMOVE	; 3
    483  1198		       85 49		      sta	COLUBK
    484  119a		       60		      rts		; 6	     @09
    485  119b
    486  119b							;------------------------------------------------------------------------------
    487  119b				   Score3x2Fix SUBROUTINE
      0  119b					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  119b		       00 02	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  119b					      SUBROUTINE
      3  119b				   DrawDigits3x2
    489  119b							;					     @07
    490  119b		       a9 16		      lda	#%010110	; 2
    491  119d		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    492  119f		       20 f8 f1 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    493  11a2
    494  11a2		       a9 00		      lda	#0
    495  11a4		       85 66		      sta	VDELP1
    496  11a6				   LoopDraw3x2		;
    497  11a6		       85 42		      sta	WSYNC	; 3
    498  11a8							;---------------------------------------------------------------
    499  11a8		       85 6a		      sta	HMOVE	; 3 =	3
    500  11aa		       b9 ad f0 	      lda	CharP-1,y	; 4
    501  11ad		       85 5b		      sta	GRP0	; 3
    502  11af				   SMPLAYER
    503  11af		       b9 3f f3 	      lda	OneR-1,y	; 4
    504  11b2		       85 5c		      sta	GRP1	; 3 = 14    @17
    505  11b4		       b9 b4 f0 	      lda	charPlace-1,y	; 4
    506  11b7				   SMMEN
    507  11b7		       be 38 f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  11ba					      SLEEP	5	;   =	5
      1  11ba				   .CYCLES    SET	5
      2  11ba
      3  11ba				  -	      IF	.CYCLES < 2
      4  11ba				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11ba				  -	      ERR
      6  11ba					      ENDIF
      7  11ba
      8  11ba					      IF	.CYCLES & 1
      9  11ba					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11ba		       04 00		      nop	0
     11  11bc				  -	      ELSE
     12  11bc				  -	      bit	VSYNC
     13  11bc					      ENDIF
     14  11bc				   .CYCLES    SET	.CYCLES - 3
     15  11bc					      ENDIF
     16  11bc
     17  11bc					      REPEAT	.CYCLES / 2
     18  11bc		       ea		      nop
     19  11bd					      REPEND
    509  11bd		       85 5b		      sta	GRP0	; 3
    510  11bf				   SMLEVELX
    511  11bf		       b9 ad f0 	      lda	CharA-1,y	; 4
    512  11c2		       85 6b		      sta	HMCLR	; 3 = 10    @40
    513  11c4		       86 5c		      stx	GRP1	; 3 =	3    @43
    514  11c6		       85 5b		      sta	GRP0	; 3
    515  11c8				   SMLEVEL
    516  11c8		       b9 3f f3 	      lda	OneR-1,y	; 4
    517  11cb		       85 5c		      sta	GRP1	; 3 = 10    @53
    518  11cd
    519  11cd		       88		      dey		; 2
      0  11ce					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  11ce					      LIST	ON
      9  11ce		       d0 d6		      bne	LoopDraw3x2
    521  11d0							;					     @57
      0  11d0					      SLEEP	3	; 3
      1  11d0				   .CYCLES    SET	3
      2  11d0
      3  11d0				  -	      IF	.CYCLES < 2
      4  11d0				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11d0				  -	      ERR
      6  11d0					      ENDIF
      7  11d0
      8  11d0					      IF	.CYCLES & 1
      9  11d0					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11d0		       04 00		      nop	0
     11  11d2				  -	      ELSE
     12  11d2				  -	      bit	VSYNC
     13  11d2					      ENDIF
     14  11d2				   .CYCLES    SET	.CYCLES - 3
     15  11d2					      ENDIF
     16  11d2
     17  11d2				  -	      REPEAT	.CYCLES / 2
     18  11d2				  -	      nop
     19  11d2					      REPEND
    523  11d2		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    524  11d5
    525  11d5
    526  11d5							;------------------------------------------------------------------------------
      0  11d5					      DEFINE_SUBROUTINE	DrawDigits
      1  11d5		       00 02	   BANK_DrawDigits =	_CURRENT_BANK
      2  11d5					      SUBROUTINE
      3  11d5				   DrawDigits
    528  11d5
    529  11d5				   VblankLoopGame
    530  11d5		       ac 84 02 	      ldy	INTIM
    531  11d8		       d0 fb		      bne	VblankLoopGame
    532  11da
    533  11da					      IF	WAIT_FOR_INITIAL_DRAW
    534  11da		       a4 b4		      ldy	blankState
    535  11dc					      ENDIF
    536  11dc		       84 41		      sty	VBLANK	; 3	     <-- 0
    537  11de		       a5 cf		      lda	scoringFlags	; 3
    538  11e0		       29 03		      and	#DISPLAY_FLAGS	; 2
    539  11e2		       aa		      tax		; 2
    540  11e3
    541  11e3							;    DEFINE_SUBROUTINE DrawDigit2
    542  11e3							;
    543  11e3							;    ; Generic interface to scoring routine
    544  11e3
    545  11e3		       bd ee f1 	      lda	ScoreKernelLo,x	; 4
    546  11e6
    547  11e6		       85 42		      sta	WSYNC	; 3
    548  11e8							;---------------------------------------------------------------
    549  11e8		       8d ec f5 	      sta	SMJUMP+1+RAM_WRITE	; 4
    550  11eb				   SMJUMP
    551  11eb		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    552  11ee
    553  11ee				   ScoreKernelLo
    554  11ee		       3b		      .byte.b	<Score2x4Fix	; TARGETs, time
    555  11ef		       00		      .byte.b	<Score1x6Fix	; score
    556  11f0		       9b		      .byte.b	<Score3x2Fix	; player, lives, level
    557  11f1		       00		      .byte.b	<Score1x6Fix	; high score
    558  11f2
      0  11f2					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  11f2					      LIST	ON
    560  11f2
    561  11f2							;------------------------------------------------------------------------------
      0  11f2					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  11f2		       00 02	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  11f2					      SUBROUTINE
      3  11f2				   PrepareDrawDigits
    563  11f2							;					     @13
    564  11f2		       a0 d1		      ldy	#$d1	; 2
    565  11f4		       a9 13		      lda	#%010011	; 2
    566  11f6		       85 66		      sta	VDELP1	; 3 =	7
    567  11f8				   PrepareDrawDigits2		;	    @17/20
    568  11f8		       84 65		      sty	VDELP0	; 3 =	3
    569  11fa
    570  11fa		       85 45		      sta	NUSIZ1	; 3
    571  11fc		       85 44		      sta	NUSIZ0	; 3 =	6
    572  11fe
    573  11fe		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    574  1201		       85 50		      sta	RESP0	; 3	     @33/36
    575  1203		       85 51		      sta	RESP1	; 3 = 10    @36/39
    576  1205
    577  1205		       84 60		      sty	HMP0	; 3
    578  1207		       c8		      iny		; 2
    579  1208		       84 61		      sty	HMP1	; 3 =	8
    580  120a				   SMCOLOR
    581  120a		       a0 9a		      ldy	#SCORE_COL	; 2
    582  120c		       84 46		      sty	COLUP0	; 3
    583  120e		       84 47		      sty	COLUP1	; 3 =	8
    584  1210
    585  1210		       a0 07		      ldy	#DIGIT_H	; 2
    586  1212		       60		      rts		; 6 =	8
    587  1213							; total: 27
    588  1213
    589  1213
    590  1213							;------------------------------------------------------------------------------
      0  1213					      DEFINE_SUBROUTINE	UpdateScore
      1  1213		       00 02	   BANK_UpdateScore =	_CURRENT_BANK
      2  1213					      SUBROUTINE
      3  1213				   UpdateScore
    592  1213							; a = added score value
    593  1213
    594  1213							; initially switch to score:
    595  1213		       a0 01		      ldy	#DISPLAY_SCORE
    596  1215		       84 e2		      sty	newDisplay
    597  1217
    598  1217		       18		      clc
    599  1218		       f8		      sed
    600  1219		       a0 04		      ldy	#SM_OFS_SCORE
    601  121b				   .loopScore
    602  121b		       79 8a f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    603  121e		       99 8a f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    604  1221		       08		      php
    605  1222							; *** bonus life every 500 points: ***
    606  1222							;	  cpy #SM_OFS_SCORE+1
    607  1222							;	  bne .skipBonusLife
    608  1222							;	  tax
    609  1222
    610  1222							;	  and #$0f
    611  1222							;	  beq .bonusLife		      ; 000?
    612  1222							;	  cmp #$05
    613  1222							;	  bne .noBonusLife		      ; 500?
    614  1222							;.bonusLife:
    615  1222							; add extra life, limited to 9
    616  1222
    617  1222							;	  lda ManCount
    618  1222							;	  and #$0f
    619  1222							;	  cmp #9
    620  1222							;	  bcs .noBonusLife
    621  1222							;	  inc ManCount
    622  1222
    623  1222							; bonus life has priority over score:
    624  1222							;	  lda #DISPLAY_LIVES
    625  1222							;	  sta newDisplay
    626  1222							;lda #EXTRA_LIFE_TIMER
    627  1222							;sta extraLifeTimer
    628  1222
    629  1222				   .noBonusLife
    630  1222		       8a		      txa
    631  1223				   .skipBonusLife
    632  1223		       20 cc f2 	      jsr	SetupBCDPtr
    633  1226		       28		      plp
    634  1227		       a9 00		      lda	#0
    635  1229		       b0 f0		      bcs	.loopScore
    636  122b		       d8		      cld
    637  122c
    638  122c							; switch display
    639  122c		       a5 cf		      lda	scoringFlags
    640  122e		       29 03		      and	#DISPLAY_FLAGS
    641  1230		       c5 e2		      cmp	newDisplay	; lower priority than current?
    642  1232		       f0 08		      beq	.restartTime
    643  1234		       b0 0a		      bcs	.skipNew
    644  1236		       45 cf		      eor	scoringFlags	; remove existing score mode
    645  1238		       05 e2		      ora	newDisplay	; switch to new score mode
    646  123a		       85 cf		      sta	scoringFlags
    647  123c				   .restartTime
    648  123c		       a9 3c		      lda	#SCORING_TIMER	; maybe always restart timer?
    649  123e		       85 ce		      sta	scoringTimer
    650  1240				   .skipNew
    651  1240
    652  1240		       60		      rts
    653  1241
    654  1241							;---------------------------------------------------------------------------
    655  1241
      0  1241					      DEFINE_SUBROUTINE	SwapPlayers
      1  1241		       00 02	   BANK_SwapPlayers =	_CURRENT_BANK
      2  1241					      SUBROUTINE
      3  1241				   SwapPlayers
    657  1241
    658  1241							; assume no new high score:
    659  1241		       a0 ff		      ldy	#-1
    660  1243		       84 e5		      sty	highScoreSK
    661  1245
    662  1245							; update highscore after last live:
    663  1245							;lda ManCount
    664  1245							;and #$0f			      ; player has lives left?
    665  1245							;bne .playerAlive		      ; YES, so we don't check high score
    666  1245
    667  1245							; check for a new high score:
    668  1245							;	  ldy #-1
    669  1245		       18		      clc		; score has to be at least 1 bigger!
    670  1246				   .loopCheckHighScore
    671  1246		       c8		      iny
    672  1247		       b9 8e f3 	      lda	ScoreCurrent,y
    673  124a		       f9 98 f3 	      sbc	HighScore,y
    674  124d		       98		      tya
    675  124e		       49 02		      eor	#2
    676  1250		       d0 f4		      bne	.loopCheckHighScore
    677  1252		       90 0d		      bcc	.noHighScore
    678  1254
    679  1254							; new high score, update:
    680  1254		       a2 04		      ldx	#5-1
    681  1256				   .loopSetHighScore
    682  1256		       bd 8e f3 	      lda	ScoreCurrent,x
    683  1259		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
    684  125c		       95 e5		      sta	highScoreSK,x
    685  125e		       ca		      dex
    686  125f		       10 f5		      bpl	.loopSetHighScore
    687  1261				   .noHighScore
    688  1261
    689  1261				   .playerAlive
    690  1261							;lda ManCount
    691  1261							;and #$f0			      ; other player has lives left?
    692  1261							;beq .otherPlayerDead		      ; NO, so we don't swap scores
    693  1261
    694  1261							; save the current player variables to the player's backup:
    695  1261		       a0 02		      ldy	#3-1
    696  1263				   .swapScore
    697  1263		       be 93 f3 	      ldx	PlayerScores,y
    698  1266		       b9 8e f3 	      lda	ScoreCurrent,y
    699  1269		       99 93 f7 	      sta	PlayerScores+RAM_WRITE,y
    700  126c		       8a		      txa
    701  126d		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
    702  1270		       88		      dey
    703  1271		       10 f0		      bpl	.swapScore
    704  1273
    705  1273							; swap levelx and level:
    706  1273		       a2 01		      ldx	#1
    707  1275				   .loopLevelXLevel
    708  1275		       bc 96 f3 	      ldy	PlayerLevelX,x
    709  1278		       b5 b8		      lda	levelX,x
    710  127a		       9d 96 f7 	      sta	PlayerLevelX+RAM_WRITE,x
    711  127d		       94 b8		      sty	levelX,x
    712  127f		       ca		      dex
    713  1280		       10 f3		      bpl	.loopLevelXLevel
    714  1282
    715  1282				   .otherPlayerDead
    716  1282		       60		      rts
    717  1283
    718  1283							;---------------------------------------------------------------------------
    719  1283
    720  1283				   HighScoreColTbl
    721  1283		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    722  1285		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    723  1287
      0  1287					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  1287		       00 02	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  1287					      SUBROUTINE
      3  1287				   GeneralScoringSetups
    725  1287
    726  1287		       a0 04		      ldy	#SM_OFS_SCORE
    727  1289				   .loopScore2
    728  1289		       a5 cf		      lda	scoringFlags
    729  128b		       29 03		      and	#DISPLAY_FLAGS
    730  128d		       c9 03		      cmp	#DISPLAY_HIGH
    731  128f		       a6 81		      ldx	Platform
    732  1291		       bd 83 f2 	      lda	HighScoreColTbl,x
    733  1294		       aa		      tax
    734  1295		       b9 94 f3 	      lda	HighScore-SM_OFS_SCORE,y
    735  1298		       b0 05		      bcs	.showHighScore
    736  129a		       a2 9a		      ldx	#SCORE_COL
    737  129c		       b9 8a f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    738  129f				   .showHighScore
    739  129f		       8e 0b f6 	      stx	SMCOLOR+1+RAM_WRITE
    740  12a2		       20 cc f2 	      jsr	SetupBCDPtr
    741  12a5		       c0 07		      cpy	#SM_OFS_SCORE+3
    742  12a7		       90 e0		      bcc	.loopScore2
    743  12a9
    744  12a9							; display number of lives in leftmost digit of middle score XX nX XX
    745  12a9
    746  12a9							;lda ManCount
    747  12a9							;and #$0f
    748  12a9							;tay
    749  12a9							;lda DigitVectorLOr,y
    750  12a9							;sta SMMEN+1+RAM_WRITE
    751  12a9
    752  12a9							; modify player number pointer (Xp XX XX)
    753  12a9
    754  12a9							;ldy whichPlayer
    755  12a9							;lda DigitVectorLOr+1,y
    756  12a9							;sta SMPLAYER+1+RAM_WRITE
    757  12a9
    758  12a9							; fall through
    759  12a9
    760  12a9							;    ;---------------------------------------------------------------------------
    761  12a9
    762  12a9							; modify levelx character pointer (XX XX cX)
    763  12a9
    764  12a9							;ldx #<charPlace-1
    765  12a9							;lda levelDisplay
    766  12a9							;cmp #$80
    767  12a9							;and #$1f
    768  12a9							;tay
    769  12a9							;bcs .intermission
    770  12a9							;ldx CharVectorLO,y
    771  12a9							;ldy level
    772  12a9							;.intermission
    773  12a9							;stx SMLEVELX+1+RAM_WRITE
    774  12a9
    775  12a9							; modify level number pointer (XX XX Xl)
    776  12a9
    777  12a9							;lda DigitVectorLOr+1,y
    778  12a9							;sta SMLEVEL+1+RAM_WRITE
    779  12a9
    780  12a9							;---------------------------------------------------------------------------
    781  12a9
    782  12a9		       4c c3 f2 	      jmp	SetupTimePtr	; modify time pointers
    783  12ac
    784  12ac							;------------------------------------------------------------------------------
    785  12ac							;    DEFINE_SUBROUTINE SetupGameOverPtr
    786  12ac
    787  12ac							;		  ldy #8-1
    788  12ac							;.loopGameOver:
    789  12ac							;		  ldx SMGameOverOfs,y
    790  12ac							;		  lda SMGameOverPtr,y
    791  12ac							;		  sta SM_BASE+1+RAM_WRITE,x
    792  12ac							;		  dey
    793  12ac							;		  bpl .loopGameOver
    794  12ac
    795  12ac							;		  rts
    796  12ac
    797  12ac							;SMGameOverOfs:
    798  12ac							;		  .byte <SM_TARGET3-SM_BASE, <SM_TARGET2-SM_BASE
    799  12ac							;		  .byte <SM_TARGET1-SM_BASE, <SM_TARGET0-SM_BASE
    800  12ac							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    801  12ac							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    802  12ac							;SMGameOverPtr:
    803  12ac							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    804  12ac							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    805  12ac
    806  12ac							;------------------------------------------------------------------------------
    807  12ac
      0  12ac					      DEFINE_SUBROUTINE	DrawBCD_targetsRequired
      1  12ac		       00 02	   BANK_DrawBCD_targetsRequired =	_CURRENT_BANK
      2  12ac					      SUBROUTINE
      3  12ac				   DrawBCD_targetsRequired
    809  12ac							; Show current TARGET counter in the top left
    810  12ac
    811  12ac		       a0 00		      ldy	#SM_OFS_TARGETS
    812  12ae		       a5 bd		      lda	BCD_targetsRequired
    813  12b0		       20 cc f2 	      jsr	SetupBCDPtr
    814  12b3
    815  12b3		       a9 b0		      lda	#ID_TARGET<<4	; if no extra targets, display the normal icon
    816  12b5		       24 cf		      bit	scoringFlags	;
    817  12b7		       10 13		      bpl	SetupBCDPtr
    818  12b9		       a9 c0		      lda	#ID_EXTRA<<4	; otherwise, display the extra icon
    819  12bb		       50 0f		      bvc	SetupBCDPtr
    820  12bd		       09 01		      ora	#1	; display 1xx targets
    821  12bf		       d0 0b		      bne	SetupBCDPtr	; unconditional
    822  12c1
    823  12c1							;------------------------------------------------------------------------------
      0  12c1					      DEFINE_SUBROUTINE	DrawTime
      1  12c1		       00 02	   BANK_DrawTime =	_CURRENT_BANK
      2  12c1					      SUBROUTINE
      3  12c1				   DrawTime
    825  12c1
    826  12c1							; mid-digit-change, but we may be required to flash/display
    827  12c1		       a0 02		      ldy	#SM_OFS_TIME
    828  12c3							;------------------------------------------------------------------------------
      0  12c3					      DEFINE_SUBROUTINE	SetupTimePtr
      1  12c3		       00 02	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  12c3					      SUBROUTINE
      3  12c3				   SetupTimePtr
    830  12c3
    831  12c3		       a5 be		      lda	BCD_moveCounter
    832  12c5		       20 cc f2 	      jsr	SetupBCDPtr
    833  12c8		       a5 bf		      lda	BCD_moveCounter+1
    834  12ca		       09 d0		      ora	#ID_CLOCK<<4
    835  12cc
    836  12cc							; fall through
    837  12cc
    838  12cc							;------------------------------------------------------------------------------
      0  12cc					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  12cc		       00 02	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  12cc					      SUBROUTINE
      3  12cc				   SetupBCDPtr
    840  12cc
    841  12cc							; a = BCD value
    842  12cc							; y = SM table offset
    843  12cc
    844  12cc		       48		      pha
    845  12cd		       29 0f		      and	#$0f
    846  12cf		       aa		      tax
    847  12d0		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    848  12d3		       be 19 f0 	      ldx	SMTblLSB,y
    849  12d6		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    850  12d9		       68		      pla
    851  12da		       4a		      lsr
    852  12db		       4a		      lsr
    853  12dc		       4a		      lsr
    854  12dd		       4a		      lsr
    855  12de		       aa		      tax
    856  12df		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    857  12e2		       be 20 f0 	      ldx	SMTblMSB,y
    858  12e5		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    859  12e8
    860  12e8		       c8		      iny
    861  12e9
    862  12e9		       a5 c9		      lda	ROM_Bank
    863  12eb				   RTS
    864  12eb		       60		      rts
    865  12ec
      0  12ec					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
 PAGE BREAK INSERTED FOR  LeftDigits
 REQUESTED SIZE =  $5b
 WASTED SPACE =  $14
 PAGEBREAK LOCATION =  $f300
     10  1300					      LIST	ON
    867  1300
    868  1300					      IF	<. = 0
    869  1300		       00		      .byte.b	0	; required!
    870  1301					      ENDIF
    871  1301
    872  1301				   BLANKR
    873  1301		       00 00 00 00*	      .ds	DIGIT_H, 0
    874  1308
    875  1308				   DequalsR
    876  1308		       00		      .byte.b	%00000000
    877  1309		       00		      .byte.b	%00000000
    878  130a		       f0		      .byte.b	%11110000
    879  130b		       00		      .byte.b	%00000000
    880  130c		       f0		      .byte.b	%11110000
    881  130d		       00		      .byte.b	%00000000
    882  130e		       f0		      .byte.b	%11110000
    883  130f				   DplusR
    884  130f		       10		      .byte.b	%00010000
    885  1310		       28		      .byte.b	%00101000
    886  1311		       6c		      .byte.b	%01101100
    887  1312		       c6		      .byte.b	%11000110
    888  1313		       6c		      .byte.b	%01101100
    889  1314		       28		      .byte.b	%00101000
    890  1315		       10		      .byte.b	%00010000
    891  1316
    892  1316				   ClockR
    893  1316		       00		      .byte.b	%00000000
    894  1317		       48		      .byte.b	%01001000
    895  1318		       fc		      .byte.b	%11111100
    896  1319		       48		      .byte.b	%01001000
    897  131a		       48		      .byte.b	%01001000
    898  131b		       fc		      .byte.b	%11111100
    899  131c		       48		      .byte.b	%01001000
    900  131d				   NineR
    901  131d		       0f		      .byte.b	%00001111
    902  131e		       01		      .byte.b	%00000001
    903  131f		       01		      .byte.b	%00000001
    904  1320		       7f		      .byte.b	%01111111
    905  1321		       41		      .byte.b	%01000001
    906  1322		       41		      .byte.b	%01000001
    907  1323		       7f		      .byte.b	%01111111
    908  1324				   SixR
    909  1324		       7f		      .byte.b	%01111111
    910  1325		       41		      .byte.b	%01000001
    911  1326		       41		      .byte.b	%01000001
    912  1327		       7f		      .byte.b	%01111111
    913  1328		       40		      .byte.b	%01000000
    914  1329		       40		      .byte.b	%01000000
    915  132a		       78		      .byte.b	%01111000
    916  132b				   EightR
    917  132b							;  .byte %00111110
    918  132b							;  .byte %01000011
    919  132b							;  .byte %01000011
    920  132b							;  .byte %00111110
    921  132b							;  .byte %00100011
    922  132b							;  .byte %00100011
    923  132b							;  .byte %00011110
    924  132b
    925  132b
    926  132b		       7f		      .byte.b	%01111111
    927  132c		       41		      .byte.b	%01000001
    928  132d		       41		      .byte.b	%01000001
    929  132e		       7f		      .byte.b	%01111111
    930  132f		       41		      .byte.b	%01000001
    931  1330		       41		      .byte.b	%01000001
    932  1331		       7f		      .byte.b	%01111111
    933  1332
    934  1332				   ZeroR
    935  1332		       7f		      .byte.b	%01111111
    936  1333		       41		      .byte.b	%01000001
    937  1334		       41		      .byte.b	%01000001
    938  1335		       41		      .byte.b	%01000001
    939  1336		       41		      .byte.b	%01000001
    940  1337		       41		      .byte.b	%01000001
    941  1338		       7f		      .byte.b	%01111111
    942  1339
    943  1339							;	  .byte %00111110
    944  1339							;	  .byte %01000011
    945  1339							;	  .byte %01000011
    946  1339							;	  .byte %01000011
    947  1339							;	  .byte %01000011
    948  1339							;	  .byte %00100011
    949  1339							;	  .byte %00011110
    950  1339				   ThreeR
    951  1339		       7f		      .byte.b	%01111111
    952  133a		       01		      .byte.b	%00000001
    953  133b		       01		      .byte.b	%00000001
    954  133c		       0f		      .byte.b	%00001111
    955  133d		       01		      .byte.b	%00000001
    956  133e		       01		      .byte.b	%00000001
    957  133f		       7f		      .byte.b	%01111111
    958  1340				   OneR
    959  1340		       08		      .byte.b	%00001000
    960  1341		       08		      .byte.b	%00001000
    961  1342		       08		      .byte.b	%00001000
    962  1343		       08		      .byte.b	%00001000
    963  1344		       08		      .byte.b	%00001000
    964  1345		       08		      .byte.b	%00001000
    965  1346		       08		      .byte.b	%00001000
    966  1347
    967  1347				   SevenR
    968  1347		       08		      .byte.b	%00001000
    969  1348		       08		      .byte.b	%00001000
    970  1349		       08		      .byte.b	%00001000
    971  134a		       0f		      .byte.b	%00001111
    972  134b		       01		      .byte.b	%00000001
    973  134c		       01		      .byte.b	%00000001
    974  134d		       7f		      .byte.b	%01111111
    975  134e
    976  134e				   TwoR
    977  134e		       7f		      .byte.b	%01111111
    978  134f		       40		      .byte.b	%01000000
    979  1350		       40		      .byte.b	%01000000
    980  1351		       7f		      .byte.b	%01111111
    981  1352		       01		      .byte.b	%00000001
    982  1353		       01		      .byte.b	%00000001
    983  1354		       7f		      .byte.b	%01111111
    984  1355				   FiveR
    985  1355		       7f		      .byte.b	%01111111
    986  1356		       01		      .byte.b	%00000001
    987  1357		       01		      .byte.b	%00000001
    988  1358		       7f		      .byte.b	%01111111
    989  1359		       40		      .byte.b	%01000000
    990  135a		       40		      .byte.b	%01000000
    991  135b		       78		      .byte.b	%01111000
    992  135c				   FourR
    993  135c		       08		      .byte.b	%00001000
    994  135d		       08		      .byte.b	%00001000
    995  135e		       08		      .byte.b	%00001000
    996  135f		       7f		      .byte.b	%01111111
    997  1360		       48		      .byte.b	%01001000
    998  1361		       48		      .byte.b	%01001000
    999  1362		       48		      .byte.b	%01001000
   1000  1363
   1001  1363							;CharAL:
   1002  1363							;    .byte %11100110
   1003  1363							;    .byte %11100110
   1004  1363							;    .byte %11111110
   1005  1363							;    .byte %11100110
   1006  1363							;    .byte %11100110
   1007  1363							;    .byte %01111100
   1008  1363							;    .byte %00111000
   1009  1363							;CharEL:
   1010  1363							;    .byte %11111110
   1011  1363							;    .byte %11111110
   1012  1363							;    .byte %11100000
   1013  1363							;    .byte %11100000
   1014  1363							;    .byte %11111100
   1015  1363							;    .byte %11100000
   1016  1363							;    .byte %11111110
   1017  1363							;CharRL:
   1018  1363							;    .byte %11100110
   1019  1363							;    .byte %11100110
   1020  1363							;    .byte %11111100
   1021  1363							;    .byte %11111100
   1022  1363							;    .byte %11100110
   1023  1363							;    .byte %11100110
   1024  1363							;    .byte %11111100
   1025  1363							;CharVL:
   1026  1363							;    .byte %00111000
   1027  1363							;    .byte %01111100
   1028  1363							;    .byte %11100110
   1029  1363							;    .byte %11100110
   1030  1363							;    .byte %11100110
   1031  1363							;    .byte %11100110
   1032  1363							;    .byte %11100110
   1033  1363
      0  1363					      CHECKPAGE	BLANKR
      8  1363					      LIST	ON
   1035  1363
   1036  1363							;---------------------------------------------------------------------------
   1037  1363
      0  1363					      DEFINE_SUBROUTINE	GameInitialise
      1  1363		       00 02	   BANK_GameInitialise =	_CURRENT_BANK
      2  1363					      SUBROUTINE
      3  1363				   GameInitialise
   1039  1363
   1040  1363							; copy loaded SK high score into scoring RAM:
   1041  1363		       a2 02		      ldx	#3-1
   1042  1365				   .loopCopyHighScore
   1043  1365		       b5 e5		      lda	highScoreSK,x
   1044  1367		       c9 ff		      cmp	#$ff
   1045  1369		       f0 06		      beq	.noSaveKey
   1046  136b		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
   1047  136e		       ca		      dex
   1048  136f		       10 f4		      bpl	.loopCopyHighScore
   1049  1371				   .noSaveKey
   1050  1371
   1051  1371							; clear both players scores
   1052  1371		       a0 05		      ldy	#2*3-1
   1053  1373		       a9 00		      lda	#0
   1054  1375				   .loopClearScore
   1055  1375		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
   1056  1378		       88		      dey
   1057  1379		       10 fa		      bpl	.loopClearScore
   1058  137b
   1059  137b							; copy levelX and level for other player and SaveKey:
   1060  137b		       a5 b8		      lda	levelX
   1061  137d		       8d 96 f7 	      sta	PlayerLevelX+RAM_WRITE
   1062  1380		       a5 e8		      lda	startingLevel
   1063  1382		       8d 91 f7 	      sta	StartLevelX+RAM_WRITE
   1064  1385		       a5 b9		      lda	level
   1065  1387		       8d 97 f7 	      sta	PlayerLevel+RAM_WRITE
   1066  138a		       8d 92 f7 	      sta	StartLevel+RAM_WRITE
   1067  138d		       60		      rts
   1068  138e
   1069  138e							;---------------------------------------------------------------------------
   1070  138e
   1071  138e		       00 00 00    ScoreCurrent ds	3, 0
   1072  1391							; start levelx and level have to be after ScoreCurrent!
   1073  1391		       00	   StartLevelX .byte.b	0
   1074  1392		       00	   StartLevel .byte.b	0
   1075  1393		       00 00 00    PlayerScores ds	3, 0
   1076  1396							; levelx and level have to be consecutive variables!
   1077  1396		       00	   PlayerLevelX .byte.b	0
   1078  1397		       00	   PlayerLevel .byte.b	0
   1079  1398		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1080  139d
   1081  139d
   1082  139d
   1083  139d							;------------------------------------------------------------------------------
   1084  139d
      0  139d					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  139d
      2  139d
      3  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $39d , FREE= $63
      4  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  139d				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  139d				  -	      ERR
      8  139d					      endif
   1086  139d
   1087  139d							;------------------------------------------------------------------------------
   1088  139d
   1089  139d							; LEVEL DATA banks can go anywhere - *EXCEPT* for the same bank as the level
   1090  139d							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_LEVEL_SIZE
   1091  139d							; which is used as a buffer size inside UnpackLevel.  It's not important if
   1092  139d							; this is defined before or after, as once the levels have processed it will be
   1093  139d							; correct. Note, that levels should all be defined BEFORE *OR* AFTER the
   1094  139d							; UnpackLevel code -- but that they should not be both, nor in the same bank.
   1095  139d							; TODO: verify above is still valid
   1096  139d
   1097  139d
      0  139d					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $39d , FREE= $463
      2  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  139d				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  139d				  -	      ERR
      6  139d					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 4
      0  139d					      include	"BANK_GENERIC.asm"
      1  139d							;    Sokoboo - a Sokoban implementation
      2  139d							;    using a generic tile-based display engine for the Atari 2600
      3  139d							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  139d							;
      5  139d							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  139d							;
      7  139d							;    Code related to the generic tile-based display engine was developed by
      8  139d							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  139d							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  139d							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  139d							;
     12  139d							;    Code related to music and sound effects uses the TIATracker music player
     13  139d							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  139d							;    directory for Apache licensing details.
     15  139d							;
     16  139d							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  139d							;    See the copyright notices in the License directory for a list of level
     18  139d							;    contributors.
     19  139d							;
     20  139d							;    Except where otherwise indicated, this software is released under the
     21  139d							;    following licensing arrangement...
     22  139d							;
     23  139d							;    This program is free software: you can redistribute it and/or modify
     24  139d							;    it under the terms of the GNU General Public License as published by
     25  139d							;    the Free Software Foundation, either version 3 of the License, or
     26  139d							;    (at your option) any later version.
     27  139d							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  139d
     29  139d							;    This program is distributed in the hope that it will be useful,
     30  139d							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  139d							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  139d							;    GNU General Public License for more details.
     33  139d
     34  139d							;------------------------------------------------------------------------------
     35  139d							;##############################################################################
     36  139d							;------------------------------------------------------------------------------
     37  139d
      0  139d					      NEWBANK	GENERIC_BANK_1
      1  1f1e ????				      SEG	GENERIC_BANK_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	GENERIC_BANK_1
     39  1800
     40  1800
     41  1800
      0  1800					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  1800					      ALIGN	$400
      2  1800				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  1800				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
------- FILE DecodeLevel.asm LEVEL 3 PASS 4
      0  1800					      include	"DecodeLevel.asm"
      1  1800							;    Sokoboo - a Sokoban implementation
      2  1800							;    using a generic tile-based display engine for the Atari 2600
      3  1800							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1800							;
      5  1800							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1800							;
      7  1800							;    Code related to the generic tile-based display engine was developed by
      8  1800							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1800							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1800							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1800							;
     12  1800							;    Code related to music and sound effects uses the TIATracker music player
     13  1800							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1800							;    directory for Apache licensing details.
     15  1800							;
     16  1800							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1800							;    See the copyright notices in the License directory for a list of level
     18  1800							;    contributors.
     19  1800							;
     20  1800							;    Except where otherwise indicated, this software is released under the
     21  1800							;    following licensing arrangement...
     22  1800							;
     23  1800							;    This program is free software: you can redistribute it and/or modify
     24  1800							;    it under the terms of the GNU General Public License as published by
     25  1800							;    the Free Software Foundation, either version 3 of the License, or
     26  1800							;    (at your option) any later version.
     27  1800							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1800
     29  1800							;    This program is distributed in the hope that it will be useful,
     30  1800							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1800							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1800							;    GNU General Public License for more details.
     33  1800
     34  1800							; The ordering here corresponds to the ordering when playing...
     35  1800
     36  1800				   LevelInfoLO
     37  1800		       ff		      .byte.b	<(LEVEL__001_L-1)
     38  1801		       11		      .byte.b	<(LEVEL__001_R-1)
     39  1802		       1d		      .byte.b	<(LEVEL__002_L-1)
     40  1803		       36		      .byte.b	<(LEVEL__002_R-1)
     41  1804		       5e		      .byte.b	<(LEVEL__003_L-1)
     42  1805		       8a		      .byte.b	<(LEVEL__003_R-1)
     43  1806		       b4		      .byte.b	<(LEVEL__004_L-1)
     44  1807		       d7		      .byte.b	<(LEVEL__004_R-1)
     45  1808		       f3		      .byte.b	<(LEVEL__005_L-1)
     46  1809		       25		      .byte.b	<(LEVEL__005_R-1)
     47  180a		       64		      .byte.b	<(LEVEL__006_L-1)
     48  180b		       9f		      .byte.b	<(LEVEL__006_R-1)
     49  180c		       dd		      .byte.b	<(LEVEL__007_L-1)
     50  180d		       0a		      .byte.b	<(LEVEL__007_R-1)
     51  180e		       3d		      .byte.b	<(LEVEL__008_L-1)
     52  180f		       73		      .byte.b	<(LEVEL__008_R-1)
     53  1810		       a4		      .byte.b	<(LEVEL__009_L-1)
     54  1811		       d6		      .byte.b	<(LEVEL__009_R-1)
     55  1812		       06		      .byte.b	<(LEVEL__010_L-1)
     56  1813		       40		      .byte.b	<(LEVEL__010_R-1)
     57  1814		       73		      .byte.b	<(LEVEL__011_L-1)
     58  1815		       a6		      .byte.b	<(LEVEL__011_R-1)
     59  1816		       e0		      .byte.b	<(LEVEL__012_L-1)
     60  1817		       10		      .byte.b	<(LEVEL__012_R-1)
     61  1818		       4c		      .byte.b	<(LEVEL__013_L-1)
     62  1819		       8b		      .byte.b	<(LEVEL__013_R-1)
     63  181a		       be		      .byte.b	<(LEVEL__014_L-1)
     64  181b		       01		      .byte.b	<(LEVEL__014_R-1)
     65  181c		       44		      .byte.b	<(LEVEL__015_L-1)
     66  181d		       79		      .byte.b	<(LEVEL__015_R-1)
     67  181e		       be		      .byte.b	<(LEVEL__016_L-1)
     68  181f		       f5		      .byte.b	<(LEVEL__016_R-1)
     69  1820		       28		      .byte.b	<(LEVEL__017_L-1)
     70  1821		       72		      .byte.b	<(LEVEL__017_R-1)
     71  1822		       b5		      .byte.b	<(LEVEL__018_L-1)
     72  1823		       e9		      .byte.b	<(LEVEL__018_R-1)
     73  1824		       25		      .byte.b	<(LEVEL__019_L-1)
     74  1825		       60		      .byte.b	<(LEVEL__019_R-1)
     75  1826		       ff		      .byte.b	<(LEVEL__020_L-1)
     76  1827		       3e		      .byte.b	<(LEVEL__020_R-1)
     77  1828		       7e		      .byte.b	<(LEVEL__021_L-1)
     78  1829		       d4		      .byte.b	<(LEVEL__021_R-1)
     79  182a		       08		      .byte.b	<(LEVEL__022_L-1)
     80  182b		       4e		      .byte.b	<(LEVEL__022_R-1)
     81  182c		       8a		      .byte.b	<(LEVEL__023_L-1)
     82  182d		       cb		      .byte.b	<(LEVEL__023_R-1)
     83  182e		       0d		      .byte.b	<(LEVEL__024_L-1)
     84  182f		       5d		      .byte.b	<(LEVEL__024_R-1)
     85  1830		       a5		      .byte.b	<(LEVEL__025_L-1)
     86  1831		       e8		      .byte.b	<(LEVEL__025_R-1)
     87  1832		       27		      .byte.b	<(LEVEL__026_L-1)
     88  1833		       60		      .byte.b	<(LEVEL__026_R-1)
     89  1834		       a1		      .byte.b	<(LEVEL__027_L-1)
     90  1835		       df		      .byte.b	<(LEVEL__027_R-1)
     91  1836		       1d		      .byte.b	<(LEVEL__028_L-1)
     92  1837		       69		      .byte.b	<(LEVEL__028_R-1)
     93  1838		       b7		      .byte.b	<(LEVEL__029_L-1)
     94  1839		       fc		      .byte.b	<(LEVEL__029_R-1)
     95  183a		       40		      .byte.b	<(LEVEL__030_L-1)
     96  183b		       90		      .byte.b	<(LEVEL__030_R-1)
     97  183c		       e3		      .byte.b	<(LEVEL__031_L-1)
     98  183d		       29		      .byte.b	<(LEVEL__031_R-1)
     99  183e		       68		      .byte.b	<(LEVEL__032_L-1)
    100  183f		       a0		      .byte.b	<(LEVEL__032_R-1)
    101  1840		       e4		      .byte.b	<(LEVEL__033_L-1)
    102  1841		       2e		      .byte.b	<(LEVEL__033_R-1)
    103  1842		       6e		      .byte.b	<(LEVEL__034_L-1)
    104  1843		       ff		      .byte.b	<(LEVEL__034_R-1)
    105  1844		       48		      .byte.b	<(LEVEL__035_L-1)
    106  1845		       8d		      .byte.b	<(LEVEL__035_R-1)
    107  1846		       cd		      .byte.b	<(LEVEL__036_L-1)
    108  1847		       03		      .byte.b	<(LEVEL__036_R-1)
    109  1848		       49		      .byte.b	<(LEVEL__037_L-1)
    110  1849		       86		      .byte.b	<(LEVEL__037_R-1)
    111  184a		       cf		      .byte.b	<(LEVEL__038_L-1)
    112  184b		       17		      .byte.b	<(LEVEL__038_R-1)
    113  184c		       66		      .byte.b	<(LEVEL__039_L-1)
    114  184d		       b5		      .byte.b	<(LEVEL__039_R-1)
    115  184e		       0f		      .byte.b	<(LEVEL__040_L-1)
    116  184f		       56		      .byte.b	<(LEVEL__040_R-1)
    117  1850
    118  1850		       9d		      .byte.b	<(LEVEL__041_L-1)
    119  1851		       e7		      .byte.b	<(LEVEL__041_R-1)
    120  1852		       2e		      .byte.b	<(LEVEL__042_L-1)
    121  1853		       7c		      .byte.b	<(LEVEL__042_R-1)
    122  1854		       d4		      .byte.b	<(LEVEL__043_L-1)
    123  1855		       21		      .byte.b	<(LEVEL__043_R-1)
    124  1856		       6d		      .byte.b	<(LEVEL__044_L-1)
    125  1857		       a5		      .byte.b	<(LEVEL__044_R-1)
    126  1858		       f5		      .byte.b	<(LEVEL__045_L-1)
    127  1859		       43		      .byte.b	<(LEVEL__045_R-1)
    128  185a		       8d		      .byte.b	<(LEVEL__046_L-1)
    129  185b		       da		      .byte.b	<(LEVEL__046_R-1)
    130  185c		       1f		      .byte.b	<(LEVEL__047_L-1)
    131  185d		       75		      .byte.b	<(LEVEL__047_R-1)
    132  185e		       ff		      .byte.b	<(LEVEL__048_L-1)
    133  185f		       4b		      .byte.b	<(LEVEL__048_R-1)
    134  1860		       96		      .byte.b	<(LEVEL__049_L-1)
    135  1861		       e8		      .byte.b	<(LEVEL__049_R-1)
    136  1862
    137  1862		       2b		      .byte.b	<(LEVEL__050_L-1)
    138  1863		       78		      .byte.b	<(LEVEL__050_R-1)
    139  1864		       b1		      .byte.b	<(LEVEL__051_L-1)
    140  1865		       04		      .byte.b	<(LEVEL__051_R-1)
    141  1866		       55		      .byte.b	<(LEVEL__052_L-1)
    142  1867		       8f		      .byte.b	<(LEVEL__052_R-1)
    143  1868		       d7		      .byte.b	<(LEVEL__053_L-1)
    144  1869		       2c		      .byte.b	<(LEVEL__053_R-1)
    145  186a		       79		      .byte.b	<(LEVEL__054_L-1)
    146  186b		       c5		      .byte.b	<(LEVEL__054_R-1)
    147  186c		       0e		      .byte.b	<(LEVEL__055_L-1)
    148  186d		       68		      .byte.b	<(LEVEL__055_R-1)
    149  186e		       bd		      .byte.b	<(LEVEL__056_L-1)
    150  186f		       17		      .byte.b	<(LEVEL__056_R-1)
    151  1870		       72		      .byte.b	<(LEVEL__057_L-1)
    152  1871		       c8		      .byte.b	<(LEVEL__057_R-1)
    153  1872		       11		      .byte.b	<(LEVEL__058_L-1)
    154  1873		       56		      .byte.b	<(LEVEL__058_R-1)
    155  1874		       a6		      .byte.b	<(LEVEL__059_L-1)
    156  1875		       f8		      .byte.b	<(LEVEL__059_R-1)
    157  1876
    158  1876		       ff		      .byte.b	<(LEVEL__060_R-1)
    159  1877		       9b		      .byte.b	<(LEVEL__061_R-1)
    160  1878		       47		      .byte.b	<(LEVEL__061_L-1)
    161  1879		       e4		      .byte.b	<(LEVEL__062_L-1)
    162  187a		       3b		      .byte.b	<(LEVEL__062_R-1)
    163  187b		       87		      .byte.b	<(LEVEL__063_L-1)
    164  187c		       d7		      .byte.b	<(LEVEL__063_R-1)
    165  187d		       84		      .byte.b	<(LEVEL__064_R-1)
    166  187e		       29		      .byte.b	<(LEVEL__064_L-1)
    167  187f		       28		      .byte.b	<(LEVEL__065_R-1)
    168  1880		       d0		      .byte.b	<(LEVEL__065_L-1)
    169  1881		       ca		      .byte.b	<(LEVEL__066_R-1)
    170  1882		       70		      .byte.b	<(LEVEL__066_L-1)
    171  1883		       6d		      .byte.b	<(LEVEL__067_R-1)
    172  1884		       20		      .byte.b	<(LEVEL__067_L-1)
    173  1885		       26		      .byte.b	<(LEVEL__068_R-1)
    174  1886		       d2		      .byte.b	<(LEVEL__068_L-1)
    175  1887		       ca		      .byte.b	<(LEVEL__069_R-1)
    176  1888		       7c		      .byte.b	<(LEVEL__069_L-1)
    177  1889
    178  1889		       e8		      .byte.b	<(LEVEL__103_Arielle-1)
    179  188a		       a1		      .byte.b	<(LEVEL__103_Ajalae-1)
    180  188b		       56		      .byte.b	<(LEVEL__103_Adin-1)
    181  188c		       e8		      .byte.b	<(LEVEL__102_Raven-1)
    182  188d		       a4		      .byte.b	<(LEVEL__102_Oralia-1)
    183  188e		       ff		      .byte.b	<(LEVEL__102_Natalie-1)
    184  188f		       45		      .byte.b	<(LEVEL__102_Mirabel-1)
    185  1890		       38		      .byte.b	<(LEVEL__1XJH_Tara_Gelson-1)
    186  1891		       72		      .byte.b	<(LEVEL__1R7X_Alison-1)
    187  1892		       9f		      .byte.b	<(LEVEL__1KWD_Cecile_Clayworth-1)
    188  1893		       d3		      .byte.b	<(LEVEL__1EKT_Samantha_Gelson-1)
    189  1894		       0c		      .byte.b	<(LEVEL__0VM5_Andrea_Wadd-1)
    190  1895		       39		      .byte.b	<(LEVEL__0PAL_Jill_Leatherby-1)
    191  1896		       63		      .byte.b	<(LEVEL__0IZ1_Sophia-1)
    192  1897		       8e		      .byte.b	<(LEVEL__0CNH_Alice-1)
    193  1898		       18		      .byte.b	<(LEVEL__122_Maya-1)
    194  1899
    195  1899		       00 99	   MAX_LEVEL  =	* - LevelInfoLO
 $99 LEVELS INSTALLED
    196  1899					      ECHO	MAX_LEVEL, "LEVELS INSTALLED"
    197  1899				   LevelInfoHI
    198  1899
    199  1899		       ef		      .byte.b	>(LEVEL__001_L-1)
    200  189a		       f0		      .byte.b	>(LEVEL__001_R-1)
    201  189b		       f0		      .byte.b	>(LEVEL__002_L-1)
    202  189c		       f0		      .byte.b	>(LEVEL__002_R-1)
    203  189d		       f0		      .byte.b	>(LEVEL__003_L-1)
    204  189e		       f0		      .byte.b	>(LEVEL__003_R-1)
    205  189f		       f0		      .byte.b	>(LEVEL__004_L-1)
    206  18a0		       f0		      .byte.b	>(LEVEL__004_R-1)
    207  18a1		       f0		      .byte.b	>(LEVEL__005_L-1)
    208  18a2		       f1		      .byte.b	>(LEVEL__005_R-1)
    209  18a3		       f1		      .byte.b	>(LEVEL__006_L-1)
    210  18a4		       f1		      .byte.b	>(LEVEL__006_R-1)
    211  18a5		       f1		      .byte.b	>(LEVEL__007_L-1)
    212  18a6		       f2		      .byte.b	>(LEVEL__007_R-1)
    213  18a7		       f2		      .byte.b	>(LEVEL__008_L-1)
    214  18a8		       f2		      .byte.b	>(LEVEL__008_R-1)
    215  18a9		       f2		      .byte.b	>(LEVEL__009_L-1)
    216  18aa		       f2		      .byte.b	>(LEVEL__009_R-1)
    217  18ab		       f3		      .byte.b	>(LEVEL__010_L-1)
    218  18ac		       f3		      .byte.b	>(LEVEL__010_R-1)
    219  18ad		       f3		      .byte.b	>(LEVEL__011_L-1)
    220  18ae		       f3		      .byte.b	>(LEVEL__011_R-1)
    221  18af		       f3		      .byte.b	>(LEVEL__012_L-1)
    222  18b0		       f4		      .byte.b	>(LEVEL__012_R-1)
    223  18b1		       f4		      .byte.b	>(LEVEL__013_L-1)
    224  18b2		       f4		      .byte.b	>(LEVEL__013_R-1)
    225  18b3		       f4		      .byte.b	>(LEVEL__014_L-1)
    226  18b4		       f5		      .byte.b	>(LEVEL__014_R-1)
    227  18b5		       f5		      .byte.b	>(LEVEL__015_L-1)
    228  18b6		       f5		      .byte.b	>(LEVEL__015_R-1)
    229  18b7		       f5		      .byte.b	>(LEVEL__016_L-1)
    230  18b8		       f5		      .byte.b	>(LEVEL__016_R-1)
    231  18b9		       f6		      .byte.b	>(LEVEL__017_L-1)
    232  18ba		       f6		      .byte.b	>(LEVEL__017_R-1)
    233  18bb		       f6		      .byte.b	>(LEVEL__018_L-1)
    234  18bc		       f6		      .byte.b	>(LEVEL__018_R-1)
    235  18bd		       f7		      .byte.b	>(LEVEL__019_L-1)
    236  18be		       f7		      .byte.b	>(LEVEL__019_R-1)
    237  18bf		       ef		      .byte.b	>(LEVEL__020_L-1)
    238  18c0		       f0		      .byte.b	>(LEVEL__020_R-1)
    239  18c1		       f0		      .byte.b	>(LEVEL__021_L-1)
    240  18c2		       f0		      .byte.b	>(LEVEL__021_R-1)
    241  18c3		       f1		      .byte.b	>(LEVEL__022_L-1)
    242  18c4		       f1		      .byte.b	>(LEVEL__022_R-1)
    243  18c5		       f1		      .byte.b	>(LEVEL__023_L-1)
    244  18c6		       f1		      .byte.b	>(LEVEL__023_R-1)
    245  18c7		       f2		      .byte.b	>(LEVEL__024_L-1)
    246  18c8		       f2		      .byte.b	>(LEVEL__024_R-1)
    247  18c9		       f2		      .byte.b	>(LEVEL__025_L-1)
    248  18ca		       f2		      .byte.b	>(LEVEL__025_R-1)
    249  18cb		       f3		      .byte.b	>(LEVEL__026_L-1)
    250  18cc		       f3		      .byte.b	>(LEVEL__026_R-1)
    251  18cd		       f3		      .byte.b	>(LEVEL__027_L-1)
    252  18ce		       f3		      .byte.b	>(LEVEL__027_R-1)
    253  18cf		       f4		      .byte.b	>(LEVEL__028_L-1)
    254  18d0		       f4		      .byte.b	>(LEVEL__028_R-1)
    255  18d1		       f4		      .byte.b	>(LEVEL__029_L-1)
    256  18d2		       f4		      .byte.b	>(LEVEL__029_R-1)
    257  18d3		       f5		      .byte.b	>(LEVEL__030_L-1)
    258  18d4		       f5		      .byte.b	>(LEVEL__030_R-1)
    259  18d5		       f5		      .byte.b	>(LEVEL__031_L-1)
    260  18d6		       f6		      .byte.b	>(LEVEL__031_R-1)
    261  18d7		       f6		      .byte.b	>(LEVEL__032_L-1)
    262  18d8		       f6		      .byte.b	>(LEVEL__032_R-1)
    263  18d9		       f6		      .byte.b	>(LEVEL__033_L-1)
    264  18da		       f7		      .byte.b	>(LEVEL__033_R-1)
    265  18db		       f7		      .byte.b	>(LEVEL__034_L-1)
    266  18dc		       ef		      .byte.b	>(LEVEL__034_R-1)
    267  18dd		       f0		      .byte.b	>(LEVEL__035_L-1)
    268  18de		       f0		      .byte.b	>(LEVEL__035_R-1)
    269  18df		       f0		      .byte.b	>(LEVEL__036_L-1)
    270  18e0		       f1		      .byte.b	>(LEVEL__036_R-1)
    271  18e1		       f1		      .byte.b	>(LEVEL__037_L-1)
    272  18e2		       f1		      .byte.b	>(LEVEL__037_R-1)
    273  18e3		       f1		      .byte.b	>(LEVEL__038_L-1)
    274  18e4		       f2		      .byte.b	>(LEVEL__038_R-1)
    275  18e5		       f2		      .byte.b	>(LEVEL__039_L-1)
    276  18e6		       f2		      .byte.b	>(LEVEL__039_R-1)
    277  18e7		       f3		      .byte.b	>(LEVEL__040_L-1)
    278  18e8		       f3		      .byte.b	>(LEVEL__040_R-1)
    279  18e9
    280  18e9		       f3		      .byte.b	>(LEVEL__041_L-1)
    281  18ea		       f3		      .byte.b	>(LEVEL__041_R-1)
    282  18eb		       f4		      .byte.b	>(LEVEL__042_L-1)
    283  18ec		       f4		      .byte.b	>(LEVEL__042_R-1)
    284  18ed		       f4		      .byte.b	>(LEVEL__043_L-1)
    285  18ee		       f5		      .byte.b	>(LEVEL__043_R-1)
    286  18ef		       f5		      .byte.b	>(LEVEL__044_L-1)
    287  18f0		       f5		      .byte.b	>(LEVEL__044_R-1)
    288  18f1		       f5		      .byte.b	>(LEVEL__045_L-1)
    289  18f2		       f6		      .byte.b	>(LEVEL__045_R-1)
    290  18f3		       f6		      .byte.b	>(LEVEL__046_L-1)
    291  18f4		       f6		      .byte.b	>(LEVEL__046_R-1)
    292  18f5		       f7		      .byte.b	>(LEVEL__047_L-1)
    293  18f6		       f7		      .byte.b	>(LEVEL__047_R-1)
    294  18f7		       ef		      .byte.b	>(LEVEL__048_L-1)
    295  18f8		       f0		      .byte.b	>(LEVEL__048_R-1)
    296  18f9		       f0		      .byte.b	>(LEVEL__049_L-1)
    297  18fa		       f0		      .byte.b	>(LEVEL__049_R-1)
    298  18fb
    299  18fb		       f1		      .byte.b	>(LEVEL__050_L-1)
    300  18fc		       f1		      .byte.b	>(LEVEL__050_R-1)
    301  18fd		       f1		      .byte.b	>(LEVEL__051_L-1)
    302  18fe		       f2		      .byte.b	>(LEVEL__051_R-1)
    303  18ff		       f2		      .byte.b	>(LEVEL__052_L-1)
    304  1900		       f2		      .byte.b	>(LEVEL__052_R-1)
    305  1901		       f2		      .byte.b	>(LEVEL__053_L-1)
    306  1902		       f3		      .byte.b	>(LEVEL__053_R-1)
    307  1903		       f3		      .byte.b	>(LEVEL__054_L-1)
    308  1904		       f3		      .byte.b	>(LEVEL__054_R-1)
    309  1905		       f4		      .byte.b	>(LEVEL__055_L-1)
    310  1906		       f4		      .byte.b	>(LEVEL__055_R-1)
    311  1907		       f4		      .byte.b	>(LEVEL__056_L-1)
    312  1908		       f5		      .byte.b	>(LEVEL__056_R-1)
    313  1909		       f5		      .byte.b	>(LEVEL__057_L-1)
    314  190a		       f5		      .byte.b	>(LEVEL__057_R-1)
    315  190b		       f6		      .byte.b	>(LEVEL__058_L-1)
    316  190c		       f6		      .byte.b	>(LEVEL__058_R-1)
    317  190d		       f6		      .byte.b	>(LEVEL__059_L-1)
    318  190e		       f6		      .byte.b	>(LEVEL__059_R-1)
    319  190f
    320  190f		       ef		      .byte.b	>(LEVEL__060_R-1)
    321  1910		       f0		      .byte.b	>(LEVEL__061_R-1)
    322  1911		       f0		      .byte.b	>(LEVEL__061_L-1)
    323  1912		       f0		      .byte.b	>(LEVEL__062_L-1)
    324  1913		       f1		      .byte.b	>(LEVEL__062_R-1)
    325  1914		       f1		      .byte.b	>(LEVEL__063_L-1)
    326  1915		       f1		      .byte.b	>(LEVEL__063_R-1)
    327  1916		       f2		      .byte.b	>(LEVEL__064_R-1)
    328  1917		       f2		      .byte.b	>(LEVEL__064_L-1)
    329  1918		       f3		      .byte.b	>(LEVEL__065_R-1)
    330  1919		       f2		      .byte.b	>(LEVEL__065_L-1)
    331  191a		       f3		      .byte.b	>(LEVEL__066_R-1)
    332  191b		       f3		      .byte.b	>(LEVEL__066_L-1)
    333  191c		       f4		      .byte.b	>(LEVEL__067_R-1)
    334  191d		       f4		      .byte.b	>(LEVEL__067_L-1)
    335  191e		       f5		      .byte.b	>(LEVEL__068_R-1)
    336  191f		       f4		      .byte.b	>(LEVEL__068_L-1)
    337  1920		       f5		      .byte.b	>(LEVEL__069_R-1)
    338  1921		       f5		      .byte.b	>(LEVEL__069_L-1)
    339  1922
    340  1922		       f1		      .byte.b	>(LEVEL__103_Arielle-1)
    341  1923		       f1		      .byte.b	>(LEVEL__103_Ajalae-1)
    342  1924		       f1		      .byte.b	>(LEVEL__103_Adin-1)
    343  1925		       f0		      .byte.b	>(LEVEL__102_Raven-1)
    344  1926		       f0		      .byte.b	>(LEVEL__102_Oralia-1)
    345  1927		       ef		      .byte.b	>(LEVEL__102_Natalie-1)
    346  1928		       f0		      .byte.b	>(LEVEL__102_Mirabel-1)
    347  1929		       f2		      .byte.b	>(LEVEL__1XJH_Tara_Gelson-1)
    348  192a		       f2		      .byte.b	>(LEVEL__1R7X_Alison-1)
    349  192b		       f2		      .byte.b	>(LEVEL__1KWD_Cecile_Clayworth-1)
    350  192c		       f2		      .byte.b	>(LEVEL__1EKT_Samantha_Gelson-1)
    351  192d		       f3		      .byte.b	>(LEVEL__0VM5_Andrea_Wadd-1)
    352  192e		       f3		      .byte.b	>(LEVEL__0PAL_Jill_Leatherby-1)
    353  192f		       f3		      .byte.b	>(LEVEL__0IZ1_Sophia-1)
    354  1930		       f3		      .byte.b	>(LEVEL__0CNH_Alice-1)
    355  1931		       f6		      .byte.b	>(LEVEL__122_Maya-1)
    356  1932
    357  1932				  -	      IF	(* - LevelInfoHI != MAX_LEVEL)
    358  1932				  -	      ECHO	"ERROR: Incorrect LevelInfoHI table!"
    359  1932				  -	      ERR
    360  1932					      ENDIF
    361  1932
    362  1932				   LevelInfoBANK
    363  1932
    364  1932		       04		      .byte.b	BANK_LEVEL__001_L
    365  1933		       04		      .byte.b	BANK_LEVEL__001_R
    366  1934		       04		      .byte.b	BANK_LEVEL__002_L
    367  1935		       04		      .byte.b	BANK_LEVEL__002_R
    368  1936		       04		      .byte.b	BANK_LEVEL__003_L
    369  1937		       04		      .byte.b	BANK_LEVEL__003_R
    370  1938		       04		      .byte.b	BANK_LEVEL__004_L
    371  1939		       04		      .byte.b	BANK_LEVEL__004_R
    372  193a		       04		      .byte.b	BANK_LEVEL__005_L
    373  193b		       04		      .byte.b	BANK_LEVEL__005_R
    374  193c		       04		      .byte.b	BANK_LEVEL__006_L
    375  193d		       04		      .byte.b	BANK_LEVEL__006_R
    376  193e		       04		      .byte.b	BANK_LEVEL__007_L
    377  193f		       04		      .byte.b	BANK_LEVEL__007_R
    378  1940		       04		      .byte.b	BANK_LEVEL__008_L
    379  1941		       04		      .byte.b	BANK_LEVEL__008_R
    380  1942		       04		      .byte.b	BANK_LEVEL__009_L
    381  1943		       04		      .byte.b	BANK_LEVEL__009_R
    382  1944		       04		      .byte.b	BANK_LEVEL__010_L
    383  1945		       04		      .byte.b	BANK_LEVEL__010_R
    384  1946		       04		      .byte.b	BANK_LEVEL__011_L
    385  1947		       04		      .byte.b	BANK_LEVEL__011_R
    386  1948		       04		      .byte.b	BANK_LEVEL__012_L
    387  1949		       04		      .byte.b	BANK_LEVEL__012_R
    388  194a		       04		      .byte.b	BANK_LEVEL__013_L
    389  194b		       04		      .byte.b	BANK_LEVEL__013_R
    390  194c		       04		      .byte.b	BANK_LEVEL__014_L
    391  194d		       04		      .byte.b	BANK_LEVEL__014_R
    392  194e		       04		      .byte.b	BANK_LEVEL__015_L
    393  194f		       04		      .byte.b	BANK_LEVEL__015_R
    394  1950		       04		      .byte.b	BANK_LEVEL__016_L
    395  1951		       04		      .byte.b	BANK_LEVEL__016_R
    396  1952		       04		      .byte.b	BANK_LEVEL__017_L
    397  1953		       04		      .byte.b	BANK_LEVEL__017_R
    398  1954		       04		      .byte.b	BANK_LEVEL__018_L
    399  1955		       04		      .byte.b	BANK_LEVEL__018_R
    400  1956		       04		      .byte.b	BANK_LEVEL__019_L
    401  1957		       04		      .byte.b	BANK_LEVEL__019_R
    402  1958		       05		      .byte.b	BANK_LEVEL__020_L
    403  1959		       05		      .byte.b	BANK_LEVEL__020_R
    404  195a		       05		      .byte.b	BANK_LEVEL__021_L
    405  195b		       05		      .byte.b	BANK_LEVEL__021_R
    406  195c		       05		      .byte.b	BANK_LEVEL__022_L
    407  195d		       05		      .byte.b	BANK_LEVEL__022_R
    408  195e		       05		      .byte.b	BANK_LEVEL__023_L
    409  195f		       05		      .byte.b	BANK_LEVEL__023_R
    410  1960		       05		      .byte.b	BANK_LEVEL__024_L
    411  1961		       05		      .byte.b	BANK_LEVEL__024_R
    412  1962		       05		      .byte.b	BANK_LEVEL__025_L
    413  1963		       05		      .byte.b	BANK_LEVEL__025_R
    414  1964		       05		      .byte.b	BANK_LEVEL__026_L
    415  1965		       05		      .byte.b	BANK_LEVEL__026_R
    416  1966		       05		      .byte.b	BANK_LEVEL__027_L
    417  1967		       05		      .byte.b	BANK_LEVEL__027_R
    418  1968		       05		      .byte.b	BANK_LEVEL__028_L
    419  1969		       05		      .byte.b	BANK_LEVEL__028_R
    420  196a		       05		      .byte.b	BANK_LEVEL__029_L
    421  196b		       05		      .byte.b	BANK_LEVEL__029_R
    422  196c		       05		      .byte.b	BANK_LEVEL__030_L
    423  196d		       05		      .byte.b	BANK_LEVEL__030_R
    424  196e		       05		      .byte.b	BANK_LEVEL__031_L
    425  196f		       05		      .byte.b	BANK_LEVEL__031_R
    426  1970		       05		      .byte.b	BANK_LEVEL__032_L
    427  1971		       05		      .byte.b	BANK_LEVEL__032_R
    428  1972		       05		      .byte.b	BANK_LEVEL__033_L
    429  1973		       05		      .byte.b	BANK_LEVEL__033_R
    430  1974		       05		      .byte.b	BANK_LEVEL__034_L
    431  1975		       06		      .byte.b	BANK_LEVEL__034_R
    432  1976		       06		      .byte.b	BANK_LEVEL__035_L
    433  1977		       06		      .byte.b	BANK_LEVEL__035_R
    434  1978		       06		      .byte.b	BANK_LEVEL__036_L
    435  1979		       06		      .byte.b	BANK_LEVEL__036_R
    436  197a		       06		      .byte.b	BANK_LEVEL__037_L
    437  197b		       06		      .byte.b	BANK_LEVEL__037_R
    438  197c		       06		      .byte.b	BANK_LEVEL__038_L
    439  197d		       06		      .byte.b	BANK_LEVEL__038_R
    440  197e		       06		      .byte.b	BANK_LEVEL__039_L
    441  197f		       06		      .byte.b	BANK_LEVEL__039_R
    442  1980		       06		      .byte.b	BANK_LEVEL__040_L
    443  1981		       06		      .byte.b	BANK_LEVEL__040_R
    444  1982
    445  1982		       06		      .byte.b	BANK_LEVEL__041_L
    446  1983		       06		      .byte.b	BANK_LEVEL__041_R
    447  1984		       06		      .byte.b	BANK_LEVEL__042_L
    448  1985		       06		      .byte.b	BANK_LEVEL__042_R
    449  1986		       06		      .byte.b	BANK_LEVEL__043_L
    450  1987		       06		      .byte.b	BANK_LEVEL__043_R
    451  1988		       06		      .byte.b	BANK_LEVEL__044_L
    452  1989		       06		      .byte.b	BANK_LEVEL__044_R
    453  198a		       06		      .byte.b	BANK_LEVEL__045_L
    454  198b		       06		      .byte.b	BANK_LEVEL__045_R
    455  198c		       06		      .byte.b	BANK_LEVEL__046_L
    456  198d		       06		      .byte.b	BANK_LEVEL__046_R
    457  198e		       06		      .byte.b	BANK_LEVEL__047_L
    458  198f		       06		      .byte.b	BANK_LEVEL__047_R
    459  1990		       07		      .byte.b	BANK_LEVEL__048_L
    460  1991		       07		      .byte.b	BANK_LEVEL__048_R
    461  1992		       07		      .byte.b	BANK_LEVEL__049_L
    462  1993		       07		      .byte.b	BANK_LEVEL__049_R
    463  1994
    464  1994		       07		      .byte.b	BANK_LEVEL__050_L
    465  1995		       07		      .byte.b	BANK_LEVEL__050_R
    466  1996		       07		      .byte.b	BANK_LEVEL__051_L
    467  1997		       07		      .byte.b	BANK_LEVEL__051_R
    468  1998		       07		      .byte.b	BANK_LEVEL__052_L
    469  1999		       07		      .byte.b	BANK_LEVEL__052_R
    470  199a		       07		      .byte.b	BANK_LEVEL__053_L
    471  199b		       07		      .byte.b	BANK_LEVEL__053_R
    472  199c		       07		      .byte.b	BANK_LEVEL__054_L
    473  199d		       07		      .byte.b	BANK_LEVEL__054_R
    474  199e		       07		      .byte.b	BANK_LEVEL__055_L
    475  199f		       07		      .byte.b	BANK_LEVEL__055_R
    476  19a0		       07		      .byte.b	BANK_LEVEL__056_L
    477  19a1		       07		      .byte.b	BANK_LEVEL__056_R
    478  19a2		       07		      .byte.b	BANK_LEVEL__057_L
    479  19a3		       07		      .byte.b	BANK_LEVEL__057_R
    480  19a4		       07		      .byte.b	BANK_LEVEL__058_L
    481  19a5		       07		      .byte.b	BANK_LEVEL__058_R
    482  19a6		       07		      .byte.b	BANK_LEVEL__059_L
    483  19a7		       07		      .byte.b	BANK_LEVEL__059_R
    484  19a8
    485  19a8		       08		      .byte.b	BANK_LEVEL__060_R
    486  19a9		       08		      .byte.b	BANK_LEVEL__061_R
    487  19aa		       08		      .byte.b	BANK_LEVEL__061_L
    488  19ab		       08		      .byte.b	BANK_LEVEL__062_L
    489  19ac		       08		      .byte.b	BANK_LEVEL__062_R
    490  19ad		       08		      .byte.b	BANK_LEVEL__063_L
    491  19ae		       08		      .byte.b	BANK_LEVEL__063_R
    492  19af		       08		      .byte.b	BANK_LEVEL__064_R
    493  19b0		       08		      .byte.b	BANK_LEVEL__064_L
    494  19b1		       08		      .byte.b	BANK_LEVEL__065_R
    495  19b2		       08		      .byte.b	BANK_LEVEL__065_L
    496  19b3		       08		      .byte.b	BANK_LEVEL__066_R
    497  19b4		       08		      .byte.b	BANK_LEVEL__066_L
    498  19b5		       08		      .byte.b	BANK_LEVEL__067_R
    499  19b6		       08		      .byte.b	BANK_LEVEL__067_L
    500  19b7		       08		      .byte.b	BANK_LEVEL__068_R
    501  19b8		       08		      .byte.b	BANK_LEVEL__068_L
    502  19b9		       08		      .byte.b	BANK_LEVEL__069_R
    503  19ba		       08		      .byte.b	BANK_LEVEL__069_L
    504  19bb
    505  19bb		       09		      .byte.b	BANK_LEVEL__103_Arielle
    506  19bc		       09		      .byte.b	BANK_LEVEL__103_Ajalae
    507  19bd		       09		      .byte.b	BANK_LEVEL__103_Adin
    508  19be		       09		      .byte.b	BANK_LEVEL__102_Raven
    509  19bf		       09		      .byte.b	BANK_LEVEL__102_Oralia
    510  19c0		       09		      .byte.b	BANK_LEVEL__102_Natalie
    511  19c1		       09		      .byte.b	BANK_LEVEL__102_Mirabel
    512  19c2		       09		      .byte.b	BANK_LEVEL__1XJH_Tara_Gelson
    513  19c3		       09		      .byte.b	BANK_LEVEL__1R7X_Alison
    514  19c4		       09		      .byte.b	BANK_LEVEL__1KWD_Cecile_Clayworth
    515  19c5		       09		      .byte.b	BANK_LEVEL__1EKT_Samantha_Gelson
    516  19c6		       09		      .byte.b	BANK_LEVEL__0VM5_Andrea_Wadd
    517  19c7		       09		      .byte.b	BANK_LEVEL__0PAL_Jill_Leatherby
    518  19c8		       09		      .byte.b	BANK_LEVEL__0IZ1_Sophia
    519  19c9		       09		      .byte.b	BANK_LEVEL__0CNH_Alice
    520  19ca
    521  19ca		       08		      .byte.b	BANK_LEVEL__122_Maya
    522  19cb
    523  19cb				  -	      IF	(* - LevelInfoBANK != MAX_LEVEL)
    524  19cb				  -	      ECHO	"ERROR: Incorrect LevelInfoBANK table!"
    525  19cb				  -	      ERR
    526  19cb					      ENDIF
    527  19cb
    528  19cb
    529  19cb
    530  19cb				   finX
    531  19cb							; now put the soil in - fill from the outsides
    532  19cb
    533  19cb		       a9 01		      lda	#CHARACTER_SOIL
    534  19cd		       85 8c		      sta	POS_Type
    535  19cf
    536  19cf		       a9 13		      lda	#SIZE_BOARD_Y-1
    537  19d1		       85 89		      sta	POS_Y
    538  19d3
    539  19d3		       a9 17	   xlin       lda	#SIZE_BOARD_X-1
    540  19d5		       85 88		      sta	POS_X
    541  19d7		       20 26 f8    zap1       jsr	GetBoardCharacter__CALL_FROM_RAM__
    542  19da		       c9 01		      cmp	#CHARACTER_SOIL
    543  19dc		       f0 07		      beq	kg2a
    544  19de		       c9 00		      cmp	#0
    545  19e0		       d0 07		      bne	endzap1
    546  19e2		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    547  19e5		       c6 88	   kg2a       dec	POS_X
    548  19e7		       10 ee		      bpl	zap1
    549  19e9
    550  19e9		       a9 00	   endzap1    lda	#0
    551  19eb		       85 88		      sta	POS_X
    552  19ed		       20 26 f8    zap2       jsr	GetBoardCharacter__CALL_FROM_RAM__
    553  19f0		       c9 01		      cmp	#CHARACTER_SOIL
    554  19f2		       f0 07		      beq	kg2
    555  19f4		       c9 00		      cmp	#0
    556  19f6		       d0 0b		      bne	endzap2
    557  19f8		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    558  19fb		       e6 88	   kg2	      inc	POS_X
    559  19fd		       a5 88		      lda	POS_X
    560  19ff		       c9 18		      cmp	#SIZE_BOARD_X
    561  1a01		       d0 ea		      bne	zap2
    562  1a03
    563  1a03		       c6 89	   endzap2    dec	POS_Y
    564  1a05		       10 cc		      bpl	xlin
    565  1a07
    566  1a07
    567  1a07		       a9 17		      lda	#SIZE_BOARD_X-1
    568  1a09		       85 88		      sta	POS_X
    569  1a0b
    570  1a0b		       a9 13	   ylin       lda	#SIZE_BOARD_Y-1
    571  1a0d		       85 89		      sta	POS_Y
    572  1a0f		       20 26 f8    zapy1      jsr	GetBoardCharacter__CALL_FROM_RAM__
    573  1a12		       c9 01		      cmp	#CHARACTER_SOIL
    574  1a14		       f0 07		      beq	kg3
    575  1a16		       c9 00		      cmp	#0
    576  1a18		       d0 07		      bne	endzapy1
    577  1a1a		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    578  1a1d		       c6 89	   kg3	      dec	POS_Y
    579  1a1f		       10 ee		      bpl	zapy1
    580  1a21
    581  1a21		       a9 00	   endzapy1   lda	#0
    582  1a23		       85 89		      sta	POS_Y
    583  1a25		       20 26 f8    zapy2      jsr	GetBoardCharacter__CALL_FROM_RAM__
    584  1a28		       c9 01		      cmp	#CHARACTER_SOIL
    585  1a2a		       f0 07		      beq	kg3b
    586  1a2c		       c9 00		      cmp	#0
    587  1a2e		       d0 0b		      bne	endzapy2
    588  1a30		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    589  1a33		       e6 89	   kg3b       inc	POS_Y
    590  1a35		       a5 89		      lda	POS_Y
    591  1a37		       c9 14		      cmp	#SIZE_BOARD_Y
    592  1a39		       d0 ea		      bne	zapy2
    593  1a3b
    594  1a3b		       c6 88	   endzapy2   dec	POS_X
    595  1a3d		       10 cc		      bpl	ylin
    596  1a3f		       60		      rts
    597  1a40
    598  1a40							;A	 steel wall
    599  1a40							;B	 soil (surround)
    600  1a40							;C	 box
    601  1a40
    602  1a40
    603  1a40				   C1			;mortar
    604  1a40		       88 b6		      .byte.b	$88,$b6
    605  1a42		       38 68		      .byte.b	$38,$68
    606  1a44		       5a aa		      .byte.b	$5a,$AA
    607  1a46		       5a 8a		      .byte.b	$5a,$8a
    608  1a48				   C2			; soil stripes
    609  1a48		       34 62		      .byte.b	$34,$62
    610  1a4a		       b4 74		      .byte.b	$b4,$74
    611  1a4c		       f4 24		      .byte.b	$F4,$24
    612  1a4e		       a4 74		      .byte.b	$a4,$74
    613  1a50				   C3			; brick
    614  1a50		       1a 2a		      .byte.b	$1A,$2a
    615  1a52		       8c bc		      .byte.b	$8C,$BC
    616  1a54		       0a fa		      .byte.b	$0A,$fA
    617  1a56		       ca 3a		      .byte.b	$ca,$3a
    618  1a58
      0  1a58					      DEFINE_SUBROUTINE	UnpackLevel
      1  1a58		       00 03	   BANK_UnpackLevel =	_CURRENT_BANK
      2  1a58					      SUBROUTINE
      3  1a58				   UnpackLevel
    620  1a58
    621  1a58		       85 ca		      sta	RAM_Bank
    622  1a5a
    623  1a5a							; has to be done before decoding the level to have the platform right:
    624  1a5a							;	    SET_PLATFORM
    625  1a5a
    626  1a5a		       a9 01		      lda	#CHARACTER_SOIL
    627  1a5c		       85 8c		      sta	POS_Type
    628  1a5e
    629  1a5e		       a9 13		      lda	#SIZE_BOARD_Y-1
    630  1a60		       85 89		      sta	POS_Y
    631  1a62		       a9 17	   xyLine     lda	#SIZE_BOARD_X-1
    632  1a64		       85 88		      sta	POS_X
    633  1a66		       20 3a f8    xyClear    jsr	PutBoardCharacterFromRAM
    634  1a69		       c6 88		      dec	POS_X
    635  1a6b		       10 f9		      bpl	xyClear
    636  1a6d		       c6 89		      dec	POS_Y
    637  1a6f		       10 f1		      bpl	xyLine
    638  1a71
    639  1a71		       a9 04		      lda	#4
    640  1a73		       85 e2		      sta	base_x
    641  1a75		       85 e3		      sta	base_y
    642  1a77
    643  1a77		       a5 d0		      lda	NextLevelTrigger
    644  1a79		       09 80		      ora	#BIT_NEXTLEVEL
    645  1a7b		       85 d0		      sta	NextLevelTrigger
    646  1a7d
    647  1a7d		       a6 b8		      ldx	levelX
    648  1a7f		       bd 00 f0 	      lda	LevelInfoLO,x
    649  1a82		       85 c5		      sta	Board_AddressR
    650  1a84		       bd 99 f0 	      lda	LevelInfoHI,x
    651  1a87		       85 c6		      sta	Board_AddressR+1
    652  1a89		       bd 32 f1 	      lda	LevelInfoBANK,x
    653  1a8c		       85 b1		      sta	LEVEL_bank
    654  1a8e
    655  1a8e		       a9 03		      lda	#BANK_UnpackLevel	; the *ROM* bank of this routine (NOT RAM)
    656  1a90		       85 c9		      sta	ROM_Bank	; GetROMByte returns to this bank
    657  1a92
    658  1a92		       a5 b8		      lda	levelX
    659  1a94		       29 03		      and	#3
    660  1a96		       0a		      asl
    661  1a97		       0a		      asl
    662  1a98		       05 81		      ora	Platform	; NTSC/PAL
    663  1a9a		       4a		      lsr
    664  1a9b		       aa		      tax
    665  1a9c		       bd 40 f2 	      lda	C1,x
    666  1a9f		       85 c2		      sta	color
    667  1aa1		       bd 48 f2 	      lda	C2,x
    668  1aa4		       85 c3		      sta	color+1
    669  1aa6		       bd 50 f2 	      lda	C3,x
    670  1aa9		       85 c4		      sta	color+2
    671  1aab
    672  1aab		       a9 00		      lda	#$00
    673  1aad		       85 be		      sta	BCD_moveCounter
    674  1aaf		       85 bf		      sta	BCD_moveCounterHi
    675  1ab1		       85 c0		      sta	takebackIndex
    676  1ab3		       85 c1		      sta	takebackBaseIndex
    677  1ab5
    678  1ab5		       a9 00		      lda	#$00	; BCD reminder!
    679  1ab7		       85 bd		      sta	BCD_targetsRequired	; # of targets that do NOT have boxes on them
    680  1ab9
    681  1ab9		       a9 18		      lda	#24	; arbitrary
    682  1abb		       85 bc		      sta	ThrottleSpeed
    683  1abd
    684  1abd							; first fill bg with character_soil
    685  1abd							; then rle unpack level
    686  1abd							; change level colours
    687  1abd
    688  1abd		       a9 00		      lda	#0
    689  1abf		       85 88		      sta	POS_X
    690  1ac1		       85 89		      sta	POS_Y
    691  1ac3		       85 97		      sta	BoardLimit_Width
    692  1ac5		       85 98		      sta	BoardLimit_Height
    693  1ac7
    694  1ac7				   GetNextItem
    695  1ac7
    696  1ac7		       a9 01		      lda	#1
    697  1ac9		       85 e4		      sta	upk_length
    698  1acb		       a9 00		      lda	#0
    699  1acd		       85 e5		      sta	upk_column	; reuse var - this flags a digit already
    700  1acf
    701  1acf		       e6 c5	   Get2       inc	Board_AddressR
    702  1ad1		       d0 02		      bne	addrOK
    703  1ad3		       e6 c6		      inc	Board_AddressR+1
    704  1ad5				   addrOK
    705  1ad5
    706  1ad5		       a5 b1		      lda	LEVEL_bank
    707  1ad7		       a0 00		      ldy	#0
    708  1ad9		       20 0f f8 	      jsr	GetROMByte
    709  1adc		       85 e6		      sta	upk_temp	;scratch
    710  1ade
    711  1ade
    712  1ade		       c9 00		      cmp	#0
    713  1ae0		       d0 03		      bne	parse
    714  1ae2		       4c cb f1 	      jmp	finX
    715  1ae5				   parse
    716  1ae5		       c9 3a		      cmp	#"9"+1
    717  1ae7		       b0 1e		      bcs	notDigit
    718  1ae9		       c9 30		      cmp	#"0"
    719  1aeb		       90 1a		      bcc	notDigit
    720  1aed
    721  1aed		       a5 e5		      lda	upk_column
    722  1aef		       f0 09		      beq	firstDig
    723  1af1
    724  1af1		       a5 e4		      lda	upk_length
    725  1af3		       0a		      asl
    726  1af4		       0a		      asl
    727  1af5		       0a		      asl
    728  1af6		       65 e4		      adc	upk_length
    729  1af8		       65 e4		      adc	upk_length
    730  1afa
    731  1afa		       18	   firstDig   clc
    732  1afb		       65 e6		      adc	upk_temp
    733  1afd		       38		      sec
    734  1afe		       e9 30		      sbc	#"0"
    735  1b00		       85 e4		      sta	upk_length
    736  1b02		       e6 e5		      inc	upk_column	; flag we have seen a digit
    737  1b04		       4c cf f2 	      jmp	Get2
    738  1b07
    739  1b07		       c9 7c	   notDigit   cmp	#"|"	; newline
    740  1b09		       d0 11		      bne	checkWall
    741  1b0b
    742  1b0b							; Handle new-line
    743  1b0b		       a9 00		      lda	#0
    744  1b0d		       85 88		      sta	POS_X
    745  1b0f		       e6 89		      inc	POS_Y
    746  1b11
    747  1b11
    748  1b11		       a5 89		      lda	POS_Y
    749  1b13		       c5 98		      cmp	BoardLimit_Height
    750  1b15		       90 02		      bcc	wOK2
    751  1b17		       85 98		      sta	BoardLimit_Height	;???^^^
    752  1b19				   wOK2
    753  1b19
    754  1b19		       4c c7 f2 	      jmp	GetNextItem
    755  1b1c
    756  1b1c		       c9 23	   checkWall  cmp	#"#"	; wall
    757  1b1e		       d0 09		      bne	checkForGap
    758  1b20		       a5 b8		      lda	levelX
    759  1b22		       29 01		      and	#1
    760  1b24		       18		      clc
    761  1b25		       69 06		      adc	#CHARACTER_STEEL
    762  1b27		       d0 62		      bne	WriteChars
    763  1b29
    764  1b29		       c9 20	   checkForGap cmp	#32
    765  1b2b		       f0 08		      beq	writeGap
    766  1b2d		       c9 2d		      cmp	#"-"
    767  1b2f		       f0 04		      beq	writeGap
    768  1b31		       c9 5f		      cmp	#"_"
    769  1b33		       d0 05		      bne	checkForMan
    770  1b35
    771  1b35		       a9 00	   writeGap   lda	#CHARACTER_BLANK
    772  1b37		       4c 8b f3 	      jmp	WriteChars
    773  1b3a
    774  1b3a				   checkForMan
    775  1b3a		       c9 2b		      cmp	#"+"	; player on goal square
    776  1b3c		       d0 07		      bne	notPlayerGoal
    777  1b3e
    778  1b3e		       20 a7 fd 	      jsr	RegisterTarget
    779  1b41
    780  1b41							; put goal square, init player with POS_VAR = CHARACTER_TARGET
    781  1b41
    782  1b41		       a9 03		      lda	#CHARACTER_TARGET
    783  1b43		       d0 06		      bne	genPlayer
    784  1b45
    785  1b45				   notPlayerGoal
    786  1b45		       c9 40		      cmp	#"@"	; player on normal square
    787  1b47		       d0 29		      bne	checkBox
    788  1b49
    789  1b49		       a9 00		      lda	#CHARACTER_BLANK
    790  1b4b
    791  1b4b				   genPlayer
    792  1b4b
    793  1b4b		       85 8d		      sta	POS_VAR	; character man is on
    794  1b4d
    795  1b4d		       18		      clc
    796  1b4e		       a5 88		      lda	POS_X
    797  1b50		       48		      pha
    798  1b51		       65 e2		      adc	base_x
    799  1b53		       85 88		      sta	POS_X
    800  1b55		       85 a2		      sta	ManX
    801  1b57
    802  1b57		       a5 89		      lda	POS_Y
    803  1b59		       48		      pha
    804  1b5a		       65 e3		      adc	base_y
    805  1b5c		       85 89		      sta	POS_Y
    806  1b5e		       85 a3		      sta	ManY
    807  1b60
    808  1b60							; POS_X     x position
    809  1b60							; POS_Y     y position
    810  1b60							; POS_VAR   CHARACTER UNDER MAN TO RESTORE
    811  1b60							; POS_Type  type of object
    812  1b60
    813  1b60		       a9 00		      lda	#TYPE_MAN
    814  1b62		       85 8c		      sta	POS_Type	;	 creature TYPE
    815  1b64		       20 24 f9 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    816  1b67
    817  1b67		       68		      pla
    818  1b68		       85 89		      sta	POS_Y
    819  1b6a		       68		      pla
    820  1b6b		       85 88		      sta	POS_X
    821  1b6d
    822  1b6d		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    823  1b6f		       4c 8b f3 	      jmp	WriteChars
    824  1b72
    825  1b72		       c9 24	   checkBox   cmp	#"$"
    826  1b74		       d0 04		      bne	checkBoxTarget
    827  1b76
    828  1b76		       a9 02		      lda	#CHARACTER_BOX
    829  1b78		       d0 11		      bne	WriteChars
    830  1b7a
    831  1b7a		       c9 2a	   checkBoxTarget cmp	#"*"
    832  1b7c		       d0 04		      bne	checkTarget
    833  1b7e
    834  1b7e		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    835  1b80		       d0 09		      bne	WriteChars
    836  1b82
    837  1b82		       c9 2e	   checkTarget cmp	#"."
    838  1b84		       f0 03		      beq	targ
    839  1b86		       4c c7 f2 	      jmp	GetNextItem
    840  1b89				   targ
    841  1b89
    842  1b89		       a9 03		      lda	#CHARACTER_TARGET
    843  1b8b
    844  1b8b		       85 8c	   WriteChars sta	POS_Type
    845  1b8d
    846  1b8d		       18	   Wc2x       clc
    847  1b8e		       a5 88		      lda	POS_X
    848  1b90		       48		      pha
    849  1b91		       65 e2		      adc	base_x
    850  1b93		       85 88		      sta	POS_X
    851  1b95
    852  1b95		       a5 89		      lda	POS_Y
    853  1b97		       48		      pha
    854  1b98		       65 e3		      adc	base_y
    855  1b9a		       85 89		      sta	POS_Y
    856  1b9c
    857  1b9c		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    858  1b9f
    859  1b9f		       a5 8c		      lda	POS_Type
    860  1ba1		       c9 03		      cmp	#CHARACTER_TARGET
    861  1ba3		       d0 03		      bne	notargdet
    862  1ba5		       20 a7 fd 	      jsr	RegisterTarget
    863  1ba8				   notargdet
    864  1ba8
    865  1ba8		       68		      pla
    866  1ba9		       85 89		      sta	POS_Y
    867  1bab		       68		      pla
    868  1bac		       85 88		      sta	POS_X
    869  1bae
    870  1bae		       18		      clc
    871  1baf		       69 01		      adc	#1
    872  1bb1		       85 88		      sta	POS_X
    873  1bb3
    874  1bb3		       c5 97		      cmp	BoardLimit_Width
    875  1bb5		       90 02		      bcc	wOK
    876  1bb7		       85 97		      sta	BoardLimit_Width
    877  1bb9				   wOK
    878  1bb9
    879  1bb9		       c6 e4		      dec	upk_length
    880  1bbb		       d0 d0		      bne	Wc2x
    881  1bbd		       4c c7 f2 	      jmp	GetNextItem
    882  1bc0
    883  1bc0				   finishedUnpack
    884  1bc0
    885  1bc0		       60		      rts
    886  1bc0					      endif
------- FILE BANK_GENERIC.asm
     44  1bc1
      0  1bc1					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_LEVEL)"
      1  1bc1
      2  1bc1
      3  1bc1		       03 c1	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_LEVEL) (1K) SIZE =  $3c1 , FREE= $3f
      4  1bc1					      ECHO	"GENERIC_BANK_1 (DECODE_LEVEL)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1bc1				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1bc1				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1bc1				  -	      ERR
      8  1bc1					      endif
     46  1bc1
     47  1bc1							;------------------------------------------------------------------------------
     48  1bc1							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     49  1bc1							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     50  1bc1							; bank finishes.  Just continue on from where it left off...
     51  1bc1							;------------------------------------------------------------------------------
     52  1bc1
      0  1bc1					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  1bc1		       00 03	   BANK_Cart_Init =	_CURRENT_BANK
      2  1bc1					      SUBROUTINE
      3  1bc1				   Cart_Init
     54  1bc1
     55  1bc1							; Note the variables from the title selection are incredibly transient an can be stomped
     56  1bc1							; at any time.  So they need to be used immediately.
     57  1bc1
     58  1bc1
     59  1bc1							; odd usage below is to prevent any possibility of variable stomping/assumptions
     60  1bc1
     61  1bc1		       a9 01		      lda	#1
     62  1bc3		       a2 00		      ldx	#0	;sLevel				      ; level # from title select
     63  1bc5		       a0 00		      ldy	#0	;sJoysticks
     64  1bc7		       84 b0		      sty	jtoggle
     65  1bc9		       86 b9		      stx	level
     66  1bcb							;sta ManCount					; = #players
     67  1bcb		       a9 00		      lda	#0
     68  1bcd		       85 b8		      sta	levelX	; make an immediate copy to safe variables!
     69  1bcf		       85 e8		      sta	startingLevel
     70  1bd1
     71  1bd1							; multiply with LEVEL_DEFINITION_SIZE (5):
     72  1bd1		       0a		      asl
     73  1bd2		       0a		      asl
     74  1bd3		       85 b8		      sta	levelX
     75  1bd5
      0  1bd5					      LOAD_ANIMATION	Animation_IDLE
      1  1bd5		       a9 20		      lda	#<Animation_IDLE
      2  1bd7		       85 9f		      sta	animation
      3  1bd9		       a9 f0		      lda	#>Animation_IDLE
      4  1bdb		       85 a0		      sta	animation+1
      5  1bdd		       a9 ff		      lda	#-1
      6  1bdf		       85 a1		      sta	animation_delay
     77  1be1		       a9 82		      lda	#ANIMATION_IDLE_ID
     78  1be3		       85 ae		      sta	ManAnimationID
     79  1be5
     80  1be5		       a9 01		      lda	#1
     81  1be7		       85 9c		      sta	whichPlayer	; will switch to 0 on 1st go
     82  1be9
     83  1be9							;lda #NUM_LIVES<<4				  ; 3 lives
     84  1be9							;ldx ManCount					; = sPlayers
     85  1be9							;beq opg
     86  1be9							;lda #NUM_LIVES<<4|NUM_LIVES
     87  1be9				   opg			;sta ManCount					; P2P1 nybble each
     88  1be9
     89  1be9							;---------------------------------------------------------------------------
     90  1be9
     91  1be9		       a9 00		      lda	#0
     92  1beb		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     93  1bee		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     94  1bf1		       85 6b		      sta	HMCLR
     95  1bf3
     96  1bf3							; cleanup remains of title screen
     97  1bf3		       85 5b		      sta	GRP0
     98  1bf5		       85 5c		      sta	GRP1
     99  1bf7		       85 5b		      sta	GRP0
    100  1bf9
    101  1bf9		       85 87		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
    102  1bfb		       85 d6		      sta	ethnic
    103  1bfd
    104  1bfd				  -	      if	0
    105  1bfd				  -	      sta	circle_d
    106  1bfd				  -	      sta	circle_d+1
    107  1bfd					      endif
    108  1bfd
    109  1bfd							;    IFCONST DEBUG_CREATURE
    110  1bfd							;		  sta worstTime
    111  1bfd							;    ENDIF
    112  1bfd
    113  1bfd		       a9 04		      lda	#%100	; players/missiles BEHIND BG
    114  1bff		       85 4a		      sta	CTRLPF
    115  1c01							;sta rnd			  ; anything non-0
    116  1c01
    117  1c01		       a9 ff		      lda	#$FF
    118  1c03		       85 82		      sta	DrawStackPointer
    119  1c05		       85 95		      sta	BufferedButton
    120  1c07		       85 96		      sta	BufferedButton+1
    121  1c09
    122  1c09							;lda #DIRECTION_BITS		  ;???
    123  1c09							;sta ManLastDirection
    124  1c09
    125  1c09		       a9 00		      lda	#0
    126  1c0b							;		  sta ObjStackPtr		  ; object stack index of last entry
    127  1c0b							;		  sta ObjStackPtr+1
    128  1c0b							;		  sta ObjStackNum
    129  1c0b							;		  sta ObjIterator
    130  1c0b
    131  1c0b		       85 d2		      sta	sortPtr
    132  1c0d		       a9 ff		      lda	#<(-1)
    133  1c0f		       85 d1		      sta	sortRequired
    134  1c11
    135  1c11							; read high score from SaveKey and store in highScoreSK,
    136  1c11							; which is transferred to high score variable in RAM by GeneralScoringSetups
    137  1c11		       4c 5c f6 	      jmp	ReadSaveKey
    138  1c14
    139  1c14							;LEVEL0CREATURE  .byte TYPE_MAN,	  0,	  3,	  5
    140  1c14							;		  .byte -1
    141  1c14
    142  1c14							;------------------------------------------------------------------------------
    143  1c14
      0  1c14					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  1c14		       00 03	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  1c14					      SUBROUTINE
      3  1c14				   SwapPlayersGeneric
    145  1c14
    146  1c14							; at the start of a level (or player, doesn't matter) we grab the current state of the colour/B&W switch
    147  1c14							; into the gameMode variable.
    148  1c14
    149  1c14		       a5 80		      lda	gameMode
    150  1c16		       29 77		      and	#~(BW_SWITCH|GAMEMODE_PAUSED)
    151  1c18		       85 80		      sta	gameMode
    152  1c1a		       ad 82 02 	      lda	SWCHB
    153  1c1d		       29 08		      and	#BW_SWITCH
    154  1c1f		       05 80		      ora	gameMode	; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    155  1c21		       85 80		      sta	gameMode	; also, BIT7=0 -- system is NOT paused
    156  1c23
    157  1c23
    158  1c23							; restart level
    159  1c23		       a5 d0		      lda	NextLevelTrigger
    160  1c25		       29 bf		      and	#<(~BIT_NEXTLIFE)
    161  1c27		       85 d0		      sta	NextLevelTrigger
    162  1c29
    163  1c29							; if new high score was set by SwapPlayers, update it:
    164  1c29
    165  1c29		       4c 82 f6 	      jmp	WriteSaveKey
    166  1c2c
    167  1c2c
    168  1c2c							;------------------------------------------------------------------------------
    169  1c2c
      0  1c2c					      DEFINE_SUBROUTINE	CreateCreatures
      1  1c2c		       00 03	   BANK_CreateCreatures =	_CURRENT_BANK
      2  1c2c					      SUBROUTINE
      3  1c2c				   CreateCreatures
    171  1c2c
    172  1c2c							; Calculate rightmost value for scrolling edge.  .
    173  1c2c
    174  1c2c		       85 c9		      sta	ROM_Bank
    175  1c2e
    176  1c2e		       38		      sec
    177  1c2f		       a5 97		      lda	BoardLimit_Width
    178  1c31		       e9 09		      sbc	#SCREEN_WIDTH-1
    179  1c33		       85 97		      sta	BoardEdge_Right	; absolute rightmost scroll value
    180  1c35
    181  1c35							;		  sec			     already set
    182  1c35		       a5 98		      lda	BoardLimit_Height
    183  1c37		       e9 07		      sbc	#SCREEN_LINES-1
    184  1c39		       85 98		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    185  1c3b
    186  1c3b							; kludge position scroll roughly at player
    187  1c3b
    188  1c3b							;		  sec			 already set
    189  1c3b		       a5 a2		      lda	ManX
    190  1c3d		       e9 05		      sbc	#5
    191  1c3f		       b0 02		      bcs	notL0
    192  1c41		       a9 00		      lda	#0
    193  1c43		       85 9a	   notL0      sta	BoardScrollX
    194  1c45
    195  1c45
    196  1c45		       38		      sec
    197  1c46		       a5 a3		      lda	ManY
    198  1c48		       e9 03		      sbc	#3	; TJ: why 5???
    199  1c4a		       b0 02		      bcs	notU0
    200  1c4c		       a9 00		      lda	#0
    201  1c4e		       85 99	   notU0      sta	BoardScrollY
    202  1c50
    203  1c50		       a9 00		      lda	#0
    204  1c52		       85 a6		      sta	ManMode
    205  1c54		       85 a7		      sta	ManDelayCount
    206  1c56		       85 d5		      sta	TakebackInhibit
    207  1c58
    208  1c58							;lda #AnimateBLANK-Manimate ;0 ;<AnimateBLANK ;STAND
    209  1c58							;sta ManAnimation
    210  1c58							;lda #>AnimateBLANK ;
    211  1c58							;sta ManAnimation+1
    212  1c58
    213  1c58		       a9 ff		      lda	#$FF
    214  1c5a		       85 b5		      sta	LastSpriteY
    215  1c5c		       85 ae		      sta	ManAnimationID
    216  1c5e
    217  1c5e		       a9 07		      lda	#DIRECTION_BITS	;????
    218  1c60		       85 ab		      sta	ManLastDirection	; duplicate?
    219  1c62
    220  1c62		       a9 00		      lda	#0
    221  1c64		       85 e2		      sta	base_x
    222  1c66		       85 e3		      sta	base_y
    223  1c68		       85 ac		      sta	ManPushCounter
    224  1c6a
    225  1c6a		       60		      rts
    226  1c6b
    227  1c6b							;-------------------------------------------------------------------------------------
    228  1c6b
      0  1c6b					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  1c6b		       00 03	   BANK_LevelInit =	_CURRENT_BANK
      2  1c6b					      SUBROUTINE
      3  1c6b				   LevelInit
    230  1c6b
    231  1c6b		       a9 00		      lda	#0
    232  1c6d		       85 84		      sta	ObjStackPtr
    233  1c6f		       85 85		      sta	ObjStackPtr+1	; kill all creatures
    234  1c71		       85 83		      sta	ObjStackNum
    235  1c73		       85 d3		      sta	ObjIterator
    236  1c75
    237  1c75		       85 9b		      sta	scrollBits
    238  1c77		       85 87		      sta	ScreenDrawPhase
    239  1c79
    240  1c79		       85 b7		      sta	BGColour
    241  1c7b		       85 cb		      sta	ColourTimer
    242  1c7d
    243  1c7d		       85 59		      sta	AUDV0
    244  1c7f		       85 5a		      sta	AUDV1	; turn off music while levels init
    245  1c81							;		  sta AUDC0
    246  1c81
    247  1c81							;sta ManLastDirection
    248  1c81							;sta ManPushCounter
    249  1c81
    250  1c81		       85 d2		      sta	sortPtr	; sort stopped
    251  1c83		       a9 ff		      lda	#<(-1)
    252  1c85		       85 d1		      sta	sortRequired	; nothing needed
    253  1c87		       85 82		      sta	DrawStackPointer
    254  1c89
    255  1c89		       a9 00		      lda	#DISPLAY_TIME	;DISPLAY_SCORE
    256  1c8b		       85 cf		      sta	scoringFlags
    257  1c8d		       a9 00		      lda	#0	;SCORING_TIMER_FIRST		      ; We want the first timer display to be long, to show level and lives
    258  1c8f		       85 ce		      sta	scoringTimer
    259  1c91
    260  1c91		       18		      clc
    261  1c92		       a5 d6		      lda	ethnic
    262  1c94		       69 10		      adc	#16
    263  1c96		       c9 40		      cmp	#4*16
    264  1c98		       90 02		      bcc	ethOK
    265  1c9a		       a9 00		      lda	#0
    266  1c9c		       85 d6	   ethOK      sta	ethnic
    267  1c9e
    268  1c9e		       60		      rts
    269  1c9f
    270  1c9f							;-------------------------------------------------------------------------------------
    271  1c9f
      0  1c9f					      DEFINE_SUBROUTINE	Resync
      1  1c9f		       00 03	   BANK_Resync =	_CURRENT_BANK
      2  1c9f					      SUBROUTINE
      3  1c9f				   Resync
      0  1c9f					      RESYNC
      1  1c9f
      2  1c9f		       a9 02		      lda	#%10
      3  1ca1		       85 41		      sta	VBLANK
      4  1ca3
      5  1ca3		       a2 08		      ldx	#8
      6  1ca5				   .loopResync
      0  1ca5					      VERTICAL_SYNC
      1  1ca5		       a9 0e		      lda	#%1110
      2  1ca7		       85 42	   .VSLP1     sta	WSYNC
      3  1ca9		       85 40		      sta	VSYNC
      4  1cab		       4a		      lsr
      5  1cac		       d0 f9		      bne	.VSLP1
      8  1cae
      9  1cae		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  1cb0		       a5 81		      lda	Platform
     11  1cb2		       49 02		      eor	#PAL_50
     12  1cb4		       d0 02		      bne	.ntsc
     13  1cb6		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  1cb8				   .ntsc
     15  1cb8				   .loopWait
     16  1cb8		       85 42		      sta	WSYNC
     17  1cba		       85 42		      sta	WSYNC
     18  1cbc		       88		      dey
     19  1cbd		       d0 f9		      bne	.loopWait
     20  1cbf		       ca		      dex
     21  1cc0		       d0 e3		      bne	.loopResync
    274  1cc2		       60	   Ret	      rts
    275  1cc3
    276  1cc3							;---------------------------------------------------------------------------
    277  1cc3
      0  1cc3					      DEFINE_SUBROUTINE	TrackPlayer	; =145; in GENERIC_BANK_1
      1  1cc3		       00 03	   BANK_TrackPlayer =	_CURRENT_BANK
      2  1cc3					      SUBROUTINE
      3  1cc3				   TrackPlayer
    279  1cc3
    280  1cc3		       a5 ad		      lda	LookingAround	; 3
    281  1cc5		       d0 fb		      bne	Ret	; 2/3=5/6   don't track when looking around
    282  1cc7
    283  1cc7							; Contribution by Thomas Jentzsch
    284  1cc7
    285  1cc7							; scrolling constants:
    286  1cc7		       00 03	   .SCRL_START_LEFT =	3	; 3
    287  1cc7		       00 03	   .SCRL_STOP_LEFT =	3	;SCREEN_WIDTH-5		    ; 5 scrolls 5-3+1 = 3 pixel
    288  1cc7		       00 07	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT	; 7
    289  1cc7		       00 07	   .SCRL_STOP_RIGHT =	SCREEN_WIDTH-.SCRL_STOP_LEFT	; 5
    290  1cc7		       00 11	   .SCRL_LEFT_BIT =	%00010001
    291  1cc7		       00 22	   .SCRL_RIGHT_BIT =	%00100010
    292  1cc7		       00 33	   .SCRL_X_BITS =	.SCRL_LEFT_BIT|.SCRL_RIGHT_BIT
    293  1cc7
    294  1cc7		       00 02	   .SCRL_START_UP =	2	; 2
    295  1cc7		       00 02	   .SCRL_STOP_UP =	2	;SCREEN_LINES-5		    ; 3 scrolls 3-2+1 = 2 pixel
    296  1cc7		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP	; 6
    297  1cc7		       00 06	   .SCRL_STOP_DOWN =	SCREEN_LINES-.SCRL_STOP_UP	; 5
    298  1cc7		       00 44	   .SCRL_UP_BIT =	%01000100
    299  1cc7		       00 88	   .SCRL_DOWN_BIT =	%10001000
    300  1cc7		       00 cc	   .SCRL_Y_BITS =	.SCRL_UP_BIT|.SCRL_DOWN_BIT
    301  1cc7
    302  1cc7							; *** horizontal scrolling (unoptimized version): ***
    303  1cc7
    304  1cc7							; check for enabling horizontal scrolling:
    305  1cc7		       a5 a2		      lda	ManX	; 3
    306  1cc9		       38		      sec		; 2
    307  1cca		       e5 9a		      sbc	BoardScrollX	; 3
    308  1ccc		       a8		      tay		; 2	     for later use
    309  1ccd		       a9 11		      lda	#.SCRL_LEFT_BIT	; 2
    310  1ccf		       c0 03		      cpy	#.SCRL_START_LEFT	; 2	     <3?
    311  1cd1		       30 06		      bmi	.startXScroll	; 2/3	     yes, scroll left
    312  1cd3		       c0 07		      cpy	#.SCRL_START_RIGHT	; 2	     <8?
    313  1cd5		       30 08		      bmi	.skipStartXScroll	; 2/3	     no
    314  1cd7		       a9 22		      lda	#.SCRL_RIGHT_BIT	; 2 = 22    yes, scroll right
    315  1cd9				   .startXScroll
    316  1cd9		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    317  1cdb		       05 9b		      ora	scrollBits	; 3
    318  1cdd		       85 9b		      sta	scrollBits	; 3 =	8
    319  1cdf				   .skipStartXScroll
    320  1cdf
    321  1cdf							; do horizontal scrolling:
    322  1cdf		       a5 9b		      lda	scrollBits	; 3
    323  1ce1		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    324  1ce3		       f0 23		      beq	.skipXScroll	; 2/3
    325  1ce5		       29 22		      and	#.SCRL_RIGHT_BIT	; 2
    326  1ce7		       d0 0c		      bne	.xScrollRight	; 2/3=11/12
    327  1ce9
    328  1ce9							; scroll left:
    329  1ce9		       a5 9a		      lda	BoardScrollX	; 3	     already at left edge?
    330  1ceb		       f0 15		      beq	.stopXScroll	; 2
    331  1ced		       c6 9a		      dec	BoardScrollX	; 5
    332  1cef		       c0 02		      cpy	#.SCRL_STOP_LEFT-1	; 2
    333  1cf1		       10 0f		      bpl	.stopXScroll	; 2/3=15
    334  1cf3		       30 13		      bmi	.skipXScroll	; 3
    335  1cf5							;---------------------------------------
    336  1cf5				   .xScrollRight
    337  1cf5		       a6 9a		      ldx	BoardScrollX	; 3
    338  1cf7		       e8		      inx		; 2
    339  1cf8		       e4 97		      cpx	BoardEdge_Right	; 3	     already at right edge?
    340  1cfa		       10 06		      bpl	.stopXScroll	; 2/3
    341  1cfc		       86 9a		      stx	BoardScrollX	; 3
    342  1cfe		       c0 08		      cpy	#.SCRL_STOP_RIGHT+1	; 2
    343  1d00		       10 06		      bpl	.skipXScroll	; 2/3=17/18
    344  1d02				   .stopXScroll
    345  1d02		       a5 9b		      lda	scrollBits	; 3
    346  1d04		       29 fc		      and	#(~(.SCRL_X_BITS >> 4))	; 2
    347  1d06		       85 9b		      sta	scrollBits	; 3 =	8
    348  1d08				   .skipXScroll
    349  1d08							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    350  1d08
    351  1d08							; *** vertical scrolling (unoptimized version): ***
    352  1d08
    353  1d08							; check for enabling vertical scrolling:
    354  1d08		       a5 a3		      lda	ManY	; 3
    355  1d0a		       38		      sec		; 2
    356  1d0b		       e5 99		      sbc	BoardScrollY	; 3
    357  1d0d		       a8		      tay		; 2	     for later use
    358  1d0e		       a9 44		      lda	#.SCRL_UP_BIT	; 2
    359  1d10		       c0 02		      cpy	#.SCRL_START_UP	; 2	     <2?
    360  1d12		       30 06		      bmi	.startYScroll	; 2/3	     yes, scroll up
    361  1d14		       c0 06		      cpy	#.SCRL_START_DOWN	; 2	     <6?
    362  1d16		       30 08		      bmi	.skipStartYScroll	; 2/3
    363  1d18		       a9 88		      lda	#.SCRL_DOWN_BIT	; 2 = 22    yes, scroll down
    364  1d1a				   .startYScroll
    365  1d1a		       29 0c		      and	#.SCRL_Y_BITS >> 4	; 2
    366  1d1c		       05 9b		      ora	scrollBits	; 3
    367  1d1e		       85 9b		      sta	scrollBits	; 3 =	8
    368  1d20				   .skipStartYScroll
    369  1d20
    370  1d20							; do vertical scrolling:
    371  1d20		       a5 9b		      lda	scrollBits	; 3
    372  1d22		       29 cc		      and	#.SCRL_Y_BITS	; 2
    373  1d24		       f0 23		      beq	.skipYScroll	; 2/3
    374  1d26		       29 88		      and	#.SCRL_DOWN_BIT	; 2
    375  1d28		       d0 0c		      bne	.yScrollDown	; 2/3=11/12
    376  1d2a
    377  1d2a							; scroll up
    378  1d2a		       a5 99		      lda	BoardScrollY	; 3
    379  1d2c		       f0 15		      beq	.stopYScroll	; 2
    380  1d2e		       c6 99		      dec	BoardScrollY	; 5
    381  1d30		       c0 01		      cpy	#.SCRL_STOP_UP-1	; 2
    382  1d32		       10 0f		      bpl	.stopYScroll	; 2/3=15
    383  1d34		       30 13		      bmi	.skipYScroll	; 3
    384  1d36							;---------------------------------------
    385  1d36				   .yScrollDown
    386  1d36		       a6 99		      ldx	BoardScrollY	; 3
    387  1d38		       e8		      inx		; 2
    388  1d39		       e4 98		      cpx	BoardEdge_Bottom	;     ; 3
    389  1d3b		       10 06		      bpl	.stopYScroll	; 2/3
    390  1d3d		       86 99		      stx	BoardScrollY	; 3
    391  1d3f		       c0 07		      cpy	#.SCRL_STOP_DOWN+1	; 2
    392  1d41		       10 06		      bpl	.skipYScroll	; 2/3=17/18
    393  1d43				   .stopYScroll
    394  1d43		       a5 9b		      lda	scrollBits	; 3
    395  1d45		       29 f3		      and	#(~(.SCRL_Y_BITS >> 4))	; 2
    396  1d47		       85 9b		      sta	scrollBits	; 3 =	8
    397  1d49				   .skipYScroll
    398  1d49							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    399  1d49
    400  1d49		       60	   EarlyAbortx rts		; 6 =	6
    401  1d4a							; total: 5+67*2+6 = 145
    402  1d4a
    403  1d4a
    404  1d4a							;------------------------------------------------------------------------------
    405  1d4a
    406  1d4a							; This is a GOOD home for these tables.
    407  1d4a
      0  1d4a					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  1d4a		       00 03	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  1d4a					      SUBROUTINE
      3  1d4a				   TS_PhaseVectorLO
    409  1d4a
    410  1d4a							; Gives LO byte of addresses of subroutines for timeslice processing
    411  1d4a
    412  1d4a		       58		      .byte.b	<ProcessObjStack
    413  1d4b		       ca		      .byte.b	<DrawFullScreen
    414  1d4c		       a3		      .byte.b	<BuildDrawStack
    415  1d4d		       aa		      .byte.b	<DrawAIntoStack
    416  1d4e		       9b		      .byte.b	<SwitchObjects
    417  1d4f
    418  1d4f				   TS_PhaseVectorHI
    419  1d4f
    420  1d4f							; Gives HI byte of addresses of subroutines for timeslice processing
    421  1d4f
    422  1d4f		       f8		      .byte.b	>ProcessObjStack
    423  1d50		       f2		      .byte.b	>DrawFullScreen
    424  1d51		       fb		      .byte.b	>BuildDrawStack
    425  1d52		       fb		      .byte.b	>DrawAIntoStack
    426  1d53		       f8		      .byte.b	>SwitchObjects
    427  1d54
    428  1d54				   TS_PhaseBank
    429  1d54
    430  1d54							; Gives bank of subroutines for timeslice processing
    431  1d54
    432  1d54		       0f		      .byte.b	BANK_ProcessObjStack
    433  1d55		       0c		      .byte.b	BANK_DrawFullScreen
    434  1d56		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    435  1d57		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    436  1d58		       0f		      .byte.b	BANK_SwitchObjects
    437  1d59
    438  1d59							;------------------------------------------------------------------------------
    439  1d59		       02 02	   lookColour2 .byte.b	$02, $02
    440  1d5b		       04 04		      .byte.b	$04, $04
    441  1d5d
    442  1d5d				   OverscanTime
    443  1d5d		       23 23		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    444  1d5f		       29 23		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    445  1d61
    446  1d61		       c0 c0 50 50 FlashColour .byte.b	$C0, $C0, $50, $50
    447  1d65		       30 30 60 60	      .byte.b	$30, $30, $60, $60	; reds - cannot takeback
    448  1d69		       12 12 22 22	      .byte.b	$12, $12, $22, $22	; yellow
    449  1d6d
    450  1d6d
      0  1d6d					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  1d6d		       00 03	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  1d6d					      SUBROUTINE
      3  1d6d				   PostScreenCleanup
    452  1d6d
    453  1d6d		       c8		      iny		; --> 0
    454  1d6e
    455  1d6e		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    456  1d70							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    457  1d70
    458  1d70		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    459  1d72							; TJ: no idea why, but you had removed it in revision 758 ;)
    460  1d72							; completely accidental -- one of our cats may have deleted it.
    461  1d72		       84 4e		      sty	PF1
    462  1d74		       84 4f		      sty	PF2
    463  1d76		       84 5d		      sty	ENAM0
    464  1d78		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    465  1d7a		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    466  1d7c
    467  1d7c							; D1 VBLANK turns off beam
    468  1d7c
    469  1d7c		       a9 42		      lda	#%01000010	; bit6 is not required
    470  1d7e		       85 41		      sta	VBLANK	; end of screen - enter blanking
    471  1d80
    472  1d80							;------------------------------------------------------------------------------
    473  1d80							; This is where the PAL system has a bit of extra time on a per-frame basis.
    474  1d80
    475  1d80		       a6 81		      ldx	Platform
    476  1d82		       bd 5d f5 	      lda	OverscanTime,x
    477  1d85		       8d 96 02 	      sta	TIM64T
    478  1d88
    479  1d88							; Background colour priorities. Increasing order of priority...
    480  1d88							;	black -- nothing happening
    481  1d88							;	looking around			     lookingAround<0		     BLUE
    482  1d88							;	when paused			     gameMode... BIT7		     RED
    483  1d88							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    484  1d88
    485  1d88
    486  1d88							;		  lda LookingAround
    487  1d88							;		  bpl nolooker			  ; if not looking around, that will do nicely
    488  1d88							;		  ldy #0 ;sok
    489  1d88							;;		   ldy lookColour2,x		   ; otherwise, use the lookaround colour as the base
    490  1d88							;nolooker	  sty BGColour			  ; 'BASE' colour pause reverts TO when unpaused
    491  1d88
    492  1d88		       a5 bc		      lda	ThrottleSpeed
    493  1d8a		       18		      clc
    494  1d8b		       65 bb		      adc	Throttle
    495  1d8d		       b0 02		      bcs	noVerflo
    496  1d8f		       85 bb		      sta	Throttle
    497  1d91				   noVerflo
    498  1d91
    499  1d91
    500  1d91							;----------------------------------------------------------------------------------------------
    501  1d91							; handle pause button for 2600 and 7800
    502  1d91
    503  1d91							; Timings:  NOT including palette setting or platform detect
    504  1d91							; 2600:     no button press:	 11 cycles
    505  1d91							;	     with button press:  21 cycles
    506  1d91							; 7800      no button press:	 16 cycles
    507  1d91							;	     with button press:  21 cycles
    508  1d91
    509  1d91
    510  1d91		       00 08	   BW_SWITCH  =	$08	; NOTE: Shares bit position with SWCHB COLOUR/B&W SWITCH
    511  1d91				  -	      if	0
    512  1d91				  -
    513  1d91				  -	      bit	gameMode
    514  1d91				  -	      bvc	.pause7800	; 7800 platform
    515  1d91				  -
    516  1d91				  -			; 2600 pause logic...
    517  1d91				  -
    518  1d91				  -	      lda	SWCHB
    519  1d91				  -	      eor	gameMode
    520  1d91				  -	      and	#BW_SWITCH
    521  1d91				  -	      beq	.setPauseCol	; no different to original state = no pause change
    522  1d91				  -	      bne	.buttonDown	; unconditional
    523  1d91				  -
    524  1d91				  -			; 7800 pause logic...
    525  1d91				  -
    526  1d91				  -			; When the button is pressed, we check if it's the FIRST time it's pressed.
    527  1d91				  -			; This FIRST time is indicated by the PFLAG7800 being clear.  If it's the first time, we toggle the pause
    528  1d91				  -			; flag (BIT6) AND we toggle the PFLAG7800 so continued button-down does nothing.  When the button is
    529  1d91				  -			; released, then we again toggle the PFLAG7800, allowing a FIRST time check once again, when the button
    530  1d91				  -			; is next pressed.
    531  1d91				  -
    532  1d91				  -.pause7800 lda	#BW_SWITCH
    533  1d91				  -	      bit	SWCHB
    534  1d91				  -	      beq	.pausePress
    535  1d91				  -	      ora	gameMode	; not pressed, so enable first time press
    536  1d91				  -	      bne	.fixPause	; unconditional
    537  1d91				  -
    538  1d91				  -.pausePress bit	gameMode
    539  1d91				  -	      beq	.setPauseCol	; NOT the first time in pause - so do nothing new
    540  1d91				  -
    541  1d91				  -			; Button is down, and we have detected it as a FIRST-TIME button press.
    542  1d91				  -
    543  1d91				  -.buttonDown eor	gameMode	; toggle first time flag(7800) or current switch state(2600)
    544  1d91				  -	      eor	#GAMEMODE_PAUSED	; toggle pause flag
    545  1d91				  -.fixPause  sta	gameMode
    546  1d91				  -
    547  1d91				  -.setPauseCol lda	gameMode	; are we paused?
    548  1d91				  -	      bpl	.exitPause	; only show pause colour when actually paused
    549  1d91				  -
    550  1d91				  -	      ldx	Platform
    551  1d91				  -	      lda	pscol,x
    552  1d91				  -	      sta	BGColour	; set main screen background colour.  RED is paused.
    553  1d91				  -
    554  1d91				  -.exitPause
    555  1d91					      endif
    556  1d91
    557  1d91							;----------------------------------------------------------------------------------------------
    558  1d91
    559  1d91							; has to be done AFTER screen display, because it disables the effect!
      0  1d91					      SLEEP	6
      1  1d91				   .CYCLES    SET	6
      2  1d91
      3  1d91				  -	      IF	.CYCLES < 2
      4  1d91				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1d91				  -	      ERR
      6  1d91					      ENDIF
      7  1d91
      8  1d91				  -	      IF	.CYCLES & 1
      9  1d91				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1d91				  -	      nop	0
     11  1d91				  -	      ELSE
     12  1d91				  -	      bit	VSYNC
     13  1d91				  -	      ENDIF
     14  1d91				  -.CYCLES    SET	.CYCLES - 3
     15  1d91					      ENDIF
     16  1d91
     17  1d91					      REPEAT	.CYCLES / 2
     18  1d91		       ea		      nop
     17  1d91					      REPEND
     18  1d92		       ea		      nop
     17  1d92					      REPEND
     18  1d93		       ea		      nop
     19  1d94					      REPEND
    561  1d94							;lda rnd		      ; 3     randomly reposition the Cosmic Ark missile
    562  1d94							;sta HMM0		      ; 3     this assumes that HMOVE is called at least once/frame
    563  1d94
    564  1d94							; "Flash" has highest BG colour priority
    565  1d94
    566  1d94		       a5 cb		      lda	ColourTimer
    567  1d96		       f0 07		      beq	noFlashBG
    568  1d98		       c6 cb		      dec	ColourTimer
    569  1d9a		       a6 cc		      ldx	ColourFlash
    570  1d9c		       bd 61 f5 	      lda	FlashColour,x
    571  1d9f		       85 b7	   noFlashBG  sta	BGColour
    572  1da1
    573  1da1							; Handle the player joystick reading. We do it *every frame* so that we can incorporate a two-frame
    574  1da1							; buffer.  This is designed to give a little better responsiveness to the 'quick tap' movement.
    575  1da1
    576  1da1		       a5 93		      lda	BufferedJoystick	; previous frame
    577  1da3		       85 94		      sta	BufferedJoystick+1	; -> buffered
    578  1da5
    579  1da5
    580  1da5							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    581  1da5							; P2 is shifted UP, so we don't need to worry in usage elsewhere (it's same format as a P1 joystick)
    582  1da5
    583  1da5		       a5 9c		      lda	whichPlayer	; 3
    584  1da7		       25 b0		      and	jtoggle	; 3
    585  1da9		       aa		      tax		; 2
    586  1daa
    587  1daa		       b5 4c		      lda	INPT4,x	; 4
    588  1dac		       25 95		      and	BufferedButton
    589  1dae		       85 95		      sta	BufferedButton	; 3 = 15
    590  1db0
    591  1db0		       ad 80 02 	      lda	SWCHA	; 4
    592  1db3
    593  1db3		       ca		      dex		; 2
    594  1db4		       30 04		      bmi	notP2	; 2/3= 8/9
    595  1db6
    596  1db6		       0a		      asl		; 2
    597  1db7		       0a		      asl		; 2
    598  1db8		       0a		      asl		; 2
    599  1db9		       0a		      asl		; 2 =	8
    600  1dba		       85 93	   notP2      sta	BufferedJoystick	; 3
    601  1dbc
    602  1dbc
    603  1dbc				  -	      if	0
    604  1dbc				  -			; "Scoring timer" reset stomp comment
    605  1dbc				  -
    606  1dbc				  -	      lda	scoringTimer
    607  1dbc				  -	      beq	timer0now
    608  1dbc				  -	      dec	scoringTimer
    609  1dbc				  -	      bne	timer0now
    610  1dbc				  -	      lda	scoringFlags
    611  1dbc				  -	      and	#<(~DISPLAY_FLAGS)	;	 switches to time display
    612  1dbc				  -	      sta	scoringFlags
    613  1dbc				  -timer0now
    614  1dbc					      endif
    615  1dbc
    616  1dbc							; fall through
    617  1dbc
    618  1dbc							;-------------------------------------------------------------------------------------
    619  1dbc							; Player animation happens *every* frame so that we get good animation speeds.  Note that
    620  1dbc							; the player animation consists of running a small animation 'program', and then actually drawing
    621  1dbc							; the player.	The draw is the neat bit, because all it does is update some self-modifying pointers
    622  1dbc							; inside the actual draw kernel in the appropriate bank.
    623  1dbc
    624  1dbc
      0  1dbc					      DEFINE_SUBROUTINE	AnimatePlayers	; in GENERIC_BANK_1
      1  1dbc		       00 03	   BANK_AnimatePlayers =	_CURRENT_BANK
      2  1dbc					      SUBROUTINE
      3  1dbc				   AnimatePlayers
    626  1dbc							; a bigggg ????
    627  1dbc
    628  1dbc							; Optimised 7/1/2012 -- single page tables
    629  1dbc
    630  1dbc							; This interesting code performs the animations for the player(s) and sets the
    631  1dbc							; pointers INSIDE the row bank for the draw code to point to the correct player
    632  1dbc							; shape.  Kind of neat, as it doesn't require any shape copying (=speed!)
    633  1dbc
    634  1dbc
    635  1dbc							; Cycle the player through his animation list.  The animation of a player is a direct
    636  1dbc							; pointer to the actual shape used to display the player.  This shape is in turn
    637  1dbc							; written to the current bank's self-modifying locations for the draw.  Since
    638  1dbc							; we are effectively drawing from this current bank, the same code can be used
    639  1dbc							; to 'undraw' the player as required.
    640  1dbc
    641  1dbc
    642  1dbc							; x = player index
    643  1dbc							; sets ManAnimation = FRAME to display for player
    644  1dbc							; ManAnimation = index of player program into Manimate list
    645  1dbc
    646  1dbc		       24 80		      bit	gameMode
    647  1dbe		       30 2c		      bmi	AnimationOK	; don't animate during pause
    648  1dc0
    649  1dc0		       c6 a7		      dec	ManDelayCount
    650  1dc2		       10 28		      bpl	AnimationOK
    651  1dc4
    652  1dc4		       a4 a8	   ReloadAnimation ldy	ManAnimation
    653  1dc6		       b9 00 f7    ContinueAnim lda	Manimate,y	; delay count
    654  1dc9		       d0 07		      bne	NewFrameOK
    655  1dcb		       b9 01 f7 	      lda	Manimate+1,y
    656  1dce		       a8		      tay
    657  1dcf		       4c c6 f5 	      jmp	ContinueAnim
    658  1dd2
    659  1dd2		       10 0d	   NewFrameOK bpl	doDelay
    660  1dd4
    661  1dd4		       c8		      iny		; handle a REFLECT
    662  1dd5		       a5 ab		      lda	ManLastDirection
    663  1dd7		       29 f7		      and	#%11110111
    664  1dd9		       19 00 f7 	      ora	Manimate,y
    665  1ddc		       85 ab		      sta	ManLastDirection
    666  1dde
    667  1dde		       c8		      iny
    668  1ddf		       d0 e5		      bne	ContinueAnim
    669  1de1
    670  1de1		       85 a7	   doDelay    sta	ManDelayCount
    671  1de3
    672  1de3		       c8		      iny
    673  1de4		       b9 00 f7 	      lda	Manimate,y
    674  1de7		       85 aa		      sta	ManAnimationFrameLO
    675  1de9
    676  1de9		       c8		      iny
    677  1dea		       84 a8		      sty	ManAnimation
    678  1dec
    679  1dec		       60	   AnimationOK rts
    680  1ded
    681  1ded
    682  1ded
    683  1ded		       40 40	   pscol      .byte.b	$40, $40
    684  1def		       60 60		      .byte.b	$60, $60
    685  1df1
    686  1df1							;------------------------------------------------------------------------------
    687  1df1
------- FILE i2c_v2.2.inc LEVEL 3 PASS 4
      0  1df1					      include	"i2c_v2.2.inc"
      1  1df1							;
      2  1df1							; i2c_v2.2.inc
      3  1df1							;
      4  1df1							;
      5  1df1							; AtariVox EEPROM Driver
      6  1df1							;
      7  1df1							; By Alex Herbert, 2004
      8  1df1							;
      9  1df1							; Optimisations by Thomas Jentzsch, 2006/2008
     10  1df1							;
     11  1df1
     12  1df1
     13  1df1							; I/O Constants
     14  1df1
     15  1df1		       00 04	   I2C_SDA_MASK equ	$04
     16  1df1		       00 08	   I2C_SCL_MASK equ	$08
     17  1df1
     18  1df1
     19  1df1							; Signalling Macros
     20  1df1
     21  1df1							;  MAC     I2C_SCL_0
     22  1df1							;    lda     #$00
     23  1df1							;    sta     SWCHA
     24  1df1							;  ENDM
     25  1df1
     26  1df1							;  MAC     I2C_SCL_1
     27  1df1							;    lda     #I2C_SCL_MASK
     28  1df1							;    sta     SWCHA
     29  1df1							;  ENDM
     30  1df1
     31  1df1							;  MAC     I2C_SDA_IN
     32  1df1							;    lda     #I2C_SCL_MASK
     33  1df1							;    sta     SWACNT
     34  1df1							;  ENDM
     35  1df1
     36  1df1							;  MAC     I2C_SDA_OUT
     37  1df1							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  1df1							;    sta     SWACNT
     39  1df1							;  ENDM
     40  1df1
     41  1df1
     42  1df1					      MAC	i2c_start
     43  1df1							; I2C_SCL_1
     44  1df1					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  1df1					      sta	SWCHA	; 4
     46  1df1							; I2C_SDA_OUT
     47  1df1					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  1df1					      sta	SWACNT	; 4
     49  1df1							; total: 12 cycles
     50  1df1					      ENDM
     51  1df1
     52  1df1
     53  1df1					      MAC	i2c_txbit
     54  1df1							; I2C_SCL_0
     55  1df1					      lda	#%0011	; 2
     56  1df1					      sta	SWCHA	; 4
     57  1df1							; set bit
     58  1df1					      adc	#%1000	; 2
     59  1df1					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  1df1							; I2C_SCL_1
     61  1df1					      lda	#I2C_SCL_MASK	; 2
     62  1df1					      sta	SWCHA	; 4
     63  1df1							; total: 18 cycles
     64  1df1					      ENDM
     65  1df1
     66  1df1
     67  1df1					      MAC	i2c_txnack
     68  1df1							; I2C_SCL_0
     69  1df1					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  1df1					      sta	SWCHA	; 4
     71  1df1							; I2C_SDA_IN
     72  1df1					      lsr		; 2	     I2C_SCL_MASK
     73  1df1					      sta	SWACNT	; 4
     74  1df1							; I2C_SCL_1
     75  1df1					      nop		; 2	     required for timing!
     76  1df1					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  1df1							; total: 18 cycles
     78  1df1					      ENDM
     79  1df1
     80  1df1
     81  1df1							; Subroutine Macros
     82  1df1
     83  1df1					      MAC	i2c_subs
     84  1df1
     85  1df1				   i2c_startread
     86  1df1							; use V to flag if previous byte needs ACK
     87  1df1					      ldy	#%10100001	; 2	     eeprom read command
     88  1df1					      .byte	$2c	; 2
     89  1df1				   i2c_startwrite
     90  1df1					      ldy	#%10100000	; 2	     eeprom write command
     91  1df1					      I2C_START		;12	     start signal (clears V flag)
     92  1df1					      tya		; 2 = 16
     93  1df1				   i2c_txbyte
     94  1df1					      eor	#$ff	; 2	     invert data byte
     95  1df1					      sec		; 2
     96  1df1					      rol		; 2 =	6    shift loop bit into a
     97  1df1				   i2c_txbyteloop
     98  1df1					      tay		; 2
     99  1df1					      I2C_TXBIT		;18	     transmit
    100  1df1					      tya		; 2
    101  1df1					      asl		; 2	     shift next bit into C
    102  1df1					      bne	i2c_txbyteloop	; 2= 26/27
    103  1df1
    104  1df1							; receive acknowledge bit
    105  1df1
    106  1df1					      beq	i2c_rxbit	;43 = 43
    107  1df1							; i2c_txbyte: 264 cycles
    108  1df1							;-------------------------------------------------------------------------------
    109  1df1
    110  1df1				   i2c_rxbyte
    111  1df1					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  1df1					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  1df1
    114  1df1				   i2c_rxskipack
    115  1df1					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  1df1
    117  1df1					      lda	#1	; 2
    118  1df1				   i2c_rxbyteloop
    119  1df1					      tay		; 2 =	2
    120  1df1				   i2c_rxbit		;	     receive bit in C
    121  1df1					      I2C_TXNACK		;18 = 18
    122  1df1
    123  1df1					      lda	SWCHA	; 4
    124  1df1					      lsr		; 2
    125  1df1					      lsr		; 2
    126  1df1					      lsr		; 2 = 10    C = SDA
    127  1df1
    128  1df1					      tya		; 2
    129  1df1					      rol		; 2	     rotate into Y
    130  1df1					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  1df1
    132  1df1							; received byte in A
    133  1df1					      rts		; 6 =	6
    134  1df1							; i2c_rxbit:  40 cycles
    135  1df1							; i2c_rxbyte: 310/333 cycles
    136  1df1							;-------------------------------------------------------------------------------
    137  1df1
    138  1df1				   i2c_stopread
    139  1df1					      bvc	i2c_stopwrite	; 2
    140  1df1					      ldy	#$80	; 2
    141  1df1					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  1df1
    143  1df1				   i2c_stopwrite
    144  1df1					      jsr	i2c_txack	;30
    145  1df1
    146  1df1							; return port to input mode
    147  1df1					      lda	#0	; 2	     0
    148  1df1					      sta	SWACNT	; 4
    149  1df1					      rts		; 6 = 12
    150  1df1							; i2c_stopread:  45/92
    151  1df1							; i2c_stopwrite: 42
    152  1df1							;-------------------------------------------------------------------------------
    153  1df1
    154  1df1				   i2c_txack
    155  1df1							; I2C_SCL_0
    156  1df1					      lda	#0	; 2	     $00
    157  1df1					      sta	SWCHA	; 4
    158  1df1							; I2C_SDA_OUT
    159  1df1					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  1df1					      sta	SWACNT	; 4
    161  1df1							; I2C_SCL_1
    162  1df1					      asl		; 2	     I2C_SCL_MASK
    163  1df1					      sta	SWCHA	; 4
    164  1df1
    165  1df1					      rts		; 6
    166  1df1							; total: 24 cycles
    167  1df1							;-------------------------------------------------------------------------------
    168  1df1
    169  1df1					      ENDM
    170  1df1
    171  1df1
    172  1df1
------- FILE BANK_GENERIC.asm
    689  1df1
      0  1df1					      i2c_subs
      1  1df1
      2  1df1				   i2c_startread
      3  1df1
      4  1df1		       a0 a1		      ldy	#%10100001
      5  1df3		       2c		      .byte.b	$2c
      6  1df4				   i2c_startwrite
      7  1df4		       a0 a0		      ldy	#%10100000
      0  1df6					      I2C_START
      1  1df6
      2  1df6		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  1df8		       8d 80 02 	      sta	SWCHA
      4  1dfb
      5  1dfb		       4a		      lsr
      6  1dfc		       8d 81 02 	      sta	SWACNT
      7  1dff
      9  1dff		       98		      tya
     10  1e00				   i2c_txbyte
     11  1e00		       49 ff		      eor	#$ff
     12  1e02		       38		      sec
     13  1e03		       2a		      rol
     14  1e04				   i2c_txbyteloop
     15  1e04		       a8		      tay
      0  1e05					      I2C_TXBIT
      1  1e05
      2  1e05		       a9 03		      lda	#%0011
      3  1e07		       8d 80 02 	      sta	SWCHA
      4  1e0a
      5  1e0a		       69 08		      adc	#%1000
      6  1e0c		       8d 81 02 	      sta	SWACNT
      7  1e0f
      8  1e0f		       a9 08		      lda	#I2C_SCL_MASK
      9  1e11		       8d 80 02 	      sta	SWCHA
     10  1e14
     17  1e14		       98		      tya
     18  1e15		       0a		      asl
     19  1e16		       d0 ec		      bne	i2c_txbyteloop
     20  1e18
     21  1e18
     22  1e18
     23  1e18		       f0 0b		      beq	i2c_rxbit
     24  1e1a
     25  1e1a
     26  1e1a
     27  1e1a				   i2c_rxbyte
     28  1e1a		       50 03		      bvc	i2c_rxskipack
     29  1e1c		       20 4d f6 	      jsr	i2c_txack
     30  1e1f
     31  1e1f				   i2c_rxskipack
     32  1e1f		       2c 1a f6 	      bit	i2c_rxbyte
     33  1e22
     34  1e22		       a9 01		      lda	#1
     35  1e24				   i2c_rxbyteloop
     36  1e24		       a8		      tay
     37  1e25				   i2c_rxbit
      0  1e25					      I2C_TXNACK
      1  1e25
      2  1e25		       a9 10		      lda	#I2C_SCL_MASK*2
      3  1e27		       8d 80 02 	      sta	SWCHA
      4  1e2a
      5  1e2a		       4a		      lsr
      6  1e2b		       8d 81 02 	      sta	SWACNT
      7  1e2e
      8  1e2e		       ea		      nop
      9  1e2f		       8d 80 02 	      sta	SWCHA
     10  1e32
     39  1e32
     40  1e32		       ad 80 02 	      lda	SWCHA
     41  1e35		       4a		      lsr
     42  1e36		       4a		      lsr
     43  1e37		       4a		      lsr
     44  1e38
     45  1e38		       98		      tya
     46  1e39		       2a		      rol
     47  1e3a		       90 e8		      bcc	i2c_rxbyteloop
     48  1e3c
     49  1e3c
     50  1e3c		       60		      rts
     51  1e3d
     52  1e3d
     53  1e3d
     54  1e3d
     55  1e3d				   i2c_stopread
     56  1e3d		       50 05		      bvc	i2c_stopwrite
     57  1e3f		       a0 80		      ldy	#$80
     58  1e41		       20 25 f6 	      jsr	i2c_rxbit
     59  1e44
     60  1e44				   i2c_stopwrite
     61  1e44		       20 4d f6 	      jsr	i2c_txack
     62  1e47
     63  1e47
     64  1e47		       a9 00		      lda	#0
     65  1e49		       8d 81 02 	      sta	SWACNT
     66  1e4c		       60		      rts
     67  1e4d
     68  1e4d
     69  1e4d
     70  1e4d
     71  1e4d				   i2c_txack
     72  1e4d
     73  1e4d		       a9 00		      lda	#0
     74  1e4f		       8d 80 02 	      sta	SWCHA
     75  1e52
     76  1e52		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  1e54		       8d 81 02 	      sta	SWACNT
     78  1e57
     79  1e57		       0a		      asl
     80  1e58		       8d 80 02 	      sta	SWCHA
     81  1e5b
     82  1e5b		       60		      rts
     83  1e5c
     84  1e5c
     85  1e5c
    691  1e5c
    692  1e5c				   HandleSaveKey SUBROUTINE
    693  1e5c
    694  1e5c		       2f 00	   SAVEKEY_ADR =	$2F00	;	     tentative address for Sokoban (64 bytes)
    695  1e5c
    696  1e5c							;------------------------------------------------------------------------------
      0  1e5c					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  1e5c		       00 03	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  1e5c					      SUBROUTINE
      3  1e5c				   ReadSaveKey
    698  1e5c
    699  1e5c							; assume no SaveKey found:
    700  1e5c		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    701  1e5e		       85 e7		      sta	highScoreSK+2	; 3
    702  1e60
    703  1e60							; setup SaveKey:
    704  1e60		       a5 e8		      lda	startingLevel	; 3	     load start levelX*5 and level
    705  1e62		       a6 b9		      ldx	level	; 3
    706  1e64		       20 9d f6 	      jsr	SetupSaveKey	;6+853
    707  1e67		       90 52		      bcc	NoSKfound	; 2/3
    708  1e69
    709  1e69							;    lda     #$34
    710  1e69							;    sta     COLUBK
    711  1e69
    712  1e69							; start read
    713  1e69		       20 44 f6 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    714  1e6c		       20 f1 f5 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    715  1e6f
    716  1e6f							; read high score:
    717  1e6f		       a2 02		      ldx	#3-1	; 2 = 1187
    718  1e71				   .loopRead
    719  1e71		       20 1a f6 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    720  1e74		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    721  1e76		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    722  1e78		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    723  1e7a				   .skipEmpty
    724  1e7a		       95 e5		      sta	highScoreSK,x	; 4
    725  1e7c		       ca		      dex		; 2
    726  1e7d		       10 f2		      bpl	.loopRead	; 2/3= 354
    727  1e7f
    728  1e7f							; stop read:
    729  1e7f		       4c 3d f6 	      jmp	i2c_stopread	;3+92=95    terminate read
    730  1e82
    731  1e82							;------------------------------------------------------------------------------
      0  1e82					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  1e82		       00 03	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  1e82					      SUBROUTINE
      3  1e82				   WriteSaveKey
    733  1e82
    734  1e82							; check if new high score:
    735  1e82		       a6 e5		      ldx	highScoreSK	; 3
    736  1e84		       e8		      inx		; 2
    737  1e85		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    738  1e87
    739  1e87							; setup SaveKey:
    740  1e87		       a5 e8		      lda	startingLevel	; 3	     load start levelX*5 and level
    741  1e89		       a6 e9		      ldx	startLevel	; 3
    742  1e8b		       20 9d f6 	      jsr	SetupSaveKey	; 6+853
    743  1e8e		       90 2b		      bcc	NoSKfound	; 2/3
    744  1e90
    745  1e90							;    lda     #$64
    746  1e90							;    sta     COLUBK
    747  1e90
    748  1e90							; write high score:
    749  1e90		       a2 02		      ldx	#3-1	; 2 = 841
    750  1e92				   .loopWrite
    751  1e92		       b5 e5		      lda	highScoreSK,x	; 4
    752  1e94		       20 00 f6 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    753  1e97		       ca		      dex		; 2
    754  1e98		       10 f8		      bpl	.loopWrite	; 2/3= 837
    755  1e9a
    756  1e9a							; stop write:
    757  1e9a		       4c 44 f6 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    758  1e9d
    759  1e9d
    760  1e9d							;------------------------------------------------------------------------------
      0  1e9d					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  1e9d		       00 03	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  1e9d					      SUBROUTINE
      3  1e9d				   SetupSaveKey
    762  1e9d
    763  1e9d							; calculate slot;
    764  1e9d							; a = levelX
    765  1e9d							; x = level (0..4)
    766  1e9d		       85 ea		      sta	offsetSK	; 3
    767  1e9f		       8a		      txa		; 2
    768  1ea0		       18		      clc		; 2
    769  1ea1		       65 ea		      adc	offsetSK	; 3
    770  1ea3		       85 ea		      sta	offsetSK	; 3
    771  1ea5		       0a		      asl		; 2	     multiply by 3
    772  1ea6		       65 ea		      adc	offsetSK	; 3
    773  1ea8		       69 00		      adc	#<SAVEKEY_ADR	; 2
    774  1eaa		       aa		      tax		; 2 = 22
    775  1eab							; detect SaveKey:
    776  1eab		       20 f4 f5 	      jsr	i2c_startwrite	;6+280
    777  1eae		       d0 0a		      bne	.exitSK	; 2/3
    778  1eb0
    779  1eb0							; setup address:
    780  1eb0		       b8		      clv		; 2
    781  1eb1		       a9 2f		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    782  1eb3		       20 00 f6 	      jsr	i2c_txbyte	;6+264
    783  1eb6		       8a		      txa		; 2	     x = lower byte offset
    784  1eb7		       4c 00 f6 	      jmp	i2c_txbyte	;3+264      returns C==1
    785  1eba
    786  1eba				   .exitSK
    787  1eba		       18		      clc
    788  1ebb				   NoSKfound
    789  1ebb		       60		      rts
    790  1ebb					      ENDIF
    791  1ebc
    792  1f00		       00 00 00 00*	      align	256
    793  1f00
    794  1f00				   Manimate
    795  1f00				   AnimateSTAND
    796  1f00				   AnimateRIGHT
    797  1f00				   AnimateLEFT
    798  1f00				   AnimateUP
    799  1f00				   AnimateSTOPPED
    800  1f00		       7f		      .byte.b	127
    801  1f01		       ce		      .byte.b	<PLAYER_RIGHT0	;PLAYER_STAND
    802  1f02							;.byte 10
    803  1f02							;.byte < PLAYER_BLINK
    804  1f02							;.byte 127
    805  1f02							;.byte < PLAYER_STAND
    806  1f02							;.byte 0
    807  1f02							;.word AnimateTAP
    808  1f02
    809  1f02				   AnimateTAP
    810  1f02							;.byte 128, %0 		  ; reflect off, always tap with left foot
    811  1f02							;.byte 8
    812  1f02							;.byte < PLAYER_TAP0
    813  1f02							;.byte 8
    814  1f02							;.byte < PLAYER_TAP1
    815  1f02							;.byte 8
    816  1f02							;.byte < PLAYER_TAP0
    817  1f02							;.byte 8
    818  1f02							;.byte < PLAYER_TAP1
    819  1f02							;.byte 8
    820  1f02							;.byte < PLAYER_TAP0
    821  1f02							;.byte 8
    822  1f02							;.byte < PLAYER_TAP1
    823  1f02		       00		      .byte.b	0
    824  1f03		       00		      .byte.b	AnimateSTAND-Manimate	;word AnimateSTAND
    825  1f04
    826  1f04							;AnimateRIGHT
    827  1f04		       80 00		      .byte.b	128, %0	; reflect off
    828  1f06		       05		      .byte.b	5
    829  1f07		       ce		      .byte.b	< PLAYER_RIGHT0
    830  1f08		       05		      .byte.b	5
    831  1f09		       e6		      .byte.b	< PLAYER_RIGHT1
    832  1f0a		       00		      .byte.b	0
    833  1f0b		       00		      .byte.b	AnimateRIGHT-Manimate	;word AnimateRIGHT
    834  1f0c
    835  1f0c							;AnimateLEFT
    836  1f0c		       80 08		      .byte.b	128, %1000	; reflect ON
    837  1f0e		       05		      .byte.b	5
    838  1f0f		       ce		      .byte.b	< PLAYER_RIGHT0
    839  1f10		       05		      .byte.b	5
    840  1f11		       e6		      .byte.b	< PLAYER_RIGHT1
    841  1f12		       00		      .byte.b	0
    842  1f13		       00		      .byte.b	AnimateLEFT-Manimate	;word AnimateLEFT
    843  1f14
    844  1f14							;AnimateUP
    845  1f14							;    .byte 128, %0		   ; reflect off
    846  1f14							;    .byte 5
    847  1f14							;    .byte < PLAYER_TAP
    848  1f14							;    .byte 128, %1000
    849  1f14							;    .byte 5
    850  1f14							;    .byte < PLAYER_TAP
    851  1f14							;    .byte 0
    852  1f14							;    .word AnimateUP
    853  1f14
    854  1f14							;AnimateUP
    855  1f14		       05		      .byte.b	5
    856  1f15		       ce		      .byte.b	< PLAYER_RIGHT0
    857  1f16		       05		      .byte.b	5
    858  1f17		       e6		      .byte.b	< PLAYER_RIGHT1
    859  1f18		       00		      .byte.b	0
    860  1f19		       00		      .byte.b	AnimateUP-Manimate	;word AnimateUP
    861  1f1a
    862  1f1a				   AnimateBLANK
    863  1f1a		       7f		      .byte.b	127
    864  1f1b		       b6		      .byte.b	< PLAYER_BLANK
    865  1f1c		       00		      .byte.b	0
    866  1f1d		       1a		      .byte.b	AnimateBLANK-Manimate	;word AnimateBLANK
    867  1f1e
    868  1f1e				   AnimateEND
      0  1f1e					      CHECKPAGEX	Manimate, "AnimateEND @ BANK_GENERIC"
      9  1f1e					      LIST	ON
    870  1f1e
    871  1f1e
      0  1f1e					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  1f1e		       07 1e	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $71e , FREE= $e2
      2  1f1e					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1f1e				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1f1e				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1f1e				  -	      ERR
      6  1f1e					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS1.asm LEVEL 2 PASS 4
      0  1f1e					      include	"BANK_LEVELS1.asm"
      1  1f1e							;    Sokoboo - a Sokoban implementation
      2  1f1e							;    using a generic tile-based display engine for the Atari 2600
      3  1f1e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1f1e							;
      5  1f1e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1f1e							;
      7  1f1e							;    Code related to the generic tile-based display engine was developed by
      8  1f1e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1f1e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1f1e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1f1e							;
     12  1f1e							;    Code related to music and sound effects uses the TIATracker music player
     13  1f1e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1f1e							;    directory for Apache licensing details.
     15  1f1e							;
     16  1f1e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1f1e							;    See the copyright notices in the License directory for a list of level
     18  1f1e							;    contributors.
     19  1f1e							;
     20  1f1e							;    Except where otherwise indicated, this software is released under the
     21  1f1e							;    following licensing arrangement...
     22  1f1e							;
     23  1f1e							;    This program is free software: you can redistribute it and/or modify
     24  1f1e							;    it under the terms of the GNU General Public License as published by
     25  1f1e							;    the Free Software Foundation, either version 3 of the License, or
     26  1f1e							;    (at your option) any later version.
     27  1f1e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1f1e
     29  1f1e							;    This program is distributed in the hope that it will be useful,
     30  1f1e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1f1e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1f1e							;    GNU General Public License for more details.
     33  1f1e
      0  1f1e					      NEWBANK	LEVELS1
      1  27b5 ????				      SEG	LEVELS1
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   LEVELS1    SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	LEVELS1
     35  2000
     36  2000
     37  2000							;  DEFL _000_SELECT, "12#|#@3-5$.#|10-|10-|12#"
     38  2000
     39  2000							; "SOKWHOLE" collection...
     40  2000
     41  2000
      0  2000					      DEFL	_001_L, "3#|#@#|#$#|#.#|3#"
      0  2000					      START_LEVEL	_001_L
      1  2000				   LEVEL_START SET	*
      2  2000		       00 04	   BANK_LEVEL__001_L =	_CURRENT_BANK
      3  2000				   LEVEL__001_L SUBROUTINE
      4  2000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2000
      2  2000		       33 23 7c 23*	      .byte.b	"3#|#@#|#$#|#.#|3#",0
      0  2012					      END_LEVEL	_001_L
      1  2012		       00 12	   LEVEL_SIZE__001_L =	* - LEVEL_START
      2  2012					      IF	LEVEL_SIZE__001_L > MAX_LEVEL_SIZE
      3  2012				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_L
      4  2012					      ENDIF
      0  2012					      DEFL	_001_R, "5#|#.$@#|5#"
      0  2012					      START_LEVEL	_001_R
      1  2012				   LEVEL_START SET	*
      2  2012		       00 04	   BANK_LEVEL__001_R =	_CURRENT_BANK
      3  2012				   LEVEL__001_R SUBROUTINE
      4  2012				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2012
      2  2012		       35 23 7c 23*	      .byte.b	"5#|#.$@#|5#",0
      0  201e					      END_LEVEL	_001_R
      1  201e		       00 0c	   LEVEL_SIZE__001_R =	* - LEVEL_START
      2  201e				  -	      IF	LEVEL_SIZE__001_R > MAX_LEVEL_SIZE
      3  201e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_R
      4  201e					      ENDIF
      0  201e					      DEFL	_002_L, "3#2-|#.3#|#*$-#|#2-@#|5#"
      0  201e					      START_LEVEL	_002_L
      1  201e				   LEVEL_START SET	*
      2  201e		       00 04	   BANK_LEVEL__002_L =	_CURRENT_BANK
      3  201e				   LEVEL__002_L SUBROUTINE
      4  201e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  201e
      2  201e		       33 23 32 2d*	      .byte.b	"3#2-|#.3#|#*$-#|#2-@#|5#",0
      0  2037					      END_LEVEL	_002_L
      1  2037		       00 19	   LEVEL_SIZE__002_L =	* - LEVEL_START
      2  2037					      IF	LEVEL_SIZE__002_L > MAX_LEVEL_SIZE
      3  2037				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_L
      4  2037					      ENDIF
      0  2037					      DEFL	_002_R, "2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#"
      0  2037					      START_LEVEL	_002_R
      1  2037				   LEVEL_START SET	*
      2  2037		       00 04	   BANK_LEVEL__002_R =	_CURRENT_BANK
      3  2037				   LEVEL__002_R SUBROUTINE
      4  2037				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2037
      2  2037		       32 2d 35 23*	      .byte.b	"2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#",0
      0  205f					      END_LEVEL	_002_R
      1  205f		       00 28	   LEVEL_SIZE__002_R =	* - LEVEL_START
      2  205f					      IF	LEVEL_SIZE__002_R > MAX_LEVEL_SIZE
      3  205f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_R
      4  205f					      ENDIF
      0  205f					      DEFL	_003_L, "4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-"
      0  205f					      START_LEVEL	_003_L
      1  205f				   LEVEL_START SET	*
      2  205f		       00 04	   BANK_LEVEL__003_L =	_CURRENT_BANK
      3  205f				   LEVEL__003_L SUBROUTINE
      4  205f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  205f
      2  205f		       34 2d 35 23*	      .byte.b	"4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-",0
      0  208b					      END_LEVEL	_003_L
      1  208b		       00 2c	   LEVEL_SIZE__003_L =	* - LEVEL_START
      2  208b					      IF	LEVEL_SIZE__003_L > MAX_LEVEL_SIZE
      3  208b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_L
      4  208b					      ENDIF
      0  208b					      DEFL	_003_R, "9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-"
      0  208b					      START_LEVEL	_003_R
      1  208b				   LEVEL_START SET	*
      2  208b		       00 04	   BANK_LEVEL__003_R =	_CURRENT_BANK
      3  208b				   LEVEL__003_R SUBROUTINE
      4  208b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  208b
      2  208b		       39 23 7c 23*	      .byte.b	"9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-",0
      0  20b5					      END_LEVEL	_003_R
      1  20b5		       00 2a	   LEVEL_SIZE__003_R =	* - LEVEL_START
      2  20b5				  -	      IF	LEVEL_SIZE__003_R > MAX_LEVEL_SIZE
      3  20b5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_R
      4  20b5					      ENDIF
      0  20b5					      DEFL	_004_L, "5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-"
      0  20b5					      START_LEVEL	_004_L
      1  20b5				   LEVEL_START SET	*
      2  20b5		       00 04	   BANK_LEVEL__004_L =	_CURRENT_BANK
      3  20b5				   LEVEL__004_L SUBROUTINE
      4  20b5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20b5
      2  20b5		       35 23 2d 7c*	      .byte.b	"5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-",0
      0  20d8					      END_LEVEL	_004_L
      1  20d8		       00 23	   LEVEL_SIZE__004_L =	* - LEVEL_START
      2  20d8				  -	      IF	LEVEL_SIZE__004_L > MAX_LEVEL_SIZE
      3  20d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_L
      4  20d8					      ENDIF
      0  20d8					      DEFL	_004_R, "-6#|-#4-#|2#-$*$#|#@$3.#|7#"
      0  20d8					      START_LEVEL	_004_R
      1  20d8				   LEVEL_START SET	*
      2  20d8		       00 04	   BANK_LEVEL__004_R =	_CURRENT_BANK
      3  20d8				   LEVEL__004_R SUBROUTINE
      4  20d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20d8
      2  20d8		       2d 36 23 7c*	      .byte.b	"-6#|-#4-#|2#-$*$#|#@$3.#|7#",0
      0  20f4					      END_LEVEL	_004_R
      1  20f4		       00 1c	   LEVEL_SIZE__004_R =	* - LEVEL_START
      2  20f4				  -	      IF	LEVEL_SIZE__004_R > MAX_LEVEL_SIZE
      3  20f4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_R
      4  20f4					      ENDIF
      0  20f4					      DEFL	_005_L, "3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-"
      0  20f4					      START_LEVEL	_005_L
      1  20f4				   LEVEL_START SET	*
      2  20f4		       00 04	   BANK_LEVEL__005_L =	_CURRENT_BANK
      3  20f4				   LEVEL__005_L SUBROUTINE
      4  20f4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20f4
      2  20f4		       33 2d 35 23*	      .byte.b	"3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-",0
      0  2126					      END_LEVEL	_005_L
      1  2126		       00 32	   LEVEL_SIZE__005_L =	* - LEVEL_START
      2  2126					      IF	LEVEL_SIZE__005_L > MAX_LEVEL_SIZE
      3  2126				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_L
      4  2126					      ENDIF
      0  2126					      DEFL	_005_R, "6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-"
      0  2126					      START_LEVEL	_005_R
      1  2126				   LEVEL_START SET	*
      2  2126		       00 04	   BANK_LEVEL__005_R =	_CURRENT_BANK
      3  2126				   LEVEL__005_R SUBROUTINE
      4  2126				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2126
      2  2126		       36 23 32 2d*	      .byte.b	"6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-",0
      0  2165					      END_LEVEL	_005_R
      1  2165		       00 3f	   LEVEL_SIZE__005_R =	* - LEVEL_START
      2  2165					      IF	LEVEL_SIZE__005_R > MAX_LEVEL_SIZE
      3  2165				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_R
      4  2165					      ENDIF
      0  2165					      DEFL	_006_L, "5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-"
      0  2165					      START_LEVEL	_006_L
      1  2165				   LEVEL_START SET	*
      2  2165		       00 04	   BANK_LEVEL__006_L =	_CURRENT_BANK
      3  2165				   LEVEL__006_L SUBROUTINE
      4  2165				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2165
      2  2165		       35 23 33 2d*	      .byte.b	"5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-",0
      0  21a0					      END_LEVEL	_006_L
      1  21a0		       00 3b	   LEVEL_SIZE__006_L =	* - LEVEL_START
      2  21a0				  -	      IF	LEVEL_SIZE__006_L > MAX_LEVEL_SIZE
      3  21a0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_L
      4  21a0					      ENDIF
      0  21a0					      DEFL	_006_R, "3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-"
      0  21a0					      START_LEVEL	_006_R
      1  21a0				   LEVEL_START SET	*
      2  21a0		       00 04	   BANK_LEVEL__006_R =	_CURRENT_BANK
      3  21a0				   LEVEL__006_R SUBROUTINE
      4  21a0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21a0
      2  21a0		       33 23 34 2d*	      .byte.b	"3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-",0
      0  21de					      END_LEVEL	_006_R
      1  21de		       00 3e	   LEVEL_SIZE__006_R =	* - LEVEL_START
      2  21de				  -	      IF	LEVEL_SIZE__006_R > MAX_LEVEL_SIZE
      3  21de				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_R
      4  21de					      ENDIF
      0  21de					      DEFL	_007_L, "6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#"
      0  21de					      START_LEVEL	_007_L
      1  21de				   LEVEL_START SET	*
      2  21de		       00 04	   BANK_LEVEL__007_L =	_CURRENT_BANK
      3  21de				   LEVEL__007_L SUBROUTINE
      4  21de				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21de
      2  21de		       36 23 2d 7c*	      .byte.b	"6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#",0
      0  220b					      END_LEVEL	_007_L
      1  220b		       00 2d	   LEVEL_SIZE__007_L =	* - LEVEL_START
      2  220b				  -	      IF	LEVEL_SIZE__007_L > MAX_LEVEL_SIZE
      3  220b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_L
      4  220b					      ENDIF
      0  220b					      DEFL	_007_R, "4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#"
      0  220b					      START_LEVEL	_007_R
      1  220b				   LEVEL_START SET	*
      2  220b		       00 04	   BANK_LEVEL__007_R =	_CURRENT_BANK
      3  220b				   LEVEL__007_R SUBROUTINE
      4  220b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  220b
      2  220b		       34 23 34 2d*	      .byte.b	"4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#",0
      0  223e					      END_LEVEL	_007_R
      1  223e		       00 33	   LEVEL_SIZE__007_R =	* - LEVEL_START
      2  223e				  -	      IF	LEVEL_SIZE__007_R > MAX_LEVEL_SIZE
      3  223e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_R
      4  223e					      ENDIF
      0  223e					      DEFL	_008_L, "2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-"
      0  223e					      START_LEVEL	_008_L
      1  223e				   LEVEL_START SET	*
      2  223e		       00 04	   BANK_LEVEL__008_L =	_CURRENT_BANK
      3  223e				   LEVEL__008_L SUBROUTINE
      4  223e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  223e
      2  223e		       32 2d 35 23*	      .byte.b	"2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-",0
      0  2274					      END_LEVEL	_008_L
      1  2274		       00 36	   LEVEL_SIZE__008_L =	* - LEVEL_START
      2  2274				  -	      IF	LEVEL_SIZE__008_L > MAX_LEVEL_SIZE
      3  2274				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_L
      4  2274					      ENDIF
      0  2274					      DEFL	_008_R, "-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#"
      0  2274					      START_LEVEL	_008_R
      1  2274				   LEVEL_START SET	*
      2  2274		       00 04	   BANK_LEVEL__008_R =	_CURRENT_BANK
      3  2274				   LEVEL__008_R SUBROUTINE
      4  2274				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2274
      2  2274		       2d 35 23 33*	      .byte.b	"-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#",0
      0  22a5					      END_LEVEL	_008_R
      1  22a5		       00 31	   LEVEL_SIZE__008_R =	* - LEVEL_START
      2  22a5				  -	      IF	LEVEL_SIZE__008_R > MAX_LEVEL_SIZE
      3  22a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_R
      4  22a5					      ENDIF
      0  22a5					      DEFL	_009_L, "-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#"
      0  22a5					      START_LEVEL	_009_L
      1  22a5				   LEVEL_START SET	*
      2  22a5		       00 04	   BANK_LEVEL__009_L =	_CURRENT_BANK
      3  22a5				   LEVEL__009_L SUBROUTINE
      4  22a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22a5
      2  22a5		       2d 35 23 2d*	      .byte.b	"-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#",0
      0  22d7					      END_LEVEL	_009_L
      1  22d7		       00 32	   LEVEL_SIZE__009_L =	* - LEVEL_START
      2  22d7				  -	      IF	LEVEL_SIZE__009_L > MAX_LEVEL_SIZE
      3  22d7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_L
      4  22d7					      ENDIF
      0  22d7					      DEFL	_009_R, "-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#"
      0  22d7					      START_LEVEL	_009_R
      1  22d7				   LEVEL_START SET	*
      2  22d7		       00 04	   BANK_LEVEL__009_R =	_CURRENT_BANK
      3  22d7				   LEVEL__009_R SUBROUTINE
      4  22d7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22d7
      2  22d7		       2d 33 23 33*	      .byte.b	"-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#",0
      0  2307					      END_LEVEL	_009_R
      1  2307		       00 30	   LEVEL_SIZE__009_R =	* - LEVEL_START
      2  2307				  -	      IF	LEVEL_SIZE__009_R > MAX_LEVEL_SIZE
      3  2307				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_R
      4  2307					      ENDIF
      0  2307					      DEFL	_010_L, "2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-"
      0  2307					      START_LEVEL	_010_L
      1  2307				   LEVEL_START SET	*
      2  2307		       00 04	   BANK_LEVEL__010_L =	_CURRENT_BANK
      3  2307				   LEVEL__010_L SUBROUTINE
      4  2307				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2307
      2  2307		       32 2d 33 23*	      .byte.b	"2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-",0
      0  2341					      END_LEVEL	_010_L
      1  2341		       00 3a	   LEVEL_SIZE__010_L =	* - LEVEL_START
      2  2341				  -	      IF	LEVEL_SIZE__010_L > MAX_LEVEL_SIZE
      3  2341				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_L
      4  2341					      ENDIF
      0  2341					      DEFL	_010_R, "4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-"
      0  2341					      START_LEVEL	_010_R
      1  2341				   LEVEL_START SET	*
      2  2341		       00 04	   BANK_LEVEL__010_R =	_CURRENT_BANK
      3  2341				   LEVEL__010_R SUBROUTINE
      4  2341				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2341
      2  2341		       34 23 32 2d*	      .byte.b	"4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-",0
      0  2374					      END_LEVEL	_010_R
      1  2374		       00 33	   LEVEL_SIZE__010_R =	* - LEVEL_START
      2  2374				  -	      IF	LEVEL_SIZE__010_R > MAX_LEVEL_SIZE
      3  2374				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_R
      4  2374					      ENDIF
      0  2374					      DEFL	_011_L, "-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-"
      0  2374					      START_LEVEL	_011_L
      1  2374				   LEVEL_START SET	*
      2  2374		       00 04	   BANK_LEVEL__011_L =	_CURRENT_BANK
      3  2374				   LEVEL__011_L SUBROUTINE
      4  2374				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2374
      2  2374		       2d 34 23 32*	      .byte.b	"-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-",0
      0  23a7					      END_LEVEL	_011_L
      1  23a7		       00 33	   LEVEL_SIZE__011_L =	* - LEVEL_START
      2  23a7				  -	      IF	LEVEL_SIZE__011_L > MAX_LEVEL_SIZE
      3  23a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_L
      4  23a7					      ENDIF
      0  23a7					      DEFL	_011_R, "2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#"
      0  23a7					      START_LEVEL	_011_R
      1  23a7				   LEVEL_START SET	*
      2  23a7		       00 04	   BANK_LEVEL__011_R =	_CURRENT_BANK
      3  23a7				   LEVEL__011_R SUBROUTINE
      4  23a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23a7
      2  23a7		       32 2d 33 23*	      .byte.b	"2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#",0
      0  23e1					      END_LEVEL	_011_R
      1  23e1		       00 3a	   LEVEL_SIZE__011_R =	* - LEVEL_START
      2  23e1				  -	      IF	LEVEL_SIZE__011_R > MAX_LEVEL_SIZE
      3  23e1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_R
      4  23e1					      ENDIF
      0  23e1					      DEFL	_012_L, "7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#"
      0  23e1					      START_LEVEL	_012_L
      1  23e1				   LEVEL_START SET	*
      2  23e1		       00 04	   BANK_LEVEL__012_L =	_CURRENT_BANK
      3  23e1				   LEVEL__012_L SUBROUTINE
      4  23e1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23e1
      2  23e1		       37 23 33 2d*	      .byte.b	"7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#",0
      0  2411					      END_LEVEL	_012_L
      1  2411		       00 30	   LEVEL_SIZE__012_L =	* - LEVEL_START
      2  2411				  -	      IF	LEVEL_SIZE__012_L > MAX_LEVEL_SIZE
      3  2411				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_L
      4  2411					      ENDIF
      0  2411					      DEFL	_012_R, "-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-"
      0  2411					      START_LEVEL	_012_R
      1  2411				   LEVEL_START SET	*
      2  2411		       00 04	   BANK_LEVEL__012_R =	_CURRENT_BANK
      3  2411				   LEVEL__012_R SUBROUTINE
      4  2411				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2411
      2  2411		       2d 36 23 32*	      .byte.b	"-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-",0
      0  244d					      END_LEVEL	_012_R
      1  244d		       00 3c	   LEVEL_SIZE__012_R =	* - LEVEL_START
      2  244d				  -	      IF	LEVEL_SIZE__012_R > MAX_LEVEL_SIZE
      3  244d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_R
      4  244d					      ENDIF
      0  244d					      DEFL	_013_L, "2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-"
      0  244d					      START_LEVEL	_013_L
      1  244d				   LEVEL_START SET	*
      2  244d		       00 04	   BANK_LEVEL__013_L =	_CURRENT_BANK
      3  244d				   LEVEL__013_L SUBROUTINE
      4  244d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  244d
      2  244d		       32 2d 35 23*	      .byte.b	"2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-",0
      0  248c					      END_LEVEL	_013_L
      1  248c		       00 3f	   LEVEL_SIZE__013_L =	* - LEVEL_START
      2  248c				  -	      IF	LEVEL_SIZE__013_L > MAX_LEVEL_SIZE
      3  248c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_L
      4  248c					      ENDIF
      0  248c					      DEFL	_013_R, "-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-"
      0  248c					      START_LEVEL	_013_R
      1  248c				   LEVEL_START SET	*
      2  248c		       00 04	   BANK_LEVEL__013_R =	_CURRENT_BANK
      3  248c				   LEVEL__013_R SUBROUTINE
      4  248c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  248c
      2  248c		       2d 35 23 32*	      .byte.b	"-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-",0
      0  24bf					      END_LEVEL	_013_R
      1  24bf		       00 33	   LEVEL_SIZE__013_R =	* - LEVEL_START
      2  24bf				  -	      IF	LEVEL_SIZE__013_R > MAX_LEVEL_SIZE
      3  24bf				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_R
      4  24bf					      ENDIF
      0  24bf					      DEFL	_014_L, "6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#"
      0  24bf					      START_LEVEL	_014_L
      1  24bf				   LEVEL_START SET	*
      2  24bf		       00 04	   BANK_LEVEL__014_L =	_CURRENT_BANK
      3  24bf				   LEVEL__014_L SUBROUTINE
      4  24bf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24bf
      2  24bf		       36 23 34 2d*	      .byte.b	"6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#",0
      0  2502					      END_LEVEL	_014_L
      1  2502		       00 43	   LEVEL_SIZE__014_L =	* - LEVEL_START
      2  2502					      IF	LEVEL_SIZE__014_L > MAX_LEVEL_SIZE
      3  2502				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_L
      4  2502					      ENDIF
      0  2502					      DEFL	_014_R, "6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-"
      0  2502					      START_LEVEL	_014_R
      1  2502				   LEVEL_START SET	*
      2  2502		       00 04	   BANK_LEVEL__014_R =	_CURRENT_BANK
      3  2502				   LEVEL__014_R SUBROUTINE
      4  2502				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2502
      2  2502		       36 23 33 2d*	      .byte.b	"6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-",0
      0  2545					      END_LEVEL	_014_R
      1  2545		       00 43	   LEVEL_SIZE__014_R =	* - LEVEL_START
      2  2545				  -	      IF	LEVEL_SIZE__014_R > MAX_LEVEL_SIZE
      3  2545				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_R
      4  2545					      ENDIF
      0  2545					      DEFL	_015_L, "2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#"
      0  2545					      START_LEVEL	_015_L
      1  2545				   LEVEL_START SET	*
      2  2545		       00 04	   BANK_LEVEL__015_L =	_CURRENT_BANK
      3  2545				   LEVEL__015_L SUBROUTINE
      4  2545				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2545
      2  2545		       32 2d 35 23*	      .byte.b	"2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#",0
      0  257a					      END_LEVEL	_015_L
      1  257a		       00 35	   LEVEL_SIZE__015_L =	* - LEVEL_START
      2  257a				  -	      IF	LEVEL_SIZE__015_L > MAX_LEVEL_SIZE
      3  257a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_L
      4  257a					      ENDIF
      0  257a					      DEFL	_015_R, "3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-"
      0  257a					      START_LEVEL	_015_R
      1  257a				   LEVEL_START SET	*
      2  257a		       00 04	   BANK_LEVEL__015_R =	_CURRENT_BANK
      3  257a				   LEVEL__015_R SUBROUTINE
      4  257a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  257a
      2  257a		       33 2d 35 23*	      .byte.b	"3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-",0
      0  25bf					      END_LEVEL	_015_R
      1  25bf		       00 45	   LEVEL_SIZE__015_R =	* - LEVEL_START
      2  25bf					      IF	LEVEL_SIZE__015_R > MAX_LEVEL_SIZE
      3  25bf				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_R
      4  25bf					      ENDIF
      0  25bf					      DEFL	_016_L, "4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-"
      0  25bf					      START_LEVEL	_016_L
      1  25bf				   LEVEL_START SET	*
      2  25bf		       00 04	   BANK_LEVEL__016_L =	_CURRENT_BANK
      3  25bf				   LEVEL__016_L SUBROUTINE
      4  25bf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25bf
      2  25bf		       34 2d 33 23*	      .byte.b	"4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-",0
      0  25f6					      END_LEVEL	_016_L
      1  25f6		       00 37	   LEVEL_SIZE__016_L =	* - LEVEL_START
      2  25f6				  -	      IF	LEVEL_SIZE__016_L > MAX_LEVEL_SIZE
      3  25f6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_L
      4  25f6					      ENDIF
      0  25f6					      DEFL	_016_R, "5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-"
      0  25f6					      START_LEVEL	_016_R
      1  25f6				   LEVEL_START SET	*
      2  25f6		       00 04	   BANK_LEVEL__016_R =	_CURRENT_BANK
      3  25f6				   LEVEL__016_R SUBROUTINE
      4  25f6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25f6
      2  25f6		       35 23 2d 7c*	      .byte.b	"5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-",0
      0  2629					      END_LEVEL	_016_R
      1  2629		       00 33	   LEVEL_SIZE__016_R =	* - LEVEL_START
      2  2629				  -	      IF	LEVEL_SIZE__016_R > MAX_LEVEL_SIZE
      3  2629				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_R
      4  2629					      ENDIF
      0  2629					      DEFL	_017_L, "5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-"
      0  2629					      START_LEVEL	_017_L
      1  2629				   LEVEL_START SET	*
      2  2629		       00 04	   BANK_LEVEL__017_L =	_CURRENT_BANK
      3  2629				   LEVEL__017_L SUBROUTINE
      4  2629				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2629
      2  2629		       35 23 34 2d*	      .byte.b	"5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-",0
      0  2673					      END_LEVEL	_017_L
      1  2673		       00 4a	   LEVEL_SIZE__017_L =	* - LEVEL_START
      2  2673					      IF	LEVEL_SIZE__017_L > MAX_LEVEL_SIZE
      3  2673				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_L
      4  2673					      ENDIF
      0  2673					      DEFL	_017_R, "3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-"
      0  2673					      START_LEVEL	_017_R
      1  2673				   LEVEL_START SET	*
      2  2673		       00 04	   BANK_LEVEL__017_R =	_CURRENT_BANK
      3  2673				   LEVEL__017_R SUBROUTINE
      4  2673				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2673
      2  2673		       33 2d 34 23*	      .byte.b	"3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-",0
      0  26b6					      END_LEVEL	_017_R
      1  26b6		       00 43	   LEVEL_SIZE__017_R =	* - LEVEL_START
      2  26b6				  -	      IF	LEVEL_SIZE__017_R > MAX_LEVEL_SIZE
      3  26b6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_R
      4  26b6					      ENDIF
      0  26b6					      DEFL	_018_L, "6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#"
      0  26b6					      START_LEVEL	_018_L
      1  26b6				   LEVEL_START SET	*
      2  26b6		       00 04	   BANK_LEVEL__018_L =	_CURRENT_BANK
      3  26b6				   LEVEL__018_L SUBROUTINE
      4  26b6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26b6
      2  26b6		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#",0
      0  26ea					      END_LEVEL	_018_L
      1  26ea		       00 34	   LEVEL_SIZE__018_L =	* - LEVEL_START
      2  26ea				  -	      IF	LEVEL_SIZE__018_L > MAX_LEVEL_SIZE
      3  26ea				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_L
      4  26ea					      ENDIF
      0  26ea					      DEFL	_018_R, "-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#"
      0  26ea					      START_LEVEL	_018_R
      1  26ea				   LEVEL_START SET	*
      2  26ea		       00 04	   BANK_LEVEL__018_R =	_CURRENT_BANK
      3  26ea				   LEVEL__018_R SUBROUTINE
      4  26ea				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26ea
      2  26ea		       2d 34 23 33*	      .byte.b	"-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#",0
      0  2726					      END_LEVEL	_018_R
      1  2726		       00 3c	   LEVEL_SIZE__018_R =	* - LEVEL_START
      2  2726				  -	      IF	LEVEL_SIZE__018_R > MAX_LEVEL_SIZE
      3  2726				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_R
      4  2726					      ENDIF
      0  2726					      DEFL	_019_L, "4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#"
      0  2726					      START_LEVEL	_019_L
      1  2726				   LEVEL_START SET	*
      2  2726		       00 04	   BANK_LEVEL__019_L =	_CURRENT_BANK
      3  2726				   LEVEL__019_L SUBROUTINE
      4  2726				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2726
      2  2726		       34 2d 35 23*	      .byte.b	"4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#",0
      0  2761					      END_LEVEL	_019_L
      1  2761		       00 3b	   LEVEL_SIZE__019_L =	* - LEVEL_START
      2  2761				  -	      IF	LEVEL_SIZE__019_L > MAX_LEVEL_SIZE
      3  2761				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_L
      4  2761					      ENDIF
      0  2761					      DEFL	_019_R, "2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#"
      0  2761					      START_LEVEL	_019_R
      1  2761				   LEVEL_START SET	*
      2  2761		       00 04	   BANK_LEVEL__019_R =	_CURRENT_BANK
      3  2761				   LEVEL__019_R SUBROUTINE
      4  2761				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2761
      2  2761		       32 2d 37 23*	      .byte.b	"2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#",0
      0  27b1					      END_LEVEL	_019_R
      1  27b1		       00 50	   LEVEL_SIZE__019_R =	* - LEVEL_START
      2  27b1					      IF	LEVEL_SIZE__019_R > MAX_LEVEL_SIZE
      3  27b1				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_R
      4  27b1					      ENDIF
     80  27b1
     81  27b1							;-----------------------------------------------------------
     82  27b1							; Stella 3E autodetect signature, can live anywhere
     83  27b1		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
     84  27b5							;-----------------------------------------------------------
     85  27b5
      0  27b5					      CHECK_BANK_SIZE	"LEVELS1"
      1  27b5		       07 b5	   .TEMP      =	* - BANK_START
 LEVELS1 (2K) SIZE =  $7b5 , FREE= $4b
      2  27b5					      ECHO	"LEVELS1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27b5				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  27b5				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27b5				  -	      ERR
      6  27b5					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS2.asm LEVEL 2 PASS 4
      0  27b5					      include	"BANK_LEVELS2.asm"
      1  27b5							;    Sokoboo - a Sokoban implementation
      2  27b5							;    using a generic tile-based display engine for the Atari 2600
      3  27b5							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  27b5							;
      5  27b5							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  27b5							;
      7  27b5							;    Code related to the generic tile-based display engine was developed by
      8  27b5							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  27b5							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  27b5							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  27b5							;
     12  27b5							;    Code related to music and sound effects uses the TIATracker music player
     13  27b5							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  27b5							;    directory for Apache licensing details.
     15  27b5							;
     16  27b5							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  27b5							;    See the copyright notices in the License directory for a list of level
     18  27b5							;    contributors.
     19  27b5							;
     20  27b5							;    Except where otherwise indicated, this software is released under the
     21  27b5							;    following licensing arrangement...
     22  27b5							;
     23  27b5							;    This program is free software: you can redistribute it and/or modify
     24  27b5							;    it under the terms of the GNU General Public License as published by
     25  27b5							;    the Free Software Foundation, either version 3 of the License, or
     26  27b5							;    (at your option) any later version.
     27  27b5							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  27b5
     29  27b5							;    This program is distributed in the hope that it will be useful,
     30  27b5							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  27b5							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  27b5							;    GNU General Public License for more details.
     33  27b5
      0  27b5					      NEWBANK	LEVELS2
      1  2fbe ????				      SEG	LEVELS2
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   LEVELS2    SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	LEVELS2
     35  2800
      0  2800					      DEFL	_020_L, "-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-"
      0  2800					      START_LEVEL	_020_L
      1  2800				   LEVEL_START SET	*
      2  2800		       00 05	   BANK_LEVEL__020_L =	_CURRENT_BANK
      3  2800				   LEVEL__020_L SUBROUTINE
      4  2800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2800
      2  2800		       2d 36 23 2d*	      .byte.b	"-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-",0
      0  283f					      END_LEVEL	_020_L
      1  283f		       00 3f	   LEVEL_SIZE__020_L =	* - LEVEL_START
      2  283f				  -	      IF	LEVEL_SIZE__020_L > MAX_LEVEL_SIZE
      3  283f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_L
      4  283f					      ENDIF
      0  283f					      DEFL	_020_R, "5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-"
      0  283f					      START_LEVEL	_020_R
      1  283f				   LEVEL_START SET	*
      2  283f		       00 05	   BANK_LEVEL__020_R =	_CURRENT_BANK
      3  283f				   LEVEL__020_R SUBROUTINE
      4  283f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  283f
      2  283f		       35 2d 34 23*	      .byte.b	"5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-",0
      0  287f					      END_LEVEL	_020_R
      1  287f		       00 40	   LEVEL_SIZE__020_R =	* - LEVEL_START
      2  287f				  -	      IF	LEVEL_SIZE__020_R > MAX_LEVEL_SIZE
      3  287f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_R
      4  287f					      ENDIF
      0  287f					      DEFL	_021_L, "4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-"
      0  287f					      START_LEVEL	_021_L
      1  287f				   LEVEL_START SET	*
      2  287f		       00 05	   BANK_LEVEL__021_L =	_CURRENT_BANK
      3  287f				   LEVEL__021_L SUBROUTINE
      4  287f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  287f
      2  287f		       34 2d 34 23*	      .byte.b	"4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-",0
      0  28d5					      END_LEVEL	_021_L
      1  28d5		       00 56	   LEVEL_SIZE__021_L =	* - LEVEL_START
      2  28d5					      IF	LEVEL_SIZE__021_L > MAX_LEVEL_SIZE
      3  28d5				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_L
      4  28d5					      ENDIF
      0  28d5					      DEFL	_021_R, "-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-"
      0  28d5					      START_LEVEL	_021_R
      1  28d5				   LEVEL_START SET	*
      2  28d5		       00 05	   BANK_LEVEL__021_R =	_CURRENT_BANK
      3  28d5				   LEVEL__021_R SUBROUTINE
      4  28d5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  28d5
      2  28d5		       2d 34 23 33*	      .byte.b	"-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-",0
      0  2909					      END_LEVEL	_021_R
      1  2909		       00 34	   LEVEL_SIZE__021_R =	* - LEVEL_START
      2  2909				  -	      IF	LEVEL_SIZE__021_R > MAX_LEVEL_SIZE
      3  2909				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_R
      4  2909					      ENDIF
      0  2909					      DEFL	_022_L, "3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-"
      0  2909					      START_LEVEL	_022_L
      1  2909				   LEVEL_START SET	*
      2  2909		       00 05	   BANK_LEVEL__022_L =	_CURRENT_BANK
      3  2909				   LEVEL__022_L SUBROUTINE
      4  2909				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2909
      2  2909		       33 2d 33 23*	      .byte.b	"3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-",0
      0  294f					      END_LEVEL	_022_L
      1  294f		       00 46	   LEVEL_SIZE__022_L =	* - LEVEL_START
      2  294f				  -	      IF	LEVEL_SIZE__022_L > MAX_LEVEL_SIZE
      3  294f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_L
      4  294f					      ENDIF
      0  294f					      DEFL	_022_R, "-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-"
      0  294f					      START_LEVEL	_022_R
      1  294f				   LEVEL_START SET	*
      2  294f		       00 05	   BANK_LEVEL__022_R =	_CURRENT_BANK
      3  294f				   LEVEL__022_R SUBROUTINE
      4  294f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  294f
      2  294f		       2d 33 23 34*	      .byte.b	"-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-",0
      0  298b					      END_LEVEL	_022_R
      1  298b		       00 3c	   LEVEL_SIZE__022_R =	* - LEVEL_START
      2  298b				  -	      IF	LEVEL_SIZE__022_R > MAX_LEVEL_SIZE
      3  298b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_R
      4  298b					      ENDIF
      0  298b					      DEFL	_023_L, "6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#"
      0  298b					      START_LEVEL	_023_L
      1  298b				   LEVEL_START SET	*
      2  298b		       00 05	   BANK_LEVEL__023_L =	_CURRENT_BANK
      3  298b				   LEVEL__023_L SUBROUTINE
      4  298b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  298b
      2  298b		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#",0
      0  29cc					      END_LEVEL	_023_L
      1  29cc		       00 41	   LEVEL_SIZE__023_L =	* - LEVEL_START
      2  29cc				  -	      IF	LEVEL_SIZE__023_L > MAX_LEVEL_SIZE
      3  29cc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_L
      4  29cc					      ENDIF
      0  29cc					      DEFL	_023_R, "7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-"
      0  29cc					      START_LEVEL	_023_R
      1  29cc				   LEVEL_START SET	*
      2  29cc		       00 05	   BANK_LEVEL__023_R =	_CURRENT_BANK
      3  29cc				   LEVEL__023_R SUBROUTINE
      4  29cc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  29cc
      2  29cc		       37 23 32 2d*	      .byte.b	"7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-",0
      0  2a0e					      END_LEVEL	_023_R
      1  2a0e		       00 42	   LEVEL_SIZE__023_R =	* - LEVEL_START
      2  2a0e				  -	      IF	LEVEL_SIZE__023_R > MAX_LEVEL_SIZE
      3  2a0e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_R
      4  2a0e					      ENDIF
      0  2a0e					      DEFL	_024_L, "-9#|-#7-#|-#-#2-$#-#|-#-#.*.#-#|2#2-.*-#-#|#3-.2$2-#|#-$2#2-3#|2#@2#2-#2-|-7#2-"
      0  2a0e					      START_LEVEL	_024_L
      1  2a0e				   LEVEL_START SET	*
      2  2a0e		       00 05	   BANK_LEVEL__024_L =	_CURRENT_BANK
      3  2a0e				   LEVEL__024_L SUBROUTINE
      4  2a0e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a0e
      2  2a0e		       2d 39 23 7c*	      .byte.b	"-9#|-#7-#|-#-#2-$#-#|-#-#.*.#-#|2#2-.*-#-#|#3-.2$2-#|#-$2#2-3#|2#@2#2-#2-|-7#2-",0
      0  2a5e					      END_LEVEL	_024_L
      1  2a5e		       00 50	   LEVEL_SIZE__024_L =	* - LEVEL_START
      2  2a5e				  -	      IF	LEVEL_SIZE__024_L > MAX_LEVEL_SIZE
      3  2a5e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__024_L
      4  2a5e					      ENDIF
      0  2a5e					      DEFL	_024_R, "-8#|2#6-#|#-$-*-#-#|#-3.*$-#|#2-*.*.2#|#2-#$-$-#|4#-$2-#|3-2#@3#|4-3#2-"
      0  2a5e					      START_LEVEL	_024_R
      1  2a5e				   LEVEL_START SET	*
      2  2a5e		       00 05	   BANK_LEVEL__024_R =	_CURRENT_BANK
      3  2a5e				   LEVEL__024_R SUBROUTINE
      4  2a5e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a5e
      2  2a5e		       2d 38 23 7c*	      .byte.b	"-8#|2#6-#|#-$-*-#-#|#-3.*$-#|#2-*.*.2#|#2-#$-$-#|4#-$2-#|3-2#@3#|4-3#2-",0
      0  2aa6					      END_LEVEL	_024_R
      1  2aa6		       00 48	   LEVEL_SIZE__024_R =	* - LEVEL_START
      2  2aa6				  -	      IF	LEVEL_SIZE__024_R > MAX_LEVEL_SIZE
      3  2aa6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__024_R
      4  2aa6					      ENDIF
      0  2aa6					      DEFL	_025_L, "4-4#2-|5#@-2#-|#4-2$-2#|#-3#2-$-#|#-3.2*.-#|#-2$*$2.2#|2#6-#-|-8#-"
      0  2aa6					      START_LEVEL	_025_L
      1  2aa6				   LEVEL_START SET	*
      2  2aa6		       00 05	   BANK_LEVEL__025_L =	_CURRENT_BANK
      3  2aa6				   LEVEL__025_L SUBROUTINE
      4  2aa6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2aa6
      2  2aa6		       34 2d 34 23*	      .byte.b	"4-4#2-|5#@-2#-|#4-2$-2#|#-3#2-$-#|#-3.2*.-#|#-2$*$2.2#|2#6-#-|-8#-",0
      0  2ae9					      END_LEVEL	_025_L
      1  2ae9		       00 43	   LEVEL_SIZE__025_L =	* - LEVEL_START
      2  2ae9				  -	      IF	LEVEL_SIZE__025_L > MAX_LEVEL_SIZE
      3  2ae9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__025_L
      4  2ae9					      ENDIF
      0  2ae9					      DEFL	_025_R, "-6#-|2#.-$-#-|#.*$*-2#|#.*2.$-#|2#3-#@#|-#-$-$-#|-3#2-2#|3-4#-"
      0  2ae9					      START_LEVEL	_025_R
      1  2ae9				   LEVEL_START SET	*
      2  2ae9		       00 05	   BANK_LEVEL__025_R =	_CURRENT_BANK
      3  2ae9				   LEVEL__025_R SUBROUTINE
      4  2ae9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ae9
      2  2ae9		       2d 36 23 2d*	      .byte.b	"-6#-|2#.-$-#-|#.*$*-2#|#.*2.$-#|2#3-#@#|-#-$-$-#|-3#2-2#|3-4#-",0
      0  2b28					      END_LEVEL	_025_R
      1  2b28		       00 3f	   LEVEL_SIZE__025_R =	* - LEVEL_START
      2  2b28				  -	      IF	LEVEL_SIZE__025_R > MAX_LEVEL_SIZE
      3  2b28				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__025_R
      4  2b28					      ENDIF
      0  2b28					      DEFL	_026_L, "-6#2-|2#-3.3#|#-$-2*.-#|#2-$-2*-#|#-$-$.$-#|#2-#-@2-#|9#"
      0  2b28					      START_LEVEL	_026_L
      1  2b28				   LEVEL_START SET	*
      2  2b28		       00 05	   BANK_LEVEL__026_L =	_CURRENT_BANK
      3  2b28				   LEVEL__026_L SUBROUTINE
      4  2b28				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b28
      2  2b28		       2d 36 23 32*	      .byte.b	"-6#2-|2#-3.3#|#-$-2*.-#|#2-$-2*-#|#-$-$.$-#|#2-#-@2-#|9#",0
      0  2b61					      END_LEVEL	_026_L
      1  2b61		       00 39	   LEVEL_SIZE__026_L =	* - LEVEL_START
      2  2b61				  -	      IF	LEVEL_SIZE__026_L > MAX_LEVEL_SIZE
      3  2b61				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__026_L
      4  2b61					      ENDIF
      0  2b61					      DEFL	_026_R, "5-4#|4-2#2-#|-4#3-#|2#2.-$2-#|#.3*$-2#|2#.$-$-#-|-3#-@2#-|3-4#2-"
      0  2b61					      START_LEVEL	_026_R
      1  2b61				   LEVEL_START SET	*
      2  2b61		       00 05	   BANK_LEVEL__026_R =	_CURRENT_BANK
      3  2b61				   LEVEL__026_R SUBROUTINE
      4  2b61				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b61
      2  2b61		       35 2d 34 23*	      .byte.b	"5-4#|4-2#2-#|-4#3-#|2#2.-$2-#|#.3*$-2#|2#.$-$-#-|-3#-@2#-|3-4#2-",0
      0  2ba2					      END_LEVEL	_026_R
      1  2ba2		       00 41	   LEVEL_SIZE__026_R =	* - LEVEL_START
      2  2ba2				  -	      IF	LEVEL_SIZE__026_R > MAX_LEVEL_SIZE
      3  2ba2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__026_R
      4  2ba2					      ENDIF
      0  2ba2					      DEFL	_027_L, "8#-|#3-@2-#-|#-*4$2#|2#*.#3-#|-#3.$2-#|-3#*.$-#|3-#.4#|3-3#3-"
      0  2ba2					      START_LEVEL	_027_L
      1  2ba2				   LEVEL_START SET	*
      2  2ba2		       00 05	   BANK_LEVEL__027_L =	_CURRENT_BANK
      3  2ba2				   LEVEL__027_L SUBROUTINE
      4  2ba2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ba2
      2  2ba2		       38 23 2d 7c*	      .byte.b	"8#-|#3-@2-#-|#-*4$2#|2#*.#3-#|-#3.$2-#|-3#*.$-#|3-#.4#|3-3#3-",0
      0  2be0					      END_LEVEL	_027_L
      1  2be0		       00 3e	   LEVEL_SIZE__027_L =	* - LEVEL_START
      2  2be0				  -	      IF	LEVEL_SIZE__027_L > MAX_LEVEL_SIZE
      3  2be0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__027_L
      4  2be0					      ENDIF
      0  2be0					      DEFL	_027_R, "7#2-|#5-2#-|#$2*-$-#-|#-*2.2-2#|#2.*3$-#|3#.#3-#|2-4#-@#|5-4#"
      0  2be0					      START_LEVEL	_027_R
      1  2be0				   LEVEL_START SET	*
      2  2be0		       00 05	   BANK_LEVEL__027_R =	_CURRENT_BANK
      3  2be0				   LEVEL__027_R SUBROUTINE
      4  2be0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2be0
      2  2be0		       37 23 32 2d*	      .byte.b	"7#2-|#5-2#-|#$2*-$-#-|#-*2.2-2#|#2.*3$-#|3#.#3-#|2-4#-@#|5-4#",0
      0  2c1e					      END_LEVEL	_027_R
      1  2c1e		       00 3e	   LEVEL_SIZE__027_R =	* - LEVEL_START
      2  2c1e				  -	      IF	LEVEL_SIZE__027_R > MAX_LEVEL_SIZE
      3  2c1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__027_R
      4  2c1e					      ENDIF
      0  2c1e					      DEFL	_028_L, "3-3#4-|4#.#4-|#-$-.#4-|#@#.*5#|#-$.*.3-#|#-2$-*$#-#|#2-#-.$2-#|4#4-2#|3-6#-"
      0  2c1e					      START_LEVEL	_028_L
      1  2c1e				   LEVEL_START SET	*
      2  2c1e		       00 05	   BANK_LEVEL__028_L =	_CURRENT_BANK
      3  2c1e				   LEVEL__028_L SUBROUTINE
      4  2c1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c1e
      2  2c1e		       33 2d 33 23*	      .byte.b	"3-3#4-|4#.#4-|#-$-.#4-|#@#.*5#|#-$.*.3-#|#-2$-*$#-#|#2-#-.$2-#|4#4-2#|3-6#-",0
      0  2c6a					      END_LEVEL	_028_L
      1  2c6a		       00 4c	   LEVEL_SIZE__028_L =	* - LEVEL_START
      2  2c6a				  -	      IF	LEVEL_SIZE__028_L > MAX_LEVEL_SIZE
      3  2c6a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__028_L
      4  2c6a					      ENDIF
      0  2c6a					      DEFL	_028_R, "9#-|#4-2#@#-|#-2#$#-$2#|#-.-.2$2-#|#-.*.2-#-#|#-#.#$3-#|#-#2*3-2#|#4-4#-|6#4-"
      0  2c6a					      START_LEVEL	_028_R
      1  2c6a				   LEVEL_START SET	*
      2  2c6a		       00 05	   BANK_LEVEL__028_R =	_CURRENT_BANK
      3  2c6a				   LEVEL__028_R SUBROUTINE
      4  2c6a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c6a
      2  2c6a		       39 23 2d 7c*	      .byte.b	"9#-|#4-2#@#-|#-2#$#-$2#|#-.-.2$2-#|#-.*.2-#-#|#-#.#$3-#|#-#2*3-2#|#4-4#-|6#4-",0
      0  2cb8					      END_LEVEL	_028_R
      1  2cb8		       00 4e	   LEVEL_SIZE__028_R =	* - LEVEL_START
      2  2cb8				  -	      IF	LEVEL_SIZE__028_R > MAX_LEVEL_SIZE
      3  2cb8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__028_R
      4  2cb8					      ENDIF
      0  2cb8					      DEFL	_029_L, "-5#3-|-#-@-2#2-|2#$*$-3#|#2.*.$2-#|#.*.$3-#|2#2-$-3#|-3#2-#2-|3-4#2-"
      0  2cb8					      START_LEVEL	_029_L
      1  2cb8				   LEVEL_START SET	*
      2  2cb8		       00 05	   BANK_LEVEL__029_L =	_CURRENT_BANK
      3  2cb8				   LEVEL__029_L SUBROUTINE
      4  2cb8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cb8
      2  2cb8		       2d 35 23 33*	      .byte.b	"-5#3-|-#-@-2#2-|2#$*$-3#|#2.*.$2-#|#.*.$3-#|2#2-$-3#|-3#2-#2-|3-4#2-",0
      0  2cfd					      END_LEVEL	_029_L
      1  2cfd		       00 45	   LEVEL_SIZE__029_L =	* - LEVEL_START
      2  2cfd				  -	      IF	LEVEL_SIZE__029_L > MAX_LEVEL_SIZE
      3  2cfd				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__029_L
      4  2cfd					      ENDIF
      0  2cfd					      DEFL	_029_R, "-4#4-|-#@-4#-|2#$-$2-2#|#2.3$2-#|#.2*.*$-#|3#2-2.-#|2-#2-$.2#|2-6#-"
      0  2cfd					      START_LEVEL	_029_R
      1  2cfd				   LEVEL_START SET	*
      2  2cfd		       00 05	   BANK_LEVEL__029_R =	_CURRENT_BANK
      3  2cfd				   LEVEL__029_R SUBROUTINE
      4  2cfd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cfd
      2  2cfd		       2d 34 23 34*	      .byte.b	"-4#4-|-#@-4#-|2#$-$2-2#|#2.3$2-#|#.2*.*$-#|3#2-2.-#|2-#2-$.2#|2-6#-",0
      0  2d41					      END_LEVEL	_029_R
      1  2d41		       00 44	   LEVEL_SIZE__029_R =	* - LEVEL_START
      2  2d41				  -	      IF	LEVEL_SIZE__029_R > MAX_LEVEL_SIZE
      3  2d41				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__029_R
      4  2d41					      ENDIF
      0  2d41					      DEFL	_030_L, "6-5#|5#-#2-@#|#3-3#2$-#|#2-$-2.-$2#|3#-.*.*-2#|2-3#-.$2-#|4-#3-#-#|4-2#4-#|5-6#"
      0  2d41					      START_LEVEL	_030_L
      1  2d41				   LEVEL_START SET	*
      2  2d41		       00 05	   BANK_LEVEL__030_L =	_CURRENT_BANK
      3  2d41				   LEVEL__030_L SUBROUTINE
      4  2d41				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d41
      2  2d41		       36 2d 35 23*	      .byte.b	"6-5#|5#-#2-@#|#3-3#2$-#|#2-$-2.-$2#|3#-.*.*-2#|2-3#-.$2-#|4-#3-#-#|4-2#4-#|5-6#",0
      0  2d91					      END_LEVEL	_030_L
      1  2d91		       00 50	   LEVEL_SIZE__030_L =	* - LEVEL_START
      2  2d91				  -	      IF	LEVEL_SIZE__030_L > MAX_LEVEL_SIZE
      3  2d91				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__030_L
      4  2d91					      ENDIF
      0  2d91					      DEFL	_030_R, "-7#2-|2#-$2-.#2-|#-$-$#.#2-|#-#.$2.#2-|#-#3.$2#-|#2-$#*2-2#|3#2-*2$-#|2-#@5-#|2-8#"
      0  2d91					      START_LEVEL	_030_R
      1  2d91				   LEVEL_START SET	*
      2  2d91		       00 05	   BANK_LEVEL__030_R =	_CURRENT_BANK
      3  2d91				   LEVEL__030_R SUBROUTINE
      4  2d91				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d91
      2  2d91		       2d 37 23 32*	      .byte.b	"-7#2-|2#-$2-.#2-|#-$-$#.#2-|#-#.$2.#2-|#-#3.$2#-|#2-$#*2-2#|3#2-*2$-#|2-#@5-#|2-8#",0
      0  2de4					      END_LEVEL	_030_R
      1  2de4		       00 53	   LEVEL_SIZE__030_R =	* - LEVEL_START
      2  2de4				  -	      IF	LEVEL_SIZE__030_R > MAX_LEVEL_SIZE
      3  2de4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__030_R
      4  2de4					      ENDIF
      0  2de4					      DEFL	_031_L, "-7#2-|-#3-@-3#|-#-2$*2$-#|3#2-*.2-#|#2.2*.*2-#|#$#2-.2-2#|#3-5#-|5#5-"
      0  2de4					      START_LEVEL	_031_L
      1  2de4				   LEVEL_START SET	*
      2  2de4		       00 05	   BANK_LEVEL__031_L =	_CURRENT_BANK
      3  2de4				   LEVEL__031_L SUBROUTINE
      4  2de4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2de4
      2  2de4		       2d 37 23 32*	      .byte.b	"-7#2-|-#3-@-3#|-#-2$*2$-#|3#2-*.2-#|#2.2*.*2-#|#$#2-.2-2#|#3-5#-|5#5-",0
      0  2e2a					      END_LEVEL	_031_L
      1  2e2a		       00 46	   LEVEL_SIZE__031_L =	* - LEVEL_START
      2  2e2a				  -	      IF	LEVEL_SIZE__031_L > MAX_LEVEL_SIZE
      3  2e2a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__031_L
      4  2e2a					      ENDIF
      0  2e2a					      DEFL	_031_R, "6#-|#2-#+#-|#2-$.2#|#2-2*.#|#-$-.$#|#-$-*.#|#-2$.-#|#-$-.-#|7#"
      0  2e2a					      START_LEVEL	_031_R
      1  2e2a				   LEVEL_START SET	*
      2  2e2a		       00 05	   BANK_LEVEL__031_R =	_CURRENT_BANK
      3  2e2a				   LEVEL__031_R SUBROUTINE
      4  2e2a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e2a
      2  2e2a		       36 23 2d 7c*	      .byte.b	"6#-|#2-#+#-|#2-$.2#|#2-2*.#|#-$-.$#|#-$-*.#|#-2$.-#|#-$-.-#|7#",0
      0  2e69					      END_LEVEL	_031_R
      1  2e69		       00 3f	   LEVEL_SIZE__031_R =	* - LEVEL_START
      2  2e69				  -	      IF	LEVEL_SIZE__031_R > MAX_LEVEL_SIZE
      3  2e69				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__031_R
      4  2e69					      ENDIF
      0  2e69					      DEFL	_032_L, "-4#2-|-#2-3#|2#2-2.#|#@2$*.#|#-$2-.#|#-$-#*#|3#3-#|2-5#"
      0  2e69					      START_LEVEL	_032_L
      1  2e69				   LEVEL_START SET	*
      2  2e69		       00 05	   BANK_LEVEL__032_L =	_CURRENT_BANK
      3  2e69				   LEVEL__032_L SUBROUTINE
      4  2e69				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e69
      2  2e69		       2d 34 23 32*	      .byte.b	"-4#2-|-#2-3#|2#2-2.#|#@2$*.#|#-$2-.#|#-$-#*#|3#3-#|2-5#",0
      0  2ea1					      END_LEVEL	_032_L
      1  2ea1		       00 38	   LEVEL_SIZE__032_L =	* - LEVEL_START
      2  2ea1				  -	      IF	LEVEL_SIZE__032_L > MAX_LEVEL_SIZE
      3  2ea1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__032_L
      4  2ea1					      ENDIF
      0  2ea1					      DEFL	_032_R, "9#-|#7-2#|#-$3#-$@#|#2-2.#.$-#|#-.*.2*$-#|#-$.*2-$-#|#2-#.$-3#|8#2-"
      0  2ea1					      START_LEVEL	_032_R
      1  2ea1				   LEVEL_START SET	*
      2  2ea1		       00 05	   BANK_LEVEL__032_R =	_CURRENT_BANK
      3  2ea1				   LEVEL__032_R SUBROUTINE
      4  2ea1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ea1
      2  2ea1		       39 23 2d 7c*	      .byte.b	"9#-|#7-2#|#-$3#-$@#|#2-2.#.$-#|#-.*.2*$-#|#-$.*2-$-#|#2-#.$-3#|8#2-",0
      0  2ee5					      END_LEVEL	_032_R
      1  2ee5		       00 44	   LEVEL_SIZE__032_R =	* - LEVEL_START
      2  2ee5				  -	      IF	LEVEL_SIZE__032_R > MAX_LEVEL_SIZE
      3  2ee5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__032_R
      4  2ee5					      ENDIF
      0  2ee5					      DEFL	_033_L, "2-7#-|-2#2-#2-2#|-#2-.*-$-#|-#-$.$-$@#|2#$-2*-3#|#2-$*.*.#-|#3-2.3#-|7#3-"
      0  2ee5					      START_LEVEL	_033_L
      1  2ee5				   LEVEL_START SET	*
      2  2ee5		       00 05	   BANK_LEVEL__033_L =	_CURRENT_BANK
      3  2ee5				   LEVEL__033_L SUBROUTINE
      4  2ee5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ee5
      2  2ee5		       32 2d 37 23*	      .byte.b	"2-7#-|-2#2-#2-2#|-#2-.*-$-#|-#-$.$-$@#|2#$-2*-3#|#2-$*.*.#-|#3-2.3#-|7#3-",0
      0  2f2f					      END_LEVEL	_033_L
      1  2f2f		       00 4a	   LEVEL_SIZE__033_L =	* - LEVEL_START
      2  2f2f				  -	      IF	LEVEL_SIZE__033_L > MAX_LEVEL_SIZE
      3  2f2f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__033_L
      4  2f2f					      ENDIF
      0  2f2f					      DEFL	_033_R, "-7#2-|2#2-#@-2#-|#-$-#3-2#|#-$2-$*$-#|#2-*.*.2-#|2#.*2.-$-#|-9#"
      0  2f2f					      START_LEVEL	_033_R
      1  2f2f				   LEVEL_START SET	*
      2  2f2f		       00 05	   BANK_LEVEL__033_R =	_CURRENT_BANK
      3  2f2f				   LEVEL__033_R SUBROUTINE
      4  2f2f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2f2f
      2  2f2f		       2d 37 23 32*	      .byte.b	"-7#2-|2#2-#@-2#-|#-$-#3-2#|#-$2-$*$-#|#2-*.*.2-#|2#.*2.-$-#|-9#",0
      0  2f6f					      END_LEVEL	_033_R
      1  2f6f		       00 40	   LEVEL_SIZE__033_R =	* - LEVEL_START
      2  2f6f				  -	      IF	LEVEL_SIZE__033_R > MAX_LEVEL_SIZE
      3  2f6f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__033_R
      4  2f6f					      ENDIF
      0  2f6f					      DEFL	_034_L, "5-4#-|-5#2-#-|-#-$@$2-#-|2#-#*$.*2#|#3-.2*2.#|#2-$2-4#|4#2-#3-|3-#2-#3-|3-4#3-"
      0  2f6f					      START_LEVEL	_034_L
      1  2f6f				   LEVEL_START SET	*
      2  2f6f		       00 05	   BANK_LEVEL__034_L =	_CURRENT_BANK
      3  2f6f				   LEVEL__034_L SUBROUTINE
      4  2f6f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2f6f
      2  2f6f		       35 2d 34 23*	      .byte.b	"5-4#-|-5#2-#-|-#-$@$2-#-|2#-#*$.*2#|#3-.2*2.#|#2-$2-4#|4#2-#3-|3-#2-#3-|3-4#3-",0
      0  2fbe					      END_LEVEL	_034_L
      1  2fbe		       00 4f	   LEVEL_SIZE__034_L =	* - LEVEL_START
      2  2fbe				  -	      IF	LEVEL_SIZE__034_L > MAX_LEVEL_SIZE
      3  2fbe				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__034_L
      4  2fbe					      ENDIF
     65  2fbe
      0  2fbe					      CHECK_BANK_SIZE	"LEVELS2"
      1  2fbe		       07 be	   .TEMP      =	* - BANK_START
 LEVELS2 (2K) SIZE =  $7be , FREE= $42
      2  2fbe					      ECHO	"LEVELS2", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2fbe				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2fbe				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2fbe				  -	      ERR
      6  2fbe					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS3.asm LEVEL 2 PASS 4
      0  2fbe					      include	"BANK_LEVELS3.asm"
      1  2fbe							;    Sokoboo - a Sokoban implementation
      2  2fbe							;    using a generic tile-based display engine for the Atari 2600
      3  2fbe							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  2fbe							;
      5  2fbe							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  2fbe							;
      7  2fbe							;    Code related to the generic tile-based display engine was developed by
      8  2fbe							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  2fbe							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  2fbe							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  2fbe							;
     12  2fbe							;    Code related to music and sound effects uses the TIATracker music player
     13  2fbe							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  2fbe							;    directory for Apache licensing details.
     15  2fbe							;
     16  2fbe							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  2fbe							;    See the copyright notices in the License directory for a list of level
     18  2fbe							;    contributors.
     19  2fbe							;
     20  2fbe							;    Except where otherwise indicated, this software is released under the
     21  2fbe							;    following licensing arrangement...
     22  2fbe							;
     23  2fbe							;    This program is free software: you can redistribute it and/or modify
     24  2fbe							;    it under the terms of the GNU General Public License as published by
     25  2fbe							;    the Free Software Foundation, either version 3 of the License, or
     26  2fbe							;    (at your option) any later version.
     27  2fbe							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  2fbe
     29  2fbe							;    This program is distributed in the hope that it will be useful,
     30  2fbe							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  2fbe							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  2fbe							;    GNU General Public License for more details.
     33  2fbe
      0  2fbe					      NEWBANK	LEVELS3
      1  37c7 ????				      SEG	LEVELS3
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   LEVELS3    SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	LEVELS3
     35  3000
      0  3000					      DEFL	_034_R, "-6#3-|-#4-#3-|2#-$.-3#-|#-2$*.$@#-|#-3.#2$2#|4#.4-#|3-3#-#-#|5-#3-#|5-5#"
      0  3000					      START_LEVEL	_034_R
      1  3000				   LEVEL_START SET	*
      2  3000		       00 06	   BANK_LEVEL__034_R =	_CURRENT_BANK
      3  3000				   LEVEL__034_R SUBROUTINE
      4  3000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3000
      2  3000		       2d 36 23 33*	      .byte.b	"-6#3-|-#4-#3-|2#-$.-3#-|#-2$*.$@#-|#-3.#2$2#|4#.4-#|3-3#-#-#|5-#3-#|5-5#",0
      0  3049					      END_LEVEL	_034_R
      1  3049		       00 49	   LEVEL_SIZE__034_R =	* - LEVEL_START
      2  3049				  -	      IF	LEVEL_SIZE__034_R > MAX_LEVEL_SIZE
      3  3049				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__034_R
      4  3049					      ENDIF
      0  3049					      DEFL	_035_L, "5-3#2-|6#.2#-|#@2-2#*.#-|#-3$2.-#-|2#2-$*.$2#|-#-$2-.2-#|-5#3-#|5-5#"
      0  3049					      START_LEVEL	_035_L
      1  3049				   LEVEL_START SET	*
      2  3049		       00 06	   BANK_LEVEL__035_L =	_CURRENT_BANK
      3  3049				   LEVEL__035_L SUBROUTINE
      4  3049				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3049
      2  3049		       35 2d 33 23*	      .byte.b	"5-3#2-|6#.2#-|#@2-2#*.#-|#-3$2.-#-|2#2-$*.$2#|-#-$2-.2-#|-5#3-#|5-5#",0
      0  308e					      END_LEVEL	_035_L
      1  308e		       00 45	   LEVEL_SIZE__035_L =	* - LEVEL_START
      2  308e				  -	      IF	LEVEL_SIZE__035_L > MAX_LEVEL_SIZE
      3  308e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__035_L
      4  308e					      ENDIF
      0  308e					      DEFL	_035_R, "-11#|-#4-@4-#|-#-2$3*$#-#|3#-*.$.-$-#|#3-.*.-4#|#3-2#.2#3-|8#4-"
      0  308e					      START_LEVEL	_035_R
      1  308e				   LEVEL_START SET	*
      2  308e		       00 06	   BANK_LEVEL__035_R =	_CURRENT_BANK
      3  308e				   LEVEL__035_R SUBROUTINE
      4  308e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  308e
      2  308e		       2d 31 31 23*	      .byte.b	"-11#|-#4-@4-#|-#-2$3*$#-#|3#-*.$.-$-#|#3-.*.-4#|#3-2#.2#3-|8#4-",0
      0  30ce					      END_LEVEL	_035_R
      1  30ce		       00 40	   LEVEL_SIZE__035_R =	* - LEVEL_START
      2  30ce				  -	      IF	LEVEL_SIZE__035_R > MAX_LEVEL_SIZE
      3  30ce				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__035_R
      4  30ce					      ENDIF
      0  30ce					      DEFL	_036_L, "5#2-|#3-3#|#*#-$@#|#.2-$-#|#.*2$-#|#2.#2-#|4#2-#|3-4#"
      0  30ce					      START_LEVEL	_036_L
      1  30ce				   LEVEL_START SET	*
      2  30ce		       00 06	   BANK_LEVEL__036_L =	_CURRENT_BANK
      3  30ce				   LEVEL__036_L SUBROUTINE
      4  30ce				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  30ce
      2  30ce		       35 23 32 2d*	      .byte.b	"5#2-|#3-3#|#*#-$@#|#.2-$-#|#.*2$-#|#2.#2-#|4#2-#|3-4#",0
      0  3104					      END_LEVEL	_036_L
      1  3104		       00 36	   LEVEL_SIZE__036_L =	* - LEVEL_START
      2  3104				  -	      IF	LEVEL_SIZE__036_L > MAX_LEVEL_SIZE
      3  3104				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__036_L
      4  3104					      ENDIF
      0  3104					      DEFL	_036_R, "2-5#2-|-2#.2-2#-|-#.*-$-2#|2#2.$-$-#|#.2*.-$@#|#2-$2-$2#|3#4-#-|2-6#-"
      0  3104					      START_LEVEL	_036_R
      1  3104				   LEVEL_START SET	*
      2  3104		       00 06	   BANK_LEVEL__036_R =	_CURRENT_BANK
      3  3104				   LEVEL__036_R SUBROUTINE
      4  3104				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3104
      2  3104		       32 2d 35 23*	      .byte.b	"2-5#2-|-2#.2-2#-|-#.*-$-2#|2#2.$-$-#|#.2*.-$@#|#2-$2-$2#|3#4-#-|2-6#-",0
      0  314a					      END_LEVEL	_036_R
      1  314a		       00 46	   LEVEL_SIZE__036_R =	* - LEVEL_START
      2  314a				  -	      IF	LEVEL_SIZE__036_R > MAX_LEVEL_SIZE
      3  314a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__036_R
      4  314a					      ENDIF
      0  314a					      DEFL	_037_L, "5-6#|6#4-#|#2-#@2.2$-#|#2-$.3*.-#|#3-$.$-$-#|2#2-#.3-2#|-9#-"
      0  314a					      START_LEVEL	_037_L
      1  314a				   LEVEL_START SET	*
      2  314a		       00 06	   BANK_LEVEL__037_L =	_CURRENT_BANK
      3  314a				   LEVEL__037_L SUBROUTINE
      4  314a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  314a
      2  314a		       35 2d 36 23*	      .byte.b	"5-6#|6#4-#|#2-#@2.2$-#|#2-$.3*.-#|#3-$.$-$-#|2#2-#.3-2#|-9#-",0
      0  3187					      END_LEVEL	_037_L
      1  3187		       00 3d	   LEVEL_SIZE__037_L =	* - LEVEL_START
      2  3187				  -	      IF	LEVEL_SIZE__037_L > MAX_LEVEL_SIZE
      3  3187				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__037_L
      4  3187					      ENDIF
      0  3187					      DEFL	_037_R, "9#2-|#7-3#|#-$2-.2*.-#|2#-*.*$3-#|-2#-2*.#2-#|2-2#@$-$-2#|3-3#3-#-|5-5#-"
      0  3187					      START_LEVEL	_037_R
      1  3187				   LEVEL_START SET	*
      2  3187		       00 06	   BANK_LEVEL__037_R =	_CURRENT_BANK
      3  3187				   LEVEL__037_R SUBROUTINE
      4  3187				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3187
      2  3187		       39 23 32 2d*	      .byte.b	"9#2-|#7-3#|#-$2-.2*.-#|2#-*.*$3-#|-2#-2*.#2-#|2-2#@$-$-2#|3-3#3-#-|5-5#-",0
      0  31d0					      END_LEVEL	_037_R
      1  31d0		       00 49	   LEVEL_SIZE__037_R =	* - LEVEL_START
      2  31d0				  -	      IF	LEVEL_SIZE__037_R > MAX_LEVEL_SIZE
      3  31d0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__037_R
      4  31d0					      ENDIF
      0  31d0					      DEFL	_038_L, "6-4#2-|4-3#@-3#|3-2#2.*$2-#|4#.*.*3-#|#2-2$3-$2-#|#5-6#|3#2-2#5-|2-4#6-"
      0  31d0					      START_LEVEL	_038_L
      1  31d0				   LEVEL_START SET	*
      2  31d0		       00 06	   BANK_LEVEL__038_L =	_CURRENT_BANK
      3  31d0				   LEVEL__038_L SUBROUTINE
      4  31d0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  31d0
      2  31d0		       36 2d 34 23*	      .byte.b	"6-4#2-|4-3#@-3#|3-2#2.*$2-#|4#.*.*3-#|#2-2$3-$2-#|#5-6#|3#2-2#5-|2-4#6-",0
      0  3218					      END_LEVEL	_038_L
      1  3218		       00 48	   LEVEL_SIZE__038_L =	* - LEVEL_START
      2  3218				  -	      IF	LEVEL_SIZE__038_L > MAX_LEVEL_SIZE
      3  3218				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__038_L
      4  3218					      ENDIF
      0  3218					      DEFL	_038_R, "6-6#|4-3#.#-@#|2-3#2.*#$-#|3#-.*2.-$-#|#2-2$2-#-3#|#-$2-#-$-#2-|2#5-3#2-|-7#4-"
      0  3218					      START_LEVEL	_038_R
      1  3218				   LEVEL_START SET	*
      2  3218		       00 06	   BANK_LEVEL__038_R =	_CURRENT_BANK
      3  3218				   LEVEL__038_R SUBROUTINE
      4  3218				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3218
      2  3218		       36 2d 36 23*	      .byte.b	"6-6#|4-3#.#-@#|2-3#2.*#$-#|3#-.*2.-$-#|#2-2$2-#-3#|#-$2-#-$-#2-|2#5-3#2-|-7#4-",0
      0  3267					      END_LEVEL	_038_R
      1  3267		       00 4f	   LEVEL_SIZE__038_R =	* - LEVEL_START
      2  3267				  -	      IF	LEVEL_SIZE__038_R > MAX_LEVEL_SIZE
      3  3267				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__038_R
      4  3267					      ENDIF
      0  3267					      DEFL	_039_L, "-7#2-|-#5-#2-|2#-#-$-#2-|#.2*.-3#-|2#@3*2-2#|-2#-2.$2-#|2-2#$#-$-#|3-#5-#|3-7#"
      0  3267					      START_LEVEL	_039_L
      1  3267				   LEVEL_START SET	*
      2  3267		       00 06	   BANK_LEVEL__039_L =	_CURRENT_BANK
      3  3267				   LEVEL__039_L SUBROUTINE
      4  3267				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3267
      2  3267		       2d 37 23 32*	      .byte.b	"-7#2-|-#5-#2-|2#-#-$-#2-|#.2*.-3#-|2#@3*2-2#|-2#-2.$2-#|2-2#$#-$-#|3-#5-#|3-7#",0
      0  32b6					      END_LEVEL	_039_L
      1  32b6		       00 4f	   LEVEL_SIZE__039_L =	* - LEVEL_START
      2  32b6				  -	      IF	LEVEL_SIZE__039_L > MAX_LEVEL_SIZE
      3  32b6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__039_L
      4  32b6					      ENDIF
      0  32b6					      DEFL	_039_R, "4-4#4-|3-2#2-3#2-|2-2#-$.2-#2-|3#-.2*-$3#|#-$-4.3-#|#@$3#-#-#-#|2#4-$2-$-#|-5#3-3#|5-5#2-"
      0  32b6					      START_LEVEL	_039_R
      1  32b6				   LEVEL_START SET	*
      2  32b6		       00 06	   BANK_LEVEL__039_R =	_CURRENT_BANK
      3  32b6				   LEVEL__039_R SUBROUTINE
      4  32b6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  32b6
      2  32b6		       34 2d 34 23*	      .byte.b	"4-4#4-|3-2#2-3#2-|2-2#-$.2-#2-|3#-.2*-$3#|#-$-4.3-#|#@$3#-#-#-#|2#4-$2-$-#|-5#3-3#|5-5#2-",0
      0  3310					      END_LEVEL	_039_R
      1  3310		       00 5a	   LEVEL_SIZE__039_R =	* - LEVEL_START
      2  3310					      IF	LEVEL_SIZE__039_R > MAX_LEVEL_SIZE
      3  3310				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__039_R
      4  3310					      ENDIF
      0  3310					      DEFL	_040_L, "6#3-|#3-@#3-|#2-$.3#-|3#$*$.2#|3#-.2*.#|#2-$-.3#|#2-$3-#-|4#3-#-|3-5#-"
      0  3310					      START_LEVEL	_040_L
      1  3310				   LEVEL_START SET	*
      2  3310		       00 06	   BANK_LEVEL__040_L =	_CURRENT_BANK
      3  3310				   LEVEL__040_L SUBROUTINE
      4  3310				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3310
      2  3310		       36 23 33 2d*	      .byte.b	"6#3-|#3-@#3-|#2-$.3#-|3#$*$.2#|3#-.2*.#|#2-$-.3#|#2-$3-#-|4#3-#-|3-5#-",0
      0  3357					      END_LEVEL	_040_L
      1  3357		       00 47	   LEVEL_SIZE__040_L =	* - LEVEL_START
      2  3357				  -	      IF	LEVEL_SIZE__040_L > MAX_LEVEL_SIZE
      3  3357				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__040_L
      4  3357					      ENDIF
      0  3357					      DEFL	_040_R, "5-4#-|-5#2-2#|2#.-$2-$-#|#-2.*.$#@#|#-*-.2-$-#|2#-$*-4#|-#3-2#3-|-5#4-"
      0  3357					      START_LEVEL	_040_R
      1  3357				   LEVEL_START SET	*
      2  3357		       00 06	   BANK_LEVEL__040_R =	_CURRENT_BANK
      3  3357				   LEVEL__040_R SUBROUTINE
      4  3357				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3357
      2  3357		       35 2d 34 23*	      .byte.b	"5-4#-|-5#2-2#|2#.-$2-$-#|#-2.*.$#@#|#-*-.2-$-#|2#-$*-4#|-#3-2#3-|-5#4-",0
      0  339e					      END_LEVEL	_040_R
      1  339e		       00 47	   LEVEL_SIZE__040_R =	* - LEVEL_START
      2  339e				  -	      IF	LEVEL_SIZE__040_R > MAX_LEVEL_SIZE
      3  339e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__040_R
      4  339e					      ENDIF
     49  339e
      0  339e					      DEFL	_041_L, "4-3#5-|4-#.4#2-|5#*.$-#2-|#4-3.-3#|#-3$-*.$2-#|2#-@2#.$-$-#|-5#4-2#|5-6#-"
      0  339e					      START_LEVEL	_041_L
      1  339e				   LEVEL_START SET	*
      2  339e		       00 06	   BANK_LEVEL__041_L =	_CURRENT_BANK
      3  339e				   LEVEL__041_L SUBROUTINE
      4  339e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  339e
      2  339e		       34 2d 33 23*	      .byte.b	"4-3#5-|4-#.4#2-|5#*.$-#2-|#4-3.-3#|#-3$-*.$2-#|2#-@2#.$-$-#|-5#4-2#|5-6#-",0
      0  33e8					      END_LEVEL	_041_L
      1  33e8		       00 4a	   LEVEL_SIZE__041_L =	* - LEVEL_START
      2  33e8				  -	      IF	LEVEL_SIZE__041_L > MAX_LEVEL_SIZE
      3  33e8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__041_L
      4  33e8					      ENDIF
      0  33e8					      DEFL	_041_R, "-4#3-|2#2-3#-|#-@2$-#-|#-$-#.#-|2#$-2.2#|#2-$*2.#|#2-$-*2#|#3-#.#-|7#-"
      0  33e8					      START_LEVEL	_041_R
      1  33e8				   LEVEL_START SET	*
      2  33e8		       00 06	   BANK_LEVEL__041_R =	_CURRENT_BANK
      3  33e8				   LEVEL__041_R SUBROUTINE
      4  33e8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  33e8
      2  33e8		       2d 34 23 33*	      .byte.b	"-4#3-|2#2-3#-|#-@2$-#-|#-$-#.#-|2#$-2.2#|#2-$*2.#|#2-$-*2#|#3-#.#-|7#-",0
      0  342f					      END_LEVEL	_041_R
      1  342f		       00 47	   LEVEL_SIZE__041_R =	* - LEVEL_START
      2  342f				  -	      IF	LEVEL_SIZE__041_R > MAX_LEVEL_SIZE
      3  342f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__041_R
      4  342f					      ENDIF
      0  342f					      DEFL	_042_L, "8#4-|#6-#4-|#-#-$*-#4-|#-#-#.3#3-|#3-#2.-3#-|#3-2*4-2#|5#.-3$-#|4-4#2-@#|7-5#"
      0  342f					      START_LEVEL	_042_L
      1  342f				   LEVEL_START SET	*
      2  342f		       00 06	   BANK_LEVEL__042_L =	_CURRENT_BANK
      3  342f				   LEVEL__042_L SUBROUTINE
      4  342f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  342f
      2  342f		       38 23 34 2d*	      .byte.b	"8#4-|#6-#4-|#-#-$*-#4-|#-#-#.3#3-|#3-#2.-3#-|#3-2*4-2#|5#.-3$-#|4-4#2-@#|7-5#",0
      0  347d					      END_LEVEL	_042_L
      1  347d		       00 4e	   LEVEL_SIZE__042_L =	* - LEVEL_START
      2  347d				  -	      IF	LEVEL_SIZE__042_L > MAX_LEVEL_SIZE
      3  347d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__042_L
      4  347d					      ENDIF
      0  347d					      DEFL	_042_R, "3-5#4-|2-2#3-#4-|2-#-$-$#4-|3#-*.-2#3-|#@$-#.$-2#2-|#-$2-.*.-3#|3#2.*-$3-#|2-6#3-#|7-5#"
      0  347d					      START_LEVEL	_042_R
      1  347d				   LEVEL_START SET	*
      2  347d		       00 06	   BANK_LEVEL__042_R =	_CURRENT_BANK
      3  347d				   LEVEL__042_R SUBROUTINE
      4  347d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  347d
      2  347d		       33 2d 35 23*	      .byte.b	"3-5#4-|2-2#3-#4-|2-#-$-$#4-|3#-*.-2#3-|#@$-#.$-2#2-|#-$2-.*.-3#|3#2.*-$3-#|2-6#3-#|7-5#",0
      0  34d5					      END_LEVEL	_042_R
      1  34d5		       00 58	   LEVEL_SIZE__042_R =	* - LEVEL_START
      2  34d5				  -	      IF	LEVEL_SIZE__042_R > MAX_LEVEL_SIZE
      3  34d5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__042_R
      4  34d5					      ENDIF
      0  34d5					      DEFL	_043_L, "-8#4-|-#@$.-.-5#|-#2$*.2*.3-#|2#2-$-.2-#$-#|#-$-2#.#3-2#|#3-8#-|#2-2#8-|4#9-"
      0  34d5					      START_LEVEL	_043_L
      1  34d5				   LEVEL_START SET	*
      2  34d5		       00 06	   BANK_LEVEL__043_L =	_CURRENT_BANK
      3  34d5				   LEVEL__043_L SUBROUTINE
      4  34d5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  34d5
      2  34d5		       2d 38 23 34*	      .byte.b	"-8#4-|-#@$.-.-5#|-#2$*.2*.3-#|2#2-$-.2-#$-#|#-$-2#.#3-2#|#3-8#-|#2-2#8-|4#9-",0
      0  3522					      END_LEVEL	_043_L
      1  3522		       00 4d	   LEVEL_SIZE__043_L =	* - LEVEL_START
      2  3522				  -	      IF	LEVEL_SIZE__043_L > MAX_LEVEL_SIZE
      3  3522				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__043_L
      4  3522					      ENDIF
      0  3522					      DEFL	_043_R, "2-6#-|-2#4-#-|2#@$-#-#-|#-$#$2.#-|#*.*2.*2#|#-$2-$2.#|#-$-$2-2#|#4-3#-|6#3-"
      0  3522					      START_LEVEL	_043_R
      1  3522				   LEVEL_START SET	*
      2  3522		       00 06	   BANK_LEVEL__043_R =	_CURRENT_BANK
      3  3522				   LEVEL__043_R SUBROUTINE
      4  3522				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3522
      2  3522		       32 2d 36 23*	      .byte.b	"2-6#-|-2#4-#-|2#@$-#-#-|#-$#$2.#-|#*.*2.*2#|#-$2-$2.#|#-$-$2-2#|#4-3#-|6#3-",0
      0  356e					      END_LEVEL	_043_R
      1  356e		       00 4c	   LEVEL_SIZE__043_R =	* - LEVEL_START
      2  356e				  -	      IF	LEVEL_SIZE__043_R > MAX_LEVEL_SIZE
      3  356e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__043_R
      4  356e					      ENDIF
      0  356e					      DEFL	_044_L, "7#-|#@4-#-|#$-.2$#-|#3.*-2#|#*$2*2-#|#3-#2-#|#3-#2-#|8#"
      0  356e					      START_LEVEL	_044_L
      1  356e				   LEVEL_START SET	*
      2  356e		       00 06	   BANK_LEVEL__044_L =	_CURRENT_BANK
      3  356e				   LEVEL__044_L SUBROUTINE
      4  356e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  356e
      2  356e		       37 23 2d 7c*	      .byte.b	"7#-|#@4-#-|#$-.2$#-|#3.*-2#|#*$2*2-#|#3-#2-#|#3-#2-#|8#",0
      0  35a6					      END_LEVEL	_044_L
      1  35a6		       00 38	   LEVEL_SIZE__044_L =	* - LEVEL_START
      2  35a6				  -	      IF	LEVEL_SIZE__044_L > MAX_LEVEL_SIZE
      3  35a6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__044_L
      4  35a6					      ENDIF
      0  35a6					      DEFL	_044_R, "4#-4#-|#2-3#2-#-|#@$2-#-$2#|#$*$5-#|#-*2.$2#-#|#3.#4-#|2#-.-$4#|-3#2-#3-|3-4#3-"
      0  35a6					      START_LEVEL	_044_R
      1  35a6				   LEVEL_START SET	*
      2  35a6		       00 06	   BANK_LEVEL__044_R =	_CURRENT_BANK
      3  35a6				   LEVEL__044_R SUBROUTINE
      4  35a6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35a6
      2  35a6		       34 23 2d 34*	      .byte.b	"4#-4#-|#2-3#2-#-|#@$2-#-$2#|#$*$5-#|#-*2.$2#-#|#3.#4-#|2#-.-$4#|-3#2-#3-|3-4#3-",0
      0  35f6					      END_LEVEL	_044_R
      1  35f6		       00 50	   LEVEL_SIZE__044_R =	* - LEVEL_START
      2  35f6				  -	      IF	LEVEL_SIZE__044_R > MAX_LEVEL_SIZE
      3  35f6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__044_R
      4  35f6					      ENDIF
      0  35f6					      DEFL	_045_L, "3-4#2-|3-#2.3#|4#$.$-#|#@-#-.*-#|#-$2-2*.#|2#-$-*2-#|-2#-$3-#|2-2#2-3#|3-4#2-"
      0  35f6					      START_LEVEL	_045_L
      1  35f6				   LEVEL_START SET	*
      2  35f6		       00 06	   BANK_LEVEL__045_L =	_CURRENT_BANK
      3  35f6				   LEVEL__045_L SUBROUTINE
      4  35f6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35f6
      2  35f6		       33 2d 34 23*	      .byte.b	"3-4#2-|3-#2.3#|4#$.$-#|#@-#-.*-#|#-$2-2*.#|2#-$-*2-#|-2#-$3-#|2-2#2-3#|3-4#2-",0
      0  3644					      END_LEVEL	_045_L
      1  3644		       00 4e	   LEVEL_SIZE__045_L =	* - LEVEL_START
      2  3644				  -	      IF	LEVEL_SIZE__045_L > MAX_LEVEL_SIZE
      3  3644				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__045_L
      4  3644					      ENDIF
      0  3644					      DEFL	_045_R, "3-6#2-|4#4-#2-|#-$-$2#-3#|#-2$-$-$2-#|#-5.#$-#|#-.*#$2.2-#|2#.-$@5#|-6#4-"
      0  3644					      START_LEVEL	_045_R
      1  3644				   LEVEL_START SET	*
      2  3644		       00 06	   BANK_LEVEL__045_R =	_CURRENT_BANK
      3  3644				   LEVEL__045_R SUBROUTINE
      4  3644				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3644
      2  3644		       33 2d 36 23*	      .byte.b	"3-6#2-|4#4-#2-|#-$-$2#-3#|#-2$-$-$2-#|#-5.#$-#|#-.*#$2.2-#|2#.-$@5#|-6#4-",0
      0  368e					      END_LEVEL	_045_R
      1  368e		       00 4a	   LEVEL_SIZE__045_R =	* - LEVEL_START
      2  368e				  -	      IF	LEVEL_SIZE__045_R > MAX_LEVEL_SIZE
      3  368e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__045_R
      4  368e					      ENDIF
      0  368e					      DEFL	_046_L, "10#-|#@3-#3-2#|#-#*$2-2$-#|#-*.$-$3-#|3#.*$-#2-#|2-#.*.-4#|2-#2.-2#3-|2-5#4-"
      0  368e					      START_LEVEL	_046_L
      1  368e				   LEVEL_START SET	*
      2  368e		       00 06	   BANK_LEVEL__046_L =	_CURRENT_BANK
      3  368e				   LEVEL__046_L SUBROUTINE
      4  368e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  368e
      2  368e		       31 30 23 2d*	      .byte.b	"10#-|#@3-#3-2#|#-#*$2-2$-#|#-*.$-$3-#|3#.*$-#2-#|2-#.*.-4#|2-#2.-2#3-|2-5#4-",0
      0  36db					      END_LEVEL	_046_L
      1  36db		       00 4d	   LEVEL_SIZE__046_L =	* - LEVEL_START
      2  36db				  -	      IF	LEVEL_SIZE__046_L > MAX_LEVEL_SIZE
      3  36db				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__046_L
      4  36db					      ENDIF
      0  36db					      DEFL	_046_R, "8#3-|#3-4#3-|#-$2-$@3#-|#2-5$-#-|3#3.*2.2#|2-2#2-$3.#|3-#2-5#|3-4#4-"
      0  36db					      START_LEVEL	_046_R
      1  36db				   LEVEL_START SET	*
      2  36db		       00 06	   BANK_LEVEL__046_R =	_CURRENT_BANK
      3  36db				   LEVEL__046_R SUBROUTINE
      4  36db				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  36db
      2  36db		       38 23 33 2d*	      .byte.b	"8#3-|#3-4#3-|#-$2-$@3#-|#2-5$-#-|3#3.*2.2#|2-2#2-$3.#|3-#2-5#|3-4#4-",0
      0  3720					      END_LEVEL	_046_R
      1  3720		       00 45	   LEVEL_SIZE__046_R =	* - LEVEL_START
      2  3720				  -	      IF	LEVEL_SIZE__046_R > MAX_LEVEL_SIZE
      3  3720				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__046_R
      4  3720					      ENDIF
      0  3720					      DEFL	_047_L, "5-3#5-|3-3#.#5-|2-2#2-.#5-|2-#-$#.6#|3#3-.2#3-#|#-$@2*.$-$#-#|#4-2#-$3-#|8#3-2#|7-5#-"
      0  3720					      START_LEVEL	_047_L
      1  3720				   LEVEL_START SET	*
      2  3720		       00 06	   BANK_LEVEL__047_L =	_CURRENT_BANK
      3  3720				   LEVEL__047_L SUBROUTINE
      4  3720				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3720
      2  3720		       35 2d 33 23*	      .byte.b	"5-3#5-|3-3#.#5-|2-2#2-.#5-|2-#-$#.6#|3#3-.2#3-#|#-$@2*.$-$#-#|#4-2#-$3-#|8#3-2#|7-5#-",0
      0  3776					      END_LEVEL	_047_L
      1  3776		       00 56	   LEVEL_SIZE__047_L =	* - LEVEL_START
      2  3776				  -	      IF	LEVEL_SIZE__047_L > MAX_LEVEL_SIZE
      3  3776				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__047_L
      4  3776					      ENDIF
      0  3776					      DEFL	_047_R, "4-6#|3-2#3-@#|-3#-3$-#|-#.2-#-$-#|2#.*2-$2-#|#2.-2$#-2#|2#2.#-3#-|-#.3-#3-|-6#3-"
      0  3776					      START_LEVEL	_047_R
      1  3776				   LEVEL_START SET	*
      2  3776		       00 06	   BANK_LEVEL__047_R =	_CURRENT_BANK
      3  3776				   LEVEL__047_R SUBROUTINE
      4  3776				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3776
      2  3776		       34 2d 36 23*	      .byte.b	"4-6#|3-2#3-@#|-3#-3$-#|-#.2-#-$-#|2#.*2-$2-#|#2.-2$#-2#|2#2.#-3#-|-#.3-#3-|-6#3-",0
      0  37c7					      END_LEVEL	_047_R
      1  37c7		       00 51	   LEVEL_SIZE__047_R =	* - LEVEL_START
      2  37c7				  -	      IF	LEVEL_SIZE__047_R > MAX_LEVEL_SIZE
      3  37c7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__047_R
      4  37c7					      ENDIF
     64  37c7
     65  37c7
     66  37c7
      0  37c7					      CHECK_BANK_SIZE	"LEVELS3 -- full 2K"
      1  37c7		       07 c7	   .TEMP      =	* - BANK_START
 LEVELS3 -- full 2K (2K) SIZE =  $7c7 , FREE= $39
      2  37c7					      ECHO	"LEVELS3 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  37c7				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  37c7				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  37c7				  -	      ERR
      6  37c7					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS4.asm LEVEL 2 PASS 4
      0  37c7					      include	"BANK_LEVELS4.asm"
      1  37c7							;    Sokoboo - a Sokoban implementation
      2  37c7							;    using a generic tile-based display engine for the Atari 2600
      3  37c7							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  37c7							;
      5  37c7							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  37c7							;
      7  37c7							;    Code related to the generic tile-based display engine was developed by
      8  37c7							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  37c7							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  37c7							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  37c7							;
     12  37c7							;    Code related to music and sound effects uses the TIATracker music player
     13  37c7							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  37c7							;    directory for Apache licensing details.
     15  37c7							;
     16  37c7							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  37c7							;    See the copyright notices in the License directory for a list of level
     18  37c7							;    contributors.
     19  37c7							;
     20  37c7							;    Except where otherwise indicated, this software is released under the
     21  37c7							;    following licensing arrangement...
     22  37c7							;
     23  37c7							;    This program is free software: you can redistribute it and/or modify
     24  37c7							;    it under the terms of the GNU General Public License as published by
     25  37c7							;    the Free Software Foundation, either version 3 of the License, or
     26  37c7							;    (at your option) any later version.
     27  37c7							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  37c7
     29  37c7							;    This program is distributed in the hope that it will be useful,
     30  37c7							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  37c7							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  37c7							;    GNU General Public License for more details.
     33  37c7
     34  37c7							; level definitions
     35  37c7							; Sample level definitions.
     36  37c7							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  37c7							; have as many banks as you like.
     38  37c7
      0  37c7					      NEWBANK	LEVELS4
      1  3f4a ????				      SEG	LEVELS4
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   LEVELS4    SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	LEVELS4
     40  3800
      0  3800					      DEFL	_048_L, "2-7#-|2-#5-2#|3#$2-#2-#|#-$.3-$-#|#.2*2-4#|#+.#-2#3-|2#$3-#3-|-#4-#3-|-6#3-"
      0  3800					      START_LEVEL	_048_L
      1  3800				   LEVEL_START SET	*
      2  3800		       00 07	   BANK_LEVEL__048_L =	_CURRENT_BANK
      3  3800				   LEVEL__048_L SUBROUTINE
      4  3800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3800
      2  3800		       32 2d 37 23*	      .byte.b	"2-7#-|2-#5-2#|3#$2-#2-#|#-$.3-$-#|#.2*2-4#|#+.#-2#3-|2#$3-#3-|-#4-#3-|-6#3-",0
      0  384c					      END_LEVEL	_048_L
      1  384c		       00 4c	   LEVEL_SIZE__048_L =	* - LEVEL_START
      2  384c				  -	      IF	LEVEL_SIZE__048_L > MAX_LEVEL_SIZE
      3  384c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__048_L
      4  384c					      ENDIF
      0  384c					      DEFL	_048_R, "5-5#|2-4#3-#|3#-.$-$-#|#2-*3.3#|#2-*.-4#|2#2$*$3-#|-#@$.4-#|-4#2-3#|4-4#2-"
      0  384c					      START_LEVEL	_048_R
      1  384c				   LEVEL_START SET	*
      2  384c		       00 07	   BANK_LEVEL__048_R =	_CURRENT_BANK
      3  384c				   LEVEL__048_R SUBROUTINE
      4  384c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  384c
      2  384c		       35 2d 35 23*	      .byte.b	"5-5#|2-4#3-#|3#-.$-$-#|#2-*3.3#|#2-*.-4#|2#2$*$3-#|-#@$.4-#|-4#2-3#|4-4#2-",0
      0  3897					      END_LEVEL	_048_R
      1  3897		       00 4b	   LEVEL_SIZE__048_R =	* - LEVEL_START
      2  3897				  -	      IF	LEVEL_SIZE__048_R > MAX_LEVEL_SIZE
      3  3897				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__048_R
      4  3897					      ENDIF
      0  3897					      DEFL	_049_L, "4#7-|#2-4#4-|#2-$2-5#|#-$-#-4.#|2#-2$-.-.2#|-#$-#-*#-#-|-#-@#$-#-#-|-4#4-#-|4-6#-"
      0  3897					      START_LEVEL	_049_L
      1  3897				   LEVEL_START SET	*
      2  3897		       00 07	   BANK_LEVEL__049_L =	_CURRENT_BANK
      3  3897				   LEVEL__049_L SUBROUTINE
      4  3897				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3897
      2  3897		       34 23 37 2d*	      .byte.b	"4#7-|#2-4#4-|#2-$2-5#|#-$-#-4.#|2#-2$-.-.2#|-#$-#-*#-#-|-#-@#$-#-#-|-4#4-#-|4-6#-",0
      0  38e9					      END_LEVEL	_049_L
      1  38e9		       00 52	   LEVEL_SIZE__049_L =	* - LEVEL_START
      2  38e9				  -	      IF	LEVEL_SIZE__049_L > MAX_LEVEL_SIZE
      3  38e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__049_L
      4  38e9					      ENDIF
      0  38e9					      DEFL	_049_R, "8#2-|#6-3#|#-$2#$.*-#|#-$-$2.*+#|#3-#2.$-#|#-2$#-.3#|2#5-#2-|-7#2-"
      0  38e9					      START_LEVEL	_049_R
      1  38e9				   LEVEL_START SET	*
      2  38e9		       00 07	   BANK_LEVEL__049_R =	_CURRENT_BANK
      3  38e9				   LEVEL__049_R SUBROUTINE
      4  38e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  38e9
      2  38e9		       38 23 32 2d*	      .byte.b	"8#2-|#6-3#|#-$2#$.*-#|#-$-$2.*+#|#3-#2.$-#|#-2$#-.3#|2#5-#2-|-7#2-",0
      0  392c					      END_LEVEL	_049_R
      1  392c		       00 43	   LEVEL_SIZE__049_R =	* - LEVEL_START
      2  392c				  -	      IF	LEVEL_SIZE__049_R > MAX_LEVEL_SIZE
      3  392c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__049_R
      4  392c					      ENDIF
     45  392c
      0  392c					      DEFL	_050_L, "4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#"
      0  392c					      START_LEVEL	_050_L
      1  392c				   LEVEL_START SET	*
      2  392c		       00 07	   BANK_LEVEL__050_L =	_CURRENT_BANK
      3  392c				   LEVEL__050_L SUBROUTINE
      4  392c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  392c
      2  392c		       34 2d 35 23*	      .byte.b	"4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#",0
      0  3979					      END_LEVEL	_050_L
      1  3979		       00 4d	   LEVEL_SIZE__050_L =	* - LEVEL_START
      2  3979				  -	      IF	LEVEL_SIZE__050_L > MAX_LEVEL_SIZE
      3  3979				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_L
      4  3979					      ENDIF
      0  3979					      DEFL	_050_R, "8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#"
      0  3979					      START_LEVEL	_050_R
      1  3979				   LEVEL_START SET	*
      2  3979		       00 07	   BANK_LEVEL__050_R =	_CURRENT_BANK
      3  3979				   LEVEL__050_R SUBROUTINE
      4  3979				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3979
      2  3979		       38 23 7c 23*	      .byte.b	"8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#",0
      0  39b2					      END_LEVEL	_050_R
      1  39b2		       00 39	   LEVEL_SIZE__050_R =	* - LEVEL_START
      2  39b2				  -	      IF	LEVEL_SIZE__050_R > MAX_LEVEL_SIZE
      3  39b2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_R
      4  39b2					      ENDIF
      0  39b2					      DEFL	_051_L, "-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#"
      0  39b2					      START_LEVEL	_051_L
      1  39b2				   LEVEL_START SET	*
      2  39b2		       00 07	   BANK_LEVEL__051_L =	_CURRENT_BANK
      3  39b2				   LEVEL__051_L SUBROUTINE
      4  39b2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  39b2
      2  39b2		       2d 36 23 34*	      .byte.b	"-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#",0
      0  3a05					      END_LEVEL	_051_L
      1  3a05		       00 53	   LEVEL_SIZE__051_L =	* - LEVEL_START
      2  3a05				  -	      IF	LEVEL_SIZE__051_L > MAX_LEVEL_SIZE
      3  3a05				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_L
      4  3a05					      ENDIF
      0  3a05					      DEFL	_051_R, "-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-"
      0  3a05					      START_LEVEL	_051_R
      1  3a05				   LEVEL_START SET	*
      2  3a05		       00 07	   BANK_LEVEL__051_R =	_CURRENT_BANK
      3  3a05				   LEVEL__051_R SUBROUTINE
      4  3a05				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a05
      2  3a05		       2d 38 23 2d*	      .byte.b	"-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-",0
      0  3a56					      END_LEVEL	_051_R
      1  3a56		       00 51	   LEVEL_SIZE__051_R =	* - LEVEL_START
      2  3a56				  -	      IF	LEVEL_SIZE__051_R > MAX_LEVEL_SIZE
      3  3a56				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_R
      4  3a56					      ENDIF
      0  3a56					      DEFL	_052_L, "5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-"
      0  3a56					      START_LEVEL	_052_L
      1  3a56				   LEVEL_START SET	*
      2  3a56		       00 07	   BANK_LEVEL__052_L =	_CURRENT_BANK
      3  3a56				   LEVEL__052_L SUBROUTINE
      4  3a56				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a56
      2  3a56		       35 23 36 2d*	      .byte.b	"5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-",0
      0  3a90					      END_LEVEL	_052_L
      1  3a90		       00 3a	   LEVEL_SIZE__052_L =	* - LEVEL_START
      2  3a90				  -	      IF	LEVEL_SIZE__052_L > MAX_LEVEL_SIZE
      3  3a90				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_L
      4  3a90					      ENDIF
      0  3a90					      DEFL	_052_R, "2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-"
      0  3a90					      START_LEVEL	_052_R
      1  3a90				   LEVEL_START SET	*
      2  3a90		       00 07	   BANK_LEVEL__052_R =	_CURRENT_BANK
      3  3a90				   LEVEL__052_R SUBROUTINE
      4  3a90				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a90
      2  3a90		       32 2d 37 23*	      .byte.b	"2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-",0
      0  3ad8					      END_LEVEL	_052_R
      1  3ad8		       00 48	   LEVEL_SIZE__052_R =	* - LEVEL_START
      2  3ad8				  -	      IF	LEVEL_SIZE__052_R > MAX_LEVEL_SIZE
      3  3ad8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_R
      4  3ad8					      ENDIF
      0  3ad8					      DEFL	_053_L, "6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-"
      0  3ad8					      START_LEVEL	_053_L
      1  3ad8				   LEVEL_START SET	*
      2  3ad8		       00 07	   BANK_LEVEL__053_L =	_CURRENT_BANK
      3  3ad8				   LEVEL__053_L SUBROUTINE
      4  3ad8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ad8
      2  3ad8		       36 23 36 2d*	      .byte.b	"6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-",0
      0  3b2d					      END_LEVEL	_053_L
      1  3b2d		       00 55	   LEVEL_SIZE__053_L =	* - LEVEL_START
      2  3b2d				  -	      IF	LEVEL_SIZE__053_L > MAX_LEVEL_SIZE
      3  3b2d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_L
      4  3b2d					      ENDIF
      0  3b2d					      DEFL	_053_R, "5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-"
      0  3b2d					      START_LEVEL	_053_R
      1  3b2d				   LEVEL_START SET	*
      2  3b2d		       00 07	   BANK_LEVEL__053_R =	_CURRENT_BANK
      3  3b2d				   LEVEL__053_R SUBROUTINE
      4  3b2d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b2d
      2  3b2d		       35 2d 35 23*	      .byte.b	"5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-",0
      0  3b7a					      END_LEVEL	_053_R
      1  3b7a		       00 4d	   LEVEL_SIZE__053_R =	* - LEVEL_START
      2  3b7a				  -	      IF	LEVEL_SIZE__053_R > MAX_LEVEL_SIZE
      3  3b7a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_R
      4  3b7a					      ENDIF
      0  3b7a					      DEFL	_054_L, "-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-"
      0  3b7a					      START_LEVEL	_054_L
      1  3b7a				   LEVEL_START SET	*
      2  3b7a		       00 07	   BANK_LEVEL__054_L =	_CURRENT_BANK
      3  3b7a				   LEVEL__054_L SUBROUTINE
      4  3b7a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b7a
      2  3b7a		       2d 38 23 32*	      .byte.b	"-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-",0
      0  3bc6					      END_LEVEL	_054_L
      1  3bc6		       00 4c	   LEVEL_SIZE__054_L =	* - LEVEL_START
      2  3bc6				  -	      IF	LEVEL_SIZE__054_L > MAX_LEVEL_SIZE
      3  3bc6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_L
      4  3bc6					      ENDIF
      0  3bc6					      DEFL	_054_R, "2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-"
      0  3bc6					      START_LEVEL	_054_R
      1  3bc6				   LEVEL_START SET	*
      2  3bc6		       00 07	   BANK_LEVEL__054_R =	_CURRENT_BANK
      3  3bc6				   LEVEL__054_R SUBROUTINE
      4  3bc6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3bc6
      2  3bc6		       32 2d 34 23*	      .byte.b	"2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-",0
      0  3c0f					      END_LEVEL	_054_R
      1  3c0f		       00 49	   LEVEL_SIZE__054_R =	* - LEVEL_START
      2  3c0f				  -	      IF	LEVEL_SIZE__054_R > MAX_LEVEL_SIZE
      3  3c0f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_R
      4  3c0f					      ENDIF
      0  3c0f					      DEFL	_055_L, "2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-"
      0  3c0f					      START_LEVEL	_055_L
      1  3c0f				   LEVEL_START SET	*
      2  3c0f		       00 07	   BANK_LEVEL__055_L =	_CURRENT_BANK
      3  3c0f				   LEVEL__055_L SUBROUTINE
      4  3c0f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c0f
      2  3c0f		       32 2d 34 23*	      .byte.b	"2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-",0
      0  3c69					      END_LEVEL	_055_L
      1  3c69		       00 5a	   LEVEL_SIZE__055_L =	* - LEVEL_START
      2  3c69				  -	      IF	LEVEL_SIZE__055_L > MAX_LEVEL_SIZE
      3  3c69				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_L
      4  3c69					      ENDIF
      0  3c69					      DEFL	_055_R, "5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-"
      0  3c69					      START_LEVEL	_055_R
      1  3c69				   LEVEL_START SET	*
      2  3c69		       00 07	   BANK_LEVEL__055_R =	_CURRENT_BANK
      3  3c69				   LEVEL__055_R SUBROUTINE
      4  3c69				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c69
      2  3c69		       35 2d 34 23*	      .byte.b	"5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-",0
      0  3cbe					      END_LEVEL	_055_R
      1  3cbe		       00 55	   LEVEL_SIZE__055_R =	* - LEVEL_START
      2  3cbe				  -	      IF	LEVEL_SIZE__055_R > MAX_LEVEL_SIZE
      3  3cbe				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_R
      4  3cbe					      ENDIF
      0  3cbe					      DEFL	_056_L, "6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#"
      0  3cbe					      START_LEVEL	_056_L
      1  3cbe				   LEVEL_START SET	*
      2  3cbe		       00 07	   BANK_LEVEL__056_L =	_CURRENT_BANK
      3  3cbe				   LEVEL__056_L SUBROUTINE
      4  3cbe				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3cbe
      2  3cbe		       36 2d 35 23*	      .byte.b	"6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#",0
      0  3d18					      END_LEVEL	_056_L
      1  3d18		       00 5a	   LEVEL_SIZE__056_L =	* - LEVEL_START
      2  3d18				  -	      IF	LEVEL_SIZE__056_L > MAX_LEVEL_SIZE
      3  3d18				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_L
      4  3d18					      ENDIF
      0  3d18					      DEFL	_056_R, "-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-"
      0  3d18					      START_LEVEL	_056_R
      1  3d18				   LEVEL_START SET	*
      2  3d18		       00 07	   BANK_LEVEL__056_R =	_CURRENT_BANK
      3  3d18				   LEVEL__056_R SUBROUTINE
      4  3d18				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d18
      2  3d18		       2d 34 23 2d*	      .byte.b	"-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-",0
      0  3d73					      END_LEVEL	_056_R
      1  3d73		       00 5b	   LEVEL_SIZE__056_R =	* - LEVEL_START
      2  3d73					      IF	LEVEL_SIZE__056_R > MAX_LEVEL_SIZE
      3  3d73				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_R
      4  3d73					      ENDIF
      0  3d73					      DEFL	_057_L, "5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-"
      0  3d73					      START_LEVEL	_057_L
      1  3d73				   LEVEL_START SET	*
      2  3d73		       00 07	   BANK_LEVEL__057_L =	_CURRENT_BANK
      3  3d73				   LEVEL__057_L SUBROUTINE
      4  3d73				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d73
      2  3d73		       35 2d 36 23*	      .byte.b	"5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-",0
      0  3dc9					      END_LEVEL	_057_L
      1  3dc9		       00 56	   LEVEL_SIZE__057_L =	* - LEVEL_START
      2  3dc9				  -	      IF	LEVEL_SIZE__057_L > MAX_LEVEL_SIZE
      3  3dc9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_L
      4  3dc9					      ENDIF
      0  3dc9					      DEFL	_057_R, "5#4-|#3-3#2-|#+2.2-3#|#.#*$-$-#|#.#.-#$-#|#-$2-$2-#|2#$2#3-#|-#5-2#|-7#-"
      0  3dc9					      START_LEVEL	_057_R
      1  3dc9				   LEVEL_START SET	*
      2  3dc9		       00 07	   BANK_LEVEL__057_R =	_CURRENT_BANK
      3  3dc9				   LEVEL__057_R SUBROUTINE
      4  3dc9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3dc9
      2  3dc9		       35 23 34 2d*	      .byte.b	"5#4-|#3-3#2-|#+2.2-3#|#.#*$-$-#|#.#.-#$-#|#-$2-$2-#|2#$2#3-#|-#5-2#|-7#-",0
      0  3e12					      END_LEVEL	_057_R
      1  3e12		       00 49	   LEVEL_SIZE__057_R =	* - LEVEL_START
      2  3e12				  -	      IF	LEVEL_SIZE__057_R > MAX_LEVEL_SIZE
      3  3e12				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_R
      4  3e12					      ENDIF
      0  3e12					      DEFL	_058_L, "-6#4-|-#-3.5#|-#-#.*2#2-#|2#-.*$4-#|#-2$*-$-$-#|#@2-2#4-#|7#3-#|6-5#"
      0  3e12					      START_LEVEL	_058_L
      1  3e12				   LEVEL_START SET	*
      2  3e12		       00 07	   BANK_LEVEL__058_L =	_CURRENT_BANK
      3  3e12				   LEVEL__058_L SUBROUTINE
      4  3e12				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3e12
      2  3e12		       2d 36 23 34*	      .byte.b	"-6#4-|-#-3.5#|-#-#.*2#2-#|2#-.*$4-#|#-2$*-$-$-#|#@2-2#4-#|7#3-#|6-5#",0
      0  3e57					      END_LEVEL	_058_L
      1  3e57		       00 45	   LEVEL_SIZE__058_L =	* - LEVEL_START
      2  3e57				  -	      IF	LEVEL_SIZE__058_L > MAX_LEVEL_SIZE
      3  3e57				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__058_L
      4  3e57					      ENDIF
      0  3e57					      DEFL	_058_R, "4-5#-|3-2#3-#-|4#-.#$#-|#-$2-.#-#-|#@-3*.-2#|#-$.2-*2-#|3#*$#3-#|2-#4-3#|2-6#2-"
      0  3e57					      START_LEVEL	_058_R
      1  3e57				   LEVEL_START SET	*
      2  3e57		       00 07	   BANK_LEVEL__058_R =	_CURRENT_BANK
      3  3e57				   LEVEL__058_R SUBROUTINE
      4  3e57				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3e57
      2  3e57		       34 2d 35 23*	      .byte.b	"4-5#-|3-2#3-#-|4#-.#$#-|#-$2-.#-#-|#@-3*.-2#|#-$.2-*2-#|3#*$#3-#|2-#4-3#|2-6#2-",0
      0  3ea7					      END_LEVEL	_058_R
      1  3ea7		       00 50	   LEVEL_SIZE__058_R =	* - LEVEL_START
      2  3ea7				  -	      IF	LEVEL_SIZE__058_R > MAX_LEVEL_SIZE
      3  3ea7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__058_R
      4  3ea7					      ENDIF
      0  3ea7					      DEFL	_059_L, "6#5-|#4-#5-|#-$#-5#-|#4-.-$@#-|#-#-2*-#$2#|#-$.*-$3-#|2#$#.-2#2-#|-#-3.2#2-#|-10#"
      0  3ea7					      START_LEVEL	_059_L
      1  3ea7				   LEVEL_START SET	*
      2  3ea7		       00 07	   BANK_LEVEL__059_L =	_CURRENT_BANK
      3  3ea7				   LEVEL__059_L SUBROUTINE
      4  3ea7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ea7
      2  3ea7		       36 23 35 2d*	      .byte.b	"6#5-|#4-#5-|#-$#-5#-|#4-.-$@#-|#-#-2*-#$2#|#-$.*-$3-#|2#$#.-2#2-#|-#-3.2#2-#|-10#",0
      0  3ef9					      END_LEVEL	_059_L
      1  3ef9		       00 52	   LEVEL_SIZE__059_L =	* - LEVEL_START
      2  3ef9				  -	      IF	LEVEL_SIZE__059_L > MAX_LEVEL_SIZE
      3  3ef9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__059_L
      4  3ef9					      ENDIF
      0  3ef9					      DEFL	_059_R, "7-3#-|8#.#-|#4-#-2.2#|#-#-2$*.$-#|#5-2.#-#|2#2-2#-2#-#|#2-$-2$2#-#|#3-2#3-@#|11#"
      0  3ef9					      START_LEVEL	_059_R
      1  3ef9				   LEVEL_START SET	*
      2  3ef9		       00 07	   BANK_LEVEL__059_R =	_CURRENT_BANK
      3  3ef9				   LEVEL__059_R SUBROUTINE
      4  3ef9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ef9
      2  3ef9		       37 2d 33 23*	      .byte.b	"7-3#-|8#.#-|#4-#-2.2#|#-#-2$*.$-#|#5-2.#-#|2#2-2#-2#-#|#2-$-2$2#-#|#3-2#3-@#|11#",0
      0  3f4a					      END_LEVEL	_059_R
      1  3f4a		       00 51	   LEVEL_SIZE__059_R =	* - LEVEL_START
      2  3f4a				  -	      IF	LEVEL_SIZE__059_R > MAX_LEVEL_SIZE
      3  3f4a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__059_R
      4  3f4a					      ENDIF
     66  3f4a
      0  3f4a					      CHECK_BANK_SIZE	"LEVELS4 -- full 2K"
      1  3f4a		       07 4a	   .TEMP      =	* - BANK_START
 LEVELS4 -- full 2K (2K) SIZE =  $74a , FREE= $b6
      2  3f4a					      ECHO	"LEVELS4 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3f4a				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3f4a				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3f4a				  -	      ERR
      6  3f4a					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS5.asm LEVEL 2 PASS 4
      0  3f4a					      include	"BANK_LEVELS5.asm"
      1  3f4a							;    Sokoboo - a Sokoban implementation
      2  3f4a							;    using a generic tile-based display engine for the Atari 2600
      3  3f4a							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  3f4a							;
      5  3f4a							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  3f4a							;
      7  3f4a							;    Code related to the generic tile-based display engine was developed by
      8  3f4a							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  3f4a							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  3f4a							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  3f4a							;
     12  3f4a							;    Code related to music and sound effects uses the TIATracker music player
     13  3f4a							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  3f4a							;    directory for Apache licensing details.
     15  3f4a							;
     16  3f4a							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  3f4a							;    See the copyright notices in the License directory for a list of level
     18  3f4a							;    contributors.
     19  3f4a							;
     20  3f4a							;    Except where otherwise indicated, this software is released under the
     21  3f4a							;    following licensing arrangement...
     22  3f4a							;
     23  3f4a							;    This program is free software: you can redistribute it and/or modify
     24  3f4a							;    it under the terms of the GNU General Public License as published by
     25  3f4a							;    the Free Software Foundation, either version 3 of the License, or
     26  3f4a							;    (at your option) any later version.
     27  3f4a							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  3f4a
     29  3f4a							;    This program is distributed in the hope that it will be useful,
     30  3f4a							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  3f4a							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  3f4a							;    GNU General Public License for more details.
     33  3f4a
     34  3f4a							; level definitions
     35  3f4a							; Sample level definitions.
     36  3f4a							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  3f4a							; have as many banks as you like.
     38  3f4a
      0  3f4a					      NEWBANK	LEVELS5
      1  4675 ????				      SEG	LEVELS5
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   LEVELS5    SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	LEVELS5
     40  4000
      0  4000					      DEFL	_060_R, "3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#"
      0  4000					      START_LEVEL	_060_R
      1  4000				   LEVEL_START SET	*
      2  4000		       00 08	   BANK_LEVEL__060_R =	_CURRENT_BANK
      3  4000				   LEVEL__060_R SUBROUTINE
      4  4000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4000
      2  4000		       33 2d 36 23*	      .byte.b	"3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#",0
      0  4048					      END_LEVEL	_060_R
      1  4048		       00 48	   LEVEL_SIZE__060_R =	* - LEVEL_START
      2  4048				  -	      IF	LEVEL_SIZE__060_R > MAX_LEVEL_SIZE
      3  4048				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__060_R
      4  4048					      ENDIF
      0  4048					      DEFL	_061_L, "10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#"
      0  4048					      START_LEVEL	_061_L
      1  4048				   LEVEL_START SET	*
      2  4048		       00 08	   BANK_LEVEL__061_L =	_CURRENT_BANK
      3  4048				   LEVEL__061_L SUBROUTINE
      4  4048				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4048
      2  4048		       31 30 23 2d*	      .byte.b	"10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#",0
      0  409c					      END_LEVEL	_061_L
      1  409c		       00 54	   LEVEL_SIZE__061_L =	* - LEVEL_START
      2  409c				  -	      IF	LEVEL_SIZE__061_L > MAX_LEVEL_SIZE
      3  409c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_L
      4  409c					      ENDIF
      0  409c					      DEFL	_061_R, "4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#"
      0  409c					      START_LEVEL	_061_R
      1  409c				   LEVEL_START SET	*
      2  409c		       00 08	   BANK_LEVEL__061_R =	_CURRENT_BANK
      3  409c				   LEVEL__061_R SUBROUTINE
      4  409c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  409c
      2  409c		       34 2d 35 23*	      .byte.b	"4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#",0
      0  40e5					      END_LEVEL	_061_R
      1  40e5		       00 49	   LEVEL_SIZE__061_R =	* - LEVEL_START
      2  40e5				  -	      IF	LEVEL_SIZE__061_R > MAX_LEVEL_SIZE
      3  40e5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_R
      4  40e5					      ENDIF
      0  40e5					      DEFL	_062_L, "-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#"
      0  40e5					      START_LEVEL	_062_L
      1  40e5				   LEVEL_START SET	*
      2  40e5		       00 08	   BANK_LEVEL__062_L =	_CURRENT_BANK
      3  40e5				   LEVEL__062_L SUBROUTINE
      4  40e5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  40e5
      2  40e5		       2d 35 23 36*	      .byte.b	"-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#",0
      0  413c					      END_LEVEL	_062_L
      1  413c		       00 57	   LEVEL_SIZE__062_L =	* - LEVEL_START
      2  413c				  -	      IF	LEVEL_SIZE__062_L > MAX_LEVEL_SIZE
      3  413c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_L
      4  413c					      ENDIF
      0  413c					      DEFL	_062_R, "5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-"
      0  413c					      START_LEVEL	_062_R
      1  413c				   LEVEL_START SET	*
      2  413c		       00 08	   BANK_LEVEL__062_R =	_CURRENT_BANK
      3  413c				   LEVEL__062_R SUBROUTINE
      4  413c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  413c
      2  413c		       35 2d 35 23*	      .byte.b	"5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-",0
      0  4188					      END_LEVEL	_062_R
      1  4188		       00 4c	   LEVEL_SIZE__062_R =	* - LEVEL_START
      2  4188				  -	      IF	LEVEL_SIZE__062_R > MAX_LEVEL_SIZE
      3  4188				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_R
      4  4188					      ENDIF
      0  4188					      DEFL	_063_L, "2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#"
      0  4188					      START_LEVEL	_063_L
      1  4188				   LEVEL_START SET	*
      2  4188		       00 08	   BANK_LEVEL__063_L =	_CURRENT_BANK
      3  4188				   LEVEL__063_L SUBROUTINE
      4  4188				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4188
      2  4188		       32 2d 35 23*	      .byte.b	"2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#",0
      0  41d8					      END_LEVEL	_063_L
      1  41d8		       00 50	   LEVEL_SIZE__063_L =	* - LEVEL_START
      2  41d8				  -	      IF	LEVEL_SIZE__063_L > MAX_LEVEL_SIZE
      3  41d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_L
      4  41d8					      ENDIF
      0  41d8					      DEFL	_063_R, "2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-"
      0  41d8					      START_LEVEL	_063_R
      1  41d8				   LEVEL_START SET	*
      2  41d8		       00 08	   BANK_LEVEL__063_R =	_CURRENT_BANK
      3  41d8				   LEVEL__063_R SUBROUTINE
      4  41d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  41d8
      2  41d8		       32 2d 36 23*	      .byte.b	"2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-",0
      0  422a					      END_LEVEL	_063_R
      1  422a		       00 52	   LEVEL_SIZE__063_R =	* - LEVEL_START
      2  422a				  -	      IF	LEVEL_SIZE__063_R > MAX_LEVEL_SIZE
      3  422a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_R
      4  422a					      ENDIF
      0  422a					      DEFL	_064_L, "-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-"
      0  422a					      START_LEVEL	_064_L
      1  422a				   LEVEL_START SET	*
      2  422a		       00 08	   BANK_LEVEL__064_L =	_CURRENT_BANK
      3  422a				   LEVEL__064_L SUBROUTINE
      4  422a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  422a
      2  422a		       2d 38 23 33*	      .byte.b	"-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-",0
      0  4285					      END_LEVEL	_064_L
      1  4285		       00 5b	   LEVEL_SIZE__064_L =	* - LEVEL_START
      2  4285				  -	      IF	LEVEL_SIZE__064_L > MAX_LEVEL_SIZE
      3  4285				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_L
      4  4285					      ENDIF
      0  4285					      DEFL	_064_R, "4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-"
      0  4285					      START_LEVEL	_064_R
      1  4285				   LEVEL_START SET	*
      2  4285		       00 08	   BANK_LEVEL__064_R =	_CURRENT_BANK
      3  4285				   LEVEL__064_R SUBROUTINE
      4  4285				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4285
      2  4285		       34 23 2d 36*	      .byte.b	"4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-",0
      0  42d1					      END_LEVEL	_064_R
      1  42d1		       00 4c	   LEVEL_SIZE__064_R =	* - LEVEL_START
      2  42d1				  -	      IF	LEVEL_SIZE__064_R > MAX_LEVEL_SIZE
      3  42d1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_R
      4  42d1					      ENDIF
      0  42d1					      DEFL	_065_L, "2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-"
      0  42d1					      START_LEVEL	_065_L
      1  42d1				   LEVEL_START SET	*
      2  42d1		       00 08	   BANK_LEVEL__065_L =	_CURRENT_BANK
      3  42d1				   LEVEL__065_L SUBROUTINE
      4  42d1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  42d1
      2  42d1		       32 2d 35 23*	      .byte.b	"2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-",0
      0  4329					      END_LEVEL	_065_L
      1  4329		       00 58	   LEVEL_SIZE__065_L =	* - LEVEL_START
      2  4329				  -	      IF	LEVEL_SIZE__065_L > MAX_LEVEL_SIZE
      3  4329				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_L
      4  4329					      ENDIF
      0  4329					      DEFL	_065_R, "3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#"
      0  4329					      START_LEVEL	_065_R
      1  4329				   LEVEL_START SET	*
      2  4329		       00 08	   BANK_LEVEL__065_R =	_CURRENT_BANK
      3  4329				   LEVEL__065_R SUBROUTINE
      4  4329				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4329
      2  4329		       33 2d 35 23*	      .byte.b	"3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#",0
      0  4371					      END_LEVEL	_065_R
      1  4371		       00 48	   LEVEL_SIZE__065_R =	* - LEVEL_START
      2  4371				  -	      IF	LEVEL_SIZE__065_R > MAX_LEVEL_SIZE
      3  4371				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_R
      4  4371					      ENDIF
      0  4371					      DEFL	_066_L, "10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-"
      0  4371					      START_LEVEL	_066_L
      1  4371				   LEVEL_START SET	*
      2  4371		       00 08	   BANK_LEVEL__066_L =	_CURRENT_BANK
      3  4371				   LEVEL__066_L SUBROUTINE
      4  4371				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4371
      2  4371		       31 30 23 33*	      .byte.b	"10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-",0
      0  43cb					      END_LEVEL	_066_L
      1  43cb		       00 5a	   LEVEL_SIZE__066_L =	* - LEVEL_START
      2  43cb				  -	      IF	LEVEL_SIZE__066_L > MAX_LEVEL_SIZE
      3  43cb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_L
      4  43cb					      ENDIF
      0  43cb					      DEFL	_066_R, "2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#"
      0  43cb					      START_LEVEL	_066_R
      1  43cb				   LEVEL_START SET	*
      2  43cb		       00 08	   BANK_LEVEL__066_R =	_CURRENT_BANK
      3  43cb				   LEVEL__066_R SUBROUTINE
      4  43cb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  43cb
      2  43cb		       32 2d 35 23*	      .byte.b	"2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#",0
      0  4421					      END_LEVEL	_066_R
      1  4421		       00 56	   LEVEL_SIZE__066_R =	* - LEVEL_START
      2  4421				  -	      IF	LEVEL_SIZE__066_R > MAX_LEVEL_SIZE
      3  4421				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_R
      4  4421					      ENDIF
      0  4421					      DEFL	_067_L, "8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#"
      0  4421					      START_LEVEL	_067_L
      1  4421				   LEVEL_START SET	*
      2  4421		       00 08	   BANK_LEVEL__067_L =	_CURRENT_BANK
      3  4421				   LEVEL__067_L SUBROUTINE
      4  4421				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4421
      2  4421		       38 23 33 2d*	      .byte.b	"8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#",0
      0  446e					      END_LEVEL	_067_L
      1  446e		       00 4d	   LEVEL_SIZE__067_L =	* - LEVEL_START
      2  446e				  -	      IF	LEVEL_SIZE__067_L > MAX_LEVEL_SIZE
      3  446e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_L
      4  446e					      ENDIF
      0  446e					      DEFL	_067_R, "7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-"
      0  446e					      START_LEVEL	_067_R
      1  446e				   LEVEL_START SET	*
      2  446e		       00 08	   BANK_LEVEL__067_R =	_CURRENT_BANK
      3  446e				   LEVEL__067_R SUBROUTINE
      4  446e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  446e
      2  446e		       37 23 32 2d*	      .byte.b	"7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-",0
      0  44d3					      END_LEVEL	_067_R
      1  44d3		       00 65	   LEVEL_SIZE__067_R =	* - LEVEL_START
      2  44d3					      IF	LEVEL_SIZE__067_R > MAX_LEVEL_SIZE
      3  44d3				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_R
      4  44d3					      ENDIF
      0  44d3					      DEFL	_068_L, "10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-"
      0  44d3					      START_LEVEL	_068_L
      1  44d3				   LEVEL_START SET	*
      2  44d3		       00 08	   BANK_LEVEL__068_L =	_CURRENT_BANK
      3  44d3				   LEVEL__068_L SUBROUTINE
      4  44d3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  44d3
      2  44d3		       31 30 23 7c*	      .byte.b	"10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-",0
      0  4527					      END_LEVEL	_068_L
      1  4527		       00 54	   LEVEL_SIZE__068_L =	* - LEVEL_START
      2  4527				  -	      IF	LEVEL_SIZE__068_L > MAX_LEVEL_SIZE
      3  4527				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_L
      4  4527					      ENDIF
      0  4527					      DEFL	_068_R, "5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-"
      0  4527					      START_LEVEL	_068_R
      1  4527				   LEVEL_START SET	*
      2  4527		       00 08	   BANK_LEVEL__068_R =	_CURRENT_BANK
      3  4527				   LEVEL__068_R SUBROUTINE
      4  4527				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4527
      2  4527		       35 2d 35 23*	      .byte.b	"5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-",0
      0  457d					      END_LEVEL	_068_R
      1  457d		       00 56	   LEVEL_SIZE__068_R =	* - LEVEL_START
      2  457d				  -	      IF	LEVEL_SIZE__068_R > MAX_LEVEL_SIZE
      3  457d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_R
      4  457d					      ENDIF
      0  457d					      DEFL	_069_L, "-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#"
      0  457d					      START_LEVEL	_069_L
      1  457d				   LEVEL_START SET	*
      2  457d		       00 08	   BANK_LEVEL__069_L =	_CURRENT_BANK
      3  457d				   LEVEL__069_L SUBROUTINE
      4  457d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  457d
      2  457d		       2d 36 23 33*	      .byte.b	"-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#",0
      0  45cb					      END_LEVEL	_069_L
      1  45cb		       00 4e	   LEVEL_SIZE__069_L =	* - LEVEL_START
      2  45cb				  -	      IF	LEVEL_SIZE__069_L > MAX_LEVEL_SIZE
      3  45cb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_L
      4  45cb					      ENDIF
      0  45cb					      DEFL	_069_R, "2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-"
      0  45cb					      START_LEVEL	_069_R
      1  45cb				   LEVEL_START SET	*
      2  45cb		       00 08	   BANK_LEVEL__069_R =	_CURRENT_BANK
      3  45cb				   LEVEL__069_R SUBROUTINE
      4  45cb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  45cb
      2  45cb		       32 2d 35 23*	      .byte.b	"2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-",0
      0  4619					      END_LEVEL	_069_R
      1  4619		       00 4e	   LEVEL_SIZE__069_R =	* - LEVEL_START
      2  4619				  -	      IF	LEVEL_SIZE__069_R > MAX_LEVEL_SIZE
      3  4619				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_R
      4  4619					      ENDIF
     60  4619
      0  4619					      DEFL	_122_Maya, "14#|4#3-3#2-2#|#-$-$2-2#3-2#|#.2-$4#$2-2#|#.*2-$3-$-3#|#*.#$*.$-#2$-#|#6.*-#-@-#|2#4-8#|14#"
      0  4619					      START_LEVEL	_122_Maya
      1  4619				   LEVEL_START SET	*
      2  4619		       00 08	   BANK_LEVEL__122_Maya =	_CURRENT_BANK
      3  4619				   LEVEL__122_Maya SUBROUTINE
      4  4619				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4619
      2  4619		       31 34 23 7c*	      .byte.b	"14#|4#3-3#2-2#|#-$-$2-2#3-2#|#.2-$4#$2-2#|#.*2-$3-$-3#|#*.#$*.$-#2$-#|#6.*-#-@-#|2#4-8#|14#",0
      0  4675					      END_LEVEL	_122_Maya
      1  4675		       00 5c	   LEVEL_SIZE__122_Maya =	* - LEVEL_START
      2  4675				  -	      IF	LEVEL_SIZE__122_Maya > MAX_LEVEL_SIZE
      3  4675				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__122_Maya
      4  4675					      ENDIF
     62  4675
      0  4675					      CHECK_BANK_SIZE	"LEVELS5 -- full 2K"
      1  4675		       06 75	   .TEMP      =	* - BANK_START
 LEVELS5 -- full 2K (2K) SIZE =  $675 , FREE= $18b
      2  4675					      ECHO	"LEVELS5 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4675				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4675				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4675				  -	      ERR
      6  4675					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS6.asm LEVEL 2 PASS 4
      0  4675					      include	"BANK_LEVELS6.asm"
      1  4675							;    Sokoboo - a Sokoban implementation
      2  4675							;    using a generic tile-based display engine for the Atari 2600
      3  4675							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  4675							;
      5  4675							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  4675							;
      7  4675							;    Code related to the generic tile-based display engine was developed by
      8  4675							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  4675							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  4675							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  4675							;
     12  4675							;    Code related to music and sound effects uses the TIATracker music player
     13  4675							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  4675							;    directory for Apache licensing details.
     15  4675							;
     16  4675							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  4675							;    See the copyright notices in the License directory for a list of level
     18  4675							;    contributors.
     19  4675							;
     20  4675							;    Except where otherwise indicated, this software is released under the
     21  4675							;    following licensing arrangement...
     22  4675							;
     23  4675							;    This program is free software: you can redistribute it and/or modify
     24  4675							;    it under the terms of the GNU General Public License as published by
     25  4675							;    the Free Software Foundation, either version 3 of the License, or
     26  4675							;    (at your option) any later version.
     27  4675							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  4675
     29  4675							;    This program is distributed in the hope that it will be useful,
     30  4675							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  4675							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  4675							;    GNU General Public License for more details.
     33  4675
     34  4675							; level definitions
     35  4675							; Sample level definitions.
     36  4675							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  4675							; have as many banks as you like.
     38  4675
      0  4675					      NEWBANK	LEVELS6
      1  4d9f ????				      SEG	LEVELS6
      2  4800					      ORG	ORIGIN
      3  4800					      RORG	$F000
      4  4800				   BANK_START SET	*
      5  4800				   LEVELS6    SET	ORIGIN / 2048
      6  4800				   ORIGIN     SET	ORIGIN + 2048
      7  4800				   _CURRENT_BANK SET	LEVELS6
     40  4800
     41  4800
     42  4800							; Level definitions
     43  4800
     44  4800							; "sokhard" collection
     45  4800
      0  4800					      START_LEVEL	_102_Natalie
      1  4800				   LEVEL_START SET	*
      2  4800		       00 09	   BANK_LEVEL__102_Natalie =	_CURRENT_BANK
      3  4800				   LEVEL__102_Natalie SUBROUTINE
      4  4800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4800
     47  4800		       31 31 23 7c*	      .byte.b	"11#|2#2-#@4.#|2#3-2$.2*#|2#-$2-2$#.#|#2-$#-#2-.#|#2-$-#-2#-#|#9-#|11#",0
      0  4846					      END_LEVEL	_102_Natalie
      1  4846		       00 46	   LEVEL_SIZE__102_Natalie =	* - LEVEL_START
      2  4846				  -	      IF	LEVEL_SIZE__102_Natalie > MAX_LEVEL_SIZE
      3  4846				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Natalie
      4  4846					      ENDIF
     49  4846
      0  4846					      START_LEVEL	_102_Mirabel
      1  4846				   LEVEL_START SET	*
      2  4846		       00 09	   BANK_LEVEL__102_Mirabel =	_CURRENT_BANK
      3  4846				   LEVEL__102_Mirabel SUBROUTINE
      4  4846				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4846
     51  4846		       31 31 23 7c*	      .byte.b	"11#|6#3-2#|2#2-2#$2-2#|2#2-#-2$-2#|#7-3#|#.-#$-#-3#|#.#.-#2-$-#|#3.#-2$#@#|#-2.4-$-#|#2-8#|11#",0
      0  48a5					      END_LEVEL	_102_Mirabel
      1  48a5		       00 5f	   LEVEL_SIZE__102_Mirabel =	* - LEVEL_START
      2  48a5				  -	      IF	LEVEL_SIZE__102_Mirabel > MAX_LEVEL_SIZE
      3  48a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Mirabel
      4  48a5					      ENDIF
     53  48a5
      0  48a5					      START_LEVEL	_102_Oralia
      1  48a5				   LEVEL_START SET	*
      2  48a5		       00 09	   BANK_LEVEL__102_Oralia =	_CURRENT_BANK
      3  48a5				   LEVEL__102_Oralia SUBROUTINE
      4  48a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  48a5
     55  48a5		       39 23 7c 23*	      .byte.b	"9#|#2.$.#2-#|#4.2*-#|#-$.2#2-#|2#-$2-$-#|4#$-$-#|#-$3-$-#|#5-#@#|9#",0
      0  48e9					      END_LEVEL	_102_Oralia
      1  48e9		       00 44	   LEVEL_SIZE__102_Oralia =	* - LEVEL_START
      2  48e9				  -	      IF	LEVEL_SIZE__102_Oralia > MAX_LEVEL_SIZE
      3  48e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Oralia
      4  48e9					      ENDIF
     57  48e9
     58  48e9
     59  48e9							;---------------------------------------------------------------------------------------------------
     60  48e9							; IMAGE IS ABOVE DEFINITION
     61  48e9
     62  48e9							;  ###########
     63  48e9							;  #  #      #
     64  48e9							;  # $# $ $$ #
     65  48e9							;  #  ##$#$  #
     66  48e9							;  #  $    #@#
     67  48e9							;  # $## #  ##
     68  48e9							;  ##	# .## #
     69  48e9							;  ##$ #.*. ##
     70  48e9							;  # ..*. *. #
     71  48e9							;  # # .. #  #
     72  48e9							;  ###########
     73  48e9
      0  48e9					      START_LEVEL	_102_Raven
      1  48e9				   LEVEL_START SET	*
      2  48e9		       00 09	   BANK_LEVEL__102_Raven =	_CURRENT_BANK
      3  48e9				   LEVEL__102_Raven SUBROUTINE
      4  48e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  48e9
     75  48e9		       31 31 23 7c*	      .byte.b	"11#|#2-#6-#|#-$#-$-2$-#|#2-2#$#$2-#|#2-$4-#@#|#-$2#-#2-2#|2#2-#-.2#-#|2#$-#.*.-2#|#-2.*.-*.-#|#-#-2.-#2-#|11#",0
      0  4957					      END_LEVEL	_102_Raven
      1  4957		       00 6e	   LEVEL_SIZE__102_Raven =	* - LEVEL_START
      2  4957					      IF	LEVEL_SIZE__102_Raven > MAX_LEVEL_SIZE
      3  4957				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Raven
      4  4957					      ENDIF
     77  4957
     78  4957							;  ############
     79  4957							;  #@##. #  # #
     80  4957							;  #**..$#    #
     81  4957							;  #. $..#  # #
     82  4957							;  # $#.$#$$$ #
     83  4957							;  #	      ##
     84  4957							;  #  ##  #   #
     85  4957							;  ############
     86  4957
      0  4957					      START_LEVEL	_103_Adin
      1  4957				   LEVEL_START SET	*
      2  4957		       00 09	   BANK_LEVEL__103_Adin =	_CURRENT_BANK
      3  4957				   LEVEL__103_Adin SUBROUTINE
      4  4957				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4957
     88  4957		       31 32 23 7c*	      .byte.b	"12#|#@2#.-#2-#-#|#2*2.$#4-#|#.-$2.#2-#-#|#-$#.$#3$-#|#9-2#|#2-2#2-#3-#|12#",0
      0  49a2					      END_LEVEL	_103_Adin
      1  49a2		       00 4b	   LEVEL_SIZE__103_Adin =	* - LEVEL_START
      2  49a2				  -	      IF	LEVEL_SIZE__103_Adin > MAX_LEVEL_SIZE
      3  49a2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Adin
      4  49a2					      ENDIF
     90  49a2
     91  49a2							;  #######___
     92  49a2							;  #	  #___
     93  49a2							;  #	$$#___
     94  49a2							;  #.*  .#___
     95  49a2							;  #$*$#*###_
     96  49a2							;  #@*... .#_
     97  49a2							;  #####$ .##
     98  49a2							;  ___# $ $ #
     99  49a2							;  ___#     #
    100  49a2							;  ___#######	(_ = modified by boo from wall)
    101  49a2
      0  49a2					      START_LEVEL	_103_Ajalae
      1  49a2				   LEVEL_START SET	*
      2  49a2		       00 09	   BANK_LEVEL__103_Ajalae =	_CURRENT_BANK
      3  49a2				   LEVEL__103_Ajalae SUBROUTINE
      4  49a2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  49a2
    103  49a2		       37 23 7c 23*	      .byte.b	"7#|#5-#|#3-2$#|#.*2-.#|#$*$#*3#|#@*3.-.#|5#$-.2#|3-#-$-$-#|3-#5-#|3-7#",0
      0  49e9					      END_LEVEL	_103_Ajalae
      1  49e9		       00 47	   LEVEL_SIZE__103_Ajalae =	* - LEVEL_START
      2  49e9				  -	      IF	LEVEL_SIZE__103_Ajalae > MAX_LEVEL_SIZE
      3  49e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Ajalae
      4  49e9					      ENDIF
    105  49e9
    106  49e9							;  ############
    107  49e9							;  #@#  #     #
    108  49e9							;  #  # #$#$# #
    109  49e9							;  # *$       #
    110  49e9							;  #..##$#$   #
    111  49e9							;  #..#. #  $ #
    112  49e9							;  #....# $$$##
    113  49e9							;  #	       #
    114  49e9							;  ############
    115  49e9
      0  49e9					      START_LEVEL	_103_Arielle
      1  49e9				   LEVEL_START SET	*
      2  49e9		       00 09	   BANK_LEVEL__103_Arielle =	_CURRENT_BANK
      3  49e9				   LEVEL__103_Arielle SUBROUTINE
      4  49e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  49e9
    117  49e9		       31 32 23 7c*	      .byte.b	"12#|#@#2-#5-#|#2-#-#$#$#-#|#-*$7-#|#2.2#$#$3-#|#2.#.-#2-$-#|#4.#-3$2#|#10-#|12#",0
      0  4a39					      END_LEVEL	_103_Arielle
      1  4a39		       00 50	   LEVEL_SIZE__103_Arielle =	* - LEVEL_START
      2  4a39				  -	      IF	LEVEL_SIZE__103_Arielle > MAX_LEVEL_SIZE
      3  4a39				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Arielle
      4  4a39					      ENDIF
    119  4a39
    120  4a39
    121  4a39
      0  4a39					      START_LEVEL	_1XJH_Tara_Gelson
      1  4a39				   LEVEL_START SET	*
      2  4a39		       00 09	   BANK_LEVEL__1XJH_Tara_Gelson =	_CURRENT_BANK
      3  4a39				   LEVEL__1XJH_Tara_Gelson SUBROUTINE
      4  4a39				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4a39
    123  4a39		       38 23 7c 23*	      .byte.b	"8#|#2-#2-*#|#2-*-*-#|#-*$-$-#|#2-.#.-#|#3-#-*#|2#-@3-#|8#",0
      0  4a73					      END_LEVEL	_1XJH_Tara_Gelson
      1  4a73		       00 3a	   LEVEL_SIZE__1XJH_Tara_Gelson =	* - LEVEL_START
      2  4a73				  -	      IF	LEVEL_SIZE__1XJH_Tara_Gelson > MAX_LEVEL_SIZE
      3  4a73				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1XJH_Tara_Gelson
      4  4a73					      ENDIF
    125  4a73
      0  4a73					      START_LEVEL	_1R7X_Alison
      1  4a73				   LEVEL_START SET	*
      2  4a73		       00 09	   BANK_LEVEL__1R7X_Alison =	_CURRENT_BANK
      3  4a73				   LEVEL__1R7X_Alison SUBROUTINE
      4  4a73				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4a73
    127  4a73		       37 23 7c 23*	      .byte.b	"7#|#2-.2-#|#-$*2$#|#-2.$.#|#@*-$-#|2#.3-#|7#",0
      0  4aa0					      END_LEVEL	_1R7X_Alison
      1  4aa0		       00 2d	   LEVEL_SIZE__1R7X_Alison =	* - LEVEL_START
      2  4aa0				  -	      IF	LEVEL_SIZE__1R7X_Alison > MAX_LEVEL_SIZE
      3  4aa0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1R7X_Alison
      4  4aa0					      ENDIF
    129  4aa0
      0  4aa0					      START_LEVEL	_1KWD_Cecile_Clayworth
      1  4aa0				   LEVEL_START SET	*
      2  4aa0		       00 09	   BANK_LEVEL__1KWD_Cecile_Clayworth =	_CURRENT_BANK
      3  4aa0				   LEVEL__1KWD_Cecile_Clayworth SUBROUTINE
      4  4aa0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4aa0
    131  4aa0		       38 23 7c 33*	      .byte.b	"8#|3#.2-.#|#-$4-#|#-*2#2$#|#3-$-+#|#-*.-*-#|#6-#|8#",0
      0  4ad4					      END_LEVEL	_1KWD_Cecile_Clayworth
      1  4ad4		       00 34	   LEVEL_SIZE__1KWD_Cecile_Clayworth =	* - LEVEL_START
      2  4ad4				  -	      IF	LEVEL_SIZE__1KWD_Cecile_Clayworth > MAX_LEVEL_SIZE
      3  4ad4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1KWD_Cecile_Clayworth
      4  4ad4					      ENDIF
    133  4ad4
      0  4ad4					      START_LEVEL	_1EKT_Samantha_Gelson
      1  4ad4				   LEVEL_START SET	*
      2  4ad4		       00 09	   BANK_LEVEL__1EKT_Samantha_Gelson =	_CURRENT_BANK
      3  4ad4				   LEVEL__1EKT_Samantha_Gelson SUBROUTINE
      4  4ad4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4ad4
    135  4ad4		       38 23 7c 23*	      .byte.b	"8#|#-*3-.#|#2-$-*-#|#-.$-$-#|#*-*2-*#|#.#-#2-#|#4-@-#|8#",0
      0  4b0d					      END_LEVEL	_1EKT_Samantha_Gelson
      1  4b0d		       00 39	   LEVEL_SIZE__1EKT_Samantha_Gelson =	* - LEVEL_START
      2  4b0d				  -	      IF	LEVEL_SIZE__1EKT_Samantha_Gelson > MAX_LEVEL_SIZE
      3  4b0d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1EKT_Samantha_Gelson
      4  4b0d					      ENDIF
    137  4b0d
      0  4b0d					      START_LEVEL	_0VM5_Andrea_Wadd
      1  4b0d				   LEVEL_START SET	*
      2  4b0d		       00 09	   BANK_LEVEL__0VM5_Andrea_Wadd =	_CURRENT_BANK
      3  4b0d				   LEVEL__0VM5_Andrea_Wadd SUBROUTINE
      4  4b0d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b0d
    139  4b0d		       37 23 7c 23*	      .byte.b	"7#|#3-#-#|#-$*2-#|#-.-+-#|#-*2$-#|2#2-.-#|7#",0
      0  4b3a					      END_LEVEL	_0VM5_Andrea_Wadd
      1  4b3a		       00 2d	   LEVEL_SIZE__0VM5_Andrea_Wadd =	* - LEVEL_START
      2  4b3a				  -	      IF	LEVEL_SIZE__0VM5_Andrea_Wadd > MAX_LEVEL_SIZE
      3  4b3a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0VM5_Andrea_Wadd
      4  4b3a					      ENDIF
    141  4b3a
      0  4b3a					      START_LEVEL	_0PAL_Jill_Leatherby
      1  4b3a				   LEVEL_START SET	*
      2  4b3a		       00 09	   BANK_LEVEL__0PAL_Jill_Leatherby =	_CURRENT_BANK
      3  4b3a				   LEVEL__0PAL_Jill_Leatherby SUBROUTINE
      4  4b3a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b3a
    143  4b3a		       37 23 7c 23*	      .byte.b	"7#|#3-3#|#2-2*-#|#3-$-#|#2-$2.#|3#@2-#|7#",0
      0  4b64					      END_LEVEL	_0PAL_Jill_Leatherby
      1  4b64		       00 2a	   LEVEL_SIZE__0PAL_Jill_Leatherby =	* - LEVEL_START
      2  4b64				  -	      IF	LEVEL_SIZE__0PAL_Jill_Leatherby > MAX_LEVEL_SIZE
      3  4b64				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0PAL_Jill_Leatherby
      4  4b64					      ENDIF
    145  4b64
      0  4b64					      START_LEVEL	_0IZ1_Sophia
      1  4b64				   LEVEL_START SET	*
      2  4b64		       00 09	   BANK_LEVEL__0IZ1_Sophia =	_CURRENT_BANK
      3  4b64				   LEVEL__0IZ1_Sophia SUBROUTINE
      4  4b64				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b64
    147  4b64		       37 23 7c 23*	      .byte.b	"7#|#5-#|#@$.#-#|#*$2-.#|#-2$2-#|#-.-.-#|7#",0
      0  4b8f					      END_LEVEL	_0IZ1_Sophia
      1  4b8f		       00 2b	   LEVEL_SIZE__0IZ1_Sophia =	* - LEVEL_START
      2  4b8f				  -	      IF	LEVEL_SIZE__0IZ1_Sophia > MAX_LEVEL_SIZE
      3  4b8f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0IZ1_Sophia
      4  4b8f					      ENDIF
    149  4b8f
      0  4b8f					      START_LEVEL	_0CNH_Alice
      1  4b8f				   LEVEL_START SET	*
      2  4b8f		       00 09	   BANK_LEVEL__0CNH_Alice =	_CURRENT_BANK
      3  4b8f				   LEVEL__0CNH_Alice SUBROUTINE
      4  4b8f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b8f
    151  4b8f		       37 23 7c 23*	      .byte.b	"7#|#.4-#|#$*-#-#|#.2-$*#|#-.$2-#|#@-*2-#|7#",0
      0  4bbb					      END_LEVEL	_0CNH_Alice
      1  4bbb		       00 2c	   LEVEL_SIZE__0CNH_Alice =	* - LEVEL_START
      2  4bbb				  -	      IF	LEVEL_SIZE__0CNH_Alice > MAX_LEVEL_SIZE
      3  4bbb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0CNH_Alice
      4  4bbb					      ENDIF
    153  4bbb
    154  4bbb							;  START_LEVEL TowC
    155  4bbb							;   .byte "4-5#|4-#3-#|4-#$2-#|2-3#2-$2#|2-#2-$-$-#|3#-#-2#-#3-6#|#3-#-2#-5#2-2.#|#-$2-$10-2.#|5#-3#-#@2#2-2.#|4-#5-9#|4-7#",0
    156  4bbb							;  END_LEVEL TowC
    157  4bbb
    158  4bbb							;  START_LEVEL SimpleC
    159  4bbb							;  .byte "7#|#.@-#-#|#$*-$-#|#3-$-#|#-..--#|#--*--#|7#",0
    160  4bbb							;  END_LEVEL SimpleC
    161  4bbb
      0  4bbb					      START_LEVEL	bAlfa_DrFogh
      1  4bbb				   LEVEL_START SET	*
      2  4bbb		       00 09	   BANK_LEVEL_bAlfa_DrFogh =	_CURRENT_BANK
      3  4bbb				   LEVEL_bAlfa_DrFogh SUBROUTINE
      4  4bbb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4bbb
    163  4bbb		       32 2d 34 23*	      .byte.b	"2-4#2-4#|-2#2-2#-#2-#|-#4-3#2-2#|2#2-2*2-#.2-2#|#2-*2-*-#*#2-#|#-*4-2*2-#-#|#-*-2#-*3-#-#|2#-*2-*#*#-#-#|-#$-2*-#-*-#-#|-#@#2-2#5-#|-2#2-4#2-3#|2-#2-#2-4#|2-#2-#|2-4#",0
      0  4c62					      END_LEVEL	bAlfa_DrFogh
      1  4c62		       00 a7	   LEVEL_SIZE_bAlfa_DrFogh =	* - LEVEL_START
      2  4c62					      IF	LEVEL_SIZE_bAlfa_DrFogh > MAX_LEVEL_SIZE
      3  4c62				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAlfa_DrFogh
      4  4c62					      ENDIF
    165  4c62
      0  4c62					      START_LEVEL	b51X_Sharpen
      1  4c62				   LEVEL_START SET	*
      2  4c62		       00 09	   BANK_LEVEL_b51X_Sharpen =	_CURRENT_BANK
      3  4c62				   LEVEL_b51X_Sharpen SUBROUTINE
      4  4c62				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4c62
    167  4c62		       2d 39 23 33*	      .byte.b	"-9#3-|-#7-#3-|-#-$-2$-$#3-|3#$#2-$-#3-|#.#3-2$-2#2-|#.3#3-$-#2-|#.#.-$-2#-3#|#3.$-$2#-$-#|#3.$3-$2-@#|#2.3#$3#-2#|#4.#5-#-|12#-",0
      0  4ce2					      END_LEVEL	b51X_Sharpen
      1  4ce2		       00 80	   LEVEL_SIZE_b51X_Sharpen =	* - LEVEL_START
      2  4ce2				  -	      IF	LEVEL_SIZE_b51X_Sharpen > MAX_LEVEL_SIZE
      3  4ce2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_b51X_Sharpen
      4  4ce2					      ENDIF
    169  4ce2
      0  4ce2					      START_LEVEL	bDarcy_Burnsell101
      1  4ce2				   LEVEL_START SET	*
      2  4ce2		       00 09	   BANK_LEVEL_bDarcy_Burnsell101 =	_CURRENT_BANK
      3  4ce2				   LEVEL_bDarcy_Burnsell101 SUBROUTINE
      4  4ce2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4ce2
    171  4ce2		       38 23 7c 23*	      .byte.b	"8#|#2-.-$@#|#.#$*2$#|#2-.-*-#|#2$-2$.#|#.#-#2-#|#.2-.-.#|8#",0
      0  4d1e					      END_LEVEL	bDarcy_Burnsell101
      1  4d1e		       00 3c	   LEVEL_SIZE_bDarcy_Burnsell101 =	* - LEVEL_START
      2  4d1e				  -	      IF	LEVEL_SIZE_bDarcy_Burnsell101 > MAX_LEVEL_SIZE
      3  4d1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bDarcy_Burnsell101
      4  4d1e					      ENDIF
    173  4d1e
      0  4d1e					      START_LEVEL	bAislin101
      1  4d1e				   LEVEL_START SET	*
      2  4d1e		       00 09	   BANK_LEVEL_bAislin101 =	_CURRENT_BANK
      3  4d1e				   LEVEL_bAislin101 SUBROUTINE
      4  4d1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4d1e
    175  4d1e		       38 23 7c 32*	      .byte.b	"8#|2#-*-*.#|#2.$-$*#|#-.#-*.#|2#-$-$2#|#-#$-$-#|#2.2-$@#|8#",0
      0  4d5a					      END_LEVEL	bAislin101
      1  4d5a		       00 3c	   LEVEL_SIZE_bAislin101 =	* - LEVEL_START
      2  4d5a				  -	      IF	LEVEL_SIZE_bAislin101 > MAX_LEVEL_SIZE
      3  4d5a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAislin101
      4  4d5a					      ENDIF
    177  4d5a
    178  4d5a							;  START_LEVEL b82X_Sharpen
    179  4d5a							;  .byte "-11#8-|-#5-#3-2#7-|-#-$-$-$-#2-5#3-|-3#2-5#5-#3-|-#4.#5-3#-#3-|-#.4#2-4#3-#3-|-#4.4-#2-$-2#3-|-#-3.#3-#-3$5#|3#.7#2-$@$3-#|#-$3-5#-$-2#3-#|#-#.#-$6-$3#$-#|#-#.8#2-#2-$-#|#-#3.7-2#-2$-#|#3-7#-$-#-#2-#|5#5-#7-2#|10-9#-",0
    180  4d5a							;  END_LEVEL b82X_Sharpen
    181  4d5a
      0  4d5a					      START_LEVEL	Thomas_Reinke16
      1  4d5a				   LEVEL_START SET	*
      2  4d5a		       00 09	   BANK_LEVEL_Thomas_Reinke16 =	_CURRENT_BANK
      3  4d5a				   LEVEL_Thomas_Reinke16 SUBROUTINE
      4  4d5a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4d5a
    183  4d5a		       2d 35 23 7c*	      .byte.b	"-5#|2#3-3#|#6-2#|#-#-2#2-#|#2.*2-#-#|#2-*2-#-#|3#*2$2-#|2-#@-4#|2-4#",0
      0  4d9f					      END_LEVEL	Thomas_Reinke16
      1  4d9f		       00 45	   LEVEL_SIZE_Thomas_Reinke16 =	* - LEVEL_START
      2  4d9f				  -	      IF	LEVEL_SIZE_Thomas_Reinke16 > MAX_LEVEL_SIZE
      3  4d9f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_Thomas_Reinke16
      4  4d9f					      ENDIF
    185  4d9f
    186  4d9f							;Level element	Character	ASCII Code
    187  4d9f							;Wall	#	0x23
    188  4d9f							;Player	@	0x40
    189  4d9f							;Player on goal square	+	0x2b
    190  4d9f							;Box	$	0x24
    191  4d9f							;Box on goal square	*	0x2a
    192  4d9f							;Goal square	.	0x2e
    193  4d9f							;Floor	(Space)	0x20 or underscore
    194  4d9f
    195  4d9f							;This level ("Claire", by Lee J Haywood):
    196  4d9f
    197  4d9f							;#######
    198  4d9f							;#.@ # #
    199  4d9f							;#$* $ #
    200  4d9f							;#   $ #
    201  4d9f							;# ..	#
    202  4d9f							;#  *	#
    203  4d9f							;#######
    204  4d9f							;runlength encoded looks like this:
    205  4d9f
    206  4d9f							;The rows of the level are separated by "|"s. There has been a discussion in the Yahoo Group about what character should represent an empty square in May 2006. Finally the hyphen has been elected to be the standard character for an empty square. Nevertheless, programs are encouraged to support both, hyphens and underscores.
    207  4d9f
    208  4d9f							;If only two level elements are grouped together they may be run length encoded, but needn't to. Example:
    209  4d9f
    210  4d9f
      0  4d9f					      CHECK_BANK_SIZE	"LEVELS6 -- full 2K"
      1  4d9f		       05 9f	   .TEMP      =	* - BANK_START
 LEVELS6 -- full 2K (2K) SIZE =  $59f , FREE= $261
      2  4d9f					      ECHO	"LEVELS6 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4d9f				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4d9f				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4d9f				  -	      ERR
      6  4d9f					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_PlayerFrames.asm LEVEL 2 PASS 4
      0  4d9f					      include	"BANK_PlayerFrames.asm"
      1  4d9f							;    Sokoboo - a Sokoban implementation
      2  4d9f							;    using a generic tile-based display engine for the Atari 2600
      3  4d9f							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  4d9f							;
      5  4d9f							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  4d9f							;
      7  4d9f							;    Code related to the generic tile-based display engine was developed by
      8  4d9f							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  4d9f							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  4d9f							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  4d9f							;
     12  4d9f							;    Code related to music and sound effects uses the TIATracker music player
     13  4d9f							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  4d9f							;    directory for Apache licensing details.
     15  4d9f							;
     16  4d9f							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  4d9f							;    See the copyright notices in the License directory for a list of level
     18  4d9f							;    contributors.
     19  4d9f							;
     20  4d9f							;    Except where otherwise indicated, this software is released under the
     21  4d9f							;    following licensing arrangement...
     22  4d9f							;
     23  4d9f							;    This program is free software: you can redistribute it and/or modify
     24  4d9f							;    it under the terms of the GNU General Public License as published by
     25  4d9f							;    the Free Software Foundation, either version 3 of the License, or
     26  4d9f							;    (at your option) any later version.
     27  4d9f							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  4d9f
     29  4d9f							;    This program is distributed in the hope that it will be useful,
     30  4d9f							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  4d9f							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  4d9f							;    GNU General Public License for more details.
     33  4d9f
      0  4d9f					      NEWBANK	PLAYER_FRAMES
      1  54ba ????				      SEG	PLAYER_FRAMES
      2  5000					      ORG	ORIGIN
      3  5000					      RORG	$F000
      4  5000				   BANK_START SET	*
      5  5000				   PLAYER_FRAMES SET	ORIGIN / 2048
      6  5000				   ORIGIN     SET	ORIGIN + 2048
      7  5000				   _CURRENT_BANK SET	PLAYER_FRAMES
     35  5000
     36  5000							;CL0	  = $0
     37  5000							;CL1	  = $4C   ;yellow
     38  5000							;CL2	  = $68
     39  5000							;CL3	  = $0C   ; cuffs/trim
     40  5000							;CL4	  = $B8   ; jumper
     41  5000							;CL5	  = $b2
     42  5000							;CL6	  = $66
     43  5000
     44  5000		       00 00	   CL0	      =	$0
     45  5000		       00 01	   CL1	      =	1	;$2C	;yellow
     46  5000		       00 02	   CL2	      =	2	;$24
     47  5000		       00 03	   CL3	      =	3	;$6A	; cuffs/trim
     48  5000		       00 04	   CL4	      =	4	;$44
     49  5000		       00 05	   CL5	      =	5	;$B6	; pants
     50  5000		       00 06	   CL6	      =	6	;$64
     51  5000
     52  5000
     53  5000
------- FILE spriteBank.asm LEVEL 3 PASS 4
      0  5000					      include	"spriteBank.asm"
      1  5000		       00 80	   ANIMATION_WALK_ID =	128+0
      2  5000		       00 82	   ANIMATION_IDLE_ID =	128+2
      3  5000		       00 84	   ANIMATION_WIN_ID =	128+4
      4  5000		       00 86	   ANIMATION_PUSH_ID =	128+6
      5  5000		       00 88	   ANIMATION_PUSHTRY_ID =	128+8
      6  5000		       00 8a	   ANIMATION_PUSHUP_ID =	128+10
      7  5000
      8  5000		       00 03	   FRAME_IDLE1 =	3
      9  5000		       00 04	   FRAME_IDLE2 =	4
     10  5000		       00 05	   FRAME_IDLE3 =	5
     11  5000		       00 00	   FRAME_WALK1 =	0
     12  5000		       00 01	   FRAME_WALK2 =	1
     13  5000		       00 02	   FRAME_WALK3 =	2
     14  5000		       00 06	   FRAME_PUSH1 =	6
     15  5000		       00 07	   FRAME_PUSH2 =	7
     16  5000		       00 08	   FRAME_PUSH3 =	8
     17  5000		       00 09	   FRAME_PUSHUP1 =	9
     18  5000		       00 0a	   FRAME_PUSHUP2 =	10
     19  5000		       00 0b	   FRAME_PUSHUP3 =	11
     20  5000		       00 0c	   FRAME_LOOK1 =	12
     21  5000		       00 0d	   FRAME_LOOK2 =	13
     22  5000		       00 0e	   FRAME_LOOK3 =	14
     23  5000		       00 0f	   FRAME_HANDLIP =	15
     24  5000		       00 10	   FRAME_TAPFOOT =	16
     25  5000		       00 11	   FRAME_LOOKUP =	17
     26  5000		       00 12	   FRAME_BLINK =	18
     27  5000
     28  5000
     29  5000
     30  5000				   ANIM_TABLE
     31  5000		       0a f0		      .word.w	Animation_Walk
     32  5002		       20 f0		      .word.w	Animation_IDLE
     33  5004		       13 f0		      .word.w	Animation_WIN
     34  5006		       6c f0		      .word.w	Animation_Push
     35  5008		       67 f0		      .word.w	Animation_PushTry
     36  500a
     37  500a
     38  500a				   Animation_Walk
     39  500a		       00 08		      .byte.b	FRAME_WALK1,8
     40  500c		       01 08		      .byte.b	FRAME_WALK2,8
     41  500e		       02 08		      .byte.b	FRAME_WALK3,8
     42  5010		       01 08		      .byte.b	FRAME_WALK2,8
     43  5012		       80		      .byte.b	ANIMATION_WALK_ID
     44  5013
     45  5013				   Animation_WIN
     46  5013		       01 1e		      .byte.b	FRAME_WALK2,30
     47  5015		       03 0a		      .byte.b	FRAME_IDLE1,10
     48  5017		       04 0a		      .byte.b	FRAME_IDLE2,10
     49  5019							;    .byte FRAME_IDLE3,10
     50  5019		       03 0a		      .byte.b	FRAME_IDLE1,10
     51  501b		       04 0a		      .byte.b	FRAME_IDLE2,10
     52  501d		       05 0a		      .byte.b	FRAME_IDLE3,10
     53  501f		       82		      .byte.b	ANIMATION_IDLE_ID
     54  5020
     55  5020				   Animation_IDLE
     56  5020
     57  5020					      REPEAT	2
     58  5020		       01 64		      .byte.b	FRAME_WALK2,100
     59  5022		       12 02		      .byte.b	FRAME_BLINK,2
     57  5022					      REPEND
     58  5024		       01 64		      .byte.b	FRAME_WALK2,100
     59  5026		       12 02		      .byte.b	FRAME_BLINK,2
     60  5028					      REPEND
     61  5028
     62  5028					      REPEAT	3
     63  5028		       10 0a		      .byte.b	FRAME_TAPFOOT,10
     64  502a		       01 05		      .byte.b	FRAME_WALK2,5
     62  502a					      REPEND
     63  502c		       10 0a		      .byte.b	FRAME_TAPFOOT,10
     64  502e		       01 05		      .byte.b	FRAME_WALK2,5
     62  502e					      REPEND
     63  5030		       10 0a		      .byte.b	FRAME_TAPFOOT,10
     64  5032		       01 05		      .byte.b	FRAME_WALK2,5
     65  5034					      REPEND
     66  5034
     67  5034		       0e 03		      .byte.b	FRAME_LOOK3,3
     68  5036		       0d 1e		      .byte.b	FRAME_LOOK2,30
     69  5038		       0e 03		      .byte.b	FRAME_LOOK3,3
     70  503a
     71  503a					      REPEAT	2
     72  503a		       01 64		      .byte.b	FRAME_WALK2,100
     73  503c		       12 02		      .byte.b	FRAME_BLINK,2
     71  503c					      REPEND
     72  503e		       01 64		      .byte.b	FRAME_WALK2,100
     73  5040		       12 02		      .byte.b	FRAME_BLINK,2
     74  5042					      REPEND
     75  5042		       11 28		      .byte.b	FRAME_LOOKUP,40
     76  5044		       01 14		      .byte.b	FRAME_WALK2,20
     77  5046
     78  5046					      REPEAT	1
     79  5046		       0e 02		      .byte.b	FRAME_LOOK3, 2
     80  5048		       0d 03		      .byte.b	FRAME_LOOK2, 3
     81  504a		       0c 14		      .byte.b	FRAME_LOOK1, 20
     82  504c		       0d 03		      .byte.b	FRAME_LOOK2, 3
     83  504e		       0e 02		      .byte.b	FRAME_LOOK3, 2
     84  5050		       01 14		      .byte.b	FRAME_WALK2, 20
     85  5052					      REPEND
     86  5052
     87  5052					      REPEAT	2
     88  5052		       01 64		      .byte.b	FRAME_WALK2,100
     89  5054		       12 02		      .byte.b	FRAME_BLINK,2
     87  5054					      REPEND
     88  5056		       01 64		      .byte.b	FRAME_WALK2,100
     89  5058		       12 02		      .byte.b	FRAME_BLINK,2
     90  505a					      REPEND
     91  505a
     92  505a		       0f 28		      .byte.b	FRAME_HANDLIP,40
     93  505c		       01 32		      .byte.b	FRAME_WALK2,50
     94  505e
     95  505e				   Animation_Yawn
     96  505e
     97  505e		       03 0a		      .byte.b	FRAME_IDLE1,10
     98  5060		       04 0a		      .byte.b	FRAME_IDLE2,10
     99  5062		       05 3c		      .byte.b	FRAME_IDLE3,60
    100  5064		       04 1e		      .byte.b	FRAME_IDLE2,30
    101  5066		       82		      .byte.b	ANIMATION_IDLE_ID
    102  5067
    103  5067
    104  5067
    105  5067
    106  5067				   Animation_PushTry
    107  5067		       06 1e		      .byte.b	FRAME_PUSH1,30
    108  5069		       06 1e		      .byte.b	FRAME_PUSH1,30
    109  506b		       82		      .byte.b	ANIMATION_IDLE_ID
    110  506c
    111  506c				   Animation_Push
    112  506c		       06 14		      .byte.b	FRAME_PUSH1,20
    113  506e		       07 14		      .byte.b	FRAME_PUSH2,20
    114  5070		       08 14		      .byte.b	FRAME_PUSH3,20
    115  5072		       07 14		      .byte.b	FRAME_PUSH2,20
    116  5074		       86		      .byte.b	ANIMATION_PUSH_ID
    117  5075
    118  5075				   Animation_PushUP
    119  5075		       09 0a		      .byte.b	FRAME_PUSHUP1, 10
    120  5077		       0a 0a		      .byte.b	FRAME_PUSHUP2,10
    121  5079		       0b 0a		      .byte.b	FRAME_PUSHUP3,10
    122  507b		       0a 0a		      .byte.b	FRAME_PUSHUP2,10
    123  507d		       8a		      .byte.b	ANIMATION_PUSHUP_ID
    124  507e
    125  507e				   FRAME_PTR_LO
    126  507e		       5a		      .byte.b	<FRAME_walk_right_3_png	;0
    127  507f		       ba		      .byte.b	<FRAME_walk_right_2_png	;1
    128  5080		       4a		      .byte.b	<FRAME_walk_right_1_png	;2
    129  5081		       5a		      .byte.b	<FRAME_idle_right_1_png	;3
    130  5082		       6a		      .byte.b	<FRAME_idle_right_2_png	;4
    131  5083		       ca		      .byte.b	<FRAME_idle_right_3_png	;5
    132  5084		       2a		      .byte.b	<FRAME_push_right_1_png	;6
    133  5085		       3a		      .byte.b	<FRAME_push_right_2_png	;7
    134  5086		       fa		      .byte.b	<FRAME_push_right_3_png	;8
    135  5087		       8a		      .byte.b	<FRAME_push_up_1_png	;9
    136  5088		       1a		      .byte.b	<FRAME_push_up_2_png	;10
    137  5089		       ea		      .byte.b	<FRAME_push_up_3_png	;11
    138  508a		       0a		      .byte.b	<FRAME_walk_right_2_look_left_png	;12
    139  508b		       aa		      .byte.b	<FRAME_walk_right_2_look_left2_png	;13
    140  508c		       da		      .byte.b	<FRAME_walk_right_2_look_left3_png	;14
    141  508d		       fa		      .byte.b	<FRAME_handlip_png	;15
    142  508e		       8a		      .byte.b	<FRAME_tapfoot_png	;16
    143  508f		       2a		      .byte.b	<FRAME_lookup_png	;17
    144  5090		       7a		      .byte.b	<FRAME_blink_png	;18
    145  5091
    146  5091				   FRAME_PTR_HI
    147  5091		       f1		      .byte.b	>FRAME_walk_right_3_png
    148  5092		       f1		      .byte.b	>FRAME_walk_right_2_png
    149  5093		       f2		      .byte.b	>FRAME_walk_right_1_png
    150  5094		       f4		      .byte.b	>FRAME_idle_right_1_png
    151  5095		       f3		      .byte.b	>FRAME_idle_right_2_png
    152  5096		       f3		      .byte.b	>FRAME_idle_right_3_png
    153  5097		       f4		      .byte.b	>FRAME_push_right_1_png
    154  5098		       f3		      .byte.b	>FRAME_push_right_2_png
    155  5099		       f3		      .byte.b	>FRAME_push_right_3_png
    156  509a		       f1		      .byte.b	>FRAME_push_up_1_png
    157  509b		       f2		      .byte.b	>FRAME_push_up_2_png
    158  509c		       f1		      .byte.b	>FRAME_push_up_3_png
    159  509d		       f3		      .byte.b	>FRAME_walk_right_2_look_left_png	;1
    160  509e		       f2		      .byte.b	>FRAME_walk_right_2_look_left2_png	;1
    161  509f		       f2		      .byte.b	>FRAME_walk_right_2_look_left3_png	;1
    162  50a0		       f0		      .byte.b	>FRAME_handlip_png	;12
    163  50a1		       f4		      .byte.b	>FRAME_tapfoot_png
    164  50a2		       f1		      .byte.b	>FRAME_lookup_png
    165  50a3		       f2		      .byte.b	>FRAME_blink_png	;17
    166  50a4
    167  50a4				   COLOUR_PTR_LO
    168  50a4		       72		      .byte.b	<COLOUR_walk_right_3	;0
    169  50a5		       d2		      .byte.b	<COLOUR_walk_right_2	;1
    170  50a6		       62		      .byte.b	<COLOUR_walk_right_1	;2
    171  50a7		       72		      .byte.b	<COLOUR_idle_right_1	;3
    172  50a8		       82		      .byte.b	<COLOUR_idle_right_2	;4
    173  50a9		       e2		      .byte.b	<COLOUR_idle_right_3	;5
    174  50aa		       42		      .byte.b	<COLOUR_push_right_1	;6
    175  50ab		       52		      .byte.b	<COLOUR_push_right_2	;7
    176  50ac		       12		      .byte.b	<COLOUR_push_right_3	;8
    177  50ad		       a2		      .byte.b	<COLOUR_push_up_1	;6
    178  50ae		       32		      .byte.b	<COLOUR_push_up_2	;7
    179  50af		       02		      .byte.b	<COLOUR_push_up_3	;8
    180  50b0		       22		      .byte.b	<COLOUR_walk_right_2_look_left	;1
    181  50b1		       c2		      .byte.b	<COLOUR_walk_right_2_look_left2	;1
    182  50b2		       f2		      .byte.b	<COLOUR_walk_right_2_look_left3	;1
    183  50b3		       12		      .byte.b	<COLOUR_handlip
    184  50b4		       a2		      .byte.b	<COLOUR_tapfoot
    185  50b5		       42		      .byte.b	<COLOUR_lookup
    186  50b6		       92		      .byte.b	<COLOUR_blink
    187  50b7
    188  50b7				   COLOUR_PTR_HI
    189  50b7		       f1		      .byte.b	>COLOUR_walk_right_3
    190  50b8		       f1		      .byte.b	>COLOUR_walk_right_2
    191  50b9		       f2		      .byte.b	>COLOUR_walk_right_1
    192  50ba		       f4		      .byte.b	>COLOUR_idle_right_1
    193  50bb		       f3		      .byte.b	>COLOUR_idle_right_2
    194  50bc		       f3		      .byte.b	>COLOUR_idle_right_3
    195  50bd		       f4		      .byte.b	>COLOUR_push_right_1
    196  50be		       f3		      .byte.b	>COLOUR_push_right_2
    197  50bf		       f4		      .byte.b	>COLOUR_push_right_3
    198  50c0		       f1		      .byte.b	>COLOUR_push_up_1	;6
    199  50c1		       f2		      .byte.b	>COLOUR_push_up_2	;7
    200  50c2		       f2		      .byte.b	>COLOUR_push_up_3	;8
    201  50c3		       f3		      .byte.b	>COLOUR_walk_right_2_look_left	;1
    202  50c4		       f2		      .byte.b	>COLOUR_walk_right_2_look_left2	;1
    203  50c5		       f2		      .byte.b	>COLOUR_walk_right_2_look_left3	;1
    204  50c6		       f1		      .byte.b	>COLOUR_handlip
    205  50c7		       f4		      .byte.b	>COLOUR_tapfoot
    206  50c8		       f1		      .byte.b	>COLOUR_lookup
    207  50c9		       f2		      .byte.b	>COLOUR_blink
    208  50ca
------- FILE spriteData.asm LEVEL 4 PASS 4
      0  50ca					      include	"spriteData.asm"
      1  50ca		       34	   FRAME_crouch1_png .byte.b	52	; 23
      2  50cb		       3c		      .byte.b	60	; 20
      3  50cc		       7e		      .byte.b	126	; 17
      4  50cd		       7c		      .byte.b	124	; 14
      5  50ce		       18		      .byte.b	24	; 11
      6  50cf		       0c		      .byte.b	12	; 8
      7  50d0		       1f		      .byte.b	31	; 5
      8  50d1		       00		      .byte.b	0	; 2
      9  50d2		       36		      .byte.b	54	; 22
     10  50d3		       30		      .byte.b	48	; 19
     11  50d4		       bc		      .byte.b	188	; 16
     12  50d5		       38		      .byte.b	56	; 13
     13  50d6		       1c		      .byte.b	28	; 10
     14  50d7		       0a		      .byte.b	10	; 7
     15  50d8		       0c		      .byte.b	12	; 4
     16  50d9		       00		      .byte.b	0	; 1
     17  50da		       16		      .byte.b	22	; 21
     18  50db		       39		      .byte.b	57	; 18
     19  50dc		       fc		      .byte.b	252	; 15
     20  50dd		       18		      .byte.b	24	; 12
     21  50de		       18		      .byte.b	24	; 9
     22  50df		       04		      .byte.b	4	; 6
     23  50e0		       00		      .byte.b	0	; 3
     24  50e1		       00		      .byte.b	0	; 0
     25  50e2		       06	   COLOUR_crouch1 .byte.b	CL6	; 23
     26  50e3		       05		      .byte.b	CL5	; 20
     27  50e4		       04		      .byte.b	CL4	; 17
     28  50e5		       04		      .byte.b	CL4	; 14
     29  50e6		       02		      .byte.b	CL2	; 11
     30  50e7		       02		      .byte.b	CL2	; 8
     31  50e8		       01		      .byte.b	CL1	; 5
     32  50e9		       00		      .byte.b	CL0	; 2
     33  50ea		       05		      .byte.b	CL5	; 22
     34  50eb		       02		      .byte.b	CL2	; 19
     35  50ec		       04		      .byte.b	CL4	; 16
     36  50ed		       04		      .byte.b	CL4	; 13
     37  50ee		       02		      .byte.b	CL2	; 10
     38  50ef		       02		      .byte.b	CL2	; 7
     39  50f0		       01		      .byte.b	CL1	; 4
     40  50f1		       00		      .byte.b	CL0	; 1
     41  50f2		       05		      .byte.b	CL5	; 21
     42  50f3		       03		      .byte.b	CL3	; 18
     43  50f4		       04		      .byte.b	CL4	; 15
     44  50f5		       03		      .byte.b	CL3	; 12
     45  50f6		       02		      .byte.b	CL2	; 9
     46  50f7		       02		      .byte.b	CL2	; 6
     47  50f8		       00		      .byte.b	CL0	; 3
     48  50f9		       00		      .byte.b	CL0	; 0
     49  50fa		       34	   FRAME_handlip_png .byte.b	52	; 23
     50  50fb		       28		      .byte.b	40	; 20
     51  50fc		       38		      .byte.b	56	; 17
     52  50fd		       38		      .byte.b	56	; 14
     53  50fe		       5e		      .byte.b	94	; 11
     54  50ff		       1a		      .byte.b	26	; 8
     55  5100		       18		      .byte.b	24	; 5
     56  5101		       04		      .byte.b	4	; 2
     57  5102		       00		      .byte.b	0	; 22
     58  5103		       28		      .byte.b	40	; 19
     59  5104		       18		      .byte.b	24	; 16
     60  5105		       68		      .byte.b	104	; 13
     61  5106		       7e		      .byte.b	126	; 10
     62  5107		       1a		      .byte.b	26	; 7
     63  5108		       0c		      .byte.b	12	; 4
     64  5109		       1e		      .byte.b	30	; 1
     65  510a		       28		      .byte.b	40	; 21
     66  510b		       28		      .byte.b	40	; 18
     67  510c		       30		      .byte.b	48	; 15
     68  510d		       5c		      .byte.b	92	; 12
     69  510e		       3a		      .byte.b	58	; 9
     70  510f		       1e		      .byte.b	30	; 6
     71  5110		       0a		      .byte.b	10	; 3
     72  5111		       1d		      .byte.b	29	; 0
     73  5112		       06	   COLOUR_handlip .byte.b	CL6	; 23
     74  5113		       05		      .byte.b	CL5	; 20
     75  5114		       05		      .byte.b	CL5	; 17
     76  5115		       03		      .byte.b	CL3	; 14
     77  5116		       04		      .byte.b	CL4	; 11
     78  5117		       03		      .byte.b	CL3	; 8
     79  5118		       02		      .byte.b	CL2	; 5
     80  5119		       02		      .byte.b	CL2	; 2
     81  511a		       00		      .byte.b	CL0	; 22
     82  511b		       05		      .byte.b	CL5	; 19
     83  511c		       05		      .byte.b	CL5	; 16
     84  511d		       04		      .byte.b	CL4	; 13
     85  511e		       04		      .byte.b	CL4	; 10
     86  511f		       02		      .byte.b	CL2	; 7
     87  5120		       02		      .byte.b	CL2	; 4
     88  5121		       01		      .byte.b	CL1	; 1
     89  5122		       05		      .byte.b	CL5	; 21
     90  5123		       05		      .byte.b	CL5	; 18
     91  5124		       02		      .byte.b	CL2	; 15
     92  5125		       04		      .byte.b	CL4	; 12
     93  5126		       04		      .byte.b	CL4	; 9
     94  5127		       02		      .byte.b	CL2	; 6
     95  5128		       02		      .byte.b	CL2	; 3
     96  5129		       01		      .byte.b	CL1	; 0
     97  512a		       34	   FRAME_lookup_png .byte.b	52	; 23
     98  512b		       28		      .byte.b	40	; 20
     99  512c		       18		      .byte.b	24	; 17
    100  512d		       b8		      .byte.b	184	; 14
    101  512e		       7c		      .byte.b	124	; 11
    102  512f		       30		      .byte.b	48	; 8
    103  5130		       70		      .byte.b	112	; 5
    104  5131		       c0		      .byte.b	192	; 2
    105  5132		       00		      .byte.b	0	; 22
    106  5133		       28		      .byte.b	40	; 19
    107  5134		       b0		      .byte.b	176	; 16
    108  5135		       b8		      .byte.b	184	; 13
    109  5136		       74		      .byte.b	116	; 10
    110  5137		       30		      .byte.b	48	; 7
    111  5138		       58		      .byte.b	88	; 4
    112  5139		       70		      .byte.b	112	; 1
    113  513a		       28		      .byte.b	40	; 21
    114  513b		       28		      .byte.b	40	; 18
    115  513c		       b8		      .byte.b	184	; 15
    116  513d		       f8		      .byte.b	248	; 12
    117  513e		       34		      .byte.b	52	; 9
    118  513f		       60		      .byte.b	96	; 6
    119  5140		       b0		      .byte.b	176	; 3
    120  5141		       00		      .byte.b	0	; 0
    121  5142		       06	   COLOUR_lookup .byte.b	CL6	; 23
    122  5143		       05		      .byte.b	CL5	; 20
    123  5144		       05		      .byte.b	CL5	; 17
    124  5145		       04		      .byte.b	CL4	; 14
    125  5146		       04		      .byte.b	CL4	; 11
    126  5147		       02		      .byte.b	CL2	; 8
    127  5148		       02		      .byte.b	CL2	; 5
    128  5149		       01		      .byte.b	CL1	; 2
    129  514a		       00		      .byte.b	CL0	; 22
    130  514b		       05		      .byte.b	CL5	; 19
    131  514c		       02		      .byte.b	CL2	; 16
    132  514d		       04		      .byte.b	CL4	; 13
    133  514e		       04		      .byte.b	CL4	; 10
    134  514f		       02		      .byte.b	CL2	; 7
    135  5150		       02		      .byte.b	CL2	; 4
    136  5151		       01		      .byte.b	CL1	; 1
    137  5152		       05		      .byte.b	CL5	; 21
    138  5153		       05		      .byte.b	CL5	; 18
    139  5154		       03		      .byte.b	CL3	; 15
    140  5155		       04		      .byte.b	CL4	; 12
    141  5156		       03		      .byte.b	CL3	; 9
    142  5157		       02		      .byte.b	CL2	; 6
    143  5158		       02		      .byte.b	CL2	; 3
    144  5159		       00		      .byte.b	CL0	; 0
    145  515a		       44	   FRAME_walk_right_3_png .byte.b	68	; 23
    146  515b		       74		      .byte.b	116	; 20
    147  515c		       28		      .byte.b	40	; 17
    148  515d		       ba		      .byte.b	186	; 14
    149  515e		       7c		      .byte.b	124	; 11
    150  515f		       18		      .byte.b	24	; 8
    151  5160		       0c		      .byte.b	12	; 5
    152  5161		       1e		      .byte.b	30	; 2
    153  5162		       82		      .byte.b	130	; 22
    154  5163		       34		      .byte.b	52	; 19
    155  5164		       b2		      .byte.b	178	; 16
    156  5165		       bc		      .byte.b	188	; 13
    157  5166		       38		      .byte.b	56	; 10
    158  5167		       1c		      .byte.b	28	; 7
    159  5168		       0a		      .byte.b	10	; 4
    160  5169		       1d		      .byte.b	29	; 1
    161  516a		       64		      .byte.b	100	; 21
    162  516b		       38		      .byte.b	56	; 18
    163  516c		       ba		      .byte.b	186	; 15
    164  516d		       fc		      .byte.b	252	; 12
    165  516e		       18		      .byte.b	24	; 9
    166  516f		       18		      .byte.b	24	; 6
    167  5170		       04		      .byte.b	4	; 3
    168  5171		       00		      .byte.b	0	; 0
    169  5172		       06	   COLOUR_walk_right_3 .byte.b	CL6	; 23
    170  5173		       05		      .byte.b	CL5	; 20
    171  5174		       05		      .byte.b	CL5	; 17
    172  5175		       04		      .byte.b	CL4	; 14
    173  5176		       04		      .byte.b	CL4	; 11
    174  5177		       02		      .byte.b	CL2	; 8
    175  5178		       02		      .byte.b	CL2	; 5
    176  5179		       01		      .byte.b	CL1	; 2
    177  517a		       06		      .byte.b	CL6	; 22
    178  517b		       05		      .byte.b	CL5	; 19
    179  517c		       02		      .byte.b	CL2	; 16
    180  517d		       04		      .byte.b	CL4	; 13
    181  517e		       04		      .byte.b	CL4	; 10
    182  517f		       02		      .byte.b	CL2	; 7
    183  5180		       02		      .byte.b	CL2	; 4
    184  5181		       01		      .byte.b	CL1	; 1
    185  5182		       05		      .byte.b	CL5	; 21
    186  5183		       05		      .byte.b	CL5	; 18
    187  5184		       03		      .byte.b	CL3	; 15
    188  5185		       04		      .byte.b	CL4	; 12
    189  5186		       03		      .byte.b	CL3	; 9
    190  5187		       02		      .byte.b	CL2	; 6
    191  5188		       02		      .byte.b	CL2	; 3
    192  5189		       00		      .byte.b	CL0	; 0
    193  518a		       00	   FRAME_push_up_1_png .byte.b	0	; 23
    194  518b		       20		      .byte.b	32	; 20
    195  518c		       20		      .byte.b	32	; 17
    196  518d		       20		      .byte.b	32	; 14
    197  518e		       38		      .byte.b	56	; 11
    198  518f		       38		      .byte.b	56	; 8
    199  5190		       ee		      .byte.b	238	; 5
    200  5191		       38		      .byte.b	56	; 2
    201  5192		       00		      .byte.b	0	; 22
    202  5193		       20		      .byte.b	32	; 19
    203  5194		       28		      .byte.b	40	; 16
    204  5195		       38		      .byte.b	56	; 13
    205  5196		       38		      .byte.b	56	; 10
    206  5197		       38		      .byte.b	56	; 7
    207  5198		       82		      .byte.b	130	; 4
    208  5199		       38		      .byte.b	56	; 1
    209  519a		       00		      .byte.b	0	; 21
    210  519b		       08		      .byte.b	8	; 18
    211  519c		       08		      .byte.b	8	; 15
    212  519d		       10		      .byte.b	16	; 12
    213  519e		       38		      .byte.b	56	; 9
    214  519f		       7c		      .byte.b	124	; 6
    215  51a0		       aa		      .byte.b	170	; 3
    216  51a1		       00		      .byte.b	0	; 0
    217  51a2		       00	   COLOUR_push_up_1 .byte.b	CL0	; 23
    218  51a3		       06		      .byte.b	CL6	; 20
    219  51a4		       05		      .byte.b	CL5	; 17
    220  51a5		       05		      .byte.b	CL5	; 14
    221  51a6		       06		      .byte.b	CL6	; 11
    222  51a7		       04		      .byte.b	CL4	; 8
    223  51a8		       04		      .byte.b	CL4	; 5
    224  51a9		       01		      .byte.b	CL1	; 2
    225  51aa		       00		      .byte.b	CL0	; 22
    226  51ab		       06		      .byte.b	CL6	; 19
    227  51ac		       05		      .byte.b	CL5	; 16
    228  51ad		       05		      .byte.b	CL5	; 13
    229  51ae		       03		      .byte.b	CL3	; 10
    230  51af		       04		      .byte.b	CL4	; 7
    231  51b0		       03		      .byte.b	CL3	; 4
    232  51b1		       01		      .byte.b	CL1	; 1
    233  51b2		       00		      .byte.b	CL0	; 21
    234  51b3		       06		      .byte.b	CL6	; 18
    235  51b4		       05		      .byte.b	CL5	; 15
    236  51b5		       05		      .byte.b	CL5	; 12
    237  51b6		       04		      .byte.b	CL4	; 9
    238  51b7		       04		      .byte.b	CL4	; 6
    239  51b8		       02		      .byte.b	CL2	; 3
    240  51b9		       00		      .byte.b	CL0	; 0
    241  51ba		       34	   FRAME_walk_right_2_png .byte.b	52	; 23
    242  51bb		       28		      .byte.b	40	; 20
    243  51bc		       38		      .byte.b	56	; 17
    244  51bd		       ba		      .byte.b	186	; 14
    245  51be		       fc		      .byte.b	252	; 11
    246  51bf		       18		      .byte.b	24	; 8
    247  51c0		       18		      .byte.b	24	; 5
    248  51c1		       04		      .byte.b	4	; 2
    249  51c2		       00		      .byte.b	0	; 22
    250  51c3		       28		      .byte.b	40	; 19
    251  51c4		       18		      .byte.b	24	; 16
    252  51c5		       ba		      .byte.b	186	; 13
    253  51c6		       7c		      .byte.b	124	; 10
    254  51c7		       18		      .byte.b	24	; 7
    255  51c8		       0c		      .byte.b	12	; 4
    256  51c9		       1e		      .byte.b	30	; 1
    257  51ca		       28		      .byte.b	40	; 21
    258  51cb		       28		      .byte.b	40	; 18
    259  51cc		       b2		      .byte.b	178	; 15
    260  51cd		       bc		      .byte.b	188	; 12
    261  51ce		       38		      .byte.b	56	; 9
    262  51cf		       1c		      .byte.b	28	; 6
    263  51d0		       0a		      .byte.b	10	; 3
    264  51d1		       1d		      .byte.b	29	; 0
    265  51d2		       06	   COLOUR_walk_right_2 .byte.b	CL6	; 23
    266  51d3		       05		      .byte.b	CL5	; 20
    267  51d4		       05		      .byte.b	CL5	; 17
    268  51d5		       03		      .byte.b	CL3	; 14
    269  51d6		       04		      .byte.b	CL4	; 11
    270  51d7		       03		      .byte.b	CL3	; 8
    271  51d8		       02		      .byte.b	CL2	; 5
    272  51d9		       02		      .byte.b	CL2	; 2
    273  51da		       00		      .byte.b	CL0	; 22
    274  51db		       05		      .byte.b	CL5	; 19
    275  51dc		       05		      .byte.b	CL5	; 16
    276  51dd		       04		      .byte.b	CL4	; 13
    277  51de		       04		      .byte.b	CL4	; 10
    278  51df		       02		      .byte.b	CL2	; 7
    279  51e0		       02		      .byte.b	CL2	; 4
    280  51e1		       01		      .byte.b	CL1	; 1
    281  51e2		       05		      .byte.b	CL5	; 21
    282  51e3		       05		      .byte.b	CL5	; 18
    283  51e4		       02		      .byte.b	CL2	; 15
    284  51e5		       04		      .byte.b	CL4	; 12
    285  51e6		       04		      .byte.b	CL4	; 9
    286  51e7		       02		      .byte.b	CL2	; 6
    287  51e8		       02		      .byte.b	CL2	; 3
    288  51e9		       01		      .byte.b	CL1	; 0
    289  51ea		       00	   FRAME_push_up_3_png .byte.b	0	; 23
    290  51eb		       08		      .byte.b	8	; 20
    291  51ec		       08		      .byte.b	8	; 17
    292  51ed		       08		      .byte.b	8	; 14
    293  51ee		       38		      .byte.b	56	; 11
    294  51ef		       38		      .byte.b	56	; 8
    295  51f0		       ee		      .byte.b	238	; 5
    296  51f1		       38		      .byte.b	56	; 2
    297  51f2		       00		      .byte.b	0	; 22
    298  51f3		       08		      .byte.b	8	; 19
    299  51f4		       28		      .byte.b	40	; 16
    300  51f5		       38		      .byte.b	56	; 13
    301  51f6		       38		      .byte.b	56	; 10
    302  51f7		       38		      .byte.b	56	; 7
    303  51f8		       82		      .byte.b	130	; 4
    304  51f9		       38		      .byte.b	56	; 1
    305  51fa		       00		      .byte.b	0	; 21
    306  51fb		       20		      .byte.b	32	; 18
    307  51fc		       20		      .byte.b	32	; 15
    308  51fd		       10		      .byte.b	16	; 12
    309  51fe		       38		      .byte.b	56	; 9
    310  51ff		       7c		      .byte.b	124	; 6
    311  5200		       aa		      .byte.b	170	; 3
    312  5201		       00		      .byte.b	0	; 0
    313  5202		       00	   COLOUR_push_up_3 .byte.b	CL0	; 23
    314  5203		       06		      .byte.b	CL6	; 20
    315  5204		       05		      .byte.b	CL5	; 17
    316  5205		       05		      .byte.b	CL5	; 14
    317  5206		       01		      .byte.b	CL1	; 11
    318  5207		       04		      .byte.b	CL4	; 8
    319  5208		       04		      .byte.b	CL4	; 5
    320  5209		       01		      .byte.b	CL1	; 2
    321  520a		       00		      .byte.b	CL0	; 22
    322  520b		       06		      .byte.b	CL6	; 19
    323  520c		       05		      .byte.b	CL5	; 16
    324  520d		       05		      .byte.b	CL5	; 13
    325  520e		       03		      .byte.b	CL3	; 10
    326  520f		       04		      .byte.b	CL4	; 7
    327  5210		       03		      .byte.b	CL3	; 4
    328  5211		       01		      .byte.b	CL1	; 1
    329  5212		       00		      .byte.b	CL0	; 21
    330  5213		       06		      .byte.b	CL6	; 18
    331  5214		       05		      .byte.b	CL5	; 15
    332  5215		       05		      .byte.b	CL5	; 12
    333  5216		       04		      .byte.b	CL4	; 9
    334  5217		       04		      .byte.b	CL4	; 6
    335  5218		       02		      .byte.b	CL2	; 3
    336  5219		       00		      .byte.b	CL0	; 0
    337  521a		       00	   FRAME_push_up_2_png .byte.b	0	; 23
    338  521b		       00		      .byte.b	0	; 20
    339  521c		       28		      .byte.b	40	; 17
    340  521d		       28		      .byte.b	40	; 14
    341  521e		       38		      .byte.b	56	; 11
    342  521f		       38		      .byte.b	56	; 8
    343  5220		       ee		      .byte.b	238	; 5
    344  5221		       38		      .byte.b	56	; 2
    345  5222		       00		      .byte.b	0	; 22
    346  5223		       28		      .byte.b	40	; 19
    347  5224		       28		      .byte.b	40	; 16
    348  5225		       38		      .byte.b	56	; 13
    349  5226		       38		      .byte.b	56	; 10
    350  5227		       38		      .byte.b	56	; 7
    351  5228		       82		      .byte.b	130	; 4
    352  5229		       38		      .byte.b	56	; 1
    353  522a		       00		      .byte.b	0	; 21
    354  522b		       00		      .byte.b	0	; 18
    355  522c		       00		      .byte.b	0	; 15
    356  522d		       10		      .byte.b	16	; 12
    357  522e		       38		      .byte.b	56	; 9
    358  522f		       7c		      .byte.b	124	; 6
    359  5230		       aa		      .byte.b	170	; 3
    360  5231		       00		      .byte.b	0	; 0
    361  5232		       00	   COLOUR_push_up_2 .byte.b	CL0	; 23
    362  5233		       00		      .byte.b	CL0	; 20
    363  5234		       05		      .byte.b	CL5	; 17
    364  5235		       05		      .byte.b	CL5	; 14
    365  5236		       06		      .byte.b	CL6	; 11
    366  5237		       04		      .byte.b	CL4	; 8
    367  5238		       04		      .byte.b	CL4	; 5
    368  5239		       01		      .byte.b	CL1	; 2
    369  523a		       00		      .byte.b	CL0	; 22
    370  523b		       06		      .byte.b	CL6	; 19
    371  523c		       05		      .byte.b	CL5	; 16
    372  523d		       05		      .byte.b	CL5	; 13
    373  523e		       03		      .byte.b	CL3	; 10
    374  523f		       04		      .byte.b	CL4	; 7
    375  5240		       03		      .byte.b	CL3	; 4
    376  5241		       01		      .byte.b	CL1	; 1
    377  5242		       00		      .byte.b	CL0	; 21
    378  5243		       00		      .byte.b	CL0	; 18
    379  5244		       00		      .byte.b	CL0	; 15
    380  5245		       05		      .byte.b	CL5	; 12
    381  5246		       04		      .byte.b	CL4	; 9
    382  5247		       04		      .byte.b	CL4	; 6
    383  5248		       02		      .byte.b	CL2	; 3
    384  5249		       00		      .byte.b	CL0	; 0
    385  524a		       44	   FRAME_walk_right_1_png .byte.b	68	; 23
    386  524b		       4c		      .byte.b	76	; 20
    387  524c		       28		      .byte.b	40	; 17
    388  524d		       ba		      .byte.b	186	; 14
    389  524e		       7c		      .byte.b	124	; 11
    390  524f		       18		      .byte.b	24	; 8
    391  5250		       0c		      .byte.b	12	; 5
    392  5251		       1e		      .byte.b	30	; 2
    393  5252		       82		      .byte.b	130	; 22
    394  5253		       1c		      .byte.b	28	; 19
    395  5254		       b2		      .byte.b	178	; 16
    396  5255		       bc		      .byte.b	188	; 13
    397  5256		       38		      .byte.b	56	; 10
    398  5257		       1c		      .byte.b	28	; 7
    399  5258		       0a		      .byte.b	10	; 4
    400  5259		       1d		      .byte.b	29	; 1
    401  525a		       6c		      .byte.b	108	; 21
    402  525b		       38		      .byte.b	56	; 18
    403  525c		       ba		      .byte.b	186	; 15
    404  525d		       fc		      .byte.b	252	; 12
    405  525e		       18		      .byte.b	24	; 9
    406  525f		       18		      .byte.b	24	; 6
    407  5260		       04		      .byte.b	4	; 3
    408  5261		       00		      .byte.b	0	; 0
    409  5262		       06	   COLOUR_walk_right_1 .byte.b	CL6	; 23
    410  5263		       05		      .byte.b	CL5	; 20
    411  5264		       05		      .byte.b	CL5	; 17
    412  5265		       04		      .byte.b	CL4	; 14
    413  5266		       04		      .byte.b	CL4	; 11
    414  5267		       02		      .byte.b	CL2	; 8
    415  5268		       02		      .byte.b	CL2	; 5
    416  5269		       01		      .byte.b	CL1	; 2
    417  526a		       06		      .byte.b	CL6	; 22
    418  526b		       05		      .byte.b	CL5	; 19
    419  526c		       02		      .byte.b	CL2	; 16
    420  526d		       04		      .byte.b	CL4	; 13
    421  526e		       04		      .byte.b	CL4	; 10
    422  526f		       02		      .byte.b	CL2	; 7
    423  5270		       02		      .byte.b	CL2	; 4
    424  5271		       01		      .byte.b	CL1	; 1
    425  5272		       05		      .byte.b	CL5	; 21
    426  5273		       05		      .byte.b	CL5	; 18
    427  5274		       03		      .byte.b	CL3	; 15
    428  5275		       04		      .byte.b	CL4	; 12
    429  5276		       03		      .byte.b	CL3	; 9
    430  5277		       02		      .byte.b	CL2	; 6
    431  5278		       02		      .byte.b	CL2	; 3
    432  5279		       00		      .byte.b	CL0	; 0
    433  527a		       34	   FRAME_blink_png .byte.b	52	; 23
    434  527b		       28		      .byte.b	40	; 20
    435  527c		       38		      .byte.b	56	; 17
    436  527d		       ba		      .byte.b	186	; 14
    437  527e		       fc		      .byte.b	252	; 11
    438  527f		       18		      .byte.b	24	; 8
    439  5280		       18		      .byte.b	24	; 5
    440  5281		       04		      .byte.b	4	; 2
    441  5282		       00		      .byte.b	0	; 22
    442  5283		       28		      .byte.b	40	; 19
    443  5284		       18		      .byte.b	24	; 16
    444  5285		       ba		      .byte.b	186	; 13
    445  5286		       7c		      .byte.b	124	; 10
    446  5287		       18		      .byte.b	24	; 7
    447  5288		       0c		      .byte.b	12	; 4
    448  5289		       1e		      .byte.b	30	; 1
    449  528a		       28		      .byte.b	40	; 21
    450  528b		       28		      .byte.b	40	; 18
    451  528c		       b2		      .byte.b	178	; 15
    452  528d		       bc		      .byte.b	188	; 12
    453  528e		       38		      .byte.b	56	; 9
    454  528f		       1c		      .byte.b	28	; 6
    455  5290		       0e		      .byte.b	14	; 3
    456  5291		       1d		      .byte.b	29	; 0
    457  5292		       06	   COLOUR_blink .byte.b	CL6	; 23
    458  5293		       05		      .byte.b	CL5	; 20
    459  5294		       05		      .byte.b	CL5	; 17
    460  5295		       03		      .byte.b	CL3	; 14
    461  5296		       04		      .byte.b	CL4	; 11
    462  5297		       03		      .byte.b	CL3	; 8
    463  5298		       02		      .byte.b	CL2	; 5
    464  5299		       02		      .byte.b	CL2	; 2
    465  529a		       00		      .byte.b	CL0	; 22
    466  529b		       05		      .byte.b	CL5	; 19
    467  529c		       05		      .byte.b	CL5	; 16
    468  529d		       04		      .byte.b	CL4	; 13
    469  529e		       04		      .byte.b	CL4	; 10
    470  529f		       02		      .byte.b	CL2	; 7
    471  52a0		       02		      .byte.b	CL2	; 4
    472  52a1		       01		      .byte.b	CL1	; 1
    473  52a2		       05		      .byte.b	CL5	; 21
    474  52a3		       05		      .byte.b	CL5	; 18
    475  52a4		       02		      .byte.b	CL2	; 15
    476  52a5		       04		      .byte.b	CL4	; 12
    477  52a6		       04		      .byte.b	CL4	; 9
    478  52a7		       02		      .byte.b	CL2	; 6
    479  52a8		       02		      .byte.b	CL2	; 3
    480  52a9		       01		      .byte.b	CL1	; 0
    481  52aa		       34	   FRAME_walk_right_2_look_left2_png .byte.b	52	; 23
    482  52ab		       28		      .byte.b	40	; 20
    483  52ac		       38		      .byte.b	56	; 17
    484  52ad		       ba		      .byte.b	186	; 14
    485  52ae		       fc		      .byte.b	252	; 11
    486  52af		       18		      .byte.b	24	; 8
    487  52b0		       0c		      .byte.b	12	; 5
    488  52b1		       38		      .byte.b	56	; 2
    489  52b2		       00		      .byte.b	0	; 22
    490  52b3		       28		      .byte.b	40	; 19
    491  52b4		       18		      .byte.b	24	; 16
    492  52b5		       ba		      .byte.b	186	; 13
    493  52b6		       7c		      .byte.b	124	; 10
    494  52b7		       18		      .byte.b	24	; 7
    495  52b8		       3c		      .byte.b	60	; 4
    496  52b9		       7c		      .byte.b	124	; 1
    497  52ba		       28		      .byte.b	40	; 21
    498  52bb		       28		      .byte.b	40	; 18
    499  52bc		       b2		      .byte.b	178	; 15
    500  52bd		       bc		      .byte.b	188	; 12
    501  52be		       38		      .byte.b	56	; 9
    502  52bf		       18		      .byte.b	24	; 6
    503  52c0		       14		      .byte.b	20	; 3
    504  52c1		       18		      .byte.b	24	; 0
    505  52c2		       06	   COLOUR_walk_right_2_look_left2 .byte.b	CL6	; 23
    506  52c3		       05		      .byte.b	CL5	; 20
    507  52c4		       05		      .byte.b	CL5	; 17
    508  52c5		       03		      .byte.b	CL3	; 14
    509  52c6		       04		      .byte.b	CL4	; 11
    510  52c7		       03		      .byte.b	CL3	; 8
    511  52c8		       02		      .byte.b	CL2	; 5
    512  52c9		       02		      .byte.b	CL2	; 2
    513  52ca		       00		      .byte.b	CL0	; 22
    514  52cb		       05		      .byte.b	CL5	; 19
    515  52cc		       05		      .byte.b	CL5	; 16
    516  52cd		       04		      .byte.b	CL4	; 13
    517  52ce		       04		      .byte.b	CL4	; 10
    518  52cf		       02		      .byte.b	CL2	; 7
    519  52d0		       02		      .byte.b	CL2	; 4
    520  52d1		       01		      .byte.b	CL1	; 1
    521  52d2		       05		      .byte.b	CL5	; 21
    522  52d3		       05		      .byte.b	CL5	; 18
    523  52d4		       02		      .byte.b	CL2	; 15
    524  52d5		       04		      .byte.b	CL4	; 12
    525  52d6		       04		      .byte.b	CL4	; 9
    526  52d7		       02		      .byte.b	CL2	; 6
    527  52d8		       02		      .byte.b	CL2	; 3
    528  52d9		       01		      .byte.b	CL1	; 0
    529  52da		       34	   FRAME_walk_right_2_look_left3_png .byte.b	52	; 23
    530  52db		       28		      .byte.b	40	; 20
    531  52dc		       38		      .byte.b	56	; 17
    532  52dd		       ba		      .byte.b	186	; 14
    533  52de		       fc		      .byte.b	252	; 11
    534  52df		       18		      .byte.b	24	; 8
    535  52e0		       30		      .byte.b	48	; 5
    536  52e1		       1c		      .byte.b	28	; 2
    537  52e2		       00		      .byte.b	0	; 22
    538  52e3		       28		      .byte.b	40	; 19
    539  52e4		       18		      .byte.b	24	; 16
    540  52e5		       ba		      .byte.b	186	; 13
    541  52e6		       7c		      .byte.b	124	; 10
    542  52e7		       18		      .byte.b	24	; 7
    543  52e8		       3c		      .byte.b	60	; 4
    544  52e9		       3e		      .byte.b	62	; 1
    545  52ea		       28		      .byte.b	40	; 21
    546  52eb		       28		      .byte.b	40	; 18
    547  52ec		       b2		      .byte.b	178	; 15
    548  52ed		       bc		      .byte.b	188	; 12
    549  52ee		       38		      .byte.b	56	; 9
    550  52ef		       18		      .byte.b	24	; 6
    551  52f0		       28		      .byte.b	40	; 3
    552  52f1		       18		      .byte.b	24	; 0
    553  52f2		       06	   COLOUR_walk_right_2_look_left3 .byte.b	CL6	; 23
    554  52f3		       05		      .byte.b	CL5	; 20
    555  52f4		       05		      .byte.b	CL5	; 17
    556  52f5		       03		      .byte.b	CL3	; 14
    557  52f6		       04		      .byte.b	CL4	; 11
    558  52f7		       03		      .byte.b	CL3	; 8
    559  52f8		       02		      .byte.b	CL2	; 5
    560  52f9		       02		      .byte.b	CL2	; 2
    561  52fa		       00		      .byte.b	CL0	; 22
    562  52fb		       05		      .byte.b	CL5	; 19
    563  52fc		       05		      .byte.b	CL5	; 16
    564  52fd		       04		      .byte.b	CL4	; 13
    565  52fe		       04		      .byte.b	CL4	; 10
    566  52ff		       02		      .byte.b	CL2	; 7
    567  5300		       02		      .byte.b	CL2	; 4
    568  5301		       01		      .byte.b	CL1	; 1
    569  5302		       05		      .byte.b	CL5	; 21
    570  5303		       05		      .byte.b	CL5	; 18
    571  5304		       02		      .byte.b	CL2	; 15
    572  5305		       04		      .byte.b	CL4	; 12
    573  5306		       04		      .byte.b	CL4	; 9
    574  5307		       02		      .byte.b	CL2	; 6
    575  5308		       02		      .byte.b	CL2	; 3
    576  5309		       01		      .byte.b	CL1	; 0
    577  530a		       34	   FRAME_walk_right_2_look_left_png .byte.b	52	; 23
    578  530b		       28		      .byte.b	40	; 20
    579  530c		       18		      .byte.b	24	; 17
    580  530d		       59		      .byte.b	89	; 14
    581  530e		       7c		      .byte.b	124	; 11
    582  530f		       18		      .byte.b	24	; 8
    583  5310		       18		      .byte.b	24	; 5
    584  5311		       20		      .byte.b	32	; 2
    585  5312		       00		      .byte.b	0	; 22
    586  5313		       38		      .byte.b	56	; 19
    587  5314		       18		      .byte.b	24	; 16
    588  5315		       5a		      .byte.b	90	; 13
    589  5316		       3c		      .byte.b	60	; 10
    590  5317		       18		      .byte.b	24	; 7
    591  5318		       30		      .byte.b	48	; 4
    592  5319		       78		      .byte.b	120	; 1
    593  531a		       28		      .byte.b	40	; 21
    594  531b		       18		      .byte.b	24	; 18
    595  531c		       31		      .byte.b	49	; 15
    596  531d		       7e		      .byte.b	126	; 12
    597  531e		       18		      .byte.b	24	; 9
    598  531f		       38		      .byte.b	56	; 6
    599  5320		       50		      .byte.b	80	; 3
    600  5321		       b8		      .byte.b	184	; 0
    601  5322		       06	   COLOUR_walk_right_2_look_left .byte.b	CL6	; 23
    602  5323		       05		      .byte.b	CL5	; 20
    603  5324		       05		      .byte.b	CL5	; 17
    604  5325		       03		      .byte.b	CL3	; 14
    605  5326		       04		      .byte.b	CL4	; 11
    606  5327		       03		      .byte.b	CL3	; 8
    607  5328		       02		      .byte.b	CL2	; 5
    608  5329		       02		      .byte.b	CL2	; 2
    609  532a		       00		      .byte.b	CL0	; 22
    610  532b		       05		      .byte.b	CL5	; 19
    611  532c		       05		      .byte.b	CL5	; 16
    612  532d		       04		      .byte.b	CL4	; 13
    613  532e		       04		      .byte.b	CL4	; 10
    614  532f		       02		      .byte.b	CL2	; 7
    615  5330		       02		      .byte.b	CL2	; 4
    616  5331		       01		      .byte.b	CL1	; 1
    617  5332		       05		      .byte.b	CL5	; 21
    618  5333		       05		      .byte.b	CL5	; 18
    619  5334		       02		      .byte.b	CL2	; 15
    620  5335		       04		      .byte.b	CL4	; 12
    621  5336		       04		      .byte.b	CL4	; 9
    622  5337		       02		      .byte.b	CL2	; 6
    623  5338		       02		      .byte.b	CL2	; 3
    624  5339		       01		      .byte.b	CL1	; 0
    625  533a		       26	   FRAME_push_right_2_png .byte.b	38	; 23
    626  533b		       14		      .byte.b	20	; 20
    627  533c		       3c		      .byte.b	60	; 17
    628  533d		       38		      .byte.b	56	; 14
    629  533e		       3c		      .byte.b	60	; 11
    630  533f		       19		      .byte.b	25	; 8
    631  5340		       18		      .byte.b	24	; 5
    632  5341		       04		      .byte.b	4	; 2
    633  5342		       40		      .byte.b	64	; 22
    634  5343		       14		      .byte.b	20	; 19
    635  5344		       28		      .byte.b	40	; 16
    636  5345		       38		      .byte.b	56	; 13
    637  5346		       3e		      .byte.b	62	; 10
    638  5347		       19		      .byte.b	25	; 7
    639  5348		       0c		      .byte.b	12	; 4
    640  5349		       1e		      .byte.b	30	; 1
    641  534a		       34		      .byte.b	52	; 21
    642  534b		       3c		      .byte.b	60	; 18
    643  534c		       30		      .byte.b	48	; 15
    644  534d		       38		      .byte.b	56	; 12
    645  534e		       3f		      .byte.b	63	; 9
    646  534f		       1d		      .byte.b	29	; 6
    647  5350		       0a		      .byte.b	10	; 3
    648  5351		       1d		      .byte.b	29	; 0
    649  5352		       06	   COLOUR_push_right_2 .byte.b	CL6	; 23
    650  5353		       05		      .byte.b	CL5	; 20
    651  5354		       05		      .byte.b	CL5	; 17
    652  5355		       03		      .byte.b	CL3	; 14
    653  5356		       04		      .byte.b	CL4	; 11
    654  5357		       03		      .byte.b	CL3	; 8
    655  5358		       02		      .byte.b	CL2	; 5
    656  5359		       02		      .byte.b	CL2	; 2
    657  535a		       06		      .byte.b	CL6	; 22
    658  535b		       05		      .byte.b	CL5	; 19
    659  535c		       05		      .byte.b	CL5	; 16
    660  535d		       04		      .byte.b	CL4	; 13
    661  535e		       04		      .byte.b	CL4	; 10
    662  535f		       02		      .byte.b	CL2	; 7
    663  5360		       02		      .byte.b	CL2	; 4
    664  5361		       01		      .byte.b	CL1	; 1
    665  5362		       05		      .byte.b	CL5	; 21
    666  5363		       05		      .byte.b	CL5	; 18
    667  5364		       01		      .byte.b	CL1	; 15
    668  5365		       04		      .byte.b	CL4	; 12
    669  5366		       04		      .byte.b	CL4	; 9
    670  5367		       02		      .byte.b	CL2	; 6
    671  5368		       02		      .byte.b	CL2	; 3
    672  5369		       01		      .byte.b	CL1	; 0
    673  536a		       2c	   FRAME_idle_right_2_png .byte.b	44	; 23
    674  536b		       28		      .byte.b	40	; 20
    675  536c		       38		      .byte.b	56	; 17
    676  536d		       38		      .byte.b	56	; 14
    677  536e		       fe		      .byte.b	254	; 11
    678  536f		       b2		      .byte.b	178	; 8
    679  5370		       30		      .byte.b	48	; 5
    680  5371		       08		      .byte.b	8	; 2
    681  5372		       00		      .byte.b	0	; 22
    682  5373		       28		      .byte.b	40	; 19
    683  5374		       38		      .byte.b	56	; 16
    684  5375		       38		      .byte.b	56	; 13
    685  5376		       fe		      .byte.b	254	; 10
    686  5377		       ba		      .byte.b	186	; 7
    687  5378		       18		      .byte.b	24	; 4
    688  5379		       3c		      .byte.b	60	; 1
    689  537a		       28		      .byte.b	40	; 21
    690  537b		       28		      .byte.b	40	; 18
    691  537c		       28		      .byte.b	40	; 15
    692  537d		       38		      .byte.b	56	; 12
    693  537e		       ba		      .byte.b	186	; 9
    694  537f		       30		      .byte.b	48	; 6
    695  5380		       14		      .byte.b	20	; 3
    696  5381		       3a		      .byte.b	58	; 0
    697  5382		       06	   COLOUR_idle_right_2 .byte.b	CL6	; 23
    698  5383		       05		      .byte.b	CL5	; 20
    699  5384		       05		      .byte.b	CL5	; 17
    700  5385		       03		      .byte.b	CL3	; 14
    701  5386		       04		      .byte.b	CL4	; 11
    702  5387		       03		      .byte.b	CL3	; 8
    703  5388		       02		      .byte.b	CL2	; 5
    704  5389		       02		      .byte.b	CL2	; 2
    705  538a		       00		      .byte.b	CL0	; 22
    706  538b		       05		      .byte.b	CL5	; 19
    707  538c		       05		      .byte.b	CL5	; 16
    708  538d		       04		      .byte.b	CL4	; 13
    709  538e		       04		      .byte.b	CL4	; 10
    710  538f		       02		      .byte.b	CL2	; 7
    711  5390		       02		      .byte.b	CL2	; 4
    712  5391		       01		      .byte.b	CL1	; 1
    713  5392		       05		      .byte.b	CL5	; 21
    714  5393		       05		      .byte.b	CL5	; 18
    715  5394		       06		      .byte.b	CL6	; 15
    716  5395		       04		      .byte.b	CL4	; 12
    717  5396		       04		      .byte.b	CL4	; 9
    718  5397		       02		      .byte.b	CL2	; 6
    719  5398		       02		      .byte.b	CL2	; 3
    720  5399		       01		      .byte.b	CL1	; 0
    721  539a		       46	   FRAME_BOO_push_right_1_png .byte.b	70	; 23
    722  539b		       62		      .byte.b	98	; 20
    723  539c		       28		      .byte.b	40	; 17
    724  539d		       38		      .byte.b	56	; 14
    725  539e		       3c		      .byte.b	60	; 11
    726  539f		       59		      .byte.b	89	; 8
    727  53a0		       0c		      .byte.b	12	; 5
    728  53a1		       1e		      .byte.b	30	; 2
    729  53a2		       80		      .byte.b	128	; 22
    730  53a3		       1e		      .byte.b	30	; 19
    731  53a4		       30		      .byte.b	48	; 16
    732  53a5		       38		      .byte.b	56	; 13
    733  53a6		       3e		      .byte.b	62	; 10
    734  53a7		       5d		      .byte.b	93	; 7
    735  53a8		       0a		      .byte.b	10	; 4
    736  53a9		       1d		      .byte.b	29	; 1
    737  53aa		       64		      .byte.b	100	; 21
    738  53ab		       3c		      .byte.b	60	; 18
    739  53ac		       38		      .byte.b	56	; 15
    740  53ad		       38		      .byte.b	56	; 12
    741  53ae		       7b		      .byte.b	123	; 9
    742  53af		       59		      .byte.b	89	; 6
    743  53b0		       04		      .byte.b	4	; 3
    744  53b1		       00		      .byte.b	0	; 0
    745  53b2		       06	   COLOUR_BOO_push_right_1 .byte.b	CL6	; 23
    746  53b3		       05		      .byte.b	CL5	; 20
    747  53b4		       05		      .byte.b	CL5	; 17
    748  53b5		       04		      .byte.b	CL4	; 14
    749  53b6		       04		      .byte.b	CL4	; 11
    750  53b7		       03		      .byte.b	CL3	; 8
    751  53b8		       02		      .byte.b	CL2	; 5
    752  53b9		       01		      .byte.b	CL1	; 2
    753  53ba		       06		      .byte.b	CL6	; 22
    754  53bb		       05		      .byte.b	CL5	; 19
    755  53bc		       06		      .byte.b	CL6	; 16
    756  53bd		       04		      .byte.b	CL4	; 13
    757  53be		       04		      .byte.b	CL4	; 10
    758  53bf		       02		      .byte.b	CL2	; 7
    759  53c0		       02		      .byte.b	CL2	; 4
    760  53c1		       01		      .byte.b	CL1	; 1
    761  53c2		       05		      .byte.b	CL5	; 21
    762  53c3		       05		      .byte.b	CL5	; 18
    763  53c4		       03		      .byte.b	CL3	; 15
    764  53c5		       04		      .byte.b	CL4	; 12
    765  53c6		       04		      .byte.b	CL4	; 9
    766  53c7		       02		      .byte.b	CL2	; 6
    767  53c8		       02		      .byte.b	CL2	; 3
    768  53c9		       00		      .byte.b	CL0	; 0
    769  53ca		       2c	   FRAME_idle_right_3_png .byte.b	44	; 23
    770  53cb		       28		      .byte.b	40	; 20
    771  53cc		       38		      .byte.b	56	; 17
    772  53cd		       38		      .byte.b	56	; 14
    773  53ce		       38		      .byte.b	56	; 11
    774  53cf		       b2		      .byte.b	178	; 8
    775  53d0		       30		      .byte.b	48	; 5
    776  53d1		       08		      .byte.b	8	; 2
    777  53d2		       00		      .byte.b	0	; 22
    778  53d3		       28		      .byte.b	40	; 19
    779  53d4		       38		      .byte.b	56	; 16
    780  53d5		       38		      .byte.b	56	; 13
    781  53d6		       fe		      .byte.b	254	; 10
    782  53d7		       ba		      .byte.b	186	; 7
    783  53d8		       18		      .byte.b	24	; 4
    784  53d9		       3c		      .byte.b	60	; 1
    785  53da		       28		      .byte.b	40	; 21
    786  53db		       28		      .byte.b	40	; 18
    787  53dc		       28		      .byte.b	40	; 15
    788  53dd		       38		      .byte.b	56	; 12
    789  53de		       fe		      .byte.b	254	; 9
    790  53df		       b2		      .byte.b	178	; 6
    791  53e0		       14		      .byte.b	20	; 3
    792  53e1		       3a		      .byte.b	58	; 0
    793  53e2		       06	   COLOUR_idle_right_3 .byte.b	CL6	; 23
    794  53e3		       05		      .byte.b	CL5	; 20
    795  53e4		       05		      .byte.b	CL5	; 17
    796  53e5		       03		      .byte.b	CL3	; 14
    797  53e6		       04		      .byte.b	CL4	; 11
    798  53e7		       03		      .byte.b	CL3	; 8
    799  53e8		       02		      .byte.b	CL2	; 5
    800  53e9		       02		      .byte.b	CL2	; 2
    801  53ea		       00		      .byte.b	CL0	; 22
    802  53eb		       05		      .byte.b	CL5	; 19
    803  53ec		       05		      .byte.b	CL5	; 16
    804  53ed		       04		      .byte.b	CL4	; 13
    805  53ee		       04		      .byte.b	CL4	; 10
    806  53ef		       02		      .byte.b	CL2	; 7
    807  53f0		       02		      .byte.b	CL2	; 4
    808  53f1		       01		      .byte.b	CL1	; 1
    809  53f2		       05		      .byte.b	CL5	; 21
    810  53f3		       05		      .byte.b	CL5	; 18
    811  53f4		       06		      .byte.b	CL6	; 15
    812  53f5		       04		      .byte.b	CL4	; 12
    813  53f6		       04		      .byte.b	CL4	; 9
    814  53f7		       02		      .byte.b	CL2	; 6
    815  53f8		       02		      .byte.b	CL2	; 3
    816  53f9		       01		      .byte.b	CL1	; 0
    817  53fa		       46	   FRAME_push_right_3_png .byte.b	70	; 23
    818  53fb		       72		      .byte.b	114	; 20
    819  53fc		       18		      .byte.b	24	; 17
    820  53fd		       38		      .byte.b	56	; 14
    821  53fe		       3e		      .byte.b	62	; 11
    822  53ff		       19		      .byte.b	25	; 8
    823  5400		       0c		      .byte.b	12	; 5
    824  5401		       1e		      .byte.b	30	; 2
    825  5402		       80		      .byte.b	128	; 22
    826  5403		       3e		      .byte.b	62	; 19
    827  5404		       30		      .byte.b	48	; 16
    828  5405		       38		      .byte.b	56	; 13
    829  5406		       3f		      .byte.b	63	; 10
    830  5407		       1d		      .byte.b	29	; 7
    831  5408		       0a		      .byte.b	10	; 4
    832  5409		       1d		      .byte.b	29	; 1
    833  540a		       64		      .byte.b	100	; 21
    834  540b		       3c		      .byte.b	60	; 18
    835  540c		       38		      .byte.b	56	; 15
    836  540d		       3c		      .byte.b	60	; 12
    837  540e		       19		      .byte.b	25	; 9
    838  540f		       18		      .byte.b	24	; 6
    839  5410		       04		      .byte.b	4	; 3
    840  5411		       00		      .byte.b	0	; 0
    841  5412		       06	   COLOUR_push_right_3 .byte.b	CL6	; 23
    842  5413		       05		      .byte.b	CL5	; 20
    843  5414		       05		      .byte.b	CL5	; 17
    844  5415		       04		      .byte.b	CL4	; 14
    845  5416		       04		      .byte.b	CL4	; 11
    846  5417		       02		      .byte.b	CL2	; 8
    847  5418		       02		      .byte.b	CL2	; 5
    848  5419		       01		      .byte.b	CL1	; 2
    849  541a		       06		      .byte.b	CL6	; 22
    850  541b		       05		      .byte.b	CL5	; 19
    851  541c		       05		      .byte.b	CL5	; 16
    852  541d		       04		      .byte.b	CL4	; 13
    853  541e		       04		      .byte.b	CL4	; 10
    854  541f		       02		      .byte.b	CL2	; 7
    855  5420		       02		      .byte.b	CL2	; 4
    856  5421		       01		      .byte.b	CL1	; 1
    857  5422		       05		      .byte.b	CL5	; 21
    858  5423		       05		      .byte.b	CL5	; 18
    859  5424		       03		      .byte.b	CL3	; 15
    860  5425		       04		      .byte.b	CL4	; 12
    861  5426		       03		      .byte.b	CL3	; 9
    862  5427		       02		      .byte.b	CL2	; 6
    863  5428		       02		      .byte.b	CL2	; 3
    864  5429		       00		      .byte.b	CL0	; 0
    865  542a		       46	   FRAME_push_right_1_png .byte.b	70	; 23
    866  542b		       62		      .byte.b	98	; 20
    867  542c		       28		      .byte.b	40	; 17
    868  542d		       38		      .byte.b	56	; 14
    869  542e		       3e		      .byte.b	62	; 11
    870  542f		       19		      .byte.b	25	; 8
    871  5430		       0c		      .byte.b	12	; 5
    872  5431		       1e		      .byte.b	30	; 2
    873  5432		       80		      .byte.b	128	; 22
    874  5433		       1e		      .byte.b	30	; 19
    875  5434		       30		      .byte.b	48	; 16
    876  5435		       38		      .byte.b	56	; 13
    877  5436		       3f		      .byte.b	63	; 10
    878  5437		       1d		      .byte.b	29	; 7
    879  5438		       0a		      .byte.b	10	; 4
    880  5439		       1d		      .byte.b	29	; 1
    881  543a		       64		      .byte.b	100	; 21
    882  543b		       3c		      .byte.b	60	; 18
    883  543c		       38		      .byte.b	56	; 15
    884  543d		       3c		      .byte.b	60	; 12
    885  543e		       19		      .byte.b	25	; 9
    886  543f		       18		      .byte.b	24	; 6
    887  5440		       04		      .byte.b	4	; 3
    888  5441		       00		      .byte.b	0	; 0
    889  5442		       06	   COLOUR_push_right_1 .byte.b	CL6	; 23
    890  5443		       05		      .byte.b	CL5	; 20
    891  5444		       05		      .byte.b	CL5	; 17
    892  5445		       04		      .byte.b	CL4	; 14
    893  5446		       04		      .byte.b	CL4	; 11
    894  5447		       02		      .byte.b	CL2	; 8
    895  5448		       02		      .byte.b	CL2	; 5
    896  5449		       01		      .byte.b	CL1	; 2
    897  544a		       06		      .byte.b	CL6	; 22
    898  544b		       05		      .byte.b	CL5	; 19
    899  544c		       06		      .byte.b	CL6	; 16
    900  544d		       04		      .byte.b	CL4	; 13
    901  544e		       04		      .byte.b	CL4	; 10
    902  544f		       02		      .byte.b	CL2	; 7
    903  5450		       02		      .byte.b	CL2	; 4
    904  5451		       01		      .byte.b	CL1	; 1
    905  5452		       05		      .byte.b	CL5	; 21
    906  5453		       05		      .byte.b	CL5	; 18
    907  5454		       03		      .byte.b	CL3	; 15
    908  5455		       04		      .byte.b	CL4	; 12
    909  5456		       03		      .byte.b	CL3	; 9
    910  5457		       02		      .byte.b	CL2	; 6
    911  5458		       02		      .byte.b	CL2	; 3
    912  5459		       00		      .byte.b	CL0	; 0
    913  545a		       2c	   FRAME_idle_right_1_png .byte.b	44	; 23
    914  545b		       28		      .byte.b	40	; 20
    915  545c		       38		      .byte.b	56	; 17
    916  545d		       ba		      .byte.b	186	; 14
    917  545e		       fc		      .byte.b	252	; 11
    918  545f		       18		      .byte.b	24	; 8
    919  5460		       18		      .byte.b	24	; 5
    920  5461		       04		      .byte.b	4	; 2
    921  5462		       00		      .byte.b	0	; 22
    922  5463		       28		      .byte.b	40	; 19
    923  5464		       38		      .byte.b	56	; 16
    924  5465		       ba		      .byte.b	186	; 13
    925  5466		       7c		      .byte.b	124	; 10
    926  5467		       18		      .byte.b	24	; 7
    927  5468		       0c		      .byte.b	12	; 4
    928  5469		       1e		      .byte.b	30	; 1
    929  546a		       28		      .byte.b	40	; 21
    930  546b		       28		      .byte.b	40	; 18
    931  546c		       aa		      .byte.b	170	; 15
    932  546d		       bc		      .byte.b	188	; 12
    933  546e		       38		      .byte.b	56	; 9
    934  546f		       1c		      .byte.b	28	; 6
    935  5470		       0a		      .byte.b	10	; 3
    936  5471		       1d		      .byte.b	29	; 0
    937  5472		       06	   COLOUR_idle_right_1 .byte.b	CL6	; 23
    938  5473		       05		      .byte.b	CL5	; 20
    939  5474		       05		      .byte.b	CL5	; 17
    940  5475		       03		      .byte.b	CL3	; 14
    941  5476		       04		      .byte.b	CL4	; 11
    942  5477		       03		      .byte.b	CL3	; 8
    943  5478		       02		      .byte.b	CL2	; 5
    944  5479		       02		      .byte.b	CL2	; 2
    945  547a		       00		      .byte.b	CL0	; 22
    946  547b		       05		      .byte.b	CL5	; 19
    947  547c		       05		      .byte.b	CL5	; 16
    948  547d		       04		      .byte.b	CL4	; 13
    949  547e		       04		      .byte.b	CL4	; 10
    950  547f		       02		      .byte.b	CL2	; 7
    951  5480		       02		      .byte.b	CL2	; 4
    952  5481		       01		      .byte.b	CL1	; 1
    953  5482		       05		      .byte.b	CL5	; 21
    954  5483		       05		      .byte.b	CL5	; 18
    955  5484		       02		      .byte.b	CL2	; 15
    956  5485		       04		      .byte.b	CL4	; 12
    957  5486		       04		      .byte.b	CL4	; 9
    958  5487		       02		      .byte.b	CL2	; 6
    959  5488		       02		      .byte.b	CL2	; 3
    960  5489		       01		      .byte.b	CL1	; 0
    961  548a		       30	   FRAME_tapfoot_png .byte.b	48	; 23
    962  548b		       28		      .byte.b	40	; 20
    963  548c		       38		      .byte.b	56	; 17
    964  548d		       ba		      .byte.b	186	; 14
    965  548e		       fc		      .byte.b	252	; 11
    966  548f		       18		      .byte.b	24	; 8
    967  5490		       18		      .byte.b	24	; 5
    968  5491		       04		      .byte.b	4	; 2
    969  5492		       0c		      .byte.b	12	; 22
    970  5493		       28		      .byte.b	40	; 19
    971  5494		       18		      .byte.b	24	; 16
    972  5495		       ba		      .byte.b	186	; 13
    973  5496		       7c		      .byte.b	124	; 10
    974  5497		       18		      .byte.b	24	; 7
    975  5498		       0c		      .byte.b	12	; 4
    976  5499		       1e		      .byte.b	30	; 1
    977  549a		       20		      .byte.b	32	; 21
    978  549b		       28		      .byte.b	40	; 18
    979  549c		       b2		      .byte.b	178	; 15
    980  549d		       bc		      .byte.b	188	; 12
    981  549e		       38		      .byte.b	56	; 9
    982  549f		       1c		      .byte.b	28	; 6
    983  54a0		       0a		      .byte.b	10	; 3
    984  54a1		       1d		      .byte.b	29	; 0
    985  54a2		       06	   COLOUR_tapfoot .byte.b	CL6	; 23
    986  54a3		       05		      .byte.b	CL5	; 20
    987  54a4		       05		      .byte.b	CL5	; 17
    988  54a5		       03		      .byte.b	CL3	; 14
    989  54a6		       04		      .byte.b	CL4	; 11
    990  54a7		       03		      .byte.b	CL3	; 8
    991  54a8		       02		      .byte.b	CL2	; 5
    992  54a9		       02		      .byte.b	CL2	; 2
    993  54aa		       06		      .byte.b	CL6	; 22
    994  54ab		       05		      .byte.b	CL5	; 19
    995  54ac		       05		      .byte.b	CL5	; 16
    996  54ad		       04		      .byte.b	CL4	; 13
    997  54ae		       04		      .byte.b	CL4	; 10
    998  54af		       02		      .byte.b	CL2	; 7
    999  54b0		       02		      .byte.b	CL2	; 4
   1000  54b1		       01		      .byte.b	CL1	; 1
   1001  54b2		       05		      .byte.b	CL5	; 21
   1002  54b3		       05		      .byte.b	CL5	; 18
   1003  54b4		       02		      .byte.b	CL2	; 15
   1004  54b5		       04		      .byte.b	CL4	; 12
   1005  54b6		       04		      .byte.b	CL4	; 9
   1006  54b7		       02		      .byte.b	CL2	; 6
   1007  54b8		       02		      .byte.b	CL2	; 3
   1008  54b9		       01		      .byte.b	CL1	; 0
------- FILE spriteBank.asm
------- FILE BANK_PlayerFrames.asm
     55  54ba
      0  54ba					      CHECK_BANK_SIZE	"PLAYER_FRAMES"
      1  54ba		       04 ba	   .TEMP      =	* - BANK_START
 PLAYER_FRAMES (2K) SIZE =  $4ba , FREE= $346
      2  54ba					      ECHO	"PLAYER_FRAMES", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  54ba				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  54ba				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  54ba				  -	      ERR
      6  54ba					      endif
------- FILE ./sokoboo.asm
------- FILE titleScreen.asm LEVEL 2 PASS 4
      0  54ba					      include	"titleScreen.asm"
      0  54ba					      NEWBANK	TITLESCREEN
      1  5c6b ????				      SEG	TITLESCREEN
      2  5800					      ORG	ORIGIN
      3  5800					      RORG	$F000
      4  5800				   BANK_START SET	*
      5  5800				   TITLESCREEN SET	ORIGIN / 2048
      6  5800				   ORIGIN     SET	ORIGIN + 2048
      7  5800				   _CURRENT_BANK SET	TITLESCREEN
      0  5800					      DEFINE_SUBROUTINE	TitleScreen
      1  5800		       00 0b	   BANK_TitleScreen =	_CURRENT_BANK
      2  5800					      SUBROUTINE
      3  5800				   TitleScreen
      3  5800
      4  5800							; Start of new frame
      5  5800
      6  5800							; Start of vertical blank processing
      7  5800
      8  5800				   TitleSequence
      9  5800
     10  5800		       a9 00		      lda	#%00000000
     11  5802		       85 4a		      sta	CTRLPF
     12  5804		       85 49		      sta	COLUBK
     13  5806
     14  5806		       a6 81		      ldx	Platform
     15  5808		       bd a7 f0 	      lda	colvec,x
     16  580b		       85 e2		      sta	colour_table
     17  580d		       bd a8 f0 	      lda	colvec+1,x
     18  5810		       85 e3		      sta	colour_table+1
     19  5812
      0  5812					      RESYNC
      1  5812
      2  5812		       a9 02		      lda	#%10
      3  5814		       85 41		      sta	VBLANK
      4  5816
      5  5816		       a2 08		      ldx	#8
      6  5818				   .loopResync
      0  5818					      VERTICAL_SYNC
      1  5818		       a9 0e		      lda	#%1110
      2  581a		       85 42	   .VSLP1     sta	WSYNC
      3  581c		       85 40		      sta	VSYNC
      4  581e		       4a		      lsr
      5  581f		       d0 f9		      bne	.VSLP1
      8  5821
      9  5821		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  5823		       a5 81		      lda	Platform
     11  5825		       49 02		      eor	#PAL_50
     12  5827		       d0 02		      bne	.ntsc
     13  5829		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  582b				   .ntsc
     15  582b				   .loopWait
     16  582b		       85 42		      sta	WSYNC
     17  582d		       85 42		      sta	WSYNC
     18  582f		       88		      dey
     19  5830		       d0 f9		      bne	.loopWait
     20  5832		       ca		      dex
     21  5833		       d0 e3		      bne	.loopResync
     21  5835
     22  5835				   RestartFrame
     23  5835		       a9 0e		      lda	#%1110	; VSYNC ON
     24  5837		       85 42	   .loopVSync2 sta	WSYNC
     25  5839		       85 40		      sta	VSYNC
     26  583b		       4a		      lsr
     27  583c		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     28  583e
     29  583e							;------------------------------------------------------------------
     30  583e
     31  583e		       a6 81		      ldx	Platform
     32  5840		       bc 78 fd 	      ldy	VBlankTime,x
     33  5843		       8c 96 02 	      sty	TIM64T
     34  5846
     35  5846		       85 42	   VerticalBlank sta	WSYNC
     36  5848		       ad 84 02 	      lda	INTIM
     37  584b		       d0 f9		      bne	VerticalBlank
     38  584d		       85 41		      sta	VBLANK
     39  584f
     40  584f
     41  584f							;------------------------------------------------------------------
     42  584f
     43  584f							; Do X scanlines of color-changing (our picture)
     44  584f
     45  584f		       a0 77		      ldy	#119	; this counts our scanline number
     46  5851		       a2 03	   SokoLogo   ldx	#3
     47  5853		       b1 e2	   triplet    lda	(colour_table),y
     48  5855		       85 42		      sta	WSYNC
     49  5857		       85 48		      sta	COLUPF	; 3
     50  5859
     51  5859		       b9 9b f1 	      lda	COL_0,y	; 5
     52  585c		       85 4d		      sta	PF0	; 3   @11
     53  585e		       b9 13 f2 	      lda	COL_1,y	; 5
     54  5861		       85 4e		      sta	PF1	; 3   @19
     55  5863		       b9 8b f2 	      lda	COL_2,y	; 5
     56  5866		       85 4f		      sta	PF2	; 3   @27
     57  5868
     58  5868		       b9 03 f3 	      lda	COL_3,y	; 5
     59  586b		       85 4d		      sta	PF0	; 3   @35
      0  586d					      SLEEP	2	; @37
      1  586d				   .CYCLES    SET	2
      2  586d
      3  586d				  -	      IF	.CYCLES < 2
      4  586d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  586d				  -	      ERR
      6  586d					      ENDIF
      7  586d
      8  586d				  -	      IF	.CYCLES & 1
      9  586d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  586d				  -	      nop	0
     11  586d				  -	      ELSE
     12  586d				  -	      bit	VSYNC
     13  586d				  -	      ENDIF
     14  586d				  -.CYCLES    SET	.CYCLES - 3
     15  586d					      ENDIF
     16  586d
     17  586d					      REPEAT	.CYCLES / 2
     18  586d		       ea		      nop
     19  586e					      REPEND
     61  586e		       b9 7b f3 	      lda	COL_4,y	; 5
     62  5871		       85 4e		      sta	PF1	; 3   @45
      0  5873					      SLEEP	3	; @45
      1  5873				   .CYCLES    SET	3
      2  5873
      3  5873				  -	      IF	.CYCLES < 2
      4  5873				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  5873				  -	      ERR
      6  5873					      ENDIF
      7  5873
      8  5873					      IF	.CYCLES & 1
      9  5873					      IFNCONST	NO_ILLEGAL_OPCODES
     10  5873		       04 00		      nop	0
     11  5875				  -	      ELSE
     12  5875				  -	      bit	VSYNC
     13  5875					      ENDIF
     14  5875				   .CYCLES    SET	.CYCLES - 3
     15  5875					      ENDIF
     16  5875
     17  5875				  -	      REPEAT	.CYCLES / 2
     18  5875				  -	      nop
     19  5875					      REPEND
     64  5875		       b9 f3 f3 	      lda	COL_5,y	; 5
     65  5878		       85 4f		      sta	PF2	; 3
     66  587a
     67  587a		       88		      dey		; 2
     68  587b		       ca		      dex		; 2
     69  587c		       d0 d5		      bne	triplet	; 2(3)
     70  587e
     71  587e		       c0 ff		      cpy	#-1	; 2
     72  5880		       d0 cf		      bne	SokoLogo	; 2(3)
     73  5882
     74  5882		       a9 00		      lda	#0
     75  5884		       85 4d		      sta	PF0
     76  5886		       85 4e		      sta	PF1
     77  5888		       85 4f		      sta	PF2
     78  588a
     79  588a		       a6 81		      ldx	Platform
     80  588c		       bd a3 f0 	      lda	OverscanTime2,x
     81  588f		       8d 96 02 	      sta	TIM64T
     82  5892
     83  5892				  -	      if	0
     84  5892				  -	      sta	WSYNC
     85  5892				  -	      sta	WSYNC
     86  5892				  -	      sta	WSYNC
     87  5892				  -	      sta	WSYNC
     88  5892				  -	      sta	WSYNC
     89  5892				  -	      SLEEP	8
     90  5892				  -	      jsr	SokoScreen
     91  5892				  -
     92  5892				  -	      lda	#0
     93  5892				  -	      sta	BoardScrollX
     94  5892				  -	      sta	BoardScrollY
     95  5892					      endif
     96  5892
     97  5892							;		ldy #63
     98  5892							;bot2		 sta WSYNC
     99  5892							;		dey
    100  5892							;		bpl bot2
    101  5892
    102  5892							;--------------------------------------------------------------------------
    103  5892
    104  5892							;		lda #0
    105  5892							;		sta PF0
    106  5892							;		sta PF1
    107  5892							;		sta PF2
    108  5892
    109  5892
    110  5892
    111  5892							; D1 VBLANK turns off beam
    112  5892							; It needs to be turned on 37 scanlines later
    113  5892
    114  5892				   oscan
    115  5892		       ad 84 02 	      lda	INTIM
    116  5895		       d0 fb		      bne	oscan
    117  5897
    118  5897		       a9 42		      lda	#%01000010	; bit6 is not required
    119  5899		       85 41		      sta	VBLANK	; end of screen - enter blanking
    120  589b
    121  589b		       a5 4c		      lda	INPT4
    122  589d		       10 03		      bpl	ret
    123  589f
    124  589f		       4c 35 f0 	      jmp	RestartFrame
    125  58a2
    126  58a2		       60	   ret	      rts
    127  58a3
    128  58a3				   OverscanTime2
    129  58a3		       85 85		      .byte.b	133, 133
    130  58a5		       8b 8b		      .byte.b	139, 139
    131  58a7
    132  58a7				   colvec
    133  58a7		       23 f1 ab f0	      .word.w	colr_ntsc, colr_pal
    134  58ab
    135  58ab
    136  58ab					      MAC	lumtable
    137  58ab							; {4} MIN LUM 1
    138  58ab							; {5} MIN LUM 2
    139  58ab							; {6} MIN LUM 3
    140  58ab
    141  58ab				   .LUM1      SET	{4}
    142  58ab				   .LUM2      SET	{5}
    143  58ab				   .LUM3      SET	{6}
    144  58ab
    145  58ab				   .STEP1     =	256*($C-{4})/8
    146  58ab				   .STEP2     =	256*($C-{5})/8
    147  58ab				   .STEP3     =	256*($C-{6})/8
    148  58ab
    149  58ab					      REPEAT	8
    150  58ab					      REPEAT	5
    151  58ab					      .byte	{1}+{4}+(.LUM1/256/5)
    152  58ab					      .byte	{2}+{5}+(.LUM2/256/5)
    153  58ab					      .byte	{3}+{6}+(.LUM3/256/5)
    154  58ab				   .LUM1      SET	.LUM1 + .STEP1
    155  58ab				   .LUM2      SET	.LUM2 + .STEP2
    156  58ab				   .LUM3      SET	.LUM3 + .STEP3
    157  58ab					      REPEND
    158  58ab					      REPEND
    159  58ab					      ENDM		;{1}{2}{3} base colours
    160  58ab
    161  58ab							;colr_pal    LUMTABLE $B0,$30,$A0,0,8,4 ;2,4,6
      0  58ab				   colr_pal   LUMTABLE	$C0, $90, $60,0,8,4
      1  58ab
      2  58ab
      3  58ab
      4  58ab
      5  58ab				   .LUM1      SET	0
      6  58ab				   .LUM2      SET	8
      7  58ab				   .LUM3      SET	4
      8  58ab
      9  58ab		       01 80	   .STEP1     =	256*($C-0)/8
     10  58ab		       00 80	   .STEP2     =	256*($C-8)/8
     11  58ab		       01 00	   .STEP3     =	256*($C-4)/8
     12  58ab
     13  58ab					      REPEAT	8
     14  58ab					      REPEAT	5
     15  58ab		       c0		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58ac		       98		      .byte.b	$90+8+(.LUM2/256/5)
     17  58ad		       64		      .byte.b	$60+4+(.LUM3/256/5)
     18  58ad				   .LUM1      SET	.LUM1 + .STEP1
     19  58ad				   .LUM2      SET	.LUM2 + .STEP2
     20  58ad				   .LUM3      SET	.LUM3 + .STEP3
     14  58ad					      REPEND
     15  58ae		       c0		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58af		       98		      .byte.b	$90+8+(.LUM2/256/5)
     17  58b0		       64		      .byte.b	$60+4+(.LUM3/256/5)
     18  58b0				   .LUM1      SET	.LUM1 + .STEP1
     19  58b0				   .LUM2      SET	.LUM2 + .STEP2
     20  58b0				   .LUM3      SET	.LUM3 + .STEP3
     14  58b0					      REPEND
     15  58b1		       c0		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58b2		       98		      .byte.b	$90+8+(.LUM2/256/5)
     17  58b3		       64		      .byte.b	$60+4+(.LUM3/256/5)
     18  58b3				   .LUM1      SET	.LUM1 + .STEP1
     19  58b3				   .LUM2      SET	.LUM2 + .STEP2
     20  58b3				   .LUM3      SET	.LUM3 + .STEP3
     14  58b3					      REPEND
     15  58b4		       c0		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58b5		       98		      .byte.b	$90+8+(.LUM2/256/5)
     17  58b6		       64		      .byte.b	$60+4+(.LUM3/256/5)
     18  58b6				   .LUM1      SET	.LUM1 + .STEP1
     19  58b6				   .LUM2      SET	.LUM2 + .STEP2
     20  58b6				   .LUM3      SET	.LUM3 + .STEP3
     14  58b6					      REPEND
     15  58b7		       c1		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58b8		       98		      .byte.b	$90+8+(.LUM2/256/5)
     17  58b9		       64		      .byte.b	$60+4+(.LUM3/256/5)
     18  58b9				   .LUM1      SET	.LUM1 + .STEP1
     19  58b9				   .LUM2      SET	.LUM2 + .STEP2
     20  58b9				   .LUM3      SET	.LUM3 + .STEP3
     21  58ba					      REPEND
     13  58ba					      REPEND
     14  58ba					      REPEAT	5
     15  58ba		       c1		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58bb		       98		      .byte.b	$90+8+(.LUM2/256/5)
     17  58bc		       65		      .byte.b	$60+4+(.LUM3/256/5)
     18  58bc				   .LUM1      SET	.LUM1 + .STEP1
     19  58bc				   .LUM2      SET	.LUM2 + .STEP2
     20  58bc				   .LUM3      SET	.LUM3 + .STEP3
     14  58bc					      REPEND
     15  58bd		       c1		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58be		       98		      .byte.b	$90+8+(.LUM2/256/5)
     17  58bf		       65		      .byte.b	$60+4+(.LUM3/256/5)
     18  58bf				   .LUM1      SET	.LUM1 + .STEP1
     19  58bf				   .LUM2      SET	.LUM2 + .STEP2
     20  58bf				   .LUM3      SET	.LUM3 + .STEP3
     14  58bf					      REPEND
     15  58c0		       c2		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58c1		       98		      .byte.b	$90+8+(.LUM2/256/5)
     17  58c2		       65		      .byte.b	$60+4+(.LUM3/256/5)
     18  58c2				   .LUM1      SET	.LUM1 + .STEP1
     19  58c2				   .LUM2      SET	.LUM2 + .STEP2
     20  58c2				   .LUM3      SET	.LUM3 + .STEP3
     14  58c2					      REPEND
     15  58c3		       c2		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58c4		       98		      .byte.b	$90+8+(.LUM2/256/5)
     17  58c5		       65		      .byte.b	$60+4+(.LUM3/256/5)
     18  58c5				   .LUM1      SET	.LUM1 + .STEP1
     19  58c5				   .LUM2      SET	.LUM2 + .STEP2
     20  58c5				   .LUM3      SET	.LUM3 + .STEP3
     14  58c5					      REPEND
     15  58c6		       c2		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58c7		       98		      .byte.b	$90+8+(.LUM2/256/5)
     17  58c8		       65		      .byte.b	$60+4+(.LUM3/256/5)
     18  58c8				   .LUM1      SET	.LUM1 + .STEP1
     19  58c8				   .LUM2      SET	.LUM2 + .STEP2
     20  58c8				   .LUM3      SET	.LUM3 + .STEP3
     21  58c9					      REPEND
     13  58c9					      REPEND
     14  58c9					      REPEAT	5
     15  58c9		       c3		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58ca		       99		      .byte.b	$90+8+(.LUM2/256/5)
     17  58cb		       66		      .byte.b	$60+4+(.LUM3/256/5)
     18  58cb				   .LUM1      SET	.LUM1 + .STEP1
     19  58cb				   .LUM2      SET	.LUM2 + .STEP2
     20  58cb				   .LUM3      SET	.LUM3 + .STEP3
     14  58cb					      REPEND
     15  58cc		       c3		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58cd		       99		      .byte.b	$90+8+(.LUM2/256/5)
     17  58ce		       66		      .byte.b	$60+4+(.LUM3/256/5)
     18  58ce				   .LUM1      SET	.LUM1 + .STEP1
     19  58ce				   .LUM2      SET	.LUM2 + .STEP2
     20  58ce				   .LUM3      SET	.LUM3 + .STEP3
     14  58ce					      REPEND
     15  58cf		       c3		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58d0		       99		      .byte.b	$90+8+(.LUM2/256/5)
     17  58d1		       66		      .byte.b	$60+4+(.LUM3/256/5)
     18  58d1				   .LUM1      SET	.LUM1 + .STEP1
     19  58d1				   .LUM2      SET	.LUM2 + .STEP2
     20  58d1				   .LUM3      SET	.LUM3 + .STEP3
     14  58d1					      REPEND
     15  58d2		       c3		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58d3		       99		      .byte.b	$90+8+(.LUM2/256/5)
     17  58d4		       66		      .byte.b	$60+4+(.LUM3/256/5)
     18  58d4				   .LUM1      SET	.LUM1 + .STEP1
     19  58d4				   .LUM2      SET	.LUM2 + .STEP2
     20  58d4				   .LUM3      SET	.LUM3 + .STEP3
     14  58d4					      REPEND
     15  58d5		       c4		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58d6		       99		      .byte.b	$90+8+(.LUM2/256/5)
     17  58d7		       66		      .byte.b	$60+4+(.LUM3/256/5)
     18  58d7				   .LUM1      SET	.LUM1 + .STEP1
     19  58d7				   .LUM2      SET	.LUM2 + .STEP2
     20  58d7				   .LUM3      SET	.LUM3 + .STEP3
     21  58d8					      REPEND
     13  58d8					      REPEND
     14  58d8					      REPEAT	5
     15  58d8		       c4		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58d9		       99		      .byte.b	$90+8+(.LUM2/256/5)
     17  58da		       67		      .byte.b	$60+4+(.LUM3/256/5)
     18  58da				   .LUM1      SET	.LUM1 + .STEP1
     19  58da				   .LUM2      SET	.LUM2 + .STEP2
     20  58da				   .LUM3      SET	.LUM3 + .STEP3
     14  58da					      REPEND
     15  58db		       c4		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58dc		       99		      .byte.b	$90+8+(.LUM2/256/5)
     17  58dd		       67		      .byte.b	$60+4+(.LUM3/256/5)
     18  58dd				   .LUM1      SET	.LUM1 + .STEP1
     19  58dd				   .LUM2      SET	.LUM2 + .STEP2
     20  58dd				   .LUM3      SET	.LUM3 + .STEP3
     14  58dd					      REPEND
     15  58de		       c5		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58df		       99		      .byte.b	$90+8+(.LUM2/256/5)
     17  58e0		       67		      .byte.b	$60+4+(.LUM3/256/5)
     18  58e0				   .LUM1      SET	.LUM1 + .STEP1
     19  58e0				   .LUM2      SET	.LUM2 + .STEP2
     20  58e0				   .LUM3      SET	.LUM3 + .STEP3
     14  58e0					      REPEND
     15  58e1		       c5		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58e2		       99		      .byte.b	$90+8+(.LUM2/256/5)
     17  58e3		       67		      .byte.b	$60+4+(.LUM3/256/5)
     18  58e3				   .LUM1      SET	.LUM1 + .STEP1
     19  58e3				   .LUM2      SET	.LUM2 + .STEP2
     20  58e3				   .LUM3      SET	.LUM3 + .STEP3
     14  58e3					      REPEND
     15  58e4		       c5		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58e5		       99		      .byte.b	$90+8+(.LUM2/256/5)
     17  58e6		       67		      .byte.b	$60+4+(.LUM3/256/5)
     18  58e6				   .LUM1      SET	.LUM1 + .STEP1
     19  58e6				   .LUM2      SET	.LUM2 + .STEP2
     20  58e6				   .LUM3      SET	.LUM3 + .STEP3
     21  58e7					      REPEND
     13  58e7					      REPEND
     14  58e7					      REPEAT	5
     15  58e7		       c6		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58e8		       9a		      .byte.b	$90+8+(.LUM2/256/5)
     17  58e9		       68		      .byte.b	$60+4+(.LUM3/256/5)
     18  58e9				   .LUM1      SET	.LUM1 + .STEP1
     19  58e9				   .LUM2      SET	.LUM2 + .STEP2
     20  58e9				   .LUM3      SET	.LUM3 + .STEP3
     14  58e9					      REPEND
     15  58ea		       c6		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58eb		       9a		      .byte.b	$90+8+(.LUM2/256/5)
     17  58ec		       68		      .byte.b	$60+4+(.LUM3/256/5)
     18  58ec				   .LUM1      SET	.LUM1 + .STEP1
     19  58ec				   .LUM2      SET	.LUM2 + .STEP2
     20  58ec				   .LUM3      SET	.LUM3 + .STEP3
     14  58ec					      REPEND
     15  58ed		       c6		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58ee		       9a		      .byte.b	$90+8+(.LUM2/256/5)
     17  58ef		       68		      .byte.b	$60+4+(.LUM3/256/5)
     18  58ef				   .LUM1      SET	.LUM1 + .STEP1
     19  58ef				   .LUM2      SET	.LUM2 + .STEP2
     20  58ef				   .LUM3      SET	.LUM3 + .STEP3
     14  58ef					      REPEND
     15  58f0		       c6		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58f1		       9a		      .byte.b	$90+8+(.LUM2/256/5)
     17  58f2		       68		      .byte.b	$60+4+(.LUM3/256/5)
     18  58f2				   .LUM1      SET	.LUM1 + .STEP1
     19  58f2				   .LUM2      SET	.LUM2 + .STEP2
     20  58f2				   .LUM3      SET	.LUM3 + .STEP3
     14  58f2					      REPEND
     15  58f3		       c7		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58f4		       9a		      .byte.b	$90+8+(.LUM2/256/5)
     17  58f5		       68		      .byte.b	$60+4+(.LUM3/256/5)
     18  58f5				   .LUM1      SET	.LUM1 + .STEP1
     19  58f5				   .LUM2      SET	.LUM2 + .STEP2
     20  58f5				   .LUM3      SET	.LUM3 + .STEP3
     21  58f6					      REPEND
     13  58f6					      REPEND
     14  58f6					      REPEAT	5
     15  58f6		       c7		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58f7		       9a		      .byte.b	$90+8+(.LUM2/256/5)
     17  58f8		       69		      .byte.b	$60+4+(.LUM3/256/5)
     18  58f8				   .LUM1      SET	.LUM1 + .STEP1
     19  58f8				   .LUM2      SET	.LUM2 + .STEP2
     20  58f8				   .LUM3      SET	.LUM3 + .STEP3
     14  58f8					      REPEND
     15  58f9		       c7		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58fa		       9a		      .byte.b	$90+8+(.LUM2/256/5)
     17  58fb		       69		      .byte.b	$60+4+(.LUM3/256/5)
     18  58fb				   .LUM1      SET	.LUM1 + .STEP1
     19  58fb				   .LUM2      SET	.LUM2 + .STEP2
     20  58fb				   .LUM3      SET	.LUM3 + .STEP3
     14  58fb					      REPEND
     15  58fc		       c8		      .byte.b	$C0+0+(.LUM1/256/5)
     16  58fd		       9a		      .byte.b	$90+8+(.LUM2/256/5)
     17  58fe		       69		      .byte.b	$60+4+(.LUM3/256/5)
     18  58fe				   .LUM1      SET	.LUM1 + .STEP1
     19  58fe				   .LUM2      SET	.LUM2 + .STEP2
     20  58fe				   .LUM3      SET	.LUM3 + .STEP3
     14  58fe					      REPEND
     15  58ff		       c8		      .byte.b	$C0+0+(.LUM1/256/5)
     16  5900		       9a		      .byte.b	$90+8+(.LUM2/256/5)
     17  5901		       69		      .byte.b	$60+4+(.LUM3/256/5)
     18  5901				   .LUM1      SET	.LUM1 + .STEP1
     19  5901				   .LUM2      SET	.LUM2 + .STEP2
     20  5901				   .LUM3      SET	.LUM3 + .STEP3
     14  5901					      REPEND
     15  5902		       c8		      .byte.b	$C0+0+(.LUM1/256/5)
     16  5903		       9a		      .byte.b	$90+8+(.LUM2/256/5)
     17  5904		       69		      .byte.b	$60+4+(.LUM3/256/5)
     18  5904				   .LUM1      SET	.LUM1 + .STEP1
     19  5904				   .LUM2      SET	.LUM2 + .STEP2
     20  5904				   .LUM3      SET	.LUM3 + .STEP3
     21  5905					      REPEND
     13  5905					      REPEND
     14  5905					      REPEAT	5
     15  5905		       c9		      .byte.b	$C0+0+(.LUM1/256/5)
     16  5906		       9b		      .byte.b	$90+8+(.LUM2/256/5)
     17  5907		       6a		      .byte.b	$60+4+(.LUM3/256/5)
     18  5907				   .LUM1      SET	.LUM1 + .STEP1
     19  5907				   .LUM2      SET	.LUM2 + .STEP2
     20  5907				   .LUM3      SET	.LUM3 + .STEP3
     14  5907					      REPEND
     15  5908		       c9		      .byte.b	$C0+0+(.LUM1/256/5)
     16  5909		       9b		      .byte.b	$90+8+(.LUM2/256/5)
     17  590a		       6a		      .byte.b	$60+4+(.LUM3/256/5)
     18  590a				   .LUM1      SET	.LUM1 + .STEP1
     19  590a				   .LUM2      SET	.LUM2 + .STEP2
     20  590a				   .LUM3      SET	.LUM3 + .STEP3
     14  590a					      REPEND
     15  590b		       c9		      .byte.b	$C0+0+(.LUM1/256/5)
     16  590c		       9b		      .byte.b	$90+8+(.LUM2/256/5)
     17  590d		       6a		      .byte.b	$60+4+(.LUM3/256/5)
     18  590d				   .LUM1      SET	.LUM1 + .STEP1
     19  590d				   .LUM2      SET	.LUM2 + .STEP2
     20  590d				   .LUM3      SET	.LUM3 + .STEP3
     14  590d					      REPEND
     15  590e		       c9		      .byte.b	$C0+0+(.LUM1/256/5)
     16  590f		       9b		      .byte.b	$90+8+(.LUM2/256/5)
     17  5910		       6a		      .byte.b	$60+4+(.LUM3/256/5)
     18  5910				   .LUM1      SET	.LUM1 + .STEP1
     19  5910				   .LUM2      SET	.LUM2 + .STEP2
     20  5910				   .LUM3      SET	.LUM3 + .STEP3
     14  5910					      REPEND
     15  5911		       ca		      .byte.b	$C0+0+(.LUM1/256/5)
     16  5912		       9b		      .byte.b	$90+8+(.LUM2/256/5)
     17  5913		       6a		      .byte.b	$60+4+(.LUM3/256/5)
     18  5913				   .LUM1      SET	.LUM1 + .STEP1
     19  5913				   .LUM2      SET	.LUM2 + .STEP2
     20  5913				   .LUM3      SET	.LUM3 + .STEP3
     21  5914					      REPEND
     13  5914					      REPEND
     14  5914					      REPEAT	5
     15  5914		       ca		      .byte.b	$C0+0+(.LUM1/256/5)
     16  5915		       9b		      .byte.b	$90+8+(.LUM2/256/5)
     17  5916		       6b		      .byte.b	$60+4+(.LUM3/256/5)
     18  5916				   .LUM1      SET	.LUM1 + .STEP1
     19  5916				   .LUM2      SET	.LUM2 + .STEP2
     20  5916				   .LUM3      SET	.LUM3 + .STEP3
     14  5916					      REPEND
     15  5917		       ca		      .byte.b	$C0+0+(.LUM1/256/5)
     16  5918		       9b		      .byte.b	$90+8+(.LUM2/256/5)
     17  5919		       6b		      .byte.b	$60+4+(.LUM3/256/5)
     18  5919				   .LUM1      SET	.LUM1 + .STEP1
     19  5919				   .LUM2      SET	.LUM2 + .STEP2
     20  5919				   .LUM3      SET	.LUM3 + .STEP3
     14  5919					      REPEND
     15  591a		       cb		      .byte.b	$C0+0+(.LUM1/256/5)
     16  591b		       9b		      .byte.b	$90+8+(.LUM2/256/5)
     17  591c		       6b		      .byte.b	$60+4+(.LUM3/256/5)
     18  591c				   .LUM1      SET	.LUM1 + .STEP1
     19  591c				   .LUM2      SET	.LUM2 + .STEP2
     20  591c				   .LUM3      SET	.LUM3 + .STEP3
     14  591c					      REPEND
     15  591d		       cb		      .byte.b	$C0+0+(.LUM1/256/5)
     16  591e		       9b		      .byte.b	$90+8+(.LUM2/256/5)
     17  591f		       6b		      .byte.b	$60+4+(.LUM3/256/5)
     18  591f				   .LUM1      SET	.LUM1 + .STEP1
     19  591f				   .LUM2      SET	.LUM2 + .STEP2
     20  591f				   .LUM3      SET	.LUM3 + .STEP3
     14  591f					      REPEND
     15  5920		       cb		      .byte.b	$C0+0+(.LUM1/256/5)
     16  5921		       9b		      .byte.b	$90+8+(.LUM2/256/5)
     17  5922		       6b		      .byte.b	$60+4+(.LUM3/256/5)
     18  5922				   .LUM1      SET	.LUM1 + .STEP1
     19  5922				   .LUM2      SET	.LUM2 + .STEP2
     20  5922				   .LUM3      SET	.LUM3 + .STEP3
     21  5923					      REPEND
     22  5923					      REPEND
      0  5923				   colr_ntsc  LUMTABLE	$80,$B0,$50,0,8,4
      1  5923
      2  5923
      3  5923
      4  5923
      5  5923				   .LUM1      SET	0
      6  5923				   .LUM2      SET	8
      7  5923				   .LUM3      SET	4
      8  5923
      9  5923		       01 80	   .STEP1     =	256*($C-0)/8
     10  5923		       00 80	   .STEP2     =	256*($C-8)/8
     11  5923		       01 00	   .STEP3     =	256*($C-4)/8
     12  5923
     13  5923					      REPEAT	8
     14  5923					      REPEAT	5
     15  5923		       80		      .byte.b	$80+0+(.LUM1/256/5)
     16  5924		       b8		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5925		       54		      .byte.b	$50+4+(.LUM3/256/5)
     18  5925				   .LUM1      SET	.LUM1 + .STEP1
     19  5925				   .LUM2      SET	.LUM2 + .STEP2
     20  5925				   .LUM3      SET	.LUM3 + .STEP3
     14  5925					      REPEND
     15  5926		       80		      .byte.b	$80+0+(.LUM1/256/5)
     16  5927		       b8		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5928		       54		      .byte.b	$50+4+(.LUM3/256/5)
     18  5928				   .LUM1      SET	.LUM1 + .STEP1
     19  5928				   .LUM2      SET	.LUM2 + .STEP2
     20  5928				   .LUM3      SET	.LUM3 + .STEP3
     14  5928					      REPEND
     15  5929		       80		      .byte.b	$80+0+(.LUM1/256/5)
     16  592a		       b8		      .byte.b	$B0+8+(.LUM2/256/5)
     17  592b		       54		      .byte.b	$50+4+(.LUM3/256/5)
     18  592b				   .LUM1      SET	.LUM1 + .STEP1
     19  592b				   .LUM2      SET	.LUM2 + .STEP2
     20  592b				   .LUM3      SET	.LUM3 + .STEP3
     14  592b					      REPEND
     15  592c		       80		      .byte.b	$80+0+(.LUM1/256/5)
     16  592d		       b8		      .byte.b	$B0+8+(.LUM2/256/5)
     17  592e		       54		      .byte.b	$50+4+(.LUM3/256/5)
     18  592e				   .LUM1      SET	.LUM1 + .STEP1
     19  592e				   .LUM2      SET	.LUM2 + .STEP2
     20  592e				   .LUM3      SET	.LUM3 + .STEP3
     14  592e					      REPEND
     15  592f		       81		      .byte.b	$80+0+(.LUM1/256/5)
     16  5930		       b8		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5931		       54		      .byte.b	$50+4+(.LUM3/256/5)
     18  5931				   .LUM1      SET	.LUM1 + .STEP1
     19  5931				   .LUM2      SET	.LUM2 + .STEP2
     20  5931				   .LUM3      SET	.LUM3 + .STEP3
     21  5932					      REPEND
     13  5932					      REPEND
     14  5932					      REPEAT	5
     15  5932		       81		      .byte.b	$80+0+(.LUM1/256/5)
     16  5933		       b8		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5934		       55		      .byte.b	$50+4+(.LUM3/256/5)
     18  5934				   .LUM1      SET	.LUM1 + .STEP1
     19  5934				   .LUM2      SET	.LUM2 + .STEP2
     20  5934				   .LUM3      SET	.LUM3 + .STEP3
     14  5934					      REPEND
     15  5935		       81		      .byte.b	$80+0+(.LUM1/256/5)
     16  5936		       b8		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5937		       55		      .byte.b	$50+4+(.LUM3/256/5)
     18  5937				   .LUM1      SET	.LUM1 + .STEP1
     19  5937				   .LUM2      SET	.LUM2 + .STEP2
     20  5937				   .LUM3      SET	.LUM3 + .STEP3
     14  5937					      REPEND
     15  5938		       82		      .byte.b	$80+0+(.LUM1/256/5)
     16  5939		       b8		      .byte.b	$B0+8+(.LUM2/256/5)
     17  593a		       55		      .byte.b	$50+4+(.LUM3/256/5)
     18  593a				   .LUM1      SET	.LUM1 + .STEP1
     19  593a				   .LUM2      SET	.LUM2 + .STEP2
     20  593a				   .LUM3      SET	.LUM3 + .STEP3
     14  593a					      REPEND
     15  593b		       82		      .byte.b	$80+0+(.LUM1/256/5)
     16  593c		       b8		      .byte.b	$B0+8+(.LUM2/256/5)
     17  593d		       55		      .byte.b	$50+4+(.LUM3/256/5)
     18  593d				   .LUM1      SET	.LUM1 + .STEP1
     19  593d				   .LUM2      SET	.LUM2 + .STEP2
     20  593d				   .LUM3      SET	.LUM3 + .STEP3
     14  593d					      REPEND
     15  593e		       82		      .byte.b	$80+0+(.LUM1/256/5)
     16  593f		       b8		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5940		       55		      .byte.b	$50+4+(.LUM3/256/5)
     18  5940				   .LUM1      SET	.LUM1 + .STEP1
     19  5940				   .LUM2      SET	.LUM2 + .STEP2
     20  5940				   .LUM3      SET	.LUM3 + .STEP3
     21  5941					      REPEND
     13  5941					      REPEND
     14  5941					      REPEAT	5
     15  5941		       83		      .byte.b	$80+0+(.LUM1/256/5)
     16  5942		       b9		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5943		       56		      .byte.b	$50+4+(.LUM3/256/5)
     18  5943				   .LUM1      SET	.LUM1 + .STEP1
     19  5943				   .LUM2      SET	.LUM2 + .STEP2
     20  5943				   .LUM3      SET	.LUM3 + .STEP3
     14  5943					      REPEND
     15  5944		       83		      .byte.b	$80+0+(.LUM1/256/5)
     16  5945		       b9		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5946		       56		      .byte.b	$50+4+(.LUM3/256/5)
     18  5946				   .LUM1      SET	.LUM1 + .STEP1
     19  5946				   .LUM2      SET	.LUM2 + .STEP2
     20  5946				   .LUM3      SET	.LUM3 + .STEP3
     14  5946					      REPEND
     15  5947		       83		      .byte.b	$80+0+(.LUM1/256/5)
     16  5948		       b9		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5949		       56		      .byte.b	$50+4+(.LUM3/256/5)
     18  5949				   .LUM1      SET	.LUM1 + .STEP1
     19  5949				   .LUM2      SET	.LUM2 + .STEP2
     20  5949				   .LUM3      SET	.LUM3 + .STEP3
     14  5949					      REPEND
     15  594a		       83		      .byte.b	$80+0+(.LUM1/256/5)
     16  594b		       b9		      .byte.b	$B0+8+(.LUM2/256/5)
     17  594c		       56		      .byte.b	$50+4+(.LUM3/256/5)
     18  594c				   .LUM1      SET	.LUM1 + .STEP1
     19  594c				   .LUM2      SET	.LUM2 + .STEP2
     20  594c				   .LUM3      SET	.LUM3 + .STEP3
     14  594c					      REPEND
     15  594d		       84		      .byte.b	$80+0+(.LUM1/256/5)
     16  594e		       b9		      .byte.b	$B0+8+(.LUM2/256/5)
     17  594f		       56		      .byte.b	$50+4+(.LUM3/256/5)
     18  594f				   .LUM1      SET	.LUM1 + .STEP1
     19  594f				   .LUM2      SET	.LUM2 + .STEP2
     20  594f				   .LUM3      SET	.LUM3 + .STEP3
     21  5950					      REPEND
     13  5950					      REPEND
     14  5950					      REPEAT	5
     15  5950		       84		      .byte.b	$80+0+(.LUM1/256/5)
     16  5951		       b9		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5952		       57		      .byte.b	$50+4+(.LUM3/256/5)
     18  5952				   .LUM1      SET	.LUM1 + .STEP1
     19  5952				   .LUM2      SET	.LUM2 + .STEP2
     20  5952				   .LUM3      SET	.LUM3 + .STEP3
     14  5952					      REPEND
     15  5953		       84		      .byte.b	$80+0+(.LUM1/256/5)
     16  5954		       b9		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5955		       57		      .byte.b	$50+4+(.LUM3/256/5)
     18  5955				   .LUM1      SET	.LUM1 + .STEP1
     19  5955				   .LUM2      SET	.LUM2 + .STEP2
     20  5955				   .LUM3      SET	.LUM3 + .STEP3
     14  5955					      REPEND
     15  5956		       85		      .byte.b	$80+0+(.LUM1/256/5)
     16  5957		       b9		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5958		       57		      .byte.b	$50+4+(.LUM3/256/5)
     18  5958				   .LUM1      SET	.LUM1 + .STEP1
     19  5958				   .LUM2      SET	.LUM2 + .STEP2
     20  5958				   .LUM3      SET	.LUM3 + .STEP3
     14  5958					      REPEND
     15  5959		       85		      .byte.b	$80+0+(.LUM1/256/5)
     16  595a		       b9		      .byte.b	$B0+8+(.LUM2/256/5)
     17  595b		       57		      .byte.b	$50+4+(.LUM3/256/5)
     18  595b				   .LUM1      SET	.LUM1 + .STEP1
     19  595b				   .LUM2      SET	.LUM2 + .STEP2
     20  595b				   .LUM3      SET	.LUM3 + .STEP3
     14  595b					      REPEND
     15  595c		       85		      .byte.b	$80+0+(.LUM1/256/5)
     16  595d		       b9		      .byte.b	$B0+8+(.LUM2/256/5)
     17  595e		       57		      .byte.b	$50+4+(.LUM3/256/5)
     18  595e				   .LUM1      SET	.LUM1 + .STEP1
     19  595e				   .LUM2      SET	.LUM2 + .STEP2
     20  595e				   .LUM3      SET	.LUM3 + .STEP3
     21  595f					      REPEND
     13  595f					      REPEND
     14  595f					      REPEAT	5
     15  595f		       86		      .byte.b	$80+0+(.LUM1/256/5)
     16  5960		       ba		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5961		       58		      .byte.b	$50+4+(.LUM3/256/5)
     18  5961				   .LUM1      SET	.LUM1 + .STEP1
     19  5961				   .LUM2      SET	.LUM2 + .STEP2
     20  5961				   .LUM3      SET	.LUM3 + .STEP3
     14  5961					      REPEND
     15  5962		       86		      .byte.b	$80+0+(.LUM1/256/5)
     16  5963		       ba		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5964		       58		      .byte.b	$50+4+(.LUM3/256/5)
     18  5964				   .LUM1      SET	.LUM1 + .STEP1
     19  5964				   .LUM2      SET	.LUM2 + .STEP2
     20  5964				   .LUM3      SET	.LUM3 + .STEP3
     14  5964					      REPEND
     15  5965		       86		      .byte.b	$80+0+(.LUM1/256/5)
     16  5966		       ba		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5967		       58		      .byte.b	$50+4+(.LUM3/256/5)
     18  5967				   .LUM1      SET	.LUM1 + .STEP1
     19  5967				   .LUM2      SET	.LUM2 + .STEP2
     20  5967				   .LUM3      SET	.LUM3 + .STEP3
     14  5967					      REPEND
     15  5968		       86		      .byte.b	$80+0+(.LUM1/256/5)
     16  5969		       ba		      .byte.b	$B0+8+(.LUM2/256/5)
     17  596a		       58		      .byte.b	$50+4+(.LUM3/256/5)
     18  596a				   .LUM1      SET	.LUM1 + .STEP1
     19  596a				   .LUM2      SET	.LUM2 + .STEP2
     20  596a				   .LUM3      SET	.LUM3 + .STEP3
     14  596a					      REPEND
     15  596b		       87		      .byte.b	$80+0+(.LUM1/256/5)
     16  596c		       ba		      .byte.b	$B0+8+(.LUM2/256/5)
     17  596d		       58		      .byte.b	$50+4+(.LUM3/256/5)
     18  596d				   .LUM1      SET	.LUM1 + .STEP1
     19  596d				   .LUM2      SET	.LUM2 + .STEP2
     20  596d				   .LUM3      SET	.LUM3 + .STEP3
     21  596e					      REPEND
     13  596e					      REPEND
     14  596e					      REPEAT	5
     15  596e		       87		      .byte.b	$80+0+(.LUM1/256/5)
     16  596f		       ba		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5970		       59		      .byte.b	$50+4+(.LUM3/256/5)
     18  5970				   .LUM1      SET	.LUM1 + .STEP1
     19  5970				   .LUM2      SET	.LUM2 + .STEP2
     20  5970				   .LUM3      SET	.LUM3 + .STEP3
     14  5970					      REPEND
     15  5971		       87		      .byte.b	$80+0+(.LUM1/256/5)
     16  5972		       ba		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5973		       59		      .byte.b	$50+4+(.LUM3/256/5)
     18  5973				   .LUM1      SET	.LUM1 + .STEP1
     19  5973				   .LUM2      SET	.LUM2 + .STEP2
     20  5973				   .LUM3      SET	.LUM3 + .STEP3
     14  5973					      REPEND
     15  5974		       88		      .byte.b	$80+0+(.LUM1/256/5)
     16  5975		       ba		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5976		       59		      .byte.b	$50+4+(.LUM3/256/5)
     18  5976				   .LUM1      SET	.LUM1 + .STEP1
     19  5976				   .LUM2      SET	.LUM2 + .STEP2
     20  5976				   .LUM3      SET	.LUM3 + .STEP3
     14  5976					      REPEND
     15  5977		       88		      .byte.b	$80+0+(.LUM1/256/5)
     16  5978		       ba		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5979		       59		      .byte.b	$50+4+(.LUM3/256/5)
     18  5979				   .LUM1      SET	.LUM1 + .STEP1
     19  5979				   .LUM2      SET	.LUM2 + .STEP2
     20  5979				   .LUM3      SET	.LUM3 + .STEP3
     14  5979					      REPEND
     15  597a		       88		      .byte.b	$80+0+(.LUM1/256/5)
     16  597b		       ba		      .byte.b	$B0+8+(.LUM2/256/5)
     17  597c		       59		      .byte.b	$50+4+(.LUM3/256/5)
     18  597c				   .LUM1      SET	.LUM1 + .STEP1
     19  597c				   .LUM2      SET	.LUM2 + .STEP2
     20  597c				   .LUM3      SET	.LUM3 + .STEP3
     21  597d					      REPEND
     13  597d					      REPEND
     14  597d					      REPEAT	5
     15  597d		       89		      .byte.b	$80+0+(.LUM1/256/5)
     16  597e		       bb		      .byte.b	$B0+8+(.LUM2/256/5)
     17  597f		       5a		      .byte.b	$50+4+(.LUM3/256/5)
     18  597f				   .LUM1      SET	.LUM1 + .STEP1
     19  597f				   .LUM2      SET	.LUM2 + .STEP2
     20  597f				   .LUM3      SET	.LUM3 + .STEP3
     14  597f					      REPEND
     15  5980		       89		      .byte.b	$80+0+(.LUM1/256/5)
     16  5981		       bb		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5982		       5a		      .byte.b	$50+4+(.LUM3/256/5)
     18  5982				   .LUM1      SET	.LUM1 + .STEP1
     19  5982				   .LUM2      SET	.LUM2 + .STEP2
     20  5982				   .LUM3      SET	.LUM3 + .STEP3
     14  5982					      REPEND
     15  5983		       89		      .byte.b	$80+0+(.LUM1/256/5)
     16  5984		       bb		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5985		       5a		      .byte.b	$50+4+(.LUM3/256/5)
     18  5985				   .LUM1      SET	.LUM1 + .STEP1
     19  5985				   .LUM2      SET	.LUM2 + .STEP2
     20  5985				   .LUM3      SET	.LUM3 + .STEP3
     14  5985					      REPEND
     15  5986		       89		      .byte.b	$80+0+(.LUM1/256/5)
     16  5987		       bb		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5988		       5a		      .byte.b	$50+4+(.LUM3/256/5)
     18  5988				   .LUM1      SET	.LUM1 + .STEP1
     19  5988				   .LUM2      SET	.LUM2 + .STEP2
     20  5988				   .LUM3      SET	.LUM3 + .STEP3
     14  5988					      REPEND
     15  5989		       8a		      .byte.b	$80+0+(.LUM1/256/5)
     16  598a		       bb		      .byte.b	$B0+8+(.LUM2/256/5)
     17  598b		       5a		      .byte.b	$50+4+(.LUM3/256/5)
     18  598b				   .LUM1      SET	.LUM1 + .STEP1
     19  598b				   .LUM2      SET	.LUM2 + .STEP2
     20  598b				   .LUM3      SET	.LUM3 + .STEP3
     21  598c					      REPEND
     13  598c					      REPEND
     14  598c					      REPEAT	5
     15  598c		       8a		      .byte.b	$80+0+(.LUM1/256/5)
     16  598d		       bb		      .byte.b	$B0+8+(.LUM2/256/5)
     17  598e		       5b		      .byte.b	$50+4+(.LUM3/256/5)
     18  598e				   .LUM1      SET	.LUM1 + .STEP1
     19  598e				   .LUM2      SET	.LUM2 + .STEP2
     20  598e				   .LUM3      SET	.LUM3 + .STEP3
     14  598e					      REPEND
     15  598f		       8a		      .byte.b	$80+0+(.LUM1/256/5)
     16  5990		       bb		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5991		       5b		      .byte.b	$50+4+(.LUM3/256/5)
     18  5991				   .LUM1      SET	.LUM1 + .STEP1
     19  5991				   .LUM2      SET	.LUM2 + .STEP2
     20  5991				   .LUM3      SET	.LUM3 + .STEP3
     14  5991					      REPEND
     15  5992		       8b		      .byte.b	$80+0+(.LUM1/256/5)
     16  5993		       bb		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5994		       5b		      .byte.b	$50+4+(.LUM3/256/5)
     18  5994				   .LUM1      SET	.LUM1 + .STEP1
     19  5994				   .LUM2      SET	.LUM2 + .STEP2
     20  5994				   .LUM3      SET	.LUM3 + .STEP3
     14  5994					      REPEND
     15  5995		       8b		      .byte.b	$80+0+(.LUM1/256/5)
     16  5996		       bb		      .byte.b	$B0+8+(.LUM2/256/5)
     17  5997		       5b		      .byte.b	$50+4+(.LUM3/256/5)
     18  5997				   .LUM1      SET	.LUM1 + .STEP1
     19  5997				   .LUM2      SET	.LUM2 + .STEP2
     20  5997				   .LUM3      SET	.LUM3 + .STEP3
     14  5997					      REPEND
     15  5998		       8b		      .byte.b	$80+0+(.LUM1/256/5)
     16  5999		       bb		      .byte.b	$B0+8+(.LUM2/256/5)
     17  599a		       5b		      .byte.b	$50+4+(.LUM3/256/5)
     18  599a				   .LUM1      SET	.LUM1 + .STEP1
     19  599a				   .LUM2      SET	.LUM2 + .STEP2
     20  599a				   .LUM3      SET	.LUM3 + .STEP3
     21  599b					      REPEND
     22  599b					      REPEND
    164  599b
------- FILE titleData.asm LEVEL 3 PASS 4
      0  599b					      include	"titleData.asm"
      1  599b				   COL_0
      2  599b		       c0		      .byte.b	192	;R (39)
      3  599c		       c0		      .byte.b	192	;G
      4  599d		       c0		      .byte.b	192	;B
      5  599e		       e0		      .byte.b	224	;R (38)
      6  599f		       e0		      .byte.b	224	;G
      7  59a0		       e0		      .byte.b	224	;B
      8  59a1		       20		      .byte.b	32	;R (37)
      9  59a2		       e0		      .byte.b	224	;G
     10  59a3		       e0		      .byte.b	224	;B
     11  59a4		       30		      .byte.b	48	;R (36)
     12  59a5		       30		      .byte.b	48	;G
     13  59a6		       30		      .byte.b	48	;B
     14  59a7		       f0		      .byte.b	240	;R (35)
     15  59a8		       10		      .byte.b	16	;G
     16  59a9		       d0		      .byte.b	208	;B
     17  59aa		       f0		      .byte.b	240	;R (34)
     18  59ab		       10		      .byte.b	16	;G
     19  59ac		       d0		      .byte.b	208	;B
     20  59ad		       f0		      .byte.b	240	;R (33)
     21  59ae		       10		      .byte.b	16	;G
     22  59af		       d0		      .byte.b	208	;B
     23  59b0		       f0		      .byte.b	240	;R (32)
     24  59b1		       10		      .byte.b	16	;G
     25  59b2		       d0		      .byte.b	208	;B
     26  59b3		       f0		      .byte.b	240	;R (31)
     27  59b4		       10		      .byte.b	16	;G
     28  59b5		       d0		      .byte.b	208	;B
     29  59b6		       f0		      .byte.b	240	;R (30)
     30  59b7		       10		      .byte.b	16	;G
     31  59b8		       10		      .byte.b	16	;B
     32  59b9		       f0		      .byte.b	240	;R (29)
     33  59ba		       10		      .byte.b	16	;G
     34  59bb		       10		      .byte.b	16	;B
     35  59bc		       f0		      .byte.b	240	;R (28)
     36  59bd		       10		      .byte.b	16	;G
     37  59be		       10		      .byte.b	16	;B
     38  59bf		       f0		      .byte.b	240	;R (27)
     39  59c0		       10		      .byte.b	16	;G
     40  59c1		       10		      .byte.b	16	;B
     41  59c2		       f0		      .byte.b	240	;R (26)
     42  59c3		       10		      .byte.b	16	;G
     43  59c4		       10		      .byte.b	16	;B
     44  59c5		       f0		      .byte.b	240	;R (25)
     45  59c6		       10		      .byte.b	16	;G
     46  59c7		       10		      .byte.b	16	;B
     47  59c8		       f0		      .byte.b	240	;R (24)
     48  59c9		       10		      .byte.b	16	;G
     49  59ca		       10		      .byte.b	16	;B
     50  59cb		       f0		      .byte.b	240	;R (23)
     51  59cc		       10		      .byte.b	16	;G
     52  59cd		       10		      .byte.b	16	;B
     53  59ce		       90		      .byte.b	144	;R (22)
     54  59cf		       70		      .byte.b	112	;G
     55  59d0		       10		      .byte.b	16	;B
     56  59d1		       10		      .byte.b	16	;R (21)
     57  59d2		       f0		      .byte.b	240	;G
     58  59d3		       10		      .byte.b	16	;B
     59  59d4		       90		      .byte.b	144	;R (20)
     60  59d5		       70		      .byte.b	112	;G
     61  59d6		       90		      .byte.b	144	;B
     62  59d7		       90		      .byte.b	144	;R (19)
     63  59d8		       70		      .byte.b	112	;G
     64  59d9		       90		      .byte.b	144	;B
     65  59da		       d0		      .byte.b	208	;R (18)
     66  59db		       30		      .byte.b	48	;G
     67  59dc		       d0		      .byte.b	208	;B
     68  59dd		       d0		      .byte.b	208	;R (17)
     69  59de		       30		      .byte.b	48	;G
     70  59df		       d0		      .byte.b	208	;B
     71  59e0		       50		      .byte.b	80	;R (16)
     72  59e1		       30		      .byte.b	48	;G
     73  59e2		       50		      .byte.b	80	;B
     74  59e3		       50		      .byte.b	80	;R (15)
     75  59e4		       30		      .byte.b	48	;G
     76  59e5		       50		      .byte.b	80	;B
     77  59e6		       50		      .byte.b	80	;R (14)
     78  59e7		       30		      .byte.b	48	;G
     79  59e8		       50		      .byte.b	80	;B
     80  59e9		       50		      .byte.b	80	;R (13)
     81  59ea		       30		      .byte.b	48	;G
     82  59eb		       50		      .byte.b	80	;B
     83  59ec		       d0		      .byte.b	208	;R (12)
     84  59ed		       30		      .byte.b	48	;G
     85  59ee		       d0		      .byte.b	208	;B
     86  59ef		       d0		      .byte.b	208	;R (11)
     87  59f0		       30		      .byte.b	48	;G
     88  59f1		       d0		      .byte.b	208	;B
     89  59f2		       d0		      .byte.b	208	;R (10)
     90  59f3		       30		      .byte.b	48	;G
     91  59f4		       d0		      .byte.b	208	;B
     92  59f5		       d0		      .byte.b	208	;R (9)
     93  59f6		       30		      .byte.b	48	;G
     94  59f7		       d0		      .byte.b	208	;B
     95  59f8		       90		      .byte.b	144	;R (8)
     96  59f9		       70		      .byte.b	112	;G
     97  59fa		       90		      .byte.b	144	;B
     98  59fb		       90		      .byte.b	144	;R (7)
     99  59fc		       70		      .byte.b	112	;G
    100  59fd		       90		      .byte.b	144	;B
    101  59fe		       10		      .byte.b	16	;R (6)
    102  59ff		       f0		      .byte.b	240	;G
    103  5a00		       10		      .byte.b	16	;B
    104  5a01		       10		      .byte.b	16	;R (5)
    105  5a02		       f0		      .byte.b	240	;G
    106  5a03		       10		      .byte.b	16	;B
    107  5a04		       10		      .byte.b	16	;R (4)
    108  5a05		       f0		      .byte.b	240	;G
    109  5a06		       10		      .byte.b	16	;B
    110  5a07		       20		      .byte.b	32	;R (3)
    111  5a08		       e0		      .byte.b	224	;G
    112  5a09		       20		      .byte.b	32	;B
    113  5a0a		       20		      .byte.b	32	;R (2)
    114  5a0b		       e0		      .byte.b	224	;G
    115  5a0c		       20		      .byte.b	32	;B
    116  5a0d		       e0		      .byte.b	224	;R (1)
    117  5a0e		       e0		      .byte.b	224	;G
    118  5a0f		       e0		      .byte.b	224	;B
    119  5a10		       c0		      .byte.b	192	;R (0)
    120  5a11		       c0		      .byte.b	192	;G
    121  5a12		       c0		      .byte.b	192	;B
    122  5a13				   COL_1
    123  5a13		       ff		      .byte.b	255	;R (39)
    124  5a14		       ff		      .byte.b	255	;G
    125  5a15		       ff		      .byte.b	255	;B
    126  5a16		       ff		      .byte.b	255	;R (38)
    127  5a17		       ff		      .byte.b	255	;G
    128  5a18		       ff		      .byte.b	255	;B
    129  5a19		       00		      .byte.b	0	;R (37)
    130  5a1a		       ff		      .byte.b	255	;G
    131  5a1b		       ff		      .byte.b	255	;B
    132  5a1c		       00		      .byte.b	0	;R (36)
    133  5a1d		       f3		      .byte.b	243	;G
    134  5a1e		       f3		      .byte.b	243	;B
    135  5a1f		       0c		      .byte.b	12	;R (35)
    136  5a20		       71		      .byte.b	113	;G
    137  5a21		       7d		      .byte.b	125	;B
    138  5a22		       0c		      .byte.b	12	;R (34)
    139  5a23		       71		      .byte.b	113	;G
    140  5a24		       7d		      .byte.b	125	;B
    141  5a25		       9c		      .byte.b	156	;R (33)
    142  5a26		       21		      .byte.b	33	;G
    143  5a27		       bd		      .byte.b	189	;B
    144  5a28		       9c		      .byte.b	156	;R (32)
    145  5a29		       21		      .byte.b	33	;G
    146  5a2a		       bd		      .byte.b	189	;B
    147  5a2b		       9e		      .byte.b	158	;R (31)
    148  5a2c		       20		      .byte.b	32	;G
    149  5a2d		       be		      .byte.b	190	;B
    150  5a2e		       de		      .byte.b	222	;R (30)
    151  5a2f		       00		      .byte.b	0	;G
    152  5a30		       de		      .byte.b	222	;B
    153  5a31		       d2		      .byte.b	210	;R (29)
    154  5a32		       00		      .byte.b	0	;G
    155  5a33		       d2		      .byte.b	210	;B
    156  5a34		       d6		      .byte.b	214	;R (28)
    157  5a35		       00		      .byte.b	0	;G
    158  5a36		       d2		      .byte.b	210	;B
    159  5a37		       d6		      .byte.b	214	;R (27)
    160  5a38		       00		      .byte.b	0	;G
    161  5a39		       d2		      .byte.b	210	;B
    162  5a3a		       d6		      .byte.b	214	;R (26)
    163  5a3b		       00		      .byte.b	0	;G
    164  5a3c		       d2		      .byte.b	210	;B
    165  5a3d		       d6		      .byte.b	214	;R (25)
    166  5a3e		       00		      .byte.b	0	;G
    167  5a3f		       d2		      .byte.b	210	;B
    168  5a40		       d6		      .byte.b	214	;R (24)
    169  5a41		       00		      .byte.b	0	;G
    170  5a42		       d2		      .byte.b	210	;B
    171  5a43		       d6		      .byte.b	214	;R (23)
    172  5a44		       00		      .byte.b	0	;G
    173  5a45		       d2		      .byte.b	210	;B
    174  5a46		       d6		      .byte.b	214	;R (22)
    175  5a47		       00		      .byte.b	0	;G
    176  5a48		       d2		      .byte.b	210	;B
    177  5a49		       d6		      .byte.b	214	;R (21)
    178  5a4a		       00		      .byte.b	0	;G
    179  5a4b		       d2		      .byte.b	210	;B
    180  5a4c		       d6		      .byte.b	214	;R (20)
    181  5a4d		       00		      .byte.b	0	;G
    182  5a4e		       d2		      .byte.b	210	;B
    183  5a4f		       d6		      .byte.b	214	;R (19)
    184  5a50		       00		      .byte.b	0	;G
    185  5a51		       d2		      .byte.b	210	;B
    186  5a52		       96		      .byte.b	150	;R (18)
    187  5a53		       20		      .byte.b	32	;G
    188  5a54		       92		      .byte.b	146	;B
    189  5a55		       12		      .byte.b	18	;R (17)
    190  5a56		       64		      .byte.b	100	;G
    191  5a57		       12		      .byte.b	18	;B
    192  5a58		       12		      .byte.b	18	;R (16)
    193  5a59		       e4		      .byte.b	228	;G
    194  5a5a		       12		      .byte.b	18	;B
    195  5a5b		       12		      .byte.b	18	;R (15)
    196  5a5c		       e4		      .byte.b	228	;G
    197  5a5d		       12		      .byte.b	18	;B
    198  5a5e		       12		      .byte.b	18	;R (14)
    199  5a5f		       e4		      .byte.b	228	;G
    200  5a60		       12		      .byte.b	18	;B
    201  5a61		       12		      .byte.b	18	;R (13)
    202  5a62		       e4		      .byte.b	228	;G
    203  5a63		       12		      .byte.b	18	;B
    204  5a64		       12		      .byte.b	18	;R (12)
    205  5a65		       64		      .byte.b	100	;G
    206  5a66		       12		      .byte.b	18	;B
    207  5a67		       12		      .byte.b	18	;R (11)
    208  5a68		       64		      .byte.b	100	;G
    209  5a69		       12		      .byte.b	18	;B
    210  5a6a		       12		      .byte.b	18	;R (10)
    211  5a6b		       64		      .byte.b	100	;G
    212  5a6c		       12		      .byte.b	18	;B
    213  5a6d		       9a		      .byte.b	154	;R (9)
    214  5a6e		       20		      .byte.b	32	;G
    215  5a6f		       9a		      .byte.b	154	;B
    216  5a70		       da		      .byte.b	218	;R (8)
    217  5a71		       00		      .byte.b	0	;G
    218  5a72		       da		      .byte.b	218	;B
    219  5a73		       fe		      .byte.b	254	;R (7)
    220  5a74		       00		      .byte.b	0	;G
    221  5a75		       fe		      .byte.b	254	;B
    222  5a76		       ee		      .byte.b	238	;R (6)
    223  5a77		       00		      .byte.b	0	;G
    224  5a78		       ee		      .byte.b	238	;B
    225  5a79		       6e		      .byte.b	110	;R (5)
    226  5a7a		       80		      .byte.b	128	;G
    227  5a7b		       6e		      .byte.b	110	;B
    228  5a7c		       24		      .byte.b	36	;R (4)
    229  5a7d		       c9		      .byte.b	201	;G
    230  5a7e		       24		      .byte.b	36	;B
    231  5a7f		       00		      .byte.b	0	;R (3)
    232  5a80		       ff		      .byte.b	255	;G
    233  5a81		       00		      .byte.b	0	;B
    234  5a82		       00		      .byte.b	0	;R (2)
    235  5a83		       ff		      .byte.b	255	;G
    236  5a84		       00		      .byte.b	0	;B
    237  5a85		       ff		      .byte.b	255	;R (1)
    238  5a86		       ff		      .byte.b	255	;G
    239  5a87		       ff		      .byte.b	255	;B
    240  5a88		       ff		      .byte.b	255	;R (0)
    241  5a89		       ff		      .byte.b	255	;G
    242  5a8a		       ff		      .byte.b	255	;B
    243  5a8b				   COL_2
    244  5a8b		       ff		      .byte.b	255	;R (39)
    245  5a8c		       ff		      .byte.b	255	;G
    246  5a8d		       ff		      .byte.b	255	;B
    247  5a8e		       ff		      .byte.b	255	;R (38)
    248  5a8f		       ff		      .byte.b	255	;G
    249  5a90		       ff		      .byte.b	255	;B
    250  5a91		       00		      .byte.b	0	;R (37)
    251  5a92		       ff		      .byte.b	255	;G
    252  5a93		       ff		      .byte.b	255	;B
    253  5a94		       00		      .byte.b	0	;R (36)
    254  5a95		       26		      .byte.b	38	;G
    255  5a96		       26		      .byte.b	38	;B
    256  5a97		       d9		      .byte.b	217	;R (35)
    257  5a98		       04		      .byte.b	4	;G
    258  5a99		       dd		      .byte.b	221	;B
    259  5a9a		       d9		      .byte.b	217	;R (34)
    260  5a9b		       04		      .byte.b	4	;G
    261  5a9c		       dd		      .byte.b	221	;B
    262  5a9d		       e9		      .byte.b	233	;R (33)
    263  5a9e		       04		      .byte.b	4	;G
    264  5a9f		       ed		      .byte.b	237	;B
    265  5aa0		       e9		      .byte.b	233	;R (32)
    266  5aa1		       04		      .byte.b	4	;G
    267  5aa2		       ed		      .byte.b	237	;B
    268  5aa3		       e9		      .byte.b	233	;R (31)
    269  5aa4		       04		      .byte.b	4	;G
    270  5aa5		       ed		      .byte.b	237	;B
    271  5aa6		       ed		      .byte.b	237	;R (30)
    272  5aa7		       00		      .byte.b	0	;G
    273  5aa8		       ed		      .byte.b	237	;B
    274  5aa9		       2f		      .byte.b	47	;R (29)
    275  5aaa		       80		      .byte.b	128	;G
    276  5aab		       af		      .byte.b	175	;B
    277  5aac		       2f		      .byte.b	47	;R (28)
    278  5aad		       80		      .byte.b	128	;G
    279  5aae		       af		      .byte.b	175	;B
    280  5aaf		       2f		      .byte.b	47	;R (27)
    281  5ab0		       80		      .byte.b	128	;G
    282  5ab1		       af		      .byte.b	175	;B
    283  5ab2		       27		      .byte.b	39	;R (26)
    284  5ab3		       90		      .byte.b	144	;G
    285  5ab4		       b7		      .byte.b	183	;B
    286  5ab5		       27		      .byte.b	39	;R (25)
    287  5ab6		       90		      .byte.b	144	;G
    288  5ab7		       b7		      .byte.b	183	;B
    289  5ab8		       27		      .byte.b	39	;R (24)
    290  5ab9		       90		      .byte.b	144	;G
    291  5aba		       b7		      .byte.b	183	;B
    292  5abb		       3b		      .byte.b	59	;R (23)
    293  5abc		       80		      .byte.b	128	;G
    294  5abd		       a3		      .byte.b	163	;B
    295  5abe		       3b		      .byte.b	59	;R (22)
    296  5abf		       80		      .byte.b	128	;G
    297  5ac0		       a3		      .byte.b	163	;B
    298  5ac1		       b7		      .byte.b	183	;R (21)
    299  5ac2		       00		      .byte.b	0	;G
    300  5ac3		       27		      .byte.b	39	;B
    301  5ac4		       b7		      .byte.b	183	;R (20)
    302  5ac5		       00		      .byte.b	0	;G
    303  5ac6		       27		      .byte.b	39	;B
    304  5ac7		       b7		      .byte.b	183	;R (19)
    305  5ac8		       00		      .byte.b	0	;G
    306  5ac9		       27		      .byte.b	39	;B
    307  5aca		       b7		      .byte.b	183	;R (18)
    308  5acb		       00		      .byte.b	0	;G
    309  5acc		       27		      .byte.b	39	;B
    310  5acd		       af		      .byte.b	175	;R (17)
    311  5ace		       00		      .byte.b	0	;G
    312  5acf		       2f		      .byte.b	47	;B
    313  5ad0		       af		      .byte.b	175	;R (16)
    314  5ad1		       00		      .byte.b	0	;G
    315  5ad2		       2f		      .byte.b	47	;B
    316  5ad3		       ad		      .byte.b	173	;R (15)
    317  5ad4		       00		      .byte.b	0	;G
    318  5ad5		       2d		      .byte.b	45	;B
    319  5ad6		       ad		      .byte.b	173	;R (14)
    320  5ad7		       00		      .byte.b	0	;G
    321  5ad8		       2d		      .byte.b	45	;B
    322  5ad9		       ad		      .byte.b	173	;R (13)
    323  5ada		       00		      .byte.b	0	;G
    324  5adb		       2d		      .byte.b	45	;B
    325  5adc		       a9		      .byte.b	169	;R (12)
    326  5add		       04		      .byte.b	4	;G
    327  5ade		       29		      .byte.b	41	;B
    328  5adf		       a9		      .byte.b	169	;R (11)
    329  5ae0		       04		      .byte.b	4	;G
    330  5ae1		       29		      .byte.b	41	;B
    331  5ae2		       a9		      .byte.b	169	;R (10)
    332  5ae3		       04		      .byte.b	4	;G
    333  5ae4		       29		      .byte.b	41	;B
    334  5ae5		       69		      .byte.b	105	;R (9)
    335  5ae6		       04		      .byte.b	4	;G
    336  5ae7		       69		      .byte.b	105	;B
    337  5ae8		       79		      .byte.b	121	;R (8)
    338  5ae9		       04		      .byte.b	4	;G
    339  5aea		       79		      .byte.b	121	;B
    340  5aeb		       f9		      .byte.b	249	;R (7)
    341  5aec		       04		      .byte.b	4	;G
    342  5aed		       f9		      .byte.b	249	;B
    343  5aee		       d9		      .byte.b	217	;R (6)
    344  5aef		       04		      .byte.b	4	;G
    345  5af0		       d9		      .byte.b	217	;B
    346  5af1		       d9		      .byte.b	217	;R (5)
    347  5af2		       04		      .byte.b	4	;G
    348  5af3		       d9		      .byte.b	217	;B
    349  5af4		       99		      .byte.b	153	;R (4)
    350  5af5		       44		      .byte.b	68	;G
    351  5af6		       99		      .byte.b	153	;B
    352  5af7		       00		      .byte.b	0	;R (3)
    353  5af8		       ff		      .byte.b	255	;G
    354  5af9		       00		      .byte.b	0	;B
    355  5afa		       00		      .byte.b	0	;R (2)
    356  5afb		       ff		      .byte.b	255	;G
    357  5afc		       00		      .byte.b	0	;B
    358  5afd		       ff		      .byte.b	255	;R (1)
    359  5afe		       ff		      .byte.b	255	;G
    360  5aff		       ff		      .byte.b	255	;B
    361  5b00		       ff		      .byte.b	255	;R (0)
    362  5b01		       ff		      .byte.b	255	;G
    363  5b02		       ff		      .byte.b	255	;B
    364  5b03				   COL_3
    365  5b03		       f0		      .byte.b	240	;R (39)
    366  5b04		       f0		      .byte.b	240	;G
    367  5b05		       f0		      .byte.b	240	;B
    368  5b06		       f0		      .byte.b	240	;R (38)
    369  5b07		       f0		      .byte.b	240	;G
    370  5b08		       f0		      .byte.b	240	;B
    371  5b09		       00		      .byte.b	0	;R (37)
    372  5b0a		       f0		      .byte.b	240	;G
    373  5b0b		       f0		      .byte.b	240	;B
    374  5b0c		       00		      .byte.b	0	;R (36)
    375  5b0d		       30		      .byte.b	48	;G
    376  5b0e		       30		      .byte.b	48	;B
    377  5b0f		       c0		      .byte.b	192	;R (35)
    378  5b10		       e0		      .byte.b	224	;G
    379  5b11		       20		      .byte.b	32	;B
    380  5b12		       c0		      .byte.b	192	;R (34)
    381  5b13		       e0		      .byte.b	224	;G
    382  5b14		       20		      .byte.b	32	;B
    383  5b15		       c0		      .byte.b	192	;R (33)
    384  5b16		       e0		      .byte.b	224	;G
    385  5b17		       20		      .byte.b	32	;B
    386  5b18		       c0		      .byte.b	192	;R (32)
    387  5b19		       e0		      .byte.b	224	;G
    388  5b1a		       20		      .byte.b	32	;B
    389  5b1b		       d0		      .byte.b	208	;R (31)
    390  5b1c		       c0		      .byte.b	192	;G
    391  5b1d		       10		      .byte.b	16	;B
    392  5b1e		       50		      .byte.b	80	;R (30)
    393  5b1f		       40		      .byte.b	64	;G
    394  5b20		       10		      .byte.b	16	;B
    395  5b21		       50		      .byte.b	80	;R (29)
    396  5b22		       40		      .byte.b	64	;G
    397  5b23		       10		      .byte.b	16	;B
    398  5b24		       50		      .byte.b	80	;R (28)
    399  5b25		       40		      .byte.b	64	;G
    400  5b26		       10		      .byte.b	16	;B
    401  5b27		       50		      .byte.b	80	;R (27)
    402  5b28		       40		      .byte.b	64	;G
    403  5b29		       10		      .byte.b	16	;B
    404  5b2a		       50		      .byte.b	80	;R (26)
    405  5b2b		       40		      .byte.b	64	;G
    406  5b2c		       10		      .byte.b	16	;B
    407  5b2d		       50		      .byte.b	80	;R (25)
    408  5b2e		       40		      .byte.b	64	;G
    409  5b2f		       10		      .byte.b	16	;B
    410  5b30		       50		      .byte.b	80	;R (24)
    411  5b31		       40		      .byte.b	64	;G
    412  5b32		       10		      .byte.b	16	;B
    413  5b33		       d0		      .byte.b	208	;R (23)
    414  5b34		       c0		      .byte.b	192	;G
    415  5b35		       10		      .byte.b	16	;B
    416  5b36		       d0		      .byte.b	208	;R (22)
    417  5b37		       c0		      .byte.b	192	;G
    418  5b38		       10		      .byte.b	16	;B
    419  5b39		       d0		      .byte.b	208	;R (21)
    420  5b3a		       c0		      .byte.b	192	;G
    421  5b3b		       10		      .byte.b	16	;B
    422  5b3c		       d0		      .byte.b	208	;R (20)
    423  5b3d		       c0		      .byte.b	192	;G
    424  5b3e		       10		      .byte.b	16	;B
    425  5b3f		       d0		      .byte.b	208	;R (19)
    426  5b40		       c0		      .byte.b	192	;G
    427  5b41		       10		      .byte.b	16	;B
    428  5b42		       d0		      .byte.b	208	;R (18)
    429  5b43		       c0		      .byte.b	192	;G
    430  5b44		       10		      .byte.b	16	;B
    431  5b45		       50		      .byte.b	80	;R (17)
    432  5b46		       40		      .byte.b	64	;G
    433  5b47		       10		      .byte.b	16	;B
    434  5b48		       50		      .byte.b	80	;R (16)
    435  5b49		       40		      .byte.b	64	;G
    436  5b4a		       10		      .byte.b	16	;B
    437  5b4b		       50		      .byte.b	80	;R (15)
    438  5b4c		       40		      .byte.b	64	;G
    439  5b4d		       10		      .byte.b	16	;B
    440  5b4e		       50		      .byte.b	80	;R (14)
    441  5b4f		       40		      .byte.b	64	;G
    442  5b50		       10		      .byte.b	16	;B
    443  5b51		       50		      .byte.b	80	;R (13)
    444  5b52		       40		      .byte.b	64	;G
    445  5b53		       10		      .byte.b	16	;B
    446  5b54		       50		      .byte.b	80	;R (12)
    447  5b55		       40		      .byte.b	64	;G
    448  5b56		       10		      .byte.b	16	;B
    449  5b57		       50		      .byte.b	80	;R (11)
    450  5b58		       40		      .byte.b	64	;G
    451  5b59		       10		      .byte.b	16	;B
    452  5b5a		       50		      .byte.b	80	;R (10)
    453  5b5b		       40		      .byte.b	64	;G
    454  5b5c		       10		      .byte.b	16	;B
    455  5b5d		       50		      .byte.b	80	;R (9)
    456  5b5e		       40		      .byte.b	64	;G
    457  5b5f		       10		      .byte.b	16	;B
    458  5b60		       d0		      .byte.b	208	;R (8)
    459  5b61		       c0		      .byte.b	192	;G
    460  5b62		       10		      .byte.b	16	;B
    461  5b63		       d0		      .byte.b	208	;R (7)
    462  5b64		       c0		      .byte.b	192	;G
    463  5b65		       10		      .byte.b	16	;B
    464  5b66		       d0		      .byte.b	208	;R (6)
    465  5b67		       c0		      .byte.b	192	;G
    466  5b68		       10		      .byte.b	16	;B
    467  5b69		       d0		      .byte.b	208	;R (5)
    468  5b6a		       c0		      .byte.b	192	;G
    469  5b6b		       10		      .byte.b	16	;B
    470  5b6c		       c0		      .byte.b	192	;R (4)
    471  5b6d		       e0		      .byte.b	224	;G
    472  5b6e		       00		      .byte.b	0	;B
    473  5b6f		       00		      .byte.b	0	;R (3)
    474  5b70		       f0		      .byte.b	240	;G
    475  5b71		       00		      .byte.b	0	;B
    476  5b72		       00		      .byte.b	0	;R (2)
    477  5b73		       f0		      .byte.b	240	;G
    478  5b74		       00		      .byte.b	0	;B
    479  5b75		       f0		      .byte.b	240	;R (1)
    480  5b76		       f0		      .byte.b	240	;G
    481  5b77		       f0		      .byte.b	240	;B
    482  5b78		       f0		      .byte.b	240	;R (0)
    483  5b79		       f0		      .byte.b	240	;G
    484  5b7a		       f0		      .byte.b	240	;B
    485  5b7b				   COL_4
    486  5b7b		       ff		      .byte.b	255	;R (39)
    487  5b7c		       ff		      .byte.b	255	;G
    488  5b7d		       ff		      .byte.b	255	;B
    489  5b7e		       ff		      .byte.b	255	;R (38)
    490  5b7f		       ff		      .byte.b	255	;G
    491  5b80		       ff		      .byte.b	255	;B
    492  5b81		       00		      .byte.b	0	;R (37)
    493  5b82		       ff		      .byte.b	255	;G
    494  5b83		       ff		      .byte.b	255	;B
    495  5b84		       00		      .byte.b	0	;R (36)
    496  5b85		       79		      .byte.b	121	;G
    497  5b86		       79		      .byte.b	121	;B
    498  5b87		       86		      .byte.b	134	;R (35)
    499  5b88		       be		      .byte.b	190	;G
    500  5b89		       38		      .byte.b	56	;B
    501  5b8a		       86		      .byte.b	134	;R (34)
    502  5b8b		       be		      .byte.b	190	;G
    503  5b8c		       38		      .byte.b	56	;B
    504  5b8d		       ce		      .byte.b	206	;R (33)
    505  5b8e		       de		      .byte.b	222	;G
    506  5b8f		       10		      .byte.b	16	;B
    507  5b90		       ee		      .byte.b	238	;R (32)
    508  5b91		       ee		      .byte.b	238	;G
    509  5b92		       00		      .byte.b	0	;B
    510  5b93		       ef		      .byte.b	239	;R (31)
    511  5b94		       ef		      .byte.b	239	;G
    512  5b95		       00		      .byte.b	0	;B
    513  5b96		       6f		      .byte.b	111	;R (30)
    514  5b97		       ef		      .byte.b	239	;G
    515  5b98		       80		      .byte.b	128	;B
    516  5b99		       29		      .byte.b	41	;R (29)
    517  5b9a		       e9		      .byte.b	233	;G
    518  5b9b		       c2		      .byte.b	194	;B
    519  5b9c		       29		      .byte.b	41	;R (28)
    520  5b9d		       e9		      .byte.b	233	;G
    521  5b9e		       c2		      .byte.b	194	;B
    522  5b9f		       29		      .byte.b	41	;R (27)
    523  5ba0		       e9		      .byte.b	233	;G
    524  5ba1		       c2		      .byte.b	194	;B
    525  5ba2		       29		      .byte.b	41	;R (26)
    526  5ba3		       e9		      .byte.b	233	;G
    527  5ba4		       c2		      .byte.b	194	;B
    528  5ba5		       69		      .byte.b	105	;R (25)
    529  5ba6		       e9		      .byte.b	233	;G
    530  5ba7		       82		      .byte.b	130	;B
    531  5ba8		       69		      .byte.b	105	;R (24)
    532  5ba9		       e9		      .byte.b	233	;G
    533  5baa		       82		      .byte.b	130	;B
    534  5bab		       69		      .byte.b	105	;R (23)
    535  5bac		       69		      .byte.b	105	;G
    536  5bad		       02		      .byte.b	2	;B
    537  5bae		       e9		      .byte.b	233	;R (22)
    538  5baf		       e9		      .byte.b	233	;G
    539  5bb0		       02		      .byte.b	2	;B
    540  5bb1		       c9		      .byte.b	201	;R (21)
    541  5bb2		       c9		      .byte.b	201	;G
    542  5bb3		       12		      .byte.b	18	;B
    543  5bb4		       c9		      .byte.b	201	;R (20)
    544  5bb5		       c9		      .byte.b	201	;G
    545  5bb6		       12		      .byte.b	18	;B
    546  5bb7		       c9		      .byte.b	201	;R (19)
    547  5bb8		       c9		      .byte.b	201	;G
    548  5bb9		       12		      .byte.b	18	;B
    549  5bba		       49		      .byte.b	73	;R (18)
    550  5bbb		       49		      .byte.b	73	;G
    551  5bbc		       12		      .byte.b	18	;B
    552  5bbd		       e9		      .byte.b	233	;R (17)
    553  5bbe		       29		      .byte.b	41	;G
    554  5bbf		       02		      .byte.b	2	;B
    555  5bc0		       e9		      .byte.b	233	;R (16)
    556  5bc1		       29		      .byte.b	41	;G
    557  5bc2		       02		      .byte.b	2	;B
    558  5bc3		       e9		      .byte.b	233	;R (15)
    559  5bc4		       29		      .byte.b	41	;G
    560  5bc5		       02		      .byte.b	2	;B
    561  5bc6		       e9		      .byte.b	233	;R (14)
    562  5bc7		       29		      .byte.b	41	;G
    563  5bc8		       02		      .byte.b	2	;B
    564  5bc9		       e9		      .byte.b	233	;R (13)
    565  5bca		       29		      .byte.b	41	;G
    566  5bcb		       02		      .byte.b	2	;B
    567  5bcc		       e9		      .byte.b	233	;R (12)
    568  5bcd		       29		      .byte.b	41	;G
    569  5bce		       02		      .byte.b	2	;B
    570  5bcf		       e9		      .byte.b	233	;R (11)
    571  5bd0		       69		      .byte.b	105	;G
    572  5bd1		       02		      .byte.b	2	;B
    573  5bd2		       e9		      .byte.b	233	;R (10)
    574  5bd3		       69		      .byte.b	105	;G
    575  5bd4		       02		      .byte.b	2	;B
    576  5bd5		       6d		      .byte.b	109	;R (9)
    577  5bd6		       6d		      .byte.b	109	;G
    578  5bd7		       00		      .byte.b	0	;B
    579  5bd8		       dd		      .byte.b	221	;R (8)
    580  5bd9		       cd		      .byte.b	205	;G
    581  5bda		       00		      .byte.b	0	;B
    582  5bdb		       df		      .byte.b	223	;R (7)
    583  5bdc		       cf		      .byte.b	207	;G
    584  5bdd		       00		      .byte.b	0	;B
    585  5bde		       df		      .byte.b	223	;R (6)
    586  5bdf		       c7		      .byte.b	199	;G
    587  5be0		       00		      .byte.b	0	;B
    588  5be1		       9f		      .byte.b	159	;R (5)
    589  5be2		       87		      .byte.b	135	;G
    590  5be3		       00		      .byte.b	0	;B
    591  5be4		       be		      .byte.b	190	;R (4)
    592  5be5		       82		      .byte.b	130	;G
    593  5be6		       00		      .byte.b	0	;B
    594  5be7		       3f		      .byte.b	63	;R (3)
    595  5be8		       c0		      .byte.b	192	;G
    596  5be9		       00		      .byte.b	0	;B
    597  5bea		       1f		      .byte.b	31	;R (2)
    598  5beb		       e0		      .byte.b	224	;G
    599  5bec		       00		      .byte.b	0	;B
    600  5bed		       ff		      .byte.b	255	;R (1)
    601  5bee		       ff		      .byte.b	255	;G
    602  5bef		       ff		      .byte.b	255	;B
    603  5bf0		       ff		      .byte.b	255	;R (0)
    604  5bf1		       ff		      .byte.b	255	;G
    605  5bf2		       ff		      .byte.b	255	;B
    606  5bf3				   COL_5
    607  5bf3		       3f		      .byte.b	63	;R (39)
    608  5bf4		       3f		      .byte.b	63	;G
    609  5bf5		       3f		      .byte.b	63	;B
    610  5bf6		       7f		      .byte.b	127	;R (38)
    611  5bf7		       7f		      .byte.b	127	;G
    612  5bf8		       7f		      .byte.b	127	;B
    613  5bf9		       40		      .byte.b	64	;R (37)
    614  5bfa		       7f		      .byte.b	127	;G
    615  5bfb		       7f		      .byte.b	127	;B
    616  5bfc		       c0		      .byte.b	192	;R (36)
    617  5bfd		       f3		      .byte.b	243	;G
    618  5bfe		       f3		      .byte.b	243	;B
    619  5bff		       8c		      .byte.b	140	;R (35)
    620  5c00		       ef		      .byte.b	239	;G
    621  5c01		       e3		      .byte.b	227	;B
    622  5c02		       8c		      .byte.b	140	;R (34)
    623  5c03		       ef		      .byte.b	239	;G
    624  5c04		       e3		      .byte.b	227	;B
    625  5c05		       8e		      .byte.b	142	;R (33)
    626  5c06		       ef		      .byte.b	239	;G
    627  5c07		       e1		      .byte.b	225	;B
    628  5c08		       8e		      .byte.b	142	;R (32)
    629  5c09		       ef		      .byte.b	239	;G
    630  5c0a		       e1		      .byte.b	225	;B
    631  5c0b		       9e		      .byte.b	158	;R (31)
    632  5c0c		       9e		      .byte.b	158	;G
    633  5c0d		       c0		      .byte.b	192	;B
    634  5c0e		       9e		      .byte.b	158	;R (30)
    635  5c0f		       9e		      .byte.b	158	;G
    636  5c10		       c0		      .byte.b	192	;B
    637  5c11		       92		      .byte.b	146	;R (29)
    638  5c12		       92		      .byte.b	146	;G
    639  5c13		       c8		      .byte.b	200	;B
    640  5c14		       92		      .byte.b	146	;R (28)
    641  5c15		       92		      .byte.b	146	;G
    642  5c16		       c8		      .byte.b	200	;B
    643  5c17		       92		      .byte.b	146	;R (27)
    644  5c18		       92		      .byte.b	146	;G
    645  5c19		       c8		      .byte.b	200	;B
    646  5c1a		       92		      .byte.b	146	;R (26)
    647  5c1b		       92		      .byte.b	146	;G
    648  5c1c		       c8		      .byte.b	200	;B
    649  5c1d		       92		      .byte.b	146	;R (25)
    650  5c1e		       92		      .byte.b	146	;G
    651  5c1f		       c8		      .byte.b	200	;B
    652  5c20		       92		      .byte.b	146	;R (24)
    653  5c21		       92		      .byte.b	146	;G
    654  5c22		       c8		      .byte.b	200	;B
    655  5c23		       92		      .byte.b	146	;R (23)
    656  5c24		       92		      .byte.b	146	;G
    657  5c25		       c8		      .byte.b	200	;B
    658  5c26		       92		      .byte.b	146	;R (22)
    659  5c27		       92		      .byte.b	146	;G
    660  5c28		       c8		      .byte.b	200	;B
    661  5c29		       92		      .byte.b	146	;R (21)
    662  5c2a		       92		      .byte.b	146	;G
    663  5c2b		       c8		      .byte.b	200	;B
    664  5c2c		       92		      .byte.b	146	;R (20)
    665  5c2d		       92		      .byte.b	146	;G
    666  5c2e		       c8		      .byte.b	200	;B
    667  5c2f		       92		      .byte.b	146	;R (19)
    668  5c30		       92		      .byte.b	146	;G
    669  5c31		       c8		      .byte.b	200	;B
    670  5c32		       92		      .byte.b	146	;R (18)
    671  5c33		       92		      .byte.b	146	;G
    672  5c34		       c8		      .byte.b	200	;B
    673  5c35		       92		      .byte.b	146	;R (17)
    674  5c36		       92		      .byte.b	146	;G
    675  5c37		       c8		      .byte.b	200	;B
    676  5c38		       92		      .byte.b	146	;R (16)
    677  5c39		       92		      .byte.b	146	;G
    678  5c3a		       c8		      .byte.b	200	;B
    679  5c3b		       92		      .byte.b	146	;R (15)
    680  5c3c		       92		      .byte.b	146	;G
    681  5c3d		       c8		      .byte.b	200	;B
    682  5c3e		       92		      .byte.b	146	;R (14)
    683  5c3f		       92		      .byte.b	146	;G
    684  5c40		       c8		      .byte.b	200	;B
    685  5c41		       92		      .byte.b	146	;R (13)
    686  5c42		       92		      .byte.b	146	;G
    687  5c43		       c8		      .byte.b	200	;B
    688  5c44		       92		      .byte.b	146	;R (12)
    689  5c45		       92		      .byte.b	146	;G
    690  5c46		       c8		      .byte.b	200	;B
    691  5c47		       92		      .byte.b	146	;R (11)
    692  5c48		       92		      .byte.b	146	;G
    693  5c49		       c8		      .byte.b	200	;B
    694  5c4a		       92		      .byte.b	146	;R (10)
    695  5c4b		       92		      .byte.b	146	;G
    696  5c4c		       c8		      .byte.b	200	;B
    697  5c4d		       96		      .byte.b	150	;R (9)
    698  5c4e		       96		      .byte.b	150	;G
    699  5c4f		       c0		      .byte.b	192	;B
    700  5c50		       96		      .byte.b	150	;R (8)
    701  5c51		       96		      .byte.b	150	;G
    702  5c52		       c0		      .byte.b	192	;B
    703  5c53		       9e		      .byte.b	158	;R (7)
    704  5c54		       9e		      .byte.b	158	;G
    705  5c55		       c0		      .byte.b	192	;B
    706  5c56		       9e		      .byte.b	158	;R (6)
    707  5c57		       9c		      .byte.b	156	;G
    708  5c58		       c0		      .byte.b	192	;B
    709  5c59		       9e		      .byte.b	158	;R (5)
    710  5c5a		       9c		      .byte.b	156	;G
    711  5c5b		       c0		      .byte.b	192	;B
    712  5c5c		       ef		      .byte.b	239	;R (4)
    713  5c5d		       88		      .byte.b	136	;G
    714  5c5e		       80		      .byte.b	128	;B
    715  5c5f		       7f		      .byte.b	127	;R (3)
    716  5c60		       40		      .byte.b	64	;G
    717  5c61		       40		      .byte.b	64	;B
    718  5c62		       7f		      .byte.b	127	;R (2)
    719  5c63		       40		      .byte.b	64	;G
    720  5c64		       40		      .byte.b	64	;B
    721  5c65		       7f		      .byte.b	127	;R (1)
    722  5c66		       7f		      .byte.b	127	;G
    723  5c67		       7f		      .byte.b	127	;B
    724  5c68		       3f		      .byte.b	63	;R (0)
    725  5c69		       3f		      .byte.b	63	;G
    726  5c6a		       3f		      .byte.b	63	;B
------- FILE titleScreen.asm
    166  5c6b							;    include "pizza.asm"
    167  5c6b
      0  5c6b					      CHECK_BANK_SIZE	"INITBANK"
      1  5c6b		       04 6b	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $46b , FREE= $395
      2  5c6b					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5c6b				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  5c6b				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5c6b				  -	      ERR
      6  5c6b					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 4
      0  5c6b					      include	"BANK_INITBANK.asm"	; MUST be after banks that include levels -- otherwise MAX_LEVELBANK is not calculated properly
      1  5c6b							;    Sokoboo - a Sokoban implementation
      2  5c6b							;    using a generic tile-based display engine for the Atari 2600
      3  5c6b							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  5c6b							;
      5  5c6b							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  5c6b							;
      7  5c6b							;    Code related to the generic tile-based display engine was developed by
      8  5c6b							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  5c6b							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  5c6b							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  5c6b							;
     12  5c6b							;    Code related to music and sound effects uses the TIATracker music player
     13  5c6b							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  5c6b							;    directory for Apache licensing details.
     15  5c6b							;
     16  5c6b							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  5c6b							;    See the copyright notices in the License directory for a list of level
     18  5c6b							;    contributors.
     19  5c6b							;
     20  5c6b							;    Except where otherwise indicated, this software is released under the
     21  5c6b							;    following licensing arrangement...
     22  5c6b							;
     23  5c6b							;    This program is free software: you can redistribute it and/or modify
     24  5c6b							;    it under the terms of the GNU General Public License as published by
     25  5c6b							;    the Free Software Foundation, either version 3 of the License, or
     26  5c6b							;    (at your option) any later version.
     27  5c6b							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  5c6b
     29  5c6b							;    This program is distributed in the hope that it will be useful,
     30  5c6b							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  5c6b							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  5c6b							;    GNU General Public License for more details.
     33  5c6b
      0  5c6b					      NEWBANK	INITBANK
      1  6369 ????				      SEG	INITBANK
      2  6000					      ORG	ORIGIN
      3  6000					      RORG	$F000
      4  6000				   BANK_START SET	*
      5  6000				   INITBANK   SET	ORIGIN / 2048
      6  6000				   ORIGIN     SET	ORIGIN + 2048
      7  6000				   _CURRENT_BANK SET	INITBANK
     35  6000
     36  6000		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
     37  6001
      0  6001					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  6001		       00 0c	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  6001					      SUBROUTINE
      3  6001				   BoardLineStartLO
     39  6001
     40  6001							; Gives the start address (LO) of each board line
     41  6001					      if	1
     42  6001				   .BOARD_LOCATION SET	Board
     43  6001					      REPEAT	SIZE_BOARD_Y
     44  6001				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6001				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6001					      ENDIF
     47  6001		       00		      .byte.b	<.BOARD_LOCATION
     48  6001				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6001					      REPEND
     44  6002				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6002				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6002					      ENDIF
     47  6002		       18		      .byte.b	<.BOARD_LOCATION
     48  6002				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6002					      REPEND
     44  6003				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6003				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6003					      ENDIF
     47  6003		       30		      .byte.b	<.BOARD_LOCATION
     48  6003				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6003					      REPEND
     44  6004				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6004				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6004					      ENDIF
     47  6004		       48		      .byte.b	<.BOARD_LOCATION
     48  6004				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6004					      REPEND
     44  6005				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6005				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6005					      ENDIF
     47  6005		       60		      .byte.b	<.BOARD_LOCATION
     48  6005				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6005					      REPEND
     44  6006				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6006				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6006					      ENDIF
     47  6006		       78		      .byte.b	<.BOARD_LOCATION
     48  6006				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6006					      REPEND
     44  6007				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6007				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6007					      ENDIF
     47  6007		       90		      .byte.b	<.BOARD_LOCATION
     48  6007				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6007					      REPEND
     44  6008				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6008				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6008					      ENDIF
     47  6008		       a8		      .byte.b	<.BOARD_LOCATION
     48  6008				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6008					      REPEND
     44  6009				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6009				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6009					      ENDIF
     47  6009		       c0		      .byte.b	<.BOARD_LOCATION
     48  6009				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6009					      REPEND
     44  600a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  600a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  600a					      ENDIF
     47  600a		       d8		      .byte.b	<.BOARD_LOCATION
     48  600a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  600a					      REPEND
     44  600b					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  600b				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  600b					      ENDIF
     47  600b		       00		      .byte.b	<.BOARD_LOCATION
     48  600b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  600b					      REPEND
     44  600c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  600c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  600c					      ENDIF
     47  600c		       18		      .byte.b	<.BOARD_LOCATION
     48  600c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  600c					      REPEND
     44  600d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  600d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  600d					      ENDIF
     47  600d		       30		      .byte.b	<.BOARD_LOCATION
     48  600d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  600d					      REPEND
     44  600e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  600e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  600e					      ENDIF
     47  600e		       48		      .byte.b	<.BOARD_LOCATION
     48  600e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  600e					      REPEND
     44  600f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  600f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  600f					      ENDIF
     47  600f		       60		      .byte.b	<.BOARD_LOCATION
     48  600f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  600f					      REPEND
     44  6010				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6010				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6010					      ENDIF
     47  6010		       78		      .byte.b	<.BOARD_LOCATION
     48  6010				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6010					      REPEND
     44  6011				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6011				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6011					      ENDIF
     47  6011		       90		      .byte.b	<.BOARD_LOCATION
     48  6011				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6011					      REPEND
     44  6012				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6012				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6012					      ENDIF
     47  6012		       a8		      .byte.b	<.BOARD_LOCATION
     48  6012				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6012					      REPEND
     44  6013				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6013				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6013					      ENDIF
     47  6013		       c0		      .byte.b	<.BOARD_LOCATION
     48  6013				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  6013					      REPEND
     44  6014				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  6014				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  6014					      ENDIF
     47  6014		       d8		      .byte.b	<.BOARD_LOCATION
     48  6014				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     49  6015					      REPEND
      0  6015					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  6015					      LIST	ON
     51  6015
     52  6015		       01 f0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     53  6015					      endif
     54  6015
     55  6015							;------------------------------------------------------------------------------
     56  6015
     57  6015				   BoardLineStartHiR
     58  6015
     59  6015							; Gives the start address (HI) of each board line
     60  6015							; Note this caters for the memory wrapping when we go from bank to bank, as
     61  6015							; the board overlays multiple banks!
     62  6015
     63  6015				   .BOARD_LOCATION SET	Board
     64  6015					      REPEAT	SIZE_BOARD_Y
     65  6015				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6015				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6015					      ENDIF
     68  6015		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6015				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6015					      REPEND
     65  6016				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6016				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6016					      ENDIF
     68  6016		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6016				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6016					      REPEND
     65  6017				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6017				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6017					      ENDIF
     68  6017		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6017				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6017					      REPEND
     65  6018				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6018				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6018					      ENDIF
     68  6018		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6018				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6018					      REPEND
     65  6019				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6019				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6019					      ENDIF
     68  6019		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6019				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6019					      REPEND
     65  601a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  601a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  601a					      ENDIF
     68  601a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  601a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  601a					      REPEND
     65  601b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  601b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  601b					      ENDIF
     68  601b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  601b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  601b					      REPEND
     65  601c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  601c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  601c					      ENDIF
     68  601c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  601c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  601c					      REPEND
     65  601d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  601d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  601d					      ENDIF
     68  601d		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  601d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  601d					      REPEND
     65  601e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  601e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  601e					      ENDIF
     68  601e		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  601e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  601e					      REPEND
     65  601f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  601f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  601f					      ENDIF
     68  601f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  601f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  601f					      REPEND
     65  6020				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6020				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6020					      ENDIF
     68  6020		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6020				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6020					      REPEND
     65  6021				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6021				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6021					      ENDIF
     68  6021		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6021				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6021					      REPEND
     65  6022				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6022				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6022					      ENDIF
     68  6022		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6022				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6022					      REPEND
     65  6023				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6023				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6023					      ENDIF
     68  6023		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6023				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6023					      REPEND
     65  6024				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6024				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6024					      ENDIF
     68  6024		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6024				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6024					      REPEND
     65  6025				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6025				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6025					      ENDIF
     68  6025		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6025				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6025					      REPEND
     65  6026				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6026				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6026					      ENDIF
     68  6026		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6026				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6026					      REPEND
     65  6027				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6027				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6027					      ENDIF
     68  6027		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6027				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  6027					      REPEND
     65  6028				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  6028				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  6028					      ENDIF
     68  6028		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  6028				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     70  6029					      REPEND
      0  6029					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  6029					      LIST	ON
     72  6029							;------------------------------------------------------------------------------
     73  6029
     74  6029				   BoardLineStartHiW
     75  6029
     76  6029							; Gives the start address (HI) of each board line
     77  6029							; Note this caters for the memory wrapping when we go from bank to bank, as
     78  6029							; the board overlays multiple banks!
     79  6029
     80  6029				   .BOARD_LOCATION SET	Board
     81  6029					      REPEAT	SIZE_BOARD_Y
     82  6029				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6029				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6029					      ENDIF
     85  6029		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6029				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6029					      REPEND
     82  602a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  602a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  602a					      ENDIF
     85  602a		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  602a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  602a					      REPEND
     82  602b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  602b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  602b					      ENDIF
     85  602b		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  602b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  602b					      REPEND
     82  602c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  602c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  602c					      ENDIF
     85  602c		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  602c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  602c					      REPEND
     82  602d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  602d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  602d					      ENDIF
     85  602d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  602d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  602d					      REPEND
     82  602e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  602e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  602e					      ENDIF
     85  602e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  602e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  602e					      REPEND
     82  602f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  602f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  602f					      ENDIF
     85  602f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  602f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  602f					      REPEND
     82  6030				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6030				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6030					      ENDIF
     85  6030		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6030				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6030					      REPEND
     82  6031				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6031				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6031					      ENDIF
     85  6031		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6031				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6031					      REPEND
     82  6032				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6032				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6032					      ENDIF
     85  6032		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6032				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6032					      REPEND
     82  6033					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6033				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6033					      ENDIF
     85  6033		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6033				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6033					      REPEND
     82  6034				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6034				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6034					      ENDIF
     85  6034		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6034				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6034					      REPEND
     82  6035				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6035				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6035					      ENDIF
     85  6035		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6035				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6035					      REPEND
     82  6036				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6036				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6036					      ENDIF
     85  6036		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6036				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6036					      REPEND
     82  6037				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6037				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6037					      ENDIF
     85  6037		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6037				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6037					      REPEND
     82  6038				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6038				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6038					      ENDIF
     85  6038		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6038				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6038					      REPEND
     82  6039				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  6039				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  6039					      ENDIF
     85  6039		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  6039				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  6039					      REPEND
     82  603a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  603a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  603a					      ENDIF
     85  603a		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  603a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  603a					      REPEND
     82  603b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  603b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  603b					      ENDIF
     85  603b		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  603b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  603b					      REPEND
     82  603c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  603c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  603c					      ENDIF
     85  603c		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  603c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     87  603d					      REPEND
      0  603d					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  603d					      LIST	ON
     89  603d
     90  603d							;------------------------------------------------------------------------------
     91  603d				  -	      IF	MULTI_BANK_BOARD = YES
     92  603d				  -BoardBank
     93  603d					      ENDIF
     94  603d							; Gives the RAM bank of the start of the board row for a given row.
     95  603d
     96  603d				   .BOARD_LOCATION SET	Board - RAM_3E
     97  603d					      REPEAT	SIZE_BOARD_Y
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  603d					      REPEND
     98  603d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  603d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  603d					      ENDIF
    101  603d				  -	      IF	MULTI_BANK_BOARD = YES
    102  603d				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  603d					      ENDIF
    104  603d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
    105  603d					      REPEND
    106  603d				  -	      IF	MULTI_BANK_BOARD = YES
    107  603d				  -	      CHECKPAGEX	BoardBank, "BoardBank in BANK_INITBANK.asm"
    108  603d					      ENDIF
    109  603d
    110  603d
    111  603d							;------------------------------------------------------------------------------
    112  603d
    113  603d				   CopyROMShadowToRAM_F000
    114  603d		       a9 f0		      lda	#>$F000
    115  603f
      0  603f					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  603f		       00 0c	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  603f					      SUBROUTINE
      3  603f				   CopyROMShadowToRAM
    117  603f
    118  603f							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
    119  603f							; the variable definitions are in the ROM shadow because this allows auto-initialisation
    120  603f							; of the variable contents from ROM declarations, but still allows access to them as
    121  603f							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
    122  603f							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
    123  603f							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
    124  603f							; code co-lives in all banks and may run even as bankswitching occurs between those
    125  603f							; banks -- by the very code itself.
    126  603f
    127  603f							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
    128  603f		       85 c6		      sta	Board_AddressR+1
    129  6041		       86 e3		      stx	O_ROM_Source_Bank	; source bank
    130  6043		       84 ca		      sty	RAM_Bank	; destination bank
    131  6045
    132  6045		       a0 00		      ldy	#0
    133  6047		       84 c5		      sty	Board_AddressR
    134  6049		       84 c7		      sty	Board_AddressW
    135  604b		       a9 14		      lda	#>($1000+RAM_WRITE)
    136  604d		       85 c8		      sta	Board_AddressW+1
    137  604f
    138  604f							; Iterate 4 pages (1K) for complete bank copy
    139  604f
    140  604f		       a9 04		      lda	#4
    141  6051		       85 e2		      sta	O_CopyCount
    142  6053
    143  6053		       84 e4	   CopyPage   sty	O_Index
    144  6055		       a5 e3		      lda	O_ROM_Source_Bank
    145  6057		       20 0f f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    146  605a							;tax
    147  605a		       a4 e4		      ldy	O_Index
    148  605c		       a6 ca		      ldx	RAM_Bank
    149  605e		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    150  6061
    151  6061		       a4 e4		      ldy	O_Index
    152  6063		       c8		      iny
    153  6064		       d0 ed		      bne	CopyPage
    154  6066
    155  6066		       e6 c6		      inc	Board_AddressR+1
    156  6068		       e6 c8		      inc	Board_AddressW+1
    157  606a
    158  606a		       c6 e2		      dec	O_CopyCount
    159  606c		       d0 e5		      bne	CopyPage
    160  606e
    161  606e		       a4 ca		      ldy	RAM_Bank	; TODO: remove!?
    162  6070		       60		      rts
    163  6071
    164  6071
    165  6071							;------------------------------------------------------------------------------
      0  6071					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  6071		       00 0c	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  6071					      SUBROUTINE
      3  6071				   SetPlatformColours
    167  6071
    168  6071							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    169  6071							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    170  6071							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    171  6071							; addressing will not violate the page-crossing restriction of 3E.
    172  6071
    173  6071							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    174  6071
    175  6071		       a9 00		      lda	#<DrawTheScreen	; = 0
    176  6073		       85 c7		      sta	Board_AddressW
    177  6075		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    178  6077		       85 c8		      sta	Board_AddressW+1
    179  6079
    180  6079							; first, set the x index (with last one being a RTS ($60))
    181  6079
    182  6079		       a6 ca		      ldx	RAM_Bank
    183  607b		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    184  607d		       d0 07		      bne	.skipPatch
    185  607f		       a9 60		      lda	#$60	; rts
    186  6081		       a0 41		      ldy	#<SELFMOD_X
    187  6083		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    188  6086				   .skipPatch
    189  6086
    190  6086		       a2 02		      ldx	#3-1
    191  6088				   .loopColor
    192  6088		       86 e2		      stx	colorIdx
    193  608a							; set PF colors
    194  608a		       b5 c2		      lda	color,x
    195  608c		       bc a9 f0 	      ldy	SelfModColOfsTbl,x
    196  608f							;tax
    197  608f		       a6 ca		      ldx	RAM_Bank
    198  6091		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy PF colour RED/GREEN/BLUE to self-modifying RAM
    199  6094							; set player colors
    200  6094		       a6 e2		      ldx	colorIdx
    201  6096		       bd ac f0 	      lda	SelfModePlayerTbl,x
    202  6099		       a4 81		      ldy	Platform
    203  609b		       c0 02		      cpy	#PAL
    204  609d		       90 02		      bcc	.platform0
    205  609f		       69 17		      adc	#LINES_PER_CHAR-1	; C==1!
    206  60a1				   .platform0
    207  60a1							;ldy SelfModPlayerColOfsTbl,x
    208  60a1							;tax
    209  60a1							;ldx RAM_Bank
    210  60a1							;jsr PutBoardCharacter 	  ;6+21(A)	  copy player colour RED/GREEN/BLUE to self-modifying RAM
    211  60a1							; loop
    212  60a1		       a6 e2		      ldx	colorIdx
    213  60a3		       ca		      dex
    214  60a4		       10 e2		      bpl	.loopColor
    215  60a6
    216  60a6		       a4 ca		      ldy	RAM_Bank
    217  60a8		       60		      rts
    218  60a9
    219  60a9				   SelfModColOfsTbl
    220  60a9		       53 86 1c 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    221  60ac				   SelfModePlayerTbl
    222  60ac		       bf b7 af 	      .byte.b	<SpriteColourBLUE, <SpriteColourGREEN, <SpriteColourRED
    223  60af							;SelfModPlayerColOfsTbl:
    224  60af							;    .byte   <(SELFMOD_PLAYERCOL_BLUE+1), <(SELFMOD_PLAYERCOL_GREEN+1), <(SELFMOD_PLAYERCOL_RED+1)
    225  60af
    226  60af
    227  60af				   DrawLineStartLO
    228  60af
    229  60af							; Gives the start address of each line in the draw flags buffer
    230  60af
    231  60af				   .DRAW_LOCATION SET	DrawFlag
    232  60af					      REPEAT	SCREEN_LINES
    233  60af		       50		      .byte.b	<.DRAW_LOCATION
    234  60af				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  60af					      REPEND
    233  60b0		       5a		      .byte.b	<.DRAW_LOCATION
    234  60b0				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  60b0					      REPEND
    233  60b1		       64		      .byte.b	<.DRAW_LOCATION
    234  60b1				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  60b1					      REPEND
    233  60b2		       6e		      .byte.b	<.DRAW_LOCATION
    234  60b2				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  60b2					      REPEND
    233  60b3		       78		      .byte.b	<.DRAW_LOCATION
    234  60b3				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  60b3					      REPEND
    233  60b4		       82		      .byte.b	<.DRAW_LOCATION
    234  60b4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  60b4					      REPEND
    233  60b5		       8c		      .byte.b	<.DRAW_LOCATION
    234  60b5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  60b5					      REPEND
    233  60b6		       96		      .byte.b	<.DRAW_LOCATION
    234  60b6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    235  60b7					      REPEND
    236  60b7
    237  60b7
    238  60b7							;------------------------------------------------------------------------------
    239  60b7
      0  60b7					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  60b7		       00 0c	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  60b7					      SUBROUTINE
      3  60b7				   GetBoardAddressRW
    241  60b7							; Must share same bank as BoardLineStart tables
    242  60b7
    243  60b7		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    244  60ba		       85 c5		      sta	Board_AddressR	; 3
    245  60bc		       85 c7		      sta	Board_AddressW	; 3
    246  60be		       b9 15 f0 	      lda	BoardLineStartHiR,y	; 4
    247  60c1		       85 c6		      sta	Board_AddressR+1	; 3	     READ address
    248  60c3		       09 04		      ora	#>RAM_WRITE	; 2
    249  60c5		       85 c8		      sta	Board_AddressW+1	; 3	     WRITE address
    250  60c7				  -	      IF	MULTI_BANK_BOARD = YES
    251  60c7				  -	      ldx	BoardBank,y	; 4 = 26    switch this on return
    252  60c7					      ELSE
    253  60c7		       a2 0d		      ldx	#BANK_BOARD	; 2
    254  60c9					      ENDIF
    255  60c9		       60		      rts		; 6 = 32[-2]
    256  60ca
    257  60ca							;------------------------------------------------------------------------------
    258  60ca
      0  60ca					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  60ca		       00 0c	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  60ca					      SUBROUTINE
      3  60ca				   GetBoardAddressR
    260  60ca
    261  60ca		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    262  60cd		       85 c5		      sta	Board_AddressR	; 3
    263  60cf		       b9 15 f0 	      lda	BoardLineStartHiR,y	; 4
    264  60d2		       85 c6		      sta	Board_AddressR+1	; 3	 READ address
    265  60d4				  -	      IF	MULTI_BANK_BOARD = YES
    266  60d4				  -	      lda	BoardBank,y	; 4	 switch this on return
    267  60d4					      ELSE
    268  60d4		       a9 0d		      lda	#BANK_BOARD	; 2
    269  60d6					      ENDIF
    270  60d6		       60		      rts		; 6[-2]
    271  60d7
    272  60d7							;------------------------------------------------------------------------------
    273  60d7
      0  60d7					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  60d7		       00 0c	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  60d7					      SUBROUTINE
      3  60d7				   GetBoardAddressW
    275  60d7
    276  60d7							; Must share same bank as BoardLineStart tables
    277  60d7
    278  60d7		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    279  60da		       85 c7		      sta	Board_AddressW	;3
    280  60dc		       b9 29 f0 	      lda	BoardLineStartHiW,y	;4
    281  60df		       85 c8		      sta	Board_AddressW+1	;3 WRITE address
    282  60e1				  -	      IF	MULTI_BANK_BOARD = YES
    283  60e1				  -	      ldx	BoardBank,y	;4 switch this on return
    284  60e1					      ELSE
    285  60e1		       a2 0d		      ldx	#BANK_BOARD	;2
    286  60e3					      ENDIF
    287  60e3		       60	   QRet       rts		;6
    288  60e4
    289  60e4							;-------------------------------------------------------------------------------
    290  60e4
    291  60e4
    292  60e4							;------------------------------------------------------------------------------
    293  60e4
    294  60e4		       e6 ac	   cannotPush inc	ManPushCounter
    295  60e6		       60		      rts
    296  60e7
      0  60e7					      DEFINE_SUBROUTINE	PushBox	; in INITBANK
      1  60e7		       00 0c	   BANK_PushBox =	_CURRENT_BANK
      2  60e7					      SUBROUTINE
      3  60e7				   PushBox
    298  60e7
    299  60e7							; X = restoration character for square we are moving TO
    300  60e7							; so, if X = CHARACTER_TARGET AND we move, THEN we are pushing a box off a target
    301  60e7							; A = this bank!
    302  60e7
    303  60e7		       85 c9		      sta	ROM_Bank
    304  60e9
    305  60e9		       a5 ae		      lda	ManAnimationID
    306  60eb		       c9 86		      cmp	#ANIMATION_PUSH_ID
    307  60ed		       f0 14		      beq	alreadyAnimPush
    308  60ef		       c9 88		      cmp	#ANIMATION_PUSHTRY_ID
    309  60f1		       f0 10		      beq	alreadyAnimPush
    310  60f3
      0  60f3					      LOAD_ANIMATION	Animation_PushTry
      1  60f3		       a9 67		      lda	#<Animation_PushTry
      2  60f5		       85 9f		      sta	animation
      3  60f7		       a9 f0		      lda	#>Animation_PushTry
      4  60f9		       85 a0		      sta	animation+1
      5  60fb		       a9 ff		      lda	#-1
      6  60fd		       85 a1		      sta	animation_delay
    312  60ff
    313  60ff		       a9 88		      lda	#ANIMATION_PUSHTRY_ID
    314  6101		       85 ae		      sta	ManAnimationID
    315  6103
    316  6103				   alreadyAnimPush
    317  6103
    318  6103		       a5 ac		      lda	ManPushCounter
    319  6105		       c9 02		      cmp	#PUSH_LIMIT
    320  6107		       90 db		      bcc	cannotPush
    321  6109
    322  6109		       a9 86		      lda	#ANIMATION_PUSH_ID
    323  610b		       c5 ae		      cmp	ManAnimationID
    324  610d		       f0 0e		      beq	alreadyPushing
    325  610f		       85 ae		      sta	ManAnimationID
    326  6111
      0  6111					      LOAD_ANIMATION	Animation_Push
      1  6111		       a9 6c		      lda	#<Animation_Push
      2  6113		       85 9f		      sta	animation
      3  6115		       a9 f0		      lda	#>Animation_Push
      4  6117		       85 a0		      sta	animation+1
      5  6119		       a9 ff		      lda	#-1
      6  611b		       85 a1		      sta	animation_delay
    328  611d
    329  611d				   alreadyPushing
    330  611d
    331  611d		       86 e4		      stx	restorationCharacter	; players new location's restore
    332  611f
    333  611f							; Determine if the box is pushable
    334  611f							; we use the joystick to calculate the subsequent square
    335  611f
    336  611f		       a5 93		      lda	BufferedJoystick
    337  6121		       4a		      lsr
    338  6122		       4a		      lsr
    339  6123		       4a		      lsr
    340  6124		       4a		      lsr
    341  6125		       48		      pha
    342  6126		       a8		      tay
    343  6127
    344  6127		       18		      clc
    345  6128		       a5 8b		      lda	POS_Y_NEW
    346  612a		       79 b3 f2 	      adc	JoyMoveY,y
    347  612d		       85 89		      sta	POS_Y	; the box's pushed-to square
    348  612f		       a8		      tay
    349  6130		       20 b7 f0 	      jsr	GetBoardAddressRW
    350  6133
    351  6133		       68		      pla
    352  6134		       a8		      tay
    353  6135
    354  6135		       18		      clc
    355  6136		       a5 8a		      lda	POS_X_NEW
    356  6138		       79 a7 f2 	      adc	JoyMoveX,y
    357  613b		       85 88		      sta	POS_X	; the box's pushed-to square
    358  613d		       48		      pha
    359  613e		       a8		      tay
    360  613f
    361  613f				  -	      IF	MULTI_BANK_BOARD = YES
    362  613f				  -	      lda	RAM_Bank
    363  613f					      ELSE
    364  613f		       a9 0d		      lda	#BANK_BOARD	; 2
    365  6141					      ENDIF
    366  6141		       20 14 f8 	      jsr	GetBoardCharacter	;6+20(A)
    367  6144		       68		      pla
    368  6145		       a8		      tay
    369  6146
    370  6146		       a9 02		      lda	#CHARACTER_BOX
    371  6148		       e0 00		      cpx	#CHARACTER_BLANK
    372  614a		       f0 0d		      beq	canPushTarget
    373  614c
    374  614c		       e0 03		      cpx	#CHARACTER_TARGET
    375  614e		       f0 04		      beq	decreaseTargets
    376  6150		       e0 04		      cpx	#CHARACTER_TARGET2
    377  6152		       d0 90		      bne	cannotPush
    378  6154
    379  6154							; Box is now on a target - so decrease the remaining targets
    380  6154
    381  6154		       20 b1 fd    decreaseTargets jsr	DeRegisterTarget
    382  6157		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    383  6159		       48	   canPushTarget pha
    384  615a
    385  615a							; If the box *WAS* on a target (restoration character = CHARACTER_TARGET)
    386  615a							; then we increase targets (as there is one more to get)
    387  615a
    388  615a		       a5 e4		      lda	restorationCharacter
    389  615c		       c9 03		      cmp	#CHARACTER_TARGET
    390  615e		       d0 03		      bne	notOnTargetAlready
    391  6160
    392  6160							; increase the required targets as box is leaving one
    393  6160
    394  6160		       20 a7 fd 	      jsr	RegisterTarget
    395  6163
    396  6163				   notOnTargetAlready
    397  6163
    398  6163							; record the box takeback params for the player move to use
    399  6163
    400  6163		       86 92		      stx	TB_CHAR
    401  6165		       a5 88		      lda	POS_X
    402  6167		       85 90		      sta	TB_PUSHX
    403  6169		       a5 89		      lda	POS_Y
    404  616b		       85 91		      sta	TB_PUSHY
    405  616d
    406  616d		       68		      pla		; new char to go on board in box's new position
    407  616e
    408  616e
    409  616e				  -	      IF	MULTI_BANK_BOARD = YES
    410  616e				  -	      ldx	RAM_Bank	; <-- this will never work calling from INITBANK!!!
    411  616e					      ELSE
    412  616e		       a2 0d		      ldx	#BANK_BOARD	; 2
    413  6170					      ENDIF
    414  6170		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)
    415  6173
    416  6173		       a5 8d		      lda	POS_VAR	; player's restoration character
    417  6175		       48		      pha
    418  6176
    419  6176							; Before the player moves to the new position, take away the box and replace with the
    420  6176							; character the box was sitting on (BLANK or TARGET). Then the player moves in "next"
    421  6176
    422  6176		       a5 8b		      lda	POS_Y_NEW
    423  6178		       85 89		      sta	POS_Y
    424  617a		       a5 8a		      lda	POS_X_NEW
    425  617c		       85 88		      sta	POS_X
    426  617e		       a5 e4		      lda	restorationCharacter
    427  6180		       85 8d		      sta	POS_VAR
    428  6182		       20 06 f9 	      jsr	PutCharacterAtXY	; put back BOX's restoration character
    429  6185
    430  6185		       68		      pla
    431  6186		       85 8d		      sta	POS_VAR
    432  6188
    433  6188							;START_SOUND SOUND_BOX
    434  6188
    435  6188							; Note: MovePlayer expects new position to be POS_X_NEW, POS_Y_NEW
    436  6188							; AND the current man's square to be ManX, ManY
    437  6188
    438  6188		       4c 5c f9 	      jmp	MovePlayer	; now there's a gap, player should move in
    439  618b
    440  618b
    441  618b							;------------------------------------------------------------------------------
    442  618b
    443  618b							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    444  618b							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    445  618b
    446  618b							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    447  618b
    448  618b							; if the creature dies then jump NextObject
    449  618b
    450  618b
    451  618b
    452  618b		       ff	   RDirY      .byte.b	-1	;,0,1,0
    453  618c		       00 01	   RDirX      .byte.b	0,1	;,0,-1
    454  618e		       00 ff 01 00 DirPushModX .byte.b	0,-1,1,0
    455  6192		       ff 00 00 01 DirPushModY .byte.b	-1,0,0,1
    456  6196		       01 02 03 00*Directional .byte.b	1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    457  61a4
    458  61a4
    459  61a4							;------------------------------------------------------------------------------
    460  61a4
    461  61a4							; the auto-calculation of these was causing DASM to get confused and abort assembling.
    462  61a4							; I don't particularly know why; probably because of the level variable-size array and the values
    463  61a4							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    464  61a4
    465  61a4		       00 00	   MANMODE_STARTUP =	0
    466  61a4		       00 01	   MANMODE_NORMAL =	1
    467  61a4		       00 02	   MANMODE_DEAD =	2
    468  61a4		       00 03	   MANMODE_WAITING =	3
    469  61a4		       00 04	   MANMODE_WAITING2 =	4
    470  61a4		       00 05	   MANMODE_WAITING_NT =	5
    471  61a4		       00 06	   MANMODE_WAITING_NT2 =	6
    472  61a4		       00 07	   MANMODE_NEXTLEVEL =	7
    473  61a4		       00 08	   MANMODE_NEXTLEVEL2 =	8
    474  61a4		       00 09	   MANMODE_SWITCH =	9
    475  61a4
      0  61a4					      DEFINE_SUBROUTINE	ManProcess
      1  61a4		       00 0c	   BANK_ManProcess =	_CURRENT_BANK
      2  61a4					      SUBROUTINE
      3  61a4				   ManProcess
    477  61a4
    478  61a4							; ManMode tells the player what it is currently doing.  State machine.
    479  61a4
    480  61a4							; Check the switches....
    481  61a4							; RESET to restart this level
    482  61a4							; SELECT to start next level
    483  61a4
    484  61a4		       ad 82 02 	      lda	SWCHB
    485  61a7		       29 03		      and	#3
    486  61a9		       aa		      tax
    487  61aa		       bd c3 f1 	      lda	newMode,x
    488  61ad		       30 02		      bmi	skipModeChange
    489  61af		       85 a6		      sta	ManMode
    490  61b1				   skipModeChange
    491  61b1
    492  61b1		       20 00 f8 	      jsr	DrawTimeFromROM	; Z-flag == 0!
    493  61b4
    494  61b4		       a4 a6		      ldy	ManMode
    495  61b6		       b9 c7 f1 	      lda	ManActionLO,y
    496  61b9		       85 e2		      sta	actionVector
    497  61bb		       b9 d1 f1 	      lda	ManActionHI,y
    498  61be		       85 e3		      sta	actionVector+1
    499  61c0		       6c e2 00 	      jmp	(actionVector)
    500  61c3
    501  61c3		       ff 09 04 ff newMode    .byte.b	-1, MANMODE_SWITCH, MANMODE_WAITING2, -1
    502  61c7
    503  61c7				   ManActionLO
    504  61c7		       db		      .byte.b	<manStartup	; 0		 no timer
    505  61c8		       f7		      .byte.b	<normalMan	; 1		 timer
    506  61c9		       00		      .byte.b	<0	; 2		 timer
    507  61ca		       f0		      .byte.b	<waitingMan	; 3		 timer
    508  61cb		       f0		      .byte.b	<waitingManPress	; 4		 timer
    509  61cc		       f0		      .byte.b	<waitingMan	; 5		 no timer
    510  61cd		       f0		      .byte.b	<waitingManPress	; 6		 no timer
    511  61ce		       7c		      .byte.b	<nextLevelMan	; 7		 no timer
    512  61cf		       83		      .byte.b	<nextLevelMan2	; 8		 no timer
    513  61d0		       8b		      .byte.b	<switchLevels	; 9		 no timer
    514  61d1
    515  61d1				   ManActionHI
    516  61d1		       f1		      .byte.b	>manStartup	; no timer
    517  61d2		       f1		      .byte.b	>normalMan	; timer
    518  61d3		       00		      .byte.b	>0	; timer
    519  61d4		       f1		      .byte.b	>waitingMan	; timer
    520  61d5		       f1		      .byte.b	>waitingManPress	; timer
    521  61d6		       f1		      .byte.b	>waitingMan	; no timer
    522  61d7		       f1		      .byte.b	>waitingManPress	; no timer
    523  61d8		       fd		      .byte.b	>nextLevelMan	; no timer
    524  61d9		       fd		      .byte.b	>nextLevelMan2	; no timer
    525  61da		       fd		      .byte.b	>switchLevels	;9  no timer
    526  61db
    527  61db							;------------------------------------------------------------------------------
      0  61db					      DEFINE_SUBROUTINE	manStartup
      1  61db		       00 0c	   BANK_manStartup =	_CURRENT_BANK
      2  61db					      SUBROUTINE
      3  61db				   manStartup
    529  61db
    530  61db					      IF	WAIT_FOR_INITIAL_DRAW
    531  61db							; Delay turning on the visible screen until the background has completed drawing.
    532  61db							; This is simple - is there anything still in the draw stack?
    533  61db		       a5 82		      lda	DrawStackPointer
    534  61dd		       10 04		      bpl	midDraw
    535  61df		       a9 00		      lda	#0
    536  61e1		       85 b4		      sta	blankState
    537  61e3				   midDraw
    538  61e3					      ENDIF
    539  61e3
    540  61e3		       a5 a2		      lda	ManX
    541  61e5		       85 8a		      sta	POS_X_NEW
    542  61e7		       a5 a3		      lda	ManY
    543  61e9		       85 8b		      sta	POS_Y_NEW
    544  61eb
    545  61eb		       a9 01		      lda	#MANMODE_NORMAL
    546  61ed		       85 a6		      sta	ManMode
    547  61ef
    548  61ef				   RTS_CF
    549  61ef		       60		      rts
    550  61f0
    551  61f0							;------------------------------------------------------------------------------
    552  61f0
    553  61f0				   waitingMan
    554  61f0				   waitingManPress
    555  61f0
    556  61f0							;		  lda #50
    557  61f0							;		  sta ColourTimer
    558  61f0
    559  61f0
    560  61f0		       a5 d0		      lda	NextLevelTrigger
    561  61f2		       09 40		      ora	#BIT_NEXTLIFE
    562  61f4		       85 d0		      sta	NextLevelTrigger
    563  61f6		       60		      rts
    564  61f7
    565  61f7
    566  61f7							;------------------------------------------------------------------------------
    567  61f7							; Normal man state
    568  61f7
    569  61f7
    570  61f7				   normalMan
    571  61f7
    572  61f7							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    573  61f7							; before exiting via (for example) look-around option :)
    574  61f7
    575  61f7		       a5 a2		      lda	ManX
    576  61f9		       85 8a		      sta	POS_X_NEW
    577  61fb		       a5 a3		      lda	ManY
    578  61fd		       85 8b		      sta	POS_Y_NEW
    579  61ff
    580  61ff							;------------------------------------------------------------------------------
    581  61ff							; Look around is triggered by holding down the fire button for a while, without any other
    582  61ff							; joystick directions chosen. The variable LookingAround has a negative value ($FF) when looking
    583  61ff							; is active. Otherwise, it is counting down to the time where it will trigger.
    584  61ff
    585  61ff		       00 00	   LOOK_DELAY =	0
    586  61ff
    587  61ff
    588  61ff							;------------------------------------------------------------------------------
    589  61ff							; Take-back is a press/release of the button, with the press being limited in duratino
    590  61ff							; to allow the action to be "cancelled". Meanwhile, a button press + direction triggers
    591  61ff							; "look-around mode"
    592  61ff
    593  61ff		       a5 95		      lda	BufferedButton
    594  6201		       30 36		      bmi	noLook	; button?
    595  6203
    596  6203							; button pressed, so in looking-around mode
    597  6203
    598  6203		       a2 ff		      ldx	#$FF
    599  6205		       86 95		      stx	BufferedButton	; "release" button
    600  6207
    601  6207		       a5 ad		      lda	LookingAround
    602  6209		       30 02		      bmi	LookAround
    603  620b		       86 ad		      stx	LookingAround
    604  620d				   LookAround
    605  620d
    606  620d							; Use the joystick as a window-scroller to change the viewport
    607  620d
    608  620d		       a5 93		      lda	BufferedJoystick
    609  620f		       4a		      lsr
    610  6210		       4a		      lsr
    611  6211		       4a		      lsr
    612  6212		       4a		      lsr
    613  6213		       a8		      tay
    614  6214
    615  6214		       b9 a7 f2 	      lda	JoyMoveX,y
    616  6217		       19 b3 f2 	      ora	JoyMoveY,y
    617  621a		       f0 1c		      beq	AbandonY
    618  621c
    619  621c		       a9 fe		      lda	#$FE
    620  621e		       85 ad		      sta	LookingAround
    621  6220
    622  6220		       b9 a7 f2 	      lda	JoyMoveX,y
    623  6223							;asl
    624  6223		       18		      clc
    625  6224		       65 9a		      adc	BoardScrollX
    626  6226		       c5 97		      cmp	BoardEdge_Right
    627  6228		       b0 02		      bcs	AbandonX
    628  622a		       85 9a		      sta	BoardScrollX
    629  622c
    630  622c		       b9 b3 f2    AbandonX   lda	JoyMoveY,y
    631  622f							;asl
    632  622f		       18		      clc
    633  6230		       65 99		      adc	BoardScrollY
    634  6232		       c5 98		      cmp	BoardEdge_Bottom
    635  6234		       b0 02		      bcs	AbandonY
    636  6236		       85 99		      sta	BoardScrollY
    637  6238
    638  6238		       60	   AbandonY   rts
    639  6239
    640  6239		       a2 00	   noLook     ldx	#0
    641  623b		       a5 ad		      lda	LookingAround
    642  623d		       c9 ff		      cmp	#$FF
    643  623f		       86 ad		      stx	LookingAround
    644  6241		       d0 08		      bne	bProcComp	; $FE means there was a lookaround, so skip
    645  6243
    646  6243							; button was presssed and now released and we didn't actually look around
    647  6243							; so we do a take-back
    648  6243							;lda Platform
    649  6243							;adc #4
    650  6243							;sta ColourFlash
    651  6243							;lda #5
    652  6243							;sta ColourTimer
    653  6243
    654  6243		       a9 0c		      lda	#BANK_ManProcess
    655  6245		       85 c9		      sta	ROM_Bank	;? might already be set
    656  6247		       20 1a fa 	      jsr	takebackRestoreEarlierPosition
    657  624a
    658  624a		       60		      rts
    659  624b
    660  624b				   bProcComp
    661  624b							;------------------------------------------------------------------------------
    662  624b
    663  624b							; control the scrolling via the joystick
    664  624b
    665  624b		       a5 ab		      lda	ManLastDirection
    666  624d		       29 07		      and	#DIRECTION_BITS
    667  624f		       a8		      tay
    668  6250
    669  6250		       a5 93		      lda	BufferedJoystick	; joystick
    670  6252		       25 94		      and	BufferedJoystick+1
    671  6254
    672  6254		       a2 00		      ldx	#0
    673  6256		       0a	   .loopDirs  asl
    674  6257		       90 1a		      bcc	.dirFound
    675  6259		       88		      dey
    676  625a		       e8		      inx
    677  625b		       e0 04		      cpx	#4
    678  625d		       d0 f7		      bne	.loopDirs
    679  625f
    680  625f							; no direction!
    681  625f
    682  625f		       a9 82		      lda	#ANIMATION_IDLE_ID
    683  6261		       c5 ae		      cmp	ManAnimationID
    684  6263		       f0 0e		      beq	alreadyIdling
    685  6265		       85 ae		      sta	ManAnimationID
      0  6267					      LOAD_ANIMATION	Animation_IDLE
      1  6267		       a9 20		      lda	#<Animation_IDLE
      2  6269		       85 9f		      sta	animation
      3  626b		       a9 f0		      lda	#>Animation_IDLE
      4  626d		       85 a0		      sta	animation+1
      5  626f		       a9 ff		      lda	#-1
      6  6271		       85 a1		      sta	animation_delay
    687  6273				   alreadyIdling
    688  6273
    689  6273
    690  6273
    691  6273
    692  6273				   .dirFound
    693  6273
    694  6273		       bd c5 f2 	      lda	anim_direction,x
    695  6276		       30 04		      bmi	dontChange
    696  6278
    697  6278		       c5 ab		      cmp	ManLastDirection
    698  627a		       85 ab		      sta	ManLastDirection
    699  627c							;bne skipMove
    700  627c				   dontChange
    701  627c
    702  627c		       18		      clc
    703  627d		       a5 8a		      lda	POS_X_NEW
    704  627f		       7d c0 f2 	      adc	JoyDirX,x
    705  6282		       85 8a		      sta	POS_X_NEW
    706  6284
    707  6284		       18		      clc
    708  6285		       a5 8b		      lda	POS_Y_NEW
    709  6287		       7d be f2 	      adc	JoyDirY,x
    710  628a		       85 8b		      sta	POS_Y_NEW
    711  628c
    712  628c		       98	   skipMove   tya
    713  628d		       f0 12		      beq	noMovement	; animation OK
    714  628f
    715  628f		       8a		      txa
    716  6290		       45 ab		      eor	ManLastDirection
    717  6292		       29 07		      and	#DIRECTION_BITS
    718  6294		       45 ab		      eor	ManLastDirection
    719  6296		       85 ab		      sta	ManLastDirection
    720  6298		       bd a2 f2 	      lda	ManAnimTblLo,x
    721  629b		       85 a8		      sta	ManAnimation
    722  629d							;lda ManAnimTblHi,x
    723  629d							;sta ManAnimation+1
    724  629d		       a9 00		      lda	#0
    725  629f		       85 a7		      sta	ManDelayCount
    726  62a1				   phase0		;jsr MovePlayer
    727  62a1				   noMovement		;ldx MAN_Player
    728  62a1
    729  62a1		       60	   DFS_rts    rts
    730  62a2
    731  62a2
    732  62a2				   ManAnimTblLo
    733  62a2		       00 00 00 00*	      .byte.b	AnimateRIGHT-Manimate, AnimateLEFT-Manimate, AnimateUP-Manimate, AnimateUP-Manimate, AnimateSTOPPED-Manimate
    734  62a7							;ManAnimTblHi
    735  62a7							;    .byte   >AnimateRIGHT, >AnimateLEFT, >AnimateUP, >AnimateUP, >AnimateSTOPPED
    736  62a7
    737  62a7
    738  62a7
    739  62a7		       00 00 00 00*JoyMoveX   .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1	;,0, 0,0,0
    740  62b3		       00 00 00 00*JoyMoveY   .byte.b	0,0,0,0,0,1,-1,0,0, 1,-1	;, 0,0,1,-1,0
    741  62be
    742  62be				   JoyDirY
    743  62be		       00 00		      .byte.b	0,0	;,1,-1,0
    744  62c0				   JoyDirX
    745  62c0		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
    746  62c5
    747  62c5							;Data Bit  Direction Player
    748  62c5							;		 D7	   right	  P0  D4
    749  62c5							;		 D6	   left      P0  D3
    750  62c5							;		 D5	   down      P0  D2
    751  62c5							;		 D4	   up	     P0  D1
    752  62c5							;     A "0" in a data bit indicates the joystick has been moved
    753  62c5							;     to close that switch.  All "1's" in a player's nibble
    754  62c5							;     indicates that joystick is not moving.
    755  62c5
    756  62c5							;0  0000 x
    757  62c5							;1  0001 x
    758  62c5							;2  0010 x
    759  62c5							;3  0011 x
    760  62c5							;4  0100 x
    761  62c5							;5  0101 right down
    762  62c5							;6  0110 right up
    763  62c5							;7  0111 right
    764  62c5							;8  1000 x
    765  62c5							;9  1001 left down
    766  62c5							;10  1010 left up
    767  62c5							;11  1011 left
    768  62c5							;12  1100 x
    769  62c5							;13  1101 down
    770  62c5							;14  1110 up
    771  62c5							;15  1111 none
    772  62c5
    773  62c5		       00 0c 80 80*anim_direction .byte.b	0,%1100,128,128,128
    774  62ca
    775  62ca							;------------------------------------------------------------------------------
    776  62ca
    777  62ca
      0  62ca					      DEFINE_SUBROUTINE	DrawFullScreen	; = 2568[-96]
      1  62ca		       00 0c	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  62ca					      SUBROUTINE
      3  62ca				   DrawFullScreen
    779  62ca
    780  62ca							; 83[-7] + 2484[-89] = 2567[-96]
    781  62ca
    782  62ca
    783  62ca		       ad 84 02 	      lda	INTIM	; 4
    784  62cd		       c9 28		      cmp	#SEGTIME_BDF	; 2
    785  62cf		       90 d0		      bcc	DFS_rts	; 2/3
      0  62d1					      STRESS_TIME	SEGTIME_BDF
      1  62d1				  -	      IF	TEST_SEGTIME_BDF = 1
      2  62d1				  -
      3  62d1				  -
      4  62d1				  -
      5  62d1				  -
      6  62d1				  -
      7  62d1				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  62d1				  -	      bne	. - 7
      9  62d1					      ENDIF
    787  62d1
    788  62d1		       a9 f4		      lda	#>( DrawFlag + RAM_WRITE )	; 2
    789  62d3		       85 e3		      sta	BDF_DrawFlagAddress+1	; 3
    790  62d5		       85 e5		      sta	BDF_DrawFlagAddress2+1	; 3
    791  62d7
    792  62d7		       ba		      tsx		; 2
    793  62d8		       86 ec		      stx	DHS_Stack	; 3
    794  62da
    795  62da		       e6 87		      inc	ScreenDrawPhase	; 5
    796  62dc
    797  62dc		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
    798  62dd		       a2 08		      ldx	#SCREEN_LINES	; 2
    799  62df		       8a		      txa		; 2 = *32
    800  62e0
    801  62e0							; fall through
    802  62e0
    803  62e0							;------------------------------------------------------------------------------
    804  62e0
      0  62e0					      DEFINE_SUBROUTINE	DrawScreenRowPreparation	; = *59[-7 if not multi-bank-board]
      1  62e0		       00 0c	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  62e0					      SUBROUTINE
      3  62e0				   DrawScreenRowPreparation
    806  62e0
    807  62e0							;clc
    808  62e0		       ca		      dex		; 2
    809  62e1		       86 eb		      stx	DHS_Line	; 3
    810  62e3		       65 99		      adc	BoardScrollY	; 3	     the Y offset of screen into board
    811  62e5		       a8		      tay		; 2 = 10
    812  62e6
    813  62e6							;clc
    814  62e6		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
    815  62e9		       65 9a		      adc	BoardScrollX	; 3	     the X offset of screen into board
    816  62eb		       85 e6		      sta	BDF_BoardAddress	; 3
    817  62ed		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    818  62ef		       85 e8		      sta	BDF_BoardAddress2	; 3
    819  62f1
    820  62f1		       b9 14 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
    821  62f4		       85 e7		      sta	BDF_BoardAddress+1	; 3
    822  62f6		       85 e9		      sta	BDF_BoardAddress2+1	; 3 = 25
    823  62f8
    824  62f8		       bd af f0 	      lda	DrawLineStartLO,x	; 4
    825  62fb		       85 e2		      sta	BDF_DrawFlagAddress	; 3
    826  62fd		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    827  62ff		       85 e4		      sta	BDF_DrawFlagAddress2	; 3 = 12
    828  6301
    829  6301				  -	      IF	MULTI_BANK_BOARD = YES
    830  6301				  -	      lda	BoardBank-1,y	; 4
    831  6301				  -	      sta	BDF_BoardBank	; 3
    832  6301					      ENDIF
    833  6301		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
    834  6303		       4c 7a fb 	      jmp	CopyRow2	; 3 = 12[-7]
    835  6306
    836  6306							;------------------------------------------------------------------------------
    837  6306
      0  6306					      DEFINE_SUBROUTINE	EOL
      1  6306		       00 0c	   BANK_EOL   =	_CURRENT_BANK
      2  6306					      SUBROUTINE
      3  6306				   EOL
    839  6306
    840  6306		       a9 14		      lda	#20
    841  6308		       85 af		      sta	DelayEndOfLevel
    842  630a		       a5 81		      lda	Platform
    843  630c		       85 cc		      sta	ColourFlash	; green
    844  630e		       a9 04		      lda	#4
    845  6310		       85 cb		      sta	ColourTimer
    846  6312
      0  6312					      LOAD_ANIMATION	Animation_WIN
      1  6312		       a9 13		      lda	#<Animation_WIN
      2  6314		       85 9f		      sta	animation
      3  6316		       a9 f0		      lda	#>Animation_WIN
      4  6318		       85 a0		      sta	animation+1
      5  631a		       a9 ff		      lda	#-1
      6  631c		       85 a1		      sta	animation_delay
    848  631e
    849  631e		       a9 08		      lda	#MANMODE_NEXTLEVEL2
    850  6320		       85 a6		      sta	ManMode
    851  6322		       60		      rts
    852  6323
    853  6323
      0  6323					      DEFINE_SUBROUTINE	IMC
      1  6323		       00 0c	   BANK_IMC   =	_CURRENT_BANK
      2  6323					      SUBROUTINE
      3  6323				   IMC
    855  6323
    856  6323		       18		      clc
    857  6324		       a5 c0		      lda	takebackIndex
    858  6326		       69 01		      adc	#1
    859  6328		       29 3f		      and	#TAKEBACK_MASK
    860  632a		       85 c0		      sta	takebackIndex
    861  632c		       c5 c1		      cmp	takebackBaseIndex
    862  632e		       d0 06		      bne	baseOK
    863  6330		       69 00		      adc	#0
    864  6332		       29 3f		      and	#TAKEBACK_MASK
    865  6334		       85 c1		      sta	takebackBaseIndex
    866  6336				   baseOK
    867  6336
    868  6336		       f8		      sed
    869  6337		       18		      clc
    870  6338		       a5 be		      lda	BCD_moveCounter
    871  633a		       69 01		      adc	#1
    872  633c		       85 be		      sta	BCD_moveCounter
    873  633e		       a5 bf		      lda	BCD_moveCounter+1
    874  6340		       69 00		      adc	#0
    875  6342		       85 bf		      sta	BCD_moveCounter+1
    876  6344		       d8		      cld
    877  6345
    878  6345		       60		      rts
    879  6346
    880  6346
      0  6346					      DEFINE_SUBROUTINE	VectorProcess	;=19(A)
      1  6346		       00 0c	   BANK_VectorProcess =	_CURRENT_BANK
      2  6346					      SUBROUTINE
      3  6346				   VectorProcess
    882  6346
    883  6346							;sta ROM_Bank			  ;3		  processors can assume bank is stored
    884  6346
    885  6346		       bd 54 f3 	      lda	OSPointerHI,x	;4
    886  6349		       85 e3		      sta	POS_Vector+1	;3
    887  634b		       bd 53 f3 	      lda	OSPointerLO,x	;4
    888  634e		       85 e2		      sta	POS_Vector	;3
    889  6350
    890  6350		       6c e2 00 	      jmp	(POS_Vector)	;5 = 19	 vector to processor for particular object type
    891  6353							;		 NOTE: Bank is either INITBANK or FIXED.
    892  6353
    893  6353
    894  6353				   OBJTYPE    SET	0
    895  6353					      MAC	define
    896  6353				   TYPE_{1}   =	OBJTYPE
    897  6353				   OBJTYPE    .SET	OBJTYPE + 1
    898  6353					      ENDM
    899  6353
    900  6353							; If adding/removing types, the following must also be updated...
    901  6353							;   InitialFace[...]		     in UnpackLevel.asm
    902  6353							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
    903  6353							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
    904  6353							;   OSPointerLO[...]		     in BANK_INITBANK.asm
    905  6353							;   OSPointerHI[...]		     in BANK_INITBANK.asm
    906  6353							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
    907  6353							;   Sortable[...]		     in BANK_FIXED.asm
    908  6353
    909  6353
      0  6353					      DEFINE	MAN
      1  6353		       00 00	   TYPE_MAN   =	OBJTYPE
      2  6353				   OBJTYPE    .SET	OBJTYPE + 1
    911  6353							;DEFINE CIRCLE
    912  6353							;DEFINE CIRCLE_HELPER
    913  6353							;DEFINE CIRCLE_DRAWER
    914  6353
      0  6353					      DEFINE	MAXIMUM
      1  6353		       00 01	   TYPE_MAXIMUM =	OBJTYPE
      2  6353				   OBJTYPE    .SET	OBJTYPE + 1
    916  6353
    917  6353
      0  6353					      DEFINE_SUBROUTINE	OSPointerLO
      1  6353		       00 0c	   BANK_OSPointerLO =	_CURRENT_BANK
      2  6353					      SUBROUTINE
      3  6353				   OSPointerLO
    919  6353		       d0		      .byte.b	<PROCESS_MAN
    920  6354							;.byte <PROCESS_CIRCLE
    921  6354							;.byte <PROCESS_CIRCLE_HELPER
    922  6354
    923  6354				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
    924  6354				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
    925  6354				  -	      ERR
    926  6354					      ENDIF
    927  6354
    928  6354
      0  6354					      DEFINE_SUBROUTINE	OSPointerHI
      1  6354		       00 0c	   BANK_OSPointerHI =	_CURRENT_BANK
      2  6354					      SUBROUTINE
      3  6354				   OSPointerHI
    930  6354		       f8		      .byte.b	>PROCESS_MAN
    931  6355							;.byte >PROCESS_CIRCLE
    932  6355							;.byte >PROCESS_CIRCLE_HELPER
    933  6355
    934  6355				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
    935  6355				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
    936  6355				  -	      ERR
    937  6355					      ENDIF
    938  6355
    939  6355							;------------------------------------------------------------------------------
    940  6355
      0  6355					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  6355		       00 0c	   BANK_MoveVecLO =	_CURRENT_BANK
      2  6355					      SUBROUTINE
      3  6355				   MoveVecLO
    942  6355
    943  6355		       b9		      .byte.b	<MOVE_BLANK
    944  6356		       b9		      .byte.b	<MOVE_SOIL
    945  6357		       08		      .byte.b	<MOVE_BOX
    946  6358		       b9		      .byte.b	<MOVE_TARGET
    947  6359		       b9		      .byte.b	<MOVE_TARGET
    948  635a		       f7		      .byte.b	<MOVE_GENERIC	;man occupied
    949  635b		       f7		      .byte.b	<MOVE_GENERIC	;steel
    950  635c		       f7		      .byte.b	<MOVE_GENERIC	;wall
    951  635d		       11		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
    952  635e		       f7		      .byte.b	<MOVE_GENERIC	;nogo
    953  635f
    954  635f				  -	      if	DIGITS
    955  635f				  -	      REPEAT	10	; DIGITS 0-9
    956  635f				  -	      .byte	<MOVE_BLANK
    957  635f				  -	      REPEND
    958  635f					      endif
    959  635f
    960  635f				  -	      if	TROPHY
    961  635f				  -	      REPEAT	20	; 4x5
    962  635f				  -	      .byte	<MOVE_BLANK
    963  635f				  -	      REPEND
    964  635f					      endif
    965  635f
    966  635f				  -	      IF	* - MoveVecLO != CHARACTER_MAXIMUM
    967  635f				  -	      ECHO	"ERROR: Incorrect number of entries in MoveVecLO table!"
    968  635f				  -	      ERR
    969  635f					      ENDIF
    970  635f
    971  635f
      0  635f					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  635f		       00 0c	   BANK_MoveVecHI =	_CURRENT_BANK
      2  635f					      SUBROUTINE
      3  635f				   MoveVecHI
    973  635f
    974  635f		       f9		      .byte.b	>MOVE_BLANK
    975  6360		       f9		      .byte.b	>MOVE_SOIL
    976  6361		       fa		      .byte.b	>MOVE_BOX
    977  6362		       f9		      .byte.b	>MOVE_TARGET
    978  6363		       f9		      .byte.b	>MOVE_TARGET
    979  6364		       f9		      .byte.b	>MOVE_GENERIC	;man occupied
    980  6365		       f9		      .byte.b	>MOVE_GENERIC	;steel
    981  6366		       f9		      .byte.b	>MOVE_GENERIC	;wall
    982  6367		       fa		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
    983  6368		       f9		      .byte.b	>MOVE_GENERIC	;nogo
    984  6369
    985  6369				  -	      if	DIGITS
    986  6369				  -	      REPEAT	10	; DIGITS 0-9
    987  6369				  -	      .byte	>MOVE_BLANK
    988  6369				  -	      REPEND
    989  6369					      endif
    990  6369
    991  6369				  -	      if	TROPHY
    992  6369				  -	      REPEAT	20	; 4x5
    993  6369				  -	      .byte	>MOVE_BLANK
    994  6369				  -	      REPEND
    995  6369					      endif
    996  6369
    997  6369				  -	      IF	* - MoveVecHI != CHARACTER_MAXIMUM
    998  6369				  -	      ECHO	"ERROR: Incorrect number of entries in MoveVecHI table!"
    999  6369				  -	      ERR
   1000  6369					      ENDIF
   1001  6369
   1002  6369
      0  6369					      CHECK_BANK_SIZE	"INITBANK"
      1  6369		       03 69	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $369 , FREE= $497
      2  6369					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  6369				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  6369				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  6369				  -	      ERR
      6  6369					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_FIXED.asm LEVEL 2 PASS 4
      0  6369					      include	"BANK_FIXED.asm"
      1  6369							;    Sokoboo - a Sokoban implementation
      2  6369							;    using a generic tile-based display engine for the Atari 2600
      3  6369							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  6369							;
      5  6369							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  6369							;
      7  6369							;    Code related to the generic tile-based display engine was developed by
      8  6369							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  6369							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  6369							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  6369							;
     12  6369							;    Code related to music and sound effects uses the TIATracker music player
     13  6369							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  6369							;    directory for Apache licensing details.
     15  6369							;
     16  6369							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  6369							;    See the copyright notices in the License directory for a list of level
     18  6369							;    contributors.
     19  6369							;
     20  6369							;    Except where otherwise indicated, this software is released under the
     21  6369							;    following licensing arrangement...
     22  6369							;
     23  6369							;    This program is free software: you can redistribute it and/or modify
     24  6369							;    it under the terms of the GNU General Public License as published by
     25  6369							;    the Free Software Foundation, either version 3 of the License, or
     26  6369							;    (at your option) any later version.
     27  6369							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  6369
     29  6369							;    This program is distributed in the hope that it will be useful,
     30  6369							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  6369							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  6369							;    GNU General Public License for more details.
     33  6369
     34  6369							;------------------------------------------------------------------------------
     35  6369							;###############################  FIXED BANK  #################################
     36  6369							;------------------------------------------------------------------------------
     37  6369
     38  6369
     39  6369				   ORIGIN     SET	FIXED_BANK
     40  6369
      0  6369					      NEWBANK	THE_FIXED_BANK
      1  7fd8 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
     42  7800					      RORG	$f800
     43  7800
     44  7800
     45  7800
     46  7800							;------------------------------------------------------------------------------
     47  7800
      0  7800					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  7800		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  7800					      SUBROUTINE
      3  7800				   DrawTimeFromROM
     49  7800
     50  7800		       a9 09		      lda	#BANK_SCORING
     51  7802		       85 3e		      sta	SET_BANK_RAM
     52  7804		       20 c1 f2 	      jsr	DrawTime
     53  7807		       20 ac f2 	      jsr	DrawBCD_targetsRequired
     54  780a		       a5 c9		      lda	ROM_Bank
     55  780c		       85 3f		      sta	SET_BANK
     56  780e		       60		      rts
     57  780f
     58  780f							;------------------------------------------------------------------------------
     59  780f
      0  780f					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  780f		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  780f					      SUBROUTINE
      3  780f				   GetROMByte
     61  780f
     62  780f							; a = ROM bank to retrieve
     63  780f							; y = page index
     64  780f							; ROM_Bank = bank to return to
     65  780f							; (Board_AddressR) = page
     66  780f							; out a = byte from (Board_AddressR)
     67  780f
     68  780f		       85 3f		      sta	SET_BANK	;3
     69  7811		       4c 16 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
     70  7814
     71  7814							;------------------------------------------------------------------------------
     72  7814
      0  7814					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7814		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7814					      SUBROUTINE
      3  7814				   GetBoardCharacter
     74  7814
     75  7814							; call from ROM bank
     76  7814							; switches back to ROM_Bank on exit
     77  7814
     78  7814							; pass A = bank containing character
     79  7814							; Y = x character position
     80  7814							; (Board_AddressR) points to character position
     81  7814							; returns character from board
     82  7814
     83  7814
     84  7814		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
     85  7816
     86  7816				   GetBoardCharacter2		;=17(A)
     87  7816
     88  7816		       b3 c5		      lax	(Board_AddressR),y	;5
     89  7818		       a4 c9		      ldy	ROM_Bank	;3
     90  781a		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
     91  781c		       60		      rts		;6   and go back
     92  781d
     93  781d							;---------------------------------------------------------------------------
     94  781d
      0  781d					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  781d		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  781d					      SUBROUTINE
      3  781d				   PutBoardCharacter
     96  781d
     97  781d		       86 3e		      stx	SET_BANK_RAM	; 3
     98  781f
     99  781f				   PutBoardCharacterSB		; =18
    100  781f		       91 c7		      sta	(Board_AddressW),y	; 6
    101  7821		       a5 c9		      lda	ROM_Bank	; 3
    102  7823		       85 3f		      sta	SET_BANK	; 3
    103  7825		       60		      rts		; 6 = 21
    104  7826
    105  7826							;---------------------------------------------------------------------------
    106  7826
      0  7826					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  7826		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  7826					      SUBROUTINE
      3  7826				   GetBoardCharacter__CALL_FROM_RAM__
    108  7826
    109  7826		       a4 89		      ldy	POS_Y	;3
    110  7828
    111  7828		       a9 0c		      lda	#BANK_GetBoardAddressR	;
    112  782a		       85 3f		      sta	SET_BANK	;
    113  782c		       20 ca f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    114  782f
    115  782f
    116  782f							;DEFINE_SUBROUTINE PartialGetBoardCharacter ;=23
    117  782f
    118  782f		       85 3e		      sta	SET_BANK_RAM	;3
    119  7831		       a4 88		      ldy	POS_X	;3
    120  7833		       b3 c5		      lax	(Board_AddressR),y	;5
    121  7835		       a4 ca		      ldy	RAM_Bank	;3
    122  7837		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    123  7839		       60		      rts		;6		 and go back
    124  783a
    125  783a							;---------------------------------------------------------------------------
    126  783a
      0  783a					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  783a		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  783a					      SUBROUTINE
      3  783a				   PutBoardCharacterFromRAM
    128  783a
    129  783a							; POS_Y  = row
    130  783a							; POS_Type = character to write
    131  783a							; POS_X     = column
    132  783a							; RAM_Bank = caller's bank
    133  783a
    134  783a		       a4 89		      ldy	POS_Y	;3
    135  783c
    136  783c		       a9 0c		      lda	#BANK_GetBoardAddressW	;
    137  783e		       85 3f		      sta	SET_BANK	;
    138  7840		       20 d7 f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
    139  7843
    140  7843		       86 3e		      stx	SET_BANK_RAM	;3
    141  7845
    142  7845		       a4 88		      ldy	POS_X	;3
    143  7847		       a5 8c		      lda	POS_Type	;3
    144  7849		       91 c7		      sta	(Board_AddressW),y	;6
    145  784b		       a4 ca		      ldy	RAM_Bank	;3
    146  784d		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    147  784f		       60		      rts		;6
    148  7850
    149  7850
      0  7850					      DEFINE_SUBROUTINE	PutBoardCharacterFromROM
      1  7850		       00 0f	   BANK_PutBoardCharacterFromROM =	_CURRENT_BANK
      2  7850					      SUBROUTINE
      3  7850				   PutBoardCharacterFromROM
    151  7850		       48		      pha
    152  7851		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    153  7854		       68		      pla
    154  7855		       85 3f		      sta	SET_BANK
    155  7857		       60		      rts
    156  7858
    157  7858							;---------------------------------------------------------------------------
    158  7858
      0  7858					      DEFINE_SUBROUTINE	ProcessObjStack	; 15 minimum segtime abort
      1  7858		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  7858					      SUBROUTINE
      3  7858				   ProcessObjStack
    160  7858
    161  7858		       ad 84 02 	      lda	INTIM	;4
    162  785b		       c9 02		      cmp	#MINIMUM_SEGTIME	;2
    163  785d		       90 3b		      bcc	EarlyAbort	;2/3= 8
      0  785f					      STRESS_TIME	MINIMUM_SEGTIME
      1  785f				  -	      IF	TEST_MINIMUM_SEGTIME = 1
      2  785f				  -
      3  785f				  -
      4  785f				  -
      5  785f				  -
      6  785f				  -
      7  785f				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  785f				  -	      bne	. - 7
      9  785f					      ENDIF
    165  785f
    166  785f		       a5 83		      lda	ObjStackNum	;3
    167  7861		       49 01		      eor	#1	;2
    168  7863		       aa		      tax		;2
    169  7864
    170  7864		       a5 d3		      lda	ObjIterator	;3
    171  7866		       d5 84		      cmp	ObjStackPtr,x	;5
    172  7868		       b0 2e		      bcs	nextPhase	;2/3
    173  786a
    174  786a
    175  786a							; Process an object...
    176  786a							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    177  786a
    178  786a		       bc 5a f9 	      ldy	BankObjStack,x	;4
    179  786d		       84 3e		      sty	SET_BANK_RAM	;3
    180  786f
    181  786f		       aa		      tax		;2
    182  7870		       bc 80 11 	      ldy	SortedObjPtr,x	;4		 indirect object pointer list (sorted)
    183  7873
    184  7873		       b9 00 10 	      lda	ObjStackX,y	;4
    185  7876		       85 88		      sta	POS_X	;3
    186  7878		       b9 80 10 	      lda	ObjStackY,y	;4
    187  787b		       85 89		      sta	POS_Y	;3
    188  787d		       b9 00 11 	      lda	ObjStackVar,y	;4
    189  7880		       85 8d		      sta	POS_VAR	;3
    190  7882		       be 00 12 	      ldx	ObjStackType,y	;4
    191  7885		       86 8c		      stx	POS_Type	;3
    192  7887
    193  7887		       a9 0c		      lda	#BANK_VectorProcess	;2
    194  7889		       85 3f		      sta	SET_BANK	;3
    195  788b
    196  788b		       bd 54 f3 	      lda	OSPointerHI,x	;4
    197  788e		       85 e3		      sta	POS_Vector+1	;3
    198  7890		       bd 53 f3 	      lda	OSPointerLO,x	;4
    199  7893		       85 e2		      sta	POS_Vector	;3
    200  7895
    201  7895		       6c e2 00 	      jmp	(POS_Vector)	;5 = 87	 vector to processor for particular object type
    202  7898
    203  7898
    204  7898							;---------------------------------------------------------------------------
    205  7898							; Now process the blank stack.  This stack holds all the recently blanked squares
    206  7898							; and determines (and moves) BOXs or TARGETs into these squares.  The space vacated
    207  7898							; by these objects are added again to the blank stack.
    208  7898
    209  7898				   nextPhase
    210  7898
    211  7898							;clc
    212  7898							;lda circle_d
    213  7898							;adc #255
    214  7898							;sta circle_d
    215  7898							;bcc nocirc
    216  7898							;nocirc
    217  7898
    218  7898		       e6 87		      inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    219  789a		       60	   EarlyAbort rts		;6
    220  789b
    221  789b							;---------------------------------------------------------------------------
    222  789b
      0  789b					      DEFINE_SUBROUTINE	SwitchObjects	;=72
      1  789b		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  789b					      SUBROUTINE
      3  789b				   SwitchObjects
    224  789b
    225  789b							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    226  789b							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    227  789b							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    228  789b
    229  789b		       ad 84 02 	      lda	INTIM	; 4
    230  789e		       c9 02		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    231  78a0		       90 f8		      bcc	EarlyAbort	; 2/3= 8
      0  78a2					      STRESS_TIME	SEGTIME_SWITCHOBJECTS
      1  78a2				  -	      IF	TEST_SEGTIME_SWITCHOBJECTS = 1
      2  78a2				  -
      3  78a2				  -
      4  78a2				  -
      5  78a2				  -
      6  78a2				  -
      7  78a2				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  78a2				  -	      bne	. - 7
      9  78a2					      ENDIF
    233  78a2
    234  78a2							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    235  78a2							; we're at the throttle cutoff do we switch game-frames.
    236  78a2
    237  78a2							;sec
    238  78a2		       a5 bb		      lda	Throttle	;3
    239  78a4		       e9 a0		      sbc	#MAX_THROTTLE	;2
    240  78a6		       90 f2		      bcc	EarlyAbort	;2/3		 plenty of time left!
    241  78a8
    242  78a8							; Time is up. But we may be in a level which requires perfect sorting
    243  78a8							; So we check for these levels, and wait for the sort to complete for those.
    244  78a8
    245  78a8		       24 ba		      bit	levelDisplay	;3
    246  78aa		       50 08		      bvc	keepFractional	;2/3		 screen does not require complete sort
    247  78ac
    248  78ac							; We have a level which requires the sort to go to completion
    249  78ac							; Check to see if the sort is finished...
    250  78ac
    251  78ac		       a4 d2		      ldy	sortPtr	;3
    252  78ae		       d0 ea		      bne	EarlyAbort	;2/3		 sort still in progress, so wait
    253  78b0		       a4 d1		      ldy	sortRequired	;3
    254  78b2		       10 e6		      bpl	EarlyAbort	;2/3		 sort still in progress, so wait
    255  78b4
    256  78b4		       85 bb	   keepFractional sta	Throttle	;3		 save fractional 'left over' bit
    257  78b6
    258  78b6							; Pause the game with B/W switch:
    259  78b6
    260  78b6		       a5 80		      lda	gameMode
    261  78b8		       30 14		      bmi	.paused	; pause flag set
    262  78ba
    263  78ba							; Now that we have completed processing the object stack, we switch
    264  78ba							; the stack bank pointers for the next time around.
    265  78ba
    266  78ba		       a5 83		      lda	ObjStackNum	;3
    267  78bc		       49 01		      eor	#1	;2
    268  78be		       aa		      tax		;2
    269  78bf		       86 83		      stx	ObjStackNum	;3		 swap stacks @here
    270  78c1
    271  78c1							; STOP the sort so it doesn't corrupt the "other" object stack. Sort may get a look-in immediately after
    272  78c1							; this code is finished, so we don't want it to do something unexpected!
    273  78c1
    274  78c1		       a0 ff		      ldy	#<(-1)	;2
    275  78c3		       84 d1		      sty	sortRequired	;3
    276  78c5		       c8		      iny		;2		 Y==0
    277  78c6		       84 d2		      sty	sortPtr	;3
    278  78c8
    279  78c8							; Initialise the iterator and stack pointer for next time around.
    280  78c8							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    281  78c8							; necessary to initialise both.
    282  78c8
    283  78c8		       84 d3		      sty	ObjIterator	;3		 Y==0
    284  78ca		       94 84		      sty	ObjStackPtr,x	;4
    285  78cc
    286  78cc		       84 87		      sty	ScreenDrawPhase	;3
    287  78ce				   .paused
    288  78ce		       60	   quickExit  rts		;6
    289  78cf
    290  78cf							;---------------------------------------------------------------------------
    291  78cf
    292  78cf				  -	      if	0
    293  78cf				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE_DRAWER
    294  78cf				  -
    295  78cf				  -	      ldy	#CHARACTER_BLANK
    296  78cf				  -	      lda	circle_d+1
    297  78cf				  -			;jsr DrawCircle
    298  78cf				  -			;bcc finCircle
    299  78cf				  -			;lda #TYPE_CIRCLE_DRAWER
    300  78cf				  -			;sta POS_Type
    301  78cf				  -			;jsr InsertObjectStack
    302  78cf				  -finCircle  jmp	NextObject
    303  78cf				  -
    304  78cf				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE_HELPER
    305  78cf				  -
    306  78cf				  -	      lda	INTIM
    307  78cf				  -	      cmp	#SEGTIME_CIRCLE_HELPER
    308  78cf				  -	      bcc	EarlyAbort
    309  78cf				  -
    310  78cf				  -
    311  78cf				  -	      jmp	NextObject	; and die
    312  78cf				  -
    313  78cf				  -
    314  78cf				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE
    315  78cf				  -
    316  78cf				  -	      lda	INTIM
    317  78cf				  -	      cmp	#SEGTIME_CIRCLE
    318  78cf				  -	      bcc	EarlyAbort
    319  78cf				  -
    320  78cf				  -	      clc
    321  78cf				  -	      lda	circle_d
    322  78cf				  -	      adc	#255
    323  78cf				  -	      sta	circle_d
    324  78cf				  -	      bcc	inactiveCircle
    325  78cf				  -
    326  78cf				  -	      inc	circle_d+1
    327  78cf				  -	      lda	circle_d+1
    328  78cf				  -	      cmp	#20
    329  78cf				  -	      beq	circleComplete
    330  78cf				  -			; time to fire off another "ring" of the clearing circle
    331  78cf				  -
    332  78cf				  -			;sta POS_VAR		    ; diameter for helper to use
    333  78cf				  -			;lda #TYPE_CIRCLE_HELPER
    334  78cf				  -			;sta POS_Type
    335  78cf				  -			;jsr InsertObjectStack
    336  78cf				  -
    337  78cf				  -
    338  78cf				  -			; a = radius
    339  78cf				  -
    340  78cf				  -	      ldy	#CHARACTER_BLANK
    341  78cf				  -	      sty	circ_char
    342  78cf				  -
    343  78cf				  -	      lda	circle_d+1
    344  78cf				  -	      sec
    345  78cf				  -	      sbc	#1
    346  78cf				  -	      sta	circ_x
    347  78cf				  -	      eor	#255
    348  78cf				  -	      clc
    349  78cf				  -	      adc	#1
    350  78cf				  -	      sta	circ_scratch	; "d" --> "1-r" in unit terms
    351  78cf				  -
    352  78cf				  -	      lda	#0
    353  78cf				  -	      sta	circ_y
    354  78cf				  -
    355  78cf				  -			;lda circle_d+1		     ; radius
    356  78cf				  -			;lda #TYPE_CIRCLE_DRAWER
    357  78cf				  -			;sta POS_Type
    358  78cf				  -			;jsr InsertObjectStack
    359  78cf				  -
    360  78cf				  -	      ldy	#CHARACTER_BLANK
    361  78cf				  -	      lda	circle_d+1
    362  78cf				  -			;	      sec
    363  78cf				  -			;	      sbc #1
    364  78cf				  -	      jsr	DrawCircle
    365  78cf				  -
    366  78cf				  -			;	      ldy #CHARACTER_STEEL
    367  78cf				  -			;		sty circ_char
    368  78cf				  -	      lda	circle_d+1
    369  78cf				  -	      sta	circ_x
    370  78cf				  -	      eor	#255
    371  78cf				  -	      clc
    372  78cf				  -	      adc	#1
    373  78cf				  -	      sta	circ_scratch	; "d" --> "1-r" in unit terms
    374  78cf				  -
    375  78cf				  -	      lda	#0
    376  78cf				  -	      sta	circ_y
    377  78cf				  -
    378  78cf				  -			;lda circle_d+1		     ; radius
    379  78cf				  -			;lda #TYPE_CIRCLE_DRAWER
    380  78cf				  -			;sta POS_Type
    381  78cf				  -			;jsr InsertObjectStack
    382  78cf				  -
    383  78cf				  -			;	      ldy #CHARACTER_BLANK
    384  78cf				  -			;	      lda circle_d+1
    385  78cf				  -			;	      ;jsr DrawCircle
    386  78cf				  -
    387  78cf				  -
    388  78cf				  -
    389  78cf				  -			;			      inc circle_d+1
    390  78cf				  -			;			      ldy #CHARACTER_STEEL
    391  78cf				  -			;			      lda circle_d+1
    392  78cf				  -			;			      jsr DrawCircle
    393  78cf				  -
    394  78cf				  -inactiveCircle lda	#TYPE_CIRCLE
    395  78cf				  -	      sta	POS_Type
    396  78cf				  -	      jsr	InsertObjectStack
    397  78cf				  -
    398  78cf				  -circleComplete jmp	NextObject
    399  78cf					      endif
    400  78cf
    401  78cf							;---------------------------------------------------------------------------
    402  78cf
    403  78cf		       60	   EarlyAbort4 rts
    404  78d0
      0  78d0					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  78d0		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  78d0					      SUBROUTINE
      3  78d0				   PROCESS_MAN
    406  78d0
    407  78d0		       ad 84 02 	      lda	INTIM
    408  78d3		       c9 10		      cmp	#SEGTIME_MAN
    409  78d5		       90 f8		      bcc	EarlyAbort4
      0  78d7					      STRESS_TIME	SEGTIME_MAN
      1  78d7				  -	      IF	TEST_SEGTIME_MAN = 1
      2  78d7				  -
      3  78d7				  -
      4  78d7				  -
      5  78d7				  -
      6  78d7				  -
      7  78d7				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  78d7				  -	      bne	. - 7
      9  78d7					      ENDIF
    411  78d7
    412  78d7		       a9 0c		      lda	#BANK_ManProcess
    413  78d9		       85 c9		      sta	ROM_Bank
    414  78db		       85 3f		      sta	SET_BANK
    415  78dd		       20 a4 f1 	      jsr	ManProcess
    416  78e0
    417  78e0		       a9 ff		      lda	#-1
    418  78e2		       85 92		      sta	TB_CHAR	; pre-set box takeback to NONE
    419  78e4
    420  78e4		       20 5c f9 	      jsr	MovePlayer	; 6+{}
    421  78e7
    422  78e7		       a5 a6		      lda	ManMode
    423  78e9		       c9 07		      cmp	#MANMODE_NEXTLEVEL	; kludge
    424  78eb		       b0 08		      bcs	notComplete
    425  78ed		       a5 bd		      lda	BCD_targetsRequired
    426  78ef		       d0 04		      bne	notComplete
    427  78f1		       a9 07		      lda	#MANMODE_NEXTLEVEL
    428  78f3		       85 a6		      sta	ManMode
    429  78f5				   notComplete
    430  78f5
    431  78f5
    432  78f5		       a9 03		      lda	#BANK_TrackPlayer	;
    433  78f7		       85 3f		      sta	SET_BANK	;
    434  78f9		       20 c3 f4 	      jsr	TrackPlayer	;11+145
    435  78fc
    436  78fc		       a9 00		      lda	#TYPE_MAN	; 2
    437  78fe		       85 8c		      sta	POS_Type	; 3
    438  7900
    439  7900		       20 2c f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    440  7903		       4c 1f f9    gnobj      jmp	NextObject
    441  7906
    442  7906							;---------------------------------------------------------------------------
    443  7906
      0  7906					      DEFINE_SUBROUTINE	PutCharacterAtXY
      1  7906		       00 0f	   BANK_PutCharacterAtXY =	_CURRENT_BANK
      2  7906					      SUBROUTINE
      3  7906				   PutCharacterAtXY
    445  7906
    446  7906							; POS_X	 character location
    447  7906							; POS_Y
    448  7906							; POS_VAR	 character to put on board
    449  7906							; ROM_Bank	 ROM bank to return to
    450  7906
    451  7906		       a4 89		      ldy	POS_Y
    452  7908
    453  7908		       a9 0c		      lda	#BANK_GetBoardAddressW
    454  790a		       85 3f		      sta	SET_BANK
    455  790c		       20 d7 f0 	      jsr	GetBoardAddressW
    456  790f		       86 3e		      stx	SET_BANK_RAM
    457  7911
    458  7911		       a4 88		      ldy	POS_X
    459  7913		       a5 8d		      lda	POS_VAR
    460  7915		       91 c7		      sta	(Board_AddressW),y
    461  7917
    462  7917		       a5 c9		      lda	ROM_Bank
    463  7919		       85 3f		      sta	SET_BANK
    464  791b		       60		      rts
    465  791c
    466  791c							;---------------------------------------------------------------------------
    467  791c
    468  791c							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    469  791c							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    470  791c
    471  791c							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    472  791c
    473  791c							; if the creature dies then jump NextObject
    474  791c
    475  791c
    476  791c		       20 2c f9    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    477  791f
    478  791f		       e6 d3	   NextObject inc	ObjIterator	; 5
    479  7921							;		  dec ObjStackPtr,x		  ; 6
    480  7921		       4c 58 f8 	      jmp	ProcessObjStack	; 3 = 16
    481  7924
    482  7924							;---------------------------------------------------------------------------
    483  7924
      0  7924					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  7924		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  7924					      SUBROUTINE
      3  7924				   InsertObjectStackFromRAM
    485  7924
    486  7924		       20 2c f9 	      jsr	InsertObjectStack	;6+76(B)
    487  7927		       a5 ca		      lda	RAM_Bank	;3
    488  7929		       85 3e		      sta	SET_BANK_RAM	;3
    489  792b
    490  792b		       60	   NotEnoughTime rts		;6
    491  792c
    492  792c							;---------------------------------------------------------------------------
    493  792c
      0  792c					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  792c		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  792c					      SUBROUTINE
      3  792c				   InsertObjectStack
    495  792c							; POS_X     x position
    496  792c							; POS_Y     y position
    497  792c							; POS_VAR   direction or other variable
    498  792c							; POS_Type  type of object
    499  792c
    500  792c		       a6 83		      ldx	ObjStackNum	; 3
    501  792e		       bc 5a f9 	      ldy	BankObjStack,x	; 4
    502  7931		       84 3e		      sty	SET_BANK_RAM	; 3
    503  7933		       b4 84		      ldy	ObjStackPtr,x	; 4 = 14
    504  7935
    505  7935
    506  7935		       a5 89		      lda	POS_Y	; 3
    507  7937		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    508  793a		       a5 88		      lda	POS_X	; 3
    509  793c		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    510  793f		       a5 8d		      lda	POS_VAR	; 3
    511  7941		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    512  7944		       a5 8c		      lda	POS_Type	; 3
    513  7946		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    514  7949
    515  7949							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    516  7949							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    517  7949							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    518  7949
    519  7949
    520  7949				  -	      IF	TYPE_MAN != 0
    521  7949				  -	      cmp	#TYPE_MAN	; 2
    522  7949					      ENDIF
    523  7949		       f0 04		      beq	alwaysAllowMan	; 2/3
    524  794b
    525  794b		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    526  794d		       b0 06		      bcs	insertDone	; 2/3= 6    no room -- drop object
    527  794f				   alwaysAllowMan
    528  794f
    529  794f		       98		      tya		; 2
    530  7950		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    531  7953
    532  7953		       f6 84		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    533  7955
    534  7955		       a4 c9	   insertDone ldy	ROM_Bank	; 3
    535  7957		       84 3f		      sty	SET_BANK	; 3
    536  7959
    537  7959				   ManIsDead2
    538  7959
    539  7959
    540  7959
    541  7959		       60		      rts		; 6 = 29
    542  795a
    543  795a							;---------------------------------------------------------------------------
    544  795a
    545  795a		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    546  795c
    547  795c							;---------------------------------------------------------------------------
    548  795c
      0  795c					      DEFINE_SUBROUTINE	MovePlayer
      1  795c		       00 0f	   BANK_MovePlayer =	_CURRENT_BANK
      2  795c					      SUBROUTINE
      3  795c				   MovePlayer
    550  795c
    551  795c							;		  lda ManMode
    552  795c							;		  cmp #MANMODE_DEAD
    553  795c							;		  bcs ManIsDead2
    554  795c
    555  795c		       a4 8b		      ldy	POS_Y_NEW
    556  795e
    557  795e		       a9 0c		      lda	#BANK_GetBoardAddressRW	;2
    558  7960		       85 3f		      sta	SET_BANK	;3
    559  7962		       85 c9		      sta	ROM_Bank	;3
    560  7964		       20 b7 f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    561  7967				  -	      IF	MULTI_BANK_BOARD = YES
    562  7967				  -	      stx	RAM_Bank
    563  7967					      ENDIF
    564  7967		       86 3e		      stx	SET_BANK_RAM	; 3
    565  7969
    566  7969		       a4 8a		      ldy	POS_X_NEW
    567  796b		       b3 c5		      lax	(Board_AddressR),y
    568  796d
    569  796d		       a9 0c		      lda	#BANK_MoveVecLO
    570  796f		       85 3f		      sta	SET_BANK
    571  7971
    572  7971		       bd 55 f3 	      lda	MoveVecLO,x
    573  7974		       85 e2		      sta	MAN_Move
    574  7976		       bd 5f f3 	      lda	MoveVecHI,x
    575  7979		       85 e3		      sta	MAN_Move+1
    576  797b
    577  797b				  -	      IF	MULTI_BANK_BOARD = YES
    578  797b				  -	      lda	RAM_Bank
    579  797b					      ELSE
    580  797b		       a9 0d		      lda	#BANK_BOARD
    581  797d					      ENDIF
    582  797d		       85 3e		      sta	SET_BANK_RAM
    583  797f		       6c e2 00 	      jmp	(MAN_Move)
    584  7982
    585  7982							;---------------------------------------------------------------------------
    586  7982
      0  7982					      DEFINE_SUBROUTINE	RecordTakeBackPosition
      1  7982		       00 0f	   BANK_RecordTakeBackPosition =	_CURRENT_BANK
      2  7982					      SUBROUTINE
      3  7982				   RecordTakeBackPosition
    588  7982
    589  7982							; Pass...
    590  7982							; TB_X 	 the man's position before he moved
    591  7982							; TB_Y
    592  7982							; TB_CHAR	 if -1 then there is no box push involved, else..
    593  7982							;		 holds the character that was under the box in its new position
    594  7982							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    595  7982							; TB_PUSHY
    596  7982
    597  7982							; On making a move,
    598  7982							; man's position before move --> TB_X,TB_Y
    599  7982							; TB_CHAR = -1
    600  7982							; IF a box was pushed,
    601  7982							;   TB_CHAR = character under the box's new position (i.e., restoration char)
    602  7982							;   box's new position --> TB_PUSHX, TB_PUSHY
    603  7982							; ENDIF
    604  7982							; BCD_moveCounter++
    605  7982
    606  7982		       a5 d5		      lda	TakebackInhibit
    607  7984		       d0 2e		      bne	noLog
    608  7986
    609  7986		       a9 0e		      lda	#BANK_TAKEBACK
    610  7988		       85 3e		      sta	SET_BANK_RAM
    611  798a
    612  798a		       a6 c0		      ldx	takebackIndex
    613  798c
    614  798c		       a5 8e		      lda	TB_X
    615  798e		       9d 00 14 	      sta	RAM_WRITE+TakeBackPreviousX,x
    616  7991		       a5 8f		      lda	TB_Y
    617  7993		       9d 40 14 	      sta	RAM_WRITE+TakeBackPreviousY,x
    618  7996		       a5 92		      lda	TB_CHAR
    619  7998		       9d 00 15 	      sta	RAM_WRITE+TakeBackPushChar,x
    620  799b
    621  799b							; if TB_CHAR is -1 that means there is no box component, and the following values are random
    622  799b
    623  799b		       a5 90		      lda	TB_PUSHX
    624  799d		       9d 80 14 	      sta	RAM_WRITE+TakeBackPushX,x
    625  79a0		       a5 91		      lda	TB_PUSHY
    626  79a2		       9d c0 14 	      sta	RAM_WRITE+TakeBackPushY,x
    627  79a5
    628  79a5		       a5 c9		      lda	ROM_Bank
    629  79a7		       85 3f		      sta	SET_BANK
    630  79a9
    631  79a9							; fall through
    632  79a9
      0  79a9					      DEFINE_SUBROUTINE	IncrementMoveCount
      1  79a9		       00 0f	   BANK_IncrementMoveCount =	_CURRENT_BANK
      2  79a9					      SUBROUTINE
      3  79a9				   IncrementMoveCount
    634  79a9		       a9 0c		      lda	#BANK_IMC
    635  79ab		       85 3f		      sta	SET_BANK
    636  79ad		       20 23 f3 	      jsr	IMC
    637  79b0		       a5 c9		      lda	ROM_Bank
    638  79b2		       85 3f		      sta	SET_BANK
    639  79b4
    640  79b4		       a9 00	   noLog      lda	#0
    641  79b6		       85 d5		      sta	TakebackInhibit
    642  79b8		       60		      rts
    643  79b9
    644  79b9							;---------------------------------------------------------------------------
    645  79b9
      0  79b9					      DEFINE_SUBROUTINE	MOVE_BLANK
      1  79b9		       00 0f	   BANK_MOVE_BLANK =	_CURRENT_BANK
      2  79b9					      SUBROUTINE
      3  79b9				   MOVE_BLANK
      0  79b9					      DEFINE_SUBROUTINE	MOVE_SOIL
      1  79b9		       00 0f	   BANK_MOVE_SOIL =	_CURRENT_BANK
      2  79b9					      SUBROUTINE
      3  79b9				   MOVE_SOIL
      0  79b9					      DEFINE_SUBROUTINE	MOVE_TARGET
      1  79b9		       00 0f	   BANK_MOVE_TARGET =	_CURRENT_BANK
      2  79b9					      SUBROUTINE
      3  79b9				   MOVE_TARGET
    649  79b9
    650  79b9		       8a		      txa		; character man will be standing on
    651  79ba		       48		      pha
    652  79bb
    653  79bb		       a9 80		      lda	#ANIMATION_WALK_ID
    654  79bd		       c5 ae		      cmp	ManAnimationID
    655  79bf		       f0 0e		      beq	walkingOK
    656  79c1		       85 ae		      sta	ManAnimationID
      0  79c3					      LOAD_ANIMATION	Animation_Walk
      1  79c3		       a9 0a		      lda	#<Animation_Walk
      2  79c5		       85 9f		      sta	animation
      3  79c7		       a9 f0		      lda	#>Animation_Walk
      4  79c9		       85 a0		      sta	animation+1
      5  79cb		       a9 ff		      lda	#-1
      6  79cd		       85 a1		      sta	animation_delay
    658  79cf				   walkingOK
    659  79cf
    660  79cf		       a5 a2		      lda	ManX
    661  79d1		       85 88		      sta	POS_X
    662  79d3		       85 8e		      sta	TB_X
    663  79d5		       a5 a3		      lda	ManY
    664  79d7		       85 89		      sta	POS_Y
    665  79d9		       85 8f		      sta	TB_Y
    666  79db		       20 06 f9 	      jsr	PutCharacterAtXY	; RESTORE (previous XY) under-man character
    667  79de
    668  79de		       a5 8a		      lda	POS_X_NEW
    669  79e0		       85 a2		      sta	ManX
    670  79e2		       85 88		      sta	POS_X
    671  79e4		       a5 8b		      lda	POS_Y_NEW
    672  79e6		       85 a3		      sta	ManY
    673  79e8		       85 89		      sta	POS_Y
    674  79ea		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    675  79ec		       85 8d		      sta	POS_VAR
    676  79ee		       20 06 f9 	      jsr	PutCharacterAtXY
    677  79f1
    678  79f1							; TB_X 	 the man's position before he moved
    679  79f1							; TB_Y
    680  79f1							; TB_CHAR	 if -1 then there is no box push involved, else..
    681  79f1							;		 holds the character that was under the box in its new position
    682  79f1							;		 this can be inferred by the box character (ONTARGET)
    683  79f1							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    684  79f1							; TB_PUSHY
    685  79f1
    686  79f1		       20 82 f9 	      jsr	RecordTakeBackPosition
    687  79f4
    688  79f4		       68		      pla
    689  79f5		       85 8d		      sta	POS_VAR	; save 'restore' character
    690  79f7
    691  79f7		       a9 00	   MOVE_GENERIC lda	#0	; 2
    692  79f9		       85 ac		      sta	ManPushCounter	; 3
    693  79fb		       60		      rts		; 6 = 11
    694  79fc
    695  79fc							;---------------------------------------------------------------------------
    696  79fc							; takeback buffer empty - flash red
    697  79fc
    698  79fc		       a5 81	   noMovesToTake lda	Platform
    699  79fe		       18		      clc
    700  79ff		       69 04		      adc	#4	; reds
    701  7a01		       85 cc		      sta	ColourFlash
    702  7a03		       a9 0a		      lda	#10
    703  7a05		       85 cb		      sta	ColourTimer
    704  7a07		       60		      rts
    705  7a08
    706  7a08							;---------------------------------------------------------------------------
    707  7a08
      0  7a08					      DEFINE_SUBROUTINE	MOVE_BOX
      1  7a08		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  7a08					      SUBROUTINE
      3  7a08				   MOVE_BOX
    709  7a08
    710  7a08		       a2 00		      ldx	#CHARACTER_BLANK	; restoration character
    711  7a0a		       a9 0c		      lda	#BANK_PushBox
    712  7a0c		       85 3f		      sta	SET_BANK
    713  7a0e		       4c e7 f0 	      jmp	PushBox
    714  7a11
      0  7a11					      DEFINE_SUBROUTINE	MOVE_BOX_ON_TARGET
      1  7a11		       00 0f	   BANK_MOVE_BOX_ON_TARGET =	_CURRENT_BANK
      2  7a11					      SUBROUTINE
      3  7a11				   MOVE_BOX_ON_TARGET
    716  7a11
    717  7a11		       a2 03		      ldx	#CHARACTER_TARGET	; restoration character
    718  7a13		       a9 0c		      lda	#BANK_PushBox
    719  7a15		       85 3f		      sta	SET_BANK
    720  7a17		       4c e7 f0 	      jmp	PushBox
    721  7a1a
    722  7a1a							;---------------------------------------------------------------------------
    723  7a1a
      0  7a1a					      DEFINE_SUBROUTINE	takebackRestoreEarlierPosition
      1  7a1a		       00 0f	   BANK_takebackRestoreEarlierPosition =	_CURRENT_BANK
      2  7a1a					      SUBROUTINE
      3  7a1a				   takebackRestoreEarlierPosition
    725  7a1a
    726  7a1a		       e6 d5		      inc	TakebackInhibit	; non-zero
    727  7a1c
    728  7a1c							; on reverting a move
    729  7a1c							; IF BCD_moveCounter > 0
    730  7a1c							;   BCD_moveCounter--
    731  7a1c							;   IF TakeBackPushChar != -1
    732  7a1c							;	 //restore the character under box (and remove box)
    733  7a1c							;	 board[TakeBackPreviousX,TakeBackPreviousY] = TakeBackPushChar
    734  7a1c							;   ENDIF
    735  7a1c							; // We will "fix" any box going back on the board through the man's restoration char
    736  7a1c							; board[ManX,ManY] = POS_VAR
    737  7a1c							; POS_VAR = board[TakeBackX,TakeBackY]
    738  7a1c							; board[TakeBackX,TakeBackY] = MANOCCUPIED
    739  7a1c							; ManX,ManY = TakeBackX, TakeBackY
    740  7a1c
    741  7a1c		       a6 c0		      ldx	takebackIndex
    742  7a1e		       e4 c1		      cpx	takebackBaseIndex
    743  7a20		       f0 da		      beq	noMovesToTake
    744  7a22
    745  7a22		       ca		      dex
    746  7a23		       8a		      txa
    747  7a24		       29 3f		      and	#TAKEBACK_MASK
    748  7a26		       85 c0		      sta	takebackIndex
    749  7a28		       aa		      tax
    750  7a29
    751  7a29		       f8		      sed
    752  7a2a		       38		      sec
    753  7a2b		       a5 be		      lda	BCD_moveCounter
    754  7a2d		       e9 01		      sbc	#1
    755  7a2f		       85 be		      sta	BCD_moveCounter
    756  7a31		       a5 bf		      lda	BCD_moveCounter+1
    757  7a33		       e9 00		      sbc	#0
    758  7a35		       85 bf		      sta	BCD_moveCounter+1
    759  7a37		       d8		      cld
    760  7a38
    761  7a38				  -	      if	0
    762  7a38				  -	      lda	Platform
    763  7a38				  -	      clc
    764  7a38				  -	      adc	#8
    765  7a38				  -	      sta	ColourFlash	; yellow flash
    766  7a38				  -	      lda	#3
    767  7a38				  -	      sta	ColourTimer
    768  7a38					      endif
    769  7a38
    770  7a38		       a9 0e		      lda	#BANK_TAKEBACK
    771  7a3a		       85 3e		      sta	SET_BANK_RAM
    772  7a3c
    773  7a3c							; TB_X 	 the man's position before he moved
    774  7a3c							; TB_Y
    775  7a3c							; TB_CHAR	 if -1 then there is no box push involved, else..
    776  7a3c							;		 holds the character that was under the box in its new position
    777  7a3c							; TB_PUSHX	 Position of pushed box AFTER it is pushed
    778  7a3c							; TB_PUSHY
    779  7a3c
    780  7a3c							;	 //restore the character under box (and remove box)
    781  7a3c							;	 board[TakeBackPreviousX,TakeBackPreviousY] = TakeBackPushChar
    782  7a3c
    783  7a3c		       a5 8d		      lda	POS_VAR
    784  7a3e		       48		      pha
    785  7a3f
    786  7a3f		       a6 c0		      ldx	takebackIndex
    787  7a41		       bd 00 11 	      lda	TakeBackPushChar,x
    788  7a44		       30 29		      bmi	noPushInvolved	; -1 = no box
    789  7a46
    790  7a46		       85 8d		      sta	POS_VAR
    791  7a48		       c9 03		      cmp	#CHARACTER_TARGET
    792  7a4a		       f0 04		      beq	isaTarget
    793  7a4c		       c9 04		      cmp	#CHARACTER_TARGET2
    794  7a4e		       d0 03		      bne	notTarget1
    795  7a50		       20 a7 fd    isaTarget  jsr	RegisterTarget
    796  7a53				   notTarget1
    797  7a53
    798  7a53
    799  7a53		       bd 80 10 	      lda	TakeBackPushX,x
    800  7a56		       85 88		      sta	POS_X
    801  7a58		       bd c0 10 	      lda	TakeBackPushY,x
    802  7a5b		       85 89		      sta	POS_Y
    803  7a5d
    804  7a5d		       20 06 f9 	      jsr	PutCharacterAtXY	; fixup BOX!
    805  7a60
    806  7a60		       68		      pla
    807  7a61		       f0 07		      beq	blnkre
    808  7a63		       20 b1 fd 	      jsr	DeRegisterTarget
    809  7a66		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    810  7a68		       d0 02		      bne	skls
    811  7a6a		       a9 02	   blnkre     lda	#CHARACTER_BOX
    812  7a6c		       85 8d	   skls       sta	POS_VAR
    813  7a6e
    814  7a6e		       48		      pha
    815  7a6f
    816  7a6f		       68	   noPushInvolved pla		; man's replacement char
    817  7a70		       85 8d		      sta	POS_VAR
    818  7a72
    819  7a72							; // We will "fix" any box going back on the board through the man's restoration char
    820  7a72							; board[ManX,ManY] = POS_VAR
    821  7a72							; POS_VAR = board[TakeBackX,TakeBackY]
    822  7a72							; board[TakeBackX,TakeBackY] = MANOCCUPIED
    823  7a72							; ManX,ManY = TakeBackX, TakeBackY
    824  7a72
    825  7a72		       a5 a2		      lda	ManX
    826  7a74		       85 88		      sta	POS_X
    827  7a76		       a5 a3		      lda	ManY
    828  7a78		       85 89		      sta	POS_Y
    829  7a7a		       20 06 f9 	      jsr	PutCharacterAtXY	; put what man was on... back
    830  7a7d
    831  7a7d
    832  7a7d		       a9 0e		      lda	#BANK_TAKEBACK
    833  7a7f		       85 3e		      sta	SET_BANK_RAM
    834  7a81
    835  7a81		       a6 c0		      ldx	takebackIndex
    836  7a83		       bd 00 10 	      lda	TakeBackPreviousX,x
    837  7a86		       85 8a		      sta	POS_X_NEW
    838  7a88		       85 a2		      sta	ManX
    839  7a8a		       bd 40 10 	      lda	TakeBackPreviousY,x
    840  7a8d		       85 8b		      sta	POS_Y_NEW
    841  7a8f		       85 a3		      sta	ManY
    842  7a91
    843  7a91							; Grab the character from the board at man's location and use as "restore character" for man
    844  7a91							; POS_VAR = board[takebackx,takebacky]
    845  7a91
    846  7a91		       a9 0c		      lda	#BANK_GetBoardAddressR
    847  7a93		       85 3f		      sta	SET_BANK
    848  7a95		       a4 8b		      ldy	POS_Y_NEW
    849  7a97		       20 ca f0 	      jsr	GetBoardAddressR
    850  7a9a		       85 3e		      sta	SET_BANK_RAM
    851  7a9c
    852  7a9c		       a4 8a		      ldy	POS_X_NEW
    853  7a9e		       b1 c5		      lda	(Board_AddressR),y
    854  7aa0							;pha
    855  7aa0							;lda #CHARACTER_MANOCCUPIED
    856  7aa0							;sta POS_VAR
    857  7aa0							;jsr PutCharacterAtXY		 ????
    858  7aa0							;pla
    859  7aa0		       85 8d		      sta	POS_VAR
    860  7aa2
    861  7aa2		       a5 c9		      lda	ROM_Bank
    862  7aa4		       85 3f		      sta	SET_BANK
    863  7aa6
    864  7aa6		       60	   timeExit   rts
    865  7aa7
    866  7aa7							;---------------------------------------------------------------------------
    867  7aa7
      0  7aa7					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7aa7		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7aa7					      SUBROUTINE
      3  7aa7				   StealCharDraw
    869  7aa7
    870  7aa7		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    871  7aa9		       85 3e		      sta	SET_BANK_RAM	; 3
    872  7aab		       a4 82		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    873  7aad		       10 35		      bpl	EnterStealCharDraw	; 3 = 10(11)
    874  7aaf
    875  7aaf				   ExitStealCharDraw
    876  7aaf
    877  7aaf							; fall through...
    878  7aaf
    879  7aaf							;---------------------------------------------------------------------------
    880  7aaf
      0  7aaf					      DEFINE_SUBROUTINE	TimeSlice
      1  7aaf		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7aaf					      SUBROUTINE
      3  7aaf				   TimeSlice
    882  7aaf
    883  7aaf							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    884  7aaf							; going ahead if there's insufficient time. This allows the previous character drawing to
    885  7aaf							; be much smaller in time, as they don't have to include the timeslice code overhead.
    886  7aaf
    887  7aaf		       ad 84 02 	      lda	INTIM	; 4
    888  7ab2		       c9 03		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    889  7ab4		       90 f0		      bcc	timeExit	; 2(3)
    890  7ab6
    891  7ab6							; Uses the phase variable to vector to the correct processing code for the given timeslice
    892  7ab6							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    893  7ab6							; it should increment ScreenDrawPhase.
    894  7ab6
    895  7ab6							; Switched-in bank(s) are undefined after this function is called!
    896  7ab6
    897  7ab6		       a9 03		      lda	#BANK_TS_PhaseVectorLO	; 2
    898  7ab8		       85 3f		      sta	SET_BANK	; 3
    899  7aba
    900  7aba		       a6 87		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    901  7abc		       bd 4a f5 	      lda	TS_PhaseVectorLO,x	; 4
    902  7abf		       85 e2		      sta	TS_Vector	; 3
    903  7ac1		       bd 4f f5 	      lda	TS_PhaseVectorHI,x	; 4
    904  7ac4		       85 e3		      sta	TS_Vector+1	; 3
    905  7ac6
    906  7ac6		       bd 54 f5 	      lda	TS_PhaseBank,x	; 4
    907  7ac9		       85 3f		      sta	SET_BANK	; 3		 switch bank
    908  7acb
    909  7acb		       6c e2 00 	      jmp	(TS_Vector)	; 3 = 40	 vector to timeslice handler
    910  7ace
    911  7ace							; = 55 minimum return time (if segtime abort)
    912  7ace
    913  7ace							;---------------------------------------------------------------------------
    914  7ace
    915  7ace
    916  7ace				   DrawAnother
    917  7ace
    918  7ace		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    919  7ad0		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    920  7ad2
    921  7ad2		       a4 82		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    922  7ad4
    923  7ad4		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    924  7ad7		       bd a0 f0 	      lda	ScreenBuffer,x	; 4	     new character to draw
    925  7ada		       29 7f		      and	#~128	; 2
    926  7adc		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    927  7adf
    928  7adf		       88		      dey		; 2
    929  7ae0		       84 82		      sty	DrawStackPointer	; 3	     one less to draw
    930  7ae2		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7
    931  7ae4
    932  7ae4				   EnterStealCharDraw		;	     RAM bank MUST be at BANK_DRAW_BUFFERS
    933  7ae4
    934  7ae4		       ad 84 02 	      lda	INTIM	; 4
    935  7ae7		       c9 03		      cmp	#SEGTIME_SCD_MIN	; 2
    936  7ae9		       90 c4		      bcc	ExitStealCharDraw	; 2/3= 8
    937  7aeb
    938  7aeb		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    939  7aee		       bc a0 f0 	      ldy	ScreenBuffer,x	; 4 =	8    new character to draw
    940  7af1
    941  7af1		       bd 00 f2 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
    942  7af4		       85 3e		      sta	SET_BANK_RAM	; 3
    943  7af6		       4c 41 f1 	      jmp	StealPart3	; 3 = 10    --> 18 cycles after check for SEGTIME_SCD_MIN
    944  7af9
    945  7af9							;---------------------------------------------------------------------------
    946  7af9
    947  7af9		       60	   skipOffscreen rts
    948  7afa
      0  7afa					      DEFINE_SUBROUTINE	writePlayerFrame
      1  7afa		       00 0f	   BANK_writePlayerFrame =	_CURRENT_BANK
      2  7afa					      SUBROUTINE
      3  7afa				   writePlayerFrame
    950  7afa
    951  7afa		       38		      sec
    952  7afb		       a5 a3		      lda	ManY
    953  7afd		       e5 99		      sbc	BoardScrollY
    954  7aff		       c9 08		      cmp	#SCREEN_LINES	; todo - use const
    955  7b01		       b0 f6		      bcs	skipOffscreen
    956  7b03		       85 e6		      sta	bank	; character line (and hence bank) of player position
    957  7b05
    958  7b05				  -	      if	0
    959  7b05				  -			; rainbow-cycle the colours, just to show it works
    960  7b05				  -	      sta	SET_BANK_RAM
    961  7b05				  -	      ldx	#8
    962  7b05				  -eth	      lda	EthnicityColourPalette+24+16,x
    963  7b05				  -	      clc
    964  7b05				  -	      adc	#1
    965  7b05				  -	      sta	EthnicityColourPalette+RAM_WRITE+24+16,x
    966  7b05				  -	      dex
    967  7b05				  -	      bpl	eth
    968  7b05					      endif
    969  7b05
    970  7b05		       a5 81		      lda	Platform
    971  7b07		       29 02		      and	#%10
    972  7b09		       0a		      asl
    973  7b0a		       0a		      asl
    974  7b0b		       65 d6		      adc	ethnic
    975  7b0d		       85 e7		      sta	ethnicity
    976  7b0f
    977  7b0f
    978  7b0f
    979  7b0f							; todo - compare with last + frame and skip if same
    980  7b0f
    981  7b0f		       a9 0a		      lda	#PLAYER_FRAMES
    982  7b11		       85 3f		      sta	SET_BANK
    983  7b13
    984  7b13		       a5 a1		      lda	animation_delay
    985  7b15		       30 0f		      bmi	getDelay	; 1st
    986  7b17		       c6 a1		      dec	animation_delay
    987  7b19		       10 11		      bpl	nextAnimation2
    988  7b1b
    989  7b1b		       18		      clc
    990  7b1c		       a5 9f		      lda	animation
    991  7b1e		       69 02		      adc	#2
    992  7b20		       85 9f		      sta	animation
    993  7b22		       90 02		      bcc	ahiok
    994  7b24		       e6 a0		      inc	animation+1
    995  7b26				   ahiok
    996  7b26		       a0 01	   getDelay   ldy	#1
    997  7b28		       b1 9f		      lda	(animation),y
    998  7b2a		       85 a1		      sta	animation_delay
    999  7b2c		       a0 00	   nextAnimation2 ldy	#0
   1000  7b2e		       b1 9f		      lda	(animation),y
   1001  7b30		       10 12		      bpl	notJump
   1002  7b32							; we have a jump
   1003  7b32
   1004  7b32		       29 7f		      and	#$7F
   1005  7b34		       85 ae		      sta	ManAnimationID
   1006  7b36
   1007  7b36		       a8		      tay
   1008  7b37		       b9 00 f0 	      lda	ANIM_TABLE,y
   1009  7b3a		       85 9f		      sta	animation
   1010  7b3c		       b9 01 f0 	      lda	ANIM_TABLE+1,y
   1011  7b3f		       85 a0		      sta	animation+1
   1012  7b41		       4c 26 fb 	      jmp	getDelay
   1013  7b44
   1014  7b44		       a8	   notJump    tay
   1015  7b45		       b9 7e f0 	      lda	FRAME_PTR_LO,y
   1016  7b48		       85 e2		      sta	frame_ptr
   1017  7b4a		       b9 91 f0 	      lda	FRAME_PTR_HI,y
   1018  7b4d		       85 e3		      sta	frame_ptr+1
   1019  7b4f
   1020  7b4f		       b9 a4 f0 	      lda	COLOUR_PTR_LO,y
   1021  7b52		       85 e4		      sta	colour_ptr
   1022  7b54		       b9 b7 f0 	      lda	COLOUR_PTR_HI,y
   1023  7b57		       85 e5		      sta	colour_ptr+1
   1024  7b59
   1025  7b59		       18		      clc
   1026  7b5a		       a0 17		      ldy	#23
   1027  7b5c				   CopySpriteToBank
   1028  7b5c		       a9 0a		      lda	#PLAYER_FRAMES
   1029  7b5e		       85 3f		      sta	SET_BANK
   1030  7b60		       b1 e2		      lda	(frame_ptr),y
   1031  7b62		       48		      pha
   1032  7b63
   1033  7b63							; The colours for the sprites are copied to the row bank's colour data. The frames contain
   1034  7b63							; colour *indexes*. These indexes are modified by the *base* which indicates both the
   1035  7b63							; system NTSC/PAL along with the "visual identity" (i.e., colour/race). That is used to
   1036  7b63							; lookup a colour conversion which FINALLY gives us the correct colour to use for the line.
   1037  7b63
   1038  7b63							; ethnicity * 16 + PALNTSC * 8
   1039  7b63
   1040  7b63		       b1 e4		      lda	(colour_ptr),y
   1041  7b65		       65 e7		      adc	ethnicity	; colour base
   1042  7b67		       aa		      tax
   1043  7b68		       a5 e6		      lda	bank
   1044  7b6a		       85 3e		      sta	SET_BANK_RAM
   1045  7b6c		       bd e6 f2 	      lda	EthnicityColourPalette,x
   1046  7b6f		       99 af f4 	      sta	SpriteColourRED+RAM_WRITE,y
   1047  7b72		       68		      pla
   1048  7b73		       99 ce f6 	      sta	PLAYER_RIGHT0+RAM_WRITE,y
   1049  7b76		       88		      dey
   1050  7b77		       10 e3		      bpl	CopySpriteToBank
   1051  7b79
   1052  7b79		       60		      rts
   1053  7b7a
   1054  7b7a							;---------------------------------------------------------------------------
   1055  7b7a
      0  7b7a					      DEFINE_SUBROUTINE	DrawFullScreenMain	;=2484[-89]
      1  7b7a		       00 0f	   BANK_DrawFullScreenMain =	_CURRENT_BANK
      2  7b7a					      SUBROUTINE
      3  7b7a				   DrawFullScreenMain
   1057  7b7a
   1058  7b7a							; Check the screen for all those characters that need to be redrawn
   1059  7b7a							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
   1060  7b7a							; the drawflags array is different to the ScreenBuffer array entry, then the
   1061  7b7a							; screenbuffer will need redrawing.
   1062  7b7a
   1063  7b7a				   CopyRow2
   1064  7b7a
   1065  7b7a				  -	      IF	MULTI_BANK_BOARD = YES
   1066  7b7a				  -	      lda	BDF_BoardBank	; 3
   1067  7b7a					      ELSE
   1068  7b7a		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
   1069  7b7c					      ENDIF
   1070  7b7c		       85 3e		      sta	SET_BANK_RAM	; 3
   1071  7b7e		       b3 e6		      lax	(BDF_BoardAddress),y	; 5
   1072  7b80		       9a		      txs		; 2
   1073  7b81		       b3 e8		      lax	(BDF_BoardAddress2),y	; 5(= 18[-1])
   1074  7b83
   1075  7b83		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
   1076  7b85		       85 3e		      sta	SET_BANK_RAM	; 3
   1077  7b87		       bd cd f1 	      lda	CharReplacement,x	; 4
   1078  7b8a		       91 e4		      sta	(BDF_DrawFlagAddress2),y	; 6
   1079  7b8c		       ba		      tsx		; 2
   1080  7b8d		       bd cd f1 	      lda	CharReplacement,x	; 4
   1081  7b90		       91 e2		      sta	(BDF_DrawFlagAddress),y	; 6(= 27)
   1082  7b92
   1083  7b92		       88		      dey		; 2
   1084  7b93		       10 e5		      bpl	CopyRow2	; 2/3=49/50[-1]
   1085  7b95							; total: 5*(50[-1])-1 = 244 *OR*  249 (MB)
   1086  7b95
   1087  7b95		       a7 eb		      lax	DHS_Line	; 3
   1088  7b97		       f0 07		      beq	.exitCopy	; 2/3= 5/6
   1089  7b99
   1090  7b99		       a0 0c		      ldy	#BANK_DrawScreenRowPreparation	;2
   1091  7b9b		       84 3f		      sty	SET_BANK	; 3
   1092  7b9d		       4c e0 f2 	      jmp	DrawScreenRowPreparation	;55[-7] = 60[-7]
   1093  7ba0
   1094  7ba0							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
   1095  7ba0
   1096  7ba0
      0  7ba0					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7ba0					      LIST	ON
   1098  7ba0
   1099  7ba0		       a6 ec	   .exitCopy  ldx	DHS_Stack	; 3
   1100  7ba2		       9a		      txs		; 2
   1101  7ba3
   1102  7ba3							; fall through
   1103  7ba3
      0  7ba3					      DEFINE_SUBROUTINE	BuildDrawStack
      1  7ba3		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7ba3					      SUBROUTINE
      3  7ba3				   BuildDrawStack
   1105  7ba3
   1106  7ba3		       a9 08		      lda	#BANK_DRAW_BUFFERS
   1107  7ba5		       85 3e		      sta	SET_BANK_RAM
   1108  7ba7		       4c f1 f0 	      jmp	DrawStackUpdate
   1109  7baa
   1110  7baa							;---------------------------------------------------------------------------
   1111  7baa
      0  7baa					      DEFINE_SUBROUTINE	DrawAIntoStack
      1  7baa		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7baa					      SUBROUTINE
      3  7baa				   DrawAIntoStack
   1113  7baa
   1114  7baa		       a9 08		      lda	#BANK_DRAW_BUFFERS
   1115  7bac		       85 3e		      sta	SET_BANK_RAM
   1116  7bae		       4c 1a f1 	      jmp	DrawIntoStack
   1117  7bb1
   1118  7bb1
   1119  7bb1
   1120  7bb1
   1121  7bb1
   1122  7bb1							;---------------------------------------------------------------------------
   1123  7bb1
   1124  7bb1
   1125  7bb1				   Reset
      0  7bb1					      CLEAN_START
      1  7bb1		       78		      sei
      2  7bb2		       d8		      cld
      3  7bb3
      4  7bb3		       a2 00		      ldx	#0
      5  7bb5		       8a		      txa
      6  7bb6		       a8		      tay
      7  7bb7		       ca	   .CLEAR_STACK dex
      8  7bb8		       9a		      txs
      9  7bb9		       48		      pha
     10  7bba		       d0 fb		      bne	.CLEAR_STACK
     11  7bbc
   1127  7bbc
   1128  7bbc							;lda #2
   1129  7bbc							;sta VSYNC
   1130  7bbc							;lda #%01000010		  ; bit6 is not required
   1131  7bbc							;sta VBLANK			  ; end of screen - enter blanking
   1132  7bbc
   1133  7bbc							; Scoring bank is copied once (not per game, not per level...)
   1134  7bbc							; otherwise non-SaveKey high score gets zapped
   1135  7bbc
   1136  7bbc		       a2 02		      ldx	#ROM_SHADOW_OF_BANK_SCORING
   1137  7bbe		       a0 09		      ldy	#BANK_SCORING
   1138  7bc0		       20 9e fd 	      jsr	CopyROM2RAM_F000
   1139  7bc3
   1140  7bc3				   Restart		; go here on RESET + SELECT
   1141  7bc3
   1142  7bc3
   1143  7bc3				   Title
   1144  7bc3		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
   1145  7bc5		       9a		      txs
   1146  7bc6
   1147  7bc6							; temporary vars from title screen are used to init level
   1148  7bc6		       a9 03		      lda	#BANK_Cart_Init	; 2
   1149  7bc8		       85 3f		      sta	SET_BANK	; 3
   1150  7bca		       20 c1 f3 	      jsr	Cart_Init	; 6+x
   1151  7bcd
   1152  7bcd
   1153  7bcd							;---------------------------------------------------------------------------
   1154  7bcd
   1155  7bcd
   1156  7bcd		       f0 00	   SEGMENT_DECODE_LEVEL_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
   1157  7bcd
   1158  7bcd		       a2 03		      ldx	#BANK_DECODE_LEVEL_SHADOW
   1159  7bcf		       a0 0a		      ldy	#BANK_DECODE_LEVEL
   1160  7bd1		       20 9e fd 	      jsr	CopyROM2RAM_F000
   1161  7bd4
   1162  7bd4
   1163  7bd4							;---------------------------------------------------------------------------
   1164  7bd4							; Once-only game initialisation goes here...
   1165  7bd4							; now we have two players so things get a bit tricky
   1166  7bd4
   1167  7bd4		       a9 09		      lda	#BANK_SCORING
   1168  7bd6		       85 3e		      sta	SET_BANK_RAM
   1169  7bd8		       20 63 f3 	      jsr	GameInitialise
   1170  7bdb
   1171  7bdb
   1172  7bdb							;---------------------------------------------------------------------------
   1173  7bdb
------- FILE sound/intro1_init.asm LEVEL 3 PASS 4
      0  7bdb					      include	"sound/intro1_init.asm"
      1  7bdb							; TIATracker music player
      2  7bdb							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7bdb							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7bdb							; Email: andre.wichmann@gmx.de
      5  7bdb							;
      6  7bdb							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7bdb							; you may not use this file except in compliance with the License.
      8  7bdb							; You may obtain a copy of the License at
      9  7bdb							;
     10  7bdb							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7bdb							;
     12  7bdb							; Unless required by applicable law or agreed to in writing, software
     13  7bdb							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7bdb							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7bdb							; See the License for the specific language governing permissions and
     16  7bdb							; limitations under the License.
     17  7bdb
     18  7bdb							; Song author: 
     19  7bdb							; Song name: 
     20  7bdb
     21  7bdb							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7bdb
     23  7bdb							; =====================================================================
     24  7bdb							; Initialize music.
     25  7bdb							; Set tt_cur_pat_index_c0/1 to the indexes of the first patterns from
     26  7bdb							; tt_SequenceTable for each channel.
     27  7bdb							; Set tt_timer and tt_cur_note_index_c0/1 to 0.
     28  7bdb							; All other variables can start with any value.
     29  7bdb							; =====================================================================
     30  7bdb		       a9 00		      lda	#0
     31  7bdd		       85 d8		      sta	tt_cur_pat_index_c0
     32  7bdf		       a9 05		      lda	#5
     33  7be1		       85 d9		      sta	tt_cur_pat_index_c1
     34  7be3							; the rest should be 0 already from startup code. If not,
     35  7be3							; set the following variables to 0 manually:
     36  7be3							; - tt_timer
     37  7be3							; - tt_cur_pat_index_c0
     38  7be3							; - tt_cur_pat_index_c1
     39  7be3							; - tt_cur_note_index_c0
     40  7be3							; - tt_cur_note_index_c1
     41  7be3
------- FILE BANK_FIXED.asm
   1175  7be3
      0  7be3					      SET_PLATFORM
      1  7be3
      2  7be3
      3  7be3
      4  7be3
      5  7be3		       ad 82 02 	      lda	SWCHB
      6  7be6		       2a		      rol
      7  7be7		       2a		      rol
      8  7be8		       2a		      rol
      9  7be9		       29 03		      and	#%11
     10  7beb		       49 02		      eor	#PAL
     11  7bed		       85 81		      sta	Platform
   1177  7bef
   1178  7bef		       a9 0b		      lda	#BANK_TitleScreen
   1179  7bf1		       85 3f		      sta	SET_BANK
   1180  7bf3		       20 00 f0 	      jsr	TitleSequence
   1181  7bf6
   1182  7bf6				   RestartLevelNextPlayer
   1183  7bf6
   1184  7bf6
   1185  7bf6							; a player has lost a life.
   1186  7bf6							; store his vars, swap to other player, continue
   1187  7bf6
   1188  7bf6							;lda #BANK_SCORING
   1189  7bf6							;sta SET_BANK_RAM
   1190  7bf6							;jsr SwapPlayers
   1191  7bf6
   1192  7bf6		       a9 03		      lda	#BANK_SwapPlayersGeneric
   1193  7bf8		       85 3f		      sta	SET_BANK
   1194  7bfa		       20 14 f4 	      jsr	SwapPlayersGeneric
   1195  7bfd
   1196  7bfd				   NextLevelLevel
   1197  7bfd				   skipDemoCheck
   1198  7bfd
   1199  7bfd							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
   1200  7bfd							; including those for general systems function. But NOT those which do not need re-initialising between
   1201  7bfd							; levels.
   1202  7bfd		       a9 03		      lda	#BANK_LevelInit	; 2
   1203  7bff		       85 3f		      sta	SET_BANK	; 3
   1204  7c01		       20 6b f4 	      jsr	LevelInit	; 6+x
   1205  7c04
   1206  7c04		       a9 0a		      lda	#BANK_DECODE_LEVEL
   1207  7c06		       85 3e		      sta	SET_BANK_RAM
   1208  7c08		       20 58 f2 	      jsr	UnpackLevel
   1209  7c0b
   1210  7c0b							; TODO now we KNOW the width, we can set the top left accordingly and re-unpack
   1211  7c0b
   1212  7c0b		       a9 18		      lda	#SIZE_BOARD_X
   1213  7c0d		       85 97		      sta	BoardLimit_Width
   1214  7c0f		       a9 14		      lda	#SIZE_BOARD_Y
   1215  7c11		       85 98		      sta	BoardLimit_Height
   1216  7c13
   1217  7c13							; Setup player animation and scroll limits.
   1218  7c13							; Mangle the board colours based on level
   1219  7c13
   1220  7c13		       a9 03		      lda	#BANK_CreateCreatures	; 2
   1221  7c15		       85 3f		      sta	SET_BANK	; 3
   1222  7c17		       20 2c f4 	      jsr	CreateCreatures	; 6+x
   1223  7c1a
   1224  7c1a							; Setup the various digit and display pointers
   1225  7c1a							; Grab current player's score/level from backup
   1226  7c1a
   1227  7c1a		       a9 09		      lda	#BANK_SCORING
   1228  7c1c		       85 3e		      sta	SET_BANK_RAM
   1229  7c1e		       20 87 f2 	      jsr	GeneralScoringSetups
   1230  7c21							;lda ROM_Bank
   1231  7c21							;sta SET_BANK
   1232  7c21
   1233  7c21							; copy the screen draw ROM shadow to RAM
   1234  7c21
   1235  7c21		       a0 07		      ldy	#SCREEN_LINES-1
   1236  7c23		       a2 00	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
   1237  7c25		       20 9e fd 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
   1238  7c28		       20 71 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
   1239  7c2b		       88		      dey
   1240  7c2c		       10 f5		      bpl	CopyScreenBanks
   1241  7c2e
   1242  7c2e		       a2 01		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
   1243  7c30		       a0 08		      ldy	#BANK_DRAW_BUFFERS
   1244  7c32		       20 3d f0 	      jsr	CopyROMShadowToRAM_F000
   1245  7c35
   1246  7c35							;---------------------------------------------------------------------------
   1247  7c35
   1248  7c35					      IF	WAIT_FOR_INITIAL_DRAW
   1249  7c35		       a9 02		      lda	#%10
   1250  7c37		       85 b4		      sta	blankState
   1251  7c39					      ENDIF
   1252  7c39
   1253  7c39		       a9 03		      lda	#BANK_Resync	; 2
   1254  7c3b		       85 3f		      sta	SET_BANK	; 3
   1255  7c3d		       20 9f f4 	      jsr	Resync	; 6+x
   1256  7c40
   1257  7c40				   NewFrameStart
   1258  7c40
   1259  7c40		       24 d0		      bit	NextLevelTrigger
   1260  7c42		       10 b9		      bpl	NextLevelLevel	; game-triggered next level
   1261  7c44		       70 b0		      bvs	RestartLevelNextPlayer	; loss of life
   1262  7c46
   1263  7c46							; Note: VSYNC must NOT be on when starting a new level! Else you get annoying TV signals.
   1264  7c46
   1265  7c46		       a9 0e		      lda	#%1110	; VSYNC ON
   1266  7c48		       85 42	   .loopVSync sta	WSYNC
   1267  7c4a		       85 40		      sta	VSYNC
   1268  7c4c		       4a		      lsr
   1269  7c4d		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
   1270  7c4f
   1271  7c4f							; moved *after* the loop since this allows to *increase* timer values by 1!
   1272  7c4f
   1273  7c4f		       a6 81		      ldx	Platform
   1274  7c51		       bc 78 fd 	      ldy	VBlankTime,x
   1275  7c54		       8c 96 02 	      sty	TIM64T
   1276  7c57
------- FILE sound/intro1_player.asm LEVEL 3 PASS 4
      0  7c57					      include	"sound/intro1_player.asm"
      1  7c57							; TIATracker music player
      2  7c57							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7c57							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7c57							; Email: andre.wichmann@gmx.de
      5  7c57							;
      6  7c57							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7c57							; you may not use this file except in compliance with the License.
      8  7c57							; You may obtain a copy of the License at
      9  7c57							;
     10  7c57							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7c57							;
     12  7c57							; Unless required by applicable law or agreed to in writing, software
     13  7c57							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7c57							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7c57							; See the License for the specific language governing permissions and
     16  7c57							; limitations under the License.
     17  7c57
     18  7c57							; Song author:
     19  7c57							; Song name:
     20  7c57
     21  7c57							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7c57
     23  7c57							; =====================================================================
     24  7c57							; TIATracker Player
     25  7c57							; =====================================================================
     26  7c57				   tt_PlayerStart
     27  7c57
     28  7c57							; PLANNED PLAYER VARIANTS:
     29  7c57							; - RAM, speed, player ROM: c0/c1 patterns have same length
     30  7c57							; - RAM: Pack 2 values (out of cur_pat_index, cur_note_index, envelope_index)
     31  7c57							;	 into one and use lsr/asl to unpack them, allowing only ranges of
     32  7c57							;	 16/16 or 32/8 for them, depending on number of patterns, max
     33  7c57							;	 pattern size and max ADSR size
     34  7c57							; - ROM: Check if tt_SequenceTable can hold ptrs directly without indexing
     35  7c57							;	 tt_PatternPtrLo/Hi. Can be smaller if not many patterns get repeated
     36  7c57							;	 (saves table and decode routine)
     37  7c57							; - Speed: Inline tt_CalcInsIndex
     38  7c57							; - Speed: Store ptr to current note in RAM instead of reconstructing it?
     39  7c57							;	 Might also save the need for cur_note_index
     40  7c57
     41  7c57
     42  7c57							; ---------------------------------------------------------------------
     43  7c57							; Helper macro: Retrieves current note. May advance pattern if needed.
     44  7c57							; Becomes a subroutine if TT_USE_OVERLAY is used.
     45  7c57							; ---------------------------------------------------------------------
     46  7c57					      MAC	tt_fetch_current_note
     47  7c57							; construct ptr to pattern
     48  7c57				   .constructPatPtr
     49  7c57					      ldy	tt_cur_pat_index_c0,x	; get current pattern (index into tt_SequenceTable)
     50  7c57					      lda	tt_SequenceTable,y
     51  7c57					      IF	TT_USE_GOTO = 1
     52  7c57					      bpl	.noPatternGoto
     53  7c57					      and	#%01111111	; mask out goto bit to get pattern number
     54  7c57					      sta	tt_cur_pat_index_c0,x	; store goto'ed pattern index
     55  7c57					      bpl	.constructPatPtr	; unconditional
     56  7c57				   .noPatternGoto
     57  7c57					      ENDIF
     58  7c57					      tay
     59  7c57					      lda	tt_PatternPtrLo,y
     60  7c57					      sta	tt_ptr
     61  7c57					      lda	tt_PatternPtrHi,y
     62  7c57					      sta	tt_ptr+1
     63  7c57							; get new note
     64  7c57					      IF	TT_USE_OVERLAY = 0
     65  7c57					      ldy	tt_cur_note_index_c0,x
     66  7c57					      ELSE
     67  7c57							; If the V flag is set and if the new note is an instrument,
     68  7c57							; it means it got pre-fetched by an overlay percussion, it has
     69  7c57							; to remain in sustain.
     70  7c57					      clv
     71  7c57							; check if note had been pre-fetched by overlay perc already
     72  7c57					      lda	tt_cur_note_index_c0,x
     73  7c57					      bpl	.notPrefetched
     74  7c57							; If so, remove flag
     75  7c57					      and	#%01111111
     76  7c57					      sta	tt_cur_note_index_c0,x
     77  7c57							; Set V flag for later
     78  7c57					      bit	tt_Bit6Set
     79  7c57				   .notPrefetched
     80  7c57					      tay
     81  7c57					      ENDIF
     82  7c57					      lda	(tt_ptr),y
     83  7c57							; pre-process new note
     84  7c57							; 7..5: instrument (1..7), 4..0 (0..31): frequency
     85  7c57							; 0/0: End of pattern
     86  7c57					      bne	.noEndOfPattern
     87  7c57							; End of pattern: Advance to next pattern
     88  7c57					      sta	tt_cur_note_index_c0,x	; a is 0
     89  7c57					      inc	tt_cur_pat_index_c0,x
     90  7c57					      bne	.constructPatPtr	; unconditional
     91  7c57				   .noEndOfPattern
     92  7c57					      ENDM
     93  7c57
     94  7c57
     95  7c57							; ---------------------------------------------------------------------
     96  7c57							; Music player entry. Call once per frame.
     97  7c57							; ---------------------------------------------------------------------
     98  7c57				   tt_Player  SUBROUTINE
     99  7c57							; ==================== Sequencer ====================
    100  7c57							; Decrease speed timer
    101  7c57		       c6 d7		      dec	tt_timer
    102  7c59		       10 6e		      bpl	.noNewNote
    103  7c5b
    104  7c5b							; Timer ran out: Do sequencer
    105  7c5b							; Advance to next note
    106  7c5b		       a2 01		      ldx	#1	; 2 channels
    107  7c5d				   .advanceLoop
    108  7c5d					      IF	TT_USE_OVERLAY = 1
    109  7c5d		       20 73 fc 	      jsr	tt_FetchNote
    110  7c60				  -	      ELSE
    111  7c60				  -	      TT_FETCH_CURRENT_NOTE
    112  7c60					      ENDIF
    113  7c60							; Parse new note from pattern
    114  7c60		       c9 10		      cmp	#TT_INS_PAUSE
    115  7c62					      IF	TT_USE_SLIDE = 0
    116  7c62		       90 55		      bcc	.finishedNewNote
    117  7c64		       d0 3d		      bne	.newNote
    118  7c66				  -	      ELSE
    119  7c66				  -	      beq	.pause
    120  7c66				  -	      bcs	.newNote
    121  7c66				  -
    122  7c66				  -			; --- slide/hold ---
    123  7c66				  -			; Adjust frequency and hold note in sustain.
    124  7c66				  -			; composer/tracker has to make sure that no unwanted
    125  7c66				  -			; under/overflow happens.
    126  7c66				  -			; Note: f = f + (8-(16-x)) = x + f - 8
    127  7c66				  -	      adc	tt_cur_ins_c0,x	; carry is clear after cmp
    128  7c66				  -	      sec
    129  7c66				  -	      sbc	#8
    130  7c66				  -	      sta	tt_cur_ins_c0,x
    131  7c66				  -	      bcs	.finishedNewNote	; unconditional, since legally no underflow can happen (ins>0 or HOLD for ins=0)
    132  7c66					      ENDIF
    133  7c66
    134  7c66							; --- pause ---
    135  7c66				   .pause
    136  7c66							; Get release index for current instrument. Since a pause can
    137  7c66							; only follow an instrument, we don't need to handle percussion
    138  7c66							; or commands.
    139  7c66		       b5 de		      lda	tt_cur_ins_c0,x
    140  7c68		       20 01 fd 	      jsr	tt_CalcInsIndex
    141  7c6b		       b9 c9 fd 	      lda	tt_InsReleaseIndexes-1,y	; -1 b/c instruments start at #1
    142  7c6e							; Put it into release. Skip junk byte so index no longer indicates
    143  7c6e							; sustain phase.
    144  7c6e		       18		      clc
    145  7c6f		       69 01		      adc	#1
    146  7c71		       90 44		      bcc	.storeADIndex	; unconditional
    147  7c73
    148  7c73							; ---------------------------------------------------------------------
    149  7c73							; Helper subroutine to minimize ROM footprint. Will be inlined if
    150  7c73							; TT_USE_OVERLAY is not used.
    151  7c73							; Interleaved here so player can be inlined.
    152  7c73							; ---------------------------------------------------------------------
    153  7c73					      IF	TT_USE_OVERLAY = 1
    154  7c73				   tt_FetchNote
      0  7c73					      TT_FETCH_CURRENT_NOTE
      1  7c73
      2  7c73				   .constructPatPtr
      3  7c73		       b4 d8		      ldy	tt_cur_pat_index_c0,x
      4  7c75		       b9 dc fe 	      lda	tt_SequenceTable,y
      5  7c78					      IF	TT_USE_GOTO = 1
      6  7c78		       10 06		      bpl	.noPatternGoto
      7  7c7a		       29 7f		      and	#%01111111
      8  7c7c		       95 d8		      sta	tt_cur_pat_index_c0,x
      9  7c7e		       10 f3		      bpl	.constructPatPtr
     10  7c80				   .noPatternGoto
     11  7c80					      ENDIF
     12  7c80		       a8		      tay
     13  7c81		       b9 d2 fe 	      lda	tt_PatternPtrLo,y
     14  7c84		       85 e0		      sta	tt_ptr
     15  7c86		       b9 d7 fe 	      lda	tt_PatternPtrHi,y
     16  7c89		       85 e1		      sta	tt_ptr+1
     17  7c8b
     18  7c8b				  -	      IF	TT_USE_OVERLAY = 0
     19  7c8b				  -	      ldy	tt_cur_note_index_c0,x
     20  7c8b					      ELSE
     21  7c8b
     22  7c8b
     23  7c8b
     24  7c8b		       b8		      clv
     25  7c8c
     26  7c8c		       b5 da		      lda	tt_cur_note_index_c0,x
     27  7c8e		       10 07		      bpl	.notPrefetched
     28  7c90
     29  7c90		       29 7f		      and	#%01111111
     30  7c92		       95 da		      sta	tt_cur_note_index_c0,x
     31  7c94
     32  7c94		       2c 07 fd 	      bit	tt_Bit6Set
     33  7c97				   .notPrefetched
     34  7c97		       a8		      tay
     35  7c98					      ENDIF
     36  7c98		       b1 e0		      lda	(tt_ptr),y
     37  7c9a
     38  7c9a
     39  7c9a
     40  7c9a		       d0 06		      bne	.noEndOfPattern
     41  7c9c
     42  7c9c		       95 da		      sta	tt_cur_note_index_c0,x
     43  7c9e		       f6 d8		      inc	tt_cur_pat_index_c0,x
     44  7ca0		       d0 d1		      bne	.constructPatPtr
     45  7ca2				   .noEndOfPattern
    156  7ca2		       60		      rts
    157  7ca3					      ENDIF
    158  7ca3
    159  7ca3
    160  7ca3							; --- start instrument or percussion ---
    161  7ca3				   .newNote
    162  7ca3		       95 de		      sta	tt_cur_ins_c0,x	; set new instrument
    163  7ca5							; Instrument or percussion?
    164  7ca5		       c9 20		      cmp	#TT_FREQ_MASK+1
    165  7ca7		       b0 06		      bcs	.startInstrument
    166  7ca9
    167  7ca9							; --- start percussion ---
    168  7ca9							; Get index of envelope
    169  7ca9		       a8		      tay
    170  7caa							; -TT_FIRST_PERC because percussion start with TT_FIRST_PERC
    171  7caa		       b9 ed fd 	      lda	tt_PercIndexes-TT_FIRST_PERC,y
    172  7cad		       d0 08		      bne	.storeADIndex	; unconditional, since index values are >0
    173  7caf
    174  7caf							; --- start instrument ---
    175  7caf				   .startInstrument
    176  7caf					      IF	TT_USE_OVERLAY = 1
    177  7caf							; If V flag is set, this note had been pre-fetched. That means
    178  7caf							; it should remain in sustain.
    179  7caf		       70 08		      bvs	.finishedNewNote
    180  7cb1					      ENDIF
    181  7cb1							; Put note into attack/decay
    182  7cb1		       20 01 fd 	      jsr	tt_CalcInsIndex
    183  7cb4		       b9 bf fd 	      lda	tt_InsADIndexes-1,y	; -1 because instruments start at #1
    184  7cb7				   .storeADIndex
    185  7cb7		       95 dc		      sta	tt_envelope_index_c0,x
    186  7cb9
    187  7cb9							; --- Finished parsing new note ---
    188  7cb9				   .finishedNewNote
    189  7cb9							; increase note index into pattern
    190  7cb9		       f6 da		      inc	tt_cur_note_index_c0,x
    191  7cbb							; loop over channels
    192  7cbb				   .sequencerNextChannel
    193  7cbb		       ca		      dex
    194  7cbc		       10 9f		      bpl	.advanceLoop
    195  7cbe
    196  7cbe							; Reset timer value
    197  7cbe				  -	      IF	TT_GLOBAL_SPEED = 0
    198  7cbe				  -			; Get timer value for current pattern in channel 0
    199  7cbe				  -	      ldx	tt_cur_pat_index_c0	; get current pattern (index into tt_SequenceTable)
    200  7cbe				  -	      ldy	tt_SequenceTable,x	; Current pattern index now in y
    201  7cbe				  -	      IF	TT_USE_FUNKTEMPO = 0
    202  7cbe				  -	      lda	tt_PatternSpeeds,y
    203  7cbe				  -	      sta	tt_timer
    204  7cbe				  -	      ELSE
    205  7cbe				  -			; Test for odd/even frame
    206  7cbe				  -	      lda	tt_cur_note_index_c0
    207  7cbe				  -	      lsr
    208  7cbe				  -	      lda	tt_PatternSpeeds,y	; does not affect carry flag
    209  7cbe				  -	      bcc	.evenFrame
    210  7cbe				  -	      and	#$0f	; does not affect carry flag
    211  7cbe				  -	      bcs	.storeFunkTempo
    212  7cbe				  -.evenFrame
    213  7cbe				  -	      lsr
    214  7cbe				  -	      lsr
    215  7cbe				  -	      lsr
    216  7cbe				  -	      lsr
    217  7cbe				  -.storeFunkTempo
    218  7cbe				  -	      sta	tt_timer
    219  7cbe				  -	      ENDIF		; TT_USE_FUNKTEMPO = 0
    220  7cbe				  -
    221  7cbe					      ELSE
    222  7cbe							; Global tempo
    223  7cbe		       a2 04		      ldx	#TT_SPEED-1
    224  7cc0					      IF	TT_USE_FUNKTEMPO = 1
    225  7cc0		       a5 da		      lda	tt_cur_note_index_c0
    226  7cc2		       4a		      lsr
    227  7cc3		       90 02		      bcc	.noOddFrame
    228  7cc5		       a2 03		      ldx	#TT_ODD_SPEED-1
    229  7cc7				   .noOddFrame
    230  7cc7					      ENDIF		; TT_USE_FUNKTEMPO = 1
    231  7cc7		       86 d7		      stx	tt_timer
    232  7cc9					      ENDIF		; TT_GLOBAL_SPEED = 0
    233  7cc9
    234  7cc9							; No new note to process
    235  7cc9				   .noNewNote
    236  7cc9
    237  7cc9							; ==================== Update registers ====================
    238  7cc9		       a2 01		      ldx	#1	; 2 channels
    239  7ccb				   .updateLoop
    240  7ccb							; Percussion or melodic instrument?
    241  7ccb		       b5 de		      lda	tt_cur_ins_c0,x
    242  7ccd				  -	      IF	TT_STARTS_WITH_NOTES = 0
    243  7ccd				  -			; This branch can be removed if track starts with a note in each channel
    244  7ccd				  -	      beq	.afterAudioUpdate
    245  7ccd					      ENDIF
    246  7ccd		       c9 20		      cmp	#TT_FREQ_MASK+1
    247  7ccf		       b0 37		      bcs	.instrument	; Melodic instrument
    248  7cd1
    249  7cd1							; --- Percussion: Get envelope index ---
    250  7cd1		       b4 dc		      ldy	tt_envelope_index_c0,x
    251  7cd3							; Set AUDC and AUDV value from envelope
    252  7cd3		       b9 16 fe 	      lda	tt_PercCtrlVolTable-1,y	; -1 because values are stored +1
    253  7cd6		       f0 02		      beq	.endOfPercussion	; 0 means end of percussion data
    254  7cd8		       f6 dc		      inc	tt_envelope_index_c0,x	; if end not reached: advance index
    255  7cda				   .endOfPercussion
    256  7cda		       95 59		      sta	AUDV0,x
    257  7cdc		       4a		      lsr
    258  7cdd		       4a		      lsr
    259  7cde		       4a		      lsr
    260  7cdf		       4a		      lsr
    261  7ce0		       95 55		      sta	AUDC0,x
    262  7ce2							; Set AUDF
    263  7ce2		       b9 00 fe 	      lda	tt_PercFreqTable-1,y	; -1 because values are stored +1
    264  7ce5							; Bit 7 (overlay) might be set, but is unused in AUDF
    265  7ce5		       95 57		      sta	AUDF0,x
    266  7ce7					      IF	TT_USE_OVERLAY = 1
    267  7ce7		       10 48		      bpl	.afterAudioUpdate
    268  7ce9							; Overlay percussion: Fetch next note out of order
    269  7ce9		       20 73 fc 	      jsr	tt_FetchNote
    270  7cec							; Only do something if it's a melodic instrument
    271  7cec		       c9 20		      cmp	#TT_FREQ_MASK+1
    272  7cee		       90 41		      bcc	.afterAudioUpdate
    273  7cf0							; Instrument: Put into sustain
    274  7cf0		       95 de		      sta	tt_cur_ins_c0,x	; set new instrument
    275  7cf2		       20 01 fd 	      jsr	tt_CalcInsIndex
    276  7cf5		       b9 c4 fd 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start at #1
    277  7cf8		       95 dc		      sta	tt_envelope_index_c0,x
    278  7cfa							; Set prefetch flag. asl-sec-ror is smaller than lda-ora #128-sta
    279  7cfa		       16 da		      asl	tt_cur_note_index_c0,x
    280  7cfc		       38		      sec
    281  7cfd		       76 da		      ror	tt_cur_note_index_c0,x
    282  7cff		       30 30		      bmi	.afterAudioUpdate	; unconditional
    283  7d01				  -	      ELSE
    284  7d01				  -	      jmp	.afterAudioUpdate
    285  7d01					      ENDIF
    286  7d01
    287  7d01
    288  7d01							; ---------------------------------------------------------------------
    289  7d01							; Helper subroutine to minimize ROM footprint.
    290  7d01							; Interleaved here so player routine can be inlined.
    291  7d01							; ---------------------------------------------------------------------
    292  7d01				   tt_CalcInsIndex
    293  7d01							; move upper 3 bits to lower 3
    294  7d01		       4a		      lsr
    295  7d02		       4a		      lsr
    296  7d03		       4a		      lsr
    297  7d04		       4a		      lsr
    298  7d05		       4a		      lsr
    299  7d06		       a8		      tay
    300  7d07				   tt_Bit6Set		; This opcode has bit #6 set, for use with bit instruction
    301  7d07		       60		      rts
    302  7d08
    303  7d08
    304  7d08				   .instrument
    305  7d08							; --- Melodic instrument ---
    306  7d08							; Compute index into ADSR indexes and master Ctrl tables
    307  7d08		       20 01 fd 	      jsr	tt_CalcInsIndex
    308  7d0b							; Set AUDC with master value for this instrument, while we are at it
    309  7d0b		       b9 ba fd 	      lda	tt_InsCtrlTable-1,y	; -1 because instruments start with #1
    310  7d0e		       95 55		      sta	AUDC0,x
    311  7d10							; advance ADSR counter and compare to end of Sustain
    312  7d10		       b5 dc		      lda	tt_envelope_index_c0,x
    313  7d12		       d9 c9 fd 	      cmp	tt_InsReleaseIndexes-1,y	; -1 because instruments start with #1
    314  7d15		       d0 03		      bne	.noEndOfSustain
    315  7d17							; End of sustain: Go back to start of sustain
    316  7d17		       b9 c4 fd 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start with #1
    317  7d1a				   .noEndOfSustain
    318  7d1a		       a8		      tay
    319  7d1b							; Set volume from envelope
    320  7d1b		       b9 cf fd 	      lda	tt_InsFreqVolTable,y
    321  7d1e		       f0 01		      beq	.endOfEnvelope	; 0 means end of release has been reached:
    322  7d20		       c8		      iny		; advance index otherwise
    323  7d21				   .endOfEnvelope
    324  7d21		       94 dc		      sty	tt_envelope_index_c0,x
    325  7d23		       95 59		      sta	AUDV0,x
    326  7d25							; Now adjust frequency with ADSR value from envelope
    327  7d25		       4a		      lsr
    328  7d26		       4a		      lsr
    329  7d27		       4a		      lsr
    330  7d28		       4a		      lsr
    331  7d29		       18		      clc
    332  7d2a		       75 de		      adc	tt_cur_ins_c0,x
    333  7d2c		       38		      sec
    334  7d2d		       e9 08		      sbc	#8
    335  7d2f		       95 57		      sta	AUDF0,x
    336  7d31
    337  7d31				   .afterAudioUpdate
    338  7d31							; loop over channels
    339  7d31		       ca		      dex
    340  7d32		       10 97		      bpl	.updateLoop
    341  7d34
 Music player size:  $dd
    342  7d34					      echo	"Music player size: ", *-tt_PlayerStart
------- FILE BANK_FIXED.asm
   1278  7d34
   1279  7d34		       20 a7 fa 	      jsr	StealCharDraw	; NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
   1280  7d37
   1281  7d37							;---------------------------------------------------------------------------
   1282  7d37
   1283  7d37		       a9 09		      lda	#BANK_SCORING	; 2
   1284  7d39		       85 3e		      sta	SET_BANK_RAM	; 3
   1285  7d3b		       20 d5 f1 	      jsr	DrawDigits	; 6 = 11
   1286  7d3e
   1287  7d3e							;---------------------------------------------------------------------------
   1288  7d3e							; A 42-cycle timing window in the screen draw code.  Perform any general
   1289  7d3e							; per-frame code here, provided it takes exactly 42 cycles to execute.
   1290  7d3e							; TJ: Well, not exactly 42 cycles, but it works! :)
   1291  7d3e							;	 @09
   1292  7d3e							;sta COLUBK		      ; 3     value comes from subroutine
   1293  7d3e							; + the 'black' left-side of top screen colour change when look-around is actually a HMOVE bar, so we can't fix it :)
   1294  7d3e
   1295  7d3e							;		  inc Throttle		      ; 5     speed limiter
      0  7d3e					      SLEEP	2	;	 TODO: optimize for space
      1  7d3e				   .CYCLES    SET	2
      2  7d3e
      3  7d3e				  -	      IF	.CYCLES < 2
      4  7d3e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7d3e				  -	      ERR
      6  7d3e					      ENDIF
      7  7d3e
      8  7d3e				  -	      IF	.CYCLES & 1
      9  7d3e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  7d3e				  -	      nop	0
     11  7d3e				  -	      ELSE
     12  7d3e				  -	      bit	VSYNC
     13  7d3e				  -	      ENDIF
     14  7d3e				  -.CYCLES    SET	.CYCLES - 3
     15  7d3e					      ENDIF
     16  7d3e
     17  7d3e					      REPEAT	.CYCLES / 2
     18  7d3e		       ea		      nop
     19  7d3f					      REPEND
   1297  7d3f
   1298  7d3f		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
   1299  7d41		       ca		      dex		; 2	 = $6f, stars effect!
   1300  7d42		       86 62		      stx	HMM0	; 3	 @24, exactly 21 cycles after the HMOVE
   1301  7d44
   1302  7d44		       85 44		      sta	NUSIZ0	; 3
   1303  7d46		       84 65		      sty	VDELP0	; 3	 y = 0!
   1304  7d48
   1305  7d48		       c8		      iny		; 2	 this relies on Y == 0 before...
   1306  7d49		       c4 cd		      cpy	extraLifeTimer	; 3	 ..,and bit 0 is set in A
   1307  7d4b		       69 02		      adc	#2	; 2
   1308  7d4d		       85 5d		      sta	ENAM0	; 3	 dis/enable Cosmic Ark star effect
   1309  7d4f
   1310  7d4f		       a5 ab		      lda	ManLastDirection	; 3
   1311  7d51		       85 4b		      sta	REFP0	; 3
   1312  7d53
   1313  7d53		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
   1314  7d55		       85 3f		      sta	SET_BANK	; testing
   1315  7d57		       85 3e		      sta	SET_BANK_RAM	; 3
   1316  7d59		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1317  7d5c							;	 @66
   1318  7d5c		       a9 03		      lda	#BANK_PostScreenCleanup	; 2
   1319  7d5e		       85 3f		      sta	SET_BANK	; 3
   1320  7d60		       20 6d f5 	      jsr	PostScreenCleanup	; 6+x
   1321  7d63
   1322  7d63		       a9 00		      lda	#BANK_SelfModDrawPlayers	; 2
   1323  7d65		       85 3f		      sta	SET_BANK	; 3
   1324  7d67		       20 8c f2 	      jsr	SelfModDrawPlayers	; 6+x
   1325  7d6a
   1326  7d6a				   SkipSc
   1327  7d6a		       20 fa fa 	      jsr	writePlayerFrame
   1328  7d6d		       20 a7 fa 	      jsr	StealCharDraw
   1329  7d70
   1330  7d70		       ad 84 02    OverscanBD lda	INTIM	;4
   1331  7d73		       d0 fb		      bne	OverscanBD	;2/3
   1332  7d75
   1333  7d75		       4c 40 fc 	      jmp	NewFrameStart
   1334  7d78				   VBlankTime
   1335  7d78		       30 30		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
   1336  7d7a		       55 55		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_PAL
   1337  7d7c
   1338  7d7c							;---------------------------------------------------------------------------
   1339  7d7c
      0  7d7c					      DEFINE_SUBROUTINE	nextLevelMan
      1  7d7c		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7d7c					      SUBROUTINE
      3  7d7c				   nextLevelMan
   1341  7d7c
   1342  7d7c		       a9 0c		      lda	#BANK_EOL
   1343  7d7e		       85 3f		      sta	SET_BANK
   1344  7d80		       4c 06 f3 	      jmp	EOL
   1345  7d83
   1346  7d83
      0  7d83					      DEFINE_SUBROUTINE	nextLevelMan2
      1  7d83		       00 0f	   BANK_nextLevelMan2 =	_CURRENT_BANK
      2  7d83					      SUBROUTINE
      3  7d83				   nextLevelMan2
   1348  7d83
   1349  7d83		       c6 af		      dec	DelayEndOfLevel
   1350  7d85		       d0 29		      bne	genericRTS
   1351  7d87
   1352  7d87		       a9 09		      lda	#MANMODE_SWITCH
   1353  7d89		       85 a6		      sta	ManMode
   1354  7d8b
      0  7d8b					      DEFINE_SUBROUTINE	switchLevels
      1  7d8b		       00 0f	   BANK_switchLevels =	_CURRENT_BANK
      2  7d8b					      SUBROUTINE
      3  7d8b				   switchLevels
   1356  7d8b
   1357  7d8b							;lda #BANK_NextLevelX
   1358  7d8b							;sta SET_BANK
   1359  7d8b							;jmp NextLevelX
   1360  7d8b
   1361  7d8b							; Now do the actual switching
   1362  7d8b
   1363  7d8b		       a5 d0		      lda	NextLevelTrigger
   1364  7d8d		       29 7f		      and	#<(~BIT_NEXTLEVEL)
   1365  7d8f		       85 d0		      sta	NextLevelTrigger
   1366  7d91
   1367  7d91							; Next level is due. Point to the next level, but if we're at the end of playable levels,
   1368  7d91							; then increment the level number. This is completely circular, so we eventually wrap
   1369  7d91							; the level back to 0 and start afresh.
   1370  7d91
   1371  7d91		       e6 b8		      inc	levelX
   1372  7d93		       a5 b8		      lda	levelX
   1373  7d95		       c9 9e		      cmp	#MAX_LEVEL_NUMBER
   1374  7d97		       90 02		      bcc	.level_ok
   1375  7d99		       a9 00		      lda	#0
   1376  7d9b		       85 b8	   .level_ok  sta	levelX
   1377  7d9d		       60		      rts
   1378  7d9e
   1379  7d9e							;---------------------------------------------------------------------------
   1380  7d9e
   1381  7d9e
      0  7d9e					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7d9e		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7d9e					      SUBROUTINE
      3  7d9e				   CopyROM2RAM_F000
   1383  7d9e
   1384  7d9e		       a9 0c		      lda	#BANK_CopyROMShadowToRAM
   1385  7da0		       85 3f		      sta	SET_BANK
   1386  7da2		       85 c9		      sta	ROM_Bank
   1387  7da4		       4c 3d f0 	      jmp	CopyROMShadowToRAM_F000
   1388  7da7
   1389  7da7
   1390  7da7							;---------------------------------------------------------------------------
   1391  7da7
      0  7da7					      DEFINE_SUBROUTINE	RegisterTarget
      1  7da7		       00 0f	   BANK_RegisterTarget =	_CURRENT_BANK
      2  7da7					      SUBROUTINE
      3  7da7				   RegisterTarget
   1393  7da7
   1394  7da7		       f8		      sed
   1395  7da8		       18		      clc
   1396  7da9		       a5 bd		      lda	BCD_targetsRequired
   1397  7dab		       69 01		      adc	#1
   1398  7dad		       85 bd		      sta	BCD_targetsRequired
   1399  7daf		       d8		      cld
   1400  7db0		       60	   genericRTS rts
   1401  7db1
      0  7db1					      DEFINE_SUBROUTINE	DeRegisterTarget
      1  7db1		       00 0f	   BANK_DeRegisterTarget =	_CURRENT_BANK
      2  7db1					      SUBROUTINE
      3  7db1				   DeRegisterTarget
   1403  7db1
   1404  7db1		       f8		      sed
   1405  7db2		       38		      sec
   1406  7db3		       a5 bd		      lda	BCD_targetsRequired
   1407  7db5		       e9 01		      sbc	#1
   1408  7db7		       85 bd		      sta	BCD_targetsRequired
   1409  7db9		       d8		      cld
   1410  7dba		       60		      rts
   1411  7dbb
   1412  7dbb							;---------------------------------------------------------------------------
   1413  7dbb
   1414  7dbb							;include "circle.asm"
------- FILE sound/intro1_trackdata.asm LEVEL 3 PASS 4
      0  7dbb					      include	"sound/intro1_trackdata.asm"
      1  7dbb							; TIATracker music player
      2  7dbb							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7dbb							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7dbb							; Email: andre.wichmann@gmx.de
      5  7dbb							;
      6  7dbb							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7dbb							; you may not use this file except in compliance with the License.
      8  7dbb							; You may obtain a copy of the License at
      9  7dbb							;
     10  7dbb							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7dbb							;
     12  7dbb							; Unless required by applicable law or agreed to in writing, software
     13  7dbb							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7dbb							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7dbb							; See the License for the specific language governing permissions and
     16  7dbb							; limitations under the License.
     17  7dbb
     18  7dbb							; Song author: 
     19  7dbb							; Song name: 
     20  7dbb
     21  7dbb							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7dbb
     23  7dbb							; =====================================================================
     24  7dbb							; TIATracker melodic and percussion instruments, patterns and sequencer
     25  7dbb							; data.
     26  7dbb							; =====================================================================
     27  7dbb				   tt_TrackDataStart
     28  7dbb
     29  7dbb							; =====================================================================
     30  7dbb							; Melodic instrument definitions (up to 7). tt_envelope_index_c0/1 hold
     31  7dbb							; the index values into these tables for the current instruments played
     32  7dbb							; in channel 0 and 1.
     33  7dbb							; 
     34  7dbb							; Each instrument is defined by:
     35  7dbb							; - tt_InsCtrlTable: the AUDC value
     36  7dbb							; - tt_InsADIndexes: the index of the start of the ADSR envelope as
     37  7dbb							;	 defined in tt_InsFreqVolTable
     38  7dbb							; - tt_InsSustainIndexes: the index of the start of the Sustain phase
     39  7dbb							;	 of the envelope
     40  7dbb							; - tt_InsReleaseIndexes: the index of the start of the Release phase
     41  7dbb							; - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
     42  7dbb							;	 the envelope
     43  7dbb							; =====================================================================
     44  7dbb
     45  7dbb							; Instrument master CTRL values
     46  7dbb				   tt_InsCtrlTable
     47  7dbb		       07 04 0c 04*	      dc.b	$07, $04, $0c, $04, $0c
     48  7dc0
     49  7dc0
     50  7dc0							; Instrument Attack/Decay start indexes into ADSR tables.
     51  7dc0				   tt_InsADIndexes
     52  7dc0		       00 0e 0e 1e*	      dc.b	$00, $0e, $0e, $1e, $1e
     53  7dc5
     54  7dc5
     55  7dc5							; Instrument Sustain start indexes into ADSR tables
     56  7dc5				   tt_InsSustainIndexes
     57  7dc5		       08 19 19 2b*	      dc.b	$08, $19, $19, $2b, $2b
     58  7dca
     59  7dca
     60  7dca							; Instrument Release start indexes into ADSR tables
     61  7dca							; Caution: Values are stored with an implicit -1 modifier! To get the
     62  7dca							; real index, add 1.
     63  7dca				   tt_InsReleaseIndexes
     64  7dca		       09 1b 1b 2c*	      dc.b	$09, $1b, $1b, $2c, $2c
     65  7dcf
     66  7dcf
     67  7dcf							; AUDVx and AUDFx ADSR envelope values.
     68  7dcf							; Each byte encodes the frequency and volume:
     69  7dcf							; - Bits 7..4: Freqency modifier for the current note ([-8..7]),
     70  7dcf							;	 8 means no change. Bit 7 is the sign bit.
     71  7dcf							; - Bits 3..0: Volume
     72  7dcf							; Between sustain and release is one byte that is not used and
     73  7dcf							; can be any value.
     74  7dcf							; The end of the release phase is encoded by a 0.
     75  7dcf				   tt_InsFreqVolTable
     76  7dcf							; 0: Pizzicato bassb
     77  7dcf		       8a 8a 89 88*	      dc.b	$8a, $8a, $89, $88, $86, $85, $85, $84
     78  7dd7		       83 00 83 83*	      dc.b	$83, $00, $83, $83, $83, $00
     79  7ddd							; 1+2: Square2
     80  7ddd		       8c 8c 8b 89*	      dc.b	$8c, $8c, $8b, $89, $87, $85, $84, $83
     81  7de5		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $00, $81, $00
     82  7ded							; 3+4: Square
     83  7ded		       85 85 85 85*	      dc.b	$85, $85, $85, $85, $84, $83, $83, $82
     84  7df5		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $81, $00, $80
     85  7dfd		       00		      dc.b	$00
     86  7dfe
     87  7dfe
     88  7dfe
     89  7dfe							; =====================================================================
     90  7dfe							; Percussion instrument definitions (up to 15)
     91  7dfe							;
     92  7dfe							; Each percussion instrument is defined by:
     93  7dfe							; - tt_PercIndexes: The index of the first percussion frame as defined
     94  7dfe							;	 in tt_PercFreqTable and tt_PercCtrlVolTable
     95  7dfe							; - tt_PercFreqTable: The AUDF frequency value
     96  7dfe							; - tt_PercCtrlVolTable: The AUDV volume and AUDC values
     97  7dfe							; =====================================================================
     98  7dfe
     99  7dfe							; Indexes into percussion definitions signifying the first frame for
    100  7dfe							; each percussion in tt_PercFreqTable.
    101  7dfe							; Caution: Values are stored with an implicit +1 modifier! To get the
    102  7dfe							; real index, subtract 1.
    103  7dfe				   tt_PercIndexes
    104  7dfe		       01 0a 0c 	      dc.b	$01, $0a, $0c
    105  7e01
    106  7e01
    107  7e01							; The AUDF frequency values for the percussion instruments.
    108  7e01							; If the second to last value is negative (>=128), it means it's an
    109  7e01							; "overlay" percussion, i.e. the player fetches the next instrument note
    110  7e01							; immediately and starts it in the sustain phase next frame. (Needs
    111  7e01							; TT_USE_OVERLAY)
    112  7e01				   tt_PercFreqTable
    113  7e01							; 0: Kick
    114  7e01		       00 01 02 03*	      dc.b	$00, $01, $02, $03, $04, $05, $06, $87
    115  7e09		       00		      dc.b	$00
    116  7e0a							; 1: HH
    117  7e0a		       80 00		      dc.b	$80, $00
    118  7e0c							; 2: Snare
    119  7e0c		       01 03 06 0e*	      dc.b	$01, $03, $06, $0e, $13, $11, $15, $14
    120  7e14		       17 1b 00 	      dc.b	$17, $1b, $00
    121  7e17
    122  7e17
    123  7e17							; The AUDCx and AUDVx volume values for the percussion instruments.
    124  7e17							; - Bits 7..4: AUDC value
    125  7e17							; - Bits 3..0: AUDV value
    126  7e17							; 0 means end of percussion data.
    127  7e17				   tt_PercCtrlVolTable
    128  7e17							; 0: Kick
    129  7e17		       ee ed ed eb*	      dc.b	$ee, $ed, $ed, $eb, $e9, $e8, $e8, $e6
    130  7e1f		       00		      dc.b	$00
    131  7e20							; 1: HH
    132  7e20		       87 00		      dc.b	$87, $00
    133  7e22							; 2: Snare
    134  7e22		       8b 8a 8a 8a*	      dc.b	$8b, $8a, $8a, $8a, $8a, $8a, $89, $88
    135  7e2a		       87 86 00 	      dc.b	$87, $86, $00
    136  7e2d
    137  7e2d
    138  7e2d
    139  7e2d							; =====================================================================
    140  7e2d							; Track definition
    141  7e2d							; The track is defined by:
    142  7e2d							; - tt_PatternX (X=0, 1, ...): Pattern definitions
    143  7e2d							; - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
    144  7e2d							;	 as index values
    145  7e2d							; - tt_SequenceTable: The order in which the patterns should be played,
    146  7e2d							;	 i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
    147  7e2d							;	 for all channels and sub-tracks. The variables
    148  7e2d							;	 tt_cur_pat_index_c0/1 hold an index into tt_SequenceTable for
    149  7e2d							;	 each channel.
    150  7e2d							;
    151  7e2d							; So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
    152  7e2d							; in turn point to pattern definitions (tt_PatternX) in which the notes
    153  7e2d							; to play are specified.
    154  7e2d							; =====================================================================
    155  7e2d
    156  7e2d							; ---------------------------------------------------------------------
    157  7e2d							; Pattern definitions, one table per pattern. tt_cur_note_index_c0/1
    158  7e2d							; hold the index values into these tables for the current pattern
    159  7e2d							; played in channel 0 and 1.
    160  7e2d							;
    161  7e2d							; A pattern is a sequence of notes (one byte per note) ending with a 0.
    162  7e2d							; A note can be either:
    163  7e2d							; - Pause: Put melodic instrument into release. Must only follow a
    164  7e2d							;	 melodic instrument.
    165  7e2d							; - Hold: Continue to play last note (or silence). Default "empty" note.
    166  7e2d							; - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
    167  7e2d							;	 by -7..+7 and keep playing it
    168  7e2d							; - Play new note with melodic instrument
    169  7e2d							; - Play new note with percussion instrument
    170  7e2d							; - End of pattern
    171  7e2d							;
    172  7e2d							; A note is defined by:
    173  7e2d							; - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
    174  7e2d							;	 and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
    175  7e2d							;	 defined as:
    176  7e2d							;	 - 0: End of pattern
    177  7e2d							;	 - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
    178  7e2d							;	 - 8: Hold
    179  7e2d							;	 - 16: Pause
    180  7e2d							;	 - [17..31]: Play percussion instrument 1..15
    181  7e2d							;
    182  7e2d							; The tracker must ensure that a pause only follows a melodic
    183  7e2d							; instrument or a hold/slide.
    184  7e2d							; ---------------------------------------------------------------------
    185  7e2d		       00 1f	   TT_FREQ_MASK =	%00011111
    186  7e2d		       00 08	   TT_INS_HOLD =	8
    187  7e2d		       00 10	   TT_INS_PAUSE =	16
    188  7e2d		       00 11	   TT_FIRST_PERC =	17
    189  7e2d
    190  7e2d							; Intro left
    191  7e2d				   tt_pattern0
    192  7e2d		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $3e, $08
    193  7e35		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $3e, $08
    194  7e3d		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $12, $3e
    195  7e45		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $13, $08
    196  7e4d		       00		      dc.b	$00
    197  7e4e
    198  7e4e							; Intro2 L
    199  7e4e				   tt_pattern1
    200  7e4e		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    201  7e56		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    202  7e5e		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    203  7e66		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    204  7e6e		       00		      dc.b	$00
    205  7e6f
    206  7e6f							; Intro2-fill L
    207  7e6f				   tt_pattern2
    208  7e6f		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    209  7e77		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    210  7e7f		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    211  7e87		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    212  7e8f		       00		      dc.b	$00
    213  7e90
    214  7e90							; Intro right
    215  7e90				   tt_pattern3
    216  7e90		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $73, $08
    217  7e98		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $73, $08, $73, $08
    218  7ea0		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $b3, $08
    219  7ea8		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    220  7eb0		       00		      dc.b	$00
    221  7eb1
    222  7eb1							; Intro2 R
    223  7eb1				   tt_pattern4
    224  7eb1		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    225  7eb9		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    226  7ec1		       b3 08 73 08*	      dc.b	$b3, $08, $73, $08, $b3, $08, $73, $08
    227  7ec9		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    228  7ed1		       00		      dc.b	$00
    229  7ed2
    230  7ed2
    231  7ed2
    232  7ed2
    233  7ed2							; Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
    234  7ed2							; Each byte encodes the speed of one pattern in the order
    235  7ed2							; of the tt_PatternPtr tables below.
    236  7ed2							; If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
    237  7ed2							; the even speed and the high nibble the odd speed.
    238  7ed2				  -	      IF	TT_GLOBAL_SPEED = 0
    239  7ed2				  -tt_PatternSpeeds
    240  7ed2				  -%%PATTERNSPEEDS%%
    241  7ed2					      ENDIF
    242  7ed2
    243  7ed2
    244  7ed2							; ---------------------------------------------------------------------
    245  7ed2							; Pattern pointers look-up table.
    246  7ed2							; ---------------------------------------------------------------------
    247  7ed2				   tt_PatternPtrLo
    248  7ed2		       2d 4e 6f 90	      dc.b	<tt_pattern0, <tt_pattern1, <tt_pattern2, <tt_pattern3
    249  7ed6		       b1		      dc.b	<tt_pattern4
    250  7ed7				   tt_PatternPtrHi
    251  7ed7		       fe fe fe fe	      dc.b	>tt_pattern0, >tt_pattern1, >tt_pattern2, >tt_pattern3
    252  7edb		       fe		      dc.b	>tt_pattern4
    253  7edc
    254  7edc
    255  7edc							; ---------------------------------------------------------------------
    256  7edc							; Pattern sequence table. Each byte is an index into the
    257  7edc							; tt_PatternPtrLo/Hi tables where the pointers to the pattern
    258  7edc							; definitions can be found. When a pattern has been played completely,
    259  7edc							; the next byte from this table is used to get the address of the next
    260  7edc							; pattern to play. tt_cur_pat_index_c0/1 hold the current index values
    261  7edc							; into this table for channels 0 and 1.
    262  7edc							; If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
    263  7edc							; number encoded in bits 6..0 (i.e. value AND %01111111).
    264  7edc							; ---------------------------------------------------------------------
    265  7edc				   tt_SequenceTable
    266  7edc							; ---------- Channel 0 ----------
    267  7edc		       00 00 01 02*	      dc.b	$00, $00, $01, $02, $80
    268  7ee1
    269  7ee1
    270  7ee1							; ---------- Channel 1 ----------
    271  7ee1		       03 04 03 04*	      dc.b	$03, $04, $03, $04, $85
    272  7ee6
    273  7ee6
 Track size:  $12b
    274  7ee6					      echo	"Track size: ", *-tt_TrackDataStart
------- FILE BANK_FIXED.asm
   1416  7ee6
------- FILE characterset/character_TARGET.asm LEVEL 3 PASS 4
      0  7ee6					      include	"characterset/character_TARGET.asm"
      1  7ee6							;    Sokoboo - a Sokoban implementation
      2  7ee6							;    using a generic tile-based display engine for the Atari 2600
      3  7ee6							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7ee6							;
      5  7ee6							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7ee6							;
      7  7ee6							;    Code related to the generic tile-based display engine was developed by
      8  7ee6							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7ee6							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7ee6							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7ee6							;
     12  7ee6							;    Code related to music and sound effects uses the TIATracker music player
     13  7ee6							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7ee6							;    directory for Apache licensing details.
     15  7ee6							;
     16  7ee6							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7ee6							;    See the copyright notices in the License directory for a list of level
     18  7ee6							;    contributors.
     19  7ee6							;
     20  7ee6							;    Except where otherwise indicated, this software is released under the
     21  7ee6							;    following licensing arrangement...
     22  7ee6							;
     23  7ee6							;    This program is free software: you can redistribute it and/or modify
     24  7ee6							;    it under the terms of the GNU General Public License as published by
     25  7ee6							;    the Free Software Foundation, either version 3 of the License, or
     26  7ee6							;    (at your option) any later version.
     27  7ee6							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7ee6
     29  7ee6							;    This program is distributed in the hope that it will be useful,
     30  7ee6							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7ee6							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7ee6							;    GNU General Public License for more details.
     33  7ee6
     34  7ee6		       00 02	   TARGET_DEF =	2
     35  7ee6
     36  7ee6					      if	TARGET_DEF = 2
     37  7ee6
      0  7ee6					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET", LINES_PER_CHAR+1
     10  7ee6					      LIST	ON
     39  7ee6							;CHARACTERSHAPE_TARGET2_MIRRORED
     40  7ee6							;    .byte %00000000
     41  7ee6				   CHARACTERSHAPE_TARGET
     42  7ee6				   CHARACTERSHAPE_TARGET_MIRRORED
     43  7ee6		       00		      .byte.b	%00000000
     44  7ee7		       00		      .byte.b	%00000000
     45  7ee8		       66		      .byte.b	%01100110
     46  7ee9		       66		      .byte.b	%01100110
     47  7eea		       66		      .byte.b	%01100110
     48  7eeb		       66		      .byte.b	%01100110
     49  7eec		       00		      .byte.b	%00000000
     50  7eed		       00		      .byte.b	%00000000
     51  7eee		       00		      .byte.b	%00000000	;R
     52  7eef		       00		      .byte.b	%00000000
     53  7ef0		       66		      .byte.b	%01100110
     54  7ef1		       66		      .byte.b	%01100110
     55  7ef2		       66		      .byte.b	%01100110
     56  7ef3		       66		      .byte.b	%01100110
     57  7ef4		       00		      .byte.b	%00000000
     58  7ef5		       00		      .byte.b	%00000000
     59  7ef6		       00		      .byte.b	%00000000	;B
     60  7ef7		       00		      .byte.b	%00000000
     61  7ef8		       66		      .byte.b	%01100110
     62  7ef9		       66		      .byte.b	%01100110
     63  7efa		       66		      .byte.b	%01100110
     64  7efb		       66		      .byte.b	%01100110
     65  7efc		       00		      .byte.b	%00000000
     66  7efd		       00		      .byte.b	%00000000
     67  7efe
     68  7efe							;--------------------------------------------------------------------------
     69  7efe							;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_TARGET_MIRRORED", LINES_PER_CHAR+1
     70  7efe
     71  7efe							;CHARACTERSHAPE_TARGET2
     72  7efe							;CHARACTERSHAPE_TARGET2_MIRRORED
     73  7efe							;    ds 21,0	      ; replace with BLANK?!
     74  7efe
     75  7efe							;    CHECKPAGE CHARACTERSHAPE_TARGET2 ; since we share one byte!
     76  7efe
     77  7efe					      endif
------- FILE BANK_FIXED.asm
------- FILE characterset/character_STEEL.asm LEVEL 3 PASS 4
      0  7efe					      include	"characterset/character_STEEL.asm"
      1  7efe							;    Sokoboo - a Sokoban implementation
      2  7efe							;    using a generic tile-based display engine for the Atari 2600
      3  7efe							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7efe							;
      5  7efe							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7efe							;
      7  7efe							;    Code related to the generic tile-based display engine was developed by
      8  7efe							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7efe							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7efe							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7efe							;
     12  7efe							;    Code related to music and sound effects uses the TIATracker music player
     13  7efe							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7efe							;    directory for Apache licensing details.
     15  7efe							;
     16  7efe							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7efe							;    See the copyright notices in the License directory for a list of level
     18  7efe							;    contributors.
     19  7efe							;
     20  7efe							;    Except where otherwise indicated, this software is released under the
     21  7efe							;    following licensing arrangement...
     22  7efe							;
     23  7efe							;    This program is free software: you can redistribute it and/or modify
     24  7efe							;    it under the terms of the GNU General Public License as published by
     25  7efe							;    the Free Software Foundation, either version 3 of the License, or
     26  7efe							;    (at your option) any later version.
     27  7efe							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7efe
     29  7efe							;    This program is distributed in the hope that it will be useful,
     30  7efe							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7efe							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7efe							;    GNU General Public License for more details.
     33  7efe
     34  7efe							;--------------------------------------------------------------------------
      0  7efe					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_STEEL
 REQUESTED SIZE =  $18
 WASTED SPACE =  $2
 PAGEBREAK LOCATION =  $ff00
     10  7f00					      LIST	ON
     36  7f00				   CHARACTERSHAPE_STEEL
     37  7f00		       00 88 00 00*	      .byte.b	%00000000,%10001000,%00000000,%00000000,%00000000,%00100010,%00000000,%00000000	;R
     38  7f08		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11111111,%11011101,%11111111	;G
     39  7f10		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11111111,%11011101,%11111111	;B
     40  7f18
     41  7f18							;--------------------------------------------------------------------------
      0  7f18					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
     10  7f18					      LIST	ON
     43  7f18				   CHARACTERSHAPE_STEEL_MIRRORED
     44  7f18		       00 11 00 00*	      .byte.b	%00000000,%00010001,%00000000,%00000000,%00000000,%01000100,%00000000,%00000000	;R
     45  7f20		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%11111111,%10111011,%11111111	;G
     46  7f28		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%11111111,%10111011,%11111111	;B
------- FILE BANK_FIXED.asm
------- FILE characterset/character_SOIL.asm LEVEL 3 PASS 4
      0  7f30					      include	"characterset/character_SOIL.asm"
      1  7f30							;    Sokoboo - a Sokoban implementation
      2  7f30							;    using a generic tile-based display engine for the Atari 2600
      3  7f30							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7f30							;
      5  7f30							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7f30							;
      7  7f30							;    Code related to the generic tile-based display engine was developed by
      8  7f30							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7f30							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7f30							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7f30							;
     12  7f30							;    Code related to music and sound effects uses the TIATracker music player
     13  7f30							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7f30							;    directory for Apache licensing details.
     15  7f30							;
     16  7f30							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7f30							;    See the copyright notices in the License directory for a list of level
     18  7f30							;    contributors.
     19  7f30							;
     20  7f30							;    Except where otherwise indicated, this software is released under the
     21  7f30							;    following licensing arrangement...
     22  7f30							;
     23  7f30							;    This program is free software: you can redistribute it and/or modify
     24  7f30							;    it under the terms of the GNU General Public License as published by
     25  7f30							;    the Free Software Foundation, either version 3 of the License, or
     26  7f30							;    (at your option) any later version.
     27  7f30							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7f30
     29  7f30							;    This program is distributed in the hope that it will be useful,
     30  7f30							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7f30							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7f30							;    GNU General Public License for more details.
     33  7f30
      0  7f30					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  7f30					      LIST	ON
     35  7f30				   CHARACTERSHAPE_SOIL
     36  7f30				   CHARACTERSHAPE_SOIL_MIRRORED
     37  7f30		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     38  7f38		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
     39  7f40		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_FIXED.asm
------- FILE characterset/character_BOX.asm LEVEL 3 PASS 4
      0  7f48					      include	"characterset/character_BOX.asm"
      1  7f48							;    Sokoboo - a Sokoban implementation
      2  7f48							;    using a generic tile-based display engine for the Atari 2600
      3  7f48							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7f48							;
      5  7f48							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7f48							;
      7  7f48							;    Code related to the generic tile-based display engine was developed by
      8  7f48							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7f48							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7f48							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7f48							;
     12  7f48							;    Code related to music and sound effects uses the TIATracker music player
     13  7f48							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7f48							;    directory for Apache licensing details.
     15  7f48							;
     16  7f48							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7f48							;    See the copyright notices in the License directory for a list of level
     18  7f48							;    contributors.
     19  7f48							;
     20  7f48							;    Except where otherwise indicated, this software is released under the
     21  7f48							;    following licensing arrangement...
     22  7f48							;
     23  7f48							;    This program is free software: you can redistribute it and/or modify
     24  7f48							;    it under the terms of the GNU General Public License as published by
     25  7f48							;    the Free Software Foundation, either version 3 of the License, or
     26  7f48							;    (at your option) any later version.
     27  7f48							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7f48
     29  7f48							;    This program is distributed in the hope that it will be useful,
     30  7f48							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7f48							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7f48							;    GNU General Public License for more details.
     33  7f48
      0  7f48					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  7f48					      LIST	ON
     35  7f48				   CHARACTERSHAPE_BOX
     36  7f48				  -	      if	MIRRORED_BOX = NO
     37  7f48				  -CHARACTERSHAPE_BOX_MIRRORED
     38  7f48					      endif
     39  7f48		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%10011001,%11111111,%11111111,%0	;R
     40  7f50		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     41  7f58		       00 00 00 00*	      .byte.b	%0,%0,%0,0,%0,%0,%0,0	;B
     42  7f60
     43  7f60							;--------------------------------------------------------------------------
     44  7f60					      if	MIRRORED_BOX = YES
      0  7f60					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
     10  7f60					      LIST	ON
     46  7f60				   CHARACTERSHAPE_BOX_MIRRORED
     47  7f60		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%10011001,%11111111,%11111111,%0	;R
     48  7f68		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     49  7f70		       00 00 00 00*	      .byte.b	%0,%0,0,0,%0,%0,%0,0	;B
     50  7f78					      endif
     51  7f78
      0  7f78					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET", LINES_PER_CHAR
     10  7f78					      LIST	ON
     53  7f78				   CHARACTERSHAPE_BOX_ON_TARGET
     54  7f78				  -	      if	MIRRORED_BOX = NO
     55  7f78				  -CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     56  7f78					      endif
     57  7f78		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     58  7f80		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     59  7f88		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,%01100110,%0,%0,0	;B
     60  7f90
     61  7f90							;--------------------------------------------------------------------------
     62  7f90					      if	MIRRORED_BOX = YES
      0  7f90					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED", LINES_PER_CHAR
     10  7f90					      LIST	ON
     64  7f90				   CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     65  7f90		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     66  7f98		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     67  7fa0		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,%01100110,0,%0,%0	;B
     68  7fa8					      endif
------- FILE BANK_FIXED.asm
------- FILE characterset/character_WALL.asm LEVEL 3 PASS 4
      0  7fa8					      include	"characterset/character_WALL.asm"
      1  7fa8							;    Sokoboo - a Sokoban implementation
      2  7fa8							;    using a generic tile-based display engine for the Atari 2600
      3  7fa8							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7fa8							;
      5  7fa8							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7fa8							;
      7  7fa8							;    Code related to the generic tile-based display engine was developed by
      8  7fa8							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7fa8							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7fa8							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7fa8							;
     12  7fa8							;    Code related to music and sound effects uses the TIATracker music player
     13  7fa8							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7fa8							;    directory for Apache licensing details.
     15  7fa8							;
     16  7fa8							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7fa8							;    See the copyright notices in the License directory for a list of level
     18  7fa8							;    contributors.
     19  7fa8							;
     20  7fa8							;    Except where otherwise indicated, this software is released under the
     21  7fa8							;    following licensing arrangement...
     22  7fa8							;
     23  7fa8							;    This program is free software: you can redistribute it and/or modify
     24  7fa8							;    it under the terms of the GNU General Public License as published by
     25  7fa8							;    the Free Software Foundation, either version 3 of the License, or
     26  7fa8							;    (at your option) any later version.
     27  7fa8							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7fa8
     29  7fa8							;    This program is distributed in the hope that it will be useful,
     30  7fa8							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7fa8							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7fa8							;    GNU General Public License for more details.
     33  7fa8
      0  7fa8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  7fa8					      LIST	ON
     35  7fa8
     36  7fa8		       00 00	   BRICK_WALL_DEF =	0
     37  7fa8
     38  7fa8				   CHARACTERSHAPE_WALL
     39  7fa8				   CHARACTERSHAPE_WALL0
     40  7fa8
     41  7fa8
     42  7fa8
     43  7fa8				  -	      if	MIRRORED_WALL = NO
     44  7fa8				  -CHARACTERSHAPE_WALL_MIRRORED
     45  7fa8				  -CHARACTERSHAPE_WALL0_MIRRORED
     46  7fa8					      endif
     47  7fa8
     48  7fa8					      if	BRICK_WALL_DEF = 0
     49  7fa8		       00 ee ee ee*	      .byte.b	%00000000,%11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;R
     50  7fb0		       ee ee ee ee*	      .byte.b	%11101110,%11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;G
     51  7fb8		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     52  7fc0					      endif
     53  7fc0
     54  7fc0
     55  7fc0
     56  7fc0							;--------------------------------------------------------------------------
     57  7fc0					      if	MIRRORED_WALL = YES
      0  7fc0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  7fc0					      LIST	ON
     59  7fc0				   CHARACTERSHAPE_WALL_MIRRORED
     60  7fc0				   CHARACTERSHAPE_WALL0_MIRRORED
     61  7fc0
     62  7fc0					      if	BRICK_WALL_DEF = 0
     63  7fc0		       00 77 77 77*	      .byte.b	%00000000,%01110111,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;R
     64  7fc8		       77 77 77 77*	      .byte.b	%01110111,%01110111,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;G
     65  7fd0		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     66  7fd8					      endif
     67  7fd8
     68  7fd8
     69  7fd8					      endif
------- FILE BANK_FIXED.asm
   1422  7fd8
   1423  7fd8				  -	      if	DIGITS
   1424  7fd8				  -	      include	"characterset/character_9.asm"
   1425  7fd8				  -	      include	"characterset/character_8.asm"
   1426  7fd8				  -	      include	"characterset/character_7.asm"
   1427  7fd8				  -	      include	"characterset/character_6.asm"
   1428  7fd8				  -	      include	"characterset/character_5.asm"
   1429  7fd8				  -	      include	"characterset/character_4.asm"
   1430  7fd8				  -	      include	"characterset/character_3.asm"
   1431  7fd8				  -	      include	"characterset/character_2.asm"
   1432  7fd8				  -	      include	"characterset/character_1.asm"
   1433  7fd8				  -	      include	"characterset/character_0.asm"
   1434  7fd8					      endif
   1435  7fd8
   1436  7fd8				  -	      if	TROPHY
   1437  7fd8				  -	      include	"trophyData.asm"
   1438  7fd8					      endif
   1439  7fd8
   1440  7fd8
   1441  7fd8
   1442  7fd8
 FREE BYTES IN FIXED BANK =  $23
   1443  7fd8					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1444  7fd8
   1445  7fd8							;---------------------------------------------------------------------------
   1446  7fd8							; The reset vectors
   1447  7fd8							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1448  7fd8
   1449  8000 ????				      SEG	InterruptVectors
   1450  7ffc					      ORG	FIXED_BANK + $7FC
   1451  7ffc					      RORG	$7ffC
   1452  7ffc
   1453  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1454  7ffc		       b1 fb		      .word.w	Reset	; RESET
   1455  7ffe		       b1 fb		      .word.w	Reset	; IRQ	      (not used)
   1456  8000
   1457  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
    895  8000
    896  8000					      END
