------- FILE ./sokoboo.asm LEVEL 1 PASS 3
      1  8000 ????
      2  8000 ????						;------------------------------------------------------------------------------
      3  8000 ????						; not-BOXdash(R)! Copyright (C)2003-2011 Andrew Davie and Thomas Jentzsch.
      4  8000 ????						; This is an engine for background animation games. The engine uses bankswitch scheme
      5  8000 ????						; Tigervision Extended (3E). Display technology developed late 2004, Copyright (C)2005-2011
      6  8000 ????						; Andrew Davie, Thomas Jentzsch. Thomas on-board mid-MAY 2005.
      7  8000 ????						; Abandoned ~Febuary 2008, re-started December 2008. Abandoned!
      8  8000 ????						; Re-started for demo release June 2011.
      9  8000 ????
     10  8000 ????						; Some portions of this code may be freely used for private, educational and research
     11  8000 ????						; purposes, excluding BOX Dash(R)-specific logic and routines, which may not
     12  8000 ????						; be distributed and which remain Copyright (C) First Star Software 1984-2011.
     13  8000 ????						; If you wish to profit from this code, please ask for permission first.
     14  8000 ????						;------------------------------------------------------------------------------
     15  8000 ????
     16  8000 ????
     17  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     18  8000 ????
     19  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  8000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  8000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  8000 ????						;
     10  8000 ????						; This file defines hardware registers and memory mapping for the
     11  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  8000 ????						; available at at http://www.atari2600.org/dasm
     14  8000 ????						;
     15  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  8000 ????						; with your views.  Please contribute, if you think you can improve this
     19  8000 ????						; file!
     20  8000 ????						;
     21  8000 ????						; Latest Revisions...
     22  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  8000 ????						;			    This will allow conditional code to verify VCS.H being
     25  8000 ????						;			    used for code assembly.
     26  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  8000 ????						;			 mirrored reading/writing differences.	This is more a
     29  8000 ????						;			 readability issue, and binary compatibility with disassembled
     30  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  8000 ????						;			 which was broken by the use of segments in this file, as
     33  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  8000 ????						;						   it is safe to leave it undefined, and the base address will
     38  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  8000 ????						;			  - register definitions are now generated through assignment
     41  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  8000 ????						;			    address architecture.
     43  8000 ????						; 1.0	22/MAR/2003		Initial release
     44  8000 ????
     45  8000 ????
     46  8000 ????						;-------------------------------------------------------------------------------
     47  8000 ????
     48  8000 ????						; TIA_BASE_ADDRESS
     49  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  8000 ????						; Normally 0, the base address should (externally, before including this file)
     51  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  8000 ????						; < $40 as a bankswitch.
     54  8000 ????
     55  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     56  8000 ????			  -TIA_BASE_ADDRESS =	0
     57  8000 ????				      ENDIF
     58  8000 ????
     59  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  8000 ????						; *OR* by declaring the label before including this file, eg:
     62  8000 ????						; TIA_BASE_ADDRESS = $40
     63  8000 ????						;   include "vcs.h"
     64  8000 ????
     65  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  8000 ????						; for the mirrored ROM hardware registers.
     68  8000 ????
     69  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     71  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     74  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  8000 ????				      ENDIF
     80  8000 ????
     81  8000 ????						;-------------------------------------------------------------------------------
     82  8000 ????
     83 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0040
     86 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0040
     88 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U006d
    134 U006d							;-------------------------------------------------------------------------------
    135 U006d
    136 U004e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0040					      ORG	TIA_BASE_READ_ADDRESS
    138 U0040
    139 U0040							;											bit 7	 bit 6
    140 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U004e
    155 U004e							;-------------------------------------------------------------------------------
    156 U004e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  0000 ????
      4  0000 ????	       00 6a	   VERSION_MACRO =	106
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	22/MAR/2003		Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Andrew Davie
     97  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  0000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  0000 ????						; Use as very first section of code on boot (ie: at reset)
    101  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  0000 ????
    103  0000 ????				      MAC	clean_start
    104  0000 ????				      sei
    105  0000 ????				      cld
    106  0000 ????
    107  0000 ????				      ldx	#0
    108  0000 ????				      txa
    109  0000 ????				      tay
    110  0000 ????			   .CLEAR_STACK dex
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  0000 ????
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    151  0000 ????			   .FREE_BYTES SET	0
    152  0000 ????				      MAC	boundary
    153  0000 ????				      REPEAT	256
    154  0000 ????				      IF	<. % {1} = 0
    155  0000 ????				      MEXIT
    156  0000 ????				      ELSE
    157  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    158  0000 ????				      .byte	$00
    159  0000 ????				      ENDIF
    160  0000 ????				      REPEND
    161  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    162  0000 ????				      ENDM
    163  0000 ????
    164  0000 ????
    165  0000 ????						; EOF
------- FILE ./sokoboo.asm
     22  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						; segtime optimization (averages):
      2  0000 ????						;   lost time = segtime/2 * 64
      3  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
      4  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
      5  0000 ????						;
      6  0000 ????						; segtime = 2:
      7  0000 ????						;   lost time = 64
      8  0000 ????						;   num-segments = 28
      9  0000 ????						;   overhead = 224!
     10  0000 ????						; segtime = 3:
     11  0000 ????						;   lost time = 96
     12  0000 ????						;   num-segments = 18
     13  0000 ????						;   overhead = 144!
     14  0000 ????						; segtime = 4: 	     <--!!!
     15  0000 ????						;   lost time = 128!
     16  0000 ????						;   num-segments = 28
     17  0000 ????						;   overhead = 112
     18  0000 ????						; segtime = 5:
     19  0000 ????						;   lost time = 160!
     20  0000 ????						;   num-segments = 11
     21  0000 ????						;   overhead = 88
     22  0000 ????						; segtime = 6:
     23  0000 ????						;   lost time = 192!
     24  0000 ????						;   num-segments = 9
     25  0000 ????						;   overhead = 72
     26  0000 ????						; segtime = 7:
     27  0000 ????						;   lost time = 224!
     28  0000 ????						;   num-segments = 8
     29  0000 ????						;   overhead = 64
     30  0000 ????						; segtime = 10:
     31  0000 ????						;   lost time = 320!
     32  0000 ????						;   num-segments = 5
     33  0000 ????						;   overhead = 40
     34  0000 ????						; segtime = 20:
     35  0000 ????						;   lost time = 640!
     36  0000 ????						;   num-segments = 2
     37  0000 ????						;   overhead = 16
     38  0000 ????						; segtime = 40:
     39  0000 ????						;   lost time = 1280!
     40  0000 ????						;   num-segments = 1
     41  0000 ????						;   overhead = 8
     42  0000 ????
     43  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     44  0000 ????						; below wasted time increases rapidly, above only moderately
     45  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     46  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     47  0000 ????						;  so larger segtimes are not that bad then
     48  0000 ????
     49  0000 ????
     50  0000 ????				      MAC	segtime
     51  0000 ????			   {1}	      SET	{2}
     52  0000 ????			   TEST_{1}   =	0
     53  0000 ????				      ENDM
     54  0000 ????
     55  0000 ????				      MAC	xsegtime
     56  0000 ????			   {1}	      SET	{2}-1
     57  0000 ????			   TEST_{1}   =	1
     58  0000 ????				      ENDM
     59  0000 ????
     60  0000 ????						;@TJ -- SIMPLY PUT AN X IN FRONT OF THE LINE(S) YOU WANT TO TEST
     61  0000 ????						; eg: XSEGTIME SEGTIME_BOX1,5
     62  0000 ????						; No other action required.  All code enables/disables automatically.
     63  0000 ????
     64  0000 ????						; 2012/02/11 -- experimental reduction in times (but not stress tested)
     65  0000 ????						; due to separation of timeslice overhead to separate check
     66  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_SCD_DIRECT,8	; TODO: 392@12/2/2012
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	8
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_QUICK,9	; TODO: 414@12/2/2012
      1  0000 ????			   SEGTIME_SCD_QUICK SET	9
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_SLOW,12	; TODO: cycles: ~635 @12/2/2012.
      1  0000 ????			   SEGTIME_SCD_SLOW SET	12
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_PF0,5	; TODO: cycle counted ~126 @12/2/2012
      1  0000 ????			   SEGTIME_SCD_PF0 SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_MIN,SEGTIME_SCD_PF0	; * MINIMUM TIME OF THE ABOVE + 1
      1  0000 ????			   SEGTIME_SCD_MIN SET	SEGTIME_SCD_PF0
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_MIN =	0
     72  0000 ????
     73  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
     74  0000 ????			  -	      SEGTIME	SEGTIME_BDF,42	; * 5/8/11 stress tested DHS->DS
     75  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BDF,41	; * 7/8/11
      1  0000 ????			   SEGTIME_BDF SET	41
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
     77  0000 ????				      ENDIF
     78  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BDS,5	; *AD 11/8/11
      1  0000 ????			   SEGTIME_BDS SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME	SEGTIME_DSL,5	; * 9/8/11 unrolled once
      1  0000 ????			   SEGTIME_DSL SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
     81  0000 ????
     82  0000 ????
     83  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SORT_TIME,3	;     157(A)->2.45
      1  0000 ????			   MINIMUM_SORT_TIME SET	3
      2  0000 ????	       00 00	   TEST_MINIMUM_SORT_TIME =	0
     85  0000 ????
     86  0000 ????
     87  0000 ????						;following will lock-up system if used as 'XSEGTIME'.
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIME,4	; processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	4
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
     89  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIMEBLANK,16	;17		 ; * 7/8/11	 993(A)->15.5
      1  0000 ????			   MINIMUM_SEGTIMEBLANK SET	16
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIMEBLANK =	0
     91  0000 ????
     92  0000 ????						; MINIMUM_SEGTIME
     93  0000 ????						; MINIMUM_SEGTIMEBLANK
     94  0000 ????						; SEGTIME_BDF
     95  0000 ????						; SEGTIME_BDS
     96  0000 ????						; SEGTIME_DSL
     97  0000 ????						; SEGTIME_SWITCHOBJECTS
     98  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MINIMUM_TIMESLICE,MINIMUM_SEGTIME+1	; MINIMUM of the TIMESLICE segments listed above
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	MINIMUM_SEGTIME+1
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    100  0000 ????
    101  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    102  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    103  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    104  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    105  0000 ????						; uses ...
    106  0000 ????
    107  0000 ????
    108  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    109  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    110  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    111  0000 ????
    112  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    113  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    114  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,24	;<< using this as XSEGTIME stops player working ...?!
      1  0000 ????			   SEGTIME_MAN SET	24
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
    116  0000 ????						; TJ: I should only prevent processes with an extra check (e.g. get diamond)
    117  0000 ????
    118  0000 ????						; push BOX is slowest (besides get diamond which has an extra timer check)
    119  0000 ????						; if we add another check for it, SEGTIME_MAN reduces by ~5
    120  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BOX1,5	; ~182 cycles if falling on man + sort overhead!
      1  0000 ????			   SEGTIME_BOX1 SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_BOX1 =	0
      0  0000 ????				      SEGTIME	SEGTIME_BOX3,8	; SEGTIME_BOX4 causes freezes if stressed
      1  0000 ????			   SEGTIME_BOX3 SET	8
      2  0000 ????	       00 00	   TEST_SEGTIME_BOX3 =	0
      0  0000 ????				      SEGTIME	SEGTIME_BOX4,7	;(*) not 100% sure, maybe one more
      1  0000 ????			   SEGTIME_BOX4 SET	7
      2  0000 ????	       00 00	   TEST_SEGTIME_BOX4 =	0
      0  0000 ????				      SEGTIME	SEGTIME_MAGIC,SEGTIME_BOX4 + 2	; tied together (diamond falling through magic wall)
      1  0000 ????			   SEGTIME_MAGIC SET	SEGTIME_BOX4 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MAGIC =	0
    125  0000 ????
    126  0000 ????						; the following values have been tested with the STRESS_TIME macro:
    127  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
    128  0000 ????			  -	      SEGTIME	SEGTIME_BIGBANG,34	; TODO* 5/8/11, 1732(B)+218(butterfly)->1940->30.3
    129  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BIGBANG,31	; * 7/8/11
      1  0000 ????			   SEGTIME_BIGBANG SET	31
      2  0000 ????	       00 00	   TEST_SEGTIME_BIGBANG =	0
    131  0000 ????				      ENDIF
      0  0000 ????				      SEGTIME	SEGTIME_EXPLOSION,7	; * 5/8/11
      1  0000 ????			   SEGTIME_EXPLOSION SET	7
      2  0000 ????	       00 00	   TEST_SEGTIME_EXPLOSION =	0
      0  0000 ????				      SEGTIME	SEGTIME_GET_DIAMOND,17	; * 14/8/11, required if UpdateScore loops (e.g. 9990->10000)
      1  0000 ????			   SEGTIME_GET_DIAMOND SET	17
      2  0000 ????	       00 00	   TEST_SEGTIME_GET_DIAMOND =	0
      0  0000 ????				      SEGTIME	SEGTIME_BUTTERFLY,10	; * 7/8/11, 525(B)->8.20
      1  0000 ????			   SEGTIME_BUTTERFLY SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_BUTTERFLY =	0
    135  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_SWITCHOBJECTS,3	; 16/8/11 by calculation. 72 cycles -->  ceil(72/64)+1 --> 3 Object stack switchover
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	3
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
------- FILE ./sokoboo.asm
     24  0000 ????
     25  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     26  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     27  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     28  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     29  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     30  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     31  0000 ????
     32  0000 ????	       00 01	   YES	      =	1
     33  0000 ????	       00 00	   NO	      =	0
     34  0000 ????
     35  0000 ????	       00 00	   DEBUG      =	NO
     36  0000 ????
     37  0000 ????	       00 00	   TJ_MODE    =	NO	; some changes which TJ prefers
     38  0000 ????	       00 01	   AD_MODE    =	YES	; some changes which AD prefers
     39  0000 ????
     40  0000 ????			  -	      IF	TJ_MODE && AD_MODE
     41  0000 ????			  -	      ECHO	"ERROR: Both TJ_MODE and AD_MODE set. Can't do both TJ and AD at the same time!"
     42  0000 ????			  -	      ERR
     43  0000 ????				      ENDIF
     44  0000 ????
     45  0000 ????
     46  0000 ????						; Note: you may also need to change the emulator "-format" switch in the Makefile.
     47  0000 ????
     48  0000 ????			   NTSC_MODE  SET	YES
     49  0000 ????
     50  0000 ????			  -	      IF	TJ_MODE
     51  0000 ????			  -NTSC_MODE  SET	NO	; force NTSC or PAL for difficulty switch
     52  0000 ????				      ENDIF
     53  0000 ????				      IF	AD_MODE
     54  0000 ????			   NTSC_MODE  SET	NO
     55  0000 ????				      ENDIF
     56  0000 ????
     57  0000 ????
     58  0000 ????
     59  0000 ????						;===================================
     60  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     61  0000 ????						;===================================
     62  0000 ????
     63  0000 ????
     64  0000 ????						;===================================
     65  0000 ????			   DEMO_VERSION SET	NO	; force a dual-level playable demo only
     66  0000 ????						;===================================
     67  0000 ????
     68  0000 ????
     69  0000 ????						;-------------------------------------------------------------------------------
     70  0000 ????						; The following should be NO for the final or DEMO version
     71  0000 ????			   TEST_BONUS_COUNTDOWN SET	NO	; causes level A1 to have a special setup for testing the bonus countdown
     72  0000 ????			   F1F2NEXTCAVE SET	NO	; debugging -- F1+F2 will trigger next level. Good to test the progression of level/caves
     73  0000 ????			   CONSTRUCTIONKIT SET	NO	; patch-capable binary for construction kit usage
     74  0000 ????			   SHOWDIAMONDP SET	NO	; debug show diamond on P
     75  0000 ????
     76  0000 ????						;-------------------------------------------------------------------------------
     77  0000 ????						; The following should be YES for the final or DEMO version
     78  0000 ????			   EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
     79  0000 ????			   SORT_OBJECTS SET	YES	; Warning: can be slow on complex screens
     80  0000 ????			   SPECIAL_ADD_DECODECAVE SET	YES	; causes BOXs and diamonds to be added as falling objects on cave startup
     81  0000 ????
     82  0000 ????						;-------------------------------------------------------------------------------
     83  0000 ????						; The following are optional YES/NO depending on phase of the moon
     84  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     85  0000 ????			   INITIAL_SCROLL SET	NO	; initially scroll board from Rockford's last position
     86  0000 ????						;-------------------------------------------------------------------------------
     87  0000 ????
     88  0000 ????	       00 01	   NUMPLAYERS =	1	; 1-indexed
     89  0000 ????	       00 05	   NUM_LEVELS =	5
     90  0000 ????			   NUM_LIVES  SET	3	; use -1 for unlimited lives
     91  0000 ????
     92  0000 ????			   DEMO_DELAY SET	1	; number of music loops without joystick input before demo kicks in
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     96  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     97  0000 ????			  -	      IF	FINAL_VERSION = YES
     98  0000 ????			  -DEMO_VERSION SET	NO	; force a dual-level playable demo only
     99  0000 ????			  -TEST_BONUS_COUNTDOWN SET	NO	; causes level A1 to have a special setup for testing the bonus countdown
    100  0000 ????			  -F1F2NEXTCAVE SET	NO	; debugging -- F1+F2 will trigger next level. Good to test the progression of level/caves
    101  0000 ????			  -CONSTRUCTIONKIT SET	NO	; patch-capable binary for construction kit usage
    102  0000 ????			  -EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
    103  0000 ????			  -SORT_OBJECTS SET	YES	; Warning: can be slow on complex screens
    104  0000 ????			  -SPECIAL_ADD_DECODECAVE SET	YES	; causes BOXs and diamonds to be added as falling objects on cave startup
    105  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
    106  0000 ????			  -SHOWDIAMONDP SET	NO	; debug show diamond on P
    107  0000 ????			  -
    108  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
    109  0000 ????			  -DEMO_DELAY SET	2	; number of music loops without joystick input before demo kicks in
    110  0000 ????			  -NTSC_MODE  SET	YES	; mmh
    111  0000 ????				      ENDIF
    112  0000 ????
    113  0000 ????			  -	      IF	DEMO_VERSION = YES
    114  0000 ????			  -TEST_BONUS_COUNTDOWN SET	NO	; causes level A1 to have a special setup for testing the bonus countdown
    115  0000 ????			  -F1F2NEXTCAVE SET	NO	; debugging -- F1+F2 will trigger next level. Good to test the progression of level/caves
    116  0000 ????			  -CONSTRUCTIONKIT SET	NO	; patch-capable binary for construction kit usage
    117  0000 ????			  -EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
    118  0000 ????			  -SORT_OBJECTS SET	YES	; Warning: can be slow on complex screens
    119  0000 ????			  -SPECIAL_ADD_DECODECAVE SET	YES	; causes BOXs and diamonds to be added as falling objects on cave startup
    120  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
    121  0000 ????			  -SHOWDIAMONDP SET	NO	; debug show diamond on P
    122  0000 ????			  -
    123  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
    124  0000 ????			  -DEMO_DELAY SET	2	; number of music loops without joystick input before demo kicks in
    125  0000 ????			  -NTSC_MODE  SET	YES	; mmh
    126  0000 ????				      ENDIF
    127  0000 ????
    128  0000 ????						;-------------------------------------------------------------------------------
    129  0000 ????
    130  0000 ????						;SHOW_TITLE			  SET YES	  ; NOW *REQUIRED* FOR CAVE/LEVEL SELECTION!!!
    131  0000 ????
    132  0000 ????
    133  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
    134  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
    135  0000 ????
    136  0000 ????
    137  0000 ????	       00 02	   PUSH_LIMIT =	2	; slowdown when pushing on a BOX
    138  0000 ????	       00 01	   GENERIC_MASK_ROUNDED =	1	; lets rocks/diamonds roll off
    139  0000 ????	       00 02	   GENERIC_MASK_SQUASHABLE =	2	; gets pummelled by anything falling on it
    140  0000 ????	       00 08	   GENERIC_MASK_EXPLODABLE =	8	; takes part in an explosion
    141  0000 ????	       00 10	   GENERIC_MASK_KILLSBUTTERFLY =	16	; causes nearby butterfly/firefly to explode
    142  0000 ????	       00 20	   GENERIC_MASK_MAGICWALL =	32	; a magic wall character
    143  0000 ????	       00 80	   GENERIC_MASK_FALLABLE =	128	; objects can fall into blanks (BMI usage assumed!!)
    144  0000 ????
    145  0000 ????						; POS_VAR flags:
    146  0000 ????	       00 80	   VAR_FALLING =	%10000000	; hardwired! negative assumed
    147  0000 ????	       00 40	   VAR_JUST_GENERATED =	%01000000	; object cannot fall and squash things yet
    148  0000 ????	       00 20	   VAR_ON_DIAMOND =	%00100000	; object is 'standing' on diamond
    149  0000 ????
    150  0000 ????						; amoeba and magic wall constants:
    151  0000 ????	       00 ff	   MAGIC_WALL_DORMANT =	$FF	; wall dormant, waiting for trigger
    152  0000 ????	       00 ff	   AMOEBA_FAST_GROW =	MAGIC_WALL_DORMANT
    153  0000 ????	       00 c8	   TOO_MUCH_AMOEBA =	200	; squares of amoeba before turns into BOXs (original 200)
    154  0000 ????						; we should try to adjust the growth first by changing MIN_AMOEBA_SCAN,
    155  0000 ????						; maybe we can assume FAST_GROW to be 256 and then can remove the code for it.
    156  0000 ????	       00 1d	   SLOW_GROW  =	30+1-2	; should be ~3%
    157  0000 ????	       00 e9	   FAST_GROW  =	240+1-8	; should be ~25% (8x SLOW_GROW)
    158  0000 ????	       00 1e	   MIN_AMOEBA_SCAN =	30	; minimum required checks/scan (this slows down small Amoebas)
    159  0000 ????
    160  0000 ????						; time bonus countdown constants:
    161  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
    162  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
    163  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
    164  0000 ????
    165  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    166  0000 ????
    167  0000 ????	       00 02	   FACE_DOWN  =	2
    168  0000 ????	       00 03	   FACE_LEFT  =	3
    169  0000 ????
    170  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
    171  0000 ????	       00 06	   FLASH_TIME =	6	; flash time for BG colour when door opens
    172  0000 ????	       00 0a	   RED_TIME_WARNING =	10	; time remaining before time remaining flashes
    173  0000 ????
    174  0000 ????						;scoring flags contants:
    175  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
    176  0000 ????	       00 00	   DISPLAY_TIME =	%00
    177  0000 ????	       00 01	   DISPLAY_SCORE =	%01
    178  0000 ????	       00 02	   DISPLAY_LIVES =	%10
    179  0000 ????	       00 03	   DISPLAY_HIGH =	%11
    180  0000 ????	       00 40	   EXTRA_100_DIAMONDS =	$40	; set if more than 100 extra diamonds collected
    181  0000 ????	       00 80	   EXTRA_DIAMONDS =	$80	; set if collecting extra diamonds
    182  0000 ????
    183  0000 ????						;------------------------------------------------------------------------------
    184  0000 ????
    185  0000 ????	       00 01	   MIRRORED_BOX =	YES
    186  0000 ????	       00 01	   MIRRORED_AMOEBA =	YES
    187  0000 ????	       00 01	   MIRRORED_STEEL =	YES
    188  0000 ????	       00 01	   MIRRORED_WALL =	YES
    189  0000 ????
    190  0000 ????						;------------------------------------------------------------------------------
    191  0000 ????
    192  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    193  0000 ????
    194  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    195  0000 ????	       00 15	   LINES_PER_CHAR =	21	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    196  0000 ????
    197  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    198  0000 ????
    199  0000 ????
    200  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    201  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    202  0000 ????
    203  0000 ????
    204  0000 ????						; color constants:
    205  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    206  0000 ????
    207  0000 ????	       00 10	   YELLOW_NTSC =	$10
    208  0000 ????	       00 20	   YELLOW_PAL =	$20
    209  0000 ????
    210  0000 ????
    211  0000 ????	       10 00	   RAM_3E     =	$1000
    212  0000 ????	       04 00	   RAM_SIZE   =	$400
    213  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    214  0000 ????
    215  0000 ????
    216  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    217  0000 ????
    218  0000 ????
    219  0000 ????						; Platform constants:
    220  0000 ????	       00 02	   PAL	      =	%10
    221  0000 ????	       00 02	   PAL_50     =	PAL|0
    222  0000 ????	       00 03	   PAL_60     =	PAL|1
    223  0000 ????
    224  0000 ????
    225  0000 ????				      IF	L276
    226  0000 ????	       00 3e	   VBLANK_TIM_NTSC =	62	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    227  0000 ????			  -	      ELSE
    228  0000 ????			  -VBLANK_TIM_NTSC =	45	; NTSC 262
    229  0000 ????				      ENDIF
    230  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    231  0000 ????
    232  0000 ????				      IF	L276
    233  0000 ????	       00 33	   OVERSCAN_TIM_NTSC =	51	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    234  0000 ????			  -	      ELSE
    235  0000 ????			  -OVERSCAN_TIM_NTSC =	51	; NTSC 262
    236  0000 ????				      ENDIF
    237  0000 ????	       00 46	   OVERSCAN_TIM_PAL =	70	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    238  0000 ????
    239  0000 ????				      IF	L276
    240  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    241  0000 ????			  -	      ELSE
    242  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    243  0000 ????				      ENDIF
    244  0000 ????	       01 38	   SCANLINES_PAL =	312
    245  0000 ????
    246  0000 ????
    247  0000 ????						;------------------------------------------------------------------------------
    248  0000 ????						; MACRO definitions
    249  0000 ????
    250  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    251  0000 ????
    252  0000 ????				      MAC	newbank
    253  0000 ????				      SEG	{1}
    254  0000 ????				      ORG	ORIGIN
    255  0000 ????				      RORG	$F000
    256  0000 ????			   BANK_START SET	*
    257  0000 ????			   {1}	      SET	ORIGIN / 2048
    258  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    259  0000 ????			   _CURRENT_BANK SET	{1}
    260  0000 ????				      ENDM		; bank name
    261  0000 ????
    262  0000 ????				      MAC	define_1k_segment
    263  0000 ????				      ALIGN	$400
    264  0000 ????			   SEGMENT_{1} SET	*
    265  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    266  0000 ????				      ENDM		; {seg name}
    267  0000 ????
    268  0000 ????				      MAC	check_bank_size
    269  0000 ????			   .TEMP      =	* - BANK_START
    270  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    271  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    272  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    273  0000 ????				      ERR
    274  0000 ????				      endif
    275  0000 ????				      ENDM		; name
    276  0000 ????
    277  0000 ????
    278  0000 ????				      MAC	check_half_bank_size
    279  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    280  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    281  0000 ????			   .TEMP      =	* - BANK_START
    282  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    283  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    284  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    285  0000 ????				      ERR
    286  0000 ????				      endif
    287  0000 ????				      ENDM		; name
    288  0000 ????
    289  0000 ????
    290  0000 ????				      MAC	overlay
    291  0000 ????				      SEG.U	OVERLAY_{1}
    292  0000 ????				      org	Overlay
    293  0000 ????				      ENDM		; {name}
    294  0000 ????
    295  0000 ????						;--------------------------------------------------------------------------
    296  0000 ????
    297  0000 ????				      MAC	validate_overlay
    298  0000 ????				      LIST	OFF
    299  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    300  0000 ????				      ERR
    301  0000 ????				      endif
    302  0000 ????				      LIST	ON
    303  0000 ????				      ENDM
    304  0000 ????
    305  0000 ????						;--------------------------------------------------------------------------
    306  0000 ????						; Macro inserts a page break if the object would overlap a page
    307  0000 ????
    308  0000 ????				      MAC	optional_pagebreak
    309  0000 ????				      LIST	OFF
    310  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    311  0000 ????			   EARLY_LOCATION SET	*
    312  0000 ????				      ALIGN	256
    313  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    314  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    315  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    316  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    317  0000 ????				      ENDIF
    318  0000 ????				      LIST	ON
    319  0000 ????				      ENDM		; { string, size }
    320  0000 ????
    321  0000 ????
    322  0000 ????				      MAC	check_page_crossing
    323  0000 ????				      LIST	OFF
    324  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    325  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    326  0000 ????				      endif
    327  0000 ????				      LIST	ON
    328  0000 ????				      ENDM
    329  0000 ????
    330  0000 ????				      MAC	checkpage
    331  0000 ????				      LIST	OFF
    332  0000 ????				      IF	>. != >{1}
    333  0000 ????				      ECHO	""
    334  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    335  0000 ????				      ECHO	""
    336  0000 ????				      ERR
    337  0000 ????				      ENDIF
    338  0000 ????				      LIST	ON
    339  0000 ????				      ENDM
    340  0000 ????
    341  0000 ????				      MAC	checkpagex
    342  0000 ????				      LIST	OFF
    343  0000 ????				      IF	>. != >{1}
    344  0000 ????				      ECHO	""
    345  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    346  0000 ????				      ECHO	{2}
    347  0000 ????				      ECHO	""
    348  0000 ????				      ERR
    349  0000 ????				      ENDIF
    350  0000 ????				      LIST	ON
    351  0000 ????				      ENDM
    352  0000 ????
    353  0000 ????
    354  0000 ????				      MAC	checkpage_bne
    355  0000 ????				      LIST	OFF
    356  0000 ????				      IF	0	;>(. + 2) != >{1}
    357  0000 ????				      ECHO	""
    358  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    359  0000 ????				      ECHO	""
    360  0000 ????				      ERR
    361  0000 ????				      ENDIF
    362  0000 ????				      LIST	ON
    363  0000 ????				      bne	{1}
    364  0000 ????				      ENDM
    365  0000 ????
    366  0000 ????				      MAC	checkpage_bpl
    367  0000 ????				      LIST	OFF
    368  0000 ????				      IF	(>(.+2 )) != >{1}
    369  0000 ????				      ECHO	""
    370  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    371  0000 ????				      ECHO	""
    372  0000 ????				      ERR
    373  0000 ????				      ENDIF
    374  0000 ????				      LIST	ON
    375  0000 ????				      bpl	{1}
    376  0000 ????				      ENDM
    377  0000 ????
    378  0000 ????				      MAC	align_free
    379  0000 ????			   FREE       SET	FREE - .
    380  0000 ????				      align	{1}
    381  0000 ????			   FREE       SET	FREE + .
    382  0000 ????				      echo	"@", ., ":", FREE
    383  0000 ????				      ENDM
    384  0000 ????
    385  0000 ????				      MAC	stress_time
    386  0000 ????				      IF	TEST_{1} = 1
    387  0000 ????
    388  0000 ????
    389  0000 ????						;LIST OFF
    390  0000 ????						; has to be put *directly* after cmp #SEGTIME_... , bcc abort
    391  0000 ????						;LIST ON
    392  0000 ????				      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
    393  0000 ????				      bne	. - 7	; branches to lda INTIM
    394  0000 ????				      ENDIF
    395  0000 ????				      ENDM
    396  0000 ????
    397  0000 ????			   IDENTITY   SET	0
    398  0000 ????				      MAC	ident
    399  0000 ????				      if	DEBUG=YES
    400  0000 ????				      lda	#IDENTITY
    401  0000 ????				      sta	debug_ident
    402  0000 ????				      lda	{1}
    403  0000 ????				      sta	debug_object
    404  0000 ????				      endif
    405  0000 ????			   IDENTITY   SET	IDENTITY + 1
    406  0000 ????				      ENDM		; {object}
    407  0000 ????
    408  0000 ????						;--------------------------------------------------------------------------
    409  0000 ????
    410  0000 ????				      MAC	vector
    411  0000 ????				      .word	{1}
    412  0000 ????				      ENDM		; just a word pointer to code
    413  0000 ????
    414  0000 ????
    415  0000 ????				      MAC	define_subroutine
    416  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    417  0000 ????				      SUBROUTINE		; keep everything local
    418  0000 ????			   {1}			; entry point
    419  0000 ????				      ENDM		; name of subroutine
    420  0000 ????
    421  0000 ????
    422  0000 ????
    423  0000 ????						;--------------------------------------------------------------------------
    424  0000 ????
    425  0000 ????				      MAC	newrambank
    426  0000 ????				      SEG.U	{1}
    427  0000 ????				      ORG	ORIGIN
    428  0000 ????				      RORG	RAM_3E
    429  0000 ????			   BANK_START SET	*
    430  0000 ????			   {1}	      SET	ORIGIN / RAM_SIZE
    431  0000 ????			   ORIGIN     SET	ORIGIN + RAM_SIZE
    432  0000 ????				      ENDM		; bank name
    433  0000 ????
    434  0000 ????				      MAC	validate_ram_size
    435  0000 ????				      if	* - RAM_3E > RAM_SIZE
    436  0000 ????				      ERR
    437  0000 ????				      endif
    438  0000 ????				      ENDM
    439  0000 ????
    440  0000 ????				      MAC	next_random
    441  0000 ????						; update random value:
    442  0000 ????				      lda	rnd	; 3
    443  0000 ????				      lsr		; 2
    444  0000 ????				      IFCONST	rndHi
    445  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    446  0000 ????				      ENDIF
    447  0000 ????				      bcc	.skipEOR	; 2/3
    448  0000 ????				      eor	#RND_EOR_VAL	; 2
    449  0000 ????			   .skipEOR
    450  0000 ????				      sta	rnd	; 3 = 14/19
    451  0000 ????				      ENDM
    452  0000 ????
    453  0000 ????				      MAC	resync
    454  0000 ????						; resync screen, X and Y == 0 afterwards
    455  0000 ????				      lda	#%10	; make sure VBLANK is ON
    456  0000 ????				      sta	VBLANK
    457  0000 ????
    458  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    459  0000 ????			   .loopResync
    460  0000 ????				      VERTICAL_SYNC
    461  0000 ????
    462  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    463  0000 ????				      lda	Platform
    464  0000 ????				      eor	#PAL_50	; PAL-50?
    465  0000 ????				      bne	.ntsc
    466  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    467  0000 ????			   .ntsc
    468  0000 ????			   .loopWait
    469  0000 ????				      sta	WSYNC
    470  0000 ????				      sta	WSYNC
    471  0000 ????				      dey
    472  0000 ????				      bne	.loopWait
    473  0000 ????				      dex
    474  0000 ????				      bne	.loopResync
    475  0000 ????				      ENDM
    476  0000 ????
    477  0000 ????				      MAC	set_platform
    478  0000 ????						; 00 = NTSC
    479  0000 ????						; 01 = NTSC
    480  0000 ????						; 10 = PAL-50
    481  0000 ????						; 11 = PAL-60
    482  0000 ????				      lda	SWCHB
    483  0000 ????				      rol
    484  0000 ????				      rol
    485  0000 ????				      rol
    486  0000 ????				      and	#%11
    487  0000 ????				      if	NTSC_MODE = NO
    488  0000 ????				      eor	#PAL
    489  0000 ????				      endif
    490  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    491  0000 ????				      ENDM
    492  0000 ????
    493  0000 ????						;  IF TJ_MODE
    494  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM ; = 29
    495  0000 ????						;	  ldy #{1}			  ; 2	  read bank
    496  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    497  0000 ????						;	  jsr GetRAMByteFromRAM 	  ;25
    498  0000 ????						;    ENDM
    499  0000 ????						;
    500  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM ; = 30
    501  0000 ????						;	  ldy #{1}			  ; 2	  write bank
    502  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    503  0000 ????						;	  jsr PutRAMByteFromRAM 	  ;26
    504  0000 ????						;    ENDM
    505  0000 ????						;
    506  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM_ADR ; = 39
    507  0000 ????						;	  ldx #<{1}			  ; 2
    508  0000 ????						;	  stx addressR			  ; 3
    509  0000 ????						;	  ldx #>{1}			  ; 2
    510  0000 ????						;	  stx addressR+1		  ; 3
    511  0000 ????						;	  GET_RAM_BYTE_FROM_RAM {2}, {3}  ;29
    512  0000 ????						;    ENDM
    513  0000 ????						;
    514  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM_ADR ; = 40
    515  0000 ????						;	  ldx #<{1}			  ; 2
    516  0000 ????						;	  stx addressW			  ; 3
    517  0000 ????						;	  ldx #>({1}+RAM_WRITE) 	  ; 2
    518  0000 ????						;	  stx addressW+1		  ; 3
    519  0000 ????						;	  PUT_RAM_BYTE_FROM_RAM {2}, {3}  ;30
    520  0000 ????						;    ENDM
    521  0000 ????						;  ENDIF
    522  0000 ????
    523  0000 ????				      MAC	nop_b
    524  0000 ????				      .byte	$82
    525  0000 ????				      ENDM		; unused
    526  0000 ????
    527  0000 ????				      MAC	nop_w
    528  0000 ????				      .byte	$0c
    529  0000 ????				      ENDM
    530  0000 ????
    531  0000 ????						;------------------------------------------------------------------------------
    532  0000 ????
    533  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????
      2 U00fb ????				      SEG.U	variables
      3 U0080					      ORG	$80
      4 U0080
      5 U0080		       00 40	   GAMEMODE_2600 =	64
      6 U0080		       00 80	   GAMEMODE_PAUSED =	128
      7 U0080
      8 U0080		       00	   gameMode   ds	1	; bit7=0: 7800; bit7=1: 2600.	bit 6=1: paused: bit3: toggle bit for B/W
      9 U0081		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     10 U0082							; above variables are preserved ALL the time!
     11 U0082
     12 U0082		       00 00 00 00*Surround   ds	5
     13 U0087		       00	   rnd	      ds	1
     14 U0088		       00	   rndHi      ds	1	; to get better random values
     15 U0089
     16 U0089		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     17 U008a		       00	   ObjStackNum ds	1	; which stack in use
     18 U008b		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     19 U008d		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     20 U008e		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     21 U008f
     22 U008f		       00	   POS_X      ds	1
     23 U0090		       00	   POS_Y      ds	1
     24 U0091		       00	   POS_X_NEW  ds	1
     25 U0092		       00	   POS_Y_NEW  ds	1
     26 U0093		       00	   POS_Type   ds	1
     27 U0094		       00	   POS_VAR    ds	1
     28 U0095
     29 U0095		       00 00	   BufferedJoystick ds	2	; player joystick input
     30 U0097		       00	   BufferedButton ds	1	; player button press
     31 U0098
     32 U0098							; Scrolling is limited to only show board within the following area...
     33 U0098		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in DecodeCave)
     34 U0099		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in DecodeCave)
     35 U009a		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     36 U009b		       00	   BoardScrollX ds	1	; scroll position in board (X)
     37 U009b		       00 98	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     38 U009b		       00 99	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     39 U009c		       00	   scrollBits ds	1
     40 U009d
     41 U009d		       00	   MagicAmoebaFlag ds	1	; status of magic wall and amoeba
     42 U009e
     43 U009e		       00	   whichPlayer ds	1	; 0 = P1, 1 = P2
     44 U009f
     45 U009f		       00	   ManX       ds	1
     46 U00a0		       00	   ManY       ds	1
     47 U00a1		       00	   ManDrawX   ds	1
     48 U00a2		       00	   ManDrawY   ds	1
     49 U00a3		       00	   ManMode    ds	1
     50 U00a4		       00	   ManDelayCount ds	1
     51 U00a5		       00 00	   ManAnimation ds	2
     52 U00a7		       00	   ManAnimationFrameLO ds	1
     53 U00a8		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     54 U00a9		       00	   ManPushCounter ds	1
     55 U00aa		       00	   LookingAround ds	1
     56 U00ab		       00	   MenCurrent ds	1	; player life counter
     57 U00ac		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     58 U00ad
     59 U00ad							;---------------------------------------------------------------------------
     60 U00ad							; 2 (shared) demo mode variables:
     61 U00ad		       00 ac	   demoMode   =	jtoggle	; bit 7==1 => demo mode
     62 U00ad		       00 ac	   moveLen    =	jtoggle	; bits 0..6
     63 U00ad		       00 9e	   moveIdx    =	whichPlayer
     64 U00ad
     65 U00ad		       00	   LastSpriteY ds	1
     66 U00ae
     67 U00ae		       00	   timer      ds	1
     68 U00af
     69 U00af		       00	   BGColour   ds	1
     70 U00b0
     71 U00b0							; cave and level have to be consecutive variables!
     72 U00b0		       00	   cave       ds	1	; current player's cave (other in scoring bank)
     73 U00b1		       00	   level      ds	1	; current player's level (other in scoring bank)
     74 U00b2		       00	   caveDisplay ds	1	; what to display as the cave ID
     75 U00b3		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
     76 U00b4		       00	   ThrottleSpeed ds	1	; system-dependant throttle speed
     77 U00b5
     78 U00b5		       00	   magicAmoebaTime ds	1	; time for magic wall and amoeba slow growth
     79 U00b6		       00	   diamondsNeeded ds	1	; TJ: changed that (NOTE: counts down to 0 then (negatively) UP to give extra diamonds found.)
     80 U00b7		       00	   diamondsWorth ds	1	; TJ: could be moved to Scoring Bank
     81 U00b8		       00	   diamondsExtraWorth ds	1	; TJ: could be moved to Scoring Bank
     82 U00b9		       00	   caveTime   ds	1	; BCD seconds for level
     83 U00ba		       00	   caveTimeHi ds	1
     84 U00bb		       00	   caveTimeFrac ds	1
     85 U00bc		       00 00 00    color      ds	3	; RGB for NTSC, RGB for PAL
     86 U00bf		       00 00	   Board_AddressR ds	2
     87 U00c1		       00 00	   Board_AddressW ds	2
     88 U00c3		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
     89 U00c4		       00	   RAM_Bank   ds	1
     90 U00c5
     91 U00c5							;  IF TJ_MODE
     92 U00c5							;addressR			  = Board_AddressR
     93 U00c5							;addressW			  = Board_AddressW
     94 U00c5							;  ENDIF
     95 U00c5
     96 U00c5		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
     97 U00c6		       00	   extraLifeTimer ds	1	; should be 5 seconds!
     98 U00c7
     99 U00c7							; extraLifeTimer:
    100 U00c7							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    101 U00c7
    102 U00c7		       00	   scoringTimer ds	1	; times the various score displays
    103 U00c8		       00	   scoringFlags ds	1	; scoring flags are stored here
    104 U00c9
    105 U00c9							; scoringFlags:
    106 U00c9							; D7		 Extra diamonds in effect (diamonds collected over requirement score more) ASSUMED BPL/BMI usage
    107 U00c9							; D6		 unused
    108 U00c9							; D5		 unused
    109 U00c9							; D4		 unused
    110 U00c9							; D3		 unused
    111 U00c9							; D2		 unused
    112 U00c9							; D1	 D1-D0	 Which display kernel to use for scoring
    113 U00c9							; D0		 0 = 2x4     used for diamonds/time
    114 U00c9							;		 1 = 1x6     used for score
    115 U00c9							;		 2 = 3x2     used for level/lives/player
    116 U00c9
    117 U00c9		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    118 U00c9		       00 80	   BIT_NEXTLEVEL =	128
    119 U00c9		       00 40	   BIT_NEXTLIFE =	64
    120 U00c9		       00 01	   BIT_GOTOLOGO =	1
    121 U00ca
    122 U00ca		       00	   amoebaX    ds	1	; x-pos of currently scanned cell
    123 U00cb		       00	   amoebaY    ds	1	; y-pos of currently scanned cell
    124 U00cc		       00	   amoebaFlag ds	1	; current status of amoeba
    125 U00cd
    126 U00cd							; constants for amoebaFlag:
    127 U00cd		       00 01	   NOT_ENCLOSED =	%00000001	;
    128 U00cd		       00 02	   SCAN_FINISHED =	%00000010	; indicates that one scan finished and the next one has to wait
    129 U00cd		       00 20	   FINISHEDDIAMOND =	%00100000	;
    130 U00cd		       00 40	   AMOEBA_PRESENT =	%01000000	; set during the very first amoeba object init
    131 U00cd		       00 80	   TODIAMOND  =	%10000000	;
    132 U00cd
    133 U00cd		       00	   amoebaCount ds	1	; number of cells counted in current scan
    134 U00ce							; bounding box for amoeba scan:
    135 U00ce		       00	   amoebaMinX ds	1
    136 U00cf		       00	   amoebaMinY ds	1
    137 U00d0		       00	   amoebaMaxX ds	1
    138 U00d1		       00	   amoebaMaxY ds	1
    139 U00d2		       00	   amoebaStepCount ds	1	; scan speed limiter
    140 U00d3
    141 U00d3							;---------------------------------------------------------------------------
    142 U00d3
    143 U00d3		       00	   sortRequired ds	1
    144 U00d4		       00	   sortPtr    ds	1
    145 U00d5
    146 U00d5							;---------------------------------------------------------------------------
    147 U00d5							; sound driver needs 6 bytes:
    148 U00d5		       00 00	   soundIdxLst ds	2	; index of current sound
    149 U00d7		       00 00	   decayIdxLst ds	2	; index of current note
    150 U00d9		       00 00	   decayTimeLst ds	2	; remaining lenght of current note
    151 U00d9		       00 d7	   soundBonusPts =	decayIdxLst	; shared, used for bonus points count down (channel 0!)
    152 U00db		       00	   newSounds  ds	1
    153 U00dc
    154 U00dc							;------------------------------------------------------------------------------
    155 U00dc
    156 U00dc		       00	   specialTimeFlag ds	1	; detects time problem with man
    157 U00dd		       00	   ObjIterator ds	1	; count UP iterator over objects
    158 U00de		       00	   DSL	      ds	1	; stack line counter
    159 U00df
    160 U00df				   OVERLAY_SIZE SET	16
    161 U00df
    162 U00df
    163 U00df
    164 U00df							; This overlay variable is used for the overlay variables.  That's OK.
    165 U00df							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    166 U00df							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    167 U00df							; (especially the latter ones) are only used in rare occasions.
    168 U00df
    169 U00df							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    170 U00df							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    171 U00df
    172 U00df		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00ef					      VALIDATE_OVERLAY
      5 U00ef					      LIST	ON
    174 U00ef
    175 U00ef
    176 U00ef		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    177 U00fb
 FREE BYTES IN ZERO PAGE =  $4
    178 U00fb					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    179 U00fb				  -	      IF	* > $FF
    180 U00fb				  -	      ERR
    181 U00fb					      ENDIF
------- FILE ./sokoboo.asm
    535 U00fb
    536 U00fb
    537 U00fb							;------------------------------------------------------------------------------
    538 U00fb							; OVERLAYS!
    539 U00fb							; These variables are overlays, and should be managed with care
    540 U00fb							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    541 U00fb
    542 U00fb							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    543 U00fb							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    544 U00fb
    545 U00fb							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    546 U00fb
    547 U00fb							;------------------------------------------------------------------------------
      0 U00fb					      OVERLAY	BuildDrawFlags
      1 U00ea ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00df					      org	Overlay
    549 U00df
    550 U00df		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    551 U00e1		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    552 U00e3		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    553 U00e5		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    554 U00e7							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    555 U00e7		       00	   BDF_BoardBank ds	1	; holds bank of current line
    556 U00e8							;  ENDIF
    557 U00e8		       00	   DHS_Line   ds	1
    558 U00e9		       00	   DHS_Stack  ds	1	; for restoring SP
    559 U00ea							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00ea					      VALIDATE_OVERLAY
      5 U00ea					      LIST	ON
    561 U00ea
    562 U00ea							;------------------------------------------------------------------------------
    563 U00ea
      0 U00ea					      OVERLAY	Process
      1 U00e1 ????				      SEG.U	OVERLAY_Process
      2 U00df					      org	Overlay
    565 U00df
    566 U00df		       00	   BOXLeft    ds	1
    567 U00e0		       00	   BOXRight   ds	1
    568 U00e1
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    570 U00e1
    571 U00e1							;------------------------------------------------------------------------------
    572 U00e1
      0 U00e1					      OVERLAY	Animate
      1 U00e0 ????				      SEG.U	OVERLAY_Animate
      2 U00df					      org	Overlay
    574 U00df		       00	   halftimer  ds	1
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    576 U00e0
    577 U00e0							;------------------------------------------------------------------------------
    578 U00e0
      0 U00e0					      OVERLAY	TimeSlice
      1 U00e1 ????				      SEG.U	OVERLAY_TimeSlice
      2 U00df					      org	Overlay
    580 U00df
    581 U00df		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    582 U00e1							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    584 U00e1
    585 U00e1							;------------------------------------------------------------------------------
    586 U00e1
      0 U00e1					      OVERLAY	CopyROMShadowToRAM
      1 U00e2 ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00df					      org	Overlay
    588 U00df
    589 U00df		       00	   O_CopyCount ds	1
    590 U00e0		       00	   O_ROM_Source_Bank ds	1
    591 U00e1		       00	   O_Index    ds	1
    592 U00e2							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e2					      VALIDATE_OVERLAY
      5 U00e2					      LIST	ON
    594 U00e2
    595 U00e2							;------------------------------------------------------------------------------
    596 U00e2
      0 U00e2					      OVERLAY	Scoring
      1 U00e1 ????				      SEG.U	OVERLAY_Scoring
      2 U00df					      org	Overlay
    598 U00df		       00	   tmpStack   ds	1
    599 U00df		       00 df	   newDisplay =	tmpStack
    600 U00e0							; also for UpdateTimer
    601 U00e0		       00 df	   tmpSound   =	tmpStack
    602 U00e0		       00	   timerLoops ds	1
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    604 U00e1
    605 U00e1
    606 U00e1							;------------------------------------------------------------------------------
    607 U00e1
      0 U00e1					      OVERLAY	SaveKey
      1 U00e8 ????				      SEG.U	OVERLAY_SaveKey
      2 U00df					      org	Overlay
    609 U00df
    610 U00df		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    611 U00e2		       00 00 00    highScoreSK ds	3
    612 U00e5		       00	   startCave  ds	1	; cave * 5
    613 U00e6		       00	   startLevel ds	1
    614 U00e7		       00	   offsetSK   ds	1	; for calculating the SK slot address
    615 U00e8
      0 U00e8					      VALIDATE_OVERLAY
      5 U00e8					      LIST	ON
    617 U00e8
    618 U00e8							;------------------------------------------------------------------------------
    619 U00e8
      0 U00e8					      OVERLAY	DrawMan
      1 U00e1 ????				      SEG.U	OVERLAY_DrawMan
      2 U00df					      org	Overlay
    621 U00df
    622 U00df		       00 00	   MAN_Move   ds	2
    623 U00e1
    624 U00e1							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    626 U00e1
    627 U00e1							;------------------------------------------------------------------------------
    628 U00e1
      0 U00e1					      OVERLAY	ProcessObjStack
      1 U00e1 ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00df					      org	Overlay
    630 U00df
    631 U00df		       00 00	   POS_Vector ds	2
    632 U00e1
    633 U00e1							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    635 U00e1
    636 U00e1							;------------------------------------------------------------------------------
      0 U00e1					      OVERLAY	Surround
      1 U00e7 ????				      SEG.U	OVERLAY_Surround
      2 U00df					      org	Overlay
    638 U00df		       00 00	   Temp_Board_Address1 ds	2
    639 U00e1		       00 00	   Temp_Board_Address2 ds	2
    640 U00e3		       00 00	   Temp_Board_Address3 ds	2
    641 U00e5							;    IF MULTI_BANK_BOARD = YES 	 ; commented, else DASM freaks out
    642 U00e5		       00	   Temp_Bank2 ds	1
    643 U00e6		       00	   Temp_Bank3 ds	1
    644 U00e7							;    ENDIF
    645 U00e7
    646 U00e7							;ECHO "FREE BYTES IN OVERLAY_Surround = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e7					      VALIDATE_OVERLAY
      5 U00e7					      LIST	ON
    648 U00e7							;------------------------------------------------------------------------------
    649 U00e7
      0 U00e7					      OVERLAY	ScoreLineOverlay
      1 U00ee ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00df					      org	Overlay
    651 U00df
    652 U00df		       00 00	   S0	      ds	2	; used for addressing digits of score
    653 U00e1		       00 00	   S1	      ds	2
    654 U00e3		       00 00	   S2	      ds	2
    655 U00e5		       00 00	   S3	      ds	2
    656 U00e7		       00 00	   S4	      ds	2
    657 U00e9		       00 00	   S5	      ds	2
    658 U00eb
    659 U00eb		       00	   stkp       ds	1
    660 U00ec		       00	   sreg       ds	1
    661 U00ed		       00	   loop       ds	1
    662 U00ee
    663 U00ee							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00ee					      VALIDATE_OVERLAY
      5 U00ee					      LIST	ON
    665 U00ee
    666 U00ee							;------------------------------------------------------------------------------
    667 U00ee
    668 U00ee
      0 U00ee					      OVERLAY	DecodeCaveOverlay
      1 U00ea ????				      SEG.U	OVERLAY_DecodeCaveOverlay
      2 U00df					      org	Overlay
    670 U00df
    671 U00df							; used everywhere
    672 U00df		       00 00 00 00 ptrCave    ds	4	; two pointers
    673 U00e3
    674 U00e3		       00	   randSeed1  ds	1
    675 U00e4		       00	   randSeed2  ds	1
    676 U00e5		       00	   tempRand1  ds	1
    677 U00e6		       00	   tempRand2  ds	1
    678 U00e7		       00	   tmpScore   ds	1
    679 U00e8
    680 U00e8							;------------------------------------------------------------------------------
    681 U00e8
    682 U00e8		       00	   object     ds	1
    683 U00e8		       00 e3	   structType =	randSeed1
    684 U00e8		       00 e4	   column     =	randSeed2
    685 U00e8		       00 e5	   row	      =	tempRand1
    686 U00e8		       00 e6	   length     =	tempRand2
    687 U00e8		       00 e1	   height     =	ptrCave+2
    688 U00e8		       00 e2	   direction  =	ptrCave+3
    689 U00e9		       00	   tmpLength  ds	1
    690 U00ea
    691 U00ea							;ECHO "FREE BYTES IN DecodeCaveOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00ea					      VALIDATE_OVERLAY
      5 U00ea					      LIST	ON
    693 U00ea
    694 U00ea							;------------------------------------------------------------------------------
    695 U00ea
      0 U00ea					      OVERLAY	Copyright
      1 U00e5 ????				      SEG.U	OVERLAY_Copyright
      2 U00df					      org	Overlay
    697 U00df		       00	   LoopCount  ds	1
    698 U00e0		       00	   colorBK    ds	1
    699 U00e1		       00 00	   Temp       ds	2
    700 U00e3		       00	   CopyTime   ds	1
    701 U00e4		       00	   saveSP     ds	1
      0 U00e5					      VALIDATE_OVERLAY
      5 U00e5					      LIST	ON
    703 U00e5
      0 U00e5					      OVERLAY	ManProcessing
      1 U00e1 ????				      SEG.U	OVERLAY_ManProcessing
      2 U00df					      org	Overlay
    705 U00df		       00 00	   actionVector ds	2
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    707 U00e1
      0 U00e1					      OVERLAY	CaveDecode
      1 U00e0 ????				      SEG.U	OVERLAY_CaveDecode
      2 U00df					      org	Overlay
    709 U00df		       00	   savex      ds	1
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    711 U00e0
    712 U00e0
      0 U00e0					      OVERLAY	TJSound
      1 U00e4 ????				      SEG.U	OVERLAY_TJSound
      2 U00df					      org	Overlay
    714 U00df							; temps (overlay these with existing temps to save RAM)
    715 U00df		       00	   musicTemp  ds	1
    716 U00e0		       00	   musicTemp16L ds	1
    717 U00e1		       00	   musicTemp16H ds	1
    718 U00e2		       00	   musicAtten ds	1
    719 U00e3		       00	   tmpVar     ds	1
      0 U00e4					      VALIDATE_OVERLAY
      5 U00e4					      LIST	ON
    721 U00e4
      0 U00e4					      OVERLAY	SetPlatformColours
      1 U00e0 ????				      SEG.U	OVERLAY_SetPlatformColours
      2 U00df					      org	Overlay
    723 U00df		       00	   colorIdx   ds	1
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    725 U00e0
      0 U00e0					      OVERLAY	SwapPlayers
      1 U00e0 ????				      SEG.U	OVERLAY_SwapPlayers
      2 U00df					      org	Overlay
    727 U00df		       00	   tmpX       ds	1
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    729 U00e0
      0 U00e0					      OVERLAY	DrawIntoStack
      1 U00e0 ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00df					      org	Overlay
    731 U00df		       00	   save_SP    ds	1
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    733 U00e0
    734 U00e0
    735 U00e0							;------------------------------------------------------------------------------
    736 U00e0							;##############################################################################
    737 U00e0							; TITLE SCREEN VARS
    738 U00e0							;------------------------------------------------------------------------------
    739 U00e0
    740 U00e0		       00 21	   NUM_BLOCKS =	33	; number of text graphics blocks
    741 U00e0		       00 04	   BLOCK_H    =	4	; height of the text graphics blocks
    742 U00e0		       00 08	   BORDER_H   =	8	; height of border blocks (~width of one PF pixel)
    743 U00e0		       00 06	   GAP_H      =	6	; height of gap blocks (~width of one PF pixel)
    744 U00e0		       00 a0	   TKERNEL_H  =	NUM_BLOCKS*BLOCK_H + 2*BORDER_H + 2*GAP_H	; = 160
    745 U00e0		       00 20	   LKERNEL_H  =	32	; height of logo/selection
    746 U00e0
    747 U00ff ????				      SEG.U	variables2
    748 U0082					      ORG	Platform+1
    749 U0082
    750 U0082		       00 82	   startOfTitleRAM =	.
    751 U0082							; current selection (has to be 0..x):
    752 U0082		       00 04	   NUM_SEL    =	4
    753 U0082
    754 U0082		       00 00 00 00 selLst     ds	NUM_SEL
    755 U0082		       00 82	   sCave      =	selLst	; 0..3/19 (FINAL_VERSION = A, E, I, M, multiply by 5 to get real number, )
    756 U0082		       00 83	   sLevel     =	selLst+1	; 0..4
    757 U0082		       00 84	   sPlayers   =	selLst+2	; 0..1
    758 U0082		       00 85	   sJoysticks =	selLst+3	; 0..1
    759 U0082		       00 86	   endTitleClear =	.
    760 U0086
    761 U0086							; from here the variables can be cleared
    762 U0086		       00	   titleMode  ds	1	; logo = 0/selection = 1
    763 U0087		       00	   counter    ds	1
    764 U0088		       00	   btnReleased ds	1
    765 U0089		       00	   hmJunior   ds	1	; $f0/$50
    766 U008a							; music vars:
    767 U008a		       00	   noteLen    ds	1
    768 U008b		       00	   noteIdx    ds	1
    769 U008c		       00	   note0      ds	1
    770 U008d		       00	   note1      ds	1
    771 U008e
    772 U008e		       00	   inputBuffer ds	1
    773 U008f		       00	   demoDelay  ds	1
    774 U0090
    775 U0090		       00	   audv0Lo    ds	1
    776 U0091		       00	   audv0Hi    ds	1
    777 U0092		       00	   audv1Lo    ds	1
    778 U0093		       00	   audv1Hi    ds	1
    779 U0094							; offset to compensate early precalculation:
    780 U0094		       00	   audvOfsLo  ds	1
    781 U0095		       00	   audvOfsHi  ds	1
    782 U0096
    783 U0096							; selection vars
    784 U0096		       00	   tmpY       ds	1
    785 U0096		       00 96	   tmpGfx     =	tmpY
    786 U0096		       00 96	   tmpGfxA    =	tmpGfx
    787 U0097		       00	   tmpGfxB    ds	1
    788 U0098
    789 U0098		       00	   loopCntFSS ds	1
    790 U0098		       00 98	   loopCntSel =	loopCntFSS
    791 U0099		       00 00	   ptrGfxA    ds	2
    792 U009b		       00 00	   ptrGfxB    ds	2
    793 U009d
    794 U009d		       00	   selRow     ds	1
    795 U009e
    796 U009e		       00	   audvTmpLo  ds	1	; high values stored in following list
    797 U009f		       00 00 00 00*audV0Lst   ds	(TKERNEL_H + LKERNEL_H)/2	; = 96 bytes
    798 U009f		       00 9f	   audV0LstBtm =	audV0Lst
    799 U009f		       00 af	   audV0LstTop =	audV0Lst + LKERNEL_H/2
    800 U009f		       00 ff	   endOfTitleRAM =	.
    801 U00ff
    802 U00ff							;------------------------------------------------------------------------------
    803 U00ff							;##############################################################################
    804 U00ff							;------------------------------------------------------------------------------
    805 U00ff
    806 U00ff							; NOW THE VERY INTERESTING '3E' RAM BANKS
    807 U00ff							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    808 U00ff
    809 U00ff				   ORIGIN     SET	0
      0 U00ff					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN / RAM_SIZE
      6 U0000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    811 U0000
    812 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    813 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    814 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    815 U0000
    816 U0000		       00 54	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    817 U0000
    818 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    819 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    820 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    821 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    822 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    823 U0000
    824 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    825 U0000							; is that we can use that code to switch between banks, and the system will happily
    826 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    827 U0000
    828 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    829 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    830 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    831 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    832 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    833 U0000
    834 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    835 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    836 U0000							; part of the draw routine *every* scanline (though the system currently uses
    837 U0000							; one colour shared between both players).
    838 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    840 U0000
    841 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    842 U0000							; accessed via the above labels but with the appropriate bank switched in.
    843 U0000
    844 U0000							;------------------------------------------------------------------------------
    845 U0000
    846 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    846 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    846 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    846 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1000				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    846 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    846 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    846 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    849 U1c00					      REPEND
    850 U1c00
    851 U1c00							;------------------------------------------------------------------------------
    852 U1c00							;##############################################################################
    853 U1c00							;------------------------------------------------------------------------------
    854 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN / RAM_SIZE
      6 U2000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    856 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    857 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    859 U2000
    860 U2000							;------------------------------------------------------------------------------
    861 U2000							;##############################################################################
    862 U2000							;------------------------------------------------------------------------------
    863 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN / RAM_SIZE
      6 U2400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    865 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    866 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    868 U2400
    869 U2400							;------------------------------------------------------------------------------
    870 U2400							;##############################################################################
    871 U2400							;------------------------------------------------------------------------------
    872 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_CAVE
      1 U2800 ????				      SEG.U	BANK_DECODE_CAVE
      2 U2800					      ORG	ORIGIN
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_CAVE SET	ORIGIN / RAM_SIZE
      6 U2800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    874 U2800							; VARS DEFINED IN BANK_DECODE_CAVE_SHADOW
    875 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    877 U2800
    878 U2800							;------------------------------------------------------------------------------
    879 U2800							;##############################################################################
    880 U2800							;------------------------------------------------------------------------------
    881 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN / RAM_SIZE
      6 U2c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
    883 U2c00
    884 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    885 U2c00							; position of something that needs to be processed.  These things include anything
    886 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    887 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    888 U2c00							; one for the next processing iteration.
    889 U2c00
    890 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    891 U2c00
    892 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    893 U2c00
    894 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    895 U2c00
    896 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    897 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    898 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    899 U2d80
    900 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    901 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    902 U2e00
    903 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    904 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    905 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    906 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    908 U2e80
    909 U2e80							;------------------------------------------------------------------------------
    910 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN / RAM_SIZE
      6 U3000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    912 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    914 U3000
    915 U3000							;------------------------------------------------------------------------------
    916 U3000
    917 U3000							;		  NEWRAMBANK BANK_OBJSTACKA
    918 U3000
    919 U3000							;
    920 U3000
    921 U3000
    922 U3000							;    ECHO "FREE RAM IN BANK_OBJSTACKA = ", RAM_SIZE - ( * - BANK_START )
    923 U3000
    924 U3000							;		VALIDATE_RAM_SIZE
    925 U3000
    926 U3000							;------------------------------------------------------------------------------
    927 U3000
    928 U3000							;		  NEWRAMBANK BANK_OBJSTACKA2
    929 U3000							; THIS IS A MIRROR OF BANK_OBJSTACKA -- DO NOT MODIFY OR USE!!
    930 U3000							;		  VALIDATE_RAM_SIZE
    931 U3000
    932 U3000							;------------------------------------------------------------------------------
    933 U3000							;##############################################################################
    934 U3000							;------------------------------------------------------------------------------
    935 U3000
    936 U3000							;		  NEWRAMBANK BANK_TITLE_SCREEN
    937 U3000							; VARS DEFINED IN ROM_SHADOW_OF_TITLE_SCREEN
    938 U3000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
    939 U3000							;		  VALIDATE_RAM_SIZE
    940 U3000
    941 U3000
    942 U3000							;------------------------------------------------------------------------------
    943 U3000							;##############################################################################
    944 U3000							;------------------------------------------------------------------------------
    945 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U37a0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN / RAM_SIZE
      6 U3400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    947 U3400
    948 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    949 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    950 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    951 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    952 U3400							; when accessing.
    953 U3400
    954 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    955 U3400							; automatically based on the sizes set in these constants. The board may overlay
    956 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    957 U3400							; we're doing OK.
    958 U3400
    959 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    960 U3400
    961 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    962 U3400
    963 U3400		       00 28	   SIZE_BOARD_X =	40
    964 U3400		       00 16	   SIZE_BOARD_Y =	22
    965 U3400
    966 U3400							; have to precalculate it here, else DASM freaks out:
    967 U3400				   .BOARD_SIZE SET	0
    968 U3400				   .BOARD_LOCATION SET	0
    969 U3400					      REPEAT	SIZE_BOARD_Y
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    969 U3400					      REPEND
    970 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    971 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    972 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    973 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    974 U3400					      ENDIF
    975 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    976 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    977 U3400					      REPEND
    978 U3400
    979 U3400		       03 a0	   SIZE_BOARD =	.BOARD_SIZE
    980 U3400
    981 U3400
    982 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    983 U3400				  -MULTI_BANK_BOARD =	YES
    984 U3400					      ELSE
    985 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    986 U3400					      ENDIF
    987 U3400
    988 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    989 U37a0							; 1024 byte chunks, switching RAM
    990 U37a0							; banks as we go.  In other words,
    991 U37a0							; this overlaps multiple banks!
    992 U37a0
    993 U37a0
    994 U37a0							; free space here (but hard to use)
    995 U37a0							; So we need to calculate where the next free bank is!
    996 U37a0							; TODO: This looks dodgy.  Check..
    997 U37a0
    998 U37a0				   ORIGIN     SET	( * + RAM_SIZE - 1 ) / RAM_SIZE
    999 U37a0				   ORIGIN     SET	ORIGIN * RAM_SIZE
   1000 U37a0
   1001 U37a0
   1002 U37a0
   1003 U37a0							;------------------------------------------------------------------------------
   1004 U37a0							;##############################################################################
   1005 U37a0							;------------------------------------------------------------------------------
   1006 U37a0
   1007 U37a0							;------------------------------------------------------------------------------
   1008 U37a0
   1009 U37a0							;    IFNCONST MAX_CAVE_SIZE
   1010 U37a0				   MAX_CAVE_SIZE SET	0
   1011 U37a0							;    ENDIF
   1012 U37a0
   1013 U37a0							;    IFNCONST MAX_CAVE_NUMBER
   1014 U37a0				   MAX_CAVE_NUMBER SET	0
   1015 U37a0							;    ENDIF
   1016 U37a0
   1017 U37a0					      MAC	start_cave
   1018 U37a0				   CAVE_START SET	*
   1019 U37a0				   BANK_CAVE_{1} =	_CURRENT_BANK
   1020 U37a0				   CAVE_{1}   SUBROUTINE
   1021 U37a0				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
   1022 U37a0							; ECHO "current MAX_CAVE_NUMBER = ", MAX_CAVE_NUMBER
   1023 U37a0					      ENDM		; {name}
   1024 U37a0
   1025 U37a0
   1026 U37a0					      MAC	end_cave
   1027 U37a0					      .byte	$FF
   1028 U37a0				   CAVE_SIZE_{1} =	* - CAVE_START
   1029 U37a0					      IF	CAVE_SIZE_{1} > MAX_CAVE_SIZE
   1030 U37a0				   MAX_CAVE_SIZE SET	CAVE_SIZE_{1}
   1031 U37a0					      ENDIF
   1032 U37a0					      ENDM		; {name}
   1033 U37a0
   1034 U37a0					      MAC	cave_size
   1035 U37a0					      .byte	{1},{2}
   1036 U37a0					      ENDM		; x, y
   1037 U37a0
   1038 U37a0					      MAC	cave_size_room
   1039 U37a0					      CAVE_SIZE	40, 22
   1040 U37a0					      ENDM
   1041 U37a0
   1042 U37a0					      MAC	cave_size_intermission
   1043 U37a0					      CAVE_SIZE	20, 12
   1044 U37a0					      ENDM
   1045 U37a0
   1046 U37a0					      MAC	stoch
   1047 U37a0					      .byte	{1},{2},{3}
   1048 U37a0					      ENDM		; {character} {x} {y}
   1049 U37a0
   1050 U37a0					      MAC	cave_random
   1051 U37a0					      .byte	{1},{2},{3},{4},{5}
   1052 U37a0					      ENDM		; {1}{2}{3}{4}{5}
   1053 U37a0
   1054 U37a0							;-------------------------------------------------------------------------------
   1055 U37a0							; Define which screens are to be included in assembly. This sets the INCLUSION.
   1056 U37a0							; The ORDERING is defined in a similar table in DecodeCave.asm.
   1057 U37a0
   1058 U37a0					      MAC	include_cave
   1059 U37a0				   CAVE_ACTIVE_{1} SET	0
   1060 U37a0					      ENDM		; {name}
   1061 U37a0					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0 U37a0					      INCLUDE_CAVE	INTRO
      1 U37a0				   CAVE_ACTIVE_INTRO SET	0
   1063 U37a0				  -	      ELSE
   1064 U37a0				  -	      INCLUDE_CAVE	APOCALYPSE
   1065 U37a0				  -	      INCLUDE_CAVE	FUNNEL
   1066 U37a0					      ENDIF
   1067 U37a0
   1068 U37a0		       00 32	   MAX_CAVENUM EQU	CAVENUM
   1069 U37a0
      0 U37a0					      INCLUDE_CAVE	SELECTION_SCREEN	; This should be the LAST cave, though!
      1 U37a0				   CAVE_ACTIVE_SELECTION_SCREEN SET	0
   1071 U37a0
   1072 U37a0
   1073 U37a0							;--------------------------------------------------------------------------------
   1074 U37a0
   1075 U37a0				   ORIGIN     SET	$00000
   1076 U37a0
------- FILE BANK_MUSIC.asm LEVEL 2 PASS 3
      0 U37a0					      include	"BANK_MUSIC.asm"
      1 U37a0							;------------------------------------------------------------------------------
      2 U37a0							;##############################################################################
      3 U37a0							;------------------------------------------------------------------------------
      4 U37a0
      5 U37a0							; 2K reserved for music.
      6 U37a0
      0 U37a0					      NEWBANK	BANK_MUSIC1
      1  045c ????				      SEG	BANK_MUSIC1
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   BANK_MUSIC1 SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	BANK_MUSIC1
      8  0000
      9  0000							;build datestamp
     10  0000
     11  0000					      IF	DEMO_VERSION = NO
     12  0000		       46 65 62 20*	      .byte.b	"Feb 29 2012"
     13  000b				  -	      ELSE
     14  000b				  -	      .byte	"Jan 18 2014"
     15  000b					      ENDIF
     16  000b
     17  000b					      IF	EMBED_COPYRIGHT = YES
     18  000b		       20 20 20 20*	      ds	80, " "
     19  005b		       54 68 69 73*	      .byte.b	"This Atari 2600 "
     20  006b		       76 65 72 73*	      .byte.b	"version of Bould"
     21  007b		       65 72 20 44*	      .byte.b	"er Dash(R) was p"
     22  008b		       72 6f 67 72*	      .byte.b	"rogrammed by And"
     23  009b		       72 65 77 20*	      .byte.b	"rew Davie and Th"
     24  00ab		       6f 6d 61 73*	      .byte.b	"omas Jentzsch be"
     25  00bb		       74 77 65 65*	      .byte.b	"tween 2003 and 2"
     26  00cb		       30 31 32 2e*	      .byte.b	"012. BOX Das"
     27  00d7		       68 28 52 29*	      .byte.b	"h(R) is a regist"
     28  00e7		       65 72 65 64*	      .byte.b	"ered trademark o"
     29  00f7		       66 20 46 69*	      .byte.b	"f First Star Sof"
     30  0107		       74 77 61 72*	      .byte.b	"tware, Inc. Copy"
     31  0117		       72 69 67 68*	      .byte.b	"right (C)1984-20"
     32  0127		       31 32 20 46*	      .byte.b	"12 First Star So"
     33  0137		       66 74 77 61*	      .byte.b	"ftware, Inc. All"
     34  0147		       20 72 69 67*	      .byte.b	" rights reserved"
     35  0157		       2e 20 54 68*	      .byte.b	". The supporting"
     36  0167		       20 73 6f 66*	      .byte.b	" software, inclu"
     37  0177		       64 69 6e 67*	      .byte.b	"ding the graphic"
     38  0187		       73 20 65 6e*	      .byte.b	"s engine, optmis"
     39  0197		       61 74 69 6f*	      .byte.b	"ation algorithms"
     40  01a7		       2c 20 61 6e*	      .byte.b	", and other code"
     41  01b7		       20 61 6e 64*	      .byte.b	" and logic not p"
     42  01c7		       65 72 74 61*	      .byte.b	"ertaining to the"
     43  01d7		       20 42 4f 58*	      .byte.b	" BOX Dash(R)"
     44  01e3		       20 69 6d 70*	      .byte.b	" implementation,"
     45  01f3		       20 61 72 65*	      .byte.b	" are Copyright ("
     46  0203		       43 29 32 30*	      .byte.b	"C)2012 Andrew Da"
     47  0213		       76 69 65 20*	      .byte.b	"vie and Thomas J"
     48  0223		       65 6e 74 7a*	      .byte.b	"entzsch."
     49  022b					      IF	DEMO_VERSION = NO
     50  022b		       20 54 68 69*	      .byte.b	" This bi"
     51  0233		       6e 61 72 79*	      .byte.b	"nary is not free"
     52  0243		       20 61 6e 64*	      .byte.b	" and may not be "
     53  0253		       73 6f 6c 64*	      .byte.b	"sold, or redistr"
     54  0263		       69 62 75 74*	      .byte.b	"ibuted in any mo"
     55  0273		       64 69 66 69*	      .byte.b	"dified form. "
     56  0280				  -	      ELSE
     57  0280				  -	      .byte	" This 2nd demo version Copyright (C)2014."
     58  0280					      ENDIF
     59  0280		       20 20 20 20*	      ds	80, "	"
     60  02d0					      ENDIF
     61  02d0
     62  02d0							;--------------------------------------------------------------------------
     63  02d0
------- FILE sounds.asm LEVEL 3 PASS 3
      0  02d0					      include	"sounds.asm"	; code and data for the various sounds:
      1  02d0							; Sound TODOs:
      2  02d0							; ? (un)cover cave (not done yet)
      3  02d0							; + initial crack sound
      4  02d0							; + diamond pickup
      5  02d0							; o diamond starts falling (double start bug)
      6  02d0							; + diamond lands
      7  02d0							; o BOX stars falling (double start bug)
      8  02d0							; + BOX lands
      9  02d0							; + BOX is pushed
     10  02d0							; + Rockford moves through soil
     11  02d0							; + Rockford moves through blank
     12  02d0							; + Rockfords digs into soil
     13  02d0							; + magic wall
     14  02d0							; + amoeba
     15  02d0							; + door opens (background flash fixed)
     16  02d0							; + running out of time
     17  02d0							; + bonus points
     18  02d0							; x extra live (no sound, Cosmic Ark effect instead, fix colors)
     19  02d0
     20  02d0							; - BD doku seems wrong, there are sound priorities
     21  02d0							;   -> rework sound system, prioritisize sounds!
     22  02d0
     23  02d0
     24  02d0
     25  02d0		       00 01	   LOW_BONUS_SOUND =	1	; 1 = the bonus points sound goes deeper
     26  02d0		       00 0f	   SND_MASK_LO =	%1111
     27  02d0		       00 f0	   SND_MASK_HI =	%11110000
     28  02d0
     29  02d0							;-----------------------------------------------------------
     30  02d0
     31  02d0					      MAC	start_sound
     32  02d0					      SUBROUTINE
     33  02d0					      lda	newSounds	; 3
     34  02d0					      IF	{1} < 16
     35  02d0					      and	#SND_MASK_LO	; 2
     36  02d0					      cmp	#SOUND_MOVE_SOIL+1	; 2	 overwrite low priority move sounds
     37  02d0					      bcs	.skipNew	; 2/3
     38  02d0					      ELSE
     39  02d0					      and	#SND_MASK_HI	; 2
     40  02d0					      cmp	#(SOUND_MOVE_SOIL+1)<<4	; 2	 overwrite low priority move sounds
     41  02d0					      bcs	.skipNew	; 2/3
     42  02d0							;	  bne	  .skipNew	      ; 2/3
     43  02d0					      ENDIF
     44  02d0					      eor	newSounds	; 3
     45  02d0					      ora	#{1}	; 2
     46  02d0					      sta	newSounds	; 3
     47  02d0				   .skipNew
     48  02d0					      SUBROUTINE
     49  02d0					      ENDM		; = 15
     50  02d0
     51  02d0
     52  02d0							;-----------------------------------------------------------
     53  02d0
     54  02d0					      MAC	start_prio_sound
     55  02d0					      lda	newSounds	; 3
     56  02d0					      IF	{1} < 16
     57  02d0					      and	#<(~SND_MASK_LO)	; 2
     58  02d0					      ELSE
     59  02d0					      and	#<(~SND_MASK_HI)	; 2
     60  02d0					      ENDIF
     61  02d0					      ora	#{1}	; 2
     62  02d0					      sta	newSounds	; 3
     63  02d0					      ENDM		; = 10
     64  02d0
     65  02d0							;-----------------------------------------------------------
     66  02d0
     67  02d0					      MAC	stop_channel
     68  02d0							; only any sound in the channel
     69  02d0					      lda	#0
     70  02d0					      sta	soundIdxLst+{1}
     71  02d0					      sta	AUDV0+{1}
     72  02d0					      ENDM		; {0 or 1}
     73  02d0
     74  02d0							;-----------------------------------------------------------
     75  02d0
     76  02d0					      MAC	stop_sound
     77  02d0							; only stops a given sound the channel
     78  02d0					      lda	#{2}
     79  02d0					      eor	soundIdxLst+{1}
     80  02d0					      bne	.skipStop
     81  02d0					      sta	soundIdxLst+{1}
     82  02d0					      sta	AUDV0+{1}
     83  02d0				   .skipStop
     84  02d0					      ENDM		; {0 or 1, sound offset}
     85  02d0
     86  02d0							;-----------------------------------------------------------
      0  02d0					      DEFINE_SUBROUTINE	StartSound
      1  02d0		       00 00	   BANK_StartSound =	_CURRENT_BANK
      2  02d0					      SUBROUTINE
      3  02d0				   StartSound
     88  02d0							;-----------------------------------------------------------
     89  02d0							; worst case timings:
     90  02d0							; SOIL, DIRT = 82
     91  02d0							; channel0   = 69
     92  02d0							; channel1   = 68
     93  02d0							; channel1   = 80+(1..2*9) (random frequency)
     94  02d0							;-----------------------------------------------------------
     95  02d0							; a = sound idx
     96  02d0							; 1. assign all sounds (except move) to their channels:
     97  02d0
     98  02d0		       a2 01		      ldx	#1	; 2
     99  02d2		       c9 20		      cmp	#SOUND_GROUP_HI	; 2
    100  02d4		       90 08		      bcc	.checkChannel0	; 2/3
    101  02d6							; channel 1 group sounds get prioritized:
    102  02d6		       c5 d6		      cmp	soundIdxLst+1	; 2
    103  02d8		       f0 47		      beq	.skipSound	; 2/3	     avoid restarting the same sound
    104  02da		       b0 1d		      bcs	.startChannel	; 2/3=12
    105  02dc		       90 43		      bcc	.skipSound	; 3
    106  02de
    107  02de				   .checkChannel0		; 7
    108  02de		       ca		      dex		; 2 =	9
    109  02df
    110  02df		       c9 0c		      cmp	#SOUND_GROUP_LO	; 2
    111  02e1		       90 0c		      bcc	.soundFree	; 2/3
    112  02e3		       c5 d5		      cmp	soundIdxLst	; 3	     prio >= current sound?
    113  02e5		       b0 12		      bcs	.startChannel	; 2/3	      yes, overwrite
    114  02e7		       a4 d5		      ldy	soundIdxLst	; 3
    115  02e9		       c0 18		      cpy	#OFSS_EXPLOSION	; 2	     current explosion?
    116  02eb		       b0 34		      bcs	.skipSound	; 2/3	      yes, keep
    117  02ed		       90 0a		      bcc	.startChannel	; 2/3	      no, overwrite
    118  02ef
    119  02ef							; 2. move sound, check for a free channel (1 preferred):
    120  02ef				   .soundFree
    121  02ef		       e8		      inx		; 2
    122  02f0		       a4 d6		      ldy	soundIdxLst+1	; 3	     channel 1 free?
    123  02f2		       f0 05		      beq	.startChannel	; 2/3	      yes, use it
    124  02f4		       ca		      dex		; 2
    125  02f5		       a4 d5		      ldy	soundIdxLst	; 3	     channel 0 free?
    126  02f7		       d0 28		      bne	.skipSound	; 2/3=14     no, skip sound
    127  02f9
    128  02f9							; 3. create new sound:
    129  02f9				   .startChannel		;13/14/21/27 (ch1, ch0, dirt/soil)
    130  02f9		       95 d5		      sta	soundIdxLst,x	; 4
    131  02fb		       a8		      tay		; 2 =	6
    132  02fc
    133  02fc				   RestartSound
    134  02fc							; x = sound channel 0/1
    135  02fc							; y = sound index
    136  02fc		       a9 00		      lda	#0	; 2
    137  02fe		       95 d9		      sta	decayTimeLst,x	; 4
    138  0300		       95 59		      sta	AUDV0,x	; 4
    139  0302		       b9 02 f4 	      lda	SoundTbl+OFS_RND_FREQ,y	; 4
    140  0305		       f0 0a		      beq	.fixedFreq	; 2/3=16
    141  0307
    142  0307							; increase base frequency by random value:
    143  0307		       a5 87		      lda	rnd	;NEXT_RANDOM		 ; 3
    144  0309		       29 0e		      and	#%1110	; 2 =	5    up to 8 different variations
    145  030b				   .reTry
    146  030b		       4a		      lsr		; 2
    147  030c		       d9 02 f4 	      cmp	SoundTbl+OFS_RND_FREQ,y	; 4
    148  030f		       b0 fa		      bcs	.reTry	; 2/3= 8
    149  0311				   .fixedFreq
    150  0311		       18		      clc		; 2
    151  0312		       79 01 f4 	      adc	SoundTbl+OFS_FREQ,y	; 4
    152  0315		       95 57		      sta	AUDF0,x	; 4
    153  0317		       b9 00 f4 	      lda	SoundTbl+OFS_DIST,y	; 4
    154  031a		       95 55		      sta	AUDC0,x	; 4
    155  031c		       b9 03 f4 	      lda	SoundTbl+OFS_DECAY,y	; 4
    156  031f		       95 d7		      sta	decayIdxLst,x	; 4 = 26
    157  0321
    158  0321				   .skipSound
    159  0321		       60		      rts		; 6 =	6
    160  0322
    161  0322							;-----------------------------------------------------------
    162  0322
    163  0322							;ManActionSounds
    164  0322							;		  .byte 1 ;<manStartup		  ; 0		  sounds
    165  0322							;		  .byte 1 ;<normalMan		  ; 1
    166  0322							;		  .byte 1 ;<deadMan		  ; 2
    167  0322							;		  .byte 1 ;<waitingMan		  ; 3
    168  0322							;		  .byte 1 ;<waitingManPress	  ; 4
    169  0322							;		  .byte 1 ;<waitingManNoTim	  ; 5
    170  0322							;		  .byte 1 ;<waitingManPressNoTim  ; 6
    171  0322							;		  .byte 0 ;<nextLevelMan	  ; 7
    172  0322							;		  .byte 1 ;<BonusCountdownStart   ; 8
    173  0322							;		  .byte 1 ;<BonusCountdownRun	  ; 9
    174  0322
    175  0322
    176  0322							;-----------------------------------------------------------
      0  0322					      DEFINE_SUBROUTINE	PlaySounds
      1  0322		       00 00	   BANK_PlaySounds =	_CURRENT_BANK
      2  0322					      SUBROUTINE
      3  0322				   PlaySounds
    178  0322							;-----------------------------------------------------------
    179  0322
    180  0322		       a4 a3		      ldy	ManMode	; 3	     new sounds allowed?
    181  0324		       c0 07		      cpy	#MANMODE_NEXTLEVEL	; 2
    182  0326		       f0 18		      beq	.skipHi	; 2/3
    183  0328
    184  0328		       a5 db		      lda	newSounds	; 3
    185  032a		       29 0f		      and	#SND_MASK_LO	; 2
    186  032c		       f0 05		      beq	.skipLo	; 2/3	     no new low sound was triggered
    187  032e		       0a		      asl		; 2
    188  032f		       0a		      asl		; 2
    189  0330		       20 d0 f2 	      jsr	StartSound	; 6
    190  0333				   .skipLo
    191  0333		       a5 db		      lda	newSounds	; 3
    192  0335		       29 f0		      and	#SND_MASK_HI	; 2
    193  0337		       f0 07		      beq	.skipHi	; 2/3	     no new high sound was triggered
    194  0339		       4a		      lsr		; 2
    195  033a		       4a		      lsr		; 2
    196  033b		       69 1c		      adc	#<(SoundTblHi-SoundTbl-4)
    197  033d		       20 d0 f2 	      jsr	StartSound	; 6
    198  0340				   .skipHi
    199  0340		       a9 00		      lda	#0	; 2	     prepare for new triggers
    200  0342		       85 db		      sta	newSounds	; 3
    201  0344
    202  0344							; fall through
    203  0344
    204  0344							; The issue here is that this code writes to channels which are not in use.
    205  0344
      0  0344					      NEXT_RANDOM		; this makes sure rnd is updated each frame, also used for other things!
      1  0344
      2  0344		       a5 87		      lda	rnd
      3  0346		       4a		      lsr
      4  0347					      IFCONST	rndHi
      5  0347		       66 88		      ror	rndHi
      6  0349					      ENDIF
      7  0349		       90 02		      bcc	.skipEOR
      8  034b		       49 b4		      eor	#RND_EOR_VAL
      9  034d				   .skipEOR
     10  034d		       85 87		      sta	rnd
    207  034f
    208  034f		       00 e3	   .freqVibrato =	tmpVar	; @Andrew: replace with whatever is available
    209  034f							; called once/frame
    210  034f		       a2 01		      ldx	#1
    211  0351				   .loopSound
    212  0351
    213  0351		       b5 d5		      lda	soundIdxLst,x
    214  0353		       f0 4c		      beq	.nextSound	; don't write to inactive channels! IMPORTANT SO MUSIC CAN CO-EXIST
    215  0355
    216  0355		       c9 1c		      cmp	#OFSS_BONUS_POINTS
    217  0357		       f0 1d		      beq	.bonusPointsSound	;
    218  0359
    219  0359		       b5 d9		      lda	decayTimeLst,x
    220  035b		       d0 42		      bne	.contNote
    221  035d							; start next note:
    222  035d		       b4 d7		      ldy	decayIdxLst,x
    223  035f		       b9 ab f3 	      lda	DecayTbl,y
    224  0362		       95 59		      sta	AUDV0,x
    225  0364		       d0 31		      bne	.contSound
    226  0366							; current sound is over, now check what to do next:
    227  0366		       b4 d5		      ldy	soundIdxLst,x
    228  0368		       c0 1c		      cpy	#OFSS_BONUS_POINTS
    229  036a		       f0 0a		      beq	.bonusPointsSound	;
    230  036c		       b9 00 f4 	      lda	SoundTbl+OFS_DIST,y	;   loop sound?
    231  036f		       10 34		      bpl	.endSound	;
    232  0371		       20 fc f2 	      jsr	RestartSound
    233  0374		       d0 db		      bne	.loopSound
    234  0376
    235  0376							; special handling for score countdown sound:
    236  0376				   .bonusPointsSound
    237  0376		       a5 d7		      lda	soundBonusPts
    238  0378		       a8		      tay
    239  0379		       29 03		      and	#$03
    240  037b		       49 03		      eor	#$03
    241  037d		       85 e3		      sta	.freqVibrato
    242  037f		       98		      tya
    243  0380		       4a		      lsr
    244  0381		       4a		      lsr
    245  0382		       4a		      lsr
    246  0383		       38		      sec		; frequency divider:
    247  0384		       e5 e3		      sbc	.freqVibrato	; 1,2,3,4, 1,2,3,4, 2,3,4,5...
    248  0386		       85 57		      sta	AUDF0	; ...28,29,30,31, 28,29,30,31
    249  0388		       a9 07		      lda	#VOL_SOUND_BONUS
    250  038a		       85 59		      sta	AUDV0
    251  038c							;		  cpy	  #MAX_SOUND_BONUS-1
    252  038c							;		  bcc	  .skipReset
    253  038c		       98		      tya
    254  038d		       d0 08		      bne	.skipReset
    255  038f					      IF	LOW_BONUS_SOUND
    256  038f		       a0 06		      ldy	#DIST_DIV31
    257  0391		       84 55		      sty	AUDC0
    258  0393		       a0 37		      ldy	#$38-1
    259  0395				  -	      ELSE
    260  0395				  -	      ldy	#MIN_SOUND_BONUS-1
    261  0395					      ENDIF
    262  0395		       84 d7		      sty	soundBonusPts	; = decayIdxLst !
    263  0397				   .skipReset
    264  0397							;		  lda	  #1<<4 		  ; -> decayTimeLst,x = 1
    265  0397
    266  0397							; continue with normal sounds:
    267  0397				   .contSound
    268  0397		       4a		      lsr
    269  0398		       4a		      lsr
    270  0399		       4a		      lsr
    271  039a		       4a		      lsr
    272  039b		       95 d9		      sta	decayTimeLst,x
    273  039d		       f6 d7		      inc	decayIdxLst,x
    274  039f				   .contNote
    275  039f		       d6 d9		      dec	decayTimeLst,x
    276  03a1				   .nextSound
    277  03a1		       ca		      dex
    278  03a2		       10 ad		      bpl	.loopSound
    279  03a4		       60		      rts
    280  03a5				   .endSound
    281  03a5		       a9 00		      lda	#0	; THIS FIXES THE SOUNDS NOT 'STOPPING' -- A was NOT 0 as commented below :)
    282  03a7		       95 d5		      sta	soundIdxLst,x	; a = 0!
    283  03a9		       f0 f6		      beq	.nextSound
    284  03ab
    285  03ab
    286  03ab							;-----------------------------------------------------------
    287  03ab							; S O U N D - D A T A
    288  03ab							;-----------------------------------------------------------
    289  03ab
    290  03ab		       00 08	   DIST_NOISE =	$08
    291  03ab		       00 04	   DIST_DIV2  =	$04	; 15720..491 Hz
    292  03ab		       00 0c	   DIST_DIV6  =	$0c	;  5240..164 Hz
    293  03ab		       00 06	   DIST_DIV31 =	$06	;  1014.. 32 Hz
    294  03ab							;DIST_DIV93	  = $0e ; unused
    295  03ab
    296  03ab		       00 80	   LOOP_SOUND =	$80
    297  03ab
    298  03ab		       00 00	   OFS_DIST   =	0
    299  03ab		       00 01	   OFS_FREQ   =	1
    300  03ab		       00 02	   OFS_RND_FREQ =	2
    301  03ab		       00 03	   OFS_DECAY  =	3
    302  03ab
    303  03ab		       00 20	   MIN_SOUND_BONUS =	$20	;$08
    304  03ab		       01 00	   MAX_SOUND_BONUS =	$100	;$e8
    305  03ab		       00 07	   VOL_SOUND_BONUS =	$07
    306  03ab
    307  03ab							;Note: The ADSR values documented at www.elmerproductions.com/sp/peterb
    308  03ab							;  are sometimes not matching what I hear when playing the original
    309  03ab							;  Also be base volume is not documented, therefore I assume 15 here. If the
    310  03ab							;  result is too loud the decays have to be adjusted.
    311  03ab				   DecayTbl
    312  03ab		       00		      .byte.b	$00
    313  03ac				   DecayMove		; 24/12ms = 1/1
    314  03ac		       12 14 00 	      .byte.b	$12, $14, $00
    315  03af				   DecayExplosion		; 8/2400ms = 1/144
    316  03af		       15		      .byte.b	$15	;  1
    317  03b0							; Vol: 10, Len: 144
    318  03b0		       5a		      .byte.b	$5a	;  5
    319  03b1		       59		      .byte.b	$59	;  5
    320  03b2		       48		      .byte.b	$48	;  4
    321  03b3		       57		      .byte.b	$57	;  5
    322  03b4		       56		      .byte.b	$56	;  5
    323  03b5		       55		      .byte.b	$55	;  5
    324  03b6		       84		      .byte.b	$84	;  8
    325  03b7		       b3		      .byte.b	$b3	; 11
    326  03b8		       f2 62		      .byte.b	$f2, $62	; 21
    327  03ba		       f1		      .byte.b	$f1	;, $f1, $f1, $f1, $f1 ; 75   shortened!
    328  03bb		       00		      .byte.b	$00
    329  03bc				   DecayDiamondPickup		; 2/6ms??  != 1/30
    330  03bc				   DecayBOX
    331  03bc							; Vol: 10, Len: 30
    332  03bc		       1a		      .byte.b	$1a	;  1
    333  03bd		       19		      .byte.b	$19	;  1
    334  03be		       18		      .byte.b	$18	;  1
    335  03bf		       17		      .byte.b	$17	;  1
    336  03c0		       16		      .byte.b	$16	;  1
    337  03c1		       15		      .byte.b	$15	;  1
    338  03c2		       24		      .byte.b	$24	;  2
    339  03c3		       23		      .byte.b	$23	;  2
    340  03c4		       42		      .byte.b	$42	;  4
    341  03c5		       f1 11		      .byte.b	$f1, $11	; 16
    342  03c7		       00		      .byte.b	$00
    343  03c8				   DecayDiamondFalling		; 2/6+6ms??  != 1/30
    344  03c8		       13		      .byte.b	$13	;  1
    345  03c9							; Vol: 7, Len: 30
    346  03c9		       17		      .byte.b	$17	;  1
    347  03ca		       26		      .byte.b	$26	;  2
    348  03cb		       15		      .byte.b	$15	;  1
    349  03cc		       24		      .byte.b	$24	;  2
    350  03cd		       23		      .byte.b	$23	;  2
    351  03ce		       42		      .byte.b	$42	;  4
    352  03cf		       f1 31		      .byte.b	$f1, $31	; 18
    353  03d1		       00		      .byte.b	$00
    354  03d2				   DecayAmoeba		; 24/??ms
    355  03d2							;    .byte   $12, $13, $12, $00
    356  03d2		       11 12 13 00	      .byte.b	$11, $12, $13, $00
    357  03d6				   DecayMagic		;  2/12ms = 0/1
    358  03d6		       13 00		      .byte.b	$13, $00
    359  03d8				   DecayCrack		; 24/750ms = 2/45
    360  03d8		       15		      .byte.b	$15	;  1
    361  03d9							; Vol: 10, Len: 45
    362  03d9		       1a		      .byte.b	$1a	;  1
    363  03da		       29		      .byte.b	$29	;  2
    364  03db		       28		      .byte.b	$28	;  2
    365  03dc		       17		      .byte.b	$17	;  1
    366  03dd		       26		      .byte.b	$26	;  2
    367  03de		       15		      .byte.b	$15	;  1
    368  03df		       34		      .byte.b	$34	;  3
    369  03e0		       33		      .byte.b	$33	;  3
    370  03e1		       62		      .byte.b	$62	;  6
    371  03e2		       f1 91		      .byte.b	$f1, $91	; 24
    372  03e4		       00		      .byte.b	$00
    373  03e5							;DecayUncover:       ; 2/168/??ms = 0/10
    374  03e5							;    .byte   $1a		      ;  1
    375  03e5							;    .byte   $19		      ;  1
    376  03e5							;    .byte   $18		      ;  1
    377  03e5							;    .byte   $17		      ;  1
    378  03e5							;    .byte   $16		      ;  1
    379  03e5							;    .byte   $15		      ;  1
    380  03e5							;    .byte   $24		      ;  2
    381  03e5							;    .byte   $23		      ;  2
    382  03e5							;    .byte   $42		      ;  4
    383  03e5							;    .byte   $f1, $11		      ; 16
    384  03e5							;    .byte   $00
    385  03e5				   DecayTime		; 2/1500ms = 1/90
    386  03e5		       15		      .byte.b	$15	;  1
    387  03e6							; Vol: 10, Len: 90
    388  03e6		       3a		      .byte.b	$3a	;  3
    389  03e7		       39		      .byte.b	$39	;  3
    390  03e8		       38		      .byte.b	$38	;  3
    391  03e9		       37		      .byte.b	$37	;  3
    392  03ea		       36		      .byte.b	$36	;  3
    393  03eb		       35		      .byte.b	$35	;  3
    394  03ec		       54		      .byte.b	$54	;  5
    395  03ed		       73		      .byte.b	$73	;  7
    396  03ee		       d2		      .byte.b	$d2	; 13
    397  03ef		       f1 f1 f1 21	      .byte.b	$f1, $f1, $f1, $21	; 47
    398  03f3		       00		      .byte.b	$00
    399  03f4
    400  0400		       00 00 00 00*	      ALIGN	256
    401  0400
    402  0400							;Note: The exact NOISE base frequency is not working. Therefore I assume a base
    403  0400							; frequency of 2620 HZ (31440/6) after comparing the sounds with the original.
    404  0400				   SoundTbl
    405  0400		       00		      .byte.b	0
    406  0401		       00 00		      .byte.b	0, 0
    407  0403		       00		      .byte.b	0
    408  0403		       00 04	   OFSS_MOVE_BLANK =	. - SoundTbl
    409  0404		       08		      .byte.b	DIST_NOISE
    410  0405		       02 00		      .byte.b	2, 0	; ~873 Hz (vs. 827)
    411  0407		       01		      .byte.b	DecayMove-DecayTbl
    412  0407		       00 08	   OFSS_MOVE_SOIL =	. - SoundTbl
    413  0408		       08		      .byte.b	DIST_NOISE
    414  0409		       00 00		      .byte.b	0, 0	; ~2620 Hz (vs. 2576)
    415  040b		       01		      .byte.b	DecayMove-DecayTbl
    416  040c
    417  040c
    418  040c							;Sounds of group LO belong to channel 0. If a new sound is requested, this
    419  040c							; overwrites existing sounds:
    420  040c		       00 0c	   SOUND_GROUP_LO =	. - SoundTbl
    421  040c
    422  040c		       00 0c	   OFSS_BOX   =	. - SoundTbl
    423  040c		       08		      .byte.b	DIST_NOISE
    424  040d		       11 00		      .byte.b	17, 0	; ~146 Hz (vs. 143)
    425  040f		       11		      .byte.b	DecayBOX-DecayTbl
    426  040f		       00 10	   OFSS_DIAMOND_PICKUP =	. - SoundTbl
    427  0410		       0c		      .byte.b	DIST_DIV6
    428  0411		       10 00		      .byte.b	16, 0	; 308 Hz
    429  0413		       11		      .byte.b	DecayDiamondPickup-DecayTbl
    430  0413		       00 14	   OFSS_DIAMOND_FALLING =	. - SoundTbl
    431  0414		       04		      .byte.b	DIST_DIV2
    432  0415		       03 05		      .byte.b	3, 5	; 1965..3930 Hz
    433  0417		       1d		      .byte.b	DecayDiamondFalling-DecayTbl
    434  0417		       00 18	   OFSS_EXPLOSION =	. - SoundTbl
    435  0418		       08		      .byte.b	DIST_NOISE
    436  0419		       07 00		      .byte.b	7, 0	; ~328 Hz (vs. 315)
    437  041b		       04		      .byte.b	DecayExplosion-DecayTbl
    438  041b		       00 1c	   OFSS_BONUS_POINTS =	. - SoundTbl
    439  041c							; at the end of each level, the time is counted down 30s/frame,
    440  041c							; during that period, this sound it played
    441  041c							; it last for up to
    442  041c							; Note: the last 10s (= 20 frames) the timer sound is played
    443  041c		       0c		      .byte.b	DIST_DIV6
    444  041d		       00 00		      .byte.b	0, 0	; unused (vs. 3246..164)
    445  041f		       20		      .byte.b	MIN_SOUND_BONUS	; here the inital frequency divider is set!
    446  0420
    447  0420
    448  0420							;Sounds of group HI belong to channel 1. If a new sound is requested, this
    449  0420							; only overwrites existing sounds if it has higher priority (index).
    450  0420		       00 20	   SOUND_GROUP_HI =	. - SoundTbl
    451  0420
    452  0420				   SoundTblHi
    453  0420		       00 20	   OFFS_HI    =	. - SoundTbl
    454  0420
    455  0420		       00 20	   OFSS_MOVE_BLANK_HI =	. - SoundTbl
    456  0420		       08		      .byte.b	DIST_NOISE
    457  0421		       02 00		      .byte.b	2, 0	; ~873 Hz (vs. 827)
    458  0423		       01		      .byte.b	DecayMove-DecayTbl
    459  0423		       00 24	   OFSS_MOVE_SOIL_HI =	. - SoundTbl
    460  0424		       08		      .byte.b	DIST_NOISE
    461  0425		       00 00		      .byte.b	0, 0	; ~2620 Hz (vs. 2576)
    462  0427		       01		      .byte.b	DecayMove-DecayTbl
    463  0427		       00 28	   OFSS_AMOEBA =	. - SoundTbl
    464  0428		       86		      .byte.b	DIST_DIV31|LOOP_SOUND
    465  0429		       04 05		      .byte.b	4, 5	; 101..203 Hz
    466  042b		       27		      .byte.b	DecayAmoeba-DecayTbl
    467  042b		       00 2c	   OFSS_MAGIC_WALL =	. - SoundTbl
    468  042c		       84		      .byte.b	DIST_DIV2|LOOP_SOUND
    469  042d		       05 03		      .byte.b	5, 3	; 1965..2620 Hz
    470  042f		       2b		      .byte.b	DecayMagic-DecayTbl
    471  042f		       00 30	   OFSS_CRACK =	. - SoundTbl
    472  0430		       08		      .byte.b	DIST_NOISE
    473  0431		       03 00		      .byte.b	3, 0	; ~655 Hz (vs. 737)
    474  0433		       2d		      .byte.b	DecayCrack-DecayTbl
    475  0434							;OFSS_UNCOVER		 = . - SoundTbl
    476  0434							;    .byte   DIST_DIV2|LOOP_SOUND
    477  0434							;    .byte   4, 6    ; 1572..3930 Hz (vs. 1561..3543)
    478  0434							;    .byte   DecayUncover-DecayTbl
    479  0434		       00 34	   OFSS_TIME_9 =	. - SoundTbl
    480  0434		       0c		      .byte.b	DIST_DIV6
    481  0435		       0b 00		      .byte.b	11, 0	; 437 Hz (vs. 468)
    482  0437		       3a		      .byte.b	DecayTime-DecayTbl
    483  0437		       00 38	   OFSS_TIME_8 =	. - SoundTbl
    484  0438		       0c		      .byte.b	DIST_DIV6
    485  0439		       0a 00		      .byte.b	10, 0	; 476 Hz (vs. 484)
    486  043b		       3a		      .byte.b	DecayTime-DecayTbl
    487  043b		       00 3c	   OFSS_TIME_7 =	. - SoundTbl
    488  043c		       04		      .byte.b	DIST_DIV2
    489  043d		       1f 00		      .byte.b	31, 0	; 491 Hz (vs. 500)
    490  043f		       3a		      .byte.b	DecayTime-DecayTbl
    491  043f		       00 40	   OFSS_TIME_6 =	. - SoundTbl
    492  0440		       04		      .byte.b	DIST_DIV2
    493  0441		       1e 00		      .byte.b	30, 0	; 507 Hz (vs. 515)
    494  0443		       3a		      .byte.b	DecayTime-DecayTbl
    495  0443		       00 44	   OFSS_TIME_5 =	. - SoundTbl
    496  0444		       04		      .byte.b	DIST_DIV2
    497  0445		       1d 00		      .byte.b	29, 0	; 524 Hz (vs. 531)
    498  0447		       3a		      .byte.b	DecayTime-DecayTbl
    499  0447		       00 48	   OFSS_TIME_4 =	. - SoundTbl
    500  0448		       04		      .byte.b	DIST_DIV2
    501  0449		       1c 00		      .byte.b	28, 0	; 542 Hz (vs. 546)
    502  044b		       3a		      .byte.b	DecayTime-DecayTbl
    503  044b		       00 4c	   OFSS_TIME_3 =	. - SoundTbl
    504  044c		       04		      .byte.b	DIST_DIV2
    505  044d		       1b 00		      .byte.b	27, 0	; 561 Hz (vs. 562)
    506  044f		       3a		      .byte.b	DecayTime-DecayTbl
    507  044f		       00 50	   OFSS_TIME_2 =	. - SoundTbl
    508  0450		       04		      .byte.b	DIST_DIV2
    509  0451		       1a 00		      .byte.b	26, 0	; 582 Hz (vs. 578)
    510  0453		       3a		      .byte.b	DecayTime-DecayTbl
    511  0453		       00 54	   OFSS_TIME_1 =	. - SoundTbl
    512  0454		       04		      .byte.b	DIST_DIV2
    513  0455		       19 00		      .byte.b	25, 0	; 605 Hz (vs. 593)
    514  0457		       3a		      .byte.b	DecayTime-DecayTbl
    515  0457		       00 58	   OFSS_TIME_0 =	. - SoundTbl
    516  0458		       04		      .byte.b	DIST_DIV2
    517  0459		       18 00		      .byte.b	24, 0	; 629 Hz (vs. 609)
    518  045b		       3a		      .byte.b	DecayTime-DecayTbl
    519  045c
    520  045c
    521  045c							; special low priority:
    522  045c		       00 01	   SOUND_MOVE_BLANK =	OFSS_MOVE_BLANK / 4
    523  045c		       00 02	   SOUND_MOVE_SOIL =	OFSS_MOVE_SOIL / 4
    524  045c							; group lo:
    525  045c		       00 03	   SOUND_BOX  =	OFSS_BOX / 4
    526  045c		       00 06	   SOUND_EXPLOSION =	OFSS_EXPLOSION / 4
    527  045c		       00 04	   SOUND_DIAMOND_PICKUP =	OFSS_DIAMOND_PICKUP / 4
    528  045c		       00 05	   SOUND_DIAMOND_FALLING =	OFSS_DIAMOND_FALLING / 4
    529  045c		       00 07	   SOUND_BONUS_POINTS =	OFSS_BONUS_POINTS / 4
    530  045c							; group hi:
    531  045c
    532  045c		       00 30	   SOUND_AMOEBA =	(OFSS_AMOEBA - OFFS_HI) * 4 + $10
    533  045c		       00 40	   SOUND_MAGIC_WALL =	(OFSS_MAGIC_WALL - OFFS_HI) * 4 + $10
    534  045c		       00 50	   SOUND_CRACK =	(OFSS_CRACK - OFFS_HI) * 4 + $10
    535  045c		       00 60	   SOUND_TIME_9 =	(OFSS_TIME_9 - OFFS_HI) * 4 + $10
    536  045c		       00 70	   SOUND_TIME_8 =	(OFSS_TIME_8 - OFFS_HI) * 4 + $10
    537  045c		       00 80	   SOUND_TIME_7 =	(OFSS_TIME_7 - OFFS_HI) * 4 + $10
    538  045c		       00 90	   SOUND_TIME_6 =	(OFSS_TIME_6 - OFFS_HI) * 4 + $10
    539  045c		       00 a0	   SOUND_TIME_5 =	(OFSS_TIME_5 - OFFS_HI) * 4 + $10
    540  045c		       00 b0	   SOUND_TIME_4 =	(OFSS_TIME_4 - OFFS_HI) * 4 + $10
    541  045c		       00 c0	   SOUND_TIME_3 =	(OFSS_TIME_3 - OFFS_HI) * 4 + $10
    542  045c		       00 d0	   SOUND_TIME_2 =	(OFSS_TIME_2 - OFFS_HI) * 4 + $10
    543  045c		       00 e0	   SOUND_TIME_1 =	(OFSS_TIME_1 - OFFS_HI) * 4 + $10
    544  045c		       00 f0	   SOUND_TIME_0 =	(OFSS_TIME_0 - OFFS_HI) * 4 + $10
------- FILE BANK_MUSIC.asm
     65  045c
      0  045c					      CHECK_BANK_SIZE	"BANK_MUSIC1"
      1  045c		       04 5c	   .TEMP      =	* - BANK_START
 BANK_MUSIC1 (2K) SIZE =  $45c , FREE= $3a4
      2  045c					      ECHO	"BANK_MUSIC1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  045c				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  045c				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  045c				  -	      ERR
      6  045c					      endif
     67  045c
     68  045c							;------------------------------------------------------------------------------
     69  045c							;##############################################################################
     70  045c							;------------------------------------------------------------------------------
     71  045c
     72  045c
------- FILE ./sokoboo.asm
------- FILE BANK_TITLE.asm LEVEL 2 PASS 3
      0  045c					      include	"BANK_TITLE.asm"
      1  045c							; TODOs
      2  045c							; + update channel 1 each scanline
      3  045c							; + update channel 0 each scanline
      4  045c							; + convert both kernels to 2LK counters
      5  045c							; + split graphic data into odd and even lines
      6  045c							; + precalculate values
      7  045c							; + calculate inital values some scanlines ahead
      8  045c							; + update AUD0 during kernels
      9  045c							; + check carry flags! AGAIN!!!
     10  045c							; + DEBUG!!!
     11  045c							; + revert code to use ROM bank
     12  045c
     13  045c							; music ideas:
     14  045c							; + precalculate 1 channel (96 bytes RAM = 48 scanlines)
     15  045c							; + calculate other channel during kernel over two scanlines
     16  045c							; x use self-modifying code
     17  045c
     18  045c							; + sync music
     19  045c							; + share logo bank with other bank (copyright!)
     20  045c							; + set pointers
     21  045c							; + joystick input
     22  045c							;   + switch from logo to selection
     23  045c							;   + block 2 joystick row for 1 player
     24  045c							; x calculate cave*=4/5 (done somewhere else)
     25  045c
     26  045c							;------------------------------------------------------------------------------
     27  045c							;##############################################################################
     28  045c							;------------------------------------------------------------------------------
     29  045c
      0  045c					      NEWBANK	TITLE_BANK
      1  0ffe ????				      SEG	TITLE_BANK
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   TITLE_BANK SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	TITLE_BANK
     31  0800
     32  0800		       00 01	   PLAY_CH_0  =	YES	; play the very tricky, precalculated channel 0
     33  0800		       00 01	   PLAY_CH_1  =	YES	; play the on-the-fly calculated channel 1
     34  0800
     35  0800		       00 0e	   TWHITE     =	WHITE
     36  0800
     37  0800		       00 09	   NOTE_LEN_NTSC =	9	; was: 9 ; number of frames each note is played in total
     38  0800		       00 08	   NOTE_LEN_PAL =	NOTE_LEN_NTSC-1	; was: NOTE_LEN_NTSC-1 = 8
     39  0800		       00 02	   NOTE_OFF_LEN =	2	; number of silent frames between each note (>=1!)
     40  0800		       00 0c	   VOL_MASK   =	%1100
     41  0800
     42  0800							; number of precalculated values
     43  0800		       00 30	   PC_TOP     =	48	; calculated during vertical blank
     44  0800		       00 30	   PC_BTM     =	48	; calculated during overscan
     45  0800
     46  0800					      MAC	check_clc
     47  0800							;    bcs     . 		  ; 2/3       set carry causes endless loop
     48  0800					      ENDM
     49  0800
     50  0800					      MAC	update_music_data_lo
     51  0800					      CHECK_CLC
     52  0800							;    clc			  ; 2	      we always assume that carry is clear!
     53  0800					      lda	audv{1}Lo	; 3
     54  0800					      adc	note{1}	; 3
     55  0800					      sta	audv{1}Lo	; 3 =	9
     56  0800					      ENDM
     57  0800
     58  0800					      MAC	update_music_data_hi
     59  0800					      lda	audv{1}Hi	; 3
     60  0800					      adc	#0	; 2
     61  0800					      sta	audv{1}Hi	; 3 =	8
     62  0800					      ENDM
     63  0800
     64  0800					      MAC	update_music_data
     65  0800					      UPDATE_MUSIC_DATA_LO	{1}	; 9
     66  0800					      UPDATE_MUSIC_DATA_HI	{1}	; 8 = 17
     67  0800					      ENDM
     68  0800
     69  0800					      MAC	update_music_prep_vol
     70  0800					      and	#VOL_MASK/2	; 2	     optional, but sounds a tiny bit better if left in
     71  0800					      asl		; 2 =	4    carry clear now!
     72  0800					      ENDM
     73  0800
     74  0800					      MAC	update_music_set_vol
     75  0800					      IF	PLAY_CH_{1} == YES
     76  0800					      sta	AUDV{1}	; 3	     @07!    NOTE: this store must always occur on the same cycle
     77  0800					      ELSE
     78  0800					      nop	AUDV{1}	; 3 =	3
     79  0800					      ENDIF
     80  0800					      ENDM
     81  0800
     82  0800					      MAC	update_music_set_vol_w
     83  0800					      IF	PLAY_CH_{1} == YES
     84  0800					      sta.w	AUDV{1}	; 4	     @07!    NOTE: this store must always occur on the same cycle
     85  0800					      ELSE
     86  0800					      nop.w	AUDV{1}	; 4 =	4
     87  0800					      ENDIF
     88  0800					      ENDM
     89  0800
     90  0800					      MAC	update_music_vol
     91  0800					      UPDATE_MUSIC_PREP_VOL	{1}	; 4
     92  0800					      UPDATE_MUSIC_SET_VOL	{1}	; 3 =	7
     93  0800					      ENDM
     94  0800
     95  0800					      MAC	update_music
     96  0800					      UPDATE_MUSIC_DATA	{1}	;17
     97  0800					      UPDATE_MUSIC_VOL	{1}	; 7 = 24
     98  0800					      ENDM
     99  0800
    100  0800					      MAC	update_music_wsync
    101  0800					      UPDATE_MUSIC_DATA	{1}	;17
    102  0800					      sta	WSYNC	; 3
    103  0800							;---------------------------------------
    104  0800					      UPDATE_MUSIC_VOL	{1}	; 7 = 27
    105  0800					      ENDM
    106  0800
    107  0800
    108  0800		       00 0a	   NOT_SEL_COL =	$0a
    109  0800
    110  0800					      MAC	set_row_col
    111  0800					      ldx	Platform	; 3
    112  0800					      lda	selRow	; 3
    113  0800					      IF	{1} != 0
    114  0800					      eor	#{1}	; 2	     do NOT change carry!
    115  0800					      ENDIF
    116  0800					      beq	.isSel{1}	; 2/3
    117  0800					      lda	#NOT_SEL_COL	; 2
    118  0800					      bne	.notSel{1}	; 3
    119  0800
    120  0800				   .isSel{1}
    121  0800					      lda	SelectionColTbl,x	; 4
    122  0800				   .notSel{1}
    123  0800					      sta	COLUP0	; 3
    124  0800					      sta	COLUP1	; 3 = 21
    125  0800					      ENDM
    126  0800
    127  0800					      MAC	end_row
    128  0800					      sty	COLUP0	; 3
    129  0800					      sty	COLUP1	; 3
    130  0800					      SLEEP	3	; 3
    131  0800							;    nop     GRP0		      ; 3
    132  0800							;    nop     GRP1		      ; 3
    133  0800							;    nop     GRP0		      ; 3
    134  0800
    135  0800					      UPDATE_MUSIC_DATA_HI	1	; 8 = 17
    136  0800							;---------------------------------------
    137  0800					      UPDATE_MUSIC_VOL	1	; 7	     @07!    <-- AUDV1
    138  0800
    139  0800					      UPDATE_MUSIC_DATA_LO	1	; 9	     @16
    140  0800					      ENDM		;	     @59
    141  0800
    142  0800					      MAC	start_row
    143  0800					      ldy	#LKERNEL_H/8-1	; 2
    144  0800					      sty	loopCntSel	; 3
    145  0800					      lda	(ptrGfxA),y	; 5
    146  0800					      sta	tmpGfxA	; 3
    147  0800
    148  0800					      SET_ROW_COL	{1}	;21		     has to be late!
    149  0800
    150  0800					      jmp	EnterSelLoop{1}	; 3 = 16    @70
    151  0800					      ENDM		;	     @33
    152  0800
    153  0800					      MAC	set_digit_ptr
    154  0800					      ldy	selLst+{1}	; 3
    155  0800					      lda	SelDigitAPtr,y	; 4
    156  0800					      sta	ptrGfxA	; 3
    157  0800					      lda	SelDigitBPtr,y	; 4
    158  0800					      sta	ptrGfxB	; 3 = 14
    159  0800					      ENDM
    160  0800
    161  0800					      MAC	set_char_ptr
    162  0800					      lda	SelCharAPtr,y	; 4
    163  0800					      sta	ptrGfxA	; 3
    164  0800					      lda	SelCharBPtr,y	; 4
    165  0800					      sta	ptrGfxB	; 3 = 14
    166  0800					      ENDM
    167  0800
    168  0800					      MAC	draw_row
    169  0800
    170  0800					      IF	{1} != 0
    171  0800					      ALIGN_FREE	256
    172  0800					      ENDIF
    173  0800
    174  0800							;--------------------------------------------------------------------------
    175  0800							; Code is exquisitely timed so that each line takes
    176  0800							; *EXACTLY* 76 cycles.  Code cannot cross page-boundaries, as the branch
    177  0800							; would then take an extra cycle, and bugger the display.
    178  0800				   LoopSelGfx{1}		;	     @60
    179  0800					      ldx	SelGfxB0_{1}-1,y	; 4
    180  0800					      stx.w	GRP0	; 4
    181  0800
    182  0800					      UPDATE_MUSIC_DATA_HI	1	; 8 = 16    @76
    183  0800							;---------------------------------------
    184  0800					      UPDATE_MUSIC_VOL	1	; 7	     @07!    <-- AUDV1
    185  0800
    186  0800					      UPDATE_MUSIC_DATA_LO	1	; 9	     @16
    187  0800
    188  0800					      lda	SelGfxB1_{1}-1,y	; 4
    189  0800					      sta	GRP1	; 3
    190  0800					      lda	SelGfxB2_{1}-1,y	; 4
    191  0800					      sta	GRP0	; 4 = 14    @30
    192  0800
    193  0800					      lax	(ptrGfxB),y	; 5
    194  0800					      lda	SelGfxB3_{1}-1,y	; 4
    195  0800					      ldy	tmpGfxB	; 3 = 12
    196  0800
    197  0800					      sta	GRP1	; 3	     @45
    198  0800					      sty	GRP0	; 3	     @48
    199  0800					      stx	GRP1	; 3	     @51
    200  0800					      sta	GRP0	; 3 = 15    @54
    201  0800
    202  0800					      ldy	loopCntSel	; 3
    203  0800					      dey		; 2 =	5
    204  0800					      sty	loopCntSel	; 3
    205  0800					      lda	(ptrGfxA),y	; 5
    206  0800					      sta	tmpGfxA	; 3 = 11
    207  0800				   EnterSelLoop{1}		;	     @70
    208  0800					      lax	SelGfxB4_{1}-1,y	; 4
    209  0800							;---------------------------------------
    210  0800				   V_OFS      SET	(3-{1})*4	;		     calculate separately, else this gives wrong results!
    211  0800					      lda	audV0LstBtm+V_OFS,y	; 4
    212  0800					      and	#VOL_MASK	; 2
    213  0800					      UPDATE_MUSIC_SET_VOL	0	; 3 = 13    @07!    <-- AUDV0
    214  0800
    215  0800					      stx	tmpGfxB	; 3
    216  0800					      ldx	SelGfxA0_{1},y	; 4
    217  0800					      stx	GRP0	; 3
    218  0800					      lda	SelGfxA1_{1},y	; 4
    219  0800					      sta	GRP1	; 3
    220  0800					      lda	SelGfxA2_{1},y	; 4
    221  0800					      sta	GRP0	; 3 = 24
    222  0800							;	     @31
    223  0800					      lax	SelGfxA4_{1},y	; 4
    224  0800					      lda	SelGfxA3_{1},y	; 4
    225  0800					      ldy	tmpGfxA	; 3
    226  0800					      sta	GRP1	; 3 = 14    @45!
    227  0800					      stx	GRP0	; 3	     @48
    228  0800					      sty	GRP1	; 3	     @51
    229  0800					      sta	GRP0	; 3 =	9    @54!
    230  0800
    231  0800					      ldy	loopCntSel	; 3
    232  0800					      bne	LoopSelGfx{1}	; 2/3= 5/6  @59
    233  0800					      CHECKPAGE	LoopSelGfx{1}
    234  0800					      ENDM
    235  0800
    236  0800
    237  0800							;===============================================================================
    238  0800							; code starts here
    239  0800							;===============================================================================
    240  0800
    241  0800				   FREE       SET	0
    242  0800
    243  0800							;--------------------------------------------------------------------------
    244  0800
    245  0800				   SwitchToContTitleBank SUBROUTINE
    246  0800							; has to be at start of bank!
    247  0800		       a9 02		      lda	#BANK_ContTitle	; 2
    248  0802		       85 3f		      sta	SET_BANK	; 3
    249  0804		       4c f1 f1 	      jmp	NewFrameTitle	; 3 =	8
    250  0807
    251  0807				   SwitchToDrawLogoBank SUBROUTINE
    252  0807							; has to be at start of bank!
    253  0807		       a9 02		      lda	#BANK_DrawLogo	; 2
    254  0809		       85 3f		      sta	SET_BANK	; 3
    255  080b
    256  080b							; color tables for NTSC/PAL:
    257  080b				   BkColTbl
    258  080b		       00		      .byte.b	0	;$82
    259  080c		       00		      .byte.b	0	;$d2
    260  080d				   StarsColTbl
    261  080d		       00		      .byte.b	0	;$9a
    262  080e		       00		      .byte.b	0	;$da
    263  080f
    264  080f		       f0 0b	   TradeMarkA =	. - 4
    265  080f		       00 00 00 00*	      ds	28, 0	; bottom 7 bytes don't matter
    266  082b		       1c		      .byte.b	%00011100
    267  082c							;    .byte   %00100010
    268  082c		       22		      .byte.b	%00100010
    269  082d							;    .byte   %01010101
    270  082d		       55		      .byte.b	%01010101
    271  082e							;    .byte   %01011001
    272  082e		       55		      .byte.b	%01010101
    273  082f							;    .byte   %01011001
    274  082f		       22		      .byte.b	%00100010
    275  0830							;    .byte   %00100010
    276  0830		       1c		      .byte.b	%00011100
    277  0831		       00 00 00 00*	      ds	(TKERNEL_H-66-9-BORDER_H+1)/2, 0	;
    278  0831		       f0 37	   TradeMarkB =	. - 33
    279  0858							;    .byte   %00011100
    280  0858		       22		      .byte.b	%00100010
    281  0859							;    .byte   %00100010
    282  0859		       55		      .byte.b	%01010101
    283  085a							;    .byte   %01010101
    284  085a		       59		      .byte.b	%01011001
    285  085b							;    .byte   %01010101
    286  085b		       59		      .byte.b	%01011001
    287  085c							;    .byte   %00100010
    288  085c		       22		      .byte.b	%00100010
    289  085d							;    .byte   %00011100
    290  085d		       00 00 00 00*	      ds	(TKERNEL_H-66-9-BORDER_H+1)/2, 0	;
      0  0884					      CHECKPAGE	TradeMarkA
      8  0884					      LIST	ON
    292  0884
    293  0884							;-----------------------------------------------------------
    294  0884							; Table defining the height of each PF graphics block.
    295  0884							; Total number must be even!
    296  0884
    297  0884				   NextXTbl
    298  0884							; stop byte
    299  0884		       ff		      .byte.b	-1
    300  0885							; bottom border:
    301  0885					      REPEAT	BORDER_H/2
    302  0885		       00		      .byte.b	0
    301  0885					      REPEND
    302  0886		       00		      .byte.b	0
    301  0886					      REPEND
    302  0887		       00		      .byte.b	0
    301  0887					      REPEND
    302  0888		       00		      .byte.b	0
    303  0889					      REPEND
    304  0889					      REPEAT	GAP_H/2
    305  0889		       01		      .byte.b	1
    304  0889					      REPEND
    305  088a		       01		      .byte.b	1
    304  088a					      REPEND
    305  088b		       01		      .byte.b	1
    306  088c					      REPEND
    307  088c							; title graphics:
    308  088c				   X	      SET	2
    309  088c					      REPEAT	NUM_BLOCKS
    310  088c					      REPEAT	BLOCK_H/2
    311  088c		       02		      .byte.b	X
    310  088c					      REPEND
    311  088d		       02		      .byte.b	X
    312  088e					      REPEND
    313  088e				   X	      SET	X+1
    309  088e					      REPEND
    310  088e					      REPEAT	BLOCK_H/2
    311  088e		       03		      .byte.b	X
    310  088e					      REPEND
    311  088f		       03		      .byte.b	X
    312  0890					      REPEND
    313  0890				   X	      SET	X+1
    309  0890					      REPEND
    310  0890					      REPEAT	BLOCK_H/2
    311  0890		       04		      .byte.b	X
    310  0890					      REPEND
    311  0891		       04		      .byte.b	X
    312  0892					      REPEND
    313  0892				   X	      SET	X+1
    309  0892					      REPEND
    310  0892					      REPEAT	BLOCK_H/2
    311  0892		       05		      .byte.b	X
    310  0892					      REPEND
    311  0893		       05		      .byte.b	X
    312  0894					      REPEND
    313  0894				   X	      SET	X+1
    309  0894					      REPEND
    310  0894					      REPEAT	BLOCK_H/2
    311  0894		       06		      .byte.b	X
    310  0894					      REPEND
    311  0895		       06		      .byte.b	X
    312  0896					      REPEND
    313  0896				   X	      SET	X+1
    309  0896					      REPEND
    310  0896					      REPEAT	BLOCK_H/2
    311  0896		       07		      .byte.b	X
    310  0896					      REPEND
    311  0897		       07		      .byte.b	X
    312  0898					      REPEND
    313  0898				   X	      SET	X+1
    309  0898					      REPEND
    310  0898					      REPEAT	BLOCK_H/2
    311  0898		       08		      .byte.b	X
    310  0898					      REPEND
    311  0899		       08		      .byte.b	X
    312  089a					      REPEND
    313  089a				   X	      SET	X+1
    309  089a					      REPEND
    310  089a					      REPEAT	BLOCK_H/2
    311  089a		       09		      .byte.b	X
    310  089a					      REPEND
    311  089b		       09		      .byte.b	X
    312  089c					      REPEND
    313  089c				   X	      SET	X+1
    309  089c					      REPEND
    310  089c					      REPEAT	BLOCK_H/2
    311  089c		       0a		      .byte.b	X
    310  089c					      REPEND
    311  089d		       0a		      .byte.b	X
    312  089e					      REPEND
    313  089e				   X	      SET	X+1
    309  089e					      REPEND
    310  089e					      REPEAT	BLOCK_H/2
    311  089e		       0b		      .byte.b	X
    310  089e					      REPEND
    311  089f		       0b		      .byte.b	X
    312  08a0					      REPEND
    313  08a0				   X	      SET	X+1
    309  08a0					      REPEND
    310  08a0					      REPEAT	BLOCK_H/2
    311  08a0		       0c		      .byte.b	X
    310  08a0					      REPEND
    311  08a1		       0c		      .byte.b	X
    312  08a2					      REPEND
    313  08a2				   X	      SET	X+1
    309  08a2					      REPEND
    310  08a2					      REPEAT	BLOCK_H/2
    311  08a2		       0d		      .byte.b	X
    310  08a2					      REPEND
    311  08a3		       0d		      .byte.b	X
    312  08a4					      REPEND
    313  08a4				   X	      SET	X+1
    309  08a4					      REPEND
    310  08a4					      REPEAT	BLOCK_H/2
    311  08a4		       0e		      .byte.b	X
    310  08a4					      REPEND
    311  08a5		       0e		      .byte.b	X
    312  08a6					      REPEND
    313  08a6				   X	      SET	X+1
    309  08a6					      REPEND
    310  08a6					      REPEAT	BLOCK_H/2
    311  08a6		       0f		      .byte.b	X
    310  08a6					      REPEND
    311  08a7		       0f		      .byte.b	X
    312  08a8					      REPEND
    313  08a8				   X	      SET	X+1
    309  08a8					      REPEND
    310  08a8					      REPEAT	BLOCK_H/2
    311  08a8		       10		      .byte.b	X
    310  08a8					      REPEND
    311  08a9		       10		      .byte.b	X
    312  08aa					      REPEND
    313  08aa				   X	      SET	X+1
    309  08aa					      REPEND
    310  08aa					      REPEAT	BLOCK_H/2
    311  08aa		       11		      .byte.b	X
    310  08aa					      REPEND
    311  08ab		       11		      .byte.b	X
    312  08ac					      REPEND
    313  08ac				   X	      SET	X+1
    309  08ac					      REPEND
    310  08ac					      REPEAT	BLOCK_H/2
    311  08ac		       12		      .byte.b	X
    310  08ac					      REPEND
    311  08ad		       12		      .byte.b	X
    312  08ae					      REPEND
    313  08ae				   X	      SET	X+1
    309  08ae					      REPEND
    310  08ae					      REPEAT	BLOCK_H/2
    311  08ae		       13		      .byte.b	X
    310  08ae					      REPEND
    311  08af		       13		      .byte.b	X
    312  08b0					      REPEND
    313  08b0				   X	      SET	X+1
    309  08b0					      REPEND
    310  08b0					      REPEAT	BLOCK_H/2
    311  08b0		       14		      .byte.b	X
    310  08b0					      REPEND
    311  08b1		       14		      .byte.b	X
    312  08b2					      REPEND
    313  08b2				   X	      SET	X+1
    309  08b2					      REPEND
    310  08b2					      REPEAT	BLOCK_H/2
    311  08b2		       15		      .byte.b	X
    310  08b2					      REPEND
    311  08b3		       15		      .byte.b	X
    312  08b4					      REPEND
    313  08b4				   X	      SET	X+1
    309  08b4					      REPEND
    310  08b4					      REPEAT	BLOCK_H/2
    311  08b4		       16		      .byte.b	X
    310  08b4					      REPEND
    311  08b5		       16		      .byte.b	X
    312  08b6					      REPEND
    313  08b6				   X	      SET	X+1
    309  08b6					      REPEND
    310  08b6					      REPEAT	BLOCK_H/2
    311  08b6		       17		      .byte.b	X
    310  08b6					      REPEND
    311  08b7		       17		      .byte.b	X
    312  08b8					      REPEND
    313  08b8				   X	      SET	X+1
    309  08b8					      REPEND
    310  08b8					      REPEAT	BLOCK_H/2
    311  08b8		       18		      .byte.b	X
    310  08b8					      REPEND
    311  08b9		       18		      .byte.b	X
    312  08ba					      REPEND
    313  08ba				   X	      SET	X+1
    309  08ba					      REPEND
    310  08ba					      REPEAT	BLOCK_H/2
    311  08ba		       19		      .byte.b	X
    310  08ba					      REPEND
    311  08bb		       19		      .byte.b	X
    312  08bc					      REPEND
    313  08bc				   X	      SET	X+1
    309  08bc					      REPEND
    310  08bc					      REPEAT	BLOCK_H/2
    311  08bc		       1a		      .byte.b	X
    310  08bc					      REPEND
    311  08bd		       1a		      .byte.b	X
    312  08be					      REPEND
    313  08be				   X	      SET	X+1
    309  08be					      REPEND
    310  08be					      REPEAT	BLOCK_H/2
    311  08be		       1b		      .byte.b	X
    310  08be					      REPEND
    311  08bf		       1b		      .byte.b	X
    312  08c0					      REPEND
    313  08c0				   X	      SET	X+1
    309  08c0					      REPEND
    310  08c0					      REPEAT	BLOCK_H/2
    311  08c0		       1c		      .byte.b	X
    310  08c0					      REPEND
    311  08c1		       1c		      .byte.b	X
    312  08c2					      REPEND
    313  08c2				   X	      SET	X+1
    309  08c2					      REPEND
    310  08c2					      REPEAT	BLOCK_H/2
    311  08c2		       1d		      .byte.b	X
    310  08c2					      REPEND
    311  08c3		       1d		      .byte.b	X
    312  08c4					      REPEND
    313  08c4				   X	      SET	X+1
    309  08c4					      REPEND
    310  08c4					      REPEAT	BLOCK_H/2
    311  08c4		       1e		      .byte.b	X
    310  08c4					      REPEND
    311  08c5		       1e		      .byte.b	X
    312  08c6					      REPEND
    313  08c6				   X	      SET	X+1
    309  08c6					      REPEND
    310  08c6					      REPEAT	BLOCK_H/2
    311  08c6		       1f		      .byte.b	X
    310  08c6					      REPEND
    311  08c7		       1f		      .byte.b	X
    312  08c8					      REPEND
    313  08c8				   X	      SET	X+1
    309  08c8					      REPEND
    310  08c8					      REPEAT	BLOCK_H/2
    311  08c8		       20		      .byte.b	X
    310  08c8					      REPEND
    311  08c9		       20		      .byte.b	X
    312  08ca					      REPEND
    313  08ca				   X	      SET	X+1
    309  08ca					      REPEND
    310  08ca					      REPEAT	BLOCK_H/2
    311  08ca		       21		      .byte.b	X
    310  08ca					      REPEND
    311  08cb		       21		      .byte.b	X
    312  08cc					      REPEND
    313  08cc				   X	      SET	X+1
    309  08cc					      REPEND
    310  08cc					      REPEAT	BLOCK_H/2
    311  08cc		       22		      .byte.b	X
    310  08cc					      REPEND
    311  08cd		       22		      .byte.b	X
    312  08ce					      REPEND
    313  08ce				   X	      SET	X+1
    314  08ce					      REPEND
    315  08ce							; top border:
    316  08ce					      REPEAT	GAP_H/2
    317  08ce		       01		      .byte.b	1	; use symmetry
    316  08ce					      REPEND
    317  08cf		       01		      .byte.b	1	; use symmetry
    316  08cf					      REPEND
    317  08d0		       01		      .byte.b	1	; use symmetry
    318  08d1					      REPEND
    319  08d1				   X	      SET	X+1
    320  08d1					      REPEAT	BORDER_H/2
    321  08d1		       00		      .byte.b	0	; use symmetry
    320  08d1					      REPEND
    321  08d2		       00		      .byte.b	0	; use symmetry
    320  08d2					      REPEND
    321  08d3		       00		      .byte.b	0	; use symmetry
    320  08d3					      REPEND
    321  08d4		       00		      .byte.b	0	; use symmetry
    322  08d5					      REPEND
      0  08d5					      CHECKPAGE	NextXTbl
      8  08d5					      LIST	ON
    324  08d5
    325  08d5							;-----------------------------------------------------------
    326  08d5							; BOX DASH PF graphics data:
    327  08d5
    328  08d5				   title_STRIP_0
    329  08d5		       00 00 00 00*	      ds	35,0
      0  08f8					      CHECKPAGE	title_STRIP_0
      8  08f8					      LIST	ON
    331  08f8
      0  08f8					      ALIGN_FREE	256
      1  08f8				   FREE       SET	FREE - .
      2  0900		       00 00 00 00*	      align	256
      3  0900				   FREE       SET	FREE + .
 @ $f100 : $8
      4  0900					      echo	"@", ., ":", FREE
    333  0900
    334  0900				   title_STRIP_1
    335  0900		       00 00 00 00*	      ds	35,0
      0  0923					      CHECKPAGE	title_STRIP_1
      8  0923					      LIST	ON
    337  0923
    338  0923				   title_STRIP_2
    339  0923		       00 00 00 00*	      ds	35,0
      0  0946					      CHECKPAGE	title_STRIP_2
      8  0946					      LIST	ON
    341  0946
    342  0946				   title_STRIP_3
    343  0946		       00 00 00 00*	      ds	35,0
      0  0969					      CHECKPAGE	title_STRIP_3
      8  0969					      LIST	ON
    345  0969
    346  0969				   title_STRIP_4
    347  0969		       00 00 00 00*	      ds	35,0
      0  098c					      CHECKPAGE	title_STRIP_4
      8  098c					      LIST	ON
    349  098c
    350  098c				   title_STRIP_5
    351  098c		       00 00 00 00*	      ds	35,0
      0  09af					      CHECKPAGE	title_STRIP_5
      8  09af					      LIST	ON
    353  09af
    354  09af							;    ALIGN_FREE 256
    355  09af
    356  09af							;    ds  $1d, 0
    357  09af							; kernel alignment
    358  09af							;    ds  11, 0
    359  09af							;------------------------------------------------------------------------------
    360  09af
      0  09af					      DEFINE_SUBROUTINE	TitleScreen
      1  09af		       00 01	   BANK_TitleScreen =	_CURRENT_BANK
      2  09af					      SUBROUTINE
      3  09af				   TitleScreen
    362  09af
    363  09af							; clear TIA:
    364  09af		       a9 00		      lda	#0
    365  09b1		       a2 2c		      ldx	#CXCLR-TIA_BASE_ADDRESS
    366  09b3				   .loopClearTIA
    367  09b3		       95 40		      sta	TIA_BASE_ADDRESS,x
    368  09b5		       ca		      dex
    369  09b6		       10 fb		      bpl	.loopClearTIA
    370  09b8
    371  09b8							; clear title RAM to avoid initial sound disturbances
    372  09b8		       a2 7d		      ldx	#endOfTitleRAM-startOfTitleRAM
    373  09ba				   .loopClearRAM
    374  09ba		       ca		      dex
    375  09bb		       95 82		      sta	startOfTitleRAM,x
    376  09bd		       d0 fb		      bne	.loopClearRAM
    377  09bf
    378  09bf		       e6 8a		      inc	noteLen	; 5	     == 1
    379  09c1		       e6 86		      inc	titleMode
    380  09c3
    381  09c3		       a9 01		      lda	#BANK_TitleScreen
    382  09c5		       85 c3		      sta	ROM_Bank
    383  09c7
    384  09c7		       a9 f6		      lda	#>CharGfx
    385  09c9		       85 9a		      sta	ptrGfxA+1
    386  09cb		       85 9c		      sta	ptrGfxB+1
    387  09cd
    388  09cd		       20 d5 f7 	      jsr	DetectConsole
    389  09d0
    390  09d0							; special resync required here, since PAL-60 is not supported:
    391  09d0							;    RESYNC			      ; 		  -> X, Y == 0
    392  09d0
    393  09d0							; resync screen, X and Y == 0 afterwards
    394  09d0							;	  lda #%10			  ; make sure VBLANK is ON
    395  09d0		       85 41		      sta	VBLANK
    396  09d2
    397  09d2		       a2 08		      ldx	#8	; 5 or more RESYNC_FRAMES
    398  09d4				   .loopResync
      0  09d4					      VERTICAL_SYNC
      1  09d4		       a9 0e		      lda	#%1110
      2  09d6		       85 42	   .VSLP1     sta	WSYNC
      3  09d8		       85 40		      sta	VSYNC
      4  09da		       4a		      lsr
      5  09db		       d0 f9		      bne	.VSLP1
    400  09dd
    401  09dd		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
    402  09df		       a5 81		      lda	Platform
    403  09e1		       29 02		      and	#PAL	; only test for PAL (carry unharmed!)
    404  09e3		       f0 02		      beq	.ntsc
    405  09e5		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
    406  09e7				   .ntsc
    407  09e7				   .loopWait
    408  09e7		       85 42		      sta	WSYNC
    409  09e9		       85 42		      sta	WSYNC
    410  09eb		       88		      dey
    411  09ec		       d0 f9		      bne	.loopWait
    412  09ee		       ca		      dex
    413  09ef		       d0 e3		      bne	.loopResync
    414  09f1
    415  09f1
    416  09f1							;    clc			      ; 		 can be removed after debugging
    417  09f1
    418  09f1				   NewFrameTitle SUBROUTINE
    419  09f1
    420  09f1							; start of vertical sync processing:
    421  09f1				   VerticalSync
    422  09f1							; Y = 00!
    423  09f1							;---------------------------------------
    424  09f1				   TEST1
    425  09f1							;    jsr     UpdateMusicWSync1       ;39	  @13
      0  09f1					      UPDATE_MUSIC_WSYNC	1	;27	     @07
      0  09f1					      UPDATE_MUSIC_DATA	1
      0  09f1					      UPDATE_MUSIC_DATA_LO	1
      0  09f1					      CHECK_CLC
      1  09f1
      2  09f1
      3  09f1		       a5 92		      lda	audv1Lo
      4  09f3		       65 8d		      adc	note1
      5  09f5		       85 92		      sta	audv1Lo
      0  09f7					      UPDATE_MUSIC_DATA_HI	1
      1  09f7		       a5 93		      lda	audv1Hi
      2  09f9		       69 00		      adc	#0
      3  09fb		       85 93		      sta	audv1Hi
      2  09fd		       85 42		      sta	WSYNC
      3  09ff
      0  09ff					      UPDATE_MUSIC_VOL	1
      0  09ff					      UPDATE_MUSIC_PREP_VOL	1
      1  09ff		       29 06		      and	#VOL_MASK/2
      2  0a01		       0a		      asl
      0  0a02					      UPDATE_MUSIC_SET_VOL	1
      1  0a02					      IF	PLAY_CH_1 == YES
      2  0a02		       85 5a		      sta	AUDV1
      3  0a04				  -	      ELSE
      4  0a04				  -	      nop	AUDV1
      5  0a04					      ENDIF
    427  0a04		       a9 72		      lda	#$72	; 2		     this value is important for the stars effect
    428  0a06		       85 63		      sta	HMM1	; 3
    429  0a08		       85 40		      sta	VSYNC	; 3 =	8	     enable VSYNC
    430  0a0a							; put into here, just because we have time:
    431  0a0a		       a9 0e		      lda	#TWHITE	; 2
    432  0a0c		       85 48		      sta	COLUPF	; 3
    433  0a0e		       85 46		      sta	COLUP0	; 3 =	8
    434  0a10
    435  0a10							; prepare data for 1st screen row:
    436  0a10		       a5 86		      lda	titleMode	; 3
    437  0a12		       f0 06		      beq	.selMode	; 2/3
    438  0a14							; for logo screen:
    439  0a14		       a2 90		      ldx	#$90	; 2
    440  0a16		       86 60		      stx	HMP0	; 3
    441  0a18		       d0 05		      bne	.setHMP0	; 3
    442  0a1a
    443  0a1a							; for selection screen:
    444  0a1a				   .selMode		; 6
    445  0a1a		       a6 89		      ldx	hmJunior	; 3		     $f0/$50
    446  0a1c		       86 61		      stx	HMP1	; 3
    447  0a1e		       ca		      dex		; 2
    448  0a1f				   .setHMP0
    449  0a1f		       86 60		      stx	HMP0	; 3 = 16
    450  0a21
    451  0a21							;    ldy     #0
    452  0a21		       2c 82 02 	      bit	SWCHB	; 4
    453  0a24				  -	      IF	NTSC_MODE = YES
    454  0a24				  -	      bpl	.primaryPlatform	; 2/3
    455  0a24					      ELSE
    456  0a24		       30 01		      bmi	.primaryPlatform	; 2/3
    457  0a26					      ENDIF
    458  0a26		       c8		      iny		; 2
    459  0a27				   .primaryPlatform
    460  0a27		       84 81		      sty	Platform	; 3 = 11    @47     P1 difficulty --> TV system (0=NTSC, 1=PAL)
    461  0a29
    462  0a29		       c6 8a		      dec	noteLen	; 5		     update frame counter
    463  0a2b							; free: 1
    464  0a2b							;---------------------------------------
    465  0a2b							;    jsr     UpdateMusicWSync0       ;39	  @13
      0  0a2b					      UPDATE_MUSIC_WSYNC	0	;27
      0  0a2b					      UPDATE_MUSIC_DATA	0
      0  0a2b					      UPDATE_MUSIC_DATA_LO	0
      0  0a2b					      CHECK_CLC
      1  0a2b
      2  0a2b
      3  0a2b		       a5 90		      lda	audv0Lo
      4  0a2d		       65 8c		      adc	note0
      5  0a2f		       85 90		      sta	audv0Lo
      0  0a31					      UPDATE_MUSIC_DATA_HI	0
      1  0a31		       a5 91		      lda	audv0Hi
      2  0a33		       69 00		      adc	#0
      3  0a35		       85 91		      sta	audv0Hi
      2  0a37		       85 42		      sta	WSYNC
      3  0a39
      0  0a39					      UPDATE_MUSIC_VOL	0
      0  0a39					      UPDATE_MUSIC_PREP_VOL	0
      1  0a39		       29 06		      and	#VOL_MASK/2
      2  0a3b		       0a		      asl
      0  0a3c					      UPDATE_MUSIC_SET_VOL	0
      1  0a3c					      IF	PLAY_CH_0 == YES
      2  0a3c		       85 59		      sta	AUDV0
      3  0a3e				  -	      ELSE
      4  0a3e				  -	      nop	AUDV0
      5  0a3e					      ENDIF
    467  0a3e
    468  0a3e							; prepare data for 1st screen row:
    469  0a3e		       a6 86		      ldx	titleMode	; 3
    470  0a40		       f0 05		      beq	.selMode2	; 2/3
    471  0a42					      IF	DEMO_VERSION = NO
    472  0a42		       ca		      dex
    473  0a43				  -	      ELSE
    474  0a43				  -	      nop		;		     start with 2nd row in demo version because cave cannot be changed anyway
    475  0a43					      ENDIF
    476  0a43		       86 9d		      stx	selRow	; 3
    477  0a45		       10 19		      bpl	.skipJoyX
    478  0a47
    479  0a47				   .selMode2
    480  0a47
    481  0a47		       a5 8a		      lda	noteLen	; 3
    482  0a49		       d0 15		      bne	.skipJoyX	; 2/3= 5
    483  0a4b
    484  0a4b		       a4 9d		      ldy	selRow	; 3
    485  0a4d		       b6 82		      ldx	selLst,y	; 4 =	7
    486  0a4f
    487  0a4f		       ad 80 02 	      lda	SWCHA	; 4
    488  0a52		       0a		      asl		; 2
    489  0a53		       b0 03		      bcs	.notRight	; 2/3
    490  0a55		       e8		      inx		; 2
    491  0a56		       10 06		      bpl	.setJoyX	; 3
    492  0a58
    493  0a58				   .notRight		; 9
    494  0a58		       18		      clc		; 2
    495  0a59		       30 03		      bmi	.notLeft	; 2/3
    496  0a5b		       ca		      dex		; 2
    497  0a5c		       30 02		      bmi	.skipJoyX	; 2/3
    498  0a5e				   .notLeft
    499  0a5e				   .setJoyX
    500  0a5e		       96 82		      stx	selLst,y	; 4
    501  0a60				   .skipJoyX		;   = 21 max
    502  0a60		       a0 00		      ldy	#0	; 2
    503  0a62							;---------------------------------------
    504  0a62		       20 1a f4 	      jsr	UpdateMusicWSync1	;39	     @13
    505  0a65
    506  0a65							; limit selection values:
    507  0a65
    508  0a65				  -	      IF	FINAL_VERSION = YES
    509  0a65				  -			; limit cave:
    510  0a65				  -	      lda	sLevel	; 3
    511  0a65				  -	      cmp	#3	; 2		     above level 3 only cave A is allowed
    512  0a65				  -	      bcc	.lowLevel	; 2/3
    513  0a65				  -	      sty	sCave	; 3 = 10
    514  0a65				  -.lowLevel
    515  0a65					      ENDIF
    516  0a65
    517  0a65							; limit joysticks:
    518  0a65		       a5 84		      lda	sPlayers	; 3
    519  0a67		       d0 02		      bne	.twoPlayers	; 2/3
    520  0a69		       84 85		      sty	sJoysticks	; 3 =	8
    521  0a6b
    522  0a6b							; limit current selection:
    523  0a6b				   .twoPlayers
    524  0a6b		       a6 9d		      ldx	selRow	; 3
    525  0a6d		       bd cf f7 	      lda	SelMaxTbl,x	; 4
    526  0a70		       d5 82		      cmp	selLst,x	; 3
    527  0a72		       b0 02		      bcs	.selOk	; 2/3
    528  0a74		       95 82		      sta	selLst,x	; 4
    529  0a76				   .selOk
    530  0a76		       18		      clc		; 2 = 18
    531  0a77							; free: 1
    532  0a77							;---------------------------------------
    533  0a77		       20 06 f4 	      jsr	UpdateMusicWSync0	;39	     @13
    534  0a7a		       84 40		      sty	VSYNC	; 3	     @16     disable VSYNC
    535  0a7c
      0  0a7c					      UPDATE_MUSIC_DATA_LO	0	; 9
      0  0a7c					      CHECK_CLC
      1  0a7c
      2  0a7c
      3  0a7c		       a5 90		      lda	audv0Lo
      4  0a7e		       65 8c		      adc	note0
      5  0a80		       85 90		      sta	audv0Lo
    537  0a82		       08		      php		; 3 = 12    @28
    538  0a83							;    clc			      ; 2 = 14	  @30
    539  0a83
    540  0a83		       e6 87		      inc	counter	; 5
    541  0a85		       a5 87		      lda	counter	; 3
    542  0a87		       29 38		      and	#%111000	; 2
    543  0a89		       4a		      lsr		; 2
    544  0a8a		       4a		      lsr		; 2
    545  0a8b		       4a		      lsr		; 2
    546  0a8c		       aa		      tax		; 2 = 18    @48
    547  0a8d							; free: 4
    548  0a8d							;---------------------------------------
    549  0a8d		       20 1a f4 	      jsr	UpdateMusicWSync1	;39	     @13
    550  0a90				   .r2
    551  0a90		       ca		      dex		; 2
    552  0a91		       10 fd		      bpl	.r2	; 2/3
    553  0a93		       85 53		      sta	RESM1	; 3	     @20..55
    554  0a95
    555  0a95		       28		      plp		; 4
      0  0a96					      UPDATE_MUSIC_DATA_HI	0	; 8
      1  0a96		       a5 91		      lda	audv0Hi
      2  0a98		       69 00		      adc	#0
      3  0a9a		       85 91		      sta	audv0Hi
      0  0a9c					      UPDATE_MUSIC_PREP_VOL	0	; 4
      1  0a9c		       29 06		      and	#VOL_MASK/2
      2  0a9e		       0a		      asl
    558  0a9f							; free: 2
    559  0a9f		       85 42		      sta	WSYNC	; 3
    560  0aa1							;---------------------------------------
    561  0aa1		       85 6a		      sta	HMOVE	; 3
      0  0aa3					      UPDATE_MUSIC_SET_VOL_W	0	; 7	     @07!    <-- AUDV0
      1  0aa3					      IF	PLAY_CH_0 == YES
      2  0aa3		       8d 59 00 	      sta.w	AUDV0
      3  0aa6				  -	      ELSE
      4  0aa6				  -	      nop.w	AUDV0
      5  0aa6					      ENDIF
    563  0aa6		       20 2d f4 	      jsr	Wait12	;12		     waste 18 cycles and load move value
    564  0aa9		       88		      dey		; 2
    565  0aaa		       84 63		      sty	HMM1	; 3	     @27     this is the tricky part
    566  0aac
    567  0aac							;-----------------------------------------------------------
    568  0aac
    569  0aac					      IF	L276
    570  0aac		       a0 07		      ldy	#(38-PC_TOP/2)/2	; 2
    571  0aae				  -	      ELSE
    572  0aae				  -	      ldy	#(32-PC_TOP/2)/2	; 2
    573  0aae					      ENDIF
    574  0aae		       a5 81		      lda	Platform	; 3
    575  0ab0		       f0 02		      beq	.vSyncNTSC	; 2/3
    576  0ab2		       a0 16		      ldy	#(68-PC_TOP/2)/2	; 2 = 11
    577  0ab4				   .vSyncNTSC		;	     @38
    578  0ab4		       84 96		      sty	tmpY	; 3
    579  0ab6
    580  0ab6		       a4 cf		      ldy	audV0Lst+PC_TOP	; 3		     take the last precalculated hi value
    581  0ab8							; here we precalculate another 48 values
    582  0ab8		       a2 2f		      ldx	#PC_TOP-1	; 2 =	8
    583  0aba							; free: 10
    584  0aba				   .loopVSync		;	     @46
    585  0aba							;---------------------------------------
      0  0aba					      UPDATE_MUSIC_WSYNC	1	;27	     @07     maintain sound while precalcuating
      0  0aba					      UPDATE_MUSIC_DATA	1
      0  0aba					      UPDATE_MUSIC_DATA_LO	1
      0  0aba					      CHECK_CLC
      1  0aba
      2  0aba
      3  0aba		       a5 92		      lda	audv1Lo
      4  0abc		       65 8d		      adc	note1
      5  0abe		       85 92		      sta	audv1Lo
      0  0ac0					      UPDATE_MUSIC_DATA_HI	1
      1  0ac0		       a5 93		      lda	audv1Hi
      2  0ac2		       69 00		      adc	#0
      3  0ac4		       85 93		      sta	audv1Hi
      2  0ac6		       85 42		      sta	WSYNC
      3  0ac8
      0  0ac8					      UPDATE_MUSIC_VOL	1
      0  0ac8					      UPDATE_MUSIC_PREP_VOL	1
      1  0ac8		       29 06		      and	#VOL_MASK/2
      2  0aca		       0a		      asl
      0  0acb					      UPDATE_MUSIC_SET_VOL	1
      1  0acb					      IF	PLAY_CH_1 == YES
      2  0acb		       85 5a		      sta	AUDV1
      3  0acd				  -	      ELSE
      4  0acd				  -	      nop	AUDV1
      5  0acd					      ENDIF
    587  0acd							; 1st calculation:
      0  0acd					      CHECK_CLC
      1  0acd
    589  0acd		       a5 9e		      lda	audvTmpLo	; 3
    590  0acf		       65 8c		      adc	note0	; 3 =	6
    591  0ad1		       90 03		      bcc	.skipHi1	; 2/3
    592  0ad3		       c8		      iny		; 2
    593  0ad4		       c8		      iny		; 2
    594  0ad5		       18		      clc		; 2
    595  0ad6				   .skipHi1
    596  0ad6		       94 9f		      sty	audV0Lst,x	; 4
    597  0ad8		       ca		      dex		; 2 = 14
    598  0ad9							; 2nd calculation:
      0  0ad9					      CHECK_CLC
      1  0ad9
    600  0ad9		       65 8c		      adc	note0	; 3
    601  0adb		       85 9e		      sta	audvTmpLo	; 3 =	6
    602  0add		       90 03		      bcc	.skipHi2	; 2/3
    603  0adf		       c8		      iny		; 2
    604  0ae0		       c8		      iny		; 2
    605  0ae1		       18		      clc		; 2
    606  0ae2				   .skipHi2
    607  0ae2		       94 9f		      sty	audV0Lst,x	; 4
    608  0ae4		       ca		      dex		; 2 = 14
    609  0ae5							;	     @47 max
    610  0ae5							;---------------------------------------
      0  0ae5					      UPDATE_MUSIC_WSYNC	0	;27	     @07     maintain sound while precalcuating
      0  0ae5					      UPDATE_MUSIC_DATA	0
      0  0ae5					      UPDATE_MUSIC_DATA_LO	0
      0  0ae5					      CHECK_CLC
      1  0ae5
      2  0ae5
      3  0ae5		       a5 90		      lda	audv0Lo
      4  0ae7		       65 8c		      adc	note0
      5  0ae9		       85 90		      sta	audv0Lo
      0  0aeb					      UPDATE_MUSIC_DATA_HI	0
      1  0aeb		       a5 91		      lda	audv0Hi
      2  0aed		       69 00		      adc	#0
      3  0aef		       85 91		      sta	audv0Hi
      2  0af1		       85 42		      sta	WSYNC
      3  0af3
      0  0af3					      UPDATE_MUSIC_VOL	0
      0  0af3					      UPDATE_MUSIC_PREP_VOL	0
      1  0af3		       29 06		      and	#VOL_MASK/2
      2  0af5		       0a		      asl
      0  0af6					      UPDATE_MUSIC_SET_VOL	0
      1  0af6					      IF	PLAY_CH_0 == YES
      2  0af6		       85 59		      sta	AUDV0
      3  0af8				  -	      ELSE
      4  0af8				  -	      nop	AUDV0
      5  0af8					      ENDIF
    612  0af8							; 3rd calculation:
      0  0af8					      CHECK_CLC
      1  0af8
    614  0af8		       a5 9e		      lda	audvTmpLo	; 3
    615  0afa		       65 8c		      adc	note0	; 3 =	6
    616  0afc		       90 03		      bcc	.skipHi3	; 2/3
    617  0afe		       c8		      iny		; 2
    618  0aff		       c8		      iny		; 2
    619  0b00		       18		      clc		; 2
    620  0b01				   .skipHi3
    621  0b01		       94 9f		      sty	audV0Lst,x	; 4
    622  0b03		       ca		      dex		; 2 = 14
    623  0b04							; 4th calculation:
      0  0b04					      CHECK_CLC
      1  0b04
    625  0b04		       65 8c		      adc	note0	; 3
    626  0b06		       85 9e		      sta	audvTmpLo	; 3 =	6
    627  0b08		       90 03		      bcc	.skipHi4	; 2/3
    628  0b0a		       c8		      iny		; 2
    629  0b0b		       c8		      iny		; 2
    630  0b0c		       18		      clc		; 2
    631  0b0d				   .skipHi4
    632  0b0d		       94 9f		      sty	audV0Lst,x	; 4
    633  0b0f		       ca		      dex		; 2 = 14
    634  0b10		       10 a8		      bpl	.loopVSync	; 2/3
    635  0b12							;	     @49 max
    636  0b12		       a6 96		      ldx	tmpY	; 3
    637  0b14							; do the remaining scanlines (required for PAL)
    638  0b14				   .waitVSync
    639  0b14							;---------------------------------------
      0  0b14					      UPDATE_MUSIC_WSYNC	1	;27	     @07
      0  0b14					      UPDATE_MUSIC_DATA	1
      0  0b14					      UPDATE_MUSIC_DATA_LO	1
      0  0b14					      CHECK_CLC
      1  0b14
      2  0b14
      3  0b14		       a5 92		      lda	audv1Lo
      4  0b16		       65 8d		      adc	note1
      5  0b18		       85 92		      sta	audv1Lo
      0  0b1a					      UPDATE_MUSIC_DATA_HI	1
      1  0b1a		       a5 93		      lda	audv1Hi
      2  0b1c		       69 00		      adc	#0
      3  0b1e		       85 93		      sta	audv1Hi
      2  0b20		       85 42		      sta	WSYNC
      3  0b22
      0  0b22					      UPDATE_MUSIC_VOL	1
      0  0b22					      UPDATE_MUSIC_PREP_VOL	1
      1  0b22		       29 06		      and	#VOL_MASK/2
      2  0b24		       0a		      asl
      0  0b25					      UPDATE_MUSIC_SET_VOL	1
      1  0b25					      IF	PLAY_CH_1 == YES
      2  0b25		       85 5a		      sta	AUDV1
      3  0b27				  -	      ELSE
      4  0b27				  -	      nop	AUDV1
      5  0b27					      ENDIF
    641  0b27
    642  0b27		       e0 01		      cpx	#1
    643  0b29		       18		      clc
    644  0b2a		       f0 0e		      beq	.lastLoop
    645  0b2c
    646  0b2c		       a4 82		      ldy	sCave
    647  0b2e		       b9 9d f7 	      lda	SelCharAPtr,y	; 4
    648  0b31		       85 99		      sta	ptrGfxA	; 3
    649  0b33		       b9 b1 f7 	      lda	SelCharBPtr,y	; 4
    650  0b36		       85 9b		      sta	ptrGfxB	; 3
    651  0b38		       90 1c		      bcc	.endLoop	; 3 = 17
    652  0b3a
    653  0b3a				   .lastLoop
    654  0b3a		       a0 03		      ldy	#LKERNEL_H/8-1	; 2
    655  0b3c		       84 98		      sty	loopCntSel	; 3
    656  0b3e		       b1 99		      lda	(ptrGfxA),y	; 5
    657  0b40		       85 96		      sta	tmpGfxA	; 3 = 13
    658  0b42
    659  0b42		       a4 81		      ldy	Platform	; 3
    660  0b44		       b9 0b f0 	      lda	BkColTbl,y	; 4
    661  0b47		       85 49		      sta	COLUBK	; 3 = 10
    662  0b49
    663  0b49							; prepare data for 1st selection screen row:
    664  0b49		       a5 9d		      lda	selRow	; 3
    665  0b4b		       f0 04		      beq	.isSel	; 2/3
    666  0b4d		       a9 0a		      lda	#NOT_SEL_COL	; 2
    667  0b4f		       d0 03		      bne	.notSel	; 3
    668  0b51
    669  0b51				   .isSel
    670  0b51		       b9 fc f6 	      lda	SelectionColTbl,y	; 4
    671  0b54				   .notSel
    672  0b54		       85 97		      sta	tmpGfxB	; 3 = 13
    673  0b56				   .endLoop
    674  0b56							;---------------------------------------
    675  0b56		       20 06 f4 	      jsr	UpdateMusicWSync0	;39	     @13
    676  0b59		       ca		      dex		; 2
    677  0b5a		       d0 b8		      bne	.waitVSync	; 2/3
    678  0b5c
    679  0b5c							;------------------------------------------------------------------------------
    680  0b5c							; START OF DISPLAY
    681  0b5c							;				     ;		 @17
    682  0b5c		       b9 0d f0 	      lda	StarsColTbl,y	; 4		     Y is still set from above!
    683  0b5f		       85 47		      sta	COLUP1	; 3 =	7    @24
    684  0b61
    685  0b61		       a2 00		      ldx	#0	; 2	     also used for kernel!
    686  0b63		       86 65		      stx	VDELP0	; 3
    687  0b65		       86 44		      stx	NUSIZ0	; 3 =	8    @32
    688  0b67
    689  0b67		       a9 15		      lda	#%10101	; 2	     double width missile, double width player
    690  0b69		       85 45		      sta	NUSIZ1	; 3
    691  0b6b		       4a		      lsr		; 2	     bit 1 is set, turn missile0 on
    692  0b6c		       85 5e		      sta	ENAM1	; 3
    693  0b6e		       0a		      asl		; 2
    694  0b6f		       85 4a		      sta	CTRLPF	; 3 = 15    @47     = %00010100
    695  0b71
    696  0b71		       a0 50		      ldy	#TKERNEL_H/2	; 2	     total number of scanlines to display (160, was 149)
    697  0b73
      0  0b73					      UPDATE_MUSIC_DATA_LO	1	; 9
      0  0b73					      CHECK_CLC
      1  0b73
      2  0b73
      3  0b73		       a5 92		      lda	audv1Lo
      4  0b75		       65 8d		      adc	note1
      5  0b77		       85 92		      sta	audv1Lo
    699  0b79
    700  0b79		       85 50		      sta	RESP0	; 3	     @61
    701  0b7b
      0  0b7b					      UPDATE_MUSIC_DATA_HI	1	; 8
      1  0b7b		       a5 93		      lda	audv1Hi
      2  0b7d		       69 00		      adc	#0
      3  0b7f		       85 93		      sta	audv1Hi
      0  0b81					      UPDATE_MUSIC_PREP_VOL	1	; 4 = 12    @73
      1  0b81		       29 06		      and	#VOL_MASK/2
      2  0b83		       0a		      asl
    704  0b84							;    bne    .enterKernel
    705  0b84							;
    706  0b84							;    align 256
    707  0b84							;
    708  0b84							;.enterKernel
    709  0b84		       85 42		      sta	WSYNC
    710  0b86							;---------------------------------------
    711  0b86		       8e 41 00 	      stx.w	VBLANK	; 4 =	4
    712  0b89				   LoopTitle		;	     @04
      0  0b89					      UPDATE_MUSIC_SET_VOL	1	; 3	     @07!    <-- AUDV1
      1  0b89					      IF	PLAY_CH_1 == YES
      2  0b89		       85 5a		      sta	AUDV1
      3  0b8b				  -	      ELSE
      4  0b8b				  -	      nop	AUDV1
      5  0b8b					      ENDIF
    714  0b8b		       bd d5 f0 	      lda	title_STRIP_0,x	; 4
    715  0b8e		       85 4d		      sta	PF0	; 3
    716  0b90		       bd 00 f1 	      lda	title_STRIP_1,x	; 4
    717  0b93		       85 4e		      sta	PF1	; 3
    718  0b95		       bd 23 f1 	      lda	title_STRIP_2,x	; 4
    719  0b98		       85 4f		      sta	PF2	; 3 = 21    @28
    720  0b9a
    721  0b9a		       b9 0b f0 	      lda	TradeMarkA,y	; 4
    722  0b9d		       85 5b		      sta	GRP0	; 3 =	7    @35
    723  0b9f
    724  0b9f		       bd 46 f1 	      lda	title_STRIP_3,x	; 4
    725  0ba2		       85 4d		      sta	PF0	; 3	     @42     <= @47!
    726  0ba4		       bd 69 f1 	      lda	title_STRIP_4,x	; 4
    727  0ba7		       85 4e		      sta	PF1	; 3
    728  0ba9		       bd 8c f1 	      lda	title_STRIP_5,x	; 4
    729  0bac		       85 4f		      sta	PF2	; 3 = 21    @56
    730  0bae
      0  0bae					      UPDATE_MUSIC_DATA_LO	1	; 9
      0  0bae					      CHECK_CLC
      1  0bae
      2  0bae
      3  0bae		       a5 92		      lda	audv1Lo
      4  0bb0		       65 8d		      adc	note1
      5  0bb2		       85 92		      sta	audv1Lo
    732  0bb4							;    SLEEP   9 		      ; 9 = 18	  @74
    733  0bb4		       48		      pha		; 3
    734  0bb5		       68		      pla		; 4
    735  0bb6		       ea		      nop		; 2
    736  0bb7							;---------------------------------------
    737  0bb7		       b9 ae 00 	      lda	audV0LstTop-1,y	; 4
    738  0bba		       29 0c		      and	#VOL_MASK	; 2
      0  0bbc					      UPDATE_MUSIC_SET_VOL	0	; 3 =	9    @07!    <-- AUDV0
      1  0bbc					      IF	PLAY_CH_0 == YES
      2  0bbc		       85 59		      sta	AUDV0
      3  0bbe				  -	      ELSE
      4  0bbe				  -	      nop	AUDV0
      5  0bbe					      ENDIF
    740  0bbe
    741  0bbe		       bd d5 f0 	      lda	title_STRIP_0,x	; 4
    742  0bc1		       85 4d		      sta	PF0	; 3
    743  0bc3		       bd 00 f1 	      lda	title_STRIP_1,x	; 4
    744  0bc6		       85 4e		      sta	PF1	; 3
    745  0bc8		       bd 23 f1 	      lda	title_STRIP_2,x	; 4
    746  0bcb		       85 4f		      sta	PF2	; 3 = 21    @28
    747  0bcd
    748  0bcd		       b9 37 f0 	      lda	TradeMarkB,y	; 4
    749  0bd0		       85 5b		      sta	GRP0	; 3 =	7    @35
    750  0bd2
    751  0bd2		       bd 46 f1 	      lda	title_STRIP_3,x	; 4
    752  0bd5		       85 4d		      sta	PF0	; 3
    753  0bd7		       bd 69 f1 	      lda	title_STRIP_4,x	; 4
    754  0bda		       85 4e		      sta	PF1	; 3
    755  0bdc		       bd 8c f1 	      lda	title_STRIP_5,x	; 4
    756  0bdf		       85 4f		      sta	PF2	; 3 = 21    @56
    757  0be1
      0  0be1					      UPDATE_MUSIC_DATA_HI	1	; 8
      1  0be1		       a5 93		      lda	audv1Hi
      2  0be3		       69 00		      adc	#0
      3  0be5		       85 93		      sta	audv1Hi
      0  0be7					      UPDATE_MUSIC_PREP_VOL	1	; 4
      1  0be7		       29 06		      and	#VOL_MASK/2
      2  0be9		       0a		      asl
      0  0bea					      SLEEP	3	; 3 = 15    @71
      1  0bea				   .CYCLES    SET	3
      2  0bea
      3  0bea				  -	      IF	.CYCLES < 2
      4  0bea				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0bea				  -	      ERR
      6  0bea					      ENDIF
      7  0bea
      8  0bea					      IF	.CYCLES & 1
      9  0bea					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0bea		       04 00		      nop	0
     11  0bec				  -	      ELSE
     12  0bec				  -	      bit	VSYNC
     13  0bec					      ENDIF
     14  0bec				   .CYCLES    SET	.CYCLES - 3
     15  0bec					      ENDIF
     16  0bec
     17  0bec				  -	      REPEAT	.CYCLES / 2
     18  0bec				  -	      nop
     19  0bec					      REPEND
    761  0bec
    762  0bec		       88		      dey		; 2
    763  0bed		       be 84 f0 	      ldx	NextXTbl,y	; 4 =	6    @01
    764  0bf0							;---------------------------------------
    765  0bf0		       10 97		      bpl	LoopTitle	; 2/3= 6    @04
      0  0bf2					      CHECKPAGE	LoopTitle
      8  0bf2					      LIST	ON
    767  0bf2
      0  0bf2					      UPDATE_MUSIC_SET_VOL_W	1	; 4	     @07!    <-- AUDV1
      1  0bf2					      IF	PLAY_CH_1 == YES
      2  0bf2		       8d 5a 00 	      sta.w	AUDV1
      3  0bf5				  -	      ELSE
      4  0bf5				  -	      nop.w	AUDV1
      5  0bf5					      ENDIF
    769  0bf5
    770  0bf5		       84 49		      sty	COLUBK	; 3		     Y==0
    771  0bf7		       84 4d		      sty	PF0	; 3
    772  0bf9		       84 4e		      sty	PF1	; 3
    773  0bfb		       84 4f		      sty	PF2	; 3
    774  0bfd		       84 5e		      sty	ENAM1	; 3 = 15    @22
    775  0bff
    776  0bff		       a5 86		      lda	titleMode	; 3
    777  0c01		       f0 2b		      beq	DrawSelection	; 2/4	     @29
    778  0c03		       4c 07 f0 	      jmp	SwitchToDrawLogoBank	; 8	     @35
    779  0c06
    780  0c06							;--------------------------------------------------------------------------
    781  0c06
    782  0c06				   UpdateMusicWSync0
    783  0c06							; maintain first channel
      0  0c06					      UPDATE_MUSIC_WSYNC	0	;27
      0  0c06					      UPDATE_MUSIC_DATA	0
      0  0c06					      UPDATE_MUSIC_DATA_LO	0
      0  0c06					      CHECK_CLC
      1  0c06
      2  0c06
      3  0c06		       a5 90		      lda	audv0Lo
      4  0c08		       65 8c		      adc	note0
      5  0c0a		       85 90		      sta	audv0Lo
      0  0c0c					      UPDATE_MUSIC_DATA_HI	0
      1  0c0c		       a5 91		      lda	audv0Hi
      2  0c0e		       69 00		      adc	#0
      3  0c10		       85 91		      sta	audv0Hi
      2  0c12		       85 42		      sta	WSYNC
      3  0c14
      0  0c14					      UPDATE_MUSIC_VOL	0
      0  0c14					      UPDATE_MUSIC_PREP_VOL	0
      1  0c14		       29 06		      and	#VOL_MASK/2
      2  0c16		       0a		      asl
      0  0c17					      UPDATE_MUSIC_SET_VOL	0
      1  0c17					      IF	PLAY_CH_0 == YES
      2  0c17		       85 59		      sta	AUDV0
      3  0c19				  -	      ELSE
      4  0c19				  -	      nop	AUDV0
      5  0c19					      ENDIF
    785  0c19		       60		      rts		; 6 = 33
    786  0c1a
    787  0c1a				   UpdateMusicWSync1
    788  0c1a							; maintain second channel
      0  0c1a					      UPDATE_MUSIC_WSYNC	1	;27
      0  0c1a					      UPDATE_MUSIC_DATA	1
      0  0c1a					      UPDATE_MUSIC_DATA_LO	1
      0  0c1a					      CHECK_CLC
      1  0c1a
      2  0c1a
      3  0c1a		       a5 92		      lda	audv1Lo
      4  0c1c		       65 8d		      adc	note1
      5  0c1e		       85 92		      sta	audv1Lo
      0  0c20					      UPDATE_MUSIC_DATA_HI	1
      1  0c20		       a5 93		      lda	audv1Hi
      2  0c22		       69 00		      adc	#0
      3  0c24		       85 93		      sta	audv1Hi
      2  0c26		       85 42		      sta	WSYNC
      3  0c28
      0  0c28					      UPDATE_MUSIC_VOL	1
      0  0c28					      UPDATE_MUSIC_PREP_VOL	1
      1  0c28		       29 06		      and	#VOL_MASK/2
      2  0c2a		       0a		      asl
      0  0c2b					      UPDATE_MUSIC_SET_VOL	1
      1  0c2b					      IF	PLAY_CH_1 == YES
      2  0c2b		       85 5a		      sta	AUDV1
      3  0c2d				  -	      ELSE
      4  0c2d				  -	      nop	AUDV1
      5  0c2d					      ENDIF
    790  0c2d				   Wait12
    791  0c2d		       60		      rts		; 6 = 33
    792  0c2e
    793  0c2e							;--------------------------------------------------------------------------
    794  0c2e							; 6-sprite routine; 32+2 lines of sprites for selection screen.
      0  0c2e					      DEFINE_SUBROUTINE	DrawSelection
      1  0c2e		       00 01	   BANK_DrawSelection =	_CURRENT_BANK
      2  0c2e					      SUBROUTINE
      3  0c2e				   DrawSelection
    796  0c2e
    797  0c2e							;    lda     #1		      ; 2
    798  0c2e							;    sta.w   VDELP1		      ; 4
    799  0c2e
      0  0c2e					      SLEEP	6
      1  0c2e				   .CYCLES    SET	6
      2  0c2e
      3  0c2e				  -	      IF	.CYCLES < 2
      4  0c2e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0c2e				  -	      ERR
      6  0c2e					      ENDIF
      7  0c2e
      8  0c2e				  -	      IF	.CYCLES & 1
      9  0c2e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0c2e				  -	      nop	0
     11  0c2e				  -	      ELSE
     12  0c2e				  -	      bit	VSYNC
     13  0c2e				  -	      ENDIF
     14  0c2e				  -.CYCLES    SET	.CYCLES - 3
     15  0c2e					      ENDIF
     16  0c2e
     17  0c2e					      REPEAT	.CYCLES / 2
     18  0c2e		       ea		      nop
     17  0c2e					      REPEND
     18  0c2f		       ea		      nop
     17  0c2f					      REPEND
     18  0c30		       ea		      nop
     19  0c31					      REPEND
    801  0c31							;	     @35
    802  0c31		       a9 03		      lda	#%00011	; 2
    803  0c33
    804  0c33		       85 50		      sta	RESP0	; 3	     @40     centered
    805  0c35		       85 51		      sta	RESP1	; 3	     @43
    806  0c37
    807  0c37		       85 44		      sta	NUSIZ0	; 3
    808  0c39		       85 45		      sta	NUSIZ1	; 3
    809  0c3b		       85 65		      sta	VDELP0	; 3 =	9    @52
    810  0c3d
    811  0c3d							; Cave:
    812  0c3d		       a0 03		      ldy	#LKERNEL_H/8-1	; 2
    813  0c3f							;    sty     loopCntSel	      ; 3
    814  0c3f							;    lda     (ptrGfxA),y	      ; 5
    815  0c3f							;    sta     tmpGfxA		      ; 3 = 10
    816  0c3f		       a5 97		      lda	tmpGfxB	; 3
    817  0c41		       8d 46 00 	      sta.w	COLUP0	; 4
    818  0c44		       85 47		      sta	COLUP1	; 3 = 10    @64
    819  0c46							;---------------------------------------
    820  0c46							;    sta     HMOVE		      ; 3	  @67
    821  0c46							;    jmp     EnterSelLoop0	      ; 3 =  6	  @70
    822  0c46
    823  0c46		       bf b1 f6 	      lax	SelGfxB4_0-1,y	; 4
    824  0c49		       85 6a		      sta	HMOVE	; 3	     @71
    825  0c4b		       4c 8a f4 	      jmp	EnterSelLoop0+3	; 3 =	6    @74
    826  0c4e
    827  0c4e							;    ALIGN_FREE 256
    828  0c4e
      0  0c4e					      DRAW_ROW	0	;	     @59
      1  0c4e
      2  0c4e				  -	      IF	0 != 0
      3  0c4e				  -	      ALIGN_FREE	256
      4  0c4e					      ENDIF
      5  0c4e
      6  0c4e
      7  0c4e
      8  0c4e
      9  0c4e
     10  0c4e				   LoopSelGfx0
     11  0c4e		       be d5 f5 	      ldx	SelGfxB0_0-1,y
     12  0c51		       8e 5b 00 	      stx.w	GRP0
     13  0c54
      0  0c54					      UPDATE_MUSIC_DATA_HI	1
      1  0c54		       a5 93		      lda	audv1Hi
      2  0c56		       69 00		      adc	#0
      3  0c58		       85 93		      sta	audv1Hi
     15  0c5a
      0  0c5a					      UPDATE_MUSIC_VOL	1
      0  0c5a					      UPDATE_MUSIC_PREP_VOL	1
      1  0c5a		       29 06		      and	#VOL_MASK/2
      2  0c5c		       0a		      asl
      0  0c5d					      UPDATE_MUSIC_SET_VOL	1
      1  0c5d					      IF	PLAY_CH_1 == YES
      2  0c5d		       85 5a		      sta	AUDV1
      3  0c5f				  -	      ELSE
      4  0c5f				  -	      nop	AUDV1
      5  0c5f					      ENDIF
     17  0c5f
      0  0c5f					      UPDATE_MUSIC_DATA_LO	1
      0  0c5f					      CHECK_CLC
      1  0c5f
      2  0c5f
      3  0c5f		       a5 92		      lda	audv1Lo
      4  0c61		       65 8d		      adc	note1
      5  0c63		       85 92		      sta	audv1Lo
     19  0c65
     20  0c65		       b9 e1 f5 	      lda	SelGfxB1_0-1,y
     21  0c68		       85 5c		      sta	GRP1
     22  0c6a		       b9 ed f5 	      lda	SelGfxB2_0-1,y
     23  0c6d		       85 5b		      sta	GRP0
     24  0c6f
     25  0c6f		       b3 9b		      lax	(ptrGfxB),y
     26  0c71		       b9 f9 f5 	      lda	SelGfxB3_0-1,y
     27  0c74		       a4 97		      ldy	tmpGfxB
     28  0c76
     29  0c76		       85 5c		      sta	GRP1
     30  0c78		       84 5b		      sty	GRP0
     31  0c7a		       86 5c		      stx	GRP1
     32  0c7c		       85 5b		      sta	GRP0
     33  0c7e
     34  0c7e		       a4 98		      ldy	loopCntSel
     35  0c80		       88		      dey
     36  0c81		       84 98		      sty	loopCntSel
     37  0c83		       b1 99		      lda	(ptrGfxA),y
     38  0c85		       85 96		      sta	tmpGfxA
     39  0c87				   EnterSelLoop0
     40  0c87		       bf b1 f6 	      lax	SelGfxB4_0-1,y
     41  0c8a
     42  0c8a				   V_OFS      SET	(3-0)*4
     43  0c8a		       b9 ab 00 	      lda	audV0LstBtm+V_OFS,y
     44  0c8d		       29 0c		      and	#VOL_MASK
      0  0c8f					      UPDATE_MUSIC_SET_VOL	0
      1  0c8f					      IF	PLAY_CH_0 == YES
      2  0c8f		       85 59		      sta	AUDV0
      3  0c91				  -	      ELSE
      4  0c91				  -	      nop	AUDV0
      5  0c91					      ENDIF
     46  0c91
     47  0c91		       86 97		      stx	tmpGfxB
     48  0c93		       be a9 f5 	      ldx	SelGfxA0_0,y
     49  0c96		       86 5b		      stx	GRP0
     50  0c98		       b9 89 f7 	      lda	SelGfxA1_0,y
     51  0c9b		       85 5c		      sta	GRP1
     52  0c9d		       b9 99 f7 	      lda	SelGfxA2_0,y
     53  0ca0		       85 5b		      sta	GRP0
     54  0ca2
     55  0ca2		       bf c9 f5 	      lax	SelGfxA4_0,y
     56  0ca5		       b9 b9 f5 	      lda	SelGfxA3_0,y
     57  0ca8		       a4 96		      ldy	tmpGfxA
     58  0caa		       85 5c		      sta	GRP1
     59  0cac		       86 5b		      stx	GRP0
     60  0cae		       84 5c		      sty	GRP1
     61  0cb0		       85 5b		      sta	GRP0
     62  0cb2
     63  0cb2		       a4 98		      ldy	loopCntSel
     64  0cb4		       d0 98		      bne	LoopSelGfx0
      0  0cb6					      CHECKPAGE	LoopSelGfx0
      8  0cb6					      LIST	ON
      0  0cb6					      END_ROW		;	     @16
      1  0cb6		       84 46		      sty	COLUP0
      2  0cb8		       84 47		      sty	COLUP1
      0  0cba					      SLEEP	3
      1  0cba				   .CYCLES    SET	3
      2  0cba
      3  0cba				  -	      IF	.CYCLES < 2
      4  0cba				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0cba				  -	      ERR
      6  0cba					      ENDIF
      7  0cba
      8  0cba					      IF	.CYCLES & 1
      9  0cba					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0cba		       04 00		      nop	0
     11  0cbc				  -	      ELSE
     12  0cbc				  -	      bit	VSYNC
     13  0cbc					      ENDIF
     14  0cbc				   .CYCLES    SET	.CYCLES - 3
     15  0cbc					      ENDIF
     16  0cbc
     17  0cbc				  -	      REPEAT	.CYCLES / 2
     18  0cbc				  -	      nop
     19  0cbc					      REPEND
      4  0cbc
      5  0cbc
      6  0cbc
      7  0cbc
      0  0cbc					      UPDATE_MUSIC_DATA_HI	1
      1  0cbc		       a5 93		      lda	audv1Hi
      2  0cbe		       69 00		      adc	#0
      3  0cc0		       85 93		      sta	audv1Hi
      9  0cc2
      0  0cc2					      UPDATE_MUSIC_VOL	1
      0  0cc2					      UPDATE_MUSIC_PREP_VOL	1
      1  0cc2		       29 06		      and	#VOL_MASK/2
      2  0cc4		       0a		      asl
      0  0cc5					      UPDATE_MUSIC_SET_VOL	1
      1  0cc5					      IF	PLAY_CH_1 == YES
      2  0cc5		       85 5a		      sta	AUDV1
      3  0cc7				  -	      ELSE
      4  0cc7				  -	      nop	AUDV1
      5  0cc7					      ENDIF
     11  0cc7
      0  0cc7					      UPDATE_MUSIC_DATA_LO	1
      0  0cc7					      CHECK_CLC
      1  0cc7
      2  0cc7
      3  0cc7		       a5 92		      lda	audv1Lo
      4  0cc9		       65 8d		      adc	note1
      5  0ccb		       85 92		      sta	audv1Lo
    831  0ccd
    832  0ccd							; Level 1/2:
      0  0ccd					      SET_DIGIT_PTR	1	;17
      1  0ccd		       a4 83		      ldy	selLst+1
      2  0ccf		       b9 c5 f7 	      lda	SelDigitAPtr,y
      3  0cd2		       85 99		      sta	ptrGfxA
      4  0cd4		       b9 ca f7 	      lda	SelDigitBPtr,y
      5  0cd7		       85 9b		      sta	ptrGfxB
      0  0cd9					      START_ROW	1
      1  0cd9		       a0 03		      ldy	#LKERNEL_H/8-1
      2  0cdb		       84 98		      sty	loopCntSel
      3  0cdd		       b1 99		      lda	(ptrGfxA),y
      4  0cdf		       85 96		      sta	tmpGfxA
      5  0ce1
      0  0ce1					      SET_ROW_COL	1
      1  0ce1		       a6 81		      ldx	Platform
      2  0ce3		       a5 9d		      lda	selRow
      3  0ce5					      IF	1 != 0
      4  0ce5		       49 01		      eor	#1
      5  0ce7					      ENDIF
      6  0ce7		       f0 04		      beq	.isSel1
      7  0ce9		       a9 0a		      lda	#NOT_SEL_COL
      8  0ceb		       d0 03		      bne	.notSel1
      9  0ced
     10  0ced				   .isSel1
     11  0ced		       bd fc f6 	      lda	SelectionColTbl,x
     12  0cf0				   .notSel1
     13  0cf0		       85 46		      sta	COLUP0
     14  0cf2		       85 47		      sta	COLUP1
      7  0cf4
      8  0cf4		       4c 39 f5 	      jmp	EnterSelLoop1
    835  0cf7
    836  0cf7							;-------------------------------------------------------------------------------
    837  0cf7							; fill align gaps:
    838  0cf7				   SelGfx1
    839  0cf7					      IF	FINAL_VERSION = NO
    840  0cf7				   SelGfxA0_2
    841  0cf7		       e0		      .byte.b	%11100000
    842  0cf8		       fc		      .byte.b	%11111100
    843  0cf9		       e6		      .byte.b	%11100110
    844  0cfa		       fc		      .byte.b	%11111100
    845  0cfb				   SelGfxA0_1
    846  0cfb		       fd		      .byte.b	%11111101
    847  0cfc		       e1		      .byte.b	%11100001
    848  0cfd		       e1		      .byte.b	%11100001
    849  0cfe		       e1		      .byte.b	%11100001
    850  0cff					      ENDIF
      0  0cff					      CHECKPAGE	SelGfx1
      8  0cff					      LIST	ON
    852  0cff
    853  0cff							;-------------------------------------------------------------------------------
    854  0cff							; Level 2/2
      0  0cff					      DRAW_ROW	1	;	     @59
      1  0cff
      2  0cff					      IF	1 != 0
      0  0cff					      ALIGN_FREE	256
      1  0cff				   FREE       SET	FREE - .
      2  0d00		       00		      align	256
      3  0d00				   FREE       SET	FREE + .
 @ $f500 : $9
      4  0d00					      echo	"@", ., ":", FREE
      4  0d00					      ENDIF
      5  0d00
      6  0d00
      7  0d00
      8  0d00
      9  0d00
     10  0d00				   LoopSelGfx1
     11  0d00		       be d2 f5 	      ldx	SelGfxB0_1-1,y
     12  0d03		       8e 5b 00 	      stx.w	GRP0
     13  0d06
      0  0d06					      UPDATE_MUSIC_DATA_HI	1
      1  0d06		       a5 93		      lda	audv1Hi
      2  0d08		       69 00		      adc	#0
      3  0d0a		       85 93		      sta	audv1Hi
     15  0d0c
      0  0d0c					      UPDATE_MUSIC_VOL	1
      0  0d0c					      UPDATE_MUSIC_PREP_VOL	1
      1  0d0c		       29 06		      and	#VOL_MASK/2
      2  0d0e		       0a		      asl
      0  0d0f					      UPDATE_MUSIC_SET_VOL	1
      1  0d0f					      IF	PLAY_CH_1 == YES
      2  0d0f		       85 5a		      sta	AUDV1
      3  0d11				  -	      ELSE
      4  0d11				  -	      nop	AUDV1
      5  0d11					      ENDIF
     17  0d11
      0  0d11					      UPDATE_MUSIC_DATA_LO	1
      0  0d11					      CHECK_CLC
      1  0d11
      2  0d11
      3  0d11		       a5 92		      lda	audv1Lo
      4  0d13		       65 8d		      adc	note1
      5  0d15		       85 92		      sta	audv1Lo
     19  0d17
     20  0d17		       b9 de f5 	      lda	SelGfxB1_1-1,y
     21  0d1a		       85 5c		      sta	GRP1
     22  0d1c		       b9 ea f5 	      lda	SelGfxB2_1-1,y
     23  0d1f		       85 5b		      sta	GRP0
     24  0d21
     25  0d21		       b3 9b		      lax	(ptrGfxB),y
     26  0d23		       b9 f6 f5 	      lda	SelGfxB3_1-1,y
     27  0d26		       a4 97		      ldy	tmpGfxB
     28  0d28
     29  0d28		       85 5c		      sta	GRP1
     30  0d2a		       84 5b		      sty	GRP0
     31  0d2c		       86 5c		      stx	GRP1
     32  0d2e		       85 5b		      sta	GRP0
     33  0d30
     34  0d30		       a4 98		      ldy	loopCntSel
     35  0d32		       88		      dey
     36  0d33		       84 98		      sty	loopCntSel
     37  0d35		       b1 99		      lda	(ptrGfxA),y
     38  0d37		       85 96		      sta	tmpGfxA
     39  0d39				   EnterSelLoop1
     40  0d39		       bf ae f6 	      lax	SelGfxB4_1-1,y
     41  0d3c
     42  0d3c				   V_OFS      SET	(3-1)*4
     43  0d3c		       b9 a7 00 	      lda	audV0LstBtm+V_OFS,y
     44  0d3f		       29 0c		      and	#VOL_MASK
      0  0d41					      UPDATE_MUSIC_SET_VOL	0
      1  0d41					      IF	PLAY_CH_0 == YES
      2  0d41		       85 59		      sta	AUDV0
      3  0d43				  -	      ELSE
      4  0d43				  -	      nop	AUDV0
      5  0d43					      ENDIF
     46  0d43
     47  0d43		       86 97		      stx	tmpGfxB
     48  0d45		       be fb f4 	      ldx	SelGfxA0_1,y
     49  0d48		       86 5b		      stx	GRP0
     50  0d4a		       b9 85 f7 	      lda	SelGfxA1_1,y
     51  0d4d		       85 5c		      sta	GRP1
     52  0d4f		       b9 95 f7 	      lda	SelGfxA2_1,y
     53  0d52		       85 5b		      sta	GRP0
     54  0d54
     55  0d54		       bf c5 f5 	      lax	SelGfxA4_1,y
     56  0d57		       b9 b5 f5 	      lda	SelGfxA3_1,y
     57  0d5a		       a4 96		      ldy	tmpGfxA
     58  0d5c		       85 5c		      sta	GRP1
     59  0d5e		       86 5b		      stx	GRP0
     60  0d60		       84 5c		      sty	GRP1
     61  0d62		       85 5b		      sta	GRP0
     62  0d64
     63  0d64		       a4 98		      ldy	loopCntSel
     64  0d66		       d0 98		      bne	LoopSelGfx1
      0  0d68					      CHECKPAGE	LoopSelGfx1
      8  0d68					      LIST	ON
      0  0d68					      END_ROW		;	     @16
      1  0d68		       84 46		      sty	COLUP0
      2  0d6a		       84 47		      sty	COLUP1
      0  0d6c					      SLEEP	3
      1  0d6c				   .CYCLES    SET	3
      2  0d6c
      3  0d6c				  -	      IF	.CYCLES < 2
      4  0d6c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d6c				  -	      ERR
      6  0d6c					      ENDIF
      7  0d6c
      8  0d6c					      IF	.CYCLES & 1
      9  0d6c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d6c		       04 00		      nop	0
     11  0d6e				  -	      ELSE
     12  0d6e				  -	      bit	VSYNC
     13  0d6e					      ENDIF
     14  0d6e				   .CYCLES    SET	.CYCLES - 3
     15  0d6e					      ENDIF
     16  0d6e
     17  0d6e				  -	      REPEAT	.CYCLES / 2
     18  0d6e				  -	      nop
     19  0d6e					      REPEND
      4  0d6e
      5  0d6e
      6  0d6e
      7  0d6e
      0  0d6e					      UPDATE_MUSIC_DATA_HI	1
      1  0d6e		       a5 93		      lda	audv1Hi
      2  0d70		       69 00		      adc	#0
      3  0d72		       85 93		      sta	audv1Hi
      9  0d74
      0  0d74					      UPDATE_MUSIC_VOL	1
      0  0d74					      UPDATE_MUSIC_PREP_VOL	1
      1  0d74		       29 06		      and	#VOL_MASK/2
      2  0d76		       0a		      asl
      0  0d77					      UPDATE_MUSIC_SET_VOL	1
      1  0d77					      IF	PLAY_CH_1 == YES
      2  0d77		       85 5a		      sta	AUDV1
      3  0d79				  -	      ELSE
      4  0d79				  -	      nop	AUDV1
      5  0d79					      ENDIF
     11  0d79
      0  0d79					      UPDATE_MUSIC_DATA_LO	1
      0  0d79					      CHECK_CLC
      1  0d79
      2  0d79
      3  0d79		       a5 92		      lda	audv1Lo
      4  0d7b		       65 8d		      adc	note1
      5  0d7d		       85 92		      sta	audv1Lo
    857  0d7f
    858  0d7f							; Players 1/2:
      0  0d7f					      SET_DIGIT_PTR	2	;17
      1  0d7f		       a4 84		      ldy	selLst+2
      2  0d81		       b9 c5 f7 	      lda	SelDigitAPtr,y
      3  0d84		       85 99		      sta	ptrGfxA
      4  0d86		       b9 ca f7 	      lda	SelDigitBPtr,y
      5  0d89		       85 9b		      sta	ptrGfxB
      0  0d8b					      START_ROW	2
      1  0d8b		       a0 03		      ldy	#LKERNEL_H/8-1
      2  0d8d		       84 98		      sty	loopCntSel
      3  0d8f		       b1 99		      lda	(ptrGfxA),y
      4  0d91		       85 96		      sta	tmpGfxA
      5  0d93
      0  0d93					      SET_ROW_COL	2
      1  0d93		       a6 81		      ldx	Platform
      2  0d95		       a5 9d		      lda	selRow
      3  0d97					      IF	2 != 0
      4  0d97		       49 02		      eor	#2
      5  0d99					      ENDIF
      6  0d99		       f0 04		      beq	.isSel2
      7  0d9b		       a9 0a		      lda	#NOT_SEL_COL
      8  0d9d		       d0 03		      bne	.notSel2
      9  0d9f
     10  0d9f				   .isSel2
     11  0d9f		       bd fc f6 	      lda	SelectionColTbl,x
     12  0da2				   .notSel2
     13  0da2		       85 46		      sta	COLUP0
     14  0da4		       85 47		      sta	COLUP1
      7  0da6
      8  0da6		       4c 39 f6 	      jmp	EnterSelLoop2
    861  0da9
    862  0da9							;-------------------------------------------------------------------------------
    863  0da9							; fill align gaps:
    864  0da9				   SelGfx2
    865  0da9				   SelGfxA0_0
    866  0da9		       7c		      .byte.b	%01111100
    867  0daa		       e6		      .byte.b	%11100110
    868  0dab		       e0		      .byte.b	%11100000
    869  0dac		       7c		      .byte.b	%01111100
    870  0dad
    871  0dad				   SelGfxA3_3
    872  0dad		       f8		      .byte.b	%11111000
    873  0dae		       0c		      .byte.b	%00001100
    874  0daf		       f8		      .byte.b	%11111000
    875  0db0		       fb		      .byte.b	%11111011
    876  0db1				   SelGfxA3_2
    877  0db1		       9b		      .byte.b	%10011011
    878  0db2		       f0		      .byte.b	%11110000
    879  0db3		       99		      .byte.b	%10011001
    880  0db4		       f1		      .byte.b	%11110001
    881  0db5				   SelGfxA3_1
    882  0db5		       fd		      .byte.b	%11111101
    883  0db6		       c1		      .byte.b	%11000001
    884  0db7		       f9		      .byte.b	%11111001
    885  0db8		       fd		      .byte.b	%11111101
    886  0db9				   SelGfxA3_0
    887  0db9		       fe		      .byte.b	%11111110
    888  0dba		       e0		      .byte.b	%11100000
    889  0dbb		       fc		      .byte.b	%11111100
    890  0dbc		       fe		      .byte.b	%11111110
    891  0dbd
    892  0dbd				   SelGfxA4_3
    893  0dbd		       e0		      .byte.b	%11100000
    894  0dbe		       e3		      .byte.b	%11100011
    895  0dbf		       e3		      .byte.b	%11100011
    896  0dc0		       f8		      .byte.b	%11111000
    897  0dc1				   SelGfxA4_2
    898  0dc1		       f0		      .byte.b	%11110000
    899  0dc2		       1b		      .byte.b	%00011011
    900  0dc3		       f3		      .byte.b	%11110011
    901  0dc4		       f0		      .byte.b	%11110000
    902  0dc5				   SelGfxA4_1
    903  0dc5		       f8		      .byte.b	%11111000
    904  0dc6		       c3		      .byte.b	%11000011
    905  0dc7		       c3		      .byte.b	%11000011
    906  0dc8		       c0		      .byte.b	%11000000
    907  0dc9				   SelGfxA4_0
    908  0dc9		       00		      .byte.b	%00000000
    909  0dca		       03		      .byte.b	%00000011
    910  0dcb		       03		      .byte.b	%00000011
    911  0dcc		       00		      .byte.b	%00000000
    912  0dcd
    913  0dcd				   SelGfxB0_3
    914  0dcd		       fd		      .byte.b	%11111101
    915  0dce		       0d		      .byte.b	%00001101
    916  0dcf		       0d		      .byte.b	%00001101
    917  0dd0				   SelGfxB0_2
    918  0dd0		       e0		      .byte.b	%11100000
    919  0dd1		       fe		      .byte.b	%11111110
    920  0dd2		       e6		      .byte.b	%11100110
    921  0dd3				   SelGfxB0_1
    922  0dd3		       fd		      .byte.b	%11111101
    923  0dd4		       e1		      .byte.b	%11100001
    924  0dd5		       e1		      .byte.b	%11100001
    925  0dd6				   SelGfxB0_0
    926  0dd6		       fe		      .byte.b	%11111110
    927  0dd7		       e0		      .byte.b	%11100000
    928  0dd8		       e6		      .byte.b	%11100110
    929  0dd9
    930  0dd9				   SelGfxB1_3
    931  0dd9		       fc		      .byte.b	%11111100
    932  0dda		       8c		      .byte.b	%10001100
    933  0ddb		       8d		      .byte.b	%10001101
    934  0ddc				   SelGfxB1_2
    935  0ddc		       fc		      .byte.b	%11111100
    936  0ddd		       e0		      .byte.b	%11100000
    937  0dde		       e3		      .byte.b	%11100011
    938  0ddf				   SelGfxB1_1
    939  0ddf		       fc		      .byte.b	%11111100
    940  0de0		       c1		      .byte.b	%11000001
    941  0de1		       c1		      .byte.b	%11000001
    942  0de2				   SelGfxB1_0
    943  0de2		       e6		      .byte.b	%11100110
    944  0de3		       e6		      .byte.b	%11100110
    945  0de4		       7c		      .byte.b	%01111100
    946  0de5
    947  0de5				   SelGfxB2_3
    948  0de5		       71		      .byte.b	%01110001
    949  0de6		       70		      .byte.b	%01110000
    950  0de7		       8d		      .byte.b	%10001101
    951  0de8				   SelGfxB2_2
    952  0de8		       e3		      .byte.b	%11100011
    953  0de9		       e3		      .byte.b	%11100011
    954  0dea		       1b		      .byte.b	%00011011
    955  0deb				   SelGfxB2_1
    956  0deb		       f9		      .byte.b	%11111001
    957  0dec		       cd		      .byte.b	%11001101
    958  0ded		       cd		      .byte.b	%11001101
    959  0dee				   SelGfxB2_0
    960  0dee		       7c		      .byte.b	%01111100
    961  0def		       e6		      .byte.b	%11100110
    962  0df0		       e6		      .byte.b	%11100110
    963  0df1
    964  0df1				   SelGfxB3_3
    965  0df1		       fc		      .byte.b	%11111100
    966  0df2		       0c		      .byte.b	%00001100
    967  0df3		       c0		      .byte.b	%11000000
    968  0df4				   SelGfxB3_2
    969  0df4		       9b		      .byte.b	%10011011
    970  0df5		       f0		      .byte.b	%11110000
    971  0df6		       9b		      .byte.b	%10011011
    972  0df7				   SelGfxB3_1
    973  0df7		       fd		      .byte.b	%11111101
    974  0df8		       c1		      .byte.b	%11000001
    975  0df9		       c1		      .byte.b	%11000001
    976  0dfa				   SelGfxB3_0
    977  0dfa		       fe		      .byte.b	%11111110
    978  0dfb		       e0		      .byte.b	%11100000
    979  0dfc		       e0		      .byte.b	%11100000
      0  0dfd					      CHECKPAGE	SelGfx2
      8  0dfd					      LIST	ON
    981  0dfd
    982  0dfd							;-------------------------------------------------------------------------------
    983  0dfd							; Players 2/2:
      0  0dfd					      DRAW_ROW	2	;	     @59
      1  0dfd
      2  0dfd					      IF	2 != 0
      0  0dfd					      ALIGN_FREE	256
      1  0dfd				   FREE       SET	FREE - .
      2  0e00		       00 00 00 	      align	256
      3  0e00				   FREE       SET	FREE + .
 @ $f600 : $c
      4  0e00					      echo	"@", ., ":", FREE
      4  0e00					      ENDIF
      5  0e00
      6  0e00
      7  0e00
      8  0e00
      9  0e00
     10  0e00				   LoopSelGfx2
     11  0e00		       be cf f5 	      ldx	SelGfxB0_2-1,y
     12  0e03		       8e 5b 00 	      stx.w	GRP0
     13  0e06
      0  0e06					      UPDATE_MUSIC_DATA_HI	1
      1  0e06		       a5 93		      lda	audv1Hi
      2  0e08		       69 00		      adc	#0
      3  0e0a		       85 93		      sta	audv1Hi
     15  0e0c
      0  0e0c					      UPDATE_MUSIC_VOL	1
      0  0e0c					      UPDATE_MUSIC_PREP_VOL	1
      1  0e0c		       29 06		      and	#VOL_MASK/2
      2  0e0e		       0a		      asl
      0  0e0f					      UPDATE_MUSIC_SET_VOL	1
      1  0e0f					      IF	PLAY_CH_1 == YES
      2  0e0f		       85 5a		      sta	AUDV1
      3  0e11				  -	      ELSE
      4  0e11				  -	      nop	AUDV1
      5  0e11					      ENDIF
     17  0e11
      0  0e11					      UPDATE_MUSIC_DATA_LO	1
      0  0e11					      CHECK_CLC
      1  0e11
      2  0e11
      3  0e11		       a5 92		      lda	audv1Lo
      4  0e13		       65 8d		      adc	note1
      5  0e15		       85 92		      sta	audv1Lo
     19  0e17
     20  0e17		       b9 db f5 	      lda	SelGfxB1_2-1,y
     21  0e1a		       85 5c		      sta	GRP1
     22  0e1c		       b9 e7 f5 	      lda	SelGfxB2_2-1,y
     23  0e1f		       85 5b		      sta	GRP0
     24  0e21
     25  0e21		       b3 9b		      lax	(ptrGfxB),y
     26  0e23		       b9 f3 f5 	      lda	SelGfxB3_2-1,y
     27  0e26		       a4 97		      ldy	tmpGfxB
     28  0e28
     29  0e28		       85 5c		      sta	GRP1
     30  0e2a		       84 5b		      sty	GRP0
     31  0e2c		       86 5c		      stx	GRP1
     32  0e2e		       85 5b		      sta	GRP0
     33  0e30
     34  0e30		       a4 98		      ldy	loopCntSel
     35  0e32		       88		      dey
     36  0e33		       84 98		      sty	loopCntSel
     37  0e35		       b1 99		      lda	(ptrGfxA),y
     38  0e37		       85 96		      sta	tmpGfxA
     39  0e39				   EnterSelLoop2
     40  0e39		       bf ab f6 	      lax	SelGfxB4_2-1,y
     41  0e3c
     42  0e3c				   V_OFS      SET	(3-2)*4
     43  0e3c		       b9 a3 00 	      lda	audV0LstBtm+V_OFS,y
     44  0e3f		       29 0c		      and	#VOL_MASK
      0  0e41					      UPDATE_MUSIC_SET_VOL	0
      1  0e41					      IF	PLAY_CH_0 == YES
      2  0e41		       85 59		      sta	AUDV0
      3  0e43				  -	      ELSE
      4  0e43				  -	      nop	AUDV0
      5  0e43					      ENDIF
     46  0e43
     47  0e43		       86 97		      stx	tmpGfxB
     48  0e45		       be f7 f4 	      ldx	SelGfxA0_2,y
     49  0e48		       86 5b		      stx	GRP0
     50  0e4a		       b9 81 f7 	      lda	SelGfxA1_2,y
     51  0e4d		       85 5c		      sta	GRP1
     52  0e4f		       b9 91 f7 	      lda	SelGfxA2_2,y
     53  0e52		       85 5b		      sta	GRP0
     54  0e54
     55  0e54		       bf c1 f5 	      lax	SelGfxA4_2,y
     56  0e57		       b9 b1 f5 	      lda	SelGfxA3_2,y
     57  0e5a		       a4 96		      ldy	tmpGfxA
     58  0e5c		       85 5c		      sta	GRP1
     59  0e5e		       86 5b		      stx	GRP0
     60  0e60		       84 5c		      sty	GRP1
     61  0e62		       85 5b		      sta	GRP0
     62  0e64
     63  0e64		       a4 98		      ldy	loopCntSel
     64  0e66		       d0 98		      bne	LoopSelGfx2
      0  0e68					      CHECKPAGE	LoopSelGfx2
      8  0e68					      LIST	ON
      0  0e68					      END_ROW		;	     @16
      1  0e68		       84 46		      sty	COLUP0
      2  0e6a		       84 47		      sty	COLUP1
      0  0e6c					      SLEEP	3
      1  0e6c				   .CYCLES    SET	3
      2  0e6c
      3  0e6c				  -	      IF	.CYCLES < 2
      4  0e6c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0e6c				  -	      ERR
      6  0e6c					      ENDIF
      7  0e6c
      8  0e6c					      IF	.CYCLES & 1
      9  0e6c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0e6c		       04 00		      nop	0
     11  0e6e				  -	      ELSE
     12  0e6e				  -	      bit	VSYNC
     13  0e6e					      ENDIF
     14  0e6e				   .CYCLES    SET	.CYCLES - 3
     15  0e6e					      ENDIF
     16  0e6e
     17  0e6e				  -	      REPEAT	.CYCLES / 2
     18  0e6e				  -	      nop
     19  0e6e					      REPEND
      4  0e6e
      5  0e6e
      6  0e6e
      7  0e6e
      0  0e6e					      UPDATE_MUSIC_DATA_HI	1
      1  0e6e		       a5 93		      lda	audv1Hi
      2  0e70		       69 00		      adc	#0
      3  0e72		       85 93		      sta	audv1Hi
      9  0e74
      0  0e74					      UPDATE_MUSIC_VOL	1
      0  0e74					      UPDATE_MUSIC_PREP_VOL	1
      1  0e74		       29 06		      and	#VOL_MASK/2
      2  0e76		       0a		      asl
      0  0e77					      UPDATE_MUSIC_SET_VOL	1
      1  0e77					      IF	PLAY_CH_1 == YES
      2  0e77		       85 5a		      sta	AUDV1
      3  0e79				  -	      ELSE
      4  0e79				  -	      nop	AUDV1
      5  0e79					      ENDIF
     11  0e79
      0  0e79					      UPDATE_MUSIC_DATA_LO	1
      0  0e79					      CHECK_CLC
      1  0e79
      2  0e79
      3  0e79		       a5 92		      lda	audv1Lo
      4  0e7b		       65 8d		      adc	note1
      5  0e7d		       85 92		      sta	audv1Lo
    986  0e7f
    987  0e7f							; Joysticks 1/2:
      0  0e7f					      SET_DIGIT_PTR	3	;17
      1  0e7f		       a4 85		      ldy	selLst+3
      2  0e81		       b9 c5 f7 	      lda	SelDigitAPtr,y
      3  0e84		       85 99		      sta	ptrGfxA
      4  0e86		       b9 ca f7 	      lda	SelDigitBPtr,y
      5  0e89		       85 9b		      sta	ptrGfxB
      0  0e8b					      START_ROW	3
      1  0e8b		       a0 03		      ldy	#LKERNEL_H/8-1
      2  0e8d		       84 98		      sty	loopCntSel
      3  0e8f		       b1 99		      lda	(ptrGfxA),y
      4  0e91		       85 96		      sta	tmpGfxA
      5  0e93
      0  0e93					      SET_ROW_COL	3
      1  0e93		       a6 81		      ldx	Platform
      2  0e95		       a5 9d		      lda	selRow
      3  0e97					      IF	3 != 0
      4  0e97		       49 03		      eor	#3
      5  0e99					      ENDIF
      6  0e99		       f0 04		      beq	.isSel3
      7  0e9b		       a9 0a		      lda	#NOT_SEL_COL
      8  0e9d		       d0 03		      bne	.notSel3
      9  0e9f
     10  0e9f				   .isSel3
     11  0e9f		       bd fc f6 	      lda	SelectionColTbl,x
     12  0ea2				   .notSel3
     13  0ea2		       85 46		      sta	COLUP0
     14  0ea4		       85 47		      sta	COLUP1
      7  0ea6
      8  0ea6		       4c 39 f7 	      jmp	EnterSelLoop3
    990  0ea9
    991  0ea9							;-------------------------------------------------------------------------------
    992  0ea9							; fill align gaps:
    993  0ea9				   SelGfx3
    994  0ea9				   SelGfxB4_3
    995  0ea9		       e3		      .byte.b	%11100011
    996  0eaa		       e0		      .byte.b	%11100000
    997  0eab		       e3		      .byte.b	%11100011
    998  0eac				   SelGfxB4_2
    999  0eac		       fb		      .byte.b	%11111011
   1000  0ead		       18		      .byte.b	%00011000
   1001  0eae		       83		      .byte.b	%10000011
   1002  0eaf				   SelGfxB4_1
   1003  0eaf		       fb		      .byte.b	%11111011
   1004  0eb0		       c0		      .byte.b	%11000000
   1005  0eb1		       c3		      .byte.b	%11000011
   1006  0eb2				   SelGfxB4_0
   1007  0eb2		       03		      .byte.b	%00000011
   1008  0eb3		       00		      .byte.b	%00000000
   1009  0eb4		       03		      .byte.b	%00000011
   1010  0eb5
   1011  0eb5				   CharGfx
   1012  0eb5				   Gfx5_A
   1013  0eb5		       3e		      .byte.b	%00111110
   1014  0eb6		       73		      .byte.b	%01110011
   1015  0eb7		       7e		      .byte.b	%01111110
   1016  0eb8		       7f		      .byte.b	%01111111
   1017  0eb9				   Gfx5_B
   1018  0eb9		       7f		      .byte.b	%01111111
   1019  0eba		       03		      .byte.b	%00000011
   1020  0ebb		       70		      .byte.b	%01110000
   1021  0ebc
   1022  0ebc				   GfxA_A
   1023  0ebc		       73		      .byte.b	%01110011
   1024  0ebd		       7f		      .byte.b	%01111111
   1025  0ebe		       73		      .byte.b	%01110011
   1026  0ebf		       1c		      .byte.b	%00011100
   1027  0ec0				   Gfx1_A
   1028  0ec0		       3f		      .byte.b	%00111111
   1029  0ec1		       0c		      .byte.b	%00001100
   1030  0ec2		       1c		      .byte.b	%00011100
   1031  0ec3		       0c		      .byte.b	%00001100
   1032  0ec4				   GfxE_A
   1033  0ec4		       7f		      .byte.b	%01111111
   1034  0ec5		       70		      .byte.b	%01110000
   1035  0ec6		       7e		      .byte.b	%01111110
   1036  0ec7		       7f		      .byte.b	%01111111
   1037  0ec8				   Gfx2_A
   1038  0ec8		       7f		      .byte.b	%01111111
   1039  0ec9		       38		      .byte.b	%00111000
   1040  0eca		       0e		      .byte.b	%00001110
   1041  0ecb		       3e		      .byte.b	%00111110
   1042  0ecc				   GfxI_A
   1043  0ecc		       3e		      .byte.b	%00111110
   1044  0ecd		       1c		      .byte.b	%00011100
   1045  0ece		       1c		      .byte.b	%00011100
   1046  0ecf		       3e		      .byte.b	%00111110
   1047  0ed0				   Gfx3_A
   1048  0ed0		       3e		      .byte.b	%00111110
   1049  0ed1		       73		      .byte.b	%01110011
   1050  0ed2		       0c		      .byte.b	%00001100
   1051  0ed3		       3f		      .byte.b	%00111111
   1052  0ed4				   GfxM_A
   1053  0ed4		       63		      .byte.b	%01100011
   1054  0ed5		       63		      .byte.b	%01100011
   1055  0ed6		       7f		      .byte.b	%01111111
   1056  0ed7		       63		      .byte.b	%01100011
   1057  0ed8				   Gfx4_A
   1058  0ed8		       0e		      .byte.b	%00001110
   1059  0ed9		       0e		      .byte.b	%00001110
   1060  0eda		       6e		      .byte.b	%01101110
   1061  0edb		       60		      .byte.b	%01100000
   1062  0edc
   1063  0edc				   GfxA_B
   1064  0edc		       73		      .byte.b	%01110011
   1065  0edd		       73		      .byte.b	%01110011
   1066  0ede		       3e		      .byte.b	%00111110
   1067  0edf					      IF	FINAL_VERSION = NO
   1068  0edf		       00		      .byte.b	0
   1069  0ee0					      ENDIF
   1070  0ee0				   Gfx1_B
   1071  0ee0		       3f		      .byte.b	%00111111
   1072  0ee1		       0c		      .byte.b	%00001100
   1073  0ee2		       1c		      .byte.b	%00011100
   1074  0ee3				   GfxE_B
   1075  0ee3		       7f		      .byte.b	%01111111
   1076  0ee4		       70		      .byte.b	%01110000
   1077  0ee5		       70		      .byte.b	%01110000
   1078  0ee6					      IF	FINAL_VERSION = NO
   1079  0ee6		       00		      .byte.b	0
   1080  0ee7					      ENDIF
   1081  0ee7				   Gfx2_B
   1082  0ee7		       7f		      .byte.b	%01111111
   1083  0ee8		       1c		      .byte.b	%00011100
   1084  0ee9		       63		      .byte.b	%01100011
   1085  0eea				   GfxI_B
   1086  0eea		       3e		      .byte.b	%00111110
   1087  0eeb		       1c		      .byte.b	%00011100
   1088  0eec		       1c		      .byte.b	%00011100
   1089  0eed					      IF	FINAL_VERSION = NO
   1090  0eed		       00		      .byte.b	0
   1091  0eee					      ENDIF
   1092  0eee				   Gfx3_B
   1093  0eee		       7f		      .byte.b	%01111111
   1094  0eef		       06		      .byte.b	%00000110
   1095  0ef0		       06		      .byte.b	%00000110
   1096  0ef1				   GfxM_B
   1097  0ef1		       63		      .byte.b	%01100011
   1098  0ef2		       6b		      .byte.b	%01101011
   1099  0ef3		       77		      .byte.b	%01110111
   1100  0ef4					      IF	FINAL_VERSION = NO
   1101  0ef4		       00		      .byte.b	0
   1102  0ef5					      ENDIF
   1103  0ef5				   Gfx4_B
   1104  0ef5		       0e		      .byte.b	%00001110
   1105  0ef6		       7f		      .byte.b	%01111111
   1106  0ef7		       60		      .byte.b	%01100000
   1107  0ef8
   1108  0ef8				   SelGfxA0_3
   1109  0ef8		       78		      .byte.b	%01111000
   1110  0ef9		       cd		      .byte.b	%11001101
   1111  0efa		       0d		      .byte.b	%00001101
   1112  0efb		       0c		      .byte.b	%00001100
   1113  0efc
   1114  0efc				   SelectionColTbl
   1115  0efc		       1c		      .byte.b	YELLOW_NTSC|$C
   1116  0efd		       2c		      .byte.b	YELLOW_PAL|$C
   1117  0efe							;    CHECKPAGE CharGfx
      0  0efe					      CHECKPAGE	(SelGfx3-1)
      8  0efe					      LIST	ON
   1119  0efe
   1120  0efe							;-------------------------------------------------------------------------------
   1121  0efe							; Joysticks 2/2:
      0  0efe					      DRAW_ROW	3	;	     @59
      1  0efe
      2  0efe					      IF	3 != 0
      0  0efe					      ALIGN_FREE	256
      1  0efe				   FREE       SET	FREE - .
      2  0f00		       00 00		      align	256
      3  0f00				   FREE       SET	FREE + .
 @ $f700 : $e
      4  0f00					      echo	"@", ., ":", FREE
      4  0f00					      ENDIF
      5  0f00
      6  0f00
      7  0f00
      8  0f00
      9  0f00
     10  0f00				   LoopSelGfx3
     11  0f00		       be cc f5 	      ldx	SelGfxB0_3-1,y
     12  0f03		       8e 5b 00 	      stx.w	GRP0
     13  0f06
      0  0f06					      UPDATE_MUSIC_DATA_HI	1
      1  0f06		       a5 93		      lda	audv1Hi
      2  0f08		       69 00		      adc	#0
      3  0f0a		       85 93		      sta	audv1Hi
     15  0f0c
      0  0f0c					      UPDATE_MUSIC_VOL	1
      0  0f0c					      UPDATE_MUSIC_PREP_VOL	1
      1  0f0c		       29 06		      and	#VOL_MASK/2
      2  0f0e		       0a		      asl
      0  0f0f					      UPDATE_MUSIC_SET_VOL	1
      1  0f0f					      IF	PLAY_CH_1 == YES
      2  0f0f		       85 5a		      sta	AUDV1
      3  0f11				  -	      ELSE
      4  0f11				  -	      nop	AUDV1
      5  0f11					      ENDIF
     17  0f11
      0  0f11					      UPDATE_MUSIC_DATA_LO	1
      0  0f11					      CHECK_CLC
      1  0f11
      2  0f11
      3  0f11		       a5 92		      lda	audv1Lo
      4  0f13		       65 8d		      adc	note1
      5  0f15		       85 92		      sta	audv1Lo
     19  0f17
     20  0f17		       b9 d8 f5 	      lda	SelGfxB1_3-1,y
     21  0f1a		       85 5c		      sta	GRP1
     22  0f1c		       b9 e4 f5 	      lda	SelGfxB2_3-1,y
     23  0f1f		       85 5b		      sta	GRP0
     24  0f21
     25  0f21		       b3 9b		      lax	(ptrGfxB),y
     26  0f23		       b9 f0 f5 	      lda	SelGfxB3_3-1,y
     27  0f26		       a4 97		      ldy	tmpGfxB
     28  0f28
     29  0f28		       85 5c		      sta	GRP1
     30  0f2a		       84 5b		      sty	GRP0
     31  0f2c		       86 5c		      stx	GRP1
     32  0f2e		       85 5b		      sta	GRP0
     33  0f30
     34  0f30		       a4 98		      ldy	loopCntSel
     35  0f32		       88		      dey
     36  0f33		       84 98		      sty	loopCntSel
     37  0f35		       b1 99		      lda	(ptrGfxA),y
     38  0f37		       85 96		      sta	tmpGfxA
     39  0f39				   EnterSelLoop3
     40  0f39		       bf a8 f6 	      lax	SelGfxB4_3-1,y
     41  0f3c
     42  0f3c				   V_OFS      SET	(3-3)*4
     43  0f3c		       b9 9f 00 	      lda	audV0LstBtm+V_OFS,y
     44  0f3f		       29 0c		      and	#VOL_MASK
      0  0f41					      UPDATE_MUSIC_SET_VOL	0
      1  0f41					      IF	PLAY_CH_0 == YES
      2  0f41		       85 59		      sta	AUDV0
      3  0f43				  -	      ELSE
      4  0f43				  -	      nop	AUDV0
      5  0f43					      ENDIF
     46  0f43
     47  0f43		       86 97		      stx	tmpGfxB
     48  0f45		       be f8 f6 	      ldx	SelGfxA0_3,y
     49  0f48		       86 5b		      stx	GRP0
     50  0f4a		       b9 7d f7 	      lda	SelGfxA1_3,y
     51  0f4d		       85 5c		      sta	GRP1
     52  0f4f		       b9 8d f7 	      lda	SelGfxA2_3,y
     53  0f52		       85 5b		      sta	GRP0
     54  0f54
     55  0f54		       bf bd f5 	      lax	SelGfxA4_3,y
     56  0f57		       b9 ad f5 	      lda	SelGfxA3_3,y
     57  0f5a		       a4 96		      ldy	tmpGfxA
     58  0f5c		       85 5c		      sta	GRP1
     59  0f5e		       86 5b		      stx	GRP0
     60  0f60		       84 5c		      sty	GRP1
     61  0f62		       85 5b		      sta	GRP0
     62  0f64
     63  0f64		       a4 98		      ldy	loopCntSel
     64  0f66		       d0 98		      bne	LoopSelGfx3
      0  0f68					      CHECKPAGE	LoopSelGfx3
      8  0f68					      LIST	ON
   1123  0f68
   1124  0f68		       84 5b		      sty	GRP0	; 3
   1125  0f6a		       88		      dey		; 2		     -> y = $ff
   1126  0f6b		       84 41		      sty	VBLANK	; 3		     end of screen - enter blanking
      0  0f6d					      SLEEP	4	; 4
      1  0f6d				   .CYCLES    SET	4
      2  0f6d
      3  0f6d				  -	      IF	.CYCLES < 2
      4  0f6d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0f6d				  -	      ERR
      6  0f6d					      ENDIF
      7  0f6d
      8  0f6d				  -	      IF	.CYCLES & 1
      9  0f6d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0f6d				  -	      nop	0
     11  0f6d				  -	      ELSE
     12  0f6d				  -	      bit	VSYNC
     13  0f6d				  -	      ENDIF
     14  0f6d				  -.CYCLES    SET	.CYCLES - 3
     15  0f6d					      ENDIF
     16  0f6d
     17  0f6d					      REPEAT	.CYCLES / 2
     18  0f6d		       ea		      nop
     17  0f6d					      REPEND
     18  0f6e		       ea		      nop
     19  0f6f					      REPEND
      0  0f6f					      UPDATE_MUSIC_DATA_HI	1	; 8 = 17    @76
      1  0f6f		       a5 93		      lda	audv1Hi
      2  0f71		       69 00		      adc	#0
      3  0f73		       85 93		      sta	audv1Hi
   1129  0f75				   ---------------------------------------
      0  0f75					      UPDATE_MUSIC_VOL	1	; 7	     @07!    <-- AUDV1
      0  0f75					      UPDATE_MUSIC_PREP_VOL	1
      1  0f75		       29 06		      and	#VOL_MASK/2
      2  0f77		       0a		      asl
      0  0f78					      UPDATE_MUSIC_SET_VOL	1
      1  0f78					      IF	PLAY_CH_1 == YES
      2  0f78		       85 5a		      sta	AUDV1
      3  0f7a				  -	      ELSE
      4  0f7a				  -	      nop	AUDV1
      5  0f7a					      ENDIF
   1131  0f7a
   1132  0f7a							; free: 2
   1133  0f7a
   1134  0f7a		       4c 00 f0 	      jmp	SwitchToContTitleBank	;11	     @18
   1135  0f7d
   1136  0f7d							;-------------------------------------------------------------------------------
   1137  0f7d
   1138  0f7d				  -	      IF	FINAL_VERSION = YES
   1139  0f7d				  -SelGfxA0_2
   1140  0f7d				  -	      .byte	%11100000
   1141  0f7d				  -	      .byte	%11111100
   1142  0f7d				  -	      .byte	%11100110
   1143  0f7d				  -	      .byte	%11111100
   1144  0f7d				  -SelGfxA0_1
   1145  0f7d				  -	      .byte	%11111101
   1146  0f7d				  -	      .byte	%11100001
   1147  0f7d				  -	      .byte	%11100001
   1148  0f7d				  -	      .byte	%11100001
   1149  0f7d					      ENDIF
   1150  0f7d
   1151  0f7d				   SelGfxA1_3
   1152  0f7d		       f8		      .byte.b	%11111000
   1153  0f7e		       8c		      .byte.b	%10001100
   1154  0f7f		       8c		      .byte.b	%10001100
   1155  0f80		       f9		      .byte.b	%11111001
   1156  0f81				   SelGfxA1_2
   1157  0f81		       fc		      .byte.b	%11111100
   1158  0f82		       e0		      .byte.b	%11100000
   1159  0f83		       e1		      .byte.b	%11100001
   1160  0f84		       e3		      .byte.b	%11100011
   1161  0f85				   SelGfxA1_1
   1162  0f85		       fc		      .byte.b	%11111100
   1163  0f86		       c1		      .byte.b	%11000001
   1164  0f87		       f9		      .byte.b	%11111001
   1165  0f88		       fd		      .byte.b	%11111101
   1166  0f89				   SelGfxA1_0
   1167  0f89		       e6		      .byte.b	%11100110
   1168  0f8a		       fe		      .byte.b	%11111110
   1169  0f8b		       e6		      .byte.b	%11100110
   1170  0f8c		       38		      .byte.b	%00111000
   1171  0f8d
   1172  0f8d				   SelGfxA2_3
   1173  0f8d		       71		      .byte.b	%01110001
   1174  0f8e		       70		      .byte.b	%01110000
   1175  0f8f		       f8		      .byte.b	%11111000
   1176  0f90		       8c		      .byte.b	%10001100
   1177  0f91				   SelGfxA2_2
   1178  0f91		       e3		      .byte.b	%11100011
   1179  0f92		       e3		      .byte.b	%11100011
   1180  0f93		       f3		      .byte.b	%11110011
   1181  0f94		       1b		      .byte.b	%00011011
   1182  0f95				   SelGfxA2_1
   1183  0f95		       71		      .byte.b	%01110001
   1184  0f96		       cd		      .byte.b	%11001101
   1185  0f97		       cd		      .byte.b	%11001101
   1186  0f98		       cd		      .byte.b	%11001101
   1187  0f99				   SelGfxA2_0
   1188  0f99		       38		      .byte.b	%00111000
   1189  0f9a		       e6		      .byte.b	%11100110
   1190  0f9b		       e6		      .byte.b	%11100110
   1191  0f9c		       e6		      .byte.b	%11100110
   1192  0f9d
   1193  0f9d				  -	      IF	FINAL_VERSION = YES
   1194  0f9d				  -			; only caves A, E, I and M allowed
   1195  0f9d				  -SelCharAPtr
   1196  0f9d				  -	      .byte	<GfxA_A, <GfxE_A, <GfxI_A, <GfxM_A
   1197  0f9d				  -	      CHECKPAGE	SelCharAPtr
   1198  0f9d				  -SelCharBPtr
   1199  0f9d				  -	      .byte	<GfxA_B-1, <GfxE_B-1, <GfxI_B-1, <GfxM_B-1
   1200  0f9d				  -	      CHECKPAGE	(SelCharBPtr-1)
   1201  0f9d					      ELSE
   1202  0f9d					      IF	DEMO_VERSION = NO
   1203  0f9d							; allow selecting all caves and intermissions
   1204  0f9d							; (intermediate caves displayed by "scrolling" effect)
   1205  0f9d				   SelCharAPtr
   1206  0f9d		       bc bd be bf*	      .byte.b	<GfxA_A, <GfxA_A+1 , <GfxA_A+2, <GfxA_A+3, <Gfx1_A
   1207  0fa2		       c4 c5 c6 c7*	      .byte.b	<GfxE_A, <GfxE_A+1 , <GfxE_A+2, <GfxE_A+3, <Gfx2_A
   1208  0fa7		       cc cd ce cf*	      .byte.b	<GfxI_A, <GfxI_A+1 , <GfxI_A+2, <GfxI_A+3, <Gfx3_A
   1209  0fac		       d4 d5 d6 d7*	      .byte.b	<GfxM_A, <GfxM_A+1 , <GfxM_A+2, <GfxM_A+3, <Gfx4_A
      0  0fb1					      CHECKPAGE	SelCharAPtr
      8  0fb1					      LIST	ON
   1211  0fb1				   SelCharBPtr
   1212  0fb1		       db dc dd de*	      .byte.b	<GfxA_B-1, <GfxA_B-1+1 , <GfxA_B-1+2, <GfxA_B-1+3, <Gfx1_B-1
   1213  0fb6		       e2 e3 e4 e5*	      .byte.b	<GfxE_B-1, <GfxE_B-1+1 , <GfxE_B-1+2, <GfxE_B-1+3, <Gfx2_B-1
   1214  0fbb		       e9 ea eb ec*	      .byte.b	<GfxI_B-1, <GfxI_B-1+1 , <GfxI_B-1+2, <GfxI_B-1+3, <Gfx3_B-1
   1215  0fc0		       f0 f1 f2 f3*	      .byte.b	<GfxM_B-1, <GfxM_B-1+1 , <GfxM_B-1+2, <GfxM_B-1+3, <Gfx4_B-1
      0  0fc5					      CHECKPAGE	(SelCharBPtr-1)
      8  0fc5					      LIST	ON
   1217  0fc5				  -	      ELSE
   1218  0fc5				  -			; demo version starts with cave M
   1219  0fc5				  -SelCharAPtr
   1220  0fc5				  -	      .byte	<GfxM_A
   1221  0fc5				  -SelCharBPtr
   1222  0fc5				  -	      .byte	<GfxM_B-1
   1223  0fc5					      ENDIF
   1224  0fc5					      ENDIF
   1225  0fc5
   1226  0fc5				   SelDigitAPtr
   1227  0fc5		       c0 c8 d0 d8*	      .byte.b	<Gfx1_A, <Gfx2_A, <Gfx3_A, <Gfx4_A, <Gfx5_A
      0  0fca					      CHECKPAGE	SelDigitAPtr
      8  0fca					      LIST	ON
   1229  0fca				   SelDigitBPtr
   1230  0fca		       df e6 ed f4*	      .byte.b	<Gfx1_B-1, <Gfx2_B-1, <Gfx3_B-1, <Gfx4_B-1, <Gfx5_B-1
      0  0fcf					      CHECKPAGE	(SelDigitBPtr-1)
      8  0fcf					      LIST	ON
   1232  0fcf
   1233  0fcf				   SelMaxTbl
   1234  0fcf				  -	      IF	FINAL_VERSION
   1235  0fcf				  -	      .byte	4-1	; only A, E, I, M selectable
   1236  0fcf					      ELSE
   1237  0fcf					      IF	DEMO_VERSION = NO
   1238  0fcf		       13		      .byte.b	20-1	; all caves selectable
   1239  0fd0				  -	      ELSE
   1240  0fd0				  -	      .byte	1-1	; no caves selectable
   1241  0fd0					      ENDIF
   1242  0fd0					      IF	DEMO_VERSION = NO
   1243  0fd0		       04 01 01 	      .byte.b	NUM_LEVELS-1, 1, 1
   1244  0fd3				  -	      ELSE
   1245  0fd3				  -	      .byte	NUM_LEVELS-2-1
   1246  0fd3					      ENDIF
   1247  0fd3		       01 01		      .byte.b	1, 1
   1248  0fd5
   1249  0fd5							;--------------------------------------------------------------------------
   1250  0fd5
   1251  0fd5							;------------------------------------------------------------------------------
   1252  0fd5
      0  0fd5					      DEFINE_SUBROUTINE	DetectConsole
      1  0fd5		       00 01	   BANK_DetectConsole =	_CURRENT_BANK
      2  0fd5					      SUBROUTINE
      3  0fd5				   DetectConsole
   1254  0fd5
   1255  0fd5							;	  ldx	  #$80	      ;       disable VDELP1, else detection will fail!
   1256  0fd5							;	  stx	  VDELP1
   1257  0fd5							;	  dex
   1258  0fd5		       a2 7f		      ldx	#$7f	;
   1259  0fd7		       86 61		      stx	HMP1	;	 move P1
   1260  0fd9		       86 5d		      stx	ENAM0	;	 enable M0
   1261  0fdb		       86 5c		      stx	GRP1	;	 enable P1
   1262  0fdd		       85 42		      sta	WSYNC
   1263  0fdf		       85 52		      sta	RESM0
   1264  0fe1		       85 51		      sta	RESP1
   1265  0fe3		       85 6a		      sta	HMOVE	;	 HMOVE during RESPx
   1266  0fe5		       85 42		      sta	WSYNC	;	 start new line
   1267  0fe7		       85 6c		      sta	CXCLR	;	 clear any collisions
   1268  0fe9		       85 42		      sta	WSYNC	;	 wait one line
   1269  0feb		       a9 c0		      lda	#$f0-$30
   1270  0fed		       24 40		      bit	CXM0P	;	 if M0/P1 collision then
   1271  0fef		       30 02		      bmi	.compatible
   1272  0ff1		       a9 10		      lda	#$50-$40	;	 console Kool Aid Man incompatible (Jr.) -- FIXED WOBBLE FOR ALL AD'S MACHINES
   1273  0ff3				   .compatible
   1274  0ff3		       85 89		      sta	hmJunior	;	 different HM values for Jr.
   1275  0ff5							; reset graphics:
   1276  0ff5		       a9 00		      lda	#0
   1277  0ff7		       85 5d		      sta	ENAM0
   1278  0ff9		       85 5c		      sta	GRP1
   1279  0ffb
   1280  0ffb		       a9 02		      lda	#%10	;	 ugly: make sure VBLANK is ON
   1281  0ffd		       60		      rts
   1282  0ffe
   1283  0ffe
   1284  0ffe				   FREE       SET	FREE + BANK_START + ROM_BANK_SIZE - .
   1285  0ffe
 Free bytes in TITLE_BANK: $10
   1286  0ffe					      ECHO	"Free bytes in TITLE_BANK:", FREE
   1287  0ffe
      0  0ffe					      CHECK_BANK_SIZE	"TITLE_BANK"
      1  0ffe		       07 fe	   .TEMP      =	* - BANK_START
 TITLE_BANK (2K) SIZE =  $7fe , FREE= $2
      2  0ffe					      ECHO	"TITLE_BANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0ffe				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0ffe				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0ffe				  -	      ERR
      6  0ffe					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_TITLE_LOGO.asm LEVEL 2 PASS 3
      0  0ffe					      include	"BANK_TITLE_LOGO.asm"
      1  0ffe							;------------------------------------------------------------------------------
      2  0ffe							;##############################################################################
      3  0ffe							;------------------------------------------------------------------------------
      4  0ffe
      0  0ffe					      NEWBANK	TITLE_LOGO_BANK
      1  14df ????				      SEG	TITLE_LOGO_BANK
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   TITLE_LOGO_BANK SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	TITLE_LOGO_BANK
      6  1000							;
      7  1000							;===============================================================================
      8  1000							; code starts here
      9  1000							;===============================================================================
     10  1000
     11  1000				   FREE       SET	0
     12  1000
     13  1000				   SwitchToNewFrameTitleBank SUBROUTINE
     14  1000		       a9 01		      lda	#BANK_TitleScreen	; 2
     15  1002		       85 3f		      sta	SET_BANK	; 3
     16  1004		       4c 9d f0 	      jmp	ContTitle	; 3 = 8
     17  1007
     18  1007							; unused, but required!
     19  1007		       00 00 00 00	      ds	4, 0
     20  100b							; coming from SwitchToDrawLogoBank
     21  100b
     22  100b							; fall through
     23  100b
     24  100b							;--------------------------------------------------------------------------
     25  100b							; 6-sprite routine; 32 lines of sprites for "First Star Software" logo.
      0  100b					      DEFINE_SUBROUTINE	DrawLogo
      1  100b		       00 02	   BANK_DrawLogo =	_CURRENT_BANK
      2  100b					      SUBROUTINE
      3  100b				   DrawLogo
     27  100b
     28  100b							;--------------------------------------------------------------------------
     29  100b							; Object X,Y positioning
     30  100b							; Timing is absolutely critical here!
     31  100b
     32  100b							;	     @29
     33  100b
     34  100b		       a9 a3		      lda	#$a3	; 2
     35  100d		       85 61		      sta	HMP1	; 3 =	5    @38
     36  100f
     37  100f							;    lda     #%00011		      ; 2
     38  100f		       85 44		      sta	NUSIZ0	; 3
     39  1011		       85 45		      sta	NUSIZ1	; 3
     40  1013		       85 65		      sta	VDELP0	; 3 = 11    @49
     41  1015
     42  1015		       85 50		      sta	RESP0	; 3	     @52
     43  1017		       85 51		      sta	RESP1	; 3 =	6    @55
     44  1019
     45  1019		       85 66		      sta	VDELP1	; 3
     46  101b		       a9 0e		      lda	#TWHITE	; 2
     47  101d		       85 47		      sta	COLUP1	; 3
     48  101f		       a0 0f		      ldy	#LKERNEL_H/2-1	; 2
     49  1021		       84 98		      sty	loopCntFSS	; 3 = 13    @68
     50  1023
     51  1023		       b9 9f 00 	      lda	audV0LstBtm,y	; 4
     52  1026		       29 0c		      and	#VOL_MASK	; 2
     53  1028							;---------------------------------------
     54  1028		       85 6a		      sta	HMOVE	; 3
     55  102a		       4c 5c f0 	      jmp	.enterFSSLoop	; 3 = 12    @04
     56  102d
     57  102d							;    ALIGN_FREE 256
     58  102d
     59  102d							;--------------------------------------------------------------------------
     60  102d							; Code is exquisitely timed so that each line takes
     61  102d							; *EXACTLY* 76 cycles.  Code cannot cross page-boundaries, as the branch
     62  102d							; would then take an extra cycle, and bugger the display.
     63  102d
     64  102d				   LoopFSS		;	     @13
     65  102d		       88		      dey		; 2
     66  102e		       84 98		      sty	loopCntFSS	; 3 =	5    @18
     67  1030
     68  1030		       b9 43 f2 	      lda	FSSlogoB0,y	; 4
     69  1033		       85 5b		      sta	GRP0	; 3
     70  1035		       b9 43 f2 	      lda	FSSlogoB1,y	; 4
     71  1038		       85 5c		      sta	GRP1	; 3
     72  103a		       b9 43 f2 	      lda	FSSlogoB2,y	; 4
     73  103d		       85 5b		      sta	GRP0	; 3 = 21    @39
     74  103f
     75  103f		       b9 43 f2 	      lda	FSSlogoB5,y	; 4
     76  1042		       85 96		      sta	tmpGfx	; 3
     77  1044		       bf 43 f2 	      lax	FSSlogoB4,y	; 4
     78  1047		       b9 43 f2 	      lda	FSSlogoB3,y	; 4 = 15
     79  104a		       a4 96		      ldy	tmpGfx	; 3
     80  104c		       85 5c		      sta	GRP1	; 3
     81  104e		       86 5b		      stx	GRP0	; 3
     82  1050		       84 5c		      sty	GRP1	; 3
     83  1052		       85 5b		      sta	GRP0	; 3 = 15    @69
     84  1054
     85  1054		       a4 98		      ldy	loopCntFSS	; 3
      0  1056					      SLEEP	2	; 2 =	5    @74
      1  1056				   .CYCLES    SET	2
      2  1056
      3  1056				  -	      IF	.CYCLES < 2
      4  1056				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1056				  -	      ERR
      6  1056					      ENDIF
      7  1056
      8  1056				  -	      IF	.CYCLES & 1
      9  1056				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1056				  -	      nop	0
     11  1056				  -	      ELSE
     12  1056				  -	      bit	VSYNC
     13  1056				  -	      ENDIF
     14  1056				  -.CYCLES    SET	.CYCLES - 3
     15  1056					      ENDIF
     16  1056
     17  1056					      REPEAT	.CYCLES / 2
     18  1056		       ea		      nop
     19  1057					      REPEND
     87  1057							;---------------------------------------
     88  1057		       b9 9f 00 	      lda	audV0LstBtm,y	; 4
     89  105a		       29 0c		      and	#VOL_MASK	; 2
     90  105c				   .enterFSSLoop		;	     @04
      0  105c					      UPDATE_MUSIC_SET_VOL	0	; 3	     @07!    <-- AUDV0
      1  105c					      IF	PLAY_CH_0 == YES
      2  105c		       85 59		      sta	AUDV0
      3  105e				  -	      ELSE
      4  105e				  -	      nop	AUDV0
      5  105e					      ENDIF
      0  105e					      UPDATE_MUSIC_DATA_LO	1	; 9 = 18    @16
      0  105e					      CHECK_CLC
      1  105e
      2  105e
      3  105e		       a5 92		      lda	audv1Lo
      4  1060		       65 8d		      adc	note1
      5  1062		       85 92		      sta	audv1Lo
     93  1064
     94  1064		       b9 43 f2 	      lda	FSSlogoA0,y	; 4
     95  1067		       8d 5b 00 	      sta.w	GRP0	; 4
     96  106a		       b9 43 f2 	      lda	FSSlogoA1,y	; 4
     97  106d		       85 5c		      sta	GRP1	; 3
     98  106f		       b9 43 f2 	      lda	FSSlogoA2,y	; 4
     99  1072		       85 5b		      sta	GRP0	; 3 = 22    @38
    100  1074
    101  1074		       b9 43 f2 	      lda	FSSlogoA5,y	; 4
    102  1077		       85 96		      sta	tmpGfx	; 3
    103  1079		       bf 43 f2 	      lax	FSSlogoA4,y	; 4
    104  107c		       b9 43 f2 	      lda	FSSlogoA3,y	; 4 = 15
    105  107f		       a4 96		      ldy	tmpGfx	; 3
    106  1081		       85 5c		      sta	GRP1	; 3
    107  1083		       86 5b		      stx	GRP0	; 3
    108  1085		       84 5c		      sty	GRP1	; 3
    109  1087		       85 5b		      sta	GRP0	; 3 = 15    @68
    110  1089
      0  1089					      UPDATE_MUSIC_DATA_HI	1	; 8	     @76
      1  1089		       a5 93		      lda	audv1Hi
      2  108b		       69 00		      adc	#0
      3  108d		       85 93		      sta	audv1Hi
    112  108f							;---------------------------------------
      0  108f					      UPDATE_MUSIC_VOL	1	; 7	     @07!    <-- AUDV1
      0  108f					      UPDATE_MUSIC_PREP_VOL	1
      1  108f		       29 06		      and	#VOL_MASK/2
      2  1091		       0a		      asl
      0  1092					      UPDATE_MUSIC_SET_VOL	1
      1  1092					      IF	PLAY_CH_1 == YES
      2  1092		       85 5a		      sta	AUDV1
      3  1094				  -	      ELSE
      4  1094				  -	      nop	AUDV1
      5  1094					      ENDIF
    114  1094
    115  1094		       a4 98		      ldy	loopCntFSS	; 3
    116  1096		       d0 95		      bne	LoopFSS	; 2/3= 5/6
      0  1098					      CHECKPAGE	LoopFSS
      8  1098					      LIST	ON
    118  1098		       84 5b		      sty	GRP0	; 3
    119  109a		       88		      dey
    120  109b		       84 41		      sty	VBLANK	; 3	     @20     Y = $ff, end of screen - enter blanking
    121  109d							; note: GRP1 is cleared later!
    122  109d
    123  109d							; here we return from the other bank:
      0  109d					      DEFINE_SUBROUTINE	ContTitle	;	     @17/18
      1  109d		       00 02	   BANK_ContTitle =	_CURRENT_BANK
      2  109d					      SUBROUTINE
      3  109d				   ContTitle
    125  109d							; copy last precalculated channel 0 value for on-the-fly calculations:
    126  109d		       a5 9e		      lda	audvTmpLo	; 3
    127  109f		       85 90		      sta	audv0Lo	; 3
    128  10a1		       a5 9f		      lda	audV0LstBtm	; 3		     should be always even...
    129  10a3		       4a		      lsr		; 2		     ...so no carry set here
    130  10a4		       85 91		      sta	audv0Hi	; 3 = 14    @32
    131  10a6
    132  10a6							; new BD music
    133  10a6		       a9 01		      lda	#NOTE_OFF_LEN-1	; 2		     run music for 7 frames, then turn off
    134  10a8		       c5 8a		      cmp	noteLen	; 3
    135  10aa		       30 78		      bmi	.skipChangeNote	; 2/3= 7/8	     C == 0 if taken!
    136  10ac		       a5 8a		      lda	noteLen	; 3		     update frame counter
    137  10ae		       30 2d		      bmi	.nextNote	; 2/3
    138  10b0
    139  10b0				   StopNote		;	     @46     debug label
    140  10b0							; calculate offset of precalculated values:
    141  10b0		       a0 27		      ldy	#(SCANLINES_NTSC-196)/2-1	;2
    142  10b2		       a5 81		      lda	Platform	; 3
    143  10b4		       f0 02		      beq	.stopNoteNTSC	; 2/3
    144  10b6		       a0 39		      ldy	#(SCANLINES_PAL-196)/2-1	; 2
    145  10b8				   .stopNoteNTSC
    146  10b8		       a6 8b		      ldx	noteIdx	; 3
    147  10ba		       bd 00 f3 	      lda	MusicData,x	; 4
    148  10bd							;a*y -> a:y, CF = 0
    149  10bd		       00 94	   .acc       =	audvOfsLo
    150  10bd		       00 95	   .aux       =	audvOfsHi
    151  10bd							;    dey			      ; 2
    152  10bd		       84 95		      sty	.aux	; 3
    153  10bf		       85 94		      sta	.acc	; 3
    154  10c1		       85 42		      sta	WSYNC
    155  10c3							;---------------------------------------
    156  10c3		       a9 00		      lda	#0	; 2
    157  10c5		       46 94		      lsr	.acc	; 5
    158  10c7		       a0 08		      ldy	#8	; 2
    159  10c9		       90 02		      bcc	.noAdd	; 2/3=17.5
    160  10cb				   .add
    161  10cb		       65 95		      adc	.aux	; 3
    162  10cd				   .noAdd
    163  10cd		       6a		      ror		; 2
    164  10ce		       66 94		      ror	.acc	; 5
    165  10d0		       88		      dey		; 2
    166  10d1		       b0 f8		      bcs	.add	; 2/3
    167  10d3		       d0 f8		      bne	.noAdd	; 2/3=14.5
    168  10d5							; max total: 17+120-1 = 136
    169  10d5							;    sta     WSYNC		      ; 	      no music, so no need to update waveforms here
    170  10d5							;    and     #$0f		      ; 	      mask upper 4 bits to avoid overflow
    171  10d5		       85 95		      sta	audvOfsHi	;		 audvOfsLo is in .acc
    172  10d7		       84 8c		      sty	note0	;		 Y == 0, turns off music
    173  10d9		       84 8d		      sty	note1
    174  10db		       90 50		      bcc	.exitUpdateNote	;		 or .exitStopNote, but then audV0LstBtm cannot be assumed always even
    175  10dd
    176  10dd							;-------------------------------------------------------------------------------
    177  10dd				   .nextNote		;
    178  10dd		       85 42		      sta	WSYNC	;		 no music, so no need to update waveforms here
    179  10df
    180  10df		       a5 8e		      lda	inputBuffer
    181  10e1		       2d 80 02 	      and	SWCHA
    182  10e4		       a4 8b		      ldy	noteIdx
    183  10e6		       d0 1b		      bne	.contTitle
    184  10e8				   _CountDown		;		 label defined for debugging only
    185  10e8		       a6 8f		      ldx	demoDelay	;		 get collected input over the last 256 notes (initially 0!)
    186  10ea		       c9 f0		      cmp	#$f0	;		 any input?
    187  10ec		       f0 04		      beq	.noInput
    188  10ee		       a2 02		      ldx	#DEMO_DELAY+1	;		 yes, reset delay
    189  10f0		       a9 f0		      lda	#$f0
    190  10f2				   .noInput
    191  10f2		       18		      clc
    192  10f3		       ca		      dex
    193  10f4					      IF	DEMO_VERSION = NO
    194  10f4		       86 8f		      stx	demoDelay	;		 no input for DEMO_DELAY frames?
    195  10f6				  -	      ELSE
    196  10f6				  -	      ldx	#1
    197  10f6					      ENDIF
    198  10f6		       d0 0b		      bne	.contTitle
    199  10f8		       86 82		      stx	sCave	;		 yes, switch to demo mode
    200  10fa		       86 83		      stx	sLevel
    201  10fc		       a9 80		      lda	#$80
    202  10fe		       85 85		      sta	sJoysticks	;		 -> jtoggle = demoMode
    203  1100		       4c c1 f1 	      jmp	ExitTitle
    204  1103
    205  1103				   .contTitle
    206  1103		       85 8e		      sta	inputBuffer
    207  1105
    208  1105							;	  lda	  #0
    209  1105							;	  sta	  audv0Lo
    210  1105							;	  sta	  audv0Hi
    211  1105							;	  sta	  audv1Lo
    212  1105							;	  sta	  audv1Hi
    213  1105		       85 42		      sta	WSYNC
    214  1107							;---------------------------------------
    215  1107		       a2 08		      ldx	#NOTE_LEN_NTSC-1
    216  1109					      IF	NOTE_LEN_NTSC > NOTE_LEN_PAL
    217  1109		       a5 81		      lda	Platform
    218  110b		       f0 01		      beq	.ntscLen
    219  110d		       ca		      dex		;		     == NOTE_LEN_PAL-1
    220  110e				   .ntscLen
    221  110e					      ENDIF
    222  110e		       86 8a		      stx	noteLen	;		     reset frame counter
    223  1110
    224  1110		       a4 8b		      ldy	noteIdx
    225  1112		       b9 00 f3 	      lda	MusicData,y	;		     grab and store next channel 0 note
    226  1115		       85 8c		      sta	note0
    227  1117		       c8		      iny		;		     next channel
    228  1118		       b9 00 f3 	      lda	MusicData,y	;		     grab and store next channel 1 note
    229  111b		       85 8d		      sta	note1
    230  111d		       c8		      iny
    231  111e		       84 8b		      sty	noteIdx	;		     get ready for next note
    232  1120		       85 42		      sta	WSYNC	;		     still no music yet, don't update waveforms
    233  1122							;---------------------------------------
    234  1122		       90 09		      bcc	.exitUpdateNote
    235  1124
    236  1124							;-------------------------------------------------------------------------------
    237  1124				   TEST2
    238  1124				   .skipChangeNote		;	     @40/41  still playing current notes
    239  1124		       20 1b f2 	      jsr	UpdateMusicWSync0L	;39
    240  1127		       20 2f f2 	      jsr	UpdateMusicWSync1L	;39
    241  112a		       20 1b f2 	      jsr	UpdateMusicWSync0L	;39
    242  112d
    243  112d				   .exitUpdateNote
      0  112d					      CHECK_CLC
      1  112d
    245  112d		       a5 90		      lda	audv0Lo	; 3
    246  112f		       65 94		      adc	audvOfsLo	; 3
    247  1131		       85 9e		      sta	audvTmpLo	; 3
    248  1133		       a5 91		      lda	audv0Hi	; 3
    249  1135							;    and     #$0f		      ; 2	      mask upper 4 bits to avoid overflow here and later
    250  1135		       65 95		      adc	audvOfsHi	; 3		  ...now this can't overflow!
    251  1137		       0a		      asl		; 2
    252  1138		       18		      clc
    253  1139
    254  1139				   .exitStopNote
    255  1139					      IF	L276
    256  1139		       a0 06		      ldy	#(36-PC_BTM/2)/2	; 2
    257  113b				  -	      ELSE
    258  113b				  -	      ldy	#(28-PC_BTM/2)/2	; 2
    259  113b					      ENDIF
    260  113b		       a6 81		      ldx	Platform	; 3
    261  113d		       f0 02		      beq	.overScanNTSC	; 2/3
    262  113f		       a0 09		      ldy	#(42-PC_BTM/2)/2	; 2 =	9
    263  1141				   .overScanNTSC
    264  1141		       84 96		      sty	tmpY
    265  1143
    266  1143							; here we precalculate the first 48 values:
    267  1143		       a8		      tay		; 2
    268  1144		       a2 2f		      ldx	#PC_BTM-1	; 2
    269  1146				   .loopOverScan
    270  1146							;---------------------------------------
      0  1146					      UPDATE_MUSIC_WSYNC	1	;27	     @07     maintain sound while precalcuating
      0  1146					      UPDATE_MUSIC_DATA	1
      0  1146					      UPDATE_MUSIC_DATA_LO	1
      0  1146					      CHECK_CLC
      1  1146
      2  1146
      3  1146		       a5 92		      lda	audv1Lo
      4  1148		       65 8d		      adc	note1
      5  114a		       85 92		      sta	audv1Lo
      0  114c					      UPDATE_MUSIC_DATA_HI	1
      1  114c		       a5 93		      lda	audv1Hi
      2  114e		       69 00		      adc	#0
      3  1150		       85 93		      sta	audv1Hi
      2  1152		       85 42		      sta	WSYNC
      3  1154
      0  1154					      UPDATE_MUSIC_VOL	1
      0  1154					      UPDATE_MUSIC_PREP_VOL	1
      1  1154		       29 06		      and	#VOL_MASK/2
      2  1156		       0a		      asl
      0  1157					      UPDATE_MUSIC_SET_VOL	1
      1  1157					      IF	PLAY_CH_1 == YES
      2  1157		       85 5a		      sta	AUDV1
      3  1159				  -	      ELSE
      4  1159				  -	      nop	AUDV1
      5  1159					      ENDIF
    272  1159							; 1st calculation:
      0  1159					      CHECK_CLC
      1  1159
    274  1159		       a5 9e		      lda	audvTmpLo	; 3
    275  115b		       65 8c		      adc	note0	; 3 =	6
    276  115d		       90 03		      bcc	.skipHi1	; 2/3
    277  115f		       c8		      iny		; 2
    278  1160		       c8		      iny		; 2
    279  1161		       18		      clc		; 2
    280  1162				   .skipHi1
    281  1162		       94 cf		      sty	audV0Lst+PC_TOP,x	; 4
    282  1164		       ca		      dex		; 2 = 14
    283  1165							; 2nd calculation:
      0  1165					      CHECK_CLC
      1  1165
    285  1165		       65 8c		      adc	note0	; 3
    286  1167		       85 9e		      sta	audvTmpLo	; 3 =	6
    287  1169		       90 03		      bcc	.skipHi2	; 2/3
    288  116b		       c8		      iny		; 2
    289  116c		       c8		      iny		; 2
    290  116d		       18		      clc		; 2
    291  116e				   .skipHi2
    292  116e		       94 cf		      sty	audV0Lst+PC_TOP,x	; 4
    293  1170		       ca		      dex		; 2 = 14
    294  1171							; total: 63					 @47 max
    295  1171							;---------------------------------------
      0  1171					      UPDATE_MUSIC_WSYNC	0	;27	     @07     maintain sound while precalcuating
      0  1171					      UPDATE_MUSIC_DATA	0
      0  1171					      UPDATE_MUSIC_DATA_LO	0
      0  1171					      CHECK_CLC
      1  1171
      2  1171
      3  1171		       a5 90		      lda	audv0Lo
      4  1173		       65 8c		      adc	note0
      5  1175		       85 90		      sta	audv0Lo
      0  1177					      UPDATE_MUSIC_DATA_HI	0
      1  1177		       a5 91		      lda	audv0Hi
      2  1179		       69 00		      adc	#0
      3  117b		       85 91		      sta	audv0Hi
      2  117d		       85 42		      sta	WSYNC
      3  117f
      0  117f					      UPDATE_MUSIC_VOL	0
      0  117f					      UPDATE_MUSIC_PREP_VOL	0
      1  117f		       29 06		      and	#VOL_MASK/2
      2  1181		       0a		      asl
      0  1182					      UPDATE_MUSIC_SET_VOL	0
      1  1182					      IF	PLAY_CH_0 == YES
      2  1182		       85 59		      sta	AUDV0
      3  1184				  -	      ELSE
      4  1184				  -	      nop	AUDV0
      5  1184					      ENDIF
    297  1184							; 3rd calculation:
      0  1184					      CHECK_CLC
      1  1184
    299  1184		       a5 9e		      lda	audvTmpLo	; 3
    300  1186		       65 8c		      adc	note0	; 3 =	6
    301  1188		       90 03		      bcc	.skipHi3	; 2/3
    302  118a		       c8		      iny		; 2
    303  118b		       c8		      iny		; 2
    304  118c		       18		      clc		; 2
    305  118d				   .skipHi3
    306  118d		       94 cf		      sty	audV0Lst+PC_TOP,x	; 4
    307  118f		       ca		      dex		; 2 = 14
    308  1190							; 4th calculation:
      0  1190					      CHECK_CLC
      1  1190
    310  1190		       65 8c		      adc	note0	; 3
    311  1192		       85 9e		      sta	audvTmpLo	; 3 =	6
    312  1194		       90 03		      bcc	.skipHi4	; 2/3
    313  1196		       c8		      iny		; 2
    314  1197		       c8		      iny		; 2
    315  1198		       18		      clc		; 2
    316  1199				   .skipHi4
    317  1199		       94 cf		      sty	audV0Lst+PC_TOP,x	; 4
    318  119b		       ca		      dex		; 2 = 14
    319  119c		       10 a8		      bpl	.loopOverScan	; 2/3
    320  119e
    321  119e		       a4 96		      ldy	tmpY	; 3
    322  11a0				   .waitOverScan
    323  11a0							;---------------------------------------
    324  11a0							;    jsr     UpdateMusicWSync1L      ;39
      0  11a0					      UPDATE_MUSIC_WSYNC	1	;27	     @07     maintain sound while precalcuating
      0  11a0					      UPDATE_MUSIC_DATA	1
      0  11a0					      UPDATE_MUSIC_DATA_LO	1
      0  11a0					      CHECK_CLC
      1  11a0
      2  11a0
      3  11a0		       a5 92		      lda	audv1Lo
      4  11a2		       65 8d		      adc	note1
      5  11a4		       85 92		      sta	audv1Lo
      0  11a6					      UPDATE_MUSIC_DATA_HI	1
      1  11a6		       a5 93		      lda	audv1Hi
      2  11a8		       69 00		      adc	#0
      3  11aa		       85 93		      sta	audv1Hi
      2  11ac		       85 42		      sta	WSYNC
      3  11ae
      0  11ae					      UPDATE_MUSIC_VOL	1
      0  11ae					      UPDATE_MUSIC_PREP_VOL	1
      1  11ae		       29 06		      and	#VOL_MASK/2
      2  11b0		       0a		      asl
      0  11b1					      UPDATE_MUSIC_SET_VOL	1
      1  11b1					      IF	PLAY_CH_1 == YES
      2  11b1		       85 5a		      sta	AUDV1
      3  11b3				  -	      ELSE
      4  11b3				  -	      nop	AUDV1
      5  11b3					      ENDIF
    326  11b3
    327  11b3		       a5 88		      lda	btnReleased	; 3
    328  11b5		       f0 16		      beq	.notReleased	; 2/3
    329  11b7		       24 4c		      bit	INPT4	; 4	     button pressed?
    330  11b9		       30 18		      bmi	.exitButton	; 2/3
    331  11bb
    332  11bb							; switch to next mode:
    333  11bb		       c6 88		      dec	btnReleased	; 5
    334  11bd		       c6 86		      dec	titleMode	; 5
    335  11bf		       10 12		      bpl	.exitButton	; 2/3
    336  11c1							;--------------------------------------------------------------------------
    337  11c1							; title screen done
    338  11c1							; clear the RAM (between Platform and last zeropage variables) to avoid wrongly initialized variables
    339  11c1				   ExitTitle		;	     debug label  only
    340  11c1		       a9 00		      lda	#0
    341  11c3		       a2 57		      ldx	#DSL-endTitleClear-1
    342  11c5				   .loopClear
    343  11c5		       95 87		      sta	endTitleClear+1,x
    344  11c7		       ca		      dex
    345  11c8		       10 fb		      bpl	.loopClear
    346  11ca		       4c 82 fb 	      jmp	ExitTitleScreen
    347  11cd
    348  11cd				   .notReleased
    349  11cd		       24 4c		      bit	INPT4	; 4	     button released?
    350  11cf		       10 02		      bpl	.exitButton	; 2/3
    351  11d1		       e6 88		      inc	btnReleased	; 5
    352  11d3				   .exitButton		;   = 24    @31 max
    353  11d3
    354  11d3							; free: 20
    355  11d3							; prepare evaluating joystick up and down:
    356  11d3		       a6 9d		      ldx	selRow	; 3
    357  11d5		       ad 80 02 	      lda	SWCHA	; 4
    358  11d8		       49 ff		      eor	#$ff	; 2
    359  11da		       0a		      asl		; 2
    360  11db		       0a		      asl		; 2
    361  11dc		       48		      pha		; 3
    362  11dd		       18		      clc		; 2 = 18
    363  11de							;---------------------------------------
    364  11de							;    jsr     UpdateMusicWSync0L      ;39	  @13
      0  11de					      UPDATE_MUSIC_WSYNC	0	;27	     @07
      0  11de					      UPDATE_MUSIC_DATA	0
      0  11de					      UPDATE_MUSIC_DATA_LO	0
      0  11de					      CHECK_CLC
      1  11de
      2  11de
      3  11de		       a5 90		      lda	audv0Lo
      4  11e0		       65 8c		      adc	note0
      5  11e2		       85 90		      sta	audv0Lo
      0  11e4					      UPDATE_MUSIC_DATA_HI	0
      1  11e4		       a5 91		      lda	audv0Hi
      2  11e6		       69 00		      adc	#0
      3  11e8		       85 91		      sta	audv0Hi
      2  11ea		       85 42		      sta	WSYNC
      3  11ec
      0  11ec					      UPDATE_MUSIC_VOL	0
      0  11ec					      UPDATE_MUSIC_PREP_VOL	0
      1  11ec		       29 06		      and	#VOL_MASK/2
      2  11ee		       0a		      asl
      0  11ef					      UPDATE_MUSIC_SET_VOL	0
      1  11ef					      IF	PLAY_CH_0 == YES
      2  11ef		       85 59		      sta	AUDV0
      3  11f1				  -	      ELSE
      4  11f1				  -	      nop	AUDV0
      5  11f1					      ENDIF
    366  11f1
    367  11f1		       68		      pla		; 4
    368  11f2
    369  11f2		       88		      dey		; 2
    370  11f3		       d0 ab		      bne	.waitOverScan	; 2/3= 8/9
    371  11f5
    372  11f5		       84 5c		      sty	GRP1	; 3 =	3    @18
    373  11f7
    374  11f7		       0a		      asl		; 2
    375  11f8		       90 13		      bcc	.notDown	; 2/3
    376  11fa		       e8		      inx		; 2
    377  11fb		       a5 84		      lda	sPlayers	; 3
    378  11fd		       f0 07		      beq	.onePlayer	; 2/3
    379  11ff		       e0 04		      cpx	#NUM_SEL	; 2
    380  1201		       90 0f		      bcc	.setJoyY	; 2/3
    381  1203		       18		      clc		; 2
    382  1204		       90 12		      bcc	.skipJoyY	; 3
    383  1206
    384  1206				   .onePlayer		;12
    385  1206		       e0 03		      cpx	#NUM_SEL-1	; 2
    386  1208		       90 08		      bcc	.setJoyY	; 2/3
    387  120a		       18		      clc		; 2
    388  120b		       90 0b		      bcc	.skipJoyY	; 3 = 21
    389  120d
    390  120d				   .notDown		; 5
    391  120d		       10 09		      bpl	.skipJoyY	; 2/3
    392  120f		       ca		      dex		; 2
    393  1210					      IF	DEMO_VERSION = NO
    394  1210		       30 06		      bmi	.skipJoyY	; 2/3
    395  1212				  -	      ELSE
    396  1212				  -	      beq	.skipJoyY	; 2/3
    397  1212					      ENDIF
    398  1212				   .setJoyY
    399  1212		       a5 8a		      lda	noteLen	; 3
    400  1214		       d0 02		      bne	.skipJoyY	; 2/3
    401  1216		       86 9d		      stx	selRow	; 3 =	8
    402  1218				   .skipJoyY		;
    403  1218							; free: 5
    404  1218							;    jmp     NewFrameTitle	      ; 3 = 29 max
    405  1218		       4c 00 f0 	      jmp	SwitchToNewFrameTitleBank	;11 = 37 max
    406  121b
    407  121b							;-----------------------------------------------------------
    408  121b
    409  121b				   UpdateMusicWSync0L
    410  121b							; maintain first channel
      0  121b					      UPDATE_MUSIC_WSYNC	0	;27
      0  121b					      UPDATE_MUSIC_DATA	0
      0  121b					      UPDATE_MUSIC_DATA_LO	0
      0  121b					      CHECK_CLC
      1  121b
      2  121b
      3  121b		       a5 90		      lda	audv0Lo
      4  121d		       65 8c		      adc	note0
      5  121f		       85 90		      sta	audv0Lo
      0  1221					      UPDATE_MUSIC_DATA_HI	0
      1  1221		       a5 91		      lda	audv0Hi
      2  1223		       69 00		      adc	#0
      3  1225		       85 91		      sta	audv0Hi
      2  1227		       85 42		      sta	WSYNC
      3  1229
      0  1229					      UPDATE_MUSIC_VOL	0
      0  1229					      UPDATE_MUSIC_PREP_VOL	0
      1  1229		       29 06		      and	#VOL_MASK/2
      2  122b		       0a		      asl
      0  122c					      UPDATE_MUSIC_SET_VOL	0
      1  122c					      IF	PLAY_CH_0 == YES
      2  122c		       85 59		      sta	AUDV0
      3  122e				  -	      ELSE
      4  122e				  -	      nop	AUDV0
      5  122e					      ENDIF
    412  122e		       60		      rts		; 6 = 33
    413  122f
    414  122f				   UpdateMusicWSync1L
    415  122f							; maintain second channel
      0  122f					      UPDATE_MUSIC_WSYNC	1	;27
      0  122f					      UPDATE_MUSIC_DATA	1
      0  122f					      UPDATE_MUSIC_DATA_LO	1
      0  122f					      CHECK_CLC
      1  122f
      2  122f
      3  122f		       a5 92		      lda	audv1Lo
      4  1231		       65 8d		      adc	note1
      5  1233		       85 92		      sta	audv1Lo
      0  1235					      UPDATE_MUSIC_DATA_HI	1
      1  1235		       a5 93		      lda	audv1Hi
      2  1237		       69 00		      adc	#0
      3  1239		       85 93		      sta	audv1Hi
      2  123b		       85 42		      sta	WSYNC
      3  123d
      0  123d					      UPDATE_MUSIC_VOL	1
      0  123d					      UPDATE_MUSIC_PREP_VOL	1
      1  123d		       29 06		      and	#VOL_MASK/2
      2  123f		       0a		      asl
      0  1240					      UPDATE_MUSIC_SET_VOL	1
      1  1240					      IF	PLAY_CH_1 == YES
      2  1240		       85 5a		      sta	AUDV1
      3  1242				  -	      ELSE
      4  1242				  -	      nop	AUDV1
      5  1242					      ENDIF
    417  1242		       60		      rts		; 6 = 33
    418  1243
    419  1243							;-----------------------------------------------------------
      0  1243					      OPTIONAL_PAGEBREAK	"FSSlogo", (31*6)
     10  1243					      LIST	ON
    421  1243							;    ALIGN_FREE 256
    422  1243
    423  1243				   FSSlogo
    424  1243				   FSSlogoA0
    425  1243				   FSSlogoA1
    426  1243				   FSSlogoA2
    427  1243				   FSSlogoA3
    428  1243				   FSSlogoA4
    429  1243				   FSSlogoA5
    430  1243				   FSSlogoB0
    431  1243				   FSSlogoB1
    432  1243				   FSSlogoB2
    433  1243				   FSSlogoB3
    434  1243				   FSSlogoB4
    435  1243				   FSSlogoB5
    436  1243		       00 00 00 00*	      ds	16,0
      0  1253					      CHECKPAGE	FSSlogo
      8  1253					      LIST	ON
    438  1253
      0  1253					      ALIGN_FREE	256
      1  1253				   FREE       SET	FREE - .
      2  1300		       00 00 00 00*	      align	256
      3  1300				   FREE       SET	FREE + .
 @ $f300 : $ad
      4  1300					      echo	"@", ., ":", FREE
    440  1300
    441  1300							; Music data for two channels
    442  1300							; exactly 256 bytes, must start at page start!
    443  1300				   MusicData
    444  1300		       2d 17		      .byte.b	45 , 23
    445  1302		       39 22		      .byte.b	57 , 34
    446  1304		       44 2d		      .byte.b	68 , 45
    447  1306		       5b 36		      .byte.b	91 , 54
    448  1308		       33 14		      .byte.b	51 , 20
    449  130a		       3d 26		      .byte.b	61 , 38
    450  130c		       44 28		      .byte.b	68 , 40
    451  130e		       66 3d		      .byte.b	102, 61
    452  1310		       48 12		      .byte.b	72 , 18
    453  1312		       51 12		      .byte.b	81 , 18
    454  1314		       5b 24		      .byte.b	91 , 36
    455  1316		       6c 12		      .byte.b	108, 18
    456  1318		       51 28		      .byte.b	81 , 40
    457  131a		       99 79		      .byte.b	153, 121
    458  131c		       56 2b		      .byte.b	86 , 43
    459  131e		       88 6c		      .byte.b	136, 108
    460  1320		       2d 17		      .byte.b	45 , 23
    461  1322		       5b 17		      .byte.b	91 , 23
    462  1324		       22 17		      .byte.b	34 , 23
    463  1326		       33 17		      .byte.b	51 , 23
    464  1328		       28 14		      .byte.b	40 , 20
    465  132a		       66 14		      .byte.b	102, 20
    466  132c		       33 14		      .byte.b	51 , 20
    467  132e		       28 14		      .byte.b	40 , 20
    468  1330		       2d 17		      .byte.b	45 , 23
    469  1332		       5b 17		      .byte.b	91 , 23
    470  1334		       22 17		      .byte.b	34 , 23
    471  1336		       33 17		      .byte.b	51 , 23
    472  1338		       48 24		      .byte.b	72 , 36
    473  133a		       b6 24		      .byte.b	182, 36
    474  133c		       5b 24		      .byte.b	91 , 36
    475  133e		       48 24		      .byte.b	72 , 36
    476  1340		       51 14		      .byte.b	81 , 20
    477  1342		       51 14		      .byte.b	81 , 20
    478  1344		       1e 14		      .byte.b	30 , 20
    479  1346		       2d 14		      .byte.b	45 , 20
    480  1348		       40 20		      .byte.b	64 , 32
    481  134a		       a2 20		      .byte.b	162, 32
    482  134c		       51 20		      .byte.b	81 , 32
    483  134e		       40 20		      .byte.b	64 , 32
    484  1350		       22 11		      .byte.b	34 , 17
    485  1352		       56 44		      .byte.b	86 , 68
    486  1354		       26 11		      .byte.b	38 , 17
    487  1356		       5b 44		      .byte.b	91 , 68
    488  1358		       3d 0f		      .byte.b	61 , 15
    489  135a		       3d 0f		      .byte.b	61 , 15
    490  135c		       79 17		      .byte.b	121, 23
    491  135e		       3d 17		      .byte.b	61 , 23
    492  1360		       5b 17		      .byte.b	91 , 23
    493  1362		       5b 17		      .byte.b	91 , 23
    494  1364		       5b 17		      .byte.b	91 , 23
    495  1366		       5b 17		      .byte.b	91 , 23
    496  1368		       5b 2d		      .byte.b	91 , 45
    497  136a		       5b 2d		      .byte.b	91 , 45
    498  136c		       5b 17		      .byte.b	91 , 23
    499  136e		       5b 17		      .byte.b	91 , 23
    500  1370		       5b 14		      .byte.b	91 , 20
    501  1372		       5b 14		      .byte.b	91 , 20
    502  1374		       5b 14		      .byte.b	91 , 20
    503  1376		       5b 14		      .byte.b	91 , 20
    504  1378		       5b 28		      .byte.b	91 , 40
    505  137a		       5b 28		      .byte.b	91 , 40
    506  137c		       5b 14		      .byte.b	91 , 20
    507  137e		       5b 14		      .byte.b	91 , 20
    508  1380		       5b 17		      .byte.b	91 , 23
    509  1382		       73 5b		      .byte.b	115, 91
    510  1384		       5b 17		      .byte.b	91 , 23
    511  1386		       79 5b		      .byte.b	121, 91
    512  1388		       5b 2d		      .byte.b	91 , 45
    513  138a		       73 5b		      .byte.b	115, 91
    514  138c		       5b 17		      .byte.b	91 , 23
    515  138e		       79 5b		      .byte.b	121, 91
    516  1390		       5b 14		      .byte.b	91 , 20
    517  1392		       73 5b		      .byte.b	115, 91
    518  1394		       5b 14		      .byte.b	91 , 20
    519  1396		       79 5b		      .byte.b	121, 91
    520  1398		       51 28		      .byte.b	81 , 40
    521  139a		       66 51		      .byte.b	102, 81
    522  139c		       51 14		      .byte.b	81 , 20
    523  139e		       6c 51		      .byte.b	108, 81
    524  13a0		       5b 17		      .byte.b	91 , 23
    525  13a2		       b6 17		      .byte.b	182, 23
    526  13a4		       5b 17		      .byte.b	91 , 23
    527  13a6		       a2 88		      .byte.b	162, 136
    528  13a8		       5b 2d		      .byte.b	91 , 45
    529  13aa		       99 2d		      .byte.b	153, 45
    530  13ac		       5b 17		      .byte.b	91 , 23
    531  13ae		       88 6c		      .byte.b	136, 108
    532  13b0		       51 14		      .byte.b	81 , 20
    533  13b2		       a2 14		      .byte.b	162, 20
    534  13b4		       51 14		      .byte.b	81 , 20
    535  13b6		       a2 14		      .byte.b	162, 20
    536  13b8		       51 28		      .byte.b	81 , 40
    537  13ba		       79 28		      .byte.b	121, 40
    538  13bc		       51 14		      .byte.b	81 , 20
    539  13be		       a2 14		      .byte.b	162, 20
    540  13c0		       5b 17		      .byte.b	91 , 23
    541  13c2		       73 5b		      .byte.b	115, 91
    542  13c4		       5b 17		      .byte.b	91 , 23
    543  13c6		       79 5b		      .byte.b	121, 91
    544  13c8		       5b 2d		      .byte.b	91 , 45
    545  13ca		       73 5b		      .byte.b	115, 91
    546  13cc		       5b 17		      .byte.b	91 , 23
    547  13ce		       79 5b		      .byte.b	121, 91
    548  13d0		       5b 14		      .byte.b	91 , 20
    549  13d2		       73 5b		      .byte.b	115, 91
    550  13d4		       5b 14		      .byte.b	91 , 20
    551  13d6		       79 5b		      .byte.b	121, 91
    552  13d8		       51 28		      .byte.b	81 , 40
    553  13da		       66 51		      .byte.b	102, 81
    554  13dc		       51 14		      .byte.b	81 , 20
    555  13de		       6c 51		      .byte.b	108, 81
    556  13e0		       73 5b		      .byte.b	115, 91
    557  13e2		       5b 44		      .byte.b	91 , 68
    558  13e4		       44 39		      .byte.b	68 , 57
    559  13e6		       39 2d		      .byte.b	57 , 45
    560  13e8		       66 51		      .byte.b	102, 81
    561  13ea		       51 3d		      .byte.b	81 , 61
    562  13ec		       3d 33		      .byte.b	61 , 51
    563  13ee		       28 14		      .byte.b	40 , 20
    564  13f0		       88 73		      .byte.b	136, 115
    565  13f2		       73 5b		      .byte.b	115, 91
    566  13f4		       5b 44		      .byte.b	91 , 68
    567  13f6		       44 39		      .byte.b	68 , 57
    568  13f8		       66 3d		      .byte.b	102, 61
    569  13fa		       51 33		      .byte.b	81 , 51
    570  13fc		       3d 28		      .byte.b	61 , 40
    571  13fe		       28 14		      .byte.b	40 , 20
    572  1400
    573  1400
    574  1400				   FREE       SET	FREE + BANK_START + ROM_BANK_SIZE/2 - .
    575  1400
 Free bytes in TITLE_LOGO_BANK: $ad
    576  1400					      ECHO	"Free bytes in TITLE_LOGO_BANK:", FREE
    577  1400
      0  1400					      CHECK_HALF_BANK_SIZE	"TITLE_LOGO_BANK"
      1  1400
      2  1400
      3  1400		       04 00	   .TEMP      =	* - BANK_START
 TITLE_LOGO_BANK (1K) SIZE =  $400 , FREE= $0
      4  1400					      ECHO	"TITLE_LOGO_BANK", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1400				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1400				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1400				  -	      ERR
      8  1400					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_Demo.asm LEVEL 2 PASS 3
      0  1400					      include	"BANK_Demo.asm"	; upper half of BANK_TITLE_LOGO
      1  1400							;    NEWBANK DEMO_BANK
      0  1400					      DEFINE_1K_SEGMENT	DEMO
      1  1400					      ALIGN	$400
      2  1400				   SEGMENT_DEMO SET	*
      3  1400				   BANK_DEMO  SET	_CURRENT_BANK
      3  1400
      4  1400		       ff ff ff ff MOVE_NONE  =	~0
      5  1400		       ff ff ff 7f MOVE_RIGHT =	~%10000000
      6  1400		       ff ff ff bf MOVE_LEFT  =	~%01000000
      7  1400		       ff ff ff df MOVE_DOWN  =	~%00100000
      8  1400		       ff ff ff ef MOVE_UP    =	~%00010000
      9  1400
      0  1400					      DEFINE_SUBROUTINE	AdvanceJoystick
      1  1400		       00 02	   BANK_AdvanceJoystick =	_CURRENT_BANK
      2  1400					      SUBROUTINE
      3  1400				   AdvanceJoystick
     11  1400
     12  1400		       a9 f0		      lda	#$F0
     13  1402		       85 95		      sta	BufferedJoystick	; processed joystick OK, so clear any direction bits
     14  1404		       85 96		      sta	BufferedJoystick+1
     15  1406
     16  1406		       24 ac		      bit	demoMode
     17  1408		       10 0d		      bpl	noAdvance
     18  140a		       c6 ac		      dec	moveLen
     19  140c		       30 09		      bmi	noAdvance
     20  140e		       e6 9e		      inc	moveIdx
     21  1410		       a4 9e		      ldy	moveIdx
     22  1412		       b9 34 f4 	      lda	MoveLenTbl-1,y	; 4
     23  1415		       85 ac		      sta	moveLen	; 3
     24  1417
     25  1417		       60	   noAdvance  rts
     26  1418
     27  1418							;===============================================================================
     28  1418							; code starts here
     29  1418							;===============================================================================
     30  1418
      0  1418					      DEFINE_SUBROUTINE	GetJoystickForDemoMode	; = 42/49/49
      1  1418		       00 02	   BANK_GetJoystickForDemoMode =	_CURRENT_BANK
      2  1418					      SUBROUTINE
      3  1418				   GetJoystickForDemoMode
     32  1418
     33  1418		       24 ac		      bit	demoMode	; 3
     34  141a		       10 18		      bpl	.normalMode	; 2/3= 5/6
     35  141c
     36  141c							; if in demo mode, the joystick direction is returned by the demo date
     37  141c
     38  141c		       a5 4c		      lda	INPT4	; 4
     39  141e		       10 09		      bpl	.exitDemo	; 2/3= 6/7	 interrupt demo
     40  1420		       85 97		      sta	BufferedButton
     41  1422
     42  1422		       a4 9e		      ldy	moveIdx	; 3
     43  1424		       b9 73 f4 	      lda	MoveDirTbl-1,y	; 4
     44  1427		       d0 07		      bne	.setMove	; 3 = 29
     45  1429
     46  1429		       a5 c9	   .exitDemo  lda	NextLevelTrigger	; 3
     47  142b		       29 7f		      and	#<(~BIT_NEXTLEVEL)	; 2
     48  142d		       85 c9		      sta	NextLevelTrigger	; 3
     49  142f		       60		      rts		; 6
     50  1430
     51  1430		       85 95	   .setMove   sta	BufferedJoystick	; 3
     52  1432		       85 96		      sta	BufferedJoystick+1	; 3
     53  1434
     54  1434		       60	   .normalMode rts		; 6
     55  1435
     56  1435							;-------------------------------------------------------------------------------
     57  1435
     58  1435				   MoveLenTbl
     59  1435		       a0		      .byte.b	$80|32	; MOVE_NONE
     60  1436		       80		      .byte.b	$80|0	; MOVE_UP
     61  1437		       86		      .byte.b	$80|6	; MOVE_RIGHT
     62  1438		       81		      .byte.b	$80|1	; MOVE_DOWN
     63  1439		       88		      .byte.b	$80|8	; MOVE_RIGHT  ; D1    148
     64  143a		       85		      .byte.b	$80|5	; MOVE_NONE
     65  143b		       81		      .byte.b	$80|1	; MOVE_DOWN
     66  143c		       83		      .byte.b	$80|3	; MOVE_RIGHT
     67  143d		       82		      .byte.b	$80|2	; MOVE_UP
     68  143e		       80		      .byte.b	$80|0	; MOVE_LEFT   ; D2    144
     69  143f		       85		      .byte.b	$80|5	; MOVE_NONE
     70  1440		       80		      .byte.b	$80|0	; MOVE_UP
     71  1441		       8a		      .byte.b	$80|10	; MOVE_RIGHT
     72  1442		       80		      .byte.b	$80|0	; MOVE_DOWN
     73  1443		       81		      .byte.b	$80|1	; MOVE_RIGHT
     74  1444		       84		      .byte.b	$80|5-1	; MOVE_NONE   ;       141
     75  1445		       85		      .byte.b	$80|5	; MOVE_DOWN
     76  1446		       81		      .byte.b	$80|0+1	; MOVE_RIGHT
     77  1447		       83		      .byte.b	$80|3	; MOVE_DOWN
     78  1448		       82		      .byte.b	$80|2	;+1 ; MOVE_LEFT   ; D3    139+1     fixes broken demo!
     79  1449		       84		      .byte.b	$80|4	; MOVE_NONE
     80  144a		       80		      .byte.b	$80|0	; MOVE_DOWN
     81  144b		       80		      .byte.b	$80|0	; MOVE_LEFT   ; D4
     82  144c		       83		      .byte.b	$80|3	; MOVE_RIGHT
     83  144d		       83		      .byte.b	$80|2+1	; MOVE_LEFT   ; D5
     84  144e		       84		      .byte.b	$80|4	; MOVE_NONE
     85  144f		       83		      .byte.b	$80|3	; MOVE_UP
     86  1450		       84		      .byte.b	$80|4	; MOVE_LEFT   ; D6
     87  1451		       80		      .byte.b	$80|0	; MOVE_UP
     88  1452		       84		      .byte.b	$80|4	; MOVE_NONE
     89  1453		       84		      .byte.b	$80|4	; MOVE_LEFT   ; D7+8
     90  1454		       83		      .byte.b	$80|3	; MOVE_DOWN   ; D9
     91  1455		       82		      .byte.b	$80|2	; MOVE_LEFT   ; D10   133+1
     92  1456		       84		      .byte.b	$80|4	; MOVE_NONE
     93  1457		       82		      .byte.b	$80|2	; MOVE_UP
     94  1458		       87		      .byte.b	$80|7	; MOVE_LEFT
     95  1459		       80		      .byte.b	$80|0	; MOVE_UP
     96  145a		       85		      .byte.b	$80|4+1	; MOVE_LEFT   ; D11
     97  145b		       80		      .byte.b	$80|0	; MOVE_DOWN
     98  145c		       86		      .byte.b	$80|5+1	; MOVE_LEFT
     99  145d		       83		      .byte.b	$80|3	; MOVE_DOWN
    100  145e		       80		      .byte.b	$80|0	; MOVE_RIGHT  ; D12   130
    101  145f		       84		      .byte.b	$80|4	; MOVE_NONE
    102  1460		       81		      .byte.b	$80|1	; MOVE_DOWN
    103  1461		       83		      .byte.b	$80|3	; MOVE_RIGHT
    104  1462		       84		      .byte.b	$80|4	; MOVE_DOWN
    105  1463		       83		      .byte.b	$80|3	; MOVE_LEFT   ; D13   127
    106  1464		       82		      .byte.b	$80|1+1	; MOVE_UP
    107  1465		       81		      .byte.b	$80|1	; MOVE_RIGHT
    108  1466		       82		      .byte.b	$80|2	; MOVE_UP
    109  1467		       8f		      .byte.b	$80|15	; MOVE_RIGHT  ; D14   125
    110  1468		       84		      .byte.b	$80|4	; MOVE_NONE
    111  1469		       80		      .byte.b	$80|0	; MOVE_DOWN
    112  146a		       84		      .byte.b	$80|4	; MOVE_RIGHT
    113  146b		       80		      .byte.b	$80|0	; MOVE_DOWN
    114  146c		       83		      .byte.b	$80|3	; MOVE_RIGHT
    115  146d		       81		      .byte.b	$80|1	; MOVE_DOWN   ; D15/6 122
    116  146e		       84		      .byte.b	$80|4	; MOVE_NONE
    117  146f		       84		      .byte.b	$80|4	; MOVE_RIGHT
    118  1470		       84		      .byte.b	$80|3+1	; MOVE_UP     ;       121
    119  1471		       84		      .byte.b	$80|4	; MOVE_RIGHT
    120  1472		       84		      .byte.b	$80|4	; MOVE_NONE   ;       119
    121  1473		       ff		      .byte.b	$80|127	; MOVE_DOWN   ; 329 points
    122  1474
    123  1474				   MoveDirTbl
    124  1474		       ff		      .byte.b	MOVE_NONE
    125  1475		       ef		      .byte.b	MOVE_UP
    126  1476		       7f		      .byte.b	MOVE_RIGHT
    127  1477		       df		      .byte.b	MOVE_DOWN
    128  1478		       7f		      .byte.b	MOVE_RIGHT	; D1	 148
    129  1479		       ff		      .byte.b	MOVE_NONE
    130  147a		       df		      .byte.b	MOVE_DOWN
    131  147b		       7f		      .byte.b	MOVE_RIGHT
    132  147c		       ef		      .byte.b	MOVE_UP
    133  147d		       bf		      .byte.b	MOVE_LEFT	; D2	 144
    134  147e		       ff		      .byte.b	MOVE_NONE
    135  147f		       ef		      .byte.b	MOVE_UP
    136  1480		       7f		      .byte.b	MOVE_RIGHT
    137  1481		       df		      .byte.b	MOVE_DOWN
    138  1482		       7f		      .byte.b	MOVE_RIGHT
    139  1483		       ff		      .byte.b	MOVE_NONE	;	 141
    140  1484		       df		      .byte.b	MOVE_DOWN
    141  1485		       7f		      .byte.b	MOVE_RIGHT
    142  1486		       df		      .byte.b	MOVE_DOWN
    143  1487		       bf		      .byte.b	MOVE_LEFT	; D3	 139
    144  1488		       ff		      .byte.b	MOVE_NONE
    145  1489		       df		      .byte.b	MOVE_DOWN
    146  148a		       bf		      .byte.b	MOVE_LEFT	; D4
    147  148b		       7f		      .byte.b	MOVE_RIGHT
    148  148c		       bf		      .byte.b	MOVE_LEFT	; D5
    149  148d		       ff		      .byte.b	MOVE_NONE
    150  148e		       ef		      .byte.b	MOVE_UP
    151  148f		       bf		      .byte.b	MOVE_LEFT	; D6
    152  1490		       ef		      .byte.b	MOVE_UP
    153  1491		       ff		      .byte.b	MOVE_NONE
    154  1492		       bf		      .byte.b	MOVE_LEFT	; D7/8
    155  1493		       df		      .byte.b	MOVE_DOWN	; D9
    156  1494		       bf		      .byte.b	MOVE_LEFT	; D10	 134
    157  1495		       ff		      .byte.b	MOVE_NONE
    158  1496		       ef		      .byte.b	MOVE_UP
    159  1497		       bf		      .byte.b	MOVE_LEFT
    160  1498		       ef		      .byte.b	MOVE_UP
    161  1499		       bf		      .byte.b	MOVE_LEFT	; D11
    162  149a		       df		      .byte.b	MOVE_DOWN
    163  149b		       bf		      .byte.b	MOVE_LEFT
    164  149c		       df		      .byte.b	MOVE_DOWN
    165  149d		       7f		      .byte.b	MOVE_RIGHT	; D12	 129
    166  149e		       ff		      .byte.b	MOVE_NONE
    167  149f		       df		      .byte.b	MOVE_DOWN
    168  14a0		       7f		      .byte.b	MOVE_RIGHT
    169  14a1		       df		      .byte.b	MOVE_DOWN
    170  14a2		       bf		      .byte.b	MOVE_LEFT	; D13	 127
    171  14a3		       ef		      .byte.b	MOVE_UP
    172  14a4		       7f		      .byte.b	MOVE_RIGHT
    173  14a5		       ef		      .byte.b	MOVE_UP
    174  14a6		       7f		      .byte.b	MOVE_RIGHT	; D14	 125
    175  14a7		       ff		      .byte.b	MOVE_NONE
    176  14a8		       df		      .byte.b	MOVE_DOWN
    177  14a9		       7f		      .byte.b	MOVE_RIGHT
    178  14aa		       df		      .byte.b	MOVE_DOWN
    179  14ab		       7f		      .byte.b	MOVE_RIGHT
    180  14ac		       df		      .byte.b	MOVE_DOWN	; D15/6 122
    181  14ad		       ff		      .byte.b	MOVE_NONE
    182  14ae		       7f		      .byte.b	MOVE_RIGHT
    183  14af		       ef		      .byte.b	MOVE_UP	;	 121
    184  14b0		       7f		      .byte.b	MOVE_RIGHT
    185  14b1		       ff		      .byte.b	MOVE_NONE	;	 119
    186  14b2		       df		      .byte.b	MOVE_DOWN	; 329 points
    187  14b3
    188  14b3
    189  14b3							;------------------------------------------------------------------------------
    190  14b3					      MAC	checksounds
    191  14b3					      lda	soundIdxLst+1
    192  14b3					      cmp	#OFSS_MAGIC_WALL+1	; Amoeba or Magic Wall?
    193  14b3					      bcs	.waitForIt
    194  14b3					      STOP_CHANNEL	1	; yes, stop repeating sounds
    195  14b3					      lda	soundIdxLst
    196  14b3				   .waitForIt
    197  14b3					      ENDM
    198  14b3							;------------------------------------------------------------------------------
    199  14b3
      0  14b3					      DEFINE_SUBROUTINE	NextCave
      1  14b3		       00 02	   BANK_NextCave =	_CURRENT_BANK
      2  14b3					      SUBROUTINE
      3  14b3				   NextCave
    201  14b3
      0  14b3					      CHECKSOUNDS		; wait until all sounds are over
      1  14b3		       a5 d6		      lda	soundIdxLst+1
      2  14b5		       c9 2d		      cmp	#OFSS_MAGIC_WALL+1
      3  14b7		       b0 08		      bcs	.waitForIt
      0  14b9					      STOP_CHANNEL	1
      1  14b9
      2  14b9		       a9 00		      lda	#0
      3  14bb		       85 d6		      sta	soundIdxLst+1
      4  14bd		       85 5a		      sta	AUDV0+1
      5  14bf		       a5 d5		      lda	soundIdxLst
      6  14c1				   .waitForIt
    203  14c1		       d0 1b		      bne	.skipNextLevel
    204  14c3
    205  14c3							; Now do the actual switching
    206  14c3
    207  14c3		       a5 c9		      lda	NextLevelTrigger
    208  14c5		       29 7f		      and	#<(~BIT_NEXTLEVEL)
    209  14c7		       85 c9		      sta	NextLevelTrigger
    210  14c9
    211  14c9							; Next level is due. Point to the next cave, but if we're at the end of playable caves,
    212  14c9							; then increment the level number. This is completely circular, so we eventually wrap
    213  14c9							; the cave back to 0 and start afresh. The level maxes out at P5 then remains at the top.
    214  14c9
    215  14c9		       a5 b0	   NextCaveAlong lda	cave
    216  14cb		       18		      clc
    217  14cc		       69 05		      adc	#CAVE_DATA_SIZE
    218  14ce		       c9 32		      cmp	#MAX_CAVENUM
    219  14d0		       90 0a		      bcc	.caveOK
    220  14d2
    221  14d2		       a6 b1		      ldx	level
    222  14d4		       e0 04		      cpx	#NUM_LEVELS-1
    223  14d6		       b0 02		      bcs	.skipIncLevel
    224  14d8		       e6 b1		      inc	level
    225  14da				   .skipIncLevel
    226  14da
    227  14da		       a9 00		      lda	#0
    228  14dc		       85 b0	   .caveOK    sta	cave
    229  14de		       60	   .skipNextLevel rts
    230  14df
    231  14df
      0  14df					      CHECK_BANK_SIZE	"DEMO_BANK"
      1  14df		       04 df	   .TEMP      =	* - BANK_START
 DEMO_BANK (2K) SIZE =  $4df , FREE= $321
      2  14df					      ECHO	"DEMO_BANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  14df				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  14df				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  14df				  -	      ERR
      6  14df					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 3
      0  14df					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1  14df							;------------------------------------------------------------------------------
      2  14df							;##############################################################################
      3  14df							;------------------------------------------------------------------------------
      0  14df					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  1e8c ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
      5  1800
      6  1800							; This is essentially a ROM mirror of a RAM bank.
      7  1800							; The contents of this bank are copied to each of the ROW banks on startup, and
      8  1800							; this gives a 1:1 correspondence between the data/addresses defined here, and
      9  1800							; the addresses in the switched-in RAM bank.
     10  1800
     11  1800							; Note: Bankswitching code between any of these banks guarantees the code can
     12  1800							; continue to run -- because, of course, the same code is still at the same
     13  1800							; memory address.
     14  1800
     15  1800		       00 01	   _PROFILE_DRAW =	YES
     16  1800
     17  1800					      MAC	profile_draw
     18  1800					      IF	_PROFILE_DRAW
     19  1800					      inc	Profile{1}
     20  1800					      bne	$skip
     21  1800					      inc	Profile{1}+1
     22  1800				   $skip
     23  1800					      ENDIF
     24  1800					      ENDM		; {label}
     25  1800
     26  1800
      0  1800					      DEFINE_SUBROUTINE	DrawTheScreen
      1  1800		       00 03	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  1800					      SUBROUTINE
      3  1800				   DrawTheScreen
     28  1800
     29  1800							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     30  1800							; A refactor of the kernel to improve the timing.
     31  1800							; Experimental refactor to remove the blank line...
     32  1800
     33  1800							; adjust here so that the first line of the kernel starts exactly at cycle 67
     34  1800							; (since TJ said it could start up to 5 cycles earlier than #67).
     35  1800
     36  1800							; TODO: remove GRP1 and COLUP1 access (or use higher resolution Rockford)
     37  1800							;	     @57
      0  1800					      SLEEP	3	; 3
      1  1800				   .CYCLES    SET	3
      2  1800
      3  1800				  -	      IF	.CYCLES < 2
      4  1800				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1800				  -	      ERR
      6  1800					      ENDIF
      7  1800
      8  1800					      IF	.CYCLES & 1
      9  1800					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1800		       04 00		      nop	0
     11  1802				  -	      ELSE
     12  1802				  -	      bit	VSYNC
     13  1802					      ENDIF
     14  1802				   .CYCLES    SET	.CYCLES - 3
     15  1802					      ENDIF
     16  1802
     17  1802				  -	      REPEAT	.CYCLES / 2
     18  1802				  -	      nop
     19  1802					      REPEND
     39  1802
     40  1802		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     41  1804		       10 3e		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     42  1806
     43  1806				   Proc2		; 5
      0  1806					      SLEEP	3	; 3	     @64
      1  1806				   .CYCLES    SET	3
      2  1806
      3  1806				  -	      IF	.CYCLES < 2
      4  1806				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1806				  -	      ERR
      6  1806					      ENDIF
      7  1806
      8  1806					      IF	.CYCLES & 1
      9  1806					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1806		       04 00		      nop	0
     11  1808				  -	      ELSE
     12  1808				  -	      bit	VSYNC
     13  1808					      ENDIF
     14  1808				   .CYCLES    SET	.CYCLES - 3
     15  1808					      ENDIF
     16  1808
     17  1808				  -	      REPEAT	.CYCLES / 2
     18  1808				  -	      nop
     19  1808					      REPEND
     45  1808		       10 3c		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     46  180a
     47  180a				   ScanRED		;	     @60
     48  180a		       b9 25 f3    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     49  180d		       85 4d		      sta	PF0	; 3	     @67
     50  180f		       b9 3e f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     51  1812		       85 4e		      sta	PF1	; 3 = 14    @74
     52  1814				   SELFMOD_PLAYERCOL_RED
     53  1814		       b9 af f0 	      lda	SpriteColourRED,y	; 4
     54  1817		       85 46		      sta	COLUP0	; 3	     @05
     55  1819		       85 47		      sta	COLUP1	; 3 = 10    @08
     56  181b
     57  181b							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     58  181b
     59  181b				   SELFMOD_RED
     60  181b		       a9 00		      lda	#0	; 2
     61  181d		       85 48		      sta	COLUPF	; 3 =	5    @13
     62  181f
     63  181f				   SELFMOD_PLAYER0_RED
     64  181f		       b9 25 f3 	      lda	ShapePlayerRED,y	; 4
     65  1822		       85 5b		      sta	GRP0	; 3 =	7    @20
     66  1824
     67  1824		       b9 53 f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
     68  1827		       85 4f		      sta	PF2	; 3 =	7    @27
     69  1829
     70  1829		       b9 25 f3    SM_PF0_REDr lda	CHARACTERSHAPE_BLANK,y	; 4
     71  182c		       85 4d		      sta	PF0	; 3	     @34
     72  182e		       b9 68 f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
     73  1831		       85 4e		      sta	PF1	; 3	     @41
     74  1833		       b9 7d f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
     75  1836		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
     76  1838
     77  1838				   SELFMOD_PLAYER1_RED
     78  1838		       b9 25 f3 	      lda	ShapePlayerRED,y	; 4
     79  183b		       8d 5c 00 	      sta.w	GRP1	; 4 =	8    @56   VDELed!
     80  183e
     81  183e		       88		      dey		; 2
     82  183f		       10 c5		      bpl	Proc2	; 2(3)      --> 61 if taken
     83  1841
     84  1841		       e8	   SELFMOD_X  inx		; 2
     85  1842		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
     86  1844							;EXIT_RETURN_HERE
     87  1844				   NextALineStart
     88  1844		       a0 06		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
     89  1846				   ScanBLUEBD		;	     @67     let's start as late as possible
     90  1846
     91  1846							;------------------------------------------------------------------------------
     92  1846
     93  1846		       b9 25 f3    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
     94  1849		       85 4d		      sta	PF0	; 3 =	7    @74
     95  184b				   SELFMOD_PLAYERCOL_BLUE
     96  184b		       b9 bd f0 	      lda	SpriteColourBLUE,y	; 4
     97  184e		       85 47		      sta	COLUP1	; 3	     @05
     98  1850		       85 46		      sta	COLUP0	; 3 = 10    @08
     99  1852
    100  1852				   SELFMOD_BLUE
    101  1852		       a9 00		      lda	#0	; 2
    102  1854		       85 48		      sta	COLUPF	; 3 =	5    @13
    103  1856
    104  1856				   SELFMOD_PLAYER0_BLUE
    105  1856		       b9 25 f3 	      lda	ShapePlayerBLUE,y	; 4
    106  1859		       85 5b		      sta	GRP0	; 3 =	7    @20
    107  185b
    108  185b		       b9 4c f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    109  185e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    110  1860		       b9 61 f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    111  1863		       85 4f		      sta	PF2	; 3 = 14    @34
    112  1865
    113  1865		       b9 25 f3    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    114  1868		       85 4d		      sta	PF0	; 3	     @41
    115  186a		       b9 76 f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    116  186d		       85 4e		      sta	PF1	; 3	     @48
    117  186f		       b9 8b f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    118  1872		       85 4f		      sta	PF2	; 3 = 21    @55
    119  1874
    120  1874				   SELFMOD_PLAYER1_BLUE
    121  1874		       b9 25 f3 	      lda	ShapePlayerBLUE,y	; 4
    122  1877		       85 5c		      sta	GRP1	; 3 =	7    VDELed! @62
    123  1879
    124  1879							;------------------------------------------------------------------------------
    125  1879
    126  1879				   ScanGREEN		;	     @62
    127  1879		       b9 25 f3    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    128  187c		       85 4d		      sta	PF0	; 3 =	7    @69
    129  187e				   SELFMOD_PLAYERCOL_GREEN
    130  187e		       b9 b6 f0 	      lda	SpriteColourGREEN,y	; 4
    131  1881		       85 47		      sta	COLUP1	; 3	     @00
    132  1883		       85 46		      sta	COLUP0	; 3 = 10    @03
    133  1885
    134  1885				   SELFMOD_GREEN
    135  1885		       a9 00		      lda	#0	; 2
    136  1887		       85 48		      sta	COLUPF	; 3 =	5    @08
    137  1889
    138  1889				   SELFMOD_PLAYER0_GREEN
    139  1889		       b9 25 f3 	      lda	ShapePlayerGREEN,y	; 4
    140  188c		       85 5b		      sta	GRP0	; 3 =	7    @15
    141  188e
    142  188e		       b9 45 f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    143  1891		       85 4e		      sta	PF1	; 3	     @22
    144  1893		       b9 5a f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    145  1896		       85 4f		      sta	PF2	; 3 = 14    @29
    146  1898
    147  1898		       b9 25 f3    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    148  189b		       85 4d		      sta	PF0	; 3	     @36
    149  189d		       b9 6f f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    150  18a0		       85 4e		      sta	PF1	; 3	     @43
    151  18a2		       b9 84 f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    152  18a5		       85 4f		      sta	PF2	; 3 = 21    @50
    153  18a7
    154  18a7				   SELFMOD_PLAYER1_GREEN
    155  18a7		       b9 25 f3 	      lda	ShapePlayerGREEN,y	; 4
    156  18aa		       85 5c		      sta	GRP1	; 3 =	7    @57     VDELed!
    157  18ac
    158  18ac		       4c 0a f0 	      jmp	ScanRED	; 3	     @60
    159  18af
    160  18af							;------------------------------------------------------------------------------
    161  18af
    162  18af							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    163  18af
    164  18af		       f3 25	   ShapePlayer =	PLAYER_BLANK
    165  18af		       f3 25	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    166  18af		       f3 25	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    167  18af		       f3 25	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    168  18af
    169  18af		       f3 25	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    170  18af		       f3 25	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    171  18af		       f3 25	   CHARACTERSHAPE_EXITDOOR2 =	PLAYER_BLANK
    172  18af		       f2 a7	   CHARACTERSHAPE_EXPLOSION =	CHARACTERSHAPE_EXPLOSION2	;PLAYER_BLANK
    173  18af		       f2 a7	   CHARACTERSHAPE_EXPLOSION_MIRRORED =	CHARACTERSHAPE_EXPLOSION2	;PLAYER_BLANK		     ; TODO: change
    174  18af
------- FILE Rockford_Color.asm LEVEL 3 PASS 3
      0  18af					      include	"Rockford_Color.asm"	; 1 * LINES_PER_CHAR bytes
      0  18af					      OPTIONAL_PAGEBREAK	"SpriteColour", LINES_PER_CHAR*2
     10  18af					      LIST	ON
      2  18af
      3  18af		       00 10	   YELLOW_NTSC =	$10	; hair
      4  18af		       00 30	   ORANGE_NTSC =	$30	; skin
      5  18af		       00 40	   RED_NTSC   =	$40	; shirt
      6  18af
      7  18af		       00 20	   YELLOW_PAL =	$20
      8  18af		       00 40	   ORANGE_PAL =	$40
      9  18af		       00 60	   RED_PAL    =	$60
     10  18af
     11  18af				   SpriteColour
     12  18af							; NTSC
     13  18af							;SpriteColourRED
     14  18af							;    .byte RED_NTSC|$6       ; 0 feet
     15  18af							;    .byte WHITE	      ; 3
     16  18af							;    .byte RED_NTSC|$4       ; 6
     17  18af							;    .byte RED_NTSC|$4       ; 9
     18  18af							;    .byte ORANGE_NTSC|$6    ;12
     19  18af							;    .byte ORANGE_NTSC|$8    ;15
     20  18af							;    .byte WHITE	      ;18
     21  18af							;SpriteColourGREEN
     22  18af							;    .byte RED_NTSC|$4       ; 1
     23  18af							;    .byte WHITE	      ; 4
     24  18af							;    .byte WHITE	      ; 7
     25  18af							;    .byte WHITE	      ;10
     26  18af							;    .byte ORANGE_NTSC|$8    ;13
     27  18af							;    .byte ORANGE_NTSC|$6    ;16
     28  18af							;    .byte WHITE	      ;19
     29  18af							;SpriteColourBLUE
     30  18af							;    .byte WHITE	      ; 2
     31  18af							;    .byte RED_NTSC|$4       ; 5
     32  18af							;    .byte RED_NTSC|$4       ; 8
     33  18af							;    .byte ORANGE_NTSC|$4    ;11 neck
     34  18af							;    .byte ORANGE_NTSC|$a    ;14
     35  18af							;    .byte YELLOW_NTSC|$c    ;17 hair
     36  18af							;    .byte WHITE	      ;20
     37  18af
     38  18af				   SpriteColourRED
     39  18af		       46		      .byte.b	RED_NTSC|$6	; 0 feet
     40  18b0		       0e		      .byte.b	WHITE	; 3
     41  18b1		       44		      .byte.b	RED_NTSC|$4	; 6
     42  18b2		       44		      .byte.b	RED_NTSC|$4	; 9
     43  18b3		       0e		      .byte.b	WHITE	;12 neck
     44  18b4		       38		      .byte.b	ORANGE_NTSC|$8	;15
     45  18b5		       36		      .byte.b	ORANGE_NTSC|$6	;18
     46  18b6				   SpriteColourGREEN
     47  18b6		       44		      .byte.b	RED_NTSC|$4	; 1
     48  18b7		       0e		      .byte.b	WHITE	; 4
     49  18b8		       44		      .byte.b	RED_NTSC|$4	; 7
     50  18b9		       44		      .byte.b	RED_NTSC|$4	;10
     51  18ba		       34		      .byte.b	ORANGE_NTSC|$4	;13 neck
     52  18bb		       3a		      .byte.b	ORANGE_NTSC|$a	;16
     53  18bc		       1c		      .byte.b	YELLOW_NTSC|$c	;19 hair
     54  18bd				   SpriteColourBLUE
     55  18bd		       0e		      .byte.b	WHITE	; 2
     56  18be		       44		      .byte.b	RED_NTSC|$4	; 5
     57  18bf		       0e		      .byte.b	WHITE	; 8
     58  18c0		       44		      .byte.b	RED_NTSC|$4	;11
     59  18c1		       36		      .byte.b	ORANGE_NTSC|$6	;14
     60  18c2		       38		      .byte.b	ORANGE_NTSC|$8	;17
     61  18c3		       0e		      .byte.b	WHITE	;20 unused
     62  18c4
     63  18c4							; PAL
     64  18c4							;    .byte RED_PAL|$6	      ; 0 feet
     65  18c4							;    .byte WHITE	      ; 3
     66  18c4							;    .byte RED_PAL|$4	      ; 6
     67  18c4							;    .byte RED_PAL|$4	      ; 9
     68  18c4							;    .byte ORANGE_PAL|$4     ;12
     69  18c4							;    .byte ORANGE_PAL|$6     ;15
     70  18c4							;    .byte WHITE	      ;18
     71  18c4							;
     72  18c4							;    .byte RED_PAL|$4	      ; 1
     73  18c4							;    .byte WHITE	      ; 4
     74  18c4							;    .byte WHITE	      ; 7
     75  18c4							;    .byte WHITE	      ;10
     76  18c4							;    .byte ORANGE_PAL|$6     ;13
     77  18c4							;    .byte ORANGE_PAL|$4     ;16
     78  18c4							;    .byte WHITE	      ;19
     79  18c4							;
     80  18c4							;    .byte WHITE	      ; 2
     81  18c4							;    .byte RED_PAL|$4	      ; 5
     82  18c4							;    .byte RED_PAL|$4	      ; 8
     83  18c4							;    .byte ORANGE_PAL|$2     ;11 neck
     84  18c4							;    .byte ORANGE_PAL|$8     ;14
     85  18c4							;    .byte YELLOW_PAL|$c     ;17 hair
     86  18c4							;    .byte WHITE	      ;20
     87  18c4
     88  18c4		       66		      .byte.b	RED_PAL|$6	; 0 feet
     89  18c5		       0e		      .byte.b	WHITE	; 3
     90  18c6		       64		      .byte.b	RED_PAL|$4	; 6
     91  18c7		       64		      .byte.b	RED_PAL|$4	; 9
     92  18c8		       0e		      .byte.b	WHITE	;12 neck
     93  18c9		       46		      .byte.b	ORANGE_PAL|$6	;15
     94  18ca		       44		      .byte.b	ORANGE_PAL|$4	;18
     95  18cb
     96  18cb		       64		      .byte.b	RED_PAL|$4	; 1
     97  18cc		       0e		      .byte.b	WHITE	; 4
     98  18cd		       64		      .byte.b	RED_PAL|$4	; 7
     99  18ce		       64		      .byte.b	RED_PAL|$4	;10
    100  18cf		       42		      .byte.b	ORANGE_PAL|$2	;13 neck
    101  18d0		       48		      .byte.b	ORANGE_PAL|$8	;16
    102  18d1		       2c		      .byte.b	YELLOW_PAL|$c	;19 hair
    103  18d2
    104  18d2		       0e		      .byte.b	WHITE	; 2
    105  18d3		       64		      .byte.b	RED_PAL|$4	; 5
    106  18d4		       0e		      .byte.b	WHITE	; 8
    107  18d5		       64		      .byte.b	RED_PAL|$4	;11
    108  18d6		       44		      .byte.b	ORANGE_PAL|$4	;14
    109  18d7		       46		      .byte.b	ORANGE_PAL|$6	;17
    110  18d8		       0e		      .byte.b	WHITE	;20 unused
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    176  18d9
    177  18d9
    178  18d9							;------------------------------------------------------------------------------
    179  18d9
    180  18d9							;*** Ideas: ***
    181  18d9							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    182  18d9							;   13.5% on average), also unrolling would be more effective than now
    183  18d9							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    184  18d9							;   see EXPERIMENTAL)
    185  18d9							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    186  18d9							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    187  18d9							;   bidirectional linked list instead)
    188  18d9							; - calculate mirrored gfx data into RAM (saves ROM)
    189  18d9
    190  18d9							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    191  18d9							;currently:
    192  18d9							; 72%*539 (!unrolled)
    193  18d9							;+ 8%*304 (unrolled)
    194  18d9							;+20%*269 (unrolled)
    195  18d9							;--------
    196  18d9							;=   ~466.2 cycles on average
    197  18d9
    198  18d9							;alternative #1:
    199  18d9							; 72%*522 (unrolled)
    200  18d9							;+ 8%*352 (!unrolled)
    201  18d9							;+20%*307 (!unrolled)
    202  18d9							;--------
    203  18d9							;=   ~465.4 cycles on average
    204  18d9
    205  18d9
    206  18d9		       00 01	   MIRROR     =	1
    207  18d9		       00 80	   DIRECT     =	$80
    208  18d9
    209  18d9							;------------------------------------------------------------------------------
    210  18d9							; Here we don't draw into a buffer, but directly patch the kernel
    211  18d9							; VERY fast!
    212  18d9							;
    213  18d9							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    214  18d9							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    215  18d9
    216  18d9				   PF0Draw		; 25 cycles until here
    217  18d9
    218  18d9		       ae 84 02 	      ldx	INTIM	; 4
    219  18dc		       e0 05		      cpx	#SEGTIME_SCD_PF0	; 2
    220  18de		       90 72		      bcc	ExitDraw	; 2(3)=8
      0  18e0					      STRESS_TIME	SEGTIME_SCD_PF0	; ok!
      1  18e0				  -	      IF	TEST_SEGTIME_SCD_PF0 = 1
      2  18e0				  -
      3  18e0				  -
      4  18e0				  -
      5  18e0				  -
      6  18e0				  -
      7  18e0				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  18e0				  -	      bne	. - 7
      9  18e0					      ENDIF
    222  18e0
    223  18e0		       29 7f		      and	#<(~DIRECT)	; 2
    224  18e2		       aa		      tax		; 2 =	4
    225  18e3
    226  18e3		       98		      tya		; 2
    227  18e4		       0a		      asl		; 2	     no mirrored chars in PF0
    228  18e5		       a8		      tay		; 2 =	6
    229  18e6							;		  clc				  ; 2
    230  18e6
    231  18e6		       b9 7b fc 	      lda	CharacterDataVecHI,y	; 4
    232  18e9		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    233  18ec		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    234  18ef		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19
    235  18f2
    236  18f2		       b9 45 fc 	      lda	CharacterDataVecLO,y	; 4
    237  18f5		       9d 0b f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    238  18f8		       69 06		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    239  18fa		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    240  18fd		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    241  18ff		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23
    242  1902
    243  1902		       4c 00 fb 	      jmp	DrawAnother	; 3 =	3
    244  1905
    245  1905							; Timing for PF0Draw
    246  1905							; 7+63 = 70
    247  1905							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    248  1905
    249  1905
    250  1905							;------------------------------------------------------------------------------
    251  1905							; Direct draw draws to PF0, which only has one active member of the character
    252  1905							; pair -- so it can be a direct copy.	Quicker still!
    253  1905
    254  1905				   DirectDraw		; 37 cycles until here
    255  1905
    256  1905							;ldy #16
    257  1905		       ad 84 02 	      lda	INTIM	; 4
    258  1908		       c9 08		      cmp	#SEGTIME_SCD_DIRECT	; 2
    259  190a		       90 46		      bcc	ExitDraw	; 2(3)=8
      0  190c					      STRESS_TIME	SEGTIME_SCD_DIRECT	; ok!
      1  190c				  -	      IF	TEST_SEGTIME_SCD_DIRECT = 1
      2  190c				  -
      3  190c				  -
      4  190c				  -
      5  190c				  -
      6  190c				  -
      7  190c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  190c				  -	      bne	. - 7
      9  190c					      ENDIF
    261  190c
    262  190c							; TIME REQUIRED FROM HERE (9/JAN)
    263  190c							; 16 + 20 + 20 + 2 + ( 7 * 32 ) - 1  + (42 SUFFIX)
    264  190c							; = 323 --> /64 = 5.04 USE 7
    265  190c
    266  190c		       b9 7b fc 	      lda	CharacterDataVecHI,y	; 4
    267  190f		       8d 3c f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    268  1912		       8d 42 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    269  1915		       8d 48 f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    270  1918
    271  1918		       b9 45 fc 	      lda	CharacterDataVecLO,y	; 4
    272  191b		       8d 3b f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    273  191e		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    274  1920		       8d 41 f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    275  1923		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    276  1925		       8d 47 f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    277  1928
    278  1928		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    279  192b		       8d 3e f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    280  192e		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    281  1930		       8d 44 f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    282  1933		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    283  1935		       8d 4a f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    284  1938
    285  1938		       a0 06		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    286  193a				   TSFill3
    287  193a		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    288  193d		       99 3e f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    289  1940		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    290  1943		       99 3e f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    291  1946		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    292  1949		       99 3e f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    293  194c
    294  194c		       88		      dey		; 2
      0  194d					      CHECKPAGE_BPL	TSFill3	; 3(2)=5
      8  194d					      LIST	ON
      9  194d		       10 eb		      bpl	TSFill3
    296  194f
    297  194f		       4c 00 fb 	      jmp	DrawAnother	; 3
    298  1952
    299  1952							; Timing for DirectDraw
    300  1952							; 17+8+16+20+20+2+(32*7)-1+3 = 309 (was: 302 + 3)
    301  1952							; total: 37+309+6 = 352 => 352/64 + 1.4 = 6.90 = 7 (= SEGTIME_SLOWDRAW-5)
    302  1952
    303  1952				   ExitDraw
    304  1952		       60		      rts
    305  1953
    306  1953							;------------------------------------------------------------------------------
      0  1953					      DEFINE_SUBROUTINE	StealPart3	; 18 CYCLES HERE
      1  1953		       00 03	   BANK_StealPart3 =	_CURRENT_BANK
      2  1953					      SUBROUTINE
      3  1953				   StealPart3
    308  1953
    309  1953		       bd ee f1 	      lda	MOD10,x	; 4
    310  1956		       30 81		      bmi	PF0Draw	; 2/3
    311  1958		       4a		      lsr		; 2
    312  1959		       aa		      tax		; 2
    313  195a		       98		      tya		; 2
    314  195b		       2a		      rol		; 2	     allows for mirrored char = * | 1
    315  195c		       a8		      tay		; 2
    316  195d		       b0 a6		      bcs	DirectDraw	; 2(3)      when draw stack was built, bit 7 flags direct-drawn character
    317  195f							;	     => +19 starting DirectDraw BUT WHO CARES AS IT'S ONLY AFTER THAT COUNTS
    318  195f
    319  195f		       b9 7b fc 	      lda	CharacterDataVecHI,y	; 4
    320  1962		       10 38		      bpl	QuickDraw	; 2(3)=42   special-case blank characters for extra speed
    321  1964							;	     => 42 starting QuickDraw
    322  1964		       8d 8d f5 	      sta	SMEOR1+RAM_WRITE+2	; 4 =	4
    323  1967
    324  1967		       ad 84 02 	      lda	INTIM	; 4
    325  196a		       c9 0c		      cmp	#SEGTIME_SCD_SLOW	; 2
    326  196c		       90 e4		      bcc	ExitDraw	; 2(3)=8
      0  196e					      STRESS_TIME	SEGTIME_SCD_SLOW	; ok!
      1  196e				  -	      IF	TEST_SEGTIME_SCD_SLOW = 1
      2  196e				  -
      3  196e				  -
      4  196e				  -
      5  196e				  -
      6  196e				  -
      7  196e				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  196e				  -	      bne	. - 7
      9  196e					      ENDIF
    328  196e
    329  196e							; TIME REQUIRED FROM HERE (9/JAN)
    330  196e							; 8 + 16 + 8 + 2 + (21 * 23) -1 + (42 OVERHEAD WHEN RETURNING)
    331  196e							; = 558 --> /64 = 8.71 INTIM --> USE 10
    332  196e
    333  196e		       b9 45 fc 	      lda	CharacterDataVecLO,y	; 4
    334  1971		       8d 8c f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    335  1974
    336  1974		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    337  1977		       8d 89 f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    338  197a		       8d 91 f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    339  197d		       8d 94 f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    340  1980
    341  1980		       bd e6 f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    342  1983		       8d 8f f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    343  1986
    344  1986		       a0 14	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2
    345  1988
    346  1988							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    347  1988							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    348  1988
    349  1988				   TSFill
    350  1988
    351  1988		       b9 3e f2    SMLOAD     lda	ScreenBitmap,y	; 4
    352  198b		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    353  198e		       29 00	   SMMASK     and	#0	; 2
    354  1990		       59 3e f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    355  1993		       99 3e f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    356  1996
    357  1996		       88		      dey		; 2
      0  1997					      CHECKPAGE_BPL	TSFill	; 3(2)=5
      8  1997					      LIST	ON
      9  1997		       10 ef		      bpl	TSFill
    359  1999
    360  1999		       4c 00 fb 	      jmp	DrawAnother	; 3
    361  199c
    362  199c							; Timing for "SLOW" draw
    363  199c							; 22+4+8+8+16+8+2+(21*24)-1+3 = 574 (was: 566 + 3)
    364  199c							; total: 37+574+6 = 617 => 628/64 + 1.4 = 11.04 = 12 (= SEGTIME_SLOWDRAW)
    365  199c
    366  199c
    367  199c							;------------------------------------------------------------------------------
    368  199c							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    369  199c							; existing character data, so can be special-cased from the normal character
    370  199c							; draw, saving roughly 230 cycles.
    371  199c
    372  199c				   QuickDraw		; 42 cycles until here
    373  199c
    374  199c		       ad 84 02 	      lda	INTIM	; 4
    375  199f		       c9 09		      cmp	#SEGTIME_SCD_QUICK	; 2	     SEE TIMING CALCS BELOW
    376  19a1		       90 af		      bcc	ExitDraw	; 2(3)=8
      0  19a3					      STRESS_TIME	SEGTIME_SCD_QUICK	; ok!
      1  19a3				  -	      IF	TEST_SEGTIME_SCD_QUICK = 1
      2  19a3				  -
      3  19a3				  -
      4  19a3				  -
      5  19a3				  -
      6  19a3				  -
      7  19a3				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  19a3				  -	      bne	. - 7
      9  19a3					      ENDIF
    378  19a3
    379  19a3							; TIME REQUIRED FROM HERE (9/JAN)
    380  19a3							;   = 32 + 4 + 2 + ( 7 * 38 ) - 1 + 3	+ (42 SUFFIX)
    381  19a3							;   = 348 --> /64 = 5.43. USE 7
    382  19a3
    383  19a3		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    384  19a6		       8d c3 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    385  19a9		       8d c6 f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    386  19ac		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    387  19ae		       8d ca f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    388  19b1		       8d cd f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    389  19b4		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    390  19b6		       8d d1 f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    391  19b9		       8d d4 f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32
    392  19bc
    393  19bc		       bc e4 f1 	      ldy	CharMask,x	; 4 =	4    masks out left or right
    394  19bf
    395  19bf		       a2 06		      ldx	#LINES_PER_CHAR/3 - 1	; 2 =	2
    396  19c1				   TSFill2
    397  19c1		       98		      tya		; 2
    398  19c2		       3d 3e f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    399  19c5		       9d 3e f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    400  19c8		       98		      tya		; 2
    401  19c9		       3d 3e f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    402  19cc		       9d 3e f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    403  19cf		       98		      tya		; 2
    404  19d0		       3d 3e f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    405  19d3		       9d 3e f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33
    406  19d6
    407  19d6		       ca		      dex		; 2
      0  19d7					      CHECKPAGE_BPL	TSFill2	; 3(2)=5
      8  19d7					      LIST	ON
      9  19d7		       10 e8		      bpl	TSFill2
    409  19d9
    410  19d9		       4c 00 fb 	      jmp	DrawAnother	; 3
    411  19dc
    412  19dc							; Timing for QuickDraw
    413  19dc							; 23+8+32+4+2+(7*38)-1+3 = 337 (was: 330 + 3)
    414  19dc							; total: 37+337+6 = 380 => 380/64 + 1.4 = 7.34 = 8 (= SEGTIME_SLOWDRAW-4)
    415  19dc
    416  19dc
    417  19dc							;------------------------------------------------------------------------------
    418  19dc
    419  19dc
    420  19dc				   CharAddressLO		;[abs char location % 10]
    421  19dc
    422  19dc							; Gives the absolute screen buffer address of the first line of the given character
    423  19dc							; Where character number is 0-9
    424  19dc
    425  19dc		       3e		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    426  19dd		       3e		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    427  19de		       53		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    428  19df		       53		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    429  19e0		       68		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    430  19e1		       68		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    431  19e2		       7d		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    432  19e3		       7d		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    433  19e4							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    434  19e4							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    435  19e4
    436  19e4				   CharMask		; [abs char location % 10]
    437  19e4
    438  19e4							; Gives the mask for any char of the screen (per row)
    439  19e4							; Note, this is hardwired to the screen format of 6 bytes/line
    440  19e4
    441  19e4		       0f		      .byte.b	$0F	; 1
    442  19e5		       f0		      .byte.b	$F0	; 2
    443  19e6				   CharMaskNeg
    444  19e6		       f0		      .byte.b	$F0	; 3/1
    445  19e7		       0f		      .byte.b	$0F	; 4/2
    446  19e8		       0f		      .byte.b	$0F	; 6/3
    447  19e9		       f0		      .byte.b	$F0	; 7/4
    448  19ea		       f0		      .byte.b	$F0	; 8/6
    449  19eb		       0f		      .byte.b	$0F	; 9/7
    450  19ec		       0f		      .byte.b	$0F	; -/8
    451  19ed		       f0		      .byte.b	$F0	; -/9
    452  19ee				   MOD10
    453  19ee					      REPEAT	SCREEN_LINES
    454  19ee							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  19ee							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  19ee		       80		      .byte.b	DIRECT
    457  19ef		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  19f3		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  19f4		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  19f4					      REPEND
    454  19f8							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  19f8							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  19f8		       80		      .byte.b	DIRECT
    457  19f9		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  19fd		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  19fe		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  19fe					      REPEND
    454  1a02							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  1a02							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  1a02		       80		      .byte.b	DIRECT
    457  1a03		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  1a07		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  1a08		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  1a08					      REPEND
    454  1a0c							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  1a0c							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  1a0c		       80		      .byte.b	DIRECT
    457  1a0d		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  1a11		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  1a12		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  1a12					      REPEND
    454  1a16							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  1a16							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  1a16		       80		      .byte.b	DIRECT
    457  1a17		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  1a1b		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  1a1c		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  1a1c					      REPEND
    454  1a20							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  1a20							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  1a20		       80		      .byte.b	DIRECT
    457  1a21		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  1a25		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  1a26		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  1a26					      REPEND
    454  1a2a							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  1a2a							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  1a2a		       80		      .byte.b	DIRECT
    457  1a2b		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  1a2f		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  1a30		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  1a30					      REPEND
    454  1a34							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  1a34							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  1a34		       80		      .byte.b	DIRECT
    457  1a35		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  1a39		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  1a3a		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    460  1a3e					      REPEND
    461  1a3e
    462  1a3e							;------------------------------------------------------------------------------
    463  1a3e
    464  1a3e
    465  1a3e
      0  1a3e					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  1a3e					      LIST	ON
    467  1a3e
    468  1a3e		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,$0	; character bitmap row (10 chars wide)
    469  1a3e		       f2 3e	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    470  1a3e		       f2 45	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    471  1a3e		       f2 4c	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    472  1a92
      0  1a92					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  1a92					      LIST	ON
    474  1a92
    475  1a92							;--------------------------------------------------------------------------
    476  1a92							;    CHARACTER_SET
    477  1a92
------- FILE Explosion.asm LEVEL 3 PASS 3
      0  1a92					      include	"Explosion.asm"	; 3 * LINES_PER_CHAR bytes
      0  1a92					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_EXPLOSION1", LINES_PER_CHAR
     10  1a92					      LIST	ON
      2  1a92				   CHARACTERSHAPE_EXPLOSION1		; large
      3  1a92				   CHARACTERSHAPE_EXPLOSION1_MIRRORED		; we don't worry about mirrored explosions!
      4  1a92		       44		      .byte.b	%01000100	; R (#3 bright, complementary color)
      5  1a93		       99		      .byte.b	%10011001
      6  1a94		       00		      .byte.b	%00000000
      7  1a95		       99		      .byte.b	%10011001
      8  1a96		       00		      .byte.b	%00000000
      9  1a97		       99		      .byte.b	%10011001
     10  1a98		       22		      .byte.b	%00100010
     11  1a99
     12  1a99		       44		      .byte.b	%01000100	; G (#2 basic dirt color, usually the darkest one)
     13  1a9a		       99		      .byte.b	%10011001
     14  1a9b		       22		      .byte.b	%00100010
     15  1a9c		       dd		      .byte.b	%11011101
     16  1a9d		       44		      .byte.b	%01000100
     17  1a9e		       99		      .byte.b	%10011001
     18  1a9f		       22		      .byte.b	%00100010
     19  1aa0
     20  1aa0		       44		      .byte.b	%01000100	; B (#1 additional wall/BOX color)
     21  1aa1		       99		      .byte.b	%10011001
     22  1aa2		       22		      .byte.b	%00100010
     23  1aa3		       bb		      .byte.b	%10111011
     24  1aa4		       44		      .byte.b	%01000100
     25  1aa5		       99		      .byte.b	%10011001
     26  1aa6		       22		      .byte.b	%00100010
     27  1aa7
      0  1aa7					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_EXPLOSION2", LINES_PER_CHAR
     10  1aa7					      LIST	ON
     29  1aa7				   CHARACTERSHAPE_EXPLOSION2		; medium
     30  1aa7				   CHARACTERSHAPE_EXPLOSION2_MIRRORED		; we don't worry about mirrored explosions!
     31  1aa7		       00		      .byte.b	%00000000	; R
     32  1aa8		       22		      .byte.b	%00100010
     33  1aa9		       88		      .byte.b	%10001000
     34  1aaa		       66		      .byte.b	%01100110
     35  1aab		       11		      .byte.b	%00010001
     36  1aac		       44		      .byte.b	%01000100
     37  1aad		       00		      .byte.b	%00000000
     38  1aae
     39  1aae		       00		      .byte.b	%00000000	; G
     40  1aaf		       22		      .byte.b	%00100010
     41  1ab0		       99		      .byte.b	%10011001
     42  1ab1		       66		      .byte.b	%01100110
     43  1ab2		       99		      .byte.b	%10011001
     44  1ab3		       44		      .byte.b	%01000100
     45  1ab4		       00		      .byte.b	%00000000
     46  1ab5
     47  1ab5		       00		      .byte.b	%00000000	; B
     48  1ab6		       22		      .byte.b	%00100010
     49  1ab7		       99		      .byte.b	%10011001
     50  1ab8		       66		      .byte.b	%01100110
     51  1ab9		       99		      .byte.b	%10011001
     52  1aba		       44		      .byte.b	%01000100
     53  1abb							; .byte %00000000
     54  1abb
     55  1abb							;    OPTIONAL_PAGEBREAK "CHARACTERSHAPE_EXPLOSION3", LINES_PER_CHAR
     56  1abb				   CHARACTERSHAPE_EXPLOSION3		; small
     57  1abb				   CHARACTERSHAPE_EXPLOSION3_MIRRORED		; we don't worry about mirrored explosions!
     58  1abb		       00		      .byte.b	%00000000	; R
     59  1abc		       00		      .byte.b	%00000000
     60  1abd		       44		      .byte.b	%01000100
     61  1abe		       00		      .byte.b	%00000000
     62  1abf		       22		      .byte.b	%00100010
     63  1ac0		       00		      .byte.b	%00000000
     64  1ac1		       00		      .byte.b	%00000000
     65  1ac2
     66  1ac2		       00		      .byte.b	%00000000	; G
     67  1ac3		       00		      .byte.b	%00000000
     68  1ac4		       44		      .byte.b	%01000100
     69  1ac5		       00		      .byte.b	%00000000
     70  1ac6		       22		      .byte.b	%00100010
     71  1ac7		       00		      .byte.b	%00000000
     72  1ac8		       00		      .byte.b	%00000000
     73  1ac9
     74  1ac9		       00		      .byte.b	%00000000	; B
     75  1aca		       00		      .byte.b	%00000000
     76  1acb		       44		      .byte.b	%01000100
     77  1acc		       00		      .byte.b	%00000000
     78  1acd		       22		      .byte.b	%00100010
     79  1ace		       00		      .byte.b	%00000000
     80  1acf		       00		      .byte.b	%00000000
     81  1ad0
      0  1ad0					      CHECKPAGE	CHARACTERSHAPE_EXPLOSION2	; since we share one byte!
      8  1ad0					      LIST	ON
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE Diamond.asm LEVEL 3 PASS 3
      0  1ad0					      include	"Diamond.asm"	; 2 * LINES_PER_CHAR + 2 bytes
      1  1ad0		       00 02	   DIAMOND_DEF =	2
      2  1ad0
      3  1ad0					      if	DIAMOND_DEF = 2
      4  1ad0
      0  1ad0					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_DIAMOND", LINES_PER_CHAR+1
     10  1ad0					      LIST	ON
      6  1ad0				   CHARACTERSHAPE_DIAMOND2_MIRRORED
      7  1ad0		       00		      .byte.b	%00000000
      8  1ad1				   CHARACTERSHAPE_DIAMOND_MIRRORED
      9  1ad1		       00		      .byte.b	%00000000
     10  1ad2		       66		      .byte.b	%01100110
     11  1ad3		       66		      .byte.b	%01100110
     12  1ad4		       66		      .byte.b	%01100110
     13  1ad5		       66		      .byte.b	%01100110
     14  1ad6		       00		      .byte.b	%00000000
     15  1ad7		       00		      .byte.b	%00000000	;R
     16  1ad8		       00		      .byte.b	%00000000
     17  1ad9		       00		      .byte.b	%00000000
     18  1ada		       00		      .byte.b	%00000000
     19  1adb		       00		      .byte.b	%00000000
     20  1adc		       00		      .byte.b	%00000000
     21  1add		       00		      .byte.b	%00000000
     22  1ade		       00		      .byte.b	%00000000	;B
     23  1adf		       00		      .byte.b	%00000000
     24  1ae0		       66		      .byte.b	%01100110
     25  1ae1		       66		      .byte.b	%01100110
     26  1ae2		       66		      .byte.b	%01100110
     27  1ae3		       66		      .byte.b	%01100110
     28  1ae4		       00		      .byte.b	%00000000
     29  1ae5							;    .byte %00000000 ;G
     30  1ae5
     31  1ae5							;--------------------------------------------------------------------------
     32  1ae5							;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_DIAMOND_MIRRORED", LINES_PER_CHAR+1
     33  1ae5				   CHARACTERSHAPE_DIAMOND2
     34  1ae5		       00		      .byte.b	%00000000
     35  1ae6				   CHARACTERSHAPE_DIAMOND
     36  1ae6		       00		      .byte.b	%00000000
     37  1ae7		       66		      .byte.b	%01100110
     38  1ae8		       66		      .byte.b	%01100110
     39  1ae9		       66		      .byte.b	%01100110
     40  1aea		       66		      .byte.b	%01100110
     41  1aeb		       00		      .byte.b	%00000000
     42  1aec		       00		      .byte.b	%00000000	;R
     43  1aed		       00		      .byte.b	%00000000
     44  1aee		       00		      .byte.b	%00000000
     45  1aef		       00		      .byte.b	%00000000
     46  1af0		       00		      .byte.b	%00000000
     47  1af1		       00		      .byte.b	%00000000
     48  1af2		       00		      .byte.b	%00000000
     49  1af3		       00		      .byte.b	%00000000	;B
     50  1af4		       00		      .byte.b	%00000000
     51  1af5		       66		      .byte.b	%01100110
     52  1af6		       66		      .byte.b	%01100110
     53  1af7		       66		      .byte.b	%01100110
     54  1af8		       66		      .byte.b	%01100110
     55  1af9		       00		      .byte.b	%00000000
     56  1afa		       00		      .byte.b	%00000000	;G
     57  1afb
      0  1afb					      CHECKPAGE	CHARACTERSHAPE_DIAMOND2	; since we share one byte!
      8  1afb					      LIST	ON
     59  1afb
     60  1afb					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    480  1afb							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    481  1afb
    482  1afb
      0  1afb					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  1afb		       00 03	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  1afb					      SUBROUTINE
      3  1afb				   SelfModDrawPlayers
    484  1afb
    485  1afb							; Now the player(s) have animated, update the appropriate shape pointers
    486  1afb							; in the draw code.
    487  1afb
    488  1afb							; Sets the shapes to a blank player -- effectively erasing
    489  1afb		       a5 ad		      lda	LastSpriteY
    490  1afd		       a2 25		      ldx	#<PLAYER_BLANK
    491  1aff		       20 0e f3 	      jsr	SetSelfModPlayer
    492  1b02
    493  1b02							; Now we've erased, we write the new shape
    494  1b02
    495  1b02							;		  sec
    496  1b02							;		  lda ManDrawX
    497  1b02							;		  sbc BoardScrollX
    498  1b02							;		  cmp #SCREEN_WIDTH			  ; disabled because we assume always onscreen
    499  1b02							;		  bcs NoMod				  ; skip if off visible screen
    500  1b02
    501  1b02		       a5 a1		      lda	ManDrawX
    502  1b04		       c9 0a		      cmp	#SCREEN_WIDTH	; disabled because we assume always onscreen
    503  1b06		       b0 1c		      bcs	NoMod	; skip if off visible screen
    504  1b08
    505  1b08							;lda LookingAround
    506  1b08							;bne NoMod
    507  1b08
    508  1b08		       a5 a2		      lda	ManDrawY
    509  1b0a		       85 ad		      sta	LastSpriteY
    510  1b0c
    511  1b0c		       a6 a7		      ldx	ManAnimationFrameLO
    512  1b0e
    513  1b0e				   SetSelfModPlayer
    514  1b0e		       c9 08		      cmp	#SCREEN_LINES	; only erase/draw if was/is onscreen
    515  1b10		       b0 12		      bcs	NoMod
    516  1b12		       69 00		      adc	#BANK_SCREENMARKII1
    517  1b14		       85 3e		      sta	SET_BANK_RAM	; switch old/new bank in
    518  1b16
    519  1b16		       8a		      txa
    520  1b17		       8d 20 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1	; lo of frame
    521  1b1a		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    522  1b1c		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    523  1b1f		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    524  1b21		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    525  1b24
    526  1b24				   NoMod
    527  1b24		       60		      rts
    528  1b25
------- FILE Rockford.asm LEVEL 3 PASS 3
      0  1b25					      include	"Rockford.asm"	; 6 * LINES_PER_CHAR	       MUST FOLLOW DIRT.ASM as data is shared
      1  1b25							;    OPTIONAL_PAGEBREAK "PLAYER", LINES_PER_CHAR * 6 - 1
      2  1b25
      3  1b25
      4  1b25		       f3 25	   PLAYER_BLANK =	.	; MUST APPEAR AT TOP AS DATA SHARED BY DIRT
      5  1b25					      REPEAT	LINES_PER_CHAR	;-1  ; as we have a "0" in the line below
      6  1b25		       00		      .byte.b	0
      5  1b25					      REPEND
      6  1b26		       00		      .byte.b	0
      5  1b26					      REPEND
      6  1b27		       00		      .byte.b	0
      5  1b27					      REPEND
      6  1b28		       00		      .byte.b	0
      5  1b28					      REPEND
      6  1b29		       00		      .byte.b	0
      5  1b29					      REPEND
      6  1b2a		       00		      .byte.b	0
      5  1b2a					      REPEND
      6  1b2b		       00		      .byte.b	0
      5  1b2b					      REPEND
      6  1b2c		       00		      .byte.b	0
      5  1b2c					      REPEND
      6  1b2d		       00		      .byte.b	0
      5  1b2d					      REPEND
      6  1b2e		       00		      .byte.b	0
      5  1b2e					      REPEND
      6  1b2f		       00		      .byte.b	0
      5  1b2f					      REPEND
      6  1b30		       00		      .byte.b	0
      5  1b30					      REPEND
      6  1b31		       00		      .byte.b	0
      5  1b31					      REPEND
      6  1b32		       00		      .byte.b	0
      5  1b32					      REPEND
      6  1b33		       00		      .byte.b	0
      5  1b33					      REPEND
      6  1b34		       00		      .byte.b	0
      5  1b34					      REPEND
      6  1b35		       00		      .byte.b	0
      5  1b35					      REPEND
      6  1b36		       00		      .byte.b	0
      5  1b36					      REPEND
      6  1b37		       00		      .byte.b	0
      5  1b37					      REPEND
      6  1b38		       00		      .byte.b	0
      5  1b38					      REPEND
      6  1b39		       00		      .byte.b	0
      7  1b3a					      REPEND
      8  1b3a
      9  1b3a				   PLAYER_RIGHT0
     10  1b3a							;  X XX
     11  1b3a							;  XXXX
     12  1b3a							;  XXX
     13  1b3a							;  XXX
     14  1b3a							;   XX
     15  1b3a							;   XX
     16  1b3a							;   XX
     17  1b3a							;   XX
     18  1b3a							;   XXX
     19  1b3a							;   XXX
     20  1b3a							;   XX
     21  1b3a							;   XX
     22  1b3a							;   XX
     23  1b3a							;   XX
     24  1b3a							;  XXXX
     25  1b3a							;  XXX X
     26  1b3a							;  XXX X
     27  1b3a							;  XXX X
     28  1b3a							;  XXXX
     29  1b3a							;   XX
     30  1b3a							;
     31  1b3a
     32  1b3a		       2c		      .byte.b	%00101100	; 0
     33  1b3b		       38		      .byte.b	%00111000	; 3
     34  1b3c		       18		      .byte.b	%00011000	; 6 etc.
     35  1b3d		       1c		      .byte.b	%00011100
     36  1b3e		       18		      .byte.b	%00011000
     37  1b3f		       3a		      .byte.b	%00111010
     38  1b40		       3c		      .byte.b	%00111100
     39  1b41
     40  1b41		       3c		      .byte.b	%00111100	; 1
     41  1b42		       18		      .byte.b	%00011000	; 4 etc.
     42  1b43		       18		      .byte.b	%00011000
     43  1b44		       18		      .byte.b	%00011000
     44  1b45		       18		      .byte.b	%00011000
     45  1b46		       3a		      .byte.b	%00111010
     46  1b47		       18		      .byte.b	%00011000
     47  1b48
     48  1b48		       38		      .byte.b	%00111000	; 2
     49  1b49		       18		      .byte.b	%00011000	; 5 etc.
     50  1b4a		       1c		      .byte.b	%00011100
     51  1b4b		       18		      .byte.b	%00011000
     52  1b4c		       3c		      .byte.b	%00111100
     53  1b4d		       3a		      .byte.b	%00111010
     54  1b4e		       00		      .byte.b	0
     55  1b4f
     56  1b4f				   PLAYER_RIGHT1
     57  1b4f
     58  1b4f					      IF	1 = 1
     59  1b4f							; X?	 XX
     60  1b4f							; X	 X
     61  1b4f							; X	 X
     62  1b4f							; XX	XX
     63  1b4f							;  XXXXX
     64  1b4f							;     XX
     65  1b4f							;     XX
     66  1b4f							;     XX
     67  1b4f							;     XXX
     68  1b4f							;     XXX
     69  1b4f							;     XX
     70  1b4f							;     XX
     71  1b4f							;     XX
     72  1b4f							;     XX
     73  1b4f							;    XXXX
     74  1b4f							;    XXX X
     75  1b4f							;    XXX X
     76  1b4f							;    XXX X
     77  1b4f							;    XXXX
     78  1b4f							;     XX
     79  1b4f
     80  1b4f		       43		      .byte.b	%01000011	; 0
     81  1b50		       66		      .byte.b	%01100110	; 3
     82  1b51		       18		      .byte.b	%00011000	; 6 etc.
     83  1b52		       1c		      .byte.b	%00011100
     84  1b53		       18		      .byte.b	%00011000
     85  1b54		       3a		      .byte.b	%00111010
     86  1b55		       3c		      .byte.b	%00111100
     87  1b56
     88  1b56		       42		      .byte.b	%01000010	; 1
     89  1b57		       3c		      .byte.b	%00111100	; 4 etc.
     90  1b58		       18		      .byte.b	%00011000
     91  1b59		       18		      .byte.b	%00011000
     92  1b5a		       18		      .byte.b	%00011000
     93  1b5b		       3a		      .byte.b	%00111010
     94  1b5c		       18		      .byte.b	%00011000
     95  1b5d
     96  1b5d		       42		      .byte.b	%01000010	; 2
     97  1b5e		       18		      .byte.b	%00011000	; 5 etc.
     98  1b5f		       1c		      .byte.b	%00011100
     99  1b60		       18		      .byte.b	%00011000
    100  1b61		       3c		      .byte.b	%00111100
    101  1b62		       3a		      .byte.b	%00111010
    102  1b63		       00		      .byte.b	0
    103  1b64				  -	      ELSE
    104  1b64				  -			; Alternativly make his neck pixel shorter here.
    105  1b64				  -			; This looks more dynamic, but shows a problems with the hair color.
    106  1b64				  -			; Maybe if we remove the t-shirt/trousers color look and make him
    107  1b64				  -			; look more like an insect (which he acutally is), we can fix this.
    108  1b64				  -
    109  1b64				  -			; X?	 XX
    110  1b64				  -			; X	 X
    111  1b64				  -			; X	 X
    112  1b64				  -			; XX	XX
    113  1b64				  -			;  XXXXX
    114  1b64				  -			;     XX
    115  1b64				  -			;     XX
    116  1b64				  -			;     XX
    117  1b64				  -			;     XXX
    118  1b64				  -			;     XXX
    119  1b64				  -			;     XX
    120  1b64				  -			;     XX
    121  1b64				  -			;     XX
    122  1b64				  -			;    XXXX
    123  1b64				  -			;    XXX X
    124  1b64				  -			;    XXX X
    125  1b64				  -			;    XXX X
    126  1b64				  -			;    XXXX
    127  1b64				  -			;     XX
    128  1b64				  -
    129  1b64				  -	      .byte	%01000011	; 0
    130  1b64				  -	      .byte	%01100110	; 3
    131  1b64				  -	      .byte	%00011000	; 6 etc.
    132  1b64				  -	      .byte	%00011100
    133  1b64				  -	      .byte	%00011000
    134  1b64				  -	      .byte	%00111010
    135  1b64				  -	      .byte	%00011000
    136  1b64				  -
    137  1b64				  -	      .byte	%01000010	; 1
    138  1b64				  -	      .byte	%00111100	; 4 etc.
    139  1b64				  -	      .byte	%00011000
    140  1b64				  -	      .byte	%00011000
    141  1b64				  -	      .byte	%00111100
    142  1b64				  -	      .byte	%00111010
    143  1b64				  -	      .byte	0
    144  1b64				  -
    145  1b64				  -	      .byte	%01000010	; 2
    146  1b64				  -	      .byte	%00011000	; 5 etc.
    147  1b64				  -	      .byte	%00011100
    148  1b64				  -	      .byte	%00011000
    149  1b64				  -	      .byte	%00111010
    150  1b64				  -	      .byte	%00111100
    151  1b64				  -	      .byte	0
    152  1b64					      ENDIF
    153  1b64
    154  1b64							;------------------------------------------------------------------------------
    155  1b64
    156  1b64							; NOTE: PLAYER SHAPES ARE *NOT* RGB
    157  1b64							; THEY ARE JUST REORDERED THIS WAY FOR THE KERNEL
    158  1b64
    159  1b64				   PLAYER_STAND
    160  1b64							; original 15 pixel tall, ours was 18 pixel, stretched to 20 now
    161  1b64							; this makes Rockford looks closer to original, slimmer and less fat
    162  1b64							; also BOX/diamonds above his head look less levitating now
    163  1b64
    164  1b64							; XX  XX    XX  XX    XX  XX
    165  1b64							;  X  X      X  X	X  X
    166  1b64							;  X  X      X  X	X  X
    167  1b64							;  XXXX      X  X	X  X
    168  1b64							;   XX       XXXX	XXXX
    169  1b64							;   XX        XX	 XX
    170  1b64							; X XX X    X XX X	 XX
    171  1b64							; X XX X    X XX X	 XX
    172  1b64							;  XXXX     X XX X    X XX X
    173  1b64							;   XX       XXXX     X XX X
    174  1b64							;  XXXX       XX      X XX X
    175  1b64							; X XX X      XX	XXXX
    176  1b64							; X XX X     XXXX	 XX
    177  1b64							;  XXXX     X XX X	 XX
    178  1b64							;  X  X     X XX X	XXXX
    179  1b64							;	     X XX X    X XX X
    180  1b64							;	      XXXX     X XX X
    181  1b64							;	      X  X     X XX X
    182  1b64							;			XXXX
    183  1b64							;			X  X
    184  1b64
    185  1b64		       66		      .byte.b	%01100110	; 0
    186  1b65		       24		      .byte.b	%00100100	; 3
    187  1b66		       18		      .byte.b	%00011000	; 6 etc.
    188  1b67		       5a		      .byte.b	%01011010
    189  1b68		       18		      .byte.b	%00011000
    190  1b69		       5a		      .byte.b	%01011010
    191  1b6a		       3c		      .byte.b	%00111100
    192  1b6b
    193  1b6b		       24		      .byte.b	%00100100	; 1
    194  1b6c		       3c		      .byte.b	%00111100	; 4 etc.
    195  1b6d		       18		      .byte.b	%00011000
    196  1b6e		       5a		      .byte.b	%01011010
    197  1b6f		       18		      .byte.b	%00011000
    198  1b70		       5a		      .byte.b	%01011010
    199  1b71		       24		      .byte.b	%00100100
    200  1b72
    201  1b72		       24		      .byte.b	%00100100	; 2
    202  1b73		       18		      .byte.b	%00011000	; 5 etc.
    203  1b74		       5a		      .byte.b	%01011010
    204  1b75		       3c		      .byte.b	%00111100
    205  1b76		       3c		      .byte.b	%00111100
    206  1b77		       5a		      .byte.b	%01011010
    207  1b78		       00		      .byte.b	0
    208  1b79
    209  1b79				   PLAYER_BLINK
    210  1b79							; XX  XX
    211  1b79							;  X  X
    212  1b79							;  X  X
    213  1b79							;  X  X
    214  1b79							;  XXXX
    215  1b79							;   XX
    216  1b79							;   XX
    217  1b79							;   XX
    218  1b79							; X XX X
    219  1b79							; X XX X
    220  1b79							; X XX X
    221  1b79							;  XXXX
    222  1b79							;   XX
    223  1b79							;   XX
    224  1b79							;  XXXX
    225  1b79							; XXXXXX
    226  1b79							; XXXXXX
    227  1b79							; XXXXXX
    228  1b79							;  XXXX
    229  1b79							;  X  X
    230  1b79
    231  1b79		       66		      .byte.b	%01100110	; 0
    232  1b7a		       24		      .byte.b	%00100100	; 3
    233  1b7b		       18		      .byte.b	%00011000	; 6 etc.
    234  1b7c		       5a		      .byte.b	%01011010
    235  1b7d		       18		      .byte.b	%00011000
    236  1b7e		       7e		      .byte.b	%01111110
    237  1b7f		       3c		      .byte.b	%00111100
    238  1b80
    239  1b80		       24		      .byte.b	%00100100	; 1
    240  1b81		       3c		      .byte.b	%00111100	; 4 etc.
    241  1b82		       18		      .byte.b	%00011000
    242  1b83		       5a		      .byte.b	%01011010
    243  1b84		       18		      .byte.b	%00011000
    244  1b85		       7e		      .byte.b	%01111110
    245  1b86		       24		      .byte.b	%00100100
    246  1b87
    247  1b87		       24		      .byte.b	%00100100	; 2
    248  1b88		       18		      .byte.b	%00011000	; 5 etc.
    249  1b89		       5a		      .byte.b	%01011010
    250  1b8a		       3c		      .byte.b	%00111100
    251  1b8b		       3c		      .byte.b	%00111100
    252  1b8c		       7e		      .byte.b	%01111110
    253  1b8d		       00		      .byte.b	0
    254  1b8e							; 1
    255  1b8e				   PLAYER_TAP0
    256  1b8e							; XX  XX
    257  1b8e							;  X  X
    258  1b8e							;  X  X
    259  1b8e							;  X  X
    260  1b8e							;  XXXX
    261  1b8e							;   XX
    262  1b8e							;   XX
    263  1b8e							;   XX
    264  1b8e							;  XXXX
    265  1b8e							; X XX X
    266  1b8e							; X XX X
    267  1b8e							;  XXXX
    268  1b8e							;   XX
    269  1b8e							;   XX
    270  1b8e							;  XXXX
    271  1b8e							; X XX X
    272  1b8e							; X XX X
    273  1b8e							; X XX X
    274  1b8e							;  XXXX
    275  1b8e							;  X  X
    276  1b8e
    277  1b8e		       66		      .byte.b	%01100110	; 0
    278  1b8f		       24		      .byte.b	%00100100	; 3
    279  1b90		       18		      .byte.b	%00011000	; 6 etc.
    280  1b91		       5a		      .byte.b	%01011010
    281  1b92		       18		      .byte.b	%00011000
    282  1b93		       5a		      .byte.b	%01011010
    283  1b94		       3c		      .byte.b	%00111100
    284  1b95
    285  1b95		       24		      .byte.b	%00100100	; 1
    286  1b96		       3c		      .byte.b	%00111100	; 4 etc.
    287  1b97		       18		      .byte.b	%00011000
    288  1b98		       5a		      .byte.b	%01011010
    289  1b99		       18		      .byte.b	%00011000
    290  1b9a		       5a		      .byte.b	%01011010
    291  1b9b		       24		      .byte.b	%00100100
    292  1b9c
    293  1b9c		       24		      .byte.b	%00100100	; 2
    294  1b9d		       18		      .byte.b	%00011000	; 5 etc.
    295  1b9e		       3c		      .byte.b	%00111100
    296  1b9f		       3c		      .byte.b	%00111100
    297  1ba0		       3c		      .byte.b	%00111100
    298  1ba1		       5a		      .byte.b	%01011010
    299  1ba2		       00		      .byte.b	0
    300  1ba3
    301  1ba3				   PLAYER_TAP1
    302  1ba3							;     XX
    303  1ba3							; XX  X
    304  1ba3							;  X  X
    305  1ba3							;  X  X
    306  1ba3							;  XXXX
    307  1ba3							;   XX
    308  1ba3							;   XX
    309  1ba3							;   XX
    310  1ba3							;  XXXX
    311  1ba3							; X XX X
    312  1ba3							; X XX X
    313  1ba3							;  XXXX
    314  1ba3							;   XX
    315  1ba3							;   XX
    316  1ba3							;  XXXX
    317  1ba3							; X XX X
    318  1ba3							; X XX X
    319  1ba3							; X XX X
    320  1ba3							;  XXXX
    321  1ba3							;  X  X
    322  1ba3
    323  1ba3		       06		      .byte.b	%00000110	; 0
    324  1ba4		       24		      .byte.b	%00100100	; 3
    325  1ba5		       18		      .byte.b	%00011000	; 6 etc.
    326  1ba6		       5a		      .byte.b	%01011010
    327  1ba7		       18		      .byte.b	%00011000
    328  1ba8		       5a		      .byte.b	%01011010
    329  1ba9		       3c		      .byte.b	%00111100
    330  1baa
    331  1baa		       64		      .byte.b	%01100100	; 1
    332  1bab		       3c		      .byte.b	%00111100	; 4 etc.
    333  1bac		       18		      .byte.b	%00011000
    334  1bad		       5a		      .byte.b	%01011010
    335  1bae		       18		      .byte.b	%00011000
    336  1baf		       5a		      .byte.b	%01011010
    337  1bb0		       24		      .byte.b	%00100100
    338  1bb1
    339  1bb1		       24		      .byte.b	%00100100	; 2
    340  1bb2		       18		      .byte.b	%00011000	; 5 etc.
    341  1bb3		       3c		      .byte.b	%00111100
    342  1bb4		       3c		      .byte.b	%00111100
    343  1bb5		       3c		      .byte.b	%00111100
    344  1bb6		       5a		      .byte.b	%01011010
    345  1bb7		       00		      .byte.b	0
    346  1bb8
    347  1bb8							;    CHECKPAGE PLAYER_BLANK
      0  1bb8					      CHECKPAGEX	CHARACTERSHAPE_SOIL, "Rockford in Rockford.asm"	; since we share some 0 bytes!
      9  1bb8					      LIST	ON
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE Dirt.asm LEVEL 3 PASS 3
      0  1bb8					      include	"Dirt.asm"	; 2 * LINES_PER_CHAR bytes
      1  1bb8		       00 05	   SOIL_DEF   =	5
      2  1bb8
      3  1bb8							; 3   RELEASED BD1
      4  1bb8							; 4
      5  1bb8							; 5   AD SOLID
      6  1bb8							; 6   AD INVERTED of released version
      7  1bb8
      8  1bb8
      9  1bb8				  -	      if	SOIL_DEF = 0
     10  1bb8				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     11  1bb8				  -CHARACTERSHAPE_SOIL
     12  1bb8				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     13  1bb8				  -	      .byte	%01110111,%11011101,%11101110,%11011101,%10101010,%01010101,%11101110	;G
     14  1bb8				  -			;  .byte %01010101,%10111011,%11101110,%11011101,%01110111,%11011101,%10101010 ;G
     15  1bb8				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;B
     16  1bb8				  -
     17  1bb8				  -			;--------------------------------------------------------------------------
     18  1bb8				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     19  1bb8				  -CHARACTERSHAPE_SOIL_MIRRORED
     20  1bb8				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     21  1bb8				  -	      .byte	%10111011,%11111111,%11011101,%11111111,%01110111,%11111111,%11101110	;G
     22  1bb8				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00010001,%00000000,%00000000	;B
     23  1bb8					      endif
     24  1bb8
     25  1bb8				  -	      if	SOIL_DEF = 1
     26  1bb8				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     27  1bb8				  -CHARACTERSHAPE_SOIL
     28  1bb8				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     29  1bb8				  -			;  .byte %01110111,%11011101,%11101110,%11011101,%10101010,%01010101,%11101110 ;G
     30  1bb8				  -	      .byte	%01010101,%10111011,%11101110,%11011101,%01110111,%11011101,%10101010	;G
     31  1bb8				  -	      .byte	%00000000,%00010001,%00000000,%00000000,%01000100,%00000000,%00000000	;B
     32  1bb8				  -
     33  1bb8				  -			;--------------------------------------------------------------------------
     34  1bb8				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     35  1bb8				  -CHARACTERSHAPE_SOIL_MIRRORED
     36  1bb8				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     37  1bb8				  -	      .byte	%10101010,%11011101,%01110111,%10111011,%11101110,%10111011,%01010101	;G
     38  1bb8				  -	      .byte	%00000000,%10001000,%00000000,%00000000,%00100010,%00000000,%00000000	;B
     39  1bb8				  -			; .byte %10111011,%11111111,%11011101,%11111111,%01110111,%11111111,%11101110 ;G
     40  1bb8				  -			; .byte %00000000,%00000000,%01000100,%00000000,%00010001,%00000000,%00000000 ;B
     41  1bb8					      endif
     42  1bb8
     43  1bb8				  -	      if	SOIL_DEF = 2
     44  1bb8				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     45  1bb8				  -CHARACTERSHAPE_SOIL
     46  1bb8				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     47  1bb8				  -	      .byte	%10101010,%01110111,%11011101,%10101010,%01110111,%10111011,%01010101	;G
     48  1bb8				  -	      .byte	%00000000,%01000100,%00000000,%00000000,%00010001,%00000000,%00000000	;B
     49  1bb8				  -
     50  1bb8				  -			;--------------------------------------------------------------------------
     51  1bb8				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     52  1bb8				  -CHARACTERSHAPE_SOIL_MIRRORED
     53  1bb8				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     54  1bb8				  -	      .byte	%01010101,%11101110,%10111011,%01010101,%11101110,%11011101,%10101010	;G
     55  1bb8				  -	      .byte	%00000000,%00100010,%00000000,%00000000,%10001000,%00000000,%00000000	;B
     56  1bb8					      endif
     57  1bb8
     58  1bb8				  -	      if	SOIL_DEF = 3
     59  1bb8				  -			; "ORIGINAL"
     60  1bb8				  -			;--------------------------------------------------------------------------
     61  1bb8				  -
     62  1bb8				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     63  1bb8				  -CHARACTERSHAPE_SOIL
     64  1bb8				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     65  1bb8				  -	      .byte	%10101010,%00100010,%01010101,%00100010,%01010101,%10101010,%00010001	;G
     66  1bb8				  -			;.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ;B
     67  1bb8				  -
     68  1bb8				  -			;--------------------------------------------------------------------------
     69  1bb8				  -			;	 OPTIONAL_PAGEBREAK "CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     70  1bb8				  -CHARACTERSHAPE_SOIL_MIRRORED
     71  1bb8				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     72  1bb8				  -	      .byte	%01010101,%01000100,%10101010,%01000100,%10101010,%01010101,%10001000	;G
     73  1bb8				  -
     74  1bb8				  -			; AD TODO - THIS IS ERRONEOUSLY OPTIMISED OUT....
     75  1bb8				  -			; AD IT RELIES ON WHATEVER FOLLOWS TO BE 0 BUT NOT ENFORCED SO ERRROR
     76  1bb8				  -			; .byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ;B shared with Rockford.asm!
     77  1bb8				  -
     78  1bb8				  -			;--------------------------------------------------------------------------
     79  1bb8					      endif
     80  1bb8
     81  1bb8				  -	      if	SOIL_DEF = 4
     82  1bb8				  -			; "ORIGINAL"
     83  1bb8				  -			;--------------------------------------------------------------------------
     84  1bb8				  -
     85  1bb8				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     86  1bb8				  -CHARACTERSHAPE_SOIL
     87  1bb8				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     88  1bb8				  -	      .byte	%10001000,%01010101,%10101010,%01010101,%00100010,%10101010,%01010101	;G
     89  1bb8				  -	      .byte	%00000000,%00000000,%10001000,%00000000,%00000000,%00100010,%00000000	;B
     90  1bb8				  -
     91  1bb8				  -			;--------------------------------------------------------------------------
     92  1bb8				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     93  1bb8				  -CHARACTERSHAPE_SOIL_MIRRORED
     94  1bb8				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     95  1bb8				  -	      .byte	%00010001,%10101010,%01010101,%10101010,%01000100,%01010101,%10101010	;G
     96  1bb8				  -	      .byte	%00000000,%00000000,%00010001,%00000000,%00000000,%01000100,%00000000	;B
     97  1bb8				  -
     98  1bb8				  -			;--------------------------------------------------------------------------
     99  1bb8					      endif
    100  1bb8
    101  1bb8					      if	SOIL_DEF = 5
    102  1bb8							; SOLID
      0  1bb8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  1bb8					      LIST	ON
    104  1bb8				   CHARACTERSHAPE_SOIL
    105  1bb8				   CHARACTERSHAPE_SOIL_MIRRORED
    106  1bb8		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
    107  1bbf		       ff		      .byte.b	%11111111
    108  1bc0		       ff		      .byte.b	%11111111
    109  1bc1		       ff		      .byte.b	%11111111
    110  1bc2		       ff		      .byte.b	%11111111
    111  1bc3		       ff		      .byte.b	%11111111
    112  1bc4		       ff		      .byte.b	%11111111
    113  1bc5		       ff		      .byte.b	%11111111
    114  1bc6		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
    115  1bcd					      endif
    116  1bcd
    117  1bcd				  -	      if	SOIL_DEF = 6
    118  1bcd				  -			; INVERTED
    119  1bcd				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
    120  1bcd				  -CHARACTERSHAPE_SOIL
    121  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
    122  1bcd				  -	      .byte	%01010101,%11011101,%10101010,%11011101,%10101010,%01010101,%11101110	;G
    123  1bcd				  -			;.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ;B
    124  1bcd				  -
    125  1bcd				  -			;--------------------------------------------------------------------------
    126  1bcd				  -			;	 OPTIONAL_PAGEBREAK "CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
    127  1bcd				  -CHARACTERSHAPE_SOIL_MIRRORED
    128  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
    129  1bcd				  -	      .byte	%10101010,%10111011,%01010101,%10111011,%01010101,%10101010,%01110111	;G
    130  1bcd				  -
    131  1bcd				  -			; AD TODO - THIS IS ERRONEOUSLY OPTIMISED OUT....
    132  1bcd				  -			; AD IT RELIES ON WHATEVER FOLLOWS TO BE 0 BUT NOT ENFORCED SO ERRROR
    133  1bcd				  -			; .byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ;B shared with Rockford.asm!
    134  1bcd					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE Magic_Wall.asm LEVEL 3 PASS 3
      0  1bcd					      include	"Magic_Wall.asm"	; 3 * LINES_PER_CHAR bytes
      1  1bcd							;    OPTIONAL_PAGEBREAK "CHARACTERSHAPE_WALL3", LINES_PER_CHAR
      2  1bcd							;CHARACTERSHAPE_WALL3
      3  1bcd							; .byte %00000000,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011 ;R
      4  1bcd							; .byte %11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011 ;G
      5  1bcd							; .byte %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000 ;B
      6  1bcd
      7  1bcd							;--------------------------------------------------------------------------
      0  1bcd					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL2", LINES_PER_CHAR
     10  1bcd					      LIST	ON
      9  1bcd				   CHARACTERSHAPE_WALL2
     10  1bcd		       00 dd dd 00*	      .byte.b	%00000000,%11011101,%11011101,%00000000,%01110111,%01110111,%01110111	;R
     11  1bd4		       dd dd dd 00*	      .byte.b	%11011101,%11011101,%11011101,%00000000,%01110111,%01110111,%01110111	;G
     12  1bdb		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;,%0 ;B
     13  1be2
     14  1be2							;--------------------------------------------------------------------------
     15  1be2							;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_WALL1", LINES_PER_CHAR
     16  1be2				   CHARACTERSHAPE_WALL1
     17  1be2		       00 bb bb 00*	      .byte.b	%00000000,%10111011,%10111011,%00000000,%11101110,%11101110,%11101110	;R
     18  1be9		       bb bb bb 00*	      .byte.b	%10111011,%10111011,%10111011,%00000000,%11101110,%11101110,%11101110	;G
     19  1bf0		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     20  1bf7
      0  1bf7					      CHECKPAGE	CHARACTERSHAPE_WALL2	; since we share one byte!
      8  1bf7					      LIST	ON
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    532  1bf7
      0  1bf7					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  1bf7
      2  1bf7
      3  1bf7		       03 f7	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $3f7 , FREE= $9
      4  1bf7					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1bf7				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1bf7				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1bf7				  -	      ERR
      8  1bf7					      endif
    534  1bf7
    535  1bf7							;------------------------------------------------------------------------------
    536  1bf7
    537  1bf7							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    538  1bf7
    539  1bf7							;------------------------------------------------------------------------------
    540  1bf7
    541  1bf7
    542  1bf7
    543  1bf7							;	 CHECK_HALF_BANK_SIZE "ROM_SHADOW_OF_RAMBANK_CODE"
    544  1bf7
    545  1bf7
    546  1bf7							; Here there's another 1K of usable ROM....
    547  1bf7							; BUT!!! WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    548  1bf7
    549  1bf7							;-----------------------------------------------------------
    550  1bf7							; Stella 3E autodetect signature, can live anywhere
    551  1bf7		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
    552  1bfb							;-----------------------------------------------------------
------- FILE CaveBank2.asm LEVEL 3 PASS 3
      0  1bfb					      include	"CaveBank2.asm"
      1  1bfb							; Cave definitions
      2  1bfb
      3  1bfb
      4  1bfb							;------------------------------------------------------------------------------
      5  1bfb							;##############################################################################
      6  1bfb							;------------------------------------------------------------------------------
      7  1bfb
      8  1bfb							;IFCONST CAVE_NAMED_FUNNEL
      0  1bfb					      START_CAVE	FUNNEL
      1  1bfb				   CAVE_START SET	*
      2  1bfb		       00 03	   BANK_CAVE_FUNNEL =	_CURRENT_BANK
      3  1bfb				   CAVE_FUNNEL SUBROUTINE
      4  1bfb				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  1bfb
     10  1bfb
     11  1bfb		       0f		      .byte.b	$0F	; Cave 15 O
      0  1bfc					      CAVE_SIZE_ROOM		; width, height
      0  1bfc					      CAVE_SIZE	40, 22
      1  1bfc		       28 16		      .byte.b	40,22
     13  1bfe		       08		      .byte.b	$08	; Magic wall/amoeba slow growth for: 8 seconds
     14  1bff		       10		      .byte.b	$10	;BCD'd $0A			    ; Diamonds worth: 10 points
     15  1c00		       20		      .byte.b	$20	;BCD'd $14			    ; Extra diamonds worth: 20 points
     16  1c01		       01 1d 1e 1f*	      .byte.b	$01, $1D, $1E, $1F, $20	; Randomiser seed values for difficulty levels 1-5
     17  1c06		       0f 14 14 19*	      .byte.b	$0F, $14, $14, $19, $1E	; Diamonds needed: 15, 20, 20, 25, 30 (for difficulty levels 1-5)
     18  1c0b		       78 78 78 78*	      .byte.b	$78, $78, $78, $78, $8C	; Cave time: 120, 120, 120, 120, 140 seconds
     19  1c10
     20  1c10							;-------------------------------------------------------------------------------------
     21  1c10							; PALETTE DEFINITIONS
     22  1c10
     23  1c10				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
     24  1c10				  -	      .byte	$88, $c6
     25  1c10				  -	      .byte	$24, $44
     26  1c10				  -	      .byte	$ee, $5e
     27  1c10					      ELSE
     28  1c10
     29  1c10							; COMMENT FOLLOWING OUT IF NOT WANTED!
     30  1c10							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
     31  1c10					      IF	AD_MODE
     32  1c10		       88 c6		      .byte.b	$88, $c6
     33  1c12		       24 44		      .byte.b	$24, $44
     34  1c14		       ee 5e		      .byte.b	$ee, $5e
     35  1c16					      ENDIF
     36  1c16
     37  1c16							; COMMENT FOLLOWING OUT IF NOT WANTED!
     38  1c16							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
     39  1c16				  -	      IF	TJ_MODE
     40  1c16				  -	      .byte	$88, $c6
     41  1c16				  -	      .byte	$24, $44
     42  1c16				  -	      .byte	$ee, $5e
     43  1c16					      ENDIF
     44  1c16
     45  1c16					      ENDIF
     46  1c16
     47  1c16							;-------------------------------------------------------------------------------------
     48  1c16
     49  1c16
     50  1c16		       00 02 09 00	      .byte.b	$00, CHARACTER_BOX, CHARACTER_FIREFLY, $00	; Random objects:
     51  1c1a		       64 50 02 00	      .byte.b	$64, $50, $02, $00	;   zSpace : 100/256 = 39%
     52  1c1e							;   zBouS  :  80/256 = 31%
     53  1c1e							;   zFFly1 :	2/256 =  0%
     54  1c1e							;   fourth code unused (0%)
     55  1c1e
     56  1c1e		       50 02 04 0a*	      .byte.b	LINE+CHARACTER_WALL, $02, $04, $0A, $03	; Line of zBrick from ( 2, 4); length = 10; direction = down/right
     57  1c23		       50 0f 0d 0a*	      .byte.b	LINE+CHARACTER_WALL, $0F, $0D, $0A, $01	; Line of zBrick from (15,13); length = 10; direction = up/right
     58  1c28		       41 0c 0e 03*	      .byte.b	LINE+CHARACTER_SOIL, $0C, $0E, $03, $02	; Line of zDirt from (12,14); length = 3; direction = right
     59  1c2d		       4b 0c 0f 03*	      .byte.b	LINE+CHARACTER_WALL0, $0C, $0F, $03, $02	; Line of zMagic from (12,15); length = 3; direction = right
     60  1c32		       11 14 16 	      .byte.b	CHARACTER_EXITDOOR, $14, $16	; StoreChar zPreOut at (20,22)
     61  1c35		       06 14 03 	      .byte.b	CHARACTER_MANOCCUPIED, $14, $03	; StoreChar zPRFd1 at (20, 3)
     62  1c38
      0  1c38					      END_CAVE	FUNNEL
      1  1c38		       ff		      .byte.b	$FF
      2  1c38		       00 3e	   CAVE_SIZE_FUNNEL =	* - CAVE_START
      3  1c39					      IF	CAVE_SIZE_FUNNEL > MAX_CAVE_SIZE
      4  1c39				   MAX_CAVE_SIZE SET	CAVE_SIZE_FUNNEL
      5  1c39					      ENDIF
     64  1c39							;ENDIF
     65  1c39
     66  1c39							;------------------------------------------------------------------------------
     67  1c39
     68  1c39					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
     69  1c39
      0  1c39					      START_CAVE	INTERMISSION_4
      1  1c39				   CAVE_START SET	*
      2  1c39		       00 03	   BANK_CAVE_INTERMISSION_4 =	_CURRENT_BANK
      3  1c39				   CAVE_INTERMISSION_4 SUBROUTINE
      4  1c39				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  1c39
     71  1c39
     72  1c39		       14		      .byte.b	$14	; Cave 20
      0  1c3a					      CAVE_SIZE_INTERMISSION		; width, height
      0  1c3a					      CAVE_SIZE	20, 12
      1  1c3a		       14 0c		      .byte.b	20,12
     74  1c3c		       03		      .byte.b	$03	; Magic wall/amoeba slow growth for: 3 seconds
     75  1c3d		       30		      .byte.b	$30	;BCD'd $1E			    ; Diamonds worth: 30 points
     76  1c3e		       00		      .byte.b	$00	; Extra diamonds worth: 0 points
     77  1c3f		       00 00 00 00*	      .byte.b	$00, $00, $00, $00, $00	; Randomiser seed values for difficulty levels 1-5
     78  1c44		       06 06 06 06*	      .byte.b	$06, $06, $06, $06, $06	; Diamonds needed: 6, 6, 6, 6, 6 (for difficulty levels 1-5)
     79  1c49		       14 14 14 14*	      .byte.b	$14, $14, $14, $14, $14	; Cave time: 20, 20, 20, 20, 20 seconds
     80  1c4e
     81  1c4e							;-------------------------------------------------------------------------------------
     82  1c4e							; PALETTE DEFINITIONS
     83  1c4e
     84  1c4e				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
     85  1c4e				  -	      .byte	$28, $48
     86  1c4e				  -	      .byte	$a6, $b6
     87  1c4e				  -	      .byte	$0e, $0e
     88  1c4e					      ELSE
     89  1c4e
     90  1c4e							; COMMENT FOLLOWING OUT IF NOT WANTED!
     91  1c4e							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
     92  1c4e					      IF	AD_MODE
     93  1c4e		       28 48		      .byte.b	$28, $48
     94  1c50		       a6 b6		      .byte.b	$a6, $b6
     95  1c52		       0e 0e		      .byte.b	$0e, $0e
     96  1c54					      ENDIF
     97  1c54
     98  1c54							; COMMENT FOLLOWING OUT IF NOT WANTED!
     99  1c54							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    100  1c54				  -	      IF	TJ_MODE
    101  1c54				  -	      .byte	$28, $48
    102  1c54				  -	      .byte	$a6, $b6
    103  1c54				  -	      .byte	$0e, $0e
    104  1c54					      ENDIF
    105  1c54
    106  1c54					      ENDIF
    107  1c54
    108  1c54							;-------------------------------------------------------------------------------------
    109  1c54
    110  1c54
    111  1c54
    112  1c54							; ENDIF
    113  1c54
    114  1c54		       00 00 00 00	      .byte.b	$00, $00, $00, $00	; Random objects:
    115  1c58		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
    116  1c5c							;   second code unused (0%)
    117  1c5c							;   third code unused (0%)
    118  1c5c							;   fourth code unused (0%)
    119  1c5c
    120  1c5c							;   superfluous due to limited cave size
    121  1c5c							;    .byte   FILL+CHARACTER_STEEL, $00, $02, $28, $16, CHARACTER_STEEL; FilledRect of zSteel from ( 0, 2); length = 40; height = 22; fill = zSteel
    122  1c5c		       8f 00 02 14*	      .byte.b	FILL+CHARACTER_STEEL, $00, $02, $14, $0C, CHARACTER_SOIL	; FilledRect of zSteel from ( 0, 2); length = 20; height = 12; fill = zDirt
    123  1c62		       c2 0b 03 03*	      .byte.b	RECT+CHARACTER_BOX, $0B, $03, $03, $02	; Rect of zBouS from (11, 3); length = 3; height = 2
    124  1c67		       80 0b 07 03*	      .byte.b	FILL+CHARACTER_BLANK, $0B, $07, $03, $06, CHARACTER_BLANK	; FilledRect of zSpace from (11, 7); length = 3; height = 6; fill = zSpace
    125  1c6d		       4b 0b 06 03*	      .byte.b	LINE+CHARACTER_WALL0, $0B, $06, $03, $02	; Line of zMagic from (11, 6); length = 3; direction = right
    126  1c72		       4b 0b 0a 03*	      .byte.b	LINE+CHARACTER_WALL0, $0B, $0A, $03, $02	; Line of zMagic from (11,10); length = 3; direction = right
    127  1c77		       42 08 07 03*	      .byte.b	LINE+CHARACTER_BOX, $08, $07, $03, $03	; Line of zBouS from ( 8, 7); length = 3; direction = down/right
    128  1c7c		       06 03 03 	      .byte.b	CHARACTER_MANOCCUPIED, $03, $03	; StoreChar zPRFd1 at ( 3, 3)
    129  1c7f		       11 09 0a 	      .byte.b	CHARACTER_EXITDOOR, $09, $0A	; StoreChar zPreOut at ( 9,10)
    130  1c82
      0  1c82					      END_CAVE	INTERMISSION_4
      1  1c82		       ff		      .byte.b	$FF
      2  1c82		       00 4a	   CAVE_SIZE_INTERMISSION_4 =	* - CAVE_START
      3  1c83					      IF	CAVE_SIZE_INTERMISSION_4 > MAX_CAVE_SIZE
      4  1c83				   MAX_CAVE_SIZE SET	CAVE_SIZE_INTERMISSION_4
      5  1c83					      ENDIF
    132  1c83
    133  1c83							;------------------------------------------------------------------------------
    134  1c83
    135  1c83					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  1c83					      START_CAVE	GUARDS
      1  1c83				   CAVE_START SET	*
      2  1c83		       00 03	   BANK_CAVE_GUARDS =	_CURRENT_BANK
      3  1c83				   CAVE_GUARDS SUBROUTINE
      4  1c83				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  1c83
    137  1c83
    138  1c83		       05		      .byte.b	$05	; Cave 05 E
      0  1c84					      CAVE_SIZE_ROOM		; width, height
      0  1c84					      CAVE_SIZE	40, 22
      1  1c84		       28 16		      .byte.b	40,22
    140  1c86		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    141  1c87		       50		      .byte.b	$50	;BCD'd $32			    ; Diamonds worth: 50 points
    142  1c88		       90		      .byte.b	$90	;BCD'd $5A			    ; Extra diamonds worth: 90 points
    143  1c89		       00 00 00 00*	      .byte.b	$00, $00, $00, $00, $00	; Randomiser seed values for difficulty levels 1-5
    144  1c8e		       04 05 06 07*	      .byte.b	$04, $05, $06, $07, $08	; Diamonds needed: 4, 5, 6, 7, 8 (for difficulty levels 1-5)
    145  1c93		       96 78 5a 3c*	      .byte.b	$96, $78, $5A, $3C, $1E	; Cave time: 150, 120, 90, 60, 30 seconds
    146  1c98
    147  1c98							;-------------------------------------------------------------------------------------
    148  1c98							; PALETTE DEFINITIONS
    149  1c98
    150  1c98				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    151  1c98				  -	      .byte	$48, $68	; NTSC/PAL
    152  1c98				  -	      .byte	$24, $46	; NTSC/PAL
    153  1c98				  -	      .byte	$ae, $be	; NTSC/PAL
    154  1c98					      ELSE
    155  1c98
    156  1c98							; COMMENT FOLLOWING OUT IF NOT WANTED!
    157  1c98							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    158  1c98					      IF	AD_MODE
    159  1c98							;good
    160  1c98							;	  .byte   $e8, $38
    161  1c98							;	  .byte   $58, $86
    162  1c98							;	  .byte   $ca, $5a
    163  1c98		       26 68		      .byte.b	$26, $68
    164  1c9a		       04 24		      .byte.b	$04, $24
    165  1c9c		       9e 0e		      .byte.b	$9e, $0e
    166  1c9e					      ENDIF
    167  1c9e
    168  1c9e							; COMMENT FOLLOWING OUT IF NOT WANTED!
    169  1c9e							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    170  1c9e				  -	      IF	TJ_MODE
    171  1c9e				  -	      .byte	$48, $68
    172  1c9e				  -	      .byte	$24, $46
    173  1c9e				  -	      .byte	$ae, $9e
    174  1c9e					      ENDIF
    175  1c9e
    176  1c9e					      ENDIF
    177  1c9e
    178  1c9e							;-------------------------------------------------------------------------------------
    179  1c9e
    180  1c9e		       00 00 00 00	      .byte.b	$00, $00, $00, $00	; Random objects:
    181  1ca2		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
    182  1ca6							;   second code unused (0%)
    183  1ca6							;   third code unused (0%)
    184  1ca6							;   fourth code unused (0%)
    185  1ca6
    186  1ca6		       06 01 03 	      .byte.b	CHARACTER_MANOCCUPIED, $01, $03	; StoreChar zPRFd1 at ( 1, 3)
    187  1ca9		       11 27 16 	      .byte.b	CHARACTER_EXITDOOR, $27, $16	; StoreChar zPreOut at (39,22)
    188  1cac		       80 08 0a 03*	      .byte.b	FILL+CHARACTER_BLANK, $08, $0A, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from ( 8,10); length = 3; height = 3; fill = zSpace
    189  1cb2		       80 10 0a 03*	      .byte.b	FILL+CHARACTER_BLANK, $10, $0A, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from (16,10); length = 3; height = 3; fill = zSpace
    190  1cb8		       80 18 0a 03*	      .byte.b	FILL+CHARACTER_BLANK, $18, $0A, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from (24,10); length = 3; height = 3; fill = zSpace
    191  1cbe		       80 20 0a 03*	      .byte.b	FILL+CHARACTER_BLANK, $20, $0A, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from (32,10); length = 3; height = 3; fill = zSpace
    192  1cc4		       04 09 0c 	      .byte.b	CHARACTER_DIAMOND, $09, $0C	; StoreChar zDiaS at ( 9,12)
    193  1cc7		       09 0a 0a 	      .byte.b	CHARACTER_FIREFLY, $0A, $0A	; StoreChar zFFly1 at (10,10)
    194  1cca		       04 11 0c 	      .byte.b	CHARACTER_DIAMOND, $11, $0C	; StoreChar zDiaS at (17,12)
    195  1ccd		       09 12 0a 	      .byte.b	CHARACTER_FIREFLY, $12, $0A	; StoreChar zFFly1 at (18,10)
    196  1cd0		       04 19 0c 	      .byte.b	CHARACTER_DIAMOND, $19, $0C	; StoreChar zDiaS at (25,12)
    197  1cd3		       09 1a 0a 	      .byte.b	CHARACTER_FIREFLY, $1A, $0A	; StoreChar zFFly1 at (26,10)
    198  1cd6		       04 21 0c 	      .byte.b	CHARACTER_DIAMOND, $21, $0C	; StoreChar zDiaS at (33,12)
    199  1cd9		       09 22 0a 	      .byte.b	CHARACTER_FIREFLY, $22, $0A	; StoreChar zFFly1 at (34,10)
    200  1cdc		       80 08 10 03*	      .byte.b	FILL+CHARACTER_BLANK, $08, $10, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from ( 8,16); length = 3; height = 3; fill = zSpace
    201  1ce2		       80 10 10 03*	      .byte.b	FILL+CHARACTER_BLANK, $10, $10, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from (16,16); length = 3; height = 3; fill = zSpace
    202  1ce8		       80 18 10 03*	      .byte.b	FILL+CHARACTER_BLANK, $18, $10, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from (24,16); length = 3; height = 3; fill = zSpace
    203  1cee		       80 20 10 03*	      .byte.b	FILL+CHARACTER_BLANK, $20, $10, $03, $03, CHARACTER_BLANK	; FilledRect of zSpace from (32,16); length = 3; height = 3; fill = zSpace
    204  1cf4		       04 09 12 	      .byte.b	CHARACTER_DIAMOND, $09, $12	; StoreChar zDiaS at ( 9,18)
    205  1cf7		       09 0a 10 	      .byte.b	CHARACTER_FIREFLY, $0A, $10	; StoreChar zFFly1 at (10,16)
    206  1cfa		       04 11 12 	      .byte.b	CHARACTER_DIAMOND, $11, $12	; StoreChar zDiaS at (17,18)
    207  1cfd		       09 12 10 	      .byte.b	CHARACTER_FIREFLY, $12, $10	; StoreChar zFFly1 at (18,16)
    208  1d00		       04 19 12 	      .byte.b	CHARACTER_DIAMOND, $19, $12	; StoreChar zDiaS at (25,18)
    209  1d03		       09 1a 10 	      .byte.b	CHARACTER_FIREFLY, $1A, $10	; StoreChar zFFly1 at (26,16)
    210  1d06		       04 21 12 	      .byte.b	CHARACTER_DIAMOND, $21, $12	; StoreChar zDiaS at (33,18)
    211  1d09		       09 22 10 	      .byte.b	CHARACTER_FIREFLY, $22, $10	; StoreChar zFFly1 at (34,16)
    212  1d0c
    213  1d0c							;    .byte   LINE+CHARACTER_WALL, $09, $10, $1E, $02	 ; Line of zBrick from ( 9,16); length = 30; direction = right
    214  1d0c
      0  1d0c					      END_CAVE	GUARDS
      1  1d0c		       ff		      .byte.b	$FF
      2  1d0c		       00 8a	   CAVE_SIZE_GUARDS =	* - CAVE_START
      3  1d0d					      IF	CAVE_SIZE_GUARDS > MAX_CAVE_SIZE
      4  1d0d				   MAX_CAVE_SIZE SET	CAVE_SIZE_GUARDS
      5  1d0d					      ENDIF
    216  1d0d					      ENDIF
    217  1d0d
    218  1d0d							;------------------------------------------------------------------------------
    219  1d0d
    220  1d0d					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  1d0d					      START_CAVE	FIREFLY_DENS
      1  1d0d				   CAVE_START SET	*
      2  1d0d		       00 03	   BANK_CAVE_FIREFLY_DENS =	_CURRENT_BANK
      3  1d0d				   CAVE_FIREFLY_DENS SUBROUTINE
      4  1d0d				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  1d0d
    222  1d0d
    223  1d0d		       06		      .byte.b	$06	; Cave 06 F
      0  1d0e					      CAVE_SIZE_ROOM		; width, height
      0  1d0e					      CAVE_SIZE	40, 22
      1  1d0e		       28 16		      .byte.b	40,22
    225  1d10		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    226  1d11		       40		      .byte.b	$40	;BCD'd $28			    ; Diamonds worth: 40 points
    227  1d12		       60		      .byte.b	$60	;BCD'd $3C			    ; Extra diamonds worth: 60 points
    228  1d13		       00 14 15 16*	      .byte.b	$00, $14, $15, $16, $17	; Randomiser seed values for difficulty levels 1-5
    229  1d18		       04 06 07 08*	      .byte.b	$04, $06, $07, $08, $08	; Diamonds needed: 4, 6, 7, 8, 8 (for difficulty levels 1-5)
    230  1d1d		       96 78 64 5a*	      .byte.b	$96, $78, $64, $5A, $50	; Cave time: 150, 120, 100, 90, 80 seconds
    231  1d22
    232  1d22							;-------------------------------------------------------------------------------------
    233  1d22							; PALETTE DEFINITIONS
    234  1d22
    235  1d22				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    236  1d22				  -	      .byte	$26, $48
    237  1d22				  -	      .byte	$78, $a4
    238  1d22				  -	      .byte	$de, $5e
    239  1d22					      ELSE
    240  1d22
    241  1d22							; COMMENT FOLLOWING OUT IF NOT WANTED!
    242  1d22							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    243  1d22					      IF	AD_MODE
    244  1d22		       26 48		      .byte.b	$26, $48
    245  1d24		       78 a4		      .byte.b	$78, $a4
    246  1d26		       de 5e		      .byte.b	$de, $5e
    247  1d28					      ENDIF
    248  1d28
    249  1d28							; COMMENT FOLLOWING OUT IF NOT WANTED!
    250  1d28							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    251  1d28				  -	      IF	TJ_MODE
    252  1d28				  -	      .byte	$26, $48
    253  1d28				  -	      .byte	$78, $a4
    254  1d28				  -	      .byte	$de, $5e
    255  1d28					      ENDIF
    256  1d28
    257  1d28					      ENDIF
    258  1d28
    259  1d28							;-------------------------------------------------------------------------------------
    260  1d28
    261  1d28		       02 00 00 00	      .byte.b	CHARACTER_BOX, $00, $00, $00	; Random objects:
    262  1d2c		       32 00 00 00	      .byte.b	$32, $00, $00, $00	;   zBouS  :  50/256 = 19%
    263  1d30							;   second code unused (0%)
    264  1d30							;   third code unused (0%)
    265  1d30							;   fourth code unused (0%)
    266  1d30
    267  1d30		       90 01 03 0a*	      .byte.b	FILL+CHARACTER_WALL, $01, $03, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from ( 1, 3); length = 10; height = 4; fill = zSpace
    268  1d36		       90 01 06 0a*	      .byte.b	FILL+CHARACTER_WALL, $01, $06, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from ( 1, 6); length = 10; height = 4; fill = zSpace
    269  1d3c		       90 01 09 0a*	      .byte.b	FILL+CHARACTER_WALL, $01, $09, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from ( 1, 9); length = 10; height = 4; fill = zSpace
    270  1d42		       90 01 0c 0a*	      .byte.b	FILL+CHARACTER_WALL, $01, $0C, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from ( 1,12); length = 10; height = 4; fill = zSpace
    271  1d48		       41 0a 03 0d*	      .byte.b	LINE+CHARACTER_SOIL, $0A, $03, $0D, $04	; Line of zDirt from (10, 3); length = 13; direction = down
    272  1d4d		       04 03 05 	      .byte.b	CHARACTER_DIAMOND, $03, $05	; StoreChar zDiaS at ( 3, 5)
    273  1d50		       09 04 05 	      .byte.b	CHARACTER_FIREFLY, $04, $05	; StoreChar zFFly1 at ( 4, 5)
    274  1d53		       04 03 08 	      .byte.b	CHARACTER_DIAMOND, $03, $08	; StoreChar zDiaS at ( 3, 8)
    275  1d56		       09 04 08 	      .byte.b	CHARACTER_FIREFLY, $04, $08	; StoreChar zFFly1 at ( 4, 8)
    276  1d59		       04 03 0b 	      .byte.b	CHARACTER_DIAMOND, $03, $0B	; StoreChar zDiaS at ( 3,11)
    277  1d5c		       09 04 0b 	      .byte.b	CHARACTER_FIREFLY, $04, $0B	; StoreChar zFFly1 at ( 4,11)
    278  1d5f		       04 03 0e 	      .byte.b	CHARACTER_DIAMOND, $03, $0E	; StoreChar zDiaS at ( 3,14)
    279  1d62		       09 04 0e 	      .byte.b	CHARACTER_FIREFLY, $04, $0E	; StoreChar zFFly1 at ( 4,14)
    280  1d65		       90 1d 03 0a*	      .byte.b	FILL+CHARACTER_WALL, $1D, $03, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from (29, 3); length = 10; height = 4; fill = zSpace
    281  1d6b		       90 1d 06 0a*	      .byte.b	FILL+CHARACTER_WALL, $1D, $06, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from (29, 6); length = 10; height = 4; fill = zSpace
    282  1d71		       90 1d 09 0a*	      .byte.b	FILL+CHARACTER_WALL, $1D, $09, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from (29, 9); length = 10; height = 4; fill = zSpace
    283  1d77		       90 1d 0c 0a*	      .byte.b	FILL+CHARACTER_WALL, $1D, $0C, $0A, $04, CHARACTER_BLANK	; FilledRect of zBrick from (29,12); length = 10; height = 4; fill = zSpace
    284  1d7d		       41 1d 03 0d*	      .byte.b	LINE+CHARACTER_SOIL, $1D, $03, $0D, $04	; Line of zDirt from (29, 3); length = 13; direction = down
    285  1d82		       04 24 05 	      .byte.b	CHARACTER_DIAMOND, $24, $05	; StoreChar zDiaS at (36, 5)
    286  1d85		       09 23 05 	      .byte.b	CHARACTER_FIREFLY, $23, $05	; StoreChar zFFly1 at (35, 5)
    287  1d88		       04 24 08 	      .byte.b	CHARACTER_DIAMOND, $24, $08	; StoreChar zDiaS at (36, 8)
    288  1d8b		       09 23 08 	      .byte.b	CHARACTER_FIREFLY, $23, $08	; StoreChar zFFly1 at (35, 8)
    289  1d8e		       04 24 0b 	      .byte.b	CHARACTER_DIAMOND, $24, $0B	; StoreChar zDiaS at (36,11)
    290  1d91		       09 23 0b 	      .byte.b	CHARACTER_FIREFLY, $23, $0B	; StoreChar zFFly1 at (35,11)
    291  1d94		       04 24 0e 	      .byte.b	CHARACTER_DIAMOND, $24, $0E	; StoreChar zDiaS at (36,14)
    292  1d97		       09 23 0e 	      .byte.b	CHARACTER_FIREFLY, $23, $0E	; StoreChar zFFly1 at (35,14)
    293  1d9a		       06 03 14 	      .byte.b	CHARACTER_MANOCCUPIED, $03, $14	; StoreChar zPRFd1 at ( 3,20)
    294  1d9d		       11 26 14 	      .byte.b	CHARACTER_EXITDOOR, $26, $14	; StoreChar zPreOut at (38,20)
    295  1da0
      0  1da0					      END_CAVE	FIREFLY_DENS
      1  1da0		       ff		      .byte.b	$FF
      2  1da0		       00 94	   CAVE_SIZE_FIREFLY_DENS =	* - CAVE_START
      3  1da1					      IF	CAVE_SIZE_FIREFLY_DENS > MAX_CAVE_SIZE
      4  1da1				   MAX_CAVE_SIZE SET	CAVE_SIZE_FIREFLY_DENS
      5  1da1					      ENDIF
    297  1da1					      ENDIF
    298  1da1
    299  1da1							;------------------------------------------------------------------------------
    300  1da1
    301  1da1					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  1da1					      START_CAVE	AMOEBA
      1  1da1				   CAVE_START SET	*
      2  1da1		       00 03	   BANK_CAVE_AMOEBA =	_CURRENT_BANK
      3  1da1				   CAVE_AMOEBA SUBROUTINE
      4  1da1				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  1da1
    303  1da1
    304  1da1		       07		      .byte.b	$07	; Cave 07 G
      0  1da2					      CAVE_SIZE_ROOM		; width, height
      0  1da2					      CAVE_SIZE	40, 22
      1  1da2		       28 16		      .byte.b	40,22
    306  1da4		       4b		      .byte.b	$4B	; Magic wall/amoeba slow growth for: 75 seconds
    307  1da5		       10		      .byte.b	$10	;BCD'd $0A			    ; Diamonds worth: 10 points
    308  1da6		       20		      .byte.b	$20	;BCD'd $14			    ; Extra diamonds worth: 20 points
    309  1da7		       02 07 08 0a*	      .byte.b	$02, $07, $08, $0A, $09	; Randomiser seed values for difficulty levels 1-5
    310  1dac		       0f 14 19 19*	      .byte.b	$0F, $14, $19, $19, $19	; Diamonds needed: 15, 20, 25, 25, 25 (for difficulty levels 1-5)
    311  1db1		       78 78 78 78*	      .byte.b	$78, $78, $78, $78, $78	; Cave time: 120, 120, 120, 120, 120 seconds
    312  1db6
    313  1db6							;-------------------------------------------------------------------------------------
    314  1db6							; PALETTE DEFINITIONS
    315  1db6
    316  1db6				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    317  1db6				  -	      .byte	$48, $68
    318  1db6				  -	      .byte	$04, $06
    319  1db6				  -	      .byte	$c8, $5a
    320  1db6					      ELSE
    321  1db6
    322  1db6							; COMMENT FOLLOWING OUT IF NOT WANTED!
    323  1db6							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    324  1db6					      IF	AD_MODE
    325  1db6		       48 66		      .byte.b	$48, $66
    326  1db8		       04 04		      .byte.b	$04, $04
    327  1dba		       c8 58		      .byte.b	$c8, $58
    328  1dbc					      ENDIF
    329  1dbc
    330  1dbc							; COMMENT FOLLOWING OUT IF NOT WANTED!
    331  1dbc							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    332  1dbc				  -	      IF	TJ_MODE
    333  1dbc				  -	      .byte	$4a, $68
    334  1dbc				  -	      .byte	$26, $24
    335  1dbc				  -	      .byte	$d8, $7a
    336  1dbc					      ENDIF
    337  1dbc
    338  1dbc					      ENDIF
    339  1dbc
    340  1dbc							;-------------------------------------------------------------------------------------
    341  1dbc							;
    342  1dbc
    343  1dbc		       00		      .byte.b	CHARACTER_BLANK	; Random objects:
    344  1dbd		       02		      .byte.b	CHARACTER_BOX
    345  1dbe		       09		      .byte.b	CHARACTER_FIREFLY
    346  1dbf		       00		      .byte.b	0	; unused
    347  1dc0		       64 28 02 00	      .byte.b	$64, $28, $02, $00	;   zSpace : 100/256 = 39%
    348  1dc4							;   zBouS  :  40/256 = 15%
    349  1dc4							;   zFFly1 :	2/256 =  0%
    350  1dc4							;   fourth code unused (0%)
    351  1dc4
    352  1dc4		       50 01 07 0c*	      .byte.b	LINE+CHARACTER_WALL, $01, $07, $0C, $02	; Line of zBrick from ( 1, 7); length = 12; direction = right
    353  1dc9		       50 1c 05 0b*	      .byte.b	LINE+CHARACTER_WALL, $1C, $05, $0B, $02	; Line of zBrick from (28, 5); length = 11; direction = right
    354  1dce		       43 13 15 02*	      .byte.b	LINE+CHARACTER_AMOEBA, $13, $15, $02, $02	; Line of zAmoe from (19,21); length = 2; direction = right
    355  1dd3		       04 04 06 	      .byte.b	CHARACTER_DIAMOND, $04, $06	; StoreChar zDiaS at ( 4, 6)
    356  1dd6		       04 04 0e 	      .byte.b	CHARACTER_DIAMOND, $04, $0E	; StoreChar zDiaS at ( 4,14)
    357  1dd9		       04 04 16 	      .byte.b	CHARACTER_DIAMOND, $04, $16	; StoreChar zDiaS at ( 4,22)
    358  1ddc		       04 22 04 	      .byte.b	CHARACTER_DIAMOND, $22, $04	; StoreChar zDiaS at (34, 4)
    359  1ddf		       04 22 0c 	      .byte.b	CHARACTER_DIAMOND, $22, $0C	; StoreChar zDiaS at (34,12)
    360  1de2		       04 22 16 	      .byte.b	CHARACTER_DIAMOND, $22, $16	; StoreChar zDiaS at (34,22)
    361  1de5		       06 14 06 	      .byte.b	CHARACTER_MANOCCUPIED, $14, $06	; StoreChar zPRFd1 at (20, 3)
    362  1de8		       11 27 07 	      .byte.b	CHARACTER_EXITDOOR, $27, $07	; StoreChar zPreOut at (39, 7)
    363  1deb
      0  1deb					      END_CAVE	AMOEBA
      1  1deb		       ff		      .byte.b	$FF
      2  1deb		       00 4b	   CAVE_SIZE_AMOEBA =	* - CAVE_START
      3  1dec				  -	      IF	CAVE_SIZE_AMOEBA > MAX_CAVE_SIZE
      4  1dec				  -MAX_CAVE_SIZE SET	CAVE_SIZE_AMOEBA
      5  1dec					      ENDIF
    365  1dec					      ENDIF
    366  1dec
    367  1dec							;------------------------------------------------------------------------------
    368  1dec
    369  1dec					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  1dec					      START_CAVE	ENCHANTED_WALL
      1  1dec				   CAVE_START SET	*
      2  1dec		       00 03	   BANK_CAVE_ENCHANTED_WALL =	_CURRENT_BANK
      3  1dec				   CAVE_ENCHANTED_WALL SUBROUTINE
      4  1dec				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  1dec
    371  1dec
    372  1dec		       08		      .byte.b	$08	; Cave 08 H
      0  1ded					      CAVE_SIZE_ROOM		; width, height
      0  1ded					      CAVE_SIZE	40, 22
      1  1ded		       28 16		      .byte.b	40,22
    374  1def		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    375  1df0		       10		      .byte.b	$10	;BCD'd $0A			    ; Diamonds worth: 10 points
    376  1df1		       20		      .byte.b	$20	;BCD'd $14			    ; Extra diamonds worth: 20 points
    377  1df2		       01 03 04 05*	      .byte.b	$01, $03, $04, $05, $06	; Randomiser seed values for difficulty levels 1-5
    378  1df7		       0a 0f 14 14*	      .byte.b	$0A, $0F, $14, $14, $14	; Diamonds needed: 10, 15, 20, 20, 20 (for difficulty levels 1-5)
    379  1dfc		       78 6e 64 5a*	      .byte.b	$78, $6E, $64, $5A, $50	; Cave time: 120, 110, 100, 90, 80 seconds
    380  1e01
    381  1e01							;-------------------------------------------------------------------------------------
    382  1e01							; PALETTE DEFINITIONS
    383  1e01
    384  1e01				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    385  1e01				  -	      .byte	$98, $d8
    386  1e01				  -	      .byte	$44, $66
    387  1e01				  -	      .byte	$de, $3e
    388  1e01					      ELSE
    389  1e01
    390  1e01							; COMMENT FOLLOWING OUT IF NOT WANTED!
    391  1e01							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    392  1e01					      IF	AD_MODE
    393  1e01		       98 d8		      .byte.b	$98, $d8
    394  1e03		       44 66		      .byte.b	$44, $66
    395  1e05		       de 3e		      .byte.b	$de, $3e
    396  1e07					      ENDIF
    397  1e07
    398  1e07							; COMMENT FOLLOWING OUT IF NOT WANTED!
    399  1e07							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    400  1e07				  -	      IF	TJ_MODE
    401  1e07				  -	      .byte	$98, $d8
    402  1e07				  -	      .byte	$44, $66
    403  1e07				  -	      .byte	$de, $3e
    404  1e07					      ENDIF
    405  1e07
    406  1e07					      ENDIF
    407  1e07
    408  1e07							;-------------------------------------------------------------------------------------
    409  1e07
    410  1e07		       00 02 09 00	      .byte.b	$00, CHARACTER_BOX, CHARACTER_FIREFLY, $00	; Random objects:
    411  1e0b		       5a 32 02 00	      .byte.b	$5A, $32, $02, $00	;   zSpace :  90/256 = 35%
    412  1e0f							;   zBouS  :  50/256 = 19%
    413  1e0f							;   zFFly1 :	2/256 =  0%
    414  1e0f							;   fourth code unused (0%)
    415  1e0f		       04 04 06 	      .byte.b	CHARACTER_DIAMOND, $04, $06	; StoreChar zDiaS at ( 4, 6)
    416  1e12		       04 22 04 	      .byte.b	CHARACTER_DIAMOND, $22, $04	; StoreChar zDiaS at (34, 4)
    417  1e15		       04 22 0c 	      .byte.b	CHARACTER_DIAMOND, $22, $0C	; StoreChar zDiaS at (34,12)
    418  1e18		       11 00 05 	      .byte.b	CHARACTER_EXITDOOR, $00, $05	; StoreChar zPreOut at ( 0, 5)
    419  1e1b		       06 14 03 	      .byte.b	CHARACTER_MANOCCUPIED, $14, $03	; StoreChar zPRFd1 at (20, 3)
    420  1e1e		       50 01 07 0c*	      .byte.b	LINE+CHARACTER_WALL, $01, $07, $0C, $02	; Line of zBrick from ( 1, 7); length = 12; direction = right
    421  1e23		       50 01 0f 0c*	      .byte.b	LINE+CHARACTER_WALL, $01, $0F, $0C, $02	; Line of zBrick from ( 1,15); length = 12; direction = right
    422  1e28		       50 1c 05 0b*	      .byte.b	LINE+CHARACTER_WALL, $1C, $05, $0B, $02	; Line of zBrick from (28, 5); length = 11; direction = right
    423  1e2d		       50 1c 0d 0b*	      .byte.b	LINE+CHARACTER_WALL, $1C, $0D, $0B, $02	; Line of zBrick from (28,13); length = 11; direction = right
    424  1e32		       4b 0e 11 08*	      .byte.b	LINE+CHARACTER_WALL0, $0E, $11, $08, $02	; Line of zMagic from (14,17); length = 8; direction = right
    425  1e37		       04 0c 10 	      .byte.b	CHARACTER_DIAMOND, $0C, $10	; StoreChar zDiaS at (12,16)
    426  1e3a		       00 0e 12 	      .byte.b	CHARACTER_BLANK, $0E, $12	; StoreChar zSpace at (14,18)
    427  1e3d		       04 13 12 	      .byte.b	CHARACTER_DIAMOND, $13, $12	; StoreChar zDiaS at (19,18)
    428  1e40		       41 0e 0f 08*	      .byte.b	LINE+CHARACTER_SOIL, $0E, $0F, $08, $02	; Line of zDirt from (14,15); length = 8; direction = right
    429  1e45
      0  1e45					      END_CAVE	ENCHANTED_WALL
      1  1e45		       ff		      .byte.b	$FF
      2  1e45		       00 5a	   CAVE_SIZE_ENCHANTED_WALL =	* - CAVE_START
      3  1e46				  -	      IF	CAVE_SIZE_ENCHANTED_WALL > MAX_CAVE_SIZE
      4  1e46				  -MAX_CAVE_SIZE SET	CAVE_SIZE_ENCHANTED_WALL
      5  1e46					      ENDIF
    431  1e46					      ENDIF
    432  1e46
    433  1e46							;------------------------------------------------------------------------------
    434  1e46
    435  1e46					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  1e46					      START_CAVE	GREED
      1  1e46				   CAVE_START SET	*
      2  1e46		       00 03	   BANK_CAVE_GREED =	_CURRENT_BANK
      3  1e46				   CAVE_GREED SUBROUTINE
      4  1e46				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  1e46
    437  1e46
    438  1e46		       09		      .byte.b	$09	; Cave 09 I
      0  1e47					      CAVE_SIZE_ROOM		; width, height
      0  1e47					      CAVE_SIZE	40, 22
      1  1e47		       28 16		      .byte.b	40,22
    440  1e49		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    441  1e4a		       05		      .byte.b	$05	; Diamonds worth: 5 points
    442  1e4b		       10		      .byte.b	$10	;BCD'd $0A			    ; Extra diamonds worth: 10 points
    443  1e4c		       64 89 8c fb*	      .byte.b	$64, $89, $8C, $FB, $33	; Randomiser seed values for difficulty levels 1-5
    444  1e51		       4b 4b 50 55*	      .byte.b	$4B, $4B, $50, $55, $5A	; Diamonds needed: 75, 75, 80, 85, 90 (for difficulty levels 1-5)
    445  1e56		       96 96 82 82*	      .byte.b	$96, $96, $82, $82, $78	; Cave time: 150, 150, 130, 130, 120 seconds
    446  1e5b
    447  1e5b							;-------------------------------------------------------------------------------------
    448  1e5b							; PALETTE DEFINITIONS
    449  1e5b
    450  1e5b				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    451  1e5b				  -	      .byte	$d6, $34
    452  1e5b				  -	      .byte	$88, $d8
    453  1e5b				  -	      .byte	$2e, $2e
    454  1e5b					      ELSE
    455  1e5b
    456  1e5b							; COMMENT FOLLOWING OUT IF NOT WANTED!
    457  1e5b							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    458  1e5b					      IF	AD_MODE
    459  1e5b		       d6 34		      .byte.b	$d6, $34
    460  1e5d		       88 d8		      .byte.b	$88, $d8
    461  1e5f		       2e 2e		      .byte.b	$2e, $2e
    462  1e61					      ENDIF
    463  1e61
    464  1e61							; COMMENT FOLLOWING OUT IF NOT WANTED!
    465  1e61							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    466  1e61				  -	      IF	TJ_MODE
    467  1e61				  -	      .byte	$d8, $78
    468  1e61				  -	      .byte	$94, $d4
    469  1e61				  -	      .byte	$3e, $4e
    470  1e61					      ENDIF
    471  1e61
    472  1e61					      ENDIF
    473  1e61
    474  1e61							;-------------------------------------------------------------------------------------
    475  1e61
    476  1e61
    477  1e61		       02 04 00 00	      .byte.b	CHARACTER_BOX, CHARACTER_DIAMOND, $00, $00	; Random objects:
    478  1e65		       f0 78 00 00	      .byte.b	$F0, $78, $00, $00	;   zBouS  : 240/256 = 93-46%
    479  1e69							;   zDiaS  : 120/256 = 46%
    480  1e69							;   third code unused (0%)
    481  1e69							;   fourth code unused (0%)
    482  1e69
    483  1e69		       90 05 0a 0d*	      .byte.b	FILL+CHARACTER_WALL, $05, $0A, $0D, $0D, CHARACTER_BLANK	; FilledRect of zBrick from ( 5,10); length = 13; height = 13; fill = zSpace
    484  1e6f		       01 0c 0a 	      .byte.b	CHARACTER_SOIL, $0C, $0A	; StoreChar zDirt at (12,10)
    485  1e72		       90 19 0a 0d*	      .byte.b	FILL+CHARACTER_WALL, $19, $0A, $0D, $0D, CHARACTER_BLANK	; FilledRect of zBrick from (25,10); length = 13; height = 13; fill = zSpace
    486  1e78		       01 1f 0a 	      .byte.b	CHARACTER_SOIL, $1F, $0A	; StoreChar zDirt at (31,10)
    487  1e7b		       50 11 12 09*	      .byte.b	LINE+CHARACTER_WALL, $11, $12, $09, $02	; Line of zBrick from (17,18); length = 9; direction = right
    488  1e80		       40 11 13 09*	      .byte.b	LINE+CHARACTER_BLANK, $11, $13, $09, $02	; Line of zSpace from (17,19); length = 9; direction = right
    489  1e85		       06 07 0c 	      .byte.b	CHARACTER_MANOCCUPIED, $07, $0C	; StoreChar zPRFd1 at ( 7,12)
    490  1e88		       11 08 0c 	      .byte.b	CHARACTER_EXITDOOR, $08, $0C	; StoreChar zPreOut at ( 8,12)
    491  1e8b
      0  1e8b					      END_CAVE	GREED
      1  1e8b		       ff		      .byte.b	$FF
      2  1e8b		       00 46	   CAVE_SIZE_GREED =	* - CAVE_START
      3  1e8c				  -	      IF	CAVE_SIZE_GREED > MAX_CAVE_SIZE
      4  1e8c				  -MAX_CAVE_SIZE SET	CAVE_SIZE_GREED
      5  1e8c					      ENDIF
    493  1e8c					      ENDIF
    494  1e8c
    495  1e8c							;ECHO "MAX CAVE SIZE = ", MAX_CAVE_SIZE
    496  1e8c							;ECHO "MAX_CAVE_NUMBER = ", MAX_CAVE_NUMBER
    497  1e8c
    498  1e8c
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    554  1e8c
    555  1e8c
      0  1e8c					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  1e8c		       06 8c	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $68c , FREE= $174
      2  1e8c					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1e8c				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1e8c				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1e8c				  -	      ERR
      6  1e8c					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 3
      0  1e8c					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  1e8c							;------------------------------------------------------------------------------
      2  1e8c							;##############################################################################
      3  1e8c							;------------------------------------------------------------------------------
      4  1e8c
      0  1e8c					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  26d9 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      6  2000
      7  2000							; NOTE: Access to these buffers must NOT overlap pages...
      8  2000
      9  2000
     10  2000							; The blank stack is a stack of recently blanked-out squares.	These squares
     11  2000							; are processed to determine if any of the surrounding squares should also
     12  2000							; be processed (for example, an action causing a blank square may cause some
     13  2000							; other action in surrounding squares, a sort of chain reaction).  The blank
     14  2000							; stack is usually added to when objects move.  Objects on the blank stack
     15  2000							; are not persistant (the blanks reference squares on the board, not physical
     16  2000							; objects doing things).
     17  2000
     18  2000
     19  2000							; THe BlankStack lists can NOT overlap page boundaries. Be careful.
     20  2000		       00 80	   BLANK_STACK_MAX =	128	; may NOT be extended
     21  2000
     22  2000		       00 00 00 00*BlankStackX ds	BLANK_STACK_MAX
     23  2080		       00 00 00 00*BlankStackY ds	BLANK_STACK_MAX
     24  2100
     25  2100							; NOTE: We get auto-initialisation of these variables from the ROM values by
     26  2100							; copying the whole bank into the RAM bank.  Neato.
     27  2100
     28  2100		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     29  2100
     30  2100
     31  2100
     32  2100		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     33  2150		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     34  21a0
      0  21a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  21a0					      LIST	ON
     36  21a0
     37  21a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     38  21a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     39  21a0							; what we want to happen!
     40  21a0
     41  21a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
     42  21f0
     43  21f0
     44  21f0
     45  21f0							;------------------------------------------------------------------------------
     46  21f0							; RAM-BASED SUBROUTINES...
     47  21f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     48  21f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     49  21f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     50  21f0							; the RAM-based routine.
     51  21f0
     52  21f0
     53  21f0
     54  21f0							;------------------------------------------------------------------------------
     55  21f0
      0  21f0					      DEFINE_SUBROUTINE	InsertBlankStack	;=32(A) ; in RAM
      1  21f0		       00 04	   BANK_InsertBlankStack =	_CURRENT_BANK
      2  21f0					      SUBROUTINE
      3  21f0				   InsertBlankStack
     57  21f0
     58  21f0							; places a blank square (POS_X,POS_Y) into the blank object stack
     59  21f0
     60  21f0		       a4 8d		      ldy	BlankStackPtr	; 3
     61  21f2
     62  21f2					      if	BLANK_STACK_MAX = 128
     63  21f2		       30 0c		      bmi	BuffersFull	; 2/3
     64  21f4				  -	      else
     65  21f4				  -	      cpy	#BLANK_STACK_MAX
     66  21f4				  -	      beq	BuffersFull	; A REAL PROBLEM, BUT GRACEFULLY HANDLE IT
     67  21f4					      endif
     68  21f4
     69  21f4		       a5 90		      lda	POS_Y	; 3
     70  21f6		       99 80 f4 	      sta	BlankStackY+RAM_WRITE,y	; 5
     71  21f9		       a5 8f		      lda	POS_X	; 3
     72  21fb		       99 00 f4 	      sta	BlankStackX+RAM_WRITE,y	; 5
     73  21fe
     74  21fe		       e6 8d		      inc	BlankStackPtr	; 5
     75  2200
     76  2200				   waitForDraw
     77  2200		       60	   BuffersFull rts		; 6
     78  2201
     79  2201							;------------------------------------------------------------------------------
     80  2201
      0  2201					      DEFINE_SUBROUTINE	DrawStackUpdate	;=196 (+13 for fall-through bit)
      1  2201		       00 04	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  2201					      SUBROUTINE
      3  2201				   DrawStackUpdate
     82  2201
     83  2201							; Parse the DrawFlags buffer and create a draw stack
     84  2201							; so that the actual draw doesn't need to scan for characters to draw.
     85  2201
     86  2201
     87  2201							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     88  2201							; symptoms would be missing parts of screen when scrolling.
     89  2201							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     90  2201
     91  2201		       a5 89		      lda	DrawStackPointer
     92  2203		       10 fb		      bpl	waitForDraw	; Wait for previously not-drawn characters to be drawn
     93  2205
     94  2205		       ad 84 02 	      lda	INTIM	;4
     95  2208		       c9 05		      cmp	#SEGTIME_BDS	;2
     96  220a		       90 f4		      bcc	waitForDraw	;2/3
      0  220c					      STRESS_TIME	SEGTIME_BDS
      1  220c				  -	      IF	TEST_SEGTIME_BDS = 1
      2  220c				  -
      3  220c				  -
      4  220c				  -
      5  220c				  -
      6  220c				  -
      7  220c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  220c				  -	      bne	. - 7
      9  220c					      ENDIF
     98  220c
     99  220c
    100  220c							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
    101  220c							; moving into the middle of dirt, or BOXs when pushing, or diamonds when grabbing.
    102  220c
    103  220c							;		  sec		 already set
    104  220c		       a5 a0		      lda	ManY	;3
    105  220e		       e5 9a		      sbc	BoardScrollY	;3
    106  2210		       85 a2		      sta	ManDrawY	;3
    107  2212
    108  2212		       38		      sec		;2
    109  2213		       a5 9f		      lda	ManX	;3
    110  2215		       e5 9b		      sbc	BoardScrollX	;3
    111  2217		       c9 0a		      cmp	#SCREEN_WIDTH	;2
    112  2219		       90 06		      bcc	onsc	;2/3
    113  221b
    114  221b							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
    115  221b							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
    116  221b							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
    117  221b
    118  221b		       a9 08		      lda	#SCREEN_LINES	;2
    119  221d		       85 a2		      sta	ManDrawY	;3
    120  221f		       d0 02		      bne	skipsc	;3		  unconditional
    121  2221
    122  2221		       85 a1	   onsc       sta	ManDrawX	;3
    123  2223				   skipsc
    124  2223
    125  2223		       e6 ae		      inc	timer	;5
    126  2225		       4c 09 fd 	      jmp	AnimateCharReplacements2	;3+139
    127  2228				   retAnim
    128  2228
    129  2228		       e6 8e		      inc	ScreenDrawPhase	;5
    130  222a
    131  222a		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
    132  222c		       85 de		      sta	DSL	;3
    133  222e
    134  222e							; fall through...
    135  222e							;---------------------------------------------------------------------------
    136  222e
      0  222e					      DEFINE_SUBROUTINE	DrawIntoStack
      1  222e		       00 04	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  222e					      SUBROUTINE
      3  222e				   DrawIntoStack
    138  222e
    139  222e		       ba		      tsx		;2
    140  222f		       86 df		      stx	save_SP	;3
    141  2231		       a6 89		      ldx	DrawStackPointer	;3
    142  2233		       9a		      txs		;2 = 10
    143  2234
    144  2234		       a4 de		      ldy	DSL	;3
    145  2236
    146  2236							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    147  2236							; + exit cost which is +10 cycles
    148  2236							; TJ: I count 63
    149  2236							;   + 14 for the wtf2 exit
    150  2236							;   + 22 for the end of loop exit
    151  2236
    152  2236							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    153  2236							; For 80 iterations that is 640 cycles, just for checking INTIM
    154  2236							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    155  2236							; it also will require a lot of CPU time for updating the screen data.
    156  2236
    157  2236							; TODO: optimize!
    158  2236							;
    159  2236							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    160  2236							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    161  2236							; costs some detection time here, but saves ~240 cylces for drawing the two
    162  2236
    163  2236		       ad 84 02    .loopDrawStack lda	INTIM	;4
    164  2239		       c9 05		      cmp	#SEGTIME_DSL	;2
    165  223b		       90 4d		      bcc	.exitDrawStack	;2/3= 8/9
      0  223d					      STRESS_TIME	SEGTIME_DSL
      1  223d				  -	      IF	TEST_SEGTIME_DSL = 1
      2  223d				  -
      3  223d				  -
      4  223d				  -
      5  223d				  -
      6  223d				  -
      7  223d				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  223d				  -	      bne	. - 7
      9  223d					      ENDIF
    167  223d
    168  223d		       b9 50 f1 	      lda	DrawFlag,y	;4
    169  2240		       d9 a0 f1 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    170  2243		       f0 16		      beq	.next0	;2/3=10/11	 yes, so we don't draw anything
    171  2245
    172  2245							; Character is NOT the same. Figure out how it should be drawn.
    173  2245							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    174  2245							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    175  2245							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    176  2245
    177  2245		       be ef f2 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    178  2248		       dd 50 f1 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    179  224b		       d0 05		      bne	.notPaired0	;2/3=10/11
    180  224d
    181  224d							; Consider two 'paired' characters. Either A:A or A:B
    182  224d							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    183  224d							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    184  224d							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    185  224d							; on the comparison, so the character will not be added to the draw stack. So our first character will
    186  224d							; do the job of drawing BOTH characters to the screen.
    187  224d
    188  224d		       9d a0 f5 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    189  2250		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    190  2252
    191  2252							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    192  2252							; the last write(below) marks the character as to be direct-drawn.
    193  2252
    194  2252		       99 a0 f5    .notPaired0 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    195  2255
    196  2255							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    197  2255
    198  2255		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    199  2256		       98		      tya		;2
    200  2257		       ba		      tsx		;2		 << now X holds drawstackpointer
    201  2258		       9d 00 f5 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    202  225b
    203  225b		       88	   .next0     dey		;2
    204  225c		       30 21		      bmi	.finishedDrawStack	;2/3= 4/5
    205  225e
    206  225e							; unrolled 2nd loop:
    207  225e		       b9 50 f1 	      lda	DrawFlag,y	;4
    208  2261		       d9 a0 f1 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    209  2264		       f0 16		      beq	.next1	;2/3=10/11	 yes, so we don't draw anything
    210  2266
    211  2266		       be ef f2 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    212  2269		       dd 50 f1 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    213  226c		       d0 05		      bne	.notPaired1	;2/3=10/11
    214  226e
    215  226e		       9d a0 f5 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    216  2271		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    217  2273
    218  2273		       99 a0 f5    .notPaired1 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    219  2276
    220  2276		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    221  2277		       98		      tya		;2
    222  2278		       ba		      tsx		;2
    223  2279		       9d 00 f5 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    224  227c
    225  227c		       88	   .next1     dey		;2
    226  227d		       10 b7		      bpl	.loopDrawStack	;2/3= 4/5
    227  227f							;worst case: 111-4
    228  227f							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    229  227f
    230  227f							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    231  227f
    232  227f				   .finishedDrawStack
    233  227f		       e6 8e		      inc	ScreenDrawPhase	;5 =  5
    234  2281		       ba		      tsx		;2
    235  2282		       86 89		      stx	DrawStackPointer	;3
    236  2284		       a6 df		      ldx	save_SP	;3
    237  2286		       9a		      txs		;2 = 10
    238  2287
    239  2287		       4c 06 f9 	      jmp	SwitchObjects
    240  228a
    241  228a							;rts				  ;6 =	6
    242  228a
    243  228a				   .exitDrawStack
    244  228a		       84 de		      sty	DSL	;3 =  3
    245  228c		       ba		      tsx		;2
    246  228d		       86 89		      stx	DrawStackPointer	;3
    247  228f		       a6 df		      ldx	save_SP	;3
    248  2291		       9a		      txs		;2 = 10
    249  2292		       60	   NoBlanks   rts		;6 =  6
    250  2293
    251  2293							;------------------------------------------------------------------------------
    252  2293
      0  2293					      DEFINE_SUBROUTINE	BlankCreatureInsertion	;=853(A)
      1  2293		       00 04	   BANK_BlankCreatureInsertion =	_CURRENT_BANK
      2  2293					      SUBROUTINE
      3  2293				   BlankCreatureInsertion
    254  2293
    255  2293		       a4 8d		      ldy	BlankStackPtr	;3
    256  2295		       88		      dey		;2
    257  2296
    258  2296							; Processes a blank stack object.
    259  2296
    260  2296		       b9 80 f0 	      lda	BlankStackY,y	;4
    261  2299		       85 90		      sta	POS_Y	;3
    262  229b		       b9 00 f0 	      lda	BlankStackX,y	;4
    263  229e		       85 8f		      sta	POS_X	;3
    264  22a0
    265  22a0							; We have the position of a blank square on the board that has been placed onto
    266  22a0							; the blank stack in the previous iteration.  IFF the square is still blank, then
    267  22a0							; we check the squares immediately above and to the sides and place those object(s)
    268  22a0							; into the object stack
    269  22a0
    270  22a0		       a9 00		      lda	#0	;2
    271  22a2		       85 94		      sta	POS_VAR	;3		 for object stack insertion
    272  22a4
    273  22a4							;  +---+---+---+
    274  22a4							;  | 1 | 2 | 3 |
    275  22a4							;  +---+---+---+
    276  22a4							;  | 0 | B | 4 |
    277  22a4							;  +---+---+---+
    278  22a4
    279  22a4							; Given a position 'B', checks the surrounding squares 0-4 for objects that could
    280  22a4							; possibly be caused to "fall" by the creation of a blank at 'B'.  These objects
    281  22a4							; are pushed onto the object stack to let them do their stuff.
    282  22a4
    283  22a4		       c6 8f		      dec	POS_X	;5
    284  22a6		       20 7f f8 	      jsr	GetBoardCharacter__CALL_FROM_RAM__	;6+61
    285  22a9		       20 c7 f2 	      jsr	CheckIt	;6+108(A)	 @ "0"
    286  22ac
    287  22ac		       e6 8f		      inc	POS_X	;5
    288  22ae		       e6 8f		      inc	POS_X	;5
    289  22b0		       20 c2 f2 	      jsr	CheckIt2	;6+141 	 # "4"
    290  22b3
    291  22b3		       c6 90		      dec	POS_Y	;5
    292  22b5		       20 7f f8 	      jsr	GetBoardCharacter__CALL_FROM_RAM__	;6+61
    293  22b8		       20 c7 f2 	      jsr	CheckIt	;6+110(A)	 @ "3"
    294  22bb
    295  22bb		       c6 8f		      dec	POS_X	;5
    296  22bd		       20 c2 f2 	      jsr	CheckIt2	;6+141 	 @ "2"
    297  22c0
    298  22c0		       c6 8f		      dec	POS_X	;5
    299  22c2
    300  22c2							; fall through (@ "1")
    301  22c2
    302  22c2				   CheckIt2		;=141
    303  22c2
    304  22c2		       a9 0d		      lda	#BANK_BOARD	;2			 Warning -- will not work for multiple bank board!
    305  22c4		       20 88 f8 	      jsr	PartialGetBoardCharacter	;6+23
    306  22c7
    307  22c7				   CheckIt		;=110(A)
    308  22c7
    309  22c7		       bd b1 fc 	      lda	GenericCharFlag,x	; 4	 check char as a fallable item
    310  22ca		       10 c6		      bpl	NoBlanks	; 2/3	 NOT a fallable object!
    311  22cc
    312  22cc							; Only FALLABLE objects detected in the candidate position are added to the object list.
    313  22cc							; These objects then make their own minds up if they're ACTUALLY going to fall.
    314  22cc
    315  22cc
    316  22cc		       bd ee fc 	      lda	CharToType,x	;4	 get type of object based on character
    317  22cf		       85 93		      sta	POS_Type	;3
    318  22d1
    319  22d1		       4c 19 fa 	      jmp	InsertObjectStackFromRAM	;3+94(B)
    320  22d4
    321  22d4							;------------------------------------------------------------------------------
    322  22d4							; Gives character replacements used during screen drawing.
    323  22d4							; The character from the board is morphed via this array into an actual character
    324  22d4							; to draw.  This allows global animation and replacment of characters without
    325  22d4							; individual objects needing to do this.  Note, the draw-time replacement happens,
    326  22d4							; not board-time.
    327  22d4
    328  22d4				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    329  22d4
    330  22d4							; Converts a character # to an animated creature type
    331  22d4							; The array is indexed by CHARACTER_...
    332  22d4
    333  22d4		       00		      .byte.b	CHARACTER_BLANK	;  0
    334  22d5		       01		      .byte.b	CHARACTER_SOIL	;  1
    335  22d6		       02		      .byte.b	CHARACTER_BOX	;  2
    336  22d7		       03	   ANIM_AMOEBA .byte.b	CHARACTER_AMOEBA	;  3
    337  22d8		       04	   ANIM_DIAMOND .byte.b	CHARACTER_DIAMOND	;  4
    338  22d9		       00		      .byte.b	0	;CHARACTER_DIAMOND   ;  5
    339  22da		       06		      .byte.b	CHARACTER_MANOCCUPIED	;  6
    340  22db		       07	   ANIM_BUTTERFLY0 .byte.b	CHARACTER_FLUTTERBY	;  7
    341  22dc		       07	   ANIM_BUTTERFLY1 .byte.b	CHARACTER_FLUTTERBY	;  8
    342  22dd		       09	   ANIM_FIREFLY0 .byte.b	CHARACTER_FIREFLY	;  9
    343  22de		       09	   ANIM_FIREFLY1 .byte.b	CHARACTER_FIREFLY	; 0a
    344  22df		       0b	   ANIM_MAGICWALL .byte.b	CHARACTER_WALL0	; 0b
    345  22e0		       00		      .byte.b	0	;CHARACTER_WALL0     ; 0c
    346  22e1		       00		      .byte.b	0	;CHARACTER_WALL0     ; 0d
    347  22e2		       00		      .byte.b	0	;CHARACTER_WALL0     ; 0e
    348  22e3		       0f		      .byte.b	CHARACTER_STEEL	; 0f
    349  22e4		       10		      .byte.b	CHARACTER_WALL	; 10
    350  22e5		       11	   ANIM_EXITDOOR .byte.b	CHARACTER_EXITDOOR	; 11
    351  22e6		       00		      .byte.b	0	;CHARACTER_EXITDOOR  ; 12
    352  22e7		       13		      .byte.b	CHARACTER_EXPLOSION	; 13
    353  22e8		       14		      .byte.b	CHARACTER_EXPLOSION1	; 14
    354  22e9		       15		      .byte.b	CHARACTER_EXPLOSION2	; 15
    355  22ea		       16		      .byte.b	CHARACTER_EXPLOSION3	; 16
    356  22eb		       00		      .byte.b	0	;CHARACTER_AMOEBA    ; 17
    357  22ec		       02		      .byte.b	CHARACTER_BOX	; 18	 falling BOX
    358  22ed		       04		      .byte.b	CHARACTER_DIAMOND	; 19	 falling diamond, no anim
    359  22ee		       1a		      .byte.b	CHARACTER_NOGO	;20 the unkillable man for end of level
    360  22ef
    361  22ef				  -	      IF	* - CharReplacement < CHARACTER_MAXIMUM
    362  22ef				  -	      ECHO	"ERROR: Missing entry in CharReplacement table!"
    363  22ef				  -	      EXIT
    364  22ef					      ENDIF
      0  22ef					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  22ef					      LIST	ON
    366  22ef
    367  22ef							;------------------------------------------------------------------------------
    368  22ef
    369  22ef				   PairedCharacter
    370  22ef
    371  22ef				   SOFF       SET	0
    372  22ef					      REPEAT	SCREEN_LINES
    373  22ef		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  22ef				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  22ef					      REPEND
    373  22f9		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  22f9				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  22f9					      REPEND
    373  2303		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  2303				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  2303					      REPEND
    373  230d		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  230d				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  230d					      REPEND
    373  2317		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  2317				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  2317					      REPEND
    373  2321		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  2321				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  2321					      REPEND
    373  232b		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  232b				   SOFF       SET	SOFF + SCREEN_WIDTH
    372  232b					      REPEND
    373  2335		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    374  2335				   SOFF       SET	SOFF + SCREEN_WIDTH
    375  233f					      REPEND
    376  233f
      0  233f					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
     10  233f					      LIST	ON
      0  233f					      DEFINE_SUBROUTINE	ROW_BankChar
      1  233f		       00 04	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  233f					      SUBROUTINE
      3  233f				   ROW_BankChar
    379  233f
    380  233f				   .BANK      SET	BANK_SCREENMARKII1
    381  233f					      REPEAT	SCREEN_LINES
    382  233f					      REPEAT	SCREEN_WIDTH
    383  233f		       00		      .byte.b	.BANK
    382  233f					      REPEND
    383  2340		       00		      .byte.b	.BANK
    382  2340					      REPEND
    383  2341		       00		      .byte.b	.BANK
    382  2341					      REPEND
    383  2342		       00		      .byte.b	.BANK
    382  2342					      REPEND
    383  2343		       00		      .byte.b	.BANK
    382  2343					      REPEND
    383  2344		       00		      .byte.b	.BANK
    382  2344					      REPEND
    383  2345		       00		      .byte.b	.BANK
    382  2345					      REPEND
    383  2346		       00		      .byte.b	.BANK
    382  2346					      REPEND
    383  2347		       00		      .byte.b	.BANK
    382  2347					      REPEND
    383  2348		       00		      .byte.b	.BANK
    384  2349					      REPEND
    385  2349				   .BANK      SET	.BANK + 1
    381  2349					      REPEND
    382  2349					      REPEAT	SCREEN_WIDTH
    383  2349		       01		      .byte.b	.BANK
    382  2349					      REPEND
    383  234a		       01		      .byte.b	.BANK
    382  234a					      REPEND
    383  234b		       01		      .byte.b	.BANK
    382  234b					      REPEND
    383  234c		       01		      .byte.b	.BANK
    382  234c					      REPEND
    383  234d		       01		      .byte.b	.BANK
    382  234d					      REPEND
    383  234e		       01		      .byte.b	.BANK
    382  234e					      REPEND
    383  234f		       01		      .byte.b	.BANK
    382  234f					      REPEND
    383  2350		       01		      .byte.b	.BANK
    382  2350					      REPEND
    383  2351		       01		      .byte.b	.BANK
    382  2351					      REPEND
    383  2352		       01		      .byte.b	.BANK
    384  2353					      REPEND
    385  2353				   .BANK      SET	.BANK + 1
    381  2353					      REPEND
    382  2353					      REPEAT	SCREEN_WIDTH
    383  2353		       02		      .byte.b	.BANK
    382  2353					      REPEND
    383  2354		       02		      .byte.b	.BANK
    382  2354					      REPEND
    383  2355		       02		      .byte.b	.BANK
    382  2355					      REPEND
    383  2356		       02		      .byte.b	.BANK
    382  2356					      REPEND
    383  2357		       02		      .byte.b	.BANK
    382  2357					      REPEND
    383  2358		       02		      .byte.b	.BANK
    382  2358					      REPEND
    383  2359		       02		      .byte.b	.BANK
    382  2359					      REPEND
    383  235a		       02		      .byte.b	.BANK
    382  235a					      REPEND
    383  235b		       02		      .byte.b	.BANK
    382  235b					      REPEND
    383  235c		       02		      .byte.b	.BANK
    384  235d					      REPEND
    385  235d				   .BANK      SET	.BANK + 1
    381  235d					      REPEND
    382  235d					      REPEAT	SCREEN_WIDTH
    383  235d		       03		      .byte.b	.BANK
    382  235d					      REPEND
    383  235e		       03		      .byte.b	.BANK
    382  235e					      REPEND
    383  235f		       03		      .byte.b	.BANK
    382  235f					      REPEND
    383  2360		       03		      .byte.b	.BANK
    382  2360					      REPEND
    383  2361		       03		      .byte.b	.BANK
    382  2361					      REPEND
    383  2362		       03		      .byte.b	.BANK
    382  2362					      REPEND
    383  2363		       03		      .byte.b	.BANK
    382  2363					      REPEND
    383  2364		       03		      .byte.b	.BANK
    382  2364					      REPEND
    383  2365		       03		      .byte.b	.BANK
    382  2365					      REPEND
    383  2366		       03		      .byte.b	.BANK
    384  2367					      REPEND
    385  2367				   .BANK      SET	.BANK + 1
    381  2367					      REPEND
    382  2367					      REPEAT	SCREEN_WIDTH
    383  2367		       04		      .byte.b	.BANK
    382  2367					      REPEND
    383  2368		       04		      .byte.b	.BANK
    382  2368					      REPEND
    383  2369		       04		      .byte.b	.BANK
    382  2369					      REPEND
    383  236a		       04		      .byte.b	.BANK
    382  236a					      REPEND
    383  236b		       04		      .byte.b	.BANK
    382  236b					      REPEND
    383  236c		       04		      .byte.b	.BANK
    382  236c					      REPEND
    383  236d		       04		      .byte.b	.BANK
    382  236d					      REPEND
    383  236e		       04		      .byte.b	.BANK
    382  236e					      REPEND
    383  236f		       04		      .byte.b	.BANK
    382  236f					      REPEND
    383  2370		       04		      .byte.b	.BANK
    384  2371					      REPEND
    385  2371				   .BANK      SET	.BANK + 1
    381  2371					      REPEND
    382  2371					      REPEAT	SCREEN_WIDTH
    383  2371		       05		      .byte.b	.BANK
    382  2371					      REPEND
    383  2372		       05		      .byte.b	.BANK
    382  2372					      REPEND
    383  2373		       05		      .byte.b	.BANK
    382  2373					      REPEND
    383  2374		       05		      .byte.b	.BANK
    382  2374					      REPEND
    383  2375		       05		      .byte.b	.BANK
    382  2375					      REPEND
    383  2376		       05		      .byte.b	.BANK
    382  2376					      REPEND
    383  2377		       05		      .byte.b	.BANK
    382  2377					      REPEND
    383  2378		       05		      .byte.b	.BANK
    382  2378					      REPEND
    383  2379		       05		      .byte.b	.BANK
    382  2379					      REPEND
    383  237a		       05		      .byte.b	.BANK
    384  237b					      REPEND
    385  237b				   .BANK      SET	.BANK + 1
    381  237b					      REPEND
    382  237b					      REPEAT	SCREEN_WIDTH
    383  237b		       06		      .byte.b	.BANK
    382  237b					      REPEND
    383  237c		       06		      .byte.b	.BANK
    382  237c					      REPEND
    383  237d		       06		      .byte.b	.BANK
    382  237d					      REPEND
    383  237e		       06		      .byte.b	.BANK
    382  237e					      REPEND
    383  237f		       06		      .byte.b	.BANK
    382  237f					      REPEND
    383  2380		       06		      .byte.b	.BANK
    382  2380					      REPEND
    383  2381		       06		      .byte.b	.BANK
    382  2381					      REPEND
    383  2382		       06		      .byte.b	.BANK
    382  2382					      REPEND
    383  2383		       06		      .byte.b	.BANK
    382  2383					      REPEND
    383  2384		       06		      .byte.b	.BANK
    384  2385					      REPEND
    385  2385				   .BANK      SET	.BANK + 1
    381  2385					      REPEND
    382  2385					      REPEAT	SCREEN_WIDTH
    383  2385		       07		      .byte.b	.BANK
    382  2385					      REPEND
    383  2386		       07		      .byte.b	.BANK
    382  2386					      REPEND
    383  2387		       07		      .byte.b	.BANK
    382  2387					      REPEND
    383  2388		       07		      .byte.b	.BANK
    382  2388					      REPEND
    383  2389		       07		      .byte.b	.BANK
    382  2389					      REPEND
    383  238a		       07		      .byte.b	.BANK
    382  238a					      REPEND
    383  238b		       07		      .byte.b	.BANK
    382  238b					      REPEND
    383  238c		       07		      .byte.b	.BANK
    382  238c					      REPEND
    383  238d		       07		      .byte.b	.BANK
    382  238d					      REPEND
    383  238e		       07		      .byte.b	.BANK
    384  238f					      REPEND
    385  238f				   .BANK      SET	.BANK + 1
    386  238f					      REPEND
    387  238f
    388  238f
    389  238f
    390  238f
      0  238f					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  238f
      2  238f
      3  238f		       03 8f	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $38f , FREE= $71
      4  238f					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  238f				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  238f				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  238f				  -	      ERR
      8  238f					      endif
    392  238f
    393  238f							; Here there is another 1K of usable ROM
    394  238f
      0  238f					      DEFINE_SUBROUTINE	MoveExit
      1  238f		       00 04	   BANK_MoveExit =	_CURRENT_BANK
      2  238f					      SUBROUTINE
      3  238f				   MoveExit
    396  238f
    397  238f		       24 c8		      bit	scoringFlags
    398  2391		       10 40		      bpl	NoExitYet	; D7 (extra diamond) triggers exit open
    399  2393
    400  2393		       a5 b2		      lda	caveDisplay
    401  2395		       10 1c		      bpl	lifeMaxedOut	; not a bonus level
    402  2397		       a5 ab		      lda	MenCurrent
    403  2399		       29 0f		      and	#$0f
    404  239b		       c9 09		      cmp	#9
    405  239d		       b0 14		      bcs	lifeMaxedOut
    406  239f		       e6 ab		      inc	MenCurrent
    407  23a1
    408  23a1							; bonus life has priority over score:
    409  23a1		       a5 c8		      lda	scoringFlags
    410  23a3		       29 03		      and	#DISPLAY_FLAGS
    411  23a5		       45 c8		      eor	scoringFlags	; remove existing score mode
    412  23a7		       09 02		      ora	#DISPLAY_LIVES	; switch to new score mode
    413  23a9		       85 c8		      sta	scoringFlags
    414  23ab		       a9 3c		      lda	#SCORING_TIMER
    415  23ad		       85 c7		      sta	scoringTimer
    416  23af		       a9 ff		      lda	#EXTRA_LIFE_TIMER
    417  23b1		       85 c6		      sta	extraLifeTimer
    418  23b3
    419  23b3				   lifeMaxedOut
    420  23b3
    421  23b3		       a9 08		      lda	#MANMODE_BONUS_START
    422  23b5		       85 a3		      sta	ManMode
    423  23b7
    424  23b7		       a9 04		      lda	#BANK_MoveExit
    425  23b9		       85 c3		      sta	ROM_Bank
    426  23bb
    427  23bb							;jsr MoveNoButton2		   ; move man over exit door area
    428  23bb
    429  23bb							; Stop the sort, so it doesn't accidentally swap "in" any creatures
    430  23bb
    431  23bb		       a9 ff		      lda	#<(-1)
    432  23bd		       85 d3		      sta	sortRequired
    433  23bf		       a9 00		      lda	#0
    434  23c1		       85 d4		      sta	sortPtr
    435  23c3		       85 8d		      sta	BlankStackPtr	; don't allow any new objects either!
    436  23c5
    437  23c5							; We want *everything* to stop, but the player to keep processing
    438  23c5							; So, kill every creature in the two object stacks, re-add the man (automatic), and continue
    439  23c5
    440  23c5		       a6 8a		      ldx	ObjStackNum
    441  23c7		       95 8b		      sta	ObjStackPtr,x	; =0, kill new object stack
    442  23c9		       8a		      txa
    443  23ca		       49 01		      eor	#1
    444  23cc		       aa		      tax
    445  23cd		       b5 8b		      lda	ObjStackPtr,x
    446  23cf		       85 dd		      sta	ObjIterator	; set the iterator to the END of the current object stack so it ends
    447  23d1
    448  23d1							; all creatures now dead and we'll only have the (reinserted) man left
    449  23d1
    450  23d1		       06 b4		      asl	ThrottleSpeed	; double game loop speed
    451  23d3
    452  23d3		       60	   NoExitYet  rts
    453  23d4
------- FILE CaveBank1.asm LEVEL 3 PASS 3
      0  23d4					      include	"CaveBank1.asm"
      1  23d4							; Cave definitions
      2  23d4
      3  23d4		       00 00	   .DIR_UP    =	0
      4  23d4		       00 02	   .DIR_RIGHT =	2
      5  23d4		       00 04	   .DIR_DOWN  =	4
      6  23d4		       00 06	   .DIR_LEFT  =	6
      7  23d4
      8  23d4
      9  23d4					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  23d4					      START_CAVE	TRACKS
      1  23d4				   CAVE_START SET	*
      2  23d4		       00 04	   BANK_CAVE_TRACKS =	_CURRENT_BANK
      3  23d4				   CAVE_TRACKS SUBROUTINE
      4  23d4				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  23d4
     11  23d4
     12  23d4		       0a		      .byte.b	$0A	; Cave 10 J
      0  23d5					      CAVE_SIZE_ROOM		; width, height
      0  23d5					      CAVE_SIZE	40, 22
      1  23d5		       28 16		      .byte.b	40,22
     14  23d7		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
     15  23d8		       25		      .byte.b	$25	;BCD'd $19				    ; Diamonds worth: 25 points
     16  23d9		       60		      .byte.b	$60	;BCD'd $3C				    ; Extra diamonds worth: 60 points
     17  23da		       00 00 00 00*	      .byte.b	$00, $00, $00, $00, $00	; Randomiser seed values for difficulty levels 1-5
     18  23df				  -	      IF	TEST_BONUS_COUNTDOWN = YES
     19  23df				  -	      .byte	$01, $01, $01, $01, $01
     20  23df					      ELSE
     21  23df		       0c 0c 0c 0c*	      .byte.b	$0C, $0C, $0C, $0C, $0C	; Diamonds needed: 12, 12, 12, 12, 12 (for difficulty levels 1-5)
     22  23e4					      ENDIF
     23  23e4
     24  23e4
     25  23e4		       96 82 78 6e*	      .byte.b	$96, $82, $78, $6E, $64	; Cave time: 150, 130, 120, 110, 100 seconds
     26  23e9
     27  23e9
     28  23e9							;-------------------------------------------------------------------------------------
     29  23e9							; PALETTE DEFINITIONS
     30  23e9
     31  23e9				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
     32  23e9				  -	      .byte	$26, $26
     33  23e9				  -	      .byte	$76, $c4
     34  23e9				  -	      .byte	$be, $7e
     35  23e9					      ELSE
     36  23e9
     37  23e9							; COMMENT FOLLOWING OUT IF NOT WANTED!
     38  23e9							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
     39  23e9					      IF	AD_MODE
     40  23e9		       26 26		      .byte.b	$26, $26
     41  23eb		       76 c4		      .byte.b	$76, $c4
     42  23ed		       be 7e		      .byte.b	$be, $7e
     43  23ef					      ENDIF
     44  23ef
     45  23ef							; COMMENT FOLLOWING OUT IF NOT WANTED!
     46  23ef							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
     47  23ef				  -	      IF	TJ_MODE
     48  23ef				  -	      .byte	$26, $26
     49  23ef				  -	      .byte	$76, $c4
     50  23ef				  -	      .byte	$be, $7e
     51  23ef					      ENDIF
     52  23ef
     53  23ef					      ENDIF
     54  23ef
     55  23ef							;-------------------------------------------------------------------------------------
     56  23ef
     57  23ef
     58  23ef		       00 00 00 00	      .byte.b	$00, $00, $00, $00	; Random objects:
     59  23f3		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
     60  23f7							;   second code unused (0%)
     61  23f7							;   third code unused (0%)
     62  23f7							;   fourth code unused (0%)
     63  23f7		       06 0d 03 	      .byte.b	CHARACTER_MANOCCUPIED, $0D, $03	; StoreChar zPRFd1 at (13, 3)
     64  23fa
     65  23fa				  -	      IF	TEST_BONUS_COUNTDOWN = YES
     66  23fa				  -	      .byte	CHARACTER_EXITDOOR, $19, 3	; StoreChar zPreOut at (39,22)
     67  23fa					      ELSE
     68  23fa		       11 27 16 	      .byte.b	CHARACTER_EXITDOOR, $27, $16	; StoreChar zPreOut at (39,22)
     69  23fd					      ENDIF
     70  23fd
     71  23fd
     72  23fd
     73  23fd		       44 05 04 11*	      .byte.b	LINE+CHARACTER_DIAMOND, $05, $04, $11, $03	; Line of zDiaS from ( 5, 4); length = 17; direction = down/right
     74  2402		       44 15 04 11*	      .byte.b	LINE+CHARACTER_DIAMOND, $15, $04, $11, $05	; Line of zDiaS from (21, 4); length = 17; direction = down/left
     75  2407		       80 05 0b 11*	      .byte.b	FILL+CHARACTER_BLANK, $05, $0B, $11, $03, CHARACTER_FIREFLY	; FilledRect of zSpace from ( 5,11); length = 17; height = 3; fill = zFFly1
     76  240d		       d0 01 04 15*	      .byte.b	RECT+CHARACTER_WALL, $01, $04, $15, $11	; Rect of zBrick from ( 1, 4); length = 21; height = 17
     77  2412		       00 0d 04 	      .byte.b	CHARACTER_BLANK, $0D, $04	; StoreChar zSpace at (13, 4)
     78  2415		       d0 07 06 0d*	      .byte.b	RECT+CHARACTER_WALL, $07, $06, $0D, $0D	; Rect of zBrick from ( 7, 6); length = 13; height = 13
     79  241a		       00 0d 06 	      .byte.b	CHARACTER_BLANK, $0D, $06	; StoreChar zSpace at (13, 6)
     80  241d		       d0 09 08 09*	      .byte.b	RECT+CHARACTER_WALL, $09, $08, $09, $09	; Rect of zBrick from ( 9, 8); length = 9; height = 9
     81  2422		       00 0d 08 	      .byte.b	CHARACTER_BLANK, $0D, $08	; StoreChar zSpace at (13, 8)
     82  2425		       d0 0b 0a 05*	      .byte.b	RECT+CHARACTER_WALL, $0B, $0A, $05, $05	; Rect of zBrick from (11,10); length = 5; height = 5
     83  242a		       00 0d 0a 	      .byte.b	CHARACTER_BLANK, $0D, $0A	; StoreChar zSpace at (13,10)
     84  242d		       90 03 06 03*	      .byte.b	FILL+CHARACTER_WALL, $03, $06, $03, $0F, CHARACTER_FIREFLY	; FilledRect of zBrick from ( 3, 6); length = 3; height = 15; fill = zFFly1
     85  2433		       00 04 06 	      .byte.b	CHARACTER_BLANK, $04, $06	; StoreChar zSpace at ( 4, 6)
     86  2436		       44 04 10 04*	      .byte.b	LINE+CHARACTER_DIAMOND, $04, $10, $04, $04	; Line of zDiaS from ( 4,16); length = 4; direction = down
     87  243b
      0  243b					      END_CAVE	TRACKS
      1  243b		       ff		      .byte.b	$FF
      2  243b		       00 68	   CAVE_SIZE_TRACKS =	* - CAVE_START
      3  243c				  -	      IF	CAVE_SIZE_TRACKS > MAX_CAVE_SIZE
      4  243c				  -MAX_CAVE_SIZE SET	CAVE_SIZE_TRACKS
      5  243c					      ENDIF
     89  243c					      ENDIF
     90  243c
     91  243c							;------------------------------------------------------------------------------
     92  243c
     93  243c					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  243c					      START_CAVE	CROWD
      1  243c				   CAVE_START SET	*
      2  243c		       00 04	   BANK_CAVE_CROWD =	_CURRENT_BANK
      3  243c				   CAVE_CROWD SUBROUTINE
      4  243c				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  243c
     95  243c
     96  243c		       0b		      .byte.b	$0B	; Cave 11 K
      0  243d					      CAVE_SIZE_ROOM		; width, height
      0  243d					      CAVE_SIZE	40, 22
      1  243d		       28 16		      .byte.b	40,22
     98  243f		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
     99  2440		       50		      .byte.b	$50	;BCD'd $32				    ; Diamonds worth: 50 points
    100  2441		       00		      .byte.b	$00	; Extra diamonds worth: 0 points
    101  2442		       00 04 66 97*	      .byte.b	$00, $04, $66, $97, $64	; Randomiser seed values for difficulty levels 1-5
    102  2447		       06 06 06 06*	      .byte.b	$06, $06, $06, $06, $06	; Diamonds needed: 6, 6, 6, 6, 6 (for difficulty levels 1-5)
    103  244c		       78 78 96 96*	      .byte.b	$78, $78, $96, $96, $F0	; Cave time: 120, 120, 150, 150, 240 seconds
    104  2451
    105  2451
    106  2451							;-------------------------------------------------------------------------------------
    107  2451							; PALETTE DEFINITIONS
    108  2451
    109  2451				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    110  2451				  -	      .byte	$26, $48
    111  2451				  -	      .byte	$04, $16
    112  2451				  -	      .byte	$9e, $be
    113  2451					      ELSE
    114  2451
    115  2451							; COMMENT FOLLOWING OUT IF NOT WANTED!
    116  2451							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    117  2451					      IF	AD_MODE
    118  2451		       26 48		      .byte.b	$26, $48
    119  2453		       04 16		      .byte.b	$04, $16
    120  2455		       9e be		      .byte.b	$9e, $be
    121  2457					      ENDIF
    122  2457
    123  2457							; COMMENT FOLLOWING OUT IF NOT WANTED!
    124  2457							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    125  2457				  -	      IF	TJ_MODE
    126  2457				  -	      .byte	$26, $48
    127  2457				  -	      .byte	$04, $16
    128  2457				  -	      .byte	$9e, $be
    129  2457					      ENDIF
    130  2457
    131  2457					      ENDIF
    132  2457
    133  2457							;-------------------------------------------------------------------------------------
    134  2457
    135  2457
    136  2457
    137  2457		       00		      .byte.b	CHARACTER_BLANK	; Random objects:
    138  2458		       02		      .byte.b	CHARACTER_BOX
    139  2459		       09		      .byte.b	CHARACTER_FIREFLY
    140  245a		       00		      .byte.b	CHARACTER_BLANK
    141  245b		       64 50 02 00	      .byte.b	$64, $50, $02, $00	;   zSpace : 100/256 = 39%
    142  245f							;   zBouS  :  80/256 = 31%
    143  245f							;   zFFly1 :	2/256 =  0%
    144  245f							;   fourth code unused (0%)
    145  245f		       50 0a 03 09*	      .byte.b	LINE+CHARACTER_WALL, $0A, $03, $09, $04	; Line of zBrick from (10, 3); length = 9; direction = down
    146  2464		       50 14 03 09*	      .byte.b	LINE+CHARACTER_WALL, $14, $03, $09, $04	; Line of zBrick from (20, 3); length = 9; direction = down
    147  2469		       50 1e 03 09*	      .byte.b	LINE+CHARACTER_WALL, $1E, $03, $09, $04	; Line of zBrick from (30, 3); length = 9; direction = down
    148  246e		       50 09 16 09*	      .byte.b	LINE+CHARACTER_WALL, $09, $16, $09, $00	; Line of zBrick from ( 9,22); length = 9; direction = up
    149  2473		       50 0c 0f 11*	      .byte.b	LINE+CHARACTER_WALL, $0C, $0F, $11, $02	; Line of zBrick from (12,15); length = 17; direction = right
    150  2478		       50 05 0b 09*	      .byte.b	LINE+CHARACTER_WALL, $05, $0B, $09, $02	; Line of zBrick from ( 5,11); length = 9; direction = right
    151  247d		       50 0f 0b 09*	      .byte.b	LINE+CHARACTER_WALL, $0F, $0B, $09, $02	; Line of zBrick from (15,11); length = 9; direction = right
    152  2482		       50 19 0b 09*	      .byte.b	LINE+CHARACTER_WALL, $19, $0B, $09, $02	; Line of zBrick from (25,11); length = 9; direction = right
    153  2487		       50 1c 13 0b*	      .byte.b	LINE+CHARACTER_WALL, $1C, $13, $0B, $01	; Line of zBrick from (28,19); length = 11; direction = up/right
    154  248c		       04 04 03 	      .byte.b	CHARACTER_DIAMOND, $04, $03	; StoreChar zDiaS at ( 4, 3)
    155  248f		       04 0e 03 	      .byte.b	CHARACTER_DIAMOND, $0E, $03	; StoreChar zDiaS at (14, 3)
    156  2492		       04 18 03 	      .byte.b	CHARACTER_DIAMOND, $18, $03	; StoreChar zDiaS at (24, 3)
    157  2495		       04 22 03 	      .byte.b	CHARACTER_DIAMOND, $22, $03	; StoreChar zDiaS at (34, 3)
    158  2498		       04 04 16 	      .byte.b	CHARACTER_DIAMOND, $04, $16	; StoreChar zDiaS at ( 4,22)
    159  249b		       04 23 15 	      .byte.b	CHARACTER_DIAMOND, $23, $15	; StoreChar zDiaS at (35,21)
    160  249e		       06 14 14 	      .byte.b	CHARACTER_MANOCCUPIED, $14, $14	; StoreChar zPRFd1 at (20,20)
    161  24a1		       11 26 11 	      .byte.b	CHARACTER_EXITDOOR, $26, $11	; StoreChar zPreOut at (38,17)
    162  24a4
      0  24a4					      END_CAVE	CROWD
      1  24a4		       ff		      .byte.b	$FF
      2  24a4		       00 69	   CAVE_SIZE_CROWD =	* - CAVE_START
      3  24a5				  -	      IF	CAVE_SIZE_CROWD > MAX_CAVE_SIZE
      4  24a5				  -MAX_CAVE_SIZE SET	CAVE_SIZE_CROWD
      5  24a5					      ENDIF
    164  24a5					      ENDIF
    165  24a5							;------------------------------------------------------------------------------
    166  24a5
    167  24a5					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  24a5					      START_CAVE	WALLS
      1  24a5				   CAVE_START SET	*
      2  24a5		       00 04	   BANK_CAVE_WALLS =	_CURRENT_BANK
      3  24a5				   CAVE_WALLS SUBROUTINE
      4  24a5				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  24a5
    169  24a5
    170  24a5		       0c		      .byte.b	$0C	; Cave 12 L
      0  24a6					      CAVE_SIZE_ROOM		; width, height
      0  24a6					      CAVE_SIZE	40, 22
      1  24a6		       28 16		      .byte.b	40,22
    172  24a8		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    173  24a9		       20		      .byte.b	$20	;BCD'd $14				    ; Diamonds worth: 20 points
    174  24aa		       00		      .byte.b	$00	; Extra diamonds worth: 0 points
    175  24ab		       00 3c 02 3b*	      .byte.b	$00, $3C, $02, $3B, $66	; Randomiser seed values for difficulty levels 1-5
    176  24b0		       13 13 0e 10*	      .byte.b	$13, $13, $0E, $10, $15	; Diamonds needed: 19, 19, 14, 16, 21 (for difficulty levels 1-5)
    177  24b5		       b4 aa a0 a0*	      .byte.b	$B4, $AA, $A0, $A0, $A0	; Cave time: 180, 170, 160, 160, 160 seconds
    178  24ba
    179  24ba							;-------------------------------------------------------------------------------------
    180  24ba							; PALETTE DEFINITIONS
    181  24ba
    182  24ba				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    183  24ba				  -	      .byte	$46, $66
    184  24ba				  -	      .byte	$06, $18
    185  24ba				  -	      .byte	$ae, $7e
    186  24ba					      ELSE
    187  24ba
    188  24ba							; COMMENT FOLLOWING OUT IF NOT WANTED!
    189  24ba							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    190  24ba					      IF	AD_MODE
    191  24ba		       46 66		      .byte.b	$46, $66
    192  24bc		       06 18		      .byte.b	$06, $18
    193  24be		       ae 7e		      .byte.b	$ae, $7e
    194  24c0					      ENDIF
    195  24c0
    196  24c0							; COMMENT FOLLOWING OUT IF NOT WANTED!
    197  24c0							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    198  24c0				  -	      IF	TJ_MODE
    199  24c0				  -	      .byte	$46, $66
    200  24c0				  -	      .byte	$06, $18
    201  24c0				  -	      .byte	$ae, $7e
    202  24c0					      ENDIF
    203  24c0
    204  24c0					      ENDIF
    205  24c0
    206  24c0							;-------------------------------------------------------------------------------------
    207  24c0
    208  24c0
    209  24c0		       00 02 04 00	      .byte.b	$00, CHARACTER_BOX, CHARACTER_DIAMOND, $00	; Random objects:
    210  24c4		       3c 32 09 00	      .byte.b	$3C, $32, $09, $00	;   zSpace :  60/256 = 23%
    211  24c8							;   zBouS  :  50/256 = 19%
    212  24c8							;   zDiaS  :	9/256 =  3%
    213  24c8							;   fourth code unused (0%)
    214  24c8
    215  24c8		       50 0a 05 12*	      .byte.b	LINE+CHARACTER_WALL, $0A, $05, $12, $04	; Line of zBrick from (10, 5); length = 18; direction = down
    216  24cd		       50 0e 05 12*	      .byte.b	LINE+CHARACTER_WALL, $0E, $05, $12, $04	; Line of zBrick from (14, 5); length = 18; direction = down
    217  24d2		       50 12 05 12*	      .byte.b	LINE+CHARACTER_WALL, $12, $05, $12, $04	; Line of zBrick from (18, 5); length = 18; direction = down
    218  24d7		       50 16 05 12*	      .byte.b	LINE+CHARACTER_WALL, $16, $05, $12, $04	; Line of zBrick from (22, 5); length = 18; direction = down
    219  24dc		       50 02 06 0b*	      .byte.b	LINE+CHARACTER_WALL, $02, $06, $0B, $02	; Line of zBrick from ( 2, 6); length = 11; direction = right
    220  24e1		       50 02 0a 0b*	      .byte.b	LINE+CHARACTER_WALL, $02, $0A, $0B, $02	; Line of zBrick from ( 2,10); length = 11; direction = right
    221  24e6		       50 02 0e 0f*	      .byte.b	LINE+CHARACTER_WALL, $02, $0E, $0F, $02	; Line of zBrick from ( 2,14); length = 15; direction = right
    222  24eb		       50 02 12 0b*	      .byte.b	LINE+CHARACTER_WALL, $02, $12, $0B, $02	; Line of zBrick from ( 2,18); length = 11; direction = right
    223  24f0		       81 1e 04 04*	      .byte.b	FILL+CHARACTER_SOIL, $1E, $04, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (30, 4); length = 4; height = 4; fill = zSpace
    224  24f6		       09 20 05 	      .byte.b	CHARACTER_FIREFLY, $20, $05	; StoreChar zFFly1 at (32, 5)
    225  24f9		       81 1e 09 04*	      .byte.b	FILL+CHARACTER_SOIL, $1E, $09, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (30, 9); length = 4; height = 4; fill = zSpace
    226  24ff		       09 20 0a 	      .byte.b	CHARACTER_FIREFLY, $20, $0A	; StoreChar zFFly1 at (32,10)
    227  2502		       81 1e 0e 04*	      .byte.b	FILL+CHARACTER_SOIL, $1E, $0E, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (30,14); length = 4; height = 4; fill = zSpace
    228  2508		       09 20 0f 	      .byte.b	CHARACTER_FIREFLY, $20, $0F	; StoreChar zFFly1 at (32,15)
    229  250b		       06 03 14 	      .byte.b	CHARACTER_MANOCCUPIED, $03, $14	; StoreChar zPRFd1 at ( 3,20)
    230  250e		       11 27 16 	      .byte.b	CHARACTER_EXITDOOR, $27, $16	; StoreChar zPreOut at (39,22)
    231  2511
      0  2511					      END_CAVE	WALLS
      1  2511		       ff		      .byte.b	$FF
      2  2511		       00 6d	   CAVE_SIZE_WALLS =	* - CAVE_START
      3  2512				  -	      IF	CAVE_SIZE_WALLS > MAX_CAVE_SIZE
      4  2512				  -MAX_CAVE_SIZE SET	CAVE_SIZE_WALLS
      5  2512					      ENDIF
    233  2512					      ENDIF
    234  2512
    235  2512							;------------------------------------------------------------------------------
    236  2512
    237  2512							;IFCONST CAVE_NAMED_APOCALYPSE
      0  2512					      START_CAVE	APOCALYPSE
      1  2512				   CAVE_START SET	*
      2  2512		       00 04	   BANK_CAVE_APOCALYPSE =	_CURRENT_BANK
      3  2512				   CAVE_APOCALYPSE SUBROUTINE
      4  2512				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2512
    239  2512
    240  2512		       0d		      .byte.b	$0D	; Cave 13 M
      0  2513					      CAVE_SIZE_ROOM		; width, height
      0  2513					      CAVE_SIZE	40, 22
      1  2513		       28 16		      .byte.b	40,22
    242  2515		       8c		      .byte.b	$8C	; Magic wall/amoeba slow growth for: 140 seconds
    243  2516		       05		      .byte.b	$05	; Diamonds worth: 5 points
    244  2517		       08		      .byte.b	$08	; Extra diamonds worth: 8 points
    245  2518		       00 01 02 03*	      .byte.b	$00, $01, $02, $03, $04	; Randomiser seed values for difficulty levels 1-5
    246  251d		       32 37 3c 46*	      .byte.b	$32, $37, $3C, $46, $50	; Diamonds needed: 50, 55, 60, 70, 80 (for difficulty levels 1-5)
    247  2522							;   .byte 30,35,40,45,50    ; modified goal due to fewer butterflies; TJ: reverted, now that we can have all 30
    248  2522
    249  2522		       a0 9b 96 91*	      .byte.b	$A0, $9B, $96, $91, $8C	; Cave time: 160, 155, 150, 145, 140 seconds
    250  2527
    251  2527
    252  2527							;-------------------------------------------------------------------------------------
    253  2527							; PALETTE DEFINITIONS
    254  2527
    255  2527				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    256  2527				  -	      .byte	$88, $c8
    257  2527				  -	      .byte	$24, $24
    258  2527				  -	      .byte	$cc, $7a
    259  2527					      ELSE
    260  2527
    261  2527							; COMMENT FOLLOWING OUT IF NOT WANTED!
    262  2527							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    263  2527					      IF	AD_MODE
    264  2527		       88 c8		      .byte.b	$88, $c8
    265  2529		       24 24		      .byte.b	$24, $24
    266  252b		       cc 7a		      .byte.b	$cc, $7a
    267  252d					      ENDIF
    268  252d
    269  252d							; COMMENT FOLLOWING OUT IF NOT WANTED!
    270  252d							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    271  252d				  -	      IF	TJ_MODE
    272  252d				  -	      .byte	$88, $c8
    273  252d				  -	      .byte	$24, $24
    274  252d				  -	      .byte	$cc, $7a
    275  252d					      ENDIF
    276  252d
    277  252d					      ENDIF
    278  252d
    279  252d							;-------------------------------------------------------------------------------------
    280  252d
    281  252d
    282  252d
    283  252d		       02 00 00 00	      .byte.b	CHARACTER_BOX, $00, $00, $00	; Random objects:
    284  2531		       28 00 00 00	      .byte.b	$28, $00, $00, $00	;   zBouS  :  40/256 = 15%
    285  2535							;   second code unused (0%)
    286  2535							;   third code unused (0%)
    287  2535							;   fourth code unused (0%)
    288  2535
    289  2535		       06 12 03 	      .byte.b	CHARACTER_MANOCCUPIED, $12, $03	; StoreChar zPRFd1 at (18, 3)
    290  2538		       11 0a 03 	      .byte.b	CHARACTER_EXITDOOR, $0A, $03	; StoreChar zPreOut at (10, 3)
    291  253b		       03 14 03 	      .byte.b	CHARACTER_AMOEBA, $14, $03	; StoreChar zAmoe at (20, 3)
    292  253e
    293  253e							;-----
    294  253e							; Modified version with fewer butterflies to allow apocalpyse to be playable for the demo
    295  253e							; Basically reduced the butterfly count significantly
    296  253e							;.byte   $70, $05, $13, $1E, $02	     ; Line of zBFly1 from ( 5,19); length = 30; direction = right
    297  253e
    298  253e
    299  253e		       50 05 12 1e*	      .byte.b	LINE+CHARACTER_WALL, $05, $12, $1E, $02	; Line of zBrick from ( 5,18); length = 30; direction = right
    300  2543		       47 05 13 1e*	      .byte.b	LINE+CHARACTER_FLUTTERBY, $05, $13, $1E, $02	; Line of zBFly1 from ( 5,19); length = 30; direction = right
    301  2548		       42 05 14 1e*	      .byte.b	LINE+CHARACTER_BOX, $05, $14, $1E, $02	; Line of zBouS from ( 5,20); length = 30; direction = right
    302  254d		       c1 05 15 1e*	      .byte.b	RECT+CHARACTER_SOIL, $05, $15, $1E, $02	; Rect of zDirt from ( 5,21); length = 30; height = 2
    303  2552
      0  2552					      END_CAVE	APOCALYPSE
      1  2552		       ff		      .byte.b	$FF
      2  2552		       00 41	   CAVE_SIZE_APOCALYPSE =	* - CAVE_START
      3  2553				  -	      IF	CAVE_SIZE_APOCALYPSE > MAX_CAVE_SIZE
      4  2553				  -MAX_CAVE_SIZE SET	CAVE_SIZE_APOCALYPSE
      5  2553					      ENDIF
    305  2553							;ENDIF
    306  2553
    307  2553							;------------------------------------------------------------------------------
    308  2553
    309  2553					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2553					      START_CAVE	ZIGZAG
      1  2553				   CAVE_START SET	*
      2  2553		       00 04	   BANK_CAVE_ZIGZAG =	_CURRENT_BANK
      3  2553				   CAVE_ZIGZAG SUBROUTINE
      4  2553				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2553
    311  2553
    312  2553		       0e		      .byte.b	$0E	; Cave 14 N
      0  2554					      CAVE_SIZE_ROOM		; width, height
      0  2554					      CAVE_SIZE	40, 22
      1  2554		       28 16		      .byte.b	40,22
    314  2556		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    315  2557		       10		      .byte.b	$10	;BCD'd $0A				    ; Diamonds worth: 10 points
    316  2558		       20		      .byte.b	$20	;BCD'd $14				    ; Extra diamonds worth: 20 points
    317  2559		       00 00 00 00*	      .byte.b	$00, $00, $00, $00, $00	; Randomiser seed values for difficulty levels 1-5
    318  255e		       1e 23 28 2a*	      .byte.b	$1E, $23, $28, $2A, $2D	; Diamonds needed: 30, 35, 40, 42, 45 (for difficulty levels 1-5)
    319  2563		       96 91 8c 87*	      .byte.b	$96, $91, $8C, $87, $82	; Cave time: 150, 145, 140, 135, 130 seconds
    320  2568
    321  2568
    322  2568							;-------------------------------------------------------------------------------------
    323  2568							; PALETTE DEFINITIONS
    324  2568
    325  2568				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    326  2568				  -	      .byte	$2A, $2A
    327  2568				  -	      .byte	$66, $a4
    328  2568				  -	      .byte	$ce, $5e
    329  2568					      ELSE
    330  2568
    331  2568							; COMMENT FOLLOWING OUT IF NOT WANTED!
    332  2568							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    333  2568					      IF	AD_MODE
    334  2568		       2a 2a		      .byte.b	$2A, $2A
    335  256a		       66 a4		      .byte.b	$66, $a4
    336  256c		       ce 5e		      .byte.b	$ce, $5e
    337  256e					      ENDIF
    338  256e
    339  256e							; COMMENT FOLLOWING OUT IF NOT WANTED!
    340  256e							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    341  256e				  -	      IF	TJ_MODE
    342  256e				  -	      .byte	$26, $46
    343  256e				  -	      .byte	$04, $06
    344  256e				  -	      .byte	$9e, $be
    345  256e					      ENDIF
    346  256e
    347  256e					      ENDIF
    348  256e
    349  256e							;-------------------------------------------------------------------------------------
    350  256e
    351  256e
    352  256e		       02 00 00 00	      .byte.b	CHARACTER_BOX, $00, $00, $00	; Random objects:
    353  2572		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
    354  2576							;   second code unused (0%) ???
    355  2576							;   third code unused (0%) ???
    356  2576							;   fourth code unused (0%) ???
    357  2576
    358  2576		       81 0a 0a 0d*	      .byte.b	FILL+CHARACTER_SOIL, $0A, $0A, $0D, $0D, CHARACTER_BLANK	; FilledRect of zDirt from (10,10); length = 13; height = 13; fill = zSpace
    359  257c		       47 0b 0b 0c*	      .byte.b	LINE+CHARACTER_FLUTTERBY, $0B, $0B, $0C, $03	; Line of zBFly1 from (11,11); length = 12; direction = down/right
    360  2581		       c1 0c 0a 03*	      .byte.b	RECT+CHARACTER_SOIL, $0C, $0A, $03, $0D	; Rect of zDirt from (12,10); length = 3; height = 13
    361  2586		       c1 10 0a 03*	      .byte.b	RECT+CHARACTER_SOIL, $10, $0A, $03, $0D	; Rect of zDirt from (16,10); length = 3; height = 13
    362  258b		       c1 14 0a 03*	      .byte.b	RECT+CHARACTER_SOIL, $14, $0A, $03, $0D	; Rect of zDirt from (20,10); length = 3; height = 13
    363  2590		       42 16 08 0c*	      .byte.b	LINE+CHARACTER_BOX, $16, $08, $0C, $02	; Line of zBouS from (22, 8); length = 12; direction = right
    364  2595		       49 16 07 0c*	      .byte.b	LINE+CHARACTER_FIREFLY, $16, $07, $0C, $02	; Line of zFFly1 from (22, 7); length = 12; direction = right
    365  259a		       c1 17 06 03*	      .byte.b	RECT+CHARACTER_SOIL, $17, $06, $03, $04	; Rect of zDirt from (23, 6); length = 3; height = 4
    366  259f		       c1 1b 06 03*	      .byte.b	RECT+CHARACTER_SOIL, $1B, $06, $03, $04	; Rect of zDirt from (27, 6); length = 3; height = 4
    367  25a4		       c1 1f 06 03*	      .byte.b	RECT+CHARACTER_SOIL, $1F, $06, $03, $04	; Rect of zDirt from (31, 6); length = 3; height = 4
    368  25a9		       06 03 03 	      .byte.b	CHARACTER_MANOCCUPIED, $03, $03	; StoreChar zPRFd1 at ( 3, 3)
    369  25ac		       11 27 14 	      .byte.b	CHARACTER_EXITDOOR, $27, $14	; StoreChar zPreOut at (39,20)
    370  25af
    371  25af							;    .byte   LINE+CHARACTER_WALL, $01, $09, $1E, $02	 ; Line of zBrick from ( 1, 9); length = 30; direction = right
    372  25af
      0  25af					      END_CAVE	ZIGZAG
      1  25af		       ff		      .byte.b	$FF
      2  25af		       00 5d	   CAVE_SIZE_ZIGZAG =	* - CAVE_START
      3  25b0				  -	      IF	CAVE_SIZE_ZIGZAG > MAX_CAVE_SIZE
      4  25b0				  -MAX_CAVE_SIZE SET	CAVE_SIZE_ZIGZAG
      5  25b0					      ENDIF
    374  25b0					      ENDIF
    375  25b0
    376  25b0							;------------------------------------------------------------------------------
    377  25b0
    378  25b0					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  25b0					      START_CAVE	ENCHANTED_BOXES
      1  25b0				   CAVE_START SET	*
      2  25b0		       00 04	   BANK_CAVE_ENCHANTED_BOXES =	_CURRENT_BANK
      3  25b0				   CAVE_ENCHANTED_BOXES SUBROUTINE
      4  25b0				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  25b0
    380  25b0
    381  25b0		       10		      .byte.b	$10	; Cave 16 P
      0  25b1					      CAVE_SIZE_ROOM		; width, height
      0  25b1					      CAVE_SIZE	40, 22
      1  25b1		       28 16		      .byte.b	40,22
    383  25b3		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    384  25b4		       10		      .byte.b	$10	;BCD'd $0A				    ; Diamonds worth: 10 points
    385  25b5		       20		      .byte.b	$20	;BCD'd $14				    ; Extra diamonds worth: 20 points
    386  25b6		       01 78 81 7e*	      .byte.b	$01, $78, $81, $7E, $7B	; Randomiser seed values for difficulty levels 1-5
    387  25bb		       0c 0f 0f 0f*	      .byte.b	$0C, $0F, $0F, $0F, $0C	; Diamonds needed: 12, 15, 15, 15, 12 (for difficulty levels 1-5)
    388  25c0		       96 96 96 96*	      .byte.b	$96, $96, $96, $96, $96	; Cave time: 150, 150, 150, 150, 150 seconds
    389  25c5
    390  25c5							;-------------------------------------------------------------------------------------
    391  25c5							; PALETTE DEFINITIONS
    392  25c5
    393  25c5				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    394  25c5				  -	      .byte	$58, $68
    395  25c5				  -	      .byte	$24, $44
    396  25c5				  -	      .byte	$be, $9e
    397  25c5					      ELSE
    398  25c5
    399  25c5							; COMMENT FOLLOWING OUT IF NOT WANTED!
    400  25c5							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    401  25c5					      IF	AD_MODE
    402  25c5		       58 68		      .byte.b	$58, $68
    403  25c7		       24 44		      .byte.b	$24, $44
    404  25c9		       be 9e		      .byte.b	$be, $9e
    405  25cb					      ENDIF
    406  25cb
    407  25cb							; COMMENT FOLLOWING OUT IF NOT WANTED!
    408  25cb							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    409  25cb				  -	      IF	TJ_MODE
    410  25cb				  -	      .byte	$58, $68
    411  25cb				  -	      .byte	$24, $44
    412  25cb				  -	      .byte	$be, $9e
    413  25cb					      ENDIF
    414  25cb
    415  25cb					      ENDIF
    416  25cb
    417  25cb							;-------------------------------------------------------------------------------------
    418  25cb
    419  25cb		       02 00 00 00	      .byte.b	CHARACTER_BOX, $00, $00, $00	; Random objects:
    420  25cf		       32 00 00 00	      .byte.b	$32, $00, $00, $00	;   zBouS  :  50/256 = 19%
    421  25d3							;   second code unused (0%)
    422  25d3							;   third code unused (0%)
    423  25d3							;   fourth code unused (0%)
    424  25d3		       06 01 03 	      .byte.b	CHARACTER_MANOCCUPIED, $01, $03	; StoreChar zPRFd1 at ( 1, 3)
    425  25d6		       11 27 04 	      .byte.b	CHARACTER_EXITDOOR, $27, $04	; StoreChar zPreOut at (39, 4)
    426  25d9		       81 08 13 04*	      .byte.b	FILL+CHARACTER_SOIL, $08, $13, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from ( 8,19); length = 4; height = 4; fill = zSpace
    427  25df		       09 0a 14 	      .byte.b	CHARACTER_FIREFLY, $0A, $14	; StoreChar zFFly1 at (10,20)
    428  25e2				  -	      IF	SHOWDIAMONDP
    429  25e2				  -	      .byte	CHARACTER_DIAMOND, $08, $8	; StoreChar zFFly1 at (10,20)
    430  25e2					      ENDIF
    431  25e2		       d0 07 0a 06*	      .byte.b	RECT+CHARACTER_WALL, $07, $0A, $06, $08	; Rect of zBrick from ( 7,10); length = 6; height = 8
    432  25e7		       4b 07 0a 06*	      .byte.b	LINE+CHARACTER_WALL0, $07, $0A, $06, $02	; Line of zMagic from ( 7,10); length = 6; direction = right
    433  25ec		       81 10 13 04*	      .byte.b	FILL+CHARACTER_SOIL, $10, $13, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (16,19); length = 4; height = 4; fill = zSpace
    434  25f2		       09 12 14 	      .byte.b	CHARACTER_FIREFLY, $12, $14	; StoreChar zFFly1 at (18,20)
    435  25f5		       d0 0f 0a 06*	      .byte.b	RECT+CHARACTER_WALL, $0F, $0A, $06, $08	; Rect of zBrick from (15,10); length = 6; height = 8
    436  25fa		       4b 0f 0a 06*	      .byte.b	LINE+CHARACTER_WALL0, $0F, $0A, $06, $02	; Line of zMagic from (15,10); length = 6; direction = right
    437  25ff		       81 18 13 04*	      .byte.b	FILL+CHARACTER_SOIL, $18, $13, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (24,19); length = 4; height = 4; fill = zSpace
    438  2605		       09 1a 14 	      .byte.b	CHARACTER_FIREFLY, $1A, $14	; StoreChar zFFly1 at (26,20)
    439  2608		       81 20 13 04*	      .byte.b	FILL+CHARACTER_SOIL, $20, $13, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (32,19); length = 4; height = 4; fill = zSpace
    440  260e		       09 22 14 	      .byte.b	CHARACTER_FIREFLY, $22, $14	; StoreChar zFFly1 at (34,20)
    441  2611
      0  2611					      END_CAVE	ENCHANTED_BOXES
      1  2611		       ff		      .byte.b	$FF
      2  2611		       00 62	   CAVE_SIZE_ENCHANTED_BOXES =	* - CAVE_START
      3  2612				  -	      IF	CAVE_SIZE_ENCHANTED_BOXES > MAX_CAVE_SIZE
      4  2612				  -MAX_CAVE_SIZE SET	CAVE_SIZE_ENCHANTED_BOXES
      5  2612					      ENDIF
    443  2612					      ENDIF
    444  2612
    445  2612							;------------------------------------------------------------------------------
    446  2612
    447  2612					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2612					      START_CAVE	INTERMISSION_1
      1  2612				   CAVE_START SET	*
      2  2612		       00 04	   BANK_CAVE_INTERMISSION_1 =	_CURRENT_BANK
      3  2612				   CAVE_INTERMISSION_1 SUBROUTINE
      4  2612				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2612
    449  2612
    450  2612		       11		      .byte.b	$11	; Cave 17 I1
      0  2613					      CAVE_SIZE_INTERMISSION		; width, height
      0  2613					      CAVE_SIZE	20, 12
      1  2613		       14 0c		      .byte.b	20,12
    452  2615		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    453  2616		       30		      .byte.b	$30	;BCD'd $1E				    ; Diamonds worth: 30 points
    454  2617		       00		      .byte.b	$00	; Extra diamonds worth: 0 points
    455  2618		       0a 0b 0c 0d*	      .byte.b	$0A, $0B, $0C, $0D, $0E	; Randomiser seed values for difficulty levels 1-5
    456  261d		       06 06 06 06*	      .byte.b	$06, $06, $06, $06, $06	; Diamonds needed: 6, 6, 6, 6, 6 (for difficulty levels 1-5)
    457  2622		       0a 0a 0a 0a*	      .byte.b	$0A, $0A, $0A, $0A, $0A	; Cave time: 10, 10, 10, 10, 10 seconds
    458  2627
    459  2627							;-------------------------------------------------------------------------------------
    460  2627							; PALETTE DEFINITIONS
    461  2627
    462  2627				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    463  2627				  -	      .byte	$28, $46
    464  2627				  -	      .byte	$54, $a4
    465  2627				  -	      .byte	$be, $5e
    466  2627					      ELSE
    467  2627
    468  2627							; COMMENT FOLLOWING OUT IF NOT WANTED!
    469  2627							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    470  2627					      IF	AD_MODE
    471  2627		       28 46		      .byte.b	$28, $46
    472  2629		       54 a4		      .byte.b	$54, $a4
    473  262b		       be 7e		      .byte.b	$be, $7e
    474  262d					      ENDIF
    475  262d
    476  262d							; COMMENT FOLLOWING OUT IF NOT WANTED!
    477  262d							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    478  262d				  -	      IF	TJ_MODE
    479  262d				  -	      .byte	$28, $46
    480  262d				  -	      .byte	$54, $a4
    481  262d				  -	      .byte	$be, $7e
    482  262d					      ENDIF
    483  262d
    484  262d					      ENDIF
    485  262d
    486  262d							;-------------------------------------------------------------------------------------
    487  262d
    488  262d
    489  262d		       00 04 00 00	      .byte.b	$00, CHARACTER_DIAMOND, $00, $00	; Random objects:
    490  2631		       ff 09 00 00	      .byte.b	$FF, $09, $00, $00	;   zSpace : 255/256 = 99%
    491  2635							;   zDiaS  :	9/256 =  3%
    492  2635							;   third code unused (0%)
    493  2635							;   fourth code unused (0%)
    494  2635
    495  2635							;   superfluous due to limited cave size
    496  2635							;    .byte   FILL+CHARACTER_STEEL, $00, $02, $28, $16, CHARACTER_STEEL; FilledRect of zSteel from ( 0, 2); length = 40; height = 22; fill = zSteel
    497  2635		       8f 00 02 14*	      .byte.b	FILL+CHARACTER_STEEL, $00, $02, $14, 9+3, CHARACTER_BLANK	; FilledRect of zSteel from ( 0, 2); length = 20; height = 12; fill = zSpace
    498  263b							;    .byte   CHARACTER_FLUTTERBY2, $0A, $0C	      ; StoreChar zBFly3 at (10,12)
    499  263b							;    .byte   CHARACTER_BOX, $0A, $05		  ; StoreChar zBouS at (10, 4)
    500  263b							;    .byte   CHARACTER_SOIL, $0A, $6		      ; StoreChar zDirt at (10, 5)
    501  263b							;    .byte   CHARACTER_MANOCCUPIED, $03, $05	      ; StoreChar zPRFd1 at ( 3, 5)
    502  263b		       08 05 0c 	      .byte.b	CHARACTER_FLUTTERBY2, $05, $0C	; StoreChar zBFly3 at (10,12)
    503  263e		       02 06 07 	      .byte.b	CHARACTER_BOX, $06, $07	; StoreChar zBouS at (10, 4)
    504  2641		       01 06 08 	      .byte.b	CHARACTER_SOIL, $06, $8	; StoreChar zDirt at (10, 5)
    505  2644		       06 03 0b 	      .byte.b	CHARACTER_MANOCCUPIED, $03, $b	; StoreChar zPRFd1 at ( 3, 5)
    506  2647
    507  2647		       11 12 0c 	      .byte.b	CHARACTER_EXITDOOR, $12, $0C	; StoreChar zPreOut at (18,12)
    508  264a
      0  264a					      END_CAVE	INTERMISSION_1
      1  264a		       ff		      .byte.b	$FF
      2  264a		       00 39	   CAVE_SIZE_INTERMISSION_1 =	* - CAVE_START
      3  264b				  -	      IF	CAVE_SIZE_INTERMISSION_1 > MAX_CAVE_SIZE
      4  264b				  -MAX_CAVE_SIZE SET	CAVE_SIZE_INTERMISSION_1
      5  264b					      ENDIF
    510  264b					      ENDIF
    511  264b
    512  264b							;------------------------------------------------------------------------------
    513  264b
    514  264b					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  264b					      START_CAVE	INTERMISSION_2
      1  264b				   CAVE_START SET	*
      2  264b		       00 04	   BANK_CAVE_INTERMISSION_2 =	_CURRENT_BANK
      3  264b				   CAVE_INTERMISSION_2 SUBROUTINE
      4  264b				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  264b
    516  264b
    517  264b		       12		      .byte.b	$12	; Cave 18
      0  264c					      CAVE_SIZE_INTERMISSION		; width, height
      0  264c					      CAVE_SIZE	20, 12
      1  264c		       14 0c		      .byte.b	20,12
    519  264e		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    520  264f		       10		      .byte.b	$10	;BCD'd $0A				    ; Diamonds worth: 10 points
    521  2650		       00		      .byte.b	$00	; Extra diamonds worth: 0 points
    522  2651		       0a 0b 0c 0d*	      .byte.b	$0A, $0B, $0C, $0D, $0E	;	Randomiser seed values for difficulty levels 1-5
    523  2656		       10 10 10 10*	      .byte.b	$10, $10, $10, $10, $10	;	Diamonds needed: 16, 16, 16, 16, 16 (for difficulty levels 1-5)
    524  265b		       0f 0f 0f 0f*	      .byte.b	$0F, $0F, $0F, $0F, $0F	;	Cave time: 15, 15, 15, 15, 15 seconds
    525  2660
    526  2660							;-------------------------------------------------------------------------------------
    527  2660							; PALETTE DEFINITIONS
    528  2660
    529  2660				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    530  2660				  -	      .byte	$0a, $0a
    531  2660				  -	      .byte	$76, $c4
    532  2660				  -	      .byte	$2e, $2e
    533  2660					      ELSE
    534  2660
    535  2660							; COMMENT FOLLOWING OUT IF NOT WANTED!
    536  2660							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    537  2660					      IF	AD_MODE
    538  2660		       0a 0a		      .byte.b	$0a, $0a
    539  2662		       76 c4		      .byte.b	$76, $c4
    540  2664		       2e 2e		      .byte.b	$2e, $2e
    541  2666					      ENDIF
    542  2666
    543  2666							; COMMENT FOLLOWING OUT IF NOT WANTED!
    544  2666							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    545  2666				  -	      IF	TJ_MODE
    546  2666				  -	      .byte	$0a, $0a
    547  2666				  -	      .byte	$76, $c4
    548  2666				  -	      .byte	$2e, $2e
    549  2666					      ENDIF
    550  2666
    551  2666					      ENDIF
    552  2666
    553  2666							;-------------------------------------------------------------------------------------
    554  2666
    555  2666		       00 00 00 00	      .byte.b	$00, $00, $00, $00	; Random objects:
    556  266a		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
    557  266e							;   second code unused (0%)
    558  266e							;   third code unused (0%)
    559  266e							;   fourth code unused (0%)
    560  266e
    561  266e							;   superfluous due to limited cave size
    562  266e							;    .byte   FILL+CHARACTER_STEEL, $00, $02, $28, $16, CHARACTER_STEEL; FilledRect of zSteel from ( 0, 2); length = 40; height = 22; fill = zSteel
    563  266e		       8f 00 02 14*	      .byte.b	FILL+CHARACTER_STEEL, $00, $02, $14, $0C, CHARACTER_SOIL	; FilledRect of zSteel from ( 0, 2); length = 20; height = 12; fill = zDirt
    564  2674		       42 01 03 09*	      .byte.b	LINE+CHARACTER_BOX, $01, $03, $09, $03	; Line of zBouS from ( 1, 3); length = 9; direction = down/right
    565  2679		       49 02 03 08*	      .byte.b	LINE+CHARACTER_FIREFLY, $02, $03, $08, $03	; Line of zFFly1 from ( 2, 3); length = 8; direction = down/right
    566  267e		       44 01 05 08*	      .byte.b	LINE+CHARACTER_DIAMOND, $01, $05, $08, $03	; Line of zDiaS from ( 1, 5); length = 8; direction = down/right
    567  2683		       42 01 06 07*	      .byte.b	LINE+CHARACTER_BOX, $01, $06, $07, $03	; Line of zBouS from ( 1, 6); length = 7; direction = down/right
    568  2688		       42 12 03 09*	      .byte.b	LINE+CHARACTER_BOX, $12, $03, $09, $05	; Line of zBouS from (18, 3); length = 9; direction = down/left
    569  268d		       44 12 05 08*	      .byte.b	LINE+CHARACTER_DIAMOND, $12, $05, $08, $05	; Line of zDiaS from (18, 5); length = 8; direction = down/left
    570  2692		       42 12 06 07*	      .byte.b	LINE+CHARACTER_BOX, $12, $06, $07, $05	; Line of zBouS from (18, 6); length = 7; direction = down/left
    571  2697		       06 01 04 	      .byte.b	CHARACTER_MANOCCUPIED, $01, $04	; StoreChar zPRFd1 at ( 1, 4)
    572  269a		       11 12 04 	      .byte.b	CHARACTER_EXITDOOR, $12, $04	; StoreChar zPreOut at (18, 4)
    573  269d
      0  269d					      END_CAVE	INTERMISSION_2
      1  269d		       ff		      .byte.b	$FF
      2  269d		       00 53	   CAVE_SIZE_INTERMISSION_2 =	* - CAVE_START
      3  269e				  -	      IF	CAVE_SIZE_INTERMISSION_2 > MAX_CAVE_SIZE
      4  269e				  -MAX_CAVE_SIZE SET	CAVE_SIZE_INTERMISSION_2
      5  269e					      ENDIF
    575  269e					      ENDIF
    576  269e
    577  269e							;------------------------------------------------------------------------------
    578  269e
    579  269e					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  269e					      START_CAVE	INTERMISSION_3
      1  269e				   CAVE_START SET	*
      2  269e		       00 04	   BANK_CAVE_INTERMISSION_3 =	_CURRENT_BANK
      3  269e				   CAVE_INTERMISSION_3 SUBROUTINE
      4  269e				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  269e
    581  269e
    582  269e		       13		      .byte.b	$13	; Cave 19
      0  269f					      CAVE_SIZE_INTERMISSION		; width, height
      0  269f					      CAVE_SIZE	20, 12
      1  269f		       14 0c		      .byte.b	20,12
    584  26a1		       04		      .byte.b	$04	; Magic wall/amoeba slow growth for: 4 seconds
    585  26a2		       10		      .byte.b	$10	;BCD'd $0A				    ; Diamonds worth: 10 points
    586  26a3		       00		      .byte.b	$00	; Extra diamonds worth: 0 points
    587  26a4		       0a 0b 0c 0d*	      .byte.b	$0A, $0B, $0C, $0D, $0E	; Randomiser seed values for difficulty levels 1-5
    588  26a9		       0e 0e 0e 0e*	      .byte.b	$0E, $0E, $0E, $0E, $0E	; Diamonds needed: 14, 14, 14, 14, 14 (for difficulty levels 1-5)
    589  26ae		       14 14 14 14*	      .byte.b	$14, $14, $14, $14, $14	; Cave time: 20, 20, 20, 20, 20 seconds
    590  26b3
    591  26b3							;-------------------------------------------------------------------------------------
    592  26b3							; PALETTE DEFINITIONS
    593  26b3
    594  26b3				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    595  26b3				  -	      .byte	$16, $26
    596  26b3				  -	      .byte	$36, $44
    597  26b3				  -	      .byte	$8e, $9e
    598  26b3					      ELSE
    599  26b3
    600  26b3							; COMMENT FOLLOWING OUT IF NOT WANTED!
    601  26b3							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    602  26b3					      IF	AD_MODE
    603  26b3		       16 26		      .byte.b	$16, $26
    604  26b5		       36 44		      .byte.b	$36, $44
    605  26b7		       8e 9e		      .byte.b	$8e, $9e
    606  26b9					      ENDIF
    607  26b9
    608  26b9							; COMMENT FOLLOWING OUT IF NOT WANTED!
    609  26b9							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    610  26b9				  -	      IF	TJ_MODE
    611  26b9				  -	      .byte	$16, $26
    612  26b9				  -	      .byte	$36, $44
    613  26b9				  -	      .byte	$8e, $9e
    614  26b9					      ENDIF
    615  26b9
    616  26b9					      ENDIF
    617  26b9
    618  26b9							;-------------------------------------------------------------------------------------
    619  26b9
    620  26b9
    621  26b9		       00 00 00 00	      .byte.b	$00, $00, $00, $00	; Random objects:
    622  26bd		       00 00 00 00	      .byte.b	$00, $00, $00, $00	;   first code unused (0%)
    623  26c1							;   second code unused (0%)
    624  26c1							;   third code unused (0%)
    625  26c1							;   fourth code unused (0%)
    626  26c1
    627  26c1							;   superfluous due to limited cave size
    628  26c1							;    .byte   FILL+CHARACTER_STEEL, $00, $02, $28, $16, CHARACTER_STEEL; FilledRect of zSteel from ( 0, 2); length = 40; height = 22; fill = zSteel
    629  26c1		       8f 00 02 14*	      .byte.b	FILL+CHARACTER_STEEL, $00, $02, $14, $0C, CHARACTER_BLANK	; FilledRect of zSteel from ( 0, 2); length = 20; height = 12; fill = zSpace
    630  26c7		       44 01 0c 12*	      .byte.b	LINE+CHARACTER_DIAMOND, $01, $0C, $12, $02	; Line of zDiaS from ( 1,12); length = 18; direction = right
    631  26cc		       89 0f 08 04*	      .byte.b	FILL+CHARACTER_FIREFLY, $0F, $08, $04, $04, CHARACTER_FIREFLY	; FilledRect of zFFly1 from (15, 9); length = 4; height = 4; fill = zFFly1
    632  26d2							;    .byte   FILL+CHARACTER_FIREFLY, $0f, $09, $04, $03, CHARACTER_FIREFLY; FilledRect of zFFly1 from (15, 9); length = 4; height = 4; fill = zFFly1
    633  26d2							;    .byte   CHARACTER_MANOCCUPIED, $08, 3		  ; StoreChar zPRFd1 at ( 8, 3)
    634  26d2		       06 0f 06 	      .byte.b	CHARACTER_MANOCCUPIED, 15, 6	; StoreChar zPRFd1 at ( 8, 3)
    635  26d5		       11 12 07 	      .byte.b	CHARACTER_EXITDOOR, $12, $07	; StoreChar zPreOut at (18, 7)
    636  26d8
    637  26d8							; remainders of WAKA WAKA :(
    638  26d8							;    .byte   $13				  ; Cave WAKA_WAKA
    639  26d8							;    CAVE_SIZE_ROOM				  ; width, height
    640  26d8							;    .byte   $04				  ; Magic wall/amoeba slow growth for: 4 seconds
    641  26d8							;    .byte   $50				  ; Diamonds worth: 50 points
    642  26d8							;    .byte   $99				  ; Extra diamonds worth: 0 points
    643  26d8							;    .byte   $00, $00, $00, $00, $00		  ; Randomiser seed values for difficulty levels 1-5
    644  26d8							;    .byte   $05, $05, $05, $05, $05		  ; Diamonds needed: 14, 14, 14, 14, 14 (for difficulty levels 1-5)
    645  26d8							;    .byte   90, 75, 60, 50, 40		  ; Cave time: 20, 20, 20, 20, 20 seconds
    646  26d8							;
    647  26d8							;    .byte   $16, $26				  ; medium yellow     NTSC/PAL
    648  26d8							;    .byte   $36, $44				  ; dark orange
    649  26d8							;    .byte   $8e, $9e				  ; bright blue
    650  26d8							;
    651  26d8							;    .byte   0, 0, 0, 0			  ; Random objects, unused
    652  26d8							;    .byte   0, 0, 0, 0			  ; random values, unused
    653  26d8							;
    654  26d8							;    .byte   FILL+CHARACTER_STEEL, 10,  2, 19, 22, CHARACTER_BLANK
    655  26d8							;    .byte   CHARACTER_BLANK, 10, 10
    656  26d8							;    .byte   CHARACTER_BLANK, 10, 12
    657  26d8							;    .byte   CHARACTER_BLANK, 10, 14
    658  26d8							;    .byte   CHARACTER_BLANK, 28, 10
    659  26d8							;    .byte   CHARACTER_BLANK, 28, 12
    660  26d8							;    .byte   CHARACTER_BLANK, 28, 14
    661  26d8							;
    662  26d8							;    .byte   RECT+CHARACTER_STEEL, 12,  4,  2,  2
    663  26d8							;    .byte   RECT+CHARACTER_STEEL, 15,  4,  3,  2
    664  26d8							;    .byte   LINE+CHARACTER_STEEL, 19,  3,  3, .DIR_DOWN
    665  26d8							;    .byte   RECT+CHARACTER_STEEL, 21,  4,  3,  2
    666  26d8							;    .byte   RECT+CHARACTER_STEEL, 25,  4,  2,  2
    667  26d8							;
    668  26d8							;    .byte   LINE+CHARACTER_STEEL, 12,  7,  2, .DIR_RIGHT
    669  26d8							;    .byte   LINE+CHARACTER_STEEL, 15,  7,  5, .DIR_DOWN
    670  26d8							;    .byte   LINE+CHARACTER_STEEL, 17,  7,  5, .DIR_RIGHT
    671  26d8							;    .byte   LINE+CHARACTER_STEEL, 19,  7,  3, .DIR_DOWN
    672  26d8							;    .byte   LINE+CHARACTER_STEEL, 23,  7,  5, .DIR_DOWN
    673  26d8							;    .byte   LINE+CHARACTER_STEEL, 25,  7,  2, .DIR_RIGHT
    674  26d8							;
    675  26d8							;    .byte   LINE+CHARACTER_STEEL, 11,  9,  3, .DIR_RIGHT
    676  26d8							;    .byte   LINE+CHARACTER_STEEL, 15,  9,  3, .DIR_RIGHT
    677  26d8							;    .byte   LINE+CHARACTER_STEEL, 21,  9,  3, .DIR_RIGHT
    678  26d8							;    .byte   LINE+CHARACTER_STEEL, 25,  9,  3, .DIR_RIGHT
    679  26d8							;
    680  26d8							;    .byte   CHARACTER_STEEL, 13, 10
    681  26d8							;    .byte   CHARACTER_STEEL, 15, 10
    682  26d8							;    .byte   CHARACTER_STEEL, 23, 10
    683  26d8							;    .byte   CHARACTER_STEEL, 25, 10
    684  26d8							;
    685  26d8							;    .byte   LINE+CHARACTER_STEEL, 11, 11,  3, .DIR_RIGHT
    686  26d8							;    .byte   LINE+CHARACTER_STEEL, 17, 11,  3, .DIR_DOWN
    687  26d8							;    .byte   LINE+CHARACTER_STEEL, 21, 11,  3, .DIR_DOWN
    688  26d8							;    .byte   LINE+CHARACTER_STEEL, 25, 11,  3, .DIR_RIGHT
    689  26d8							;
    690  26d8							;    .byte   CHARACTER_STEEL, 17, 11
    691  26d8							;    .byte   CHARACTER_STEEL, 21, 11
    692  26d8							;
    693  26d8							;    .byte   LINE+CHARACTER_STEEL, 11, 12,  3, .DIR_RIGHT
    694  26d8							;    .byte   LINE+CHARACTER_STEEL, 15, 12,  3, .DIR_DOWN
    695  26d8							;    .byte   LINE+CHARACTER_STEEL, 17, 12,  5, .DIR_RIGHT
    696  26d8							;    .byte   LINE+CHARACTER_STEEL, 23, 12,  3, .DIR_DOWN
    697  26d8							;    .byte   LINE+CHARACTER_STEEL, 25, 12,  3, .DIR_RIGHT
    698  26d8							;
    699  26d8							;    .byte   CHARACTER_STEEL, 13, 14
    700  26d8							;    .byte   CHARACTER_STEEL, 15, 14
    701  26d8							;    .byte   CHARACTER_STEEL, 23, 14
    702  26d8							;    .byte   CHARACTER_STEEL, 25, 14
    703  26d8							;
    704  26d8							; about half way done until here...
    705  26d8							;
    706  26d8							;    .byte   CHARACTER_MANOCCUPIED, 1, 12
    707  26d8							;    .byte   CHARACTER_EXITDOOR, 38, 12
    708  26d8
    709  26d8					      ENDIF
    710  26d8
      0  26d8					      END_CAVE	INTERMISSION_3
      1  26d8		       ff		      .byte.b	$FF
      2  26d8		       00 3b	   CAVE_SIZE_INTERMISSION_3 =	* - CAVE_START
      3  26d9				  -	      IF	CAVE_SIZE_INTERMISSION_3 > MAX_CAVE_SIZE
      4  26d9				  -MAX_CAVE_SIZE SET	CAVE_SIZE_INTERMISSION_3
      5  26d9					      ENDIF
    712  26d9					      ENDIF
    713  26d9
    714  26d9
    715  26d9
    716  26d9
    717  26d9
    718  26d9							;ECHO "MAX CAVE SIZE = ", MAX_CAVE_SIZE
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm
    455  26d9
      0  26d9					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  26d9		       06 d9	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $6d9 , FREE= $127
      2  26d9					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  26d9				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  26d9				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  26d9				  -	      ERR
      6  26d9					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 3
      0  26d9					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  26d9							;------------------------------------------------------------------------------
      2  26d9							;##############################################################################
      3  26d9							;------------------------------------------------------------------------------
      0  26d9					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  2d21 ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
      5  2800
      6  2800							;TODOs:
      7  2800							; + store diamondsNeeded as BCD (with extra diamond flag in separate variable)
      8  2800							; + store caveTime as BCD (2 bytes)
      9  2800							; + diamonds left, time right (while playing)
     10  2800							; + six digit score, centered (short period after scoring)
     11  2800							; + player, men, cave/level (P#2 3 R, E/1) (at start of level, until Rockford appears)
     12  2800							; + make digits a bit darker
     13  2800							; o minimize space before and after digits
     14  2800							; - add missing texts (somehow)
     15  2800							;   - PAUSED (six digits)
     16  2800							;   ? OUT OF TIME (?)
     17  2800							;   ? BONUS LIFE (?)
     18  2800
     19  2800
     20  2800		       00 0e	   SCORE_COL  =	WHITE	;-2
     21  2800		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     22  2800		       00 66	   SCORE_COL_HIGH_PAL =	$66
     23  2800
     24  2800
     25  2800				   DigitVectorLOr
     26  2800		       88 94 a1 8e*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     27  280a		       5c 63 69 70	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     28  280e				   DigitVectorLO
     29  280e		       50 5c 69 56*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     30  2818		       37		      .byte.b	<BLANKL-1
     31  2819
     32  2819
     33  2819		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     34  2819		       00 0b	   ID_DIAMOND =	11
     35  2819		       00 0c	   ID_EXTRA   =	12
     36  2819		       00 0d	   ID_CLOCK   =	13
     37  2819		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     38  2819							;ID_A	      = 13
     39  2819							;ID_B	      = 14
     40  2819							;ID_C	      = 15
     41  2819							;ID_D	      = 16
     42  2819							;ID_E	      = 17
     43  2819							;ID_F	      = 18
     44  2819							;ID_G	      = 19
     45  2819							;ID_H	      = 20
     46  2819							;ID_I	      = 21
     47  2819							;ID_J	      = 22
     48  2819							;ID_K	      = 23
     49  2819							;ID_L	      = 24
     50  2819							;ID_M	      = 25
     51  2819							;ID_N	      = 26
     52  2819							;ID_O	      = 27
     53  2819							;ID_P	      = 28
     54  2819							;ID_BONUS0   = 29
     55  2819							;ID_BONUS1   = 30
     56  2819							;ID_BONUS2   = 31
     57  2819
     58  2819							; score patch adresses:
     59  2819				   SMTblLSB
     60  2819				   SMTblDiamonds
     61  2819		       52 48		      .byte.b	SM_Diamond0+1-SM_BASE, SM_Diamond2+1-SM_BASE
     62  281b				   SMTblTime
     63  281b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     64  281d				   SMTblScore
     65  281d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     66  2820				   SMTblMSB
     67  2820		       4d 43		      .byte.b	SM_Diamond1+1-SM_BASE, SM_Diamond3+1-SM_BASE
     68  2822		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     69  2824		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     70  2827
     71  2827		       00 00	   SM_OFS_DIAMONDS =	SMTblDiamonds - SMTblLSB
     72  2827		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     73  2827		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     74  2827
     75  2827				   CharVectorLO
     76  2827		       37		      .byte.b	<BLANKL-1
     77  2828		       8e a2 af bc	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     78  282c		       ca d3 c3 89	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     79  2830		       b5 95 83 d0	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     80  2834		       da 7d a9 9c	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     81  2838							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     82  2838
     83  2838							; Digit shape definitions are at start of bank so that we don't have page boundary
     84  2838							; crossing issues.
     85  2838
     86  2838							;	  .byte 0	      ; required!
     87  2838
     88  2838		       00 07	   DIGIT_H    =	7	; height of a score digit
     89  2838
     90  2838		       00 00 00 00*BLANKL     ds	7,0
     91  283f
     92  283f				   NineL
     93  283f		       70		      .byte.b	%01110000
     94  2840		       38		      .byte.b	%00111000
     95  2841		       1c		      .byte.b	%00011100
     96  2842		       7e		      .byte.b	%01111110
     97  2843		       e6		      .byte.b	%11100110
     98  2844		       e6		      .byte.b	%11100110
     99  2845							;    .byte %01111100
    100  2845				   SixL
    101  2845		       7c		      .byte.b	%01111100
    102  2846		       fe		      .byte.b	%11111110
    103  2847		       e6		      .byte.b	%11100110
    104  2848		       e6		      .byte.b	%11100110
    105  2849		       fc		      .byte.b	%11111100
    106  284a		       e0		      .byte.b	%11100000
    107  284b							;    .byte %01111100
    108  284b				   EightL
    109  284b		       7c		      .byte.b	%01111100
    110  284c		       fe		      .byte.b	%11111110
    111  284d		       e6		      .byte.b	%11100110
    112  284e		       e6		      .byte.b	%11100110
    113  284f		       7c		      .byte.b	%01111100
    114  2850		       e6		      .byte.b	%11100110
    115  2851							;    .byte %01111100
    116  2851				   ZeroL
    117  2851		       7c		      .byte.b	%01111100
    118  2852		       fe		      .byte.b	%11111110
    119  2853		       e6		      .byte.b	%11100110
    120  2854		       e6		      .byte.b	%11100110
    121  2855		       e6		      .byte.b	%11100110
    122  2856		       e6		      .byte.b	%11100110
    123  2857							;    .byte %01111100
    124  2857				   ThreeL
    125  2857		       7c		      .byte.b	%01111100
    126  2858		       fe		      .byte.b	%11111110
    127  2859		       e6		      .byte.b	%11100110
    128  285a		       0c		      .byte.b	%00001100
    129  285b		       18		      .byte.b	%00011000
    130  285c		       0c		      .byte.b	%00001100
    131  285d							;    .byte %01111110
    132  285d				   OneL
    133  285d		       7e		      .byte.b	%01111110
    134  285e		       7e		      .byte.b	%01111110
    135  285f		       18		      .byte.b	%00011000
    136  2860		       18		      .byte.b	%00011000
    137  2861		       38		      .byte.b	%00111000
    138  2862		       38		      .byte.b	%00111000
    139  2863		       18		      .byte.b	%00011000
    140  2864
    141  2864				   SevenL
    142  2864		       e0		      .byte.b	%11100000
    143  2865		       e0		      .byte.b	%11100000
    144  2866		       70		      .byte.b	%01110000
    145  2867		       38		      .byte.b	%00111000
    146  2868		       1c		      .byte.b	%00011100
    147  2869		       8e		      .byte.b	%10001110
    148  286a							;    .byte %11111110
    149  286a				   TwoL
    150  286a		       fe		      .byte.b	%11111110
    151  286b		       fe		      .byte.b	%11111110
    152  286c		       70		      .byte.b	%01110000
    153  286d		       38		      .byte.b	%00111000
    154  286e		       1c		      .byte.b	%00011100
    155  286f		       ce		      .byte.b	%11001110
    156  2870							;    .byte %01111100
    157  2870				   FiveL
    158  2870		       7c		      .byte.b	%01111100
    159  2871		       fe		      .byte.b	%11111110
    160  2872		       ee		      .byte.b	%11101110
    161  2873		       0e		      .byte.b	%00001110
    162  2874		       fc		      .byte.b	%11111100
    163  2875		       e0		      .byte.b	%11100000
    164  2876		       fe		      .byte.b	%11111110
    165  2877
    166  2877				   FourL
    167  2877		       1c		      .byte.b	%00011100
    168  2878		       1c		      .byte.b	%00011100
    169  2879		       1c		      .byte.b	%00011100
    170  287a		       fe		      .byte.b	%11111110
    171  287b		       dc		      .byte.b	%11011100
    172  287c		       c0		      .byte.b	%11000000
    173  287d		       c0		      .byte.b	%11000000
    174  287e
    175  287e							; cave "name" characters (left only!):
    176  287e
    177  287e				   CharN
    178  287e		       73		      .byte.b	%01110011
    179  287f		       77		      .byte.b	%01110111
    180  2880		       7f		      .byte.b	%01111111
    181  2881		       7f		      .byte.b	%01111111
    182  2882		       7f		      .byte.b	%01111111
    183  2883		       7b		      .byte.b	%01111011
    184  2884							;	  .byte %01110011
    185  2884				   CharK
    186  2884		       73		      .byte.b	%01110011
    187  2885		       73		      .byte.b	%01110011
    188  2886		       76		      .byte.b	%01110110
    189  2887		       7c		      .byte.b	%01111100
    190  2888		       7c		      .byte.b	%01111100
    191  2889		       76		      .byte.b	%01110110
    192  288a							;	  .byte %01110011
    193  288a				   CharH
    194  288a		       73		      .byte.b	%01110011
    195  288b		       73		      .byte.b	%01110011
    196  288c		       73		      .byte.b	%01110011
    197  288d		       73		      .byte.b	%01110011
    198  288e		       7f		      .byte.b	%01111111
    199  288f							;	  .byte %01110011
    200  288f							;	  .byte %01110011
    201  288f				   CharA
    202  288f		       73		      .byte.b	%01110011
    203  2890		       73		      .byte.b	%01110011
    204  2891		       7f		      .byte.b	%01111111
    205  2892		       73		      .byte.b	%01110011
    206  2893		       73		      .byte.b	%01110011
    207  2894		       3e		      .byte.b	%00111110
    208  2895		       1c		      .byte.b	%00011100
    209  2896
    210  2896				   CharJ
    211  2896		       1e		      .byte.b	%00011110
    212  2897		       3f		      .byte.b	%00111111
    213  2898		       73		      .byte.b	%01110011
    214  2899		       03		      .byte.b	%00000011
    215  289a		       03		      .byte.b	%00000011
    216  289b		       03		      .byte.b	%00000011
    217  289c		       03		      .byte.b	%00000011
    218  289d
    219  289d				   CharP
    220  289d		       70		      .byte.b	%01110000
    221  289e		       70		      .byte.b	%01110000
    222  289f		       7e		      .byte.b	%01111110
    223  28a0		       7f		      .byte.b	%01111111
    224  28a1		       73		      .byte.b	%01110011
    225  28a2		       73		      .byte.b	%01110011
    226  28a3							;	  .byte %01111110
    227  28a3				   CharB
    228  28a3		       7e		      .byte.b	%01111110
    229  28a4		       7f		      .byte.b	%01111111
    230  28a5		       73		      .byte.b	%01110011
    231  28a6		       73		      .byte.b	%01110011
    232  28a7		       7e		      .byte.b	%01111110
    233  28a8		       73		      .byte.b	%01110011
    234  28a9		       7e		      .byte.b	%01111110
    235  28aa
    236  28aa				   CharO
    237  28aa		       3e		      .byte.b	%00111110
    238  28ab		       7f		      .byte.b	%01111111
    239  28ac		       63		      .byte.b	%01100011
    240  28ad		       63		      .byte.b	%01100011
    241  28ae		       63		      .byte.b	%01100011
    242  28af		       63		      .byte.b	%01100011
    243  28b0							;	  .byte %00111110
    244  28b0				   CharC
    245  28b0		       3e		      .byte.b	%00111110
    246  28b1		       7f		      .byte.b	%01111111
    247  28b2		       73		      .byte.b	%01110011
    248  28b3		       70		      .byte.b	%01110000
    249  28b4		       70		      .byte.b	%01110000
    250  28b5		       73		      .byte.b	%01110011
    251  28b6							;	  .byte %00111110
    252  28b6				   CharI
    253  28b6		       3e		      .byte.b	%00111110
    254  28b7		       3e		      .byte.b	%00111110
    255  28b8		       1c		      .byte.b	%00011100
    256  28b9		       1c		      .byte.b	%00011100
    257  28ba		       1c		      .byte.b	%00011100
    258  28bb		       1c		      .byte.b	%00011100
    259  28bc		       3e		      .byte.b	%00111110
    260  28bd
    261  28bd				   CharD
    262  28bd		       7c		      .byte.b	%01111100
    263  28be		       7e		      .byte.b	%01111110
    264  28bf		       76		      .byte.b	%01110110
    265  28c0		       73		      .byte.b	%01110011
    266  28c1		       73		      .byte.b	%01110011
    267  28c2		       76		      .byte.b	%01110110
    268  28c3		       7c		      .byte.b	%01111100
    269  28c4				   CharG
    270  28c4		       3f		      .byte.b	%00111111
    271  28c5		       7f		      .byte.b	%01111111
    272  28c6		       73		      .byte.b	%01110011
    273  28c7		       77		      .byte.b	%01110111
    274  28c8		       70		      .byte.b	%01110000
    275  28c9		       70		      .byte.b	%01110000
    276  28ca		       3f		      .byte.b	%00111111
    277  28cb
    278  28cb				   CharE
    279  28cb		       7f		      .byte.b	%01111111
    280  28cc		       7f		      .byte.b	%01111111
    281  28cd		       70		      .byte.b	%01110000
    282  28ce		       70		      .byte.b	%01110000
    283  28cf		       7e		      .byte.b	%01111110
    284  28d0		       70		      .byte.b	%01110000
    285  28d1							;	  .byte %01111111
    286  28d1				   CharL
    287  28d1		       7f		      .byte.b	%01111111
    288  28d2		       7f		      .byte.b	%01111111
    289  28d3		       70		      .byte.b	%01110000
    290  28d4							;	  .byte %01110000
    291  28d4							;	  .byte %01110000
    292  28d4							;	  .byte %01110000
    293  28d4							;	  .byte %01110000
    294  28d4				   CharF
    295  28d4		       70		      .byte.b	%01110000
    296  28d5		       70		      .byte.b	%01110000
    297  28d6		       70		      .byte.b	%01110000
    298  28d7		       70		      .byte.b	%01110000
    299  28d8		       7e		      .byte.b	%01111110
    300  28d9		       70		      .byte.b	%01110000
    301  28da		       7f		      .byte.b	%01111111
    302  28db
    303  28db				   CharM
    304  28db		       63		      .byte.b	%01100011
    305  28dc		       63		      .byte.b	%01100011
    306  28dd		       63		      .byte.b	%01100011
    307  28de		       6b		      .byte.b	%01101011
    308  28df		       7f		      .byte.b	%01111111
    309  28e0		       77		      .byte.b	%01110111
    310  28e1		       63		      .byte.b	%01100011
    311  28e2
    312  28e2				   HeadL
    313  28e2		       24		      .byte.b	%00100100
    314  28e3		       18		      .byte.b	%00011000
    315  28e4		       3c		      .byte.b	%00111100
    316  28e5		       5a		      .byte.b	%01011010
    317  28e6		       5a		      .byte.b	%01011010
    318  28e7		       3c		      .byte.b	%00111100
    319  28e8		       24		      .byte.b	%00100100
    320  28e9
    321  28e9				   IntermissionL
    322  28e9		       1e		      .byte.b	%00011110
    323  28ea		       1e		      .byte.b	%00011110
    324  28eb		       0c		      .byte.b	%00001100
    325  28ec		       0c		      .byte.b	%00001100
    326  28ed		       1e		      .byte.b	%00011110
    327  28ee		       00		      .byte.b	%00000000
    328  28ef		       0c		      .byte.b	%00001100
    329  28f0
    330  28f0							;-------------------------------------------------------------------------------------
    331  28f0				   PosTbl
    332  28f0		       40		      .byte.b	$40
    333  28f1		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    334  28f9		       b9		      .byte.b	$b9
    335  28fa
    336  28fa
    337  28fa							;------------------------------------------------------------------------------
    338  28fa							; RAM-BASED SUBROUTINES...
    339  28fa							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    340  28fa							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    341  28fa							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    342  28fa							; the RAM-based routine.
    343  28fa
    344  28fa							;z26 call ..\Tools\Z26\4A50\z26.exe -v18 -g14 -r60 $(ProjectName)$(ConfigurationName).bin
    345  28fa
    346  28fa
    347  2900		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    348  2900
    349  2900		       f1 00	   SM_BASE    =	.
    350  2900
    351  2900							;#IF 0 ;{
    352  2900							;    DEFINE_SUBROUTINE Score3x3
    353  2900							;
    354  2900							;	  sta	  RESP0
    355  2900							;	   sta	   RESP1
    356  2900							;	   lda	   #$$000
    357  2900							;	    sta     GRP0
    358  2900							;	    lda     #$$009
    359  2900							;	    sta     GRP1
    360  2900							;	    lda     #$$202
    361  2900							;	    sta     ENABL
    362  2900							;	    nop
    363  2900							;	    nop
    364  2900							;	    nop
    365  2900							;	    lda     #$$016
    366  2900							;	    ldy     #$$100
    367  2900							;	    ldx     #$$109
    368  2900							;	    sta     GRP0    ; Critical time is right here
    369  2900							;	    stx     GRP1
    370  2900							;	    sty     GRP0
    371  2900							;	    sta     RESP0
    372  2900							;	    sta     RESP1
    373  2900							;	    ldx     #$$116
    374  2900							;	    lda     #$$209
    375  2900							;	    stx     GRP0
    376  2900							;	    sta     GRP1
    377  2900							;	    lda     #$$200
    378  2900							;	    sta     GRP0
    379  2900							;	    sta     RESP0
    380  2900							;	    sta     RESP1
    381  2900							;	    lda     #$$216
    382  2900							;	    nop
    383  2900							;	    sta     GRP0
    384  2900							;
    385  2900							;	      rts
    386  2900							;#ENDIF ;}
    387  2900
    388  2900
    389  2900							;------------------------------------------------------------------------------
    390  2900				   Score1x6Fix SUBROUTINE
      0  2900					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  2900		       00 05	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  2900					      SUBROUTINE
      3  2900				   DrawDigits1x6
    392  2900							;					     @07
    393  2900		       ba		      tsx		; 2
    394  2901
    395  2901		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 58    @65
    396  2904
    397  2904		       86 df		      stx	tmpStack	; 3 =	3
    398  2906
    399  2906				   LoopDraw1x6		;
    400  2906				   SMDIGIT0
    401  2906		       b9 88 f3 	      lda	ZeroR-1,y	; 4
    402  2909		       85 42		      sta	WSYNC	; 3
    403  290b							;---------------------------------------------------------------
    404  290b		       85 6a		      sta	HMOVE	; 3
      0  290d					      SLEEP	3	; 3 =	6
      1  290d				   .CYCLES    SET	3
      2  290d
      3  290d				  -	      IF	.CYCLES < 2
      4  290d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  290d				  -	      ERR
      6  290d					      ENDIF
      7  290d
      8  290d					      IF	.CYCLES & 1
      9  290d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  290d		       04 00		      nop	0
     11  290f				  -	      ELSE
     12  290f				  -	      bit	VSYNC
     13  290f					      ENDIF
     14  290f				   .CYCLES    SET	.CYCLES - 3
     15  290f					      ENDIF
     16  290f
     17  290f				  -	      REPEAT	.CYCLES / 2
     18  290f				  -	      nop
     19  290f					      REPEND
    406  290f		       85 5b		      sta	GRP0	; 3
    407  2911				   SMDIGIT1
    408  2911		       b9 50 f0 	      lda	ZeroL-1,y	; 4
    409  2914		       85 5c		      sta	GRP1	; 3
    410  2916				   SMDIGIT2
    411  2916		       b9 88 f3 	      lda	ZeroR-1,y	; 4
    412  2919		       85 5b		      sta	GRP0	; 3 = 17
    413  291b				   SMDIGIT5
    414  291b		       be 50 f0 	      ldx	ZeroL-1,y	; 4
    415  291e		       9a		      txs		; 2
    416  291f				   SMDIGIT3
    417  291f		       be 50 f0 	      ldx	ZeroL-1,y	; 4
    418  2922				   SMDIGIT4
    419  2922		       b9 88 f3 	      lda	ZeroR-1,y	; 4
    420  2925		       85 6b		      sta	HMCLR	; 3
    421  2927		       86 5c		      stx	GRP1	; 3
    422  2929		       85 5b		      sta	GRP0	; 3 = 23
    423  292b
    424  292b		       ba		      tsx		; 2
    425  292c		       86 5c		      stx	GRP1	; 3
    426  292e		       85 5b		      sta	GRP0	; 3 =	8
    427  2930
    428  2930		       88		      dey		; 2
      0  2931					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  2931					      LIST	ON
      9  2931		       d0 d3		      bne	LoopDraw1x6
    430  2933
    431  2933		       a6 df		      ldx	tmpStack	; 3
    432  2935		       9a		      txs		; 2
    433  2936				   ExitDigitKernel6
      0  2936					      SLEEP	3	; 3
      1  2936				   .CYCLES    SET	3
      2  2936
      3  2936				  -	      IF	.CYCLES < 2
      4  2936				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2936				  -	      ERR
      6  2936					      ENDIF
      7  2936
      8  2936					      IF	.CYCLES & 1
      9  2936					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2936		       04 00		      nop	0
     11  2938				  -	      ELSE
     12  2938				  -	      bit	VSYNC
     13  2938					      ENDIF
     14  2938				   .CYCLES    SET	.CYCLES - 3
     15  2938					      ENDIF
     16  2938
     17  2938				  -	      REPEAT	.CYCLES / 2
     18  2938				  -	      nop
     19  2938					      REPEND
    435  2938		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    436  293b
    437  293b
    438  293b							;------------------------------------------------------------------------------
    439  293b				   Score2x4Fix SUBROUTINE
      0  293b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  293b		       00 05	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  293b					      SUBROUTINE
      3  293b				   DrawDigits2x4
    441  293b
    442  293b
    443  293b							; Subroutine by Thomas Jentzsch.  Magic!
    444  293b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    445  293b
    446  293b		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 56    @63
    447  293e
    448  293e		       85 6a		      sta	HMOVE	; 3
      0  2940					      SLEEP	4	; 4  =  7
      1  2940				   .CYCLES    SET	4
      2  2940
      3  2940				  -	      IF	.CYCLES < 2
      4  2940				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2940				  -	      ERR
      6  2940					      ENDIF
      7  2940
      8  2940				  -	      IF	.CYCLES & 1
      9  2940				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2940				  -	      nop	0
     11  2940				  -	      ELSE
     12  2940				  -	      bit	VSYNC
     13  2940				  -	      ENDIF
     14  2940				  -.CYCLES    SET	.CYCLES - 3
     15  2940					      ENDIF
     16  2940
     17  2940					      REPEAT	.CYCLES / 2
     18  2940		       ea		      nop
     17  2940					      REPEND
     18  2941		       ea		      nop
     19  2942					      REPEND
    450  2942
    451  2942				   LoopDraw2x4		;	     @70
    452  2942				   SM_Diamond3
    453  2942		       b9 63 f3 	      lda	DequalsR-1,y	; 4		     G
    454  2945							;---------------------------------------------------------------
    455  2945		       85 5b		      sta	GRP0	; 3
    456  2947				   SM_Diamond2
    457  2947		       b9 50 f0 	      lda	ZeroL-1,y	; 4		     A
    458  294a		       85 5c		      sta	GRP1	; 3
    459  294c				   SM_Diamond1
    460  294c		       b9 88 f3 	      lda	ZeroR-1,y	; 4		     M
    461  294f		       85 5b		      sta	GRP0	; 3
    462  2951				   SM_Diamond0
    463  2951		       be 50 f0 	      ldx	ZeroL-1,y	; 4		     E
    464  2954		       85 50		      sta	RESP0	; 3 = 28    @22
    465  2956		       85 51		      sta	RESP1	; 3 =	3    @25
    466  2958				   SM_Time3
    467  2958		       b9 70 f3 	      lda	ClockR-1,y	; 4		     O
    468  295b		       86 5c		      stx	GRP1	; 3
    469  295d		       85 5b		      sta	GRP0	; 3
    470  295f				   SM_Time2
    471  295f		       b9 50 f0 	      lda	ZeroL-1,y	; 4		     V
    472  2962		       85 5c		      sta	GRP1	; 3
    473  2964				   SM_Time1
    474  2964		       b9 88 f3 	      lda	ZeroR-1,y	; 4		     E
    475  2967		       85 5b		      sta	GRP0	; 3
    476  2969		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    477  296b		       85 51		      sta	RESP1	; 3 =	3    @55
    478  296d				   SM_Time0
    479  296d		       b9 50 f0 	      lda	ZeroL-1,y	; 4		     R
    480  2970		       85 5c		      sta	GRP1	; 3
    481  2972		       85 5b		      sta	GRP0	; 3
    482  2974		       88		      dey		; 2
      0  2975					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  2975					      LIST	ON
      9  2975		       d0 cb		      bne	LoopDraw2x4
    484  2977
    485  2977				   ExitDigitKernel		;	     @69
    486  2977		       84 5b		      sty	GRP0	; 3
    487  2979		       84 5c		      sty	GRP1	; 3
    488  297b							;---------------------------------------------------------------
    489  297b		       84 5b		      sty	GRP0	; 3	     @02
    490  297d
    491  297d							; Contribution by Thomas Jentzsch
    492  297d							; Rewrite/Optimised for single sprite AD
    493  297d
    494  297d		       a6 a1		      ldx	ManDrawX	; 3
    495  297f		       bd f0 f0 	      lda	PosTbl,x	; 4
    496  2982		       85 60		      sta	HMP0	; 3
    497  2984		       29 0f		      and	#$0f	; 2
    498  2986		       f0 04		      beq	.zeroPos	; 2/3=15
    499  2988		       aa		      tax		; 2
    500  2989				   .loopWait
    501  2989		       ca		      dex		; 2
    502  298a		       d0 fd		      bne	.loopWait	; 2/3= 6
    503  298c				   .zeroPos
    504  298c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    505  298e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    506  2990		       a5 af		      lda	BGColour	; 3
    507  2992		       86 62		      stx	HMM0	; 3	     for extra life stars!
    508  2994		       85 42		      sta	WSYNC	; 3
    509  2996							;---------------------------------------------------------------
    510  2996		       85 6a		      sta	HMOVE	; 3
    511  2998		       60		      rts		; 6	     @09
    512  2999
    513  2999							;------------------------------------------------------------------------------
    514  2999				   Score3x2Fix SUBROUTINE
      0  2999					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  2999		       00 05	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  2999					      SUBROUTINE
      3  2999				   DrawDigits3x2
    516  2999							;					     @07
    517  2999		       a9 16		      lda	#%010110	; 2
    518  299b		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    519  299d		       20 f4 f1 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    520  29a0
    521  29a0		       a9 00		      lda	#0
    522  29a2		       85 66		      sta	VDELP1
    523  29a4				   LoopDraw3x2		;
    524  29a4		       85 42		      sta	WSYNC	; 3
    525  29a6							;---------------------------------------------------------------
    526  29a6		       85 6a		      sta	HMOVE	; 3 =	3
    527  29a8		       b9 9c f0 	      lda	CharP-1,y	; 4
    528  29ab		       85 5b		      sta	GRP0	; 3
    529  29ad				   SMPLAYER
    530  29ad		       b9 94 f3 	      lda	OneR-1,y	; 4
    531  29b0		       85 5c		      sta	GRP1	; 3 = 14    @17
    532  29b2		       b9 e1 f0 	      lda	HeadL-1,y	; 4
    533  29b5				   SMMEN
    534  29b5		       be 8e f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  29b8					      SLEEP	5	;   =	5
      1  29b8				   .CYCLES    SET	5
      2  29b8
      3  29b8				  -	      IF	.CYCLES < 2
      4  29b8				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  29b8				  -	      ERR
      6  29b8					      ENDIF
      7  29b8
      8  29b8					      IF	.CYCLES & 1
      9  29b8					      IFNCONST	NO_ILLEGAL_OPCODES
     10  29b8		       04 00		      nop	0
     11  29ba				  -	      ELSE
     12  29ba				  -	      bit	VSYNC
     13  29ba					      ENDIF
     14  29ba				   .CYCLES    SET	.CYCLES - 3
     15  29ba					      ENDIF
     16  29ba
     17  29ba					      REPEAT	.CYCLES / 2
     18  29ba		       ea		      nop
     19  29bb					      REPEND
    536  29bb		       85 5b		      sta	GRP0	; 3
    537  29bd				   SMCAVE
    538  29bd		       b9 8e f0 	      lda	CharA-1,y	; 4
    539  29c0		       85 6b		      sta	HMCLR	; 3 = 10    @40
    540  29c2		       86 5c		      stx	GRP1	; 3 =	3    @43
    541  29c4		       85 5b		      sta	GRP0	; 3
    542  29c6				   SMLEVEL
    543  29c6		       b9 94 f3 	      lda	OneR-1,y	; 4
    544  29c9		       85 5c		      sta	GRP1	; 3 = 10    @53
    545  29cb
    546  29cb		       88		      dey		; 2
      0  29cc					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  29cc					      LIST	ON
      9  29cc		       d0 d6		      bne	LoopDraw3x2
    548  29ce							;					     @57
      0  29ce					      SLEEP	3	; 3
      1  29ce				   .CYCLES    SET	3
      2  29ce
      3  29ce				  -	      IF	.CYCLES < 2
      4  29ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  29ce				  -	      ERR
      6  29ce					      ENDIF
      7  29ce
      8  29ce					      IF	.CYCLES & 1
      9  29ce					      IFNCONST	NO_ILLEGAL_OPCODES
     10  29ce		       04 00		      nop	0
     11  29d0				  -	      ELSE
     12  29d0				  -	      bit	VSYNC
     13  29d0					      ENDIF
     14  29d0				   .CYCLES    SET	.CYCLES - 3
     15  29d0					      ENDIF
     16  29d0
     17  29d0				  -	      REPEAT	.CYCLES / 2
     18  29d0				  -	      nop
     19  29d0					      REPEND
    550  29d0		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    551  29d3
    552  29d3
    553  29d3							;------------------------------------------------------------------------------
      0  29d3					      DEFINE_SUBROUTINE	DrawDigits
      1  29d3		       00 05	   BANK_DrawDigits =	_CURRENT_BANK
      2  29d3					      SUBROUTINE
      3  29d3				   DrawDigits
    555  29d3
    556  29d3				   VblankLoopBD
    557  29d3		       ac 84 02 	      ldy	INTIM
    558  29d6		       d0 fb		      bne	VblankLoopBD
    559  29d8
    560  29d8		       84 41		      sty	VBLANK	; 3	     <-- 0
    561  29da		       a5 c8		      lda	scoringFlags	; 3
    562  29dc		       29 03		      and	#DISPLAY_FLAGS	; 2
    563  29de		       aa		      tax		; 2
    564  29df
    565  29df							;    DEFINE_SUBROUTINE DrawDigit2
    566  29df							;
    567  29df							;    ; Generic interface to scoring routine
    568  29df
    569  29df		       bd ea f1 	      lda	ScoreKernelLo,x	; 4
    570  29e2
    571  29e2		       85 42		      sta	WSYNC	; 3
    572  29e4							;---------------------------------------------------------------
    573  29e4		       8d e8 f5 	      sta	SMJUMP+1+RAM_WRITE	; 4
    574  29e7				   SMJUMP
    575  29e7		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    576  29ea
    577  29ea				   ScoreKernelLo
    578  29ea		       3b		      .byte.b	<Score2x4Fix	; diamonds, time
    579  29eb		       00		      .byte.b	<Score1x6Fix	; score
    580  29ec		       99		      .byte.b	<Score3x2Fix	; player, lives, cave/level
    581  29ed		       00		      .byte.b	<Score1x6Fix	; high score
    582  29ee
      0  29ee					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  29ee					      LIST	ON
    584  29ee
    585  29ee							;------------------------------------------------------------------------------
      0  29ee					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  29ee		       00 05	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  29ee					      SUBROUTINE
      3  29ee				   PrepareDrawDigits
    587  29ee							;					     @13
    588  29ee		       a0 d1		      ldy	#$d1	; 2
    589  29f0		       a9 13		      lda	#%010011	; 2
    590  29f2		       85 66		      sta	VDELP1	; 3 =	7
    591  29f4				   PrepareDrawDigits2		;	    @17/20
    592  29f4		       84 65		      sty	VDELP0	; 3 =	3
    593  29f6
    594  29f6		       85 45		      sta	NUSIZ1	; 3
    595  29f8		       85 44		      sta	NUSIZ0	; 3 =	6
    596  29fa
    597  29fa		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    598  29fd		       85 50		      sta	RESP0	; 3	     @33/36
    599  29ff		       85 51		      sta	RESP1	; 3 = 10    @36/39
    600  2a01
    601  2a01		       84 60		      sty	HMP0	; 3
    602  2a03		       c8		      iny		; 2
    603  2a04		       84 61		      sty	HMP1	; 3 =	8
    604  2a06				   SMCOLOR
    605  2a06		       a0 0e		      ldy	#SCORE_COL	; 2
    606  2a08		       84 46		      sty	COLUP0	; 3
    607  2a0a		       84 47		      sty	COLUP1	; 3 =	8
    608  2a0c
    609  2a0c		       a0 07		      ldy	#DIGIT_H	; 2
    610  2a0e		       60		      rts		; 6 =	8
    611  2a0f							; total: 27
    612  2a0f
    613  2a0f
    614  2a0f							;------------------------------------------------------------------------------
      0  2a0f					      DEFINE_SUBROUTINE	UpdateScore
      1  2a0f		       00 05	   BANK_UpdateScore =	_CURRENT_BANK
      2  2a0f					      SUBROUTINE
      3  2a0f				   UpdateScore
    616  2a0f							; a = added score value
    617  2a0f
    618  2a0f							; initially switch to score:
    619  2a0f		       a0 01		      ldy	#DISPLAY_SCORE
    620  2a11		       84 df		      sty	newDisplay
    621  2a13
    622  2a13		       18		      clc
    623  2a14		       f8		      sed
    624  2a15		       a0 04		      ldy	#SM_OFS_SCORE
    625  2a17				   .loopScore
    626  2a17		       79 dd f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    627  2a1a		       99 dd f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    628  2a1d		       08		      php
    629  2a1e							; *** bonus life every 500 points: ***
    630  2a1e		       c0 05		      cpy	#SM_OFS_SCORE+1
    631  2a20		       d0 1c		      bne	.skipBonusLife
    632  2a22		       aa		      tax
    633  2a23
    634  2a23		       29 0f		      and	#$0f
    635  2a25		       f0 04		      beq	.bonusLife	; 000?
    636  2a27		       c9 05		      cmp	#$05
    637  2a29		       d0 12		      bne	.noBonusLife	; 500?
    638  2a2b				   .bonusLife
    639  2a2b							; add extra life, limited to 9
    640  2a2b
    641  2a2b		       a5 ab		      lda	MenCurrent
    642  2a2d		       29 0f		      and	#$0f
    643  2a2f		       c9 09		      cmp	#9
    644  2a31		       b0 0a		      bcs	.noBonusLife
    645  2a33		       e6 ab		      inc	MenCurrent
    646  2a35
    647  2a35							; bonus life has priority over score:
    648  2a35		       a9 02		      lda	#DISPLAY_LIVES
    649  2a37		       85 df		      sta	newDisplay
    650  2a39		       a9 ff		      lda	#EXTRA_LIFE_TIMER
    651  2a3b		       85 c6		      sta	extraLifeTimer
    652  2a3d
    653  2a3d				   .noBonusLife
    654  2a3d		       8a		      txa
    655  2a3e				   .skipBonusLife
    656  2a3e		       20 3d f3 	      jsr	SetupBCDPtr
    657  2a41		       28		      plp
    658  2a42		       a9 00		      lda	#0
    659  2a44		       b0 d1		      bcs	.loopScore
    660  2a46		       d8		      cld
    661  2a47
    662  2a47							; switch display
    663  2a47		       a5 c8		      lda	scoringFlags
    664  2a49		       29 03		      and	#DISPLAY_FLAGS
    665  2a4b		       c5 df		      cmp	newDisplay	; lower priority than current?
    666  2a4d		       f0 08		      beq	.restartTime
    667  2a4f		       b0 0a		      bcs	.skipNew
    668  2a51		       45 c8		      eor	scoringFlags	; remove existing score mode
    669  2a53		       05 df		      ora	newDisplay	; switch to new score mode
    670  2a55		       85 c8		      sta	scoringFlags
    671  2a57				   .restartTime
    672  2a57		       a9 3c		      lda	#SCORING_TIMER	; maybe always restart timer?
    673  2a59		       85 c7		      sta	scoringTimer
    674  2a5b				   .skipNew
    675  2a5b
    676  2a5b		       60		      rts
    677  2a5c
    678  2a5c							;---------------------------------------------------------------------------
    679  2a5c
      0  2a5c					      DEFINE_SUBROUTINE	SwapPlayers
      1  2a5c		       00 05	   BANK_SwapPlayers =	_CURRENT_BANK
      2  2a5c					      SUBROUTINE
      3  2a5c				   SwapPlayers
    681  2a5c
    682  2a5c							; assume no new high score:
    683  2a5c		       a0 ff		      ldy	#-1
    684  2a5e		       84 e2		      sty	highScoreSK
    685  2a60
    686  2a60							; update highscore after last live:
    687  2a60		       a5 ab		      lda	MenCurrent
    688  2a62		       29 0f		      and	#$0f	; player has lives left?
    689  2a64		       d0 1c		      bne	.playerAlive	; YES, so we don't check high score
    690  2a66
    691  2a66							; check for a new high score:
    692  2a66							;	  ldy #-1
    693  2a66		       18		      clc		; score has to be at least 1 bigger!
    694  2a67				   .loopCheckHighScore
    695  2a67		       c8		      iny
    696  2a68		       b9 e1 f3 	      lda	ScoreCurrent,y
    697  2a6b		       f9 eb f3 	      sbc	HighScore,y
    698  2a6e		       98		      tya
    699  2a6f		       49 02		      eor	#2
    700  2a71		       d0 f4		      bne	.loopCheckHighScore
    701  2a73		       90 0d		      bcc	.noHighScore
    702  2a75
    703  2a75							; new high score, update:
    704  2a75		       a2 04		      ldx	#5-1
    705  2a77				   .loopSetHighScore
    706  2a77		       bd e1 f3 	      lda	ScoreCurrent,x
    707  2a7a		       9d eb f7 	      sta	HighScore+RAM_WRITE,x
    708  2a7d		       95 e2		      sta	highScoreSK,x
    709  2a7f		       ca		      dex
    710  2a80		       10 f5		      bpl	.loopSetHighScore
    711  2a82				   .noHighScore
    712  2a82
    713  2a82				   .playerAlive
    714  2a82		       a5 ab		      lda	MenCurrent
    715  2a84		       29 f0		      and	#$f0	; other player has lives left?
    716  2a86		       f0 21		      beq	.otherPlayerDead	; NO, so we don't swap scores
    717  2a88
    718  2a88							; save the current player variables to the player's backup:
    719  2a88		       a0 02		      ldy	#3-1
    720  2a8a				   .swapScore
    721  2a8a		       be e6 f3 	      ldx	PlayerScores,y
    722  2a8d		       b9 e1 f3 	      lda	ScoreCurrent,y
    723  2a90		       99 e6 f7 	      sta	PlayerScores+RAM_WRITE,y
    724  2a93		       8a		      txa
    725  2a94		       99 e1 f7 	      sta	ScoreCurrent+RAM_WRITE,y
    726  2a97		       88		      dey
    727  2a98		       10 f0		      bpl	.swapScore
    728  2a9a
    729  2a9a							; swap cave and level:
    730  2a9a		       a2 01		      ldx	#1
    731  2a9c				   .loopCaveLevel
    732  2a9c		       bc e9 f3 	      ldy	PlayerCave,x
    733  2a9f		       b5 b0		      lda	cave,x
    734  2aa1		       9d e9 f7 	      sta	PlayerCave+RAM_WRITE,x
    735  2aa4		       94 b0		      sty	cave,x
    736  2aa6		       ca		      dex
    737  2aa7		       10 f3		      bpl	.loopCaveLevel
    738  2aa9
    739  2aa9				   .otherPlayerDead
    740  2aa9		       60		      rts
    741  2aaa
    742  2aaa							;---------------------------------------------------------------------------
    743  2aaa
    744  2aaa				   HighScoreColTbl
    745  2aaa		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    746  2aac		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    747  2aae
      0  2aae					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  2aae		       00 05	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  2aae					      SUBROUTINE
      3  2aae				   GeneralScoringSetups
    749  2aae
    750  2aae		       a0 04		      ldy	#SM_OFS_SCORE
    751  2ab0				   .loopScore2
    752  2ab0		       a5 c8		      lda	scoringFlags
    753  2ab2		       29 03		      and	#DISPLAY_FLAGS
    754  2ab4		       c9 03		      cmp	#DISPLAY_HIGH
    755  2ab6		       a6 81		      ldx	Platform
    756  2ab8		       bd aa f2 	      lda	HighScoreColTbl,x
    757  2abb		       aa		      tax
    758  2abc		       b9 e7 f3 	      lda	HighScore-SM_OFS_SCORE,y
    759  2abf		       b0 05		      bcs	.showHighScore
    760  2ac1		       a2 0e		      ldx	#SCORE_COL
    761  2ac3		       b9 dd f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    762  2ac6				   .showHighScore
    763  2ac6		       8e 07 f6 	      stx	SMCOLOR+1+RAM_WRITE
    764  2ac9		       20 3d f3 	      jsr	SetupBCDPtr
    765  2acc		       c0 07		      cpy	#SM_OFS_SCORE+3
    766  2ace		       90 e0		      bcc	.loopScore2
    767  2ad0
    768  2ad0							; display number of lives in leftmost digit of middle score XX nX XX
    769  2ad0
    770  2ad0		       a5 ab		      lda	MenCurrent
    771  2ad2		       29 0f		      and	#$0f
    772  2ad4		       a8		      tay
    773  2ad5		       b9 00 f0 	      lda	DigitVectorLOr,y
    774  2ad8		       8d b6 f5 	      sta	SMMEN+1+RAM_WRITE
    775  2adb
    776  2adb							; modify player number pointer (Xp XX XX)
    777  2adb
    778  2adb		       a4 9e		      ldy	whichPlayer
    779  2add		       b9 01 f0 	      lda	DigitVectorLOr+1,y
    780  2ae0		       8d ae f5 	      sta	SMPLAYER+1+RAM_WRITE
    781  2ae3
    782  2ae3							; fall through
    783  2ae3
    784  2ae3							;    ;---------------------------------------------------------------------------
    785  2ae3
    786  2ae3							; modify cave character pointer (XX XX cX)
    787  2ae3
    788  2ae3		       a2 e8		      ldx	#<IntermissionL-1
    789  2ae5		       a5 b2		      lda	caveDisplay
    790  2ae7		       c9 80		      cmp	#$80
    791  2ae9		       29 1f		      and	#$1f
    792  2aeb		       a8		      tay
    793  2aec		       b0 05		      bcs	.intermission
    794  2aee		       be 27 f0 	      ldx	CharVectorLO,y
    795  2af1		       a4 b1		      ldy	level
    796  2af3				   .intermission
    797  2af3		       8e be f5 	      stx	SMCAVE+1+RAM_WRITE
    798  2af6
    799  2af6							; modify level number pointer (XX XX Xl)
    800  2af6
    801  2af6		       b9 01 f0 	      lda	DigitVectorLOr+1,y
    802  2af9		       8d c7 f5 	      sta	SMLEVEL+1+RAM_WRITE
    803  2afc
    804  2afc							;---------------------------------------------------------------------------
    805  2afc
    806  2afc		       20 02 f3 	      jsr	SetupDiamondsPtr	; modify required diamonds pointers
    807  2aff		       4c 34 f3 	      jmp	SetupTimePtr	; modify time pointers
    808  2b02
    809  2b02							;------------------------------------------------------------------------------
    810  2b02							;    DEFINE_SUBROUTINE SetupGameOverPtr
    811  2b02
    812  2b02							;		  ldy #8-1
    813  2b02							;.loopGameOver:
    814  2b02							;		  ldx SMGameOverOfs,y
    815  2b02							;		  lda SMGameOverPtr,y
    816  2b02							;		  sta SM_BASE+1+RAM_WRITE,x
    817  2b02							;		  dey
    818  2b02							;		  bpl .loopGameOver
    819  2b02
    820  2b02							;		  rts
    821  2b02
    822  2b02							;SMGameOverOfs:
    823  2b02							;		  .byte <SM_Diamond3-SM_BASE, <SM_Diamond2-SM_BASE
    824  2b02							;		  .byte <SM_Diamond1-SM_BASE, <SM_Diamond0-SM_BASE
    825  2b02							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    826  2b02							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    827  2b02							;SMGameOverPtr:
    828  2b02							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    829  2b02							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    830  2b02
    831  2b02							;------------------------------------------------------------------------------
      0  2b02					      DEFINE_SUBROUTINE	GetDiamond
      1  2b02		       00 05	   BANK_GetDiamond =	_CURRENT_BANK
      2  2b02					      SUBROUTINE
      3  2b02				   GetDiamond
    833  2b02
    834  2b02							;sok jsr UpdateScore		      ;looong!
    835  2b02
    836  2b02							;------------------------------------------------------------------------------
      0  2b02					      DEFINE_SUBROUTINE	SetupDiamondsPtr
      1  2b02		       00 05	   BANK_SetupDiamondsPtr =	_CURRENT_BANK
      2  2b02					      SUBROUTINE
      3  2b02				   SetupDiamondsPtr
    838  2b02							; Show current diamond counter in the top left
    839  2b02
    840  2b02		       a0 00		      ldy	#SM_OFS_DIAMONDS
    841  2b04		       a5 b6		      lda	diamondsNeeded
    842  2b06		       20 3d f3 	      jsr	SetupBCDPtr
    843  2b09
    844  2b09		       a9 b0		      lda	#ID_DIAMOND<<4	; if no extra diamonds, display the normal icon
    845  2b0b		       24 c8		      bit	scoringFlags	;
    846  2b0d		       10 2e		      bpl	SetupBCDPtr
    847  2b0f		       a9 c0		      lda	#ID_EXTRA<<4	; otherwise, display the extra icon
    848  2b11		       50 2a		      bvc	SetupBCDPtr
    849  2b13		       09 01		      ora	#1	; display 1xx diamonds
    850  2b15		       d0 26		      bne	SetupBCDPtr	; unconditional
    851  2b17
    852  2b17							;------------------------------------------------------------------------------
      0  2b17					      DEFINE_SUBROUTINE	DrawTime
      1  2b17		       00 05	   BANK_DrawTime =	_CURRENT_BANK
      2  2b17					      SUBROUTINE
      3  2b17				   DrawTime
    854  2b17
    855  2b17							; mid-digit-change, but we may be required to flash/display
    856  2b17		       a0 02		      ldy	#SM_OFS_TIME
    857  2b19		       a5 ba		      lda	caveTimeHi
    858  2b1b		       d0 17		      bne	BGOK
    859  2b1d		       a5 b9		      lda	caveTime
    860  2b1f		       c9 0a		      cmp	#RED_TIME_WARNING
    861  2b21		       b0 11		      bcs	BGOK
    862  2b23		       a5 bb		      lda	caveTimeFrac
    863  2b25		       69 20		      adc	#$20
    864  2b27		       29 60		      and	#$60	; 75% on, 25% off
    865  2b29		       d0 09		      bne	BGOK
    866  2b2b
    867  2b2b		       a9 aa		      lda	#ID_BLANK<<4|ID_BLANK
    868  2b2d		       20 3d f3 	      jsr	SetupBCDPtr
    869  2b30		       a9 da		      lda	#ID_CLOCK<<4|ID_BLANK
    870  2b32		       d0 09		      bne	SetupBCDPtr	; ASSUMES ID_BLANK != 0
    871  2b34				   BGOK
    872  2b34							;------------------------------------------------------------------------------
      0  2b34					      DEFINE_SUBROUTINE	SetupTimePtr
      1  2b34		       00 05	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  2b34					      SUBROUTINE
      3  2b34				   SetupTimePtr
    874  2b34
    875  2b34		       a5 b9		      lda	caveTime
    876  2b36		       20 3d f3 	      jsr	SetupBCDPtr
    877  2b39		       a5 ba		      lda	caveTime+1
    878  2b3b		       09 d0		      ora	#ID_CLOCK<<4
    879  2b3d
    880  2b3d							; fall through
    881  2b3d
    882  2b3d							;------------------------------------------------------------------------------
      0  2b3d					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  2b3d		       00 05	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  2b3d					      SUBROUTINE
      3  2b3d				   SetupBCDPtr
    884  2b3d
    885  2b3d							; a = BCD value
    886  2b3d							; y = SM table offset
    887  2b3d
    888  2b3d		       48		      pha
    889  2b3e		       29 0f		      and	#$0f
    890  2b40		       aa		      tax
    891  2b41		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    892  2b44		       be 19 f0 	      ldx	SMTblLSB,y
    893  2b47		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    894  2b4a		       68		      pla
    895  2b4b		       4a		      lsr
    896  2b4c		       4a		      lsr
    897  2b4d		       4a		      lsr
    898  2b4e		       4a		      lsr
    899  2b4f		       aa		      tax
    900  2b50		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    901  2b53		       be 20 f0 	      ldx	SMTblMSB,y
    902  2b56		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    903  2b59
    904  2b59		       c8		      iny
    905  2b5a
    906  2b5a		       a5 c3		      lda	ROM_Bank
    907  2b5c				   RTS
    908  2b5c		       60		      rts
    909  2b5d
      0  2b5d					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
     10  2b5d					      LIST	ON
    911  2b5d
    912  2b5d				  -	      IF	<. = 0
    913  2b5d				  -	      .byte	0	; required!
    914  2b5d					      ENDIF
    915  2b5d
    916  2b5d				   BLANKR
    917  2b5d		       00 00 00 00*	      .ds	DIGIT_H, 0
    918  2b64
    919  2b64				   DequalsR
    920  2b64		       10		      .byte.b	%00010000
    921  2b65		       28		      .byte.b	%00101000
    922  2b66		       44		      .byte.b	%01000100
    923  2b67		       82		      .byte.b	%10000010
    924  2b68		       44		      .byte.b	%01000100
    925  2b69		       28		      .byte.b	%00101000
    926  2b6a							;    .byte %00010000
    927  2b6a				   DplusR
    928  2b6a		       10		      .byte.b	%00010000
    929  2b6b		       28		      .byte.b	%00101000
    930  2b6c		       6c		      .byte.b	%01101100
    931  2b6d		       c6		      .byte.b	%11000110
    932  2b6e		       6c		      .byte.b	%01101100
    933  2b6f		       28		      .byte.b	%00101000
    934  2b70		       10		      .byte.b	%00010000
    935  2b71
    936  2b71				   ClockR
    937  2b71		       38		      .byte.b	%00111000
    938  2b72		       44		      .byte.b	%01000100
    939  2b73		       a2		      .byte.b	%10100010
    940  2b74		       92		      .byte.b	%10010010
    941  2b75		       92		      .byte.b	%10010010
    942  2b76		       54		      .byte.b	%01010100
    943  2b77							;	  .byte %00111000
    944  2b77				   NineR
    945  2b77		       38		      .byte.b	%00111000
    946  2b78		       1c		      .byte.b	%00011100
    947  2b79		       0e		      .byte.b	%00001110
    948  2b7a		       3f		      .byte.b	%00111111
    949  2b7b		       73		      .byte.b	%01110011
    950  2b7c		       73		      .byte.b	%01110011
    951  2b7d							;	  .byte %00111110
    952  2b7d				   SixR
    953  2b7d		       3e		      .byte.b	%00111110
    954  2b7e		       7f		      .byte.b	%01111111
    955  2b7f		       73		      .byte.b	%01110011
    956  2b80		       73		      .byte.b	%01110011
    957  2b81		       7e		      .byte.b	%01111110
    958  2b82		       70		      .byte.b	%01110000
    959  2b83							;	  .byte %00111110
    960  2b83				   EightR
    961  2b83		       3e		      .byte.b	%00111110
    962  2b84		       7f		      .byte.b	%01111111
    963  2b85		       73		      .byte.b	%01110011
    964  2b86		       73		      .byte.b	%01110011
    965  2b87		       3e		      .byte.b	%00111110
    966  2b88		       73		      .byte.b	%01110011
    967  2b89							;	  .byte %00111110
    968  2b89				   ZeroR
    969  2b89		       3e		      .byte.b	%00111110
    970  2b8a		       7f		      .byte.b	%01111111
    971  2b8b		       73		      .byte.b	%01110011
    972  2b8c		       73		      .byte.b	%01110011
    973  2b8d		       73		      .byte.b	%01110011
    974  2b8e		       73		      .byte.b	%01110011
    975  2b8f							;	  .byte %00111110
    976  2b8f				   ThreeR
    977  2b8f		       3e		      .byte.b	%00111110
    978  2b90		       7f		      .byte.b	%01111111
    979  2b91		       73		      .byte.b	%01110011
    980  2b92		       06		      .byte.b	%00000110
    981  2b93		       0c		      .byte.b	%00001100
    982  2b94		       06		      .byte.b	%00000110
    983  2b95							;	  .byte %00111111
    984  2b95				   OneR
    985  2b95		       3f		      .byte.b	%00111111
    986  2b96		       3f		      .byte.b	%00111111
    987  2b97		       0c		      .byte.b	%00001100
    988  2b98		       0c		      .byte.b	%00001100
    989  2b99		       1c		      .byte.b	%00011100
    990  2b9a		       1c		      .byte.b	%00011100
    991  2b9b		       0c		      .byte.b	%00001100
    992  2b9c
    993  2b9c				   SevenR
    994  2b9c		       70		      .byte.b	%01110000
    995  2b9d		       70		      .byte.b	%01110000
    996  2b9e		       38		      .byte.b	%00111000
    997  2b9f		       1c		      .byte.b	%00011100
    998  2ba0		       0e		      .byte.b	%00001110
    999  2ba1		       43		      .byte.b	%01000011
   1000  2ba2							;	  .byte %01111111
   1001  2ba2				   TwoR
   1002  2ba2		       7f		      .byte.b	%01111111
   1003  2ba3		       7f		      .byte.b	%01111111
   1004  2ba4		       38		      .byte.b	%00111000
   1005  2ba5		       1c		      .byte.b	%00011100
   1006  2ba6		       0e		      .byte.b	%00001110
   1007  2ba7		       67		      .byte.b	%01100111
   1008  2ba8							;	  .byte %00111110
   1009  2ba8				   FiveR
   1010  2ba8		       3e		      .byte.b	%00111110
   1011  2ba9		       7f		      .byte.b	%01111111
   1012  2baa		       77		      .byte.b	%01110111
   1013  2bab		       07		      .byte.b	%00000111
   1014  2bac		       7e		      .byte.b	%01111110
   1015  2bad		       70		      .byte.b	%01110000
   1016  2bae		       7f		      .byte.b	%01111111
   1017  2baf				   FourR
   1018  2baf		       0e		      .byte.b	%00001110
   1019  2bb0		       0e		      .byte.b	%00001110
   1020  2bb1		       0e		      .byte.b	%00001110
   1021  2bb2		       7f		      .byte.b	%01111111
   1022  2bb3		       6e		      .byte.b	%01101110
   1023  2bb4		       60		      .byte.b	%01100000
   1024  2bb5		       60		      .byte.b	%01100000
   1025  2bb6
   1026  2bb6							;CharAL:
   1027  2bb6							;    .byte %11100110
   1028  2bb6							;    .byte %11100110
   1029  2bb6							;    .byte %11111110
   1030  2bb6							;    .byte %11100110
   1031  2bb6							;    .byte %11100110
   1032  2bb6							;    .byte %01111100
   1033  2bb6							;    .byte %00111000
   1034  2bb6							;CharEL:
   1035  2bb6							;    .byte %11111110
   1036  2bb6							;    .byte %11111110
   1037  2bb6							;    .byte %11100000
   1038  2bb6							;    .byte %11100000
   1039  2bb6							;    .byte %11111100
   1040  2bb6							;    .byte %11100000
   1041  2bb6							;    .byte %11111110
   1042  2bb6							;CharRL:
   1043  2bb6							;    .byte %11100110
   1044  2bb6							;    .byte %11100110
   1045  2bb6							;    .byte %11111100
   1046  2bb6							;    .byte %11111100
   1047  2bb6							;    .byte %11100110
   1048  2bb6							;    .byte %11100110
   1049  2bb6							;    .byte %11111100
   1050  2bb6							;CharVL:
   1051  2bb6							;    .byte %00111000
   1052  2bb6							;    .byte %01111100
   1053  2bb6							;    .byte %11100110
   1054  2bb6							;    .byte %11100110
   1055  2bb6							;    .byte %11100110
   1056  2bb6							;    .byte %11100110
   1057  2bb6							;    .byte %11100110
   1058  2bb6
      0  2bb6					      CHECKPAGE	BLANKR
      8  2bb6					      LIST	ON
   1060  2bb6
   1061  2bb6							;---------------------------------------------------------------------------
   1062  2bb6
      0  2bb6					      DEFINE_SUBROUTINE	GameInitialise
      1  2bb6		       00 05	   BANK_GameInitialise =	_CURRENT_BANK
      2  2bb6					      SUBROUTINE
      3  2bb6				   GameInitialise
   1064  2bb6
   1065  2bb6							; copy loaded SK high score into scoring RAM:
   1066  2bb6		       a2 02		      ldx	#3-1
   1067  2bb8				   .loopCopyHighScore
   1068  2bb8		       b5 e2		      lda	highScoreSK,x
   1069  2bba		       c9 ff		      cmp	#$ff
   1070  2bbc		       f0 06		      beq	.noSaveKey
   1071  2bbe		       9d eb f7 	      sta	HighScore+RAM_WRITE,x
   1072  2bc1		       ca		      dex
   1073  2bc2		       10 f4		      bpl	.loopCopyHighScore
   1074  2bc4				   .noSaveKey
   1075  2bc4
   1076  2bc4							; clear both players scores
   1077  2bc4		       a0 05		      ldy	#2*3-1
   1078  2bc6		       a9 00		      lda	#0
   1079  2bc8				   .loopClearScore
   1080  2bc8		       99 e1 f7 	      sta	ScoreCurrent+RAM_WRITE,y
   1081  2bcb		       88		      dey
   1082  2bcc		       10 fa		      bpl	.loopClearScore
   1083  2bce
   1084  2bce							; copy cave and level for other player and SaveKey:
   1085  2bce		       a5 b0		      lda	cave
   1086  2bd0		       8d e9 f7 	      sta	PlayerCave+RAM_WRITE
   1087  2bd3		       a5 e5		      lda	startCave
   1088  2bd5		       8d e4 f7 	      sta	StartCave+RAM_WRITE
   1089  2bd8		       a5 b1		      lda	level
   1090  2bda		       8d ea f7 	      sta	PlayerLevel+RAM_WRITE
   1091  2bdd		       8d e5 f7 	      sta	StartLevel+RAM_WRITE
   1092  2be0		       60		      rts
   1093  2be1
   1094  2be1							;---------------------------------------------------------------------------
   1095  2be1
   1096  2be1		       00 00 00    ScoreCurrent ds	3, 0
   1097  2be4							; start cave and level have to be after ScoreCurrent!
   1098  2be4		       00	   StartCave  .byte.b	0
   1099  2be5		       00	   StartLevel .byte.b	0
   1100  2be6		       00 00 00    PlayerScores ds	3, 0
   1101  2be9							; cave and level have to be consecutive variables!
   1102  2be9		       00	   PlayerCave .byte.b	0
   1103  2bea		       00	   PlayerLevel .byte.b	0
   1104  2beb		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1105  2bf0
   1106  2bf0
   1107  2bf0
   1108  2bf0							;------------------------------------------------------------------------------
   1109  2bf0
      0  2bf0					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  2bf0
      2  2bf0
      3  2bf0		       03 f0	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $3f0 , FREE= $10
      4  2bf0					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  2bf0				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  2bf0				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  2bf0				  -	      ERR
      8  2bf0					      endif
   1111  2bf0
   1112  2bf0							;------------------------------------------------------------------------------
   1113  2bf0
   1114  2bf0							; CAVE DATA banks can go anywhere - *EXCEPT* for the same bank as the cave
   1115  2bf0							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_CAVE_SIZE
   1116  2bf0							; which is used as a buffer size inside DecodeCave.  It's not important if
   1117  2bf0							; this is defined before or after, as once the caves have processed it will be
   1118  2bf0							; correct. Note, that caves should all be defined BEFORE *OR* AFTER the
   1119  2bf0							; DecodeCave code -- but that they should not be both, nor in the same bank.
   1120  2bf0
------- FILE CaveBank0.asm LEVEL 3 PASS 3
      0  2bf0					      include	"CaveBank0.asm"
      1  2bf0							; Cave definitions
      2  2bf0							; Sample cave definitions.
      3  2bf0							; Any cave can be in any bank.  System auto-calculates required bank buffer size in RAM.
      4  2bf0							; have as many banks as you like.  Add new banks in notBOXDash.asm.
      5  2bf0
      6  2bf0
      7  2bf0							;------------------------------------------------------------------------------
      8  2bf0							;##############################################################################
      9  2bf0							;------------------------------------------------------------------------------
     10  2bf0
     11  2bf0				  -	      IF	0	;{
     12  2bf0				  -			;IF DEMO_VERSION = NO && FINAL_VERSION = NO
     13  2bf0				  -	      START_CAVE	SELECTION_SCREEN
     14  2bf0				  -
     15  2bf0				  -
     16  2bf0				  -	      .byte	0	; cave 0 -- selection screen
     17  2bf0				  -	      CAVE_SIZE	10, SCREEN_LINES	; width, height
     18  2bf0				  -	      .byte	$14	; Magic wall/amoeba slow growth for: 20 seconds
     19  2bf0				  -	      .byte	$10	;BCD'd $0A			    ; Diamonds worth: 10 points
     20  2bf0				  -	      .byte	$15	;BCD'd $0F			    ; Extra diamonds worth: 15 points
     21  2bf0				  -	      CAVE_RANDOM	$0,0,0,0,0	; Randomiser seed values for difficulty levels 1-5
     22  2bf0				  -	      .byte	$0C, $0C, $0C, $0C, $0C	; Diamonds needed: 12, 12, 12, 12, 12 (for difficulty levels 1-5)
     23  2bf0				  -	      .byte	$FF,0,0,0,0	; cave time
     24  2bf0				  -	      .byte	$a6, $96	; NTSC/PAL
     25  2bf0				  -	      .byte	$36, $46	; NTSC/PAL
     26  2bf0				  -	      .byte	$0e, $0e	; NTSC/PAL
     27  2bf0				  -	      .byte	$00, $00, $00, $00	; Random objects:
     28  2bf0				  -	      .byte	$00, $00, $00, $00	;   SPACE / BOXS/ DIAMONDS / unused
     29  2bf0				  -
     30  2bf0				  -
     31  2bf0				  -			;.byte   FILL+CHARACTER_BOX, $01, $03, 38,6, $00
     32  2bf0				  -	      STOCH	CHARACTER_MANOCCUPIED, $03, $04	; StoreChar zPRFd1 at ( 3, 4)
     33  2bf0				  -	      STOCH	CHARACTER_EXPLOSION3, 1,3	; special selector creature (overload explosion character)
     34  2bf0				  -	      END_CAVE	SELECTION_SCREEN
     35  2bf0					      ENDIF		;}
     36  2bf0
     37  2bf0							;------------------------------------------------------------------------------
     38  2bf0
     39  2bf0					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2bf0					      START_CAVE	INTRO
      1  2bf0				   CAVE_START SET	*
      2  2bf0		       00 05	   BANK_CAVE_INTRO =	_CURRENT_BANK
      3  2bf0				   CAVE_INTRO SUBROUTINE
      4  2bf0				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2bf0
     41  2bf0
     42  2bf0		       01		      .byte.b	$01	; Cave 01 A
      0  2bf1					      CAVE_SIZE_ROOM		; width, height
      0  2bf1					      CAVE_SIZE	40, 22
      1  2bf1		       28 16		      .byte.b	40,22
     44  2bf3		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
     45  2bf4		       10		      .byte.b	$10	;BCD'd $0A				    ; Diamonds worth: 10 points
     46  2bf5		       15		      .byte.b	$15	;BCD'd $0F				    ; Extra diamonds worth: 15 points
      0  2bf6					      CAVE_RANDOM	$2A, $0B, $0C, $0D, $0E	; Randomiser seed values for difficulty levels 1-5
      1  2bf6		       2a 0b 0c 0d*	      .byte.b	$2A,$0B,$0C,$0D,$0E
     48  2bfb
     49  2bfb		       0c 0c 0c 0c*	      .byte.b	$0C, $0C, $0C, $0C, $0C	; Diamonds needed: 12, 12, 12, 12, 12 (for difficulty levels 1-5)
     50  2c00
     51  2c00		       96 6e 46 28*	      .byte.b	$96, $6E, $46, $28, $1E	; Cave time
     52  2c05
     53  2c05							; z26 palette/z26 palette:
     54  2c05							;    .byte   $a8, $96				  ; NTSC/PAL
     55  2c05							;    .byte   $36, $46				  ; NTSC/PAL
     56  2c05							;    .byte   $0e, $0e				  ; NTSC/PAL
     57  2c05							; z26 palette/TJ's PAL TV palette:
     58  2c05
     59  2c05
     60  2c05							;-------------------------------------------------------------------------------------
     61  2c05							; PALETTE DEFINITIONS
     62  2c05
     63  2c05		       18 66		      .byte.b	$18, $66
     64  2c07		       30 a0		      .byte.b	$30, $a0
     65  2c09		       0e 9c		      .byte.b	$0e, $9C
     66  2c0b							;-------------------------------------------------------------------------------------
     67  2c0b
     68  2c0b		       00		      .byte.b	CHARACTER_BLANK	; Random objects:
     69  2c0c		       02		      .byte.b	CHARACTER_BOX
     70  2c0d		       04		      .byte.b	CHARACTER_DIAMOND
     71  2c0e		       00		      .byte.b	CHARACTER_BLANK
     72  2c0f		       3c 32 09 00	      .byte.b	$3C, $32, $09, $00	;   zSpace :  60/256 = 23-19-3%
     73  2c13							;   zBouS  :  50/256 = 19-3%
     74  2c13							;   zDiaS  :	9/256 =  3%
     75  2c13							;   fourth code unused (0%)
     76  2c13
     77  2c13		       00 05	   BASEX      =	5
     78  2c13		       00 09	   BASEY      =	9
     79  2c13
     80  2c13
     81  2c13
     82  2c13					      if	1
     83  2c13
     84  2c13		       40 0a 0a 03*	      .byte.b	LINE+CHARACTER_BLANK, BASEX+5, BASEY+1, 3, 2
     85  2c18		       40 0a 0b 03*	      .byte.b	LINE+CHARACTER_BLANK, BASEX+5, BASEY+2, 3, 2
     86  2c1d		       40 0a 0c 03*	      .byte.b	LINE+CHARACTER_BLANK, BASEX+5, BASEY+3, 3, 2
     87  2c22		       40 08 0d 06*	      .byte.b	LINE+CHARACTER_BLANK, BASEX+3, BASEY+4, 6, 2
     88  2c27		       40 08 0e 06*	      .byte.b	LINE+CHARACTER_BLANK, BASEX+3, BASEY+5, 6, 2
     89  2c2c		       40 06 0f 0f*	      .byte.b	LINE+CHARACTER_BLANK, BASEX+1, BASEY+6, 15, 2
     90  2c31		       40 06 10 0f*	      .byte.b	LINE+CHARACTER_BLANK, BASEX+1, BASEY+7, 15, 2
     91  2c36		       40 06 11 0f*	      .byte.b	LINE+CHARACTER_BLANK, BASEX+1, BASEY+8, 15, 2
     92  2c3b		       40 0a 12 05*	      .byte.b	LINE+CHARACTER_BLANK, BASEX+5, BASEY+9, 5, 2
     93  2c40
     94  2c40
     95  2c40		       4f 09 09 05*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+4, BASEY+0, 5, 2
     96  2c45		       4f 09 09 04*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+4, BASEY+0, 4, 4
     97  2c4a		       4f 07 0c 03*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+2, BASEY+3, 3, 2
     98  2c4f		       4f 07 0c 03*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+2, BASEY+3, 3, 4
     99  2c54		       4f 05 0e 03*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+0, BASEY+5, 3, 2
    100  2c59		       4f 05 0e 04*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+0, BASEY+5, 4, 4
    101  2c5e		       4f 05 11 05*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+0, BASEY+8, 5, 2
    102  2c63		       4f 09 11 03*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+4, BASEY+8, 3, 4
    103  2c68		       4f 09 13 07*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+4, BASEY+10, 7, 2
    104  2c6d		       4f 0f 11 03*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+10, BASEY+8, 3, 4
    105  2c72		       4f 0f 12 09*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+10, BASEY+9, 9, 2
    106  2c77		       4f 11 11 02*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+12, BASEY+8, 2, 2
    107  2c7c		       4f 0b 11 03*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+6, BASEY+8, 3, 2
    108  2c81		       4f 17 0e 05*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+18, BASEY+5, 5, 4
    109  2c86		       4f 12 0e 06*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+13, BASEY+5, 6, 2
    110  2c8b		       4f 0e 0f 05*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+9, BASEY+6, 5, 2
    111  2c90		       4f 0e 0c 04*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+9, BASEY+3, 4, 4
    112  2c95		       4f 0d 09 04*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+8, BASEY+0, 4, 4
    113  2c9a		       4f 09 0e 02*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+4, BASEY+5, 2, 4
    114  2c9f		       4f 0b 0e 02*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+6, BASEY+5, 2, 4
    115  2ca4		       4f 0c 0e 02*	      .byte.b	LINE+CHARACTER_STEEL, BASEX+7, BASEY+5, 2, 4
    116  2ca9
      0  2ca9					      STOCH	CHARACTER_MANOCCUPIED, BASEX+11, BASEY+8	; StoreChar zPRFd1 at ( 3, 4)
      1  2ca9		       06 10 11 	      .byte.b	CHARACTER_MANOCCUPIED,BASEX+11,BASEY+8
    118  2cac
      0  2cac					      STOCH	CHARACTER_BOX, BASEX+5, BASEY+2
      1  2cac		       02 0a 0b 	      .byte.b	CHARACTER_BOX,BASEX+5,BASEY+2
      0  2caf					      STOCH	CHARACTER_BOX, BASEX+7, BASEY+3
      1  2caf		       02 0c 0c 	      .byte.b	CHARACTER_BOX,BASEX+7,BASEY+3
      0  2cb2					      STOCH	CHARACTER_BOX, BASEX+5, BASEY+4
      1  2cb2		       02 0a 0d 	      .byte.b	CHARACTER_BOX,BASEX+5,BASEY+4
      0  2cb5					      STOCH	CHARACTER_BOX, BASEX+7, BASEY+4
      1  2cb5		       02 0c 0d 	      .byte.b	CHARACTER_BOX,BASEX+7,BASEY+4
      0  2cb8					      STOCH	CHARACTER_BOX, BASEX+2, BASEY+7
      1  2cb8		       02 07 10 	      .byte.b	CHARACTER_BOX,BASEX+2,BASEY+7
      0  2cbb					      STOCH	CHARACTER_BOX, BASEX+5, BASEY+7
      1  2cbb		       02 0a 10 	      .byte.b	CHARACTER_BOX,BASEX+5,BASEY+7
    125  2cbe
      0  2cbe					      STOCH	CHARACTER_DIAMOND, BASEX+16, BASEY+6
      1  2cbe		       04 15 0f 	      .byte.b	CHARACTER_DIAMOND,BASEX+16,BASEY+6
      0  2cc1					      STOCH	CHARACTER_DIAMOND, BASEX+17, BASEY+6
      1  2cc1		       04 16 0f 	      .byte.b	CHARACTER_DIAMOND,BASEX+17,BASEY+6
      0  2cc4					      STOCH	CHARACTER_DIAMOND, BASEX+16, BASEY+7
      1  2cc4		       04 15 10 	      .byte.b	CHARACTER_DIAMOND,BASEX+16,BASEY+7
      0  2cc7					      STOCH	CHARACTER_DIAMOND, BASEX+17, BASEY+7
      1  2cc7		       04 16 10 	      .byte.b	CHARACTER_DIAMOND,BASEX+17,BASEY+7
      0  2cca					      STOCH	CHARACTER_DIAMOND, BASEX+16, BASEY+8
      1  2cca		       04 15 11 	      .byte.b	CHARACTER_DIAMOND,BASEX+16,BASEY+8
      0  2ccd					      STOCH	CHARACTER_DIAMOND, BASEX+17, BASEY+8
      1  2ccd		       04 16 11 	      .byte.b	CHARACTER_DIAMOND,BASEX+17,BASEY+8
    132  2cd0
    133  2cd0					      endif
    134  2cd0
    135  2cd0				  -	      if	0
    136  2cd0				  -	      .byte	LINE+CHARACTER_BLANK, BASEX+1, BASEY+1, 8, $02	; Line of zBrick from ( 1, 9); length = 30; direction = right
    137  2cd0				  -	      .byte	LINE+CHARACTER_BLANK, BASEX+1, BASEY+2, 8, $02	; Line of zBrick from ( 1, 9); length = 30; direction = right
    138  2cd0				  -	      .byte	LINE+CHARACTER_BLANK, BASEX+1, BASEY+3, 8, $02	; Line of zBrick from ( 1, 9); length = 30; direction = right
    139  2cd0				  -	      .byte	LINE+CHARACTER_BLANK, BASEX+1, BASEY+4, 8, $02	; Line of zBrick from ( 1, 9); length = 30; direction = right
    140  2cd0				  -	      .byte	LINE+CHARACTER_BLANK, BASEX+1, BASEY+5, 8, $02	; Line of zBrick from ( 1, 9); length = 30; direction = right
    141  2cd0				  -
    142  2cd0				  -
    143  2cd0				  -
    144  2cd0				  -	      .byte	LINE+CHARACTER_STEEL, BASEX+$01, BASEY+0, 7, $02	; Line of zBrick from ( 1, 9); length = 30; direction = right
    145  2cd0				  -	      .byte	LINE+CHARACTER_STEEL, BASEX+$01, BASEY+1, 2, 4	; Line of zBrick from ( 1, 9); length = 30; direction = down
    146  2cd0				  -	      .byte	LINE+CHARACTER_STEEL, BASEX+3, BASEY+2, 3, 2	; Line of zBrick from ( 1, 9); length = 30; direction = down
    147  2cd0				  -	      .byte	LINE+CHARACTER_STEEL, BASEX+4, BASEY+4, 2, 4	; Line of zBrick from ( 1, 9); length = 30; direction = down
    148  2cd0				  -	      .byte	LINE+CHARACTER_STEEL, BASEX+0, BASEY+2, 4, 4	; Line of zBrick from ( 1, 9); length = 30; direction = down
    149  2cd0				  -	      .byte	LINE+CHARACTER_STEEL, BASEX+1, BASEY+5, 1, 4	; Line of zBrick from ( 1, 9); length = 30; direction = down
    150  2cd0				  -	      .byte	LINE+CHARACTER_STEEL, BASEX+1, BASEY+6, 8, 2	; Line of zBrick from ( 1, 9); length = 30; direction = down
    151  2cd0				  -	      .byte	LINE+CHARACTER_STEEL, BASEX+8, BASEY+4, 2, 4	; Line of zBrick from ( 1, 9); length = 30; direction = down
    152  2cd0				  -	      .byte	LINE+CHARACTER_STEEL, BASEX+7, BASEY+1, 2,2	; Line of zBrick from ( 1, 9); length = 30; direction = down
    153  2cd0				  -	      .byte	LINE+CHARACTER_STEEL, BASEX+9, BASEY+1, 4,4	; Line of zBrick from ( 1, 9); length = 30; direction = down
    154  2cd0				  -
    155  2cd0				  -	      .byte	LINE+CHARACTER_DIAMOND, BASEX+2, BASEY+4, 2,2	; Line of zBrick from ( 1, 9); length = 30; direction = down
    156  2cd0				  -	      .byte	LINE+CHARACTER_DIAMOND, BASEX+2, BASEY+5, 2,2	; Line of zBrick from ( 1, 9); length = 30; direction = down
    157  2cd0				  -
    158  2cd0				  -			;.byte   LINE+CHARACTER_WALL, $01, $09, $1E, $02    ; Line of zBrick from ( 1, 9); length = 30; direction = right
    159  2cd0				  -			;.byte   LINE+CHARACTER_WALL, $09, $10, $1E, $02    ; Line of zBrick from ( 9,16); length = 30; direction = right
    160  2cd0				  -	      STOCH	CHARACTER_MANOCCUPIED, BASEX+02, BASEY+3	; StoreChar zPRFd1 at ( 3, 4)
    161  2cd0				  -
    162  2cd0				  -	      STOCH	CHARACTER_BOX, BASEX+2, BASEY+2	; StoreChar zPRFd1 at ( 3, 4)
    163  2cd0				  -	      STOCH	CHARACTER_BOX, BASEX+4, BASEY+3	; StoreChar zPRFd1 at ( 3, 4)
    164  2cd0				  -	      STOCH	CHARACTER_BOX, BASEX+7, BASEY+3	; StoreChar zPRFd1 at ( 3, 4)
    165  2cd0				  -	      STOCH	CHARACTER_BOX, BASEX+6, BASEY+4	; StoreChar zPRFd1 at ( 3, 4)
    166  2cd0					      endif
    167  2cd0
      0  2cd0					      END_CAVE	INTRO
      1  2cd0		       ff		      .byte.b	$FF
      2  2cd0		       00 e1	   CAVE_SIZE_INTRO =	* - CAVE_START
      3  2cd1					      IF	CAVE_SIZE_INTRO > MAX_CAVE_SIZE
      4  2cd1				   MAX_CAVE_SIZE SET	CAVE_SIZE_INTRO
      5  2cd1					      ENDIF
    169  2cd1
    170  2cd1							;------------------------------------------------------------------------------
    171  2cd1
    172  2cd1					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
    173  2cd1
      0  2cd1					      START_CAVE	ROOMS
      1  2cd1				   CAVE_START SET	*
      2  2cd1		       00 05	   BANK_CAVE_ROOMS =	_CURRENT_BANK
      3  2cd1				   CAVE_ROOMS SUBROUTINE
      4  2cd1				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2cd1
      0  2cd1					      END_CAVE	ROOMS
      1  2cd1		       ff		      .byte.b	$FF
      2  2cd1		       00 01	   CAVE_SIZE_ROOMS =	* - CAVE_START
      3  2cd2				  -	      IF	CAVE_SIZE_ROOMS > MAX_CAVE_SIZE
      4  2cd2				  -MAX_CAVE_SIZE SET	CAVE_SIZE_ROOMS
      5  2cd2					      ENDIF
    176  2cd2					      ENDIF
    177  2cd2
    178  2cd2							;------------------------------------------------------------------------------
    179  2cd2
    180  2cd2					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2cd2					      START_CAVE	MAZE
      1  2cd2				   CAVE_START SET	*
      2  2cd2		       00 05	   BANK_CAVE_MAZE =	_CURRENT_BANK
      3  2cd2				   CAVE_MAZE  SUBROUTINE
      4  2cd2				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2cd2
      0  2cd2					      END_CAVE	MAZE
      1  2cd2		       ff		      .byte.b	$FF
      2  2cd2		       00 01	   CAVE_SIZE_MAZE =	* - CAVE_START
      3  2cd3				  -	      IF	CAVE_SIZE_MAZE > MAX_CAVE_SIZE
      4  2cd3				  -MAX_CAVE_SIZE SET	CAVE_SIZE_MAZE
      5  2cd3					      ENDIF
    183  2cd3					      ENDIF
    184  2cd3
    185  2cd3							;------------------------------------------------------------------------------
    186  2cd3
    187  2cd3					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2cd3					      START_CAVE	BUTTERFLIES
      1  2cd3				   CAVE_START SET	*
      2  2cd3		       00 05	   BANK_CAVE_BUTTERFLIES =	_CURRENT_BANK
      3  2cd3				   CAVE_BUTTERFLIES SUBROUTINE
      4  2cd3				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2cd3
    189  2cd3
    190  2cd3		       04		      .byte.b	$04	; Cave 04 D
      0  2cd4					      CAVE_SIZE_ROOM		; width, height
      0  2cd4					      CAVE_SIZE	40, 22
      1  2cd4		       28 16		      .byte.b	40,22
    192  2cd6		       14		      .byte.b	$14	; Magic wall/amoeba slow growth for: 20 seconds
    193  2cd7		       05		      .byte.b	$05	; Diamonds worth: 5 points
    194  2cd8		       20		      .byte.b	$20	;BCD'd $14				    ; Extra diamonds worth: 20 points
      0  2cd9					      CAVE_RANDOM	$00, $6E, $70, $73, $77	; Randomiser seed values for difficulty levels 1-5
      1  2cd9		       00 6e 70 73*	      .byte.b	$00,$6E,$70,$73,$77
    196  2cde		       24 24 24 24*	      .byte.b	$24, $24, $24, $24, $24	; Diamonds needed: 36, 36, 36, 36, 36 (for difficulty levels 1-5)
    197  2ce3		       78 64 50 3c*	      .byte.b	$78, $64, $50, $3C, $32	; Cave time: 120, 100, 80, 60, 50 seconds
    198  2ce8
    199  2ce8							;; z26 palette/z26 palette:
    200  2ce8							;    .byte   $16, $26				  ; NTSC/PAL
    201  2ce8							;    .byte   $54, $84				  ; NTSC/PAL
    202  2ce8							;    .byte   $ae, $7e				  ; NTSC/PAL
    203  2ce8							; z26 palette/TJ's PAL TV palette:
    204  2ce8
    205  2ce8							;-------------------------------------------------------------------------------------
    206  2ce8							; PALETTE DEFINITIONS
    207  2ce8
    208  2ce8				  -	      IF	FINAL_VERSION || ![TJ_MODE|AD_MODE]
    209  2ce8				  -	      .byte	$16, $26
    210  2ce8				  -	      .byte	$54, $86
    211  2ce8				  -	      .byte	$ae, $9e
    212  2ce8					      ELSE
    213  2ce8
    214  2ce8							; COMMENT FOLLOWING OUT IF NOT WANTED!
    215  2ce8							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    216  2ce8					      IF	AD_MODE
    217  2ce8		       16 26		      .byte.b	$16, $26
    218  2cea		       54 86		      .byte.b	$54, $86
    219  2cec		       ae 9e		      .byte.b	$ae, $9e
    220  2cee					      ENDIF
    221  2cee
    222  2cee							; COMMENT FOLLOWING OUT IF NOT WANTED!
    223  2cee							; OPTIONAL block -- if it's not here, then the FINAL_VERSION is used
    224  2cee				  -	      IF	TJ_MODE
    225  2cee				  -	      .byte	$16, $26
    226  2cee				  -	      .byte	$54, $86
    227  2cee				  -	      .byte	$ae, $9e
    228  2cee					      ENDIF
    229  2cee
    230  2cee					      ENDIF
    231  2cee
    232  2cee							;-------------------------------------------------------------------------------------
    233  2cee
    234  2cee
    235  2cee		       02		      .byte.b	CHARACTER_BOX	; Random objects:
    236  2cef		       00		      .byte.b	CHARACTER_BLANK
    237  2cf0		       00		      .byte.b	CHARACTER_BLANK
    238  2cf1		       00		      .byte.b	CHARACTER_BLANK
    239  2cf2		       14 00 00 00	      .byte.b	$14, $00, $00, $00	;   zBouS  :  20/256 =  7%
    240  2cf6
    241  2cf6		       06 01 03 	      .byte.b	CHARACTER_MANOCCUPIED, $01, $03	; StoreChar zPRFd1 at ( 1, 3)
    242  2cf9		       11 26 16 	      .byte.b	CHARACTER_EXITDOOR, $26, $16	; StoreChar zPreOut at (38,22)
    243  2cfc		       81 08 0a 04*	      .byte.b	FILL+CHARACTER_SOIL, $08, $0A, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from ( 8,10); length = 4; height = 4; fill = zSpace
    244  2d02		       07 0a 0b 	      .byte.b	CHARACTER_FLUTTERBY, $0A, $0B	; StoreChar zBFly1 at (10,11)
    245  2d05		       81 10 0a 04*	      .byte.b	FILL+CHARACTER_SOIL, $10, $0A, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (16,10); length = 4; height = 4; fill = zSpace
    246  2d0b		       07 12 0b 	      .byte.b	CHARACTER_FLUTTERBY, $12, $0B	; StoreChar zBFly1 at (18,11)
    247  2d0e		       81 18 0a 04*	      .byte.b	FILL+CHARACTER_SOIL, $18, $0A, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (24,10); length = 4; height = 4; fill = zSpace
    248  2d14		       07 1a 0b 	      .byte.b	CHARACTER_FLUTTERBY, $1A, $0B	; StoreChar zBFly1 at (26,11)
    249  2d17		       81 20 0a 04*	      .byte.b	FILL+CHARACTER_SOIL, $20, $0A, $04, $04, CHARACTER_BLANK	; FilledRect of zDirt from (32,10); length = 4; height = 4; fill = zSpace
    250  2d1d		       07 22 0b 	      .byte.b	CHARACTER_FLUTTERBY, $22, $0B	; StoreChar zBFly1 at (34,11)
      0  2d20					      END_CAVE	BUTTERFLIES
      1  2d20		       ff		      .byte.b	$FF
      2  2d20		       00 4e	   CAVE_SIZE_BUTTERFLIES =	* - CAVE_START
      3  2d21				  -	      IF	CAVE_SIZE_BUTTERFLIES > MAX_CAVE_SIZE
      4  2d21				  -MAX_CAVE_SIZE SET	CAVE_SIZE_BUTTERFLIES
      5  2d21					      ENDIF
    252  2d21					      ENDIF
    253  2d21
    254  2d21							; ECHO "MAX CAVE SIZE = ", MAX_CAVE_SIZE
------- FILE BANK_ROM_SHADOW_SCORING.asm
   1122  2d21
      0  2d21					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  2d21		       05 21	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $521 , FREE= $2df
      2  2d21					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2d21				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2d21				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2d21				  -	      ERR
      6  2d21					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 3
      0  2d21					      include	"BANK_GENERIC.asm"
      1  2d21							;------------------------------------------------------------------------------
      2  2d21							;##############################################################################
      3  2d21							;------------------------------------------------------------------------------
      4  2d21
      0  2d21					      NEWBANK	GENERIC_BANK_1
      1  3769 ????				      SEG	GENERIC_BANK_1
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	GENERIC_BANK_1
      6  3000
      7  3000
      8  3000
      0  3000					      DEFINE_1K_SEGMENT	DECODE_CAVE_SHADOW
      1  3000					      ALIGN	$400
      2  3000				   SEGMENT_DECODE_CAVE_SHADOW SET	*
      3  3000				   BANK_DECODE_CAVE_SHADOW SET	_CURRENT_BANK
------- FILE DecodeCave.asm LEVEL 3 PASS 3
      0  3000					      include	"DecodeCave.asm"
      1  3000							;TODOs:
      2  3000							;+ load cave from ROM
      3  3000							;- remove delimiter
      4  3000							;+ variable board sizes
      5  3000							;- use Andrew's character ids
      6  3000							;+ store other cave parameter (times, diamonds, points etc.)
      7  3000
      8  3000							;---------------------------------------------------------------------------
      9  3000							; Board area must not overlap page boundary, as writing code uses indexing to save
     10  3000
      0  3000					      OPTIONAL_PAGEBREAK	"BOARD_DATA_AREA", MAX_CAVE_SIZE
     10  3000					      LIST	ON
     12  3000				   BOARD_DATA_AREA
     13  3000		       ff ff ff ff*	      ds	MAX_CAVE_SIZE,$FF
     14  30e1
     15  30e1							;---------------------------------------------------------------------------
     16  30e1
     17  30e1				   ThrottleSpeedTbl
     18  30e1							; based on MAX_THROTTLE = 160, NTSC_276/PAL (312/276=1.13)
     19  30e1		       13 16		      .byte.b	19, 22	; level 1 (E1: 5.60s) 1,16; 1.00/1.00 (1.00)
     20  30e3		       16 1a		      .byte.b	22, 26	; level 2 (E2	4.80s) 1,18  1.16/1.18 (1.17)
     21  30e5		       18 1c		      .byte.b	24, 28	; level 3 (E3: 4.40s) 1,16  1.26/1.27 (1.27)
     22  30e7		       1a 1e		      .byte.b	26, 30	; level 4 (E4: 4.17s) 1,15  1.37/1.36 (1.34)
     23  30e9		       1b 1f		      .byte.b	27, 31	; level 5 (E5: 4.00s) 1,14; 1.42/1.41 (1.40)
     24  30eb
      0  30eb					      DEFINE_SUBROUTINE	DecodeCave
      1  30eb		       00 06	   BANK_DecodeCave =	_CURRENT_BANK
      2  30eb					      SUBROUTINE
      3  30eb				   DecodeCave
     26  30eb
     27  30eb							; *** local constants for cava data: ***
     28  30eb
     29  30eb		       00 04	   .NUM_RANDOM =	4	; number of random objects
     30  30eb
     31  30eb		       00 01	   .SIZE_OFS  =	1	; -1
     32  30eb		       00 03	   .MAGIC_OFS =	3
     33  30eb		       00 04	   .WORTH_OFS =	4
     34  30eb		       00 05	   .EXTRA_WORTH_OFS =	5
     35  30eb		       00 0b	   .DIAMONDS_OFS =	11
     36  30eb		       00 10	   .TIME_OFS  =	16
     37  30eb		       00 06	   .RND_INIT_OFS =	$04+2	; -1
     38  30eb		       00 1b	   .RND_OBJECT_OFS =	$18+3	; -3
     39  30eb		       00 1f	   .RND_VALUE_OFS =	$1c+3	; -3
     40  30eb		       00 15	   .COLOR_OFS =	$13+2
     41  30eb
     42  30eb		       00 23	   .STRUCT_OFFSET =	$20+3	; -3
     43  30eb		       00 ff	   .STRUCT_DELIMITER =	$ff
     44  30eb		       00 c0	   .STRUCTURE_MASK =	%11000000
     45  30eb
     46  30eb		       00 00	   .STRUCT_SINGLE =	%00 << 6
     47  30eb							;.STRUCT_LINE	      = LINE
     48  30eb							;.STRUCT_FILLED      = FILL
     49  30eb							;.STRUCT_RECTANGLE   = RECT
     50  30eb		       00 40	   .STRUCT_LINE =	%01 << 6
     51  30eb		       00 80	   .STRUCT_FILLED =	%10 << 6
     52  30eb		       00 c0	   .STRUCT_RECTANGLE =	%11 << 6
     53  30eb							;POINT 	      = .STRUCT_POINT
     54  30eb		       00 80	   FILL       =	.STRUCT_FILLED
     55  30eb		       00 40	   LINE       =	.STRUCT_LINE
     56  30eb		       00 c0	   RECT       =	.STRUCT_RECTANGLE
     57  30eb
     58  30eb		       00 00	   .DIR_UP    =	0
     59  30eb		       00 02	   .DIR_RIGHT =	2
     60  30eb		       00 04	   .DIR_DOWN  =	4
     61  30eb		       00 06	   .DIR_LEFT  =	6
     62  30eb
     63  30eb
     64  30eb		       85 c4		      sta	RAM_Bank
     65  30ed
     66  30ed							; Setup for NTSC/PAL based on P1 difficulty (0=NTSC, 1=PAL)
     67  30ed							; Set the throttle speed based on system.
     68  30ed
      0  30ed					      DEFINE_SUBROUTINE	PlatformSelect
      1  30ed		       00 06	   BANK_PlatformSelect =	_CURRENT_BANK
      2  30ed					      SUBROUTINE
      3  30ed				   PlatformSelect
     70  30ed
     71  30ed							; has to be done before decoding the cave to have the platform right:
      0  30ed					      SET_PLATFORM
      1  30ed
      2  30ed
      3  30ed
      4  30ed
      5  30ed		       ad 82 02 	      lda	SWCHB
      6  30f0		       2a		      rol
      7  30f1		       2a		      rol
      8  30f2		       2a		      rol
      9  30f3		       29 03		      and	#%11
     10  30f5					      if	NTSC_MODE = NO
     11  30f5		       49 02		      eor	#PAL
     12  30f7					      endif
     13  30f7		       85 81		      sta	Platform
     73  30f9
     74  30f9
     75  30f9							;------------------------------------------------------------------------------
     76  30f9							; Copy the ROM cave data into our local RAM cave data buffer.	Note that the
     77  30f9							; system is automatically setup so that the biggest cave will cause the available
     78  30f9							; buffer to increase during compile time.  So all we really need to do here is
     79  30f9							; copy the appropriate amount of data for the cave from ROM elsewhere, and then
     80  30f9							; let the system run just as it was before.
     81  30f9
     82  30f9							; Note that cave is an index to 4-byte entry table, so please use CAVE_NAMED_*
     83  30f9							; for cave reference numbers.
     84  30f9
     85  30f9							;		  sta RAM_Bank
     86  30f9
     87  30f9		       a5 c9		      lda	NextLevelTrigger
     88  30fb		       09 80		      ora	#BIT_NEXTLEVEL
     89  30fd		       85 c9		      sta	NextLevelTrigger
     90  30ff
     91  30ff
     92  30ff
     93  30ff		       a9 06		      lda	#BANK_DecodeCave	; the *ROM* bank of this routine (NOT RAM)
     94  3101		       85 c3		      sta	ROM_Bank	; GetROMByte returns to this bank
     95  3103
     96  3103		       a4 b0		      ldy	cave
     97  3105		       b9 a7 f3 	      lda	CaveInformation,y
     98  3108		       85 bf		      sta	Board_AddressR
     99  310a		       b9 a8 f3 	      lda	CaveInformation+1,y
    100  310d		       85 c0		      sta	Board_AddressR+1	; source of the board data (bank handled later)
    101  310f
    102  310f		       b9 aa f3 	      lda	CaveInformation+3,y	; size of the board data in bytes
    103  3112		       8d 3d f5 	      sta	SMLimit+RAM_WRITE+1	; might as well use self-modifying
    104  3115
    105  3115		       b9 ab f3 	      lda	CaveInformation+4,y
    106  3118		       85 b2		      sta	caveDisplay	; what to display as the cave ID.
    107  311a
    108  311a		       a2 00		      ldx	#0
    109  311c		       86 bb		      stx	caveTimeFrac	; now the 1st second is fully available
    110  311e		       86 cc		      stx	amoebaFlag
    111  3120		       86 df	   CopyBoardData stx	savex
    112  3122
    113  3122							; We are using GetROMByte to get *any* byte from ROM (although it was designed
    114  3122							; just to get a board-character).  Should be OK.
    115  3122
    116  3122		       a4 b0		      ldy	cave
    117  3124		       b9 a9 f3 	      lda	CaveInformation+2,y	; bank of the board data
    118  3127		       a0 00		      ldy	#0
    119  3129		       20 61 f8 	      jsr	GetROMByte	; note, this returns to ROM -- but that's a copy of us!!
    120  312c		       a4 c4		      ldy	RAM_Bank	; RAM bank we are *actually* running from
    121  312e		       84 3e		      sty	SET_BANK_RAM	; and switch 'ourself' back in.  Sneaky.
    122  3130
    123  3130		       a6 df		      ldx	savex
    124  3132		       9d 00 f4 	      sta	BOARD_DATA_AREA + RAM_WRITE,x	; save byte from ROM into our local RAM buffer
    125  3135
    126  3135		       e6 bf		      inc	Board_AddressR
    127  3137		       d0 02		      bne	NoPage
    128  3139		       e6 c0		      inc	Board_AddressR+1	; point to next byte of data
    129  313b				   NoPage
    130  313b
    131  313b		       e8		      inx
    132  313c		       e0 00	   SMLimit    cpx	#0	; byte count (self) modified by board size
    133  313e		       d0 e0		      bne	CopyBoardData
    134  3140
    135  3140
    136  3140							;------------------------------------------------------------------------------
    137  3140
    138  3140
    139  3140		       a9 00		      lda	#<BOARD_DATA_AREA
    140  3142		       85 df		      sta	ptrCave
    141  3144		       a9 f0		      lda	#>BOARD_DATA_AREA
    142  3146		       85 e0		      sta	ptrCave+1
    143  3148
    144  3148							; colors are organised in 3 NTSC/PAL pairs (medium mixcolor, dark color, bright mixcolor)
    145  3148		       a5 81		      lda	Platform
    146  314a		       c9 02		      cmp	#PAL
    147  314c		       a0 1a		      ldy	#.COLOR_OFS+5
    148  314e		       b0 01		      bcs	.originalPlatform
    149  3150		       88		      dey
    150  3151				   .originalPlatform
    151  3151		       a2 02		      ldx	#3-1
    152  3153				   .copyCols
    153  3153		       b1 df		      lda	(ptrCave),y
    154  3155		       95 bc		      sta	color,x
    155  3157		       88		      dey
    156  3158		       88		      dey
    157  3159		       ca		      dex
    158  315a		       10 f7		      bpl	.copyCols
    159  315c
    160  315c		       a0 01		      ldy	#.SIZE_OFS
    161  315e		       b1 df		      lda	(ptrCave),y
    162  3160		       85 98		      sta	BoardLimit_Width
    163  3162		       8d ea f7 	      sta	BoundingWall+RAM_WRITE+3
    164  3165		       c8		      iny
    165  3166		       b1 df		      lda	(ptrCave),y
    166  3168		       85 99		      sta	BoardLimit_Height
    167  316a		       8d eb f7 	      sta	BoundingWall+RAM_WRITE+4
    168  316d
    169  316d							;*** 1. load some cave data ***
    170  316d		       c8		      iny		;	     Y == 3 == .MAGIC_OFS
    171  316e		       b1 df		      lda	(ptrCave),y
    172  3170		       85 b5		      sta	magicAmoebaTime
    173  3172
    174  3172		       c8		      iny		;	     Y == 4 == .WORTH_OFS
    175  3173		       b1 df		      lda	(ptrCave),y
    176  3175							;jsr	  Convert2BCD
    177  3175		       85 b7		      sta	diamondsWorth	; now BCD in cave data
    178  3177
    179  3177		       a0 05		      ldy	#.EXTRA_WORTH_OFS
    180  3179		       b1 df		      lda	(ptrCave),y
    181  317b							;jsr	  Convert2BCD
    182  317b		       85 b8		      sta	diamondsExtraWorth	; now BCD in cave data
    183  317d
    184  317d		       a9 10		      lda	#.TIME_OFS
    185  317f		       20 9d f2 	      jsr	GetLevelDataBCD
    186  3182		       85 b9		      sta	caveTime
    187  3184		       86 ba		      stx	caveTimeHi
    188  3186
    189  3186		       a9 0b		      lda	#.DIAMONDS_OFS
    190  3188		       20 9d f2 	      jsr	GetLevelDataBCD
    191  318b		       85 b6		      sta	diamondsNeeded	;	 should never be 0
    192  318d
    193  318d							; *** 2. create random objects ***
    194  318d							; set initial random seed for level:
    195  318d		       a9 00		      lda	#0
    196  318f		       85 e3		      sta	randSeed1
    197  3191		       a9 06		      lda	#.RND_INIT_OFS
    198  3193		       20 c1 f2 	      jsr	GetLevelData
    199  3196		       85 e4		      sta	randSeed2
    200  3198
    201  3198							; setup pointers:
    202  3198		       a9 1f		      lda	#.RND_VALUE_OFS
    203  319a		       a2 02		      ldx	#2
    204  319c		       20 ca f2 	      jsr	AddPointer	;	 set ptrCave+2 to random values
    205  319f		       a9 1b		      lda	#.RND_OBJECT_OFS
    206  31a1		       20 c8 f2 	      jsr	AddPointer0	;	 set ptrCave+0 to random objects
    207  31a4
    208  31a4							; loop the board:
    209  31a4		       a0 01		      ldy	#1
    210  31a6				   .loopRows
    211  31a6		       84 90		      sty	POS_Y
    212  31a8		       a2 00		      ldx	#0
    213  31aa				   .loopColumns
    214  31aa		       86 8f		      stx	POS_X
    215  31ac							; get random object type:
    216  31ac		       20 d6 f2 	      jsr	NextRandom	;	 a = randSeed1
    217  31af		       a0 03		      ldy	#.NUM_RANDOM-1
    218  31b1				   .loopRandom
    219  31b1		       d1 e1		      cmp	(ptrCave+2),y
    220  31b3		       90 06		      bcc	.exitRandom
    221  31b5		       88		      dey
    222  31b6		       10 f9		      bpl	.loopRandom
    223  31b8		       a9 01		      lda	#CHARACTER_SOIL	;	 default character (dirt), = 0
      0  31ba					      NOP_W
      1  31ba		       0c		      .byte.b	$0c
    225  31bb				   .exitRandom
    226  31bb		       a9 01		      lda	#CHARACTER_SOIL	;	 default character (dirt), = 0
    227  31bd							;		  lda	  (ptrCave),y
    228  31bd		       85 93		      sta	POS_Type
    229  31bf
    230  31bf							; put new object on board:
    231  31bf		       20 93 f8 	      jsr	PutBoardCharacterFromRAM
    232  31c2							; goto next board cell:
    233  31c2		       a6 8f		      ldx	POS_X
    234  31c4		       e8		      inx
    235  31c5		       e4 98		      cpx	BoardLimit_Width
    236  31c7		       90 e1		      bcc	.loopColumns
    237  31c9		       a4 90		      ldy	POS_Y
    238  31cb		       c8		      iny
    239  31cc		       c4 99		      cpy	BoardLimit_Height
    240  31ce		       90 d6		      bcc	.loopRows
    241  31d0
    242  31d0							; *** 3. draw the bounding steel wall: ***
    243  31d0		       a9 e7		      lda	#<(BoundingWall)
    244  31d2		       85 df		      sta	ptrCave
    245  31d4		       a9 f3		      lda	#>(BoundingWall)
    246  31d6		       85 e0		      sta	ptrCave+1
    247  31d8		       20 fa f2 	      jsr	DecodeBoundary
    248  31db
    249  31db							; ...and decode the structures...
    250  31db		       a9 00		      lda	#<(BOARD_DATA_AREA)
    251  31dd		       85 df		      sta	ptrCave
    252  31df		       a9 f0		      lda	#>(BOARD_DATA_AREA)
    253  31e1		       85 e0		      sta	ptrCave+1
    254  31e3		       20 f5 f2 	      jsr	DecodeStructures
    255  31e6
    256  31e6							;*** 4. activate all objects: ***
    257  31e6
    258  31e6				   ActivateObjects
    259  31e6
    260  31e6		       a4 99		      ldy	BoardLimit_Height
    261  31e8				   .loopY
    262  31e8		       88		      dey
    263  31e9		       84 90		      sty	POS_Y
    264  31eb		       a6 98		      ldx	BoardLimit_Width
    265  31ed				   .loopX
    266  31ed		       ca		      dex
    267  31ee		       86 8f		      stx	POS_X
    268  31f0		       20 7f f8 	      jsr	GetBoardCharacter__CALL_FROM_RAM__	;6+61(A)
    269  31f3		       aa		      tax
    270  31f4		       bd 74 f2 	      lda	CharToType2,x
    271  31f7		       30 5f		      bmi	.skipActivate
    272  31f9
    273  31f9		       c9 40		      cmp	#SPECIAL_ADD
    274  31fb		       29 1f		      and	#TYPEMASK
    275  31fd		       85 93		      sta	POS_Type	;	 creature TYPE
    276  31ff		       90 23		      bcc	.Activate
    277  3201
    278  3201					      IF	SPECIAL_ADD_DECODECAVE = YES
    279  3201
    280  3201							;-------------------------------------------------------------------------------------------------------------
    281  3201							; 23/June/2011: Some objects (BOXs, diamonds) of type SPECIAL_ADD only go onto the creature stack IF they
    282  3201							; have a surrounding blank square which means they MAY fall on startup.  So, we need to see if the LRD squares
    283  3201							; (any) are blank. They may not ACTUALLY fall, but that will be checked in due course as they're on the stack.
    284  3201
    285  3201							;  +---+---+---+
    286  3201							;  | 1 | X | 2 |
    287  3201							;  +---+---+---+
    288  3201							;	| 0 |
    289  3201							;	+---+
    290  3201
    291  3201
    292  3201		       e6 90		      inc	POS_Y
    293  3203		       20 7f f8 	      jsr	GetBoardCharacter__CALL_FROM_RAM__	;6+61(A)[0]
    294  3206		       c6 90		      dec	POS_Y
    295  3208		       c9 00		      cmp	#0
    296  320a		       f0 16		      beq	ItIsBlank
    297  320c
    298  320c		       c6 8f		      dec	POS_X
    299  320e		       20 7f f8 	      jsr	GetBoardCharacter__CALL_FROM_RAM__	;6+61(A)[1]
    300  3211		       e6 8f		      inc	POS_X
    301  3213		       c9 00		      cmp	#0
    302  3215		       f0 0b		      beq	ItIsBlank
    303  3217
    304  3217		       e6 8f		      inc	POS_X
    305  3219		       20 7f f8 	      jsr	GetBoardCharacter__CALL_FROM_RAM__	;6+61(A)[2]
    306  321c		       c6 8f		      dec	POS_X
    307  321e		       c9 00		      cmp	#0
    308  3220		       d0 36		      bne	.skipActivate
    309  3222
    310  3222		       a5 93	   ItIsBlank  lda	POS_Type
    311  3224
    312  3224				  -	      ELSE
    313  3224				  -	      jmp	.skipActivate
    314  3224					      ENDIF
    315  3224
    316  3224							;-------------------------------------------------------------------------------------------------------------
    317  3224
    318  3224				   .Activate
    319  3224		       a8		      tay
    320  3225		       a9 00		      lda	#0	;InitialFace,y
    321  3227		       85 94		      sta	POS_VAR
    322  3229
    323  3229		       bd 74 f2 	      lda	CharToType2,x
    324  322c		       29 20		      and	#ALTERNATE_FACE
    325  322e		       f0 00		      beq	noAlternate
    326  3230
    327  3230							;inc POS_VAR
    328  3230							;inc POS_VAR
    329  3230
    330  3230		       98	   noAlternate tya
    331  3231		       aa		      tax
    332  3232		       e0 02		      cpx	#TYPE_AMOEBA
    333  3234		       f0 03		      beq	skipAmoebaSpecial
    334  3236
    335  3236		       20 19 fa 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    336  3239
    337  3239				   skipAmoebaSpecial
    338  3239							;tes
    339  3239
    340  3239							; handle special types:
    341  3239		       a6 8f		      ldx	POS_X	;	 x coordinate
    342  323b		       a4 90		      ldy	POS_Y	;	 y coordinate
    343  323d		       a5 93		      lda	POS_Type
    344  323f		       c9 02		      cmp	#TYPE_AMOEBA
    345  3241		       d0 0d		      bne	.skipAmoeba
    346  3243
    347  3243		       a9 40		      lda	#AMOEBA_PRESENT
    348  3245		       85 cc		      sta	amoebaFlag	; this turns ON the scanning for this level
    349  3247							; Remember initial Amoeba position for bounding box.
    350  3247							; Since always the left most cell is added last and there are no more than two cells in same row at the beginning,
    351  3247							; simply increasing the maximum X by 1 solves the problem
    352  3247		       86 ce		      stx	amoebaMinX
    353  3249		       e8		      inx
    354  324a		       86 d0		      stx	amoebaMaxX
    355  324c		       84 cf		      sty	amoebaMinY
    356  324e		       84 d1		      sty	amoebaMaxY
    357  3250
    358  3250				   .skipAmoeba
    359  3250		       c9 00		      cmp	#TYPE_MAN
    360  3252		       d0 04		      bne	.skipActivate
    361  3254
    362  3254							; insert man:
    363  3254		       86 9f		      stx	ManX
    364  3256		       84 a0		      sty	ManY
    365  3258
    366  3258		       a6 8f	   .skipActivate ldx	POS_X	;	 x coordinate
    367  325a		       d0 91		      bne	.loopX
    368  325c		       a4 90		      ldy	POS_Y	;	 y coordinate
    369  325e		       d0 88		      bne	.loopY
    370  3260
    371  3260
    372  3260							; adjusts playing speed based on level:
    373  3260
    374  3260		       a9 04		      lda	#NUM_LEVELS-1	; intermissions run at full speed
    375  3262		       24 b2		      bit	caveDisplay
    376  3264		       30 02		      bmi	.intermission3
    377  3266		       a5 b1		      lda	level
    378  3268				   .intermission3
    379  3268		       0a		      asl
    380  3269		       0a		      asl
    381  326a		       05 81		      ora	Platform
    382  326c		       4a		      lsr
    383  326d		       aa		      tax
    384  326e		       bd e1 f0 	      lda	ThrottleSpeedTbl,x
    385  3271		       85 b4		      sta	ThrottleSpeed
    386  3273
    387  3273		       60		      rts
    388  3274
    389  3274
    390  3274							;------------------------------------------------------------------------------
    391  3274
    392  3274
    393  3274		       00 80	   NOT_ADDED  =	128
    394  3274		       00 ff	   NULL_TYPE  =	255
    395  3274		       00 40	   SPECIAL_ADD =	64
    396  3274		       00 20	   ALTERNATE_FACE =	32
    397  3274		       00 1f	   TYPEMASK   =	31
    398  3274
    399  3274
    400  3274				   CharToType2
    401  3274
    402  3274							; Converts a character # to a creature type
    403  3274							; add 128 if character is NOT to be added as a creature on board draw
    404  3274
    405  3274		       ff		      .byte.b	NULL_TYPE	; blank
    406  3275		       ff		      .byte.b	NULL_TYPE	; soil
    407  3276		       41		      .byte.b	TYPE_BOX + SPECIAL_ADD
    408  3277		       02		      .byte.b	TYPE_AMOEBA
    409  3278		       45		      .byte.b	TYPE_DIAMOND + SPECIAL_ADD
    410  3279		       45		      .byte.b	TYPE_DIAMOND + SPECIAL_ADD
    411  327a		       00		      .byte.b	TYPE_MAN
    412  327b		       03		      .byte.b	TYPE_FLUTTERBY
    413  327c		       23		      .byte.b	TYPE_FLUTTERBY + ALTERNATE_FACE	; character_flutterby2
    414  327d		       04		      .byte.b	TYPE_FIREFLY
    415  327e		       24		      .byte.b	TYPE_FIREFLY + ALTERNATE_FACE	; character_firefly2
    416  327f		       86		      .byte.b	TYPE_MAGICWALL + NOT_ADDED
    417  3280		       86		      .byte.b	TYPE_MAGICWALL + NOT_ADDED
    418  3281		       86		      .byte.b	TYPE_MAGICWALL + NOT_ADDED
    419  3282		       86		      .byte.b	TYPE_MAGICWALL + NOT_ADDED
    420  3283		       ff		      .byte.b	NULL_TYPE	; steel wall
    421  3284		       ff		      .byte.b	NULL_TYPE	; plain brick wall
    422  3285		       87		      .byte.b	TYPE_EXITDOOR + NOT_ADDED
    423  3286		       87		      .byte.b	TYPE_EXITDOOR + NOT_ADDED
    424  3287		       09		      .byte.b	TYPE_EXPLOSION
    425  3288		       0a		      .byte.b	TYPE_EXPLOSION1
    426  3289		       0b		      .byte.b	TYPE_EXPLOSION2
    427  328a		       08		      .byte.b	TYPE_SELECTOR	;EXPLOSION3		     ; overload explosion character
    428  328b		       02		      .byte.b	TYPE_AMOEBA
    429  328c
    430  328c							; The following two will NEVER APPEAR ON BOARD DECODE DATA so can be skipped
    431  328c							;.byte TYPE_BOX			      ; falling BOX
    432  328c							;.byte TYPE_DIAMOND
    433  328c							;.byte TYPE_MAN				 ; unkillable man
    434  328c
    435  328c							; --> see also MoveVec
    436  328c							; --> see also DecodeCave's table
    437  328c
      0  328c					      DEFINE_SUBROUTINE	InitialFace	;[type]
      1  328c		       00 06	   BANK_InitialFace =	_CURRENT_BANK
      2  328c					      SUBROUTINE
      3  328c				   InitialFace
    439  328c
    440  328c							; Given an object type, gives an initial facing direction for that type.
    441  328c							; If changing, also see 'DEFINE' definitions of types in BANK_INITBANK.asm
    442  328c
    443  328c		       00		      .byte.b	0	; MAN
    444  328d		       00		      .byte.b	0	; BOX
    445  328e		       00		      .byte.b	0	; AMOEBA
    446  328f		       02		      .byte.b	FACE_DOWN	; FLUTTERBY	 starts life facing down
    447  3290		       0b		      .byte.b	FACE_LEFT+8	; FIREFLY	 starts life facing left
    448  3291		       00		      .byte.b	0	; DIAMOND
    449  3292		       01		      .byte.b	1	; WALL0						 facing????
    450  3293		       00		      .byte.b	0	; EXITDOOR
    451  3294		       00		      .byte.b	0	; SELECT
    452  3295		       00		      .byte.b	0	; EXPLOSION
    453  3296		       00		      .byte.b	0	; EXPLOSION1
    454  3297		       00		      .byte.b	0	; EXPLOSION2
    455  3298		       00		      .byte.b	0	; EXPLOSION3
    456  3299		       00		      .byte.b	0	; BLANK
    457  329a		       00		      .byte.b	0	; SOIL
    458  329b		       00		      .byte.b	0	; STEEL
    459  329c		       00		      .byte.b	0	; WALL
    460  329d
    461  329d
    462  329d				   GetLevelDataBCD		; SUBROUTINE
    463  329d		       20 c1 f2 	      jsr	GetLevelData
    464  32a0
    465  32a0				   Convert2BCD		; SUBROUTINE
    466  32a0		       a2 00		      ldx	#0
    467  32a2		       a0 ff		      ldy	#<(-1)
    468  32a4				   .loop
    469  32a4		       c8		      iny
    470  32a5		       c0 0a		      cpy	#10
    471  32a7		       90 03		      bcc	.ok
    472  32a9		       a0 00		      ldy	#0
    473  32ab		       e8		      inx
    474  32ac				   .ok
    475  32ac		       38		      sec
    476  32ad		       e9 0a		      sbc	#10
    477  32af		       b0 f3		      bcs	.loop
    478  32b1		       69 0a		      adc	#10
    479  32b3		       19 b7 f2 	      ora	Mult16Tbl,y
    480  32b6		       60		      rts
    481  32b7
    482  32b7				   Y	      SET	0
    483  32b7				   Mult16Tbl
    484  32b7					      REPEAT	10
    485  32b7		       00		      .byte.b	Y
    486  32b7				   Y	      SET	Y + $10
    484  32b7					      REPEND
    485  32b8		       10		      .byte.b	Y
    486  32b8				   Y	      SET	Y + $10
    484  32b8					      REPEND
    485  32b9		       20		      .byte.b	Y
    486  32b9				   Y	      SET	Y + $10
    484  32b9					      REPEND
    485  32ba		       30		      .byte.b	Y
    486  32ba				   Y	      SET	Y + $10
    484  32ba					      REPEND
    485  32bb		       40		      .byte.b	Y
    486  32bb				   Y	      SET	Y + $10
    484  32bb					      REPEND
    485  32bc		       50		      .byte.b	Y
    486  32bc				   Y	      SET	Y + $10
    484  32bc					      REPEND
    485  32bd		       60		      .byte.b	Y
    486  32bd				   Y	      SET	Y + $10
    484  32bd					      REPEND
    485  32be		       70		      .byte.b	Y
    486  32be				   Y	      SET	Y + $10
    484  32be					      REPEND
    485  32bf		       80		      .byte.b	Y
    486  32bf				   Y	      SET	Y + $10
    484  32bf					      REPEND
    485  32c0		       90		      .byte.b	Y
    486  32c0				   Y	      SET	Y + $10
    487  32c1					      REPEND
    488  32c1
    489  32c1				   GetLevelData 		; SUBROUTINE
    490  32c1		       18		      clc
    491  32c2		       65 b1		      adc	level
    492  32c4		       a8		      tay
    493  32c5		       b1 df		      lda	(ptrCave),y
    494  32c7		       60		      rts
    495  32c8
    496  32c8				   AddPointer0
    497  32c8		       a2 00		      ldx	#0
    498  32ca				   AddPointer
    499  32ca		       18		      clc
    500  32cb		       65 df		      adc	ptrCave
    501  32cd		       95 df		      sta	ptrCave,x
    502  32cf		       a5 e0		      lda	ptrCave+1
    503  32d1		       69 00		      adc	#0
    504  32d3		       95 e0		      sta	ptrCave+1,x
    505  32d5		       60		      rts
    506  32d6
    507  32d6
    508  32d6				   NextRandom
    509  32d6		       a5 e3		      lda	randSeed1
    510  32d8		       6a		      ror
    511  32d9		       6a		      ror
    512  32da		       29 80		      and	#$80
    513  32dc		       85 e5		      sta	tempRand1	;	 TempRand1 = (RandSeed1 & 1) << 7
    514  32de
    515  32de		       a5 e4		      lda	randSeed2
    516  32e0		       4a		      lsr
    517  32e1		       85 e6		      sta	tempRand2	;	 TempRand2 = RandSeed2 >> 1
    518  32e3
    519  32e3							;		  lda	  randSeed2
    520  32e3							;		  and	  #$01
    521  32e3							;		  lsr
    522  32e3		       a9 00		      lda	#$00
    523  32e5		       6a		      ror
    524  32e6		       65 e4		      adc	randSeed2	;	 C=0!
    525  32e8		       69 13		      adc	#$13	;	 C=?
    526  32ea		       85 e4		      sta	randSeed2	;	 RandSeed2 = RandSeed2 << 7 + RandSeed2 + $13
    527  32ec
    528  32ec		       a5 e3		      lda	randSeed1
    529  32ee		       65 e5		      adc	tempRand1	;	 C=?
    530  32f0		       65 e6		      adc	tempRand2	;	 C=?
    531  32f2		       85 e3		      sta	randSeed1
    532  32f4				   Exit
    533  32f4		       60		      rts
    534  32f5
    535  32f5
    536  32f5				   DecodeStructures
    537  32f5		       a9 23		      lda	#.STRUCT_OFFSET
    538  32f7				   .loopStructures
    539  32f7		       20 c8 f2 	      jsr	AddPointer0
    540  32fa				   DecodeBoundary
    541  32fa							; load structure type and object:
    542  32fa		       a0 00		      ldy	#0
    543  32fc		       b1 df		      lda	(ptrCave),y
    544  32fe		       c9 ff		      cmp	#.STRUCT_DELIMITER
    545  3300		       f0 f2		      beq	Exit
    546  3302		       29 3f		      and	#(~.STRUCTURE_MASK) & $FF
    547  3304		       85 93		      sta	POS_Type
    548  3306		       51 df		      eor	(ptrCave),y
    549  3308		       0a		      asl
    550  3309		       2a		      rol
    551  330a		       2a		      rol
    552  330b		       85 e3		      sta	structType
    553  330d							; load structure values:
    554  330d		       a0 01		      ldy	#1
    555  330f		       b1 df		      lda	(ptrCave),y	;	 +1
    556  3311		       85 e4		      sta	column
    557  3313		       c8		      iny
    558  3314		       b1 df		      lda	(ptrCave),y	;	 +2
    559  3316		       38		      sec
    560  3317		       e9 02		      sbc	#2	;	 cave starts at row 2 in C64 original
    561  3319		       85 e5		      sta	row
    562  331b		       c8		      iny
    563  331c		       b1 df		      lda	(ptrCave),y	;	 +3
    564  331e		       85 e6		      sta	length
    565  3320		       c8		      iny
    566  3321		       b1 df		      lda	(ptrCave),y	;	 +4
    567  3323		       85 e1		      sta	height	;	 == direction for LINE
    568  3325
    569  3325							; process structure:
    570  3325		       a6 e3		      ldx	structType
    571  3327		       d0 12		      bne	.skipSingle
    572  3329							; draw single object:
    573  3329		       a6 e4		      ldx	column
    574  332b		       86 8f		      stx	POS_X
    575  332d		       a5 e5		      lda	row
    576  332f		       85 90		      sta	POS_Y
    577  3331		       20 93 f8 	      jsr	PutBoardCharacterFromRAM
    578  3334
    579  3334				   .nextStructure
    580  3334		       a6 e3		      ldx	structType
    581  3336		       bd e3 f3 	      lda	StructureSizeTbl,x
    582  3339		       d0 bc		      bne	.loopStructures	; 3	 unconditional
    583  333b							;    DEBUG_BRK
    584  333b
    585  333b				   .skipSingle
    586  333b		       ca		      dex
    587  333c		       d0 05		      bne	.skipLine
    588  333e							; draw a line:
    589  333e		       20 67 f3 	      jsr	DrawLine	;	 a == direction
    590  3341		       f0 f1		      beq	.nextStructure	; 3	 unconditional
    591  3343							;    DEBUG_BRK
    592  3343
    593  3343				   .skipLine
    594  3343		       ca		      dex
    595  3344		       d0 1a		      bne	.skipFilled
    596  3346							; draw a filled rectangle:
    597  3346		       20 92 f3 	      jsr	DrawRectangle
    598  3349
    599  3349		       a0 05		      ldy	#5
    600  334b		       b1 df		      lda	(ptrCave),y	;	 +5
    601  334d		       85 93		      sta	POS_Type
    602  334f
    603  334f		       e6 e4		      inc	column
    604  3351		       c6 e1		      dec	height
    605  3353		       c6 e6		      dec	length
    606  3355				   .loopFill
    607  3355		       e6 e5		      inc	row
    608  3357		       20 65 f3 	      jsr	DrawLineRight
    609  335a		       c6 e1		      dec	height
    610  335c		       d0 f7		      bne	.loopFill
    611  335e		       f0 d4		      beq	.nextStructure	; 3	 unconditional
    612  3360
    613  3360				   .skipFilled
    614  3360							; draw a rectangle:
    615  3360		       20 92 f3 	      jsr	DrawRectangle
    616  3363		       f0 cf		      beq	.nextStructure	; 3	 unconditional
    617  3365							;    DEBUG_BRK
    618  3365
    619  3365				   DrawLineRight
    620  3365		       a9 02		      lda	#.DIR_RIGHT
    621  3367				   DrawLine
    622  3367		       a6 e4		      ldx	column
    623  3369		       a4 e5		      ldy	row
    624  336b							; direction is set outside
    625  336b		       86 8f		      stx	POS_X
    626  336d		       84 90		      sty	POS_Y
    627  336f				   DrawNextHLine
    628  336f		       a6 e6		      ldx	length
      0  3371					      NOP_W
      1  3371		       0c		      .byte.b	$0c
    630  3372				   DrawNextVLine
    631  3372		       a6 e1		      ldx	height
    632  3374		       85 e2		      sta	direction
    633  3376		       86 e9		      stx	tmpLength
    634  3378				   .loopLine
    635  3378		       20 93 f8 	      jsr	PutBoardCharacterFromRAM
    636  337b		       a4 e2		      ldy	direction
    637  337d		       a5 8f		      lda	POS_X
    638  337f		       18		      clc
    639  3380		       79 db f3 	      adc	ColumnDirTbl,y
    640  3383		       85 8f		      sta	POS_X
    641  3385		       a5 90		      lda	POS_Y
    642  3387		       18		      clc
    643  3388		       79 d9 f3 	      adc	RowDirTbl,y
    644  338b		       85 90		      sta	POS_Y
    645  338d		       c6 e9		      dec	tmpLength
    646  338f		       d0 e7		      bne	.loopLine
    647  3391		       60		      rts
    648  3392
    649  3392
    650  3392				   DrawRectangle
    651  3392		       c6 e6		      dec	length
    652  3394		       c6 e1		      dec	height
    653  3396
    654  3396		       20 65 f3 	      jsr	DrawLineRight
    655  3399
    656  3399		       a9 04		      lda	#.DIR_DOWN
    657  339b		       20 72 f3 	      jsr	DrawNextVLine
    658  339e		       a9 06		      lda	#.DIR_LEFT
    659  33a0		       20 6f f3 	      jsr	DrawNextHLine
    660  33a3		       a9 00		      lda	#.DIR_UP
    661  33a5		       10 cb		      bpl	DrawNextVLine	; 3	 unconditional
    662  33a7							;    DEBUG_BRK
    663  33a7
    664  33a7
    665  33a7				   CAVENUM    SET	0
    666  33a7		       00 05	   CAVE_DATA_SIZE =	5
    667  33a7
    668  33a7					      MAC	add_cave
    669  33a7				   CAVE_ACTIVE_{1} SET	1
    670  33a7				   CAVE_NAMED_{1} =	CAVENUM
    671  33a7					      .byte	<CAVE_{1}
    672  33a7					      .byte	>CAVE_{1}
    673  33a7					      .byte	BANK_CAVE_{1}
    674  33a7					      .byte	CAVE_SIZE_{1}
    675  33a7					      .byte	{2}	; display as #.  $80 indicates intermission.
    676  33a7				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    677  33a7					      ENDM		; {name}
    678  33a7
    679  33a7				   CaveInformation
    680  33a7
    681  33a7							; The ordering here corresponds to the ordering when playing...
    682  33a7					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  33a7					      ADD_CAVE	INTRO,1
      1  33a7				   CAVE_ACTIVE_INTRO SET	1
      2  33a7		       00 00	   CAVE_NAMED_INTRO =	CAVENUM
      3  33a7		       f0		      .byte.b	<CAVE_INTRO
      4  33a8		       f3		      .byte.b	>CAVE_INTRO
      5  33a9		       05		      .byte.b	BANK_CAVE_INTRO
      6  33aa		       e1		      .byte.b	CAVE_SIZE_INTRO
      7  33ab		       01		      .byte.b	1
      8  33ab				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  33ac					      ADD_CAVE	ROOMS,2
      1  33ac				   CAVE_ACTIVE_ROOMS SET	1
      2  33ac		       00 05	   CAVE_NAMED_ROOMS =	CAVENUM
      3  33ac		       d1		      .byte.b	<CAVE_ROOMS
      4  33ad		       f4		      .byte.b	>CAVE_ROOMS
      5  33ae		       05		      .byte.b	BANK_CAVE_ROOMS
      6  33af		       01		      .byte.b	CAVE_SIZE_ROOMS
      7  33b0		       02		      .byte.b	2
      8  33b0				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  33b1					      ADD_CAVE	MAZE,3
      1  33b1				   CAVE_ACTIVE_MAZE SET	1
      2  33b1		       00 0a	   CAVE_NAMED_MAZE =	CAVENUM
      3  33b1		       d2		      .byte.b	<CAVE_MAZE
      4  33b2		       f4		      .byte.b	>CAVE_MAZE
      5  33b3		       05		      .byte.b	BANK_CAVE_MAZE
      6  33b4		       01		      .byte.b	CAVE_SIZE_MAZE
      7  33b5		       03		      .byte.b	3
      8  33b5				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  33b6					      ADD_CAVE	BUTTERFLIES,4
      1  33b6				   CAVE_ACTIVE_BUTTERFLIES SET	1
      2  33b6		       00 0f	   CAVE_NAMED_BUTTERFLIES =	CAVENUM
      3  33b6		       d3		      .byte.b	<CAVE_BUTTERFLIES
      4  33b7		       f4		      .byte.b	>CAVE_BUTTERFLIES
      5  33b8		       05		      .byte.b	BANK_CAVE_BUTTERFLIES
      6  33b9		       4e		      .byte.b	CAVE_SIZE_BUTTERFLIES
      7  33ba		       04		      .byte.b	4
      8  33ba				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  33bb					      ADD_CAVE	INTERMISSION_1,$80|$0
      1  33bb				   CAVE_ACTIVE_INTERMISSION_1 SET	1
      2  33bb		       00 14	   CAVE_NAMED_INTERMISSION_1 =	CAVENUM
      3  33bb		       12		      .byte.b	<CAVE_INTERMISSION_1
      4  33bc		       f6		      .byte.b	>CAVE_INTERMISSION_1
      5  33bd		       04		      .byte.b	BANK_CAVE_INTERMISSION_1
      6  33be		       39		      .byte.b	CAVE_SIZE_INTERMISSION_1
      7  33bf		       80		      .byte.b	$80|$0
      8  33bf				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    688  33c0
      0  33c0					      ADD_CAVE	GUARDS,5
      1  33c0				   CAVE_ACTIVE_GUARDS SET	1
      2  33c0		       00 19	   CAVE_NAMED_GUARDS =	CAVENUM
      3  33c0		       83		      .byte.b	<CAVE_GUARDS
      4  33c1		       f4		      .byte.b	>CAVE_GUARDS
      5  33c2		       03		      .byte.b	BANK_CAVE_GUARDS
      6  33c3		       8a		      .byte.b	CAVE_SIZE_GUARDS
      7  33c4		       05		      .byte.b	5
      8  33c4				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  33c5					      ADD_CAVE	FIREFLY_DENS,6
      1  33c5				   CAVE_ACTIVE_FIREFLY_DENS SET	1
      2  33c5		       00 1e	   CAVE_NAMED_FIREFLY_DENS =	CAVENUM
      3  33c5		       0d		      .byte.b	<CAVE_FIREFLY_DENS
      4  33c6		       f5		      .byte.b	>CAVE_FIREFLY_DENS
      5  33c7		       03		      .byte.b	BANK_CAVE_FIREFLY_DENS
      6  33c8		       94		      .byte.b	CAVE_SIZE_FIREFLY_DENS
      7  33c9		       06		      .byte.b	6
      8  33c9				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  33ca					      ADD_CAVE	AMOEBA,7
      1  33ca				   CAVE_ACTIVE_AMOEBA SET	1
      2  33ca		       00 23	   CAVE_NAMED_AMOEBA =	CAVENUM
      3  33ca		       a1		      .byte.b	<CAVE_AMOEBA
      4  33cb		       f5		      .byte.b	>CAVE_AMOEBA
      5  33cc		       03		      .byte.b	BANK_CAVE_AMOEBA
      6  33cd		       4b		      .byte.b	CAVE_SIZE_AMOEBA
      7  33ce		       07		      .byte.b	7
      8  33ce				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  33cf					      ADD_CAVE	ENCHANTED_WALL,8
      1  33cf				   CAVE_ACTIVE_ENCHANTED_WALL SET	1
      2  33cf		       00 28	   CAVE_NAMED_ENCHANTED_WALL =	CAVENUM
      3  33cf		       ec		      .byte.b	<CAVE_ENCHANTED_WALL
      4  33d0		       f5		      .byte.b	>CAVE_ENCHANTED_WALL
      5  33d1		       03		      .byte.b	BANK_CAVE_ENCHANTED_WALL
      6  33d2		       5a		      .byte.b	CAVE_SIZE_ENCHANTED_WALL
      7  33d3		       08		      .byte.b	8
      8  33d3				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    693  33d4
      0  33d4					      ADD_CAVE	INTERMISSION_2,$80|$1
      1  33d4				   CAVE_ACTIVE_INTERMISSION_2 SET	1
      2  33d4		       00 2d	   CAVE_NAMED_INTERMISSION_2 =	CAVENUM
      3  33d4		       4b		      .byte.b	<CAVE_INTERMISSION_2
      4  33d5		       f6		      .byte.b	>CAVE_INTERMISSION_2
      5  33d6		       04		      .byte.b	BANK_CAVE_INTERMISSION_2
      6  33d7		       53		      .byte.b	CAVE_SIZE_INTERMISSION_2
      7  33d8		       81		      .byte.b	$80|$1
      8  33d8				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
    695  33d9
    696  33d9
    697  33d9
    698  33d9					      ENDIF
    699  33d9
    700  33d9							;---------------------------------------------------------------------------
    701  33d9
    702  33d9
    703  33d9				   RowDirTbl
    704  33d9		       ff ff		      .byte.b	-1, -1	;, 0, 1, 1, 1, 0, -1
    705  33db				   ColumnDirTbl
    706  33db		       00 01 01 01*	      .byte.b	0, 1, 1, 1, 0, -1, -1, -1
    707  33e3
    708  33e3				   StructureSizeTbl
    709  33e3		       03 05 06 05	      .byte.b	3, 5, 6, 5
    710  33e7
    711  33e7
    712  33e7							;foreground color is ignored (white instead), except for amoeba levels G and M (light green)
    713  33e7
    714  33e7							;C64 palette:
    715  33e7							;	 website     x64	 ccs64
    716  33e7							;00	 00 00 00    00 00 00	 19 1d 19    black
    717  33e7							;01	 FF FF FF    ff ff ff	 fc f9 fc    white
    718  33e7							;02	 74 43 35		 a0 3a 4c    red
    719  33e7							;03	 7c ac ba		 b6 fa fa    cyan
    720  33e7							;04	 7b 48 90    8a 46 ae	 d2 7d ed    magenta/purple
    721  33e7							;05	 64 97 4e		 6a cf 6f    green
    722  33e7							;06	 40 32 85		 4f 44 d8    blue
    723  33e7							;07	 bf cd 7a		 fb fb 8b    yellow
    724  33e7							;08	 7b 5b 2f    90 5f 35	 d8 9c 5b    orange
    725  33e7							;09	 4f 45 00    92 71 00	 7f 53 07    brown
    726  33e7							;0a	 a3 72 65    bb 77 6d	 ef 83 9f    light-red
    727  33e7							;0b	 50 50 50    55 55 55	 57 57 53    dark-gray
    728  33e7							;0c	 78 78 78		 a3 a7 a7    gray
    729  33e7							;0d	 a4 d7 d7		 b7 fb bf    light-cyan
    730  33e7							;0e	 78 6a bd		 a3 9f ff    light-blue
    731  33e7							;0f	 9f 9f 9f		 ef f9 e7    light-gray
    732  33e7
    733  33e7
    734  33e7							; structure for the bounding steel wall:
    735  33e7				   BoundingWall
    736  33e7		       cf 00 02 63*	      .byte.b	.STRUCT_RECTANGLE|CHARACTER_STEEL, 0, 2, 99, 99	; bounding steel wall
    737  33ec		       ff		      .byte.b	.STRUCT_DELIMITER
------- FILE BANK_GENERIC.asm
     11  33ed
      0  33ed					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_CAVE)"
      1  33ed
      2  33ed
      3  33ed		       03 ed	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_CAVE) (1K) SIZE =  $3ed , FREE= $13
      4  33ed					      ECHO	"GENERIC_BANK_1 (DECODE_CAVE)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  33ed				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  33ed				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  33ed				  -	      ERR
      8  33ed					      endif
     13  33ed
     14  33ed							;------------------------------------------------------------------------------
     15  33ed							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     16  33ed							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     17  33ed							; bank finishes.  Just continue on from where it left off...
     18  33ed							;------------------------------------------------------------------------------
     19  33ed
      0  33ed					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  33ed		       00 06	   BANK_Cart_Init =	_CURRENT_BANK
      2  33ed					      SUBROUTINE
      3  33ed				   Cart_Init
     21  33ed
     22  33ed							; Note the variables from the title selection are incredibly transient an can be stomped
     23  33ed							; at any time.  So they need to be used immediately.
     24  33ed
     25  33ed
     26  33ed							; odd usage below is to prevent any possibility of variable stomping/assumptions
     27  33ed
     28  33ed		       a5 82		      lda	sCave	; cave # from title select
     29  33ef		       48		      pha
     30  33f0		       a5 84		      lda	sPlayers
     31  33f2		       a6 83		      ldx	sLevel	; level # from title select
     32  33f4		       a4 85		      ldy	sJoysticks
     33  33f6		       84 ac		      sty	jtoggle
     34  33f8		       86 b1		      stx	level
     35  33fa		       85 ab		      sta	MenCurrent	; = #players
     36  33fc		       68		      pla
     37  33fd		       85 b0		      sta	cave	; make an immediate copy to safe variables!
     38  33ff
     39  33ff				  -	      IF	FINAL_VERSION
     40  33ff				  -	      asl
     41  33ff				  -	      asl
     42  33ff				  -	      adc	cave	; *5 because it only cycles 0/1/2/3 equaing to caves 0/5/10/15
     43  33ff				  -	      sta	cave
     44  33ff					      ENDIF
     45  33ff		       85 e5		      sta	startCave
     46  3401
     47  3401							; multiply with CAVE_DATA_SIZE (5):
     48  3401		       0a		      asl
     49  3402		       0a		      asl
     50  3403		       65 b0		      adc	cave
     51  3405		       85 b0		      sta	cave
     52  3407
     53  3407		       a9 01		      lda	#1
     54  3409		       85 9e		      sta	whichPlayer	; will switch to 0 on 1st go
     55  340b
     56  340b		       a9 30		      lda	#NUM_LIVES<<4	; 3 lives
     57  340d		       a6 ab		      ldx	MenCurrent	; = sPlayers
     58  340f		       f0 02		      beq	opg
     59  3411		       a9 33		      lda	#NUM_LIVES<<4|NUM_LIVES
     60  3413		       85 ab	   opg	      sta	MenCurrent	; P2P1 nybble each
     61  3415
     62  3415							;---------------------------------------------------------------------------
     63  3415
     64  3415		       a9 00		      lda	#0
     65  3417		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     66  341a		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     67  341d		       85 6b		      sta	HMCLR
     68  341f
     69  341f							; cleanup remains of title screen
     70  341f		       85 5b		      sta	GRP0
     71  3421		       85 5c		      sta	GRP1
     72  3423		       85 5b		      sta	GRP0
     73  3425
     74  3425		       85 8e		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     75  3427
     76  3427							;    IFCONST DEBUG_CREATURE
     77  3427							;		  sta worstTime
     78  3427							;    ENDIF
     79  3427
     80  3427		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     81  3429		       85 4a		      sta	CTRLPF
     82  342b		       85 87		      sta	rnd	; anything non-0
     83  342d
     84  342d		       a9 ff		      lda	#$FF
     85  342f		       85 89		      sta	DrawStackPointer
     86  3431
     87  3431		       a9 07		      lda	#DIRECTION_BITS
     88  3433		       85 a8		      sta	ManLastDirection
     89  3435
     90  3435		       a9 00		      lda	#0
     91  3437							;		  sta ObjStackPtr		  ; object stack index of last entry
     92  3437							;		  sta ObjStackPtr+1
     93  3437							;		  sta BlankStackPtr		  ; blank stack index of last entry
     94  3437							;		  sta ObjStackNum
     95  3437							;		  sta ObjIterator
     96  3437
     97  3437		       85 d4		      sta	sortPtr
     98  3439		       a9 ff		      lda	#<(-1)
     99  343b		       85 d3		      sta	sortRequired
    100  343d
    101  343d							; read high score from SaveKey and store in highScoreSK,
    102  343d							; which is transferred to high score variable in RAM by GeneralScoringSetups
    103  343d		       4c 09 f7 	      jmp	ReadSaveKey
    104  3440
    105  3440							;LEVEL0CREATURE  .byte TYPE_MAN,	  0,	  3,	  5
    106  3440							;		  .byte -1
    107  3440
    108  3440							;------------------------------------------------------------------------------
    109  3440
      0  3440					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  3440		       00 06	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  3440					      SUBROUTINE
      3  3440				   SwapPlayersGeneric
    111  3440
    112  3440							; at the start of a cave (or player, doesn't matter) we grab the current state of the colour/B&W switch
    113  3440							; into the gameMode variable.
    114  3440
    115  3440		       a5 80		      lda	gameMode
    116  3442		       29 77		      and	#~(BW_SWITCH|GAMEMODE_PAUSED)
    117  3444		       85 80		      sta	gameMode
    118  3446		       ad 82 02 	      lda	SWCHB
    119  3449		       29 08		      and	#BW_SWITCH
    120  344b		       05 80		      ora	gameMode	; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    121  344d		       85 80		      sta	gameMode	; also, BIT7=0 -- system is NOT paused
    122  344f
    123  344f
    124  344f							; restart cave
    125  344f		       a5 c9		      lda	NextLevelTrigger
    126  3451		       29 bf		      and	#<(~BIT_NEXTLIFE)
    127  3453		       85 c9		      sta	NextLevelTrigger
    128  3455
    129  3455							; if new high score was set by SwapPlayers, update it:
    130  3455
    131  3455		       4c 2f f7 	      jmp	WriteSaveKey
    132  3458
    133  3458
    134  3458							;------------------------------------------------------------------------------
    135  3458
      0  3458					      DEFINE_SUBROUTINE	CreateCreatures	; GENERIC_BANK_1
      1  3458		       00 06	   BANK_CreateCreatures =	_CURRENT_BANK
      2  3458					      SUBROUTINE
      3  3458				   CreateCreatures
    137  3458
    138  3458
    139  3458							; Calculate rightmost value for scrolling edge.  .
    140  3458
    141  3458		       85 c3		      sta	ROM_Bank
    142  345a
    143  345a		       38		      sec
    144  345b		       a5 98		      lda	BoardLimit_Width
    145  345d		       e9 09		      sbc	#SCREEN_WIDTH-1
    146  345f		       85 98		      sta	BoardEdge_Right	; absolute rightmost scroll value
    147  3461				  -	      IF	INITIAL_SCROLL = YES
    148  3461				  -	      sbc	#1
    149  3461				  -	      cmp	BoardScrollX
    150  3461				  -	      bcs	.Xok
    151  3461				  -	      sta	BoardScrollX
    152  3461				  -	      sec
    153  3461				  -.Xok
    154  3461					      ENDIF
    155  3461
    156  3461							;		  sec			     already set
    157  3461		       a5 99		      lda	BoardLimit_Height
    158  3463		       e9 07		      sbc	#SCREEN_LINES-1
    159  3465		       85 99		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    160  3467				  -	      IF	INITIAL_SCROLL = YES
    161  3467				  -	      sbc	#1
    162  3467				  -	      cmp	BoardScrollY
    163  3467				  -	      bcs	.Yok
    164  3467				  -	      sta	BoardScrollY
    165  3467				  -.Yok
    166  3467					      ENDIF
    167  3467
    168  3467							; kludge position scroll roughly at player
    169  3467
    170  3467							;TODO: "correct" BD scrolling.
    171  3467							; The game scrolls from the players last position (no difference between 1st and 2nd player)
    172  3467
    173  3467					      IF	INITIAL_SCROLL = NO
    174  3467							;		  sec			 already set
    175  3467		       a5 9f		      lda	ManX
    176  3469		       e9 05		      sbc	#5
    177  346b		       b0 02		      bcs	notL0
    178  346d		       a9 00		      lda	#0
    179  346f		       85 9b	   notL0      sta	BoardScrollX
    180  3471
    181  3471
    182  3471		       38		      sec
    183  3472		       a5 a0		      lda	ManY
    184  3474		       e9 05		      sbc	#5	; TJ: why 5???
    185  3476		       b0 02		      bcs	notU0
    186  3478		       a9 00		      lda	#0
    187  347a		       85 9a	   notU0      sta	BoardScrollY
    188  347c					      ENDIF
    189  347c
    190  347c		       a9 00		      lda	#0
    191  347e		       85 a3		      sta	ManMode
    192  3480		       85 a4		      sta	ManDelayCount
    193  3482
    194  3482		       a9 2c		      lda	#AnimateBLANK-Manimate	;0 ;<AnimateBLANK ;STAND
    195  3484		       85 a5		      sta	ManAnimation
    196  3486							;lda #>AnimateBLANK ;
    197  3486							;sta ManAnimation+1
    198  3486
    199  3486		       a9 ff		      lda	#$FF
    200  3488		       85 ad		      sta	LastSpriteY
    201  348a
    202  348a		       a9 07		      lda	#DIRECTION_BITS
    203  348c		       85 a8		      sta	ManLastDirection
    204  348e
    205  348e		       24 cc		      bit	amoebaFlag	; AMOEBA_PRESENT?
    206  3490		       50 12		      bvc	.noAmoeba
    207  3492
    208  3492		       a6 d0		      ldx	amoebaMaxX
    209  3494		       86 ca		      stx	amoebaX
    210  3496		       a4 d1		      ldy	amoebaMaxY
    211  3498		       84 cb		      sty	amoebaY
    212  349a		       a9 01		      lda	#1
    213  349c		       85 d2		      sta	amoebaStepCount
    214  349e		       85 cd		      sta	amoebaCount	; doesn't matter to be 1 too big here initially
    215  34a0							;		 lda #0
    216  34a0							;sta amoebaFlag		     ; now initialised in DecodeCave
    217  34a0							;		 sta amoebaCount
    218  34a0		       a5 b5		      lda	magicAmoebaTime	; setup slow growth time
    219  34a2		       85 9d		      sta	MagicAmoebaFlag	;
    220  34a4				   .noAmoeba
    221  34a4
    222  34a4		       60		      rts
    223  34a5
    224  34a5							;-------------------------------------------------------------------------------------
    225  34a5
      0  34a5					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  34a5		       00 06	   BANK_LevelInit =	_CURRENT_BANK
      2  34a5					      SUBROUTINE
      3  34a5				   LevelInit
    227  34a5
    228  34a5		       a9 00		      lda	#0
    229  34a7		       85 8b		      sta	ObjStackPtr
    230  34a9		       85 8c		      sta	ObjStackPtr+1	; kill all creatures
    231  34ab		       85 8a		      sta	ObjStackNum
    232  34ad		       85 dd		      sta	ObjIterator
    233  34af
    234  34af		       85 9c		      sta	scrollBits
    235  34b1		       85 8e		      sta	ScreenDrawPhase
    236  34b3
    237  34b3		       85 af		      sta	BGColour
    238  34b5		       85 c5		      sta	ColourTimer
    239  34b7		       85 c6		      sta	extraLifeTimer	; Cosmic Ark stars off
    240  34b9
    241  34b9		       85 8d		      sta	BlankStackPtr
    242  34bb
    243  34bb		       85 d5		      sta	soundIdxLst
    244  34bd		       85 d6		      sta	soundIdxLst+1
    245  34bf		       85 db		      sta	newSounds
    246  34c1
    247  34c1		       85 59		      sta	AUDV0
    248  34c3		       85 5a		      sta	AUDV1	; turn off music while levels init
    249  34c5							;		  sta AUDC0
    250  34c5
    251  34c5		       85 a8		      sta	ManLastDirection
    252  34c7		       85 a9		      sta	ManPushCounter
    253  34c9
    254  34c9		       85 d4		      sta	sortPtr	; sort stopped
    255  34cb		       a9 ff		      lda	#<(-1)
    256  34cd		       85 d3		      sta	sortRequired	; nothing needed
    257  34cf		       85 89		      sta	DrawStackPointer
    258  34d1
    259  34d1
    260  34d1		       a9 ff		      lda	#MAGIC_WALL_DORMANT
    261  34d3		       85 9d		      sta	MagicAmoebaFlag
    262  34d5
    263  34d5		       a9 02		      lda	#DISPLAY_LIVES
    264  34d7		       85 c8		      sta	scoringFlags
    265  34d9		       a9 96		      lda	#SCORING_TIMER_FIRST	; We want the first timer display to be long, to show level and lives
    266  34db		       85 c7		      sta	scoringTimer
    267  34dd		       60		      rts
    268  34de
    269  34de							;-------------------------------------------------------------------------------------
    270  34de
    271  34de
    272  34de							;---------------------------------------------------------------------------
    273  34de
      0  34de					      DEFINE_SUBROUTINE	Resync
      1  34de		       00 06	   BANK_Resync =	_CURRENT_BANK
      2  34de					      SUBROUTINE
      3  34de				   Resync
      0  34de					      RESYNC
      1  34de
      2  34de		       a9 02		      lda	#%10
      3  34e0		       85 41		      sta	VBLANK
      4  34e2
      5  34e2		       a2 08		      ldx	#8
      6  34e4				   .loopResync
      0  34e4					      VERTICAL_SYNC
      1  34e4		       a9 0e		      lda	#%1110
      2  34e6		       85 42	   .VSLP1     sta	WSYNC
      3  34e8		       85 40		      sta	VSYNC
      4  34ea		       4a		      lsr
      5  34eb		       d0 f9		      bne	.VSLP1
      8  34ed
      9  34ed		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  34ef		       a5 81		      lda	Platform
     11  34f1		       49 02		      eor	#PAL_50
     12  34f3		       d0 02		      bne	.ntsc
     13  34f5		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  34f7				   .ntsc
     15  34f7				   .loopWait
     16  34f7		       85 42		      sta	WSYNC
     17  34f9		       85 42		      sta	WSYNC
     18  34fb		       88		      dey
     19  34fc		       d0 f9		      bne	.loopWait
     20  34fe		       ca		      dex
     21  34ff		       d0 e3		      bne	.loopResync
    276  3501		       60	   Ret	      rts
    277  3502
    278  3502							;---------------------------------------------------------------------------
    279  3502				   Manimate
    280  3502				   AnimateSTAND
    281  3502				   AnimateSTOPPED
    282  3502		       7f		      .byte.b	127
    283  3503		       64		      .byte.b	<PLAYER_STAND
    284  3504		       0a		      .byte.b	10
    285  3505		       79		      .byte.b	< PLAYER_BLINK
    286  3506		       7f		      .byte.b	127
    287  3507		       64		      .byte.b	< PLAYER_STAND
    288  3508							;.byte 0
    289  3508							;.word AnimateTAP
    290  3508
    291  3508				   AnimateTAP
    292  3508		       80 00		      .byte.b	128, %0	; reflect off, always tap with left foot
    293  350a		       08		      .byte.b	8
    294  350b		       8e		      .byte.b	< PLAYER_TAP0
    295  350c		       08		      .byte.b	8
    296  350d		       a3		      .byte.b	< PLAYER_TAP1
    297  350e		       08		      .byte.b	8
    298  350f		       8e		      .byte.b	< PLAYER_TAP0
    299  3510		       08		      .byte.b	8
    300  3511		       a3		      .byte.b	< PLAYER_TAP1
    301  3512		       08		      .byte.b	8
    302  3513		       8e		      .byte.b	< PLAYER_TAP0
    303  3514		       08		      .byte.b	8
    304  3515		       a3		      .byte.b	< PLAYER_TAP1
    305  3516		       00		      .byte.b	0
    306  3517		       00		      .byte.b	AnimateSTAND-Manimate	;word AnimateSTAND
    307  3518
    308  3518				   AnimateRIGHT
    309  3518		       80 00		      .byte.b	128, %0	; reflect off
    310  351a		       05		      .byte.b	5
    311  351b		       3a		      .byte.b	< PLAYER_RIGHT0
    312  351c		       05		      .byte.b	5
    313  351d		       4f		      .byte.b	< PLAYER_RIGHT1
    314  351e		       00		      .byte.b	0
    315  351f		       16		      .byte.b	AnimateRIGHT-Manimate	;word AnimateRIGHT
    316  3520
    317  3520				   AnimateLEFT
    318  3520		       80 08		      .byte.b	128, %1000	; reflect ON
    319  3522		       05		      .byte.b	5
    320  3523		       3a		      .byte.b	< PLAYER_RIGHT0
    321  3524		       05		      .byte.b	5
    322  3525		       4f		      .byte.b	< PLAYER_RIGHT1
    323  3526		       00		      .byte.b	0
    324  3527		       1e		      .byte.b	AnimateLEFT-Manimate	;word AnimateLEFT
    325  3528
    326  3528							;AnimateUP
    327  3528							;    .byte 128, %0		   ; reflect off
    328  3528							;    .byte 5
    329  3528							;    .byte < PLAYER_TAP
    330  3528							;    .byte 128, %1000
    331  3528							;    .byte 5
    332  3528							;    .byte < PLAYER_TAP
    333  3528							;    .byte 0
    334  3528							;    .word AnimateUP
    335  3528
    336  3528				   AnimateUP		; keep last reflection, like in original game
    337  3528		       05		      .byte.b	5
    338  3529		       3a		      .byte.b	< PLAYER_RIGHT0
    339  352a		       05		      .byte.b	5
    340  352b		       4f		      .byte.b	< PLAYER_RIGHT1
    341  352c		       00		      .byte.b	0
    342  352d		       26		      .byte.b	AnimateUP-Manimate	;word AnimateUP
    343  352e
    344  352e				   AnimateBLANK
    345  352e		       7f		      .byte.b	127
    346  352f		       25		      .byte.b	< PLAYER_BLANK
    347  3530		       00		      .byte.b	0
    348  3531		       2c		      .byte.b	AnimateBLANK-Manimate	;word AnimateBLANK
    349  3532
    350  3532				   AnimateEND
      0  3532					      CHECKPAGEX	Manimate, "AnimateEND @ BANK_GENERIC"
      9  3532					      LIST	ON
    352  3532							;---------------------------------------------------------------------------
    353  3532
    354  3532
      0  3532					      DEFINE_SUBROUTINE	TrackPlayer	; =145; in GENERIC_BANK_1
      1  3532		       00 06	   BANK_TrackPlayer =	_CURRENT_BANK
      2  3532					      SUBROUTINE
      3  3532				   TrackPlayer
    356  3532
    357  3532		       a5 aa		      lda	LookingAround	; 3
    358  3534		       30 cb		      bmi	Ret	; 2/3=5/6   don't track when looking around
    359  3536
    360  3536							; Contribution by Thomas Jentzsch
    361  3536
    362  3536							; scrolling constants:
    363  3536		       00 03	   .SCRL_START_LEFT =	3	; 3
    364  3536		       00 03	   .SCRL_STOP_LEFT =	3	;SCREEN_WIDTH-5		    ; 5 scrolls 5-3+1 = 3 pixel
    365  3536		       00 07	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT	; 7
    366  3536		       00 07	   .SCRL_STOP_RIGHT =	SCREEN_WIDTH-.SCRL_STOP_LEFT	; 5
    367  3536		       00 11	   .SCRL_LEFT_BIT =	%00010001
    368  3536		       00 22	   .SCRL_RIGHT_BIT =	%00100010
    369  3536		       00 33	   .SCRL_X_BITS =	.SCRL_LEFT_BIT|.SCRL_RIGHT_BIT
    370  3536
    371  3536		       00 02	   .SCRL_START_UP =	2	; 2
    372  3536		       00 02	   .SCRL_STOP_UP =	2	;SCREEN_LINES-5		    ; 3 scrolls 3-2+1 = 2 pixel
    373  3536		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP	; 6
    374  3536		       00 06	   .SCRL_STOP_DOWN =	SCREEN_LINES-.SCRL_STOP_UP	; 5
    375  3536		       00 44	   .SCRL_UP_BIT =	%01000100
    376  3536		       00 88	   .SCRL_DOWN_BIT =	%10001000
    377  3536		       00 cc	   .SCRL_Y_BITS =	.SCRL_UP_BIT|.SCRL_DOWN_BIT
    378  3536
    379  3536							; *** horizontal scrolling (unoptimized version): ***
    380  3536
    381  3536							; check for enabling horizontal scrolling:
    382  3536		       a5 9f		      lda	ManX	; 3
    383  3538		       38		      sec		; 2
    384  3539		       e5 9b		      sbc	BoardScrollX	; 3
    385  353b		       a8		      tay		; 2	     for later use
    386  353c		       a9 11		      lda	#.SCRL_LEFT_BIT	; 2
    387  353e		       c0 03		      cpy	#.SCRL_START_LEFT	; 2	     <3?
    388  3540		       30 06		      bmi	.startXScroll	; 2/3	     yes, scroll left
    389  3542		       c0 07		      cpy	#.SCRL_START_RIGHT	; 2	     <8?
    390  3544		       30 08		      bmi	.skipStartXScroll	; 2/3	     no
    391  3546		       a9 22		      lda	#.SCRL_RIGHT_BIT	; 2 = 22    yes, scroll right
    392  3548				   .startXScroll
    393  3548		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    394  354a		       05 9c		      ora	scrollBits	; 3
    395  354c		       85 9c		      sta	scrollBits	; 3 =	8
    396  354e				   .skipStartXScroll
    397  354e
    398  354e							; do horizontal scrolling:
    399  354e		       a5 9c		      lda	scrollBits	; 3
    400  3550		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    401  3552		       f0 23		      beq	.skipXScroll	; 2/3
    402  3554		       29 22		      and	#.SCRL_RIGHT_BIT	; 2
    403  3556		       d0 0c		      bne	.xScrollRight	; 2/3=11/12
    404  3558
    405  3558							; scroll left:
    406  3558		       a5 9b		      lda	BoardScrollX	; 3	     already at left edge?
    407  355a		       f0 15		      beq	.stopXScroll	; 2
    408  355c		       c6 9b		      dec	BoardScrollX	; 5
    409  355e		       c0 02		      cpy	#.SCRL_STOP_LEFT-1	; 2
    410  3560		       10 0f		      bpl	.stopXScroll	; 2/3=15
    411  3562		       30 13		      bmi	.skipXScroll	; 3
    412  3564							;---------------------------------------
    413  3564				   .xScrollRight
    414  3564		       a6 9b		      ldx	BoardScrollX	; 3
    415  3566		       e8		      inx		; 2
    416  3567		       e4 98		      cpx	BoardEdge_Right	; 3	     already at right edge?
    417  3569		       10 06		      bpl	.stopXScroll	; 2/3
    418  356b		       86 9b		      stx	BoardScrollX	; 3
    419  356d		       c0 08		      cpy	#.SCRL_STOP_RIGHT+1	; 2
    420  356f		       10 06		      bpl	.skipXScroll	; 2/3=17/18
    421  3571				   .stopXScroll
    422  3571		       a5 9c		      lda	scrollBits	; 3
    423  3573		       29 fc		      and	#(~(.SCRL_X_BITS >> 4))	; 2
    424  3575		       85 9c		      sta	scrollBits	; 3 =	8
    425  3577				   .skipXScroll
    426  3577							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    427  3577
    428  3577							; *** vertical scrolling (unoptimized version): ***
    429  3577
    430  3577							; check for enabling vertical scrolling:
    431  3577		       a5 a0		      lda	ManY	; 3
    432  3579		       38		      sec		; 2
    433  357a		       e5 9a		      sbc	BoardScrollY	; 3
    434  357c		       a8		      tay		; 2	     for later use
    435  357d		       a9 44		      lda	#.SCRL_UP_BIT	; 2
    436  357f		       c0 02		      cpy	#.SCRL_START_UP	; 2	     <2?
    437  3581		       30 06		      bmi	.startYScroll	; 2/3	     yes, scroll up
    438  3583		       c0 06		      cpy	#.SCRL_START_DOWN	; 2	     <6?
    439  3585		       30 08		      bmi	.skipStartYScroll	; 2/3
    440  3587		       a9 88		      lda	#.SCRL_DOWN_BIT	; 2 = 22    yes, scroll down
    441  3589				   .startYScroll
    442  3589		       29 0c		      and	#.SCRL_Y_BITS >> 4	; 2
    443  358b		       05 9c		      ora	scrollBits	; 3
    444  358d		       85 9c		      sta	scrollBits	; 3 =	8
    445  358f				   .skipStartYScroll
    446  358f
    447  358f							; do vertical scrolling:
    448  358f		       a5 9c		      lda	scrollBits	; 3
    449  3591		       29 cc		      and	#.SCRL_Y_BITS	; 2
    450  3593		       f0 23		      beq	.skipYScroll	; 2/3
    451  3595		       29 88		      and	#.SCRL_DOWN_BIT	; 2
    452  3597		       d0 0c		      bne	.yScrollDown	; 2/3=11/12
    453  3599
    454  3599							; scroll up
    455  3599		       a5 9a		      lda	BoardScrollY	; 3
    456  359b		       f0 15		      beq	.stopYScroll	; 2
    457  359d		       c6 9a		      dec	BoardScrollY	; 5
    458  359f		       c0 01		      cpy	#.SCRL_STOP_UP-1	; 2
    459  35a1		       10 0f		      bpl	.stopYScroll	; 2/3=15
    460  35a3		       30 13		      bmi	.skipYScroll	; 3
    461  35a5							;---------------------------------------
    462  35a5				   .yScrollDown
    463  35a5		       a6 9a		      ldx	BoardScrollY	; 3
    464  35a7		       e8		      inx		; 2
    465  35a8		       e4 99		      cpx	BoardEdge_Bottom	;     ; 3
    466  35aa		       10 06		      bpl	.stopYScroll	; 2/3
    467  35ac		       86 9a		      stx	BoardScrollY	; 3
    468  35ae		       c0 07		      cpy	#.SCRL_STOP_DOWN+1	; 2
    469  35b0		       10 06		      bpl	.skipYScroll	; 2/3=17/18
    470  35b2				   .stopYScroll
    471  35b2		       a5 9c		      lda	scrollBits	; 3
    472  35b4		       29 f3		      and	#(~(.SCRL_Y_BITS >> 4))	; 2
    473  35b6		       85 9c		      sta	scrollBits	; 3 =	8
    474  35b8				   .skipYScroll
    475  35b8							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    476  35b8
    477  35b8		       60	   EarlyAbortx rts		; 6 =	6
    478  35b9							; total: 5+67*2+6 = 145
    479  35b9
    480  35b9							;------------------------------------------------------------------------------
    481  35b9
    482  35b9
    483  35b9
    484  35b9							; worst case time from positive last check to rts: 123
    485  35b9							; cycles until 0-check: 15
    486  35b9							; minimum cycles available after last positive check until timer turns 0: (MINIMUM_SORT_TIME-1)*64+1
    487  35b9							; MINIMUM_SORT_TIME = 3 = 129
    488  35b9							; MINIMUM_SORT_TIME = 4 = 193 <- ok
    489  35b9
    490  35b9							;------------------------------------------------------------------------------
    491  35b9
    492  35b9							;    DEFINE_SUBROUTINE PrepareTimeVector ; = 27
    493  35b9
    494  35b9							;		  ldx ScreenDrawPhase		  ; 3		; current phase of drawing
    495  35b9							;		  lda TS_PhaseVectorLO,x	  ; 4
    496  35b9							;		  sta TS_Vector 		  ; 3
    497  35b9							;		  lda TS_PhaseVectorHI,x	  ; 4
    498  35b9							;		  sta TS_Vector+1		  ; 3
    499  35b9
    500  35b9							;		  lda TS_PhaseBank,x		  ; 4
    501  35b9							;sta ROM_Bank			  ; 4	     GUESS!  SEEMS TO RUN OK WITHOUT THIS.
    502  35b9							;		  rts				  ; 6
    503  35b9
    504  35b9							;------------------------------------------------------------------------------
    505  35b9
    506  35b9							; This is a GOOD home for these tables.  Move AD's tables here and fix code appropriately
    507  35b9
      0  35b9					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  35b9		       00 06	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  35b9					      SUBROUTINE
      3  35b9				   TS_PhaseVectorLO
    509  35b9
    510  35b9							; Gives LO byte of addresses of subroutines for timeslice processing
    511  35b9
    512  35b9		       a9		      .byte.b	<ProcessObjStack
    513  35ba		       ef		      .byte.b	<ProcessBlankStack
    514  35bb		       ce		      .byte.b	<DrawFullScreen
    515  35bc		       2b		      .byte.b	<BuildDrawStack
    516  35bd		       32		      .byte.b	<DrawAIntoStack
    517  35be		       06		      .byte.b	<SwitchObjects
    518  35bf
    519  35bf				   TS_PhaseVectorHI
    520  35bf
    521  35bf							; Gives HI byte of addresses of subroutines for timeslice processing
    522  35bf
    523  35bf		       f8		      .byte.b	>ProcessObjStack
    524  35c0		       f8		      .byte.b	>ProcessBlankStack
    525  35c1		       f3		      .byte.b	>DrawFullScreen
    526  35c2		       fb		      .byte.b	>BuildDrawStack
    527  35c3		       fb		      .byte.b	>DrawAIntoStack
    528  35c4		       f9		      .byte.b	>SwitchObjects
    529  35c5
    530  35c5				   TS_PhaseBank
    531  35c5
    532  35c5							; Gives bank of subroutines for timeslice processing
    533  35c5
    534  35c5		       0f		      .byte.b	BANK_ProcessObjStack
    535  35c6		       0f		      .byte.b	BANK_ProcessBlankStack
    536  35c7		       07		      .byte.b	BANK_DrawFullScreen
    537  35c8		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    538  35c9		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    539  35ca		       0f		      .byte.b	BANK_SwitchObjects
    540  35cb
    541  35cb							;------------------------------------------------------------------------------
    542  35cb		       02 02	   lookColour2 .byte.b	$02, $02
    543  35cd		       04 04		      .byte.b	$04, $04
    544  35cf
    545  35cf				   OverscanTime
    546  35cf		       33 33		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    547  35d1		       46 33		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    548  35d3
    549  35d3
    550  35d3
    551  35d3
      0  35d3					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  35d3		       00 06	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  35d3					      SUBROUTINE
      3  35d3				   PostScreenCleanup
    553  35d3
    554  35d3		       c8		      iny		; --> 0
    555  35d4
    556  35d4		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    557  35d6							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    558  35d6
    559  35d6		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    560  35d8							; TJ: no idea why, but you had removed it in revision 758 ;)
    561  35d8							; completely accidental -- one of our cats may have deleted it.
    562  35d8		       84 4e		      sty	PF1
    563  35da		       84 4f		      sty	PF2
    564  35dc		       84 5d		      sty	ENAM0
    565  35de		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    566  35e0		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    567  35e2
    568  35e2
    569  35e2
    570  35e2							; D1 VBLANK turns off beam
    571  35e2							; It needs to be turned on 37 scanlines later
    572  35e2
    573  35e2		       a9 42		      lda	#%01000010	; bit6 is not required
    574  35e4		       85 41		      sta	VBLANK	; end of screen - enter blanking
    575  35e6
    576  35e6							;------------------------------------------------------------------------------
    577  35e6							; This is where the PAL system has a bit of extra time on a per-frame basis.
    578  35e6
    579  35e6		       a6 81		      ldx	Platform
    580  35e8		       bd cf f5 	      lda	OverscanTime,x
    581  35eb		       8d 96 02 	      sta	TIM64T
    582  35ee
    583  35ee							; Background colour priorities. Increasing order of priority...
    584  35ee							;	black -- nothing happening
    585  35ee							;	looking around			     lookingAround<0		     BLUE
    586  35ee							;	when paused			     gameMode... BIT7		     RED
    587  35ee							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    588  35ee
    589  35ee
    590  35ee		       a5 aa		      lda	LookingAround
    591  35f0		       10 02		      bpl	nolooker	; if not looking around, that will do nicely
    592  35f2		       a0 00		      ldy	#0	;sok
    593  35f4							;		  ldy lookColour2,x		  ; otherwise, use the lookaround colour as the base
    594  35f4		       84 af	   nolooker   sty	BGColour	; 'BASE' colour pause reverts TO when unpaused
    595  35f6
    596  35f6		       a5 b4		      lda	ThrottleSpeed
    597  35f8		       18		      clc
    598  35f9		       65 b3		      adc	Throttle
    599  35fb		       b0 02		      bcs	noVerflo
    600  35fd		       85 b3		      sta	Throttle
    601  35ff				   noVerflo
    602  35ff
    603  35ff
    604  35ff							;----------------------------------------------------------------------------------------------
    605  35ff							; handle pause button for 2600 and 7800
    606  35ff
    607  35ff							; Timings:  NOT including palette setting or platform detect
    608  35ff							; 2600:     no button press:	 11 cycles
    609  35ff							;	     with button press:  21 cycles
    610  35ff							; 7800      no button press:	 16 cycles
    611  35ff							;	     with button press:  21 cycles
    612  35ff
    613  35ff
    614  35ff
    615  35ff		       00 08	   BW_SWITCH  =	$08	; NOTE: Shares bit position with SWCHB COLOUR/B&W SWITCH
    616  35ff
    617  35ff		       24 80		      bit	gameMode
    618  3601		       50 0b		      bvc	.pause7800	; 7800 platform
    619  3603
    620  3603							; 2600 pause logic...
    621  3603
    622  3603		       ad 82 02 	      lda	SWCHB
    623  3606		       45 80		      eor	gameMode
    624  3608		       29 08		      and	#BW_SWITCH
    625  360a		       f0 17		      beq	.setPauseCol	; no different to original state = no pause change
    626  360c		       d0 0f		      bne	.buttonDown	; unconditional
    627  360e
    628  360e							; 7800 pause logic...
    629  360e
    630  360e							; When the button is pressed, we check if it's the FIRST time it's pressed.
    631  360e							; This FIRST time is indicated by the PFLAG7800 being clear.  If it's the first time, we toggle the pause
    632  360e							; flag (BIT6) AND we toggle the PFLAG7800 so continued button-down does nothing.  When the button is
    633  360e							; released, then we again toggle the PFLAG7800, allowing a FIRST time check once again, when the button
    634  360e							; is next pressed.
    635  360e
    636  360e		       a9 08	   .pause7800 lda	#BW_SWITCH
    637  3610		       2c 82 02 	      bit	SWCHB
    638  3613		       f0 04		      beq	.pausePress
    639  3615		       05 80		      ora	gameMode	; not pressed, so enable first time press
    640  3617		       d0 08		      bne	.fixPause	; unconditional
    641  3619
    642  3619		       24 80	   .pausePress bit	gameMode
    643  361b		       f0 06		      beq	.setPauseCol	; NOT the first time in pause - so do nothing new
    644  361d
    645  361d							; Button is down, and we have detected it as a FIRST-TIME button press.
    646  361d
    647  361d		       45 80	   .buttonDown eor	gameMode	; toggle first time flag(7800) or current switch state(2600)
    648  361f		       49 80		      eor	#GAMEMODE_PAUSED	; toggle pause flag
    649  3621		       85 80	   .fixPause  sta	gameMode
    650  3623
    651  3623		       a5 80	   .setPauseCol lda	gameMode	; are we paused?
    652  3625		       10 07		      bpl	.exitPause	; only show pause colour when actually paused
    653  3627
    654  3627		       a6 81		      ldx	Platform
    655  3629		       bd 9a f6 	      lda	pscol,x
    656  362c		       85 af		      sta	BGColour	; set main screen background colour.  RED is paused.
    657  362e
    658  362e				   .exitPause
    659  362e
    660  362e							;----------------------------------------------------------------------------------------------
    661  362e
    662  362e							; has to be done AFTER screen display, because it disables the effect!
    663  362e		       a5 87		      lda	rnd	; 3	 randomly reposition the Cosmic Ark missile
    664  3630		       85 62		      sta	HMM0	; 3	 this assumes that HMOVE is called at least once/frame
    665  3632
    666  3632							; "Flash" has highest BG colour priority
    667  3632
    668  3632		       a6 c5		      ldx	ColourTimer
    669  3634		       f0 06		      beq	noFlashBG
    670  3636		       c6 c5		      dec	ColourTimer
    671  3638		       a9 0e		      lda	#WHITE
    672  363a		       85 af		      sta	BGColour
    673  363c				   noFlashBG
    674  363c
    675  363c		       a5 c6		      lda	extraLifeTimer
    676  363e		       f0 02		      beq	alreadyBlack2
    677  3640		       c6 c6		      dec	extraLifeTimer
    678  3642				   alreadyBlack2
    679  3642
    680  3642							; Handle the player joystick reading. We do it *every frame* so that we can incorporate a two-frame
    681  3642							; buffer.  This is designed to give a little better responsiveness to the 'quick tap' movement.
    682  3642
    683  3642		       a5 95		      lda	BufferedJoystick	; previous frame
    684  3644		       85 96		      sta	BufferedJoystick+1	; -> buffered
    685  3646
    686  3646							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    687  3646							; P2 is shifted UP, so we don't need to worry in usage elsewhere (it's same format as a P1 joystick)
    688  3646
    689  3646		       a5 9e		      lda	whichPlayer	; 3
    690  3648		       25 ac		      and	jtoggle	; 3
    691  364a		       aa		      tax		; 2
    692  364b
    693  364b		       b5 4c		      lda	INPT4,x	; 4
    694  364d		       85 97		      sta	BufferedButton	; 3 = 15
    695  364f
    696  364f		       ad 80 02 	      lda	SWCHA	; 4
    697  3652
    698  3652		       ca		      dex		; 2
    699  3653		       30 04		      bmi	notP2	; 2/3= 8/9
    700  3655
    701  3655		       0a		      asl		; 2
    702  3656		       0a		      asl		; 2
    703  3657		       0a		      asl		; 2
    704  3658		       0a		      asl		; 2 =	8
    705  3659		       85 95	   notP2      sta	BufferedJoystick	; 3
    706  365b
    707  365b
    708  365b							; "Scoring timer" reset stomp comment
    709  365b
    710  365b		       a5 c7		      lda	scoringTimer
    711  365d		       f0 0a		      beq	timer0now
    712  365f		       c6 c7		      dec	scoringTimer
    713  3661		       d0 06		      bne	timer0now
    714  3663		       a5 c8		      lda	scoringFlags
    715  3665		       29 fc		      and	#<(~DISPLAY_FLAGS)	;	 switches to time display
    716  3667		       85 c8		      sta	scoringFlags
    717  3669				   timer0now
    718  3669
    719  3669							; fall through
    720  3669
    721  3669							;-------------------------------------------------------------------------------------
    722  3669							; Player animation happens *every* frame so that we get good animation speeds.  Note that
    723  3669							; the player animation consists of running a small animation 'program', and then actually drawing
    724  3669							; the player.	The draw is the neat bit, because all it does is update some self-modifying pointers
    725  3669							; inside the actual draw kernel in the appropriate bank.
    726  3669
    727  3669
      0  3669					      DEFINE_SUBROUTINE	AnimatePlayers	; in GENERIC_BANK_1
      1  3669		       00 06	   BANK_AnimatePlayers =	_CURRENT_BANK
      2  3669					      SUBROUTINE
      3  3669				   AnimatePlayers
    729  3669
    730  3669							; Optimised 7/1/2012 -- single page tables
    731  3669
    732  3669							; This interesting code performs the animations for the player(s) and sets the
    733  3669							; pointers INSIDE the row bank for the draw code to point to the correct player
    734  3669							; shape.  Kind of neat, as it doesn't require any shape copying (=speed!)
    735  3669
    736  3669
    737  3669							; Cycle the player through his animation list.  The animation of a player is a direct
    738  3669							; pointer to the actual shape used to display the player.  This shape is in turn
    739  3669							; written to the current bank's self-modifying locations for the draw.  Since
    740  3669							; we are effectively drawing from this current bank, the same code can be used
    741  3669							; to 'undraw' the player as required.
    742  3669
    743  3669
    744  3669							; x = player index
    745  3669							; sets ManAnimation = FRAME to display for player
    746  3669							; ManAnimation = index of player program into Manimate list
    747  3669
    748  3669		       24 80		      bit	gameMode
    749  366b		       30 2c		      bmi	AnimationOK	; don't animate during pause
    750  366d
    751  366d		       c6 a4		      dec	ManDelayCount
    752  366f		       10 28		      bpl	AnimationOK
    753  3671
    754  3671		       a4 a5	   ReloadAnimation ldy	ManAnimation
    755  3673		       b9 02 f5    ContinueAnim lda	Manimate,y	; delay count
    756  3676		       d0 07		      bne	NewFrameOK
    757  3678		       b9 03 f5 	      lda	Manimate+1,y
    758  367b		       a8		      tay
    759  367c		       4c 73 f6 	      jmp	ContinueAnim
    760  367f
    761  367f		       10 0d	   NewFrameOK bpl	doDelay
    762  3681
    763  3681		       c8		      iny		; handle a REFLECT
    764  3682		       a5 a8		      lda	ManLastDirection
    765  3684		       29 f7		      and	#%11110111
    766  3686		       19 02 f5 	      ora	Manimate,y
    767  3689		       85 a8		      sta	ManLastDirection
    768  368b
    769  368b		       c8		      iny
    770  368c		       d0 e5		      bne	ContinueAnim
    771  368e
    772  368e		       85 a4	   doDelay    sta	ManDelayCount
    773  3690
    774  3690		       c8		      iny
    775  3691		       b9 02 f5 	      lda	Manimate,y
    776  3694		       85 a7		      sta	ManAnimationFrameLO
    777  3696
    778  3696		       c8		      iny
    779  3697		       84 a5		      sty	ManAnimation
    780  3699
    781  3699		       60	   AnimationOK rts
    782  369a
    783  369a
    784  369a
    785  369a		       40 40	   pscol      .byte.b	$40, $40
    786  369c		       60 60		      .byte.b	$60, $60
    787  369e
    788  369e							;------------------------------------------------------------------------------
    789  369e
------- FILE i2c_v2.2.inc LEVEL 3 PASS 3
      0  369e					      include	"i2c_v2.2.inc"
      1  369e							;
      2  369e							; i2c_v2.2.inc
      3  369e							;
      4  369e							;
      5  369e							; AtariVox EEPROM Driver
      6  369e							;
      7  369e							; By Alex Herbert, 2004
      8  369e							;
      9  369e							; Optimisations by Thomas Jentzsch, 2006/2008
     10  369e							;
     11  369e
     12  369e
     13  369e							; I/O Constants
     14  369e
     15  369e		       00 04	   I2C_SDA_MASK equ	$04
     16  369e		       00 08	   I2C_SCL_MASK equ	$08
     17  369e
     18  369e
     19  369e							; Signalling Macros
     20  369e
     21  369e							;  MAC     I2C_SCL_0
     22  369e							;    lda     #$00
     23  369e							;    sta     SWCHA
     24  369e							;  ENDM
     25  369e
     26  369e							;  MAC     I2C_SCL_1
     27  369e							;    lda     #I2C_SCL_MASK
     28  369e							;    sta     SWCHA
     29  369e							;  ENDM
     30  369e
     31  369e							;  MAC     I2C_SDA_IN
     32  369e							;    lda     #I2C_SCL_MASK
     33  369e							;    sta     SWACNT
     34  369e							;  ENDM
     35  369e
     36  369e							;  MAC     I2C_SDA_OUT
     37  369e							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  369e							;    sta     SWACNT
     39  369e							;  ENDM
     40  369e
     41  369e
     42  369e					      MAC	i2c_start
     43  369e							; I2C_SCL_1
     44  369e					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  369e					      sta	SWCHA	; 4
     46  369e							; I2C_SDA_OUT
     47  369e					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  369e					      sta	SWACNT	; 4
     49  369e							; total: 12 cycles
     50  369e					      ENDM
     51  369e
     52  369e
     53  369e					      MAC	i2c_txbit
     54  369e							; I2C_SCL_0
     55  369e					      lda	#%0011	; 2
     56  369e					      sta	SWCHA	; 4
     57  369e							; set bit
     58  369e					      adc	#%1000	; 2
     59  369e					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  369e							; I2C_SCL_1
     61  369e					      lda	#I2C_SCL_MASK	; 2
     62  369e					      sta	SWCHA	; 4
     63  369e							; total: 18 cycles
     64  369e					      ENDM
     65  369e
     66  369e
     67  369e					      MAC	i2c_txnack
     68  369e							; I2C_SCL_0
     69  369e					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  369e					      sta	SWCHA	; 4
     71  369e							; I2C_SDA_IN
     72  369e					      lsr		; 2	     I2C_SCL_MASK
     73  369e					      sta	SWACNT	; 4
     74  369e							; I2C_SCL_1
     75  369e					      nop		; 2	     required for timing!
     76  369e					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  369e							; total: 18 cycles
     78  369e					      ENDM
     79  369e
     80  369e
     81  369e							; Subroutine Macros
     82  369e
     83  369e					      MAC	i2c_subs
     84  369e
     85  369e				   i2c_startread
     86  369e							; use V to flag if previous byte needs ACK
     87  369e					      ldy	#%10100001	; 2	     eeprom read command
     88  369e					      .byte	$2c	; 2
     89  369e				   i2c_startwrite
     90  369e					      ldy	#%10100000	; 2	     eeprom write command
     91  369e					      I2C_START		;12	     start signal (clears V flag)
     92  369e					      tya		; 2 = 16
     93  369e				   i2c_txbyte
     94  369e					      eor	#$ff	; 2	     invert data byte
     95  369e					      sec		; 2
     96  369e					      rol		; 2 =	6    shift loop bit into a
     97  369e				   i2c_txbyteloop
     98  369e					      tay		; 2
     99  369e					      I2C_TXBIT		;18	     transmit
    100  369e					      tya		; 2
    101  369e					      asl		; 2	     shift next bit into C
    102  369e					      bne	i2c_txbyteloop	; 2= 26/27
    103  369e
    104  369e							; receive acknowledge bit
    105  369e
    106  369e					      beq	i2c_rxbit	;43 = 43
    107  369e							; i2c_txbyte: 264 cycles
    108  369e							;-------------------------------------------------------------------------------
    109  369e
    110  369e				   i2c_rxbyte
    111  369e					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  369e					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  369e
    114  369e				   i2c_rxskipack
    115  369e					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  369e
    117  369e					      lda	#1	; 2
    118  369e				   i2c_rxbyteloop
    119  369e					      tay		; 2 =	2
    120  369e				   i2c_rxbit		;	     receive bit in C
    121  369e					      I2C_TXNACK		;18 = 18
    122  369e
    123  369e					      lda	SWCHA	; 4
    124  369e					      lsr		; 2
    125  369e					      lsr		; 2
    126  369e					      lsr		; 2 = 10    C = SDA
    127  369e
    128  369e					      tya		; 2
    129  369e					      rol		; 2	     rotate into Y
    130  369e					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  369e
    132  369e							; received byte in A
    133  369e					      rts		; 6 =	6
    134  369e							; i2c_rxbit:  40 cycles
    135  369e							; i2c_rxbyte: 310/333 cycles
    136  369e							;-------------------------------------------------------------------------------
    137  369e
    138  369e				   i2c_stopread
    139  369e					      bvc	i2c_stopwrite	; 2
    140  369e					      ldy	#$80	; 2
    141  369e					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  369e
    143  369e				   i2c_stopwrite
    144  369e					      jsr	i2c_txack	;30
    145  369e
    146  369e							; return port to input mode
    147  369e					      lda	#0	; 2	     0
    148  369e					      sta	SWACNT	; 4
    149  369e					      rts		; 6 = 12
    150  369e							; i2c_stopread:  45/92
    151  369e							; i2c_stopwrite: 42
    152  369e							;-------------------------------------------------------------------------------
    153  369e
    154  369e				   i2c_txack
    155  369e							; I2C_SCL_0
    156  369e					      lda	#0	; 2	     $00
    157  369e					      sta	SWCHA	; 4
    158  369e							; I2C_SDA_OUT
    159  369e					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  369e					      sta	SWACNT	; 4
    161  369e							; I2C_SCL_1
    162  369e					      asl		; 2	     I2C_SCL_MASK
    163  369e					      sta	SWCHA	; 4
    164  369e
    165  369e					      rts		; 6
    166  369e							; total: 24 cycles
    167  369e							;-------------------------------------------------------------------------------
    168  369e
    169  369e					      ENDM
    170  369e
    171  369e
    172  369e
------- FILE BANK_GENERIC.asm
    791  369e
      0  369e					      i2c_subs
      1  369e
      2  369e				   i2c_startread
      3  369e
      4  369e		       a0 a1		      ldy	#%10100001
      5  36a0		       2c		      .byte.b	$2c
      6  36a1				   i2c_startwrite
      7  36a1		       a0 a0		      ldy	#%10100000
      0  36a3					      I2C_START
      1  36a3
      2  36a3		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  36a5		       8d 80 02 	      sta	SWCHA
      4  36a8
      5  36a8		       4a		      lsr
      6  36a9		       8d 81 02 	      sta	SWACNT
      7  36ac
      9  36ac		       98		      tya
     10  36ad				   i2c_txbyte
     11  36ad		       49 ff		      eor	#$ff
     12  36af		       38		      sec
     13  36b0		       2a		      rol
     14  36b1				   i2c_txbyteloop
     15  36b1		       a8		      tay
      0  36b2					      I2C_TXBIT
      1  36b2
      2  36b2		       a9 03		      lda	#%0011
      3  36b4		       8d 80 02 	      sta	SWCHA
      4  36b7
      5  36b7		       69 08		      adc	#%1000
      6  36b9		       8d 81 02 	      sta	SWACNT
      7  36bc
      8  36bc		       a9 08		      lda	#I2C_SCL_MASK
      9  36be		       8d 80 02 	      sta	SWCHA
     10  36c1
     17  36c1		       98		      tya
     18  36c2		       0a		      asl
     19  36c3		       d0 ec		      bne	i2c_txbyteloop
     20  36c5
     21  36c5
     22  36c5
     23  36c5		       f0 0b		      beq	i2c_rxbit
     24  36c7
     25  36c7
     26  36c7
     27  36c7				   i2c_rxbyte
     28  36c7		       50 03		      bvc	i2c_rxskipack
     29  36c9		       20 fa f6 	      jsr	i2c_txack
     30  36cc
     31  36cc				   i2c_rxskipack
     32  36cc		       2c c7 f6 	      bit	i2c_rxbyte
     33  36cf
     34  36cf		       a9 01		      lda	#1
     35  36d1				   i2c_rxbyteloop
     36  36d1		       a8		      tay
     37  36d2				   i2c_rxbit
      0  36d2					      I2C_TXNACK
      1  36d2
      2  36d2		       a9 10		      lda	#I2C_SCL_MASK*2
      3  36d4		       8d 80 02 	      sta	SWCHA
      4  36d7
      5  36d7		       4a		      lsr
      6  36d8		       8d 81 02 	      sta	SWACNT
      7  36db
      8  36db		       ea		      nop
      9  36dc		       8d 80 02 	      sta	SWCHA
     10  36df
     39  36df
     40  36df		       ad 80 02 	      lda	SWCHA
     41  36e2		       4a		      lsr
     42  36e3		       4a		      lsr
     43  36e4		       4a		      lsr
     44  36e5
     45  36e5		       98		      tya
     46  36e6		       2a		      rol
     47  36e7		       90 e8		      bcc	i2c_rxbyteloop
     48  36e9
     49  36e9
     50  36e9		       60		      rts
     51  36ea
     52  36ea
     53  36ea
     54  36ea
     55  36ea				   i2c_stopread
     56  36ea		       50 05		      bvc	i2c_stopwrite
     57  36ec		       a0 80		      ldy	#$80
     58  36ee		       20 d2 f6 	      jsr	i2c_rxbit
     59  36f1
     60  36f1				   i2c_stopwrite
     61  36f1		       20 fa f6 	      jsr	i2c_txack
     62  36f4
     63  36f4
     64  36f4		       a9 00		      lda	#0
     65  36f6		       8d 81 02 	      sta	SWACNT
     66  36f9		       60		      rts
     67  36fa
     68  36fa
     69  36fa
     70  36fa
     71  36fa				   i2c_txack
     72  36fa
     73  36fa		       a9 00		      lda	#0
     74  36fc		       8d 80 02 	      sta	SWCHA
     75  36ff
     76  36ff		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  3701		       8d 81 02 	      sta	SWACNT
     78  3704
     79  3704		       0a		      asl
     80  3705		       8d 80 02 	      sta	SWCHA
     81  3708
     82  3708		       60		      rts
     83  3709
     84  3709
     85  3709
    793  3709
    794  3709				   HandleSaveKey SUBROUTINE
    795  3709
    796  3709		       06 00	   SAVEKEY_ADR =	$0600	;	     reserved address for Boulder Dash (64 bytes)
    797  3709
    798  3709							; SK Memory Map:
    799  3709							;		 cave	 level
    800  3709							; $0600-$0602	 A	 1
    801  3709							; $0603-$0605	 A	 2
    802  3709							; $0606-$0608	 A	 3
    803  3709							; $0609-$060b	 A	 4
    804  3709							; $060c-$060e	 A	 5
    805  3709							; $060f-$0611	 E	 1
    806  3709							; $0612-$0614	 E	 2
    807  3709							; $0615-$0617	 E	 3
    808  3709							; $0618-$061a	 unused
    809  3709							; $061b-$061d	 unused
    810  3709							; $061e-$0620	 I	 1
    811  3709							; $0621-$0623	 I	 2
    812  3709							; $0624-$0626	 I	 3
    813  3709							; $0627-$0629	 unused
    814  3709							; $062a-$062c	 unused
    815  3709							; $062d-$062f	 M	 1
    816  3709							; $0630-$0632	 M	 2
    817  3709							; $0633-$0635	 M	 3
    818  3709							; $0636-$063f	 unused
    819  3709
    820  3709							;------------------------------------------------------------------------------
      0  3709					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  3709		       00 06	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  3709					      SUBROUTINE
      3  3709				   ReadSaveKey
    822  3709
    823  3709							; assume no SaveKey found:
    824  3709		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    825  370b		       85 e4		      sta	highScoreSK+2	; 3
    826  370d
    827  370d							; setup SaveKey:
    828  370d		       a5 e5		      lda	startCave	; 3	     load start cave*5 and level
    829  370f		       a6 b1		      ldx	level	; 3
    830  3711		       20 4a f7 	      jsr	SetupSaveKey	;6+853
    831  3714		       90 52		      bcc	NoSKfound	; 2/3
    832  3716
    833  3716							;    lda     #$34
    834  3716							;    sta     COLUBK
    835  3716
    836  3716							; start read
    837  3716		       20 f1 f6 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    838  3719		       20 9e f6 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    839  371c
    840  371c							; read high score:
    841  371c		       a2 02		      ldx	#3-1	; 2 = 1187
    842  371e				   .loopRead
    843  371e		       20 c7 f6 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    844  3721		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    845  3723		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    846  3725		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    847  3727				   .skipEmpty
    848  3727		       95 e2		      sta	highScoreSK,x	; 4
    849  3729		       ca		      dex		; 2
    850  372a		       10 f2		      bpl	.loopRead	; 2/3= 354
    851  372c
    852  372c							; stop read:
    853  372c		       4c ea f6 	      jmp	i2c_stopread	;3+92=95    terminate read
    854  372f
    855  372f							;------------------------------------------------------------------------------
      0  372f					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  372f		       00 06	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  372f					      SUBROUTINE
      3  372f				   WriteSaveKey
    857  372f
    858  372f							; check if new high score:
    859  372f		       a6 e2		      ldx	highScoreSK	; 3
    860  3731		       e8		      inx		; 2
    861  3732		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    862  3734
    863  3734							; setup SaveKey:
    864  3734		       a5 e5		      lda	startCave	; 3	     load start cave*5 and level
    865  3736		       a6 e6		      ldx	startLevel	; 3
    866  3738		       20 4a f7 	      jsr	SetupSaveKey	; 6+853
    867  373b		       90 2b		      bcc	NoSKfound	; 2/3
    868  373d
    869  373d							;    lda     #$64
    870  373d							;    sta     COLUBK
    871  373d
    872  373d							; write high score:
    873  373d		       a2 02		      ldx	#3-1	; 2 = 841
    874  373f				   .loopWrite
    875  373f		       b5 e2		      lda	highScoreSK,x	; 4
    876  3741		       20 ad f6 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    877  3744		       ca		      dex		; 2
    878  3745		       10 f8		      bpl	.loopWrite	; 2/3= 837
    879  3747
    880  3747							; stop write:
    881  3747		       4c f1 f6 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    882  374a
    883  374a
    884  374a							;------------------------------------------------------------------------------
      0  374a					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  374a		       00 06	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  374a					      SUBROUTINE
      3  374a				   SetupSaveKey
    886  374a
    887  374a							; calculate slot;
    888  374a							; a = cave (5*n): A=$00; E=$05; I=$0a; M=$0f
    889  374a							; x = level (0..4)
    890  374a		       85 e7		      sta	offsetSK	; 3
    891  374c		       8a		      txa		; 2
    892  374d		       18		      clc		; 2
    893  374e		       65 e7		      adc	offsetSK	; 3
    894  3750		       85 e7		      sta	offsetSK	; 3
    895  3752		       0a		      asl		; 2	     multiply by 3
    896  3753		       65 e7		      adc	offsetSK	; 3
    897  3755		       69 00		      adc	#<SAVEKEY_ADR	; 2
    898  3757		       aa		      tax		; 2 = 22
    899  3758							; detect SaveKey:
    900  3758		       20 a1 f6 	      jsr	i2c_startwrite	;6+280
    901  375b		       d0 0a		      bne	.exitSK	; 2/3
    902  375d
    903  375d							; setup address:
    904  375d		       b8		      clv		; 2
    905  375e		       a9 06		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    906  3760		       20 ad f6 	      jsr	i2c_txbyte	;6+264
    907  3763		       8a		      txa		; 2	     x = lower byte offset
    908  3764		       4c ad f6 	      jmp	i2c_txbyte	;3+264      returns C==1
    909  3767
    910  3767				   .exitSK
    911  3767		       18		      clc
    912  3768				   NoSKfound
    913  3768		       60		      rts
    914  3768					      ENDIF
    915  3769
    916  3769
      0  3769					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  3769		       07 69	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $769 , FREE= $97
      2  3769					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3769				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3769				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3769				  -	      ERR
      6  3769					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 3
      0  3769					      include	"BANK_INITBANK.asm"	; MUST be after banks that include caves -- otherwise MAX_CAVEBANK is not calculated properly
      1  3769
      0  3769					      NEWBANK	INITBANK
      1  3c67 ????				      SEG	INITBANK
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   INITBANK   SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	INITBANK
      3  3800
      4  3800		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
      5  3801
      0  3801					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  3801		       00 07	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  3801					      SUBROUTINE
      3  3801				   BoardLineStartLO
      7  3801
      8  3801							; Gives the start address (LO) of each board line
      9  3801
     10  3801				   .BOARD_LOCATION SET	Board
     11  3801					      REPEAT	SIZE_BOARD_Y
     12  3801				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3801				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3801					      ENDIF
     15  3801		       00		      .byte.b	<.BOARD_LOCATION
     16  3801				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3801					      REPEND
     12  3802				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3802				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3802					      ENDIF
     15  3802		       28		      .byte.b	<.BOARD_LOCATION
     16  3802				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3802					      REPEND
     12  3803				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3803				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3803					      ENDIF
     15  3803		       50		      .byte.b	<.BOARD_LOCATION
     16  3803				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3803					      REPEND
     12  3804				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3804				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3804					      ENDIF
     15  3804		       78		      .byte.b	<.BOARD_LOCATION
     16  3804				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3804					      REPEND
     12  3805				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3805				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3805					      ENDIF
     15  3805		       a0		      .byte.b	<.BOARD_LOCATION
     16  3805				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3805					      REPEND
     12  3806				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3806				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3806					      ENDIF
     15  3806		       c8		      .byte.b	<.BOARD_LOCATION
     16  3806				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3806					      REPEND
     12  3807					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3807				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3807					      ENDIF
     15  3807		       00		      .byte.b	<.BOARD_LOCATION
     16  3807				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3807					      REPEND
     12  3808				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3808				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3808					      ENDIF
     15  3808		       28		      .byte.b	<.BOARD_LOCATION
     16  3808				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3808					      REPEND
     12  3809				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3809				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3809					      ENDIF
     15  3809		       50		      .byte.b	<.BOARD_LOCATION
     16  3809				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3809					      REPEND
     12  380a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  380a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  380a					      ENDIF
     15  380a		       78		      .byte.b	<.BOARD_LOCATION
     16  380a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  380a					      REPEND
     12  380b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  380b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  380b					      ENDIF
     15  380b		       a0		      .byte.b	<.BOARD_LOCATION
     16  380b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  380b					      REPEND
     12  380c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  380c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  380c					      ENDIF
     15  380c		       c8		      .byte.b	<.BOARD_LOCATION
     16  380c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  380c					      REPEND
     12  380d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  380d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  380d					      ENDIF
     15  380d		       00		      .byte.b	<.BOARD_LOCATION
     16  380d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  380d					      REPEND
     12  380e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  380e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  380e					      ENDIF
     15  380e		       28		      .byte.b	<.BOARD_LOCATION
     16  380e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  380e					      REPEND
     12  380f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  380f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  380f					      ENDIF
     15  380f		       50		      .byte.b	<.BOARD_LOCATION
     16  380f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  380f					      REPEND
     12  3810				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3810				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3810					      ENDIF
     15  3810		       78		      .byte.b	<.BOARD_LOCATION
     16  3810				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3810					      REPEND
     12  3811				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3811				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3811					      ENDIF
     15  3811		       a0		      .byte.b	<.BOARD_LOCATION
     16  3811				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3811					      REPEND
     12  3812				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3812				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3812					      ENDIF
     15  3812		       c8		      .byte.b	<.BOARD_LOCATION
     16  3812				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3812					      REPEND
     12  3813					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3813				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3813					      ENDIF
     15  3813		       00		      .byte.b	<.BOARD_LOCATION
     16  3813				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3813					      REPEND
     12  3814				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3814				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3814					      ENDIF
     15  3814		       28		      .byte.b	<.BOARD_LOCATION
     16  3814				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3814					      REPEND
     12  3815				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3815				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3815					      ENDIF
     15  3815		       50		      .byte.b	<.BOARD_LOCATION
     16  3815				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3815					      REPEND
     12  3816				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3816				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3816					      ENDIF
     15  3816		       78		      .byte.b	<.BOARD_LOCATION
     16  3816				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     17  3817					      REPEND
      0  3817					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  3817					      LIST	ON
     19  3817
     20  3817		       03 a0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     21  3817
     22  3817							;------------------------------------------------------------------------------
     23  3817
     24  3817				   BoardLineStartHiR
     25  3817
     26  3817							; Gives the start address (HI) of each board line
     27  3817							; Note this caters for the memory wrapping when we go from bank to bank, as
     28  3817							; the board overlays multiple banks!
     29  3817
     30  3817				   .BOARD_LOCATION SET	Board
     31  3817					      REPEAT	SIZE_BOARD_Y
     32  3817				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3817				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3817					      ENDIF
     35  3817		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3817				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3817					      REPEND
     32  3818				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3818				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3818					      ENDIF
     35  3818		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3818				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3818					      REPEND
     32  3819				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3819				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3819					      ENDIF
     35  3819		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3819				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3819					      REPEND
     32  381a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  381a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  381a					      ENDIF
     35  381a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  381a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  381a					      REPEND
     32  381b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  381b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  381b					      ENDIF
     35  381b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  381b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  381b					      REPEND
     32  381c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  381c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  381c					      ENDIF
     35  381c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  381c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  381c					      REPEND
     32  381d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  381d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  381d					      ENDIF
     35  381d		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  381d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  381d					      REPEND
     32  381e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  381e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  381e					      ENDIF
     35  381e		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  381e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  381e					      REPEND
     32  381f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  381f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  381f					      ENDIF
     35  381f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  381f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  381f					      REPEND
     32  3820				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3820				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3820					      ENDIF
     35  3820		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3820				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3820					      REPEND
     32  3821				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3821				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3821					      ENDIF
     35  3821		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3821				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3821					      REPEND
     32  3822				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3822				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3822					      ENDIF
     35  3822		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3822				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3822					      REPEND
     32  3823					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3823				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3823					      ENDIF
     35  3823		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3823				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3823					      REPEND
     32  3824				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3824				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3824					      ENDIF
     35  3824		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3824				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3824					      REPEND
     32  3825				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3825				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3825					      ENDIF
     35  3825		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3825				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3825					      REPEND
     32  3826				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3826				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3826					      ENDIF
     35  3826		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3826				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3826					      REPEND
     32  3827				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3827				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3827					      ENDIF
     35  3827		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3827				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3827					      REPEND
     32  3828				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3828				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3828					      ENDIF
     35  3828		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3828				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3828					      REPEND
     32  3829					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3829				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3829					      ENDIF
     35  3829		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3829				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3829					      REPEND
     32  382a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  382a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  382a					      ENDIF
     35  382a		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  382a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  382a					      REPEND
     32  382b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  382b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  382b					      ENDIF
     35  382b		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  382b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  382b					      REPEND
     32  382c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  382c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  382c					      ENDIF
     35  382c		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  382c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     37  382d					      REPEND
      0  382d					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  382d					      LIST	ON
     39  382d							;------------------------------------------------------------------------------
     40  382d
     41  382d				   BoardLineStartHiW
     42  382d
     43  382d							; Gives the start address (HI) of each board line
     44  382d							; Note this caters for the memory wrapping when we go from bank to bank, as
     45  382d							; the board overlays multiple banks!
     46  382d
     47  382d				   .BOARD_LOCATION SET	Board
     48  382d					      REPEAT	SIZE_BOARD_Y
     49  382d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  382d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  382d					      ENDIF
     52  382d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  382d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  382d					      REPEND
     49  382e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  382e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  382e					      ENDIF
     52  382e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  382e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  382e					      REPEND
     49  382f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  382f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  382f					      ENDIF
     52  382f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  382f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  382f					      REPEND
     49  3830				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3830				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3830					      ENDIF
     52  3830		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3830				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3830					      REPEND
     49  3831				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3831				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3831					      ENDIF
     52  3831		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3831				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3831					      REPEND
     49  3832				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3832				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3832					      ENDIF
     52  3832		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3832				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3832					      REPEND
     49  3833					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3833				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3833					      ENDIF
     52  3833		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3833				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3833					      REPEND
     49  3834				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3834				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3834					      ENDIF
     52  3834		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3834				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3834					      REPEND
     49  3835				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3835				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3835					      ENDIF
     52  3835		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3835				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3835					      REPEND
     49  3836				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3836				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3836					      ENDIF
     52  3836		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3836				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3836					      REPEND
     49  3837				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3837				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3837					      ENDIF
     52  3837		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3837				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3837					      REPEND
     49  3838				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3838				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3838					      ENDIF
     52  3838		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3838				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3838					      REPEND
     49  3839					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3839				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3839					      ENDIF
     52  3839		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3839				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3839					      REPEND
     49  383a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  383a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  383a					      ENDIF
     52  383a		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  383a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  383a					      REPEND
     49  383b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  383b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  383b					      ENDIF
     52  383b		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  383b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  383b					      REPEND
     49  383c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  383c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  383c					      ENDIF
     52  383c		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  383c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  383c					      REPEND
     49  383d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  383d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  383d					      ENDIF
     52  383d		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  383d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  383d					      REPEND
     49  383e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  383e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  383e					      ENDIF
     52  383e		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  383e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  383e					      REPEND
     49  383f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  383f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  383f					      ENDIF
     52  383f		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  383f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  383f					      REPEND
     49  3840				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3840				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3840					      ENDIF
     52  3840		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3840				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3840					      REPEND
     49  3841				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3841				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3841					      ENDIF
     52  3841		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3841				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3841					      REPEND
     49  3842				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3842				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3842					      ENDIF
     52  3842		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3842				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     54  3843					      REPEND
      0  3843					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  3843					      LIST	ON
     56  3843
     57  3843							;------------------------------------------------------------------------------
     58  3843				  -	      IF	MULTI_BANK_BOARD = YES
     59  3843				  -BoardBank
     60  3843					      ENDIF
     61  3843							; Gives the RAM bank of the start of the board row for a given row.
     62  3843
     63  3843				   .BOARD_LOCATION SET	Board - RAM_3E
     64  3843					      REPEAT	SIZE_BOARD_Y
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     72  3843					      REPEND
     73  3843				  -	      IF	MULTI_BANK_BOARD = YES
     74  3843				  -	      CHECKPAGEX	BoardBank, "BoardBank in BANK_INITBANK.asm"
     75  3843					      ENDIF
     76  3843
     77  3843
     78  3843							;------------------------------------------------------------------------------
     79  3843
     80  3843				   CopyROMShadowToRAM_F000
     81  3843		       a9 f0		      lda	#>$F000
     82  3845
      0  3845					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  3845		       00 07	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  3845					      SUBROUTINE
      3  3845				   CopyROMShadowToRAM
     84  3845
     85  3845							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
     86  3845							; the variable definitions are in the ROM shadow because this allows auto-initialisation
     87  3845							; of the variable contents from ROM declarations, but still allows access to them as
     88  3845							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
     89  3845							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
     90  3845							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
     91  3845							; code co-lives in all banks and may run even as bankswitching occurs between those
     92  3845							; banks -- by the very code itself.
     93  3845
     94  3845							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
     95  3845		       85 c0		      sta	Board_AddressR+1
     96  3847		       86 e0		      stx	O_ROM_Source_Bank	; source bank
     97  3849		       84 c4		      sty	RAM_Bank	; destination bank
     98  384b
     99  384b		       a0 00		      ldy	#0
    100  384d		       84 bf		      sty	Board_AddressR
    101  384f		       84 c1		      sty	Board_AddressW
    102  3851		       a9 14		      lda	#>($1000+RAM_WRITE)
    103  3853		       85 c2		      sta	Board_AddressW+1
    104  3855
    105  3855							; Iterate 4 pages (1K) for complete bank copy
    106  3855
    107  3855		       a9 04		      lda	#4
    108  3857		       85 df		      sta	O_CopyCount
    109  3859
    110  3859		       84 e1	   CopyPage   sty	O_Index
    111  385b		       a5 e0		      lda	O_ROM_Source_Bank
    112  385d		       20 61 f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    113  3860							;tax
    114  3860		       a4 e1		      ldy	O_Index
    115  3862		       a6 c4		      ldx	RAM_Bank
    116  3864		       20 6f f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    117  3867
    118  3867		       a4 e1		      ldy	O_Index
    119  3869		       c8		      iny
    120  386a		       d0 ed		      bne	CopyPage
    121  386c
    122  386c		       e6 c0		      inc	Board_AddressR+1
    123  386e		       e6 c2		      inc	Board_AddressW+1
    124  3870
    125  3870		       c6 df		      dec	O_CopyCount
    126  3872		       d0 e5		      bne	CopyPage
    127  3874
    128  3874		       a4 c4		      ldy	RAM_Bank	; TODO: remove!?
    129  3876		       60		      rts
    130  3877
    131  3877
    132  3877							;------------------------------------------------------------------------------
      0  3877					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  3877		       00 07	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  3877					      SUBROUTINE
      3  3877				   SetPlatformColours
    134  3877
    135  3877							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    136  3877							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    137  3877							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    138  3877							; addressing will not violate the page-crossing restriction of 3E.
    139  3877
    140  3877							; TODO: adapt for fast vertical scrolling
    141  3877
    142  3877							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    143  3877
    144  3877		       a9 00		      lda	#<DrawTheScreen	; = 0
    145  3879		       85 c1		      sta	Board_AddressW
    146  387b		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    147  387d		       85 c2		      sta	Board_AddressW+1
    148  387f
    149  387f							; first, set the x index (with last one being a RTS ($60))
    150  387f
    151  387f		       a6 c4		      ldx	RAM_Bank
    152  3881		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    153  3883		       d0 07		      bne	.skipPatch
    154  3885		       a9 60		      lda	#$60	; rts
    155  3887		       a0 41		      ldy	#<SELFMOD_X
    156  3889		       20 6f f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    157  388c				   .skipPatch
    158  388c
    159  388c		       a2 02		      ldx	#3-1
    160  388e				   .loopColor
    161  388e		       86 df		      stx	colorIdx
    162  3890							; set PF colors
    163  3890		       b5 bc		      lda	color,x
    164  3892		       bc b7 f0 	      ldy	SelfModColOfsTbl,x
    165  3895							;tax
    166  3895		       a6 c4		      ldx	RAM_Bank
    167  3897		       20 6f f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy PF colour RED/GREEN/BLUE to self-modifying RAM
    168  389a							; set player colors
    169  389a		       a6 df		      ldx	colorIdx
    170  389c		       bd ba f0 	      lda	SelfModePlayerTbl,x
    171  389f		       a4 81		      ldy	Platform
    172  38a1		       c0 02		      cpy	#PAL
    173  38a3		       90 02		      bcc	.platform0
    174  38a5		       69 14		      adc	#LINES_PER_CHAR-1	; C==1!
    175  38a7				   .platform0
    176  38a7		       bc bd f0 	      ldy	SelfModPlayerColOfsTbl,x
    177  38aa							;tax
    178  38aa		       a6 c4		      ldx	RAM_Bank
    179  38ac		       20 6f f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy player colour RED/GREEN/BLUE to self-modifying RAM
    180  38af							; loop
    181  38af		       a6 df		      ldx	colorIdx
    182  38b1		       ca		      dex
    183  38b2		       10 da		      bpl	.loopColor
    184  38b4
    185  38b4		       a4 c4		      ldy	RAM_Bank
    186  38b6		       60		      rts
    187  38b7
    188  38b7				   SelfModColOfsTbl
    189  38b7		       53 86 1c 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    190  38ba				   SelfModePlayerTbl
    191  38ba		       bd b6 af 	      .byte.b	<SpriteColourBLUE, <SpriteColourGREEN, <SpriteColourRED
    192  38bd				   SelfModPlayerColOfsTbl
    193  38bd		       4c 7f 15 	      .byte.b	<(SELFMOD_PLAYERCOL_BLUE+1), <(SELFMOD_PLAYERCOL_GREEN+1), <(SELFMOD_PLAYERCOL_RED+1)
    194  38c0
    195  38c0
    196  38c0				   DrawLineStartLO
    197  38c0
    198  38c0							; Gives the start address of each line in the draw flags buffer
    199  38c0
    200  38c0				   .DRAW_LOCATION SET	DrawFlag
    201  38c0					      REPEAT	SCREEN_LINES
    202  38c0		       50		      .byte.b	<.DRAW_LOCATION
    203  38c0				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  38c0					      REPEND
    202  38c1		       5a		      .byte.b	<.DRAW_LOCATION
    203  38c1				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  38c1					      REPEND
    202  38c2		       64		      .byte.b	<.DRAW_LOCATION
    203  38c2				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  38c2					      REPEND
    202  38c3		       6e		      .byte.b	<.DRAW_LOCATION
    203  38c3				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  38c3					      REPEND
    202  38c4		       78		      .byte.b	<.DRAW_LOCATION
    203  38c4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  38c4					      REPEND
    202  38c5		       82		      .byte.b	<.DRAW_LOCATION
    203  38c5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  38c5					      REPEND
    202  38c6		       8c		      .byte.b	<.DRAW_LOCATION
    203  38c6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    201  38c6					      REPEND
    202  38c7		       96		      .byte.b	<.DRAW_LOCATION
    203  38c7				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    204  38c8					      REPEND
    205  38c8
    206  38c8
    207  38c8							;------------------------------------------------------------------------------
    208  38c8
      0  38c8					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  38c8		       00 07	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  38c8					      SUBROUTINE
      3  38c8				   GetBoardAddressRW
    210  38c8							; Must share same bank as BoardLineStart tables
    211  38c8
    212  38c8		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    213  38cb		       85 bf		      sta	Board_AddressR	; 3
    214  38cd		       85 c1		      sta	Board_AddressW	; 3
    215  38cf		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    216  38d2		       85 c0		      sta	Board_AddressR+1	; 3	     READ address
    217  38d4		       09 04		      ora	#>RAM_WRITE	; 2
    218  38d6		       85 c2		      sta	Board_AddressW+1	; 3	     WRITE address
    219  38d8				  -	      IF	MULTI_BANK_BOARD = YES
    220  38d8				  -	      ldx	BoardBank,y	; 4 = 26    switch this on return
    221  38d8					      ELSE
    222  38d8		       a2 0d		      ldx	#BANK_BOARD	; 2
    223  38da					      ENDIF
    224  38da		       60		      rts		; 6 = 32[-2]
    225  38db
    226  38db							;------------------------------------------------------------------------------
    227  38db
      0  38db					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  38db		       00 07	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  38db					      SUBROUTINE
      3  38db				   GetBoardAddressR
    229  38db
    230  38db		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    231  38de		       85 bf		      sta	Board_AddressR	; 3
    232  38e0		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    233  38e3		       85 c0		      sta	Board_AddressR+1	; 3	 READ address
    234  38e5				  -	      IF	MULTI_BANK_BOARD = YES
    235  38e5				  -	      lda	BoardBank,y	; 4	 switch this on return
    236  38e5					      ELSE
    237  38e5		       a9 0d		      lda	#BANK_BOARD	; 2
    238  38e7					      ENDIF
    239  38e7		       60		      rts		; 6[-2]
    240  38e8
    241  38e8							;------------------------------------------------------------------------------
    242  38e8
    243  38e8							; +------+------+------+
    244  38e8							; |*	  | a(0) |	|   *= where Temp_board_address1 points
    245  38e8							; +------+------+------+
    246  38e8							; | d(3) | X(4) | b(1) |
    247  38e8							; +------+------+------+
    248  38e8							; |	  | c(2) |	|
    249  38e8							; +------+------+------+
    250  38e8
    251  38e8
      0  38e8					      DEFINE_SUBROUTINE	GetBoardAddress4	;=72[-16](C)
      1  38e8		       00 07	   BANK_GetBoardAddress4 =	_CURRENT_BANK
      2  38e8					      SUBROUTINE
      3  38e8				   GetBoardAddress4
    253  38e8
    254  38e8		       a4 90		      ldy	POS_Y	;3
    255  38ea
    256  38ea		       b9 00 f0 	      lda	BoardLineStartLO-1,y	;4
    257  38ed		       85 df		      sta	Temp_Board_Address1	;3
    258  38ef		       b9 01 f0 	      lda	BoardLineStartLO+1-1,y	;4
    259  38f2		       85 e1		      sta	Temp_Board_Address2	;3
    260  38f4		       b9 02 f0 	      lda	BoardLineStartLO+2-1,y	;4
    261  38f7		       85 e3		      sta	Temp_Board_Address3	;3
    262  38f9		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	;4
    263  38fc		       85 e0		      sta	Temp_Board_Address1+1	;3
    264  38fe		       b9 17 f0 	      lda	BoardLineStartHiR+1-1,y	;4
    265  3901		       85 e2		      sta	Temp_Board_Address2+1	;3
    266  3903		       b9 18 f0 	      lda	BoardLineStartHiR+2-1,y	;4
    267  3906		       85 e4		      sta	Temp_Board_Address3+1	;3
    268  3908				  -	      IF	MULTI_BANK_BOARD = YES
    269  3908				  -	      lda	BoardBank+1-1,y	;4
    270  3908				  -	      sta	Temp_Bank2	;3
    271  3908				  -	      lda	BoardBank+2-1,y	;4
    272  3908				  -	      sta	Temp_Bank3	;3
    273  3908				  -	      lda	BoardBank-1,y	;4
    274  3908				  -			;sta Temp_Bank 		 ;   this becomes switched in RAM bank in normal usage
    275  3908					      ELSE
    276  3908		       a9 0d		      lda	#BANK_BOARD	;2
    277  390a					      ENDIF
    278  390a		       a4 8f		      ldy	POS_X	;3
    279  390c		       60		      rts		;6 = 72[-16]
    280  390d
    281  390d							;------------------------------------------------------------------------------
    282  390d
      0  390d					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  390d		       00 07	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  390d					      SUBROUTINE
      3  390d				   GetBoardAddressW
    284  390d
    285  390d							; Must share same bank as BoardLineStart tables
    286  390d
    287  390d		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    288  3910		       85 c1		      sta	Board_AddressW	;3
    289  3912		       b9 2d f0 	      lda	BoardLineStartHiW,y	;4
    290  3915		       85 c2		      sta	Board_AddressW+1	;3 WRITE address
    291  3917				  -	      IF	MULTI_BANK_BOARD = YES
    292  3917				  -	      ldx	BoardBank,y	;4 switch this on return
    293  3917					      ELSE
    294  3917		       a2 0d		      ldx	#BANK_BOARD	;2
    295  3919					      ENDIF
    296  3919		       60	   QRet       rts		;6
    297  391a
    298  391a							;------------------------------------------------------------------------------
    299  391a
    300  391a				  -	      IF	0	;{
    301  391a				  -			;IF DEMO_VERSION = YES && FINAL_VERSION = NO
    302  391a				  -	      DEFINE_SUBROUTINE	ProcessSelector	; in INITBANK
    303  391a				  -
    304  391a				  -	      sta	ROM_Bank
    305  391a				  -
    306  391a				  -			; This object handles the selection of screen and level
    307  391a				  -
    308  391a				  -	      jsr	MoveViaJoystick
    309  391a				  -	      jsr	InsertObjectStack	;6+76(B)	  re-insert object at same position
    310  391a				  -
    311  391a				  -	      asl	NextLevelTrigger
    312  391a				  -	      lda	BufferedButton	; button pressed?
    313  391a				  -	      asl
    314  391a				  -	      ror	NextLevelTrigger
    315  391a				  -
    316  391a				  -	      lda	POS_VAR
    317  391a				  -	      and	#31
    318  391a				  -	      sta	caveDisplay
    319  391a				  -	      asl
    320  391a				  -	      asl
    321  391a				  -	      adc	caveDisplay	; *5
    322  391a				  -	      sta	cave
    323  391a				  -
    324  391a				  -			; Note: we can only select level 1,2,3,4
    325  391a				  -			; Didn't have enough bits in the POS_VAR variable to hold 0-4 for level and 0-34 for cave... eh?
    326  391a				  -	      lda	POS_VAR
    327  391a				  -	      lsr
    328  391a				  -	      lsr
    329  391a				  -	      lsr
    330  391a				  -	      lsr
    331  391a				  -	      lsr
    332  391a				  -	      sta	level
    333  391a				  -
    334  391a				  -
    335  391a				  -	      ldx	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    336  391a				  -	      lda	ThrottlePerSystem,x
    337  391a				  -	      sta	ThrottleSpeed	; only for selection screen
    338  391a				  -
    339  391a				  -	      rts
    340  391a				  -ThrottlePerSystem
    341  391a				  -	      .byte	19
    342  391a				  -	      .byte	21
    343  391a					      ENDIF		;}
    344  391a
    345  391a							;-------------------------------------------------------------------------------
    346  391a
    347  391a
    348  391a				   OBJTYPE    SET	0
    349  391a					      MAC	define_character
    350  391a				   CHARACTER_{1} =	OBJTYPE
    351  391a				   OBJTYPE    .SET	OBJTYPE + 1
    352  391a					      ENDM
    353  391a
    354  391a							; Modifications to character #/order must also ensure the following are correct...
    355  391a							;   CharacterDataVecLO[...]	     in BANK_FIXED.asm
    356  391a							;   CharacterDataVecHI[...]	     in BANK_FIXED.asm
    357  391a							;   GenericCharFlag[...]	     in BANK_FIXED.asm
    358  391a							;   MoveVecLO[...]		     in BANK_INITBANK.asm
    359  391a							;   MoveVecHI[...]		     in BANK_INITBANK.asm
    360  391a							;   CharToType[...]		     in BANK_FIXED.asm
    361  391a							;   CharToType2[...]		     in DecodeCave.asm
    362  391a
      0  391a					      DEFINE_CHARACTER	BLANK
      1  391a		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	SOIL
      1  391a		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	BOX
      1  391a		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	AMOEBA
      1  391a		       00 03	   CHARACTER_AMOEBA =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	DIAMOND
      1  391a		       00 04	   CHARACTER_DIAMOND =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	DIAMOND2
      1  391a		       00 05	   CHARACTER_DIAMOND2 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	MANOCCUPIED
      1  391a		       00 06	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	FLUTTERBY
      1  391a		       00 07	   CHARACTER_FLUTTERBY =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	FLUTTERBY2
      1  391a		       00 08	   CHARACTER_FLUTTERBY2 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	FIREFLY
      1  391a		       00 09	   CHARACTER_FIREFLY =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	FIREFLY2
      1  391a		       00 0a	   CHARACTER_FIREFLY2 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	WALL0
      1  391a		       00 0b	   CHARACTER_WALL0 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	WALL1
      1  391a		       00 0c	   CHARACTER_WALL1 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	WALL2
      1  391a		       00 0d	   CHARACTER_WALL2 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	WALL3
      1  391a		       00 0e	   CHARACTER_WALL3 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	STEEL
      1  391a		       00 0f	   CHARACTER_STEEL =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	WALL
      1  391a		       00 10	   CHARACTER_WALL =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	EXITDOOR
      1  391a		       00 11	   CHARACTER_EXITDOOR =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	EXITDOOR2
      1  391a		       00 12	   CHARACTER_EXITDOOR2 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	EXPLOSION
      1  391a		       00 13	   CHARACTER_EXPLOSION =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	EXPLOSION1
      1  391a		       00 14	   CHARACTER_EXPLOSION1 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	EXPLOSION2
      1  391a		       00 15	   CHARACTER_EXPLOSION2 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	EXPLOSION3
      1  391a		       00 16	   CHARACTER_EXPLOSION3 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	AMOEBA2
      1  391a		       00 17	   CHARACTER_AMOEBA2 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	BOX_FALLING
      1  391a		       00 18	   CHARACTER_BOX_FALLING =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	DIAMOND_FALLING
      1  391a		       00 19	   CHARACTER_DIAMOND_FALLING =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	NOGO
      1  391a		       00 1a	   CHARACTER_NOGO =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
    390  391a
      0  391a					      DEFINE_CHARACTER	MAXIMUM
      1  391a		       00 1b	   CHARACTER_MAXIMUM =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
    392  391a
    393  391a							;------------------------------------------------------------------------------
    394  391a
      0  391a					      DEFINE_SUBROUTINE	PushBox	; in INITBANK
      1  391a		       00 07	   BANK_PushBox =	_CURRENT_BANK
      2  391a					      SUBROUTINE
      3  391a				   PushBox
    396  391a
    397  391a							; Note: FALLING boulders are not really boulders. They are falling boulders. They are a different
    398  391a							; character type, so will not get to this code. So you can't push falling objects :)
    399  391a
    400  391a		       85 c3		      sta	ROM_Bank
    401  391c
    402  391c							; Determine if the boulder is pushable
    403  391c							; we use the joystick to calculate the subsequent square
    404  391c							;;;
    405  391c
    406  391c		       a5 95		      lda	BufferedJoystick
    407  391e		       4a		      lsr
    408  391f		       4a		      lsr
    409  3920		       4a		      lsr
    410  3921		       4a		      lsr
    411  3922		       48		      pha
    412  3923		       a8		      tay
    413  3924
    414  3924		       18		      clc
    415  3925		       a5 92		      lda	POS_Y_NEW
    416  3927		       79 bc f3 	      adc	JoyMoveY,y
    417  392a		       a8		      tay
    418  392b		       20 c8 f0 	      jsr	GetBoardAddressRW
    419  392e
    420  392e		       68		      pla
    421  392f		       a8		      tay
    422  3930
    423  3930		       18		      clc
    424  3931		       a5 91		      lda	POS_X_NEW
    425  3933		       79 b0 f3 	      adc	JoyMoveX,y
    426  3936		       48		      pha
    427  3937		       a8		      tay
    428  3938
    429  3938				  -	      IF	MULTI_BANK_BOARD = YES
    430  3938				  -	      lda	RAM_Bank
    431  3938					      ELSE
    432  3938		       a9 0d		      lda	#BANK_BOARD	; 2
    433  393a					      ENDIF
    434  393a		       20 66 f8 	      jsr	GetBoardCharacter	;6+20(A)
    435  393d		       c9 04		      cmp	#CHARACTER_DIAMOND
    436  393f		       f0 04		      beq	canPush
    437  3941		       c9 00		      cmp	#CHARACTER_BLANK
    438  3943		       d0 21		      bne	cannotPush
    439  3945
    440  3945		       68	   canPush    pla
    441  3946		       a8		      tay
    442  3947
    443  3947		       e6 a9		      inc	ManPushCounter
    444  3949		       a5 a9		      lda	ManPushCounter
    445  394b		       49 02		      eor	#PUSH_LIMIT
    446  394d		       d0 18		      bne	cannotPush2	; nice 'get to 0' optimisation
    447  394f		       85 a9		      sta	ManPushCounter
    448  3951
    449  3951				  -	      IF	MULTI_BANK_BOARD = YES
    450  3951				  -	      ldx	RAM_Bank
    451  3951					      ELSE
    452  3951		       a2 0d		      ldx	#BANK_BOARD	; 2
    453  3953					      ENDIF
    454  3953		       a9 02		      lda	#CHARACTER_BOX
    455  3955		       20 6f f8 	      jsr	PutBoardCharacter	;6+21(A)
    456  3958
    457  3958		       a6 92		      ldx	POS_Y_NEW
    458  395a		       86 90		      stx	POS_Y
    459  395c		       a4 91		      ldy	POS_X_NEW
    460  395e		       84 8f		      sty	POS_X
    461  3960
    462  3960		       20 93 f9 	      jsr	BlankOriginalLocationXY	;6+87[-2](A)	     and stacks newly blank position for checking -- also causing boulder to fall!
    463  3963
    464  3963							;START_SOUND SOUND_BOX
    465  3963
    466  3963							;lda BufferedButton		       ; button pressed?
    467  3963							;bpl PushWithButton
    468  3963		       4c 53 fa 	      jmp	MovePlayer	; now there's a gap, player should move in
    469  3966
    470  3966		       68	   cannotPush pla
    471  3967							;lda #0
    472  3967							;sta ManPushCounter
    473  3967				   PushWithButton
    474  3967				   cannotPush2
    475  3967				   timeout
    476  3967		       60		      rts
    477  3968
    478  3968		       4c f7 f9    Bango      jmp	NextObject	;??? >-- should be OK. Creature dies.
    479  396b
    480  396b
    481  396b							;------------------------------------------------------------------------------
    482  396b
    483  396b							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    484  396b							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    485  396b
    486  396b							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    487  396b
    488  396b							; if the creature dies then jump NextObject
    489  396b
    490  396b
    491  396b
    492  396b		       ff	   RDirY      .byte.b	-1	;,0,1,0
    493  396c		       00 01	   RDirX      .byte.b	0,1	;,0,-1
    494  396e		       00 ff 01 00 DirPushModX .byte.b	0,-1,1,0
    495  3972		       ff 00 00 01 DirPushModY .byte.b	-1,0,0,1
    496  3976		       01 02 03 00*Directional .byte.b	1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    497  3984
    498  3984
    499  3984							;------------------------------------------------------------------------------
    500  3984
    501  3984							; Thomas, the auto-calculation of these was causing DASM to get confused and abort assembling.
    502  3984							; I don't particularly know why; probably because of the cave variable-size array and the values
    503  3984							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    504  3984
    505  3984		       00 00	   MANMODE_STARTUP =	0
    506  3984		       00 01	   MANMODE_NORMAL =	1
    507  3984		       00 02	   MANMODE_DEAD =	2
    508  3984		       00 03	   MANMODE_WAITING =	3
    509  3984		       00 04	   MANMODE_WAITING2 =	4
    510  3984		       00 05	   MANMODE_WAITING_NT =	5
    511  3984		       00 06	   MANMODE_WAITING_NT2 =	6
    512  3984		       00 07	   MANMODE_NEXTLEVEL =	7
    513  3984		       00 08	   MANMODE_BONUS_START =	8
    514  3984		       00 09	   MANMODE_BONUS_RUN =	9
    515  3984
      0  3984					      DEFINE_SUBROUTINE	ManProcess	; in INITBANK
      1  3984		       00 07	   BANK_ManProcess =	_CURRENT_BANK
      2  3984					      SUBROUTINE
      3  3984				   ManProcess
    517  3984
    518  3984		       a9 ff		      lda	#$FF
    519  3986		       85 dc		      sta	specialTimeFlag	; detects time overflow in bigbang (and diamond grab)
    520  3988
    521  3988
    522  3988							; ManMode tells the player what it is currently doing.  State machine.
    523  3988
    524  3988		       ad 82 02 	      lda	SWCHB
    525  398b		       29 03		      and	#3
    526  398d		       d0 03		      bne	.skipReset	; BOTH select/reset = restart
    527  398f
    528  398f							;		  lsr SWCHB
    529  398f							;		  bcs .skipReset
    530  398f
    531  398f				  -	      IF	F1F2NEXTCAVE=YES
    532  398f				  -	      lda	#MANMODE_NEXTLEVEL
    533  398f				  -	      sta	ManMode
    534  398f					      ELSE
    535  398f		       4c 78 fb 	      jmp	Restart	; RESET = end game, jump to title screen
    536  3992					      ENDIF
    537  3992
    538  3992				   .skipReset
    539  3992
    540  3992							;sokldy ManMode
    541  3992							;sok lda ManActionTimer,y
    542  3992							;sok beq .skipTimer
    543  3992							;sok jsr UpdateTimer
    544  3992				   .skipTimer
    545  3992		       a4 a3		      ldy	ManMode
    546  3994		       b9 ab f1 	      lda	ManActionLO,y
    547  3997		       85 df		      sta	actionVector
    548  3999		       b9 b5 f1 	      lda	ManActionHI,y
    549  399c		       85 e0		      sta	actionVector+1
    550  399e		       6c df 00 	      jmp	(actionVector)
    551  39a1
    552  39a1				   ManActionTimer
    553  39a1		       00		      .byte.b	0	;<manStartup		 ; 0		 no timer
    554  39a2		       01		      .byte.b	1	;<normalMan		 ; 1		 timer
    555  39a3		       01		      .byte.b	1	;<deadMan		 ; 2		 timer
    556  39a4		       01		      .byte.b	1	;<waitingMan		 ; 3		 timer
    557  39a5		       01		      .byte.b	1	;<waitingManPress	 ; 4		 timer
    558  39a6		       00		      .byte.b	0	;<waitingManNoTim	 ; 5		 no timer
    559  39a7		       00		      .byte.b	0	;<waitingManPressNoTim  ; 6		 no timer
    560  39a8		       00		      .byte.b	0	;<nextLevelMan 	 ; 7		 no timer
    561  39a9		       02		      .byte.b	2	;<BonusCountdownStart	 ; 8		 fast timer
    562  39aa		       02		      .byte.b	2	;<BonusCountdownRun	 ; 9		 fast timer
    563  39ab				   ManActionLO
    564  39ab		       3d		      .byte.b	<manStartup	; 0		 no timer
    565  39ac		       df		      .byte.b	<normalMan	; 1		 timer
    566  39ad		       08		      .byte.b	<deadMan	; 2		 timer
    567  39ae		       83		      .byte.b	<waitingMan	; 3		 timer
    568  39af		       a6		      .byte.b	<waitingManPress	; 4		 timer
    569  39b0		       83		      .byte.b	<waitingMan	; 5		 no timer
    570  39b1		       a6		      .byte.b	<waitingManPress	; 6		 no timer
    571  39b2		       36		      .byte.b	<nextLevelMan	; 7		 no timer
    572  39b3		       16		      .byte.b	<BonusCountdownStart	; 8		 fast timer
    573  39b4		       33		      .byte.b	<BonusCountdownRun	; 9		 fast timer
    574  39b5
    575  39b5				   ManActionHI
    576  39b5		       f2		      .byte.b	>manStartup	; no timer
    577  39b6		       f2		      .byte.b	>normalMan	; timer
    578  39b7		       f3		      .byte.b	>deadMan	; timer
    579  39b8		       f2		      .byte.b	>waitingMan	; timer
    580  39b9		       f2		      .byte.b	>waitingManPress	; timer
    581  39ba		       f2		      .byte.b	>waitingMan	; no timer
    582  39bb		       f2		      .byte.b	>waitingManPress	; no timer
    583  39bc		       fd		      .byte.b	>nextLevelMan	; no timer
    584  39bd		       f3		      .byte.b	>BonusCountdownStart	; fast timer
    585  39be		       f3		      .byte.b	>BonusCountdownRun	; fast timer
    586  39bf
    587  39bf							;------------------------------------------------------------------------------
      0  39bf					      DEFINE_SUBROUTINE	UpdateTimer
      1  39bf		       00 07	   BANK_UpdateTimer =	_CURRENT_BANK
      2  39bf					      SUBROUTINE
      3  39bf				   UpdateTimer
    589  39bf
    590  39bf		       a2 03		      ldx	#3
    591  39c1		       a5 a3		      lda	ManMode
    592  39c3		       c9 09		      cmp	#MANMODE_BONUS_RUN
    593  39c5		       f0 19		      beq	.setLoops
    594  39c7
    595  39c7		       a2 04		      ldx	#NUM_LEVELS-1	; intermissions run at full speed
    596  39c9		       24 b2		      bit	caveDisplay
    597  39cb		       30 02		      bmi	.intermission2
    598  39cd		       a6 b1		      ldx	level
    599  39cf				   .intermission2
    600  39cf		       bd 38 f2 	      lda	TimeFracTbl,x
    601  39d2		       24 aa		      bit	LookingAround
    602  39d4		       10 02		      bpl	notSlowTime
    603  39d6		       a9 00		      lda	#0	; new behaviour: time does not count down when looking around
    604  39d8							;lsr				  ; go half-speed time countdown when looking around
    605  39d8				   notSlowTime
    606  39d8		       65 bb		      adc	caveTimeFrac
    607  39da		       85 bb		      sta	caveTimeFrac
    608  39dc		       90 4f		      bcc	.forceTimeDraw
    609  39de
    610  39de		       a2 01		      ldx	#1
    611  39e0				   .setLoops
    612  39e0		       86 e0		      stx	timerLoops
    613  39e2		       d0 08		      bne	.notScoring
    614  39e4				   .loopTimer
    615  39e4		       a5 b1		      lda	level	; each second left adds 'level' to score
    616  39e6		       18		      clc
    617  39e7		       69 01		      adc	#1
    618  39e9		       20 2a fd 	      jsr	ScoreAdd
    619  39ec				   .notScoring
    620  39ec		       f8		      sed
    621  39ed		       38		      sec
    622  39ee		       a5 b9		      lda	caveTime
    623  39f0		       e9 01		      sbc	#1
    624  39f2		       85 b9		      sta	caveTime
    625  39f4		       d8		      cld
    626  39f5		       b0 02		      bcs	.skipHi2a
    627  39f7		       c6 ba		      dec	caveTimeHi
    628  39f9				   .skipHi2a
    629  39f9							; check for running out of time sound:
    630  39f9		       a5 ba		      lda	caveTimeHi
    631  39fb		       d0 35		      bne	.timeAbove9
    632  39fd		       a9 09		      lda	#$09
    633  39ff		       38		      sec
    634  3a00		       e5 b9		      sbc	caveTime
    635  3a02		       90 2e		      bcc	.timeAbove9
    636  3a04							; this assumes that SND_MASK_HI = %11110000
    637  3a04							;  and the time entries are ordered 9 to 0!
    638  3a04		       0a		      asl
    639  3a05		       0a		      asl
    640  3a06		       0a		      asl
    641  3a07		       0a		      asl
    642  3a08		       69 60		      adc	#SOUND_TIME_9
    643  3a0a		       85 df		      sta	tmpSound
    644  3a0c		       a5 db		      lda	newSounds
    645  3a0e		       29 0f		      and	#<(~SND_MASK_HI)
    646  3a10		       05 df		      ora	tmpSound
    647  3a12		       85 db		      sta	newSounds
    648  3a14				   .skipTimeSound
    649  3a14		       a6 b9		      ldx	caveTime
    650  3a16		       d0 15		      bne	.timeNotZero
    651  3a18		       86 59		      stx	AUDV0	; stop bonus sound
    652  3a1a		       86 d5		      stx	soundIdxLst
    653  3a1c				   .contChannel1
    654  3a1c		       a2 07		      ldx	#MANMODE_NEXTLEVEL	; time bonus
    655  3a1e		       a5 a3		      lda	ManMode
    656  3a20		       c9 09		      cmp	#MANMODE_BONUS_RUN
    657  3a22		       f0 07		      beq	.nextLevel
    658  3a24		       a2 06		      ldx	#MANMODE_WAITING_NT2	; time over
    659  3a26		       c9 04		      cmp	#MANMODE_WAITING2	; Man already dead?
    660  3a28		       f0 01		      beq	.nextLevel
    661  3a2a		       ca		      dex		; == MANMODE_WAITING_NT
    662  3a2b				   .nextLevel
    663  3a2b		       86 a3		      stx	ManMode	; -> man dies, but no explosion
    664  3a2d				   .timeNotZero
    665  3a2d				   .forceTimeDraw
    666  3a2d		       a9 09		      lda	#BANK_SCORING
    667  3a2f		       4c 4f f8 	      jmp	DrawTimeFromROM	; Z-flag == 0!
    668  3a32
    669  3a32				   .timeAbove9
    670  3a32		       c6 e0		      dec	timerLoops
    671  3a34		       d0 ae		      bne	.loopTimer
    672  3a36		       f0 f5		      beq	.forceTimeDraw
    673  3a38
    674  3a38				   TimeFracTbl
    675  3a38		       1f		      .byte.b	31	; level 1, NTSC/PAL
    676  3a39		       1b		      .byte.b	27	; level 2, NTSC/PAL
    677  3a3a		       18		      .byte.b	24	; level 3, NTSC/PAL
    678  3a3b		       17		      .byte.b	23	; level 4, NTSC/PAL
    679  3a3c		       16		      .byte.b	22	; level 5, NTSC/PAL
    680  3a3d							; calculate: level 5 throttle * level 5 time / level x throttle
    681  3a3d
    682  3a3d
    683  3a3d							;------------------------------------------------------------------------------
      0  3a3d					      DEFINE_SUBROUTINE	manStartup
      1  3a3d		       00 07	   BANK_manStartup =	_CURRENT_BANK
      2  3a3d					      SUBROUTINE
      3  3a3d				   manStartup
    685  3a3d
    686  3a3d		       a5 9f		      lda	ManX
    687  3a3f		       85 91		      sta	POS_X_NEW	;NewX
    688  3a41		       85 8f		      sta	POS_X
    689  3a43		       a5 a0		      lda	ManY
    690  3a45		       85 92		      sta	POS_Y_NEW	;NewY
    691  3a47		       85 90		      sta	POS_Y
    692  3a49
    693  3a49		       e6 94		      inc	POS_VAR
    694  3a4b		       a6 94		      ldx	POS_VAR	; animation index
    695  3a4d		       bd 6f f2 	      lda	.RockfordStartup-1,x
    696  3a50		       30 1b		      bmi	CreateRockford
    697  3a52		       85 93		      sta	POS_Type
    698  3a54
    699  3a54							; check for start of "crack" sound:
    700  3a54		       c9 16		      cmp	#CHARACTER_EXPLOSION3	; first explosion frame?
    701  3a56		       d0 0e		      bne	.skipCrack1
      0  3a58					      START_SOUND	SOUND_CRACK	;  yes, start "crack" sound
      1  3a58					      SUBROUTINE
      2  3a58		       a5 db		      lda	newSounds
      3  3a5a				  -	      IF	SOUND_CRACK < 16
      4  3a5a				  -	      and	#SND_MASK_LO
      5  3a5a				  -	      cmp	#SOUND_MOVE_SOIL+1
      6  3a5a				  -	      bcs	.skipNew
      7  3a5a					      ELSE
      8  3a5a		       29 f0		      and	#SND_MASK_HI
      9  3a5c		       c9 30		      cmp	#(SOUND_MOVE_SOIL+1)<<4
     10  3a5e		       b0 06		      bcs	.skipNew
     11  3a60
     12  3a60					      ENDIF
     13  3a60		       45 db		      eor	newSounds
     14  3a62		       09 50		      ora	#SOUND_CRACK
     15  3a64		       85 db		      sta	newSounds
     16  3a66				   .skipNew
     17  3a66					      SUBROUTINE
    703  3a66				   .skipCrack1
    704  3a66		       a9 ff		      lda	#$FF
    705  3a68		       85 a4		      sta	ManDelayCount	; anything, just non-0
    706  3a6a
    707  3a6a		       4c 93 f8 	      jmp	PutBoardCharacterFromRAM	;70 --> switches this bank out but who cares!
    708  3a6d
    709  3a6d				   CreateRockford
    710  3a6d		       e6 a3		      inc	ManMode	; --> MANMODE_NORMAL
    711  3a6f				   RTS_CF
    712  3a6f		       60		      rts
    713  3a70
    714  3a70				   .RockfordStartup
    715  3a70							;    .byte CHARACTER_NOGO
    716  3a70							;    .byte CHARACTER_NOGO
    717  3a70		       0f		      .byte.b	CHARACTER_STEEL
    718  3a71		       0f		      .byte.b	CHARACTER_STEEL
    719  3a72		       1a		      .byte.b	CHARACTER_NOGO
    720  3a73		       0f		      .byte.b	CHARACTER_STEEL
    721  3a74		       1a		      .byte.b	CHARACTER_NOGO
    722  3a75		       0f		      .byte.b	CHARACTER_STEEL
    723  3a76		       1a		      .byte.b	CHARACTER_NOGO
    724  3a77		       0f		      .byte.b	CHARACTER_STEEL
    725  3a78		       1a		      .byte.b	CHARACTER_NOGO
    726  3a79		       0f		      .byte.b	CHARACTER_STEEL
    727  3a7a		       1a		      .byte.b	CHARACTER_NOGO
    728  3a7b		       0f		      .byte.b	CHARACTER_STEEL
    729  3a7c		       1a		      .byte.b	CHARACTER_NOGO
    730  3a7d		       0f		      .byte.b	CHARACTER_STEEL
    731  3a7e							;.byte CHARACTER_NOGO
    732  3a7e		       16		      .byte.b	CHARACTER_EXPLOSION3
    733  3a7f							;.byte CHARACTER_EXPLOSION
    734  3a7f		       15		      .byte.b	CHARACTER_EXPLOSION2
    735  3a80		       14		      .byte.b	CHARACTER_EXPLOSION1
    736  3a81		       06		      .byte.b	CHARACTER_MANOCCUPIED
    737  3a82		       ff		      .byte.b	-1
    738  3a83
    739  3a83							;------------------------------------------------------------------------------
    740  3a83
    741  3a83		       c6 a4	   waitingMan dec	ManDelayCount
    742  3a85
    743  3a85		       a9 00		      lda	#0
    744  3a87		       85 aa		      sta	LookingAround
    745  3a89		       85 af		      sta	BGColour
    746  3a8b
    747  3a8b							; Wait for button to be RELEASED first!
    748  3a8b
    749  3a8b		       a5 97		      lda	BufferedButton
    750  3a8d		       10 4f		      bpl	noChange
    751  3a8f		       e6 a3		      inc	ManMode
    752  3a91
    753  3a91							; Man loses a life and re-starts level if lives available
    754  3a91							; Special-case: Bonus levels go to next level.
    755  3a91
    756  3a91		       a5 b2		      lda	caveDisplay
    757  3a93		       30 0d		      bmi	intermission	; don't lose a life on intermission screens
    758  3a95					      IF	NUM_LIVES != -1
    759  3a95		       c6 ab		      dec	MenCurrent	; works for P1P2 format
    760  3a97							; display lives after a live is lost
    761  3a97		       a5 c8		      lda	scoringFlags	;
    762  3a99		       29 fc		      and	#~DISPLAY_FLAGS
    763  3a9b		       09 02		      ora	#DISPLAY_LIVES
    764  3a9d		       85 c8		      sta	scoringFlags	;
    765  3a9f					      ENDIF
    766  3a9f		       20 92 fd 	      jsr	goGeneralScoringSetups	; update the life display. Roundabout way of doing it.
    767  3aa2				   intermission
    768  3aa2
    769  3aa2		       a9 78		      lda	#120	; something long.  anything.
    770  3aa4		       85 c7		      sta	scoringTimer	; first time through we wait on the current display
    771  3aa6
    772  3aa6				   waitingManPress
    773  3aa6
    774  3aa6							; Cycle the score display, player display, level display based on timing
    775  3aa6							; see "Scoring timer" reset stomp comment in bank_generic.
    776  3aa6
    777  3aa6		       a5 c7		      lda	scoringTimer
    778  3aa8		       c9 0a		      cmp	#10	; non-zero so we don't get stomped on by the scoring reset in
    779  3aaa		       b0 19		      bcs	stillKicking
    780  3aac		       a9 5a		      lda	#90	; something long.  anything.
    781  3aae		       85 c7		      sta	scoringTimer
    782  3ab0
    783  3ab0		       a5 ab		      lda	MenCurrent
    784  3ab2		       29 0f		      and	#$0f
    785  3ab4		       c9 01		      cmp	#$01
    786  3ab6		       a6 c8		      ldx	scoringFlags
    787  3ab8		       e8		      inx
    788  3ab9		       8a		      txa
    789  3aba							; if game over for current player, display diamonds/time, score, player/lives/cave and high score
    790  3aba		       29 f3		      and	#$f3
    791  3abc		       90 02		      bcc	gameOver
    792  3abe							; else display diamonds/time and score only
    793  3abe		       29 f1		      and	#$f1
    794  3ac0		       85 c8	   gameOver   sta	scoringFlags	;
    795  3ac2
    796  3ac2		       20 92 fd 	      jsr	goGeneralScoringSetups	; update the score display.
    797  3ac5
    798  3ac5				   stillKicking
    799  3ac5
    800  3ac5		       a5 97		      lda	BufferedButton	; button pressed?
    801  3ac7		       30 15		      bmi	noChange
    802  3ac9
      0  3ac9					      STOP_CHANNEL	1	; stop all long running sounds
      1  3ac9
      2  3ac9		       a9 00		      lda	#0
      3  3acb		       85 d6		      sta	soundIdxLst+1
      4  3acd		       85 5a		      sta	AUDV0+1
    804  3acf
    805  3acf							; If it's a bonus level, even though we've died... we go to the next cave
    806  3acf
    807  3acf		       a5 b2		      lda	caveDisplay
    808  3ad1		       10 05		      bpl	nonextlevel
    809  3ad3		       a2 07		      ldx	#MANMODE_NEXTLEVEL
    810  3ad5		       86 a3		      stx	ManMode
    811  3ad7		       60		      rts
    812  3ad8
    813  3ad8
    814  3ad8		       a5 c9	   nonextlevel lda	NextLevelTrigger
    815  3ada		       09 40		      ora	#BIT_NEXTLIFE
    816  3adc		       85 c9		      sta	NextLevelTrigger
    817  3ade
    818  3ade		       60	   noChange   rts
    819  3adf
    820  3adf							;------------------------------------------------------------------------------
    821  3adf							; Normal man state
    822  3adf
    823  3adf
    824  3adf				   normalMan
    825  3adf
    826  3adf							; Timer is still running, so we see if the player is to die for any reason
    827  3adf
    828  3adf		       24 ac		      bit	demoMode
    829  3ae1		       30 09		      bmi	stayAlive
    830  3ae3							; SELECT pressed?
    831  3ae3		       ad 82 02 	      lda	SWCHB
    832  3ae6		       49 ff		      eor	#$FF
    833  3ae8		       29 03		      and	#3
    834  3aea		       d0 1a		      bne	Time0	; EITHER select or reset are pressed
    835  3aec							;		  lsr
    836  3aec							;		  lsr
    837  3aec							;		  bcc Time0			  ; suicide!
    838  3aec				   stayAlive
    839  3aec
    840  3aec							;------------------------------------------------------------------------------
    841  3aec
    842  3aec		       a6 a0		      ldx	ManY
    843  3aee		       a4 9f		      ldy	ManX
    844  3af0
    845  3af0		       bd 01 f0 	      lda	BoardLineStartLO,x
    846  3af3		       85 bf		      sta	Board_AddressR
    847  3af5		       bd 17 f0 	      lda	BoardLineStartHiR,x
    848  3af8		       85 c0		      sta	Board_AddressR+1
    849  3afa
    850  3afa				  -	      IF	MULTI_BANK_BOARD = YES
    851  3afa				  -	      lda	BoardBank,x	;4
    852  3afa				  -	      sta	RAM_Bank	;3
    853  3afa					      ELSE
    854  3afa		       a9 0d		      lda	#BANK_BOARD	;2
    855  3afc					      ENDIF
    856  3afc		       20 66 f8 	      jsr	GetBoardCharacter	;6+20(A)
    857  3aff
    858  3aff		       bd ee fc 	      lda	CharToType,x
    859  3b02		       c9 00		      cmp	#TYPE_MAN
    860  3b04		       f0 4e		      beq	PlayerAlive
    861  3b06							;jmp PlayerAlive ;sok
    862  3b06
    863  3b06							; character he's on isn't a MAN character, so he dies...
    864  3b06
    865  3b06				   Time0
    866  3b06
    867  3b06		       e6 a3		      inc	ManMode	; #1 -- player dead!
    868  3b08
    869  3b08
    870  3b08							; the dead man creates an explosion...
    871  3b08							; note, if we get a segtime problem, this code will re-execute OK
    872  3b08
    873  3b08		       a5 9f	   deadMan    lda	ManX
    874  3b0a		       85 8f		      sta	POS_X
    875  3b0c		       a5 a0		      lda	ManY
    876  3b0e		       85 90		      sta	POS_Y
    877  3b10
    878  3b10		       20 2b f3 	      jsr	BlankPlayerFrame
    879  3b13
    880  3b13							;sok jsr BigBang
    881  3b13							;sok ror specialTimeFlag
    882  3b13							;sok bpl timeTooShortToDie	      ; wait until next time around
    883  3b13
    884  3b13							; and becomes a man waiting for resurrection...
    885  3b13
    886  3b13		       e6 a3		      inc	ManMode
    887  3b15
    888  3b15				   timeTooShortToDie
    889  3b15		       60		      rts
    890  3b16
    891  3b16							;------------------------------------------------------------------------------
      0  3b16					      DEFINE_SUBROUTINE	BonusCountdownStart
      1  3b16		       00 07	   BANK_BonusCountdownStart =	_CURRENT_BANK
      2  3b16					      SUBROUTINE
      3  3b16				   BonusCountdownStart
    893  3b16		       e6 a3		      inc	ManMode	; waiting for countdown to complete
    894  3b18
      0  3b18					      START_SOUND	SOUND_BONUS_POINTS	; one-off trigger of bonus countdown sound
      1  3b18					      SUBROUTINE
      2  3b18		       a5 db		      lda	newSounds
      3  3b1a					      IF	SOUND_BONUS_POINTS < 16
      4  3b1a		       29 0f		      and	#SND_MASK_LO
      5  3b1c		       c9 03		      cmp	#SOUND_MOVE_SOIL+1
      6  3b1e		       b0 06		      bcs	.skipNew
      7  3b20				  -	      ELSE
      8  3b20				  -	      and	#SND_MASK_HI
      9  3b20				  -	      cmp	#(SOUND_MOVE_SOIL+1)<<4
     10  3b20				  -	      bcs	.skipNew
     11  3b20				  -
     12  3b20					      ENDIF
     13  3b20		       45 db		      eor	newSounds
     14  3b22		       09 07		      ora	#SOUND_BONUS_POINTS
     15  3b24		       85 db		      sta	newSounds
     16  3b26				   .skipNew
     17  3b26					      SUBROUTINE
    896  3b26
    897  3b26		       a9 00		      lda	#AnimateSTAND-Manimate
    898  3b28		       85 a5		      sta	ManAnimation
    899  3b2a							;lda #>AnimateSTAND
    900  3b2a							;sta ManAnimation+1
    901  3b2a
    902  3b2a
    903  3b2a		       60		      rts
    904  3b2b
    905  3b2b							;------------------------------------------------------------------------------
    906  3b2b
      0  3b2b					      DEFINE_SUBROUTINE	BlankPlayerFrame
      1  3b2b		       00 07	   BANK_BlankPlayerFrame =	_CURRENT_BANK
      2  3b2b					      SUBROUTINE
      3  3b2b				   BlankPlayerFrame
    908  3b2b
    909  3b2b		       a9 2c		      lda	#AnimateBLANK-Manimate
    910  3b2d		       85 a5		      sta	ManAnimation
    911  3b2f							;lda #>AnimateBLANK
    912  3b2f							;sta ManAnimation+1
    913  3b2f		       a9 00		      lda	#0
    914  3b31		       85 a4		      sta	ManDelayCount
    915  3b33							;rts
    916  3b33
    917  3b33							; do NOT fall through!  Above removed just while there's a plain rts following...
    918  3b33
    919  3b33							;------------------------------------------------------------------------------
      0  3b33					      DEFINE_SUBROUTINE	BonusCountdownRun
      1  3b33		       00 07	   BANK_BonusCountdownRun =	_CURRENT_BANK
      2  3b33					      SUBROUTINE
      3  3b33				   BonusCountdownRun
    921  3b33		       60		      rts
    922  3b34
    923  3b34							;------------------------------------------------------------------------------
    924  3b34
    925  3b34							;lookColour	  .byte $b0,$02
    926  3b34
      0  3b34					      DEFINE_SUBROUTINE	LookAround	; in INITBANK
      1  3b34		       00 07	   BANK_LookAround =	_CURRENT_BANK
      2  3b34					      SUBROUTINE
      3  3b34				   LookAround
    928  3b34
    929  3b34							;ldx Platform
    930  3b34							;lda lookColour,x
    931  3b34							;sta BGColour
    932  3b34
    933  3b34							; Use the joystick as a window-scroller to change the viewport
    934  3b34
    935  3b34		       a5 95		      lda	BufferedJoystick
    936  3b36		       4a		      lsr
    937  3b37		       4a		      lsr
    938  3b38		       4a		      lsr
    939  3b39		       4a		      lsr
    940  3b3a		       a8		      tay
    941  3b3b
    942  3b3b		       b9 b0 f3 	      lda	JoyMoveX,y
    943  3b3e							;asl
    944  3b3e		       18		      clc
    945  3b3f		       65 9b		      adc	BoardScrollX
    946  3b41		       c5 98		      cmp	BoardEdge_Right
    947  3b43		       b0 02		      bcs	AbandonX
    948  3b45		       85 9b		      sta	BoardScrollX
    949  3b47
    950  3b47		       b9 bc f3    AbandonX   lda	JoyMoveY,y
    951  3b4a							;asl
    952  3b4a		       18		      clc
    953  3b4b		       65 9a		      adc	BoardScrollY
    954  3b4d		       c5 99		      cmp	BoardEdge_Bottom
    955  3b4f		       b0 02		      bcs	AbandonY
    956  3b51		       85 9a		      sta	BoardScrollY
    957  3b53
    958  3b53		       60	   AbandonY   rts
    959  3b54
    960  3b54
    961  3b54
    962  3b54
    963  3b54				   PlayerAlive
    964  3b54
    965  3b54							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    966  3b54							; before exiting via (for example) look-around option :)
    967  3b54
    968  3b54		       a5 9f		      lda	ManX
    969  3b56		       85 91		      sta	POS_X_NEW
    970  3b58		       a5 a0		      lda	ManY
    971  3b5a		       85 92		      sta	POS_Y_NEW
    972  3b5c
    973  3b5c
    974  3b5c							;------------------------------------------------------------------------------
    975  3b5c							; Look around is triggered by holding down the fire button for a while, without any other
    976  3b5c							; joystick directions chosen. The variable LookingAround has a negative value ($FF) when looking
    977  3b5c							; is active. Otherwise, it is counting down to the time where it will trigger.
    978  3b5c
    979  3b5c		       00 00	   LOOK_DELAY =	0
    980  3b5c
    981  3b5c		       a2 00		      ldx	#LOOK_DELAY
    982  3b5e		       a5 97		      lda	BufferedButton
    983  3b60		       30 0d		      bmi	noLook	; button?
    984  3b62		       a5 aa		      lda	LookingAround
    985  3b64		       30 ce		      bmi	LookAround	; already looking
    986  3b66		       a5 95		      lda	BufferedJoystick
    987  3b68		       c9 f0		      cmp	#$F0
    988  3b6a		       90 03		      bcc	noLook	; must have no directions chosen
    989  3b6c		       a6 aa		      ldx	LookingAround
    990  3b6e		       ca		      dex
    991  3b6f		       86 aa	   noLook     stx	LookingAround
    992  3b71
    993  3b71							;------------------------------------------------------------------------------
    994  3b71
    995  3b71							; control the scrolling via the joystick
    996  3b71
    997  3b71		       a5 a8		      lda	ManLastDirection
    998  3b73		       29 07		      and	#DIRECTION_BITS
    999  3b75		       a8		      tay
   1000  3b76
   1001  3b76		       a5 95		      lda	BufferedJoystick	; joystick
   1002  3b78		       25 96		      and	BufferedJoystick+1
   1003  3b7a
   1004  3b7a		       a2 00		      ldx	#0
   1005  3b7c		       0a	   .loopDirs  asl
   1006  3b7d		       90 07		      bcc	.dirFound
   1007  3b7f		       88		      dey
   1008  3b80		       e8		      inx
   1009  3b81		       e0 04		      cpx	#4
   1010  3b83		       d0 f7		      bne	.loopDirs
   1011  3b85		       18		      clc
   1012  3b86				   .dirFound
   1013  3b86		       a5 91		      lda	POS_X_NEW	;NewX
   1014  3b88		       7d c9 f3 	      adc	JoyDirX,x
   1015  3b8b		       85 91		      sta	POS_X_NEW	;NewX
   1016  3b8d		       a5 92		      lda	POS_Y_NEW	;NewY
   1017  3b8f		       18		      clc
   1018  3b90		       7d c7 f3 	      adc	JoyDirY,x
   1019  3b93		       85 92		      sta	POS_Y_NEW	;NewY
   1020  3b95
   1021  3b95		       98		      tya
   1022  3b96		       f0 12		      beq	noMovement	; animation OK
   1023  3b98
   1024  3b98		       8a		      txa
   1025  3b99		       45 a8		      eor	ManLastDirection
   1026  3b9b		       29 07		      and	#DIRECTION_BITS
   1027  3b9d		       45 a8		      eor	ManLastDirection
   1028  3b9f		       85 a8		      sta	ManLastDirection
   1029  3ba1		       bd ab f3 	      lda	ManAnimTblLo,x
   1030  3ba4		       85 a5		      sta	ManAnimation
   1031  3ba6							;lda ManAnimTblHi,x
   1032  3ba6							;sta ManAnimation+1
   1033  3ba6		       a9 00		      lda	#0
   1034  3ba8		       85 a4		      sta	ManDelayCount
   1035  3baa				   phase0		;jsr MovePlayer
   1036  3baa				   noMovement		;ldx MAN_Player
   1037  3baa
   1038  3baa		       60	   DFS_rts    rts
   1039  3bab
   1040  3bab
   1041  3bab				   ManAnimTblLo
   1042  3bab		       16 1e 26 26*	      .byte.b	AnimateRIGHT-Manimate, AnimateLEFT-Manimate, AnimateUP-Manimate, AnimateUP-Manimate, AnimateSTOPPED-Manimate
   1043  3bb0							;ManAnimTblHi
   1044  3bb0							;    .byte   >AnimateRIGHT, >AnimateLEFT, >AnimateUP, >AnimateUP, >AnimateSTOPPED
   1045  3bb0
   1046  3bb0
   1047  3bb0
   1048  3bb0		       00 00 00 00*JoyMoveX   .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1	;,0, 0,0,0
   1049  3bbc		       00 00 00 00*JoyMoveY   .byte.b	0,0,0,0,0,1,-1,0,0, 1,-1	;, 0,0,1,-1,0
   1050  3bc7
   1051  3bc7				   JoyDirY
   1052  3bc7		       00 00		      .byte.b	0,0	;,1,-1,0
   1053  3bc9				   JoyDirX
   1054  3bc9		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
   1055  3bce
   1056  3bce
   1057  3bce							;------------------------------------------------------------------------------
   1058  3bce
   1059  3bce
      0  3bce					      DEFINE_SUBROUTINE	DrawFullScreen	; = 2568[-96]
      1  3bce		       00 07	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  3bce					      SUBROUTINE
      3  3bce				   DrawFullScreen
   1061  3bce
   1062  3bce							; 83[-7] + 2484[-89] = 2567[-96]
   1063  3bce
   1064  3bce
   1065  3bce		       ad 84 02 	      lda	INTIM	; 4
   1066  3bd1		       c9 29		      cmp	#SEGTIME_BDF	; 2
   1067  3bd3		       90 d5		      bcc	DFS_rts	; 2/3
      0  3bd5					      STRESS_TIME	SEGTIME_BDF
      1  3bd5				  -	      IF	TEST_SEGTIME_BDF = 1
      2  3bd5				  -
      3  3bd5				  -
      4  3bd5				  -
      5  3bd5				  -
      6  3bd5				  -
      7  3bd5				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  3bd5				  -	      bne	. - 7
      9  3bd5					      ENDIF
   1069  3bd5
   1070  3bd5		       a9 f5		      lda	#>( DrawFlag + RAM_WRITE )	; 2
   1071  3bd7		       85 e0		      sta	BDF_DrawFlagAddress+1	; 3
   1072  3bd9		       85 e2		      sta	BDF_DrawFlagAddress2+1	; 3
   1073  3bdb
   1074  3bdb		       ba		      tsx		; 2
   1075  3bdc		       86 e9		      stx	DHS_Stack	; 3
   1076  3bde
   1077  3bde		       e6 8e		      inc	ScreenDrawPhase	; 5
   1078  3be0
   1079  3be0		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
   1080  3be1		       a2 08		      ldx	#SCREEN_LINES	; 2
   1081  3be3		       8a		      txa		; 2 = 31
   1082  3be4
   1083  3be4							; fall through
   1084  3be4
   1085  3be4							;------------------------------------------------------------------------------
   1086  3be4
      0  3be4					      DEFINE_SUBROUTINE	DrawScreenRowPreparation	; = 52[-7]
      1  3be4		       00 07	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  3be4					      SUBROUTINE
      3  3be4				   DrawScreenRowPreparation
   1088  3be4
   1089  3be4							;clc
   1090  3be4		       ca		      dex		; 2
   1091  3be5		       86 e8		      stx	DHS_Line	; 3
   1092  3be7		       65 9a		      adc	BoardScrollY	; 3	     the Y offset of screen into board
   1093  3be9		       a8		      tay		; 2 = 10
   1094  3bea
   1095  3bea							;clc
   1096  3bea		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
   1097  3bed		       65 9b		      adc	BoardScrollX	; 3	     the X offset of screen into board
   1098  3bef		       85 e3		      sta	BDF_BoardAddress	; 3
   1099  3bf1		       69 05		      adc	#SCREEN_WIDTH/2	; 2
   1100  3bf3		       85 e5		      sta	BDF_BoardAddress2	; 3
   1101  3bf5
   1102  3bf5		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
   1103  3bf8		       85 e4		      sta	BDF_BoardAddress+1	; 3
   1104  3bfa		       85 e6		      sta	BDF_BoardAddress2+1	; 3 = 25
   1105  3bfc
   1106  3bfc		       bd c0 f0 	      lda	DrawLineStartLO,x	; 4
   1107  3bff		       85 df		      sta	BDF_DrawFlagAddress	; 3
   1108  3c01		       69 05		      adc	#SCREEN_WIDTH/2	; 2
   1109  3c03		       85 e1		      sta	BDF_DrawFlagAddress2	; 3 = 12
   1110  3c05
   1111  3c05				  -	      IF	MULTI_BANK_BOARD = YES
   1112  3c05				  -	      lda	BoardBank-1,y	; 4
   1113  3c05				  -	      sta	BDF_BoardBank	; 3
   1114  3c05					      ENDIF
   1115  3c05		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
   1116  3c07		       4c 39 fb 	      jmp	CopyRow2	; 3 = 12[-7]
   1117  3c0a
   1118  3c0a							;------------------------------------------------------------------------------
   1119  3c0a
      0  3c0a					      DEFINE_SUBROUTINE	VectorProcess	;=19(A)
      1  3c0a		       00 07	   BANK_VectorProcess =	_CURRENT_BANK
      2  3c0a					      SUBROUTINE
      3  3c0a				   VectorProcess
   1121  3c0a
   1122  3c0a							;sta ROM_Bank			  ;3		  processors can assume bank is stored
   1123  3c0a
   1124  3c0a		       bd 24 f4 	      lda	OSPointerHI,x	;4
   1125  3c0d		       85 e0		      sta	POS_Vector+1	;3
   1126  3c0f		       bd 17 f4 	      lda	OSPointerLO,x	;4
   1127  3c12		       85 df		      sta	POS_Vector	;3
   1128  3c14
   1129  3c14		       6c df 00 	      jmp	(POS_Vector)	;5 = 19	 vector to processor for particular object type
   1130  3c17							;		 NOTE: Bank is either INITBANK or FIXED.
   1131  3c17
   1132  3c17
   1133  3c17				   OBJTYPE    SET	0
   1134  3c17					      MAC	define
   1135  3c17				   TYPE_{1}   =	OBJTYPE
   1136  3c17				   OBJTYPE    .SET	OBJTYPE + 1
   1137  3c17					      ENDM
   1138  3c17
   1139  3c17							; If adding/removing types, the following must also be updated...
   1140  3c17							;   InitialFace[...]		     in DecodeCave.asm
   1141  3c17							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
   1142  3c17							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
   1143  3c17							;   OSPointerLO[...]		     in BANK_INITBANK.asm
   1144  3c17							;   OSPointerHI[...]		     in BANK_INITBANK.asm
   1145  3c17							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1146  3c17							;   CharToType[...]		     in BANK_FIXED.asm (may have deleted types)
   1147  3c17							;   CharToType2[...]		     in DecodeCave.asm (may have deleted types)
   1148  3c17							;   Sortable[...]		     in BANK_FIXED.asm
   1149  3c17
   1150  3c17
      0  3c17					      DEFINE	MAN
      1  3c17		       00 00	   TYPE_MAN   =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	BOX
      1  3c17		       00 01	   TYPE_BOX   =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	AMOEBA
      1  3c17		       00 02	   TYPE_AMOEBA =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	FLUTTERBY
      1  3c17		       00 03	   TYPE_FLUTTERBY =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	FIREFLY
      1  3c17		       00 04	   TYPE_FIREFLY =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	DIAMOND
      1  3c17		       00 05	   TYPE_DIAMOND =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	MAGICWALL
      1  3c17		       00 06	   TYPE_MAGICWALL =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	EXITDOOR
      1  3c17		       00 07	   TYPE_EXITDOOR =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	SELECTOR
      1  3c17		       00 08	   TYPE_SELECTOR =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	EXPLOSION
      1  3c17		       00 09	   TYPE_EXPLOSION =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	EXPLOSION1
      1  3c17		       00 0a	   TYPE_EXPLOSION1 =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	EXPLOSION2
      1  3c17		       00 0b	   TYPE_EXPLOSION2 =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	EXPLOSION3
      1  3c17		       00 0c	   TYPE_EXPLOSION3 =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	BLANK
      1  3c17		       00 0d	   TYPE_BLANK =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	SOIL
      1  3c17		       00 0e	   TYPE_SOIL  =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	STEELWALL
      1  3c17		       00 0f	   TYPE_STEELWALL =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
      0  3c17					      DEFINE	BRICKWALL
      1  3c17		       00 10	   TYPE_BRICKWALL =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
   1168  3c17
      0  3c17					      DEFINE	MAXIMUM
      1  3c17		       00 11	   TYPE_MAXIMUM =	OBJTYPE
      2  3c17				   OBJTYPE    .SET	OBJTYPE + 1
   1170  3c17							;    IF DEMO_VERSION = NO
   1171  3c17							;PROCESS_SELECTOR = 0
   1172  3c17							;    ENDIF
   1173  3c17
   1174  3c17
      0  3c17					      DEFINE_SUBROUTINE	OSPointerLO
      1  3c17		       00 07	   BANK_OSPointerLO =	_CURRENT_BANK
      2  3c17					      SUBROUTINE
      3  3c17				   OSPointerLO
   1176  3c17		       3a		      .byte.b	<PROCESS_MAN
   1177  3c18		       ae		      .byte.b	<PROCESS_BOX
   1178  3c19		       00		      .byte.b	0
   1179  3c1a		       00		      .byte.b	0
   1180  3c1b		       00		      .byte.b	0
   1181  3c1c		       ae		      .byte.b	<PROCESS_DIAMOND
   1182  3c1d		       00		      .byte.b	0	; magic wall
   1183  3c1e		       00		      .byte.b	0	; exit door
   1184  3c1f		       00		      .byte.b	0	;<PROCESS_SELECTOR	    ; selection screen controller
   1185  3c20		       00		      .byte.b	0
   1186  3c21		       00		      .byte.b	0
   1187  3c22		       00		      .byte.b	0
   1188  3c23		       00		      .byte.b	0
   1189  3c24							;		  .byte 0
   1190  3c24							;		  .byte 0			  ; soil
   1191  3c24							;		  .byte 0			  ; steel
   1192  3c24							;		  .byte 0			  ; wall
   1193  3c24
   1194  3c24				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
   1195  3c24				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
   1196  3c24				  -	      EXIT
   1197  3c24					      ENDIF
   1198  3c24
   1199  3c24
      0  3c24					      DEFINE_SUBROUTINE	OSPointerHI
      1  3c24		       00 07	   BANK_OSPointerHI =	_CURRENT_BANK
      2  3c24					      SUBROUTINE
      3  3c24				   OSPointerHI
   1201  3c24		       f9		      .byte.b	>PROCESS_MAN
   1202  3c25		       f9		      .byte.b	>PROCESS_BOX
   1203  3c26		       00		      .byte.b	0
   1204  3c27		       00		      .byte.b	0
   1205  3c28		       00		      .byte.b	0
   1206  3c29		       f9		      .byte.b	>PROCESS_DIAMOND
   1207  3c2a		       00		      .byte.b	0
   1208  3c2b		       00		      .byte.b	0
   1209  3c2c		       00		      .byte.b	0	;>PROCESS_SELECTOR	    ; selection screen controller
   1210  3c2d		       00		      .byte.b	0
   1211  3c2e		       00		      .byte.b	0
   1212  3c2f		       00		      .byte.b	0
   1213  3c30		       00		      .byte.b	0
   1214  3c31							;		  .byte 0
   1215  3c31							;		  .byte 0 ;soil
   1216  3c31							;		  .byte 0 ;steel
   1217  3c31							;		  .byte 0 ;wall
   1218  3c31
   1219  3c31				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
   1220  3c31				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
   1221  3c31				  -	      EXIT
   1222  3c31					      ENDIF
   1223  3c31
   1224  3c31							;	 IF TIMER_DEBUG = NO
   1225  3c31							;    DEFINE_SUBROUTINE OSTimer
   1226  3c31							;		  .byte SEGTIME_MAN
   1227  3c31							;		  .byte SEGTIME_BOULDER1
   1228  3c31							;		  .byte SEGTIME_AMOEBASQUARE
   1229  3c31							;		  .byte SEGTIME_BUTTERFLY
   1230  3c31							;		  .byte SEGTIME_FIREFLY
   1231  3c31							;		  .byte SEGTIME_BOULDER1
   1232  3c31							;		  .byte 0		 ; MAGICWALL
   1233  3c31							;		  .byte 0		  ; exit door
   1234  3c31							;		  .byte 0		     ; selection screen controller (no timer)
   1235  3c31							;		  .byte SEGTIME_EXPLOSION
   1236  3c31							;		  .byte SEGTIME_EXPLOSION
   1237  3c31							;		  .byte SEGTIME_EXPLOSION
   1238  3c31							;		  .byte SEGTIME_EXPLOSION
   1239  3c31							;;		   .byte 0
   1240  3c31							;;		   .byte 0 ;soil
   1241  3c31							;;		   .byte 0 ;steel
   1242  3c31							;;		   .byte 0 ;wall
   1243  3c31							;
   1244  3c31							;    IF * - OSTimer < TYPE_MAXIMUM-4
   1245  3c31							;	  ECHO "ERROR: Missing entry in OSTimer table!"
   1246  3c31							;	  EXIT
   1247  3c31							;    ENDIF
   1248  3c31							;	 ENDIF
   1249  3c31
   1250  3c31
   1251  3c31							;------------------------------------------------------------------------------
   1252  3c31
      0  3c31					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  3c31		       00 07	   BANK_MoveVecLO =	_CURRENT_BANK
      2  3c31					      SUBROUTINE
      3  3c31				   MoveVecLO
   1254  3c31
   1255  3c31		       8e		      .byte.b	<MOVE_BLANK
   1256  3c32		       91		      .byte.b	<MOVE_SOIL
   1257  3c33		       d2		      .byte.b	<MOVE_BOX
   1258  3c34		       cd		      .byte.b	<MOVE_GENERIC	;amoeba
   1259  3c35		       7f		      .byte.b	<MOVE_DIAMOND
   1260  3c36		       7f		      .byte.b	<MOVE_DIAMOND
   1261  3c37		       cd		      .byte.b	<MOVE_GENERIC
   1262  3c38		       cd		      .byte.b	<MOVE_GENERIC
   1263  3c39		       cd		      .byte.b	<MOVE_GENERIC
   1264  3c3a		       cd		      .byte.b	<MOVE_GENERIC
   1265  3c3b		       cd		      .byte.b	<MOVE_GENERIC
   1266  3c3c		       cd		      .byte.b	<MOVE_GENERIC
   1267  3c3d		       cd		      .byte.b	<MOVE_GENERIC
   1268  3c3e		       cd		      .byte.b	<MOVE_GENERIC
   1269  3c3f		       cd		      .byte.b	<MOVE_GENERIC
   1270  3c40		       cd		      .byte.b	<MOVE_GENERIC
   1271  3c41		       cd		      .byte.b	<MOVE_GENERIC
   1272  3c42		       cd		      .byte.b	<MOVE_GENERIC
   1273  3c43		       cd		      .byte.b	<MOVE_GENERIC
   1274  3c44
   1275  3c44		       cd		      .byte.b	<MOVE_GENERIC
   1276  3c45		       cd		      .byte.b	<MOVE_GENERIC
   1277  3c46		       cd		      .byte.b	<MOVE_GENERIC
   1278  3c47		       cd		      .byte.b	<MOVE_GENERIC
   1279  3c48		       cd		      .byte.b	<MOVE_GENERIC	; amoeba???
   1280  3c49
   1281  3c49		       cd		      .byte.b	<MOVE_GENERIC	; falling boulder
   1282  3c4a		       cd		      .byte.b	<MOVE_GENERIC	; falling diamond
   1283  3c4b
   1284  3c4b		       cd		      .byte.b	<MOVE_GENERIC	; unkillable man
   1285  3c4c
   1286  3c4c				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
   1287  3c4c				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
   1288  3c4c				  -	      EXIT
   1289  3c4c					      ENDIF
   1290  3c4c
   1291  3c4c
   1292  3c4c
      0  3c4c					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  3c4c		       00 07	   BANK_MoveVecHI =	_CURRENT_BANK
      2  3c4c					      SUBROUTINE
      3  3c4c				   MoveVecHI
   1294  3c4c
   1295  3c4c		       fa		      .byte.b	>MOVE_BLANK
   1296  3c4d		       fa		      .byte.b	>MOVE_SOIL
   1297  3c4e		       fa		      .byte.b	>MOVE_BOX
   1298  3c4f		       fa		      .byte.b	>MOVE_GENERIC	;amoeba
   1299  3c50		       fa		      .byte.b	>MOVE_DIAMOND
   1300  3c51		       fa		      .byte.b	>MOVE_DIAMOND
   1301  3c52		       fa		      .byte.b	>MOVE_GENERIC
   1302  3c53		       fa		      .byte.b	>MOVE_GENERIC
   1303  3c54		       fa		      .byte.b	>MOVE_GENERIC
   1304  3c55		       fa		      .byte.b	>MOVE_GENERIC
   1305  3c56		       fa		      .byte.b	>MOVE_GENERIC
   1306  3c57		       fa		      .byte.b	>MOVE_GENERIC
   1307  3c58		       fa		      .byte.b	>MOVE_GENERIC
   1308  3c59		       fa		      .byte.b	>MOVE_GENERIC
   1309  3c5a		       fa		      .byte.b	>MOVE_GENERIC
   1310  3c5b		       fa		      .byte.b	>MOVE_GENERIC
   1311  3c5c		       fa		      .byte.b	>MOVE_GENERIC
   1312  3c5d		       fa		      .byte.b	>MOVE_GENERIC
   1313  3c5e		       fa		      .byte.b	>MOVE_GENERIC
   1314  3c5f
   1315  3c5f		       fa		      .byte.b	>MOVE_GENERIC
   1316  3c60		       fa		      .byte.b	>MOVE_GENERIC
   1317  3c61		       fa		      .byte.b	>MOVE_GENERIC
   1318  3c62		       fa		      .byte.b	>MOVE_GENERIC
   1319  3c63		       fa		      .byte.b	>MOVE_GENERIC	;amoeba
   1320  3c64
   1321  3c64		       fa		      .byte.b	>MOVE_GENERIC	; falling boulder
   1322  3c65		       fa		      .byte.b	>MOVE_GENERIC	; falling diamond
   1323  3c66
   1324  3c66		       fa		      .byte.b	>MOVE_GENERIC	; unkillable man
   1325  3c67
   1326  3c67				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
   1327  3c67				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
   1328  3c67				  -	      EXIT
   1329  3c67					      ENDIF
   1330  3c67
   1331  3c67
      0  3c67					      CHECK_BANK_SIZE	"INITBANK"
      1  3c67		       04 67	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $467 , FREE= $399
      2  3c67					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3c67				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3c67				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3c67				  -	      ERR
      6  3c67					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_FIXED.asm LEVEL 2 PASS 3
      0  3c67					      include	"BANK_FIXED.asm"
      1  3c67							;------------------------------------------------------------------------------
      2  3c67							;###############################  FIXED BANK  #################################
      3  3c67							;------------------------------------------------------------------------------
      4  3c67
      5  3c67
      6  3c67				   ORIGIN     SET	FIXED_BANK
      7  3c67
      0  3c67					      NEWBANK	THE_FIXED_BANK
      1  7e2a ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
      9  7800					      RORG	$f800
     10  7800
     11  7800
     12  7800							;------------------------------------------------------------------------------
     13  7800							; TJ: used by:
     14  7800							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
------- FILE Brick_Wall.asm LEVEL 3 PASS 3
      0  7800					      include	"Brick_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      0  7800					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  7800					      LIST	ON
      2  7800
      3  7800		       00 00	   BRICK_WALL_DEF =	0
      4  7800
      5  7800				   CHARACTERSHAPE_FLUTTERBYHOLD
      6  7800				   CHARACTERSHAPE_FLUTTERBYHOLD_MIRRORED
      7  7800				   CHARACTERSHAPE_FIREFLYHOLD
      8  7800				   CHARACTERSHAPE_FIREFLYHOLD_MIRRORED
      9  7800				   CHARACTERSHAPE_FLUTTERBYHOLD2
     10  7800				   CHARACTERSHAPE_FLUTTERBYHOLD2_MIRRORED
     11  7800				   CHARACTERSHAPE_FIREFLYHOLD2
     12  7800				   CHARACTERSHAPE_FIREFLYHOLD2_MIRRORED
     13  7800
     14  7800
     15  7800				   CHARACTERSHAPE_WALL
     16  7800				   CHARACTERSHAPE_WALL0
     17  7800
     18  7800
     19  7800
     20  7800				  -	      if	MIRRORED_WALL = NO
     21  7800				  -CHARACTERSHAPE_WALL_MIRRORED
     22  7800				  -CHARACTERSHAPE_WALL0_MIRRORED
     23  7800					      endif
     24  7800
     25  7800					      if	BRICK_WALL_DEF = 0
     26  7800		       00 77 77 00*	      .byte.b	%00000000,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;R
     27  7807		       77 77 77 00*	      .byte.b	%01110111,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;G
     28  780e		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     29  7815					      endif
     30  7815
     31  7815				  -	      if	BRICK_WALL_DEF = 1
     32  7815				  -	      .byte	%01100110	;R #2 bright color
     33  7815				  -	      .byte	%01110111
     34  7815				  -	      .byte	%01110111
     35  7815				  -	      .byte	%00000000
     36  7815				  -	      .byte	%10011001
     37  7815				  -	      .byte	%11011101
     38  7815				  -	      .byte	%11011101
     39  7815				  -
     40  7815				  -	      .byte	%01100110	;G #1 dark, dirt color
     41  7815				  -	      .byte	%01110111
     42  7815				  -	      .byte	%01110111
     43  7815				  -	      .byte	%00000000
     44  7815				  -	      .byte	%10011001
     45  7815				  -	      .byte	%11011101
     46  7815				  -	      .byte	%11011101
     47  7815				  -
     48  7815				  -	      .byte	%01100110	;B #0 medium, mix color
     49  7815				  -	      .byte	%01110111
     50  7815				  -	      .byte	%00000000
     51  7815				  -	      .byte	%00000000
     52  7815				  -	      .byte	%10011001
     53  7815				  -	      .byte	%11011101
     54  7815				  -	      .byte	%00000000
     55  7815					      endif
     56  7815
     57  7815				  -	      if	BRICK_WALL_DEF = 2
     58  7815				  -	      .byte	%01100110	;R #2 bright color
     59  7815				  -	      .byte	%01110111
     60  7815				  -	      .byte	%01110111
     61  7815				  -	      .byte	%00000000
     62  7815				  -	      .byte	%10011001
     63  7815				  -	      .byte	%11011101
     64  7815				  -	      .byte	%11011101
     65  7815				  -
     66  7815				  -	      .byte	%11111111	;G #1 dark, dirt color
     67  7815				  -	      .byte	%11111111
     68  7815				  -	      .byte	%11111111
     69  7815				  -	      .byte	%11111111
     70  7815				  -	      .byte	%11111111
     71  7815				  -	      .byte	%11111111
     72  7815				  -	      .byte	%11111111
     73  7815				  -
     74  7815				  -	      .byte	%11111111	;B #0 medium, mix color
     75  7815				  -	      .byte	%11111111
     76  7815				  -	      .byte	%11111111
     77  7815				  -	      .byte	%11111111
     78  7815				  -	      .byte	%11111111
     79  7815				  -	      .byte	%11111111
     80  7815				  -	      .byte	%00000000
     81  7815					      endif
     82  7815
     83  7815				  -	      if	BRICK_WALL_DEF = 3
     84  7815				  -	      .byte	%00000000
     85  7815				  -	      .byte	%10011001	;R #2 bright color
     86  7815				  -	      .byte	%11011101
     87  7815				  -	      .byte	%11011101
     88  7815				  -			;.byte %00000000
     89  7815				  -	      .byte	%01100110
     90  7815				  -	      .byte	%01110111
     91  7815				  -	      .byte	%01110111
     92  7815				  -
     93  7815				  -	      .byte	%00000000
     94  7815				  -	      .byte	%10011001	;G #1 dark, dirt color
     95  7815				  -	      .byte	%11011101
     96  7815				  -			;.byte %11011101
     97  7815				  -	      .byte	%00000000
     98  7815				  -	      .byte	%01100110
     99  7815				  -	      .byte	%01110111
    100  7815				  -	      .byte	%01110111
    101  7815				  -
    102  7815				  -	      .byte	%10111011	;B #0 medium, mix color
    103  7815				  -	      .byte	%11111111
    104  7815				  -	      .byte	%11111111
    105  7815				  -	      .byte	%00000000
    106  7815				  -	      .byte	%11101110
    107  7815				  -	      .byte	%11111111
    108  7815				  -	      .byte	%11111111
    109  7815				  -			;.byte %00000000
    110  7815					      endif
    111  7815
    112  7815
    113  7815							;--------------------------------------------------------------------------
    114  7815					      if	MIRRORED_WALL = YES
      0  7815					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  7815					      LIST	ON
    116  7815				   CHARACTERSHAPE_WALL_MIRRORED
    117  7815				   CHARACTERSHAPE_WALL0_MIRRORED
    118  7815
    119  7815					      if	BRICK_WALL_DEF = 0
    120  7815		       00 ee ee 00*	      .byte.b	%00000000,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;R
    121  781c		       ee ee ee 00*	      .byte.b	%11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;G
    122  7823		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
    123  782a					      endif
    124  782a
    125  782a				  -	      if	BRICK_WALL_DEF = 1
    126  782a				  -	      .byte	%01100110	;R
    127  782a				  -	      .byte	%11101110
    128  782a				  -	      .byte	%11101110
    129  782a				  -	      .byte	%00000000
    130  782a				  -	      .byte	%10011001
    131  782a				  -	      .byte	%10111011
    132  782a				  -	      .byte	%10111011
    133  782a				  -
    134  782a				  -	      .byte	%01100110	;G
    135  782a				  -	      .byte	%11101110
    136  782a				  -	      .byte	%11101110
    137  782a				  -	      .byte	%00000000
    138  782a				  -	      .byte	%10011001
    139  782a				  -	      .byte	%10111011
    140  782a				  -	      .byte	%10111011
    141  782a				  -
    142  782a				  -	      .byte	%01100110	;B
    143  782a				  -	      .byte	%11101110
    144  782a				  -	      .byte	%00000000
    145  782a				  -	      .byte	%00000000
    146  782a				  -	      .byte	%10011001
    147  782a				  -	      .byte	%10111011
    148  782a				  -	      .byte	%00000000
    149  782a					      endif
    150  782a
    151  782a				  -	      if	BRICK_WALL_DEF = 2
    152  782a				  -	      .byte	%01100110	;R
    153  782a				  -	      .byte	%11101110
    154  782a				  -	      .byte	%11101110
    155  782a				  -	      .byte	%00000000
    156  782a				  -	      .byte	%10011001
    157  782a				  -	      .byte	%10111011
    158  782a				  -	      .byte	%10111011
    159  782a				  -
    160  782a				  -	      .byte	%11111111	;G #1 dark, dirt color
    161  782a				  -	      .byte	%11111111
    162  782a				  -	      .byte	%11111111
    163  782a				  -	      .byte	%11111111
    164  782a				  -	      .byte	%11111111
    165  782a				  -	      .byte	%11111111
    166  782a				  -	      .byte	%11111111
    167  782a				  -
    168  782a				  -	      .byte	%11111111	;B #0 medium, mix color
    169  782a				  -	      .byte	%11111111
    170  782a				  -	      .byte	%11111111
    171  782a				  -	      .byte	%11111111
    172  782a				  -	      .byte	%11111111
    173  782a				  -	      .byte	%11111111
    174  782a				  -	      .byte	%00000000
    175  782a					      endif
    176  782a
    177  782a				  -	      if	BRICK_WALL_DEF = 3
    178  782a				  -	      .byte	%00000000
    179  782a				  -	      .byte	%10011001	;R
    180  782a				  -	      .byte	%10111011
    181  782a				  -	      .byte	%10111011
    182  782a				  -			;.byte %00000000
    183  782a				  -	      .byte	%01100110
    184  782a				  -	      .byte	%11101110
    185  782a				  -	      .byte	%11101110
    186  782a				  -
    187  782a				  -	      .byte	%00000000
    188  782a				  -	      .byte	%10011001	;G
    189  782a				  -	      .byte	%10111011
    190  782a				  -			;.byte %10111011
    191  782a				  -	      .byte	%00000000
    192  782a				  -	      .byte	%01100110
    193  782a				  -	      .byte	%11101110
    194  782a				  -	      .byte	%11101110
    195  782a				  -
    196  782a				  -	      .byte	%11011101	;B
    197  782a				  -	      .byte	%11111111
    198  782a				  -	      .byte	%11111111
    199  782a				  -	      .byte	%00000000
    200  782a				  -	      .byte	%01110111
    201  782a				  -	      .byte	%11111111
    202  782a				  -	      .byte	%11111111
    203  782a				  -			;.byte %00000000
    204  782a					      endif
    205  782a
    206  782a					      endif
------- FILE BANK_FIXED.asm
     16  782a
     17  782a							;------------------------------------------------------------------------------
     18  782a
      0  782a					      DEFINE_SUBROUTINE	GetSurroundingChars	;=156[-28](C)
      1  782a		       00 0f	   BANK_GetSurroundingChars =	_CURRENT_BANK
      2  782a					      SUBROUTINE
      3  782a				   GetSurroundingChars
     20  782a							; TJ: used by:
     21  782a							; - BANK_INITBANK.asm
     22  782a
     23  782a							; Retrieve the surrounding characters from the board around a given position.
     24  782a							; These are placed into the Surround array with the indexes as shown...
     25  782a
     26  782a							; +------+------+------+
     27  782a							; |*	  | a(0) |	|   *= where Temp_board_address1 points
     28  782a							; +------+------+------+
     29  782a							; | d(3) | X(4) | b(1) |
     30  782a							; +------+------+------+
     31  782a							; |	  | c(2) |	|
     32  782a							; +------+------+------+
     33  782a
     34  782a							; X = ( POS_X,POS_Y )
     35  782a
     36  782a		       a9 07		      lda	#BANK_GetBoardAddress4	;
     37  782c		       85 3f		      sta	SET_BANK	;
     38  782e		       20 e8 f0 	      jsr	GetBoardAddress4	;11+72[-16](C)
     39  7831
     40  7831		       85 3e		      sta	SET_BANK_RAM	;3
     41  7833		       b3 df		      lax	(Temp_Board_Address1),y	;5
     42  7835		       85 82		      sta	Surround	;3
     43  7837
     44  7837				  -	      IF	MULTI_BANK_BOARD = YES
     45  7837				  -	      lda	Temp_Bank3	;3
     46  7837				  -	      sta	SET_BANK_RAM	;3
     47  7837					      ENDIF
     48  7837		       b1 e3		      lda	(Temp_Board_Address3),y	;5
     49  7839		       85 84		      sta	Surround+2	;3
     50  783b
     51  783b				  -	      IF	MULTI_BANK_BOARD = YES
     52  783b				  -	      lda	Temp_Bank2	;3
     53  783b				  -	      sta	SET_BANK_RAM	;3
     54  783b					      ENDIF
     55  783b		       b1 e1		      lda	(Temp_Board_Address2),y	;5
     56  783d		       85 86		      sta	Surround+4	;3
     57  783f
     58  783f		       88		      dey		;2
     59  7840		       b1 e1		      lda	(Temp_Board_Address2),y	;5
     60  7842		       85 85		      sta	Surround+3	;3
     61  7844
     62  7844		       c8		      iny		;2
     63  7845		       c8		      iny		;2
     64  7846		       b1 e1		      lda	(Temp_Board_Address2),y	;5
     65  7848		       85 83		      sta	Surround+1	;3
     66  784a
     67  784a		       a5 c3		      lda	ROM_Bank	;3
     68  784c		       85 3f		      sta	SET_BANK	;3
     69  784e
     70  784e							; returns: X = Surround
     71  784e		       60		      rts		;6 = 156[-12]
     72  784f
     73  784f							;------------------------------------------------------------------------------
     74  784f
      0  784f					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  784f		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  784f					      SUBROUTINE
      3  784f				   DrawTimeFromROM
     76  784f							; TJ: used by:
     77  784f							; - BANK_INITBANK.asm
     78  784f
     79  784f		       85 3e		      sta	SET_BANK_RAM
     80  7851		       20 17 f3 	      jsr	DrawTime
     81  7854		       85 3f		      sta	SET_BANK
     82  7856		       60		      rts
     83  7857
     84  7857							;------------------------------------------------------------------------------
     85  7857
      0  7857					      DEFINE_SUBROUTINE	InsertBlankStack2	;=51(A)
      1  7857		       00 0f	   BANK_InsertBlankStack2 =	_CURRENT_BANK
      2  7857					      SUBROUTINE
      3  7857				   InsertBlankStack2
     87  7857							; TJ: used by:
     88  7857							; - BANK_INITBANK.asm
     89  7857
     90  7857		       85 3e		      sta	SET_BANK_RAM	; 3
     91  7859		       20 f0 f1 	      jsr	InsertBlankStack	; 6+30(A)
     92  785c		       a5 c3		      lda	ROM_Bank	; 3
     93  785e		       85 3f		      sta	SET_BANK	; 3
     94  7860		       60		      rts		; 6
     95  7861
     96  7861							;------------------------------------------------------------------------------
     97  7861
     98  7861
      0  7861					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  7861		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  7861					      SUBROUTINE
      3  7861				   GetROMByte
    100  7861							; TJ: used by:
    101  7861							; - BANK_INITBANK.asm
    102  7861							; - DecodeCave.asm
    103  7861
    104  7861							; a = ROM bank to retrieve (NOTE: status negative flag important!!!!!!!)
    105  7861							; y = page index
    106  7861							; ROM_Bank = bank to return to
    107  7861							; (Board_AddressR) = page
    108  7861							; out a = byte from (Board_AddressR)
    109  7861
    110  7861		       85 3f		      sta	SET_BANK	;3
    111  7863		       4c 68 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
    112  7866
    113  7866							;------------------------------------------------------------------------------
    114  7866
      0  7866					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7866		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7866					      SUBROUTINE
      3  7866				   GetBoardCharacter
    116  7866							; TJ: used by:
    117  7866							; - BANK_INITBANK.asm
    118  7866
    119  7866							; call from ROM bank
    120  7866							; switches back to ROM_Bank on exit
    121  7866
    122  7866							; pass A = bank containing character
    123  7866							; Y = x character position
    124  7866							; (Board_AddressR) points to character position
    125  7866							; returns character from board
    126  7866
    127  7866
    128  7866		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
    129  7868
    130  7868				   GetBoardCharacter2		;=17(A)
    131  7868
    132  7868		       b3 bf		      lax	(Board_AddressR),y	;5
    133  786a		       a4 c3		      ldy	ROM_Bank	;3
    134  786c		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
    135  786e		       60		      rts		;6   and go back
    136  786f
    137  786f							;---------------------------------------------------------------------------
    138  786f
      0  786f					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  786f		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  786f					      SUBROUTINE
      3  786f				   PutBoardCharacter
    140  786f							; TJ: used by:
    141  786f							; - BANK_INITBANK.asm
    142  786f		       86 3e		      stx	SET_BANK_RAM	; 3
    143  7871
    144  7871				   PutBoardCharacterSB		; =18
    145  7871		       91 c1		      sta	(Board_AddressW),y	; 6
    146  7873		       a5 c3		      lda	ROM_Bank	; 3
    147  7875		       85 3f		      sta	SET_BANK	; 3
    148  7877		       60		      rts		; 6 = 21
    149  7878
    150  7878							;---------------------------------------------------------------------------
    151  7878
      0  7878					      DEFINE_SUBROUTINE	PutBoardCharacterButterfly	;=110(B)
      1  7878		       00 0f	   BANK_PutBoardCharacterButterfly =	_CURRENT_BANK
      2  7878					      SUBROUTINE
      3  7878				   PutBoardCharacterButterfly
    153  7878							; TJ: used by:
    154  7878							; - BANK_INITBANK.asm
    155  7878
    156  7878
    157  7878		       86 3e		      stx	SET_BANK_RAM	;3
    158  787a		       91 c1		      sta	(Board_AddressW),y	;6
    159  787c		       4c f4 f9 	      jmp	ReInsertObject	;3+98(B)
    160  787f
    161  787f							;------------------------------------------------------------------------------
    162  787f
      0  787f					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  787f		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  787f					      SUBROUTINE
      3  787f				   GetBoardCharacter__CALL_FROM_RAM__
    164  787f							; TJ: used by:
    165  787f							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
    166  787f							; - DecodeCave.asm
    167  787f
    168  787f		       a4 90		      ldy	POS_Y	;3
    169  7881
    170  7881		       a9 07		      lda	#BANK_GetBoardAddressR	;
    171  7883		       85 3f		      sta	SET_BANK	;
    172  7885		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    173  7888
    174  7888
      0  7888					      DEFINE_SUBROUTINE	PartialGetBoardCharacter	;=23
      1  7888		       00 0f	   BANK_PartialGetBoardCharacter =	_CURRENT_BANK
      2  7888					      SUBROUTINE
      3  7888				   PartialGetBoardCharacter
    176  7888							; TJ: used by:
    177  7888							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
    178  7888
    179  7888		       85 3e		      sta	SET_BANK_RAM	;3
    180  788a		       a4 8f		      ldy	POS_X	;3
    181  788c		       b3 bf		      lax	(Board_AddressR),y	;5
    182  788e		       a4 c4		      ldy	RAM_Bank	;3
    183  7890		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    184  7892		       60		      rts		;6		 and go back
    185  7893
    186  7893							;---------------------------------------------------------------------------
    187  7893
      0  7893					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  7893		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  7893					      SUBROUTINE
      3  7893				   PutBoardCharacterFromRAM
    189  7893							; TJ: used by:
    190  7893							; - BANK_INITBANK.asm
    191  7893							; - DecodeCave.asm
    192  7893
    193  7893							; POS_Y  = row
    194  7893							; POS_Type = character to write
    195  7893							; POS_X     = column
    196  7893							; RAM_Bank = caller's bank
    197  7893
    198  7893		       a4 90		      ldy	POS_Y	;3
    199  7895
    200  7895		       a9 07		      lda	#BANK_GetBoardAddressW	;
    201  7897		       85 3f		      sta	SET_BANK	;
    202  7899		       20 0d f1 	      jsr	GetBoardAddressW	;11+24[-2](A)
    203  789c
    204  789c		       86 3e		      stx	SET_BANK_RAM	;3
    205  789e
    206  789e		       a4 8f		      ldy	POS_X	;3
    207  78a0		       a5 93		      lda	POS_Type	;3
    208  78a2		       91 c1		      sta	(Board_AddressW),y	;6
    209  78a4		       a4 c4		      ldy	RAM_Bank	;3
    210  78a6		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    211  78a8		       60		      rts		;6
    212  78a9
    213  78a9
    214  78a9							;---------------------------------------------------------------------------
    215  78a9
      0  78a9					      DEFINE_SUBROUTINE	ProcessObjStack	; 15 minimum segtime abort
      1  78a9		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  78a9					      SUBROUTINE
      3  78a9				   ProcessObjStack
    217  78a9							; TJ: used by:
    218  78a9							; - BANK_FIXED.asm
    219  78a9
    220  78a9		       ad 84 02 	      lda	INTIM	;4
    221  78ac		       c9 04		      cmp	#MINIMUM_SEGTIME	;2
    222  78ae		       90 55		      bcc	EarlyAbort	;2/3= 8
      0  78b0					      STRESS_TIME	MINIMUM_SEGTIME
      1  78b0				  -	      IF	TEST_MINIMUM_SEGTIME = 1
      2  78b0				  -
      3  78b0				  -
      4  78b0				  -
      5  78b0				  -
      6  78b0				  -
      7  78b0				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  78b0				  -	      bne	. - 7
      9  78b0					      ENDIF
    224  78b0
    225  78b0		       a5 8a		      lda	ObjStackNum	;3
    226  78b2		       49 01		      eor	#1	;2
    227  78b4		       aa		      tax		;2
    228  78b5
    229  78b5		       a5 dd		      lda	ObjIterator	;3
    230  78b7		       d5 8b		      cmp	ObjStackPtr,x	;5
    231  78b9		       b0 2e		      bcs	doBlanks	;2/3		check for blanks
    232  78bb
    233  78bb							; Process an object...
    234  78bb							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    235  78bb
    236  78bb		       bc 51 fa 	      ldy	BankObjStack,x	;4
    237  78be		       84 3e		      sty	SET_BANK_RAM	;3
    238  78c0
    239  78c0		       aa		      tax		;2
    240  78c1		       bc 80 11 	      ldy	SortedObjPtr,x	;4		 indirect object pointer list (sorted)
    241  78c4
    242  78c4		       b9 00 10 	      lda	ObjStackX,y	;4
    243  78c7		       85 8f		      sta	POS_X	;3
    244  78c9		       b9 80 10 	      lda	ObjStackY,y	;4
    245  78cc		       85 90		      sta	POS_Y	;3
    246  78ce		       b9 00 11 	      lda	ObjStackVar,y	;4
    247  78d1		       85 94		      sta	POS_VAR	;3
    248  78d3		       be 00 12 	      ldx	ObjStackType,y	;4
    249  78d6		       86 93		      stx	POS_Type	;3
    250  78d8
    251  78d8		       a9 07		      lda	#BANK_VectorProcess	;2
    252  78da		       85 3f		      sta	SET_BANK	;3
    253  78dc
    254  78dc		       bd 24 f4 	      lda	OSPointerHI,x	;4
    255  78df		       85 e0		      sta	POS_Vector+1	;3
    256  78e1		       bd 17 f4 	      lda	OSPointerLO,x	;4
    257  78e4		       85 df		      sta	POS_Vector	;3
    258  78e6
    259  78e6		       6c df 00 	      jmp	(POS_Vector)	;5 = 82	 vector to processor for particular object type
    260  78e9
    261  78e9
    262  78e9							;---------------------------------------------------------------------------
    263  78e9							; Now process the blank stack.  This stack holds all the recently blanked squares
    264  78e9							; and determines (and moves) BOXs or diamonds into these squares.  The space vacated
    265  78e9							; by these objects are added again to the blank stack.
    266  78e9
    267  78e9		       e6 8e	   doBlanks   inc	ScreenDrawPhase
    268  78eb		       a4 8d		      ldy	BlankStackPtr	; 3
    269  78ed		       f0 14		      beq	nextPhase	; 2/3		 blanks finished!!
    270  78ef
      0  78ef					      DEFINE_SUBROUTINE	ProcessBlankStack	;=892
      1  78ef		       00 0f	   BANK_ProcessBlankStack =	_CURRENT_BANK
      2  78ef					      SUBROUTINE
      3  78ef				   ProcessBlankStack
    272  78ef
    273  78ef		       ad 84 02 	      lda	INTIM	;4
    274  78f2		       c9 10		      cmp	#MINIMUM_SEGTIMEBLANK	;2
    275  78f4		       90 0f		      bcc	EarlyAbort	;2/3
      0  78f6					      STRESS_TIME	MINIMUM_SEGTIMEBLANK
      1  78f6				  -	      IF	TEST_MINIMUM_SEGTIMEBLANK = 1
      2  78f6				  -
      3  78f6				  -
      4  78f6				  -
      5  78f6				  -
      6  78f6				  -
      7  78f6				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  78f6				  -	      bne	. - 7
      9  78f6					      ENDIF
    277  78f6
    278  78f6		       a9 08		      lda	#BANK_DRAW_BUFFERS	;2
    279  78f8		       85 3e		      sta	SET_BANK_RAM	;3
    280  78fa		       85 c4		      sta	RAM_Bank	;3
    281  78fc		       20 93 f2 	      jsr	BlankCreatureInsertion	;6+853
    282  78ff
    283  78ff		       c6 8d	   NextBlank  dec	BlankStackPtr	;5		 one less object on the blank stack
    284  7901		       d0 ec		      bne	ProcessBlankStack	;2/3
    285  7903
    286  7903		       e6 8e	   nextPhase  inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    287  7905		       60	   EarlyAbort rts		;6
    288  7906
    289  7906
    290  7906
    291  7906							;---------------------------------------------------------------------------
    292  7906
      0  7906					      DEFINE_SUBROUTINE	SwitchObjects	;=72
      1  7906		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  7906					      SUBROUTINE
      3  7906				   SwitchObjects
    294  7906							; TJ: used by:
    295  7906							; - BANK_FIXED.asm
    296  7906
    297  7906							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    298  7906							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    299  7906							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    300  7906
    301  7906		       ad 84 02 	      lda	INTIM	; 4
    302  7909		       c9 03		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    303  790b		       90 f8		      bcc	EarlyAbort	; 2/3= 8
      0  790d					      STRESS_TIME	SEGTIME_SWITCHOBJECTS
      1  790d				  -	      IF	TEST_SEGTIME_SWITCHOBJECTS = 1
      2  790d				  -
      3  790d				  -
      4  790d				  -
      5  790d				  -
      6  790d				  -
      7  790d				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  790d				  -	      bne	. - 7
      9  790d					      ENDIF
    305  790d
    306  790d							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    307  790d							; we're at the throttle cutoff do we switch game-frames.
    308  790d
    309  790d							;sec
    310  790d		       a5 b3		      lda	Throttle	;3
    311  790f		       e9 a0		      sbc	#MAX_THROTTLE	;2
    312  7911		       90 f2		      bcc	EarlyAbort	;2/3		 plenty of time left!
    313  7913
    314  7913							; Time is up. But we may be in a cave which requires perfect sorting (e.g., intermission 4)
    315  7913							; So we check for these caves, and wait for the sort to complete for those.
    316  7913
    317  7913		       24 b2		      bit	caveDisplay	;3
    318  7915		       50 08		      bvc	keepFractional	;2/3		 screen does not require complete sort
    319  7917
    320  7917							; We have an intermission or screen which requires the sort to go to completion
    321  7917							; Check to see if the sort is finished...
    322  7917
    323  7917		       a4 d4		      ldy	sortPtr	;3
    324  7919		       d0 ea		      bne	EarlyAbort	;2/3		 sort still in progress, so wait
    325  791b		       a4 d3		      ldy	sortRequired	;3
    326  791d		       10 e6		      bpl	EarlyAbort	;2/3		 sort still in progress, so wait
    327  791f
    328  791f		       85 b3	   keepFractional sta	Throttle	;3		 save fractional 'left over' bit
    329  7921
    330  7921
    331  7921							; Pause the game with B/W switch:
    332  7921
    333  7921		       a5 80		      lda	gameMode
    334  7923							;		  ora LookingAround		  ; New behavour of looking around pauses creatures when activated.
    335  7923		       30 14		      bmi	.paused	; pause flag set
    336  7925
    337  7925							; Now that we have completed processing both the object and blanks stacks, we switch
    338  7925							; the stack bank pointers for the next time around.
    339  7925
    340  7925		       a5 8a		      lda	ObjStackNum	;3
    341  7927		       49 01		      eor	#1	;2
    342  7929		       aa		      tax		;2
    343  792a		       86 8a		      stx	ObjStackNum	;3		 swap stacks @here
    344  792c
    345  792c							; STOP the sort so it doesn't corrupt the "other" object stack. Sort may get a look-in immediately after
    346  792c							; this code is finished, so we don't want it to do something unexpected!
    347  792c
    348  792c		       a0 ff		      ldy	#<(-1)	;2
    349  792e		       84 d3		      sty	sortRequired	;3
    350  7930		       c8		      iny		;2		 Y==0
    351  7931		       84 d4		      sty	sortPtr	;3
    352  7933
    353  7933							; Initialise the iterator and stack pointer for next time around.
    354  7933							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    355  7933							; necessary to initialise both.
    356  7933
    357  7933		       84 dd		      sty	ObjIterator	;3		 Y==0
    358  7935		       94 8b		      sty	ObjStackPtr,x	;4
    359  7937
    360  7937		       84 8e		      sty	ScreenDrawPhase	;3
    361  7939				   .paused
    362  7939		       60	   quickExit  rts		;6
    363  793a
    364  793a							;---------------------------------------------------------------------------
    365  793a
      0  793a					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  793a		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  793a					      SUBROUTINE
      3  793a				   PROCESS_MAN
    367  793a							; TJ: used by:
    368  793a							; - BANK_INITBANK.asm
    369  793a
    370  793a		       ad 84 02 	      lda	INTIM
    371  793d		       c9 18		      cmp	#SEGTIME_MAN
    372  793f		       90 c4		      bcc	EarlyAbort
      0  7941					      STRESS_TIME	SEGTIME_MAN
      1  7941				  -	      IF	TEST_SEGTIME_MAN = 1
      2  7941				  -
      3  7941				  -
      4  7941				  -
      5  7941				  -
      6  7941				  -
      7  7941				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7941				  -	      bne	. - 7
      9  7941					      ENDIF
    374  7941
    375  7941		       a9 02		      lda	#BANK_GetJoystickForDemoMode
    376  7943		       85 3f		      sta	SET_BANK
    377  7945		       20 18 f4 	      jsr	GetJoystickForDemoMode	; 2 player/2 joysticks
    378  7948
    379  7948		       a9 07		      lda	#BANK_ManProcess
    380  794a		       85 c3		      sta	ROM_Bank
    381  794c		       85 3f		      sta	SET_BANK
    382  794e		       20 84 f1 	      jsr	ManProcess
    383  7951
    384  7951		       20 53 fa 	      jsr	MovePlayer	; 6+{}
    385  7954
    386  7954		       a5 dc		      lda	specialTimeFlag
    387  7956		       10 e1		      bpl	quickExit	; time problem (e.g., bigbang)
    388  7958
    389  7958		       a9 02		      lda	#BANK_AdvanceJoystick	;
    390  795a		       85 3f		      sta	SET_BANK	;
    391  795c		       20 00 f4 	      jsr	AdvanceJoystick	;11+49      2 player/2 joysticks
    392  795f
    393  795f		       a9 06		      lda	#BANK_TrackPlayer	;
    394  7961		       85 3f		      sta	SET_BANK	;
    395  7963		       20 32 f5 	      jsr	TrackPlayer	;11+145
    396  7966
    397  7966		       a9 00		      lda	#TYPE_MAN	; 2
    398  7968		       85 93		      sta	POS_Type	; 3
    399  796a
    400  796a		       20 21 fa 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    401  796d		       4c f7 f9    gnobj      jmp	NextObject
    402  7970
    403  7970							;---------------------------------------------------------------------------
    404  7970
    405  7970
      0  7970					      DEFINE_SUBROUTINE	RestoreOriginalCharacter	;=93[-2](A)
      1  7970		       00 0f	   BANK_RestoreOriginalCharacter =	_CURRENT_BANK
      2  7970					      SUBROUTINE
      3  7970				   RestoreOriginalCharacter
    407  7970							; TJ: used by:
    408  7970							; - BANK_FIXED.asm
    409  7970							; - BANK_INITBANK.asm
    410  7970
    411  7970		       a6 90		      ldx	POS_Y	;3
    412  7972		       a4 8f		      ldy	POS_X	;3
    413  7974
    414  7974		       a9 07		      lda	#BANK_BoardLineStartLO	;2
    415  7976		       85 3f		      sta	SET_BANK	;3
    416  7978
    417  7978		       bd 01 f0 	      lda	BoardLineStartLO,x	;4
    418  797b		       85 c1		      sta	Board_AddressW	;3
    419  797d		       bd 2d f0 	      lda	BoardLineStartHiW,x	;4
    420  7980		       85 c2		      sta	Board_AddressW+1	;3 WRITE address
    421  7982				  -	      IF	MULTI_BANK_BOARD = YES
    422  7982				  -	      lda	BoardBank,x	;4 switch this on return
    423  7982					      ELSE
    424  7982		       a9 0d		      lda	#BANK_BOARD	;2
    425  7984					      ENDIF
    426  7984		       85 3e		      sta	SET_BANK_RAM	;3
    427  7986
    428  7986		       a5 94		      lda	POS_VAR	;3
    429  7988		       91 c1		      sta	(Board_AddressW),y	;6 clear vacated board position
    430  798a
    431  798a							;lda #BANK_DRAW_BUFFERS	  ;2
    432  798a							;sta SET_BANK_RAM		  ;3
    433  798a							;jsr InsertBlankStack		  ;6+30(A)
    434  798a
    435  798a		       a5 c3		      lda	ROM_Bank	;3
    436  798c		       85 3f		      sta	SET_BANK	;3
    437  798e		       60		      rts		;6
    438  798f
    439  798f
      0  798f					      DEFINE_SUBROUTINE	BlankOriginalLocation	;=93[-2](A)
      1  798f		       00 0f	   BANK_BlankOriginalLocation =	_CURRENT_BANK
      2  798f					      SUBROUTINE
      3  798f				   BlankOriginalLocation
    441  798f							; TJ: used by:
    442  798f							; - BANK_FIXED.asm
    443  798f							; - BANK_INITBANK.asm
    444  798f
    445  798f		       a6 90		      ldx	POS_Y	;3
    446  7991		       a4 8f		      ldy	POS_X	;3
    447  7993
      0  7993					      DEFINE_SUBROUTINE	BlankOriginalLocationXY	;=87[-2](A)
      1  7993		       00 0f	   BANK_BlankOriginalLocationXY =	_CURRENT_BANK
      2  7993					      SUBROUTINE
      3  7993				   BlankOriginalLocationXY
    449  7993
    450  7993		       a9 07		      lda	#BANK_BoardLineStartLO	;2
    451  7995		       85 3f		      sta	SET_BANK	;3
    452  7997
    453  7997		       bd 01 f0 	      lda	BoardLineStartLO,x	;4
    454  799a		       85 c1		      sta	Board_AddressW	;3
    455  799c		       bd 2d f0 	      lda	BoardLineStartHiW,x	;4
    456  799f		       85 c2		      sta	Board_AddressW+1	;3 WRITE address
    457  79a1				  -	      IF	MULTI_BANK_BOARD = YES
    458  79a1				  -	      lda	BoardBank,x	;4 switch this on return
    459  79a1					      ELSE
    460  79a1		       a9 0d		      lda	#BANK_BOARD	;2
    461  79a3					      ENDIF
    462  79a3		       85 3e		      sta	SET_BANK_RAM	;3
    463  79a5
    464  79a5		       a9 00		      lda	#CHARACTER_BLANK	;2
    465  79a7		       91 c1		      sta	(Board_AddressW),y	;6 clear vacated board position
    466  79a9
    467  79a9							;lda #BANK_DRAW_BUFFERS	  ;2
    468  79a9							;sta SET_BANK_RAM		  ;3
    469  79a9							;jsr InsertBlankStack		  ;6+30(A)
    470  79a9
    471  79a9		       a5 c3		      lda	ROM_Bank	;3
    472  79ab		       85 3f		      sta	SET_BANK	;3
    473  79ad
    474  79ad				   EarlyAbortBOX
    475  79ad
    476  79ad		       60		      rts		;6
    477  79ae
    478  79ae							;---------------------------------------------------------------------------
    479  79ae
    480  79ae							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    481  79ae							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    482  79ae
    483  79ae							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    484  79ae
    485  79ae							; if the creature dies then jump NextObject
    486  79ae
    487  79ae
      0  79ae					      DEFINE_SUBROUTINE	PROCESS_BOX
      1  79ae		       00 0f	   BANK_PROCESS_BOX =	_CURRENT_BANK
      2  79ae					      SUBROUTINE
      3  79ae				   PROCESS_BOX
      0  79ae					      DEFINE_SUBROUTINE	PROCESS_DIAMOND
      1  79ae		       00 0f	   BANK_PROCESS_DIAMOND =	_CURRENT_BANK
      2  79ae					      SUBROUTINE
      3  79ae				   PROCESS_DIAMOND
    490  79ae							; TJ: used by:
    491  79ae							; - BANK_INITBANK.asm
    492  79ae
    493  79ae		       ad 84 02 	      lda	INTIM	;4
    494  79b1		       c9 05		      cmp	#SEGTIME_BOX1	;2
    495  79b3		       90 f8		      bcc	EarlyAbortBOX	;2/3
      0  79b5					      STRESS_TIME	SEGTIME_BOX1
      1  79b5				  -	      IF	TEST_SEGTIME_BOX1 = 1
      2  79b5				  -
      3  79b5				  -
      4  79b5				  -
      5  79b5				  -
      6  79b5				  -
      7  79b5				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  79b5				  -	      bne	. - 7
      9  79b5					      ENDIF
    497  79b5
    498  79b5		       a5 8f		      lda	POS_X	;3
    499  79b7		       85 91		      sta	POS_X_NEW	;3
    500  79b9		       a4 90		      ldy	POS_Y	;3
    501  79bb		       84 92		      sty	POS_Y_NEW	;3
    502  79bd
    503  79bd							; Make sure the character we're working with is still the same type of object
    504  79bd							; (for example, a 'BOX' placed on the object stack by the blank stack
    505  79bd							; handler, may no longer be there, so it's really a dummy).
    506  79bd
    507  79bd							;ldy POS_Y			  ;3
    508  79bd
    509  79bd		       a9 07		      lda	#BANK_GetBoardAddressR	;
    510  79bf		       85 3f		      sta	SET_BANK	;
    511  79c1		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    512  79c4		       85 3e		      sta	SET_BANK_RAM	;3
    513  79c6
    514  79c6		       a4 8f		      ldy	POS_X	;3
    515  79c8		       b3 bf		      lax	(Board_AddressR),y	;5
    516  79ca		       bd ee fc 	      lda	CharToType,x	;4
    517  79cd		       c5 93		      cmp	POS_Type	;3
    518  79cf							;bne gnobj			  ;2/3
    519  79cf
    520  79cf		       4c d3 f9 	      jmp	NotStraightDown	; Sokoban ovveride
    521  79d2
    522  79d2
    523  79d2				   NotEnoughTime2
    524  79d2		       60		      rts
    525  79d3
    526  79d3				   NotStraightDown
    527  79d3		       ad 84 02 	      lda	INTIM
    528  79d6		       c9 08		      cmp	#SEGTIME_BOX3
    529  79d8		       90 f8		      bcc	NotEnoughTime2
      0  79da					      STRESS_TIME	SEGTIME_BOX3
      1  79da				  -	      IF	TEST_SEGTIME_BOX3 = 1
      2  79da				  -
      3  79da				  -
      4  79da				  -
      5  79da				  -
      6  79da				  -
      7  79da				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  79da				  -	      bne	. - 7
      9  79da					      ENDIF
    531  79da
    532  79da				   ProcessBD
    533  79da
    534  79da							; Depending on the character UNDER this object (since this object can't fall straight
    535  79da							; down), we either fall sideways or not.  Currently we fall if the object we are
    536  79da							; on top of is a 'rounded' object AND the two sideways squares are blank.
    537  79da
    538  79da							; Note that the object under us may be a NON-ROUNDED (=FALLING) BOX/diamond
    539  79da
    540  79da							;;lda GenericCharFlag,x	       ; is the object we're sitting on 'rounded'?
    541  79da							;;and #GENERIC_MASK_ROUNDED
    542  79da							;;bne mayRoundOff
    543  79da
    544  79da							; Could have been FALLING character/object type, so replace with a default character on the board
    545  79da
    546  79da				   ReplaceFallingChar
    547  79da
    548  79da		       a4 90		      ldy	POS_Y
    549  79dc
    550  79dc		       a9 07		      lda	#BANK_GetBoardAddressW	;
    551  79de		       85 3f		      sta	SET_BANK	;
    552  79e0		       20 0d f1 	      jsr	GetBoardAddressW	;11+24[-2](A)
    553  79e3		       86 3e		      stx	SET_BANK_RAM	;3
    554  79e5
    555  79e5		       a4 8f		      ldy	POS_X
    556  79e7		       a6 93		      ldx	POS_Type
    557  79e9		       bd cc fc 	      lda	BaseTypeCharacter,x	; original character base character
    558  79ec		       91 c1		      sta	(Board_AddressW),y	; draw object in new location (Y = new X posn)
    559  79ee
    560  79ee							; We have just...
    561  79ee							; a) Rolled off a rounded object, or...  (TJ, TODO: Original makes no sound here)
    562  79ee							; b) Hit an object which we can't squash
    563  79ee							; So, play a terminating sound but only if the object was already falling
    564  79ee
    565  79ee		       20 fc f9 	      jsr	StartSoundCheckAlreadyFalling
    566  79f1				   silentAlways
    567  79f1		       4c f7 f9    wasNotFalling jmp	NextObject	; no, so we can't roll off it. Object becomes quiescent.
    568  79f4
    569  79f4							; The object underneath is rounded, so we may roll off it.  We preferentially roll
    570  79f4							; to the left.  Rolling involves moving sideways if the square to the side is blank AND
    571  79f4							; the one below that one is squashable.  Here we get the 4 squares which will be
    572  79f4							; involved in the calcs...
    573  79f4							;;mayRoundOff					       ; y == POS_X
    574  79f4							;;		   dey
    575  79f4							;;		   lda (Board_AddressR),y	       ; leftward of row UNDERNEATH
    576  79f4							;;		   sta BOXLeft
    577  79f4							;;		   iny
    578  79f4							;;		   iny
    579  79f4							;;		   lda (Board_AddressR),y
    580  79f4							;;		   sta BOXRight 		   ; rightward of row UNDERNEATH
    581  79f4
    582  79f4							;;		   ldy POS_Y
    583  79f4
    584  79f4							;;		   lda #BANK_GetBoardAddressR	       ;
    585  79f4							;;		   sta SET_BANK 		       ;
    586  79f4							;;		   jsr GetBoardAddressR 	       ;11+24[-2](A)
    587  79f4							;;		   sta SET_BANK_RAM		       ;3
    588  79f4
    589  79f4							;;		   ldy POS_X
    590  79f4							;;		   dey
    591  79f4							;;		   lda (Board_AddressR),y	       ; leftward of current row
    592  79f4
    593  79f4							;;		   ora BOXLeft			   ; check for the movement left/down
    594  79f4							;;		   bne MayRollRight		       ; there must be NOTHING in the left squares
    595  79f4
    596  79f4							;;		   dec POS_X_NEW		       ; new position (LEFT)
    597  79f4							;;		   bpl BlankDownSound		       ; unconditional
    598  79f4
    599  79f4							;;MayRollRight
    600  79f4
    601  79f4							; check for the movement right/down
    602  79f4							;;		   iny
    603  79f4							;;		   iny
    604  79f4							;;		   lda (Board_AddressR),y	       ; rightward of current row
    605  79f4							;;		   ora BOXRight
    606  79f4							;;		   bne ReplaceFallingChar	       ; there must be NOTHING in the right squares
    607  79f4
    608  79f4							;;		   inc POS_X_NEW		       ; new position (RIGHT)
    609  79f4
    610  79f4							;;BlankDownSound:
    611  79f4
    612  79f4							;;		   jsr StartSoundCheckAlreadyFalling   ; prevent a sound if the object wasn't already falling
    613  79f4							;;		   lda #VAR_FALLING		       ; this prevents a sound in the following
    614  79f4							;;		   sta POS_VAR			       ; ...call to StartSoundCheckFalling
    615  79f4
    616  79f4							;;BlankDown
    617  79f4
    618  79f4							;;		   lda INTIM
    619  79f4							;;		   cmp #SEGTIME_BOX4
    620  79f4							;;		   bcc NotEnoughTime
    621  79f4							;;		   STRESS_TIME SEGTIME_BOX4
    622  79f4
    623  79f4							; The object is 'falling' into position (POS_X_NEW,POS_Y_NEW)
    624  79f4							; object starts falling, so we play a sound here too:
    625  79f4
    626  79f4							;;		   lda #<(~VAR_FALLING) 	       ; do not start if already falling
    627  79f4							;;		   jsr StartSoundCheckFalling
    628  79f4
    629  79f4							;;		   lda #VAR_FALLING
    630  79f4							;;		   sta POS_VAR
    631  79f4
    632  79f4							;lda POS_VAR
    633  79f4							;ora #VAR_FALLING
    634  79f4							;sta POS_VAR			      ; indicate object *is* falling
    635  79f4
    636  79f4							;;		   jsr BlankOriginalLocation	   ;6+97(A)	   blank/stack previous position
    637  79f4
    638  79f4							;;		   ldy POS_Y_NEW
    639  79f4							;;		   sty POS_Y
    640  79f4
    641  79f4							;;		   lda #BANK_GetBoardAddressW	       ;
    642  79f4							;;		   sta SET_BANK 		       ;
    643  79f4							;;		   jsr GetBoardAddressW 	       ;11+24[-2](A)
    644  79f4							;;		   stx SET_BANK_RAM		       ;3
    645  79f4
    646  79f4							;;		   ldy POS_X_NEW
    647  79f4							;;		   sty POS_X
    648  79f4
    649  79f4							;;		   ldx POS_Type
    650  79f4							;;		   lda BaseTypeCharacterFalling,x		; original character base character
    651  79f4							;;		   sta (Board_AddressW),y			; draw object in new location (Y = new X posn)
    652  79f4
    653  79f4		       20 21 fa    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    654  79f7
    655  79f7				   NextObject
    656  79f7		       e6 dd		      inc	ObjIterator	; 5
    657  79f9							;		  dec ObjStackPtr,x		  ; 6
    658  79f9		       4c a9 f8 	      jmp	ProcessObjStack	; 3 = 16
    659  79fc
    660  79fc							;---------------------------------------------------------------------------
    661  79fc
      0  79fc					      DEFINE_SUBROUTINE	StartSoundCheckAlreadyFalling
      1  79fc		       00 0f	   BANK_StartSoundCheckAlreadyFalling =	_CURRENT_BANK
      2  79fc					      SUBROUTINE
      3  79fc				   StartSoundCheckAlreadyFalling
    663  79fc							; TJ: used by:
    664  79fc							; - BANK_FIXED.asm
    665  79fc		       a9 80		      lda	#VAR_FALLING	; play ONLY if we were already falling
      0  79fe					      DEFINE_SUBROUTINE	StartSoundCheckFalling
      1  79fe		       00 0f	   BANK_StartSoundCheckFalling =	_CURRENT_BANK
      2  79fe					      SUBROUTINE
      3  79fe				   StartSoundCheckFalling
    667  79fe		       45 94		      eor	POS_VAR	; check if already falling or not
    668  7a00		       30 11		      bmi	.noSound	; <--- DANGEROUS assumption of flag value
      0  7a02					      DEFINE_SUBROUTINE	StartSoundAlways
      1  7a02		       00 0f	   BANK_StartSoundAlways =	_CURRENT_BANK
      2  7a02					      SUBROUTINE
      3  7a02				   StartSoundAlways
    670  7a02		       a4 93		      ldy	POS_Type
    671  7a04		       a5 db		      lda	newSounds
    672  7a06		       29 0f		      and	#SND_MASK_LO	; already a new sound triggerd?
    673  7a08		       c9 03		      cmp	#SOUND_MOVE_SOIL+1	; except for low priority move sounds!
    674  7a0a		       b0 07		      bcs	.noSound	; yes, no new sound
    675  7a0c		       45 db		      eor	newSounds
    676  7a0e		       19 13 fa 	      ora	FallSoundTbl-TYPE_BOX,y
    677  7a11		       85 db		      sta	newSounds
    678  7a13				   .noSound
    679  7a13		       60		      rts
    680  7a14
    681  7a14							;---------------------------------------------------------------------------
    682  7a14
    683  7a14							; Warning: Hardwired dependence on existing TYPE_
    684  7a14							; sounds are played when BOXs/diamonds start *and* end falling:
    685  7a14				   FallSoundTbl
    686  7a14							; TJ: used by:
    687  7a14							; - BANK_FIXED.asm
    688  7a14		       03		      .byte.b	SOUND_BOX	; TYPE_BOX
    689  7a15		       00		      .byte.b	0
    690  7a16		       00		      .byte.b	0
    691  7a17		       00		      .byte.b	0
    692  7a18		       05		      .byte.b	SOUND_DIAMOND_FALLING	; TYPE_DIAMOND
    693  7a19
    694  7a19							;---------------------------------------------------------------------------
    695  7a19
      0  7a19					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  7a19		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  7a19					      SUBROUTINE
      3  7a19				   InsertObjectStackFromRAM
    697  7a19							; TJ: used by:
    698  7a19							; - BANK_FIXED.asm
    699  7a19							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
    700  7a19
    701  7a19		       20 21 fa 	      jsr	InsertObjectStack	;6+76(B)
    702  7a1c		       a5 c4		      lda	RAM_Bank	;3
    703  7a1e		       85 3e		      sta	SET_BANK_RAM	;3
    704  7a20
    705  7a20		       60	   NotEnoughTime rts		;6
    706  7a21
    707  7a21							;---------------------------------------------------------------------------
    708  7a21
      0  7a21					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  7a21		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  7a21					      SUBROUTINE
      3  7a21				   InsertObjectStack
    710  7a21							; TJ: used by:
    711  7a21							; - BANK_FIXED.asm
    712  7a21							; - BANK_INITBANK.asm
    713  7a21
    714  7a21							; POS_X     x position
    715  7a21							; POS_Y     y position
    716  7a21							; POS_VAR   direction or other variable
    717  7a21							; POS_Type  type of object
    718  7a21
    719  7a21		       a6 8a		      ldx	ObjStackNum	; 3
    720  7a23		       bc 51 fa 	      ldy	BankObjStack,x	; 4
    721  7a26		       84 3e		      sty	SET_BANK_RAM	; 3
    722  7a28		       b4 8b		      ldy	ObjStackPtr,x	; 4 = 14
    723  7a2a
    724  7a2a
    725  7a2a		       a5 90		      lda	POS_Y	; 3
    726  7a2c		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    727  7a2f		       a5 8f		      lda	POS_X	; 3
    728  7a31		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    729  7a34		       a5 94		      lda	POS_VAR	; 3
    730  7a36		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    731  7a39		       a5 93		      lda	POS_Type	; 3
    732  7a3b		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    733  7a3e
    734  7a3e							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    735  7a3e							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    736  7a3e							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    737  7a3e
    738  7a3e
    739  7a3e				  -	      IF	TYPE_MAN != 0
    740  7a3e				  -	      cmp	#TYPE_MAN	; 2
    741  7a3e					      ENDIF
    742  7a3e		       f0 04		      beq	alwaysAllowMan	; 2/3
    743  7a40
    744  7a40		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    745  7a42		       b0 08		      bcs	insertDone	; 2/3= 6    no room -- drop object
    746  7a44				   alwaysAllowMan
    747  7a44
    748  7a44		       98		      tya		; 2
    749  7a45		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    750  7a48
    751  7a48		       f6 8b		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    752  7a4a					      IF	SORT_OBJECTS = YES
    753  7a4a		       84 d3		      sty	sortRequired	; 3	     flag that a sort is required
    754  7a4c					      ENDIF
    755  7a4c
    756  7a4c		       a4 c3	   insertDone ldy	ROM_Bank	; 3
    757  7a4e		       84 3f		      sty	SET_BANK	; 3
    758  7a50
    759  7a50		       60	   ManIsDead2 rts		; 6 = 29
    760  7a51
    761  7a51							;---------------------------------------------------------------------------
    762  7a51
    763  7a51		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    764  7a53							; TJ: used by:
    765  7a53							; - BANK_FIXED.asm
    766  7a53
    767  7a53							;---------------------------------------------------------------------------
    768  7a53
    769  7a53
    770  7a53				   MovePlayer
    771  7a53							; TJ: used by:
    772  7a53							; - BANK_FIXED.asm
    773  7a53							; - BANK_INITBANK.asm
    774  7a53		       a5 a3		      lda	ManMode
    775  7a55		       c9 02		      cmp	#MANMODE_DEAD
    776  7a57		       b0 f7		      bcs	ManIsDead2
    777  7a59
    778  7a59		       a4 92		      ldy	POS_Y_NEW
    779  7a5b
    780  7a5b		       a9 07		      lda	#BANK_GetBoardAddressRW	;2
    781  7a5d		       85 3f		      sta	SET_BANK	;3
    782  7a5f		       85 c3		      sta	ROM_Bank	;3
    783  7a61		       20 c8 f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    784  7a64				  -	      IF	MULTI_BANK_BOARD = YES
    785  7a64				  -	      stx	RAM_Bank
    786  7a64					      ENDIF
    787  7a64		       86 3e		      stx	SET_BANK_RAM	; 3
    788  7a66
    789  7a66		       a4 91		      ldy	POS_X_NEW
    790  7a68		       b3 bf		      lax	(Board_AddressR),y
    791  7a6a							; TODO: would it makes sense to add a move conversion table?
    792  7a6a							; that way, the move tables would become much smaller
    793  7a6a		       a9 07		      lda	#BANK_MoveVecLO
    794  7a6c		       85 3f		      sta	SET_BANK
    795  7a6e
    796  7a6e		       bd 31 f4 	      lda	MoveVecLO,x
    797  7a71		       85 df		      sta	MAN_Move
    798  7a73		       bd 4c f4 	      lda	MoveVecHI,x
    799  7a76		       85 e0		      sta	MAN_Move+1
    800  7a78
    801  7a78				  -	      IF	MULTI_BANK_BOARD = YES
    802  7a78				  -	      lda	RAM_Bank
    803  7a78					      ELSE
    804  7a78		       a9 0d		      lda	#BANK_BOARD
    805  7a7a					      ENDIF
    806  7a7a		       85 3e		      sta	SET_BANK_RAM
    807  7a7c		       6c df 00 	      jmp	(MAN_Move)
    808  7a7f
    809  7a7f							;---------------------------------------------------------------------------
    810  7a7f
    811  7a7f
    812  7a7f				   MOVE_DIAMOND
    813  7a7f							; TJ: used by:
    814  7a7f							; - BANK_FIXED.asm
    815  7a7f
    816  7a7f
    817  7a7f		       ad 84 02 	      lda	INTIM
    818  7a82		       c9 11		      cmp	#SEGTIME_GET_DIAMOND
    819  7a84		       66 dc		      ror	specialTimeFlag	; mark any overtime!
    820  7a86		       10 49		      bpl	timeExit
      0  7a88					      STRESS_TIME	SEGTIME_GET_DIAMOND
      1  7a88				  -	      IF	TEST_SEGTIME_GET_DIAMOND = 1
      2  7a88				  -
      3  7a88				  -
      4  7a88				  -
      5  7a88				  -
      6  7a88				  -
      7  7a88				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7a88				  -	      bne	. - 7
      9  7a88					      ENDIF
    822  7a88
    823  7a88				  -	      IF	MULTI_BANK_BOARD = YES
    824  7a88				  -	      lda	RAM_Bank
    825  7a88					      ELSE
    826  7a88		       a9 0d		      lda	#BANK_BOARD
    827  7a8a					      ENDIF
    828  7a8a		       85 3e		      sta	SET_BANK_RAM
    829  7a8c		       10 1c		      bpl	checkForSnatch	;3		 unconditional
    830  7a8e
    831  7a8e							;---------------------------------------------------------------------------
    832  7a8e
    833  7a8e				   MOVE_BLANK
    834  7a8e							; TJ: used by:
    835  7a8e							; - BANK_FIXED.asm
    836  7a8e
    837  7a8e							; The movement sounds are lowest priority. They only trigger if there is a free channel.
    838  7a8e							; The code below checks the two channels and if either is free, uses it for the move sound.
    839  7a8e
    840  7a8e		       a0 01		      ldy	#SOUND_MOVE_BLANK	; 2
      0  7a90					      NOP_W		; 2
      1  7a90		       0c		      .byte.b	$0c
    842  7a91		       a0 02	   MOVE_SOIL  ldy	#SOUND_MOVE_SOIL	; 2
    843  7a93							; TJ: used by:
    844  7a93							; - BANK_FIXED.asm
    845  7a93
    846  7a93							; lowest priority, look for a free channel, 0 first
    847  7a93
    848  7a93		       a7 db		      lax	newSounds
    849  7a95		       29 0f		      and	#SND_MASK_LO
    850  7a97		       d0 03		      bne	.skipUseLow	;		 LO channel is not available
    851  7a99
    852  7a99		       98		      tya
    853  7a9a		       d0 0a		      bne	.setSound	;		 unconditional: USE lo channel!
    854  7a9c
    855  7a9c				   .skipUseLow
    856  7a9c		       8a		      txa
    857  7a9d		       29 f0		      and	#SND_MASK_HI
    858  7a9f		       d0 09		      bne	checkForSnatch	;2/3		 no channel available so skip sound
    859  7aa1
    860  7aa1		       98		      tya
    861  7aa2		       0a		      asl
    862  7aa3		       0a		      asl
    863  7aa4		       0a		      asl
    864  7aa5		       0a		      asl		;		 use requested sound in Hi channel
    865  7aa6
    866  7aa6		       05 db	   .setSound  ora	newSounds
    867  7aa8		       85 db		      sta	newSounds
    868  7aaa
    869  7aaa							;---------------------------------------------------------------------------
    870  7aaa							; Handle snatching...
    871  7aaa
    872  7aaa				   checkForSnatch
    873  7aaa
    874  7aaa
    875  7aaa		       a9 0d		      lda	#BANK_BOARD
    876  7aac		       85 3e		      sta	SET_BANK_RAM
    877  7aae
    878  7aae		       a4 91		      ldy	POS_X_NEW
    879  7ab0		       b1 bf		      lda	(Board_AddressR),y
    880  7ab2		       48		      pha
    881  7ab3
    882  7ab3		       a9 06		      lda	#CHARACTER_MANOCCUPIED	; 2
    883  7ab5		       91 c1		      sta	(Board_AddressW),y	; 6 =	8	 the man's new square
    884  7ab7
    885  7ab7
    886  7ab7		       a6 a0		      ldx	ManY	; 3
    887  7ab9		       86 90		      stx	POS_Y	; 3
    888  7abb		       a4 9f		      ldy	ManX	; 3
    889  7abd		       84 8f		      sty	POS_X	; 3 = 12
    890  7abf
    891  7abf		       20 70 f9 	      jsr	RestoreOriginalCharacter
    892  7ac2
    893  7ac2		       68		      pla
    894  7ac3		       85 94		      sta	POS_VAR
    895  7ac5
    896  7ac5
    897  7ac5		       a5 91	   pastblank  lda	POS_X_NEW	; 3
    898  7ac7		       85 9f		      sta	ManX	; 3
    899  7ac9		       a5 92		      lda	POS_Y_NEW	; 3
    900  7acb		       85 a0		      sta	ManY	; 3 = 12	 actually MOVE!
    901  7acd
    902  7acd				   MOVE_GENERIC
    903  7acd							; TJ: used by:
    904  7acd							; - BANK_FIXED.asm
    905  7acd		       a9 00		      lda	#0	; 2
    906  7acf		       85 a9		      sta	ManPushCounter	; 3
    907  7ad1		       60	   timeExit   rts		; 6 = 11
    908  7ad2
    909  7ad2							;---------------------------------------------------------------------------
    910  7ad2
      0  7ad2					      DEFINE_SUBROUTINE	MOVE_BOX
      1  7ad2		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  7ad2					      SUBROUTINE
      3  7ad2				   MOVE_BOX
    912  7ad2							; TJ: used by:
    913  7ad2							; - BANK_FIXED.asm
    914  7ad2
    915  7ad2		       a9 07		      lda	#BANK_PushBox
    916  7ad4		       85 3f		      sta	SET_BANK
    917  7ad6		       4c 1a f1 	      jmp	PushBox
    918  7ad9
    919  7ad9							;---------------------------------------------------------------------------
    920  7ad9
      0  7ad9					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7ad9		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7ad9					      SUBROUTINE
      3  7ad9				   StealCharDraw
    922  7ad9							; TJ: used by:
    923  7ad9							; - BANK_FIXED.asm
    924  7ad9
    925  7ad9		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    926  7adb		       85 3e		      sta	SET_BANK_RAM	; 3
    927  7add		       a4 89		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    928  7adf		       10 35		      bpl	EnterStealCharDraw	; 3 = 10(11)
    929  7ae1
    930  7ae1				   ExitStealCharDraw
    931  7ae1
    932  7ae1							; fall through...
    933  7ae1
    934  7ae1							;---------------------------------------------------------------------------
    935  7ae1
      0  7ae1					      DEFINE_SUBROUTINE	TimeSlice
      1  7ae1		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7ae1					      SUBROUTINE
      3  7ae1				   TimeSlice
    937  7ae1							; TJ: used by:
    938  7ae1							; - BANK_FIXED.asm
    939  7ae1
    940  7ae1							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    941  7ae1							; going ahead if there's insufficient time. This allows the previous character drawing to
    942  7ae1							; be much smaller in time, as they don't have to include the timeslice code overhead.
    943  7ae1
    944  7ae1		       ad 84 02 	      lda	INTIM	; 4
    945  7ae4		       c9 05		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    946  7ae6		       90 e9		      bcc	timeExit	; 2(3)
    947  7ae8
    948  7ae8							; Uses the phase variable to vector to the correct processing code for the given timeslice
    949  7ae8							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    950  7ae8							; it should increment ScreenDrawPhase.
    951  7ae8
    952  7ae8							; Switched-in bank(s) are undefined after this function is called!
    953  7ae8
    954  7ae8		       a9 06		      lda	#BANK_TS_PhaseVectorLO	; 2
    955  7aea		       85 3f		      sta	SET_BANK	; 3
    956  7aec
    957  7aec		       a6 8e		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    958  7aee		       bd b9 f5 	      lda	TS_PhaseVectorLO,x	; 4
    959  7af1		       85 df		      sta	TS_Vector	; 3
    960  7af3		       bd bf f5 	      lda	TS_PhaseVectorHI,x	; 4
    961  7af6		       85 e0		      sta	TS_Vector+1	; 3
    962  7af8
    963  7af8		       bd c5 f5 	      lda	TS_PhaseBank,x	; 4
    964  7afb		       85 3f		      sta	SET_BANK	; 3		 switch bank
    965  7afd
    966  7afd		       6c df 00 	      jmp	(TS_Vector)	; 3 = 40	 vector to timeslice handler
    967  7b00
    968  7b00							; = 55 minimum return time (if segtime abort)
    969  7b00
    970  7b00							;---------------------------------------------------------------------------
    971  7b00
    972  7b00
    973  7b00				   DrawAnother
    974  7b00							; TJ: used by:
    975  7b00							; - BANK_ROM_SHADOW_RAMBANK.asm
    976  7b00
    977  7b00		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    978  7b02		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    979  7b04
    980  7b04		       a4 89		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    981  7b06
    982  7b06		       be 00 f1 	      ldx	DrawStack,y	; 4	     in actuality a character index
    983  7b09		       bd a0 f1 	      lda	ScreenBuffer,x	; 4	     new character to draw
    984  7b0c		       29 7f		      and	#~128	; 2
    985  7b0e		       9d a0 f5 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    986  7b11
    987  7b11		       88		      dey		; 2
    988  7b12		       84 89		      sty	DrawStackPointer	; 3	     one less to draw
    989  7b14		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7
    990  7b16
    991  7b16				   EnterStealCharDraw		;	     RAM bank MUST be at BANK_DRAW_BUFFERS
    992  7b16							; TJ: used by:
    993  7b16							; - BANK_FIXED.asm
    994  7b16
    995  7b16		       ad 84 02 	      lda	INTIM	; 4
    996  7b19		       c9 05		      cmp	#SEGTIME_SCD_MIN	; 2
    997  7b1b		       90 c4		      bcc	ExitStealCharDraw	; 2/3= 8
    998  7b1d
    999  7b1d		       be 00 f1 	      ldx	DrawStack,y	; 4	     in actuality a character index
   1000  7b20		       bc a0 f1 	      ldy	ScreenBuffer,x	; 4 =	8    new character to draw
   1001  7b23
   1002  7b23		       bd 3f f3 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
   1003  7b26		       85 3e		      sta	SET_BANK_RAM	; 3
   1004  7b28		       4c 53 f1 	      jmp	StealPart3	; 3 = 10    --> 18 cycles after check for SEGTIME_SCD_MIN
   1005  7b2b
   1006  7b2b
   1007  7b2b							;---------------------------------------------------------------------------
   1008  7b2b
      0  7b2b					      DEFINE_SUBROUTINE	BuildDrawStack	; in FIXED BANK
      1  7b2b		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7b2b					      SUBROUTINE
      3  7b2b				   BuildDrawStack
   1010  7b2b							; TJ: used by:
   1011  7b2b							; - BANK_FIXED.asm
   1012  7b2b
   1013  7b2b		       a9 08		      lda	#BANK_DRAW_BUFFERS
   1014  7b2d		       85 3e		      sta	SET_BANK_RAM
   1015  7b2f		       4c 01 f2 	      jmp	DrawStackUpdate
   1016  7b32
   1017  7b32							;---------------------------------------------------------------------------
   1018  7b32
      0  7b32					      DEFINE_SUBROUTINE	DrawAIntoStack	; in FIXED BANK
      1  7b32		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7b32					      SUBROUTINE
      3  7b32				   DrawAIntoStack
   1020  7b32							; TJ: used by:
   1021  7b32							; - BANK_FIXED.asm
   1022  7b32
   1023  7b32		       a9 08		      lda	#BANK_DRAW_BUFFERS
   1024  7b34		       85 3e		      sta	SET_BANK_RAM
   1025  7b36		       4c 2e f2 	      jmp	DrawIntoStack
   1026  7b39
   1027  7b39
   1028  7b39							;---------------------------------------------------------------------------
   1029  7b39
   1030  7b39
      0  7b39					      DEFINE_SUBROUTINE	DrawFullScreenMain	;=2484[-89]
      1  7b39		       00 0f	   BANK_DrawFullScreenMain =	_CURRENT_BANK
      2  7b39					      SUBROUTINE
      3  7b39				   DrawFullScreenMain
   1032  7b39
   1033  7b39							; Check the screen for all those characters that need to be redrawn
   1034  7b39							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
   1035  7b39							; the drawflags array is different to the ScreenBuffer array entry, then the
   1036  7b39							; screenbuffer will need redrawing.
   1037  7b39
   1038  7b39				   CopyRow2
   1039  7b39							; TJ: used by:
   1040  7b39							; - BANK_INITBANK.asm
   1041  7b39
   1042  7b39				  -	      IF	MULTI_BANK_BOARD = YES
   1043  7b39				  -	      lda	BDF_BoardBank	; 3
   1044  7b39					      ELSE
   1045  7b39		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
   1046  7b3b					      ENDIF
   1047  7b3b		       85 3e		      sta	SET_BANK_RAM	; 3
   1048  7b3d		       b3 e3		      lax	(BDF_BoardAddress),y	; 5
   1049  7b3f		       9a		      txs		; 2
   1050  7b40		       b3 e5		      lax	(BDF_BoardAddress2),y	; 5(= 18[-1])
   1051  7b42
   1052  7b42		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
   1053  7b44		       85 3e		      sta	SET_BANK_RAM	; 3
   1054  7b46		       bd d4 f2 	      lda	CharReplacement,x	; 4
   1055  7b49		       91 e1		      sta	(BDF_DrawFlagAddress2),y	; 6
   1056  7b4b		       ba		      tsx		; 2
   1057  7b4c		       bd d4 f2 	      lda	CharReplacement,x	; 4
   1058  7b4f		       91 df		      sta	(BDF_DrawFlagAddress),y	; 6(= 27)
   1059  7b51
   1060  7b51		       88		      dey		; 2
   1061  7b52		       10 e5		      bpl	CopyRow2	; 2/3=49/50[-1]
   1062  7b54							; total: 5*49[-1]-1 = 244[-5]
   1063  7b54
   1064  7b54							; TJ: examples for multi RAM bank access.
   1065  7b54							;CopyRow2
   1066  7b54							;		  lax (BDF_BoardAddress),y	  ; 5
   1067  7b54							;		  txs				  ; 2
   1068  7b54							;		  lax (BDF_BoardAddress2),y	  ; 5(= 12)
   1069  7b54							;		  lda CharReplacement,x 	  ; 4
   1070  7b54							;		  sta (BDF_DrawFlagAddress2),y	  ; 6
   1071  7b54							;		  tsx				  ; 2
   1072  7b54							;		  lda CharReplacement,x 	  ; 4
   1073  7b54							;		  sta (BDF_DrawFlagAddress),y	  ; 6(= 22)
   1074  7b54							;		  dey				  ; 2
   1075  7b54							;		  bpl CopyRow2			  ; 2/3=38/39
   1076  7b54							;; total: 5*39 - 1 = 194
   1077  7b54							;
   1078  7b54							;CopyRow2
   1079  7b54							;		  lax (BDF_BoardAddress),y	  ; 5
   1080  7b54							;		  lda CharReplacement,x 	  ; 4
   1081  7b54							;		  sta (BDF_DrawFlagAddress),y	  ; 6(= 15)
   1082  7b54							;		  dey				  ; 2
   1083  7b54							;		  bpl CopyRow2			  ; 2/3=19/20
   1084  7b54							;; total: 10*20 - 1 = 199 (and much less setup code)
   1085  7b54
   1086  7b54		       a7 e8		      lax	DHS_Line	; 3
   1087  7b56		       f0 07		      beq	.exitCopy	; 2/3= 5/6
   1088  7b58
   1089  7b58		       a0 07		      ldy	#BANK_DrawScreenRowPreparation	;2
   1090  7b5a		       84 3f		      sty	SET_BANK	; 3
   1091  7b5c		       4c e4 f3 	      jmp	DrawScreenRowPreparation	;55[-7] = 60[-7]
   1092  7b5f
   1093  7b5f							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
   1094  7b5f
   1095  7b5f
      0  7b5f					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7b5f					      LIST	ON
   1097  7b5f
   1098  7b5f		       a6 e9	   .exitCopy  ldx	DHS_Stack	; 3
   1099  7b61		       9a		      txs		; 2
   1100  7b62
   1101  7b62		       4c 2b fb 	      jmp	BuildDrawStack
   1102  7b65
   1103  7b65		       60	   SwitchPhaseR rts		; 6 = 11
   1104  7b66
   1105  7b66							;---------------------------------------------------------------------------
   1106  7b66
   1107  7b66				   Reset
   1108  7b66							; TJ: used by:
   1109  7b66							; - BANK_FIXED.asm
   1110  7b66
      0  7b66					      CLEAN_START
      1  7b66		       78		      sei
      2  7b67		       d8		      cld
      3  7b68
      4  7b68		       a2 00		      ldx	#0
      5  7b6a		       8a		      txa
      6  7b6b		       a8		      tay
      7  7b6c		       ca	   .CLEAR_STACK dex
      8  7b6d		       9a		      txs
      9  7b6e		       48		      pha
     10  7b6f		       d0 fb		      bne	.CLEAR_STACK
     11  7b71
   1112  7b71
   1113  7b71							; Scoring bank is copied once (not per game, not per level...)
   1114  7b71							; otherwise non-SaveKey high score gets zapped
   1115  7b71
   1116  7b71		       a2 05		      ldx	#ROM_SHADOW_OF_BANK_SCORING
   1117  7b73		       a0 09		      ldy	#BANK_SCORING
   1118  7b75		       20 9e fd 	      jsr	CopyROM2RAM_F000
   1119  7b78
   1120  7b78				   Restart		; go here on RESET + SELECT
   1121  7b78							; TJ: used by:
   1122  7b78							; - BANK_INITBANK.asm
   1123  7b78
   1124  7b78
   1125  7b78				   Title
   1126  7b78		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
   1127  7b7a		       9a		      txs
   1128  7b7b
   1129  7b7b		       a9 01		      lda	#BANK_TitleScreen	; 2
   1130  7b7d		       85 3f		      sta	SET_BANK	; 3
   1131  7b7f		       4c af f1 	      jmp	TitleScreen	; 3+x
   1132  7b82				   ExitTitleScreen
   1133  7b82							; temporary vars from title screen are used to init level/cave
   1134  7b82		       a9 06		      lda	#BANK_Cart_Init	; 2
   1135  7b84		       85 3f		      sta	SET_BANK	; 3
   1136  7b86		       20 ed f3 	      jsr	Cart_Init	; 6+x
   1137  7b89
   1138  7b89
   1139  7b89							;---------------------------------------------------------------------------
   1140  7b89
   1141  7b89
   1142  7b89		       f0 00	   SEGMENT_DECODE_CAVE_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
   1143  7b89
   1144  7b89		       a2 06		      ldx	#BANK_DECODE_CAVE_SHADOW
   1145  7b8b		       a0 0a		      ldy	#BANK_DECODE_CAVE
   1146  7b8d		       20 9e fd 	      jsr	CopyROM2RAM_F000
   1147  7b90
   1148  7b90
   1149  7b90							;---------------------------------------------------------------------------
   1150  7b90							; Once-only game initialisation goes here...
   1151  7b90							; now we have two players so things get a bit tricky
   1152  7b90
   1153  7b90		       a9 09		      lda	#BANK_SCORING
   1154  7b92		       85 3e		      sta	SET_BANK_RAM
   1155  7b94		       20 b6 f3 	      jsr	GameInitialise
   1156  7b97
   1157  7b97
   1158  7b97							;---------------------------------------------------------------------------
   1159  7b97
   1160  7b97				   RestartCaveNextPlayer
   1161  7b97							; TJ: used by:
   1162  7b97							; - BANK_FIXED.asm
   1163  7b97
   1164  7b97							; a player has lost a life.
   1165  7b97							; store his vars, swap to other player, continue
   1166  7b97
   1167  7b97							;lda #BANK_SCORING
   1168  7b97							;sta SET_BANK_RAM
   1169  7b97							;jsr SwapPlayers
   1170  7b97
   1171  7b97		       a9 06		      lda	#BANK_SwapPlayersGeneric
   1172  7b99		       85 3f		      sta	SET_BANK
   1173  7b9b		       20 40 f4 	      jsr	SwapPlayersGeneric
   1174  7b9e
   1175  7b9e
   1176  7b9e		       a5 ab		      lda	MenCurrent
   1177  7ba0		       f0 d6		      beq	Title	; all lives lost! (works for both P1P2)
   1178  7ba2		       d0 04		      bne	skipDemoCheck
   1179  7ba4
   1180  7ba4				   NextCaveLevel
   1181  7ba4		       24 ac		      bit	demoMode
   1182  7ba6		       30 d0		      bmi	Title
   1183  7ba8				   skipDemoCheck
   1184  7ba8
   1185  7ba8							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
   1186  7ba8							; including those for general systems function. But NOT those which do not need re-initialising between
   1187  7ba8							; levels.
   1188  7ba8		       a9 06		      lda	#BANK_LevelInit	; 2
   1189  7baa		       85 3f		      sta	SET_BANK	; 3
   1190  7bac		       20 a5 f4 	      jsr	LevelInit	; 6+x
   1191  7baf
   1192  7baf		       a9 0a		      lda	#BANK_DECODE_CAVE
   1193  7bb1		       85 3e		      sta	SET_BANK_RAM
   1194  7bb3		       20 eb f0 	      jsr	DecodeCave
   1195  7bb6
   1196  7bb6							; Setup player animation and scroll limits.
   1197  7bb6							; Mangle the board colours based on level
   1198  7bb6
   1199  7bb6		       a9 06		      lda	#BANK_CreateCreatures	; 2
   1200  7bb8		       85 3f		      sta	SET_BANK	; 3
   1201  7bba		       20 58 f4 	      jsr	CreateCreatures	; 6+x
   1202  7bbd
   1203  7bbd
   1204  7bbd							; Setup the various digit and display pointers
   1205  7bbd							; Grab current player's score/cave/level from backup
   1206  7bbd
   1207  7bbd		       20 92 fd 	      jsr	goGeneralScoringSetups
   1208  7bc0
   1209  7bc0							; copy the screen draw ROM shadow to RAM
   1210  7bc0
   1211  7bc0		       a0 07		      ldy	#SCREEN_LINES-1
   1212  7bc2		       a2 03	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
   1213  7bc4		       20 9e fd 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
   1214  7bc7		       20 77 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
   1215  7bca		       88		      dey
   1216  7bcb		       10 f5		      bpl	CopyScreenBanks
   1217  7bcd
   1218  7bcd		       a2 04		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
   1219  7bcf		       a0 08		      ldy	#BANK_DRAW_BUFFERS
   1220  7bd1		       20 43 f0 	      jsr	CopyROMShadowToRAM_F000
   1221  7bd4
   1222  7bd4							;---------------------------------------------------------------------------
   1223  7bd4
   1224  7bd4		       a9 06		      lda	#BANK_Resync	; 2
   1225  7bd6		       85 3f		      sta	SET_BANK	; 3
   1226  7bd8		       20 de f4 	      jsr	Resync	; 6+x
   1227  7bdb
   1228  7bdb				   NewFrameBD
   1229  7bdb							; the (at least) 220 cycles wasted in the above... bugs me!
   1230  7bdb							; the below is an unrolled version.  I've moved some other code between the sync writes, effectively saving um... 22 cycles/frame.
   1231  7bdb							; This required TIM64T values to be increased by 1 for each platform (we have actually gained back some usable time :)
   1232  7bdb
   1233  7bdb		       24 c9		      bit	NextLevelTrigger
   1234  7bdd		       10 c5		      bpl	NextCaveLevel	; game-triggered next level
   1235  7bdf		       70 b6		      bvs	RestartCaveNextPlayer	; loss of life
   1236  7be1
   1237  7be1							; Note: VSYNC must NOT be on when starting a new cave! Else you get annoying TV signals.
   1238  7be1
   1239  7be1		       a9 0e		      lda	#%1110	; VSYNC ON
   1240  7be3		       85 42	   .loopVSync sta	WSYNC
   1241  7be5		       85 40		      sta	VSYNC
   1242  7be7		       4a		      lsr
   1243  7be8		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
   1244  7bea
   1245  7bea							; moved *after* the loop since this allows to *increase* timer values by 1!
   1246  7bea
   1247  7bea		       a6 81		      ldx	Platform
   1248  7bec		       bc 41 fc 	      ldy	VBlankTime,x
   1249  7bef		       8c 96 02 	      sty	TIM64T
   1250  7bf2
   1251  7bf2		       a2 00		      ldx	#BANK_PlaySounds
   1252  7bf4		       86 3f		      stx	SET_BANK
   1253  7bf6
   1254  7bf6							;---------------------------------------------------------------------------
   1255  7bf6							; Do not separate code, as bank assumption is made
   1256  7bf6
   1257  7bf6		       20 22 f3 	      jsr	PlaySounds	; 6+x	 Jentzsch sound system
   1258  7bf9
   1259  7bf9		       20 d9 fa 	      jsr	StealCharDraw	; NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
   1260  7bfc					      IF	SORT_OBJECTS = YES
   1261  7bfc		       20 3d fd 	      jsr	SortObjects2	; 6+15 mininum. Opportunistic sorting
   1262  7bff					      ENDIF
   1263  7bff
   1264  7bff							;---------------------------------------------------------------------------
   1265  7bff							; START OF DISPLAY
   1266  7bff
   1267  7bff		       a9 09		      lda	#BANK_SCORING	; 2
   1268  7c01		       85 3e		      sta	SET_BANK_RAM	; 3
   1269  7c03		       20 d3 f1 	      jsr	DrawDigits	; 6 = 11
   1270  7c06
   1271  7c06							;---------------------------------------------------------------------------
   1272  7c06							; A 42-cycle timing window in the screen draw code.  Perform any general
   1273  7c06							; per-frame code here, provided it takes exactly 42 cycles to execute.
   1274  7c06							; TJ: Well, not exactly 42 cycles, but it works! :)
   1275  7c06							;	 @09
   1276  7c06		       85 49		      sta	COLUBK	; 3	 value comes from subroutine
   1277  7c08							; + the 'black' left-side of top screen colour change when look-around is actually a HMOVE bar, so we can't fix it :)
   1278  7c08
   1279  7c08
   1280  7c08							;		  inc Throttle		      ; 5     speed limiter
      0  7c08					      SLEEP	5	;	 TODO: optimize for space
      1  7c08				   .CYCLES    SET	5
      2  7c08
      3  7c08				  -	      IF	.CYCLES < 2
      4  7c08				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c08				  -	      ERR
      6  7c08					      ENDIF
      7  7c08
      8  7c08					      IF	.CYCLES & 1
      9  7c08					      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c08		       04 00		      nop	0
     11  7c0a				  -	      ELSE
     12  7c0a				  -	      bit	VSYNC
     13  7c0a					      ENDIF
     14  7c0a				   .CYCLES    SET	.CYCLES - 3
     15  7c0a					      ENDIF
     16  7c0a
     17  7c0a					      REPEAT	.CYCLES / 2
     18  7c0a		       ea		      nop
     19  7c0b					      REPEND
   1282  7c0b
   1283  7c0b		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
   1284  7c0d		       ca		      dex		; 2	 = $6f, stars effect!
   1285  7c0e		       86 62		      stx	HMM0	; 3	 @24, exactly 21 cycles after the HMOVE
   1286  7c10
   1287  7c10		       85 44		      sta	NUSIZ0	; 3
   1288  7c12		       84 65		      sty	VDELP0	; 3	 y = 0!
   1289  7c14
   1290  7c14		       c8		      iny		; 2	 this relies on Y == 0 before...
   1291  7c15		       c4 c6		      cpy	extraLifeTimer	; 3	 ..,and bit 0 is set in A
   1292  7c17		       69 02		      adc	#2	; 2
   1293  7c19		       85 5d		      sta	ENAM0	; 3	 dis/enable Cosmic Ark star effect
   1294  7c1b
   1295  7c1b		       a5 a8		      lda	ManLastDirection	; 3
   1296  7c1d		       85 4b		      sta	REFP0	; 3
   1297  7c1f
   1298  7c1f		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
   1299  7c21		       85 3e		      sta	SET_BANK_RAM	; 3
   1300  7c23		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1301  7c26							;	 @66
   1302  7c26		       a9 06		      lda	#BANK_PostScreenCleanup	; 2
   1303  7c28		       85 3f		      sta	SET_BANK	; 3
   1304  7c2a		       20 d3 f5 	      jsr	PostScreenCleanup	; 6+x
   1305  7c2d
   1306  7c2d		       a9 03		      lda	#BANK_SelfModDrawPlayers	; 2
   1307  7c2f		       85 3f		      sta	SET_BANK	; 3
   1308  7c31		       20 fb f2 	      jsr	SelfModDrawPlayers	; 6+x
   1309  7c34
   1310  7c34		       20 d9 fa 	      jsr	StealCharDraw
   1311  7c37					      IF	SORT_OBJECTS = YES
   1312  7c37		       20 3d fd 	      jsr	SortObjects2	;6+15 minimum	Opportunistic sorting
   1313  7c3a					      ENDIF
   1314  7c3a
   1315  7c3a		       ad 84 02    OverscanBD lda	INTIM	;4
   1316  7c3d		       d0 fb		      bne	OverscanBD	;2/3
   1317  7c3f		       f0 9a		      beq	NewFrameBD	;3	 unconditional
   1318  7c41
   1319  7c41				   VBlankTime
   1320  7c41							; TJ: used by:
   1321  7c41							; - BANK_FIXED.asm
   1322  7c41		       3e 3e		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
   1323  7c43		       55 3e		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_NTSC
   1324  7c45
   1325  7c45							;---------------------------------------------------------------------------
   1326  7c45
   1327  7c45				   CharacterDataVecLO
   1328  7c45							; TJ: used by:
   1329  7c45							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1330  7c45
   1331  7c45							; Two entries per character.  2nd is ptr to mirrored character
   1332  7c45							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
   1333  7c45
   1334  7c45		       25		      .byte.b	<CHARACTERSHAPE_BLANK
   1335  7c46		       25		      .byte.b	<CHARACTERSHAPE_BLANK
   1336  7c47		       b8		      .byte.b	<CHARACTERSHAPE_SOIL
   1337  7c48		       b8		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
   1338  7c49		       a7		      .byte.b	<CHARACTERSHAPE_BOX
   1339  7c4a		       bc		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
   1340  7c4b		       00		      .byte.b	<0
   1341  7c4c		       00		      .byte.b	<0
   1342  7c4d		       e6		      .byte.b	<CHARACTERSHAPE_DIAMOND
   1343  7c4e		       d1		      .byte.b	<CHARACTERSHAPE_DIAMOND_MIRRORED
   1344  7c4f		       e5		      .byte.b	<CHARACTERSHAPE_DIAMOND2
   1345  7c50		       d0		      .byte.b	<CHARACTERSHAPE_DIAMOND2_MIRRORED
   1346  7c51		       25		      .byte.b	<CHARACTERSHAPE_BLANK
   1347  7c52		       25		      .byte.b	<CHARACTERSHAPE_BLANK
   1348  7c53		       00		      .byte.b	<0
   1349  7c54		       00		      .byte.b	<0
   1350  7c55		       00		      .byte.b	<0
   1351  7c56		       00		      .byte.b	<0
   1352  7c57		       00		      .byte.b	<0
   1353  7c58		       00		      .byte.b	<0
   1354  7c59		       00		      .byte.b	<0
   1355  7c5a		       00		      .byte.b	<0
   1356  7c5b		       00		      .byte.b	<CHARACTERSHAPE_WALL0
   1357  7c5c		       15		      .byte.b	<CHARACTERSHAPE_WALL0_MIRRORED
   1358  7c5d		       e2		      .byte.b	<CHARACTERSHAPE_WALL1
   1359  7c5e		       e2		      .byte.b	<CHARACTERSHAPE_WALL1
   1360  7c5f		       00		      .byte.b	<CHARACTERSHAPE_WALL0
   1361  7c60		       00		      .byte.b	<CHARACTERSHAPE_WALL0
   1362  7c61		       cd		      .byte.b	<CHARACTERSHAPE_WALL2
   1363  7c62		       cd		      .byte.b	<CHARACTERSHAPE_WALL2
   1364  7c63		       00		      .byte.b	<CHARACTERSHAPE_STEEL
   1365  7c64		       15		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
   1366  7c65		       00		      .byte.b	<CHARACTERSHAPE_WALL
   1367  7c66		       15		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
   1368  7c67		       00		      .byte.b	<CHARACTERSHAPE_EXITDOOR
   1369  7c68		       15		      .byte.b	<CHARACTERSHAPE_EXITDOOR_MIRRORED
   1370  7c69		       25		      .byte.b	<CHARACTERSHAPE_EXITDOOR2
   1371  7c6a		       25		      .byte.b	<CHARACTERSHAPE_EXITDOOR2
   1372  7c6b
   1373  7c6b		       a7		      .byte.b	<CHARACTERSHAPE_EXPLOSION
   1374  7c6c		       a7		      .byte.b	<CHARACTERSHAPE_EXPLOSION_MIRRORED
   1375  7c6d		       92		      .byte.b	<CHARACTERSHAPE_EXPLOSION1
   1376  7c6e		       92		      .byte.b	<CHARACTERSHAPE_EXPLOSION1_MIRRORED
   1377  7c6f		       a7		      .byte.b	<CHARACTERSHAPE_EXPLOSION2
   1378  7c70		       a7		      .byte.b	<CHARACTERSHAPE_EXPLOSION2_MIRRORED
   1379  7c71		       bb		      .byte.b	<CHARACTERSHAPE_EXPLOSION3
   1380  7c72		       bb		      .byte.b	<CHARACTERSHAPE_EXPLOSION3_MIRRORED
   1381  7c73
   1382  7c73		       00		      .byte.b	<0
   1383  7c74		       00		      .byte.b	<0
   1384  7c75
   1385  7c75		       a7		      .byte.b	<CHARACTERSHAPE_BOX	; falling BOX
   1386  7c76		       bc		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED	; falling BOX
   1387  7c77		       e6		      .byte.b	<CHARACTERSHAPE_DIAMOND	; falling diamond
   1388  7c78		       d1		      .byte.b	<CHARACTERSHAPE_DIAMOND_MIRRORED	; falling diamond
   1389  7c79
   1390  7c79		       25		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
   1391  7c7a		       25		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
   1392  7c7b
   1393  7c7b				  -	      IF	* - CharacterDataVecLO < CHARACTER_MAXIMUM*2
   1394  7c7b				  -	      ECHO	"ERROR: Missing entry in CharacterDataVecLO table!"
   1395  7c7b				  -	      EXIT
   1396  7c7b					      ENDIF
   1397  7c7b
   1398  7c7b							;---------------------------------------------------------------------------
   1399  7c7b
   1400  7c7b				   CharacterDataVecHI
   1401  7c7b							; TJ: used by:
   1402  7c7b							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1403  7c7b
   1404  7c7b		       73		      .byte.b	( >CHARACTERSHAPE_BLANK ) & $7F
   1405  7c7c		       73		      .byte.b	( >CHARACTERSHAPE_BLANK ) & $7F
   1406  7c7d		       f3		      .byte.b	>CHARACTERSHAPE_SOIL
   1407  7c7e		       f3		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
   1408  7c7f		       fd		      .byte.b	>CHARACTERSHAPE_BOX
   1409  7c80		       fd		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
   1410  7c81		       00		      .byte.b	>0
   1411  7c82		       00		      .byte.b	>0
   1412  7c83		       f2		      .byte.b	>CHARACTERSHAPE_DIAMOND
   1413  7c84		       f2		      .byte.b	>CHARACTERSHAPE_DIAMOND_MIRRORED
   1414  7c85		       f2		      .byte.b	>CHARACTERSHAPE_DIAMOND2
   1415  7c86		       f2		      .byte.b	>CHARACTERSHAPE_DIAMOND2_MIRRORED
   1416  7c87		       73		      .byte.b	( >CHARACTERSHAPE_BLANK ) & $7F	;manoccupied
   1417  7c88		       73		      .byte.b	( >CHARACTERSHAPE_BLANK ) & $7F	;manoccupied
   1418  7c89		       00		      .byte.b	>0
   1419  7c8a		       00		      .byte.b	>0
   1420  7c8b		       00		      .byte.b	>0
   1421  7c8c		       00		      .byte.b	>0
   1422  7c8d		       00		      .byte.b	>0
   1423  7c8e		       00		      .byte.b	>0
   1424  7c8f		       00		      .byte.b	>0
   1425  7c90		       00		      .byte.b	>0
   1426  7c91		       f8		      .byte.b	>CHARACTERSHAPE_WALL0
   1427  7c92		       f8		      .byte.b	>CHARACTERSHAPE_WALL0_MIRRORED
   1428  7c93		       f3		      .byte.b	>CHARACTERSHAPE_WALL1
   1429  7c94		       f3		      .byte.b	>CHARACTERSHAPE_WALL1
   1430  7c95		       f8		      .byte.b	>CHARACTERSHAPE_WALL0
   1431  7c96		       f8		      .byte.b	>CHARACTERSHAPE_WALL0
   1432  7c97		       f3		      .byte.b	>CHARACTERSHAPE_WALL2
   1433  7c98		       f3		      .byte.b	>CHARACTERSHAPE_WALL2
   1434  7c99		       fe		      .byte.b	>CHARACTERSHAPE_STEEL
   1435  7c9a		       fe		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
   1436  7c9b		       f8		      .byte.b	>CHARACTERSHAPE_WALL
   1437  7c9c		       f8		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
   1438  7c9d		       fe		      .byte.b	>CHARACTERSHAPE_EXITDOOR
   1439  7c9e		       fe		      .byte.b	>CHARACTERSHAPE_EXITDOOR_MIRRORED
   1440  7c9f		       73		      .byte.b	( >CHARACTERSHAPE_EXITDOOR2 ) & $7F
   1441  7ca0		       73		      .byte.b	( >CHARACTERSHAPE_EXITDOOR2 ) & $7F
   1442  7ca1
   1443  7ca1		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION
   1444  7ca2		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION_MIRRORED
   1445  7ca3		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION1
   1446  7ca4		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION1_MIRRORED
   1447  7ca5		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION2
   1448  7ca6		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION2_MIRRORED
   1449  7ca7		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION3
   1450  7ca8		       f2		      .byte.b	>CHARACTERSHAPE_EXPLOSION3_MIRRORED
   1451  7ca9
   1452  7ca9		       00		      .byte.b	>0
   1453  7caa		       00		      .byte.b	>0
   1454  7cab
   1455  7cab		       fd		      .byte.b	>CHARACTERSHAPE_BOX	; falling BOX
   1456  7cac		       fd		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED	; falling BOX
   1457  7cad		       f2		      .byte.b	>CHARACTERSHAPE_DIAMOND	; falling diamond
   1458  7cae		       f2		      .byte.b	>CHARACTERSHAPE_DIAMOND_MIRRORED	; falling diamond
   1459  7caf
   1460  7caf		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
   1461  7cb0		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
   1462  7cb1
   1463  7cb1				  -	      IF	* - CharacterDataVecHI < CHARACTER_MAXIMUM*2
   1464  7cb1				  -	      ECHO	"ERROR: Missing entry in CharacterDataVecHI table!"
   1465  7cb1				  -	      EXIT
   1466  7cb1					      ENDIF
   1467  7cb1
   1468  7cb1							;---------------------------------------------------------------------------
   1469  7cb1
   1470  7cb1				   GenericCharFlag
   1471  7cb1							; TJ: used by:
   1472  7cb1							; - BANK_FIXED.asm
   1473  7cb1							; - BANK_INITBANK.asm
   1474  7cb1							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1475  7cb1
   1476  7cb1							; Tells us information about a particular character.  Multiple bits define characteristics
   1477  7cb1							; of how the character behaves during gameplay.
   1478  7cb1
   1479  7cb1		       0a		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_SQUASHABLE	; blank
   1480  7cb2		       08		      .byte.b	GENERIC_MASK_EXPLODABLE	; soil
   1481  7cb3		       89		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_ROUNDED|GENERIC_MASK_FALLABLE	; BOX
   1482  7cb4		       00		      .byte.b	0	; <unused>
   1483  7cb5		       89		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_ROUNDED|GENERIC_MASK_FALLABLE	; diamond
   1484  7cb6		       89		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_ROUNDED|GENERIC_MASK_FALLABLE	; diamond2
   1485  7cb7		       1a		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_SQUASHABLE|GENERIC_MASK_KILLSBUTTERFLY	; man
   1486  7cb8
   1487  7cb8							; Note: Butterflies and fireflies are not explodable, to prevent chain-reactions
   1488  7cb8
   1489  7cb8		       00		      .byte.b	0	; unused
   1490  7cb9		       00		      .byte.b	0	; unused
   1491  7cba		       00		      .byte.b	0	; unused
   1492  7cbb		       00		      .byte.b	0	; unused
   1493  7cbc		       22		      .byte.b	GENERIC_MASK_SQUASHABLE|GENERIC_MASK_MAGICWALL	; magic wall
   1494  7cbd		       22		      .byte.b	GENERIC_MASK_SQUASHABLE|GENERIC_MASK_MAGICWALL	; magic wall
   1495  7cbe		       22		      .byte.b	GENERIC_MASK_SQUASHABLE|GENERIC_MASK_MAGICWALL	; magic wall
   1496  7cbf		       22		      .byte.b	GENERIC_MASK_SQUASHABLE|GENERIC_MASK_MAGICWALL	; magic wall
   1497  7cc0		       00		      .byte.b	0	; steel wall
   1498  7cc1		       09		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_ROUNDED	; plain brick wall
   1499  7cc2		       00		      .byte.b	0	; exit
   1500  7cc3		       00		      .byte.b	0	; exit
   1501  7cc4		       00		      .byte.b	0	; explosion
   1502  7cc5		       00		      .byte.b	0	; explosion 1
   1503  7cc6		       00		      .byte.b	0	; explosion 2
   1504  7cc7		       00		      .byte.b	0	; explosion 3
   1505  7cc8		       00		      .byte.b	0
   1506  7cc9
   1507  7cc9		       09		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_ROUNDED	; falling BOX
   1508  7cca		       09		      .byte.b	GENERIC_MASK_EXPLODABLE|GENERIC_MASK_ROUNDED	; falling diamond
   1509  7ccb
   1510  7ccb		       00		      .byte.b	0	; unkillable man
   1511  7ccc
   1512  7ccc				  -	      IF	* - GenericCharFlag < CHARACTER_MAXIMUM
   1513  7ccc				  -	      ECHO	"ERROR: Missing entry in GenericCharFlag table!"
   1514  7ccc				  -	      EXIT
   1515  7ccc					      ENDIF
   1516  7ccc
   1517  7ccc							;---------------------------------------------------------------------------
   1518  7ccc
   1519  7ccc				   BaseTypeCharacter
   1520  7ccc							; TJ: used by:
   1521  7ccc							; - BANK_FIXED.asm
   1522  7ccc
   1523  7ccc							; Given an object type, gives a base character to use for that type
   1524  7ccc							; essentially the conversion BaseTypeCharacer[ TYPE ] --> character
   1525  7ccc
   1526  7ccc		       06		      .byte.b	CHARACTER_MANOCCUPIED
   1527  7ccd		       02		      .byte.b	CHARACTER_BOX
   1528  7cce		       00		      .byte.b	0
   1529  7ccf		       00		      .byte.b	0
   1530  7cd0		       00		      .byte.b	0
   1531  7cd1		       04		      .byte.b	CHARACTER_DIAMOND
   1532  7cd2		       0b		      .byte.b	CHARACTER_WALL0
   1533  7cd3		       11		      .byte.b	CHARACTER_EXITDOOR	; exit door
   1534  7cd4		       00		      .byte.b	CHARACTER_BLANK	; select
   1535  7cd5		       13		      .byte.b	CHARACTER_EXPLOSION
   1536  7cd6		       14		      .byte.b	CHARACTER_EXPLOSION1
   1537  7cd7		       15		      .byte.b	CHARACTER_EXPLOSION2
   1538  7cd8		       16		      .byte.b	CHARACTER_EXPLOSION3
   1539  7cd9		       00		      .byte.b	CHARACTER_BLANK
   1540  7cda		       01		      .byte.b	CHARACTER_SOIL
   1541  7cdb		       0f		      .byte.b	CHARACTER_STEEL
   1542  7cdc		       10		      .byte.b	CHARACTER_WALL
   1543  7cdd
   1544  7cdd							;--> if adding types, also see InitialFace in DecodeCave.asm
   1545  7cdd
   1546  7cdd				  -	      IF	* - BaseTypeCharacter < TYPE_MAXIMUM
   1547  7cdd				  -	      ECHO	"ERROR: Missing entry in BaseTypeCharacter table!"
   1548  7cdd				  -	      EXIT
   1549  7cdd					      ENDIF
   1550  7cdd
   1551  7cdd							;---------------------------------------------------------------------------
   1552  7cdd
   1553  7cdd				   BaseTypeCharacterFalling
   1554  7cdd							; TJ: used by:
   1555  7cdd							; - BANK_FIXED.asm
   1556  7cdd
   1557  7cdd							; Given an object type, gives a base character to use for that type
   1558  7cdd							; essentially the conversion BaseTypeCharacer[ TYPE ] --> character
   1559  7cdd
   1560  7cdd		       06		      .byte.b	CHARACTER_MANOCCUPIED
   1561  7cde		       18		      .byte.b	CHARACTER_BOX_FALLING
   1562  7cdf		       00		      .byte.b	0
   1563  7ce0		       00		      .byte.b	0
   1564  7ce1		       00		      .byte.b	0
   1565  7ce2		       19		      .byte.b	CHARACTER_DIAMOND_FALLING
   1566  7ce3		       0b		      .byte.b	CHARACTER_WALL0
   1567  7ce4		       11		      .byte.b	CHARACTER_EXITDOOR	; exit door
   1568  7ce5		       00		      .byte.b	CHARACTER_BLANK	; select
   1569  7ce6		       13		      .byte.b	CHARACTER_EXPLOSION
   1570  7ce7		       14		      .byte.b	CHARACTER_EXPLOSION1
   1571  7ce8		       15		      .byte.b	CHARACTER_EXPLOSION2
   1572  7ce9		       16		      .byte.b	CHARACTER_EXPLOSION3
   1573  7cea		       00		      .byte.b	CHARACTER_BLANK
   1574  7ceb		       01		      .byte.b	CHARACTER_SOIL
   1575  7cec		       0f		      .byte.b	CHARACTER_STEEL
   1576  7ced		       10		      .byte.b	CHARACTER_WALL
   1577  7cee
   1578  7cee							;--> if adding types, also see InitialFace in DecodeCave.asm
   1579  7cee
   1580  7cee				  -	      IF	* - BaseTypeCharacterFalling < TYPE_MAXIMUM
   1581  7cee				  -	      ECHO	"ERROR: Missing entry in BaseTypeCharacterFalling table!"
   1582  7cee				  -	      EXIT
   1583  7cee					      ENDIF
   1584  7cee
   1585  7cee							;---------------------------------------------------------------------------
   1586  7cee
      0  7cee					      DEFINE_SUBROUTINE	CharToType	; in FIXED_BANK
      1  7cee		       00 0f	   BANK_CharToType =	_CURRENT_BANK
      2  7cee					      SUBROUTINE
      3  7cee				   CharToType
   1588  7cee							; TJ: used by:
   1589  7cee							; - BANK_FIXED.asm
   1590  7cee							; - BANK_INITBANK.asm
   1591  7cee
   1592  7cee							; Converts a character # to a creature type
   1593  7cee							; add 128 if character is NOT to be added as a creature on board draw
   1594  7cee
   1595  7cee		       0d		      .byte.b	TYPE_BLANK	;  0	 blank
   1596  7cef		       0e		      .byte.b	TYPE_SOIL	;  1	 soil
   1597  7cf0		       01		      .byte.b	TYPE_BOX	;  2
   1598  7cf1		       00		      .byte.b	0	;  3
   1599  7cf2		       05		      .byte.b	TYPE_DIAMOND	;  4
   1600  7cf3		       05		      .byte.b	TYPE_DIAMOND	;  5
   1601  7cf4		       00		      .byte.b	TYPE_MAN	;  6
   1602  7cf5		       00		      .byte.b	0	;  7
   1603  7cf6		       00		      .byte.b	0	;  8
   1604  7cf7		       00		      .byte.b	0	;  9
   1605  7cf8		       00		      .byte.b	0	; 0a
   1606  7cf9		       06		      .byte.b	TYPE_MAGICWALL	; 0b
   1607  7cfa		       06		      .byte.b	TYPE_MAGICWALL	; 0c
   1608  7cfb		       06		      .byte.b	TYPE_MAGICWALL	; 0d
   1609  7cfc		       06		      .byte.b	TYPE_MAGICWALL	; 0e
   1610  7cfd		       0f		      .byte.b	TYPE_STEELWALL	; 0f	  ; steel wall
   1611  7cfe		       10		      .byte.b	TYPE_BRICKWALL	; 10	  ; plain brick wall
   1612  7cff		       07		      .byte.b	TYPE_EXITDOOR	; 11
   1613  7d00		       07		      .byte.b	TYPE_EXITDOOR	; 12
   1614  7d01		       09		      .byte.b	TYPE_EXPLOSION	; 13
   1615  7d02		       0a		      .byte.b	TYPE_EXPLOSION1	; 14
   1616  7d03		       0b		      .byte.b	TYPE_EXPLOSION2	; 15
   1617  7d04		       0c		      .byte.b	TYPE_EXPLOSION3	; 16
   1618  7d05		       00		      .byte.b	0	; 17
   1619  7d06
   1620  7d06		       01		      .byte.b	TYPE_BOX	; falling BOX
   1621  7d07		       05		      .byte.b	TYPE_DIAMOND	; falling diamond
   1622  7d08
   1623  7d08		       0d		      .byte.b	TYPE_BLANK	; 20 unkillable man
   1624  7d09							; --> see also MoveVec
   1625  7d09							; --> see also DecodeCave's table
   1626  7d09
   1627  7d09				  -	      IF	* - CharToType < CHARACTER_MAXIMUM
   1628  7d09				  -	      ECHO	"ERROR: Missing entry in CharToType table!"
   1629  7d09				  -	      EXIT
   1630  7d09					      ENDIF
   1631  7d09
   1632  7d09							;---------------------------------------------------------------------------
   1633  7d09
      0  7d09					      DEFINE_SUBROUTINE	AnimateCharReplacements2	;139
      1  7d09		       00 0f	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  7d09					      SUBROUTINE
      3  7d09				   AnimateCharReplacements2
   1635  7d09							; TJ: used by:
   1636  7d09							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1637  7d09
   1638  7d09							; This manages character animation on a per-object basis.  Morph/animate these
   1639  7d09							; characters individually or as required.  Change will affect all characters
   1640  7d09							; of the same type in the visible display.
   1641  7d09
   1642  7d09							; -------------------------------------------
   1643  7d09							; The door will animate when it is 'open'. It's open when the required number of diamonds have been
   1644  7d09							; collected. This in turn triggers the "extra diamonds" flag for scoring, so that is used to determine
   1645  7d09							; when the door should flash.
   1646  7d09
   1647  7d09		       24 c8		      bit	scoringFlags	;3
   1648  7d0b		       10 08		      bpl	NoDoor	;2/3		 extra diamonds (D7) set when door animates
   1649  7d0d
   1650  7d0d		       ad e5 f2 	      lda	ANIM_EXITDOOR	;4
   1651  7d10		       49 03		      eor	#CHARACTER_EXITDOOR2^CHARACTER_EXITDOOR	;2
   1652  7d12		       8d e5 f6 	      sta	ANIM_EXITDOOR + RAM_WRITE	;4 = 22	 exit door
   1653  7d15				   NoDoor
   1654  7d15
   1655  7d15							; -------------------------------------------
   1656  7d15
   1657  7d15							; handle the non-mandatory animating things
   1658  7d15
   1659  7d15		       a5 ae		      lda	timer	;3
   1660  7d17		       29 03		      and	#%11	;2
   1661  7d19		       d0 0c		      bne	nothingAnimates	;2/3
   1662  7d1b
   1663  7d1b		       a5 9c		      lda	scrollBits	;3
   1664  7d1d		       d0 08		      bne	nothingAnimates	;2/3		 DON'T animate if we scrolled
   1665  7d1f
   1666  7d1f		       ad d8 f2 	      lda	ANIM_DIAMOND	;4
   1667  7d22		       49 01		      eor	#CHARACTER_DIAMOND^CHARACTER_DIAMOND2	;2
   1668  7d24		       8d d8 f6 	      sta	ANIM_DIAMOND + RAM_WRITE	;4 = 15	 diamond
   1669  7d27
   1670  7d27		       4c 28 f2    nothingAnimates jmp	retAnim	;3
   1671  7d2a
   1672  7d2a							;---------------------------------------------------------------------------
   1673  7d2a
      0  7d2a					      DEFINE_SUBROUTINE	ScoreAdd
      1  7d2a		       00 0f	   BANK_ScoreAdd =	_CURRENT_BANK
      2  7d2a					      SUBROUTINE
      3  7d2a				   ScoreAdd
   1675  7d2a							; TJ: used by:
   1676  7d2a							; - BANK_INITBANK.asm
   1677  7d2a		       a2 09		      ldx	#BANK_SCORING
   1678  7d2c		       86 3e		      stx	SET_BANK_RAM
   1679  7d2e		       20 0f f2 	      jsr	UpdateScore
   1680  7d31		       a5 c3	   rbret      lda	ROM_Bank
   1681  7d33		       85 3f		      sta	SET_BANK
   1682  7d35		       60		      rts
   1683  7d36
   1684  7d36							;---------------------------------------------------------------------------
   1685  7d36
      0  7d36					      DEFINE_SUBROUTINE	nextLevelMan
      1  7d36		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7d36					      SUBROUTINE
      3  7d36				   nextLevelMan
   1687  7d36							; TJ: used by:
   1688  7d36							; - BANK_INITBANK.asm
   1689  7d36		       a9 02		      lda	#BANK_NextCave
   1690  7d38		       85 3f		      sta	SET_BANK
   1691  7d3a		       4c b3 f4 	      jmp	NextCave
   1692  7d3d
   1693  7d3d							;---------------------------------------------------------------------------
   1694  7d3d
      0  7d3d					      DEFINE_SUBROUTINE	SortObjects2	;=128(A), minimum 15 @ segtime exit
      1  7d3d		       00 0f	   BANK_SortObjects2 =	_CURRENT_BANK
      2  7d3d					      SUBROUTINE
      3  7d3d				   SortObjects2
   1696  7d3d							; TJ: used by:
   1697  7d3d							; - BANK_FIXED.asm
   1698  7d3d
   1699  7d3d		       ad 84 02 	      lda	INTIM	;4
   1700  7d40		       c9 03		      cmp	#MINIMUM_SORT_TIME	;2
   1701  7d42		       90 4d		      bcc	.sortExit	;2(3)=8	insufficient time
      0  7d44					      STRESS_TIME	MINIMUM_SORT_TIME
      1  7d44				  -	      IF	TEST_MINIMUM_SORT_TIME = 1
      2  7d44				  -
      3  7d44				  -
      4  7d44				  -
      5  7d44				  -
      6  7d44				  -
      7  7d44				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7d44				  -	      bne	. - 7
      9  7d44					      ENDIF
   1703  7d44
   1704  7d44		       a6 8a		      ldx	ObjStackNum	;3
   1705  7d46		       bd 51 fa 	      lda	BankObjStack,x	;4
   1706  7d49		       85 3e		      sta	SET_BANK_RAM	;3
   1707  7d4b		       4c 89 fd 	      jmp	.enterSort	;3 = 13
   1708  7d4e
   1709  7d4e				   restartSort		;  = 11
   1710  7d4e
   1711  7d4e							; So there's another sort 'starting' and we reset the ptr to the end of the obj list
   1712  7d4e
   1713  7d4e							; retrieve size of list to sort
   1714  7d4e		       a9 ff		      lda	#<(-1)	;2
   1715  7d50		       85 d3		      sta	sortRequired	;3		 flag that we're DOING it
   1716  7d52
   1717  7d52		       a6 8a		      ldx	ObjStackNum	;3
   1718  7d54		       b4 8b		      ldy	ObjStackPtr,x	;4		 index of 1st free slot = # slots in use
   1719  7d56		       88		      dey		;2
   1720  7d57		       84 d4		      sty	sortPtr	;3		 earlier potential swappable object
   1721  7d59		       f0 36		      beq	.sortExit	;2/3
   1722  7d5b
   1723  7d5b				   midSort		;  =  6
   1724  7d5b
   1725  7d5b		       b9 80 11 	      lda	SortedObjPtr,y	;4		 y = sortPtr!
   1726  7d5e		       be 7f 11 	      ldx	SortedObjPtr-1,y	;4		 the 'current' object looking to be sorted correctly
   1727  7d61		       a8		      tay		;2
   1728  7d62
   1729  7d62		       bd 80 10 	      lda	ObjStackY,x	;4
   1730  7d65		       d9 80 10 	      cmp	ObjStackY,y	;4
   1731  7d68		       90 16		      bcc	earlierObject	;2(3)
   1732  7d6a		       d0 08		      bne	swapAround	;2(3)
   1733  7d6c
   1734  7d6c		       b9 00 10 	      lda	ObjStackX,y	;4
   1735  7d6f		       dd 00 10 	      cmp	ObjStackX,x	;4
   1736  7d72		       b0 0c		      bcs	earlierObject	;2(3)		 WE DO NOT WANT TO SWAP IF == OTHERWISE LOCKUP
   1737  7d74
   1738  7d74				   swapAround		;   = 32 max.
   1739  7d74		       98		      tya		;2		 y = SortedObjPtr[sortPtr]
   1740  7d75		       a4 d4		      ldy	sortPtr	;3
   1741  7d77		       99 7f 15 	      sta	SortedObjPtr+RAM_WRITE-1,y	;5
   1742  7d7a		       8a		      txa		;2		 x = SortedObjPtr[sortPtr-1]
   1743  7d7b		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	;5
   1744  7d7e		       84 d3		      sty	sortRequired	;3 = 20	 as we've done a swap, ensure another pass (ANY non-neg value)
   1745  7d80
   1746  7d80		       c6 d4	   earlierObject dec	sortPtr	;5 =  5	 look at earlier object
   1747  7d82
   1748  7d82		       ad 84 02 	      lda	INTIM	;4
   1749  7d85		       c9 03		      cmp	#MINIMUM_SORT_TIME	;2
   1750  7d87		       90 08		      bcc	.sortExit	;2(3)=8	insufficient time
      0  7d89					      STRESS_TIME	MINIMUM_SORT_TIME
      1  7d89				  -	      IF	TEST_MINIMUM_SORT_TIME = 1
      2  7d89				  -
      3  7d89				  -
      4  7d89				  -
      5  7d89				  -
      6  7d89				  -
      7  7d89				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7d89				  -	      bne	. - 7
      9  7d89					      ENDIF
   1752  7d89							; loop max: 71 cycles, + 15 for exit + overhead outside
   1753  7d89							; -> MINIMUM_SORT_TIME = ceiling(86/64)+1 = 3
   1754  7d89							; TJ: I do not count the 1st INTIM, that's why I have 4 cylces less.
   1755  7d89				   .enterSort
   1756  7d89		       a4 d4		      ldy	sortPtr	;3		 sort 'stops' when potential swappable objects run out
   1757  7d8b		       d0 ce		      bne	midSort	;2(3)=5
   1758  7d8d		       a5 d3		      lda	sortRequired	;3		 AND there were no more sort requests
   1759  7d8f		       10 bd		      bpl	restartSort	;2(3)=5
   1760  7d91
   1761  7d91		       60	   .sortExit  rts		;6		 completed sort! (or time exit)
   1762  7d92
   1763  7d92
   1764  7d92							;---------------------------------------------------------------------------
   1765  7d92
      0  7d92					      DEFINE_SUBROUTINE	goGeneralScoringSetups
      1  7d92		       00 0f	   BANK_goGeneralScoringSetups =	_CURRENT_BANK
      2  7d92					      SUBROUTINE
      3  7d92				   goGeneralScoringSetups
   1767  7d92							; TJ: used by:
   1768  7d92							; - BANK_INITBANK.asm
   1769  7d92		       a9 09		      lda	#BANK_SCORING
   1770  7d94		       85 3e		      sta	SET_BANK_RAM
   1771  7d96		       20 ae f2 	      jsr	GeneralScoringSetups
   1772  7d99		       a5 c3		      lda	ROM_Bank
   1773  7d9b		       85 3f		      sta	SET_BANK
   1774  7d9d		       60		      rts
   1775  7d9e
   1776  7d9e
   1777  7d9e							;---------------------------------------------------------------------------
   1778  7d9e
      0  7d9e					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7d9e		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7d9e					      SUBROUTINE
      3  7d9e				   CopyROM2RAM_F000
   1780  7d9e							; TJ: used by:
   1781  7d9e							; - BANK_FIXED.asm
   1782  7d9e
   1783  7d9e		       a9 07		      lda	#BANK_CopyROMShadowToRAM
   1784  7da0		       85 3f		      sta	SET_BANK
   1785  7da2		       85 c3		      sta	ROM_Bank
   1786  7da4		       4c 43 f0 	      jmp	CopyROMShadowToRAM_F000
   1787  7da7
   1788  7da7
   1789  7da7							;---------------------------------------------------------------------------
   1790  7da7							; TJ: used by:
   1791  7da7							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
------- FILE BOX.asm LEVEL 3 PASS 3
      0  7da7					      include	"BOX.asm"	; 2 * LINES_PER_CHAR bytes
      0  7da7					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  7da7					      LIST	ON
      2  7da7				   CHARACTERSHAPE_BOX
      3  7da7				  -	      if	MIRRORED_BOX = NO
      4  7da7				  -CHARACTERSHAPE_BOX_MIRRORED
      5  7da7					      endif
      6  7da7		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
      7  7dae		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
      8  7db5		       00 00 66 66*	      .byte.b	%0,%0,%01100110,%01100110,%0,%0,%0	;B
      9  7dbc
     10  7dbc							;--------------------------------------------------------------------------
     11  7dbc					      if	MIRRORED_BOX = YES
      0  7dbc					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
     10  7dbc					      LIST	ON
     13  7dbc				   CHARACTERSHAPE_BOX_MIRRORED
     14  7dbc		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
     15  7dc3		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     16  7dca		       00 00 66 66*	      .byte.b	%0,%0,%01100110,%01100110,%0,%0,%0	;B
     17  7dd1					      endif
------- FILE BANK_FIXED.asm
------- FILE Butterfly.asm LEVEL 3 PASS 3
      0  7dd1					      include	"Butterfly.asm"	; 2 * LINES_PER_CHAR bytes
      1  7dd1		       00 02	   BUTTERFLY_DEF =	2
      2  7dd1
      3  7dd1				  -	      if	BUTTERFLY_DEF = 0
      4  7dd1				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FLUTTERBY", LINES_PER_CHAR
      5  7dd1				  -CHARACTERSHAPE_FLUTTERBY
      6  7dd1				  -
      7  7dd1				  -			; an x shape
      8  7dd1				  -
      9  7dd1				  -	      .byte	%00000000	;R
     10  7dd1				  -	      .byte	%10011001
     11  7dd1				  -	      .byte	%11111111
     12  7dd1				  -	      .byte	%01100110
     13  7dd1				  -	      .byte	%10011001
     14  7dd1				  -	      .byte	%00000000
     15  7dd1				  -	      .byte	0
     16  7dd1				  -
     17  7dd1				  -	      .byte	%10011001	;G
     18  7dd1				  -	      .byte	%10011001
     19  7dd1				  -	      .byte	%11111111
     20  7dd1				  -	      .byte	%11111111
     21  7dd1				  -	      .byte	%10011001
     22  7dd1				  -	      .byte	%10011001
     23  7dd1				  -	      .byte	0
     24  7dd1				  -
     25  7dd1				  -	      .byte	%00000000	;B
     26  7dd1				  -	      .byte	%10011001
     27  7dd1				  -	      .byte	%01100110
     28  7dd1				  -	      .byte	%11111111
     29  7dd1				  -	      .byte	%10011001
     30  7dd1				  -	      .byte	%00000000
     31  7dd1				  -	      .byte	0
     32  7dd1				  -
     33  7dd1				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FLUTTERBY2", LINES_PER_CHAR
     34  7dd1				  -CHARACTERSHAPE_FLUTTERBY2
     35  7dd1				  -
     36  7dd1				  -			; an x shape (flutter)
     37  7dd1				  -
     38  7dd1				  -	      .byte	%00000000	;R
     39  7dd1				  -	      .byte	%01100110
     40  7dd1				  -	      .byte	%01100110
     41  7dd1				  -	      .byte	%01100110
     42  7dd1				  -	      .byte	%01100110
     43  7dd1				  -	      .byte	%01100110
     44  7dd1				  -	      .byte	0
     45  7dd1				  -
     46  7dd1				  -	      .byte	%01100110	;G
     47  7dd1				  -	      .byte	%01100110
     48  7dd1				  -	      .byte	%01100110
     49  7dd1				  -	      .byte	%01100110
     50  7dd1				  -	      .byte	%01100110
     51  7dd1				  -	      .byte	%01100110
     52  7dd1				  -	      .byte	0
     53  7dd1				  -
     54  7dd1				  -	      .byte	%01100110	;B
     55  7dd1				  -	      .byte	%01100110
     56  7dd1				  -	      .byte	%01100110
     57  7dd1				  -	      .byte	%01100110
     58  7dd1				  -	      .byte	%01100110
     59  7dd1				  -	      .byte	%00000000
     60  7dd1				  -	      .byte	0
     61  7dd1					      endif
     62  7dd1
     63  7dd1				  -	      if	BUTTERFLY_DEF = 1
     64  7dd1				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FLUTTERBY", LINES_PER_CHAR
     65  7dd1				  -CHARACTERSHAPE_FLUTTERBY
     66  7dd1				  -
     67  7dd1				  -			; an x shape
     68  7dd1				  -
     69  7dd1				  -	      .byte	%10011001	;R (#3 bright color)
     70  7dd1				  -	      .byte	%11011101
     71  7dd1				  -	      .byte	%11111111
     72  7dd1				  -	      .byte	%01100110
     73  7dd1				  -	      .byte	%11111111
     74  7dd1				  -	      .byte	%10111011
     75  7dd1				  -	      .byte	%10011001
     76  7dd1				  -
     77  7dd1				  -	      .byte	%00000000	;G (#2 dirt color)
     78  7dd1				  -	      .byte	%10001000
     79  7dd1				  -	      .byte	%11111111
     80  7dd1				  -	      .byte	%01100110
     81  7dd1				  -	      .byte	%01000100
     82  7dd1				  -	      .byte	%10101010
     83  7dd1				  -	      .byte	%10011001
     84  7dd1				  -
     85  7dd1				  -	      .byte	%10011001	;B (#1 wall color)
     86  7dd1				  -	      .byte	%11011101
     87  7dd1				  -	      .byte	%11111111
     88  7dd1				  -	      .byte	%01100110
     89  7dd1				  -	      .byte	%11111111
     90  7dd1				  -	      .byte	%10111011
     91  7dd1				  -	      .byte	%10011001
     92  7dd1				  -
     93  7dd1				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FLUTTERBY2", LINES_PER_CHAR
     94  7dd1				  -CHARACTERSHAPE_FLUTTERBY2
     95  7dd1				  -
     96  7dd1				  -			; an x shape (flutter)
     97  7dd1				  -
     98  7dd1				  -	      .byte	%00000000	;R
     99  7dd1				  -	      .byte	%00000000
    100  7dd1				  -	      .byte	%00000000
    101  7dd1				  -	      .byte	%00000000
    102  7dd1				  -	      .byte	%00000000
    103  7dd1				  -	      .byte	%00000000
    104  7dd1				  -	      .byte	%00100010
    105  7dd1				  -
    106  7dd1				  -	      .byte	%01100110	;G
    107  7dd1				  -	      .byte	%01100110
    108  7dd1				  -	      .byte	%01000100
    109  7dd1				  -	      .byte	%00100010
    110  7dd1				  -	      .byte	%01100110
    111  7dd1				  -	      .byte	%01100110
    112  7dd1				  -	      .byte	%01000100
    113  7dd1				  -
    114  7dd1				  -	      .byte	%01100110	;B
    115  7dd1				  -	      .byte	%01100110
    116  7dd1				  -	      .byte	%01100110
    117  7dd1				  -	      .byte	%01000100
    118  7dd1				  -	      .byte	%00100010
    119  7dd1				  -	      .byte	%01100110
    120  7dd1				  -	      .byte	%01100110
    121  7dd1					      endif
    122  7dd1
    123  7dd1					      if	BUTTERFLY_DEF = 2
      0  7dd1					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FLUTTERBY", LINES_PER_CHAR
     10  7dd1					      LIST	ON
    125  7dd1				   CHARACTERSHAPE_FLUTTERBY
    126  7dd1
    127  7dd1		       99		      .byte.b	%10011001	;R (#3 bright color)
    128  7dd2		       99		      .byte.b	%10011001
    129  7dd3		       99		      .byte.b	%10011001
    130  7dd4		       00		      .byte.b	%00000000
    131  7dd5		       99		      .byte.b	%10011001
    132  7dd6		       99		      .byte.b	%10011001
    133  7dd7		       99		      .byte.b	%10011001
    134  7dd8
    135  7dd8		       99		      .byte.b	%10011001	;G (#2 dirt color)
    136  7dd9		       ff		      .byte.b	%11111111
    137  7dda		       ff		      .byte.b	%11111111
    138  7ddb		       66		      .byte.b	%01100110
    139  7ddc		       66		      .byte.b	%01100110
    140  7ddd		       00		      .byte.b	%00000000
    141  7dde		       00		      .byte.b	%00000000
    142  7ddf
    143  7ddf		       00		      .byte.b	%00000000	;B (#1 wall color)
    144  7de0		       66		      .byte.b	%01100110
    145  7de1		       66		      .byte.b	%01100110
    146  7de2		       66		      .byte.b	%01100110
    147  7de3		       ff		      .byte.b	%11111111
    148  7de4		       99		      .byte.b	%10011001
    149  7de5		       99		      .byte.b	%10011001
    150  7de6
      0  7de6					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_FLUTTERBY2", LINES_PER_CHAR
     10  7de6					      LIST	ON
    152  7de6				   CHARACTERSHAPE_FLUTTERBY2
    153  7de6
    154  7de6		       66		      .byte.b	%01100110	;R
    155  7de7		       66		      .byte.b	%01100110
    156  7de8		       66		      .byte.b	%01100110
    157  7de9		       00		      .byte.b	%00000000
    158  7dea		       66		      .byte.b	%01100110
    159  7deb		       66		      .byte.b	%01100110
    160  7dec		       66		      .byte.b	%01100110
    161  7ded
    162  7ded		       66		      .byte.b	%01100110	;G
    163  7dee		       66		      .byte.b	%01100110
    164  7def		       66		      .byte.b	%01100110
    165  7df0		       66		      .byte.b	%01100110
    166  7df1		       66		      .byte.b	%01100110
    167  7df2		       00		      .byte.b	%00000000
    168  7df3		       00		      .byte.b	%00000000
    169  7df4
    170  7df4		       00		      .byte.b	%00000000	;B
    171  7df5		       66		      .byte.b	%01100110
    172  7df6		       66		      .byte.b	%01100110
    173  7df7		       66		      .byte.b	%01100110
    174  7df8		       66		      .byte.b	%01100110
    175  7df9		       66		      .byte.b	%01100110
    176  7dfa		       66		      .byte.b	%01100110
    177  7dfb					      endif
------- FILE BANK_FIXED.asm
------- FILE Steel_Wall.asm LEVEL 3 PASS 3
      0  7dfb					      include	"Steel_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      1  7dfb							;--------------------------------------------------------------------------
      0  7dfb					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_STEEL
 REQUESTED SIZE =  $15
 WASTED SPACE =  $5
 PAGEBREAK LOCATION =  $fe00
     10  7e00					      LIST	ON
      3  7e00				   CHARACTERSHAPE_STEEL
      4  7e00				   CHARACTERSHAPE_EXITDOOR
      5  7e00				  -	      if	MIRRORED_STEEL = NO
      6  7e00				  -CHARACTERSHAPE_STEEL_MIRRORED
      7  7e00				  -CHARACTERSHAPE_EXITDOOR_MIRRORED
      8  7e00					      endif
      9  7e00		       00 11 00 00*	      .byte.b	%00000000,%00010001,%00000000,%00000000,%01000100,%00000000,%00000000	;R
     10  7e07		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;G
     11  7e0e		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;B
     12  7e15
     13  7e15							;--------------------------------------------------------------------------
     14  7e15					      if	MIRRORED_STEEL = YES
      0  7e15					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
     10  7e15					      LIST	ON
     16  7e15				   CHARACTERSHAPE_STEEL_MIRRORED
     17  7e15				   CHARACTERSHAPE_EXITDOOR_MIRRORED
     18  7e15		       00 88 00 00*	      .byte.b	%00000000,%10001000,%00000000,%00000000,%00100010,%00000000,%00000000	;R
     19  7e1c		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;G
     20  7e23		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;B
     21  7e2a					      endif
------- FILE BANK_FIXED.asm
   1795  7e2a							;---------------------------------------------------------------------------
   1796  7e2a
   1797  7e2a
 FREE BYTES IN FIXED BANK =  $1d1
   1798  7e2a					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1799  7e2a
   1800  7e2a							;---------------------------------------------------------------------------
   1801  7e2a							; The reset vectors
   1802  7e2a							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1803  7e2a
   1804  8000 ????				      SEG	InterruptVectors
   1805  7ffc					      ORG	FIXED_BANK + $7FC
   1806  7ffc					      RORG	$7ffC
   1807  7ffc
   1808  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1809  7ffc		       66 fb		      .word.w	Reset	; RESET
   1810  7ffe		       66 fb		      .word.w	Reset	; IRQ	      (not used)
   1811  8000
   1812  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
   1087  8000
   1088  8000					      END
