------- FILE ./sokoboo.asm LEVEL 1 PASS 3
      1  8000 ????						;    Sokoboo - a Sokoban implementation
      2  8000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  8000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  8000 ????						;
      5  8000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  8000 ????						;
      7  8000 ????						;    Code related to the generic tile-based display engine was developed by
      8  8000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  8000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  8000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  8000 ????						;
     12  8000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  8000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  8000 ????						;    directory for Apache licensing details.
     15  8000 ????						;
     16  8000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  8000 ????						;    See the copyright notices in the License directory for a list of level
     18  8000 ????						;    contributors.
     19  8000 ????						;
     20  8000 ????						;    Except where otherwise indicated, this software is released under the
     21  8000 ????						;    following licensing arrangement...
     22  8000 ????						;
     23  8000 ????						;    This program is free software: you can redistribute it and/or modify
     24  8000 ????						;    it under the terms of the GNU General Public License as published by
     25  8000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  8000 ????						;    (at your option) any later version.
     27  8000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  8000 ????
     29  8000 ????						;    This program is distributed in the hope that it will be useful,
     30  8000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  8000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  8000 ????						;    GNU General Public License for more details.
     33  8000 ????
     34  8000 ????
     35  8000 ????
     36  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     37  8000 ????
     38  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./sokoboo.asm
     41  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	xsegtime
     89  0000 ????			   {1}	      SET	{2}-1
     90  0000 ????			   TEST_{1}   =	1
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????						;@TJ -- SIMPLY PUT AN X IN FRONT OF THE LINE(S) YOU WANT TO TEST
     94  0000 ????						; eg: XSEGTIME SEGTIME_BOX1,5
     95  0000 ????						; No other action required.  All code enables/disables automatically.
     96  0000 ????
     97  0000 ????						; 2012/02/11 -- experimental reduction in times (but not stress tested)
     98  0000 ????						; due to separation of timeslice overhead to separate check
     99  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_SCD_DIRECT,8	; TODO: 392@12/2/2012
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	8
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_QUICK,9	; TODO: 414@12/2/2012
      1  0000 ????			   SEGTIME_SCD_QUICK SET	9
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_SLOW,12	; TODO: cycles: ~635 @12/2/2012.
      1  0000 ????			   SEGTIME_SCD_SLOW SET	12
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_PF0,5	; TODO: cycle counted ~126 @12/2/2012
      1  0000 ????			   SEGTIME_SCD_PF0 SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_MIN,SEGTIME_SCD_PF0	; * MINIMUM TIME OF THE ABOVE + 1
      1  0000 ????			   SEGTIME_SCD_MIN SET	SEGTIME_SCD_PF0
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_MIN =	0
    105  0000 ????
    106  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
    107  0000 ????			  -	      SEGTIME	SEGTIME_BDF,42	; * 5/8/11 stress tested DHS->DS
    108  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BDF,41	; * 7/8/11
      1  0000 ????			   SEGTIME_BDF SET	41
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
    110  0000 ????				      ENDIF
    111  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BDS,5	; *AD 11/8/11
      1  0000 ????			   SEGTIME_BDS SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME	SEGTIME_DSL,5	; * 9/8/11 unrolled once
      1  0000 ????			   SEGTIME_DSL SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
    114  0000 ????
    115  0000 ????
    116  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SORT_TIME,3	;     157(A)->2.45
      1  0000 ????			   MINIMUM_SORT_TIME SET	3
      2  0000 ????	       00 00	   TEST_MINIMUM_SORT_TIME =	0
    118  0000 ????
    119  0000 ????
    120  0000 ????						;following will lock-up system if used as 'XSEGTIME'.
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIME,4	; processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	4
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
    122  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIMEBLANK,16	;17		 ; * 7/8/11	 993(A)->15.5
      1  0000 ????			   MINIMUM_SEGTIMEBLANK SET	16
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIMEBLANK =	0
    124  0000 ????
    125  0000 ????						; MINIMUM_SEGTIME
    126  0000 ????						; MINIMUM_SEGTIMEBLANK
    127  0000 ????						; SEGTIME_BDF
    128  0000 ????						; SEGTIME_BDS
    129  0000 ????						; SEGTIME_DSL
    130  0000 ????						; SEGTIME_SWITCHOBJECTS
    131  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MINIMUM_TIMESLICE,MINIMUM_SEGTIME+1	; MINIMUM of the TIMESLICE segments listed above
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	MINIMUM_SEGTIME+1
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    133  0000 ????
    134  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    135  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    136  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    137  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    138  0000 ????						; uses ...
    139  0000 ????
    140  0000 ????
    141  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    142  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    143  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    144  0000 ????
    145  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    146  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    147  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,24	;<< using this as XSEGTIME stops player working ...?!
      1  0000 ????			   SEGTIME_MAN SET	24
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE, 10	; drawing circle creature
      1  0000 ????			   SEGTIME_CIRCLE SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE_HELPER, 10	; drawing circle creature's helper
      1  0000 ????			   SEGTIME_CIRCLE_HELPER SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE_HELPER =	0
    151  0000 ????
    152  0000 ????						; TJ: I should only prevent processes with an extra check (e.g. get TARGET)
    153  0000 ????
    154  0000 ????						; push BOX is slowest (besides get TARGET which has an extra timer check)
    155  0000 ????						; if we add another check for it, SEGTIME_MAN reduces by ~5
    156  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_GET_TARGET,17	; * 14/8/11, required if UpdateScore loops (e.g. 9990->10000)
      1  0000 ????			   SEGTIME_GET_TARGET SET	17
      2  0000 ????	       00 00	   TEST_SEGTIME_GET_TARGET =	0
      0  0000 ????				      SEGTIME	SEGTIME_SWITCHOBJECTS,3	; 16/8/11 by calculation. 72 cycles -->  ceil(72/64)+1 --> 3 Object stack switchover
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	3
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
------- FILE ./sokoboo.asm
     43  0000 ????
     44  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     45  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     46  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     47  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     48  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     49  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     50  0000 ????
     51  0000 ????	       00 01	   YES	      =	1
     52  0000 ????	       00 00	   NO	      =	0
     53  0000 ????
     54  0000 ????	       00 00	   DEBUG      =	NO
     55  0000 ????
     56  0000 ????	       00 00	   TJ_MODE    =	NO	; some changes which TJ prefers
     57  0000 ????	       00 01	   AD_MODE    =	YES	; some changes which AD prefers
     58  0000 ????
     59  0000 ????			  -	      IF	TJ_MODE && AD_MODE
     60  0000 ????			  -	      ECHO	"ERROR: Both TJ_MODE and AD_MODE set. Can't do both TJ and AD at the same time!"
     61  0000 ????			  -	      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????
     65  0000 ????						; Note: you may also need to change the emulator "-format" switch in the Makefile.
     66  0000 ????
     67  0000 ????			   NTSC_MODE  SET	NO
     68  0000 ????
     69  0000 ????			  -	      IF	TJ_MODE
     70  0000 ????			  -NTSC_MODE  SET	NO	; force NTSC or PAL for difficulty switch
     71  0000 ????				      ENDIF
     72  0000 ????				      IF	AD_MODE
     73  0000 ????			   NTSC_MODE  SET	NO
     74  0000 ????				      ENDIF
     75  0000 ????
     76  0000 ????
     77  0000 ????
     78  0000 ????						;===================================
     79  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     80  0000 ????						;===================================
     81  0000 ????
     82  0000 ????						;-------------------------------------------------------------------------------
     83  0000 ????						; The following should be YES for the final or DEMO version
     84  0000 ????			   EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
     85  0000 ????
     86  0000 ????						;-------------------------------------------------------------------------------
     87  0000 ????						; The following are optional YES/NO depending on phase of the moon
     88  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     89  0000 ????						;-------------------------------------------------------------------------------
     90  0000 ????
     91  0000 ????	       00 01	   NUMPLAYERS =	1	; 1-indexed
     92  0000 ????	       00 05	   NUM_LEVELS =	5
     93  0000 ????			   NUM_LIVES  SET	3	; use -1 for unlimited lives
     94  0000 ????
     95  0000 ????			   DEMO_DELAY SET	1	; number of music loops without joystick input before demo kicks in
     96  0000 ????
     97  0000 ????						;-------------------------------------------------------------------------------
     98  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     99  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
    100  0000 ????			  -	      IF	FINAL_VERSION = YES
    101  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
    102  0000 ????			  -SHOWTARGETP SET	NO	; debug show TARGET on P
    103  0000 ????			  -
    104  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
    105  0000 ????			  -DEMO_DELAY SET	2	; number of music loops without joystick input before demo kicks in
    106  0000 ????			  -NTSC_MODE  SET	YES	; mmh
    107  0000 ????				      ENDIF
    108  0000 ????
    109  0000 ????						;-------------------------------------------------------------------------------
    110  0000 ????
    111  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
    112  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
    113  0000 ????
    114  0000 ????
    115  0000 ????	       00 01	   PUSH_LIMIT =	1	; slowdown when pushing on a BOX
    116  0000 ????
    117  0000 ????						; time bonus countdown constants:
    118  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
    119  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
    120  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
    121  0000 ????
    122  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    123  0000 ????
    124  0000 ????	       00 03	   FACE_LEFT  =	3
    125  0000 ????
    126  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
    127  0000 ????
    128  0000 ????						;scoring flags contants:
    129  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
    130  0000 ????	       00 00	   DISPLAY_TIME =	%00
    131  0000 ????	       00 01	   DISPLAY_SCORE =	%01
    132  0000 ????	       00 02	   DISPLAY_LIVES =	%10
    133  0000 ????	       00 03	   DISPLAY_HIGH =	%11
    134  0000 ????
    135  0000 ????						;------------------------------------------------------------------------------
    136  0000 ????
    137  0000 ????	       00 01	   MIRRORED_BOX =	YES
    138  0000 ????	       00 01	   MIRRORED_STEEL =	YES
    139  0000 ????	       00 01	   MIRRORED_WALL =	YES
    140  0000 ????
    141  0000 ????						;------------------------------------------------------------------------------
    142  0000 ????
    143  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    144  0000 ????
    145  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    146  0000 ????	       00 15	   LINES_PER_CHAR =	21	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    147  0000 ????
    148  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    149  0000 ????
    150  0000 ????
    151  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    152  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    153  0000 ????
    154  0000 ????
    155  0000 ????						; color constants:
    156  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    157  0000 ????
    158  0000 ????	       00 10	   YELLOW_NTSC =	$10
    159  0000 ????	       00 20	   YELLOW_PAL =	$20
    160  0000 ????
    161  0000 ????
    162  0000 ????	       10 00	   RAM_3E     =	$1000
    163  0000 ????	       04 00	   RAM_SIZE   =	$400
    164  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    165  0000 ????
    166  0000 ????
    167  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    168  0000 ????
    169  0000 ????
    170  0000 ????						; Platform constants:
    171  0000 ????	       00 02	   PAL	      =	%10
    172  0000 ????	       00 02	   PAL_50     =	PAL|0
    173  0000 ????	       00 03	   PAL_60     =	PAL|1
    174  0000 ????
    175  0000 ????
    176  0000 ????				      IF	L276
    177  0000 ????	       00 3e	   VBLANK_TIM_NTSC =	62	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    178  0000 ????			  -	      ELSE
    179  0000 ????			  -VBLANK_TIM_NTSC =	45	; NTSC 262
    180  0000 ????				      ENDIF
    181  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    182  0000 ????
    183  0000 ????				      IF	L276
    184  0000 ????	       00 33	   OVERSCAN_TIM_NTSC =	51	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    185  0000 ????			  -	      ELSE
    186  0000 ????			  -OVERSCAN_TIM_NTSC =	51	; NTSC 262
    187  0000 ????				      ENDIF
    188  0000 ????	       00 46	   OVERSCAN_TIM_PAL =	70	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    189  0000 ????
    190  0000 ????				      IF	L276
    191  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    192  0000 ????			  -	      ELSE
    193  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    194  0000 ????				      ENDIF
    195  0000 ????	       01 38	   SCANLINES_PAL =	312
    196  0000 ????
    197  0000 ????
    198  0000 ????						;------------------------------------------------------------------------------
    199  0000 ????						; MACRO definitions
    200  0000 ????
    201  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    202  0000 ????
    203  0000 ????				      MAC	newbank
    204  0000 ????				      SEG	{1}
    205  0000 ????				      ORG	ORIGIN
    206  0000 ????				      RORG	$F000
    207  0000 ????			   BANK_START SET	*
    208  0000 ????			   {1}	      SET	ORIGIN / 2048
    209  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    210  0000 ????			   _CURRENT_BANK SET	{1}
    211  0000 ????				      ENDM		; bank name
    212  0000 ????
    213  0000 ????				      MAC	define_1k_segment
    214  0000 ????				      ALIGN	$400
    215  0000 ????			   SEGMENT_{1} SET	*
    216  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    217  0000 ????				      ENDM		; {seg name}
    218  0000 ????
    219  0000 ????				      MAC	check_bank_size
    220  0000 ????			   .TEMP      =	* - BANK_START
    221  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    222  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    223  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    224  0000 ????				      ERR
    225  0000 ????				      endif
    226  0000 ????				      ENDM		; name
    227  0000 ????
    228  0000 ????
    229  0000 ????				      MAC	check_half_bank_size
    230  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    231  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    232  0000 ????			   .TEMP      =	* - BANK_START
    233  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    234  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    235  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    236  0000 ????				      ERR
    237  0000 ????				      endif
    238  0000 ????				      ENDM		; name
    239  0000 ????
    240  0000 ????
    241  0000 ????				      MAC	overlay
    242  0000 ????				      SEG.U	OVERLAY_{1}
    243  0000 ????				      org	Overlay
    244  0000 ????				      ENDM		; {name}
    245  0000 ????
    246  0000 ????						;--------------------------------------------------------------------------
    247  0000 ????
    248  0000 ????				      MAC	validate_overlay
    249  0000 ????				      LIST	OFF
    250  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    251  0000 ????				      ERR
    252  0000 ????				      endif
    253  0000 ????				      LIST	ON
    254  0000 ????				      ENDM
    255  0000 ????
    256  0000 ????						;--------------------------------------------------------------------------
    257  0000 ????						; Macro inserts a page break if the object would overlap a page
    258  0000 ????
    259  0000 ????				      MAC	optional_pagebreak
    260  0000 ????				      LIST	OFF
    261  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    262  0000 ????			   EARLY_LOCATION SET	*
    263  0000 ????				      ALIGN	256
    264  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    265  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    266  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    267  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    268  0000 ????				      ENDIF
    269  0000 ????				      LIST	ON
    270  0000 ????				      ENDM		; { string, size }
    271  0000 ????
    272  0000 ????
    273  0000 ????				      MAC	check_page_crossing
    274  0000 ????				      LIST	OFF
    275  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    276  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    277  0000 ????				      endif
    278  0000 ????				      LIST	ON
    279  0000 ????				      ENDM
    280  0000 ????
    281  0000 ????				      MAC	checkpage
    282  0000 ????				      LIST	OFF
    283  0000 ????				      IF	>. != >{1}
    284  0000 ????				      ECHO	""
    285  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    286  0000 ????				      ECHO	""
    287  0000 ????				      ERR
    288  0000 ????				      ENDIF
    289  0000 ????				      LIST	ON
    290  0000 ????				      ENDM
    291  0000 ????
    292  0000 ????				      MAC	checkpagex
    293  0000 ????				      LIST	OFF
    294  0000 ????				      IF	>. != >{1}
    295  0000 ????				      ECHO	""
    296  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    297  0000 ????				      ECHO	{2}
    298  0000 ????				      ECHO	""
    299  0000 ????				      ERR
    300  0000 ????				      ENDIF
    301  0000 ????				      LIST	ON
    302  0000 ????				      ENDM
    303  0000 ????
    304  0000 ????
    305  0000 ????				      MAC	checkpage_bne
    306  0000 ????				      LIST	OFF
    307  0000 ????				      IF	0	;>(. + 2) != >{1}
    308  0000 ????				      ECHO	""
    309  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    310  0000 ????				      ECHO	""
    311  0000 ????				      ERR
    312  0000 ????				      ENDIF
    313  0000 ????				      LIST	ON
    314  0000 ????				      bne	{1}
    315  0000 ????				      ENDM
    316  0000 ????
    317  0000 ????				      MAC	checkpage_bpl
    318  0000 ????				      LIST	OFF
    319  0000 ????				      IF	(>(.+2 )) != >{1}
    320  0000 ????				      ECHO	""
    321  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    322  0000 ????				      ECHO	""
    323  0000 ????				      ERR
    324  0000 ????				      ENDIF
    325  0000 ????				      LIST	ON
    326  0000 ????				      bpl	{1}
    327  0000 ????				      ENDM
    328  0000 ????
    329  0000 ????				      MAC	align_free
    330  0000 ????			   FREE       SET	FREE - .
    331  0000 ????				      align	{1}
    332  0000 ????			   FREE       SET	FREE + .
    333  0000 ????				      echo	"@", ., ":", FREE
    334  0000 ????				      ENDM
    335  0000 ????
    336  0000 ????				      MAC	stress_time
    337  0000 ????				      IF	TEST_{1} = 1
    338  0000 ????
    339  0000 ????
    340  0000 ????						;LIST OFF
    341  0000 ????						; has to be put *directly* after cmp #SEGTIME_... , bcc abort
    342  0000 ????						;LIST ON
    343  0000 ????				      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
    344  0000 ????				      bne	. - 7	; branches to lda INTIM
    345  0000 ????				      ENDIF
    346  0000 ????				      ENDM
    347  0000 ????
    348  0000 ????			   IDENTITY   SET	0
    349  0000 ????				      MAC	ident
    350  0000 ????				      if	DEBUG=YES
    351  0000 ????				      lda	#IDENTITY
    352  0000 ????				      sta	debug_ident
    353  0000 ????				      lda	{1}
    354  0000 ????				      sta	debug_object
    355  0000 ????				      endif
    356  0000 ????			   IDENTITY   SET	IDENTITY + 1
    357  0000 ????				      ENDM		; {object}
    358  0000 ????
    359  0000 ????						;--------------------------------------------------------------------------
    360  0000 ????
    361  0000 ????				      MAC	vector
    362  0000 ????				      .word	{1}
    363  0000 ????				      ENDM		; just a word pointer to code
    364  0000 ????
    365  0000 ????
    366  0000 ????				      MAC	define_subroutine
    367  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    368  0000 ????				      SUBROUTINE		; keep everything local
    369  0000 ????			   {1}			; entry point
    370  0000 ????				      ENDM		; name of subroutine
    371  0000 ????
    372  0000 ????
    373  0000 ????
    374  0000 ????						;--------------------------------------------------------------------------
    375  0000 ????
    376  0000 ????				      MAC	newrambank
    377  0000 ????				      SEG.U	{1}
    378  0000 ????				      ORG	ORIGIN
    379  0000 ????				      RORG	RAM_3E
    380  0000 ????			   BANK_START SET	*
    381  0000 ????			   {1}	      SET	ORIGIN / RAM_SIZE
    382  0000 ????			   ORIGIN     SET	ORIGIN + RAM_SIZE
    383  0000 ????				      ENDM		; bank name
    384  0000 ????
    385  0000 ????				      MAC	validate_ram_size
    386  0000 ????				      if	* - RAM_3E > RAM_SIZE
    387  0000 ????				      ERR
    388  0000 ????				      endif
    389  0000 ????				      ENDM
    390  0000 ????
    391  0000 ????				      MAC	next_random
    392  0000 ????						; update random value:
    393  0000 ????				      lda	rnd	; 3
    394  0000 ????				      lsr		; 2
    395  0000 ????				      IFCONST	rndHi
    396  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    397  0000 ????				      ENDIF
    398  0000 ????				      bcc	.skipEOR	; 2/3
    399  0000 ????				      eor	#RND_EOR_VAL	; 2
    400  0000 ????			   .skipEOR
    401  0000 ????				      sta	rnd	; 3 = 14/19
    402  0000 ????				      ENDM
    403  0000 ????
    404  0000 ????				      MAC	resync
    405  0000 ????						; resync screen, X and Y == 0 afterwards
    406  0000 ????				      lda	#%10	; make sure VBLANK is ON
    407  0000 ????				      sta	VBLANK
    408  0000 ????
    409  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    410  0000 ????			   .loopResync
    411  0000 ????				      VERTICAL_SYNC
    412  0000 ????
    413  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    414  0000 ????				      lda	Platform
    415  0000 ????				      eor	#PAL_50	; PAL-50?
    416  0000 ????				      bne	.ntsc
    417  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    418  0000 ????			   .ntsc
    419  0000 ????			   .loopWait
    420  0000 ????				      sta	WSYNC
    421  0000 ????				      sta	WSYNC
    422  0000 ????				      dey
    423  0000 ????				      bne	.loopWait
    424  0000 ????				      dex
    425  0000 ????				      bne	.loopResync
    426  0000 ????				      ENDM
    427  0000 ????
    428  0000 ????				      MAC	set_platform
    429  0000 ????						; 00 = NTSC
    430  0000 ????						; 01 = NTSC
    431  0000 ????						; 10 = PAL-50
    432  0000 ????						; 11 = PAL-60
    433  0000 ????				      lda	SWCHB
    434  0000 ????				      rol
    435  0000 ????				      rol
    436  0000 ????				      rol
    437  0000 ????				      and	#%11
    438  0000 ????				      if	NTSC_MODE = NO
    439  0000 ????				      eor	#PAL
    440  0000 ????				      endif
    441  0000 ????				      lda	#0	;tmp
    442  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    443  0000 ????				      ENDM
    444  0000 ????
    445  0000 ????						;  IF TJ_MODE
    446  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM ; = 29
    447  0000 ????						;	  ldy #{1}			  ; 2	  read bank
    448  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    449  0000 ????						;	  jsr GetRAMByteFromRAM 	  ;25
    450  0000 ????						;    ENDM
    451  0000 ????						;
    452  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM ; = 30
    453  0000 ????						;	  ldy #{1}			  ; 2	  write bank
    454  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    455  0000 ????						;	  jsr PutRAMByteFromRAM 	  ;26
    456  0000 ????						;    ENDM
    457  0000 ????						;
    458  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM_ADR ; = 39
    459  0000 ????						;	  ldx #<{1}			  ; 2
    460  0000 ????						;	  stx addressR			  ; 3
    461  0000 ????						;	  ldx #>{1}			  ; 2
    462  0000 ????						;	  stx addressR+1		  ; 3
    463  0000 ????						;	  GET_RAM_BYTE_FROM_RAM {2}, {3}  ;29
    464  0000 ????						;    ENDM
    465  0000 ????						;
    466  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM_ADR ; = 40
    467  0000 ????						;	  ldx #<{1}			  ; 2
    468  0000 ????						;	  stx addressW			  ; 3
    469  0000 ????						;	  ldx #>({1}+RAM_WRITE) 	  ; 2
    470  0000 ????						;	  stx addressW+1		  ; 3
    471  0000 ????						;	  PUT_RAM_BYTE_FROM_RAM {2}, {3}  ;30
    472  0000 ????						;    ENDM
    473  0000 ????						;  ENDIF
    474  0000 ????
    475  0000 ????				      MAC	nop_b
    476  0000 ????				      .byte	$82
    477  0000 ????				      ENDM		; unused
    478  0000 ????
    479  0000 ????				      MAC	nop_w
    480  0000 ????				      .byte	$0c
    481  0000 ????				      ENDM
    482  0000 ????
    483  0000 ????						;------------------------------------------------------------------------------
    484  0000 ????
    485  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34 U00f6 ????				      SEG.U	variables
     35 U0080					      ORG	$80
     36 U0080
     37 U0080
     38 U0080		       00 40	   GAMEMODE_2600 =	64
     39 U0080		       00 80	   GAMEMODE_PAUSED =	128
     40 U0080
     41 U0080		       00	   gameMode   ds	1	; bit7=0: 7800; bit7=1: 2600.	bit 6=1: paused: bit3: toggle bit for B/W
     42 U0081		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U0082							; above variables are preserved ALL the time!
     44 U0082
     45 U0082		       00	   rnd	      ds	1
     46 U0083		       00	   rndHi      ds	1	; to get better random values
     47 U0084
     48 U0084		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     49 U0085		       00	   ObjStackNum ds	1	; which stack in use
     50 U0086		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     51 U0088		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     52 U0089		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     53 U008a
     54 U008a		       00	   POS_X      ds	1
     55 U008b		       00	   POS_Y      ds	1
     56 U008c		       00	   POS_X_NEW  ds	1
     57 U008d		       00	   POS_Y_NEW  ds	1
     58 U008e		       00	   POS_Type   ds	1
     59 U008f		       00	   POS_VAR    ds	1
     60 U0090
     61 U0090		       00 00	   BufferedJoystick ds	2	; player joystick input
     62 U0092		       00 00	   BufferedButton ds	2	; player button press
     63 U0094
     64 U0094							; Scrolling is limited to only show board within the following area...
     65 U0094		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in UnpackLevel)
     66 U0095		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in UnpackLevel)
     67 U0096		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     68 U0097		       00	   BoardScrollX ds	1	; scroll position in board (X)
     69 U0097		       00 94	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     70 U0097		       00 95	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     71 U0098		       00	   scrollBits ds	1
     72 U0099
     73 U0099		       00	   whichPlayer ds	1	; 0 = P1, 1 = P2
     74 U009a		       00	   manAnimationIndex ds	1
     75 U009b		       00	   ManX       ds	1
     76 U009c		       00	   ManY       ds	1
     77 U009d		       00	   ManDrawX   ds	1
     78 U009e		       00	   ManDrawY   ds	1
     79 U009f		       00	   ManMode    ds	1
     80 U00a0		       00	   ManDelayCount ds	1
     81 U00a1		       00 00	   ManAnimation ds	2
     82 U00a3		       00	   ManAnimationFrameLO ds	1
     83 U00a4		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     84 U00a5		       00	   ManPushCounter ds	1
     85 U00a6		       00	   LookingAround ds	1
     86 U00a7		       00	   ManCount   ds	1	; player life counter
     87 U00a8		       00	   DelayEndOfLevel ds	1
     88 U00a9		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     89 U00aa		       00 00	   circle_d   ds	2
     90 U00ac		       00	   circ_x     ds	1
     91 U00ad		       00	   circ_y     ds	1
     92 U00ae		       00	   circ_char  ds	1
     93 U00af		       00	   circ_scratch ds	1
     94 U00b0		       00	   LEVEL_bank ds	1
     95 U00b1							;---------------------------------------------------------------------------
     96 U00b1							; 2 (shared) demo mode variables:
     97 U00b1		       00 a9	   demoMode   =	jtoggle	; bit 7==1 => demo mode
     98 U00b1		       00 a9	   moveLen    =	jtoggle	; bits 0..6
     99 U00b1		       00 99	   moveIdx    =	whichPlayer
    100 U00b1
    101 U00b1		       00	   LastSpriteY ds	1
    102 U00b2
    103 U00b2		       00	   timer      ds	1
    104 U00b3
    105 U00b3		       00	   BGColour   ds	1
    106 U00b4
    107 U00b4							; levelx and level have to be consecutive variables!
    108 U00b4		       00	   levelX     ds	1	; current player's level (other in scoring bank)
    109 U00b5		       00	   level      ds	1	; current player's level (other in scoring bank)
    110 U00b6		       00	   levelDisplay ds	1	; what to display as the level ID
    111 U00b7		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
    112 U00b8		       00	   ThrottleSpeed ds	1	; system-dependant throttle speed
    113 U00b9
    114 U00b9		       00	   targetsRequired ds	1	; number of un-targeted left to go
    115 U00ba		       00	   moveCounter ds	1	; BCD seconds for level
    116 U00bb		       00	   moveCounterHi ds	1
    117 U00bc		       00	   moveCounterBinary ds	1
    118 U00bd		       00 00 00    color      ds	3	; RGB for NTSC, RGB for PAL
    119 U00c0		       00 00	   Board_AddressR ds	2
    120 U00c2		       00 00	   Board_AddressW ds	2
    121 U00c4		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
    122 U00c5		       00	   RAM_Bank   ds	1
    123 U00c6
    124 U00c6		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
    125 U00c7		       00	   extraLifeTimer ds	1	; should be 5 seconds!
    126 U00c8
    127 U00c8							; extraLifeTimer:
    128 U00c8							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    129 U00c8
    130 U00c8		       00	   scoringTimer ds	1	; times the various score displays
    131 U00c9		       00	   scoringFlags ds	1	; scoring flags are stored here
    132 U00ca
    133 U00ca							; scoringFlags:
    134 U00ca							; D7		 Extra TARGETs in effect (TARGETs collected over requirement score more) ASSUMED BPL/BMI usage
    135 U00ca							; D6		 unused
    136 U00ca							; D5		 unused
    137 U00ca							; D4		 unused
    138 U00ca							; D3		 unused
    139 U00ca							; D2		 unused
    140 U00ca							; D1	 D1-D0	 Which display kernel to use for scoring
    141 U00ca							; D0		 0 = 2x4     used for TARGETs/time
    142 U00ca							;		 1 = 1x6     used for score
    143 U00ca							;		 2 = 3x2     used for level/lives/player
    144 U00ca
    145 U00ca		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    146 U00ca		       00 80	   BIT_NEXTLEVEL =	128
    147 U00ca		       00 40	   BIT_NEXTLIFE =	64
    148 U00cb
    149 U00cb							;---------------------------------------------------------------------------
    150 U00cb
    151 U00cb		       00	   sortRequired ds	1
    152 U00cc		       00	   sortPtr    ds	1
    153 U00cd
    154 U00cd							;------------------------------------------------------------------------------
    155 U00cd
    156 U00cd		       00	   ObjIterator ds	1	; count UP iterator over objects
    157 U00ce		       00	   DSL	      ds	1	; stack line counter
    158 U00cf
------- FILE sound/intro1_variables.asm LEVEL 3 PASS 3
      0 U00cf					      include	"sound/intro1_variables.asm"
      1 U00cf							; TIATracker music player
      2 U00cf							; Copyright 2016 Andre "Kylearan" Wichmann
      3 U00cf							; Website: https://bitbucket.org/kylearan/tiatracker
      4 U00cf							; Email: andre.wichmann@gmx.de
      5 U00cf							;
      6 U00cf							; Licensed under the Apache License, Version 2.0 (the "License");
      7 U00cf							; you may not use this file except in compliance with the License.
      8 U00cf							; You may obtain a copy of the License at
      9 U00cf							;
     10 U00cf							;   http://www.apache.org/licenses/LICENSE-2.0
     11 U00cf							;
     12 U00cf							; Unless required by applicable law or agreed to in writing, software
     13 U00cf							; distributed under the License is distributed on an "AS IS" BASIS,
     14 U00cf							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15 U00cf							; See the License for the specific language governing permissions and
     16 U00cf							; limitations under the License.
     17 U00cf
     18 U00cf							; Song author: 
     19 U00cf							; Song name: 
     20 U00cf
     21 U00cf							; @com.wudsn.ide.asm.hardware=ATARI2600
     22 U00cf
     23 U00cf							; =====================================================================
     24 U00cf							; Flags
     25 U00cf							; =====================================================================
     26 U00cf
     27 U00cf							; 1: Global song speed, 0: Each pattern has individual speed
     28 U00cf		       00 01	   TT_GLOBAL_SPEED =	1
     29 U00cf							; duration (number of TV frames) of a note
     30 U00cf		       00 05	   TT_SPEED   =	5
     31 U00cf							; duration of odd frames (needs TT_USE_FUNKTEMPO)
     32 U00cf		       00 04	   TT_ODD_SPEED =	4
     33 U00cf
     34 U00cf							; 1: Overlay percussion, +40 bytes
     35 U00cf		       00 01	   TT_USE_OVERLAY =	1
     36 U00cf							; 1: Melodic instrument slide, +9 bytes
     37 U00cf		       00 00	   TT_USE_SLIDE =	0
     38 U00cf							; 1: Goto pattern, +8 bytes
     39 U00cf		       00 01	   TT_USE_GOTO =	1
     40 U00cf							; 1: Odd/even rows have different SPEED values, +7 bytes
     41 U00cf		       00 01	   TT_USE_FUNKTEMPO =	1
     42 U00cf							; If the very first notes played on each channel are not PAUSE, HOLD or
     43 U00cf							; SLIDE, i.e. if they start with an instrument or percussion, then set
     44 U00cf							; this flag to 0 to save 2 bytes.
     45 U00cf							; 0: +2 bytes
     46 U00cf		       00 01	   TT_STARTS_WITH_NOTES =	1
     47 U00cf
     48 U00cf
     49 U00cf							; =====================================================================
     50 U00cf							; Permanent variables. These are states needed by the player.
     51 U00cf							; =====================================================================
     52 U00cf		       00	   tt_timer   ds	1	; current music timer value
     53 U00d0		       00	   tt_cur_pat_index_c0 ds	1	; current pattern index into tt_SequenceTable
     54 U00d1		       00	   tt_cur_pat_index_c1 ds	1
     55 U00d2		       00	   tt_cur_note_index_c0 ds	1	; note index into current pattern
     56 U00d3		       00	   tt_cur_note_index_c1 ds	1
     57 U00d4		       00	   tt_envelope_index_c0 ds	1	; index into ADSR envelope
     58 U00d5		       00	   tt_envelope_index_c1 ds	1
     59 U00d6		       00	   tt_cur_ins_c0 ds	1	; current instrument
     60 U00d7		       00	   tt_cur_ins_c1 ds	1
     61 U00d8
     62 U00d8
     63 U00d8							; =====================================================================
     64 U00d8							; Temporary variables. These will be overwritten during a call to the
     65 U00d8							; player routine, but can be used between calls for other things.
     66 U00d8							; =====================================================================
     67 U00d8		       00 00	   tt_ptr     ds	2
------- FILE zeropage.asm
    160 U00da
    161 U00da
    162 U00da
    163 U00da				   OVERLAY_SIZE SET	16
    164 U00da
    165 U00da
    166 U00da
    167 U00da							; This overlay variable is used for the overlay variables.  That's OK.
    168 U00da							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    169 U00da							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    170 U00da							; (especially the latter ones) are only used in rare occasions.
    171 U00da
    172 U00da							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    173 U00da							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    174 U00da
    175 U00da		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00ea					      VALIDATE_OVERLAY
      5 U00ea					      LIST	ON
    177 U00ea
    178 U00ea
    179 U00ea		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    180 U00f6
 FREE BYTES IN ZERO PAGE =  $9
    181 U00f6					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    182 U00f6				  -	      IF	* > $FF
    183 U00f6				  -	      ERR
    184 U00f6					      ENDIF
------- FILE ./sokoboo.asm
    487 U00f6
    488 U00f6
    489 U00f6							;------------------------------------------------------------------------------
    490 U00f6							; OVERLAYS!
    491 U00f6							; These variables are overlays, and should be managed with care
    492 U00f6							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    493 U00f6
    494 U00f6							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    495 U00f6							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    496 U00f6
    497 U00f6							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    498 U00f6
    499 U00f6
    500 U00f6
    501 U00f6							;------------------------------------------------------------------------------
      0 U00f6					      OVERLAY	BuildDrawFlags
      1 U00e5 ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00da					      org	Overlay
    503 U00da
    504 U00da		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    505 U00dc		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    506 U00de		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    507 U00e0		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    508 U00e2							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    509 U00e2		       00	   BDF_BoardBank ds	1	; holds bank of current line
    510 U00e3							;  ENDIF
    511 U00e3		       00	   DHS_Line   ds	1
    512 U00e4		       00	   DHS_Stack  ds	1	; for restoring SP
    513 U00e5							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e5					      VALIDATE_OVERLAY
      5 U00e5					      LIST	ON
    515 U00e5
    516 U00e5							;------------------------------------------------------------------------------
    517 U00e5
      0 U00e5					      OVERLAY	Process
      1 U00dd ????				      SEG.U	OVERLAY_Process
      2 U00da					      org	Overlay
    519 U00da
    520 U00da		       00	   BOXLeft    ds	1
    521 U00db		       00	   BOXRight   ds	1
    522 U00dc		       00	   restorationCharacter ds	1
    523 U00dd
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    525 U00dd
    526 U00dd							;------------------------------------------------------------------------------
    527 U00dd
      0 U00dd					      OVERLAY	Animate
      1 U00db ????				      SEG.U	OVERLAY_Animate
      2 U00da					      org	Overlay
    529 U00da		       00	   halftimer  ds	1
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    531 U00db
    532 U00db							;------------------------------------------------------------------------------
    533 U00db
      0 U00db					      OVERLAY	TimeSlice
      1 U00dc ????				      SEG.U	OVERLAY_TimeSlice
      2 U00da					      org	Overlay
    535 U00da
    536 U00da		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    537 U00dc							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    539 U00dc
    540 U00dc							;------------------------------------------------------------------------------
    541 U00dc
      0 U00dc					      OVERLAY	CopyROMShadowToRAM
      1 U00dd ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00da					      org	Overlay
    543 U00da
    544 U00da		       00	   O_CopyCount ds	1
    545 U00db		       00	   O_ROM_Source_Bank ds	1
    546 U00dc		       00	   O_Index    ds	1
    547 U00dd							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    549 U00dd
    550 U00dd							;------------------------------------------------------------------------------
    551 U00dd
      0 U00dd					      OVERLAY	Scoring
      1 U00dc ????				      SEG.U	OVERLAY_Scoring
      2 U00da					      org	Overlay
    553 U00da		       00	   tmpStack   ds	1
    554 U00da		       00 da	   newDisplay =	tmpStack
    555 U00db							; also for UpdateTimer
    556 U00db		       00 da	   tmpSound   =	tmpStack
    557 U00db		       00	   timerLoops ds	1
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    559 U00dc
    560 U00dc
    561 U00dc							;------------------------------------------------------------------------------
    562 U00dc
      0 U00dc					      OVERLAY	SaveKey
      1 U00e3 ????				      SEG.U	OVERLAY_SaveKey
      2 U00da					      org	Overlay
    564 U00da
    565 U00da		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    566 U00dd		       00 00 00    highScoreSK ds	3
    567 U00e0		       00	   startingLevel ds	1	; levelx * 5
    568 U00e1		       00	   startLevel ds	1
    569 U00e2		       00	   offsetSK   ds	1	; for calculating the SK slot address
    570 U00e3
      0 U00e3					      VALIDATE_OVERLAY
      5 U00e3					      LIST	ON
    572 U00e3
    573 U00e3							;------------------------------------------------------------------------------
    574 U00e3
      0 U00e3					      OVERLAY	DrawMan
      1 U00dc ????				      SEG.U	OVERLAY_DrawMan
      2 U00da					      org	Overlay
    576 U00da
    577 U00da		       00 00	   MAN_Move   ds	2
    578 U00dc
    579 U00dc							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    581 U00dc
    582 U00dc							;------------------------------------------------------------------------------
    583 U00dc
      0 U00dc					      OVERLAY	ProcessObjStack
      1 U00dc ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00da					      org	Overlay
    585 U00da
    586 U00da		       00 00	   POS_Vector ds	2
    587 U00dc
    588 U00dc							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    590 U00dc
    591 U00dc							;------------------------------------------------------------------------------
    592 U00dc
      0 U00dc					      OVERLAY	ScoreLineOverlay
      1 U00e9 ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00da					      org	Overlay
    594 U00da
    595 U00da		       00 00	   S0	      ds	2	; used for addressing digits of score
    596 U00dc		       00 00	   S1	      ds	2
    597 U00de		       00 00	   S2	      ds	2
    598 U00e0		       00 00	   S3	      ds	2
    599 U00e2		       00 00	   S4	      ds	2
    600 U00e4		       00 00	   S5	      ds	2
    601 U00e6
    602 U00e6		       00	   stkp       ds	1
    603 U00e7		       00	   sreg       ds	1
    604 U00e8		       00	   loop       ds	1
    605 U00e9
    606 U00e9							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e9					      VALIDATE_OVERLAY
      5 U00e9					      LIST	ON
    608 U00e9
    609 U00e9							;------------------------------------------------------------------------------
    610 U00e9
    611 U00e9
      0 U00e9					      OVERLAY	UnpackLevelOverlay
      1 U00df ????				      SEG.U	OVERLAY_UnpackLevelOverlay
      2 U00da					      org	Overlay
    613 U00da
    614 U00da		       00	   base_x     ds	1
    615 U00db		       00	   base_y     ds	1
    616 U00dc		       00	   upk_length ds	1
    617 U00dd		       00	   upk_column ds	1
    618 U00de		       00	   upk_temp   ds	1
    619 U00df
    620 U00df							;ECHO "FREE BYTES IN UnpackLevelOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00df					      VALIDATE_OVERLAY
      5 U00df					      LIST	ON
    622 U00df
    623 U00df							;------------------------------------------------------------------------------
    624 U00df
      0 U00df					      OVERLAY	ManProcessing
      1 U00dc ????				      SEG.U	OVERLAY_ManProcessing
      2 U00da					      org	Overlay
    626 U00da		       00 00	   actionVector ds	2
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    628 U00dc
      0 U00dc					      OVERLAY	SetPlatformColours
      1 U00db ????				      SEG.U	OVERLAY_SetPlatformColours
      2 U00da					      org	Overlay
    630 U00da		       00	   colorIdx   ds	1
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    632 U00db
      0 U00db					      OVERLAY	SwapPlayers
      1 U00db ????				      SEG.U	OVERLAY_SwapPlayers
      2 U00da					      org	Overlay
    634 U00da		       00	   tmpX       ds	1
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    636 U00db
      0 U00db					      OVERLAY	DrawIntoStack
      1 U00db ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00da					      org	Overlay
    638 U00da		       00	   save_SP    ds	1
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    640 U00db
    641 U00db							;------------------------------------------------------------------------------
    642 U00db							;##############################################################################
    643 U00db							;------------------------------------------------------------------------------
    644 U00db
    645 U00db							; NOW THE VERY INTERESTING '3E' RAM BANKS
    646 U00db							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    647 U00db
    648 U00db				   ORIGIN     SET	0
      0 U00db					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN / RAM_SIZE
      6 U0000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    650 U0000
    651 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    652 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    653 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    654 U0000
    655 U0000		       00 54	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    656 U0000
    657 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    658 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    659 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    660 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    661 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    662 U0000
    663 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    664 U0000							; is that we can use that code to switch between banks, and the system will happily
    665 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    666 U0000
    667 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    668 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    669 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    670 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    671 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    672 U0000
    673 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    674 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    675 U0000							; part of the draw routine *every* scanline (though the system currently uses
    676 U0000							; one colour shared between both players).
    677 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    679 U0000
    680 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    681 U0000							; accessed via the above labels but with the appropriate bank switched in.
    682 U0000
    683 U0000							;------------------------------------------------------------------------------
    684 U0000
    685 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    685 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    685 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    685 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1000				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    685 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    685 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    685 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    688 U1c00					      REPEND
    689 U1c00
    690 U1c00							;------------------------------------------------------------------------------
    691 U1c00							;##############################################################################
    692 U1c00							;------------------------------------------------------------------------------
    693 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN / RAM_SIZE
      6 U2000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    695 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    696 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    698 U2000
    699 U2000							;------------------------------------------------------------------------------
    700 U2000							;##############################################################################
    701 U2000							;------------------------------------------------------------------------------
    702 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN / RAM_SIZE
      6 U2400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    704 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    705 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    707 U2400
    708 U2400							;------------------------------------------------------------------------------
    709 U2400							;##############################################################################
    710 U2400							;------------------------------------------------------------------------------
    711 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_LEVEL
      1 U2800 ????				      SEG.U	BANK_DECODE_LEVEL
      2 U2800					      ORG	ORIGIN
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_LEVEL SET	ORIGIN / RAM_SIZE
      6 U2800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    713 U2800							; VARS DEFINED IN BANK_DECODE_LEVEL_SHADOW
    714 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    716 U2800
    717 U2800							;------------------------------------------------------------------------------
    718 U2800							;##############################################################################
    719 U2800							;------------------------------------------------------------------------------
    720 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN / RAM_SIZE
      6 U2c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
    722 U2c00
    723 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    724 U2c00							; position of something that needs to be processed.  These things include anything
    725 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    726 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    727 U2c00							; one for the next processing iteration.
    728 U2c00
    729 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    730 U2c00
    731 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    732 U2c00
    733 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    734 U2c00
    735 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    736 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    737 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    738 U2d80
    739 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    740 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    741 U2e00
    742 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    743 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    744 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    745 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    747 U2e80
    748 U2e80							;------------------------------------------------------------------------------
    749 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN / RAM_SIZE
      6 U3000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    751 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    753 U3000
    754 U3000							;------------------------------------------------------------------------------
    755 U3000							;##############################################################################
    756 U3000							;------------------------------------------------------------------------------
    757 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U37a0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN / RAM_SIZE
      6 U3400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    759 U3400
    760 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    761 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    762 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    763 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    764 U3400							; when accessing.
    765 U3400
    766 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    767 U3400							; automatically based on the sizes set in these constants. The board may overlay
    768 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    769 U3400							; we're doing OK.
    770 U3400
    771 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    772 U3400
    773 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    774 U3400
    775 U3400		       00 28	   SIZE_BOARD_X =	40
    776 U3400		       00 16	   SIZE_BOARD_Y =	22
    777 U3400
    778 U3400							; have to precalculate it here, else DASM freaks out:
    779 U3400				   .BOARD_SIZE SET	0
    780 U3400				   .BOARD_LOCATION SET	0
    781 U3400					      REPEAT	SIZE_BOARD_Y
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    781 U3400					      REPEND
    782 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    783 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    784 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    785 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    786 U3400					      ENDIF
    787 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    788 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    789 U3400					      REPEND
    790 U3400
    791 U3400		       03 a0	   SIZE_BOARD =	.BOARD_SIZE
    792 U3400
    793 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    794 U3400				  -MULTI_BANK_BOARD =	YES
    795 U3400					      ELSE
    796 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    797 U3400					      ENDIF
    798 U3400
    799 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    800 U37a0							; 1024 byte chunks, switching RAM
    801 U37a0							; banks as we go.  In other words,
    802 U37a0							; this overlaps multiple banks!
    803 U37a0
      0 U37a0					      NEWRAMBANK	BANK_TAKEBACK
      1 U3b00 ????				      SEG.U	BANK_TAKEBACK
      2 U3800					      ORG	ORIGIN
      3 U3800					      RORG	RAM_3E
      4 U3800				   BANK_START SET	*
      5 U3800				   BANK_TAKEBACK SET	ORIGIN / RAM_SIZE
      6 U3800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    805 U3800		       00 00 00 00*TakeBackX  ds	256
    806 U3900		       00 00 00 00*TakeBackY  ds	256
    807 U3a00		       00 00 00 00*TakeBackA  ds	256
    808 U3b00
    809 U3b00							; free space here (but hard to use)
    810 U3b00							; So we need to calculate where the next free bank is!
    811 U3b00							; TODO: This looks dodgy.  Check..
    812 U3b00
    813 U3b00				   ORIGIN     SET	( * + RAM_SIZE - 1 ) / RAM_SIZE
    814 U3b00				   ORIGIN     SET	ORIGIN * RAM_SIZE
    815 U3b00
    816 U3b00
    817 U3b00
    818 U3b00							;------------------------------------------------------------------------------
    819 U3b00							;##############################################################################
    820 U3b00							;------------------------------------------------------------------------------
    821 U3b00
    822 U3b00							;------------------------------------------------------------------------------
    823 U3b00
    824 U3b00							;    IFNCONST MAX_LEVEL_SIZE
    825 U3b00				   MAX_LEVEL_SIZE SET	0
    826 U3b00							;    ENDIF
    827 U3b00
    828 U3b00					      MAC	start_level
    829 U3b00				   LEVEL_START SET	*
    830 U3b00				   BANK_LEVEL_{1} =	_CURRENT_BANK
    831 U3b00				   LEVEL_{1}  SUBROUTINE
    832 U3b00				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
    833 U3b00							; ECHO "current MAX_LEVEL_NUMBER = ", MAX_LEVEL_NUMBER
    834 U3b00					      ENDM		; {name}
    835 U3b00
    836 U3b00
    837 U3b00					      MAC	end_level
    838 U3b00					      .byte	0
    839 U3b00				   LEVEL_SIZE_{1} =	* - LEVEL_START
    840 U3b00					      IF	LEVEL_SIZE_{1} > MAX_LEVEL_SIZE
    841 U3b00				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_{1}
    842 U3b00					      ENDIF
    843 U3b00					      ENDM		; {name}
    844 U3b00
    845 U3b00
    846 U3b00					      MAC	defl
    847 U3b00					      START_LEVEL	{1}
    848 U3b00					      .byte	{2},0
    849 U3b00					      END_LEVEL	{1}
    850 U3b00					      ENDM
    851 U3b00
    852 U3b00							;--------------------------------------------------------------------------------
    853 U3b00
    854 U3b00				   ORIGIN     SET	$00000
    855 U3b00
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 3
      0 U3b00					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1 U3b00							;    Sokoboo - a Sokoban implementation
      2 U3b00							;    using a generic tile-based display engine for the Atari 2600
      3 U3b00							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4 U3b00							;
      5 U3b00							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6 U3b00							;
      7 U3b00							;    Code related to the generic tile-based display engine was developed by
      8 U3b00							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9 U3b00							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10 U3b00							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11 U3b00							;
     12 U3b00							;    Code related to music and sound effects uses the TIATracker music player
     13 U3b00							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14 U3b00							;    directory for Apache licensing details.
     15 U3b00							;
     16 U3b00							;    Some level data incorporated in this program were created by Lee J Haywood.
     17 U3b00							;    See the copyright notices in the License directory for a list of level
     18 U3b00							;    contributors.
     19 U3b00							;
     20 U3b00							;    Except where otherwise indicated, this software is released under the
     21 U3b00							;    following licensing arrangement...
     22 U3b00							;
     23 U3b00							;    This program is free software: you can redistribute it and/or modify
     24 U3b00							;    it under the terms of the GNU General Public License as published by
     25 U3b00							;    the Free Software Foundation, either version 3 of the License, or
     26 U3b00							;    (at your option) any later version.
     27 U3b00							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28 U3b00
     29 U3b00							;    This program is distributed in the hope that it will be useful,
     30 U3b00							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31 U3b00							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32 U3b00							;    GNU General Public License for more details.
     33 U3b00
     34 U3b00							;------------------------------------------------------------------------------
     35 U3b00							;##############################################################################
     36 U3b00							;------------------------------------------------------------------------------
      0 U3b00					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  0346 ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
     38  0000
     39  0000							; This is essentially a ROM mirror of a RAM bank.
     40  0000							; The contents of this bank are copied to each of the ROW banks on startup, and
     41  0000							; this gives a 1:1 correspondence between the data/addresses defined here, and
     42  0000							; the addresses in the switched-in RAM bank.
     43  0000
     44  0000							; Note: Bankswitching code between any of these banks guarantees the code can
     45  0000							; continue to run -- because, of course, the same code is still at the same
     46  0000							; memory address.
     47  0000
     48  0000		       00 01	   _PROFILE_DRAW =	YES
     49  0000
     50  0000					      MAC	profile_draw
     51  0000					      IF	_PROFILE_DRAW
     52  0000					      inc	Profile{1}
     53  0000					      bne	$skip
     54  0000					      inc	Profile{1}+1
     55  0000				   $skip
     56  0000					      ENDIF
     57  0000					      ENDM		; {label}
     58  0000
     59  0000
      0  0000					      DEFINE_SUBROUTINE	DrawTheScreen
      1  0000		       00 00	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  0000					      SUBROUTINE
      3  0000				   DrawTheScreen
     61  0000
     62  0000							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     63  0000							; A refactor of the kernel to improve the timing.
     64  0000							; Experimental refactor to remove the blank line...
     65  0000
     66  0000							; adjust here so that the first line of the kernel starts exactly at cycle 67
     67  0000							; (since TJ said it could start up to 5 cycles earlier than #67).
     68  0000
     69  0000							; TODO: remove GRP1 and COLUP1 access (or use higher resolution player)
     70  0000							;	     @57
      0  0000					      SLEEP	3	; 3
      1  0000				   .CYCLES    SET	3
      2  0000
      3  0000				  -	      IF	.CYCLES < 2
      4  0000				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0000				  -	      ERR
      6  0000					      ENDIF
      7  0000
      8  0000					      IF	.CYCLES & 1
      9  0000					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0000		       04 00		      nop	0
     11  0002				  -	      ELSE
     12  0002				  -	      bit	VSYNC
     13  0002					      ENDIF
     14  0002				   .CYCLES    SET	.CYCLES - 3
     15  0002					      ENDIF
     16  0002
     17  0002				  -	      REPEAT	.CYCLES / 2
     18  0002				  -	      nop
     19  0002					      REPEND
     72  0002
     73  0002		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     74  0004		       10 3e		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     75  0006
     76  0006				   Proc2		; 5
      0  0006					      SLEEP	3	; 3	     @64
      1  0006				   .CYCLES    SET	3
      2  0006
      3  0006				  -	      IF	.CYCLES < 2
      4  0006				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0006				  -	      ERR
      6  0006					      ENDIF
      7  0006
      8  0006					      IF	.CYCLES & 1
      9  0006					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0006		       04 00		      nop	0
     11  0008				  -	      ELSE
     12  0008				  -	      bit	VSYNC
     13  0008					      ENDIF
     14  0008				   .CYCLES    SET	.CYCLES - 3
     15  0008					      ENDIF
     16  0008
     17  0008				  -	      REPEAT	.CYCLES / 2
     18  0008				  -	      nop
     19  0008					      REPEND
     78  0008		       10 3c		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     79  000a
     80  000a				   ScanRED		;	     @60
     81  000a		       b9 03 f3    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     82  000d		       85 4d		      sta	PF0	; 3	     @67
     83  000f		       b9 85 f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     84  0012		       85 4e		      sta	PF1	; 3 = 14    @74
     85  0014				   SELFMOD_PLAYERCOL_RED
     86  0014		       b9 af f0 	      lda	SpriteColourRED,y	; 4
     87  0017		       85 46		      sta	COLUP0	; 3	     @05
     88  0019		       85 47		      sta	COLUP1	; 3 = 10    @08
     89  001b
     90  001b							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     91  001b
     92  001b				   SELFMOD_RED
     93  001b		       a9 00		      lda	#0	; 2
     94  001d		       85 48		      sta	COLUPF	; 3 =	5    @13
     95  001f
     96  001f				   SELFMOD_PLAYER0_RED
     97  001f		       b9 03 f3 	      lda	ShapePlayerRED,y	; 4
     98  0022		       85 5b		      sta	GRP0	; 3 =	7    @20
     99  0024
    100  0024		       b9 9a f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
    101  0027		       85 4f		      sta	PF2	; 3 =	7    @27
    102  0029
    103  0029		       b9 03 f3    SM_PF0_REDr lda	CHARACTERSHAPE_BLANK,y	; 4
    104  002c		       85 4d		      sta	PF0	; 3	     @34
    105  002e		       b9 af f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
    106  0031		       85 4e		      sta	PF1	; 3	     @41
    107  0033		       b9 c4 f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
    108  0036		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
    109  0038
    110  0038				   SELFMOD_PLAYER1_RED
    111  0038		       b9 03 f3 	      lda	ShapePlayerRED,y	; 4
    112  003b		       8d 5c 00 	      sta.w	GRP1	; 4 =	8    @56   VDELed!
    113  003e
    114  003e		       88		      dey		; 2
    115  003f		       10 c5		      bpl	Proc2	; 2(3)      --> 61 if taken
    116  0041
    117  0041		       e8	   SELFMOD_X  inx		; 2
    118  0042		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
    119  0044							;EXIT_RETURN_HERE
    120  0044				   NextALineStart
    121  0044		       a0 06		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
    122  0046				   ScanBLUEBD		;	     @67     let's start as late as possible
    123  0046
    124  0046							;------------------------------------------------------------------------------
    125  0046
    126  0046		       b9 03 f3    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
    127  0049		       85 4d		      sta	PF0	; 3 =	7    @74
    128  004b				   SELFMOD_PLAYERCOL_BLUE
    129  004b		       b9 bd f0 	      lda	SpriteColourBLUE,y	; 4
    130  004e		       85 47		      sta	COLUP1	; 3	     @05
    131  0050		       85 46		      sta	COLUP0	; 3 = 10    @08
    132  0052
    133  0052				   SELFMOD_BLUE
    134  0052		       a9 00		      lda	#0	; 2
    135  0054		       85 48		      sta	COLUPF	; 3 =	5    @13
    136  0056
    137  0056				   SELFMOD_PLAYER0_BLUE
    138  0056		       b9 03 f3 	      lda	ShapePlayerBLUE,y	; 4
    139  0059		       85 5b		      sta	GRP0	; 3 =	7    @20
    140  005b
    141  005b		       b9 93 f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    142  005e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    143  0060		       b9 a8 f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    144  0063		       85 4f		      sta	PF2	; 3 = 14    @34
    145  0065
    146  0065		       b9 03 f3    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    147  0068		       85 4d		      sta	PF0	; 3	     @41
    148  006a		       b9 bd f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    149  006d		       85 4e		      sta	PF1	; 3	     @48
    150  006f		       b9 d2 f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    151  0072		       85 4f		      sta	PF2	; 3 = 21    @55
    152  0074
    153  0074				   SELFMOD_PLAYER1_BLUE
    154  0074		       b9 03 f3 	      lda	ShapePlayerBLUE,y	; 4
    155  0077		       85 5c		      sta	GRP1	; 3 =	7    VDELed! @62
    156  0079
    157  0079							;------------------------------------------------------------------------------
    158  0079
    159  0079				   ScanGREEN		;	     @62
    160  0079		       b9 03 f3    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    161  007c		       85 4d		      sta	PF0	; 3 =	7    @69
    162  007e				   SELFMOD_PLAYERCOL_GREEN
    163  007e		       b9 b6 f0 	      lda	SpriteColourGREEN,y	; 4
    164  0081		       85 47		      sta	COLUP1	; 3	     @00
    165  0083		       85 46		      sta	COLUP0	; 3 = 10    @03
    166  0085
    167  0085				   SELFMOD_GREEN
    168  0085		       a9 00		      lda	#0	; 2
    169  0087		       85 48		      sta	COLUPF	; 3 =	5    @08
    170  0089
    171  0089				   SELFMOD_PLAYER0_GREEN
    172  0089		       b9 03 f3 	      lda	ShapePlayerGREEN,y	; 4
    173  008c		       85 5b		      sta	GRP0	; 3 =	7    @15
    174  008e
    175  008e		       b9 8c f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    176  0091		       85 4e		      sta	PF1	; 3	     @22
    177  0093		       b9 a1 f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    178  0096		       85 4f		      sta	PF2	; 3 = 14    @29
    179  0098
    180  0098		       b9 03 f3    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    181  009b		       85 4d		      sta	PF0	; 3	     @36
    182  009d		       b9 b6 f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    183  00a0		       85 4e		      sta	PF1	; 3	     @43
    184  00a2		       b9 cb f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    185  00a5		       85 4f		      sta	PF2	; 3 = 21    @50
    186  00a7
    187  00a7				   SELFMOD_PLAYER1_GREEN
    188  00a7		       b9 03 f3 	      lda	ShapePlayerGREEN,y	; 4
    189  00aa		       85 5c		      sta	GRP1	; 3 =	7    @57     VDELed!
    190  00ac
    191  00ac		       4c 0a f0 	      jmp	ScanRED	; 3	     @60
    192  00af
    193  00af							;------------------------------------------------------------------------------
    194  00af
    195  00af							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    196  00af
    197  00af		       f3 03	   ShapePlayer =	PLAYER_BLANK
    198  00af		       f3 03	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    199  00af		       f3 03	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    200  00af		       f3 03	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    201  00af
    202  00af		       f3 03	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    203  00af		       f3 03	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    204  00af
------- FILE playerColour.asm LEVEL 3 PASS 3
      0  00af					      include	"playerColour.asm"	; 1 * LINES_PER_CHAR bytes
      1  00af							;;    Sokoboo - a Sokoban implementation
      2  00af							;    using a generic tile-based display engine for the Atari 2600
      3  00af							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  00af							;
      5  00af							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  00af							;
      7  00af							;    Code related to the generic tile-based display engine was developed by
      8  00af							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  00af							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  00af							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  00af							;
     12  00af							;    Code related to music and sound effects uses the TIATracker music player
     13  00af							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  00af							;    directory for Apache licensing details.
     15  00af							;
     16  00af							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  00af							;    See the copyright notices in the License directory for a list of level
     18  00af							;    contributors.
     19  00af							;
     20  00af							;    Except where otherwise indicated, this software is released under the
     21  00af							;    following licensing arrangement...
     22  00af							;
     23  00af							;    This program is free software: you can redistribute it and/or modify
     24  00af							;    it under the terms of the GNU General Public License as published by
     25  00af							;    the Free Software Foundation, either version 3 of the License, or
     26  00af							;    (at your option) any later version.
     27  00af							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  00af
     29  00af							;    This program is distributed in the hope that it will be useful,
     30  00af							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  00af							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  00af							;    GNU General Public License for more details.
     33  00af
      0  00af					      OPTIONAL_PAGEBREAK	"SpriteColour", LINES_PER_CHAR*2
     10  00af					      LIST	ON
     35  00af
     36  00af		       00 10	   YELLOW_NTSC =	$10	; hair
     37  00af		       00 30	   ORANGE_NTSC =	$30	; skin
     38  00af		       00 40	   RED_NTSC   =	$40	; shirt
     39  00af		       00 a4	   BLUE_NTSC  =	$A4
     40  00af
     41  00af		       00 20	   YELLOW_PAL =	$20
     42  00af		       00 40	   ORANGE_PAL =	$40
     43  00af		       00 60	   RED_PAL    =	$60
     44  00af
     45  00af				   SpriteColour
     46  00af							; NTSC
     47  00af							;SpriteColourRED
     48  00af							;    .byte RED_NTSC|$6       ; 0 feet
     49  00af							;    .byte WHITE	      ; 3
     50  00af							;    .byte RED_NTSC|$4       ; 6
     51  00af							;    .byte RED_NTSC|$4       ; 9
     52  00af							;    .byte ORANGE_NTSC|$6    ;12
     53  00af							;    .byte ORANGE_NTSC|$8    ;15
     54  00af							;    .byte WHITE	      ;18
     55  00af							;SpriteColourGREEN
     56  00af							;    .byte RED_NTSC|$4       ; 1
     57  00af							;    .byte WHITE	      ; 4
     58  00af							;    .byte WHITE	      ; 7
     59  00af							;    .byte WHITE	      ;10
     60  00af							;    .byte ORANGE_NTSC|$8    ;13
     61  00af							;    .byte ORANGE_NTSC|$6    ;16
     62  00af							;    .byte WHITE	      ;19
     63  00af							;SpriteColourBLUE
     64  00af							;    .byte WHITE	      ; 2
     65  00af							;    .byte RED_NTSC|$4       ; 5
     66  00af							;    .byte RED_NTSC|$4       ; 8
     67  00af							;    .byte ORANGE_NTSC|$4    ;11 neck
     68  00af							;    .byte ORANGE_NTSC|$a    ;14
     69  00af							;    .byte YELLOW_NTSC|$c    ;17 hair
     70  00af							;    .byte WHITE	      ;20
     71  00af
     72  00af				   SpriteColourRED
     73  00af		       76		      .byte.b	$76
     74  00b0		       76		      .byte.b	$76
     75  00b1		       76		      .byte.b	$76
     76  00b2		       76		      .byte.b	$76
     77  00b3		       76		      .byte.b	$76
     78  00b4		       76		      .byte.b	$76
     79  00b5		       76		      .byte.b	$76
     80  00b6
     81  00b6							;  .byte #$1C;0
     82  00b6							;  .byte #$78;3
     83  00b6							;  .byte #$52;6
     84  00b6							;  .byte #$52;9
     85  00b6							;  .byte #$0C;12
     86  00b6							;  .byte #$4A;15
     87  00b6							;  .byte #$1A;18
     88  00b6				   SpriteColourGREEN
     89  00b6		       7a		      .byte.b	$7A
     90  00b7		       7a		      .byte.b	$7A
     91  00b8		       7a		      .byte.b	$7A
     92  00b9		       7a		      .byte.b	$7A
     93  00ba		       7a		      .byte.b	$7A
     94  00bb		       7a		      .byte.b	$7A
     95  00bc		       7a		      .byte.b	$7A
     96  00bd				   SpriteColourBLUE
     97  00bd		       2a		      .byte.b	$2A
     98  00be		       2a		      .byte.b	$2A
     99  00bf		       2a		      .byte.b	$2A
    100  00c0		       2a		      .byte.b	$2A
    101  00c1		       2a		      .byte.b	$2A
    102  00c2		       2a		      .byte.b	$2A
    103  00c3		       2a		      .byte.b	$2A
    104  00c4
    105  00c4					      REPEAT	21
    106  00c4		       26		      .byte.b	$20|$6	; 2
    105  00c4					      REPEND
    106  00c5		       26		      .byte.b	$20|$6	; 2
    105  00c5					      REPEND
    106  00c6		       26		      .byte.b	$20|$6	; 2
    105  00c6					      REPEND
    106  00c7		       26		      .byte.b	$20|$6	; 2
    105  00c7					      REPEND
    106  00c8		       26		      .byte.b	$20|$6	; 2
    105  00c8					      REPEND
    106  00c9		       26		      .byte.b	$20|$6	; 2
    105  00c9					      REPEND
    106  00ca		       26		      .byte.b	$20|$6	; 2
    105  00ca					      REPEND
    106  00cb		       26		      .byte.b	$20|$6	; 2
    105  00cb					      REPEND
    106  00cc		       26		      .byte.b	$20|$6	; 2
    105  00cc					      REPEND
    106  00cd		       26		      .byte.b	$20|$6	; 2
    105  00cd					      REPEND
    106  00ce		       26		      .byte.b	$20|$6	; 2
    105  00ce					      REPEND
    106  00cf		       26		      .byte.b	$20|$6	; 2
    105  00cf					      REPEND
    106  00d0		       26		      .byte.b	$20|$6	; 2
    105  00d0					      REPEND
    106  00d1		       26		      .byte.b	$20|$6	; 2
    105  00d1					      REPEND
    106  00d2		       26		      .byte.b	$20|$6	; 2
    105  00d2					      REPEND
    106  00d3		       26		      .byte.b	$20|$6	; 2
    105  00d3					      REPEND
    106  00d4		       26		      .byte.b	$20|$6	; 2
    105  00d4					      REPEND
    106  00d5		       26		      .byte.b	$20|$6	; 2
    105  00d5					      REPEND
    106  00d6		       26		      .byte.b	$20|$6	; 2
    105  00d6					      REPEND
    106  00d7		       26		      .byte.b	$20|$6	; 2
    105  00d7					      REPEND
    106  00d8		       26		      .byte.b	$20|$6	; 2
    107  00d9					      REPEND
    108  00d9
    109  00d9							; PAL
    110  00d9							;    .byte RED_PAL|$6	      ; 0 feet
    111  00d9							;    .byte WHITE	      ; 3
    112  00d9							;    .byte RED_PAL|$4	      ; 6
    113  00d9							;    .byte RED_PAL|$4	      ; 9
    114  00d9							;    .byte ORANGE_PAL|$4     ;12
    115  00d9							;    .byte ORANGE_PAL|$6     ;15
    116  00d9							;    .byte WHITE	      ;18
    117  00d9							;
    118  00d9							;    .byte RED_PAL|$4	      ; 1
    119  00d9							;    .byte WHITE	      ; 4
    120  00d9							;    .byte WHITE	      ; 7
    121  00d9							;    .byte WHITE	      ;10
    122  00d9							;    .byte ORANGE_PAL|$6     ;13
    123  00d9							;    .byte ORANGE_PAL|$4     ;16
    124  00d9							;    .byte WHITE	      ;19
    125  00d9							;
    126  00d9							;    .byte WHITE	      ; 2
    127  00d9							;    .byte RED_PAL|$4	      ; 5
    128  00d9							;    .byte RED_PAL|$4	      ; 8
    129  00d9							;    .byte ORANGE_PAL|$2     ;11 neck
    130  00d9							;    .byte ORANGE_PAL|$8     ;14
    131  00d9							;    .byte YELLOW_PAL|$c     ;17 hair
    132  00d9							;    .byte WHITE	      ;20
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    206  00d9
    207  00d9
    208  00d9							;------------------------------------------------------------------------------
    209  00d9
    210  00d9							;*** Ideas: ***
    211  00d9							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    212  00d9							;   13.5% on average), also unrolling would be more effective than now
    213  00d9							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    214  00d9							;   see EXPERIMENTAL)
    215  00d9							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    216  00d9							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    217  00d9							;   bidirectional linked list instead)
    218  00d9							; - calculate mirrored gfx data into RAM (saves ROM)
    219  00d9
    220  00d9							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    221  00d9							;currently:
    222  00d9							; 72%*539 (!unrolled)
    223  00d9							;+ 8%*304 (unrolled)
    224  00d9							;+20%*269 (unrolled)
    225  00d9							;--------
    226  00d9							;=   ~466.2 cycles on average
    227  00d9
    228  00d9							;alternative #1:
    229  00d9							; 72%*522 (unrolled)
    230  00d9							;+ 8%*352 (!unrolled)
    231  00d9							;+20%*307 (!unrolled)
    232  00d9							;--------
    233  00d9							;=   ~465.4 cycles on average
    234  00d9
    235  00d9
    236  00d9		       00 01	   MIRROR     =	1
    237  00d9		       00 80	   DIRECT     =	$80
    238  00d9
    239  00d9							;------------------------------------------------------------------------------
    240  00d9							; Here we don't draw into a buffer, but directly patch the kernel
    241  00d9							; VERY fast!
    242  00d9							;
    243  00d9							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    244  00d9							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    245  00d9
    246  00d9				   PF0Draw		; 25 cycles until here
    247  00d9
    248  00d9		       ae 84 02 	      ldx	INTIM	; 4
    249  00dc		       e0 05		      cpx	#SEGTIME_SCD_PF0	; 2
    250  00de		       90 72		      bcc	ExitDraw	; 2(3)=8
      0  00e0					      STRESS_TIME	SEGTIME_SCD_PF0	; ok!
      1  00e0				  -	      IF	TEST_SEGTIME_SCD_PF0 = 1
      2  00e0				  -
      3  00e0				  -
      4  00e0				  -
      5  00e0				  -
      6  00e0				  -
      7  00e0				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  00e0				  -	      bne	. - 7
      9  00e0					      ENDIF
    252  00e0
    253  00e0		       29 7f		      and	#<(~DIRECT)	; 2
    254  00e2		       aa		      tax		; 2 =	4
    255  00e3
    256  00e3		       98		      tya		; 2
    257  00e4		       0a		      asl		; 2	     no mirrored chars in PF0
    258  00e5		       a8		      tay		; 2 =	6
    259  00e6							;		  clc				  ; 2
    260  00e6
    261  00e6		       b9 bd fc 	      lda	CharacterDataVecHI,y	; 4
    262  00e9		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    263  00ec		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    264  00ef		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19
    265  00f2
    266  00f2		       b9 a9 fc 	      lda	CharacterDataVecLO,y	; 4
    267  00f5		       9d 0b f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    268  00f8		       69 06		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    269  00fa		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    270  00fd		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    271  00ff		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23
    272  0102
    273  0102		       4c 94 fa 	      jmp	DrawAnother	; 3 =	3
    274  0105
    275  0105							; Timing for PF0Draw
    276  0105							; 7+63 = 70
    277  0105							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    278  0105
    279  0105
    280  0105							;------------------------------------------------------------------------------
    281  0105							; Direct draw draws to PF0, which only has one active member of the character
    282  0105							; pair -- so it can be a direct copy.	Quicker still!
    283  0105
    284  0105				   DirectDraw		; 37 cycles until here
    285  0105
    286  0105							;ldy #16
    287  0105		       ad 84 02 	      lda	INTIM	; 4
    288  0108		       c9 08		      cmp	#SEGTIME_SCD_DIRECT	; 2
    289  010a		       90 46		      bcc	ExitDraw	; 2(3)=8
      0  010c					      STRESS_TIME	SEGTIME_SCD_DIRECT	; ok!
      1  010c				  -	      IF	TEST_SEGTIME_SCD_DIRECT = 1
      2  010c				  -
      3  010c				  -
      4  010c				  -
      5  010c				  -
      6  010c				  -
      7  010c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  010c				  -	      bne	. - 7
      9  010c					      ENDIF
    291  010c
    292  010c							; TIME REQUIRED FROM HERE (9/JAN)
    293  010c							; 16 + 20 + 20 + 2 + ( 7 * 32 ) - 1  + (42 SUFFIX)
    294  010c							; = 323 --> /64 = 5.04 USE 7
    295  010c
    296  010c		       b9 bd fc 	      lda	CharacterDataVecHI,y	; 4
    297  010f		       8d 3c f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    298  0112		       8d 42 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    299  0115		       8d 48 f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    300  0118
    301  0118		       b9 a9 fc 	      lda	CharacterDataVecLO,y	; 4
    302  011b		       8d 3b f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    303  011e		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    304  0120		       8d 41 f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    305  0123		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    306  0125		       8d 47 f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    307  0128
    308  0128		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    309  012b		       8d 3e f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    310  012e		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    311  0130		       8d 44 f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    312  0133		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    313  0135		       8d 4a f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    314  0138
    315  0138		       a0 06		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    316  013a				   TSFill3
    317  013a		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    318  013d		       99 85 f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    319  0140		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    320  0143		       99 85 f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    321  0146		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    322  0149		       99 85 f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    323  014c
    324  014c		       88		      dey		; 2
      0  014d					      CHECKPAGE_BPL	TSFill3	; 3(2)=5
      8  014d					      LIST	ON
      9  014d		       10 eb		      bpl	TSFill3
    326  014f
    327  014f		       4c 94 fa 	      jmp	DrawAnother	; 3
    328  0152
    329  0152							; Timing for DirectDraw
    330  0152							; 17+8+16+20+20+2+(32*7)-1+3 = 309 (was: 302 + 3)
    331  0152							; total: 37+309+6 = 352 => 352/64 + 1.4 = 6.90 = 7 (= SEGTIME_SLOWDRAW-5)
    332  0152
    333  0152				   ExitDraw
    334  0152		       60		      rts
    335  0153
    336  0153							;------------------------------------------------------------------------------
      0  0153					      DEFINE_SUBROUTINE	StealPart3	; 18 CYCLES HERE
      1  0153		       00 00	   BANK_StealPart3 =	_CURRENT_BANK
      2  0153					      SUBROUTINE
      3  0153				   StealPart3
    338  0153
    339  0153		       bd ee f1 	      lda	MOD10,x	; 4
    340  0156		       30 81		      bmi	PF0Draw	; 2/3
    341  0158		       4a		      lsr		; 2
    342  0159		       aa		      tax		; 2
    343  015a		       98		      tya		; 2
    344  015b		       2a		      rol		; 2	     allows for mirrored char = * | 1
    345  015c		       a8		      tay		; 2
    346  015d		       b0 a6		      bcs	DirectDraw	; 2(3)      when draw stack was built, bit 7 flags direct-drawn character
    347  015f							;	     => +19 starting DirectDraw BUT WHO CARES AS IT'S ONLY AFTER THAT COUNTS
    348  015f
    349  015f		       b9 bd fc 	      lda	CharacterDataVecHI,y	; 4
    350  0162		       10 38		      bpl	QuickDraw	; 2(3)=42   special-case blank characters for extra speed
    351  0164							;	     => 42 starting QuickDraw
    352  0164		       8d 8d f5 	      sta	SMEOR1+RAM_WRITE+2	; 4 =	4
    353  0167
    354  0167		       ad 84 02 	      lda	INTIM	; 4
    355  016a		       c9 0c		      cmp	#SEGTIME_SCD_SLOW	; 2
    356  016c		       90 e4		      bcc	ExitDraw	; 2(3)=8
      0  016e					      STRESS_TIME	SEGTIME_SCD_SLOW	; ok!
      1  016e				  -	      IF	TEST_SEGTIME_SCD_SLOW = 1
      2  016e				  -
      3  016e				  -
      4  016e				  -
      5  016e				  -
      6  016e				  -
      7  016e				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  016e				  -	      bne	. - 7
      9  016e					      ENDIF
    358  016e
    359  016e							; TIME REQUIRED FROM HERE (9/JAN)
    360  016e							; 8 + 16 + 8 + 2 + (21 * 23) -1 + (42 OVERHEAD WHEN RETURNING)
    361  016e							; = 558 --> /64 = 8.71 INTIM --> USE 10
    362  016e
    363  016e		       b9 a9 fc 	      lda	CharacterDataVecLO,y	; 4
    364  0171		       8d 8c f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    365  0174
    366  0174		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    367  0177		       8d 89 f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    368  017a		       8d 91 f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    369  017d		       8d 94 f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    370  0180
    371  0180		       bd e6 f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    372  0183		       8d 8f f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    373  0186
    374  0186		       a0 14	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2
    375  0188
    376  0188							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    377  0188							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    378  0188
    379  0188				   TSFill
    380  0188
    381  0188		       b9 85 f2    SMLOAD     lda	ScreenBitmap,y	; 4
    382  018b		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    383  018e		       29 00	   SMMASK     and	#0	; 2
    384  0190		       59 85 f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    385  0193		       99 85 f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    386  0196
    387  0196		       88		      dey		; 2
      0  0197					      CHECKPAGE_BPL	TSFill	; 3(2)=5
      8  0197					      LIST	ON
      9  0197		       10 ef		      bpl	TSFill
    389  0199
    390  0199		       4c 94 fa 	      jmp	DrawAnother	; 3
    391  019c
    392  019c							; Timing for "SLOW" draw
    393  019c							; 22+4+8+8+16+8+2+(21*24)-1+3 = 574 (was: 566 + 3)
    394  019c							; total: 37+574+6 = 617 => 628/64 + 1.4 = 11.04 = 12 (= SEGTIME_SLOWDRAW)
    395  019c
    396  019c
    397  019c							;------------------------------------------------------------------------------
    398  019c							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    399  019c							; existing character data, so can be special-cased from the normal character
    400  019c							; draw, saving roughly 230 cycles.
    401  019c
    402  019c				   QuickDraw		; 42 cycles until here
    403  019c
    404  019c		       ad 84 02 	      lda	INTIM	; 4
    405  019f		       c9 09		      cmp	#SEGTIME_SCD_QUICK	; 2	     SEE TIMING CALCS BELOW
    406  01a1		       90 af		      bcc	ExitDraw	; 2(3)=8
      0  01a3					      STRESS_TIME	SEGTIME_SCD_QUICK	; ok!
      1  01a3				  -	      IF	TEST_SEGTIME_SCD_QUICK = 1
      2  01a3				  -
      3  01a3				  -
      4  01a3				  -
      5  01a3				  -
      6  01a3				  -
      7  01a3				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  01a3				  -	      bne	. - 7
      9  01a3					      ENDIF
    408  01a3
    409  01a3							; TIME REQUIRED FROM HERE (9/JAN)
    410  01a3							;   = 32 + 4 + 2 + ( 7 * 38 ) - 1 + 3	+ (42 SUFFIX)
    411  01a3							;   = 348 --> /64 = 5.43. USE 7
    412  01a3
    413  01a3		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    414  01a6		       8d c3 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    415  01a9		       8d c6 f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    416  01ac		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    417  01ae		       8d ca f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    418  01b1		       8d cd f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    419  01b4		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    420  01b6		       8d d1 f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    421  01b9		       8d d4 f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32
    422  01bc
    423  01bc		       bc e4 f1 	      ldy	CharMask,x	; 4 =	4    masks out left or right
    424  01bf
    425  01bf		       a2 06		      ldx	#LINES_PER_CHAR/3 - 1	; 2 =	2
    426  01c1				   TSFill2
    427  01c1		       98		      tya		; 2
    428  01c2		       3d 85 f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    429  01c5		       9d 85 f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    430  01c8		       98		      tya		; 2
    431  01c9		       3d 85 f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    432  01cc		       9d 85 f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    433  01cf		       98		      tya		; 2
    434  01d0		       3d 85 f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    435  01d3		       9d 85 f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33
    436  01d6
    437  01d6		       ca		      dex		; 2
      0  01d7					      CHECKPAGE_BPL	TSFill2	; 3(2)=5
      8  01d7					      LIST	ON
      9  01d7		       10 e8		      bpl	TSFill2
    439  01d9
    440  01d9		       4c 94 fa 	      jmp	DrawAnother	; 3
    441  01dc
    442  01dc							; Timing for QuickDraw
    443  01dc							; 23+8+32+4+2+(7*38)-1+3 = 337 (was: 330 + 3)
    444  01dc							; total: 37+337+6 = 380 => 380/64 + 1.4 = 7.34 = 8 (= SEGTIME_SLOWDRAW-4)
    445  01dc
    446  01dc
    447  01dc							;------------------------------------------------------------------------------
    448  01dc
    449  01dc
    450  01dc				   CharAddressLO		;[abs char location % 10]
    451  01dc
    452  01dc							; Gives the absolute screen buffer address of the first line of the given character
    453  01dc							; Where character number is 0-9
    454  01dc
    455  01dc		       85		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    456  01dd		       85		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    457  01de		       9a		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    458  01df		       9a		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    459  01e0		       af		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    460  01e1		       af		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    461  01e2		       c4		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    462  01e3		       c4		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    463  01e4							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    464  01e4							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    465  01e4
    466  01e4				   CharMask		; [abs char location % 10]
    467  01e4
    468  01e4							; Gives the mask for any char of the screen (per row)
    469  01e4							; Note, this is hardwired to the screen format of 6 bytes/line
    470  01e4
    471  01e4		       0f		      .byte.b	$0F	; 1
    472  01e5		       f0		      .byte.b	$F0	; 2
    473  01e6				   CharMaskNeg
    474  01e6		       f0		      .byte.b	$F0	; 3/1
    475  01e7		       0f		      .byte.b	$0F	; 4/2
    476  01e8		       0f		      .byte.b	$0F	; 6/3
    477  01e9		       f0		      .byte.b	$F0	; 7/4
    478  01ea		       f0		      .byte.b	$F0	; 8/6
    479  01eb		       0f		      .byte.b	$0F	; 9/7
    480  01ec		       0f		      .byte.b	$0F	; -/8
    481  01ed		       f0		      .byte.b	$F0	; -/9
    482  01ee				   MOD10
    483  01ee					      REPEAT	SCREEN_LINES
    484  01ee							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  01ee							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  01ee		       80		      .byte.b	DIRECT
    487  01ef		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  01f3		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  01f4		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  01f4					      REPEND
    484  01f8							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  01f8							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  01f8		       80		      .byte.b	DIRECT
    487  01f9		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  01fd		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  01fe		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  01fe					      REPEND
    484  0202							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0202							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0202		       80		      .byte.b	DIRECT
    487  0203		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0207		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0208		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0208					      REPEND
    484  020c							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  020c							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  020c		       80		      .byte.b	DIRECT
    487  020d		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0211		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0212		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0212					      REPEND
    484  0216							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0216							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0216		       80		      .byte.b	DIRECT
    487  0217		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  021b		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  021c		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  021c					      REPEND
    484  0220							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0220							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0220		       80		      .byte.b	DIRECT
    487  0221		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0225		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0226		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0226					      REPEND
    484  022a							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  022a							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  022a		       80		      .byte.b	DIRECT
    487  022b		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  022f		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0230		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0230					      REPEND
    484  0234							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0234							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0234		       80		      .byte.b	DIRECT
    487  0235		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0239		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  023a		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    490  023e					      REPEND
    491  023e
    492  023e							;------------------------------------------------------------------------------
    493  023e
------- FILE characterset/target.asm LEVEL 3 PASS 3
      0  023e					      include	"characterset/target.asm"	; 2 * LINES_PER_CHAR + 2 bytes
      1  023e							;    Sokoboo - a Sokoban implementation
      2  023e							;    using a generic tile-based display engine for the Atari 2600
      3  023e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  023e							;
      5  023e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  023e							;
      7  023e							;    Code related to the generic tile-based display engine was developed by
      8  023e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  023e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  023e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  023e							;
     12  023e							;    Code related to music and sound effects uses the TIATracker music player
     13  023e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  023e							;    directory for Apache licensing details.
     15  023e							;
     16  023e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  023e							;    See the copyright notices in the License directory for a list of level
     18  023e							;    contributors.
     19  023e							;
     20  023e							;    Except where otherwise indicated, this software is released under the
     21  023e							;    following licensing arrangement...
     22  023e							;
     23  023e							;    This program is free software: you can redistribute it and/or modify
     24  023e							;    it under the terms of the GNU General Public License as published by
     25  023e							;    the Free Software Foundation, either version 3 of the License, or
     26  023e							;    (at your option) any later version.
     27  023e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  023e
     29  023e							;    This program is distributed in the hope that it will be useful,
     30  023e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  023e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  023e							;    GNU General Public License for more details.
     33  023e
     34  023e		       00 02	   TARGET_DEF =	2
     35  023e
     36  023e					      if	TARGET_DEF = 2
     37  023e
      0  023e					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET", LINES_PER_CHAR+1
     10  023e					      LIST	ON
     39  023e							;CHARACTERSHAPE_TARGET2_MIRRORED
     40  023e							;    .byte %00000000
     41  023e				   CHARACTERSHAPE_TARGET
     42  023e				   CHARACTERSHAPE_TARGET_MIRRORED
     43  023e		       00		      .byte.b	%00000000
     44  023f		       66		      .byte.b	%01100110
     45  0240		       66		      .byte.b	%01100110
     46  0241		       66		      .byte.b	%01100110
     47  0242		       66		      .byte.b	%01100110
     48  0243		       00		      .byte.b	%00000000
     49  0244		       00		      .byte.b	%00000000	;R
     50  0245		       00		      .byte.b	%00000000
     51  0246		       66		      .byte.b	%01100110
     52  0247		       66		      .byte.b	%01100110
     53  0248		       66		      .byte.b	%01100110
     54  0249		       66		      .byte.b	%01100110
     55  024a		       00		      .byte.b	%00000000
     56  024b		       00		      .byte.b	%00000000	;B
     57  024c		       00		      .byte.b	%00000000
     58  024d		       66		      .byte.b	%01100110
     59  024e		       66		      .byte.b	%01100110
     60  024f		       66		      .byte.b	%01100110
     61  0250		       66		      .byte.b	%01100110
     62  0251		       00		      .byte.b	%00000000
     63  0252							;    .byte %00000000 ;G
     64  0252
     65  0252							;--------------------------------------------------------------------------
     66  0252							;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_TARGET_MIRRORED", LINES_PER_CHAR+1
     67  0252
     68  0252				   CHARACTERSHAPE_TARGET2
     69  0252				   CHARACTERSHAPE_TARGET2_MIRRORED
     70  0252		       00 00 00 00*	      ds	21,0
     71  0267
      0  0267					      CHECKPAGE	CHARACTERSHAPE_TARGET2	; since we share one byte!
      8  0267					      LIST	ON
     73  0267
     74  0267					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    495  0267		       00 00 00 00*	      ds	30	; todo - fixes a graphical glitch so we have a page boundary issue somewhwere
    496  0285
    497  0285
      0  0285					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  0285					      LIST	ON
    499  0285
    500  0285		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,$0	; character bitmap row (10 chars wide)
    501  0285		       f2 85	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    502  0285		       f2 8c	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    503  0285		       f2 93	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    504  02d9
      0  02d9					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  02d9					      LIST	ON
    506  02d9
    507  02d9							;--------------------------------------------------------------------------
    508  02d9							;    CHARACTER_SET
    509  02d9
    510  02d9							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    511  02d9
    512  02d9
      0  02d9					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  02d9		       00 00	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  02d9					      SUBROUTINE
      3  02d9				   SelfModDrawPlayers
    514  02d9
    515  02d9							; Now the player(s) have animated, update the appropriate shape pointers
    516  02d9							; in the draw code.
    517  02d9
    518  02d9							; Sets the shapes to a blank player -- effectively erasing
    519  02d9		       a5 b1		      lda	LastSpriteY
    520  02db		       a2 03		      ldx	#<PLAYER_BLANK
    521  02dd		       20 ec f2 	      jsr	SetSelfModPlayer
    522  02e0
    523  02e0							; Now we've erased, we write the new shape
    524  02e0
    525  02e0							;		  sec
    526  02e0							;		  lda ManDrawX
    527  02e0							;		  sbc BoardScrollX
    528  02e0							;		  cmp #SCREEN_WIDTH			  ; disabled because we assume always onscreen
    529  02e0							;		  bcs NoMod				  ; skip if off visible screen
    530  02e0
    531  02e0		       a5 9d		      lda	ManDrawX
    532  02e2		       c9 0a		      cmp	#SCREEN_WIDTH	; disabled because we assume always onscreen
    533  02e4		       b0 1c		      bcs	NoMod	; skip if off visible screen
    534  02e6
    535  02e6							;lda LookingAround
    536  02e6							;bne NoMod
    537  02e6
    538  02e6		       a5 9e		      lda	ManDrawY
    539  02e8		       85 b1		      sta	LastSpriteY
    540  02ea
    541  02ea		       a6 a3		      ldx	ManAnimationFrameLO
    542  02ec
    543  02ec				   SetSelfModPlayer
    544  02ec		       c9 08		      cmp	#SCREEN_LINES	; only erase/draw if was/is onscreen
    545  02ee		       b0 12		      bcs	NoMod
    546  02f0		       69 00		      adc	#BANK_SCREENMARKII1
    547  02f2		       85 3e		      sta	SET_BANK_RAM	; switch old/new bank in
    548  02f4
    549  02f4		       8a		      txa
    550  02f5		       8d 20 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1	; lo of frame
    551  02f8		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    552  02fa		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    553  02fd		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    554  02ff		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    555  0302
    556  0302				   NoMod
    557  0302		       60		      rts
    558  0303
      0  0303					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  0303
      2  0303
      3  0303		       03 03	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $303 , FREE= $fd
      4  0303					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0303				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0303				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0303				  -	      ERR
      8  0303					      endif
    560  0303
------- FILE player.asm LEVEL 3 PASS 3
      0  0303					      include	"player.asm"	; 6 * LINES_PER_CHAR	       MUST FOLLOW DIRT.ASM as data is shared
      1  0303							;    Sokoboo - a Sokoban implementation
      2  0303							;    using a generic tile-based display engine for the Atari 2600
      3  0303							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0303							;
      5  0303							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0303							;
      7  0303							;    Code related to the generic tile-based display engine was developed by
      8  0303							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0303							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0303							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0303							;
     12  0303							;    Code related to music and sound effects uses the TIATracker music player
     13  0303							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0303							;    directory for Apache licensing details.
     15  0303							;
     16  0303							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0303							;    See the copyright notices in the License directory for a list of level
     18  0303							;    contributors.
     19  0303							;
     20  0303							;    Except where otherwise indicated, this software is released under the
     21  0303							;    following licensing arrangement...
     22  0303							;
     23  0303							;    This program is free software: you can redistribute it and/or modify
     24  0303							;    it under the terms of the GNU General Public License as published by
     25  0303							;    the Free Software Foundation, either version 3 of the License, or
     26  0303							;    (at your option) any later version.
     27  0303							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0303
     29  0303							;    This program is distributed in the hope that it will be useful,
     30  0303							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0303							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0303							;    GNU General Public License for more details.
     33  0303
     34  0303							;    OPTIONAL_PAGEBREAK "PLAYER", LINES_PER_CHAR * 6 - 1
     35  0303
     36  0303
     37  0303		       f3 03	   PLAYER_BLANK =	.
     38  0303					      REPEAT	LINES_PER_CHAR	;-1  ; as we have a "0" in the line below
     39  0303		       00		      .byte.b	0
     38  0303					      REPEND
     39  0304		       00		      .byte.b	0
     38  0304					      REPEND
     39  0305		       00		      .byte.b	0
     38  0305					      REPEND
     39  0306		       00		      .byte.b	0
     38  0306					      REPEND
     39  0307		       00		      .byte.b	0
     38  0307					      REPEND
     39  0308		       00		      .byte.b	0
     38  0308					      REPEND
     39  0309		       00		      .byte.b	0
     38  0309					      REPEND
     39  030a		       00		      .byte.b	0
     38  030a					      REPEND
     39  030b		       00		      .byte.b	0
     38  030b					      REPEND
     39  030c		       00		      .byte.b	0
     38  030c					      REPEND
     39  030d		       00		      .byte.b	0
     38  030d					      REPEND
     39  030e		       00		      .byte.b	0
     38  030e					      REPEND
     39  030f		       00		      .byte.b	0
     38  030f					      REPEND
     39  0310		       00		      .byte.b	0
     38  0310					      REPEND
     39  0311		       00		      .byte.b	0
     38  0311					      REPEND
     39  0312		       00		      .byte.b	0
     38  0312					      REPEND
     39  0313		       00		      .byte.b	0
     38  0313					      REPEND
     39  0314		       00		      .byte.b	0
     38  0314					      REPEND
     39  0315		       00		      .byte.b	0
     38  0315					      REPEND
     39  0316		       00		      .byte.b	0
     38  0316					      REPEND
     39  0317		       00		      .byte.b	0
     40  0318					      REPEND
     41  0318
     42  0318				   PLAYER_RIGHT0
     43  0318
     44  0318					      if	1
     45  0318		       18		      .byte.b	%00011000	;20
     46  0319		       18		      .byte.b	%00011000	;20
     47  031a		       7e		      .byte.b	%01111110	;20
     48  031b		       7e		      .byte.b	%01111110	;20
     49  031c		       7e		      .byte.b	%01111110	;20
     50  031d		       18		      .byte.b	%00011000	;20
     51  031e		       18		      .byte.b	%00011000	;20
     52  031f
     53  031f		       18		      .byte.b	%00011000	;20
     54  0320		       18		      .byte.b	%00011000	;20
     55  0321		       7e		      .byte.b	%01111110	;20
     56  0322		       7e		      .byte.b	%01111110	;20
     57  0323		       7e		      .byte.b	%01111110	;20
     58  0324		       18		      .byte.b	%00011000	;20
     59  0325		       18		      .byte.b	%00011000	;20
     60  0326
     61  0326		       18		      .byte.b	%00011000	;20
     62  0327		       18		      .byte.b	%00011000	;20
     63  0328		       7e		      .byte.b	%01111110	;20
     64  0329		       7e		      .byte.b	%01111110	;20
     65  032a		       7e		      .byte.b	%01111110	;20
     66  032b		       18		      .byte.b	%00011000	;20
     67  032c		       18		      .byte.b	%00011000	;20
     68  032d
     69  032d				  -	      else
     70  032d				  -			;push
     71  032d				  -	      .byte	#%01110000	;$1C 0
     72  032d				  -	      .byte	#%01110000	;$78 3
     73  032d				  -	      .byte	#%00010000	;$52 6
     74  032d				  -	      .byte	#%00111100	;$52 9
     75  032d				  -	      .byte	#%00011001	;$0C 12
     76  032d				  -	      .byte	#%00001100	;$4A 15
     77  032d				  -	      .byte	#%00001111	;$1A18
     78  032d				  -
     79  032d				  -	      .byte	#%10100000	;$1C 1
     80  032d				  -	      .byte	#%00111000	;$78 4
     81  032d				  -	      .byte	#%00111000	;$52 7
     82  032d				  -	      .byte	#%00111100	;$56 10
     83  032d				  -	      .byte	#%00001000	;$4A 13
     84  032d				  -	      .byte	#%00001100	;$4A 16
     85  032d				  -	      .byte	#%00001100	;$1C 19
     86  032d				  -
     87  032d				  -	      .byte	#%11010000	;$78 2
     88  032d				  -	      .byte	#%00101000	;$78 5
     89  032d				  -	      .byte	#%00111000	;$52 8
     90  032d				  -	      .byte	#%00011111	;$56 11
     91  032d				  -	      .byte	#%00001000	;$4A 14
     92  032d				  -	      .byte	#%00011010	;$4A 17
     93  032d				  -	      .byte	#%00001100	;$1C 20
     94  032d				  -
     95  032d					      endif
     96  032d
     97  032d				  -	      IF	0
     98  032d				  -			;---Graphics Data from PlayerPal 2600---
     99  032d				  -
    100  032d				  -Frame0
    101  032d				  -	      .byte	#%01110011	;$1C
    102  032d				  -	      .byte	#%00100110	;$1C
    103  032d				  -	      .byte	#%00110100	;$78
    104  032d				  -	      .byte	#%00010100	;$78
    105  032d				  -	      .byte	#%00011100	;$78
    106  032d				  -	      .byte	#%00001000	;$78
    107  032d				  -	      .byte	#%00010000	;$52
    108  032d				  -	      .byte	#%00111000	;$52
    109  032d				  -	      .byte	#%00111000	;$52
    110  032d				  -	      .byte	#%10111000	;$52
    111  032d				  -	      .byte	#%01111000	;$56
    112  032d				  -	      .byte	#%00110000	;$56
    113  032d				  -	      .byte	#%00111100	;$0C
    114  032d				  -	      .byte	#%00110010	;$4A
    115  032d				  -	      .byte	#%00010000	;$4A
    116  032d				  -	      .byte	#%00011000	;$4A
    117  032d				  -	      .byte	#%00011000	;$4A
    118  032d				  -	      .byte	#%00110100	;$4A
    119  032d				  -	      .byte	#%00011110	;$1A
    120  032d				  -	      .byte	#%00011000	;$1C
    121  032d				  -	      .byte	#%00011000	;$1C
    122  032d				  -Frame1
    123  032d				  -	      .byte	#%00110110	;$1C
    124  032d				  -	      .byte	#%00100100	;$1C
    125  032d				  -	      .byte	#%00010100	;$78
    126  032d				  -	      .byte	#%00010100	;$78
    127  032d				  -	      .byte	#%00011100	;$78
    128  032d				  -	      .byte	#%00001000	;$78
    129  032d				  -	      .byte	#%00010000	;$52
    130  032d				  -	      .byte	#%00111000	;$52
    131  032d				  -	      .byte	#%00011000	;$52
    132  032d				  -	      .byte	#%01111000	;$52
    133  032d				  -	      .byte	#%00111000	;$56
    134  032d				  -	      .byte	#%00110110	;$56
    135  032d				  -	      .byte	#%00111100	;$0C
    136  032d				  -	      .byte	#%00010000	;$4A
    137  032d				  -	      .byte	#%00010000	;$4A
    138  032d				  -	      .byte	#%00011000	;$4A
    139  032d				  -	      .byte	#%00011000	;$4A
    140  032d				  -	      .byte	#%00110100	;$4A
    141  032d				  -	      .byte	#%00011110	;$1A
    142  032d				  -	      .byte	#%00011000	;$1C
    143  032d				  -	      .byte	#%00011000	;$1C
    144  032d				  -Frame2
    145  032d				  -	      .byte	#%00011000	;$1C
    146  032d				  -	      .byte	#%00110000	;$1C
    147  032d				  -	      .byte	#%01010000	;$78
    148  032d				  -	      .byte	#%00111000	;$78
    149  032d				  -	      .byte	#%00011000	;$78
    150  032d				  -	      .byte	#%00001000	;$78
    151  032d				  -	      .byte	#%00010000	;$52
    152  032d				  -	      .byte	#%00111000	;$52
    153  032d				  -	      .byte	#%00111000	;$52
    154  032d				  -	      .byte	#%00111100	;$52
    155  032d				  -	      .byte	#%00110100	;$56
    156  032d				  -	      .byte	#%00111100	;$56
    157  032d				  -	      .byte	#%00111000	;$0C
    158  032d				  -	      .byte	#%00010000	;$4A
    159  032d				  -	      .byte	#%00010000	;$4A
    160  032d				  -	      .byte	#%00011000	;$4A
    161  032d				  -	      .byte	#%00011000	;$4A
    162  032d				  -	      .byte	#%00110100	;$4A
    163  032d				  -	      .byte	#%00011110	;$1A
    164  032d				  -	      .byte	#%00011000	;$1C
    165  032d				  -	      .byte	#%00011000	;$1C
    166  032d				  -Frame3
    167  032d				  -	      .byte	#%01110000	;$1C
    168  032d				  -	      .byte	#%10100000	;$1C
    169  032d				  -	      .byte	#%11010000	;$78
    170  032d				  -	      .byte	#%01110000	;$78
    171  032d				  -	      .byte	#%00111000	;$78
    172  032d				  -	      .byte	#%00101000	;$78
    173  032d				  -	      .byte	#%00010000	;$52
    174  032d				  -	      .byte	#%00111000	;$52
    175  032d				  -	      .byte	#%00111000	;$52
    176  032d				  -	      .byte	#%00111100	;$52
    177  032d				  -	      .byte	#%00111100	;$56
    178  032d				  -	      .byte	#%00011111	;$56
    179  032d				  -	      .byte	#%00011001	;$0C
    180  032d				  -	      .byte	#%00001000	;$4A
    181  032d				  -	      .byte	#%00001000	;$4A
    182  032d				  -	      .byte	#%00001100	;$4A
    183  032d				  -	      .byte	#%00001100	;$4A
    184  032d				  -	      .byte	#%00011010	;$4A
    185  032d				  -	      .byte	#%00001111	;$1A
    186  032d				  -	      .byte	#%00001100	;$1C
    187  032d				  -	      .byte	#%00001100	;$1C
    188  032d				  -Frame4
    189  032d				  -	      .byte	#%00110110	;$1C
    190  032d				  -	      .byte	#%00010100	;$1C
    191  032d				  -	      .byte	#%00010100	;$78
    192  032d				  -	      .byte	#%00010100	;$78
    193  032d				  -	      .byte	#%00011100	;$78
    194  032d				  -	      .byte	#%00001100	;$78
    195  032d				  -	      .byte	#%00010000	;$52
    196  032d				  -	      .byte	#%00011000	;$52
    197  032d				  -	      .byte	#%00011100	;$52
    198  032d				  -	      .byte	#%00111100	;$52
    199  032d				  -	      .byte	#%00111100	;$56
    200  032d				  -	      .byte	#%00111100	;$56
    201  032d				  -	      .byte	#%00111110	;$0C
    202  032d				  -	      .byte	#%01011010	;$4A
    203  032d				  -	      .byte	#%10010001	;$4A
    204  032d				  -	      .byte	#%10011001	;$4A
    205  032d				  -	      .byte	#%00011000	;$4A
    206  032d				  -	      .byte	#%00011000	;$4A
    207  032d				  -	      .byte	#%00011100	;$1A
    208  032d				  -	      .byte	#%00011000	;$1C
    209  032d				  -	      .byte	#%00010000	;$1C
    210  032d				  -Frame5
    211  032d				  -	      .byte	#%00110110	;$1C
    212  032d				  -	      .byte	#%00010100	;$1C
    213  032d				  -	      .byte	#%00010100	;$78
    214  032d				  -	      .byte	#%00010100	;$78
    215  032d				  -	      .byte	#%00011100	;$78
    216  032d				  -	      .byte	#%01001101	;$78
    217  032d				  -	      .byte	#%01010001	;$52
    218  032d				  -	      .byte	#%01011011	;$52
    219  032d				  -	      .byte	#%01011110	;$52
    220  032d				  -	      .byte	#%00111100	;$52
    221  032d				  -	      .byte	#%00111100	;$56
    222  032d				  -	      .byte	#%00011100	;$56
    223  032d				  -	      .byte	#%00011000	;$0C
    224  032d				  -	      .byte	#%00011000	;$4A
    225  032d				  -	      .byte	#%00011000	;$4A
    226  032d				  -	      .byte	#%00111000	;$4A
    227  032d				  -	      .byte	#%00001000	;$4A
    228  032d				  -	      .byte	#%00000000	;$4A
    229  032d				  -	      .byte	#%00000000	;$1A
    230  032d				  -	      .byte	#%00000000	;$1C
    231  032d				  -	      .byte	#%00000000	;$1C
    232  032d				  -			;---End Graphics Data---
    233  032d				  -
    234  032d				  -
    235  032d				  -			;---Color Data from PlayerPal 2600---
    236  032d				  -
    237  032d				  -ColorFrame0
    238  032d				  -	      .byte	#$1C	;
    239  032d				  -	      .byte	#$1C	;
    240  032d				  -	      .byte	#$78	;
    241  032d				  -	      .byte	#$78	;
    242  032d				  -	      .byte	#$78	;
    243  032d				  -	      .byte	#$78	;
    244  032d				  -	      .byte	#$52	;
    245  032d				  -	      .byte	#$52	;
    246  032d				  -	      .byte	#$52	;
    247  032d				  -	      .byte	#$52	;
    248  032d				  -	      .byte	#$56	;
    249  032d				  -	      .byte	#$56	;
    250  032d				  -	      .byte	#$0C	;
    251  032d				  -	      .byte	#$4A	;
    252  032d				  -	      .byte	#$4A	;
    253  032d				  -	      .byte	#$4A	;
    254  032d				  -	      .byte	#$4A	;
    255  032d				  -	      .byte	#$4A	;
    256  032d				  -	      .byte	#$1A	;
    257  032d				  -	      .byte	#$1C	;
    258  032d				  -	      .byte	#$1C	;
    259  032d				  -ColorFrame1
    260  032d				  -	      .byte	#$1C	;
    261  032d				  -	      .byte	#$1C	;
    262  032d				  -	      .byte	#$78	;
    263  032d				  -	      .byte	#$78	;
    264  032d				  -	      .byte	#$78	;
    265  032d				  -	      .byte	#$78	;
    266  032d				  -	      .byte	#$52	;
    267  032d				  -	      .byte	#$52	;
    268  032d				  -	      .byte	#$52	;
    269  032d				  -	      .byte	#$52	;
    270  032d				  -	      .byte	#$56	;
    271  032d				  -	      .byte	#$56	;
    272  032d				  -	      .byte	#$0C	;
    273  032d				  -	      .byte	#$4A	;
    274  032d				  -	      .byte	#$4A	;
    275  032d				  -	      .byte	#$4A	;
    276  032d				  -	      .byte	#$4A	;
    277  032d				  -	      .byte	#$4A	;
    278  032d				  -	      .byte	#$1A	;
    279  032d				  -	      .byte	#$1C	;
    280  032d				  -	      .byte	#$1C	;
    281  032d				  -ColorFrame2
    282  032d				  -	      .byte	#$1C	;
    283  032d				  -	      .byte	#$1C	;
    284  032d				  -	      .byte	#$78	;
    285  032d				  -	      .byte	#$78	;
    286  032d				  -	      .byte	#$78	;
    287  032d				  -	      .byte	#$78	;
    288  032d				  -	      .byte	#$52	;
    289  032d				  -	      .byte	#$52	;
    290  032d				  -	      .byte	#$52	;
    291  032d				  -	      .byte	#$52	;
    292  032d				  -	      .byte	#$56	;
    293  032d				  -	      .byte	#$56	;
    294  032d				  -	      .byte	#$0C	;
    295  032d				  -	      .byte	#$4A	;
    296  032d				  -	      .byte	#$4A	;
    297  032d				  -	      .byte	#$4A	;
    298  032d				  -	      .byte	#$4A	;
    299  032d				  -	      .byte	#$4A	;
    300  032d				  -	      .byte	#$1A	;
    301  032d				  -	      .byte	#$1C	;
    302  032d				  -	      .byte	#$1C	;
    303  032d				  -ColorFrame3
    304  032d				  -	      .byte	#$1C	;
    305  032d				  -	      .byte	#$1C	;
    306  032d				  -	      .byte	#$78	;
    307  032d				  -	      .byte	#$78	;
    308  032d				  -	      .byte	#$78	;
    309  032d				  -	      .byte	#$78	;
    310  032d				  -	      .byte	#$52	;
    311  032d				  -	      .byte	#$52	;
    312  032d				  -	      .byte	#$52	;
    313  032d				  -	      .byte	#$52	;
    314  032d				  -	      .byte	#$56	;
    315  032d				  -	      .byte	#$56	;
    316  032d				  -	      .byte	#$0C	;
    317  032d				  -	      .byte	#$4A	;
    318  032d				  -	      .byte	#$4A	;
    319  032d				  -	      .byte	#$4A	;
    320  032d				  -	      .byte	#$4A	;
    321  032d				  -	      .byte	#$4A	;
    322  032d				  -	      .byte	#$1A	;
    323  032d				  -	      .byte	#$1C	;
    324  032d				  -	      .byte	#$1C	;
    325  032d				  -ColorFrame4
    326  032d				  -	      .byte	#$1C	;
    327  032d				  -	      .byte	#$1C	;
    328  032d				  -	      .byte	#$78	;
    329  032d				  -	      .byte	#$78	;
    330  032d				  -	      .byte	#$78	;
    331  032d				  -	      .byte	#$78	;
    332  032d				  -	      .byte	#$52	;
    333  032d				  -	      .byte	#$52	;
    334  032d				  -	      .byte	#$52	;
    335  032d				  -	      .byte	#$52	;
    336  032d				  -	      .byte	#$56	;
    337  032d				  -	      .byte	#$56	;
    338  032d				  -	      .byte	#$0C	;
    339  032d				  -	      .byte	#$4A	;
    340  032d				  -	      .byte	#$4A	;
    341  032d				  -	      .byte	#$4A	;
    342  032d				  -	      .byte	#$4A	;
    343  032d				  -	      .byte	#$4A	;
    344  032d				  -	      .byte	#$1A	;
    345  032d				  -	      .byte	#$1C	;
    346  032d				  -	      .byte	#$1C	;
    347  032d				  -ColorFrame5
    348  032d				  -	      .byte	#$1C	;
    349  032d				  -	      .byte	#$1C	;
    350  032d				  -	      .byte	#$78	;
    351  032d				  -	      .byte	#$78	;
    352  032d				  -	      .byte	#$78	;
    353  032d				  -	      .byte	#$78	;
    354  032d				  -	      .byte	#$52	;
    355  032d				  -	      .byte	#$52	;
    356  032d				  -	      .byte	#$52	;
    357  032d				  -	      .byte	#$52	;
    358  032d				  -	      .byte	#$56	;
    359  032d				  -	      .byte	#$56	;
    360  032d				  -	      .byte	#$0C	;
    361  032d				  -	      .byte	#$4A	;
    362  032d				  -	      .byte	#$4A	;
    363  032d				  -	      .byte	#$4A	;
    364  032d				  -	      .byte	#$4A	;
    365  032d				  -	      .byte	#$4A	;
    366  032d				  -	      .byte	#$1A	;
    367  032d				  -	      .byte	#$1C	;
    368  032d				  -	      .byte	#$1C	;
    369  032d				  -			;---End Color Data---
    370  032d					      ENDIF
    371  032d
    372  032d
    373  032d							;.byte %00011000  ;  XXX   ; 0
    374  032d							;.byte %00111100  ;XXXXXX  ; 1
    375  032d							;.byte %01110100  ;XXXX X  ; 2 etc.
    376  032d							;.byte %01111100  ;XXXXXX  ; 3
    377  032d							;.byte %00111000  ;XXXXX   ;4
    378  032d							;.byte %01111100  ; XXXXX  ;5
    379  032d							;.byte %00111000  ;  XXX   ;6
    380  032d							;.byte %11111000  ;XXXXX   ;7
    381  032d							;.byte %11111100  ;XXXXXX  ;8
    382  032d							;.byte %11111100  ;XXXXXX  ;9 etc.
    383  032d							;.byte %10000100  ;X	 X  ;10
    384  032d							;.byte %11111100  ;XXXXXX  ;11
    385  032d							;.byte %00001100  ;	XX  ;12
    386  032d							;.byte %01111100  ; XXXXX  ;13
    387  032d							;.byte %01111100  ; XXXXX  ;14
    388  032d							;.byte %01111000  ; XXXX   ;15
    389  032d							;.byte %01111000  ; XXXX   ;16 etc.
    390  032d							;.byte %11111000  ;XXXXX   ;17
    391  032d							;.byte %11101100  ;XXX XX  ;18
    392  032d							;.byte %10111100  ;X XXXX  ;19
    393  032d							;.byte %11001100  ;XX	XX   20
    394  032d
    395  032d							;---Graphics Data from PlayerPal 2600---
    396  032d
    397  032d				   PLAYER_RIGHT1
    398  032d				   PLAYER_STAND
    399  032d				   PLAYER_BLINK
    400  032d				   PLAYER_TAP0
    401  032d				   PLAYER_TAP1
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE characterset/filler.asm LEVEL 3 PASS 3
      0  032d					      include	"characterset/filler.asm"	; 2 * LINES_PER_CHAR bytes
      1  032d							;    Sokoboo - a Sokoban implementation
      2  032d							;    using a generic tile-based display engine for the Atari 2600
      3  032d							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  032d							;
      5  032d							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  032d							;
      7  032d							;    Code related to the generic tile-based display engine was developed by
      8  032d							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  032d							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  032d							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  032d							;
     12  032d							;    Code related to music and sound effects uses the TIATracker music player
     13  032d							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  032d							;    directory for Apache licensing details.
     15  032d							;
     16  032d							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  032d							;    See the copyright notices in the License directory for a list of level
     18  032d							;    contributors.
     19  032d							;
     20  032d							;    Except where otherwise indicated, this software is released under the
     21  032d							;    following licensing arrangement...
     22  032d							;
     23  032d							;    This program is free software: you can redistribute it and/or modify
     24  032d							;    it under the terms of the GNU General Public License as published by
     25  032d							;    the Free Software Foundation, either version 3 of the License, or
     26  032d							;    (at your option) any later version.
     27  032d							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  032d
     29  032d							;    This program is distributed in the hope that it will be useful,
     30  032d							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  032d							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  032d							;    GNU General Public License for more details.
     33  032d
      0  032d					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  032d					      LIST	ON
     35  032d				   CHARACTERSHAPE_SOIL
     36  032d				   CHARACTERSHAPE_SOIL_MIRRORED
     37  032d		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
     38  0334		       ff		      .byte.b	%11111111
     39  0335		       ff		      .byte.b	%11111111
     40  0336		       ff		      .byte.b	%11111111
     41  0337		       ff		      .byte.b	%11111111
     42  0338		       ff		      .byte.b	%11111111
     43  0339		       ff		      .byte.b	%11111111
     44  033a		       ff		      .byte.b	%11111111
     45  033b		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    563  0342							;------------------------------------------------------------------------------
    564  0342
    565  0342							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    566  0342
    567  0342							;------------------------------------------------------------------------------
    568  0342
    569  0342
    570  0342
    571  0342							;	 CHECK_HALF_BANK_SIZE "ROM_SHADOW_OF_RAMBANK_CODE"
    572  0342
    573  0342
    574  0342							; Here there's another 1K of usable ROM....
    575  0342							; BUT!!! WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    576  0342
    577  0342							;-----------------------------------------------------------
    578  0342							; Stella 3E autodetect signature, can live anywhere
    579  0342		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
    580  0346							;-----------------------------------------------------------
    581  0346
      0  0346					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  0346		       03 46	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $346 , FREE= $4ba
      2  0346					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0346				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0346				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0346				  -	      ERR
      6  0346					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 3
      0  0346					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  0346							;    Sokoboo - a Sokoban implementation
      2  0346							;    using a generic tile-based display engine for the Atari 2600
      3  0346							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0346							;
      5  0346							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0346							;
      7  0346							;    Code related to the generic tile-based display engine was developed by
      8  0346							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0346							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0346							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0346							;
     12  0346							;    Code related to music and sound effects uses the TIATracker music player
     13  0346							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0346							;    directory for Apache licensing details.
     15  0346							;
     16  0346							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0346							;    See the copyright notices in the License directory for a list of level
     18  0346							;    contributors.
     19  0346							;
     20  0346							;    Except where otherwise indicated, this software is released under the
     21  0346							;    following licensing arrangement...
     22  0346							;
     23  0346							;    This program is free software: you can redistribute it and/or modify
     24  0346							;    it under the terms of the GNU General Public License as published by
     25  0346							;    the Free Software Foundation, either version 3 of the License, or
     26  0346							;    (at your option) any later version.
     27  0346							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0346
     29  0346							;    This program is distributed in the hope that it will be useful,
     30  0346							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0346							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0346							;    GNU General Public License for more details.
     33  0346
     34  0346							;------------------------------------------------------------------------------
     35  0346							;##############################################################################
     36  0346							;------------------------------------------------------------------------------
     37  0346
      0  0346					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  0a50 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
     39  0800
     40  0800							; NOTE: Access to these buffers must NOT overlap pages...
     41  0800							; NOTE: We get auto-initialisation of these variables from the ROM values by
     42  0800							; copying the whole bank into the RAM bank.  Neato.
     43  0800
     44  0800		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     45  0800
     46  0800
     47  0800
     48  0800		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     49  0850		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     50  08a0
      0  08a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  08a0					      LIST	ON
     52  08a0
     53  08a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     54  08a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     55  08a0							; what we want to happen!
     56  08a0
     57  08a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
     58  08f0
     59  08f0
     60  08f0							;------------------------------------------------------------------------------
     61  08f0							; RAM-BASED SUBROUTINES...
     62  08f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     63  08f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     64  08f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     65  08f0							; the RAM-based routine.
     66  08f0
     67  08f0
     68  08f0
     69  08f0							;------------------------------------------------------------------------------
     70  08f0
     71  08f0
     72  08f0		       60	   waitForDraw rts		; 6
     73  08f1
     74  08f1							;------------------------------------------------------------------------------
     75  08f1
      0  08f1					      DEFINE_SUBROUTINE	DrawStackUpdate	;=196 (+13 for fall-through bit)
      1  08f1		       00 01	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  08f1					      SUBROUTINE
      3  08f1				   DrawStackUpdate
     77  08f1
     78  08f1							; Parse the DrawFlags buffer and create a draw stack
     79  08f1							; so that the actual draw doesn't need to scan for characters to draw.
     80  08f1
     81  08f1
     82  08f1							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     83  08f1							; symptoms would be missing parts of screen when scrolling.
     84  08f1							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     85  08f1							; disabled for sokoban 27/7/2019
     86  08f1
     87  08f1		       a5 84		      lda	DrawStackPointer
     88  08f3							;bpl waitForDraw		  ; Wait for previously not-drawn characters to be drawn
     89  08f3
     90  08f3		       ad 84 02 	      lda	INTIM	;4
     91  08f6		       c9 05		      cmp	#SEGTIME_BDS	;2
     92  08f8		       90 f6		      bcc	waitForDraw	;2/3
      0  08fa					      STRESS_TIME	SEGTIME_BDS
      1  08fa				  -	      IF	TEST_SEGTIME_BDS = 1
      2  08fa				  -
      3  08fa				  -
      4  08fa				  -
      5  08fa				  -
      6  08fa				  -
      7  08fa				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  08fa				  -	      bne	. - 7
      9  08fa					      ENDIF
     94  08fa
     95  08fa
     96  08fa							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
     97  08fa							; moving into the middle of dirt, or BOXs when pushing, or TARGETs when grabbing.
     98  08fa
     99  08fa							;		  sec		 already set
    100  08fa		       a5 9c		      lda	ManY	;3
    101  08fc		       e5 96		      sbc	BoardScrollY	;3
    102  08fe		       85 9e		      sta	ManDrawY	;3
    103  0900
    104  0900		       38		      sec		;2
    105  0901		       a5 9b		      lda	ManX	;3
    106  0903		       e5 97		      sbc	BoardScrollX	;3
    107  0905		       c9 0a		      cmp	#SCREEN_WIDTH	;2
    108  0907		       90 06		      bcc	onsc	;2/3
    109  0909
    110  0909							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
    111  0909							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
    112  0909							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
    113  0909
    114  0909		       a9 08		      lda	#SCREEN_LINES	;2
    115  090b		       85 9e		      sta	ManDrawY	;3
    116  090d		       d0 02		      bne	skipsc	;3		  unconditional
    117  090f
    118  090f		       85 9d	   onsc       sta	ManDrawX	;3
    119  0911				   skipsc
    120  0911
    121  0911		       e6 b2		      inc	timer	;5
    122  0913		       4c d1 fc 	      jmp	AnimateCharReplacements2	;3+139
    123  0916				   retAnim
    124  0916
    125  0916		       e6 89		      inc	ScreenDrawPhase	;5
    126  0918
    127  0918		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
    128  091a		       85 ce		      sta	DSL	;3
    129  091c
    130  091c							; fall through...
    131  091c							;---------------------------------------------------------------------------
    132  091c
      0  091c					      DEFINE_SUBROUTINE	DrawIntoStack
      1  091c		       00 01	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  091c					      SUBROUTINE
      3  091c				   DrawIntoStack
    134  091c
    135  091c		       ba		      tsx		;2
    136  091d		       86 da		      stx	save_SP	;3
    137  091f		       a6 84		      ldx	DrawStackPointer	;3
    138  0921		       9a		      txs		;2 = 10
    139  0922
    140  0922		       a4 ce		      ldy	DSL	;3
    141  0924
    142  0924							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    143  0924							; + exit cost which is +10 cycles
    144  0924							; TJ: I count 63
    145  0924							;   + 14 for the wtf2 exit
    146  0924							;   + 22 for the end of loop exit
    147  0924
    148  0924							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    149  0924							; For 80 iterations that is 640 cycles, just for checking INTIM
    150  0924							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    151  0924							; it also will require a lot of CPU time for updating the screen data.
    152  0924
    153  0924							; TODO: optimize!
    154  0924							;
    155  0924							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    156  0924							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    157  0924							; costs some detection time here, but saves ~240 cylces for drawing the two
    158  0924
    159  0924		       ad 84 02    .loopDrawStack lda	INTIM	;4
    160  0927		       c9 05		      cmp	#SEGTIME_DSL	;2
    161  0929		       90 4d		      bcc	.exitDrawStack	;2/3= 8/9
      0  092b					      STRESS_TIME	SEGTIME_DSL
      1  092b				  -	      IF	TEST_SEGTIME_DSL = 1
      2  092b				  -
      3  092b				  -
      4  092b				  -
      5  092b				  -
      6  092b				  -
      7  092b				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  092b				  -	      bne	. - 7
      9  092b					      ENDIF
    163  092b
    164  092b		       b9 50 f0 	      lda	DrawFlag,y	;4
    165  092e		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    166  0931		       f0 16		      beq	.next0	;2/3=10/11	 yes, so we don't draw anything
    167  0933
    168  0933							; Character is NOT the same. Figure out how it should be drawn.
    169  0933							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    170  0933							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    171  0933							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    172  0933
    173  0933		       be 81 f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    174  0936		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    175  0939		       d0 05		      bne	.notPaired0	;2/3=10/11
    176  093b
    177  093b							; Consider two 'paired' characters. Either A:A or A:B
    178  093b							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    179  093b							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    180  093b							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    181  093b							; on the comparison, so the character will not be added to the draw stack. So our first character will
    182  093b							; do the job of drawing BOTH characters to the screen.
    183  093b
    184  093b		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    185  093e		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    186  0940
    187  0940							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    188  0940							; the last write(below) marks the character as to be direct-drawn.
    189  0940
    190  0940		       99 a0 f4    .notPaired0 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    191  0943
    192  0943							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    193  0943
    194  0943		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    195  0944		       98		      tya		;2
    196  0945		       ba		      tsx		;2		 << now X holds drawstackpointer
    197  0946		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    198  0949
    199  0949		       88	   .next0     dey		;2
    200  094a		       30 21		      bmi	.finishedDrawStack	;2/3= 4/5
    201  094c
    202  094c							; unrolled 2nd loop:
    203  094c		       b9 50 f0 	      lda	DrawFlag,y	;4
    204  094f		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    205  0952		       f0 16		      beq	.next1	;2/3=10/11	 yes, so we don't draw anything
    206  0954
    207  0954		       be 81 f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    208  0957		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    209  095a		       d0 05		      bne	.notPaired1	;2/3=10/11
    210  095c
    211  095c		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    212  095f		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    213  0961
    214  0961		       99 a0 f4    .notPaired1 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    215  0964
    216  0964		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    217  0965		       98		      tya		;2
    218  0966		       ba		      tsx		;2
    219  0967		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    220  096a
    221  096a		       88	   .next1     dey		;2
    222  096b		       10 b7		      bpl	.loopDrawStack	;2/3= 4/5
    223  096d							;worst case: 111-4
    224  096d							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    225  096d
    226  096d							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    227  096d
    228  096d				   .finishedDrawStack
    229  096d		       e6 89		      inc	ScreenDrawPhase	;5 =  5
    230  096f		       ba		      tsx		;2
    231  0970		       86 84		      stx	DrawStackPointer	;3
    232  0972		       a6 da		      ldx	save_SP	;3
    233  0974		       9a		      txs		;2 = 10
    234  0975
    235  0975		       4c 96 f8 	      jmp	SwitchObjects
    236  0978
    237  0978							;rts				  ;6 =	6
    238  0978
    239  0978				   .exitDrawStack
    240  0978		       84 ce		      sty	DSL	;3 =  3
    241  097a		       ba		      tsx		;2
    242  097b		       86 84		      stx	DrawStackPointer	;3
    243  097d		       a6 da		      ldx	save_SP	;3
    244  097f		       9a		      txs		;2 = 10
    245  0980		       60		      rts		;6 =  6
    246  0981
    247  0981				   PairedCharacter
    248  0981
    249  0981				   SOFF       SET	0
    250  0981					      REPEAT	SCREEN_LINES
    251  0981		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  0981				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  0981					      REPEND
    251  098b		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  098b				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  098b					      REPEND
    251  0995		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  0995				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  0995					      REPEND
    251  099f		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  099f				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  099f					      REPEND
    251  09a9		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  09a9				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  09a9					      REPEND
    251  09b3		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  09b3				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  09b3					      REPEND
    251  09bd		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  09bd				   SOFF       SET	SOFF + SCREEN_WIDTH
    250  09bd					      REPEND
    251  09c7		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    252  09c7				   SOFF       SET	SOFF + SCREEN_WIDTH
    253  09d1					      REPEND
    254  09d1
    255  09d1							;------------------------------------------------------------------------------
    256  09d1							; Gives character replacements used during screen drawing.
    257  09d1							; The character from the board is morphed via this array into an actual character
    258  09d1							; to draw.  This allows global animation and replacment of characters without
    259  09d1							; individual objects needing to do this.  Note, the draw-time replacement happens,
    260  09d1							; not board-time.
    261  09d1
    262  09d1				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    263  09d1
    264  09d1							; Converts a character # to an animated creature type
    265  09d1							; The array is indexed by CHARACTER_...
    266  09d1
    267  09d1		       00		      .byte.b	CHARACTER_BLANK	;  0
    268  09d2		       01		      .byte.b	CHARACTER_SOIL	;  1
    269  09d3		       02		      .byte.b	CHARACTER_BOX	;  2
    270  09d4		       03	   ANIM_TARGET .byte.b	CHARACTER_TARGET	;  3  XOR'd to give flashing target squares
    271  09d5		       04		      .byte.b	CHARACTER_TARGET2	;  4
    272  09d6		       05		      .byte.b	CHARACTER_MANOCCUPIED	;  5
    273  09d7		       06		      .byte.b	CHARACTER_STEEL	;  6
    274  09d8		       07		      .byte.b	CHARACTER_WALL	;  7
    275  09d9		       08		      .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    276  09da		       00		      .byte.b	CHARACTER_BLANK	;  9
    277  09db
    278  09db				  -	      IF	(* - CharReplacement != CHARACTER_MAXIMUM)
    279  09db				  -	      ECHO	"ERROR: Incorrect CharReplacement table!"
    280  09db				  -	      ERR
    281  09db					      ENDIF
      0  09db					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  09db					      LIST	ON
    283  09db
    284  09db							;------------------------------------------------------------------------------
    285  09db
    286  09db
      0  09db					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
 PAGE BREAK INSERTED FOR  ROW_BankChar
 REQUESTED SIZE =  $50
 WASTED SPACE =  $25
 PAGEBREAK LOCATION =  $f200
     10  0a00					      LIST	ON
      0  0a00					      DEFINE_SUBROUTINE	ROW_BankChar
      1  0a00		       00 01	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  0a00					      SUBROUTINE
      3  0a00				   ROW_BankChar
    289  0a00
    290  0a00				   .BANK      SET	BANK_SCREENMARKII1
    291  0a00					      REPEAT	SCREEN_LINES
    292  0a00					      REPEAT	SCREEN_WIDTH
    293  0a00		       00		      .byte.b	.BANK
    292  0a00					      REPEND
    293  0a01		       00		      .byte.b	.BANK
    292  0a01					      REPEND
    293  0a02		       00		      .byte.b	.BANK
    292  0a02					      REPEND
    293  0a03		       00		      .byte.b	.BANK
    292  0a03					      REPEND
    293  0a04		       00		      .byte.b	.BANK
    292  0a04					      REPEND
    293  0a05		       00		      .byte.b	.BANK
    292  0a05					      REPEND
    293  0a06		       00		      .byte.b	.BANK
    292  0a06					      REPEND
    293  0a07		       00		      .byte.b	.BANK
    292  0a07					      REPEND
    293  0a08		       00		      .byte.b	.BANK
    292  0a08					      REPEND
    293  0a09		       00		      .byte.b	.BANK
    294  0a0a					      REPEND
    295  0a0a				   .BANK      SET	.BANK + 1
    291  0a0a					      REPEND
    292  0a0a					      REPEAT	SCREEN_WIDTH
    293  0a0a		       01		      .byte.b	.BANK
    292  0a0a					      REPEND
    293  0a0b		       01		      .byte.b	.BANK
    292  0a0b					      REPEND
    293  0a0c		       01		      .byte.b	.BANK
    292  0a0c					      REPEND
    293  0a0d		       01		      .byte.b	.BANK
    292  0a0d					      REPEND
    293  0a0e		       01		      .byte.b	.BANK
    292  0a0e					      REPEND
    293  0a0f		       01		      .byte.b	.BANK
    292  0a0f					      REPEND
    293  0a10		       01		      .byte.b	.BANK
    292  0a10					      REPEND
    293  0a11		       01		      .byte.b	.BANK
    292  0a11					      REPEND
    293  0a12		       01		      .byte.b	.BANK
    292  0a12					      REPEND
    293  0a13		       01		      .byte.b	.BANK
    294  0a14					      REPEND
    295  0a14				   .BANK      SET	.BANK + 1
    291  0a14					      REPEND
    292  0a14					      REPEAT	SCREEN_WIDTH
    293  0a14		       02		      .byte.b	.BANK
    292  0a14					      REPEND
    293  0a15		       02		      .byte.b	.BANK
    292  0a15					      REPEND
    293  0a16		       02		      .byte.b	.BANK
    292  0a16					      REPEND
    293  0a17		       02		      .byte.b	.BANK
    292  0a17					      REPEND
    293  0a18		       02		      .byte.b	.BANK
    292  0a18					      REPEND
    293  0a19		       02		      .byte.b	.BANK
    292  0a19					      REPEND
    293  0a1a		       02		      .byte.b	.BANK
    292  0a1a					      REPEND
    293  0a1b		       02		      .byte.b	.BANK
    292  0a1b					      REPEND
    293  0a1c		       02		      .byte.b	.BANK
    292  0a1c					      REPEND
    293  0a1d		       02		      .byte.b	.BANK
    294  0a1e					      REPEND
    295  0a1e				   .BANK      SET	.BANK + 1
    291  0a1e					      REPEND
    292  0a1e					      REPEAT	SCREEN_WIDTH
    293  0a1e		       03		      .byte.b	.BANK
    292  0a1e					      REPEND
    293  0a1f		       03		      .byte.b	.BANK
    292  0a1f					      REPEND
    293  0a20		       03		      .byte.b	.BANK
    292  0a20					      REPEND
    293  0a21		       03		      .byte.b	.BANK
    292  0a21					      REPEND
    293  0a22		       03		      .byte.b	.BANK
    292  0a22					      REPEND
    293  0a23		       03		      .byte.b	.BANK
    292  0a23					      REPEND
    293  0a24		       03		      .byte.b	.BANK
    292  0a24					      REPEND
    293  0a25		       03		      .byte.b	.BANK
    292  0a25					      REPEND
    293  0a26		       03		      .byte.b	.BANK
    292  0a26					      REPEND
    293  0a27		       03		      .byte.b	.BANK
    294  0a28					      REPEND
    295  0a28				   .BANK      SET	.BANK + 1
    291  0a28					      REPEND
    292  0a28					      REPEAT	SCREEN_WIDTH
    293  0a28		       04		      .byte.b	.BANK
    292  0a28					      REPEND
    293  0a29		       04		      .byte.b	.BANK
    292  0a29					      REPEND
    293  0a2a		       04		      .byte.b	.BANK
    292  0a2a					      REPEND
    293  0a2b		       04		      .byte.b	.BANK
    292  0a2b					      REPEND
    293  0a2c		       04		      .byte.b	.BANK
    292  0a2c					      REPEND
    293  0a2d		       04		      .byte.b	.BANK
    292  0a2d					      REPEND
    293  0a2e		       04		      .byte.b	.BANK
    292  0a2e					      REPEND
    293  0a2f		       04		      .byte.b	.BANK
    292  0a2f					      REPEND
    293  0a30		       04		      .byte.b	.BANK
    292  0a30					      REPEND
    293  0a31		       04		      .byte.b	.BANK
    294  0a32					      REPEND
    295  0a32				   .BANK      SET	.BANK + 1
    291  0a32					      REPEND
    292  0a32					      REPEAT	SCREEN_WIDTH
    293  0a32		       05		      .byte.b	.BANK
    292  0a32					      REPEND
    293  0a33		       05		      .byte.b	.BANK
    292  0a33					      REPEND
    293  0a34		       05		      .byte.b	.BANK
    292  0a34					      REPEND
    293  0a35		       05		      .byte.b	.BANK
    292  0a35					      REPEND
    293  0a36		       05		      .byte.b	.BANK
    292  0a36					      REPEND
    293  0a37		       05		      .byte.b	.BANK
    292  0a37					      REPEND
    293  0a38		       05		      .byte.b	.BANK
    292  0a38					      REPEND
    293  0a39		       05		      .byte.b	.BANK
    292  0a39					      REPEND
    293  0a3a		       05		      .byte.b	.BANK
    292  0a3a					      REPEND
    293  0a3b		       05		      .byte.b	.BANK
    294  0a3c					      REPEND
    295  0a3c				   .BANK      SET	.BANK + 1
    291  0a3c					      REPEND
    292  0a3c					      REPEAT	SCREEN_WIDTH
    293  0a3c		       06		      .byte.b	.BANK
    292  0a3c					      REPEND
    293  0a3d		       06		      .byte.b	.BANK
    292  0a3d					      REPEND
    293  0a3e		       06		      .byte.b	.BANK
    292  0a3e					      REPEND
    293  0a3f		       06		      .byte.b	.BANK
    292  0a3f					      REPEND
    293  0a40		       06		      .byte.b	.BANK
    292  0a40					      REPEND
    293  0a41		       06		      .byte.b	.BANK
    292  0a41					      REPEND
    293  0a42		       06		      .byte.b	.BANK
    292  0a42					      REPEND
    293  0a43		       06		      .byte.b	.BANK
    292  0a43					      REPEND
    293  0a44		       06		      .byte.b	.BANK
    292  0a44					      REPEND
    293  0a45		       06		      .byte.b	.BANK
    294  0a46					      REPEND
    295  0a46				   .BANK      SET	.BANK + 1
    291  0a46					      REPEND
    292  0a46					      REPEAT	SCREEN_WIDTH
    293  0a46		       07		      .byte.b	.BANK
    292  0a46					      REPEND
    293  0a47		       07		      .byte.b	.BANK
    292  0a47					      REPEND
    293  0a48		       07		      .byte.b	.BANK
    292  0a48					      REPEND
    293  0a49		       07		      .byte.b	.BANK
    292  0a49					      REPEND
    293  0a4a		       07		      .byte.b	.BANK
    292  0a4a					      REPEND
    293  0a4b		       07		      .byte.b	.BANK
    292  0a4b					      REPEND
    293  0a4c		       07		      .byte.b	.BANK
    292  0a4c					      REPEND
    293  0a4d		       07		      .byte.b	.BANK
    292  0a4d					      REPEND
    293  0a4e		       07		      .byte.b	.BANK
    292  0a4e					      REPEND
    293  0a4f		       07		      .byte.b	.BANK
    294  0a50					      REPEND
    295  0a50				   .BANK      SET	.BANK + 1
    296  0a50					      REPEND
    297  0a50
      0  0a50					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  0a50
      2  0a50
      3  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $250 , FREE= $1b0
      4  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0a50				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0a50				  -	      ERR
      8  0a50					      endif
    299  0a50
    300  0a50
      0  0a50					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $250 , FREE= $5b0
      2  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0a50				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0a50				  -	      ERR
      6  0a50					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 3
      0  0a50					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  0a50							;    Sokoboo - a Sokoban implementation
      2  0a50							;    using a generic tile-based display engine for the Atari 2600
      3  0a50							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0a50							;
      5  0a50							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0a50							;
      7  0a50							;    Code related to the generic tile-based display engine was developed by
      8  0a50							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0a50							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0a50							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0a50							;
     12  0a50							;    Code related to music and sound effects uses the TIATracker music player
     13  0a50							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0a50							;    directory for Apache licensing details.
     15  0a50							;
     16  0a50							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0a50							;    See the copyright notices in the License directory for a list of level
     18  0a50							;    contributors.
     19  0a50							;
     20  0a50							;    Except where otherwise indicated, this software is released under the
     21  0a50							;    following licensing arrangement...
     22  0a50							;
     23  0a50							;    This program is free software: you can redistribute it and/or modify
     24  0a50							;    it under the terms of the GNU General Public License as published by
     25  0a50							;    the Free Software Foundation, either version 3 of the License, or
     26  0a50							;    (at your option) any later version.
     27  0a50							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0a50
     29  0a50							;    This program is distributed in the hope that it will be useful,
     30  0a50							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0a50							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0a50							;    GNU General Public License for more details.
     33  0a50
     34  0a50							;------------------------------------------------------------------------------
     35  0a50							;##############################################################################
     36  0a50							;------------------------------------------------------------------------------
      0  0a50					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  13bc ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
     38  1000
     39  1000
     40  1000		       00 9a	   SCORE_COL  =	$9a	;WHITE ;-2
     41  1000		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     42  1000		       00 66	   SCORE_COL_HIGH_PAL =	$66
     43  1000
     44  1000
     45  1000				   DigitVectorLOr
     46  1000		       50 5e 6c 57*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     47  100a		       1f 26 2d 34	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     48  100e				   DigitVectorLO
     49  100e		       53 61 6e 5a*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     50  1018		       37		      .byte.b	<BLANKL-1
     51  1019
     52  1019
     53  1019		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     54  1019		       00 0b	   ID_TARGET  =	11
     55  1019		       00 0c	   ID_EXTRA   =	12
     56  1019		       00 0d	   ID_CLOCK   =	13
     57  1019		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     58  1019
     59  1019							; score patch adresses:
     60  1019				   SMTblLSB
     61  1019				   SMTblTargets
     62  1019		       52 48		      .byte.b	SM_TARGET0+1-SM_BASE, SM_TARGET2+1-SM_BASE
     63  101b				   SMTblTime
     64  101b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     65  101d				   SMTblScore
     66  101d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     67  1020				   SMTblMSB
     68  1020		       4d 43		      .byte.b	SM_TARGET1+1-SM_BASE, SM_TARGET3+1-SM_BASE
     69  1022		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     70  1024		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     71  1027
     72  1027		       00 00	   SM_OFS_TARGETS =	SMTblTargets - SMTblLSB
     73  1027		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     74  1027		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     75  1027
     76  1027				   CharVectorLO
     77  1027		       37		      .byte.b	<BLANKL-1
     78  1028		       ad ad ad ad	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     79  102c		       ad ad ad ad	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     80  1030		       ad ad ad ad	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     81  1034		       ad ad ad ad	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     82  1038							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     83  1038
     84  1038							; Digit shape definitions are at start of bank so that we don't have page boundary
     85  1038							; crossing issues.
     86  1038
     87  1038							;	  .byte 0	      ; required!
     88  1038
     89  1038		       00 07	   DIGIT_H    =	7	; height of a score digit
     90  1038
     91  1038		       00 00 00 00*BLANKL     ds	7,0
     92  103f
     93  103f
     94  103f
     95  103f				   NineL
     96  103f		       1e		      .byte.b	%00011110
     97  1040		       02		      .byte.b	%00000010
     98  1041		       02		      .byte.b	%00000010
     99  1042		       fe		      .byte.b	%11111110
    100  1043		       82		      .byte.b	%10000010
    101  1044		       82		      .byte.b	%10000010
    102  1045		       fe		      .byte.b	%11111110
    103  1046
    104  1046				   SixL
    105  1046		       fe		      .byte.b	%11111110
    106  1047		       82		      .byte.b	%10000010
    107  1048		       82		      .byte.b	%10000010
    108  1049		       fe		      .byte.b	%11111110
    109  104a		       80		      .byte.b	%10000000
    110  104b		       80		      .byte.b	%10000000
    111  104c		       f0		      .byte.b	%11110000
    112  104d
    113  104d							;    .byte %01111100
    114  104d							;    .byte %11000010
    115  104d							;    .byte %11000010
    116  104d							;    .byte %11111100
    117  104d							;    .byte %11000000
    118  104d							;    .byte %01100000
    119  104d							;    .byte %00111000
    120  104d				   EightL
    121  104d
    122  104d
    123  104d		       fe		      .byte.b	%11111110
    124  104e		       82		      .byte.b	%10000010
    125  104f		       82		      .byte.b	%10000010
    126  1050		       fe		      .byte.b	%11111110
    127  1051		       82		      .byte.b	%10000010
    128  1052		       82		      .byte.b	%10000010
    129  1053		       fe		      .byte.b	%11111110
    130  1054
    131  1054							;  .byte %01111100
    132  1054							;  .byte %10000110
    133  1054							;  .byte %10000110
    134  1054							;  .byte %01111100
    135  1054							;  .byte %01000110
    136  1054							;  .byte %01000110
    137  1054							;  .byte %00111100
    138  1054				   ZeroL
    139  1054							;  .byte %01111100
    140  1054							;  .byte %10000110
    141  1054							;  .byte %10000110
    142  1054							;  .byte %10000110
    143  1054							;  .byte %10000110
    144  1054							;  .byte %01000110
    145  1054							;  .byte %00111100
    146  1054
    147  1054		       fe		      .byte.b	%11111110
    148  1055		       82		      .byte.b	%10000010
    149  1056		       82		      .byte.b	%10000010
    150  1057		       82		      .byte.b	%10000010
    151  1058		       82		      .byte.b	%10000010
    152  1059		       82		      .byte.b	%10000010
    153  105a		       fe		      .byte.b	%11111110
    154  105b
    155  105b				   ThreeL
    156  105b		       fe		      .byte.b	%11111110
    157  105c		       02		      .byte.b	%00000010
    158  105d		       02		      .byte.b	%00000010
    159  105e		       1e		      .byte.b	%00011110
    160  105f		       02		      .byte.b	%00000010
    161  1060		       02		      .byte.b	%00000010
    162  1061		       fe		      .byte.b	%11111110
    163  1062				   OneL
    164  1062		       10		      .byte.b	%00010000
    165  1063		       10		      .byte.b	%00010000
    166  1064		       10		      .byte.b	%00010000
    167  1065		       10		      .byte.b	%00010000
    168  1066		       10		      .byte.b	%00010000
    169  1067		       10		      .byte.b	%00010000
    170  1068		       10		      .byte.b	%00010000
    171  1069
    172  1069				   SevenL
    173  1069
    174  1069		       10		      .byte.b	%00010000
    175  106a		       10		      .byte.b	%00010000
    176  106b		       10		      .byte.b	%00010000
    177  106c		       1e		      .byte.b	%00011110
    178  106d		       02		      .byte.b	%00000010
    179  106e		       02		      .byte.b	%00000010
    180  106f							;  .byte %11111110
    181  106f
    182  106f							;    .byte %00010000
    183  106f							;    .byte %00010000
    184  106f							;    .byte %00010000
    185  106f							;    .byte %00011000
    186  106f							;    .byte %00001100
    187  106f							;    .byte %10000110
    188  106f							;    ;.byte %11111110
    189  106f				   TwoL
    190  106f		       fe		      .byte.b	%11111110
    191  1070		       80		      .byte.b	%10000000
    192  1071		       80		      .byte.b	%10000000
    193  1072		       fe		      .byte.b	%11111110
    194  1073		       02		      .byte.b	%00000010
    195  1074		       02		      .byte.b	%00000010
    196  1075		       fe		      .byte.b	%11111110
    197  1076
    198  1076				   FiveL
    199  1076		       fe		      .byte.b	%11111110
    200  1077		       02		      .byte.b	%00000010
    201  1078		       02		      .byte.b	%00000010
    202  1079		       fe		      .byte.b	%11111110
    203  107a		       80		      .byte.b	%10000000
    204  107b		       80		      .byte.b	%10000000
    205  107c		       f0		      .byte.b	%11110000
    206  107d
    207  107d				   FourL
    208  107d		       10		      .byte.b	%00010000
    209  107e		       10		      .byte.b	%00010000
    210  107f		       10		      .byte.b	%00010000
    211  1080		       fe		      .byte.b	%11111110
    212  1081		       90		      .byte.b	%10010000
    213  1082		       90		      .byte.b	%10010000
    214  1083		       90		      .byte.b	%10010000
    215  1084
    216  1084
    217  1084				   ZL
    218  1084		       7f		      .byte.b	%01111111
    219  1085		       40		      .byte.b	%01000000
    220  1086		       40		      .byte.b	%01000000
    221  1087		       7f		      .byte.b	%01111111
    222  1088		       01		      .byte.b	%00000001
    223  1089		       01		      .byte.b	%00000001
    224  108a		       0f		      .byte.b	%00001111
    225  108b
    226  108b				   EL
    227  108b		       7f		      .byte.b	%01111111
    228  108c		       40		      .byte.b	%01000000
    229  108d		       40		      .byte.b	%01000000
    230  108e		       78		      .byte.b	%01111000
    231  108f		       40		      .byte.b	%01000000
    232  1090		       40		      .byte.b	%01000000
    233  1091		       7f		      .byte.b	%01111111
    234  1092
    235  1092				   RL
    236  1092		       48		      .byte.b	%01001000
    237  1093		       48		      .byte.b	%01001000
    238  1094		       48		      .byte.b	%01001000
    239  1095		       7f		      .byte.b	%01111111
    240  1096		       41		      .byte.b	%01000001
    241  1097		       41		      .byte.b	%01000001
    242  1098		       7f		      .byte.b	%01111111
    243  1099
    244  1099				   PL
    245  1099		       40		      .byte.b	%01000000
    246  109a		       40		      .byte.b	%01000000
    247  109b		       40		      .byte.b	%01000000
    248  109c		       7f		      .byte.b	%01111111
    249  109d		       41		      .byte.b	%01000001
    250  109e		       41		      .byte.b	%01000001
    251  109f		       7f		      .byte.b	%01111111
    252  10a0
    253  10a0				   AL
    254  10a0		       41		      .byte.b	%01000001
    255  10a1		       41		      .byte.b	%01000001
    256  10a2		       41		      .byte.b	%01000001
    257  10a3		       7f		      .byte.b	%01111111
    258  10a4		       41		      .byte.b	%01000001
    259  10a5		       41		      .byte.b	%01000001
    260  10a6		       7f		      .byte.b	%01111111
    261  10a7
    262  10a7				   GL
    263  10a7		       7f		      .byte.b	%01111111
    264  10a8		       41		      .byte.b	%01000001
    265  10a9		       41		      .byte.b	%01000001
    266  10aa		       4f		      .byte.b	%01001111
    267  10ab		       40		      .byte.b	%01000000
    268  10ac		       40		      .byte.b	%01000000
    269  10ad		       7f		      .byte.b	%01111111
    270  10ae
    271  10ae
    272  10ae							; level "name" characters (left only!):
    273  10ae
    274  10ae				   CharN
    275  10ae				   CharK
    276  10ae				   CharH
    277  10ae				   CharA
    278  10ae				   CharJ
    279  10ae				   CharP
    280  10ae				   CharB
    281  10ae				   CharO
    282  10ae				   CharC
    283  10ae				   CharI
    284  10ae				   CharD
    285  10ae				   CharG
    286  10ae				   CharE
    287  10ae				   CharL
    288  10ae				   CharF
    289  10ae				   CharM
    290  10ae		       00 00 00 00*	      ds	7,0
    291  10b5
    292  10b5				   charPlace
    293  10b5		       0c		      .byte.b	%00001100
    294  10b6		       0c		      .byte.b	%00001100
    295  10b7		       0c		      .byte.b	%00001100
    296  10b8		       0c		      .byte.b	%00001100
    297  10b9		       0c		      .byte.b	%00001100
    298  10ba		       00		      .byte.b	%00000000
    299  10bb		       0c		      .byte.b	%00001100
    300  10bc
    301  10bc							;-------------------------------------------------------------------------------------
    302  10bc				   PosTbl
    303  10bc		       40		      .byte.b	$40
    304  10bd		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    305  10c5		       b9		      .byte.b	$b9
    306  10c6
    307  10c6
    308  10c6							;------------------------------------------------------------------------------
    309  10c6							; RAM-BASED SUBROUTINES...
    310  10c6							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    311  10c6							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    312  10c6							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    313  10c6							; the RAM-based routine.
    314  10c6
    315  1100		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    316  1100
    317  1100		       f1 00	   SM_BASE    =	.
    318  1100
    319  1100							;#IF 0 ;{
    320  1100							;    DEFINE_SUBROUTINE Score3x3
    321  1100							;
    322  1100							;	  sta	  RESP0
    323  1100							;	   sta	   RESP1
    324  1100							;	   lda	   #$$000
    325  1100							;	    sta     GRP0
    326  1100							;	    lda     #$$009
    327  1100							;	    sta     GRP1
    328  1100							;	    lda     #$$202
    329  1100							;	    sta     ENABL
    330  1100							;	    nop
    331  1100							;	    nop
    332  1100							;	    nop
    333  1100							;	    lda     #$$016
    334  1100							;	    ldy     #$$100
    335  1100							;	    ldx     #$$109
    336  1100							;	    sta     GRP0    ; Critical time is right here
    337  1100							;	    stx     GRP1
    338  1100							;	    sty     GRP0
    339  1100							;	    sta     RESP0
    340  1100							;	    sta     RESP1
    341  1100							;	    ldx     #$$116
    342  1100							;	    lda     #$$209
    343  1100							;	    stx     GRP0
    344  1100							;	    sta     GRP1
    345  1100							;	    lda     #$$200
    346  1100							;	    sta     GRP0
    347  1100							;	    sta     RESP0
    348  1100							;	    sta     RESP1
    349  1100							;	    lda     #$$216
    350  1100							;	    nop
    351  1100							;	    sta     GRP0
    352  1100							;
    353  1100							;	      rts
    354  1100							;#ENDIF ;}
    355  1100
    356  1100
    357  1100							;------------------------------------------------------------------------------
    358  1100				   Score1x6Fix SUBROUTINE
      0  1100					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  1100		       00 02	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  1100					      SUBROUTINE
      3  1100				   DrawDigits1x6
    360  1100							;					     @07
    361  1100		       ba		      tsx		; 2
    362  1101
    363  1101		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 58    @65
    364  1104
    365  1104		       86 da		      stx	tmpStack	; 3 =	3
    366  1106
    367  1106				   LoopDraw1x6		;
    368  1106				   SMDIGIT0
    369  1106		       b9 50 f3 	      lda	ZeroR-1,y	; 4
    370  1109		       85 42		      sta	WSYNC	; 3
    371  110b							;---------------------------------------------------------------
    372  110b		       85 6a		      sta	HMOVE	; 3
      0  110d					      SLEEP	3	; 3 =	6
      1  110d				   .CYCLES    SET	3
      2  110d
      3  110d				  -	      IF	.CYCLES < 2
      4  110d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  110d				  -	      ERR
      6  110d					      ENDIF
      7  110d
      8  110d					      IF	.CYCLES & 1
      9  110d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  110d		       04 00		      nop	0
     11  110f				  -	      ELSE
     12  110f				  -	      bit	VSYNC
     13  110f					      ENDIF
     14  110f				   .CYCLES    SET	.CYCLES - 3
     15  110f					      ENDIF
     16  110f
     17  110f				  -	      REPEAT	.CYCLES / 2
     18  110f				  -	      nop
     19  110f					      REPEND
    374  110f		       85 5b		      sta	GRP0	; 3
    375  1111				   SMDIGIT1
    376  1111		       b9 53 f0 	      lda	ZeroL-1,y	; 4
    377  1114		       85 5c		      sta	GRP1	; 3
    378  1116				   SMDIGIT2
    379  1116		       b9 50 f3 	      lda	ZeroR-1,y	; 4
    380  1119		       85 5b		      sta	GRP0	; 3 = 17
    381  111b				   SMDIGIT5
    382  111b		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    383  111e		       9a		      txs		; 2
    384  111f				   SMDIGIT3
    385  111f		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    386  1122				   SMDIGIT4
    387  1122		       b9 50 f3 	      lda	ZeroR-1,y	; 4
    388  1125		       85 6b		      sta	HMCLR	; 3
    389  1127		       86 5c		      stx	GRP1	; 3
    390  1129		       85 5b		      sta	GRP0	; 3 = 23
    391  112b
    392  112b		       ba		      tsx		; 2
    393  112c		       86 5c		      stx	GRP1	; 3
    394  112e		       85 5b		      sta	GRP0	; 3 =	8
    395  1130
    396  1130		       88		      dey		; 2
      0  1131					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  1131					      LIST	ON
      9  1131		       d0 d3		      bne	LoopDraw1x6
    398  1133
    399  1133		       a6 da		      ldx	tmpStack	; 3
    400  1135		       9a		      txs		; 2
    401  1136				   ExitDigitKernel6
      0  1136					      SLEEP	3	; 3
      1  1136				   .CYCLES    SET	3
      2  1136
      3  1136				  -	      IF	.CYCLES < 2
      4  1136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1136				  -	      ERR
      6  1136					      ENDIF
      7  1136
      8  1136					      IF	.CYCLES & 1
      9  1136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1136		       04 00		      nop	0
     11  1138				  -	      ELSE
     12  1138				  -	      bit	VSYNC
     13  1138					      ENDIF
     14  1138				   .CYCLES    SET	.CYCLES - 3
     15  1138					      ENDIF
     16  1138
     17  1138				  -	      REPEAT	.CYCLES / 2
     18  1138				  -	      nop
     19  1138					      REPEND
    403  1138		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    404  113b
    405  113b
    406  113b							;------------------------------------------------------------------------------
    407  113b				   Score2x4Fix SUBROUTINE
      0  113b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  113b		       00 02	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  113b					      SUBROUTINE
      3  113b				   DrawDigits2x4
    409  113b
    410  113b
    411  113b							; Subroutine by Thomas Jentzsch.  Magic!
    412  113b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    413  113b
    414  113b							;sta COLUBK
    415  113b
    416  113b		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 56    @63
    417  113e
    418  113e		       85 6a		      sta	HMOVE	; 3
      0  1140					      SLEEP	4	; 4  =  7
      1  1140				   .CYCLES    SET	4
      2  1140
      3  1140				  -	      IF	.CYCLES < 2
      4  1140				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1140				  -	      ERR
      6  1140					      ENDIF
      7  1140
      8  1140				  -	      IF	.CYCLES & 1
      9  1140				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1140				  -	      nop	0
     11  1140				  -	      ELSE
     12  1140				  -	      bit	VSYNC
     13  1140				  -	      ENDIF
     14  1140				  -.CYCLES    SET	.CYCLES - 3
     15  1140					      ENDIF
     16  1140
     17  1140					      REPEAT	.CYCLES / 2
     18  1140		       ea		      nop
     17  1140					      REPEND
     18  1141		       ea		      nop
     19  1142					      REPEND
    420  1142
    421  1142				   LoopDraw2x4		;	     @70
    422  1142				   SM_TARGET3
    423  1142		       b9 26 f3 	      lda	DequalsR-1,y	; 4		     G
    424  1145							;---------------------------------------------------------------
    425  1145		       85 5b		      sta	GRP0	; 3
    426  1147				   SM_TARGET2
    427  1147		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     A
    428  114a		       85 5c		      sta	GRP1	; 3
    429  114c				   SM_TARGET1
    430  114c		       b9 50 f3 	      lda	ZeroR-1,y	; 4		     M
    431  114f		       85 5b		      sta	GRP0	; 3
    432  1151				   SM_TARGET0
    433  1151		       be 53 f0 	      ldx	ZeroL-1,y	; 4		     E
    434  1154		       85 50		      sta	RESP0	; 3 = 28    @22
    435  1156		       85 51		      sta	RESP1	; 3 =	3    @25
    436  1158				   SM_Time3
    437  1158		       b9 34 f3 	      lda	ClockR-1,y	; 4		     O
    438  115b		       86 5c		      stx	GRP1	; 3
    439  115d		       85 5b		      sta	GRP0	; 3
    440  115f				   SM_Time2
    441  115f		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     V
    442  1162		       85 5c		      sta	GRP1	; 3
    443  1164				   SM_Time1
    444  1164		       b9 50 f3 	      lda	ZeroR-1,y	; 4		     E
    445  1167		       85 5b		      sta	GRP0	; 3
    446  1169		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    447  116b		       85 51		      sta	RESP1	; 3 =	3    @55
    448  116d				   SM_Time0
    449  116d		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     R
    450  1170		       85 5c		      sta	GRP1	; 3
    451  1172		       85 5b		      sta	GRP0	; 3
    452  1174		       88		      dey		; 2
      0  1175					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  1175					      LIST	ON
      9  1175		       d0 cb		      bne	LoopDraw2x4
    454  1177
    455  1177				   ExitDigitKernel		;	     @69
    456  1177		       84 5b		      sty	GRP0	; 3
    457  1179		       84 5c		      sty	GRP1	; 3
    458  117b							;---------------------------------------------------------------
    459  117b		       84 5b		      sty	GRP0	; 3	     @02
    460  117d
    461  117d							; Contribution by Thomas Jentzsch
    462  117d							; Rewrite/Optimised for single sprite AD
    463  117d
    464  117d		       a6 9d		      ldx	ManDrawX	; 3
    465  117f		       bd bc f0 	      lda	PosTbl,x	; 4
    466  1182		       85 60		      sta	HMP0	; 3
    467  1184		       29 0f		      and	#$0f	; 2
    468  1186		       f0 04		      beq	.zeroPos	; 2/3=15
    469  1188		       aa		      tax		; 2
    470  1189				   .loopWait
    471  1189		       ca		      dex		; 2
    472  118a		       d0 fd		      bne	.loopWait	; 2/3= 6
    473  118c				   .zeroPos
    474  118c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    475  118e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    476  1190		       a5 b3		      lda	BGColour	; 3
    477  1192		       86 62		      stx	HMM0	; 3	     for extra life stars!
    478  1194		       85 42		      sta	WSYNC	; 3
    479  1196							;---------------------------------------------------------------
    480  1196		       85 6a		      sta	HMOVE	; 3
    481  1198		       60		      rts		; 6	     @09
    482  1199
    483  1199							;------------------------------------------------------------------------------
    484  1199				   Score3x2Fix SUBROUTINE
      0  1199					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  1199		       00 02	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  1199					      SUBROUTINE
      3  1199				   DrawDigits3x2
    486  1199							;					     @07
    487  1199		       a9 16		      lda	#%010110	; 2
    488  119b		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    489  119d		       20 f4 f1 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    490  11a0
    491  11a0		       a9 00		      lda	#0
    492  11a2		       85 66		      sta	VDELP1
    493  11a4				   LoopDraw3x2		;
    494  11a4		       85 42		      sta	WSYNC	; 3
    495  11a6							;---------------------------------------------------------------
    496  11a6		       85 6a		      sta	HMOVE	; 3 =	3
    497  11a8		       b9 ad f0 	      lda	CharP-1,y	; 4
    498  11ab		       85 5b		      sta	GRP0	; 3
    499  11ad				   SMPLAYER
    500  11ad		       b9 5e f3 	      lda	OneR-1,y	; 4
    501  11b0		       85 5c		      sta	GRP1	; 3 = 14    @17
    502  11b2		       b9 b4 f0 	      lda	charPlace-1,y	; 4
    503  11b5				   SMMEN
    504  11b5		       be 57 f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  11b8					      SLEEP	5	;   =	5
      1  11b8				   .CYCLES    SET	5
      2  11b8
      3  11b8				  -	      IF	.CYCLES < 2
      4  11b8				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11b8				  -	      ERR
      6  11b8					      ENDIF
      7  11b8
      8  11b8					      IF	.CYCLES & 1
      9  11b8					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11b8		       04 00		      nop	0
     11  11ba				  -	      ELSE
     12  11ba				  -	      bit	VSYNC
     13  11ba					      ENDIF
     14  11ba				   .CYCLES    SET	.CYCLES - 3
     15  11ba					      ENDIF
     16  11ba
     17  11ba					      REPEAT	.CYCLES / 2
     18  11ba		       ea		      nop
     19  11bb					      REPEND
    506  11bb		       85 5b		      sta	GRP0	; 3
    507  11bd				   SMLEVELX
    508  11bd		       b9 ad f0 	      lda	CharA-1,y	; 4
    509  11c0		       85 6b		      sta	HMCLR	; 3 = 10    @40
    510  11c2		       86 5c		      stx	GRP1	; 3 =	3    @43
    511  11c4		       85 5b		      sta	GRP0	; 3
    512  11c6				   SMLEVEL
    513  11c6		       b9 5e f3 	      lda	OneR-1,y	; 4
    514  11c9		       85 5c		      sta	GRP1	; 3 = 10    @53
    515  11cb
    516  11cb		       88		      dey		; 2
      0  11cc					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  11cc					      LIST	ON
      9  11cc		       d0 d6		      bne	LoopDraw3x2
    518  11ce							;					     @57
      0  11ce					      SLEEP	3	; 3
      1  11ce				   .CYCLES    SET	3
      2  11ce
      3  11ce				  -	      IF	.CYCLES < 2
      4  11ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11ce				  -	      ERR
      6  11ce					      ENDIF
      7  11ce
      8  11ce					      IF	.CYCLES & 1
      9  11ce					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11ce		       04 00		      nop	0
     11  11d0				  -	      ELSE
     12  11d0				  -	      bit	VSYNC
     13  11d0					      ENDIF
     14  11d0				   .CYCLES    SET	.CYCLES - 3
     15  11d0					      ENDIF
     16  11d0
     17  11d0				  -	      REPEAT	.CYCLES / 2
     18  11d0				  -	      nop
     19  11d0					      REPEND
    520  11d0		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    521  11d3
    522  11d3
    523  11d3							;------------------------------------------------------------------------------
      0  11d3					      DEFINE_SUBROUTINE	DrawDigits
      1  11d3		       00 02	   BANK_DrawDigits =	_CURRENT_BANK
      2  11d3					      SUBROUTINE
      3  11d3				   DrawDigits
    525  11d3
    526  11d3				   VblankLoopGame
    527  11d3		       ac 84 02 	      ldy	INTIM
    528  11d6		       d0 fb		      bne	VblankLoopGame
    529  11d8
    530  11d8		       84 41		      sty	VBLANK	; 3	     <-- 0
    531  11da		       a5 c9		      lda	scoringFlags	; 3
    532  11dc		       29 03		      and	#DISPLAY_FLAGS	; 2
    533  11de		       aa		      tax		; 2
    534  11df
    535  11df							;    DEFINE_SUBROUTINE DrawDigit2
    536  11df							;
    537  11df							;    ; Generic interface to scoring routine
    538  11df
    539  11df		       bd ea f1 	      lda	ScoreKernelLo,x	; 4
    540  11e2
    541  11e2		       85 42		      sta	WSYNC	; 3
    542  11e4							;---------------------------------------------------------------
    543  11e4		       8d e8 f5 	      sta	SMJUMP+1+RAM_WRITE	; 4
    544  11e7				   SMJUMP
    545  11e7		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    546  11ea
    547  11ea				   ScoreKernelLo
    548  11ea		       3b		      .byte.b	<Score2x4Fix	; TARGETs, time
    549  11eb		       00		      .byte.b	<Score1x6Fix	; score
    550  11ec		       99		      .byte.b	<Score3x2Fix	; player, lives, level
    551  11ed		       00		      .byte.b	<Score1x6Fix	; high score
    552  11ee
      0  11ee					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  11ee					      LIST	ON
    554  11ee
    555  11ee							;------------------------------------------------------------------------------
      0  11ee					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  11ee		       00 02	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  11ee					      SUBROUTINE
      3  11ee				   PrepareDrawDigits
    557  11ee							;					     @13
    558  11ee		       a0 d1		      ldy	#$d1	; 2
    559  11f0		       a9 13		      lda	#%010011	; 2
    560  11f2		       85 66		      sta	VDELP1	; 3 =	7
    561  11f4				   PrepareDrawDigits2		;	    @17/20
    562  11f4		       84 65		      sty	VDELP0	; 3 =	3
    563  11f6
    564  11f6		       85 45		      sta	NUSIZ1	; 3
    565  11f8		       85 44		      sta	NUSIZ0	; 3 =	6
    566  11fa
    567  11fa		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    568  11fd		       85 50		      sta	RESP0	; 3	     @33/36
    569  11ff		       85 51		      sta	RESP1	; 3 = 10    @36/39
    570  1201
    571  1201		       84 60		      sty	HMP0	; 3
    572  1203		       c8		      iny		; 2
    573  1204		       84 61		      sty	HMP1	; 3 =	8
    574  1206				   SMCOLOR
    575  1206		       a0 9a		      ldy	#SCORE_COL	; 2
    576  1208		       84 46		      sty	COLUP0	; 3
    577  120a		       84 47		      sty	COLUP1	; 3 =	8
    578  120c
    579  120c		       a0 07		      ldy	#DIGIT_H	; 2
    580  120e		       60		      rts		; 6 =	8
    581  120f							; total: 27
    582  120f
    583  120f
    584  120f							;------------------------------------------------------------------------------
      0  120f					      DEFINE_SUBROUTINE	UpdateScore
      1  120f		       00 02	   BANK_UpdateScore =	_CURRENT_BANK
      2  120f					      SUBROUTINE
      3  120f				   UpdateScore
    586  120f							; a = added score value
    587  120f
    588  120f							; initially switch to score:
    589  120f		       a0 01		      ldy	#DISPLAY_SCORE
    590  1211		       84 da		      sty	newDisplay
    591  1213
    592  1213		       18		      clc
    593  1214		       f8		      sed
    594  1215		       a0 04		      ldy	#SM_OFS_SCORE
    595  1217				   .loopScore
    596  1217		       79 a9 f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    597  121a		       99 a9 f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    598  121d		       08		      php
    599  121e							; *** bonus life every 500 points: ***
    600  121e							;	  cpy #SM_OFS_SCORE+1
    601  121e							;	  bne .skipBonusLife
    602  121e							;	  tax
    603  121e
    604  121e							;	  and #$0f
    605  121e							;	  beq .bonusLife		      ; 000?
    606  121e							;	  cmp #$05
    607  121e							;	  bne .noBonusLife		      ; 500?
    608  121e							;.bonusLife:
    609  121e							; add extra life, limited to 9
    610  121e
    611  121e							;	  lda ManCount
    612  121e							;	  and #$0f
    613  121e							;	  cmp #9
    614  121e							;	  bcs .noBonusLife
    615  121e							;	  inc ManCount
    616  121e
    617  121e							; bonus life has priority over score:
    618  121e							;	  lda #DISPLAY_LIVES
    619  121e							;	  sta newDisplay
    620  121e							;lda #EXTRA_LIFE_TIMER
    621  121e							;sta extraLifeTimer
    622  121e
    623  121e				   .noBonusLife
    624  121e		       8a		      txa
    625  121f				   .skipBonusLife
    626  121f		       20 00 f3 	      jsr	SetupBCDPtr
    627  1222		       28		      plp
    628  1223		       a9 00		      lda	#0
    629  1225		       b0 f0		      bcs	.loopScore
    630  1227		       d8		      cld
    631  1228
    632  1228							; switch display
    633  1228		       a5 c9		      lda	scoringFlags
    634  122a		       29 03		      and	#DISPLAY_FLAGS
    635  122c		       c5 da		      cmp	newDisplay	; lower priority than current?
    636  122e		       f0 08		      beq	.restartTime
    637  1230		       b0 0a		      bcs	.skipNew
    638  1232		       45 c9		      eor	scoringFlags	; remove existing score mode
    639  1234		       05 da		      ora	newDisplay	; switch to new score mode
    640  1236		       85 c9		      sta	scoringFlags
    641  1238				   .restartTime
    642  1238		       a9 3c		      lda	#SCORING_TIMER	; maybe always restart timer?
    643  123a		       85 c8		      sta	scoringTimer
    644  123c				   .skipNew
    645  123c
    646  123c		       60		      rts
    647  123d
    648  123d							;---------------------------------------------------------------------------
    649  123d
      0  123d					      DEFINE_SUBROUTINE	SwapPlayers
      1  123d		       00 02	   BANK_SwapPlayers =	_CURRENT_BANK
      2  123d					      SUBROUTINE
      3  123d				   SwapPlayers
    651  123d
    652  123d							; assume no new high score:
    653  123d		       a0 ff		      ldy	#-1
    654  123f		       84 dd		      sty	highScoreSK
    655  1241
    656  1241							; update highscore after last live:
    657  1241		       a5 a7		      lda	ManCount
    658  1243		       29 0f		      and	#$0f	; player has lives left?
    659  1245		       d0 1c		      bne	.playerAlive	; YES, so we don't check high score
    660  1247
    661  1247							; check for a new high score:
    662  1247							;	  ldy #-1
    663  1247		       18		      clc		; score has to be at least 1 bigger!
    664  1248				   .loopCheckHighScore
    665  1248		       c8		      iny
    666  1249		       b9 ad f3 	      lda	ScoreCurrent,y
    667  124c		       f9 b7 f3 	      sbc	HighScore,y
    668  124f		       98		      tya
    669  1250		       49 02		      eor	#2
    670  1252		       d0 f4		      bne	.loopCheckHighScore
    671  1254		       90 0d		      bcc	.noHighScore
    672  1256
    673  1256							; new high score, update:
    674  1256		       a2 04		      ldx	#5-1
    675  1258				   .loopSetHighScore
    676  1258		       bd ad f3 	      lda	ScoreCurrent,x
    677  125b		       9d b7 f7 	      sta	HighScore+RAM_WRITE,x
    678  125e		       95 dd		      sta	highScoreSK,x
    679  1260		       ca		      dex
    680  1261		       10 f5		      bpl	.loopSetHighScore
    681  1263				   .noHighScore
    682  1263
    683  1263				   .playerAlive
    684  1263		       a5 a7		      lda	ManCount
    685  1265		       29 f0		      and	#$f0	; other player has lives left?
    686  1267		       f0 21		      beq	.otherPlayerDead	; NO, so we don't swap scores
    687  1269
    688  1269							; save the current player variables to the player's backup:
    689  1269		       a0 02		      ldy	#3-1
    690  126b				   .swapScore
    691  126b		       be b2 f3 	      ldx	PlayerScores,y
    692  126e		       b9 ad f3 	      lda	ScoreCurrent,y
    693  1271		       99 b2 f7 	      sta	PlayerScores+RAM_WRITE,y
    694  1274		       8a		      txa
    695  1275		       99 ad f7 	      sta	ScoreCurrent+RAM_WRITE,y
    696  1278		       88		      dey
    697  1279		       10 f0		      bpl	.swapScore
    698  127b
    699  127b							; swap levelx and level:
    700  127b		       a2 01		      ldx	#1
    701  127d				   .loopLevelXLevel
    702  127d		       bc b5 f3 	      ldy	PlayerLevelX,x
    703  1280		       b5 b4		      lda	levelX,x
    704  1282		       9d b5 f7 	      sta	PlayerLevelX+RAM_WRITE,x
    705  1285		       94 b4		      sty	levelX,x
    706  1287		       ca		      dex
    707  1288		       10 f3		      bpl	.loopLevelXLevel
    708  128a
    709  128a				   .otherPlayerDead
    710  128a		       60		      rts
    711  128b
    712  128b							;---------------------------------------------------------------------------
    713  128b
    714  128b				   HighScoreColTbl
    715  128b		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    716  128d		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    717  128f
      0  128f					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  128f		       00 02	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  128f					      SUBROUTINE
      3  128f				   GeneralScoringSetups
    719  128f
    720  128f		       a0 04		      ldy	#SM_OFS_SCORE
    721  1291				   .loopScore2
    722  1291		       a5 c9		      lda	scoringFlags
    723  1293		       29 03		      and	#DISPLAY_FLAGS
    724  1295		       c9 03		      cmp	#DISPLAY_HIGH
    725  1297		       a6 81		      ldx	Platform
    726  1299		       bd 8b f2 	      lda	HighScoreColTbl,x
    727  129c		       aa		      tax
    728  129d		       b9 b3 f3 	      lda	HighScore-SM_OFS_SCORE,y
    729  12a0		       b0 05		      bcs	.showHighScore
    730  12a2		       a2 9a		      ldx	#SCORE_COL
    731  12a4		       b9 a9 f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    732  12a7				   .showHighScore
    733  12a7		       8e 07 f6 	      stx	SMCOLOR+1+RAM_WRITE
    734  12aa		       20 00 f3 	      jsr	SetupBCDPtr
    735  12ad		       c0 07		      cpy	#SM_OFS_SCORE+3
    736  12af		       90 e0		      bcc	.loopScore2
    737  12b1
    738  12b1							; display number of lives in leftmost digit of middle score XX nX XX
    739  12b1
    740  12b1		       a5 a7		      lda	ManCount
    741  12b3		       29 0f		      and	#$0f
    742  12b5		       a8		      tay
    743  12b6		       b9 00 f0 	      lda	DigitVectorLOr,y
    744  12b9		       8d b6 f5 	      sta	SMMEN+1+RAM_WRITE
    745  12bc
    746  12bc							; modify player number pointer (Xp XX XX)
    747  12bc
    748  12bc		       a4 99		      ldy	whichPlayer
    749  12be		       b9 01 f0 	      lda	DigitVectorLOr+1,y
    750  12c1		       8d ae f5 	      sta	SMPLAYER+1+RAM_WRITE
    751  12c4
    752  12c4							; fall through
    753  12c4
    754  12c4							;    ;---------------------------------------------------------------------------
    755  12c4
    756  12c4							; modify levelx character pointer (XX XX cX)
    757  12c4
    758  12c4		       a2 b4		      ldx	#<charPlace-1
    759  12c6		       a5 b6		      lda	levelDisplay
    760  12c8		       c9 80		      cmp	#$80
    761  12ca		       29 1f		      and	#$1f
    762  12cc		       a8		      tay
    763  12cd		       b0 05		      bcs	.intermission
    764  12cf		       be 27 f0 	      ldx	CharVectorLO,y
    765  12d2		       a4 b5		      ldy	level
    766  12d4				   .intermission
    767  12d4		       8e be f5 	      stx	SMLEVELX+1+RAM_WRITE
    768  12d7
    769  12d7							; modify level number pointer (XX XX Xl)
    770  12d7
    771  12d7		       b9 01 f0 	      lda	DigitVectorLOr+1,y
    772  12da		       8d c7 f5 	      sta	SMLEVEL+1+RAM_WRITE
    773  12dd
    774  12dd							;---------------------------------------------------------------------------
    775  12dd
    776  12dd		       4c f7 f2 	      jmp	SetupTimePtr	; modify time pointers
    777  12e0
    778  12e0							;------------------------------------------------------------------------------
    779  12e0							;    DEFINE_SUBROUTINE SetupGameOverPtr
    780  12e0
    781  12e0							;		  ldy #8-1
    782  12e0							;.loopGameOver:
    783  12e0							;		  ldx SMGameOverOfs,y
    784  12e0							;		  lda SMGameOverPtr,y
    785  12e0							;		  sta SM_BASE+1+RAM_WRITE,x
    786  12e0							;		  dey
    787  12e0							;		  bpl .loopGameOver
    788  12e0
    789  12e0							;		  rts
    790  12e0
    791  12e0							;SMGameOverOfs:
    792  12e0							;		  .byte <SM_TARGET3-SM_BASE, <SM_TARGET2-SM_BASE
    793  12e0							;		  .byte <SM_TARGET1-SM_BASE, <SM_TARGET0-SM_BASE
    794  12e0							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    795  12e0							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    796  12e0							;SMGameOverPtr:
    797  12e0							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    798  12e0							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    799  12e0
    800  12e0							;------------------------------------------------------------------------------
    801  12e0
      0  12e0					      DEFINE_SUBROUTINE	DrawTargetsRequired
      1  12e0		       00 02	   BANK_DrawTargetsRequired =	_CURRENT_BANK
      2  12e0					      SUBROUTINE
      3  12e0				   DrawTargetsRequired
    803  12e0							; Show current TARGET counter in the top left
    804  12e0
    805  12e0		       a0 00		      ldy	#SM_OFS_TARGETS
    806  12e2		       a5 b9		      lda	targetsRequired
    807  12e4		       20 00 f3 	      jsr	SetupBCDPtr
    808  12e7
    809  12e7		       a9 b0		      lda	#ID_TARGET<<4	; if no extra targets, display the normal icon
    810  12e9		       24 c9		      bit	scoringFlags	;
    811  12eb		       10 13		      bpl	SetupBCDPtr
    812  12ed		       a9 c0		      lda	#ID_EXTRA<<4	; otherwise, display the extra icon
    813  12ef		       50 0f		      bvc	SetupBCDPtr
    814  12f1		       09 01		      ora	#1	; display 1xx targets
    815  12f3		       d0 0b		      bne	SetupBCDPtr	; unconditional
    816  12f5
    817  12f5							;------------------------------------------------------------------------------
      0  12f5					      DEFINE_SUBROUTINE	DrawTime
      1  12f5		       00 02	   BANK_DrawTime =	_CURRENT_BANK
      2  12f5					      SUBROUTINE
      3  12f5				   DrawTime
    819  12f5
    820  12f5							; mid-digit-change, but we may be required to flash/display
    821  12f5		       a0 02		      ldy	#SM_OFS_TIME
    822  12f7							;------------------------------------------------------------------------------
      0  12f7					      DEFINE_SUBROUTINE	SetupTimePtr
      1  12f7		       00 02	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  12f7					      SUBROUTINE
      3  12f7				   SetupTimePtr
    824  12f7
    825  12f7		       a5 ba		      lda	moveCounter
    826  12f9		       20 00 f3 	      jsr	SetupBCDPtr
    827  12fc		       a5 bb		      lda	moveCounter+1
    828  12fe		       09 d0		      ora	#ID_CLOCK<<4
    829  1300
    830  1300							; fall through
    831  1300
    832  1300							;------------------------------------------------------------------------------
      0  1300					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  1300		       00 02	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  1300					      SUBROUTINE
      3  1300				   SetupBCDPtr
    834  1300
    835  1300							; a = BCD value
    836  1300							; y = SM table offset
    837  1300
    838  1300		       48		      pha
    839  1301		       29 0f		      and	#$0f
    840  1303		       aa		      tax
    841  1304		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    842  1307		       be 19 f0 	      ldx	SMTblLSB,y
    843  130a		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    844  130d		       68		      pla
    845  130e		       4a		      lsr
    846  130f		       4a		      lsr
    847  1310		       4a		      lsr
    848  1311		       4a		      lsr
    849  1312		       aa		      tax
    850  1313		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    851  1316		       be 20 f0 	      ldx	SMTblMSB,y
    852  1319		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    853  131c
    854  131c		       c8		      iny
    855  131d
    856  131d		       a5 c4		      lda	ROM_Bank
    857  131f				   RTS
    858  131f		       60		      rts
    859  1320
      0  1320					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
     10  1320					      LIST	ON
    861  1320
    862  1320				  -	      IF	<. = 0
    863  1320				  -	      .byte	0	; required!
    864  1320					      ENDIF
    865  1320
    866  1320				   BLANKR
    867  1320		       00 00 00 00*	      .ds	DIGIT_H, 0
    868  1327
    869  1327				   DequalsR
    870  1327		       00		      .byte.b	%00000000
    871  1328		       00		      .byte.b	%00000000
    872  1329		       f0		      .byte.b	%11110000
    873  132a		       00		      .byte.b	%00000000
    874  132b		       f0		      .byte.b	%11110000
    875  132c		       00		      .byte.b	%00000000
    876  132d		       f0		      .byte.b	%11110000
    877  132e				   DplusR
    878  132e		       10		      .byte.b	%00010000
    879  132f		       28		      .byte.b	%00101000
    880  1330		       6c		      .byte.b	%01101100
    881  1331		       c6		      .byte.b	%11000110
    882  1332		       6c		      .byte.b	%01101100
    883  1333		       28		      .byte.b	%00101000
    884  1334		       10		      .byte.b	%00010000
    885  1335
    886  1335				   ClockR
    887  1335		       00		      .byte.b	%00000000
    888  1336		       48		      .byte.b	%01001000
    889  1337		       fc		      .byte.b	%11111100
    890  1338		       48		      .byte.b	%01001000
    891  1339		       48		      .byte.b	%01001000
    892  133a		       fc		      .byte.b	%11111100
    893  133b		       48		      .byte.b	%01001000
    894  133c				   NineR
    895  133c		       0f		      .byte.b	%00001111
    896  133d		       01		      .byte.b	%00000001
    897  133e		       01		      .byte.b	%00000001
    898  133f		       7f		      .byte.b	%01111111
    899  1340		       41		      .byte.b	%01000001
    900  1341		       41		      .byte.b	%01000001
    901  1342		       7f		      .byte.b	%01111111
    902  1343				   SixR
    903  1343		       7f		      .byte.b	%01111111
    904  1344		       41		      .byte.b	%01000001
    905  1345		       41		      .byte.b	%01000001
    906  1346		       7f		      .byte.b	%01111111
    907  1347		       40		      .byte.b	%01000000
    908  1348		       40		      .byte.b	%01000000
    909  1349		       78		      .byte.b	%01111000
    910  134a				   EightR
    911  134a							;  .byte %00111110
    912  134a							;  .byte %01000011
    913  134a							;  .byte %01000011
    914  134a							;  .byte %00111110
    915  134a							;  .byte %00100011
    916  134a							;  .byte %00100011
    917  134a							;  .byte %00011110
    918  134a
    919  134a
    920  134a		       7f		      .byte.b	%01111111
    921  134b		       41		      .byte.b	%01000001
    922  134c		       41		      .byte.b	%01000001
    923  134d		       7f		      .byte.b	%01111111
    924  134e		       41		      .byte.b	%01000001
    925  134f		       41		      .byte.b	%01000001
    926  1350		       7f		      .byte.b	%01111111
    927  1351
    928  1351				   ZeroR
    929  1351		       7f		      .byte.b	%01111111
    930  1352		       41		      .byte.b	%01000001
    931  1353		       41		      .byte.b	%01000001
    932  1354		       41		      .byte.b	%01000001
    933  1355		       41		      .byte.b	%01000001
    934  1356		       41		      .byte.b	%01000001
    935  1357		       7f		      .byte.b	%01111111
    936  1358
    937  1358							;	  .byte %00111110
    938  1358							;	  .byte %01000011
    939  1358							;	  .byte %01000011
    940  1358							;	  .byte %01000011
    941  1358							;	  .byte %01000011
    942  1358							;	  .byte %00100011
    943  1358							;	  .byte %00011110
    944  1358				   ThreeR
    945  1358		       7f		      .byte.b	%01111111
    946  1359		       01		      .byte.b	%00000001
    947  135a		       01		      .byte.b	%00000001
    948  135b		       0f		      .byte.b	%00001111
    949  135c		       01		      .byte.b	%00000001
    950  135d		       01		      .byte.b	%00000001
    951  135e		       7f		      .byte.b	%01111111
    952  135f				   OneR
    953  135f		       08		      .byte.b	%00001000
    954  1360		       08		      .byte.b	%00001000
    955  1361		       08		      .byte.b	%00001000
    956  1362		       08		      .byte.b	%00001000
    957  1363		       08		      .byte.b	%00001000
    958  1364		       08		      .byte.b	%00001000
    959  1365		       08		      .byte.b	%00001000
    960  1366
    961  1366				   SevenR
    962  1366		       08		      .byte.b	%00001000
    963  1367		       08		      .byte.b	%00001000
    964  1368		       08		      .byte.b	%00001000
    965  1369		       0f		      .byte.b	%00001111
    966  136a		       01		      .byte.b	%00000001
    967  136b		       01		      .byte.b	%00000001
    968  136c		       7f		      .byte.b	%01111111
    969  136d
    970  136d				   TwoR
    971  136d		       7f		      .byte.b	%01111111
    972  136e		       40		      .byte.b	%01000000
    973  136f		       40		      .byte.b	%01000000
    974  1370		       7f		      .byte.b	%01111111
    975  1371		       01		      .byte.b	%00000001
    976  1372		       01		      .byte.b	%00000001
    977  1373		       7f		      .byte.b	%01111111
    978  1374				   FiveR
    979  1374		       7f		      .byte.b	%01111111
    980  1375		       01		      .byte.b	%00000001
    981  1376		       01		      .byte.b	%00000001
    982  1377		       7f		      .byte.b	%01111111
    983  1378		       40		      .byte.b	%01000000
    984  1379		       40		      .byte.b	%01000000
    985  137a		       78		      .byte.b	%01111000
    986  137b				   FourR
    987  137b		       08		      .byte.b	%00001000
    988  137c		       08		      .byte.b	%00001000
    989  137d		       08		      .byte.b	%00001000
    990  137e		       7f		      .byte.b	%01111111
    991  137f		       48		      .byte.b	%01001000
    992  1380		       48		      .byte.b	%01001000
    993  1381		       48		      .byte.b	%01001000
    994  1382
    995  1382							;CharAL:
    996  1382							;    .byte %11100110
    997  1382							;    .byte %11100110
    998  1382							;    .byte %11111110
    999  1382							;    .byte %11100110
   1000  1382							;    .byte %11100110
   1001  1382							;    .byte %01111100
   1002  1382							;    .byte %00111000
   1003  1382							;CharEL:
   1004  1382							;    .byte %11111110
   1005  1382							;    .byte %11111110
   1006  1382							;    .byte %11100000
   1007  1382							;    .byte %11100000
   1008  1382							;    .byte %11111100
   1009  1382							;    .byte %11100000
   1010  1382							;    .byte %11111110
   1011  1382							;CharRL:
   1012  1382							;    .byte %11100110
   1013  1382							;    .byte %11100110
   1014  1382							;    .byte %11111100
   1015  1382							;    .byte %11111100
   1016  1382							;    .byte %11100110
   1017  1382							;    .byte %11100110
   1018  1382							;    .byte %11111100
   1019  1382							;CharVL:
   1020  1382							;    .byte %00111000
   1021  1382							;    .byte %01111100
   1022  1382							;    .byte %11100110
   1023  1382							;    .byte %11100110
   1024  1382							;    .byte %11100110
   1025  1382							;    .byte %11100110
   1026  1382							;    .byte %11100110
   1027  1382
      0  1382					      CHECKPAGE	BLANKR
      8  1382					      LIST	ON
   1029  1382
   1030  1382							;---------------------------------------------------------------------------
   1031  1382
      0  1382					      DEFINE_SUBROUTINE	GameInitialise
      1  1382		       00 02	   BANK_GameInitialise =	_CURRENT_BANK
      2  1382					      SUBROUTINE
      3  1382				   GameInitialise
   1033  1382
   1034  1382							; copy loaded SK high score into scoring RAM:
   1035  1382		       a2 02		      ldx	#3-1
   1036  1384				   .loopCopyHighScore
   1037  1384		       b5 dd		      lda	highScoreSK,x
   1038  1386		       c9 ff		      cmp	#$ff
   1039  1388		       f0 06		      beq	.noSaveKey
   1040  138a		       9d b7 f7 	      sta	HighScore+RAM_WRITE,x
   1041  138d		       ca		      dex
   1042  138e		       10 f4		      bpl	.loopCopyHighScore
   1043  1390				   .noSaveKey
   1044  1390
   1045  1390							; clear both players scores
   1046  1390		       a0 05		      ldy	#2*3-1
   1047  1392		       a9 00		      lda	#0
   1048  1394				   .loopClearScore
   1049  1394		       99 ad f7 	      sta	ScoreCurrent+RAM_WRITE,y
   1050  1397		       88		      dey
   1051  1398		       10 fa		      bpl	.loopClearScore
   1052  139a
   1053  139a							; copy levelX and level for other player and SaveKey:
   1054  139a		       a5 b4		      lda	levelX
   1055  139c		       8d b5 f7 	      sta	PlayerLevelX+RAM_WRITE
   1056  139f		       a5 e0		      lda	startingLevel
   1057  13a1		       8d b0 f7 	      sta	StartLevelX+RAM_WRITE
   1058  13a4		       a5 b5		      lda	level
   1059  13a6		       8d b6 f7 	      sta	PlayerLevel+RAM_WRITE
   1060  13a9		       8d b1 f7 	      sta	StartLevel+RAM_WRITE
   1061  13ac		       60		      rts
   1062  13ad
   1063  13ad							;---------------------------------------------------------------------------
   1064  13ad
   1065  13ad		       00 00 00    ScoreCurrent ds	3, 0
   1066  13b0							; start levelx and level have to be after ScoreCurrent!
   1067  13b0		       00	   StartLevelX .byte.b	0
   1068  13b1		       00	   StartLevel .byte.b	0
   1069  13b2		       00 00 00    PlayerScores ds	3, 0
   1070  13b5							; levelx and level have to be consecutive variables!
   1071  13b5		       00	   PlayerLevelX .byte.b	0
   1072  13b6		       00	   PlayerLevel .byte.b	0
   1073  13b7		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1074  13bc
   1075  13bc
   1076  13bc
   1077  13bc							;------------------------------------------------------------------------------
   1078  13bc
      0  13bc					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  13bc
      2  13bc
      3  13bc		       03 bc	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $3bc , FREE= $44
      4  13bc					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  13bc				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  13bc				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  13bc				  -	      ERR
      8  13bc					      endif
   1080  13bc
   1081  13bc							;------------------------------------------------------------------------------
   1082  13bc
   1083  13bc							; LEVEL DATA banks can go anywhere - *EXCEPT* for the same bank as the level
   1084  13bc							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_LEVEL_SIZE
   1085  13bc							; which is used as a buffer size inside UnpackLevel.  It's not important if
   1086  13bc							; this is defined before or after, as once the levels have processed it will be
   1087  13bc							; correct. Note, that levels should all be defined BEFORE *OR* AFTER the
   1088  13bc							; UnpackLevel code -- but that they should not be both, nor in the same bank.
   1089  13bc							; TODO: verify above is still valid
   1090  13bc
   1091  13bc
      0  13bc					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  13bc		       03 bc	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $3bc , FREE= $444
      2  13bc					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  13bc				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  13bc				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  13bc				  -	      ERR
      6  13bc					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 3
      0  13bc					      include	"BANK_GENERIC.asm"
      1  13bc							;    Sokoboo - a Sokoban implementation
      2  13bc							;    using a generic tile-based display engine for the Atari 2600
      3  13bc							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  13bc							;
      5  13bc							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  13bc							;
      7  13bc							;    Code related to the generic tile-based display engine was developed by
      8  13bc							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  13bc							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  13bc							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  13bc							;
     12  13bc							;    Code related to music and sound effects uses the TIATracker music player
     13  13bc							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  13bc							;    directory for Apache licensing details.
     15  13bc							;
     16  13bc							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  13bc							;    See the copyright notices in the License directory for a list of level
     18  13bc							;    contributors.
     19  13bc							;
     20  13bc							;    Except where otherwise indicated, this software is released under the
     21  13bc							;    following licensing arrangement...
     22  13bc							;
     23  13bc							;    This program is free software: you can redistribute it and/or modify
     24  13bc							;    it under the terms of the GNU General Public License as published by
     25  13bc							;    the Free Software Foundation, either version 3 of the License, or
     26  13bc							;    (at your option) any later version.
     27  13bc							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  13bc
     29  13bc							;    This program is distributed in the hope that it will be useful,
     30  13bc							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  13bc							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  13bc							;    GNU General Public License for more details.
     33  13bc
     34  13bc							;------------------------------------------------------------------------------
     35  13bc							;##############################################################################
     36  13bc							;------------------------------------------------------------------------------
     37  13bc
      0  13bc					      NEWBANK	GENERIC_BANK_1
      1  1f1e ????				      SEG	GENERIC_BANK_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	GENERIC_BANK_1
     39  1800
     40  1800
     41  1800
      0  1800					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  1800					      ALIGN	$400
      2  1800				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  1800				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
------- FILE DecodeLevel.asm LEVEL 3 PASS 3
      0  1800					      include	"DecodeLevel.asm"
      1  1800							;    Sokoboo - a Sokoban implementation
      2  1800							;    using a generic tile-based display engine for the Atari 2600
      3  1800							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1800							;
      5  1800							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1800							;
      7  1800							;    Code related to the generic tile-based display engine was developed by
      8  1800							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1800							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1800							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1800							;
     12  1800							;    Code related to music and sound effects uses the TIATracker music player
     13  1800							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1800							;    directory for Apache licensing details.
     15  1800							;
     16  1800							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1800							;    See the copyright notices in the License directory for a list of level
     18  1800							;    contributors.
     19  1800							;
     20  1800							;    Except where otherwise indicated, this software is released under the
     21  1800							;    following licensing arrangement...
     22  1800							;
     23  1800							;    This program is free software: you can redistribute it and/or modify
     24  1800							;    it under the terms of the GNU General Public License as published by
     25  1800							;    the Free Software Foundation, either version 3 of the License, or
     26  1800							;    (at your option) any later version.
     27  1800							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1800
     29  1800							;    This program is distributed in the hope that it will be useful,
     30  1800							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1800							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1800							;    GNU General Public License for more details.
     33  1800
     34  1800				   LEVELNUM   SET	0
     35  1800				   NUMBEROFLEVELS SET	0
     36  1800		       00 03	   LEVEL_DEFINITION_SIZE =	3
     37  1800
     38  1800					      MAC	add_level
     39  1800				   LEVEL_ACTIVE_{1} SET	1
     40  1800				   LEVEL_NAMED_{1} =	LEVELNUM
     41  1800					      .byte	<LEVEL_{1}
     42  1800					      .byte	>LEVEL_{1}
     43  1800					      .byte	BANK_LEVEL_{1}
     44  1800							;.byte LEVEL_SIZE_{1}
     45  1800				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
     46  1800				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     47  1800					      ENDM		; {name}
     48  1800
     49  1800				   LevelInformation
     50  1800
     51  1800							; The ordering here corresponds to the ordering when playing...
     52  1800
      0  1800					      ADD_LEVEL	_001_L
      1  1800				   LEVEL_ACTIVE__001_L SET	1
      2  1800		       00 00	   LEVEL_NAMED__001_L =	LEVELNUM
      3  1800		       00		      .byte.b	<LEVEL__001_L
      4  1801		       f0		      .byte.b	>LEVEL__001_L
      5  1802		       04		      .byte.b	BANK_LEVEL__001_L
      6  1803
      7  1803				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1803				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1803					      ADD_LEVEL	_001_R
      1  1803				   LEVEL_ACTIVE__001_R SET	1
      2  1803		       00 03	   LEVEL_NAMED__001_R =	LEVELNUM
      3  1803		       13		      .byte.b	<LEVEL__001_R
      4  1804		       f0		      .byte.b	>LEVEL__001_R
      5  1805		       04		      .byte.b	BANK_LEVEL__001_R
      6  1806
      7  1806				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1806				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1806					      ADD_LEVEL	_002_L
      1  1806				   LEVEL_ACTIVE__002_L SET	1
      2  1806		       00 06	   LEVEL_NAMED__002_L =	LEVELNUM
      3  1806		       20		      .byte.b	<LEVEL__002_L
      4  1807		       f0		      .byte.b	>LEVEL__002_L
      5  1808		       04		      .byte.b	BANK_LEVEL__002_L
      6  1809
      7  1809				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1809				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1809					      ADD_LEVEL	_002_R
      1  1809				   LEVEL_ACTIVE__002_R SET	1
      2  1809		       00 09	   LEVEL_NAMED__002_R =	LEVELNUM
      3  1809		       3a		      .byte.b	<LEVEL__002_R
      4  180a		       f0		      .byte.b	>LEVEL__002_R
      5  180b		       04		      .byte.b	BANK_LEVEL__002_R
      6  180c
      7  180c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  180c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  180c					      ADD_LEVEL	_003_L
      1  180c				   LEVEL_ACTIVE__003_L SET	1
      2  180c		       00 0c	   LEVEL_NAMED__003_L =	LEVELNUM
      3  180c		       63		      .byte.b	<LEVEL__003_L
      4  180d		       f0		      .byte.b	>LEVEL__003_L
      5  180e		       04		      .byte.b	BANK_LEVEL__003_L
      6  180f
      7  180f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  180f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  180f					      ADD_LEVEL	_003_R
      1  180f				   LEVEL_ACTIVE__003_R SET	1
      2  180f		       00 0f	   LEVEL_NAMED__003_R =	LEVELNUM
      3  180f		       90		      .byte.b	<LEVEL__003_R
      4  1810		       f0		      .byte.b	>LEVEL__003_R
      5  1811		       04		      .byte.b	BANK_LEVEL__003_R
      6  1812
      7  1812				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1812				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1812					      ADD_LEVEL	_004_L
      1  1812				   LEVEL_ACTIVE__004_L SET	1
      2  1812		       00 12	   LEVEL_NAMED__004_L =	LEVELNUM
      3  1812		       bb		      .byte.b	<LEVEL__004_L
      4  1813		       f0		      .byte.b	>LEVEL__004_L
      5  1814		       04		      .byte.b	BANK_LEVEL__004_L
      6  1815
      7  1815				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1815				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1815					      ADD_LEVEL	_004_R
      1  1815				   LEVEL_ACTIVE__004_R SET	1
      2  1815		       00 15	   LEVEL_NAMED__004_R =	LEVELNUM
      3  1815		       df		      .byte.b	<LEVEL__004_R
      4  1816		       f0		      .byte.b	>LEVEL__004_R
      5  1817		       04		      .byte.b	BANK_LEVEL__004_R
      6  1818
      7  1818				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1818				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1818					      ADD_LEVEL	_005_L
      1  1818				   LEVEL_ACTIVE__005_L SET	1
      2  1818		       00 18	   LEVEL_NAMED__005_L =	LEVELNUM
      3  1818		       fc		      .byte.b	<LEVEL__005_L
      4  1819		       f0		      .byte.b	>LEVEL__005_L
      5  181a		       04		      .byte.b	BANK_LEVEL__005_L
      6  181b
      7  181b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  181b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  181b					      ADD_LEVEL	_005_R
      1  181b				   LEVEL_ACTIVE__005_R SET	1
      2  181b		       00 1b	   LEVEL_NAMED__005_R =	LEVELNUM
      3  181b		       2f		      .byte.b	<LEVEL__005_R
      4  181c		       f1		      .byte.b	>LEVEL__005_R
      5  181d		       04		      .byte.b	BANK_LEVEL__005_R
      6  181e
      7  181e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  181e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  181e					      ADD_LEVEL	_006_L
      1  181e				   LEVEL_ACTIVE__006_L SET	1
      2  181e		       00 1e	   LEVEL_NAMED__006_L =	LEVELNUM
      3  181e		       6f		      .byte.b	<LEVEL__006_L
      4  181f		       f1		      .byte.b	>LEVEL__006_L
      5  1820		       04		      .byte.b	BANK_LEVEL__006_L
      6  1821
      7  1821				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1821				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1821					      ADD_LEVEL	_006_R
      1  1821				   LEVEL_ACTIVE__006_R SET	1
      2  1821		       00 21	   LEVEL_NAMED__006_R =	LEVELNUM
      3  1821		       ab		      .byte.b	<LEVEL__006_R
      4  1822		       f1		      .byte.b	>LEVEL__006_R
      5  1823		       04		      .byte.b	BANK_LEVEL__006_R
      6  1824
      7  1824				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1824				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1824					      ADD_LEVEL	_007_L
      1  1824				   LEVEL_ACTIVE__007_L SET	1
      2  1824		       00 24	   LEVEL_NAMED__007_L =	LEVELNUM
      3  1824		       ea		      .byte.b	<LEVEL__007_L
      4  1825		       f1		      .byte.b	>LEVEL__007_L
      5  1826		       04		      .byte.b	BANK_LEVEL__007_L
      6  1827
      7  1827				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1827				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1827					      ADD_LEVEL	_007_R
      1  1827				   LEVEL_ACTIVE__007_R SET	1
      2  1827		       00 27	   LEVEL_NAMED__007_R =	LEVELNUM
      3  1827		       18		      .byte.b	<LEVEL__007_R
      4  1828		       f2		      .byte.b	>LEVEL__007_R
      5  1829		       04		      .byte.b	BANK_LEVEL__007_R
      6  182a
      7  182a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  182a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  182a					      ADD_LEVEL	_008_L
      1  182a				   LEVEL_ACTIVE__008_L SET	1
      2  182a		       00 2a	   LEVEL_NAMED__008_L =	LEVELNUM
      3  182a		       4c		      .byte.b	<LEVEL__008_L
      4  182b		       f2		      .byte.b	>LEVEL__008_L
      5  182c		       04		      .byte.b	BANK_LEVEL__008_L
      6  182d
      7  182d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  182d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  182d					      ADD_LEVEL	_008_R
      1  182d				   LEVEL_ACTIVE__008_R SET	1
      2  182d		       00 2d	   LEVEL_NAMED__008_R =	LEVELNUM
      3  182d		       83		      .byte.b	<LEVEL__008_R
      4  182e		       f2		      .byte.b	>LEVEL__008_R
      5  182f		       04		      .byte.b	BANK_LEVEL__008_R
      6  1830
      7  1830				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1830				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1830					      ADD_LEVEL	_009_L
      1  1830				   LEVEL_ACTIVE__009_L SET	1
      2  1830		       00 30	   LEVEL_NAMED__009_L =	LEVELNUM
      3  1830		       b5		      .byte.b	<LEVEL__009_L
      4  1831		       f2		      .byte.b	>LEVEL__009_L
      5  1832		       04		      .byte.b	BANK_LEVEL__009_L
      6  1833
      7  1833				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1833				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1833					      ADD_LEVEL	_009_R
      1  1833				   LEVEL_ACTIVE__009_R SET	1
      2  1833		       00 33	   LEVEL_NAMED__009_R =	LEVELNUM
      3  1833		       e8		      .byte.b	<LEVEL__009_R
      4  1834		       f2		      .byte.b	>LEVEL__009_R
      5  1835		       04		      .byte.b	BANK_LEVEL__009_R
      6  1836
      7  1836				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1836				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1836					      ADD_LEVEL	_010_L
      1  1836				   LEVEL_ACTIVE__010_L SET	1
      2  1836		       00 36	   LEVEL_NAMED__010_L =	LEVELNUM
      3  1836		       19		      .byte.b	<LEVEL__010_L
      4  1837		       f3		      .byte.b	>LEVEL__010_L
      5  1838		       04		      .byte.b	BANK_LEVEL__010_L
      6  1839
      7  1839				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1839				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1839					      ADD_LEVEL	_010_R
      1  1839				   LEVEL_ACTIVE__010_R SET	1
      2  1839		       00 39	   LEVEL_NAMED__010_R =	LEVELNUM
      3  1839		       54		      .byte.b	<LEVEL__010_R
      4  183a		       f3		      .byte.b	>LEVEL__010_R
      5  183b		       04		      .byte.b	BANK_LEVEL__010_R
      6  183c
      7  183c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  183c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  183c					      ADD_LEVEL	_011_L
      1  183c				   LEVEL_ACTIVE__011_L SET	1
      2  183c		       00 3c	   LEVEL_NAMED__011_L =	LEVELNUM
      3  183c		       88		      .byte.b	<LEVEL__011_L
      4  183d		       f3		      .byte.b	>LEVEL__011_L
      5  183e		       04		      .byte.b	BANK_LEVEL__011_L
      6  183f
      7  183f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  183f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  183f					      ADD_LEVEL	_011_R
      1  183f				   LEVEL_ACTIVE__011_R SET	1
      2  183f		       00 3f	   LEVEL_NAMED__011_R =	LEVELNUM
      3  183f		       bc		      .byte.b	<LEVEL__011_R
      4  1840		       f3		      .byte.b	>LEVEL__011_R
      5  1841		       04		      .byte.b	BANK_LEVEL__011_R
      6  1842
      7  1842				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1842				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1842					      ADD_LEVEL	_012_L
      1  1842				   LEVEL_ACTIVE__012_L SET	1
      2  1842		       00 42	   LEVEL_NAMED__012_L =	LEVELNUM
      3  1842		       f7		      .byte.b	<LEVEL__012_L
      4  1843		       f3		      .byte.b	>LEVEL__012_L
      5  1844		       04		      .byte.b	BANK_LEVEL__012_L
      6  1845
      7  1845				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1845				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1845					      ADD_LEVEL	_012_R
      1  1845				   LEVEL_ACTIVE__012_R SET	1
      2  1845		       00 45	   LEVEL_NAMED__012_R =	LEVELNUM
      3  1845		       28		      .byte.b	<LEVEL__012_R
      4  1846		       f4		      .byte.b	>LEVEL__012_R
      5  1847		       04		      .byte.b	BANK_LEVEL__012_R
      6  1848
      7  1848				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1848				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1848					      ADD_LEVEL	_013_L
      1  1848				   LEVEL_ACTIVE__013_L SET	1
      2  1848		       00 48	   LEVEL_NAMED__013_L =	LEVELNUM
      3  1848		       65		      .byte.b	<LEVEL__013_L
      4  1849		       f4		      .byte.b	>LEVEL__013_L
      5  184a		       04		      .byte.b	BANK_LEVEL__013_L
      6  184b
      7  184b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  184b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  184b					      ADD_LEVEL	_013_R
      1  184b				   LEVEL_ACTIVE__013_R SET	1
      2  184b		       00 4b	   LEVEL_NAMED__013_R =	LEVELNUM
      3  184b		       a5		      .byte.b	<LEVEL__013_R
      4  184c		       f4		      .byte.b	>LEVEL__013_R
      5  184d		       04		      .byte.b	BANK_LEVEL__013_R
      6  184e
      7  184e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  184e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  184e					      ADD_LEVEL	_014_L
      1  184e				   LEVEL_ACTIVE__014_L SET	1
      2  184e		       00 4e	   LEVEL_NAMED__014_L =	LEVELNUM
      3  184e		       d9		      .byte.b	<LEVEL__014_L
      4  184f		       f4		      .byte.b	>LEVEL__014_L
      5  1850		       04		      .byte.b	BANK_LEVEL__014_L
      6  1851
      7  1851				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1851				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1851					      ADD_LEVEL	_014_R
      1  1851				   LEVEL_ACTIVE__014_R SET	1
      2  1851		       00 51	   LEVEL_NAMED__014_R =	LEVELNUM
      3  1851		       1d		      .byte.b	<LEVEL__014_R
      4  1852		       f5		      .byte.b	>LEVEL__014_R
      5  1853		       04		      .byte.b	BANK_LEVEL__014_R
      6  1854
      7  1854				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1854				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1854					      ADD_LEVEL	_015_L
      1  1854				   LEVEL_ACTIVE__015_L SET	1
      2  1854		       00 54	   LEVEL_NAMED__015_L =	LEVELNUM
      3  1854		       61		      .byte.b	<LEVEL__015_L
      4  1855		       f5		      .byte.b	>LEVEL__015_L
      5  1856		       04		      .byte.b	BANK_LEVEL__015_L
      6  1857
      7  1857				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1857				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1857					      ADD_LEVEL	_015_R
      1  1857				   LEVEL_ACTIVE__015_R SET	1
      2  1857		       00 57	   LEVEL_NAMED__015_R =	LEVELNUM
      3  1857		       97		      .byte.b	<LEVEL__015_R
      4  1858		       f5		      .byte.b	>LEVEL__015_R
      5  1859		       04		      .byte.b	BANK_LEVEL__015_R
      6  185a
      7  185a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  185a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  185a					      ADD_LEVEL	_016_L
      1  185a				   LEVEL_ACTIVE__016_L SET	1
      2  185a		       00 5a	   LEVEL_NAMED__016_L =	LEVELNUM
      3  185a		       dd		      .byte.b	<LEVEL__016_L
      4  185b		       f5		      .byte.b	>LEVEL__016_L
      5  185c		       04		      .byte.b	BANK_LEVEL__016_L
      6  185d
      7  185d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  185d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  185d					      ADD_LEVEL	_016_R
      1  185d				   LEVEL_ACTIVE__016_R SET	1
      2  185d		       00 5d	   LEVEL_NAMED__016_R =	LEVELNUM
      3  185d		       15		      .byte.b	<LEVEL__016_R
      4  185e		       f6		      .byte.b	>LEVEL__016_R
      5  185f		       04		      .byte.b	BANK_LEVEL__016_R
      6  1860
      7  1860				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1860				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1860					      ADD_LEVEL	_017_L
      1  1860				   LEVEL_ACTIVE__017_L SET	1
      2  1860		       00 60	   LEVEL_NAMED__017_L =	LEVELNUM
      3  1860		       49		      .byte.b	<LEVEL__017_L
      4  1861		       f6		      .byte.b	>LEVEL__017_L
      5  1862		       04		      .byte.b	BANK_LEVEL__017_L
      6  1863
      7  1863				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1863				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1863					      ADD_LEVEL	_017_R
      1  1863				   LEVEL_ACTIVE__017_R SET	1
      2  1863		       00 63	   LEVEL_NAMED__017_R =	LEVELNUM
      3  1863		       94		      .byte.b	<LEVEL__017_R
      4  1864		       f6		      .byte.b	>LEVEL__017_R
      5  1865		       04		      .byte.b	BANK_LEVEL__017_R
      6  1866
      7  1866				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1866				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1866					      ADD_LEVEL	_018_L
      1  1866				   LEVEL_ACTIVE__018_L SET	1
      2  1866		       00 66	   LEVEL_NAMED__018_L =	LEVELNUM
      3  1866		       d8		      .byte.b	<LEVEL__018_L
      4  1867		       f6		      .byte.b	>LEVEL__018_L
      5  1868		       04		      .byte.b	BANK_LEVEL__018_L
      6  1869
      7  1869				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1869				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1869					      ADD_LEVEL	_018_R
      1  1869				   LEVEL_ACTIVE__018_R SET	1
      2  1869		       00 69	   LEVEL_NAMED__018_R =	LEVELNUM
      3  1869		       0d		      .byte.b	<LEVEL__018_R
      4  186a		       f7		      .byte.b	>LEVEL__018_R
      5  186b		       04		      .byte.b	BANK_LEVEL__018_R
      6  186c
      7  186c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  186c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  186c					      ADD_LEVEL	_019_L
      1  186c				   LEVEL_ACTIVE__019_L SET	1
      2  186c		       00 6c	   LEVEL_NAMED__019_L =	LEVELNUM
      3  186c		       4a		      .byte.b	<LEVEL__019_L
      4  186d		       f7		      .byte.b	>LEVEL__019_L
      5  186e		       04		      .byte.b	BANK_LEVEL__019_L
      6  186f
      7  186f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  186f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  186f					      ADD_LEVEL	_019_R
      1  186f				   LEVEL_ACTIVE__019_R SET	1
      2  186f		       00 6f	   LEVEL_NAMED__019_R =	LEVELNUM
      3  186f		       86		      .byte.b	<LEVEL__019_R
      4  1870		       f7		      .byte.b	>LEVEL__019_R
      5  1871		       04		      .byte.b	BANK_LEVEL__019_R
      6  1872
      7  1872				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1872				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1872					      ADD_LEVEL	_020_L
      1  1872				   LEVEL_ACTIVE__020_L SET	1
      2  1872		       00 72	   LEVEL_NAMED__020_L =	LEVELNUM
      3  1872		       00		      .byte.b	<LEVEL__020_L
      4  1873		       f0		      .byte.b	>LEVEL__020_L
      5  1874		       05		      .byte.b	BANK_LEVEL__020_L
      6  1875
      7  1875				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1875				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1875					      ADD_LEVEL	_020_R
      1  1875				   LEVEL_ACTIVE__020_R SET	1
      2  1875		       00 75	   LEVEL_NAMED__020_R =	LEVELNUM
      3  1875		       40		      .byte.b	<LEVEL__020_R
      4  1876		       f0		      .byte.b	>LEVEL__020_R
      5  1877		       05		      .byte.b	BANK_LEVEL__020_R
      6  1878
      7  1878				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1878				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1878					      ADD_LEVEL	_021_L
      1  1878				   LEVEL_ACTIVE__021_L SET	1
      2  1878		       00 78	   LEVEL_NAMED__021_L =	LEVELNUM
      3  1878		       81		      .byte.b	<LEVEL__021_L
      4  1879		       f0		      .byte.b	>LEVEL__021_L
      5  187a		       05		      .byte.b	BANK_LEVEL__021_L
      6  187b
      7  187b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  187b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  187b					      ADD_LEVEL	_021_R
      1  187b				   LEVEL_ACTIVE__021_R SET	1
      2  187b		       00 7b	   LEVEL_NAMED__021_R =	LEVELNUM
      3  187b		       d8		      .byte.b	<LEVEL__021_R
      4  187c		       f0		      .byte.b	>LEVEL__021_R
      5  187d		       05		      .byte.b	BANK_LEVEL__021_R
      6  187e
      7  187e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  187e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  187e					      ADD_LEVEL	_022_L
      1  187e				   LEVEL_ACTIVE__022_L SET	1
      2  187e		       00 7e	   LEVEL_NAMED__022_L =	LEVELNUM
      3  187e		       0d		      .byte.b	<LEVEL__022_L
      4  187f		       f1		      .byte.b	>LEVEL__022_L
      5  1880		       05		      .byte.b	BANK_LEVEL__022_L
      6  1881
      7  1881				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1881				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1881					      ADD_LEVEL	_022_R
      1  1881				   LEVEL_ACTIVE__022_R SET	1
      2  1881		       00 81	   LEVEL_NAMED__022_R =	LEVELNUM
      3  1881		       54		      .byte.b	<LEVEL__022_R
      4  1882		       f1		      .byte.b	>LEVEL__022_R
      5  1883		       05		      .byte.b	BANK_LEVEL__022_R
      6  1884
      7  1884				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1884				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1884					      ADD_LEVEL	_023_L
      1  1884				   LEVEL_ACTIVE__023_L SET	1
      2  1884		       00 84	   LEVEL_NAMED__023_L =	LEVELNUM
      3  1884		       91		      .byte.b	<LEVEL__023_L
      4  1885		       f1		      .byte.b	>LEVEL__023_L
      5  1886		       05		      .byte.b	BANK_LEVEL__023_L
      6  1887
      7  1887				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1887				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1887					      ADD_LEVEL	_023_R
      1  1887				   LEVEL_ACTIVE__023_R SET	1
      2  1887		       00 87	   LEVEL_NAMED__023_R =	LEVELNUM
      3  1887		       d3		      .byte.b	<LEVEL__023_R
      4  1888		       f1		      .byte.b	>LEVEL__023_R
      5  1889		       05		      .byte.b	BANK_LEVEL__023_R
      6  188a
      7  188a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  188a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     99  188a
      0  188a					      ADD_LEVEL	_050_L
      1  188a				   LEVEL_ACTIVE__050_L SET	1
      2  188a		       00 8a	   LEVEL_NAMED__050_L =	LEVELNUM
      3  188a		       16		      .byte.b	<LEVEL__050_L
      4  188b		       f2		      .byte.b	>LEVEL__050_L
      5  188c		       05		      .byte.b	BANK_LEVEL__050_L
      6  188d
      7  188d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  188d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  188d					      ADD_LEVEL	_050_R
      1  188d				   LEVEL_ACTIVE__050_R SET	1
      2  188d		       00 8d	   LEVEL_NAMED__050_R =	LEVELNUM
      3  188d		       64		      .byte.b	<LEVEL__050_R
      4  188e		       f2		      .byte.b	>LEVEL__050_R
      5  188f		       05		      .byte.b	BANK_LEVEL__050_R
      6  1890
      7  1890				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1890				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1890					      ADD_LEVEL	_051_L
      1  1890				   LEVEL_ACTIVE__051_L SET	1
      2  1890		       00 90	   LEVEL_NAMED__051_L =	LEVELNUM
      3  1890		       9e		      .byte.b	<LEVEL__051_L
      4  1891		       f2		      .byte.b	>LEVEL__051_L
      5  1892		       05		      .byte.b	BANK_LEVEL__051_L
      6  1893
      7  1893				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1893				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1893					      ADD_LEVEL	_051_R
      1  1893				   LEVEL_ACTIVE__051_R SET	1
      2  1893		       00 93	   LEVEL_NAMED__051_R =	LEVELNUM
      3  1893		       f2		      .byte.b	<LEVEL__051_R
      4  1894		       f2		      .byte.b	>LEVEL__051_R
      5  1895		       05		      .byte.b	BANK_LEVEL__051_R
      6  1896
      7  1896				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1896				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1896					      ADD_LEVEL	_052_L
      1  1896				   LEVEL_ACTIVE__052_L SET	1
      2  1896		       00 96	   LEVEL_NAMED__052_L =	LEVELNUM
      3  1896		       44		      .byte.b	<LEVEL__052_L
      4  1897		       f3		      .byte.b	>LEVEL__052_L
      5  1898		       05		      .byte.b	BANK_LEVEL__052_L
      6  1899
      7  1899				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1899				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1899					      ADD_LEVEL	_052_R
      1  1899				   LEVEL_ACTIVE__052_R SET	1
      2  1899		       00 99	   LEVEL_NAMED__052_R =	LEVELNUM
      3  1899		       7f		      .byte.b	<LEVEL__052_R
      4  189a		       f3		      .byte.b	>LEVEL__052_R
      5  189b		       05		      .byte.b	BANK_LEVEL__052_R
      6  189c
      7  189c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  189c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  189c					      ADD_LEVEL	_053_L
      1  189c				   LEVEL_ACTIVE__053_L SET	1
      2  189c		       00 9c	   LEVEL_NAMED__053_L =	LEVELNUM
      3  189c		       c8		      .byte.b	<LEVEL__053_L
      4  189d		       f3		      .byte.b	>LEVEL__053_L
      5  189e		       05		      .byte.b	BANK_LEVEL__053_L
      6  189f
      7  189f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  189f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  189f					      ADD_LEVEL	_053_R
      1  189f				   LEVEL_ACTIVE__053_R SET	1
      2  189f		       00 9f	   LEVEL_NAMED__053_R =	LEVELNUM
      3  189f		       1e		      .byte.b	<LEVEL__053_R
      4  18a0		       f4		      .byte.b	>LEVEL__053_R
      5  18a1		       05		      .byte.b	BANK_LEVEL__053_R
      6  18a2
      7  18a2				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a2				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a2					      ADD_LEVEL	_054_L
      1  18a2				   LEVEL_ACTIVE__054_L SET	1
      2  18a2		       00 a2	   LEVEL_NAMED__054_L =	LEVELNUM
      3  18a2		       6c		      .byte.b	<LEVEL__054_L
      4  18a3		       f4		      .byte.b	>LEVEL__054_L
      5  18a4		       05		      .byte.b	BANK_LEVEL__054_L
      6  18a5
      7  18a5				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a5				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a5					      ADD_LEVEL	_054_R
      1  18a5				   LEVEL_ACTIVE__054_R SET	1
      2  18a5		       00 a5	   LEVEL_NAMED__054_R =	LEVELNUM
      3  18a5		       b9		      .byte.b	<LEVEL__054_R
      4  18a6		       f4		      .byte.b	>LEVEL__054_R
      5  18a7		       05		      .byte.b	BANK_LEVEL__054_R
      6  18a8
      7  18a8				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a8				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a8					      ADD_LEVEL	_055_L
      1  18a8				   LEVEL_ACTIVE__055_L SET	1
      2  18a8		       00 a8	   LEVEL_NAMED__055_L =	LEVELNUM
      3  18a8		       03		      .byte.b	<LEVEL__055_L
      4  18a9		       f5		      .byte.b	>LEVEL__055_L
      5  18aa		       05		      .byte.b	BANK_LEVEL__055_L
      6  18ab
      7  18ab				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ab				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ab					      ADD_LEVEL	_055_R
      1  18ab				   LEVEL_ACTIVE__055_R SET	1
      2  18ab		       00 ab	   LEVEL_NAMED__055_R =	LEVELNUM
      3  18ab		       5e		      .byte.b	<LEVEL__055_R
      4  18ac		       f5		      .byte.b	>LEVEL__055_R
      5  18ad		       05		      .byte.b	BANK_LEVEL__055_R
      6  18ae
      7  18ae				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ae				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ae					      ADD_LEVEL	_056_L
      1  18ae				   LEVEL_ACTIVE__056_L SET	1
      2  18ae		       00 ae	   LEVEL_NAMED__056_L =	LEVELNUM
      3  18ae		       b4		      .byte.b	<LEVEL__056_L
      4  18af		       f5		      .byte.b	>LEVEL__056_L
      5  18b0		       05		      .byte.b	BANK_LEVEL__056_L
      6  18b1
      7  18b1				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b1				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18b1					      ADD_LEVEL	_056_R
      1  18b1				   LEVEL_ACTIVE__056_R SET	1
      2  18b1		       00 b1	   LEVEL_NAMED__056_R =	LEVELNUM
      3  18b1		       0f		      .byte.b	<LEVEL__056_R
      4  18b2		       f6		      .byte.b	>LEVEL__056_R
      5  18b3		       05		      .byte.b	BANK_LEVEL__056_R
      6  18b4
      7  18b4				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b4				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18b4					      ADD_LEVEL	_057_L
      1  18b4				   LEVEL_ACTIVE__057_L SET	1
      2  18b4		       00 b4	   LEVEL_NAMED__057_L =	LEVELNUM
      3  18b4		       6b		      .byte.b	<LEVEL__057_L
      4  18b5		       f6		      .byte.b	>LEVEL__057_L
      5  18b6		       05		      .byte.b	BANK_LEVEL__057_L
      6  18b7
      7  18b7				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b7				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    115  18b7
      0  18b7					      ADD_LEVEL	_060_R
      1  18b7				   LEVEL_ACTIVE__060_R SET	1
      2  18b7		       00 b7	   LEVEL_NAMED__060_R =	LEVELNUM
      3  18b7		       00		      .byte.b	<LEVEL__060_R
      4  18b8		       f0		      .byte.b	>LEVEL__060_R
      5  18b9		       06		      .byte.b	BANK_LEVEL__060_R
      6  18ba
      7  18ba				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ba				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ba					      ADD_LEVEL	_061_R
      1  18ba				   LEVEL_ACTIVE__061_R SET	1
      2  18ba		       00 ba	   LEVEL_NAMED__061_R =	LEVELNUM
      3  18ba		       9e		      .byte.b	<LEVEL__061_R
      4  18bb		       f0		      .byte.b	>LEVEL__061_R
      5  18bc		       06		      .byte.b	BANK_LEVEL__061_R
      6  18bd
      7  18bd				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18bd				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18bd					      ADD_LEVEL	_061_L
      1  18bd				   LEVEL_ACTIVE__061_L SET	1
      2  18bd		       00 bd	   LEVEL_NAMED__061_L =	LEVELNUM
      3  18bd		       49		      .byte.b	<LEVEL__061_L
      4  18be		       f0		      .byte.b	>LEVEL__061_L
      5  18bf		       06		      .byte.b	BANK_LEVEL__061_L
      6  18c0
      7  18c0				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c0				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c0					      ADD_LEVEL	_062_L
      1  18c0				   LEVEL_ACTIVE__062_L SET	1
      2  18c0		       00 c0	   LEVEL_NAMED__062_L =	LEVELNUM
      3  18c0		       e8		      .byte.b	<LEVEL__062_L
      4  18c1		       f0		      .byte.b	>LEVEL__062_L
      5  18c2		       06		      .byte.b	BANK_LEVEL__062_L
      6  18c3
      7  18c3				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c3				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c3					      ADD_LEVEL	_062_R
      1  18c3				   LEVEL_ACTIVE__062_R SET	1
      2  18c3		       00 c3	   LEVEL_NAMED__062_R =	LEVELNUM
      3  18c3		       40		      .byte.b	<LEVEL__062_R
      4  18c4		       f1		      .byte.b	>LEVEL__062_R
      5  18c5		       06		      .byte.b	BANK_LEVEL__062_R
      6  18c6
      7  18c6				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c6				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c6					      ADD_LEVEL	_063_L
      1  18c6				   LEVEL_ACTIVE__063_L SET	1
      2  18c6		       00 c6	   LEVEL_NAMED__063_L =	LEVELNUM
      3  18c6		       8d		      .byte.b	<LEVEL__063_L
      4  18c7		       f1		      .byte.b	>LEVEL__063_L
      5  18c8		       06		      .byte.b	BANK_LEVEL__063_L
      6  18c9
      7  18c9				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c9				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c9					      ADD_LEVEL	_063_R
      1  18c9				   LEVEL_ACTIVE__063_R SET	1
      2  18c9		       00 c9	   LEVEL_NAMED__063_R =	LEVELNUM
      3  18c9		       de		      .byte.b	<LEVEL__063_R
      4  18ca		       f1		      .byte.b	>LEVEL__063_R
      5  18cb		       06		      .byte.b	BANK_LEVEL__063_R
      6  18cc
      7  18cc				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18cc				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18cc					      ADD_LEVEL	_064_R
      1  18cc				   LEVEL_ACTIVE__064_R SET	1
      2  18cc		       00 cc	   LEVEL_NAMED__064_R =	LEVELNUM
      3  18cc		       8d		      .byte.b	<LEVEL__064_R
      4  18cd		       f2		      .byte.b	>LEVEL__064_R
      5  18ce		       06		      .byte.b	BANK_LEVEL__064_R
      6  18cf
      7  18cf				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18cf				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18cf					      ADD_LEVEL	_064_L
      1  18cf				   LEVEL_ACTIVE__064_L SET	1
      2  18cf		       00 cf	   LEVEL_NAMED__064_L =	LEVELNUM
      3  18cf		       31		      .byte.b	<LEVEL__064_L
      4  18d0		       f2		      .byte.b	>LEVEL__064_L
      5  18d1		       06		      .byte.b	BANK_LEVEL__064_L
      6  18d2
      7  18d2				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18d2				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18d2					      ADD_LEVEL	_065_R
      1  18d2				   LEVEL_ACTIVE__065_R SET	1
      2  18d2		       00 d2	   LEVEL_NAMED__065_R =	LEVELNUM
      3  18d2		       33		      .byte.b	<LEVEL__065_R
      4  18d3		       f3		      .byte.b	>LEVEL__065_R
      5  18d4		       06		      .byte.b	BANK_LEVEL__065_R
      6  18d5
      7  18d5				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18d5				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18d5					      ADD_LEVEL	_065_L
      1  18d5				   LEVEL_ACTIVE__065_L SET	1
      2  18d5		       00 d5	   LEVEL_NAMED__065_L =	LEVELNUM
      3  18d5		       da		      .byte.b	<LEVEL__065_L
      4  18d6		       f2		      .byte.b	>LEVEL__065_L
      5  18d7		       06		      .byte.b	BANK_LEVEL__065_L
      6  18d8
      7  18d8				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18d8				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18d8					      ADD_LEVEL	_066_R
      1  18d8				   LEVEL_ACTIVE__066_R SET	1
      2  18d8		       00 d8	   LEVEL_NAMED__066_R =	LEVELNUM
      3  18d8		       d7		      .byte.b	<LEVEL__066_R
      4  18d9		       f3		      .byte.b	>LEVEL__066_R
      5  18da		       06		      .byte.b	BANK_LEVEL__066_R
      6  18db
      7  18db				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18db				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18db					      ADD_LEVEL	_066_L
      1  18db				   LEVEL_ACTIVE__066_L SET	1
      2  18db		       00 db	   LEVEL_NAMED__066_L =	LEVELNUM
      3  18db		       7c		      .byte.b	<LEVEL__066_L
      4  18dc		       f3		      .byte.b	>LEVEL__066_L
      5  18dd		       06		      .byte.b	BANK_LEVEL__066_L
      6  18de
      7  18de				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18de				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18de					      ADD_LEVEL	_067_R
      1  18de				   LEVEL_ACTIVE__067_R SET	1
      2  18de		       00 de	   LEVEL_NAMED__067_R =	LEVELNUM
      3  18de		       7c		      .byte.b	<LEVEL__067_R
      4  18df		       f4		      .byte.b	>LEVEL__067_R
      5  18e0		       06		      .byte.b	BANK_LEVEL__067_R
      6  18e1
      7  18e1				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18e1				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18e1					      ADD_LEVEL	_067_L
      1  18e1				   LEVEL_ACTIVE__067_L SET	1
      2  18e1		       00 e1	   LEVEL_NAMED__067_L =	LEVELNUM
      3  18e1		       2e		      .byte.b	<LEVEL__067_L
      4  18e2		       f4		      .byte.b	>LEVEL__067_L
      5  18e3		       06		      .byte.b	BANK_LEVEL__067_L
      6  18e4
      7  18e4				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18e4				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18e4					      ADD_LEVEL	_068_R
      1  18e4				   LEVEL_ACTIVE__068_R SET	1
      2  18e4		       00 e4	   LEVEL_NAMED__068_R =	LEVELNUM
      3  18e4		       37		      .byte.b	<LEVEL__068_R
      4  18e5		       f5		      .byte.b	>LEVEL__068_R
      5  18e6		       06		      .byte.b	BANK_LEVEL__068_R
      6  18e7
      7  18e7				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18e7				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18e7					      ADD_LEVEL	_068_L
      1  18e7				   LEVEL_ACTIVE__068_L SET	1
      2  18e7		       00 e7	   LEVEL_NAMED__068_L =	LEVELNUM
      3  18e7		       e2		      .byte.b	<LEVEL__068_L
      4  18e8		       f4		      .byte.b	>LEVEL__068_L
      5  18e9		       06		      .byte.b	BANK_LEVEL__068_L
      6  18ea
      7  18ea				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ea				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ea					      ADD_LEVEL	_069_R
      1  18ea				   LEVEL_ACTIVE__069_R SET	1
      2  18ea		       00 ea	   LEVEL_NAMED__069_R =	LEVELNUM
      3  18ea		       dd		      .byte.b	<LEVEL__069_R
      4  18eb		       f5		      .byte.b	>LEVEL__069_R
      5  18ec		       06		      .byte.b	BANK_LEVEL__069_R
      6  18ed
      7  18ed				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ed				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ed					      ADD_LEVEL	_069_L
      1  18ed				   LEVEL_ACTIVE__069_L SET	1
      2  18ed		       00 ed	   LEVEL_NAMED__069_L =	LEVELNUM
      3  18ed		       8e		      .byte.b	<LEVEL__069_L
      4  18ee		       f5		      .byte.b	>LEVEL__069_L
      5  18ef		       06		      .byte.b	BANK_LEVEL__069_L
      6  18f0
      7  18f0				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f0				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    135  18f0
      0  18f0					      ADD_LEVEL	_103_Arielle
      1  18f0				   LEVEL_ACTIVE__103_Arielle SET	1
      2  18f0		       00 f0	   LEVEL_NAMED__103_Arielle =	LEVELNUM
      3  18f0		       ef		      .byte.b	<LEVEL__103_Arielle
      4  18f1		       f1		      .byte.b	>LEVEL__103_Arielle
      5  18f2		       07		      .byte.b	BANK_LEVEL__103_Arielle
      6  18f3
      7  18f3				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f3				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18f3					      ADD_LEVEL	_103_Ajalae
      1  18f3				   LEVEL_ACTIVE__103_Ajalae SET	1
      2  18f3		       00 f3	   LEVEL_NAMED__103_Ajalae =	LEVELNUM
      3  18f3		       a7		      .byte.b	<LEVEL__103_Ajalae
      4  18f4		       f1		      .byte.b	>LEVEL__103_Ajalae
      5  18f5		       07		      .byte.b	BANK_LEVEL__103_Ajalae
      6  18f6
      7  18f6				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f6				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18f6					      ADD_LEVEL	_103_Adin
      1  18f6				   LEVEL_ACTIVE__103_Adin SET	1
      2  18f6		       00 f6	   LEVEL_NAMED__103_Adin =	LEVELNUM
      3  18f6		       5b		      .byte.b	<LEVEL__103_Adin
      4  18f7		       f1		      .byte.b	>LEVEL__103_Adin
      5  18f8		       07		      .byte.b	BANK_LEVEL__103_Adin
      6  18f9
      7  18f9				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f9				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18f9					      ADD_LEVEL	_102_Raven
      1  18f9				   LEVEL_ACTIVE__102_Raven SET	1
      2  18f9		       00 f9	   LEVEL_NAMED__102_Raven =	LEVELNUM
      3  18f9		       ec		      .byte.b	<LEVEL__102_Raven
      4  18fa		       f0		      .byte.b	>LEVEL__102_Raven
      5  18fb		       07		      .byte.b	BANK_LEVEL__102_Raven
      6  18fc
      7  18fc				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18fc				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18fc					      ADD_LEVEL	_102_Oralia
      1  18fc				   LEVEL_ACTIVE__102_Oralia SET	1
      2  18fc		       00 fc	   LEVEL_NAMED__102_Oralia =	LEVELNUM
      3  18fc		       a7		      .byte.b	<LEVEL__102_Oralia
      4  18fd		       f0		      .byte.b	>LEVEL__102_Oralia
      5  18fe		       07		      .byte.b	BANK_LEVEL__102_Oralia
      6  18ff
      7  18ff				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ff				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ff					      ADD_LEVEL	_102_Natalie
      1  18ff				   LEVEL_ACTIVE__102_Natalie SET	1
      2  18ff		       00 ff	   LEVEL_NAMED__102_Natalie =	LEVELNUM
      3  18ff		       00		      .byte.b	<LEVEL__102_Natalie
      4  1900		       f0		      .byte.b	>LEVEL__102_Natalie
      5  1901		       07		      .byte.b	BANK_LEVEL__102_Natalie
      6  1902
      7  1902				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1902				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1902					      ADD_LEVEL	_102_Mirabel
      1  1902				   LEVEL_ACTIVE__102_Mirabel SET	1
      2  1902		       01 02	   LEVEL_NAMED__102_Mirabel =	LEVELNUM
      3  1902		       47		      .byte.b	<LEVEL__102_Mirabel
      4  1903		       f0		      .byte.b	>LEVEL__102_Mirabel
      5  1904		       07		      .byte.b	BANK_LEVEL__102_Mirabel
      6  1905
      7  1905				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1905				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1905					      ADD_LEVEL	_1XJH_Tara_Gelson
      1  1905				   LEVEL_ACTIVE__1XJH_Tara_Gelson SET	1
      2  1905		       01 05	   LEVEL_NAMED__1XJH_Tara_Gelson =	LEVELNUM
      3  1905		       40		      .byte.b	<LEVEL__1XJH_Tara_Gelson
      4  1906		       f2		      .byte.b	>LEVEL__1XJH_Tara_Gelson
      5  1907		       07		      .byte.b	BANK_LEVEL__1XJH_Tara_Gelson
      6  1908
      7  1908				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1908				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1908					      ADD_LEVEL	_1R7X_Alison
      1  1908				   LEVEL_ACTIVE__1R7X_Alison SET	1
      2  1908		       01 08	   LEVEL_NAMED__1R7X_Alison =	LEVELNUM
      3  1908		       7b		      .byte.b	<LEVEL__1R7X_Alison
      4  1909		       f2		      .byte.b	>LEVEL__1R7X_Alison
      5  190a		       07		      .byte.b	BANK_LEVEL__1R7X_Alison
      6  190b
      7  190b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  190b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  190b					      ADD_LEVEL	_1KWD_Cecile_Clayworth
      1  190b				   LEVEL_ACTIVE__1KWD_Cecile_Clayworth SET	1
      2  190b		       01 0b	   LEVEL_NAMED__1KWD_Cecile_Clayworth =	LEVELNUM
      3  190b		       a9		      .byte.b	<LEVEL__1KWD_Cecile_Clayworth
      4  190c		       f2		      .byte.b	>LEVEL__1KWD_Cecile_Clayworth
      5  190d		       07		      .byte.b	BANK_LEVEL__1KWD_Cecile_Clayworth
      6  190e
      7  190e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  190e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  190e					      ADD_LEVEL	_1EKT_Samantha_Gelson
      1  190e				   LEVEL_ACTIVE__1EKT_Samantha_Gelson SET	1
      2  190e		       01 0e	   LEVEL_NAMED__1EKT_Samantha_Gelson =	LEVELNUM
      3  190e		       de		      .byte.b	<LEVEL__1EKT_Samantha_Gelson
      4  190f		       f2		      .byte.b	>LEVEL__1EKT_Samantha_Gelson
      5  1910		       07		      .byte.b	BANK_LEVEL__1EKT_Samantha_Gelson
      6  1911
      7  1911				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1911				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1911					      ADD_LEVEL	_0VM5_Andrea_Wadd
      1  1911				   LEVEL_ACTIVE__0VM5_Andrea_Wadd SET	1
      2  1911		       01 11	   LEVEL_NAMED__0VM5_Andrea_Wadd =	LEVELNUM
      3  1911		       18		      .byte.b	<LEVEL__0VM5_Andrea_Wadd
      4  1912		       f3		      .byte.b	>LEVEL__0VM5_Andrea_Wadd
      5  1913		       07		      .byte.b	BANK_LEVEL__0VM5_Andrea_Wadd
      6  1914
      7  1914				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1914				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1914					      ADD_LEVEL	_0PAL_Jill_Leatherby
      1  1914				   LEVEL_ACTIVE__0PAL_Jill_Leatherby SET	1
      2  1914		       01 14	   LEVEL_NAMED__0PAL_Jill_Leatherby =	LEVELNUM
      3  1914		       46		      .byte.b	<LEVEL__0PAL_Jill_Leatherby
      4  1915		       f3		      .byte.b	>LEVEL__0PAL_Jill_Leatherby
      5  1916		       07		      .byte.b	BANK_LEVEL__0PAL_Jill_Leatherby
      6  1917
      7  1917				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1917				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1917					      ADD_LEVEL	_0IZ1_Sophia
      1  1917				   LEVEL_ACTIVE__0IZ1_Sophia SET	1
      2  1917		       01 17	   LEVEL_NAMED__0IZ1_Sophia =	LEVELNUM
      3  1917		       71		      .byte.b	<LEVEL__0IZ1_Sophia
      4  1918		       f3		      .byte.b	>LEVEL__0IZ1_Sophia
      5  1919		       07		      .byte.b	BANK_LEVEL__0IZ1_Sophia
      6  191a
      7  191a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  191a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  191a					      ADD_LEVEL	_0CNH_Alice
      1  191a				   LEVEL_ACTIVE__0CNH_Alice SET	1
      2  191a		       01 1a	   LEVEL_NAMED__0CNH_Alice =	LEVELNUM
      3  191a		       9d		      .byte.b	<LEVEL__0CNH_Alice
      4  191b		       f3		      .byte.b	>LEVEL__0CNH_Alice
      5  191c		       07		      .byte.b	BANK_LEVEL__0CNH_Alice
      6  191d
      7  191d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  191d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  191d					      ADD_LEVEL	Thomas_Reinke16
      1  191d				   LEVEL_ACTIVE_Thomas_Reinke16 SET	1
      2  191d		       01 1d	   LEVEL_NAMED_Thomas_Reinke16 =	LEVELNUM
      3  191d		       6d		      .byte.b	<LEVEL_Thomas_Reinke16
      4  191e		       f5		      .byte.b	>LEVEL_Thomas_Reinke16
      5  191f		       07		      .byte.b	BANK_LEVEL_Thomas_Reinke16
      6  1920
      7  1920				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1920				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1920					      ADD_LEVEL	bDarcy_Burnsell101
      1  1920				   LEVEL_ACTIVE_bDarcy_Burnsell101 SET	1
      2  1920		       01 20	   LEVEL_NAMED_bDarcy_Burnsell101 =	LEVELNUM
      3  1920		       f3		      .byte.b	<LEVEL_bDarcy_Burnsell101
      4  1921		       f4		      .byte.b	>LEVEL_bDarcy_Burnsell101
      5  1922		       07		      .byte.b	BANK_LEVEL_bDarcy_Burnsell101
      6  1923
      7  1923				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1923				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1923					      ADD_LEVEL	bAlfa_DrFogh
      1  1923				   LEVEL_ACTIVE_bAlfa_DrFogh SET	1
      2  1923		       01 23	   LEVEL_NAMED_bAlfa_DrFogh =	LEVELNUM
      3  1923		       ca		      .byte.b	<LEVEL_bAlfa_DrFogh
      4  1924		       f3		      .byte.b	>LEVEL_bAlfa_DrFogh
      5  1925		       07		      .byte.b	BANK_LEVEL_bAlfa_DrFogh
      6  1926
      7  1926				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1926				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1926					      ADD_LEVEL	bAislin101
      1  1926				   LEVEL_ACTIVE_bAislin101 SET	1
      2  1926		       01 26	   LEVEL_NAMED_bAislin101 =	LEVELNUM
      3  1926		       30		      .byte.b	<LEVEL_bAislin101
      4  1927		       f5		      .byte.b	>LEVEL_bAislin101
      5  1928		       07		      .byte.b	BANK_LEVEL_bAislin101
      6  1929
      7  1929				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1929				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1929					      ADD_LEVEL	b51X_Sharpen
      1  1929				   LEVEL_ACTIVE_b51X_Sharpen SET	1
      2  1929		       01 29	   LEVEL_NAMED_b51X_Sharpen =	LEVELNUM
      3  1929		       72		      .byte.b	<LEVEL_b51X_Sharpen
      4  192a		       f4		      .byte.b	>LEVEL_b51X_Sharpen
      5  192b		       07		      .byte.b	BANK_LEVEL_b51X_Sharpen
      6  192c
      7  192c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  192c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    156  192c							;    ADD_LEVEL b82X_Sharpen
    157  192c
    158  192c
    159  192c				   finX
    160  192c							; now put the soil in - fill from the outsides
    161  192c
    162  192c		       a9 01		      lda	#CHARACTER_SOIL
    163  192e		       85 8e		      sta	POS_Type
    164  1930
    165  1930		       a9 15		      lda	#SIZE_BOARD_Y-1
    166  1932		       85 8b		      sta	POS_Y
    167  1934
    168  1934		       a9 27	   xlin       lda	#SIZE_BOARD_X-1
    169  1936		       85 8a		      sta	POS_X
    170  1938		       20 29 f8    zap1       jsr	GetBoardCharacter__CALL_FROM_RAM__
    171  193b		       c9 01		      cmp	#CHARACTER_SOIL
    172  193d		       f0 07		      beq	kg2a
    173  193f		       c9 00		      cmp	#0
    174  1941		       d0 07		      bne	endzap1
    175  1943		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    176  1946		       c6 8a	   kg2a       dec	POS_X
    177  1948		       10 ee		      bpl	zap1
    178  194a
    179  194a		       a9 00	   endzap1    lda	#0
    180  194c		       85 8a		      sta	POS_X
    181  194e		       20 29 f8    zap2       jsr	GetBoardCharacter__CALL_FROM_RAM__
    182  1951		       c9 01		      cmp	#CHARACTER_SOIL
    183  1953		       f0 07		      beq	kg2
    184  1955		       c9 00		      cmp	#0
    185  1957		       d0 0b		      bne	endzap2
    186  1959		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    187  195c		       e6 8a	   kg2	      inc	POS_X
    188  195e		       a5 8a		      lda	POS_X
    189  1960		       c9 28		      cmp	#SIZE_BOARD_X
    190  1962		       d0 ea		      bne	zap2
    191  1964
    192  1964		       c6 8b	   endzap2    dec	POS_Y
    193  1966		       10 cc		      bpl	xlin
    194  1968
    195  1968
    196  1968		       a9 27		      lda	#SIZE_BOARD_X-1
    197  196a		       85 8a		      sta	POS_X
    198  196c
    199  196c		       a9 15	   ylin       lda	#SIZE_BOARD_Y-1
    200  196e		       85 8b		      sta	POS_Y
    201  1970		       20 29 f8    zapy1      jsr	GetBoardCharacter__CALL_FROM_RAM__
    202  1973		       c9 01		      cmp	#CHARACTER_SOIL
    203  1975		       f0 07		      beq	kg3
    204  1977		       c9 00		      cmp	#0
    205  1979		       d0 07		      bne	endzapy1
    206  197b		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    207  197e		       c6 8b	   kg3	      dec	POS_Y
    208  1980		       10 ee		      bpl	zapy1
    209  1982
    210  1982		       a9 00	   endzapy1   lda	#0
    211  1984		       85 8b		      sta	POS_Y
    212  1986		       20 29 f8    zapy2      jsr	GetBoardCharacter__CALL_FROM_RAM__
    213  1989		       c9 01		      cmp	#CHARACTER_SOIL
    214  198b		       f0 07		      beq	kg3b
    215  198d		       c9 00		      cmp	#0
    216  198f		       d0 0b		      bne	endzapy2
    217  1991		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    218  1994		       e6 8b	   kg3b       inc	POS_Y
    219  1996		       a5 8b		      lda	POS_Y
    220  1998		       c9 16		      cmp	#SIZE_BOARD_Y
    221  199a		       d0 ea		      bne	zapy2
    222  199c
    223  199c		       c6 8a	   endzapy2   dec	POS_X
    224  199e		       10 cc		      bpl	ylin
    225  19a0		       60		      rts
    226  19a1
      0  19a1					      DEFINE_SUBROUTINE	RegisterOneMoreTarget
      1  19a1		       00 03	   BANK_RegisterOneMoreTarget =	_CURRENT_BANK
      2  19a1					      SUBROUTINE
      3  19a1				   RegisterOneMoreTarget
    228  19a1
    229  19a1		       f8		      sed
    230  19a2		       18		      clc
    231  19a3		       a5 b9		      lda	targetsRequired
    232  19a5		       69 01		      adc	#1
    233  19a7		       85 b9		      sta	targetsRequired
    234  19a9		       d8		      cld
    235  19aa		       60		      rts
    236  19ab
    237  19ab							;A	 steel wall
    238  19ab							;B	 soil (surround)
    239  19ab							;C	 box
    240  19ab
    241  19ab
    242  19ab				   C1
    243  19ab		       98 2a a8 48	      .byte.b	$98,$2A,$a8,$48
    244  19af		       c8 08 28 98	      .byte.b	$C8,$08,$28,$98
    245  19b3				   C2
    246  19b3		       04 d4 22 84	      .byte.b	$04,$D4,$22,$84
    247  19b7		       44 86 b4 64	      .byte.b	$44,$86,$B4,$64
    248  19bb				   C3
    249  19bb		       28 7a f8 b8	      .byte.b	$28,$7A,$f8,$B8
    250  19bf		       fc c6 98 28	      .byte.b	$FC,$C6,$98,$28
    251  19c3
    252  19c3							; C6 44 2A	 browns
    253  19c3							; BA 96 E8	 ice blues
    254  19c3
    255  19c3
      0  19c3					      DEFINE_SUBROUTINE	UnpackLevel
      1  19c3		       00 03	   BANK_UnpackLevel =	_CURRENT_BANK
      2  19c3					      SUBROUTINE
      3  19c3				   UnpackLevel
    257  19c3
    258  19c3		       85 c5		      sta	RAM_Bank
    259  19c5
    260  19c5							; has to be done before decoding the level to have the platform right:
      0  19c5					      SET_PLATFORM
      1  19c5
      2  19c5
      3  19c5
      4  19c5
      5  19c5		       ad 82 02 	      lda	SWCHB
      6  19c8		       2a		      rol
      7  19c9		       2a		      rol
      8  19ca		       2a		      rol
      9  19cb		       29 03		      and	#%11
     10  19cd					      if	NTSC_MODE = NO
     11  19cd		       49 02		      eor	#PAL
     12  19cf					      endif
     13  19cf		       a9 00		      lda	#0
     14  19d1		       85 81		      sta	Platform
    262  19d3
    263  19d3		       a9 01		      lda	#CHARACTER_SOIL
    264  19d5		       85 8e		      sta	POS_Type
    265  19d7
    266  19d7		       a9 15		      lda	#SIZE_BOARD_Y-1
    267  19d9		       85 8b		      sta	POS_Y
    268  19db		       a9 27	   xyLine     lda	#SIZE_BOARD_X-1
    269  19dd		       85 8a		      sta	POS_X
    270  19df		       20 3d f8    xyClear    jsr	PutBoardCharacterFromRAM
    271  19e2		       c6 8a		      dec	POS_X
    272  19e4		       10 f9		      bpl	xyClear
    273  19e6		       c6 8b		      dec	POS_Y
    274  19e8		       10 f1		      bpl	xyLine
    275  19ea
    276  19ea		       a9 06		      lda	#6
    277  19ec		       85 da		      sta	base_x
    278  19ee		       85 db		      sta	base_y
    279  19f0
    280  19f0		       a5 ca		      lda	NextLevelTrigger
    281  19f2		       09 80		      ora	#BIT_NEXTLEVEL
    282  19f4		       85 ca		      sta	NextLevelTrigger
    283  19f6
    284  19f6		       a5 b4		      lda	levelX
    285  19f8		       0a		      asl
    286  19f9		       65 b4		      adc	levelX
    287  19fb		       a8		      tay
    288  19fc		       38		      sec
    289  19fd		       b9 00 f0 	      lda	LevelInformation,y
    290  1a00		       e9 01		      sbc	#1
    291  1a02		       85 c0		      sta	Board_AddressR
    292  1a04		       b9 01 f0 	      lda	LevelInformation+1,y
    293  1a07		       e9 00		      sbc	#0
    294  1a09		       85 c1		      sta	Board_AddressR+1
    295  1a0b		       b9 02 f0 	      lda	LevelInformation+2,y
    296  1a0e		       85 b0		      sta	LEVEL_bank
    297  1a10
    298  1a10		       a9 03		      lda	#BANK_UnpackLevel	; the *ROM* bank of this routine (NOT RAM)
    299  1a12		       85 c4		      sta	ROM_Bank	; GetROMByte returns to this bank
    300  1a14
    301  1a14		       a5 b4		      lda	levelX
    302  1a16		       29 07		      and	#7
    303  1a18		       aa		      tax
    304  1a19		       bd ab f1 	      lda	C1,x
    305  1a1c		       85 bd		      sta	color
    306  1a1e		       bd b3 f1 	      lda	C2,x
    307  1a21		       85 be		      sta	color+1
    308  1a23		       bd bb f1 	      lda	C3,x
    309  1a26		       85 bf		      sta	color+2
    310  1a28
    311  1a28							;NEXT_RANDOM
    312  1a28							;and #$F0
    313  1a28							;ora #$A
    314  1a28							;lda #$ba
    315  1a28							;sta color
    316  1a28							;lda #$96
    317  1a28							;lda #$A0
    318  1a28							;sta color+1
    319  1a28							;lda #$e8 ;lda #$9C
    320  1a28							;sta color+2
    321  1a28
    322  1a28							; good colours
    323  1a28
    324  1a28
    325  1a28		       a9 00		      lda	#$00
    326  1a2a		       85 ba		      sta	moveCounter
    327  1a2c		       85 bb		      sta	moveCounterHi
    328  1a2e		       85 bc		      sta	moveCounterBinary
    329  1a30
    330  1a30		       a9 00		      lda	#$00	; BCD reminder!
    331  1a32		       85 b9		      sta	targetsRequired	; # of targets that do NOT have boxes on them
    332  1a34
    333  1a34							;lda #SIZE_BOARD_X
    334  1a34							;sta BoardLimit_Width
    335  1a34							;lda #SIZE_BOARD_Y
    336  1a34							;sta BoardLimit_Height
    337  1a34							;lda #$5
    338  1a34							;sta targetsRequired		   ;	   should never be 0
    339  1a34
    340  1a34		       a9 18		      lda	#24	; arbitrary
    341  1a36		       85 b8		      sta	ThrottleSpeed
    342  1a38
    343  1a38							; first fill bg with character_soil
    344  1a38							; then rle unpack level
    345  1a38							; change level colours
    346  1a38
    347  1a38		       a9 00		      lda	#0
    348  1a3a		       85 8a		      sta	POS_X
    349  1a3c		       85 8b		      sta	POS_Y
    350  1a3e		       85 94		      sta	BoardLimit_Width
    351  1a40		       85 95		      sta	BoardLimit_Height
    352  1a42
    353  1a42				   GetNextItem
    354  1a42
    355  1a42		       a9 01		      lda	#1
    356  1a44		       85 dc		      sta	upk_length
    357  1a46		       a9 00		      lda	#0
    358  1a48		       85 dd		      sta	upk_column	; reuse var - this flags a digit already
    359  1a4a
    360  1a4a		       e6 c0	   Get2       inc	Board_AddressR
    361  1a4c		       d0 02		      bne	addrOK
    362  1a4e		       e6 c1		      inc	Board_AddressR+1
    363  1a50				   addrOK
    364  1a50
    365  1a50		       a5 b0		      lda	LEVEL_bank
    366  1a52		       a0 00		      ldy	#0
    367  1a54		       20 12 f8 	      jsr	GetROMByte
    368  1a57		       85 de		      sta	upk_temp	;scratch
    369  1a59
    370  1a59
    371  1a59		       c9 00		      cmp	#0
    372  1a5b		       d0 03		      bne	parse
    373  1a5d		       4c 2c f1 	      jmp	finX
    374  1a60				   parse
    375  1a60		       c9 3a		      cmp	#"9"+1
    376  1a62		       b0 1e		      bcs	notDigit
    377  1a64		       c9 30		      cmp	#"0"
    378  1a66		       90 1a		      bcc	notDigit
    379  1a68
    380  1a68		       a5 dd		      lda	upk_column
    381  1a6a		       f0 09		      beq	firstDig
    382  1a6c
    383  1a6c		       a5 dc		      lda	upk_length
    384  1a6e		       0a		      asl
    385  1a6f		       0a		      asl
    386  1a70		       0a		      asl
    387  1a71		       65 dc		      adc	upk_length
    388  1a73		       65 dc		      adc	upk_length
    389  1a75
    390  1a75		       18	   firstDig   clc
    391  1a76		       65 de		      adc	upk_temp
    392  1a78		       38		      sec
    393  1a79		       e9 30		      sbc	#"0"
    394  1a7b		       85 dc		      sta	upk_length
    395  1a7d		       e6 dd		      inc	upk_column	; flag we have seen a digit
    396  1a7f		       4c 4a f2 	      jmp	Get2
    397  1a82
    398  1a82		       c9 7c	   notDigit   cmp	#"|"	; newline
    399  1a84		       d0 11		      bne	checkWall
    400  1a86
    401  1a86							; Handle new-line
    402  1a86		       a9 00		      lda	#0
    403  1a88		       85 8a		      sta	POS_X
    404  1a8a		       e6 8b		      inc	POS_Y
    405  1a8c
    406  1a8c
    407  1a8c		       a5 8b		      lda	POS_Y
    408  1a8e		       c5 95		      cmp	BoardLimit_Height
    409  1a90		       90 02		      bcc	wOK2
    410  1a92		       85 95		      sta	BoardLimit_Height	;???^^^
    411  1a94				   wOK2
    412  1a94
    413  1a94		       4c 42 f2 	      jmp	GetNextItem
    414  1a97
    415  1a97		       c9 23	   checkWall  cmp	#"#"	; wall
    416  1a99		       d0 09		      bne	checkForGap
    417  1a9b		       a5 b4		      lda	levelX
    418  1a9d		       29 01		      and	#1
    419  1a9f		       18		      clc
    420  1aa0		       69 06		      adc	#CHARACTER_STEEL
    421  1aa2		       d0 66		      bne	WriteChars
    422  1aa4
    423  1aa4		       c9 20	   checkForGap cmp	#32
    424  1aa6		       f0 08		      beq	writeGap
    425  1aa8		       c9 2d		      cmp	#"-"
    426  1aaa		       f0 04		      beq	writeGap
    427  1aac		       c9 5f		      cmp	#"_"
    428  1aae		       d0 05		      bne	checkForMan
    429  1ab0
    430  1ab0		       a9 00	   writeGap   lda	#CHARACTER_BLANK
    431  1ab2		       4c 0a f3 	      jmp	WriteChars
    432  1ab5
    433  1ab5				   checkForMan
    434  1ab5		       c9 2b		      cmp	#"+"	; player on goal square
    435  1ab7		       d0 07		      bne	notPlayerGoal
    436  1ab9
    437  1ab9		       20 a1 f1 	      jsr	RegisterOneMoreTarget
    438  1abc
    439  1abc							; put goal square, init player with POS_VAR = CHARACTER_TARGET
    440  1abc
    441  1abc		       a9 03		      lda	#CHARACTER_TARGET
    442  1abe		       d0 06		      bne	genPlayer
    443  1ac0
    444  1ac0				   notPlayerGoal
    445  1ac0		       c9 40		      cmp	#"@"	; player on normal square
    446  1ac2		       d0 2d		      bne	checkBox
    447  1ac4
    448  1ac4		       a9 00		      lda	#CHARACTER_BLANK
    449  1ac6
    450  1ac6				   genPlayer
    451  1ac6
    452  1ac6		       85 8f		      sta	POS_VAR	; character man is on
    453  1ac8
    454  1ac8		       18		      clc
    455  1ac9		       a5 8a		      lda	POS_X
    456  1acb		       48		      pha
    457  1acc		       65 da		      adc	base_x
    458  1ace		       85 8a		      sta	POS_X
    459  1ad0		       85 9b		      sta	ManX
    460  1ad2
    461  1ad2		       a5 8b		      lda	POS_Y
    462  1ad4		       48		      pha
    463  1ad5		       65 db		      adc	base_y
    464  1ad7		       85 8b		      sta	POS_Y
    465  1ad9		       85 9c		      sta	ManY
    466  1adb
    467  1adb							; POS_X     x position
    468  1adb							; POS_Y     y position
    469  1adb							; POS_VAR   CHARACTER UNDER MAN TO RESTORE
    470  1adb							; POS_Type  type of object
    471  1adb
    472  1adb		       a9 00		      lda	#TYPE_MAN
    473  1add		       85 8e		      sta	POS_Type	;	 creature TYPE
    474  1adf		       20 83 f9 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    475  1ae2
    476  1ae2		       a9 00		      lda	#0
    477  1ae4		       85 9a		      sta	manAnimationIndex
    478  1ae6
    479  1ae6		       68		      pla
    480  1ae7		       85 8b		      sta	POS_Y
    481  1ae9		       68		      pla
    482  1aea		       85 8a		      sta	POS_X
    483  1aec
    484  1aec		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    485  1aee		       4c 0a f3 	      jmp	WriteChars
    486  1af1
    487  1af1		       c9 24	   checkBox   cmp	#"$"
    488  1af3		       d0 04		      bne	checkBoxTarget
    489  1af5
    490  1af5		       a9 02		      lda	#CHARACTER_BOX
    491  1af7		       d0 11		      bne	WriteChars
    492  1af9
    493  1af9		       c9 2a	   checkBoxTarget cmp	#"*"
    494  1afb		       d0 04		      bne	checkTarget
    495  1afd
    496  1afd		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    497  1aff		       d0 09		      bne	WriteChars
    498  1b01
    499  1b01		       c9 2e	   checkTarget cmp	#"."
    500  1b03		       f0 03		      beq	targ
    501  1b05		       4c 42 f2 	      jmp	GetNextItem
    502  1b08				   targ
    503  1b08
    504  1b08		       a9 03		      lda	#CHARACTER_TARGET
    505  1b0a
    506  1b0a		       85 8e	   WriteChars sta	POS_Type
    507  1b0c
    508  1b0c		       18	   Wc2x       clc
    509  1b0d		       a5 8a		      lda	POS_X
    510  1b0f		       48		      pha
    511  1b10		       65 da		      adc	base_x
    512  1b12		       85 8a		      sta	POS_X
    513  1b14
    514  1b14		       a5 8b		      lda	POS_Y
    515  1b16		       48		      pha
    516  1b17		       65 db		      adc	base_y
    517  1b19		       85 8b		      sta	POS_Y
    518  1b1b
    519  1b1b		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    520  1b1e
    521  1b1e		       a5 8e		      lda	POS_Type
    522  1b20		       c9 03		      cmp	#CHARACTER_TARGET
    523  1b22		       d0 03		      bne	notargdet
    524  1b24		       20 a1 f1 	      jsr	RegisterOneMoreTarget
    525  1b27				   notargdet
    526  1b27
    527  1b27		       68		      pla
    528  1b28		       85 8b		      sta	POS_Y
    529  1b2a		       68		      pla
    530  1b2b		       85 8a		      sta	POS_X
    531  1b2d
    532  1b2d		       18		      clc
    533  1b2e		       69 01		      adc	#1
    534  1b30		       85 8a		      sta	POS_X
    535  1b32
    536  1b32		       c5 94		      cmp	BoardLimit_Width
    537  1b34		       90 02		      bcc	wOK
    538  1b36		       85 94		      sta	BoardLimit_Width
    539  1b38				   wOK
    540  1b38
    541  1b38		       c6 dc		      dec	upk_length
    542  1b3a		       d0 d0		      bne	Wc2x
    543  1b3c		       4c 42 f2 	      jmp	GetNextItem
    544  1b3f
    545  1b3f				   finishedUnpack
    546  1b3f
    547  1b3f		       60		      rts
    548  1b3f					      endif
------- FILE BANK_GENERIC.asm
     44  1b40
      0  1b40					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_LEVEL)"
      1  1b40
      2  1b40
      3  1b40		       03 40	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_LEVEL) (1K) SIZE =  $340 , FREE= $c0
      4  1b40					      ECHO	"GENERIC_BANK_1 (DECODE_LEVEL)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1b40				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1b40				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1b40				  -	      ERR
      8  1b40					      endif
     46  1b40
     47  1b40							;------------------------------------------------------------------------------
     48  1b40							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     49  1b40							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     50  1b40							; bank finishes.  Just continue on from where it left off...
     51  1b40							;------------------------------------------------------------------------------
     52  1b40
      0  1b40					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  1b40		       00 03	   BANK_Cart_Init =	_CURRENT_BANK
      2  1b40					      SUBROUTINE
      3  1b40				   Cart_Init
     54  1b40
     55  1b40							; Note the variables from the title selection are incredibly transient an can be stomped
     56  1b40							; at any time.  So they need to be used immediately.
     57  1b40
     58  1b40
     59  1b40							; odd usage below is to prevent any possibility of variable stomping/assumptions
     60  1b40
     61  1b40		       a9 01		      lda	#1
     62  1b42		       a2 00		      ldx	#0	;sLevel				      ; level # from title select
     63  1b44		       a0 00		      ldy	#0	;sJoysticks
     64  1b46		       84 a9		      sty	jtoggle
     65  1b48		       86 b5		      stx	level
     66  1b4a		       85 a7		      sta	ManCount	; = #players
     67  1b4c		       a9 00		      lda	#0
     68  1b4e		       85 b4		      sta	levelX	; make an immediate copy to safe variables!
     69  1b50		       85 e0		      sta	startingLevel
     70  1b52
     71  1b52							; multiply with LEVEL_DEFINITION_SIZE (5):
     72  1b52		       0a		      asl
     73  1b53		       0a		      asl
     74  1b54		       85 b4		      sta	levelX
     75  1b56
     76  1b56		       a9 01		      lda	#1
     77  1b58		       85 99		      sta	whichPlayer	; will switch to 0 on 1st go
     78  1b5a
     79  1b5a		       a9 30		      lda	#NUM_LIVES<<4	; 3 lives
     80  1b5c		       a6 a7		      ldx	ManCount	; = sPlayers
     81  1b5e		       f0 02		      beq	opg
     82  1b60		       a9 33		      lda	#NUM_LIVES<<4|NUM_LIVES
     83  1b62		       85 a7	   opg	      sta	ManCount	; P2P1 nybble each
     84  1b64
     85  1b64							;---------------------------------------------------------------------------
     86  1b64
     87  1b64		       a9 00		      lda	#0
     88  1b66		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     89  1b69		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     90  1b6c		       85 6b		      sta	HMCLR
     91  1b6e
     92  1b6e							; cleanup remains of title screen
     93  1b6e		       85 5b		      sta	GRP0
     94  1b70		       85 5c		      sta	GRP1
     95  1b72		       85 5b		      sta	GRP0
     96  1b74
     97  1b74		       85 89		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     98  1b76		       85 aa		      sta	circle_d
     99  1b78		       85 ab		      sta	circle_d+1
    100  1b7a
    101  1b7a							;    IFCONST DEBUG_CREATURE
    102  1b7a							;		  sta worstTime
    103  1b7a							;    ENDIF
    104  1b7a
    105  1b7a		       a9 04		      lda	#%100	; players/missiles BEHIND BG
    106  1b7c		       85 4a		      sta	CTRLPF
    107  1b7e		       85 82		      sta	rnd	; anything non-0
    108  1b80
    109  1b80		       a9 ff		      lda	#$FF
    110  1b82		       85 84		      sta	DrawStackPointer
    111  1b84		       85 92		      sta	BufferedButton
    112  1b86		       85 93		      sta	BufferedButton+1
    113  1b88
    114  1b88		       a9 07		      lda	#DIRECTION_BITS
    115  1b8a		       85 a4		      sta	ManLastDirection
    116  1b8c
    117  1b8c		       a9 00		      lda	#0
    118  1b8e							;		  sta ObjStackPtr		  ; object stack index of last entry
    119  1b8e							;		  sta ObjStackPtr+1
    120  1b8e							;		  sta ObjStackNum
    121  1b8e							;		  sta ObjIterator
    122  1b8e
    123  1b8e		       85 cc		      sta	sortPtr
    124  1b90		       a9 ff		      lda	#<(-1)
    125  1b92		       85 cb		      sta	sortRequired
    126  1b94
    127  1b94							; read high score from SaveKey and store in highScoreSK,
    128  1b94							; which is transferred to high score variable in RAM by GeneralScoringSetups
    129  1b94		       4c fd f5 	      jmp	ReadSaveKey
    130  1b97
    131  1b97							;LEVEL0CREATURE  .byte TYPE_MAN,	  0,	  3,	  5
    132  1b97							;		  .byte -1
    133  1b97
    134  1b97							;------------------------------------------------------------------------------
    135  1b97
      0  1b97					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  1b97		       00 03	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  1b97					      SUBROUTINE
      3  1b97				   SwapPlayersGeneric
    137  1b97
    138  1b97							; at the start of a level (or player, doesn't matter) we grab the current state of the colour/B&W switch
    139  1b97							; into the gameMode variable.
    140  1b97
    141  1b97		       a5 80		      lda	gameMode
    142  1b99		       29 77		      and	#~(BW_SWITCH|GAMEMODE_PAUSED)
    143  1b9b		       85 80		      sta	gameMode
    144  1b9d		       ad 82 02 	      lda	SWCHB
    145  1ba0		       29 08		      and	#BW_SWITCH
    146  1ba2		       05 80		      ora	gameMode	; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    147  1ba4		       85 80		      sta	gameMode	; also, BIT7=0 -- system is NOT paused
    148  1ba6
    149  1ba6
    150  1ba6							; restart level
    151  1ba6		       a5 ca		      lda	NextLevelTrigger
    152  1ba8		       29 bf		      and	#<(~BIT_NEXTLIFE)
    153  1baa		       85 ca		      sta	NextLevelTrigger
    154  1bac
    155  1bac							; if new high score was set by SwapPlayers, update it:
    156  1bac
    157  1bac		       4c 23 f6 	      jmp	WriteSaveKey
    158  1baf
    159  1baf
    160  1baf							;------------------------------------------------------------------------------
    161  1baf
      0  1baf					      DEFINE_SUBROUTINE	CreateCreatures
      1  1baf		       00 03	   BANK_CreateCreatures =	_CURRENT_BANK
      2  1baf					      SUBROUTINE
      3  1baf				   CreateCreatures
    163  1baf
    164  1baf							; Calculate rightmost value for scrolling edge.  .
    165  1baf
    166  1baf		       85 c4		      sta	ROM_Bank
    167  1bb1
    168  1bb1		       38		      sec
    169  1bb2		       a5 94		      lda	BoardLimit_Width
    170  1bb4		       e9 09		      sbc	#SCREEN_WIDTH-1
    171  1bb6		       85 94		      sta	BoardEdge_Right	; absolute rightmost scroll value
    172  1bb8
    173  1bb8							;		  sec			     already set
    174  1bb8		       a5 95		      lda	BoardLimit_Height
    175  1bba		       e9 07		      sbc	#SCREEN_LINES-1
    176  1bbc		       85 95		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    177  1bbe
    178  1bbe							; kludge position scroll roughly at player
    179  1bbe
    180  1bbe							;		  sec			 already set
    181  1bbe		       a5 9b		      lda	ManX
    182  1bc0		       e9 05		      sbc	#5
    183  1bc2		       b0 02		      bcs	notL0
    184  1bc4		       a9 00		      lda	#0
    185  1bc6		       85 97	   notL0      sta	BoardScrollX
    186  1bc8
    187  1bc8
    188  1bc8		       38		      sec
    189  1bc9		       a5 9c		      lda	ManY
    190  1bcb		       e9 03		      sbc	#3	; TJ: why 5???
    191  1bcd		       b0 02		      bcs	notU0
    192  1bcf		       a9 00		      lda	#0
    193  1bd1		       85 96	   notU0      sta	BoardScrollY
    194  1bd3
    195  1bd3		       a9 00		      lda	#0
    196  1bd5		       85 9f		      sta	ManMode
    197  1bd7		       85 a0		      sta	ManDelayCount
    198  1bd9
    199  1bd9		       a9 1a		      lda	#AnimateBLANK-Manimate	;0 ;<AnimateBLANK ;STAND
    200  1bdb		       85 a1		      sta	ManAnimation
    201  1bdd							;lda #>AnimateBLANK ;
    202  1bdd							;sta ManAnimation+1
    203  1bdd
    204  1bdd		       a9 ff		      lda	#$FF
    205  1bdf		       85 b1		      sta	LastSpriteY
    206  1be1
    207  1be1		       a9 07		      lda	#DIRECTION_BITS
    208  1be3		       85 a4		      sta	ManLastDirection
    209  1be5		       60		      rts
    210  1be6
    211  1be6							;-------------------------------------------------------------------------------------
    212  1be6
      0  1be6					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  1be6		       00 03	   BANK_LevelInit =	_CURRENT_BANK
      2  1be6					      SUBROUTINE
      3  1be6				   LevelInit
    214  1be6
    215  1be6		       a9 00		      lda	#0
    216  1be8		       85 86		      sta	ObjStackPtr
    217  1bea		       85 87		      sta	ObjStackPtr+1	; kill all creatures
    218  1bec		       85 85		      sta	ObjStackNum
    219  1bee		       85 cd		      sta	ObjIterator
    220  1bf0
    221  1bf0		       85 98		      sta	scrollBits
    222  1bf2		       85 89		      sta	ScreenDrawPhase
    223  1bf4
    224  1bf4		       85 b3		      sta	BGColour
    225  1bf6		       85 c6		      sta	ColourTimer
    226  1bf8
    227  1bf8		       85 59		      sta	AUDV0
    228  1bfa		       85 5a		      sta	AUDV1	; turn off music while levels init
    229  1bfc							;		  sta AUDC0
    230  1bfc
    231  1bfc		       85 a4		      sta	ManLastDirection
    232  1bfe		       85 a5		      sta	ManPushCounter
    233  1c00
    234  1c00		       85 cc		      sta	sortPtr	; sort stopped
    235  1c02		       a9 ff		      lda	#<(-1)
    236  1c04		       85 cb		      sta	sortRequired	; nothing needed
    237  1c06		       85 84		      sta	DrawStackPointer
    238  1c08
    239  1c08		       a9 00		      lda	#DISPLAY_TIME	;DISPLAY_SCORE
    240  1c0a		       85 c9		      sta	scoringFlags
    241  1c0c		       a9 00		      lda	#0	;SCORING_TIMER_FIRST		      ; We want the first timer display to be long, to show level and lives
    242  1c0e		       85 c8		      sta	scoringTimer
    243  1c10		       60		      rts
    244  1c11
    245  1c11							;-------------------------------------------------------------------------------------
    246  1c11
      0  1c11					      DEFINE_SUBROUTINE	Resync
      1  1c11		       00 03	   BANK_Resync =	_CURRENT_BANK
      2  1c11					      SUBROUTINE
      3  1c11				   Resync
      0  1c11					      RESYNC
      1  1c11
      2  1c11		       a9 02		      lda	#%10
      3  1c13		       85 41		      sta	VBLANK
      4  1c15
      5  1c15		       a2 08		      ldx	#8
      6  1c17				   .loopResync
      0  1c17					      VERTICAL_SYNC
      1  1c17		       a9 0e		      lda	#%1110
      2  1c19		       85 42	   .VSLP1     sta	WSYNC
      3  1c1b		       85 40		      sta	VSYNC
      4  1c1d		       4a		      lsr
      5  1c1e		       d0 f9		      bne	.VSLP1
      8  1c20
      9  1c20		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  1c22		       a5 81		      lda	Platform
     11  1c24		       49 02		      eor	#PAL_50
     12  1c26		       d0 02		      bne	.ntsc
     13  1c28		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  1c2a				   .ntsc
     15  1c2a				   .loopWait
     16  1c2a		       85 42		      sta	WSYNC
     17  1c2c		       85 42		      sta	WSYNC
     18  1c2e		       88		      dey
     19  1c2f		       d0 f9		      bne	.loopWait
     20  1c31		       ca		      dex
     21  1c32		       d0 e3		      bne	.loopResync
    249  1c34		       60	   Ret	      rts
    250  1c35
    251  1c35							;---------------------------------------------------------------------------
    252  1c35
      0  1c35					      DEFINE_SUBROUTINE	TrackPlayer	; =145; in GENERIC_BANK_1
      1  1c35		       00 03	   BANK_TrackPlayer =	_CURRENT_BANK
      2  1c35					      SUBROUTINE
      3  1c35				   TrackPlayer
    254  1c35
    255  1c35		       a5 a6		      lda	LookingAround	; 3
    256  1c37		       d0 fb		      bne	Ret	; 2/3=5/6   don't track when looking around
    257  1c39
    258  1c39							; Contribution by Thomas Jentzsch
    259  1c39
    260  1c39							; scrolling constants:
    261  1c39		       00 03	   .SCRL_START_LEFT =	3	; 3
    262  1c39		       00 03	   .SCRL_STOP_LEFT =	3	;SCREEN_WIDTH-5		    ; 5 scrolls 5-3+1 = 3 pixel
    263  1c39		       00 07	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT	; 7
    264  1c39		       00 07	   .SCRL_STOP_RIGHT =	SCREEN_WIDTH-.SCRL_STOP_LEFT	; 5
    265  1c39		       00 11	   .SCRL_LEFT_BIT =	%00010001
    266  1c39		       00 22	   .SCRL_RIGHT_BIT =	%00100010
    267  1c39		       00 33	   .SCRL_X_BITS =	.SCRL_LEFT_BIT|.SCRL_RIGHT_BIT
    268  1c39
    269  1c39		       00 02	   .SCRL_START_UP =	2	; 2
    270  1c39		       00 02	   .SCRL_STOP_UP =	2	;SCREEN_LINES-5		    ; 3 scrolls 3-2+1 = 2 pixel
    271  1c39		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP	; 6
    272  1c39		       00 06	   .SCRL_STOP_DOWN =	SCREEN_LINES-.SCRL_STOP_UP	; 5
    273  1c39		       00 44	   .SCRL_UP_BIT =	%01000100
    274  1c39		       00 88	   .SCRL_DOWN_BIT =	%10001000
    275  1c39		       00 cc	   .SCRL_Y_BITS =	.SCRL_UP_BIT|.SCRL_DOWN_BIT
    276  1c39
    277  1c39							; *** horizontal scrolling (unoptimized version): ***
    278  1c39
    279  1c39							; check for enabling horizontal scrolling:
    280  1c39		       a5 9b		      lda	ManX	; 3
    281  1c3b		       38		      sec		; 2
    282  1c3c		       e5 97		      sbc	BoardScrollX	; 3
    283  1c3e		       a8		      tay		; 2	     for later use
    284  1c3f		       a9 11		      lda	#.SCRL_LEFT_BIT	; 2
    285  1c41		       c0 03		      cpy	#.SCRL_START_LEFT	; 2	     <3?
    286  1c43		       30 06		      bmi	.startXScroll	; 2/3	     yes, scroll left
    287  1c45		       c0 07		      cpy	#.SCRL_START_RIGHT	; 2	     <8?
    288  1c47		       30 08		      bmi	.skipStartXScroll	; 2/3	     no
    289  1c49		       a9 22		      lda	#.SCRL_RIGHT_BIT	; 2 = 22    yes, scroll right
    290  1c4b				   .startXScroll
    291  1c4b		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    292  1c4d		       05 98		      ora	scrollBits	; 3
    293  1c4f		       85 98		      sta	scrollBits	; 3 =	8
    294  1c51				   .skipStartXScroll
    295  1c51
    296  1c51							; do horizontal scrolling:
    297  1c51		       a5 98		      lda	scrollBits	; 3
    298  1c53		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    299  1c55		       f0 23		      beq	.skipXScroll	; 2/3
    300  1c57		       29 22		      and	#.SCRL_RIGHT_BIT	; 2
    301  1c59		       d0 0c		      bne	.xScrollRight	; 2/3=11/12
    302  1c5b
    303  1c5b							; scroll left:
    304  1c5b		       a5 97		      lda	BoardScrollX	; 3	     already at left edge?
    305  1c5d		       f0 15		      beq	.stopXScroll	; 2
    306  1c5f		       c6 97		      dec	BoardScrollX	; 5
    307  1c61		       c0 02		      cpy	#.SCRL_STOP_LEFT-1	; 2
    308  1c63		       10 0f		      bpl	.stopXScroll	; 2/3=15
    309  1c65		       30 13		      bmi	.skipXScroll	; 3
    310  1c67							;---------------------------------------
    311  1c67				   .xScrollRight
    312  1c67		       a6 97		      ldx	BoardScrollX	; 3
    313  1c69		       e8		      inx		; 2
    314  1c6a		       e4 94		      cpx	BoardEdge_Right	; 3	     already at right edge?
    315  1c6c		       10 06		      bpl	.stopXScroll	; 2/3
    316  1c6e		       86 97		      stx	BoardScrollX	; 3
    317  1c70		       c0 08		      cpy	#.SCRL_STOP_RIGHT+1	; 2
    318  1c72		       10 06		      bpl	.skipXScroll	; 2/3=17/18
    319  1c74				   .stopXScroll
    320  1c74		       a5 98		      lda	scrollBits	; 3
    321  1c76		       29 fc		      and	#(~(.SCRL_X_BITS >> 4))	; 2
    322  1c78		       85 98		      sta	scrollBits	; 3 =	8
    323  1c7a				   .skipXScroll
    324  1c7a							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    325  1c7a
    326  1c7a							; *** vertical scrolling (unoptimized version): ***
    327  1c7a
    328  1c7a							; check for enabling vertical scrolling:
    329  1c7a		       a5 9c		      lda	ManY	; 3
    330  1c7c		       38		      sec		; 2
    331  1c7d		       e5 96		      sbc	BoardScrollY	; 3
    332  1c7f		       a8		      tay		; 2	     for later use
    333  1c80		       a9 44		      lda	#.SCRL_UP_BIT	; 2
    334  1c82		       c0 02		      cpy	#.SCRL_START_UP	; 2	     <2?
    335  1c84		       30 06		      bmi	.startYScroll	; 2/3	     yes, scroll up
    336  1c86		       c0 06		      cpy	#.SCRL_START_DOWN	; 2	     <6?
    337  1c88		       30 08		      bmi	.skipStartYScroll	; 2/3
    338  1c8a		       a9 88		      lda	#.SCRL_DOWN_BIT	; 2 = 22    yes, scroll down
    339  1c8c				   .startYScroll
    340  1c8c		       29 0c		      and	#.SCRL_Y_BITS >> 4	; 2
    341  1c8e		       05 98		      ora	scrollBits	; 3
    342  1c90		       85 98		      sta	scrollBits	; 3 =	8
    343  1c92				   .skipStartYScroll
    344  1c92
    345  1c92							; do vertical scrolling:
    346  1c92		       a5 98		      lda	scrollBits	; 3
    347  1c94		       29 cc		      and	#.SCRL_Y_BITS	; 2
    348  1c96		       f0 23		      beq	.skipYScroll	; 2/3
    349  1c98		       29 88		      and	#.SCRL_DOWN_BIT	; 2
    350  1c9a		       d0 0c		      bne	.yScrollDown	; 2/3=11/12
    351  1c9c
    352  1c9c							; scroll up
    353  1c9c		       a5 96		      lda	BoardScrollY	; 3
    354  1c9e		       f0 15		      beq	.stopYScroll	; 2
    355  1ca0		       c6 96		      dec	BoardScrollY	; 5
    356  1ca2		       c0 01		      cpy	#.SCRL_STOP_UP-1	; 2
    357  1ca4		       10 0f		      bpl	.stopYScroll	; 2/3=15
    358  1ca6		       30 13		      bmi	.skipYScroll	; 3
    359  1ca8							;---------------------------------------
    360  1ca8				   .yScrollDown
    361  1ca8		       a6 96		      ldx	BoardScrollY	; 3
    362  1caa		       e8		      inx		; 2
    363  1cab		       e4 95		      cpx	BoardEdge_Bottom	;     ; 3
    364  1cad		       10 06		      bpl	.stopYScroll	; 2/3
    365  1caf		       86 96		      stx	BoardScrollY	; 3
    366  1cb1		       c0 07		      cpy	#.SCRL_STOP_DOWN+1	; 2
    367  1cb3		       10 06		      bpl	.skipYScroll	; 2/3=17/18
    368  1cb5				   .stopYScroll
    369  1cb5		       a5 98		      lda	scrollBits	; 3
    370  1cb7		       29 f3		      and	#(~(.SCRL_Y_BITS >> 4))	; 2
    371  1cb9		       85 98		      sta	scrollBits	; 3 =	8
    372  1cbb				   .skipYScroll
    373  1cbb							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    374  1cbb
    375  1cbb		       60	   EarlyAbortx rts		; 6 =	6
    376  1cbc							; total: 5+67*2+6 = 145
    377  1cbc
    378  1cbc							;------------------------------------------------------------------------------
    379  1cbc
    380  1cbc
    381  1cbc
    382  1cbc							; worst case time from positive last check to rts: 123
    383  1cbc							; cycles until 0-check: 15
    384  1cbc							; minimum cycles available after last positive check until timer turns 0: (MINIMUM_SORT_TIME-1)*64+1
    385  1cbc							; MINIMUM_SORT_TIME = 3 = 129
    386  1cbc							; MINIMUM_SORT_TIME = 4 = 193 <- ok
    387  1cbc
    388  1cbc							;------------------------------------------------------------------------------
    389  1cbc
    390  1cbc							; This is a GOOD home for these tables.
    391  1cbc
      0  1cbc					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  1cbc		       00 03	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  1cbc					      SUBROUTINE
      3  1cbc				   TS_PhaseVectorLO
    393  1cbc
    394  1cbc							; Gives LO byte of addresses of subroutines for timeslice processing
    395  1cbc
    396  1cbc		       53		      .byte.b	<ProcessObjStack
    397  1cbd		       db		      .byte.b	<DrawFullScreen
    398  1cbe		       e8		      .byte.b	<BuildDrawStack
    399  1cbf		       ef		      .byte.b	<DrawAIntoStack
    400  1cc0		       96		      .byte.b	<SwitchObjects
    401  1cc1
    402  1cc1				   TS_PhaseVectorHI
    403  1cc1
    404  1cc1							; Gives HI byte of addresses of subroutines for timeslice processing
    405  1cc1
    406  1cc1		       f8		      .byte.b	>ProcessObjStack
    407  1cc2		       f2		      .byte.b	>DrawFullScreen
    408  1cc3		       fa		      .byte.b	>BuildDrawStack
    409  1cc4		       fa		      .byte.b	>DrawAIntoStack
    410  1cc5		       f8		      .byte.b	>SwitchObjects
    411  1cc6
    412  1cc6				   TS_PhaseBank
    413  1cc6
    414  1cc6							; Gives bank of subroutines for timeslice processing
    415  1cc6
    416  1cc6		       0f		      .byte.b	BANK_ProcessObjStack
    417  1cc7		       08		      .byte.b	BANK_DrawFullScreen
    418  1cc8		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    419  1cc9		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    420  1cca		       0f		      .byte.b	BANK_SwitchObjects
    421  1ccb
    422  1ccb							;------------------------------------------------------------------------------
    423  1ccb		       02 02	   lookColour2 .byte.b	$02, $02
    424  1ccd		       04 04		      .byte.b	$04, $04
    425  1ccf
    426  1ccf				   OverscanTime
    427  1ccf		       33 33		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    428  1cd1		       46 33		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    429  1cd3
    430  1cd3
    431  1cd3
    432  1cd3
      0  1cd3					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  1cd3		       00 03	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  1cd3					      SUBROUTINE
      3  1cd3				   PostScreenCleanup
    434  1cd3
    435  1cd3		       c8		      iny		; --> 0
    436  1cd4
    437  1cd4		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    438  1cd6							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    439  1cd6
    440  1cd6		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    441  1cd8							; TJ: no idea why, but you had removed it in revision 758 ;)
    442  1cd8							; completely accidental -- one of our cats may have deleted it.
    443  1cd8		       84 4e		      sty	PF1
    444  1cda		       84 4f		      sty	PF2
    445  1cdc		       84 5d		      sty	ENAM0
    446  1cde		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    447  1ce0		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    448  1ce2
    449  1ce2
    450  1ce2
    451  1ce2							; D1 VBLANK turns off beam
    452  1ce2							; It needs to be turned on 37 scanlines later
    453  1ce2
    454  1ce2		       a9 42		      lda	#%01000010	; bit6 is not required
    455  1ce4		       85 41		      sta	VBLANK	; end of screen - enter blanking
    456  1ce6
    457  1ce6							;------------------------------------------------------------------------------
    458  1ce6							; This is where the PAL system has a bit of extra time on a per-frame basis.
    459  1ce6
    460  1ce6		       a6 81		      ldx	Platform
    461  1ce8		       bd cf f4 	      lda	OverscanTime,x
    462  1ceb		       8d 96 02 	      sta	TIM64T
    463  1cee
    464  1cee							; Background colour priorities. Increasing order of priority...
    465  1cee							;	black -- nothing happening
    466  1cee							;	looking around			     lookingAround<0		     BLUE
    467  1cee							;	when paused			     gameMode... BIT7		     RED
    468  1cee							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    469  1cee
    470  1cee
    471  1cee							;		  lda LookingAround
    472  1cee							;		  bpl nolooker			  ; if not looking around, that will do nicely
    473  1cee							;		  ldy #0 ;sok
    474  1cee							;;		   ldy lookColour2,x		   ; otherwise, use the lookaround colour as the base
    475  1cee							;nolooker	  sty BGColour			  ; 'BASE' colour pause reverts TO when unpaused
    476  1cee
    477  1cee		       a5 b8		      lda	ThrottleSpeed
    478  1cf0		       18		      clc
    479  1cf1		       65 b7		      adc	Throttle
    480  1cf3		       b0 02		      bcs	noVerflo
    481  1cf5		       85 b7		      sta	Throttle
    482  1cf7				   noVerflo
    483  1cf7
    484  1cf7
    485  1cf7							;----------------------------------------------------------------------------------------------
    486  1cf7							; handle pause button for 2600 and 7800
    487  1cf7
    488  1cf7							; Timings:  NOT including palette setting or platform detect
    489  1cf7							; 2600:     no button press:	 11 cycles
    490  1cf7							;	     with button press:  21 cycles
    491  1cf7							; 7800      no button press:	 16 cycles
    492  1cf7							;	     with button press:  21 cycles
    493  1cf7
    494  1cf7
    495  1cf7
    496  1cf7		       00 08	   BW_SWITCH  =	$08	; NOTE: Shares bit position with SWCHB COLOUR/B&W SWITCH
    497  1cf7
    498  1cf7		       24 80		      bit	gameMode
    499  1cf9		       50 0b		      bvc	.pause7800	; 7800 platform
    500  1cfb
    501  1cfb							; 2600 pause logic...
    502  1cfb
    503  1cfb		       ad 82 02 	      lda	SWCHB
    504  1cfe		       45 80		      eor	gameMode
    505  1d00		       29 08		      and	#BW_SWITCH
    506  1d02		       f0 17		      beq	.setPauseCol	; no different to original state = no pause change
    507  1d04		       d0 0f		      bne	.buttonDown	; unconditional
    508  1d06
    509  1d06							; 7800 pause logic...
    510  1d06
    511  1d06							; When the button is pressed, we check if it's the FIRST time it's pressed.
    512  1d06							; This FIRST time is indicated by the PFLAG7800 being clear.  If it's the first time, we toggle the pause
    513  1d06							; flag (BIT6) AND we toggle the PFLAG7800 so continued button-down does nothing.  When the button is
    514  1d06							; released, then we again toggle the PFLAG7800, allowing a FIRST time check once again, when the button
    515  1d06							; is next pressed.
    516  1d06
    517  1d06		       a9 08	   .pause7800 lda	#BW_SWITCH
    518  1d08		       2c 82 02 	      bit	SWCHB
    519  1d0b		       f0 04		      beq	.pausePress
    520  1d0d		       05 80		      ora	gameMode	; not pressed, so enable first time press
    521  1d0f		       d0 08		      bne	.fixPause	; unconditional
    522  1d11
    523  1d11		       24 80	   .pausePress bit	gameMode
    524  1d13		       f0 06		      beq	.setPauseCol	; NOT the first time in pause - so do nothing new
    525  1d15
    526  1d15							; Button is down, and we have detected it as a FIRST-TIME button press.
    527  1d15
    528  1d15		       45 80	   .buttonDown eor	gameMode	; toggle first time flag(7800) or current switch state(2600)
    529  1d17		       49 80		      eor	#GAMEMODE_PAUSED	; toggle pause flag
    530  1d19		       85 80	   .fixPause  sta	gameMode
    531  1d1b
    532  1d1b		       a5 80	   .setPauseCol lda	gameMode	; are we paused?
    533  1d1d		       10 07		      bpl	.exitPause	; only show pause colour when actually paused
    534  1d1f
    535  1d1f		       a6 81		      ldx	Platform
    536  1d21		       bd 8e f5 	      lda	pscol,x
    537  1d24		       85 b3		      sta	BGColour	; set main screen background colour.  RED is paused.
    538  1d26
    539  1d26				   .exitPause
    540  1d26
    541  1d26							;----------------------------------------------------------------------------------------------
    542  1d26
    543  1d26							; has to be done AFTER screen display, because it disables the effect!
    544  1d26		       a5 82		      lda	rnd	; 3	 randomly reposition the Cosmic Ark missile
    545  1d28		       85 62		      sta	HMM0	; 3	 this assumes that HMOVE is called at least once/frame
    546  1d2a
    547  1d2a							; "Flash" has highest BG colour priority
    548  1d2a
    549  1d2a		       a6 c6		      ldx	ColourTimer
    550  1d2c		       f0 04		      beq	noFlashBG
    551  1d2e		       c6 c6		      dec	ColourTimer
    552  1d30		       a2 c0		      ldx	#$C0
    553  1d32		       86 b3	   noFlashBG  stx	BGColour
    554  1d34
    555  1d34							; Handle the player joystick reading. We do it *every frame* so that we can incorporate a two-frame
    556  1d34							; buffer.  This is designed to give a little better responsiveness to the 'quick tap' movement.
    557  1d34
    558  1d34		       a5 90		      lda	BufferedJoystick	; previous frame
    559  1d36		       85 91		      sta	BufferedJoystick+1	; -> buffered
    560  1d38
    561  1d38
    562  1d38							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    563  1d38							; P2 is shifted UP, so we don't need to worry in usage elsewhere (it's same format as a P1 joystick)
    564  1d38
    565  1d38		       a5 99		      lda	whichPlayer	; 3
    566  1d3a		       25 a9		      and	jtoggle	; 3
    567  1d3c		       aa		      tax		; 2
    568  1d3d
    569  1d3d		       b5 4c		      lda	INPT4,x	; 4
    570  1d3f		       25 92		      and	BufferedButton
    571  1d41		       85 92		      sta	BufferedButton	; 3 = 15
    572  1d43
    573  1d43		       ad 80 02 	      lda	SWCHA	; 4
    574  1d46
    575  1d46		       ca		      dex		; 2
    576  1d47		       30 04		      bmi	notP2	; 2/3= 8/9
    577  1d49
    578  1d49		       0a		      asl		; 2
    579  1d4a		       0a		      asl		; 2
    580  1d4b		       0a		      asl		; 2
    581  1d4c		       0a		      asl		; 2 =	8
    582  1d4d		       85 90	   notP2      sta	BufferedJoystick	; 3
    583  1d4f
    584  1d4f
    585  1d4f							; "Scoring timer" reset stomp comment
    586  1d4f
    587  1d4f		       a5 c8		      lda	scoringTimer
    588  1d51		       f0 0a		      beq	timer0now
    589  1d53		       c6 c8		      dec	scoringTimer
    590  1d55		       d0 06		      bne	timer0now
    591  1d57		       a5 c9		      lda	scoringFlags
    592  1d59		       29 fc		      and	#<(~DISPLAY_FLAGS)	;	 switches to time display
    593  1d5b		       85 c9		      sta	scoringFlags
    594  1d5d				   timer0now
    595  1d5d
    596  1d5d							; fall through
    597  1d5d
    598  1d5d							;-------------------------------------------------------------------------------------
    599  1d5d							; Player animation happens *every* frame so that we get good animation speeds.  Note that
    600  1d5d							; the player animation consists of running a small animation 'program', and then actually drawing
    601  1d5d							; the player.	The draw is the neat bit, because all it does is update some self-modifying pointers
    602  1d5d							; inside the actual draw kernel in the appropriate bank.
    603  1d5d
    604  1d5d
      0  1d5d					      DEFINE_SUBROUTINE	AnimatePlayers	; in GENERIC_BANK_1
      1  1d5d		       00 03	   BANK_AnimatePlayers =	_CURRENT_BANK
      2  1d5d					      SUBROUTINE
      3  1d5d				   AnimatePlayers
    606  1d5d
    607  1d5d							; Optimised 7/1/2012 -- single page tables
    608  1d5d
    609  1d5d							; This interesting code performs the animations for the player(s) and sets the
    610  1d5d							; pointers INSIDE the row bank for the draw code to point to the correct player
    611  1d5d							; shape.  Kind of neat, as it doesn't require any shape copying (=speed!)
    612  1d5d
    613  1d5d
    614  1d5d							; Cycle the player through his animation list.  The animation of a player is a direct
    615  1d5d							; pointer to the actual shape used to display the player.  This shape is in turn
    616  1d5d							; written to the current bank's self-modifying locations for the draw.  Since
    617  1d5d							; we are effectively drawing from this current bank, the same code can be used
    618  1d5d							; to 'undraw' the player as required.
    619  1d5d
    620  1d5d
    621  1d5d							; x = player index
    622  1d5d							; sets ManAnimation = FRAME to display for player
    623  1d5d							; ManAnimation = index of player program into Manimate list
    624  1d5d
    625  1d5d		       24 80		      bit	gameMode
    626  1d5f		       30 2c		      bmi	AnimationOK	; don't animate during pause
    627  1d61
    628  1d61		       c6 a0		      dec	ManDelayCount
    629  1d63		       10 28		      bpl	AnimationOK
    630  1d65
    631  1d65		       a4 a1	   ReloadAnimation ldy	ManAnimation
    632  1d67		       b9 00 f7    ContinueAnim lda	Manimate,y	; delay count
    633  1d6a		       d0 07		      bne	NewFrameOK
    634  1d6c		       b9 01 f7 	      lda	Manimate+1,y
    635  1d6f		       a8		      tay
    636  1d70		       4c 67 f5 	      jmp	ContinueAnim
    637  1d73
    638  1d73		       10 0d	   NewFrameOK bpl	doDelay
    639  1d75
    640  1d75		       c8		      iny		; handle a REFLECT
    641  1d76		       a5 a4		      lda	ManLastDirection
    642  1d78		       29 f7		      and	#%11110111
    643  1d7a		       19 00 f7 	      ora	Manimate,y
    644  1d7d		       85 a4		      sta	ManLastDirection
    645  1d7f
    646  1d7f		       c8		      iny
    647  1d80		       d0 e5		      bne	ContinueAnim
    648  1d82
    649  1d82		       85 a0	   doDelay    sta	ManDelayCount
    650  1d84
    651  1d84		       c8		      iny
    652  1d85		       b9 00 f7 	      lda	Manimate,y
    653  1d88		       85 a3		      sta	ManAnimationFrameLO
    654  1d8a
    655  1d8a		       c8		      iny
    656  1d8b		       84 a1		      sty	ManAnimation
    657  1d8d
    658  1d8d		       60	   AnimationOK rts
    659  1d8e
    660  1d8e
    661  1d8e
    662  1d8e		       40 40	   pscol      .byte.b	$40, $40
    663  1d90		       60 60		      .byte.b	$60, $60
    664  1d92
    665  1d92							;------------------------------------------------------------------------------
    666  1d92
------- FILE i2c_v2.2.inc LEVEL 3 PASS 3
      0  1d92					      include	"i2c_v2.2.inc"
      1  1d92							;
      2  1d92							; i2c_v2.2.inc
      3  1d92							;
      4  1d92							;
      5  1d92							; AtariVox EEPROM Driver
      6  1d92							;
      7  1d92							; By Alex Herbert, 2004
      8  1d92							;
      9  1d92							; Optimisations by Thomas Jentzsch, 2006/2008
     10  1d92							;
     11  1d92
     12  1d92
     13  1d92							; I/O Constants
     14  1d92
     15  1d92		       00 04	   I2C_SDA_MASK equ	$04
     16  1d92		       00 08	   I2C_SCL_MASK equ	$08
     17  1d92
     18  1d92
     19  1d92							; Signalling Macros
     20  1d92
     21  1d92							;  MAC     I2C_SCL_0
     22  1d92							;    lda     #$00
     23  1d92							;    sta     SWCHA
     24  1d92							;  ENDM
     25  1d92
     26  1d92							;  MAC     I2C_SCL_1
     27  1d92							;    lda     #I2C_SCL_MASK
     28  1d92							;    sta     SWCHA
     29  1d92							;  ENDM
     30  1d92
     31  1d92							;  MAC     I2C_SDA_IN
     32  1d92							;    lda     #I2C_SCL_MASK
     33  1d92							;    sta     SWACNT
     34  1d92							;  ENDM
     35  1d92
     36  1d92							;  MAC     I2C_SDA_OUT
     37  1d92							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  1d92							;    sta     SWACNT
     39  1d92							;  ENDM
     40  1d92
     41  1d92
     42  1d92					      MAC	i2c_start
     43  1d92							; I2C_SCL_1
     44  1d92					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  1d92					      sta	SWCHA	; 4
     46  1d92							; I2C_SDA_OUT
     47  1d92					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  1d92					      sta	SWACNT	; 4
     49  1d92							; total: 12 cycles
     50  1d92					      ENDM
     51  1d92
     52  1d92
     53  1d92					      MAC	i2c_txbit
     54  1d92							; I2C_SCL_0
     55  1d92					      lda	#%0011	; 2
     56  1d92					      sta	SWCHA	; 4
     57  1d92							; set bit
     58  1d92					      adc	#%1000	; 2
     59  1d92					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  1d92							; I2C_SCL_1
     61  1d92					      lda	#I2C_SCL_MASK	; 2
     62  1d92					      sta	SWCHA	; 4
     63  1d92							; total: 18 cycles
     64  1d92					      ENDM
     65  1d92
     66  1d92
     67  1d92					      MAC	i2c_txnack
     68  1d92							; I2C_SCL_0
     69  1d92					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  1d92					      sta	SWCHA	; 4
     71  1d92							; I2C_SDA_IN
     72  1d92					      lsr		; 2	     I2C_SCL_MASK
     73  1d92					      sta	SWACNT	; 4
     74  1d92							; I2C_SCL_1
     75  1d92					      nop		; 2	     required for timing!
     76  1d92					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  1d92							; total: 18 cycles
     78  1d92					      ENDM
     79  1d92
     80  1d92
     81  1d92							; Subroutine Macros
     82  1d92
     83  1d92					      MAC	i2c_subs
     84  1d92
     85  1d92				   i2c_startread
     86  1d92							; use V to flag if previous byte needs ACK
     87  1d92					      ldy	#%10100001	; 2	     eeprom read command
     88  1d92					      .byte	$2c	; 2
     89  1d92				   i2c_startwrite
     90  1d92					      ldy	#%10100000	; 2	     eeprom write command
     91  1d92					      I2C_START		;12	     start signal (clears V flag)
     92  1d92					      tya		; 2 = 16
     93  1d92				   i2c_txbyte
     94  1d92					      eor	#$ff	; 2	     invert data byte
     95  1d92					      sec		; 2
     96  1d92					      rol		; 2 =	6    shift loop bit into a
     97  1d92				   i2c_txbyteloop
     98  1d92					      tay		; 2
     99  1d92					      I2C_TXBIT		;18	     transmit
    100  1d92					      tya		; 2
    101  1d92					      asl		; 2	     shift next bit into C
    102  1d92					      bne	i2c_txbyteloop	; 2= 26/27
    103  1d92
    104  1d92							; receive acknowledge bit
    105  1d92
    106  1d92					      beq	i2c_rxbit	;43 = 43
    107  1d92							; i2c_txbyte: 264 cycles
    108  1d92							;-------------------------------------------------------------------------------
    109  1d92
    110  1d92				   i2c_rxbyte
    111  1d92					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  1d92					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  1d92
    114  1d92				   i2c_rxskipack
    115  1d92					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  1d92
    117  1d92					      lda	#1	; 2
    118  1d92				   i2c_rxbyteloop
    119  1d92					      tay		; 2 =	2
    120  1d92				   i2c_rxbit		;	     receive bit in C
    121  1d92					      I2C_TXNACK		;18 = 18
    122  1d92
    123  1d92					      lda	SWCHA	; 4
    124  1d92					      lsr		; 2
    125  1d92					      lsr		; 2
    126  1d92					      lsr		; 2 = 10    C = SDA
    127  1d92
    128  1d92					      tya		; 2
    129  1d92					      rol		; 2	     rotate into Y
    130  1d92					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  1d92
    132  1d92							; received byte in A
    133  1d92					      rts		; 6 =	6
    134  1d92							; i2c_rxbit:  40 cycles
    135  1d92							; i2c_rxbyte: 310/333 cycles
    136  1d92							;-------------------------------------------------------------------------------
    137  1d92
    138  1d92				   i2c_stopread
    139  1d92					      bvc	i2c_stopwrite	; 2
    140  1d92					      ldy	#$80	; 2
    141  1d92					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  1d92
    143  1d92				   i2c_stopwrite
    144  1d92					      jsr	i2c_txack	;30
    145  1d92
    146  1d92							; return port to input mode
    147  1d92					      lda	#0	; 2	     0
    148  1d92					      sta	SWACNT	; 4
    149  1d92					      rts		; 6 = 12
    150  1d92							; i2c_stopread:  45/92
    151  1d92							; i2c_stopwrite: 42
    152  1d92							;-------------------------------------------------------------------------------
    153  1d92
    154  1d92				   i2c_txack
    155  1d92							; I2C_SCL_0
    156  1d92					      lda	#0	; 2	     $00
    157  1d92					      sta	SWCHA	; 4
    158  1d92							; I2C_SDA_OUT
    159  1d92					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  1d92					      sta	SWACNT	; 4
    161  1d92							; I2C_SCL_1
    162  1d92					      asl		; 2	     I2C_SCL_MASK
    163  1d92					      sta	SWCHA	; 4
    164  1d92
    165  1d92					      rts		; 6
    166  1d92							; total: 24 cycles
    167  1d92							;-------------------------------------------------------------------------------
    168  1d92
    169  1d92					      ENDM
    170  1d92
    171  1d92
    172  1d92
------- FILE BANK_GENERIC.asm
    668  1d92
      0  1d92					      i2c_subs
      1  1d92
      2  1d92				   i2c_startread
      3  1d92
      4  1d92		       a0 a1		      ldy	#%10100001
      5  1d94		       2c		      .byte.b	$2c
      6  1d95				   i2c_startwrite
      7  1d95		       a0 a0		      ldy	#%10100000
      0  1d97					      I2C_START
      1  1d97
      2  1d97		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  1d99		       8d 80 02 	      sta	SWCHA
      4  1d9c
      5  1d9c		       4a		      lsr
      6  1d9d		       8d 81 02 	      sta	SWACNT
      7  1da0
      9  1da0		       98		      tya
     10  1da1				   i2c_txbyte
     11  1da1		       49 ff		      eor	#$ff
     12  1da3		       38		      sec
     13  1da4		       2a		      rol
     14  1da5				   i2c_txbyteloop
     15  1da5		       a8		      tay
      0  1da6					      I2C_TXBIT
      1  1da6
      2  1da6		       a9 03		      lda	#%0011
      3  1da8		       8d 80 02 	      sta	SWCHA
      4  1dab
      5  1dab		       69 08		      adc	#%1000
      6  1dad		       8d 81 02 	      sta	SWACNT
      7  1db0
      8  1db0		       a9 08		      lda	#I2C_SCL_MASK
      9  1db2		       8d 80 02 	      sta	SWCHA
     10  1db5
     17  1db5		       98		      tya
     18  1db6		       0a		      asl
     19  1db7		       d0 ec		      bne	i2c_txbyteloop
     20  1db9
     21  1db9
     22  1db9
     23  1db9		       f0 0b		      beq	i2c_rxbit
     24  1dbb
     25  1dbb
     26  1dbb
     27  1dbb				   i2c_rxbyte
     28  1dbb		       50 03		      bvc	i2c_rxskipack
     29  1dbd		       20 ee f5 	      jsr	i2c_txack
     30  1dc0
     31  1dc0				   i2c_rxskipack
     32  1dc0		       2c bb f5 	      bit	i2c_rxbyte
     33  1dc3
     34  1dc3		       a9 01		      lda	#1
     35  1dc5				   i2c_rxbyteloop
     36  1dc5		       a8		      tay
     37  1dc6				   i2c_rxbit
      0  1dc6					      I2C_TXNACK
      1  1dc6
      2  1dc6		       a9 10		      lda	#I2C_SCL_MASK*2
      3  1dc8		       8d 80 02 	      sta	SWCHA
      4  1dcb
      5  1dcb		       4a		      lsr
      6  1dcc		       8d 81 02 	      sta	SWACNT
      7  1dcf
      8  1dcf		       ea		      nop
      9  1dd0		       8d 80 02 	      sta	SWCHA
     10  1dd3
     39  1dd3
     40  1dd3		       ad 80 02 	      lda	SWCHA
     41  1dd6		       4a		      lsr
     42  1dd7		       4a		      lsr
     43  1dd8		       4a		      lsr
     44  1dd9
     45  1dd9		       98		      tya
     46  1dda		       2a		      rol
     47  1ddb		       90 e8		      bcc	i2c_rxbyteloop
     48  1ddd
     49  1ddd
     50  1ddd		       60		      rts
     51  1dde
     52  1dde
     53  1dde
     54  1dde
     55  1dde				   i2c_stopread
     56  1dde		       50 05		      bvc	i2c_stopwrite
     57  1de0		       a0 80		      ldy	#$80
     58  1de2		       20 c6 f5 	      jsr	i2c_rxbit
     59  1de5
     60  1de5				   i2c_stopwrite
     61  1de5		       20 ee f5 	      jsr	i2c_txack
     62  1de8
     63  1de8
     64  1de8		       a9 00		      lda	#0
     65  1dea		       8d 81 02 	      sta	SWACNT
     66  1ded		       60		      rts
     67  1dee
     68  1dee
     69  1dee
     70  1dee
     71  1dee				   i2c_txack
     72  1dee
     73  1dee		       a9 00		      lda	#0
     74  1df0		       8d 80 02 	      sta	SWCHA
     75  1df3
     76  1df3		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  1df5		       8d 81 02 	      sta	SWACNT
     78  1df8
     79  1df8		       0a		      asl
     80  1df9		       8d 80 02 	      sta	SWCHA
     81  1dfc
     82  1dfc		       60		      rts
     83  1dfd
     84  1dfd
     85  1dfd
    670  1dfd
    671  1dfd				   HandleSaveKey SUBROUTINE
    672  1dfd
    673  1dfd		       2f 00	   SAVEKEY_ADR =	$2F00	;	     tentative address for Sokoban (64 bytes)
    674  1dfd
    675  1dfd							;------------------------------------------------------------------------------
      0  1dfd					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  1dfd		       00 03	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  1dfd					      SUBROUTINE
      3  1dfd				   ReadSaveKey
    677  1dfd
    678  1dfd							; assume no SaveKey found:
    679  1dfd		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    680  1dff		       85 df		      sta	highScoreSK+2	; 3
    681  1e01
    682  1e01							; setup SaveKey:
    683  1e01		       a5 e0		      lda	startingLevel	; 3	     load start levelX*5 and level
    684  1e03		       a6 b5		      ldx	level	; 3
    685  1e05		       20 3e f6 	      jsr	SetupSaveKey	;6+853
    686  1e08		       90 52		      bcc	NoSKfound	; 2/3
    687  1e0a
    688  1e0a							;    lda     #$34
    689  1e0a							;    sta     COLUBK
    690  1e0a
    691  1e0a							; start read
    692  1e0a		       20 e5 f5 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    693  1e0d		       20 92 f5 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    694  1e10
    695  1e10							; read high score:
    696  1e10		       a2 02		      ldx	#3-1	; 2 = 1187
    697  1e12				   .loopRead
    698  1e12		       20 bb f5 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    699  1e15		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    700  1e17		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    701  1e19		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    702  1e1b				   .skipEmpty
    703  1e1b		       95 dd		      sta	highScoreSK,x	; 4
    704  1e1d		       ca		      dex		; 2
    705  1e1e		       10 f2		      bpl	.loopRead	; 2/3= 354
    706  1e20
    707  1e20							; stop read:
    708  1e20		       4c de f5 	      jmp	i2c_stopread	;3+92=95    terminate read
    709  1e23
    710  1e23							;------------------------------------------------------------------------------
      0  1e23					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  1e23		       00 03	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  1e23					      SUBROUTINE
      3  1e23				   WriteSaveKey
    712  1e23
    713  1e23							; check if new high score:
    714  1e23		       a6 dd		      ldx	highScoreSK	; 3
    715  1e25		       e8		      inx		; 2
    716  1e26		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    717  1e28
    718  1e28							; setup SaveKey:
    719  1e28		       a5 e0		      lda	startingLevel	; 3	     load start levelX*5 and level
    720  1e2a		       a6 e1		      ldx	startLevel	; 3
    721  1e2c		       20 3e f6 	      jsr	SetupSaveKey	; 6+853
    722  1e2f		       90 2b		      bcc	NoSKfound	; 2/3
    723  1e31
    724  1e31							;    lda     #$64
    725  1e31							;    sta     COLUBK
    726  1e31
    727  1e31							; write high score:
    728  1e31		       a2 02		      ldx	#3-1	; 2 = 841
    729  1e33				   .loopWrite
    730  1e33		       b5 dd		      lda	highScoreSK,x	; 4
    731  1e35		       20 a1 f5 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    732  1e38		       ca		      dex		; 2
    733  1e39		       10 f8		      bpl	.loopWrite	; 2/3= 837
    734  1e3b
    735  1e3b							; stop write:
    736  1e3b		       4c e5 f5 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    737  1e3e
    738  1e3e
    739  1e3e							;------------------------------------------------------------------------------
      0  1e3e					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  1e3e		       00 03	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  1e3e					      SUBROUTINE
      3  1e3e				   SetupSaveKey
    741  1e3e
    742  1e3e							; calculate slot;
    743  1e3e							; a = levelX
    744  1e3e							; x = level (0..4)
    745  1e3e		       85 e2		      sta	offsetSK	; 3
    746  1e40		       8a		      txa		; 2
    747  1e41		       18		      clc		; 2
    748  1e42		       65 e2		      adc	offsetSK	; 3
    749  1e44		       85 e2		      sta	offsetSK	; 3
    750  1e46		       0a		      asl		; 2	     multiply by 3
    751  1e47		       65 e2		      adc	offsetSK	; 3
    752  1e49		       69 00		      adc	#<SAVEKEY_ADR	; 2
    753  1e4b		       aa		      tax		; 2 = 22
    754  1e4c							; detect SaveKey:
    755  1e4c		       20 95 f5 	      jsr	i2c_startwrite	;6+280
    756  1e4f		       d0 0a		      bne	.exitSK	; 2/3
    757  1e51
    758  1e51							; setup address:
    759  1e51		       b8		      clv		; 2
    760  1e52		       a9 2f		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    761  1e54		       20 a1 f5 	      jsr	i2c_txbyte	;6+264
    762  1e57		       8a		      txa		; 2	     x = lower byte offset
    763  1e58		       4c a1 f5 	      jmp	i2c_txbyte	;3+264      returns C==1
    764  1e5b
    765  1e5b				   .exitSK
    766  1e5b		       18		      clc
    767  1e5c				   NoSKfound
    768  1e5c		       60		      rts
    769  1e5c					      ENDIF
    770  1e5d
    771  1f00		       00 00 00 00*	      align	256
    772  1f00
    773  1f00				   Manimate
    774  1f00				   AnimateSTAND
    775  1f00				   AnimateRIGHT
    776  1f00				   AnimateLEFT
    777  1f00				   AnimateUP
    778  1f00				   AnimateSTOPPED
    779  1f00		       7f		      .byte.b	127
    780  1f01		       18		      .byte.b	<PLAYER_RIGHT0	;PLAYER_STAND
    781  1f02							;.byte 10
    782  1f02							;.byte < PLAYER_BLINK
    783  1f02							;.byte 127
    784  1f02							;.byte < PLAYER_STAND
    785  1f02							;.byte 0
    786  1f02							;.word AnimateTAP
    787  1f02
    788  1f02				   AnimateTAP
    789  1f02							;.byte 128, %0 		  ; reflect off, always tap with left foot
    790  1f02							;.byte 8
    791  1f02							;.byte < PLAYER_TAP0
    792  1f02							;.byte 8
    793  1f02							;.byte < PLAYER_TAP1
    794  1f02							;.byte 8
    795  1f02							;.byte < PLAYER_TAP0
    796  1f02							;.byte 8
    797  1f02							;.byte < PLAYER_TAP1
    798  1f02							;.byte 8
    799  1f02							;.byte < PLAYER_TAP0
    800  1f02							;.byte 8
    801  1f02							;.byte < PLAYER_TAP1
    802  1f02		       00		      .byte.b	0
    803  1f03		       00		      .byte.b	AnimateSTAND-Manimate	;word AnimateSTAND
    804  1f04
    805  1f04							;AnimateRIGHT
    806  1f04		       80 00		      .byte.b	128, %0	; reflect off
    807  1f06		       05		      .byte.b	5
    808  1f07		       18		      .byte.b	< PLAYER_RIGHT0
    809  1f08		       05		      .byte.b	5
    810  1f09		       2d		      .byte.b	< PLAYER_RIGHT1
    811  1f0a		       00		      .byte.b	0
    812  1f0b		       00		      .byte.b	AnimateRIGHT-Manimate	;word AnimateRIGHT
    813  1f0c
    814  1f0c							;AnimateLEFT
    815  1f0c		       80 08		      .byte.b	128, %1000	; reflect ON
    816  1f0e		       05		      .byte.b	5
    817  1f0f		       18		      .byte.b	< PLAYER_RIGHT0
    818  1f10		       05		      .byte.b	5
    819  1f11		       2d		      .byte.b	< PLAYER_RIGHT1
    820  1f12		       00		      .byte.b	0
    821  1f13		       00		      .byte.b	AnimateLEFT-Manimate	;word AnimateLEFT
    822  1f14
    823  1f14							;AnimateUP
    824  1f14							;    .byte 128, %0		   ; reflect off
    825  1f14							;    .byte 5
    826  1f14							;    .byte < PLAYER_TAP
    827  1f14							;    .byte 128, %1000
    828  1f14							;    .byte 5
    829  1f14							;    .byte < PLAYER_TAP
    830  1f14							;    .byte 0
    831  1f14							;    .word AnimateUP
    832  1f14
    833  1f14							;AnimateUP
    834  1f14		       05		      .byte.b	5
    835  1f15		       18		      .byte.b	< PLAYER_RIGHT0
    836  1f16		       05		      .byte.b	5
    837  1f17		       2d		      .byte.b	< PLAYER_RIGHT1
    838  1f18		       00		      .byte.b	0
    839  1f19		       00		      .byte.b	AnimateUP-Manimate	;word AnimateUP
    840  1f1a
    841  1f1a				   AnimateBLANK
    842  1f1a		       7f		      .byte.b	127
    843  1f1b		       03		      .byte.b	< PLAYER_BLANK
    844  1f1c		       00		      .byte.b	0
    845  1f1d		       1a		      .byte.b	AnimateBLANK-Manimate	;word AnimateBLANK
    846  1f1e
    847  1f1e				   AnimateEND
      0  1f1e					      CHECKPAGEX	Manimate, "AnimateEND @ BANK_GENERIC"
      9  1f1e					      LIST	ON
    849  1f1e
    850  1f1e
      0  1f1e					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  1f1e		       07 1e	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $71e , FREE= $e2
      2  1f1e					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1f1e				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1f1e				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1f1e				  -	      ERR
      6  1f1e					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS1.asm LEVEL 2 PASS 3
      0  1f1e					      include	"BANK_LEVELS1.asm"
      1  1f1e							;    Sokoboo - a Sokoban implementation
      2  1f1e							;    using a generic tile-based display engine for the Atari 2600
      3  1f1e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1f1e							;
      5  1f1e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1f1e							;
      7  1f1e							;    Code related to the generic tile-based display engine was developed by
      8  1f1e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1f1e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1f1e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1f1e							;
     12  1f1e							;    Code related to music and sound effects uses the TIATracker music player
     13  1f1e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1f1e							;    directory for Apache licensing details.
     15  1f1e							;
     16  1f1e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1f1e							;    See the copyright notices in the License directory for a list of level
     18  1f1e							;    contributors.
     19  1f1e							;
     20  1f1e							;    Except where otherwise indicated, this software is released under the
     21  1f1e							;    following licensing arrangement...
     22  1f1e							;
     23  1f1e							;    This program is free software: you can redistribute it and/or modify
     24  1f1e							;    it under the terms of the GNU General Public License as published by
     25  1f1e							;    the Free Software Foundation, either version 3 of the License, or
     26  1f1e							;    (at your option) any later version.
     27  1f1e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1f1e
     29  1f1e							;    This program is distributed in the hope that it will be useful,
     30  1f1e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1f1e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1f1e							;    GNU General Public License for more details.
     33  1f1e
      0  1f1e					      NEWBANK	LEVELS1
      1  27d7 ????				      SEG	LEVELS1
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   LEVELS1    SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	LEVELS1
     35  2000
     36  2000							; "SOKWHOLE" collection...
     37  2000
      0  2000					      DEFL	_001_L, "3#|#@#|#$#|#.#|3#"
      0  2000					      START_LEVEL	_001_L
      1  2000				   LEVEL_START SET	*
      2  2000		       00 04	   BANK_LEVEL__001_L =	_CURRENT_BANK
      3  2000				   LEVEL__001_L SUBROUTINE
      4  2000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2000
      2  2000		       33 23 7c 23*	      .byte.b	"3#|#@#|#$#|#.#|3#",0
      0  2012					      END_LEVEL	_001_L
      1  2012		       00		      .byte.b	0
      2  2012		       00 13	   LEVEL_SIZE__001_L =	* - LEVEL_START
      3  2013					      IF	LEVEL_SIZE__001_L > MAX_LEVEL_SIZE
      4  2013				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_L
      5  2013					      ENDIF
      0  2013					      DEFL	_001_R, "5#|#.$@#|5#"
      0  2013					      START_LEVEL	_001_R
      1  2013				   LEVEL_START SET	*
      2  2013		       00 04	   BANK_LEVEL__001_R =	_CURRENT_BANK
      3  2013				   LEVEL__001_R SUBROUTINE
      4  2013				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2013
      2  2013		       35 23 7c 23*	      .byte.b	"5#|#.$@#|5#",0
      0  201f					      END_LEVEL	_001_R
      1  201f		       00		      .byte.b	0
      2  201f		       00 0d	   LEVEL_SIZE__001_R =	* - LEVEL_START
      3  2020				  -	      IF	LEVEL_SIZE__001_R > MAX_LEVEL_SIZE
      4  2020				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_R
      5  2020					      ENDIF
      0  2020					      DEFL	_002_L, "3#2-|#.3#|#*$-#|#2-@#|5#"
      0  2020					      START_LEVEL	_002_L
      1  2020				   LEVEL_START SET	*
      2  2020		       00 04	   BANK_LEVEL__002_L =	_CURRENT_BANK
      3  2020				   LEVEL__002_L SUBROUTINE
      4  2020				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2020
      2  2020		       33 23 32 2d*	      .byte.b	"3#2-|#.3#|#*$-#|#2-@#|5#",0
      0  2039					      END_LEVEL	_002_L
      1  2039		       00		      .byte.b	0
      2  2039		       00 1a	   LEVEL_SIZE__002_L =	* - LEVEL_START
      3  203a					      IF	LEVEL_SIZE__002_L > MAX_LEVEL_SIZE
      4  203a				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_L
      5  203a					      ENDIF
      0  203a					      DEFL	_002_R, "2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#"
      0  203a					      START_LEVEL	_002_R
      1  203a				   LEVEL_START SET	*
      2  203a		       00 04	   BANK_LEVEL__002_R =	_CURRENT_BANK
      3  203a				   LEVEL__002_R SUBROUTINE
      4  203a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  203a
      2  203a		       32 2d 35 23*	      .byte.b	"2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#",0
      0  2062					      END_LEVEL	_002_R
      1  2062		       00		      .byte.b	0
      2  2062		       00 29	   LEVEL_SIZE__002_R =	* - LEVEL_START
      3  2063					      IF	LEVEL_SIZE__002_R > MAX_LEVEL_SIZE
      4  2063				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_R
      5  2063					      ENDIF
      0  2063					      DEFL	_003_L, "4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-"
      0  2063					      START_LEVEL	_003_L
      1  2063				   LEVEL_START SET	*
      2  2063		       00 04	   BANK_LEVEL__003_L =	_CURRENT_BANK
      3  2063				   LEVEL__003_L SUBROUTINE
      4  2063				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2063
      2  2063		       34 2d 35 23*	      .byte.b	"4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-",0
      0  208f					      END_LEVEL	_003_L
      1  208f		       00		      .byte.b	0
      2  208f		       00 2d	   LEVEL_SIZE__003_L =	* - LEVEL_START
      3  2090					      IF	LEVEL_SIZE__003_L > MAX_LEVEL_SIZE
      4  2090				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_L
      5  2090					      ENDIF
      0  2090					      DEFL	_003_R, "9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-"
      0  2090					      START_LEVEL	_003_R
      1  2090				   LEVEL_START SET	*
      2  2090		       00 04	   BANK_LEVEL__003_R =	_CURRENT_BANK
      3  2090				   LEVEL__003_R SUBROUTINE
      4  2090				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2090
      2  2090		       39 23 7c 23*	      .byte.b	"9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-",0
      0  20ba					      END_LEVEL	_003_R
      1  20ba		       00		      .byte.b	0
      2  20ba		       00 2b	   LEVEL_SIZE__003_R =	* - LEVEL_START
      3  20bb				  -	      IF	LEVEL_SIZE__003_R > MAX_LEVEL_SIZE
      4  20bb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_R
      5  20bb					      ENDIF
      0  20bb					      DEFL	_004_L, "5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-"
      0  20bb					      START_LEVEL	_004_L
      1  20bb				   LEVEL_START SET	*
      2  20bb		       00 04	   BANK_LEVEL__004_L =	_CURRENT_BANK
      3  20bb				   LEVEL__004_L SUBROUTINE
      4  20bb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20bb
      2  20bb		       35 23 2d 7c*	      .byte.b	"5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-",0
      0  20de					      END_LEVEL	_004_L
      1  20de		       00		      .byte.b	0
      2  20de		       00 24	   LEVEL_SIZE__004_L =	* - LEVEL_START
      3  20df				  -	      IF	LEVEL_SIZE__004_L > MAX_LEVEL_SIZE
      4  20df				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_L
      5  20df					      ENDIF
      0  20df					      DEFL	_004_R, "-6#|-#4-#|2#-$*$#|#@$3.#|7#"
      0  20df					      START_LEVEL	_004_R
      1  20df				   LEVEL_START SET	*
      2  20df		       00 04	   BANK_LEVEL__004_R =	_CURRENT_BANK
      3  20df				   LEVEL__004_R SUBROUTINE
      4  20df				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20df
      2  20df		       2d 36 23 7c*	      .byte.b	"-6#|-#4-#|2#-$*$#|#@$3.#|7#",0
      0  20fb					      END_LEVEL	_004_R
      1  20fb		       00		      .byte.b	0
      2  20fb		       00 1d	   LEVEL_SIZE__004_R =	* - LEVEL_START
      3  20fc				  -	      IF	LEVEL_SIZE__004_R > MAX_LEVEL_SIZE
      4  20fc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_R
      5  20fc					      ENDIF
      0  20fc					      DEFL	_005_L, "3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-"
      0  20fc					      START_LEVEL	_005_L
      1  20fc				   LEVEL_START SET	*
      2  20fc		       00 04	   BANK_LEVEL__005_L =	_CURRENT_BANK
      3  20fc				   LEVEL__005_L SUBROUTINE
      4  20fc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20fc
      2  20fc		       33 2d 35 23*	      .byte.b	"3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-",0
      0  212e					      END_LEVEL	_005_L
      1  212e		       00		      .byte.b	0
      2  212e		       00 33	   LEVEL_SIZE__005_L =	* - LEVEL_START
      3  212f					      IF	LEVEL_SIZE__005_L > MAX_LEVEL_SIZE
      4  212f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_L
      5  212f					      ENDIF
      0  212f					      DEFL	_005_R, "6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-"
      0  212f					      START_LEVEL	_005_R
      1  212f				   LEVEL_START SET	*
      2  212f		       00 04	   BANK_LEVEL__005_R =	_CURRENT_BANK
      3  212f				   LEVEL__005_R SUBROUTINE
      4  212f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  212f
      2  212f		       36 23 32 2d*	      .byte.b	"6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-",0
      0  216e					      END_LEVEL	_005_R
      1  216e		       00		      .byte.b	0
      2  216e		       00 40	   LEVEL_SIZE__005_R =	* - LEVEL_START
      3  216f					      IF	LEVEL_SIZE__005_R > MAX_LEVEL_SIZE
      4  216f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_R
      5  216f					      ENDIF
      0  216f					      DEFL	_006_L, "5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-"
      0  216f					      START_LEVEL	_006_L
      1  216f				   LEVEL_START SET	*
      2  216f		       00 04	   BANK_LEVEL__006_L =	_CURRENT_BANK
      3  216f				   LEVEL__006_L SUBROUTINE
      4  216f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  216f
      2  216f		       35 23 33 2d*	      .byte.b	"5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-",0
      0  21aa					      END_LEVEL	_006_L
      1  21aa		       00		      .byte.b	0
      2  21aa		       00 3c	   LEVEL_SIZE__006_L =	* - LEVEL_START
      3  21ab				  -	      IF	LEVEL_SIZE__006_L > MAX_LEVEL_SIZE
      4  21ab				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_L
      5  21ab					      ENDIF
      0  21ab					      DEFL	_006_R, "3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-"
      0  21ab					      START_LEVEL	_006_R
      1  21ab				   LEVEL_START SET	*
      2  21ab		       00 04	   BANK_LEVEL__006_R =	_CURRENT_BANK
      3  21ab				   LEVEL__006_R SUBROUTINE
      4  21ab				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21ab
      2  21ab		       33 23 34 2d*	      .byte.b	"3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-",0
      0  21e9					      END_LEVEL	_006_R
      1  21e9		       00		      .byte.b	0
      2  21e9		       00 3f	   LEVEL_SIZE__006_R =	* - LEVEL_START
      3  21ea				  -	      IF	LEVEL_SIZE__006_R > MAX_LEVEL_SIZE
      4  21ea				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_R
      5  21ea					      ENDIF
      0  21ea					      DEFL	_007_L, "6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#"
      0  21ea					      START_LEVEL	_007_L
      1  21ea				   LEVEL_START SET	*
      2  21ea		       00 04	   BANK_LEVEL__007_L =	_CURRENT_BANK
      3  21ea				   LEVEL__007_L SUBROUTINE
      4  21ea				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21ea
      2  21ea		       36 23 2d 7c*	      .byte.b	"6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#",0
      0  2217					      END_LEVEL	_007_L
      1  2217		       00		      .byte.b	0
      2  2217		       00 2e	   LEVEL_SIZE__007_L =	* - LEVEL_START
      3  2218				  -	      IF	LEVEL_SIZE__007_L > MAX_LEVEL_SIZE
      4  2218				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_L
      5  2218					      ENDIF
      0  2218					      DEFL	_007_R, "4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#"
      0  2218					      START_LEVEL	_007_R
      1  2218				   LEVEL_START SET	*
      2  2218		       00 04	   BANK_LEVEL__007_R =	_CURRENT_BANK
      3  2218				   LEVEL__007_R SUBROUTINE
      4  2218				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2218
      2  2218		       34 23 34 2d*	      .byte.b	"4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#",0
      0  224b					      END_LEVEL	_007_R
      1  224b		       00		      .byte.b	0
      2  224b		       00 34	   LEVEL_SIZE__007_R =	* - LEVEL_START
      3  224c				  -	      IF	LEVEL_SIZE__007_R > MAX_LEVEL_SIZE
      4  224c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_R
      5  224c					      ENDIF
      0  224c					      DEFL	_008_L, "2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-"
      0  224c					      START_LEVEL	_008_L
      1  224c				   LEVEL_START SET	*
      2  224c		       00 04	   BANK_LEVEL__008_L =	_CURRENT_BANK
      3  224c				   LEVEL__008_L SUBROUTINE
      4  224c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  224c
      2  224c		       32 2d 35 23*	      .byte.b	"2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-",0
      0  2282					      END_LEVEL	_008_L
      1  2282		       00		      .byte.b	0
      2  2282		       00 37	   LEVEL_SIZE__008_L =	* - LEVEL_START
      3  2283				  -	      IF	LEVEL_SIZE__008_L > MAX_LEVEL_SIZE
      4  2283				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_L
      5  2283					      ENDIF
      0  2283					      DEFL	_008_R, "-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#"
      0  2283					      START_LEVEL	_008_R
      1  2283				   LEVEL_START SET	*
      2  2283		       00 04	   BANK_LEVEL__008_R =	_CURRENT_BANK
      3  2283				   LEVEL__008_R SUBROUTINE
      4  2283				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2283
      2  2283		       2d 35 23 33*	      .byte.b	"-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#",0
      0  22b4					      END_LEVEL	_008_R
      1  22b4		       00		      .byte.b	0
      2  22b4		       00 32	   LEVEL_SIZE__008_R =	* - LEVEL_START
      3  22b5				  -	      IF	LEVEL_SIZE__008_R > MAX_LEVEL_SIZE
      4  22b5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_R
      5  22b5					      ENDIF
      0  22b5					      DEFL	_009_L, "-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#"
      0  22b5					      START_LEVEL	_009_L
      1  22b5				   LEVEL_START SET	*
      2  22b5		       00 04	   BANK_LEVEL__009_L =	_CURRENT_BANK
      3  22b5				   LEVEL__009_L SUBROUTINE
      4  22b5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22b5
      2  22b5		       2d 35 23 2d*	      .byte.b	"-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#",0
      0  22e7					      END_LEVEL	_009_L
      1  22e7		       00		      .byte.b	0
      2  22e7		       00 33	   LEVEL_SIZE__009_L =	* - LEVEL_START
      3  22e8				  -	      IF	LEVEL_SIZE__009_L > MAX_LEVEL_SIZE
      4  22e8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_L
      5  22e8					      ENDIF
      0  22e8					      DEFL	_009_R, "-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#"
      0  22e8					      START_LEVEL	_009_R
      1  22e8				   LEVEL_START SET	*
      2  22e8		       00 04	   BANK_LEVEL__009_R =	_CURRENT_BANK
      3  22e8				   LEVEL__009_R SUBROUTINE
      4  22e8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22e8
      2  22e8		       2d 33 23 33*	      .byte.b	"-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#",0
      0  2318					      END_LEVEL	_009_R
      1  2318		       00		      .byte.b	0
      2  2318		       00 31	   LEVEL_SIZE__009_R =	* - LEVEL_START
      3  2319				  -	      IF	LEVEL_SIZE__009_R > MAX_LEVEL_SIZE
      4  2319				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_R
      5  2319					      ENDIF
      0  2319					      DEFL	_010_L, "2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-"
      0  2319					      START_LEVEL	_010_L
      1  2319				   LEVEL_START SET	*
      2  2319		       00 04	   BANK_LEVEL__010_L =	_CURRENT_BANK
      3  2319				   LEVEL__010_L SUBROUTINE
      4  2319				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2319
      2  2319		       32 2d 33 23*	      .byte.b	"2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-",0
      0  2353					      END_LEVEL	_010_L
      1  2353		       00		      .byte.b	0
      2  2353		       00 3b	   LEVEL_SIZE__010_L =	* - LEVEL_START
      3  2354				  -	      IF	LEVEL_SIZE__010_L > MAX_LEVEL_SIZE
      4  2354				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_L
      5  2354					      ENDIF
      0  2354					      DEFL	_010_R, "4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-"
      0  2354					      START_LEVEL	_010_R
      1  2354				   LEVEL_START SET	*
      2  2354		       00 04	   BANK_LEVEL__010_R =	_CURRENT_BANK
      3  2354				   LEVEL__010_R SUBROUTINE
      4  2354				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2354
      2  2354		       34 23 32 2d*	      .byte.b	"4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-",0
      0  2387					      END_LEVEL	_010_R
      1  2387		       00		      .byte.b	0
      2  2387		       00 34	   LEVEL_SIZE__010_R =	* - LEVEL_START
      3  2388				  -	      IF	LEVEL_SIZE__010_R > MAX_LEVEL_SIZE
      4  2388				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_R
      5  2388					      ENDIF
      0  2388					      DEFL	_011_L, "-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-"
      0  2388					      START_LEVEL	_011_L
      1  2388				   LEVEL_START SET	*
      2  2388		       00 04	   BANK_LEVEL__011_L =	_CURRENT_BANK
      3  2388				   LEVEL__011_L SUBROUTINE
      4  2388				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2388
      2  2388		       2d 34 23 32*	      .byte.b	"-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-",0
      0  23bb					      END_LEVEL	_011_L
      1  23bb		       00		      .byte.b	0
      2  23bb		       00 34	   LEVEL_SIZE__011_L =	* - LEVEL_START
      3  23bc				  -	      IF	LEVEL_SIZE__011_L > MAX_LEVEL_SIZE
      4  23bc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_L
      5  23bc					      ENDIF
      0  23bc					      DEFL	_011_R, "2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#"
      0  23bc					      START_LEVEL	_011_R
      1  23bc				   LEVEL_START SET	*
      2  23bc		       00 04	   BANK_LEVEL__011_R =	_CURRENT_BANK
      3  23bc				   LEVEL__011_R SUBROUTINE
      4  23bc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23bc
      2  23bc		       32 2d 33 23*	      .byte.b	"2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#",0
      0  23f6					      END_LEVEL	_011_R
      1  23f6		       00		      .byte.b	0
      2  23f6		       00 3b	   LEVEL_SIZE__011_R =	* - LEVEL_START
      3  23f7				  -	      IF	LEVEL_SIZE__011_R > MAX_LEVEL_SIZE
      4  23f7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_R
      5  23f7					      ENDIF
      0  23f7					      DEFL	_012_L, "7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#"
      0  23f7					      START_LEVEL	_012_L
      1  23f7				   LEVEL_START SET	*
      2  23f7		       00 04	   BANK_LEVEL__012_L =	_CURRENT_BANK
      3  23f7				   LEVEL__012_L SUBROUTINE
      4  23f7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23f7
      2  23f7		       37 23 33 2d*	      .byte.b	"7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#",0
      0  2427					      END_LEVEL	_012_L
      1  2427		       00		      .byte.b	0
      2  2427		       00 31	   LEVEL_SIZE__012_L =	* - LEVEL_START
      3  2428				  -	      IF	LEVEL_SIZE__012_L > MAX_LEVEL_SIZE
      4  2428				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_L
      5  2428					      ENDIF
      0  2428					      DEFL	_012_R, "-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-"
      0  2428					      START_LEVEL	_012_R
      1  2428				   LEVEL_START SET	*
      2  2428		       00 04	   BANK_LEVEL__012_R =	_CURRENT_BANK
      3  2428				   LEVEL__012_R SUBROUTINE
      4  2428				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2428
      2  2428		       2d 36 23 32*	      .byte.b	"-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-",0
      0  2464					      END_LEVEL	_012_R
      1  2464		       00		      .byte.b	0
      2  2464		       00 3d	   LEVEL_SIZE__012_R =	* - LEVEL_START
      3  2465				  -	      IF	LEVEL_SIZE__012_R > MAX_LEVEL_SIZE
      4  2465				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_R
      5  2465					      ENDIF
      0  2465					      DEFL	_013_L, "2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-"
      0  2465					      START_LEVEL	_013_L
      1  2465				   LEVEL_START SET	*
      2  2465		       00 04	   BANK_LEVEL__013_L =	_CURRENT_BANK
      3  2465				   LEVEL__013_L SUBROUTINE
      4  2465				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2465
      2  2465		       32 2d 35 23*	      .byte.b	"2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-",0
      0  24a4					      END_LEVEL	_013_L
      1  24a4		       00		      .byte.b	0
      2  24a4		       00 40	   LEVEL_SIZE__013_L =	* - LEVEL_START
      3  24a5				  -	      IF	LEVEL_SIZE__013_L > MAX_LEVEL_SIZE
      4  24a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_L
      5  24a5					      ENDIF
      0  24a5					      DEFL	_013_R, "-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-"
      0  24a5					      START_LEVEL	_013_R
      1  24a5				   LEVEL_START SET	*
      2  24a5		       00 04	   BANK_LEVEL__013_R =	_CURRENT_BANK
      3  24a5				   LEVEL__013_R SUBROUTINE
      4  24a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24a5
      2  24a5		       2d 35 23 32*	      .byte.b	"-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-",0
      0  24d8					      END_LEVEL	_013_R
      1  24d8		       00		      .byte.b	0
      2  24d8		       00 34	   LEVEL_SIZE__013_R =	* - LEVEL_START
      3  24d9				  -	      IF	LEVEL_SIZE__013_R > MAX_LEVEL_SIZE
      4  24d9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_R
      5  24d9					      ENDIF
      0  24d9					      DEFL	_014_L, "6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#"
      0  24d9					      START_LEVEL	_014_L
      1  24d9				   LEVEL_START SET	*
      2  24d9		       00 04	   BANK_LEVEL__014_L =	_CURRENT_BANK
      3  24d9				   LEVEL__014_L SUBROUTINE
      4  24d9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24d9
      2  24d9		       36 23 34 2d*	      .byte.b	"6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#",0
      0  251c					      END_LEVEL	_014_L
      1  251c		       00		      .byte.b	0
      2  251c		       00 44	   LEVEL_SIZE__014_L =	* - LEVEL_START
      3  251d					      IF	LEVEL_SIZE__014_L > MAX_LEVEL_SIZE
      4  251d				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_L
      5  251d					      ENDIF
      0  251d					      DEFL	_014_R, "6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-"
      0  251d					      START_LEVEL	_014_R
      1  251d				   LEVEL_START SET	*
      2  251d		       00 04	   BANK_LEVEL__014_R =	_CURRENT_BANK
      3  251d				   LEVEL__014_R SUBROUTINE
      4  251d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  251d
      2  251d		       36 23 33 2d*	      .byte.b	"6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-",0
      0  2560					      END_LEVEL	_014_R
      1  2560		       00		      .byte.b	0
      2  2560		       00 44	   LEVEL_SIZE__014_R =	* - LEVEL_START
      3  2561				  -	      IF	LEVEL_SIZE__014_R > MAX_LEVEL_SIZE
      4  2561				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_R
      5  2561					      ENDIF
      0  2561					      DEFL	_015_L, "2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#"
      0  2561					      START_LEVEL	_015_L
      1  2561				   LEVEL_START SET	*
      2  2561		       00 04	   BANK_LEVEL__015_L =	_CURRENT_BANK
      3  2561				   LEVEL__015_L SUBROUTINE
      4  2561				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2561
      2  2561		       32 2d 35 23*	      .byte.b	"2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#",0
      0  2596					      END_LEVEL	_015_L
      1  2596		       00		      .byte.b	0
      2  2596		       00 36	   LEVEL_SIZE__015_L =	* - LEVEL_START
      3  2597				  -	      IF	LEVEL_SIZE__015_L > MAX_LEVEL_SIZE
      4  2597				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_L
      5  2597					      ENDIF
      0  2597					      DEFL	_015_R, "3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-"
      0  2597					      START_LEVEL	_015_R
      1  2597				   LEVEL_START SET	*
      2  2597		       00 04	   BANK_LEVEL__015_R =	_CURRENT_BANK
      3  2597				   LEVEL__015_R SUBROUTINE
      4  2597				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2597
      2  2597		       33 2d 35 23*	      .byte.b	"3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-",0
      0  25dc					      END_LEVEL	_015_R
      1  25dc		       00		      .byte.b	0
      2  25dc		       00 46	   LEVEL_SIZE__015_R =	* - LEVEL_START
      3  25dd					      IF	LEVEL_SIZE__015_R > MAX_LEVEL_SIZE
      4  25dd				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_R
      5  25dd					      ENDIF
      0  25dd					      DEFL	_016_L, "4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-"
      0  25dd					      START_LEVEL	_016_L
      1  25dd				   LEVEL_START SET	*
      2  25dd		       00 04	   BANK_LEVEL__016_L =	_CURRENT_BANK
      3  25dd				   LEVEL__016_L SUBROUTINE
      4  25dd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25dd
      2  25dd		       34 2d 33 23*	      .byte.b	"4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-",0
      0  2614					      END_LEVEL	_016_L
      1  2614		       00		      .byte.b	0
      2  2614		       00 38	   LEVEL_SIZE__016_L =	* - LEVEL_START
      3  2615				  -	      IF	LEVEL_SIZE__016_L > MAX_LEVEL_SIZE
      4  2615				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_L
      5  2615					      ENDIF
      0  2615					      DEFL	_016_R, "5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-"
      0  2615					      START_LEVEL	_016_R
      1  2615				   LEVEL_START SET	*
      2  2615		       00 04	   BANK_LEVEL__016_R =	_CURRENT_BANK
      3  2615				   LEVEL__016_R SUBROUTINE
      4  2615				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2615
      2  2615		       35 23 2d 7c*	      .byte.b	"5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-",0
      0  2648					      END_LEVEL	_016_R
      1  2648		       00		      .byte.b	0
      2  2648		       00 34	   LEVEL_SIZE__016_R =	* - LEVEL_START
      3  2649				  -	      IF	LEVEL_SIZE__016_R > MAX_LEVEL_SIZE
      4  2649				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_R
      5  2649					      ENDIF
      0  2649					      DEFL	_017_L, "5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-"
      0  2649					      START_LEVEL	_017_L
      1  2649				   LEVEL_START SET	*
      2  2649		       00 04	   BANK_LEVEL__017_L =	_CURRENT_BANK
      3  2649				   LEVEL__017_L SUBROUTINE
      4  2649				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2649
      2  2649		       35 23 34 2d*	      .byte.b	"5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-",0
      0  2693					      END_LEVEL	_017_L
      1  2693		       00		      .byte.b	0
      2  2693		       00 4b	   LEVEL_SIZE__017_L =	* - LEVEL_START
      3  2694					      IF	LEVEL_SIZE__017_L > MAX_LEVEL_SIZE
      4  2694				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_L
      5  2694					      ENDIF
      0  2694					      DEFL	_017_R, "3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-"
      0  2694					      START_LEVEL	_017_R
      1  2694				   LEVEL_START SET	*
      2  2694		       00 04	   BANK_LEVEL__017_R =	_CURRENT_BANK
      3  2694				   LEVEL__017_R SUBROUTINE
      4  2694				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2694
      2  2694		       33 2d 34 23*	      .byte.b	"3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-",0
      0  26d7					      END_LEVEL	_017_R
      1  26d7		       00		      .byte.b	0
      2  26d7		       00 44	   LEVEL_SIZE__017_R =	* - LEVEL_START
      3  26d8				  -	      IF	LEVEL_SIZE__017_R > MAX_LEVEL_SIZE
      4  26d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_R
      5  26d8					      ENDIF
      0  26d8					      DEFL	_018_L, "6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#"
      0  26d8					      START_LEVEL	_018_L
      1  26d8				   LEVEL_START SET	*
      2  26d8		       00 04	   BANK_LEVEL__018_L =	_CURRENT_BANK
      3  26d8				   LEVEL__018_L SUBROUTINE
      4  26d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26d8
      2  26d8		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#",0
      0  270c					      END_LEVEL	_018_L
      1  270c		       00		      .byte.b	0
      2  270c		       00 35	   LEVEL_SIZE__018_L =	* - LEVEL_START
      3  270d				  -	      IF	LEVEL_SIZE__018_L > MAX_LEVEL_SIZE
      4  270d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_L
      5  270d					      ENDIF
      0  270d					      DEFL	_018_R, "-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#"
      0  270d					      START_LEVEL	_018_R
      1  270d				   LEVEL_START SET	*
      2  270d		       00 04	   BANK_LEVEL__018_R =	_CURRENT_BANK
      3  270d				   LEVEL__018_R SUBROUTINE
      4  270d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  270d
      2  270d		       2d 34 23 33*	      .byte.b	"-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#",0
      0  2749					      END_LEVEL	_018_R
      1  2749		       00		      .byte.b	0
      2  2749		       00 3d	   LEVEL_SIZE__018_R =	* - LEVEL_START
      3  274a				  -	      IF	LEVEL_SIZE__018_R > MAX_LEVEL_SIZE
      4  274a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_R
      5  274a					      ENDIF
      0  274a					      DEFL	_019_L, "4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#"
      0  274a					      START_LEVEL	_019_L
      1  274a				   LEVEL_START SET	*
      2  274a		       00 04	   BANK_LEVEL__019_L =	_CURRENT_BANK
      3  274a				   LEVEL__019_L SUBROUTINE
      4  274a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  274a
      2  274a		       34 2d 35 23*	      .byte.b	"4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#",0
      0  2785					      END_LEVEL	_019_L
      1  2785		       00		      .byte.b	0
      2  2785		       00 3c	   LEVEL_SIZE__019_L =	* - LEVEL_START
      3  2786				  -	      IF	LEVEL_SIZE__019_L > MAX_LEVEL_SIZE
      4  2786				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_L
      5  2786					      ENDIF
      0  2786					      DEFL	_019_R, "2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#"
      0  2786					      START_LEVEL	_019_R
      1  2786				   LEVEL_START SET	*
      2  2786		       00 04	   BANK_LEVEL__019_R =	_CURRENT_BANK
      3  2786				   LEVEL__019_R SUBROUTINE
      4  2786				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2786
      2  2786		       32 2d 37 23*	      .byte.b	"2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#",0
      0  27d6					      END_LEVEL	_019_R
      1  27d6		       00		      .byte.b	0
      2  27d6		       00 51	   LEVEL_SIZE__019_R =	* - LEVEL_START
      3  27d7					      IF	LEVEL_SIZE__019_R > MAX_LEVEL_SIZE
      4  27d7				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_R
      5  27d7					      ENDIF
     76  27d7
      0  27d7					      CHECK_BANK_SIZE	"LEVELS1"
      1  27d7		       07 d7	   .TEMP      =	* - BANK_START
 LEVELS1 (2K) SIZE =  $7d7 , FREE= $29
      2  27d7					      ECHO	"LEVELS1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27d7				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  27d7				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27d7				  -	      ERR
      6  27d7					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS2.asm LEVEL 2 PASS 3
      0  27d7					      include	"BANK_LEVELS2.asm"
      1  27d7							;    Sokoboo - a Sokoban implementation
      2  27d7							;    using a generic tile-based display engine for the Atari 2600
      3  27d7							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  27d7							;
      5  27d7							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  27d7							;
      7  27d7							;    Code related to the generic tile-based display engine was developed by
      8  27d7							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  27d7							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  27d7							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  27d7							;
     12  27d7							;    Code related to music and sound effects uses the TIATracker music player
     13  27d7							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  27d7							;    directory for Apache licensing details.
     15  27d7							;
     16  27d7							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  27d7							;    See the copyright notices in the License directory for a list of level
     18  27d7							;    contributors.
     19  27d7							;
     20  27d7							;    Except where otherwise indicated, this software is released under the
     21  27d7							;    following licensing arrangement...
     22  27d7							;
     23  27d7							;    This program is free software: you can redistribute it and/or modify
     24  27d7							;    it under the terms of the GNU General Public License as published by
     25  27d7							;    the Free Software Foundation, either version 3 of the License, or
     26  27d7							;    (at your option) any later version.
     27  27d7							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  27d7
     29  27d7							;    This program is distributed in the hope that it will be useful,
     30  27d7							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  27d7							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  27d7							;    GNU General Public License for more details.
     33  27d7
      0  27d7					      NEWBANK	LEVELS2
      1  2ec2 ????				      SEG	LEVELS2
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   LEVELS2    SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	LEVELS2
     35  2800
      0  2800					      DEFL	_020_L, "-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-"
      0  2800					      START_LEVEL	_020_L
      1  2800				   LEVEL_START SET	*
      2  2800		       00 05	   BANK_LEVEL__020_L =	_CURRENT_BANK
      3  2800				   LEVEL__020_L SUBROUTINE
      4  2800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2800
      2  2800		       2d 36 23 2d*	      .byte.b	"-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-",0
      0  283f					      END_LEVEL	_020_L
      1  283f		       00		      .byte.b	0
      2  283f		       00 40	   LEVEL_SIZE__020_L =	* - LEVEL_START
      3  2840				  -	      IF	LEVEL_SIZE__020_L > MAX_LEVEL_SIZE
      4  2840				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_L
      5  2840					      ENDIF
      0  2840					      DEFL	_020_R, "5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-"
      0  2840					      START_LEVEL	_020_R
      1  2840				   LEVEL_START SET	*
      2  2840		       00 05	   BANK_LEVEL__020_R =	_CURRENT_BANK
      3  2840				   LEVEL__020_R SUBROUTINE
      4  2840				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2840
      2  2840		       35 2d 34 23*	      .byte.b	"5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-",0
      0  2880					      END_LEVEL	_020_R
      1  2880		       00		      .byte.b	0
      2  2880		       00 41	   LEVEL_SIZE__020_R =	* - LEVEL_START
      3  2881				  -	      IF	LEVEL_SIZE__020_R > MAX_LEVEL_SIZE
      4  2881				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_R
      5  2881					      ENDIF
      0  2881					      DEFL	_021_L, "4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-"
      0  2881					      START_LEVEL	_021_L
      1  2881				   LEVEL_START SET	*
      2  2881		       00 05	   BANK_LEVEL__021_L =	_CURRENT_BANK
      3  2881				   LEVEL__021_L SUBROUTINE
      4  2881				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2881
      2  2881		       34 2d 34 23*	      .byte.b	"4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-",0
      0  28d7					      END_LEVEL	_021_L
      1  28d7		       00		      .byte.b	0
      2  28d7		       00 57	   LEVEL_SIZE__021_L =	* - LEVEL_START
      3  28d8					      IF	LEVEL_SIZE__021_L > MAX_LEVEL_SIZE
      4  28d8				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_L
      5  28d8					      ENDIF
      0  28d8					      DEFL	_021_R, "-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-"
      0  28d8					      START_LEVEL	_021_R
      1  28d8				   LEVEL_START SET	*
      2  28d8		       00 05	   BANK_LEVEL__021_R =	_CURRENT_BANK
      3  28d8				   LEVEL__021_R SUBROUTINE
      4  28d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  28d8
      2  28d8		       2d 34 23 33*	      .byte.b	"-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-",0
      0  290c					      END_LEVEL	_021_R
      1  290c		       00		      .byte.b	0
      2  290c		       00 35	   LEVEL_SIZE__021_R =	* - LEVEL_START
      3  290d				  -	      IF	LEVEL_SIZE__021_R > MAX_LEVEL_SIZE
      4  290d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_R
      5  290d					      ENDIF
      0  290d					      DEFL	_022_L, "3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-"
      0  290d					      START_LEVEL	_022_L
      1  290d				   LEVEL_START SET	*
      2  290d		       00 05	   BANK_LEVEL__022_L =	_CURRENT_BANK
      3  290d				   LEVEL__022_L SUBROUTINE
      4  290d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  290d
      2  290d		       33 2d 33 23*	      .byte.b	"3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-",0
      0  2953					      END_LEVEL	_022_L
      1  2953		       00		      .byte.b	0
      2  2953		       00 47	   LEVEL_SIZE__022_L =	* - LEVEL_START
      3  2954				  -	      IF	LEVEL_SIZE__022_L > MAX_LEVEL_SIZE
      4  2954				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_L
      5  2954					      ENDIF
      0  2954					      DEFL	_022_R, "-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-"
      0  2954					      START_LEVEL	_022_R
      1  2954				   LEVEL_START SET	*
      2  2954		       00 05	   BANK_LEVEL__022_R =	_CURRENT_BANK
      3  2954				   LEVEL__022_R SUBROUTINE
      4  2954				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2954
      2  2954		       2d 33 23 34*	      .byte.b	"-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-",0
      0  2990					      END_LEVEL	_022_R
      1  2990		       00		      .byte.b	0
      2  2990		       00 3d	   LEVEL_SIZE__022_R =	* - LEVEL_START
      3  2991				  -	      IF	LEVEL_SIZE__022_R > MAX_LEVEL_SIZE
      4  2991				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_R
      5  2991					      ENDIF
      0  2991					      DEFL	_023_L, "6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#"
      0  2991					      START_LEVEL	_023_L
      1  2991				   LEVEL_START SET	*
      2  2991		       00 05	   BANK_LEVEL__023_L =	_CURRENT_BANK
      3  2991				   LEVEL__023_L SUBROUTINE
      4  2991				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2991
      2  2991		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#",0
      0  29d2					      END_LEVEL	_023_L
      1  29d2		       00		      .byte.b	0
      2  29d2		       00 42	   LEVEL_SIZE__023_L =	* - LEVEL_START
      3  29d3				  -	      IF	LEVEL_SIZE__023_L > MAX_LEVEL_SIZE
      4  29d3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_L
      5  29d3					      ENDIF
      0  29d3					      DEFL	_023_R, "7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-"
      0  29d3					      START_LEVEL	_023_R
      1  29d3				   LEVEL_START SET	*
      2  29d3		       00 05	   BANK_LEVEL__023_R =	_CURRENT_BANK
      3  29d3				   LEVEL__023_R SUBROUTINE
      4  29d3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  29d3
      2  29d3		       37 23 32 2d*	      .byte.b	"7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-",0
      0  2a15					      END_LEVEL	_023_R
      1  2a15		       00		      .byte.b	0
      2  2a15		       00 43	   LEVEL_SIZE__023_R =	* - LEVEL_START
      3  2a16				  -	      IF	LEVEL_SIZE__023_R > MAX_LEVEL_SIZE
      4  2a16				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_R
      5  2a16					      ENDIF
     44  2a16
      0  2a16					      DEFL	_050_L, "4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#"
      0  2a16					      START_LEVEL	_050_L
      1  2a16				   LEVEL_START SET	*
      2  2a16		       00 05	   BANK_LEVEL__050_L =	_CURRENT_BANK
      3  2a16				   LEVEL__050_L SUBROUTINE
      4  2a16				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a16
      2  2a16		       34 2d 35 23*	      .byte.b	"4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#",0
      0  2a63					      END_LEVEL	_050_L
      1  2a63		       00		      .byte.b	0
      2  2a63		       00 4e	   LEVEL_SIZE__050_L =	* - LEVEL_START
      3  2a64				  -	      IF	LEVEL_SIZE__050_L > MAX_LEVEL_SIZE
      4  2a64				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_L
      5  2a64					      ENDIF
      0  2a64					      DEFL	_050_R, "8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#"
      0  2a64					      START_LEVEL	_050_R
      1  2a64				   LEVEL_START SET	*
      2  2a64		       00 05	   BANK_LEVEL__050_R =	_CURRENT_BANK
      3  2a64				   LEVEL__050_R SUBROUTINE
      4  2a64				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a64
      2  2a64		       38 23 7c 23*	      .byte.b	"8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#",0
      0  2a9d					      END_LEVEL	_050_R
      1  2a9d		       00		      .byte.b	0
      2  2a9d		       00 3a	   LEVEL_SIZE__050_R =	* - LEVEL_START
      3  2a9e				  -	      IF	LEVEL_SIZE__050_R > MAX_LEVEL_SIZE
      4  2a9e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_R
      5  2a9e					      ENDIF
      0  2a9e					      DEFL	_051_L, "-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#"
      0  2a9e					      START_LEVEL	_051_L
      1  2a9e				   LEVEL_START SET	*
      2  2a9e		       00 05	   BANK_LEVEL__051_L =	_CURRENT_BANK
      3  2a9e				   LEVEL__051_L SUBROUTINE
      4  2a9e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a9e
      2  2a9e		       2d 36 23 34*	      .byte.b	"-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#",0
      0  2af1					      END_LEVEL	_051_L
      1  2af1		       00		      .byte.b	0
      2  2af1		       00 54	   LEVEL_SIZE__051_L =	* - LEVEL_START
      3  2af2				  -	      IF	LEVEL_SIZE__051_L > MAX_LEVEL_SIZE
      4  2af2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_L
      5  2af2					      ENDIF
      0  2af2					      DEFL	_051_R, "-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-"
      0  2af2					      START_LEVEL	_051_R
      1  2af2				   LEVEL_START SET	*
      2  2af2		       00 05	   BANK_LEVEL__051_R =	_CURRENT_BANK
      3  2af2				   LEVEL__051_R SUBROUTINE
      4  2af2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2af2
      2  2af2		       2d 38 23 2d*	      .byte.b	"-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-",0
      0  2b43					      END_LEVEL	_051_R
      1  2b43		       00		      .byte.b	0
      2  2b43		       00 52	   LEVEL_SIZE__051_R =	* - LEVEL_START
      3  2b44				  -	      IF	LEVEL_SIZE__051_R > MAX_LEVEL_SIZE
      4  2b44				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_R
      5  2b44					      ENDIF
      0  2b44					      DEFL	_052_L, "5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-"
      0  2b44					      START_LEVEL	_052_L
      1  2b44				   LEVEL_START SET	*
      2  2b44		       00 05	   BANK_LEVEL__052_L =	_CURRENT_BANK
      3  2b44				   LEVEL__052_L SUBROUTINE
      4  2b44				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b44
      2  2b44		       35 23 36 2d*	      .byte.b	"5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-",0
      0  2b7e					      END_LEVEL	_052_L
      1  2b7e		       00		      .byte.b	0
      2  2b7e		       00 3b	   LEVEL_SIZE__052_L =	* - LEVEL_START
      3  2b7f				  -	      IF	LEVEL_SIZE__052_L > MAX_LEVEL_SIZE
      4  2b7f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_L
      5  2b7f					      ENDIF
      0  2b7f					      DEFL	_052_R, "2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-"
      0  2b7f					      START_LEVEL	_052_R
      1  2b7f				   LEVEL_START SET	*
      2  2b7f		       00 05	   BANK_LEVEL__052_R =	_CURRENT_BANK
      3  2b7f				   LEVEL__052_R SUBROUTINE
      4  2b7f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b7f
      2  2b7f		       32 2d 37 23*	      .byte.b	"2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-",0
      0  2bc7					      END_LEVEL	_052_R
      1  2bc7		       00		      .byte.b	0
      2  2bc7		       00 49	   LEVEL_SIZE__052_R =	* - LEVEL_START
      3  2bc8				  -	      IF	LEVEL_SIZE__052_R > MAX_LEVEL_SIZE
      4  2bc8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_R
      5  2bc8					      ENDIF
      0  2bc8					      DEFL	_053_L, "6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-"
      0  2bc8					      START_LEVEL	_053_L
      1  2bc8				   LEVEL_START SET	*
      2  2bc8		       00 05	   BANK_LEVEL__053_L =	_CURRENT_BANK
      3  2bc8				   LEVEL__053_L SUBROUTINE
      4  2bc8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2bc8
      2  2bc8		       36 23 36 2d*	      .byte.b	"6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-",0
      0  2c1d					      END_LEVEL	_053_L
      1  2c1d		       00		      .byte.b	0
      2  2c1d		       00 56	   LEVEL_SIZE__053_L =	* - LEVEL_START
      3  2c1e				  -	      IF	LEVEL_SIZE__053_L > MAX_LEVEL_SIZE
      4  2c1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_L
      5  2c1e					      ENDIF
      0  2c1e					      DEFL	_053_R, "5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-"
      0  2c1e					      START_LEVEL	_053_R
      1  2c1e				   LEVEL_START SET	*
      2  2c1e		       00 05	   BANK_LEVEL__053_R =	_CURRENT_BANK
      3  2c1e				   LEVEL__053_R SUBROUTINE
      4  2c1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c1e
      2  2c1e		       35 2d 35 23*	      .byte.b	"5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-",0
      0  2c6b					      END_LEVEL	_053_R
      1  2c6b		       00		      .byte.b	0
      2  2c6b		       00 4e	   LEVEL_SIZE__053_R =	* - LEVEL_START
      3  2c6c				  -	      IF	LEVEL_SIZE__053_R > MAX_LEVEL_SIZE
      4  2c6c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_R
      5  2c6c					      ENDIF
      0  2c6c					      DEFL	_054_L, "-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-"
      0  2c6c					      START_LEVEL	_054_L
      1  2c6c				   LEVEL_START SET	*
      2  2c6c		       00 05	   BANK_LEVEL__054_L =	_CURRENT_BANK
      3  2c6c				   LEVEL__054_L SUBROUTINE
      4  2c6c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c6c
      2  2c6c		       2d 38 23 32*	      .byte.b	"-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-",0
      0  2cb8					      END_LEVEL	_054_L
      1  2cb8		       00		      .byte.b	0
      2  2cb8		       00 4d	   LEVEL_SIZE__054_L =	* - LEVEL_START
      3  2cb9				  -	      IF	LEVEL_SIZE__054_L > MAX_LEVEL_SIZE
      4  2cb9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_L
      5  2cb9					      ENDIF
      0  2cb9					      DEFL	_054_R, "2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-"
      0  2cb9					      START_LEVEL	_054_R
      1  2cb9				   LEVEL_START SET	*
      2  2cb9		       00 05	   BANK_LEVEL__054_R =	_CURRENT_BANK
      3  2cb9				   LEVEL__054_R SUBROUTINE
      4  2cb9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cb9
      2  2cb9		       32 2d 34 23*	      .byte.b	"2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-",0
      0  2d02					      END_LEVEL	_054_R
      1  2d02		       00		      .byte.b	0
      2  2d02		       00 4a	   LEVEL_SIZE__054_R =	* - LEVEL_START
      3  2d03				  -	      IF	LEVEL_SIZE__054_R > MAX_LEVEL_SIZE
      4  2d03				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_R
      5  2d03					      ENDIF
      0  2d03					      DEFL	_055_L, "2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-"
      0  2d03					      START_LEVEL	_055_L
      1  2d03				   LEVEL_START SET	*
      2  2d03		       00 05	   BANK_LEVEL__055_L =	_CURRENT_BANK
      3  2d03				   LEVEL__055_L SUBROUTINE
      4  2d03				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d03
      2  2d03		       32 2d 34 23*	      .byte.b	"2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-",0
      0  2d5d					      END_LEVEL	_055_L
      1  2d5d		       00		      .byte.b	0
      2  2d5d		       00 5b	   LEVEL_SIZE__055_L =	* - LEVEL_START
      3  2d5e					      IF	LEVEL_SIZE__055_L > MAX_LEVEL_SIZE
      4  2d5e				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_L
      5  2d5e					      ENDIF
      0  2d5e					      DEFL	_055_R, "5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-"
      0  2d5e					      START_LEVEL	_055_R
      1  2d5e				   LEVEL_START SET	*
      2  2d5e		       00 05	   BANK_LEVEL__055_R =	_CURRENT_BANK
      3  2d5e				   LEVEL__055_R SUBROUTINE
      4  2d5e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d5e
      2  2d5e		       35 2d 34 23*	      .byte.b	"5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-",0
      0  2db3					      END_LEVEL	_055_R
      1  2db3		       00		      .byte.b	0
      2  2db3		       00 56	   LEVEL_SIZE__055_R =	* - LEVEL_START
      3  2db4				  -	      IF	LEVEL_SIZE__055_R > MAX_LEVEL_SIZE
      4  2db4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_R
      5  2db4					      ENDIF
      0  2db4					      DEFL	_056_L, "6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#"
      0  2db4					      START_LEVEL	_056_L
      1  2db4				   LEVEL_START SET	*
      2  2db4		       00 05	   BANK_LEVEL__056_L =	_CURRENT_BANK
      3  2db4				   LEVEL__056_L SUBROUTINE
      4  2db4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2db4
      2  2db4		       36 2d 35 23*	      .byte.b	"6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#",0
      0  2e0e					      END_LEVEL	_056_L
      1  2e0e		       00		      .byte.b	0
      2  2e0e		       00 5b	   LEVEL_SIZE__056_L =	* - LEVEL_START
      3  2e0f				  -	      IF	LEVEL_SIZE__056_L > MAX_LEVEL_SIZE
      4  2e0f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_L
      5  2e0f					      ENDIF
      0  2e0f					      DEFL	_056_R, "-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-"
      0  2e0f					      START_LEVEL	_056_R
      1  2e0f				   LEVEL_START SET	*
      2  2e0f		       00 05	   BANK_LEVEL__056_R =	_CURRENT_BANK
      3  2e0f				   LEVEL__056_R SUBROUTINE
      4  2e0f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e0f
      2  2e0f		       2d 34 23 2d*	      .byte.b	"-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-",0
      0  2e6a					      END_LEVEL	_056_R
      1  2e6a		       00		      .byte.b	0
      2  2e6a		       00 5c	   LEVEL_SIZE__056_R =	* - LEVEL_START
      3  2e6b					      IF	LEVEL_SIZE__056_R > MAX_LEVEL_SIZE
      4  2e6b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_R
      5  2e6b					      ENDIF
      0  2e6b					      DEFL	_057_L, "5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-"
      0  2e6b					      START_LEVEL	_057_L
      1  2e6b				   LEVEL_START SET	*
      2  2e6b		       00 05	   BANK_LEVEL__057_L =	_CURRENT_BANK
      3  2e6b				   LEVEL__057_L SUBROUTINE
      4  2e6b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e6b
      2  2e6b		       35 2d 36 23*	      .byte.b	"5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-",0
      0  2ec1					      END_LEVEL	_057_L
      1  2ec1		       00		      .byte.b	0
      2  2ec1		       00 57	   LEVEL_SIZE__057_L =	* - LEVEL_START
      3  2ec2				  -	      IF	LEVEL_SIZE__057_L > MAX_LEVEL_SIZE
      4  2ec2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_L
      5  2ec2					      ENDIF
     60  2ec2
      0  2ec2					      CHECK_BANK_SIZE	"LEVELS2"
      1  2ec2		       06 c2	   .TEMP      =	* - BANK_START
 LEVELS2 (2K) SIZE =  $6c2 , FREE= $13e
      2  2ec2					      ECHO	"LEVELS2", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2ec2				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2ec2				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2ec2				  -	      ERR
      6  2ec2					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS3.asm LEVEL 2 PASS 3
      0  2ec2					      include	"BANK_LEVELS3.asm"
      1  2ec2							;    Sokoboo - a Sokoban implementation
      2  2ec2							;    using a generic tile-based display engine for the Atari 2600
      3  2ec2							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  2ec2							;
      5  2ec2							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  2ec2							;
      7  2ec2							;    Code related to the generic tile-based display engine was developed by
      8  2ec2							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  2ec2							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  2ec2							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  2ec2							;
     12  2ec2							;    Code related to music and sound effects uses the TIATracker music player
     13  2ec2							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  2ec2							;    directory for Apache licensing details.
     15  2ec2							;
     16  2ec2							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  2ec2							;    See the copyright notices in the License directory for a list of level
     18  2ec2							;    contributors.
     19  2ec2							;
     20  2ec2							;    Except where otherwise indicated, this software is released under the
     21  2ec2							;    following licensing arrangement...
     22  2ec2							;
     23  2ec2							;    This program is free software: you can redistribute it and/or modify
     24  2ec2							;    it under the terms of the GNU General Public License as published by
     25  2ec2							;    the Free Software Foundation, either version 3 of the License, or
     26  2ec2							;    (at your option) any later version.
     27  2ec2							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  2ec2
     29  2ec2							;    This program is distributed in the hope that it will be useful,
     30  2ec2							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  2ec2							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  2ec2							;    GNU General Public License for more details.
     33  2ec2
      0  2ec2					      NEWBANK	LEVELS3
      1  362c ????				      SEG	LEVELS3
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   LEVELS3    SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	LEVELS3
     35  3000
      0  3000					      DEFL	_060_R, "3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#"
      0  3000					      START_LEVEL	_060_R
      1  3000				   LEVEL_START SET	*
      2  3000		       00 06	   BANK_LEVEL__060_R =	_CURRENT_BANK
      3  3000				   LEVEL__060_R SUBROUTINE
      4  3000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3000
      2  3000		       33 2d 36 23*	      .byte.b	"3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#",0
      0  3048					      END_LEVEL	_060_R
      1  3048		       00		      .byte.b	0
      2  3048		       00 49	   LEVEL_SIZE__060_R =	* - LEVEL_START
      3  3049				  -	      IF	LEVEL_SIZE__060_R > MAX_LEVEL_SIZE
      4  3049				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__060_R
      5  3049					      ENDIF
      0  3049					      DEFL	_061_L, "10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#"
      0  3049					      START_LEVEL	_061_L
      1  3049				   LEVEL_START SET	*
      2  3049		       00 06	   BANK_LEVEL__061_L =	_CURRENT_BANK
      3  3049				   LEVEL__061_L SUBROUTINE
      4  3049				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3049
      2  3049		       31 30 23 2d*	      .byte.b	"10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#",0
      0  309d					      END_LEVEL	_061_L
      1  309d		       00		      .byte.b	0
      2  309d		       00 55	   LEVEL_SIZE__061_L =	* - LEVEL_START
      3  309e				  -	      IF	LEVEL_SIZE__061_L > MAX_LEVEL_SIZE
      4  309e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_L
      5  309e					      ENDIF
      0  309e					      DEFL	_061_R, "4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#"
      0  309e					      START_LEVEL	_061_R
      1  309e				   LEVEL_START SET	*
      2  309e		       00 06	   BANK_LEVEL__061_R =	_CURRENT_BANK
      3  309e				   LEVEL__061_R SUBROUTINE
      4  309e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  309e
      2  309e		       34 2d 35 23*	      .byte.b	"4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#",0
      0  30e7					      END_LEVEL	_061_R
      1  30e7		       00		      .byte.b	0
      2  30e7		       00 4a	   LEVEL_SIZE__061_R =	* - LEVEL_START
      3  30e8				  -	      IF	LEVEL_SIZE__061_R > MAX_LEVEL_SIZE
      4  30e8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_R
      5  30e8					      ENDIF
      0  30e8					      DEFL	_062_L, "-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#"
      0  30e8					      START_LEVEL	_062_L
      1  30e8				   LEVEL_START SET	*
      2  30e8		       00 06	   BANK_LEVEL__062_L =	_CURRENT_BANK
      3  30e8				   LEVEL__062_L SUBROUTINE
      4  30e8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  30e8
      2  30e8		       2d 35 23 36*	      .byte.b	"-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#",0
      0  313f					      END_LEVEL	_062_L
      1  313f		       00		      .byte.b	0
      2  313f		       00 58	   LEVEL_SIZE__062_L =	* - LEVEL_START
      3  3140				  -	      IF	LEVEL_SIZE__062_L > MAX_LEVEL_SIZE
      4  3140				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_L
      5  3140					      ENDIF
      0  3140					      DEFL	_062_R, "5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-"
      0  3140					      START_LEVEL	_062_R
      1  3140				   LEVEL_START SET	*
      2  3140		       00 06	   BANK_LEVEL__062_R =	_CURRENT_BANK
      3  3140				   LEVEL__062_R SUBROUTINE
      4  3140				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3140
      2  3140		       35 2d 35 23*	      .byte.b	"5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-",0
      0  318c					      END_LEVEL	_062_R
      1  318c		       00		      .byte.b	0
      2  318c		       00 4d	   LEVEL_SIZE__062_R =	* - LEVEL_START
      3  318d				  -	      IF	LEVEL_SIZE__062_R > MAX_LEVEL_SIZE
      4  318d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_R
      5  318d					      ENDIF
      0  318d					      DEFL	_063_L, "2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#"
      0  318d					      START_LEVEL	_063_L
      1  318d				   LEVEL_START SET	*
      2  318d		       00 06	   BANK_LEVEL__063_L =	_CURRENT_BANK
      3  318d				   LEVEL__063_L SUBROUTINE
      4  318d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  318d
      2  318d		       32 2d 35 23*	      .byte.b	"2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#",0
      0  31dd					      END_LEVEL	_063_L
      1  31dd		       00		      .byte.b	0
      2  31dd		       00 51	   LEVEL_SIZE__063_L =	* - LEVEL_START
      3  31de				  -	      IF	LEVEL_SIZE__063_L > MAX_LEVEL_SIZE
      4  31de				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_L
      5  31de					      ENDIF
      0  31de					      DEFL	_063_R, "2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-"
      0  31de					      START_LEVEL	_063_R
      1  31de				   LEVEL_START SET	*
      2  31de		       00 06	   BANK_LEVEL__063_R =	_CURRENT_BANK
      3  31de				   LEVEL__063_R SUBROUTINE
      4  31de				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  31de
      2  31de		       32 2d 36 23*	      .byte.b	"2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-",0
      0  3230					      END_LEVEL	_063_R
      1  3230		       00		      .byte.b	0
      2  3230		       00 53	   LEVEL_SIZE__063_R =	* - LEVEL_START
      3  3231				  -	      IF	LEVEL_SIZE__063_R > MAX_LEVEL_SIZE
      4  3231				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_R
      5  3231					      ENDIF
      0  3231					      DEFL	_064_L, "-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-"
      0  3231					      START_LEVEL	_064_L
      1  3231				   LEVEL_START SET	*
      2  3231		       00 06	   BANK_LEVEL__064_L =	_CURRENT_BANK
      3  3231				   LEVEL__064_L SUBROUTINE
      4  3231				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3231
      2  3231		       2d 38 23 33*	      .byte.b	"-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-",0
      0  328c					      END_LEVEL	_064_L
      1  328c		       00		      .byte.b	0
      2  328c		       00 5c	   LEVEL_SIZE__064_L =	* - LEVEL_START
      3  328d				  -	      IF	LEVEL_SIZE__064_L > MAX_LEVEL_SIZE
      4  328d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_L
      5  328d					      ENDIF
      0  328d					      DEFL	_064_R, "4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-"
      0  328d					      START_LEVEL	_064_R
      1  328d				   LEVEL_START SET	*
      2  328d		       00 06	   BANK_LEVEL__064_R =	_CURRENT_BANK
      3  328d				   LEVEL__064_R SUBROUTINE
      4  328d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  328d
      2  328d		       34 23 2d 36*	      .byte.b	"4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-",0
      0  32d9					      END_LEVEL	_064_R
      1  32d9		       00		      .byte.b	0
      2  32d9		       00 4d	   LEVEL_SIZE__064_R =	* - LEVEL_START
      3  32da				  -	      IF	LEVEL_SIZE__064_R > MAX_LEVEL_SIZE
      4  32da				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_R
      5  32da					      ENDIF
      0  32da					      DEFL	_065_L, "2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-"
      0  32da					      START_LEVEL	_065_L
      1  32da				   LEVEL_START SET	*
      2  32da		       00 06	   BANK_LEVEL__065_L =	_CURRENT_BANK
      3  32da				   LEVEL__065_L SUBROUTINE
      4  32da				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  32da
      2  32da		       32 2d 35 23*	      .byte.b	"2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-",0
      0  3332					      END_LEVEL	_065_L
      1  3332		       00		      .byte.b	0
      2  3332		       00 59	   LEVEL_SIZE__065_L =	* - LEVEL_START
      3  3333				  -	      IF	LEVEL_SIZE__065_L > MAX_LEVEL_SIZE
      4  3333				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_L
      5  3333					      ENDIF
      0  3333					      DEFL	_065_R, "3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#"
      0  3333					      START_LEVEL	_065_R
      1  3333				   LEVEL_START SET	*
      2  3333		       00 06	   BANK_LEVEL__065_R =	_CURRENT_BANK
      3  3333				   LEVEL__065_R SUBROUTINE
      4  3333				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3333
      2  3333		       33 2d 35 23*	      .byte.b	"3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#",0
      0  337b					      END_LEVEL	_065_R
      1  337b		       00		      .byte.b	0
      2  337b		       00 49	   LEVEL_SIZE__065_R =	* - LEVEL_START
      3  337c				  -	      IF	LEVEL_SIZE__065_R > MAX_LEVEL_SIZE
      4  337c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_R
      5  337c					      ENDIF
      0  337c					      DEFL	_066_L, "10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-"
      0  337c					      START_LEVEL	_066_L
      1  337c				   LEVEL_START SET	*
      2  337c		       00 06	   BANK_LEVEL__066_L =	_CURRENT_BANK
      3  337c				   LEVEL__066_L SUBROUTINE
      4  337c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  337c
      2  337c		       31 30 23 33*	      .byte.b	"10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-",0
      0  33d6					      END_LEVEL	_066_L
      1  33d6		       00		      .byte.b	0
      2  33d6		       00 5b	   LEVEL_SIZE__066_L =	* - LEVEL_START
      3  33d7				  -	      IF	LEVEL_SIZE__066_L > MAX_LEVEL_SIZE
      4  33d7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_L
      5  33d7					      ENDIF
      0  33d7					      DEFL	_066_R, "2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#"
      0  33d7					      START_LEVEL	_066_R
      1  33d7				   LEVEL_START SET	*
      2  33d7		       00 06	   BANK_LEVEL__066_R =	_CURRENT_BANK
      3  33d7				   LEVEL__066_R SUBROUTINE
      4  33d7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  33d7
      2  33d7		       32 2d 35 23*	      .byte.b	"2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#",0
      0  342d					      END_LEVEL	_066_R
      1  342d		       00		      .byte.b	0
      2  342d		       00 57	   LEVEL_SIZE__066_R =	* - LEVEL_START
      3  342e				  -	      IF	LEVEL_SIZE__066_R > MAX_LEVEL_SIZE
      4  342e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_R
      5  342e					      ENDIF
      0  342e					      DEFL	_067_L, "8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#"
      0  342e					      START_LEVEL	_067_L
      1  342e				   LEVEL_START SET	*
      2  342e		       00 06	   BANK_LEVEL__067_L =	_CURRENT_BANK
      3  342e				   LEVEL__067_L SUBROUTINE
      4  342e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  342e
      2  342e		       38 23 33 2d*	      .byte.b	"8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#",0
      0  347b					      END_LEVEL	_067_L
      1  347b		       00		      .byte.b	0
      2  347b		       00 4e	   LEVEL_SIZE__067_L =	* - LEVEL_START
      3  347c				  -	      IF	LEVEL_SIZE__067_L > MAX_LEVEL_SIZE
      4  347c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_L
      5  347c					      ENDIF
      0  347c					      DEFL	_067_R, "7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-"
      0  347c					      START_LEVEL	_067_R
      1  347c				   LEVEL_START SET	*
      2  347c		       00 06	   BANK_LEVEL__067_R =	_CURRENT_BANK
      3  347c				   LEVEL__067_R SUBROUTINE
      4  347c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  347c
      2  347c		       37 23 32 2d*	      .byte.b	"7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-",0
      0  34e1					      END_LEVEL	_067_R
      1  34e1		       00		      .byte.b	0
      2  34e1		       00 66	   LEVEL_SIZE__067_R =	* - LEVEL_START
      3  34e2					      IF	LEVEL_SIZE__067_R > MAX_LEVEL_SIZE
      4  34e2				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_R
      5  34e2					      ENDIF
      0  34e2					      DEFL	_068_L, "10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-"
      0  34e2					      START_LEVEL	_068_L
      1  34e2				   LEVEL_START SET	*
      2  34e2		       00 06	   BANK_LEVEL__068_L =	_CURRENT_BANK
      3  34e2				   LEVEL__068_L SUBROUTINE
      4  34e2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  34e2
      2  34e2		       31 30 23 7c*	      .byte.b	"10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-",0
      0  3536					      END_LEVEL	_068_L
      1  3536		       00		      .byte.b	0
      2  3536		       00 55	   LEVEL_SIZE__068_L =	* - LEVEL_START
      3  3537				  -	      IF	LEVEL_SIZE__068_L > MAX_LEVEL_SIZE
      4  3537				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_L
      5  3537					      ENDIF
      0  3537					      DEFL	_068_R, "5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-"
      0  3537					      START_LEVEL	_068_R
      1  3537				   LEVEL_START SET	*
      2  3537		       00 06	   BANK_LEVEL__068_R =	_CURRENT_BANK
      3  3537				   LEVEL__068_R SUBROUTINE
      4  3537				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3537
      2  3537		       35 2d 35 23*	      .byte.b	"5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-",0
      0  358d					      END_LEVEL	_068_R
      1  358d		       00		      .byte.b	0
      2  358d		       00 57	   LEVEL_SIZE__068_R =	* - LEVEL_START
      3  358e				  -	      IF	LEVEL_SIZE__068_R > MAX_LEVEL_SIZE
      4  358e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_R
      5  358e					      ENDIF
      0  358e					      DEFL	_069_L, "-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#"
      0  358e					      START_LEVEL	_069_L
      1  358e				   LEVEL_START SET	*
      2  358e		       00 06	   BANK_LEVEL__069_L =	_CURRENT_BANK
      3  358e				   LEVEL__069_L SUBROUTINE
      4  358e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  358e
      2  358e		       2d 36 23 33*	      .byte.b	"-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#",0
      0  35dc					      END_LEVEL	_069_L
      1  35dc		       00		      .byte.b	0
      2  35dc		       00 4f	   LEVEL_SIZE__069_L =	* - LEVEL_START
      3  35dd				  -	      IF	LEVEL_SIZE__069_L > MAX_LEVEL_SIZE
      4  35dd				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_L
      5  35dd					      ENDIF
      0  35dd					      DEFL	_069_R, "2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-"
      0  35dd					      START_LEVEL	_069_R
      1  35dd				   LEVEL_START SET	*
      2  35dd		       00 06	   BANK_LEVEL__069_R =	_CURRENT_BANK
      3  35dd				   LEVEL__069_R SUBROUTINE
      4  35dd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35dd
      2  35dd		       32 2d 35 23*	      .byte.b	"2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-",0
      0  362b					      END_LEVEL	_069_R
      1  362b		       00		      .byte.b	0
      2  362b		       00 4f	   LEVEL_SIZE__069_R =	* - LEVEL_START
      3  362c				  -	      IF	LEVEL_SIZE__069_R > MAX_LEVEL_SIZE
      4  362c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_R
      5  362c					      ENDIF
     55  362c
     56  362c
     57  362c
      0  362c					      CHECK_BANK_SIZE	"LEVELS3 -- full 2K"
      1  362c		       06 2c	   .TEMP      =	* - BANK_START
 LEVELS3 -- full 2K (2K) SIZE =  $62c , FREE= $1d4
      2  362c					      ECHO	"LEVELS3 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  362c				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  362c				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  362c				  -	      ERR
      6  362c					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS4.asm LEVEL 2 PASS 3
      0  362c					      include	"BANK_LEVELS4.asm"
      1  362c							;    Sokoboo - a Sokoban implementation
      2  362c							;    using a generic tile-based display engine for the Atari 2600
      3  362c							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  362c							;
      5  362c							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  362c							;
      7  362c							;    Code related to the generic tile-based display engine was developed by
      8  362c							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  362c							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  362c							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  362c							;
     12  362c							;    Code related to music and sound effects uses the TIATracker music player
     13  362c							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  362c							;    directory for Apache licensing details.
     15  362c							;
     16  362c							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  362c							;    See the copyright notices in the License directory for a list of level
     18  362c							;    contributors.
     19  362c							;
     20  362c							;    Except where otherwise indicated, this software is released under the
     21  362c							;    following licensing arrangement...
     22  362c							;
     23  362c							;    This program is free software: you can redistribute it and/or modify
     24  362c							;    it under the terms of the GNU General Public License as published by
     25  362c							;    the Free Software Foundation, either version 3 of the License, or
     26  362c							;    (at your option) any later version.
     27  362c							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  362c
     29  362c							;    This program is distributed in the hope that it will be useful,
     30  362c							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  362c							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  362c							;    GNU General Public License for more details.
     33  362c
     34  362c							; level definitions
     35  362c							; Sample level definitions.
     36  362c							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  362c							; have as many banks as you like.
     38  362c
      0  362c					      NEWBANK	LEVELS4
      1  3db3 ????				      SEG	LEVELS4
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   LEVELS4    SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	LEVELS4
     40  3800
     41  3800							; Level definitions
     42  3800
     43  3800							; "sokhard" collection
     44  3800
      0  3800					      START_LEVEL	_102_Natalie
      1  3800				   LEVEL_START SET	*
      2  3800		       00 07	   BANK_LEVEL__102_Natalie =	_CURRENT_BANK
      3  3800				   LEVEL__102_Natalie SUBROUTINE
      4  3800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3800
     46  3800		       31 31 23 7c*	      .byte.b	"11#|2#2-#@4.#|2#3-2$.2*#|2#-$2-2$#.#|#2-$#-#2-.#|#2-$-#-2#-#|#9-#|11#",0
      0  3846					      END_LEVEL	_102_Natalie
      1  3846		       00		      .byte.b	0
      2  3846		       00 47	   LEVEL_SIZE__102_Natalie =	* - LEVEL_START
      3  3847				  -	      IF	LEVEL_SIZE__102_Natalie > MAX_LEVEL_SIZE
      4  3847				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Natalie
      5  3847					      ENDIF
     48  3847
      0  3847					      START_LEVEL	_102_Mirabel
      1  3847				   LEVEL_START SET	*
      2  3847		       00 07	   BANK_LEVEL__102_Mirabel =	_CURRENT_BANK
      3  3847				   LEVEL__102_Mirabel SUBROUTINE
      4  3847				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3847
     50  3847		       31 31 23 7c*	      .byte.b	"11#|6#3-2#|2#2-2#$2-2#|2#2-#-2$-2#|#7-3#|#.-#$-#-3#|#.#.-#2-$-#|#3.#-2$#@#|#-2.4-$-#|#2-8#|11#",0
      0  38a6					      END_LEVEL	_102_Mirabel
      1  38a6		       00		      .byte.b	0
      2  38a6		       00 60	   LEVEL_SIZE__102_Mirabel =	* - LEVEL_START
      3  38a7				  -	      IF	LEVEL_SIZE__102_Mirabel > MAX_LEVEL_SIZE
      4  38a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Mirabel
      5  38a7					      ENDIF
     52  38a7
      0  38a7					      START_LEVEL	_102_Oralia
      1  38a7				   LEVEL_START SET	*
      2  38a7		       00 07	   BANK_LEVEL__102_Oralia =	_CURRENT_BANK
      3  38a7				   LEVEL__102_Oralia SUBROUTINE
      4  38a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  38a7
     54  38a7		       39 23 7c 23*	      .byte.b	"9#|#2.$.#2-#|#4.2*-#|#-$.2#2-#|2#-$2-$-#|4#$-$-#|#-$3-$-#|#5-#@#|9#",0
      0  38eb					      END_LEVEL	_102_Oralia
      1  38eb		       00		      .byte.b	0
      2  38eb		       00 45	   LEVEL_SIZE__102_Oralia =	* - LEVEL_START
      3  38ec				  -	      IF	LEVEL_SIZE__102_Oralia > MAX_LEVEL_SIZE
      4  38ec				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Oralia
      5  38ec					      ENDIF
     56  38ec
     57  38ec
     58  38ec							;---------------------------------------------------------------------------------------------------
     59  38ec							; IMAGE IS ABOVE DEFINITION
     60  38ec
     61  38ec							;  ###########
     62  38ec							;  #  #      #
     63  38ec							;  # $# $ $$ #
     64  38ec							;  #  ##$#$  #
     65  38ec							;  #  $    #@#
     66  38ec							;  # $## #  ##
     67  38ec							;  ##	# .## #
     68  38ec							;  ##$ #.*. ##
     69  38ec							;  # ..*. *. #
     70  38ec							;  # # .. #  #
     71  38ec							;  ###########
     72  38ec
      0  38ec					      START_LEVEL	_102_Raven
      1  38ec				   LEVEL_START SET	*
      2  38ec		       00 07	   BANK_LEVEL__102_Raven =	_CURRENT_BANK
      3  38ec				   LEVEL__102_Raven SUBROUTINE
      4  38ec				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  38ec
     74  38ec		       31 31 23 7c*	      .byte.b	"11#|#2-#6-#|#-$#-$-2$-#|#2-2#$#$2-#|#2-$4-#@#|#-$2#-#2-2#|2#2-#-.2#-#|2#$-#.*.-2#|#-2.*.-*.-#|#-#-2.-#2-#|11#",0
      0  395a					      END_LEVEL	_102_Raven
      1  395a		       00		      .byte.b	0
      2  395a		       00 6f	   LEVEL_SIZE__102_Raven =	* - LEVEL_START
      3  395b					      IF	LEVEL_SIZE__102_Raven > MAX_LEVEL_SIZE
      4  395b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Raven
      5  395b					      ENDIF
     76  395b
     77  395b							;  ############
     78  395b							;  #@##. #  # #
     79  395b							;  #**..$#    #
     80  395b							;  #. $..#  # #
     81  395b							;  # $#.$#$$$ #
     82  395b							;  #	      ##
     83  395b							;  #  ##  #   #
     84  395b							;  ############
     85  395b
      0  395b					      START_LEVEL	_103_Adin
      1  395b				   LEVEL_START SET	*
      2  395b		       00 07	   BANK_LEVEL__103_Adin =	_CURRENT_BANK
      3  395b				   LEVEL__103_Adin SUBROUTINE
      4  395b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  395b
     87  395b		       31 32 23 7c*	      .byte.b	"12#|#@2#.-#2-#-#|#2*2.$#4-#|#.-$2.#2-#-#|#-$#.$#3$-#|#9-2#|#2-2#2-#3-#|12#",0
      0  39a6					      END_LEVEL	_103_Adin
      1  39a6		       00		      .byte.b	0
      2  39a6		       00 4c	   LEVEL_SIZE__103_Adin =	* - LEVEL_START
      3  39a7				  -	      IF	LEVEL_SIZE__103_Adin > MAX_LEVEL_SIZE
      4  39a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Adin
      5  39a7					      ENDIF
     89  39a7
     90  39a7							;  #######___
     91  39a7							;  #	  #___
     92  39a7							;  #	$$#___
     93  39a7							;  #.*  .#___
     94  39a7							;  #$*$#*###_
     95  39a7							;  #@*... .#_
     96  39a7							;  #####$ .##
     97  39a7							;  ___# $ $ #
     98  39a7							;  ___#     #
     99  39a7							;  ___#######	(_ = modified by boo from wall)
    100  39a7
      0  39a7					      START_LEVEL	_103_Ajalae
      1  39a7				   LEVEL_START SET	*
      2  39a7		       00 07	   BANK_LEVEL__103_Ajalae =	_CURRENT_BANK
      3  39a7				   LEVEL__103_Ajalae SUBROUTINE
      4  39a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  39a7
    102  39a7		       37 23 7c 23*	      .byte.b	"7#|#5-#|#3-2$#|#.*2-.#|#$*$#*3#|#@*3.-.#|5#$-.2#|3-#-$-$-#|3-#5-#|3-7#",0
      0  39ee					      END_LEVEL	_103_Ajalae
      1  39ee		       00		      .byte.b	0
      2  39ee		       00 48	   LEVEL_SIZE__103_Ajalae =	* - LEVEL_START
      3  39ef				  -	      IF	LEVEL_SIZE__103_Ajalae > MAX_LEVEL_SIZE
      4  39ef				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Ajalae
      5  39ef					      ENDIF
    104  39ef
    105  39ef							;  ############
    106  39ef							;  #@#  #     #
    107  39ef							;  #  # #$#$# #
    108  39ef							;  # *$       #
    109  39ef							;  #..##$#$   #
    110  39ef							;  #..#. #  $ #
    111  39ef							;  #....# $$$##
    112  39ef							;  #	       #
    113  39ef							;  ############
    114  39ef
      0  39ef					      START_LEVEL	_103_Arielle
      1  39ef				   LEVEL_START SET	*
      2  39ef		       00 07	   BANK_LEVEL__103_Arielle =	_CURRENT_BANK
      3  39ef				   LEVEL__103_Arielle SUBROUTINE
      4  39ef				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  39ef
    116  39ef		       31 32 23 7c*	      .byte.b	"12#|#@#2-#5-#|#2-#-#$#$#-#|#-*$7-#|#2.2#$#$3-#|#2.#.-#2-$-#|#4.#-3$2#|#10-#|12#",0
      0  3a3f					      END_LEVEL	_103_Arielle
      1  3a3f		       00		      .byte.b	0
      2  3a3f		       00 51	   LEVEL_SIZE__103_Arielle =	* - LEVEL_START
      3  3a40				  -	      IF	LEVEL_SIZE__103_Arielle > MAX_LEVEL_SIZE
      4  3a40				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Arielle
      5  3a40					      ENDIF
    118  3a40
    119  3a40
    120  3a40
      0  3a40					      START_LEVEL	_1XJH_Tara_Gelson
      1  3a40				   LEVEL_START SET	*
      2  3a40		       00 07	   BANK_LEVEL__1XJH_Tara_Gelson =	_CURRENT_BANK
      3  3a40				   LEVEL__1XJH_Tara_Gelson SUBROUTINE
      4  3a40				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a40
    122  3a40		       38 23 7c 23*	      .byte.b	"8#|#2-#2-*#|#2-*-*-#|#-*$-$-#|#2-.#.-#|#3-#-*#|2#-@3-#|8#",0
      0  3a7a					      END_LEVEL	_1XJH_Tara_Gelson
      1  3a7a		       00		      .byte.b	0
      2  3a7a		       00 3b	   LEVEL_SIZE__1XJH_Tara_Gelson =	* - LEVEL_START
      3  3a7b				  -	      IF	LEVEL_SIZE__1XJH_Tara_Gelson > MAX_LEVEL_SIZE
      4  3a7b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1XJH_Tara_Gelson
      5  3a7b					      ENDIF
    124  3a7b
      0  3a7b					      START_LEVEL	_1R7X_Alison
      1  3a7b				   LEVEL_START SET	*
      2  3a7b		       00 07	   BANK_LEVEL__1R7X_Alison =	_CURRENT_BANK
      3  3a7b				   LEVEL__1R7X_Alison SUBROUTINE
      4  3a7b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a7b
    126  3a7b		       37 23 7c 23*	      .byte.b	"7#|#2-.2-#|#-$*2$#|#-2.$.#|#@*-$-#|2#.3-#|7#",0
      0  3aa8					      END_LEVEL	_1R7X_Alison
      1  3aa8		       00		      .byte.b	0
      2  3aa8		       00 2e	   LEVEL_SIZE__1R7X_Alison =	* - LEVEL_START
      3  3aa9				  -	      IF	LEVEL_SIZE__1R7X_Alison > MAX_LEVEL_SIZE
      4  3aa9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1R7X_Alison
      5  3aa9					      ENDIF
    128  3aa9
      0  3aa9					      START_LEVEL	_1KWD_Cecile_Clayworth
      1  3aa9				   LEVEL_START SET	*
      2  3aa9		       00 07	   BANK_LEVEL__1KWD_Cecile_Clayworth =	_CURRENT_BANK
      3  3aa9				   LEVEL__1KWD_Cecile_Clayworth SUBROUTINE
      4  3aa9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3aa9
    130  3aa9		       38 23 7c 33*	      .byte.b	"8#|3#.2-.#|#-$4-#|#-*2#2$#|#3-$-+#|#-*.-*-#|#6-#|8#",0
      0  3add					      END_LEVEL	_1KWD_Cecile_Clayworth
      1  3add		       00		      .byte.b	0
      2  3add		       00 35	   LEVEL_SIZE__1KWD_Cecile_Clayworth =	* - LEVEL_START
      3  3ade				  -	      IF	LEVEL_SIZE__1KWD_Cecile_Clayworth > MAX_LEVEL_SIZE
      4  3ade				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1KWD_Cecile_Clayworth
      5  3ade					      ENDIF
    132  3ade
      0  3ade					      START_LEVEL	_1EKT_Samantha_Gelson
      1  3ade				   LEVEL_START SET	*
      2  3ade		       00 07	   BANK_LEVEL__1EKT_Samantha_Gelson =	_CURRENT_BANK
      3  3ade				   LEVEL__1EKT_Samantha_Gelson SUBROUTINE
      4  3ade				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ade
    134  3ade		       38 23 7c 23*	      .byte.b	"8#|#-*3-.#|#2-$-*-#|#-.$-$-#|#*-*2-*#|#.#-#2-#|#4-@-#|8#",0
      0  3b17					      END_LEVEL	_1EKT_Samantha_Gelson
      1  3b17		       00		      .byte.b	0
      2  3b17		       00 3a	   LEVEL_SIZE__1EKT_Samantha_Gelson =	* - LEVEL_START
      3  3b18				  -	      IF	LEVEL_SIZE__1EKT_Samantha_Gelson > MAX_LEVEL_SIZE
      4  3b18				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1EKT_Samantha_Gelson
      5  3b18					      ENDIF
    136  3b18
      0  3b18					      START_LEVEL	_0VM5_Andrea_Wadd
      1  3b18				   LEVEL_START SET	*
      2  3b18		       00 07	   BANK_LEVEL__0VM5_Andrea_Wadd =	_CURRENT_BANK
      3  3b18				   LEVEL__0VM5_Andrea_Wadd SUBROUTINE
      4  3b18				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b18
    138  3b18		       37 23 7c 23*	      .byte.b	"7#|#3-#-#|#-$*2-#|#-.-+-#|#-*2$-#|2#2-.-#|7#",0
      0  3b45					      END_LEVEL	_0VM5_Andrea_Wadd
      1  3b45		       00		      .byte.b	0
      2  3b45		       00 2e	   LEVEL_SIZE__0VM5_Andrea_Wadd =	* - LEVEL_START
      3  3b46				  -	      IF	LEVEL_SIZE__0VM5_Andrea_Wadd > MAX_LEVEL_SIZE
      4  3b46				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0VM5_Andrea_Wadd
      5  3b46					      ENDIF
    140  3b46
      0  3b46					      START_LEVEL	_0PAL_Jill_Leatherby
      1  3b46				   LEVEL_START SET	*
      2  3b46		       00 07	   BANK_LEVEL__0PAL_Jill_Leatherby =	_CURRENT_BANK
      3  3b46				   LEVEL__0PAL_Jill_Leatherby SUBROUTINE
      4  3b46				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b46
    142  3b46		       37 23 7c 23*	      .byte.b	"7#|#3-3#|#2-2*-#|#3-$-#|#2-$2.#|3#@2-#|7#",0
      0  3b70					      END_LEVEL	_0PAL_Jill_Leatherby
      1  3b70		       00		      .byte.b	0
      2  3b70		       00 2b	   LEVEL_SIZE__0PAL_Jill_Leatherby =	* - LEVEL_START
      3  3b71				  -	      IF	LEVEL_SIZE__0PAL_Jill_Leatherby > MAX_LEVEL_SIZE
      4  3b71				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0PAL_Jill_Leatherby
      5  3b71					      ENDIF
    144  3b71
      0  3b71					      START_LEVEL	_0IZ1_Sophia
      1  3b71				   LEVEL_START SET	*
      2  3b71		       00 07	   BANK_LEVEL__0IZ1_Sophia =	_CURRENT_BANK
      3  3b71				   LEVEL__0IZ1_Sophia SUBROUTINE
      4  3b71				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b71
    146  3b71		       37 23 7c 23*	      .byte.b	"7#|#5-#|#@$.#-#|#*$2-.#|#-2$2-#|#-.-.-#|7#",0
      0  3b9c					      END_LEVEL	_0IZ1_Sophia
      1  3b9c		       00		      .byte.b	0
      2  3b9c		       00 2c	   LEVEL_SIZE__0IZ1_Sophia =	* - LEVEL_START
      3  3b9d				  -	      IF	LEVEL_SIZE__0IZ1_Sophia > MAX_LEVEL_SIZE
      4  3b9d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0IZ1_Sophia
      5  3b9d					      ENDIF
    148  3b9d
      0  3b9d					      START_LEVEL	_0CNH_Alice
      1  3b9d				   LEVEL_START SET	*
      2  3b9d		       00 07	   BANK_LEVEL__0CNH_Alice =	_CURRENT_BANK
      3  3b9d				   LEVEL__0CNH_Alice SUBROUTINE
      4  3b9d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b9d
    150  3b9d		       37 23 7c 23*	      .byte.b	"7#|#.4-#|#$*-#-#|#.2-$*#|#-.$2-#|#@-*2-#|7#",0
      0  3bc9					      END_LEVEL	_0CNH_Alice
      1  3bc9		       00		      .byte.b	0
      2  3bc9		       00 2d	   LEVEL_SIZE__0CNH_Alice =	* - LEVEL_START
      3  3bca				  -	      IF	LEVEL_SIZE__0CNH_Alice > MAX_LEVEL_SIZE
      4  3bca				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0CNH_Alice
      5  3bca					      ENDIF
    152  3bca
    153  3bca							;  START_LEVEL TowC
    154  3bca							;   .byte "4-5#|4-#3-#|4-#$2-#|2-3#2-$2#|2-#2-$-$-#|3#-#-2#-#3-6#|#3-#-2#-5#2-2.#|#-$2-$10-2.#|5#-3#-#@2#2-2.#|4-#5-9#|4-7#",0
    155  3bca							;  END_LEVEL TowC
    156  3bca
    157  3bca							;  START_LEVEL SimpleC
    158  3bca							;  .byte "7#|#.@-#-#|#$*-$-#|#3-$-#|#-..--#|#--*--#|7#",0
    159  3bca							;  END_LEVEL SimpleC
    160  3bca
      0  3bca					      START_LEVEL	bAlfa_DrFogh
      1  3bca				   LEVEL_START SET	*
      2  3bca		       00 07	   BANK_LEVEL_bAlfa_DrFogh =	_CURRENT_BANK
      3  3bca				   LEVEL_bAlfa_DrFogh SUBROUTINE
      4  3bca				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3bca
    162  3bca		       32 2d 34 23*	      .byte.b	"2-4#2-4#|-2#2-2#-#2-#|-#4-3#2-2#|2#2-2*2-#.2-2#|#2-*2-*-#*#2-#|#-*4-2*2-#-#|#-*-2#-*3-#-#|2#-*2-*#*#-#-#|-#$-2*-#-*-#-#|-#@#2-2#5-#|-2#2-4#2-3#|2-#2-#2-4#|2-#2-#|2-4#",0
      0  3c71					      END_LEVEL	bAlfa_DrFogh
      1  3c71		       00		      .byte.b	0
      2  3c71		       00 a8	   LEVEL_SIZE_bAlfa_DrFogh =	* - LEVEL_START
      3  3c72					      IF	LEVEL_SIZE_bAlfa_DrFogh > MAX_LEVEL_SIZE
      4  3c72				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAlfa_DrFogh
      5  3c72					      ENDIF
    164  3c72
      0  3c72					      START_LEVEL	b51X_Sharpen
      1  3c72				   LEVEL_START SET	*
      2  3c72		       00 07	   BANK_LEVEL_b51X_Sharpen =	_CURRENT_BANK
      3  3c72				   LEVEL_b51X_Sharpen SUBROUTINE
      4  3c72				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c72
    166  3c72		       2d 39 23 33*	      .byte.b	"-9#3-|-#7-#3-|-#-$-2$-$#3-|3#$#2-$-#3-|#.#3-2$-2#2-|#.3#3-$-#2-|#.#.-$-2#-3#|#3.$-$2#-$-#|#3.$3-$2-@#|#2.3#$3#-2#|#4.#5-#-|12#-",0
      0  3cf2					      END_LEVEL	b51X_Sharpen
      1  3cf2		       00		      .byte.b	0
      2  3cf2		       00 81	   LEVEL_SIZE_b51X_Sharpen =	* - LEVEL_START
      3  3cf3				  -	      IF	LEVEL_SIZE_b51X_Sharpen > MAX_LEVEL_SIZE
      4  3cf3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_b51X_Sharpen
      5  3cf3					      ENDIF
    168  3cf3
      0  3cf3					      START_LEVEL	bDarcy_Burnsell101
      1  3cf3				   LEVEL_START SET	*
      2  3cf3		       00 07	   BANK_LEVEL_bDarcy_Burnsell101 =	_CURRENT_BANK
      3  3cf3				   LEVEL_bDarcy_Burnsell101 SUBROUTINE
      4  3cf3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3cf3
    170  3cf3		       38 23 7c 23*	      .byte.b	"8#|#2-.-$@#|#.#$*2$#|#2-.-*-#|#2$-2$.#|#.#-#2-#|#.2-.-.#|8#",0
      0  3d2f					      END_LEVEL	bDarcy_Burnsell101
      1  3d2f		       00		      .byte.b	0
      2  3d2f		       00 3d	   LEVEL_SIZE_bDarcy_Burnsell101 =	* - LEVEL_START
      3  3d30				  -	      IF	LEVEL_SIZE_bDarcy_Burnsell101 > MAX_LEVEL_SIZE
      4  3d30				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bDarcy_Burnsell101
      5  3d30					      ENDIF
    172  3d30
      0  3d30					      START_LEVEL	bAislin101
      1  3d30				   LEVEL_START SET	*
      2  3d30		       00 07	   BANK_LEVEL_bAislin101 =	_CURRENT_BANK
      3  3d30				   LEVEL_bAislin101 SUBROUTINE
      4  3d30				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d30
    174  3d30		       38 23 7c 32*	      .byte.b	"8#|2#-*-*.#|#2.$-$*#|#-.#-*.#|2#-$-$2#|#-#$-$-#|#2.2-$@#|8#",0
      0  3d6c					      END_LEVEL	bAislin101
      1  3d6c		       00		      .byte.b	0
      2  3d6c		       00 3d	   LEVEL_SIZE_bAislin101 =	* - LEVEL_START
      3  3d6d				  -	      IF	LEVEL_SIZE_bAislin101 > MAX_LEVEL_SIZE
      4  3d6d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAislin101
      5  3d6d					      ENDIF
    176  3d6d
    177  3d6d							;  START_LEVEL b82X_Sharpen
    178  3d6d							;  .byte "-11#8-|-#5-#3-2#7-|-#-$-$-$-#2-5#3-|-3#2-5#5-#3-|-#4.#5-3#-#3-|-#.4#2-4#3-#3-|-#4.4-#2-$-2#3-|-#-3.#3-#-3$5#|3#.7#2-$@$3-#|#-$3-5#-$-2#3-#|#-#.#-$6-$3#$-#|#-#.8#2-#2-$-#|#-#3.7-2#-2$-#|#3-7#-$-#-#2-#|5#5-#7-2#|10-9#-",0
    179  3d6d							;  END_LEVEL b82X_Sharpen
    180  3d6d
      0  3d6d					      START_LEVEL	Thomas_Reinke16
      1  3d6d				   LEVEL_START SET	*
      2  3d6d		       00 07	   BANK_LEVEL_Thomas_Reinke16 =	_CURRENT_BANK
      3  3d6d				   LEVEL_Thomas_Reinke16 SUBROUTINE
      4  3d6d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d6d
    182  3d6d		       2d 35 23 7c*	      .byte.b	"-5#|2#3-3#|#6-2#|#-#-2#2-#|#2.*2-#-#|#2-*2-#-#|3#*2$2-#|2-#@-4#|2-4#",0
      0  3db2					      END_LEVEL	Thomas_Reinke16
      1  3db2		       00		      .byte.b	0
      2  3db2		       00 46	   LEVEL_SIZE_Thomas_Reinke16 =	* - LEVEL_START
      3  3db3				  -	      IF	LEVEL_SIZE_Thomas_Reinke16 > MAX_LEVEL_SIZE
      4  3db3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_Thomas_Reinke16
      5  3db3					      ENDIF
    184  3db3
    185  3db3							;Level element	Character	ASCII Code
    186  3db3							;Wall	#	0x23
    187  3db3							;Player	@	0x40
    188  3db3							;Player on goal square	+	0x2b
    189  3db3							;Box	$	0x24
    190  3db3							;Box on goal square	*	0x2a
    191  3db3							;Goal square	.	0x2e
    192  3db3							;Floor	(Space)	0x20 or underscore
    193  3db3
    194  3db3							;This level ("Claire", by Lee J Haywood):
    195  3db3
    196  3db3							;#######
    197  3db3							;#.@ # #
    198  3db3							;#$* $ #
    199  3db3							;#   $ #
    200  3db3							;# ..	#
    201  3db3							;#  *	#
    202  3db3							;#######
    203  3db3							;runlength encoded looks like this:
    204  3db3
    205  3db3							;The rows of the level are separated by "|"s. There has been a discussion in the Yahoo Group about what character should represent an empty square in May 2006. Finally the hyphen has been elected to be the standard character for an empty square. Nevertheless, programs are encouraged to support both, hyphens and underscores.
    206  3db3
    207  3db3							;If only two level elements are grouped together they may be run length encoded, but needn't to. Example:
    208  3db3
    209  3db3
      0  3db3					      CHECK_BANK_SIZE	"LEVELS4 -- full 2K"
      1  3db3		       05 b3	   .TEMP      =	* - BANK_START
 LEVELS4 -- full 2K (2K) SIZE =  $5b3 , FREE= $24d
      2  3db3					      ECHO	"LEVELS4 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3db3				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3db3				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3db3				  -	      ERR
      6  3db3					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 3
      0  3db3					      include	"BANK_INITBANK.asm"	; MUST be after banks that include levels -- otherwise MAX_LEVELBANK is not calculated properly
      1  3db3							;    Sokoboo - a Sokoban implementation
      2  3db3							;    using a generic tile-based display engine for the Atari 2600
      3  3db3							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  3db3							;
      5  3db3							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  3db3							;
      7  3db3							;    Code related to the generic tile-based display engine was developed by
      8  3db3							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  3db3							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  3db3							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  3db3							;
     12  3db3							;    Code related to music and sound effects uses the TIATracker music player
     13  3db3							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  3db3							;    directory for Apache licensing details.
     15  3db3							;
     16  3db3							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  3db3							;    See the copyright notices in the License directory for a list of level
     18  3db3							;    contributors.
     19  3db3							;
     20  3db3							;    Except where otherwise indicated, this software is released under the
     21  3db3							;    following licensing arrangement...
     22  3db3							;
     23  3db3							;    This program is free software: you can redistribute it and/or modify
     24  3db3							;    it under the terms of the GNU General Public License as published by
     25  3db3							;    the Free Software Foundation, either version 3 of the License, or
     26  3db3							;    (at your option) any later version.
     27  3db3							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  3db3
     29  3db3							;    This program is distributed in the hope that it will be useful,
     30  3db3							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  3db3							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  3db3							;    GNU General Public License for more details.
     33  3db3
      0  3db3					      NEWBANK	INITBANK
      1  433e ????				      SEG	INITBANK
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   INITBANK   SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	INITBANK
     35  4000
     36  4000		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
     37  4001
      0  4001					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  4001		       00 08	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  4001					      SUBROUTINE
      3  4001				   BoardLineStartLO
     39  4001
     40  4001							; Gives the start address (LO) of each board line
     41  4001
     42  4001				   .BOARD_LOCATION SET	Board
     43  4001					      REPEAT	SIZE_BOARD_Y
     44  4001				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4001				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4001					      ENDIF
     47  4001		       00		      .byte.b	<.BOARD_LOCATION
     48  4001				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4001					      REPEND
     44  4002				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4002				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4002					      ENDIF
     47  4002		       28		      .byte.b	<.BOARD_LOCATION
     48  4002				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4002					      REPEND
     44  4003				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4003				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4003					      ENDIF
     47  4003		       50		      .byte.b	<.BOARD_LOCATION
     48  4003				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4003					      REPEND
     44  4004				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4004				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4004					      ENDIF
     47  4004		       78		      .byte.b	<.BOARD_LOCATION
     48  4004				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4004					      REPEND
     44  4005				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4005				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4005					      ENDIF
     47  4005		       a0		      .byte.b	<.BOARD_LOCATION
     48  4005				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4005					      REPEND
     44  4006				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4006				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4006					      ENDIF
     47  4006		       c8		      .byte.b	<.BOARD_LOCATION
     48  4006				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4006					      REPEND
     44  4007					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4007				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4007					      ENDIF
     47  4007		       00		      .byte.b	<.BOARD_LOCATION
     48  4007				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4007					      REPEND
     44  4008				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4008				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4008					      ENDIF
     47  4008		       28		      .byte.b	<.BOARD_LOCATION
     48  4008				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4008					      REPEND
     44  4009				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4009				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4009					      ENDIF
     47  4009		       50		      .byte.b	<.BOARD_LOCATION
     48  4009				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4009					      REPEND
     44  400a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  400a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  400a					      ENDIF
     47  400a		       78		      .byte.b	<.BOARD_LOCATION
     48  400a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  400a					      REPEND
     44  400b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  400b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  400b					      ENDIF
     47  400b		       a0		      .byte.b	<.BOARD_LOCATION
     48  400b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  400b					      REPEND
     44  400c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  400c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  400c					      ENDIF
     47  400c		       c8		      .byte.b	<.BOARD_LOCATION
     48  400c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  400c					      REPEND
     44  400d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  400d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  400d					      ENDIF
     47  400d		       00		      .byte.b	<.BOARD_LOCATION
     48  400d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  400d					      REPEND
     44  400e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  400e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  400e					      ENDIF
     47  400e		       28		      .byte.b	<.BOARD_LOCATION
     48  400e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  400e					      REPEND
     44  400f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  400f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  400f					      ENDIF
     47  400f		       50		      .byte.b	<.BOARD_LOCATION
     48  400f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  400f					      REPEND
     44  4010				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4010				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4010					      ENDIF
     47  4010		       78		      .byte.b	<.BOARD_LOCATION
     48  4010				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4010					      REPEND
     44  4011				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4011				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4011					      ENDIF
     47  4011		       a0		      .byte.b	<.BOARD_LOCATION
     48  4011				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4011					      REPEND
     44  4012				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4012				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4012					      ENDIF
     47  4012		       c8		      .byte.b	<.BOARD_LOCATION
     48  4012				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4012					      REPEND
     44  4013					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4013				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4013					      ENDIF
     47  4013		       00		      .byte.b	<.BOARD_LOCATION
     48  4013				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4013					      REPEND
     44  4014				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4014				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4014					      ENDIF
     47  4014		       28		      .byte.b	<.BOARD_LOCATION
     48  4014				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4014					      REPEND
     44  4015				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4015				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4015					      ENDIF
     47  4015		       50		      .byte.b	<.BOARD_LOCATION
     48  4015				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4015					      REPEND
     44  4016				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4016				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4016					      ENDIF
     47  4016		       78		      .byte.b	<.BOARD_LOCATION
     48  4016				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     49  4017					      REPEND
      0  4017					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  4017					      LIST	ON
     51  4017
     52  4017		       03 a0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     53  4017
     54  4017							;------------------------------------------------------------------------------
     55  4017
     56  4017				   BoardLineStartHiR
     57  4017
     58  4017							; Gives the start address (HI) of each board line
     59  4017							; Note this caters for the memory wrapping when we go from bank to bank, as
     60  4017							; the board overlays multiple banks!
     61  4017
     62  4017				   .BOARD_LOCATION SET	Board
     63  4017					      REPEAT	SIZE_BOARD_Y
     64  4017				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4017				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4017					      ENDIF
     67  4017		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4017				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4017					      REPEND
     64  4018				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4018				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4018					      ENDIF
     67  4018		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4018				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4018					      REPEND
     64  4019				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4019				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4019					      ENDIF
     67  4019		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4019				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4019					      REPEND
     64  401a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  401a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  401a					      ENDIF
     67  401a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  401a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  401a					      REPEND
     64  401b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  401b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  401b					      ENDIF
     67  401b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  401b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  401b					      REPEND
     64  401c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  401c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  401c					      ENDIF
     67  401c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  401c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  401c					      REPEND
     64  401d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  401d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  401d					      ENDIF
     67  401d		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  401d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  401d					      REPEND
     64  401e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  401e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  401e					      ENDIF
     67  401e		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  401e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  401e					      REPEND
     64  401f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  401f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  401f					      ENDIF
     67  401f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  401f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  401f					      REPEND
     64  4020				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4020				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4020					      ENDIF
     67  4020		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4020				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4020					      REPEND
     64  4021				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4021				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4021					      ENDIF
     67  4021		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4021				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4021					      REPEND
     64  4022				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4022				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4022					      ENDIF
     67  4022		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4022				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4022					      REPEND
     64  4023					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4023				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4023					      ENDIF
     67  4023		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4023				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4023					      REPEND
     64  4024				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4024				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4024					      ENDIF
     67  4024		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4024				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4024					      REPEND
     64  4025				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4025				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4025					      ENDIF
     67  4025		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4025				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4025					      REPEND
     64  4026				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4026				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4026					      ENDIF
     67  4026		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4026				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4026					      REPEND
     64  4027				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4027				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4027					      ENDIF
     67  4027		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4027				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4027					      REPEND
     64  4028				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4028				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4028					      ENDIF
     67  4028		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4028				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4028					      REPEND
     64  4029					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  4029				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  4029					      ENDIF
     67  4029		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  4029				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  4029					      REPEND
     64  402a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  402a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  402a					      ENDIF
     67  402a		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  402a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  402a					      REPEND
     64  402b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  402b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  402b					      ENDIF
     67  402b		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  402b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     63  402b					      REPEND
     64  402c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     65  402c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     66  402c					      ENDIF
     67  402c		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     68  402c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     69  402d					      REPEND
      0  402d					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  402d					      LIST	ON
     71  402d							;------------------------------------------------------------------------------
     72  402d
     73  402d				   BoardLineStartHiW
     74  402d
     75  402d							; Gives the start address (HI) of each board line
     76  402d							; Note this caters for the memory wrapping when we go from bank to bank, as
     77  402d							; the board overlays multiple banks!
     78  402d
     79  402d				   .BOARD_LOCATION SET	Board
     80  402d					      REPEAT	SIZE_BOARD_Y
     81  402d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  402d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  402d					      ENDIF
     84  402d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  402d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  402d					      REPEND
     81  402e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  402e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  402e					      ENDIF
     84  402e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  402e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  402e					      REPEND
     81  402f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  402f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  402f					      ENDIF
     84  402f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  402f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  402f					      REPEND
     81  4030				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4030				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4030					      ENDIF
     84  4030		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4030				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4030					      REPEND
     81  4031				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4031				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4031					      ENDIF
     84  4031		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4031				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4031					      REPEND
     81  4032				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4032				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4032					      ENDIF
     84  4032		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4032				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4032					      REPEND
     81  4033					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4033				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4033					      ENDIF
     84  4033		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4033				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4033					      REPEND
     81  4034				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4034				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4034					      ENDIF
     84  4034		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4034				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4034					      REPEND
     81  4035				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4035				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4035					      ENDIF
     84  4035		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4035				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4035					      REPEND
     81  4036				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4036				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4036					      ENDIF
     84  4036		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4036				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4036					      REPEND
     81  4037				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4037				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4037					      ENDIF
     84  4037		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4037				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4037					      REPEND
     81  4038				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4038				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4038					      ENDIF
     84  4038		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4038				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4038					      REPEND
     81  4039					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4039				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4039					      ENDIF
     84  4039		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4039				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4039					      REPEND
     81  403a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  403a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  403a					      ENDIF
     84  403a		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  403a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  403a					      REPEND
     81  403b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  403b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  403b					      ENDIF
     84  403b		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  403b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  403b					      REPEND
     81  403c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  403c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  403c					      ENDIF
     84  403c		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  403c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  403c					      REPEND
     81  403d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  403d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  403d					      ENDIF
     84  403d		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  403d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  403d					      REPEND
     81  403e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  403e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  403e					      ENDIF
     84  403e		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  403e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  403e					      REPEND
     81  403f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  403f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  403f					      ENDIF
     84  403f		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  403f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  403f					      REPEND
     81  4040				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4040				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4040					      ENDIF
     84  4040		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4040				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4040					      REPEND
     81  4041				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4041				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4041					      ENDIF
     84  4041		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4041				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     80  4041					      REPEND
     81  4042				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     82  4042				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     83  4042					      ENDIF
     84  4042		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     85  4042				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     86  4043					      REPEND
      0  4043					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  4043					      LIST	ON
     88  4043
     89  4043							;------------------------------------------------------------------------------
     90  4043				  -	      IF	MULTI_BANK_BOARD = YES
     91  4043				  -BoardBank
     92  4043					      ENDIF
     93  4043							; Gives the RAM bank of the start of the board row for a given row.
     94  4043
     95  4043				   .BOARD_LOCATION SET	Board - RAM_3E
     96  4043					      REPEAT	SIZE_BOARD_Y
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     96  4043					      REPEND
     97  4043				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     98  4043				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     99  4043					      ENDIF
    100  4043				  -	      IF	MULTI_BANK_BOARD = YES
    101  4043				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    102  4043					      ENDIF
    103  4043				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
    104  4043					      REPEND
    105  4043				  -	      IF	MULTI_BANK_BOARD = YES
    106  4043				  -	      CHECKPAGEX	BoardBank, "BoardBank in BANK_INITBANK.asm"
    107  4043					      ENDIF
    108  4043
    109  4043
    110  4043							;------------------------------------------------------------------------------
    111  4043
    112  4043				   CopyROMShadowToRAM_F000
    113  4043		       a9 f0		      lda	#>$F000
    114  4045
      0  4045					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  4045		       00 08	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  4045					      SUBROUTINE
      3  4045				   CopyROMShadowToRAM
    116  4045
    117  4045							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
    118  4045							; the variable definitions are in the ROM shadow because this allows auto-initialisation
    119  4045							; of the variable contents from ROM declarations, but still allows access to them as
    120  4045							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
    121  4045							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
    122  4045							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
    123  4045							; code co-lives in all banks and may run even as bankswitching occurs between those
    124  4045							; banks -- by the very code itself.
    125  4045
    126  4045							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
    127  4045		       85 c1		      sta	Board_AddressR+1
    128  4047		       86 db		      stx	O_ROM_Source_Bank	; source bank
    129  4049		       84 c5		      sty	RAM_Bank	; destination bank
    130  404b
    131  404b		       a0 00		      ldy	#0
    132  404d		       84 c0		      sty	Board_AddressR
    133  404f		       84 c2		      sty	Board_AddressW
    134  4051		       a9 14		      lda	#>($1000+RAM_WRITE)
    135  4053		       85 c3		      sta	Board_AddressW+1
    136  4055
    137  4055							; Iterate 4 pages (1K) for complete bank copy
    138  4055
    139  4055		       a9 04		      lda	#4
    140  4057		       85 da		      sta	O_CopyCount
    141  4059
    142  4059		       84 dc	   CopyPage   sty	O_Index
    143  405b		       a5 db		      lda	O_ROM_Source_Bank
    144  405d		       20 12 f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    145  4060							;tax
    146  4060		       a4 dc		      ldy	O_Index
    147  4062		       a6 c5		      ldx	RAM_Bank
    148  4064		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    149  4067
    150  4067		       a4 dc		      ldy	O_Index
    151  4069		       c8		      iny
    152  406a		       d0 ed		      bne	CopyPage
    153  406c
    154  406c		       e6 c1		      inc	Board_AddressR+1
    155  406e		       e6 c3		      inc	Board_AddressW+1
    156  4070
    157  4070		       c6 da		      dec	O_CopyCount
    158  4072		       d0 e5		      bne	CopyPage
    159  4074
    160  4074		       a4 c5		      ldy	RAM_Bank	; TODO: remove!?
    161  4076		       60		      rts
    162  4077
    163  4077
    164  4077							;------------------------------------------------------------------------------
      0  4077					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  4077		       00 08	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  4077					      SUBROUTINE
      3  4077				   SetPlatformColours
    166  4077
    167  4077							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    168  4077							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    169  4077							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    170  4077							; addressing will not violate the page-crossing restriction of 3E.
    171  4077
    172  4077							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    173  4077
    174  4077		       a9 00		      lda	#<DrawTheScreen	; = 0
    175  4079		       85 c2		      sta	Board_AddressW
    176  407b		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    177  407d		       85 c3		      sta	Board_AddressW+1
    178  407f
    179  407f							; first, set the x index (with last one being a RTS ($60))
    180  407f
    181  407f		       a6 c5		      ldx	RAM_Bank
    182  4081		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    183  4083		       d0 07		      bne	.skipPatch
    184  4085		       a9 60		      lda	#$60	; rts
    185  4087		       a0 41		      ldy	#<SELFMOD_X
    186  4089		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    187  408c				   .skipPatch
    188  408c
    189  408c		       a2 02		      ldx	#3-1
    190  408e				   .loopColor
    191  408e		       86 da		      stx	colorIdx
    192  4090							; set PF colors
    193  4090		       b5 bd		      lda	color,x
    194  4092		       bc b7 f0 	      ldy	SelfModColOfsTbl,x
    195  4095							;tax
    196  4095		       a6 c5		      ldx	RAM_Bank
    197  4097		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy PF colour RED/GREEN/BLUE to self-modifying RAM
    198  409a							; set player colors
    199  409a		       a6 da		      ldx	colorIdx
    200  409c		       bd ba f0 	      lda	SelfModePlayerTbl,x
    201  409f		       a4 81		      ldy	Platform
    202  40a1		       c0 02		      cpy	#PAL
    203  40a3		       90 02		      bcc	.platform0
    204  40a5		       69 14		      adc	#LINES_PER_CHAR-1	; C==1!
    205  40a7				   .platform0
    206  40a7		       bc bd f0 	      ldy	SelfModPlayerColOfsTbl,x
    207  40aa							;tax
    208  40aa		       a6 c5		      ldx	RAM_Bank
    209  40ac		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy player colour RED/GREEN/BLUE to self-modifying RAM
    210  40af							; loop
    211  40af		       a6 da		      ldx	colorIdx
    212  40b1		       ca		      dex
    213  40b2		       10 da		      bpl	.loopColor
    214  40b4
    215  40b4		       a4 c5		      ldy	RAM_Bank
    216  40b6		       60		      rts
    217  40b7
    218  40b7				   SelfModColOfsTbl
    219  40b7		       53 86 1c 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    220  40ba				   SelfModePlayerTbl
    221  40ba		       bd b6 af 	      .byte.b	<SpriteColourBLUE, <SpriteColourGREEN, <SpriteColourRED
    222  40bd				   SelfModPlayerColOfsTbl
    223  40bd		       4c 7f 15 	      .byte.b	<(SELFMOD_PLAYERCOL_BLUE+1), <(SELFMOD_PLAYERCOL_GREEN+1), <(SELFMOD_PLAYERCOL_RED+1)
    224  40c0
    225  40c0
    226  40c0				   DrawLineStartLO
    227  40c0
    228  40c0							; Gives the start address of each line in the draw flags buffer
    229  40c0
    230  40c0				   .DRAW_LOCATION SET	DrawFlag
    231  40c0					      REPEAT	SCREEN_LINES
    232  40c0		       50		      .byte.b	<.DRAW_LOCATION
    233  40c0				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c0					      REPEND
    232  40c1		       5a		      .byte.b	<.DRAW_LOCATION
    233  40c1				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c1					      REPEND
    232  40c2		       64		      .byte.b	<.DRAW_LOCATION
    233  40c2				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c2					      REPEND
    232  40c3		       6e		      .byte.b	<.DRAW_LOCATION
    233  40c3				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c3					      REPEND
    232  40c4		       78		      .byte.b	<.DRAW_LOCATION
    233  40c4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c4					      REPEND
    232  40c5		       82		      .byte.b	<.DRAW_LOCATION
    233  40c5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c5					      REPEND
    232  40c6		       8c		      .byte.b	<.DRAW_LOCATION
    233  40c6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    231  40c6					      REPEND
    232  40c7		       96		      .byte.b	<.DRAW_LOCATION
    233  40c7				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    234  40c8					      REPEND
    235  40c8
    236  40c8
    237  40c8							;------------------------------------------------------------------------------
    238  40c8
      0  40c8					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  40c8		       00 08	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  40c8					      SUBROUTINE
      3  40c8				   GetBoardAddressRW
    240  40c8							; Must share same bank as BoardLineStart tables
    241  40c8
    242  40c8		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    243  40cb		       85 c0		      sta	Board_AddressR	; 3
    244  40cd		       85 c2		      sta	Board_AddressW	; 3
    245  40cf		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    246  40d2		       85 c1		      sta	Board_AddressR+1	; 3	     READ address
    247  40d4		       09 04		      ora	#>RAM_WRITE	; 2
    248  40d6		       85 c3		      sta	Board_AddressW+1	; 3	     WRITE address
    249  40d8				  -	      IF	MULTI_BANK_BOARD = YES
    250  40d8				  -	      ldx	BoardBank,y	; 4 = 26    switch this on return
    251  40d8					      ELSE
    252  40d8		       a2 0d		      ldx	#BANK_BOARD	; 2
    253  40da					      ENDIF
    254  40da		       60		      rts		; 6 = 32[-2]
    255  40db
    256  40db							;------------------------------------------------------------------------------
    257  40db
      0  40db					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  40db		       00 08	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  40db					      SUBROUTINE
      3  40db				   GetBoardAddressR
    259  40db
    260  40db		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    261  40de		       85 c0		      sta	Board_AddressR	; 3
    262  40e0		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    263  40e3		       85 c1		      sta	Board_AddressR+1	; 3	 READ address
    264  40e5				  -	      IF	MULTI_BANK_BOARD = YES
    265  40e5				  -	      lda	BoardBank,y	; 4	 switch this on return
    266  40e5					      ELSE
    267  40e5		       a9 0d		      lda	#BANK_BOARD	; 2
    268  40e7					      ENDIF
    269  40e7		       60		      rts		; 6[-2]
    270  40e8
    271  40e8							;------------------------------------------------------------------------------
    272  40e8
      0  40e8					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  40e8		       00 08	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  40e8					      SUBROUTINE
      3  40e8				   GetBoardAddressW
    274  40e8
    275  40e8							; Must share same bank as BoardLineStart tables
    276  40e8
    277  40e8		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    278  40eb		       85 c2		      sta	Board_AddressW	;3
    279  40ed		       b9 2d f0 	      lda	BoardLineStartHiW,y	;4
    280  40f0		       85 c3		      sta	Board_AddressW+1	;3 WRITE address
    281  40f2				  -	      IF	MULTI_BANK_BOARD = YES
    282  40f2				  -	      ldx	BoardBank,y	;4 switch this on return
    283  40f2					      ELSE
    284  40f2		       a2 0d		      ldx	#BANK_BOARD	;2
    285  40f4					      ENDIF
    286  40f4		       60	   QRet       rts		;6
    287  40f5
    288  40f5							;-------------------------------------------------------------------------------
    289  40f5
    290  40f5
    291  40f5				   OBJTYPE    SET	0
    292  40f5					      MAC	define_character
    293  40f5				   CHARACTER_{1} =	OBJTYPE
    294  40f5				   OBJTYPE    .SET	OBJTYPE + 1
    295  40f5					      ENDM
    296  40f5
    297  40f5							; Modifications to character #/order must also ensure the following are correct...
    298  40f5							;   CharacterDataVecLO/HI	   in BANK_FIXED.asm
    299  40f5							;   MoveVecLO/HI		   in BANK_INITBANK
    300  40f5							;   CharReplacement		   in BANK_ROM_SHADOW_DRAWBUFFERS
    301  40f5
      0  40f5					      DEFINE_CHARACTER	BLANK
      1  40f5		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	SOIL
      1  40f5		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	BOX
      1  40f5		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	TARGET
      1  40f5		       00 03	   CHARACTER_TARGET =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	TARGET2
      1  40f5		       00 04	   CHARACTER_TARGET2 =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	MANOCCUPIED
      1  40f5		       00 05	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	STEEL
      1  40f5		       00 06	   CHARACTER_STEEL =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	WALL
      1  40f5		       00 07	   CHARACTER_WALL =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	BOX_ON_TARGET
      1  40f5		       00 08	   CHARACTER_BOX_ON_TARGET =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  40f5					      DEFINE_CHARACTER	NOGO
      1  40f5		       00 09	   CHARACTER_NOGO =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
    312  40f5
      0  40f5					      DEFINE_CHARACTER	MAXIMUM
      1  40f5		       00 0a	   CHARACTER_MAXIMUM =	OBJTYPE
      2  40f5				   OBJTYPE    .SET	OBJTYPE + 1
    314  40f5
    315  40f5							;------------------------------------------------------------------------------
    316  40f5
      0  40f5					      DEFINE_SUBROUTINE	PushBox	; in INITBANK
      1  40f5		       00 08	   BANK_PushBox =	_CURRENT_BANK
      2  40f5					      SUBROUTINE
      3  40f5				   PushBox
    318  40f5
    319  40f5							; X = restoration character for square we are moving TO
    320  40f5							; so, if X = CHARACTER_TARGET AND we move, THEN we are pushing a box off a target
    321  40f5
    322  40f5		       85 c4		      sta	ROM_Bank
    323  40f7
    324  40f7		       a5 a5		      lda	ManPushCounter
    325  40f9		       c9 01		      cmp	#PUSH_LIMIT
    326  40fb		       90 6c		      bcc	cannotPush
    327  40fd
    328  40fd		       86 dc		      stx	restorationCharacter	; BOX'S NEW CHAR
    329  40ff
    330  40ff							; Determine if the box is pushable
    331  40ff							; we use the joystick to calculate the subsequent square
    332  40ff
    333  40ff		       a5 90		      lda	BufferedJoystick
    334  4101		       4a		      lsr
    335  4102		       4a		      lsr
    336  4103		       4a		      lsr
    337  4104		       4a		      lsr
    338  4105		       48		      pha
    339  4106		       a8		      tay
    340  4107
    341  4107		       18		      clc
    342  4108		       a5 8d		      lda	POS_Y_NEW
    343  410a		       79 c9 f2 	      adc	JoyMoveY,y
    344  410d		       a8		      tay
    345  410e		       20 c8 f0 	      jsr	GetBoardAddressRW
    346  4111
    347  4111		       68		      pla
    348  4112		       a8		      tay
    349  4113
    350  4113		       18		      clc
    351  4114		       a5 8c		      lda	POS_X_NEW
    352  4116		       79 bd f2 	      adc	JoyMoveX,y
    353  4119		       48		      pha
    354  411a		       a8		      tay
    355  411b
    356  411b				  -	      IF	MULTI_BANK_BOARD = YES
    357  411b				  -	      lda	RAM_Bank
    358  411b					      ELSE
    359  411b		       a9 0d		      lda	#BANK_BOARD	; 2
    360  411d					      ENDIF
    361  411d		       20 17 f8 	      jsr	GetBoardCharacter	;6+20(A)
    362  4120		       68		      pla
    363  4121		       a8		      tay
    364  4122
    365  4122		       a9 02		      lda	#CHARACTER_BOX
    366  4124		       e0 00		      cpx	#CHARACTER_BLANK
    367  4126		       f0 13		      beq	canPushTarget
    368  4128
    369  4128		       e0 03		      cpx	#CHARACTER_TARGET
    370  412a		       f0 04		      beq	decreaseTargets
    371  412c		       e0 04		      cpx	#CHARACTER_TARGET2
    372  412e		       d0 39		      bne	cannotPush
    373  4130
    374  4130							; Box is now on a target - so decrease the remaining targets
    375  4130
    376  4130		       f8	   decreaseTargets sed
    377  4131		       38		      sec
    378  4132		       a5 b9		      lda	targetsRequired
    379  4134		       e9 01		      sbc	#1
    380  4136		       85 b9		      sta	targetsRequired
    381  4138		       d8		      cld
    382  4139
    383  4139		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    384  413b		       48	   canPushTarget pha
    385  413c
    386  413c							; If the box *WAS* on a target (restoration character = CHARACTER_TARGET)
    387  413c							; then we increase targets (as there is one more to get)
    388  413c
    389  413c		       a5 dc		      lda	restorationCharacter
    390  413e		       c9 03		      cmp	#CHARACTER_TARGET
    391  4140		       d0 09		      bne	notOnTargetAlready
    392  4142
    393  4142							; increase the required targets as box is leaving one
    394  4142
    395  4142		       f8		      sed
    396  4143		       18		      clc
    397  4144		       a5 b9		      lda	targetsRequired
    398  4146		       69 01		      adc	#1
    399  4148		       85 b9		      sta	targetsRequired
    400  414a		       d8		      cld
    401  414b
    402  414b				   notOnTargetAlready
    403  414b
    404  414b
    405  414b		       68		      pla
    406  414c
    407  414c
    408  414c				  -	      IF	MULTI_BANK_BOARD = YES
    409  414c				  -	      ldx	RAM_Bank
    410  414c					      ELSE
    411  414c		       a2 0d		      ldx	#BANK_BOARD	; 2
    412  414e					      ENDIF
    413  414e		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)
    414  4151
    415  4151		       a5 8f		      lda	POS_VAR	; player's restoration character
    416  4153		       48		      pha
    417  4154
    418  4154		       a6 8d		      ldx	POS_Y_NEW
    419  4156		       86 8b		      stx	POS_Y
    420  4158		       a4 8c		      ldy	POS_X_NEW
    421  415a		       84 8a		      sty	POS_X
    422  415c		       a5 dc		      lda	restorationCharacter
    423  415e		       85 8f		      sta	POS_VAR
    424  4160
    425  4160		       20 5c f9 	      jsr	RestoreOriginalCharacter	; put back BOX's restoration character
    426  4163
    427  4163		       68		      pla
    428  4164		       85 8f		      sta	POS_VAR
    429  4166
    430  4166							;START_SOUND SOUND_BOX
    431  4166
    432  4166		       4c bb f9 	      jmp	MovePlayer	; now there's a gap, player should move in
    433  4169
    434  4169		       e6 a5	   cannotPush inc	ManPushCounter
    435  416b		       60		      rts
    436  416c
    437  416c							;------------------------------------------------------------------------------
    438  416c
    439  416c							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    440  416c							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    441  416c
    442  416c							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    443  416c
    444  416c							; if the creature dies then jump NextObject
    445  416c
    446  416c
    447  416c
    448  416c		       ff	   RDirY      .byte.b	-1	;,0,1,0
    449  416d		       00 01	   RDirX      .byte.b	0,1	;,0,-1
    450  416f		       00 ff 01 00 DirPushModX .byte.b	0,-1,1,0
    451  4173		       ff 00 00 01 DirPushModY .byte.b	-1,0,0,1
    452  4177		       01 02 03 00*Directional .byte.b	1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    453  4185
    454  4185
    455  4185							;------------------------------------------------------------------------------
    456  4185
    457  4185							; the auto-calculation of these was causing DASM to get confused and abort assembling.
    458  4185							; I don't particularly know why; probably because of the level variable-size array and the values
    459  4185							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    460  4185
    461  4185		       00 00	   MANMODE_STARTUP =	0
    462  4185		       00 01	   MANMODE_NORMAL =	1
    463  4185		       00 02	   MANMODE_DEAD =	2
    464  4185		       00 03	   MANMODE_WAITING =	3
    465  4185		       00 04	   MANMODE_WAITING2 =	4
    466  4185		       00 05	   MANMODE_WAITING_NT =	5
    467  4185		       00 06	   MANMODE_WAITING_NT2 =	6
    468  4185		       00 07	   MANMODE_NEXTLEVEL =	7
    469  4185		       00 08	   MANMODE_NEXTLEVEL2 =	8
    470  4185		       00 09	   MANMODE_SWITCH =	9
    471  4185
      0  4185					      DEFINE_SUBROUTINE	ManProcess	; in INITBANK
      1  4185		       00 08	   BANK_ManProcess =	_CURRENT_BANK
      2  4185					      SUBROUTINE
      3  4185				   ManProcess
    473  4185
    474  4185							;lda #$FF
    475  4185							;sta specialTimeFlag		  ; detects time overflow in bigbang (and TARGET grab)
    476  4185
    477  4185
    478  4185							; ManMode tells the player what it is currently doing.  State machine.
    479  4185
    480  4185					      if	1
    481  4185							; RESET to start next level
    482  4185
    483  4185		       ad 82 02 	      lda	SWCHB
    484  4188		       29 02		      and	#2
    485  418a		       d0 04		      bne	skipNextLevel
    486  418c		       a9 09		      lda	#MANMODE_SWITCH
    487  418e		       85 9f		      sta	ManMode
    488  4190				   skipNextLevel
    489  4190
    490  4190							; RESET to re-start current level
    491  4190
    492  4190		       ad 82 02 	      lda	SWCHB
    493  4193		       29 01		      and	#1
    494  4195		       d0 04		      bne	noReset
    495  4197		       a9 04		      lda	#MANMODE_WAITING2
    496  4199		       85 9f		      sta	ManMode
    497  419b				   noReset
    498  419b
    499  419b					      endif
    500  419b
    501  419b
    502  419b							; Check if all the boxes are on their target square
    503  419b
    504  419b
    505  419b							;lda SWCHB
    506  419b							;and #3
    507  419b							;bne .skipReset	  ; BOTH select/reset = restart
    508  419b
    509  419b							;lsr SWCHB
    510  419b							;bcs .skipReset
    511  419b
    512  419b
    513  419b				   .skipReset
    514  419b
    515  419b							;sokldy ManMode
    516  419b							;sok lda ManActionTimer,y
    517  419b							;sok beq .skipTimer
    518  419b		       20 cb f1 	      jsr	UpdateTimer
    519  419e				   .skipTimer
    520  419e		       a4 9f		      ldy	ManMode
    521  41a0		       b9 b7 f1 	      lda	ManActionLO,y
    522  41a3		       85 da		      sta	actionVector
    523  41a5		       b9 c1 f1 	      lda	ManActionHI,y
    524  41a8		       85 db		      sta	actionVector+1
    525  41aa		       6c da 00 	      jmp	(actionVector)
    526  41ad
    527  41ad				   ManActionTimer
    528  41ad		       00		      .byte.b	0	;<manStartup		 ; 0		 no timer
    529  41ae		       01		      .byte.b	1	;<normalMan		 ; 1		 timer
    530  41af		       01		      .byte.b	1	;<deadMan		 ; 2		 timer
    531  41b0		       01		      .byte.b	1	;<waitingMan		 ; 3		 timer
    532  41b1		       01		      .byte.b	1	;<waitingManPress	 ; 4		 timer
    533  41b2		       00		      .byte.b	0	;<waitingManNoTim	 ; 5		 no timer
    534  41b3		       00		      .byte.b	0	;<waitingManPressNoTim  ; 6		 no timer
    535  41b4		       00		      .byte.b	0	;<nextLevelMan 	 ; 7		 no timer
    536  41b5		       00		      .byte.b	0	;<nextLevelMan2	  ; 8		  no timer
    537  41b6		       00		      .byte.b	0	;<nextLevelMan3	  ; 9		  no timer
    538  41b7				   ManActionLO
    539  41b7		       f8		      .byte.b	<manStartup	; 0		 no timer
    540  41b8		       22		      .byte.b	<normalMan	; 1		 timer
    541  41b9		       27		      .byte.b	<deadMan	; 2		 timer
    542  41ba		       1b		      .byte.b	<waitingMan	; 3		 timer
    543  41bb		       1b		      .byte.b	<waitingManPress	; 4		 timer
    544  41bc		       1b		      .byte.b	<waitingMan	; 5		 no timer
    545  41bd		       1b		      .byte.b	<waitingManPress	; 6		 no timer
    546  41be		       f2		      .byte.b	<nextLevelMan	; 7		 no timer
    547  41bf		       0a		      .byte.b	<nextLevelMan2	; 8		 no timer
    548  41c0		       13		      .byte.b	<switchLevels	; 9		 no timer
    549  41c1
    550  41c1				   ManActionHI
    551  41c1		       f1		      .byte.b	>manStartup	; no timer
    552  41c2		       f2		      .byte.b	>normalMan	; timer
    553  41c3		       f2		      .byte.b	>deadMan	; timer
    554  41c4		       f2		      .byte.b	>waitingMan	; timer
    555  41c5		       f2		      .byte.b	>waitingManPress	; timer
    556  41c6		       f2		      .byte.b	>waitingMan	; no timer
    557  41c7		       f2		      .byte.b	>waitingManPress	; no timer
    558  41c8		       fc		      .byte.b	>nextLevelMan	; no timer
    559  41c9		       fd		      .byte.b	>nextLevelMan2	; no timer
    560  41ca		       fd		      .byte.b	>switchLevels	;9  no timer
    561  41cb
    562  41cb							;------------------------------------------------------------------------------
      0  41cb					      DEFINE_SUBROUTINE	UpdateTimer
      1  41cb		       00 08	   BANK_UpdateTimer =	_CURRENT_BANK
      2  41cb					      SUBROUTINE
      3  41cb				   UpdateTimer
    564  41cb
    565  41cb		       a9 09		      lda	#BANK_SCORING
    566  41cd		       20 08 f8 	      jsr	DrawTargetsRequiredFromROM
    567  41d0
    568  41d0
    569  41d0		       a2 03		      ldx	#3
    570  41d2							;		  lda ManMode
    571  41d2							;		  cmp #MANMODE_BONUS_RUN
    572  41d2							;		  beq .setLoops
    573  41d2
    574  41d2		       a2 04		      ldx	#NUM_LEVELS-1	; intermissions run at full speed
    575  41d4		       24 b6		      bit	levelDisplay
    576  41d6		       30 02		      bmi	.intermission2
    577  41d8		       a6 b5		      ldx	level
    578  41da				   .intermission2
    579  41da
    580  41da		       a2 01		      ldx	#1
    581  41dc				   .setLoops
    582  41dc		       86 db		      stx	timerLoops
    583  41de		       d0 08		      bne	.notScoring
    584  41e0				   .loopTimer
    585  41e0		       a5 b5		      lda	level	; each second left adds 'level' to score
    586  41e2		       18		      clc
    587  41e3		       69 01		      adc	#1
    588  41e5		       20 e6 fc 	      jsr	ScoreAdd
    589  41e8				   .notScoring
    590  41e8							;		  sed
    591  41e8							;		  sec
    592  41e8							;		  lda moveCounter
    593  41e8							;		  sbc #1
    594  41e8							;		  sta moveCounter
    595  41e8							;		  cld
    596  41e8							;		  bcs .skipHi2a
    597  41e8							;		  dec moveCounterHi
    598  41e8							;.skipHi2a
    599  41e8							; check for running out of time sound:
    600  41e8							;		  lda moveCounterHi
    601  41e8							;		  bne .timeAbove9
    602  41e8							;		  lda #$09
    603  41e8							;		  sec
    604  41e8							;		  sbc moveCounter
    605  41e8							;		  bcc .timeAbove9
    606  41e8							; this assumes that SND_MASK_HI = %11110000
    607  41e8							;  and the time entries are ordered 9 to 0!
    608  41e8							;		  asl
    609  41e8							;		  asl
    610  41e8							;		  asl
    611  41e8							;		  asl
    612  41e8							;		  adc #SOUND_TIME_9
    613  41e8							;		  sta tmpSound
    614  41e8							;		  lda newSounds
    615  41e8							;		  and #<(~SND_MASK_HI)
    616  41e8							;		  ora tmpSound
    617  41e8							;		  sta newSounds
    618  41e8							;.skipTimeSound:
    619  41e8							;		  ldx moveCounter
    620  41e8							;		  bne .timeNotZero
    621  41e8							;		  stx AUDV0			  ; stop bonus sound
    622  41e8							;		  stx soundIdxLst
    623  41e8							;.contChannel1:
    624  41e8							;		  ldx #MANMODE_NEXTLEVEL	  ; time bonus
    625  41e8							;		  lda ManMode
    626  41e8							;		  cmp #MANMODE_BONUS_RUN
    627  41e8							;		  beq .nextLevel
    628  41e8							;		  ldx #MANMODE_WAITING_NT2	  ; time over
    629  41e8							;		  cmp #MANMODE_WAITING2 	  ; Man already dead?
    630  41e8							;		  beq .nextLevel
    631  41e8							;		  dex				  ; == MANMODE_WAITING_NT
    632  41e8							;.nextLevel
    633  41e8							;		  stx ManMode			  ; -> man dies
    634  41e8				   .timeNotZero
    635  41e8				   .forceTimeDraw
    636  41e8
    637  41e8
    638  41e8		       a9 09		      lda	#BANK_SCORING
    639  41ea		       4c 00 f8 	      jmp	DrawTimeFromROM	; Z-flag == 0!
    640  41ed
    641  41ed				   .timeAbove9
    642  41ed		       c6 db		      dec	timerLoops
    643  41ef		       d0 ef		      bne	.loopTimer
    644  41f1		       f0 f5		      beq	.forceTimeDraw
    645  41f3
    646  41f3				   TimeFracTbl
    647  41f3		       1f		      .byte.b	31	; level 1, NTSC/PAL
    648  41f4		       1b		      .byte.b	27	; level 2, NTSC/PAL
    649  41f5		       18		      .byte.b	24	; level 3, NTSC/PAL
    650  41f6		       17		      .byte.b	23	; level 4, NTSC/PAL
    651  41f7		       16		      .byte.b	22	; level 5, NTSC/PAL
    652  41f8							; calculate: level 5 throttle * level 5 time / level x throttle
    653  41f8
    654  41f8
    655  41f8							;------------------------------------------------------------------------------
      0  41f8					      DEFINE_SUBROUTINE	manStartup
      1  41f8		       00 08	   BANK_manStartup =	_CURRENT_BANK
      2  41f8					      SUBROUTINE
      3  41f8				   manStartup
    657  41f8
    658  41f8		       a5 9b		      lda	ManX
    659  41fa		       85 8c		      sta	POS_X_NEW	;NewX
    660  41fc		       85 8a		      sta	POS_X
    661  41fe		       a5 9c		      lda	ManY
    662  4200		       85 8d		      sta	POS_Y_NEW	;NewY
    663  4202		       85 8b		      sta	POS_Y
    664  4204
    665  4204		       e6 9a		      inc	manAnimationIndex
    666  4206		       a6 9a		      ldx	manAnimationIndex	; animation index
    667  4208		       bd 18 f2 	      lda	.ManStartup-1,x
    668  420b		       30 09		      bmi	CreateThePlayer
    669  420d		       85 8e		      sta	POS_Type
    670  420f
    671  420f		       a9 ff		      lda	#$FF
    672  4211		       85 a0		      sta	ManDelayCount	; anything, just non-0
    673  4213
    674  4213		       4c 3d f8 	      jmp	PutBoardCharacterFromRAM	;70 --> switches this bank out but who cares!
    675  4216
    676  4216				   CreateThePlayer
    677  4216
    678  4216		       e6 9f		      inc	ManMode	; --> MANMODE_NORMAL
    679  4218				   RTS_CF
    680  4218		       60		      rts
    681  4219
    682  4219				   .ManStartup
    683  4219							;    .byte CHARACTER_NOGO
    684  4219							;    .byte CHARACTER_NOGO
    685  4219							;    .byte CHARACTER_STEEL
    686  4219							;    .byte CHARACTER_STEEL
    687  4219							;    .byte CHARACTER_NOGO
    688  4219							;    .byte CHARACTER_NOGO
    689  4219							;    .byte CHARACTER_STEEL
    690  4219							;    .byte CHARACTER_NOGO
    691  4219							;    .byte CHARACTER_STEEL
    692  4219							;    .byte CHARACTER_NOGO
    693  4219							;    .byte CHARACTER_STEEL
    694  4219							;    .byte CHARACTER_NOGO
    695  4219							;    .byte CHARACTER_STEEL
    696  4219							;    .byte CHARACTER_NOGO
    697  4219							;    .byte CHARACTER_STEEL
    698  4219							;    .byte CHARACTER_NOGO
    699  4219							;    .byte CHARACTER_STEEL
    700  4219							;.byte CHARACTER_NOGO
    701  4219		       05		      .byte.b	CHARACTER_MANOCCUPIED
    702  421a		       ff		      .byte.b	-1
    703  421b
    704  421b							;------------------------------------------------------------------------------
    705  421b
    706  421b				   waitingMan
    707  421b				   waitingManPress
    708  421b
    709  421b							;		  lda #50
    710  421b							;		  sta ColourTimer
    711  421b
    712  421b
    713  421b		       a5 ca		      lda	NextLevelTrigger
    714  421d		       09 40		      ora	#BIT_NEXTLIFE
    715  421f		       85 ca		      sta	NextLevelTrigger
    716  4221		       60		      rts
    717  4222
    718  4222
    719  4222							;------------------------------------------------------------------------------
    720  4222							; Normal man state
    721  4222
    722  4222
    723  4222				   normalMan
    724  4222
    725  4222							; Timer is still running, so we see if the player is to die for any reason
    726  4222
    727  4222							;		  bit demoMode
    728  4222							;		  bmi stayAlive
    729  4222							; SELECT pressed?
    730  4222							;		  lda SWCHB
    731  4222							;		  eor #$FF
    732  4222							;		  and #3
    733  4222							;		  bne Time0			  ; EITHER select or reset are pressed
    734  4222							;		  lsr
    735  4222							;		  lsr
    736  4222							;		  bcc Time0			  ; suicide!
    737  4222				   stayAlive
    738  4222
    739  4222							;------------------------------------------------------------------------------
    740  4222
    741  4222							;ldx ManY
    742  4222							;ldy ManX
    743  4222
    744  4222							;lda BoardLineStartLO,x
    745  4222							;sta Board_AddressR
    746  4222							;lda BoardLineStartHiR,x
    747  4222							;sta Board_AddressR+1
    748  4222
    749  4222				  -	      IF	MULTI_BANK_BOARD = YES
    750  4222				  -			;lda BoardBank,x		  ;4
    751  4222				  -			;sta RAM_Bank			  ;3
    752  4222					      ELSE
    753  4222							;lda #BANK_BOARD		  ;2
    754  4222					      ENDIF
    755  4222							;jsr GetBoardCharacter 	  ;6+20(A)
    756  4222
    757  4222							;lda CharToType,x
    758  4222							;cmp #TYPE_MAN
    759  4222							;beq PlayerAlive
    760  4222		       4c 32 f2 	      jmp	PlayerAlive	;sok
    761  4225
    762  4225							; character he's on isn't a MAN character, so he dies...
    763  4225
    764  4225				   Time0
    765  4225
    766  4225		       e6 9f		      inc	ManMode	; #1 -- player dead!
    767  4227
    768  4227
    769  4227		       a5 9b	   deadMan    lda	ManX
    770  4229		       85 8a		      sta	POS_X
    771  422b		       a5 9c		      lda	ManY
    772  422d		       85 8b		      sta	POS_Y
    773  422f
    774  422f							;jsr BlankPlayerFrame
    775  422f
    776  422f							; and becomes a man waiting for resurrection...
    777  422f
    778  422f		       e6 9f		      inc	ManMode
    779  4231
    780  4231				   timeTooShortToDie
    781  4231		       60		      rts
    782  4232
    783  4232							;------------------------------------------------------------------------------
    784  4232
    785  4232				   PlayerAlive
    786  4232
    787  4232							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    788  4232							; before exiting via (for example) look-around option :)
    789  4232
    790  4232		       a5 9b		      lda	ManX
    791  4234		       85 8c		      sta	POS_X_NEW
    792  4236		       a5 9c		      lda	ManY
    793  4238		       85 8d		      sta	POS_Y_NEW
    794  423a
    795  423a
    796  423a
    797  423a							;------------------------------------------------------------------------------
    798  423a							; Look around is triggered by holding down the fire button for a while, without any other
    799  423a							; joystick directions chosen. The variable LookingAround has a negative value ($FF) when looking
    800  423a							; is active. Otherwise, it is counting down to the time where it will trigger.
    801  423a
    802  423a		       00 00	   LOOK_DELAY =	0
    803  423a
    804  423a
    805  423a							;------------------------------------------------------------------------------
    806  423a							; Take-back is a press/release of the button, with the press being limited in duratino
    807  423a							; to allow the action to be "cancelled". Meanwhile, a button press + direction triggers
    808  423a							; "look-around mode"
    809  423a
    810  423a		       a5 92		      lda	BufferedButton
    811  423c		       30 36		      bmi	noLook	; button?
    812  423e
    813  423e							; button pressed, so in looking-around mode
    814  423e
    815  423e		       a2 ff		      ldx	#$FF
    816  4240		       86 92		      stx	BufferedButton	; "release" button
    817  4242
    818  4242		       a5 a6		      lda	LookingAround
    819  4244		       30 02		      bmi	LookAround
    820  4246		       86 a6		      stx	LookingAround
    821  4248				   LookAround
    822  4248
    823  4248							; Use the joystick as a window-scroller to change the viewport
    824  4248
    825  4248		       a5 90		      lda	BufferedJoystick
    826  424a		       4a		      lsr
    827  424b		       4a		      lsr
    828  424c		       4a		      lsr
    829  424d		       4a		      lsr
    830  424e		       a8		      tay
    831  424f
    832  424f		       b9 bd f2 	      lda	JoyMoveX,y
    833  4252		       19 c9 f2 	      ora	JoyMoveY,y
    834  4255		       f0 1c		      beq	AbandonY
    835  4257
    836  4257		       a9 fe		      lda	#$FE
    837  4259		       85 a6		      sta	LookingAround
    838  425b
    839  425b		       b9 bd f2 	      lda	JoyMoveX,y
    840  425e							;asl
    841  425e		       18		      clc
    842  425f		       65 97		      adc	BoardScrollX
    843  4261		       c5 94		      cmp	BoardEdge_Right
    844  4263		       b0 02		      bcs	AbandonX
    845  4265		       85 97		      sta	BoardScrollX
    846  4267
    847  4267		       b9 c9 f2    AbandonX   lda	JoyMoveY,y
    848  426a							;asl
    849  426a		       18		      clc
    850  426b		       65 96		      adc	BoardScrollY
    851  426d		       c5 95		      cmp	BoardEdge_Bottom
    852  426f		       b0 02		      bcs	AbandonY
    853  4271		       85 96		      sta	BoardScrollY
    854  4273
    855  4273		       60	   AbandonY   rts
    856  4274
    857  4274		       a5 a6	   noLook     lda	LookingAround
    858  4276		       c9 ff		      cmp	#$FF
    859  4278		       d0 00		      bne	bProcComp
    860  427a
    861  427a							; button was presssed and now released and we didn't actually look around
    862  427a							; TODO -- takeback here
    863  427a							;jsr restorePreviousManPosition
    864  427a							;lda #2
    865  427a							;sta ColourTimer
    866  427a
    867  427a		       a2 00	   bProcComp  ldx	#0
    868  427c		       86 a6		      stx	LookingAround
    869  427e
    870  427e							;------------------------------------------------------------------------------
    871  427e
    872  427e							; control the scrolling via the joystick
    873  427e
    874  427e		       a5 a4		      lda	ManLastDirection
    875  4280		       29 07		      and	#DIRECTION_BITS
    876  4282		       a8		      tay
    877  4283
    878  4283		       a5 90		      lda	BufferedJoystick	; joystick
    879  4285		       25 91		      and	BufferedJoystick+1
    880  4287
    881  4287		       a2 00		      ldx	#0
    882  4289		       0a	   .loopDirs  asl
    883  428a		       90 07		      bcc	.dirFound
    884  428c		       88		      dey
    885  428d		       e8		      inx
    886  428e		       e0 04		      cpx	#4
    887  4290		       d0 f7		      bne	.loopDirs
    888  4292		       18		      clc
    889  4293				   .dirFound
    890  4293		       a5 8c		      lda	POS_X_NEW	;NewX
    891  4295		       7d d6 f2 	      adc	JoyDirX,x
    892  4298		       85 8c		      sta	POS_X_NEW	;NewX
    893  429a		       a5 8d		      lda	POS_Y_NEW	;NewY
    894  429c		       18		      clc
    895  429d		       7d d4 f2 	      adc	JoyDirY,x
    896  42a0		       85 8d		      sta	POS_Y_NEW	;NewY
    897  42a2
    898  42a2		       98		      tya
    899  42a3		       f0 12		      beq	noMovement	; animation OK
    900  42a5
    901  42a5		       8a		      txa
    902  42a6		       45 a4		      eor	ManLastDirection
    903  42a8		       29 07		      and	#DIRECTION_BITS
    904  42aa		       45 a4		      eor	ManLastDirection
    905  42ac		       85 a4		      sta	ManLastDirection
    906  42ae		       bd b8 f2 	      lda	ManAnimTblLo,x
    907  42b1		       85 a1		      sta	ManAnimation
    908  42b3							;lda ManAnimTblHi,x
    909  42b3							;sta ManAnimation+1
    910  42b3		       a9 00		      lda	#0
    911  42b5		       85 a0		      sta	ManDelayCount
    912  42b7				   phase0		;jsr MovePlayer
    913  42b7				   noMovement		;ldx MAN_Player
    914  42b7
    915  42b7		       60	   DFS_rts    rts
    916  42b8
    917  42b8
    918  42b8				   ManAnimTblLo
    919  42b8		       00 00 00 00*	      .byte.b	AnimateRIGHT-Manimate, AnimateLEFT-Manimate, AnimateUP-Manimate, AnimateUP-Manimate, AnimateSTOPPED-Manimate
    920  42bd							;ManAnimTblHi
    921  42bd							;    .byte   >AnimateRIGHT, >AnimateLEFT, >AnimateUP, >AnimateUP, >AnimateSTOPPED
    922  42bd
    923  42bd
    924  42bd
    925  42bd		       00 00 00 00*JoyMoveX   .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1	;,0, 0,0,0
    926  42c9		       00 00 00 00*JoyMoveY   .byte.b	0,0,0,0,0,1,-1,0,0, 1,-1	;, 0,0,1,-1,0
    927  42d4
    928  42d4				   JoyDirY
    929  42d4		       00 00		      .byte.b	0,0	;,1,-1,0
    930  42d6				   JoyDirX
    931  42d6		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
    932  42db
    933  42db
    934  42db							;------------------------------------------------------------------------------
    935  42db
    936  42db
      0  42db					      DEFINE_SUBROUTINE	DrawFullScreen	; = 2568[-96]
      1  42db		       00 08	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  42db					      SUBROUTINE
      3  42db				   DrawFullScreen
    938  42db
    939  42db							; 83[-7] + 2484[-89] = 2567[-96]
    940  42db
    941  42db
    942  42db		       ad 84 02 	      lda	INTIM	; 4
    943  42de		       c9 29		      cmp	#SEGTIME_BDF	; 2
    944  42e0		       90 d5		      bcc	DFS_rts	; 2/3
      0  42e2					      STRESS_TIME	SEGTIME_BDF
      1  42e2				  -	      IF	TEST_SEGTIME_BDF = 1
      2  42e2				  -
      3  42e2				  -
      4  42e2				  -
      5  42e2				  -
      6  42e2				  -
      7  42e2				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  42e2				  -	      bne	. - 7
      9  42e2					      ENDIF
    946  42e2
    947  42e2		       a9 f4		      lda	#>( DrawFlag + RAM_WRITE )	; 2
    948  42e4		       85 db		      sta	BDF_DrawFlagAddress+1	; 3
    949  42e6		       85 dd		      sta	BDF_DrawFlagAddress2+1	; 3
    950  42e8
    951  42e8		       ba		      tsx		; 2
    952  42e9		       86 e4		      stx	DHS_Stack	; 3
    953  42eb
    954  42eb		       e6 89		      inc	ScreenDrawPhase	; 5
    955  42ed
    956  42ed		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
    957  42ee		       a2 08		      ldx	#SCREEN_LINES	; 2
    958  42f0		       8a		      txa		; 2 = 31
    959  42f1
    960  42f1							; fall through
    961  42f1
    962  42f1							;------------------------------------------------------------------------------
    963  42f1
      0  42f1					      DEFINE_SUBROUTINE	DrawScreenRowPreparation	; = 52[-7]
      1  42f1		       00 08	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  42f1					      SUBROUTINE
      3  42f1				   DrawScreenRowPreparation
    965  42f1
    966  42f1							;clc
    967  42f1		       ca		      dex		; 2
    968  42f2		       86 e3		      stx	DHS_Line	; 3
    969  42f4		       65 96		      adc	BoardScrollY	; 3	     the Y offset of screen into board
    970  42f6		       a8		      tay		; 2 = 10
    971  42f7
    972  42f7							;clc
    973  42f7		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
    974  42fa		       65 97		      adc	BoardScrollX	; 3	     the X offset of screen into board
    975  42fc		       85 de		      sta	BDF_BoardAddress	; 3
    976  42fe		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    977  4300		       85 e0		      sta	BDF_BoardAddress2	; 3
    978  4302
    979  4302		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
    980  4305		       85 df		      sta	BDF_BoardAddress+1	; 3
    981  4307		       85 e1		      sta	BDF_BoardAddress2+1	; 3 = 25
    982  4309
    983  4309		       bd c0 f0 	      lda	DrawLineStartLO,x	; 4
    984  430c		       85 da		      sta	BDF_DrawFlagAddress	; 3
    985  430e		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    986  4310		       85 dc		      sta	BDF_DrawFlagAddress2	; 3 = 12
    987  4312
    988  4312				  -	      IF	MULTI_BANK_BOARD = YES
    989  4312				  -	      lda	BoardBank-1,y	; 4
    990  4312				  -	      sta	BDF_BoardBank	; 3
    991  4312					      ENDIF
    992  4312		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
    993  4314		       4c bf fa 	      jmp	CopyRow2	; 3 = 12[-7]
    994  4317
    995  4317							;------------------------------------------------------------------------------
    996  4317
      0  4317					      DEFINE_SUBROUTINE	VectorProcess	;=19(A)
      1  4317		       00 08	   BANK_VectorProcess =	_CURRENT_BANK
      2  4317					      SUBROUTINE
      3  4317				   VectorProcess
    998  4317
    999  4317							;sta ROM_Bank			  ;3		  processors can assume bank is stored
   1000  4317
   1001  4317		       bd 27 f3 	      lda	OSPointerHI,x	;4
   1002  431a		       85 db		      sta	POS_Vector+1	;3
   1003  431c		       bd 24 f3 	      lda	OSPointerLO,x	;4
   1004  431f		       85 da		      sta	POS_Vector	;3
   1005  4321
   1006  4321		       6c da 00 	      jmp	(POS_Vector)	;5 = 19	 vector to processor for particular object type
   1007  4324							;		 NOTE: Bank is either INITBANK or FIXED.
   1008  4324
   1009  4324
   1010  4324				   OBJTYPE    SET	0
   1011  4324					      MAC	define
   1012  4324				   TYPE_{1}   =	OBJTYPE
   1013  4324				   OBJTYPE    .SET	OBJTYPE + 1
   1014  4324					      ENDM
   1015  4324
   1016  4324							; If adding/removing types, the following must also be updated...
   1017  4324							;   InitialFace[...]		     in UnpackLevel.asm
   1018  4324							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
   1019  4324							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
   1020  4324							;   OSPointerLO[...]		     in BANK_INITBANK.asm
   1021  4324							;   OSPointerHI[...]		     in BANK_INITBANK.asm
   1022  4324							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1023  4324							;   Sortable[...]		     in BANK_FIXED.asm
   1024  4324
   1025  4324
      0  4324					      DEFINE	MAN
      1  4324		       00 00	   TYPE_MAN   =	OBJTYPE
      2  4324				   OBJTYPE    .SET	OBJTYPE + 1
      0  4324					      DEFINE	CIRCLE
      1  4324		       00 01	   TYPE_CIRCLE =	OBJTYPE
      2  4324				   OBJTYPE    .SET	OBJTYPE + 1
      0  4324					      DEFINE	CIRCLE_HELPER
      1  4324		       00 02	   TYPE_CIRCLE_HELPER =	OBJTYPE
      2  4324				   OBJTYPE    .SET	OBJTYPE + 1
      0  4324					      DEFINE	CIRCLE_DRAWER
      1  4324		       00 03	   TYPE_CIRCLE_DRAWER =	OBJTYPE
      2  4324				   OBJTYPE    .SET	OBJTYPE + 1
   1030  4324
      0  4324					      DEFINE	MAXIMUM
      1  4324		       00 04	   TYPE_MAXIMUM =	OBJTYPE
      2  4324				   OBJTYPE    .SET	OBJTYPE + 1
   1032  4324
   1033  4324
      0  4324					      DEFINE_SUBROUTINE	OSPointerLO
      1  4324		       00 08	   BANK_OSPointerLO =	_CURRENT_BANK
      2  4324					      SUBROUTINE
      3  4324				   OSPointerLO
   1035  4324		       2a		      .byte.b	<PROCESS_MAN
   1036  4325		       db		      .byte.b	<PROCESS_CIRCLE
   1037  4326		       d1		      .byte.b	<PROCESS_CIRCLE_HELPER
   1038  4327
   1039  4327				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
   1040  4327				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
   1041  4327				  -	      ERR
   1042  4327					      ENDIF
   1043  4327
   1044  4327
      0  4327					      DEFINE_SUBROUTINE	OSPointerHI
      1  4327		       00 08	   BANK_OSPointerHI =	_CURRENT_BANK
      2  4327					      SUBROUTINE
      3  4327				   OSPointerHI
   1046  4327		       f9		      .byte.b	>PROCESS_MAN
   1047  4328		       f8		      .byte.b	>PROCESS_CIRCLE
   1048  4329		       f8		      .byte.b	>PROCESS_CIRCLE_HELPER
   1049  432a
   1050  432a				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
   1051  432a				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
   1052  432a				  -	      ERR
   1053  432a					      ENDIF
   1054  432a
   1055  432a							;------------------------------------------------------------------------------
   1056  432a
      0  432a					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  432a		       00 08	   BANK_MoveVecLO =	_CURRENT_BANK
      2  432a					      SUBROUTINE
      3  432a				   MoveVecLO
   1058  432a
   1059  432a		       e7		      .byte.b	<MOVE_BLANK
   1060  432b		       e7		      .byte.b	<MOVE_SOIL
   1061  432c		       31		      .byte.b	<MOVE_BOX
   1062  432d		       e7		      .byte.b	<MOVE_TARGET
   1063  432e		       e7		      .byte.b	<MOVE_TARGET
   1064  432f		       2c		      .byte.b	<MOVE_GENERIC	;man occupied
   1065  4330		       2c		      .byte.b	<MOVE_GENERIC	;steel
   1066  4331		       2c		      .byte.b	<MOVE_GENERIC	;wall
   1067  4332		       3c		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
   1068  4333		       2c		      .byte.b	<MOVE_GENERIC	;nogo
   1069  4334
   1070  4334				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
   1071  4334				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
   1072  4334				  -	      ERR
   1073  4334					      ENDIF
   1074  4334
   1075  4334
   1076  4334
      0  4334					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  4334		       00 08	   BANK_MoveVecHI =	_CURRENT_BANK
      2  4334					      SUBROUTINE
      3  4334				   MoveVecHI
   1078  4334
   1079  4334		       f9		      .byte.b	>MOVE_BLANK
   1080  4335		       f9		      .byte.b	>MOVE_SOIL
   1081  4336		       fa		      .byte.b	>MOVE_BOX
   1082  4337		       f9		      .byte.b	>MOVE_TARGET
   1083  4338		       f9		      .byte.b	>MOVE_TARGET
   1084  4339		       fa		      .byte.b	>MOVE_GENERIC	;man occupied
   1085  433a		       fa		      .byte.b	>MOVE_GENERIC	;steel
   1086  433b		       fa		      .byte.b	>MOVE_GENERIC	;wall
   1087  433c		       fa		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
   1088  433d		       fa		      .byte.b	>MOVE_GENERIC	;nogo
   1089  433e
   1090  433e				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
   1091  433e				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
   1092  433e				  -	      EXIT
   1093  433e					      ENDIF
   1094  433e
   1095  433e
      0  433e					      CHECK_BANK_SIZE	"INITBANK"
      1  433e		       03 3e	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $33e , FREE= $4c2
      2  433e					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  433e				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  433e				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  433e				  -	      ERR
      6  433e					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_FIXED.asm LEVEL 2 PASS 3
      0  433e					      include	"BANK_FIXED.asm"
      1  433e							;    Sokoboo - a Sokoban implementation
      2  433e							;    using a generic tile-based display engine for the Atari 2600
      3  433e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  433e							;
      5  433e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  433e							;
      7  433e							;    Code related to the generic tile-based display engine was developed by
      8  433e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  433e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  433e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  433e							;
     12  433e							;    Code related to music and sound effects uses the TIATracker music player
     13  433e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  433e							;    directory for Apache licensing details.
     15  433e							;
     16  433e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  433e							;    See the copyright notices in the License directory for a list of level
     18  433e							;    contributors.
     19  433e							;
     20  433e							;    Except where otherwise indicated, this software is released under the
     21  433e							;    following licensing arrangement...
     22  433e							;
     23  433e							;    This program is free software: you can redistribute it and/or modify
     24  433e							;    it under the terms of the GNU General Public License as published by
     25  433e							;    the Free Software Foundation, either version 3 of the License, or
     26  433e							;    (at your option) any later version.
     27  433e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  433e
     29  433e							;    This program is distributed in the hope that it will be useful,
     30  433e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  433e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  433e							;    GNU General Public License for more details.
     33  433e
     34  433e							;------------------------------------------------------------------------------
     35  433e							;###############################  FIXED BANK  #################################
     36  433e							;------------------------------------------------------------------------------
     37  433e
     38  433e
     39  433e				   ORIGIN     SET	FIXED_BANK
     40  433e
      0  433e					      NEWBANK	THE_FIXED_BANK
      1  7fda ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
     42  7800					      RORG	$f800
     43  7800
     44  7800
     45  7800
     46  7800							;------------------------------------------------------------------------------
     47  7800
      0  7800					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  7800		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  7800					      SUBROUTINE
      3  7800				   DrawTimeFromROM
     49  7800
     50  7800		       85 3e		      sta	SET_BANK_RAM
     51  7802		       20 f5 f2 	      jsr	DrawTime
     52  7805		       85 3f		      sta	SET_BANK
     53  7807		       60		      rts
     54  7808
      0  7808					      DEFINE_SUBROUTINE	DrawTargetsRequiredFromROM
      1  7808		       00 0f	   BANK_DrawTargetsRequiredFromROM =	_CURRENT_BANK
      2  7808					      SUBROUTINE
      3  7808				   DrawTargetsRequiredFromROM
     56  7808
     57  7808		       85 3e		      sta	SET_BANK_RAM
     58  780a		       20 e0 f2 	      jsr	DrawTargetsRequired
     59  780d		       a5 c4		      lda	ROM_Bank
     60  780f		       85 3f		      sta	SET_BANK
     61  7811		       60		      rts
     62  7812
     63  7812							;------------------------------------------------------------------------------
     64  7812
      0  7812					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  7812		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  7812					      SUBROUTINE
      3  7812				   GetROMByte
     66  7812
     67  7812							; a = ROM bank to retrieve
     68  7812							; y = page index
     69  7812							; ROM_Bank = bank to return to
     70  7812							; (Board_AddressR) = page
     71  7812							; out a = byte from (Board_AddressR)
     72  7812
     73  7812		       85 3f		      sta	SET_BANK	;3
     74  7814		       4c 19 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
     75  7817
     76  7817							;------------------------------------------------------------------------------
     77  7817
      0  7817					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7817		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7817					      SUBROUTINE
      3  7817				   GetBoardCharacter
     79  7817
     80  7817							; call from ROM bank
     81  7817							; switches back to ROM_Bank on exit
     82  7817
     83  7817							; pass A = bank containing character
     84  7817							; Y = x character position
     85  7817							; (Board_AddressR) points to character position
     86  7817							; returns character from board
     87  7817
     88  7817
     89  7817		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
     90  7819
     91  7819				   GetBoardCharacter2		;=17(A)
     92  7819
     93  7819		       b3 c0		      lax	(Board_AddressR),y	;5
     94  781b		       a4 c4		      ldy	ROM_Bank	;3
     95  781d		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
     96  781f		       60		      rts		;6   and go back
     97  7820
     98  7820							;---------------------------------------------------------------------------
     99  7820
      0  7820					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  7820		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  7820					      SUBROUTINE
      3  7820				   PutBoardCharacter
    101  7820
    102  7820		       86 3e		      stx	SET_BANK_RAM	; 3
    103  7822
    104  7822				   PutBoardCharacterSB		; =18
    105  7822		       91 c2		      sta	(Board_AddressW),y	; 6
    106  7824		       a5 c4		      lda	ROM_Bank	; 3
    107  7826		       85 3f		      sta	SET_BANK	; 3
    108  7828		       60		      rts		; 6 = 21
    109  7829
    110  7829							;---------------------------------------------------------------------------
    111  7829
      0  7829					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  7829		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  7829					      SUBROUTINE
      3  7829				   GetBoardCharacter__CALL_FROM_RAM__
    113  7829
    114  7829		       a4 8b		      ldy	POS_Y	;3
    115  782b
    116  782b		       a9 08		      lda	#BANK_GetBoardAddressR	;
    117  782d		       85 3f		      sta	SET_BANK	;
    118  782f		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    119  7832
    120  7832
      0  7832					      DEFINE_SUBROUTINE	PartialGetBoardCharacter	;=23
      1  7832		       00 0f	   BANK_PartialGetBoardCharacter =	_CURRENT_BANK
      2  7832					      SUBROUTINE
      3  7832				   PartialGetBoardCharacter
    122  7832
    123  7832
    124  7832		       85 3e		      sta	SET_BANK_RAM	;3
    125  7834		       a4 8a		      ldy	POS_X	;3
    126  7836		       b3 c0		      lax	(Board_AddressR),y	;5
    127  7838		       a4 c5		      ldy	RAM_Bank	;3
    128  783a		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    129  783c		       60		      rts		;6		 and go back
    130  783d
    131  783d							;---------------------------------------------------------------------------
    132  783d
      0  783d					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  783d		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  783d					      SUBROUTINE
      3  783d				   PutBoardCharacterFromRAM
    134  783d
    135  783d							; POS_Y  = row
    136  783d							; POS_Type = character to write
    137  783d							; POS_X     = column
    138  783d							; RAM_Bank = caller's bank
    139  783d
    140  783d		       a4 8b		      ldy	POS_Y	;3
    141  783f
    142  783f		       a9 08		      lda	#BANK_GetBoardAddressW	;
    143  7841		       85 3f		      sta	SET_BANK	;
    144  7843		       20 e8 f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
    145  7846
    146  7846		       86 3e		      stx	SET_BANK_RAM	;3
    147  7848
    148  7848		       a4 8a		      ldy	POS_X	;3
    149  784a		       a5 8e		      lda	POS_Type	;3
    150  784c		       91 c2		      sta	(Board_AddressW),y	;6
    151  784e		       a4 c5		      ldy	RAM_Bank	;3
    152  7850		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    153  7852		       60		      rts		;6
    154  7853
    155  7853
    156  7853							;---------------------------------------------------------------------------
    157  7853
      0  7853					      DEFINE_SUBROUTINE	ProcessObjStack	; 15 minimum segtime abort
      1  7853		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  7853					      SUBROUTINE
      3  7853				   ProcessObjStack
    159  7853
    160  7853		       ad 84 02 	      lda	INTIM	;4
    161  7856		       c9 04		      cmp	#MINIMUM_SEGTIME	;2
    162  7858		       90 3b		      bcc	EarlyAbort	;2/3= 8
      0  785a					      STRESS_TIME	MINIMUM_SEGTIME
      1  785a				  -	      IF	TEST_MINIMUM_SEGTIME = 1
      2  785a				  -
      3  785a				  -
      4  785a				  -
      5  785a				  -
      6  785a				  -
      7  785a				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  785a				  -	      bne	. - 7
      9  785a					      ENDIF
    164  785a
    165  785a		       a5 85		      lda	ObjStackNum	;3
    166  785c		       49 01		      eor	#1	;2
    167  785e		       aa		      tax		;2
    168  785f
    169  785f		       a5 cd		      lda	ObjIterator	;3
    170  7861		       d5 86		      cmp	ObjStackPtr,x	;5
    171  7863		       b0 2e		      bcs	nextPhase	;2/3
    172  7865
    173  7865
    174  7865							; Process an object...
    175  7865							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    176  7865
    177  7865		       bc b9 f9 	      ldy	BankObjStack,x	;4
    178  7868		       84 3e		      sty	SET_BANK_RAM	;3
    179  786a
    180  786a		       aa		      tax		;2
    181  786b		       bc 80 11 	      ldy	SortedObjPtr,x	;4		 indirect object pointer list (sorted)
    182  786e
    183  786e		       b9 00 10 	      lda	ObjStackX,y	;4
    184  7871		       85 8a		      sta	POS_X	;3
    185  7873		       b9 80 10 	      lda	ObjStackY,y	;4
    186  7876		       85 8b		      sta	POS_Y	;3
    187  7878		       b9 00 11 	      lda	ObjStackVar,y	;4
    188  787b		       85 8f		      sta	POS_VAR	;3
    189  787d		       be 00 12 	      ldx	ObjStackType,y	;4
    190  7880		       86 8e		      stx	POS_Type	;3
    191  7882
    192  7882		       a9 08		      lda	#BANK_VectorProcess	;2
    193  7884		       85 3f		      sta	SET_BANK	;3
    194  7886
    195  7886		       bd 27 f3 	      lda	OSPointerHI,x	;4
    196  7889		       85 db		      sta	POS_Vector+1	;3
    197  788b		       bd 24 f3 	      lda	OSPointerLO,x	;4
    198  788e		       85 da		      sta	POS_Vector	;3
    199  7890
    200  7890		       6c da 00 	      jmp	(POS_Vector)	;5 = 82	 vector to processor for particular object type
    201  7893
    202  7893
    203  7893							;---------------------------------------------------------------------------
    204  7893							; Now process the blank stack.  This stack holds all the recently blanked squares
    205  7893							; and determines (and moves) BOXs or TARGETs into these squares.  The space vacated
    206  7893							; by these objects are added again to the blank stack.
    207  7893
    208  7893				   nextPhase
    209  7893
    210  7893							;clc
    211  7893							;lda circle_d
    212  7893							;adc #255
    213  7893							;sta circle_d
    214  7893							;bcc nocirc
    215  7893
    216  7893
    217  7893
    218  7893				   nocirc
    219  7893
    220  7893		       e6 89		      inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    221  7895		       60	   EarlyAbort rts		;6
    222  7896
    223  7896							;---------------------------------------------------------------------------
    224  7896
      0  7896					      DEFINE_SUBROUTINE	SwitchObjects	;=72
      1  7896		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  7896					      SUBROUTINE
      3  7896				   SwitchObjects
    226  7896
    227  7896							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    228  7896							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    229  7896							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    230  7896
    231  7896		       ad 84 02 	      lda	INTIM	; 4
    232  7899		       c9 03		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    233  789b		       90 f8		      bcc	EarlyAbort	; 2/3= 8
      0  789d					      STRESS_TIME	SEGTIME_SWITCHOBJECTS
      1  789d				  -	      IF	TEST_SEGTIME_SWITCHOBJECTS = 1
      2  789d				  -
      3  789d				  -
      4  789d				  -
      5  789d				  -
      6  789d				  -
      7  789d				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  789d				  -	      bne	. - 7
      9  789d					      ENDIF
    235  789d
    236  789d							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    237  789d							; we're at the throttle cutoff do we switch game-frames.
    238  789d
    239  789d							;sec
    240  789d		       a5 b7		      lda	Throttle	;3
    241  789f		       e9 a0		      sbc	#MAX_THROTTLE	;2
    242  78a1		       90 f2		      bcc	EarlyAbort	;2/3		 plenty of time left!
    243  78a3
    244  78a3							; Time is up. But we may be in a level which requires perfect sorting
    245  78a3							; So we check for these levels, and wait for the sort to complete for those.
    246  78a3
    247  78a3		       24 b6		      bit	levelDisplay	;3
    248  78a5		       50 08		      bvc	keepFractional	;2/3		 screen does not require complete sort
    249  78a7
    250  78a7							; We have a level which requires the sort to go to completion
    251  78a7							; Check to see if the sort is finished...
    252  78a7
    253  78a7		       a4 cc		      ldy	sortPtr	;3
    254  78a9		       d0 ea		      bne	EarlyAbort	;2/3		 sort still in progress, so wait
    255  78ab		       a4 cb		      ldy	sortRequired	;3
    256  78ad		       10 e6		      bpl	EarlyAbort	;2/3		 sort still in progress, so wait
    257  78af
    258  78af		       85 b7	   keepFractional sta	Throttle	;3		 save fractional 'left over' bit
    259  78b1
    260  78b1							; Pause the game with B/W switch:
    261  78b1
    262  78b1		       a5 80		      lda	gameMode
    263  78b3		       30 14		      bmi	.paused	; pause flag set
    264  78b5
    265  78b5							; Now that we have completed processing the object stack, we switch
    266  78b5							; the stack bank pointers for the next time around.
    267  78b5
    268  78b5		       a5 85		      lda	ObjStackNum	;3
    269  78b7		       49 01		      eor	#1	;2
    270  78b9		       aa		      tax		;2
    271  78ba		       86 85		      stx	ObjStackNum	;3		 swap stacks @here
    272  78bc
    273  78bc							; STOP the sort so it doesn't corrupt the "other" object stack. Sort may get a look-in immediately after
    274  78bc							; this code is finished, so we don't want it to do something unexpected!
    275  78bc
    276  78bc		       a0 ff		      ldy	#<(-1)	;2
    277  78be		       84 cb		      sty	sortRequired	;3
    278  78c0		       c8		      iny		;2		 Y==0
    279  78c1		       84 cc		      sty	sortPtr	;3
    280  78c3
    281  78c3							; Initialise the iterator and stack pointer for next time around.
    282  78c3							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    283  78c3							; necessary to initialise both.
    284  78c3
    285  78c3		       84 cd		      sty	ObjIterator	;3		 Y==0
    286  78c5		       94 86		      sty	ObjStackPtr,x	;4
    287  78c7
    288  78c7		       84 89		      sty	ScreenDrawPhase	;3
    289  78c9				   .paused
    290  78c9		       60	   quickExit  rts		;6
    291  78ca
    292  78ca							;---------------------------------------------------------------------------
    293  78ca
      0  78ca					      DEFINE_SUBROUTINE	PROCESS_CIRCLE_DRAWER
      1  78ca		       00 0f	   BANK_PROCESS_CIRCLE_DRAWER =	_CURRENT_BANK
      2  78ca					      SUBROUTINE
      3  78ca				   PROCESS_CIRCLE_DRAWER
    295  78ca
    296  78ca		       a0 00		      ldy	#CHARACTER_BLANK
    297  78cc		       a5 ab		      lda	circle_d+1
    298  78ce							;jsr DrawCircle
    299  78ce							;bcc finCircle
    300  78ce							;lda #TYPE_CIRCLE_DRAWER
    301  78ce							;sta POS_Type
    302  78ce							;jsr InsertObjectStack
    303  78ce		       4c 7e f9    finCircle  jmp	NextObject
    304  78d1
      0  78d1					      DEFINE_SUBROUTINE	PROCESS_CIRCLE_HELPER
      1  78d1		       00 0f	   BANK_PROCESS_CIRCLE_HELPER =	_CURRENT_BANK
      2  78d1					      SUBROUTINE
      3  78d1				   PROCESS_CIRCLE_HELPER
    306  78d1
    307  78d1		       ad 84 02 	      lda	INTIM
    308  78d4		       c9 0a		      cmp	#SEGTIME_CIRCLE_HELPER
    309  78d6		       90 bd		      bcc	EarlyAbort
    310  78d8
    311  78d8
    312  78d8		       4c 7e f9 	      jmp	NextObject	; and die
    313  78db
    314  78db
      0  78db					      DEFINE_SUBROUTINE	PROCESS_CIRCLE
      1  78db		       00 0f	   BANK_PROCESS_CIRCLE =	_CURRENT_BANK
      2  78db					      SUBROUTINE
      3  78db				   PROCESS_CIRCLE
    316  78db
    317  78db		       ad 84 02 	      lda	INTIM
    318  78de		       c9 0a		      cmp	#SEGTIME_CIRCLE
    319  78e0		       90 b3		      bcc	EarlyAbort
    320  78e2
    321  78e2		       18		      clc
    322  78e3		       a5 aa		      lda	circle_d
    323  78e5		       69 ff		      adc	#255
    324  78e7		       85 aa		      sta	circle_d
    325  78e9		       90 34		      bcc	inactiveCircle
    326  78eb
    327  78eb		       e6 ab		      inc	circle_d+1
    328  78ed		       a5 ab		      lda	circle_d+1
    329  78ef		       c9 14		      cmp	#20
    330  78f1		       f0 33		      beq	circleComplete
    331  78f3							; time to fire off another "ring" of the clearing circle
    332  78f3
    333  78f3							;sta POS_VAR		    ; diameter for helper to use
    334  78f3							;lda #TYPE_CIRCLE_HELPER
    335  78f3							;sta POS_Type
    336  78f3							;jsr InsertObjectStack
    337  78f3
    338  78f3
    339  78f3							; a = radius
    340  78f3
    341  78f3		       a0 00		      ldy	#CHARACTER_BLANK
    342  78f5		       84 ae		      sty	circ_char
    343  78f7
    344  78f7		       a5 ab		      lda	circle_d+1
    345  78f9		       38		      sec
    346  78fa		       e9 01		      sbc	#1
    347  78fc		       85 ac		      sta	circ_x
    348  78fe		       49 ff		      eor	#255
    349  7900		       18		      clc
    350  7901		       69 01		      adc	#1
    351  7903		       85 af		      sta	circ_scratch	; "d" --> "1-r" in unit terms
    352  7905
    353  7905		       a9 00		      lda	#0
    354  7907		       85 ad		      sta	circ_y
    355  7909
    356  7909							;lda circle_d+1		     ; radius
    357  7909							;lda #TYPE_CIRCLE_DRAWER
    358  7909							;sta POS_Type
    359  7909							;jsr InsertObjectStack
    360  7909
    361  7909		       a0 00		      ldy	#CHARACTER_BLANK
    362  790b		       a5 ab		      lda	circle_d+1
    363  790d							;	      sec
    364  790d							;	      sbc #1
    365  790d		       20 5f fe 	      jsr	DrawCircle
    366  7910
    367  7910							;	      ldy #CHARACTER_STEEL
    368  7910							;		sty circ_char
    369  7910		       a5 ab		      lda	circle_d+1
    370  7912		       85 ac		      sta	circ_x
    371  7914		       49 ff		      eor	#255
    372  7916		       18		      clc
    373  7917		       69 01		      adc	#1
    374  7919		       85 af		      sta	circ_scratch	; "d" --> "1-r" in unit terms
    375  791b
    376  791b		       a9 00		      lda	#0
    377  791d		       85 ad		      sta	circ_y
    378  791f
    379  791f							;lda circle_d+1		     ; radius
    380  791f							;lda #TYPE_CIRCLE_DRAWER
    381  791f							;sta POS_Type
    382  791f							;jsr InsertObjectStack
    383  791f
    384  791f							;	      ldy #CHARACTER_BLANK
    385  791f							;	      lda circle_d+1
    386  791f							;	      ;jsr DrawCircle
    387  791f
    388  791f
    389  791f
    390  791f							;			      inc circle_d+1
    391  791f							;			      ldy #CHARACTER_STEEL
    392  791f							;			      lda circle_d+1
    393  791f							;			      jsr DrawCircle
    394  791f
    395  791f		       a9 01	   inactiveCircle lda	#TYPE_CIRCLE
    396  7921		       85 8e		      sta	POS_Type
    397  7923		       20 8b f9 	      jsr	InsertObjectStack
    398  7926
    399  7926		       4c 7e f9    circleComplete jmp	NextObject
    400  7929
    401  7929							;---------------------------------------------------------------------------
    402  7929
    403  7929		       60	   EarlyAbort4 rts
    404  792a
      0  792a					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  792a		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  792a					      SUBROUTINE
      3  792a				   PROCESS_MAN
    406  792a
    407  792a		       ad 84 02 	      lda	INTIM
    408  792d		       c9 18		      cmp	#SEGTIME_MAN
    409  792f		       90 f8		      bcc	EarlyAbort4
      0  7931					      STRESS_TIME	SEGTIME_MAN
      1  7931				  -	      IF	TEST_SEGTIME_MAN = 1
      2  7931				  -
      3  7931				  -
      4  7931				  -
      5  7931				  -
      6  7931				  -
      7  7931				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7931				  -	      bne	. - 7
      9  7931					      ENDIF
    411  7931
    412  7931		       a9 08		      lda	#BANK_ManProcess
    413  7933		       85 c4		      sta	ROM_Bank
    414  7935		       85 3f		      sta	SET_BANK
    415  7937		       20 85 f1 	      jsr	ManProcess
    416  793a
    417  793a		       20 bb f9 	      jsr	MovePlayer	; 6+{}
    418  793d
    419  793d		       a5 9f		      lda	ManMode
    420  793f		       c9 07		      cmp	#MANMODE_NEXTLEVEL	; kludge
    421  7941		       b0 08		      bcs	notComplete
    422  7943		       a5 b9		      lda	targetsRequired
    423  7945		       d0 04		      bne	notComplete
    424  7947		       a9 07		      lda	#MANMODE_NEXTLEVEL
    425  7949		       85 9f		      sta	ManMode
    426  794b				   notComplete
    427  794b
    428  794b
    429  794b		       a9 03		      lda	#BANK_TrackPlayer	;
    430  794d		       85 3f		      sta	SET_BANK	;
    431  794f		       20 35 f4 	      jsr	TrackPlayer	;11+145
    432  7952
    433  7952		       a9 00		      lda	#TYPE_MAN	; 2
    434  7954		       85 8e		      sta	POS_Type	; 3
    435  7956
    436  7956		       20 8b f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    437  7959		       4c 7e f9    gnobj      jmp	NextObject
    438  795c
    439  795c							;---------------------------------------------------------------------------
    440  795c
      0  795c					      DEFINE_SUBROUTINE	RestoreOriginalCharacter	;=93[-2](A)
      1  795c		       00 0f	   BANK_RestoreOriginalCharacter =	_CURRENT_BANK
      2  795c					      SUBROUTINE
      3  795c				   RestoreOriginalCharacter
    442  795c
    443  795c		       a6 8b		      ldx	POS_Y	;3
    444  795e		       a4 8a		      ldy	POS_X	;3
    445  7960
    446  7960		       a9 08		      lda	#BANK_BoardLineStartLO	;2
    447  7962		       85 3f		      sta	SET_BANK	;3
    448  7964
    449  7964		       bd 01 f0 	      lda	BoardLineStartLO,x	;4
    450  7967		       85 c2		      sta	Board_AddressW	;3
    451  7969		       bd 2d f0 	      lda	BoardLineStartHiW,x	;4
    452  796c		       85 c3		      sta	Board_AddressW+1	;3 WRITE address
    453  796e				  -	      IF	MULTI_BANK_BOARD = YES
    454  796e				  -	      lda	BoardBank,x	;4 switch this on return
    455  796e					      ELSE
    456  796e		       a9 0d		      lda	#BANK_BOARD	;2
    457  7970					      ENDIF
    458  7970		       85 3e		      sta	SET_BANK_RAM	;3
    459  7972
    460  7972		       a5 8f		      lda	POS_VAR
    461  7974		       91 c2		      sta	(Board_AddressW),y	;6 clear vacated board position
    462  7976
    463  7976		       a5 c4		      lda	ROM_Bank	;3
    464  7978		       85 3f		      sta	SET_BANK	;3
    465  797a		       60	   EarlyAbortBOX rts		;6
    466  797b
    467  797b
    468  797b							;---------------------------------------------------------------------------
    469  797b
    470  797b							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    471  797b							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    472  797b
    473  797b							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    474  797b
    475  797b							; if the creature dies then jump NextObject
    476  797b
    477  797b
    478  797b		       20 8b f9    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    479  797e
    480  797e		       e6 cd	   NextObject inc	ObjIterator	; 5
    481  7980							;		  dec ObjStackPtr,x		  ; 6
    482  7980		       4c 53 f8 	      jmp	ProcessObjStack	; 3 = 16
    483  7983
    484  7983							;---------------------------------------------------------------------------
    485  7983
      0  7983					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  7983		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  7983					      SUBROUTINE
      3  7983				   InsertObjectStackFromRAM
    487  7983
    488  7983		       20 8b f9 	      jsr	InsertObjectStack	;6+76(B)
    489  7986		       a5 c5		      lda	RAM_Bank	;3
    490  7988		       85 3e		      sta	SET_BANK_RAM	;3
    491  798a
    492  798a		       60	   NotEnoughTime rts		;6
    493  798b
    494  798b							;---------------------------------------------------------------------------
    495  798b
      0  798b					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  798b		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  798b					      SUBROUTINE
      3  798b				   InsertObjectStack
    497  798b							; POS_X     x position
    498  798b							; POS_Y     y position
    499  798b							; POS_VAR   direction or other variable
    500  798b							; POS_Type  type of object
    501  798b
    502  798b		       a6 85		      ldx	ObjStackNum	; 3
    503  798d		       bc b9 f9 	      ldy	BankObjStack,x	; 4
    504  7990		       84 3e		      sty	SET_BANK_RAM	; 3
    505  7992		       b4 86		      ldy	ObjStackPtr,x	; 4 = 14
    506  7994
    507  7994
    508  7994		       a5 8b		      lda	POS_Y	; 3
    509  7996		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    510  7999		       a5 8a		      lda	POS_X	; 3
    511  799b		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    512  799e		       a5 8f		      lda	POS_VAR	; 3
    513  79a0		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    514  79a3		       a5 8e		      lda	POS_Type	; 3
    515  79a5		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    516  79a8
    517  79a8							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    518  79a8							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    519  79a8							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    520  79a8
    521  79a8
    522  79a8				  -	      IF	TYPE_MAN != 0
    523  79a8				  -	      cmp	#TYPE_MAN	; 2
    524  79a8					      ENDIF
    525  79a8		       f0 04		      beq	alwaysAllowMan	; 2/3
    526  79aa
    527  79aa		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    528  79ac		       b0 06		      bcs	insertDone	; 2/3= 6    no room -- drop object
    529  79ae				   alwaysAllowMan
    530  79ae
    531  79ae		       98		      tya		; 2
    532  79af		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    533  79b2
    534  79b2		       f6 86		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    535  79b4
    536  79b4		       a4 c4	   insertDone ldy	ROM_Bank	; 3
    537  79b6		       84 3f		      sty	SET_BANK	; 3
    538  79b8
    539  79b8				   ManIsDead2
    540  79b8
    541  79b8
    542  79b8
    543  79b8		       60		      rts		; 6 = 29
    544  79b9
    545  79b9							;---------------------------------------------------------------------------
    546  79b9
    547  79b9		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    548  79bb
    549  79bb							;---------------------------------------------------------------------------
    550  79bb
    551  79bb				   MovePlayer
    552  79bb		       a5 9f		      lda	ManMode
    553  79bd		       c9 02		      cmp	#MANMODE_DEAD
    554  79bf		       b0 f7		      bcs	ManIsDead2
    555  79c1
    556  79c1		       a4 8d		      ldy	POS_Y_NEW
    557  79c3
    558  79c3		       a9 08		      lda	#BANK_GetBoardAddressRW	;2
    559  79c5		       85 3f		      sta	SET_BANK	;3
    560  79c7		       85 c4		      sta	ROM_Bank	;3
    561  79c9		       20 c8 f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    562  79cc				  -	      IF	MULTI_BANK_BOARD = YES
    563  79cc				  -	      stx	RAM_Bank
    564  79cc					      ENDIF
    565  79cc		       86 3e		      stx	SET_BANK_RAM	; 3
    566  79ce
    567  79ce		       a4 8c		      ldy	POS_X_NEW
    568  79d0		       b3 c0		      lax	(Board_AddressR),y
    569  79d2
    570  79d2		       a9 08		      lda	#BANK_MoveVecLO
    571  79d4		       85 3f		      sta	SET_BANK
    572  79d6
    573  79d6		       bd 2a f3 	      lda	MoveVecLO,x
    574  79d9		       85 da		      sta	MAN_Move
    575  79db		       bd 34 f3 	      lda	MoveVecHI,x
    576  79de		       85 db		      sta	MAN_Move+1
    577  79e0
    578  79e0				  -	      IF	MULTI_BANK_BOARD = YES
    579  79e0				  -	      lda	RAM_Bank
    580  79e0					      ELSE
    581  79e0		       a9 0d		      lda	#BANK_BOARD
    582  79e2					      ENDIF
    583  79e2		       85 3e		      sta	SET_BANK_RAM
    584  79e4		       6c da 00 	      jmp	(MAN_Move)
    585  79e7
    586  79e7							;---------------------------------------------------------------------------
    587  79e7
      0  79e7					      DEFINE_SUBROUTINE	MOVE_BLANK
      1  79e7		       00 0f	   BANK_MOVE_BLANK =	_CURRENT_BANK
      2  79e7					      SUBROUTINE
      3  79e7				   MOVE_BLANK
      0  79e7					      DEFINE_SUBROUTINE	MOVE_SOIL
      1  79e7		       00 0f	   BANK_MOVE_SOIL =	_CURRENT_BANK
      2  79e7					      SUBROUTINE
      3  79e7				   MOVE_SOIL
      0  79e7					      DEFINE_SUBROUTINE	MOVE_TARGET
      1  79e7		       00 0f	   BANK_MOVE_TARGET =	_CURRENT_BANK
      2  79e7					      SUBROUTINE
      3  79e7				   MOVE_TARGET
    591  79e7
    592  79e7		       a4 8c		      ldy	POS_X_NEW
    593  79e9		       b1 c0		      lda	(Board_AddressR),y	; what's on the board under man?
    594  79eb		       48		      pha
    595  79ec
    596  79ec		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    597  79ee		       91 c2		      sta	(Board_AddressW),y
    598  79f0
    599  79f0		       a6 9c		      ldx	ManY
    600  79f2		       86 8b		      stx	POS_Y
    601  79f4		       a4 9b		      ldy	ManX
    602  79f6		       84 8a		      sty	POS_X
    603  79f8
    604  79f8		       20 5c f9 	      jsr	RestoreOriginalCharacter
    605  79fb
    606  79fb		       68		      pla
    607  79fc		       85 8f		      sta	POS_VAR	; save 'restore' characte
    608  79fe
    609  79fe		       a9 0e		      lda	#BANK_TAKEBACK
    610  7a00		       85 3e		      sta	SET_BANK_RAM
    611  7a02
    612  7a02		       a6 bc		      ldx	moveCounterBinary
    613  7a04
    614  7a04		       a5 8c		      lda	POS_X_NEW
    615  7a06		       85 9b		      sta	ManX
    616  7a08		       9d 00 14 	      sta	RAM_WRITE+TakeBackX,x
    617  7a0b
    618  7a0b		       a5 8d		      lda	POS_Y_NEW
    619  7a0d		       85 9c		      sta	ManY	; actually MOVE!
    620  7a0f		       9d 00 15 	      sta	RAM_WRITE+TakeBackY,x
    621  7a12
    622  7a12		       a5 8f		      lda	POS_VAR	; replace char
    623  7a14		       9d 00 16 	      sta	RAM_WRITE+TakeBackA,x
    624  7a17
    625  7a17		       a5 c5		      lda	RAM_Bank
    626  7a19		       85 3e		      sta	SET_BANK_RAM
    627  7a1b
    628  7a1b							; Move counter..
    629  7a1b
    630  7a1b		       e6 bc		      inc	moveCounterBinary
    631  7a1d
    632  7a1d		       f8		      sed
    633  7a1e		       18		      clc
    634  7a1f		       a5 ba		      lda	moveCounter
    635  7a21		       69 01		      adc	#1
    636  7a23		       85 ba		      sta	moveCounter
    637  7a25		       a5 bb		      lda	moveCounter+1
    638  7a27		       69 00		      adc	#0
    639  7a29		       85 bb		      sta	moveCounter+1
    640  7a2b		       d8		      cld
    641  7a2c
    642  7a2c		       a9 00	   MOVE_GENERIC lda	#0	; 2
    643  7a2e		       85 a5		      sta	ManPushCounter	; 3
    644  7a30
    645  7a30		       60	   timeExit   rts		; 6 = 11
    646  7a31
    647  7a31							;---------------------------------------------------------------------------
    648  7a31
      0  7a31					      DEFINE_SUBROUTINE	MOVE_BOX
      1  7a31		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  7a31					      SUBROUTINE
      3  7a31				   MOVE_BOX
    650  7a31
    651  7a31		       a2 00		      ldx	#CHARACTER_BLANK	; restoration character
    652  7a33		       a9 08		      lda	#BANK_PushBox
    653  7a35		       85 c4		      sta	ROM_Bank
    654  7a37		       85 3f		      sta	SET_BANK
    655  7a39		       4c f5 f0 	      jmp	PushBox
    656  7a3c
      0  7a3c					      DEFINE_SUBROUTINE	MOVE_BOX_ON_TARGET
      1  7a3c		       00 0f	   BANK_MOVE_BOX_ON_TARGET =	_CURRENT_BANK
      2  7a3c					      SUBROUTINE
      3  7a3c				   MOVE_BOX_ON_TARGET
    658  7a3c
    659  7a3c		       a2 03		      ldx	#CHARACTER_TARGET	; restoration character
    660  7a3e		       a9 08		      lda	#BANK_PushBox
    661  7a40		       85 c4		      sta	ROM_Bank
    662  7a42		       85 3f		      sta	SET_BANK
    663  7a44		       4c f5 f0 	      jmp	PushBox
    664  7a47
    665  7a47							;---------------------------------------------------------------------------
    666  7a47
      0  7a47					      DEFINE_SUBROUTINE	restorePreviousManPosition
      1  7a47		       00 0f	   BANK_restorePreviousManPosition =	_CURRENT_BANK
      2  7a47					      SUBROUTINE
      3  7a47				   restorePreviousManPosition
    668  7a47
    669  7a47		       a6 bc		      ldx	moveCounterBinary
    670  7a49		       f0 21		      beq	noMovesToTake
    671  7a4b		       ca		      dex
    672  7a4c		       c6 bc		      dec	moveCounterBinary
    673  7a4e
    674  7a4e		       a9 0e		      lda	#BANK_TAKEBACK
    675  7a50		       85 3e		      sta	SET_BANK_RAM
    676  7a52
    677  7a52		       bd 00 10 	      lda	TakeBackX,x
    678  7a55		       85 8a		      sta	POS_X
    679  7a57		       85 8c		      sta	POS_X_NEW
    680  7a59		       bd 00 11 	      lda	TakeBackY,x
    681  7a5c		       85 8b		      sta	POS_Y
    682  7a5e		       85 8d		      sta	POS_Y_NEW
    683  7a60		       bd 00 12 	      lda	TakeBackA,x
    684  7a63		       85 8f		      sta	POS_VAR
    685  7a65
    686  7a65							; Put character @ X,Y
    687  7a65		       20 5c f9 	      jsr	RestoreOriginalCharacter
    688  7a68
    689  7a68		       a5 c4		      lda	ROM_Bank
    690  7a6a		       85 3f		      sta	SET_BANK
    691  7a6c
    692  7a6c		       60	   noMovesToTake rts
    693  7a6d
    694  7a6d							;---------------------------------------------------------------------------
    695  7a6d
      0  7a6d					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7a6d		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7a6d					      SUBROUTINE
      3  7a6d				   StealCharDraw
    697  7a6d
    698  7a6d		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    699  7a6f		       85 3e		      sta	SET_BANK_RAM	; 3
    700  7a71		       a4 84		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    701  7a73		       10 35		      bpl	EnterStealCharDraw	; 3 = 10(11)
    702  7a75
    703  7a75				   ExitStealCharDraw
    704  7a75
    705  7a75							; fall through...
    706  7a75
    707  7a75							;---------------------------------------------------------------------------
    708  7a75
      0  7a75					      DEFINE_SUBROUTINE	TimeSlice
      1  7a75		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7a75					      SUBROUTINE
      3  7a75				   TimeSlice
    710  7a75
    711  7a75							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    712  7a75							; going ahead if there's insufficient time. This allows the previous character drawing to
    713  7a75							; be much smaller in time, as they don't have to include the timeslice code overhead.
    714  7a75
    715  7a75		       ad 84 02 	      lda	INTIM	; 4
    716  7a78		       c9 05		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    717  7a7a		       90 b4		      bcc	timeExit	; 2(3)
    718  7a7c
    719  7a7c							; Uses the phase variable to vector to the correct processing code for the given timeslice
    720  7a7c							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    721  7a7c							; it should increment ScreenDrawPhase.
    722  7a7c
    723  7a7c							; Switched-in bank(s) are undefined after this function is called!
    724  7a7c
    725  7a7c		       a9 03		      lda	#BANK_TS_PhaseVectorLO	; 2
    726  7a7e		       85 3f		      sta	SET_BANK	; 3
    727  7a80
    728  7a80		       a6 89		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    729  7a82		       bd bc f4 	      lda	TS_PhaseVectorLO,x	; 4
    730  7a85		       85 da		      sta	TS_Vector	; 3
    731  7a87		       bd c1 f4 	      lda	TS_PhaseVectorHI,x	; 4
    732  7a8a		       85 db		      sta	TS_Vector+1	; 3
    733  7a8c
    734  7a8c		       bd c6 f4 	      lda	TS_PhaseBank,x	; 4
    735  7a8f		       85 3f		      sta	SET_BANK	; 3		 switch bank
    736  7a91
    737  7a91		       6c da 00 	      jmp	(TS_Vector)	; 3 = 40	 vector to timeslice handler
    738  7a94
    739  7a94							; = 55 minimum return time (if segtime abort)
    740  7a94
    741  7a94							;---------------------------------------------------------------------------
    742  7a94
    743  7a94
    744  7a94				   DrawAnother
    745  7a94
    746  7a94		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    747  7a96		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    748  7a98
    749  7a98		       a4 84		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    750  7a9a
    751  7a9a		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    752  7a9d		       bd a0 f0 	      lda	ScreenBuffer,x	; 4	     new character to draw
    753  7aa0		       29 7f		      and	#~128	; 2
    754  7aa2		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    755  7aa5
    756  7aa5		       88		      dey		; 2
    757  7aa6		       84 84		      sty	DrawStackPointer	; 3	     one less to draw
    758  7aa8		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7
    759  7aaa
    760  7aaa				   EnterStealCharDraw		;	     RAM bank MUST be at BANK_DRAW_BUFFERS
    761  7aaa
    762  7aaa		       ad 84 02 	      lda	INTIM	; 4
    763  7aad		       c9 05		      cmp	#SEGTIME_SCD_MIN	; 2
    764  7aaf		       90 c4		      bcc	ExitStealCharDraw	; 2/3= 8
    765  7ab1
    766  7ab1		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    767  7ab4		       bc a0 f0 	      ldy	ScreenBuffer,x	; 4 =	8    new character to draw
    768  7ab7
    769  7ab7		       bd 00 f2 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
    770  7aba		       85 3e		      sta	SET_BANK_RAM	; 3
    771  7abc		       4c 53 f1 	      jmp	StealPart3	; 3 = 10    --> 18 cycles after check for SEGTIME_SCD_MIN
    772  7abf
    773  7abf
    774  7abf
    775  7abf
      0  7abf					      DEFINE_SUBROUTINE	DrawFullScreenMain	;=2484[-89]
      1  7abf		       00 0f	   BANK_DrawFullScreenMain =	_CURRENT_BANK
      2  7abf					      SUBROUTINE
      3  7abf				   DrawFullScreenMain
    777  7abf
    778  7abf							; Check the screen for all those characters that need to be redrawn
    779  7abf							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
    780  7abf							; the drawflags array is different to the ScreenBuffer array entry, then the
    781  7abf							; screenbuffer will need redrawing.
    782  7abf
    783  7abf				   CopyRow2
    784  7abf
    785  7abf				  -	      IF	MULTI_BANK_BOARD = YES
    786  7abf				  -	      lda	BDF_BoardBank	; 3
    787  7abf					      ELSE
    788  7abf		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
    789  7ac1					      ENDIF
    790  7ac1		       85 3e		      sta	SET_BANK_RAM	; 3
    791  7ac3		       b3 de		      lax	(BDF_BoardAddress),y	; 5
    792  7ac5		       9a		      txs		; 2
    793  7ac6		       b3 e0		      lax	(BDF_BoardAddress2),y	; 5(= 18[-1])
    794  7ac8
    795  7ac8		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    796  7aca		       85 3e		      sta	SET_BANK_RAM	; 3
    797  7acc		       bd d1 f1 	      lda	CharReplacement,x	; 4
    798  7acf		       91 dc		      sta	(BDF_DrawFlagAddress2),y	; 6
    799  7ad1		       ba		      tsx		; 2
    800  7ad2		       bd d1 f1 	      lda	CharReplacement,x	; 4
    801  7ad5		       91 da		      sta	(BDF_DrawFlagAddress),y	; 6(= 27)
    802  7ad7
    803  7ad7		       88		      dey		; 2
    804  7ad8		       10 e5		      bpl	CopyRow2	; 2/3=49/50[-1]
    805  7ada							; total: 5*49[-1]-1 = 244[-5]
    806  7ada
    807  7ada		       a7 e3		      lax	DHS_Line	; 3
    808  7adc		       f0 07		      beq	.exitCopy	; 2/3= 5/6
    809  7ade
    810  7ade		       a0 08		      ldy	#BANK_DrawScreenRowPreparation	;2
    811  7ae0		       84 3f		      sty	SET_BANK	; 3
    812  7ae2		       4c f1 f2 	      jmp	DrawScreenRowPreparation	;55[-7] = 60[-7]
    813  7ae5
    814  7ae5							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
    815  7ae5
    816  7ae5
      0  7ae5					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7ae5					      LIST	ON
    818  7ae5
    819  7ae5		       a6 e4	   .exitCopy  ldx	DHS_Stack	; 3
    820  7ae7		       9a		      txs		; 2
    821  7ae8
    822  7ae8							; fall through
    823  7ae8
      0  7ae8					      DEFINE_SUBROUTINE	BuildDrawStack
      1  7ae8		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7ae8					      SUBROUTINE
      3  7ae8				   BuildDrawStack
    825  7ae8
    826  7ae8		       a9 08		      lda	#BANK_DRAW_BUFFERS
    827  7aea		       85 3e		      sta	SET_BANK_RAM
    828  7aec		       4c f1 f0 	      jmp	DrawStackUpdate
    829  7aef
    830  7aef							;---------------------------------------------------------------------------
    831  7aef
      0  7aef					      DEFINE_SUBROUTINE	DrawAIntoStack
      1  7aef		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7aef					      SUBROUTINE
      3  7aef				   DrawAIntoStack
    833  7aef
    834  7aef		       a9 08		      lda	#BANK_DRAW_BUFFERS
    835  7af1		       85 3e		      sta	SET_BANK_RAM
    836  7af3		       4c 1c f1 	      jmp	DrawIntoStack
    837  7af6
    838  7af6
    839  7af6							;---------------------------------------------------------------------------
    840  7af6
    841  7af6
    842  7af6				   Reset
      0  7af6					      CLEAN_START
      1  7af6		       78		      sei
      2  7af7		       d8		      cld
      3  7af8
      4  7af8		       a2 00		      ldx	#0
      5  7afa		       8a		      txa
      6  7afb		       a8		      tay
      7  7afc		       ca	   .CLEAR_STACK dex
      8  7afd		       9a		      txs
      9  7afe		       48		      pha
     10  7aff		       d0 fb		      bne	.CLEAR_STACK
     11  7b01
    844  7b01
    845  7b01							; Scoring bank is copied once (not per game, not per level...)
    846  7b01							; otherwise non-SaveKey high score gets zapped
    847  7b01
    848  7b01		       a2 02		      ldx	#ROM_SHADOW_OF_BANK_SCORING
    849  7b03		       a0 09		      ldy	#BANK_SCORING
    850  7b05		       20 32 fd 	      jsr	CopyROM2RAM_F000
    851  7b08
    852  7b08				   Restart		; go here on RESET + SELECT
    853  7b08
    854  7b08
    855  7b08				   Title
    856  7b08		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
    857  7b0a		       9a		      txs
    858  7b0b
    859  7b0b							; temporary vars from title screen are used to init level
    860  7b0b		       a9 03		      lda	#BANK_Cart_Init	; 2
    861  7b0d		       85 3f		      sta	SET_BANK	; 3
    862  7b0f		       20 40 f3 	      jsr	Cart_Init	; 6+x
    863  7b12
    864  7b12
    865  7b12							;---------------------------------------------------------------------------
    866  7b12
    867  7b12
    868  7b12		       f0 00	   SEGMENT_DECODE_LEVEL_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
    869  7b12
    870  7b12		       a2 03		      ldx	#BANK_DECODE_LEVEL_SHADOW
    871  7b14		       a0 0a		      ldy	#BANK_DECODE_LEVEL
    872  7b16		       20 32 fd 	      jsr	CopyROM2RAM_F000
    873  7b19
    874  7b19
    875  7b19							;---------------------------------------------------------------------------
    876  7b19							; Once-only game initialisation goes here...
    877  7b19							; now we have two players so things get a bit tricky
    878  7b19
    879  7b19		       a9 09		      lda	#BANK_SCORING
    880  7b1b		       85 3e		      sta	SET_BANK_RAM
    881  7b1d		       20 82 f3 	      jsr	GameInitialise
    882  7b20
    883  7b20
    884  7b20							;---------------------------------------------------------------------------
    885  7b20
    886  7b20				   RestartLevelNextPlayer
    887  7b20
    888  7b20
    889  7b20							; a player has lost a life.
    890  7b20							; store his vars, swap to other player, continue
    891  7b20
    892  7b20							;lda #BANK_SCORING
    893  7b20							;sta SET_BANK_RAM
    894  7b20							;jsr SwapPlayers
    895  7b20
    896  7b20		       a9 03		      lda	#BANK_SwapPlayersGeneric
    897  7b22		       85 3f		      sta	SET_BANK
    898  7b24		       20 97 f3 	      jsr	SwapPlayersGeneric
    899  7b27
    900  7b27				   NextLevelLevel
    901  7b27				   skipDemoCheck
    902  7b27
    903  7b27							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
    904  7b27							; including those for general systems function. But NOT those which do not need re-initialising between
    905  7b27							; levels.
    906  7b27		       a9 03		      lda	#BANK_LevelInit	; 2
    907  7b29		       85 3f		      sta	SET_BANK	; 3
    908  7b2b		       20 e6 f3 	      jsr	LevelInit	; 6+x
    909  7b2e
    910  7b2e		       a9 00		      lda	#0
    911  7b30		       85 da		      sta	base_x
    912  7b32		       85 db		      sta	base_y
    913  7b34
    914  7b34		       a9 0a		      lda	#BANK_DECODE_LEVEL
    915  7b36		       85 3e		      sta	SET_BANK_RAM
    916  7b38		       20 c3 f1 	      jsr	UnpackLevel
    917  7b3b
    918  7b3b							; TODO now we KNOW the width, we can set the top left accordingly and re-unpack
    919  7b3b
    920  7b3b		       a9 28		      lda	#SIZE_BOARD_X
    921  7b3d		       85 94		      sta	BoardLimit_Width
    922  7b3f		       a9 16		      lda	#SIZE_BOARD_Y
    923  7b41		       85 95		      sta	BoardLimit_Height
    924  7b43
    925  7b43							; Setup player animation and scroll limits.
    926  7b43							; Mangle the board colours based on level
    927  7b43
    928  7b43		       a9 03		      lda	#BANK_CreateCreatures	; 2
    929  7b45		       85 3f		      sta	SET_BANK	; 3
    930  7b47		       20 af f3 	      jsr	CreateCreatures	; 6+x
    931  7b4a
    932  7b4a
    933  7b4a							; Setup the various digit and display pointers
    934  7b4a							; Grab current player's score/level from backup
    935  7b4a
    936  7b4a		       20 26 fd 	      jsr	goGeneralScoringSetups
    937  7b4d
    938  7b4d							; copy the screen draw ROM shadow to RAM
    939  7b4d
    940  7b4d		       a0 07		      ldy	#SCREEN_LINES-1
    941  7b4f		       a2 00	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
    942  7b51		       20 32 fd 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
    943  7b54		       20 77 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
    944  7b57		       88		      dey
    945  7b58		       10 f5		      bpl	CopyScreenBanks
    946  7b5a
    947  7b5a		       a2 01		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    948  7b5c		       a0 08		      ldy	#BANK_DRAW_BUFFERS
    949  7b5e		       20 43 f0 	      jsr	CopyROMShadowToRAM_F000
    950  7b61
    951  7b61							;---------------------------------------------------------------------------
    952  7b61
    953  7b61		       a9 03		      lda	#BANK_Resync	; 2
    954  7b63		       85 3f		      sta	SET_BANK	; 3
    955  7b65		       20 11 f4 	      jsr	Resync	; 6+x
    956  7b68
------- FILE sound/intro1_init.asm LEVEL 3 PASS 3
      0  7b68					      include	"sound/intro1_init.asm"
      1  7b68							; TIATracker music player
      2  7b68							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7b68							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7b68							; Email: andre.wichmann@gmx.de
      5  7b68							;
      6  7b68							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7b68							; you may not use this file except in compliance with the License.
      8  7b68							; You may obtain a copy of the License at
      9  7b68							;
     10  7b68							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7b68							;
     12  7b68							; Unless required by applicable law or agreed to in writing, software
     13  7b68							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7b68							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7b68							; See the License for the specific language governing permissions and
     16  7b68							; limitations under the License.
     17  7b68
     18  7b68							; Song author: 
     19  7b68							; Song name: 
     20  7b68
     21  7b68							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7b68
     23  7b68							; =====================================================================
     24  7b68							; Initialize music.
     25  7b68							; Set tt_cur_pat_index_c0/1 to the indexes of the first patterns from
     26  7b68							; tt_SequenceTable for each channel.
     27  7b68							; Set tt_timer and tt_cur_note_index_c0/1 to 0.
     28  7b68							; All other variables can start with any value.
     29  7b68							; =====================================================================
     30  7b68		       a9 00		      lda	#0
     31  7b6a		       85 d0		      sta	tt_cur_pat_index_c0
     32  7b6c		       a9 05		      lda	#5
     33  7b6e		       85 d1		      sta	tt_cur_pat_index_c1
     34  7b70							; the rest should be 0 already from startup code. If not,
     35  7b70							; set the following variables to 0 manually:
     36  7b70							; - tt_timer
     37  7b70							; - tt_cur_pat_index_c0
     38  7b70							; - tt_cur_pat_index_c1
     39  7b70							; - tt_cur_note_index_c0
     40  7b70							; - tt_cur_note_index_c1
     41  7b70
------- FILE BANK_FIXED.asm
    958  7b70
    959  7b70				   NewFrameStart
    960  7b70
    961  7b70		       24 ca		      bit	NextLevelTrigger
    962  7b72		       10 b3		      bpl	NextLevelLevel	; game-triggered next level
    963  7b74		       70 aa		      bvs	RestartLevelNextPlayer	; loss of life
    964  7b76
    965  7b76							; Note: VSYNC must NOT be on when starting a new level! Else you get annoying TV signals.
    966  7b76
    967  7b76		       a9 0e		      lda	#%1110	; VSYNC ON
    968  7b78		       85 42	   .loopVSync sta	WSYNC
    969  7b7a		       85 40		      sta	VSYNC
    970  7b7c		       4a		      lsr
    971  7b7d		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
    972  7b7f
    973  7b7f							; moved *after* the loop since this allows to *increase* timer values by 1!
    974  7b7f
    975  7b7f		       a6 81		      ldx	Platform
    976  7b81		       bc a5 fc 	      ldy	VBlankTime,x
    977  7b84		       8c 96 02 	      sty	TIM64T
    978  7b87
    979  7b87
------- FILE sound/intro1_player.asm LEVEL 3 PASS 3
      0  7b87					      include	"sound/intro1_player.asm"
      1  7b87							; TIATracker music player
      2  7b87							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7b87							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7b87							; Email: andre.wichmann@gmx.de
      5  7b87							;
      6  7b87							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7b87							; you may not use this file except in compliance with the License.
      8  7b87							; You may obtain a copy of the License at
      9  7b87							;
     10  7b87							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7b87							;
     12  7b87							; Unless required by applicable law or agreed to in writing, software
     13  7b87							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7b87							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7b87							; See the License for the specific language governing permissions and
     16  7b87							; limitations under the License.
     17  7b87
     18  7b87							; Song author: 
     19  7b87							; Song name: 
     20  7b87
     21  7b87							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7b87
     23  7b87							; =====================================================================
     24  7b87							; TIATracker Player
     25  7b87							; =====================================================================
     26  7b87				   tt_PlayerStart
     27  7b87
     28  7b87							; PLANNED PLAYER VARIANTS:
     29  7b87							; - RAM, speed, player ROM: c0/c1 patterns have same length
     30  7b87							; - RAM: Pack 2 values (out of cur_pat_index, cur_note_index, envelope_index)
     31  7b87							;	 into one and use lsr/asl to unpack them, allowing only ranges of
     32  7b87							;	 16/16 or 32/8 for them, depending on number of patterns, max
     33  7b87							;	 pattern size and max ADSR size
     34  7b87							; - ROM: Check if tt_SequenceTable can hold ptrs directly without indexing
     35  7b87							;	 tt_PatternPtrLo/Hi. Can be smaller if not many patterns get repeated
     36  7b87							;	 (saves table and decode routine)
     37  7b87							; - Speed: Inline tt_CalcInsIndex
     38  7b87							; - Speed: Store ptr to current note in RAM instead of reconstructing it?
     39  7b87							;	 Might also save the need for cur_note_index
     40  7b87
     41  7b87
     42  7b87							; ---------------------------------------------------------------------
     43  7b87							; Helper macro: Retrieves current note. May advance pattern if needed.
     44  7b87							; Becomes a subroutine if TT_USE_OVERLAY is used.
     45  7b87							; ---------------------------------------------------------------------
     46  7b87					      MAC	tt_fetch_current_note
     47  7b87							; construct ptr to pattern
     48  7b87				   .constructPatPtr
     49  7b87					      ldy	tt_cur_pat_index_c0,x	; get current pattern (index into tt_SequenceTable)
     50  7b87					      lda	tt_SequenceTable,y
     51  7b87					      IF	TT_USE_GOTO = 1
     52  7b87					      bpl	.noPatternGoto
     53  7b87					      and	#%01111111	; mask out goto bit to get pattern number
     54  7b87					      sta	tt_cur_pat_index_c0,x	; store goto'ed pattern index
     55  7b87					      bpl	.constructPatPtr	; unconditional
     56  7b87				   .noPatternGoto
     57  7b87					      ENDIF
     58  7b87					      tay
     59  7b87					      lda	tt_PatternPtrLo,y
     60  7b87					      sta	tt_ptr
     61  7b87					      lda	tt_PatternPtrHi,y
     62  7b87					      sta	tt_ptr+1
     63  7b87							; get new note
     64  7b87					      IF	TT_USE_OVERLAY = 0
     65  7b87					      ldy	tt_cur_note_index_c0,x
     66  7b87					      ELSE
     67  7b87							; If the V flag is set and if the new note is an instrument,
     68  7b87							; it means it got pre-fetched by an overlay percussion, it has
     69  7b87							; to remain in sustain.
     70  7b87					      clv
     71  7b87							; check if note had been pre-fetched by overlay perc already
     72  7b87					      lda	tt_cur_note_index_c0,x
     73  7b87					      bpl	.notPrefetched
     74  7b87							; If so, remove flag
     75  7b87					      and	#%01111111
     76  7b87					      sta	tt_cur_note_index_c0,x
     77  7b87							; Set V flag for later
     78  7b87					      bit	tt_Bit6Set
     79  7b87				   .notPrefetched
     80  7b87					      tay
     81  7b87					      ENDIF
     82  7b87					      lda	(tt_ptr),y
     83  7b87							; pre-process new note
     84  7b87							; 7..5: instrument (1..7), 4..0 (0..31): frequency
     85  7b87							; 0/0: End of pattern
     86  7b87					      bne	.noEndOfPattern
     87  7b87							; End of pattern: Advance to next pattern
     88  7b87					      sta	tt_cur_note_index_c0,x	; a is 0
     89  7b87					      inc	tt_cur_pat_index_c0,x
     90  7b87					      bne	.constructPatPtr	; unconditional
     91  7b87				   .noEndOfPattern
     92  7b87					      ENDM
     93  7b87
     94  7b87
     95  7b87							; ---------------------------------------------------------------------
     96  7b87							; Music player entry. Call once per frame.
     97  7b87							; ---------------------------------------------------------------------
     98  7b87				   tt_Player  SUBROUTINE
     99  7b87							; ==================== Sequencer ====================
    100  7b87							; Decrease speed timer
    101  7b87		       c6 cf		      dec	tt_timer
    102  7b89		       10 6e		      bpl	.noNewNote
    103  7b8b
    104  7b8b							; Timer ran out: Do sequencer
    105  7b8b							; Advance to next note
    106  7b8b		       a2 01		      ldx	#1	; 2 channels
    107  7b8d				   .advanceLoop
    108  7b8d					      IF	TT_USE_OVERLAY = 1
    109  7b8d		       20 a3 fb 	      jsr	tt_FetchNote
    110  7b90				  -	      ELSE
    111  7b90				  -	      TT_FETCH_CURRENT_NOTE
    112  7b90					      ENDIF
    113  7b90							; Parse new note from pattern
    114  7b90		       c9 10		      cmp	#TT_INS_PAUSE
    115  7b92					      IF	TT_USE_SLIDE = 0
    116  7b92		       90 55		      bcc	.finishedNewNote
    117  7b94		       d0 3d		      bne	.newNote
    118  7b96				  -	      ELSE
    119  7b96				  -	      beq	.pause
    120  7b96				  -	      bcs	.newNote
    121  7b96				  -
    122  7b96				  -			; --- slide/hold ---
    123  7b96				  -			; Adjust frequency and hold note in sustain.
    124  7b96				  -			; composer/tracker has to make sure that no unwanted
    125  7b96				  -			; under/overflow happens.
    126  7b96				  -			; Note: f = f + (8-(16-x)) = x + f - 8
    127  7b96				  -	      adc	tt_cur_ins_c0,x	; carry is clear after cmp
    128  7b96				  -	      sec
    129  7b96				  -	      sbc	#8
    130  7b96				  -	      sta	tt_cur_ins_c0,x
    131  7b96				  -	      bcs	.finishedNewNote	; unconditional, since legally no underflow can happen (ins>0 or HOLD for ins=0)
    132  7b96					      ENDIF
    133  7b96
    134  7b96							; --- pause ---
    135  7b96				   .pause
    136  7b96							; Get release index for current instrument. Since a pause can
    137  7b96							; only follow an instrument, we don't need to handle percussion
    138  7b96							; or commands.
    139  7b96		       b5 d6		      lda	tt_cur_ins_c0,x
    140  7b98		       20 31 fc 	      jsr	tt_CalcInsIndex
    141  7b9b		       b9 bd fe 	      lda	tt_InsReleaseIndexes-1,y	; -1 b/c instruments start at #1
    142  7b9e							; Put it into release. Skip junk byte so index no longer indicates
    143  7b9e							; sustain phase.
    144  7b9e		       18		      clc
    145  7b9f		       69 01		      adc	#1
    146  7ba1		       90 44		      bcc	.storeADIndex	; unconditional
    147  7ba3
    148  7ba3							; ---------------------------------------------------------------------
    149  7ba3							; Helper subroutine to minimize ROM footprint. Will be inlined if
    150  7ba3							; TT_USE_OVERLAY is not used.
    151  7ba3							; Interleaved here so player can be inlined.
    152  7ba3							; ---------------------------------------------------------------------
    153  7ba3					      IF	TT_USE_OVERLAY = 1
    154  7ba3				   tt_FetchNote
      0  7ba3					      TT_FETCH_CURRENT_NOTE
      1  7ba3
      2  7ba3				   .constructPatPtr
      3  7ba3		       b4 d0		      ldy	tt_cur_pat_index_c0,x
      4  7ba5		       b9 d0 ff 	      lda	tt_SequenceTable,y
      5  7ba8					      IF	TT_USE_GOTO = 1
      6  7ba8		       10 06		      bpl	.noPatternGoto
      7  7baa		       29 7f		      and	#%01111111
      8  7bac		       95 d0		      sta	tt_cur_pat_index_c0,x
      9  7bae		       10 f3		      bpl	.constructPatPtr
     10  7bb0				   .noPatternGoto
     11  7bb0					      ENDIF
     12  7bb0		       a8		      tay
     13  7bb1		       b9 c6 ff 	      lda	tt_PatternPtrLo,y
     14  7bb4		       85 d8		      sta	tt_ptr
     15  7bb6		       b9 cb ff 	      lda	tt_PatternPtrHi,y
     16  7bb9		       85 d9		      sta	tt_ptr+1
     17  7bbb
     18  7bbb				  -	      IF	TT_USE_OVERLAY = 0
     19  7bbb				  -	      ldy	tt_cur_note_index_c0,x
     20  7bbb					      ELSE
     21  7bbb
     22  7bbb
     23  7bbb
     24  7bbb		       b8		      clv
     25  7bbc
     26  7bbc		       b5 d2		      lda	tt_cur_note_index_c0,x
     27  7bbe		       10 07		      bpl	.notPrefetched
     28  7bc0
     29  7bc0		       29 7f		      and	#%01111111
     30  7bc2		       95 d2		      sta	tt_cur_note_index_c0,x
     31  7bc4
     32  7bc4		       2c 37 fc 	      bit	tt_Bit6Set
     33  7bc7				   .notPrefetched
     34  7bc7		       a8		      tay
     35  7bc8					      ENDIF
     36  7bc8		       b1 d8		      lda	(tt_ptr),y
     37  7bca
     38  7bca
     39  7bca
     40  7bca		       d0 06		      bne	.noEndOfPattern
     41  7bcc
     42  7bcc		       95 d2		      sta	tt_cur_note_index_c0,x
     43  7bce		       f6 d0		      inc	tt_cur_pat_index_c0,x
     44  7bd0		       d0 d1		      bne	.constructPatPtr
     45  7bd2				   .noEndOfPattern
    156  7bd2		       60		      rts
    157  7bd3					      ENDIF
    158  7bd3
    159  7bd3
    160  7bd3							; --- start instrument or percussion ---
    161  7bd3				   .newNote
    162  7bd3		       95 d6		      sta	tt_cur_ins_c0,x	; set new instrument
    163  7bd5							; Instrument or percussion?
    164  7bd5		       c9 20		      cmp	#TT_FREQ_MASK+1
    165  7bd7		       b0 06		      bcs	.startInstrument
    166  7bd9
    167  7bd9							; --- start percussion ---
    168  7bd9							; Get index of envelope
    169  7bd9		       a8		      tay
    170  7bda							; -TT_FIRST_PERC because percussion start with TT_FIRST_PERC
    171  7bda		       b9 e1 fe 	      lda	tt_PercIndexes-TT_FIRST_PERC,y
    172  7bdd		       d0 08		      bne	.storeADIndex	; unconditional, since index values are >0
    173  7bdf
    174  7bdf							; --- start instrument ---
    175  7bdf				   .startInstrument
    176  7bdf					      IF	TT_USE_OVERLAY = 1
    177  7bdf							; If V flag is set, this note had been pre-fetched. That means
    178  7bdf							; it should remain in sustain.
    179  7bdf		       70 08		      bvs	.finishedNewNote
    180  7be1					      ENDIF
    181  7be1							; Put note into attack/decay
    182  7be1		       20 31 fc 	      jsr	tt_CalcInsIndex
    183  7be4		       b9 b3 fe 	      lda	tt_InsADIndexes-1,y	; -1 because instruments start at #1
    184  7be7				   .storeADIndex
    185  7be7		       95 d4		      sta	tt_envelope_index_c0,x
    186  7be9
    187  7be9							; --- Finished parsing new note ---
    188  7be9				   .finishedNewNote
    189  7be9							; increase note index into pattern
    190  7be9		       f6 d2		      inc	tt_cur_note_index_c0,x
    191  7beb							; loop over channels
    192  7beb				   .sequencerNextChannel
    193  7beb		       ca		      dex
    194  7bec		       10 9f		      bpl	.advanceLoop
    195  7bee
    196  7bee							; Reset timer value
    197  7bee				  -	      IF	TT_GLOBAL_SPEED = 0
    198  7bee				  -			; Get timer value for current pattern in channel 0
    199  7bee				  -	      ldx	tt_cur_pat_index_c0	; get current pattern (index into tt_SequenceTable)
    200  7bee				  -	      ldy	tt_SequenceTable,x	; Current pattern index now in y
    201  7bee				  -	      IF	TT_USE_FUNKTEMPO = 0
    202  7bee				  -	      lda	tt_PatternSpeeds,y
    203  7bee				  -	      sta	tt_timer
    204  7bee				  -	      ELSE
    205  7bee				  -			; Test for odd/even frame
    206  7bee				  -	      lda	tt_cur_note_index_c0
    207  7bee				  -	      lsr
    208  7bee				  -	      lda	tt_PatternSpeeds,y	; does not affect carry flag
    209  7bee				  -	      bcc	.evenFrame
    210  7bee				  -	      and	#$0f	; does not affect carry flag
    211  7bee				  -	      bcs	.storeFunkTempo
    212  7bee				  -.evenFrame
    213  7bee				  -	      lsr
    214  7bee				  -	      lsr
    215  7bee				  -	      lsr
    216  7bee				  -	      lsr
    217  7bee				  -.storeFunkTempo
    218  7bee				  -	      sta	tt_timer
    219  7bee				  -	      ENDIF		; TT_USE_FUNKTEMPO = 0
    220  7bee				  -
    221  7bee					      ELSE
    222  7bee							; Global tempo
    223  7bee		       a2 04		      ldx	#TT_SPEED-1
    224  7bf0					      IF	TT_USE_FUNKTEMPO = 1
    225  7bf0		       a5 d2		      lda	tt_cur_note_index_c0
    226  7bf2		       4a		      lsr
    227  7bf3		       90 02		      bcc	.noOddFrame
    228  7bf5		       a2 03		      ldx	#TT_ODD_SPEED-1
    229  7bf7				   .noOddFrame
    230  7bf7					      ENDIF		; TT_USE_FUNKTEMPO = 1
    231  7bf7		       86 cf		      stx	tt_timer
    232  7bf9					      ENDIF		; TT_GLOBAL_SPEED = 0
    233  7bf9
    234  7bf9							; No new note to process
    235  7bf9				   .noNewNote
    236  7bf9
    237  7bf9							; ==================== Update registers ====================
    238  7bf9		       a2 01		      ldx	#1	; 2 channels
    239  7bfb				   .updateLoop
    240  7bfb							; Percussion or melodic instrument?
    241  7bfb		       b5 d6		      lda	tt_cur_ins_c0,x
    242  7bfd				  -	      IF	TT_STARTS_WITH_NOTES = 0
    243  7bfd				  -			; This branch can be removed if track starts with a note in each channel
    244  7bfd				  -	      beq	.afterAudioUpdate
    245  7bfd					      ENDIF
    246  7bfd		       c9 20		      cmp	#TT_FREQ_MASK+1
    247  7bff		       b0 37		      bcs	.instrument	; Melodic instrument
    248  7c01
    249  7c01							; --- Percussion: Get envelope index ---
    250  7c01		       b4 d4		      ldy	tt_envelope_index_c0,x
    251  7c03							; Set AUDC and AUDV value from envelope
    252  7c03		       b9 0a ff 	      lda	tt_PercCtrlVolTable-1,y	; -1 because values are stored +1
    253  7c06		       f0 02		      beq	.endOfPercussion	; 0 means end of percussion data
    254  7c08		       f6 d4		      inc	tt_envelope_index_c0,x	; if end not reached: advance index
    255  7c0a				   .endOfPercussion
    256  7c0a		       95 59		      sta	AUDV0,x
    257  7c0c		       4a		      lsr
    258  7c0d		       4a		      lsr
    259  7c0e		       4a		      lsr
    260  7c0f		       4a		      lsr
    261  7c10		       95 55		      sta	AUDC0,x
    262  7c12							; Set AUDF
    263  7c12		       b9 f4 fe 	      lda	tt_PercFreqTable-1,y	; -1 because values are stored +1
    264  7c15							; Bit 7 (overlay) might be set, but is unused in AUDF
    265  7c15		       95 57		      sta	AUDF0,x
    266  7c17					      IF	TT_USE_OVERLAY = 1
    267  7c17		       10 48		      bpl	.afterAudioUpdate
    268  7c19							; Overlay percussion: Fetch next note out of order
    269  7c19		       20 a3 fb 	      jsr	tt_FetchNote
    270  7c1c							; Only do something if it's a melodic instrument
    271  7c1c		       c9 20		      cmp	#TT_FREQ_MASK+1
    272  7c1e		       90 41		      bcc	.afterAudioUpdate
    273  7c20							; Instrument: Put into sustain
    274  7c20		       95 d6		      sta	tt_cur_ins_c0,x	; set new instrument
    275  7c22		       20 31 fc 	      jsr	tt_CalcInsIndex
    276  7c25		       b9 b8 fe 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start at #1
    277  7c28		       95 d4		      sta	tt_envelope_index_c0,x
    278  7c2a							; Set prefetch flag. asl-sec-ror is smaller than lda-ora #128-sta
    279  7c2a		       16 d2		      asl	tt_cur_note_index_c0,x
    280  7c2c		       38		      sec
    281  7c2d		       76 d2		      ror	tt_cur_note_index_c0,x
    282  7c2f		       30 30		      bmi	.afterAudioUpdate	; unconditional
    283  7c31				  -	      ELSE
    284  7c31				  -	      jmp	.afterAudioUpdate
    285  7c31					      ENDIF
    286  7c31
    287  7c31
    288  7c31							; ---------------------------------------------------------------------
    289  7c31							; Helper subroutine to minimize ROM footprint.
    290  7c31							; Interleaved here so player routine can be inlined.
    291  7c31							; ---------------------------------------------------------------------
    292  7c31				   tt_CalcInsIndex
    293  7c31							; move upper 3 bits to lower 3
    294  7c31		       4a		      lsr
    295  7c32		       4a		      lsr
    296  7c33		       4a		      lsr
    297  7c34		       4a		      lsr
    298  7c35		       4a		      lsr
    299  7c36		       a8		      tay
    300  7c37				   tt_Bit6Set		; This opcode has bit #6 set, for use with bit instruction
    301  7c37		       60		      rts
    302  7c38
    303  7c38
    304  7c38				   .instrument
    305  7c38							; --- Melodic instrument ---
    306  7c38							; Compute index into ADSR indexes and master Ctrl tables
    307  7c38		       20 31 fc 	      jsr	tt_CalcInsIndex
    308  7c3b							; Set AUDC with master value for this instrument, while we are at it
    309  7c3b		       b9 ae fe 	      lda	tt_InsCtrlTable-1,y	; -1 because instruments start with #1
    310  7c3e		       95 55		      sta	AUDC0,x
    311  7c40							; advance ADSR counter and compare to end of Sustain
    312  7c40		       b5 d4		      lda	tt_envelope_index_c0,x
    313  7c42		       d9 bd fe 	      cmp	tt_InsReleaseIndexes-1,y	; -1 because instruments start with #1
    314  7c45		       d0 03		      bne	.noEndOfSustain
    315  7c47							; End of sustain: Go back to start of sustain
    316  7c47		       b9 b8 fe 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start with #1
    317  7c4a				   .noEndOfSustain
    318  7c4a		       a8		      tay
    319  7c4b							; Set volume from envelope
    320  7c4b		       b9 c3 fe 	      lda	tt_InsFreqVolTable,y
    321  7c4e		       f0 01		      beq	.endOfEnvelope	; 0 means end of release has been reached:
    322  7c50		       c8		      iny		; advance index otherwise
    323  7c51				   .endOfEnvelope
    324  7c51		       94 d4		      sty	tt_envelope_index_c0,x
    325  7c53		       95 59		      sta	AUDV0,x
    326  7c55							; Now adjust frequency with ADSR value from envelope
    327  7c55		       4a		      lsr
    328  7c56		       4a		      lsr
    329  7c57		       4a		      lsr
    330  7c58		       4a		      lsr
    331  7c59		       18		      clc
    332  7c5a		       75 d6		      adc	tt_cur_ins_c0,x
    333  7c5c		       38		      sec
    334  7c5d		       e9 08		      sbc	#8
    335  7c5f		       95 57		      sta	AUDF0,x
    336  7c61
    337  7c61				   .afterAudioUpdate
    338  7c61							; loop over channels
    339  7c61		       ca		      dex
    340  7c62		       10 97		      bpl	.updateLoop
    341  7c64
 Music player size:  $dd
    342  7c64					      echo	"Music player size: ", *-tt_PlayerStart
------- FILE BANK_FIXED.asm
    981  7c64
    982  7c64		       20 6d fa 	      jsr	StealCharDraw	; NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
    983  7c67
    984  7c67							;---------------------------------------------------------------------------
    985  7c67							; START OF DISPLAY
    986  7c67
    987  7c67		       a9 09		      lda	#BANK_SCORING	; 2
    988  7c69		       85 3e		      sta	SET_BANK_RAM	; 3
    989  7c6b		       20 d3 f1 	      jsr	DrawDigits	; 6 = 11
    990  7c6e
    991  7c6e							;---------------------------------------------------------------------------
    992  7c6e							; A 42-cycle timing window in the screen draw code.  Perform any general
    993  7c6e							; per-frame code here, provided it takes exactly 42 cycles to execute.
    994  7c6e							; TJ: Well, not exactly 42 cycles, but it works! :)
    995  7c6e							;	 @09
    996  7c6e		       85 49		      sta	COLUBK	; 3	 value comes from subroutine
    997  7c70							; + the 'black' left-side of top screen colour change when look-around is actually a HMOVE bar, so we can't fix it :)
    998  7c70
    999  7c70
   1000  7c70							;		  inc Throttle		      ; 5     speed limiter
      0  7c70					      SLEEP	5	;	 TODO: optimize for space
      1  7c70				   .CYCLES    SET	5
      2  7c70
      3  7c70				  -	      IF	.CYCLES < 2
      4  7c70				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c70				  -	      ERR
      6  7c70					      ENDIF
      7  7c70
      8  7c70					      IF	.CYCLES & 1
      9  7c70					      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c70		       04 00		      nop	0
     11  7c72				  -	      ELSE
     12  7c72				  -	      bit	VSYNC
     13  7c72					      ENDIF
     14  7c72				   .CYCLES    SET	.CYCLES - 3
     15  7c72					      ENDIF
     16  7c72
     17  7c72					      REPEAT	.CYCLES / 2
     18  7c72		       ea		      nop
     19  7c73					      REPEND
   1002  7c73
   1003  7c73		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
   1004  7c75		       ca		      dex		; 2	 = $6f, stars effect!
   1005  7c76		       86 62		      stx	HMM0	; 3	 @24, exactly 21 cycles after the HMOVE
   1006  7c78
   1007  7c78		       85 44		      sta	NUSIZ0	; 3
   1008  7c7a		       84 65		      sty	VDELP0	; 3	 y = 0!
   1009  7c7c
      0  7c7c					      SLEEP	10
      1  7c7c				   .CYCLES    SET	10
      2  7c7c
      3  7c7c				  -	      IF	.CYCLES < 2
      4  7c7c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c7c				  -	      ERR
      6  7c7c					      ENDIF
      7  7c7c
      8  7c7c				  -	      IF	.CYCLES & 1
      9  7c7c				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c7c				  -	      nop	0
     11  7c7c				  -	      ELSE
     12  7c7c				  -	      bit	VSYNC
     13  7c7c				  -	      ENDIF
     14  7c7c				  -.CYCLES    SET	.CYCLES - 3
     15  7c7c					      ENDIF
     16  7c7c
     17  7c7c					      REPEAT	.CYCLES / 2
     18  7c7c		       ea		      nop
     17  7c7c					      REPEND
     18  7c7d		       ea		      nop
     17  7c7d					      REPEND
     18  7c7e		       ea		      nop
     17  7c7e					      REPEND
     18  7c7f		       ea		      nop
     17  7c7f					      REPEND
     18  7c80		       ea		      nop
     19  7c81					      REPEND
   1011  7c81							;iny			      ; 2     this relies on Y == 0 before...
   1012  7c81							;cpy extraLifeTimer	      ; 3     ..,and bit 0 is set in A
   1013  7c81							;adc #2		      ; 2
   1014  7c81							;sta ENAM0		      ; 3     dis/enable Cosmic Ark star effect
   1015  7c81
   1016  7c81		       a5 a4		      lda	ManLastDirection	; 3
   1017  7c83		       85 4b		      sta	REFP0	; 3
   1018  7c85
   1019  7c85		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
   1020  7c87		       85 3e		      sta	SET_BANK_RAM	; 3
   1021  7c89		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1022  7c8c							;	 @66
   1023  7c8c		       a9 03		      lda	#BANK_PostScreenCleanup	; 2
   1024  7c8e		       85 3f		      sta	SET_BANK	; 3
   1025  7c90		       20 d3 f4 	      jsr	PostScreenCleanup	; 6+x
   1026  7c93
   1027  7c93		       a9 00		      lda	#BANK_SelfModDrawPlayers	; 2
   1028  7c95		       85 3f		      sta	SET_BANK	; 3
   1029  7c97		       20 d9 f2 	      jsr	SelfModDrawPlayers	; 6+x
   1030  7c9a
   1031  7c9a		       20 6d fa 	      jsr	StealCharDraw
   1032  7c9d
   1033  7c9d		       ad 84 02    OverscanBD lda	INTIM	;4
   1034  7ca0		       d0 fb		      bne	OverscanBD	;2/3
   1035  7ca2		       4c 70 fb 	      jmp	NewFrameStart
   1036  7ca5				   VBlankTime
   1037  7ca5		       3e 3e		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
   1038  7ca7		       55 55		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_PAL
   1039  7ca9
   1040  7ca9							;---------------------------------------------------------------------------
   1041  7ca9
   1042  7ca9				   CharacterDataVecLO
   1043  7ca9
   1044  7ca9							; Two entries per character.  2nd is ptr to mirrored character
   1045  7ca9							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
   1046  7ca9
   1047  7ca9		       03		      .byte.b	<CHARACTERSHAPE_BLANK
   1048  7caa		       03		      .byte.b	<CHARACTERSHAPE_BLANK
   1049  7cab		       2d		      .byte.b	<CHARACTERSHAPE_SOIL
   1050  7cac		       2d		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
   1051  7cad		       3b		      .byte.b	<CHARACTERSHAPE_BOX
   1052  7cae		       50		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
   1053  7caf		       3e		      .byte.b	<CHARACTERSHAPE_TARGET
   1054  7cb0		       3e		      .byte.b	<CHARACTERSHAPE_TARGET_MIRRORED
   1055  7cb1		       52		      .byte.b	<CHARACTERSHAPE_TARGET2
   1056  7cb2		       52		      .byte.b	<CHARACTERSHAPE_TARGET2_MIRRORED
   1057  7cb3		       03		      .byte.b	<CHARACTERSHAPE_BLANK	; man occupied
   1058  7cb4		       03		      .byte.b	<CHARACTERSHAPE_BLANK
   1059  7cb5		       8f		      .byte.b	<CHARACTERSHAPE_STEEL
   1060  7cb6		       a4		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
   1061  7cb7		       85		      .byte.b	<CHARACTERSHAPE_WALL
   1062  7cb8		       9a		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
   1063  7cb9		       65		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET
   1064  7cba		       7a		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
   1065  7cbb		       03		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
   1066  7cbc		       03		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
   1067  7cbd
   1068  7cbd				  -	      IF	* - CharacterDataVecLO != CHARACTER_MAXIMUM*2
   1069  7cbd				  -	      ECHO	"ERROR: Incorrect CharacterDataVecLO table!"
   1070  7cbd				  -	      ERR
   1071  7cbd					      ENDIF
   1072  7cbd
   1073  7cbd							;---------------------------------------------------------------------------
   1074  7cbd
   1075  7cbd				   CharacterDataVecHI
   1076  7cbd							; TJ: used by:
   1077  7cbd							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1078  7cbd
   1079  7cbd		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
   1080  7cbe		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
   1081  7cbf		       f3		      .byte.b	>CHARACTERSHAPE_SOIL
   1082  7cc0		       f3		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
   1083  7cc1		       fd		      .byte.b	>CHARACTERSHAPE_BOX
   1084  7cc2		       fd		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
   1085  7cc3		       f2		      .byte.b	>CHARACTERSHAPE_TARGET
   1086  7cc4		       f2		      .byte.b	>CHARACTERSHAPE_TARGET_MIRRORED
   1087  7cc5		       f2		      .byte.b	>CHARACTERSHAPE_TARGET2
   1088  7cc6		       f2		      .byte.b	>CHARACTERSHAPE_TARGET2_MIRRORED
   1089  7cc7		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; man occupied
   1090  7cc8		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
   1091  7cc9		       fd		      .byte.b	>CHARACTERSHAPE_STEEL
   1092  7cca		       fd		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
   1093  7ccb		       fe		      .byte.b	>CHARACTERSHAPE_WALL
   1094  7ccc		       fe		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
   1095  7ccd		       fd		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET
   1096  7cce		       fd		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
   1097  7ccf		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
   1098  7cd0		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
   1099  7cd1
   1100  7cd1				  -	      IF	* - CharacterDataVecHI != CHARACTER_MAXIMUM*2
   1101  7cd1				  -	      ECHO	"ERROR: Incorrect CharacterDataVecHI table!"
   1102  7cd1				  -	      ERR
   1103  7cd1					      ENDIF
   1104  7cd1
   1105  7cd1							;---------------------------------------------------------------------------
   1106  7cd1
      0  7cd1					      DEFINE_SUBROUTINE	AnimateCharReplacements2	;139
      1  7cd1		       00 0f	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  7cd1					      SUBROUTINE
      3  7cd1				   AnimateCharReplacements2
   1108  7cd1
   1109  7cd1							; This manages character animation on a per-object basis.  Morph/animate these
   1110  7cd1							; characters individually or as required.  Change will affect all characters
   1111  7cd1							; of the same type in the visible display.
   1112  7cd1
   1113  7cd1							; -------------------------------------------
   1114  7cd1
   1115  7cd1							; handle the non-mandatory animating things
   1116  7cd1
   1117  7cd1		       a5 b2		      lda	timer	;3
   1118  7cd3		       29 03		      and	#%11	;2
   1119  7cd5		       d0 0c		      bne	nothingAnimates	;2/3
   1120  7cd7
   1121  7cd7		       a5 98		      lda	scrollBits	;3
   1122  7cd9		       d0 08		      bne	nothingAnimates	;2/3		 DON'T animate if we scrolled
   1123  7cdb
   1124  7cdb		       ad d4 f1 	      lda	ANIM_TARGET	;4
   1125  7cde		       49 07		      eor	#CHARACTER_TARGET^CHARACTER_TARGET2	;2
   1126  7ce0		       8d d4 f5 	      sta	ANIM_TARGET + RAM_WRITE	;4 = 15	 TARGET
   1127  7ce3
   1128  7ce3		       4c 16 f1    nothingAnimates jmp	retAnim	;3
   1129  7ce6
   1130  7ce6							;---------------------------------------------------------------------------
   1131  7ce6
      0  7ce6					      DEFINE_SUBROUTINE	ScoreAdd
      1  7ce6		       00 0f	   BANK_ScoreAdd =	_CURRENT_BANK
      2  7ce6					      SUBROUTINE
      3  7ce6				   ScoreAdd
   1133  7ce6							; TJ: used by:
   1134  7ce6							; - BANK_INITBANK.asm
   1135  7ce6		       a2 09		      ldx	#BANK_SCORING
   1136  7ce8		       86 3e		      stx	SET_BANK_RAM
   1137  7cea		       20 0f f2 	      jsr	UpdateScore
   1138  7ced		       a5 c4	   rbret      lda	ROM_Bank
   1139  7cef		       85 3f		      sta	SET_BANK
   1140  7cf1		       60		      rts
   1141  7cf2
   1142  7cf2							;---------------------------------------------------------------------------
   1143  7cf2
      0  7cf2					      DEFINE_SUBROUTINE	nextLevelMan
      1  7cf2		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7cf2					      SUBROUTINE
      3  7cf2				   nextLevelMan
   1145  7cf2
   1146  7cf2		       a9 14		      lda	#20
   1147  7cf4		       85 a8		      sta	DelayEndOfLevel
   1148  7cf6		       a9 14		      lda	#20
   1149  7cf8		       85 c6		      sta	ColourTimer
   1150  7cfa
   1151  7cfa
   1152  7cfa
   1153  7cfa					      if	1
   1154  7cfa
   1155  7cfa							; Fire up a circle-drawing special-effect object...
   1156  7cfa
   1157  7cfa		       a9 00		      lda	#0
   1158  7cfc		       85 aa		      sta	circle_d
   1159  7cfe		       85 ab		      sta	circle_d+1
   1160  7d00
   1161  7d00		       a9 01		      lda	#TYPE_CIRCLE
   1162  7d02		       85 8e		      sta	POS_Type
   1163  7d04		       20 8b f9 	      jsr	InsertObjectStack
   1164  7d07
   1165  7d07					      endif
   1166  7d07
   1167  7d07
   1168  7d07				  -	      if	0
   1169  7d07				  -	      lda	#$08
   1170  7d07				  -	      sta	color
   1171  7d07				  -	      lda	#$04
   1172  7d07				  -	      sta	color+1
   1173  7d07				  -	      lda	#$0A
   1174  7d07				  -	      sta	color+2
   1175  7d07					      endif
   1176  7d07		       e6 9f		      inc	ManMode
   1177  7d09		       60		      rts
   1178  7d0a
      0  7d0a					      DEFINE_SUBROUTINE	nextLevelMan2
      1  7d0a		       00 0f	   BANK_nextLevelMan2 =	_CURRENT_BANK
      2  7d0a					      SUBROUTINE
      3  7d0a				   nextLevelMan2
   1180  7d0a
   1181  7d0a				  -	      if	0
   1182  7d0a				  -	      ldy	#SCREEN_LINES-1
   1183  7d0a				  -CopyScreenBank2 ldx	#ROM_SHADOW_OF_RAMBANK_CODE
   1184  7d0a				  -	      sty	RAM_Bank
   1185  7d0a				  -	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
   1186  7d0a				  -	      dey
   1187  7d0a				  -	      bpl	CopyScreenBank2
   1188  7d0a				  -
   1189  7d0a				  -	      ldx	#2
   1190  7d0a				  -fade       lda	color,x
   1191  7d0a				  -	      and	#$F
   1192  7d0a				  -	      bne	nz
   1193  7d0a				  -	      lda	#1
   1194  7d0a				  -	      sta	color,x
   1195  7d0a				  -nz	      dec	color,x
   1196  7d0a				  -zalready   dex
   1197  7d0a				  -	      bpl	fade
   1198  7d0a					      endif
   1199  7d0a
   1200  7d0a							;dec DelayEndOfLevel
   1201  7d0a							;beq goNL3
   1202  7d0a
   1203  7d0a		       a5 ab		      lda	circle_d+1
   1204  7d0c		       c9 14		      cmp	#20
   1205  7d0e		       b0 01		      bcs	goNL3
   1206  7d10
   1207  7d10
   1208  7d10		       60		      rts
   1209  7d11
   1210  7d11				   goNL3
   1211  7d11		       e6 9f		      inc	ManMode
   1212  7d13
      0  7d13					      DEFINE_SUBROUTINE	switchLevels
      1  7d13		       00 0f	   BANK_switchLevels =	_CURRENT_BANK
      2  7d13					      SUBROUTINE
      3  7d13				   switchLevels
   1214  7d13
   1215  7d13							;lda #BANK_NextLevelX
   1216  7d13							;sta SET_BANK
   1217  7d13							;jmp NextLevelX
   1218  7d13
   1219  7d13							; Now do the actual switching
   1220  7d13
   1221  7d13		       a5 ca		      lda	NextLevelTrigger
   1222  7d15		       29 7f		      and	#<(~BIT_NEXTLEVEL)
   1223  7d17		       85 ca		      sta	NextLevelTrigger
   1224  7d19
   1225  7d19							; Next level is due. Point to the next level, but if we're at the end of playable levels,
   1226  7d19							; then increment the level number. This is completely circular, so we eventually wrap
   1227  7d19							; the level back to 0 and start afresh.
   1228  7d19
   1229  7d19		       e6 b4		      inc	levelX
   1230  7d1b		       a5 b4		      lda	levelX
   1231  7d1d		       c9 64		      cmp	#NUMBEROFLEVELS
   1232  7d1f		       90 02		      bcc	.level_ok
   1233  7d21		       a9 00		      lda	#0
   1234  7d23		       85 b4	   .level_ok  sta	levelX
   1235  7d25		       60		      rts
   1236  7d26
   1237  7d26							;---------------------------------------------------------------------------
   1238  7d26
      0  7d26					      DEFINE_SUBROUTINE	goGeneralScoringSetups
      1  7d26		       00 0f	   BANK_goGeneralScoringSetups =	_CURRENT_BANK
      2  7d26					      SUBROUTINE
      3  7d26				   goGeneralScoringSetups
   1240  7d26
   1241  7d26		       a9 09		      lda	#BANK_SCORING
   1242  7d28		       85 3e		      sta	SET_BANK_RAM
   1243  7d2a		       20 8f f2 	      jsr	GeneralScoringSetups
   1244  7d2d		       a5 c4		      lda	ROM_Bank
   1245  7d2f		       85 3f		      sta	SET_BANK
   1246  7d31		       60		      rts
   1247  7d32							;---------------------------------------------------------------------------
   1248  7d32
      0  7d32					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7d32		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7d32					      SUBROUTINE
      3  7d32				   CopyROM2RAM_F000
   1250  7d32
   1251  7d32		       a9 08		      lda	#BANK_CopyROMShadowToRAM
   1252  7d34		       85 3f		      sta	SET_BANK
   1253  7d36		       85 c4		      sta	ROM_Bank
   1254  7d38		       4c 43 f0 	      jmp	CopyROMShadowToRAM_F000
   1255  7d3b
   1256  7d3b
   1257  7d3b							;---------------------------------------------------------------------------
   1258  7d3b
------- FILE characterset/BOX.asm LEVEL 3 PASS 3
      0  7d3b					      include	"characterset/BOX.asm"	; 2 * LINES_PER_CHAR bytes
      1  7d3b							;    Sokoboo - a Sokoban implementation
      2  7d3b							;    using a generic tile-based display engine for the Atari 2600
      3  7d3b							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7d3b							;
      5  7d3b							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7d3b							;
      7  7d3b							;    Code related to the generic tile-based display engine was developed by
      8  7d3b							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7d3b							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7d3b							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7d3b							;
     12  7d3b							;    Code related to music and sound effects uses the TIATracker music player
     13  7d3b							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7d3b							;    directory for Apache licensing details.
     15  7d3b							;
     16  7d3b							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7d3b							;    See the copyright notices in the License directory for a list of level
     18  7d3b							;    contributors.
     19  7d3b							;
     20  7d3b							;    Except where otherwise indicated, this software is released under the
     21  7d3b							;    following licensing arrangement...
     22  7d3b							;
     23  7d3b							;    This program is free software: you can redistribute it and/or modify
     24  7d3b							;    it under the terms of the GNU General Public License as published by
     25  7d3b							;    the Free Software Foundation, either version 3 of the License, or
     26  7d3b							;    (at your option) any later version.
     27  7d3b							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7d3b
     29  7d3b							;    This program is distributed in the hope that it will be useful,
     30  7d3b							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7d3b							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7d3b							;    GNU General Public License for more details.
     33  7d3b
      0  7d3b					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  7d3b					      LIST	ON
     35  7d3b				   CHARACTERSHAPE_BOX
     36  7d3b				  -	      if	MIRRORED_BOX = NO
     37  7d3b				  -CHARACTERSHAPE_BOX_MIRRORED
     38  7d3b					      endif
     39  7d3b		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
     40  7d42		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     41  7d49		       00 00 00 00*	      .byte.b	%0,%0,%0,0,%0,%0,%0	;B
     42  7d50
     43  7d50							;--------------------------------------------------------------------------
     44  7d50					      if	MIRRORED_BOX = YES
      0  7d50					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
     10  7d50					      LIST	ON
     46  7d50				   CHARACTERSHAPE_BOX_MIRRORED
     47  7d50		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
     48  7d57		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     49  7d5e		       00 00 00 00*	      .byte.b	%0,%0,0,0,%0,%0,%0	;B
     50  7d65					      endif
     51  7d65
      0  7d65					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET", LINES_PER_CHAR
     10  7d65					      LIST	ON
     53  7d65				   CHARACTERSHAPE_BOX_ON_TARGET
     54  7d65				  -	      if	MIRRORED_BOX = NO
     55  7d65				  -CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     56  7d65					      endif
     57  7d65		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     58  7d6c		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     59  7d73		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,0,%0,%0	;B
     60  7d7a
     61  7d7a							;--------------------------------------------------------------------------
     62  7d7a					      if	MIRRORED_BOX = YES
      0  7d7a					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED", LINES_PER_CHAR
     10  7d7a					      LIST	ON
     64  7d7a				   CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     65  7d7a		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     66  7d81		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     67  7d88		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,0,%0,%0	;B
     68  7d8f					      endif
------- FILE BANK_FIXED.asm
------- FILE characterset/Steel_Wall.asm LEVEL 3 PASS 3
      0  7d8f					      include	"characterset/Steel_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      1  7d8f							;    Sokoboo - a Sokoban implementation
      2  7d8f							;    using a generic tile-based display engine for the Atari 2600
      3  7d8f							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7d8f							;
      5  7d8f							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7d8f							;
      7  7d8f							;    Code related to the generic tile-based display engine was developed by
      8  7d8f							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7d8f							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7d8f							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7d8f							;
     12  7d8f							;    Code related to music and sound effects uses the TIATracker music player
     13  7d8f							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7d8f							;    directory for Apache licensing details.
     15  7d8f							;
     16  7d8f							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7d8f							;    See the copyright notices in the License directory for a list of level
     18  7d8f							;    contributors.
     19  7d8f							;
     20  7d8f							;    Except where otherwise indicated, this software is released under the
     21  7d8f							;    following licensing arrangement...
     22  7d8f							;
     23  7d8f							;    This program is free software: you can redistribute it and/or modify
     24  7d8f							;    it under the terms of the GNU General Public License as published by
     25  7d8f							;    the Free Software Foundation, either version 3 of the License, or
     26  7d8f							;    (at your option) any later version.
     27  7d8f							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7d8f
     29  7d8f							;    This program is distributed in the hope that it will be useful,
     30  7d8f							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7d8f							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7d8f							;    GNU General Public License for more details.
     33  7d8f
     34  7d8f							;--------------------------------------------------------------------------
      0  7d8f					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
     10  7d8f					      LIST	ON
     36  7d8f				   CHARACTERSHAPE_STEEL
     37  7d8f		       00 88 00 00*	      .byte.b	%00000000,%10001000,%00000000,%00000000,%00100010,%00000000,%00000000	;R
     38  7d96		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;G
     39  7d9d		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;B
     40  7da4
     41  7da4							;--------------------------------------------------------------------------
      0  7da4					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
     10  7da4					      LIST	ON
     43  7da4				   CHARACTERSHAPE_STEEL_MIRRORED
     44  7da4		       00 11 00 00*	      .byte.b	%00000000,%00010001,%00000000,%00000000,%01000100,%00000000,%00000000	;R
     45  7dab		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;G
     46  7db2		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;B
------- FILE BANK_FIXED.asm
   1261  7db9							;---------------------------------------------------------------------------
   1262  7db9
------- FILE circle.asm LEVEL 3 PASS 3
      0  7db9					      include	"circle.asm"
      1  7db9							;    Sokoboo - a Sokoban implementation
      2  7db9							;    using a generic tile-based display engine for the Atari 2600
      3  7db9							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7db9							;
      5  7db9							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7db9							;
      7  7db9							;    Code related to the generic tile-based display engine was developed by
      8  7db9							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7db9							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7db9							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7db9							;
     12  7db9							;    Code related to music and sound effects uses the TIATracker music player
     13  7db9							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7db9							;    directory for Apache licensing details.
     15  7db9							;
     16  7db9							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7db9							;    See the copyright notices in the License directory for a list of level
     18  7db9							;    contributors.
     19  7db9							;
     20  7db9							;    Except where otherwise indicated, this software is released under the
     21  7db9							;    following licensing arrangement...
     22  7db9							;
     23  7db9							;    This program is free software: you can redistribute it and/or modify
     24  7db9							;    it under the terms of the GNU General Public License as published by
     25  7db9							;    the Free Software Foundation, either version 3 of the License, or
     26  7db9							;    (at your option) any later version.
     27  7db9							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7db9
     29  7db9							;    This program is distributed in the hope that it will be useful,
     30  7db9							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7db9							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7db9							;    GNU General Public License for more details.
     33  7db9
     34  7db9							;Begin {Circle}
     35  7db9							;x := r;
     36  7db9							;y := 0;
     37  7db9							;d := 1 - r;
     38  7db9							;Repeat
     39  7db9							;Circle_Points(x,y);
     40  7db9							;y := y + 1;
     41  7db9							;if d < 0 Then
     42  7db9							;    d := d + 2*y + 1
     43  7db9							;Else Begin
     44  7db9							;    x := x - 1;
     45  7db9							;    d := d + 2*(y-x) + 1
     46  7db9							;    End
     47  7db9							;Until x < y
     48  7db9							;End; {Circle}
     49  7db9
     50  7db9
      0  7db9					      DEFINE_SUBROUTINE	PlotChar
      1  7db9		       00 0f	   BANK_PlotChar =	_CURRENT_BANK
      2  7db9					      SUBROUTINE
      3  7db9				   PlotChar
     52  7db9
     53  7db9							; a = x pos
     54  7db9							; y = y pos
     55  7db9
     56  7db9		       c5 94		      cmp	BoardLimit_Width
     57  7dbb		       b0 14		      bcs	off1x
     58  7dbd		       c4 95		      cpy	BoardLimit_Height
     59  7dbf		       b0 10		      bcs	off1x
     60  7dc1
     61  7dc1		       48		      pha
     62  7dc2		       a9 08		      lda	#BANK_GetBoardAddressW	;
     63  7dc4		       85 3f		      sta	SET_BANK	;
     64  7dc6		       20 e8 f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
     65  7dc9
     66  7dc9		       86 3e		      stx	SET_BANK_RAM	;3
     67  7dcb
     68  7dcb		       68		      pla
     69  7dcc		       a8		      tay
     70  7dcd		       a5 ae		      lda	circ_char	;3
     71  7dcf		       91 c2		      sta	(Board_AddressW),y	;6
     72  7dd1		       60	   off1x      rts
     73  7dd2
     74  7dd2							;x	       Plot(x,y);
     75  7dd2							;x	       Plot(y,x);
     76  7dd2							;x	      Plot(y,-x);
     77  7dd2							;x	      Plot(x,-y);
     78  7dd2							;x	      Plot(-x,-y);
     79  7dd2							;x	      Plot(-y,-x);
     80  7dd2							;x	       Plot(-y,x);
     81  7dd2							;x	       Plot(-x,y)
     82  7dd2
      0  7dd2					      DEFINE_SUBROUTINE	PlotCirclePoints
      1  7dd2		       00 0f	   BANK_PlotCirclePoints =	_CURRENT_BANK
      2  7dd2					      SUBROUTINE
      3  7dd2				   PlotCirclePoints
     84  7dd2
     85  7dd2							; +x+y
     86  7dd2		       18		      clc
     87  7dd3		       a5 ad		      lda	circ_y
     88  7dd5		       4a		      lsr
     89  7dd6		       65 9c		      adc	ManY	; "origin"
     90  7dd8		       a8		      tay
     91  7dd9		       18		      clc
     92  7dda		       a5 ac		      lda	circ_x
     93  7ddc		       4a		      lsr
     94  7ddd		       65 9b		      adc	ManX
     95  7ddf		       c5 95		      cmp	BoardLimit_Height
     96  7de1		       b0 ee		      bcs	off1x
     97  7de3		       20 b9 fd 	      jsr	PlotChar
     98  7de6
     99  7de6							;+y+x
    100  7de6		       18		      clc
    101  7de7		       a5 ac		      lda	circ_x
    102  7de9		       4a		      lsr
    103  7dea		       65 9c		      adc	ManY	; "origin"
    104  7dec		       a8		      tay
    105  7ded		       18		      clc
    106  7dee		       a5 ad		      lda	circ_y
    107  7df0		       4a		      lsr
    108  7df1		       65 9b		      adc	ManX
    109  7df3		       20 b9 fd 	      jsr	PlotChar
    110  7df6
    111  7df6							; y,-x
    112  7df6		       38		      sec
    113  7df7		       a5 9c		      lda	ManY
    114  7df9		       0a		      asl
    115  7dfa		       e5 ac		      sbc	circ_x
    116  7dfc		       4a		      lsr
    117  7dfd		       a8		      tay
    118  7dfe		       18		      clc
    119  7dff		       a5 ad		      lda	circ_y
    120  7e01		       4a		      lsr
    121  7e02		       65 9b		      adc	ManX	; "origin"
    122  7e04		       20 b9 fd 	      jsr	PlotChar
    123  7e07
    124  7e07							; x,-y
    125  7e07		       a5 9c		      lda	ManY
    126  7e09		       0a		      asl
    127  7e0a		       38		      sec
    128  7e0b		       e5 ad		      sbc	circ_y	; "origin"
    129  7e0d		       4a		      lsr
    130  7e0e		       a8		      tay
    131  7e0f		       a5 ac		      lda	circ_x
    132  7e11		       4a		      lsr
    133  7e12		       18		      clc
    134  7e13		       65 9b		      adc	ManX
    135  7e15		       20 b9 fd 	      jsr	PlotChar
    136  7e18
    137  7e18							; -x,-y
    138  7e18		       a5 9c		      lda	ManY
    139  7e1a		       0a		      asl
    140  7e1b		       38		      sec
    141  7e1c		       e5 ad		      sbc	circ_y	; "origin"
    142  7e1e		       4a		      lsr
    143  7e1f		       a8		      tay
    144  7e20		       a5 9b		      lda	ManX
    145  7e22		       0a		      asl
    146  7e23		       38		      sec
    147  7e24		       e5 ac		      sbc	circ_x
    148  7e26		       4a		      lsr
    149  7e27		       20 b9 fd 	      jsr	PlotChar
    150  7e2a
    151  7e2a							; -y,-x
    152  7e2a		       a5 9c		      lda	ManY
    153  7e2c		       0a		      asl
    154  7e2d		       38		      sec
    155  7e2e		       e5 ac		      sbc	circ_x	; "origin"
    156  7e30		       4a		      lsr
    157  7e31		       a8		      tay
    158  7e32		       a5 9b		      lda	ManX
    159  7e34		       0a		      asl
    160  7e35		       38		      sec
    161  7e36		       e5 ad		      sbc	circ_y
    162  7e38		       4a		      lsr
    163  7e39		       20 b9 fd 	      jsr	PlotChar
    164  7e3c
    165  7e3c							; -y,x
    166  7e3c		       a5 ac		      lda	circ_x
    167  7e3e		       4a		      lsr
    168  7e3f		       18		      clc
    169  7e40		       65 9c		      adc	ManY	; "origin"
    170  7e42		       a8		      tay
    171  7e43		       a5 9b		      lda	ManX
    172  7e45		       0a		      asl
    173  7e46		       38		      sec
    174  7e47		       e5 ad		      sbc	circ_y
    175  7e49		       4a		      lsr
    176  7e4a		       20 b9 fd 	      jsr	PlotChar
    177  7e4d
    178  7e4d							; -x,y
    179  7e4d		       a5 ad		      lda	circ_y
    180  7e4f		       4a		      lsr
    181  7e50		       d8		      cld
    182  7e51		       65 9c		      adc	ManY	; "origin"
    183  7e53		       a8		      tay
    184  7e54		       a5 9b		      lda	ManX
    185  7e56		       0a		      asl
    186  7e57		       38		      sec
    187  7e58		       e5 ac		      sbc	circ_x
    188  7e5a		       4a		      lsr
    189  7e5b		       20 b9 fd 	      jsr	PlotChar
    190  7e5e
    191  7e5e
    192  7e5e		       60		      rts		;6
    193  7e5f
    194  7e5f
    195  7e5f
      0  7e5f					      DEFINE_SUBROUTINE	DrawCircle
      1  7e5f		       00 0f	   BANK_DrawCircle =	_CURRENT_BANK
      2  7e5f					      SUBROUTINE
      3  7e5f				   DrawCircle
    197  7e5f							; a = radius
    198  7e5f							;		    sty circ_char
    199  7e5f							;		    sta circ_x
    200  7e5f							;		    eor #255
    201  7e5f							;		    clc
    202  7e5f							;		    adc #1
    203  7e5f							;		    sta circ_scratch	 ; "d" --> "1-r" in unit terms
    204  7e5f
    205  7e5f							;		    lda #0
    206  7e5f							;		    sta circ_y
    207  7e5f
    208  7e5f				   CircleRepeat
    209  7e5f
    210  7e5f
    211  7e5f
    212  7e5f		       20 d2 fd 	      jsr	PlotCirclePoints
    213  7e62		       e6 ad		      inc	circ_y
    214  7e64		       a5 af		      lda	circ_scratch
    215  7e66		       10 09		      bpl	positiveD
    216  7e68
    217  7e68		       a5 ad		      lda	circ_y
    218  7e6a		       0a		      asl
    219  7e6b		       38		      sec		; "+1"
    220  7e6c		       65 af		      adc	circ_scratch
    221  7e6e		       4c 7c fe 	      jmp	CCont
    222  7e71
    223  7e71		       c6 ac	   positiveD  dec	circ_x
    224  7e73
    225  7e73		       38		      sec
    226  7e74		       a5 ad		      lda	circ_y
    227  7e76		       e5 ac		      sbc	circ_x
    228  7e78		       0a		      asl
    229  7e79		       38		      sec		; "+1"
    230  7e7a		       65 af		      adc	circ_scratch
    231  7e7c
    232  7e7c		       85 af	   CCont      sta	circ_scratch
    233  7e7e
    234  7e7e		       a5 ac		      lda	circ_x
    235  7e80		       c5 ad		      cmp	circ_y
    236  7e82		       b0 db		      bcs	CircleRepeat	; circleDie
    237  7e84
    238  7e84		       60	   circleDie  rts
------- FILE BANK_FIXED.asm
------- FILE characterset/Brick_Wall.asm LEVEL 3 PASS 3
      0  7e85					      include	"characterset/Brick_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      1  7e85							;    Sokoboo - a Sokoban implementation
      2  7e85							;    using a generic tile-based display engine for the Atari 2600
      3  7e85							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7e85							;
      5  7e85							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7e85							;
      7  7e85							;    Code related to the generic tile-based display engine was developed by
      8  7e85							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7e85							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7e85							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7e85							;
     12  7e85							;    Code related to music and sound effects uses the TIATracker music player
     13  7e85							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7e85							;    directory for Apache licensing details.
     15  7e85							;
     16  7e85							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7e85							;    See the copyright notices in the License directory for a list of level
     18  7e85							;    contributors.
     19  7e85							;
     20  7e85							;    Except where otherwise indicated, this software is released under the
     21  7e85							;    following licensing arrangement...
     22  7e85							;
     23  7e85							;    This program is free software: you can redistribute it and/or modify
     24  7e85							;    it under the terms of the GNU General Public License as published by
     25  7e85							;    the Free Software Foundation, either version 3 of the License, or
     26  7e85							;    (at your option) any later version.
     27  7e85							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7e85
     29  7e85							;    This program is distributed in the hope that it will be useful,
     30  7e85							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7e85							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7e85							;    GNU General Public License for more details.
     33  7e85
      0  7e85					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  7e85					      LIST	ON
     35  7e85
     36  7e85		       00 00	   BRICK_WALL_DEF =	0
     37  7e85
     38  7e85				   CHARACTERSHAPE_WALL
     39  7e85				   CHARACTERSHAPE_WALL0
     40  7e85
     41  7e85
     42  7e85
     43  7e85				  -	      if	MIRRORED_WALL = NO
     44  7e85				  -CHARACTERSHAPE_WALL_MIRRORED
     45  7e85				  -CHARACTERSHAPE_WALL0_MIRRORED
     46  7e85					      endif
     47  7e85
     48  7e85					      if	BRICK_WALL_DEF = 0
     49  7e85		       00 ee ee 00*	      .byte.b	%00000000,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;R
     50  7e8c		       ee ee ee 00*	      .byte.b	%11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;G
     51  7e93		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     52  7e9a					      endif
     53  7e9a
     54  7e9a
     55  7e9a
     56  7e9a							;--------------------------------------------------------------------------
     57  7e9a					      if	MIRRORED_WALL = YES
      0  7e9a					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  7e9a					      LIST	ON
     59  7e9a				   CHARACTERSHAPE_WALL_MIRRORED
     60  7e9a				   CHARACTERSHAPE_WALL0_MIRRORED
     61  7e9a
     62  7e9a					      if	BRICK_WALL_DEF = 0
     63  7e9a		       00 77 77 00*	      .byte.b	%00000000,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;R
     64  7ea1		       77 77 77 00*	      .byte.b	%01110111,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;G
     65  7ea8		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     66  7eaf					      endif
     67  7eaf
     68  7eaf
     69  7eaf					      endif
------- FILE BANK_FIXED.asm
------- FILE sound/intro1_trackdata.asm LEVEL 3 PASS 3
      0  7eaf					      include	"sound/intro1_trackdata.asm"
      1  7eaf							; TIATracker music player
      2  7eaf							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7eaf							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7eaf							; Email: andre.wichmann@gmx.de
      5  7eaf							;
      6  7eaf							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7eaf							; you may not use this file except in compliance with the License.
      8  7eaf							; You may obtain a copy of the License at
      9  7eaf							;
     10  7eaf							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7eaf							;
     12  7eaf							; Unless required by applicable law or agreed to in writing, software
     13  7eaf							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7eaf							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7eaf							; See the License for the specific language governing permissions and
     16  7eaf							; limitations under the License.
     17  7eaf
     18  7eaf							; Song author: 
     19  7eaf							; Song name: 
     20  7eaf
     21  7eaf							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7eaf
     23  7eaf							; =====================================================================
     24  7eaf							; TIATracker melodic and percussion instruments, patterns and sequencer
     25  7eaf							; data.
     26  7eaf							; =====================================================================
     27  7eaf				   tt_TrackDataStart
     28  7eaf
     29  7eaf							; =====================================================================
     30  7eaf							; Melodic instrument definitions (up to 7). tt_envelope_index_c0/1 hold
     31  7eaf							; the index values into these tables for the current instruments played
     32  7eaf							; in channel 0 and 1.
     33  7eaf							; 
     34  7eaf							; Each instrument is defined by:
     35  7eaf							; - tt_InsCtrlTable: the AUDC value
     36  7eaf							; - tt_InsADIndexes: the index of the start of the ADSR envelope as
     37  7eaf							;	 defined in tt_InsFreqVolTable
     38  7eaf							; - tt_InsSustainIndexes: the index of the start of the Sustain phase
     39  7eaf							;	 of the envelope
     40  7eaf							; - tt_InsReleaseIndexes: the index of the start of the Release phase
     41  7eaf							; - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
     42  7eaf							;	 the envelope
     43  7eaf							; =====================================================================
     44  7eaf
     45  7eaf							; Instrument master CTRL values
     46  7eaf				   tt_InsCtrlTable
     47  7eaf		       07 04 0c 04*	      dc.b	$07, $04, $0c, $04, $0c
     48  7eb4
     49  7eb4
     50  7eb4							; Instrument Attack/Decay start indexes into ADSR tables.
     51  7eb4				   tt_InsADIndexes
     52  7eb4		       00 0e 0e 1e*	      dc.b	$00, $0e, $0e, $1e, $1e
     53  7eb9
     54  7eb9
     55  7eb9							; Instrument Sustain start indexes into ADSR tables
     56  7eb9				   tt_InsSustainIndexes
     57  7eb9		       08 19 19 2b*	      dc.b	$08, $19, $19, $2b, $2b
     58  7ebe
     59  7ebe
     60  7ebe							; Instrument Release start indexes into ADSR tables
     61  7ebe							; Caution: Values are stored with an implicit -1 modifier! To get the
     62  7ebe							; real index, add 1.
     63  7ebe				   tt_InsReleaseIndexes
     64  7ebe		       09 1b 1b 2c*	      dc.b	$09, $1b, $1b, $2c, $2c
     65  7ec3
     66  7ec3
     67  7ec3							; AUDVx and AUDFx ADSR envelope values.
     68  7ec3							; Each byte encodes the frequency and volume:
     69  7ec3							; - Bits 7..4: Freqency modifier for the current note ([-8..7]),
     70  7ec3							;	 8 means no change. Bit 7 is the sign bit.
     71  7ec3							; - Bits 3..0: Volume
     72  7ec3							; Between sustain and release is one byte that is not used and
     73  7ec3							; can be any value.
     74  7ec3							; The end of the release phase is encoded by a 0.
     75  7ec3				   tt_InsFreqVolTable
     76  7ec3							; 0: Pizzicato bassb
     77  7ec3		       8a 8a 89 88*	      dc.b	$8a, $8a, $89, $88, $86, $85, $85, $84
     78  7ecb		       83 00 83 83*	      dc.b	$83, $00, $83, $83, $83, $00
     79  7ed1							; 1+2: Square2
     80  7ed1		       8c 8c 8b 89*	      dc.b	$8c, $8c, $8b, $89, $87, $85, $84, $83
     81  7ed9		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $00, $81, $00
     82  7ee1							; 3+4: Square
     83  7ee1		       85 85 85 85*	      dc.b	$85, $85, $85, $85, $84, $83, $83, $82
     84  7ee9		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $81, $00, $80
     85  7ef1		       00		      dc.b	$00
     86  7ef2
     87  7ef2
     88  7ef2
     89  7ef2							; =====================================================================
     90  7ef2							; Percussion instrument definitions (up to 15)
     91  7ef2							;
     92  7ef2							; Each percussion instrument is defined by:
     93  7ef2							; - tt_PercIndexes: The index of the first percussion frame as defined
     94  7ef2							;	 in tt_PercFreqTable and tt_PercCtrlVolTable
     95  7ef2							; - tt_PercFreqTable: The AUDF frequency value
     96  7ef2							; - tt_PercCtrlVolTable: The AUDV volume and AUDC values
     97  7ef2							; =====================================================================
     98  7ef2
     99  7ef2							; Indexes into percussion definitions signifying the first frame for
    100  7ef2							; each percussion in tt_PercFreqTable.
    101  7ef2							; Caution: Values are stored with an implicit +1 modifier! To get the
    102  7ef2							; real index, subtract 1.
    103  7ef2				   tt_PercIndexes
    104  7ef2		       01 0a 0c 	      dc.b	$01, $0a, $0c
    105  7ef5
    106  7ef5
    107  7ef5							; The AUDF frequency values for the percussion instruments.
    108  7ef5							; If the second to last value is negative (>=128), it means it's an
    109  7ef5							; "overlay" percussion, i.e. the player fetches the next instrument note
    110  7ef5							; immediately and starts it in the sustain phase next frame. (Needs
    111  7ef5							; TT_USE_OVERLAY)
    112  7ef5				   tt_PercFreqTable
    113  7ef5							; 0: Kick
    114  7ef5		       00 01 02 03*	      dc.b	$00, $01, $02, $03, $04, $05, $06, $87
    115  7efd		       00		      dc.b	$00
    116  7efe							; 1: HH
    117  7efe		       80 00		      dc.b	$80, $00
    118  7f00							; 2: Snare
    119  7f00		       01 03 06 0e*	      dc.b	$01, $03, $06, $0e, $13, $11, $15, $14
    120  7f08		       17 1b 00 	      dc.b	$17, $1b, $00
    121  7f0b
    122  7f0b
    123  7f0b							; The AUDCx and AUDVx volume values for the percussion instruments.
    124  7f0b							; - Bits 7..4: AUDC value
    125  7f0b							; - Bits 3..0: AUDV value
    126  7f0b							; 0 means end of percussion data.
    127  7f0b				   tt_PercCtrlVolTable
    128  7f0b							; 0: Kick
    129  7f0b		       ee ed ed eb*	      dc.b	$ee, $ed, $ed, $eb, $e9, $e8, $e8, $e6
    130  7f13		       00		      dc.b	$00
    131  7f14							; 1: HH
    132  7f14		       87 00		      dc.b	$87, $00
    133  7f16							; 2: Snare
    134  7f16		       8b 8a 8a 8a*	      dc.b	$8b, $8a, $8a, $8a, $8a, $8a, $89, $88
    135  7f1e		       87 86 00 	      dc.b	$87, $86, $00
    136  7f21
    137  7f21
    138  7f21
    139  7f21							; =====================================================================
    140  7f21							; Track definition
    141  7f21							; The track is defined by:
    142  7f21							; - tt_PatternX (X=0, 1, ...): Pattern definitions
    143  7f21							; - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
    144  7f21							;	 as index values
    145  7f21							; - tt_SequenceTable: The order in which the patterns should be played,
    146  7f21							;	 i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
    147  7f21							;	 for all channels and sub-tracks. The variables
    148  7f21							;	 tt_cur_pat_index_c0/1 hold an index into tt_SequenceTable for
    149  7f21							;	 each channel.
    150  7f21							;
    151  7f21							; So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
    152  7f21							; in turn point to pattern definitions (tt_PatternX) in which the notes
    153  7f21							; to play are specified.
    154  7f21							; =====================================================================
    155  7f21
    156  7f21							; ---------------------------------------------------------------------
    157  7f21							; Pattern definitions, one table per pattern. tt_cur_note_index_c0/1
    158  7f21							; hold the index values into these tables for the current pattern
    159  7f21							; played in channel 0 and 1.
    160  7f21							;
    161  7f21							; A pattern is a sequence of notes (one byte per note) ending with a 0.
    162  7f21							; A note can be either:
    163  7f21							; - Pause: Put melodic instrument into release. Must only follow a
    164  7f21							;	 melodic instrument.
    165  7f21							; - Hold: Continue to play last note (or silence). Default "empty" note.
    166  7f21							; - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
    167  7f21							;	 by -7..+7 and keep playing it
    168  7f21							; - Play new note with melodic instrument
    169  7f21							; - Play new note with percussion instrument
    170  7f21							; - End of pattern
    171  7f21							;
    172  7f21							; A note is defined by:
    173  7f21							; - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
    174  7f21							;	 and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
    175  7f21							;	 defined as:
    176  7f21							;	 - 0: End of pattern
    177  7f21							;	 - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
    178  7f21							;	 - 8: Hold
    179  7f21							;	 - 16: Pause
    180  7f21							;	 - [17..31]: Play percussion instrument 1..15
    181  7f21							;
    182  7f21							; The tracker must ensure that a pause only follows a melodic
    183  7f21							; instrument or a hold/slide.
    184  7f21							; ---------------------------------------------------------------------
    185  7f21		       00 1f	   TT_FREQ_MASK =	%00011111
    186  7f21		       00 08	   TT_INS_HOLD =	8
    187  7f21		       00 10	   TT_INS_PAUSE =	16
    188  7f21		       00 11	   TT_FIRST_PERC =	17
    189  7f21
    190  7f21							; Intro left
    191  7f21				   tt_pattern0
    192  7f21		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $3e, $08
    193  7f29		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $3e, $08
    194  7f31		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $12, $3e
    195  7f39		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $13, $08
    196  7f41		       00		      dc.b	$00
    197  7f42
    198  7f42							; Intro2 L
    199  7f42				   tt_pattern1
    200  7f42		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    201  7f4a		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    202  7f52		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    203  7f5a		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    204  7f62		       00		      dc.b	$00
    205  7f63
    206  7f63							; Intro2-fill L
    207  7f63				   tt_pattern2
    208  7f63		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    209  7f6b		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    210  7f73		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    211  7f7b		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    212  7f83		       00		      dc.b	$00
    213  7f84
    214  7f84							; Intro right
    215  7f84				   tt_pattern3
    216  7f84		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $73, $08
    217  7f8c		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $73, $08, $73, $08
    218  7f94		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $b3, $08
    219  7f9c		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    220  7fa4		       00		      dc.b	$00
    221  7fa5
    222  7fa5							; Intro2 R
    223  7fa5				   tt_pattern4
    224  7fa5		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    225  7fad		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    226  7fb5		       b3 08 73 08*	      dc.b	$b3, $08, $73, $08, $b3, $08, $73, $08
    227  7fbd		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    228  7fc5		       00		      dc.b	$00
    229  7fc6
    230  7fc6
    231  7fc6
    232  7fc6
    233  7fc6							; Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
    234  7fc6							; Each byte encodes the speed of one pattern in the order
    235  7fc6							; of the tt_PatternPtr tables below.
    236  7fc6							; If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
    237  7fc6							; the even speed and the high nibble the odd speed.
    238  7fc6				  -	      IF	TT_GLOBAL_SPEED = 0
    239  7fc6				  -tt_PatternSpeeds
    240  7fc6				  -%%PATTERNSPEEDS%%
    241  7fc6					      ENDIF
    242  7fc6
    243  7fc6
    244  7fc6							; ---------------------------------------------------------------------
    245  7fc6							; Pattern pointers look-up table.
    246  7fc6							; ---------------------------------------------------------------------
    247  7fc6				   tt_PatternPtrLo
    248  7fc6		       21 42 63 84	      dc.b	<tt_pattern0, <tt_pattern1, <tt_pattern2, <tt_pattern3
    249  7fca		       a5		      dc.b	<tt_pattern4
    250  7fcb				   tt_PatternPtrHi
    251  7fcb		       ff ff ff ff	      dc.b	>tt_pattern0, >tt_pattern1, >tt_pattern2, >tt_pattern3
    252  7fcf		       ff		      dc.b	>tt_pattern4
    253  7fd0
    254  7fd0
    255  7fd0							; ---------------------------------------------------------------------
    256  7fd0							; Pattern sequence table. Each byte is an index into the
    257  7fd0							; tt_PatternPtrLo/Hi tables where the pointers to the pattern
    258  7fd0							; definitions can be found. When a pattern has been played completely,
    259  7fd0							; the next byte from this table is used to get the address of the next
    260  7fd0							; pattern to play. tt_cur_pat_index_c0/1 hold the current index values
    261  7fd0							; into this table for channels 0 and 1.
    262  7fd0							; If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
    263  7fd0							; number encoded in bits 6..0 (i.e. value AND %01111111).
    264  7fd0							; ---------------------------------------------------------------------
    265  7fd0				   tt_SequenceTable
    266  7fd0							; ---------- Channel 0 ----------
    267  7fd0		       00 00 01 02*	      dc.b	$00, $00, $01, $02, $80
    268  7fd5
    269  7fd5
    270  7fd5							; ---------- Channel 1 ----------
    271  7fd5		       03 04 03 04*	      dc.b	$03, $04, $03, $04, $85
    272  7fda
    273  7fda
 Track size:  $12b
    274  7fda					      echo	"Track size: ", *-tt_TrackDataStart
------- FILE BANK_FIXED.asm
   1266  7fda
 FREE BYTES IN FIXED BANK =  $21
   1267  7fda					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1268  7fda
   1269  7fda							;---------------------------------------------------------------------------
   1270  7fda							; The reset vectors
   1271  7fda							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1272  7fda
   1273  8000 ????				      SEG	InterruptVectors
   1274  7ffc					      ORG	FIXED_BANK + $7FC
   1275  7ffc					      RORG	$7ffC
   1276  7ffc
   1277  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1278  7ffc		       f6 fa		      .word.w	Reset	; RESET
   1279  7ffe		       f6 fa		      .word.w	Reset	; IRQ	      (not used)
   1280  8000
   1281  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
    866  8000
    867  8000					      END
