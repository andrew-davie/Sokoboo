------- FILE ./sokoboo.asm LEVEL 1 PASS 3
      1  8000 ????
      2  8000 ????						;------------------------------------------------------------------------------
      3  8000 ????						; Some portions of this code may be freely used for private, educational and research
      4  8000 ????						; purposes
      5  8000 ????						; If you wish to profit from this code, please ask for permission first.
      6  8000 ????						;------------------------------------------------------------------------------
      7  8000 ????
      8  8000 ????
      9  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     10  8000 ????
     11  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  8000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  8000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  8000 ????						;
     10  8000 ????						; This file defines hardware registers and memory mapping for the
     11  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  8000 ????						; available at at http://www.atari2600.org/dasm
     14  8000 ????						;
     15  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  8000 ????						; with your views.  Please contribute, if you think you can improve this
     19  8000 ????						; file!
     20  8000 ????						;
     21  8000 ????						; Latest Revisions...
     22  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  8000 ????						;			    This will allow conditional code to verify VCS.H being
     25  8000 ????						;			    used for code assembly.
     26  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  8000 ????						;			 mirrored reading/writing differences.	This is more a
     29  8000 ????						;			 readability issue, and binary compatibility with disassembled
     30  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  8000 ????						;			 which was broken by the use of segments in this file, as
     33  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  8000 ????						;						   it is safe to leave it undefined, and the base address will
     38  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  8000 ????						;			  - register definitions are now generated through assignment
     41  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  8000 ????						;			    address architecture.
     43  8000 ????						; 1.0	22/MAR/2003		Initial release
     44  8000 ????
     45  8000 ????
     46  8000 ????						;-------------------------------------------------------------------------------
     47  8000 ????
     48  8000 ????						; TIA_BASE_ADDRESS
     49  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  8000 ????						; Normally 0, the base address should (externally, before including this file)
     51  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  8000 ????						; < $40 as a bankswitch.
     54  8000 ????
     55  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     56  8000 ????			  -TIA_BASE_ADDRESS =	0
     57  8000 ????				      ENDIF
     58  8000 ????
     59  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  8000 ????						; *OR* by declaring the label before including this file, eg:
     62  8000 ????						; TIA_BASE_ADDRESS = $40
     63  8000 ????						;   include "vcs.h"
     64  8000 ????
     65  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  8000 ????						; for the mirrored ROM hardware registers.
     68  8000 ????
     69  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     71  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     74  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  8000 ????				      ENDIF
     80  8000 ????
     81  8000 ????						;-------------------------------------------------------------------------------
     82  8000 ????
     83 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0040
     86 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0040
     88 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U006d
    134 U006d							;-------------------------------------------------------------------------------
    135 U006d
    136 U004e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0040					      ORG	TIA_BASE_READ_ADDRESS
    138 U0040
    139 U0040							;											bit 7	 bit 6
    140 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U004e
    155 U004e							;-------------------------------------------------------------------------------
    156 U004e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  0000 ????
      4  0000 ????	       00 6a	   VERSION_MACRO =	106
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	22/MAR/2003		Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Andrew Davie
     97  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  0000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  0000 ????						; Use as very first section of code on boot (ie: at reset)
    101  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  0000 ????
    103  0000 ????				      MAC	clean_start
    104  0000 ????				      sei
    105  0000 ????				      cld
    106  0000 ????
    107  0000 ????				      ldx	#0
    108  0000 ????				      txa
    109  0000 ????				      tay
    110  0000 ????			   .CLEAR_STACK dex
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  0000 ????
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    151  0000 ????			   .FREE_BYTES SET	0
    152  0000 ????				      MAC	boundary
    153  0000 ????				      REPEAT	256
    154  0000 ????				      IF	<. % {1} = 0
    155  0000 ????				      MEXIT
    156  0000 ????				      ELSE
    157  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    158  0000 ????				      .byte	$00
    159  0000 ????				      ENDIF
    160  0000 ????				      REPEND
    161  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    162  0000 ????				      ENDM
    163  0000 ????
    164  0000 ????
    165  0000 ????						; EOF
------- FILE ./sokoboo.asm
     14  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						; segtime optimization (averages):
      2  0000 ????						;   lost time = segtime/2 * 64
      3  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
      4  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
      5  0000 ????						;
      6  0000 ????						; segtime = 2:
      7  0000 ????						;   lost time = 64
      8  0000 ????						;   num-segments = 28
      9  0000 ????						;   overhead = 224!
     10  0000 ????						; segtime = 3:
     11  0000 ????						;   lost time = 96
     12  0000 ????						;   num-segments = 18
     13  0000 ????						;   overhead = 144!
     14  0000 ????						; segtime = 4: 	     <--!!!
     15  0000 ????						;   lost time = 128!
     16  0000 ????						;   num-segments = 28
     17  0000 ????						;   overhead = 112
     18  0000 ????						; segtime = 5:
     19  0000 ????						;   lost time = 160!
     20  0000 ????						;   num-segments = 11
     21  0000 ????						;   overhead = 88
     22  0000 ????						; segtime = 6:
     23  0000 ????						;   lost time = 192!
     24  0000 ????						;   num-segments = 9
     25  0000 ????						;   overhead = 72
     26  0000 ????						; segtime = 7:
     27  0000 ????						;   lost time = 224!
     28  0000 ????						;   num-segments = 8
     29  0000 ????						;   overhead = 64
     30  0000 ????						; segtime = 10:
     31  0000 ????						;   lost time = 320!
     32  0000 ????						;   num-segments = 5
     33  0000 ????						;   overhead = 40
     34  0000 ????						; segtime = 20:
     35  0000 ????						;   lost time = 640!
     36  0000 ????						;   num-segments = 2
     37  0000 ????						;   overhead = 16
     38  0000 ????						; segtime = 40:
     39  0000 ????						;   lost time = 1280!
     40  0000 ????						;   num-segments = 1
     41  0000 ????						;   overhead = 8
     42  0000 ????
     43  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     44  0000 ????						; below wasted time increases rapidly, above only moderately
     45  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     46  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     47  0000 ????						;  so larger segtimes are not that bad then
     48  0000 ????
     49  0000 ????
     50  0000 ????				      MAC	segtime
     51  0000 ????			   {1}	      SET	{2}
     52  0000 ????			   TEST_{1}   =	0
     53  0000 ????				      ENDM
     54  0000 ????
     55  0000 ????				      MAC	xsegtime
     56  0000 ????			   {1}	      SET	{2}-1
     57  0000 ????			   TEST_{1}   =	1
     58  0000 ????				      ENDM
     59  0000 ????
     60  0000 ????						;@TJ -- SIMPLY PUT AN X IN FRONT OF THE LINE(S) YOU WANT TO TEST
     61  0000 ????						; eg: XSEGTIME SEGTIME_BOX1,5
     62  0000 ????						; No other action required.  All code enables/disables automatically.
     63  0000 ????
     64  0000 ????						; 2012/02/11 -- experimental reduction in times (but not stress tested)
     65  0000 ????						; due to separation of timeslice overhead to separate check
     66  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_SCD_DIRECT,8	; TODO: 392@12/2/2012
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	8
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_QUICK,9	; TODO: 414@12/2/2012
      1  0000 ????			   SEGTIME_SCD_QUICK SET	9
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_SLOW,12	; TODO: cycles: ~635 @12/2/2012.
      1  0000 ????			   SEGTIME_SCD_SLOW SET	12
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_PF0,5	; TODO: cycle counted ~126 @12/2/2012
      1  0000 ????			   SEGTIME_SCD_PF0 SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_MIN,SEGTIME_SCD_PF0	; * MINIMUM TIME OF THE ABOVE + 1
      1  0000 ????			   SEGTIME_SCD_MIN SET	SEGTIME_SCD_PF0
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_MIN =	0
     72  0000 ????
     73  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
     74  0000 ????			  -	      SEGTIME	SEGTIME_BDF,42	; * 5/8/11 stress tested DHS->DS
     75  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BDF,41	; * 7/8/11
      1  0000 ????			   SEGTIME_BDF SET	41
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
     77  0000 ????				      ENDIF
     78  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BDS,5	; *AD 11/8/11
      1  0000 ????			   SEGTIME_BDS SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME	SEGTIME_DSL,5	; * 9/8/11 unrolled once
      1  0000 ????			   SEGTIME_DSL SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
     81  0000 ????
     82  0000 ????
     83  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SORT_TIME,3	;     157(A)->2.45
      1  0000 ????			   MINIMUM_SORT_TIME SET	3
      2  0000 ????	       00 00	   TEST_MINIMUM_SORT_TIME =	0
     85  0000 ????
     86  0000 ????
     87  0000 ????						;following will lock-up system if used as 'XSEGTIME'.
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIME,4	; processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	4
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
     89  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIMEBLANK,16	;17		 ; * 7/8/11	 993(A)->15.5
      1  0000 ????			   MINIMUM_SEGTIMEBLANK SET	16
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIMEBLANK =	0
     91  0000 ????
     92  0000 ????						; MINIMUM_SEGTIME
     93  0000 ????						; MINIMUM_SEGTIMEBLANK
     94  0000 ????						; SEGTIME_BDF
     95  0000 ????						; SEGTIME_BDS
     96  0000 ????						; SEGTIME_DSL
     97  0000 ????						; SEGTIME_SWITCHOBJECTS
     98  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MINIMUM_TIMESLICE,MINIMUM_SEGTIME+1	; MINIMUM of the TIMESLICE segments listed above
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	MINIMUM_SEGTIME+1
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    100  0000 ????
    101  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    102  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    103  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    104  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    105  0000 ????						; uses ...
    106  0000 ????
    107  0000 ????
    108  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    109  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    110  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    111  0000 ????
    112  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    113  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    114  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,24	;<< using this as XSEGTIME stops player working ...?!
      1  0000 ????			   SEGTIME_MAN SET	24
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE, 10	; drawing circle creature
      1  0000 ????			   SEGTIME_CIRCLE SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE_HELPER, 10	; drawing circle creature's helper
      1  0000 ????			   SEGTIME_CIRCLE_HELPER SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE_HELPER =	0
    118  0000 ????
    119  0000 ????						; TJ: I should only prevent processes with an extra check (e.g. get diamond)
    120  0000 ????
    121  0000 ????						; push BOX is slowest (besides get diamond which has an extra timer check)
    122  0000 ????						; if we add another check for it, SEGTIME_MAN reduces by ~5
    123  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BOX1,5	; ~182 cycles if falling on man + sort overhead!
      1  0000 ????			   SEGTIME_BOX1 SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_BOX1 =	0
      0  0000 ????				      SEGTIME	SEGTIME_BOX3,8	; SEGTIME_BOX4 causes freezes if stressed
      1  0000 ????			   SEGTIME_BOX3 SET	8
      2  0000 ????	       00 00	   TEST_SEGTIME_BOX3 =	0
      0  0000 ????				      SEGTIME	SEGTIME_BOX4,7	;(*) not 100% sure, maybe one more
      1  0000 ????			   SEGTIME_BOX4 SET	7
      2  0000 ????	       00 00	   TEST_SEGTIME_BOX4 =	0
      0  0000 ????				      SEGTIME	SEGTIME_MAGIC,SEGTIME_BOX4 + 2	; tied together (diamond falling through magic wall)
      1  0000 ????			   SEGTIME_MAGIC SET	SEGTIME_BOX4 + 2
      2  0000 ????	       00 00	   TEST_SEGTIME_MAGIC =	0
    128  0000 ????
    129  0000 ????						; the following values have been tested with the STRESS_TIME macro:
    130  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
    131  0000 ????			  -	      SEGTIME	SEGTIME_BIGBANG,34	; TODO* 5/8/11, 1732(B)+218(butterfly)->1940->30.3
    132  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BIGBANG,31	; * 7/8/11
      1  0000 ????			   SEGTIME_BIGBANG SET	31
      2  0000 ????	       00 00	   TEST_SEGTIME_BIGBANG =	0
    134  0000 ????				      ENDIF
      0  0000 ????				      SEGTIME	SEGTIME_EXPLOSION,7	; * 5/8/11
      1  0000 ????			   SEGTIME_EXPLOSION SET	7
      2  0000 ????	       00 00	   TEST_SEGTIME_EXPLOSION =	0
      0  0000 ????				      SEGTIME	SEGTIME_GET_TARGET,17	; * 14/8/11, required if UpdateScore loops (e.g. 9990->10000)
      1  0000 ????			   SEGTIME_GET_TARGET SET	17
      2  0000 ????	       00 00	   TEST_SEGTIME_GET_TARGET =	0
      0  0000 ????				      SEGTIME	SEGTIME_BUTTERFLY,10	; * 7/8/11, 525(B)->8.20
      1  0000 ????			   SEGTIME_BUTTERFLY SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_BUTTERFLY =	0
    138  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_SWITCHOBJECTS,3	; 16/8/11 by calculation. 72 cycles -->  ceil(72/64)+1 --> 3 Object stack switchover
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	3
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
------- FILE ./sokoboo.asm
     16  0000 ????
     17  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     18  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     19  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     20  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     21  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     22  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     23  0000 ????
     24  0000 ????	       00 01	   YES	      =	1
     25  0000 ????	       00 00	   NO	      =	0
     26  0000 ????
     27  0000 ????	       00 00	   DEBUG      =	NO
     28  0000 ????
     29  0000 ????	       00 00	   TJ_MODE    =	NO	; some changes which TJ prefers
     30  0000 ????	       00 01	   AD_MODE    =	YES	; some changes which AD prefers
     31  0000 ????
     32  0000 ????			  -	      IF	TJ_MODE && AD_MODE
     33  0000 ????			  -	      ECHO	"ERROR: Both TJ_MODE and AD_MODE set. Can't do both TJ and AD at the same time!"
     34  0000 ????			  -	      ERR
     35  0000 ????				      ENDIF
     36  0000 ????
     37  0000 ????
     38  0000 ????						; Note: you may also need to change the emulator "-format" switch in the Makefile.
     39  0000 ????
     40  0000 ????			   NTSC_MODE  SET	NO
     41  0000 ????
     42  0000 ????			  -	      IF	TJ_MODE
     43  0000 ????			  -NTSC_MODE  SET	NO	; force NTSC or PAL for difficulty switch
     44  0000 ????				      ENDIF
     45  0000 ????				      IF	AD_MODE
     46  0000 ????			   NTSC_MODE  SET	NO
     47  0000 ????				      ENDIF
     48  0000 ????
     49  0000 ????
     50  0000 ????
     51  0000 ????						;===================================
     52  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     53  0000 ????						;===================================
     54  0000 ????
     55  0000 ????
     56  0000 ????						;===================================
     57  0000 ????			   DEMO_VERSION SET	NO	; force a dual-level playable demo only
     58  0000 ????						;===================================
     59  0000 ????
     60  0000 ????
     61  0000 ????						;-------------------------------------------------------------------------------
     62  0000 ????						; The following should be NO for the final or DEMO version
     63  0000 ????			   TEST_BONUS_COUNTDOWN SET	NO	; causes level A1 to have a special setup for testing the bonus countdown
     64  0000 ????			   F1F2NEXTCAVE SET	NO	; debugging -- F1+F2 will trigger next level. Good to test the progression of level/caves
     65  0000 ????			   CONSTRUCTIONKIT SET	NO	; patch-capable binary for construction kit usage
     66  0000 ????			   SHOWDIAMONDP SET	NO	; debug show diamond on P
     67  0000 ????
     68  0000 ????						;-------------------------------------------------------------------------------
     69  0000 ????						; The following should be YES for the final or DEMO version
     70  0000 ????			   EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
     71  0000 ????						;SPECIAL_ADD_UnpackLevel	   SET YES	   ; causes BOXs and diamonds to be added as falling objects on cave startup
     72  0000 ????
     73  0000 ????						;-------------------------------------------------------------------------------
     74  0000 ????						; The following are optional YES/NO depending on phase of the moon
     75  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     76  0000 ????			   INITIAL_SCROLL SET	NO	; initially scroll board from Rockford's last position
     77  0000 ????						;-------------------------------------------------------------------------------
     78  0000 ????
     79  0000 ????	       00 01	   NUMPLAYERS =	1	; 1-indexed
     80  0000 ????	       00 05	   NUM_LEVELS =	5
     81  0000 ????			   NUM_LIVES  SET	3	; use -1 for unlimited lives
     82  0000 ????
     83  0000 ????			   DEMO_DELAY SET	1	; number of music loops without joystick input before demo kicks in
     84  0000 ????
     85  0000 ????						;-------------------------------------------------------------------------------
     86  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     87  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     88  0000 ????			  -	      IF	FINAL_VERSION = YES
     89  0000 ????			  -DEMO_VERSION SET	NO	; force a dual-level playable demo only
     90  0000 ????			  -TEST_BONUS_COUNTDOWN SET	NO	; causes level A1 to have a special setup for testing the bonus countdown
     91  0000 ????			  -F1F2NEXTCAVE SET	NO	; debugging -- F1+F2 will trigger next level. Good to test the progression of level/caves
     92  0000 ????			  -CONSTRUCTIONKIT SET	NO	; patch-capable binary for construction kit usage
     93  0000 ????			  -EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
     94  0000 ????			  -			;SPECIAL_ADD_UnpackLevel	   SET YES	   ; causes BOXs and diamonds to be added as falling objects on cave startup
     95  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     96  0000 ????			  -SHOWDIAMONDP SET	NO	; debug show diamond on P
     97  0000 ????			  -
     98  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
     99  0000 ????			  -DEMO_DELAY SET	2	; number of music loops without joystick input before demo kicks in
    100  0000 ????			  -NTSC_MODE  SET	YES	; mmh
    101  0000 ????				      ENDIF
    102  0000 ????
    103  0000 ????			  -	      IF	DEMO_VERSION = YES
    104  0000 ????			  -TEST_BONUS_COUNTDOWN SET	NO	; causes level A1 to have a special setup for testing the bonus countdown
    105  0000 ????			  -F1F2NEXTCAVE SET	NO	; debugging -- F1+F2 will trigger next level. Good to test the progression of level/caves
    106  0000 ????			  -CONSTRUCTIONKIT SET	NO	; patch-capable binary for construction kit usage
    107  0000 ????			  -EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
    108  0000 ????			  -SORT_OBJECTS SET	NO	; Warning: can be slow on complex screens
    109  0000 ????			  -			;SPECIAL_ADD_UnpackLevel	   SET YES	   ; causes BOXs and diamonds to be added as falling objects on cave startup
    110  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
    111  0000 ????			  -SHOWDIAMONDP SET	NO	; debug show diamond on P
    112  0000 ????			  -
    113  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
    114  0000 ????			  -DEMO_DELAY SET	2	; number of music loops without joystick input before demo kicks in
    115  0000 ????			  -NTSC_MODE  SET	YES	; mmh
    116  0000 ????				      ENDIF
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------------------------------
    119  0000 ????
    120  0000 ????						;SHOW_TITLE			  SET YES	  ; NOW *REQUIRED* FOR CAVE/LEVEL SELECTION!!!
    121  0000 ????
    122  0000 ????
    123  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
    124  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
    125  0000 ????
    126  0000 ????
    127  0000 ????	       00 01	   PUSH_LIMIT =	1	; slowdown when pushing on a BOX
    128  0000 ????
    129  0000 ????						; POS_VAR flags:
    130  0000 ????	       00 20	   VAR_ON_TARGET =	%00100000	; object is 'standing' on diamond
    131  0000 ????
    132  0000 ????						; time bonus countdown constants:
    133  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
    134  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
    135  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
    136  0000 ????
    137  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    138  0000 ????
    139  0000 ????	       00 03	   FACE_LEFT  =	3
    140  0000 ????
    141  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
    142  0000 ????
    143  0000 ????						;scoring flags contants:
    144  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
    145  0000 ????	       00 00	   DISPLAY_TIME =	%00
    146  0000 ????	       00 01	   DISPLAY_SCORE =	%01
    147  0000 ????	       00 02	   DISPLAY_LIVES =	%10
    148  0000 ????	       00 03	   DISPLAY_HIGH =	%11
    149  0000 ????	       00 40	   EXTRA_100_TARGETS =	$40	; set if more than 100 extra diamonds collected
    150  0000 ????	       00 80	   EXTRA_TARGETS =	$80	; set if collecting extra diamonds
    151  0000 ????
    152  0000 ????						;------------------------------------------------------------------------------
    153  0000 ????
    154  0000 ????	       00 01	   MIRRORED_BOX =	YES
    155  0000 ????	       00 01	   MIRRORED_STEEL =	YES
    156  0000 ????	       00 01	   MIRRORED_WALL =	YES
    157  0000 ????
    158  0000 ????						;------------------------------------------------------------------------------
    159  0000 ????
    160  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    161  0000 ????
    162  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    163  0000 ????	       00 15	   LINES_PER_CHAR =	21	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    164  0000 ????
    165  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    166  0000 ????
    167  0000 ????
    168  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    169  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    170  0000 ????
    171  0000 ????
    172  0000 ????						; color constants:
    173  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    174  0000 ????
    175  0000 ????	       00 10	   YELLOW_NTSC =	$10
    176  0000 ????	       00 20	   YELLOW_PAL =	$20
    177  0000 ????
    178  0000 ????
    179  0000 ????	       10 00	   RAM_3E     =	$1000
    180  0000 ????	       04 00	   RAM_SIZE   =	$400
    181  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    182  0000 ????
    183  0000 ????
    184  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    185  0000 ????
    186  0000 ????
    187  0000 ????						; Platform constants:
    188  0000 ????	       00 02	   PAL	      =	%10
    189  0000 ????	       00 02	   PAL_50     =	PAL|0
    190  0000 ????	       00 03	   PAL_60     =	PAL|1
    191  0000 ????
    192  0000 ????
    193  0000 ????				      IF	L276
    194  0000 ????	       00 3e	   VBLANK_TIM_NTSC =	62	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    195  0000 ????			  -	      ELSE
    196  0000 ????			  -VBLANK_TIM_NTSC =	45	; NTSC 262
    197  0000 ????				      ENDIF
    198  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    199  0000 ????
    200  0000 ????				      IF	L276
    201  0000 ????	       00 33	   OVERSCAN_TIM_NTSC =	51	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    202  0000 ????			  -	      ELSE
    203  0000 ????			  -OVERSCAN_TIM_NTSC =	51	; NTSC 262
    204  0000 ????				      ENDIF
    205  0000 ????	       00 46	   OVERSCAN_TIM_PAL =	70	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    206  0000 ????
    207  0000 ????				      IF	L276
    208  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    209  0000 ????			  -	      ELSE
    210  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    211  0000 ????				      ENDIF
    212  0000 ????	       01 38	   SCANLINES_PAL =	312
    213  0000 ????
    214  0000 ????
    215  0000 ????						;------------------------------------------------------------------------------
    216  0000 ????						; MACRO definitions
    217  0000 ????
    218  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    219  0000 ????
    220  0000 ????				      MAC	newbank
    221  0000 ????				      SEG	{1}
    222  0000 ????				      ORG	ORIGIN
    223  0000 ????				      RORG	$F000
    224  0000 ????			   BANK_START SET	*
    225  0000 ????			   {1}	      SET	ORIGIN / 2048
    226  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    227  0000 ????			   _CURRENT_BANK SET	{1}
    228  0000 ????				      ENDM		; bank name
    229  0000 ????
    230  0000 ????				      MAC	define_1k_segment
    231  0000 ????				      ALIGN	$400
    232  0000 ????			   SEGMENT_{1} SET	*
    233  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    234  0000 ????				      ENDM		; {seg name}
    235  0000 ????
    236  0000 ????				      MAC	check_bank_size
    237  0000 ????			   .TEMP      =	* - BANK_START
    238  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    239  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    240  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    241  0000 ????				      ERR
    242  0000 ????				      endif
    243  0000 ????				      ENDM		; name
    244  0000 ????
    245  0000 ????
    246  0000 ????				      MAC	check_half_bank_size
    247  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    248  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    249  0000 ????			   .TEMP      =	* - BANK_START
    250  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    251  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    252  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    253  0000 ????				      ERR
    254  0000 ????				      endif
    255  0000 ????				      ENDM		; name
    256  0000 ????
    257  0000 ????
    258  0000 ????				      MAC	overlay
    259  0000 ????				      SEG.U	OVERLAY_{1}
    260  0000 ????				      org	Overlay
    261  0000 ????				      ENDM		; {name}
    262  0000 ????
    263  0000 ????						;--------------------------------------------------------------------------
    264  0000 ????
    265  0000 ????				      MAC	validate_overlay
    266  0000 ????				      LIST	OFF
    267  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    268  0000 ????				      ERR
    269  0000 ????				      endif
    270  0000 ????				      LIST	ON
    271  0000 ????				      ENDM
    272  0000 ????
    273  0000 ????						;--------------------------------------------------------------------------
    274  0000 ????						; Macro inserts a page break if the object would overlap a page
    275  0000 ????
    276  0000 ????				      MAC	optional_pagebreak
    277  0000 ????				      LIST	OFF
    278  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    279  0000 ????			   EARLY_LOCATION SET	*
    280  0000 ????				      ALIGN	256
    281  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    282  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    283  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    284  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    285  0000 ????				      ENDIF
    286  0000 ????				      LIST	ON
    287  0000 ????				      ENDM		; { string, size }
    288  0000 ????
    289  0000 ????
    290  0000 ????				      MAC	check_page_crossing
    291  0000 ????				      LIST	OFF
    292  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    293  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    294  0000 ????				      endif
    295  0000 ????				      LIST	ON
    296  0000 ????				      ENDM
    297  0000 ????
    298  0000 ????				      MAC	checkpage
    299  0000 ????				      LIST	OFF
    300  0000 ????				      IF	>. != >{1}
    301  0000 ????				      ECHO	""
    302  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    303  0000 ????				      ECHO	""
    304  0000 ????				      ERR
    305  0000 ????				      ENDIF
    306  0000 ????				      LIST	ON
    307  0000 ????				      ENDM
    308  0000 ????
    309  0000 ????				      MAC	checkpagex
    310  0000 ????				      LIST	OFF
    311  0000 ????				      IF	>. != >{1}
    312  0000 ????				      ECHO	""
    313  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    314  0000 ????				      ECHO	{2}
    315  0000 ????				      ECHO	""
    316  0000 ????				      ERR
    317  0000 ????				      ENDIF
    318  0000 ????				      LIST	ON
    319  0000 ????				      ENDM
    320  0000 ????
    321  0000 ????
    322  0000 ????				      MAC	checkpage_bne
    323  0000 ????				      LIST	OFF
    324  0000 ????				      IF	0	;>(. + 2) != >{1}
    325  0000 ????				      ECHO	""
    326  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    327  0000 ????				      ECHO	""
    328  0000 ????				      ERR
    329  0000 ????				      ENDIF
    330  0000 ????				      LIST	ON
    331  0000 ????				      bne	{1}
    332  0000 ????				      ENDM
    333  0000 ????
    334  0000 ????				      MAC	checkpage_bpl
    335  0000 ????				      LIST	OFF
    336  0000 ????				      IF	(>(.+2 )) != >{1}
    337  0000 ????				      ECHO	""
    338  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    339  0000 ????				      ECHO	""
    340  0000 ????				      ERR
    341  0000 ????				      ENDIF
    342  0000 ????				      LIST	ON
    343  0000 ????				      bpl	{1}
    344  0000 ????				      ENDM
    345  0000 ????
    346  0000 ????				      MAC	align_free
    347  0000 ????			   FREE       SET	FREE - .
    348  0000 ????				      align	{1}
    349  0000 ????			   FREE       SET	FREE + .
    350  0000 ????				      echo	"@", ., ":", FREE
    351  0000 ????				      ENDM
    352  0000 ????
    353  0000 ????				      MAC	stress_time
    354  0000 ????				      IF	TEST_{1} = 1
    355  0000 ????
    356  0000 ????
    357  0000 ????						;LIST OFF
    358  0000 ????						; has to be put *directly* after cmp #SEGTIME_... , bcc abort
    359  0000 ????						;LIST ON
    360  0000 ????				      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
    361  0000 ????				      bne	. - 7	; branches to lda INTIM
    362  0000 ????				      ENDIF
    363  0000 ????				      ENDM
    364  0000 ????
    365  0000 ????			   IDENTITY   SET	0
    366  0000 ????				      MAC	ident
    367  0000 ????				      if	DEBUG=YES
    368  0000 ????				      lda	#IDENTITY
    369  0000 ????				      sta	debug_ident
    370  0000 ????				      lda	{1}
    371  0000 ????				      sta	debug_object
    372  0000 ????				      endif
    373  0000 ????			   IDENTITY   SET	IDENTITY + 1
    374  0000 ????				      ENDM		; {object}
    375  0000 ????
    376  0000 ????						;--------------------------------------------------------------------------
    377  0000 ????
    378  0000 ????				      MAC	vector
    379  0000 ????				      .word	{1}
    380  0000 ????				      ENDM		; just a word pointer to code
    381  0000 ????
    382  0000 ????
    383  0000 ????				      MAC	define_subroutine
    384  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    385  0000 ????				      SUBROUTINE		; keep everything local
    386  0000 ????			   {1}			; entry point
    387  0000 ????				      ENDM		; name of subroutine
    388  0000 ????
    389  0000 ????
    390  0000 ????
    391  0000 ????						;--------------------------------------------------------------------------
    392  0000 ????
    393  0000 ????				      MAC	newrambank
    394  0000 ????				      SEG.U	{1}
    395  0000 ????				      ORG	ORIGIN
    396  0000 ????				      RORG	RAM_3E
    397  0000 ????			   BANK_START SET	*
    398  0000 ????			   {1}	      SET	ORIGIN / RAM_SIZE
    399  0000 ????			   ORIGIN     SET	ORIGIN + RAM_SIZE
    400  0000 ????				      ENDM		; bank name
    401  0000 ????
    402  0000 ????				      MAC	validate_ram_size
    403  0000 ????				      if	* - RAM_3E > RAM_SIZE
    404  0000 ????				      ERR
    405  0000 ????				      endif
    406  0000 ????				      ENDM
    407  0000 ????
    408  0000 ????				      MAC	next_random
    409  0000 ????						; update random value:
    410  0000 ????				      lda	rnd	; 3
    411  0000 ????				      lsr		; 2
    412  0000 ????				      IFCONST	rndHi
    413  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    414  0000 ????				      ENDIF
    415  0000 ????				      bcc	.skipEOR	; 2/3
    416  0000 ????				      eor	#RND_EOR_VAL	; 2
    417  0000 ????			   .skipEOR
    418  0000 ????				      sta	rnd	; 3 = 14/19
    419  0000 ????				      ENDM
    420  0000 ????
    421  0000 ????				      MAC	resync
    422  0000 ????						; resync screen, X and Y == 0 afterwards
    423  0000 ????				      lda	#%10	; make sure VBLANK is ON
    424  0000 ????				      sta	VBLANK
    425  0000 ????
    426  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    427  0000 ????			   .loopResync
    428  0000 ????				      VERTICAL_SYNC
    429  0000 ????
    430  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    431  0000 ????				      lda	Platform
    432  0000 ????				      eor	#PAL_50	; PAL-50?
    433  0000 ????				      bne	.ntsc
    434  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    435  0000 ????			   .ntsc
    436  0000 ????			   .loopWait
    437  0000 ????				      sta	WSYNC
    438  0000 ????				      sta	WSYNC
    439  0000 ????				      dey
    440  0000 ????				      bne	.loopWait
    441  0000 ????				      dex
    442  0000 ????				      bne	.loopResync
    443  0000 ????				      ENDM
    444  0000 ????
    445  0000 ????				      MAC	set_platform
    446  0000 ????						; 00 = NTSC
    447  0000 ????						; 01 = NTSC
    448  0000 ????						; 10 = PAL-50
    449  0000 ????						; 11 = PAL-60
    450  0000 ????				      lda	SWCHB
    451  0000 ????				      rol
    452  0000 ????				      rol
    453  0000 ????				      rol
    454  0000 ????				      and	#%11
    455  0000 ????				      if	NTSC_MODE = NO
    456  0000 ????				      eor	#PAL
    457  0000 ????				      endif
    458  0000 ????				      lda	#0	;tmp
    459  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    460  0000 ????				      ENDM
    461  0000 ????
    462  0000 ????						;  IF TJ_MODE
    463  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM ; = 29
    464  0000 ????						;	  ldy #{1}			  ; 2	  read bank
    465  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    466  0000 ????						;	  jsr GetRAMByteFromRAM 	  ;25
    467  0000 ????						;    ENDM
    468  0000 ????						;
    469  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM ; = 30
    470  0000 ????						;	  ldy #{1}			  ; 2	  write bank
    471  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    472  0000 ????						;	  jsr PutRAMByteFromRAM 	  ;26
    473  0000 ????						;    ENDM
    474  0000 ????						;
    475  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM_ADR ; = 39
    476  0000 ????						;	  ldx #<{1}			  ; 2
    477  0000 ????						;	  stx addressR			  ; 3
    478  0000 ????						;	  ldx #>{1}			  ; 2
    479  0000 ????						;	  stx addressR+1		  ; 3
    480  0000 ????						;	  GET_RAM_BYTE_FROM_RAM {2}, {3}  ;29
    481  0000 ????						;    ENDM
    482  0000 ????						;
    483  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM_ADR ; = 40
    484  0000 ????						;	  ldx #<{1}			  ; 2
    485  0000 ????						;	  stx addressW			  ; 3
    486  0000 ????						;	  ldx #>({1}+RAM_WRITE) 	  ; 2
    487  0000 ????						;	  stx addressW+1		  ; 3
    488  0000 ????						;	  PUT_RAM_BYTE_FROM_RAM {2}, {3}  ;30
    489  0000 ????						;    ENDM
    490  0000 ????						;  ENDIF
    491  0000 ????
    492  0000 ????				      MAC	nop_b
    493  0000 ????				      .byte	$82
    494  0000 ????				      ENDM		; unused
    495  0000 ????
    496  0000 ????				      MAC	nop_w
    497  0000 ????				      .byte	$0c
    498  0000 ????				      ENDM
    499  0000 ????
    500  0000 ????						;------------------------------------------------------------------------------
    501  0000 ????
    502  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????
      2 U00fa ????				      SEG.U	variables
      3 U0080					      ORG	$80
      4 U0080
      5 U0080
      6 U0080		       00 40	   GAMEMODE_2600 =	64
      7 U0080		       00 80	   GAMEMODE_PAUSED =	128
      8 U0080
      9 U0080		       00	   gameMode   ds	1	; bit7=0: 7800; bit7=1: 2600.	bit 6=1: paused: bit3: toggle bit for B/W
     10 U0081		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     11 U0082							; above variables are preserved ALL the time!
     12 U0082
     13 U0082		       00	   rnd	      ds	1
     14 U0083		       00	   rndHi      ds	1	; to get better random values
     15 U0084
     16 U0084		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     17 U0085		       00	   ObjStackNum ds	1	; which stack in use
     18 U0086		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     19 U0088		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     20 U0089		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     21 U008a
     22 U008a		       00	   POS_X      ds	1
     23 U008b		       00	   POS_Y      ds	1
     24 U008c		       00	   POS_X_NEW  ds	1
     25 U008d		       00	   POS_Y_NEW  ds	1
     26 U008e		       00	   POS_Type   ds	1
     27 U008f		       00	   POS_VAR    ds	1
     28 U0090
     29 U0090		       00 00	   BufferedJoystick ds	2	; player joystick input
     30 U0092		       00	   BufferedButton ds	1	; player button press
     31 U0093
     32 U0093							; Scrolling is limited to only show board within the following area...
     33 U0093		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in UnpackLevel)
     34 U0094		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in UnpackLevel)
     35 U0095		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     36 U0096		       00	   BoardScrollX ds	1	; scroll position in board (X)
     37 U0096		       00 93	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     38 U0096		       00 94	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     39 U0097		       00	   scrollBits ds	1
     40 U0098
     41 U0098							;MagicAmoebaFlag		  ds 1	      ; status of magic wall and amoeba
     42 U0098
     43 U0098		       00	   whichPlayer ds	1	; 0 = P1, 1 = P2
     44 U0099
     45 U0099		       00	   ManX       ds	1
     46 U009a		       00	   ManY       ds	1
     47 U009b		       00	   ManDrawX   ds	1
     48 U009c		       00	   ManDrawY   ds	1
     49 U009d		       00	   ManMode    ds	1
     50 U009e		       00	   ManDelayCount ds	1
     51 U009f		       00 00	   ManAnimation ds	2
     52 U00a1		       00	   ManAnimationFrameLO ds	1
     53 U00a2		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     54 U00a3		       00	   ManPushCounter ds	1
     55 U00a4		       00	   LookingAround ds	1
     56 U00a5		       00	   ManCount   ds	1	; player life counter
     57 U00a6		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     58 U00a7		       00 00	   circle_d   ds	2
     59 U00a9		       00	   circ_x     ds	1
     60 U00aa		       00	   circ_y     ds	1
     61 U00ab		       00	   circ_char  ds	1
     62 U00ac		       00	   circ_scratch ds	1
     63 U00ad		       00	   cave_bank  ds	1
     64 U00ae							;---------------------------------------------------------------------------
     65 U00ae							; 2 (shared) demo mode variables:
     66 U00ae		       00 a6	   demoMode   =	jtoggle	; bit 7==1 => demo mode
     67 U00ae		       00 a6	   moveLen    =	jtoggle	; bits 0..6
     68 U00ae		       00 98	   moveIdx    =	whichPlayer
     69 U00ae
     70 U00ae		       00	   LastSpriteY ds	1
     71 U00af
     72 U00af		       00	   timer      ds	1
     73 U00b0
     74 U00b0		       00	   BGColour   ds	1
     75 U00b1
     76 U00b1							; cave and level have to be consecutive variables!
     77 U00b1		       00	   cave       ds	1	; current player's cave (other in scoring bank)
     78 U00b2		       00	   level      ds	1	; current player's level (other in scoring bank)
     79 U00b3		       00	   levelDisplay ds	1	; what to display as the cave ID
     80 U00b4		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
     81 U00b5		       00	   ThrottleSpeed ds	1	; system-dependant throttle speed
     82 U00b6
     83 U00b6							;magicAmoebaTime		  ds 1		  ; time for magic wall and amoeba slow growth
     84 U00b6		       00	   targetsRequired ds	1	; TJ: changed that (NOTE: counts down to 0 then (negatively) UP to give extra diamonds found.)
     85 U00b7							;diamondsWorth 		  ds 1		  ; TJ: could be moved to Scoring Bank
     86 U00b7							;diamondsExtraWorth		  ds 1		  ; TJ: could be moved to Scoring Bank
     87 U00b7		       00	   caveTime   ds	1	; BCD seconds for level
     88 U00b8		       00	   caveTimeHi ds	1
     89 U00b9		       00	   caveTimeFrac ds	1
     90 U00ba		       00 00 00    color      ds	3	; RGB for NTSC, RGB for PAL
     91 U00bd		       00 00	   Board_AddressR ds	2
     92 U00bf		       00 00	   Board_AddressW ds	2
     93 U00c1		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
     94 U00c2		       00	   RAM_Bank   ds	1
     95 U00c3
     96 U00c3							;  IF TJ_MODE
     97 U00c3							;addressR			  = Board_AddressR
     98 U00c3							;addressW			  = Board_AddressW
     99 U00c3							;  ENDIF
    100 U00c3
    101 U00c3		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
    102 U00c4		       00	   extraLifeTimer ds	1	; should be 5 seconds!
    103 U00c5
    104 U00c5							; extraLifeTimer:
    105 U00c5							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    106 U00c5
    107 U00c5		       00	   scoringTimer ds	1	; times the various score displays
    108 U00c6		       00	   scoringFlags ds	1	; scoring flags are stored here
    109 U00c7
    110 U00c7							; scoringFlags:
    111 U00c7							; D7		 Extra diamonds in effect (diamonds collected over requirement score more) ASSUMED BPL/BMI usage
    112 U00c7							; D6		 unused
    113 U00c7							; D5		 unused
    114 U00c7							; D4		 unused
    115 U00c7							; D3		 unused
    116 U00c7							; D2		 unused
    117 U00c7							; D1	 D1-D0	 Which display kernel to use for scoring
    118 U00c7							; D0		 0 = 2x4     used for diamonds/time
    119 U00c7							;		 1 = 1x6     used for score
    120 U00c7							;		 2 = 3x2     used for level/lives/player
    121 U00c7
    122 U00c7		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    123 U00c7		       00 80	   BIT_NEXTLEVEL =	128
    124 U00c7		       00 40	   BIT_NEXTLIFE =	64
    125 U00c7		       00 01	   BIT_GOTOLOGO =	1
    126 U00c8
    127 U00c8							;amoebaX			  ds 1	      ; x-pos of currently scanned cell
    128 U00c8							;amoebaY			  ds 1	      ; y-pos of currently scanned cell
    129 U00c8							;amoebaFlag			  ds 1	      ; current status of amoeba
    130 U00c8
    131 U00c8							; constants for amoebaFlag:
    132 U00c8		       00 01	   NOT_ENCLOSED =	%00000001	;
    133 U00c8		       00 02	   SCAN_FINISHED =	%00000010	; indicates that one scan finished and the next one has to wait
    134 U00c8		       00 20	   FINISHEDDIAMOND =	%00100000	;
    135 U00c8		       00 40	   AMOEBA_PRESENT =	%01000000	; set during the very first amoeba object init
    136 U00c8		       00 80	   TODIAMOND  =	%10000000	;
    137 U00c8
    138 U00c8							;---------------------------------------------------------------------------
    139 U00c8
    140 U00c8		       00	   sortRequired ds	1
    141 U00c9		       00	   sortPtr    ds	1
    142 U00ca
    143 U00ca							;---------------------------------------------------------------------------
    144 U00ca							; sound driver needs 6 bytes:
    145 U00ca		       00 00	   soundIdxLst ds	2	; index of current sound
    146 U00cc		       00 00	   decayIdxLst ds	2	; index of current note
    147 U00ce		       00 00	   decayTimeLst ds	2	; remaining lenght of current note
    148 U00ce		       00 cc	   soundBonusPts =	decayIdxLst	; shared, used for bonus points count down (channel 0!)
    149 U00d0		       00	   newSounds  ds	1
    150 U00d1
    151 U00d1							;------------------------------------------------------------------------------
    152 U00d1
    153 U00d1		       00	   ObjIterator ds	1	; count UP iterator over objects
    154 U00d2		       00	   DSL	      ds	1	; stack line counter
    155 U00d3
------- FILE sound/intro1_variables.asm LEVEL 3 PASS 3
      0 U00d3					      include	"sound/intro1_variables.asm"
      1 U00d3							; TIATracker music player
      2 U00d3							; Copyright 2016 Andre "Kylearan" Wichmann
      3 U00d3							; Website: https://bitbucket.org/kylearan/tiatracker
      4 U00d3							; Email: andre.wichmann@gmx.de
      5 U00d3							;
      6 U00d3							; Licensed under the Apache License, Version 2.0 (the "License");
      7 U00d3							; you may not use this file except in compliance with the License.
      8 U00d3							; You may obtain a copy of the License at
      9 U00d3							;
     10 U00d3							;   http://www.apache.org/licenses/LICENSE-2.0
     11 U00d3							;
     12 U00d3							; Unless required by applicable law or agreed to in writing, software
     13 U00d3							; distributed under the License is distributed on an "AS IS" BASIS,
     14 U00d3							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15 U00d3							; See the License for the specific language governing permissions and
     16 U00d3							; limitations under the License.
     17 U00d3
     18 U00d3							; Song author: 
     19 U00d3							; Song name: 
     20 U00d3
     21 U00d3							; @com.wudsn.ide.asm.hardware=ATARI2600
     22 U00d3
     23 U00d3							; =====================================================================
     24 U00d3							; Flags
     25 U00d3							; =====================================================================
     26 U00d3
     27 U00d3							; 1: Global song speed, 0: Each pattern has individual speed
     28 U00d3		       00 01	   TT_GLOBAL_SPEED =	1
     29 U00d3							; duration (number of TV frames) of a note
     30 U00d3		       00 05	   TT_SPEED   =	5
     31 U00d3							; duration of odd frames (needs TT_USE_FUNKTEMPO)
     32 U00d3		       00 04	   TT_ODD_SPEED =	4
     33 U00d3
     34 U00d3							; 1: Overlay percussion, +40 bytes
     35 U00d3		       00 01	   TT_USE_OVERLAY =	1
     36 U00d3							; 1: Melodic instrument slide, +9 bytes
     37 U00d3		       00 00	   TT_USE_SLIDE =	0
     38 U00d3							; 1: Goto pattern, +8 bytes
     39 U00d3		       00 01	   TT_USE_GOTO =	1
     40 U00d3							; 1: Odd/even rows have different SPEED values, +7 bytes
     41 U00d3		       00 01	   TT_USE_FUNKTEMPO =	1
     42 U00d3							; If the very first notes played on each channel are not PAUSE, HOLD or
     43 U00d3							; SLIDE, i.e. if they start with an instrument or percussion, then set
     44 U00d3							; this flag to 0 to save 2 bytes.
     45 U00d3							; 0: +2 bytes
     46 U00d3		       00 01	   TT_STARTS_WITH_NOTES =	1
     47 U00d3
     48 U00d3
     49 U00d3							; =====================================================================
     50 U00d3							; Permanent variables. These are states needed by the player.
     51 U00d3							; =====================================================================
     52 U00d3		       00	   tt_timer   ds	1	; current music timer value
     53 U00d4		       00	   tt_cur_pat_index_c0 ds	1	; current pattern index into tt_SequenceTable
     54 U00d5		       00	   tt_cur_pat_index_c1 ds	1
     55 U00d6		       00	   tt_cur_note_index_c0 ds	1	; note index into current pattern
     56 U00d7		       00	   tt_cur_note_index_c1 ds	1
     57 U00d8		       00	   tt_envelope_index_c0 ds	1	; index into ADSR envelope
     58 U00d9		       00	   tt_envelope_index_c1 ds	1
     59 U00da		       00	   tt_cur_ins_c0 ds	1	; current instrument
     60 U00db		       00	   tt_cur_ins_c1 ds	1
     61 U00dc
     62 U00dc
     63 U00dc							; =====================================================================
     64 U00dc							; Temporary variables. These will be overwritten during a call to the
     65 U00dc							; player routine, but can be used between calls for other things.
     66 U00dc							; =====================================================================
     67 U00dc		       00 00	   tt_ptr     ds	2
------- FILE zeropage.asm
    157 U00de
    158 U00de
    159 U00de
    160 U00de				   OVERLAY_SIZE SET	16
    161 U00de
    162 U00de
    163 U00de
    164 U00de							; This overlay variable is used for the overlay variables.  That's OK.
    165 U00de							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    166 U00de							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    167 U00de							; (especially the latter ones) are only used in rare occasions.
    168 U00de
    169 U00de							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    170 U00de							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    171 U00de
    172 U00de		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00ee					      VALIDATE_OVERLAY
      5 U00ee					      LIST	ON
    174 U00ee
    175 U00ee
    176 U00ee		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    177 U00fa
 FREE BYTES IN ZERO PAGE =  $5
    178 U00fa					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    179 U00fa				  -	      IF	* > $FF
    180 U00fa				  -	      ERR
    181 U00fa					      ENDIF
------- FILE ./sokoboo.asm
    504 U00fa
    505 U00fa
    506 U00fa							;------------------------------------------------------------------------------
    507 U00fa							; OVERLAYS!
    508 U00fa							; These variables are overlays, and should be managed with care
    509 U00fa							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    510 U00fa
    511 U00fa							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    512 U00fa							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    513 U00fa
    514 U00fa							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    515 U00fa
    516 U00fa
    517 U00fa
    518 U00fa							;------------------------------------------------------------------------------
      0 U00fa					      OVERLAY	BuildDrawFlags
      1 U00e9 ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00de					      org	Overlay
    520 U00de
    521 U00de		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    522 U00e0		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    523 U00e2		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    524 U00e4		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    525 U00e6							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    526 U00e6		       00	   BDF_BoardBank ds	1	; holds bank of current line
    527 U00e7							;  ENDIF
    528 U00e7		       00	   DHS_Line   ds	1
    529 U00e8		       00	   DHS_Stack  ds	1	; for restoring SP
    530 U00e9							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e9					      VALIDATE_OVERLAY
      5 U00e9					      LIST	ON
    532 U00e9
    533 U00e9							;------------------------------------------------------------------------------
    534 U00e9
      0 U00e9					      OVERLAY	Process
      1 U00e1 ????				      SEG.U	OVERLAY_Process
      2 U00de					      org	Overlay
    536 U00de
    537 U00de		       00	   BOXLeft    ds	1
    538 U00df		       00	   BOXRight   ds	1
    539 U00e0		       00	   restorationCharacter ds	1
    540 U00e1
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    542 U00e1
    543 U00e1							;------------------------------------------------------------------------------
    544 U00e1
      0 U00e1					      OVERLAY	Animate
      1 U00df ????				      SEG.U	OVERLAY_Animate
      2 U00de					      org	Overlay
    546 U00de		       00	   halftimer  ds	1
      0 U00df					      VALIDATE_OVERLAY
      5 U00df					      LIST	ON
    548 U00df
    549 U00df							;------------------------------------------------------------------------------
    550 U00df
      0 U00df					      OVERLAY	TimeSlice
      1 U00e0 ????				      SEG.U	OVERLAY_TimeSlice
      2 U00de					      org	Overlay
    552 U00de
    553 U00de		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    554 U00e0							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    556 U00e0
    557 U00e0							;------------------------------------------------------------------------------
    558 U00e0
      0 U00e0					      OVERLAY	CopyROMShadowToRAM
      1 U00e1 ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00de					      org	Overlay
    560 U00de
    561 U00de		       00	   O_CopyCount ds	1
    562 U00df		       00	   O_ROM_Source_Bank ds	1
    563 U00e0		       00	   O_Index    ds	1
    564 U00e1							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    566 U00e1
    567 U00e1							;------------------------------------------------------------------------------
    568 U00e1
      0 U00e1					      OVERLAY	Scoring
      1 U00e0 ????				      SEG.U	OVERLAY_Scoring
      2 U00de					      org	Overlay
    570 U00de		       00	   tmpStack   ds	1
    571 U00de		       00 de	   newDisplay =	tmpStack
    572 U00df							; also for UpdateTimer
    573 U00df		       00 de	   tmpSound   =	tmpStack
    574 U00df		       00	   timerLoops ds	1
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    576 U00e0
    577 U00e0
    578 U00e0							;------------------------------------------------------------------------------
    579 U00e0
      0 U00e0					      OVERLAY	SaveKey
      1 U00e7 ????				      SEG.U	OVERLAY_SaveKey
      2 U00de					      org	Overlay
    581 U00de
    582 U00de		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    583 U00e1		       00 00 00    highScoreSK ds	3
    584 U00e4		       00	   startCave  ds	1	; cave * 5
    585 U00e5		       00	   startLevel ds	1
    586 U00e6		       00	   offsetSK   ds	1	; for calculating the SK slot address
    587 U00e7
      0 U00e7					      VALIDATE_OVERLAY
      5 U00e7					      LIST	ON
    589 U00e7
    590 U00e7							;------------------------------------------------------------------------------
    591 U00e7
      0 U00e7					      OVERLAY	DrawMan
      1 U00e0 ????				      SEG.U	OVERLAY_DrawMan
      2 U00de					      org	Overlay
    593 U00de
    594 U00de		       00 00	   MAN_Move   ds	2
    595 U00e0
    596 U00e0							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    598 U00e0
    599 U00e0							;------------------------------------------------------------------------------
    600 U00e0
      0 U00e0					      OVERLAY	ProcessObjStack
      1 U00e0 ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00de					      org	Overlay
    602 U00de
    603 U00de		       00 00	   POS_Vector ds	2
    604 U00e0
    605 U00e0							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    607 U00e0
    608 U00e0							;------------------------------------------------------------------------------
      0 U00e0					      OVERLAY	Surround
      1 U00e6 ????				      SEG.U	OVERLAY_Surround
      2 U00de					      org	Overlay
    610 U00de		       00 00	   Temp_Board_Address1 ds	2
    611 U00e0		       00 00	   Temp_Board_Address2 ds	2
    612 U00e2		       00 00	   Temp_Board_Address3 ds	2
    613 U00e4							;    IF MULTI_BANK_BOARD = YES 	 ; commented, else DASM freaks out
    614 U00e4		       00	   Temp_Bank2 ds	1
    615 U00e5		       00	   Temp_Bank3 ds	1
    616 U00e6							;    ENDIF
    617 U00e6
    618 U00e6							;ECHO "FREE BYTES IN OVERLAY_Surround = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e6					      VALIDATE_OVERLAY
      5 U00e6					      LIST	ON
    620 U00e6							;------------------------------------------------------------------------------
    621 U00e6
      0 U00e6					      OVERLAY	ScoreLineOverlay
      1 U00ed ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00de					      org	Overlay
    623 U00de
    624 U00de		       00 00	   S0	      ds	2	; used for addressing digits of score
    625 U00e0		       00 00	   S1	      ds	2
    626 U00e2		       00 00	   S2	      ds	2
    627 U00e4		       00 00	   S3	      ds	2
    628 U00e6		       00 00	   S4	      ds	2
    629 U00e8		       00 00	   S5	      ds	2
    630 U00ea
    631 U00ea		       00	   stkp       ds	1
    632 U00eb		       00	   sreg       ds	1
    633 U00ec		       00	   loop       ds	1
    634 U00ed
    635 U00ed							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00ed					      VALIDATE_OVERLAY
      5 U00ed					      LIST	ON
    637 U00ed
    638 U00ed							;------------------------------------------------------------------------------
    639 U00ed
    640 U00ed
      0 U00ed					      OVERLAY	UnpackLevelOverlay
      1 U00ee ????				      SEG.U	OVERLAY_UnpackLevelOverlay
      2 U00de					      org	Overlay
    642 U00de
    643 U00de							; used everywhere
    644 U00de		       00 00 00 00 ptrCave    ds	4	; two pointers
    645 U00e2
    646 U00e2		       00	   randSeed1  ds	1
    647 U00e3		       00	   randSeed2  ds	1
    648 U00e4		       00	   tempRand1  ds	1
    649 U00e5		       00	   tempRand2  ds	1
    650 U00e6		       00	   tmpScore   ds	1
    651 U00e7
    652 U00e7		       00	   base_x     ds	1
    653 U00e8		       00	   base_y     ds	1
    654 U00e9		       00	   upk_length ds	1
    655 U00ea		       00	   upk_column ds	1
    656 U00eb		       00	   upk_temp   ds	1
    657 U00ec
    658 U00ec							;------------------------------------------------------------------------------
    659 U00ec
    660 U00ec		       00	   object     ds	1
    661 U00ec		       00 e2	   structType =	randSeed1
    662 U00ec		       00 e3	   column     =	randSeed2
    663 U00ec		       00 e4	   row	      =	tempRand1
    664 U00ec		       00 e5	   length     =	tempRand2
    665 U00ec		       00 e0	   height     =	ptrCave+2
    666 U00ec		       00 e1	   direction  =	ptrCave+3
    667 U00ed		       00	   tmpLength  ds	1
    668 U00ee
    669 U00ee							;ECHO "FREE BYTES IN UnpackLevelOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00ee					      VALIDATE_OVERLAY
      5 U00ee					      LIST	ON
    671 U00ee
    672 U00ee							;------------------------------------------------------------------------------
    673 U00ee
      0 U00ee					      OVERLAY	Copyright
      1 U00e4 ????				      SEG.U	OVERLAY_Copyright
      2 U00de					      org	Overlay
    675 U00de		       00	   LoopCount  ds	1
    676 U00df		       00	   colorBK    ds	1
    677 U00e0		       00 00	   Temp       ds	2
    678 U00e2		       00	   CopyTime   ds	1
    679 U00e3		       00	   saveSP     ds	1
      0 U00e4					      VALIDATE_OVERLAY
      5 U00e4					      LIST	ON
    681 U00e4
      0 U00e4					      OVERLAY	ManProcessing
      1 U00e0 ????				      SEG.U	OVERLAY_ManProcessing
      2 U00de					      org	Overlay
    683 U00de		       00 00	   actionVector ds	2
      0 U00e0					      VALIDATE_OVERLAY
      5 U00e0					      LIST	ON
    685 U00e0
      0 U00e0					      OVERLAY	CaveDecode
      1 U00df ????				      SEG.U	OVERLAY_CaveDecode
      2 U00de					      org	Overlay
    687 U00de		       00	   savex      ds	1
      0 U00df					      VALIDATE_OVERLAY
      5 U00df					      LIST	ON
    689 U00df
    690 U00df
      0 U00df					      OVERLAY	TJSound
      1 U00e3 ????				      SEG.U	OVERLAY_TJSound
      2 U00de					      org	Overlay
    692 U00de							; temps (overlay these with existing temps to save RAM)
    693 U00de		       00	   musicTemp  ds	1
    694 U00df		       00	   musicTemp16L ds	1
    695 U00e0		       00	   musicTemp16H ds	1
    696 U00e1		       00	   musicAtten ds	1
    697 U00e2		       00	   tmpVar     ds	1
      0 U00e3					      VALIDATE_OVERLAY
      5 U00e3					      LIST	ON
    699 U00e3
      0 U00e3					      OVERLAY	SetPlatformColours
      1 U00df ????				      SEG.U	OVERLAY_SetPlatformColours
      2 U00de					      org	Overlay
    701 U00de		       00	   colorIdx   ds	1
      0 U00df					      VALIDATE_OVERLAY
      5 U00df					      LIST	ON
    703 U00df
      0 U00df					      OVERLAY	SwapPlayers
      1 U00df ????				      SEG.U	OVERLAY_SwapPlayers
      2 U00de					      org	Overlay
    705 U00de		       00	   tmpX       ds	1
      0 U00df					      VALIDATE_OVERLAY
      5 U00df					      LIST	ON
    707 U00df
      0 U00df					      OVERLAY	DrawIntoStack
      1 U00df ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00de					      org	Overlay
    709 U00de		       00	   save_SP    ds	1
      0 U00df					      VALIDATE_OVERLAY
      5 U00df					      LIST	ON
    711 U00df
    712 U00df
    713 U00df							;------------------------------------------------------------------------------
    714 U00df							;##############################################################################
    715 U00df							; TITLE SCREEN VARS
    716 U00df							;------------------------------------------------------------------------------
    717 U00df
    718 U00df		       00 21	   NUM_BLOCKS =	33	; number of text graphics blocks
    719 U00df		       00 04	   BLOCK_H    =	4	; height of the text graphics blocks
    720 U00df		       00 08	   BORDER_H   =	8	; height of border blocks (~width of one PF pixel)
    721 U00df		       00 06	   GAP_H      =	6	; height of gap blocks (~width of one PF pixel)
    722 U00df		       00 a0	   TKERNEL_H  =	NUM_BLOCKS*BLOCK_H + 2*BORDER_H + 2*GAP_H	; = 160
    723 U00df		       00 20	   LKERNEL_H  =	32	; height of logo/selection
    724 U00df
    725 U00ff ????				      SEG.U	variables2
    726 U0082					      ORG	Platform+1
    727 U0082
    728 U0082		       00 82	   startOfTitleRAM =	.
    729 U0082							; current selection (has to be 0..x):
    730 U0082		       00 04	   NUM_SEL    =	4
    731 U0082
    732 U0082		       00 00 00 00 selLst     ds	NUM_SEL
    733 U0082		       00 82	   sCave      =	selLst	; 0..3/19 (FINAL_VERSION = A, E, I, M, multiply by 5 to get real number, )
    734 U0082		       00 83	   sLevel     =	selLst+1	; 0..4
    735 U0082		       00 84	   sPlayers   =	selLst+2	; 0..1
    736 U0082		       00 85	   sJoysticks =	selLst+3	; 0..1
    737 U0082		       00 86	   endTitleClear =	.
    738 U0086
    739 U0086							; from here the variables can be cleared
    740 U0086		       00	   titleMode  ds	1	; logo = 0/selection = 1
    741 U0087		       00	   counter    ds	1
    742 U0088		       00	   btnReleased ds	1
    743 U0089		       00	   hmJunior   ds	1	; $f0/$50
    744 U008a							; music vars:
    745 U008a		       00	   noteLen    ds	1
    746 U008b		       00	   noteIdx    ds	1
    747 U008c		       00	   note0      ds	1
    748 U008d		       00	   note1      ds	1
    749 U008e
    750 U008e		       00	   inputBuffer ds	1
    751 U008f		       00	   demoDelay  ds	1
    752 U0090
    753 U0090		       00	   audv0Lo    ds	1
    754 U0091		       00	   audv0Hi    ds	1
    755 U0092		       00	   audv1Lo    ds	1
    756 U0093		       00	   audv1Hi    ds	1
    757 U0094							; offset to compensate early precalculation:
    758 U0094		       00	   audvOfsLo  ds	1
    759 U0095		       00	   audvOfsHi  ds	1
    760 U0096
    761 U0096							; selection vars
    762 U0096		       00	   tmpY       ds	1
    763 U0096		       00 96	   tmpGfx     =	tmpY
    764 U0096		       00 96	   tmpGfxA    =	tmpGfx
    765 U0097		       00	   tmpGfxB    ds	1
    766 U0098
    767 U0098		       00	   loopCntFSS ds	1
    768 U0098		       00 98	   loopCntSel =	loopCntFSS
    769 U0099		       00 00	   ptrGfxA    ds	2
    770 U009b		       00 00	   ptrGfxB    ds	2
    771 U009d
    772 U009d		       00	   selRow     ds	1
    773 U009e
    774 U009e		       00	   audvTmpLo  ds	1	; high values stored in following list
    775 U009f		       00 00 00 00*audV0Lst   ds	(TKERNEL_H + LKERNEL_H)/2	; = 96 bytes
    776 U009f		       00 9f	   audV0LstBtm =	audV0Lst
    777 U009f		       00 af	   audV0LstTop =	audV0Lst + LKERNEL_H/2
    778 U009f		       00 ff	   endOfTitleRAM =	.
    779 U00ff
    780 U00ff							;------------------------------------------------------------------------------
    781 U00ff							;##############################################################################
    782 U00ff							;------------------------------------------------------------------------------
    783 U00ff
    784 U00ff							; NOW THE VERY INTERESTING '3E' RAM BANKS
    785 U00ff							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    786 U00ff
    787 U00ff				   ORIGIN     SET	0
      0 U00ff					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN / RAM_SIZE
      6 U0000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    789 U0000
    790 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    791 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    792 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    793 U0000
    794 U0000		       00 54	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    795 U0000
    796 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    797 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    798 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    799 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    800 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    801 U0000
    802 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    803 U0000							; is that we can use that code to switch between banks, and the system will happily
    804 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    805 U0000
    806 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    807 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    808 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    809 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    810 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    811 U0000
    812 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    813 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    814 U0000							; part of the draw routine *every* scanline (though the system currently uses
    815 U0000							; one colour shared between both players).
    816 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    818 U0000
    819 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    820 U0000							; accessed via the above labels but with the appropriate bank switched in.
    821 U0000
    822 U0000							;------------------------------------------------------------------------------
    823 U0000
    824 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    824 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    824 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    824 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1000				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    824 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    824 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    824 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    827 U1c00					      REPEND
    828 U1c00
    829 U1c00							;------------------------------------------------------------------------------
    830 U1c00							;##############################################################################
    831 U1c00							;------------------------------------------------------------------------------
    832 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN / RAM_SIZE
      6 U2000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    834 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    835 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    837 U2000
    838 U2000							;------------------------------------------------------------------------------
    839 U2000							;##############################################################################
    840 U2000							;------------------------------------------------------------------------------
    841 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN / RAM_SIZE
      6 U2400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    843 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    844 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    846 U2400
    847 U2400							;------------------------------------------------------------------------------
    848 U2400							;##############################################################################
    849 U2400							;------------------------------------------------------------------------------
    850 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_CAVE
      1 U2800 ????				      SEG.U	BANK_DECODE_CAVE
      2 U2800					      ORG	ORIGIN
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_CAVE SET	ORIGIN / RAM_SIZE
      6 U2800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    852 U2800							; VARS DEFINED IN BANK_DECODE_CAVE_SHADOW
    853 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    855 U2800
    856 U2800							;------------------------------------------------------------------------------
    857 U2800							;##############################################################################
    858 U2800							;------------------------------------------------------------------------------
    859 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN / RAM_SIZE
      6 U2c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
    861 U2c00
    862 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    863 U2c00							; position of something that needs to be processed.  These things include anything
    864 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    865 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    866 U2c00							; one for the next processing iteration.
    867 U2c00
    868 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    869 U2c00
    870 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    871 U2c00
    872 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    873 U2c00
    874 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    875 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    876 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    877 U2d80
    878 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    879 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    880 U2e00
    881 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    882 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    883 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    884 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    886 U2e80
    887 U2e80							;------------------------------------------------------------------------------
    888 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN / RAM_SIZE
      6 U3000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    890 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    892 U3000
    893 U3000							;------------------------------------------------------------------------------
    894 U3000
    895 U3000							;		  NEWRAMBANK BANK_OBJSTACKA
    896 U3000
    897 U3000							;
    898 U3000
    899 U3000
    900 U3000							;    ECHO "FREE RAM IN BANK_OBJSTACKA = ", RAM_SIZE - ( * - BANK_START )
    901 U3000
    902 U3000							;		VALIDATE_RAM_SIZE
    903 U3000
    904 U3000							;------------------------------------------------------------------------------
    905 U3000
    906 U3000							;		  NEWRAMBANK BANK_OBJSTACKA2
    907 U3000							; THIS IS A MIRROR OF BANK_OBJSTACKA -- DO NOT MODIFY OR USE!!
    908 U3000							;		  VALIDATE_RAM_SIZE
    909 U3000
    910 U3000							;------------------------------------------------------------------------------
    911 U3000							;##############################################################################
    912 U3000							;------------------------------------------------------------------------------
    913 U3000
    914 U3000							;		  NEWRAMBANK BANK_TITLE_SCREEN
    915 U3000							; VARS DEFINED IN ROM_SHADOW_OF_TITLE_SCREEN
    916 U3000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
    917 U3000							;		  VALIDATE_RAM_SIZE
    918 U3000
    919 U3000
    920 U3000							;------------------------------------------------------------------------------
    921 U3000							;##############################################################################
    922 U3000							;------------------------------------------------------------------------------
    923 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U37a0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN / RAM_SIZE
      6 U3400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    925 U3400
    926 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    927 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    928 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    929 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    930 U3400							; when accessing.
    931 U3400
    932 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    933 U3400							; automatically based on the sizes set in these constants. The board may overlay
    934 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    935 U3400							; we're doing OK.
    936 U3400
    937 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    938 U3400
    939 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    940 U3400
    941 U3400		       00 28	   SIZE_BOARD_X =	40
    942 U3400		       00 16	   SIZE_BOARD_Y =	22
    943 U3400
    944 U3400							; have to precalculate it here, else DASM freaks out:
    945 U3400				   .BOARD_SIZE SET	0
    946 U3400				   .BOARD_LOCATION SET	0
    947 U3400					      REPEAT	SIZE_BOARD_Y
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    947 U3400					      REPEND
    948 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    949 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    950 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    951 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    952 U3400					      ENDIF
    953 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    954 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    955 U3400					      REPEND
    956 U3400
    957 U3400		       03 a0	   SIZE_BOARD =	.BOARD_SIZE
    958 U3400
    959 U3400
    960 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    961 U3400				  -MULTI_BANK_BOARD =	YES
    962 U3400					      ELSE
    963 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    964 U3400					      ENDIF
    965 U3400
    966 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    967 U37a0							; 1024 byte chunks, switching RAM
    968 U37a0							; banks as we go.  In other words,
    969 U37a0							; this overlaps multiple banks!
    970 U37a0
    971 U37a0
    972 U37a0							; free space here (but hard to use)
    973 U37a0							; So we need to calculate where the next free bank is!
    974 U37a0							; TODO: This looks dodgy.  Check..
    975 U37a0
    976 U37a0				   ORIGIN     SET	( * + RAM_SIZE - 1 ) / RAM_SIZE
    977 U37a0				   ORIGIN     SET	ORIGIN * RAM_SIZE
    978 U37a0
    979 U37a0
    980 U37a0
    981 U37a0							;------------------------------------------------------------------------------
    982 U37a0							;##############################################################################
    983 U37a0							;------------------------------------------------------------------------------
    984 U37a0
    985 U37a0							;------------------------------------------------------------------------------
    986 U37a0
    987 U37a0							;    IFNCONST MAX_CAVE_SIZE
    988 U37a0				   MAX_CAVE_SIZE SET	0
    989 U37a0							;    ENDIF
    990 U37a0
    991 U37a0							;    IFNCONST MAX_CAVE_NUMBER
    992 U37a0				   MAX_CAVE_NUMBER SET	0
    993 U37a0							;    ENDIF
    994 U37a0
    995 U37a0					      MAC	start_cave
    996 U37a0				   CAVE_START SET	*
    997 U37a0				   BANK_CAVE_{1} =	_CURRENT_BANK
    998 U37a0				   CAVE_{1}   SUBROUTINE
    999 U37a0				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
   1000 U37a0							; ECHO "current MAX_CAVE_NUMBER = ", MAX_CAVE_NUMBER
   1001 U37a0					      ENDM		; {name}
   1002 U37a0
   1003 U37a0
   1004 U37a0					      MAC	end_cave
   1005 U37a0					      .byte	$FF
   1006 U37a0				   CAVE_SIZE_{1} =	* - CAVE_START
   1007 U37a0					      IF	CAVE_SIZE_{1} > MAX_CAVE_SIZE
   1008 U37a0				   MAX_CAVE_SIZE SET	CAVE_SIZE_{1}
   1009 U37a0					      ENDIF
   1010 U37a0					      ENDM		; {name}
   1011 U37a0
   1012 U37a0					      MAC	cave_size
   1013 U37a0					      .byte	{1},{2}
   1014 U37a0					      ENDM		; x, y
   1015 U37a0
   1016 U37a0					      MAC	cave_size_room
   1017 U37a0					      CAVE_SIZE	40, 22
   1018 U37a0					      ENDM
   1019 U37a0
   1020 U37a0					      MAC	cave_size_intermission
   1021 U37a0					      CAVE_SIZE	20, 12
   1022 U37a0					      ENDM
   1023 U37a0
   1024 U37a0					      MAC	stoch
   1025 U37a0					      .byte	{1},{2},{3}
   1026 U37a0					      ENDM		; {character} {x} {y}
   1027 U37a0
   1028 U37a0					      MAC	cave_random
   1029 U37a0					      .byte	{1},{2},{3},{4},{5}
   1030 U37a0					      ENDM		; {1}{2}{3}{4}{5}
   1031 U37a0
   1032 U37a0							;-------------------------------------------------------------------------------
   1033 U37a0							; Define which screens are to be included in assembly. This sets the INCLUSION.
   1034 U37a0							; The ORDERING is defined in a similar table in UnpackLevel.asm.
   1035 U37a0
   1036 U37a0					      MAC	include_cave
   1037 U37a0				   CAVE_ACTIVE_{1} SET	0
   1038 U37a0					      ENDM		; {name}
   1039 U37a0
      0 U37a0					      INCLUDE_CAVE	TowC
      1 U37a0				   CAVE_ACTIVE_TowC SET	0
      0 U37a0					      INCLUDE_CAVE	SimpleC
      1 U37a0				   CAVE_ACTIVE_SimpleC SET	0
      0 U37a0					      INCLUDE_CAVE	Thomas_Reinke16
      1 U37a0				   CAVE_ACTIVE_Thomas_Reinke16 SET	0
      0 U37a0					      INCLUDE_CAVE	bAlfa_DrFogh
      1 U37a0				   CAVE_ACTIVE_bAlfa_DrFogh SET	0
      0 U37a0					      INCLUDE_CAVE	b51X_Sharpen
      1 U37a0				   CAVE_ACTIVE_b51X_Sharpen SET	0
      0 U37a0					      INCLUDE_CAVE	bDarcy_Burnsell101
      1 U37a0				   CAVE_ACTIVE_bDarcy_Burnsell101 SET	0
      0 U37a0					      INCLUDE_CAVE	bAislin101
      1 U37a0				   CAVE_ACTIVE_bAislin101 SET	0
      0 U37a0					      INCLUDE_CAVE	b82X_Sharpen
      1 U37a0				   CAVE_ACTIVE_b82X_Sharpen SET	0
   1048 U37a0
   1049 U37a0		       00 20	   MAX_CAVENUM EQU	CAVENUM
   1050 U37a0
      0 U37a0					      INCLUDE_CAVE	SELECTION_SCREEN	; This should be the LAST cave, though!
      1 U37a0				   CAVE_ACTIVE_SELECTION_SCREEN SET	0
   1052 U37a0
   1053 U37a0
   1054 U37a0							;--------------------------------------------------------------------------------
   1055 U37a0
   1056 U37a0				   ORIGIN     SET	$00000
   1057 U37a0
------- FILE BANK_MUSIC.asm LEVEL 2 PASS 3
      0 U37a0					      include	"BANK_MUSIC.asm"
      1 U37a0							;------------------------------------------------------------------------------
      2 U37a0							;##############################################################################
      3 U37a0							;------------------------------------------------------------------------------
      4 U37a0
      5 U37a0							; 2K reserved for music.
      6 U37a0
      0 U37a0					      NEWBANK	BANK_MUSIC1
      1  035c ????				      SEG	BANK_MUSIC1
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   BANK_MUSIC1 SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	BANK_MUSIC1
      8  0000
      9  0000							;build datestamp
     10  0000
     11  0000		       4a 75 6c 79*	      .byte.b	"July 25 2019"
     12  000c
     13  000c		       20 20 20 20*	      ds	80, " "
     14  005c		       54 68 69 73*	      .byte.b	"This Atari 2600 "
     15  006c		       76 65 72 73*	      .byte.b	"version of Sokob"
     16  007c		       61 6e 20 77*	      .byte.b	"an was programmed by And"
     17  0094		       72 65 77 20*	      .byte.b	"rew Davie using "
     18  00a4		       61 20 63 68*	      .byte.b	"a character engi"
     19  00b4		       6e 65 20 64*	      .byte.b	"ne developed by "
     20  00c4		       68 65 20 61*	      .byte.b	"he and Thomas Je"
     21  00d4		       6e 74 7a 73*	      .byte.b	"ntzsch. This bin"
     22  00e4		       61 72 79 20*	      .byte.b	"ary is...   Copy"
     23  00f4		       72 69 67 68*	      .byte.b	"right Andrew Dav"
     24  0104		       69 65 20 28*	      .byte.b	"ie (C)2019 "
     25  010f
     26  010f							;--------------------------------------------------------------------------
     27  010f
------- FILE sounds.asm LEVEL 3 PASS 3
      0  010f					      include	"sounds.asm"	; code and data for the various sounds:
      1  010f							; Sound TODOs:
      2  010f							; ? (un)cover cave (not done yet)
      3  010f							; + initial crack sound
      4  010f							; + diamond pickup
      5  010f							; o diamond starts falling (double start bug)
      6  010f							; + diamond lands
      7  010f							; o BOX stars falling (double start bug)
      8  010f							; + BOX lands
      9  010f							; + BOX is pushed
     10  010f							; + Rockford moves through soil
     11  010f							; + Rockford moves through blank
     12  010f							; + Rockfords digs into soil
     13  010f							; + magic wall
     14  010f							; + amoeba
     15  010f							; + door opens (background flash fixed)
     16  010f							; + running out of time
     17  010f							; + bonus points
     18  010f							; x extra live (no sound, Cosmic Ark effect instead, fix colors)
     19  010f
     20  010f							; - BD doku seems wrong, there are sound priorities
     21  010f							;   -> rework sound system, prioritisize sounds!
     22  010f
     23  010f
     24  010f
     25  010f		       00 01	   LOW_BONUS_SOUND =	1	; 1 = the bonus points sound goes deeper
     26  010f		       00 0f	   SND_MASK_LO =	%1111
     27  010f		       00 f0	   SND_MASK_HI =	%11110000
     28  010f
     29  010f							;-----------------------------------------------------------
     30  010f
     31  010f					      MAC	start_sound
     32  010f					      SUBROUTINE
     33  010f					      lda	newSounds	; 3
     34  010f					      IF	{1} < 16
     35  010f					      and	#SND_MASK_LO	; 2
     36  010f					      cmp	#SOUND_MOVE_SOIL+1	; 2	 overwrite low priority move sounds
     37  010f					      bcs	.skipNew	; 2/3
     38  010f					      ELSE
     39  010f					      and	#SND_MASK_HI	; 2
     40  010f					      cmp	#(SOUND_MOVE_SOIL+1)<<4	; 2	 overwrite low priority move sounds
     41  010f					      bcs	.skipNew	; 2/3
     42  010f							;	  bne	  .skipNew	      ; 2/3
     43  010f					      ENDIF
     44  010f					      eor	newSounds	; 3
     45  010f					      ora	#{1}	; 2
     46  010f					      sta	newSounds	; 3
     47  010f				   .skipNew
     48  010f					      SUBROUTINE
     49  010f					      ENDM		; = 15
     50  010f
     51  010f
     52  010f							;-----------------------------------------------------------
     53  010f
     54  010f					      MAC	start_prio_sound
     55  010f					      lda	newSounds	; 3
     56  010f					      IF	{1} < 16
     57  010f					      and	#<(~SND_MASK_LO)	; 2
     58  010f					      ELSE
     59  010f					      and	#<(~SND_MASK_HI)	; 2
     60  010f					      ENDIF
     61  010f					      ora	#{1}	; 2
     62  010f					      sta	newSounds	; 3
     63  010f					      ENDM		; = 10
     64  010f
     65  010f							;-----------------------------------------------------------
     66  010f
     67  010f					      MAC	stop_channel
     68  010f							; only any sound in the channel
     69  010f					      lda	#0
     70  010f					      sta	soundIdxLst+{1}
     71  010f					      sta	AUDV0+{1}
     72  010f					      ENDM		; {0 or 1}
     73  010f
     74  010f							;-----------------------------------------------------------
     75  010f
     76  010f					      MAC	stop_sound
     77  010f							; only stops a given sound the channel
     78  010f					      lda	#{2}
     79  010f					      eor	soundIdxLst+{1}
     80  010f					      bne	.skipStop
     81  010f					      sta	soundIdxLst+{1}
     82  010f					      sta	AUDV0+{1}
     83  010f				   .skipStop
     84  010f					      ENDM		; {0 or 1, sound offset}
     85  010f
     86  010f							;-----------------------------------------------------------
      0  010f					      DEFINE_SUBROUTINE	StartSound
      1  010f		       00 00	   BANK_StartSound =	_CURRENT_BANK
      2  010f					      SUBROUTINE
      3  010f				   StartSound
     88  010f							;-----------------------------------------------------------
     89  010f							; worst case timings:
     90  010f							; SOIL, DIRT = 82
     91  010f							; channel0   = 69
     92  010f							; channel1   = 68
     93  010f							; channel1   = 80+(1..2*9) (random frequency)
     94  010f							;-----------------------------------------------------------
     95  010f							; a = sound idx
     96  010f							; 1. assign all sounds (except move) to their channels:
     97  010f
     98  010f		       a2 01		      ldx	#1	; 2
     99  0111		       c9 20		      cmp	#SOUND_GROUP_HI	; 2
    100  0113		       90 08		      bcc	.checkChannel0	; 2/3
    101  0115							; channel 1 group sounds get prioritized:
    102  0115		       c5 cb		      cmp	soundIdxLst+1	; 2
    103  0117		       f0 47		      beq	.skipSound	; 2/3	     avoid restarting the same sound
    104  0119		       b0 1d		      bcs	.startChannel	; 2/3=12
    105  011b		       90 43		      bcc	.skipSound	; 3
    106  011d
    107  011d				   .checkChannel0		; 7
    108  011d		       ca		      dex		; 2 =	9
    109  011e
    110  011e		       c9 0c		      cmp	#SOUND_GROUP_LO	; 2
    111  0120		       90 0c		      bcc	.soundFree	; 2/3
    112  0122		       c5 ca		      cmp	soundIdxLst	; 3	     prio >= current sound?
    113  0124		       b0 12		      bcs	.startChannel	; 2/3	      yes, overwrite
    114  0126		       a4 ca		      ldy	soundIdxLst	; 3
    115  0128		       c0 18		      cpy	#OFSS_EXPLOSION	; 2	     current explosion?
    116  012a		       b0 34		      bcs	.skipSound	; 2/3	      yes, keep
    117  012c		       90 0a		      bcc	.startChannel	; 2/3	      no, overwrite
    118  012e
    119  012e							; 2. move sound, check for a free channel (1 preferred):
    120  012e				   .soundFree
    121  012e		       e8		      inx		; 2
    122  012f		       a4 cb		      ldy	soundIdxLst+1	; 3	     channel 1 free?
    123  0131		       f0 05		      beq	.startChannel	; 2/3	      yes, use it
    124  0133		       ca		      dex		; 2
    125  0134		       a4 ca		      ldy	soundIdxLst	; 3	     channel 0 free?
    126  0136		       d0 28		      bne	.skipSound	; 2/3=14     no, skip sound
    127  0138
    128  0138							; 3. create new sound:
    129  0138				   .startChannel		;13/14/21/27 (ch1, ch0, dirt/soil)
    130  0138		       95 ca		      sta	soundIdxLst,x	; 4
    131  013a		       a8		      tay		; 2 =	6
    132  013b
    133  013b				   RestartSound
    134  013b							; x = sound channel 0/1
    135  013b							; y = sound index
    136  013b		       a9 00		      lda	#0	; 2
    137  013d		       95 ce		      sta	decayTimeLst,x	; 4
    138  013f		       95 59		      sta	AUDV0,x	; 4
    139  0141		       b9 02 f3 	      lda	SoundTbl+OFS_RND_FREQ,y	; 4
    140  0144		       f0 0a		      beq	.fixedFreq	; 2/3=16
    141  0146
    142  0146							; increase base frequency by random value:
    143  0146		       a5 82		      lda	rnd	;NEXT_RANDOM		 ; 3
    144  0148		       29 0e		      and	#%1110	; 2 =	5    up to 8 different variations
    145  014a				   .reTry
    146  014a		       4a		      lsr		; 2
    147  014b		       d9 02 f3 	      cmp	SoundTbl+OFS_RND_FREQ,y	; 4
    148  014e		       b0 fa		      bcs	.reTry	; 2/3= 8
    149  0150				   .fixedFreq
    150  0150		       18		      clc		; 2
    151  0151		       79 01 f3 	      adc	SoundTbl+OFS_FREQ,y	; 4
    152  0154		       95 57		      sta	AUDF0,x	; 4
    153  0156		       b9 00 f3 	      lda	SoundTbl+OFS_DIST,y	; 4
    154  0159		       95 55		      sta	AUDC0,x	; 4
    155  015b		       b9 03 f3 	      lda	SoundTbl+OFS_DECAY,y	; 4
    156  015e		       95 cc		      sta	decayIdxLst,x	; 4 = 26
    157  0160
    158  0160				   .skipSound
    159  0160		       60		      rts		; 6 =	6
    160  0161
    161  0161							;-----------------------------------------------------------
    162  0161
    163  0161							;ManActionSounds
    164  0161							;		  .byte 1 ;<manStartup		  ; 0		  sounds
    165  0161							;		  .byte 1 ;<normalMan		  ; 1
    166  0161							;		  .byte 1 ;<deadMan		  ; 2
    167  0161							;		  .byte 1 ;<waitingMan		  ; 3
    168  0161							;		  .byte 1 ;<waitingManPress	  ; 4
    169  0161							;		  .byte 1 ;<waitingManNoTim	  ; 5
    170  0161							;		  .byte 1 ;<waitingManPressNoTim  ; 6
    171  0161							;		  .byte 0 ;<nextLevelMan	  ; 7
    172  0161							;		  .byte 1 ;<BonusCountdownStart   ; 8
    173  0161							;		  .byte 1 ;<BonusCountdownRun	  ; 9
    174  0161
    175  0161
    176  0161							;-----------------------------------------------------------
      0  0161					      DEFINE_SUBROUTINE	PlaySounds
      1  0161		       00 00	   BANK_PlaySounds =	_CURRENT_BANK
      2  0161					      SUBROUTINE
      3  0161				   PlaySounds
    178  0161							;-----------------------------------------------------------
    179  0161
    180  0161		       a4 9d		      ldy	ManMode	; 3	     new sounds allowed?
    181  0163		       c0 07		      cpy	#MANMODE_NEXTLEVEL	; 2
    182  0165		       f0 18		      beq	.skipHi	; 2/3
    183  0167
    184  0167		       a5 d0		      lda	newSounds	; 3
    185  0169		       29 0f		      and	#SND_MASK_LO	; 2
    186  016b		       f0 05		      beq	.skipLo	; 2/3	     no new low sound was triggered
    187  016d		       0a		      asl		; 2
    188  016e		       0a		      asl		; 2
    189  016f		       20 0f f1 	      jsr	StartSound	; 6
    190  0172				   .skipLo
    191  0172		       a5 d0		      lda	newSounds	; 3
    192  0174		       29 f0		      and	#SND_MASK_HI	; 2
    193  0176		       f0 07		      beq	.skipHi	; 2/3	     no new high sound was triggered
    194  0178		       4a		      lsr		; 2
    195  0179		       4a		      lsr		; 2
    196  017a		       69 1c		      adc	#<(SoundTblHi-SoundTbl-4)
    197  017c		       20 0f f1 	      jsr	StartSound	; 6
    198  017f				   .skipHi
    199  017f		       a9 00		      lda	#0	; 2	     prepare for new triggers
    200  0181		       85 d0		      sta	newSounds	; 3
    201  0183
    202  0183							; fall through
    203  0183
    204  0183							; The issue here is that this code writes to channels which are not in use.
    205  0183
      0  0183					      NEXT_RANDOM		; this makes sure rnd is updated each frame, also used for other things!
      1  0183
      2  0183		       a5 82		      lda	rnd
      3  0185		       4a		      lsr
      4  0186					      IFCONST	rndHi
      5  0186		       66 83		      ror	rndHi
      6  0188					      ENDIF
      7  0188		       90 02		      bcc	.skipEOR
      8  018a		       49 b4		      eor	#RND_EOR_VAL
      9  018c				   .skipEOR
     10  018c		       85 82		      sta	rnd
    207  018e
    208  018e		       00 e2	   .freqVibrato =	tmpVar	; @Andrew: replace with whatever is available
    209  018e							; called once/frame
    210  018e		       a2 01		      ldx	#1
    211  0190				   .loopSound
    212  0190
    213  0190		       b5 ca		      lda	soundIdxLst,x
    214  0192		       f0 4c		      beq	.nextSound	; don't write to inactive channels! IMPORTANT SO MUSIC CAN CO-EXIST
    215  0194
    216  0194		       c9 1c		      cmp	#OFSS_BONUS_POINTS
    217  0196		       f0 1d		      beq	.bonusPointsSound	;
    218  0198
    219  0198		       b5 ce		      lda	decayTimeLst,x
    220  019a		       d0 42		      bne	.contNote
    221  019c							; start next note:
    222  019c		       b4 cc		      ldy	decayIdxLst,x
    223  019e		       b9 ea f1 	      lda	DecayTbl,y
    224  01a1		       95 59		      sta	AUDV0,x
    225  01a3		       d0 31		      bne	.contSound
    226  01a5							; current sound is over, now check what to do next:
    227  01a5		       b4 ca		      ldy	soundIdxLst,x
    228  01a7		       c0 1c		      cpy	#OFSS_BONUS_POINTS
    229  01a9		       f0 0a		      beq	.bonusPointsSound	;
    230  01ab		       b9 00 f3 	      lda	SoundTbl+OFS_DIST,y	;   loop sound?
    231  01ae		       10 34		      bpl	.endSound	;
    232  01b0		       20 3b f1 	      jsr	RestartSound
    233  01b3		       d0 db		      bne	.loopSound
    234  01b5
    235  01b5							; special handling for score countdown sound:
    236  01b5				   .bonusPointsSound
    237  01b5		       a5 cc		      lda	soundBonusPts
    238  01b7		       a8		      tay
    239  01b8		       29 03		      and	#$03
    240  01ba		       49 03		      eor	#$03
    241  01bc		       85 e2		      sta	.freqVibrato
    242  01be		       98		      tya
    243  01bf		       4a		      lsr
    244  01c0		       4a		      lsr
    245  01c1		       4a		      lsr
    246  01c2		       38		      sec		; frequency divider:
    247  01c3		       e5 e2		      sbc	.freqVibrato	; 1,2,3,4, 1,2,3,4, 2,3,4,5...
    248  01c5		       85 57		      sta	AUDF0	; ...28,29,30,31, 28,29,30,31
    249  01c7		       a9 07		      lda	#VOL_SOUND_BONUS
    250  01c9		       85 59		      sta	AUDV0
    251  01cb							;		  cpy	  #MAX_SOUND_BONUS-1
    252  01cb							;		  bcc	  .skipReset
    253  01cb		       98		      tya
    254  01cc		       d0 08		      bne	.skipReset
    255  01ce					      IF	LOW_BONUS_SOUND
    256  01ce		       a0 06		      ldy	#DIST_DIV31
    257  01d0		       84 55		      sty	AUDC0
    258  01d2		       a0 37		      ldy	#$38-1
    259  01d4				  -	      ELSE
    260  01d4				  -	      ldy	#MIN_SOUND_BONUS-1
    261  01d4					      ENDIF
    262  01d4		       84 cc		      sty	soundBonusPts	; = decayIdxLst !
    263  01d6				   .skipReset
    264  01d6							;		  lda	  #1<<4 		  ; -> decayTimeLst,x = 1
    265  01d6
    266  01d6							; continue with normal sounds:
    267  01d6				   .contSound
    268  01d6		       4a		      lsr
    269  01d7		       4a		      lsr
    270  01d8		       4a		      lsr
    271  01d9		       4a		      lsr
    272  01da		       95 ce		      sta	decayTimeLst,x
    273  01dc		       f6 cc		      inc	decayIdxLst,x
    274  01de				   .contNote
    275  01de		       d6 ce		      dec	decayTimeLst,x
    276  01e0				   .nextSound
    277  01e0		       ca		      dex
    278  01e1		       10 ad		      bpl	.loopSound
    279  01e3		       60		      rts
    280  01e4				   .endSound
    281  01e4		       a9 00		      lda	#0	; THIS FIXES THE SOUNDS NOT 'STOPPING' -- A was NOT 0 as commented below :)
    282  01e6		       95 ca		      sta	soundIdxLst,x	; a = 0!
    283  01e8		       f0 f6		      beq	.nextSound
    284  01ea
    285  01ea
    286  01ea							;-----------------------------------------------------------
    287  01ea							; S O U N D - D A T A
    288  01ea							;-----------------------------------------------------------
    289  01ea
    290  01ea		       00 08	   DIST_NOISE =	$08
    291  01ea		       00 04	   DIST_DIV2  =	$04	; 15720..491 Hz
    292  01ea		       00 0c	   DIST_DIV6  =	$0c	;  5240..164 Hz
    293  01ea		       00 06	   DIST_DIV31 =	$06	;  1014.. 32 Hz
    294  01ea							;DIST_DIV93	  = $0e ; unused
    295  01ea
    296  01ea		       00 80	   LOOP_SOUND =	$80
    297  01ea
    298  01ea		       00 00	   OFS_DIST   =	0
    299  01ea		       00 01	   OFS_FREQ   =	1
    300  01ea		       00 02	   OFS_RND_FREQ =	2
    301  01ea		       00 03	   OFS_DECAY  =	3
    302  01ea
    303  01ea		       00 20	   MIN_SOUND_BONUS =	$20	;$08
    304  01ea		       01 00	   MAX_SOUND_BONUS =	$100	;$e8
    305  01ea		       00 07	   VOL_SOUND_BONUS =	$07
    306  01ea
    307  01ea							;Note: The ADSR values documented at www.elmerproductions.com/sp/peterb
    308  01ea							;  are sometimes not matching what I hear when playing the original
    309  01ea							;  Also be base volume is not documented, therefore I assume 15 here. If the
    310  01ea							;  result is too loud the decays have to be adjusted.
    311  01ea				   DecayTbl
    312  01ea		       00		      .byte.b	$00
    313  01eb				   DecayMove		; 24/12ms = 1/1
    314  01eb		       12 14 00 	      .byte.b	$12, $14, $00
    315  01ee				   DecayExplosion		; 8/2400ms = 1/144
    316  01ee		       15		      .byte.b	$15	;  1
    317  01ef							; Vol: 10, Len: 144
    318  01ef		       5a		      .byte.b	$5a	;  5
    319  01f0		       59		      .byte.b	$59	;  5
    320  01f1		       48		      .byte.b	$48	;  4
    321  01f2		       57		      .byte.b	$57	;  5
    322  01f3		       56		      .byte.b	$56	;  5
    323  01f4		       55		      .byte.b	$55	;  5
    324  01f5		       84		      .byte.b	$84	;  8
    325  01f6		       b3		      .byte.b	$b3	; 11
    326  01f7		       f2 62		      .byte.b	$f2, $62	; 21
    327  01f9		       f1		      .byte.b	$f1	;, $f1, $f1, $f1, $f1 ; 75   shortened!
    328  01fa		       00		      .byte.b	$00
    329  01fb				   DecayDiamondPickup		; 2/6ms??  != 1/30
    330  01fb				   DecayBOX
    331  01fb							; Vol: 10, Len: 30
    332  01fb		       1a		      .byte.b	$1a	;  1
    333  01fc		       19		      .byte.b	$19	;  1
    334  01fd		       18		      .byte.b	$18	;  1
    335  01fe		       17		      .byte.b	$17	;  1
    336  01ff		       16		      .byte.b	$16	;  1
    337  0200		       15		      .byte.b	$15	;  1
    338  0201		       24		      .byte.b	$24	;  2
    339  0202		       23		      .byte.b	$23	;  2
    340  0203		       42		      .byte.b	$42	;  4
    341  0204		       f1 11		      .byte.b	$f1, $11	; 16
    342  0206		       00		      .byte.b	$00
    343  0207				   DecayDiamondFalling		; 2/6+6ms??  != 1/30
    344  0207		       13		      .byte.b	$13	;  1
    345  0208							; Vol: 7, Len: 30
    346  0208		       17		      .byte.b	$17	;  1
    347  0209		       26		      .byte.b	$26	;  2
    348  020a		       15		      .byte.b	$15	;  1
    349  020b		       24		      .byte.b	$24	;  2
    350  020c		       23		      .byte.b	$23	;  2
    351  020d		       42		      .byte.b	$42	;  4
    352  020e		       f1 31		      .byte.b	$f1, $31	; 18
    353  0210		       00		      .byte.b	$00
    354  0211				   DecayAmoeba		; 24/??ms
    355  0211							;    .byte   $12, $13, $12, $00
    356  0211		       11 12 13 00	      .byte.b	$11, $12, $13, $00
    357  0215				   DecayMagic		;  2/12ms = 0/1
    358  0215		       13 00		      .byte.b	$13, $00
    359  0217				   DecayCrack		; 24/750ms = 2/45
    360  0217		       15		      .byte.b	$15	;  1
    361  0218							; Vol: 10, Len: 45
    362  0218		       1a		      .byte.b	$1a	;  1
    363  0219		       29		      .byte.b	$29	;  2
    364  021a		       28		      .byte.b	$28	;  2
    365  021b		       17		      .byte.b	$17	;  1
    366  021c		       26		      .byte.b	$26	;  2
    367  021d		       15		      .byte.b	$15	;  1
    368  021e		       34		      .byte.b	$34	;  3
    369  021f		       33		      .byte.b	$33	;  3
    370  0220		       62		      .byte.b	$62	;  6
    371  0221		       f1 91		      .byte.b	$f1, $91	; 24
    372  0223		       00		      .byte.b	$00
    373  0224							;DecayUncover:       ; 2/168/??ms = 0/10
    374  0224							;    .byte   $1a		      ;  1
    375  0224							;    .byte   $19		      ;  1
    376  0224							;    .byte   $18		      ;  1
    377  0224							;    .byte   $17		      ;  1
    378  0224							;    .byte   $16		      ;  1
    379  0224							;    .byte   $15		      ;  1
    380  0224							;    .byte   $24		      ;  2
    381  0224							;    .byte   $23		      ;  2
    382  0224							;    .byte   $42		      ;  4
    383  0224							;    .byte   $f1, $11		      ; 16
    384  0224							;    .byte   $00
    385  0224				   DecayTime		; 2/1500ms = 1/90
    386  0224		       15		      .byte.b	$15	;  1
    387  0225							; Vol: 10, Len: 90
    388  0225		       3a		      .byte.b	$3a	;  3
    389  0226		       39		      .byte.b	$39	;  3
    390  0227		       38		      .byte.b	$38	;  3
    391  0228		       37		      .byte.b	$37	;  3
    392  0229		       36		      .byte.b	$36	;  3
    393  022a		       35		      .byte.b	$35	;  3
    394  022b		       54		      .byte.b	$54	;  5
    395  022c		       73		      .byte.b	$73	;  7
    396  022d		       d2		      .byte.b	$d2	; 13
    397  022e		       f1 f1 f1 21	      .byte.b	$f1, $f1, $f1, $21	; 47
    398  0232		       00		      .byte.b	$00
    399  0233
    400  0300		       00 00 00 00*	      ALIGN	256
    401  0300
    402  0300							;Note: The exact NOISE base frequency is not working. Therefore I assume a base
    403  0300							; frequency of 2620 HZ (31440/6) after comparing the sounds with the original.
    404  0300				   SoundTbl
    405  0300		       00		      .byte.b	0
    406  0301		       00 00		      .byte.b	0, 0
    407  0303		       00		      .byte.b	0
    408  0303		       00 04	   OFSS_MOVE_BLANK =	. - SoundTbl
    409  0304		       08		      .byte.b	DIST_NOISE
    410  0305		       02 00		      .byte.b	2, 0	; ~873 Hz (vs. 827)
    411  0307		       01		      .byte.b	DecayMove-DecayTbl
    412  0307		       00 08	   OFSS_MOVE_SOIL =	. - SoundTbl
    413  0308		       08		      .byte.b	DIST_NOISE
    414  0309		       00 00		      .byte.b	0, 0	; ~2620 Hz (vs. 2576)
    415  030b		       01		      .byte.b	DecayMove-DecayTbl
    416  030c
    417  030c
    418  030c							;Sounds of group LO belong to channel 0. If a new sound is requested, this
    419  030c							; overwrites existing sounds:
    420  030c		       00 0c	   SOUND_GROUP_LO =	. - SoundTbl
    421  030c
    422  030c		       00 0c	   OFSS_BOX   =	. - SoundTbl
    423  030c		       08		      .byte.b	DIST_NOISE
    424  030d		       11 00		      .byte.b	17, 0	; ~146 Hz (vs. 143)
    425  030f		       11		      .byte.b	DecayBOX-DecayTbl
    426  030f		       00 10	   OFSS_TARGET_PICKUP =	. - SoundTbl
    427  0310		       0c		      .byte.b	DIST_DIV6
    428  0311		       10 00		      .byte.b	16, 0	; 308 Hz
    429  0313		       11		      .byte.b	DecayDiamondPickup-DecayTbl
    430  0313		       00 14	   OFSS_TARGET_FALLING =	. - SoundTbl
    431  0314		       04		      .byte.b	DIST_DIV2
    432  0315		       03 05		      .byte.b	3, 5	; 1965..3930 Hz
    433  0317		       1d		      .byte.b	DecayDiamondFalling-DecayTbl
    434  0317		       00 18	   OFSS_EXPLOSION =	. - SoundTbl
    435  0318		       08		      .byte.b	DIST_NOISE
    436  0319		       07 00		      .byte.b	7, 0	; ~328 Hz (vs. 315)
    437  031b		       04		      .byte.b	DecayExplosion-DecayTbl
    438  031b		       00 1c	   OFSS_BONUS_POINTS =	. - SoundTbl
    439  031c							; at the end of each level, the time is counted down 30s/frame,
    440  031c							; during that period, this sound it played
    441  031c							; it last for up to
    442  031c							; Note: the last 10s (= 20 frames) the timer sound is played
    443  031c		       0c		      .byte.b	DIST_DIV6
    444  031d		       00 00		      .byte.b	0, 0	; unused (vs. 3246..164)
    445  031f		       20		      .byte.b	MIN_SOUND_BONUS	; here the inital frequency divider is set!
    446  0320
    447  0320
    448  0320							;Sounds of group HI belong to channel 1. If a new sound is requested, this
    449  0320							; only overwrites existing sounds if it has higher priority (index).
    450  0320		       00 20	   SOUND_GROUP_HI =	. - SoundTbl
    451  0320
    452  0320				   SoundTblHi
    453  0320		       00 20	   OFFS_HI    =	. - SoundTbl
    454  0320
    455  0320		       00 20	   OFSS_MOVE_BLANK_HI =	. - SoundTbl
    456  0320		       08		      .byte.b	DIST_NOISE
    457  0321		       02 00		      .byte.b	2, 0	; ~873 Hz (vs. 827)
    458  0323		       01		      .byte.b	DecayMove-DecayTbl
    459  0323		       00 24	   OFSS_MOVE_SOIL_HI =	. - SoundTbl
    460  0324		       08		      .byte.b	DIST_NOISE
    461  0325		       00 00		      .byte.b	0, 0	; ~2620 Hz (vs. 2576)
    462  0327		       01		      .byte.b	DecayMove-DecayTbl
    463  0327		       00 28	   OFSS_AMOEBA =	. - SoundTbl
    464  0328		       86		      .byte.b	DIST_DIV31|LOOP_SOUND
    465  0329		       04 05		      .byte.b	4, 5	; 101..203 Hz
    466  032b		       27		      .byte.b	DecayAmoeba-DecayTbl
    467  032b		       00 2c	   OFSS_MAGIC_WALL =	. - SoundTbl
    468  032c		       84		      .byte.b	DIST_DIV2|LOOP_SOUND
    469  032d		       05 03		      .byte.b	5, 3	; 1965..2620 Hz
    470  032f		       2b		      .byte.b	DecayMagic-DecayTbl
    471  032f		       00 30	   OFSS_CRACK =	. - SoundTbl
    472  0330		       08		      .byte.b	DIST_NOISE
    473  0331		       03 00		      .byte.b	3, 0	; ~655 Hz (vs. 737)
    474  0333		       2d		      .byte.b	DecayCrack-DecayTbl
    475  0334							;OFSS_UNCOVER		 = . - SoundTbl
    476  0334							;    .byte   DIST_DIV2|LOOP_SOUND
    477  0334							;    .byte   4, 6    ; 1572..3930 Hz (vs. 1561..3543)
    478  0334							;    .byte   DecayUncover-DecayTbl
    479  0334		       00 34	   OFSS_TIME_9 =	. - SoundTbl
    480  0334		       0c		      .byte.b	DIST_DIV6
    481  0335		       0b 00		      .byte.b	11, 0	; 437 Hz (vs. 468)
    482  0337		       3a		      .byte.b	DecayTime-DecayTbl
    483  0337		       00 38	   OFSS_TIME_8 =	. - SoundTbl
    484  0338		       0c		      .byte.b	DIST_DIV6
    485  0339		       0a 00		      .byte.b	10, 0	; 476 Hz (vs. 484)
    486  033b		       3a		      .byte.b	DecayTime-DecayTbl
    487  033b		       00 3c	   OFSS_TIME_7 =	. - SoundTbl
    488  033c		       04		      .byte.b	DIST_DIV2
    489  033d		       1f 00		      .byte.b	31, 0	; 491 Hz (vs. 500)
    490  033f		       3a		      .byte.b	DecayTime-DecayTbl
    491  033f		       00 40	   OFSS_TIME_6 =	. - SoundTbl
    492  0340		       04		      .byte.b	DIST_DIV2
    493  0341		       1e 00		      .byte.b	30, 0	; 507 Hz (vs. 515)
    494  0343		       3a		      .byte.b	DecayTime-DecayTbl
    495  0343		       00 44	   OFSS_TIME_5 =	. - SoundTbl
    496  0344		       04		      .byte.b	DIST_DIV2
    497  0345		       1d 00		      .byte.b	29, 0	; 524 Hz (vs. 531)
    498  0347		       3a		      .byte.b	DecayTime-DecayTbl
    499  0347		       00 48	   OFSS_TIME_4 =	. - SoundTbl
    500  0348		       04		      .byte.b	DIST_DIV2
    501  0349		       1c 00		      .byte.b	28, 0	; 542 Hz (vs. 546)
    502  034b		       3a		      .byte.b	DecayTime-DecayTbl
    503  034b		       00 4c	   OFSS_TIME_3 =	. - SoundTbl
    504  034c		       04		      .byte.b	DIST_DIV2
    505  034d		       1b 00		      .byte.b	27, 0	; 561 Hz (vs. 562)
    506  034f		       3a		      .byte.b	DecayTime-DecayTbl
    507  034f		       00 50	   OFSS_TIME_2 =	. - SoundTbl
    508  0350		       04		      .byte.b	DIST_DIV2
    509  0351		       1a 00		      .byte.b	26, 0	; 582 Hz (vs. 578)
    510  0353		       3a		      .byte.b	DecayTime-DecayTbl
    511  0353		       00 54	   OFSS_TIME_1 =	. - SoundTbl
    512  0354		       04		      .byte.b	DIST_DIV2
    513  0355		       19 00		      .byte.b	25, 0	; 605 Hz (vs. 593)
    514  0357		       3a		      .byte.b	DecayTime-DecayTbl
    515  0357		       00 58	   OFSS_TIME_0 =	. - SoundTbl
    516  0358		       04		      .byte.b	DIST_DIV2
    517  0359		       18 00		      .byte.b	24, 0	; 629 Hz (vs. 609)
    518  035b		       3a		      .byte.b	DecayTime-DecayTbl
    519  035c
    520  035c
    521  035c							; special low priority:
    522  035c		       00 01	   SOUND_MOVE_BLANK =	OFSS_MOVE_BLANK / 4
    523  035c		       00 02	   SOUND_MOVE_SOIL =	OFSS_MOVE_SOIL / 4
    524  035c							; group lo:
    525  035c		       00 03	   SOUND_BOX  =	OFSS_BOX / 4
    526  035c		       00 06	   SOUND_EXPLOSION =	OFSS_EXPLOSION / 4
    527  035c		       00 04	   SOUND_TARGET_PICKUP =	OFSS_TARGET_PICKUP / 4
    528  035c		       00 05	   SOUND_TARGET_FALLING =	OFSS_TARGET_FALLING / 4
    529  035c		       00 07	   SOUND_BONUS_POINTS =	OFSS_BONUS_POINTS / 4
    530  035c							; group hi:
    531  035c
    532  035c		       00 30	   SOUND_AMOEBA =	(OFSS_AMOEBA - OFFS_HI) * 4 + $10
    533  035c		       00 40	   SOUND_MAGIC_WALL =	(OFSS_MAGIC_WALL - OFFS_HI) * 4 + $10
    534  035c		       00 50	   SOUND_CRACK =	(OFSS_CRACK - OFFS_HI) * 4 + $10
    535  035c		       00 60	   SOUND_TIME_9 =	(OFSS_TIME_9 - OFFS_HI) * 4 + $10
    536  035c		       00 70	   SOUND_TIME_8 =	(OFSS_TIME_8 - OFFS_HI) * 4 + $10
    537  035c		       00 80	   SOUND_TIME_7 =	(OFSS_TIME_7 - OFFS_HI) * 4 + $10
    538  035c		       00 90	   SOUND_TIME_6 =	(OFSS_TIME_6 - OFFS_HI) * 4 + $10
    539  035c		       00 a0	   SOUND_TIME_5 =	(OFSS_TIME_5 - OFFS_HI) * 4 + $10
    540  035c		       00 b0	   SOUND_TIME_4 =	(OFSS_TIME_4 - OFFS_HI) * 4 + $10
    541  035c		       00 c0	   SOUND_TIME_3 =	(OFSS_TIME_3 - OFFS_HI) * 4 + $10
    542  035c		       00 d0	   SOUND_TIME_2 =	(OFSS_TIME_2 - OFFS_HI) * 4 + $10
    543  035c		       00 e0	   SOUND_TIME_1 =	(OFSS_TIME_1 - OFFS_HI) * 4 + $10
    544  035c		       00 f0	   SOUND_TIME_0 =	(OFSS_TIME_0 - OFFS_HI) * 4 + $10
------- FILE BANK_MUSIC.asm
     29  035c
      0  035c					      CHECK_BANK_SIZE	"BANK_MUSIC1"
      1  035c		       03 5c	   .TEMP      =	* - BANK_START
 BANK_MUSIC1 (2K) SIZE =  $35c , FREE= $4a4
      2  035c					      ECHO	"BANK_MUSIC1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  035c				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  035c				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  035c				  -	      ERR
      6  035c					      endif
     31  035c
     32  035c							;------------------------------------------------------------------------------
     33  035c							;##############################################################################
     34  035c							;------------------------------------------------------------------------------
------- FILE ./sokoboo.asm
------- FILE BANK_TITLE.asm LEVEL 2 PASS 3
      0  035c					      include	"BANK_TITLE.asm"
      1  035c							; TODOs
      2  035c							; + update channel 1 each scanline
      3  035c							; + update channel 0 each scanline
      4  035c							; + convert both kernels to 2LK counters
      5  035c							; + split graphic data into odd and even lines
      6  035c							; + precalculate values
      7  035c							; + calculate inital values some scanlines ahead
      8  035c							; + update AUD0 during kernels
      9  035c							; + check carry flags! AGAIN!!!
     10  035c							; + DEBUG!!!
     11  035c							; + revert code to use ROM bank
     12  035c
     13  035c							; music ideas:
     14  035c							; + precalculate 1 channel (96 bytes RAM = 48 scanlines)
     15  035c							; + calculate other channel during kernel over two scanlines
     16  035c							; x use self-modifying code
     17  035c
     18  035c							; + sync music
     19  035c							; + share logo bank with other bank (copyright!)
     20  035c							; + set pointers
     21  035c							; + joystick input
     22  035c							;   + switch from logo to selection
     23  035c							;   + block 2 joystick row for 1 player
     24  035c							; x calculate cave*=4/5 (done somewhere else)
     25  035c
     26  035c							;------------------------------------------------------------------------------
     27  035c							;##############################################################################
     28  035c							;------------------------------------------------------------------------------
     29  035c
      0  035c					      NEWBANK	TITLE_BANK
      1  0ffe ????				      SEG	TITLE_BANK
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   TITLE_BANK SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	TITLE_BANK
     31  0800
     32  0800		       00 01	   PLAY_CH_0  =	YES	; play the very tricky, precalculated channel 0
     33  0800		       00 01	   PLAY_CH_1  =	YES	; play the on-the-fly calculated channel 1
     34  0800
     35  0800		       00 0e	   TWHITE     =	WHITE
     36  0800
     37  0800		       00 09	   NOTE_LEN_NTSC =	9	; was: 9 ; number of frames each note is played in total
     38  0800		       00 08	   NOTE_LEN_PAL =	NOTE_LEN_NTSC-1	; was: NOTE_LEN_NTSC-1 = 8
     39  0800		       00 02	   NOTE_OFF_LEN =	2	; number of silent frames between each note (>=1!)
     40  0800		       00 0c	   VOL_MASK   =	%1100
     41  0800
     42  0800							; number of precalculated values
     43  0800		       00 30	   PC_TOP     =	48	; calculated during vertical blank
     44  0800		       00 30	   PC_BTM     =	48	; calculated during overscan
     45  0800
     46  0800					      MAC	check_clc
     47  0800							;    bcs     . 		  ; 2/3       set carry causes endless loop
     48  0800					      ENDM
     49  0800
     50  0800					      MAC	update_music_data_lo
     51  0800					      CHECK_CLC
     52  0800							;    clc			  ; 2	      we always assume that carry is clear!
     53  0800					      lda	audv{1}Lo	; 3
     54  0800					      adc	note{1}	; 3
     55  0800					      sta	audv{1}Lo	; 3 =	9
     56  0800					      ENDM
     57  0800
     58  0800					      MAC	update_music_data_hi
     59  0800					      lda	audv{1}Hi	; 3
     60  0800					      adc	#0	; 2
     61  0800					      sta	audv{1}Hi	; 3 =	8
     62  0800					      ENDM
     63  0800
     64  0800					      MAC	update_music_data
     65  0800					      UPDATE_MUSIC_DATA_LO	{1}	; 9
     66  0800					      UPDATE_MUSIC_DATA_HI	{1}	; 8 = 17
     67  0800					      ENDM
     68  0800
     69  0800					      MAC	update_music_prep_vol
     70  0800					      and	#VOL_MASK/2	; 2	     optional, but sounds a tiny bit better if left in
     71  0800					      asl		; 2 =	4    carry clear now!
     72  0800					      ENDM
     73  0800
     74  0800					      MAC	update_music_set_vol
     75  0800					      IF	PLAY_CH_{1} == YES
     76  0800					      sta	AUDV{1}	; 3	     @07!    NOTE: this store must always occur on the same cycle
     77  0800					      ELSE
     78  0800					      nop	AUDV{1}	; 3 =	3
     79  0800					      ENDIF
     80  0800					      ENDM
     81  0800
     82  0800					      MAC	update_music_set_vol_w
     83  0800					      IF	PLAY_CH_{1} == YES
     84  0800					      sta.w	AUDV{1}	; 4	     @07!    NOTE: this store must always occur on the same cycle
     85  0800					      ELSE
     86  0800					      nop.w	AUDV{1}	; 4 =	4
     87  0800					      ENDIF
     88  0800					      ENDM
     89  0800
     90  0800					      MAC	update_music_vol
     91  0800					      UPDATE_MUSIC_PREP_VOL	{1}	; 4
     92  0800					      UPDATE_MUSIC_SET_VOL	{1}	; 3 =	7
     93  0800					      ENDM
     94  0800
     95  0800					      MAC	update_music
     96  0800					      UPDATE_MUSIC_DATA	{1}	;17
     97  0800					      UPDATE_MUSIC_VOL	{1}	; 7 = 24
     98  0800					      ENDM
     99  0800
    100  0800					      MAC	update_music_wsync
    101  0800					      UPDATE_MUSIC_DATA	{1}	;17
    102  0800					      sta	WSYNC	; 3
    103  0800							;---------------------------------------
    104  0800					      UPDATE_MUSIC_VOL	{1}	; 7 = 27
    105  0800					      ENDM
    106  0800
    107  0800
    108  0800		       00 0a	   NOT_SEL_COL =	$0a
    109  0800
    110  0800					      MAC	set_row_col
    111  0800					      ldx	Platform	; 3
    112  0800					      lda	selRow	; 3
    113  0800					      IF	{1} != 0
    114  0800					      eor	#{1}	; 2	     do NOT change carry!
    115  0800					      ENDIF
    116  0800					      beq	.isSel{1}	; 2/3
    117  0800					      lda	#NOT_SEL_COL	; 2
    118  0800					      bne	.notSel{1}	; 3
    119  0800
    120  0800				   .isSel{1}
    121  0800					      lda	SelectionColTbl,x	; 4
    122  0800				   .notSel{1}
    123  0800					      sta	COLUP0	; 3
    124  0800					      sta	COLUP1	; 3 = 21
    125  0800					      ENDM
    126  0800
    127  0800					      MAC	end_row
    128  0800					      sty	COLUP0	; 3
    129  0800					      sty	COLUP1	; 3
    130  0800					      SLEEP	3	; 3
    131  0800							;    nop     GRP0		      ; 3
    132  0800							;    nop     GRP1		      ; 3
    133  0800							;    nop     GRP0		      ; 3
    134  0800
    135  0800					      UPDATE_MUSIC_DATA_HI	1	; 8 = 17
    136  0800							;---------------------------------------
    137  0800					      UPDATE_MUSIC_VOL	1	; 7	     @07!    <-- AUDV1
    138  0800
    139  0800					      UPDATE_MUSIC_DATA_LO	1	; 9	     @16
    140  0800					      ENDM		;	     @59
    141  0800
    142  0800					      MAC	start_row
    143  0800					      ldy	#LKERNEL_H/8-1	; 2
    144  0800					      sty	loopCntSel	; 3
    145  0800					      lda	(ptrGfxA),y	; 5
    146  0800					      sta	tmpGfxA	; 3
    147  0800
    148  0800					      SET_ROW_COL	{1}	;21		     has to be late!
    149  0800
    150  0800					      jmp	EnterSelLoop{1}	; 3 = 16    @70
    151  0800					      ENDM		;	     @33
    152  0800
    153  0800					      MAC	set_digit_ptr
    154  0800					      ldy	selLst+{1}	; 3
    155  0800					      lda	SelDigitAPtr,y	; 4
    156  0800					      sta	ptrGfxA	; 3
    157  0800					      lda	SelDigitBPtr,y	; 4
    158  0800					      sta	ptrGfxB	; 3 = 14
    159  0800					      ENDM
    160  0800
    161  0800					      MAC	set_char_ptr
    162  0800					      lda	SelCharAPtr,y	; 4
    163  0800					      sta	ptrGfxA	; 3
    164  0800					      lda	SelCharBPtr,y	; 4
    165  0800					      sta	ptrGfxB	; 3 = 14
    166  0800					      ENDM
    167  0800
    168  0800					      MAC	draw_row
    169  0800
    170  0800					      IF	{1} != 0
    171  0800					      ALIGN_FREE	256
    172  0800					      ENDIF
    173  0800
    174  0800							;--------------------------------------------------------------------------
    175  0800							; Code is exquisitely timed so that each line takes
    176  0800							; *EXACTLY* 76 cycles.  Code cannot cross page-boundaries, as the branch
    177  0800							; would then take an extra cycle, and bugger the display.
    178  0800				   LoopSelGfx{1}		;	     @60
    179  0800					      ldx	SelGfxB0_{1}-1,y	; 4
    180  0800					      stx.w	GRP0	; 4
    181  0800
    182  0800					      UPDATE_MUSIC_DATA_HI	1	; 8 = 16    @76
    183  0800							;---------------------------------------
    184  0800					      UPDATE_MUSIC_VOL	1	; 7	     @07!    <-- AUDV1
    185  0800
    186  0800					      UPDATE_MUSIC_DATA_LO	1	; 9	     @16
    187  0800
    188  0800					      lda	SelGfxB1_{1}-1,y	; 4
    189  0800					      sta	GRP1	; 3
    190  0800					      lda	SelGfxB2_{1}-1,y	; 4
    191  0800					      sta	GRP0	; 4 = 14    @30
    192  0800
    193  0800					      lax	(ptrGfxB),y	; 5
    194  0800					      lda	SelGfxB3_{1}-1,y	; 4
    195  0800					      ldy	tmpGfxB	; 3 = 12
    196  0800
    197  0800					      sta	GRP1	; 3	     @45
    198  0800					      sty	GRP0	; 3	     @48
    199  0800					      stx	GRP1	; 3	     @51
    200  0800					      sta	GRP0	; 3 = 15    @54
    201  0800
    202  0800					      ldy	loopCntSel	; 3
    203  0800					      dey		; 2 =	5
    204  0800					      sty	loopCntSel	; 3
    205  0800					      lda	(ptrGfxA),y	; 5
    206  0800					      sta	tmpGfxA	; 3 = 11
    207  0800				   EnterSelLoop{1}		;	     @70
    208  0800					      lax	SelGfxB4_{1}-1,y	; 4
    209  0800							;---------------------------------------
    210  0800				   V_OFS      SET	(3-{1})*4	;		     calculate separately, else this gives wrong results!
    211  0800					      lda	audV0LstBtm+V_OFS,y	; 4
    212  0800					      and	#VOL_MASK	; 2
    213  0800					      UPDATE_MUSIC_SET_VOL	0	; 3 = 13    @07!    <-- AUDV0
    214  0800
    215  0800					      stx	tmpGfxB	; 3
    216  0800					      ldx	SelGfxA0_{1},y	; 4
    217  0800					      stx	GRP0	; 3
    218  0800					      lda	SelGfxA1_{1},y	; 4
    219  0800					      sta	GRP1	; 3
    220  0800					      lda	SelGfxA2_{1},y	; 4
    221  0800					      sta	GRP0	; 3 = 24
    222  0800							;	     @31
    223  0800					      lax	SelGfxA4_{1},y	; 4
    224  0800					      lda	SelGfxA3_{1},y	; 4
    225  0800					      ldy	tmpGfxA	; 3
    226  0800					      sta	GRP1	; 3 = 14    @45!
    227  0800					      stx	GRP0	; 3	     @48
    228  0800					      sty	GRP1	; 3	     @51
    229  0800					      sta	GRP0	; 3 =	9    @54!
    230  0800
    231  0800					      ldy	loopCntSel	; 3
    232  0800					      bne	LoopSelGfx{1}	; 2/3= 5/6  @59
    233  0800					      CHECKPAGE	LoopSelGfx{1}
    234  0800					      ENDM
    235  0800
    236  0800
    237  0800							;===============================================================================
    238  0800							; code starts here
    239  0800							;===============================================================================
    240  0800
    241  0800				   FREE       SET	0
    242  0800
    243  0800							;--------------------------------------------------------------------------
    244  0800
    245  0800				   SwitchToContTitleBank SUBROUTINE
    246  0800							; has to be at start of bank!
    247  0800		       a9 02		      lda	#BANK_ContTitle	; 2
    248  0802		       85 3f		      sta	SET_BANK	; 3
    249  0804		       4c f1 f1 	      jmp	NewFrameTitle	; 3 =	8
    250  0807
    251  0807				   SwitchToDrawLogoBank SUBROUTINE
    252  0807							; has to be at start of bank!
    253  0807		       a9 02		      lda	#BANK_DrawLogo	; 2
    254  0809		       85 3f		      sta	SET_BANK	; 3
    255  080b
    256  080b							; color tables for NTSC/PAL:
    257  080b				   BkColTbl
    258  080b		       00		      .byte.b	0	;$82
    259  080c		       00		      .byte.b	0	;$d2
    260  080d				   StarsColTbl
    261  080d		       00		      .byte.b	0	;$9a
    262  080e		       00		      .byte.b	0	;$da
    263  080f
    264  080f		       f0 0b	   TradeMarkA =	. - 4
    265  080f		       00 00 00 00*	      ds	28, 0	; bottom 7 bytes don't matter
    266  082b		       1c		      .byte.b	%00011100
    267  082c							;    .byte   %00100010
    268  082c		       22		      .byte.b	%00100010
    269  082d							;    .byte   %01010101
    270  082d		       55		      .byte.b	%01010101
    271  082e							;    .byte   %01011001
    272  082e		       55		      .byte.b	%01010101
    273  082f							;    .byte   %01011001
    274  082f		       22		      .byte.b	%00100010
    275  0830							;    .byte   %00100010
    276  0830		       1c		      .byte.b	%00011100
    277  0831		       00 00 00 00*	      ds	(TKERNEL_H-66-9-BORDER_H+1)/2, 0	;
    278  0831		       f0 37	   TradeMarkB =	. - 33
    279  0858							;    .byte   %00011100
    280  0858		       22		      .byte.b	%00100010
    281  0859							;    .byte   %00100010
    282  0859		       55		      .byte.b	%01010101
    283  085a							;    .byte   %01010101
    284  085a		       59		      .byte.b	%01011001
    285  085b							;    .byte   %01010101
    286  085b		       59		      .byte.b	%01011001
    287  085c							;    .byte   %00100010
    288  085c		       22		      .byte.b	%00100010
    289  085d							;    .byte   %00011100
    290  085d		       00 00 00 00*	      ds	(TKERNEL_H-66-9-BORDER_H+1)/2, 0	;
      0  0884					      CHECKPAGE	TradeMarkA
      8  0884					      LIST	ON
    292  0884
    293  0884							;-----------------------------------------------------------
    294  0884							; Table defining the height of each PF graphics block.
    295  0884							; Total number must be even!
    296  0884
    297  0884				   NextXTbl
    298  0884							; stop byte
    299  0884		       ff		      .byte.b	-1
    300  0885							; bottom border:
    301  0885					      REPEAT	BORDER_H/2
    302  0885		       00		      .byte.b	0
    301  0885					      REPEND
    302  0886		       00		      .byte.b	0
    301  0886					      REPEND
    302  0887		       00		      .byte.b	0
    301  0887					      REPEND
    302  0888		       00		      .byte.b	0
    303  0889					      REPEND
    304  0889					      REPEAT	GAP_H/2
    305  0889		       01		      .byte.b	1
    304  0889					      REPEND
    305  088a		       01		      .byte.b	1
    304  088a					      REPEND
    305  088b		       01		      .byte.b	1
    306  088c					      REPEND
    307  088c							; title graphics:
    308  088c				   X	      SET	2
    309  088c					      REPEAT	NUM_BLOCKS
    310  088c					      REPEAT	BLOCK_H/2
    311  088c		       02		      .byte.b	X
    310  088c					      REPEND
    311  088d		       02		      .byte.b	X
    312  088e					      REPEND
    313  088e				   X	      SET	X+1
    309  088e					      REPEND
    310  088e					      REPEAT	BLOCK_H/2
    311  088e		       03		      .byte.b	X
    310  088e					      REPEND
    311  088f		       03		      .byte.b	X
    312  0890					      REPEND
    313  0890				   X	      SET	X+1
    309  0890					      REPEND
    310  0890					      REPEAT	BLOCK_H/2
    311  0890		       04		      .byte.b	X
    310  0890					      REPEND
    311  0891		       04		      .byte.b	X
    312  0892					      REPEND
    313  0892				   X	      SET	X+1
    309  0892					      REPEND
    310  0892					      REPEAT	BLOCK_H/2
    311  0892		       05		      .byte.b	X
    310  0892					      REPEND
    311  0893		       05		      .byte.b	X
    312  0894					      REPEND
    313  0894				   X	      SET	X+1
    309  0894					      REPEND
    310  0894					      REPEAT	BLOCK_H/2
    311  0894		       06		      .byte.b	X
    310  0894					      REPEND
    311  0895		       06		      .byte.b	X
    312  0896					      REPEND
    313  0896				   X	      SET	X+1
    309  0896					      REPEND
    310  0896					      REPEAT	BLOCK_H/2
    311  0896		       07		      .byte.b	X
    310  0896					      REPEND
    311  0897		       07		      .byte.b	X
    312  0898					      REPEND
    313  0898				   X	      SET	X+1
    309  0898					      REPEND
    310  0898					      REPEAT	BLOCK_H/2
    311  0898		       08		      .byte.b	X
    310  0898					      REPEND
    311  0899		       08		      .byte.b	X
    312  089a					      REPEND
    313  089a				   X	      SET	X+1
    309  089a					      REPEND
    310  089a					      REPEAT	BLOCK_H/2
    311  089a		       09		      .byte.b	X
    310  089a					      REPEND
    311  089b		       09		      .byte.b	X
    312  089c					      REPEND
    313  089c				   X	      SET	X+1
    309  089c					      REPEND
    310  089c					      REPEAT	BLOCK_H/2
    311  089c		       0a		      .byte.b	X
    310  089c					      REPEND
    311  089d		       0a		      .byte.b	X
    312  089e					      REPEND
    313  089e				   X	      SET	X+1
    309  089e					      REPEND
    310  089e					      REPEAT	BLOCK_H/2
    311  089e		       0b		      .byte.b	X
    310  089e					      REPEND
    311  089f		       0b		      .byte.b	X
    312  08a0					      REPEND
    313  08a0				   X	      SET	X+1
    309  08a0					      REPEND
    310  08a0					      REPEAT	BLOCK_H/2
    311  08a0		       0c		      .byte.b	X
    310  08a0					      REPEND
    311  08a1		       0c		      .byte.b	X
    312  08a2					      REPEND
    313  08a2				   X	      SET	X+1
    309  08a2					      REPEND
    310  08a2					      REPEAT	BLOCK_H/2
    311  08a2		       0d		      .byte.b	X
    310  08a2					      REPEND
    311  08a3		       0d		      .byte.b	X
    312  08a4					      REPEND
    313  08a4				   X	      SET	X+1
    309  08a4					      REPEND
    310  08a4					      REPEAT	BLOCK_H/2
    311  08a4		       0e		      .byte.b	X
    310  08a4					      REPEND
    311  08a5		       0e		      .byte.b	X
    312  08a6					      REPEND
    313  08a6				   X	      SET	X+1
    309  08a6					      REPEND
    310  08a6					      REPEAT	BLOCK_H/2
    311  08a6		       0f		      .byte.b	X
    310  08a6					      REPEND
    311  08a7		       0f		      .byte.b	X
    312  08a8					      REPEND
    313  08a8				   X	      SET	X+1
    309  08a8					      REPEND
    310  08a8					      REPEAT	BLOCK_H/2
    311  08a8		       10		      .byte.b	X
    310  08a8					      REPEND
    311  08a9		       10		      .byte.b	X
    312  08aa					      REPEND
    313  08aa				   X	      SET	X+1
    309  08aa					      REPEND
    310  08aa					      REPEAT	BLOCK_H/2
    311  08aa		       11		      .byte.b	X
    310  08aa					      REPEND
    311  08ab		       11		      .byte.b	X
    312  08ac					      REPEND
    313  08ac				   X	      SET	X+1
    309  08ac					      REPEND
    310  08ac					      REPEAT	BLOCK_H/2
    311  08ac		       12		      .byte.b	X
    310  08ac					      REPEND
    311  08ad		       12		      .byte.b	X
    312  08ae					      REPEND
    313  08ae				   X	      SET	X+1
    309  08ae					      REPEND
    310  08ae					      REPEAT	BLOCK_H/2
    311  08ae		       13		      .byte.b	X
    310  08ae					      REPEND
    311  08af		       13		      .byte.b	X
    312  08b0					      REPEND
    313  08b0				   X	      SET	X+1
    309  08b0					      REPEND
    310  08b0					      REPEAT	BLOCK_H/2
    311  08b0		       14		      .byte.b	X
    310  08b0					      REPEND
    311  08b1		       14		      .byte.b	X
    312  08b2					      REPEND
    313  08b2				   X	      SET	X+1
    309  08b2					      REPEND
    310  08b2					      REPEAT	BLOCK_H/2
    311  08b2		       15		      .byte.b	X
    310  08b2					      REPEND
    311  08b3		       15		      .byte.b	X
    312  08b4					      REPEND
    313  08b4				   X	      SET	X+1
    309  08b4					      REPEND
    310  08b4					      REPEAT	BLOCK_H/2
    311  08b4		       16		      .byte.b	X
    310  08b4					      REPEND
    311  08b5		       16		      .byte.b	X
    312  08b6					      REPEND
    313  08b6				   X	      SET	X+1
    309  08b6					      REPEND
    310  08b6					      REPEAT	BLOCK_H/2
    311  08b6		       17		      .byte.b	X
    310  08b6					      REPEND
    311  08b7		       17		      .byte.b	X
    312  08b8					      REPEND
    313  08b8				   X	      SET	X+1
    309  08b8					      REPEND
    310  08b8					      REPEAT	BLOCK_H/2
    311  08b8		       18		      .byte.b	X
    310  08b8					      REPEND
    311  08b9		       18		      .byte.b	X
    312  08ba					      REPEND
    313  08ba				   X	      SET	X+1
    309  08ba					      REPEND
    310  08ba					      REPEAT	BLOCK_H/2
    311  08ba		       19		      .byte.b	X
    310  08ba					      REPEND
    311  08bb		       19		      .byte.b	X
    312  08bc					      REPEND
    313  08bc				   X	      SET	X+1
    309  08bc					      REPEND
    310  08bc					      REPEAT	BLOCK_H/2
    311  08bc		       1a		      .byte.b	X
    310  08bc					      REPEND
    311  08bd		       1a		      .byte.b	X
    312  08be					      REPEND
    313  08be				   X	      SET	X+1
    309  08be					      REPEND
    310  08be					      REPEAT	BLOCK_H/2
    311  08be		       1b		      .byte.b	X
    310  08be					      REPEND
    311  08bf		       1b		      .byte.b	X
    312  08c0					      REPEND
    313  08c0				   X	      SET	X+1
    309  08c0					      REPEND
    310  08c0					      REPEAT	BLOCK_H/2
    311  08c0		       1c		      .byte.b	X
    310  08c0					      REPEND
    311  08c1		       1c		      .byte.b	X
    312  08c2					      REPEND
    313  08c2				   X	      SET	X+1
    309  08c2					      REPEND
    310  08c2					      REPEAT	BLOCK_H/2
    311  08c2		       1d		      .byte.b	X
    310  08c2					      REPEND
    311  08c3		       1d		      .byte.b	X
    312  08c4					      REPEND
    313  08c4				   X	      SET	X+1
    309  08c4					      REPEND
    310  08c4					      REPEAT	BLOCK_H/2
    311  08c4		       1e		      .byte.b	X
    310  08c4					      REPEND
    311  08c5		       1e		      .byte.b	X
    312  08c6					      REPEND
    313  08c6				   X	      SET	X+1
    309  08c6					      REPEND
    310  08c6					      REPEAT	BLOCK_H/2
    311  08c6		       1f		      .byte.b	X
    310  08c6					      REPEND
    311  08c7		       1f		      .byte.b	X
    312  08c8					      REPEND
    313  08c8				   X	      SET	X+1
    309  08c8					      REPEND
    310  08c8					      REPEAT	BLOCK_H/2
    311  08c8		       20		      .byte.b	X
    310  08c8					      REPEND
    311  08c9		       20		      .byte.b	X
    312  08ca					      REPEND
    313  08ca				   X	      SET	X+1
    309  08ca					      REPEND
    310  08ca					      REPEAT	BLOCK_H/2
    311  08ca		       21		      .byte.b	X
    310  08ca					      REPEND
    311  08cb		       21		      .byte.b	X
    312  08cc					      REPEND
    313  08cc				   X	      SET	X+1
    309  08cc					      REPEND
    310  08cc					      REPEAT	BLOCK_H/2
    311  08cc		       22		      .byte.b	X
    310  08cc					      REPEND
    311  08cd		       22		      .byte.b	X
    312  08ce					      REPEND
    313  08ce				   X	      SET	X+1
    314  08ce					      REPEND
    315  08ce							; top border:
    316  08ce					      REPEAT	GAP_H/2
    317  08ce		       01		      .byte.b	1	; use symmetry
    316  08ce					      REPEND
    317  08cf		       01		      .byte.b	1	; use symmetry
    316  08cf					      REPEND
    317  08d0		       01		      .byte.b	1	; use symmetry
    318  08d1					      REPEND
    319  08d1				   X	      SET	X+1
    320  08d1					      REPEAT	BORDER_H/2
    321  08d1		       00		      .byte.b	0	; use symmetry
    320  08d1					      REPEND
    321  08d2		       00		      .byte.b	0	; use symmetry
    320  08d2					      REPEND
    321  08d3		       00		      .byte.b	0	; use symmetry
    320  08d3					      REPEND
    321  08d4		       00		      .byte.b	0	; use symmetry
    322  08d5					      REPEND
      0  08d5					      CHECKPAGE	NextXTbl
      8  08d5					      LIST	ON
    324  08d5
    325  08d5							;-----------------------------------------------------------
    326  08d5							; BOX DASH PF graphics data:
    327  08d5
    328  08d5				   title_STRIP_0
    329  08d5		       00 00 00 00*	      ds	35,0
      0  08f8					      CHECKPAGE	title_STRIP_0
      8  08f8					      LIST	ON
    331  08f8
      0  08f8					      ALIGN_FREE	256
      1  08f8				   FREE       SET	FREE - .
      2  0900		       00 00 00 00*	      align	256
      3  0900				   FREE       SET	FREE + .
 @ $f100 : $8
      4  0900					      echo	"@", ., ":", FREE
    333  0900
    334  0900				   title_STRIP_1
    335  0900		       00 00 00 00*	      ds	35,0
      0  0923					      CHECKPAGE	title_STRIP_1
      8  0923					      LIST	ON
    337  0923
    338  0923				   title_STRIP_2
    339  0923		       00 00 00 00*	      ds	35,0
      0  0946					      CHECKPAGE	title_STRIP_2
      8  0946					      LIST	ON
    341  0946
    342  0946				   title_STRIP_3
    343  0946		       00 00 00 00*	      ds	35,0
      0  0969					      CHECKPAGE	title_STRIP_3
      8  0969					      LIST	ON
    345  0969
    346  0969				   title_STRIP_4
    347  0969		       00 00 00 00*	      ds	35,0
      0  098c					      CHECKPAGE	title_STRIP_4
      8  098c					      LIST	ON
    349  098c
    350  098c				   title_STRIP_5
    351  098c		       00 00 00 00*	      ds	35,0
      0  09af					      CHECKPAGE	title_STRIP_5
      8  09af					      LIST	ON
    353  09af
    354  09af							;    ALIGN_FREE 256
    355  09af
    356  09af							;    ds  $1d, 0
    357  09af							; kernel alignment
    358  09af							;    ds  11, 0
    359  09af							;------------------------------------------------------------------------------
    360  09af
      0  09af					      DEFINE_SUBROUTINE	TitleScreen
      1  09af		       00 01	   BANK_TitleScreen =	_CURRENT_BANK
      2  09af					      SUBROUTINE
      3  09af				   TitleScreen
    362  09af
    363  09af							; clear TIA:
    364  09af		       a9 00		      lda	#0
    365  09b1		       a2 2c		      ldx	#CXCLR-TIA_BASE_ADDRESS
    366  09b3				   .loopClearTIA
    367  09b3		       95 40		      sta	TIA_BASE_ADDRESS,x
    368  09b5		       ca		      dex
    369  09b6		       10 fb		      bpl	.loopClearTIA
    370  09b8
    371  09b8							; clear title RAM to avoid initial sound disturbances
    372  09b8		       a2 7d		      ldx	#endOfTitleRAM-startOfTitleRAM
    373  09ba				   .loopClearRAM
    374  09ba		       ca		      dex
    375  09bb		       95 82		      sta	startOfTitleRAM,x
    376  09bd		       d0 fb		      bne	.loopClearRAM
    377  09bf
    378  09bf		       e6 8a		      inc	noteLen	; 5	     == 1
    379  09c1		       e6 86		      inc	titleMode
    380  09c3
    381  09c3		       a9 01		      lda	#BANK_TitleScreen
    382  09c5		       85 c1		      sta	ROM_Bank
    383  09c7
    384  09c7		       a9 f6		      lda	#>CharGfx
    385  09c9		       85 9a		      sta	ptrGfxA+1
    386  09cb		       85 9c		      sta	ptrGfxB+1
    387  09cd
    388  09cd		       20 d5 f7 	      jsr	DetectConsole
    389  09d0
    390  09d0							; special resync required here, since PAL-60 is not supported:
    391  09d0							;    RESYNC			      ; 		  -> X, Y == 0
    392  09d0
    393  09d0							; resync screen, X and Y == 0 afterwards
    394  09d0							;	  lda #%10			  ; make sure VBLANK is ON
    395  09d0		       85 41		      sta	VBLANK
    396  09d2
    397  09d2		       a2 08		      ldx	#8	; 5 or more RESYNC_FRAMES
    398  09d4				   .loopResync
      0  09d4					      VERTICAL_SYNC
      1  09d4		       a9 0e		      lda	#%1110
      2  09d6		       85 42	   .VSLP1     sta	WSYNC
      3  09d8		       85 40		      sta	VSYNC
      4  09da		       4a		      lsr
      5  09db		       d0 f9		      bne	.VSLP1
    400  09dd
    401  09dd		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
    402  09df		       a5 81		      lda	Platform
    403  09e1		       29 02		      and	#PAL	; only test for PAL (carry unharmed!)
    404  09e3		       f0 02		      beq	.ntsc
    405  09e5		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
    406  09e7				   .ntsc
    407  09e7				   .loopWait
    408  09e7		       85 42		      sta	WSYNC
    409  09e9		       85 42		      sta	WSYNC
    410  09eb		       88		      dey
    411  09ec		       d0 f9		      bne	.loopWait
    412  09ee		       ca		      dex
    413  09ef		       d0 e3		      bne	.loopResync
    414  09f1
    415  09f1
    416  09f1							;    clc			      ; 		 can be removed after debugging
    417  09f1
    418  09f1				   NewFrameTitle SUBROUTINE
    419  09f1
    420  09f1							; start of vertical sync processing:
    421  09f1				   VerticalSync
    422  09f1							; Y = 00!
    423  09f1							;---------------------------------------
    424  09f1				   TEST1
    425  09f1							;    jsr     UpdateMusicWSync1       ;39	  @13
      0  09f1					      UPDATE_MUSIC_WSYNC	1	;27	     @07
      0  09f1					      UPDATE_MUSIC_DATA	1
      0  09f1					      UPDATE_MUSIC_DATA_LO	1
      0  09f1					      CHECK_CLC
      1  09f1
      2  09f1
      3  09f1		       a5 92		      lda	audv1Lo
      4  09f3		       65 8d		      adc	note1
      5  09f5		       85 92		      sta	audv1Lo
      0  09f7					      UPDATE_MUSIC_DATA_HI	1
      1  09f7		       a5 93		      lda	audv1Hi
      2  09f9		       69 00		      adc	#0
      3  09fb		       85 93		      sta	audv1Hi
      2  09fd		       85 42		      sta	WSYNC
      3  09ff
      0  09ff					      UPDATE_MUSIC_VOL	1
      0  09ff					      UPDATE_MUSIC_PREP_VOL	1
      1  09ff		       29 06		      and	#VOL_MASK/2
      2  0a01		       0a		      asl
      0  0a02					      UPDATE_MUSIC_SET_VOL	1
      1  0a02					      IF	PLAY_CH_1 == YES
      2  0a02		       85 5a		      sta	AUDV1
      3  0a04				  -	      ELSE
      4  0a04				  -	      nop	AUDV1
      5  0a04					      ENDIF
    427  0a04		       a9 72		      lda	#$72	; 2		     this value is important for the stars effect
    428  0a06		       85 63		      sta	HMM1	; 3
    429  0a08		       85 40		      sta	VSYNC	; 3 =	8	     enable VSYNC
    430  0a0a							; put into here, just because we have time:
    431  0a0a		       a9 0e		      lda	#TWHITE	; 2
    432  0a0c		       85 48		      sta	COLUPF	; 3
    433  0a0e		       85 46		      sta	COLUP0	; 3 =	8
    434  0a10
    435  0a10							; prepare data for 1st screen row:
    436  0a10		       a5 86		      lda	titleMode	; 3
    437  0a12		       f0 06		      beq	.selMode	; 2/3
    438  0a14							; for logo screen:
    439  0a14		       a2 90		      ldx	#$90	; 2
    440  0a16		       86 60		      stx	HMP0	; 3
    441  0a18		       d0 05		      bne	.setHMP0	; 3
    442  0a1a
    443  0a1a							; for selection screen:
    444  0a1a				   .selMode		; 6
    445  0a1a		       a6 89		      ldx	hmJunior	; 3		     $f0/$50
    446  0a1c		       86 61		      stx	HMP1	; 3
    447  0a1e		       ca		      dex		; 2
    448  0a1f				   .setHMP0
    449  0a1f		       86 60		      stx	HMP0	; 3 = 16
    450  0a21
    451  0a21							;    ldy     #0
    452  0a21		       2c 82 02 	      bit	SWCHB	; 4
    453  0a24				  -	      IF	NTSC_MODE = YES
    454  0a24				  -	      bpl	.primaryPlatform	; 2/3
    455  0a24					      ELSE
    456  0a24		       30 01		      bmi	.primaryPlatform	; 2/3
    457  0a26					      ENDIF
    458  0a26		       c8		      iny		; 2
    459  0a27				   .primaryPlatform
    460  0a27		       84 81		      sty	Platform	; 3 = 11    @47     P1 difficulty --> TV system (0=NTSC, 1=PAL)
    461  0a29
    462  0a29		       c6 8a		      dec	noteLen	; 5		     update frame counter
    463  0a2b							; free: 1
    464  0a2b							;---------------------------------------
    465  0a2b							;    jsr     UpdateMusicWSync0       ;39	  @13
      0  0a2b					      UPDATE_MUSIC_WSYNC	0	;27
      0  0a2b					      UPDATE_MUSIC_DATA	0
      0  0a2b					      UPDATE_MUSIC_DATA_LO	0
      0  0a2b					      CHECK_CLC
      1  0a2b
      2  0a2b
      3  0a2b		       a5 90		      lda	audv0Lo
      4  0a2d		       65 8c		      adc	note0
      5  0a2f		       85 90		      sta	audv0Lo
      0  0a31					      UPDATE_MUSIC_DATA_HI	0
      1  0a31		       a5 91		      lda	audv0Hi
      2  0a33		       69 00		      adc	#0
      3  0a35		       85 91		      sta	audv0Hi
      2  0a37		       85 42		      sta	WSYNC
      3  0a39
      0  0a39					      UPDATE_MUSIC_VOL	0
      0  0a39					      UPDATE_MUSIC_PREP_VOL	0
      1  0a39		       29 06		      and	#VOL_MASK/2
      2  0a3b		       0a		      asl
      0  0a3c					      UPDATE_MUSIC_SET_VOL	0
      1  0a3c					      IF	PLAY_CH_0 == YES
      2  0a3c		       85 59		      sta	AUDV0
      3  0a3e				  -	      ELSE
      4  0a3e				  -	      nop	AUDV0
      5  0a3e					      ENDIF
    467  0a3e
    468  0a3e							; prepare data for 1st screen row:
    469  0a3e		       a6 86		      ldx	titleMode	; 3
    470  0a40		       f0 05		      beq	.selMode2	; 2/3
    471  0a42					      IF	DEMO_VERSION = NO
    472  0a42		       ca		      dex
    473  0a43				  -	      ELSE
    474  0a43				  -	      nop		;		     start with 2nd row in demo version because cave cannot be changed anyway
    475  0a43					      ENDIF
    476  0a43		       86 9d		      stx	selRow	; 3
    477  0a45		       10 19		      bpl	.skipJoyX
    478  0a47
    479  0a47				   .selMode2
    480  0a47
    481  0a47		       a5 8a		      lda	noteLen	; 3
    482  0a49		       d0 15		      bne	.skipJoyX	; 2/3= 5
    483  0a4b
    484  0a4b		       a4 9d		      ldy	selRow	; 3
    485  0a4d		       b6 82		      ldx	selLst,y	; 4 =	7
    486  0a4f
    487  0a4f		       ad 80 02 	      lda	SWCHA	; 4
    488  0a52		       0a		      asl		; 2
    489  0a53		       b0 03		      bcs	.notRight	; 2/3
    490  0a55		       e8		      inx		; 2
    491  0a56		       10 06		      bpl	.setJoyX	; 3
    492  0a58
    493  0a58				   .notRight		; 9
    494  0a58		       18		      clc		; 2
    495  0a59		       30 03		      bmi	.notLeft	; 2/3
    496  0a5b		       ca		      dex		; 2
    497  0a5c		       30 02		      bmi	.skipJoyX	; 2/3
    498  0a5e				   .notLeft
    499  0a5e				   .setJoyX
    500  0a5e		       96 82		      stx	selLst,y	; 4
    501  0a60				   .skipJoyX		;   = 21 max
    502  0a60		       a0 00		      ldy	#0	; 2
    503  0a62							;---------------------------------------
    504  0a62		       20 1a f4 	      jsr	UpdateMusicWSync1	;39	     @13
    505  0a65
    506  0a65							; limit selection values:
    507  0a65
    508  0a65				  -	      IF	FINAL_VERSION = YES
    509  0a65				  -			; limit cave:
    510  0a65				  -	      lda	sLevel	; 3
    511  0a65				  -	      cmp	#3	; 2		     above level 3 only cave A is allowed
    512  0a65				  -	      bcc	.lowLevel	; 2/3
    513  0a65				  -	      sty	sCave	; 3 = 10
    514  0a65				  -.lowLevel
    515  0a65					      ENDIF
    516  0a65
    517  0a65							; limit joysticks:
    518  0a65		       a5 84		      lda	sPlayers	; 3
    519  0a67		       d0 02		      bne	.twoPlayers	; 2/3
    520  0a69		       84 85		      sty	sJoysticks	; 3 =	8
    521  0a6b
    522  0a6b							; limit current selection:
    523  0a6b				   .twoPlayers
    524  0a6b		       a6 9d		      ldx	selRow	; 3
    525  0a6d		       bd cf f7 	      lda	SelMaxTbl,x	; 4
    526  0a70		       d5 82		      cmp	selLst,x	; 3
    527  0a72		       b0 02		      bcs	.selOk	; 2/3
    528  0a74		       95 82		      sta	selLst,x	; 4
    529  0a76				   .selOk
    530  0a76		       18		      clc		; 2 = 18
    531  0a77							; free: 1
    532  0a77							;---------------------------------------
    533  0a77		       20 06 f4 	      jsr	UpdateMusicWSync0	;39	     @13
    534  0a7a		       84 40		      sty	VSYNC	; 3	     @16     disable VSYNC
    535  0a7c
      0  0a7c					      UPDATE_MUSIC_DATA_LO	0	; 9
      0  0a7c					      CHECK_CLC
      1  0a7c
      2  0a7c
      3  0a7c		       a5 90		      lda	audv0Lo
      4  0a7e		       65 8c		      adc	note0
      5  0a80		       85 90		      sta	audv0Lo
    537  0a82		       08		      php		; 3 = 12    @28
    538  0a83							;    clc			      ; 2 = 14	  @30
    539  0a83
    540  0a83		       e6 87		      inc	counter	; 5
    541  0a85		       a5 87		      lda	counter	; 3
    542  0a87		       29 38		      and	#%111000	; 2
    543  0a89		       4a		      lsr		; 2
    544  0a8a		       4a		      lsr		; 2
    545  0a8b		       4a		      lsr		; 2
    546  0a8c		       aa		      tax		; 2 = 18    @48
    547  0a8d							; free: 4
    548  0a8d							;---------------------------------------
    549  0a8d		       20 1a f4 	      jsr	UpdateMusicWSync1	;39	     @13
    550  0a90				   .r2
    551  0a90		       ca		      dex		; 2
    552  0a91		       10 fd		      bpl	.r2	; 2/3
    553  0a93		       85 53		      sta	RESM1	; 3	     @20..55
    554  0a95
    555  0a95		       28		      plp		; 4
      0  0a96					      UPDATE_MUSIC_DATA_HI	0	; 8
      1  0a96		       a5 91		      lda	audv0Hi
      2  0a98		       69 00		      adc	#0
      3  0a9a		       85 91		      sta	audv0Hi
      0  0a9c					      UPDATE_MUSIC_PREP_VOL	0	; 4
      1  0a9c		       29 06		      and	#VOL_MASK/2
      2  0a9e		       0a		      asl
    558  0a9f							; free: 2
    559  0a9f		       85 42		      sta	WSYNC	; 3
    560  0aa1							;---------------------------------------
    561  0aa1		       85 6a		      sta	HMOVE	; 3
      0  0aa3					      UPDATE_MUSIC_SET_VOL_W	0	; 7	     @07!    <-- AUDV0
      1  0aa3					      IF	PLAY_CH_0 == YES
      2  0aa3		       8d 59 00 	      sta.w	AUDV0
      3  0aa6				  -	      ELSE
      4  0aa6				  -	      nop.w	AUDV0
      5  0aa6					      ENDIF
    563  0aa6		       20 2d f4 	      jsr	Wait12	;12		     waste 18 cycles and load move value
    564  0aa9		       88		      dey		; 2
    565  0aaa		       84 63		      sty	HMM1	; 3	     @27     this is the tricky part
    566  0aac
    567  0aac							;-----------------------------------------------------------
    568  0aac
    569  0aac					      IF	L276
    570  0aac		       a0 07		      ldy	#(38-PC_TOP/2)/2	; 2
    571  0aae				  -	      ELSE
    572  0aae				  -	      ldy	#(32-PC_TOP/2)/2	; 2
    573  0aae					      ENDIF
    574  0aae		       a5 81		      lda	Platform	; 3
    575  0ab0		       f0 02		      beq	.vSyncNTSC	; 2/3
    576  0ab2		       a0 16		      ldy	#(68-PC_TOP/2)/2	; 2 = 11
    577  0ab4				   .vSyncNTSC		;	     @38
    578  0ab4		       84 96		      sty	tmpY	; 3
    579  0ab6
    580  0ab6		       a4 cf		      ldy	audV0Lst+PC_TOP	; 3		     take the last precalculated hi value
    581  0ab8							; here we precalculate another 48 values
    582  0ab8		       a2 2f		      ldx	#PC_TOP-1	; 2 =	8
    583  0aba							; free: 10
    584  0aba				   .loopVSync		;	     @46
    585  0aba							;---------------------------------------
      0  0aba					      UPDATE_MUSIC_WSYNC	1	;27	     @07     maintain sound while precalcuating
      0  0aba					      UPDATE_MUSIC_DATA	1
      0  0aba					      UPDATE_MUSIC_DATA_LO	1
      0  0aba					      CHECK_CLC
      1  0aba
      2  0aba
      3  0aba		       a5 92		      lda	audv1Lo
      4  0abc		       65 8d		      adc	note1
      5  0abe		       85 92		      sta	audv1Lo
      0  0ac0					      UPDATE_MUSIC_DATA_HI	1
      1  0ac0		       a5 93		      lda	audv1Hi
      2  0ac2		       69 00		      adc	#0
      3  0ac4		       85 93		      sta	audv1Hi
      2  0ac6		       85 42		      sta	WSYNC
      3  0ac8
      0  0ac8					      UPDATE_MUSIC_VOL	1
      0  0ac8					      UPDATE_MUSIC_PREP_VOL	1
      1  0ac8		       29 06		      and	#VOL_MASK/2
      2  0aca		       0a		      asl
      0  0acb					      UPDATE_MUSIC_SET_VOL	1
      1  0acb					      IF	PLAY_CH_1 == YES
      2  0acb		       85 5a		      sta	AUDV1
      3  0acd				  -	      ELSE
      4  0acd				  -	      nop	AUDV1
      5  0acd					      ENDIF
    587  0acd							; 1st calculation:
      0  0acd					      CHECK_CLC
      1  0acd
    589  0acd		       a5 9e		      lda	audvTmpLo	; 3
    590  0acf		       65 8c		      adc	note0	; 3 =	6
    591  0ad1		       90 03		      bcc	.skipHi1	; 2/3
    592  0ad3		       c8		      iny		; 2
    593  0ad4		       c8		      iny		; 2
    594  0ad5		       18		      clc		; 2
    595  0ad6				   .skipHi1
    596  0ad6		       94 9f		      sty	audV0Lst,x	; 4
    597  0ad8		       ca		      dex		; 2 = 14
    598  0ad9							; 2nd calculation:
      0  0ad9					      CHECK_CLC
      1  0ad9
    600  0ad9		       65 8c		      adc	note0	; 3
    601  0adb		       85 9e		      sta	audvTmpLo	; 3 =	6
    602  0add		       90 03		      bcc	.skipHi2	; 2/3
    603  0adf		       c8		      iny		; 2
    604  0ae0		       c8		      iny		; 2
    605  0ae1		       18		      clc		; 2
    606  0ae2				   .skipHi2
    607  0ae2		       94 9f		      sty	audV0Lst,x	; 4
    608  0ae4		       ca		      dex		; 2 = 14
    609  0ae5							;	     @47 max
    610  0ae5							;---------------------------------------
      0  0ae5					      UPDATE_MUSIC_WSYNC	0	;27	     @07     maintain sound while precalcuating
      0  0ae5					      UPDATE_MUSIC_DATA	0
      0  0ae5					      UPDATE_MUSIC_DATA_LO	0
      0  0ae5					      CHECK_CLC
      1  0ae5
      2  0ae5
      3  0ae5		       a5 90		      lda	audv0Lo
      4  0ae7		       65 8c		      adc	note0
      5  0ae9		       85 90		      sta	audv0Lo
      0  0aeb					      UPDATE_MUSIC_DATA_HI	0
      1  0aeb		       a5 91		      lda	audv0Hi
      2  0aed		       69 00		      adc	#0
      3  0aef		       85 91		      sta	audv0Hi
      2  0af1		       85 42		      sta	WSYNC
      3  0af3
      0  0af3					      UPDATE_MUSIC_VOL	0
      0  0af3					      UPDATE_MUSIC_PREP_VOL	0
      1  0af3		       29 06		      and	#VOL_MASK/2
      2  0af5		       0a		      asl
      0  0af6					      UPDATE_MUSIC_SET_VOL	0
      1  0af6					      IF	PLAY_CH_0 == YES
      2  0af6		       85 59		      sta	AUDV0
      3  0af8				  -	      ELSE
      4  0af8				  -	      nop	AUDV0
      5  0af8					      ENDIF
    612  0af8							; 3rd calculation:
      0  0af8					      CHECK_CLC
      1  0af8
    614  0af8		       a5 9e		      lda	audvTmpLo	; 3
    615  0afa		       65 8c		      adc	note0	; 3 =	6
    616  0afc		       90 03		      bcc	.skipHi3	; 2/3
    617  0afe		       c8		      iny		; 2
    618  0aff		       c8		      iny		; 2
    619  0b00		       18		      clc		; 2
    620  0b01				   .skipHi3
    621  0b01		       94 9f		      sty	audV0Lst,x	; 4
    622  0b03		       ca		      dex		; 2 = 14
    623  0b04							; 4th calculation:
      0  0b04					      CHECK_CLC
      1  0b04
    625  0b04		       65 8c		      adc	note0	; 3
    626  0b06		       85 9e		      sta	audvTmpLo	; 3 =	6
    627  0b08		       90 03		      bcc	.skipHi4	; 2/3
    628  0b0a		       c8		      iny		; 2
    629  0b0b		       c8		      iny		; 2
    630  0b0c		       18		      clc		; 2
    631  0b0d				   .skipHi4
    632  0b0d		       94 9f		      sty	audV0Lst,x	; 4
    633  0b0f		       ca		      dex		; 2 = 14
    634  0b10		       10 a8		      bpl	.loopVSync	; 2/3
    635  0b12							;	     @49 max
    636  0b12		       a6 96		      ldx	tmpY	; 3
    637  0b14							; do the remaining scanlines (required for PAL)
    638  0b14				   .waitVSync
    639  0b14							;---------------------------------------
      0  0b14					      UPDATE_MUSIC_WSYNC	1	;27	     @07
      0  0b14					      UPDATE_MUSIC_DATA	1
      0  0b14					      UPDATE_MUSIC_DATA_LO	1
      0  0b14					      CHECK_CLC
      1  0b14
      2  0b14
      3  0b14		       a5 92		      lda	audv1Lo
      4  0b16		       65 8d		      adc	note1
      5  0b18		       85 92		      sta	audv1Lo
      0  0b1a					      UPDATE_MUSIC_DATA_HI	1
      1  0b1a		       a5 93		      lda	audv1Hi
      2  0b1c		       69 00		      adc	#0
      3  0b1e		       85 93		      sta	audv1Hi
      2  0b20		       85 42		      sta	WSYNC
      3  0b22
      0  0b22					      UPDATE_MUSIC_VOL	1
      0  0b22					      UPDATE_MUSIC_PREP_VOL	1
      1  0b22		       29 06		      and	#VOL_MASK/2
      2  0b24		       0a		      asl
      0  0b25					      UPDATE_MUSIC_SET_VOL	1
      1  0b25					      IF	PLAY_CH_1 == YES
      2  0b25		       85 5a		      sta	AUDV1
      3  0b27				  -	      ELSE
      4  0b27				  -	      nop	AUDV1
      5  0b27					      ENDIF
    641  0b27
    642  0b27		       e0 01		      cpx	#1
    643  0b29		       18		      clc
    644  0b2a		       f0 0e		      beq	.lastLoop
    645  0b2c
    646  0b2c		       a4 82		      ldy	sCave
    647  0b2e		       b9 9d f7 	      lda	SelCharAPtr,y	; 4
    648  0b31		       85 99		      sta	ptrGfxA	; 3
    649  0b33		       b9 b1 f7 	      lda	SelCharBPtr,y	; 4
    650  0b36		       85 9b		      sta	ptrGfxB	; 3
    651  0b38		       90 1c		      bcc	.endLoop	; 3 = 17
    652  0b3a
    653  0b3a				   .lastLoop
    654  0b3a		       a0 03		      ldy	#LKERNEL_H/8-1	; 2
    655  0b3c		       84 98		      sty	loopCntSel	; 3
    656  0b3e		       b1 99		      lda	(ptrGfxA),y	; 5
    657  0b40		       85 96		      sta	tmpGfxA	; 3 = 13
    658  0b42
    659  0b42		       a4 81		      ldy	Platform	; 3
    660  0b44		       b9 0b f0 	      lda	BkColTbl,y	; 4
    661  0b47		       85 49		      sta	COLUBK	; 3 = 10
    662  0b49
    663  0b49							; prepare data for 1st selection screen row:
    664  0b49		       a5 9d		      lda	selRow	; 3
    665  0b4b		       f0 04		      beq	.isSel	; 2/3
    666  0b4d		       a9 0a		      lda	#NOT_SEL_COL	; 2
    667  0b4f		       d0 03		      bne	.notSel	; 3
    668  0b51
    669  0b51				   .isSel
    670  0b51		       b9 fc f6 	      lda	SelectionColTbl,y	; 4
    671  0b54				   .notSel
    672  0b54		       85 97		      sta	tmpGfxB	; 3 = 13
    673  0b56				   .endLoop
    674  0b56							;---------------------------------------
    675  0b56		       20 06 f4 	      jsr	UpdateMusicWSync0	;39	     @13
    676  0b59		       ca		      dex		; 2
    677  0b5a		       d0 b8		      bne	.waitVSync	; 2/3
    678  0b5c
    679  0b5c							;------------------------------------------------------------------------------
    680  0b5c							; START OF DISPLAY
    681  0b5c							;				     ;		 @17
    682  0b5c		       b9 0d f0 	      lda	StarsColTbl,y	; 4		     Y is still set from above!
    683  0b5f		       85 47		      sta	COLUP1	; 3 =	7    @24
    684  0b61
    685  0b61		       a2 00		      ldx	#0	; 2	     also used for kernel!
    686  0b63		       86 65		      stx	VDELP0	; 3
    687  0b65		       86 44		      stx	NUSIZ0	; 3 =	8    @32
    688  0b67
    689  0b67		       a9 15		      lda	#%10101	; 2	     double width missile, double width player
    690  0b69		       85 45		      sta	NUSIZ1	; 3
    691  0b6b		       4a		      lsr		; 2	     bit 1 is set, turn missile0 on
    692  0b6c		       85 5e		      sta	ENAM1	; 3
    693  0b6e		       0a		      asl		; 2
    694  0b6f		       85 4a		      sta	CTRLPF	; 3 = 15    @47     = %00010100
    695  0b71
    696  0b71		       a0 50		      ldy	#TKERNEL_H/2	; 2	     total number of scanlines to display (160, was 149)
    697  0b73
      0  0b73					      UPDATE_MUSIC_DATA_LO	1	; 9
      0  0b73					      CHECK_CLC
      1  0b73
      2  0b73
      3  0b73		       a5 92		      lda	audv1Lo
      4  0b75		       65 8d		      adc	note1
      5  0b77		       85 92		      sta	audv1Lo
    699  0b79
    700  0b79		       85 50		      sta	RESP0	; 3	     @61
    701  0b7b
      0  0b7b					      UPDATE_MUSIC_DATA_HI	1	; 8
      1  0b7b		       a5 93		      lda	audv1Hi
      2  0b7d		       69 00		      adc	#0
      3  0b7f		       85 93		      sta	audv1Hi
      0  0b81					      UPDATE_MUSIC_PREP_VOL	1	; 4 = 12    @73
      1  0b81		       29 06		      and	#VOL_MASK/2
      2  0b83		       0a		      asl
    704  0b84							;    bne    .enterKernel
    705  0b84							;
    706  0b84							;    align 256
    707  0b84							;
    708  0b84							;.enterKernel
    709  0b84		       85 42		      sta	WSYNC
    710  0b86							;---------------------------------------
    711  0b86		       8e 41 00 	      stx.w	VBLANK	; 4 =	4
    712  0b89				   LoopTitle		;	     @04
      0  0b89					      UPDATE_MUSIC_SET_VOL	1	; 3	     @07!    <-- AUDV1
      1  0b89					      IF	PLAY_CH_1 == YES
      2  0b89		       85 5a		      sta	AUDV1
      3  0b8b				  -	      ELSE
      4  0b8b				  -	      nop	AUDV1
      5  0b8b					      ENDIF
    714  0b8b		       bd d5 f0 	      lda	title_STRIP_0,x	; 4
    715  0b8e		       85 4d		      sta	PF0	; 3
    716  0b90		       bd 00 f1 	      lda	title_STRIP_1,x	; 4
    717  0b93		       85 4e		      sta	PF1	; 3
    718  0b95		       bd 23 f1 	      lda	title_STRIP_2,x	; 4
    719  0b98		       85 4f		      sta	PF2	; 3 = 21    @28
    720  0b9a
    721  0b9a		       b9 0b f0 	      lda	TradeMarkA,y	; 4
    722  0b9d		       85 5b		      sta	GRP0	; 3 =	7    @35
    723  0b9f
    724  0b9f		       bd 46 f1 	      lda	title_STRIP_3,x	; 4
    725  0ba2		       85 4d		      sta	PF0	; 3	     @42     <= @47!
    726  0ba4		       bd 69 f1 	      lda	title_STRIP_4,x	; 4
    727  0ba7		       85 4e		      sta	PF1	; 3
    728  0ba9		       bd 8c f1 	      lda	title_STRIP_5,x	; 4
    729  0bac		       85 4f		      sta	PF2	; 3 = 21    @56
    730  0bae
      0  0bae					      UPDATE_MUSIC_DATA_LO	1	; 9
      0  0bae					      CHECK_CLC
      1  0bae
      2  0bae
      3  0bae		       a5 92		      lda	audv1Lo
      4  0bb0		       65 8d		      adc	note1
      5  0bb2		       85 92		      sta	audv1Lo
    732  0bb4							;    SLEEP   9 		      ; 9 = 18	  @74
    733  0bb4		       48		      pha		; 3
    734  0bb5		       68		      pla		; 4
    735  0bb6		       ea		      nop		; 2
    736  0bb7							;---------------------------------------
    737  0bb7		       b9 ae 00 	      lda	audV0LstTop-1,y	; 4
    738  0bba		       29 0c		      and	#VOL_MASK	; 2
      0  0bbc					      UPDATE_MUSIC_SET_VOL	0	; 3 =	9    @07!    <-- AUDV0
      1  0bbc					      IF	PLAY_CH_0 == YES
      2  0bbc		       85 59		      sta	AUDV0
      3  0bbe				  -	      ELSE
      4  0bbe				  -	      nop	AUDV0
      5  0bbe					      ENDIF
    740  0bbe
    741  0bbe		       bd d5 f0 	      lda	title_STRIP_0,x	; 4
    742  0bc1		       85 4d		      sta	PF0	; 3
    743  0bc3		       bd 00 f1 	      lda	title_STRIP_1,x	; 4
    744  0bc6		       85 4e		      sta	PF1	; 3
    745  0bc8		       bd 23 f1 	      lda	title_STRIP_2,x	; 4
    746  0bcb		       85 4f		      sta	PF2	; 3 = 21    @28
    747  0bcd
    748  0bcd		       b9 37 f0 	      lda	TradeMarkB,y	; 4
    749  0bd0		       85 5b		      sta	GRP0	; 3 =	7    @35
    750  0bd2
    751  0bd2		       bd 46 f1 	      lda	title_STRIP_3,x	; 4
    752  0bd5		       85 4d		      sta	PF0	; 3
    753  0bd7		       bd 69 f1 	      lda	title_STRIP_4,x	; 4
    754  0bda		       85 4e		      sta	PF1	; 3
    755  0bdc		       bd 8c f1 	      lda	title_STRIP_5,x	; 4
    756  0bdf		       85 4f		      sta	PF2	; 3 = 21    @56
    757  0be1
      0  0be1					      UPDATE_MUSIC_DATA_HI	1	; 8
      1  0be1		       a5 93		      lda	audv1Hi
      2  0be3		       69 00		      adc	#0
      3  0be5		       85 93		      sta	audv1Hi
      0  0be7					      UPDATE_MUSIC_PREP_VOL	1	; 4
      1  0be7		       29 06		      and	#VOL_MASK/2
      2  0be9		       0a		      asl
      0  0bea					      SLEEP	3	; 3 = 15    @71
      1  0bea				   .CYCLES    SET	3
      2  0bea
      3  0bea				  -	      IF	.CYCLES < 2
      4  0bea				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0bea				  -	      ERR
      6  0bea					      ENDIF
      7  0bea
      8  0bea					      IF	.CYCLES & 1
      9  0bea					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0bea		       04 00		      nop	0
     11  0bec				  -	      ELSE
     12  0bec				  -	      bit	VSYNC
     13  0bec					      ENDIF
     14  0bec				   .CYCLES    SET	.CYCLES - 3
     15  0bec					      ENDIF
     16  0bec
     17  0bec				  -	      REPEAT	.CYCLES / 2
     18  0bec				  -	      nop
     19  0bec					      REPEND
    761  0bec
    762  0bec		       88		      dey		; 2
    763  0bed		       be 84 f0 	      ldx	NextXTbl,y	; 4 =	6    @01
    764  0bf0							;---------------------------------------
    765  0bf0		       10 97		      bpl	LoopTitle	; 2/3= 6    @04
      0  0bf2					      CHECKPAGE	LoopTitle
      8  0bf2					      LIST	ON
    767  0bf2
      0  0bf2					      UPDATE_MUSIC_SET_VOL_W	1	; 4	     @07!    <-- AUDV1
      1  0bf2					      IF	PLAY_CH_1 == YES
      2  0bf2		       8d 5a 00 	      sta.w	AUDV1
      3  0bf5				  -	      ELSE
      4  0bf5				  -	      nop.w	AUDV1
      5  0bf5					      ENDIF
    769  0bf5
    770  0bf5		       84 49		      sty	COLUBK	; 3		     Y==0
    771  0bf7		       84 4d		      sty	PF0	; 3
    772  0bf9		       84 4e		      sty	PF1	; 3
    773  0bfb		       84 4f		      sty	PF2	; 3
    774  0bfd		       84 5e		      sty	ENAM1	; 3 = 15    @22
    775  0bff
    776  0bff		       a5 86		      lda	titleMode	; 3
    777  0c01		       f0 2b		      beq	DrawSelection	; 2/4	     @29
    778  0c03		       4c 07 f0 	      jmp	SwitchToDrawLogoBank	; 8	     @35
    779  0c06
    780  0c06							;--------------------------------------------------------------------------
    781  0c06
    782  0c06				   UpdateMusicWSync0
    783  0c06							; maintain first channel
      0  0c06					      UPDATE_MUSIC_WSYNC	0	;27
      0  0c06					      UPDATE_MUSIC_DATA	0
      0  0c06					      UPDATE_MUSIC_DATA_LO	0
      0  0c06					      CHECK_CLC
      1  0c06
      2  0c06
      3  0c06		       a5 90		      lda	audv0Lo
      4  0c08		       65 8c		      adc	note0
      5  0c0a		       85 90		      sta	audv0Lo
      0  0c0c					      UPDATE_MUSIC_DATA_HI	0
      1  0c0c		       a5 91		      lda	audv0Hi
      2  0c0e		       69 00		      adc	#0
      3  0c10		       85 91		      sta	audv0Hi
      2  0c12		       85 42		      sta	WSYNC
      3  0c14
      0  0c14					      UPDATE_MUSIC_VOL	0
      0  0c14					      UPDATE_MUSIC_PREP_VOL	0
      1  0c14		       29 06		      and	#VOL_MASK/2
      2  0c16		       0a		      asl
      0  0c17					      UPDATE_MUSIC_SET_VOL	0
      1  0c17					      IF	PLAY_CH_0 == YES
      2  0c17		       85 59		      sta	AUDV0
      3  0c19				  -	      ELSE
      4  0c19				  -	      nop	AUDV0
      5  0c19					      ENDIF
    785  0c19		       60		      rts		; 6 = 33
    786  0c1a
    787  0c1a				   UpdateMusicWSync1
    788  0c1a							; maintain second channel
      0  0c1a					      UPDATE_MUSIC_WSYNC	1	;27
      0  0c1a					      UPDATE_MUSIC_DATA	1
      0  0c1a					      UPDATE_MUSIC_DATA_LO	1
      0  0c1a					      CHECK_CLC
      1  0c1a
      2  0c1a
      3  0c1a		       a5 92		      lda	audv1Lo
      4  0c1c		       65 8d		      adc	note1
      5  0c1e		       85 92		      sta	audv1Lo
      0  0c20					      UPDATE_MUSIC_DATA_HI	1
      1  0c20		       a5 93		      lda	audv1Hi
      2  0c22		       69 00		      adc	#0
      3  0c24		       85 93		      sta	audv1Hi
      2  0c26		       85 42		      sta	WSYNC
      3  0c28
      0  0c28					      UPDATE_MUSIC_VOL	1
      0  0c28					      UPDATE_MUSIC_PREP_VOL	1
      1  0c28		       29 06		      and	#VOL_MASK/2
      2  0c2a		       0a		      asl
      0  0c2b					      UPDATE_MUSIC_SET_VOL	1
      1  0c2b					      IF	PLAY_CH_1 == YES
      2  0c2b		       85 5a		      sta	AUDV1
      3  0c2d				  -	      ELSE
      4  0c2d				  -	      nop	AUDV1
      5  0c2d					      ENDIF
    790  0c2d				   Wait12
    791  0c2d		       60		      rts		; 6 = 33
    792  0c2e
    793  0c2e							;--------------------------------------------------------------------------
    794  0c2e							; 6-sprite routine; 32+2 lines of sprites for selection screen.
      0  0c2e					      DEFINE_SUBROUTINE	DrawSelection
      1  0c2e		       00 01	   BANK_DrawSelection =	_CURRENT_BANK
      2  0c2e					      SUBROUTINE
      3  0c2e				   DrawSelection
    796  0c2e
    797  0c2e							;    lda     #1		      ; 2
    798  0c2e							;    sta.w   VDELP1		      ; 4
    799  0c2e
      0  0c2e					      SLEEP	6
      1  0c2e				   .CYCLES    SET	6
      2  0c2e
      3  0c2e				  -	      IF	.CYCLES < 2
      4  0c2e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0c2e				  -	      ERR
      6  0c2e					      ENDIF
      7  0c2e
      8  0c2e				  -	      IF	.CYCLES & 1
      9  0c2e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0c2e				  -	      nop	0
     11  0c2e				  -	      ELSE
     12  0c2e				  -	      bit	VSYNC
     13  0c2e				  -	      ENDIF
     14  0c2e				  -.CYCLES    SET	.CYCLES - 3
     15  0c2e					      ENDIF
     16  0c2e
     17  0c2e					      REPEAT	.CYCLES / 2
     18  0c2e		       ea		      nop
     17  0c2e					      REPEND
     18  0c2f		       ea		      nop
     17  0c2f					      REPEND
     18  0c30		       ea		      nop
     19  0c31					      REPEND
    801  0c31							;	     @35
    802  0c31		       a9 03		      lda	#%00011	; 2
    803  0c33
    804  0c33		       85 50		      sta	RESP0	; 3	     @40     centered
    805  0c35		       85 51		      sta	RESP1	; 3	     @43
    806  0c37
    807  0c37		       85 44		      sta	NUSIZ0	; 3
    808  0c39		       85 45		      sta	NUSIZ1	; 3
    809  0c3b		       85 65		      sta	VDELP0	; 3 =	9    @52
    810  0c3d
    811  0c3d							; Cave:
    812  0c3d		       a0 03		      ldy	#LKERNEL_H/8-1	; 2
    813  0c3f							;    sty     loopCntSel	      ; 3
    814  0c3f							;    lda     (ptrGfxA),y	      ; 5
    815  0c3f							;    sta     tmpGfxA		      ; 3 = 10
    816  0c3f		       a5 97		      lda	tmpGfxB	; 3
    817  0c41		       8d 46 00 	      sta.w	COLUP0	; 4
    818  0c44		       85 47		      sta	COLUP1	; 3 = 10    @64
    819  0c46							;---------------------------------------
    820  0c46							;    sta     HMOVE		      ; 3	  @67
    821  0c46							;    jmp     EnterSelLoop0	      ; 3 =  6	  @70
    822  0c46
    823  0c46		       bf b1 f6 	      lax	SelGfxB4_0-1,y	; 4
    824  0c49		       85 6a		      sta	HMOVE	; 3	     @71
    825  0c4b		       4c 8a f4 	      jmp	EnterSelLoop0+3	; 3 =	6    @74
    826  0c4e
    827  0c4e							;    ALIGN_FREE 256
    828  0c4e
      0  0c4e					      DRAW_ROW	0	;	     @59
      1  0c4e
      2  0c4e				  -	      IF	0 != 0
      3  0c4e				  -	      ALIGN_FREE	256
      4  0c4e					      ENDIF
      5  0c4e
      6  0c4e
      7  0c4e
      8  0c4e
      9  0c4e
     10  0c4e				   LoopSelGfx0
     11  0c4e		       be d5 f5 	      ldx	SelGfxB0_0-1,y
     12  0c51		       8e 5b 00 	      stx.w	GRP0
     13  0c54
      0  0c54					      UPDATE_MUSIC_DATA_HI	1
      1  0c54		       a5 93		      lda	audv1Hi
      2  0c56		       69 00		      adc	#0
      3  0c58		       85 93		      sta	audv1Hi
     15  0c5a
      0  0c5a					      UPDATE_MUSIC_VOL	1
      0  0c5a					      UPDATE_MUSIC_PREP_VOL	1
      1  0c5a		       29 06		      and	#VOL_MASK/2
      2  0c5c		       0a		      asl
      0  0c5d					      UPDATE_MUSIC_SET_VOL	1
      1  0c5d					      IF	PLAY_CH_1 == YES
      2  0c5d		       85 5a		      sta	AUDV1
      3  0c5f				  -	      ELSE
      4  0c5f				  -	      nop	AUDV1
      5  0c5f					      ENDIF
     17  0c5f
      0  0c5f					      UPDATE_MUSIC_DATA_LO	1
      0  0c5f					      CHECK_CLC
      1  0c5f
      2  0c5f
      3  0c5f		       a5 92		      lda	audv1Lo
      4  0c61		       65 8d		      adc	note1
      5  0c63		       85 92		      sta	audv1Lo
     19  0c65
     20  0c65		       b9 e1 f5 	      lda	SelGfxB1_0-1,y
     21  0c68		       85 5c		      sta	GRP1
     22  0c6a		       b9 ed f5 	      lda	SelGfxB2_0-1,y
     23  0c6d		       85 5b		      sta	GRP0
     24  0c6f
     25  0c6f		       b3 9b		      lax	(ptrGfxB),y
     26  0c71		       b9 f9 f5 	      lda	SelGfxB3_0-1,y
     27  0c74		       a4 97		      ldy	tmpGfxB
     28  0c76
     29  0c76		       85 5c		      sta	GRP1
     30  0c78		       84 5b		      sty	GRP0
     31  0c7a		       86 5c		      stx	GRP1
     32  0c7c		       85 5b		      sta	GRP0
     33  0c7e
     34  0c7e		       a4 98		      ldy	loopCntSel
     35  0c80		       88		      dey
     36  0c81		       84 98		      sty	loopCntSel
     37  0c83		       b1 99		      lda	(ptrGfxA),y
     38  0c85		       85 96		      sta	tmpGfxA
     39  0c87				   EnterSelLoop0
     40  0c87		       bf b1 f6 	      lax	SelGfxB4_0-1,y
     41  0c8a
     42  0c8a				   V_OFS      SET	(3-0)*4
     43  0c8a		       b9 ab 00 	      lda	audV0LstBtm+V_OFS,y
     44  0c8d		       29 0c		      and	#VOL_MASK
      0  0c8f					      UPDATE_MUSIC_SET_VOL	0
      1  0c8f					      IF	PLAY_CH_0 == YES
      2  0c8f		       85 59		      sta	AUDV0
      3  0c91				  -	      ELSE
      4  0c91				  -	      nop	AUDV0
      5  0c91					      ENDIF
     46  0c91
     47  0c91		       86 97		      stx	tmpGfxB
     48  0c93		       be a9 f5 	      ldx	SelGfxA0_0,y
     49  0c96		       86 5b		      stx	GRP0
     50  0c98		       b9 89 f7 	      lda	SelGfxA1_0,y
     51  0c9b		       85 5c		      sta	GRP1
     52  0c9d		       b9 99 f7 	      lda	SelGfxA2_0,y
     53  0ca0		       85 5b		      sta	GRP0
     54  0ca2
     55  0ca2		       bf c9 f5 	      lax	SelGfxA4_0,y
     56  0ca5		       b9 b9 f5 	      lda	SelGfxA3_0,y
     57  0ca8		       a4 96		      ldy	tmpGfxA
     58  0caa		       85 5c		      sta	GRP1
     59  0cac		       86 5b		      stx	GRP0
     60  0cae		       84 5c		      sty	GRP1
     61  0cb0		       85 5b		      sta	GRP0
     62  0cb2
     63  0cb2		       a4 98		      ldy	loopCntSel
     64  0cb4		       d0 98		      bne	LoopSelGfx0
      0  0cb6					      CHECKPAGE	LoopSelGfx0
      8  0cb6					      LIST	ON
      0  0cb6					      END_ROW		;	     @16
      1  0cb6		       84 46		      sty	COLUP0
      2  0cb8		       84 47		      sty	COLUP1
      0  0cba					      SLEEP	3
      1  0cba				   .CYCLES    SET	3
      2  0cba
      3  0cba				  -	      IF	.CYCLES < 2
      4  0cba				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0cba				  -	      ERR
      6  0cba					      ENDIF
      7  0cba
      8  0cba					      IF	.CYCLES & 1
      9  0cba					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0cba		       04 00		      nop	0
     11  0cbc				  -	      ELSE
     12  0cbc				  -	      bit	VSYNC
     13  0cbc					      ENDIF
     14  0cbc				   .CYCLES    SET	.CYCLES - 3
     15  0cbc					      ENDIF
     16  0cbc
     17  0cbc				  -	      REPEAT	.CYCLES / 2
     18  0cbc				  -	      nop
     19  0cbc					      REPEND
      4  0cbc
      5  0cbc
      6  0cbc
      7  0cbc
      0  0cbc					      UPDATE_MUSIC_DATA_HI	1
      1  0cbc		       a5 93		      lda	audv1Hi
      2  0cbe		       69 00		      adc	#0
      3  0cc0		       85 93		      sta	audv1Hi
      9  0cc2
      0  0cc2					      UPDATE_MUSIC_VOL	1
      0  0cc2					      UPDATE_MUSIC_PREP_VOL	1
      1  0cc2		       29 06		      and	#VOL_MASK/2
      2  0cc4		       0a		      asl
      0  0cc5					      UPDATE_MUSIC_SET_VOL	1
      1  0cc5					      IF	PLAY_CH_1 == YES
      2  0cc5		       85 5a		      sta	AUDV1
      3  0cc7				  -	      ELSE
      4  0cc7				  -	      nop	AUDV1
      5  0cc7					      ENDIF
     11  0cc7
      0  0cc7					      UPDATE_MUSIC_DATA_LO	1
      0  0cc7					      CHECK_CLC
      1  0cc7
      2  0cc7
      3  0cc7		       a5 92		      lda	audv1Lo
      4  0cc9		       65 8d		      adc	note1
      5  0ccb		       85 92		      sta	audv1Lo
    831  0ccd
    832  0ccd							; Level 1/2:
      0  0ccd					      SET_DIGIT_PTR	1	;17
      1  0ccd		       a4 83		      ldy	selLst+1
      2  0ccf		       b9 c5 f7 	      lda	SelDigitAPtr,y
      3  0cd2		       85 99		      sta	ptrGfxA
      4  0cd4		       b9 ca f7 	      lda	SelDigitBPtr,y
      5  0cd7		       85 9b		      sta	ptrGfxB
      0  0cd9					      START_ROW	1
      1  0cd9		       a0 03		      ldy	#LKERNEL_H/8-1
      2  0cdb		       84 98		      sty	loopCntSel
      3  0cdd		       b1 99		      lda	(ptrGfxA),y
      4  0cdf		       85 96		      sta	tmpGfxA
      5  0ce1
      0  0ce1					      SET_ROW_COL	1
      1  0ce1		       a6 81		      ldx	Platform
      2  0ce3		       a5 9d		      lda	selRow
      3  0ce5					      IF	1 != 0
      4  0ce5		       49 01		      eor	#1
      5  0ce7					      ENDIF
      6  0ce7		       f0 04		      beq	.isSel1
      7  0ce9		       a9 0a		      lda	#NOT_SEL_COL
      8  0ceb		       d0 03		      bne	.notSel1
      9  0ced
     10  0ced				   .isSel1
     11  0ced		       bd fc f6 	      lda	SelectionColTbl,x
     12  0cf0				   .notSel1
     13  0cf0		       85 46		      sta	COLUP0
     14  0cf2		       85 47		      sta	COLUP1
      7  0cf4
      8  0cf4		       4c 39 f5 	      jmp	EnterSelLoop1
    835  0cf7
    836  0cf7							;-------------------------------------------------------------------------------
    837  0cf7							; fill align gaps:
    838  0cf7				   SelGfx1
    839  0cf7					      IF	FINAL_VERSION = NO
    840  0cf7				   SelGfxA0_2
    841  0cf7		       e0		      .byte.b	%11100000
    842  0cf8		       fc		      .byte.b	%11111100
    843  0cf9		       e6		      .byte.b	%11100110
    844  0cfa		       fc		      .byte.b	%11111100
    845  0cfb				   SelGfxA0_1
    846  0cfb		       fd		      .byte.b	%11111101
    847  0cfc		       e1		      .byte.b	%11100001
    848  0cfd		       e1		      .byte.b	%11100001
    849  0cfe		       e1		      .byte.b	%11100001
    850  0cff					      ENDIF
      0  0cff					      CHECKPAGE	SelGfx1
      8  0cff					      LIST	ON
    852  0cff
    853  0cff							;-------------------------------------------------------------------------------
    854  0cff							; Level 2/2
      0  0cff					      DRAW_ROW	1	;	     @59
      1  0cff
      2  0cff					      IF	1 != 0
      0  0cff					      ALIGN_FREE	256
      1  0cff				   FREE       SET	FREE - .
      2  0d00		       00		      align	256
      3  0d00				   FREE       SET	FREE + .
 @ $f500 : $9
      4  0d00					      echo	"@", ., ":", FREE
      4  0d00					      ENDIF
      5  0d00
      6  0d00
      7  0d00
      8  0d00
      9  0d00
     10  0d00				   LoopSelGfx1
     11  0d00		       be d2 f5 	      ldx	SelGfxB0_1-1,y
     12  0d03		       8e 5b 00 	      stx.w	GRP0
     13  0d06
      0  0d06					      UPDATE_MUSIC_DATA_HI	1
      1  0d06		       a5 93		      lda	audv1Hi
      2  0d08		       69 00		      adc	#0
      3  0d0a		       85 93		      sta	audv1Hi
     15  0d0c
      0  0d0c					      UPDATE_MUSIC_VOL	1
      0  0d0c					      UPDATE_MUSIC_PREP_VOL	1
      1  0d0c		       29 06		      and	#VOL_MASK/2
      2  0d0e		       0a		      asl
      0  0d0f					      UPDATE_MUSIC_SET_VOL	1
      1  0d0f					      IF	PLAY_CH_1 == YES
      2  0d0f		       85 5a		      sta	AUDV1
      3  0d11				  -	      ELSE
      4  0d11				  -	      nop	AUDV1
      5  0d11					      ENDIF
     17  0d11
      0  0d11					      UPDATE_MUSIC_DATA_LO	1
      0  0d11					      CHECK_CLC
      1  0d11
      2  0d11
      3  0d11		       a5 92		      lda	audv1Lo
      4  0d13		       65 8d		      adc	note1
      5  0d15		       85 92		      sta	audv1Lo
     19  0d17
     20  0d17		       b9 de f5 	      lda	SelGfxB1_1-1,y
     21  0d1a		       85 5c		      sta	GRP1
     22  0d1c		       b9 ea f5 	      lda	SelGfxB2_1-1,y
     23  0d1f		       85 5b		      sta	GRP0
     24  0d21
     25  0d21		       b3 9b		      lax	(ptrGfxB),y
     26  0d23		       b9 f6 f5 	      lda	SelGfxB3_1-1,y
     27  0d26		       a4 97		      ldy	tmpGfxB
     28  0d28
     29  0d28		       85 5c		      sta	GRP1
     30  0d2a		       84 5b		      sty	GRP0
     31  0d2c		       86 5c		      stx	GRP1
     32  0d2e		       85 5b		      sta	GRP0
     33  0d30
     34  0d30		       a4 98		      ldy	loopCntSel
     35  0d32		       88		      dey
     36  0d33		       84 98		      sty	loopCntSel
     37  0d35		       b1 99		      lda	(ptrGfxA),y
     38  0d37		       85 96		      sta	tmpGfxA
     39  0d39				   EnterSelLoop1
     40  0d39		       bf ae f6 	      lax	SelGfxB4_1-1,y
     41  0d3c
     42  0d3c				   V_OFS      SET	(3-1)*4
     43  0d3c		       b9 a7 00 	      lda	audV0LstBtm+V_OFS,y
     44  0d3f		       29 0c		      and	#VOL_MASK
      0  0d41					      UPDATE_MUSIC_SET_VOL	0
      1  0d41					      IF	PLAY_CH_0 == YES
      2  0d41		       85 59		      sta	AUDV0
      3  0d43				  -	      ELSE
      4  0d43				  -	      nop	AUDV0
      5  0d43					      ENDIF
     46  0d43
     47  0d43		       86 97		      stx	tmpGfxB
     48  0d45		       be fb f4 	      ldx	SelGfxA0_1,y
     49  0d48		       86 5b		      stx	GRP0
     50  0d4a		       b9 85 f7 	      lda	SelGfxA1_1,y
     51  0d4d		       85 5c		      sta	GRP1
     52  0d4f		       b9 95 f7 	      lda	SelGfxA2_1,y
     53  0d52		       85 5b		      sta	GRP0
     54  0d54
     55  0d54		       bf c5 f5 	      lax	SelGfxA4_1,y
     56  0d57		       b9 b5 f5 	      lda	SelGfxA3_1,y
     57  0d5a		       a4 96		      ldy	tmpGfxA
     58  0d5c		       85 5c		      sta	GRP1
     59  0d5e		       86 5b		      stx	GRP0
     60  0d60		       84 5c		      sty	GRP1
     61  0d62		       85 5b		      sta	GRP0
     62  0d64
     63  0d64		       a4 98		      ldy	loopCntSel
     64  0d66		       d0 98		      bne	LoopSelGfx1
      0  0d68					      CHECKPAGE	LoopSelGfx1
      8  0d68					      LIST	ON
      0  0d68					      END_ROW		;	     @16
      1  0d68		       84 46		      sty	COLUP0
      2  0d6a		       84 47		      sty	COLUP1
      0  0d6c					      SLEEP	3
      1  0d6c				   .CYCLES    SET	3
      2  0d6c
      3  0d6c				  -	      IF	.CYCLES < 2
      4  0d6c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0d6c				  -	      ERR
      6  0d6c					      ENDIF
      7  0d6c
      8  0d6c					      IF	.CYCLES & 1
      9  0d6c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0d6c		       04 00		      nop	0
     11  0d6e				  -	      ELSE
     12  0d6e				  -	      bit	VSYNC
     13  0d6e					      ENDIF
     14  0d6e				   .CYCLES    SET	.CYCLES - 3
     15  0d6e					      ENDIF
     16  0d6e
     17  0d6e				  -	      REPEAT	.CYCLES / 2
     18  0d6e				  -	      nop
     19  0d6e					      REPEND
      4  0d6e
      5  0d6e
      6  0d6e
      7  0d6e
      0  0d6e					      UPDATE_MUSIC_DATA_HI	1
      1  0d6e		       a5 93		      lda	audv1Hi
      2  0d70		       69 00		      adc	#0
      3  0d72		       85 93		      sta	audv1Hi
      9  0d74
      0  0d74					      UPDATE_MUSIC_VOL	1
      0  0d74					      UPDATE_MUSIC_PREP_VOL	1
      1  0d74		       29 06		      and	#VOL_MASK/2
      2  0d76		       0a		      asl
      0  0d77					      UPDATE_MUSIC_SET_VOL	1
      1  0d77					      IF	PLAY_CH_1 == YES
      2  0d77		       85 5a		      sta	AUDV1
      3  0d79				  -	      ELSE
      4  0d79				  -	      nop	AUDV1
      5  0d79					      ENDIF
     11  0d79
      0  0d79					      UPDATE_MUSIC_DATA_LO	1
      0  0d79					      CHECK_CLC
      1  0d79
      2  0d79
      3  0d79		       a5 92		      lda	audv1Lo
      4  0d7b		       65 8d		      adc	note1
      5  0d7d		       85 92		      sta	audv1Lo
    857  0d7f
    858  0d7f							; Players 1/2:
      0  0d7f					      SET_DIGIT_PTR	2	;17
      1  0d7f		       a4 84		      ldy	selLst+2
      2  0d81		       b9 c5 f7 	      lda	SelDigitAPtr,y
      3  0d84		       85 99		      sta	ptrGfxA
      4  0d86		       b9 ca f7 	      lda	SelDigitBPtr,y
      5  0d89		       85 9b		      sta	ptrGfxB
      0  0d8b					      START_ROW	2
      1  0d8b		       a0 03		      ldy	#LKERNEL_H/8-1
      2  0d8d		       84 98		      sty	loopCntSel
      3  0d8f		       b1 99		      lda	(ptrGfxA),y
      4  0d91		       85 96		      sta	tmpGfxA
      5  0d93
      0  0d93					      SET_ROW_COL	2
      1  0d93		       a6 81		      ldx	Platform
      2  0d95		       a5 9d		      lda	selRow
      3  0d97					      IF	2 != 0
      4  0d97		       49 02		      eor	#2
      5  0d99					      ENDIF
      6  0d99		       f0 04		      beq	.isSel2
      7  0d9b		       a9 0a		      lda	#NOT_SEL_COL
      8  0d9d		       d0 03		      bne	.notSel2
      9  0d9f
     10  0d9f				   .isSel2
     11  0d9f		       bd fc f6 	      lda	SelectionColTbl,x
     12  0da2				   .notSel2
     13  0da2		       85 46		      sta	COLUP0
     14  0da4		       85 47		      sta	COLUP1
      7  0da6
      8  0da6		       4c 39 f6 	      jmp	EnterSelLoop2
    861  0da9
    862  0da9							;-------------------------------------------------------------------------------
    863  0da9							; fill align gaps:
    864  0da9				   SelGfx2
    865  0da9				   SelGfxA0_0
    866  0da9		       7c		      .byte.b	%01111100
    867  0daa		       e6		      .byte.b	%11100110
    868  0dab		       e0		      .byte.b	%11100000
    869  0dac		       7c		      .byte.b	%01111100
    870  0dad
    871  0dad				   SelGfxA3_3
    872  0dad		       f8		      .byte.b	%11111000
    873  0dae		       0c		      .byte.b	%00001100
    874  0daf		       f8		      .byte.b	%11111000
    875  0db0		       fb		      .byte.b	%11111011
    876  0db1				   SelGfxA3_2
    877  0db1		       9b		      .byte.b	%10011011
    878  0db2		       f0		      .byte.b	%11110000
    879  0db3		       99		      .byte.b	%10011001
    880  0db4		       f1		      .byte.b	%11110001
    881  0db5				   SelGfxA3_1
    882  0db5		       fd		      .byte.b	%11111101
    883  0db6		       c1		      .byte.b	%11000001
    884  0db7		       f9		      .byte.b	%11111001
    885  0db8		       fd		      .byte.b	%11111101
    886  0db9				   SelGfxA3_0
    887  0db9		       fe		      .byte.b	%11111110
    888  0dba		       e0		      .byte.b	%11100000
    889  0dbb		       fc		      .byte.b	%11111100
    890  0dbc		       fe		      .byte.b	%11111110
    891  0dbd
    892  0dbd				   SelGfxA4_3
    893  0dbd		       e0		      .byte.b	%11100000
    894  0dbe		       e3		      .byte.b	%11100011
    895  0dbf		       e3		      .byte.b	%11100011
    896  0dc0		       f8		      .byte.b	%11111000
    897  0dc1				   SelGfxA4_2
    898  0dc1		       f0		      .byte.b	%11110000
    899  0dc2		       1b		      .byte.b	%00011011
    900  0dc3		       f3		      .byte.b	%11110011
    901  0dc4		       f0		      .byte.b	%11110000
    902  0dc5				   SelGfxA4_1
    903  0dc5		       f8		      .byte.b	%11111000
    904  0dc6		       c3		      .byte.b	%11000011
    905  0dc7		       c3		      .byte.b	%11000011
    906  0dc8		       c0		      .byte.b	%11000000
    907  0dc9				   SelGfxA4_0
    908  0dc9		       00		      .byte.b	%00000000
    909  0dca		       03		      .byte.b	%00000011
    910  0dcb		       03		      .byte.b	%00000011
    911  0dcc		       00		      .byte.b	%00000000
    912  0dcd
    913  0dcd				   SelGfxB0_3
    914  0dcd		       fd		      .byte.b	%11111101
    915  0dce		       0d		      .byte.b	%00001101
    916  0dcf		       0d		      .byte.b	%00001101
    917  0dd0				   SelGfxB0_2
    918  0dd0		       e0		      .byte.b	%11100000
    919  0dd1		       fe		      .byte.b	%11111110
    920  0dd2		       e6		      .byte.b	%11100110
    921  0dd3				   SelGfxB0_1
    922  0dd3		       fd		      .byte.b	%11111101
    923  0dd4		       e1		      .byte.b	%11100001
    924  0dd5		       e1		      .byte.b	%11100001
    925  0dd6				   SelGfxB0_0
    926  0dd6		       fe		      .byte.b	%11111110
    927  0dd7		       e0		      .byte.b	%11100000
    928  0dd8		       e6		      .byte.b	%11100110
    929  0dd9
    930  0dd9				   SelGfxB1_3
    931  0dd9		       fc		      .byte.b	%11111100
    932  0dda		       8c		      .byte.b	%10001100
    933  0ddb		       8d		      .byte.b	%10001101
    934  0ddc				   SelGfxB1_2
    935  0ddc		       fc		      .byte.b	%11111100
    936  0ddd		       e0		      .byte.b	%11100000
    937  0dde		       e3		      .byte.b	%11100011
    938  0ddf				   SelGfxB1_1
    939  0ddf		       fc		      .byte.b	%11111100
    940  0de0		       c1		      .byte.b	%11000001
    941  0de1		       c1		      .byte.b	%11000001
    942  0de2				   SelGfxB1_0
    943  0de2		       e6		      .byte.b	%11100110
    944  0de3		       e6		      .byte.b	%11100110
    945  0de4		       7c		      .byte.b	%01111100
    946  0de5
    947  0de5				   SelGfxB2_3
    948  0de5		       71		      .byte.b	%01110001
    949  0de6		       70		      .byte.b	%01110000
    950  0de7		       8d		      .byte.b	%10001101
    951  0de8				   SelGfxB2_2
    952  0de8		       e3		      .byte.b	%11100011
    953  0de9		       e3		      .byte.b	%11100011
    954  0dea		       1b		      .byte.b	%00011011
    955  0deb				   SelGfxB2_1
    956  0deb		       f9		      .byte.b	%11111001
    957  0dec		       cd		      .byte.b	%11001101
    958  0ded		       cd		      .byte.b	%11001101
    959  0dee				   SelGfxB2_0
    960  0dee		       7c		      .byte.b	%01111100
    961  0def		       e6		      .byte.b	%11100110
    962  0df0		       e6		      .byte.b	%11100110
    963  0df1
    964  0df1				   SelGfxB3_3
    965  0df1		       fc		      .byte.b	%11111100
    966  0df2		       0c		      .byte.b	%00001100
    967  0df3		       c0		      .byte.b	%11000000
    968  0df4				   SelGfxB3_2
    969  0df4		       9b		      .byte.b	%10011011
    970  0df5		       f0		      .byte.b	%11110000
    971  0df6		       9b		      .byte.b	%10011011
    972  0df7				   SelGfxB3_1
    973  0df7		       fd		      .byte.b	%11111101
    974  0df8		       c1		      .byte.b	%11000001
    975  0df9		       c1		      .byte.b	%11000001
    976  0dfa				   SelGfxB3_0
    977  0dfa		       fe		      .byte.b	%11111110
    978  0dfb		       e0		      .byte.b	%11100000
    979  0dfc		       e0		      .byte.b	%11100000
      0  0dfd					      CHECKPAGE	SelGfx2
      8  0dfd					      LIST	ON
    981  0dfd
    982  0dfd							;-------------------------------------------------------------------------------
    983  0dfd							; Players 2/2:
      0  0dfd					      DRAW_ROW	2	;	     @59
      1  0dfd
      2  0dfd					      IF	2 != 0
      0  0dfd					      ALIGN_FREE	256
      1  0dfd				   FREE       SET	FREE - .
      2  0e00		       00 00 00 	      align	256
      3  0e00				   FREE       SET	FREE + .
 @ $f600 : $c
      4  0e00					      echo	"@", ., ":", FREE
      4  0e00					      ENDIF
      5  0e00
      6  0e00
      7  0e00
      8  0e00
      9  0e00
     10  0e00				   LoopSelGfx2
     11  0e00		       be cf f5 	      ldx	SelGfxB0_2-1,y
     12  0e03		       8e 5b 00 	      stx.w	GRP0
     13  0e06
      0  0e06					      UPDATE_MUSIC_DATA_HI	1
      1  0e06		       a5 93		      lda	audv1Hi
      2  0e08		       69 00		      adc	#0
      3  0e0a		       85 93		      sta	audv1Hi
     15  0e0c
      0  0e0c					      UPDATE_MUSIC_VOL	1
      0  0e0c					      UPDATE_MUSIC_PREP_VOL	1
      1  0e0c		       29 06		      and	#VOL_MASK/2
      2  0e0e		       0a		      asl
      0  0e0f					      UPDATE_MUSIC_SET_VOL	1
      1  0e0f					      IF	PLAY_CH_1 == YES
      2  0e0f		       85 5a		      sta	AUDV1
      3  0e11				  -	      ELSE
      4  0e11				  -	      nop	AUDV1
      5  0e11					      ENDIF
     17  0e11
      0  0e11					      UPDATE_MUSIC_DATA_LO	1
      0  0e11					      CHECK_CLC
      1  0e11
      2  0e11
      3  0e11		       a5 92		      lda	audv1Lo
      4  0e13		       65 8d		      adc	note1
      5  0e15		       85 92		      sta	audv1Lo
     19  0e17
     20  0e17		       b9 db f5 	      lda	SelGfxB1_2-1,y
     21  0e1a		       85 5c		      sta	GRP1
     22  0e1c		       b9 e7 f5 	      lda	SelGfxB2_2-1,y
     23  0e1f		       85 5b		      sta	GRP0
     24  0e21
     25  0e21		       b3 9b		      lax	(ptrGfxB),y
     26  0e23		       b9 f3 f5 	      lda	SelGfxB3_2-1,y
     27  0e26		       a4 97		      ldy	tmpGfxB
     28  0e28
     29  0e28		       85 5c		      sta	GRP1
     30  0e2a		       84 5b		      sty	GRP0
     31  0e2c		       86 5c		      stx	GRP1
     32  0e2e		       85 5b		      sta	GRP0
     33  0e30
     34  0e30		       a4 98		      ldy	loopCntSel
     35  0e32		       88		      dey
     36  0e33		       84 98		      sty	loopCntSel
     37  0e35		       b1 99		      lda	(ptrGfxA),y
     38  0e37		       85 96		      sta	tmpGfxA
     39  0e39				   EnterSelLoop2
     40  0e39		       bf ab f6 	      lax	SelGfxB4_2-1,y
     41  0e3c
     42  0e3c				   V_OFS      SET	(3-2)*4
     43  0e3c		       b9 a3 00 	      lda	audV0LstBtm+V_OFS,y
     44  0e3f		       29 0c		      and	#VOL_MASK
      0  0e41					      UPDATE_MUSIC_SET_VOL	0
      1  0e41					      IF	PLAY_CH_0 == YES
      2  0e41		       85 59		      sta	AUDV0
      3  0e43				  -	      ELSE
      4  0e43				  -	      nop	AUDV0
      5  0e43					      ENDIF
     46  0e43
     47  0e43		       86 97		      stx	tmpGfxB
     48  0e45		       be f7 f4 	      ldx	SelGfxA0_2,y
     49  0e48		       86 5b		      stx	GRP0
     50  0e4a		       b9 81 f7 	      lda	SelGfxA1_2,y
     51  0e4d		       85 5c		      sta	GRP1
     52  0e4f		       b9 91 f7 	      lda	SelGfxA2_2,y
     53  0e52		       85 5b		      sta	GRP0
     54  0e54
     55  0e54		       bf c1 f5 	      lax	SelGfxA4_2,y
     56  0e57		       b9 b1 f5 	      lda	SelGfxA3_2,y
     57  0e5a		       a4 96		      ldy	tmpGfxA
     58  0e5c		       85 5c		      sta	GRP1
     59  0e5e		       86 5b		      stx	GRP0
     60  0e60		       84 5c		      sty	GRP1
     61  0e62		       85 5b		      sta	GRP0
     62  0e64
     63  0e64		       a4 98		      ldy	loopCntSel
     64  0e66		       d0 98		      bne	LoopSelGfx2
      0  0e68					      CHECKPAGE	LoopSelGfx2
      8  0e68					      LIST	ON
      0  0e68					      END_ROW		;	     @16
      1  0e68		       84 46		      sty	COLUP0
      2  0e6a		       84 47		      sty	COLUP1
      0  0e6c					      SLEEP	3
      1  0e6c				   .CYCLES    SET	3
      2  0e6c
      3  0e6c				  -	      IF	.CYCLES < 2
      4  0e6c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0e6c				  -	      ERR
      6  0e6c					      ENDIF
      7  0e6c
      8  0e6c					      IF	.CYCLES & 1
      9  0e6c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0e6c		       04 00		      nop	0
     11  0e6e				  -	      ELSE
     12  0e6e				  -	      bit	VSYNC
     13  0e6e					      ENDIF
     14  0e6e				   .CYCLES    SET	.CYCLES - 3
     15  0e6e					      ENDIF
     16  0e6e
     17  0e6e				  -	      REPEAT	.CYCLES / 2
     18  0e6e				  -	      nop
     19  0e6e					      REPEND
      4  0e6e
      5  0e6e
      6  0e6e
      7  0e6e
      0  0e6e					      UPDATE_MUSIC_DATA_HI	1
      1  0e6e		       a5 93		      lda	audv1Hi
      2  0e70		       69 00		      adc	#0
      3  0e72		       85 93		      sta	audv1Hi
      9  0e74
      0  0e74					      UPDATE_MUSIC_VOL	1
      0  0e74					      UPDATE_MUSIC_PREP_VOL	1
      1  0e74		       29 06		      and	#VOL_MASK/2
      2  0e76		       0a		      asl
      0  0e77					      UPDATE_MUSIC_SET_VOL	1
      1  0e77					      IF	PLAY_CH_1 == YES
      2  0e77		       85 5a		      sta	AUDV1
      3  0e79				  -	      ELSE
      4  0e79				  -	      nop	AUDV1
      5  0e79					      ENDIF
     11  0e79
      0  0e79					      UPDATE_MUSIC_DATA_LO	1
      0  0e79					      CHECK_CLC
      1  0e79
      2  0e79
      3  0e79		       a5 92		      lda	audv1Lo
      4  0e7b		       65 8d		      adc	note1
      5  0e7d		       85 92		      sta	audv1Lo
    986  0e7f
    987  0e7f							; Joysticks 1/2:
      0  0e7f					      SET_DIGIT_PTR	3	;17
      1  0e7f		       a4 85		      ldy	selLst+3
      2  0e81		       b9 c5 f7 	      lda	SelDigitAPtr,y
      3  0e84		       85 99		      sta	ptrGfxA
      4  0e86		       b9 ca f7 	      lda	SelDigitBPtr,y
      5  0e89		       85 9b		      sta	ptrGfxB
      0  0e8b					      START_ROW	3
      1  0e8b		       a0 03		      ldy	#LKERNEL_H/8-1
      2  0e8d		       84 98		      sty	loopCntSel
      3  0e8f		       b1 99		      lda	(ptrGfxA),y
      4  0e91		       85 96		      sta	tmpGfxA
      5  0e93
      0  0e93					      SET_ROW_COL	3
      1  0e93		       a6 81		      ldx	Platform
      2  0e95		       a5 9d		      lda	selRow
      3  0e97					      IF	3 != 0
      4  0e97		       49 03		      eor	#3
      5  0e99					      ENDIF
      6  0e99		       f0 04		      beq	.isSel3
      7  0e9b		       a9 0a		      lda	#NOT_SEL_COL
      8  0e9d		       d0 03		      bne	.notSel3
      9  0e9f
     10  0e9f				   .isSel3
     11  0e9f		       bd fc f6 	      lda	SelectionColTbl,x
     12  0ea2				   .notSel3
     13  0ea2		       85 46		      sta	COLUP0
     14  0ea4		       85 47		      sta	COLUP1
      7  0ea6
      8  0ea6		       4c 39 f7 	      jmp	EnterSelLoop3
    990  0ea9
    991  0ea9							;-------------------------------------------------------------------------------
    992  0ea9							; fill align gaps:
    993  0ea9				   SelGfx3
    994  0ea9				   SelGfxB4_3
    995  0ea9		       e3		      .byte.b	%11100011
    996  0eaa		       e0		      .byte.b	%11100000
    997  0eab		       e3		      .byte.b	%11100011
    998  0eac				   SelGfxB4_2
    999  0eac		       fb		      .byte.b	%11111011
   1000  0ead		       18		      .byte.b	%00011000
   1001  0eae		       83		      .byte.b	%10000011
   1002  0eaf				   SelGfxB4_1
   1003  0eaf		       fb		      .byte.b	%11111011
   1004  0eb0		       c0		      .byte.b	%11000000
   1005  0eb1		       c3		      .byte.b	%11000011
   1006  0eb2				   SelGfxB4_0
   1007  0eb2		       03		      .byte.b	%00000011
   1008  0eb3		       00		      .byte.b	%00000000
   1009  0eb4		       03		      .byte.b	%00000011
   1010  0eb5
   1011  0eb5				   CharGfx
   1012  0eb5				   Gfx5_A
   1013  0eb5		       3e		      .byte.b	%00111110
   1014  0eb6		       73		      .byte.b	%01110011
   1015  0eb7		       7e		      .byte.b	%01111110
   1016  0eb8		       7f		      .byte.b	%01111111
   1017  0eb9				   Gfx5_B
   1018  0eb9		       7f		      .byte.b	%01111111
   1019  0eba		       03		      .byte.b	%00000011
   1020  0ebb		       70		      .byte.b	%01110000
   1021  0ebc
   1022  0ebc				   GfxA_A
   1023  0ebc		       73		      .byte.b	%01110011
   1024  0ebd		       7f		      .byte.b	%01111111
   1025  0ebe		       73		      .byte.b	%01110011
   1026  0ebf		       1c		      .byte.b	%00011100
   1027  0ec0				   Gfx1_A
   1028  0ec0		       3f		      .byte.b	%00111111
   1029  0ec1		       0c		      .byte.b	%00001100
   1030  0ec2		       1c		      .byte.b	%00011100
   1031  0ec3		       0c		      .byte.b	%00001100
   1032  0ec4				   GfxE_A
   1033  0ec4		       7f		      .byte.b	%01111111
   1034  0ec5		       70		      .byte.b	%01110000
   1035  0ec6		       7e		      .byte.b	%01111110
   1036  0ec7		       7f		      .byte.b	%01111111
   1037  0ec8				   Gfx2_A
   1038  0ec8		       7f		      .byte.b	%01111111
   1039  0ec9		       38		      .byte.b	%00111000
   1040  0eca		       0e		      .byte.b	%00001110
   1041  0ecb		       3e		      .byte.b	%00111110
   1042  0ecc				   GfxI_A
   1043  0ecc		       3e		      .byte.b	%00111110
   1044  0ecd		       1c		      .byte.b	%00011100
   1045  0ece		       1c		      .byte.b	%00011100
   1046  0ecf		       3e		      .byte.b	%00111110
   1047  0ed0				   Gfx3_A
   1048  0ed0		       3e		      .byte.b	%00111110
   1049  0ed1		       73		      .byte.b	%01110011
   1050  0ed2		       0c		      .byte.b	%00001100
   1051  0ed3		       3f		      .byte.b	%00111111
   1052  0ed4				   GfxM_A
   1053  0ed4		       63		      .byte.b	%01100011
   1054  0ed5		       63		      .byte.b	%01100011
   1055  0ed6		       7f		      .byte.b	%01111111
   1056  0ed7		       63		      .byte.b	%01100011
   1057  0ed8				   Gfx4_A
   1058  0ed8		       0e		      .byte.b	%00001110
   1059  0ed9		       0e		      .byte.b	%00001110
   1060  0eda		       6e		      .byte.b	%01101110
   1061  0edb		       60		      .byte.b	%01100000
   1062  0edc
   1063  0edc				   GfxA_B
   1064  0edc		       73		      .byte.b	%01110011
   1065  0edd		       73		      .byte.b	%01110011
   1066  0ede		       3e		      .byte.b	%00111110
   1067  0edf					      IF	FINAL_VERSION = NO
   1068  0edf		       00		      .byte.b	0
   1069  0ee0					      ENDIF
   1070  0ee0				   Gfx1_B
   1071  0ee0		       3f		      .byte.b	%00111111
   1072  0ee1		       0c		      .byte.b	%00001100
   1073  0ee2		       1c		      .byte.b	%00011100
   1074  0ee3				   GfxE_B
   1075  0ee3		       7f		      .byte.b	%01111111
   1076  0ee4		       70		      .byte.b	%01110000
   1077  0ee5		       70		      .byte.b	%01110000
   1078  0ee6					      IF	FINAL_VERSION = NO
   1079  0ee6		       00		      .byte.b	0
   1080  0ee7					      ENDIF
   1081  0ee7				   Gfx2_B
   1082  0ee7		       7f		      .byte.b	%01111111
   1083  0ee8		       1c		      .byte.b	%00011100
   1084  0ee9		       63		      .byte.b	%01100011
   1085  0eea				   GfxI_B
   1086  0eea		       3e		      .byte.b	%00111110
   1087  0eeb		       1c		      .byte.b	%00011100
   1088  0eec		       1c		      .byte.b	%00011100
   1089  0eed					      IF	FINAL_VERSION = NO
   1090  0eed		       00		      .byte.b	0
   1091  0eee					      ENDIF
   1092  0eee				   Gfx3_B
   1093  0eee		       7f		      .byte.b	%01111111
   1094  0eef		       06		      .byte.b	%00000110
   1095  0ef0		       06		      .byte.b	%00000110
   1096  0ef1				   GfxM_B
   1097  0ef1		       63		      .byte.b	%01100011
   1098  0ef2		       6b		      .byte.b	%01101011
   1099  0ef3		       77		      .byte.b	%01110111
   1100  0ef4					      IF	FINAL_VERSION = NO
   1101  0ef4		       00		      .byte.b	0
   1102  0ef5					      ENDIF
   1103  0ef5				   Gfx4_B
   1104  0ef5		       0e		      .byte.b	%00001110
   1105  0ef6		       7f		      .byte.b	%01111111
   1106  0ef7		       60		      .byte.b	%01100000
   1107  0ef8
   1108  0ef8				   SelGfxA0_3
   1109  0ef8		       78		      .byte.b	%01111000
   1110  0ef9		       cd		      .byte.b	%11001101
   1111  0efa		       0d		      .byte.b	%00001101
   1112  0efb		       0c		      .byte.b	%00001100
   1113  0efc
   1114  0efc				   SelectionColTbl
   1115  0efc		       1c		      .byte.b	YELLOW_NTSC|$C
   1116  0efd		       2c		      .byte.b	YELLOW_PAL|$C
   1117  0efe							;    CHECKPAGE CharGfx
      0  0efe					      CHECKPAGE	(SelGfx3-1)
      8  0efe					      LIST	ON
   1119  0efe
   1120  0efe							;-------------------------------------------------------------------------------
   1121  0efe							; Joysticks 2/2:
      0  0efe					      DRAW_ROW	3	;	     @59
      1  0efe
      2  0efe					      IF	3 != 0
      0  0efe					      ALIGN_FREE	256
      1  0efe				   FREE       SET	FREE - .
      2  0f00		       00 00		      align	256
      3  0f00				   FREE       SET	FREE + .
 @ $f700 : $e
      4  0f00					      echo	"@", ., ":", FREE
      4  0f00					      ENDIF
      5  0f00
      6  0f00
      7  0f00
      8  0f00
      9  0f00
     10  0f00				   LoopSelGfx3
     11  0f00		       be cc f5 	      ldx	SelGfxB0_3-1,y
     12  0f03		       8e 5b 00 	      stx.w	GRP0
     13  0f06
      0  0f06					      UPDATE_MUSIC_DATA_HI	1
      1  0f06		       a5 93		      lda	audv1Hi
      2  0f08		       69 00		      adc	#0
      3  0f0a		       85 93		      sta	audv1Hi
     15  0f0c
      0  0f0c					      UPDATE_MUSIC_VOL	1
      0  0f0c					      UPDATE_MUSIC_PREP_VOL	1
      1  0f0c		       29 06		      and	#VOL_MASK/2
      2  0f0e		       0a		      asl
      0  0f0f					      UPDATE_MUSIC_SET_VOL	1
      1  0f0f					      IF	PLAY_CH_1 == YES
      2  0f0f		       85 5a		      sta	AUDV1
      3  0f11				  -	      ELSE
      4  0f11				  -	      nop	AUDV1
      5  0f11					      ENDIF
     17  0f11
      0  0f11					      UPDATE_MUSIC_DATA_LO	1
      0  0f11					      CHECK_CLC
      1  0f11
      2  0f11
      3  0f11		       a5 92		      lda	audv1Lo
      4  0f13		       65 8d		      adc	note1
      5  0f15		       85 92		      sta	audv1Lo
     19  0f17
     20  0f17		       b9 d8 f5 	      lda	SelGfxB1_3-1,y
     21  0f1a		       85 5c		      sta	GRP1
     22  0f1c		       b9 e4 f5 	      lda	SelGfxB2_3-1,y
     23  0f1f		       85 5b		      sta	GRP0
     24  0f21
     25  0f21		       b3 9b		      lax	(ptrGfxB),y
     26  0f23		       b9 f0 f5 	      lda	SelGfxB3_3-1,y
     27  0f26		       a4 97		      ldy	tmpGfxB
     28  0f28
     29  0f28		       85 5c		      sta	GRP1
     30  0f2a		       84 5b		      sty	GRP0
     31  0f2c		       86 5c		      stx	GRP1
     32  0f2e		       85 5b		      sta	GRP0
     33  0f30
     34  0f30		       a4 98		      ldy	loopCntSel
     35  0f32		       88		      dey
     36  0f33		       84 98		      sty	loopCntSel
     37  0f35		       b1 99		      lda	(ptrGfxA),y
     38  0f37		       85 96		      sta	tmpGfxA
     39  0f39				   EnterSelLoop3
     40  0f39		       bf a8 f6 	      lax	SelGfxB4_3-1,y
     41  0f3c
     42  0f3c				   V_OFS      SET	(3-3)*4
     43  0f3c		       b9 9f 00 	      lda	audV0LstBtm+V_OFS,y
     44  0f3f		       29 0c		      and	#VOL_MASK
      0  0f41					      UPDATE_MUSIC_SET_VOL	0
      1  0f41					      IF	PLAY_CH_0 == YES
      2  0f41		       85 59		      sta	AUDV0
      3  0f43				  -	      ELSE
      4  0f43				  -	      nop	AUDV0
      5  0f43					      ENDIF
     46  0f43
     47  0f43		       86 97		      stx	tmpGfxB
     48  0f45		       be f8 f6 	      ldx	SelGfxA0_3,y
     49  0f48		       86 5b		      stx	GRP0
     50  0f4a		       b9 7d f7 	      lda	SelGfxA1_3,y
     51  0f4d		       85 5c		      sta	GRP1
     52  0f4f		       b9 8d f7 	      lda	SelGfxA2_3,y
     53  0f52		       85 5b		      sta	GRP0
     54  0f54
     55  0f54		       bf bd f5 	      lax	SelGfxA4_3,y
     56  0f57		       b9 ad f5 	      lda	SelGfxA3_3,y
     57  0f5a		       a4 96		      ldy	tmpGfxA
     58  0f5c		       85 5c		      sta	GRP1
     59  0f5e		       86 5b		      stx	GRP0
     60  0f60		       84 5c		      sty	GRP1
     61  0f62		       85 5b		      sta	GRP0
     62  0f64
     63  0f64		       a4 98		      ldy	loopCntSel
     64  0f66		       d0 98		      bne	LoopSelGfx3
      0  0f68					      CHECKPAGE	LoopSelGfx3
      8  0f68					      LIST	ON
   1123  0f68
   1124  0f68		       84 5b		      sty	GRP0	; 3
   1125  0f6a		       88		      dey		; 2		     -> y = $ff
   1126  0f6b		       84 41		      sty	VBLANK	; 3		     end of screen - enter blanking
      0  0f6d					      SLEEP	4	; 4
      1  0f6d				   .CYCLES    SET	4
      2  0f6d
      3  0f6d				  -	      IF	.CYCLES < 2
      4  0f6d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0f6d				  -	      ERR
      6  0f6d					      ENDIF
      7  0f6d
      8  0f6d				  -	      IF	.CYCLES & 1
      9  0f6d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  0f6d				  -	      nop	0
     11  0f6d				  -	      ELSE
     12  0f6d				  -	      bit	VSYNC
     13  0f6d				  -	      ENDIF
     14  0f6d				  -.CYCLES    SET	.CYCLES - 3
     15  0f6d					      ENDIF
     16  0f6d
     17  0f6d					      REPEAT	.CYCLES / 2
     18  0f6d		       ea		      nop
     17  0f6d					      REPEND
     18  0f6e		       ea		      nop
     19  0f6f					      REPEND
      0  0f6f					      UPDATE_MUSIC_DATA_HI	1	; 8 = 17    @76
      1  0f6f		       a5 93		      lda	audv1Hi
      2  0f71		       69 00		      adc	#0
      3  0f73		       85 93		      sta	audv1Hi
   1129  0f75				   ---------------------------------------
      0  0f75					      UPDATE_MUSIC_VOL	1	; 7	     @07!    <-- AUDV1
      0  0f75					      UPDATE_MUSIC_PREP_VOL	1
      1  0f75		       29 06		      and	#VOL_MASK/2
      2  0f77		       0a		      asl
      0  0f78					      UPDATE_MUSIC_SET_VOL	1
      1  0f78					      IF	PLAY_CH_1 == YES
      2  0f78		       85 5a		      sta	AUDV1
      3  0f7a				  -	      ELSE
      4  0f7a				  -	      nop	AUDV1
      5  0f7a					      ENDIF
   1131  0f7a
   1132  0f7a							; free: 2
   1133  0f7a
   1134  0f7a		       4c 00 f0 	      jmp	SwitchToContTitleBank	;11	     @18
   1135  0f7d
   1136  0f7d							;-------------------------------------------------------------------------------
   1137  0f7d
   1138  0f7d				  -	      IF	FINAL_VERSION = YES
   1139  0f7d				  -SelGfxA0_2
   1140  0f7d				  -	      .byte	%11100000
   1141  0f7d				  -	      .byte	%11111100
   1142  0f7d				  -	      .byte	%11100110
   1143  0f7d				  -	      .byte	%11111100
   1144  0f7d				  -SelGfxA0_1
   1145  0f7d				  -	      .byte	%11111101
   1146  0f7d				  -	      .byte	%11100001
   1147  0f7d				  -	      .byte	%11100001
   1148  0f7d				  -	      .byte	%11100001
   1149  0f7d					      ENDIF
   1150  0f7d
   1151  0f7d				   SelGfxA1_3
   1152  0f7d		       f8		      .byte.b	%11111000
   1153  0f7e		       8c		      .byte.b	%10001100
   1154  0f7f		       8c		      .byte.b	%10001100
   1155  0f80		       f9		      .byte.b	%11111001
   1156  0f81				   SelGfxA1_2
   1157  0f81		       fc		      .byte.b	%11111100
   1158  0f82		       e0		      .byte.b	%11100000
   1159  0f83		       e1		      .byte.b	%11100001
   1160  0f84		       e3		      .byte.b	%11100011
   1161  0f85				   SelGfxA1_1
   1162  0f85		       fc		      .byte.b	%11111100
   1163  0f86		       c1		      .byte.b	%11000001
   1164  0f87		       f9		      .byte.b	%11111001
   1165  0f88		       fd		      .byte.b	%11111101
   1166  0f89				   SelGfxA1_0
   1167  0f89		       e6		      .byte.b	%11100110
   1168  0f8a		       fe		      .byte.b	%11111110
   1169  0f8b		       e6		      .byte.b	%11100110
   1170  0f8c		       38		      .byte.b	%00111000
   1171  0f8d
   1172  0f8d				   SelGfxA2_3
   1173  0f8d		       71		      .byte.b	%01110001
   1174  0f8e		       70		      .byte.b	%01110000
   1175  0f8f		       f8		      .byte.b	%11111000
   1176  0f90		       8c		      .byte.b	%10001100
   1177  0f91				   SelGfxA2_2
   1178  0f91		       e3		      .byte.b	%11100011
   1179  0f92		       e3		      .byte.b	%11100011
   1180  0f93		       f3		      .byte.b	%11110011
   1181  0f94		       1b		      .byte.b	%00011011
   1182  0f95				   SelGfxA2_1
   1183  0f95		       71		      .byte.b	%01110001
   1184  0f96		       cd		      .byte.b	%11001101
   1185  0f97		       cd		      .byte.b	%11001101
   1186  0f98		       cd		      .byte.b	%11001101
   1187  0f99				   SelGfxA2_0
   1188  0f99		       38		      .byte.b	%00111000
   1189  0f9a		       e6		      .byte.b	%11100110
   1190  0f9b		       e6		      .byte.b	%11100110
   1191  0f9c		       e6		      .byte.b	%11100110
   1192  0f9d
   1193  0f9d				  -	      IF	FINAL_VERSION = YES
   1194  0f9d				  -			; only caves A, E, I and M allowed
   1195  0f9d				  -SelCharAPtr
   1196  0f9d				  -	      .byte	<GfxA_A, <GfxE_A, <GfxI_A, <GfxM_A
   1197  0f9d				  -	      CHECKPAGE	SelCharAPtr
   1198  0f9d				  -SelCharBPtr
   1199  0f9d				  -	      .byte	<GfxA_B-1, <GfxE_B-1, <GfxI_B-1, <GfxM_B-1
   1200  0f9d				  -	      CHECKPAGE	(SelCharBPtr-1)
   1201  0f9d					      ELSE
   1202  0f9d					      IF	DEMO_VERSION = NO
   1203  0f9d							; allow selecting all caves and intermissions
   1204  0f9d							; (intermediate caves displayed by "scrolling" effect)
   1205  0f9d				   SelCharAPtr
   1206  0f9d		       bc bd be bf*	      .byte.b	<GfxA_A, <GfxA_A+1 , <GfxA_A+2, <GfxA_A+3, <Gfx1_A
   1207  0fa2		       c4 c5 c6 c7*	      .byte.b	<GfxE_A, <GfxE_A+1 , <GfxE_A+2, <GfxE_A+3, <Gfx2_A
   1208  0fa7		       cc cd ce cf*	      .byte.b	<GfxI_A, <GfxI_A+1 , <GfxI_A+2, <GfxI_A+3, <Gfx3_A
   1209  0fac		       d4 d5 d6 d7*	      .byte.b	<GfxM_A, <GfxM_A+1 , <GfxM_A+2, <GfxM_A+3, <Gfx4_A
      0  0fb1					      CHECKPAGE	SelCharAPtr
      8  0fb1					      LIST	ON
   1211  0fb1				   SelCharBPtr
   1212  0fb1		       db dc dd de*	      .byte.b	<GfxA_B-1, <GfxA_B-1+1 , <GfxA_B-1+2, <GfxA_B-1+3, <Gfx1_B-1
   1213  0fb6		       e2 e3 e4 e5*	      .byte.b	<GfxE_B-1, <GfxE_B-1+1 , <GfxE_B-1+2, <GfxE_B-1+3, <Gfx2_B-1
   1214  0fbb		       e9 ea eb ec*	      .byte.b	<GfxI_B-1, <GfxI_B-1+1 , <GfxI_B-1+2, <GfxI_B-1+3, <Gfx3_B-1
   1215  0fc0		       f0 f1 f2 f3*	      .byte.b	<GfxM_B-1, <GfxM_B-1+1 , <GfxM_B-1+2, <GfxM_B-1+3, <Gfx4_B-1
      0  0fc5					      CHECKPAGE	(SelCharBPtr-1)
      8  0fc5					      LIST	ON
   1217  0fc5				  -	      ELSE
   1218  0fc5				  -			; demo version starts with cave M
   1219  0fc5				  -SelCharAPtr
   1220  0fc5				  -	      .byte	<GfxM_A
   1221  0fc5				  -SelCharBPtr
   1222  0fc5				  -	      .byte	<GfxM_B-1
   1223  0fc5					      ENDIF
   1224  0fc5					      ENDIF
   1225  0fc5
   1226  0fc5				   SelDigitAPtr
   1227  0fc5		       c0 c8 d0 d8*	      .byte.b	<Gfx1_A, <Gfx2_A, <Gfx3_A, <Gfx4_A, <Gfx5_A
      0  0fca					      CHECKPAGE	SelDigitAPtr
      8  0fca					      LIST	ON
   1229  0fca				   SelDigitBPtr
   1230  0fca		       df e6 ed f4*	      .byte.b	<Gfx1_B-1, <Gfx2_B-1, <Gfx3_B-1, <Gfx4_B-1, <Gfx5_B-1
      0  0fcf					      CHECKPAGE	(SelDigitBPtr-1)
      8  0fcf					      LIST	ON
   1232  0fcf
   1233  0fcf				   SelMaxTbl
   1234  0fcf				  -	      IF	FINAL_VERSION
   1235  0fcf				  -	      .byte	4-1	; only A, E, I, M selectable
   1236  0fcf					      ELSE
   1237  0fcf					      IF	DEMO_VERSION = NO
   1238  0fcf		       13		      .byte.b	20-1	; all caves selectable
   1239  0fd0				  -	      ELSE
   1240  0fd0				  -	      .byte	1-1	; no caves selectable
   1241  0fd0					      ENDIF
   1242  0fd0					      IF	DEMO_VERSION = NO
   1243  0fd0		       04 01 01 	      .byte.b	NUM_LEVELS-1, 1, 1
   1244  0fd3				  -	      ELSE
   1245  0fd3				  -	      .byte	NUM_LEVELS-2-1
   1246  0fd3					      ENDIF
   1247  0fd3		       01 01		      .byte.b	1, 1
   1248  0fd5
   1249  0fd5							;--------------------------------------------------------------------------
   1250  0fd5
   1251  0fd5							;------------------------------------------------------------------------------
   1252  0fd5
      0  0fd5					      DEFINE_SUBROUTINE	DetectConsole
      1  0fd5		       00 01	   BANK_DetectConsole =	_CURRENT_BANK
      2  0fd5					      SUBROUTINE
      3  0fd5				   DetectConsole
   1254  0fd5
   1255  0fd5							;	  ldx	  #$80	      ;       disable VDELP1, else detection will fail!
   1256  0fd5							;	  stx	  VDELP1
   1257  0fd5							;	  dex
   1258  0fd5		       a2 7f		      ldx	#$7f	;
   1259  0fd7		       86 61		      stx	HMP1	;	 move P1
   1260  0fd9		       86 5d		      stx	ENAM0	;	 enable M0
   1261  0fdb		       86 5c		      stx	GRP1	;	 enable P1
   1262  0fdd		       85 42		      sta	WSYNC
   1263  0fdf		       85 52		      sta	RESM0
   1264  0fe1		       85 51		      sta	RESP1
   1265  0fe3		       85 6a		      sta	HMOVE	;	 HMOVE during RESPx
   1266  0fe5		       85 42		      sta	WSYNC	;	 start new line
   1267  0fe7		       85 6c		      sta	CXCLR	;	 clear any collisions
   1268  0fe9		       85 42		      sta	WSYNC	;	 wait one line
   1269  0feb		       a9 c0		      lda	#$f0-$30
   1270  0fed		       24 40		      bit	CXM0P	;	 if M0/P1 collision then
   1271  0fef		       30 02		      bmi	.compatible
   1272  0ff1		       a9 10		      lda	#$50-$40	;	 console Kool Aid Man incompatible (Jr.) -- FIXED WOBBLE FOR ALL AD'S MACHINES
   1273  0ff3				   .compatible
   1274  0ff3		       85 89		      sta	hmJunior	;	 different HM values for Jr.
   1275  0ff5							; reset graphics:
   1276  0ff5		       a9 00		      lda	#0
   1277  0ff7		       85 5d		      sta	ENAM0
   1278  0ff9		       85 5c		      sta	GRP1
   1279  0ffb
   1280  0ffb		       a9 02		      lda	#%10	;	 ugly: make sure VBLANK is ON
   1281  0ffd		       60		      rts
   1282  0ffe
   1283  0ffe
   1284  0ffe				   FREE       SET	FREE + BANK_START + ROM_BANK_SIZE - .
   1285  0ffe
 Free bytes in TITLE_BANK: $10
   1286  0ffe					      ECHO	"Free bytes in TITLE_BANK:", FREE
   1287  0ffe
      0  0ffe					      CHECK_BANK_SIZE	"TITLE_BANK"
      1  0ffe		       07 fe	   .TEMP      =	* - BANK_START
 TITLE_BANK (2K) SIZE =  $7fe , FREE= $2
      2  0ffe					      ECHO	"TITLE_BANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0ffe				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0ffe				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0ffe				  -	      ERR
      6  0ffe					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_TITLE_LOGO.asm LEVEL 2 PASS 3
      0  0ffe					      include	"BANK_TITLE_LOGO.asm"
      1  0ffe							;------------------------------------------------------------------------------
      2  0ffe							;##############################################################################
      3  0ffe							;------------------------------------------------------------------------------
      4  0ffe
      0  0ffe					      NEWBANK	TITLE_LOGO_BANK
      1  1414 ????				      SEG	TITLE_LOGO_BANK
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   TITLE_LOGO_BANK SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	TITLE_LOGO_BANK
      6  1000							;
      7  1000							;===============================================================================
      8  1000							; code starts here
      9  1000							;===============================================================================
     10  1000
     11  1000				   FREE       SET	0
     12  1000
     13  1000				   SwitchToNewFrameTitleBank SUBROUTINE
     14  1000		       a9 01		      lda	#BANK_TitleScreen	; 2
     15  1002		       85 3f		      sta	SET_BANK	; 3
     16  1004		       4c 9d f0 	      jmp	ContTitle	; 3 = 8
     17  1007
     18  1007							; unused, but required!
     19  1007		       00 00 00 00	      ds	4, 0
     20  100b							; coming from SwitchToDrawLogoBank
     21  100b
     22  100b							; fall through
     23  100b
     24  100b							;--------------------------------------------------------------------------
     25  100b							; 6-sprite routine; 32 lines of sprites for "First Star Software" logo.
      0  100b					      DEFINE_SUBROUTINE	DrawLogo
      1  100b		       00 02	   BANK_DrawLogo =	_CURRENT_BANK
      2  100b					      SUBROUTINE
      3  100b				   DrawLogo
     27  100b
     28  100b							;--------------------------------------------------------------------------
     29  100b							; Object X,Y positioning
     30  100b							; Timing is absolutely critical here!
     31  100b
     32  100b							;	     @29
     33  100b
     34  100b		       a9 a3		      lda	#$a3	; 2
     35  100d		       85 61		      sta	HMP1	; 3 =	5    @38
     36  100f
     37  100f							;    lda     #%00011		      ; 2
     38  100f		       85 44		      sta	NUSIZ0	; 3
     39  1011		       85 45		      sta	NUSIZ1	; 3
     40  1013		       85 65		      sta	VDELP0	; 3 = 11    @49
     41  1015
     42  1015		       85 50		      sta	RESP0	; 3	     @52
     43  1017		       85 51		      sta	RESP1	; 3 =	6    @55
     44  1019
     45  1019		       85 66		      sta	VDELP1	; 3
     46  101b		       a9 0e		      lda	#TWHITE	; 2
     47  101d		       85 47		      sta	COLUP1	; 3
     48  101f		       a0 0f		      ldy	#LKERNEL_H/2-1	; 2
     49  1021		       84 98		      sty	loopCntFSS	; 3 = 13    @68
     50  1023
     51  1023		       b9 9f 00 	      lda	audV0LstBtm,y	; 4
     52  1026		       29 0c		      and	#VOL_MASK	; 2
     53  1028							;---------------------------------------
     54  1028		       85 6a		      sta	HMOVE	; 3
     55  102a		       4c 5c f0 	      jmp	.enterFSSLoop	; 3 = 12    @04
     56  102d
     57  102d							;    ALIGN_FREE 256
     58  102d
     59  102d							;--------------------------------------------------------------------------
     60  102d							; Code is exquisitely timed so that each line takes
     61  102d							; *EXACTLY* 76 cycles.  Code cannot cross page-boundaries, as the branch
     62  102d							; would then take an extra cycle, and bugger the display.
     63  102d
     64  102d				   LoopFSS		;	     @13
     65  102d		       88		      dey		; 2
     66  102e		       84 98		      sty	loopCntFSS	; 3 =	5    @18
     67  1030
     68  1030		       b9 43 f2 	      lda	FSSlogoB0,y	; 4
     69  1033		       85 5b		      sta	GRP0	; 3
     70  1035		       b9 43 f2 	      lda	FSSlogoB1,y	; 4
     71  1038		       85 5c		      sta	GRP1	; 3
     72  103a		       b9 43 f2 	      lda	FSSlogoB2,y	; 4
     73  103d		       85 5b		      sta	GRP0	; 3 = 21    @39
     74  103f
     75  103f		       b9 43 f2 	      lda	FSSlogoB5,y	; 4
     76  1042		       85 96		      sta	tmpGfx	; 3
     77  1044		       bf 43 f2 	      lax	FSSlogoB4,y	; 4
     78  1047		       b9 43 f2 	      lda	FSSlogoB3,y	; 4 = 15
     79  104a		       a4 96		      ldy	tmpGfx	; 3
     80  104c		       85 5c		      sta	GRP1	; 3
     81  104e		       86 5b		      stx	GRP0	; 3
     82  1050		       84 5c		      sty	GRP1	; 3
     83  1052		       85 5b		      sta	GRP0	; 3 = 15    @69
     84  1054
     85  1054		       a4 98		      ldy	loopCntFSS	; 3
      0  1056					      SLEEP	2	; 2 =	5    @74
      1  1056				   .CYCLES    SET	2
      2  1056
      3  1056				  -	      IF	.CYCLES < 2
      4  1056				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1056				  -	      ERR
      6  1056					      ENDIF
      7  1056
      8  1056				  -	      IF	.CYCLES & 1
      9  1056				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1056				  -	      nop	0
     11  1056				  -	      ELSE
     12  1056				  -	      bit	VSYNC
     13  1056				  -	      ENDIF
     14  1056				  -.CYCLES    SET	.CYCLES - 3
     15  1056					      ENDIF
     16  1056
     17  1056					      REPEAT	.CYCLES / 2
     18  1056		       ea		      nop
     19  1057					      REPEND
     87  1057							;---------------------------------------
     88  1057		       b9 9f 00 	      lda	audV0LstBtm,y	; 4
     89  105a		       29 0c		      and	#VOL_MASK	; 2
     90  105c				   .enterFSSLoop		;	     @04
      0  105c					      UPDATE_MUSIC_SET_VOL	0	; 3	     @07!    <-- AUDV0
      1  105c					      IF	PLAY_CH_0 == YES
      2  105c		       85 59		      sta	AUDV0
      3  105e				  -	      ELSE
      4  105e				  -	      nop	AUDV0
      5  105e					      ENDIF
      0  105e					      UPDATE_MUSIC_DATA_LO	1	; 9 = 18    @16
      0  105e					      CHECK_CLC
      1  105e
      2  105e
      3  105e		       a5 92		      lda	audv1Lo
      4  1060		       65 8d		      adc	note1
      5  1062		       85 92		      sta	audv1Lo
     93  1064
     94  1064		       b9 43 f2 	      lda	FSSlogoA0,y	; 4
     95  1067		       8d 5b 00 	      sta.w	GRP0	; 4
     96  106a		       b9 43 f2 	      lda	FSSlogoA1,y	; 4
     97  106d		       85 5c		      sta	GRP1	; 3
     98  106f		       b9 43 f2 	      lda	FSSlogoA2,y	; 4
     99  1072		       85 5b		      sta	GRP0	; 3 = 22    @38
    100  1074
    101  1074		       b9 43 f2 	      lda	FSSlogoA5,y	; 4
    102  1077		       85 96		      sta	tmpGfx	; 3
    103  1079		       bf 43 f2 	      lax	FSSlogoA4,y	; 4
    104  107c		       b9 43 f2 	      lda	FSSlogoA3,y	; 4 = 15
    105  107f		       a4 96		      ldy	tmpGfx	; 3
    106  1081		       85 5c		      sta	GRP1	; 3
    107  1083		       86 5b		      stx	GRP0	; 3
    108  1085		       84 5c		      sty	GRP1	; 3
    109  1087		       85 5b		      sta	GRP0	; 3 = 15    @68
    110  1089
      0  1089					      UPDATE_MUSIC_DATA_HI	1	; 8	     @76
      1  1089		       a5 93		      lda	audv1Hi
      2  108b		       69 00		      adc	#0
      3  108d		       85 93		      sta	audv1Hi
    112  108f							;---------------------------------------
      0  108f					      UPDATE_MUSIC_VOL	1	; 7	     @07!    <-- AUDV1
      0  108f					      UPDATE_MUSIC_PREP_VOL	1
      1  108f		       29 06		      and	#VOL_MASK/2
      2  1091		       0a		      asl
      0  1092					      UPDATE_MUSIC_SET_VOL	1
      1  1092					      IF	PLAY_CH_1 == YES
      2  1092		       85 5a		      sta	AUDV1
      3  1094				  -	      ELSE
      4  1094				  -	      nop	AUDV1
      5  1094					      ENDIF
    114  1094
    115  1094		       a4 98		      ldy	loopCntFSS	; 3
    116  1096		       d0 95		      bne	LoopFSS	; 2/3= 5/6
      0  1098					      CHECKPAGE	LoopFSS
      8  1098					      LIST	ON
    118  1098		       84 5b		      sty	GRP0	; 3
    119  109a		       88		      dey
    120  109b		       84 41		      sty	VBLANK	; 3	     @20     Y = $ff, end of screen - enter blanking
    121  109d							; note: GRP1 is cleared later!
    122  109d
    123  109d							; here we return from the other bank:
      0  109d					      DEFINE_SUBROUTINE	ContTitle	;	     @17/18
      1  109d		       00 02	   BANK_ContTitle =	_CURRENT_BANK
      2  109d					      SUBROUTINE
      3  109d				   ContTitle
    125  109d							; copy last precalculated channel 0 value for on-the-fly calculations:
    126  109d		       a5 9e		      lda	audvTmpLo	; 3
    127  109f		       85 90		      sta	audv0Lo	; 3
    128  10a1		       a5 9f		      lda	audV0LstBtm	; 3		     should be always even...
    129  10a3		       4a		      lsr		; 2		     ...so no carry set here
    130  10a4		       85 91		      sta	audv0Hi	; 3 = 14    @32
    131  10a6
    132  10a6							; new BD music
    133  10a6		       a9 01		      lda	#NOTE_OFF_LEN-1	; 2		     run music for 7 frames, then turn off
    134  10a8		       c5 8a		      cmp	noteLen	; 3
    135  10aa		       30 78		      bmi	.skipChangeNote	; 2/3= 7/8	     C == 0 if taken!
    136  10ac		       a5 8a		      lda	noteLen	; 3		     update frame counter
    137  10ae		       30 2d		      bmi	.nextNote	; 2/3
    138  10b0
    139  10b0				   StopNote		;	     @46     debug label
    140  10b0							; calculate offset of precalculated values:
    141  10b0		       a0 27		      ldy	#(SCANLINES_NTSC-196)/2-1	;2
    142  10b2		       a5 81		      lda	Platform	; 3
    143  10b4		       f0 02		      beq	.stopNoteNTSC	; 2/3
    144  10b6		       a0 39		      ldy	#(SCANLINES_PAL-196)/2-1	; 2
    145  10b8				   .stopNoteNTSC
    146  10b8		       a6 8b		      ldx	noteIdx	; 3
    147  10ba		       bd 00 f3 	      lda	MusicData,x	; 4
    148  10bd							;a*y -> a:y, CF = 0
    149  10bd		       00 94	   .acc       =	audvOfsLo
    150  10bd		       00 95	   .aux       =	audvOfsHi
    151  10bd							;    dey			      ; 2
    152  10bd		       84 95		      sty	.aux	; 3
    153  10bf		       85 94		      sta	.acc	; 3
    154  10c1		       85 42		      sta	WSYNC
    155  10c3							;---------------------------------------
    156  10c3		       a9 00		      lda	#0	; 2
    157  10c5		       46 94		      lsr	.acc	; 5
    158  10c7		       a0 08		      ldy	#8	; 2
    159  10c9		       90 02		      bcc	.noAdd	; 2/3=17.5
    160  10cb				   .add
    161  10cb		       65 95		      adc	.aux	; 3
    162  10cd				   .noAdd
    163  10cd		       6a		      ror		; 2
    164  10ce		       66 94		      ror	.acc	; 5
    165  10d0		       88		      dey		; 2
    166  10d1		       b0 f8		      bcs	.add	; 2/3
    167  10d3		       d0 f8		      bne	.noAdd	; 2/3=14.5
    168  10d5							; max total: 17+120-1 = 136
    169  10d5							;    sta     WSYNC		      ; 	      no music, so no need to update waveforms here
    170  10d5							;    and     #$0f		      ; 	      mask upper 4 bits to avoid overflow
    171  10d5		       85 95		      sta	audvOfsHi	;		 audvOfsLo is in .acc
    172  10d7		       84 8c		      sty	note0	;		 Y == 0, turns off music
    173  10d9		       84 8d		      sty	note1
    174  10db		       90 50		      bcc	.exitUpdateNote	;		 or .exitStopNote, but then audV0LstBtm cannot be assumed always even
    175  10dd
    176  10dd							;-------------------------------------------------------------------------------
    177  10dd				   .nextNote		;
    178  10dd		       85 42		      sta	WSYNC	;		 no music, so no need to update waveforms here
    179  10df
    180  10df		       a5 8e		      lda	inputBuffer
    181  10e1		       2d 80 02 	      and	SWCHA
    182  10e4		       a4 8b		      ldy	noteIdx
    183  10e6		       d0 1b		      bne	.contTitle
    184  10e8				   _CountDown		;		 label defined for debugging only
    185  10e8		       a6 8f		      ldx	demoDelay	;		 get collected input over the last 256 notes (initially 0!)
    186  10ea		       c9 f0		      cmp	#$f0	;		 any input?
    187  10ec		       f0 04		      beq	.noInput
    188  10ee		       a2 02		      ldx	#DEMO_DELAY+1	;		 yes, reset delay
    189  10f0		       a9 f0		      lda	#$f0
    190  10f2				   .noInput
    191  10f2		       18		      clc
    192  10f3		       ca		      dex
    193  10f4					      IF	DEMO_VERSION = NO
    194  10f4		       86 8f		      stx	demoDelay	;		 no input for DEMO_DELAY frames?
    195  10f6				  -	      ELSE
    196  10f6				  -	      ldx	#1
    197  10f6					      ENDIF
    198  10f6		       d0 0b		      bne	.contTitle
    199  10f8		       86 82		      stx	sCave	;		 yes, switch to demo mode
    200  10fa		       86 83		      stx	sLevel
    201  10fc		       a9 80		      lda	#$80
    202  10fe		       85 85		      sta	sJoysticks	;		 -> jtoggle = demoMode
    203  1100		       4c c1 f1 	      jmp	ExitTitle
    204  1103
    205  1103				   .contTitle
    206  1103		       85 8e		      sta	inputBuffer
    207  1105
    208  1105							;	  lda	  #0
    209  1105							;	  sta	  audv0Lo
    210  1105							;	  sta	  audv0Hi
    211  1105							;	  sta	  audv1Lo
    212  1105							;	  sta	  audv1Hi
    213  1105		       85 42		      sta	WSYNC
    214  1107							;---------------------------------------
    215  1107		       a2 08		      ldx	#NOTE_LEN_NTSC-1
    216  1109					      IF	NOTE_LEN_NTSC > NOTE_LEN_PAL
    217  1109		       a5 81		      lda	Platform
    218  110b		       f0 01		      beq	.ntscLen
    219  110d		       ca		      dex		;		     == NOTE_LEN_PAL-1
    220  110e				   .ntscLen
    221  110e					      ENDIF
    222  110e		       86 8a		      stx	noteLen	;		     reset frame counter
    223  1110
    224  1110		       a4 8b		      ldy	noteIdx
    225  1112		       b9 00 f3 	      lda	MusicData,y	;		     grab and store next channel 0 note
    226  1115		       85 8c		      sta	note0
    227  1117		       c8		      iny		;		     next channel
    228  1118		       b9 00 f3 	      lda	MusicData,y	;		     grab and store next channel 1 note
    229  111b		       85 8d		      sta	note1
    230  111d		       c8		      iny
    231  111e		       84 8b		      sty	noteIdx	;		     get ready for next note
    232  1120		       85 42		      sta	WSYNC	;		     still no music yet, don't update waveforms
    233  1122							;---------------------------------------
    234  1122		       90 09		      bcc	.exitUpdateNote
    235  1124
    236  1124							;-------------------------------------------------------------------------------
    237  1124				   TEST2
    238  1124				   .skipChangeNote		;	     @40/41  still playing current notes
    239  1124		       20 1b f2 	      jsr	UpdateMusicWSync0L	;39
    240  1127		       20 2f f2 	      jsr	UpdateMusicWSync1L	;39
    241  112a		       20 1b f2 	      jsr	UpdateMusicWSync0L	;39
    242  112d
    243  112d				   .exitUpdateNote
      0  112d					      CHECK_CLC
      1  112d
    245  112d		       a5 90		      lda	audv0Lo	; 3
    246  112f		       65 94		      adc	audvOfsLo	; 3
    247  1131		       85 9e		      sta	audvTmpLo	; 3
    248  1133		       a5 91		      lda	audv0Hi	; 3
    249  1135							;    and     #$0f		      ; 2	      mask upper 4 bits to avoid overflow here and later
    250  1135		       65 95		      adc	audvOfsHi	; 3		  ...now this can't overflow!
    251  1137		       0a		      asl		; 2
    252  1138		       18		      clc
    253  1139
    254  1139				   .exitStopNote
    255  1139					      IF	L276
    256  1139		       a0 06		      ldy	#(36-PC_BTM/2)/2	; 2
    257  113b				  -	      ELSE
    258  113b				  -	      ldy	#(28-PC_BTM/2)/2	; 2
    259  113b					      ENDIF
    260  113b		       a6 81		      ldx	Platform	; 3
    261  113d		       f0 02		      beq	.overScanNTSC	; 2/3
    262  113f		       a0 09		      ldy	#(42-PC_BTM/2)/2	; 2 =	9
    263  1141				   .overScanNTSC
    264  1141		       84 96		      sty	tmpY
    265  1143
    266  1143							; here we precalculate the first 48 values:
    267  1143		       a8		      tay		; 2
    268  1144		       a2 2f		      ldx	#PC_BTM-1	; 2
    269  1146				   .loopOverScan
    270  1146							;---------------------------------------
      0  1146					      UPDATE_MUSIC_WSYNC	1	;27	     @07     maintain sound while precalcuating
      0  1146					      UPDATE_MUSIC_DATA	1
      0  1146					      UPDATE_MUSIC_DATA_LO	1
      0  1146					      CHECK_CLC
      1  1146
      2  1146
      3  1146		       a5 92		      lda	audv1Lo
      4  1148		       65 8d		      adc	note1
      5  114a		       85 92		      sta	audv1Lo
      0  114c					      UPDATE_MUSIC_DATA_HI	1
      1  114c		       a5 93		      lda	audv1Hi
      2  114e		       69 00		      adc	#0
      3  1150		       85 93		      sta	audv1Hi
      2  1152		       85 42		      sta	WSYNC
      3  1154
      0  1154					      UPDATE_MUSIC_VOL	1
      0  1154					      UPDATE_MUSIC_PREP_VOL	1
      1  1154		       29 06		      and	#VOL_MASK/2
      2  1156		       0a		      asl
      0  1157					      UPDATE_MUSIC_SET_VOL	1
      1  1157					      IF	PLAY_CH_1 == YES
      2  1157		       85 5a		      sta	AUDV1
      3  1159				  -	      ELSE
      4  1159				  -	      nop	AUDV1
      5  1159					      ENDIF
    272  1159							; 1st calculation:
      0  1159					      CHECK_CLC
      1  1159
    274  1159		       a5 9e		      lda	audvTmpLo	; 3
    275  115b		       65 8c		      adc	note0	; 3 =	6
    276  115d		       90 03		      bcc	.skipHi1	; 2/3
    277  115f		       c8		      iny		; 2
    278  1160		       c8		      iny		; 2
    279  1161		       18		      clc		; 2
    280  1162				   .skipHi1
    281  1162		       94 cf		      sty	audV0Lst+PC_TOP,x	; 4
    282  1164		       ca		      dex		; 2 = 14
    283  1165							; 2nd calculation:
      0  1165					      CHECK_CLC
      1  1165
    285  1165		       65 8c		      adc	note0	; 3
    286  1167		       85 9e		      sta	audvTmpLo	; 3 =	6
    287  1169		       90 03		      bcc	.skipHi2	; 2/3
    288  116b		       c8		      iny		; 2
    289  116c		       c8		      iny		; 2
    290  116d		       18		      clc		; 2
    291  116e				   .skipHi2
    292  116e		       94 cf		      sty	audV0Lst+PC_TOP,x	; 4
    293  1170		       ca		      dex		; 2 = 14
    294  1171							; total: 63					 @47 max
    295  1171							;---------------------------------------
      0  1171					      UPDATE_MUSIC_WSYNC	0	;27	     @07     maintain sound while precalcuating
      0  1171					      UPDATE_MUSIC_DATA	0
      0  1171					      UPDATE_MUSIC_DATA_LO	0
      0  1171					      CHECK_CLC
      1  1171
      2  1171
      3  1171		       a5 90		      lda	audv0Lo
      4  1173		       65 8c		      adc	note0
      5  1175		       85 90		      sta	audv0Lo
      0  1177					      UPDATE_MUSIC_DATA_HI	0
      1  1177		       a5 91		      lda	audv0Hi
      2  1179		       69 00		      adc	#0
      3  117b		       85 91		      sta	audv0Hi
      2  117d		       85 42		      sta	WSYNC
      3  117f
      0  117f					      UPDATE_MUSIC_VOL	0
      0  117f					      UPDATE_MUSIC_PREP_VOL	0
      1  117f		       29 06		      and	#VOL_MASK/2
      2  1181		       0a		      asl
      0  1182					      UPDATE_MUSIC_SET_VOL	0
      1  1182					      IF	PLAY_CH_0 == YES
      2  1182		       85 59		      sta	AUDV0
      3  1184				  -	      ELSE
      4  1184				  -	      nop	AUDV0
      5  1184					      ENDIF
    297  1184							; 3rd calculation:
      0  1184					      CHECK_CLC
      1  1184
    299  1184		       a5 9e		      lda	audvTmpLo	; 3
    300  1186		       65 8c		      adc	note0	; 3 =	6
    301  1188		       90 03		      bcc	.skipHi3	; 2/3
    302  118a		       c8		      iny		; 2
    303  118b		       c8		      iny		; 2
    304  118c		       18		      clc		; 2
    305  118d				   .skipHi3
    306  118d		       94 cf		      sty	audV0Lst+PC_TOP,x	; 4
    307  118f		       ca		      dex		; 2 = 14
    308  1190							; 4th calculation:
      0  1190					      CHECK_CLC
      1  1190
    310  1190		       65 8c		      adc	note0	; 3
    311  1192		       85 9e		      sta	audvTmpLo	; 3 =	6
    312  1194		       90 03		      bcc	.skipHi4	; 2/3
    313  1196		       c8		      iny		; 2
    314  1197		       c8		      iny		; 2
    315  1198		       18		      clc		; 2
    316  1199				   .skipHi4
    317  1199		       94 cf		      sty	audV0Lst+PC_TOP,x	; 4
    318  119b		       ca		      dex		; 2 = 14
    319  119c		       10 a8		      bpl	.loopOverScan	; 2/3
    320  119e
    321  119e		       a4 96		      ldy	tmpY	; 3
    322  11a0				   .waitOverScan
    323  11a0							;---------------------------------------
    324  11a0							;    jsr     UpdateMusicWSync1L      ;39
      0  11a0					      UPDATE_MUSIC_WSYNC	1	;27	     @07     maintain sound while precalcuating
      0  11a0					      UPDATE_MUSIC_DATA	1
      0  11a0					      UPDATE_MUSIC_DATA_LO	1
      0  11a0					      CHECK_CLC
      1  11a0
      2  11a0
      3  11a0		       a5 92		      lda	audv1Lo
      4  11a2		       65 8d		      adc	note1
      5  11a4		       85 92		      sta	audv1Lo
      0  11a6					      UPDATE_MUSIC_DATA_HI	1
      1  11a6		       a5 93		      lda	audv1Hi
      2  11a8		       69 00		      adc	#0
      3  11aa		       85 93		      sta	audv1Hi
      2  11ac		       85 42		      sta	WSYNC
      3  11ae
      0  11ae					      UPDATE_MUSIC_VOL	1
      0  11ae					      UPDATE_MUSIC_PREP_VOL	1
      1  11ae		       29 06		      and	#VOL_MASK/2
      2  11b0		       0a		      asl
      0  11b1					      UPDATE_MUSIC_SET_VOL	1
      1  11b1					      IF	PLAY_CH_1 == YES
      2  11b1		       85 5a		      sta	AUDV1
      3  11b3				  -	      ELSE
      4  11b3				  -	      nop	AUDV1
      5  11b3					      ENDIF
    326  11b3
    327  11b3		       a5 88		      lda	btnReleased	; 3
    328  11b5		       f0 16		      beq	.notReleased	; 2/3
    329  11b7		       24 4c		      bit	INPT4	; 4	     button pressed?
    330  11b9		       30 18		      bmi	.exitButton	; 2/3
    331  11bb
    332  11bb							; switch to next mode:
    333  11bb		       c6 88		      dec	btnReleased	; 5
    334  11bd		       c6 86		      dec	titleMode	; 5
    335  11bf		       10 12		      bpl	.exitButton	; 2/3
    336  11c1							;--------------------------------------------------------------------------
    337  11c1							; title screen done
    338  11c1							; clear the RAM (between Platform and last zeropage variables) to avoid wrongly initialized variables
    339  11c1				   ExitTitle		;	     debug label  only
    340  11c1		       a9 00		      lda	#0
    341  11c3		       a2 4b		      ldx	#DSL-endTitleClear-1
    342  11c5				   .loopClear
    343  11c5		       95 87		      sta	endTitleClear+1,x
    344  11c7		       ca		      dex
    345  11c8		       10 fb		      bpl	.loopClear
    346  11ca		       4c 26 fb 	      jmp	ExitTitleScreen
    347  11cd
    348  11cd				   .notReleased
    349  11cd		       24 4c		      bit	INPT4	; 4	     button released?
    350  11cf		       10 02		      bpl	.exitButton	; 2/3
    351  11d1		       e6 88		      inc	btnReleased	; 5
    352  11d3				   .exitButton		;   = 24    @31 max
    353  11d3
    354  11d3							; free: 20
    355  11d3							; prepare evaluating joystick up and down:
    356  11d3		       a6 9d		      ldx	selRow	; 3
    357  11d5		       ad 80 02 	      lda	SWCHA	; 4
    358  11d8		       49 ff		      eor	#$ff	; 2
    359  11da		       0a		      asl		; 2
    360  11db		       0a		      asl		; 2
    361  11dc		       48		      pha		; 3
    362  11dd		       18		      clc		; 2 = 18
    363  11de							;---------------------------------------
    364  11de							;    jsr     UpdateMusicWSync0L      ;39	  @13
      0  11de					      UPDATE_MUSIC_WSYNC	0	;27	     @07
      0  11de					      UPDATE_MUSIC_DATA	0
      0  11de					      UPDATE_MUSIC_DATA_LO	0
      0  11de					      CHECK_CLC
      1  11de
      2  11de
      3  11de		       a5 90		      lda	audv0Lo
      4  11e0		       65 8c		      adc	note0
      5  11e2		       85 90		      sta	audv0Lo
      0  11e4					      UPDATE_MUSIC_DATA_HI	0
      1  11e4		       a5 91		      lda	audv0Hi
      2  11e6		       69 00		      adc	#0
      3  11e8		       85 91		      sta	audv0Hi
      2  11ea		       85 42		      sta	WSYNC
      3  11ec
      0  11ec					      UPDATE_MUSIC_VOL	0
      0  11ec					      UPDATE_MUSIC_PREP_VOL	0
      1  11ec		       29 06		      and	#VOL_MASK/2
      2  11ee		       0a		      asl
      0  11ef					      UPDATE_MUSIC_SET_VOL	0
      1  11ef					      IF	PLAY_CH_0 == YES
      2  11ef		       85 59		      sta	AUDV0
      3  11f1				  -	      ELSE
      4  11f1				  -	      nop	AUDV0
      5  11f1					      ENDIF
    366  11f1
    367  11f1		       68		      pla		; 4
    368  11f2
    369  11f2		       88		      dey		; 2
    370  11f3		       d0 ab		      bne	.waitOverScan	; 2/3= 8/9
    371  11f5
    372  11f5		       84 5c		      sty	GRP1	; 3 =	3    @18
    373  11f7
    374  11f7		       0a		      asl		; 2
    375  11f8		       90 13		      bcc	.notDown	; 2/3
    376  11fa		       e8		      inx		; 2
    377  11fb		       a5 84		      lda	sPlayers	; 3
    378  11fd		       f0 07		      beq	.onePlayer	; 2/3
    379  11ff		       e0 04		      cpx	#NUM_SEL	; 2
    380  1201		       90 0f		      bcc	.setJoyY	; 2/3
    381  1203		       18		      clc		; 2
    382  1204		       90 12		      bcc	.skipJoyY	; 3
    383  1206
    384  1206				   .onePlayer		;12
    385  1206		       e0 03		      cpx	#NUM_SEL-1	; 2
    386  1208		       90 08		      bcc	.setJoyY	; 2/3
    387  120a		       18		      clc		; 2
    388  120b		       90 0b		      bcc	.skipJoyY	; 3 = 21
    389  120d
    390  120d				   .notDown		; 5
    391  120d		       10 09		      bpl	.skipJoyY	; 2/3
    392  120f		       ca		      dex		; 2
    393  1210					      IF	DEMO_VERSION = NO
    394  1210		       30 06		      bmi	.skipJoyY	; 2/3
    395  1212				  -	      ELSE
    396  1212				  -	      beq	.skipJoyY	; 2/3
    397  1212					      ENDIF
    398  1212				   .setJoyY
    399  1212		       a5 8a		      lda	noteLen	; 3
    400  1214		       d0 02		      bne	.skipJoyY	; 2/3
    401  1216		       86 9d		      stx	selRow	; 3 =	8
    402  1218				   .skipJoyY		;
    403  1218							; free: 5
    404  1218							;    jmp     NewFrameTitle	      ; 3 = 29 max
    405  1218		       4c 00 f0 	      jmp	SwitchToNewFrameTitleBank	;11 = 37 max
    406  121b
    407  121b							;-----------------------------------------------------------
    408  121b
    409  121b				   UpdateMusicWSync0L
    410  121b							; maintain first channel
      0  121b					      UPDATE_MUSIC_WSYNC	0	;27
      0  121b					      UPDATE_MUSIC_DATA	0
      0  121b					      UPDATE_MUSIC_DATA_LO	0
      0  121b					      CHECK_CLC
      1  121b
      2  121b
      3  121b		       a5 90		      lda	audv0Lo
      4  121d		       65 8c		      adc	note0
      5  121f		       85 90		      sta	audv0Lo
      0  1221					      UPDATE_MUSIC_DATA_HI	0
      1  1221		       a5 91		      lda	audv0Hi
      2  1223		       69 00		      adc	#0
      3  1225		       85 91		      sta	audv0Hi
      2  1227		       85 42		      sta	WSYNC
      3  1229
      0  1229					      UPDATE_MUSIC_VOL	0
      0  1229					      UPDATE_MUSIC_PREP_VOL	0
      1  1229		       29 06		      and	#VOL_MASK/2
      2  122b		       0a		      asl
      0  122c					      UPDATE_MUSIC_SET_VOL	0
      1  122c					      IF	PLAY_CH_0 == YES
      2  122c		       85 59		      sta	AUDV0
      3  122e				  -	      ELSE
      4  122e				  -	      nop	AUDV0
      5  122e					      ENDIF
    412  122e		       60		      rts		; 6 = 33
    413  122f
    414  122f				   UpdateMusicWSync1L
    415  122f							; maintain second channel
      0  122f					      UPDATE_MUSIC_WSYNC	1	;27
      0  122f					      UPDATE_MUSIC_DATA	1
      0  122f					      UPDATE_MUSIC_DATA_LO	1
      0  122f					      CHECK_CLC
      1  122f
      2  122f
      3  122f		       a5 92		      lda	audv1Lo
      4  1231		       65 8d		      adc	note1
      5  1233		       85 92		      sta	audv1Lo
      0  1235					      UPDATE_MUSIC_DATA_HI	1
      1  1235		       a5 93		      lda	audv1Hi
      2  1237		       69 00		      adc	#0
      3  1239		       85 93		      sta	audv1Hi
      2  123b		       85 42		      sta	WSYNC
      3  123d
      0  123d					      UPDATE_MUSIC_VOL	1
      0  123d					      UPDATE_MUSIC_PREP_VOL	1
      1  123d		       29 06		      and	#VOL_MASK/2
      2  123f		       0a		      asl
      0  1240					      UPDATE_MUSIC_SET_VOL	1
      1  1240					      IF	PLAY_CH_1 == YES
      2  1240		       85 5a		      sta	AUDV1
      3  1242				  -	      ELSE
      4  1242				  -	      nop	AUDV1
      5  1242					      ENDIF
    417  1242		       60		      rts		; 6 = 33
    418  1243
    419  1243							;-----------------------------------------------------------
      0  1243					      OPTIONAL_PAGEBREAK	"FSSlogo", (31*6)
     10  1243					      LIST	ON
    421  1243							;    ALIGN_FREE 256
    422  1243
    423  1243				   FSSlogo
    424  1243				   FSSlogoA0
    425  1243				   FSSlogoA1
    426  1243				   FSSlogoA2
    427  1243				   FSSlogoA3
    428  1243				   FSSlogoA4
    429  1243				   FSSlogoA5
    430  1243				   FSSlogoB0
    431  1243				   FSSlogoB1
    432  1243				   FSSlogoB2
    433  1243				   FSSlogoB3
    434  1243				   FSSlogoB4
    435  1243				   FSSlogoB5
    436  1243		       00 00 00 00*	      ds	16,0
      0  1253					      CHECKPAGE	FSSlogo
      8  1253					      LIST	ON
    438  1253
      0  1253					      ALIGN_FREE	256
      1  1253				   FREE       SET	FREE - .
      2  1300		       00 00 00 00*	      align	256
      3  1300				   FREE       SET	FREE + .
 @ $f300 : $ad
      4  1300					      echo	"@", ., ":", FREE
    440  1300
    441  1300							; Music data for two channels
    442  1300							; exactly 256 bytes, must start at page start!
    443  1300				   MusicData
    444  1300		       2d 17		      .byte.b	45 , 23
    445  1302		       39 22		      .byte.b	57 , 34
    446  1304		       44 2d		      .byte.b	68 , 45
    447  1306		       5b 36		      .byte.b	91 , 54
    448  1308		       33 14		      .byte.b	51 , 20
    449  130a		       3d 26		      .byte.b	61 , 38
    450  130c		       44 28		      .byte.b	68 , 40
    451  130e		       66 3d		      .byte.b	102, 61
    452  1310		       48 12		      .byte.b	72 , 18
    453  1312		       51 12		      .byte.b	81 , 18
    454  1314		       5b 24		      .byte.b	91 , 36
    455  1316		       6c 12		      .byte.b	108, 18
    456  1318		       51 28		      .byte.b	81 , 40
    457  131a		       99 79		      .byte.b	153, 121
    458  131c		       56 2b		      .byte.b	86 , 43
    459  131e		       88 6c		      .byte.b	136, 108
    460  1320		       2d 17		      .byte.b	45 , 23
    461  1322		       5b 17		      .byte.b	91 , 23
    462  1324		       22 17		      .byte.b	34 , 23
    463  1326		       33 17		      .byte.b	51 , 23
    464  1328		       28 14		      .byte.b	40 , 20
    465  132a		       66 14		      .byte.b	102, 20
    466  132c		       33 14		      .byte.b	51 , 20
    467  132e		       28 14		      .byte.b	40 , 20
    468  1330		       2d 17		      .byte.b	45 , 23
    469  1332		       5b 17		      .byte.b	91 , 23
    470  1334		       22 17		      .byte.b	34 , 23
    471  1336		       33 17		      .byte.b	51 , 23
    472  1338		       48 24		      .byte.b	72 , 36
    473  133a		       b6 24		      .byte.b	182, 36
    474  133c		       5b 24		      .byte.b	91 , 36
    475  133e		       48 24		      .byte.b	72 , 36
    476  1340		       51 14		      .byte.b	81 , 20
    477  1342		       51 14		      .byte.b	81 , 20
    478  1344		       1e 14		      .byte.b	30 , 20
    479  1346		       2d 14		      .byte.b	45 , 20
    480  1348		       40 20		      .byte.b	64 , 32
    481  134a		       a2 20		      .byte.b	162, 32
    482  134c		       51 20		      .byte.b	81 , 32
    483  134e		       40 20		      .byte.b	64 , 32
    484  1350		       22 11		      .byte.b	34 , 17
    485  1352		       56 44		      .byte.b	86 , 68
    486  1354		       26 11		      .byte.b	38 , 17
    487  1356		       5b 44		      .byte.b	91 , 68
    488  1358		       3d 0f		      .byte.b	61 , 15
    489  135a		       3d 0f		      .byte.b	61 , 15
    490  135c		       79 17		      .byte.b	121, 23
    491  135e		       3d 17		      .byte.b	61 , 23
    492  1360		       5b 17		      .byte.b	91 , 23
    493  1362		       5b 17		      .byte.b	91 , 23
    494  1364		       5b 17		      .byte.b	91 , 23
    495  1366		       5b 17		      .byte.b	91 , 23
    496  1368		       5b 2d		      .byte.b	91 , 45
    497  136a		       5b 2d		      .byte.b	91 , 45
    498  136c		       5b 17		      .byte.b	91 , 23
    499  136e		       5b 17		      .byte.b	91 , 23
    500  1370		       5b 14		      .byte.b	91 , 20
    501  1372		       5b 14		      .byte.b	91 , 20
    502  1374		       5b 14		      .byte.b	91 , 20
    503  1376		       5b 14		      .byte.b	91 , 20
    504  1378		       5b 28		      .byte.b	91 , 40
    505  137a		       5b 28		      .byte.b	91 , 40
    506  137c		       5b 14		      .byte.b	91 , 20
    507  137e		       5b 14		      .byte.b	91 , 20
    508  1380		       5b 17		      .byte.b	91 , 23
    509  1382		       73 5b		      .byte.b	115, 91
    510  1384		       5b 17		      .byte.b	91 , 23
    511  1386		       79 5b		      .byte.b	121, 91
    512  1388		       5b 2d		      .byte.b	91 , 45
    513  138a		       73 5b		      .byte.b	115, 91
    514  138c		       5b 17		      .byte.b	91 , 23
    515  138e		       79 5b		      .byte.b	121, 91
    516  1390		       5b 14		      .byte.b	91 , 20
    517  1392		       73 5b		      .byte.b	115, 91
    518  1394		       5b 14		      .byte.b	91 , 20
    519  1396		       79 5b		      .byte.b	121, 91
    520  1398		       51 28		      .byte.b	81 , 40
    521  139a		       66 51		      .byte.b	102, 81
    522  139c		       51 14		      .byte.b	81 , 20
    523  139e		       6c 51		      .byte.b	108, 81
    524  13a0		       5b 17		      .byte.b	91 , 23
    525  13a2		       b6 17		      .byte.b	182, 23
    526  13a4		       5b 17		      .byte.b	91 , 23
    527  13a6		       a2 88		      .byte.b	162, 136
    528  13a8		       5b 2d		      .byte.b	91 , 45
    529  13aa		       99 2d		      .byte.b	153, 45
    530  13ac		       5b 17		      .byte.b	91 , 23
    531  13ae		       88 6c		      .byte.b	136, 108
    532  13b0		       51 14		      .byte.b	81 , 20
    533  13b2		       a2 14		      .byte.b	162, 20
    534  13b4		       51 14		      .byte.b	81 , 20
    535  13b6		       a2 14		      .byte.b	162, 20
    536  13b8		       51 28		      .byte.b	81 , 40
    537  13ba		       79 28		      .byte.b	121, 40
    538  13bc		       51 14		      .byte.b	81 , 20
    539  13be		       a2 14		      .byte.b	162, 20
    540  13c0		       5b 17		      .byte.b	91 , 23
    541  13c2		       73 5b		      .byte.b	115, 91
    542  13c4		       5b 17		      .byte.b	91 , 23
    543  13c6		       79 5b		      .byte.b	121, 91
    544  13c8		       5b 2d		      .byte.b	91 , 45
    545  13ca		       73 5b		      .byte.b	115, 91
    546  13cc		       5b 17		      .byte.b	91 , 23
    547  13ce		       79 5b		      .byte.b	121, 91
    548  13d0		       5b 14		      .byte.b	91 , 20
    549  13d2		       73 5b		      .byte.b	115, 91
    550  13d4		       5b 14		      .byte.b	91 , 20
    551  13d6		       79 5b		      .byte.b	121, 91
    552  13d8		       51 28		      .byte.b	81 , 40
    553  13da		       66 51		      .byte.b	102, 81
    554  13dc		       51 14		      .byte.b	81 , 20
    555  13de		       6c 51		      .byte.b	108, 81
    556  13e0		       73 5b		      .byte.b	115, 91
    557  13e2		       5b 44		      .byte.b	91 , 68
    558  13e4		       44 39		      .byte.b	68 , 57
    559  13e6		       39 2d		      .byte.b	57 , 45
    560  13e8		       66 51		      .byte.b	102, 81
    561  13ea		       51 3d		      .byte.b	81 , 61
    562  13ec		       3d 33		      .byte.b	61 , 51
    563  13ee		       28 14		      .byte.b	40 , 20
    564  13f0		       88 73		      .byte.b	136, 115
    565  13f2		       73 5b		      .byte.b	115, 91
    566  13f4		       5b 44		      .byte.b	91 , 68
    567  13f6		       44 39		      .byte.b	68 , 57
    568  13f8		       66 3d		      .byte.b	102, 61
    569  13fa		       51 33		      .byte.b	81 , 51
    570  13fc		       3d 28		      .byte.b	61 , 40
    571  13fe		       28 14		      .byte.b	40 , 20
    572  1400
    573  1400
    574  1400				   FREE       SET	FREE + BANK_START + ROM_BANK_SIZE/2 - .
    575  1400
 Free bytes in TITLE_LOGO_BANK: $ad
    576  1400					      ECHO	"Free bytes in TITLE_LOGO_BANK:", FREE
    577  1400
      0  1400					      CHECK_HALF_BANK_SIZE	"TITLE_LOGO_BANK"
      1  1400
      2  1400
      3  1400		       04 00	   .TEMP      =	* - BANK_START
 TITLE_LOGO_BANK (1K) SIZE =  $400 , FREE= $0
      4  1400					      ECHO	"TITLE_LOGO_BANK", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1400				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1400				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1400				  -	      ERR
      8  1400					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_Demo.asm LEVEL 2 PASS 3
      0  1400					      include	"BANK_Demo.asm"	; upper half of BANK_TITLE_LOGO
      1  1400							;    NEWBANK DEMO_BANK
      0  1400					      DEFINE_1K_SEGMENT	DEMO
      1  1400					      ALIGN	$400
      2  1400				   SEGMENT_DEMO SET	*
      3  1400				   BANK_DEMO  SET	_CURRENT_BANK
      3  1400
      4  1400		       ff ff ff ff MOVE_NONE  =	~0
      5  1400		       ff ff ff 7f MOVE_RIGHT =	~%10000000
      6  1400		       ff ff ff bf MOVE_LEFT  =	~%01000000
      7  1400		       ff ff ff df MOVE_DOWN  =	~%00100000
      8  1400		       ff ff ff ef MOVE_UP    =	~%00010000
      9  1400
     10  1400							;------------------------------------------------------------------------------
     11  1400					      MAC	checksounds
     12  1400					      lda	soundIdxLst+1
     13  1400					      cmp	#OFSS_MAGIC_WALL+1	; Amoeba or Magic Wall?
     14  1400					      bcs	.waitForIt
     15  1400					      STOP_CHANNEL	1	; yes, stop repeating sounds
     16  1400					      lda	soundIdxLst
     17  1400				   .waitForIt
     18  1400					      ENDM
     19  1400							;------------------------------------------------------------------------------
     20  1400
      0  1400					      DEFINE_SUBROUTINE	NextCave
      1  1400		       00 02	   BANK_NextCave =	_CURRENT_BANK
      2  1400					      SUBROUTINE
      3  1400				   NextCave
     22  1400
     23  1400							;CHECKSOUNDS		      ; wait until all sounds are over
     24  1400							;bne .skipNextLevel
     25  1400
     26  1400							; Now do the actual switching
     27  1400
     28  1400		       a5 c7		      lda	NextLevelTrigger
     29  1402		       29 7f		      and	#<(~BIT_NEXTLEVEL)
     30  1404		       85 c7		      sta	NextLevelTrigger
     31  1406
     32  1406							; Next level is due. Point to the next cave, but if we're at the end of playable caves,
     33  1406							; then increment the level number. This is completely circular, so we eventually wrap
     34  1406							; the cave back to 0 and start afresh. The level maxes out at P5 then remains at the top.
     35  1406
     36  1406		       a5 b1	   NextCaveAlong lda	cave
     37  1408		       18		      clc
     38  1409		       69 04		      adc	#CAVE_DATA_SIZE
     39  140b		       c9 20		      cmp	#MAX_CAVENUM
     40  140d		       90 02		      bcc	.caveOK
     41  140f
     42  140f							;		  ldx level
     43  140f							;		  cpx #NUM_LEVELS-1
     44  140f							;		  bcs .skipIncLevel
     45  140f							;		  inc level
     46  140f							;.skipIncLevel
     47  140f
     48  140f		       a9 00		      lda	#0
     49  1411		       85 b1	   .caveOK    sta	cave
     50  1413		       60	   .skipNextLevel rts
     51  1414
     52  1414
      0  1414					      CHECK_BANK_SIZE	"DEMO_BANK"
      1  1414		       04 14	   .TEMP      =	* - BANK_START
 DEMO_BANK (2K) SIZE =  $414 , FREE= $3ec
      2  1414					      ECHO	"DEMO_BANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1414				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1414				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1414				  -	      ERR
      6  1414					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 3
      0  1414					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1  1414							;------------------------------------------------------------------------------
      2  1414							;##############################################################################
      3  1414							;------------------------------------------------------------------------------
      0  1414					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  1be6 ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
      5  1800
      6  1800							; This is essentially a ROM mirror of a RAM bank.
      7  1800							; The contents of this bank are copied to each of the ROW banks on startup, and
      8  1800							; this gives a 1:1 correspondence between the data/addresses defined here, and
      9  1800							; the addresses in the switched-in RAM bank.
     10  1800
     11  1800							; Note: Bankswitching code between any of these banks guarantees the code can
     12  1800							; continue to run -- because, of course, the same code is still at the same
     13  1800							; memory address.
     14  1800
     15  1800		       00 01	   _PROFILE_DRAW =	YES
     16  1800
     17  1800					      MAC	profile_draw
     18  1800					      IF	_PROFILE_DRAW
     19  1800					      inc	Profile{1}
     20  1800					      bne	$skip
     21  1800					      inc	Profile{1}+1
     22  1800				   $skip
     23  1800					      ENDIF
     24  1800					      ENDM		; {label}
     25  1800
     26  1800
      0  1800					      DEFINE_SUBROUTINE	DrawTheScreen
      1  1800		       00 03	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  1800					      SUBROUTINE
      3  1800				   DrawTheScreen
     28  1800
     29  1800							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     30  1800							; A refactor of the kernel to improve the timing.
     31  1800							; Experimental refactor to remove the blank line...
     32  1800
     33  1800							; adjust here so that the first line of the kernel starts exactly at cycle 67
     34  1800							; (since TJ said it could start up to 5 cycles earlier than #67).
     35  1800
     36  1800							; TODO: remove GRP1 and COLUP1 access (or use higher resolution Rockford)
     37  1800							;	     @57
      0  1800					      SLEEP	3	; 3
      1  1800				   .CYCLES    SET	3
      2  1800
      3  1800				  -	      IF	.CYCLES < 2
      4  1800				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1800				  -	      ERR
      6  1800					      ENDIF
      7  1800
      8  1800					      IF	.CYCLES & 1
      9  1800					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1800		       04 00		      nop	0
     11  1802				  -	      ELSE
     12  1802				  -	      bit	VSYNC
     13  1802					      ENDIF
     14  1802				   .CYCLES    SET	.CYCLES - 3
     15  1802					      ENDIF
     16  1802
     17  1802				  -	      REPEAT	.CYCLES / 2
     18  1802				  -	      nop
     19  1802					      REPEND
     39  1802
     40  1802		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     41  1804		       10 3e		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     42  1806
     43  1806				   Proc2		; 5
      0  1806					      SLEEP	3	; 3	     @64
      1  1806				   .CYCLES    SET	3
      2  1806
      3  1806				  -	      IF	.CYCLES < 2
      4  1806				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1806				  -	      ERR
      6  1806					      ENDIF
      7  1806
      8  1806					      IF	.CYCLES & 1
      9  1806					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1806		       04 00		      nop	0
     11  1808				  -	      ELSE
     12  1808				  -	      bit	VSYNC
     13  1808					      ENDIF
     14  1808				   .CYCLES    SET	.CYCLES - 3
     15  1808					      ENDIF
     16  1808
     17  1808				  -	      REPEAT	.CYCLES / 2
     18  1808				  -	      nop
     19  1808					      REPEND
     45  1808		       10 3c		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     46  180a
     47  180a				   ScanRED		;	     @60
     48  180a		       b9 25 f3    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     49  180d		       85 4d		      sta	PF0	; 3	     @67
     50  180f		       b9 a7 f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     51  1812		       85 4e		      sta	PF1	; 3 = 14    @74
     52  1814				   SELFMOD_PLAYERCOL_RED
     53  1814		       b9 af f0 	      lda	SpriteColourRED,y	; 4
     54  1817		       85 46		      sta	COLUP0	; 3	     @05
     55  1819		       85 47		      sta	COLUP1	; 3 = 10    @08
     56  181b
     57  181b							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     58  181b
     59  181b				   SELFMOD_RED
     60  181b		       a9 00		      lda	#0	; 2
     61  181d		       85 48		      sta	COLUPF	; 3 =	5    @13
     62  181f
     63  181f				   SELFMOD_PLAYER0_RED
     64  181f		       b9 25 f3 	      lda	ShapePlayerRED,y	; 4
     65  1822		       85 5b		      sta	GRP0	; 3 =	7    @20
     66  1824
     67  1824		       b9 bc f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
     68  1827		       85 4f		      sta	PF2	; 3 =	7    @27
     69  1829
     70  1829		       b9 25 f3    SM_PF0_REDr lda	CHARACTERSHAPE_BLANK,y	; 4
     71  182c		       85 4d		      sta	PF0	; 3	     @34
     72  182e		       b9 d1 f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
     73  1831		       85 4e		      sta	PF1	; 3	     @41
     74  1833		       b9 e6 f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
     75  1836		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
     76  1838
     77  1838				   SELFMOD_PLAYER1_RED
     78  1838		       b9 25 f3 	      lda	ShapePlayerRED,y	; 4
     79  183b		       8d 5c 00 	      sta.w	GRP1	; 4 =	8    @56   VDELed!
     80  183e
     81  183e		       88		      dey		; 2
     82  183f		       10 c5		      bpl	Proc2	; 2(3)      --> 61 if taken
     83  1841
     84  1841		       e8	   SELFMOD_X  inx		; 2
     85  1842		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
     86  1844							;EXIT_RETURN_HERE
     87  1844				   NextALineStart
     88  1844		       a0 06		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
     89  1846				   ScanBLUEBD		;	     @67     let's start as late as possible
     90  1846
     91  1846							;------------------------------------------------------------------------------
     92  1846
     93  1846		       b9 25 f3    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
     94  1849		       85 4d		      sta	PF0	; 3 =	7    @74
     95  184b				   SELFMOD_PLAYERCOL_BLUE
     96  184b		       b9 bd f0 	      lda	SpriteColourBLUE,y	; 4
     97  184e		       85 47		      sta	COLUP1	; 3	     @05
     98  1850		       85 46		      sta	COLUP0	; 3 = 10    @08
     99  1852
    100  1852				   SELFMOD_BLUE
    101  1852		       a9 00		      lda	#0	; 2
    102  1854		       85 48		      sta	COLUPF	; 3 =	5    @13
    103  1856
    104  1856				   SELFMOD_PLAYER0_BLUE
    105  1856		       b9 25 f3 	      lda	ShapePlayerBLUE,y	; 4
    106  1859		       85 5b		      sta	GRP0	; 3 =	7    @20
    107  185b
    108  185b		       b9 b5 f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    109  185e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    110  1860		       b9 ca f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    111  1863		       85 4f		      sta	PF2	; 3 = 14    @34
    112  1865
    113  1865		       b9 25 f3    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    114  1868		       85 4d		      sta	PF0	; 3	     @41
    115  186a		       b9 df f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    116  186d		       85 4e		      sta	PF1	; 3	     @48
    117  186f		       b9 f4 f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    118  1872		       85 4f		      sta	PF2	; 3 = 21    @55
    119  1874
    120  1874				   SELFMOD_PLAYER1_BLUE
    121  1874		       b9 25 f3 	      lda	ShapePlayerBLUE,y	; 4
    122  1877		       85 5c		      sta	GRP1	; 3 =	7    VDELed! @62
    123  1879
    124  1879							;------------------------------------------------------------------------------
    125  1879
    126  1879				   ScanGREEN		;	     @62
    127  1879		       b9 25 f3    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    128  187c		       85 4d		      sta	PF0	; 3 =	7    @69
    129  187e				   SELFMOD_PLAYERCOL_GREEN
    130  187e		       b9 b6 f0 	      lda	SpriteColourGREEN,y	; 4
    131  1881		       85 47		      sta	COLUP1	; 3	     @00
    132  1883		       85 46		      sta	COLUP0	; 3 = 10    @03
    133  1885
    134  1885				   SELFMOD_GREEN
    135  1885		       a9 00		      lda	#0	; 2
    136  1887		       85 48		      sta	COLUPF	; 3 =	5    @08
    137  1889
    138  1889				   SELFMOD_PLAYER0_GREEN
    139  1889		       b9 25 f3 	      lda	ShapePlayerGREEN,y	; 4
    140  188c		       85 5b		      sta	GRP0	; 3 =	7    @15
    141  188e
    142  188e		       b9 ae f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    143  1891		       85 4e		      sta	PF1	; 3	     @22
    144  1893		       b9 c3 f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    145  1896		       85 4f		      sta	PF2	; 3 = 14    @29
    146  1898
    147  1898		       b9 25 f3    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    148  189b		       85 4d		      sta	PF0	; 3	     @36
    149  189d		       b9 d8 f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    150  18a0		       85 4e		      sta	PF1	; 3	     @43
    151  18a2		       b9 ed f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    152  18a5		       85 4f		      sta	PF2	; 3 = 21    @50
    153  18a7
    154  18a7				   SELFMOD_PLAYER1_GREEN
    155  18a7		       b9 25 f3 	      lda	ShapePlayerGREEN,y	; 4
    156  18aa		       85 5c		      sta	GRP1	; 3 =	7    @57     VDELed!
    157  18ac
    158  18ac		       4c 0a f0 	      jmp	ScanRED	; 3	     @60
    159  18af
    160  18af							;------------------------------------------------------------------------------
    161  18af
    162  18af							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    163  18af
    164  18af		       f3 25	   ShapePlayer =	PLAYER_BLANK
    165  18af		       f3 25	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    166  18af		       f3 25	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    167  18af		       f3 25	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    168  18af
    169  18af		       f3 25	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    170  18af		       f3 25	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    171  18af		       f3 25	   CHARACTERSHAPE_EXITDOOR2 =	PLAYER_BLANK
    172  18af		       f2 7e	   CHARACTERSHAPE_EXPLOSION =	CHARACTERSHAPE_EXPLOSION2	;PLAYER_BLANK
    173  18af		       f2 7e	   CHARACTERSHAPE_EXPLOSION_MIRRORED =	CHARACTERSHAPE_EXPLOSION2	;PLAYER_BLANK		     ; TODO: change
    174  18af
------- FILE Rockford_Color.asm LEVEL 3 PASS 3
      0  18af					      include	"Rockford_Color.asm"	; 1 * LINES_PER_CHAR bytes
      0  18af					      OPTIONAL_PAGEBREAK	"SpriteColour", LINES_PER_CHAR*2
     10  18af					      LIST	ON
      2  18af
      3  18af		       00 10	   YELLOW_NTSC =	$10	; hair
      4  18af		       00 30	   ORANGE_NTSC =	$30	; skin
      5  18af		       00 40	   RED_NTSC   =	$40	; shirt
      6  18af		       00 a4	   BLUE_NTSC  =	$A4
      7  18af
      8  18af		       00 20	   YELLOW_PAL =	$20
      9  18af		       00 40	   ORANGE_PAL =	$40
     10  18af		       00 60	   RED_PAL    =	$60
     11  18af
     12  18af				   SpriteColour
     13  18af							; NTSC
     14  18af							;SpriteColourRED
     15  18af							;    .byte RED_NTSC|$6       ; 0 feet
     16  18af							;    .byte WHITE	      ; 3
     17  18af							;    .byte RED_NTSC|$4       ; 6
     18  18af							;    .byte RED_NTSC|$4       ; 9
     19  18af							;    .byte ORANGE_NTSC|$6    ;12
     20  18af							;    .byte ORANGE_NTSC|$8    ;15
     21  18af							;    .byte WHITE	      ;18
     22  18af							;SpriteColourGREEN
     23  18af							;    .byte RED_NTSC|$4       ; 1
     24  18af							;    .byte WHITE	      ; 4
     25  18af							;    .byte WHITE	      ; 7
     26  18af							;    .byte WHITE	      ;10
     27  18af							;    .byte ORANGE_NTSC|$8    ;13
     28  18af							;    .byte ORANGE_NTSC|$6    ;16
     29  18af							;    .byte WHITE	      ;19
     30  18af							;SpriteColourBLUE
     31  18af							;    .byte WHITE	      ; 2
     32  18af							;    .byte RED_NTSC|$4       ; 5
     33  18af							;    .byte RED_NTSC|$4       ; 8
     34  18af							;    .byte ORANGE_NTSC|$4    ;11 neck
     35  18af							;    .byte ORANGE_NTSC|$a    ;14
     36  18af							;    .byte YELLOW_NTSC|$c    ;17 hair
     37  18af							;    .byte WHITE	      ;20
     38  18af
     39  18af				   SpriteColourRED
     40  18af		       0e		      .byte.b	WHITE
     41  18b0		       0e		      .byte.b	WHITE
     42  18b1		       0e		      .byte.b	WHITE
     43  18b2		       0e		      .byte.b	WHITE
     44  18b3		       0e		      .byte.b	WHITE
     45  18b4		       0e		      .byte.b	WHITE
     46  18b5		       0e		      .byte.b	WHITE
     47  18b6
     48  18b6							;  .byte #$1C;0
     49  18b6							;  .byte #$78;3
     50  18b6							;  .byte #$52;6
     51  18b6							;  .byte #$52;9
     52  18b6							;  .byte #$0C;12
     53  18b6							;  .byte #$4A;15
     54  18b6							;  .byte #$1A;18
     55  18b6				   SpriteColourGREEN
     56  18b6		       0e		      .byte.b	WHITE
     57  18b7		       0e		      .byte.b	WHITE
     58  18b8		       0e		      .byte.b	WHITE
     59  18b9		       0e		      .byte.b	WHITE
     60  18ba		       0e		      .byte.b	WHITE
     61  18bb		       0e		      .byte.b	WHITE
     62  18bc		       0e		      .byte.b	WHITE
     63  18bd				   SpriteColourBLUE
     64  18bd		       0e		      .byte.b	WHITE
     65  18be		       0e		      .byte.b	WHITE
     66  18bf		       0e		      .byte.b	WHITE
     67  18c0		       0e		      .byte.b	WHITE
     68  18c1		       0e		      .byte.b	WHITE
     69  18c2		       0e		      .byte.b	WHITE
     70  18c3		       0e		      .byte.b	WHITE
     71  18c4
     72  18c4					      REPEAT	21
     73  18c4		       26		      .byte.b	$20|$6	; 2
     72  18c4					      REPEND
     73  18c5		       26		      .byte.b	$20|$6	; 2
     72  18c5					      REPEND
     73  18c6		       26		      .byte.b	$20|$6	; 2
     72  18c6					      REPEND
     73  18c7		       26		      .byte.b	$20|$6	; 2
     72  18c7					      REPEND
     73  18c8		       26		      .byte.b	$20|$6	; 2
     72  18c8					      REPEND
     73  18c9		       26		      .byte.b	$20|$6	; 2
     72  18c9					      REPEND
     73  18ca		       26		      .byte.b	$20|$6	; 2
     72  18ca					      REPEND
     73  18cb		       26		      .byte.b	$20|$6	; 2
     72  18cb					      REPEND
     73  18cc		       26		      .byte.b	$20|$6	; 2
     72  18cc					      REPEND
     73  18cd		       26		      .byte.b	$20|$6	; 2
     72  18cd					      REPEND
     73  18ce		       26		      .byte.b	$20|$6	; 2
     72  18ce					      REPEND
     73  18cf		       26		      .byte.b	$20|$6	; 2
     72  18cf					      REPEND
     73  18d0		       26		      .byte.b	$20|$6	; 2
     72  18d0					      REPEND
     73  18d1		       26		      .byte.b	$20|$6	; 2
     72  18d1					      REPEND
     73  18d2		       26		      .byte.b	$20|$6	; 2
     72  18d2					      REPEND
     73  18d3		       26		      .byte.b	$20|$6	; 2
     72  18d3					      REPEND
     73  18d4		       26		      .byte.b	$20|$6	; 2
     72  18d4					      REPEND
     73  18d5		       26		      .byte.b	$20|$6	; 2
     72  18d5					      REPEND
     73  18d6		       26		      .byte.b	$20|$6	; 2
     72  18d6					      REPEND
     73  18d7		       26		      .byte.b	$20|$6	; 2
     72  18d7					      REPEND
     73  18d8		       26		      .byte.b	$20|$6	; 2
     74  18d9					      REPEND
     75  18d9
     76  18d9							; PAL
     77  18d9							;    .byte RED_PAL|$6	      ; 0 feet
     78  18d9							;    .byte WHITE	      ; 3
     79  18d9							;    .byte RED_PAL|$4	      ; 6
     80  18d9							;    .byte RED_PAL|$4	      ; 9
     81  18d9							;    .byte ORANGE_PAL|$4     ;12
     82  18d9							;    .byte ORANGE_PAL|$6     ;15
     83  18d9							;    .byte WHITE	      ;18
     84  18d9							;
     85  18d9							;    .byte RED_PAL|$4	      ; 1
     86  18d9							;    .byte WHITE	      ; 4
     87  18d9							;    .byte WHITE	      ; 7
     88  18d9							;    .byte WHITE	      ;10
     89  18d9							;    .byte ORANGE_PAL|$6     ;13
     90  18d9							;    .byte ORANGE_PAL|$4     ;16
     91  18d9							;    .byte WHITE	      ;19
     92  18d9							;
     93  18d9							;    .byte WHITE	      ; 2
     94  18d9							;    .byte RED_PAL|$4	      ; 5
     95  18d9							;    .byte RED_PAL|$4	      ; 8
     96  18d9							;    .byte ORANGE_PAL|$2     ;11 neck
     97  18d9							;    .byte ORANGE_PAL|$8     ;14
     98  18d9							;    .byte YELLOW_PAL|$c     ;17 hair
     99  18d9							;    .byte WHITE	      ;20
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    176  18d9
    177  18d9
    178  18d9							;------------------------------------------------------------------------------
    179  18d9
    180  18d9							;*** Ideas: ***
    181  18d9							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    182  18d9							;   13.5% on average), also unrolling would be more effective than now
    183  18d9							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    184  18d9							;   see EXPERIMENTAL)
    185  18d9							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    186  18d9							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    187  18d9							;   bidirectional linked list instead)
    188  18d9							; - calculate mirrored gfx data into RAM (saves ROM)
    189  18d9
    190  18d9							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    191  18d9							;currently:
    192  18d9							; 72%*539 (!unrolled)
    193  18d9							;+ 8%*304 (unrolled)
    194  18d9							;+20%*269 (unrolled)
    195  18d9							;--------
    196  18d9							;=   ~466.2 cycles on average
    197  18d9
    198  18d9							;alternative #1:
    199  18d9							; 72%*522 (unrolled)
    200  18d9							;+ 8%*352 (!unrolled)
    201  18d9							;+20%*307 (!unrolled)
    202  18d9							;--------
    203  18d9							;=   ~465.4 cycles on average
    204  18d9
    205  18d9
    206  18d9		       00 01	   MIRROR     =	1
    207  18d9		       00 80	   DIRECT     =	$80
    208  18d9
    209  18d9							;------------------------------------------------------------------------------
    210  18d9							; Here we don't draw into a buffer, but directly patch the kernel
    211  18d9							; VERY fast!
    212  18d9							;
    213  18d9							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    214  18d9							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    215  18d9
    216  18d9				   PF0Draw		; 25 cycles until here
    217  18d9
    218  18d9		       ae 84 02 	      ldx	INTIM	; 4
    219  18dc		       e0 05		      cpx	#SEGTIME_SCD_PF0	; 2
    220  18de		       90 72		      bcc	ExitDraw	; 2(3)=8
      0  18e0					      STRESS_TIME	SEGTIME_SCD_PF0	; ok!
      1  18e0				  -	      IF	TEST_SEGTIME_SCD_PF0 = 1
      2  18e0				  -
      3  18e0				  -
      4  18e0				  -
      5  18e0				  -
      6  18e0				  -
      7  18e0				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  18e0				  -	      bne	. - 7
      9  18e0					      ENDIF
    222  18e0
    223  18e0		       29 7f		      and	#<(~DIRECT)	; 2
    224  18e2		       aa		      tax		; 2 =	4
    225  18e3
    226  18e3		       98		      tya		; 2
    227  18e4		       0a		      asl		; 2	     no mirrored chars in PF0
    228  18e5		       a8		      tay		; 2 =	6
    229  18e6							;		  clc				  ; 2
    230  18e6
    231  18e6		       b9 df fc 	      lda	CharacterDataVecHI,y	; 4
    232  18e9		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    233  18ec		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    234  18ef		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19
    235  18f2
    236  18f2		       b9 cb fc 	      lda	CharacterDataVecLO,y	; 4
    237  18f5		       9d 0b f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    238  18f8		       69 06		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    239  18fa		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    240  18fd		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    241  18ff		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23
    242  1902
    243  1902		       4c ab fa 	      jmp	DrawAnother	; 3 =	3
    244  1905
    245  1905							; Timing for PF0Draw
    246  1905							; 7+63 = 70
    247  1905							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    248  1905
    249  1905
    250  1905							;------------------------------------------------------------------------------
    251  1905							; Direct draw draws to PF0, which only has one active member of the character
    252  1905							; pair -- so it can be a direct copy.	Quicker still!
    253  1905
    254  1905				   DirectDraw		; 37 cycles until here
    255  1905
    256  1905							;ldy #16
    257  1905		       ad 84 02 	      lda	INTIM	; 4
    258  1908		       c9 08		      cmp	#SEGTIME_SCD_DIRECT	; 2
    259  190a		       90 46		      bcc	ExitDraw	; 2(3)=8
      0  190c					      STRESS_TIME	SEGTIME_SCD_DIRECT	; ok!
      1  190c				  -	      IF	TEST_SEGTIME_SCD_DIRECT = 1
      2  190c				  -
      3  190c				  -
      4  190c				  -
      5  190c				  -
      6  190c				  -
      7  190c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  190c				  -	      bne	. - 7
      9  190c					      ENDIF
    261  190c
    262  190c							; TIME REQUIRED FROM HERE (9/JAN)
    263  190c							; 16 + 20 + 20 + 2 + ( 7 * 32 ) - 1  + (42 SUFFIX)
    264  190c							; = 323 --> /64 = 5.04 USE 7
    265  190c
    266  190c		       b9 df fc 	      lda	CharacterDataVecHI,y	; 4
    267  190f		       8d 3c f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    268  1912		       8d 42 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    269  1915		       8d 48 f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    270  1918
    271  1918		       b9 cb fc 	      lda	CharacterDataVecLO,y	; 4
    272  191b		       8d 3b f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    273  191e		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    274  1920		       8d 41 f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    275  1923		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    276  1925		       8d 47 f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    277  1928
    278  1928		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    279  192b		       8d 3e f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    280  192e		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    281  1930		       8d 44 f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    282  1933		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    283  1935		       8d 4a f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    284  1938
    285  1938		       a0 06		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    286  193a				   TSFill3
    287  193a		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    288  193d		       99 a7 f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    289  1940		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    290  1943		       99 a7 f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    291  1946		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    292  1949		       99 a7 f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    293  194c
    294  194c		       88		      dey		; 2
      0  194d					      CHECKPAGE_BPL	TSFill3	; 3(2)=5
      8  194d					      LIST	ON
      9  194d		       10 eb		      bpl	TSFill3
    296  194f
    297  194f		       4c ab fa 	      jmp	DrawAnother	; 3
    298  1952
    299  1952							; Timing for DirectDraw
    300  1952							; 17+8+16+20+20+2+(32*7)-1+3 = 309 (was: 302 + 3)
    301  1952							; total: 37+309+6 = 352 => 352/64 + 1.4 = 6.90 = 7 (= SEGTIME_SLOWDRAW-5)
    302  1952
    303  1952				   ExitDraw
    304  1952		       60		      rts
    305  1953
    306  1953							;------------------------------------------------------------------------------
      0  1953					      DEFINE_SUBROUTINE	StealPart3	; 18 CYCLES HERE
      1  1953		       00 03	   BANK_StealPart3 =	_CURRENT_BANK
      2  1953					      SUBROUTINE
      3  1953				   StealPart3
    308  1953
    309  1953		       bd ee f1 	      lda	MOD10,x	; 4
    310  1956		       30 81		      bmi	PF0Draw	; 2/3
    311  1958		       4a		      lsr		; 2
    312  1959		       aa		      tax		; 2
    313  195a		       98		      tya		; 2
    314  195b		       2a		      rol		; 2	     allows for mirrored char = * | 1
    315  195c		       a8		      tay		; 2
    316  195d		       b0 a6		      bcs	DirectDraw	; 2(3)      when draw stack was built, bit 7 flags direct-drawn character
    317  195f							;	     => +19 starting DirectDraw BUT WHO CARES AS IT'S ONLY AFTER THAT COUNTS
    318  195f
    319  195f		       b9 df fc 	      lda	CharacterDataVecHI,y	; 4
    320  1962		       10 38		      bpl	QuickDraw	; 2(3)=42   special-case blank characters for extra speed
    321  1964							;	     => 42 starting QuickDraw
    322  1964		       8d 8d f5 	      sta	SMEOR1+RAM_WRITE+2	; 4 =	4
    323  1967
    324  1967		       ad 84 02 	      lda	INTIM	; 4
    325  196a		       c9 0c		      cmp	#SEGTIME_SCD_SLOW	; 2
    326  196c		       90 e4		      bcc	ExitDraw	; 2(3)=8
      0  196e					      STRESS_TIME	SEGTIME_SCD_SLOW	; ok!
      1  196e				  -	      IF	TEST_SEGTIME_SCD_SLOW = 1
      2  196e				  -
      3  196e				  -
      4  196e				  -
      5  196e				  -
      6  196e				  -
      7  196e				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  196e				  -	      bne	. - 7
      9  196e					      ENDIF
    328  196e
    329  196e							; TIME REQUIRED FROM HERE (9/JAN)
    330  196e							; 8 + 16 + 8 + 2 + (21 * 23) -1 + (42 OVERHEAD WHEN RETURNING)
    331  196e							; = 558 --> /64 = 8.71 INTIM --> USE 10
    332  196e
    333  196e		       b9 cb fc 	      lda	CharacterDataVecLO,y	; 4
    334  1971		       8d 8c f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    335  1974
    336  1974		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    337  1977		       8d 89 f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    338  197a		       8d 91 f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    339  197d		       8d 94 f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    340  1980
    341  1980		       bd e6 f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    342  1983		       8d 8f f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    343  1986
    344  1986		       a0 14	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2
    345  1988
    346  1988							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    347  1988							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    348  1988
    349  1988				   TSFill
    350  1988
    351  1988		       b9 a7 f2    SMLOAD     lda	ScreenBitmap,y	; 4
    352  198b		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    353  198e		       29 00	   SMMASK     and	#0	; 2
    354  1990		       59 a7 f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    355  1993		       99 a7 f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    356  1996
    357  1996		       88		      dey		; 2
      0  1997					      CHECKPAGE_BPL	TSFill	; 3(2)=5
      8  1997					      LIST	ON
      9  1997		       10 ef		      bpl	TSFill
    359  1999
    360  1999		       4c ab fa 	      jmp	DrawAnother	; 3
    361  199c
    362  199c							; Timing for "SLOW" draw
    363  199c							; 22+4+8+8+16+8+2+(21*24)-1+3 = 574 (was: 566 + 3)
    364  199c							; total: 37+574+6 = 617 => 628/64 + 1.4 = 11.04 = 12 (= SEGTIME_SLOWDRAW)
    365  199c
    366  199c
    367  199c							;------------------------------------------------------------------------------
    368  199c							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    369  199c							; existing character data, so can be special-cased from the normal character
    370  199c							; draw, saving roughly 230 cycles.
    371  199c
    372  199c				   QuickDraw		; 42 cycles until here
    373  199c
    374  199c		       ad 84 02 	      lda	INTIM	; 4
    375  199f		       c9 09		      cmp	#SEGTIME_SCD_QUICK	; 2	     SEE TIMING CALCS BELOW
    376  19a1		       90 af		      bcc	ExitDraw	; 2(3)=8
      0  19a3					      STRESS_TIME	SEGTIME_SCD_QUICK	; ok!
      1  19a3				  -	      IF	TEST_SEGTIME_SCD_QUICK = 1
      2  19a3				  -
      3  19a3				  -
      4  19a3				  -
      5  19a3				  -
      6  19a3				  -
      7  19a3				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  19a3				  -	      bne	. - 7
      9  19a3					      ENDIF
    378  19a3
    379  19a3							; TIME REQUIRED FROM HERE (9/JAN)
    380  19a3							;   = 32 + 4 + 2 + ( 7 * 38 ) - 1 + 3	+ (42 SUFFIX)
    381  19a3							;   = 348 --> /64 = 5.43. USE 7
    382  19a3
    383  19a3		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    384  19a6		       8d c3 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    385  19a9		       8d c6 f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    386  19ac		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    387  19ae		       8d ca f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    388  19b1		       8d cd f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    389  19b4		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    390  19b6		       8d d1 f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    391  19b9		       8d d4 f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32
    392  19bc
    393  19bc		       bc e4 f1 	      ldy	CharMask,x	; 4 =	4    masks out left or right
    394  19bf
    395  19bf		       a2 06		      ldx	#LINES_PER_CHAR/3 - 1	; 2 =	2
    396  19c1				   TSFill2
    397  19c1		       98		      tya		; 2
    398  19c2		       3d a7 f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    399  19c5		       9d a7 f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    400  19c8		       98		      tya		; 2
    401  19c9		       3d a7 f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    402  19cc		       9d a7 f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    403  19cf		       98		      tya		; 2
    404  19d0		       3d a7 f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    405  19d3		       9d a7 f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33
    406  19d6
    407  19d6		       ca		      dex		; 2
      0  19d7					      CHECKPAGE_BPL	TSFill2	; 3(2)=5
      8  19d7					      LIST	ON
      9  19d7		       10 e8		      bpl	TSFill2
    409  19d9
    410  19d9		       4c ab fa 	      jmp	DrawAnother	; 3
    411  19dc
    412  19dc							; Timing for QuickDraw
    413  19dc							; 23+8+32+4+2+(7*38)-1+3 = 337 (was: 330 + 3)
    414  19dc							; total: 37+337+6 = 380 => 380/64 + 1.4 = 7.34 = 8 (= SEGTIME_SLOWDRAW-4)
    415  19dc
    416  19dc
    417  19dc							;------------------------------------------------------------------------------
    418  19dc
    419  19dc
    420  19dc				   CharAddressLO		;[abs char location % 10]
    421  19dc
    422  19dc							; Gives the absolute screen buffer address of the first line of the given character
    423  19dc							; Where character number is 0-9
    424  19dc
    425  19dc		       a7		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    426  19dd		       a7		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    427  19de		       bc		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    428  19df		       bc		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    429  19e0		       d1		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    430  19e1		       d1		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    431  19e2		       e6		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    432  19e3		       e6		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    433  19e4							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    434  19e4							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    435  19e4
    436  19e4				   CharMask		; [abs char location % 10]
    437  19e4
    438  19e4							; Gives the mask for any char of the screen (per row)
    439  19e4							; Note, this is hardwired to the screen format of 6 bytes/line
    440  19e4
    441  19e4		       0f		      .byte.b	$0F	; 1
    442  19e5		       f0		      .byte.b	$F0	; 2
    443  19e6				   CharMaskNeg
    444  19e6		       f0		      .byte.b	$F0	; 3/1
    445  19e7		       0f		      .byte.b	$0F	; 4/2
    446  19e8		       0f		      .byte.b	$0F	; 6/3
    447  19e9		       f0		      .byte.b	$F0	; 7/4
    448  19ea		       f0		      .byte.b	$F0	; 8/6
    449  19eb		       0f		      .byte.b	$0F	; 9/7
    450  19ec		       0f		      .byte.b	$0F	; -/8
    451  19ed		       f0		      .byte.b	$F0	; -/9
    452  19ee				   MOD10
    453  19ee					      REPEAT	SCREEN_LINES
    454  19ee							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  19ee							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  19ee		       80		      .byte.b	DIRECT
    457  19ef		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  19f3		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  19f4		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  19f4					      REPEND
    454  19f8							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  19f8							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  19f8		       80		      .byte.b	DIRECT
    457  19f9		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  19fd		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  19fe		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  19fe					      REPEND
    454  1a02							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  1a02							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  1a02		       80		      .byte.b	DIRECT
    457  1a03		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  1a07		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  1a08		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  1a08					      REPEND
    454  1a0c							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  1a0c							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  1a0c		       80		      .byte.b	DIRECT
    457  1a0d		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  1a11		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  1a12		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  1a12					      REPEND
    454  1a16							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  1a16							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  1a16		       80		      .byte.b	DIRECT
    457  1a17		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  1a1b		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  1a1c		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  1a1c					      REPEND
    454  1a20							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  1a20							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  1a20		       80		      .byte.b	DIRECT
    457  1a21		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  1a25		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  1a26		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  1a26					      REPEND
    454  1a2a							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  1a2a							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  1a2a		       80		      .byte.b	DIRECT
    457  1a2b		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  1a2f		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  1a30		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  1a30					      REPEND
    454  1a34							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  1a34							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    456  1a34		       80		      .byte.b	DIRECT
    457  1a35		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    458  1a39		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    459  1a3a		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    460  1a3e					      REPEND
    461  1a3e
    462  1a3e							;------------------------------------------------------------------------------
    463  1a3e
------- FILE target.asm LEVEL 3 PASS 3
      0  1a3e					      include	"target.asm"	; 2 * LINES_PER_CHAR + 2 bytes
      1  1a3e		       00 02	   DIAMOND_DEF =	2
      2  1a3e
      3  1a3e					      if	DIAMOND_DEF = 2
      4  1a3e
      0  1a3e					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET", LINES_PER_CHAR+1
     10  1a3e					      LIST	ON
      6  1a3e				   CHARACTERSHAPE_TARGET2_MIRRORED
      7  1a3e		       00		      .byte.b	%00000000
      8  1a3f				   CHARACTERSHAPE_TARGET_MIRRORED
      9  1a3f		       00		      .byte.b	%00000000
     10  1a40		       66		      .byte.b	%01100110
     11  1a41		       66		      .byte.b	%01100110
     12  1a42		       66		      .byte.b	%01100110
     13  1a43		       66		      .byte.b	%01100110
     14  1a44		       00		      .byte.b	%00000000
     15  1a45		       00		      .byte.b	%00000000	;R
     16  1a46		       00		      .byte.b	%00000000
     17  1a47		       66		      .byte.b	%01100110
     18  1a48		       66		      .byte.b	%01100110
     19  1a49		       66		      .byte.b	%01100110
     20  1a4a		       66		      .byte.b	%01100110
     21  1a4b		       00		      .byte.b	%00000000
     22  1a4c		       00		      .byte.b	%00000000	;B
     23  1a4d		       00		      .byte.b	%00000000
     24  1a4e		       66		      .byte.b	%01100110
     25  1a4f		       66		      .byte.b	%01100110
     26  1a50		       66		      .byte.b	%01100110
     27  1a51		       66		      .byte.b	%01100110
     28  1a52		       00		      .byte.b	%00000000
     29  1a53							;    .byte %00000000 ;G
     30  1a53
     31  1a53							;--------------------------------------------------------------------------
     32  1a53							;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_TARGET_MIRRORED", LINES_PER_CHAR+1
     33  1a53				   CHARACTERSHAPE_TARGET2
     34  1a53		       00		      .byte.b	%00000000
     35  1a54				   CHARACTERSHAPE_TARGET
     36  1a54		       00		      .byte.b	%00000000
     37  1a55		       66		      .byte.b	%01100110
     38  1a56		       66		      .byte.b	%01100110
     39  1a57		       66		      .byte.b	%01100110
     40  1a58		       66		      .byte.b	%01100110
     41  1a59		       00		      .byte.b	%00000000
     42  1a5a		       00		      .byte.b	%00000000	;R
     43  1a5b		       00		      .byte.b	%00000000
     44  1a5c		       66		      .byte.b	%01100110
     45  1a5d		       66		      .byte.b	%01100110
     46  1a5e		       66		      .byte.b	%01100110
     47  1a5f		       66		      .byte.b	%01100110
     48  1a60		       00		      .byte.b	%00000000
     49  1a61		       00		      .byte.b	%00000000	;B
     50  1a62		       00		      .byte.b	%00000000
     51  1a63		       66		      .byte.b	%01100110
     52  1a64		       66		      .byte.b	%01100110
     53  1a65		       66		      .byte.b	%01100110
     54  1a66		       66		      .byte.b	%01100110
     55  1a67		       00		      .byte.b	%00000000
     56  1a68		       00		      .byte.b	%00000000	;G
     57  1a69
      0  1a69					      CHECKPAGE	CHARACTERSHAPE_TARGET2	; since we share one byte!
      8  1a69					      LIST	ON
     59  1a69
     60  1a69					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE Explosion.asm LEVEL 3 PASS 3
      0  1a69					      include	"Explosion.asm"	; 3 * LINES_PER_CHAR bytes
      0  1a69					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_EXPLOSION1", LINES_PER_CHAR
     10  1a69					      LIST	ON
      2  1a69				   CHARACTERSHAPE_EXPLOSION1		; large
      3  1a69				   CHARACTERSHAPE_EXPLOSION1_MIRRORED		; we don't worry about mirrored explosions!
      4  1a69		       44		      .byte.b	%01000100	; R (#3 bright, complementary color)
      5  1a6a		       99		      .byte.b	%10011001
      6  1a6b		       00		      .byte.b	%00000000
      7  1a6c		       99		      .byte.b	%10011001
      8  1a6d		       00		      .byte.b	%00000000
      9  1a6e		       99		      .byte.b	%10011001
     10  1a6f		       22		      .byte.b	%00100010
     11  1a70
     12  1a70		       44		      .byte.b	%01000100	; G (#2 basic dirt color, usually the darkest one)
     13  1a71		       99		      .byte.b	%10011001
     14  1a72		       22		      .byte.b	%00100010
     15  1a73		       dd		      .byte.b	%11011101
     16  1a74		       44		      .byte.b	%01000100
     17  1a75		       99		      .byte.b	%10011001
     18  1a76		       22		      .byte.b	%00100010
     19  1a77
     20  1a77		       44		      .byte.b	%01000100	; B (#1 additional wall/BOX color)
     21  1a78		       99		      .byte.b	%10011001
     22  1a79		       22		      .byte.b	%00100010
     23  1a7a		       bb		      .byte.b	%10111011
     24  1a7b		       44		      .byte.b	%01000100
     25  1a7c		       99		      .byte.b	%10011001
     26  1a7d		       22		      .byte.b	%00100010
     27  1a7e
      0  1a7e					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_EXPLOSION2", LINES_PER_CHAR
     10  1a7e					      LIST	ON
     29  1a7e				   CHARACTERSHAPE_EXPLOSION2		; medium
     30  1a7e				   CHARACTERSHAPE_EXPLOSION2_MIRRORED		; we don't worry about mirrored explosions!
     31  1a7e		       00		      .byte.b	%00000000	; R
     32  1a7f		       22		      .byte.b	%00100010
     33  1a80		       88		      .byte.b	%10001000
     34  1a81		       66		      .byte.b	%01100110
     35  1a82		       11		      .byte.b	%00010001
     36  1a83		       44		      .byte.b	%01000100
     37  1a84		       00		      .byte.b	%00000000
     38  1a85
     39  1a85		       00		      .byte.b	%00000000	; G
     40  1a86		       22		      .byte.b	%00100010
     41  1a87		       99		      .byte.b	%10011001
     42  1a88		       66		      .byte.b	%01100110
     43  1a89		       99		      .byte.b	%10011001
     44  1a8a		       44		      .byte.b	%01000100
     45  1a8b		       00		      .byte.b	%00000000
     46  1a8c
     47  1a8c		       00		      .byte.b	%00000000	; B
     48  1a8d		       22		      .byte.b	%00100010
     49  1a8e		       99		      .byte.b	%10011001
     50  1a8f		       66		      .byte.b	%01100110
     51  1a90		       99		      .byte.b	%10011001
     52  1a91		       44		      .byte.b	%01000100
     53  1a92							; .byte %00000000
     54  1a92
     55  1a92							;    OPTIONAL_PAGEBREAK "CHARACTERSHAPE_EXPLOSION3", LINES_PER_CHAR
     56  1a92				   CHARACTERSHAPE_EXPLOSION3		; small
     57  1a92				   CHARACTERSHAPE_EXPLOSION3_MIRRORED		; we don't worry about mirrored explosions!
     58  1a92		       00		      .byte.b	%00000000	; R
     59  1a93		       00		      .byte.b	%00000000
     60  1a94		       44		      .byte.b	%01000100
     61  1a95		       00		      .byte.b	%00000000
     62  1a96		       22		      .byte.b	%00100010
     63  1a97		       00		      .byte.b	%00000000
     64  1a98		       00		      .byte.b	%00000000
     65  1a99
     66  1a99		       00		      .byte.b	%00000000	; G
     67  1a9a		       00		      .byte.b	%00000000
     68  1a9b		       44		      .byte.b	%01000100
     69  1a9c		       00		      .byte.b	%00000000
     70  1a9d		       22		      .byte.b	%00100010
     71  1a9e		       00		      .byte.b	%00000000
     72  1a9f		       00		      .byte.b	%00000000
     73  1aa0
     74  1aa0		       00		      .byte.b	%00000000	; B
     75  1aa1		       00		      .byte.b	%00000000
     76  1aa2		       44		      .byte.b	%01000100
     77  1aa3		       00		      .byte.b	%00000000
     78  1aa4		       22		      .byte.b	%00100010
     79  1aa5		       00		      .byte.b	%00000000
     80  1aa6		       00		      .byte.b	%00000000
     81  1aa7
      0  1aa7					      CHECKPAGE	CHARACTERSHAPE_EXPLOSION2	; since we share one byte!
      8  1aa7					      LIST	ON
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    466  1aa7
    467  1aa7
      0  1aa7					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  1aa7					      LIST	ON
    469  1aa7
    470  1aa7		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,$0	; character bitmap row (10 chars wide)
    471  1aa7		       f2 a7	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    472  1aa7		       f2 ae	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    473  1aa7		       f2 b5	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    474  1afb
      0  1afb					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  1afb					      LIST	ON
    476  1afb
    477  1afb							;--------------------------------------------------------------------------
    478  1afb							;    CHARACTER_SET
    479  1afb
    480  1afb							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    481  1afb
    482  1afb
      0  1afb					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  1afb		       00 03	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  1afb					      SUBROUTINE
      3  1afb				   SelfModDrawPlayers
    484  1afb
    485  1afb							; Now the player(s) have animated, update the appropriate shape pointers
    486  1afb							; in the draw code.
    487  1afb
    488  1afb							; Sets the shapes to a blank player -- effectively erasing
    489  1afb		       a5 ae		      lda	LastSpriteY
    490  1afd		       a2 25		      ldx	#<PLAYER_BLANK
    491  1aff		       20 0e f3 	      jsr	SetSelfModPlayer
    492  1b02
    493  1b02							; Now we've erased, we write the new shape
    494  1b02
    495  1b02							;		  sec
    496  1b02							;		  lda ManDrawX
    497  1b02							;		  sbc BoardScrollX
    498  1b02							;		  cmp #SCREEN_WIDTH			  ; disabled because we assume always onscreen
    499  1b02							;		  bcs NoMod				  ; skip if off visible screen
    500  1b02
    501  1b02		       a5 9b		      lda	ManDrawX
    502  1b04		       c9 0a		      cmp	#SCREEN_WIDTH	; disabled because we assume always onscreen
    503  1b06		       b0 1c		      bcs	NoMod	; skip if off visible screen
    504  1b08
    505  1b08							;lda LookingAround
    506  1b08							;bne NoMod
    507  1b08
    508  1b08		       a5 9c		      lda	ManDrawY
    509  1b0a		       85 ae		      sta	LastSpriteY
    510  1b0c
    511  1b0c		       a6 a1		      ldx	ManAnimationFrameLO
    512  1b0e
    513  1b0e				   SetSelfModPlayer
    514  1b0e		       c9 08		      cmp	#SCREEN_LINES	; only erase/draw if was/is onscreen
    515  1b10		       b0 12		      bcs	NoMod
    516  1b12		       69 00		      adc	#BANK_SCREENMARKII1
    517  1b14		       85 3e		      sta	SET_BANK_RAM	; switch old/new bank in
    518  1b16
    519  1b16		       8a		      txa
    520  1b17		       8d 20 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1	; lo of frame
    521  1b1a		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    522  1b1c		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    523  1b1f		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    524  1b21		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    525  1b24
    526  1b24				   NoMod
    527  1b24		       60		      rts
    528  1b25
    529  1b25							;include "Magic_Wall.asm"	; 3 * LINES_PER_CHAR bytes
    530  1b25
      0  1b25					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  1b25
      2  1b25
      3  1b25		       03 25	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $325 , FREE= $db
      4  1b25					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1b25				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1b25				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1b25				  -	      ERR
      8  1b25					      endif
    532  1b25
------- FILE player.asm LEVEL 3 PASS 3
      0  1b25					      include	"player.asm"	; 6 * LINES_PER_CHAR	       MUST FOLLOW DIRT.ASM as data is shared
      1  1b25							;    OPTIONAL_PAGEBREAK "PLAYER", LINES_PER_CHAR * 6 - 1
      2  1b25
      3  1b25
      4  1b25		       f3 25	   PLAYER_BLANK =	.	; MUST APPEAR AT TOP AS DATA SHARED BY DIRT
      5  1b25					      REPEAT	LINES_PER_CHAR	;-1  ; as we have a "0" in the line below
      6  1b25		       00		      .byte.b	0
      5  1b25					      REPEND
      6  1b26		       00		      .byte.b	0
      5  1b26					      REPEND
      6  1b27		       00		      .byte.b	0
      5  1b27					      REPEND
      6  1b28		       00		      .byte.b	0
      5  1b28					      REPEND
      6  1b29		       00		      .byte.b	0
      5  1b29					      REPEND
      6  1b2a		       00		      .byte.b	0
      5  1b2a					      REPEND
      6  1b2b		       00		      .byte.b	0
      5  1b2b					      REPEND
      6  1b2c		       00		      .byte.b	0
      5  1b2c					      REPEND
      6  1b2d		       00		      .byte.b	0
      5  1b2d					      REPEND
      6  1b2e		       00		      .byte.b	0
      5  1b2e					      REPEND
      6  1b2f		       00		      .byte.b	0
      5  1b2f					      REPEND
      6  1b30		       00		      .byte.b	0
      5  1b30					      REPEND
      6  1b31		       00		      .byte.b	0
      5  1b31					      REPEND
      6  1b32		       00		      .byte.b	0
      5  1b32					      REPEND
      6  1b33		       00		      .byte.b	0
      5  1b33					      REPEND
      6  1b34		       00		      .byte.b	0
      5  1b34					      REPEND
      6  1b35		       00		      .byte.b	0
      5  1b35					      REPEND
      6  1b36		       00		      .byte.b	0
      5  1b36					      REPEND
      6  1b37		       00		      .byte.b	0
      5  1b37					      REPEND
      6  1b38		       00		      .byte.b	0
      5  1b38					      REPEND
      6  1b39		       00		      .byte.b	0
      7  1b3a					      REPEND
      8  1b3a
      9  1b3a				   PLAYER_RIGHT0
     10  1b3a							;  X XX
     11  1b3a							;  XXXX
     12  1b3a							;  XXX
     13  1b3a							;  XXX
     14  1b3a							;   XX
     15  1b3a							;   XX
     16  1b3a							;   XX
     17  1b3a							;   XX
     18  1b3a							;   XXX
     19  1b3a							;   XXX
     20  1b3a							;   XX
     21  1b3a							;   XX
     22  1b3a							;   XX
     23  1b3a							;   XX
     24  1b3a							;  XXXX
     25  1b3a							;  XXX X
     26  1b3a							;  XXX X
     27  1b3a							;  XXX X
     28  1b3a							;  XXXX
     29  1b3a							;   XX
     30  1b3a							;
     31  1b3a							;---Graphics Data from PlayerPal 2600---
     32  1b3a
     33  1b3a
     34  1b3a					      if	1
     35  1b3a		       18		      .byte.b	%00011000	;20
     36  1b3b		       18		      .byte.b	%00011000	;20
     37  1b3c		       7e		      .byte.b	%01111110	;20
     38  1b3d		       7e		      .byte.b	%01111110	;20
     39  1b3e		       7e		      .byte.b	%01111110	;20
     40  1b3f		       18		      .byte.b	%00011000	;20
     41  1b40		       18		      .byte.b	%00011000	;20
     42  1b41
     43  1b41		       18		      .byte.b	%00011000	;20
     44  1b42		       18		      .byte.b	%00011000	;20
     45  1b43		       7e		      .byte.b	%01111110	;20
     46  1b44		       7e		      .byte.b	%01111110	;20
     47  1b45		       7e		      .byte.b	%01111110	;20
     48  1b46		       18		      .byte.b	%00011000	;20
     49  1b47		       18		      .byte.b	%00011000	;20
     50  1b48
     51  1b48		       18		      .byte.b	%00011000	;20
     52  1b49		       18		      .byte.b	%00011000	;20
     53  1b4a		       7e		      .byte.b	%01111110	;20
     54  1b4b		       7e		      .byte.b	%01111110	;20
     55  1b4c		       7e		      .byte.b	%01111110	;20
     56  1b4d		       18		      .byte.b	%00011000	;20
     57  1b4e		       18		      .byte.b	%00011000	;20
     58  1b4f
     59  1b4f				  -	      else
     60  1b4f				  -			;push
     61  1b4f				  -	      .byte	#%01110000	;$1C 0
     62  1b4f				  -	      .byte	#%01110000	;$78 3
     63  1b4f				  -	      .byte	#%00010000	;$52 6
     64  1b4f				  -	      .byte	#%00111100	;$52 9
     65  1b4f				  -	      .byte	#%00011001	;$0C 12
     66  1b4f				  -	      .byte	#%00001100	;$4A 15
     67  1b4f				  -	      .byte	#%00001111	;$1A18
     68  1b4f				  -
     69  1b4f				  -	      .byte	#%10100000	;$1C 1
     70  1b4f				  -	      .byte	#%00111000	;$78 4
     71  1b4f				  -	      .byte	#%00111000	;$52 7
     72  1b4f				  -	      .byte	#%00111100	;$56 10
     73  1b4f				  -	      .byte	#%00001000	;$4A 13
     74  1b4f				  -	      .byte	#%00001100	;$4A 16
     75  1b4f				  -	      .byte	#%00001100	;$1C 19
     76  1b4f				  -
     77  1b4f				  -	      .byte	#%11010000	;$78 2
     78  1b4f				  -	      .byte	#%00101000	;$78 5
     79  1b4f				  -	      .byte	#%00111000	;$52 8
     80  1b4f				  -	      .byte	#%00011111	;$56 11
     81  1b4f				  -	      .byte	#%00001000	;$4A 14
     82  1b4f				  -	      .byte	#%00011010	;$4A 17
     83  1b4f				  -	      .byte	#%00001100	;$1C 20
     84  1b4f				  -
     85  1b4f					      endif
     86  1b4f
     87  1b4f				  -	      IF	0
     88  1b4f				  -			;---Graphics Data from PlayerPal 2600---
     89  1b4f				  -
     90  1b4f				  -Frame0
     91  1b4f				  -	      .byte	#%01110011	;$1C
     92  1b4f				  -	      .byte	#%00100110	;$1C
     93  1b4f				  -	      .byte	#%00110100	;$78
     94  1b4f				  -	      .byte	#%00010100	;$78
     95  1b4f				  -	      .byte	#%00011100	;$78
     96  1b4f				  -	      .byte	#%00001000	;$78
     97  1b4f				  -	      .byte	#%00010000	;$52
     98  1b4f				  -	      .byte	#%00111000	;$52
     99  1b4f				  -	      .byte	#%00111000	;$52
    100  1b4f				  -	      .byte	#%10111000	;$52
    101  1b4f				  -	      .byte	#%01111000	;$56
    102  1b4f				  -	      .byte	#%00110000	;$56
    103  1b4f				  -	      .byte	#%00111100	;$0C
    104  1b4f				  -	      .byte	#%00110010	;$4A
    105  1b4f				  -	      .byte	#%00010000	;$4A
    106  1b4f				  -	      .byte	#%00011000	;$4A
    107  1b4f				  -	      .byte	#%00011000	;$4A
    108  1b4f				  -	      .byte	#%00110100	;$4A
    109  1b4f				  -	      .byte	#%00011110	;$1A
    110  1b4f				  -	      .byte	#%00011000	;$1C
    111  1b4f				  -	      .byte	#%00011000	;$1C
    112  1b4f				  -Frame1
    113  1b4f				  -	      .byte	#%00110110	;$1C
    114  1b4f				  -	      .byte	#%00100100	;$1C
    115  1b4f				  -	      .byte	#%00010100	;$78
    116  1b4f				  -	      .byte	#%00010100	;$78
    117  1b4f				  -	      .byte	#%00011100	;$78
    118  1b4f				  -	      .byte	#%00001000	;$78
    119  1b4f				  -	      .byte	#%00010000	;$52
    120  1b4f				  -	      .byte	#%00111000	;$52
    121  1b4f				  -	      .byte	#%00011000	;$52
    122  1b4f				  -	      .byte	#%01111000	;$52
    123  1b4f				  -	      .byte	#%00111000	;$56
    124  1b4f				  -	      .byte	#%00110110	;$56
    125  1b4f				  -	      .byte	#%00111100	;$0C
    126  1b4f				  -	      .byte	#%00010000	;$4A
    127  1b4f				  -	      .byte	#%00010000	;$4A
    128  1b4f				  -	      .byte	#%00011000	;$4A
    129  1b4f				  -	      .byte	#%00011000	;$4A
    130  1b4f				  -	      .byte	#%00110100	;$4A
    131  1b4f				  -	      .byte	#%00011110	;$1A
    132  1b4f				  -	      .byte	#%00011000	;$1C
    133  1b4f				  -	      .byte	#%00011000	;$1C
    134  1b4f				  -Frame2
    135  1b4f				  -	      .byte	#%00011000	;$1C
    136  1b4f				  -	      .byte	#%00110000	;$1C
    137  1b4f				  -	      .byte	#%01010000	;$78
    138  1b4f				  -	      .byte	#%00111000	;$78
    139  1b4f				  -	      .byte	#%00011000	;$78
    140  1b4f				  -	      .byte	#%00001000	;$78
    141  1b4f				  -	      .byte	#%00010000	;$52
    142  1b4f				  -	      .byte	#%00111000	;$52
    143  1b4f				  -	      .byte	#%00111000	;$52
    144  1b4f				  -	      .byte	#%00111100	;$52
    145  1b4f				  -	      .byte	#%00110100	;$56
    146  1b4f				  -	      .byte	#%00111100	;$56
    147  1b4f				  -	      .byte	#%00111000	;$0C
    148  1b4f				  -	      .byte	#%00010000	;$4A
    149  1b4f				  -	      .byte	#%00010000	;$4A
    150  1b4f				  -	      .byte	#%00011000	;$4A
    151  1b4f				  -	      .byte	#%00011000	;$4A
    152  1b4f				  -	      .byte	#%00110100	;$4A
    153  1b4f				  -	      .byte	#%00011110	;$1A
    154  1b4f				  -	      .byte	#%00011000	;$1C
    155  1b4f				  -	      .byte	#%00011000	;$1C
    156  1b4f				  -Frame3
    157  1b4f				  -	      .byte	#%01110000	;$1C
    158  1b4f				  -	      .byte	#%10100000	;$1C
    159  1b4f				  -	      .byte	#%11010000	;$78
    160  1b4f				  -	      .byte	#%01110000	;$78
    161  1b4f				  -	      .byte	#%00111000	;$78
    162  1b4f				  -	      .byte	#%00101000	;$78
    163  1b4f				  -	      .byte	#%00010000	;$52
    164  1b4f				  -	      .byte	#%00111000	;$52
    165  1b4f				  -	      .byte	#%00111000	;$52
    166  1b4f				  -	      .byte	#%00111100	;$52
    167  1b4f				  -	      .byte	#%00111100	;$56
    168  1b4f				  -	      .byte	#%00011111	;$56
    169  1b4f				  -	      .byte	#%00011001	;$0C
    170  1b4f				  -	      .byte	#%00001000	;$4A
    171  1b4f				  -	      .byte	#%00001000	;$4A
    172  1b4f				  -	      .byte	#%00001100	;$4A
    173  1b4f				  -	      .byte	#%00001100	;$4A
    174  1b4f				  -	      .byte	#%00011010	;$4A
    175  1b4f				  -	      .byte	#%00001111	;$1A
    176  1b4f				  -	      .byte	#%00001100	;$1C
    177  1b4f				  -	      .byte	#%00001100	;$1C
    178  1b4f				  -Frame4
    179  1b4f				  -	      .byte	#%00110110	;$1C
    180  1b4f				  -	      .byte	#%00010100	;$1C
    181  1b4f				  -	      .byte	#%00010100	;$78
    182  1b4f				  -	      .byte	#%00010100	;$78
    183  1b4f				  -	      .byte	#%00011100	;$78
    184  1b4f				  -	      .byte	#%00001100	;$78
    185  1b4f				  -	      .byte	#%00010000	;$52
    186  1b4f				  -	      .byte	#%00011000	;$52
    187  1b4f				  -	      .byte	#%00011100	;$52
    188  1b4f				  -	      .byte	#%00111100	;$52
    189  1b4f				  -	      .byte	#%00111100	;$56
    190  1b4f				  -	      .byte	#%00111100	;$56
    191  1b4f				  -	      .byte	#%00111110	;$0C
    192  1b4f				  -	      .byte	#%01011010	;$4A
    193  1b4f				  -	      .byte	#%10010001	;$4A
    194  1b4f				  -	      .byte	#%10011001	;$4A
    195  1b4f				  -	      .byte	#%00011000	;$4A
    196  1b4f				  -	      .byte	#%00011000	;$4A
    197  1b4f				  -	      .byte	#%00011100	;$1A
    198  1b4f				  -	      .byte	#%00011000	;$1C
    199  1b4f				  -	      .byte	#%00010000	;$1C
    200  1b4f				  -Frame5
    201  1b4f				  -	      .byte	#%00110110	;$1C
    202  1b4f				  -	      .byte	#%00010100	;$1C
    203  1b4f				  -	      .byte	#%00010100	;$78
    204  1b4f				  -	      .byte	#%00010100	;$78
    205  1b4f				  -	      .byte	#%00011100	;$78
    206  1b4f				  -	      .byte	#%01001101	;$78
    207  1b4f				  -	      .byte	#%01010001	;$52
    208  1b4f				  -	      .byte	#%01011011	;$52
    209  1b4f				  -	      .byte	#%01011110	;$52
    210  1b4f				  -	      .byte	#%00111100	;$52
    211  1b4f				  -	      .byte	#%00111100	;$56
    212  1b4f				  -	      .byte	#%00011100	;$56
    213  1b4f				  -	      .byte	#%00011000	;$0C
    214  1b4f				  -	      .byte	#%00011000	;$4A
    215  1b4f				  -	      .byte	#%00011000	;$4A
    216  1b4f				  -	      .byte	#%00111000	;$4A
    217  1b4f				  -	      .byte	#%00001000	;$4A
    218  1b4f				  -	      .byte	#%00000000	;$4A
    219  1b4f				  -	      .byte	#%00000000	;$1A
    220  1b4f				  -	      .byte	#%00000000	;$1C
    221  1b4f				  -	      .byte	#%00000000	;$1C
    222  1b4f				  -			;---End Graphics Data---
    223  1b4f				  -
    224  1b4f				  -
    225  1b4f				  -			;---Color Data from PlayerPal 2600---
    226  1b4f				  -
    227  1b4f				  -ColorFrame0
    228  1b4f				  -	      .byte	#$1C	;
    229  1b4f				  -	      .byte	#$1C	;
    230  1b4f				  -	      .byte	#$78	;
    231  1b4f				  -	      .byte	#$78	;
    232  1b4f				  -	      .byte	#$78	;
    233  1b4f				  -	      .byte	#$78	;
    234  1b4f				  -	      .byte	#$52	;
    235  1b4f				  -	      .byte	#$52	;
    236  1b4f				  -	      .byte	#$52	;
    237  1b4f				  -	      .byte	#$52	;
    238  1b4f				  -	      .byte	#$56	;
    239  1b4f				  -	      .byte	#$56	;
    240  1b4f				  -	      .byte	#$0C	;
    241  1b4f				  -	      .byte	#$4A	;
    242  1b4f				  -	      .byte	#$4A	;
    243  1b4f				  -	      .byte	#$4A	;
    244  1b4f				  -	      .byte	#$4A	;
    245  1b4f				  -	      .byte	#$4A	;
    246  1b4f				  -	      .byte	#$1A	;
    247  1b4f				  -	      .byte	#$1C	;
    248  1b4f				  -	      .byte	#$1C	;
    249  1b4f				  -ColorFrame1
    250  1b4f				  -	      .byte	#$1C	;
    251  1b4f				  -	      .byte	#$1C	;
    252  1b4f				  -	      .byte	#$78	;
    253  1b4f				  -	      .byte	#$78	;
    254  1b4f				  -	      .byte	#$78	;
    255  1b4f				  -	      .byte	#$78	;
    256  1b4f				  -	      .byte	#$52	;
    257  1b4f				  -	      .byte	#$52	;
    258  1b4f				  -	      .byte	#$52	;
    259  1b4f				  -	      .byte	#$52	;
    260  1b4f				  -	      .byte	#$56	;
    261  1b4f				  -	      .byte	#$56	;
    262  1b4f				  -	      .byte	#$0C	;
    263  1b4f				  -	      .byte	#$4A	;
    264  1b4f				  -	      .byte	#$4A	;
    265  1b4f				  -	      .byte	#$4A	;
    266  1b4f				  -	      .byte	#$4A	;
    267  1b4f				  -	      .byte	#$4A	;
    268  1b4f				  -	      .byte	#$1A	;
    269  1b4f				  -	      .byte	#$1C	;
    270  1b4f				  -	      .byte	#$1C	;
    271  1b4f				  -ColorFrame2
    272  1b4f				  -	      .byte	#$1C	;
    273  1b4f				  -	      .byte	#$1C	;
    274  1b4f				  -	      .byte	#$78	;
    275  1b4f				  -	      .byte	#$78	;
    276  1b4f				  -	      .byte	#$78	;
    277  1b4f				  -	      .byte	#$78	;
    278  1b4f				  -	      .byte	#$52	;
    279  1b4f				  -	      .byte	#$52	;
    280  1b4f				  -	      .byte	#$52	;
    281  1b4f				  -	      .byte	#$52	;
    282  1b4f				  -	      .byte	#$56	;
    283  1b4f				  -	      .byte	#$56	;
    284  1b4f				  -	      .byte	#$0C	;
    285  1b4f				  -	      .byte	#$4A	;
    286  1b4f				  -	      .byte	#$4A	;
    287  1b4f				  -	      .byte	#$4A	;
    288  1b4f				  -	      .byte	#$4A	;
    289  1b4f				  -	      .byte	#$4A	;
    290  1b4f				  -	      .byte	#$1A	;
    291  1b4f				  -	      .byte	#$1C	;
    292  1b4f				  -	      .byte	#$1C	;
    293  1b4f				  -ColorFrame3
    294  1b4f				  -	      .byte	#$1C	;
    295  1b4f				  -	      .byte	#$1C	;
    296  1b4f				  -	      .byte	#$78	;
    297  1b4f				  -	      .byte	#$78	;
    298  1b4f				  -	      .byte	#$78	;
    299  1b4f				  -	      .byte	#$78	;
    300  1b4f				  -	      .byte	#$52	;
    301  1b4f				  -	      .byte	#$52	;
    302  1b4f				  -	      .byte	#$52	;
    303  1b4f				  -	      .byte	#$52	;
    304  1b4f				  -	      .byte	#$56	;
    305  1b4f				  -	      .byte	#$56	;
    306  1b4f				  -	      .byte	#$0C	;
    307  1b4f				  -	      .byte	#$4A	;
    308  1b4f				  -	      .byte	#$4A	;
    309  1b4f				  -	      .byte	#$4A	;
    310  1b4f				  -	      .byte	#$4A	;
    311  1b4f				  -	      .byte	#$4A	;
    312  1b4f				  -	      .byte	#$1A	;
    313  1b4f				  -	      .byte	#$1C	;
    314  1b4f				  -	      .byte	#$1C	;
    315  1b4f				  -ColorFrame4
    316  1b4f				  -	      .byte	#$1C	;
    317  1b4f				  -	      .byte	#$1C	;
    318  1b4f				  -	      .byte	#$78	;
    319  1b4f				  -	      .byte	#$78	;
    320  1b4f				  -	      .byte	#$78	;
    321  1b4f				  -	      .byte	#$78	;
    322  1b4f				  -	      .byte	#$52	;
    323  1b4f				  -	      .byte	#$52	;
    324  1b4f				  -	      .byte	#$52	;
    325  1b4f				  -	      .byte	#$52	;
    326  1b4f				  -	      .byte	#$56	;
    327  1b4f				  -	      .byte	#$56	;
    328  1b4f				  -	      .byte	#$0C	;
    329  1b4f				  -	      .byte	#$4A	;
    330  1b4f				  -	      .byte	#$4A	;
    331  1b4f				  -	      .byte	#$4A	;
    332  1b4f				  -	      .byte	#$4A	;
    333  1b4f				  -	      .byte	#$4A	;
    334  1b4f				  -	      .byte	#$1A	;
    335  1b4f				  -	      .byte	#$1C	;
    336  1b4f				  -	      .byte	#$1C	;
    337  1b4f				  -ColorFrame5
    338  1b4f				  -	      .byte	#$1C	;
    339  1b4f				  -	      .byte	#$1C	;
    340  1b4f				  -	      .byte	#$78	;
    341  1b4f				  -	      .byte	#$78	;
    342  1b4f				  -	      .byte	#$78	;
    343  1b4f				  -	      .byte	#$78	;
    344  1b4f				  -	      .byte	#$52	;
    345  1b4f				  -	      .byte	#$52	;
    346  1b4f				  -	      .byte	#$52	;
    347  1b4f				  -	      .byte	#$52	;
    348  1b4f				  -	      .byte	#$56	;
    349  1b4f				  -	      .byte	#$56	;
    350  1b4f				  -	      .byte	#$0C	;
    351  1b4f				  -	      .byte	#$4A	;
    352  1b4f				  -	      .byte	#$4A	;
    353  1b4f				  -	      .byte	#$4A	;
    354  1b4f				  -	      .byte	#$4A	;
    355  1b4f				  -	      .byte	#$4A	;
    356  1b4f				  -	      .byte	#$1A	;
    357  1b4f				  -	      .byte	#$1C	;
    358  1b4f				  -	      .byte	#$1C	;
    359  1b4f				  -			;---End Color Data---
    360  1b4f					      ENDIF
    361  1b4f
    362  1b4f
    363  1b4f							;.byte %00011000  ;  XXX   ; 0
    364  1b4f							;.byte %00111100  ;XXXXXX  ; 1
    365  1b4f							;.byte %01110100  ;XXXX X  ; 2 etc.
    366  1b4f							;.byte %01111100  ;XXXXXX  ; 3
    367  1b4f							;.byte %00111000  ;XXXXX   ;4
    368  1b4f							;.byte %01111100  ; XXXXX  ;5
    369  1b4f							;.byte %00111000  ;  XXX   ;6
    370  1b4f							;.byte %11111000  ;XXXXX   ;7
    371  1b4f							;.byte %11111100  ;XXXXXX  ;8
    372  1b4f							;.byte %11111100  ;XXXXXX  ;9 etc.
    373  1b4f							;.byte %10000100  ;X	 X  ;10
    374  1b4f							;.byte %11111100  ;XXXXXX  ;11
    375  1b4f							;.byte %00001100  ;	XX  ;12
    376  1b4f							;.byte %01111100  ; XXXXX  ;13
    377  1b4f							;.byte %01111100  ; XXXXX  ;14
    378  1b4f							;.byte %01111000  ; XXXX   ;15
    379  1b4f							;.byte %01111000  ; XXXX   ;16 etc.
    380  1b4f							;.byte %11111000  ;XXXXX   ;17
    381  1b4f							;.byte %11101100  ;XXX XX  ;18
    382  1b4f							;.byte %10111100  ;X XXXX  ;19
    383  1b4f							;.byte %11001100  ;XX	XX   20
    384  1b4f
    385  1b4f							;---Graphics Data from PlayerPal 2600---
    386  1b4f
    387  1b4f
    388  1b4f		       18		      .byte.b	%00011000	;20
    389  1b50		       18		      .byte.b	%00011000	;20
    390  1b51		       7e		      .byte.b	%01111110	;20
    391  1b52		       7e		      .byte.b	%01111110	;20
    392  1b53		       7e		      .byte.b	%01111110	;20
    393  1b54		       18		      .byte.b	%00011000	;20
    394  1b55		       18		      .byte.b	%00011000	;20
    395  1b56
    396  1b56		       18		      .byte.b	%00011000	;20
    397  1b57		       18		      .byte.b	%00011000	;20
    398  1b58		       7e		      .byte.b	%01111110	;20
    399  1b59		       7e		      .byte.b	%01111110	;20
    400  1b5a		       7e		      .byte.b	%01111110	;20
    401  1b5b		       18		      .byte.b	%00011000	;20
    402  1b5c		       18		      .byte.b	%00011000	;20
    403  1b5d
    404  1b5d		       18		      .byte.b	%00011000	;20
    405  1b5e		       18		      .byte.b	%00011000	;20
    406  1b5f		       7e		      .byte.b	%01111110	;20
    407  1b60		       7e		      .byte.b	%01111110	;20
    408  1b61		       7e		      .byte.b	%01111110	;20
    409  1b62		       18		      .byte.b	%00011000	;20
    410  1b63		       18		      .byte.b	%00011000	;20
    411  1b64
    412  1b64							;		  .byte %11111111 ; 0
    413  1b64							;		  .byte %11111111 ; 3
    414  1b64							;		  .byte %11111111 ; 6 etc.
    415  1b64							;		  .byte %11111111
    416  1b64							;		  .byte %11111111
    417  1b64							;		  .byte %11111111
    418  1b64							;		  .byte %11111110
    419  1b64
    420  1b64							;		  .byte %11111111 ; 1
    421  1b64							;		  .byte %11111111 ; 4 etc.
    422  1b64							;		  .byte %11111111
    423  1b64							;		  .byte %11111111
    424  1b64							;		  .byte %11111111
    425  1b64							;		  .byte %11111111
    426  1b64							;		  .byte %01110100
    427  1b64
    428  1b64							;		  .byte %11111111 ; 2
    429  1b64							;		  .byte %11111111 ; 5 etc.
    430  1b64							;		  .byte %11111111
    431  1b64							;		  .byte %11111111
    432  1b64							;		  .byte %11111100
    433  1b64							;		  .byte %00111000
    434  1b64							;		  .byte 0
    435  1b64
    436  1b64				   PLAYER_RIGHT1
    437  1b64
    438  1b64					      IF	1 = 1
    439  1b64							; X?	 XX
    440  1b64							; X	 X
    441  1b64							; X	 X
    442  1b64							; XX	XX
    443  1b64							;  XXXXX
    444  1b64							;     XX
    445  1b64							;     XX
    446  1b64							;     XX
    447  1b64							;     XXX
    448  1b64							;     XXX
    449  1b64							;     XX
    450  1b64							;     XX
    451  1b64							;     XX
    452  1b64							;     XX
    453  1b64							;    XXXX
    454  1b64							;    XXX X
    455  1b64							;    XXX X
    456  1b64							;    XXX X
    457  1b64							;    XXXX
    458  1b64							;     XX
    459  1b64
    460  1b64		       43		      .byte.b	%01000011	; 0
    461  1b65		       66		      .byte.b	%01100110	; 3
    462  1b66		       18		      .byte.b	%00011000	; 6 etc.
    463  1b67		       1c		      .byte.b	%00011100
    464  1b68		       18		      .byte.b	%00011000
    465  1b69		       3a		      .byte.b	%00111010
    466  1b6a		       3c		      .byte.b	%00111100
    467  1b6b
    468  1b6b		       42		      .byte.b	%01000010	; 1
    469  1b6c		       3c		      .byte.b	%00111100	; 4 etc.
    470  1b6d		       18		      .byte.b	%00011000
    471  1b6e		       18		      .byte.b	%00011000
    472  1b6f		       18		      .byte.b	%00011000
    473  1b70		       3a		      .byte.b	%00111010
    474  1b71		       18		      .byte.b	%00011000
    475  1b72
    476  1b72		       42		      .byte.b	%01000010	; 2
    477  1b73		       18		      .byte.b	%00011000	; 5 etc.
    478  1b74		       1c		      .byte.b	%00011100
    479  1b75		       18		      .byte.b	%00011000
    480  1b76		       3c		      .byte.b	%00111100
    481  1b77		       3a		      .byte.b	%00111010
    482  1b78		       00		      .byte.b	0
    483  1b79				  -	      ELSE
    484  1b79				  -			; Alternativly make his neck pixel shorter here.
    485  1b79				  -			; This looks more dynamic, but shows a problems with the hair color.
    486  1b79				  -			; Maybe if we remove the t-shirt/trousers color look and make him
    487  1b79				  -			; look more like an insect (which he acutally is), we can fix this.
    488  1b79				  -
    489  1b79				  -			; X?	 XX
    490  1b79				  -			; X	 X
    491  1b79				  -			; X	 X
    492  1b79				  -			; XX	XX
    493  1b79				  -			;  XXXXX
    494  1b79				  -			;     XX
    495  1b79				  -			;     XX
    496  1b79				  -			;     XX
    497  1b79				  -			;     XXX
    498  1b79				  -			;     XXX
    499  1b79				  -			;     XX
    500  1b79				  -			;     XX
    501  1b79				  -			;     XX
    502  1b79				  -			;    XXXX
    503  1b79				  -			;    XXX X
    504  1b79				  -			;    XXX X
    505  1b79				  -			;    XXX X
    506  1b79				  -			;    XXXX
    507  1b79				  -			;     XX
    508  1b79				  -
    509  1b79				  -	      .byte	%01000011	; 0
    510  1b79				  -	      .byte	%01100110	; 3
    511  1b79				  -	      .byte	%00011000	; 6 etc.
    512  1b79				  -	      .byte	%00011100
    513  1b79				  -	      .byte	%00011000
    514  1b79				  -	      .byte	%00111010
    515  1b79				  -	      .byte	%00011000
    516  1b79				  -
    517  1b79				  -	      .byte	%01000010	; 1
    518  1b79				  -	      .byte	%00111100	; 4 etc.
    519  1b79				  -	      .byte	%00011000
    520  1b79				  -	      .byte	%00011000
    521  1b79				  -	      .byte	%00111100
    522  1b79				  -	      .byte	%00111010
    523  1b79				  -	      .byte	0
    524  1b79				  -
    525  1b79				  -	      .byte	%01000010	; 2
    526  1b79				  -	      .byte	%00011000	; 5 etc.
    527  1b79				  -	      .byte	%00011100
    528  1b79				  -	      .byte	%00011000
    529  1b79				  -	      .byte	%00111010
    530  1b79				  -	      .byte	%00111100
    531  1b79				  -	      .byte	0
    532  1b79					      ENDIF
    533  1b79
    534  1b79							;------------------------------------------------------------------------------
    535  1b79
    536  1b79							; NOTE: PLAYER SHAPES ARE *NOT* RGB
    537  1b79							; THEY ARE JUST REORDERED THIS WAY FOR THE KERNEL
    538  1b79
    539  1b79				   PLAYER_STAND
    540  1b79							; original 15 pixel tall, ours was 18 pixel, stretched to 20 now
    541  1b79							; this makes Rockford looks closer to original, slimmer and less fat
    542  1b79							; also BOX/diamonds above his head look less levitating now
    543  1b79
    544  1b79							; XX  XX    XX  XX    XX  XX
    545  1b79							;  X  X      X  X	X  X
    546  1b79							;  X  X      X  X	X  X
    547  1b79							;  XXXX      X  X	X  X
    548  1b79							;   XX       XXXX	XXXX
    549  1b79							;   XX        XX	 XX
    550  1b79							; X XX X    X XX X	 XX
    551  1b79							; X XX X    X XX X	 XX
    552  1b79							;  XXXX     X XX X    X XX X
    553  1b79							;   XX       XXXX     X XX X
    554  1b79							;  XXXX       XX      X XX X
    555  1b79							; X XX X      XX	XXXX
    556  1b79							; X XX X     XXXX	 XX
    557  1b79							;  XXXX     X XX X	 XX
    558  1b79							;  X  X     X XX X	XXXX
    559  1b79							;	     X XX X    X XX X
    560  1b79							;	      XXXX     X XX X
    561  1b79							;	      X  X     X XX X
    562  1b79							;			XXXX
    563  1b79							;			X  X
    564  1b79
    565  1b79		       66		      .byte.b	%01100110	; 0
    566  1b7a		       24		      .byte.b	%00100100	; 3
    567  1b7b		       18		      .byte.b	%00011000	; 6 etc.
    568  1b7c		       5a		      .byte.b	%01011010
    569  1b7d		       18		      .byte.b	%00011000
    570  1b7e		       5a		      .byte.b	%01011010
    571  1b7f		       3c		      .byte.b	%00111100
    572  1b80
    573  1b80		       24		      .byte.b	%00100100	; 1
    574  1b81		       3c		      .byte.b	%00111100	; 4 etc.
    575  1b82		       18		      .byte.b	%00011000
    576  1b83		       5a		      .byte.b	%01011010
    577  1b84		       18		      .byte.b	%00011000
    578  1b85		       5a		      .byte.b	%01011010
    579  1b86		       24		      .byte.b	%00100100
    580  1b87
    581  1b87		       24		      .byte.b	%00100100	; 2
    582  1b88		       18		      .byte.b	%00011000	; 5 etc.
    583  1b89		       5a		      .byte.b	%01011010
    584  1b8a		       3c		      .byte.b	%00111100
    585  1b8b		       3c		      .byte.b	%00111100
    586  1b8c		       5a		      .byte.b	%01011010
    587  1b8d		       00		      .byte.b	0
    588  1b8e
    589  1b8e				   PLAYER_BLINK
    590  1b8e							; XX  XX
    591  1b8e							;  X  X
    592  1b8e							;  X  X
    593  1b8e							;  X  X
    594  1b8e							;  XXXX
    595  1b8e							;   XX
    596  1b8e							;   XX
    597  1b8e							;   XX
    598  1b8e							; X XX X
    599  1b8e							; X XX X
    600  1b8e							; X XX X
    601  1b8e							;  XXXX
    602  1b8e							;   XX
    603  1b8e							;   XX
    604  1b8e							;  XXXX
    605  1b8e							; XXXXXX
    606  1b8e							; XXXXXX
    607  1b8e							; XXXXXX
    608  1b8e							;  XXXX
    609  1b8e							;  X  X
    610  1b8e
    611  1b8e		       66		      .byte.b	%01100110	; 0
    612  1b8f		       24		      .byte.b	%00100100	; 3
    613  1b90		       18		      .byte.b	%00011000	; 6 etc.
    614  1b91		       5a		      .byte.b	%01011010
    615  1b92		       18		      .byte.b	%00011000
    616  1b93		       7e		      .byte.b	%01111110
    617  1b94		       3c		      .byte.b	%00111100
    618  1b95
    619  1b95		       24		      .byte.b	%00100100	; 1
    620  1b96		       3c		      .byte.b	%00111100	; 4 etc.
    621  1b97		       18		      .byte.b	%00011000
    622  1b98		       5a		      .byte.b	%01011010
    623  1b99		       18		      .byte.b	%00011000
    624  1b9a		       7e		      .byte.b	%01111110
    625  1b9b		       24		      .byte.b	%00100100
    626  1b9c
    627  1b9c		       24		      .byte.b	%00100100	; 2
    628  1b9d		       18		      .byte.b	%00011000	; 5 etc.
    629  1b9e		       5a		      .byte.b	%01011010
    630  1b9f		       3c		      .byte.b	%00111100
    631  1ba0		       3c		      .byte.b	%00111100
    632  1ba1		       7e		      .byte.b	%01111110
    633  1ba2		       00		      .byte.b	0
    634  1ba3							; 1
    635  1ba3				   PLAYER_TAP0
    636  1ba3							; XX  XX
    637  1ba3							;  X  X
    638  1ba3							;  X  X
    639  1ba3							;  X  X
    640  1ba3							;  XXXX
    641  1ba3							;   XX
    642  1ba3							;   XX
    643  1ba3							;   XX
    644  1ba3							;  XXXX
    645  1ba3							; X XX X
    646  1ba3							; X XX X
    647  1ba3							;  XXXX
    648  1ba3							;   XX
    649  1ba3							;   XX
    650  1ba3							;  XXXX
    651  1ba3							; X XX X
    652  1ba3							; X XX X
    653  1ba3							; X XX X
    654  1ba3							;  XXXX
    655  1ba3							;  X  X
    656  1ba3
    657  1ba3		       66		      .byte.b	%01100110	; 0
    658  1ba4		       24		      .byte.b	%00100100	; 3
    659  1ba5		       18		      .byte.b	%00011000	; 6 etc.
    660  1ba6		       5a		      .byte.b	%01011010
    661  1ba7		       18		      .byte.b	%00011000
    662  1ba8		       5a		      .byte.b	%01011010
    663  1ba9		       3c		      .byte.b	%00111100
    664  1baa
    665  1baa		       24		      .byte.b	%00100100	; 1
    666  1bab		       3c		      .byte.b	%00111100	; 4 etc.
    667  1bac		       18		      .byte.b	%00011000
    668  1bad		       5a		      .byte.b	%01011010
    669  1bae		       18		      .byte.b	%00011000
    670  1baf		       5a		      .byte.b	%01011010
    671  1bb0		       24		      .byte.b	%00100100
    672  1bb1
    673  1bb1		       24		      .byte.b	%00100100	; 2
    674  1bb2		       18		      .byte.b	%00011000	; 5 etc.
    675  1bb3		       3c		      .byte.b	%00111100
    676  1bb4		       3c		      .byte.b	%00111100
    677  1bb5		       3c		      .byte.b	%00111100
    678  1bb6		       5a		      .byte.b	%01011010
    679  1bb7		       00		      .byte.b	0
    680  1bb8
    681  1bb8				   PLAYER_TAP1
    682  1bb8							;     XX
    683  1bb8							; XX  X
    684  1bb8							;  X  X
    685  1bb8							;  X  X
    686  1bb8							;  XXXX
    687  1bb8							;   XX
    688  1bb8							;   XX
    689  1bb8							;   XX
    690  1bb8							;  XXXX
    691  1bb8							; X XX X
    692  1bb8							; X XX X
    693  1bb8							;  XXXX
    694  1bb8							;   XX
    695  1bb8							;   XX
    696  1bb8							;  XXXX
    697  1bb8							; X XX X
    698  1bb8							; X XX X
    699  1bb8							; X XX X
    700  1bb8							;  XXXX
    701  1bb8							;  X  X
    702  1bb8
    703  1bb8		       06		      .byte.b	%00000110	; 0
    704  1bb9		       24		      .byte.b	%00100100	; 3
    705  1bba		       18		      .byte.b	%00011000	; 6 etc.
    706  1bbb		       5a		      .byte.b	%01011010
    707  1bbc		       18		      .byte.b	%00011000
    708  1bbd		       5a		      .byte.b	%01011010
    709  1bbe		       3c		      .byte.b	%00111100
    710  1bbf
    711  1bbf		       64		      .byte.b	%01100100	; 1
    712  1bc0		       3c		      .byte.b	%00111100	; 4 etc.
    713  1bc1		       18		      .byte.b	%00011000
    714  1bc2		       5a		      .byte.b	%01011010
    715  1bc3		       18		      .byte.b	%00011000
    716  1bc4		       5a		      .byte.b	%01011010
    717  1bc5		       24		      .byte.b	%00100100
    718  1bc6
    719  1bc6		       24		      .byte.b	%00100100	; 2
    720  1bc7		       18		      .byte.b	%00011000	; 5 etc.
    721  1bc8		       3c		      .byte.b	%00111100
    722  1bc9		       3c		      .byte.b	%00111100
    723  1bca		       3c		      .byte.b	%00111100
    724  1bcb		       5a		      .byte.b	%01011010
    725  1bcc		       00		      .byte.b	0
    726  1bcd
    727  1bcd							;    CHECKPAGE PLAYER_BLANK
      0  1bcd					      CHECKPAGEX	CHARACTERSHAPE_SOIL, "Rockford in Rockford.asm"	; since we share some 0 bytes!
      9  1bcd					      LIST	ON
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE filler.asm LEVEL 3 PASS 3
      0  1bcd					      include	"filler.asm"	; 2 * LINES_PER_CHAR bytes
      1  1bcd		       00 05	   SOIL_DEF   =	5
      2  1bcd
      3  1bcd							; 3   RELEASED BD1
      4  1bcd							; 4
      5  1bcd							; 5   AD SOLID
      6  1bcd							; 6   AD INVERTED of released version
      7  1bcd
      8  1bcd
      9  1bcd				  -	      if	SOIL_DEF = 0
     10  1bcd				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     11  1bcd				  -CHARACTERSHAPE_SOIL
     12  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     13  1bcd				  -	      .byte	%01110111,%11011101,%11101110,%11011101,%10101010,%01010101,%11101110	;G
     14  1bcd				  -			;  .byte %01010101,%10111011,%11101110,%11011101,%01110111,%11011101,%10101010 ;G
     15  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;B
     16  1bcd				  -
     17  1bcd				  -			;--------------------------------------------------------------------------
     18  1bcd				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     19  1bcd				  -CHARACTERSHAPE_SOIL_MIRRORED
     20  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     21  1bcd				  -	      .byte	%10111011,%11111111,%11011101,%11111111,%01110111,%11111111,%11101110	;G
     22  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00010001,%00000000,%00000000	;B
     23  1bcd					      endif
     24  1bcd
     25  1bcd				  -	      if	SOIL_DEF = 1
     26  1bcd				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     27  1bcd				  -CHARACTERSHAPE_SOIL
     28  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     29  1bcd				  -			;  .byte %01110111,%11011101,%11101110,%11011101,%10101010,%01010101,%11101110 ;G
     30  1bcd				  -	      .byte	%01010101,%10111011,%11101110,%11011101,%01110111,%11011101,%10101010	;G
     31  1bcd				  -	      .byte	%00000000,%00010001,%00000000,%00000000,%01000100,%00000000,%00000000	;B
     32  1bcd				  -
     33  1bcd				  -			;--------------------------------------------------------------------------
     34  1bcd				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     35  1bcd				  -CHARACTERSHAPE_SOIL_MIRRORED
     36  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     37  1bcd				  -	      .byte	%10101010,%11011101,%01110111,%10111011,%11101110,%10111011,%01010101	;G
     38  1bcd				  -	      .byte	%00000000,%10001000,%00000000,%00000000,%00100010,%00000000,%00000000	;B
     39  1bcd				  -			; .byte %10111011,%11111111,%11011101,%11111111,%01110111,%11111111,%11101110 ;G
     40  1bcd				  -			; .byte %00000000,%00000000,%01000100,%00000000,%00010001,%00000000,%00000000 ;B
     41  1bcd					      endif
     42  1bcd
     43  1bcd				  -	      if	SOIL_DEF = 2
     44  1bcd				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     45  1bcd				  -CHARACTERSHAPE_SOIL
     46  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     47  1bcd				  -	      .byte	%10101010,%01110111,%11011101,%10101010,%01110111,%10111011,%01010101	;G
     48  1bcd				  -	      .byte	%00000000,%01000100,%00000000,%00000000,%00010001,%00000000,%00000000	;B
     49  1bcd				  -
     50  1bcd				  -			;--------------------------------------------------------------------------
     51  1bcd				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     52  1bcd				  -CHARACTERSHAPE_SOIL_MIRRORED
     53  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     54  1bcd				  -	      .byte	%01010101,%11101110,%10111011,%01010101,%11101110,%11011101,%10101010	;G
     55  1bcd				  -	      .byte	%00000000,%00100010,%00000000,%00000000,%10001000,%00000000,%00000000	;B
     56  1bcd					      endif
     57  1bcd
     58  1bcd				  -	      if	SOIL_DEF = 3
     59  1bcd				  -			; "ORIGINAL"
     60  1bcd				  -			;--------------------------------------------------------------------------
     61  1bcd				  -
     62  1bcd				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     63  1bcd				  -CHARACTERSHAPE_SOIL
     64  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     65  1bcd				  -	      .byte	%10101010,%00100010,%01010101,%00100010,%01010101,%10101010,%00010001	;G
     66  1bcd				  -			;.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ;B
     67  1bcd				  -
     68  1bcd				  -			;--------------------------------------------------------------------------
     69  1bcd				  -			;	 OPTIONAL_PAGEBREAK "CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     70  1bcd				  -CHARACTERSHAPE_SOIL_MIRRORED
     71  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     72  1bcd				  -	      .byte	%01010101,%01000100,%10101010,%01000100,%10101010,%01010101,%10001000	;G
     73  1bcd				  -
     74  1bcd				  -			; AD TODO - THIS IS ERRONEOUSLY OPTIMISED OUT....
     75  1bcd				  -			; AD IT RELIES ON WHATEVER FOLLOWS TO BE 0 BUT NOT ENFORCED SO ERRROR
     76  1bcd				  -			; .byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ;B shared with Rockford.asm!
     77  1bcd				  -
     78  1bcd				  -			;--------------------------------------------------------------------------
     79  1bcd					      endif
     80  1bcd
     81  1bcd				  -	      if	SOIL_DEF = 4
     82  1bcd				  -			; "ORIGINAL"
     83  1bcd				  -			;--------------------------------------------------------------------------
     84  1bcd				  -
     85  1bcd				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     86  1bcd				  -CHARACTERSHAPE_SOIL
     87  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     88  1bcd				  -	      .byte	%10001000,%01010101,%10101010,%01010101,%00100010,%10101010,%01010101	;G
     89  1bcd				  -	      .byte	%00000000,%00000000,%10001000,%00000000,%00000000,%00100010,%00000000	;B
     90  1bcd				  -
     91  1bcd				  -			;--------------------------------------------------------------------------
     92  1bcd				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
     93  1bcd				  -CHARACTERSHAPE_SOIL_MIRRORED
     94  1bcd				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
     95  1bcd				  -	      .byte	%00010001,%10101010,%01010101,%10101010,%01000100,%01010101,%10101010	;G
     96  1bcd				  -	      .byte	%00000000,%00000000,%00010001,%00000000,%00000000,%01000100,%00000000	;B
     97  1bcd				  -
     98  1bcd				  -			;--------------------------------------------------------------------------
     99  1bcd					      endif
    100  1bcd
    101  1bcd					      if	SOIL_DEF = 5
    102  1bcd							; SOLID
      0  1bcd					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  1bcd					      LIST	ON
    104  1bcd				   CHARACTERSHAPE_SOIL
    105  1bcd				   CHARACTERSHAPE_SOIL_MIRRORED
    106  1bcd		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
    107  1bd4		       ff		      .byte.b	%11111111
    108  1bd5		       ff		      .byte.b	%11111111
    109  1bd6		       ff		      .byte.b	%11111111
    110  1bd7		       ff		      .byte.b	%11111111
    111  1bd8		       ff		      .byte.b	%11111111
    112  1bd9		       ff		      .byte.b	%11111111
    113  1bda		       ff		      .byte.b	%11111111
    114  1bdb		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
    115  1be2					      endif
    116  1be2
    117  1be2				  -	      if	SOIL_DEF = 6
    118  1be2				  -			; INVERTED
    119  1be2				  -	      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
    120  1be2				  -CHARACTERSHAPE_SOIL
    121  1be2				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
    122  1be2				  -	      .byte	%01010101,%11011101,%10101010,%11011101,%10101010,%01010101,%11101110	;G
    123  1be2				  -			;.byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ;B
    124  1be2				  -
    125  1be2				  -			;--------------------------------------------------------------------------
    126  1be2				  -			;	 OPTIONAL_PAGEBREAK "CHARACTERSHAPE_SOIL_MIRRORED", LINES_PER_CHAR
    127  1be2				  -CHARACTERSHAPE_SOIL_MIRRORED
    128  1be2				  -	      .byte	%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000	;R
    129  1be2				  -	      .byte	%10101010,%10111011,%01010101,%10111011,%01010101,%10101010,%01110111	;G
    130  1be2				  -
    131  1be2				  -			; AD TODO - THIS IS ERRONEOUSLY OPTIMISED OUT....
    132  1be2				  -			; AD IT RELIES ON WHATEVER FOLLOWS TO BE 0 BUT NOT ENFORCED SO ERRROR
    133  1be2				  -			; .byte %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ;B shared with Rockford.asm!
    134  1be2					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    535  1be2							;------------------------------------------------------------------------------
    536  1be2
    537  1be2							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    538  1be2
    539  1be2							;------------------------------------------------------------------------------
    540  1be2
    541  1be2
    542  1be2
    543  1be2							;	 CHECK_HALF_BANK_SIZE "ROM_SHADOW_OF_RAMBANK_CODE"
    544  1be2
    545  1be2
    546  1be2							; Here there's another 1K of usable ROM....
    547  1be2							; BUT!!! WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    548  1be2
    549  1be2							;-----------------------------------------------------------
    550  1be2							; Stella 3E autodetect signature, can live anywhere
    551  1be2		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
    552  1be6							;-----------------------------------------------------------
    553  1be6
      0  1be6					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  1be6		       03 e6	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $3e6 , FREE= $41a
      2  1be6					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1be6				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1be6				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1be6				  -	      ERR
      6  1be6					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 3
      0  1be6					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  1be6							;------------------------------------------------------------------------------
      2  1be6							;##############################################################################
      3  1be6							;------------------------------------------------------------------------------
      4  1be6
      0  1be6					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  2259 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      6  2000
      7  2000							; NOTE: Access to these buffers must NOT overlap pages...
      8  2000							; NOTE: We get auto-initialisation of these variables from the ROM values by
      9  2000							; copying the whole bank into the RAM bank.  Neato.
     10  2000
     11  2000		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     12  2000
     13  2000
     14  2000
     15  2000		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     16  2050		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     17  20a0
      0  20a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  20a0					      LIST	ON
     19  20a0
     20  20a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     21  20a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     22  20a0							; what we want to happen!
     23  20a0
     24  20a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
     25  20f0
     26  20f0
     27  20f0
     28  20f0							;------------------------------------------------------------------------------
     29  20f0							; RAM-BASED SUBROUTINES...
     30  20f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     31  20f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     32  20f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     33  20f0							; the RAM-based routine.
     34  20f0
     35  20f0
     36  20f0
     37  20f0							;------------------------------------------------------------------------------
     38  20f0
     39  20f0
     40  20f0		       60	   waitForDraw rts		; 6
     41  20f1
     42  20f1							;------------------------------------------------------------------------------
     43  20f1
      0  20f1					      DEFINE_SUBROUTINE	DrawStackUpdate	;=196 (+13 for fall-through bit)
      1  20f1		       00 04	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  20f1					      SUBROUTINE
      3  20f1				   DrawStackUpdate
     45  20f1
     46  20f1							; Parse the DrawFlags buffer and create a draw stack
     47  20f1							; so that the actual draw doesn't need to scan for characters to draw.
     48  20f1
     49  20f1
     50  20f1							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     51  20f1							; symptoms would be missing parts of screen when scrolling.
     52  20f1							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     53  20f1
     54  20f1		       a5 84		      lda	DrawStackPointer
     55  20f3		       10 fb		      bpl	waitForDraw	; Wait for previously not-drawn characters to be drawn
     56  20f5
     57  20f5		       ad 84 02 	      lda	INTIM	;4
     58  20f8		       c9 05		      cmp	#SEGTIME_BDS	;2
     59  20fa		       90 f4		      bcc	waitForDraw	;2/3
      0  20fc					      STRESS_TIME	SEGTIME_BDS
      1  20fc				  -	      IF	TEST_SEGTIME_BDS = 1
      2  20fc				  -
      3  20fc				  -
      4  20fc				  -
      5  20fc				  -
      6  20fc				  -
      7  20fc				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  20fc				  -	      bne	. - 7
      9  20fc					      ENDIF
     61  20fc
     62  20fc
     63  20fc							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
     64  20fc							; moving into the middle of dirt, or BOXs when pushing, or diamonds when grabbing.
     65  20fc
     66  20fc							;		  sec		 already set
     67  20fc		       a5 9a		      lda	ManY	;3
     68  20fe		       e5 95		      sbc	BoardScrollY	;3
     69  2100		       85 9c		      sta	ManDrawY	;3
     70  2102
     71  2102		       38		      sec		;2
     72  2103		       a5 99		      lda	ManX	;3
     73  2105		       e5 96		      sbc	BoardScrollX	;3
     74  2107		       c9 0a		      cmp	#SCREEN_WIDTH	;2
     75  2109		       90 06		      bcc	onsc	;2/3
     76  210b
     77  210b							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
     78  210b							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
     79  210b							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
     80  210b
     81  210b		       a9 08		      lda	#SCREEN_LINES	;2
     82  210d		       85 9c		      sta	ManDrawY	;3
     83  210f		       d0 02		      bne	skipsc	;3		  unconditional
     84  2111
     85  2111		       85 9b	   onsc       sta	ManDrawX	;3
     86  2113				   skipsc
     87  2113
     88  2113		       e6 af		      inc	timer	;5
     89  2115		       4c f3 fc 	      jmp	AnimateCharReplacements2	;3+139
     90  2118				   retAnim
     91  2118
     92  2118		       e6 89		      inc	ScreenDrawPhase	;5
     93  211a
     94  211a		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
     95  211c		       85 d2		      sta	DSL	;3
     96  211e
     97  211e							; fall through...
     98  211e							;---------------------------------------------------------------------------
     99  211e
      0  211e					      DEFINE_SUBROUTINE	DrawIntoStack
      1  211e		       00 04	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  211e					      SUBROUTINE
      3  211e				   DrawIntoStack
    101  211e
    102  211e		       ba		      tsx		;2
    103  211f		       86 de		      stx	save_SP	;3
    104  2121		       a6 84		      ldx	DrawStackPointer	;3
    105  2123		       9a		      txs		;2 = 10
    106  2124
    107  2124		       a4 d2		      ldy	DSL	;3
    108  2126
    109  2126							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    110  2126							; + exit cost which is +10 cycles
    111  2126							; TJ: I count 63
    112  2126							;   + 14 for the wtf2 exit
    113  2126							;   + 22 for the end of loop exit
    114  2126
    115  2126							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    116  2126							; For 80 iterations that is 640 cycles, just for checking INTIM
    117  2126							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    118  2126							; it also will require a lot of CPU time for updating the screen data.
    119  2126
    120  2126							; TODO: optimize!
    121  2126							;
    122  2126							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    123  2126							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    124  2126							; costs some detection time here, but saves ~240 cylces for drawing the two
    125  2126
    126  2126		       ad 84 02    .loopDrawStack lda	INTIM	;4
    127  2129		       c9 05		      cmp	#SEGTIME_DSL	;2
    128  212b		       90 4d		      bcc	.exitDrawStack	;2/3= 8/9
      0  212d					      STRESS_TIME	SEGTIME_DSL
      1  212d				  -	      IF	TEST_SEGTIME_DSL = 1
      2  212d				  -
      3  212d				  -
      4  212d				  -
      5  212d				  -
      6  212d				  -
      7  212d				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  212d				  -	      bne	. - 7
      9  212d					      ENDIF
    130  212d
    131  212d		       b9 50 f0 	      lda	DrawFlag,y	;4
    132  2130		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    133  2133		       f0 16		      beq	.next0	;2/3=10/11	 yes, so we don't draw anything
    134  2135
    135  2135							; Character is NOT the same. Figure out how it should be drawn.
    136  2135							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    137  2135							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    138  2135							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    139  2135
    140  2135		       be 83 f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    141  2138		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    142  213b		       d0 05		      bne	.notPaired0	;2/3=10/11
    143  213d
    144  213d							; Consider two 'paired' characters. Either A:A or A:B
    145  213d							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    146  213d							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    147  213d							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    148  213d							; on the comparison, so the character will not be added to the draw stack. So our first character will
    149  213d							; do the job of drawing BOTH characters to the screen.
    150  213d
    151  213d		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    152  2140		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    153  2142
    154  2142							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    155  2142							; the last write(below) marks the character as to be direct-drawn.
    156  2142
    157  2142		       99 a0 f4    .notPaired0 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    158  2145
    159  2145							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    160  2145
    161  2145		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    162  2146		       98		      tya		;2
    163  2147		       ba		      tsx		;2		 << now X holds drawstackpointer
    164  2148		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    165  214b
    166  214b		       88	   .next0     dey		;2
    167  214c		       30 21		      bmi	.finishedDrawStack	;2/3= 4/5
    168  214e
    169  214e							; unrolled 2nd loop:
    170  214e		       b9 50 f0 	      lda	DrawFlag,y	;4
    171  2151		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    172  2154		       f0 16		      beq	.next1	;2/3=10/11	 yes, so we don't draw anything
    173  2156
    174  2156		       be 83 f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    175  2159		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    176  215c		       d0 05		      bne	.notPaired1	;2/3=10/11
    177  215e
    178  215e		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    179  2161		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    180  2163
    181  2163		       99 a0 f4    .notPaired1 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    182  2166
    183  2166		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    184  2167		       98		      tya		;2
    185  2168		       ba		      tsx		;2
    186  2169		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    187  216c
    188  216c		       88	   .next1     dey		;2
    189  216d		       10 b7		      bpl	.loopDrawStack	;2/3= 4/5
    190  216f							;worst case: 111-4
    191  216f							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    192  216f
    193  216f							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    194  216f
    195  216f				   .finishedDrawStack
    196  216f		       e6 89		      inc	ScreenDrawPhase	;5 =  5
    197  2171		       ba		      tsx		;2
    198  2172		       86 84		      stx	DrawStackPointer	;3
    199  2174		       a6 de		      ldx	save_SP	;3
    200  2176		       9a		      txs		;2 = 10
    201  2177
    202  2177		       4c c0 f8 	      jmp	SwitchObjects
    203  217a
    204  217a							;rts				  ;6 =	6
    205  217a
    206  217a				   .exitDrawStack
    207  217a		       84 d2		      sty	DSL	;3 =  3
    208  217c		       ba		      tsx		;2
    209  217d		       86 84		      stx	DrawStackPointer	;3
    210  217f		       a6 de		      ldx	save_SP	;3
    211  2181		       9a		      txs		;2 = 10
    212  2182		       60		      rts		;6 =  6
    213  2183
    214  2183				   PairedCharacter
    215  2183
    216  2183				   SOFF       SET	0
    217  2183					      REPEAT	SCREEN_LINES
    218  2183		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    219  2183				   SOFF       SET	SOFF + SCREEN_WIDTH
    217  2183					      REPEND
    218  218d		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    219  218d				   SOFF       SET	SOFF + SCREEN_WIDTH
    217  218d					      REPEND
    218  2197		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    219  2197				   SOFF       SET	SOFF + SCREEN_WIDTH
    217  2197					      REPEND
    218  21a1		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    219  21a1				   SOFF       SET	SOFF + SCREEN_WIDTH
    217  21a1					      REPEND
    218  21ab		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    219  21ab				   SOFF       SET	SOFF + SCREEN_WIDTH
    217  21ab					      REPEND
    218  21b5		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    219  21b5				   SOFF       SET	SOFF + SCREEN_WIDTH
    217  21b5					      REPEND
    218  21bf		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    219  21bf				   SOFF       SET	SOFF + SCREEN_WIDTH
    217  21bf					      REPEND
    218  21c9		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    219  21c9				   SOFF       SET	SOFF + SCREEN_WIDTH
    220  21d3					      REPEND
    221  21d3
    222  21d3							;------------------------------------------------------------------------------
    223  21d3							; Gives character replacements used during screen drawing.
    224  21d3							; The character from the board is morphed via this array into an actual character
    225  21d3							; to draw.  This allows global animation and replacment of characters without
    226  21d3							; individual objects needing to do this.  Note, the draw-time replacement happens,
    227  21d3							; not board-time.
    228  21d3
    229  21d3				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    230  21d3
    231  21d3							; Converts a character # to an animated creature type
    232  21d3							; The array is indexed by CHARACTER_...
    233  21d3
    234  21d3		       00		      .byte.b	CHARACTER_BLANK	;  0
    235  21d4		       01		      .byte.b	CHARACTER_SOIL	;  1
    236  21d5		       02		      .byte.b	CHARACTER_BOX	;  2
    237  21d6		       03	   ANIM_TARGET .byte.b	CHARACTER_TARGET	;  3  XOR'd to give flashing target squares
    238  21d7		       04		      .byte.b	CHARACTER_TARGET2	;  4
    239  21d8		       05		      .byte.b	CHARACTER_MANOCCUPIED	;  5
    240  21d9		       06		      .byte.b	CHARACTER_STEEL	;  6
    241  21da		       07		      .byte.b	CHARACTER_WALL	;  7
    242  21db		       08		      .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    243  21dc		       00		      .byte.b	CHARACTER_BLANK	;  9
    244  21dd
    245  21dd
    246  21dd				  -	      IF	* - CharReplacement < CHARACTER_MAXIMUM
    247  21dd				  -	      ECHO	"ERROR: Missing entry in CharReplacement table!"
    248  21dd				  -	      EXIT
    249  21dd					      ENDIF
      0  21dd					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  21dd					      LIST	ON
    251  21dd
    252  21dd							;------------------------------------------------------------------------------
    253  21dd
    254  21dd
      0  21dd					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
 PAGE BREAK INSERTED FOR  ROW_BankChar
 REQUESTED SIZE =  $50
 WASTED SPACE =  $23
 PAGEBREAK LOCATION =  $f200
     10  2200					      LIST	ON
      0  2200					      DEFINE_SUBROUTINE	ROW_BankChar
      1  2200		       00 04	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  2200					      SUBROUTINE
      3  2200				   ROW_BankChar
    257  2200
    258  2200				   .BANK      SET	BANK_SCREENMARKII1
    259  2200					      REPEAT	SCREEN_LINES
    260  2200					      REPEAT	SCREEN_WIDTH
    261  2200		       00		      .byte.b	.BANK
    260  2200					      REPEND
    261  2201		       00		      .byte.b	.BANK
    260  2201					      REPEND
    261  2202		       00		      .byte.b	.BANK
    260  2202					      REPEND
    261  2203		       00		      .byte.b	.BANK
    260  2203					      REPEND
    261  2204		       00		      .byte.b	.BANK
    260  2204					      REPEND
    261  2205		       00		      .byte.b	.BANK
    260  2205					      REPEND
    261  2206		       00		      .byte.b	.BANK
    260  2206					      REPEND
    261  2207		       00		      .byte.b	.BANK
    260  2207					      REPEND
    261  2208		       00		      .byte.b	.BANK
    260  2208					      REPEND
    261  2209		       00		      .byte.b	.BANK
    262  220a					      REPEND
    263  220a				   .BANK      SET	.BANK + 1
    259  220a					      REPEND
    260  220a					      REPEAT	SCREEN_WIDTH
    261  220a		       01		      .byte.b	.BANK
    260  220a					      REPEND
    261  220b		       01		      .byte.b	.BANK
    260  220b					      REPEND
    261  220c		       01		      .byte.b	.BANK
    260  220c					      REPEND
    261  220d		       01		      .byte.b	.BANK
    260  220d					      REPEND
    261  220e		       01		      .byte.b	.BANK
    260  220e					      REPEND
    261  220f		       01		      .byte.b	.BANK
    260  220f					      REPEND
    261  2210		       01		      .byte.b	.BANK
    260  2210					      REPEND
    261  2211		       01		      .byte.b	.BANK
    260  2211					      REPEND
    261  2212		       01		      .byte.b	.BANK
    260  2212					      REPEND
    261  2213		       01		      .byte.b	.BANK
    262  2214					      REPEND
    263  2214				   .BANK      SET	.BANK + 1
    259  2214					      REPEND
    260  2214					      REPEAT	SCREEN_WIDTH
    261  2214		       02		      .byte.b	.BANK
    260  2214					      REPEND
    261  2215		       02		      .byte.b	.BANK
    260  2215					      REPEND
    261  2216		       02		      .byte.b	.BANK
    260  2216					      REPEND
    261  2217		       02		      .byte.b	.BANK
    260  2217					      REPEND
    261  2218		       02		      .byte.b	.BANK
    260  2218					      REPEND
    261  2219		       02		      .byte.b	.BANK
    260  2219					      REPEND
    261  221a		       02		      .byte.b	.BANK
    260  221a					      REPEND
    261  221b		       02		      .byte.b	.BANK
    260  221b					      REPEND
    261  221c		       02		      .byte.b	.BANK
    260  221c					      REPEND
    261  221d		       02		      .byte.b	.BANK
    262  221e					      REPEND
    263  221e				   .BANK      SET	.BANK + 1
    259  221e					      REPEND
    260  221e					      REPEAT	SCREEN_WIDTH
    261  221e		       03		      .byte.b	.BANK
    260  221e					      REPEND
    261  221f		       03		      .byte.b	.BANK
    260  221f					      REPEND
    261  2220		       03		      .byte.b	.BANK
    260  2220					      REPEND
    261  2221		       03		      .byte.b	.BANK
    260  2221					      REPEND
    261  2222		       03		      .byte.b	.BANK
    260  2222					      REPEND
    261  2223		       03		      .byte.b	.BANK
    260  2223					      REPEND
    261  2224		       03		      .byte.b	.BANK
    260  2224					      REPEND
    261  2225		       03		      .byte.b	.BANK
    260  2225					      REPEND
    261  2226		       03		      .byte.b	.BANK
    260  2226					      REPEND
    261  2227		       03		      .byte.b	.BANK
    262  2228					      REPEND
    263  2228				   .BANK      SET	.BANK + 1
    259  2228					      REPEND
    260  2228					      REPEAT	SCREEN_WIDTH
    261  2228		       04		      .byte.b	.BANK
    260  2228					      REPEND
    261  2229		       04		      .byte.b	.BANK
    260  2229					      REPEND
    261  222a		       04		      .byte.b	.BANK
    260  222a					      REPEND
    261  222b		       04		      .byte.b	.BANK
    260  222b					      REPEND
    261  222c		       04		      .byte.b	.BANK
    260  222c					      REPEND
    261  222d		       04		      .byte.b	.BANK
    260  222d					      REPEND
    261  222e		       04		      .byte.b	.BANK
    260  222e					      REPEND
    261  222f		       04		      .byte.b	.BANK
    260  222f					      REPEND
    261  2230		       04		      .byte.b	.BANK
    260  2230					      REPEND
    261  2231		       04		      .byte.b	.BANK
    262  2232					      REPEND
    263  2232				   .BANK      SET	.BANK + 1
    259  2232					      REPEND
    260  2232					      REPEAT	SCREEN_WIDTH
    261  2232		       05		      .byte.b	.BANK
    260  2232					      REPEND
    261  2233		       05		      .byte.b	.BANK
    260  2233					      REPEND
    261  2234		       05		      .byte.b	.BANK
    260  2234					      REPEND
    261  2235		       05		      .byte.b	.BANK
    260  2235					      REPEND
    261  2236		       05		      .byte.b	.BANK
    260  2236					      REPEND
    261  2237		       05		      .byte.b	.BANK
    260  2237					      REPEND
    261  2238		       05		      .byte.b	.BANK
    260  2238					      REPEND
    261  2239		       05		      .byte.b	.BANK
    260  2239					      REPEND
    261  223a		       05		      .byte.b	.BANK
    260  223a					      REPEND
    261  223b		       05		      .byte.b	.BANK
    262  223c					      REPEND
    263  223c				   .BANK      SET	.BANK + 1
    259  223c					      REPEND
    260  223c					      REPEAT	SCREEN_WIDTH
    261  223c		       06		      .byte.b	.BANK
    260  223c					      REPEND
    261  223d		       06		      .byte.b	.BANK
    260  223d					      REPEND
    261  223e		       06		      .byte.b	.BANK
    260  223e					      REPEND
    261  223f		       06		      .byte.b	.BANK
    260  223f					      REPEND
    261  2240		       06		      .byte.b	.BANK
    260  2240					      REPEND
    261  2241		       06		      .byte.b	.BANK
    260  2241					      REPEND
    261  2242		       06		      .byte.b	.BANK
    260  2242					      REPEND
    261  2243		       06		      .byte.b	.BANK
    260  2243					      REPEND
    261  2244		       06		      .byte.b	.BANK
    260  2244					      REPEND
    261  2245		       06		      .byte.b	.BANK
    262  2246					      REPEND
    263  2246				   .BANK      SET	.BANK + 1
    259  2246					      REPEND
    260  2246					      REPEAT	SCREEN_WIDTH
    261  2246		       07		      .byte.b	.BANK
    260  2246					      REPEND
    261  2247		       07		      .byte.b	.BANK
    260  2247					      REPEND
    261  2248		       07		      .byte.b	.BANK
    260  2248					      REPEND
    261  2249		       07		      .byte.b	.BANK
    260  2249					      REPEND
    261  224a		       07		      .byte.b	.BANK
    260  224a					      REPEND
    261  224b		       07		      .byte.b	.BANK
    260  224b					      REPEND
    261  224c		       07		      .byte.b	.BANK
    260  224c					      REPEND
    261  224d		       07		      .byte.b	.BANK
    260  224d					      REPEND
    261  224e		       07		      .byte.b	.BANK
    260  224e					      REPEND
    261  224f		       07		      .byte.b	.BANK
    262  2250					      REPEND
    263  2250				   .BANK      SET	.BANK + 1
    264  2250					      REPEND
    265  2250
    266  2250
    267  2250
    268  2250
      0  2250					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  2250
      2  2250
      3  2250		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $250 , FREE= $1b0
      4  2250					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  2250				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  2250				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  2250				  -	      ERR
      8  2250					      endif
    270  2250
    271  2250
------- FILE CaveBank1.asm LEVEL 3 PASS 3
      0  2250					      include	"CaveBank1.asm"
      1  2250							; Cave definitions
      2  2250
      3  2250		       00 00	   .DIR_UP    =	0
      4  2250		       00 02	   .DIR_RIGHT =	2
      5  2250		       00 04	   .DIR_DOWN  =	4
      6  2250		       00 06	   .DIR_LEFT  =	6
      7  2250
      8  2250
      9  2250					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2250					      START_CAVE	TRACKS
      1  2250				   CAVE_START SET	*
      2  2250		       00 04	   BANK_CAVE_TRACKS =	_CURRENT_BANK
      3  2250				   CAVE_TRACKS SUBROUTINE
      4  2250				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2250
     11  2250
     12  2250							;    .byte   RECT+CHARACTER_WALL, $01, $04, $15, $11	 ; Rect of zBrick from ( 1, 4); length = 21; height = 17
     13  2250							;    .byte   FILL+CHARACTER_WALL, $03, $06, $03, $0F, CHARACTER_FIREFLY; FilledRect of zBrick from ( 3, 6); length = 3; height = 15; fill = zFFly1
      0  2250					      END_CAVE	TRACKS
      1  2250		       ff		      .byte.b	$FF
      2  2250		       00 01	   CAVE_SIZE_TRACKS =	* - CAVE_START
      3  2251					      IF	CAVE_SIZE_TRACKS > MAX_CAVE_SIZE
      4  2251				   MAX_CAVE_SIZE SET	CAVE_SIZE_TRACKS
      5  2251					      ENDIF
     15  2251					      ENDIF
     16  2251
     17  2251							;------------------------------------------------------------------------------
     18  2251
     19  2251					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2251					      START_CAVE	CROWD
      1  2251				   CAVE_START SET	*
      2  2251		       00 04	   BANK_CAVE_CROWD =	_CURRENT_BANK
      3  2251				   CAVE_CROWD SUBROUTINE
      4  2251				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2251
      0  2251					      END_CAVE	CROWD
      1  2251		       ff		      .byte.b	$FF
      2  2251		       00 01	   CAVE_SIZE_CROWD =	* - CAVE_START
      3  2252				  -	      IF	CAVE_SIZE_CROWD > MAX_CAVE_SIZE
      4  2252				  -MAX_CAVE_SIZE SET	CAVE_SIZE_CROWD
      5  2252					      ENDIF
     22  2252					      ENDIF
     23  2252							;------------------------------------------------------------------------------
     24  2252
     25  2252					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2252					      START_CAVE	WALLS
      1  2252				   CAVE_START SET	*
      2  2252		       00 04	   BANK_CAVE_WALLS =	_CURRENT_BANK
      3  2252				   CAVE_WALLS SUBROUTINE
      4  2252				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2252
      0  2252					      END_CAVE	WALLS
      1  2252		       ff		      .byte.b	$FF
      2  2252		       00 01	   CAVE_SIZE_WALLS =	* - CAVE_START
      3  2253				  -	      IF	CAVE_SIZE_WALLS > MAX_CAVE_SIZE
      4  2253				  -MAX_CAVE_SIZE SET	CAVE_SIZE_WALLS
      5  2253					      ENDIF
     28  2253					      ENDIF
     29  2253
     30  2253							;------------------------------------------------------------------------------
     31  2253
     32  2253							;IFCONST CAVE_NAMED_APOCALYPSE
      0  2253					      START_CAVE	APOCALYPSE
      1  2253				   CAVE_START SET	*
      2  2253		       00 04	   BANK_CAVE_APOCALYPSE =	_CURRENT_BANK
      3  2253				   CAVE_APOCALYPSE SUBROUTINE
      4  2253				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2253
      0  2253					      END_CAVE	APOCALYPSE
      1  2253		       ff		      .byte.b	$FF
      2  2253		       00 01	   CAVE_SIZE_APOCALYPSE =	* - CAVE_START
      3  2254				  -	      IF	CAVE_SIZE_APOCALYPSE > MAX_CAVE_SIZE
      4  2254				  -MAX_CAVE_SIZE SET	CAVE_SIZE_APOCALYPSE
      5  2254					      ENDIF
     35  2254							;ENDIF
     36  2254
     37  2254							;------------------------------------------------------------------------------
     38  2254
     39  2254					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2254					      START_CAVE	ZIGZAG
      1  2254				   CAVE_START SET	*
      2  2254		       00 04	   BANK_CAVE_ZIGZAG =	_CURRENT_BANK
      3  2254				   CAVE_ZIGZAG SUBROUTINE
      4  2254				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2254
      0  2254					      END_CAVE	ZIGZAG
      1  2254		       ff		      .byte.b	$FF
      2  2254		       00 01	   CAVE_SIZE_ZIGZAG =	* - CAVE_START
      3  2255				  -	      IF	CAVE_SIZE_ZIGZAG > MAX_CAVE_SIZE
      4  2255				  -MAX_CAVE_SIZE SET	CAVE_SIZE_ZIGZAG
      5  2255					      ENDIF
     42  2255					      ENDIF
     43  2255
     44  2255							;------------------------------------------------------------------------------
     45  2255
     46  2255					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2255					      START_CAVE	ENCHANTED_BOXES
      1  2255				   CAVE_START SET	*
      2  2255		       00 04	   BANK_CAVE_ENCHANTED_BOXES =	_CURRENT_BANK
      3  2255				   CAVE_ENCHANTED_BOXES SUBROUTINE
      4  2255				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2255
      0  2255					      END_CAVE	ENCHANTED_BOXES
      1  2255		       ff		      .byte.b	$FF
      2  2255		       00 01	   CAVE_SIZE_ENCHANTED_BOXES =	* - CAVE_START
      3  2256				  -	      IF	CAVE_SIZE_ENCHANTED_BOXES > MAX_CAVE_SIZE
      4  2256				  -MAX_CAVE_SIZE SET	CAVE_SIZE_ENCHANTED_BOXES
      5  2256					      ENDIF
     49  2256					      ENDIF
     50  2256
     51  2256							;------------------------------------------------------------------------------
     52  2256
     53  2256					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2256					      START_CAVE	INTERMISSION_1
      1  2256				   CAVE_START SET	*
      2  2256		       00 04	   BANK_CAVE_INTERMISSION_1 =	_CURRENT_BANK
      3  2256				   CAVE_INTERMISSION_1 SUBROUTINE
      4  2256				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2256
      0  2256					      END_CAVE	INTERMISSION_1
      1  2256		       ff		      .byte.b	$FF
      2  2256		       00 01	   CAVE_SIZE_INTERMISSION_1 =	* - CAVE_START
      3  2257				  -	      IF	CAVE_SIZE_INTERMISSION_1 > MAX_CAVE_SIZE
      4  2257				  -MAX_CAVE_SIZE SET	CAVE_SIZE_INTERMISSION_1
      5  2257					      ENDIF
     56  2257					      ENDIF
     57  2257
     58  2257							;------------------------------------------------------------------------------
     59  2257
     60  2257					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2257					      START_CAVE	INTERMISSION_2
      1  2257				   CAVE_START SET	*
      2  2257		       00 04	   BANK_CAVE_INTERMISSION_2 =	_CURRENT_BANK
      3  2257				   CAVE_INTERMISSION_2 SUBROUTINE
      4  2257				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2257
      0  2257					      END_CAVE	INTERMISSION_2
      1  2257		       ff		      .byte.b	$FF
      2  2257		       00 01	   CAVE_SIZE_INTERMISSION_2 =	* - CAVE_START
      3  2258				  -	      IF	CAVE_SIZE_INTERMISSION_2 > MAX_CAVE_SIZE
      4  2258				  -MAX_CAVE_SIZE SET	CAVE_SIZE_INTERMISSION_2
      5  2258					      ENDIF
     63  2258					      ENDIF
     64  2258
     65  2258							;------------------------------------------------------------------------------
     66  2258
     67  2258					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  2258					      START_CAVE	INTERMISSION_3
      1  2258				   CAVE_START SET	*
      2  2258		       00 04	   BANK_CAVE_INTERMISSION_3 =	_CURRENT_BANK
      3  2258				   CAVE_INTERMISSION_3 SUBROUTINE
      4  2258				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2258
      0  2258					      END_CAVE	INTERMISSION_3
      1  2258		       ff		      .byte.b	$FF
      2  2258		       00 01	   CAVE_SIZE_INTERMISSION_3 =	* - CAVE_START
      3  2259				  -	      IF	CAVE_SIZE_INTERMISSION_3 > MAX_CAVE_SIZE
      4  2259				  -MAX_CAVE_SIZE SET	CAVE_SIZE_INTERMISSION_3
      5  2259					      ENDIF
     70  2259					      ENDIF
     71  2259
     72  2259
     73  2259
     74  2259
     75  2259
     76  2259							;ECHO "MAX CAVE SIZE = ", MAX_CAVE_SIZE
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm
    273  2259
      0  2259					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  2259		       02 59	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $259 , FREE= $5a7
      2  2259					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2259				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2259				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2259				  -	      ERR
      6  2259					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 3
      0  2259					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  2259							;------------------------------------------------------------------------------
      2  2259							;##############################################################################
      3  2259							;------------------------------------------------------------------------------
      0  2259					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  2f23 ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
      5  2800
      6  2800							;TODOs:
      7  2800							; + store targetsRequired as BCD (with extra diamond flag in separate variable)
      8  2800							; + store caveTime as BCD (2 bytes)
      9  2800							; + diamonds left, time right (while playing)
     10  2800							; + six digit score, centered (short period after scoring)
     11  2800							; + player, men, cave/level (P#2 3 R, E/1) (at start of level, until Rockford appears)
     12  2800							; + make digits a bit darker
     13  2800							; o minimize space before and after digits
     14  2800							; - add missing texts (somehow)
     15  2800							;   - PAUSED (six digits)
     16  2800							;   ? OUT OF TIME (?)
     17  2800							;   ? BONUS LIFE (?)
     18  2800
     19  2800
     20  2800		       00 9a	   SCORE_COL  =	$9a	;WHITE ;-2
     21  2800		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     22  2800		       00 66	   SCORE_COL_HIGH_PAL =	$66
     23  2800
     24  2800
     25  2800				   DigitVectorLOr
     26  2800		       54 62 70 5b*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     27  280a		       23 2a 31 38	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     28  280e				   DigitVectorLO
     29  280e		       53 61 6e 5a*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     30  2818		       37		      .byte.b	<BLANKL-1
     31  2819
     32  2819
     33  2819		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     34  2819		       00 0b	   ID_TARGET  =	11
     35  2819		       00 0c	   ID_EXTRA   =	12
     36  2819		       00 0d	   ID_CLOCK   =	13
     37  2819		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     38  2819							;ID_A	      = 13
     39  2819							;ID_B	      = 14
     40  2819							;ID_C	      = 15
     41  2819							;ID_D	      = 16
     42  2819							;ID_E	      = 17
     43  2819							;ID_F	      = 18
     44  2819							;ID_G	      = 19
     45  2819							;ID_H	      = 20
     46  2819							;ID_I	      = 21
     47  2819							;ID_J	      = 22
     48  2819							;ID_K	      = 23
     49  2819							;ID_L	      = 24
     50  2819							;ID_M	      = 25
     51  2819							;ID_N	      = 26
     52  2819							;ID_O	      = 27
     53  2819							;ID_P	      = 28
     54  2819							;ID_BONUS0   = 29
     55  2819							;ID_BONUS1   = 30
     56  2819							;ID_BONUS2   = 31
     57  2819
     58  2819							; score patch adresses:
     59  2819				   SMTblLSB
     60  2819				   SMTblDiamonds
     61  2819		       52 48		      .byte.b	SM_TARGET0+1-SM_BASE, SM_TARGET2+1-SM_BASE
     62  281b				   SMTblTime
     63  281b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     64  281d				   SMTblScore
     65  281d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     66  2820				   SMTblMSB
     67  2820		       4d 43		      .byte.b	SM_TARGET1+1-SM_BASE, SM_TARGET3+1-SM_BASE
     68  2822		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     69  2824		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     70  2827
     71  2827		       00 00	   SM_OFS_TARGETS =	SMTblDiamonds - SMTblLSB
     72  2827		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     73  2827		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     74  2827
     75  2827				   CharVectorLO
     76  2827		       37		      .byte.b	<BLANKL-1
     77  2828		       94 a8 b5 c2	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     78  282c		       d0 d9 c9 8f	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     79  2830		       bb 9b 89 d6	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     80  2834		       e0 83 af a2	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     81  2838							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     82  2838
     83  2838							; Digit shape definitions are at start of bank so that we don't have page boundary
     84  2838							; crossing issues.
     85  2838
     86  2838							;	  .byte 0	      ; required!
     87  2838
     88  2838		       00 07	   DIGIT_H    =	7	; height of a score digit
     89  2838
     90  2838		       00 00 00 00*BLANKL     ds	7,0
     91  283f
     92  283f
     93  283f
     94  283f				   NineL
     95  283f		       1e		      .byte.b	%00011110
     96  2840		       02		      .byte.b	%00000010
     97  2841		       02		      .byte.b	%00000010
     98  2842		       fe		      .byte.b	%11111110
     99  2843		       82		      .byte.b	%10000010
    100  2844		       82		      .byte.b	%10000010
    101  2845		       fe		      .byte.b	%11111110
    102  2846
    103  2846				   SixL
    104  2846		       fe		      .byte.b	%11111110
    105  2847		       82		      .byte.b	%10000010
    106  2848		       82		      .byte.b	%10000010
    107  2849		       fe		      .byte.b	%11111110
    108  284a		       80		      .byte.b	%10000000
    109  284b		       80		      .byte.b	%10000000
    110  284c		       f0		      .byte.b	%11110000
    111  284d
    112  284d							;    .byte %01111100
    113  284d							;    .byte %11000010
    114  284d							;    .byte %11000010
    115  284d							;    .byte %11111100
    116  284d							;    .byte %11000000
    117  284d							;    .byte %01100000
    118  284d							;    .byte %00111000
    119  284d				   EightL
    120  284d
    121  284d
    122  284d		       fe		      .byte.b	%11111110
    123  284e		       82		      .byte.b	%10000010
    124  284f		       82		      .byte.b	%10000010
    125  2850		       fe		      .byte.b	%11111110
    126  2851		       82		      .byte.b	%10000010
    127  2852		       82		      .byte.b	%10000010
    128  2853		       fe		      .byte.b	%11111110
    129  2854
    130  2854							;  .byte %01111100
    131  2854							;  .byte %10000110
    132  2854							;  .byte %10000110
    133  2854							;  .byte %01111100
    134  2854							;  .byte %01000110
    135  2854							;  .byte %01000110
    136  2854							;  .byte %00111100
    137  2854				   ZeroL
    138  2854							;  .byte %01111100
    139  2854							;  .byte %10000110
    140  2854							;  .byte %10000110
    141  2854							;  .byte %10000110
    142  2854							;  .byte %10000110
    143  2854							;  .byte %01000110
    144  2854							;  .byte %00111100
    145  2854
    146  2854		       fe		      .byte.b	%11111110
    147  2855		       82		      .byte.b	%10000010
    148  2856		       82		      .byte.b	%10000010
    149  2857		       82		      .byte.b	%10000010
    150  2858		       82		      .byte.b	%10000010
    151  2859		       82		      .byte.b	%10000010
    152  285a		       fe		      .byte.b	%11111110
    153  285b
    154  285b				   ThreeL
    155  285b		       fe		      .byte.b	%11111110
    156  285c		       02		      .byte.b	%00000010
    157  285d		       02		      .byte.b	%00000010
    158  285e		       1e		      .byte.b	%00011110
    159  285f		       02		      .byte.b	%00000010
    160  2860		       02		      .byte.b	%00000010
    161  2861		       fe		      .byte.b	%11111110
    162  2862				   OneL
    163  2862		       10		      .byte.b	%00010000
    164  2863		       10		      .byte.b	%00010000
    165  2864		       10		      .byte.b	%00010000
    166  2865		       10		      .byte.b	%00010000
    167  2866		       10		      .byte.b	%00010000
    168  2867		       10		      .byte.b	%00010000
    169  2868		       10		      .byte.b	%00010000
    170  2869
    171  2869				   SevenL
    172  2869
    173  2869		       10		      .byte.b	%00010000
    174  286a		       10		      .byte.b	%00010000
    175  286b		       10		      .byte.b	%00010000
    176  286c		       1e		      .byte.b	%00011110
    177  286d		       02		      .byte.b	%00000010
    178  286e		       02		      .byte.b	%00000010
    179  286f							;  .byte %11111110
    180  286f
    181  286f							;    .byte %00010000
    182  286f							;    .byte %00010000
    183  286f							;    .byte %00010000
    184  286f							;    .byte %00011000
    185  286f							;    .byte %00001100
    186  286f							;    .byte %10000110
    187  286f							;    ;.byte %11111110
    188  286f				   TwoL
    189  286f		       fe		      .byte.b	%11111110
    190  2870		       80		      .byte.b	%10000000
    191  2871		       80		      .byte.b	%10000000
    192  2872		       fe		      .byte.b	%11111110
    193  2873		       02		      .byte.b	%00000010
    194  2874		       02		      .byte.b	%00000010
    195  2875		       fe		      .byte.b	%11111110
    196  2876
    197  2876				   FiveL
    198  2876		       fe		      .byte.b	%11111110
    199  2877		       02		      .byte.b	%00000010
    200  2878		       02		      .byte.b	%00000010
    201  2879		       fe		      .byte.b	%11111110
    202  287a		       80		      .byte.b	%10000000
    203  287b		       80		      .byte.b	%10000000
    204  287c		       f0		      .byte.b	%11110000
    205  287d
    206  287d				   FourL
    207  287d		       10		      .byte.b	%00010000
    208  287e		       10		      .byte.b	%00010000
    209  287f		       10		      .byte.b	%00010000
    210  2880		       fe		      .byte.b	%11111110
    211  2881		       90		      .byte.b	%10010000
    212  2882		       90		      .byte.b	%10010000
    213  2883		       90		      .byte.b	%10010000
    214  2884
    215  2884							; cave "name" characters (left only!):
    216  2884
    217  2884				   CharN
    218  2884		       73		      .byte.b	%01110011
    219  2885		       77		      .byte.b	%01110111
    220  2886		       7f		      .byte.b	%01111111
    221  2887		       7f		      .byte.b	%01111111
    222  2888		       7f		      .byte.b	%01111111
    223  2889		       7b		      .byte.b	%01111011
    224  288a							;	  .byte %01110011
    225  288a				   CharK
    226  288a		       73		      .byte.b	%01110011
    227  288b		       73		      .byte.b	%01110011
    228  288c		       76		      .byte.b	%01110110
    229  288d		       7c		      .byte.b	%01111100
    230  288e		       7c		      .byte.b	%01111100
    231  288f		       76		      .byte.b	%01110110
    232  2890							;	  .byte %01110011
    233  2890				   CharH
    234  2890		       73		      .byte.b	%01110011
    235  2891		       73		      .byte.b	%01110011
    236  2892		       73		      .byte.b	%01110011
    237  2893		       73		      .byte.b	%01110011
    238  2894		       7f		      .byte.b	%01111111
    239  2895							;	  .byte %01110011
    240  2895							;	  .byte %01110011
    241  2895				   CharA
    242  2895		       73		      .byte.b	%01110011
    243  2896		       73		      .byte.b	%01110011
    244  2897		       7f		      .byte.b	%01111111
    245  2898		       73		      .byte.b	%01110011
    246  2899		       73		      .byte.b	%01110011
    247  289a		       3e		      .byte.b	%00111110
    248  289b		       1c		      .byte.b	%00011100
    249  289c
    250  289c				   CharJ
    251  289c		       1e		      .byte.b	%00011110
    252  289d		       3f		      .byte.b	%00111111
    253  289e		       73		      .byte.b	%01110011
    254  289f		       03		      .byte.b	%00000011
    255  28a0		       03		      .byte.b	%00000011
    256  28a1		       03		      .byte.b	%00000011
    257  28a2		       03		      .byte.b	%00000011
    258  28a3
    259  28a3				   CharP
    260  28a3		       40		      .byte.b	%01000000
    261  28a4		       40		      .byte.b	%01000000
    262  28a5		       40		      .byte.b	%01000000
    263  28a6		       7f		      .byte.b	%01111111
    264  28a7		       41		      .byte.b	%01000001
    265  28a8		       41		      .byte.b	%01000001
    266  28a9							;	  .byte %01111110
    267  28a9				   CharB
    268  28a9		       7f		      .byte.b	%01111111
    269  28aa		       7f		      .byte.b	%01111111
    270  28ab		       73		      .byte.b	%01110011
    271  28ac		       73		      .byte.b	%01110011
    272  28ad		       7e		      .byte.b	%01111110
    273  28ae		       73		      .byte.b	%01110011
    274  28af		       7e		      .byte.b	%01111110
    275  28b0
    276  28b0				   CharO
    277  28b0		       3e		      .byte.b	%00111110
    278  28b1		       7f		      .byte.b	%01111111
    279  28b2		       63		      .byte.b	%01100011
    280  28b3		       63		      .byte.b	%01100011
    281  28b4		       63		      .byte.b	%01100011
    282  28b5		       63		      .byte.b	%01100011
    283  28b6							;	  .byte %00111110
    284  28b6				   CharC
    285  28b6		       3e		      .byte.b	%00111110
    286  28b7		       7f		      .byte.b	%01111111
    287  28b8		       73		      .byte.b	%01110011
    288  28b9		       70		      .byte.b	%01110000
    289  28ba		       70		      .byte.b	%01110000
    290  28bb		       73		      .byte.b	%01110011
    291  28bc							;	  .byte %00111110
    292  28bc				   CharI
    293  28bc		       3e		      .byte.b	%00111110
    294  28bd		       3e		      .byte.b	%00111110
    295  28be		       1c		      .byte.b	%00011100
    296  28bf		       1c		      .byte.b	%00011100
    297  28c0		       1c		      .byte.b	%00011100
    298  28c1		       1c		      .byte.b	%00011100
    299  28c2		       3e		      .byte.b	%00111110
    300  28c3
    301  28c3				   CharD
    302  28c3		       7c		      .byte.b	%01111100
    303  28c4		       7e		      .byte.b	%01111110
    304  28c5		       76		      .byte.b	%01110110
    305  28c6		       73		      .byte.b	%01110011
    306  28c7		       73		      .byte.b	%01110011
    307  28c8		       76		      .byte.b	%01110110
    308  28c9		       7c		      .byte.b	%01111100
    309  28ca				   CharG
    310  28ca		       3f		      .byte.b	%00111111
    311  28cb		       7f		      .byte.b	%01111111
    312  28cc		       73		      .byte.b	%01110011
    313  28cd		       77		      .byte.b	%01110111
    314  28ce		       70		      .byte.b	%01110000
    315  28cf		       70		      .byte.b	%01110000
    316  28d0		       3f		      .byte.b	%00111111
    317  28d1
    318  28d1				   CharE
    319  28d1		       7f		      .byte.b	%01111111
    320  28d2		       7f		      .byte.b	%01111111
    321  28d3		       70		      .byte.b	%01110000
    322  28d4		       70		      .byte.b	%01110000
    323  28d5		       7e		      .byte.b	%01111110
    324  28d6		       70		      .byte.b	%01110000
    325  28d7							;	  .byte %01111111
    326  28d7				   CharL
    327  28d7		       7f		      .byte.b	%01111111
    328  28d8		       7f		      .byte.b	%01111111
    329  28d9		       70		      .byte.b	%01110000
    330  28da							;	  .byte %01110000
    331  28da							;	  .byte %01110000
    332  28da							;	  .byte %01110000
    333  28da							;	  .byte %01110000
    334  28da				   CharF
    335  28da		       70		      .byte.b	%01110000
    336  28db		       70		      .byte.b	%01110000
    337  28dc		       70		      .byte.b	%01110000
    338  28dd		       70		      .byte.b	%01110000
    339  28de		       7e		      .byte.b	%01111110
    340  28df		       70		      .byte.b	%01110000
    341  28e0		       7f		      .byte.b	%01111111
    342  28e1
    343  28e1				   CharM
    344  28e1		       63		      .byte.b	%01100011
    345  28e2		       63		      .byte.b	%01100011
    346  28e3		       63		      .byte.b	%01100011
    347  28e4		       6b		      .byte.b	%01101011
    348  28e5		       7f		      .byte.b	%01111111
    349  28e6		       77		      .byte.b	%01110111
    350  28e7		       63		      .byte.b	%01100011
    351  28e8
    352  28e8		       24		      .byte.b	%00100100
    353  28e9		       18		      .byte.b	%00011000
    354  28ea		       3c		      .byte.b	%00111100
    355  28eb		       5a		      .byte.b	%01011010
    356  28ec		       5a		      .byte.b	%01011010
    357  28ed		       3c		      .byte.b	%00111100
    358  28ee		       24		      .byte.b	%00100100
    359  28ef
    360  28ef				   HeadL
    361  28ef				   IntermissionL
    362  28ef		       0c		      .byte.b	%00001100
    363  28f0		       0c		      .byte.b	%00001100
    364  28f1		       0c		      .byte.b	%00001100
    365  28f2		       0c		      .byte.b	%00001100
    366  28f3		       0c		      .byte.b	%00001100
    367  28f4		       00		      .byte.b	%00000000
    368  28f5		       0c		      .byte.b	%00001100
    369  28f6
    370  28f6							;-------------------------------------------------------------------------------------
    371  28f6				   PosTbl
    372  28f6		       40		      .byte.b	$40
    373  28f7		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    374  28ff		       b9		      .byte.b	$b9
    375  2900
    376  2900
    377  2900							;------------------------------------------------------------------------------
    378  2900							; RAM-BASED SUBROUTINES...
    379  2900							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    380  2900							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    381  2900							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    382  2900							; the RAM-based routine.
    383  2900
    384  2900							;z26 call ..\Tools\Z26\4A50\z26.exe -v18 -g14 -r60 $(ProjectName)$(ConfigurationName).bin
    385  2900
    386  2900
    387  2900					      ALIGN	256	; so SM code needs no HI table
    388  2900
    389  2900		       f1 00	   SM_BASE    =	.
    390  2900
    391  2900							;#IF 0 ;{
    392  2900							;    DEFINE_SUBROUTINE Score3x3
    393  2900							;
    394  2900							;	  sta	  RESP0
    395  2900							;	   sta	   RESP1
    396  2900							;	   lda	   #$$000
    397  2900							;	    sta     GRP0
    398  2900							;	    lda     #$$009
    399  2900							;	    sta     GRP1
    400  2900							;	    lda     #$$202
    401  2900							;	    sta     ENABL
    402  2900							;	    nop
    403  2900							;	    nop
    404  2900							;	    nop
    405  2900							;	    lda     #$$016
    406  2900							;	    ldy     #$$100
    407  2900							;	    ldx     #$$109
    408  2900							;	    sta     GRP0    ; Critical time is right here
    409  2900							;	    stx     GRP1
    410  2900							;	    sty     GRP0
    411  2900							;	    sta     RESP0
    412  2900							;	    sta     RESP1
    413  2900							;	    ldx     #$$116
    414  2900							;	    lda     #$$209
    415  2900							;	    stx     GRP0
    416  2900							;	    sta     GRP1
    417  2900							;	    lda     #$$200
    418  2900							;	    sta     GRP0
    419  2900							;	    sta     RESP0
    420  2900							;	    sta     RESP1
    421  2900							;	    lda     #$$216
    422  2900							;	    nop
    423  2900							;	    sta     GRP0
    424  2900							;
    425  2900							;	      rts
    426  2900							;#ENDIF ;}
    427  2900
    428  2900
    429  2900							;------------------------------------------------------------------------------
    430  2900				   Score1x6Fix SUBROUTINE
      0  2900					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  2900		       00 05	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  2900					      SUBROUTINE
      3  2900				   DrawDigits1x6
    432  2900							;					     @07
    433  2900		       ba		      tsx		; 2
    434  2901
    435  2901		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 58    @65
    436  2904
    437  2904		       86 de		      stx	tmpStack	; 3 =	3
    438  2906
    439  2906				   LoopDraw1x6		;
    440  2906				   SMDIGIT0
    441  2906		       b9 54 f3 	      lda	ZeroR-1,y	; 4
    442  2909		       85 42		      sta	WSYNC	; 3
    443  290b							;---------------------------------------------------------------
    444  290b		       85 6a		      sta	HMOVE	; 3
      0  290d					      SLEEP	3	; 3 =	6
      1  290d				   .CYCLES    SET	3
      2  290d
      3  290d				  -	      IF	.CYCLES < 2
      4  290d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  290d				  -	      ERR
      6  290d					      ENDIF
      7  290d
      8  290d					      IF	.CYCLES & 1
      9  290d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  290d		       04 00		      nop	0
     11  290f				  -	      ELSE
     12  290f				  -	      bit	VSYNC
     13  290f					      ENDIF
     14  290f				   .CYCLES    SET	.CYCLES - 3
     15  290f					      ENDIF
     16  290f
     17  290f				  -	      REPEAT	.CYCLES / 2
     18  290f				  -	      nop
     19  290f					      REPEND
    446  290f		       85 5b		      sta	GRP0	; 3
    447  2911				   SMDIGIT1
    448  2911		       b9 53 f0 	      lda	ZeroL-1,y	; 4
    449  2914		       85 5c		      sta	GRP1	; 3
    450  2916				   SMDIGIT2
    451  2916		       b9 54 f3 	      lda	ZeroR-1,y	; 4
    452  2919		       85 5b		      sta	GRP0	; 3 = 17
    453  291b				   SMDIGIT5
    454  291b		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    455  291e		       9a		      txs		; 2
    456  291f				   SMDIGIT3
    457  291f		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    458  2922				   SMDIGIT4
    459  2922		       b9 54 f3 	      lda	ZeroR-1,y	; 4
    460  2925		       85 6b		      sta	HMCLR	; 3
    461  2927		       86 5c		      stx	GRP1	; 3
    462  2929		       85 5b		      sta	GRP0	; 3 = 23
    463  292b
    464  292b		       ba		      tsx		; 2
    465  292c		       86 5c		      stx	GRP1	; 3
    466  292e		       85 5b		      sta	GRP0	; 3 =	8
    467  2930
    468  2930		       88		      dey		; 2
      0  2931					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  2931					      LIST	ON
      9  2931		       d0 d3		      bne	LoopDraw1x6
    470  2933
    471  2933		       a6 de		      ldx	tmpStack	; 3
    472  2935		       9a		      txs		; 2
    473  2936				   ExitDigitKernel6
      0  2936					      SLEEP	3	; 3
      1  2936				   .CYCLES    SET	3
      2  2936
      3  2936				  -	      IF	.CYCLES < 2
      4  2936				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2936				  -	      ERR
      6  2936					      ENDIF
      7  2936
      8  2936					      IF	.CYCLES & 1
      9  2936					      IFNCONST	NO_ILLEGAL_OPCODES
     10  2936		       04 00		      nop	0
     11  2938				  -	      ELSE
     12  2938				  -	      bit	VSYNC
     13  2938					      ENDIF
     14  2938				   .CYCLES    SET	.CYCLES - 3
     15  2938					      ENDIF
     16  2938
     17  2938				  -	      REPEAT	.CYCLES / 2
     18  2938				  -	      nop
     19  2938					      REPEND
    475  2938		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    476  293b
    477  293b
    478  293b							;------------------------------------------------------------------------------
    479  293b				   Score2x4Fix SUBROUTINE
      0  293b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  293b		       00 05	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  293b					      SUBROUTINE
      3  293b				   DrawDigits2x4
    481  293b
    482  293b
    483  293b							; Subroutine by Thomas Jentzsch.  Magic!
    484  293b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    485  293b
    486  293b							;sta COLUBK
    487  293b
    488  293b		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 56    @63
    489  293e
    490  293e		       85 6a		      sta	HMOVE	; 3
      0  2940					      SLEEP	4	; 4  =  7
      1  2940				   .CYCLES    SET	4
      2  2940
      3  2940				  -	      IF	.CYCLES < 2
      4  2940				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  2940				  -	      ERR
      6  2940					      ENDIF
      7  2940
      8  2940				  -	      IF	.CYCLES & 1
      9  2940				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  2940				  -	      nop	0
     11  2940				  -	      ELSE
     12  2940				  -	      bit	VSYNC
     13  2940				  -	      ENDIF
     14  2940				  -.CYCLES    SET	.CYCLES - 3
     15  2940					      ENDIF
     16  2940
     17  2940					      REPEAT	.CYCLES / 2
     18  2940		       ea		      nop
     17  2940					      REPEND
     18  2941		       ea		      nop
     19  2942					      REPEND
    492  2942
    493  2942				   LoopDraw2x4		;	     @70
    494  2942				   SM_TARGET3
    495  2942		       b9 2a f3 	      lda	DequalsR-1,y	; 4		     G
    496  2945							;---------------------------------------------------------------
    497  2945		       85 5b		      sta	GRP0	; 3
    498  2947				   SM_TARGET2
    499  2947		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     A
    500  294a		       85 5c		      sta	GRP1	; 3
    501  294c				   SM_TARGET1
    502  294c		       b9 54 f3 	      lda	ZeroR-1,y	; 4		     M
    503  294f		       85 5b		      sta	GRP0	; 3
    504  2951				   SM_TARGET0
    505  2951		       be 53 f0 	      ldx	ZeroL-1,y	; 4		     E
    506  2954		       85 50		      sta	RESP0	; 3 = 28    @22
    507  2956		       85 51		      sta	RESP1	; 3 =	3    @25
    508  2958				   SM_Time3
    509  2958		       b9 38 f3 	      lda	ClockR-1,y	; 4		     O
    510  295b		       86 5c		      stx	GRP1	; 3
    511  295d		       85 5b		      sta	GRP0	; 3
    512  295f				   SM_Time2
    513  295f		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     V
    514  2962		       85 5c		      sta	GRP1	; 3
    515  2964				   SM_Time1
    516  2964		       b9 54 f3 	      lda	ZeroR-1,y	; 4		     E
    517  2967		       85 5b		      sta	GRP0	; 3
    518  2969		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    519  296b		       85 51		      sta	RESP1	; 3 =	3    @55
    520  296d				   SM_Time0
    521  296d		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     R
    522  2970		       85 5c		      sta	GRP1	; 3
    523  2972		       85 5b		      sta	GRP0	; 3
    524  2974		       88		      dey		; 2
      0  2975					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  2975					      LIST	ON
      9  2975		       d0 cb		      bne	LoopDraw2x4
    526  2977
    527  2977				   ExitDigitKernel		;	     @69
    528  2977		       84 5b		      sty	GRP0	; 3
    529  2979		       84 5c		      sty	GRP1	; 3
    530  297b							;---------------------------------------------------------------
    531  297b		       84 5b		      sty	GRP0	; 3	     @02
    532  297d
    533  297d							; Contribution by Thomas Jentzsch
    534  297d							; Rewrite/Optimised for single sprite AD
    535  297d
    536  297d		       a6 9b		      ldx	ManDrawX	; 3
    537  297f		       bd f6 f0 	      lda	PosTbl,x	; 4
    538  2982		       85 60		      sta	HMP0	; 3
    539  2984		       29 0f		      and	#$0f	; 2
    540  2986		       f0 04		      beq	.zeroPos	; 2/3=15
    541  2988		       aa		      tax		; 2
    542  2989				   .loopWait
    543  2989		       ca		      dex		; 2
    544  298a		       d0 fd		      bne	.loopWait	; 2/3= 6
    545  298c				   .zeroPos
    546  298c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    547  298e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    548  2990		       a5 b0		      lda	BGColour	; 3
    549  2992		       86 62		      stx	HMM0	; 3	     for extra life stars!
    550  2994		       85 42		      sta	WSYNC	; 3
    551  2996							;---------------------------------------------------------------
    552  2996		       85 6a		      sta	HMOVE	; 3
    553  2998		       60		      rts		; 6	     @09
    554  2999
    555  2999							;------------------------------------------------------------------------------
    556  2999				   Score3x2Fix SUBROUTINE
      0  2999					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  2999		       00 05	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  2999					      SUBROUTINE
      3  2999				   DrawDigits3x2
    558  2999							;					     @07
    559  2999		       a9 16		      lda	#%010110	; 2
    560  299b		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    561  299d		       20 f4 f1 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    562  29a0
    563  29a0		       a9 00		      lda	#0
    564  29a2		       85 66		      sta	VDELP1
    565  29a4				   LoopDraw3x2		;
    566  29a4		       85 42		      sta	WSYNC	; 3
    567  29a6							;---------------------------------------------------------------
    568  29a6		       85 6a		      sta	HMOVE	; 3 =	3
    569  29a8		       b9 a2 f0 	      lda	CharP-1,y	; 4
    570  29ab		       85 5b		      sta	GRP0	; 3
    571  29ad				   SMPLAYER
    572  29ad		       b9 62 f3 	      lda	OneR-1,y	; 4
    573  29b0		       85 5c		      sta	GRP1	; 3 = 14    @17
    574  29b2		       b9 ee f0 	      lda	HeadL-1,y	; 4
    575  29b5				   SMMEN
    576  29b5		       be 5b f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  29b8					      SLEEP	5	;   =	5
      1  29b8				   .CYCLES    SET	5
      2  29b8
      3  29b8				  -	      IF	.CYCLES < 2
      4  29b8				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  29b8				  -	      ERR
      6  29b8					      ENDIF
      7  29b8
      8  29b8					      IF	.CYCLES & 1
      9  29b8					      IFNCONST	NO_ILLEGAL_OPCODES
     10  29b8		       04 00		      nop	0
     11  29ba				  -	      ELSE
     12  29ba				  -	      bit	VSYNC
     13  29ba					      ENDIF
     14  29ba				   .CYCLES    SET	.CYCLES - 3
     15  29ba					      ENDIF
     16  29ba
     17  29ba					      REPEAT	.CYCLES / 2
     18  29ba		       ea		      nop
     19  29bb					      REPEND
    578  29bb		       85 5b		      sta	GRP0	; 3
    579  29bd				   SMCAVE
    580  29bd		       b9 94 f0 	      lda	CharA-1,y	; 4
    581  29c0		       85 6b		      sta	HMCLR	; 3 = 10    @40
    582  29c2		       86 5c		      stx	GRP1	; 3 =	3    @43
    583  29c4		       85 5b		      sta	GRP0	; 3
    584  29c6				   SMLEVEL
    585  29c6		       b9 62 f3 	      lda	OneR-1,y	; 4
    586  29c9		       85 5c		      sta	GRP1	; 3 = 10    @53
    587  29cb
    588  29cb		       88		      dey		; 2
      0  29cc					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  29cc					      LIST	ON
      9  29cc		       d0 d6		      bne	LoopDraw3x2
    590  29ce							;					     @57
      0  29ce					      SLEEP	3	; 3
      1  29ce				   .CYCLES    SET	3
      2  29ce
      3  29ce				  -	      IF	.CYCLES < 2
      4  29ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  29ce				  -	      ERR
      6  29ce					      ENDIF
      7  29ce
      8  29ce					      IF	.CYCLES & 1
      9  29ce					      IFNCONST	NO_ILLEGAL_OPCODES
     10  29ce		       04 00		      nop	0
     11  29d0				  -	      ELSE
     12  29d0				  -	      bit	VSYNC
     13  29d0					      ENDIF
     14  29d0				   .CYCLES    SET	.CYCLES - 3
     15  29d0					      ENDIF
     16  29d0
     17  29d0				  -	      REPEAT	.CYCLES / 2
     18  29d0				  -	      nop
     19  29d0					      REPEND
    592  29d0		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    593  29d3
    594  29d3
    595  29d3							;------------------------------------------------------------------------------
      0  29d3					      DEFINE_SUBROUTINE	DrawDigits
      1  29d3		       00 05	   BANK_DrawDigits =	_CURRENT_BANK
      2  29d3					      SUBROUTINE
      3  29d3				   DrawDigits
    597  29d3
    598  29d3				   VblankLoopBD
    599  29d3		       ac 84 02 	      ldy	INTIM
    600  29d6		       d0 fb		      bne	VblankLoopBD
    601  29d8
    602  29d8		       84 41		      sty	VBLANK	; 3	     <-- 0
    603  29da		       a5 c6		      lda	scoringFlags	; 3
    604  29dc		       29 03		      and	#DISPLAY_FLAGS	; 2
    605  29de		       aa		      tax		; 2
    606  29df
    607  29df							;    DEFINE_SUBROUTINE DrawDigit2
    608  29df							;
    609  29df							;    ; Generic interface to scoring routine
    610  29df
    611  29df		       bd ea f1 	      lda	ScoreKernelLo,x	; 4
    612  29e2
    613  29e2		       85 42		      sta	WSYNC	; 3
    614  29e4							;---------------------------------------------------------------
    615  29e4		       8d e8 f5 	      sta	SMJUMP+1+RAM_WRITE	; 4
    616  29e7				   SMJUMP
    617  29e7		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    618  29ea
    619  29ea				   ScoreKernelLo
    620  29ea		       3b		      .byte.b	<Score2x4Fix	; diamonds, time
    621  29eb		       00		      .byte.b	<Score1x6Fix	; score
    622  29ec		       99		      .byte.b	<Score3x2Fix	; player, lives, cave/level
    623  29ed		       00		      .byte.b	<Score1x6Fix	; high score
    624  29ee
      0  29ee					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  29ee					      LIST	ON
    626  29ee
    627  29ee							;------------------------------------------------------------------------------
      0  29ee					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  29ee		       00 05	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  29ee					      SUBROUTINE
      3  29ee				   PrepareDrawDigits
    629  29ee							;					     @13
    630  29ee		       a0 d1		      ldy	#$d1	; 2
    631  29f0		       a9 13		      lda	#%010011	; 2
    632  29f2		       85 66		      sta	VDELP1	; 3 =	7
    633  29f4				   PrepareDrawDigits2		;	    @17/20
    634  29f4		       84 65		      sty	VDELP0	; 3 =	3
    635  29f6
    636  29f6		       85 45		      sta	NUSIZ1	; 3
    637  29f8		       85 44		      sta	NUSIZ0	; 3 =	6
    638  29fa
    639  29fa		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    640  29fd		       85 50		      sta	RESP0	; 3	     @33/36
    641  29ff		       85 51		      sta	RESP1	; 3 = 10    @36/39
    642  2a01
    643  2a01		       84 60		      sty	HMP0	; 3
    644  2a03		       c8		      iny		; 2
    645  2a04		       84 61		      sty	HMP1	; 3 =	8
    646  2a06				   SMCOLOR
    647  2a06		       a0 9a		      ldy	#SCORE_COL	; 2
    648  2a08		       84 46		      sty	COLUP0	; 3
    649  2a0a		       84 47		      sty	COLUP1	; 3 =	8
    650  2a0c
    651  2a0c		       a0 07		      ldy	#DIGIT_H	; 2
    652  2a0e		       60		      rts		; 6 =	8
    653  2a0f							; total: 27
    654  2a0f
    655  2a0f
    656  2a0f							;------------------------------------------------------------------------------
      0  2a0f					      DEFINE_SUBROUTINE	UpdateScore
      1  2a0f		       00 05	   BANK_UpdateScore =	_CURRENT_BANK
      2  2a0f					      SUBROUTINE
      3  2a0f				   UpdateScore
    658  2a0f							; a = added score value
    659  2a0f
    660  2a0f							; initially switch to score:
    661  2a0f		       a0 01		      ldy	#DISPLAY_SCORE
    662  2a11		       84 de		      sty	newDisplay
    663  2a13
    664  2a13		       18		      clc
    665  2a14		       f8		      sed
    666  2a15		       a0 04		      ldy	#SM_OFS_SCORE
    667  2a17				   .loopScore
    668  2a17		       79 ad f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    669  2a1a		       99 ad f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    670  2a1d		       08		      php
    671  2a1e							; *** bonus life every 500 points: ***
    672  2a1e							;	  cpy #SM_OFS_SCORE+1
    673  2a1e							;	  bne .skipBonusLife
    674  2a1e							;	  tax
    675  2a1e
    676  2a1e							;	  and #$0f
    677  2a1e							;	  beq .bonusLife		      ; 000?
    678  2a1e							;	  cmp #$05
    679  2a1e							;	  bne .noBonusLife		      ; 500?
    680  2a1e							;.bonusLife:
    681  2a1e							; add extra life, limited to 9
    682  2a1e
    683  2a1e							;	  lda ManCount
    684  2a1e							;	  and #$0f
    685  2a1e							;	  cmp #9
    686  2a1e							;	  bcs .noBonusLife
    687  2a1e							;	  inc ManCount
    688  2a1e
    689  2a1e							; bonus life has priority over score:
    690  2a1e							;	  lda #DISPLAY_LIVES
    691  2a1e							;	  sta newDisplay
    692  2a1e							;lda #EXTRA_LIFE_TIMER
    693  2a1e							;sta extraLifeTimer
    694  2a1e
    695  2a1e				   .noBonusLife
    696  2a1e		       8a		      txa
    697  2a1f				   .skipBonusLife
    698  2a1f		       20 04 f3 	      jsr	SetupBCDPtr
    699  2a22		       28		      plp
    700  2a23		       a9 00		      lda	#0
    701  2a25		       b0 f0		      bcs	.loopScore
    702  2a27		       d8		      cld
    703  2a28
    704  2a28							; switch display
    705  2a28		       a5 c6		      lda	scoringFlags
    706  2a2a		       29 03		      and	#DISPLAY_FLAGS
    707  2a2c		       c5 de		      cmp	newDisplay	; lower priority than current?
    708  2a2e		       f0 08		      beq	.restartTime
    709  2a30		       b0 0a		      bcs	.skipNew
    710  2a32		       45 c6		      eor	scoringFlags	; remove existing score mode
    711  2a34		       05 de		      ora	newDisplay	; switch to new score mode
    712  2a36		       85 c6		      sta	scoringFlags
    713  2a38				   .restartTime
    714  2a38		       a9 3c		      lda	#SCORING_TIMER	; maybe always restart timer?
    715  2a3a		       85 c5		      sta	scoringTimer
    716  2a3c				   .skipNew
    717  2a3c
    718  2a3c		       60		      rts
    719  2a3d
    720  2a3d							;---------------------------------------------------------------------------
    721  2a3d
      0  2a3d					      DEFINE_SUBROUTINE	SwapPlayers
      1  2a3d		       00 05	   BANK_SwapPlayers =	_CURRENT_BANK
      2  2a3d					      SUBROUTINE
      3  2a3d				   SwapPlayers
    723  2a3d
    724  2a3d							; assume no new high score:
    725  2a3d		       a0 ff		      ldy	#-1
    726  2a3f		       84 e1		      sty	highScoreSK
    727  2a41
    728  2a41							; update highscore after last live:
    729  2a41		       a5 a5		      lda	ManCount
    730  2a43		       29 0f		      and	#$0f	; player has lives left?
    731  2a45		       d0 1c		      bne	.playerAlive	; YES, so we don't check high score
    732  2a47
    733  2a47							; check for a new high score:
    734  2a47							;	  ldy #-1
    735  2a47		       18		      clc		; score has to be at least 1 bigger!
    736  2a48				   .loopCheckHighScore
    737  2a48		       c8		      iny
    738  2a49		       b9 b1 f3 	      lda	ScoreCurrent,y
    739  2a4c		       f9 bb f3 	      sbc	HighScore,y
    740  2a4f		       98		      tya
    741  2a50		       49 02		      eor	#2
    742  2a52		       d0 f4		      bne	.loopCheckHighScore
    743  2a54		       90 0d		      bcc	.noHighScore
    744  2a56
    745  2a56							; new high score, update:
    746  2a56		       a2 04		      ldx	#5-1
    747  2a58				   .loopSetHighScore
    748  2a58		       bd b1 f3 	      lda	ScoreCurrent,x
    749  2a5b		       9d bb f7 	      sta	HighScore+RAM_WRITE,x
    750  2a5e		       95 e1		      sta	highScoreSK,x
    751  2a60		       ca		      dex
    752  2a61		       10 f5		      bpl	.loopSetHighScore
    753  2a63				   .noHighScore
    754  2a63
    755  2a63				   .playerAlive
    756  2a63		       a5 a5		      lda	ManCount
    757  2a65		       29 f0		      and	#$f0	; other player has lives left?
    758  2a67		       f0 21		      beq	.otherPlayerDead	; NO, so we don't swap scores
    759  2a69
    760  2a69							; save the current player variables to the player's backup:
    761  2a69		       a0 02		      ldy	#3-1
    762  2a6b				   .swapScore
    763  2a6b		       be b6 f3 	      ldx	PlayerScores,y
    764  2a6e		       b9 b1 f3 	      lda	ScoreCurrent,y
    765  2a71		       99 b6 f7 	      sta	PlayerScores+RAM_WRITE,y
    766  2a74		       8a		      txa
    767  2a75		       99 b1 f7 	      sta	ScoreCurrent+RAM_WRITE,y
    768  2a78		       88		      dey
    769  2a79		       10 f0		      bpl	.swapScore
    770  2a7b
    771  2a7b							; swap cave and level:
    772  2a7b		       a2 01		      ldx	#1
    773  2a7d				   .loopCaveLevel
    774  2a7d		       bc b9 f3 	      ldy	PlayerCave,x
    775  2a80		       b5 b1		      lda	cave,x
    776  2a82		       9d b9 f7 	      sta	PlayerCave+RAM_WRITE,x
    777  2a85		       94 b1		      sty	cave,x
    778  2a87		       ca		      dex
    779  2a88		       10 f3		      bpl	.loopCaveLevel
    780  2a8a
    781  2a8a				   .otherPlayerDead
    782  2a8a		       60		      rts
    783  2a8b
    784  2a8b							;---------------------------------------------------------------------------
    785  2a8b
    786  2a8b				   HighScoreColTbl
    787  2a8b		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    788  2a8d		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    789  2a8f
      0  2a8f					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  2a8f		       00 05	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  2a8f					      SUBROUTINE
      3  2a8f				   GeneralScoringSetups
    791  2a8f
    792  2a8f		       a0 04		      ldy	#SM_OFS_SCORE
    793  2a91				   .loopScore2
    794  2a91		       a5 c6		      lda	scoringFlags
    795  2a93		       29 03		      and	#DISPLAY_FLAGS
    796  2a95		       c9 03		      cmp	#DISPLAY_HIGH
    797  2a97		       a6 81		      ldx	Platform
    798  2a99		       bd 8b f2 	      lda	HighScoreColTbl,x
    799  2a9c		       aa		      tax
    800  2a9d		       b9 b7 f3 	      lda	HighScore-SM_OFS_SCORE,y
    801  2aa0		       b0 05		      bcs	.showHighScore
    802  2aa2		       a2 9a		      ldx	#SCORE_COL
    803  2aa4		       b9 ad f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    804  2aa7				   .showHighScore
    805  2aa7		       8e 07 f6 	      stx	SMCOLOR+1+RAM_WRITE
    806  2aaa		       20 04 f3 	      jsr	SetupBCDPtr
    807  2aad		       c0 07		      cpy	#SM_OFS_SCORE+3
    808  2aaf		       90 e0		      bcc	.loopScore2
    809  2ab1
    810  2ab1							; display number of lives in leftmost digit of middle score XX nX XX
    811  2ab1
    812  2ab1		       a5 a5		      lda	ManCount
    813  2ab3		       29 0f		      and	#$0f
    814  2ab5		       a8		      tay
    815  2ab6		       b9 00 f0 	      lda	DigitVectorLOr,y
    816  2ab9		       8d b6 f5 	      sta	SMMEN+1+RAM_WRITE
    817  2abc
    818  2abc							; modify player number pointer (Xp XX XX)
    819  2abc
    820  2abc		       a4 98		      ldy	whichPlayer
    821  2abe		       b9 01 f0 	      lda	DigitVectorLOr+1,y
    822  2ac1		       8d ae f5 	      sta	SMPLAYER+1+RAM_WRITE
    823  2ac4
    824  2ac4							; fall through
    825  2ac4
    826  2ac4							;    ;---------------------------------------------------------------------------
    827  2ac4
    828  2ac4							; modify cave character pointer (XX XX cX)
    829  2ac4
    830  2ac4		       a2 ee		      ldx	#<IntermissionL-1
    831  2ac6		       a5 b3		      lda	levelDisplay
    832  2ac8		       c9 80		      cmp	#$80
    833  2aca		       29 1f		      and	#$1f
    834  2acc		       a8		      tay
    835  2acd		       b0 05		      bcs	.intermission
    836  2acf		       be 27 f0 	      ldx	CharVectorLO,y
    837  2ad2		       a4 b2		      ldy	level
    838  2ad4				   .intermission
    839  2ad4		       8e be f5 	      stx	SMCAVE+1+RAM_WRITE
    840  2ad7
    841  2ad7							; modify level number pointer (XX XX Xl)
    842  2ad7
    843  2ad7		       b9 01 f0 	      lda	DigitVectorLOr+1,y
    844  2ada		       8d c7 f5 	      sta	SMLEVEL+1+RAM_WRITE
    845  2add
    846  2add							;---------------------------------------------------------------------------
    847  2add
    848  2add		       4c fb f2 	      jmp	SetupTimePtr	; modify time pointers
    849  2ae0
    850  2ae0							;------------------------------------------------------------------------------
    851  2ae0							;    DEFINE_SUBROUTINE SetupGameOverPtr
    852  2ae0
    853  2ae0							;		  ldy #8-1
    854  2ae0							;.loopGameOver:
    855  2ae0							;		  ldx SMGameOverOfs,y
    856  2ae0							;		  lda SMGameOverPtr,y
    857  2ae0							;		  sta SM_BASE+1+RAM_WRITE,x
    858  2ae0							;		  dey
    859  2ae0							;		  bpl .loopGameOver
    860  2ae0
    861  2ae0							;		  rts
    862  2ae0
    863  2ae0							;SMGameOverOfs:
    864  2ae0							;		  .byte <SM_TARGET3-SM_BASE, <SM_TARGET2-SM_BASE
    865  2ae0							;		  .byte <SM_TARGET1-SM_BASE, <SM_TARGET0-SM_BASE
    866  2ae0							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    867  2ae0							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    868  2ae0							;SMGameOverPtr:
    869  2ae0							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    870  2ae0							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    871  2ae0
    872  2ae0							;------------------------------------------------------------------------------
      0  2ae0					      DEFINE_SUBROUTINE	GetDiamond
      1  2ae0		       00 05	   BANK_GetDiamond =	_CURRENT_BANK
      2  2ae0					      SUBROUTINE
      3  2ae0				   GetDiamond
    874  2ae0
    875  2ae0							;sok jsr UpdateScore		      ;looong!
    876  2ae0
    877  2ae0							;------------------------------------------------------------------------------
    878  2ae0
      0  2ae0					      DEFINE_SUBROUTINE	DrawTargetsRequired
      1  2ae0		       00 05	   BANK_DrawTargetsRequired =	_CURRENT_BANK
      2  2ae0					      SUBROUTINE
      3  2ae0				   DrawTargetsRequired
    880  2ae0							; Show current diamond counter in the top left
    881  2ae0
    882  2ae0		       a0 00		      ldy	#SM_OFS_TARGETS
    883  2ae2		       a5 b6		      lda	targetsRequired
    884  2ae4		       20 04 f3 	      jsr	SetupBCDPtr
    885  2ae7
    886  2ae7		       a9 b0		      lda	#ID_TARGET<<4	; if no extra diamonds, display the normal icon
    887  2ae9		       24 c6		      bit	scoringFlags	;
    888  2aeb		       10 17		      bpl	SetupBCDPtr
    889  2aed		       a9 c0		      lda	#ID_EXTRA<<4	; otherwise, display the extra icon
    890  2aef		       50 13		      bvc	SetupBCDPtr
    891  2af1		       09 01		      ora	#1	; display 1xx diamonds
    892  2af3		       d0 0f		      bne	SetupBCDPtr	; unconditional
    893  2af5
    894  2af5							;------------------------------------------------------------------------------
      0  2af5					      DEFINE_SUBROUTINE	DrawTime
      1  2af5		       00 05	   BANK_DrawTime =	_CURRENT_BANK
      2  2af5					      SUBROUTINE
      3  2af5				   DrawTime
    896  2af5
    897  2af5							; mid-digit-change, but we may be required to flash/display
    898  2af5		       a0 02		      ldy	#SM_OFS_TIME
    899  2af7		       a5 b8		      lda	caveTimeHi
    900  2af9		       d0 00		      bne	BGOK
    901  2afb							;lda caveTime
    902  2afb							;cmp #RED_TIME_WARNING
    903  2afb							;bcs BGOK
    904  2afb							;lda caveTimeFrac
    905  2afb							;adc #$20
    906  2afb							;and #$60			      ; 75% on, 25% off
    907  2afb							;bne BGOK
    908  2afb
    909  2afb							;lda #ID_BLANK<<4|ID_BLANK
    910  2afb							;jsr SetupBCDPtr
    911  2afb							;lda #ID_CLOCK<<4|ID_BLANK
    912  2afb							;bne SetupBCDPtr		      ; ASSUMES ID_BLANK != 0
    913  2afb				   BGOK
    914  2afb							;------------------------------------------------------------------------------
      0  2afb					      DEFINE_SUBROUTINE	SetupTimePtr
      1  2afb		       00 05	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  2afb					      SUBROUTINE
      3  2afb				   SetupTimePtr
    916  2afb
    917  2afb		       a5 b7		      lda	caveTime
    918  2afd		       20 04 f3 	      jsr	SetupBCDPtr
    919  2b00		       a5 b8		      lda	caveTime+1
    920  2b02		       09 d0		      ora	#ID_CLOCK<<4
    921  2b04
    922  2b04							; fall through
    923  2b04
    924  2b04							;------------------------------------------------------------------------------
      0  2b04					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  2b04		       00 05	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  2b04					      SUBROUTINE
      3  2b04				   SetupBCDPtr
    926  2b04
    927  2b04							; a = BCD value
    928  2b04							; y = SM table offset
    929  2b04
    930  2b04		       48		      pha
    931  2b05		       29 0f		      and	#$0f
    932  2b07		       aa		      tax
    933  2b08		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    934  2b0b		       be 19 f0 	      ldx	SMTblLSB,y
    935  2b0e		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    936  2b11		       68		      pla
    937  2b12		       4a		      lsr
    938  2b13		       4a		      lsr
    939  2b14		       4a		      lsr
    940  2b15		       4a		      lsr
    941  2b16		       aa		      tax
    942  2b17		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    943  2b1a		       be 20 f0 	      ldx	SMTblMSB,y
    944  2b1d		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    945  2b20
    946  2b20		       c8		      iny
    947  2b21
    948  2b21		       a5 c1		      lda	ROM_Bank
    949  2b23				   RTS
    950  2b23		       60		      rts
    951  2b24
      0  2b24					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
     10  2b24					      LIST	ON
    953  2b24
    954  2b24				  -	      IF	<. = 0
    955  2b24				  -	      .byte	0	; required!
    956  2b24					      ENDIF
    957  2b24
    958  2b24				   BLANKR
    959  2b24		       00 00 00 00*	      .ds	DIGIT_H, 0
    960  2b2b
    961  2b2b				   DequalsR
    962  2b2b		       00		      .byte.b	%00000000
    963  2b2c		       00		      .byte.b	%00000000
    964  2b2d		       f0		      .byte.b	%11110000
    965  2b2e		       00		      .byte.b	%00000000
    966  2b2f		       f0		      .byte.b	%11110000
    967  2b30		       00		      .byte.b	%00000000
    968  2b31		       f0		      .byte.b	%11110000
    969  2b32				   DplusR
    970  2b32		       10		      .byte.b	%00010000
    971  2b33		       28		      .byte.b	%00101000
    972  2b34		       6c		      .byte.b	%01101100
    973  2b35		       c6		      .byte.b	%11000110
    974  2b36		       6c		      .byte.b	%01101100
    975  2b37		       28		      .byte.b	%00101000
    976  2b38		       10		      .byte.b	%00010000
    977  2b39
    978  2b39				   ClockR
    979  2b39		       00		      .byte.b	%00000000
    980  2b3a		       48		      .byte.b	%01001000
    981  2b3b		       fc		      .byte.b	%11111100
    982  2b3c		       48		      .byte.b	%01001000
    983  2b3d		       48		      .byte.b	%01001000
    984  2b3e		       fc		      .byte.b	%11111100
    985  2b3f		       48		      .byte.b	%01001000
    986  2b40				   NineR
    987  2b40		       0f		      .byte.b	%00001111
    988  2b41		       01		      .byte.b	%00000001
    989  2b42		       01		      .byte.b	%00000001
    990  2b43		       7f		      .byte.b	%01111111
    991  2b44		       41		      .byte.b	%01000001
    992  2b45		       41		      .byte.b	%01000001
    993  2b46		       7f		      .byte.b	%01111111
    994  2b47				   SixR
    995  2b47		       7f		      .byte.b	%01111111
    996  2b48		       41		      .byte.b	%01000001
    997  2b49		       41		      .byte.b	%01000001
    998  2b4a		       7f		      .byte.b	%01111111
    999  2b4b		       40		      .byte.b	%01000000
   1000  2b4c		       40		      .byte.b	%01000000
   1001  2b4d		       78		      .byte.b	%01111000
   1002  2b4e				   EightR
   1003  2b4e							;  .byte %00111110
   1004  2b4e							;  .byte %01000011
   1005  2b4e							;  .byte %01000011
   1006  2b4e							;  .byte %00111110
   1007  2b4e							;  .byte %00100011
   1008  2b4e							;  .byte %00100011
   1009  2b4e							;  .byte %00011110
   1010  2b4e
   1011  2b4e
   1012  2b4e		       7f		      .byte.b	%01111111
   1013  2b4f		       41		      .byte.b	%01000001
   1014  2b50		       41		      .byte.b	%01000001
   1015  2b51		       7f		      .byte.b	%01111111
   1016  2b52		       41		      .byte.b	%01000001
   1017  2b53		       41		      .byte.b	%01000001
   1018  2b54		       7f		      .byte.b	%01111111
   1019  2b55
   1020  2b55				   ZeroR
   1021  2b55		       7f		      .byte.b	%01111111
   1022  2b56		       41		      .byte.b	%01000001
   1023  2b57		       41		      .byte.b	%01000001
   1024  2b58		       41		      .byte.b	%01000001
   1025  2b59		       41		      .byte.b	%01000001
   1026  2b5a		       41		      .byte.b	%01000001
   1027  2b5b		       7f		      .byte.b	%01111111
   1028  2b5c
   1029  2b5c							;	  .byte %00111110
   1030  2b5c							;	  .byte %01000011
   1031  2b5c							;	  .byte %01000011
   1032  2b5c							;	  .byte %01000011
   1033  2b5c							;	  .byte %01000011
   1034  2b5c							;	  .byte %00100011
   1035  2b5c							;	  .byte %00011110
   1036  2b5c				   ThreeR
   1037  2b5c		       7f		      .byte.b	%01111111
   1038  2b5d		       01		      .byte.b	%00000001
   1039  2b5e		       01		      .byte.b	%00000001
   1040  2b5f		       0f		      .byte.b	%00001111
   1041  2b60		       01		      .byte.b	%00000001
   1042  2b61		       01		      .byte.b	%00000001
   1043  2b62		       7f		      .byte.b	%01111111
   1044  2b63				   OneR
   1045  2b63		       08		      .byte.b	%00001000
   1046  2b64		       08		      .byte.b	%00001000
   1047  2b65		       08		      .byte.b	%00001000
   1048  2b66		       08		      .byte.b	%00001000
   1049  2b67		       08		      .byte.b	%00001000
   1050  2b68		       08		      .byte.b	%00001000
   1051  2b69		       08		      .byte.b	%00001000
   1052  2b6a
   1053  2b6a				   SevenR
   1054  2b6a		       08		      .byte.b	%00001000
   1055  2b6b		       08		      .byte.b	%00001000
   1056  2b6c		       08		      .byte.b	%00001000
   1057  2b6d		       0f		      .byte.b	%00001111
   1058  2b6e		       01		      .byte.b	%00000001
   1059  2b6f		       01		      .byte.b	%00000001
   1060  2b70		       7f		      .byte.b	%01111111
   1061  2b71
   1062  2b71				   TwoR
   1063  2b71		       7f		      .byte.b	%01111111
   1064  2b72		       40		      .byte.b	%01000000
   1065  2b73		       40		      .byte.b	%01000000
   1066  2b74		       7f		      .byte.b	%01111111
   1067  2b75		       01		      .byte.b	%00000001
   1068  2b76		       01		      .byte.b	%00000001
   1069  2b77		       7f		      .byte.b	%01111111
   1070  2b78				   FiveR
   1071  2b78		       7f		      .byte.b	%01111111
   1072  2b79		       01		      .byte.b	%00000001
   1073  2b7a		       01		      .byte.b	%00000001
   1074  2b7b		       7f		      .byte.b	%01111111
   1075  2b7c		       40		      .byte.b	%01000000
   1076  2b7d		       40		      .byte.b	%01000000
   1077  2b7e		       78		      .byte.b	%01111000
   1078  2b7f				   FourR
   1079  2b7f		       08		      .byte.b	%00001000
   1080  2b80		       08		      .byte.b	%00001000
   1081  2b81		       08		      .byte.b	%00001000
   1082  2b82		       7f		      .byte.b	%01111111
   1083  2b83		       48		      .byte.b	%01001000
   1084  2b84		       48		      .byte.b	%01001000
   1085  2b85		       48		      .byte.b	%01001000
   1086  2b86
   1087  2b86							;CharAL:
   1088  2b86							;    .byte %11100110
   1089  2b86							;    .byte %11100110
   1090  2b86							;    .byte %11111110
   1091  2b86							;    .byte %11100110
   1092  2b86							;    .byte %11100110
   1093  2b86							;    .byte %01111100
   1094  2b86							;    .byte %00111000
   1095  2b86							;CharEL:
   1096  2b86							;    .byte %11111110
   1097  2b86							;    .byte %11111110
   1098  2b86							;    .byte %11100000
   1099  2b86							;    .byte %11100000
   1100  2b86							;    .byte %11111100
   1101  2b86							;    .byte %11100000
   1102  2b86							;    .byte %11111110
   1103  2b86							;CharRL:
   1104  2b86							;    .byte %11100110
   1105  2b86							;    .byte %11100110
   1106  2b86							;    .byte %11111100
   1107  2b86							;    .byte %11111100
   1108  2b86							;    .byte %11100110
   1109  2b86							;    .byte %11100110
   1110  2b86							;    .byte %11111100
   1111  2b86							;CharVL:
   1112  2b86							;    .byte %00111000
   1113  2b86							;    .byte %01111100
   1114  2b86							;    .byte %11100110
   1115  2b86							;    .byte %11100110
   1116  2b86							;    .byte %11100110
   1117  2b86							;    .byte %11100110
   1118  2b86							;    .byte %11100110
   1119  2b86
      0  2b86					      CHECKPAGE	BLANKR
      8  2b86					      LIST	ON
   1121  2b86
   1122  2b86							;---------------------------------------------------------------------------
   1123  2b86
      0  2b86					      DEFINE_SUBROUTINE	GameInitialise
      1  2b86		       00 05	   BANK_GameInitialise =	_CURRENT_BANK
      2  2b86					      SUBROUTINE
      3  2b86				   GameInitialise
   1125  2b86
   1126  2b86							; copy loaded SK high score into scoring RAM:
   1127  2b86		       a2 02		      ldx	#3-1
   1128  2b88				   .loopCopyHighScore
   1129  2b88		       b5 e1		      lda	highScoreSK,x
   1130  2b8a		       c9 ff		      cmp	#$ff
   1131  2b8c		       f0 06		      beq	.noSaveKey
   1132  2b8e		       9d bb f7 	      sta	HighScore+RAM_WRITE,x
   1133  2b91		       ca		      dex
   1134  2b92		       10 f4		      bpl	.loopCopyHighScore
   1135  2b94				   .noSaveKey
   1136  2b94
   1137  2b94							; clear both players scores
   1138  2b94		       a0 05		      ldy	#2*3-1
   1139  2b96		       a9 00		      lda	#0
   1140  2b98				   .loopClearScore
   1141  2b98		       99 b1 f7 	      sta	ScoreCurrent+RAM_WRITE,y
   1142  2b9b		       88		      dey
   1143  2b9c		       10 fa		      bpl	.loopClearScore
   1144  2b9e
   1145  2b9e							; copy cave and level for other player and SaveKey:
   1146  2b9e		       a5 b1		      lda	cave
   1147  2ba0		       8d b9 f7 	      sta	PlayerCave+RAM_WRITE
   1148  2ba3		       a5 e4		      lda	startCave
   1149  2ba5		       8d b4 f7 	      sta	StartCave+RAM_WRITE
   1150  2ba8		       a5 b2		      lda	level
   1151  2baa		       8d ba f7 	      sta	PlayerLevel+RAM_WRITE
   1152  2bad		       8d b5 f7 	      sta	StartLevel+RAM_WRITE
   1153  2bb0		       60		      rts
   1154  2bb1
   1155  2bb1							;---------------------------------------------------------------------------
   1156  2bb1
   1157  2bb1		       00 00 00    ScoreCurrent ds	3, 0
   1158  2bb4							; start cave and level have to be after ScoreCurrent!
   1159  2bb4		       00	   StartCave  .byte.b	0
   1160  2bb5		       00	   StartLevel .byte.b	0
   1161  2bb6		       00 00 00    PlayerScores ds	3, 0
   1162  2bb9							; cave and level have to be consecutive variables!
   1163  2bb9		       00	   PlayerCave .byte.b	0
   1164  2bba		       00	   PlayerLevel .byte.b	0
   1165  2bbb		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1166  2bc0
   1167  2bc0
   1168  2bc0
   1169  2bc0							;------------------------------------------------------------------------------
   1170  2bc0
      0  2bc0					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  2bc0
      2  2bc0
      3  2bc0		       03 c0	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $3c0 , FREE= $40
      4  2bc0					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  2bc0				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  2bc0				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  2bc0				  -	      ERR
      8  2bc0					      endif
   1172  2bc0
   1173  2bc0							;------------------------------------------------------------------------------
   1174  2bc0
   1175  2bc0							; CAVE DATA banks can go anywhere - *EXCEPT* for the same bank as the cave
   1176  2bc0							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_CAVE_SIZE
   1177  2bc0							; which is used as a buffer size inside UnpackLevel.  It's not important if
   1178  2bc0							; this is defined before or after, as once the caves have processed it will be
   1179  2bc0							; correct. Note, that caves should all be defined BEFORE *OR* AFTER the
   1180  2bc0							; UnpackLevel code -- but that they should not be both, nor in the same bank.
   1181  2bc0
------- FILE CaveBank0.asm LEVEL 3 PASS 3
      0  2bc0					      include	"CaveBank0.asm"
      1  2bc0							; Cave definitions
      2  2bc0							; Sample cave definitions.
      3  2bc0							; Any cave can be in any bank.  System auto-calculates required bank buffer size in RAM.
      4  2bc0							; have as many banks as you like.  Add new banks in notBOXDash.asm.
      5  2bc0
      6  2bc0							;.byte "4-5#|4-#3-#|4-#$2-#|2-3#2-$2#|2-#2-$-$-#|3#-#-2#-#3-6#|#3-#-2#-5#2-2.#|#-$2-$10-2.#|5#-3#-#@2#2-2.#|4-#5-9#|4-7#",0
      7  2bc0							;.byte "-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#",0
      8  2bc0							;.byte "3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-",0
      9  2bc0							;.byte "23#|#21 #|#@18#$##|#-#3.#12-#--#|#-#3.#-8$-#-#--#|#-#..$--$6-$#.-$ -#|#-#3-#3-6$.#-#--#|#-#3.#-#-5.#3-.3#|#-17#$-#|#+2- #|23#",0
     10  2bc0
      0  2bc0					      START_CAVE	TowC
      1  2bc0				   CAVE_START SET	*
      2  2bc0		       00 05	   BANK_CAVE_TowC =	_CURRENT_BANK
      3  2bc0				   CAVE_TowC  SUBROUTINE
      4  2bc0				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2bc0
     12  2bc0		       34 2d 35 23*	      .byte.b	"4-5#|4-#3-#|4-#$2-#|2-3#2-$2#|2-#2-$-$-#|3#-#-2#-#3-6#|#3-#-2#-5#2-2.#|#-$2-$10-2.#|5#-3#-#@2#2-2.#|4-#5-9#|4-7#",0
      0  2c31					      END_CAVE	TowC
      1  2c31		       ff		      .byte.b	$FF
      2  2c31		       00 72	   CAVE_SIZE_TowC =	* - CAVE_START
      3  2c32					      IF	CAVE_SIZE_TowC > MAX_CAVE_SIZE
      4  2c32				   MAX_CAVE_SIZE SET	CAVE_SIZE_TowC
      5  2c32					      ENDIF
     14  2c32
      0  2c32					      START_CAVE	SimpleC
      1  2c32				   CAVE_START SET	*
      2  2c32		       00 05	   BANK_CAVE_SimpleC =	_CURRENT_BANK
      3  2c32				   CAVE_SimpleC SUBROUTINE
      4  2c32				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2c32
     16  2c32		       37 23 7c 23*	      .byte.b	"7#|#.@-#-#|#$*-$-#|#3-$-#|#-..--#|#--*--#|7#",0
      0  2c5f					      END_CAVE	SimpleC
      1  2c5f		       ff		      .byte.b	$FF
      2  2c5f		       00 2e	   CAVE_SIZE_SimpleC =	* - CAVE_START
      3  2c60				  -	      IF	CAVE_SIZE_SimpleC > MAX_CAVE_SIZE
      4  2c60				  -MAX_CAVE_SIZE SET	CAVE_SIZE_SimpleC
      5  2c60					      ENDIF
     18  2c60
      0  2c60					      START_CAVE	bAlfa_DrFogh
      1  2c60				   CAVE_START SET	*
      2  2c60		       00 05	   BANK_CAVE_bAlfa_DrFogh =	_CURRENT_BANK
      3  2c60				   CAVE_bAlfa_DrFogh SUBROUTINE
      4  2c60				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2c60
     20  2c60		       32 2d 34 23*	      .byte.b	"2-4#2-4#|-2#2-2#-#2-#|-#4-3#2-2#|2#2-2*2-#.2-2#|#2-*2-*-#*#2-#|#-*4-2*2-#-#|#-*-2#-*3-#-#|2#-*2-*#*#-#-#|-#$-2*-#-*-#-#|-#@#2-2#5-#|-2#2-4#2-3#|2-#2-#2-4#|2-#2-#|2-4#",0
      0  2d07					      END_CAVE	bAlfa_DrFogh
      1  2d07		       ff		      .byte.b	$FF
      2  2d07		       00 a8	   CAVE_SIZE_bAlfa_DrFogh =	* - CAVE_START
      3  2d08					      IF	CAVE_SIZE_bAlfa_DrFogh > MAX_CAVE_SIZE
      4  2d08				   MAX_CAVE_SIZE SET	CAVE_SIZE_bAlfa_DrFogh
      5  2d08					      ENDIF
     22  2d08
      0  2d08					      START_CAVE	b51X_Sharpen
      1  2d08				   CAVE_START SET	*
      2  2d08		       00 05	   BANK_CAVE_b51X_Sharpen =	_CURRENT_BANK
      3  2d08				   CAVE_b51X_Sharpen SUBROUTINE
      4  2d08				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2d08
     24  2d08		       2d 39 23 33*	      .byte.b	"-9#3-|-#7-#3-|-#-$-2$-$#3-|3#$#2-$-#3-|#.#3-2$-2#2-|#.3#3-$-#2-|#.#.-$-2#-3#|#3.$-$2#-$-#|#3.$3-$2-@#|#2.3#$3#-2#|#4.#5-#-|12#-",0
      0  2d88					      END_CAVE	b51X_Sharpen
      1  2d88		       ff		      .byte.b	$FF
      2  2d88		       00 81	   CAVE_SIZE_b51X_Sharpen =	* - CAVE_START
      3  2d89				  -	      IF	CAVE_SIZE_b51X_Sharpen > MAX_CAVE_SIZE
      4  2d89				  -MAX_CAVE_SIZE SET	CAVE_SIZE_b51X_Sharpen
      5  2d89					      ENDIF
     26  2d89
      0  2d89					      START_CAVE	bDarcy_Burnsell101
      1  2d89				   CAVE_START SET	*
      2  2d89		       00 05	   BANK_CAVE_bDarcy_Burnsell101 =	_CURRENT_BANK
      3  2d89				   CAVE_bDarcy_Burnsell101 SUBROUTINE
      4  2d89				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2d89
     28  2d89		       38 23 7c 23*	      .byte.b	"8#|#2-.-$@#|#.#$*2$#|#2-.-*-#|#2$-2$.#|#.#-#2-#|#.2-.-.#|8#",0
      0  2dc5					      END_CAVE	bDarcy_Burnsell101
      1  2dc5		       ff		      .byte.b	$FF
      2  2dc5		       00 3d	   CAVE_SIZE_bDarcy_Burnsell101 =	* - CAVE_START
      3  2dc6				  -	      IF	CAVE_SIZE_bDarcy_Burnsell101 > MAX_CAVE_SIZE
      4  2dc6				  -MAX_CAVE_SIZE SET	CAVE_SIZE_bDarcy_Burnsell101
      5  2dc6					      ENDIF
     30  2dc6
      0  2dc6					      START_CAVE	bAislin101
      1  2dc6				   CAVE_START SET	*
      2  2dc6		       00 05	   BANK_CAVE_bAislin101 =	_CURRENT_BANK
      3  2dc6				   CAVE_bAislin101 SUBROUTINE
      4  2dc6				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2dc6
     32  2dc6		       38 23 7c 32*	      .byte.b	"8#|2#-*-*.#|#2.$-$*#|#-.#-*.#|2#-$-$2#|#-#$-$-#|#2.2-$@#|8#",0
      0  2e02					      END_CAVE	bAislin101
      1  2e02		       ff		      .byte.b	$FF
      2  2e02		       00 3d	   CAVE_SIZE_bAislin101 =	* - CAVE_START
      3  2e03				  -	      IF	CAVE_SIZE_bAislin101 > MAX_CAVE_SIZE
      4  2e03				  -MAX_CAVE_SIZE SET	CAVE_SIZE_bAislin101
      5  2e03					      ENDIF
     34  2e03
      0  2e03					      START_CAVE	b82X_Sharpen
      1  2e03				   CAVE_START SET	*
      2  2e03		       00 05	   BANK_CAVE_b82X_Sharpen =	_CURRENT_BANK
      3  2e03				   CAVE_b82X_Sharpen SUBROUTINE
      4  2e03				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2e03
     36  2e03		       2d 31 31 23*	      .byte.b	"-11#8-|-#5-#3-2#7-|-#-$-$-$-#2-5#3-|-3#2-5#5-#3-|-#4.#5-3#-#3-|-#.4#2-4#3-#3-|-#4.4-#2-$-2#3-|-#-3.#3-#-3$5#|3#.7#2-$@$3-#|#-$3-5#-$-2#3-#|#-#.#-$6-$3#$-#|#-#.8#2-#2-$-#|#-#3.7-2#-2$-#|#3-7#-$-#-#2-#|5#5-#7-2#|10-9#-",0
      0  2edc					      END_CAVE	b82X_Sharpen
      1  2edc		       ff		      .byte.b	$FF
      2  2edc		       00 da	   CAVE_SIZE_b82X_Sharpen =	* - CAVE_START
      3  2edd					      IF	CAVE_SIZE_b82X_Sharpen > MAX_CAVE_SIZE
      4  2edd				   MAX_CAVE_SIZE SET	CAVE_SIZE_b82X_Sharpen
      5  2edd					      ENDIF
     38  2edd
      0  2edd					      START_CAVE	Thomas_Reinke16
      1  2edd				   CAVE_START SET	*
      2  2edd		       00 05	   BANK_CAVE_Thomas_Reinke16 =	_CURRENT_BANK
      3  2edd				   CAVE_Thomas_Reinke16 SUBROUTINE
      4  2edd				   MAX_CAVE_NUMBER SET	MAX_CAVE_NUMBER + 1
      5  2edd
     40  2edd		       2d 35 23 7c*	      .byte.b	"-5#|2#3-3#|#6-2#|#-#-2#2-#|#2.*2-#-#|#2-*2-#-#|3#*2$2-#|2-#@-4#|2-4#",0
      0  2f22					      END_CAVE	Thomas_Reinke16
      1  2f22		       ff		      .byte.b	$FF
      2  2f22		       00 46	   CAVE_SIZE_Thomas_Reinke16 =	* - CAVE_START
      3  2f23				  -	      IF	CAVE_SIZE_Thomas_Reinke16 > MAX_CAVE_SIZE
      4  2f23				  -MAX_CAVE_SIZE SET	CAVE_SIZE_Thomas_Reinke16
      5  2f23					      ENDIF
     42  2f23							;Level element	Character	ASCII Code
     43  2f23							;Wall	#	0x23
     44  2f23							;Player	@	0x40
     45  2f23							;Player on goal square	+	0x2b
     46  2f23							;Box	$	0x24
     47  2f23							;Box on goal square	*	0x2a
     48  2f23							;Goal square	.	0x2e
     49  2f23							;Floor	(Space)	0x20 or underscore
     50  2f23
     51  2f23							;This level ("Claire", by Lee J Haywood):
     52  2f23
     53  2f23							;#######
     54  2f23							;#.@ # #
     55  2f23							;#$* $ #
     56  2f23							;#   $ #
     57  2f23							;# ..	#
     58  2f23							;#  *	#
     59  2f23							;#######
     60  2f23							;runlength encoded looks like this:
     61  2f23
     62  2f23							;The rows of the level are separated by "|"s. There has been a discussion in the Yahoo Group about what character should represent an empty square in May 2006. Finally the hyphen has been elected to be the standard character for an empty square. Nevertheless, programs are encouraged to support both, hyphens and underscores.
     63  2f23
     64  2f23							;If only two level elements are grouped together they may be run length encoded, but needn't to. Example:
     65  2f23
     66  2f23
     67  2f23							; ECHO "MAX CAVE SIZE = ", MAX_CAVE_SIZE
------- FILE BANK_ROM_SHADOW_SCORING.asm
   1183  2f23
      0  2f23					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  2f23		       07 23	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $723 , FREE= $dd
      2  2f23					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2f23				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2f23				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2f23				  -	      ERR
      6  2f23					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 3
      0  2f23					      include	"BANK_GENERIC.asm"
      1  2f23							;------------------------------------------------------------------------------
      2  2f23							;##############################################################################
      3  2f23							;------------------------------------------------------------------------------
      4  2f23
      0  2f23					      NEWBANK	GENERIC_BANK_1
      1  371e ????				      SEG	GENERIC_BANK_1
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	GENERIC_BANK_1
      6  3000
      7  3000
      8  3000
      0  3000					      DEFINE_1K_SEGMENT	DECODE_CAVE_SHADOW
      1  3000					      ALIGN	$400
      2  3000				   SEGMENT_DECODE_CAVE_SHADOW SET	*
      3  3000				   BANK_DECODE_CAVE_SHADOW SET	_CURRENT_BANK
------- FILE DecodeCave.asm LEVEL 3 PASS 3
      0  3000					      include	"DecodeCave.asm"
      1  3000							;TODOs:
      2  3000							;+ load cave from ROM
      3  3000							;- remove delimiter
      4  3000							;+ variable board sizes
      5  3000							;- use Andrew's character ids
      6  3000							;+ store other cave parameter (times, diamonds, points etc.)
      7  3000
      8  3000							;---------------------------------------------------------------------------
      9  3000							; Board area must not overlap page boundary, as writing code uses indexing to save
     10  3000
      0  3000					      OPTIONAL_PAGEBREAK	"BOARD_DATA_AREA", MAX_CAVE_SIZE
     10  3000					      LIST	ON
     12  3000				   BOARD_DATA_AREA
     13  3000		       ff ff ff ff*	      ds	MAX_CAVE_SIZE,$FF
     14  30da
     15  30da							;---------------------------------------------------------------------------
     16  30da
     17  30da
     18  30da
     19  30da
     20  30da							;ThrottleSpeedTbl
     21  30da							;; based on MAX_THROTTLE = 160, NTSC_276/PAL (312/276=1.13)
     22  30da							;    .byte   19, 22  ; level 1 (E1: 5.60s) 1,16; 1.00/1.00 (1.00)
     23  30da							;    .byte   22, 26  ; level 2 (E2  4.80s) 1,18  1.16/1.18 (1.17)
     24  30da							;    .byte   24, 28  ; level 3 (E3: 4.40s) 1,16  1.26/1.27 (1.27)
     25  30da							;    .byte   26, 30  ; level 4 (E4: 4.17s) 1,15  1.37/1.36 (1.34)
     26  30da							;    .byte   27, 31  ; level 5 (E5: 4.00s) 1,14; 1.42/1.41 (1.40)
     27  30da
     28  30da							; *** local constants for cava data: ***
     29  30da
     30  30da		       00 04	   .NUM_RANDOM =	4	; number of random objects
     31  30da
     32  30da		       00 01	   .SIZE_OFS  =	1	; -1
     33  30da		       00 03	   .MAGIC_OFS =	3
     34  30da		       00 04	   .WORTH_OFS =	4
     35  30da		       00 05	   .EXTRA_WORTH_OFS =	5
     36  30da		       00 0b	   .DIAMONDS_OFS =	11
     37  30da		       00 10	   .TIME_OFS  =	16
     38  30da		       00 06	   .RND_INIT_OFS =	$04+2	; -1
     39  30da		       00 1b	   .RND_OBJECT_OFS =	$18+3	; -3
     40  30da		       00 1f	   .RND_VALUE_OFS =	$1c+3	; -3
     41  30da		       00 15	   .COLOR_OFS =	$13+2
     42  30da
     43  30da		       00 23	   .STRUCT_OFFSET =	$20+3	; -3
     44  30da		       00 ff	   .STRUCT_DELIMITER =	$ff
     45  30da		       00 c0	   .STRUCTURE_MASK =	%11000000
     46  30da
     47  30da		       00 00	   .STRUCT_SINGLE =	%00 << 6
     48  30da							;.STRUCT_LINE	      = LINE
     49  30da							;.STRUCT_FILLED      = FILL
     50  30da							;.STRUCT_RECTANGLE   = RECT
     51  30da		       00 40	   .STRUCT_LINE =	%01 << 6
     52  30da		       00 80	   .STRUCT_FILLED =	%10 << 6
     53  30da		       00 c0	   .STRUCT_RECTANGLE =	%11 << 6
     54  30da							;POINT 	      = .STRUCT_POINT
     55  30da		       00 80	   FILL       =	.STRUCT_FILLED
     56  30da		       00 40	   LINE       =	.STRUCT_LINE
     57  30da		       00 c0	   RECT       =	.STRUCT_RECTANGLE
     58  30da
     59  30da		       00 00	   .DIR_UP    =	0
     60  30da		       00 02	   .DIR_RIGHT =	2
     61  30da		       00 04	   .DIR_DOWN  =	4
     62  30da		       00 06	   .DIR_LEFT  =	6
     63  30da
     64  30da				   CAVENUM    SET	0
     65  30da		       00 04	   CAVE_DATA_SIZE =	4
     66  30da
     67  30da					      MAC	add_cave
     68  30da				   CAVE_ACTIVE_{1} SET	1
     69  30da				   CAVE_NAMED_{1} =	CAVENUM
     70  30da					      .byte	<CAVE_{1}
     71  30da					      .byte	>CAVE_{1}
     72  30da					      .byte	BANK_CAVE_{1}
     73  30da					      .byte	CAVE_SIZE_{1}
     74  30da				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
     75  30da					      ENDM		; {name}
     76  30da
     77  30da				   CaveInformation
     78  30da
     79  30da							; The ordering here corresponds to the ordering when playing...
     80  30da					      IF	FINAL_VERSION = YES || DEMO_VERSION = NO
      0  30da					      ADD_CAVE	TowC
      1  30da				   CAVE_ACTIVE_TowC SET	1
      2  30da		       00 00	   CAVE_NAMED_TowC =	CAVENUM
      3  30da		       c0		      .byte.b	<CAVE_TowC
      4  30db		       f3		      .byte.b	>CAVE_TowC
      5  30dc		       05		      .byte.b	BANK_CAVE_TowC
      6  30dd		       72		      .byte.b	CAVE_SIZE_TowC
      7  30dd				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  30de					      ADD_CAVE	SimpleC
      1  30de				   CAVE_ACTIVE_SimpleC SET	1
      2  30de		       00 04	   CAVE_NAMED_SimpleC =	CAVENUM
      3  30de		       32		      .byte.b	<CAVE_SimpleC
      4  30df		       f4		      .byte.b	>CAVE_SimpleC
      5  30e0		       05		      .byte.b	BANK_CAVE_SimpleC
      6  30e1		       2e		      .byte.b	CAVE_SIZE_SimpleC
      7  30e1				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  30e2					      ADD_CAVE	Thomas_Reinke16
      1  30e2				   CAVE_ACTIVE_Thomas_Reinke16 SET	1
      2  30e2		       00 08	   CAVE_NAMED_Thomas_Reinke16 =	CAVENUM
      3  30e2		       dd		      .byte.b	<CAVE_Thomas_Reinke16
      4  30e3		       f6		      .byte.b	>CAVE_Thomas_Reinke16
      5  30e4		       05		      .byte.b	BANK_CAVE_Thomas_Reinke16
      6  30e5		       46		      .byte.b	CAVE_SIZE_Thomas_Reinke16
      7  30e5				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  30e6					      ADD_CAVE	bAlfa_DrFogh
      1  30e6				   CAVE_ACTIVE_bAlfa_DrFogh SET	1
      2  30e6		       00 0c	   CAVE_NAMED_bAlfa_DrFogh =	CAVENUM
      3  30e6		       60		      .byte.b	<CAVE_bAlfa_DrFogh
      4  30e7		       f4		      .byte.b	>CAVE_bAlfa_DrFogh
      5  30e8		       05		      .byte.b	BANK_CAVE_bAlfa_DrFogh
      6  30e9		       a8		      .byte.b	CAVE_SIZE_bAlfa_DrFogh
      7  30e9				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  30ea					      ADD_CAVE	b51X_Sharpen
      1  30ea				   CAVE_ACTIVE_b51X_Sharpen SET	1
      2  30ea		       00 10	   CAVE_NAMED_b51X_Sharpen =	CAVENUM
      3  30ea		       08		      .byte.b	<CAVE_b51X_Sharpen
      4  30eb		       f5		      .byte.b	>CAVE_b51X_Sharpen
      5  30ec		       05		      .byte.b	BANK_CAVE_b51X_Sharpen
      6  30ed		       81		      .byte.b	CAVE_SIZE_b51X_Sharpen
      7  30ed				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  30ee					      ADD_CAVE	bDarcy_Burnsell101
      1  30ee				   CAVE_ACTIVE_bDarcy_Burnsell101 SET	1
      2  30ee		       00 14	   CAVE_NAMED_bDarcy_Burnsell101 =	CAVENUM
      3  30ee		       89		      .byte.b	<CAVE_bDarcy_Burnsell101
      4  30ef		       f5		      .byte.b	>CAVE_bDarcy_Burnsell101
      5  30f0		       05		      .byte.b	BANK_CAVE_bDarcy_Burnsell101
      6  30f1		       3d		      .byte.b	CAVE_SIZE_bDarcy_Burnsell101
      7  30f1				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  30f2					      ADD_CAVE	bAislin101
      1  30f2				   CAVE_ACTIVE_bAislin101 SET	1
      2  30f2		       00 18	   CAVE_NAMED_bAislin101 =	CAVENUM
      3  30f2		       c6		      .byte.b	<CAVE_bAislin101
      4  30f3		       f5		      .byte.b	>CAVE_bAislin101
      5  30f4		       05		      .byte.b	BANK_CAVE_bAislin101
      6  30f5		       3d		      .byte.b	CAVE_SIZE_bAislin101
      7  30f5				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
      0  30f6					      ADD_CAVE	b82X_Sharpen
      1  30f6				   CAVE_ACTIVE_b82X_Sharpen SET	1
      2  30f6		       00 1c	   CAVE_NAMED_b82X_Sharpen =	CAVENUM
      3  30f6		       03		      .byte.b	<CAVE_b82X_Sharpen
      4  30f7		       f6		      .byte.b	>CAVE_b82X_Sharpen
      5  30f8		       05		      .byte.b	BANK_CAVE_b82X_Sharpen
      6  30f9		       da		      .byte.b	CAVE_SIZE_b82X_Sharpen
      7  30f9				   CAVENUM    SET	CAVENUM + CAVE_DATA_SIZE
     89  30fa					      ENDIF
     90  30fa
     91  30fa							; undo/rewind
     92  30fa							; move counter
     93  30fa							;counter of #targets left
     94  30fa							; digits
     95  30fa							; character/animations
     96  30fa							; cave table pointers
     97  30fa							; color randomize
     98  30fa							; more levels
     99  30fa							; (timer)?
    100  30fa							; hihg "score"  and savekey
    101  30fa							; password for level unlocks
    102  30fa							; title screen
    103  30fa
    104  30fa
    105  30fa				   finX
    106  30fa							; now put the soil in - fill from the outsides
    107  30fa
    108  30fa		       a9 01		      lda	#CHARACTER_SOIL
    109  30fc		       85 8e		      sta	POS_Type
    110  30fe
    111  30fe		       a9 15		      lda	#SIZE_BOARD_Y-1
    112  3100		       85 8b		      sta	POS_Y
    113  3102
    114  3102		       a9 27	   xlin       lda	#SIZE_BOARD_X-1
    115  3104		       85 8a		      sta	POS_X
    116  3106		       20 53 f8    zap1       jsr	GetBoardCharacter__CALL_FROM_RAM__
    117  3109		       c9 01		      cmp	#CHARACTER_SOIL
    118  310b		       f0 07		      beq	kg2a
    119  310d		       c9 00		      cmp	#0
    120  310f		       d0 07		      bne	endzap1
    121  3111		       20 67 f8 	      jsr	PutBoardCharacterFromRAM
    122  3114		       c6 8a	   kg2a       dec	POS_X
    123  3116		       10 ee		      bpl	zap1
    124  3118
    125  3118		       a9 00	   endzap1    lda	#0
    126  311a		       85 8a		      sta	POS_X
    127  311c		       20 53 f8    zap2       jsr	GetBoardCharacter__CALL_FROM_RAM__
    128  311f		       c9 01		      cmp	#CHARACTER_SOIL
    129  3121		       f0 07		      beq	kg2
    130  3123		       c9 00		      cmp	#0
    131  3125		       d0 0b		      bne	endzap2
    132  3127		       20 67 f8 	      jsr	PutBoardCharacterFromRAM
    133  312a		       e6 8a	   kg2	      inc	POS_X
    134  312c		       a5 8a		      lda	POS_X
    135  312e		       c9 28		      cmp	#SIZE_BOARD_X
    136  3130		       d0 ea		      bne	zap2
    137  3132
    138  3132		       c6 8b	   endzap2    dec	POS_Y
    139  3134		       10 cc		      bpl	xlin
    140  3136
    141  3136
    142  3136		       a9 27		      lda	#SIZE_BOARD_X-1
    143  3138		       85 8a		      sta	POS_X
    144  313a
    145  313a		       a9 15	   ylin       lda	#SIZE_BOARD_Y-1
    146  313c		       85 8b		      sta	POS_Y
    147  313e		       20 53 f8    zapy1      jsr	GetBoardCharacter__CALL_FROM_RAM__
    148  3141		       c9 01		      cmp	#CHARACTER_SOIL
    149  3143		       f0 07		      beq	kg3
    150  3145		       c9 00		      cmp	#0
    151  3147		       d0 07		      bne	endzapy1
    152  3149		       20 67 f8 	      jsr	PutBoardCharacterFromRAM
    153  314c		       c6 8b	   kg3	      dec	POS_Y
    154  314e		       10 ee		      bpl	zapy1
    155  3150
    156  3150		       a9 00	   endzapy1   lda	#0
    157  3152		       85 8b		      sta	POS_Y
    158  3154		       20 53 f8    zapy2      jsr	GetBoardCharacter__CALL_FROM_RAM__
    159  3157		       c9 01		      cmp	#CHARACTER_SOIL
    160  3159		       f0 07		      beq	kg3b
    161  315b		       c9 00		      cmp	#0
    162  315d		       d0 0b		      bne	endzapy2
    163  315f		       20 67 f8 	      jsr	PutBoardCharacterFromRAM
    164  3162		       e6 8b	   kg3b       inc	POS_Y
    165  3164		       a5 8b		      lda	POS_Y
    166  3166		       c9 16		      cmp	#SIZE_BOARD_Y
    167  3168		       d0 ea		      bne	zapy2
    168  316a
    169  316a		       c6 8a	   endzapy2   dec	POS_X
    170  316c		       10 cc		      bpl	ylin
    171  316e		       60		      rts
    172  316f
      0  316f					      DEFINE_SUBROUTINE	RegisterOneMoreTarget
      1  316f		       00 06	   BANK_RegisterOneMoreTarget =	_CURRENT_BANK
      2  316f					      SUBROUTINE
      3  316f				   RegisterOneMoreTarget
    174  316f
    175  316f		       f8		      sed
    176  3170		       18		      clc
    177  3171		       a5 b6		      lda	targetsRequired
    178  3173		       69 01		      adc	#1
    179  3175		       85 b6		      sta	targetsRequired
    180  3177		       d8		      cld
    181  3178		       60		      rts
    182  3179
    183  3179
      0  3179					      DEFINE_SUBROUTINE	UnpackLevel
      1  3179		       00 06	   BANK_UnpackLevel =	_CURRENT_BANK
      2  3179					      SUBROUTINE
      3  3179				   UnpackLevel
    185  3179
    186  3179		       85 c2		      sta	RAM_Bank
    187  317b
    188  317b							; has to be done before decoding the cave to have the platform right:
      0  317b					      SET_PLATFORM
      1  317b
      2  317b
      3  317b
      4  317b
      5  317b		       ad 82 02 	      lda	SWCHB
      6  317e		       2a		      rol
      7  317f		       2a		      rol
      8  3180		       2a		      rol
      9  3181		       29 03		      and	#%11
     10  3183					      if	NTSC_MODE = NO
     11  3183		       49 02		      eor	#PAL
     12  3185					      endif
     13  3185		       a9 00		      lda	#0
     14  3187		       85 81		      sta	Platform
    190  3189
    191  3189		       a9 00		      lda	#CHARACTER_BLANK
    192  318b		       85 8e		      sta	POS_Type
    193  318d
    194  318d		       a9 15		      lda	#SIZE_BOARD_Y-1
    195  318f		       85 8b		      sta	POS_Y
    196  3191		       a9 27	   xyLine     lda	#SIZE_BOARD_X-1
    197  3193		       85 8a		      sta	POS_X
    198  3195		       20 67 f8    xyClear    jsr	PutBoardCharacterFromRAM
    199  3198		       c6 8a		      dec	POS_X
    200  319a		       10 f9		      bpl	xyClear
    201  319c		       c6 8b		      dec	POS_Y
    202  319e		       10 f1		      bpl	xyLine
    203  31a0
    204  31a0		       a9 06		      lda	#6
    205  31a2		       85 e7		      sta	base_x
    206  31a4		       85 e8		      sta	base_y
    207  31a6
    208  31a6		       a5 c7		      lda	NextLevelTrigger
    209  31a8		       09 80		      ora	#BIT_NEXTLEVEL
    210  31aa		       85 c7		      sta	NextLevelTrigger
    211  31ac
    212  31ac		       a4 b1		      ldy	cave
    213  31ae		       38		      sec
    214  31af		       b9 da f0 	      lda	CaveInformation,y
    215  31b2		       e9 01		      sbc	#1
    216  31b4		       85 bd		      sta	Board_AddressR
    217  31b6		       b9 db f0 	      lda	CaveInformation+1,y
    218  31b9		       e9 00		      sbc	#0
    219  31bb		       85 be		      sta	Board_AddressR+1
    220  31bd		       b9 dc f0 	      lda	CaveInformation+2,y
    221  31c0		       85 ad		      sta	cave_bank
    222  31c2
    223  31c2		       a9 06		      lda	#BANK_UnpackLevel	; the *ROM* bank of this routine (NOT RAM)
    224  31c4		       85 c1		      sta	ROM_Bank	; GetROMByte returns to this bank
    225  31c6
    226  31c6							;NEXT_RANDOM
    227  31c6							;and #$F0
    228  31c6							;ora #$A
    229  31c6		       a9 8a		      lda	#$8a	;ba
    230  31c8		       85 ba		      sta	color
    231  31ca		       a9 44		      lda	#$44
    232  31cc							;lda #$A0
    233  31cc		       85 bb		      sta	color+1
    234  31ce		       a9 2a		      lda	#$2a	;lda #$9C
    235  31d0		       85 bc		      sta	color+2
    236  31d2
    237  31d2		       a9 00		      lda	#$00
    238  31d4		       85 b7		      sta	caveTime
    239  31d6		       85 b8		      sta	caveTimeHi
    240  31d8
    241  31d8		       a9 00		      lda	#$00	; BCD reminder!
    242  31da		       85 b6		      sta	targetsRequired	; # of targets that do NOT have boxes on them
    243  31dc
    244  31dc							;lda #SIZE_BOARD_X
    245  31dc							;sta BoardLimit_Width
    246  31dc							;lda #SIZE_BOARD_Y
    247  31dc							;sta BoardLimit_Height
    248  31dc							;lda #$5
    249  31dc							;sta targetsRequired		   ;	   should never be 0
    250  31dc
    251  31dc		       a9 18		      lda	#24	; arbitrary
    252  31de		       85 b5		      sta	ThrottleSpeed
    253  31e0
    254  31e0							; first fill bg with character_soil
    255  31e0							; then rle unpack level
    256  31e0							; change level colours
    257  31e0
    258  31e0		       a9 00		      lda	#0
    259  31e2		       85 8a		      sta	POS_X
    260  31e4		       85 8b		      sta	POS_Y
    261  31e6		       85 93		      sta	BoardLimit_Width
    262  31e8		       85 94		      sta	BoardLimit_Height
    263  31ea
    264  31ea				   GetNextItem
    265  31ea
    266  31ea		       a9 01		      lda	#1
    267  31ec		       85 e9		      sta	upk_length
    268  31ee		       a9 00		      lda	#0
    269  31f0		       85 ea		      sta	upk_column	; reuse var - this flags a digit already
    270  31f2
    271  31f2		       e6 bd	   Get2       inc	Board_AddressR
    272  31f4		       d0 02		      bne	addrOK
    273  31f6		       e6 be		      inc	Board_AddressR+1
    274  31f8				   addrOK
    275  31f8
    276  31f8		       a5 ad		      lda	cave_bank
    277  31fa		       a0 00		      ldy	#0
    278  31fc		       20 3c f8 	      jsr	GetROMByte
    279  31ff		       85 eb		      sta	upk_temp	;scratch
    280  3201
    281  3201
    282  3201		       c9 00		      cmp	#0
    283  3203		       d0 03		      bne	parse
    284  3205		       4c fa f0 	      jmp	finX
    285  3208				   parse
    286  3208		       c9 3a		      cmp	#"9"+1
    287  320a		       b0 1e		      bcs	notDigit
    288  320c		       c9 30		      cmp	#"0"
    289  320e		       90 1a		      bcc	notDigit
    290  3210
    291  3210		       a5 ea		      lda	upk_column
    292  3212		       f0 09		      beq	firstDig
    293  3214
    294  3214		       a5 e9		      lda	upk_length
    295  3216		       0a		      asl
    296  3217		       0a		      asl
    297  3218		       0a		      asl
    298  3219		       65 e9		      adc	upk_length
    299  321b		       65 e9		      adc	upk_length
    300  321d
    301  321d		       18	   firstDig   clc
    302  321e		       65 eb		      adc	upk_temp
    303  3220		       38		      sec
    304  3221		       e9 30		      sbc	#"0"
    305  3223		       85 e9		      sta	upk_length
    306  3225		       e6 ea		      inc	upk_column	; flag we have seen a digit
    307  3227		       4c f2 f1 	      jmp	Get2
    308  322a
    309  322a		       c9 7c	   notDigit   cmp	#"|"	; newline
    310  322c		       d0 11		      bne	checkWall
    311  322e
    312  322e							; Handle new-line
    313  322e		       a9 00		      lda	#0
    314  3230		       85 8a		      sta	POS_X
    315  3232		       e6 8b		      inc	POS_Y
    316  3234
    317  3234
    318  3234		       a5 8b		      lda	POS_Y
    319  3236		       c5 94		      cmp	BoardLimit_Height
    320  3238		       90 02		      bcc	wOK2
    321  323a		       85 94		      sta	BoardLimit_Height	;???^^^
    322  323c				   wOK2
    323  323c
    324  323c		       4c ea f1 	      jmp	GetNextItem
    325  323f
    326  323f		       c9 23	   checkWall  cmp	#"#"	; wall
    327  3241		       d0 04		      bne	checkForGap
    328  3243		       a9 07		      lda	#CHARACTER_WALL
    329  3245		       d0 62		      bne	WriteChars
    330  3247
    331  3247		       c9 20	   checkForGap cmp	#32
    332  3249		       f0 08		      beq	writeGap
    333  324b		       c9 2d		      cmp	#"-"
    334  324d		       f0 04		      beq	writeGap
    335  324f		       c9 5f		      cmp	#"_"
    336  3251		       d0 05		      bne	checkForMan
    337  3253
    338  3253		       a9 00	   writeGap   lda	#CHARACTER_BLANK
    339  3255		       4c a9 f2 	      jmp	WriteChars
    340  3258
    341  3258				   checkForMan
    342  3258		       c9 2b		      cmp	#"+"	; player on goal square
    343  325a		       d0 07		      bne	notPlayerGoal
    344  325c
    345  325c		       20 6f f1 	      jsr	RegisterOneMoreTarget
    346  325f
    347  325f							; put goal square, init player with POS_VAR = CHARACTER_TARGET
    348  325f
    349  325f		       a9 03		      lda	#CHARACTER_TARGET
    350  3261		       d0 06		      bne	genPlayer
    351  3263
    352  3263				   notPlayerGoal
    353  3263		       c9 40		      cmp	#"@"	; player on normal square
    354  3265		       d0 29		      bne	checkBox
    355  3267
    356  3267		       a9 00		      lda	#CHARACTER_BLANK
    357  3269
    358  3269				   genPlayer
    359  3269
    360  3269		       85 8f		      sta	POS_VAR	; character man is on
    361  326b
    362  326b		       18		      clc
    363  326c		       a5 8a		      lda	POS_X
    364  326e		       48		      pha
    365  326f		       65 e7		      adc	base_x
    366  3271		       85 8a		      sta	POS_X
    367  3273		       85 99		      sta	ManX
    368  3275
    369  3275		       a5 8b		      lda	POS_Y
    370  3277		       48		      pha
    371  3278		       65 e8		      adc	base_y
    372  327a		       85 8b		      sta	POS_Y
    373  327c		       85 9a		      sta	ManY
    374  327e
    375  327e							; POS_X     x position
    376  327e							; POS_Y     y position
    377  327e							; POS_VAR   direction or other variable
    378  327e							; POS_Type  type of object
    379  327e
    380  327e		       a9 00		      lda	#TYPE_MAN
    381  3280		       85 8e		      sta	POS_Type	;	 creature TYPE
    382  3282		       20 b6 f9 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    383  3285
    384  3285		       68		      pla
    385  3286		       85 8b		      sta	POS_Y
    386  3288		       68		      pla
    387  3289		       85 8a		      sta	POS_X
    388  328b
    389  328b		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    390  328d		       4c a9 f2 	      jmp	WriteChars
    391  3290
    392  3290		       c9 24	   checkBox   cmp	#"$"
    393  3292		       d0 04		      bne	checkBoxTarget
    394  3294
    395  3294		       a9 02		      lda	#CHARACTER_BOX
    396  3296		       d0 11		      bne	WriteChars
    397  3298
    398  3298		       c9 2a	   checkBoxTarget cmp	#"*"
    399  329a		       d0 04		      bne	checkTarget
    400  329c
    401  329c		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    402  329e		       d0 09		      bne	WriteChars
    403  32a0
    404  32a0		       c9 2e	   checkTarget cmp	#"."
    405  32a2		       f0 03		      beq	targ
    406  32a4		       4c ea f1 	      jmp	GetNextItem
    407  32a7				   targ
    408  32a7
    409  32a7		       a9 03		      lda	#CHARACTER_TARGET
    410  32a9
    411  32a9		       85 8e	   WriteChars sta	POS_Type
    412  32ab
    413  32ab		       18	   Wc2x       clc
    414  32ac		       a5 8a		      lda	POS_X
    415  32ae		       48		      pha
    416  32af		       65 e7		      adc	base_x
    417  32b1		       85 8a		      sta	POS_X
    418  32b3
    419  32b3		       a5 8b		      lda	POS_Y
    420  32b5		       48		      pha
    421  32b6		       65 e8		      adc	base_y
    422  32b8		       85 8b		      sta	POS_Y
    423  32ba
    424  32ba		       20 67 f8 	      jsr	PutBoardCharacterFromRAM
    425  32bd
    426  32bd		       a5 8e		      lda	POS_Type
    427  32bf		       c9 03		      cmp	#CHARACTER_TARGET
    428  32c1		       d0 03		      bne	notargdet
    429  32c3		       20 6f f1 	      jsr	RegisterOneMoreTarget
    430  32c6				   notargdet
    431  32c6
    432  32c6		       68		      pla
    433  32c7		       85 8b		      sta	POS_Y
    434  32c9		       68		      pla
    435  32ca		       85 8a		      sta	POS_X
    436  32cc
    437  32cc		       18		      clc
    438  32cd		       69 01		      adc	#1
    439  32cf		       85 8a		      sta	POS_X
    440  32d1
    441  32d1		       c5 93		      cmp	BoardLimit_Width
    442  32d3		       90 02		      bcc	wOK
    443  32d5		       85 93		      sta	BoardLimit_Width
    444  32d7				   wOK
    445  32d7
    446  32d7		       c6 e9		      dec	upk_length
    447  32d9		       d0 d0		      bne	Wc2x
    448  32db		       4c ea f1 	      jmp	GetNextItem
    449  32de
    450  32de				   finishedUnpack
    451  32de
    452  32de		       60		      rts
    453  32de					      endif
------- FILE BANK_GENERIC.asm
     11  32df
      0  32df					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_CAVE)"
      1  32df
      2  32df
      3  32df		       02 df	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_CAVE) (1K) SIZE =  $2df , FREE= $121
      4  32df					      ECHO	"GENERIC_BANK_1 (DECODE_CAVE)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  32df				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  32df				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  32df				  -	      ERR
      8  32df					      endif
     13  32df
     14  32df							;------------------------------------------------------------------------------
     15  32df							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     16  32df							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     17  32df							; bank finishes.  Just continue on from where it left off...
     18  32df							;------------------------------------------------------------------------------
     19  32df
      0  32df					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  32df		       00 06	   BANK_Cart_Init =	_CURRENT_BANK
      2  32df					      SUBROUTINE
      3  32df				   Cart_Init
     21  32df
     22  32df							; Note the variables from the title selection are incredibly transient an can be stomped
     23  32df							; at any time.  So they need to be used immediately.
     24  32df
     25  32df
     26  32df							; odd usage below is to prevent any possibility of variable stomping/assumptions
     27  32df
     28  32df		       a5 82		      lda	sCave	; cave # from title select
     29  32e1		       48		      pha
     30  32e2		       a9 01		      lda	#1	;sPlayers
     31  32e4		       a6 83		      ldx	sLevel	; level # from title select
     32  32e6		       a4 85		      ldy	sJoysticks
     33  32e8		       84 a6		      sty	jtoggle
     34  32ea		       86 b2		      stx	level
     35  32ec		       85 a5		      sta	ManCount	; = #players
     36  32ee		       68		      pla
     37  32ef		       a9 00		      lda	#0	;tmp
     38  32f1		       85 b1		      sta	cave	; make an immediate copy to safe variables!
     39  32f3
     40  32f3							;    IF FINAL_VERSION
     41  32f3							;		  asl
     42  32f3							;		  asl
     43  32f3							;		  adc cave					 ; *5 because it only cycles 0/1/2/3 equaing to caves 0/5/10/15
     44  32f3							;		  sta cave
     45  32f3							;    ENDIF
     46  32f3		       85 e4		      sta	startCave
     47  32f5
     48  32f5							; multiply with CAVE_DATA_SIZE (5):
     49  32f5		       0a		      asl
     50  32f6		       0a		      asl
     51  32f7							;		  adc cave
     52  32f7		       85 b1		      sta	cave
     53  32f9
     54  32f9		       a9 01		      lda	#1
     55  32fb		       85 98		      sta	whichPlayer	; will switch to 0 on 1st go
     56  32fd
     57  32fd		       a9 30		      lda	#NUM_LIVES<<4	; 3 lives
     58  32ff		       a6 a5		      ldx	ManCount	; = sPlayers
     59  3301		       f0 02		      beq	opg
     60  3303		       a9 33		      lda	#NUM_LIVES<<4|NUM_LIVES
     61  3305		       85 a5	   opg	      sta	ManCount	; P2P1 nybble each
     62  3307
     63  3307							;---------------------------------------------------------------------------
     64  3307
     65  3307		       a9 00		      lda	#0
     66  3309		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     67  330c		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     68  330f		       85 6b		      sta	HMCLR
     69  3311
     70  3311							; cleanup remains of title screen
     71  3311		       85 5b		      sta	GRP0
     72  3313		       85 5c		      sta	GRP1
     73  3315		       85 5b		      sta	GRP0
     74  3317
     75  3317		       85 89		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     76  3319		       85 a7		      sta	circle_d
     77  331b		       85 a8		      sta	circle_d+1
     78  331d
     79  331d							;    IFCONST DEBUG_CREATURE
     80  331d							;		  sta worstTime
     81  331d							;    ENDIF
     82  331d
     83  331d		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     84  331f		       85 4a		      sta	CTRLPF
     85  3321		       85 82		      sta	rnd	; anything non-0
     86  3323
     87  3323		       a9 ff		      lda	#$FF
     88  3325		       85 84		      sta	DrawStackPointer
     89  3327
     90  3327		       a9 07		      lda	#DIRECTION_BITS
     91  3329		       85 a2		      sta	ManLastDirection
     92  332b
     93  332b		       a9 00		      lda	#0
     94  332d							;		  sta ObjStackPtr		  ; object stack index of last entry
     95  332d							;		  sta ObjStackPtr+1
     96  332d							;		  sta ObjStackNum
     97  332d							;		  sta ObjIterator
     98  332d
     99  332d		       85 c9		      sta	sortPtr
    100  332f		       a9 ff		      lda	#<(-1)
    101  3331		       85 c8		      sta	sortRequired
    102  3333
    103  3333							; read high score from SaveKey and store in highScoreSK,
    104  3333							; which is transferred to high score variable in RAM by GeneralScoringSetups
    105  3333		       4c a8 f5 	      jmp	ReadSaveKey
    106  3336
    107  3336							;LEVEL0CREATURE  .byte TYPE_MAN,	  0,	  3,	  5
    108  3336							;		  .byte -1
    109  3336
    110  3336							;------------------------------------------------------------------------------
    111  3336
      0  3336					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  3336		       00 06	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  3336					      SUBROUTINE
      3  3336				   SwapPlayersGeneric
    113  3336
    114  3336							; at the start of a cave (or player, doesn't matter) we grab the current state of the colour/B&W switch
    115  3336							; into the gameMode variable.
    116  3336
    117  3336		       a5 80		      lda	gameMode
    118  3338		       29 77		      and	#~(BW_SWITCH|GAMEMODE_PAUSED)
    119  333a		       85 80		      sta	gameMode
    120  333c		       ad 82 02 	      lda	SWCHB
    121  333f		       29 08		      and	#BW_SWITCH
    122  3341		       05 80		      ora	gameMode	; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    123  3343		       85 80		      sta	gameMode	; also, BIT7=0 -- system is NOT paused
    124  3345
    125  3345
    126  3345							; restart cave
    127  3345		       a5 c7		      lda	NextLevelTrigger
    128  3347		       29 bf		      and	#<(~BIT_NEXTLIFE)
    129  3349		       85 c7		      sta	NextLevelTrigger
    130  334b
    131  334b							; if new high score was set by SwapPlayers, update it:
    132  334b
    133  334b		       4c ce f5 	      jmp	WriteSaveKey
    134  334e
    135  334e
    136  334e							;------------------------------------------------------------------------------
    137  334e
      0  334e					      DEFINE_SUBROUTINE	CreateCreatures
      1  334e		       00 06	   BANK_CreateCreatures =	_CURRENT_BANK
      2  334e					      SUBROUTINE
      3  334e				   CreateCreatures
    139  334e
    140  334e							; Calculate rightmost value for scrolling edge.  .
    141  334e
    142  334e		       85 c1		      sta	ROM_Bank
    143  3350
    144  3350		       38		      sec
    145  3351		       a5 93		      lda	BoardLimit_Width
    146  3353		       e9 09		      sbc	#SCREEN_WIDTH-1
    147  3355		       85 93		      sta	BoardEdge_Right	; absolute rightmost scroll value
    148  3357				  -	      IF	INITIAL_SCROLL = YES
    149  3357				  -	      sbc	#1
    150  3357				  -	      cmp	BoardScrollX
    151  3357				  -	      bcs	.Xok
    152  3357				  -	      sta	BoardScrollX
    153  3357				  -	      sec
    154  3357				  -.Xok
    155  3357					      ENDIF
    156  3357
    157  3357							;		  sec			     already set
    158  3357		       a5 94		      lda	BoardLimit_Height
    159  3359		       e9 07		      sbc	#SCREEN_LINES-1
    160  335b		       85 94		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    161  335d				  -	      IF	INITIAL_SCROLL = YES
    162  335d				  -	      sbc	#1
    163  335d				  -	      cmp	BoardScrollY
    164  335d				  -	      bcs	.Yok
    165  335d				  -	      sta	BoardScrollY
    166  335d				  -.Yok
    167  335d					      ENDIF
    168  335d
    169  335d							; kludge position scroll roughly at player
    170  335d
    171  335d							;TODO: "correct" BD scrolling.
    172  335d							; The game scrolls from the players last position (no difference between 1st and 2nd player)
    173  335d
    174  335d					      IF	INITIAL_SCROLL = NO
    175  335d							;		  sec			 already set
    176  335d		       a5 99		      lda	ManX
    177  335f		       e9 05		      sbc	#5
    178  3361		       b0 02		      bcs	notL0
    179  3363		       a9 00		      lda	#0
    180  3365		       85 96	   notL0      sta	BoardScrollX
    181  3367
    182  3367
    183  3367		       38		      sec
    184  3368		       a5 9a		      lda	ManY
    185  336a		       e9 05		      sbc	#5	; TJ: why 5???
    186  336c		       b0 02		      bcs	notU0
    187  336e		       a9 00		      lda	#0
    188  3370		       85 95	   notU0      sta	BoardScrollY
    189  3372					      ENDIF
    190  3372
    191  3372		       a9 00		      lda	#0
    192  3374		       85 9d		      sta	ManMode
    193  3376		       85 9e		      sta	ManDelayCount
    194  3378
    195  3378		       a9 1a		      lda	#AnimateBLANK-Manimate	;0 ;<AnimateBLANK ;STAND
    196  337a		       85 9f		      sta	ManAnimation
    197  337c							;lda #>AnimateBLANK ;
    198  337c							;sta ManAnimation+1
    199  337c
    200  337c		       a9 ff		      lda	#$FF
    201  337e		       85 ae		      sta	LastSpriteY
    202  3380
    203  3380		       a9 07		      lda	#DIRECTION_BITS
    204  3382		       85 a2		      sta	ManLastDirection
    205  3384
    206  3384							;		  bit amoebaFlag		      ; AMOEBA_PRESENT?
    207  3384							;		  bvc .noAmoeba
    208  3384
    209  3384							;		  ldx amoebaMaxX
    210  3384							;		  stx amoebaX
    211  3384							;		  ldy amoebaMaxY
    212  3384							;		  sty amoebaY
    213  3384							;		  lda #1
    214  3384							;		  sta amoebaStepCount
    215  3384							;		  sta amoebaCount		      ; doesn't matter to be 1 too big here initially
    216  3384							;;		  lda #0
    217  3384							;		  ;sta amoebaFlag		      ; now initialised in DecodeCave
    218  3384							;;		  sta amoebaCount
    219  3384							;		  lda magicAmoebaTime		      ; setup slow growth time
    220  3384							;		  sta MagicAmoebaFlag		      ;
    221  3384							;.noAmoeba
    222  3384
    223  3384		       60		      rts
    224  3385
    225  3385							;-------------------------------------------------------------------------------------
    226  3385
      0  3385					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  3385		       00 06	   BANK_LevelInit =	_CURRENT_BANK
      2  3385					      SUBROUTINE
      3  3385				   LevelInit
    228  3385
    229  3385		       a9 00		      lda	#0
    230  3387		       85 86		      sta	ObjStackPtr
    231  3389		       85 87		      sta	ObjStackPtr+1	; kill all creatures
    232  338b		       85 85		      sta	ObjStackNum
    233  338d		       85 d1		      sta	ObjIterator
    234  338f
    235  338f		       85 97		      sta	scrollBits
    236  3391		       85 89		      sta	ScreenDrawPhase
    237  3393
    238  3393		       85 b0		      sta	BGColour
    239  3395		       85 c3		      sta	ColourTimer
    240  3397							;sta extraLifeTimer		  ; Cosmic Ark stars off
    241  3397
    242  3397		       85 ca		      sta	soundIdxLst
    243  3399		       85 cb		      sta	soundIdxLst+1
    244  339b		       85 d0		      sta	newSounds
    245  339d
    246  339d		       85 59		      sta	AUDV0
    247  339f		       85 5a		      sta	AUDV1	; turn off music while levels init
    248  33a1							;		  sta AUDC0
    249  33a1
    250  33a1		       85 a2		      sta	ManLastDirection
    251  33a3		       85 a3		      sta	ManPushCounter
    252  33a5
    253  33a5		       85 c9		      sta	sortPtr	; sort stopped
    254  33a7		       a9 ff		      lda	#<(-1)
    255  33a9		       85 c8		      sta	sortRequired	; nothing needed
    256  33ab		       85 84		      sta	DrawStackPointer
    257  33ad
    258  33ad		       a9 02		      lda	#DISPLAY_LIVES
    259  33af		       85 c6		      sta	scoringFlags
    260  33b1		       a9 96		      lda	#SCORING_TIMER_FIRST	; We want the first timer display to be long, to show level and lives
    261  33b3		       85 c5		      sta	scoringTimer
    262  33b5		       60		      rts
    263  33b6
    264  33b6							;-------------------------------------------------------------------------------------
    265  33b6
    266  33b6
    267  33b6							;---------------------------------------------------------------------------
    268  33b6
      0  33b6					      DEFINE_SUBROUTINE	Resync
      1  33b6		       00 06	   BANK_Resync =	_CURRENT_BANK
      2  33b6					      SUBROUTINE
      3  33b6				   Resync
      0  33b6					      RESYNC
      1  33b6
      2  33b6		       a9 02		      lda	#%10
      3  33b8		       85 41		      sta	VBLANK
      4  33ba
      5  33ba		       a2 08		      ldx	#8
      6  33bc				   .loopResync
      0  33bc					      VERTICAL_SYNC
      1  33bc		       a9 0e		      lda	#%1110
      2  33be		       85 42	   .VSLP1     sta	WSYNC
      3  33c0		       85 40		      sta	VSYNC
      4  33c2		       4a		      lsr
      5  33c3		       d0 f9		      bne	.VSLP1
      8  33c5
      9  33c5		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  33c7		       a5 81		      lda	Platform
     11  33c9		       49 02		      eor	#PAL_50
     12  33cb		       d0 02		      bne	.ntsc
     13  33cd		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  33cf				   .ntsc
     15  33cf				   .loopWait
     16  33cf		       85 42		      sta	WSYNC
     17  33d1		       85 42		      sta	WSYNC
     18  33d3		       88		      dey
     19  33d4		       d0 f9		      bne	.loopWait
     20  33d6		       ca		      dex
     21  33d7		       d0 e3		      bne	.loopResync
    271  33d9		       60	   Ret	      rts
    272  33da
    273  33da							;---------------------------------------------------------------------------
    274  33da
      0  33da					      DEFINE_SUBROUTINE	TrackPlayer	; =145; in GENERIC_BANK_1
      1  33da		       00 06	   BANK_TrackPlayer =	_CURRENT_BANK
      2  33da					      SUBROUTINE
      3  33da				   TrackPlayer
    276  33da
    277  33da		       a5 a4		      lda	LookingAround	; 3
    278  33dc		       30 fb		      bmi	Ret	; 2/3=5/6   don't track when looking around
    279  33de
    280  33de							; Contribution by Thomas Jentzsch
    281  33de
    282  33de							; scrolling constants:
    283  33de		       00 03	   .SCRL_START_LEFT =	3	; 3
    284  33de		       00 03	   .SCRL_STOP_LEFT =	3	;SCREEN_WIDTH-5		    ; 5 scrolls 5-3+1 = 3 pixel
    285  33de		       00 07	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT	; 7
    286  33de		       00 07	   .SCRL_STOP_RIGHT =	SCREEN_WIDTH-.SCRL_STOP_LEFT	; 5
    287  33de		       00 11	   .SCRL_LEFT_BIT =	%00010001
    288  33de		       00 22	   .SCRL_RIGHT_BIT =	%00100010
    289  33de		       00 33	   .SCRL_X_BITS =	.SCRL_LEFT_BIT|.SCRL_RIGHT_BIT
    290  33de
    291  33de		       00 02	   .SCRL_START_UP =	2	; 2
    292  33de		       00 02	   .SCRL_STOP_UP =	2	;SCREEN_LINES-5		    ; 3 scrolls 3-2+1 = 2 pixel
    293  33de		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP	; 6
    294  33de		       00 06	   .SCRL_STOP_DOWN =	SCREEN_LINES-.SCRL_STOP_UP	; 5
    295  33de		       00 44	   .SCRL_UP_BIT =	%01000100
    296  33de		       00 88	   .SCRL_DOWN_BIT =	%10001000
    297  33de		       00 cc	   .SCRL_Y_BITS =	.SCRL_UP_BIT|.SCRL_DOWN_BIT
    298  33de
    299  33de							; *** horizontal scrolling (unoptimized version): ***
    300  33de
    301  33de							; check for enabling horizontal scrolling:
    302  33de		       a5 99		      lda	ManX	; 3
    303  33e0		       38		      sec		; 2
    304  33e1		       e5 96		      sbc	BoardScrollX	; 3
    305  33e3		       a8		      tay		; 2	     for later use
    306  33e4		       a9 11		      lda	#.SCRL_LEFT_BIT	; 2
    307  33e6		       c0 03		      cpy	#.SCRL_START_LEFT	; 2	     <3?
    308  33e8		       30 06		      bmi	.startXScroll	; 2/3	     yes, scroll left
    309  33ea		       c0 07		      cpy	#.SCRL_START_RIGHT	; 2	     <8?
    310  33ec		       30 08		      bmi	.skipStartXScroll	; 2/3	     no
    311  33ee		       a9 22		      lda	#.SCRL_RIGHT_BIT	; 2 = 22    yes, scroll right
    312  33f0				   .startXScroll
    313  33f0		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    314  33f2		       05 97		      ora	scrollBits	; 3
    315  33f4		       85 97		      sta	scrollBits	; 3 =	8
    316  33f6				   .skipStartXScroll
    317  33f6
    318  33f6							; do horizontal scrolling:
    319  33f6		       a5 97		      lda	scrollBits	; 3
    320  33f8		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    321  33fa		       f0 23		      beq	.skipXScroll	; 2/3
    322  33fc		       29 22		      and	#.SCRL_RIGHT_BIT	; 2
    323  33fe		       d0 0c		      bne	.xScrollRight	; 2/3=11/12
    324  3400
    325  3400							; scroll left:
    326  3400		       a5 96		      lda	BoardScrollX	; 3	     already at left edge?
    327  3402		       f0 15		      beq	.stopXScroll	; 2
    328  3404		       c6 96		      dec	BoardScrollX	; 5
    329  3406		       c0 02		      cpy	#.SCRL_STOP_LEFT-1	; 2
    330  3408		       10 0f		      bpl	.stopXScroll	; 2/3=15
    331  340a		       30 13		      bmi	.skipXScroll	; 3
    332  340c							;---------------------------------------
    333  340c				   .xScrollRight
    334  340c		       a6 96		      ldx	BoardScrollX	; 3
    335  340e		       e8		      inx		; 2
    336  340f		       e4 93		      cpx	BoardEdge_Right	; 3	     already at right edge?
    337  3411		       10 06		      bpl	.stopXScroll	; 2/3
    338  3413		       86 96		      stx	BoardScrollX	; 3
    339  3415		       c0 08		      cpy	#.SCRL_STOP_RIGHT+1	; 2
    340  3417		       10 06		      bpl	.skipXScroll	; 2/3=17/18
    341  3419				   .stopXScroll
    342  3419		       a5 97		      lda	scrollBits	; 3
    343  341b		       29 fc		      and	#(~(.SCRL_X_BITS >> 4))	; 2
    344  341d		       85 97		      sta	scrollBits	; 3 =	8
    345  341f				   .skipXScroll
    346  341f							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    347  341f
    348  341f							; *** vertical scrolling (unoptimized version): ***
    349  341f
    350  341f							; check for enabling vertical scrolling:
    351  341f		       a5 9a		      lda	ManY	; 3
    352  3421		       38		      sec		; 2
    353  3422		       e5 95		      sbc	BoardScrollY	; 3
    354  3424		       a8		      tay		; 2	     for later use
    355  3425		       a9 44		      lda	#.SCRL_UP_BIT	; 2
    356  3427		       c0 02		      cpy	#.SCRL_START_UP	; 2	     <2?
    357  3429		       30 06		      bmi	.startYScroll	; 2/3	     yes, scroll up
    358  342b		       c0 06		      cpy	#.SCRL_START_DOWN	; 2	     <6?
    359  342d		       30 08		      bmi	.skipStartYScroll	; 2/3
    360  342f		       a9 88		      lda	#.SCRL_DOWN_BIT	; 2 = 22    yes, scroll down
    361  3431				   .startYScroll
    362  3431		       29 0c		      and	#.SCRL_Y_BITS >> 4	; 2
    363  3433		       05 97		      ora	scrollBits	; 3
    364  3435		       85 97		      sta	scrollBits	; 3 =	8
    365  3437				   .skipStartYScroll
    366  3437
    367  3437							; do vertical scrolling:
    368  3437		       a5 97		      lda	scrollBits	; 3
    369  3439		       29 cc		      and	#.SCRL_Y_BITS	; 2
    370  343b		       f0 23		      beq	.skipYScroll	; 2/3
    371  343d		       29 88		      and	#.SCRL_DOWN_BIT	; 2
    372  343f		       d0 0c		      bne	.yScrollDown	; 2/3=11/12
    373  3441
    374  3441							; scroll up
    375  3441		       a5 95		      lda	BoardScrollY	; 3
    376  3443		       f0 15		      beq	.stopYScroll	; 2
    377  3445		       c6 95		      dec	BoardScrollY	; 5
    378  3447		       c0 01		      cpy	#.SCRL_STOP_UP-1	; 2
    379  3449		       10 0f		      bpl	.stopYScroll	; 2/3=15
    380  344b		       30 13		      bmi	.skipYScroll	; 3
    381  344d							;---------------------------------------
    382  344d				   .yScrollDown
    383  344d		       a6 95		      ldx	BoardScrollY	; 3
    384  344f		       e8		      inx		; 2
    385  3450		       e4 94		      cpx	BoardEdge_Bottom	;     ; 3
    386  3452		       10 06		      bpl	.stopYScroll	; 2/3
    387  3454		       86 95		      stx	BoardScrollY	; 3
    388  3456		       c0 07		      cpy	#.SCRL_STOP_DOWN+1	; 2
    389  3458		       10 06		      bpl	.skipYScroll	; 2/3=17/18
    390  345a				   .stopYScroll
    391  345a		       a5 97		      lda	scrollBits	; 3
    392  345c		       29 f3		      and	#(~(.SCRL_Y_BITS >> 4))	; 2
    393  345e		       85 97		      sta	scrollBits	; 3 =	8
    394  3460				   .skipYScroll
    395  3460							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    396  3460
    397  3460		       60	   EarlyAbortx rts		; 6 =	6
    398  3461							; total: 5+67*2+6 = 145
    399  3461
    400  3461							;------------------------------------------------------------------------------
    401  3461
    402  3461
    403  3461
    404  3461							; worst case time from positive last check to rts: 123
    405  3461							; cycles until 0-check: 15
    406  3461							; minimum cycles available after last positive check until timer turns 0: (MINIMUM_SORT_TIME-1)*64+1
    407  3461							; MINIMUM_SORT_TIME = 3 = 129
    408  3461							; MINIMUM_SORT_TIME = 4 = 193 <- ok
    409  3461
    410  3461							;------------------------------------------------------------------------------
    411  3461
    412  3461							;    DEFINE_SUBROUTINE PrepareTimeVector ; = 27
    413  3461
    414  3461							;		  ldx ScreenDrawPhase		  ; 3		; current phase of drawing
    415  3461							;		  lda TS_PhaseVectorLO,x	  ; 4
    416  3461							;		  sta TS_Vector 		  ; 3
    417  3461							;		  lda TS_PhaseVectorHI,x	  ; 4
    418  3461							;		  sta TS_Vector+1		  ; 3
    419  3461
    420  3461							;		  lda TS_PhaseBank,x		  ; 4
    421  3461							;sta ROM_Bank			  ; 4	     GUESS!  SEEMS TO RUN OK WITHOUT THIS.
    422  3461							;		  rts				  ; 6
    423  3461
    424  3461							;------------------------------------------------------------------------------
    425  3461
    426  3461							; This is a GOOD home for these tables.  Move AD's tables here and fix code appropriately
    427  3461
      0  3461					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  3461		       00 06	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  3461					      SUBROUTINE
      3  3461				   TS_PhaseVectorLO
    429  3461
    430  3461							; Gives LO byte of addresses of subroutines for timeslice processing
    431  3461
    432  3461		       7d		      .byte.b	<ProcessObjStack
    433  3462		       59		      .byte.b	<DrawFullScreen
    434  3463		       ff		      .byte.b	<BuildDrawStack
    435  3464		       06		      .byte.b	<DrawAIntoStack
    436  3465		       c0		      .byte.b	<SwitchObjects
    437  3466
    438  3466				   TS_PhaseVectorHI
    439  3466
    440  3466							; Gives HI byte of addresses of subroutines for timeslice processing
    441  3466
    442  3466		       f8		      .byte.b	>ProcessObjStack
    443  3467		       f3		      .byte.b	>DrawFullScreen
    444  3468		       fa		      .byte.b	>BuildDrawStack
    445  3469		       fb		      .byte.b	>DrawAIntoStack
    446  346a		       f8		      .byte.b	>SwitchObjects
    447  346b
    448  346b				   TS_PhaseBank
    449  346b
    450  346b							; Gives bank of subroutines for timeslice processing
    451  346b
    452  346b		       0f		      .byte.b	BANK_ProcessObjStack
    453  346c		       07		      .byte.b	BANK_DrawFullScreen
    454  346d		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    455  346e		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    456  346f		       0f		      .byte.b	BANK_SwitchObjects
    457  3470
    458  3470							;------------------------------------------------------------------------------
    459  3470		       02 02	   lookColour2 .byte.b	$02, $02
    460  3472		       04 04		      .byte.b	$04, $04
    461  3474
    462  3474				   OverscanTime
    463  3474		       33 33		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    464  3476		       46 33		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    465  3478
    466  3478
    467  3478
    468  3478
      0  3478					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  3478		       00 06	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  3478					      SUBROUTINE
      3  3478				   PostScreenCleanup
    470  3478
    471  3478		       c8		      iny		; --> 0
    472  3479
    473  3479		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    474  347b							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    475  347b
    476  347b		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    477  347d							; TJ: no idea why, but you had removed it in revision 758 ;)
    478  347d							; completely accidental -- one of our cats may have deleted it.
    479  347d		       84 4e		      sty	PF1
    480  347f		       84 4f		      sty	PF2
    481  3481		       84 5d		      sty	ENAM0
    482  3483		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    483  3485		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    484  3487
    485  3487
    486  3487
    487  3487							; D1 VBLANK turns off beam
    488  3487							; It needs to be turned on 37 scanlines later
    489  3487
    490  3487		       a9 42		      lda	#%01000010	; bit6 is not required
    491  3489		       85 41		      sta	VBLANK	; end of screen - enter blanking
    492  348b
    493  348b							;------------------------------------------------------------------------------
    494  348b							; This is where the PAL system has a bit of extra time on a per-frame basis.
    495  348b
    496  348b		       a6 81		      ldx	Platform
    497  348d		       bd 74 f4 	      lda	OverscanTime,x
    498  3490		       8d 96 02 	      sta	TIM64T
    499  3493
    500  3493							; Background colour priorities. Increasing order of priority...
    501  3493							;	black -- nothing happening
    502  3493							;	looking around			     lookingAround<0		     BLUE
    503  3493							;	when paused			     gameMode... BIT7		     RED
    504  3493							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    505  3493
    506  3493
    507  3493		       a5 a4		      lda	LookingAround
    508  3495		       10 02		      bpl	nolooker	; if not looking around, that will do nicely
    509  3497		       a0 00		      ldy	#0	;sok
    510  3499							;		  ldy lookColour2,x		  ; otherwise, use the lookaround colour as the base
    511  3499		       84 b0	   nolooker   sty	BGColour	; 'BASE' colour pause reverts TO when unpaused
    512  349b
    513  349b		       a5 b5		      lda	ThrottleSpeed
    514  349d		       18		      clc
    515  349e		       65 b4		      adc	Throttle
    516  34a0		       b0 02		      bcs	noVerflo
    517  34a2		       85 b4		      sta	Throttle
    518  34a4				   noVerflo
    519  34a4
    520  34a4
    521  34a4							;----------------------------------------------------------------------------------------------
    522  34a4							; handle pause button for 2600 and 7800
    523  34a4
    524  34a4							; Timings:  NOT including palette setting or platform detect
    525  34a4							; 2600:     no button press:	 11 cycles
    526  34a4							;	     with button press:  21 cycles
    527  34a4							; 7800      no button press:	 16 cycles
    528  34a4							;	     with button press:  21 cycles
    529  34a4
    530  34a4
    531  34a4
    532  34a4		       00 08	   BW_SWITCH  =	$08	; NOTE: Shares bit position with SWCHB COLOUR/B&W SWITCH
    533  34a4
    534  34a4		       24 80		      bit	gameMode
    535  34a6		       50 0b		      bvc	.pause7800	; 7800 platform
    536  34a8
    537  34a8							; 2600 pause logic...
    538  34a8
    539  34a8		       ad 82 02 	      lda	SWCHB
    540  34ab		       45 80		      eor	gameMode
    541  34ad		       29 08		      and	#BW_SWITCH
    542  34af		       f0 17		      beq	.setPauseCol	; no different to original state = no pause change
    543  34b1		       d0 0f		      bne	.buttonDown	; unconditional
    544  34b3
    545  34b3							; 7800 pause logic...
    546  34b3
    547  34b3							; When the button is pressed, we check if it's the FIRST time it's pressed.
    548  34b3							; This FIRST time is indicated by the PFLAG7800 being clear.  If it's the first time, we toggle the pause
    549  34b3							; flag (BIT6) AND we toggle the PFLAG7800 so continued button-down does nothing.  When the button is
    550  34b3							; released, then we again toggle the PFLAG7800, allowing a FIRST time check once again, when the button
    551  34b3							; is next pressed.
    552  34b3
    553  34b3		       a9 08	   .pause7800 lda	#BW_SWITCH
    554  34b5		       2c 82 02 	      bit	SWCHB
    555  34b8		       f0 04		      beq	.pausePress
    556  34ba		       05 80		      ora	gameMode	; not pressed, so enable first time press
    557  34bc		       d0 08		      bne	.fixPause	; unconditional
    558  34be
    559  34be		       24 80	   .pausePress bit	gameMode
    560  34c0		       f0 06		      beq	.setPauseCol	; NOT the first time in pause - so do nothing new
    561  34c2
    562  34c2							; Button is down, and we have detected it as a FIRST-TIME button press.
    563  34c2
    564  34c2		       45 80	   .buttonDown eor	gameMode	; toggle first time flag(7800) or current switch state(2600)
    565  34c4		       49 80		      eor	#GAMEMODE_PAUSED	; toggle pause flag
    566  34c6		       85 80	   .fixPause  sta	gameMode
    567  34c8
    568  34c8		       a5 80	   .setPauseCol lda	gameMode	; are we paused?
    569  34ca		       10 07		      bpl	.exitPause	; only show pause colour when actually paused
    570  34cc
    571  34cc		       a6 81		      ldx	Platform
    572  34ce		       bd 39 f5 	      lda	pscol,x
    573  34d1		       85 b0		      sta	BGColour	; set main screen background colour.  RED is paused.
    574  34d3
    575  34d3				   .exitPause
    576  34d3
    577  34d3							;----------------------------------------------------------------------------------------------
    578  34d3
    579  34d3							; has to be done AFTER screen display, because it disables the effect!
    580  34d3		       a5 82		      lda	rnd	; 3	 randomly reposition the Cosmic Ark missile
    581  34d5		       85 62		      sta	HMM0	; 3	 this assumes that HMOVE is called at least once/frame
    582  34d7
    583  34d7							; "Flash" has highest BG colour priority
    584  34d7
    585  34d7		       a6 c3		      ldx	ColourTimer
    586  34d9		       f0 06		      beq	noFlashBG
    587  34db		       c6 c3		      dec	ColourTimer
    588  34dd		       a9 0e		      lda	#WHITE
    589  34df		       85 b0		      sta	BGColour
    590  34e1				   noFlashBG
    591  34e1
    592  34e1							;		  lda extraLifeTimer
    593  34e1							;		  beq alreadyBlack2
    594  34e1							;		  dec extraLifeTimer
    595  34e1							;alreadyBlack2
    596  34e1
    597  34e1							; Handle the player joystick reading. We do it *every frame* so that we can incorporate a two-frame
    598  34e1							; buffer.  This is designed to give a little better responsiveness to the 'quick tap' movement.
    599  34e1
    600  34e1		       a5 90		      lda	BufferedJoystick	; previous frame
    601  34e3		       85 91		      sta	BufferedJoystick+1	; -> buffered
    602  34e5
    603  34e5							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    604  34e5							; P2 is shifted UP, so we don't need to worry in usage elsewhere (it's same format as a P1 joystick)
    605  34e5
    606  34e5		       a5 98		      lda	whichPlayer	; 3
    607  34e7		       25 a6		      and	jtoggle	; 3
    608  34e9		       aa		      tax		; 2
    609  34ea
    610  34ea		       b5 4c		      lda	INPT4,x	; 4
    611  34ec		       85 92		      sta	BufferedButton	; 3 = 15
    612  34ee
    613  34ee		       ad 80 02 	      lda	SWCHA	; 4
    614  34f1
    615  34f1		       ca		      dex		; 2
    616  34f2		       30 04		      bmi	notP2	; 2/3= 8/9
    617  34f4
    618  34f4		       0a		      asl		; 2
    619  34f5		       0a		      asl		; 2
    620  34f6		       0a		      asl		; 2
    621  34f7		       0a		      asl		; 2 =	8
    622  34f8		       85 90	   notP2      sta	BufferedJoystick	; 3
    623  34fa
    624  34fa
    625  34fa							; "Scoring timer" reset stomp comment
    626  34fa
    627  34fa		       a5 c5		      lda	scoringTimer
    628  34fc		       f0 0a		      beq	timer0now
    629  34fe		       c6 c5		      dec	scoringTimer
    630  3500		       d0 06		      bne	timer0now
    631  3502		       a5 c6		      lda	scoringFlags
    632  3504		       29 fc		      and	#<(~DISPLAY_FLAGS)	;	 switches to time display
    633  3506		       85 c6		      sta	scoringFlags
    634  3508				   timer0now
    635  3508
    636  3508							; fall through
    637  3508
    638  3508							;-------------------------------------------------------------------------------------
    639  3508							; Player animation happens *every* frame so that we get good animation speeds.  Note that
    640  3508							; the player animation consists of running a small animation 'program', and then actually drawing
    641  3508							; the player.	The draw is the neat bit, because all it does is update some self-modifying pointers
    642  3508							; inside the actual draw kernel in the appropriate bank.
    643  3508
    644  3508
      0  3508					      DEFINE_SUBROUTINE	AnimatePlayers	; in GENERIC_BANK_1
      1  3508		       00 06	   BANK_AnimatePlayers =	_CURRENT_BANK
      2  3508					      SUBROUTINE
      3  3508				   AnimatePlayers
    646  3508
    647  3508							; Optimised 7/1/2012 -- single page tables
    648  3508
    649  3508							; This interesting code performs the animations for the player(s) and sets the
    650  3508							; pointers INSIDE the row bank for the draw code to point to the correct player
    651  3508							; shape.  Kind of neat, as it doesn't require any shape copying (=speed!)
    652  3508
    653  3508
    654  3508							; Cycle the player through his animation list.  The animation of a player is a direct
    655  3508							; pointer to the actual shape used to display the player.  This shape is in turn
    656  3508							; written to the current bank's self-modifying locations for the draw.  Since
    657  3508							; we are effectively drawing from this current bank, the same code can be used
    658  3508							; to 'undraw' the player as required.
    659  3508
    660  3508
    661  3508							; x = player index
    662  3508							; sets ManAnimation = FRAME to display for player
    663  3508							; ManAnimation = index of player program into Manimate list
    664  3508
    665  3508		       24 80		      bit	gameMode
    666  350a		       30 2c		      bmi	AnimationOK	; don't animate during pause
    667  350c
    668  350c		       c6 9e		      dec	ManDelayCount
    669  350e		       10 28		      bpl	AnimationOK
    670  3510
    671  3510		       a4 9f	   ReloadAnimation ldy	ManAnimation
    672  3512		       b9 00 f7    ContinueAnim lda	Manimate,y	; delay count
    673  3515		       d0 07		      bne	NewFrameOK
    674  3517		       b9 01 f7 	      lda	Manimate+1,y
    675  351a		       a8		      tay
    676  351b		       4c 12 f5 	      jmp	ContinueAnim
    677  351e
    678  351e		       10 0d	   NewFrameOK bpl	doDelay
    679  3520
    680  3520		       c8		      iny		; handle a REFLECT
    681  3521		       a5 a2		      lda	ManLastDirection
    682  3523		       29 f7		      and	#%11110111
    683  3525		       19 00 f7 	      ora	Manimate,y
    684  3528		       85 a2		      sta	ManLastDirection
    685  352a
    686  352a		       c8		      iny
    687  352b		       d0 e5		      bne	ContinueAnim
    688  352d
    689  352d		       85 9e	   doDelay    sta	ManDelayCount
    690  352f
    691  352f		       c8		      iny
    692  3530		       b9 00 f7 	      lda	Manimate,y
    693  3533		       85 a1		      sta	ManAnimationFrameLO
    694  3535
    695  3535		       c8		      iny
    696  3536		       84 9f		      sty	ManAnimation
    697  3538
    698  3538		       60	   AnimationOK rts
    699  3539
    700  3539
    701  3539
    702  3539		       40 40	   pscol      .byte.b	$40, $40
    703  353b		       60 60		      .byte.b	$60, $60
    704  353d
    705  353d							;------------------------------------------------------------------------------
    706  353d
------- FILE i2c_v2.2.inc LEVEL 3 PASS 3
      0  353d					      include	"i2c_v2.2.inc"
      1  353d							;
      2  353d							; i2c_v2.2.inc
      3  353d							;
      4  353d							;
      5  353d							; AtariVox EEPROM Driver
      6  353d							;
      7  353d							; By Alex Herbert, 2004
      8  353d							;
      9  353d							; Optimisations by Thomas Jentzsch, 2006/2008
     10  353d							;
     11  353d
     12  353d
     13  353d							; I/O Constants
     14  353d
     15  353d		       00 04	   I2C_SDA_MASK equ	$04
     16  353d		       00 08	   I2C_SCL_MASK equ	$08
     17  353d
     18  353d
     19  353d							; Signalling Macros
     20  353d
     21  353d							;  MAC     I2C_SCL_0
     22  353d							;    lda     #$00
     23  353d							;    sta     SWCHA
     24  353d							;  ENDM
     25  353d
     26  353d							;  MAC     I2C_SCL_1
     27  353d							;    lda     #I2C_SCL_MASK
     28  353d							;    sta     SWCHA
     29  353d							;  ENDM
     30  353d
     31  353d							;  MAC     I2C_SDA_IN
     32  353d							;    lda     #I2C_SCL_MASK
     33  353d							;    sta     SWACNT
     34  353d							;  ENDM
     35  353d
     36  353d							;  MAC     I2C_SDA_OUT
     37  353d							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  353d							;    sta     SWACNT
     39  353d							;  ENDM
     40  353d
     41  353d
     42  353d					      MAC	i2c_start
     43  353d							; I2C_SCL_1
     44  353d					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  353d					      sta	SWCHA	; 4
     46  353d							; I2C_SDA_OUT
     47  353d					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  353d					      sta	SWACNT	; 4
     49  353d							; total: 12 cycles
     50  353d					      ENDM
     51  353d
     52  353d
     53  353d					      MAC	i2c_txbit
     54  353d							; I2C_SCL_0
     55  353d					      lda	#%0011	; 2
     56  353d					      sta	SWCHA	; 4
     57  353d							; set bit
     58  353d					      adc	#%1000	; 2
     59  353d					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  353d							; I2C_SCL_1
     61  353d					      lda	#I2C_SCL_MASK	; 2
     62  353d					      sta	SWCHA	; 4
     63  353d							; total: 18 cycles
     64  353d					      ENDM
     65  353d
     66  353d
     67  353d					      MAC	i2c_txnack
     68  353d							; I2C_SCL_0
     69  353d					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  353d					      sta	SWCHA	; 4
     71  353d							; I2C_SDA_IN
     72  353d					      lsr		; 2	     I2C_SCL_MASK
     73  353d					      sta	SWACNT	; 4
     74  353d							; I2C_SCL_1
     75  353d					      nop		; 2	     required for timing!
     76  353d					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  353d							; total: 18 cycles
     78  353d					      ENDM
     79  353d
     80  353d
     81  353d							; Subroutine Macros
     82  353d
     83  353d					      MAC	i2c_subs
     84  353d
     85  353d				   i2c_startread
     86  353d							; use V to flag if previous byte needs ACK
     87  353d					      ldy	#%10100001	; 2	     eeprom read command
     88  353d					      .byte	$2c	; 2
     89  353d				   i2c_startwrite
     90  353d					      ldy	#%10100000	; 2	     eeprom write command
     91  353d					      I2C_START		;12	     start signal (clears V flag)
     92  353d					      tya		; 2 = 16
     93  353d				   i2c_txbyte
     94  353d					      eor	#$ff	; 2	     invert data byte
     95  353d					      sec		; 2
     96  353d					      rol		; 2 =	6    shift loop bit into a
     97  353d				   i2c_txbyteloop
     98  353d					      tay		; 2
     99  353d					      I2C_TXBIT		;18	     transmit
    100  353d					      tya		; 2
    101  353d					      asl		; 2	     shift next bit into C
    102  353d					      bne	i2c_txbyteloop	; 2= 26/27
    103  353d
    104  353d							; receive acknowledge bit
    105  353d
    106  353d					      beq	i2c_rxbit	;43 = 43
    107  353d							; i2c_txbyte: 264 cycles
    108  353d							;-------------------------------------------------------------------------------
    109  353d
    110  353d				   i2c_rxbyte
    111  353d					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  353d					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  353d
    114  353d				   i2c_rxskipack
    115  353d					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  353d
    117  353d					      lda	#1	; 2
    118  353d				   i2c_rxbyteloop
    119  353d					      tay		; 2 =	2
    120  353d				   i2c_rxbit		;	     receive bit in C
    121  353d					      I2C_TXNACK		;18 = 18
    122  353d
    123  353d					      lda	SWCHA	; 4
    124  353d					      lsr		; 2
    125  353d					      lsr		; 2
    126  353d					      lsr		; 2 = 10    C = SDA
    127  353d
    128  353d					      tya		; 2
    129  353d					      rol		; 2	     rotate into Y
    130  353d					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  353d
    132  353d							; received byte in A
    133  353d					      rts		; 6 =	6
    134  353d							; i2c_rxbit:  40 cycles
    135  353d							; i2c_rxbyte: 310/333 cycles
    136  353d							;-------------------------------------------------------------------------------
    137  353d
    138  353d				   i2c_stopread
    139  353d					      bvc	i2c_stopwrite	; 2
    140  353d					      ldy	#$80	; 2
    141  353d					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  353d
    143  353d				   i2c_stopwrite
    144  353d					      jsr	i2c_txack	;30
    145  353d
    146  353d							; return port to input mode
    147  353d					      lda	#0	; 2	     0
    148  353d					      sta	SWACNT	; 4
    149  353d					      rts		; 6 = 12
    150  353d							; i2c_stopread:  45/92
    151  353d							; i2c_stopwrite: 42
    152  353d							;-------------------------------------------------------------------------------
    153  353d
    154  353d				   i2c_txack
    155  353d							; I2C_SCL_0
    156  353d					      lda	#0	; 2	     $00
    157  353d					      sta	SWCHA	; 4
    158  353d							; I2C_SDA_OUT
    159  353d					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  353d					      sta	SWACNT	; 4
    161  353d							; I2C_SCL_1
    162  353d					      asl		; 2	     I2C_SCL_MASK
    163  353d					      sta	SWCHA	; 4
    164  353d
    165  353d					      rts		; 6
    166  353d							; total: 24 cycles
    167  353d							;-------------------------------------------------------------------------------
    168  353d
    169  353d					      ENDM
    170  353d
    171  353d
    172  353d
------- FILE BANK_GENERIC.asm
    708  353d
      0  353d					      i2c_subs
      1  353d
      2  353d				   i2c_startread
      3  353d
      4  353d		       a0 a1		      ldy	#%10100001
      5  353f		       2c		      .byte.b	$2c
      6  3540				   i2c_startwrite
      7  3540		       a0 a0		      ldy	#%10100000
      0  3542					      I2C_START
      1  3542
      2  3542		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  3544		       8d 80 02 	      sta	SWCHA
      4  3547
      5  3547		       4a		      lsr
      6  3548		       8d 81 02 	      sta	SWACNT
      7  354b
      9  354b		       98		      tya
     10  354c				   i2c_txbyte
     11  354c		       49 ff		      eor	#$ff
     12  354e		       38		      sec
     13  354f		       2a		      rol
     14  3550				   i2c_txbyteloop
     15  3550		       a8		      tay
      0  3551					      I2C_TXBIT
      1  3551
      2  3551		       a9 03		      lda	#%0011
      3  3553		       8d 80 02 	      sta	SWCHA
      4  3556
      5  3556		       69 08		      adc	#%1000
      6  3558		       8d 81 02 	      sta	SWACNT
      7  355b
      8  355b		       a9 08		      lda	#I2C_SCL_MASK
      9  355d		       8d 80 02 	      sta	SWCHA
     10  3560
     17  3560		       98		      tya
     18  3561		       0a		      asl
     19  3562		       d0 ec		      bne	i2c_txbyteloop
     20  3564
     21  3564
     22  3564
     23  3564		       f0 0b		      beq	i2c_rxbit
     24  3566
     25  3566
     26  3566
     27  3566				   i2c_rxbyte
     28  3566		       50 03		      bvc	i2c_rxskipack
     29  3568		       20 99 f5 	      jsr	i2c_txack
     30  356b
     31  356b				   i2c_rxskipack
     32  356b		       2c 66 f5 	      bit	i2c_rxbyte
     33  356e
     34  356e		       a9 01		      lda	#1
     35  3570				   i2c_rxbyteloop
     36  3570		       a8		      tay
     37  3571				   i2c_rxbit
      0  3571					      I2C_TXNACK
      1  3571
      2  3571		       a9 10		      lda	#I2C_SCL_MASK*2
      3  3573		       8d 80 02 	      sta	SWCHA
      4  3576
      5  3576		       4a		      lsr
      6  3577		       8d 81 02 	      sta	SWACNT
      7  357a
      8  357a		       ea		      nop
      9  357b		       8d 80 02 	      sta	SWCHA
     10  357e
     39  357e
     40  357e		       ad 80 02 	      lda	SWCHA
     41  3581		       4a		      lsr
     42  3582		       4a		      lsr
     43  3583		       4a		      lsr
     44  3584
     45  3584		       98		      tya
     46  3585		       2a		      rol
     47  3586		       90 e8		      bcc	i2c_rxbyteloop
     48  3588
     49  3588
     50  3588		       60		      rts
     51  3589
     52  3589
     53  3589
     54  3589
     55  3589				   i2c_stopread
     56  3589		       50 05		      bvc	i2c_stopwrite
     57  358b		       a0 80		      ldy	#$80
     58  358d		       20 71 f5 	      jsr	i2c_rxbit
     59  3590
     60  3590				   i2c_stopwrite
     61  3590		       20 99 f5 	      jsr	i2c_txack
     62  3593
     63  3593
     64  3593		       a9 00		      lda	#0
     65  3595		       8d 81 02 	      sta	SWACNT
     66  3598		       60		      rts
     67  3599
     68  3599
     69  3599
     70  3599
     71  3599				   i2c_txack
     72  3599
     73  3599		       a9 00		      lda	#0
     74  359b		       8d 80 02 	      sta	SWCHA
     75  359e
     76  359e		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  35a0		       8d 81 02 	      sta	SWACNT
     78  35a3
     79  35a3		       0a		      asl
     80  35a4		       8d 80 02 	      sta	SWCHA
     81  35a7
     82  35a7		       60		      rts
     83  35a8
     84  35a8
     85  35a8
    710  35a8
    711  35a8				   HandleSaveKey SUBROUTINE
    712  35a8
    713  35a8		       06 00	   SAVEKEY_ADR =	$0600	;	     reserved address for Boulder Dash (64 bytes)
    714  35a8
    715  35a8							; SK Memory Map:
    716  35a8							;		 cave	 level
    717  35a8							; $0600-$0602	 A	 1
    718  35a8							; $0603-$0605	 A	 2
    719  35a8							; $0606-$0608	 A	 3
    720  35a8							; $0609-$060b	 A	 4
    721  35a8							; $060c-$060e	 A	 5
    722  35a8							; $060f-$0611	 E	 1
    723  35a8							; $0612-$0614	 E	 2
    724  35a8							; $0615-$0617	 E	 3
    725  35a8							; $0618-$061a	 unused
    726  35a8							; $061b-$061d	 unused
    727  35a8							; $061e-$0620	 I	 1
    728  35a8							; $0621-$0623	 I	 2
    729  35a8							; $0624-$0626	 I	 3
    730  35a8							; $0627-$0629	 unused
    731  35a8							; $062a-$062c	 unused
    732  35a8							; $062d-$062f	 M	 1
    733  35a8							; $0630-$0632	 M	 2
    734  35a8							; $0633-$0635	 M	 3
    735  35a8							; $0636-$063f	 unused
    736  35a8
    737  35a8							;------------------------------------------------------------------------------
      0  35a8					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  35a8		       00 06	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  35a8					      SUBROUTINE
      3  35a8				   ReadSaveKey
    739  35a8
    740  35a8							; assume no SaveKey found:
    741  35a8		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    742  35aa		       85 e3		      sta	highScoreSK+2	; 3
    743  35ac
    744  35ac							; setup SaveKey:
    745  35ac		       a5 e4		      lda	startCave	; 3	     load start cave*5 and level
    746  35ae		       a6 b2		      ldx	level	; 3
    747  35b0		       20 e9 f5 	      jsr	SetupSaveKey	;6+853
    748  35b3		       90 52		      bcc	NoSKfound	; 2/3
    749  35b5
    750  35b5							;    lda     #$34
    751  35b5							;    sta     COLUBK
    752  35b5
    753  35b5							; start read
    754  35b5		       20 90 f5 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    755  35b8		       20 3d f5 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    756  35bb
    757  35bb							; read high score:
    758  35bb		       a2 02		      ldx	#3-1	; 2 = 1187
    759  35bd				   .loopRead
    760  35bd		       20 66 f5 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    761  35c0		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    762  35c2		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    763  35c4		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    764  35c6				   .skipEmpty
    765  35c6		       95 e1		      sta	highScoreSK,x	; 4
    766  35c8		       ca		      dex		; 2
    767  35c9		       10 f2		      bpl	.loopRead	; 2/3= 354
    768  35cb
    769  35cb							; stop read:
    770  35cb		       4c 89 f5 	      jmp	i2c_stopread	;3+92=95    terminate read
    771  35ce
    772  35ce							;------------------------------------------------------------------------------
      0  35ce					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  35ce		       00 06	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  35ce					      SUBROUTINE
      3  35ce				   WriteSaveKey
    774  35ce
    775  35ce							; check if new high score:
    776  35ce		       a6 e1		      ldx	highScoreSK	; 3
    777  35d0		       e8		      inx		; 2
    778  35d1		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    779  35d3
    780  35d3							; setup SaveKey:
    781  35d3		       a5 e4		      lda	startCave	; 3	     load start cave*5 and level
    782  35d5		       a6 e5		      ldx	startLevel	; 3
    783  35d7		       20 e9 f5 	      jsr	SetupSaveKey	; 6+853
    784  35da		       90 2b		      bcc	NoSKfound	; 2/3
    785  35dc
    786  35dc							;    lda     #$64
    787  35dc							;    sta     COLUBK
    788  35dc
    789  35dc							; write high score:
    790  35dc		       a2 02		      ldx	#3-1	; 2 = 841
    791  35de				   .loopWrite
    792  35de		       b5 e1		      lda	highScoreSK,x	; 4
    793  35e0		       20 4c f5 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    794  35e3		       ca		      dex		; 2
    795  35e4		       10 f8		      bpl	.loopWrite	; 2/3= 837
    796  35e6
    797  35e6							; stop write:
    798  35e6		       4c 90 f5 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    799  35e9
    800  35e9
    801  35e9							;------------------------------------------------------------------------------
      0  35e9					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  35e9		       00 06	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  35e9					      SUBROUTINE
      3  35e9				   SetupSaveKey
    803  35e9
    804  35e9							; calculate slot;
    805  35e9							; a = cave (5*n): A=$00; E=$05; I=$0a; M=$0f
    806  35e9							; x = level (0..4)
    807  35e9		       85 e6		      sta	offsetSK	; 3
    808  35eb		       8a		      txa		; 2
    809  35ec		       18		      clc		; 2
    810  35ed		       65 e6		      adc	offsetSK	; 3
    811  35ef		       85 e6		      sta	offsetSK	; 3
    812  35f1		       0a		      asl		; 2	     multiply by 3
    813  35f2		       65 e6		      adc	offsetSK	; 3
    814  35f4		       69 00		      adc	#<SAVEKEY_ADR	; 2
    815  35f6		       aa		      tax		; 2 = 22
    816  35f7							; detect SaveKey:
    817  35f7		       20 40 f5 	      jsr	i2c_startwrite	;6+280
    818  35fa		       d0 0a		      bne	.exitSK	; 2/3
    819  35fc
    820  35fc							; setup address:
    821  35fc		       b8		      clv		; 2
    822  35fd		       a9 06		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    823  35ff		       20 4c f5 	      jsr	i2c_txbyte	;6+264
    824  3602		       8a		      txa		; 2	     x = lower byte offset
    825  3603		       4c 4c f5 	      jmp	i2c_txbyte	;3+264      returns C==1
    826  3606
    827  3606				   .exitSK
    828  3606		       18		      clc
    829  3607				   NoSKfound
    830  3607		       60		      rts
    831  3607					      ENDIF
    832  3608
    833  3700		       00 00 00 00*	      align	256
    834  3700
    835  3700				   Manimate
    836  3700				   AnimateSTAND
    837  3700				   AnimateRIGHT
    838  3700				   AnimateLEFT
    839  3700				   AnimateUP
    840  3700				   AnimateSTOPPED
    841  3700		       7f		      .byte.b	127
    842  3701		       3a		      .byte.b	<PLAYER_RIGHT0	;PLAYER_STAND
    843  3702							;.byte 10
    844  3702							;.byte < PLAYER_BLINK
    845  3702							;.byte 127
    846  3702							;.byte < PLAYER_STAND
    847  3702							;.byte 0
    848  3702							;.word AnimateTAP
    849  3702
    850  3702				   AnimateTAP
    851  3702							;.byte 128, %0 		  ; reflect off, always tap with left foot
    852  3702							;.byte 8
    853  3702							;.byte < PLAYER_TAP0
    854  3702							;.byte 8
    855  3702							;.byte < PLAYER_TAP1
    856  3702							;.byte 8
    857  3702							;.byte < PLAYER_TAP0
    858  3702							;.byte 8
    859  3702							;.byte < PLAYER_TAP1
    860  3702							;.byte 8
    861  3702							;.byte < PLAYER_TAP0
    862  3702							;.byte 8
    863  3702							;.byte < PLAYER_TAP1
    864  3702		       00		      .byte.b	0
    865  3703		       00		      .byte.b	AnimateSTAND-Manimate	;word AnimateSTAND
    866  3704
    867  3704							;AnimateRIGHT
    868  3704		       80 00		      .byte.b	128, %0	; reflect off
    869  3706		       05		      .byte.b	5
    870  3707		       3a		      .byte.b	< PLAYER_RIGHT0
    871  3708		       05		      .byte.b	5
    872  3709		       64		      .byte.b	< PLAYER_RIGHT1
    873  370a		       00		      .byte.b	0
    874  370b		       00		      .byte.b	AnimateRIGHT-Manimate	;word AnimateRIGHT
    875  370c
    876  370c							;AnimateLEFT
    877  370c		       80 08		      .byte.b	128, %1000	; reflect ON
    878  370e		       05		      .byte.b	5
    879  370f		       3a		      .byte.b	< PLAYER_RIGHT0
    880  3710		       05		      .byte.b	5
    881  3711		       64		      .byte.b	< PLAYER_RIGHT1
    882  3712		       00		      .byte.b	0
    883  3713		       00		      .byte.b	AnimateLEFT-Manimate	;word AnimateLEFT
    884  3714
    885  3714							;AnimateUP
    886  3714							;    .byte 128, %0		   ; reflect off
    887  3714							;    .byte 5
    888  3714							;    .byte < PLAYER_TAP
    889  3714							;    .byte 128, %1000
    890  3714							;    .byte 5
    891  3714							;    .byte < PLAYER_TAP
    892  3714							;    .byte 0
    893  3714							;    .word AnimateUP
    894  3714
    895  3714							;AnimateUP			      ; keep last reflection, like in original game
    896  3714		       05		      .byte.b	5
    897  3715		       3a		      .byte.b	< PLAYER_RIGHT0
    898  3716		       05		      .byte.b	5
    899  3717		       64		      .byte.b	< PLAYER_RIGHT1
    900  3718		       00		      .byte.b	0
    901  3719		       00		      .byte.b	AnimateUP-Manimate	;word AnimateUP
    902  371a
    903  371a				   AnimateBLANK
    904  371a		       7f		      .byte.b	127
    905  371b		       25		      .byte.b	< PLAYER_BLANK
    906  371c		       00		      .byte.b	0
    907  371d		       1a		      .byte.b	AnimateBLANK-Manimate	;word AnimateBLANK
    908  371e
    909  371e				   AnimateEND
      0  371e					      CHECKPAGEX	Manimate, "AnimateEND @ BANK_GENERIC"
      9  371e					      LIST	ON
    911  371e
    912  371e
      0  371e					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  371e		       07 1e	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $71e , FREE= $e2
      2  371e					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  371e				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  371e				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  371e				  -	      ERR
      6  371e					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 3
      0  371e					      include	"BANK_INITBANK.asm"	; MUST be after banks that include caves -- otherwise MAX_CAVEBANK is not calculated properly
      1  371e
      0  371e					      NEWBANK	INITBANK
      1  3bbc ????				      SEG	INITBANK
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   INITBANK   SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	INITBANK
      3  3800
      4  3800		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
      5  3801
      0  3801					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  3801		       00 07	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  3801					      SUBROUTINE
      3  3801				   BoardLineStartLO
      7  3801
      8  3801							; Gives the start address (LO) of each board line
      9  3801
     10  3801				   .BOARD_LOCATION SET	Board
     11  3801					      REPEAT	SIZE_BOARD_Y
     12  3801				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3801				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3801					      ENDIF
     15  3801		       00		      .byte.b	<.BOARD_LOCATION
     16  3801				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3801					      REPEND
     12  3802				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3802				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3802					      ENDIF
     15  3802		       28		      .byte.b	<.BOARD_LOCATION
     16  3802				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3802					      REPEND
     12  3803				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3803				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3803					      ENDIF
     15  3803		       50		      .byte.b	<.BOARD_LOCATION
     16  3803				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3803					      REPEND
     12  3804				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3804				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3804					      ENDIF
     15  3804		       78		      .byte.b	<.BOARD_LOCATION
     16  3804				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3804					      REPEND
     12  3805				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3805				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3805					      ENDIF
     15  3805		       a0		      .byte.b	<.BOARD_LOCATION
     16  3805				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3805					      REPEND
     12  3806				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3806				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3806					      ENDIF
     15  3806		       c8		      .byte.b	<.BOARD_LOCATION
     16  3806				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3806					      REPEND
     12  3807					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3807				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3807					      ENDIF
     15  3807		       00		      .byte.b	<.BOARD_LOCATION
     16  3807				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3807					      REPEND
     12  3808				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3808				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3808					      ENDIF
     15  3808		       28		      .byte.b	<.BOARD_LOCATION
     16  3808				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3808					      REPEND
     12  3809				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3809				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3809					      ENDIF
     15  3809		       50		      .byte.b	<.BOARD_LOCATION
     16  3809				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3809					      REPEND
     12  380a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  380a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  380a					      ENDIF
     15  380a		       78		      .byte.b	<.BOARD_LOCATION
     16  380a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  380a					      REPEND
     12  380b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  380b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  380b					      ENDIF
     15  380b		       a0		      .byte.b	<.BOARD_LOCATION
     16  380b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  380b					      REPEND
     12  380c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  380c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  380c					      ENDIF
     15  380c		       c8		      .byte.b	<.BOARD_LOCATION
     16  380c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  380c					      REPEND
     12  380d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  380d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  380d					      ENDIF
     15  380d		       00		      .byte.b	<.BOARD_LOCATION
     16  380d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  380d					      REPEND
     12  380e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  380e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  380e					      ENDIF
     15  380e		       28		      .byte.b	<.BOARD_LOCATION
     16  380e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  380e					      REPEND
     12  380f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  380f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  380f					      ENDIF
     15  380f		       50		      .byte.b	<.BOARD_LOCATION
     16  380f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  380f					      REPEND
     12  3810				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3810				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3810					      ENDIF
     15  3810		       78		      .byte.b	<.BOARD_LOCATION
     16  3810				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3810					      REPEND
     12  3811				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3811				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3811					      ENDIF
     15  3811		       a0		      .byte.b	<.BOARD_LOCATION
     16  3811				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3811					      REPEND
     12  3812				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3812				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3812					      ENDIF
     15  3812		       c8		      .byte.b	<.BOARD_LOCATION
     16  3812				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3812					      REPEND
     12  3813					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3813				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3813					      ENDIF
     15  3813		       00		      .byte.b	<.BOARD_LOCATION
     16  3813				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3813					      REPEND
     12  3814				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3814				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3814					      ENDIF
     15  3814		       28		      .byte.b	<.BOARD_LOCATION
     16  3814				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3814					      REPEND
     12  3815				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3815				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3815					      ENDIF
     15  3815		       50		      .byte.b	<.BOARD_LOCATION
     16  3815				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  3815					      REPEND
     12  3816				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  3816				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  3816					      ENDIF
     15  3816		       78		      .byte.b	<.BOARD_LOCATION
     16  3816				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     17  3817					      REPEND
      0  3817					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  3817					      LIST	ON
     19  3817
     20  3817		       03 a0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     21  3817
     22  3817							;------------------------------------------------------------------------------
     23  3817
     24  3817				   BoardLineStartHiR
     25  3817
     26  3817							; Gives the start address (HI) of each board line
     27  3817							; Note this caters for the memory wrapping when we go from bank to bank, as
     28  3817							; the board overlays multiple banks!
     29  3817
     30  3817				   .BOARD_LOCATION SET	Board
     31  3817					      REPEAT	SIZE_BOARD_Y
     32  3817				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3817				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3817					      ENDIF
     35  3817		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3817				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3817					      REPEND
     32  3818				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3818				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3818					      ENDIF
     35  3818		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3818				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3818					      REPEND
     32  3819				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3819				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3819					      ENDIF
     35  3819		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3819				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3819					      REPEND
     32  381a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  381a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  381a					      ENDIF
     35  381a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  381a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  381a					      REPEND
     32  381b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  381b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  381b					      ENDIF
     35  381b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  381b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  381b					      REPEND
     32  381c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  381c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  381c					      ENDIF
     35  381c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  381c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  381c					      REPEND
     32  381d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  381d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  381d					      ENDIF
     35  381d		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  381d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  381d					      REPEND
     32  381e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  381e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  381e					      ENDIF
     35  381e		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  381e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  381e					      REPEND
     32  381f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  381f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  381f					      ENDIF
     35  381f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  381f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  381f					      REPEND
     32  3820				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3820				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3820					      ENDIF
     35  3820		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3820				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3820					      REPEND
     32  3821				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3821				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3821					      ENDIF
     35  3821		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3821				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3821					      REPEND
     32  3822				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3822				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3822					      ENDIF
     35  3822		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3822				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3822					      REPEND
     32  3823					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3823				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3823					      ENDIF
     35  3823		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3823				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3823					      REPEND
     32  3824				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3824				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3824					      ENDIF
     35  3824		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3824				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3824					      REPEND
     32  3825				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3825				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3825					      ENDIF
     35  3825		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3825				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3825					      REPEND
     32  3826				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3826				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3826					      ENDIF
     35  3826		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3826				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3826					      REPEND
     32  3827				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3827				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3827					      ENDIF
     35  3827		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3827				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3827					      REPEND
     32  3828				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3828				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3828					      ENDIF
     35  3828		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3828				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3828					      REPEND
     32  3829					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  3829				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  3829					      ENDIF
     35  3829		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  3829				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  3829					      REPEND
     32  382a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  382a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  382a					      ENDIF
     35  382a		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  382a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  382a					      REPEND
     32  382b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  382b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  382b					      ENDIF
     35  382b		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  382b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  382b					      REPEND
     32  382c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  382c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  382c					      ENDIF
     35  382c		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  382c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     37  382d					      REPEND
      0  382d					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  382d					      LIST	ON
     39  382d							;------------------------------------------------------------------------------
     40  382d
     41  382d				   BoardLineStartHiW
     42  382d
     43  382d							; Gives the start address (HI) of each board line
     44  382d							; Note this caters for the memory wrapping when we go from bank to bank, as
     45  382d							; the board overlays multiple banks!
     46  382d
     47  382d				   .BOARD_LOCATION SET	Board
     48  382d					      REPEAT	SIZE_BOARD_Y
     49  382d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  382d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  382d					      ENDIF
     52  382d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  382d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  382d					      REPEND
     49  382e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  382e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  382e					      ENDIF
     52  382e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  382e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  382e					      REPEND
     49  382f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  382f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  382f					      ENDIF
     52  382f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  382f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  382f					      REPEND
     49  3830				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3830				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3830					      ENDIF
     52  3830		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3830				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3830					      REPEND
     49  3831				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3831				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3831					      ENDIF
     52  3831		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3831				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3831					      REPEND
     49  3832				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3832				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3832					      ENDIF
     52  3832		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3832				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3832					      REPEND
     49  3833					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3833				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3833					      ENDIF
     52  3833		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3833				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3833					      REPEND
     49  3834				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3834				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3834					      ENDIF
     52  3834		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3834				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3834					      REPEND
     49  3835				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3835				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3835					      ENDIF
     52  3835		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3835				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3835					      REPEND
     49  3836				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3836				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3836					      ENDIF
     52  3836		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3836				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3836					      REPEND
     49  3837				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3837				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3837					      ENDIF
     52  3837		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3837				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3837					      REPEND
     49  3838				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3838				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3838					      ENDIF
     52  3838		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3838				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3838					      REPEND
     49  3839					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3839				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3839					      ENDIF
     52  3839		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3839				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3839					      REPEND
     49  383a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  383a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  383a					      ENDIF
     52  383a		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  383a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  383a					      REPEND
     49  383b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  383b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  383b					      ENDIF
     52  383b		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  383b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  383b					      REPEND
     49  383c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  383c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  383c					      ENDIF
     52  383c		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  383c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  383c					      REPEND
     49  383d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  383d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  383d					      ENDIF
     52  383d		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  383d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  383d					      REPEND
     49  383e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  383e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  383e					      ENDIF
     52  383e		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  383e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  383e					      REPEND
     49  383f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  383f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  383f					      ENDIF
     52  383f		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  383f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  383f					      REPEND
     49  3840				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3840				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3840					      ENDIF
     52  3840		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3840				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3840					      REPEND
     49  3841				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3841				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3841					      ENDIF
     52  3841		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3841				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  3841					      REPEND
     49  3842				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  3842				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  3842					      ENDIF
     52  3842		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  3842				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     54  3843					      REPEND
      0  3843					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  3843					      LIST	ON
     56  3843
     57  3843							;------------------------------------------------------------------------------
     58  3843				  -	      IF	MULTI_BANK_BOARD = YES
     59  3843				  -BoardBank
     60  3843					      ENDIF
     61  3843							; Gives the RAM bank of the start of the board row for a given row.
     62  3843
     63  3843				   .BOARD_LOCATION SET	Board - RAM_3E
     64  3843					      REPEAT	SIZE_BOARD_Y
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  3843					      REPEND
     65  3843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  3843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  3843					      ENDIF
     68  3843				  -	      IF	MULTI_BANK_BOARD = YES
     69  3843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  3843					      ENDIF
     71  3843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     72  3843					      REPEND
     73  3843				  -	      IF	MULTI_BANK_BOARD = YES
     74  3843				  -	      CHECKPAGEX	BoardBank, "BoardBank in BANK_INITBANK.asm"
     75  3843					      ENDIF
     76  3843
     77  3843
     78  3843							;------------------------------------------------------------------------------
     79  3843
     80  3843				   CopyROMShadowToRAM_F000
     81  3843		       a9 f0		      lda	#>$F000
     82  3845
      0  3845					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  3845		       00 07	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  3845					      SUBROUTINE
      3  3845				   CopyROMShadowToRAM
     84  3845
     85  3845							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
     86  3845							; the variable definitions are in the ROM shadow because this allows auto-initialisation
     87  3845							; of the variable contents from ROM declarations, but still allows access to them as
     88  3845							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
     89  3845							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
     90  3845							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
     91  3845							; code co-lives in all banks and may run even as bankswitching occurs between those
     92  3845							; banks -- by the very code itself.
     93  3845
     94  3845							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
     95  3845		       85 be		      sta	Board_AddressR+1
     96  3847		       86 df		      stx	O_ROM_Source_Bank	; source bank
     97  3849		       84 c2		      sty	RAM_Bank	; destination bank
     98  384b
     99  384b		       a0 00		      ldy	#0
    100  384d		       84 bd		      sty	Board_AddressR
    101  384f		       84 bf		      sty	Board_AddressW
    102  3851		       a9 14		      lda	#>($1000+RAM_WRITE)
    103  3853		       85 c0		      sta	Board_AddressW+1
    104  3855
    105  3855							; Iterate 4 pages (1K) for complete bank copy
    106  3855
    107  3855		       a9 04		      lda	#4
    108  3857		       85 de		      sta	O_CopyCount
    109  3859
    110  3859		       84 e0	   CopyPage   sty	O_Index
    111  385b		       a5 df		      lda	O_ROM_Source_Bank
    112  385d		       20 3c f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    113  3860							;tax
    114  3860		       a4 e0		      ldy	O_Index
    115  3862		       a6 c2		      ldx	RAM_Bank
    116  3864		       20 4a f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    117  3867
    118  3867		       a4 e0		      ldy	O_Index
    119  3869		       c8		      iny
    120  386a		       d0 ed		      bne	CopyPage
    121  386c
    122  386c		       e6 be		      inc	Board_AddressR+1
    123  386e		       e6 c0		      inc	Board_AddressW+1
    124  3870
    125  3870		       c6 de		      dec	O_CopyCount
    126  3872		       d0 e5		      bne	CopyPage
    127  3874
    128  3874		       a4 c2		      ldy	RAM_Bank	; TODO: remove!?
    129  3876		       60		      rts
    130  3877
    131  3877
    132  3877							;------------------------------------------------------------------------------
      0  3877					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  3877		       00 07	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  3877					      SUBROUTINE
      3  3877				   SetPlatformColours
    134  3877
    135  3877							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    136  3877							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    137  3877							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    138  3877							; addressing will not violate the page-crossing restriction of 3E.
    139  3877
    140  3877							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    141  3877
    142  3877		       a9 00		      lda	#<DrawTheScreen	; = 0
    143  3879		       85 bf		      sta	Board_AddressW
    144  387b		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    145  387d		       85 c0		      sta	Board_AddressW+1
    146  387f
    147  387f							; first, set the x index (with last one being a RTS ($60))
    148  387f
    149  387f		       a6 c2		      ldx	RAM_Bank
    150  3881		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    151  3883		       d0 07		      bne	.skipPatch
    152  3885		       a9 60		      lda	#$60	; rts
    153  3887		       a0 41		      ldy	#<SELFMOD_X
    154  3889		       20 4a f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    155  388c				   .skipPatch
    156  388c
    157  388c		       a2 02		      ldx	#3-1
    158  388e				   .loopColor
    159  388e		       86 de		      stx	colorIdx
    160  3890							; set PF colors
    161  3890		       b5 ba		      lda	color,x
    162  3892		       bc b7 f0 	      ldy	SelfModColOfsTbl,x
    163  3895							;tax
    164  3895		       a6 c2		      ldx	RAM_Bank
    165  3897		       20 4a f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy PF colour RED/GREEN/BLUE to self-modifying RAM
    166  389a							; set player colors
    167  389a		       a6 de		      ldx	colorIdx
    168  389c		       bd ba f0 	      lda	SelfModePlayerTbl,x
    169  389f		       a4 81		      ldy	Platform
    170  38a1		       c0 02		      cpy	#PAL
    171  38a3		       90 02		      bcc	.platform0
    172  38a5		       69 14		      adc	#LINES_PER_CHAR-1	; C==1!
    173  38a7				   .platform0
    174  38a7		       bc bd f0 	      ldy	SelfModPlayerColOfsTbl,x
    175  38aa							;tax
    176  38aa		       a6 c2		      ldx	RAM_Bank
    177  38ac		       20 4a f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy player colour RED/GREEN/BLUE to self-modifying RAM
    178  38af							; loop
    179  38af		       a6 de		      ldx	colorIdx
    180  38b1		       ca		      dex
    181  38b2		       10 da		      bpl	.loopColor
    182  38b4
    183  38b4		       a4 c2		      ldy	RAM_Bank
    184  38b6		       60		      rts
    185  38b7
    186  38b7				   SelfModColOfsTbl
    187  38b7		       53 86 1c 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    188  38ba				   SelfModePlayerTbl
    189  38ba		       bd b6 af 	      .byte.b	<SpriteColourBLUE, <SpriteColourGREEN, <SpriteColourRED
    190  38bd				   SelfModPlayerColOfsTbl
    191  38bd		       4c 7f 15 	      .byte.b	<(SELFMOD_PLAYERCOL_BLUE+1), <(SELFMOD_PLAYERCOL_GREEN+1), <(SELFMOD_PLAYERCOL_RED+1)
    192  38c0
    193  38c0
    194  38c0				   DrawLineStartLO
    195  38c0
    196  38c0							; Gives the start address of each line in the draw flags buffer
    197  38c0
    198  38c0				   .DRAW_LOCATION SET	DrawFlag
    199  38c0					      REPEAT	SCREEN_LINES
    200  38c0		       50		      .byte.b	<.DRAW_LOCATION
    201  38c0				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  38c0					      REPEND
    200  38c1		       5a		      .byte.b	<.DRAW_LOCATION
    201  38c1				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  38c1					      REPEND
    200  38c2		       64		      .byte.b	<.DRAW_LOCATION
    201  38c2				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  38c2					      REPEND
    200  38c3		       6e		      .byte.b	<.DRAW_LOCATION
    201  38c3				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  38c3					      REPEND
    200  38c4		       78		      .byte.b	<.DRAW_LOCATION
    201  38c4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  38c4					      REPEND
    200  38c5		       82		      .byte.b	<.DRAW_LOCATION
    201  38c5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  38c5					      REPEND
    200  38c6		       8c		      .byte.b	<.DRAW_LOCATION
    201  38c6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  38c6					      REPEND
    200  38c7		       96		      .byte.b	<.DRAW_LOCATION
    201  38c7				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    202  38c8					      REPEND
    203  38c8
    204  38c8
    205  38c8							;------------------------------------------------------------------------------
    206  38c8
      0  38c8					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  38c8		       00 07	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  38c8					      SUBROUTINE
      3  38c8				   GetBoardAddressRW
    208  38c8							; Must share same bank as BoardLineStart tables
    209  38c8
    210  38c8		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    211  38cb		       85 bd		      sta	Board_AddressR	; 3
    212  38cd		       85 bf		      sta	Board_AddressW	; 3
    213  38cf		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    214  38d2		       85 be		      sta	Board_AddressR+1	; 3	     READ address
    215  38d4		       09 04		      ora	#>RAM_WRITE	; 2
    216  38d6		       85 c0		      sta	Board_AddressW+1	; 3	     WRITE address
    217  38d8				  -	      IF	MULTI_BANK_BOARD = YES
    218  38d8				  -	      ldx	BoardBank,y	; 4 = 26    switch this on return
    219  38d8					      ELSE
    220  38d8		       a2 0d		      ldx	#BANK_BOARD	; 2
    221  38da					      ENDIF
    222  38da		       60		      rts		; 6 = 32[-2]
    223  38db
    224  38db							;------------------------------------------------------------------------------
    225  38db
      0  38db					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  38db		       00 07	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  38db					      SUBROUTINE
      3  38db				   GetBoardAddressR
    227  38db
    228  38db		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    229  38de		       85 bd		      sta	Board_AddressR	; 3
    230  38e0		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    231  38e3		       85 be		      sta	Board_AddressR+1	; 3	 READ address
    232  38e5				  -	      IF	MULTI_BANK_BOARD = YES
    233  38e5				  -	      lda	BoardBank,y	; 4	 switch this on return
    234  38e5					      ELSE
    235  38e5		       a9 0d		      lda	#BANK_BOARD	; 2
    236  38e7					      ENDIF
    237  38e7		       60		      rts		; 6[-2]
    238  38e8
    239  38e8							;------------------------------------------------------------------------------
    240  38e8
    241  38e8							; +------+------+------+
    242  38e8							; |*	  | a(0) |	|   *= where Temp_board_address1 points
    243  38e8							; +------+------+------+
    244  38e8							; | d(3) | X(4) | b(1) |
    245  38e8							; +------+------+------+
    246  38e8							; |	  | c(2) |	|
    247  38e8							; +------+------+------+
    248  38e8
    249  38e8
      0  38e8					      DEFINE_SUBROUTINE	GetBoardAddress4	;=72[-16](C)
      1  38e8		       00 07	   BANK_GetBoardAddress4 =	_CURRENT_BANK
      2  38e8					      SUBROUTINE
      3  38e8				   GetBoardAddress4
    251  38e8
    252  38e8		       a4 8b		      ldy	POS_Y	;3
    253  38ea
    254  38ea		       b9 00 f0 	      lda	BoardLineStartLO-1,y	;4
    255  38ed		       85 de		      sta	Temp_Board_Address1	;3
    256  38ef		       b9 01 f0 	      lda	BoardLineStartLO+1-1,y	;4
    257  38f2		       85 e0		      sta	Temp_Board_Address2	;3
    258  38f4		       b9 02 f0 	      lda	BoardLineStartLO+2-1,y	;4
    259  38f7		       85 e2		      sta	Temp_Board_Address3	;3
    260  38f9		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	;4
    261  38fc		       85 df		      sta	Temp_Board_Address1+1	;3
    262  38fe		       b9 17 f0 	      lda	BoardLineStartHiR+1-1,y	;4
    263  3901		       85 e1		      sta	Temp_Board_Address2+1	;3
    264  3903		       b9 18 f0 	      lda	BoardLineStartHiR+2-1,y	;4
    265  3906		       85 e3		      sta	Temp_Board_Address3+1	;3
    266  3908				  -	      IF	MULTI_BANK_BOARD = YES
    267  3908				  -	      lda	BoardBank+1-1,y	;4
    268  3908				  -	      sta	Temp_Bank2	;3
    269  3908				  -	      lda	BoardBank+2-1,y	;4
    270  3908				  -	      sta	Temp_Bank3	;3
    271  3908				  -	      lda	BoardBank-1,y	;4
    272  3908				  -			;sta Temp_Bank 		 ;   this becomes switched in RAM bank in normal usage
    273  3908					      ELSE
    274  3908		       a9 0d		      lda	#BANK_BOARD	;2
    275  390a					      ENDIF
    276  390a		       a4 8a		      ldy	POS_X	;3
    277  390c		       60		      rts		;6 = 72[-16]
    278  390d
    279  390d							;------------------------------------------------------------------------------
    280  390d
      0  390d					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  390d		       00 07	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  390d					      SUBROUTINE
      3  390d				   GetBoardAddressW
    282  390d
    283  390d							; Must share same bank as BoardLineStart tables
    284  390d
    285  390d		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    286  3910		       85 bf		      sta	Board_AddressW	;3
    287  3912		       b9 2d f0 	      lda	BoardLineStartHiW,y	;4
    288  3915		       85 c0		      sta	Board_AddressW+1	;3 WRITE address
    289  3917				  -	      IF	MULTI_BANK_BOARD = YES
    290  3917				  -	      ldx	BoardBank,y	;4 switch this on return
    291  3917					      ELSE
    292  3917		       a2 0d		      ldx	#BANK_BOARD	;2
    293  3919					      ENDIF
    294  3919		       60	   QRet       rts		;6
    295  391a
    296  391a							;-------------------------------------------------------------------------------
    297  391a
    298  391a
    299  391a				   OBJTYPE    SET	0
    300  391a					      MAC	define_character
    301  391a				   CHARACTER_{1} =	OBJTYPE
    302  391a				   OBJTYPE    .SET	OBJTYPE + 1
    303  391a					      ENDM
    304  391a
    305  391a							; Modifications to character #/order must also ensure the following are correct...
    306  391a							;   CharacterDataVecLO/HI	   in BANK_FIXED.asm
    307  391a							;   MoveVecLO/HI		   in BANK_INITBANK
    308  391a							;   CharReplacement		   in BANK_ROM_SHADOW_DRAWBUFFERS
    309  391a
      0  391a					      DEFINE_CHARACTER	BLANK
      1  391a		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	SOIL
      1  391a		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	BOX
      1  391a		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	TARGET
      1  391a		       00 03	   CHARACTER_TARGET =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	TARGET2
      1  391a		       00 04	   CHARACTER_TARGET2 =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	MANOCCUPIED
      1  391a		       00 05	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	STEEL
      1  391a		       00 06	   CHARACTER_STEEL =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	WALL
      1  391a		       00 07	   CHARACTER_WALL =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	BOX_ON_TARGET
      1  391a		       00 08	   CHARACTER_BOX_ON_TARGET =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
      0  391a					      DEFINE_CHARACTER	NOGO
      1  391a		       00 09	   CHARACTER_NOGO =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
    320  391a
      0  391a					      DEFINE_CHARACTER	MAXIMUM
      1  391a		       00 0a	   CHARACTER_MAXIMUM =	OBJTYPE
      2  391a				   OBJTYPE    .SET	OBJTYPE + 1
    322  391a
    323  391a							;------------------------------------------------------------------------------
    324  391a
      0  391a					      DEFINE_SUBROUTINE	PushBox	; in INITBANK
      1  391a		       00 07	   BANK_PushBox =	_CURRENT_BANK
      2  391a					      SUBROUTINE
      3  391a				   PushBox
    326  391a
    327  391a							; X = restoration character for square we are moving TO
    328  391a							; so, if X = CHARACTER_TARGET AND we move, THEN we are pushing a box off a diamond
    329  391a
    330  391a		       85 c1		      sta	ROM_Bank
    331  391c
    332  391c		       a5 a3		      lda	ManPushCounter
    333  391e		       c9 01		      cmp	#PUSH_LIMIT
    334  3920		       90 6c		      bcc	cannotPush
    335  3922
    336  3922		       86 e0		      stx	restorationCharacter	; BOX'S NEW CHAR
    337  3924
    338  3924							; Determine if the box is pushable
    339  3924							; we use the joystick to calculate the subsequent square
    340  3924
    341  3924		       a5 90		      lda	BufferedJoystick
    342  3926		       4a		      lsr
    343  3927		       4a		      lsr
    344  3928		       4a		      lsr
    345  3929		       4a		      lsr
    346  392a		       48		      pha
    347  392b		       a8		      tay
    348  392c
    349  392c		       18		      clc
    350  392d		       a5 8d		      lda	POS_Y_NEW
    351  392f		       79 47 f3 	      adc	JoyMoveY,y
    352  3932		       a8		      tay
    353  3933		       20 c8 f0 	      jsr	GetBoardAddressRW
    354  3936
    355  3936		       68		      pla
    356  3937		       a8		      tay
    357  3938
    358  3938		       18		      clc
    359  3939		       a5 8c		      lda	POS_X_NEW
    360  393b		       79 3b f3 	      adc	JoyMoveX,y
    361  393e		       48		      pha
    362  393f		       a8		      tay
    363  3940
    364  3940				  -	      IF	MULTI_BANK_BOARD = YES
    365  3940				  -	      lda	RAM_Bank
    366  3940					      ELSE
    367  3940		       a9 0d		      lda	#BANK_BOARD	; 2
    368  3942					      ENDIF
    369  3942		       20 41 f8 	      jsr	GetBoardCharacter	;6+20(A)
    370  3945		       68		      pla
    371  3946		       a8		      tay
    372  3947
    373  3947		       a9 02		      lda	#CHARACTER_BOX
    374  3949		       e0 00		      cpx	#CHARACTER_BLANK
    375  394b		       f0 13		      beq	canPushTarget
    376  394d
    377  394d		       e0 03		      cpx	#CHARACTER_TARGET
    378  394f		       f0 04		      beq	decreaseTargets
    379  3951		       e0 04		      cpx	#CHARACTER_TARGET2
    380  3953		       d0 39		      bne	cannotPush
    381  3955
    382  3955							; Box is now on a target - so decrease the remaining targets
    383  3955
    384  3955		       f8	   decreaseTargets sed
    385  3956		       38		      sec
    386  3957		       a5 b6		      lda	targetsRequired
    387  3959		       e9 01		      sbc	#1
    388  395b		       85 b6		      sta	targetsRequired
    389  395d		       d8		      cld
    390  395e
    391  395e		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    392  3960		       48	   canPushTarget pha
    393  3961
    394  3961							; If the box *WAS* on a target (restoration character = CHARACTER_TARGET)
    395  3961							; then we increase targets (as there is one more to get)
    396  3961
    397  3961		       a5 e0		      lda	restorationCharacter
    398  3963		       c9 03		      cmp	#CHARACTER_TARGET
    399  3965		       d0 09		      bne	notOnTargetAlready
    400  3967
    401  3967							; increase the required targets as box is leaving one
    402  3967
    403  3967		       f8		      sed
    404  3968		       18		      clc
    405  3969		       a5 b6		      lda	targetsRequired
    406  396b		       69 01		      adc	#1
    407  396d		       85 b6		      sta	targetsRequired
    408  396f		       d8		      cld
    409  3970
    410  3970				   notOnTargetAlready
    411  3970
    412  3970		       68		      pla
    413  3971
    414  3971
    415  3971				  -	      IF	MULTI_BANK_BOARD = YES
    416  3971				  -	      ldx	RAM_Bank
    417  3971					      ELSE
    418  3971		       a2 0d		      ldx	#BANK_BOARD	; 2
    419  3973					      ENDIF
    420  3973		       20 4a f8 	      jsr	PutBoardCharacter	;6+21(A)
    421  3976
    422  3976		       a5 8f		      lda	POS_VAR	; player's restoration character
    423  3978		       48		      pha
    424  3979
    425  3979		       a6 8d		      ldx	POS_Y_NEW
    426  397b		       86 8b		      stx	POS_Y
    427  397d		       a4 8c		      ldy	POS_X_NEW
    428  397f		       84 8a		      sty	POS_X
    429  3981		       a5 e0		      lda	restorationCharacter
    430  3983		       85 8f		      sta	POS_VAR
    431  3985
    432  3985		       20 8f f9 	      jsr	RestoreOriginalCharacter	; put back BOX's restoration character
    433  3988
    434  3988		       68		      pla
    435  3989		       85 8f		      sta	POS_VAR
    436  398b
    437  398b							;START_SOUND SOUND_BOX
    438  398b
    439  398b		       4c ee f9 	      jmp	MovePlayer	; now there's a gap, player should move in
    440  398e
    441  398e		       e6 a3	   cannotPush inc	ManPushCounter
    442  3990		       60		      rts
    443  3991
    444  3991							;------------------------------------------------------------------------------
    445  3991
    446  3991							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    447  3991							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    448  3991
    449  3991							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    450  3991
    451  3991							; if the creature dies then jump NextObject
    452  3991
    453  3991
    454  3991
    455  3991		       ff	   RDirY      .byte.b	-1	;,0,1,0
    456  3992		       00 01	   RDirX      .byte.b	0,1	;,0,-1
    457  3994		       00 ff 01 00 DirPushModX .byte.b	0,-1,1,0
    458  3998		       ff 00 00 01 DirPushModY .byte.b	-1,0,0,1
    459  399c		       01 02 03 00*Directional .byte.b	1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    460  39aa
    461  39aa
    462  39aa							;------------------------------------------------------------------------------
    463  39aa
    464  39aa							; Thomas, the auto-calculation of these was causing DASM to get confused and abort assembling.
    465  39aa							; I don't particularly know why; probably because of the cave variable-size array and the values
    466  39aa							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    467  39aa
    468  39aa		       00 00	   MANMODE_STARTUP =	0
    469  39aa		       00 01	   MANMODE_NORMAL =	1
    470  39aa		       00 02	   MANMODE_DEAD =	2
    471  39aa		       00 03	   MANMODE_WAITING =	3
    472  39aa		       00 04	   MANMODE_WAITING2 =	4
    473  39aa		       00 05	   MANMODE_WAITING_NT =	5
    474  39aa		       00 06	   MANMODE_WAITING_NT2 =	6
    475  39aa		       00 07	   MANMODE_NEXTLEVEL =	7
    476  39aa		       00 08	   MANMODE_BONUS_START =	8
    477  39aa		       00 09	   MANMODE_BONUS_RUN =	9
    478  39aa
      0  39aa					      DEFINE_SUBROUTINE	ManProcess	; in INITBANK
      1  39aa		       00 07	   BANK_ManProcess =	_CURRENT_BANK
      2  39aa					      SUBROUTINE
      3  39aa				   ManProcess
    480  39aa
    481  39aa							;lda #$FF
    482  39aa							;sta specialTimeFlag		  ; detects time overflow in bigbang (and diamond grab)
    483  39aa
    484  39aa
    485  39aa							; ManMode tells the player what it is currently doing.  State machine.
    486  39aa
    487  39aa				  -	      if	0
    488  39aa				  -	      lda	SWCHB
    489  39aa				  -	      and	#2
    490  39aa				  -	      bne	skipNextLevel
    491  39aa				  -	      lda	#MANMODE_NEXTLEVEL
    492  39aa				  -	      sta	ManMode
    493  39aa				  -skipNextLevel
    494  39aa					      endif
    495  39aa
    496  39aa		       a5 b6		      lda	targetsRequired
    497  39ac		       d0 04		      bne	notComplete
    498  39ae		       a9 07		      lda	#MANMODE_NEXTLEVEL
    499  39b0		       85 9d		      sta	ManMode
    500  39b2				   notComplete
    501  39b2
    502  39b2		       ad 82 02 	      lda	SWCHB
    503  39b5		       29 03		      and	#3
    504  39b7		       d0 03		      bne	.skipReset	; BOTH select/reset = restart
    505  39b9
    506  39b9							;		  lsr SWCHB
    507  39b9							;		  bcs .skipReset
    508  39b9
    509  39b9				  -	      IF	F1F2NEXTCAVE=YES
    510  39b9				  -	      lda	#MANMODE_NEXTLEVEL
    511  39b9				  -	      sta	ManMode
    512  39b9					      ELSE
    513  39b9		       4c 1f fb 	      jmp	Restart	; RESET = end game, jump to title screen
    514  39bc					      ENDIF
    515  39bc
    516  39bc				   .skipReset
    517  39bc
    518  39bc							;sokldy ManMode
    519  39bc							;sok lda ManActionTimer,y
    520  39bc							;sok beq .skipTimer
    521  39bc		       20 e6 f1 	      jsr	UpdateTimer
    522  39bf				   .skipTimer
    523  39bf		       a4 9d		      ldy	ManMode
    524  39c1		       b9 d6 f1 	      lda	ManActionLO,y
    525  39c4		       85 de		      sta	actionVector
    526  39c6		       b9 de f1 	      lda	ManActionHI,y
    527  39c9		       85 df		      sta	actionVector+1
    528  39cb		       6c de 00 	      jmp	(actionVector)
    529  39ce
    530  39ce				   ManActionTimer
    531  39ce		       00		      .byte.b	0	;<manStartup		 ; 0		 no timer
    532  39cf		       01		      .byte.b	1	;<normalMan		 ; 1		 timer
    533  39d0		       01		      .byte.b	1	;<deadMan		 ; 2		 timer
    534  39d1		       01		      .byte.b	1	;<waitingMan		 ; 3		 timer
    535  39d2		       01		      .byte.b	1	;<waitingManPress	 ; 4		 timer
    536  39d3		       00		      .byte.b	0	;<waitingManNoTim	 ; 5		 no timer
    537  39d4		       00		      .byte.b	0	;<waitingManPressNoTim  ; 6		 no timer
    538  39d5		       00		      .byte.b	0	;<nextLevelMan 	 ; 7		 no timer
    539  39d6				   ManActionLO
    540  39d6		       19		      .byte.b	<manStartup	; 0		 no timer
    541  39d7		       ab		      .byte.b	<normalMan	; 1		 timer
    542  39d8		       b4		      .byte.b	<deadMan	; 2		 timer
    543  39d9		       4f		      .byte.b	<waitingMan	; 3		 timer
    544  39da		       72		      .byte.b	<waitingManPress	; 4		 timer
    545  39db		       4f		      .byte.b	<waitingMan	; 5		 no timer
    546  39dc		       72		      .byte.b	<waitingManPress	; 6		 no timer
    547  39dd		       14		      .byte.b	<nextLevelMan	; 7		 no timer
    548  39de
    549  39de				   ManActionHI
    550  39de		       f2		      .byte.b	>manStartup	; no timer
    551  39df		       f2		      .byte.b	>normalMan	; timer
    552  39e0		       f2		      .byte.b	>deadMan	; timer
    553  39e1		       f2		      .byte.b	>waitingMan	; timer
    554  39e2		       f2		      .byte.b	>waitingManPress	; timer
    555  39e3		       f2		      .byte.b	>waitingMan	; no timer
    556  39e4		       f2		      .byte.b	>waitingManPress	; no timer
    557  39e5		       fd		      .byte.b	>nextLevelMan	; no timer
    558  39e6
    559  39e6							;------------------------------------------------------------------------------
      0  39e6					      DEFINE_SUBROUTINE	UpdateTimer
      1  39e6		       00 07	   BANK_UpdateTimer =	_CURRENT_BANK
      2  39e6					      SUBROUTINE
      3  39e6				   UpdateTimer
    561  39e6
    562  39e6		       a9 09		      lda	#BANK_SCORING
    563  39e8		       20 32 f8 	      jsr	DrawTargetsRequiredFromROM
    564  39eb
    565  39eb
    566  39eb		       a2 03		      ldx	#3
    567  39ed		       a5 9d		      lda	ManMode
    568  39ef		       c9 09		      cmp	#MANMODE_BONUS_RUN
    569  39f1		       f0 0a		      beq	.setLoops
    570  39f3
    571  39f3		       a2 04		      ldx	#NUM_LEVELS-1	; intermissions run at full speed
    572  39f5		       24 b3		      bit	levelDisplay
    573  39f7		       30 02		      bmi	.intermission2
    574  39f9		       a6 b2		      ldx	level
    575  39fb				   .intermission2
    576  39fb
    577  39fb							;		  lda TimeFracTbl,x
    578  39fb							;		  bit LookingAround
    579  39fb							;		  bpl notSlowTime
    580  39fb							;		  lda #0			   ; new behaviour: time does not count down when looking around
    581  39fb							;lsr				  ; go half-speed time countdown when looking around
    582  39fb							;notSlowTime
    583  39fb							;		  adc caveTimeFrac
    584  39fb							;		  sta caveTimeFrac
    585  39fb							;		  bcc .forceTimeDraw
    586  39fb
    587  39fb		       a2 01		      ldx	#1
    588  39fd				   .setLoops
    589  39fd		       86 df		      stx	timerLoops
    590  39ff		       d0 08		      bne	.notScoring
    591  3a01				   .loopTimer
    592  3a01		       a5 b2		      lda	level	; each second left adds 'level' to score
    593  3a03		       18		      clc
    594  3a04		       69 01		      adc	#1
    595  3a06		       20 08 fd 	      jsr	ScoreAdd
    596  3a09				   .notScoring
    597  3a09							;		  sed
    598  3a09							;		  sec
    599  3a09							;		  lda caveTime
    600  3a09							;		  sbc #1
    601  3a09							;		  sta caveTime
    602  3a09							;		  cld
    603  3a09							;		  bcs .skipHi2a
    604  3a09							;		  dec caveTimeHi
    605  3a09							;.skipHi2a
    606  3a09							; check for running out of time sound:
    607  3a09							;		  lda caveTimeHi
    608  3a09							;		  bne .timeAbove9
    609  3a09							;		  lda #$09
    610  3a09							;		  sec
    611  3a09							;		  sbc caveTime
    612  3a09							;		  bcc .timeAbove9
    613  3a09							; this assumes that SND_MASK_HI = %11110000
    614  3a09							;  and the time entries are ordered 9 to 0!
    615  3a09							;		  asl
    616  3a09							;		  asl
    617  3a09							;		  asl
    618  3a09							;		  asl
    619  3a09							;		  adc #SOUND_TIME_9
    620  3a09							;		  sta tmpSound
    621  3a09							;		  lda newSounds
    622  3a09							;		  and #<(~SND_MASK_HI)
    623  3a09							;		  ora tmpSound
    624  3a09							;		  sta newSounds
    625  3a09							;.skipTimeSound:
    626  3a09							;		  ldx caveTime
    627  3a09							;		  bne .timeNotZero
    628  3a09							;		  stx AUDV0			  ; stop bonus sound
    629  3a09							;		  stx soundIdxLst
    630  3a09							;.contChannel1:
    631  3a09							;		  ldx #MANMODE_NEXTLEVEL	  ; time bonus
    632  3a09							;		  lda ManMode
    633  3a09							;		  cmp #MANMODE_BONUS_RUN
    634  3a09							;		  beq .nextLevel
    635  3a09							;		  ldx #MANMODE_WAITING_NT2	  ; time over
    636  3a09							;		  cmp #MANMODE_WAITING2 	  ; Man already dead?
    637  3a09							;		  beq .nextLevel
    638  3a09							;		  dex				  ; == MANMODE_WAITING_NT
    639  3a09							;.nextLevel
    640  3a09							;		  stx ManMode			  ; -> man dies, but no explosion
    641  3a09				   .timeNotZero
    642  3a09				   .forceTimeDraw
    643  3a09
    644  3a09
    645  3a09		       a9 09		      lda	#BANK_SCORING
    646  3a0b		       4c 2a f8 	      jmp	DrawTimeFromROM	; Z-flag == 0!
    647  3a0e
    648  3a0e				   .timeAbove9
    649  3a0e		       c6 df		      dec	timerLoops
    650  3a10		       d0 ef		      bne	.loopTimer
    651  3a12		       f0 f5		      beq	.forceTimeDraw
    652  3a14
    653  3a14				   TimeFracTbl
    654  3a14		       1f		      .byte.b	31	; level 1, NTSC/PAL
    655  3a15		       1b		      .byte.b	27	; level 2, NTSC/PAL
    656  3a16		       18		      .byte.b	24	; level 3, NTSC/PAL
    657  3a17		       17		      .byte.b	23	; level 4, NTSC/PAL
    658  3a18		       16		      .byte.b	22	; level 5, NTSC/PAL
    659  3a19							; calculate: level 5 throttle * level 5 time / level x throttle
    660  3a19
    661  3a19
    662  3a19							;------------------------------------------------------------------------------
      0  3a19					      DEFINE_SUBROUTINE	manStartup
      1  3a19		       00 07	   BANK_manStartup =	_CURRENT_BANK
      2  3a19					      SUBROUTINE
      3  3a19				   manStartup
    664  3a19
    665  3a19				  -	      if	0
    666  3a19				  -	      lda	POS_Type
    667  3a19				  -	      pha
    668  3a19				  -	      lda	#TYPE_CIRCLE
    669  3a19				  -	      sta	POS_Type
    670  3a19				  -	      jsr	InsertObjectStack
    671  3a19				  -	      pla
    672  3a19				  -	      sta	POS_Type
    673  3a19					      endif
    674  3a19
    675  3a19		       a5 99		      lda	ManX
    676  3a1b		       85 8c		      sta	POS_X_NEW	;NewX
    677  3a1d		       85 8a		      sta	POS_X
    678  3a1f		       a5 9a		      lda	ManY
    679  3a21		       85 8d		      sta	POS_Y_NEW	;NewY
    680  3a23		       85 8b		      sta	POS_Y
    681  3a25
    682  3a25		       e6 8f		      inc	POS_VAR
    683  3a27		       a6 8f		      ldx	POS_VAR	; animation index
    684  3a29		       bd 3d f2 	      lda	.ManStartup-1,x
    685  3a2c		       30 09		      bmi	CreateRockford
    686  3a2e		       85 8e		      sta	POS_Type
    687  3a30
    688  3a30		       a9 ff		      lda	#$FF
    689  3a32		       85 9e		      sta	ManDelayCount	; anything, just non-0
    690  3a34
    691  3a34		       4c 67 f8 	      jmp	PutBoardCharacterFromRAM	;70 --> switches this bank out but who cares!
    692  3a37
    693  3a37				   CreateRockford
    694  3a37
    695  3a37		       a9 00		      lda	#CHARACTER_BLANK
    696  3a39		       85 8f		      sta	POS_VAR
    697  3a3b
    698  3a3b		       e6 9d		      inc	ManMode	; --> MANMODE_NORMAL
    699  3a3d				   RTS_CF
    700  3a3d		       60		      rts
    701  3a3e
    702  3a3e				   .ManStartup
    703  3a3e							;    .byte CHARACTER_NOGO
    704  3a3e							;    .byte CHARACTER_NOGO
    705  3a3e		       06		      .byte.b	CHARACTER_STEEL
    706  3a3f		       06		      .byte.b	CHARACTER_STEEL
    707  3a40		       09		      .byte.b	CHARACTER_NOGO
    708  3a41		       09		      .byte.b	CHARACTER_NOGO
    709  3a42		       06		      .byte.b	CHARACTER_STEEL
    710  3a43		       09		      .byte.b	CHARACTER_NOGO
    711  3a44		       06		      .byte.b	CHARACTER_STEEL
    712  3a45		       09		      .byte.b	CHARACTER_NOGO
    713  3a46		       06		      .byte.b	CHARACTER_STEEL
    714  3a47		       09		      .byte.b	CHARACTER_NOGO
    715  3a48		       06		      .byte.b	CHARACTER_STEEL
    716  3a49		       09		      .byte.b	CHARACTER_NOGO
    717  3a4a		       06		      .byte.b	CHARACTER_STEEL
    718  3a4b		       09		      .byte.b	CHARACTER_NOGO
    719  3a4c		       06		      .byte.b	CHARACTER_STEEL
    720  3a4d							;.byte CHARACTER_NOGO
    721  3a4d							;.byte CHARACTER_EXPLOSION3
    722  3a4d							;.byte CHARACTER_EXPLOSION
    723  3a4d							;.byte CHARACTER_EXPLOSION2
    724  3a4d							;.byte CHARACTER_EXPLOSION1
    725  3a4d		       05		      .byte.b	CHARACTER_MANOCCUPIED
    726  3a4e		       ff		      .byte.b	-1
    727  3a4f
    728  3a4f							;------------------------------------------------------------------------------
    729  3a4f
    730  3a4f		       c6 9e	   waitingMan dec	ManDelayCount
    731  3a51
    732  3a51		       a9 00		      lda	#0
    733  3a53		       85 a4		      sta	LookingAround
    734  3a55		       85 b0		      sta	BGColour
    735  3a57
    736  3a57							; Wait for button to be RELEASED first!
    737  3a57
    738  3a57		       a5 92		      lda	BufferedButton
    739  3a59		       10 4f		      bpl	noChange
    740  3a5b		       e6 9d		      inc	ManMode
    741  3a5d
    742  3a5d							; Man loses a life and re-starts level if lives available
    743  3a5d							; Special-case: Bonus levels go to next level.
    744  3a5d
    745  3a5d		       a5 b3		      lda	levelDisplay
    746  3a5f		       30 0d		      bmi	intermission	; don't lose a life on intermission screens
    747  3a61					      IF	NUM_LIVES != -1
    748  3a61		       c6 a5		      dec	ManCount	; works for P1P2 format
    749  3a63							; display lives after a live is lost
    750  3a63		       a5 c6		      lda	scoringFlags	;
    751  3a65		       29 fc		      and	#~DISPLAY_FLAGS
    752  3a67		       09 02		      ora	#DISPLAY_LIVES
    753  3a69		       85 c6		      sta	scoringFlags	;
    754  3a6b					      ENDIF
    755  3a6b		       20 1b fd 	      jsr	goGeneralScoringSetups	; update the life display. Roundabout way of doing it.
    756  3a6e				   intermission
    757  3a6e
    758  3a6e		       a9 78		      lda	#120	; something long.  anything.
    759  3a70		       85 c5		      sta	scoringTimer	; first time through we wait on the current display
    760  3a72
    761  3a72				   waitingManPress
    762  3a72
    763  3a72							; Cycle the score display, player display, level display based on timing
    764  3a72							; see "Scoring timer" reset stomp comment in bank_generic.
    765  3a72
    766  3a72		       a5 c5		      lda	scoringTimer
    767  3a74		       c9 0a		      cmp	#10	; non-zero so we don't get stomped on by the scoring reset in
    768  3a76		       b0 19		      bcs	stillKicking
    769  3a78		       a9 5a		      lda	#90	; something long.  anything.
    770  3a7a		       85 c5		      sta	scoringTimer
    771  3a7c
    772  3a7c		       a5 a5		      lda	ManCount
    773  3a7e		       29 0f		      and	#$0f
    774  3a80		       c9 01		      cmp	#$01
    775  3a82		       a6 c6		      ldx	scoringFlags
    776  3a84		       e8		      inx
    777  3a85		       8a		      txa
    778  3a86							; if game over for current player, display diamonds/time, score, player/lives/cave and high score
    779  3a86		       29 f3		      and	#$f3
    780  3a88		       90 02		      bcc	gameOver
    781  3a8a							; else display diamonds/time and score only
    782  3a8a		       29 f1		      and	#$f1
    783  3a8c		       85 c6	   gameOver   sta	scoringFlags	;
    784  3a8e
    785  3a8e		       20 1b fd 	      jsr	goGeneralScoringSetups	; update the score display.
    786  3a91
    787  3a91				   stillKicking
    788  3a91
    789  3a91		       a5 92		      lda	BufferedButton	; button pressed?
    790  3a93		       30 15		      bmi	noChange
    791  3a95
      0  3a95					      STOP_CHANNEL	1	; stop all long running sounds
      1  3a95
      2  3a95		       a9 00		      lda	#0
      3  3a97		       85 cb		      sta	soundIdxLst+1
      4  3a99		       85 5a		      sta	AUDV0+1
    793  3a9b
    794  3a9b							; If it's a bonus level, even though we've died... we go to the next cave
    795  3a9b
    796  3a9b		       a5 b3		      lda	levelDisplay
    797  3a9d		       10 05		      bpl	nonextlevel
    798  3a9f		       a2 07		      ldx	#MANMODE_NEXTLEVEL
    799  3aa1		       86 9d		      stx	ManMode
    800  3aa3		       60		      rts
    801  3aa4
    802  3aa4
    803  3aa4		       a5 c7	   nonextlevel lda	NextLevelTrigger
    804  3aa6		       09 40		      ora	#BIT_NEXTLIFE
    805  3aa8		       85 c7		      sta	NextLevelTrigger
    806  3aaa
    807  3aaa		       60	   noChange   rts
    808  3aab
    809  3aab							;------------------------------------------------------------------------------
    810  3aab							; Normal man state
    811  3aab
    812  3aab
    813  3aab				   normalMan
    814  3aab
    815  3aab							; Timer is still running, so we see if the player is to die for any reason
    816  3aab
    817  3aab		       24 a6		      bit	demoMode
    818  3aad		       30 00		      bmi	stayAlive
    819  3aaf							; SELECT pressed?
    820  3aaf							;		  lda SWCHB
    821  3aaf							;		  eor #$FF
    822  3aaf							;		  and #3
    823  3aaf							;		  bne Time0			  ; EITHER select or reset are pressed
    824  3aaf							;		  lsr
    825  3aaf							;		  lsr
    826  3aaf							;		  bcc Time0			  ; suicide!
    827  3aaf				   stayAlive
    828  3aaf
    829  3aaf							;------------------------------------------------------------------------------
    830  3aaf
    831  3aaf							;ldx ManY
    832  3aaf							;ldy ManX
    833  3aaf
    834  3aaf							;lda BoardLineStartLO,x
    835  3aaf							;sta Board_AddressR
    836  3aaf							;lda BoardLineStartHiR,x
    837  3aaf							;sta Board_AddressR+1
    838  3aaf
    839  3aaf				  -	      IF	MULTI_BANK_BOARD = YES
    840  3aaf				  -			;lda BoardBank,x		  ;4
    841  3aaf				  -			;sta RAM_Bank			  ;3
    842  3aaf					      ELSE
    843  3aaf							;lda #BANK_BOARD		  ;2
    844  3aaf					      ENDIF
    845  3aaf							;jsr GetBoardCharacter 	  ;6+20(A)
    846  3aaf
    847  3aaf							;lda CharToType,x
    848  3aaf							;cmp #TYPE_MAN
    849  3aaf							;beq PlayerAlive
    850  3aaf		       4c df f2 	      jmp	PlayerAlive	;sok
    851  3ab2
    852  3ab2							; character he's on isn't a MAN character, so he dies...
    853  3ab2
    854  3ab2				   Time0
    855  3ab2
    856  3ab2		       e6 9d		      inc	ManMode	; #1 -- player dead!
    857  3ab4
    858  3ab4
    859  3ab4							; the dead man creates an explosion...
    860  3ab4							; note, if we get a segtime problem, this code will re-execute OK
    861  3ab4
    862  3ab4		       a5 99	   deadMan    lda	ManX
    863  3ab6		       85 8a		      sta	POS_X
    864  3ab8		       a5 9a		      lda	ManY
    865  3aba		       85 8b		      sta	POS_Y
    866  3abc
    867  3abc							;jsr BlankPlayerFrame
    868  3abc
    869  3abc							; and becomes a man waiting for resurrection...
    870  3abc
    871  3abc		       e6 9d		      inc	ManMode
    872  3abe
    873  3abe				   timeTooShortToDie
    874  3abe		       60		      rts
    875  3abf
    876  3abf							;------------------------------------------------------------------------------
    877  3abf
    878  3abf							;lookColour	  .byte $b0,$02
    879  3abf
      0  3abf					      DEFINE_SUBROUTINE	LookAround	; in INITBANK
      1  3abf		       00 07	   BANK_LookAround =	_CURRENT_BANK
      2  3abf					      SUBROUTINE
      3  3abf				   LookAround
    881  3abf
    882  3abf							;ldx Platform
    883  3abf							;lda lookColour,x
    884  3abf							;sta BGColour
    885  3abf
    886  3abf							; Use the joystick as a window-scroller to change the viewport
    887  3abf
    888  3abf		       a5 90		      lda	BufferedJoystick
    889  3ac1		       4a		      lsr
    890  3ac2		       4a		      lsr
    891  3ac3		       4a		      lsr
    892  3ac4		       4a		      lsr
    893  3ac5		       a8		      tay
    894  3ac6
    895  3ac6		       b9 3b f3 	      lda	JoyMoveX,y
    896  3ac9							;asl
    897  3ac9		       18		      clc
    898  3aca		       65 96		      adc	BoardScrollX
    899  3acc		       c5 93		      cmp	BoardEdge_Right
    900  3ace		       b0 02		      bcs	AbandonX
    901  3ad0		       85 96		      sta	BoardScrollX
    902  3ad2
    903  3ad2		       b9 47 f3    AbandonX   lda	JoyMoveY,y
    904  3ad5							;asl
    905  3ad5		       18		      clc
    906  3ad6		       65 95		      adc	BoardScrollY
    907  3ad8		       c5 94		      cmp	BoardEdge_Bottom
    908  3ada		       b0 02		      bcs	AbandonY
    909  3adc		       85 95		      sta	BoardScrollY
    910  3ade
    911  3ade		       60	   AbandonY   rts
    912  3adf
    913  3adf
    914  3adf
    915  3adf
    916  3adf				   PlayerAlive
    917  3adf
    918  3adf							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    919  3adf							; before exiting via (for example) look-around option :)
    920  3adf
    921  3adf		       a5 99		      lda	ManX
    922  3ae1		       85 8c		      sta	POS_X_NEW
    923  3ae3		       a5 9a		      lda	ManY
    924  3ae5		       85 8d		      sta	POS_Y_NEW
    925  3ae7
    926  3ae7
    927  3ae7							;------------------------------------------------------------------------------
    928  3ae7							; Look around is triggered by holding down the fire button for a while, without any other
    929  3ae7							; joystick directions chosen. The variable LookingAround has a negative value ($FF) when looking
    930  3ae7							; is active. Otherwise, it is counting down to the time where it will trigger.
    931  3ae7
    932  3ae7		       00 00	   LOOK_DELAY =	0
    933  3ae7
    934  3ae7		       a2 00		      ldx	#LOOK_DELAY
    935  3ae9		       a5 92		      lda	BufferedButton
    936  3aeb		       30 0d		      bmi	noLook	; button?
    937  3aed		       a5 a4		      lda	LookingAround
    938  3aef		       30 ce		      bmi	LookAround	; already looking
    939  3af1		       a5 90		      lda	BufferedJoystick
    940  3af3		       c9 f0		      cmp	#$F0
    941  3af5		       90 03		      bcc	noLook	; must have no directions chosen
    942  3af7		       a6 a4		      ldx	LookingAround
    943  3af9		       ca		      dex
    944  3afa		       86 a4	   noLook     stx	LookingAround
    945  3afc
    946  3afc							;------------------------------------------------------------------------------
    947  3afc
    948  3afc							; control the scrolling via the joystick
    949  3afc
    950  3afc		       a5 a2		      lda	ManLastDirection
    951  3afe		       29 07		      and	#DIRECTION_BITS
    952  3b00		       a8		      tay
    953  3b01
    954  3b01		       a5 90		      lda	BufferedJoystick	; joystick
    955  3b03		       25 91		      and	BufferedJoystick+1
    956  3b05
    957  3b05		       a2 00		      ldx	#0
    958  3b07		       0a	   .loopDirs  asl
    959  3b08		       90 07		      bcc	.dirFound
    960  3b0a		       88		      dey
    961  3b0b		       e8		      inx
    962  3b0c		       e0 04		      cpx	#4
    963  3b0e		       d0 f7		      bne	.loopDirs
    964  3b10		       18		      clc
    965  3b11				   .dirFound
    966  3b11		       a5 8c		      lda	POS_X_NEW	;NewX
    967  3b13		       7d 54 f3 	      adc	JoyDirX,x
    968  3b16		       85 8c		      sta	POS_X_NEW	;NewX
    969  3b18		       a5 8d		      lda	POS_Y_NEW	;NewY
    970  3b1a		       18		      clc
    971  3b1b		       7d 52 f3 	      adc	JoyDirY,x
    972  3b1e		       85 8d		      sta	POS_Y_NEW	;NewY
    973  3b20
    974  3b20		       98		      tya
    975  3b21		       f0 12		      beq	noMovement	; animation OK
    976  3b23
    977  3b23		       8a		      txa
    978  3b24		       45 a2		      eor	ManLastDirection
    979  3b26		       29 07		      and	#DIRECTION_BITS
    980  3b28		       45 a2		      eor	ManLastDirection
    981  3b2a		       85 a2		      sta	ManLastDirection
    982  3b2c		       bd 36 f3 	      lda	ManAnimTblLo,x
    983  3b2f		       85 9f		      sta	ManAnimation
    984  3b31							;lda ManAnimTblHi,x
    985  3b31							;sta ManAnimation+1
    986  3b31		       a9 00		      lda	#0
    987  3b33		       85 9e		      sta	ManDelayCount
    988  3b35				   phase0		;jsr MovePlayer
    989  3b35				   noMovement		;ldx MAN_Player
    990  3b35
    991  3b35		       60	   DFS_rts    rts
    992  3b36
    993  3b36
    994  3b36				   ManAnimTblLo
    995  3b36		       00 00 00 00*	      .byte.b	AnimateRIGHT-Manimate, AnimateLEFT-Manimate, AnimateUP-Manimate, AnimateUP-Manimate, AnimateSTOPPED-Manimate
    996  3b3b							;ManAnimTblHi
    997  3b3b							;    .byte   >AnimateRIGHT, >AnimateLEFT, >AnimateUP, >AnimateUP, >AnimateSTOPPED
    998  3b3b
    999  3b3b
   1000  3b3b
   1001  3b3b		       00 00 00 00*JoyMoveX   .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1	;,0, 0,0,0
   1002  3b47		       00 00 00 00*JoyMoveY   .byte.b	0,0,0,0,0,1,-1,0,0, 1,-1	;, 0,0,1,-1,0
   1003  3b52
   1004  3b52				   JoyDirY
   1005  3b52		       00 00		      .byte.b	0,0	;,1,-1,0
   1006  3b54				   JoyDirX
   1007  3b54		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
   1008  3b59
   1009  3b59
   1010  3b59							;------------------------------------------------------------------------------
   1011  3b59
   1012  3b59
      0  3b59					      DEFINE_SUBROUTINE	DrawFullScreen	; = 2568[-96]
      1  3b59		       00 07	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  3b59					      SUBROUTINE
      3  3b59				   DrawFullScreen
   1014  3b59
   1015  3b59							; 83[-7] + 2484[-89] = 2567[-96]
   1016  3b59
   1017  3b59
   1018  3b59		       ad 84 02 	      lda	INTIM	; 4
   1019  3b5c		       c9 29		      cmp	#SEGTIME_BDF	; 2
   1020  3b5e		       90 d5		      bcc	DFS_rts	; 2/3
      0  3b60					      STRESS_TIME	SEGTIME_BDF
      1  3b60				  -	      IF	TEST_SEGTIME_BDF = 1
      2  3b60				  -
      3  3b60				  -
      4  3b60				  -
      5  3b60				  -
      6  3b60				  -
      7  3b60				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  3b60				  -	      bne	. - 7
      9  3b60					      ENDIF
   1022  3b60
   1023  3b60		       a9 f4		      lda	#>( DrawFlag + RAM_WRITE )	; 2
   1024  3b62		       85 df		      sta	BDF_DrawFlagAddress+1	; 3
   1025  3b64		       85 e1		      sta	BDF_DrawFlagAddress2+1	; 3
   1026  3b66
   1027  3b66		       ba		      tsx		; 2
   1028  3b67		       86 e8		      stx	DHS_Stack	; 3
   1029  3b69
   1030  3b69		       e6 89		      inc	ScreenDrawPhase	; 5
   1031  3b6b
   1032  3b6b		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
   1033  3b6c		       a2 08		      ldx	#SCREEN_LINES	; 2
   1034  3b6e		       8a		      txa		; 2 = 31
   1035  3b6f
   1036  3b6f							; fall through
   1037  3b6f
   1038  3b6f							;------------------------------------------------------------------------------
   1039  3b6f
      0  3b6f					      DEFINE_SUBROUTINE	DrawScreenRowPreparation	; = 52[-7]
      1  3b6f		       00 07	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  3b6f					      SUBROUTINE
      3  3b6f				   DrawScreenRowPreparation
   1041  3b6f
   1042  3b6f							;clc
   1043  3b6f		       ca		      dex		; 2
   1044  3b70		       86 e7		      stx	DHS_Line	; 3
   1045  3b72		       65 95		      adc	BoardScrollY	; 3	     the Y offset of screen into board
   1046  3b74		       a8		      tay		; 2 = 10
   1047  3b75
   1048  3b75							;clc
   1049  3b75		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
   1050  3b78		       65 96		      adc	BoardScrollX	; 3	     the X offset of screen into board
   1051  3b7a		       85 e2		      sta	BDF_BoardAddress	; 3
   1052  3b7c		       69 05		      adc	#SCREEN_WIDTH/2	; 2
   1053  3b7e		       85 e4		      sta	BDF_BoardAddress2	; 3
   1054  3b80
   1055  3b80		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
   1056  3b83		       85 e3		      sta	BDF_BoardAddress+1	; 3
   1057  3b85		       85 e5		      sta	BDF_BoardAddress2+1	; 3 = 25
   1058  3b87
   1059  3b87		       bd c0 f0 	      lda	DrawLineStartLO,x	; 4
   1060  3b8a		       85 de		      sta	BDF_DrawFlagAddress	; 3
   1061  3b8c		       69 05		      adc	#SCREEN_WIDTH/2	; 2
   1062  3b8e		       85 e0		      sta	BDF_DrawFlagAddress2	; 3 = 12
   1063  3b90
   1064  3b90				  -	      IF	MULTI_BANK_BOARD = YES
   1065  3b90				  -	      lda	BoardBank-1,y	; 4
   1066  3b90				  -	      sta	BDF_BoardBank	; 3
   1067  3b90					      ENDIF
   1068  3b90		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
   1069  3b92		       4c d6 fa 	      jmp	CopyRow2	; 3 = 12[-7]
   1070  3b95
   1071  3b95							;------------------------------------------------------------------------------
   1072  3b95
      0  3b95					      DEFINE_SUBROUTINE	VectorProcess	;=19(A)
      1  3b95		       00 07	   BANK_VectorProcess =	_CURRENT_BANK
      2  3b95					      SUBROUTINE
      3  3b95				   VectorProcess
   1074  3b95
   1075  3b95							;sta ROM_Bank			  ;3		  processors can assume bank is stored
   1076  3b95
   1077  3b95		       bd a5 f3 	      lda	OSPointerHI,x	;4
   1078  3b98		       85 df		      sta	POS_Vector+1	;3
   1079  3b9a		       bd a2 f3 	      lda	OSPointerLO,x	;4
   1080  3b9d		       85 de		      sta	POS_Vector	;3
   1081  3b9f
   1082  3b9f		       6c de 00 	      jmp	(POS_Vector)	;5 = 19	 vector to processor for particular object type
   1083  3ba2							;		 NOTE: Bank is either INITBANK or FIXED.
   1084  3ba2
   1085  3ba2
   1086  3ba2				   OBJTYPE    SET	0
   1087  3ba2					      MAC	define
   1088  3ba2				   TYPE_{1}   =	OBJTYPE
   1089  3ba2				   OBJTYPE    .SET	OBJTYPE + 1
   1090  3ba2					      ENDM
   1091  3ba2
   1092  3ba2							; If adding/removing types, the following must also be updated...
   1093  3ba2							;   InitialFace[...]		     in DecodeCave.asm
   1094  3ba2							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
   1095  3ba2							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
   1096  3ba2							;   OSPointerLO[...]		     in BANK_INITBANK.asm
   1097  3ba2							;   OSPointerHI[...]		     in BANK_INITBANK.asm
   1098  3ba2							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1099  3ba2							;   Sortable[...]		     in BANK_FIXED.asm
   1100  3ba2
   1101  3ba2
      0  3ba2					      DEFINE	MAN
      1  3ba2		       00 00	   TYPE_MAN   =	OBJTYPE
      2  3ba2				   OBJTYPE    .SET	OBJTYPE + 1
      0  3ba2					      DEFINE	CIRCLE
      1  3ba2		       00 01	   TYPE_CIRCLE =	OBJTYPE
      2  3ba2				   OBJTYPE    .SET	OBJTYPE + 1
      0  3ba2					      DEFINE	CIRCLE_HELPER
      1  3ba2		       00 02	   TYPE_CIRCLE_HELPER =	OBJTYPE
      2  3ba2				   OBJTYPE    .SET	OBJTYPE + 1
      0  3ba2					      DEFINE	CIRCLE_DRAWER
      1  3ba2		       00 03	   TYPE_CIRCLE_DRAWER =	OBJTYPE
      2  3ba2				   OBJTYPE    .SET	OBJTYPE + 1
   1106  3ba2
      0  3ba2					      DEFINE	MAXIMUM
      1  3ba2		       00 04	   TYPE_MAXIMUM =	OBJTYPE
      2  3ba2				   OBJTYPE    .SET	OBJTYPE + 1
   1108  3ba2							;    IF DEMO_VERSION = NO
   1109  3ba2							;PROCESS_SELECTOR = 0
   1110  3ba2							;    ENDIF
   1111  3ba2
   1112  3ba2
      0  3ba2					      DEFINE_SUBROUTINE	OSPointerLO
      1  3ba2		       00 07	   BANK_OSPointerLO =	_CURRENT_BANK
      2  3ba2					      SUBROUTINE
      3  3ba2				   OSPointerLO
   1114  3ba2		       6b		      .byte.b	<PROCESS_MAN
   1115  3ba3		       05		      .byte.b	<PROCESS_CIRCLE
   1116  3ba4		       fb		      .byte.b	<PROCESS_CIRCLE_HELPER
   1117  3ba5
   1118  3ba5				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
   1119  3ba5				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
   1120  3ba5				  -	      EXIT
   1121  3ba5					      ENDIF
   1122  3ba5
   1123  3ba5
      0  3ba5					      DEFINE_SUBROUTINE	OSPointerHI
      1  3ba5		       00 07	   BANK_OSPointerHI =	_CURRENT_BANK
      2  3ba5					      SUBROUTINE
      3  3ba5				   OSPointerHI
   1125  3ba5		       f9		      .byte.b	>PROCESS_MAN
   1126  3ba6		       f9		      .byte.b	>PROCESS_CIRCLE
   1127  3ba7		       f8		      .byte.b	>PROCESS_CIRCLE_HELPER
   1128  3ba8
   1129  3ba8				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
   1130  3ba8				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
   1131  3ba8				  -	      EXIT
   1132  3ba8					      ENDIF
   1133  3ba8
   1134  3ba8							;	 IF TIMER_DEBUG = NO
   1135  3ba8							;    DEFINE_SUBROUTINE OSTimer
   1136  3ba8							;		  .byte SEGTIME_MAN
   1137  3ba8							;		  .byte SEGTIME_BOULDER1
   1138  3ba8							;		  .byte SEGTIME_AMOEBASQUARE
   1139  3ba8							;		  .byte SEGTIME_BUTTERFLY
   1140  3ba8							;		  .byte SEGTIME_FIREFLY
   1141  3ba8							;		  .byte SEGTIME_BOULDER1
   1142  3ba8							;		  .byte 0		 ; MAGICWALL
   1143  3ba8							;		  .byte 0		  ; exit door
   1144  3ba8							;		  .byte 0		     ; selection screen controller (no timer)
   1145  3ba8							;		  .byte SEGTIME_EXPLOSION
   1146  3ba8							;		  .byte SEGTIME_EXPLOSION
   1147  3ba8							;		  .byte SEGTIME_EXPLOSION
   1148  3ba8							;		  .byte SEGTIME_EXPLOSION
   1149  3ba8							;;		   .byte 0
   1150  3ba8							;;		   .byte 0 ;soil
   1151  3ba8							;;		   .byte 0 ;steel
   1152  3ba8							;;		   .byte 0 ;wall
   1153  3ba8							;
   1154  3ba8							;    IF * - OSTimer < TYPE_MAXIMUM-4
   1155  3ba8							;	  ECHO "ERROR: Missing entry in OSTimer table!"
   1156  3ba8							;	  EXIT
   1157  3ba8							;    ENDIF
   1158  3ba8							;	 ENDIF
   1159  3ba8
   1160  3ba8
   1161  3ba8							;------------------------------------------------------------------------------
   1162  3ba8
      0  3ba8					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  3ba8		       00 07	   BANK_MoveVecLO =	_CURRENT_BANK
      2  3ba8					      SUBROUTINE
      3  3ba8				   MoveVecLO
   1164  3ba8
   1165  3ba8		       1a		      .byte.b	<MOVE_BLANK
   1166  3ba9		       1a		      .byte.b	<MOVE_SOIL
   1167  3baa		       6e		      .byte.b	<MOVE_BOX
   1168  3bab		       33		      .byte.b	<MOVE_TARGET
   1169  3bac		       33		      .byte.b	<MOVE_TARGET
   1170  3bad		       65		      .byte.b	<MOVE_GENERIC	;man occupied
   1171  3bae		       65		      .byte.b	<MOVE_GENERIC	;steel
   1172  3baf		       65		      .byte.b	<MOVE_GENERIC	;wall
   1173  3bb0		       79		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
   1174  3bb1		       65		      .byte.b	<MOVE_GENERIC	;nogo
   1175  3bb2
   1176  3bb2				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
   1177  3bb2				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
   1178  3bb2				  -	      ERR
   1179  3bb2					      ENDIF
   1180  3bb2
   1181  3bb2
   1182  3bb2
      0  3bb2					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  3bb2		       00 07	   BANK_MoveVecHI =	_CURRENT_BANK
      2  3bb2					      SUBROUTINE
      3  3bb2				   MoveVecHI
   1184  3bb2
   1185  3bb2		       fa		      .byte.b	>MOVE_BLANK
   1186  3bb3		       fa		      .byte.b	>MOVE_SOIL
   1187  3bb4		       fa		      .byte.b	>MOVE_BOX
   1188  3bb5		       fa		      .byte.b	>MOVE_TARGET
   1189  3bb6		       fa		      .byte.b	>MOVE_TARGET
   1190  3bb7		       fa		      .byte.b	>MOVE_GENERIC	;man occupied
   1191  3bb8		       fa		      .byte.b	>MOVE_GENERIC	;steel
   1192  3bb9		       fa		      .byte.b	>MOVE_GENERIC	;wall
   1193  3bba		       fa		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
   1194  3bbb		       fa		      .byte.b	>MOVE_GENERIC	;nogo
   1195  3bbc
   1196  3bbc				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
   1197  3bbc				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
   1198  3bbc				  -	      EXIT
   1199  3bbc					      ENDIF
   1200  3bbc
   1201  3bbc
      0  3bbc					      CHECK_BANK_SIZE	"INITBANK"
      1  3bbc		       03 bc	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $3bc , FREE= $444
      2  3bbc					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3bbc				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3bbc				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3bbc				  -	      ERR
      6  3bbc					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_FIXED.asm LEVEL 2 PASS 3
      0  3bbc					      include	"BANK_FIXED.asm"
      1  3bbc							;------------------------------------------------------------------------------
      2  3bbc							;###############################  FIXED BANK  #################################
      3  3bbc							;------------------------------------------------------------------------------
      4  3bbc
      5  3bbc
      6  3bbc				   ORIGIN     SET	FIXED_BANK
      7  3bbc
      0  3bbc					      NEWBANK	THE_FIXED_BANK
      1  7fa5 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
      9  7800					      RORG	$f800
     10  7800
     11  7800
     12  7800							;------------------------------------------------------------------------------
     13  7800							; TJ: used by:
     14  7800							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
------- FILE Brick_Wall.asm LEVEL 3 PASS 3
      0  7800					      include	"Brick_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      0  7800					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  7800					      LIST	ON
      2  7800
      3  7800		       00 00	   BRICK_WALL_DEF =	0
      4  7800
      5  7800				   CHARACTERSHAPE_WALL
      6  7800				   CHARACTERSHAPE_WALL0
      7  7800
      8  7800
      9  7800
     10  7800				  -	      if	MIRRORED_WALL = NO
     11  7800				  -CHARACTERSHAPE_WALL_MIRRORED
     12  7800				  -CHARACTERSHAPE_WALL0_MIRRORED
     13  7800					      endif
     14  7800
     15  7800					      if	BRICK_WALL_DEF = 0
     16  7800		       00 77 77 00*	      .byte.b	%00000000,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;R
     17  7807		       77 77 77 00*	      .byte.b	%01110111,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;G
     18  780e		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     19  7815					      endif
     20  7815
     21  7815				  -	      if	BRICK_WALL_DEF = 1
     22  7815				  -	      .byte	%01100110	;R #2 bright color
     23  7815				  -	      .byte	%01110111
     24  7815				  -	      .byte	%01110111
     25  7815				  -	      .byte	%00000000
     26  7815				  -	      .byte	%10011001
     27  7815				  -	      .byte	%11011101
     28  7815				  -	      .byte	%11011101
     29  7815				  -
     30  7815				  -	      .byte	%01100110	;G #1 dark, dirt color
     31  7815				  -	      .byte	%01110111
     32  7815				  -	      .byte	%01110111
     33  7815				  -	      .byte	%00000000
     34  7815				  -	      .byte	%10011001
     35  7815				  -	      .byte	%11011101
     36  7815				  -	      .byte	%11011101
     37  7815				  -
     38  7815				  -	      .byte	%01100110	;B #0 medium, mix color
     39  7815				  -	      .byte	%01110111
     40  7815				  -	      .byte	%00000000
     41  7815				  -	      .byte	%00000000
     42  7815				  -	      .byte	%10011001
     43  7815				  -	      .byte	%11011101
     44  7815				  -	      .byte	%00000000
     45  7815					      endif
     46  7815
     47  7815				  -	      if	BRICK_WALL_DEF = 2
     48  7815				  -	      .byte	%01100110	;R #2 bright color
     49  7815				  -	      .byte	%01110111
     50  7815				  -	      .byte	%01110111
     51  7815				  -	      .byte	%00000000
     52  7815				  -	      .byte	%10011001
     53  7815				  -	      .byte	%11011101
     54  7815				  -	      .byte	%11011101
     55  7815				  -
     56  7815				  -	      .byte	%11111111	;G #1 dark, dirt color
     57  7815				  -	      .byte	%11111111
     58  7815				  -	      .byte	%11111111
     59  7815				  -	      .byte	%11111111
     60  7815				  -	      .byte	%11111111
     61  7815				  -	      .byte	%11111111
     62  7815				  -	      .byte	%11111111
     63  7815				  -
     64  7815				  -	      .byte	%11111111	;B #0 medium, mix color
     65  7815				  -	      .byte	%11111111
     66  7815				  -	      .byte	%11111111
     67  7815				  -	      .byte	%11111111
     68  7815				  -	      .byte	%11111111
     69  7815				  -	      .byte	%11111111
     70  7815				  -	      .byte	%00000000
     71  7815					      endif
     72  7815
     73  7815				  -	      if	BRICK_WALL_DEF = 3
     74  7815				  -	      .byte	%00000000
     75  7815				  -	      .byte	%10011001	;R #2 bright color
     76  7815				  -	      .byte	%11011101
     77  7815				  -	      .byte	%11011101
     78  7815				  -			;.byte %00000000
     79  7815				  -	      .byte	%01100110
     80  7815				  -	      .byte	%01110111
     81  7815				  -	      .byte	%01110111
     82  7815				  -
     83  7815				  -	      .byte	%00000000
     84  7815				  -	      .byte	%10011001	;G #1 dark, dirt color
     85  7815				  -	      .byte	%11011101
     86  7815				  -			;.byte %11011101
     87  7815				  -	      .byte	%00000000
     88  7815				  -	      .byte	%01100110
     89  7815				  -	      .byte	%01110111
     90  7815				  -	      .byte	%01110111
     91  7815				  -
     92  7815				  -	      .byte	%10111011	;B #0 medium, mix color
     93  7815				  -	      .byte	%11111111
     94  7815				  -	      .byte	%11111111
     95  7815				  -	      .byte	%00000000
     96  7815				  -	      .byte	%11101110
     97  7815				  -	      .byte	%11111111
     98  7815				  -	      .byte	%11111111
     99  7815				  -			;.byte %00000000
    100  7815					      endif
    101  7815
    102  7815
    103  7815							;--------------------------------------------------------------------------
    104  7815					      if	MIRRORED_WALL = YES
      0  7815					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  7815					      LIST	ON
    106  7815				   CHARACTERSHAPE_WALL_MIRRORED
    107  7815				   CHARACTERSHAPE_WALL0_MIRRORED
    108  7815
    109  7815					      if	BRICK_WALL_DEF = 0
    110  7815		       00 ee ee 00*	      .byte.b	%00000000,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;R
    111  781c		       ee ee ee 00*	      .byte.b	%11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;G
    112  7823		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
    113  782a					      endif
    114  782a
    115  782a				  -	      if	BRICK_WALL_DEF = 1
    116  782a				  -	      .byte	%01100110	;R
    117  782a				  -	      .byte	%11101110
    118  782a				  -	      .byte	%11101110
    119  782a				  -	      .byte	%00000000
    120  782a				  -	      .byte	%10011001
    121  782a				  -	      .byte	%10111011
    122  782a				  -	      .byte	%10111011
    123  782a				  -
    124  782a				  -	      .byte	%01100110	;G
    125  782a				  -	      .byte	%11101110
    126  782a				  -	      .byte	%11101110
    127  782a				  -	      .byte	%00000000
    128  782a				  -	      .byte	%10011001
    129  782a				  -	      .byte	%10111011
    130  782a				  -	      .byte	%10111011
    131  782a				  -
    132  782a				  -	      .byte	%01100110	;B
    133  782a				  -	      .byte	%11101110
    134  782a				  -	      .byte	%00000000
    135  782a				  -	      .byte	%00000000
    136  782a				  -	      .byte	%10011001
    137  782a				  -	      .byte	%10111011
    138  782a				  -	      .byte	%00000000
    139  782a					      endif
    140  782a
    141  782a				  -	      if	BRICK_WALL_DEF = 2
    142  782a				  -	      .byte	%01100110	;R
    143  782a				  -	      .byte	%11101110
    144  782a				  -	      .byte	%11101110
    145  782a				  -	      .byte	%00000000
    146  782a				  -	      .byte	%10011001
    147  782a				  -	      .byte	%10111011
    148  782a				  -	      .byte	%10111011
    149  782a				  -
    150  782a				  -	      .byte	%11111111	;G #1 dark, dirt color
    151  782a				  -	      .byte	%11111111
    152  782a				  -	      .byte	%11111111
    153  782a				  -	      .byte	%11111111
    154  782a				  -	      .byte	%11111111
    155  782a				  -	      .byte	%11111111
    156  782a				  -	      .byte	%11111111
    157  782a				  -
    158  782a				  -	      .byte	%11111111	;B #0 medium, mix color
    159  782a				  -	      .byte	%11111111
    160  782a				  -	      .byte	%11111111
    161  782a				  -	      .byte	%11111111
    162  782a				  -	      .byte	%11111111
    163  782a				  -	      .byte	%11111111
    164  782a				  -	      .byte	%00000000
    165  782a					      endif
    166  782a
    167  782a				  -	      if	BRICK_WALL_DEF = 3
    168  782a				  -	      .byte	%00000000
    169  782a				  -	      .byte	%10011001	;R
    170  782a				  -	      .byte	%10111011
    171  782a				  -	      .byte	%10111011
    172  782a				  -			;.byte %00000000
    173  782a				  -	      .byte	%01100110
    174  782a				  -	      .byte	%11101110
    175  782a				  -	      .byte	%11101110
    176  782a				  -
    177  782a				  -	      .byte	%00000000
    178  782a				  -	      .byte	%10011001	;G
    179  782a				  -	      .byte	%10111011
    180  782a				  -			;.byte %10111011
    181  782a				  -	      .byte	%00000000
    182  782a				  -	      .byte	%01100110
    183  782a				  -	      .byte	%11101110
    184  782a				  -	      .byte	%11101110
    185  782a				  -
    186  782a				  -	      .byte	%11011101	;B
    187  782a				  -	      .byte	%11111111
    188  782a				  -	      .byte	%11111111
    189  782a				  -	      .byte	%00000000
    190  782a				  -	      .byte	%01110111
    191  782a				  -	      .byte	%11111111
    192  782a				  -	      .byte	%11111111
    193  782a				  -			;.byte %00000000
    194  782a					      endif
    195  782a
    196  782a					      endif
------- FILE BANK_FIXED.asm
     16  782a
     17  782a							;------------------------------------------------------------------------------
     18  782a
      0  782a					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  782a		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  782a					      SUBROUTINE
      3  782a				   DrawTimeFromROM
     20  782a							; TJ: used by:
     21  782a							; - BANK_INITBANK.asm
     22  782a
     23  782a		       85 3e		      sta	SET_BANK_RAM
     24  782c		       20 f5 f2 	      jsr	DrawTime
     25  782f		       85 3f		      sta	SET_BANK
     26  7831		       60		      rts
     27  7832
      0  7832					      DEFINE_SUBROUTINE	DrawTargetsRequiredFromROM
      1  7832		       00 0f	   BANK_DrawTargetsRequiredFromROM =	_CURRENT_BANK
      2  7832					      SUBROUTINE
      3  7832				   DrawTargetsRequiredFromROM
     29  7832
     30  7832		       85 3e		      sta	SET_BANK_RAM
     31  7834		       20 e0 f2 	      jsr	DrawTargetsRequired
     32  7837		       a5 c1		      lda	ROM_Bank
     33  7839		       85 3f		      sta	SET_BANK
     34  783b		       60		      rts
     35  783c
     36  783c							;------------------------------------------------------------------------------
     37  783c
      0  783c					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  783c		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  783c					      SUBROUTINE
      3  783c				   GetROMByte
     39  783c							; TJ: used by:
     40  783c							; - BANK_INITBANK.asm
     41  783c							; - DecodeCave.asm
     42  783c
     43  783c							; a = ROM bank to retrieve (NOTE: status negative flag important!!!!!!!)
     44  783c							; y = page index
     45  783c							; ROM_Bank = bank to return to
     46  783c							; (Board_AddressR) = page
     47  783c							; out a = byte from (Board_AddressR)
     48  783c
     49  783c		       85 3f		      sta	SET_BANK	;3
     50  783e		       4c 43 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
     51  7841
     52  7841							;------------------------------------------------------------------------------
     53  7841
      0  7841					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7841		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7841					      SUBROUTINE
      3  7841				   GetBoardCharacter
     55  7841							; TJ: used by:
     56  7841							; - BANK_INITBANK.asm
     57  7841
     58  7841							; call from ROM bank
     59  7841							; switches back to ROM_Bank on exit
     60  7841
     61  7841							; pass A = bank containing character
     62  7841							; Y = x character position
     63  7841							; (Board_AddressR) points to character position
     64  7841							; returns character from board
     65  7841
     66  7841
     67  7841		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
     68  7843
     69  7843				   GetBoardCharacter2		;=17(A)
     70  7843
     71  7843		       b3 bd		      lax	(Board_AddressR),y	;5
     72  7845		       a4 c1		      ldy	ROM_Bank	;3
     73  7847		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
     74  7849		       60		      rts		;6   and go back
     75  784a
     76  784a							;---------------------------------------------------------------------------
     77  784a
      0  784a					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  784a		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  784a					      SUBROUTINE
      3  784a				   PutBoardCharacter
     79  784a							; TJ: used by:
     80  784a							; - BANK_INITBANK.asm
     81  784a		       86 3e		      stx	SET_BANK_RAM	; 3
     82  784c
     83  784c				   PutBoardCharacterSB		; =18
     84  784c		       91 bf		      sta	(Board_AddressW),y	; 6
     85  784e		       a5 c1		      lda	ROM_Bank	; 3
     86  7850		       85 3f		      sta	SET_BANK	; 3
     87  7852		       60		      rts		; 6 = 21
     88  7853
     89  7853							;---------------------------------------------------------------------------
     90  7853
      0  7853					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  7853		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  7853					      SUBROUTINE
      3  7853				   GetBoardCharacter__CALL_FROM_RAM__
     92  7853							; TJ: used by:
     93  7853							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
     94  7853							; - DecodeCave.asm
     95  7853
     96  7853		       a4 8b		      ldy	POS_Y	;3
     97  7855
     98  7855		       a9 07		      lda	#BANK_GetBoardAddressR	;
     99  7857		       85 3f		      sta	SET_BANK	;
    100  7859		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    101  785c
    102  785c
      0  785c					      DEFINE_SUBROUTINE	PartialGetBoardCharacter	;=23
      1  785c		       00 0f	   BANK_PartialGetBoardCharacter =	_CURRENT_BANK
      2  785c					      SUBROUTINE
      3  785c				   PartialGetBoardCharacter
    104  785c							; TJ: used by:
    105  785c							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
    106  785c
    107  785c		       85 3e		      sta	SET_BANK_RAM	;3
    108  785e		       a4 8a		      ldy	POS_X	;3
    109  7860		       b3 bd		      lax	(Board_AddressR),y	;5
    110  7862		       a4 c2		      ldy	RAM_Bank	;3
    111  7864		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    112  7866		       60		      rts		;6		 and go back
    113  7867
    114  7867							;---------------------------------------------------------------------------
    115  7867
      0  7867					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  7867		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  7867					      SUBROUTINE
      3  7867				   PutBoardCharacterFromRAM
    117  7867							; TJ: used by:
    118  7867							; - BANK_INITBANK.asm
    119  7867							; - DecodeCave.asm
    120  7867
    121  7867							; POS_Y  = row
    122  7867							; POS_Type = character to write
    123  7867							; POS_X     = column
    124  7867							; RAM_Bank = caller's bank
    125  7867
    126  7867		       a4 8b		      ldy	POS_Y	;3
    127  7869
    128  7869		       a9 07		      lda	#BANK_GetBoardAddressW	;
    129  786b		       85 3f		      sta	SET_BANK	;
    130  786d		       20 0d f1 	      jsr	GetBoardAddressW	;11+24[-2](A)
    131  7870
    132  7870		       86 3e		      stx	SET_BANK_RAM	;3
    133  7872
    134  7872		       a4 8a		      ldy	POS_X	;3
    135  7874		       a5 8e		      lda	POS_Type	;3
    136  7876		       91 bf		      sta	(Board_AddressW),y	;6
    137  7878		       a4 c2		      ldy	RAM_Bank	;3
    138  787a		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    139  787c		       60		      rts		;6
    140  787d
    141  787d
    142  787d							;---------------------------------------------------------------------------
    143  787d
      0  787d					      DEFINE_SUBROUTINE	ProcessObjStack	; 15 minimum segtime abort
      1  787d		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  787d					      SUBROUTINE
      3  787d				   ProcessObjStack
    145  787d
    146  787d		       ad 84 02 	      lda	INTIM	;4
    147  7880		       c9 04		      cmp	#MINIMUM_SEGTIME	;2
    148  7882		       90 3b		      bcc	EarlyAbort	;2/3= 8
      0  7884					      STRESS_TIME	MINIMUM_SEGTIME
      1  7884				  -	      IF	TEST_MINIMUM_SEGTIME = 1
      2  7884				  -
      3  7884				  -
      4  7884				  -
      5  7884				  -
      6  7884				  -
      7  7884				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7884				  -	      bne	. - 7
      9  7884					      ENDIF
    150  7884
    151  7884		       a5 85		      lda	ObjStackNum	;3
    152  7886		       49 01		      eor	#1	;2
    153  7888		       aa		      tax		;2
    154  7889
    155  7889		       a5 d1		      lda	ObjIterator	;3
    156  788b		       d5 86		      cmp	ObjStackPtr,x	;5
    157  788d		       b0 2e		      bcs	nextPhase	;2/3
    158  788f
    159  788f
    160  788f							; Process an object...
    161  788f							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    162  788f
    163  788f		       bc ec f9 	      ldy	BankObjStack,x	;4
    164  7892		       84 3e		      sty	SET_BANK_RAM	;3
    165  7894
    166  7894		       aa		      tax		;2
    167  7895		       bc 80 11 	      ldy	SortedObjPtr,x	;4		 indirect object pointer list (sorted)
    168  7898
    169  7898		       b9 00 10 	      lda	ObjStackX,y	;4
    170  789b		       85 8a		      sta	POS_X	;3
    171  789d		       b9 80 10 	      lda	ObjStackY,y	;4
    172  78a0		       85 8b		      sta	POS_Y	;3
    173  78a2		       b9 00 11 	      lda	ObjStackVar,y	;4
    174  78a5		       85 8f		      sta	POS_VAR	;3
    175  78a7		       be 00 12 	      ldx	ObjStackType,y	;4
    176  78aa		       86 8e		      stx	POS_Type	;3
    177  78ac
    178  78ac		       a9 07		      lda	#BANK_VectorProcess	;2
    179  78ae		       85 3f		      sta	SET_BANK	;3
    180  78b0
    181  78b0		       bd a5 f3 	      lda	OSPointerHI,x	;4
    182  78b3		       85 df		      sta	POS_Vector+1	;3
    183  78b5		       bd a2 f3 	      lda	OSPointerLO,x	;4
    184  78b8		       85 de		      sta	POS_Vector	;3
    185  78ba
    186  78ba		       6c de 00 	      jmp	(POS_Vector)	;5 = 82	 vector to processor for particular object type
    187  78bd
    188  78bd
    189  78bd							;---------------------------------------------------------------------------
    190  78bd							; Now process the blank stack.  This stack holds all the recently blanked squares
    191  78bd							; and determines (and moves) BOXs or diamonds into these squares.  The space vacated
    192  78bd							; by these objects are added again to the blank stack.
    193  78bd
    194  78bd				   nextPhase
    195  78bd
    196  78bd							;clc
    197  78bd							;lda circle_d
    198  78bd							;adc #255
    199  78bd							;sta circle_d
    200  78bd							;bcc nocirc
    201  78bd
    202  78bd
    203  78bd
    204  78bd				   nocirc
    205  78bd
    206  78bd		       e6 89		      inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    207  78bf		       60	   EarlyAbort rts		;6
    208  78c0
    209  78c0							;---------------------------------------------------------------------------
    210  78c0
      0  78c0					      DEFINE_SUBROUTINE	SwitchObjects	;=72
      1  78c0		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  78c0					      SUBROUTINE
      3  78c0				   SwitchObjects
    212  78c0							; TJ: used by:
    213  78c0							; - BANK_FIXED.asm
    214  78c0
    215  78c0							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    216  78c0							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    217  78c0							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    218  78c0
    219  78c0		       ad 84 02 	      lda	INTIM	; 4
    220  78c3		       c9 03		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    221  78c5		       90 f8		      bcc	EarlyAbort	; 2/3= 8
      0  78c7					      STRESS_TIME	SEGTIME_SWITCHOBJECTS
      1  78c7				  -	      IF	TEST_SEGTIME_SWITCHOBJECTS = 1
      2  78c7				  -
      3  78c7				  -
      4  78c7				  -
      5  78c7				  -
      6  78c7				  -
      7  78c7				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  78c7				  -	      bne	. - 7
      9  78c7					      ENDIF
    223  78c7
    224  78c7							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    225  78c7							; we're at the throttle cutoff do we switch game-frames.
    226  78c7
    227  78c7							;sec
    228  78c7		       a5 b4		      lda	Throttle	;3
    229  78c9		       e9 a0		      sbc	#MAX_THROTTLE	;2
    230  78cb		       90 f2		      bcc	EarlyAbort	;2/3		 plenty of time left!
    231  78cd
    232  78cd							; Time is up. But we may be in a level which requires perfect sorting
    233  78cd							; So we check for these levels, and wait for the sort to complete for those.
    234  78cd
    235  78cd		       24 b3		      bit	levelDisplay	;3
    236  78cf		       50 08		      bvc	keepFractional	;2/3		 screen does not require complete sort
    237  78d1
    238  78d1							; We have a level which requires the sort to go to completion
    239  78d1							; Check to see if the sort is finished...
    240  78d1
    241  78d1		       a4 c9		      ldy	sortPtr	;3
    242  78d3		       d0 ea		      bne	EarlyAbort	;2/3		 sort still in progress, so wait
    243  78d5		       a4 c8		      ldy	sortRequired	;3
    244  78d7		       10 e6		      bpl	EarlyAbort	;2/3		 sort still in progress, so wait
    245  78d9
    246  78d9		       85 b4	   keepFractional sta	Throttle	;3		 save fractional 'left over' bit
    247  78db
    248  78db							; Pause the game with B/W switch:
    249  78db
    250  78db		       a5 80		      lda	gameMode
    251  78dd							;		  ora LookingAround		  ; New behavour of looking around pauses creatures when activated.
    252  78dd		       30 14		      bmi	.paused	; pause flag set
    253  78df
    254  78df							; Now that we have completed processing the object stack, we switch
    255  78df							; the stack bank pointers for the next time around.
    256  78df
    257  78df		       a5 85		      lda	ObjStackNum	;3
    258  78e1		       49 01		      eor	#1	;2
    259  78e3		       aa		      tax		;2
    260  78e4		       86 85		      stx	ObjStackNum	;3		 swap stacks @here
    261  78e6
    262  78e6							; STOP the sort so it doesn't corrupt the "other" object stack. Sort may get a look-in immediately after
    263  78e6							; this code is finished, so we don't want it to do something unexpected!
    264  78e6
    265  78e6		       a0 ff		      ldy	#<(-1)	;2
    266  78e8		       84 c8		      sty	sortRequired	;3
    267  78ea		       c8		      iny		;2		 Y==0
    268  78eb		       84 c9		      sty	sortPtr	;3
    269  78ed
    270  78ed							; Initialise the iterator and stack pointer for next time around.
    271  78ed							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    272  78ed							; necessary to initialise both.
    273  78ed
    274  78ed		       84 d1		      sty	ObjIterator	;3		 Y==0
    275  78ef		       94 86		      sty	ObjStackPtr,x	;4
    276  78f1
    277  78f1		       84 89		      sty	ScreenDrawPhase	;3
    278  78f3				   .paused
    279  78f3		       60	   quickExit  rts		;6
    280  78f4
    281  78f4							;---------------------------------------------------------------------------
    282  78f4
      0  78f4					      DEFINE_SUBROUTINE	PROCESS_CIRCLE_DRAWER
      1  78f4		       00 0f	   BANK_PROCESS_CIRCLE_DRAWER =	_CURRENT_BANK
      2  78f4					      SUBROUTINE
      3  78f4				   PROCESS_CIRCLE_DRAWER
    284  78f4
    285  78f4		       a0 00		      ldy	#CHARACTER_BLANK
    286  78f6		       a5 a8		      lda	circle_d+1
    287  78f8							;jsr DrawCircle
    288  78f8							;bcc finCircle
    289  78f8							;lda #TYPE_CIRCLE_DRAWER
    290  78f8							;sta POS_Type
    291  78f8							;jsr InsertObjectStack
    292  78f8		       4c b1 f9    finCircle  jmp	NextObject
    293  78fb
      0  78fb					      DEFINE_SUBROUTINE	PROCESS_CIRCLE_HELPER
      1  78fb		       00 0f	   BANK_PROCESS_CIRCLE_HELPER =	_CURRENT_BANK
      2  78fb					      SUBROUTINE
      3  78fb				   PROCESS_CIRCLE_HELPER
    295  78fb
    296  78fb		       ad 84 02 	      lda	INTIM
    297  78fe		       c9 0a		      cmp	#SEGTIME_CIRCLE_HELPER
    298  7900		       90 bd		      bcc	EarlyAbort
    299  7902
    300  7902
    301  7902		       4c b1 f9 	      jmp	NextObject	; and die
    302  7905
    303  7905
      0  7905					      DEFINE_SUBROUTINE	PROCESS_CIRCLE
      1  7905		       00 0f	   BANK_PROCESS_CIRCLE =	_CURRENT_BANK
      2  7905					      SUBROUTINE
      3  7905				   PROCESS_CIRCLE
    305  7905
    306  7905		       ad 84 02 	      lda	INTIM
    307  7908		       c9 0a		      cmp	#SEGTIME_CIRCLE
    308  790a		       90 b3		      bcc	EarlyAbort
    309  790c
    310  790c		       18		      clc
    311  790d		       a5 a7		      lda	circle_d
    312  790f		       69 19		      adc	#25
    313  7911		       85 a7		      sta	circle_d
    314  7913		       90 4b		      bcc	inactiveCircle
    315  7915
    316  7915		       e6 a8		      inc	circle_d+1
    317  7917		       a5 a8		      lda	circle_d+1
    318  7919		       c9 14		      cmp	#20
    319  791b		       f0 4a		      beq	circleComplete
    320  791d							; time to fire off another "ring" of the clearing circle
    321  791d
    322  791d							;sta POS_VAR		    ; diameter for helper to use
    323  791d							;lda #TYPE_CIRCLE_HELPER
    324  791d							;sta POS_Type
    325  791d							;jsr InsertObjectStack
    326  791d
    327  791d
    328  791d							; a = radius
    329  791d
    330  791d		       a0 00		      ldy	#CHARACTER_BLANK
    331  791f		       84 ab		      sty	circ_char
    332  7921
    333  7921		       a5 a8		      lda	circle_d+1
    334  7923		       38		      sec
    335  7924		       e9 01		      sbc	#1
    336  7926		       85 a9		      sta	circ_x
    337  7928		       49 ff		      eor	#255
    338  792a		       18		      clc
    339  792b		       69 01		      adc	#1
    340  792d		       85 ac		      sta	circ_scratch	; "d" --> "1-r" in unit terms
    341  792f
    342  792f		       a9 00		      lda	#0
    343  7931		       85 aa		      sta	circ_y
    344  7933
    345  7933		       a5 a8		      lda	circle_d+1	; radius
    346  7935		       a9 03		      lda	#TYPE_CIRCLE_DRAWER
    347  7937		       85 8e		      sta	POS_Type
    348  7939							;jsr InsertObjectStack
    349  7939
    350  7939		       a0 00		      ldy	#CHARACTER_BLANK
    351  793b		       a5 a8		      lda	circle_d+1
    352  793d		       38		      sec
    353  793e		       e9 01		      sbc	#1
    354  7940		       20 54 fe 	      jsr	DrawCircle
    355  7943
    356  7943		       a0 06		      ldy	#CHARACTER_STEEL
    357  7945		       84 ab		      sty	circ_char
    358  7947		       a5 a8		      lda	circle_d+1
    359  7949		       85 a9		      sta	circ_x
    360  794b		       49 ff		      eor	#255
    361  794d		       18		      clc
    362  794e		       69 01		      adc	#1
    363  7950		       85 ac		      sta	circ_scratch	; "d" --> "1-r" in unit terms
    364  7952
    365  7952		       a9 00		      lda	#0
    366  7954		       85 aa		      sta	circ_y
    367  7956
    368  7956		       a5 a8		      lda	circle_d+1	; radius
    369  7958		       a9 03		      lda	#TYPE_CIRCLE_DRAWER
    370  795a		       85 8e		      sta	POS_Type
    371  795c							;jsr InsertObjectStack
    372  795c
    373  795c		       a0 00		      ldy	#CHARACTER_BLANK
    374  795e		       a5 a8		      lda	circle_d+1
    375  7960							;jsr DrawCircle
    376  7960
    377  7960
    378  7960
    379  7960							;			      inc circle_d+1
    380  7960							;			      ldy #CHARACTER_STEEL
    381  7960							;			      lda circle_d+1
    382  7960							;			      jsr DrawCircle
    383  7960
    384  7960		       a9 01	   inactiveCircle lda	#TYPE_CIRCLE
    385  7962		       85 8e		      sta	POS_Type
    386  7964		       20 be f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    387  7967
    388  7967		       4c b1 f9    circleComplete jmp	NextObject
    389  796a
    390  796a							;---------------------------------------------------------------------------
    391  796a
    392  796a		       60	   EarlyAbort4 rts
    393  796b
      0  796b					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  796b		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  796b					      SUBROUTINE
      3  796b				   PROCESS_MAN
    395  796b							; TJ: used by:
    396  796b							; - BANK_INITBANK.asm
    397  796b		       ad 84 02 	      lda	INTIM
    398  796e		       c9 18		      cmp	#SEGTIME_MAN
    399  7970		       90 f8		      bcc	EarlyAbort4
      0  7972					      STRESS_TIME	SEGTIME_MAN
      1  7972				  -	      IF	TEST_SEGTIME_MAN = 1
      2  7972				  -
      3  7972				  -
      4  7972				  -
      5  7972				  -
      6  7972				  -
      7  7972				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7972				  -	      bne	. - 7
      9  7972					      ENDIF
    401  7972
    402  7972		       a9 07		      lda	#BANK_ManProcess
    403  7974		       85 c1		      sta	ROM_Bank
    404  7976		       85 3f		      sta	SET_BANK
    405  7978		       20 aa f1 	      jsr	ManProcess
    406  797b
    407  797b		       20 ee f9 	      jsr	MovePlayer	; 6+{}
    408  797e
    409  797e		       a9 06		      lda	#BANK_TrackPlayer	;
    410  7980		       85 3f		      sta	SET_BANK	;
    411  7982		       20 da f3 	      jsr	TrackPlayer	;11+145
    412  7985
    413  7985		       a9 00		      lda	#TYPE_MAN	; 2
    414  7987		       85 8e		      sta	POS_Type	; 3
    415  7989
    416  7989		       20 be f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    417  798c		       4c b1 f9    gnobj      jmp	NextObject
    418  798f
    419  798f							;---------------------------------------------------------------------------
    420  798f
      0  798f					      DEFINE_SUBROUTINE	RestoreOriginalCharacter	;=93[-2](A)
      1  798f		       00 0f	   BANK_RestoreOriginalCharacter =	_CURRENT_BANK
      2  798f					      SUBROUTINE
      3  798f				   RestoreOriginalCharacter
    422  798f
    423  798f		       a6 8b		      ldx	POS_Y	;3
    424  7991		       a4 8a		      ldy	POS_X	;3
    425  7993
    426  7993		       a9 07		      lda	#BANK_BoardLineStartLO	;2
    427  7995		       85 3f		      sta	SET_BANK	;3
    428  7997
    429  7997		       bd 01 f0 	      lda	BoardLineStartLO,x	;4
    430  799a		       85 bf		      sta	Board_AddressW	;3
    431  799c		       bd 2d f0 	      lda	BoardLineStartHiW,x	;4
    432  799f		       85 c0		      sta	Board_AddressW+1	;3 WRITE address
    433  79a1				  -	      IF	MULTI_BANK_BOARD = YES
    434  79a1				  -	      lda	BoardBank,x	;4 switch this on return
    435  79a1					      ELSE
    436  79a1		       a9 0d		      lda	#BANK_BOARD	;2
    437  79a3					      ENDIF
    438  79a3		       85 3e		      sta	SET_BANK_RAM	;3
    439  79a5
    440  79a5		       a5 8f		      lda	POS_VAR
    441  79a7		       91 bf		      sta	(Board_AddressW),y	;6 clear vacated board position
    442  79a9
    443  79a9		       a5 c1		      lda	ROM_Bank	;3
    444  79ab		       85 3f		      sta	SET_BANK	;3
    445  79ad		       60	   EarlyAbortBOX rts		;6
    446  79ae
    447  79ae
    448  79ae							;---------------------------------------------------------------------------
    449  79ae
    450  79ae							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    451  79ae							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    452  79ae
    453  79ae							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    454  79ae
    455  79ae							; if the creature dies then jump NextObject
    456  79ae
    457  79ae
    458  79ae		       20 be f9    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    459  79b1
    460  79b1		       e6 d1	   NextObject inc	ObjIterator	; 5
    461  79b3							;		  dec ObjStackPtr,x		  ; 6
    462  79b3		       4c 7d f8 	      jmp	ProcessObjStack	; 3 = 16
    463  79b6
    464  79b6							;---------------------------------------------------------------------------
    465  79b6
      0  79b6					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  79b6		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  79b6					      SUBROUTINE
      3  79b6				   InsertObjectStackFromRAM
    467  79b6
    468  79b6		       20 be f9 	      jsr	InsertObjectStack	;6+76(B)
    469  79b9		       a5 c2		      lda	RAM_Bank	;3
    470  79bb		       85 3e		      sta	SET_BANK_RAM	;3
    471  79bd
    472  79bd		       60	   NotEnoughTime rts		;6
    473  79be
    474  79be							;---------------------------------------------------------------------------
    475  79be
      0  79be					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  79be		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  79be					      SUBROUTINE
      3  79be				   InsertObjectStack
    477  79be							; POS_X     x position
    478  79be							; POS_Y     y position
    479  79be							; POS_VAR   direction or other variable
    480  79be							; POS_Type  type of object
    481  79be
    482  79be		       a6 85		      ldx	ObjStackNum	; 3
    483  79c0		       bc ec f9 	      ldy	BankObjStack,x	; 4
    484  79c3		       84 3e		      sty	SET_BANK_RAM	; 3
    485  79c5		       b4 86		      ldy	ObjStackPtr,x	; 4 = 14
    486  79c7
    487  79c7
    488  79c7		       a5 8b		      lda	POS_Y	; 3
    489  79c9		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    490  79cc		       a5 8a		      lda	POS_X	; 3
    491  79ce		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    492  79d1		       a5 8f		      lda	POS_VAR	; 3
    493  79d3		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    494  79d6		       a5 8e		      lda	POS_Type	; 3
    495  79d8		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    496  79db
    497  79db							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    498  79db							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    499  79db							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    500  79db
    501  79db
    502  79db				  -	      IF	TYPE_MAN != 0
    503  79db				  -	      cmp	#TYPE_MAN	; 2
    504  79db					      ENDIF
    505  79db		       f0 04		      beq	alwaysAllowMan	; 2/3
    506  79dd
    507  79dd		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    508  79df		       b0 06		      bcs	insertDone	; 2/3= 6    no room -- drop object
    509  79e1				   alwaysAllowMan
    510  79e1
    511  79e1		       98		      tya		; 2
    512  79e2		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    513  79e5
    514  79e5		       f6 86		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    515  79e7
    516  79e7		       a4 c1	   insertDone ldy	ROM_Bank	; 3
    517  79e9		       84 3f		      sty	SET_BANK	; 3
    518  79eb
    519  79eb				   ManIsDead2
    520  79eb
    521  79eb
    522  79eb
    523  79eb		       60		      rts		; 6 = 29
    524  79ec
    525  79ec							;---------------------------------------------------------------------------
    526  79ec
    527  79ec		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    528  79ee
    529  79ee							;---------------------------------------------------------------------------
    530  79ee
    531  79ee				   MovePlayer
    532  79ee
    533  79ee
    534  79ee		       a5 9d		      lda	ManMode
    535  79f0		       c9 02		      cmp	#MANMODE_DEAD
    536  79f2		       b0 f7		      bcs	ManIsDead2
    537  79f4
    538  79f4		       a4 8d		      ldy	POS_Y_NEW
    539  79f6
    540  79f6		       a9 07		      lda	#BANK_GetBoardAddressRW	;2
    541  79f8		       85 3f		      sta	SET_BANK	;3
    542  79fa		       85 c1		      sta	ROM_Bank	;3
    543  79fc		       20 c8 f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    544  79ff				  -	      IF	MULTI_BANK_BOARD = YES
    545  79ff				  -	      stx	RAM_Bank
    546  79ff					      ENDIF
    547  79ff		       86 3e		      stx	SET_BANK_RAM	; 3
    548  7a01
    549  7a01		       a4 8c		      ldy	POS_X_NEW
    550  7a03		       b3 bd		      lax	(Board_AddressR),y
    551  7a05
    552  7a05		       a9 07		      lda	#BANK_MoveVecLO
    553  7a07		       85 3f		      sta	SET_BANK
    554  7a09
    555  7a09		       bd a8 f3 	      lda	MoveVecLO,x
    556  7a0c		       85 de		      sta	MAN_Move
    557  7a0e		       bd b2 f3 	      lda	MoveVecHI,x
    558  7a11		       85 df		      sta	MAN_Move+1
    559  7a13
    560  7a13				  -	      IF	MULTI_BANK_BOARD = YES
    561  7a13				  -	      lda	RAM_Bank
    562  7a13					      ELSE
    563  7a13		       a9 0d		      lda	#BANK_BOARD
    564  7a15					      ENDIF
    565  7a15		       85 3e		      sta	SET_BANK_RAM
    566  7a17		       6c de 00 	      jmp	(MAN_Move)
    567  7a1a
    568  7a1a							;---------------------------------------------------------------------------
    569  7a1a
    570  7a1a
    571  7a1a							;MOVE_TARGET
    572  7a1a							;		  lda INTIM
    573  7a1a							;		  cmp #SEGTIME_GET_TARGET
    574  7a1a							;		  STRESS_TIME SEGTIME_GET_TARGET
    575  7a1a
    576  7a1a							;    IF MULTI_BANK_BOARD = YES
    577  7a1a							;		  lda RAM_Bank
    578  7a1a							;    ELSE
    579  7a1a							;		  lda #BANK_BOARD
    580  7a1a							;    ENDIF
    581  7a1a							;		  sta SET_BANK_RAM
    582  7a1a							;		  bpl checkForSnatch		  ;3		  unconditional
    583  7a1a
    584  7a1a							;---------------------------------------------------------------------------
    585  7a1a
    586  7a1a				   MOVE_BLANK
    587  7a1a				   MOVE_SOIL
    588  7a1a
    589  7a1a
    590  7a1a		       a0 02		      ldy	#SOUND_MOVE_SOIL	; 2
    591  7a1c
    592  7a1c							; lowest priority, look for a free channel, 0 first
    593  7a1c
    594  7a1c		       a7 d0		      lax	newSounds
    595  7a1e		       29 0f		      and	#SND_MASK_LO
    596  7a20		       d0 03		      bne	.skipUseLow	;		 LO channel is not available
    597  7a22
    598  7a22		       98		      tya
    599  7a23		       d0 0a		      bne	.setSound	;		 unconditional: USE lo channel!
    600  7a25
    601  7a25				   .skipUseLow
    602  7a25		       8a		      txa
    603  7a26		       29 f0		      and	#SND_MASK_HI
    604  7a28		       d0 09		      bne	checkForSnatch	;2/3		 no channel available so skip sound
    605  7a2a
    606  7a2a		       98		      tya
    607  7a2b		       0a		      asl
    608  7a2c		       0a		      asl
    609  7a2d		       0a		      asl
    610  7a2e		       0a		      asl		;		 use requested sound in Hi channel
    611  7a2f
    612  7a2f		       05 d0	   .setSound  ora	newSounds
    613  7a31		       85 d0		      sta	newSounds
    614  7a33
    615  7a33							;---------------------------------------------------------------------------
    616  7a33							; Handle snatching...
    617  7a33
    618  7a33				   MOVE_TARGET
    619  7a33				   checkForSnatch
    620  7a33
    621  7a33
    622  7a33		       a9 0d		      lda	#BANK_BOARD
    623  7a35		       85 3e		      sta	SET_BANK_RAM
    624  7a37
    625  7a37		       a4 8c		      ldy	POS_X_NEW
    626  7a39		       b1 bd		      lda	(Board_AddressR),y
    627  7a3b		       48		      pha
    628  7a3c
    629  7a3c		       a9 05		      lda	#CHARACTER_MANOCCUPIED	; 2
    630  7a3e		       91 bf		      sta	(Board_AddressW),y	; 6 =	8	 the man's new square
    631  7a40
    632  7a40		       a6 9a		      ldx	ManY	; 3
    633  7a42		       86 8b		      stx	POS_Y	; 3
    634  7a44		       a4 99		      ldy	ManX	; 3
    635  7a46		       84 8a		      sty	POS_X	; 3 = 12
    636  7a48
    637  7a48		       20 8f f9 	      jsr	RestoreOriginalCharacter
    638  7a4b
    639  7a4b		       68		      pla
    640  7a4c		       85 8f		      sta	POS_VAR
    641  7a4e
    642  7a4e
    643  7a4e		       a5 8c	   pastblank  lda	POS_X_NEW	; 3
    644  7a50		       85 99		      sta	ManX	; 3
    645  7a52		       a5 8d		      lda	POS_Y_NEW	; 3
    646  7a54		       85 9a		      sta	ManY	; 3 = 12	 actually MOVE!
    647  7a56
    648  7a56		       f8		      sed
    649  7a57		       18		      clc
    650  7a58		       a5 b7		      lda	caveTime
    651  7a5a		       69 01		      adc	#1
    652  7a5c		       85 b7		      sta	caveTime
    653  7a5e		       a5 b8		      lda	caveTime+1
    654  7a60		       69 00		      adc	#0
    655  7a62		       85 b8		      sta	caveTime+1
    656  7a64		       d8		      cld
    657  7a65
    658  7a65				   MOVE_GENERIC
    659  7a65							; TJ: used by:
    660  7a65							; - BANK_FIXED.asm
    661  7a65		       a9 00		      lda	#0	; 2
    662  7a67		       85 a3		      sta	ManPushCounter	; 3
    663  7a69
    664  7a69		       20 6d fa 	      jsr	UpMoveCount
    665  7a6c
    666  7a6c		       60	   timeExit   rts		; 6 = 11
    667  7a6d
    668  7a6d
      0  7a6d					      DEFINE_SUBROUTINE	UpMoveCount
      1  7a6d		       00 0f	   BANK_UpMoveCount =	_CURRENT_BANK
      2  7a6d					      SUBROUTINE
      3  7a6d				   UpMoveCount
    670  7a6d
    671  7a6d		       60		      rts
    672  7a6e
    673  7a6e							;---------------------------------------------------------------------------
    674  7a6e
      0  7a6e					      DEFINE_SUBROUTINE	MOVE_BOX
      1  7a6e		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  7a6e					      SUBROUTINE
      3  7a6e				   MOVE_BOX
    676  7a6e
    677  7a6e		       a2 00		      ldx	#CHARACTER_BLANK	; restoration character
    678  7a70		       a9 07		      lda	#BANK_PushBox
    679  7a72		       85 c1		      sta	ROM_Bank
    680  7a74		       85 3f		      sta	SET_BANK
    681  7a76		       4c 1a f1 	      jmp	PushBox
    682  7a79
      0  7a79					      DEFINE_SUBROUTINE	MOVE_BOX_ON_TARGET
      1  7a79		       00 0f	   BANK_MOVE_BOX_ON_TARGET =	_CURRENT_BANK
      2  7a79					      SUBROUTINE
      3  7a79				   MOVE_BOX_ON_TARGET
    684  7a79
    685  7a79		       a2 03		      ldx	#CHARACTER_TARGET	; restoration character
    686  7a7b		       a9 07		      lda	#BANK_PushBox
    687  7a7d		       85 c1		      sta	ROM_Bank
    688  7a7f		       85 3f		      sta	SET_BANK
    689  7a81		       4c 1a f1 	      jmp	PushBox
    690  7a84
    691  7a84							;---------------------------------------------------------------------------
    692  7a84
      0  7a84					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7a84		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7a84					      SUBROUTINE
      3  7a84				   StealCharDraw
    694  7a84
    695  7a84		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    696  7a86		       85 3e		      sta	SET_BANK_RAM	; 3
    697  7a88		       a4 84		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    698  7a8a		       10 35		      bpl	EnterStealCharDraw	; 3 = 10(11)
    699  7a8c
    700  7a8c				   ExitStealCharDraw
    701  7a8c
    702  7a8c							; fall through...
    703  7a8c
    704  7a8c							;---------------------------------------------------------------------------
    705  7a8c
      0  7a8c					      DEFINE_SUBROUTINE	TimeSlice
      1  7a8c		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7a8c					      SUBROUTINE
      3  7a8c				   TimeSlice
    707  7a8c
    708  7a8c							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    709  7a8c							; going ahead if there's insufficient time. This allows the previous character drawing to
    710  7a8c							; be much smaller in time, as they don't have to include the timeslice code overhead.
    711  7a8c
    712  7a8c		       ad 84 02 	      lda	INTIM	; 4
    713  7a8f		       c9 05		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    714  7a91		       90 d9		      bcc	timeExit	; 2(3)
    715  7a93
    716  7a93							; Uses the phase variable to vector to the correct processing code for the given timeslice
    717  7a93							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    718  7a93							; it should increment ScreenDrawPhase.
    719  7a93
    720  7a93							; Switched-in bank(s) are undefined after this function is called!
    721  7a93
    722  7a93		       a9 06		      lda	#BANK_TS_PhaseVectorLO	; 2
    723  7a95		       85 3f		      sta	SET_BANK	; 3
    724  7a97
    725  7a97		       a6 89		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    726  7a99		       bd 61 f4 	      lda	TS_PhaseVectorLO,x	; 4
    727  7a9c		       85 de		      sta	TS_Vector	; 3
    728  7a9e		       bd 66 f4 	      lda	TS_PhaseVectorHI,x	; 4
    729  7aa1		       85 df		      sta	TS_Vector+1	; 3
    730  7aa3
    731  7aa3		       bd 6b f4 	      lda	TS_PhaseBank,x	; 4
    732  7aa6		       85 3f		      sta	SET_BANK	; 3		 switch bank
    733  7aa8
    734  7aa8		       6c de 00 	      jmp	(TS_Vector)	; 3 = 40	 vector to timeslice handler
    735  7aab
    736  7aab							; = 55 minimum return time (if segtime abort)
    737  7aab
    738  7aab							;---------------------------------------------------------------------------
    739  7aab
    740  7aab
    741  7aab				   DrawAnother
    742  7aab
    743  7aab		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    744  7aad		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    745  7aaf
    746  7aaf		       a4 84		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    747  7ab1
    748  7ab1		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    749  7ab4		       bd a0 f0 	      lda	ScreenBuffer,x	; 4	     new character to draw
    750  7ab7		       29 7f		      and	#~128	; 2
    751  7ab9		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    752  7abc
    753  7abc		       88		      dey		; 2
    754  7abd		       84 84		      sty	DrawStackPointer	; 3	     one less to draw
    755  7abf		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7
    756  7ac1
    757  7ac1				   EnterStealCharDraw		;	     RAM bank MUST be at BANK_DRAW_BUFFERS
    758  7ac1
    759  7ac1		       ad 84 02 	      lda	INTIM	; 4
    760  7ac4		       c9 05		      cmp	#SEGTIME_SCD_MIN	; 2
    761  7ac6		       90 c4		      bcc	ExitStealCharDraw	; 2/3= 8
    762  7ac8
    763  7ac8		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    764  7acb		       bc a0 f0 	      ldy	ScreenBuffer,x	; 4 =	8    new character to draw
    765  7ace
    766  7ace		       bd 00 f2 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
    767  7ad1		       85 3e		      sta	SET_BANK_RAM	; 3
    768  7ad3		       4c 53 f1 	      jmp	StealPart3	; 3 = 10    --> 18 cycles after check for SEGTIME_SCD_MIN
    769  7ad6
    770  7ad6
    771  7ad6
    772  7ad6
      0  7ad6					      DEFINE_SUBROUTINE	DrawFullScreenMain	;=2484[-89]
      1  7ad6		       00 0f	   BANK_DrawFullScreenMain =	_CURRENT_BANK
      2  7ad6					      SUBROUTINE
      3  7ad6				   DrawFullScreenMain
    774  7ad6
    775  7ad6							; Check the screen for all those characters that need to be redrawn
    776  7ad6							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
    777  7ad6							; the drawflags array is different to the ScreenBuffer array entry, then the
    778  7ad6							; screenbuffer will need redrawing.
    779  7ad6
    780  7ad6				   CopyRow2
    781  7ad6
    782  7ad6				  -	      IF	MULTI_BANK_BOARD = YES
    783  7ad6				  -	      lda	BDF_BoardBank	; 3
    784  7ad6					      ELSE
    785  7ad6		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
    786  7ad8					      ENDIF
    787  7ad8		       85 3e		      sta	SET_BANK_RAM	; 3
    788  7ada		       b3 e2		      lax	(BDF_BoardAddress),y	; 5
    789  7adc		       9a		      txs		; 2
    790  7add		       b3 e4		      lax	(BDF_BoardAddress2),y	; 5(= 18[-1])
    791  7adf
    792  7adf		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    793  7ae1		       85 3e		      sta	SET_BANK_RAM	; 3
    794  7ae3		       bd d3 f1 	      lda	CharReplacement,x	; 4
    795  7ae6		       91 e0		      sta	(BDF_DrawFlagAddress2),y	; 6
    796  7ae8		       ba		      tsx		; 2
    797  7ae9		       bd d3 f1 	      lda	CharReplacement,x	; 4
    798  7aec		       91 de		      sta	(BDF_DrawFlagAddress),y	; 6(= 27)
    799  7aee
    800  7aee		       88		      dey		; 2
    801  7aef		       10 e5		      bpl	CopyRow2	; 2/3=49/50[-1]
    802  7af1							; total: 5*49[-1]-1 = 244[-5]
    803  7af1
    804  7af1		       a7 e7		      lax	DHS_Line	; 3
    805  7af3		       f0 07		      beq	.exitCopy	; 2/3= 5/6
    806  7af5
    807  7af5		       a0 07		      ldy	#BANK_DrawScreenRowPreparation	;2
    808  7af7		       84 3f		      sty	SET_BANK	; 3
    809  7af9		       4c 6f f3 	      jmp	DrawScreenRowPreparation	;55[-7] = 60[-7]
    810  7afc
    811  7afc							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
    812  7afc
    813  7afc
      0  7afc					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7afc					      LIST	ON
    815  7afc
    816  7afc		       a6 e8	   .exitCopy  ldx	DHS_Stack	; 3
    817  7afe		       9a		      txs		; 2
    818  7aff
    819  7aff							; fall through
    820  7aff
      0  7aff					      DEFINE_SUBROUTINE	BuildDrawStack
      1  7aff		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7aff					      SUBROUTINE
      3  7aff				   BuildDrawStack
    822  7aff
    823  7aff		       a9 08		      lda	#BANK_DRAW_BUFFERS
    824  7b01		       85 3e		      sta	SET_BANK_RAM
    825  7b03		       4c f1 f0 	      jmp	DrawStackUpdate
    826  7b06
    827  7b06							;---------------------------------------------------------------------------
    828  7b06
      0  7b06					      DEFINE_SUBROUTINE	DrawAIntoStack
      1  7b06		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7b06					      SUBROUTINE
      3  7b06				   DrawAIntoStack
    830  7b06
    831  7b06		       a9 08		      lda	#BANK_DRAW_BUFFERS
    832  7b08		       85 3e		      sta	SET_BANK_RAM
    833  7b0a		       4c 1e f1 	      jmp	DrawIntoStack
    834  7b0d
    835  7b0d
    836  7b0d							;---------------------------------------------------------------------------
    837  7b0d
    838  7b0d
    839  7b0d				   Reset
      0  7b0d					      CLEAN_START
      1  7b0d		       78		      sei
      2  7b0e		       d8		      cld
      3  7b0f
      4  7b0f		       a2 00		      ldx	#0
      5  7b11		       8a		      txa
      6  7b12		       a8		      tay
      7  7b13		       ca	   .CLEAR_STACK dex
      8  7b14		       9a		      txs
      9  7b15		       48		      pha
     10  7b16		       d0 fb		      bne	.CLEAR_STACK
     11  7b18
    841  7b18
    842  7b18							; Scoring bank is copied once (not per game, not per level...)
    843  7b18							; otherwise non-SaveKey high score gets zapped
    844  7b18
    845  7b18		       a2 05		      ldx	#ROM_SHADOW_OF_BANK_SCORING
    846  7b1a		       a0 09		      ldy	#BANK_SCORING
    847  7b1c		       20 27 fd 	      jsr	CopyROM2RAM_F000
    848  7b1f
    849  7b1f				   Restart		; go here on RESET + SELECT
    850  7b1f
    851  7b1f
    852  7b1f				   Title
    853  7b1f		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
    854  7b21		       9a		      txs
    855  7b22
    856  7b22		       a9 01		      lda	#BANK_TitleScreen	; 2
    857  7b24		       85 3f		      sta	SET_BANK	; 3
    858  7b26							;jmp TitleScreen		  ; 3+x
    859  7b26				   ExitTitleScreen
    860  7b26							; temporary vars from title screen are used to init level/cave
    861  7b26		       a9 06		      lda	#BANK_Cart_Init	; 2
    862  7b28		       85 3f		      sta	SET_BANK	; 3
    863  7b2a		       20 df f2 	      jsr	Cart_Init	; 6+x
    864  7b2d
    865  7b2d
    866  7b2d							;---------------------------------------------------------------------------
    867  7b2d
    868  7b2d
    869  7b2d		       f0 00	   SEGMENT_DECODE_CAVE_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
    870  7b2d
    871  7b2d		       a2 06		      ldx	#BANK_DECODE_CAVE_SHADOW
    872  7b2f		       a0 0a		      ldy	#BANK_DECODE_CAVE
    873  7b31		       20 27 fd 	      jsr	CopyROM2RAM_F000
    874  7b34
    875  7b34
    876  7b34							;---------------------------------------------------------------------------
    877  7b34							; Once-only game initialisation goes here...
    878  7b34							; now we have two players so things get a bit tricky
    879  7b34
    880  7b34		       a9 09		      lda	#BANK_SCORING
    881  7b36		       85 3e		      sta	SET_BANK_RAM
    882  7b38		       20 86 f3 	      jsr	GameInitialise
    883  7b3b
    884  7b3b
    885  7b3b							;---------------------------------------------------------------------------
    886  7b3b
    887  7b3b				   RestartCaveNextPlayer
    888  7b3b
    889  7b3b
    890  7b3b							; a player has lost a life.
    891  7b3b							; store his vars, swap to other player, continue
    892  7b3b
    893  7b3b							;lda #BANK_SCORING
    894  7b3b							;sta SET_BANK_RAM
    895  7b3b							;jsr SwapPlayers
    896  7b3b
    897  7b3b		       a9 06		      lda	#BANK_SwapPlayersGeneric
    898  7b3d		       85 3f		      sta	SET_BANK
    899  7b3f		       20 36 f3 	      jsr	SwapPlayersGeneric
    900  7b42
    901  7b42		       4c 4b fb 	      jmp	skipDemoCheck	;tmp
    902  7b45		       a5 a5		      lda	ManCount
    903  7b47		       f0 d6		      beq	Title	; all lives lost! (works for both P1P2)
    904  7b49		       d0 00		      bne	skipDemoCheck
    905  7b4b
    906  7b4b				   NextCaveLevel
    907  7b4b							;bit demoMode
    908  7b4b							;bmi Title
    909  7b4b				   skipDemoCheck
    910  7b4b
    911  7b4b							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
    912  7b4b							; including those for general systems function. But NOT those which do not need re-initialising between
    913  7b4b							; levels.
    914  7b4b		       a9 06		      lda	#BANK_LevelInit	; 2
    915  7b4d		       85 3f		      sta	SET_BANK	; 3
    916  7b4f		       20 85 f3 	      jsr	LevelInit	; 6+x
    917  7b52
    918  7b52		       a9 00		      lda	#0
    919  7b54		       85 e7		      sta	base_x
    920  7b56		       85 e8		      sta	base_y
    921  7b58
    922  7b58		       a9 0a		      lda	#BANK_DECODE_CAVE
    923  7b5a		       85 3e		      sta	SET_BANK_RAM
    924  7b5c		       20 79 f1 	      jsr	UnpackLevel
    925  7b5f
    926  7b5f							; TODO now we KNOW the width, we can set the top left accordingly and re-unpack
    927  7b5f
    928  7b5f		       a9 28		      lda	#SIZE_BOARD_X
    929  7b61		       85 93		      sta	BoardLimit_Width
    930  7b63		       a9 16		      lda	#SIZE_BOARD_Y
    931  7b65		       85 94		      sta	BoardLimit_Height
    932  7b67
    933  7b67							; Setup player animation and scroll limits.
    934  7b67							; Mangle the board colours based on level
    935  7b67
    936  7b67		       a9 06		      lda	#BANK_CreateCreatures	; 2
    937  7b69		       85 3f		      sta	SET_BANK	; 3
    938  7b6b		       20 4e f3 	      jsr	CreateCreatures	; 6+x
    939  7b6e
    940  7b6e
    941  7b6e							; Setup the various digit and display pointers
    942  7b6e							; Grab current player's score/cave/level from backup
    943  7b6e
    944  7b6e		       20 1b fd 	      jsr	goGeneralScoringSetups
    945  7b71
    946  7b71							; copy the screen draw ROM shadow to RAM
    947  7b71
    948  7b71		       a0 07		      ldy	#SCREEN_LINES-1
    949  7b73		       a2 03	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
    950  7b75		       20 27 fd 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
    951  7b78		       20 77 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
    952  7b7b		       88		      dey
    953  7b7c		       10 f5		      bpl	CopyScreenBanks
    954  7b7e
    955  7b7e		       a2 04		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    956  7b80		       a0 08		      ldy	#BANK_DRAW_BUFFERS
    957  7b82		       20 43 f0 	      jsr	CopyROMShadowToRAM_F000
    958  7b85
    959  7b85							;---------------------------------------------------------------------------
    960  7b85
    961  7b85		       a9 06		      lda	#BANK_Resync	; 2
    962  7b87		       85 3f		      sta	SET_BANK	; 3
    963  7b89		       20 b6 f3 	      jsr	Resync	; 6+x
    964  7b8c
------- FILE sound/intro1_init.asm LEVEL 3 PASS 3
      0  7b8c					      include	"sound/intro1_init.asm"
      1  7b8c							; TIATracker music player
      2  7b8c							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7b8c							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7b8c							; Email: andre.wichmann@gmx.de
      5  7b8c							;
      6  7b8c							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7b8c							; you may not use this file except in compliance with the License.
      8  7b8c							; You may obtain a copy of the License at
      9  7b8c							;
     10  7b8c							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7b8c							;
     12  7b8c							; Unless required by applicable law or agreed to in writing, software
     13  7b8c							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7b8c							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7b8c							; See the License for the specific language governing permissions and
     16  7b8c							; limitations under the License.
     17  7b8c
     18  7b8c							; Song author: 
     19  7b8c							; Song name: 
     20  7b8c
     21  7b8c							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7b8c
     23  7b8c							; =====================================================================
     24  7b8c							; Initialize music.
     25  7b8c							; Set tt_cur_pat_index_c0/1 to the indexes of the first patterns from
     26  7b8c							; tt_SequenceTable for each channel.
     27  7b8c							; Set tt_timer and tt_cur_note_index_c0/1 to 0.
     28  7b8c							; All other variables can start with any value.
     29  7b8c							; =====================================================================
     30  7b8c		       a9 00		      lda	#0
     31  7b8e		       85 d4		      sta	tt_cur_pat_index_c0
     32  7b90		       a9 05		      lda	#5
     33  7b92		       85 d5		      sta	tt_cur_pat_index_c1
     34  7b94							; the rest should be 0 already from startup code. If not,
     35  7b94							; set the following variables to 0 manually:
     36  7b94							; - tt_timer
     37  7b94							; - tt_cur_pat_index_c0
     38  7b94							; - tt_cur_pat_index_c1
     39  7b94							; - tt_cur_note_index_c0
     40  7b94							; - tt_cur_note_index_c1
     41  7b94
------- FILE BANK_FIXED.asm
    966  7b94
    967  7b94				   NewFrameBD
    968  7b94							; the (at least) 220 cycles wasted in the above... bugs me!
    969  7b94							; the below is an unrolled version.  I've moved some other code between the sync writes, effectively saving um... 22 cycles/frame.
    970  7b94							; This required TIM64T values to be increased by 1 for each platform (we have actually gained back some usable time :)
    971  7b94
    972  7b94		       24 c7		      bit	NextLevelTrigger
    973  7b96		       10 b3		      bpl	NextCaveLevel	; game-triggered next level
    974  7b98							;bvs RestartCaveNextPlayer	  ; loss of life
    975  7b98
    976  7b98							; Note: VSYNC must NOT be on when starting a new cave! Else you get annoying TV signals.
    977  7b98
    978  7b98		       a9 0e		      lda	#%1110	; VSYNC ON
    979  7b9a		       85 42	   .loopVSync sta	WSYNC
    980  7b9c		       85 40		      sta	VSYNC
    981  7b9e		       4a		      lsr
    982  7b9f		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
    983  7ba1
    984  7ba1							; moved *after* the loop since this allows to *increase* timer values by 1!
    985  7ba1
    986  7ba1		       a6 81		      ldx	Platform
    987  7ba3		       bc c7 fc 	      ldy	VBlankTime,x
    988  7ba6		       8c 96 02 	      sty	TIM64T
    989  7ba9
    990  7ba9
------- FILE sound/intro1_player.asm LEVEL 3 PASS 3
      0  7ba9					      include	"sound/intro1_player.asm"
      1  7ba9							; TIATracker music player
      2  7ba9							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7ba9							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7ba9							; Email: andre.wichmann@gmx.de
      5  7ba9							;
      6  7ba9							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7ba9							; you may not use this file except in compliance with the License.
      8  7ba9							; You may obtain a copy of the License at
      9  7ba9							;
     10  7ba9							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7ba9							;
     12  7ba9							; Unless required by applicable law or agreed to in writing, software
     13  7ba9							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7ba9							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7ba9							; See the License for the specific language governing permissions and
     16  7ba9							; limitations under the License.
     17  7ba9
     18  7ba9							; Song author: 
     19  7ba9							; Song name: 
     20  7ba9
     21  7ba9							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7ba9
     23  7ba9							; =====================================================================
     24  7ba9							; TIATracker Player
     25  7ba9							; =====================================================================
     26  7ba9				   tt_PlayerStart
     27  7ba9
     28  7ba9							; PLANNED PLAYER VARIANTS:
     29  7ba9							; - RAM, speed, player ROM: c0/c1 patterns have same length
     30  7ba9							; - RAM: Pack 2 values (out of cur_pat_index, cur_note_index, envelope_index)
     31  7ba9							;	 into one and use lsr/asl to unpack them, allowing only ranges of
     32  7ba9							;	 16/16 or 32/8 for them, depending on number of patterns, max
     33  7ba9							;	 pattern size and max ADSR size
     34  7ba9							; - ROM: Check if tt_SequenceTable can hold ptrs directly without indexing
     35  7ba9							;	 tt_PatternPtrLo/Hi. Can be smaller if not many patterns get repeated
     36  7ba9							;	 (saves table and decode routine)
     37  7ba9							; - Speed: Inline tt_CalcInsIndex
     38  7ba9							; - Speed: Store ptr to current note in RAM instead of reconstructing it?
     39  7ba9							;	 Might also save the need for cur_note_index
     40  7ba9
     41  7ba9
     42  7ba9							; ---------------------------------------------------------------------
     43  7ba9							; Helper macro: Retrieves current note. May advance pattern if needed.
     44  7ba9							; Becomes a subroutine if TT_USE_OVERLAY is used.
     45  7ba9							; ---------------------------------------------------------------------
     46  7ba9					      MAC	tt_fetch_current_note
     47  7ba9							; construct ptr to pattern
     48  7ba9				   .constructPatPtr
     49  7ba9					      ldy	tt_cur_pat_index_c0,x	; get current pattern (index into tt_SequenceTable)
     50  7ba9					      lda	tt_SequenceTable,y
     51  7ba9					      IF	TT_USE_GOTO = 1
     52  7ba9					      bpl	.noPatternGoto
     53  7ba9					      and	#%01111111	; mask out goto bit to get pattern number
     54  7ba9					      sta	tt_cur_pat_index_c0,x	; store goto'ed pattern index
     55  7ba9					      bpl	.constructPatPtr	; unconditional
     56  7ba9				   .noPatternGoto
     57  7ba9					      ENDIF
     58  7ba9					      tay
     59  7ba9					      lda	tt_PatternPtrLo,y
     60  7ba9					      sta	tt_ptr
     61  7ba9					      lda	tt_PatternPtrHi,y
     62  7ba9					      sta	tt_ptr+1
     63  7ba9							; get new note
     64  7ba9					      IF	TT_USE_OVERLAY = 0
     65  7ba9					      ldy	tt_cur_note_index_c0,x
     66  7ba9					      ELSE
     67  7ba9							; If the V flag is set and if the new note is an instrument,
     68  7ba9							; it means it got pre-fetched by an overlay percussion, it has
     69  7ba9							; to remain in sustain.
     70  7ba9					      clv
     71  7ba9							; check if note had been pre-fetched by overlay perc already
     72  7ba9					      lda	tt_cur_note_index_c0,x
     73  7ba9					      bpl	.notPrefetched
     74  7ba9							; If so, remove flag
     75  7ba9					      and	#%01111111
     76  7ba9					      sta	tt_cur_note_index_c0,x
     77  7ba9							; Set V flag for later
     78  7ba9					      bit	tt_Bit6Set
     79  7ba9				   .notPrefetched
     80  7ba9					      tay
     81  7ba9					      ENDIF
     82  7ba9					      lda	(tt_ptr),y
     83  7ba9							; pre-process new note
     84  7ba9							; 7..5: instrument (1..7), 4..0 (0..31): frequency
     85  7ba9							; 0/0: End of pattern
     86  7ba9					      bne	.noEndOfPattern
     87  7ba9							; End of pattern: Advance to next pattern
     88  7ba9					      sta	tt_cur_note_index_c0,x	; a is 0
     89  7ba9					      inc	tt_cur_pat_index_c0,x
     90  7ba9					      bne	.constructPatPtr	; unconditional
     91  7ba9				   .noEndOfPattern
     92  7ba9					      ENDM
     93  7ba9
     94  7ba9
     95  7ba9							; ---------------------------------------------------------------------
     96  7ba9							; Music player entry. Call once per frame.
     97  7ba9							; ---------------------------------------------------------------------
     98  7ba9				   tt_Player  SUBROUTINE
     99  7ba9							; ==================== Sequencer ====================
    100  7ba9							; Decrease speed timer
    101  7ba9		       c6 d3		      dec	tt_timer
    102  7bab		       10 6e		      bpl	.noNewNote
    103  7bad
    104  7bad							; Timer ran out: Do sequencer
    105  7bad							; Advance to next note
    106  7bad		       a2 01		      ldx	#1	; 2 channels
    107  7baf				   .advanceLoop
    108  7baf					      IF	TT_USE_OVERLAY = 1
    109  7baf		       20 c5 fb 	      jsr	tt_FetchNote
    110  7bb2				  -	      ELSE
    111  7bb2				  -	      TT_FETCH_CURRENT_NOTE
    112  7bb2					      ENDIF
    113  7bb2							; Parse new note from pattern
    114  7bb2		       c9 10		      cmp	#TT_INS_PAUSE
    115  7bb4					      IF	TT_USE_SLIDE = 0
    116  7bb4		       90 55		      bcc	.finishedNewNote
    117  7bb6		       d0 3d		      bne	.newNote
    118  7bb8				  -	      ELSE
    119  7bb8				  -	      beq	.pause
    120  7bb8				  -	      bcs	.newNote
    121  7bb8				  -
    122  7bb8				  -			; --- slide/hold ---
    123  7bb8				  -			; Adjust frequency and hold note in sustain.
    124  7bb8				  -			; composer/tracker has to make sure that no unwanted
    125  7bb8				  -			; under/overflow happens.
    126  7bb8				  -			; Note: f = f + (8-(16-x)) = x + f - 8
    127  7bb8				  -	      adc	tt_cur_ins_c0,x	; carry is clear after cmp
    128  7bb8				  -	      sec
    129  7bb8				  -	      sbc	#8
    130  7bb8				  -	      sta	tt_cur_ins_c0,x
    131  7bb8				  -	      bcs	.finishedNewNote	; unconditional, since legally no underflow can happen (ins>0 or HOLD for ins=0)
    132  7bb8					      ENDIF
    133  7bb8
    134  7bb8							; --- pause ---
    135  7bb8				   .pause
    136  7bb8							; Get release index for current instrument. Since a pause can
    137  7bb8							; only follow an instrument, we don't need to handle percussion
    138  7bb8							; or commands.
    139  7bb8		       b5 da		      lda	tt_cur_ins_c0,x
    140  7bba		       20 53 fc 	      jsr	tt_CalcInsIndex
    141  7bbd		       b9 88 fe 	      lda	tt_InsReleaseIndexes-1,y	; -1 b/c instruments start at #1
    142  7bc0							; Put it into release. Skip junk byte so index no longer indicates
    143  7bc0							; sustain phase.
    144  7bc0		       18		      clc
    145  7bc1		       69 01		      adc	#1
    146  7bc3		       90 44		      bcc	.storeADIndex	; unconditional
    147  7bc5
    148  7bc5							; ---------------------------------------------------------------------
    149  7bc5							; Helper subroutine to minimize ROM footprint. Will be inlined if
    150  7bc5							; TT_USE_OVERLAY is not used.
    151  7bc5							; Interleaved here so player can be inlined.
    152  7bc5							; ---------------------------------------------------------------------
    153  7bc5					      IF	TT_USE_OVERLAY = 1
    154  7bc5				   tt_FetchNote
      0  7bc5					      TT_FETCH_CURRENT_NOTE
      1  7bc5
      2  7bc5				   .constructPatPtr
      3  7bc5		       b4 d4		      ldy	tt_cur_pat_index_c0,x
      4  7bc7		       b9 9b ff 	      lda	tt_SequenceTable,y
      5  7bca					      IF	TT_USE_GOTO = 1
      6  7bca		       10 06		      bpl	.noPatternGoto
      7  7bcc		       29 7f		      and	#%01111111
      8  7bce		       95 d4		      sta	tt_cur_pat_index_c0,x
      9  7bd0		       10 f3		      bpl	.constructPatPtr
     10  7bd2				   .noPatternGoto
     11  7bd2					      ENDIF
     12  7bd2		       a8		      tay
     13  7bd3		       b9 91 ff 	      lda	tt_PatternPtrLo,y
     14  7bd6		       85 dc		      sta	tt_ptr
     15  7bd8		       b9 96 ff 	      lda	tt_PatternPtrHi,y
     16  7bdb		       85 dd		      sta	tt_ptr+1
     17  7bdd
     18  7bdd				  -	      IF	TT_USE_OVERLAY = 0
     19  7bdd				  -	      ldy	tt_cur_note_index_c0,x
     20  7bdd					      ELSE
     21  7bdd
     22  7bdd
     23  7bdd
     24  7bdd		       b8		      clv
     25  7bde
     26  7bde		       b5 d6		      lda	tt_cur_note_index_c0,x
     27  7be0		       10 07		      bpl	.notPrefetched
     28  7be2
     29  7be2		       29 7f		      and	#%01111111
     30  7be4		       95 d6		      sta	tt_cur_note_index_c0,x
     31  7be6
     32  7be6		       2c 59 fc 	      bit	tt_Bit6Set
     33  7be9				   .notPrefetched
     34  7be9		       a8		      tay
     35  7bea					      ENDIF
     36  7bea		       b1 dc		      lda	(tt_ptr),y
     37  7bec
     38  7bec
     39  7bec
     40  7bec		       d0 06		      bne	.noEndOfPattern
     41  7bee
     42  7bee		       95 d6		      sta	tt_cur_note_index_c0,x
     43  7bf0		       f6 d4		      inc	tt_cur_pat_index_c0,x
     44  7bf2		       d0 d1		      bne	.constructPatPtr
     45  7bf4				   .noEndOfPattern
    156  7bf4		       60		      rts
    157  7bf5					      ENDIF
    158  7bf5
    159  7bf5
    160  7bf5							; --- start instrument or percussion ---
    161  7bf5				   .newNote
    162  7bf5		       95 da		      sta	tt_cur_ins_c0,x	; set new instrument
    163  7bf7							; Instrument or percussion?
    164  7bf7		       c9 20		      cmp	#TT_FREQ_MASK+1
    165  7bf9		       b0 06		      bcs	.startInstrument
    166  7bfb
    167  7bfb							; --- start percussion ---
    168  7bfb							; Get index of envelope
    169  7bfb		       a8		      tay
    170  7bfc							; -TT_FIRST_PERC because percussion start with TT_FIRST_PERC
    171  7bfc		       b9 ac fe 	      lda	tt_PercIndexes-TT_FIRST_PERC,y
    172  7bff		       d0 08		      bne	.storeADIndex	; unconditional, since index values are >0
    173  7c01
    174  7c01							; --- start instrument ---
    175  7c01				   .startInstrument
    176  7c01					      IF	TT_USE_OVERLAY = 1
    177  7c01							; If V flag is set, this note had been pre-fetched. That means
    178  7c01							; it should remain in sustain.
    179  7c01		       70 08		      bvs	.finishedNewNote
    180  7c03					      ENDIF
    181  7c03							; Put note into attack/decay
    182  7c03		       20 53 fc 	      jsr	tt_CalcInsIndex
    183  7c06		       b9 7e fe 	      lda	tt_InsADIndexes-1,y	; -1 because instruments start at #1
    184  7c09				   .storeADIndex
    185  7c09		       95 d8		      sta	tt_envelope_index_c0,x
    186  7c0b
    187  7c0b							; --- Finished parsing new note ---
    188  7c0b				   .finishedNewNote
    189  7c0b							; increase note index into pattern
    190  7c0b		       f6 d6		      inc	tt_cur_note_index_c0,x
    191  7c0d							; loop over channels
    192  7c0d				   .sequencerNextChannel
    193  7c0d		       ca		      dex
    194  7c0e		       10 9f		      bpl	.advanceLoop
    195  7c10
    196  7c10							; Reset timer value
    197  7c10				  -	      IF	TT_GLOBAL_SPEED = 0
    198  7c10				  -			; Get timer value for current pattern in channel 0
    199  7c10				  -	      ldx	tt_cur_pat_index_c0	; get current pattern (index into tt_SequenceTable)
    200  7c10				  -	      ldy	tt_SequenceTable,x	; Current pattern index now in y
    201  7c10				  -	      IF	TT_USE_FUNKTEMPO = 0
    202  7c10				  -	      lda	tt_PatternSpeeds,y
    203  7c10				  -	      sta	tt_timer
    204  7c10				  -	      ELSE
    205  7c10				  -			; Test for odd/even frame
    206  7c10				  -	      lda	tt_cur_note_index_c0
    207  7c10				  -	      lsr
    208  7c10				  -	      lda	tt_PatternSpeeds,y	; does not affect carry flag
    209  7c10				  -	      bcc	.evenFrame
    210  7c10				  -	      and	#$0f	; does not affect carry flag
    211  7c10				  -	      bcs	.storeFunkTempo
    212  7c10				  -.evenFrame
    213  7c10				  -	      lsr
    214  7c10				  -	      lsr
    215  7c10				  -	      lsr
    216  7c10				  -	      lsr
    217  7c10				  -.storeFunkTempo
    218  7c10				  -	      sta	tt_timer
    219  7c10				  -	      ENDIF		; TT_USE_FUNKTEMPO = 0
    220  7c10				  -
    221  7c10					      ELSE
    222  7c10							; Global tempo
    223  7c10		       a2 04		      ldx	#TT_SPEED-1
    224  7c12					      IF	TT_USE_FUNKTEMPO = 1
    225  7c12		       a5 d6		      lda	tt_cur_note_index_c0
    226  7c14		       4a		      lsr
    227  7c15		       90 02		      bcc	.noOddFrame
    228  7c17		       a2 03		      ldx	#TT_ODD_SPEED-1
    229  7c19				   .noOddFrame
    230  7c19					      ENDIF		; TT_USE_FUNKTEMPO = 1
    231  7c19		       86 d3		      stx	tt_timer
    232  7c1b					      ENDIF		; TT_GLOBAL_SPEED = 0
    233  7c1b
    234  7c1b							; No new note to process
    235  7c1b				   .noNewNote
    236  7c1b
    237  7c1b							; ==================== Update registers ====================
    238  7c1b		       a2 01		      ldx	#1	; 2 channels
    239  7c1d				   .updateLoop
    240  7c1d							; Percussion or melodic instrument?
    241  7c1d		       b5 da		      lda	tt_cur_ins_c0,x
    242  7c1f				  -	      IF	TT_STARTS_WITH_NOTES = 0
    243  7c1f				  -			; This branch can be removed if track starts with a note in each channel
    244  7c1f				  -	      beq	.afterAudioUpdate
    245  7c1f					      ENDIF
    246  7c1f		       c9 20		      cmp	#TT_FREQ_MASK+1
    247  7c21		       b0 37		      bcs	.instrument	; Melodic instrument
    248  7c23
    249  7c23							; --- Percussion: Get envelope index ---
    250  7c23		       b4 d8		      ldy	tt_envelope_index_c0,x
    251  7c25							; Set AUDC and AUDV value from envelope
    252  7c25		       b9 d5 fe 	      lda	tt_PercCtrlVolTable-1,y	; -1 because values are stored +1
    253  7c28		       f0 02		      beq	.endOfPercussion	; 0 means end of percussion data
    254  7c2a		       f6 d8		      inc	tt_envelope_index_c0,x	; if end not reached: advance index
    255  7c2c				   .endOfPercussion
    256  7c2c		       95 59		      sta	AUDV0,x
    257  7c2e		       4a		      lsr
    258  7c2f		       4a		      lsr
    259  7c30		       4a		      lsr
    260  7c31		       4a		      lsr
    261  7c32		       95 55		      sta	AUDC0,x
    262  7c34							; Set AUDF
    263  7c34		       b9 bf fe 	      lda	tt_PercFreqTable-1,y	; -1 because values are stored +1
    264  7c37							; Bit 7 (overlay) might be set, but is unused in AUDF
    265  7c37		       95 57		      sta	AUDF0,x
    266  7c39					      IF	TT_USE_OVERLAY = 1
    267  7c39		       10 48		      bpl	.afterAudioUpdate
    268  7c3b							; Overlay percussion: Fetch next note out of order
    269  7c3b		       20 c5 fb 	      jsr	tt_FetchNote
    270  7c3e							; Only do something if it's a melodic instrument
    271  7c3e		       c9 20		      cmp	#TT_FREQ_MASK+1
    272  7c40		       90 41		      bcc	.afterAudioUpdate
    273  7c42							; Instrument: Put into sustain
    274  7c42		       95 da		      sta	tt_cur_ins_c0,x	; set new instrument
    275  7c44		       20 53 fc 	      jsr	tt_CalcInsIndex
    276  7c47		       b9 83 fe 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start at #1
    277  7c4a		       95 d8		      sta	tt_envelope_index_c0,x
    278  7c4c							; Set prefetch flag. asl-sec-ror is smaller than lda-ora #128-sta
    279  7c4c		       16 d6		      asl	tt_cur_note_index_c0,x
    280  7c4e		       38		      sec
    281  7c4f		       76 d6		      ror	tt_cur_note_index_c0,x
    282  7c51		       30 30		      bmi	.afterAudioUpdate	; unconditional
    283  7c53				  -	      ELSE
    284  7c53				  -	      jmp	.afterAudioUpdate
    285  7c53					      ENDIF
    286  7c53
    287  7c53
    288  7c53							; ---------------------------------------------------------------------
    289  7c53							; Helper subroutine to minimize ROM footprint.
    290  7c53							; Interleaved here so player routine can be inlined.
    291  7c53							; ---------------------------------------------------------------------
    292  7c53				   tt_CalcInsIndex
    293  7c53							; move upper 3 bits to lower 3
    294  7c53		       4a		      lsr
    295  7c54		       4a		      lsr
    296  7c55		       4a		      lsr
    297  7c56		       4a		      lsr
    298  7c57		       4a		      lsr
    299  7c58		       a8		      tay
    300  7c59				   tt_Bit6Set		; This opcode has bit #6 set, for use with bit instruction
    301  7c59		       60		      rts
    302  7c5a
    303  7c5a
    304  7c5a				   .instrument
    305  7c5a							; --- Melodic instrument ---
    306  7c5a							; Compute index into ADSR indexes and master Ctrl tables
    307  7c5a		       20 53 fc 	      jsr	tt_CalcInsIndex
    308  7c5d							; Set AUDC with master value for this instrument, while we are at it
    309  7c5d		       b9 79 fe 	      lda	tt_InsCtrlTable-1,y	; -1 because instruments start with #1
    310  7c60		       95 55		      sta	AUDC0,x
    311  7c62							; advance ADSR counter and compare to end of Sustain
    312  7c62		       b5 d8		      lda	tt_envelope_index_c0,x
    313  7c64		       d9 88 fe 	      cmp	tt_InsReleaseIndexes-1,y	; -1 because instruments start with #1
    314  7c67		       d0 03		      bne	.noEndOfSustain
    315  7c69							; End of sustain: Go back to start of sustain
    316  7c69		       b9 83 fe 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start with #1
    317  7c6c				   .noEndOfSustain
    318  7c6c		       a8		      tay
    319  7c6d							; Set volume from envelope
    320  7c6d		       b9 8e fe 	      lda	tt_InsFreqVolTable,y
    321  7c70		       f0 01		      beq	.endOfEnvelope	; 0 means end of release has been reached:
    322  7c72		       c8		      iny		; advance index otherwise
    323  7c73				   .endOfEnvelope
    324  7c73		       94 d8		      sty	tt_envelope_index_c0,x
    325  7c75		       95 59		      sta	AUDV0,x
    326  7c77							; Now adjust frequency with ADSR value from envelope
    327  7c77		       4a		      lsr
    328  7c78		       4a		      lsr
    329  7c79		       4a		      lsr
    330  7c7a		       4a		      lsr
    331  7c7b		       18		      clc
    332  7c7c		       75 da		      adc	tt_cur_ins_c0,x
    333  7c7e		       38		      sec
    334  7c7f		       e9 08		      sbc	#8
    335  7c81		       95 57		      sta	AUDF0,x
    336  7c83
    337  7c83				   .afterAudioUpdate
    338  7c83							; loop over channels
    339  7c83		       ca		      dex
    340  7c84		       10 97		      bpl	.updateLoop
    341  7c86
 Music player size:  $dd
    342  7c86					      echo	"Music player size: ", *-tt_PlayerStart
------- FILE BANK_FIXED.asm
    992  7c86
    993  7c86
    994  7c86							;ldx #BANK_PlaySounds
    995  7c86							;stx SET_BANK
    996  7c86
    997  7c86							;---------------------------------------------------------------------------
    998  7c86							; Do not separate code, as bank assumption is made
    999  7c86
   1000  7c86							;jsr PlaySounds		  ; 6+x   Jentzsch sound system
   1001  7c86
   1002  7c86		       20 84 fa 	      jsr	StealCharDraw	; NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
   1003  7c89
   1004  7c89							;---------------------------------------------------------------------------
   1005  7c89							; START OF DISPLAY
   1006  7c89
   1007  7c89		       a9 09		      lda	#BANK_SCORING	; 2
   1008  7c8b		       85 3e		      sta	SET_BANK_RAM	; 3
   1009  7c8d		       20 d3 f1 	      jsr	DrawDigits	; 6 = 11
   1010  7c90
   1011  7c90							;---------------------------------------------------------------------------
   1012  7c90							; A 42-cycle timing window in the screen draw code.  Perform any general
   1013  7c90							; per-frame code here, provided it takes exactly 42 cycles to execute.
   1014  7c90							; TJ: Well, not exactly 42 cycles, but it works! :)
   1015  7c90							;	 @09
   1016  7c90		       85 49		      sta	COLUBK	; 3	 value comes from subroutine
   1017  7c92							; + the 'black' left-side of top screen colour change when look-around is actually a HMOVE bar, so we can't fix it :)
   1018  7c92
   1019  7c92
   1020  7c92							;		  inc Throttle		      ; 5     speed limiter
      0  7c92					      SLEEP	5	;	 TODO: optimize for space
      1  7c92				   .CYCLES    SET	5
      2  7c92
      3  7c92				  -	      IF	.CYCLES < 2
      4  7c92				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c92				  -	      ERR
      6  7c92					      ENDIF
      7  7c92
      8  7c92					      IF	.CYCLES & 1
      9  7c92					      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c92		       04 00		      nop	0
     11  7c94				  -	      ELSE
     12  7c94				  -	      bit	VSYNC
     13  7c94					      ENDIF
     14  7c94				   .CYCLES    SET	.CYCLES - 3
     15  7c94					      ENDIF
     16  7c94
     17  7c94					      REPEAT	.CYCLES / 2
     18  7c94		       ea		      nop
     19  7c95					      REPEND
   1022  7c95
   1023  7c95		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
   1024  7c97		       ca		      dex		; 2	 = $6f, stars effect!
   1025  7c98		       86 62		      stx	HMM0	; 3	 @24, exactly 21 cycles after the HMOVE
   1026  7c9a
   1027  7c9a		       85 44		      sta	NUSIZ0	; 3
   1028  7c9c		       84 65		      sty	VDELP0	; 3	 y = 0!
   1029  7c9e
      0  7c9e					      SLEEP	10
      1  7c9e				   .CYCLES    SET	10
      2  7c9e
      3  7c9e				  -	      IF	.CYCLES < 2
      4  7c9e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c9e				  -	      ERR
      6  7c9e					      ENDIF
      7  7c9e
      8  7c9e				  -	      IF	.CYCLES & 1
      9  7c9e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c9e				  -	      nop	0
     11  7c9e				  -	      ELSE
     12  7c9e				  -	      bit	VSYNC
     13  7c9e				  -	      ENDIF
     14  7c9e				  -.CYCLES    SET	.CYCLES - 3
     15  7c9e					      ENDIF
     16  7c9e
     17  7c9e					      REPEAT	.CYCLES / 2
     18  7c9e		       ea		      nop
     17  7c9e					      REPEND
     18  7c9f		       ea		      nop
     17  7c9f					      REPEND
     18  7ca0		       ea		      nop
     17  7ca0					      REPEND
     18  7ca1		       ea		      nop
     17  7ca1					      REPEND
     18  7ca2		       ea		      nop
     19  7ca3					      REPEND
   1031  7ca3							;iny			      ; 2     this relies on Y == 0 before...
   1032  7ca3							;cpy extraLifeTimer	      ; 3     ..,and bit 0 is set in A
   1033  7ca3							;adc #2		      ; 2
   1034  7ca3							;sta ENAM0		      ; 3     dis/enable Cosmic Ark star effect
   1035  7ca3
   1036  7ca3		       a5 a2		      lda	ManLastDirection	; 3
   1037  7ca5		       85 4b		      sta	REFP0	; 3
   1038  7ca7
   1039  7ca7		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
   1040  7ca9		       85 3e		      sta	SET_BANK_RAM	; 3
   1041  7cab		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1042  7cae							;	 @66
   1043  7cae		       a9 06		      lda	#BANK_PostScreenCleanup	; 2
   1044  7cb0		       85 3f		      sta	SET_BANK	; 3
   1045  7cb2		       20 78 f4 	      jsr	PostScreenCleanup	; 6+x
   1046  7cb5
   1047  7cb5		       a9 03		      lda	#BANK_SelfModDrawPlayers	; 2
   1048  7cb7		       85 3f		      sta	SET_BANK	; 3
   1049  7cb9		       20 fb f2 	      jsr	SelfModDrawPlayers	; 6+x
   1050  7cbc
   1051  7cbc		       20 84 fa 	      jsr	StealCharDraw
   1052  7cbf
   1053  7cbf		       ad 84 02    OverscanBD lda	INTIM	;4
   1054  7cc2		       d0 fb		      bne	OverscanBD	;2/3
   1055  7cc4		       4c 94 fb 	      jmp	NewFrameBD
   1056  7cc7				   VBlankTime
   1057  7cc7		       3e 3e		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
   1058  7cc9		       55 55		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_PAL
   1059  7ccb
   1060  7ccb							;---------------------------------------------------------------------------
   1061  7ccb
   1062  7ccb				   CharacterDataVecLO
   1063  7ccb
   1064  7ccb							; Two entries per character.  2nd is ptr to mirrored character
   1065  7ccb							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
   1066  7ccb
   1067  7ccb		       25		      .byte.b	<CHARACTERSHAPE_BLANK
   1068  7ccc		       25		      .byte.b	<CHARACTERSHAPE_BLANK
   1069  7ccd		       cd		      .byte.b	<CHARACTERSHAPE_SOIL
   1070  7cce		       cd		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
   1071  7ccf		       30		      .byte.b	<CHARACTERSHAPE_BOX
   1072  7cd0		       45		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
   1073  7cd1		       54		      .byte.b	<CHARACTERSHAPE_TARGET
   1074  7cd2		       3f		      .byte.b	<CHARACTERSHAPE_TARGET_MIRRORED
   1075  7cd3		       53		      .byte.b	<CHARACTERSHAPE_TARGET2
   1076  7cd4		       3e		      .byte.b	<CHARACTERSHAPE_TARGET2_MIRRORED
   1077  7cd5		       25		      .byte.b	<CHARACTERSHAPE_BLANK	; man occupied
   1078  7cd6		       25		      .byte.b	<CHARACTERSHAPE_BLANK
   1079  7cd7		       84		      .byte.b	<CHARACTERSHAPE_STEEL
   1080  7cd8		       99		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
   1081  7cd9		       00		      .byte.b	<CHARACTERSHAPE_WALL
   1082  7cda		       15		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
   1083  7cdb		       5a		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET
   1084  7cdc		       6f		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
   1085  7cdd		       25		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
   1086  7cde		       25		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
   1087  7cdf
   1088  7cdf				  -	      IF	* - CharacterDataVecLO < CHARACTER_MAXIMUM*2
   1089  7cdf				  -	      ECHO	"ERROR: Missing entry in CharacterDataVecLO table!"
   1090  7cdf				  -	      EXIT
   1091  7cdf					      ENDIF
   1092  7cdf
   1093  7cdf							;---------------------------------------------------------------------------
   1094  7cdf
   1095  7cdf				   CharacterDataVecHI
   1096  7cdf							; TJ: used by:
   1097  7cdf							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1098  7cdf
   1099  7cdf		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
   1100  7ce0		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
   1101  7ce1		       f3		      .byte.b	>CHARACTERSHAPE_SOIL
   1102  7ce2		       f3		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
   1103  7ce3		       fd		      .byte.b	>CHARACTERSHAPE_BOX
   1104  7ce4		       fd		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
   1105  7ce5		       f2		      .byte.b	>CHARACTERSHAPE_TARGET
   1106  7ce6		       f2		      .byte.b	>CHARACTERSHAPE_TARGET_MIRRORED
   1107  7ce7		       f2		      .byte.b	>CHARACTERSHAPE_TARGET2
   1108  7ce8		       f2		      .byte.b	>CHARACTERSHAPE_TARGET2_MIRRORED
   1109  7ce9		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; man occupied
   1110  7cea		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
   1111  7ceb		       fd		      .byte.b	>CHARACTERSHAPE_STEEL
   1112  7cec		       fd		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
   1113  7ced		       f8		      .byte.b	>CHARACTERSHAPE_WALL
   1114  7cee		       f8		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
   1115  7cef		       fd		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET
   1116  7cf0		       fd		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
   1117  7cf1		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
   1118  7cf2		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
   1119  7cf3
   1120  7cf3				  -	      IF	* - CharacterDataVecHI < CHARACTER_MAXIMUM*2
   1121  7cf3				  -	      ECHO	"ERROR: Missing entry in CharacterDataVecHI table!"
   1122  7cf3				  -	      EXIT
   1123  7cf3					      ENDIF
   1124  7cf3
   1125  7cf3							;---------------------------------------------------------------------------
   1126  7cf3
      0  7cf3					      DEFINE_SUBROUTINE	AnimateCharReplacements2	;139
      1  7cf3		       00 0f	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  7cf3					      SUBROUTINE
      3  7cf3				   AnimateCharReplacements2
   1128  7cf3
   1129  7cf3							; This manages character animation on a per-object basis.  Morph/animate these
   1130  7cf3							; characters individually or as required.  Change will affect all characters
   1131  7cf3							; of the same type in the visible display.
   1132  7cf3
   1133  7cf3							; -------------------------------------------
   1134  7cf3
   1135  7cf3							; handle the non-mandatory animating things
   1136  7cf3
   1137  7cf3		       a5 af		      lda	timer	;3
   1138  7cf5		       29 03		      and	#%11	;2
   1139  7cf7		       d0 0c		      bne	nothingAnimates	;2/3
   1140  7cf9
   1141  7cf9		       a5 97		      lda	scrollBits	;3
   1142  7cfb		       d0 08		      bne	nothingAnimates	;2/3		 DON'T animate if we scrolled
   1143  7cfd
   1144  7cfd		       ad d6 f1 	      lda	ANIM_TARGET	;4
   1145  7d00		       49 07		      eor	#CHARACTER_TARGET^CHARACTER_TARGET2	;2
   1146  7d02		       8d d6 f5 	      sta	ANIM_TARGET + RAM_WRITE	;4 = 15	 diamond
   1147  7d05
   1148  7d05		       4c 18 f1    nothingAnimates jmp	retAnim	;3
   1149  7d08
   1150  7d08							;---------------------------------------------------------------------------
   1151  7d08
      0  7d08					      DEFINE_SUBROUTINE	ScoreAdd
      1  7d08		       00 0f	   BANK_ScoreAdd =	_CURRENT_BANK
      2  7d08					      SUBROUTINE
      3  7d08				   ScoreAdd
   1153  7d08							; TJ: used by:
   1154  7d08							; - BANK_INITBANK.asm
   1155  7d08		       a2 09		      ldx	#BANK_SCORING
   1156  7d0a		       86 3e		      stx	SET_BANK_RAM
   1157  7d0c		       20 0f f2 	      jsr	UpdateScore
   1158  7d0f		       a5 c1	   rbret      lda	ROM_Bank
   1159  7d11		       85 3f		      sta	SET_BANK
   1160  7d13		       60		      rts
   1161  7d14
   1162  7d14							;---------------------------------------------------------------------------
   1163  7d14
      0  7d14					      DEFINE_SUBROUTINE	nextLevelMan
      1  7d14		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7d14					      SUBROUTINE
      3  7d14				   nextLevelMan
   1165  7d14
   1166  7d14		       a9 02		      lda	#BANK_NextCave
   1167  7d16		       85 3f		      sta	SET_BANK
   1168  7d18		       4c 00 f4 	      jmp	NextCave
   1169  7d1b
   1170  7d1b
   1171  7d1b							;---------------------------------------------------------------------------
   1172  7d1b
      0  7d1b					      DEFINE_SUBROUTINE	goGeneralScoringSetups
      1  7d1b		       00 0f	   BANK_goGeneralScoringSetups =	_CURRENT_BANK
      2  7d1b					      SUBROUTINE
      3  7d1b				   goGeneralScoringSetups
   1174  7d1b
   1175  7d1b		       a9 09		      lda	#BANK_SCORING
   1176  7d1d		       85 3e		      sta	SET_BANK_RAM
   1177  7d1f		       20 8f f2 	      jsr	GeneralScoringSetups
   1178  7d22		       a5 c1		      lda	ROM_Bank
   1179  7d24		       85 3f		      sta	SET_BANK
   1180  7d26		       60		      rts
   1181  7d27							;---------------------------------------------------------------------------
   1182  7d27
      0  7d27					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7d27		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7d27					      SUBROUTINE
      3  7d27				   CopyROM2RAM_F000
   1184  7d27
   1185  7d27		       a9 07		      lda	#BANK_CopyROMShadowToRAM
   1186  7d29		       85 3f		      sta	SET_BANK
   1187  7d2b		       85 c1		      sta	ROM_Bank
   1188  7d2d		       4c 43 f0 	      jmp	CopyROMShadowToRAM_F000
   1189  7d30
   1190  7d30
   1191  7d30							;---------------------------------------------------------------------------
   1192  7d30
------- FILE BOX.asm LEVEL 3 PASS 3
      0  7d30					      include	"BOX.asm"	; 2 * LINES_PER_CHAR bytes
      0  7d30					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  7d30					      LIST	ON
      2  7d30				   CHARACTERSHAPE_BOX
      3  7d30				  -	      if	MIRRORED_BOX = NO
      4  7d30				  -CHARACTERSHAPE_BOX_MIRRORED
      5  7d30					      endif
      6  7d30		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
      7  7d37		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
      8  7d3e		       00 00 00 00*	      .byte.b	%0,%0,%0,0,%0,%0,%0	;B
      9  7d45
     10  7d45							;--------------------------------------------------------------------------
     11  7d45					      if	MIRRORED_BOX = YES
      0  7d45					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
     10  7d45					      LIST	ON
     13  7d45				   CHARACTERSHAPE_BOX_MIRRORED
     14  7d45		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
     15  7d4c		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     16  7d53		       00 00 00 00*	      .byte.b	%0,%0,0,0,%0,%0,%0	;B
     17  7d5a					      endif
     18  7d5a
      0  7d5a					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET", LINES_PER_CHAR
     10  7d5a					      LIST	ON
     20  7d5a				   CHARACTERSHAPE_BOX_ON_TARGET
     21  7d5a				  -	      if	MIRRORED_BOX = NO
     22  7d5a				  -CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     23  7d5a					      endif
     24  7d5a		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     25  7d61		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     26  7d68		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,0,%0,%0	;B
     27  7d6f
     28  7d6f							;--------------------------------------------------------------------------
     29  7d6f					      if	MIRRORED_BOX = YES
      0  7d6f					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED", LINES_PER_CHAR
     10  7d6f					      LIST	ON
     31  7d6f				   CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     32  7d6f		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     33  7d76		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     34  7d7d		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,0,%0,%0	;B
     35  7d84					      endif
------- FILE BANK_FIXED.asm
------- FILE Steel_Wall.asm LEVEL 3 PASS 3
      0  7d84					      include	"Steel_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      1  7d84							;--------------------------------------------------------------------------
      0  7d84					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
     10  7d84					      LIST	ON
      3  7d84				   CHARACTERSHAPE_STEEL
      4  7d84				   CHARACTERSHAPE_EXITDOOR
      5  7d84				  -	      if	MIRRORED_STEEL = NO
      6  7d84				  -CHARACTERSHAPE_STEEL_MIRRORED
      7  7d84				  -CHARACTERSHAPE_EXITDOOR_MIRRORED
      8  7d84					      endif
      9  7d84		       00 11 00 00*	      .byte.b	%00000000,%00010001,%00000000,%00000000,%01000100,%00000000,%00000000	;R
     10  7d8b		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;G
     11  7d92		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;B
     12  7d99
     13  7d99							;--------------------------------------------------------------------------
     14  7d99					      if	MIRRORED_STEEL = YES
      0  7d99					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
     10  7d99					      LIST	ON
     16  7d99				   CHARACTERSHAPE_STEEL_MIRRORED
     17  7d99				   CHARACTERSHAPE_EXITDOOR_MIRRORED
     18  7d99		       00 88 00 00*	      .byte.b	%00000000,%10001000,%00000000,%00000000,%00100010,%00000000,%00000000	;R
     19  7da0		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;G
     20  7da7		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;B
     21  7dae					      endif
------- FILE BANK_FIXED.asm
   1195  7dae							;---------------------------------------------------------------------------
   1196  7dae
------- FILE circle.asm LEVEL 3 PASS 3
      0  7dae					      include	"circle.asm"
      1  7dae
      2  7dae							;Begin {Circle}
      3  7dae							;x := r;
      4  7dae							;y := 0;
      5  7dae							;d := 1 - r;
      6  7dae							;Repeat
      7  7dae							;Circle_Points(x,y);
      8  7dae							;y := y + 1;
      9  7dae							;if d < 0 Then
     10  7dae							;    d := d + 2*y + 1
     11  7dae							;Else Begin
     12  7dae							;    x := x - 1;
     13  7dae							;    d := d + 2*(y-x) + 1
     14  7dae							;    End
     15  7dae							;Until x < y
     16  7dae							;End; {Circle}
     17  7dae
     18  7dae
      0  7dae					      DEFINE_SUBROUTINE	PlotChar
      1  7dae		       00 0f	   BANK_PlotChar =	_CURRENT_BANK
      2  7dae					      SUBROUTINE
      3  7dae				   PlotChar
     20  7dae
     21  7dae							; a = x pos
     22  7dae							; y = y pos
     23  7dae
     24  7dae		       c5 93		      cmp	BoardLimit_Width
     25  7db0		       b0 14		      bcs	off1x
     26  7db2		       c4 94		      cpy	BoardLimit_Height
     27  7db4		       b0 10		      bcs	off1x
     28  7db6
     29  7db6		       48		      pha
     30  7db7		       a9 07		      lda	#BANK_GetBoardAddressW	;
     31  7db9		       85 3f		      sta	SET_BANK	;
     32  7dbb		       20 0d f1 	      jsr	GetBoardAddressW	;11+24[-2](A)
     33  7dbe
     34  7dbe		       86 3e		      stx	SET_BANK_RAM	;3
     35  7dc0
     36  7dc0		       68		      pla
     37  7dc1		       a8		      tay
     38  7dc2		       a5 ab		      lda	circ_char	;3
     39  7dc4		       91 bf		      sta	(Board_AddressW),y	;6
     40  7dc6		       60	   off1x      rts
     41  7dc7
     42  7dc7							;x	       Plot(x,y);
     43  7dc7							;x	       Plot(y,x);
     44  7dc7							;x	      Plot(y,-x);
     45  7dc7							;x	      Plot(x,-y);
     46  7dc7							;x	      Plot(-x,-y);
     47  7dc7							;x	      Plot(-y,-x);
     48  7dc7							;x	       Plot(-y,x);
     49  7dc7							;x	       Plot(-x,y)
     50  7dc7
      0  7dc7					      DEFINE_SUBROUTINE	PlotCirclePoints
      1  7dc7		       00 0f	   BANK_PlotCirclePoints =	_CURRENT_BANK
      2  7dc7					      SUBROUTINE
      3  7dc7				   PlotCirclePoints
     52  7dc7
     53  7dc7							; +x+y
     54  7dc7		       18		      clc
     55  7dc8		       a5 aa		      lda	circ_y
     56  7dca		       4a		      lsr
     57  7dcb		       65 9a		      adc	ManY	; "origin"
     58  7dcd		       a8		      tay
     59  7dce		       18		      clc
     60  7dcf		       a5 a9		      lda	circ_x
     61  7dd1		       4a		      lsr
     62  7dd2		       65 99		      adc	ManX
     63  7dd4		       c5 94		      cmp	BoardLimit_Height
     64  7dd6		       b0 ee		      bcs	off1x
     65  7dd8		       20 ae fd 	      jsr	PlotChar
     66  7ddb
     67  7ddb							;+y+x
     68  7ddb		       18		      clc
     69  7ddc		       a5 a9		      lda	circ_x
     70  7dde		       4a		      lsr
     71  7ddf		       65 9a		      adc	ManY	; "origin"
     72  7de1		       a8		      tay
     73  7de2		       18		      clc
     74  7de3		       a5 aa		      lda	circ_y
     75  7de5		       4a		      lsr
     76  7de6		       65 99		      adc	ManX
     77  7de8		       20 ae fd 	      jsr	PlotChar
     78  7deb
     79  7deb							; y,-x
     80  7deb		       38		      sec
     81  7dec		       a5 9a		      lda	ManY
     82  7dee		       0a		      asl
     83  7def		       e5 a9		      sbc	circ_x
     84  7df1		       4a		      lsr
     85  7df2		       a8		      tay
     86  7df3		       18		      clc
     87  7df4		       a5 aa		      lda	circ_y
     88  7df6		       4a		      lsr
     89  7df7		       65 99		      adc	ManX	; "origin"
     90  7df9		       20 ae fd 	      jsr	PlotChar
     91  7dfc
     92  7dfc							; x,-y
     93  7dfc		       a5 9a		      lda	ManY
     94  7dfe		       0a		      asl
     95  7dff		       38		      sec
     96  7e00		       e5 aa		      sbc	circ_y	; "origin"
     97  7e02		       4a		      lsr
     98  7e03		       a8		      tay
     99  7e04		       a5 a9		      lda	circ_x
    100  7e06		       4a		      lsr
    101  7e07		       18		      clc
    102  7e08		       65 99		      adc	ManX
    103  7e0a		       20 ae fd 	      jsr	PlotChar
    104  7e0d
    105  7e0d							; -x,-y
    106  7e0d		       a5 9a		      lda	ManY
    107  7e0f		       0a		      asl
    108  7e10		       38		      sec
    109  7e11		       e5 aa		      sbc	circ_y	; "origin"
    110  7e13		       4a		      lsr
    111  7e14		       a8		      tay
    112  7e15		       a5 99		      lda	ManX
    113  7e17		       0a		      asl
    114  7e18		       38		      sec
    115  7e19		       e5 a9		      sbc	circ_x
    116  7e1b		       4a		      lsr
    117  7e1c		       20 ae fd 	      jsr	PlotChar
    118  7e1f
    119  7e1f							; -y,-x
    120  7e1f		       a5 9a		      lda	ManY
    121  7e21		       0a		      asl
    122  7e22		       38		      sec
    123  7e23		       e5 a9		      sbc	circ_x	; "origin"
    124  7e25		       4a		      lsr
    125  7e26		       a8		      tay
    126  7e27		       a5 99		      lda	ManX
    127  7e29		       0a		      asl
    128  7e2a		       38		      sec
    129  7e2b		       e5 aa		      sbc	circ_y
    130  7e2d		       4a		      lsr
    131  7e2e		       20 ae fd 	      jsr	PlotChar
    132  7e31
    133  7e31							; -y,x
    134  7e31		       a5 a9		      lda	circ_x
    135  7e33		       4a		      lsr
    136  7e34		       18		      clc
    137  7e35		       65 9a		      adc	ManY	; "origin"
    138  7e37		       a8		      tay
    139  7e38		       a5 99		      lda	ManX
    140  7e3a		       0a		      asl
    141  7e3b		       38		      sec
    142  7e3c		       e5 aa		      sbc	circ_y
    143  7e3e		       4a		      lsr
    144  7e3f		       20 ae fd 	      jsr	PlotChar
    145  7e42
    146  7e42							; -x,y
    147  7e42		       a5 aa		      lda	circ_y
    148  7e44		       4a		      lsr
    149  7e45		       d8		      cld
    150  7e46		       65 9a		      adc	ManY	; "origin"
    151  7e48		       a8		      tay
    152  7e49		       a5 99		      lda	ManX
    153  7e4b		       0a		      asl
    154  7e4c		       38		      sec
    155  7e4d		       e5 a9		      sbc	circ_x
    156  7e4f		       4a		      lsr
    157  7e50		       20 ae fd 	      jsr	PlotChar
    158  7e53
    159  7e53
    160  7e53		       60		      rts		;6
    161  7e54
    162  7e54
    163  7e54
      0  7e54					      DEFINE_SUBROUTINE	DrawCircle
      1  7e54		       00 0f	   BANK_DrawCircle =	_CURRENT_BANK
      2  7e54					      SUBROUTINE
      3  7e54				   DrawCircle
    165  7e54							; a = radius
    166  7e54							;		    sty circ_char
    167  7e54							;		    sta circ_x
    168  7e54							;		    eor #255
    169  7e54							;		    clc
    170  7e54							;		    adc #1
    171  7e54							;		    sta circ_scratch	 ; "d" --> "1-r" in unit terms
    172  7e54
    173  7e54							;		    lda #0
    174  7e54							;		    sta circ_y
    175  7e54
    176  7e54				   CircleRepeat
    177  7e54
    178  7e54
    179  7e54
    180  7e54		       20 c7 fd 	      jsr	PlotCirclePoints
    181  7e57		       e6 aa		      inc	circ_y
    182  7e59		       a5 ac		      lda	circ_scratch
    183  7e5b		       10 09		      bpl	positiveD
    184  7e5d
    185  7e5d		       a5 aa		      lda	circ_y
    186  7e5f		       0a		      asl
    187  7e60		       38		      sec		; "+1"
    188  7e61		       65 ac		      adc	circ_scratch
    189  7e63		       4c 71 fe 	      jmp	CCont
    190  7e66
    191  7e66		       c6 a9	   positiveD  dec	circ_x
    192  7e68
    193  7e68		       38		      sec
    194  7e69		       a5 aa		      lda	circ_y
    195  7e6b		       e5 a9		      sbc	circ_x
    196  7e6d		       0a		      asl
    197  7e6e		       38		      sec		; "+1"
    198  7e6f		       65 ac		      adc	circ_scratch
    199  7e71
    200  7e71		       85 ac	   CCont      sta	circ_scratch
    201  7e73
    202  7e73		       a5 a9		      lda	circ_x
    203  7e75		       c5 aa		      cmp	circ_y
    204  7e77		       b0 db		      bcs	CircleRepeat	; circleDie
    205  7e79
    206  7e79		       60	   circleDie  rts
------- FILE BANK_FIXED.asm
------- FILE sound/intro1_trackdata.asm LEVEL 3 PASS 3
      0  7e7a					      include	"sound/intro1_trackdata.asm"
      1  7e7a							; TIATracker music player
      2  7e7a							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7e7a							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7e7a							; Email: andre.wichmann@gmx.de
      5  7e7a							;
      6  7e7a							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7e7a							; you may not use this file except in compliance with the License.
      8  7e7a							; You may obtain a copy of the License at
      9  7e7a							;
     10  7e7a							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7e7a							;
     12  7e7a							; Unless required by applicable law or agreed to in writing, software
     13  7e7a							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7e7a							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7e7a							; See the License for the specific language governing permissions and
     16  7e7a							; limitations under the License.
     17  7e7a
     18  7e7a							; Song author: 
     19  7e7a							; Song name: 
     20  7e7a
     21  7e7a							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7e7a
     23  7e7a							; =====================================================================
     24  7e7a							; TIATracker melodic and percussion instruments, patterns and sequencer
     25  7e7a							; data.
     26  7e7a							; =====================================================================
     27  7e7a				   tt_TrackDataStart
     28  7e7a
     29  7e7a							; =====================================================================
     30  7e7a							; Melodic instrument definitions (up to 7). tt_envelope_index_c0/1 hold
     31  7e7a							; the index values into these tables for the current instruments played
     32  7e7a							; in channel 0 and 1.
     33  7e7a							; 
     34  7e7a							; Each instrument is defined by:
     35  7e7a							; - tt_InsCtrlTable: the AUDC value
     36  7e7a							; - tt_InsADIndexes: the index of the start of the ADSR envelope as
     37  7e7a							;	 defined in tt_InsFreqVolTable
     38  7e7a							; - tt_InsSustainIndexes: the index of the start of the Sustain phase
     39  7e7a							;	 of the envelope
     40  7e7a							; - tt_InsReleaseIndexes: the index of the start of the Release phase
     41  7e7a							; - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
     42  7e7a							;	 the envelope
     43  7e7a							; =====================================================================
     44  7e7a
     45  7e7a							; Instrument master CTRL values
     46  7e7a				   tt_InsCtrlTable
     47  7e7a		       07 04 0c 04*	      dc.b	$07, $04, $0c, $04, $0c
     48  7e7f
     49  7e7f
     50  7e7f							; Instrument Attack/Decay start indexes into ADSR tables.
     51  7e7f				   tt_InsADIndexes
     52  7e7f		       00 0e 0e 1e*	      dc.b	$00, $0e, $0e, $1e, $1e
     53  7e84
     54  7e84
     55  7e84							; Instrument Sustain start indexes into ADSR tables
     56  7e84				   tt_InsSustainIndexes
     57  7e84		       08 19 19 2b*	      dc.b	$08, $19, $19, $2b, $2b
     58  7e89
     59  7e89
     60  7e89							; Instrument Release start indexes into ADSR tables
     61  7e89							; Caution: Values are stored with an implicit -1 modifier! To get the
     62  7e89							; real index, add 1.
     63  7e89				   tt_InsReleaseIndexes
     64  7e89		       09 1b 1b 2c*	      dc.b	$09, $1b, $1b, $2c, $2c
     65  7e8e
     66  7e8e
     67  7e8e							; AUDVx and AUDFx ADSR envelope values.
     68  7e8e							; Each byte encodes the frequency and volume:
     69  7e8e							; - Bits 7..4: Freqency modifier for the current note ([-8..7]),
     70  7e8e							;	 8 means no change. Bit 7 is the sign bit.
     71  7e8e							; - Bits 3..0: Volume
     72  7e8e							; Between sustain and release is one byte that is not used and
     73  7e8e							; can be any value.
     74  7e8e							; The end of the release phase is encoded by a 0.
     75  7e8e				   tt_InsFreqVolTable
     76  7e8e							; 0: Pizzicato bassb
     77  7e8e		       8a 8a 89 88*	      dc.b	$8a, $8a, $89, $88, $86, $85, $85, $84
     78  7e96		       83 00 83 83*	      dc.b	$83, $00, $83, $83, $83, $00
     79  7e9c							; 1+2: Square2
     80  7e9c		       8c 8c 8b 89*	      dc.b	$8c, $8c, $8b, $89, $87, $85, $84, $83
     81  7ea4		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $00, $81, $00
     82  7eac							; 3+4: Square
     83  7eac		       85 85 85 85*	      dc.b	$85, $85, $85, $85, $84, $83, $83, $82
     84  7eb4		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $81, $00, $80
     85  7ebc		       00		      dc.b	$00
     86  7ebd
     87  7ebd
     88  7ebd
     89  7ebd							; =====================================================================
     90  7ebd							; Percussion instrument definitions (up to 15)
     91  7ebd							;
     92  7ebd							; Each percussion instrument is defined by:
     93  7ebd							; - tt_PercIndexes: The index of the first percussion frame as defined
     94  7ebd							;	 in tt_PercFreqTable and tt_PercCtrlVolTable
     95  7ebd							; - tt_PercFreqTable: The AUDF frequency value
     96  7ebd							; - tt_PercCtrlVolTable: The AUDV volume and AUDC values
     97  7ebd							; =====================================================================
     98  7ebd
     99  7ebd							; Indexes into percussion definitions signifying the first frame for
    100  7ebd							; each percussion in tt_PercFreqTable.
    101  7ebd							; Caution: Values are stored with an implicit +1 modifier! To get the
    102  7ebd							; real index, subtract 1.
    103  7ebd				   tt_PercIndexes
    104  7ebd		       01 0a 0c 	      dc.b	$01, $0a, $0c
    105  7ec0
    106  7ec0
    107  7ec0							; The AUDF frequency values for the percussion instruments.
    108  7ec0							; If the second to last value is negative (>=128), it means it's an
    109  7ec0							; "overlay" percussion, i.e. the player fetches the next instrument note
    110  7ec0							; immediately and starts it in the sustain phase next frame. (Needs
    111  7ec0							; TT_USE_OVERLAY)
    112  7ec0				   tt_PercFreqTable
    113  7ec0							; 0: Kick
    114  7ec0		       00 01 02 03*	      dc.b	$00, $01, $02, $03, $04, $05, $06, $87
    115  7ec8		       00		      dc.b	$00
    116  7ec9							; 1: HH
    117  7ec9		       80 00		      dc.b	$80, $00
    118  7ecb							; 2: Snare
    119  7ecb		       01 03 06 0e*	      dc.b	$01, $03, $06, $0e, $13, $11, $15, $14
    120  7ed3		       17 1b 00 	      dc.b	$17, $1b, $00
    121  7ed6
    122  7ed6
    123  7ed6							; The AUDCx and AUDVx volume values for the percussion instruments.
    124  7ed6							; - Bits 7..4: AUDC value
    125  7ed6							; - Bits 3..0: AUDV value
    126  7ed6							; 0 means end of percussion data.
    127  7ed6				   tt_PercCtrlVolTable
    128  7ed6							; 0: Kick
    129  7ed6		       ee ed ed eb*	      dc.b	$ee, $ed, $ed, $eb, $e9, $e8, $e8, $e6
    130  7ede		       00		      dc.b	$00
    131  7edf							; 1: HH
    132  7edf		       87 00		      dc.b	$87, $00
    133  7ee1							; 2: Snare
    134  7ee1		       8b 8a 8a 8a*	      dc.b	$8b, $8a, $8a, $8a, $8a, $8a, $89, $88
    135  7ee9		       87 86 00 	      dc.b	$87, $86, $00
    136  7eec
    137  7eec
    138  7eec
    139  7eec							; =====================================================================
    140  7eec							; Track definition
    141  7eec							; The track is defined by:
    142  7eec							; - tt_PatternX (X=0, 1, ...): Pattern definitions
    143  7eec							; - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
    144  7eec							;	 as index values
    145  7eec							; - tt_SequenceTable: The order in which the patterns should be played,
    146  7eec							;	 i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
    147  7eec							;	 for all channels and sub-tracks. The variables
    148  7eec							;	 tt_cur_pat_index_c0/1 hold an index into tt_SequenceTable for
    149  7eec							;	 each channel.
    150  7eec							;
    151  7eec							; So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
    152  7eec							; in turn point to pattern definitions (tt_PatternX) in which the notes
    153  7eec							; to play are specified.
    154  7eec							; =====================================================================
    155  7eec
    156  7eec							; ---------------------------------------------------------------------
    157  7eec							; Pattern definitions, one table per pattern. tt_cur_note_index_c0/1
    158  7eec							; hold the index values into these tables for the current pattern
    159  7eec							; played in channel 0 and 1.
    160  7eec							;
    161  7eec							; A pattern is a sequence of notes (one byte per note) ending with a 0.
    162  7eec							; A note can be either:
    163  7eec							; - Pause: Put melodic instrument into release. Must only follow a
    164  7eec							;	 melodic instrument.
    165  7eec							; - Hold: Continue to play last note (or silence). Default "empty" note.
    166  7eec							; - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
    167  7eec							;	 by -7..+7 and keep playing it
    168  7eec							; - Play new note with melodic instrument
    169  7eec							; - Play new note with percussion instrument
    170  7eec							; - End of pattern
    171  7eec							;
    172  7eec							; A note is defined by:
    173  7eec							; - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
    174  7eec							;	 and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
    175  7eec							;	 defined as:
    176  7eec							;	 - 0: End of pattern
    177  7eec							;	 - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
    178  7eec							;	 - 8: Hold
    179  7eec							;	 - 16: Pause
    180  7eec							;	 - [17..31]: Play percussion instrument 1..15
    181  7eec							;
    182  7eec							; The tracker must ensure that a pause only follows a melodic
    183  7eec							; instrument or a hold/slide.
    184  7eec							; ---------------------------------------------------------------------
    185  7eec		       00 1f	   TT_FREQ_MASK =	%00011111
    186  7eec		       00 08	   TT_INS_HOLD =	8
    187  7eec		       00 10	   TT_INS_PAUSE =	16
    188  7eec		       00 11	   TT_FIRST_PERC =	17
    189  7eec
    190  7eec							; Intro left
    191  7eec				   tt_pattern0
    192  7eec		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $3e, $08
    193  7ef4		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $3e, $08
    194  7efc		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $12, $3e
    195  7f04		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $13, $08
    196  7f0c		       00		      dc.b	$00
    197  7f0d
    198  7f0d							; Intro2 L
    199  7f0d				   tt_pattern1
    200  7f0d		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    201  7f15		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    202  7f1d		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    203  7f25		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    204  7f2d		       00		      dc.b	$00
    205  7f2e
    206  7f2e							; Intro2-fill L
    207  7f2e				   tt_pattern2
    208  7f2e		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    209  7f36		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    210  7f3e		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    211  7f46		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    212  7f4e		       00		      dc.b	$00
    213  7f4f
    214  7f4f							; Intro right
    215  7f4f				   tt_pattern3
    216  7f4f		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $73, $08
    217  7f57		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $73, $08, $73, $08
    218  7f5f		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $b3, $08
    219  7f67		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    220  7f6f		       00		      dc.b	$00
    221  7f70
    222  7f70							; Intro2 R
    223  7f70				   tt_pattern4
    224  7f70		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    225  7f78		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    226  7f80		       b3 08 73 08*	      dc.b	$b3, $08, $73, $08, $b3, $08, $73, $08
    227  7f88		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    228  7f90		       00		      dc.b	$00
    229  7f91
    230  7f91
    231  7f91
    232  7f91
    233  7f91							; Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
    234  7f91							; Each byte encodes the speed of one pattern in the order
    235  7f91							; of the tt_PatternPtr tables below.
    236  7f91							; If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
    237  7f91							; the even speed and the high nibble the odd speed.
    238  7f91				  -	      IF	TT_GLOBAL_SPEED = 0
    239  7f91				  -tt_PatternSpeeds
    240  7f91				  -%%PATTERNSPEEDS%%
    241  7f91					      ENDIF
    242  7f91
    243  7f91
    244  7f91							; ---------------------------------------------------------------------
    245  7f91							; Pattern pointers look-up table.
    246  7f91							; ---------------------------------------------------------------------
    247  7f91				   tt_PatternPtrLo
    248  7f91		       ec 0d 2e 4f	      dc.b	<tt_pattern0, <tt_pattern1, <tt_pattern2, <tt_pattern3
    249  7f95		       70		      dc.b	<tt_pattern4
    250  7f96				   tt_PatternPtrHi
    251  7f96		       fe ff ff ff	      dc.b	>tt_pattern0, >tt_pattern1, >tt_pattern2, >tt_pattern3
    252  7f9a		       ff		      dc.b	>tt_pattern4
    253  7f9b
    254  7f9b
    255  7f9b							; ---------------------------------------------------------------------
    256  7f9b							; Pattern sequence table. Each byte is an index into the
    257  7f9b							; tt_PatternPtrLo/Hi tables where the pointers to the pattern
    258  7f9b							; definitions can be found. When a pattern has been played completely,
    259  7f9b							; the next byte from this table is used to get the address of the next
    260  7f9b							; pattern to play. tt_cur_pat_index_c0/1 hold the current index values
    261  7f9b							; into this table for channels 0 and 1.
    262  7f9b							; If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
    263  7f9b							; number encoded in bits 6..0 (i.e. value AND %01111111).
    264  7f9b							; ---------------------------------------------------------------------
    265  7f9b				   tt_SequenceTable
    266  7f9b							; ---------- Channel 0 ----------
    267  7f9b		       00 00 01 02*	      dc.b	$00, $00, $01, $02, $80
    268  7fa0
    269  7fa0
    270  7fa0							; ---------- Channel 1 ----------
    271  7fa0		       03 04 03 04*	      dc.b	$03, $04, $03, $04, $85
    272  7fa5
    273  7fa5
 Track size:  $12b
    274  7fa5					      echo	"Track size: ", *-tt_TrackDataStart
------- FILE BANK_FIXED.asm
   1199  7fa5
 FREE BYTES IN FIXED BANK =  $56
   1200  7fa5					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1201  7fa5
   1202  7fa5							;---------------------------------------------------------------------------
   1203  7fa5							; The reset vectors
   1204  7fa5							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1205  7fa5
   1206  8000 ????				      SEG	InterruptVectors
   1207  7ffc					      ORG	FIXED_BANK + $7FC
   1208  7ffc					      RORG	$7ffC
   1209  7ffc
   1210  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1211  7ffc		       0d fb		      .word.w	Reset	; RESET
   1212  7ffe		       0d fb		      .word.w	Reset	; IRQ	      (not used)
   1213  8000
   1214  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
   1068  8000
   1069  8000					      END
