------- FILE ./sokoboo.asm LEVEL 1 PASS 4
      1  8000 ????						;    Sokoboo - a Sokoban implementation
      2  8000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  8000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  8000 ????						;
      5  8000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  8000 ????						;
      7  8000 ????						;    Code related to the generic tile-based display engine was developed by
      8  8000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  8000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  8000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  8000 ????						;
     12  8000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  8000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  8000 ????						;    directory for Apache licensing details.
     15  8000 ????						;
     16  8000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  8000 ????						;    See the copyright notices in the License directory for a list of level
     18  8000 ????						;    contributors.
     19  8000 ????						;
     20  8000 ????						;    Except where otherwise indicated, this software is released under the
     21  8000 ????						;    following licensing arrangement...
     22  8000 ????						;
     23  8000 ????						;    This program is free software: you can redistribute it and/or modify
     24  8000 ????						;    it under the terms of the GNU General Public License as published by
     25  8000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  8000 ????						;    (at your option) any later version.
     27  8000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  8000 ????
     29  8000 ????						;    This program is distributed in the hope that it will be useful,
     30  8000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  8000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  8000 ????						;    GNU General Public License for more details.
     33  8000 ????
     34  8000 ????
     35  8000 ????
     36  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     37  8000 ????
     38  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./sokoboo.asm
     41  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	xsegtime
     89  0000 ????			   {1}	      SET	{2}-1
     90  0000 ????			   TEST_{1}   =	1
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????				      MAC	segtime_c
     94  0000 ????			   {1}	      SET	({2}+32)/64 + 1
     95  0000 ????			   TEST_{1}   =	0
     96  0000 ????				      ENDM
     97  0000 ????
     98  0000 ????						;@TJ -- SIMPLY PUT AN X IN FRONT OF THE LINE(S) YOU WANT TO TEST
     99  0000 ????						; eg: XSEGTIME SEGTIME_BOX1,5
    100  0000 ????						; No other action required.  All code enables/disables automatically.
    101  0000 ????
    102  0000 ????						; 2012/02/11 -- experimental reduction in times (but not stress tested)
    103  0000 ????						; due to separation of timeslice overhead to separate check
    104  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_DIRECT, 323 +200	; @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	(323 +200+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_QUICK, 348 +200	; @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_QUICK SET	(348 +200+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_SLOW, 579 +200	; @ 4/8/2019
      1  0000 ????			   SEGTIME_SCD_SLOW SET	(579 +200+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME_C	SEGTIME_SCD_PF0, 88 +100	; @ 4/8/2019 ??
      1  0000 ????			   SEGTIME_SCD_PF0 SET	(88 +100+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_MIN,SEGTIME_SCD_PF0+1	; * MINIMUM TIME OF THE ABOVE + 1
      1  0000 ????			   SEGTIME_SCD_MIN SET	SEGTIME_SCD_PF0+1
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_MIN =	0
    110  0000 ????
    111  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
    112  0000 ????			  -	      SEGTIME	SEGTIME_BDF,42 +4	; * 5/8/11 stress tested DHS->DS
    113  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BDF,35+4	;41			  ; * 7/8/11
      1  0000 ????			   SEGTIME_BDF SET	35+4
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
    115  0000 ????				      ENDIF
    116  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BDS,2 +2	;4			 ; *AD 11/8/11
      1  0000 ????			   SEGTIME_BDS SET	2 +2
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME	SEGTIME_DSL,3 +2	;5			  ; * 9/8/11 unrolled once
      1  0000 ????			   SEGTIME_DSL SET	3 +2
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
    119  0000 ????
      0  0000 ????				      SEGTIME_C	MINIMUM_SORT_TIME, 157 +100	;     157(A)->2.45
      1  0000 ????			   MINIMUM_SORT_TIME SET	(157 +100+32)/64 + 1
      2  0000 ????	       00 00	   TEST_MINIMUM_SORT_TIME =	0
    121  0000 ????
    122  0000 ????
    123  0000 ????						;following will lock-up system if used as 'XSEGTIME'.
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIME,2 +2	;4		    ; processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	2 +2
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
      0  0000 ????				      SEGTIME_C	MINIMUM_SEGTIMEBLANK, 993 +200	; * 7/8/11	 993(A)->15.5
      1  0000 ????			   MINIMUM_SEGTIMEBLANK SET	(993 +200+32)/64 + 1
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIMEBLANK =	0
      0  0000 ????				      SEGTIME	SEGTIME_MINIMUM_TIMESLICE,MINIMUM_SEGTIME+1	; MINIMUM of the TIMESLICE segments listed above
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	MINIMUM_SEGTIME+1
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    127  0000 ????
    128  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    129  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    130  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    131  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    132  0000 ????						; uses ...
    133  0000 ????
    134  0000 ????
    135  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    136  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    137  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    138  0000 ????
    139  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    140  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    141  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,24	;<< using this as XSEGTIME stops player working ...?!
      1  0000 ????			   SEGTIME_MAN SET	24
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE, 10	; drawing circle creature
      1  0000 ????			   SEGTIME_CIRCLE SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE_HELPER, 10	; drawing circle creature's helper
      1  0000 ????			   SEGTIME_CIRCLE_HELPER SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE_HELPER =	0
    145  0000 ????
    146  0000 ????						; TJ: I should only prevent processes with an extra check (e.g. get TARGET)
    147  0000 ????
    148  0000 ????						; push BOX is slowest (besides get TARGET which has an extra timer check)
    149  0000 ????						; if we add another check for it, SEGTIME_MAN reduces by ~5
    150  0000 ????
      0  0000 ????				      SEGTIME_C	SEGTIME_SWITCHOBJECTS,74	; 16/8/11 by calculation. 72 cycles -->  ceil(72/64)+1 --> 3 Object stack switchover
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	(74+32)/64 + 1
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
------- FILE ./sokoboo.asm
     43  0000 ????
     44  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     45  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     46  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     47  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     48  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     49  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     50  0000 ????
     51  0000 ????	       00 01	   YES	      =	1
     52  0000 ????	       00 00	   NO	      =	0
     53  0000 ????
     54  0000 ????	       00 00	   DEBUG      =	NO
     55  0000 ????
     56  0000 ????	       00 00	   TJ_MODE    =	NO	; some changes which TJ prefers
     57  0000 ????	       00 01	   AD_MODE    =	YES	; some changes which AD prefers
     58  0000 ????
     59  0000 ????			  -	      IF	TJ_MODE && AD_MODE
     60  0000 ????			  -	      ECHO	"ERROR: Both TJ_MODE and AD_MODE set. Can't do both TJ and AD at the same time!"
     61  0000 ????			  -	      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????
     65  0000 ????						; Note: you may also need to change the emulator "-format" switch in the Makefile.
     66  0000 ????
     67  0000 ????
     68  0000 ????						;===================================
     69  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     70  0000 ????						;===================================
     71  0000 ????
     72  0000 ????						;-------------------------------------------------------------------------------
     73  0000 ????						; The following should be YES for the final or DEMO version
     74  0000 ????			   EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
     75  0000 ????
     76  0000 ????						;-------------------------------------------------------------------------------
     77  0000 ????						; The following are optional YES/NO depending on phase of the moon
     78  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????
     81  0000 ????	       00 01	   NUMPLAYERS =	1	; 1-indexed
     82  0000 ????	       00 05	   NUM_LEVELS =	5
     83  0000 ????			   NUM_LIVES  SET	3	; use -1 for unlimited lives
     84  0000 ????
     85  0000 ????						;-------------------------------------------------------------------------------
     86  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     87  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     88  0000 ????			  -	      IF	FINAL_VERSION = YES
     89  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     90  0000 ????			  -
     91  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
     92  0000 ????				      ENDIF
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????
     96  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     97  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
     98  0000 ????
     99  0000 ????
    100  0000 ????	       00 01	   PUSH_LIMIT =	1	; slowdown when pushing on a BOX
    101  0000 ????
    102  0000 ????						; time bonus countdown constants:
    103  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
    104  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
    105  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
    106  0000 ????
    107  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    108  0000 ????
    109  0000 ????	       00 03	   FACE_LEFT  =	3
    110  0000 ????
    111  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
    112  0000 ????
    113  0000 ????						;scoring flags contants:
    114  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
    115  0000 ????	       00 00	   DISPLAY_TIME =	%00
    116  0000 ????	       00 01	   DISPLAY_SCORE =	%01
    117  0000 ????	       00 02	   DISPLAY_LIVES =	%10
    118  0000 ????	       00 03	   DISPLAY_HIGH =	%11
    119  0000 ????
    120  0000 ????						;------------------------------------------------------------------------------
    121  0000 ????
    122  0000 ????	       00 01	   MIRRORED_BOX =	YES
    123  0000 ????	       00 01	   MIRRORED_STEEL =	YES
    124  0000 ????	       00 01	   MIRRORED_WALL =	YES
    125  0000 ????
    126  0000 ????	       00 00	   TROPHY     =	NO
    127  0000 ????	       00 00	   DIGITS     =	NO
    128  0000 ????
    129  0000 ????						;------------------------------------------------------------------------------
    130  0000 ????
    131  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    132  0000 ????
    133  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    134  0000 ????	       00 18	   LINES_PER_CHAR =	24	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    135  0000 ????
    136  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    137  0000 ????
    138  0000 ????
    139  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    140  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    141  0000 ????
    142  0000 ????
    143  0000 ????						; color constants:
    144  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    145  0000 ????
    146  0000 ????	       00 10	   YELLOW_NTSC =	$10
    147  0000 ????	       00 20	   YELLOW_PAL =	$20
    148  0000 ????
    149  0000 ????
    150  0000 ????	       10 00	   RAM_3E     =	$1000
    151  0000 ????	       04 00	   RAM_SIZE   =	$400
    152  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    153  0000 ????
    154  0000 ????
    155  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    156  0000 ????
    157  0000 ????
    158  0000 ????						; Platform constants:
    159  0000 ????	       00 02	   PAL	      =	%10
    160  0000 ????	       00 02	   PAL_50     =	PAL|0
    161  0000 ????	       00 03	   PAL_60     =	PAL|1
    162  0000 ????
    163  0000 ????
    164  0000 ????				      IF	L276
    165  0000 ????	       00 32	   VBLANK_TIM_NTSC =	50	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    166  0000 ????			  -	      ELSE
    167  0000 ????			  -VBLANK_TIM_NTSC =	50	; NTSC 262
    168  0000 ????				      ENDIF
    169  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	;85			    ; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    170  0000 ????
    171  0000 ????				      IF	L276
    172  0000 ????	       00 22	   OVERSCAN_TIM_NTSC =	34	;24 ;51			; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    173  0000 ????			  -	      ELSE
    174  0000 ????			  -OVERSCAN_TIM_NTSC =	8	;51			    ; NTSC 262
    175  0000 ????				      ENDIF
    176  0000 ????	       00 29	   OVERSCAN_TIM_PAL =	41	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    177  0000 ????
    178  0000 ????				      IF	L276
    179  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    180  0000 ????			  -	      ELSE
    181  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    182  0000 ????				      ENDIF
    183  0000 ????	       01 38	   SCANLINES_PAL =	312
    184  0000 ????
    185  0000 ????
    186  0000 ????						;------------------------------------------------------------------------------
    187  0000 ????						; MACRO definitions
    188  0000 ????
    189  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    190  0000 ????
    191  0000 ????				      MAC	newbank
    192  0000 ????				      SEG	{1}
    193  0000 ????				      ORG	ORIGIN
    194  0000 ????				      RORG	$F000
    195  0000 ????			   BANK_START SET	*
    196  0000 ????			   {1}	      SET	ORIGIN / 2048
    197  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    198  0000 ????			   _CURRENT_BANK SET	{1}
    199  0000 ????				      ENDM		; bank name
    200  0000 ????
    201  0000 ????				      MAC	define_1k_segment
    202  0000 ????				      ALIGN	$400
    203  0000 ????			   SEGMENT_{1} SET	*
    204  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    205  0000 ????				      ENDM		; {seg name}
    206  0000 ????
    207  0000 ????				      MAC	check_bank_size
    208  0000 ????			   .TEMP      =	* - BANK_START
    209  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    210  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    211  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    212  0000 ????				      ERR
    213  0000 ????				      endif
    214  0000 ????				      ENDM		; name
    215  0000 ????
    216  0000 ????
    217  0000 ????				      MAC	check_half_bank_size
    218  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    219  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    220  0000 ????			   .TEMP      =	* - BANK_START
    221  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    222  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    223  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    224  0000 ????				      ERR
    225  0000 ????				      endif
    226  0000 ????				      ENDM		; name
    227  0000 ????
    228  0000 ????
    229  0000 ????				      MAC	overlay
    230  0000 ????				      SEG.U	OVERLAY_{1}
    231  0000 ????				      org	Overlay
    232  0000 ????				      ENDM		; {name}
    233  0000 ????
    234  0000 ????						;--------------------------------------------------------------------------
    235  0000 ????
    236  0000 ????				      MAC	validate_overlay
    237  0000 ????				      LIST	OFF
    238  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    239  0000 ????				      ERR
    240  0000 ????				      endif
    241  0000 ????				      LIST	ON
    242  0000 ????				      ENDM
    243  0000 ????
    244  0000 ????						;--------------------------------------------------------------------------
    245  0000 ????						; Macro inserts a page break if the object would overlap a page
    246  0000 ????
    247  0000 ????				      MAC	optional_pagebreak
    248  0000 ????				      LIST	OFF
    249  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    250  0000 ????			   EARLY_LOCATION SET	*
    251  0000 ????				      ALIGN	256
    252  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    253  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    254  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    255  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    256  0000 ????				      ENDIF
    257  0000 ????				      LIST	ON
    258  0000 ????				      ENDM		; { string, size }
    259  0000 ????
    260  0000 ????
    261  0000 ????				      MAC	check_page_crossing
    262  0000 ????				      LIST	OFF
    263  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    264  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    265  0000 ????				      endif
    266  0000 ????				      LIST	ON
    267  0000 ????				      ENDM
    268  0000 ????
    269  0000 ????				      MAC	checkpage
    270  0000 ????				      LIST	OFF
    271  0000 ????				      IF	>. != >{1}
    272  0000 ????				      ECHO	""
    273  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    274  0000 ????				      ECHO	""
    275  0000 ????				      ERR
    276  0000 ????				      ENDIF
    277  0000 ????				      LIST	ON
    278  0000 ????				      ENDM
    279  0000 ????
    280  0000 ????				      MAC	checkpagex
    281  0000 ????				      LIST	OFF
    282  0000 ????				      IF	>. != >{1}
    283  0000 ????				      ECHO	""
    284  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    285  0000 ????				      ECHO	{2}
    286  0000 ????				      ECHO	""
    287  0000 ????				      ERR
    288  0000 ????				      ENDIF
    289  0000 ????				      LIST	ON
    290  0000 ????				      ENDM
    291  0000 ????
    292  0000 ????
    293  0000 ????				      MAC	checkpage_bne
    294  0000 ????				      LIST	OFF
    295  0000 ????				      IF	0	;>(. + 2) != >{1}
    296  0000 ????				      ECHO	""
    297  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    298  0000 ????				      ECHO	""
    299  0000 ????				      ERR
    300  0000 ????				      ENDIF
    301  0000 ????				      LIST	ON
    302  0000 ????				      bne	{1}
    303  0000 ????				      ENDM
    304  0000 ????
    305  0000 ????				      MAC	checkpage_bpl
    306  0000 ????				      LIST	OFF
    307  0000 ????				      IF	(>(.+2 )) != >{1}
    308  0000 ????				      ECHO	""
    309  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    310  0000 ????				      ECHO	""
    311  0000 ????				      ERR
    312  0000 ????				      ENDIF
    313  0000 ????				      LIST	ON
    314  0000 ????				      bpl	{1}
    315  0000 ????				      ENDM
    316  0000 ????
    317  0000 ????				      MAC	align_free
    318  0000 ????			   FREE       SET	FREE - .
    319  0000 ????				      align	{1}
    320  0000 ????			   FREE       SET	FREE + .
    321  0000 ????				      echo	"@", ., ":", FREE
    322  0000 ????				      ENDM
    323  0000 ????
    324  0000 ????				      MAC	stress_time
    325  0000 ????				      IF	TEST_{1} = 1
    326  0000 ????
    327  0000 ????
    328  0000 ????						;LIST OFF
    329  0000 ????						; has to be put *directly* after cmp #SEGTIME_... , bcc abort
    330  0000 ????						;LIST ON
    331  0000 ????				      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
    332  0000 ????				      bne	. - 7	; branches to lda INTIM
    333  0000 ????				      ENDIF
    334  0000 ????				      ENDM
    335  0000 ????
    336  0000 ????			   IDENTITY   SET	0
    337  0000 ????				      MAC	ident
    338  0000 ????				      if	DEBUG=YES
    339  0000 ????				      lda	#IDENTITY
    340  0000 ????				      sta	debug_ident
    341  0000 ????				      lda	{1}
    342  0000 ????				      sta	debug_object
    343  0000 ????				      endif
    344  0000 ????			   IDENTITY   SET	IDENTITY + 1
    345  0000 ????				      ENDM		; {object}
    346  0000 ????
    347  0000 ????						;--------------------------------------------------------------------------
    348  0000 ????
    349  0000 ????				      MAC	vector
    350  0000 ????				      .word	{1}
    351  0000 ????				      ENDM		; just a word pointer to code
    352  0000 ????
    353  0000 ????
    354  0000 ????				      MAC	define_subroutine
    355  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    356  0000 ????				      SUBROUTINE		; keep everything local
    357  0000 ????			   {1}			; entry point
    358  0000 ????				      ENDM		; name of subroutine
    359  0000 ????
    360  0000 ????
    361  0000 ????
    362  0000 ????						;--------------------------------------------------------------------------
    363  0000 ????
    364  0000 ????				      MAC	newrambank
    365  0000 ????				      SEG.U	{1}
    366  0000 ????				      ORG	ORIGIN
    367  0000 ????				      RORG	RAM_3E
    368  0000 ????			   BANK_START SET	*
    369  0000 ????			   {1}	      SET	ORIGIN / RAM_SIZE
    370  0000 ????			   ORIGIN     SET	ORIGIN + RAM_SIZE
    371  0000 ????				      ENDM		; bank name
    372  0000 ????
    373  0000 ????				      MAC	validate_ram_size
    374  0000 ????				      if	* - RAM_3E > RAM_SIZE
    375  0000 ????				      ERR
    376  0000 ????				      endif
    377  0000 ????				      ENDM
    378  0000 ????
    379  0000 ????				      MAC	next_random
    380  0000 ????						; update random value:
    381  0000 ????				      lda	rnd	; 3
    382  0000 ????				      lsr		; 2
    383  0000 ????				      IFCONST	rndHi
    384  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    385  0000 ????				      ENDIF
    386  0000 ????				      bcc	.skipEOR	; 2/3
    387  0000 ????				      eor	#RND_EOR_VAL	; 2
    388  0000 ????			   .skipEOR
    389  0000 ????				      sta	rnd	; 3 = 14/19
    390  0000 ????				      ENDM
    391  0000 ????
    392  0000 ????				      MAC	resync
    393  0000 ????						; resync screen, X and Y == 0 afterwards
    394  0000 ????				      lda	#%10	; make sure VBLANK is ON
    395  0000 ????				      sta	VBLANK
    396  0000 ????
    397  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    398  0000 ????			   .loopResync
    399  0000 ????				      VERTICAL_SYNC
    400  0000 ????
    401  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    402  0000 ????				      lda	Platform
    403  0000 ????				      eor	#PAL_50	; PAL-50?
    404  0000 ????				      bne	.ntsc
    405  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    406  0000 ????			   .ntsc
    407  0000 ????			   .loopWait
    408  0000 ????				      sta	WSYNC
    409  0000 ????				      sta	WSYNC
    410  0000 ????				      dey
    411  0000 ????				      bne	.loopWait
    412  0000 ????				      dex
    413  0000 ????				      bne	.loopResync
    414  0000 ????				      ENDM
    415  0000 ????
    416  0000 ????				      MAC	set_platform
    417  0000 ????						; 00 = NTSC
    418  0000 ????						; 01 = NTSC
    419  0000 ????						; 10 = PAL-50
    420  0000 ????						; 11 = PAL-60
    421  0000 ????				      lda	SWCHB
    422  0000 ????				      rol
    423  0000 ????				      rol
    424  0000 ????				      rol
    425  0000 ????				      and	#%11
    426  0000 ????				      eor	#PAL
    427  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    428  0000 ????				      ENDM
    429  0000 ????
    430  0000 ????						;  IF TJ_MODE
    431  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM ; = 29
    432  0000 ????						;	  ldy #{1}			  ; 2	  read bank
    433  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    434  0000 ????						;	  jsr GetRAMByteFromRAM 	  ;25
    435  0000 ????						;    ENDM
    436  0000 ????						;
    437  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM ; = 30
    438  0000 ????						;	  ldy #{1}			  ; 2	  write bank
    439  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    440  0000 ????						;	  jsr PutRAMByteFromRAM 	  ;26
    441  0000 ????						;    ENDM
    442  0000 ????						;
    443  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM_ADR ; = 39
    444  0000 ????						;	  ldx #<{1}			  ; 2
    445  0000 ????						;	  stx addressR			  ; 3
    446  0000 ????						;	  ldx #>{1}			  ; 2
    447  0000 ????						;	  stx addressR+1		  ; 3
    448  0000 ????						;	  GET_RAM_BYTE_FROM_RAM {2}, {3}  ;29
    449  0000 ????						;    ENDM
    450  0000 ????						;
    451  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM_ADR ; = 40
    452  0000 ????						;	  ldx #<{1}			  ; 2
    453  0000 ????						;	  stx addressW			  ; 3
    454  0000 ????						;	  ldx #>({1}+RAM_WRITE) 	  ; 2
    455  0000 ????						;	  stx addressW+1		  ; 3
    456  0000 ????						;	  PUT_RAM_BYTE_FROM_RAM {2}, {3}  ;30
    457  0000 ????						;    ENDM
    458  0000 ????						;  ENDIF
    459  0000 ????
    460  0000 ????				      MAC	nop_b
    461  0000 ????				      .byte	$82
    462  0000 ????				      ENDM		; unused
    463  0000 ????
    464  0000 ????				      MAC	nop_w
    465  0000 ????				      .byte	$0c
    466  0000 ????				      ENDM
    467  0000 ????
    468  0000 ????						;------------------------------------------------------------------------------
    469  0000 ????
    470  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34 U00f8 ????				      SEG.U	variables
     35 U0080					      ORG	$80
     36 U0080
     37 U0080
     38 U0080		       00 40	   GAMEMODE_2600 =	64
     39 U0080		       00 80	   GAMEMODE_PAUSED =	128
     40 U0080
     41 U0080		       00	   gameMode   ds	1	; bit7=0: 7800; bit7=1: 2600.	bit 6=1: paused: bit3: toggle bit for B/W
     42 U0081		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U0082							; above variables are preserved ALL the time!
     44 U0082
     45 U0082		       00	   rnd	      ds	1
     46 U0083		       00	   rndHi      ds	1	; to get better random values
     47 U0084
     48 U0084		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     49 U0085		       00	   ObjStackNum ds	1	; which stack in use
     50 U0086		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     51 U0088		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     52 U0089		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     53 U008a
     54 U008a		       00	   POS_X      ds	1
     55 U008b		       00	   POS_Y      ds	1
     56 U008c		       00	   POS_X_NEW  ds	1
     57 U008d		       00	   POS_Y_NEW  ds	1
     58 U008e		       00	   POS_Type   ds	1
     59 U008f		       00	   POS_VAR    ds	1
     60 U0090
     61 U0090		       00 00	   BufferedJoystick ds	2	; player joystick input
     62 U0092		       00 00	   BufferedButton ds	2	; player button press
     63 U0094
     64 U0094							; Scrolling is limited to only show board within the following area...
     65 U0094		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in UnpackLevel)
     66 U0095		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in UnpackLevel)
     67 U0096		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     68 U0097		       00	   BoardScrollX ds	1	; scroll position in board (X)
     69 U0097		       00 94	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     70 U0097		       00 95	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     71 U0098		       00	   scrollBits ds	1
     72 U0099
     73 U0099		       00	   whichPlayer ds	1	; 0 = P1, 1 = P2
     74 U009a		       00	   manAnimationIndex ds	1
     75 U009b		       00	   ManX       ds	1
     76 U009c		       00	   ManY       ds	1
     77 U009d		       00	   ManDrawX   ds	1
     78 U009e		       00	   ManDrawY   ds	1
     79 U009f		       00	   ManMode    ds	1
     80 U00a0		       00	   ManDelayCount ds	1
     81 U00a1		       00 00	   ManAnimation ds	2
     82 U00a3		       00	   ManAnimationFrameLO ds	1
     83 U00a4		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     84 U00a5		       00	   ManPushCounter ds	1
     85 U00a6		       00	   LookingAround ds	1
     86 U00a7		       00	   ManCount   ds	1	; player life counter
     87 U00a8		       00	   DelayEndOfLevel ds	1
     88 U00a9		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     89 U00aa		       00 00	   circle_d   ds	2
     90 U00ac		       00	   circ_x     ds	1
     91 U00ad		       00	   circ_y     ds	1
     92 U00ae		       00	   circ_char  ds	1
     93 U00af		       00	   circ_scratch ds	1
     94 U00b0		       00	   LEVEL_bank ds	1
     95 U00b1		       00 00	   levelPtr   ds	2
     96 U00b3							;---------------------------------------------------------------------------
     97 U00b3							; 2 (shared) demo mode variables:
     98 U00b3		       00 a9	   demoMode   =	jtoggle	; bit 7==1 => demo mode
     99 U00b3		       00 a9	   moveLen    =	jtoggle	; bits 0..6
    100 U00b3		       00 99	   moveIdx    =	whichPlayer
    101 U00b3
    102 U00b3		       00	   LastSpriteY ds	1
    103 U00b4
    104 U00b4		       00	   timer      ds	1
    105 U00b5
    106 U00b5		       00	   BGColour   ds	1
    107 U00b6
    108 U00b6							; levelx and level have to be consecutive variables!
    109 U00b6		       00	   levelX     ds	1	; current player's level (other in scoring bank)
    110 U00b7		       00	   level      ds	1	; current player's level (other in scoring bank)
    111 U00b8		       00	   levelDisplay ds	1	; what to display as the level ID
    112 U00b9		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
    113 U00ba		       00	   ThrottleSpeed ds	1	; system-dependant throttle speed
    114 U00bb
    115 U00bb		       00	   targetsRequired ds	1	; number of un-targeted left to go
    116 U00bc		       00	   moveCounter ds	1	; BCD seconds for level
    117 U00bd		       00	   moveCounterHi ds	1
    118 U00be		       00	   moveCounterBinary ds	1
    119 U00bf		       00 00 00    color      ds	3	; RGB for NTSC, RGB for PAL
    120 U00c2		       00 00	   Board_AddressR ds	2
    121 U00c4		       00 00	   Board_AddressW ds	2
    122 U00c6		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
    123 U00c7		       00	   RAM_Bank   ds	1
    124 U00c8
    125 U00c8		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
    126 U00c9		       00	   extraLifeTimer ds	1	; should be 5 seconds!
    127 U00ca
    128 U00ca							; extraLifeTimer:
    129 U00ca							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    130 U00ca
    131 U00ca		       00	   scoringTimer ds	1	; times the various score displays
    132 U00cb		       00	   scoringFlags ds	1	; scoring flags are stored here
    133 U00cc
    134 U00cc							; scoringFlags:
    135 U00cc							; D7		 Extra TARGETs in effect (TARGETs collected over requirement score more) ASSUMED BPL/BMI usage
    136 U00cc							; D6		 unused
    137 U00cc							; D5		 unused
    138 U00cc							; D4		 unused
    139 U00cc							; D3		 unused
    140 U00cc							; D2		 unused
    141 U00cc							; D1	 D1-D0	 Which display kernel to use for scoring
    142 U00cc							; D0		 0 = 2x4     used for TARGETs/time
    143 U00cc							;		 1 = 1x6     used for score
    144 U00cc							;		 2 = 3x2     used for level/lives/player
    145 U00cc
    146 U00cc		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    147 U00cc		       00 80	   BIT_NEXTLEVEL =	128
    148 U00cc		       00 40	   BIT_NEXTLIFE =	64
    149 U00cd
    150 U00cd							;---------------------------------------------------------------------------
    151 U00cd
    152 U00cd		       00	   sortRequired ds	1
    153 U00ce		       00	   sortPtr    ds	1
    154 U00cf
    155 U00cf							;------------------------------------------------------------------------------
    156 U00cf
    157 U00cf		       00	   ObjIterator ds	1	; count UP iterator over objects
    158 U00d0		       00	   DSL	      ds	1	; stack line counter
    159 U00d1
------- FILE sound/intro1_variables.asm LEVEL 3 PASS 4
      0 U00d1					      include	"sound/intro1_variables.asm"
      1 U00d1							; TIATracker music player
      2 U00d1							; Copyright 2016 Andre "Kylearan" Wichmann
      3 U00d1							; Website: https://bitbucket.org/kylearan/tiatracker
      4 U00d1							; Email: andre.wichmann@gmx.de
      5 U00d1							;
      6 U00d1							; Licensed under the Apache License, Version 2.0 (the "License");
      7 U00d1							; you may not use this file except in compliance with the License.
      8 U00d1							; You may obtain a copy of the License at
      9 U00d1							;
     10 U00d1							;   http://www.apache.org/licenses/LICENSE-2.0
     11 U00d1							;
     12 U00d1							; Unless required by applicable law or agreed to in writing, software
     13 U00d1							; distributed under the License is distributed on an "AS IS" BASIS,
     14 U00d1							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15 U00d1							; See the License for the specific language governing permissions and
     16 U00d1							; limitations under the License.
     17 U00d1
     18 U00d1							; Song author: 
     19 U00d1							; Song name: 
     20 U00d1
     21 U00d1							; @com.wudsn.ide.asm.hardware=ATARI2600
     22 U00d1
     23 U00d1							; =====================================================================
     24 U00d1							; Flags
     25 U00d1							; =====================================================================
     26 U00d1
     27 U00d1							; 1: Global song speed, 0: Each pattern has individual speed
     28 U00d1		       00 01	   TT_GLOBAL_SPEED =	1
     29 U00d1							; duration (number of TV frames) of a note
     30 U00d1		       00 05	   TT_SPEED   =	5
     31 U00d1							; duration of odd frames (needs TT_USE_FUNKTEMPO)
     32 U00d1		       00 04	   TT_ODD_SPEED =	4
     33 U00d1
     34 U00d1							; 1: Overlay percussion, +40 bytes
     35 U00d1		       00 01	   TT_USE_OVERLAY =	1
     36 U00d1							; 1: Melodic instrument slide, +9 bytes
     37 U00d1		       00 00	   TT_USE_SLIDE =	0
     38 U00d1							; 1: Goto pattern, +8 bytes
     39 U00d1		       00 01	   TT_USE_GOTO =	1
     40 U00d1							; 1: Odd/even rows have different SPEED values, +7 bytes
     41 U00d1		       00 01	   TT_USE_FUNKTEMPO =	1
     42 U00d1							; If the very first notes played on each channel are not PAUSE, HOLD or
     43 U00d1							; SLIDE, i.e. if they start with an instrument or percussion, then set
     44 U00d1							; this flag to 0 to save 2 bytes.
     45 U00d1							; 0: +2 bytes
     46 U00d1		       00 01	   TT_STARTS_WITH_NOTES =	1
     47 U00d1
     48 U00d1
     49 U00d1							; =====================================================================
     50 U00d1							; Permanent variables. These are states needed by the player.
     51 U00d1							; =====================================================================
     52 U00d1		       00	   tt_timer   ds	1	; current music timer value
     53 U00d2		       00	   tt_cur_pat_index_c0 ds	1	; current pattern index into tt_SequenceTable
     54 U00d3		       00	   tt_cur_pat_index_c1 ds	1
     55 U00d4		       00	   tt_cur_note_index_c0 ds	1	; note index into current pattern
     56 U00d5		       00	   tt_cur_note_index_c1 ds	1
     57 U00d6		       00	   tt_envelope_index_c0 ds	1	; index into ADSR envelope
     58 U00d7		       00	   tt_envelope_index_c1 ds	1
     59 U00d8		       00	   tt_cur_ins_c0 ds	1	; current instrument
     60 U00d9		       00	   tt_cur_ins_c1 ds	1
     61 U00da
     62 U00da
     63 U00da							; =====================================================================
     64 U00da							; Temporary variables. These will be overwritten during a call to the
     65 U00da							; player routine, but can be used between calls for other things.
     66 U00da							; =====================================================================
     67 U00da		       00 00	   tt_ptr     ds	2
------- FILE zeropage.asm
    161 U00dc
    162 U00dc
    163 U00dc
    164 U00dc				   OVERLAY_SIZE SET	16
    165 U00dc
    166 U00dc
    167 U00dc
    168 U00dc							; This overlay variable is used for the overlay variables.  That's OK.
    169 U00dc							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    170 U00dc							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    171 U00dc							; (especially the latter ones) are only used in rare occasions.
    172 U00dc
    173 U00dc							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    174 U00dc							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    175 U00dc
    176 U00dc		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00ec					      VALIDATE_OVERLAY
      5 U00ec					      LIST	ON
    178 U00ec
    179 U00ec
    180 U00ec		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    181 U00f8
 FREE BYTES IN ZERO PAGE =  $7
    182 U00f8					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    183 U00f8				  -	      IF	* > $FF
    184 U00f8				  -	      ERR
    185 U00f8					      ENDIF
------- FILE ./sokoboo.asm
    472 U00f8
    473 U00f8
    474 U00f8							;------------------------------------------------------------------------------
    475 U00f8							; OVERLAYS!
    476 U00f8							; These variables are overlays, and should be managed with care
    477 U00f8							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    478 U00f8
    479 U00f8							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    480 U00f8							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    481 U00f8
    482 U00f8							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    483 U00f8
    484 U00f8
    485 U00f8
    486 U00f8							;------------------------------------------------------------------------------
      0 U00f8					      OVERLAY	BuildDrawFlags
      1 U00e7 ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00dc					      org	Overlay
    488 U00dc
    489 U00dc		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    490 U00de		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    491 U00e0		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    492 U00e2		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    493 U00e4							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    494 U00e4		       00	   BDF_BoardBank ds	1	; holds bank of current line
    495 U00e5							;  ENDIF
    496 U00e5		       00	   DHS_Line   ds	1
    497 U00e6		       00	   DHS_Stack  ds	1	; for restoring SP
    498 U00e7							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e7					      VALIDATE_OVERLAY
      5 U00e7					      LIST	ON
    500 U00e7
    501 U00e7							;------------------------------------------------------------------------------
    502 U00e7
      0 U00e7					      OVERLAY	Process
      1 U00df ????				      SEG.U	OVERLAY_Process
      2 U00dc					      org	Overlay
    504 U00dc
    505 U00dc		       00	   BOXLeft    ds	1
    506 U00dd		       00	   BOXRight   ds	1
    507 U00de		       00	   restorationCharacter ds	1
    508 U00df
      0 U00df					      VALIDATE_OVERLAY
      5 U00df					      LIST	ON
    510 U00df
    511 U00df							;------------------------------------------------------------------------------
    512 U00df
      0 U00df					      OVERLAY	Animate
      1 U00dd ????				      SEG.U	OVERLAY_Animate
      2 U00dc					      org	Overlay
    514 U00dc		       00	   halftimer  ds	1
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    516 U00dd
    517 U00dd							;------------------------------------------------------------------------------
    518 U00dd
      0 U00dd					      OVERLAY	TitleScreen
      1 U00de ????				      SEG.U	OVERLAY_TitleScreen
      2 U00dc					      org	Overlay
    520 U00dc		       00 00	   colour_table ds	2
      0 U00de					      VALIDATE_OVERLAY
      5 U00de					      LIST	ON
    522 U00de
    523 U00de							;------------------------------------------------------------------------------
    524 U00de
      0 U00de					      OVERLAY	TimeSlice
      1 U00de ????				      SEG.U	OVERLAY_TimeSlice
      2 U00dc					      org	Overlay
    526 U00dc
    527 U00dc		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    528 U00de							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00de					      VALIDATE_OVERLAY
      5 U00de					      LIST	ON
    530 U00de
    531 U00de							;------------------------------------------------------------------------------
    532 U00de
      0 U00de					      OVERLAY	CopyROMShadowToRAM
      1 U00df ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00dc					      org	Overlay
    534 U00dc
    535 U00dc		       00	   O_CopyCount ds	1
    536 U00dd		       00	   O_ROM_Source_Bank ds	1
    537 U00de		       00	   O_Index    ds	1
    538 U00df							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00df					      VALIDATE_OVERLAY
      5 U00df					      LIST	ON
    540 U00df
    541 U00df							;------------------------------------------------------------------------------
    542 U00df
      0 U00df					      OVERLAY	Scoring
      1 U00dd ????				      SEG.U	OVERLAY_Scoring
      2 U00dc					      org	Overlay
    544 U00dc		       00	   tmpStack   ds	1
    545 U00dc		       00 dc	   newDisplay =	tmpStack
    546 U00dd							; also for UpdateTimer
    547 U00dd		       00 dc	   tmpSound   =	tmpStack
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    549 U00dd
    550 U00dd
    551 U00dd							;------------------------------------------------------------------------------
    552 U00dd
      0 U00dd					      OVERLAY	SaveKey
      1 U00e5 ????				      SEG.U	OVERLAY_SaveKey
      2 U00dc					      org	Overlay
    554 U00dc
    555 U00dc		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    556 U00df		       00 00 00    highScoreSK ds	3
    557 U00e2		       00	   startingLevel ds	1	; levelx * 5
    558 U00e3		       00	   startLevel ds	1
    559 U00e4		       00	   offsetSK   ds	1	; for calculating the SK slot address
    560 U00e5
      0 U00e5					      VALIDATE_OVERLAY
      5 U00e5					      LIST	ON
    562 U00e5
    563 U00e5							;------------------------------------------------------------------------------
    564 U00e5
      0 U00e5					      OVERLAY	DrawMan
      1 U00de ????				      SEG.U	OVERLAY_DrawMan
      2 U00dc					      org	Overlay
    566 U00dc
    567 U00dc		       00 00	   MAN_Move   ds	2
    568 U00de
    569 U00de							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00de					      VALIDATE_OVERLAY
      5 U00de					      LIST	ON
    571 U00de
    572 U00de							;------------------------------------------------------------------------------
    573 U00de
      0 U00de					      OVERLAY	ProcessObjStack
      1 U00de ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00dc					      org	Overlay
    575 U00dc
    576 U00dc		       00 00	   POS_Vector ds	2
    577 U00de
    578 U00de							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00de					      VALIDATE_OVERLAY
      5 U00de					      LIST	ON
    580 U00de
    581 U00de							;------------------------------------------------------------------------------
    582 U00de
      0 U00de					      OVERLAY	ScoreLineOverlay
      1 U00eb ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00dc					      org	Overlay
    584 U00dc
    585 U00dc		       00 00	   S0	      ds	2	; used for addressing digits of score
    586 U00de		       00 00	   S1	      ds	2
    587 U00e0		       00 00	   S2	      ds	2
    588 U00e2		       00 00	   S3	      ds	2
    589 U00e4		       00 00	   S4	      ds	2
    590 U00e6		       00 00	   S5	      ds	2
    591 U00e8
    592 U00e8		       00	   stkp       ds	1
    593 U00e9		       00	   sreg       ds	1
    594 U00ea		       00	   loop       ds	1
    595 U00eb
    596 U00eb							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00eb					      VALIDATE_OVERLAY
      5 U00eb					      LIST	ON
    598 U00eb
    599 U00eb							;------------------------------------------------------------------------------
    600 U00eb
    601 U00eb
      0 U00eb					      OVERLAY	UnpackLevelOverlay
      1 U00e1 ????				      SEG.U	OVERLAY_UnpackLevelOverlay
      2 U00dc					      org	Overlay
    603 U00dc
    604 U00dc		       00	   base_x     ds	1
    605 U00dd		       00	   base_y     ds	1
    606 U00de		       00	   upk_length ds	1
    607 U00df		       00	   upk_column ds	1
    608 U00e0		       00	   upk_temp   ds	1
    609 U00e1
    610 U00e1							;ECHO "FREE BYTES IN UnpackLevelOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    612 U00e1
    613 U00e1							;------------------------------------------------------------------------------
    614 U00e1
      0 U00e1					      OVERLAY	ManProcessing
      1 U00de ????				      SEG.U	OVERLAY_ManProcessing
      2 U00dc					      org	Overlay
    616 U00dc		       00 00	   actionVector ds	2
      0 U00de					      VALIDATE_OVERLAY
      5 U00de					      LIST	ON
    618 U00de
      0 U00de					      OVERLAY	SetPlatformColours
      1 U00dd ????				      SEG.U	OVERLAY_SetPlatformColours
      2 U00dc					      org	Overlay
    620 U00dc		       00	   colorIdx   ds	1
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    622 U00dd
      0 U00dd					      OVERLAY	SwapPlayers
      1 U00dd ????				      SEG.U	OVERLAY_SwapPlayers
      2 U00dc					      org	Overlay
    624 U00dc		       00	   tmpX       ds	1
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    626 U00dd
      0 U00dd					      OVERLAY	DrawIntoStack
      1 U00dd ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00dc					      org	Overlay
    628 U00dc		       00	   save_SP    ds	1
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    630 U00dd
    631 U00dd							;------------------------------------------------------------------------------
    632 U00dd							;##############################################################################
    633 U00dd							;------------------------------------------------------------------------------
    634 U00dd
    635 U00dd							; NOW THE VERY INTERESTING '3E' RAM BANKS
    636 U00dd							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    637 U00dd
    638 U00dd				   ORIGIN     SET	0
      0 U00dd					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN / RAM_SIZE
      6 U0000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    640 U0000
    641 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    642 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    643 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    644 U0000
    645 U0000		       00 60	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    646 U0000
    647 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    648 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    649 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    650 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    651 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    652 U0000
    653 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    654 U0000							; is that we can use that code to switch between banks, and the system will happily
    655 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    656 U0000
    657 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    658 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    659 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    660 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    661 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    662 U0000
    663 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    664 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    665 U0000							; part of the draw routine *every* scanline (though the system currently uses
    666 U0000							; one colour shared between both players).
    667 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    669 U0000
    670 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    671 U0000							; accessed via the above labels but with the appropriate bank switched in.
    672 U0000
    673 U0000							;------------------------------------------------------------------------------
    674 U0000
    675 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    675 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    675 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    675 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1000				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    675 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    675 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    675 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    678 U1c00					      REPEND
    679 U1c00
    680 U1c00							;------------------------------------------------------------------------------
    681 U1c00							;##############################################################################
    682 U1c00							;------------------------------------------------------------------------------
    683 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN / RAM_SIZE
      6 U2000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    685 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    686 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    688 U2000
    689 U2000							;------------------------------------------------------------------------------
    690 U2000							;##############################################################################
    691 U2000							;------------------------------------------------------------------------------
    692 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN / RAM_SIZE
      6 U2400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    694 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    695 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    697 U2400
    698 U2400							;------------------------------------------------------------------------------
    699 U2400							;##############################################################################
    700 U2400							;------------------------------------------------------------------------------
    701 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_LEVEL
      1 U2800 ????				      SEG.U	BANK_DECODE_LEVEL
      2 U2800					      ORG	ORIGIN
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_LEVEL SET	ORIGIN / RAM_SIZE
      6 U2800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    703 U2800							; VARS DEFINED IN BANK_DECODE_LEVEL_SHADOW
    704 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    706 U2800
    707 U2800							;------------------------------------------------------------------------------
    708 U2800							;##############################################################################
    709 U2800							;------------------------------------------------------------------------------
    710 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN / RAM_SIZE
      6 U2c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
    712 U2c00
    713 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    714 U2c00							; position of something that needs to be processed.  These things include anything
    715 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    716 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    717 U2c00							; one for the next processing iteration.
    718 U2c00
    719 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    720 U2c00
    721 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    722 U2c00
    723 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    724 U2c00
    725 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    726 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    727 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    728 U2d80
    729 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    730 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    731 U2e00
    732 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    733 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    734 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    735 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    737 U2e80
    738 U2e80							;------------------------------------------------------------------------------
    739 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN / RAM_SIZE
      6 U3000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    741 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    743 U3000
    744 U3000							;------------------------------------------------------------------------------
    745 U3000							;##############################################################################
    746 U3000							;------------------------------------------------------------------------------
    747 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U37a0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN / RAM_SIZE
      6 U3400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    749 U3400
    750 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    751 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    752 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    753 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    754 U3400							; when accessing.
    755 U3400
    756 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    757 U3400							; automatically based on the sizes set in these constants. The board may overlay
    758 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    759 U3400							; we're doing OK.
    760 U3400
    761 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    762 U3400
    763 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    764 U3400
    765 U3400		       00 28	   SIZE_BOARD_X =	40
    766 U3400		       00 16	   SIZE_BOARD_Y =	22
    767 U3400				  -	      if	0
    768 U3400				  -			; have to precalculate it here, else DASM freaks out:
    769 U3400				  -.BOARD_SIZE SET	0
    770 U3400				  -.BOARD_LOCATION SET	0
    771 U3400				  -	      REPEAT	SIZE_BOARD_Y
    772 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    773 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    774 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    775 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    776 U3400				  -	      ENDIF
    777 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    778 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    779 U3400				  -	      REPEND
    780 U3400				  -
    781 U3400				  -SIZE_BOARD =	.BOARD_SIZE
    782 U3400					      endif
    783 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    784 U3400				  -MULTI_BANK_BOARD =	YES
    785 U3400					      ELSE
    786 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    787 U3400					      ENDIF
    788 U3400
    789 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    790 U37a0							; 1024 byte chunks, switching RAM
    791 U37a0							; banks as we go.  In other words,
    792 U37a0							; this overlaps multiple banks!
    793 U37a0
      0 U37a0					      NEWRAMBANK	BANK_TAKEBACK
      1 U3b00 ????				      SEG.U	BANK_TAKEBACK
      2 U3800					      ORG	ORIGIN
      3 U3800					      RORG	RAM_3E
      4 U3800				   BANK_START SET	*
      5 U3800				   BANK_TAKEBACK SET	ORIGIN / RAM_SIZE
      6 U3800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    795 U3800		       00 00 00 00*TakeBackX  ds	256
    796 U3900		       00 00 00 00*TakeBackY  ds	256
    797 U3a00		       00 00 00 00*TakeBackA  ds	256
    798 U3b00
    799 U3b00							; free space here (but hard to use)
    800 U3b00							; So we need to calculate where the next free bank is!
    801 U3b00							; TODO: This looks dodgy.  Check..
    802 U3b00
    803 U3b00				   ORIGIN     SET	( * + RAM_SIZE - 1 ) / RAM_SIZE
    804 U3b00				   ORIGIN     SET	ORIGIN * RAM_SIZE
    805 U3b00
    806 U3b00
    807 U3b00
    808 U3b00							;------------------------------------------------------------------------------
    809 U3b00							;##############################################################################
    810 U3b00							;------------------------------------------------------------------------------
    811 U3b00
    812 U3b00							;------------------------------------------------------------------------------
    813 U3b00
    814 U3b00							;    IFNCONST MAX_LEVEL_SIZE
    815 U3b00				   MAX_LEVEL_SIZE SET	0
    816 U3b00							;    ENDIF
    817 U3b00
    818 U3b00
    819 U3b00				   MAX_LEVEL_NUMBER SET	0
    820 U3b00					      MAC	start_level
    821 U3b00				   LEVEL_START SET	*
    822 U3b00				   BANK_LEVEL_{1} =	_CURRENT_BANK
    823 U3b00				   LEVEL_{1}  SUBROUTINE
    824 U3b00				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
    825 U3b00							; ECHO "current MAX_LEVEL_NUMBER = ", MAX_LEVEL_NUMBER
    826 U3b00					      ENDM		; {name}
    827 U3b00
    828 U3b00
    829 U3b00					      MAC	end_level
    830 U3b00				   LEVEL_SIZE_{1} =	* - LEVEL_START
    831 U3b00					      IF	LEVEL_SIZE_{1} > MAX_LEVEL_SIZE
    832 U3b00				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_{1}
    833 U3b00					      ENDIF
    834 U3b00					      ENDM		; {name}
    835 U3b00
    836 U3b00
    837 U3b00					      MAC	defl
    838 U3b00					      START_LEVEL	{1}
    839 U3b00					      .byte	{2},0
    840 U3b00					      END_LEVEL	{1}
    841 U3b00					      ENDM
    842 U3b00
    843 U3b00							;--------------------------------------------------------------------------------
    844 U3b00
    845 U3b00				   ORIGIN     SET	$00000
    846 U3b00
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 4
      0 U3b00					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1 U3b00							;    Sokoboo - a Sokoban implementation
      2 U3b00							;    using a generic tile-based display engine for the Atari 2600
      3 U3b00							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4 U3b00							;
      5 U3b00							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6 U3b00							;
      7 U3b00							;    Code related to the generic tile-based display engine was developed by
      8 U3b00							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9 U3b00							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10 U3b00							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11 U3b00							;
     12 U3b00							;    Code related to music and sound effects uses the TIATracker music player
     13 U3b00							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14 U3b00							;    directory for Apache licensing details.
     15 U3b00							;
     16 U3b00							;    Some level data incorporated in this program were created by Lee J Haywood.
     17 U3b00							;    See the copyright notices in the License directory for a list of level
     18 U3b00							;    contributors.
     19 U3b00							;
     20 U3b00							;    Except where otherwise indicated, this software is released under the
     21 U3b00							;    following licensing arrangement...
     22 U3b00							;
     23 U3b00							;    This program is free software: you can redistribute it and/or modify
     24 U3b00							;    it under the terms of the GNU General Public License as published by
     25 U3b00							;    the Free Software Foundation, either version 3 of the License, or
     26 U3b00							;    (at your option) any later version.
     27 U3b00							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28 U3b00
     29 U3b00							;    This program is distributed in the hope that it will be useful,
     30 U3b00							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31 U3b00							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32 U3b00							;    GNU General Public License for more details.
     33 U3b00
     34 U3b00							;------------------------------------------------------------------------------
     35 U3b00							;##############################################################################
     36 U3b00							;------------------------------------------------------------------------------
      0 U3b00					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  036e ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
     38  0000
     39  0000							; This is essentially a ROM mirror of a RAM bank.
     40  0000							; The contents of this bank are copied to each of the ROW banks on startup, and
     41  0000							; this gives a 1:1 correspondence between the data/addresses defined here, and
     42  0000							; the addresses in the switched-in RAM bank.
     43  0000
     44  0000							; Note: Bankswitching code between any of these banks guarantees the code can
     45  0000							; continue to run -- because, of course, the same code is still at the same
     46  0000							; memory address.
     47  0000
     48  0000		       00 01	   _PROFILE_DRAW =	YES
     49  0000
     50  0000					      MAC	profile_draw
     51  0000					      IF	_PROFILE_DRAW
     52  0000					      inc	Profile{1}
     53  0000					      bne	$skip
     54  0000					      inc	Profile{1}+1
     55  0000				   $skip
     56  0000					      ENDIF
     57  0000					      ENDM		; {label}
     58  0000
     59  0000
      0  0000					      DEFINE_SUBROUTINE	DrawTheScreen
      1  0000		       00 00	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  0000					      SUBROUTINE
      3  0000				   DrawTheScreen
     61  0000
     62  0000							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     63  0000							; A refactor of the kernel to improve the timing.
     64  0000							; Experimental refactor to remove the blank line...
     65  0000
     66  0000							; adjust here so that the first line of the kernel starts exactly at cycle 67
     67  0000							; (since TJ said it could start up to 5 cycles earlier than #67).
     68  0000
     69  0000							; TODO: remove GRP1 and COLUP1 access (or use higher resolution player)
     70  0000							;	     @57
      0  0000					      SLEEP	3	; 3
      1  0000				   .CYCLES    SET	3
      2  0000
      3  0000				  -	      IF	.CYCLES < 2
      4  0000				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0000				  -	      ERR
      6  0000					      ENDIF
      7  0000
      8  0000					      IF	.CYCLES & 1
      9  0000					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0000		       04 00		      nop	0
     11  0002				  -	      ELSE
     12  0002				  -	      bit	VSYNC
     13  0002					      ENDIF
     14  0002				   .CYCLES    SET	.CYCLES - 3
     15  0002					      ENDIF
     16  0002
     17  0002				  -	      REPEAT	.CYCLES / 2
     18  0002				  -	      nop
     19  0002					      REPEND
     72  0002
     73  0002		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     74  0004		       10 3e		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     75  0006
     76  0006				   Proc2		; 5
      0  0006					      SLEEP	3	; 3	     @64
      1  0006				   .CYCLES    SET	3
      2  0006
      3  0006				  -	      IF	.CYCLES < 2
      4  0006				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0006				  -	      ERR
      6  0006					      ENDIF
      7  0006
      8  0006					      IF	.CYCLES & 1
      9  0006					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0006		       04 00		      nop	0
     11  0008				  -	      ELSE
     12  0008				  -	      bit	VSYNC
     13  0008					      ENDIF
     14  0008				   .CYCLES    SET	.CYCLES - 3
     15  0008					      ENDIF
     16  0008
     17  0008				  -	      REPEAT	.CYCLES / 2
     18  0008				  -	      nop
     19  0008					      REPEND
     78  0008		       10 3c		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     79  000a
     80  000a				   ScanRED		;	     @60
     81  000a		       b9 b6 f2    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     82  000d		       85 4d		      sta	PF0	; 3	     @67
     83  000f		       b9 2c f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     84  0012		       85 4e		      sta	PF1	; 3 = 14    @74
     85  0014				   SELFMOD_PLAYERCOL_RED
     86  0014		       b9 af f0 	      lda	SpriteColourRED,y	; 4
     87  0017		       85 46		      sta	COLUP0	; 3	     @05
     88  0019		       85 47		      sta	COLUP1	; 3 = 10    @08
     89  001b
     90  001b							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     91  001b
     92  001b				   SELFMOD_RED
     93  001b		       a9 00		      lda	#0	; 2
     94  001d		       85 48		      sta	COLUPF	; 3 =	5    @13
     95  001f
     96  001f				   SELFMOD_PLAYER0_RED
     97  001f		       b9 b6 f2 	      lda	ShapePlayerRED,y	; 4
     98  0022		       85 5b		      sta	GRP0	; 3 =	7    @20
     99  0024
    100  0024		       b9 44 f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
    101  0027		       85 4f		      sta	PF2	; 3 =	7    @27
    102  0029
    103  0029		       b9 b6 f2    SM_PF0_REDr lda	CHARACTERSHAPE_BLANK,y	; 4
    104  002c		       85 4d		      sta	PF0	; 3	     @34
    105  002e		       b9 5c f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
    106  0031		       85 4e		      sta	PF1	; 3	     @41
    107  0033		       b9 74 f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
    108  0036		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
    109  0038
    110  0038				   SELFMOD_PLAYER1_RED
    111  0038		       b9 b6 f2 	      lda	ShapePlayerRED,y	; 4
    112  003b		       8d 5c 00 	      sta.w	GRP1	; 4 =	8    @56   VDELed!
    113  003e
    114  003e		       88		      dey		; 2
    115  003f		       10 c5		      bpl	Proc2	; 2(3)      --> 61 if taken
    116  0041
    117  0041		       e8	   SELFMOD_X  inx		; 2
    118  0042		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
    119  0044							;EXIT_RETURN_HERE
    120  0044				   NextALineStart
    121  0044		       a0 07		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
    122  0046				   ScanBLUEBD		;	     @67     let's start as late as possible
    123  0046
    124  0046							;------------------------------------------------------------------------------
    125  0046
    126  0046		       b9 b6 f2    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
    127  0049		       85 4d		      sta	PF0	; 3 =	7    @74
    128  004b				   SELFMOD_PLAYERCOL_BLUE
    129  004b		       b9 bf f0 	      lda	SpriteColourBLUE,y	; 4
    130  004e		       85 47		      sta	COLUP1	; 3	     @05
    131  0050		       85 46		      sta	COLUP0	; 3 = 10    @08
    132  0052
    133  0052				   SELFMOD_BLUE
    134  0052		       a9 00		      lda	#0	; 2
    135  0054		       85 48		      sta	COLUPF	; 3 =	5    @13
    136  0056
    137  0056				   SELFMOD_PLAYER0_BLUE
    138  0056		       b9 b6 f2 	      lda	ShapePlayerBLUE,y	; 4
    139  0059		       85 5b		      sta	GRP0	; 3 =	7    @20
    140  005b
    141  005b		       b9 3c f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    142  005e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    143  0060		       b9 54 f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    144  0063		       85 4f		      sta	PF2	; 3 = 14    @34
    145  0065
    146  0065		       b9 b6 f2    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    147  0068		       85 4d		      sta	PF0	; 3	     @41
    148  006a		       b9 6c f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    149  006d		       85 4e		      sta	PF1	; 3	     @48
    150  006f		       b9 84 f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    151  0072		       85 4f		      sta	PF2	; 3 = 21    @55
    152  0074
    153  0074				   SELFMOD_PLAYER1_BLUE
    154  0074		       b9 b6 f2 	      lda	ShapePlayerBLUE,y	; 4
    155  0077		       85 5c		      sta	GRP1	; 3 =	7    VDELed! @62
    156  0079
    157  0079							;------------------------------------------------------------------------------
    158  0079
    159  0079				   ScanGREEN		;	     @62
    160  0079		       b9 b6 f2    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    161  007c		       85 4d		      sta	PF0	; 3 =	7    @69
    162  007e				   SELFMOD_PLAYERCOL_GREEN
    163  007e		       b9 b7 f0 	      lda	SpriteColourGREEN,y	; 4
    164  0081		       85 47		      sta	COLUP1	; 3	     @00
    165  0083		       85 46		      sta	COLUP0	; 3 = 10    @03
    166  0085
    167  0085				   SELFMOD_GREEN
    168  0085		       a9 00		      lda	#0	; 2
    169  0087		       85 48		      sta	COLUPF	; 3 =	5    @08
    170  0089
    171  0089				   SELFMOD_PLAYER0_GREEN
    172  0089		       b9 b6 f2 	      lda	ShapePlayerGREEN,y	; 4
    173  008c		       85 5b		      sta	GRP0	; 3 =	7    @15
    174  008e
    175  008e		       b9 34 f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    176  0091		       85 4e		      sta	PF1	; 3	     @22
    177  0093		       b9 4c f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    178  0096		       85 4f		      sta	PF2	; 3 = 14    @29
    179  0098
    180  0098		       b9 b6 f2    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    181  009b		       85 4d		      sta	PF0	; 3	     @36
    182  009d		       b9 64 f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    183  00a0		       85 4e		      sta	PF1	; 3	     @43
    184  00a2		       b9 7c f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    185  00a5		       85 4f		      sta	PF2	; 3 = 21    @50
    186  00a7
    187  00a7				   SELFMOD_PLAYER1_GREEN
    188  00a7		       b9 b6 f2 	      lda	ShapePlayerGREEN,y	; 4
    189  00aa		       85 5c		      sta	GRP1	; 3 =	7    @57     VDELed!
    190  00ac
    191  00ac		       4c 0a f0 	      jmp	ScanRED	; 3	     @60
    192  00af
    193  00af							;------------------------------------------------------------------------------
    194  00af
    195  00af							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    196  00af
    197  00af		       f2 b6	   ShapePlayer =	PLAYER_BLANK
    198  00af		       f2 b6	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    199  00af		       f2 b6	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    200  00af		       f2 b6	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    201  00af
    202  00af		       f2 b6	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    203  00af		       f2 b6	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    204  00af
------- FILE playerColour.asm LEVEL 3 PASS 4
      0  00af					      include	"playerColour.asm"	; 1 * LINES_PER_CHAR bytes
      1  00af							;;    Sokoboo - a Sokoban implementation
      2  00af							;    using a generic tile-based display engine for the Atari 2600
      3  00af							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  00af							;
      5  00af							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  00af							;
      7  00af							;    Code related to the generic tile-based display engine was developed by
      8  00af							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  00af							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  00af							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  00af							;
     12  00af							;    Code related to music and sound effects uses the TIATracker music player
     13  00af							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  00af							;    directory for Apache licensing details.
     15  00af							;
     16  00af							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  00af							;    See the copyright notices in the License directory for a list of level
     18  00af							;    contributors.
     19  00af							;
     20  00af							;    Except where otherwise indicated, this software is released under the
     21  00af							;    following licensing arrangement...
     22  00af							;
     23  00af							;    This program is free software: you can redistribute it and/or modify
     24  00af							;    it under the terms of the GNU General Public License as published by
     25  00af							;    the Free Software Foundation, either version 3 of the License, or
     26  00af							;    (at your option) any later version.
     27  00af							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  00af
     29  00af							;    This program is distributed in the hope that it will be useful,
     30  00af							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  00af							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  00af							;    GNU General Public License for more details.
     33  00af
      0  00af					      OPTIONAL_PAGEBREAK	"SpriteColour", LINES_PER_CHAR*2
     10  00af					      LIST	ON
     35  00af
     36  00af		       00 10	   YELLOW_NTSC =	$10	; hair
     37  00af		       00 30	   ORANGE_NTSC =	$30	; skin
     38  00af		       00 40	   RED_NTSC   =	$40	; shirt
     39  00af		       00 a4	   BLUE_NTSC  =	$A4
     40  00af
     41  00af		       00 20	   YELLOW_PAL =	$20
     42  00af		       00 40	   ORANGE_PAL =	$40
     43  00af		       00 60	   RED_PAL    =	$60
     44  00af
     45  00af				   SpriteColour
     46  00af							; NTSC
     47  00af							;SpriteColourRED
     48  00af							;    .byte RED_NTSC|$6       ; 0 feet
     49  00af							;    .byte WHITE	      ; 3
     50  00af							;    .byte RED_NTSC|$4       ; 6
     51  00af							;    .byte RED_NTSC|$4       ; 9
     52  00af							;    .byte ORANGE_NTSC|$6    ;12
     53  00af							;    .byte ORANGE_NTSC|$8    ;15
     54  00af							;    .byte WHITE	      ;18
     55  00af							;SpriteColourGREEN
     56  00af							;    .byte RED_NTSC|$4       ; 1
     57  00af							;    .byte WHITE	      ; 4
     58  00af							;    .byte WHITE	      ; 7
     59  00af							;    .byte WHITE	      ;10
     60  00af							;    .byte ORANGE_NTSC|$8    ;13
     61  00af							;    .byte ORANGE_NTSC|$6    ;16
     62  00af							;    .byte WHITE	      ;19
     63  00af							;SpriteColourBLUE
     64  00af							;    .byte WHITE	      ; 2
     65  00af							;    .byte RED_NTSC|$4       ; 5
     66  00af							;    .byte RED_NTSC|$4       ; 8
     67  00af							;    .byte ORANGE_NTSC|$4    ;11 neck
     68  00af							;    .byte ORANGE_NTSC|$a    ;14
     69  00af							;    .byte YELLOW_NTSC|$c    ;17 hair
     70  00af							;    .byte WHITE	      ;20
     71  00af
     72  00af				   SpriteColourRED
     73  00af		       76		      .byte.b	$76
     74  00b0		       76		      .byte.b	$76
     75  00b1		       76		      .byte.b	$76
     76  00b2		       76		      .byte.b	$76
     77  00b3		       76		      .byte.b	$76
     78  00b4		       76		      .byte.b	$76
     79  00b5		       76		      .byte.b	$76
     80  00b6		       76		      .byte.b	$76
     81  00b7
     82  00b7
     83  00b7							;  .byte #$1C;0
     84  00b7							;  .byte #$78;3
     85  00b7							;  .byte #$52;6
     86  00b7							;  .byte #$52;9
     87  00b7							;  .byte #$0C;12
     88  00b7							;  .byte #$4A;15
     89  00b7							;  .byte #$1A;18
     90  00b7				   SpriteColourGREEN
     91  00b7		       76		      .byte.b	$76
     92  00b8		       76		      .byte.b	$76
     93  00b9		       76		      .byte.b	$76
     94  00ba		       76		      .byte.b	$76
     95  00bb		       76		      .byte.b	$76
     96  00bc		       76		      .byte.b	$76
     97  00bd		       76		      .byte.b	$76
     98  00be		       76		      .byte.b	$76
     99  00bf				   SpriteColourBLUE
    100  00bf		       76		      .byte.b	$76
    101  00c0		       76		      .byte.b	$76
    102  00c1		       76		      .byte.b	$76
    103  00c2		       76		      .byte.b	$76
    104  00c3		       76		      .byte.b	$76
    105  00c4		       76		      .byte.b	$76
    106  00c5		       76		      .byte.b	$76
    107  00c6		       76		      .byte.b	$76
    108  00c7
    109  00c7							;  REPEAT LINES_PER_CHARACTER	      ;???
    110  00c7							;  .byte $20|$6	     ; 2
    111  00c7							;   REPEND
    112  00c7
    113  00c7							; PAL
    114  00c7							;    .byte RED_PAL|$6	      ; 0 feet
    115  00c7							;    .byte WHITE	      ; 3
    116  00c7							;    .byte RED_PAL|$4	      ; 6
    117  00c7							;    .byte RED_PAL|$4	      ; 9
    118  00c7							;    .byte ORANGE_PAL|$4     ;12
    119  00c7							;    .byte ORANGE_PAL|$6     ;15
    120  00c7							;    .byte WHITE	      ;18
    121  00c7							;
    122  00c7							;    .byte RED_PAL|$4	      ; 1
    123  00c7							;    .byte WHITE	      ; 4
    124  00c7							;    .byte WHITE	      ; 7
    125  00c7							;    .byte WHITE	      ;10
    126  00c7							;    .byte ORANGE_PAL|$6     ;13
    127  00c7							;    .byte ORANGE_PAL|$4     ;16
    128  00c7							;    .byte WHITE	      ;19
    129  00c7							;
    130  00c7							;    .byte WHITE	      ; 2
    131  00c7							;    .byte RED_PAL|$4	      ; 5
    132  00c7							;    .byte RED_PAL|$4	      ; 8
    133  00c7							;    .byte ORANGE_PAL|$2     ;11 neck
    134  00c7							;    .byte ORANGE_PAL|$8     ;14
    135  00c7							;    .byte YELLOW_PAL|$c     ;17 hair
    136  00c7							;    .byte WHITE	      ;20
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    206  00c7
    207  00c7
    208  00c7							;------------------------------------------------------------------------------
    209  00c7
    210  00c7							;*** Ideas: ***
    211  00c7							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    212  00c7							;   13.5% on average), also unrolling would be more effective than now
    213  00c7							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    214  00c7							;   see EXPERIMENTAL)
    215  00c7							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    216  00c7							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    217  00c7							;   bidirectional linked list instead)
    218  00c7							; - calculate mirrored gfx data into RAM (saves ROM)
    219  00c7
    220  00c7							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    221  00c7							;currently:
    222  00c7							; 72%*539 (!unrolled)
    223  00c7							;+ 8%*304 (unrolled)
    224  00c7							;+20%*269 (unrolled)
    225  00c7							;--------
    226  00c7							;=   ~466.2 cycles on average
    227  00c7
    228  00c7							;alternative #1:
    229  00c7							; 72%*522 (unrolled)
    230  00c7							;+ 8%*352 (!unrolled)
    231  00c7							;+20%*307 (!unrolled)
    232  00c7							;--------
    233  00c7							;=   ~465.4 cycles on average
    234  00c7
    235  00c7
    236  00c7		       00 01	   MIRROR     =	1
    237  00c7		       00 80	   DIRECT     =	$80
    238  00c7
    239  00c7							;------------------------------------------------------------------------------
    240  00c7							; Here we don't draw into a buffer, but directly patch the kernel
    241  00c7							; VERY fast!
    242  00c7							;
    243  00c7							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    244  00c7							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    245  00c7
    246  00c7				   PF0Draw		; 25 cycles until here
    247  00c7
    248  00c7		       ae 84 02 	      ldx	INTIM	; 4
    249  00ca		       e0 04		      cpx	#SEGTIME_SCD_PF0	; 2
    250  00cc		       90 72		      bcc	ExitDraw	; 2(3)=8
      0  00ce					      STRESS_TIME	SEGTIME_SCD_PF0	; ok!
      1  00ce				  -	      IF	TEST_SEGTIME_SCD_PF0 = 1
      2  00ce				  -
      3  00ce				  -
      4  00ce				  -
      5  00ce				  -
      6  00ce				  -
      7  00ce				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  00ce				  -	      bne	. - 7
      9  00ce					      ENDIF
    252  00ce
    253  00ce		       29 7f		      and	#<(~DIRECT)	; 2
    254  00d0		       aa		      tax		; 2 =	4
    255  00d1
    256  00d1		       98		      tya		; 2
    257  00d2		       0a		      asl		; 2	     no mirrored chars in PF0
    258  00d3		       a8		      tay		; 2 =	6
    259  00d4							;		  clc				  ; 2
    260  00d4
    261  00d4		       b9 fa f2 	      lda	CharacterDataVecHI,y	; 4
    262  00d7		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    263  00da		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    264  00dd		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19
    265  00e0
    266  00e0		       b9 e6 f2 	      lda	CharacterDataVecLO,y	; 4
    267  00e3		       9d 0b f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    268  00e6		       69 07		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    269  00e8		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    270  00eb		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    271  00ed		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23
    272  00f0
    273  00f0		       4c 3a fa 	      jmp	DrawAnother	; 3 =	3
    274  00f3
    275  00f3							; Timing for PF0Draw
    276  00f3							; 7+63 = 70
    277  00f3							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    278  00f3
    279  00f3
    280  00f3							;------------------------------------------------------------------------------
    281  00f3							; Direct draw draws to PF0, which only has one active member of the character
    282  00f3							; pair -- so it can be a direct copy.	Quicker still!
    283  00f3
    284  00f3				   DirectDraw		; 37 cycles until here
    285  00f3
    286  00f3							;ldy #16
    287  00f3		       ad 84 02 	      lda	INTIM	; 4
    288  00f6		       c9 09		      cmp	#SEGTIME_SCD_DIRECT	; 2
    289  00f8		       90 46		      bcc	ExitDraw	; 2(3)=8
      0  00fa					      STRESS_TIME	SEGTIME_SCD_DIRECT	; ok!
      1  00fa				  -	      IF	TEST_SEGTIME_SCD_DIRECT = 1
      2  00fa				  -
      3  00fa				  -
      4  00fa				  -
      5  00fa				  -
      6  00fa				  -
      7  00fa				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  00fa				  -	      bne	. - 7
      9  00fa					      ENDIF
    291  00fa
    292  00fa							; TIME REQUIRED FROM HERE (9/JAN)
    293  00fa							; 16 + 20 + 20 + 2 + ( 7 * 32 ) - 1  + (42 SUFFIX)
    294  00fa							; = 323 --> /64 = 5.04 USE 7
    295  00fa
    296  00fa		       b9 fa f2 	      lda	CharacterDataVecHI,y	; 4
    297  00fd		       8d 2a f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    298  0100		       8d 30 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    299  0103		       8d 36 f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    300  0106
    301  0106		       b9 e6 f2 	      lda	CharacterDataVecLO,y	; 4
    302  0109		       8d 29 f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    303  010c		       69 07		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    304  010e		       8d 2f f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    305  0111		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    306  0113		       8d 35 f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    307  0116
    308  0116		       bd ca f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    309  0119		       8d 2c f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    310  011c		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    311  011e		       8d 32 f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    312  0121		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    313  0123		       8d 38 f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    314  0126
    315  0126		       a0 07		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    316  0128				   TSFill3
    317  0128		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    318  012b		       99 2c f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    319  012e		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    320  0131		       99 2c f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    321  0134		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    322  0137		       99 2c f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    323  013a
    324  013a		       88		      dey		; 2
      0  013b					      CHECKPAGE_BPL	TSFill3	; 3(2)=5
      8  013b					      LIST	ON
      9  013b		       10 eb		      bpl	TSFill3
    326  013d
    327  013d		       4c 3a fa 	      jmp	DrawAnother	; 3
    328  0140
    329  0140							; Timing for DirectDraw
    330  0140							; 17+8+16+20+20+2+(32*7)-1+3 = 309 (was: 302 + 3)
    331  0140							; total: 37+309+6 = 352 => 352/64 + 1.4 = 6.90 = 7 (= SEGTIME_SLOWDRAW-5)
    332  0140
    333  0140				   ExitDraw
    334  0140		       60		      rts
    335  0141
    336  0141							;------------------------------------------------------------------------------
      0  0141					      DEFINE_SUBROUTINE	StealPart3	; 18 CYCLES HERE
      1  0141		       00 00	   BANK_StealPart3 =	_CURRENT_BANK
      2  0141					      SUBROUTINE
      3  0141				   StealPart3
    338  0141
    339  0141		       bd dc f1 	      lda	MOD10,x	; 4
    340  0144		       30 81		      bmi	PF0Draw	; 2/3
    341  0146		       4a		      lsr		; 2
    342  0147		       aa		      tax		; 2
    343  0148		       98		      tya		; 2
    344  0149		       2a		      rol		; 2	     allows for mirrored char = * | 1
    345  014a		       a8		      tay		; 2
    346  014b		       b0 a6		      bcs	DirectDraw	; 2(3)      when draw stack was built, bit 7 flags direct-drawn character
    347  014d							;	     => +19 starting DirectDraw BUT WHO CARES AS IT'S ONLY AFTER THAT COUNTS
    348  014d
    349  014d		       b9 fa f2 	      lda	CharacterDataVecHI,y	; 4
    350  0150		       10 38		      bpl	QuickDraw	; 2(3)=42   special-case blank characters for extra speed
    351  0152							;	     => 42 starting QuickDraw
    352  0152		       8d 7b f5 	      sta	SMEOR1+RAM_WRITE+2	; 4 =	4
    353  0155
    354  0155		       ad 84 02 	      lda	INTIM	; 4
    355  0158		       c9 0d		      cmp	#SEGTIME_SCD_SLOW	; 2
    356  015a		       90 e4		      bcc	ExitDraw	; 2(3)=8
      0  015c					      STRESS_TIME	SEGTIME_SCD_SLOW	; ok!
      1  015c				  -	      IF	TEST_SEGTIME_SCD_SLOW = 1
      2  015c				  -
      3  015c				  -
      4  015c				  -
      5  015c				  -
      6  015c				  -
      7  015c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  015c				  -	      bne	. - 7
      9  015c					      ENDIF
    358  015c
    359  015c							; TIME REQUIRED FROM HERE (9/JAN)
    360  015c							; 8 + 16 + 8 + 2 + (21 * 24) -1 + (42 OVERHEAD WHEN RETURNING)
    361  015c							; = 579 --> /64 = 9.04 INTIM --> USE 10
    362  015c
    363  015c		       b9 e6 f2 	      lda	CharacterDataVecLO,y	; 4
    364  015f		       8d 7a f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    365  0162
    366  0162		       bd ca f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    367  0165		       8d 77 f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    368  0168		       8d 7f f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    369  016b		       8d 82 f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    370  016e
    371  016e		       bd d4 f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    372  0171		       8d 7d f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    373  0174
    374  0174		       a0 17	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2
    375  0176
    376  0176							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    377  0176							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    378  0176
    379  0176				   TSFill
    380  0176
    381  0176		       b9 2c f2    SMLOAD     lda	ScreenBitmap,y	; 4
    382  0179		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    383  017c		       29 00	   SMMASK     and	#0	; 2
    384  017e		       59 2c f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    385  0181		       99 2c f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    386  0184
    387  0184		       88		      dey		; 2
      0  0185					      CHECKPAGE_BPL	TSFill	; 3(2)=5
      8  0185					      LIST	ON
      9  0185		       10 ef		      bpl	TSFill
    389  0187
    390  0187		       4c 3a fa 	      jmp	DrawAnother	; 3
    391  018a
    392  018a							; Timing for "SLOW" draw
    393  018a							; 22+4+8+8+16+8+2+(21*24)-1+3 = 574 (was: 566 + 3)
    394  018a							; total: 37+574+6 = 617 => 628/64 + 1.4 = 11.04 = 12 (= SEGTIME_SLOWDRAW)
    395  018a
    396  018a
    397  018a							;------------------------------------------------------------------------------
    398  018a							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    399  018a							; existing character data, so can be special-cased from the normal character
    400  018a							; draw, saving roughly 230 cycles.
    401  018a
    402  018a				   QuickDraw		; 42 cycles until here
    403  018a
    404  018a		       ad 84 02 	      lda	INTIM	; 4
    405  018d		       c9 0a		      cmp	#SEGTIME_SCD_QUICK	; 2	     SEE TIMING CALCS BELOW
    406  018f		       90 af		      bcc	ExitDraw	; 2(3)=8
      0  0191					      STRESS_TIME	SEGTIME_SCD_QUICK	; ok!
      1  0191				  -	      IF	TEST_SEGTIME_SCD_QUICK = 1
      2  0191				  -
      3  0191				  -
      4  0191				  -
      5  0191				  -
      6  0191				  -
      7  0191				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  0191				  -	      bne	. - 7
      9  0191					      ENDIF
    408  0191
    409  0191							; TIME REQUIRED FROM HERE (9/JAN)
    410  0191							;   = 32 + 4 + 2 + ( 7 * 38 ) - 1 + 3	+ (42 SUFFIX)
    411  0191							;   = 348 --> /64 = 5.43. USE 7
    412  0191
    413  0191		       bd ca f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    414  0194		       8d b1 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    415  0197		       8d b4 f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    416  019a		       69 07		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    417  019c		       8d b8 f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    418  019f		       8d bb f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    419  01a2		       69 08		      adc	#LINES_PER_CHAR/3	; 2
    420  01a4		       8d bf f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    421  01a7		       8d c2 f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32
    422  01aa
    423  01aa		       bc d2 f1 	      ldy	CharMask,x	; 4 =	4    masks out left or right
    424  01ad
    425  01ad		       a2 07		      ldx	#LINES_PER_CHAR/3 - 1	; 2 =	2
    426  01af				   TSFill2
    427  01af		       98		      tya		; 2
    428  01b0		       3d 2c f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    429  01b3		       9d 2c f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    430  01b6		       98		      tya		; 2
    431  01b7		       3d 2c f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    432  01ba		       9d 2c f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    433  01bd		       98		      tya		; 2
    434  01be		       3d 2c f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    435  01c1		       9d 2c f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33
    436  01c4
    437  01c4		       ca		      dex		; 2
      0  01c5					      CHECKPAGE_BPL	TSFill2	; 3(2)=5
      8  01c5					      LIST	ON
      9  01c5		       10 e8		      bpl	TSFill2
    439  01c7
    440  01c7		       4c 3a fa 	      jmp	DrawAnother	; 3
    441  01ca
    442  01ca							; Timing for QuickDraw
    443  01ca							; 23+8+32+4+2+(7*38)-1+3 = 337 (was: 330 + 3)
    444  01ca							; total: 37+337+6 = 380 => 380/64 + 1.4 = 7.34 = 8 (= SEGTIME_SLOWDRAW-4)
    445  01ca
    446  01ca
    447  01ca							;------------------------------------------------------------------------------
    448  01ca
    449  01ca
    450  01ca				   CharAddressLO		;[abs char location % 10]
    451  01ca
    452  01ca							; Gives the absolute screen buffer address of the first line of the given character
    453  01ca							; Where character number is 0-9
    454  01ca
    455  01ca		       2c		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    456  01cb		       2c		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    457  01cc		       44		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    458  01cd		       44		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    459  01ce		       5c		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    460  01cf		       5c		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    461  01d0		       74		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    462  01d1		       74		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    463  01d2							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    464  01d2							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    465  01d2
    466  01d2				   CharMask		; [abs char location % 10]
    467  01d2
    468  01d2							; Gives the mask for any char of the screen (per row)
    469  01d2							; Note, this is hardwired to the screen format of 6 bytes/line
    470  01d2
    471  01d2		       0f		      .byte.b	$0F	; 1
    472  01d3		       f0		      .byte.b	$F0	; 2
    473  01d4				   CharMaskNeg
    474  01d4		       f0		      .byte.b	$F0	; 3/1
    475  01d5		       0f		      .byte.b	$0F	; 4/2
    476  01d6		       0f		      .byte.b	$0F	; 6/3
    477  01d7		       f0		      .byte.b	$F0	; 7/4
    478  01d8		       f0		      .byte.b	$F0	; 8/6
    479  01d9		       0f		      .byte.b	$0F	; 9/7
    480  01da		       0f		      .byte.b	$0F	; -/8
    481  01db		       f0		      .byte.b	$F0	; -/9
    482  01dc				   MOD10
    483  01dc					      REPEAT	SCREEN_LINES
    484  01dc							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  01dc							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  01dc		       80		      .byte.b	DIRECT
    487  01dd		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  01e1		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  01e2		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  01e2					      REPEND
    484  01e6							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  01e6							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  01e6		       80		      .byte.b	DIRECT
    487  01e7		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  01eb		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  01ec		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  01ec					      REPEND
    484  01f0							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  01f0							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  01f0		       80		      .byte.b	DIRECT
    487  01f1		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  01f5		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  01f6		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  01f6					      REPEND
    484  01fa							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  01fa							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  01fa		       80		      .byte.b	DIRECT
    487  01fb		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  01ff		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0200		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0200					      REPEND
    484  0204							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0204							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0204		       80		      .byte.b	DIRECT
    487  0205		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0209		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  020a		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  020a					      REPEND
    484  020e							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  020e							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  020e		       80		      .byte.b	DIRECT
    487  020f		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0213		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0214		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0214					      REPEND
    484  0218							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0218							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0218		       80		      .byte.b	DIRECT
    487  0219		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  021d		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  021e		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  021e					      REPEND
    484  0222							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0222							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0222		       80		      .byte.b	DIRECT
    487  0223		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0227		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0228		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    490  022c					      REPEND
    491  022c
    492  022c							;------------------------------------------------------------------------------
    493  022c
      0  022c					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  022c					      LIST	ON
    495  022c
    496  022c		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,0	; character bitmap row (10 chars wide)
    497  022c		       f2 2c	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    498  022c		       f2 34	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    499  022c		       f2 3c	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    500  028c
      0  028c					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  028c					      LIST	ON
    502  028c
    503  028c
    504  028c							;--------------------------------------------------------------------------
    505  028c
      0  028c					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  028c		       00 00	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  028c					      SUBROUTINE
      3  028c				   SelfModDrawPlayers
    507  028c
    508  028c							; Now the player(s) have animated, update the appropriate shape pointers
    509  028c							; in the draw code.
    510  028c
    511  028c							; Sets the shapes to a blank player -- effectively erasing
    512  028c		       a5 b3		      lda	LastSpriteY
    513  028e		       a2 b6		      ldx	#<PLAYER_BLANK
    514  0290		       20 9f f2 	      jsr	SetSelfModPlayer
    515  0293
    516  0293							; Now we've erased, we write the new shape
    517  0293
    518  0293							;		  sec
    519  0293							;		  lda ManDrawX
    520  0293							;		  sbc BoardScrollX
    521  0293							;		  cmp #SCREEN_WIDTH			  ; disabled because we assume always onscreen
    522  0293							;		  bcs NoMod				  ; skip if off visible screen
    523  0293
    524  0293		       a5 9d		      lda	ManDrawX
    525  0295		       c9 0a		      cmp	#SCREEN_WIDTH	; disabled because we assume always onscreen
    526  0297		       b0 1c		      bcs	NoMod	; skip if off visible screen
    527  0299
    528  0299							;lda LookingAround
    529  0299							;bne NoMod
    530  0299
    531  0299		       a5 9e		      lda	ManDrawY
    532  029b		       85 b3		      sta	LastSpriteY
    533  029d
    534  029d		       a6 a3		      ldx	ManAnimationFrameLO
    535  029f
    536  029f				   SetSelfModPlayer
    537  029f		       c9 08		      cmp	#SCREEN_LINES	; only erase/draw if was/is onscreen
    538  02a1		       b0 12		      bcs	NoMod
    539  02a3		       69 00		      adc	#BANK_SCREENMARKII1
    540  02a5		       85 3e		      sta	SET_BANK_RAM	; switch old/new bank in
    541  02a7
    542  02a7		       8a		      txa
    543  02a8		       8d 20 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1	; lo of frame
    544  02ab		       69 08		      adc	#LINES_PER_CHAR/3
    545  02ad		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    546  02b0		       69 08		      adc	#LINES_PER_CHAR/3
    547  02b2		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    548  02b5
    549  02b5		       60	   NoMod      rts
    550  02b6
      0  02b6					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  02b6
      2  02b6
      3  02b6		       02 b6	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $2b6 , FREE= $14a
      4  02b6					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  02b6				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  02b6				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  02b6				  -	      ERR
      8  02b6					      endif
    552  02b6
------- FILE player.asm LEVEL 3 PASS 4
      0  02b6					      include	"player.asm"	; 6 * LINES_PER_CHAR	       MUST FOLLOW DIRT.ASM as data is shared
      1  02b6							;    Sokoboo - a Sokoban implementation
      2  02b6							;    using a generic tile-based display engine for the Atari 2600
      3  02b6							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  02b6							;
      5  02b6							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  02b6							;
      7  02b6							;    Code related to the generic tile-based display engine was developed by
      8  02b6							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  02b6							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  02b6							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  02b6							;
     12  02b6							;    Code related to music and sound effects uses the TIATracker music player
     13  02b6							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  02b6							;    directory for Apache licensing details.
     15  02b6							;
     16  02b6							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  02b6							;    See the copyright notices in the License directory for a list of level
     18  02b6							;    contributors.
     19  02b6							;
     20  02b6							;    Except where otherwise indicated, this software is released under the
     21  02b6							;    following licensing arrangement...
     22  02b6							;
     23  02b6							;    This program is free software: you can redistribute it and/or modify
     24  02b6							;    it under the terms of the GNU General Public License as published by
     25  02b6							;    the Free Software Foundation, either version 3 of the License, or
     26  02b6							;    (at your option) any later version.
     27  02b6							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  02b6
     29  02b6							;    This program is distributed in the hope that it will be useful,
     30  02b6							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  02b6							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  02b6							;    GNU General Public License for more details.
     33  02b6
     34  02b6							;    OPTIONAL_PAGEBREAK "PLAYER", LINES_PER_CHAR * 6 - 1
     35  02b6
     36  02b6
     37  02b6		       f2 b6	   PLAYER_BLANK =	.
     38  02b6					      REPEAT	LINES_PER_CHAR	;-1  ; as we have a "0" in the line below
     39  02b6		       00		      .byte.b	0
     38  02b6					      REPEND
     39  02b7		       00		      .byte.b	0
     38  02b7					      REPEND
     39  02b8		       00		      .byte.b	0
     38  02b8					      REPEND
     39  02b9		       00		      .byte.b	0
     38  02b9					      REPEND
     39  02ba		       00		      .byte.b	0
     38  02ba					      REPEND
     39  02bb		       00		      .byte.b	0
     38  02bb					      REPEND
     39  02bc		       00		      .byte.b	0
     38  02bc					      REPEND
     39  02bd		       00		      .byte.b	0
     38  02bd					      REPEND
     39  02be		       00		      .byte.b	0
     38  02be					      REPEND
     39  02bf		       00		      .byte.b	0
     38  02bf					      REPEND
     39  02c0		       00		      .byte.b	0
     38  02c0					      REPEND
     39  02c1		       00		      .byte.b	0
     38  02c1					      REPEND
     39  02c2		       00		      .byte.b	0
     38  02c2					      REPEND
     39  02c3		       00		      .byte.b	0
     38  02c3					      REPEND
     39  02c4		       00		      .byte.b	0
     38  02c4					      REPEND
     39  02c5		       00		      .byte.b	0
     38  02c5					      REPEND
     39  02c6		       00		      .byte.b	0
     38  02c6					      REPEND
     39  02c7		       00		      .byte.b	0
     38  02c7					      REPEND
     39  02c8		       00		      .byte.b	0
     38  02c8					      REPEND
     39  02c9		       00		      .byte.b	0
     38  02c9					      REPEND
     39  02ca		       00		      .byte.b	0
     38  02ca					      REPEND
     39  02cb		       00		      .byte.b	0
     38  02cb					      REPEND
     39  02cc		       00		      .byte.b	0
     38  02cc					      REPEND
     39  02cd		       00		      .byte.b	0
     40  02ce					      REPEND
     41  02ce
     42  02ce				   PLAYER_RIGHT0
     43  02ce
     44  02ce					      if	1
     45  02ce		       18		      .byte.b	%00011000	;20
     46  02cf		       18		      .byte.b	%00011000	;20
     47  02d0		       7e		      .byte.b	%01111110	;20
     48  02d1		       7e		      .byte.b	%01111110	;20
     49  02d2		       7e		      .byte.b	%01111110	;20
     50  02d3		       18		      .byte.b	%00011000	;20
     51  02d4		       18		      .byte.b	%00011000	;20
     52  02d5		       00		      .byte.b	%00000000	;20
     53  02d6
     54  02d6		       18		      .byte.b	%00011000	;20
     55  02d7		       18		      .byte.b	%00011000	;20
     56  02d8		       7e		      .byte.b	%01111110	;20
     57  02d9		       7e		      .byte.b	%01111110	;20
     58  02da		       7e		      .byte.b	%01111110	;20
     59  02db		       18		      .byte.b	%00011000	;20
     60  02dc		       18		      .byte.b	%00011000	;20
     61  02dd		       00		      .byte.b	%00000000	;20
     62  02de
     63  02de		       18		      .byte.b	%00011000	;20
     64  02df		       18		      .byte.b	%00011000	;20
     65  02e0		       7e		      .byte.b	%01111110	;20
     66  02e1		       7e		      .byte.b	%01111110	;20
     67  02e2		       7e		      .byte.b	%01111110	;20
     68  02e3		       18		      .byte.b	%00011000	;20
     69  02e4		       18		      .byte.b	%00011000	;20
     70  02e5		       00		      .byte.b	%00000000	;20
     71  02e6
     72  02e6				  -	      else
     73  02e6				  -			;push
     74  02e6				  -	      .byte	#%01110000	;$1C 0
     75  02e6				  -	      .byte	#%01110000	;$78 3
     76  02e6				  -	      .byte	#%00010000	;$52 6
     77  02e6				  -	      .byte	#%00111100	;$52 9
     78  02e6				  -	      .byte	#%00011001	;$0C 12
     79  02e6				  -	      .byte	#%00001100	;$4A 15
     80  02e6				  -	      .byte	#%00001111	;$1A18
     81  02e6				  -
     82  02e6				  -	      .byte	#%10100000	;$1C 1
     83  02e6				  -	      .byte	#%00111000	;$78 4
     84  02e6				  -	      .byte	#%00111000	;$52 7
     85  02e6				  -	      .byte	#%00111100	;$56 10
     86  02e6				  -	      .byte	#%00001000	;$4A 13
     87  02e6				  -	      .byte	#%00001100	;$4A 16
     88  02e6				  -	      .byte	#%00001100	;$1C 19
     89  02e6				  -
     90  02e6				  -	      .byte	#%11010000	;$78 2
     91  02e6				  -	      .byte	#%00101000	;$78 5
     92  02e6				  -	      .byte	#%00111000	;$52 8
     93  02e6				  -	      .byte	#%00011111	;$56 11
     94  02e6				  -	      .byte	#%00001000	;$4A 14
     95  02e6				  -	      .byte	#%00011010	;$4A 17
     96  02e6				  -	      .byte	#%00001100	;$1C 20
     97  02e6				  -
     98  02e6					      endif
     99  02e6
    100  02e6				  -	      IF	0
    101  02e6				  -			;---Graphics Data from PlayerPal 2600---
    102  02e6				  -
    103  02e6				  -Frame0
    104  02e6				  -	      .byte	#%01110011	;$1C
    105  02e6				  -	      .byte	#%00100110	;$1C
    106  02e6				  -	      .byte	#%00110100	;$78
    107  02e6				  -	      .byte	#%00010100	;$78
    108  02e6				  -	      .byte	#%00011100	;$78
    109  02e6				  -	      .byte	#%00001000	;$78
    110  02e6				  -	      .byte	#%00010000	;$52
    111  02e6				  -	      .byte	#%00111000	;$52
    112  02e6				  -	      .byte	#%00111000	;$52
    113  02e6				  -	      .byte	#%10111000	;$52
    114  02e6				  -	      .byte	#%01111000	;$56
    115  02e6				  -	      .byte	#%00110000	;$56
    116  02e6				  -	      .byte	#%00111100	;$0C
    117  02e6				  -	      .byte	#%00110010	;$4A
    118  02e6				  -	      .byte	#%00010000	;$4A
    119  02e6				  -	      .byte	#%00011000	;$4A
    120  02e6				  -	      .byte	#%00011000	;$4A
    121  02e6				  -	      .byte	#%00110100	;$4A
    122  02e6				  -	      .byte	#%00011110	;$1A
    123  02e6				  -	      .byte	#%00011000	;$1C
    124  02e6				  -	      .byte	#%00011000	;$1C
    125  02e6				  -Frame1
    126  02e6				  -	      .byte	#%00110110	;$1C
    127  02e6				  -	      .byte	#%00100100	;$1C
    128  02e6				  -	      .byte	#%00010100	;$78
    129  02e6				  -	      .byte	#%00010100	;$78
    130  02e6				  -	      .byte	#%00011100	;$78
    131  02e6				  -	      .byte	#%00001000	;$78
    132  02e6				  -	      .byte	#%00010000	;$52
    133  02e6				  -	      .byte	#%00111000	;$52
    134  02e6				  -	      .byte	#%00011000	;$52
    135  02e6				  -	      .byte	#%01111000	;$52
    136  02e6				  -	      .byte	#%00111000	;$56
    137  02e6				  -	      .byte	#%00110110	;$56
    138  02e6				  -	      .byte	#%00111100	;$0C
    139  02e6				  -	      .byte	#%00010000	;$4A
    140  02e6				  -	      .byte	#%00010000	;$4A
    141  02e6				  -	      .byte	#%00011000	;$4A
    142  02e6				  -	      .byte	#%00011000	;$4A
    143  02e6				  -	      .byte	#%00110100	;$4A
    144  02e6				  -	      .byte	#%00011110	;$1A
    145  02e6				  -	      .byte	#%00011000	;$1C
    146  02e6				  -	      .byte	#%00011000	;$1C
    147  02e6				  -Frame2
    148  02e6				  -	      .byte	#%00011000	;$1C
    149  02e6				  -	      .byte	#%00110000	;$1C
    150  02e6				  -	      .byte	#%01010000	;$78
    151  02e6				  -	      .byte	#%00111000	;$78
    152  02e6				  -	      .byte	#%00011000	;$78
    153  02e6				  -	      .byte	#%00001000	;$78
    154  02e6				  -	      .byte	#%00010000	;$52
    155  02e6				  -	      .byte	#%00111000	;$52
    156  02e6				  -	      .byte	#%00111000	;$52
    157  02e6				  -	      .byte	#%00111100	;$52
    158  02e6				  -	      .byte	#%00110100	;$56
    159  02e6				  -	      .byte	#%00111100	;$56
    160  02e6				  -	      .byte	#%00111000	;$0C
    161  02e6				  -	      .byte	#%00010000	;$4A
    162  02e6				  -	      .byte	#%00010000	;$4A
    163  02e6				  -	      .byte	#%00011000	;$4A
    164  02e6				  -	      .byte	#%00011000	;$4A
    165  02e6				  -	      .byte	#%00110100	;$4A
    166  02e6				  -	      .byte	#%00011110	;$1A
    167  02e6				  -	      .byte	#%00011000	;$1C
    168  02e6				  -	      .byte	#%00011000	;$1C
    169  02e6				  -Frame3
    170  02e6				  -	      .byte	#%01110000	;$1C
    171  02e6				  -	      .byte	#%10100000	;$1C
    172  02e6				  -	      .byte	#%11010000	;$78
    173  02e6				  -	      .byte	#%01110000	;$78
    174  02e6				  -	      .byte	#%00111000	;$78
    175  02e6				  -	      .byte	#%00101000	;$78
    176  02e6				  -	      .byte	#%00010000	;$52
    177  02e6				  -	      .byte	#%00111000	;$52
    178  02e6				  -	      .byte	#%00111000	;$52
    179  02e6				  -	      .byte	#%00111100	;$52
    180  02e6				  -	      .byte	#%00111100	;$56
    181  02e6				  -	      .byte	#%00011111	;$56
    182  02e6				  -	      .byte	#%00011001	;$0C
    183  02e6				  -	      .byte	#%00001000	;$4A
    184  02e6				  -	      .byte	#%00001000	;$4A
    185  02e6				  -	      .byte	#%00001100	;$4A
    186  02e6				  -	      .byte	#%00001100	;$4A
    187  02e6				  -	      .byte	#%00011010	;$4A
    188  02e6				  -	      .byte	#%00001111	;$1A
    189  02e6				  -	      .byte	#%00001100	;$1C
    190  02e6				  -	      .byte	#%00001100	;$1C
    191  02e6				  -Frame4
    192  02e6				  -	      .byte	#%00110110	;$1C
    193  02e6				  -	      .byte	#%00010100	;$1C
    194  02e6				  -	      .byte	#%00010100	;$78
    195  02e6				  -	      .byte	#%00010100	;$78
    196  02e6				  -	      .byte	#%00011100	;$78
    197  02e6				  -	      .byte	#%00001100	;$78
    198  02e6				  -	      .byte	#%00010000	;$52
    199  02e6				  -	      .byte	#%00011000	;$52
    200  02e6				  -	      .byte	#%00011100	;$52
    201  02e6				  -	      .byte	#%00111100	;$52
    202  02e6				  -	      .byte	#%00111100	;$56
    203  02e6				  -	      .byte	#%00111100	;$56
    204  02e6				  -	      .byte	#%00111110	;$0C
    205  02e6				  -	      .byte	#%01011010	;$4A
    206  02e6				  -	      .byte	#%10010001	;$4A
    207  02e6				  -	      .byte	#%10011001	;$4A
    208  02e6				  -	      .byte	#%00011000	;$4A
    209  02e6				  -	      .byte	#%00011000	;$4A
    210  02e6				  -	      .byte	#%00011100	;$1A
    211  02e6				  -	      .byte	#%00011000	;$1C
    212  02e6				  -	      .byte	#%00010000	;$1C
    213  02e6				  -Frame5
    214  02e6				  -	      .byte	#%00110110	;$1C
    215  02e6				  -	      .byte	#%00010100	;$1C
    216  02e6				  -	      .byte	#%00010100	;$78
    217  02e6				  -	      .byte	#%00010100	;$78
    218  02e6				  -	      .byte	#%00011100	;$78
    219  02e6				  -	      .byte	#%01001101	;$78
    220  02e6				  -	      .byte	#%01010001	;$52
    221  02e6				  -	      .byte	#%01011011	;$52
    222  02e6				  -	      .byte	#%01011110	;$52
    223  02e6				  -	      .byte	#%00111100	;$52
    224  02e6				  -	      .byte	#%00111100	;$56
    225  02e6				  -	      .byte	#%00011100	;$56
    226  02e6				  -	      .byte	#%00011000	;$0C
    227  02e6				  -	      .byte	#%00011000	;$4A
    228  02e6				  -	      .byte	#%00011000	;$4A
    229  02e6				  -	      .byte	#%00111000	;$4A
    230  02e6				  -	      .byte	#%00001000	;$4A
    231  02e6				  -	      .byte	#%00000000	;$4A
    232  02e6				  -	      .byte	#%00000000	;$1A
    233  02e6				  -	      .byte	#%00000000	;$1C
    234  02e6				  -	      .byte	#%00000000	;$1C
    235  02e6				  -			;---End Graphics Data---
    236  02e6				  -
    237  02e6				  -
    238  02e6				  -			;---Color Data from PlayerPal 2600---
    239  02e6				  -
    240  02e6				  -ColorFrame0
    241  02e6				  -	      .byte	#$1C	;
    242  02e6				  -	      .byte	#$1C	;
    243  02e6				  -	      .byte	#$78	;
    244  02e6				  -	      .byte	#$78	;
    245  02e6				  -	      .byte	#$78	;
    246  02e6				  -	      .byte	#$78	;
    247  02e6				  -	      .byte	#$52	;
    248  02e6				  -	      .byte	#$52	;
    249  02e6				  -	      .byte	#$52	;
    250  02e6				  -	      .byte	#$52	;
    251  02e6				  -	      .byte	#$56	;
    252  02e6				  -	      .byte	#$56	;
    253  02e6				  -	      .byte	#$0C	;
    254  02e6				  -	      .byte	#$4A	;
    255  02e6				  -	      .byte	#$4A	;
    256  02e6				  -	      .byte	#$4A	;
    257  02e6				  -	      .byte	#$4A	;
    258  02e6				  -	      .byte	#$4A	;
    259  02e6				  -	      .byte	#$1A	;
    260  02e6				  -	      .byte	#$1C	;
    261  02e6				  -	      .byte	#$1C	;
    262  02e6				  -ColorFrame1
    263  02e6				  -	      .byte	#$1C	;
    264  02e6				  -	      .byte	#$1C	;
    265  02e6				  -	      .byte	#$78	;
    266  02e6				  -	      .byte	#$78	;
    267  02e6				  -	      .byte	#$78	;
    268  02e6				  -	      .byte	#$78	;
    269  02e6				  -	      .byte	#$52	;
    270  02e6				  -	      .byte	#$52	;
    271  02e6				  -	      .byte	#$52	;
    272  02e6				  -	      .byte	#$52	;
    273  02e6				  -	      .byte	#$56	;
    274  02e6				  -	      .byte	#$56	;
    275  02e6				  -	      .byte	#$0C	;
    276  02e6				  -	      .byte	#$4A	;
    277  02e6				  -	      .byte	#$4A	;
    278  02e6				  -	      .byte	#$4A	;
    279  02e6				  -	      .byte	#$4A	;
    280  02e6				  -	      .byte	#$4A	;
    281  02e6				  -	      .byte	#$1A	;
    282  02e6				  -	      .byte	#$1C	;
    283  02e6				  -	      .byte	#$1C	;
    284  02e6				  -ColorFrame2
    285  02e6				  -	      .byte	#$1C	;
    286  02e6				  -	      .byte	#$1C	;
    287  02e6				  -	      .byte	#$78	;
    288  02e6				  -	      .byte	#$78	;
    289  02e6				  -	      .byte	#$78	;
    290  02e6				  -	      .byte	#$78	;
    291  02e6				  -	      .byte	#$52	;
    292  02e6				  -	      .byte	#$52	;
    293  02e6				  -	      .byte	#$52	;
    294  02e6				  -	      .byte	#$52	;
    295  02e6				  -	      .byte	#$56	;
    296  02e6				  -	      .byte	#$56	;
    297  02e6				  -	      .byte	#$0C	;
    298  02e6				  -	      .byte	#$4A	;
    299  02e6				  -	      .byte	#$4A	;
    300  02e6				  -	      .byte	#$4A	;
    301  02e6				  -	      .byte	#$4A	;
    302  02e6				  -	      .byte	#$4A	;
    303  02e6				  -	      .byte	#$1A	;
    304  02e6				  -	      .byte	#$1C	;
    305  02e6				  -	      .byte	#$1C	;
    306  02e6				  -ColorFrame3
    307  02e6				  -	      .byte	#$1C	;
    308  02e6				  -	      .byte	#$1C	;
    309  02e6				  -	      .byte	#$78	;
    310  02e6				  -	      .byte	#$78	;
    311  02e6				  -	      .byte	#$78	;
    312  02e6				  -	      .byte	#$78	;
    313  02e6				  -	      .byte	#$52	;
    314  02e6				  -	      .byte	#$52	;
    315  02e6				  -	      .byte	#$52	;
    316  02e6				  -	      .byte	#$52	;
    317  02e6				  -	      .byte	#$56	;
    318  02e6				  -	      .byte	#$56	;
    319  02e6				  -	      .byte	#$0C	;
    320  02e6				  -	      .byte	#$4A	;
    321  02e6				  -	      .byte	#$4A	;
    322  02e6				  -	      .byte	#$4A	;
    323  02e6				  -	      .byte	#$4A	;
    324  02e6				  -	      .byte	#$4A	;
    325  02e6				  -	      .byte	#$1A	;
    326  02e6				  -	      .byte	#$1C	;
    327  02e6				  -	      .byte	#$1C	;
    328  02e6				  -ColorFrame4
    329  02e6				  -	      .byte	#$1C	;
    330  02e6				  -	      .byte	#$1C	;
    331  02e6				  -	      .byte	#$78	;
    332  02e6				  -	      .byte	#$78	;
    333  02e6				  -	      .byte	#$78	;
    334  02e6				  -	      .byte	#$78	;
    335  02e6				  -	      .byte	#$52	;
    336  02e6				  -	      .byte	#$52	;
    337  02e6				  -	      .byte	#$52	;
    338  02e6				  -	      .byte	#$52	;
    339  02e6				  -	      .byte	#$56	;
    340  02e6				  -	      .byte	#$56	;
    341  02e6				  -	      .byte	#$0C	;
    342  02e6				  -	      .byte	#$4A	;
    343  02e6				  -	      .byte	#$4A	;
    344  02e6				  -	      .byte	#$4A	;
    345  02e6				  -	      .byte	#$4A	;
    346  02e6				  -	      .byte	#$4A	;
    347  02e6				  -	      .byte	#$1A	;
    348  02e6				  -	      .byte	#$1C	;
    349  02e6				  -	      .byte	#$1C	;
    350  02e6				  -ColorFrame5
    351  02e6				  -	      .byte	#$1C	;
    352  02e6				  -	      .byte	#$1C	;
    353  02e6				  -	      .byte	#$78	;
    354  02e6				  -	      .byte	#$78	;
    355  02e6				  -	      .byte	#$78	;
    356  02e6				  -	      .byte	#$78	;
    357  02e6				  -	      .byte	#$52	;
    358  02e6				  -	      .byte	#$52	;
    359  02e6				  -	      .byte	#$52	;
    360  02e6				  -	      .byte	#$52	;
    361  02e6				  -	      .byte	#$56	;
    362  02e6				  -	      .byte	#$56	;
    363  02e6				  -	      .byte	#$0C	;
    364  02e6				  -	      .byte	#$4A	;
    365  02e6				  -	      .byte	#$4A	;
    366  02e6				  -	      .byte	#$4A	;
    367  02e6				  -	      .byte	#$4A	;
    368  02e6				  -	      .byte	#$4A	;
    369  02e6				  -	      .byte	#$1A	;
    370  02e6				  -	      .byte	#$1C	;
    371  02e6				  -	      .byte	#$1C	;
    372  02e6				  -			;---End Color Data---
    373  02e6					      ENDIF
    374  02e6
    375  02e6
    376  02e6							;.byte %00011000  ;  XXX   ; 0
    377  02e6							;.byte %00111100  ;XXXXXX  ; 1
    378  02e6							;.byte %01110100  ;XXXX X  ; 2 etc.
    379  02e6							;.byte %01111100  ;XXXXXX  ; 3
    380  02e6							;.byte %00111000  ;XXXXX   ;4
    381  02e6							;.byte %01111100  ; XXXXX  ;5
    382  02e6							;.byte %00111000  ;  XXX   ;6
    383  02e6							;.byte %11111000  ;XXXXX   ;7
    384  02e6							;.byte %11111100  ;XXXXXX  ;8
    385  02e6							;.byte %11111100  ;XXXXXX  ;9 etc.
    386  02e6							;.byte %10000100  ;X	 X  ;10
    387  02e6							;.byte %11111100  ;XXXXXX  ;11
    388  02e6							;.byte %00001100  ;	XX  ;12
    389  02e6							;.byte %01111100  ; XXXXX  ;13
    390  02e6							;.byte %01111100  ; XXXXX  ;14
    391  02e6							;.byte %01111000  ; XXXX   ;15
    392  02e6							;.byte %01111000  ; XXXX   ;16 etc.
    393  02e6							;.byte %11111000  ;XXXXX   ;17
    394  02e6							;.byte %11101100  ;XXX XX  ;18
    395  02e6							;.byte %10111100  ;X XXXX  ;19
    396  02e6							;.byte %11001100  ;XX	XX   20
    397  02e6
    398  02e6							;---Graphics Data from PlayerPal 2600---
    399  02e6
    400  02e6				   PLAYER_RIGHT1
    401  02e6				   PLAYER_STAND
    402  02e6				   PLAYER_BLINK
    403  02e6				   PLAYER_TAP0
    404  02e6				   PLAYER_TAP1
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    554  02e6
    555  02e6							;------------------------------------------------------------------------------
    556  02e6
    557  02e6							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    558  02e6
    559  02e6							;------------------------------------------------------------------------------
    560  02e6
    561  02e6
    562  02e6
    563  02e6
    564  02e6				   OBJTYPE    SET	0
    565  02e6					      MAC	define_character
    566  02e6				   CHARACTER_{1} =	OBJTYPE
    567  02e6				   OBJTYPE    .SET	OBJTYPE + 1
    568  02e6					      ENDM
    569  02e6
    570  02e6							; Modifications to character #/order must also ensure the following are correct...
    571  02e6							;   CharacterDataVecLO/HI	   in this file
    572  02e6							;   MoveVecLO/HI		   in BANK_INITBANK
    573  02e6							;   CharReplacement		   in BANK_ROM_SHADOW_DRAWBUFFERS
    574  02e6
      0  02e6					      DEFINE_CHARACTER	BLANK
      1  02e6		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	SOIL
      1  02e6		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	BOX
      1  02e6		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	TARGET
      1  02e6		       00 03	   CHARACTER_TARGET =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	TARGET2
      1  02e6		       00 04	   CHARACTER_TARGET2 =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	MANOCCUPIED
      1  02e6		       00 05	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	STEEL
      1  02e6		       00 06	   CHARACTER_STEEL =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	WALL
      1  02e6		       00 07	   CHARACTER_WALL =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	BOX_ON_TARGET
      1  02e6		       00 08	   CHARACTER_BOX_ON_TARGET =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
      0  02e6					      DEFINE_CHARACTER	NOGO
      1  02e6		       00 09	   CHARACTER_NOGO =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
    585  02e6
    586  02e6				  -	      if	DIGITS
    587  02e6				  -	      DEFINE_CHARACTER	0
    588  02e6				  -	      DEFINE_CHARACTER	1
    589  02e6				  -	      DEFINE_CHARACTER	2
    590  02e6				  -	      DEFINE_CHARACTER	3
    591  02e6				  -	      DEFINE_CHARACTER	4
    592  02e6				  -	      DEFINE_CHARACTER	5
    593  02e6				  -	      DEFINE_CHARACTER	6
    594  02e6				  -	      DEFINE_CHARACTER	7
    595  02e6				  -	      DEFINE_CHARACTER	8
    596  02e6				  -	      DEFINE_CHARACTER	9
    597  02e6					      endif
    598  02e6
    599  02e6				  -	      if	TROPHY
    600  02e6				  -
    601  02e6				  -	      DEFINE_CHARACTER	TROPHY_0_0
    602  02e6				  -	      DEFINE_CHARACTER	TROPHY_1_0
    603  02e6				  -	      DEFINE_CHARACTER	TROPHY_2_0
    604  02e6				  -	      DEFINE_CHARACTER	TROPHY_3_0
    605  02e6				  -
    606  02e6				  -	      DEFINE_CHARACTER	TROPHY_0_1
    607  02e6				  -	      DEFINE_CHARACTER	TROPHY_1_1
    608  02e6				  -	      DEFINE_CHARACTER	TROPHY_2_1
    609  02e6				  -	      DEFINE_CHARACTER	TROPHY_3_1
    610  02e6				  -
    611  02e6				  -	      DEFINE_CHARACTER	TROPHY_0_2
    612  02e6				  -	      DEFINE_CHARACTER	TROPHY_1_2
    613  02e6				  -	      DEFINE_CHARACTER	TROPHY_2_2
    614  02e6				  -	      DEFINE_CHARACTER	TROPHY_3_2
    615  02e6				  -
    616  02e6				  -	      DEFINE_CHARACTER	TROPHY_0_3
    617  02e6				  -	      DEFINE_CHARACTER	TROPHY_1_3
    618  02e6				  -	      DEFINE_CHARACTER	TROPHY_2_3
    619  02e6				  -	      DEFINE_CHARACTER	TROPHY_3_3
    620  02e6				  -
    621  02e6				  -	      DEFINE_CHARACTER	TROPHY_0_4
    622  02e6				  -	      DEFINE_CHARACTER	TROPHY_1_4
    623  02e6				  -	      DEFINE_CHARACTER	TROPHY_2_4
    624  02e6				  -	      DEFINE_CHARACTER	TROPHY_3_4
    625  02e6					      endif
    626  02e6
      0  02e6					      DEFINE_CHARACTER	MAXIMUM
      1  02e6		       00 0a	   CHARACTER_MAXIMUM =	OBJTYPE
      2  02e6				   OBJTYPE    .SET	OBJTYPE + 1
    628  02e6
    629  02e6
    630  02e6				   CharacterDataVecLO
    631  02e6
    632  02e6							; Two entries per character.  2nd is ptr to mirrored character
    633  02e6							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
    634  02e6
    635  02e6		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    636  02e7		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    637  02e8		       56		      .byte.b	<CHARACTERSHAPE_SOIL
    638  02e9		       56		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
    639  02ea		       cc		      .byte.b	<CHARACTERSHAPE_BOX
    640  02eb		       e4		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
    641  02ec		       0e		      .byte.b	<CHARACTERSHAPE_TARGET
    642  02ed		       0e		      .byte.b	<CHARACTERSHAPE_TARGET_MIRRORED
    643  02ee		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    644  02ef		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    645  02f0		       b6		      .byte.b	<CHARACTERSHAPE_BLANK	; man occupied
    646  02f1		       b6		      .byte.b	<CHARACTERSHAPE_BLANK
    647  02f2		       26		      .byte.b	<CHARACTERSHAPE_STEEL
    648  02f3		       3e		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
    649  02f4		       30		      .byte.b	<CHARACTERSHAPE_WALL
    650  02f5		       48		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
    651  02f6		       00		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET
    652  02f7		       18		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    653  02f8		       b6		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    654  02f9		       b6		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    655  02fa
    656  02fa				  -	      if	DIGITS
    657  02fa				  -	      .byte	<CHARACTERSHAPE_0, <CHARACTERSHAPE_0_MIRRORED
    658  02fa				  -	      .byte	<CHARACTERSHAPE_1, <CHARACTERSHAPE_1_MIRRORED
    659  02fa				  -	      .byte	<CHARACTERSHAPE_2, <CHARACTERSHAPE_2_MIRRORED
    660  02fa				  -	      .byte	<CHARACTERSHAPE_3, <CHARACTERSHAPE_3_MIRRORED
    661  02fa				  -	      .byte	<CHARACTERSHAPE_4, <CHARACTERSHAPE_4_MIRRORED
    662  02fa				  -	      .byte	<CHARACTERSHAPE_5, <CHARACTERSHAPE_5_MIRRORED
    663  02fa				  -	      .byte	<CHARACTERSHAPE_6, <CHARACTERSHAPE_6_MIRRORED
    664  02fa				  -	      .byte	<CHARACTERSHAPE_7, <CHARACTERSHAPE_7_MIRRORED
    665  02fa				  -	      .byte	<CHARACTERSHAPE_8, <CHARACTERSHAPE_8_MIRRORED
    666  02fa				  -	      .byte	<CHARACTERSHAPE_9, <CHARACTERSHAPE_9_MIRRORED
    667  02fa					      endif
    668  02fa
    669  02fa				  -	      if	TROPHY
    670  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_0_0, <CHARACTERSHAPE_TROPHY_0_0
    671  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_1_0, <CHARACTERSHAPE_TROPHY_1_0
    672  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_2_0, <CHARACTERSHAPE_TROPHY_2_0
    673  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_3_0, <CHARACTERSHAPE_TROPHY_3_0
    674  02fa				  -
    675  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_0_1, <CHARACTERSHAPE_TROPHY_0_1
    676  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_1_1, <CHARACTERSHAPE_TROPHY_1_1
    677  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_2_1, <CHARACTERSHAPE_TROPHY_2_1
    678  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_3_1, <CHARACTERSHAPE_TROPHY_3_1
    679  02fa				  -
    680  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_0_2, <CHARACTERSHAPE_TROPHY_0_2
    681  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_1_2, <CHARACTERSHAPE_TROPHY_1_2
    682  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_2_2, <CHARACTERSHAPE_TROPHY_2_2
    683  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_3_2, <CHARACTERSHAPE_TROPHY_3_2
    684  02fa				  -
    685  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_0_3, <CHARACTERSHAPE_TROPHY_0_3
    686  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_1_3, <CHARACTERSHAPE_TROPHY_1_3
    687  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_2_3, <CHARACTERSHAPE_TROPHY_2_3
    688  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_3_3, <CHARACTERSHAPE_TROPHY_3_3
    689  02fa				  -
    690  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_0_4, <CHARACTERSHAPE_TROPHY_0_4
    691  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_1_4, <CHARACTERSHAPE_TROPHY_1_4
    692  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_2_4, <CHARACTERSHAPE_TROPHY_2_4
    693  02fa				  -	      .byte	<CHARACTERSHAPE_TROPHY_3_4, <CHARACTERSHAPE_TROPHY_3_4
    694  02fa					      endif
    695  02fa
    696  02fa				  -	      IF	* - CharacterDataVecLO != CHARACTER_MAXIMUM*2
    697  02fa				  -	      ECHO	"ERROR: Incorrect CharacterDataVecLO table!"
    698  02fa				  -	      ERR
    699  02fa					      ENDIF
    700  02fa
    701  02fa
    702  02fa							;ds 20,0
    703  02fa
    704  02fa							;---------------------------------------------------------------------------
    705  02fa
    706  02fa				   CharacterDataVecHI
    707  02fa
    708  02fa		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    709  02fb		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    710  02fc		       f3		      .byte.b	>CHARACTERSHAPE_SOIL
    711  02fd		       f3		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
    712  02fe		       fd		      .byte.b	>CHARACTERSHAPE_BOX
    713  02ff		       fd		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
    714  0300		       f3		      .byte.b	>CHARACTERSHAPE_TARGET
    715  0301		       f3		      .byte.b	>CHARACTERSHAPE_TARGET_MIRRORED
    716  0302		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    717  0303		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    718  0304		       f2		      .byte.b	>CHARACTERSHAPE_BLANK	; man occupied
    719  0305		       f2		      .byte.b	>CHARACTERSHAPE_BLANK
    720  0306		       f3		      .byte.b	>CHARACTERSHAPE_STEEL
    721  0307		       f3		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
    722  0308		       fe		      .byte.b	>CHARACTERSHAPE_WALL
    723  0309		       fe		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
    724  030a		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET
    725  030b		       fe		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    726  030c		       f2		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    727  030d		       f2		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    728  030e
    729  030e				  -	      if	DIGITS
    730  030e				  -	      .byte	>CHARACTERSHAPE_0, >CHARACTERSHAPE_0_MIRRORED
    731  030e				  -	      .byte	>CHARACTERSHAPE_1, >CHARACTERSHAPE_1_MIRRORED
    732  030e				  -	      .byte	>CHARACTERSHAPE_2, >CHARACTERSHAPE_2_MIRRORED
    733  030e				  -	      .byte	>CHARACTERSHAPE_3, >CHARACTERSHAPE_3_MIRRORED
    734  030e				  -	      .byte	>CHARACTERSHAPE_4, >CHARACTERSHAPE_4_MIRRORED
    735  030e				  -	      .byte	>CHARACTERSHAPE_5, >CHARACTERSHAPE_5_MIRRORED
    736  030e				  -	      .byte	>CHARACTERSHAPE_6, >CHARACTERSHAPE_6_MIRRORED
    737  030e				  -	      .byte	>CHARACTERSHAPE_7, >CHARACTERSHAPE_7_MIRRORED
    738  030e				  -	      .byte	>CHARACTERSHAPE_8, >CHARACTERSHAPE_8_MIRRORED
    739  030e				  -	      .byte	>CHARACTERSHAPE_9, >CHARACTERSHAPE_9_MIRRORED
    740  030e					      endif
    741  030e
    742  030e				  -	      if	TROPHY
    743  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_0_0, >CHARACTERSHAPE_TROPHY_0_0
    744  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_1_0, >CHARACTERSHAPE_TROPHY_1_0
    745  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_2_0, >CHARACTERSHAPE_TROPHY_2_0
    746  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_3_0, >CHARACTERSHAPE_TROPHY_3_0
    747  030e				  -
    748  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_0_1, >CHARACTERSHAPE_TROPHY_0_1
    749  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_1_1, >CHARACTERSHAPE_TROPHY_1_1
    750  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_2_1, >CHARACTERSHAPE_TROPHY_2_1
    751  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_3_1, >CHARACTERSHAPE_TROPHY_3_1
    752  030e				  -
    753  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_0_2, >CHARACTERSHAPE_TROPHY_0_2
    754  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_1_2, >CHARACTERSHAPE_TROPHY_1_2
    755  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_2_2, >CHARACTERSHAPE_TROPHY_2_2
    756  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_3_2, >CHARACTERSHAPE_TROPHY_3_2
    757  030e				  -
    758  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_0_3, >CHARACTERSHAPE_TROPHY_0_3
    759  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_1_3, >CHARACTERSHAPE_TROPHY_1_3
    760  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_2_3, >CHARACTERSHAPE_TROPHY_2_3
    761  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_3_3, >CHARACTERSHAPE_TROPHY_3_3
    762  030e				  -
    763  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_0_4, >CHARACTERSHAPE_TROPHY_0_4
    764  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_1_4, >CHARACTERSHAPE_TROPHY_1_4
    765  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_2_4, >CHARACTERSHAPE_TROPHY_2_4
    766  030e				  -	      .byte	>CHARACTERSHAPE_TROPHY_3_4, >CHARACTERSHAPE_TROPHY_3_4
    767  030e					      endif
    768  030e
    769  030e
    770  030e				  -	      IF	* - CharacterDataVecHI != CHARACTER_MAXIMUM*2
    771  030e				  -	      ECHO	"ERROR: Incorrect CharacterDataVecHI table!"
    772  030e				  -	      ERR
    773  030e					      ENDIF
    774  030e
    775  030e
    776  030e
    777  030e							; Here there's another 1K of usable ROM....
    778  030e							; BUT!!! WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    779  030e
    780  030e							;--------------------------------------------------------------------------
    781  030e							;    CHARACTER_SET
    782  030e
------- FILE characterset/character_TARGET.asm LEVEL 3 PASS 4
      0  030e					      include	"characterset/character_TARGET.asm"
      1  030e							;    Sokoboo - a Sokoban implementation
      2  030e							;    using a generic tile-based display engine for the Atari 2600
      3  030e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  030e							;
      5  030e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  030e							;
      7  030e							;    Code related to the generic tile-based display engine was developed by
      8  030e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  030e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  030e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  030e							;
     12  030e							;    Code related to music and sound effects uses the TIATracker music player
     13  030e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  030e							;    directory for Apache licensing details.
     15  030e							;
     16  030e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  030e							;    See the copyright notices in the License directory for a list of level
     18  030e							;    contributors.
     19  030e							;
     20  030e							;    Except where otherwise indicated, this software is released under the
     21  030e							;    following licensing arrangement...
     22  030e							;
     23  030e							;    This program is free software: you can redistribute it and/or modify
     24  030e							;    it under the terms of the GNU General Public License as published by
     25  030e							;    the Free Software Foundation, either version 3 of the License, or
     26  030e							;    (at your option) any later version.
     27  030e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  030e
     29  030e							;    This program is distributed in the hope that it will be useful,
     30  030e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  030e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  030e							;    GNU General Public License for more details.
     33  030e
     34  030e		       00 02	   TARGET_DEF =	2
     35  030e
     36  030e					      if	TARGET_DEF = 2
     37  030e
      0  030e					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET", LINES_PER_CHAR+1
     10  030e					      LIST	ON
     39  030e							;CHARACTERSHAPE_TARGET2_MIRRORED
     40  030e							;    .byte %00000000
     41  030e				   CHARACTERSHAPE_TARGET
     42  030e				   CHARACTERSHAPE_TARGET_MIRRORED
     43  030e		       00		      .byte.b	%00000000
     44  030f		       00		      .byte.b	%00000000
     45  0310		       66		      .byte.b	%01100110
     46  0311		       66		      .byte.b	%01100110
     47  0312		       66		      .byte.b	%01100110
     48  0313		       66		      .byte.b	%01100110
     49  0314		       00		      .byte.b	%00000000
     50  0315		       00		      .byte.b	%00000000
     51  0316		       00		      .byte.b	%00000000	;R
     52  0317		       00		      .byte.b	%00000000
     53  0318		       66		      .byte.b	%01100110
     54  0319		       66		      .byte.b	%01100110
     55  031a		       66		      .byte.b	%01100110
     56  031b		       66		      .byte.b	%01100110
     57  031c		       00		      .byte.b	%00000000
     58  031d		       00		      .byte.b	%00000000
     59  031e		       00		      .byte.b	%00000000	;B
     60  031f		       00		      .byte.b	%00000000
     61  0320		       66		      .byte.b	%01100110
     62  0321		       66		      .byte.b	%01100110
     63  0322		       66		      .byte.b	%01100110
     64  0323		       66		      .byte.b	%01100110
     65  0324		       00		      .byte.b	%00000000
     66  0325		       00		      .byte.b	%00000000
     67  0326
     68  0326							;--------------------------------------------------------------------------
     69  0326							;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_TARGET_MIRRORED", LINES_PER_CHAR+1
     70  0326
     71  0326							;CHARACTERSHAPE_TARGET2
     72  0326							;CHARACTERSHAPE_TARGET2_MIRRORED
     73  0326							;    ds 21,0	      ; replace with BLANK?!
     74  0326
     75  0326							;    CHECKPAGE CHARACTERSHAPE_TARGET2 ; since we share one byte!
     76  0326
     77  0326					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE characterset/character_STEEL.asm LEVEL 3 PASS 4
      0  0326					      include	"characterset/character_STEEL.asm"
      1  0326							;    Sokoboo - a Sokoban implementation
      2  0326							;    using a generic tile-based display engine for the Atari 2600
      3  0326							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0326							;
      5  0326							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0326							;
      7  0326							;    Code related to the generic tile-based display engine was developed by
      8  0326							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0326							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0326							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0326							;
     12  0326							;    Code related to music and sound effects uses the TIATracker music player
     13  0326							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0326							;    directory for Apache licensing details.
     15  0326							;
     16  0326							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0326							;    See the copyright notices in the License directory for a list of level
     18  0326							;    contributors.
     19  0326							;
     20  0326							;    Except where otherwise indicated, this software is released under the
     21  0326							;    following licensing arrangement...
     22  0326							;
     23  0326							;    This program is free software: you can redistribute it and/or modify
     24  0326							;    it under the terms of the GNU General Public License as published by
     25  0326							;    the Free Software Foundation, either version 3 of the License, or
     26  0326							;    (at your option) any later version.
     27  0326							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0326
     29  0326							;    This program is distributed in the hope that it will be useful,
     30  0326							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0326							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0326							;    GNU General Public License for more details.
     33  0326
     34  0326							;--------------------------------------------------------------------------
      0  0326					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
     10  0326					      LIST	ON
     36  0326				   CHARACTERSHAPE_STEEL
     37  0326		       00 88 00 00*	      .byte.b	%00000000,%10001000,%00000000,%00000000,%00000000,%00100010,%00000000,%00000000	;R
     38  032e		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11111111,%11011101,%11111111	;G
     39  0336		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11111111,%11011101,%11111111	;B
     40  033e
     41  033e							;--------------------------------------------------------------------------
      0  033e					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
     10  033e					      LIST	ON
     43  033e				   CHARACTERSHAPE_STEEL_MIRRORED
     44  033e		       00 11 00 00*	      .byte.b	%00000000,%00010001,%00000000,%00000000,%00000000,%01000100,%00000000,%00000000	;R
     45  0346		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%11111111,%10111011,%11111111	;G
     46  034e		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%11111111,%10111011,%11111111	;B
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE characterset/character_SOIL.asm LEVEL 3 PASS 4
      0  0356					      include	"characterset/character_SOIL.asm"
      1  0356							;    Sokoboo - a Sokoban implementation
      2  0356							;    using a generic tile-based display engine for the Atari 2600
      3  0356							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0356							;
      5  0356							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0356							;
      7  0356							;    Code related to the generic tile-based display engine was developed by
      8  0356							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0356							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0356							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0356							;
     12  0356							;    Code related to music and sound effects uses the TIATracker music player
     13  0356							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0356							;    directory for Apache licensing details.
     15  0356							;
     16  0356							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0356							;    See the copyright notices in the License directory for a list of level
     18  0356							;    contributors.
     19  0356							;
     20  0356							;    Except where otherwise indicated, this software is released under the
     21  0356							;    following licensing arrangement...
     22  0356							;
     23  0356							;    This program is free software: you can redistribute it and/or modify
     24  0356							;    it under the terms of the GNU General Public License as published by
     25  0356							;    the Free Software Foundation, either version 3 of the License, or
     26  0356							;    (at your option) any later version.
     27  0356							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0356
     29  0356							;    This program is distributed in the hope that it will be useful,
     30  0356							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0356							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0356							;    GNU General Public License for more details.
     33  0356
      0  0356					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  0356					      LIST	ON
     35  0356				   CHARACTERSHAPE_SOIL
     36  0356				   CHARACTERSHAPE_SOIL_MIRRORED
     37  0356		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
     38  035e		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111
     39  0366		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    786  036e
      0  036e					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- 1K"
      1  036e
      2  036e
      3  036e		       03 6e	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- 1K (1K) SIZE =  $36e , FREE= $92
      4  036e					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- 1K", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  036e				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  036e				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  036e				  -	      ERR
      8  036e					      endif
    788  036e
    789  036e
    790  036e
    791  036e							; Anything here is ONLY accessible if the bank is switched in as a ROM bank
    792  036e
    793  036e
      0  036e					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  036e		       03 6e	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $36e , FREE= $492
      2  036e					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  036e				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  036e				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  036e				  -	      ERR
      6  036e					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 4
      0  036e					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  036e							;    Sokoboo - a Sokoban implementation
      2  036e							;    using a generic tile-based display engine for the Atari 2600
      3  036e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  036e							;
      5  036e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  036e							;
      7  036e							;    Code related to the generic tile-based display engine was developed by
      8  036e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  036e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  036e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  036e							;
     12  036e							;    Code related to music and sound effects uses the TIATracker music player
     13  036e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  036e							;    directory for Apache licensing details.
     15  036e							;
     16  036e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  036e							;    See the copyright notices in the License directory for a list of level
     18  036e							;    contributors.
     19  036e							;
     20  036e							;    Except where otherwise indicated, this software is released under the
     21  036e							;    following licensing arrangement...
     22  036e							;
     23  036e							;    This program is free software: you can redistribute it and/or modify
     24  036e							;    it under the terms of the GNU General Public License as published by
     25  036e							;    the Free Software Foundation, either version 3 of the License, or
     26  036e							;    (at your option) any later version.
     27  036e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  036e
     29  036e							;    This program is distributed in the hope that it will be useful,
     30  036e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  036e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  036e							;    GNU General Public License for more details.
     33  036e
     34  036e							;------------------------------------------------------------------------------
     35  036e							;##############################################################################
     36  036e							;------------------------------------------------------------------------------
     37  036e
      0  036e					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  0a50 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
     39  0800
     40  0800							; NOTE: Access to these buffers must NOT overlap pages...
     41  0800							; NOTE: We get auto-initialisation of these variables from the ROM values by
     42  0800							; copying the whole bank into the RAM bank.  Neato.
     43  0800
     44  0800		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     45  0800
     46  0800
     47  0800
     48  0800		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     49  0850		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     50  08a0
      0  08a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  08a0					      LIST	ON
     52  08a0
     53  08a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     54  08a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     55  08a0							; what we want to happen!
     56  08a0
     57  08a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
     58  08f0
     59  08f0
     60  08f0							;------------------------------------------------------------------------------
     61  08f0							; RAM-BASED SUBROUTINES...
     62  08f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     63  08f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     64  08f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     65  08f0							; the RAM-based routine.
     66  08f0
     67  08f0
     68  08f0
     69  08f0							;------------------------------------------------------------------------------
     70  08f0
     71  08f0
     72  08f0		       60	   waitForDraw rts		; 6
     73  08f1
     74  08f1							;------------------------------------------------------------------------------
     75  08f1
      0  08f1					      DEFINE_SUBROUTINE	DrawStackUpdate	;=196 (+13 for fall-through bit)
      1  08f1		       00 01	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  08f1					      SUBROUTINE
      3  08f1				   DrawStackUpdate
     77  08f1
     78  08f1							; Parse the DrawFlags buffer and create a draw stack
     79  08f1							; so that the actual draw doesn't need to scan for characters to draw.
     80  08f1
     81  08f1
     82  08f1							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     83  08f1							; symptoms would be missing parts of screen when scrolling.
     84  08f1							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     85  08f1							; disabled for sokoban 27/7/2019
     86  08f1
     87  08f1							;lda DrawStackPointer
     88  08f1							;bpl waitForDraw		  ; Wait for previously not-drawn characters to be drawn
     89  08f1
     90  08f1		       ad 84 02 	      lda	INTIM	;4
     91  08f4		       c9 04		      cmp	#SEGTIME_BDS	;2
     92  08f6		       90 f8		      bcc	waitForDraw	;2/3
      0  08f8					      STRESS_TIME	SEGTIME_BDS
      1  08f8				  -	      IF	TEST_SEGTIME_BDS = 1
      2  08f8				  -
      3  08f8				  -
      4  08f8				  -
      5  08f8				  -
      6  08f8				  -
      7  08f8				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  08f8				  -	      bne	. - 7
      9  08f8					      ENDIF
     94  08f8
     95  08f8
     96  08f8							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
     97  08f8							; moving into the middle of dirt, or BOXs when pushing, or TARGETs when grabbing.
     98  08f8
     99  08f8							;		  sec		 already set
    100  08f8		       a5 9c		      lda	ManY	;3
    101  08fa		       e5 96		      sbc	BoardScrollY	;3
    102  08fc		       85 9e		      sta	ManDrawY	;3
    103  08fe
    104  08fe		       38		      sec		;2
    105  08ff		       a5 9b		      lda	ManX	;3
    106  0901		       e5 97		      sbc	BoardScrollX	;3
    107  0903		       c9 0a		      cmp	#SCREEN_WIDTH	;2
    108  0905		       90 06		      bcc	onsc	;2/3
    109  0907
    110  0907							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
    111  0907							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
    112  0907							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
    113  0907
    114  0907		       a9 08		      lda	#SCREEN_LINES	;2
    115  0909		       85 9e		      sta	ManDrawY	;3
    116  090b		       d0 02		      bne	skipsc	;3		  unconditional
    117  090d
    118  090d		       85 9d	   onsc       sta	ManDrawX	;3
    119  090f				   skipsc
    120  090f
    121  090f		       e6 b4		      inc	timer	;5
    122  0911		       20 d7 f1 	      jsr	AnimateCharReplacements2	;3+28
    123  0914
    124  0914		       e6 89		      inc	ScreenDrawPhase	;5
    125  0916
    126  0916		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
    127  0918		       85 d0		      sta	DSL	;3
    128  091a
    129  091a							; fall through...
    130  091a							;---------------------------------------------------------------------------
    131  091a
      0  091a					      DEFINE_SUBROUTINE	DrawIntoStack
      1  091a		       00 01	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  091a					      SUBROUTINE
      3  091a				   DrawIntoStack
    133  091a
    134  091a		       ba		      tsx		;2
    135  091b		       86 dc		      stx	save_SP	;3
    136  091d		       a6 84		      ldx	DrawStackPointer	;3
    137  091f		       9a		      txs		;2 = 10
    138  0920
    139  0920		       a4 d0		      ldy	DSL	;3
    140  0922
    141  0922							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    142  0922							; + exit cost which is +10 cycles
    143  0922							; TJ: I count 63
    144  0922							;   + 14 for the wtf2 exit
    145  0922							;   + 22 for the end of loop exit
    146  0922
    147  0922							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    148  0922							; For 80 iterations that is 640 cycles, just for checking INTIM
    149  0922							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    150  0922							; it also will require a lot of CPU time for updating the screen data.
    151  0922
    152  0922							; TODO: optimize!
    153  0922							;
    154  0922							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    155  0922							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    156  0922							; costs some detection time here, but saves ~240 cylces for drawing the two
    157  0922
    158  0922		       ad 84 02    .loopDrawStack lda	INTIM	;4
    159  0925		       c9 05		      cmp	#SEGTIME_DSL	;2
    160  0927		       90 4b		      bcc	.exitDrawStack	;2/3= 8/9
      0  0929					      STRESS_TIME	SEGTIME_DSL
      1  0929				  -	      IF	TEST_SEGTIME_DSL = 1
      2  0929				  -
      3  0929				  -
      4  0929				  -
      5  0929				  -
      6  0929				  -
      7  0929				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  0929				  -	      bne	. - 7
      9  0929					      ENDIF
    162  0929
    163  0929		       b9 50 f0 	      lda	DrawFlag,y	;4
    164  092c		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    165  092f		       f0 16		      beq	.next0	;2/3=10/11	 yes, so we don't draw anything
    166  0931
    167  0931							; Character is NOT the same. Figure out how it should be drawn.
    168  0931							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    169  0931							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    170  0931							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    171  0931
    172  0931		       be 7d f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    173  0934		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    174  0937		       d0 05		      bne	.notPaired0	;2/3=10/11
    175  0939
    176  0939							; Consider two 'paired' characters. Either A:A or A:B
    177  0939							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    178  0939							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    179  0939							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    180  0939							; on the comparison, so the character will not be added to the draw stack. So our first character will
    181  0939							; do the job of drawing BOTH characters to the screen.
    182  0939
    183  0939		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    184  093c		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    185  093e
    186  093e							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    187  093e							; the last write(below) marks the character as to be direct-drawn.
    188  093e
    189  093e		       99 a0 f4    .notPaired0 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    190  0941
    191  0941							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    192  0941
    193  0941		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    194  0942		       98		      tya		;2
    195  0943		       ba		      tsx		;2		 << now X holds drawstackpointer
    196  0944		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    197  0947
    198  0947		       88	   .next0     dey		;2
    199  0948		       30 21		      bmi	.finishedDrawStack	;2/3= 4/5
    200  094a
    201  094a							; unrolled 2nd loop:
    202  094a		       b9 50 f0 	      lda	DrawFlag,y	;4
    203  094d		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    204  0950		       f0 16		      beq	.next1	;2/3=10/11	 yes, so we don't draw anything
    205  0952
    206  0952		       be 7d f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    207  0955		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    208  0958		       d0 05		      bne	.notPaired1	;2/3=10/11
    209  095a
    210  095a		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    211  095d		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    212  095f
    213  095f		       99 a0 f4    .notPaired1 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    214  0962
    215  0962		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    216  0963		       98		      tya		;2
    217  0964		       ba		      tsx		;2
    218  0965		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    219  0968
    220  0968		       88	   .next1     dey		;2
    221  0969		       10 b7		      bpl	.loopDrawStack	;2/3= 4/5
    222  096b							;worst case: 111-4
    223  096b							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    224  096b
    225  096b							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    226  096b
    227  096b				   .finishedDrawStack
    228  096b		       e6 89		      inc	ScreenDrawPhase	;5 =  5
    229  096d		       ba		      tsx		;2
    230  096e		       86 84		      stx	DrawStackPointer	;3
    231  0970		       a6 dc		      ldx	save_SP	;3
    232  0972		       9a		      txs		;2 = 10
    233  0973
    234  0973							;jmp SwitchObjects
    235  0973
    236  0973		       60		      rts		;6 =  6
    237  0974
    238  0974				   .exitDrawStack
    239  0974		       84 d0		      sty	DSL	;3 =  3
    240  0976		       ba		      tsx		;2
    241  0977		       86 84		      stx	DrawStackPointer	;3
    242  0979		       a6 dc		      ldx	save_SP	;3
    243  097b		       9a		      txs		;2 = 10
    244  097c		       60		      rts		;6 =  6
    245  097d
    246  097d				   PairedCharacter
    247  097d
    248  097d				   SOFF       SET	0
    249  097d					      REPEAT	SCREEN_LINES
    250  097d		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  097d				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  097d					      REPEND
    250  0987		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  0987				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  0987					      REPEND
    250  0991		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  0991				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  0991					      REPEND
    250  099b		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  099b				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  099b					      REPEND
    250  09a5		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  09a5				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  09a5					      REPEND
    250  09af		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  09af				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  09af					      REPEND
    250  09b9		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  09b9				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  09b9					      REPEND
    250  09c3		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  09c3				   SOFF       SET	SOFF + SCREEN_WIDTH
    252  09cd					      REPEND
    253  09cd
    254  09cd							;------------------------------------------------------------------------------
    255  09cd							; Gives character replacements used during screen drawing.
    256  09cd							; The character from the board is morphed via this array into an actual character
    257  09cd							; to draw.  This allows global animation and replacment of characters without
    258  09cd							; individual objects needing to do this.  Note, the draw-time replacement happens,
    259  09cd							; not board-time.
    260  09cd
    261  09cd				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    262  09cd
    263  09cd							; Converts a character # to an animated creature type
    264  09cd							; The array is indexed by CHARACTER_...
    265  09cd
    266  09cd		       00		      .byte.b	CHARACTER_BLANK	;  0
    267  09ce		       01		      .byte.b	CHARACTER_SOIL	;  1
    268  09cf		       02		      .byte.b	CHARACTER_BOX	;  2
    269  09d0		       03	   ANIM_TARGET .byte.b	CHARACTER_TARGET	;  3  XOR'd to give flashing target squares
    270  09d1		       04		      .byte.b	CHARACTER_TARGET2	;  4
    271  09d2		       05		      .byte.b	CHARACTER_MANOCCUPIED	;  5
    272  09d3		       06		      .byte.b	CHARACTER_STEEL	;  6
    273  09d4		       07		      .byte.b	CHARACTER_WALL	;  7
    274  09d5		       08		      .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    275  09d6		       00		      .byte.b	CHARACTER_BLANK	;  9
    276  09d7
    277  09d7				  -	      if	DIGITS
    278  09d7				  -	      .byte	CHARACTER_0
    279  09d7				  -	      .byte	CHARACTER_1
    280  09d7				  -	      .byte	CHARACTER_2
    281  09d7				  -	      .byte	CHARACTER_3
    282  09d7				  -	      .byte	CHARACTER_4
    283  09d7				  -	      .byte	CHARACTER_5
    284  09d7				  -	      .byte	CHARACTER_6
    285  09d7				  -	      .byte	CHARACTER_7
    286  09d7				  -	      .byte	CHARACTER_8
    287  09d7				  -	      .byte	CHARACTER_9
    288  09d7					      endif
    289  09d7
    290  09d7				  -	      if	TROPHY
    291  09d7				  -	      .byte	CHARACTER_TROPHY_0_0, CHARACTER_TROPHY_1_0, CHARACTER_TROPHY_2_0, CHARACTER_TROPHY_3_0
    292  09d7				  -	      .byte	CHARACTER_TROPHY_0_1, CHARACTER_TROPHY_1_1, CHARACTER_TROPHY_2_1, CHARACTER_TROPHY_3_1
    293  09d7				  -	      .byte	CHARACTER_TROPHY_0_2, CHARACTER_TROPHY_1_2, CHARACTER_TROPHY_2_2, CHARACTER_TROPHY_3_2
    294  09d7				  -	      .byte	CHARACTER_TROPHY_0_3, CHARACTER_TROPHY_1_3, CHARACTER_TROPHY_2_3, CHARACTER_TROPHY_3_3
    295  09d7				  -	      .byte	CHARACTER_TROPHY_0_4, CHARACTER_TROPHY_1_4, CHARACTER_TROPHY_2_4, CHARACTER_TROPHY_3_4
    296  09d7					      endif
    297  09d7
    298  09d7				  -	      IF	(* - CharReplacement != CHARACTER_MAXIMUM)
    299  09d7				  -	      ECHO	"ERROR: Incorrect CharReplacement table!"
    300  09d7				  -	      ERR
    301  09d7					      ENDIF
      0  09d7					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  09d7					      LIST	ON
    303  09d7
    304  09d7
      0  09d7					      DEFINE_SUBROUTINE	AnimateCharReplacements2	;139
      1  09d7		       00 01	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  09d7					      SUBROUTINE
      3  09d7				   AnimateCharReplacements2
    306  09d7
    307  09d7							; This manages character animation on a per-object basis.  Morph/animate these
    308  09d7							; characters individually or as required.  Change will affect all characters
    309  09d7							; of the same type in the visible display.
    310  09d7
    311  09d7							; -------------------------------------------
    312  09d7
    313  09d7							; handle the non-mandatory animating things
    314  09d7
    315  09d7		       a5 b4		      lda	timer	;3
    316  09d9		       29 01		      and	#1	;2
    317  09db		       d0 0c		      bne	nothingAnimates	;2/3
    318  09dd
    319  09dd		       a5 98		      lda	scrollBits	;3
    320  09df		       d0 08		      bne	nothingAnimates	;2/3		 DON'T animate if we scrolled
    321  09e1
    322  09e1		       ad d0 f1 	      lda	ANIM_TARGET	;4
    323  09e4		       49 07		      eor	#CHARACTER_TARGET^CHARACTER_TARGET2	;2
    324  09e6		       8d d0 f5 	      sta	ANIM_TARGET + RAM_WRITE	;4 = 22	 TARGET
    325  09e9
    326  09e9		       60	   nothingAnimates rts		;6 = 28 if animating, less if not
    327  09ea
    328  09ea							;------------------------------------------------------------------------------
    329  09ea
    330  09ea
      0  09ea					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
 PAGE BREAK INSERTED FOR  ROW_BankChar
 REQUESTED SIZE =  $50
 WASTED SPACE =  $16
 PAGEBREAK LOCATION =  $f200
     10  0a00					      LIST	ON
      0  0a00					      DEFINE_SUBROUTINE	ROW_BankChar
      1  0a00		       00 01	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  0a00					      SUBROUTINE
      3  0a00				   ROW_BankChar
    333  0a00
    334  0a00				   .BANK      SET	BANK_SCREENMARKII1
    335  0a00					      REPEAT	SCREEN_LINES
    336  0a00					      REPEAT	SCREEN_WIDTH
    337  0a00		       00		      .byte.b	.BANK
    336  0a00					      REPEND
    337  0a01		       00		      .byte.b	.BANK
    336  0a01					      REPEND
    337  0a02		       00		      .byte.b	.BANK
    336  0a02					      REPEND
    337  0a03		       00		      .byte.b	.BANK
    336  0a03					      REPEND
    337  0a04		       00		      .byte.b	.BANK
    336  0a04					      REPEND
    337  0a05		       00		      .byte.b	.BANK
    336  0a05					      REPEND
    337  0a06		       00		      .byte.b	.BANK
    336  0a06					      REPEND
    337  0a07		       00		      .byte.b	.BANK
    336  0a07					      REPEND
    337  0a08		       00		      .byte.b	.BANK
    336  0a08					      REPEND
    337  0a09		       00		      .byte.b	.BANK
    338  0a0a					      REPEND
    339  0a0a				   .BANK      SET	.BANK + 1
    335  0a0a					      REPEND
    336  0a0a					      REPEAT	SCREEN_WIDTH
    337  0a0a		       01		      .byte.b	.BANK
    336  0a0a					      REPEND
    337  0a0b		       01		      .byte.b	.BANK
    336  0a0b					      REPEND
    337  0a0c		       01		      .byte.b	.BANK
    336  0a0c					      REPEND
    337  0a0d		       01		      .byte.b	.BANK
    336  0a0d					      REPEND
    337  0a0e		       01		      .byte.b	.BANK
    336  0a0e					      REPEND
    337  0a0f		       01		      .byte.b	.BANK
    336  0a0f					      REPEND
    337  0a10		       01		      .byte.b	.BANK
    336  0a10					      REPEND
    337  0a11		       01		      .byte.b	.BANK
    336  0a11					      REPEND
    337  0a12		       01		      .byte.b	.BANK
    336  0a12					      REPEND
    337  0a13		       01		      .byte.b	.BANK
    338  0a14					      REPEND
    339  0a14				   .BANK      SET	.BANK + 1
    335  0a14					      REPEND
    336  0a14					      REPEAT	SCREEN_WIDTH
    337  0a14		       02		      .byte.b	.BANK
    336  0a14					      REPEND
    337  0a15		       02		      .byte.b	.BANK
    336  0a15					      REPEND
    337  0a16		       02		      .byte.b	.BANK
    336  0a16					      REPEND
    337  0a17		       02		      .byte.b	.BANK
    336  0a17					      REPEND
    337  0a18		       02		      .byte.b	.BANK
    336  0a18					      REPEND
    337  0a19		       02		      .byte.b	.BANK
    336  0a19					      REPEND
    337  0a1a		       02		      .byte.b	.BANK
    336  0a1a					      REPEND
    337  0a1b		       02		      .byte.b	.BANK
    336  0a1b					      REPEND
    337  0a1c		       02		      .byte.b	.BANK
    336  0a1c					      REPEND
    337  0a1d		       02		      .byte.b	.BANK
    338  0a1e					      REPEND
    339  0a1e				   .BANK      SET	.BANK + 1
    335  0a1e					      REPEND
    336  0a1e					      REPEAT	SCREEN_WIDTH
    337  0a1e		       03		      .byte.b	.BANK
    336  0a1e					      REPEND
    337  0a1f		       03		      .byte.b	.BANK
    336  0a1f					      REPEND
    337  0a20		       03		      .byte.b	.BANK
    336  0a20					      REPEND
    337  0a21		       03		      .byte.b	.BANK
    336  0a21					      REPEND
    337  0a22		       03		      .byte.b	.BANK
    336  0a22					      REPEND
    337  0a23		       03		      .byte.b	.BANK
    336  0a23					      REPEND
    337  0a24		       03		      .byte.b	.BANK
    336  0a24					      REPEND
    337  0a25		       03		      .byte.b	.BANK
    336  0a25					      REPEND
    337  0a26		       03		      .byte.b	.BANK
    336  0a26					      REPEND
    337  0a27		       03		      .byte.b	.BANK
    338  0a28					      REPEND
    339  0a28				   .BANK      SET	.BANK + 1
    335  0a28					      REPEND
    336  0a28					      REPEAT	SCREEN_WIDTH
    337  0a28		       04		      .byte.b	.BANK
    336  0a28					      REPEND
    337  0a29		       04		      .byte.b	.BANK
    336  0a29					      REPEND
    337  0a2a		       04		      .byte.b	.BANK
    336  0a2a					      REPEND
    337  0a2b		       04		      .byte.b	.BANK
    336  0a2b					      REPEND
    337  0a2c		       04		      .byte.b	.BANK
    336  0a2c					      REPEND
    337  0a2d		       04		      .byte.b	.BANK
    336  0a2d					      REPEND
    337  0a2e		       04		      .byte.b	.BANK
    336  0a2e					      REPEND
    337  0a2f		       04		      .byte.b	.BANK
    336  0a2f					      REPEND
    337  0a30		       04		      .byte.b	.BANK
    336  0a30					      REPEND
    337  0a31		       04		      .byte.b	.BANK
    338  0a32					      REPEND
    339  0a32				   .BANK      SET	.BANK + 1
    335  0a32					      REPEND
    336  0a32					      REPEAT	SCREEN_WIDTH
    337  0a32		       05		      .byte.b	.BANK
    336  0a32					      REPEND
    337  0a33		       05		      .byte.b	.BANK
    336  0a33					      REPEND
    337  0a34		       05		      .byte.b	.BANK
    336  0a34					      REPEND
    337  0a35		       05		      .byte.b	.BANK
    336  0a35					      REPEND
    337  0a36		       05		      .byte.b	.BANK
    336  0a36					      REPEND
    337  0a37		       05		      .byte.b	.BANK
    336  0a37					      REPEND
    337  0a38		       05		      .byte.b	.BANK
    336  0a38					      REPEND
    337  0a39		       05		      .byte.b	.BANK
    336  0a39					      REPEND
    337  0a3a		       05		      .byte.b	.BANK
    336  0a3a					      REPEND
    337  0a3b		       05		      .byte.b	.BANK
    338  0a3c					      REPEND
    339  0a3c				   .BANK      SET	.BANK + 1
    335  0a3c					      REPEND
    336  0a3c					      REPEAT	SCREEN_WIDTH
    337  0a3c		       06		      .byte.b	.BANK
    336  0a3c					      REPEND
    337  0a3d		       06		      .byte.b	.BANK
    336  0a3d					      REPEND
    337  0a3e		       06		      .byte.b	.BANK
    336  0a3e					      REPEND
    337  0a3f		       06		      .byte.b	.BANK
    336  0a3f					      REPEND
    337  0a40		       06		      .byte.b	.BANK
    336  0a40					      REPEND
    337  0a41		       06		      .byte.b	.BANK
    336  0a41					      REPEND
    337  0a42		       06		      .byte.b	.BANK
    336  0a42					      REPEND
    337  0a43		       06		      .byte.b	.BANK
    336  0a43					      REPEND
    337  0a44		       06		      .byte.b	.BANK
    336  0a44					      REPEND
    337  0a45		       06		      .byte.b	.BANK
    338  0a46					      REPEND
    339  0a46				   .BANK      SET	.BANK + 1
    335  0a46					      REPEND
    336  0a46					      REPEAT	SCREEN_WIDTH
    337  0a46		       07		      .byte.b	.BANK
    336  0a46					      REPEND
    337  0a47		       07		      .byte.b	.BANK
    336  0a47					      REPEND
    337  0a48		       07		      .byte.b	.BANK
    336  0a48					      REPEND
    337  0a49		       07		      .byte.b	.BANK
    336  0a49					      REPEND
    337  0a4a		       07		      .byte.b	.BANK
    336  0a4a					      REPEND
    337  0a4b		       07		      .byte.b	.BANK
    336  0a4b					      REPEND
    337  0a4c		       07		      .byte.b	.BANK
    336  0a4c					      REPEND
    337  0a4d		       07		      .byte.b	.BANK
    336  0a4d					      REPEND
    337  0a4e		       07		      .byte.b	.BANK
    336  0a4e					      REPEND
    337  0a4f		       07		      .byte.b	.BANK
    338  0a50					      REPEND
    339  0a50				   .BANK      SET	.BANK + 1
    340  0a50					      REPEND
    341  0a50
      0  0a50					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  0a50
      2  0a50
      3  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $250 , FREE= $1b0
      4  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0a50				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0a50				  -	      ERR
      8  0a50					      endif
    343  0a50
    344  0a50
      0  0a50					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $250 , FREE= $5b0
      2  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0a50				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0a50				  -	      ERR
      6  0a50					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 4
      0  0a50					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  0a50							;    Sokoboo - a Sokoban implementation
      2  0a50							;    using a generic tile-based display engine for the Atari 2600
      3  0a50							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0a50							;
      5  0a50							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0a50							;
      7  0a50							;    Code related to the generic tile-based display engine was developed by
      8  0a50							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0a50							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0a50							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0a50							;
     12  0a50							;    Code related to music and sound effects uses the TIATracker music player
     13  0a50							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0a50							;    directory for Apache licensing details.
     15  0a50							;
     16  0a50							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0a50							;    See the copyright notices in the License directory for a list of level
     18  0a50							;    contributors.
     19  0a50							;
     20  0a50							;    Except where otherwise indicated, this software is released under the
     21  0a50							;    following licensing arrangement...
     22  0a50							;
     23  0a50							;    This program is free software: you can redistribute it and/or modify
     24  0a50							;    it under the terms of the GNU General Public License as published by
     25  0a50							;    the Free Software Foundation, either version 3 of the License, or
     26  0a50							;    (at your option) any later version.
     27  0a50							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0a50
     29  0a50							;    This program is distributed in the hope that it will be useful,
     30  0a50							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0a50							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0a50							;    GNU General Public License for more details.
     33  0a50
     34  0a50							;------------------------------------------------------------------------------
     35  0a50							;##############################################################################
     36  0a50							;------------------------------------------------------------------------------
      0  0a50					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  139d ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
     38  1000
     39  1000
     40  1000		       00 9a	   SCORE_COL  =	$9a	;WHITE ;-2
     41  1000		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     42  1000		       00 66	   SCORE_COL_HIGH_PAL =	$66
     43  1000
     44  1000
     45  1000				   DigitVectorLOr
     46  1000		       31 3f 4d 38*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     47  100a		       00 07 0e 15	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     48  100e				   DigitVectorLO
     49  100e		       53 61 6e 5a*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     50  1018		       37		      .byte.b	<BLANKL-1
     51  1019
     52  1019
     53  1019		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     54  1019		       00 0b	   ID_TARGET  =	11
     55  1019		       00 0c	   ID_EXTRA   =	12
     56  1019		       00 0d	   ID_CLOCK   =	13
     57  1019		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     58  1019
     59  1019							; score patch adresses:
     60  1019				   SMTblLSB
     61  1019				   SMTblTargets
     62  1019		       52 48		      .byte.b	SM_TARGET0+1-SM_BASE, SM_TARGET2+1-SM_BASE
     63  101b				   SMTblTime
     64  101b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     65  101d				   SMTblScore
     66  101d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     67  1020				   SMTblMSB
     68  1020		       4d 43		      .byte.b	SM_TARGET1+1-SM_BASE, SM_TARGET3+1-SM_BASE
     69  1022		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     70  1024		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     71  1027
     72  1027		       00 00	   SM_OFS_TARGETS =	SMTblTargets - SMTblLSB
     73  1027		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     74  1027		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     75  1027
     76  1027				   CharVectorLO
     77  1027		       37		      .byte.b	<BLANKL-1
     78  1028		       ad ad ad ad	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     79  102c		       ad ad ad ad	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     80  1030		       ad ad ad ad	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     81  1034		       ad ad ad ad	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     82  1038							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     83  1038
     84  1038							; Digit shape definitions are at start of bank so that we don't have page boundary
     85  1038							; crossing issues.
     86  1038
     87  1038							;	  .byte 0	      ; required!
     88  1038
     89  1038		       00 07	   DIGIT_H    =	7	; height of a score digit
     90  1038
     91  1038		       00 00 00 00*BLANKL     ds	7,0
     92  103f
     93  103f
     94  103f
     95  103f				   NineL
     96  103f		       1e		      .byte.b	%00011110
     97  1040		       02		      .byte.b	%00000010
     98  1041		       02		      .byte.b	%00000010
     99  1042		       fe		      .byte.b	%11111110
    100  1043		       82		      .byte.b	%10000010
    101  1044		       82		      .byte.b	%10000010
    102  1045		       fe		      .byte.b	%11111110
    103  1046
    104  1046				   SixL
    105  1046		       fe		      .byte.b	%11111110
    106  1047		       82		      .byte.b	%10000010
    107  1048		       82		      .byte.b	%10000010
    108  1049		       fe		      .byte.b	%11111110
    109  104a		       80		      .byte.b	%10000000
    110  104b		       80		      .byte.b	%10000000
    111  104c		       f0		      .byte.b	%11110000
    112  104d
    113  104d							;    .byte %01111100
    114  104d							;    .byte %11000010
    115  104d							;    .byte %11000010
    116  104d							;    .byte %11111100
    117  104d							;    .byte %11000000
    118  104d							;    .byte %01100000
    119  104d							;    .byte %00111000
    120  104d				   EightL
    121  104d
    122  104d
    123  104d		       fe		      .byte.b	%11111110
    124  104e		       82		      .byte.b	%10000010
    125  104f		       82		      .byte.b	%10000010
    126  1050		       fe		      .byte.b	%11111110
    127  1051		       82		      .byte.b	%10000010
    128  1052		       82		      .byte.b	%10000010
    129  1053		       fe		      .byte.b	%11111110
    130  1054
    131  1054							;  .byte %01111100
    132  1054							;  .byte %10000110
    133  1054							;  .byte %10000110
    134  1054							;  .byte %01111100
    135  1054							;  .byte %01000110
    136  1054							;  .byte %01000110
    137  1054							;  .byte %00111100
    138  1054				   ZeroL
    139  1054							;  .byte %01111100
    140  1054							;  .byte %10000110
    141  1054							;  .byte %10000110
    142  1054							;  .byte %10000110
    143  1054							;  .byte %10000110
    144  1054							;  .byte %01000110
    145  1054							;  .byte %00111100
    146  1054
    147  1054		       fe		      .byte.b	%11111110
    148  1055		       82		      .byte.b	%10000010
    149  1056		       82		      .byte.b	%10000010
    150  1057		       82		      .byte.b	%10000010
    151  1058		       82		      .byte.b	%10000010
    152  1059		       82		      .byte.b	%10000010
    153  105a		       fe		      .byte.b	%11111110
    154  105b
    155  105b				   ThreeL
    156  105b		       fe		      .byte.b	%11111110
    157  105c		       02		      .byte.b	%00000010
    158  105d		       02		      .byte.b	%00000010
    159  105e		       1e		      .byte.b	%00011110
    160  105f		       02		      .byte.b	%00000010
    161  1060		       02		      .byte.b	%00000010
    162  1061		       fe		      .byte.b	%11111110
    163  1062				   OneL
    164  1062		       10		      .byte.b	%00010000
    165  1063		       10		      .byte.b	%00010000
    166  1064		       10		      .byte.b	%00010000
    167  1065		       10		      .byte.b	%00010000
    168  1066		       10		      .byte.b	%00010000
    169  1067		       10		      .byte.b	%00010000
    170  1068		       10		      .byte.b	%00010000
    171  1069
    172  1069				   SevenL
    173  1069
    174  1069		       10		      .byte.b	%00010000
    175  106a		       10		      .byte.b	%00010000
    176  106b		       10		      .byte.b	%00010000
    177  106c		       1e		      .byte.b	%00011110
    178  106d		       02		      .byte.b	%00000010
    179  106e		       02		      .byte.b	%00000010
    180  106f							;  .byte %11111110
    181  106f
    182  106f							;    .byte %00010000
    183  106f							;    .byte %00010000
    184  106f							;    .byte %00010000
    185  106f							;    .byte %00011000
    186  106f							;    .byte %00001100
    187  106f							;    .byte %10000110
    188  106f							;    ;.byte %11111110
    189  106f				   TwoL
    190  106f		       fe		      .byte.b	%11111110
    191  1070		       80		      .byte.b	%10000000
    192  1071		       80		      .byte.b	%10000000
    193  1072		       fe		      .byte.b	%11111110
    194  1073		       02		      .byte.b	%00000010
    195  1074		       02		      .byte.b	%00000010
    196  1075		       fe		      .byte.b	%11111110
    197  1076
    198  1076				   FiveL
    199  1076		       fe		      .byte.b	%11111110
    200  1077		       02		      .byte.b	%00000010
    201  1078		       02		      .byte.b	%00000010
    202  1079		       fe		      .byte.b	%11111110
    203  107a		       80		      .byte.b	%10000000
    204  107b		       80		      .byte.b	%10000000
    205  107c		       f0		      .byte.b	%11110000
    206  107d
    207  107d				   FourL
    208  107d		       10		      .byte.b	%00010000
    209  107e		       10		      .byte.b	%00010000
    210  107f		       10		      .byte.b	%00010000
    211  1080		       fe		      .byte.b	%11111110
    212  1081		       90		      .byte.b	%10010000
    213  1082		       90		      .byte.b	%10010000
    214  1083		       90		      .byte.b	%10010000
    215  1084
    216  1084
    217  1084				   ZL
    218  1084		       7f		      .byte.b	%01111111
    219  1085		       40		      .byte.b	%01000000
    220  1086		       40		      .byte.b	%01000000
    221  1087		       7f		      .byte.b	%01111111
    222  1088		       01		      .byte.b	%00000001
    223  1089		       01		      .byte.b	%00000001
    224  108a		       0f		      .byte.b	%00001111
    225  108b
    226  108b				   EL
    227  108b		       7f		      .byte.b	%01111111
    228  108c		       40		      .byte.b	%01000000
    229  108d		       40		      .byte.b	%01000000
    230  108e		       78		      .byte.b	%01111000
    231  108f		       40		      .byte.b	%01000000
    232  1090		       40		      .byte.b	%01000000
    233  1091		       7f		      .byte.b	%01111111
    234  1092
    235  1092				   RL
    236  1092		       48		      .byte.b	%01001000
    237  1093		       48		      .byte.b	%01001000
    238  1094		       48		      .byte.b	%01001000
    239  1095		       7f		      .byte.b	%01111111
    240  1096		       41		      .byte.b	%01000001
    241  1097		       41		      .byte.b	%01000001
    242  1098		       7f		      .byte.b	%01111111
    243  1099
    244  1099				   PL
    245  1099		       40		      .byte.b	%01000000
    246  109a		       40		      .byte.b	%01000000
    247  109b		       40		      .byte.b	%01000000
    248  109c		       7f		      .byte.b	%01111111
    249  109d		       41		      .byte.b	%01000001
    250  109e		       41		      .byte.b	%01000001
    251  109f		       7f		      .byte.b	%01111111
    252  10a0
    253  10a0				   AL
    254  10a0		       41		      .byte.b	%01000001
    255  10a1		       41		      .byte.b	%01000001
    256  10a2		       41		      .byte.b	%01000001
    257  10a3		       7f		      .byte.b	%01111111
    258  10a4		       41		      .byte.b	%01000001
    259  10a5		       41		      .byte.b	%01000001
    260  10a6		       7f		      .byte.b	%01111111
    261  10a7
    262  10a7				   GL
    263  10a7		       7f		      .byte.b	%01111111
    264  10a8		       41		      .byte.b	%01000001
    265  10a9		       41		      .byte.b	%01000001
    266  10aa		       4f		      .byte.b	%01001111
    267  10ab		       40		      .byte.b	%01000000
    268  10ac		       40		      .byte.b	%01000000
    269  10ad		       7f		      .byte.b	%01111111
    270  10ae
    271  10ae
    272  10ae							; level "name" characters (left only!):
    273  10ae
    274  10ae				   CharN
    275  10ae				   CharK
    276  10ae				   CharH
    277  10ae				   CharA
    278  10ae				   CharJ
    279  10ae				   CharP
    280  10ae				   CharB
    281  10ae				   CharO
    282  10ae				   CharC
    283  10ae				   CharI
    284  10ae				   CharD
    285  10ae				   CharG
    286  10ae				   CharE
    287  10ae				   CharL
    288  10ae				   CharF
    289  10ae				   CharM
    290  10ae		       00 00 00 00*	      ds	7,0
    291  10b5
    292  10b5				   charPlace
    293  10b5		       0c		      .byte.b	%00001100
    294  10b6		       0c		      .byte.b	%00001100
    295  10b7		       0c		      .byte.b	%00001100
    296  10b8		       0c		      .byte.b	%00001100
    297  10b9		       0c		      .byte.b	%00001100
    298  10ba		       00		      .byte.b	%00000000
    299  10bb		       0c		      .byte.b	%00001100
    300  10bc
    301  10bc							;-------------------------------------------------------------------------------------
    302  10bc				   PosTbl
    303  10bc		       40		      .byte.b	$40
    304  10bd		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    305  10c5		       b9		      .byte.b	$b9
    306  10c6
    307  10c6
    308  10c6							;------------------------------------------------------------------------------
    309  10c6							; RAM-BASED SUBROUTINES...
    310  10c6							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    311  10c6							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    312  10c6							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    313  10c6							; the RAM-based routine.
    314  10c6
    315  1100		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    316  1100
    317  1100		       f1 00	   SM_BASE    =	.
    318  1100
    319  1100							;#IF 0 ;{
    320  1100							;    DEFINE_SUBROUTINE Score3x3
    321  1100							;
    322  1100							;	  sta	  RESP0
    323  1100							;	   sta	   RESP1
    324  1100							;	   lda	   #$$000
    325  1100							;	    sta     GRP0
    326  1100							;	    lda     #$$009
    327  1100							;	    sta     GRP1
    328  1100							;	    lda     #$$202
    329  1100							;	    sta     ENABL
    330  1100							;	    nop
    331  1100							;	    nop
    332  1100							;	    nop
    333  1100							;	    lda     #$$016
    334  1100							;	    ldy     #$$100
    335  1100							;	    ldx     #$$109
    336  1100							;	    sta     GRP0    ; Critical time is right here
    337  1100							;	    stx     GRP1
    338  1100							;	    sty     GRP0
    339  1100							;	    sta     RESP0
    340  1100							;	    sta     RESP1
    341  1100							;	    ldx     #$$116
    342  1100							;	    lda     #$$209
    343  1100							;	    stx     GRP0
    344  1100							;	    sta     GRP1
    345  1100							;	    lda     #$$200
    346  1100							;	    sta     GRP0
    347  1100							;	    sta     RESP0
    348  1100							;	    sta     RESP1
    349  1100							;	    lda     #$$216
    350  1100							;	    nop
    351  1100							;	    sta     GRP0
    352  1100							;
    353  1100							;	      rts
    354  1100							;#ENDIF ;}
    355  1100
    356  1100
    357  1100							;------------------------------------------------------------------------------
    358  1100				   Score1x6Fix SUBROUTINE
      0  1100					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  1100		       00 02	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  1100					      SUBROUTINE
      3  1100				   DrawDigits1x6
    360  1100							;					     @07
    361  1100		       ba		      tsx		; 2
    362  1101
    363  1101		       20 f0 f1 	      jsr	PrepareDrawDigits	;56 = 58    @65
    364  1104
    365  1104		       86 dc		      stx	tmpStack	; 3 =	3
    366  1106
    367  1106				   LoopDraw1x6		;
    368  1106				   SMDIGIT0
    369  1106		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    370  1109		       85 42		      sta	WSYNC	; 3
    371  110b							;---------------------------------------------------------------
    372  110b		       85 6a		      sta	HMOVE	; 3
      0  110d					      SLEEP	3	; 3 =	6
      1  110d				   .CYCLES    SET	3
      2  110d
      3  110d				  -	      IF	.CYCLES < 2
      4  110d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  110d				  -	      ERR
      6  110d					      ENDIF
      7  110d
      8  110d					      IF	.CYCLES & 1
      9  110d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  110d		       04 00		      nop	0
     11  110f				  -	      ELSE
     12  110f				  -	      bit	VSYNC
     13  110f					      ENDIF
     14  110f				   .CYCLES    SET	.CYCLES - 3
     15  110f					      ENDIF
     16  110f
     17  110f				  -	      REPEAT	.CYCLES / 2
     18  110f				  -	      nop
     19  110f					      REPEND
    374  110f		       85 5b		      sta	GRP0	; 3
    375  1111				   SMDIGIT1
    376  1111		       b9 53 f0 	      lda	ZeroL-1,y	; 4
    377  1114		       85 5c		      sta	GRP1	; 3
    378  1116				   SMDIGIT2
    379  1116		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    380  1119		       85 5b		      sta	GRP0	; 3 = 17
    381  111b				   SMDIGIT5
    382  111b		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    383  111e		       9a		      txs		; 2
    384  111f				   SMDIGIT3
    385  111f		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    386  1122				   SMDIGIT4
    387  1122		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    388  1125		       85 6b		      sta	HMCLR	; 3
    389  1127		       86 5c		      stx	GRP1	; 3
    390  1129		       85 5b		      sta	GRP0	; 3 = 23
    391  112b
    392  112b		       ba		      tsx		; 2
    393  112c		       86 5c		      stx	GRP1	; 3
    394  112e		       85 5b		      sta	GRP0	; 3 =	8
    395  1130
    396  1130		       88		      dey		; 2
      0  1131					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  1131					      LIST	ON
      9  1131		       d0 d3		      bne	LoopDraw1x6
    398  1133
    399  1133		       a6 dc		      ldx	tmpStack	; 3
    400  1135		       9a		      txs		; 2
    401  1136				   ExitDigitKernel6
      0  1136					      SLEEP	3	; 3
      1  1136				   .CYCLES    SET	3
      2  1136
      3  1136				  -	      IF	.CYCLES < 2
      4  1136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1136				  -	      ERR
      6  1136					      ENDIF
      7  1136
      8  1136					      IF	.CYCLES & 1
      9  1136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1136		       04 00		      nop	0
     11  1138				  -	      ELSE
     12  1138				  -	      bit	VSYNC
     13  1138					      ENDIF
     14  1138				   .CYCLES    SET	.CYCLES - 3
     15  1138					      ENDIF
     16  1138
     17  1138				  -	      REPEAT	.CYCLES / 2
     18  1138				  -	      nop
     19  1138					      REPEND
    403  1138		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    404  113b
    405  113b
    406  113b							;------------------------------------------------------------------------------
    407  113b				   Score2x4Fix SUBROUTINE
      0  113b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  113b		       00 02	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  113b					      SUBROUTINE
      3  113b				   DrawDigits2x4
    409  113b
    410  113b
    411  113b							; Subroutine by Thomas Jentzsch.  Magic!
    412  113b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    413  113b
    414  113b							;sta COLUBK
    415  113b
    416  113b		       20 f0 f1 	      jsr	PrepareDrawDigits	;56 = 56    @63
    417  113e
    418  113e		       85 6a		      sta	HMOVE	; 3
      0  1140					      SLEEP	4	; 4  =  7
      1  1140				   .CYCLES    SET	4
      2  1140
      3  1140				  -	      IF	.CYCLES < 2
      4  1140				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1140				  -	      ERR
      6  1140					      ENDIF
      7  1140
      8  1140				  -	      IF	.CYCLES & 1
      9  1140				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1140				  -	      nop	0
     11  1140				  -	      ELSE
     12  1140				  -	      bit	VSYNC
     13  1140				  -	      ENDIF
     14  1140				  -.CYCLES    SET	.CYCLES - 3
     15  1140					      ENDIF
     16  1140
     17  1140					      REPEAT	.CYCLES / 2
     18  1140		       ea		      nop
     17  1140					      REPEND
     18  1141		       ea		      nop
     19  1142					      REPEND
    420  1142
    421  1142				   LoopDraw2x4		;	     @70
    422  1142				   SM_TARGET3
    423  1142		       b9 07 f3 	      lda	DequalsR-1,y	; 4		     G
    424  1145							;---------------------------------------------------------------
    425  1145		       85 5b		      sta	GRP0	; 3
    426  1147				   SM_TARGET2
    427  1147		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     A
    428  114a		       85 5c		      sta	GRP1	; 3
    429  114c				   SM_TARGET1
    430  114c		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     M
    431  114f		       85 5b		      sta	GRP0	; 3
    432  1151				   SM_TARGET0
    433  1151		       be 53 f0 	      ldx	ZeroL-1,y	; 4		     E
    434  1154		       85 50		      sta	RESP0	; 3 = 28    @22
    435  1156		       85 51		      sta	RESP1	; 3 =	3    @25
    436  1158				   SM_Time3
    437  1158		       b9 15 f3 	      lda	ClockR-1,y	; 4		     O
    438  115b		       86 5c		      stx	GRP1	; 3
    439  115d		       85 5b		      sta	GRP0	; 3
    440  115f				   SM_Time2
    441  115f		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     V
    442  1162		       85 5c		      sta	GRP1	; 3
    443  1164				   SM_Time1
    444  1164		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     E
    445  1167		       85 5b		      sta	GRP0	; 3
    446  1169		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    447  116b		       85 51		      sta	RESP1	; 3 =	3    @55
    448  116d				   SM_Time0
    449  116d		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     R
    450  1170		       85 5c		      sta	GRP1	; 3
    451  1172		       85 5b		      sta	GRP0	; 3
    452  1174		       88		      dey		; 2
      0  1175					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  1175					      LIST	ON
      9  1175		       d0 cb		      bne	LoopDraw2x4
    454  1177
    455  1177				   ExitDigitKernel		;	     @69
    456  1177		       84 5b		      sty	GRP0	; 3
    457  1179		       84 5c		      sty	GRP1	; 3
    458  117b							;---------------------------------------------------------------
    459  117b		       84 5b		      sty	GRP0	; 3	     @02
    460  117d
    461  117d							; Contribution by Thomas Jentzsch
    462  117d							; Rewrite/Optimised for single sprite AD
    463  117d
    464  117d		       a6 9d		      ldx	ManDrawX	; 3
    465  117f		       bd bc f0 	      lda	PosTbl,x	; 4
    466  1182		       85 60		      sta	HMP0	; 3
    467  1184		       29 0f		      and	#$0f	; 2
    468  1186		       f0 04		      beq	.zeroPos	; 2/3=15
    469  1188		       aa		      tax		; 2
    470  1189				   .loopWait
    471  1189		       ca		      dex		; 2
    472  118a		       d0 fd		      bne	.loopWait	; 2/3= 6
    473  118c				   .zeroPos
    474  118c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    475  118e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    476  1190		       a5 b5		      lda	BGColour	; 3
    477  1192		       86 62		      stx	HMM0	; 3	     for extra life stars!
    478  1194		       85 42		      sta	WSYNC	; 3
    479  1196							;    sta WSYNC
    480  1196							;    sta WSYNC
    481  1196							;---------------------------------------------------------------
    482  1196		       85 6a		      sta	HMOVE	; 3
    483  1198		       85 49		      sta	COLUBK
    484  119a		       60		      rts		; 6	     @09
    485  119b
    486  119b							;------------------------------------------------------------------------------
    487  119b				   Score3x2Fix SUBROUTINE
      0  119b					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  119b		       00 02	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  119b					      SUBROUTINE
      3  119b				   DrawDigits3x2
    489  119b							;					     @07
    490  119b		       a9 16		      lda	#%010110	; 2
    491  119d		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    492  119f		       20 f6 f1 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    493  11a2
    494  11a2		       a9 00		      lda	#0
    495  11a4		       85 66		      sta	VDELP1
    496  11a6				   LoopDraw3x2		;
    497  11a6		       85 42		      sta	WSYNC	; 3
    498  11a8							;---------------------------------------------------------------
    499  11a8		       85 6a		      sta	HMOVE	; 3 =	3
    500  11aa		       b9 ad f0 	      lda	CharP-1,y	; 4
    501  11ad		       85 5b		      sta	GRP0	; 3
    502  11af				   SMPLAYER
    503  11af		       b9 3f f3 	      lda	OneR-1,y	; 4
    504  11b2		       85 5c		      sta	GRP1	; 3 = 14    @17
    505  11b4		       b9 b4 f0 	      lda	charPlace-1,y	; 4
    506  11b7				   SMMEN
    507  11b7		       be 38 f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  11ba					      SLEEP	5	;   =	5
      1  11ba				   .CYCLES    SET	5
      2  11ba
      3  11ba				  -	      IF	.CYCLES < 2
      4  11ba				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11ba				  -	      ERR
      6  11ba					      ENDIF
      7  11ba
      8  11ba					      IF	.CYCLES & 1
      9  11ba					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11ba		       04 00		      nop	0
     11  11bc				  -	      ELSE
     12  11bc				  -	      bit	VSYNC
     13  11bc					      ENDIF
     14  11bc				   .CYCLES    SET	.CYCLES - 3
     15  11bc					      ENDIF
     16  11bc
     17  11bc					      REPEAT	.CYCLES / 2
     18  11bc		       ea		      nop
     19  11bd					      REPEND
    509  11bd		       85 5b		      sta	GRP0	; 3
    510  11bf				   SMLEVELX
    511  11bf		       b9 ad f0 	      lda	CharA-1,y	; 4
    512  11c2		       85 6b		      sta	HMCLR	; 3 = 10    @40
    513  11c4		       86 5c		      stx	GRP1	; 3 =	3    @43
    514  11c6		       85 5b		      sta	GRP0	; 3
    515  11c8				   SMLEVEL
    516  11c8		       b9 3f f3 	      lda	OneR-1,y	; 4
    517  11cb		       85 5c		      sta	GRP1	; 3 = 10    @53
    518  11cd
    519  11cd		       88		      dey		; 2
      0  11ce					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  11ce					      LIST	ON
      9  11ce		       d0 d6		      bne	LoopDraw3x2
    521  11d0							;					     @57
      0  11d0					      SLEEP	3	; 3
      1  11d0				   .CYCLES    SET	3
      2  11d0
      3  11d0				  -	      IF	.CYCLES < 2
      4  11d0				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11d0				  -	      ERR
      6  11d0					      ENDIF
      7  11d0
      8  11d0					      IF	.CYCLES & 1
      9  11d0					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11d0		       04 00		      nop	0
     11  11d2				  -	      ELSE
     12  11d2				  -	      bit	VSYNC
     13  11d2					      ENDIF
     14  11d2				   .CYCLES    SET	.CYCLES - 3
     15  11d2					      ENDIF
     16  11d2
     17  11d2				  -	      REPEAT	.CYCLES / 2
     18  11d2				  -	      nop
     19  11d2					      REPEND
    523  11d2		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    524  11d5
    525  11d5
    526  11d5							;------------------------------------------------------------------------------
      0  11d5					      DEFINE_SUBROUTINE	DrawDigits
      1  11d5		       00 02	   BANK_DrawDigits =	_CURRENT_BANK
      2  11d5					      SUBROUTINE
      3  11d5				   DrawDigits
    528  11d5
    529  11d5				   VblankLoopGame
    530  11d5							;jsr StealCharDraw
    531  11d5		       ac 84 02 	      ldy	INTIM
    532  11d8		       d0 fb		      bne	VblankLoopGame
    533  11da
    534  11da		       84 41		      sty	VBLANK	; 3	     <-- 0
    535  11dc		       a5 cb		      lda	scoringFlags	; 3
    536  11de		       29 03		      and	#DISPLAY_FLAGS	; 2
    537  11e0		       aa		      tax		; 2
    538  11e1
    539  11e1							;    DEFINE_SUBROUTINE DrawDigit2
    540  11e1							;
    541  11e1							;    ; Generic interface to scoring routine
    542  11e1
    543  11e1		       bd ec f1 	      lda	ScoreKernelLo,x	; 4
    544  11e4
    545  11e4		       85 42		      sta	WSYNC	; 3
    546  11e6							;---------------------------------------------------------------
    547  11e6		       8d ea f5 	      sta	SMJUMP+1+RAM_WRITE	; 4
    548  11e9				   SMJUMP
    549  11e9		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    550  11ec
    551  11ec				   ScoreKernelLo
    552  11ec		       3b		      .byte.b	<Score2x4Fix	; TARGETs, time
    553  11ed		       00		      .byte.b	<Score1x6Fix	; score
    554  11ee		       9b		      .byte.b	<Score3x2Fix	; player, lives, level
    555  11ef		       00		      .byte.b	<Score1x6Fix	; high score
    556  11f0
      0  11f0					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  11f0					      LIST	ON
    558  11f0
    559  11f0							;------------------------------------------------------------------------------
      0  11f0					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  11f0		       00 02	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  11f0					      SUBROUTINE
      3  11f0				   PrepareDrawDigits
    561  11f0							;					     @13
    562  11f0		       a0 d1		      ldy	#$d1	; 2
    563  11f2		       a9 13		      lda	#%010011	; 2
    564  11f4		       85 66		      sta	VDELP1	; 3 =	7
    565  11f6				   PrepareDrawDigits2		;	    @17/20
    566  11f6		       84 65		      sty	VDELP0	; 3 =	3
    567  11f8
    568  11f8		       85 45		      sta	NUSIZ1	; 3
    569  11fa		       85 44		      sta	NUSIZ0	; 3 =	6
    570  11fc
    571  11fc		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    572  11ff		       85 50		      sta	RESP0	; 3	     @33/36
    573  1201		       85 51		      sta	RESP1	; 3 = 10    @36/39
    574  1203
    575  1203		       84 60		      sty	HMP0	; 3
    576  1205		       c8		      iny		; 2
    577  1206		       84 61		      sty	HMP1	; 3 =	8
    578  1208				   SMCOLOR
    579  1208		       a0 9a		      ldy	#SCORE_COL	; 2
    580  120a		       84 46		      sty	COLUP0	; 3
    581  120c		       84 47		      sty	COLUP1	; 3 =	8
    582  120e
    583  120e		       a0 07		      ldy	#DIGIT_H	; 2
    584  1210		       60		      rts		; 6 =	8
    585  1211							; total: 27
    586  1211
    587  1211
    588  1211							;------------------------------------------------------------------------------
      0  1211					      DEFINE_SUBROUTINE	UpdateScore
      1  1211		       00 02	   BANK_UpdateScore =	_CURRENT_BANK
      2  1211					      SUBROUTINE
      3  1211				   UpdateScore
    590  1211							; a = added score value
    591  1211
    592  1211							; initially switch to score:
    593  1211		       a0 01		      ldy	#DISPLAY_SCORE
    594  1213		       84 dc		      sty	newDisplay
    595  1215
    596  1215		       18		      clc
    597  1216		       f8		      sed
    598  1217		       a0 04		      ldy	#SM_OFS_SCORE
    599  1219				   .loopScore
    600  1219		       79 8a f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    601  121c		       99 8a f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    602  121f		       08		      php
    603  1220							; *** bonus life every 500 points: ***
    604  1220							;	  cpy #SM_OFS_SCORE+1
    605  1220							;	  bne .skipBonusLife
    606  1220							;	  tax
    607  1220
    608  1220							;	  and #$0f
    609  1220							;	  beq .bonusLife		      ; 000?
    610  1220							;	  cmp #$05
    611  1220							;	  bne .noBonusLife		      ; 500?
    612  1220							;.bonusLife:
    613  1220							; add extra life, limited to 9
    614  1220
    615  1220							;	  lda ManCount
    616  1220							;	  and #$0f
    617  1220							;	  cmp #9
    618  1220							;	  bcs .noBonusLife
    619  1220							;	  inc ManCount
    620  1220
    621  1220							; bonus life has priority over score:
    622  1220							;	  lda #DISPLAY_LIVES
    623  1220							;	  sta newDisplay
    624  1220							;lda #EXTRA_LIFE_TIMER
    625  1220							;sta extraLifeTimer
    626  1220
    627  1220				   .noBonusLife
    628  1220		       8a		      txa
    629  1221				   .skipBonusLife
    630  1221		       20 d6 f2 	      jsr	SetupBCDPtr
    631  1224		       28		      plp
    632  1225		       a9 00		      lda	#0
    633  1227		       b0 f0		      bcs	.loopScore
    634  1229		       d8		      cld
    635  122a
    636  122a							; switch display
    637  122a		       a5 cb		      lda	scoringFlags
    638  122c		       29 03		      and	#DISPLAY_FLAGS
    639  122e		       c5 dc		      cmp	newDisplay	; lower priority than current?
    640  1230		       f0 08		      beq	.restartTime
    641  1232		       b0 0a		      bcs	.skipNew
    642  1234		       45 cb		      eor	scoringFlags	; remove existing score mode
    643  1236		       05 dc		      ora	newDisplay	; switch to new score mode
    644  1238		       85 cb		      sta	scoringFlags
    645  123a				   .restartTime
    646  123a		       a9 3c		      lda	#SCORING_TIMER	; maybe always restart timer?
    647  123c		       85 ca		      sta	scoringTimer
    648  123e				   .skipNew
    649  123e
    650  123e		       60		      rts
    651  123f
    652  123f							;---------------------------------------------------------------------------
    653  123f
      0  123f					      DEFINE_SUBROUTINE	SwapPlayers
      1  123f		       00 02	   BANK_SwapPlayers =	_CURRENT_BANK
      2  123f					      SUBROUTINE
      3  123f				   SwapPlayers
    655  123f
    656  123f							; assume no new high score:
    657  123f		       a0 ff		      ldy	#-1
    658  1241		       84 df		      sty	highScoreSK
    659  1243
    660  1243							; update highscore after last live:
    661  1243		       a5 a7		      lda	ManCount
    662  1245		       29 0f		      and	#$0f	; player has lives left?
    663  1247		       d0 1c		      bne	.playerAlive	; YES, so we don't check high score
    664  1249
    665  1249							; check for a new high score:
    666  1249							;	  ldy #-1
    667  1249		       18		      clc		; score has to be at least 1 bigger!
    668  124a				   .loopCheckHighScore
    669  124a		       c8		      iny
    670  124b		       b9 8e f3 	      lda	ScoreCurrent,y
    671  124e		       f9 98 f3 	      sbc	HighScore,y
    672  1251		       98		      tya
    673  1252		       49 02		      eor	#2
    674  1254		       d0 f4		      bne	.loopCheckHighScore
    675  1256		       90 0d		      bcc	.noHighScore
    676  1258
    677  1258							; new high score, update:
    678  1258		       a2 04		      ldx	#5-1
    679  125a				   .loopSetHighScore
    680  125a		       bd 8e f3 	      lda	ScoreCurrent,x
    681  125d		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
    682  1260		       95 df		      sta	highScoreSK,x
    683  1262		       ca		      dex
    684  1263		       10 f5		      bpl	.loopSetHighScore
    685  1265				   .noHighScore
    686  1265
    687  1265				   .playerAlive
    688  1265		       a5 a7		      lda	ManCount
    689  1267		       29 f0		      and	#$f0	; other player has lives left?
    690  1269		       f0 21		      beq	.otherPlayerDead	; NO, so we don't swap scores
    691  126b
    692  126b							; save the current player variables to the player's backup:
    693  126b		       a0 02		      ldy	#3-1
    694  126d				   .swapScore
    695  126d		       be 93 f3 	      ldx	PlayerScores,y
    696  1270		       b9 8e f3 	      lda	ScoreCurrent,y
    697  1273		       99 93 f7 	      sta	PlayerScores+RAM_WRITE,y
    698  1276		       8a		      txa
    699  1277		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
    700  127a		       88		      dey
    701  127b		       10 f0		      bpl	.swapScore
    702  127d
    703  127d							; swap levelx and level:
    704  127d		       a2 01		      ldx	#1
    705  127f				   .loopLevelXLevel
    706  127f		       bc 96 f3 	      ldy	PlayerLevelX,x
    707  1282		       b5 b6		      lda	levelX,x
    708  1284		       9d 96 f7 	      sta	PlayerLevelX+RAM_WRITE,x
    709  1287		       94 b6		      sty	levelX,x
    710  1289		       ca		      dex
    711  128a		       10 f3		      bpl	.loopLevelXLevel
    712  128c
    713  128c				   .otherPlayerDead
    714  128c		       60		      rts
    715  128d
    716  128d							;---------------------------------------------------------------------------
    717  128d
    718  128d				   HighScoreColTbl
    719  128d		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    720  128f		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    721  1291
      0  1291					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  1291		       00 02	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  1291					      SUBROUTINE
      3  1291				   GeneralScoringSetups
    723  1291
    724  1291		       a0 04		      ldy	#SM_OFS_SCORE
    725  1293				   .loopScore2
    726  1293		       a5 cb		      lda	scoringFlags
    727  1295		       29 03		      and	#DISPLAY_FLAGS
    728  1297		       c9 03		      cmp	#DISPLAY_HIGH
    729  1299		       a6 81		      ldx	Platform
    730  129b		       bd 8d f2 	      lda	HighScoreColTbl,x
    731  129e		       aa		      tax
    732  129f		       b9 94 f3 	      lda	HighScore-SM_OFS_SCORE,y
    733  12a2		       b0 05		      bcs	.showHighScore
    734  12a4		       a2 9a		      ldx	#SCORE_COL
    735  12a6		       b9 8a f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    736  12a9				   .showHighScore
    737  12a9		       8e 09 f6 	      stx	SMCOLOR+1+RAM_WRITE
    738  12ac		       20 d6 f2 	      jsr	SetupBCDPtr
    739  12af		       c0 07		      cpy	#SM_OFS_SCORE+3
    740  12b1		       90 e0		      bcc	.loopScore2
    741  12b3
    742  12b3							; display number of lives in leftmost digit of middle score XX nX XX
    743  12b3
    744  12b3							;lda ManCount
    745  12b3							;and #$0f
    746  12b3							;tay
    747  12b3							;lda DigitVectorLOr,y
    748  12b3							;sta SMMEN+1+RAM_WRITE
    749  12b3
    750  12b3							; modify player number pointer (Xp XX XX)
    751  12b3
    752  12b3							;ldy whichPlayer
    753  12b3							;lda DigitVectorLOr+1,y
    754  12b3							;sta SMPLAYER+1+RAM_WRITE
    755  12b3
    756  12b3							; fall through
    757  12b3
    758  12b3							;    ;---------------------------------------------------------------------------
    759  12b3
    760  12b3							; modify levelx character pointer (XX XX cX)
    761  12b3
    762  12b3							;ldx #<charPlace-1
    763  12b3							;lda levelDisplay
    764  12b3							;cmp #$80
    765  12b3							;and #$1f
    766  12b3							;tay
    767  12b3							;bcs .intermission
    768  12b3							;ldx CharVectorLO,y
    769  12b3							;ldy level
    770  12b3							;.intermission
    771  12b3							;stx SMLEVELX+1+RAM_WRITE
    772  12b3
    773  12b3							; modify level number pointer (XX XX Xl)
    774  12b3
    775  12b3							;lda DigitVectorLOr+1,y
    776  12b3							;sta SMLEVEL+1+RAM_WRITE
    777  12b3
    778  12b3							;---------------------------------------------------------------------------
    779  12b3
    780  12b3		       4c cd f2 	      jmp	SetupTimePtr	; modify time pointers
    781  12b6
    782  12b6							;------------------------------------------------------------------------------
    783  12b6							;    DEFINE_SUBROUTINE SetupGameOverPtr
    784  12b6
    785  12b6							;		  ldy #8-1
    786  12b6							;.loopGameOver:
    787  12b6							;		  ldx SMGameOverOfs,y
    788  12b6							;		  lda SMGameOverPtr,y
    789  12b6							;		  sta SM_BASE+1+RAM_WRITE,x
    790  12b6							;		  dey
    791  12b6							;		  bpl .loopGameOver
    792  12b6
    793  12b6							;		  rts
    794  12b6
    795  12b6							;SMGameOverOfs:
    796  12b6							;		  .byte <SM_TARGET3-SM_BASE, <SM_TARGET2-SM_BASE
    797  12b6							;		  .byte <SM_TARGET1-SM_BASE, <SM_TARGET0-SM_BASE
    798  12b6							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    799  12b6							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    800  12b6							;SMGameOverPtr:
    801  12b6							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    802  12b6							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    803  12b6
    804  12b6							;------------------------------------------------------------------------------
    805  12b6
      0  12b6					      DEFINE_SUBROUTINE	DrawTargetsRequired
      1  12b6		       00 02	   BANK_DrawTargetsRequired =	_CURRENT_BANK
      2  12b6					      SUBROUTINE
      3  12b6				   DrawTargetsRequired
    807  12b6							; Show current TARGET counter in the top left
    808  12b6
    809  12b6		       a0 00		      ldy	#SM_OFS_TARGETS
    810  12b8		       a5 bb		      lda	targetsRequired
    811  12ba		       20 d6 f2 	      jsr	SetupBCDPtr
    812  12bd
    813  12bd		       a9 b0		      lda	#ID_TARGET<<4	; if no extra targets, display the normal icon
    814  12bf		       24 cb		      bit	scoringFlags	;
    815  12c1		       10 13		      bpl	SetupBCDPtr
    816  12c3		       a9 c0		      lda	#ID_EXTRA<<4	; otherwise, display the extra icon
    817  12c5		       50 0f		      bvc	SetupBCDPtr
    818  12c7		       09 01		      ora	#1	; display 1xx targets
    819  12c9		       d0 0b		      bne	SetupBCDPtr	; unconditional
    820  12cb
    821  12cb							;------------------------------------------------------------------------------
      0  12cb					      DEFINE_SUBROUTINE	DrawTime
      1  12cb		       00 02	   BANK_DrawTime =	_CURRENT_BANK
      2  12cb					      SUBROUTINE
      3  12cb				   DrawTime
    823  12cb
    824  12cb							; mid-digit-change, but we may be required to flash/display
    825  12cb		       a0 02		      ldy	#SM_OFS_TIME
    826  12cd							;------------------------------------------------------------------------------
      0  12cd					      DEFINE_SUBROUTINE	SetupTimePtr
      1  12cd		       00 02	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  12cd					      SUBROUTINE
      3  12cd				   SetupTimePtr
    828  12cd
    829  12cd		       a5 bc		      lda	moveCounter
    830  12cf		       20 d6 f2 	      jsr	SetupBCDPtr
    831  12d2		       a5 bd		      lda	moveCounter+1
    832  12d4		       09 d0		      ora	#ID_CLOCK<<4
    833  12d6
    834  12d6							; fall through
    835  12d6
    836  12d6							;------------------------------------------------------------------------------
      0  12d6					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  12d6		       00 02	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  12d6					      SUBROUTINE
      3  12d6				   SetupBCDPtr
    838  12d6
    839  12d6							; a = BCD value
    840  12d6							; y = SM table offset
    841  12d6
    842  12d6		       48		      pha
    843  12d7		       29 0f		      and	#$0f
    844  12d9		       aa		      tax
    845  12da		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    846  12dd		       be 19 f0 	      ldx	SMTblLSB,y
    847  12e0		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    848  12e3		       68		      pla
    849  12e4		       4a		      lsr
    850  12e5		       4a		      lsr
    851  12e6		       4a		      lsr
    852  12e7		       4a		      lsr
    853  12e8		       aa		      tax
    854  12e9		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    855  12ec		       be 20 f0 	      ldx	SMTblMSB,y
    856  12ef		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    857  12f2
    858  12f2		       c8		      iny
    859  12f3
    860  12f3		       a5 c6		      lda	ROM_Bank
    861  12f5				   RTS
    862  12f5		       60		      rts
    863  12f6
      0  12f6					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
 PAGE BREAK INSERTED FOR  LeftDigits
 REQUESTED SIZE =  $5b
 WASTED SPACE =  $a
 PAGEBREAK LOCATION =  $f300
     10  1300					      LIST	ON
    865  1300
    866  1300					      IF	<. = 0
    867  1300		       00		      .byte.b	0	; required!
    868  1301					      ENDIF
    869  1301
    870  1301				   BLANKR
    871  1301		       00 00 00 00*	      .ds	DIGIT_H, 0
    872  1308
    873  1308				   DequalsR
    874  1308		       00		      .byte.b	%00000000
    875  1309		       00		      .byte.b	%00000000
    876  130a		       f0		      .byte.b	%11110000
    877  130b		       00		      .byte.b	%00000000
    878  130c		       f0		      .byte.b	%11110000
    879  130d		       00		      .byte.b	%00000000
    880  130e		       f0		      .byte.b	%11110000
    881  130f				   DplusR
    882  130f		       10		      .byte.b	%00010000
    883  1310		       28		      .byte.b	%00101000
    884  1311		       6c		      .byte.b	%01101100
    885  1312		       c6		      .byte.b	%11000110
    886  1313		       6c		      .byte.b	%01101100
    887  1314		       28		      .byte.b	%00101000
    888  1315		       10		      .byte.b	%00010000
    889  1316
    890  1316				   ClockR
    891  1316		       00		      .byte.b	%00000000
    892  1317		       48		      .byte.b	%01001000
    893  1318		       fc		      .byte.b	%11111100
    894  1319		       48		      .byte.b	%01001000
    895  131a		       48		      .byte.b	%01001000
    896  131b		       fc		      .byte.b	%11111100
    897  131c		       48		      .byte.b	%01001000
    898  131d				   NineR
    899  131d		       0f		      .byte.b	%00001111
    900  131e		       01		      .byte.b	%00000001
    901  131f		       01		      .byte.b	%00000001
    902  1320		       7f		      .byte.b	%01111111
    903  1321		       41		      .byte.b	%01000001
    904  1322		       41		      .byte.b	%01000001
    905  1323		       7f		      .byte.b	%01111111
    906  1324				   SixR
    907  1324		       7f		      .byte.b	%01111111
    908  1325		       41		      .byte.b	%01000001
    909  1326		       41		      .byte.b	%01000001
    910  1327		       7f		      .byte.b	%01111111
    911  1328		       40		      .byte.b	%01000000
    912  1329		       40		      .byte.b	%01000000
    913  132a		       78		      .byte.b	%01111000
    914  132b				   EightR
    915  132b							;  .byte %00111110
    916  132b							;  .byte %01000011
    917  132b							;  .byte %01000011
    918  132b							;  .byte %00111110
    919  132b							;  .byte %00100011
    920  132b							;  .byte %00100011
    921  132b							;  .byte %00011110
    922  132b
    923  132b
    924  132b		       7f		      .byte.b	%01111111
    925  132c		       41		      .byte.b	%01000001
    926  132d		       41		      .byte.b	%01000001
    927  132e		       7f		      .byte.b	%01111111
    928  132f		       41		      .byte.b	%01000001
    929  1330		       41		      .byte.b	%01000001
    930  1331		       7f		      .byte.b	%01111111
    931  1332
    932  1332				   ZeroR
    933  1332		       7f		      .byte.b	%01111111
    934  1333		       41		      .byte.b	%01000001
    935  1334		       41		      .byte.b	%01000001
    936  1335		       41		      .byte.b	%01000001
    937  1336		       41		      .byte.b	%01000001
    938  1337		       41		      .byte.b	%01000001
    939  1338		       7f		      .byte.b	%01111111
    940  1339
    941  1339							;	  .byte %00111110
    942  1339							;	  .byte %01000011
    943  1339							;	  .byte %01000011
    944  1339							;	  .byte %01000011
    945  1339							;	  .byte %01000011
    946  1339							;	  .byte %00100011
    947  1339							;	  .byte %00011110
    948  1339				   ThreeR
    949  1339		       7f		      .byte.b	%01111111
    950  133a		       01		      .byte.b	%00000001
    951  133b		       01		      .byte.b	%00000001
    952  133c		       0f		      .byte.b	%00001111
    953  133d		       01		      .byte.b	%00000001
    954  133e		       01		      .byte.b	%00000001
    955  133f		       7f		      .byte.b	%01111111
    956  1340				   OneR
    957  1340		       08		      .byte.b	%00001000
    958  1341		       08		      .byte.b	%00001000
    959  1342		       08		      .byte.b	%00001000
    960  1343		       08		      .byte.b	%00001000
    961  1344		       08		      .byte.b	%00001000
    962  1345		       08		      .byte.b	%00001000
    963  1346		       08		      .byte.b	%00001000
    964  1347
    965  1347				   SevenR
    966  1347		       08		      .byte.b	%00001000
    967  1348		       08		      .byte.b	%00001000
    968  1349		       08		      .byte.b	%00001000
    969  134a		       0f		      .byte.b	%00001111
    970  134b		       01		      .byte.b	%00000001
    971  134c		       01		      .byte.b	%00000001
    972  134d		       7f		      .byte.b	%01111111
    973  134e
    974  134e				   TwoR
    975  134e		       7f		      .byte.b	%01111111
    976  134f		       40		      .byte.b	%01000000
    977  1350		       40		      .byte.b	%01000000
    978  1351		       7f		      .byte.b	%01111111
    979  1352		       01		      .byte.b	%00000001
    980  1353		       01		      .byte.b	%00000001
    981  1354		       7f		      .byte.b	%01111111
    982  1355				   FiveR
    983  1355		       7f		      .byte.b	%01111111
    984  1356		       01		      .byte.b	%00000001
    985  1357		       01		      .byte.b	%00000001
    986  1358		       7f		      .byte.b	%01111111
    987  1359		       40		      .byte.b	%01000000
    988  135a		       40		      .byte.b	%01000000
    989  135b		       78		      .byte.b	%01111000
    990  135c				   FourR
    991  135c		       08		      .byte.b	%00001000
    992  135d		       08		      .byte.b	%00001000
    993  135e		       08		      .byte.b	%00001000
    994  135f		       7f		      .byte.b	%01111111
    995  1360		       48		      .byte.b	%01001000
    996  1361		       48		      .byte.b	%01001000
    997  1362		       48		      .byte.b	%01001000
    998  1363
    999  1363							;CharAL:
   1000  1363							;    .byte %11100110
   1001  1363							;    .byte %11100110
   1002  1363							;    .byte %11111110
   1003  1363							;    .byte %11100110
   1004  1363							;    .byte %11100110
   1005  1363							;    .byte %01111100
   1006  1363							;    .byte %00111000
   1007  1363							;CharEL:
   1008  1363							;    .byte %11111110
   1009  1363							;    .byte %11111110
   1010  1363							;    .byte %11100000
   1011  1363							;    .byte %11100000
   1012  1363							;    .byte %11111100
   1013  1363							;    .byte %11100000
   1014  1363							;    .byte %11111110
   1015  1363							;CharRL:
   1016  1363							;    .byte %11100110
   1017  1363							;    .byte %11100110
   1018  1363							;    .byte %11111100
   1019  1363							;    .byte %11111100
   1020  1363							;    .byte %11100110
   1021  1363							;    .byte %11100110
   1022  1363							;    .byte %11111100
   1023  1363							;CharVL:
   1024  1363							;    .byte %00111000
   1025  1363							;    .byte %01111100
   1026  1363							;    .byte %11100110
   1027  1363							;    .byte %11100110
   1028  1363							;    .byte %11100110
   1029  1363							;    .byte %11100110
   1030  1363							;    .byte %11100110
   1031  1363
      0  1363					      CHECKPAGE	BLANKR
      8  1363					      LIST	ON
   1033  1363
   1034  1363							;---------------------------------------------------------------------------
   1035  1363
      0  1363					      DEFINE_SUBROUTINE	GameInitialise
      1  1363		       00 02	   BANK_GameInitialise =	_CURRENT_BANK
      2  1363					      SUBROUTINE
      3  1363				   GameInitialise
   1037  1363
   1038  1363							; copy loaded SK high score into scoring RAM:
   1039  1363		       a2 02		      ldx	#3-1
   1040  1365				   .loopCopyHighScore
   1041  1365		       b5 df		      lda	highScoreSK,x
   1042  1367		       c9 ff		      cmp	#$ff
   1043  1369		       f0 06		      beq	.noSaveKey
   1044  136b		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
   1045  136e		       ca		      dex
   1046  136f		       10 f4		      bpl	.loopCopyHighScore
   1047  1371				   .noSaveKey
   1048  1371
   1049  1371							; clear both players scores
   1050  1371		       a0 05		      ldy	#2*3-1
   1051  1373		       a9 00		      lda	#0
   1052  1375				   .loopClearScore
   1053  1375		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
   1054  1378		       88		      dey
   1055  1379		       10 fa		      bpl	.loopClearScore
   1056  137b
   1057  137b							; copy levelX and level for other player and SaveKey:
   1058  137b		       a5 b6		      lda	levelX
   1059  137d		       8d 96 f7 	      sta	PlayerLevelX+RAM_WRITE
   1060  1380		       a5 e2		      lda	startingLevel
   1061  1382		       8d 91 f7 	      sta	StartLevelX+RAM_WRITE
   1062  1385		       a5 b7		      lda	level
   1063  1387		       8d 97 f7 	      sta	PlayerLevel+RAM_WRITE
   1064  138a		       8d 92 f7 	      sta	StartLevel+RAM_WRITE
   1065  138d		       60		      rts
   1066  138e
   1067  138e							;---------------------------------------------------------------------------
   1068  138e
   1069  138e		       00 00 00    ScoreCurrent ds	3, 0
   1070  1391							; start levelx and level have to be after ScoreCurrent!
   1071  1391		       00	   StartLevelX .byte.b	0
   1072  1392		       00	   StartLevel .byte.b	0
   1073  1393		       00 00 00    PlayerScores ds	3, 0
   1074  1396							; levelx and level have to be consecutive variables!
   1075  1396		       00	   PlayerLevelX .byte.b	0
   1076  1397		       00	   PlayerLevel .byte.b	0
   1077  1398		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1078  139d
   1079  139d
   1080  139d
   1081  139d							;------------------------------------------------------------------------------
   1082  139d
      0  139d					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  139d
      2  139d
      3  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $39d , FREE= $63
      4  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  139d				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  139d				  -	      ERR
      8  139d					      endif
   1084  139d
   1085  139d							;------------------------------------------------------------------------------
   1086  139d
   1087  139d							; LEVEL DATA banks can go anywhere - *EXCEPT* for the same bank as the level
   1088  139d							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_LEVEL_SIZE
   1089  139d							; which is used as a buffer size inside UnpackLevel.  It's not important if
   1090  139d							; this is defined before or after, as once the levels have processed it will be
   1091  139d							; correct. Note, that levels should all be defined BEFORE *OR* AFTER the
   1092  139d							; UnpackLevel code -- but that they should not be both, nor in the same bank.
   1093  139d							; TODO: verify above is still valid
   1094  139d
   1095  139d
      0  139d					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $39d , FREE= $463
      2  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  139d				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  139d				  -	      ERR
      6  139d					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 4
      0  139d					      include	"BANK_GENERIC.asm"
      1  139d							;    Sokoboo - a Sokoban implementation
      2  139d							;    using a generic tile-based display engine for the Atari 2600
      3  139d							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  139d							;
      5  139d							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  139d							;
      7  139d							;    Code related to the generic tile-based display engine was developed by
      8  139d							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  139d							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  139d							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  139d							;
     12  139d							;    Code related to music and sound effects uses the TIATracker music player
     13  139d							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  139d							;    directory for Apache licensing details.
     15  139d							;
     16  139d							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  139d							;    See the copyright notices in the License directory for a list of level
     18  139d							;    contributors.
     19  139d							;
     20  139d							;    Except where otherwise indicated, this software is released under the
     21  139d							;    following licensing arrangement...
     22  139d							;
     23  139d							;    This program is free software: you can redistribute it and/or modify
     24  139d							;    it under the terms of the GNU General Public License as published by
     25  139d							;    the Free Software Foundation, either version 3 of the License, or
     26  139d							;    (at your option) any later version.
     27  139d							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  139d
     29  139d							;    This program is distributed in the hope that it will be useful,
     30  139d							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  139d							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  139d							;    GNU General Public License for more details.
     33  139d
     34  139d							;------------------------------------------------------------------------------
     35  139d							;##############################################################################
     36  139d							;------------------------------------------------------------------------------
     37  139d
      0  139d					      NEWBANK	GENERIC_BANK_1
      1  1f1e ????				      SEG	GENERIC_BANK_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	GENERIC_BANK_1
     39  1800
     40  1800
     41  1800
      0  1800					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  1800					      ALIGN	$400
      2  1800				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  1800				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
------- FILE DecodeLevel.asm LEVEL 3 PASS 4
      0  1800					      include	"DecodeLevel.asm"
      1  1800							;    Sokoboo - a Sokoban implementation
      2  1800							;    using a generic tile-based display engine for the Atari 2600
      3  1800							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1800							;
      5  1800							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1800							;
      7  1800							;    Code related to the generic tile-based display engine was developed by
      8  1800							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1800							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1800							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1800							;
     12  1800							;    Code related to music and sound effects uses the TIATracker music player
     13  1800							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1800							;    directory for Apache licensing details.
     15  1800							;
     16  1800							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1800							;    See the copyright notices in the License directory for a list of level
     18  1800							;    contributors.
     19  1800							;
     20  1800							;    Except where otherwise indicated, this software is released under the
     21  1800							;    following licensing arrangement...
     22  1800							;
     23  1800							;    This program is free software: you can redistribute it and/or modify
     24  1800							;    it under the terms of the GNU General Public License as published by
     25  1800							;    the Free Software Foundation, either version 3 of the License, or
     26  1800							;    (at your option) any later version.
     27  1800							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1800
     29  1800							;    This program is distributed in the hope that it will be useful,
     30  1800							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1800							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1800							;    GNU General Public License for more details.
     33  1800
     34  1800							; The ordering here corresponds to the ordering when playing...
     35  1800
     36  1800				   LevelInfoLO
     37  1800		       ff		      .byte.b	<(LEVEL__001_L-1)
     38  1801		       11		      .byte.b	<(LEVEL__001_R-1)
     39  1802		       1d		      .byte.b	<(LEVEL__002_L-1)
     40  1803		       36		      .byte.b	<(LEVEL__002_R-1)
     41  1804		       5e		      .byte.b	<(LEVEL__003_L-1)
     42  1805		       8a		      .byte.b	<(LEVEL__003_R-1)
     43  1806		       b4		      .byte.b	<(LEVEL__004_L-1)
     44  1807		       d7		      .byte.b	<(LEVEL__004_R-1)
     45  1808		       f3		      .byte.b	<(LEVEL__005_L-1)
     46  1809		       25		      .byte.b	<(LEVEL__005_R-1)
     47  180a		       64		      .byte.b	<(LEVEL__006_L-1)
     48  180b		       9f		      .byte.b	<(LEVEL__006_R-1)
     49  180c		       dd		      .byte.b	<(LEVEL__007_L-1)
     50  180d		       0a		      .byte.b	<(LEVEL__007_R-1)
     51  180e		       3d		      .byte.b	<(LEVEL__008_L-1)
     52  180f		       73		      .byte.b	<(LEVEL__008_R-1)
     53  1810		       a4		      .byte.b	<(LEVEL__009_L-1)
     54  1811		       d6		      .byte.b	<(LEVEL__009_R-1)
     55  1812		       06		      .byte.b	<(LEVEL__010_L-1)
     56  1813		       40		      .byte.b	<(LEVEL__010_R-1)
     57  1814		       73		      .byte.b	<(LEVEL__011_L-1)
     58  1815		       a6		      .byte.b	<(LEVEL__011_R-1)
     59  1816		       e0		      .byte.b	<(LEVEL__012_L-1)
     60  1817		       10		      .byte.b	<(LEVEL__012_R-1)
     61  1818		       4c		      .byte.b	<(LEVEL__013_L-1)
     62  1819		       8b		      .byte.b	<(LEVEL__013_R-1)
     63  181a		       be		      .byte.b	<(LEVEL__014_L-1)
     64  181b		       01		      .byte.b	<(LEVEL__014_R-1)
     65  181c		       44		      .byte.b	<(LEVEL__015_L-1)
     66  181d		       79		      .byte.b	<(LEVEL__015_R-1)
     67  181e		       be		      .byte.b	<(LEVEL__016_L-1)
     68  181f		       f5		      .byte.b	<(LEVEL__016_R-1)
     69  1820		       28		      .byte.b	<(LEVEL__017_L-1)
     70  1821		       72		      .byte.b	<(LEVEL__017_R-1)
     71  1822		       b5		      .byte.b	<(LEVEL__018_L-1)
     72  1823		       e9		      .byte.b	<(LEVEL__018_R-1)
     73  1824		       25		      .byte.b	<(LEVEL__019_L-1)
     74  1825		       60		      .byte.b	<(LEVEL__019_R-1)
     75  1826		       ff		      .byte.b	<(LEVEL__020_L-1)
     76  1827		       3e		      .byte.b	<(LEVEL__020_R-1)
     77  1828		       7e		      .byte.b	<(LEVEL__021_L-1)
     78  1829		       d4		      .byte.b	<(LEVEL__021_R-1)
     79  182a		       08		      .byte.b	<(LEVEL__022_L-1)
     80  182b		       4e		      .byte.b	<(LEVEL__022_R-1)
     81  182c		       8a		      .byte.b	<(LEVEL__023_L-1)
     82  182d		       cb		      .byte.b	<(LEVEL__023_R-1)
     83  182e		       0d		      .byte.b	<(LEVEL__024_L-1)
     84  182f		       5d		      .byte.b	<(LEVEL__024_R-1)
     85  1830		       a5		      .byte.b	<(LEVEL__025_L-1)
     86  1831		       e8		      .byte.b	<(LEVEL__025_R-1)
     87  1832		       27		      .byte.b	<(LEVEL__026_L-1)
     88  1833		       60		      .byte.b	<(LEVEL__026_R-1)
     89  1834		       a1		      .byte.b	<(LEVEL__027_L-1)
     90  1835		       df		      .byte.b	<(LEVEL__027_R-1)
     91  1836		       1d		      .byte.b	<(LEVEL__028_L-1)
     92  1837		       69		      .byte.b	<(LEVEL__028_R-1)
     93  1838		       b7		      .byte.b	<(LEVEL__029_L-1)
     94  1839		       fc		      .byte.b	<(LEVEL__029_R-1)
     95  183a		       40		      .byte.b	<(LEVEL__030_L-1)
     96  183b		       90		      .byte.b	<(LEVEL__030_R-1)
     97  183c		       e3		      .byte.b	<(LEVEL__031_L-1)
     98  183d		       29		      .byte.b	<(LEVEL__031_R-1)
     99  183e		       68		      .byte.b	<(LEVEL__032_L-1)
    100  183f		       a0		      .byte.b	<(LEVEL__032_R-1)
    101  1840		       e4		      .byte.b	<(LEVEL__033_L-1)
    102  1841		       2e		      .byte.b	<(LEVEL__033_R-1)
    103  1842		       6e		      .byte.b	<(LEVEL__034_L-1)
    104  1843		       ff		      .byte.b	<(LEVEL__034_R-1)
    105  1844		       48		      .byte.b	<(LEVEL__035_L-1)
    106  1845		       8d		      .byte.b	<(LEVEL__035_R-1)
    107  1846		       cd		      .byte.b	<(LEVEL__036_L-1)
    108  1847		       03		      .byte.b	<(LEVEL__036_R-1)
    109  1848		       49		      .byte.b	<(LEVEL__037_L-1)
    110  1849		       86		      .byte.b	<(LEVEL__037_R-1)
    111  184a		       cf		      .byte.b	<(LEVEL__038_L-1)
    112  184b		       17		      .byte.b	<(LEVEL__038_R-1)
    113  184c		       66		      .byte.b	<(LEVEL__039_L-1)
    114  184d		       b5		      .byte.b	<(LEVEL__039_R-1)
    115  184e		       0f		      .byte.b	<(LEVEL__040_L-1)
    116  184f		       56		      .byte.b	<(LEVEL__040_R-1)
    117  1850
    118  1850		       9d		      .byte.b	<(LEVEL__041_L-1)
    119  1851		       e7		      .byte.b	<(LEVEL__041_R-1)
    120  1852		       2e		      .byte.b	<(LEVEL__042_L-1)
    121  1853		       7c		      .byte.b	<(LEVEL__042_R-1)
    122  1854		       d4		      .byte.b	<(LEVEL__043_L-1)
    123  1855		       21		      .byte.b	<(LEVEL__043_R-1)
    124  1856		       6d		      .byte.b	<(LEVEL__044_L-1)
    125  1857		       a5		      .byte.b	<(LEVEL__044_R-1)
    126  1858		       f5		      .byte.b	<(LEVEL__045_L-1)
    127  1859		       43		      .byte.b	<(LEVEL__045_R-1)
    128  185a		       8d		      .byte.b	<(LEVEL__046_L-1)
    129  185b		       da		      .byte.b	<(LEVEL__046_R-1)
    130  185c		       1f		      .byte.b	<(LEVEL__047_L-1)
    131  185d		       75		      .byte.b	<(LEVEL__047_R-1)
    132  185e		       ff		      .byte.b	<(LEVEL__048_L-1)
    133  185f		       4b		      .byte.b	<(LEVEL__048_R-1)
    134  1860		       96		      .byte.b	<(LEVEL__049_L-1)
    135  1861		       e8		      .byte.b	<(LEVEL__049_R-1)
    136  1862
    137  1862		       2b		      .byte.b	<(LEVEL__050_L-1)
    138  1863		       78		      .byte.b	<(LEVEL__050_R-1)
    139  1864		       b1		      .byte.b	<(LEVEL__051_L-1)
    140  1865		       04		      .byte.b	<(LEVEL__051_R-1)
    141  1866		       55		      .byte.b	<(LEVEL__052_L-1)
    142  1867		       8f		      .byte.b	<(LEVEL__052_R-1)
    143  1868		       d7		      .byte.b	<(LEVEL__053_L-1)
    144  1869		       2c		      .byte.b	<(LEVEL__053_R-1)
    145  186a		       79		      .byte.b	<(LEVEL__054_L-1)
    146  186b		       c5		      .byte.b	<(LEVEL__054_R-1)
    147  186c		       0e		      .byte.b	<(LEVEL__055_L-1)
    148  186d		       68		      .byte.b	<(LEVEL__055_R-1)
    149  186e		       bd		      .byte.b	<(LEVEL__056_L-1)
    150  186f		       17		      .byte.b	<(LEVEL__056_R-1)
    151  1870		       72		      .byte.b	<(LEVEL__057_L-1)
    152  1871		       c8		      .byte.b	<(LEVEL__057_R-1)
    153  1872		       11		      .byte.b	<(LEVEL__058_L-1)
    154  1873		       56		      .byte.b	<(LEVEL__058_R-1)
    155  1874		       a6		      .byte.b	<(LEVEL__059_L-1)
    156  1875		       f8		      .byte.b	<(LEVEL__059_R-1)
    157  1876
    158  1876		       ff		      .byte.b	<(LEVEL__060_R-1)
    159  1877		       9b		      .byte.b	<(LEVEL__061_R-1)
    160  1878		       47		      .byte.b	<(LEVEL__061_L-1)
    161  1879		       e4		      .byte.b	<(LEVEL__062_L-1)
    162  187a		       3b		      .byte.b	<(LEVEL__062_R-1)
    163  187b		       87		      .byte.b	<(LEVEL__063_L-1)
    164  187c		       d7		      .byte.b	<(LEVEL__063_R-1)
    165  187d		       84		      .byte.b	<(LEVEL__064_R-1)
    166  187e		       29		      .byte.b	<(LEVEL__064_L-1)
    167  187f		       28		      .byte.b	<(LEVEL__065_R-1)
    168  1880		       d0		      .byte.b	<(LEVEL__065_L-1)
    169  1881		       ca		      .byte.b	<(LEVEL__066_R-1)
    170  1882		       70		      .byte.b	<(LEVEL__066_L-1)
    171  1883		       6d		      .byte.b	<(LEVEL__067_R-1)
    172  1884		       20		      .byte.b	<(LEVEL__067_L-1)
    173  1885		       26		      .byte.b	<(LEVEL__068_R-1)
    174  1886		       d2		      .byte.b	<(LEVEL__068_L-1)
    175  1887		       ca		      .byte.b	<(LEVEL__069_R-1)
    176  1888		       7c		      .byte.b	<(LEVEL__069_L-1)
    177  1889
    178  1889		       e8		      .byte.b	<(LEVEL__103_Arielle-1)
    179  188a		       a1		      .byte.b	<(LEVEL__103_Ajalae-1)
    180  188b		       56		      .byte.b	<(LEVEL__103_Adin-1)
    181  188c		       e8		      .byte.b	<(LEVEL__102_Raven-1)
    182  188d		       a4		      .byte.b	<(LEVEL__102_Oralia-1)
    183  188e		       ff		      .byte.b	<(LEVEL__102_Natalie-1)
    184  188f		       45		      .byte.b	<(LEVEL__102_Mirabel-1)
    185  1890		       38		      .byte.b	<(LEVEL__1XJH_Tara_Gelson-1)
    186  1891		       72		      .byte.b	<(LEVEL__1R7X_Alison-1)
    187  1892		       9f		      .byte.b	<(LEVEL__1KWD_Cecile_Clayworth-1)
    188  1893		       d3		      .byte.b	<(LEVEL__1EKT_Samantha_Gelson-1)
    189  1894		       0c		      .byte.b	<(LEVEL__0VM5_Andrea_Wadd-1)
    190  1895		       39		      .byte.b	<(LEVEL__0PAL_Jill_Leatherby-1)
    191  1896		       63		      .byte.b	<(LEVEL__0IZ1_Sophia-1)
    192  1897		       8e		      .byte.b	<(LEVEL__0CNH_Alice-1)
    193  1898
    194  1898				   LevelInfoHI
    195  1898		       ef		      .byte.b	>(LEVEL__001_L-1)
    196  1899		       f0		      .byte.b	>(LEVEL__001_R-1)
    197  189a		       f0		      .byte.b	>(LEVEL__002_L-1)
    198  189b		       f0		      .byte.b	>(LEVEL__002_R-1)
    199  189c		       f0		      .byte.b	>(LEVEL__003_L-1)
    200  189d		       f0		      .byte.b	>(LEVEL__003_R-1)
    201  189e		       f0		      .byte.b	>(LEVEL__004_L-1)
    202  189f		       f0		      .byte.b	>(LEVEL__004_R-1)
    203  18a0		       f0		      .byte.b	>(LEVEL__005_L-1)
    204  18a1		       f1		      .byte.b	>(LEVEL__005_R-1)
    205  18a2		       f1		      .byte.b	>(LEVEL__006_L-1)
    206  18a3		       f1		      .byte.b	>(LEVEL__006_R-1)
    207  18a4		       f1		      .byte.b	>(LEVEL__007_L-1)
    208  18a5		       f2		      .byte.b	>(LEVEL__007_R-1)
    209  18a6		       f2		      .byte.b	>(LEVEL__008_L-1)
    210  18a7		       f2		      .byte.b	>(LEVEL__008_R-1)
    211  18a8		       f2		      .byte.b	>(LEVEL__009_L-1)
    212  18a9		       f2		      .byte.b	>(LEVEL__009_R-1)
    213  18aa		       f3		      .byte.b	>(LEVEL__010_L-1)
    214  18ab		       f3		      .byte.b	>(LEVEL__010_R-1)
    215  18ac		       f3		      .byte.b	>(LEVEL__011_L-1)
    216  18ad		       f3		      .byte.b	>(LEVEL__011_R-1)
    217  18ae		       f3		      .byte.b	>(LEVEL__012_L-1)
    218  18af		       f4		      .byte.b	>(LEVEL__012_R-1)
    219  18b0		       f4		      .byte.b	>(LEVEL__013_L-1)
    220  18b1		       f4		      .byte.b	>(LEVEL__013_R-1)
    221  18b2		       f4		      .byte.b	>(LEVEL__014_L-1)
    222  18b3		       f5		      .byte.b	>(LEVEL__014_R-1)
    223  18b4		       f5		      .byte.b	>(LEVEL__015_L-1)
    224  18b5		       f5		      .byte.b	>(LEVEL__015_R-1)
    225  18b6		       f5		      .byte.b	>(LEVEL__016_L-1)
    226  18b7		       f5		      .byte.b	>(LEVEL__016_R-1)
    227  18b8		       f6		      .byte.b	>(LEVEL__017_L-1)
    228  18b9		       f6		      .byte.b	>(LEVEL__017_R-1)
    229  18ba		       f6		      .byte.b	>(LEVEL__018_L-1)
    230  18bb		       f6		      .byte.b	>(LEVEL__018_R-1)
    231  18bc		       f7		      .byte.b	>(LEVEL__019_L-1)
    232  18bd		       f7		      .byte.b	>(LEVEL__019_R-1)
    233  18be		       ef		      .byte.b	>(LEVEL__020_L-1)
    234  18bf		       f0		      .byte.b	>(LEVEL__020_R-1)
    235  18c0		       f0		      .byte.b	>(LEVEL__021_L-1)
    236  18c1		       f0		      .byte.b	>(LEVEL__021_R-1)
    237  18c2		       f1		      .byte.b	>(LEVEL__022_L-1)
    238  18c3		       f1		      .byte.b	>(LEVEL__022_R-1)
    239  18c4		       f1		      .byte.b	>(LEVEL__023_L-1)
    240  18c5		       f1		      .byte.b	>(LEVEL__023_R-1)
    241  18c6		       f2		      .byte.b	>(LEVEL__024_L-1)
    242  18c7		       f2		      .byte.b	>(LEVEL__024_R-1)
    243  18c8		       f2		      .byte.b	>(LEVEL__025_L-1)
    244  18c9		       f2		      .byte.b	>(LEVEL__025_R-1)
    245  18ca		       f3		      .byte.b	>(LEVEL__026_L-1)
    246  18cb		       f3		      .byte.b	>(LEVEL__026_R-1)
    247  18cc		       f3		      .byte.b	>(LEVEL__027_L-1)
    248  18cd		       f3		      .byte.b	>(LEVEL__027_R-1)
    249  18ce		       f4		      .byte.b	>(LEVEL__028_L-1)
    250  18cf		       f4		      .byte.b	>(LEVEL__028_R-1)
    251  18d0		       f4		      .byte.b	>(LEVEL__029_L-1)
    252  18d1		       f4		      .byte.b	>(LEVEL__029_R-1)
    253  18d2		       f5		      .byte.b	>(LEVEL__030_L-1)
    254  18d3		       f5		      .byte.b	>(LEVEL__030_R-1)
    255  18d4		       f5		      .byte.b	>(LEVEL__031_L-1)
    256  18d5		       f6		      .byte.b	>(LEVEL__031_R-1)
    257  18d6		       f6		      .byte.b	>(LEVEL__032_L-1)
    258  18d7		       f6		      .byte.b	>(LEVEL__032_R-1)
    259  18d8		       f6		      .byte.b	>(LEVEL__033_L-1)
    260  18d9		       f7		      .byte.b	>(LEVEL__033_R-1)
    261  18da		       f7		      .byte.b	>(LEVEL__034_L-1)
    262  18db		       ef		      .byte.b	>(LEVEL__034_R-1)
    263  18dc		       f0		      .byte.b	>(LEVEL__035_L-1)
    264  18dd		       f0		      .byte.b	>(LEVEL__035_R-1)
    265  18de		       f0		      .byte.b	>(LEVEL__036_L-1)
    266  18df		       f1		      .byte.b	>(LEVEL__036_R-1)
    267  18e0		       f1		      .byte.b	>(LEVEL__037_L-1)
    268  18e1		       f1		      .byte.b	>(LEVEL__037_R-1)
    269  18e2		       f1		      .byte.b	>(LEVEL__038_L-1)
    270  18e3		       f2		      .byte.b	>(LEVEL__038_R-1)
    271  18e4		       f2		      .byte.b	>(LEVEL__039_L-1)
    272  18e5		       f2		      .byte.b	>(LEVEL__039_R-1)
    273  18e6		       f3		      .byte.b	>(LEVEL__040_L-1)
    274  18e7		       f3		      .byte.b	>(LEVEL__040_R-1)
    275  18e8
    276  18e8		       f3		      .byte.b	>(LEVEL__041_L-1)
    277  18e9		       f3		      .byte.b	>(LEVEL__041_R-1)
    278  18ea		       f4		      .byte.b	>(LEVEL__042_L-1)
    279  18eb		       f4		      .byte.b	>(LEVEL__042_R-1)
    280  18ec		       f4		      .byte.b	>(LEVEL__043_L-1)
    281  18ed		       f5		      .byte.b	>(LEVEL__043_R-1)
    282  18ee		       f5		      .byte.b	>(LEVEL__044_L-1)
    283  18ef		       f5		      .byte.b	>(LEVEL__044_R-1)
    284  18f0		       f5		      .byte.b	>(LEVEL__045_L-1)
    285  18f1		       f6		      .byte.b	>(LEVEL__045_R-1)
    286  18f2		       f6		      .byte.b	>(LEVEL__046_L-1)
    287  18f3		       f6		      .byte.b	>(LEVEL__046_R-1)
    288  18f4		       f7		      .byte.b	>(LEVEL__047_L-1)
    289  18f5		       f7		      .byte.b	>(LEVEL__047_R-1)
    290  18f6		       ef		      .byte.b	>(LEVEL__048_L-1)
    291  18f7		       f0		      .byte.b	>(LEVEL__048_R-1)
    292  18f8		       f0		      .byte.b	>(LEVEL__049_L-1)
    293  18f9		       f0		      .byte.b	>(LEVEL__049_R-1)
    294  18fa
    295  18fa		       f1		      .byte.b	>(LEVEL__050_L-1)
    296  18fb		       f1		      .byte.b	>(LEVEL__050_R-1)
    297  18fc		       f1		      .byte.b	>(LEVEL__051_L-1)
    298  18fd		       f2		      .byte.b	>(LEVEL__051_R-1)
    299  18fe		       f2		      .byte.b	>(LEVEL__052_L-1)
    300  18ff		       f2		      .byte.b	>(LEVEL__052_R-1)
    301  1900		       f2		      .byte.b	>(LEVEL__053_L-1)
    302  1901		       f3		      .byte.b	>(LEVEL__053_R-1)
    303  1902		       f3		      .byte.b	>(LEVEL__054_L-1)
    304  1903		       f3		      .byte.b	>(LEVEL__054_R-1)
    305  1904		       f4		      .byte.b	>(LEVEL__055_L-1)
    306  1905		       f4		      .byte.b	>(LEVEL__055_R-1)
    307  1906		       f4		      .byte.b	>(LEVEL__056_L-1)
    308  1907		       f5		      .byte.b	>(LEVEL__056_R-1)
    309  1908		       f5		      .byte.b	>(LEVEL__057_L-1)
    310  1909		       f5		      .byte.b	>(LEVEL__057_R-1)
    311  190a		       f6		      .byte.b	>(LEVEL__058_L-1)
    312  190b		       f6		      .byte.b	>(LEVEL__058_R-1)
    313  190c		       f6		      .byte.b	>(LEVEL__059_L-1)
    314  190d		       f6		      .byte.b	>(LEVEL__059_R-1)
    315  190e
    316  190e		       ef		      .byte.b	>(LEVEL__060_R-1)
    317  190f		       f0		      .byte.b	>(LEVEL__061_R-1)
    318  1910		       f0		      .byte.b	>(LEVEL__061_L-1)
    319  1911		       f0		      .byte.b	>(LEVEL__062_L-1)
    320  1912		       f1		      .byte.b	>(LEVEL__062_R-1)
    321  1913		       f1		      .byte.b	>(LEVEL__063_L-1)
    322  1914		       f1		      .byte.b	>(LEVEL__063_R-1)
    323  1915		       f2		      .byte.b	>(LEVEL__064_R-1)
    324  1916		       f2		      .byte.b	>(LEVEL__064_L-1)
    325  1917		       f3		      .byte.b	>(LEVEL__065_R-1)
    326  1918		       f2		      .byte.b	>(LEVEL__065_L-1)
    327  1919		       f3		      .byte.b	>(LEVEL__066_R-1)
    328  191a		       f3		      .byte.b	>(LEVEL__066_L-1)
    329  191b		       f4		      .byte.b	>(LEVEL__067_R-1)
    330  191c		       f4		      .byte.b	>(LEVEL__067_L-1)
    331  191d		       f5		      .byte.b	>(LEVEL__068_R-1)
    332  191e		       f4		      .byte.b	>(LEVEL__068_L-1)
    333  191f		       f5		      .byte.b	>(LEVEL__069_R-1)
    334  1920		       f5		      .byte.b	>(LEVEL__069_L-1)
    335  1921
    336  1921		       f1		      .byte.b	>(LEVEL__103_Arielle-1)
    337  1922		       f1		      .byte.b	>(LEVEL__103_Ajalae-1)
    338  1923		       f1		      .byte.b	>(LEVEL__103_Adin-1)
    339  1924		       f0		      .byte.b	>(LEVEL__102_Raven-1)
    340  1925		       f0		      .byte.b	>(LEVEL__102_Oralia-1)
    341  1926		       ef		      .byte.b	>(LEVEL__102_Natalie-1)
    342  1927		       f0		      .byte.b	>(LEVEL__102_Mirabel-1)
    343  1928		       f2		      .byte.b	>(LEVEL__1XJH_Tara_Gelson-1)
    344  1929		       f2		      .byte.b	>(LEVEL__1R7X_Alison-1)
    345  192a		       f2		      .byte.b	>(LEVEL__1KWD_Cecile_Clayworth-1)
    346  192b		       f2		      .byte.b	>(LEVEL__1EKT_Samantha_Gelson-1)
    347  192c		       f3		      .byte.b	>(LEVEL__0VM5_Andrea_Wadd-1)
    348  192d		       f3		      .byte.b	>(LEVEL__0PAL_Jill_Leatherby-1)
    349  192e		       f3		      .byte.b	>(LEVEL__0IZ1_Sophia-1)
    350  192f		       f3		      .byte.b	>(LEVEL__0CNH_Alice-1)
    351  1930
    352  1930				   LevelInfoBANK
    353  1930		       04		      .byte.b	BANK_LEVEL__001_L
    354  1931		       04		      .byte.b	BANK_LEVEL__001_R
    355  1932		       04		      .byte.b	BANK_LEVEL__002_L
    356  1933		       04		      .byte.b	BANK_LEVEL__002_R
    357  1934		       04		      .byte.b	BANK_LEVEL__003_L
    358  1935		       04		      .byte.b	BANK_LEVEL__003_R
    359  1936		       04		      .byte.b	BANK_LEVEL__004_L
    360  1937		       04		      .byte.b	BANK_LEVEL__004_R
    361  1938		       04		      .byte.b	BANK_LEVEL__005_L
    362  1939		       04		      .byte.b	BANK_LEVEL__005_R
    363  193a		       04		      .byte.b	BANK_LEVEL__006_L
    364  193b		       04		      .byte.b	BANK_LEVEL__006_R
    365  193c		       04		      .byte.b	BANK_LEVEL__007_L
    366  193d		       04		      .byte.b	BANK_LEVEL__007_R
    367  193e		       04		      .byte.b	BANK_LEVEL__008_L
    368  193f		       04		      .byte.b	BANK_LEVEL__008_R
    369  1940		       04		      .byte.b	BANK_LEVEL__009_L
    370  1941		       04		      .byte.b	BANK_LEVEL__009_R
    371  1942		       04		      .byte.b	BANK_LEVEL__010_L
    372  1943		       04		      .byte.b	BANK_LEVEL__010_R
    373  1944		       04		      .byte.b	BANK_LEVEL__011_L
    374  1945		       04		      .byte.b	BANK_LEVEL__011_R
    375  1946		       04		      .byte.b	BANK_LEVEL__012_L
    376  1947		       04		      .byte.b	BANK_LEVEL__012_R
    377  1948		       04		      .byte.b	BANK_LEVEL__013_L
    378  1949		       04		      .byte.b	BANK_LEVEL__013_R
    379  194a		       04		      .byte.b	BANK_LEVEL__014_L
    380  194b		       04		      .byte.b	BANK_LEVEL__014_R
    381  194c		       04		      .byte.b	BANK_LEVEL__015_L
    382  194d		       04		      .byte.b	BANK_LEVEL__015_R
    383  194e		       04		      .byte.b	BANK_LEVEL__016_L
    384  194f		       04		      .byte.b	BANK_LEVEL__016_R
    385  1950		       04		      .byte.b	BANK_LEVEL__017_L
    386  1951		       04		      .byte.b	BANK_LEVEL__017_R
    387  1952		       04		      .byte.b	BANK_LEVEL__018_L
    388  1953		       04		      .byte.b	BANK_LEVEL__018_R
    389  1954		       04		      .byte.b	BANK_LEVEL__019_L
    390  1955		       04		      .byte.b	BANK_LEVEL__019_R
    391  1956		       05		      .byte.b	BANK_LEVEL__020_L
    392  1957		       05		      .byte.b	BANK_LEVEL__020_R
    393  1958		       05		      .byte.b	BANK_LEVEL__021_L
    394  1959		       05		      .byte.b	BANK_LEVEL__021_R
    395  195a		       05		      .byte.b	BANK_LEVEL__022_L
    396  195b		       05		      .byte.b	BANK_LEVEL__022_R
    397  195c		       05		      .byte.b	BANK_LEVEL__023_L
    398  195d		       05		      .byte.b	BANK_LEVEL__023_R
    399  195e		       05		      .byte.b	BANK_LEVEL__024_L
    400  195f		       05		      .byte.b	BANK_LEVEL__024_R
    401  1960		       05		      .byte.b	BANK_LEVEL__025_L
    402  1961		       05		      .byte.b	BANK_LEVEL__025_R
    403  1962		       05		      .byte.b	BANK_LEVEL__026_L
    404  1963		       05		      .byte.b	BANK_LEVEL__026_R
    405  1964		       05		      .byte.b	BANK_LEVEL__027_L
    406  1965		       05		      .byte.b	BANK_LEVEL__027_R
    407  1966		       05		      .byte.b	BANK_LEVEL__028_L
    408  1967		       05		      .byte.b	BANK_LEVEL__028_R
    409  1968		       05		      .byte.b	BANK_LEVEL__029_L
    410  1969		       05		      .byte.b	BANK_LEVEL__029_R
    411  196a		       05		      .byte.b	BANK_LEVEL__030_L
    412  196b		       05		      .byte.b	BANK_LEVEL__030_R
    413  196c		       05		      .byte.b	BANK_LEVEL__031_L
    414  196d		       05		      .byte.b	BANK_LEVEL__031_R
    415  196e		       05		      .byte.b	BANK_LEVEL__032_L
    416  196f		       05		      .byte.b	BANK_LEVEL__032_R
    417  1970		       05		      .byte.b	BANK_LEVEL__033_L
    418  1971		       05		      .byte.b	BANK_LEVEL__033_R
    419  1972		       05		      .byte.b	BANK_LEVEL__034_L
    420  1973		       06		      .byte.b	BANK_LEVEL__034_R
    421  1974		       06		      .byte.b	BANK_LEVEL__035_L
    422  1975		       06		      .byte.b	BANK_LEVEL__035_R
    423  1976		       06		      .byte.b	BANK_LEVEL__036_L
    424  1977		       06		      .byte.b	BANK_LEVEL__036_R
    425  1978		       06		      .byte.b	BANK_LEVEL__037_L
    426  1979		       06		      .byte.b	BANK_LEVEL__037_R
    427  197a		       06		      .byte.b	BANK_LEVEL__038_L
    428  197b		       06		      .byte.b	BANK_LEVEL__038_R
    429  197c		       06		      .byte.b	BANK_LEVEL__039_L
    430  197d		       06		      .byte.b	BANK_LEVEL__039_R
    431  197e		       06		      .byte.b	BANK_LEVEL__040_L
    432  197f		       06		      .byte.b	BANK_LEVEL__040_R
    433  1980
    434  1980		       06		      .byte.b	BANK_LEVEL__041_L
    435  1981		       06		      .byte.b	BANK_LEVEL__041_R
    436  1982		       06		      .byte.b	BANK_LEVEL__042_L
    437  1983		       06		      .byte.b	BANK_LEVEL__042_R
    438  1984		       06		      .byte.b	BANK_LEVEL__043_L
    439  1985		       06		      .byte.b	BANK_LEVEL__043_R
    440  1986		       06		      .byte.b	BANK_LEVEL__044_L
    441  1987		       06		      .byte.b	BANK_LEVEL__044_R
    442  1988		       06		      .byte.b	BANK_LEVEL__045_L
    443  1989		       06		      .byte.b	BANK_LEVEL__045_R
    444  198a		       06		      .byte.b	BANK_LEVEL__046_L
    445  198b		       06		      .byte.b	BANK_LEVEL__046_R
    446  198c		       06		      .byte.b	BANK_LEVEL__047_L
    447  198d		       06		      .byte.b	BANK_LEVEL__047_R
    448  198e		       07		      .byte.b	BANK_LEVEL__048_L
    449  198f		       07		      .byte.b	BANK_LEVEL__048_R
    450  1990		       07		      .byte.b	BANK_LEVEL__049_L
    451  1991		       07		      .byte.b	BANK_LEVEL__049_R
    452  1992
    453  1992		       07		      .byte.b	BANK_LEVEL__050_L
    454  1993		       07		      .byte.b	BANK_LEVEL__050_R
    455  1994		       07		      .byte.b	BANK_LEVEL__051_L
    456  1995		       07		      .byte.b	BANK_LEVEL__051_R
    457  1996		       07		      .byte.b	BANK_LEVEL__052_L
    458  1997		       07		      .byte.b	BANK_LEVEL__052_R
    459  1998		       07		      .byte.b	BANK_LEVEL__053_L
    460  1999		       07		      .byte.b	BANK_LEVEL__053_R
    461  199a		       07		      .byte.b	BANK_LEVEL__054_L
    462  199b		       07		      .byte.b	BANK_LEVEL__054_R
    463  199c		       07		      .byte.b	BANK_LEVEL__055_L
    464  199d		       07		      .byte.b	BANK_LEVEL__055_R
    465  199e		       07		      .byte.b	BANK_LEVEL__056_L
    466  199f		       07		      .byte.b	BANK_LEVEL__056_R
    467  19a0		       07		      .byte.b	BANK_LEVEL__057_L
    468  19a1		       07		      .byte.b	BANK_LEVEL__057_R
    469  19a2		       07		      .byte.b	BANK_LEVEL__058_L
    470  19a3		       07		      .byte.b	BANK_LEVEL__058_R
    471  19a4		       07		      .byte.b	BANK_LEVEL__059_L
    472  19a5		       07		      .byte.b	BANK_LEVEL__059_R
    473  19a6
    474  19a6		       08		      .byte.b	BANK_LEVEL__060_R
    475  19a7		       08		      .byte.b	BANK_LEVEL__061_R
    476  19a8		       08		      .byte.b	BANK_LEVEL__061_L
    477  19a9		       08		      .byte.b	BANK_LEVEL__062_L
    478  19aa		       08		      .byte.b	BANK_LEVEL__062_R
    479  19ab		       08		      .byte.b	BANK_LEVEL__063_L
    480  19ac		       08		      .byte.b	BANK_LEVEL__063_R
    481  19ad		       08		      .byte.b	BANK_LEVEL__064_R
    482  19ae		       08		      .byte.b	BANK_LEVEL__064_L
    483  19af		       08		      .byte.b	BANK_LEVEL__065_R
    484  19b0		       08		      .byte.b	BANK_LEVEL__065_L
    485  19b1		       08		      .byte.b	BANK_LEVEL__066_R
    486  19b2		       08		      .byte.b	BANK_LEVEL__066_L
    487  19b3		       08		      .byte.b	BANK_LEVEL__067_R
    488  19b4		       08		      .byte.b	BANK_LEVEL__067_L
    489  19b5		       08		      .byte.b	BANK_LEVEL__068_R
    490  19b6		       08		      .byte.b	BANK_LEVEL__068_L
    491  19b7		       08		      .byte.b	BANK_LEVEL__069_R
    492  19b8		       08		      .byte.b	BANK_LEVEL__069_L
    493  19b9
    494  19b9		       09		      .byte.b	BANK_LEVEL__103_Arielle
    495  19ba		       09		      .byte.b	BANK_LEVEL__103_Ajalae
    496  19bb		       09		      .byte.b	BANK_LEVEL__103_Adin
    497  19bc		       09		      .byte.b	BANK_LEVEL__102_Raven
    498  19bd		       09		      .byte.b	BANK_LEVEL__102_Oralia
    499  19be		       09		      .byte.b	BANK_LEVEL__102_Natalie
    500  19bf		       09		      .byte.b	BANK_LEVEL__102_Mirabel
    501  19c0		       09		      .byte.b	BANK_LEVEL__1XJH_Tara_Gelson
    502  19c1		       09		      .byte.b	BANK_LEVEL__1R7X_Alison
    503  19c2		       09		      .byte.b	BANK_LEVEL__1KWD_Cecile_Clayworth
    504  19c3		       09		      .byte.b	BANK_LEVEL__1EKT_Samantha_Gelson
    505  19c4		       09		      .byte.b	BANK_LEVEL__0VM5_Andrea_Wadd
    506  19c5		       09		      .byte.b	BANK_LEVEL__0PAL_Jill_Leatherby
    507  19c6		       09		      .byte.b	BANK_LEVEL__0IZ1_Sophia
    508  19c7		       09		      .byte.b	BANK_LEVEL__0CNH_Alice
    509  19c8
    510  19c8
    511  19c8
    512  19c8				   finX
    513  19c8							; now put the soil in - fill from the outsides
    514  19c8
    515  19c8		       a9 01		      lda	#CHARACTER_SOIL
    516  19ca		       85 8e		      sta	POS_Type
    517  19cc
    518  19cc		       a9 15		      lda	#SIZE_BOARD_Y-1
    519  19ce		       85 8b		      sta	POS_Y
    520  19d0
    521  19d0		       a9 27	   xlin       lda	#SIZE_BOARD_X-1
    522  19d2		       85 8a		      sta	POS_X
    523  19d4		       20 26 f8    zap1       jsr	GetBoardCharacter__CALL_FROM_RAM__
    524  19d7		       c9 01		      cmp	#CHARACTER_SOIL
    525  19d9		       f0 07		      beq	kg2a
    526  19db		       c9 00		      cmp	#0
    527  19dd		       d0 07		      bne	endzap1
    528  19df		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    529  19e2		       c6 8a	   kg2a       dec	POS_X
    530  19e4		       10 ee		      bpl	zap1
    531  19e6
    532  19e6		       a9 00	   endzap1    lda	#0
    533  19e8		       85 8a		      sta	POS_X
    534  19ea		       20 26 f8    zap2       jsr	GetBoardCharacter__CALL_FROM_RAM__
    535  19ed		       c9 01		      cmp	#CHARACTER_SOIL
    536  19ef		       f0 07		      beq	kg2
    537  19f1		       c9 00		      cmp	#0
    538  19f3		       d0 0b		      bne	endzap2
    539  19f5		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    540  19f8		       e6 8a	   kg2	      inc	POS_X
    541  19fa		       a5 8a		      lda	POS_X
    542  19fc		       c9 28		      cmp	#SIZE_BOARD_X
    543  19fe		       d0 ea		      bne	zap2
    544  1a00
    545  1a00		       c6 8b	   endzap2    dec	POS_Y
    546  1a02		       10 cc		      bpl	xlin
    547  1a04
    548  1a04
    549  1a04		       a9 27		      lda	#SIZE_BOARD_X-1
    550  1a06		       85 8a		      sta	POS_X
    551  1a08
    552  1a08		       a9 15	   ylin       lda	#SIZE_BOARD_Y-1
    553  1a0a		       85 8b		      sta	POS_Y
    554  1a0c		       20 26 f8    zapy1      jsr	GetBoardCharacter__CALL_FROM_RAM__
    555  1a0f		       c9 01		      cmp	#CHARACTER_SOIL
    556  1a11		       f0 07		      beq	kg3
    557  1a13		       c9 00		      cmp	#0
    558  1a15		       d0 07		      bne	endzapy1
    559  1a17		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    560  1a1a		       c6 8b	   kg3	      dec	POS_Y
    561  1a1c		       10 ee		      bpl	zapy1
    562  1a1e
    563  1a1e		       a9 00	   endzapy1   lda	#0
    564  1a20		       85 8b		      sta	POS_Y
    565  1a22		       20 26 f8    zapy2      jsr	GetBoardCharacter__CALL_FROM_RAM__
    566  1a25		       c9 01		      cmp	#CHARACTER_SOIL
    567  1a27		       f0 07		      beq	kg3b
    568  1a29		       c9 00		      cmp	#0
    569  1a2b		       d0 0b		      bne	endzapy2
    570  1a2d		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    571  1a30		       e6 8b	   kg3b       inc	POS_Y
    572  1a32		       a5 8b		      lda	POS_Y
    573  1a34		       c9 16		      cmp	#SIZE_BOARD_Y
    574  1a36		       d0 ea		      bne	zapy2
    575  1a38
    576  1a38		       c6 8a	   endzapy2   dec	POS_X
    577  1a3a		       10 cc		      bpl	ylin
    578  1a3c		       60		      rts
    579  1a3d
      0  1a3d					      DEFINE_SUBROUTINE	RegisterOneMoreTarget
      1  1a3d		       00 03	   BANK_RegisterOneMoreTarget =	_CURRENT_BANK
      2  1a3d					      SUBROUTINE
      3  1a3d				   RegisterOneMoreTarget
    581  1a3d
    582  1a3d		       f8		      sed
    583  1a3e		       18		      clc
    584  1a3f		       a5 bb		      lda	targetsRequired
    585  1a41		       69 01		      adc	#1
    586  1a43		       85 bb		      sta	targetsRequired
    587  1a45		       d8		      cld
    588  1a46		       60		      rts
    589  1a47
    590  1a47							;A	 steel wall
    591  1a47							;B	 soil (surround)
    592  1a47							;C	 box
    593  1a47
    594  1a47
    595  1a47				   C1			;mortar
    596  1a47		       88 b6		      .byte.b	$88,$b6
    597  1a49		       38 68		      .byte.b	$38,$68
    598  1a4b		       5a aa		      .byte.b	$5a,$AA
    599  1a4d		       5a 8a		      .byte.b	$5a,$8a
    600  1a4f				   C2			; soil stripes
    601  1a4f		       34 62		      .byte.b	$34,$62
    602  1a51		       b4 74		      .byte.b	$b4,$74
    603  1a53		       f4 24		      .byte.b	$F4,$24
    604  1a55		       a4 74		      .byte.b	$a4,$74
    605  1a57				   C3			; brick
    606  1a57		       1a 2a		      .byte.b	$1A,$2a
    607  1a59		       8c bc		      .byte.b	$8C,$BC
    608  1a5b		       0a fa		      .byte.b	$0A,$fA
    609  1a5d		       ca 3a		      .byte.b	$ca,$3a
    610  1a5f
      0  1a5f					      DEFINE_SUBROUTINE	UnpackLevel
      1  1a5f		       00 03	   BANK_UnpackLevel =	_CURRENT_BANK
      2  1a5f					      SUBROUTINE
      3  1a5f				   UnpackLevel
    612  1a5f
    613  1a5f		       85 c7		      sta	RAM_Bank
    614  1a61
    615  1a61							; has to be done before decoding the level to have the platform right:
    616  1a61							;	    SET_PLATFORM
    617  1a61
    618  1a61		       a9 01		      lda	#CHARACTER_SOIL
    619  1a63		       85 8e		      sta	POS_Type
    620  1a65
    621  1a65		       a9 15		      lda	#SIZE_BOARD_Y-1
    622  1a67		       85 8b		      sta	POS_Y
    623  1a69		       a9 27	   xyLine     lda	#SIZE_BOARD_X-1
    624  1a6b		       85 8a		      sta	POS_X
    625  1a6d		       20 3a f8    xyClear    jsr	PutBoardCharacterFromRAM
    626  1a70		       c6 8a		      dec	POS_X
    627  1a72		       10 f9		      bpl	xyClear
    628  1a74		       c6 8b		      dec	POS_Y
    629  1a76		       10 f1		      bpl	xyLine
    630  1a78
    631  1a78		       a9 05		      lda	#5
    632  1a7a		       85 dc		      sta	base_x
    633  1a7c		       85 dd		      sta	base_y
    634  1a7e
    635  1a7e		       a5 cc		      lda	NextLevelTrigger
    636  1a80		       09 80		      ora	#BIT_NEXTLEVEL
    637  1a82		       85 cc		      sta	NextLevelTrigger
    638  1a84
    639  1a84		       a6 b6		      ldx	levelX
    640  1a86		       bd 00 f0 	      lda	LevelInfoLO,x
    641  1a89		       85 c2		      sta	Board_AddressR
    642  1a8b		       bd 98 f0 	      lda	LevelInfoHI,x
    643  1a8e		       85 c3		      sta	Board_AddressR+1
    644  1a90		       bd 30 f1 	      lda	LevelInfoBANK,x
    645  1a93		       85 b0		      sta	LEVEL_bank
    646  1a95
    647  1a95		       a9 03		      lda	#BANK_UnpackLevel	; the *ROM* bank of this routine (NOT RAM)
    648  1a97		       85 c6		      sta	ROM_Bank	; GetROMByte returns to this bank
    649  1a99
    650  1a99		       a5 b6		      lda	levelX
    651  1a9b		       29 03		      and	#3
    652  1a9d		       0a		      asl
    653  1a9e		       0a		      asl
    654  1a9f		       05 81		      ora	Platform	; NTSC/PAL
    655  1aa1		       4a		      lsr
    656  1aa2		       aa		      tax
    657  1aa3		       bd 47 f2 	      lda	C1,x
    658  1aa6		       85 bf		      sta	color
    659  1aa8		       bd 4f f2 	      lda	C2,x
    660  1aab		       85 c0		      sta	color+1
    661  1aad		       bd 57 f2 	      lda	C3,x
    662  1ab0		       85 c1		      sta	color+2
    663  1ab2
    664  1ab2							;lda #$00
    665  1ab2							;sta moveCounter
    666  1ab2							;sta moveCounterHi
    667  1ab2							;sta moveCounterBinary
    668  1ab2
    669  1ab2		       a9 00		      lda	#$00	; BCD reminder!
    670  1ab4		       85 bb		      sta	targetsRequired	; # of targets that do NOT have boxes on them
    671  1ab6
    672  1ab6		       a9 18		      lda	#24	; arbitrary
    673  1ab8		       85 ba		      sta	ThrottleSpeed
    674  1aba
    675  1aba							; first fill bg with character_soil
    676  1aba							; then rle unpack level
    677  1aba							; change level colours
    678  1aba
    679  1aba		       a9 00		      lda	#0
    680  1abc		       85 8a		      sta	POS_X
    681  1abe		       85 8b		      sta	POS_Y
    682  1ac0		       85 94		      sta	BoardLimit_Width
    683  1ac2		       85 95		      sta	BoardLimit_Height
    684  1ac4
    685  1ac4				   GetNextItem
    686  1ac4
    687  1ac4		       a9 01		      lda	#1
    688  1ac6		       85 de		      sta	upk_length
    689  1ac8		       a9 00		      lda	#0
    690  1aca		       85 df		      sta	upk_column	; reuse var - this flags a digit already
    691  1acc
    692  1acc		       e6 c2	   Get2       inc	Board_AddressR
    693  1ace		       d0 02		      bne	addrOK
    694  1ad0		       e6 c3		      inc	Board_AddressR+1
    695  1ad2				   addrOK
    696  1ad2
    697  1ad2		       a5 b0		      lda	LEVEL_bank
    698  1ad4		       a0 00		      ldy	#0
    699  1ad6		       20 0f f8 	      jsr	GetROMByte
    700  1ad9		       85 e0		      sta	upk_temp	;scratch
    701  1adb
    702  1adb
    703  1adb		       c9 00		      cmp	#0
    704  1add		       d0 03		      bne	parse
    705  1adf		       4c c8 f1 	      jmp	finX
    706  1ae2				   parse
    707  1ae2		       c9 3a		      cmp	#"9"+1
    708  1ae4		       b0 1e		      bcs	notDigit
    709  1ae6		       c9 30		      cmp	#"0"
    710  1ae8		       90 1a		      bcc	notDigit
    711  1aea
    712  1aea		       a5 df		      lda	upk_column
    713  1aec		       f0 09		      beq	firstDig
    714  1aee
    715  1aee		       a5 de		      lda	upk_length
    716  1af0		       0a		      asl
    717  1af1		       0a		      asl
    718  1af2		       0a		      asl
    719  1af3		       65 de		      adc	upk_length
    720  1af5		       65 de		      adc	upk_length
    721  1af7
    722  1af7		       18	   firstDig   clc
    723  1af8		       65 e0		      adc	upk_temp
    724  1afa		       38		      sec
    725  1afb		       e9 30		      sbc	#"0"
    726  1afd		       85 de		      sta	upk_length
    727  1aff		       e6 df		      inc	upk_column	; flag we have seen a digit
    728  1b01		       4c cc f2 	      jmp	Get2
    729  1b04
    730  1b04		       c9 7c	   notDigit   cmp	#"|"	; newline
    731  1b06		       d0 11		      bne	checkWall
    732  1b08
    733  1b08							; Handle new-line
    734  1b08		       a9 00		      lda	#0
    735  1b0a		       85 8a		      sta	POS_X
    736  1b0c		       e6 8b		      inc	POS_Y
    737  1b0e
    738  1b0e
    739  1b0e		       a5 8b		      lda	POS_Y
    740  1b10		       c5 95		      cmp	BoardLimit_Height
    741  1b12		       90 02		      bcc	wOK2
    742  1b14		       85 95		      sta	BoardLimit_Height	;???^^^
    743  1b16				   wOK2
    744  1b16
    745  1b16		       4c c4 f2 	      jmp	GetNextItem
    746  1b19
    747  1b19		       c9 23	   checkWall  cmp	#"#"	; wall
    748  1b1b		       d0 09		      bne	checkForGap
    749  1b1d		       a5 b6		      lda	levelX
    750  1b1f		       29 01		      and	#1
    751  1b21		       18		      clc
    752  1b22		       69 06		      adc	#CHARACTER_STEEL
    753  1b24		       d0 66		      bne	WriteChars
    754  1b26
    755  1b26		       c9 20	   checkForGap cmp	#32
    756  1b28		       f0 08		      beq	writeGap
    757  1b2a		       c9 2d		      cmp	#"-"
    758  1b2c		       f0 04		      beq	writeGap
    759  1b2e		       c9 5f		      cmp	#"_"
    760  1b30		       d0 05		      bne	checkForMan
    761  1b32
    762  1b32		       a9 00	   writeGap   lda	#CHARACTER_BLANK
    763  1b34		       4c 8c f3 	      jmp	WriteChars
    764  1b37
    765  1b37				   checkForMan
    766  1b37		       c9 2b		      cmp	#"+"	; player on goal square
    767  1b39		       d0 07		      bne	notPlayerGoal
    768  1b3b
    769  1b3b		       20 3d f2 	      jsr	RegisterOneMoreTarget
    770  1b3e
    771  1b3e							; put goal square, init player with POS_VAR = CHARACTER_TARGET
    772  1b3e
    773  1b3e		       a9 03		      lda	#CHARACTER_TARGET
    774  1b40		       d0 06		      bne	genPlayer
    775  1b42
    776  1b42				   notPlayerGoal
    777  1b42		       c9 40		      cmp	#"@"	; player on normal square
    778  1b44		       d0 2d		      bne	checkBox
    779  1b46
    780  1b46		       a9 00		      lda	#CHARACTER_BLANK
    781  1b48
    782  1b48				   genPlayer
    783  1b48
    784  1b48		       85 8f		      sta	POS_VAR	; character man is on
    785  1b4a
    786  1b4a		       18		      clc
    787  1b4b		       a5 8a		      lda	POS_X
    788  1b4d		       48		      pha
    789  1b4e		       65 dc		      adc	base_x
    790  1b50		       85 8a		      sta	POS_X
    791  1b52		       85 9b		      sta	ManX
    792  1b54
    793  1b54		       a5 8b		      lda	POS_Y
    794  1b56		       48		      pha
    795  1b57		       65 dd		      adc	base_y
    796  1b59		       85 8b		      sta	POS_Y
    797  1b5b		       85 9c		      sta	ManY
    798  1b5d
    799  1b5d							; POS_X     x position
    800  1b5d							; POS_Y     y position
    801  1b5d							; POS_VAR   CHARACTER UNDER MAN TO RESTORE
    802  1b5d							; POS_Type  type of object
    803  1b5d
    804  1b5d		       a9 00		      lda	#TYPE_MAN
    805  1b5f		       85 8e		      sta	POS_Type	;	 creature TYPE
    806  1b61		       20 29 f9 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    807  1b64
    808  1b64		       a9 00		      lda	#0
    809  1b66		       85 9a		      sta	manAnimationIndex
    810  1b68
    811  1b68		       68		      pla
    812  1b69		       85 8b		      sta	POS_Y
    813  1b6b		       68		      pla
    814  1b6c		       85 8a		      sta	POS_X
    815  1b6e
    816  1b6e		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    817  1b70		       4c 8c f3 	      jmp	WriteChars
    818  1b73
    819  1b73		       c9 24	   checkBox   cmp	#"$"
    820  1b75		       d0 04		      bne	checkBoxTarget
    821  1b77
    822  1b77		       a9 02		      lda	#CHARACTER_BOX
    823  1b79		       d0 11		      bne	WriteChars
    824  1b7b
    825  1b7b		       c9 2a	   checkBoxTarget cmp	#"*"
    826  1b7d		       d0 04		      bne	checkTarget
    827  1b7f
    828  1b7f		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    829  1b81		       d0 09		      bne	WriteChars
    830  1b83
    831  1b83		       c9 2e	   checkTarget cmp	#"."
    832  1b85		       f0 03		      beq	targ
    833  1b87		       4c c4 f2 	      jmp	GetNextItem
    834  1b8a				   targ
    835  1b8a
    836  1b8a		       a9 03		      lda	#CHARACTER_TARGET
    837  1b8c
    838  1b8c		       85 8e	   WriteChars sta	POS_Type
    839  1b8e
    840  1b8e		       18	   Wc2x       clc
    841  1b8f		       a5 8a		      lda	POS_X
    842  1b91		       48		      pha
    843  1b92		       65 dc		      adc	base_x
    844  1b94		       85 8a		      sta	POS_X
    845  1b96
    846  1b96		       a5 8b		      lda	POS_Y
    847  1b98		       48		      pha
    848  1b99		       65 dd		      adc	base_y
    849  1b9b		       85 8b		      sta	POS_Y
    850  1b9d
    851  1b9d		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    852  1ba0
    853  1ba0		       a5 8e		      lda	POS_Type
    854  1ba2		       c9 03		      cmp	#CHARACTER_TARGET
    855  1ba4		       d0 03		      bne	notargdet
    856  1ba6		       20 3d f2 	      jsr	RegisterOneMoreTarget
    857  1ba9				   notargdet
    858  1ba9
    859  1ba9		       68		      pla
    860  1baa		       85 8b		      sta	POS_Y
    861  1bac		       68		      pla
    862  1bad		       85 8a		      sta	POS_X
    863  1baf
    864  1baf		       18		      clc
    865  1bb0		       69 01		      adc	#1
    866  1bb2		       85 8a		      sta	POS_X
    867  1bb4
    868  1bb4		       c5 94		      cmp	BoardLimit_Width
    869  1bb6		       90 02		      bcc	wOK
    870  1bb8		       85 94		      sta	BoardLimit_Width
    871  1bba				   wOK
    872  1bba
    873  1bba		       c6 de		      dec	upk_length
    874  1bbc		       d0 d0		      bne	Wc2x
    875  1bbe		       4c c4 f2 	      jmp	GetNextItem
    876  1bc1
    877  1bc1				   finishedUnpack
    878  1bc1
    879  1bc1		       60		      rts
    880  1bc1					      endif
------- FILE BANK_GENERIC.asm
     44  1bc2
      0  1bc2					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_LEVEL)"
      1  1bc2
      2  1bc2
      3  1bc2		       03 c2	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_LEVEL) (1K) SIZE =  $3c2 , FREE= $3e
      4  1bc2					      ECHO	"GENERIC_BANK_1 (DECODE_LEVEL)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1bc2				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1bc2				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1bc2				  -	      ERR
      8  1bc2					      endif
     46  1bc2
     47  1bc2							;------------------------------------------------------------------------------
     48  1bc2							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     49  1bc2							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     50  1bc2							; bank finishes.  Just continue on from where it left off...
     51  1bc2							;------------------------------------------------------------------------------
     52  1bc2
      0  1bc2					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  1bc2		       00 03	   BANK_Cart_Init =	_CURRENT_BANK
      2  1bc2					      SUBROUTINE
      3  1bc2				   Cart_Init
     54  1bc2
     55  1bc2							; Note the variables from the title selection are incredibly transient an can be stomped
     56  1bc2							; at any time.  So they need to be used immediately.
     57  1bc2
     58  1bc2
     59  1bc2							; odd usage below is to prevent any possibility of variable stomping/assumptions
     60  1bc2
     61  1bc2		       a9 01		      lda	#1
     62  1bc4		       a2 00		      ldx	#0	;sLevel				      ; level # from title select
     63  1bc6		       a0 00		      ldy	#0	;sJoysticks
     64  1bc8		       84 a9		      sty	jtoggle
     65  1bca		       86 b7		      stx	level
     66  1bcc		       85 a7		      sta	ManCount	; = #players
     67  1bce		       a9 00		      lda	#0
     68  1bd0		       85 b6		      sta	levelX	; make an immediate copy to safe variables!
     69  1bd2		       85 e2		      sta	startingLevel
     70  1bd4
     71  1bd4							; multiply with LEVEL_DEFINITION_SIZE (5):
     72  1bd4		       0a		      asl
     73  1bd5		       0a		      asl
     74  1bd6		       85 b6		      sta	levelX
     75  1bd8
     76  1bd8		       a9 01		      lda	#1
     77  1bda		       85 99		      sta	whichPlayer	; will switch to 0 on 1st go
     78  1bdc
     79  1bdc		       a9 30		      lda	#NUM_LIVES<<4	; 3 lives
     80  1bde		       a6 a7		      ldx	ManCount	; = sPlayers
     81  1be0		       f0 02		      beq	opg
     82  1be2		       a9 33		      lda	#NUM_LIVES<<4|NUM_LIVES
     83  1be4		       85 a7	   opg	      sta	ManCount	; P2P1 nybble each
     84  1be6
     85  1be6							;---------------------------------------------------------------------------
     86  1be6
     87  1be6		       a9 00		      lda	#0
     88  1be8		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     89  1beb		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     90  1bee		       85 6b		      sta	HMCLR
     91  1bf0
     92  1bf0							; cleanup remains of title screen
     93  1bf0		       85 5b		      sta	GRP0
     94  1bf2		       85 5c		      sta	GRP1
     95  1bf4		       85 5b		      sta	GRP0
     96  1bf6
     97  1bf6		       85 89		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     98  1bf8		       85 aa		      sta	circle_d
     99  1bfa		       85 ab		      sta	circle_d+1
    100  1bfc
    101  1bfc							;    IFCONST DEBUG_CREATURE
    102  1bfc							;		  sta worstTime
    103  1bfc							;    ENDIF
    104  1bfc
    105  1bfc		       a9 04		      lda	#%100	; players/missiles BEHIND BG
    106  1bfe		       85 4a		      sta	CTRLPF
    107  1c00		       85 82		      sta	rnd	; anything non-0
    108  1c02
    109  1c02		       a9 ff		      lda	#$FF
    110  1c04		       85 84		      sta	DrawStackPointer
    111  1c06		       85 92		      sta	BufferedButton
    112  1c08		       85 93		      sta	BufferedButton+1
    113  1c0a
    114  1c0a		       a9 07		      lda	#DIRECTION_BITS
    115  1c0c		       85 a4		      sta	ManLastDirection
    116  1c0e
    117  1c0e		       a9 00		      lda	#0
    118  1c10							;		  sta ObjStackPtr		  ; object stack index of last entry
    119  1c10							;		  sta ObjStackPtr+1
    120  1c10							;		  sta ObjStackNum
    121  1c10							;		  sta ObjIterator
    122  1c10
    123  1c10		       85 ce		      sta	sortPtr
    124  1c12		       a9 ff		      lda	#<(-1)
    125  1c14		       85 cd		      sta	sortRequired
    126  1c16
    127  1c16							; read high score from SaveKey and store in highScoreSK,
    128  1c16							; which is transferred to high score variable in RAM by GeneralScoringSetups
    129  1c16		       4c 86 f6 	      jmp	ReadSaveKey
    130  1c19
    131  1c19							;LEVEL0CREATURE  .byte TYPE_MAN,	  0,	  3,	  5
    132  1c19							;		  .byte -1
    133  1c19
    134  1c19							;------------------------------------------------------------------------------
    135  1c19
      0  1c19					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  1c19		       00 03	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  1c19					      SUBROUTINE
      3  1c19				   SwapPlayersGeneric
    137  1c19
    138  1c19							; at the start of a level (or player, doesn't matter) we grab the current state of the colour/B&W switch
    139  1c19							; into the gameMode variable.
    140  1c19
    141  1c19		       a5 80		      lda	gameMode
    142  1c1b		       29 77		      and	#~(BW_SWITCH|GAMEMODE_PAUSED)
    143  1c1d		       85 80		      sta	gameMode
    144  1c1f		       ad 82 02 	      lda	SWCHB
    145  1c22		       29 08		      and	#BW_SWITCH
    146  1c24		       05 80		      ora	gameMode	; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    147  1c26		       85 80		      sta	gameMode	; also, BIT7=0 -- system is NOT paused
    148  1c28
    149  1c28
    150  1c28							; restart level
    151  1c28		       a5 cc		      lda	NextLevelTrigger
    152  1c2a		       29 bf		      and	#<(~BIT_NEXTLIFE)
    153  1c2c		       85 cc		      sta	NextLevelTrigger
    154  1c2e
    155  1c2e							; if new high score was set by SwapPlayers, update it:
    156  1c2e
    157  1c2e		       4c ac f6 	      jmp	WriteSaveKey
    158  1c31
    159  1c31
    160  1c31							;------------------------------------------------------------------------------
    161  1c31
      0  1c31					      DEFINE_SUBROUTINE	CreateCreatures
      1  1c31		       00 03	   BANK_CreateCreatures =	_CURRENT_BANK
      2  1c31					      SUBROUTINE
      3  1c31				   CreateCreatures
    163  1c31
    164  1c31							; Calculate rightmost value for scrolling edge.  .
    165  1c31
    166  1c31		       85 c6		      sta	ROM_Bank
    167  1c33
    168  1c33		       38		      sec
    169  1c34		       a5 94		      lda	BoardLimit_Width
    170  1c36		       e9 09		      sbc	#SCREEN_WIDTH-1
    171  1c38		       85 94		      sta	BoardEdge_Right	; absolute rightmost scroll value
    172  1c3a
    173  1c3a							;		  sec			     already set
    174  1c3a		       a5 95		      lda	BoardLimit_Height
    175  1c3c		       e9 07		      sbc	#SCREEN_LINES-1
    176  1c3e		       85 95		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    177  1c40
    178  1c40							; kludge position scroll roughly at player
    179  1c40
    180  1c40							;		  sec			 already set
    181  1c40		       a5 9b		      lda	ManX
    182  1c42		       e9 05		      sbc	#5
    183  1c44		       b0 02		      bcs	notL0
    184  1c46		       a9 00		      lda	#0
    185  1c48		       85 97	   notL0      sta	BoardScrollX
    186  1c4a
    187  1c4a
    188  1c4a		       38		      sec
    189  1c4b		       a5 9c		      lda	ManY
    190  1c4d		       e9 03		      sbc	#3	; TJ: why 5???
    191  1c4f		       b0 02		      bcs	notU0
    192  1c51		       a9 00		      lda	#0
    193  1c53		       85 96	   notU0      sta	BoardScrollY
    194  1c55
    195  1c55		       a9 00		      lda	#0
    196  1c57		       85 9f		      sta	ManMode
    197  1c59		       85 a0		      sta	ManDelayCount
    198  1c5b
    199  1c5b		       a9 1a		      lda	#AnimateBLANK-Manimate	;0 ;<AnimateBLANK ;STAND
    200  1c5d		       85 a1		      sta	ManAnimation
    201  1c5f							;lda #>AnimateBLANK ;
    202  1c5f							;sta ManAnimation+1
    203  1c5f
    204  1c5f		       a9 ff		      lda	#$FF
    205  1c61		       85 b3		      sta	LastSpriteY
    206  1c63
    207  1c63		       a9 07		      lda	#DIRECTION_BITS
    208  1c65		       85 a4		      sta	ManLastDirection
    209  1c67		       60		      rts
    210  1c68
    211  1c68							;-------------------------------------------------------------------------------------
    212  1c68
      0  1c68					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  1c68		       00 03	   BANK_LevelInit =	_CURRENT_BANK
      2  1c68					      SUBROUTINE
      3  1c68				   LevelInit
    214  1c68
    215  1c68		       a9 00		      lda	#0
    216  1c6a		       85 86		      sta	ObjStackPtr
    217  1c6c		       85 87		      sta	ObjStackPtr+1	; kill all creatures
    218  1c6e		       85 85		      sta	ObjStackNum
    219  1c70		       85 cf		      sta	ObjIterator
    220  1c72
    221  1c72		       85 98		      sta	scrollBits
    222  1c74		       85 89		      sta	ScreenDrawPhase
    223  1c76
    224  1c76		       85 b5		      sta	BGColour
    225  1c78		       85 c8		      sta	ColourTimer
    226  1c7a
    227  1c7a		       85 59		      sta	AUDV0
    228  1c7c		       85 5a		      sta	AUDV1	; turn off music while levels init
    229  1c7e							;		  sta AUDC0
    230  1c7e
    231  1c7e		       85 a4		      sta	ManLastDirection
    232  1c80		       85 a5		      sta	ManPushCounter
    233  1c82
    234  1c82		       85 ce		      sta	sortPtr	; sort stopped
    235  1c84		       a9 ff		      lda	#<(-1)
    236  1c86		       85 cd		      sta	sortRequired	; nothing needed
    237  1c88		       85 84		      sta	DrawStackPointer
    238  1c8a
    239  1c8a		       a9 00		      lda	#DISPLAY_TIME	;DISPLAY_SCORE
    240  1c8c		       85 cb		      sta	scoringFlags
    241  1c8e		       a9 00		      lda	#0	;SCORING_TIMER_FIRST		      ; We want the first timer display to be long, to show level and lives
    242  1c90		       85 ca		      sta	scoringTimer
    243  1c92		       60		      rts
    244  1c93
    245  1c93							;-------------------------------------------------------------------------------------
    246  1c93
      0  1c93					      DEFINE_SUBROUTINE	Resync
      1  1c93		       00 03	   BANK_Resync =	_CURRENT_BANK
      2  1c93					      SUBROUTINE
      3  1c93				   Resync
      0  1c93					      RESYNC
      1  1c93
      2  1c93		       a9 02		      lda	#%10
      3  1c95		       85 41		      sta	VBLANK
      4  1c97
      5  1c97		       a2 08		      ldx	#8
      6  1c99				   .loopResync
      0  1c99					      VERTICAL_SYNC
      1  1c99		       a9 0e		      lda	#%1110
      2  1c9b		       85 42	   .VSLP1     sta	WSYNC
      3  1c9d		       85 40		      sta	VSYNC
      4  1c9f		       4a		      lsr
      5  1ca0		       d0 f9		      bne	.VSLP1
      8  1ca2
      9  1ca2		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  1ca4		       a5 81		      lda	Platform
     11  1ca6		       49 02		      eor	#PAL_50
     12  1ca8		       d0 02		      bne	.ntsc
     13  1caa		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  1cac				   .ntsc
     15  1cac				   .loopWait
     16  1cac		       85 42		      sta	WSYNC
     17  1cae		       85 42		      sta	WSYNC
     18  1cb0		       88		      dey
     19  1cb1		       d0 f9		      bne	.loopWait
     20  1cb3		       ca		      dex
     21  1cb4		       d0 e3		      bne	.loopResync
    249  1cb6		       60	   Ret	      rts
    250  1cb7
    251  1cb7							;---------------------------------------------------------------------------
    252  1cb7
      0  1cb7					      DEFINE_SUBROUTINE	TrackPlayer	; =145; in GENERIC_BANK_1
      1  1cb7		       00 03	   BANK_TrackPlayer =	_CURRENT_BANK
      2  1cb7					      SUBROUTINE
      3  1cb7				   TrackPlayer
    254  1cb7
    255  1cb7		       a5 a6		      lda	LookingAround	; 3
    256  1cb9		       d0 fb		      bne	Ret	; 2/3=5/6   don't track when looking around
    257  1cbb
    258  1cbb							; Contribution by Thomas Jentzsch
    259  1cbb
    260  1cbb							; scrolling constants:
    261  1cbb		       00 03	   .SCRL_START_LEFT =	3	; 3
    262  1cbb		       00 03	   .SCRL_STOP_LEFT =	3	;SCREEN_WIDTH-5		    ; 5 scrolls 5-3+1 = 3 pixel
    263  1cbb		       00 07	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT	; 7
    264  1cbb		       00 07	   .SCRL_STOP_RIGHT =	SCREEN_WIDTH-.SCRL_STOP_LEFT	; 5
    265  1cbb		       00 11	   .SCRL_LEFT_BIT =	%00010001
    266  1cbb		       00 22	   .SCRL_RIGHT_BIT =	%00100010
    267  1cbb		       00 33	   .SCRL_X_BITS =	.SCRL_LEFT_BIT|.SCRL_RIGHT_BIT
    268  1cbb
    269  1cbb		       00 02	   .SCRL_START_UP =	2	; 2
    270  1cbb		       00 02	   .SCRL_STOP_UP =	2	;SCREEN_LINES-5		    ; 3 scrolls 3-2+1 = 2 pixel
    271  1cbb		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP	; 6
    272  1cbb		       00 06	   .SCRL_STOP_DOWN =	SCREEN_LINES-.SCRL_STOP_UP	; 5
    273  1cbb		       00 44	   .SCRL_UP_BIT =	%01000100
    274  1cbb		       00 88	   .SCRL_DOWN_BIT =	%10001000
    275  1cbb		       00 cc	   .SCRL_Y_BITS =	.SCRL_UP_BIT|.SCRL_DOWN_BIT
    276  1cbb
    277  1cbb							; *** horizontal scrolling (unoptimized version): ***
    278  1cbb
    279  1cbb							; check for enabling horizontal scrolling:
    280  1cbb		       a5 9b		      lda	ManX	; 3
    281  1cbd		       38		      sec		; 2
    282  1cbe		       e5 97		      sbc	BoardScrollX	; 3
    283  1cc0		       a8		      tay		; 2	     for later use
    284  1cc1		       a9 11		      lda	#.SCRL_LEFT_BIT	; 2
    285  1cc3		       c0 03		      cpy	#.SCRL_START_LEFT	; 2	     <3?
    286  1cc5		       30 06		      bmi	.startXScroll	; 2/3	     yes, scroll left
    287  1cc7		       c0 07		      cpy	#.SCRL_START_RIGHT	; 2	     <8?
    288  1cc9		       30 08		      bmi	.skipStartXScroll	; 2/3	     no
    289  1ccb		       a9 22		      lda	#.SCRL_RIGHT_BIT	; 2 = 22    yes, scroll right
    290  1ccd				   .startXScroll
    291  1ccd		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    292  1ccf		       05 98		      ora	scrollBits	; 3
    293  1cd1		       85 98		      sta	scrollBits	; 3 =	8
    294  1cd3				   .skipStartXScroll
    295  1cd3
    296  1cd3							; do horizontal scrolling:
    297  1cd3		       a5 98		      lda	scrollBits	; 3
    298  1cd5		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    299  1cd7		       f0 23		      beq	.skipXScroll	; 2/3
    300  1cd9		       29 22		      and	#.SCRL_RIGHT_BIT	; 2
    301  1cdb		       d0 0c		      bne	.xScrollRight	; 2/3=11/12
    302  1cdd
    303  1cdd							; scroll left:
    304  1cdd		       a5 97		      lda	BoardScrollX	; 3	     already at left edge?
    305  1cdf		       f0 15		      beq	.stopXScroll	; 2
    306  1ce1		       c6 97		      dec	BoardScrollX	; 5
    307  1ce3		       c0 02		      cpy	#.SCRL_STOP_LEFT-1	; 2
    308  1ce5		       10 0f		      bpl	.stopXScroll	; 2/3=15
    309  1ce7		       30 13		      bmi	.skipXScroll	; 3
    310  1ce9							;---------------------------------------
    311  1ce9				   .xScrollRight
    312  1ce9		       a6 97		      ldx	BoardScrollX	; 3
    313  1ceb		       e8		      inx		; 2
    314  1cec		       e4 94		      cpx	BoardEdge_Right	; 3	     already at right edge?
    315  1cee		       10 06		      bpl	.stopXScroll	; 2/3
    316  1cf0		       86 97		      stx	BoardScrollX	; 3
    317  1cf2		       c0 08		      cpy	#.SCRL_STOP_RIGHT+1	; 2
    318  1cf4		       10 06		      bpl	.skipXScroll	; 2/3=17/18
    319  1cf6				   .stopXScroll
    320  1cf6		       a5 98		      lda	scrollBits	; 3
    321  1cf8		       29 fc		      and	#(~(.SCRL_X_BITS >> 4))	; 2
    322  1cfa		       85 98		      sta	scrollBits	; 3 =	8
    323  1cfc				   .skipXScroll
    324  1cfc							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    325  1cfc
    326  1cfc							; *** vertical scrolling (unoptimized version): ***
    327  1cfc
    328  1cfc							; check for enabling vertical scrolling:
    329  1cfc		       a5 9c		      lda	ManY	; 3
    330  1cfe		       38		      sec		; 2
    331  1cff		       e5 96		      sbc	BoardScrollY	; 3
    332  1d01		       a8		      tay		; 2	     for later use
    333  1d02		       a9 44		      lda	#.SCRL_UP_BIT	; 2
    334  1d04		       c0 02		      cpy	#.SCRL_START_UP	; 2	     <2?
    335  1d06		       30 06		      bmi	.startYScroll	; 2/3	     yes, scroll up
    336  1d08		       c0 06		      cpy	#.SCRL_START_DOWN	; 2	     <6?
    337  1d0a		       30 08		      bmi	.skipStartYScroll	; 2/3
    338  1d0c		       a9 88		      lda	#.SCRL_DOWN_BIT	; 2 = 22    yes, scroll down
    339  1d0e				   .startYScroll
    340  1d0e		       29 0c		      and	#.SCRL_Y_BITS >> 4	; 2
    341  1d10		       05 98		      ora	scrollBits	; 3
    342  1d12		       85 98		      sta	scrollBits	; 3 =	8
    343  1d14				   .skipStartYScroll
    344  1d14
    345  1d14							; do vertical scrolling:
    346  1d14		       a5 98		      lda	scrollBits	; 3
    347  1d16		       29 cc		      and	#.SCRL_Y_BITS	; 2
    348  1d18		       f0 23		      beq	.skipYScroll	; 2/3
    349  1d1a		       29 88		      and	#.SCRL_DOWN_BIT	; 2
    350  1d1c		       d0 0c		      bne	.yScrollDown	; 2/3=11/12
    351  1d1e
    352  1d1e							; scroll up
    353  1d1e		       a5 96		      lda	BoardScrollY	; 3
    354  1d20		       f0 15		      beq	.stopYScroll	; 2
    355  1d22		       c6 96		      dec	BoardScrollY	; 5
    356  1d24		       c0 01		      cpy	#.SCRL_STOP_UP-1	; 2
    357  1d26		       10 0f		      bpl	.stopYScroll	; 2/3=15
    358  1d28		       30 13		      bmi	.skipYScroll	; 3
    359  1d2a							;---------------------------------------
    360  1d2a				   .yScrollDown
    361  1d2a		       a6 96		      ldx	BoardScrollY	; 3
    362  1d2c		       e8		      inx		; 2
    363  1d2d		       e4 95		      cpx	BoardEdge_Bottom	;     ; 3
    364  1d2f		       10 06		      bpl	.stopYScroll	; 2/3
    365  1d31		       86 96		      stx	BoardScrollY	; 3
    366  1d33		       c0 07		      cpy	#.SCRL_STOP_DOWN+1	; 2
    367  1d35		       10 06		      bpl	.skipYScroll	; 2/3=17/18
    368  1d37				   .stopYScroll
    369  1d37		       a5 98		      lda	scrollBits	; 3
    370  1d39		       29 f3		      and	#(~(.SCRL_Y_BITS >> 4))	; 2
    371  1d3b		       85 98		      sta	scrollBits	; 3 =	8
    372  1d3d				   .skipYScroll
    373  1d3d							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    374  1d3d
    375  1d3d		       60	   EarlyAbortx rts		; 6 =	6
    376  1d3e							; total: 5+67*2+6 = 145
    377  1d3e
    378  1d3e							;------------------------------------------------------------------------------
    379  1d3e
    380  1d3e
    381  1d3e
    382  1d3e							; worst case time from positive last check to rts: 123
    383  1d3e							; cycles until 0-check: 15
    384  1d3e							; minimum cycles available after last positive check until timer turns 0: (MINIMUM_SORT_TIME-1)*64+1
    385  1d3e							; MINIMUM_SORT_TIME = 3 = 129
    386  1d3e							; MINIMUM_SORT_TIME = 4 = 193 <- ok
    387  1d3e
    388  1d3e							;------------------------------------------------------------------------------
    389  1d3e
    390  1d3e							; This is a GOOD home for these tables.
    391  1d3e
      0  1d3e					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  1d3e		       00 03	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  1d3e					      SUBROUTINE
      3  1d3e				   TS_PhaseVectorLO
    393  1d3e
    394  1d3e							; Gives LO byte of addresses of subroutines for timeslice processing
    395  1d3e
    396  1d3e		       58		      .byte.b	<ProcessObjStack
    397  1d3f		       ac		      .byte.b	<DrawFullScreen
    398  1d40		       8e		      .byte.b	<BuildDrawStack
    399  1d41		       95		      .byte.b	<DrawAIntoStack
    400  1d42		       9b		      .byte.b	<SwitchObjects
    401  1d43
    402  1d43				   TS_PhaseVectorHI
    403  1d43
    404  1d43							; Gives HI byte of addresses of subroutines for timeslice processing
    405  1d43
    406  1d43		       f8		      .byte.b	>ProcessObjStack
    407  1d44		       f2		      .byte.b	>DrawFullScreen
    408  1d45		       fa		      .byte.b	>BuildDrawStack
    409  1d46		       fa		      .byte.b	>DrawAIntoStack
    410  1d47		       f8		      .byte.b	>SwitchObjects
    411  1d48
    412  1d48				   TS_PhaseBank
    413  1d48
    414  1d48							; Gives bank of subroutines for timeslice processing
    415  1d48
    416  1d48		       0f		      .byte.b	BANK_ProcessObjStack
    417  1d49		       0b		      .byte.b	BANK_DrawFullScreen
    418  1d4a		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    419  1d4b		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    420  1d4c		       0f		      .byte.b	BANK_SwitchObjects
    421  1d4d
    422  1d4d							;------------------------------------------------------------------------------
    423  1d4d		       02 02	   lookColour2 .byte.b	$02, $02
    424  1d4f		       04 04		      .byte.b	$04, $04
    425  1d51
    426  1d51				   OverscanTime
    427  1d51		       22 22		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    428  1d53		       29 22		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    429  1d55
    430  1d55		       c0 c0 50 50 FlashColour .byte.b	$C0, $C0, $50, $50
    431  1d59
    432  1d59
      0  1d59					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  1d59		       00 03	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  1d59					      SUBROUTINE
      3  1d59				   PostScreenCleanup
    434  1d59
    435  1d59		       c8		      iny		; --> 0
    436  1d5a
    437  1d5a		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    438  1d5c							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    439  1d5c
    440  1d5c		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    441  1d5e							; TJ: no idea why, but you had removed it in revision 758 ;)
    442  1d5e							; completely accidental -- one of our cats may have deleted it.
    443  1d5e		       84 4e		      sty	PF1
    444  1d60		       84 4f		      sty	PF2
    445  1d62		       84 5d		      sty	ENAM0
    446  1d64		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    447  1d66		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    448  1d68
    449  1d68							; D1 VBLANK turns off beam
    450  1d68
    451  1d68		       a9 42		      lda	#%01000010	; bit6 is not required
    452  1d6a		       85 41		      sta	VBLANK	; end of screen - enter blanking
    453  1d6c
    454  1d6c							;------------------------------------------------------------------------------
    455  1d6c							; This is where the PAL system has a bit of extra time on a per-frame basis.
    456  1d6c
    457  1d6c		       a6 81		      ldx	Platform
    458  1d6e		       bd 51 f5 	      lda	OverscanTime,x
    459  1d71		       8d 96 02 	      sta	TIM64T
    460  1d74
    461  1d74							; Background colour priorities. Increasing order of priority...
    462  1d74							;	black -- nothing happening
    463  1d74							;	looking around			     lookingAround<0		     BLUE
    464  1d74							;	when paused			     gameMode... BIT7		     RED
    465  1d74							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    466  1d74
    467  1d74
    468  1d74							;		  lda LookingAround
    469  1d74							;		  bpl nolooker			  ; if not looking around, that will do nicely
    470  1d74							;		  ldy #0 ;sok
    471  1d74							;;		   ldy lookColour2,x		   ; otherwise, use the lookaround colour as the base
    472  1d74							;nolooker	  sty BGColour			  ; 'BASE' colour pause reverts TO when unpaused
    473  1d74
    474  1d74		       a5 ba		      lda	ThrottleSpeed
    475  1d76		       18		      clc
    476  1d77		       65 b9		      adc	Throttle
    477  1d79		       b0 02		      bcs	noVerflo
    478  1d7b		       85 b9		      sta	Throttle
    479  1d7d				   noVerflo
    480  1d7d
    481  1d7d
    482  1d7d							;----------------------------------------------------------------------------------------------
    483  1d7d							; handle pause button for 2600 and 7800
    484  1d7d
    485  1d7d							; Timings:  NOT including palette setting or platform detect
    486  1d7d							; 2600:     no button press:	 11 cycles
    487  1d7d							;	     with button press:  21 cycles
    488  1d7d							; 7800      no button press:	 16 cycles
    489  1d7d							;	     with button press:  21 cycles
    490  1d7d
    491  1d7d
    492  1d7d
    493  1d7d		       00 08	   BW_SWITCH  =	$08	; NOTE: Shares bit position with SWCHB COLOUR/B&W SWITCH
    494  1d7d
    495  1d7d		       24 80		      bit	gameMode
    496  1d7f		       50 0b		      bvc	.pause7800	; 7800 platform
    497  1d81
    498  1d81							; 2600 pause logic...
    499  1d81
    500  1d81		       ad 82 02 	      lda	SWCHB
    501  1d84		       45 80		      eor	gameMode
    502  1d86		       29 08		      and	#BW_SWITCH
    503  1d88		       f0 17		      beq	.setPauseCol	; no different to original state = no pause change
    504  1d8a		       d0 0f		      bne	.buttonDown	; unconditional
    505  1d8c
    506  1d8c							; 7800 pause logic...
    507  1d8c
    508  1d8c							; When the button is pressed, we check if it's the FIRST time it's pressed.
    509  1d8c							; This FIRST time is indicated by the PFLAG7800 being clear.  If it's the first time, we toggle the pause
    510  1d8c							; flag (BIT6) AND we toggle the PFLAG7800 so continued button-down does nothing.  When the button is
    511  1d8c							; released, then we again toggle the PFLAG7800, allowing a FIRST time check once again, when the button
    512  1d8c							; is next pressed.
    513  1d8c
    514  1d8c		       a9 08	   .pause7800 lda	#BW_SWITCH
    515  1d8e		       2c 82 02 	      bit	SWCHB
    516  1d91		       f0 04		      beq	.pausePress
    517  1d93		       05 80		      ora	gameMode	; not pressed, so enable first time press
    518  1d95		       d0 08		      bne	.fixPause	; unconditional
    519  1d97
    520  1d97		       24 80	   .pausePress bit	gameMode
    521  1d99		       f0 06		      beq	.setPauseCol	; NOT the first time in pause - so do nothing new
    522  1d9b
    523  1d9b							; Button is down, and we have detected it as a FIRST-TIME button press.
    524  1d9b
    525  1d9b		       45 80	   .buttonDown eor	gameMode	; toggle first time flag(7800) or current switch state(2600)
    526  1d9d		       49 80		      eor	#GAMEMODE_PAUSED	; toggle pause flag
    527  1d9f		       85 80	   .fixPause  sta	gameMode
    528  1da1
    529  1da1		       a5 80	   .setPauseCol lda	gameMode	; are we paused?
    530  1da3		       10 07		      bpl	.exitPause	; only show pause colour when actually paused
    531  1da5
    532  1da5		       a6 81		      ldx	Platform
    533  1da7		       bd 17 f6 	      lda	pscol,x
    534  1daa		       85 b5		      sta	BGColour	; set main screen background colour.  RED is paused.
    535  1dac
    536  1dac				   .exitPause
    537  1dac
    538  1dac							;----------------------------------------------------------------------------------------------
    539  1dac
    540  1dac							; has to be done AFTER screen display, because it disables the effect!
    541  1dac		       a5 82		      lda	rnd	; 3	 randomly reposition the Cosmic Ark missile
    542  1dae		       85 62		      sta	HMM0	; 3	 this assumes that HMOVE is called at least once/frame
    543  1db0
    544  1db0							; "Flash" has highest BG colour priority
    545  1db0
    546  1db0		       a5 c8		      lda	ColourTimer
    547  1db2		       f0 07		      beq	noFlashBG
    548  1db4		       c6 c8		      dec	ColourTimer
    549  1db6		       a6 81		      ldx	Platform
    550  1db8		       bd 55 f5 	      lda	FlashColour,x
    551  1dbb		       85 b5	   noFlashBG  sta	BGColour
    552  1dbd
    553  1dbd							; Handle the player joystick reading. We do it *every frame* so that we can incorporate a two-frame
    554  1dbd							; buffer.  This is designed to give a little better responsiveness to the 'quick tap' movement.
    555  1dbd
    556  1dbd		       a5 90		      lda	BufferedJoystick	; previous frame
    557  1dbf		       85 91		      sta	BufferedJoystick+1	; -> buffered
    558  1dc1
    559  1dc1
    560  1dc1							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    561  1dc1							; P2 is shifted UP, so we don't need to worry in usage elsewhere (it's same format as a P1 joystick)
    562  1dc1
    563  1dc1		       a5 99		      lda	whichPlayer	; 3
    564  1dc3		       25 a9		      and	jtoggle	; 3
    565  1dc5		       aa		      tax		; 2
    566  1dc6
    567  1dc6		       b5 4c		      lda	INPT4,x	; 4
    568  1dc8		       25 92		      and	BufferedButton
    569  1dca		       85 92		      sta	BufferedButton	; 3 = 15
    570  1dcc
    571  1dcc		       ad 80 02 	      lda	SWCHA	; 4
    572  1dcf
    573  1dcf		       ca		      dex		; 2
    574  1dd0		       30 04		      bmi	notP2	; 2/3= 8/9
    575  1dd2
    576  1dd2		       0a		      asl		; 2
    577  1dd3		       0a		      asl		; 2
    578  1dd4		       0a		      asl		; 2
    579  1dd5		       0a		      asl		; 2 =	8
    580  1dd6		       85 90	   notP2      sta	BufferedJoystick	; 3
    581  1dd8
    582  1dd8
    583  1dd8							; "Scoring timer" reset stomp comment
    584  1dd8
    585  1dd8		       a5 ca		      lda	scoringTimer
    586  1dda		       f0 0a		      beq	timer0now
    587  1ddc		       c6 ca		      dec	scoringTimer
    588  1dde		       d0 06		      bne	timer0now
    589  1de0		       a5 cb		      lda	scoringFlags
    590  1de2		       29 fc		      and	#<(~DISPLAY_FLAGS)	;	 switches to time display
    591  1de4		       85 cb		      sta	scoringFlags
    592  1de6				   timer0now
    593  1de6
    594  1de6							; fall through
    595  1de6
    596  1de6							;-------------------------------------------------------------------------------------
    597  1de6							; Player animation happens *every* frame so that we get good animation speeds.  Note that
    598  1de6							; the player animation consists of running a small animation 'program', and then actually drawing
    599  1de6							; the player.	The draw is the neat bit, because all it does is update some self-modifying pointers
    600  1de6							; inside the actual draw kernel in the appropriate bank.
    601  1de6
    602  1de6
      0  1de6					      DEFINE_SUBROUTINE	AnimatePlayers	; in GENERIC_BANK_1
      1  1de6		       00 03	   BANK_AnimatePlayers =	_CURRENT_BANK
      2  1de6					      SUBROUTINE
      3  1de6				   AnimatePlayers
    604  1de6
    605  1de6							; Optimised 7/1/2012 -- single page tables
    606  1de6
    607  1de6							; This interesting code performs the animations for the player(s) and sets the
    608  1de6							; pointers INSIDE the row bank for the draw code to point to the correct player
    609  1de6							; shape.  Kind of neat, as it doesn't require any shape copying (=speed!)
    610  1de6
    611  1de6
    612  1de6							; Cycle the player through his animation list.  The animation of a player is a direct
    613  1de6							; pointer to the actual shape used to display the player.  This shape is in turn
    614  1de6							; written to the current bank's self-modifying locations for the draw.  Since
    615  1de6							; we are effectively drawing from this current bank, the same code can be used
    616  1de6							; to 'undraw' the player as required.
    617  1de6
    618  1de6
    619  1de6							; x = player index
    620  1de6							; sets ManAnimation = FRAME to display for player
    621  1de6							; ManAnimation = index of player program into Manimate list
    622  1de6
    623  1de6		       24 80		      bit	gameMode
    624  1de8		       30 2c		      bmi	AnimationOK	; don't animate during pause
    625  1dea
    626  1dea		       c6 a0		      dec	ManDelayCount
    627  1dec		       10 28		      bpl	AnimationOK
    628  1dee
    629  1dee		       a4 a1	   ReloadAnimation ldy	ManAnimation
    630  1df0		       b9 00 f7    ContinueAnim lda	Manimate,y	; delay count
    631  1df3		       d0 07		      bne	NewFrameOK
    632  1df5		       b9 01 f7 	      lda	Manimate+1,y
    633  1df8		       a8		      tay
    634  1df9		       4c f0 f5 	      jmp	ContinueAnim
    635  1dfc
    636  1dfc		       10 0d	   NewFrameOK bpl	doDelay
    637  1dfe
    638  1dfe		       c8		      iny		; handle a REFLECT
    639  1dff		       a5 a4		      lda	ManLastDirection
    640  1e01		       29 f7		      and	#%11110111
    641  1e03		       19 00 f7 	      ora	Manimate,y
    642  1e06		       85 a4		      sta	ManLastDirection
    643  1e08
    644  1e08		       c8		      iny
    645  1e09		       d0 e5		      bne	ContinueAnim
    646  1e0b
    647  1e0b		       85 a0	   doDelay    sta	ManDelayCount
    648  1e0d
    649  1e0d		       c8		      iny
    650  1e0e		       b9 00 f7 	      lda	Manimate,y
    651  1e11		       85 a3		      sta	ManAnimationFrameLO
    652  1e13
    653  1e13		       c8		      iny
    654  1e14		       84 a1		      sty	ManAnimation
    655  1e16
    656  1e16		       60	   AnimationOK rts
    657  1e17
    658  1e17
    659  1e17
    660  1e17		       40 40	   pscol      .byte.b	$40, $40
    661  1e19		       60 60		      .byte.b	$60, $60
    662  1e1b
    663  1e1b							;------------------------------------------------------------------------------
    664  1e1b
------- FILE i2c_v2.2.inc LEVEL 3 PASS 4
      0  1e1b					      include	"i2c_v2.2.inc"
      1  1e1b							;
      2  1e1b							; i2c_v2.2.inc
      3  1e1b							;
      4  1e1b							;
      5  1e1b							; AtariVox EEPROM Driver
      6  1e1b							;
      7  1e1b							; By Alex Herbert, 2004
      8  1e1b							;
      9  1e1b							; Optimisations by Thomas Jentzsch, 2006/2008
     10  1e1b							;
     11  1e1b
     12  1e1b
     13  1e1b							; I/O Constants
     14  1e1b
     15  1e1b		       00 04	   I2C_SDA_MASK equ	$04
     16  1e1b		       00 08	   I2C_SCL_MASK equ	$08
     17  1e1b
     18  1e1b
     19  1e1b							; Signalling Macros
     20  1e1b
     21  1e1b							;  MAC     I2C_SCL_0
     22  1e1b							;    lda     #$00
     23  1e1b							;    sta     SWCHA
     24  1e1b							;  ENDM
     25  1e1b
     26  1e1b							;  MAC     I2C_SCL_1
     27  1e1b							;    lda     #I2C_SCL_MASK
     28  1e1b							;    sta     SWCHA
     29  1e1b							;  ENDM
     30  1e1b
     31  1e1b							;  MAC     I2C_SDA_IN
     32  1e1b							;    lda     #I2C_SCL_MASK
     33  1e1b							;    sta     SWACNT
     34  1e1b							;  ENDM
     35  1e1b
     36  1e1b							;  MAC     I2C_SDA_OUT
     37  1e1b							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  1e1b							;    sta     SWACNT
     39  1e1b							;  ENDM
     40  1e1b
     41  1e1b
     42  1e1b					      MAC	i2c_start
     43  1e1b							; I2C_SCL_1
     44  1e1b					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  1e1b					      sta	SWCHA	; 4
     46  1e1b							; I2C_SDA_OUT
     47  1e1b					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  1e1b					      sta	SWACNT	; 4
     49  1e1b							; total: 12 cycles
     50  1e1b					      ENDM
     51  1e1b
     52  1e1b
     53  1e1b					      MAC	i2c_txbit
     54  1e1b							; I2C_SCL_0
     55  1e1b					      lda	#%0011	; 2
     56  1e1b					      sta	SWCHA	; 4
     57  1e1b							; set bit
     58  1e1b					      adc	#%1000	; 2
     59  1e1b					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  1e1b							; I2C_SCL_1
     61  1e1b					      lda	#I2C_SCL_MASK	; 2
     62  1e1b					      sta	SWCHA	; 4
     63  1e1b							; total: 18 cycles
     64  1e1b					      ENDM
     65  1e1b
     66  1e1b
     67  1e1b					      MAC	i2c_txnack
     68  1e1b							; I2C_SCL_0
     69  1e1b					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  1e1b					      sta	SWCHA	; 4
     71  1e1b							; I2C_SDA_IN
     72  1e1b					      lsr		; 2	     I2C_SCL_MASK
     73  1e1b					      sta	SWACNT	; 4
     74  1e1b							; I2C_SCL_1
     75  1e1b					      nop		; 2	     required for timing!
     76  1e1b					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  1e1b							; total: 18 cycles
     78  1e1b					      ENDM
     79  1e1b
     80  1e1b
     81  1e1b							; Subroutine Macros
     82  1e1b
     83  1e1b					      MAC	i2c_subs
     84  1e1b
     85  1e1b				   i2c_startread
     86  1e1b							; use V to flag if previous byte needs ACK
     87  1e1b					      ldy	#%10100001	; 2	     eeprom read command
     88  1e1b					      .byte	$2c	; 2
     89  1e1b				   i2c_startwrite
     90  1e1b					      ldy	#%10100000	; 2	     eeprom write command
     91  1e1b					      I2C_START		;12	     start signal (clears V flag)
     92  1e1b					      tya		; 2 = 16
     93  1e1b				   i2c_txbyte
     94  1e1b					      eor	#$ff	; 2	     invert data byte
     95  1e1b					      sec		; 2
     96  1e1b					      rol		; 2 =	6    shift loop bit into a
     97  1e1b				   i2c_txbyteloop
     98  1e1b					      tay		; 2
     99  1e1b					      I2C_TXBIT		;18	     transmit
    100  1e1b					      tya		; 2
    101  1e1b					      asl		; 2	     shift next bit into C
    102  1e1b					      bne	i2c_txbyteloop	; 2= 26/27
    103  1e1b
    104  1e1b							; receive acknowledge bit
    105  1e1b
    106  1e1b					      beq	i2c_rxbit	;43 = 43
    107  1e1b							; i2c_txbyte: 264 cycles
    108  1e1b							;-------------------------------------------------------------------------------
    109  1e1b
    110  1e1b				   i2c_rxbyte
    111  1e1b					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  1e1b					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  1e1b
    114  1e1b				   i2c_rxskipack
    115  1e1b					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  1e1b
    117  1e1b					      lda	#1	; 2
    118  1e1b				   i2c_rxbyteloop
    119  1e1b					      tay		; 2 =	2
    120  1e1b				   i2c_rxbit		;	     receive bit in C
    121  1e1b					      I2C_TXNACK		;18 = 18
    122  1e1b
    123  1e1b					      lda	SWCHA	; 4
    124  1e1b					      lsr		; 2
    125  1e1b					      lsr		; 2
    126  1e1b					      lsr		; 2 = 10    C = SDA
    127  1e1b
    128  1e1b					      tya		; 2
    129  1e1b					      rol		; 2	     rotate into Y
    130  1e1b					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  1e1b
    132  1e1b							; received byte in A
    133  1e1b					      rts		; 6 =	6
    134  1e1b							; i2c_rxbit:  40 cycles
    135  1e1b							; i2c_rxbyte: 310/333 cycles
    136  1e1b							;-------------------------------------------------------------------------------
    137  1e1b
    138  1e1b				   i2c_stopread
    139  1e1b					      bvc	i2c_stopwrite	; 2
    140  1e1b					      ldy	#$80	; 2
    141  1e1b					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  1e1b
    143  1e1b				   i2c_stopwrite
    144  1e1b					      jsr	i2c_txack	;30
    145  1e1b
    146  1e1b							; return port to input mode
    147  1e1b					      lda	#0	; 2	     0
    148  1e1b					      sta	SWACNT	; 4
    149  1e1b					      rts		; 6 = 12
    150  1e1b							; i2c_stopread:  45/92
    151  1e1b							; i2c_stopwrite: 42
    152  1e1b							;-------------------------------------------------------------------------------
    153  1e1b
    154  1e1b				   i2c_txack
    155  1e1b							; I2C_SCL_0
    156  1e1b					      lda	#0	; 2	     $00
    157  1e1b					      sta	SWCHA	; 4
    158  1e1b							; I2C_SDA_OUT
    159  1e1b					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  1e1b					      sta	SWACNT	; 4
    161  1e1b							; I2C_SCL_1
    162  1e1b					      asl		; 2	     I2C_SCL_MASK
    163  1e1b					      sta	SWCHA	; 4
    164  1e1b
    165  1e1b					      rts		; 6
    166  1e1b							; total: 24 cycles
    167  1e1b							;-------------------------------------------------------------------------------
    168  1e1b
    169  1e1b					      ENDM
    170  1e1b
    171  1e1b
    172  1e1b
------- FILE BANK_GENERIC.asm
    666  1e1b
      0  1e1b					      i2c_subs
      1  1e1b
      2  1e1b				   i2c_startread
      3  1e1b
      4  1e1b		       a0 a1		      ldy	#%10100001
      5  1e1d		       2c		      .byte.b	$2c
      6  1e1e				   i2c_startwrite
      7  1e1e		       a0 a0		      ldy	#%10100000
      0  1e20					      I2C_START
      1  1e20
      2  1e20		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  1e22		       8d 80 02 	      sta	SWCHA
      4  1e25
      5  1e25		       4a		      lsr
      6  1e26		       8d 81 02 	      sta	SWACNT
      7  1e29
      9  1e29		       98		      tya
     10  1e2a				   i2c_txbyte
     11  1e2a		       49 ff		      eor	#$ff
     12  1e2c		       38		      sec
     13  1e2d		       2a		      rol
     14  1e2e				   i2c_txbyteloop
     15  1e2e		       a8		      tay
      0  1e2f					      I2C_TXBIT
      1  1e2f
      2  1e2f		       a9 03		      lda	#%0011
      3  1e31		       8d 80 02 	      sta	SWCHA
      4  1e34
      5  1e34		       69 08		      adc	#%1000
      6  1e36		       8d 81 02 	      sta	SWACNT
      7  1e39
      8  1e39		       a9 08		      lda	#I2C_SCL_MASK
      9  1e3b		       8d 80 02 	      sta	SWCHA
     10  1e3e
     17  1e3e		       98		      tya
     18  1e3f		       0a		      asl
     19  1e40		       d0 ec		      bne	i2c_txbyteloop
     20  1e42
     21  1e42
     22  1e42
     23  1e42		       f0 0b		      beq	i2c_rxbit
     24  1e44
     25  1e44
     26  1e44
     27  1e44				   i2c_rxbyte
     28  1e44		       50 03		      bvc	i2c_rxskipack
     29  1e46		       20 77 f6 	      jsr	i2c_txack
     30  1e49
     31  1e49				   i2c_rxskipack
     32  1e49		       2c 44 f6 	      bit	i2c_rxbyte
     33  1e4c
     34  1e4c		       a9 01		      lda	#1
     35  1e4e				   i2c_rxbyteloop
     36  1e4e		       a8		      tay
     37  1e4f				   i2c_rxbit
      0  1e4f					      I2C_TXNACK
      1  1e4f
      2  1e4f		       a9 10		      lda	#I2C_SCL_MASK*2
      3  1e51		       8d 80 02 	      sta	SWCHA
      4  1e54
      5  1e54		       4a		      lsr
      6  1e55		       8d 81 02 	      sta	SWACNT
      7  1e58
      8  1e58		       ea		      nop
      9  1e59		       8d 80 02 	      sta	SWCHA
     10  1e5c
     39  1e5c
     40  1e5c		       ad 80 02 	      lda	SWCHA
     41  1e5f		       4a		      lsr
     42  1e60		       4a		      lsr
     43  1e61		       4a		      lsr
     44  1e62
     45  1e62		       98		      tya
     46  1e63		       2a		      rol
     47  1e64		       90 e8		      bcc	i2c_rxbyteloop
     48  1e66
     49  1e66
     50  1e66		       60		      rts
     51  1e67
     52  1e67
     53  1e67
     54  1e67
     55  1e67				   i2c_stopread
     56  1e67		       50 05		      bvc	i2c_stopwrite
     57  1e69		       a0 80		      ldy	#$80
     58  1e6b		       20 4f f6 	      jsr	i2c_rxbit
     59  1e6e
     60  1e6e				   i2c_stopwrite
     61  1e6e		       20 77 f6 	      jsr	i2c_txack
     62  1e71
     63  1e71
     64  1e71		       a9 00		      lda	#0
     65  1e73		       8d 81 02 	      sta	SWACNT
     66  1e76		       60		      rts
     67  1e77
     68  1e77
     69  1e77
     70  1e77
     71  1e77				   i2c_txack
     72  1e77
     73  1e77		       a9 00		      lda	#0
     74  1e79		       8d 80 02 	      sta	SWCHA
     75  1e7c
     76  1e7c		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  1e7e		       8d 81 02 	      sta	SWACNT
     78  1e81
     79  1e81		       0a		      asl
     80  1e82		       8d 80 02 	      sta	SWCHA
     81  1e85
     82  1e85		       60		      rts
     83  1e86
     84  1e86
     85  1e86
    668  1e86
    669  1e86				   HandleSaveKey SUBROUTINE
    670  1e86
    671  1e86		       2f 00	   SAVEKEY_ADR =	$2F00	;	     tentative address for Sokoban (64 bytes)
    672  1e86
    673  1e86							;------------------------------------------------------------------------------
      0  1e86					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  1e86		       00 03	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  1e86					      SUBROUTINE
      3  1e86				   ReadSaveKey
    675  1e86
    676  1e86							; assume no SaveKey found:
    677  1e86		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    678  1e88		       85 e1		      sta	highScoreSK+2	; 3
    679  1e8a
    680  1e8a							; setup SaveKey:
    681  1e8a		       a5 e2		      lda	startingLevel	; 3	     load start levelX*5 and level
    682  1e8c		       a6 b7		      ldx	level	; 3
    683  1e8e		       20 c7 f6 	      jsr	SetupSaveKey	;6+853
    684  1e91		       90 52		      bcc	NoSKfound	; 2/3
    685  1e93
    686  1e93							;    lda     #$34
    687  1e93							;    sta     COLUBK
    688  1e93
    689  1e93							; start read
    690  1e93		       20 6e f6 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    691  1e96		       20 1b f6 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    692  1e99
    693  1e99							; read high score:
    694  1e99		       a2 02		      ldx	#3-1	; 2 = 1187
    695  1e9b				   .loopRead
    696  1e9b		       20 44 f6 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    697  1e9e		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    698  1ea0		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    699  1ea2		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    700  1ea4				   .skipEmpty
    701  1ea4		       95 df		      sta	highScoreSK,x	; 4
    702  1ea6		       ca		      dex		; 2
    703  1ea7		       10 f2		      bpl	.loopRead	; 2/3= 354
    704  1ea9
    705  1ea9							; stop read:
    706  1ea9		       4c 67 f6 	      jmp	i2c_stopread	;3+92=95    terminate read
    707  1eac
    708  1eac							;------------------------------------------------------------------------------
      0  1eac					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  1eac		       00 03	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  1eac					      SUBROUTINE
      3  1eac				   WriteSaveKey
    710  1eac
    711  1eac							; check if new high score:
    712  1eac		       a6 df		      ldx	highScoreSK	; 3
    713  1eae		       e8		      inx		; 2
    714  1eaf		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    715  1eb1
    716  1eb1							; setup SaveKey:
    717  1eb1		       a5 e2		      lda	startingLevel	; 3	     load start levelX*5 and level
    718  1eb3		       a6 e3		      ldx	startLevel	; 3
    719  1eb5		       20 c7 f6 	      jsr	SetupSaveKey	; 6+853
    720  1eb8		       90 2b		      bcc	NoSKfound	; 2/3
    721  1eba
    722  1eba							;    lda     #$64
    723  1eba							;    sta     COLUBK
    724  1eba
    725  1eba							; write high score:
    726  1eba		       a2 02		      ldx	#3-1	; 2 = 841
    727  1ebc				   .loopWrite
    728  1ebc		       b5 df		      lda	highScoreSK,x	; 4
    729  1ebe		       20 2a f6 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    730  1ec1		       ca		      dex		; 2
    731  1ec2		       10 f8		      bpl	.loopWrite	; 2/3= 837
    732  1ec4
    733  1ec4							; stop write:
    734  1ec4		       4c 6e f6 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    735  1ec7
    736  1ec7
    737  1ec7							;------------------------------------------------------------------------------
      0  1ec7					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  1ec7		       00 03	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  1ec7					      SUBROUTINE
      3  1ec7				   SetupSaveKey
    739  1ec7
    740  1ec7							; calculate slot;
    741  1ec7							; a = levelX
    742  1ec7							; x = level (0..4)
    743  1ec7		       85 e4		      sta	offsetSK	; 3
    744  1ec9		       8a		      txa		; 2
    745  1eca		       18		      clc		; 2
    746  1ecb		       65 e4		      adc	offsetSK	; 3
    747  1ecd		       85 e4		      sta	offsetSK	; 3
    748  1ecf		       0a		      asl		; 2	     multiply by 3
    749  1ed0		       65 e4		      adc	offsetSK	; 3
    750  1ed2		       69 00		      adc	#<SAVEKEY_ADR	; 2
    751  1ed4		       aa		      tax		; 2 = 22
    752  1ed5							; detect SaveKey:
    753  1ed5		       20 1e f6 	      jsr	i2c_startwrite	;6+280
    754  1ed8		       d0 0a		      bne	.exitSK	; 2/3
    755  1eda
    756  1eda							; setup address:
    757  1eda		       b8		      clv		; 2
    758  1edb		       a9 2f		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    759  1edd		       20 2a f6 	      jsr	i2c_txbyte	;6+264
    760  1ee0		       8a		      txa		; 2	     x = lower byte offset
    761  1ee1		       4c 2a f6 	      jmp	i2c_txbyte	;3+264      returns C==1
    762  1ee4
    763  1ee4				   .exitSK
    764  1ee4		       18		      clc
    765  1ee5				   NoSKfound
    766  1ee5		       60		      rts
    767  1ee5					      ENDIF
    768  1ee6
    769  1f00		       00 00 00 00*	      align	256
    770  1f00
    771  1f00				   Manimate
    772  1f00				   AnimateSTAND
    773  1f00				   AnimateRIGHT
    774  1f00				   AnimateLEFT
    775  1f00				   AnimateUP
    776  1f00				   AnimateSTOPPED
    777  1f00		       7f		      .byte.b	127
    778  1f01		       ce		      .byte.b	<PLAYER_RIGHT0	;PLAYER_STAND
    779  1f02							;.byte 10
    780  1f02							;.byte < PLAYER_BLINK
    781  1f02							;.byte 127
    782  1f02							;.byte < PLAYER_STAND
    783  1f02							;.byte 0
    784  1f02							;.word AnimateTAP
    785  1f02
    786  1f02				   AnimateTAP
    787  1f02							;.byte 128, %0 		  ; reflect off, always tap with left foot
    788  1f02							;.byte 8
    789  1f02							;.byte < PLAYER_TAP0
    790  1f02							;.byte 8
    791  1f02							;.byte < PLAYER_TAP1
    792  1f02							;.byte 8
    793  1f02							;.byte < PLAYER_TAP0
    794  1f02							;.byte 8
    795  1f02							;.byte < PLAYER_TAP1
    796  1f02							;.byte 8
    797  1f02							;.byte < PLAYER_TAP0
    798  1f02							;.byte 8
    799  1f02							;.byte < PLAYER_TAP1
    800  1f02		       00		      .byte.b	0
    801  1f03		       00		      .byte.b	AnimateSTAND-Manimate	;word AnimateSTAND
    802  1f04
    803  1f04							;AnimateRIGHT
    804  1f04		       80 00		      .byte.b	128, %0	; reflect off
    805  1f06		       05		      .byte.b	5
    806  1f07		       ce		      .byte.b	< PLAYER_RIGHT0
    807  1f08		       05		      .byte.b	5
    808  1f09		       e6		      .byte.b	< PLAYER_RIGHT1
    809  1f0a		       00		      .byte.b	0
    810  1f0b		       00		      .byte.b	AnimateRIGHT-Manimate	;word AnimateRIGHT
    811  1f0c
    812  1f0c							;AnimateLEFT
    813  1f0c		       80 08		      .byte.b	128, %1000	; reflect ON
    814  1f0e		       05		      .byte.b	5
    815  1f0f		       ce		      .byte.b	< PLAYER_RIGHT0
    816  1f10		       05		      .byte.b	5
    817  1f11		       e6		      .byte.b	< PLAYER_RIGHT1
    818  1f12		       00		      .byte.b	0
    819  1f13		       00		      .byte.b	AnimateLEFT-Manimate	;word AnimateLEFT
    820  1f14
    821  1f14							;AnimateUP
    822  1f14							;    .byte 128, %0		   ; reflect off
    823  1f14							;    .byte 5
    824  1f14							;    .byte < PLAYER_TAP
    825  1f14							;    .byte 128, %1000
    826  1f14							;    .byte 5
    827  1f14							;    .byte < PLAYER_TAP
    828  1f14							;    .byte 0
    829  1f14							;    .word AnimateUP
    830  1f14
    831  1f14							;AnimateUP
    832  1f14		       05		      .byte.b	5
    833  1f15		       ce		      .byte.b	< PLAYER_RIGHT0
    834  1f16		       05		      .byte.b	5
    835  1f17		       e6		      .byte.b	< PLAYER_RIGHT1
    836  1f18		       00		      .byte.b	0
    837  1f19		       00		      .byte.b	AnimateUP-Manimate	;word AnimateUP
    838  1f1a
    839  1f1a				   AnimateBLANK
    840  1f1a		       7f		      .byte.b	127
    841  1f1b		       b6		      .byte.b	< PLAYER_BLANK
    842  1f1c		       00		      .byte.b	0
    843  1f1d		       1a		      .byte.b	AnimateBLANK-Manimate	;word AnimateBLANK
    844  1f1e
    845  1f1e				   AnimateEND
      0  1f1e					      CHECKPAGEX	Manimate, "AnimateEND @ BANK_GENERIC"
      9  1f1e					      LIST	ON
    847  1f1e
    848  1f1e
      0  1f1e					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  1f1e		       07 1e	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $71e , FREE= $e2
      2  1f1e					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1f1e				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1f1e				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1f1e				  -	      ERR
      6  1f1e					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS1.asm LEVEL 2 PASS 4
      0  1f1e					      include	"BANK_LEVELS1.asm"
      1  1f1e							;    Sokoboo - a Sokoban implementation
      2  1f1e							;    using a generic tile-based display engine for the Atari 2600
      3  1f1e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1f1e							;
      5  1f1e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1f1e							;
      7  1f1e							;    Code related to the generic tile-based display engine was developed by
      8  1f1e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1f1e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1f1e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1f1e							;
     12  1f1e							;    Code related to music and sound effects uses the TIATracker music player
     13  1f1e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1f1e							;    directory for Apache licensing details.
     15  1f1e							;
     16  1f1e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1f1e							;    See the copyright notices in the License directory for a list of level
     18  1f1e							;    contributors.
     19  1f1e							;
     20  1f1e							;    Except where otherwise indicated, this software is released under the
     21  1f1e							;    following licensing arrangement...
     22  1f1e							;
     23  1f1e							;    This program is free software: you can redistribute it and/or modify
     24  1f1e							;    it under the terms of the GNU General Public License as published by
     25  1f1e							;    the Free Software Foundation, either version 3 of the License, or
     26  1f1e							;    (at your option) any later version.
     27  1f1e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1f1e
     29  1f1e							;    This program is distributed in the hope that it will be useful,
     30  1f1e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1f1e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1f1e							;    GNU General Public License for more details.
     33  1f1e
      0  1f1e					      NEWBANK	LEVELS1
      1  27b5 ????				      SEG	LEVELS1
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   LEVELS1    SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	LEVELS1
     35  2000
     36  2000
     37  2000							;  DEFL _000_SELECT, "12#|#@3-5$.#|10-|10-|12#"
     38  2000
     39  2000							; "SOKWHOLE" collection...
     40  2000
     41  2000
      0  2000					      DEFL	_001_L, "3#|#@#|#$#|#.#|3#"
      0  2000					      START_LEVEL	_001_L
      1  2000				   LEVEL_START SET	*
      2  2000		       00 04	   BANK_LEVEL__001_L =	_CURRENT_BANK
      3  2000				   LEVEL__001_L SUBROUTINE
      4  2000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2000
      2  2000		       33 23 7c 23*	      .byte.b	"3#|#@#|#$#|#.#|3#",0
      0  2012					      END_LEVEL	_001_L
      1  2012		       00 12	   LEVEL_SIZE__001_L =	* - LEVEL_START
      2  2012					      IF	LEVEL_SIZE__001_L > MAX_LEVEL_SIZE
      3  2012				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_L
      4  2012					      ENDIF
      0  2012					      DEFL	_001_R, "5#|#.$@#|5#"
      0  2012					      START_LEVEL	_001_R
      1  2012				   LEVEL_START SET	*
      2  2012		       00 04	   BANK_LEVEL__001_R =	_CURRENT_BANK
      3  2012				   LEVEL__001_R SUBROUTINE
      4  2012				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2012
      2  2012		       35 23 7c 23*	      .byte.b	"5#|#.$@#|5#",0
      0  201e					      END_LEVEL	_001_R
      1  201e		       00 0c	   LEVEL_SIZE__001_R =	* - LEVEL_START
      2  201e				  -	      IF	LEVEL_SIZE__001_R > MAX_LEVEL_SIZE
      3  201e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_R
      4  201e					      ENDIF
      0  201e					      DEFL	_002_L, "3#2-|#.3#|#*$-#|#2-@#|5#"
      0  201e					      START_LEVEL	_002_L
      1  201e				   LEVEL_START SET	*
      2  201e		       00 04	   BANK_LEVEL__002_L =	_CURRENT_BANK
      3  201e				   LEVEL__002_L SUBROUTINE
      4  201e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  201e
      2  201e		       33 23 32 2d*	      .byte.b	"3#2-|#.3#|#*$-#|#2-@#|5#",0
      0  2037					      END_LEVEL	_002_L
      1  2037		       00 19	   LEVEL_SIZE__002_L =	* - LEVEL_START
      2  2037					      IF	LEVEL_SIZE__002_L > MAX_LEVEL_SIZE
      3  2037				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_L
      4  2037					      ENDIF
      0  2037					      DEFL	_002_R, "2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#"
      0  2037					      START_LEVEL	_002_R
      1  2037				   LEVEL_START SET	*
      2  2037		       00 04	   BANK_LEVEL__002_R =	_CURRENT_BANK
      3  2037				   LEVEL__002_R SUBROUTINE
      4  2037				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2037
      2  2037		       32 2d 35 23*	      .byte.b	"2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#",0
      0  205f					      END_LEVEL	_002_R
      1  205f		       00 28	   LEVEL_SIZE__002_R =	* - LEVEL_START
      2  205f					      IF	LEVEL_SIZE__002_R > MAX_LEVEL_SIZE
      3  205f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_R
      4  205f					      ENDIF
      0  205f					      DEFL	_003_L, "4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-"
      0  205f					      START_LEVEL	_003_L
      1  205f				   LEVEL_START SET	*
      2  205f		       00 04	   BANK_LEVEL__003_L =	_CURRENT_BANK
      3  205f				   LEVEL__003_L SUBROUTINE
      4  205f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  205f
      2  205f		       34 2d 35 23*	      .byte.b	"4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-",0
      0  208b					      END_LEVEL	_003_L
      1  208b		       00 2c	   LEVEL_SIZE__003_L =	* - LEVEL_START
      2  208b					      IF	LEVEL_SIZE__003_L > MAX_LEVEL_SIZE
      3  208b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_L
      4  208b					      ENDIF
      0  208b					      DEFL	_003_R, "9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-"
      0  208b					      START_LEVEL	_003_R
      1  208b				   LEVEL_START SET	*
      2  208b		       00 04	   BANK_LEVEL__003_R =	_CURRENT_BANK
      3  208b				   LEVEL__003_R SUBROUTINE
      4  208b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  208b
      2  208b		       39 23 7c 23*	      .byte.b	"9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-",0
      0  20b5					      END_LEVEL	_003_R
      1  20b5		       00 2a	   LEVEL_SIZE__003_R =	* - LEVEL_START
      2  20b5				  -	      IF	LEVEL_SIZE__003_R > MAX_LEVEL_SIZE
      3  20b5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_R
      4  20b5					      ENDIF
      0  20b5					      DEFL	_004_L, "5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-"
      0  20b5					      START_LEVEL	_004_L
      1  20b5				   LEVEL_START SET	*
      2  20b5		       00 04	   BANK_LEVEL__004_L =	_CURRENT_BANK
      3  20b5				   LEVEL__004_L SUBROUTINE
      4  20b5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20b5
      2  20b5		       35 23 2d 7c*	      .byte.b	"5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-",0
      0  20d8					      END_LEVEL	_004_L
      1  20d8		       00 23	   LEVEL_SIZE__004_L =	* - LEVEL_START
      2  20d8				  -	      IF	LEVEL_SIZE__004_L > MAX_LEVEL_SIZE
      3  20d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_L
      4  20d8					      ENDIF
      0  20d8					      DEFL	_004_R, "-6#|-#4-#|2#-$*$#|#@$3.#|7#"
      0  20d8					      START_LEVEL	_004_R
      1  20d8				   LEVEL_START SET	*
      2  20d8		       00 04	   BANK_LEVEL__004_R =	_CURRENT_BANK
      3  20d8				   LEVEL__004_R SUBROUTINE
      4  20d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20d8
      2  20d8		       2d 36 23 7c*	      .byte.b	"-6#|-#4-#|2#-$*$#|#@$3.#|7#",0
      0  20f4					      END_LEVEL	_004_R
      1  20f4		       00 1c	   LEVEL_SIZE__004_R =	* - LEVEL_START
      2  20f4				  -	      IF	LEVEL_SIZE__004_R > MAX_LEVEL_SIZE
      3  20f4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_R
      4  20f4					      ENDIF
      0  20f4					      DEFL	_005_L, "3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-"
      0  20f4					      START_LEVEL	_005_L
      1  20f4				   LEVEL_START SET	*
      2  20f4		       00 04	   BANK_LEVEL__005_L =	_CURRENT_BANK
      3  20f4				   LEVEL__005_L SUBROUTINE
      4  20f4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20f4
      2  20f4		       33 2d 35 23*	      .byte.b	"3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-",0
      0  2126					      END_LEVEL	_005_L
      1  2126		       00 32	   LEVEL_SIZE__005_L =	* - LEVEL_START
      2  2126					      IF	LEVEL_SIZE__005_L > MAX_LEVEL_SIZE
      3  2126				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_L
      4  2126					      ENDIF
      0  2126					      DEFL	_005_R, "6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-"
      0  2126					      START_LEVEL	_005_R
      1  2126				   LEVEL_START SET	*
      2  2126		       00 04	   BANK_LEVEL__005_R =	_CURRENT_BANK
      3  2126				   LEVEL__005_R SUBROUTINE
      4  2126				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2126
      2  2126		       36 23 32 2d*	      .byte.b	"6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-",0
      0  2165					      END_LEVEL	_005_R
      1  2165		       00 3f	   LEVEL_SIZE__005_R =	* - LEVEL_START
      2  2165					      IF	LEVEL_SIZE__005_R > MAX_LEVEL_SIZE
      3  2165				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_R
      4  2165					      ENDIF
      0  2165					      DEFL	_006_L, "5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-"
      0  2165					      START_LEVEL	_006_L
      1  2165				   LEVEL_START SET	*
      2  2165		       00 04	   BANK_LEVEL__006_L =	_CURRENT_BANK
      3  2165				   LEVEL__006_L SUBROUTINE
      4  2165				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2165
      2  2165		       35 23 33 2d*	      .byte.b	"5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-",0
      0  21a0					      END_LEVEL	_006_L
      1  21a0		       00 3b	   LEVEL_SIZE__006_L =	* - LEVEL_START
      2  21a0				  -	      IF	LEVEL_SIZE__006_L > MAX_LEVEL_SIZE
      3  21a0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_L
      4  21a0					      ENDIF
      0  21a0					      DEFL	_006_R, "3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-"
      0  21a0					      START_LEVEL	_006_R
      1  21a0				   LEVEL_START SET	*
      2  21a0		       00 04	   BANK_LEVEL__006_R =	_CURRENT_BANK
      3  21a0				   LEVEL__006_R SUBROUTINE
      4  21a0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21a0
      2  21a0		       33 23 34 2d*	      .byte.b	"3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-",0
      0  21de					      END_LEVEL	_006_R
      1  21de		       00 3e	   LEVEL_SIZE__006_R =	* - LEVEL_START
      2  21de				  -	      IF	LEVEL_SIZE__006_R > MAX_LEVEL_SIZE
      3  21de				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_R
      4  21de					      ENDIF
      0  21de					      DEFL	_007_L, "6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#"
      0  21de					      START_LEVEL	_007_L
      1  21de				   LEVEL_START SET	*
      2  21de		       00 04	   BANK_LEVEL__007_L =	_CURRENT_BANK
      3  21de				   LEVEL__007_L SUBROUTINE
      4  21de				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21de
      2  21de		       36 23 2d 7c*	      .byte.b	"6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#",0
      0  220b					      END_LEVEL	_007_L
      1  220b		       00 2d	   LEVEL_SIZE__007_L =	* - LEVEL_START
      2  220b				  -	      IF	LEVEL_SIZE__007_L > MAX_LEVEL_SIZE
      3  220b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_L
      4  220b					      ENDIF
      0  220b					      DEFL	_007_R, "4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#"
      0  220b					      START_LEVEL	_007_R
      1  220b				   LEVEL_START SET	*
      2  220b		       00 04	   BANK_LEVEL__007_R =	_CURRENT_BANK
      3  220b				   LEVEL__007_R SUBROUTINE
      4  220b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  220b
      2  220b		       34 23 34 2d*	      .byte.b	"4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#",0
      0  223e					      END_LEVEL	_007_R
      1  223e		       00 33	   LEVEL_SIZE__007_R =	* - LEVEL_START
      2  223e				  -	      IF	LEVEL_SIZE__007_R > MAX_LEVEL_SIZE
      3  223e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_R
      4  223e					      ENDIF
      0  223e					      DEFL	_008_L, "2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-"
      0  223e					      START_LEVEL	_008_L
      1  223e				   LEVEL_START SET	*
      2  223e		       00 04	   BANK_LEVEL__008_L =	_CURRENT_BANK
      3  223e				   LEVEL__008_L SUBROUTINE
      4  223e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  223e
      2  223e		       32 2d 35 23*	      .byte.b	"2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-",0
      0  2274					      END_LEVEL	_008_L
      1  2274		       00 36	   LEVEL_SIZE__008_L =	* - LEVEL_START
      2  2274				  -	      IF	LEVEL_SIZE__008_L > MAX_LEVEL_SIZE
      3  2274				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_L
      4  2274					      ENDIF
      0  2274					      DEFL	_008_R, "-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#"
      0  2274					      START_LEVEL	_008_R
      1  2274				   LEVEL_START SET	*
      2  2274		       00 04	   BANK_LEVEL__008_R =	_CURRENT_BANK
      3  2274				   LEVEL__008_R SUBROUTINE
      4  2274				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2274
      2  2274		       2d 35 23 33*	      .byte.b	"-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#",0
      0  22a5					      END_LEVEL	_008_R
      1  22a5		       00 31	   LEVEL_SIZE__008_R =	* - LEVEL_START
      2  22a5				  -	      IF	LEVEL_SIZE__008_R > MAX_LEVEL_SIZE
      3  22a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_R
      4  22a5					      ENDIF
      0  22a5					      DEFL	_009_L, "-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#"
      0  22a5					      START_LEVEL	_009_L
      1  22a5				   LEVEL_START SET	*
      2  22a5		       00 04	   BANK_LEVEL__009_L =	_CURRENT_BANK
      3  22a5				   LEVEL__009_L SUBROUTINE
      4  22a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22a5
      2  22a5		       2d 35 23 2d*	      .byte.b	"-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#",0
      0  22d7					      END_LEVEL	_009_L
      1  22d7		       00 32	   LEVEL_SIZE__009_L =	* - LEVEL_START
      2  22d7				  -	      IF	LEVEL_SIZE__009_L > MAX_LEVEL_SIZE
      3  22d7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_L
      4  22d7					      ENDIF
      0  22d7					      DEFL	_009_R, "-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#"
      0  22d7					      START_LEVEL	_009_R
      1  22d7				   LEVEL_START SET	*
      2  22d7		       00 04	   BANK_LEVEL__009_R =	_CURRENT_BANK
      3  22d7				   LEVEL__009_R SUBROUTINE
      4  22d7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22d7
      2  22d7		       2d 33 23 33*	      .byte.b	"-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#",0
      0  2307					      END_LEVEL	_009_R
      1  2307		       00 30	   LEVEL_SIZE__009_R =	* - LEVEL_START
      2  2307				  -	      IF	LEVEL_SIZE__009_R > MAX_LEVEL_SIZE
      3  2307				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_R
      4  2307					      ENDIF
      0  2307					      DEFL	_010_L, "2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-"
      0  2307					      START_LEVEL	_010_L
      1  2307				   LEVEL_START SET	*
      2  2307		       00 04	   BANK_LEVEL__010_L =	_CURRENT_BANK
      3  2307				   LEVEL__010_L SUBROUTINE
      4  2307				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2307
      2  2307		       32 2d 33 23*	      .byte.b	"2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-",0
      0  2341					      END_LEVEL	_010_L
      1  2341		       00 3a	   LEVEL_SIZE__010_L =	* - LEVEL_START
      2  2341				  -	      IF	LEVEL_SIZE__010_L > MAX_LEVEL_SIZE
      3  2341				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_L
      4  2341					      ENDIF
      0  2341					      DEFL	_010_R, "4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-"
      0  2341					      START_LEVEL	_010_R
      1  2341				   LEVEL_START SET	*
      2  2341		       00 04	   BANK_LEVEL__010_R =	_CURRENT_BANK
      3  2341				   LEVEL__010_R SUBROUTINE
      4  2341				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2341
      2  2341		       34 23 32 2d*	      .byte.b	"4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-",0
      0  2374					      END_LEVEL	_010_R
      1  2374		       00 33	   LEVEL_SIZE__010_R =	* - LEVEL_START
      2  2374				  -	      IF	LEVEL_SIZE__010_R > MAX_LEVEL_SIZE
      3  2374				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_R
      4  2374					      ENDIF
      0  2374					      DEFL	_011_L, "-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-"
      0  2374					      START_LEVEL	_011_L
      1  2374				   LEVEL_START SET	*
      2  2374		       00 04	   BANK_LEVEL__011_L =	_CURRENT_BANK
      3  2374				   LEVEL__011_L SUBROUTINE
      4  2374				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2374
      2  2374		       2d 34 23 32*	      .byte.b	"-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-",0
      0  23a7					      END_LEVEL	_011_L
      1  23a7		       00 33	   LEVEL_SIZE__011_L =	* - LEVEL_START
      2  23a7				  -	      IF	LEVEL_SIZE__011_L > MAX_LEVEL_SIZE
      3  23a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_L
      4  23a7					      ENDIF
      0  23a7					      DEFL	_011_R, "2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#"
      0  23a7					      START_LEVEL	_011_R
      1  23a7				   LEVEL_START SET	*
      2  23a7		       00 04	   BANK_LEVEL__011_R =	_CURRENT_BANK
      3  23a7				   LEVEL__011_R SUBROUTINE
      4  23a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23a7
      2  23a7		       32 2d 33 23*	      .byte.b	"2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#",0
      0  23e1					      END_LEVEL	_011_R
      1  23e1		       00 3a	   LEVEL_SIZE__011_R =	* - LEVEL_START
      2  23e1				  -	      IF	LEVEL_SIZE__011_R > MAX_LEVEL_SIZE
      3  23e1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_R
      4  23e1					      ENDIF
      0  23e1					      DEFL	_012_L, "7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#"
      0  23e1					      START_LEVEL	_012_L
      1  23e1				   LEVEL_START SET	*
      2  23e1		       00 04	   BANK_LEVEL__012_L =	_CURRENT_BANK
      3  23e1				   LEVEL__012_L SUBROUTINE
      4  23e1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23e1
      2  23e1		       37 23 33 2d*	      .byte.b	"7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#",0
      0  2411					      END_LEVEL	_012_L
      1  2411		       00 30	   LEVEL_SIZE__012_L =	* - LEVEL_START
      2  2411				  -	      IF	LEVEL_SIZE__012_L > MAX_LEVEL_SIZE
      3  2411				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_L
      4  2411					      ENDIF
      0  2411					      DEFL	_012_R, "-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-"
      0  2411					      START_LEVEL	_012_R
      1  2411				   LEVEL_START SET	*
      2  2411		       00 04	   BANK_LEVEL__012_R =	_CURRENT_BANK
      3  2411				   LEVEL__012_R SUBROUTINE
      4  2411				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2411
      2  2411		       2d 36 23 32*	      .byte.b	"-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-",0
      0  244d					      END_LEVEL	_012_R
      1  244d		       00 3c	   LEVEL_SIZE__012_R =	* - LEVEL_START
      2  244d				  -	      IF	LEVEL_SIZE__012_R > MAX_LEVEL_SIZE
      3  244d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_R
      4  244d					      ENDIF
      0  244d					      DEFL	_013_L, "2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-"
      0  244d					      START_LEVEL	_013_L
      1  244d				   LEVEL_START SET	*
      2  244d		       00 04	   BANK_LEVEL__013_L =	_CURRENT_BANK
      3  244d				   LEVEL__013_L SUBROUTINE
      4  244d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  244d
      2  244d		       32 2d 35 23*	      .byte.b	"2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-",0
      0  248c					      END_LEVEL	_013_L
      1  248c		       00 3f	   LEVEL_SIZE__013_L =	* - LEVEL_START
      2  248c				  -	      IF	LEVEL_SIZE__013_L > MAX_LEVEL_SIZE
      3  248c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_L
      4  248c					      ENDIF
      0  248c					      DEFL	_013_R, "-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-"
      0  248c					      START_LEVEL	_013_R
      1  248c				   LEVEL_START SET	*
      2  248c		       00 04	   BANK_LEVEL__013_R =	_CURRENT_BANK
      3  248c				   LEVEL__013_R SUBROUTINE
      4  248c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  248c
      2  248c		       2d 35 23 32*	      .byte.b	"-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-",0
      0  24bf					      END_LEVEL	_013_R
      1  24bf		       00 33	   LEVEL_SIZE__013_R =	* - LEVEL_START
      2  24bf				  -	      IF	LEVEL_SIZE__013_R > MAX_LEVEL_SIZE
      3  24bf				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_R
      4  24bf					      ENDIF
      0  24bf					      DEFL	_014_L, "6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#"
      0  24bf					      START_LEVEL	_014_L
      1  24bf				   LEVEL_START SET	*
      2  24bf		       00 04	   BANK_LEVEL__014_L =	_CURRENT_BANK
      3  24bf				   LEVEL__014_L SUBROUTINE
      4  24bf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24bf
      2  24bf		       36 23 34 2d*	      .byte.b	"6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#",0
      0  2502					      END_LEVEL	_014_L
      1  2502		       00 43	   LEVEL_SIZE__014_L =	* - LEVEL_START
      2  2502					      IF	LEVEL_SIZE__014_L > MAX_LEVEL_SIZE
      3  2502				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_L
      4  2502					      ENDIF
      0  2502					      DEFL	_014_R, "6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-"
      0  2502					      START_LEVEL	_014_R
      1  2502				   LEVEL_START SET	*
      2  2502		       00 04	   BANK_LEVEL__014_R =	_CURRENT_BANK
      3  2502				   LEVEL__014_R SUBROUTINE
      4  2502				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2502
      2  2502		       36 23 33 2d*	      .byte.b	"6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-",0
      0  2545					      END_LEVEL	_014_R
      1  2545		       00 43	   LEVEL_SIZE__014_R =	* - LEVEL_START
      2  2545				  -	      IF	LEVEL_SIZE__014_R > MAX_LEVEL_SIZE
      3  2545				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_R
      4  2545					      ENDIF
      0  2545					      DEFL	_015_L, "2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#"
      0  2545					      START_LEVEL	_015_L
      1  2545				   LEVEL_START SET	*
      2  2545		       00 04	   BANK_LEVEL__015_L =	_CURRENT_BANK
      3  2545				   LEVEL__015_L SUBROUTINE
      4  2545				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2545
      2  2545		       32 2d 35 23*	      .byte.b	"2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#",0
      0  257a					      END_LEVEL	_015_L
      1  257a		       00 35	   LEVEL_SIZE__015_L =	* - LEVEL_START
      2  257a				  -	      IF	LEVEL_SIZE__015_L > MAX_LEVEL_SIZE
      3  257a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_L
      4  257a					      ENDIF
      0  257a					      DEFL	_015_R, "3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-"
      0  257a					      START_LEVEL	_015_R
      1  257a				   LEVEL_START SET	*
      2  257a		       00 04	   BANK_LEVEL__015_R =	_CURRENT_BANK
      3  257a				   LEVEL__015_R SUBROUTINE
      4  257a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  257a
      2  257a		       33 2d 35 23*	      .byte.b	"3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-",0
      0  25bf					      END_LEVEL	_015_R
      1  25bf		       00 45	   LEVEL_SIZE__015_R =	* - LEVEL_START
      2  25bf					      IF	LEVEL_SIZE__015_R > MAX_LEVEL_SIZE
      3  25bf				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_R
      4  25bf					      ENDIF
      0  25bf					      DEFL	_016_L, "4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-"
      0  25bf					      START_LEVEL	_016_L
      1  25bf				   LEVEL_START SET	*
      2  25bf		       00 04	   BANK_LEVEL__016_L =	_CURRENT_BANK
      3  25bf				   LEVEL__016_L SUBROUTINE
      4  25bf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25bf
      2  25bf		       34 2d 33 23*	      .byte.b	"4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-",0
      0  25f6					      END_LEVEL	_016_L
      1  25f6		       00 37	   LEVEL_SIZE__016_L =	* - LEVEL_START
      2  25f6				  -	      IF	LEVEL_SIZE__016_L > MAX_LEVEL_SIZE
      3  25f6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_L
      4  25f6					      ENDIF
      0  25f6					      DEFL	_016_R, "5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-"
      0  25f6					      START_LEVEL	_016_R
      1  25f6				   LEVEL_START SET	*
      2  25f6		       00 04	   BANK_LEVEL__016_R =	_CURRENT_BANK
      3  25f6				   LEVEL__016_R SUBROUTINE
      4  25f6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25f6
      2  25f6		       35 23 2d 7c*	      .byte.b	"5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-",0
      0  2629					      END_LEVEL	_016_R
      1  2629		       00 33	   LEVEL_SIZE__016_R =	* - LEVEL_START
      2  2629				  -	      IF	LEVEL_SIZE__016_R > MAX_LEVEL_SIZE
      3  2629				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_R
      4  2629					      ENDIF
      0  2629					      DEFL	_017_L, "5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-"
      0  2629					      START_LEVEL	_017_L
      1  2629				   LEVEL_START SET	*
      2  2629		       00 04	   BANK_LEVEL__017_L =	_CURRENT_BANK
      3  2629				   LEVEL__017_L SUBROUTINE
      4  2629				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2629
      2  2629		       35 23 34 2d*	      .byte.b	"5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-",0
      0  2673					      END_LEVEL	_017_L
      1  2673		       00 4a	   LEVEL_SIZE__017_L =	* - LEVEL_START
      2  2673					      IF	LEVEL_SIZE__017_L > MAX_LEVEL_SIZE
      3  2673				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_L
      4  2673					      ENDIF
      0  2673					      DEFL	_017_R, "3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-"
      0  2673					      START_LEVEL	_017_R
      1  2673				   LEVEL_START SET	*
      2  2673		       00 04	   BANK_LEVEL__017_R =	_CURRENT_BANK
      3  2673				   LEVEL__017_R SUBROUTINE
      4  2673				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2673
      2  2673		       33 2d 34 23*	      .byte.b	"3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-",0
      0  26b6					      END_LEVEL	_017_R
      1  26b6		       00 43	   LEVEL_SIZE__017_R =	* - LEVEL_START
      2  26b6				  -	      IF	LEVEL_SIZE__017_R > MAX_LEVEL_SIZE
      3  26b6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_R
      4  26b6					      ENDIF
      0  26b6					      DEFL	_018_L, "6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#"
      0  26b6					      START_LEVEL	_018_L
      1  26b6				   LEVEL_START SET	*
      2  26b6		       00 04	   BANK_LEVEL__018_L =	_CURRENT_BANK
      3  26b6				   LEVEL__018_L SUBROUTINE
      4  26b6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26b6
      2  26b6		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#",0
      0  26ea					      END_LEVEL	_018_L
      1  26ea		       00 34	   LEVEL_SIZE__018_L =	* - LEVEL_START
      2  26ea				  -	      IF	LEVEL_SIZE__018_L > MAX_LEVEL_SIZE
      3  26ea				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_L
      4  26ea					      ENDIF
      0  26ea					      DEFL	_018_R, "-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#"
      0  26ea					      START_LEVEL	_018_R
      1  26ea				   LEVEL_START SET	*
      2  26ea		       00 04	   BANK_LEVEL__018_R =	_CURRENT_BANK
      3  26ea				   LEVEL__018_R SUBROUTINE
      4  26ea				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26ea
      2  26ea		       2d 34 23 33*	      .byte.b	"-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#",0
      0  2726					      END_LEVEL	_018_R
      1  2726		       00 3c	   LEVEL_SIZE__018_R =	* - LEVEL_START
      2  2726				  -	      IF	LEVEL_SIZE__018_R > MAX_LEVEL_SIZE
      3  2726				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_R
      4  2726					      ENDIF
      0  2726					      DEFL	_019_L, "4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#"
      0  2726					      START_LEVEL	_019_L
      1  2726				   LEVEL_START SET	*
      2  2726		       00 04	   BANK_LEVEL__019_L =	_CURRENT_BANK
      3  2726				   LEVEL__019_L SUBROUTINE
      4  2726				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2726
      2  2726		       34 2d 35 23*	      .byte.b	"4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#",0
      0  2761					      END_LEVEL	_019_L
      1  2761		       00 3b	   LEVEL_SIZE__019_L =	* - LEVEL_START
      2  2761				  -	      IF	LEVEL_SIZE__019_L > MAX_LEVEL_SIZE
      3  2761				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_L
      4  2761					      ENDIF
      0  2761					      DEFL	_019_R, "2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#"
      0  2761					      START_LEVEL	_019_R
      1  2761				   LEVEL_START SET	*
      2  2761		       00 04	   BANK_LEVEL__019_R =	_CURRENT_BANK
      3  2761				   LEVEL__019_R SUBROUTINE
      4  2761				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2761
      2  2761		       32 2d 37 23*	      .byte.b	"2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#",0
      0  27b1					      END_LEVEL	_019_R
      1  27b1		       00 50	   LEVEL_SIZE__019_R =	* - LEVEL_START
      2  27b1					      IF	LEVEL_SIZE__019_R > MAX_LEVEL_SIZE
      3  27b1				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_R
      4  27b1					      ENDIF
     80  27b1
     81  27b1							;-----------------------------------------------------------
     82  27b1							; Stella 3E autodetect signature, can live anywhere
     83  27b1		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
     84  27b5							;-----------------------------------------------------------
     85  27b5
      0  27b5					      CHECK_BANK_SIZE	"LEVELS1"
      1  27b5		       07 b5	   .TEMP      =	* - BANK_START
 LEVELS1 (2K) SIZE =  $7b5 , FREE= $4b
      2  27b5					      ECHO	"LEVELS1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27b5				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  27b5				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27b5				  -	      ERR
      6  27b5					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS2.asm LEVEL 2 PASS 4
      0  27b5					      include	"BANK_LEVELS2.asm"
      1  27b5							;    Sokoboo - a Sokoban implementation
      2  27b5							;    using a generic tile-based display engine for the Atari 2600
      3  27b5							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  27b5							;
      5  27b5							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  27b5							;
      7  27b5							;    Code related to the generic tile-based display engine was developed by
      8  27b5							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  27b5							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  27b5							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  27b5							;
     12  27b5							;    Code related to music and sound effects uses the TIATracker music player
     13  27b5							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  27b5							;    directory for Apache licensing details.
     15  27b5							;
     16  27b5							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  27b5							;    See the copyright notices in the License directory for a list of level
     18  27b5							;    contributors.
     19  27b5							;
     20  27b5							;    Except where otherwise indicated, this software is released under the
     21  27b5							;    following licensing arrangement...
     22  27b5							;
     23  27b5							;    This program is free software: you can redistribute it and/or modify
     24  27b5							;    it under the terms of the GNU General Public License as published by
     25  27b5							;    the Free Software Foundation, either version 3 of the License, or
     26  27b5							;    (at your option) any later version.
     27  27b5							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  27b5
     29  27b5							;    This program is distributed in the hope that it will be useful,
     30  27b5							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  27b5							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  27b5							;    GNU General Public License for more details.
     33  27b5
      0  27b5					      NEWBANK	LEVELS2
      1  2fbe ????				      SEG	LEVELS2
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   LEVELS2    SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	LEVELS2
     35  2800
      0  2800					      DEFL	_020_L, "-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-"
      0  2800					      START_LEVEL	_020_L
      1  2800				   LEVEL_START SET	*
      2  2800		       00 05	   BANK_LEVEL__020_L =	_CURRENT_BANK
      3  2800				   LEVEL__020_L SUBROUTINE
      4  2800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2800
      2  2800		       2d 36 23 2d*	      .byte.b	"-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-",0
      0  283f					      END_LEVEL	_020_L
      1  283f		       00 3f	   LEVEL_SIZE__020_L =	* - LEVEL_START
      2  283f				  -	      IF	LEVEL_SIZE__020_L > MAX_LEVEL_SIZE
      3  283f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_L
      4  283f					      ENDIF
      0  283f					      DEFL	_020_R, "5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-"
      0  283f					      START_LEVEL	_020_R
      1  283f				   LEVEL_START SET	*
      2  283f		       00 05	   BANK_LEVEL__020_R =	_CURRENT_BANK
      3  283f				   LEVEL__020_R SUBROUTINE
      4  283f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  283f
      2  283f		       35 2d 34 23*	      .byte.b	"5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-",0
      0  287f					      END_LEVEL	_020_R
      1  287f		       00 40	   LEVEL_SIZE__020_R =	* - LEVEL_START
      2  287f				  -	      IF	LEVEL_SIZE__020_R > MAX_LEVEL_SIZE
      3  287f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_R
      4  287f					      ENDIF
      0  287f					      DEFL	_021_L, "4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-"
      0  287f					      START_LEVEL	_021_L
      1  287f				   LEVEL_START SET	*
      2  287f		       00 05	   BANK_LEVEL__021_L =	_CURRENT_BANK
      3  287f				   LEVEL__021_L SUBROUTINE
      4  287f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  287f
      2  287f		       34 2d 34 23*	      .byte.b	"4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-",0
      0  28d5					      END_LEVEL	_021_L
      1  28d5		       00 56	   LEVEL_SIZE__021_L =	* - LEVEL_START
      2  28d5					      IF	LEVEL_SIZE__021_L > MAX_LEVEL_SIZE
      3  28d5				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_L
      4  28d5					      ENDIF
      0  28d5					      DEFL	_021_R, "-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-"
      0  28d5					      START_LEVEL	_021_R
      1  28d5				   LEVEL_START SET	*
      2  28d5		       00 05	   BANK_LEVEL__021_R =	_CURRENT_BANK
      3  28d5				   LEVEL__021_R SUBROUTINE
      4  28d5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  28d5
      2  28d5		       2d 34 23 33*	      .byte.b	"-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-",0
      0  2909					      END_LEVEL	_021_R
      1  2909		       00 34	   LEVEL_SIZE__021_R =	* - LEVEL_START
      2  2909				  -	      IF	LEVEL_SIZE__021_R > MAX_LEVEL_SIZE
      3  2909				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_R
      4  2909					      ENDIF
      0  2909					      DEFL	_022_L, "3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-"
      0  2909					      START_LEVEL	_022_L
      1  2909				   LEVEL_START SET	*
      2  2909		       00 05	   BANK_LEVEL__022_L =	_CURRENT_BANK
      3  2909				   LEVEL__022_L SUBROUTINE
      4  2909				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2909
      2  2909		       33 2d 33 23*	      .byte.b	"3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-",0
      0  294f					      END_LEVEL	_022_L
      1  294f		       00 46	   LEVEL_SIZE__022_L =	* - LEVEL_START
      2  294f				  -	      IF	LEVEL_SIZE__022_L > MAX_LEVEL_SIZE
      3  294f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_L
      4  294f					      ENDIF
      0  294f					      DEFL	_022_R, "-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-"
      0  294f					      START_LEVEL	_022_R
      1  294f				   LEVEL_START SET	*
      2  294f		       00 05	   BANK_LEVEL__022_R =	_CURRENT_BANK
      3  294f				   LEVEL__022_R SUBROUTINE
      4  294f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  294f
      2  294f		       2d 33 23 34*	      .byte.b	"-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-",0
      0  298b					      END_LEVEL	_022_R
      1  298b		       00 3c	   LEVEL_SIZE__022_R =	* - LEVEL_START
      2  298b				  -	      IF	LEVEL_SIZE__022_R > MAX_LEVEL_SIZE
      3  298b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_R
      4  298b					      ENDIF
      0  298b					      DEFL	_023_L, "6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#"
      0  298b					      START_LEVEL	_023_L
      1  298b				   LEVEL_START SET	*
      2  298b		       00 05	   BANK_LEVEL__023_L =	_CURRENT_BANK
      3  298b				   LEVEL__023_L SUBROUTINE
      4  298b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  298b
      2  298b		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#",0
      0  29cc					      END_LEVEL	_023_L
      1  29cc		       00 41	   LEVEL_SIZE__023_L =	* - LEVEL_START
      2  29cc				  -	      IF	LEVEL_SIZE__023_L > MAX_LEVEL_SIZE
      3  29cc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_L
      4  29cc					      ENDIF
      0  29cc					      DEFL	_023_R, "7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-"
      0  29cc					      START_LEVEL	_023_R
      1  29cc				   LEVEL_START SET	*
      2  29cc		       00 05	   BANK_LEVEL__023_R =	_CURRENT_BANK
      3  29cc				   LEVEL__023_R SUBROUTINE
      4  29cc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  29cc
      2  29cc		       37 23 32 2d*	      .byte.b	"7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-",0
      0  2a0e					      END_LEVEL	_023_R
      1  2a0e		       00 42	   LEVEL_SIZE__023_R =	* - LEVEL_START
      2  2a0e				  -	      IF	LEVEL_SIZE__023_R > MAX_LEVEL_SIZE
      3  2a0e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_R
      4  2a0e					      ENDIF
      0  2a0e					      DEFL	_024_L, "-9#|-#7-#|-#-#2-$#-#|-#-#.*.#-#|2#2-.*-#-#|#3-.2$2-#|#-$2#2-3#|2#@2#2-#2-|-7#2-"
      0  2a0e					      START_LEVEL	_024_L
      1  2a0e				   LEVEL_START SET	*
      2  2a0e		       00 05	   BANK_LEVEL__024_L =	_CURRENT_BANK
      3  2a0e				   LEVEL__024_L SUBROUTINE
      4  2a0e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a0e
      2  2a0e		       2d 39 23 7c*	      .byte.b	"-9#|-#7-#|-#-#2-$#-#|-#-#.*.#-#|2#2-.*-#-#|#3-.2$2-#|#-$2#2-3#|2#@2#2-#2-|-7#2-",0
      0  2a5e					      END_LEVEL	_024_L
      1  2a5e		       00 50	   LEVEL_SIZE__024_L =	* - LEVEL_START
      2  2a5e				  -	      IF	LEVEL_SIZE__024_L > MAX_LEVEL_SIZE
      3  2a5e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__024_L
      4  2a5e					      ENDIF
      0  2a5e					      DEFL	_024_R, "-8#|2#6-#|#-$-*-#-#|#-3.*$-#|#2-*.*.2#|#2-#$-$-#|4#-$2-#|3-2#@3#|4-3#2-"
      0  2a5e					      START_LEVEL	_024_R
      1  2a5e				   LEVEL_START SET	*
      2  2a5e		       00 05	   BANK_LEVEL__024_R =	_CURRENT_BANK
      3  2a5e				   LEVEL__024_R SUBROUTINE
      4  2a5e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a5e
      2  2a5e		       2d 38 23 7c*	      .byte.b	"-8#|2#6-#|#-$-*-#-#|#-3.*$-#|#2-*.*.2#|#2-#$-$-#|4#-$2-#|3-2#@3#|4-3#2-",0
      0  2aa6					      END_LEVEL	_024_R
      1  2aa6		       00 48	   LEVEL_SIZE__024_R =	* - LEVEL_START
      2  2aa6				  -	      IF	LEVEL_SIZE__024_R > MAX_LEVEL_SIZE
      3  2aa6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__024_R
      4  2aa6					      ENDIF
      0  2aa6					      DEFL	_025_L, "4-4#2-|5#@-2#-|#4-2$-2#|#-3#2-$-#|#-3.2*.-#|#-2$*$2.2#|2#6-#-|-8#-"
      0  2aa6					      START_LEVEL	_025_L
      1  2aa6				   LEVEL_START SET	*
      2  2aa6		       00 05	   BANK_LEVEL__025_L =	_CURRENT_BANK
      3  2aa6				   LEVEL__025_L SUBROUTINE
      4  2aa6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2aa6
      2  2aa6		       34 2d 34 23*	      .byte.b	"4-4#2-|5#@-2#-|#4-2$-2#|#-3#2-$-#|#-3.2*.-#|#-2$*$2.2#|2#6-#-|-8#-",0
      0  2ae9					      END_LEVEL	_025_L
      1  2ae9		       00 43	   LEVEL_SIZE__025_L =	* - LEVEL_START
      2  2ae9				  -	      IF	LEVEL_SIZE__025_L > MAX_LEVEL_SIZE
      3  2ae9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__025_L
      4  2ae9					      ENDIF
      0  2ae9					      DEFL	_025_R, "-6#-|2#.-$-#-|#.*$*-2#|#.*2.$-#|2#3-#@#|-#-$-$-#|-3#2-2#|3-4#-"
      0  2ae9					      START_LEVEL	_025_R
      1  2ae9				   LEVEL_START SET	*
      2  2ae9		       00 05	   BANK_LEVEL__025_R =	_CURRENT_BANK
      3  2ae9				   LEVEL__025_R SUBROUTINE
      4  2ae9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ae9
      2  2ae9		       2d 36 23 2d*	      .byte.b	"-6#-|2#.-$-#-|#.*$*-2#|#.*2.$-#|2#3-#@#|-#-$-$-#|-3#2-2#|3-4#-",0
      0  2b28					      END_LEVEL	_025_R
      1  2b28		       00 3f	   LEVEL_SIZE__025_R =	* - LEVEL_START
      2  2b28				  -	      IF	LEVEL_SIZE__025_R > MAX_LEVEL_SIZE
      3  2b28				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__025_R
      4  2b28					      ENDIF
      0  2b28					      DEFL	_026_L, "-6#2-|2#-3.3#|#-$-2*.-#|#2-$-2*-#|#-$-$.$-#|#2-#-@2-#|9#"
      0  2b28					      START_LEVEL	_026_L
      1  2b28				   LEVEL_START SET	*
      2  2b28		       00 05	   BANK_LEVEL__026_L =	_CURRENT_BANK
      3  2b28				   LEVEL__026_L SUBROUTINE
      4  2b28				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b28
      2  2b28		       2d 36 23 32*	      .byte.b	"-6#2-|2#-3.3#|#-$-2*.-#|#2-$-2*-#|#-$-$.$-#|#2-#-@2-#|9#",0
      0  2b61					      END_LEVEL	_026_L
      1  2b61		       00 39	   LEVEL_SIZE__026_L =	* - LEVEL_START
      2  2b61				  -	      IF	LEVEL_SIZE__026_L > MAX_LEVEL_SIZE
      3  2b61				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__026_L
      4  2b61					      ENDIF
      0  2b61					      DEFL	_026_R, "5-4#|4-2#2-#|-4#3-#|2#2.-$2-#|#.3*$-2#|2#.$-$-#-|-3#-@2#-|3-4#2-"
      0  2b61					      START_LEVEL	_026_R
      1  2b61				   LEVEL_START SET	*
      2  2b61		       00 05	   BANK_LEVEL__026_R =	_CURRENT_BANK
      3  2b61				   LEVEL__026_R SUBROUTINE
      4  2b61				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b61
      2  2b61		       35 2d 34 23*	      .byte.b	"5-4#|4-2#2-#|-4#3-#|2#2.-$2-#|#.3*$-2#|2#.$-$-#-|-3#-@2#-|3-4#2-",0
      0  2ba2					      END_LEVEL	_026_R
      1  2ba2		       00 41	   LEVEL_SIZE__026_R =	* - LEVEL_START
      2  2ba2				  -	      IF	LEVEL_SIZE__026_R > MAX_LEVEL_SIZE
      3  2ba2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__026_R
      4  2ba2					      ENDIF
      0  2ba2					      DEFL	_027_L, "8#-|#3-@2-#-|#-*4$2#|2#*.#3-#|-#3.$2-#|-3#*.$-#|3-#.4#|3-3#3-"
      0  2ba2					      START_LEVEL	_027_L
      1  2ba2				   LEVEL_START SET	*
      2  2ba2		       00 05	   BANK_LEVEL__027_L =	_CURRENT_BANK
      3  2ba2				   LEVEL__027_L SUBROUTINE
      4  2ba2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ba2
      2  2ba2		       38 23 2d 7c*	      .byte.b	"8#-|#3-@2-#-|#-*4$2#|2#*.#3-#|-#3.$2-#|-3#*.$-#|3-#.4#|3-3#3-",0
      0  2be0					      END_LEVEL	_027_L
      1  2be0		       00 3e	   LEVEL_SIZE__027_L =	* - LEVEL_START
      2  2be0				  -	      IF	LEVEL_SIZE__027_L > MAX_LEVEL_SIZE
      3  2be0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__027_L
      4  2be0					      ENDIF
      0  2be0					      DEFL	_027_R, "7#2-|#5-2#-|#$2*-$-#-|#-*2.2-2#|#2.*3$-#|3#.#3-#|2-4#-@#|5-4#"
      0  2be0					      START_LEVEL	_027_R
      1  2be0				   LEVEL_START SET	*
      2  2be0		       00 05	   BANK_LEVEL__027_R =	_CURRENT_BANK
      3  2be0				   LEVEL__027_R SUBROUTINE
      4  2be0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2be0
      2  2be0		       37 23 32 2d*	      .byte.b	"7#2-|#5-2#-|#$2*-$-#-|#-*2.2-2#|#2.*3$-#|3#.#3-#|2-4#-@#|5-4#",0
      0  2c1e					      END_LEVEL	_027_R
      1  2c1e		       00 3e	   LEVEL_SIZE__027_R =	* - LEVEL_START
      2  2c1e				  -	      IF	LEVEL_SIZE__027_R > MAX_LEVEL_SIZE
      3  2c1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__027_R
      4  2c1e					      ENDIF
      0  2c1e					      DEFL	_028_L, "3-3#4-|4#.#4-|#-$-.#4-|#@#.*5#|#-$.*.3-#|#-2$-*$#-#|#2-#-.$2-#|4#4-2#|3-6#-"
      0  2c1e					      START_LEVEL	_028_L
      1  2c1e				   LEVEL_START SET	*
      2  2c1e		       00 05	   BANK_LEVEL__028_L =	_CURRENT_BANK
      3  2c1e				   LEVEL__028_L SUBROUTINE
      4  2c1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c1e
      2  2c1e		       33 2d 33 23*	      .byte.b	"3-3#4-|4#.#4-|#-$-.#4-|#@#.*5#|#-$.*.3-#|#-2$-*$#-#|#2-#-.$2-#|4#4-2#|3-6#-",0
      0  2c6a					      END_LEVEL	_028_L
      1  2c6a		       00 4c	   LEVEL_SIZE__028_L =	* - LEVEL_START
      2  2c6a				  -	      IF	LEVEL_SIZE__028_L > MAX_LEVEL_SIZE
      3  2c6a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__028_L
      4  2c6a					      ENDIF
      0  2c6a					      DEFL	_028_R, "9#-|#4-2#@#-|#-2#$#-$2#|#-.-.2$2-#|#-.*.2-#-#|#-#.#$3-#|#-#2*3-2#|#4-4#-|6#4-"
      0  2c6a					      START_LEVEL	_028_R
      1  2c6a				   LEVEL_START SET	*
      2  2c6a		       00 05	   BANK_LEVEL__028_R =	_CURRENT_BANK
      3  2c6a				   LEVEL__028_R SUBROUTINE
      4  2c6a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c6a
      2  2c6a		       39 23 2d 7c*	      .byte.b	"9#-|#4-2#@#-|#-2#$#-$2#|#-.-.2$2-#|#-.*.2-#-#|#-#.#$3-#|#-#2*3-2#|#4-4#-|6#4-",0
      0  2cb8					      END_LEVEL	_028_R
      1  2cb8		       00 4e	   LEVEL_SIZE__028_R =	* - LEVEL_START
      2  2cb8				  -	      IF	LEVEL_SIZE__028_R > MAX_LEVEL_SIZE
      3  2cb8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__028_R
      4  2cb8					      ENDIF
      0  2cb8					      DEFL	_029_L, "-5#3-|-#-@-2#2-|2#$*$-3#|#2.*.$2-#|#.*.$3-#|2#2-$-3#|-3#2-#2-|3-4#2-"
      0  2cb8					      START_LEVEL	_029_L
      1  2cb8				   LEVEL_START SET	*
      2  2cb8		       00 05	   BANK_LEVEL__029_L =	_CURRENT_BANK
      3  2cb8				   LEVEL__029_L SUBROUTINE
      4  2cb8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cb8
      2  2cb8		       2d 35 23 33*	      .byte.b	"-5#3-|-#-@-2#2-|2#$*$-3#|#2.*.$2-#|#.*.$3-#|2#2-$-3#|-3#2-#2-|3-4#2-",0
      0  2cfd					      END_LEVEL	_029_L
      1  2cfd		       00 45	   LEVEL_SIZE__029_L =	* - LEVEL_START
      2  2cfd				  -	      IF	LEVEL_SIZE__029_L > MAX_LEVEL_SIZE
      3  2cfd				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__029_L
      4  2cfd					      ENDIF
      0  2cfd					      DEFL	_029_R, "-4#4-|-#@-4#-|2#$-$2-2#|#2.3$2-#|#.2*.*$-#|3#2-2.-#|2-#2-$.2#|2-6#-"
      0  2cfd					      START_LEVEL	_029_R
      1  2cfd				   LEVEL_START SET	*
      2  2cfd		       00 05	   BANK_LEVEL__029_R =	_CURRENT_BANK
      3  2cfd				   LEVEL__029_R SUBROUTINE
      4  2cfd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cfd
      2  2cfd		       2d 34 23 34*	      .byte.b	"-4#4-|-#@-4#-|2#$-$2-2#|#2.3$2-#|#.2*.*$-#|3#2-2.-#|2-#2-$.2#|2-6#-",0
      0  2d41					      END_LEVEL	_029_R
      1  2d41		       00 44	   LEVEL_SIZE__029_R =	* - LEVEL_START
      2  2d41				  -	      IF	LEVEL_SIZE__029_R > MAX_LEVEL_SIZE
      3  2d41				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__029_R
      4  2d41					      ENDIF
      0  2d41					      DEFL	_030_L, "6-5#|5#-#2-@#|#3-3#2$-#|#2-$-2.-$2#|3#-.*.*-2#|2-3#-.$2-#|4-#3-#-#|4-2#4-#|5-6#"
      0  2d41					      START_LEVEL	_030_L
      1  2d41				   LEVEL_START SET	*
      2  2d41		       00 05	   BANK_LEVEL__030_L =	_CURRENT_BANK
      3  2d41				   LEVEL__030_L SUBROUTINE
      4  2d41				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d41
      2  2d41		       36 2d 35 23*	      .byte.b	"6-5#|5#-#2-@#|#3-3#2$-#|#2-$-2.-$2#|3#-.*.*-2#|2-3#-.$2-#|4-#3-#-#|4-2#4-#|5-6#",0
      0  2d91					      END_LEVEL	_030_L
      1  2d91		       00 50	   LEVEL_SIZE__030_L =	* - LEVEL_START
      2  2d91				  -	      IF	LEVEL_SIZE__030_L > MAX_LEVEL_SIZE
      3  2d91				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__030_L
      4  2d91					      ENDIF
      0  2d91					      DEFL	_030_R, "-7#2-|2#-$2-.#2-|#-$-$#.#2-|#-#.$2.#2-|#-#3.$2#-|#2-$#*2-2#|3#2-*2$-#|2-#@5-#|2-8#"
      0  2d91					      START_LEVEL	_030_R
      1  2d91				   LEVEL_START SET	*
      2  2d91		       00 05	   BANK_LEVEL__030_R =	_CURRENT_BANK
      3  2d91				   LEVEL__030_R SUBROUTINE
      4  2d91				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d91
      2  2d91		       2d 37 23 32*	      .byte.b	"-7#2-|2#-$2-.#2-|#-$-$#.#2-|#-#.$2.#2-|#-#3.$2#-|#2-$#*2-2#|3#2-*2$-#|2-#@5-#|2-8#",0
      0  2de4					      END_LEVEL	_030_R
      1  2de4		       00 53	   LEVEL_SIZE__030_R =	* - LEVEL_START
      2  2de4				  -	      IF	LEVEL_SIZE__030_R > MAX_LEVEL_SIZE
      3  2de4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__030_R
      4  2de4					      ENDIF
      0  2de4					      DEFL	_031_L, "-7#2-|-#3-@-3#|-#-2$*2$-#|3#2-*.2-#|#2.2*.*2-#|#$#2-.2-2#|#3-5#-|5#5-"
      0  2de4					      START_LEVEL	_031_L
      1  2de4				   LEVEL_START SET	*
      2  2de4		       00 05	   BANK_LEVEL__031_L =	_CURRENT_BANK
      3  2de4				   LEVEL__031_L SUBROUTINE
      4  2de4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2de4
      2  2de4		       2d 37 23 32*	      .byte.b	"-7#2-|-#3-@-3#|-#-2$*2$-#|3#2-*.2-#|#2.2*.*2-#|#$#2-.2-2#|#3-5#-|5#5-",0
      0  2e2a					      END_LEVEL	_031_L
      1  2e2a		       00 46	   LEVEL_SIZE__031_L =	* - LEVEL_START
      2  2e2a				  -	      IF	LEVEL_SIZE__031_L > MAX_LEVEL_SIZE
      3  2e2a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__031_L
      4  2e2a					      ENDIF
      0  2e2a					      DEFL	_031_R, "6#-|#2-#+#-|#2-$.2#|#2-2*.#|#-$-.$#|#-$-*.#|#-2$.-#|#-$-.-#|7#"
      0  2e2a					      START_LEVEL	_031_R
      1  2e2a				   LEVEL_START SET	*
      2  2e2a		       00 05	   BANK_LEVEL__031_R =	_CURRENT_BANK
      3  2e2a				   LEVEL__031_R SUBROUTINE
      4  2e2a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e2a
      2  2e2a		       36 23 2d 7c*	      .byte.b	"6#-|#2-#+#-|#2-$.2#|#2-2*.#|#-$-.$#|#-$-*.#|#-2$.-#|#-$-.-#|7#",0
      0  2e69					      END_LEVEL	_031_R
      1  2e69		       00 3f	   LEVEL_SIZE__031_R =	* - LEVEL_START
      2  2e69				  -	      IF	LEVEL_SIZE__031_R > MAX_LEVEL_SIZE
      3  2e69				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__031_R
      4  2e69					      ENDIF
      0  2e69					      DEFL	_032_L, "-4#2-|-#2-3#|2#2-2.#|#@2$*.#|#-$2-.#|#-$-#*#|3#3-#|2-5#"
      0  2e69					      START_LEVEL	_032_L
      1  2e69				   LEVEL_START SET	*
      2  2e69		       00 05	   BANK_LEVEL__032_L =	_CURRENT_BANK
      3  2e69				   LEVEL__032_L SUBROUTINE
      4  2e69				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e69
      2  2e69		       2d 34 23 32*	      .byte.b	"-4#2-|-#2-3#|2#2-2.#|#@2$*.#|#-$2-.#|#-$-#*#|3#3-#|2-5#",0
      0  2ea1					      END_LEVEL	_032_L
      1  2ea1		       00 38	   LEVEL_SIZE__032_L =	* - LEVEL_START
      2  2ea1				  -	      IF	LEVEL_SIZE__032_L > MAX_LEVEL_SIZE
      3  2ea1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__032_L
      4  2ea1					      ENDIF
      0  2ea1					      DEFL	_032_R, "9#-|#7-2#|#-$3#-$@#|#2-2.#.$-#|#-.*.2*$-#|#-$.*2-$-#|#2-#.$-3#|8#2-"
      0  2ea1					      START_LEVEL	_032_R
      1  2ea1				   LEVEL_START SET	*
      2  2ea1		       00 05	   BANK_LEVEL__032_R =	_CURRENT_BANK
      3  2ea1				   LEVEL__032_R SUBROUTINE
      4  2ea1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ea1
      2  2ea1		       39 23 2d 7c*	      .byte.b	"9#-|#7-2#|#-$3#-$@#|#2-2.#.$-#|#-.*.2*$-#|#-$.*2-$-#|#2-#.$-3#|8#2-",0
      0  2ee5					      END_LEVEL	_032_R
      1  2ee5		       00 44	   LEVEL_SIZE__032_R =	* - LEVEL_START
      2  2ee5				  -	      IF	LEVEL_SIZE__032_R > MAX_LEVEL_SIZE
      3  2ee5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__032_R
      4  2ee5					      ENDIF
      0  2ee5					      DEFL	_033_L, "2-7#-|-2#2-#2-2#|-#2-.*-$-#|-#-$.$-$@#|2#$-2*-3#|#2-$*.*.#-|#3-2.3#-|7#3-"
      0  2ee5					      START_LEVEL	_033_L
      1  2ee5				   LEVEL_START SET	*
      2  2ee5		       00 05	   BANK_LEVEL__033_L =	_CURRENT_BANK
      3  2ee5				   LEVEL__033_L SUBROUTINE
      4  2ee5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2ee5
      2  2ee5		       32 2d 37 23*	      .byte.b	"2-7#-|-2#2-#2-2#|-#2-.*-$-#|-#-$.$-$@#|2#$-2*-3#|#2-$*.*.#-|#3-2.3#-|7#3-",0
      0  2f2f					      END_LEVEL	_033_L
      1  2f2f		       00 4a	   LEVEL_SIZE__033_L =	* - LEVEL_START
      2  2f2f				  -	      IF	LEVEL_SIZE__033_L > MAX_LEVEL_SIZE
      3  2f2f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__033_L
      4  2f2f					      ENDIF
      0  2f2f					      DEFL	_033_R, "-7#2-|2#2-#@-2#-|#-$-#3-2#|#-$2-$*$-#|#2-*.*.2-#|2#.*2.-$-#|-9#"
      0  2f2f					      START_LEVEL	_033_R
      1  2f2f				   LEVEL_START SET	*
      2  2f2f		       00 05	   BANK_LEVEL__033_R =	_CURRENT_BANK
      3  2f2f				   LEVEL__033_R SUBROUTINE
      4  2f2f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2f2f
      2  2f2f		       2d 37 23 32*	      .byte.b	"-7#2-|2#2-#@-2#-|#-$-#3-2#|#-$2-$*$-#|#2-*.*.2-#|2#.*2.-$-#|-9#",0
      0  2f6f					      END_LEVEL	_033_R
      1  2f6f		       00 40	   LEVEL_SIZE__033_R =	* - LEVEL_START
      2  2f6f				  -	      IF	LEVEL_SIZE__033_R > MAX_LEVEL_SIZE
      3  2f6f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__033_R
      4  2f6f					      ENDIF
      0  2f6f					      DEFL	_034_L, "5-4#-|-5#2-#-|-#-$@$2-#-|2#-#*$.*2#|#3-.2*2.#|#2-$2-4#|4#2-#3-|3-#2-#3-|3-4#3-"
      0  2f6f					      START_LEVEL	_034_L
      1  2f6f				   LEVEL_START SET	*
      2  2f6f		       00 05	   BANK_LEVEL__034_L =	_CURRENT_BANK
      3  2f6f				   LEVEL__034_L SUBROUTINE
      4  2f6f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2f6f
      2  2f6f		       35 2d 34 23*	      .byte.b	"5-4#-|-5#2-#-|-#-$@$2-#-|2#-#*$.*2#|#3-.2*2.#|#2-$2-4#|4#2-#3-|3-#2-#3-|3-4#3-",0
      0  2fbe					      END_LEVEL	_034_L
      1  2fbe		       00 4f	   LEVEL_SIZE__034_L =	* - LEVEL_START
      2  2fbe				  -	      IF	LEVEL_SIZE__034_L > MAX_LEVEL_SIZE
      3  2fbe				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__034_L
      4  2fbe					      ENDIF
     65  2fbe
      0  2fbe					      CHECK_BANK_SIZE	"LEVELS2"
      1  2fbe		       07 be	   .TEMP      =	* - BANK_START
 LEVELS2 (2K) SIZE =  $7be , FREE= $42
      2  2fbe					      ECHO	"LEVELS2", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2fbe				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2fbe				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2fbe				  -	      ERR
      6  2fbe					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS3.asm LEVEL 2 PASS 4
      0  2fbe					      include	"BANK_LEVELS3.asm"
      1  2fbe							;    Sokoboo - a Sokoban implementation
      2  2fbe							;    using a generic tile-based display engine for the Atari 2600
      3  2fbe							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  2fbe							;
      5  2fbe							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  2fbe							;
      7  2fbe							;    Code related to the generic tile-based display engine was developed by
      8  2fbe							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  2fbe							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  2fbe							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  2fbe							;
     12  2fbe							;    Code related to music and sound effects uses the TIATracker music player
     13  2fbe							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  2fbe							;    directory for Apache licensing details.
     15  2fbe							;
     16  2fbe							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  2fbe							;    See the copyright notices in the License directory for a list of level
     18  2fbe							;    contributors.
     19  2fbe							;
     20  2fbe							;    Except where otherwise indicated, this software is released under the
     21  2fbe							;    following licensing arrangement...
     22  2fbe							;
     23  2fbe							;    This program is free software: you can redistribute it and/or modify
     24  2fbe							;    it under the terms of the GNU General Public License as published by
     25  2fbe							;    the Free Software Foundation, either version 3 of the License, or
     26  2fbe							;    (at your option) any later version.
     27  2fbe							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  2fbe
     29  2fbe							;    This program is distributed in the hope that it will be useful,
     30  2fbe							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  2fbe							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  2fbe							;    GNU General Public License for more details.
     33  2fbe
      0  2fbe					      NEWBANK	LEVELS3
      1  37c7 ????				      SEG	LEVELS3
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   LEVELS3    SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	LEVELS3
     35  3000
      0  3000					      DEFL	_034_R, "-6#3-|-#4-#3-|2#-$.-3#-|#-2$*.$@#-|#-3.#2$2#|4#.4-#|3-3#-#-#|5-#3-#|5-5#"
      0  3000					      START_LEVEL	_034_R
      1  3000				   LEVEL_START SET	*
      2  3000		       00 06	   BANK_LEVEL__034_R =	_CURRENT_BANK
      3  3000				   LEVEL__034_R SUBROUTINE
      4  3000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3000
      2  3000		       2d 36 23 33*	      .byte.b	"-6#3-|-#4-#3-|2#-$.-3#-|#-2$*.$@#-|#-3.#2$2#|4#.4-#|3-3#-#-#|5-#3-#|5-5#",0
      0  3049					      END_LEVEL	_034_R
      1  3049		       00 49	   LEVEL_SIZE__034_R =	* - LEVEL_START
      2  3049				  -	      IF	LEVEL_SIZE__034_R > MAX_LEVEL_SIZE
      3  3049				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__034_R
      4  3049					      ENDIF
      0  3049					      DEFL	_035_L, "5-3#2-|6#.2#-|#@2-2#*.#-|#-3$2.-#-|2#2-$*.$2#|-#-$2-.2-#|-5#3-#|5-5#"
      0  3049					      START_LEVEL	_035_L
      1  3049				   LEVEL_START SET	*
      2  3049		       00 06	   BANK_LEVEL__035_L =	_CURRENT_BANK
      3  3049				   LEVEL__035_L SUBROUTINE
      4  3049				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3049
      2  3049		       35 2d 33 23*	      .byte.b	"5-3#2-|6#.2#-|#@2-2#*.#-|#-3$2.-#-|2#2-$*.$2#|-#-$2-.2-#|-5#3-#|5-5#",0
      0  308e					      END_LEVEL	_035_L
      1  308e		       00 45	   LEVEL_SIZE__035_L =	* - LEVEL_START
      2  308e				  -	      IF	LEVEL_SIZE__035_L > MAX_LEVEL_SIZE
      3  308e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__035_L
      4  308e					      ENDIF
      0  308e					      DEFL	_035_R, "-11#|-#4-@4-#|-#-2$3*$#-#|3#-*.$.-$-#|#3-.*.-4#|#3-2#.2#3-|8#4-"
      0  308e					      START_LEVEL	_035_R
      1  308e				   LEVEL_START SET	*
      2  308e		       00 06	   BANK_LEVEL__035_R =	_CURRENT_BANK
      3  308e				   LEVEL__035_R SUBROUTINE
      4  308e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  308e
      2  308e		       2d 31 31 23*	      .byte.b	"-11#|-#4-@4-#|-#-2$3*$#-#|3#-*.$.-$-#|#3-.*.-4#|#3-2#.2#3-|8#4-",0
      0  30ce					      END_LEVEL	_035_R
      1  30ce		       00 40	   LEVEL_SIZE__035_R =	* - LEVEL_START
      2  30ce				  -	      IF	LEVEL_SIZE__035_R > MAX_LEVEL_SIZE
      3  30ce				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__035_R
      4  30ce					      ENDIF
      0  30ce					      DEFL	_036_L, "5#2-|#3-3#|#*#-$@#|#.2-$-#|#.*2$-#|#2.#2-#|4#2-#|3-4#"
      0  30ce					      START_LEVEL	_036_L
      1  30ce				   LEVEL_START SET	*
      2  30ce		       00 06	   BANK_LEVEL__036_L =	_CURRENT_BANK
      3  30ce				   LEVEL__036_L SUBROUTINE
      4  30ce				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  30ce
      2  30ce		       35 23 32 2d*	      .byte.b	"5#2-|#3-3#|#*#-$@#|#.2-$-#|#.*2$-#|#2.#2-#|4#2-#|3-4#",0
      0  3104					      END_LEVEL	_036_L
      1  3104		       00 36	   LEVEL_SIZE__036_L =	* - LEVEL_START
      2  3104				  -	      IF	LEVEL_SIZE__036_L > MAX_LEVEL_SIZE
      3  3104				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__036_L
      4  3104					      ENDIF
      0  3104					      DEFL	_036_R, "2-5#2-|-2#.2-2#-|-#.*-$-2#|2#2.$-$-#|#.2*.-$@#|#2-$2-$2#|3#4-#-|2-6#-"
      0  3104					      START_LEVEL	_036_R
      1  3104				   LEVEL_START SET	*
      2  3104		       00 06	   BANK_LEVEL__036_R =	_CURRENT_BANK
      3  3104				   LEVEL__036_R SUBROUTINE
      4  3104				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3104
      2  3104		       32 2d 35 23*	      .byte.b	"2-5#2-|-2#.2-2#-|-#.*-$-2#|2#2.$-$-#|#.2*.-$@#|#2-$2-$2#|3#4-#-|2-6#-",0
      0  314a					      END_LEVEL	_036_R
      1  314a		       00 46	   LEVEL_SIZE__036_R =	* - LEVEL_START
      2  314a				  -	      IF	LEVEL_SIZE__036_R > MAX_LEVEL_SIZE
      3  314a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__036_R
      4  314a					      ENDIF
      0  314a					      DEFL	_037_L, "5-6#|6#4-#|#2-#@2.2$-#|#2-$.3*.-#|#3-$.$-$-#|2#2-#.3-2#|-9#-"
      0  314a					      START_LEVEL	_037_L
      1  314a				   LEVEL_START SET	*
      2  314a		       00 06	   BANK_LEVEL__037_L =	_CURRENT_BANK
      3  314a				   LEVEL__037_L SUBROUTINE
      4  314a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  314a
      2  314a		       35 2d 36 23*	      .byte.b	"5-6#|6#4-#|#2-#@2.2$-#|#2-$.3*.-#|#3-$.$-$-#|2#2-#.3-2#|-9#-",0
      0  3187					      END_LEVEL	_037_L
      1  3187		       00 3d	   LEVEL_SIZE__037_L =	* - LEVEL_START
      2  3187				  -	      IF	LEVEL_SIZE__037_L > MAX_LEVEL_SIZE
      3  3187				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__037_L
      4  3187					      ENDIF
      0  3187					      DEFL	_037_R, "9#2-|#7-3#|#-$2-.2*.-#|2#-*.*$3-#|-2#-2*.#2-#|2-2#@$-$-2#|3-3#3-#-|5-5#-"
      0  3187					      START_LEVEL	_037_R
      1  3187				   LEVEL_START SET	*
      2  3187		       00 06	   BANK_LEVEL__037_R =	_CURRENT_BANK
      3  3187				   LEVEL__037_R SUBROUTINE
      4  3187				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3187
      2  3187		       39 23 32 2d*	      .byte.b	"9#2-|#7-3#|#-$2-.2*.-#|2#-*.*$3-#|-2#-2*.#2-#|2-2#@$-$-2#|3-3#3-#-|5-5#-",0
      0  31d0					      END_LEVEL	_037_R
      1  31d0		       00 49	   LEVEL_SIZE__037_R =	* - LEVEL_START
      2  31d0				  -	      IF	LEVEL_SIZE__037_R > MAX_LEVEL_SIZE
      3  31d0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__037_R
      4  31d0					      ENDIF
      0  31d0					      DEFL	_038_L, "6-4#2-|4-3#@-3#|3-2#2.*$2-#|4#.*.*3-#|#2-2$3-$2-#|#5-6#|3#2-2#5-|2-4#6-"
      0  31d0					      START_LEVEL	_038_L
      1  31d0				   LEVEL_START SET	*
      2  31d0		       00 06	   BANK_LEVEL__038_L =	_CURRENT_BANK
      3  31d0				   LEVEL__038_L SUBROUTINE
      4  31d0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  31d0
      2  31d0		       36 2d 34 23*	      .byte.b	"6-4#2-|4-3#@-3#|3-2#2.*$2-#|4#.*.*3-#|#2-2$3-$2-#|#5-6#|3#2-2#5-|2-4#6-",0
      0  3218					      END_LEVEL	_038_L
      1  3218		       00 48	   LEVEL_SIZE__038_L =	* - LEVEL_START
      2  3218				  -	      IF	LEVEL_SIZE__038_L > MAX_LEVEL_SIZE
      3  3218				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__038_L
      4  3218					      ENDIF
      0  3218					      DEFL	_038_R, "6-6#|4-3#.#-@#|2-3#2.*#$-#|3#-.*2.-$-#|#2-2$2-#-3#|#-$2-#-$-#2-|2#5-3#2-|-7#4-"
      0  3218					      START_LEVEL	_038_R
      1  3218				   LEVEL_START SET	*
      2  3218		       00 06	   BANK_LEVEL__038_R =	_CURRENT_BANK
      3  3218				   LEVEL__038_R SUBROUTINE
      4  3218				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3218
      2  3218		       36 2d 36 23*	      .byte.b	"6-6#|4-3#.#-@#|2-3#2.*#$-#|3#-.*2.-$-#|#2-2$2-#-3#|#-$2-#-$-#2-|2#5-3#2-|-7#4-",0
      0  3267					      END_LEVEL	_038_R
      1  3267		       00 4f	   LEVEL_SIZE__038_R =	* - LEVEL_START
      2  3267				  -	      IF	LEVEL_SIZE__038_R > MAX_LEVEL_SIZE
      3  3267				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__038_R
      4  3267					      ENDIF
      0  3267					      DEFL	_039_L, "-7#2-|-#5-#2-|2#-#-$-#2-|#.2*.-3#-|2#@3*2-2#|-2#-2.$2-#|2-2#$#-$-#|3-#5-#|3-7#"
      0  3267					      START_LEVEL	_039_L
      1  3267				   LEVEL_START SET	*
      2  3267		       00 06	   BANK_LEVEL__039_L =	_CURRENT_BANK
      3  3267				   LEVEL__039_L SUBROUTINE
      4  3267				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3267
      2  3267		       2d 37 23 32*	      .byte.b	"-7#2-|-#5-#2-|2#-#-$-#2-|#.2*.-3#-|2#@3*2-2#|-2#-2.$2-#|2-2#$#-$-#|3-#5-#|3-7#",0
      0  32b6					      END_LEVEL	_039_L
      1  32b6		       00 4f	   LEVEL_SIZE__039_L =	* - LEVEL_START
      2  32b6				  -	      IF	LEVEL_SIZE__039_L > MAX_LEVEL_SIZE
      3  32b6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__039_L
      4  32b6					      ENDIF
      0  32b6					      DEFL	_039_R, "4-4#4-|3-2#2-3#2-|2-2#-$.2-#2-|3#-.2*-$3#|#-$-4.3-#|#@$3#-#-#-#|2#4-$2-$-#|-5#3-3#|5-5#2-"
      0  32b6					      START_LEVEL	_039_R
      1  32b6				   LEVEL_START SET	*
      2  32b6		       00 06	   BANK_LEVEL__039_R =	_CURRENT_BANK
      3  32b6				   LEVEL__039_R SUBROUTINE
      4  32b6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  32b6
      2  32b6		       34 2d 34 23*	      .byte.b	"4-4#4-|3-2#2-3#2-|2-2#-$.2-#2-|3#-.2*-$3#|#-$-4.3-#|#@$3#-#-#-#|2#4-$2-$-#|-5#3-3#|5-5#2-",0
      0  3310					      END_LEVEL	_039_R
      1  3310		       00 5a	   LEVEL_SIZE__039_R =	* - LEVEL_START
      2  3310					      IF	LEVEL_SIZE__039_R > MAX_LEVEL_SIZE
      3  3310				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__039_R
      4  3310					      ENDIF
      0  3310					      DEFL	_040_L, "6#3-|#3-@#3-|#2-$.3#-|3#$*$.2#|3#-.2*.#|#2-$-.3#|#2-$3-#-|4#3-#-|3-5#-"
      0  3310					      START_LEVEL	_040_L
      1  3310				   LEVEL_START SET	*
      2  3310		       00 06	   BANK_LEVEL__040_L =	_CURRENT_BANK
      3  3310				   LEVEL__040_L SUBROUTINE
      4  3310				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3310
      2  3310		       36 23 33 2d*	      .byte.b	"6#3-|#3-@#3-|#2-$.3#-|3#$*$.2#|3#-.2*.#|#2-$-.3#|#2-$3-#-|4#3-#-|3-5#-",0
      0  3357					      END_LEVEL	_040_L
      1  3357		       00 47	   LEVEL_SIZE__040_L =	* - LEVEL_START
      2  3357				  -	      IF	LEVEL_SIZE__040_L > MAX_LEVEL_SIZE
      3  3357				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__040_L
      4  3357					      ENDIF
      0  3357					      DEFL	_040_R, "5-4#-|-5#2-2#|2#.-$2-$-#|#-2.*.$#@#|#-*-.2-$-#|2#-$*-4#|-#3-2#3-|-5#4-"
      0  3357					      START_LEVEL	_040_R
      1  3357				   LEVEL_START SET	*
      2  3357		       00 06	   BANK_LEVEL__040_R =	_CURRENT_BANK
      3  3357				   LEVEL__040_R SUBROUTINE
      4  3357				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3357
      2  3357		       35 2d 34 23*	      .byte.b	"5-4#-|-5#2-2#|2#.-$2-$-#|#-2.*.$#@#|#-*-.2-$-#|2#-$*-4#|-#3-2#3-|-5#4-",0
      0  339e					      END_LEVEL	_040_R
      1  339e		       00 47	   LEVEL_SIZE__040_R =	* - LEVEL_START
      2  339e				  -	      IF	LEVEL_SIZE__040_R > MAX_LEVEL_SIZE
      3  339e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__040_R
      4  339e					      ENDIF
     49  339e
      0  339e					      DEFL	_041_L, "4-3#5-|4-#.4#2-|5#*.$-#2-|#4-3.-3#|#-3$-*.$2-#|2#-@2#.$-$-#|-5#4-2#|5-6#-"
      0  339e					      START_LEVEL	_041_L
      1  339e				   LEVEL_START SET	*
      2  339e		       00 06	   BANK_LEVEL__041_L =	_CURRENT_BANK
      3  339e				   LEVEL__041_L SUBROUTINE
      4  339e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  339e
      2  339e		       34 2d 33 23*	      .byte.b	"4-3#5-|4-#.4#2-|5#*.$-#2-|#4-3.-3#|#-3$-*.$2-#|2#-@2#.$-$-#|-5#4-2#|5-6#-",0
      0  33e8					      END_LEVEL	_041_L
      1  33e8		       00 4a	   LEVEL_SIZE__041_L =	* - LEVEL_START
      2  33e8				  -	      IF	LEVEL_SIZE__041_L > MAX_LEVEL_SIZE
      3  33e8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__041_L
      4  33e8					      ENDIF
      0  33e8					      DEFL	_041_R, "-4#3-|2#2-3#-|#-@2$-#-|#-$-#.#-|2#$-2.2#|#2-$*2.#|#2-$-*2#|#3-#.#-|7#-"
      0  33e8					      START_LEVEL	_041_R
      1  33e8				   LEVEL_START SET	*
      2  33e8		       00 06	   BANK_LEVEL__041_R =	_CURRENT_BANK
      3  33e8				   LEVEL__041_R SUBROUTINE
      4  33e8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  33e8
      2  33e8		       2d 34 23 33*	      .byte.b	"-4#3-|2#2-3#-|#-@2$-#-|#-$-#.#-|2#$-2.2#|#2-$*2.#|#2-$-*2#|#3-#.#-|7#-",0
      0  342f					      END_LEVEL	_041_R
      1  342f		       00 47	   LEVEL_SIZE__041_R =	* - LEVEL_START
      2  342f				  -	      IF	LEVEL_SIZE__041_R > MAX_LEVEL_SIZE
      3  342f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__041_R
      4  342f					      ENDIF
      0  342f					      DEFL	_042_L, "8#4-|#6-#4-|#-#-$*-#4-|#-#-#.3#3-|#3-#2.-3#-|#3-2*4-2#|5#.-3$-#|4-4#2-@#|7-5#"
      0  342f					      START_LEVEL	_042_L
      1  342f				   LEVEL_START SET	*
      2  342f		       00 06	   BANK_LEVEL__042_L =	_CURRENT_BANK
      3  342f				   LEVEL__042_L SUBROUTINE
      4  342f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  342f
      2  342f		       38 23 34 2d*	      .byte.b	"8#4-|#6-#4-|#-#-$*-#4-|#-#-#.3#3-|#3-#2.-3#-|#3-2*4-2#|5#.-3$-#|4-4#2-@#|7-5#",0
      0  347d					      END_LEVEL	_042_L
      1  347d		       00 4e	   LEVEL_SIZE__042_L =	* - LEVEL_START
      2  347d				  -	      IF	LEVEL_SIZE__042_L > MAX_LEVEL_SIZE
      3  347d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__042_L
      4  347d					      ENDIF
      0  347d					      DEFL	_042_R, "3-5#4-|2-2#3-#4-|2-#-$-$#4-|3#-*.-2#3-|#@$-#.$-2#2-|#-$2-.*.-3#|3#2.*-$3-#|2-6#3-#|7-5#"
      0  347d					      START_LEVEL	_042_R
      1  347d				   LEVEL_START SET	*
      2  347d		       00 06	   BANK_LEVEL__042_R =	_CURRENT_BANK
      3  347d				   LEVEL__042_R SUBROUTINE
      4  347d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  347d
      2  347d		       33 2d 35 23*	      .byte.b	"3-5#4-|2-2#3-#4-|2-#-$-$#4-|3#-*.-2#3-|#@$-#.$-2#2-|#-$2-.*.-3#|3#2.*-$3-#|2-6#3-#|7-5#",0
      0  34d5					      END_LEVEL	_042_R
      1  34d5		       00 58	   LEVEL_SIZE__042_R =	* - LEVEL_START
      2  34d5				  -	      IF	LEVEL_SIZE__042_R > MAX_LEVEL_SIZE
      3  34d5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__042_R
      4  34d5					      ENDIF
      0  34d5					      DEFL	_043_L, "-8#4-|-#@$.-.-5#|-#2$*.2*.3-#|2#2-$-.2-#$-#|#-$-2#.#3-2#|#3-8#-|#2-2#8-|4#9-"
      0  34d5					      START_LEVEL	_043_L
      1  34d5				   LEVEL_START SET	*
      2  34d5		       00 06	   BANK_LEVEL__043_L =	_CURRENT_BANK
      3  34d5				   LEVEL__043_L SUBROUTINE
      4  34d5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  34d5
      2  34d5		       2d 38 23 34*	      .byte.b	"-8#4-|-#@$.-.-5#|-#2$*.2*.3-#|2#2-$-.2-#$-#|#-$-2#.#3-2#|#3-8#-|#2-2#8-|4#9-",0
      0  3522					      END_LEVEL	_043_L
      1  3522		       00 4d	   LEVEL_SIZE__043_L =	* - LEVEL_START
      2  3522				  -	      IF	LEVEL_SIZE__043_L > MAX_LEVEL_SIZE
      3  3522				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__043_L
      4  3522					      ENDIF
      0  3522					      DEFL	_043_R, "2-6#-|-2#4-#-|2#@$-#-#-|#-$#$2.#-|#*.*2.*2#|#-$2-$2.#|#-$-$2-2#|#4-3#-|6#3-"
      0  3522					      START_LEVEL	_043_R
      1  3522				   LEVEL_START SET	*
      2  3522		       00 06	   BANK_LEVEL__043_R =	_CURRENT_BANK
      3  3522				   LEVEL__043_R SUBROUTINE
      4  3522				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3522
      2  3522		       32 2d 36 23*	      .byte.b	"2-6#-|-2#4-#-|2#@$-#-#-|#-$#$2.#-|#*.*2.*2#|#-$2-$2.#|#-$-$2-2#|#4-3#-|6#3-",0
      0  356e					      END_LEVEL	_043_R
      1  356e		       00 4c	   LEVEL_SIZE__043_R =	* - LEVEL_START
      2  356e				  -	      IF	LEVEL_SIZE__043_R > MAX_LEVEL_SIZE
      3  356e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__043_R
      4  356e					      ENDIF
      0  356e					      DEFL	_044_L, "7#-|#@4-#-|#$-.2$#-|#3.*-2#|#*$2*2-#|#3-#2-#|#3-#2-#|8#"
      0  356e					      START_LEVEL	_044_L
      1  356e				   LEVEL_START SET	*
      2  356e		       00 06	   BANK_LEVEL__044_L =	_CURRENT_BANK
      3  356e				   LEVEL__044_L SUBROUTINE
      4  356e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  356e
      2  356e		       37 23 2d 7c*	      .byte.b	"7#-|#@4-#-|#$-.2$#-|#3.*-2#|#*$2*2-#|#3-#2-#|#3-#2-#|8#",0
      0  35a6					      END_LEVEL	_044_L
      1  35a6		       00 38	   LEVEL_SIZE__044_L =	* - LEVEL_START
      2  35a6				  -	      IF	LEVEL_SIZE__044_L > MAX_LEVEL_SIZE
      3  35a6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__044_L
      4  35a6					      ENDIF
      0  35a6					      DEFL	_044_R, "4#-4#-|#2-3#2-#-|#@$2-#-$2#|#$*$5-#|#-*2.$2#-#|#3.#4-#|2#-.-$4#|-3#2-#3-|3-4#3-"
      0  35a6					      START_LEVEL	_044_R
      1  35a6				   LEVEL_START SET	*
      2  35a6		       00 06	   BANK_LEVEL__044_R =	_CURRENT_BANK
      3  35a6				   LEVEL__044_R SUBROUTINE
      4  35a6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35a6
      2  35a6		       34 23 2d 34*	      .byte.b	"4#-4#-|#2-3#2-#-|#@$2-#-$2#|#$*$5-#|#-*2.$2#-#|#3.#4-#|2#-.-$4#|-3#2-#3-|3-4#3-",0
      0  35f6					      END_LEVEL	_044_R
      1  35f6		       00 50	   LEVEL_SIZE__044_R =	* - LEVEL_START
      2  35f6				  -	      IF	LEVEL_SIZE__044_R > MAX_LEVEL_SIZE
      3  35f6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__044_R
      4  35f6					      ENDIF
      0  35f6					      DEFL	_045_L, "3-4#2-|3-#2.3#|4#$.$-#|#@-#-.*-#|#-$2-2*.#|2#-$-*2-#|-2#-$3-#|2-2#2-3#|3-4#2-"
      0  35f6					      START_LEVEL	_045_L
      1  35f6				   LEVEL_START SET	*
      2  35f6		       00 06	   BANK_LEVEL__045_L =	_CURRENT_BANK
      3  35f6				   LEVEL__045_L SUBROUTINE
      4  35f6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35f6
      2  35f6		       33 2d 34 23*	      .byte.b	"3-4#2-|3-#2.3#|4#$.$-#|#@-#-.*-#|#-$2-2*.#|2#-$-*2-#|-2#-$3-#|2-2#2-3#|3-4#2-",0
      0  3644					      END_LEVEL	_045_L
      1  3644		       00 4e	   LEVEL_SIZE__045_L =	* - LEVEL_START
      2  3644				  -	      IF	LEVEL_SIZE__045_L > MAX_LEVEL_SIZE
      3  3644				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__045_L
      4  3644					      ENDIF
      0  3644					      DEFL	_045_R, "3-6#2-|4#4-#2-|#-$-$2#-3#|#-2$-$-$2-#|#-5.#$-#|#-.*#$2.2-#|2#.-$@5#|-6#4-"
      0  3644					      START_LEVEL	_045_R
      1  3644				   LEVEL_START SET	*
      2  3644		       00 06	   BANK_LEVEL__045_R =	_CURRENT_BANK
      3  3644				   LEVEL__045_R SUBROUTINE
      4  3644				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3644
      2  3644		       33 2d 36 23*	      .byte.b	"3-6#2-|4#4-#2-|#-$-$2#-3#|#-2$-$-$2-#|#-5.#$-#|#-.*#$2.2-#|2#.-$@5#|-6#4-",0
      0  368e					      END_LEVEL	_045_R
      1  368e		       00 4a	   LEVEL_SIZE__045_R =	* - LEVEL_START
      2  368e				  -	      IF	LEVEL_SIZE__045_R > MAX_LEVEL_SIZE
      3  368e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__045_R
      4  368e					      ENDIF
      0  368e					      DEFL	_046_L, "10#-|#@3-#3-2#|#-#*$2-2$-#|#-*.$-$3-#|3#.*$-#2-#|2-#.*.-4#|2-#2.-2#3-|2-5#4-"
      0  368e					      START_LEVEL	_046_L
      1  368e				   LEVEL_START SET	*
      2  368e		       00 06	   BANK_LEVEL__046_L =	_CURRENT_BANK
      3  368e				   LEVEL__046_L SUBROUTINE
      4  368e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  368e
      2  368e		       31 30 23 2d*	      .byte.b	"10#-|#@3-#3-2#|#-#*$2-2$-#|#-*.$-$3-#|3#.*$-#2-#|2-#.*.-4#|2-#2.-2#3-|2-5#4-",0
      0  36db					      END_LEVEL	_046_L
      1  36db		       00 4d	   LEVEL_SIZE__046_L =	* - LEVEL_START
      2  36db				  -	      IF	LEVEL_SIZE__046_L > MAX_LEVEL_SIZE
      3  36db				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__046_L
      4  36db					      ENDIF
      0  36db					      DEFL	_046_R, "8#3-|#3-4#3-|#-$2-$@3#-|#2-5$-#-|3#3.*2.2#|2-2#2-$3.#|3-#2-5#|3-4#4-"
      0  36db					      START_LEVEL	_046_R
      1  36db				   LEVEL_START SET	*
      2  36db		       00 06	   BANK_LEVEL__046_R =	_CURRENT_BANK
      3  36db				   LEVEL__046_R SUBROUTINE
      4  36db				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  36db
      2  36db		       38 23 33 2d*	      .byte.b	"8#3-|#3-4#3-|#-$2-$@3#-|#2-5$-#-|3#3.*2.2#|2-2#2-$3.#|3-#2-5#|3-4#4-",0
      0  3720					      END_LEVEL	_046_R
      1  3720		       00 45	   LEVEL_SIZE__046_R =	* - LEVEL_START
      2  3720				  -	      IF	LEVEL_SIZE__046_R > MAX_LEVEL_SIZE
      3  3720				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__046_R
      4  3720					      ENDIF
      0  3720					      DEFL	_047_L, "5-3#5-|3-3#.#5-|2-2#2-.#5-|2-#-$#.6#|3#3-.2#3-#|#-$@2*.$-$#-#|#4-2#-$3-#|8#3-2#|7-5#-"
      0  3720					      START_LEVEL	_047_L
      1  3720				   LEVEL_START SET	*
      2  3720		       00 06	   BANK_LEVEL__047_L =	_CURRENT_BANK
      3  3720				   LEVEL__047_L SUBROUTINE
      4  3720				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3720
      2  3720		       35 2d 33 23*	      .byte.b	"5-3#5-|3-3#.#5-|2-2#2-.#5-|2-#-$#.6#|3#3-.2#3-#|#-$@2*.$-$#-#|#4-2#-$3-#|8#3-2#|7-5#-",0
      0  3776					      END_LEVEL	_047_L
      1  3776		       00 56	   LEVEL_SIZE__047_L =	* - LEVEL_START
      2  3776				  -	      IF	LEVEL_SIZE__047_L > MAX_LEVEL_SIZE
      3  3776				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__047_L
      4  3776					      ENDIF
      0  3776					      DEFL	_047_R, "4-6#|3-2#3-@#|-3#-3$-#|-#.2-#-$-#|2#.*2-$2-#|#2.-2$#-2#|2#2.#-3#-|-#.3-#3-|-6#3-"
      0  3776					      START_LEVEL	_047_R
      1  3776				   LEVEL_START SET	*
      2  3776		       00 06	   BANK_LEVEL__047_R =	_CURRENT_BANK
      3  3776				   LEVEL__047_R SUBROUTINE
      4  3776				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3776
      2  3776		       34 2d 36 23*	      .byte.b	"4-6#|3-2#3-@#|-3#-3$-#|-#.2-#-$-#|2#.*2-$2-#|#2.-2$#-2#|2#2.#-3#-|-#.3-#3-|-6#3-",0
      0  37c7					      END_LEVEL	_047_R
      1  37c7		       00 51	   LEVEL_SIZE__047_R =	* - LEVEL_START
      2  37c7				  -	      IF	LEVEL_SIZE__047_R > MAX_LEVEL_SIZE
      3  37c7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__047_R
      4  37c7					      ENDIF
     64  37c7
     65  37c7
     66  37c7
      0  37c7					      CHECK_BANK_SIZE	"LEVELS3 -- full 2K"
      1  37c7		       07 c7	   .TEMP      =	* - BANK_START
 LEVELS3 -- full 2K (2K) SIZE =  $7c7 , FREE= $39
      2  37c7					      ECHO	"LEVELS3 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  37c7				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  37c7				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  37c7				  -	      ERR
      6  37c7					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS4.asm LEVEL 2 PASS 4
      0  37c7					      include	"BANK_LEVELS4.asm"
      1  37c7							;    Sokoboo - a Sokoban implementation
      2  37c7							;    using a generic tile-based display engine for the Atari 2600
      3  37c7							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  37c7							;
      5  37c7							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  37c7							;
      7  37c7							;    Code related to the generic tile-based display engine was developed by
      8  37c7							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  37c7							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  37c7							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  37c7							;
     12  37c7							;    Code related to music and sound effects uses the TIATracker music player
     13  37c7							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  37c7							;    directory for Apache licensing details.
     15  37c7							;
     16  37c7							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  37c7							;    See the copyright notices in the License directory for a list of level
     18  37c7							;    contributors.
     19  37c7							;
     20  37c7							;    Except where otherwise indicated, this software is released under the
     21  37c7							;    following licensing arrangement...
     22  37c7							;
     23  37c7							;    This program is free software: you can redistribute it and/or modify
     24  37c7							;    it under the terms of the GNU General Public License as published by
     25  37c7							;    the Free Software Foundation, either version 3 of the License, or
     26  37c7							;    (at your option) any later version.
     27  37c7							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  37c7
     29  37c7							;    This program is distributed in the hope that it will be useful,
     30  37c7							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  37c7							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  37c7							;    GNU General Public License for more details.
     33  37c7
     34  37c7							; level definitions
     35  37c7							; Sample level definitions.
     36  37c7							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  37c7							; have as many banks as you like.
     38  37c7
      0  37c7					      NEWBANK	LEVELS4
      1  3f4a ????				      SEG	LEVELS4
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   LEVELS4    SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	LEVELS4
     40  3800
      0  3800					      DEFL	_048_L, "2-7#-|2-#5-2#|3#$2-#2-#|#-$.3-$-#|#.2*2-4#|#+.#-2#3-|2#$3-#3-|-#4-#3-|-6#3-"
      0  3800					      START_LEVEL	_048_L
      1  3800				   LEVEL_START SET	*
      2  3800		       00 07	   BANK_LEVEL__048_L =	_CURRENT_BANK
      3  3800				   LEVEL__048_L SUBROUTINE
      4  3800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3800
      2  3800		       32 2d 37 23*	      .byte.b	"2-7#-|2-#5-2#|3#$2-#2-#|#-$.3-$-#|#.2*2-4#|#+.#-2#3-|2#$3-#3-|-#4-#3-|-6#3-",0
      0  384c					      END_LEVEL	_048_L
      1  384c		       00 4c	   LEVEL_SIZE__048_L =	* - LEVEL_START
      2  384c				  -	      IF	LEVEL_SIZE__048_L > MAX_LEVEL_SIZE
      3  384c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__048_L
      4  384c					      ENDIF
      0  384c					      DEFL	_048_R, "5-5#|2-4#3-#|3#-.$-$-#|#2-*3.3#|#2-*.-4#|2#2$*$3-#|-#@$.4-#|-4#2-3#|4-4#2-"
      0  384c					      START_LEVEL	_048_R
      1  384c				   LEVEL_START SET	*
      2  384c		       00 07	   BANK_LEVEL__048_R =	_CURRENT_BANK
      3  384c				   LEVEL__048_R SUBROUTINE
      4  384c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  384c
      2  384c		       35 2d 35 23*	      .byte.b	"5-5#|2-4#3-#|3#-.$-$-#|#2-*3.3#|#2-*.-4#|2#2$*$3-#|-#@$.4-#|-4#2-3#|4-4#2-",0
      0  3897					      END_LEVEL	_048_R
      1  3897		       00 4b	   LEVEL_SIZE__048_R =	* - LEVEL_START
      2  3897				  -	      IF	LEVEL_SIZE__048_R > MAX_LEVEL_SIZE
      3  3897				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__048_R
      4  3897					      ENDIF
      0  3897					      DEFL	_049_L, "4#7-|#2-4#4-|#2-$2-5#|#-$-#-4.#|2#-2$-.-.2#|-#$-#-*#-#-|-#-@#$-#-#-|-4#4-#-|4-6#-"
      0  3897					      START_LEVEL	_049_L
      1  3897				   LEVEL_START SET	*
      2  3897		       00 07	   BANK_LEVEL__049_L =	_CURRENT_BANK
      3  3897				   LEVEL__049_L SUBROUTINE
      4  3897				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3897
      2  3897		       34 23 37 2d*	      .byte.b	"4#7-|#2-4#4-|#2-$2-5#|#-$-#-4.#|2#-2$-.-.2#|-#$-#-*#-#-|-#-@#$-#-#-|-4#4-#-|4-6#-",0
      0  38e9					      END_LEVEL	_049_L
      1  38e9		       00 52	   LEVEL_SIZE__049_L =	* - LEVEL_START
      2  38e9				  -	      IF	LEVEL_SIZE__049_L > MAX_LEVEL_SIZE
      3  38e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__049_L
      4  38e9					      ENDIF
      0  38e9					      DEFL	_049_R, "8#2-|#6-3#|#-$2#$.*-#|#-$-$2.*+#|#3-#2.$-#|#-2$#-.3#|2#5-#2-|-7#2-"
      0  38e9					      START_LEVEL	_049_R
      1  38e9				   LEVEL_START SET	*
      2  38e9		       00 07	   BANK_LEVEL__049_R =	_CURRENT_BANK
      3  38e9				   LEVEL__049_R SUBROUTINE
      4  38e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  38e9
      2  38e9		       38 23 32 2d*	      .byte.b	"8#2-|#6-3#|#-$2#$.*-#|#-$-$2.*+#|#3-#2.$-#|#-2$#-.3#|2#5-#2-|-7#2-",0
      0  392c					      END_LEVEL	_049_R
      1  392c		       00 43	   LEVEL_SIZE__049_R =	* - LEVEL_START
      2  392c				  -	      IF	LEVEL_SIZE__049_R > MAX_LEVEL_SIZE
      3  392c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__049_R
      4  392c					      ENDIF
     45  392c
      0  392c					      DEFL	_050_L, "4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#"
      0  392c					      START_LEVEL	_050_L
      1  392c				   LEVEL_START SET	*
      2  392c		       00 07	   BANK_LEVEL__050_L =	_CURRENT_BANK
      3  392c				   LEVEL__050_L SUBROUTINE
      4  392c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  392c
      2  392c		       34 2d 35 23*	      .byte.b	"4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#",0
      0  3979					      END_LEVEL	_050_L
      1  3979		       00 4d	   LEVEL_SIZE__050_L =	* - LEVEL_START
      2  3979				  -	      IF	LEVEL_SIZE__050_L > MAX_LEVEL_SIZE
      3  3979				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_L
      4  3979					      ENDIF
      0  3979					      DEFL	_050_R, "8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#"
      0  3979					      START_LEVEL	_050_R
      1  3979				   LEVEL_START SET	*
      2  3979		       00 07	   BANK_LEVEL__050_R =	_CURRENT_BANK
      3  3979				   LEVEL__050_R SUBROUTINE
      4  3979				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3979
      2  3979		       38 23 7c 23*	      .byte.b	"8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#",0
      0  39b2					      END_LEVEL	_050_R
      1  39b2		       00 39	   LEVEL_SIZE__050_R =	* - LEVEL_START
      2  39b2				  -	      IF	LEVEL_SIZE__050_R > MAX_LEVEL_SIZE
      3  39b2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_R
      4  39b2					      ENDIF
      0  39b2					      DEFL	_051_L, "-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#"
      0  39b2					      START_LEVEL	_051_L
      1  39b2				   LEVEL_START SET	*
      2  39b2		       00 07	   BANK_LEVEL__051_L =	_CURRENT_BANK
      3  39b2				   LEVEL__051_L SUBROUTINE
      4  39b2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  39b2
      2  39b2		       2d 36 23 34*	      .byte.b	"-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#",0
      0  3a05					      END_LEVEL	_051_L
      1  3a05		       00 53	   LEVEL_SIZE__051_L =	* - LEVEL_START
      2  3a05				  -	      IF	LEVEL_SIZE__051_L > MAX_LEVEL_SIZE
      3  3a05				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_L
      4  3a05					      ENDIF
      0  3a05					      DEFL	_051_R, "-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-"
      0  3a05					      START_LEVEL	_051_R
      1  3a05				   LEVEL_START SET	*
      2  3a05		       00 07	   BANK_LEVEL__051_R =	_CURRENT_BANK
      3  3a05				   LEVEL__051_R SUBROUTINE
      4  3a05				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a05
      2  3a05		       2d 38 23 2d*	      .byte.b	"-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-",0
      0  3a56					      END_LEVEL	_051_R
      1  3a56		       00 51	   LEVEL_SIZE__051_R =	* - LEVEL_START
      2  3a56				  -	      IF	LEVEL_SIZE__051_R > MAX_LEVEL_SIZE
      3  3a56				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_R
      4  3a56					      ENDIF
      0  3a56					      DEFL	_052_L, "5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-"
      0  3a56					      START_LEVEL	_052_L
      1  3a56				   LEVEL_START SET	*
      2  3a56		       00 07	   BANK_LEVEL__052_L =	_CURRENT_BANK
      3  3a56				   LEVEL__052_L SUBROUTINE
      4  3a56				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a56
      2  3a56		       35 23 36 2d*	      .byte.b	"5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-",0
      0  3a90					      END_LEVEL	_052_L
      1  3a90		       00 3a	   LEVEL_SIZE__052_L =	* - LEVEL_START
      2  3a90				  -	      IF	LEVEL_SIZE__052_L > MAX_LEVEL_SIZE
      3  3a90				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_L
      4  3a90					      ENDIF
      0  3a90					      DEFL	_052_R, "2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-"
      0  3a90					      START_LEVEL	_052_R
      1  3a90				   LEVEL_START SET	*
      2  3a90		       00 07	   BANK_LEVEL__052_R =	_CURRENT_BANK
      3  3a90				   LEVEL__052_R SUBROUTINE
      4  3a90				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a90
      2  3a90		       32 2d 37 23*	      .byte.b	"2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-",0
      0  3ad8					      END_LEVEL	_052_R
      1  3ad8		       00 48	   LEVEL_SIZE__052_R =	* - LEVEL_START
      2  3ad8				  -	      IF	LEVEL_SIZE__052_R > MAX_LEVEL_SIZE
      3  3ad8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_R
      4  3ad8					      ENDIF
      0  3ad8					      DEFL	_053_L, "6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-"
      0  3ad8					      START_LEVEL	_053_L
      1  3ad8				   LEVEL_START SET	*
      2  3ad8		       00 07	   BANK_LEVEL__053_L =	_CURRENT_BANK
      3  3ad8				   LEVEL__053_L SUBROUTINE
      4  3ad8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ad8
      2  3ad8		       36 23 36 2d*	      .byte.b	"6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-",0
      0  3b2d					      END_LEVEL	_053_L
      1  3b2d		       00 55	   LEVEL_SIZE__053_L =	* - LEVEL_START
      2  3b2d				  -	      IF	LEVEL_SIZE__053_L > MAX_LEVEL_SIZE
      3  3b2d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_L
      4  3b2d					      ENDIF
      0  3b2d					      DEFL	_053_R, "5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-"
      0  3b2d					      START_LEVEL	_053_R
      1  3b2d				   LEVEL_START SET	*
      2  3b2d		       00 07	   BANK_LEVEL__053_R =	_CURRENT_BANK
      3  3b2d				   LEVEL__053_R SUBROUTINE
      4  3b2d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b2d
      2  3b2d		       35 2d 35 23*	      .byte.b	"5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-",0
      0  3b7a					      END_LEVEL	_053_R
      1  3b7a		       00 4d	   LEVEL_SIZE__053_R =	* - LEVEL_START
      2  3b7a				  -	      IF	LEVEL_SIZE__053_R > MAX_LEVEL_SIZE
      3  3b7a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_R
      4  3b7a					      ENDIF
      0  3b7a					      DEFL	_054_L, "-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-"
      0  3b7a					      START_LEVEL	_054_L
      1  3b7a				   LEVEL_START SET	*
      2  3b7a		       00 07	   BANK_LEVEL__054_L =	_CURRENT_BANK
      3  3b7a				   LEVEL__054_L SUBROUTINE
      4  3b7a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b7a
      2  3b7a		       2d 38 23 32*	      .byte.b	"-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-",0
      0  3bc6					      END_LEVEL	_054_L
      1  3bc6		       00 4c	   LEVEL_SIZE__054_L =	* - LEVEL_START
      2  3bc6				  -	      IF	LEVEL_SIZE__054_L > MAX_LEVEL_SIZE
      3  3bc6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_L
      4  3bc6					      ENDIF
      0  3bc6					      DEFL	_054_R, "2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-"
      0  3bc6					      START_LEVEL	_054_R
      1  3bc6				   LEVEL_START SET	*
      2  3bc6		       00 07	   BANK_LEVEL__054_R =	_CURRENT_BANK
      3  3bc6				   LEVEL__054_R SUBROUTINE
      4  3bc6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3bc6
      2  3bc6		       32 2d 34 23*	      .byte.b	"2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-",0
      0  3c0f					      END_LEVEL	_054_R
      1  3c0f		       00 49	   LEVEL_SIZE__054_R =	* - LEVEL_START
      2  3c0f				  -	      IF	LEVEL_SIZE__054_R > MAX_LEVEL_SIZE
      3  3c0f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_R
      4  3c0f					      ENDIF
      0  3c0f					      DEFL	_055_L, "2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-"
      0  3c0f					      START_LEVEL	_055_L
      1  3c0f				   LEVEL_START SET	*
      2  3c0f		       00 07	   BANK_LEVEL__055_L =	_CURRENT_BANK
      3  3c0f				   LEVEL__055_L SUBROUTINE
      4  3c0f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c0f
      2  3c0f		       32 2d 34 23*	      .byte.b	"2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-",0
      0  3c69					      END_LEVEL	_055_L
      1  3c69		       00 5a	   LEVEL_SIZE__055_L =	* - LEVEL_START
      2  3c69				  -	      IF	LEVEL_SIZE__055_L > MAX_LEVEL_SIZE
      3  3c69				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_L
      4  3c69					      ENDIF
      0  3c69					      DEFL	_055_R, "5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-"
      0  3c69					      START_LEVEL	_055_R
      1  3c69				   LEVEL_START SET	*
      2  3c69		       00 07	   BANK_LEVEL__055_R =	_CURRENT_BANK
      3  3c69				   LEVEL__055_R SUBROUTINE
      4  3c69				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c69
      2  3c69		       35 2d 34 23*	      .byte.b	"5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-",0
      0  3cbe					      END_LEVEL	_055_R
      1  3cbe		       00 55	   LEVEL_SIZE__055_R =	* - LEVEL_START
      2  3cbe				  -	      IF	LEVEL_SIZE__055_R > MAX_LEVEL_SIZE
      3  3cbe				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_R
      4  3cbe					      ENDIF
      0  3cbe					      DEFL	_056_L, "6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#"
      0  3cbe					      START_LEVEL	_056_L
      1  3cbe				   LEVEL_START SET	*
      2  3cbe		       00 07	   BANK_LEVEL__056_L =	_CURRENT_BANK
      3  3cbe				   LEVEL__056_L SUBROUTINE
      4  3cbe				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3cbe
      2  3cbe		       36 2d 35 23*	      .byte.b	"6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#",0
      0  3d18					      END_LEVEL	_056_L
      1  3d18		       00 5a	   LEVEL_SIZE__056_L =	* - LEVEL_START
      2  3d18				  -	      IF	LEVEL_SIZE__056_L > MAX_LEVEL_SIZE
      3  3d18				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_L
      4  3d18					      ENDIF
      0  3d18					      DEFL	_056_R, "-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-"
      0  3d18					      START_LEVEL	_056_R
      1  3d18				   LEVEL_START SET	*
      2  3d18		       00 07	   BANK_LEVEL__056_R =	_CURRENT_BANK
      3  3d18				   LEVEL__056_R SUBROUTINE
      4  3d18				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d18
      2  3d18		       2d 34 23 2d*	      .byte.b	"-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-",0
      0  3d73					      END_LEVEL	_056_R
      1  3d73		       00 5b	   LEVEL_SIZE__056_R =	* - LEVEL_START
      2  3d73					      IF	LEVEL_SIZE__056_R > MAX_LEVEL_SIZE
      3  3d73				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_R
      4  3d73					      ENDIF
      0  3d73					      DEFL	_057_L, "5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-"
      0  3d73					      START_LEVEL	_057_L
      1  3d73				   LEVEL_START SET	*
      2  3d73		       00 07	   BANK_LEVEL__057_L =	_CURRENT_BANK
      3  3d73				   LEVEL__057_L SUBROUTINE
      4  3d73				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d73
      2  3d73		       35 2d 36 23*	      .byte.b	"5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-",0
      0  3dc9					      END_LEVEL	_057_L
      1  3dc9		       00 56	   LEVEL_SIZE__057_L =	* - LEVEL_START
      2  3dc9				  -	      IF	LEVEL_SIZE__057_L > MAX_LEVEL_SIZE
      3  3dc9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_L
      4  3dc9					      ENDIF
      0  3dc9					      DEFL	_057_R, "5#4-|#3-3#2-|#+2.2-3#|#.#*$-$-#|#.#.-#$-#|#-$2-$2-#|2#$2#3-#|-#5-2#|-7#-"
      0  3dc9					      START_LEVEL	_057_R
      1  3dc9				   LEVEL_START SET	*
      2  3dc9		       00 07	   BANK_LEVEL__057_R =	_CURRENT_BANK
      3  3dc9				   LEVEL__057_R SUBROUTINE
      4  3dc9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3dc9
      2  3dc9		       35 23 34 2d*	      .byte.b	"5#4-|#3-3#2-|#+2.2-3#|#.#*$-$-#|#.#.-#$-#|#-$2-$2-#|2#$2#3-#|-#5-2#|-7#-",0
      0  3e12					      END_LEVEL	_057_R
      1  3e12		       00 49	   LEVEL_SIZE__057_R =	* - LEVEL_START
      2  3e12				  -	      IF	LEVEL_SIZE__057_R > MAX_LEVEL_SIZE
      3  3e12				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_R
      4  3e12					      ENDIF
      0  3e12					      DEFL	_058_L, "-6#4-|-#-3.5#|-#-#.*2#2-#|2#-.*$4-#|#-2$*-$-$-#|#@2-2#4-#|7#3-#|6-5#"
      0  3e12					      START_LEVEL	_058_L
      1  3e12				   LEVEL_START SET	*
      2  3e12		       00 07	   BANK_LEVEL__058_L =	_CURRENT_BANK
      3  3e12				   LEVEL__058_L SUBROUTINE
      4  3e12				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3e12
      2  3e12		       2d 36 23 34*	      .byte.b	"-6#4-|-#-3.5#|-#-#.*2#2-#|2#-.*$4-#|#-2$*-$-$-#|#@2-2#4-#|7#3-#|6-5#",0
      0  3e57					      END_LEVEL	_058_L
      1  3e57		       00 45	   LEVEL_SIZE__058_L =	* - LEVEL_START
      2  3e57				  -	      IF	LEVEL_SIZE__058_L > MAX_LEVEL_SIZE
      3  3e57				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__058_L
      4  3e57					      ENDIF
      0  3e57					      DEFL	_058_R, "4-5#-|3-2#3-#-|4#-.#$#-|#-$2-.#-#-|#@-3*.-2#|#-$.2-*2-#|3#*$#3-#|2-#4-3#|2-6#2-"
      0  3e57					      START_LEVEL	_058_R
      1  3e57				   LEVEL_START SET	*
      2  3e57		       00 07	   BANK_LEVEL__058_R =	_CURRENT_BANK
      3  3e57				   LEVEL__058_R SUBROUTINE
      4  3e57				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3e57
      2  3e57		       34 2d 35 23*	      .byte.b	"4-5#-|3-2#3-#-|4#-.#$#-|#-$2-.#-#-|#@-3*.-2#|#-$.2-*2-#|3#*$#3-#|2-#4-3#|2-6#2-",0
      0  3ea7					      END_LEVEL	_058_R
      1  3ea7		       00 50	   LEVEL_SIZE__058_R =	* - LEVEL_START
      2  3ea7				  -	      IF	LEVEL_SIZE__058_R > MAX_LEVEL_SIZE
      3  3ea7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__058_R
      4  3ea7					      ENDIF
      0  3ea7					      DEFL	_059_L, "6#5-|#4-#5-|#-$#-5#-|#4-.-$@#-|#-#-2*-#$2#|#-$.*-$3-#|2#$#.-2#2-#|-#-3.2#2-#|-10#"
      0  3ea7					      START_LEVEL	_059_L
      1  3ea7				   LEVEL_START SET	*
      2  3ea7		       00 07	   BANK_LEVEL__059_L =	_CURRENT_BANK
      3  3ea7				   LEVEL__059_L SUBROUTINE
      4  3ea7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ea7
      2  3ea7		       36 23 35 2d*	      .byte.b	"6#5-|#4-#5-|#-$#-5#-|#4-.-$@#-|#-#-2*-#$2#|#-$.*-$3-#|2#$#.-2#2-#|-#-3.2#2-#|-10#",0
      0  3ef9					      END_LEVEL	_059_L
      1  3ef9		       00 52	   LEVEL_SIZE__059_L =	* - LEVEL_START
      2  3ef9				  -	      IF	LEVEL_SIZE__059_L > MAX_LEVEL_SIZE
      3  3ef9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__059_L
      4  3ef9					      ENDIF
      0  3ef9					      DEFL	_059_R, "7-3#-|8#.#-|#4-#-2.2#|#-#-2$*.$-#|#5-2.#-#|2#2-2#-2#-#|#2-$-2$2#-#|#3-2#3-@#|11#"
      0  3ef9					      START_LEVEL	_059_R
      1  3ef9				   LEVEL_START SET	*
      2  3ef9		       00 07	   BANK_LEVEL__059_R =	_CURRENT_BANK
      3  3ef9				   LEVEL__059_R SUBROUTINE
      4  3ef9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ef9
      2  3ef9		       37 2d 33 23*	      .byte.b	"7-3#-|8#.#-|#4-#-2.2#|#-#-2$*.$-#|#5-2.#-#|2#2-2#-2#-#|#2-$-2$2#-#|#3-2#3-@#|11#",0
      0  3f4a					      END_LEVEL	_059_R
      1  3f4a		       00 51	   LEVEL_SIZE__059_R =	* - LEVEL_START
      2  3f4a				  -	      IF	LEVEL_SIZE__059_R > MAX_LEVEL_SIZE
      3  3f4a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__059_R
      4  3f4a					      ENDIF
     66  3f4a
      0  3f4a					      CHECK_BANK_SIZE	"LEVELS4 -- full 2K"
      1  3f4a		       07 4a	   .TEMP      =	* - BANK_START
 LEVELS4 -- full 2K (2K) SIZE =  $74a , FREE= $b6
      2  3f4a					      ECHO	"LEVELS4 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3f4a				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3f4a				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3f4a				  -	      ERR
      6  3f4a					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS5.asm LEVEL 2 PASS 4
      0  3f4a					      include	"BANK_LEVELS5.asm"
      1  3f4a							;    Sokoboo - a Sokoban implementation
      2  3f4a							;    using a generic tile-based display engine for the Atari 2600
      3  3f4a							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  3f4a							;
      5  3f4a							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  3f4a							;
      7  3f4a							;    Code related to the generic tile-based display engine was developed by
      8  3f4a							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  3f4a							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  3f4a							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  3f4a							;
     12  3f4a							;    Code related to music and sound effects uses the TIATracker music player
     13  3f4a							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  3f4a							;    directory for Apache licensing details.
     15  3f4a							;
     16  3f4a							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  3f4a							;    See the copyright notices in the License directory for a list of level
     18  3f4a							;    contributors.
     19  3f4a							;
     20  3f4a							;    Except where otherwise indicated, this software is released under the
     21  3f4a							;    following licensing arrangement...
     22  3f4a							;
     23  3f4a							;    This program is free software: you can redistribute it and/or modify
     24  3f4a							;    it under the terms of the GNU General Public License as published by
     25  3f4a							;    the Free Software Foundation, either version 3 of the License, or
     26  3f4a							;    (at your option) any later version.
     27  3f4a							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  3f4a
     29  3f4a							;    This program is distributed in the hope that it will be useful,
     30  3f4a							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  3f4a							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  3f4a							;    GNU General Public License for more details.
     33  3f4a
     34  3f4a							; level definitions
     35  3f4a							; Sample level definitions.
     36  3f4a							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  3f4a							; have as many banks as you like.
     38  3f4a
      0  3f4a					      NEWBANK	LEVELS5
      1  4619 ????				      SEG	LEVELS5
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   LEVELS5    SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	LEVELS5
     40  4000
      0  4000					      DEFL	_060_R, "3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#"
      0  4000					      START_LEVEL	_060_R
      1  4000				   LEVEL_START SET	*
      2  4000		       00 08	   BANK_LEVEL__060_R =	_CURRENT_BANK
      3  4000				   LEVEL__060_R SUBROUTINE
      4  4000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4000
      2  4000		       33 2d 36 23*	      .byte.b	"3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#",0
      0  4048					      END_LEVEL	_060_R
      1  4048		       00 48	   LEVEL_SIZE__060_R =	* - LEVEL_START
      2  4048				  -	      IF	LEVEL_SIZE__060_R > MAX_LEVEL_SIZE
      3  4048				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__060_R
      4  4048					      ENDIF
      0  4048					      DEFL	_061_L, "10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#"
      0  4048					      START_LEVEL	_061_L
      1  4048				   LEVEL_START SET	*
      2  4048		       00 08	   BANK_LEVEL__061_L =	_CURRENT_BANK
      3  4048				   LEVEL__061_L SUBROUTINE
      4  4048				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4048
      2  4048		       31 30 23 2d*	      .byte.b	"10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#",0
      0  409c					      END_LEVEL	_061_L
      1  409c		       00 54	   LEVEL_SIZE__061_L =	* - LEVEL_START
      2  409c				  -	      IF	LEVEL_SIZE__061_L > MAX_LEVEL_SIZE
      3  409c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_L
      4  409c					      ENDIF
      0  409c					      DEFL	_061_R, "4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#"
      0  409c					      START_LEVEL	_061_R
      1  409c				   LEVEL_START SET	*
      2  409c		       00 08	   BANK_LEVEL__061_R =	_CURRENT_BANK
      3  409c				   LEVEL__061_R SUBROUTINE
      4  409c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  409c
      2  409c		       34 2d 35 23*	      .byte.b	"4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#",0
      0  40e5					      END_LEVEL	_061_R
      1  40e5		       00 49	   LEVEL_SIZE__061_R =	* - LEVEL_START
      2  40e5				  -	      IF	LEVEL_SIZE__061_R > MAX_LEVEL_SIZE
      3  40e5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_R
      4  40e5					      ENDIF
      0  40e5					      DEFL	_062_L, "-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#"
      0  40e5					      START_LEVEL	_062_L
      1  40e5				   LEVEL_START SET	*
      2  40e5		       00 08	   BANK_LEVEL__062_L =	_CURRENT_BANK
      3  40e5				   LEVEL__062_L SUBROUTINE
      4  40e5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  40e5
      2  40e5		       2d 35 23 36*	      .byte.b	"-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#",0
      0  413c					      END_LEVEL	_062_L
      1  413c		       00 57	   LEVEL_SIZE__062_L =	* - LEVEL_START
      2  413c				  -	      IF	LEVEL_SIZE__062_L > MAX_LEVEL_SIZE
      3  413c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_L
      4  413c					      ENDIF
      0  413c					      DEFL	_062_R, "5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-"
      0  413c					      START_LEVEL	_062_R
      1  413c				   LEVEL_START SET	*
      2  413c		       00 08	   BANK_LEVEL__062_R =	_CURRENT_BANK
      3  413c				   LEVEL__062_R SUBROUTINE
      4  413c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  413c
      2  413c		       35 2d 35 23*	      .byte.b	"5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-",0
      0  4188					      END_LEVEL	_062_R
      1  4188		       00 4c	   LEVEL_SIZE__062_R =	* - LEVEL_START
      2  4188				  -	      IF	LEVEL_SIZE__062_R > MAX_LEVEL_SIZE
      3  4188				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_R
      4  4188					      ENDIF
      0  4188					      DEFL	_063_L, "2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#"
      0  4188					      START_LEVEL	_063_L
      1  4188				   LEVEL_START SET	*
      2  4188		       00 08	   BANK_LEVEL__063_L =	_CURRENT_BANK
      3  4188				   LEVEL__063_L SUBROUTINE
      4  4188				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4188
      2  4188		       32 2d 35 23*	      .byte.b	"2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#",0
      0  41d8					      END_LEVEL	_063_L
      1  41d8		       00 50	   LEVEL_SIZE__063_L =	* - LEVEL_START
      2  41d8				  -	      IF	LEVEL_SIZE__063_L > MAX_LEVEL_SIZE
      3  41d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_L
      4  41d8					      ENDIF
      0  41d8					      DEFL	_063_R, "2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-"
      0  41d8					      START_LEVEL	_063_R
      1  41d8				   LEVEL_START SET	*
      2  41d8		       00 08	   BANK_LEVEL__063_R =	_CURRENT_BANK
      3  41d8				   LEVEL__063_R SUBROUTINE
      4  41d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  41d8
      2  41d8		       32 2d 36 23*	      .byte.b	"2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-",0
      0  422a					      END_LEVEL	_063_R
      1  422a		       00 52	   LEVEL_SIZE__063_R =	* - LEVEL_START
      2  422a				  -	      IF	LEVEL_SIZE__063_R > MAX_LEVEL_SIZE
      3  422a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_R
      4  422a					      ENDIF
      0  422a					      DEFL	_064_L, "-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-"
      0  422a					      START_LEVEL	_064_L
      1  422a				   LEVEL_START SET	*
      2  422a		       00 08	   BANK_LEVEL__064_L =	_CURRENT_BANK
      3  422a				   LEVEL__064_L SUBROUTINE
      4  422a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  422a
      2  422a		       2d 38 23 33*	      .byte.b	"-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-",0
      0  4285					      END_LEVEL	_064_L
      1  4285		       00 5b	   LEVEL_SIZE__064_L =	* - LEVEL_START
      2  4285				  -	      IF	LEVEL_SIZE__064_L > MAX_LEVEL_SIZE
      3  4285				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_L
      4  4285					      ENDIF
      0  4285					      DEFL	_064_R, "4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-"
      0  4285					      START_LEVEL	_064_R
      1  4285				   LEVEL_START SET	*
      2  4285		       00 08	   BANK_LEVEL__064_R =	_CURRENT_BANK
      3  4285				   LEVEL__064_R SUBROUTINE
      4  4285				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4285
      2  4285		       34 23 2d 36*	      .byte.b	"4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-",0
      0  42d1					      END_LEVEL	_064_R
      1  42d1		       00 4c	   LEVEL_SIZE__064_R =	* - LEVEL_START
      2  42d1				  -	      IF	LEVEL_SIZE__064_R > MAX_LEVEL_SIZE
      3  42d1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_R
      4  42d1					      ENDIF
      0  42d1					      DEFL	_065_L, "2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-"
      0  42d1					      START_LEVEL	_065_L
      1  42d1				   LEVEL_START SET	*
      2  42d1		       00 08	   BANK_LEVEL__065_L =	_CURRENT_BANK
      3  42d1				   LEVEL__065_L SUBROUTINE
      4  42d1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  42d1
      2  42d1		       32 2d 35 23*	      .byte.b	"2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-",0
      0  4329					      END_LEVEL	_065_L
      1  4329		       00 58	   LEVEL_SIZE__065_L =	* - LEVEL_START
      2  4329				  -	      IF	LEVEL_SIZE__065_L > MAX_LEVEL_SIZE
      3  4329				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_L
      4  4329					      ENDIF
      0  4329					      DEFL	_065_R, "3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#"
      0  4329					      START_LEVEL	_065_R
      1  4329				   LEVEL_START SET	*
      2  4329		       00 08	   BANK_LEVEL__065_R =	_CURRENT_BANK
      3  4329				   LEVEL__065_R SUBROUTINE
      4  4329				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4329
      2  4329		       33 2d 35 23*	      .byte.b	"3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#",0
      0  4371					      END_LEVEL	_065_R
      1  4371		       00 48	   LEVEL_SIZE__065_R =	* - LEVEL_START
      2  4371				  -	      IF	LEVEL_SIZE__065_R > MAX_LEVEL_SIZE
      3  4371				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_R
      4  4371					      ENDIF
      0  4371					      DEFL	_066_L, "10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-"
      0  4371					      START_LEVEL	_066_L
      1  4371				   LEVEL_START SET	*
      2  4371		       00 08	   BANK_LEVEL__066_L =	_CURRENT_BANK
      3  4371				   LEVEL__066_L SUBROUTINE
      4  4371				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4371
      2  4371		       31 30 23 33*	      .byte.b	"10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-",0
      0  43cb					      END_LEVEL	_066_L
      1  43cb		       00 5a	   LEVEL_SIZE__066_L =	* - LEVEL_START
      2  43cb				  -	      IF	LEVEL_SIZE__066_L > MAX_LEVEL_SIZE
      3  43cb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_L
      4  43cb					      ENDIF
      0  43cb					      DEFL	_066_R, "2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#"
      0  43cb					      START_LEVEL	_066_R
      1  43cb				   LEVEL_START SET	*
      2  43cb		       00 08	   BANK_LEVEL__066_R =	_CURRENT_BANK
      3  43cb				   LEVEL__066_R SUBROUTINE
      4  43cb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  43cb
      2  43cb		       32 2d 35 23*	      .byte.b	"2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#",0
      0  4421					      END_LEVEL	_066_R
      1  4421		       00 56	   LEVEL_SIZE__066_R =	* - LEVEL_START
      2  4421				  -	      IF	LEVEL_SIZE__066_R > MAX_LEVEL_SIZE
      3  4421				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_R
      4  4421					      ENDIF
      0  4421					      DEFL	_067_L, "8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#"
      0  4421					      START_LEVEL	_067_L
      1  4421				   LEVEL_START SET	*
      2  4421		       00 08	   BANK_LEVEL__067_L =	_CURRENT_BANK
      3  4421				   LEVEL__067_L SUBROUTINE
      4  4421				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4421
      2  4421		       38 23 33 2d*	      .byte.b	"8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#",0
      0  446e					      END_LEVEL	_067_L
      1  446e		       00 4d	   LEVEL_SIZE__067_L =	* - LEVEL_START
      2  446e				  -	      IF	LEVEL_SIZE__067_L > MAX_LEVEL_SIZE
      3  446e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_L
      4  446e					      ENDIF
      0  446e					      DEFL	_067_R, "7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-"
      0  446e					      START_LEVEL	_067_R
      1  446e				   LEVEL_START SET	*
      2  446e		       00 08	   BANK_LEVEL__067_R =	_CURRENT_BANK
      3  446e				   LEVEL__067_R SUBROUTINE
      4  446e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  446e
      2  446e		       37 23 32 2d*	      .byte.b	"7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-",0
      0  44d3					      END_LEVEL	_067_R
      1  44d3		       00 65	   LEVEL_SIZE__067_R =	* - LEVEL_START
      2  44d3					      IF	LEVEL_SIZE__067_R > MAX_LEVEL_SIZE
      3  44d3				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_R
      4  44d3					      ENDIF
      0  44d3					      DEFL	_068_L, "10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-"
      0  44d3					      START_LEVEL	_068_L
      1  44d3				   LEVEL_START SET	*
      2  44d3		       00 08	   BANK_LEVEL__068_L =	_CURRENT_BANK
      3  44d3				   LEVEL__068_L SUBROUTINE
      4  44d3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  44d3
      2  44d3		       31 30 23 7c*	      .byte.b	"10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-",0
      0  4527					      END_LEVEL	_068_L
      1  4527		       00 54	   LEVEL_SIZE__068_L =	* - LEVEL_START
      2  4527				  -	      IF	LEVEL_SIZE__068_L > MAX_LEVEL_SIZE
      3  4527				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_L
      4  4527					      ENDIF
      0  4527					      DEFL	_068_R, "5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-"
      0  4527					      START_LEVEL	_068_R
      1  4527				   LEVEL_START SET	*
      2  4527		       00 08	   BANK_LEVEL__068_R =	_CURRENT_BANK
      3  4527				   LEVEL__068_R SUBROUTINE
      4  4527				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4527
      2  4527		       35 2d 35 23*	      .byte.b	"5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-",0
      0  457d					      END_LEVEL	_068_R
      1  457d		       00 56	   LEVEL_SIZE__068_R =	* - LEVEL_START
      2  457d				  -	      IF	LEVEL_SIZE__068_R > MAX_LEVEL_SIZE
      3  457d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_R
      4  457d					      ENDIF
      0  457d					      DEFL	_069_L, "-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#"
      0  457d					      START_LEVEL	_069_L
      1  457d				   LEVEL_START SET	*
      2  457d		       00 08	   BANK_LEVEL__069_L =	_CURRENT_BANK
      3  457d				   LEVEL__069_L SUBROUTINE
      4  457d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  457d
      2  457d		       2d 36 23 33*	      .byte.b	"-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#",0
      0  45cb					      END_LEVEL	_069_L
      1  45cb		       00 4e	   LEVEL_SIZE__069_L =	* - LEVEL_START
      2  45cb				  -	      IF	LEVEL_SIZE__069_L > MAX_LEVEL_SIZE
      3  45cb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_L
      4  45cb					      ENDIF
      0  45cb					      DEFL	_069_R, "2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-"
      0  45cb					      START_LEVEL	_069_R
      1  45cb				   LEVEL_START SET	*
      2  45cb		       00 08	   BANK_LEVEL__069_R =	_CURRENT_BANK
      3  45cb				   LEVEL__069_R SUBROUTINE
      4  45cb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  45cb
      2  45cb		       32 2d 35 23*	      .byte.b	"2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-",0
      0  4619					      END_LEVEL	_069_R
      1  4619		       00 4e	   LEVEL_SIZE__069_R =	* - LEVEL_START
      2  4619				  -	      IF	LEVEL_SIZE__069_R > MAX_LEVEL_SIZE
      3  4619				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_R
      4  4619					      ENDIF
     60  4619
     61  4619
      0  4619					      CHECK_BANK_SIZE	"LEVELS5 -- full 2K"
      1  4619		       06 19	   .TEMP      =	* - BANK_START
 LEVELS5 -- full 2K (2K) SIZE =  $619 , FREE= $1e7
      2  4619					      ECHO	"LEVELS5 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4619				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4619				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4619				  -	      ERR
      6  4619					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS6.asm LEVEL 2 PASS 4
      0  4619					      include	"BANK_LEVELS6.asm"
      1  4619							;    Sokoboo - a Sokoban implementation
      2  4619							;    using a generic tile-based display engine for the Atari 2600
      3  4619							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  4619							;
      5  4619							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  4619							;
      7  4619							;    Code related to the generic tile-based display engine was developed by
      8  4619							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  4619							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  4619							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  4619							;
     12  4619							;    Code related to music and sound effects uses the TIATracker music player
     13  4619							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  4619							;    directory for Apache licensing details.
     15  4619							;
     16  4619							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  4619							;    See the copyright notices in the License directory for a list of level
     18  4619							;    contributors.
     19  4619							;
     20  4619							;    Except where otherwise indicated, this software is released under the
     21  4619							;    following licensing arrangement...
     22  4619							;
     23  4619							;    This program is free software: you can redistribute it and/or modify
     24  4619							;    it under the terms of the GNU General Public License as published by
     25  4619							;    the Free Software Foundation, either version 3 of the License, or
     26  4619							;    (at your option) any later version.
     27  4619							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  4619
     29  4619							;    This program is distributed in the hope that it will be useful,
     30  4619							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  4619							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  4619							;    GNU General Public License for more details.
     33  4619
     34  4619							; level definitions
     35  4619							; Sample level definitions.
     36  4619							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  4619							; have as many banks as you like.
     38  4619
      0  4619					      NEWBANK	LEVELS6
      1  4d9f ????				      SEG	LEVELS6
      2  4800					      ORG	ORIGIN
      3  4800					      RORG	$F000
      4  4800				   BANK_START SET	*
      5  4800				   LEVELS6    SET	ORIGIN / 2048
      6  4800				   ORIGIN     SET	ORIGIN + 2048
      7  4800				   _CURRENT_BANK SET	LEVELS6
     40  4800
     41  4800
     42  4800							; Level definitions
     43  4800
     44  4800							; "sokhard" collection
     45  4800
      0  4800					      START_LEVEL	_102_Natalie
      1  4800				   LEVEL_START SET	*
      2  4800		       00 09	   BANK_LEVEL__102_Natalie =	_CURRENT_BANK
      3  4800				   LEVEL__102_Natalie SUBROUTINE
      4  4800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4800
     47  4800		       31 31 23 7c*	      .byte.b	"11#|2#2-#@4.#|2#3-2$.2*#|2#-$2-2$#.#|#2-$#-#2-.#|#2-$-#-2#-#|#9-#|11#",0
      0  4846					      END_LEVEL	_102_Natalie
      1  4846		       00 46	   LEVEL_SIZE__102_Natalie =	* - LEVEL_START
      2  4846				  -	      IF	LEVEL_SIZE__102_Natalie > MAX_LEVEL_SIZE
      3  4846				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Natalie
      4  4846					      ENDIF
     49  4846
      0  4846					      START_LEVEL	_102_Mirabel
      1  4846				   LEVEL_START SET	*
      2  4846		       00 09	   BANK_LEVEL__102_Mirabel =	_CURRENT_BANK
      3  4846				   LEVEL__102_Mirabel SUBROUTINE
      4  4846				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4846
     51  4846		       31 31 23 7c*	      .byte.b	"11#|6#3-2#|2#2-2#$2-2#|2#2-#-2$-2#|#7-3#|#.-#$-#-3#|#.#.-#2-$-#|#3.#-2$#@#|#-2.4-$-#|#2-8#|11#",0
      0  48a5					      END_LEVEL	_102_Mirabel
      1  48a5		       00 5f	   LEVEL_SIZE__102_Mirabel =	* - LEVEL_START
      2  48a5				  -	      IF	LEVEL_SIZE__102_Mirabel > MAX_LEVEL_SIZE
      3  48a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Mirabel
      4  48a5					      ENDIF
     53  48a5
      0  48a5					      START_LEVEL	_102_Oralia
      1  48a5				   LEVEL_START SET	*
      2  48a5		       00 09	   BANK_LEVEL__102_Oralia =	_CURRENT_BANK
      3  48a5				   LEVEL__102_Oralia SUBROUTINE
      4  48a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  48a5
     55  48a5		       39 23 7c 23*	      .byte.b	"9#|#2.$.#2-#|#4.2*-#|#-$.2#2-#|2#-$2-$-#|4#$-$-#|#-$3-$-#|#5-#@#|9#",0
      0  48e9					      END_LEVEL	_102_Oralia
      1  48e9		       00 44	   LEVEL_SIZE__102_Oralia =	* - LEVEL_START
      2  48e9				  -	      IF	LEVEL_SIZE__102_Oralia > MAX_LEVEL_SIZE
      3  48e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Oralia
      4  48e9					      ENDIF
     57  48e9
     58  48e9
     59  48e9							;---------------------------------------------------------------------------------------------------
     60  48e9							; IMAGE IS ABOVE DEFINITION
     61  48e9
     62  48e9							;  ###########
     63  48e9							;  #  #      #
     64  48e9							;  # $# $ $$ #
     65  48e9							;  #  ##$#$  #
     66  48e9							;  #  $    #@#
     67  48e9							;  # $## #  ##
     68  48e9							;  ##	# .## #
     69  48e9							;  ##$ #.*. ##
     70  48e9							;  # ..*. *. #
     71  48e9							;  # # .. #  #
     72  48e9							;  ###########
     73  48e9
      0  48e9					      START_LEVEL	_102_Raven
      1  48e9				   LEVEL_START SET	*
      2  48e9		       00 09	   BANK_LEVEL__102_Raven =	_CURRENT_BANK
      3  48e9				   LEVEL__102_Raven SUBROUTINE
      4  48e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  48e9
     75  48e9		       31 31 23 7c*	      .byte.b	"11#|#2-#6-#|#-$#-$-2$-#|#2-2#$#$2-#|#2-$4-#@#|#-$2#-#2-2#|2#2-#-.2#-#|2#$-#.*.-2#|#-2.*.-*.-#|#-#-2.-#2-#|11#",0
      0  4957					      END_LEVEL	_102_Raven
      1  4957		       00 6e	   LEVEL_SIZE__102_Raven =	* - LEVEL_START
      2  4957					      IF	LEVEL_SIZE__102_Raven > MAX_LEVEL_SIZE
      3  4957				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Raven
      4  4957					      ENDIF
     77  4957
     78  4957							;  ############
     79  4957							;  #@##. #  # #
     80  4957							;  #**..$#    #
     81  4957							;  #. $..#  # #
     82  4957							;  # $#.$#$$$ #
     83  4957							;  #	      ##
     84  4957							;  #  ##  #   #
     85  4957							;  ############
     86  4957
      0  4957					      START_LEVEL	_103_Adin
      1  4957				   LEVEL_START SET	*
      2  4957		       00 09	   BANK_LEVEL__103_Adin =	_CURRENT_BANK
      3  4957				   LEVEL__103_Adin SUBROUTINE
      4  4957				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4957
     88  4957		       31 32 23 7c*	      .byte.b	"12#|#@2#.-#2-#-#|#2*2.$#4-#|#.-$2.#2-#-#|#-$#.$#3$-#|#9-2#|#2-2#2-#3-#|12#",0
      0  49a2					      END_LEVEL	_103_Adin
      1  49a2		       00 4b	   LEVEL_SIZE__103_Adin =	* - LEVEL_START
      2  49a2				  -	      IF	LEVEL_SIZE__103_Adin > MAX_LEVEL_SIZE
      3  49a2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Adin
      4  49a2					      ENDIF
     90  49a2
     91  49a2							;  #######___
     92  49a2							;  #	  #___
     93  49a2							;  #	$$#___
     94  49a2							;  #.*  .#___
     95  49a2							;  #$*$#*###_
     96  49a2							;  #@*... .#_
     97  49a2							;  #####$ .##
     98  49a2							;  ___# $ $ #
     99  49a2							;  ___#     #
    100  49a2							;  ___#######	(_ = modified by boo from wall)
    101  49a2
      0  49a2					      START_LEVEL	_103_Ajalae
      1  49a2				   LEVEL_START SET	*
      2  49a2		       00 09	   BANK_LEVEL__103_Ajalae =	_CURRENT_BANK
      3  49a2				   LEVEL__103_Ajalae SUBROUTINE
      4  49a2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  49a2
    103  49a2		       37 23 7c 23*	      .byte.b	"7#|#5-#|#3-2$#|#.*2-.#|#$*$#*3#|#@*3.-.#|5#$-.2#|3-#-$-$-#|3-#5-#|3-7#",0
      0  49e9					      END_LEVEL	_103_Ajalae
      1  49e9		       00 47	   LEVEL_SIZE__103_Ajalae =	* - LEVEL_START
      2  49e9				  -	      IF	LEVEL_SIZE__103_Ajalae > MAX_LEVEL_SIZE
      3  49e9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Ajalae
      4  49e9					      ENDIF
    105  49e9
    106  49e9							;  ############
    107  49e9							;  #@#  #     #
    108  49e9							;  #  # #$#$# #
    109  49e9							;  # *$       #
    110  49e9							;  #..##$#$   #
    111  49e9							;  #..#. #  $ #
    112  49e9							;  #....# $$$##
    113  49e9							;  #	       #
    114  49e9							;  ############
    115  49e9
      0  49e9					      START_LEVEL	_103_Arielle
      1  49e9				   LEVEL_START SET	*
      2  49e9		       00 09	   BANK_LEVEL__103_Arielle =	_CURRENT_BANK
      3  49e9				   LEVEL__103_Arielle SUBROUTINE
      4  49e9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  49e9
    117  49e9		       31 32 23 7c*	      .byte.b	"12#|#@#2-#5-#|#2-#-#$#$#-#|#-*$7-#|#2.2#$#$3-#|#2.#.-#2-$-#|#4.#-3$2#|#10-#|12#",0
      0  4a39					      END_LEVEL	_103_Arielle
      1  4a39		       00 50	   LEVEL_SIZE__103_Arielle =	* - LEVEL_START
      2  4a39				  -	      IF	LEVEL_SIZE__103_Arielle > MAX_LEVEL_SIZE
      3  4a39				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Arielle
      4  4a39					      ENDIF
    119  4a39
    120  4a39
    121  4a39
      0  4a39					      START_LEVEL	_1XJH_Tara_Gelson
      1  4a39				   LEVEL_START SET	*
      2  4a39		       00 09	   BANK_LEVEL__1XJH_Tara_Gelson =	_CURRENT_BANK
      3  4a39				   LEVEL__1XJH_Tara_Gelson SUBROUTINE
      4  4a39				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4a39
    123  4a39		       38 23 7c 23*	      .byte.b	"8#|#2-#2-*#|#2-*-*-#|#-*$-$-#|#2-.#.-#|#3-#-*#|2#-@3-#|8#",0
      0  4a73					      END_LEVEL	_1XJH_Tara_Gelson
      1  4a73		       00 3a	   LEVEL_SIZE__1XJH_Tara_Gelson =	* - LEVEL_START
      2  4a73				  -	      IF	LEVEL_SIZE__1XJH_Tara_Gelson > MAX_LEVEL_SIZE
      3  4a73				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1XJH_Tara_Gelson
      4  4a73					      ENDIF
    125  4a73
      0  4a73					      START_LEVEL	_1R7X_Alison
      1  4a73				   LEVEL_START SET	*
      2  4a73		       00 09	   BANK_LEVEL__1R7X_Alison =	_CURRENT_BANK
      3  4a73				   LEVEL__1R7X_Alison SUBROUTINE
      4  4a73				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4a73
    127  4a73		       37 23 7c 23*	      .byte.b	"7#|#2-.2-#|#-$*2$#|#-2.$.#|#@*-$-#|2#.3-#|7#",0
      0  4aa0					      END_LEVEL	_1R7X_Alison
      1  4aa0		       00 2d	   LEVEL_SIZE__1R7X_Alison =	* - LEVEL_START
      2  4aa0				  -	      IF	LEVEL_SIZE__1R7X_Alison > MAX_LEVEL_SIZE
      3  4aa0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1R7X_Alison
      4  4aa0					      ENDIF
    129  4aa0
      0  4aa0					      START_LEVEL	_1KWD_Cecile_Clayworth
      1  4aa0				   LEVEL_START SET	*
      2  4aa0		       00 09	   BANK_LEVEL__1KWD_Cecile_Clayworth =	_CURRENT_BANK
      3  4aa0				   LEVEL__1KWD_Cecile_Clayworth SUBROUTINE
      4  4aa0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4aa0
    131  4aa0		       38 23 7c 33*	      .byte.b	"8#|3#.2-.#|#-$4-#|#-*2#2$#|#3-$-+#|#-*.-*-#|#6-#|8#",0
      0  4ad4					      END_LEVEL	_1KWD_Cecile_Clayworth
      1  4ad4		       00 34	   LEVEL_SIZE__1KWD_Cecile_Clayworth =	* - LEVEL_START
      2  4ad4				  -	      IF	LEVEL_SIZE__1KWD_Cecile_Clayworth > MAX_LEVEL_SIZE
      3  4ad4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1KWD_Cecile_Clayworth
      4  4ad4					      ENDIF
    133  4ad4
      0  4ad4					      START_LEVEL	_1EKT_Samantha_Gelson
      1  4ad4				   LEVEL_START SET	*
      2  4ad4		       00 09	   BANK_LEVEL__1EKT_Samantha_Gelson =	_CURRENT_BANK
      3  4ad4				   LEVEL__1EKT_Samantha_Gelson SUBROUTINE
      4  4ad4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4ad4
    135  4ad4		       38 23 7c 23*	      .byte.b	"8#|#-*3-.#|#2-$-*-#|#-.$-$-#|#*-*2-*#|#.#-#2-#|#4-@-#|8#",0
      0  4b0d					      END_LEVEL	_1EKT_Samantha_Gelson
      1  4b0d		       00 39	   LEVEL_SIZE__1EKT_Samantha_Gelson =	* - LEVEL_START
      2  4b0d				  -	      IF	LEVEL_SIZE__1EKT_Samantha_Gelson > MAX_LEVEL_SIZE
      3  4b0d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1EKT_Samantha_Gelson
      4  4b0d					      ENDIF
    137  4b0d
      0  4b0d					      START_LEVEL	_0VM5_Andrea_Wadd
      1  4b0d				   LEVEL_START SET	*
      2  4b0d		       00 09	   BANK_LEVEL__0VM5_Andrea_Wadd =	_CURRENT_BANK
      3  4b0d				   LEVEL__0VM5_Andrea_Wadd SUBROUTINE
      4  4b0d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b0d
    139  4b0d		       37 23 7c 23*	      .byte.b	"7#|#3-#-#|#-$*2-#|#-.-+-#|#-*2$-#|2#2-.-#|7#",0
      0  4b3a					      END_LEVEL	_0VM5_Andrea_Wadd
      1  4b3a		       00 2d	   LEVEL_SIZE__0VM5_Andrea_Wadd =	* - LEVEL_START
      2  4b3a				  -	      IF	LEVEL_SIZE__0VM5_Andrea_Wadd > MAX_LEVEL_SIZE
      3  4b3a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0VM5_Andrea_Wadd
      4  4b3a					      ENDIF
    141  4b3a
      0  4b3a					      START_LEVEL	_0PAL_Jill_Leatherby
      1  4b3a				   LEVEL_START SET	*
      2  4b3a		       00 09	   BANK_LEVEL__0PAL_Jill_Leatherby =	_CURRENT_BANK
      3  4b3a				   LEVEL__0PAL_Jill_Leatherby SUBROUTINE
      4  4b3a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b3a
    143  4b3a		       37 23 7c 23*	      .byte.b	"7#|#3-3#|#2-2*-#|#3-$-#|#2-$2.#|3#@2-#|7#",0
      0  4b64					      END_LEVEL	_0PAL_Jill_Leatherby
      1  4b64		       00 2a	   LEVEL_SIZE__0PAL_Jill_Leatherby =	* - LEVEL_START
      2  4b64				  -	      IF	LEVEL_SIZE__0PAL_Jill_Leatherby > MAX_LEVEL_SIZE
      3  4b64				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0PAL_Jill_Leatherby
      4  4b64					      ENDIF
    145  4b64
      0  4b64					      START_LEVEL	_0IZ1_Sophia
      1  4b64				   LEVEL_START SET	*
      2  4b64		       00 09	   BANK_LEVEL__0IZ1_Sophia =	_CURRENT_BANK
      3  4b64				   LEVEL__0IZ1_Sophia SUBROUTINE
      4  4b64				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b64
    147  4b64		       37 23 7c 23*	      .byte.b	"7#|#5-#|#@$.#-#|#*$2-.#|#-2$2-#|#-.-.-#|7#",0
      0  4b8f					      END_LEVEL	_0IZ1_Sophia
      1  4b8f		       00 2b	   LEVEL_SIZE__0IZ1_Sophia =	* - LEVEL_START
      2  4b8f				  -	      IF	LEVEL_SIZE__0IZ1_Sophia > MAX_LEVEL_SIZE
      3  4b8f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0IZ1_Sophia
      4  4b8f					      ENDIF
    149  4b8f
      0  4b8f					      START_LEVEL	_0CNH_Alice
      1  4b8f				   LEVEL_START SET	*
      2  4b8f		       00 09	   BANK_LEVEL__0CNH_Alice =	_CURRENT_BANK
      3  4b8f				   LEVEL__0CNH_Alice SUBROUTINE
      4  4b8f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4b8f
    151  4b8f		       37 23 7c 23*	      .byte.b	"7#|#.4-#|#$*-#-#|#.2-$*#|#-.$2-#|#@-*2-#|7#",0
      0  4bbb					      END_LEVEL	_0CNH_Alice
      1  4bbb		       00 2c	   LEVEL_SIZE__0CNH_Alice =	* - LEVEL_START
      2  4bbb				  -	      IF	LEVEL_SIZE__0CNH_Alice > MAX_LEVEL_SIZE
      3  4bbb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0CNH_Alice
      4  4bbb					      ENDIF
    153  4bbb
    154  4bbb							;  START_LEVEL TowC
    155  4bbb							;   .byte "4-5#|4-#3-#|4-#$2-#|2-3#2-$2#|2-#2-$-$-#|3#-#-2#-#3-6#|#3-#-2#-5#2-2.#|#-$2-$10-2.#|5#-3#-#@2#2-2.#|4-#5-9#|4-7#",0
    156  4bbb							;  END_LEVEL TowC
    157  4bbb
    158  4bbb							;  START_LEVEL SimpleC
    159  4bbb							;  .byte "7#|#.@-#-#|#$*-$-#|#3-$-#|#-..--#|#--*--#|7#",0
    160  4bbb							;  END_LEVEL SimpleC
    161  4bbb
      0  4bbb					      START_LEVEL	bAlfa_DrFogh
      1  4bbb				   LEVEL_START SET	*
      2  4bbb		       00 09	   BANK_LEVEL_bAlfa_DrFogh =	_CURRENT_BANK
      3  4bbb				   LEVEL_bAlfa_DrFogh SUBROUTINE
      4  4bbb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4bbb
    163  4bbb		       32 2d 34 23*	      .byte.b	"2-4#2-4#|-2#2-2#-#2-#|-#4-3#2-2#|2#2-2*2-#.2-2#|#2-*2-*-#*#2-#|#-*4-2*2-#-#|#-*-2#-*3-#-#|2#-*2-*#*#-#-#|-#$-2*-#-*-#-#|-#@#2-2#5-#|-2#2-4#2-3#|2-#2-#2-4#|2-#2-#|2-4#",0
      0  4c62					      END_LEVEL	bAlfa_DrFogh
      1  4c62		       00 a7	   LEVEL_SIZE_bAlfa_DrFogh =	* - LEVEL_START
      2  4c62					      IF	LEVEL_SIZE_bAlfa_DrFogh > MAX_LEVEL_SIZE
      3  4c62				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAlfa_DrFogh
      4  4c62					      ENDIF
    165  4c62
      0  4c62					      START_LEVEL	b51X_Sharpen
      1  4c62				   LEVEL_START SET	*
      2  4c62		       00 09	   BANK_LEVEL_b51X_Sharpen =	_CURRENT_BANK
      3  4c62				   LEVEL_b51X_Sharpen SUBROUTINE
      4  4c62				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4c62
    167  4c62		       2d 39 23 33*	      .byte.b	"-9#3-|-#7-#3-|-#-$-2$-$#3-|3#$#2-$-#3-|#.#3-2$-2#2-|#.3#3-$-#2-|#.#.-$-2#-3#|#3.$-$2#-$-#|#3.$3-$2-@#|#2.3#$3#-2#|#4.#5-#-|12#-",0
      0  4ce2					      END_LEVEL	b51X_Sharpen
      1  4ce2		       00 80	   LEVEL_SIZE_b51X_Sharpen =	* - LEVEL_START
      2  4ce2				  -	      IF	LEVEL_SIZE_b51X_Sharpen > MAX_LEVEL_SIZE
      3  4ce2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_b51X_Sharpen
      4  4ce2					      ENDIF
    169  4ce2
      0  4ce2					      START_LEVEL	bDarcy_Burnsell101
      1  4ce2				   LEVEL_START SET	*
      2  4ce2		       00 09	   BANK_LEVEL_bDarcy_Burnsell101 =	_CURRENT_BANK
      3  4ce2				   LEVEL_bDarcy_Burnsell101 SUBROUTINE
      4  4ce2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4ce2
    171  4ce2		       38 23 7c 23*	      .byte.b	"8#|#2-.-$@#|#.#$*2$#|#2-.-*-#|#2$-2$.#|#.#-#2-#|#.2-.-.#|8#",0
      0  4d1e					      END_LEVEL	bDarcy_Burnsell101
      1  4d1e		       00 3c	   LEVEL_SIZE_bDarcy_Burnsell101 =	* - LEVEL_START
      2  4d1e				  -	      IF	LEVEL_SIZE_bDarcy_Burnsell101 > MAX_LEVEL_SIZE
      3  4d1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bDarcy_Burnsell101
      4  4d1e					      ENDIF
    173  4d1e
      0  4d1e					      START_LEVEL	bAislin101
      1  4d1e				   LEVEL_START SET	*
      2  4d1e		       00 09	   BANK_LEVEL_bAislin101 =	_CURRENT_BANK
      3  4d1e				   LEVEL_bAislin101 SUBROUTINE
      4  4d1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4d1e
    175  4d1e		       38 23 7c 32*	      .byte.b	"8#|2#-*-*.#|#2.$-$*#|#-.#-*.#|2#-$-$2#|#-#$-$-#|#2.2-$@#|8#",0
      0  4d5a					      END_LEVEL	bAislin101
      1  4d5a		       00 3c	   LEVEL_SIZE_bAislin101 =	* - LEVEL_START
      2  4d5a				  -	      IF	LEVEL_SIZE_bAislin101 > MAX_LEVEL_SIZE
      3  4d5a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAislin101
      4  4d5a					      ENDIF
    177  4d5a
    178  4d5a							;  START_LEVEL b82X_Sharpen
    179  4d5a							;  .byte "-11#8-|-#5-#3-2#7-|-#-$-$-$-#2-5#3-|-3#2-5#5-#3-|-#4.#5-3#-#3-|-#.4#2-4#3-#3-|-#4.4-#2-$-2#3-|-#-3.#3-#-3$5#|3#.7#2-$@$3-#|#-$3-5#-$-2#3-#|#-#.#-$6-$3#$-#|#-#.8#2-#2-$-#|#-#3.7-2#-2$-#|#3-7#-$-#-#2-#|5#5-#7-2#|10-9#-",0
    180  4d5a							;  END_LEVEL b82X_Sharpen
    181  4d5a
      0  4d5a					      START_LEVEL	Thomas_Reinke16
      1  4d5a				   LEVEL_START SET	*
      2  4d5a		       00 09	   BANK_LEVEL_Thomas_Reinke16 =	_CURRENT_BANK
      3  4d5a				   LEVEL_Thomas_Reinke16 SUBROUTINE
      4  4d5a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  4d5a
    183  4d5a		       2d 35 23 7c*	      .byte.b	"-5#|2#3-3#|#6-2#|#-#-2#2-#|#2.*2-#-#|#2-*2-#-#|3#*2$2-#|2-#@-4#|2-4#",0
      0  4d9f					      END_LEVEL	Thomas_Reinke16
      1  4d9f		       00 45	   LEVEL_SIZE_Thomas_Reinke16 =	* - LEVEL_START
      2  4d9f				  -	      IF	LEVEL_SIZE_Thomas_Reinke16 > MAX_LEVEL_SIZE
      3  4d9f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_Thomas_Reinke16
      4  4d9f					      ENDIF
    185  4d9f
    186  4d9f							;Level element	Character	ASCII Code
    187  4d9f							;Wall	#	0x23
    188  4d9f							;Player	@	0x40
    189  4d9f							;Player on goal square	+	0x2b
    190  4d9f							;Box	$	0x24
    191  4d9f							;Box on goal square	*	0x2a
    192  4d9f							;Goal square	.	0x2e
    193  4d9f							;Floor	(Space)	0x20 or underscore
    194  4d9f
    195  4d9f							;This level ("Claire", by Lee J Haywood):
    196  4d9f
    197  4d9f							;#######
    198  4d9f							;#.@ # #
    199  4d9f							;#$* $ #
    200  4d9f							;#   $ #
    201  4d9f							;# ..	#
    202  4d9f							;#  *	#
    203  4d9f							;#######
    204  4d9f							;runlength encoded looks like this:
    205  4d9f
    206  4d9f							;The rows of the level are separated by "|"s. There has been a discussion in the Yahoo Group about what character should represent an empty square in May 2006. Finally the hyphen has been elected to be the standard character for an empty square. Nevertheless, programs are encouraged to support both, hyphens and underscores.
    207  4d9f
    208  4d9f							;If only two level elements are grouped together they may be run length encoded, but needn't to. Example:
    209  4d9f
    210  4d9f
      0  4d9f					      CHECK_BANK_SIZE	"LEVELS6 -- full 2K"
      1  4d9f		       05 9f	   .TEMP      =	* - BANK_START
 LEVELS6 -- full 2K (2K) SIZE =  $59f , FREE= $261
      2  4d9f					      ECHO	"LEVELS6 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4d9f				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4d9f				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4d9f				  -	      ERR
      6  4d9f					      endif
------- FILE ./sokoboo.asm
------- FILE titleScreen.asm LEVEL 2 PASS 4
      0  4d9f					      include	"titleScreen.asm"
      0  4d9f					      NEWBANK	TITLESCREEN
      1  546b ????				      SEG	TITLESCREEN
      2  5000					      ORG	ORIGIN
      3  5000					      RORG	$F000
      4  5000				   BANK_START SET	*
      5  5000				   TITLESCREEN SET	ORIGIN / 2048
      6  5000				   ORIGIN     SET	ORIGIN + 2048
      7  5000				   _CURRENT_BANK SET	TITLESCREEN
      0  5000					      DEFINE_SUBROUTINE	TitleScreen
      1  5000		       00 0a	   BANK_TitleScreen =	_CURRENT_BANK
      2  5000					      SUBROUTINE
      3  5000				   TitleScreen
      3  5000
      4  5000							; Start of new frame
      5  5000
      6  5000							; Start of vertical blank processing
      7  5000
      8  5000				   TitleSequence
      9  5000
     10  5000		       a9 00		      lda	#%00000000
     11  5002		       85 4a		      sta	CTRLPF
     12  5004		       85 49		      sta	COLUBK
     13  5006
     14  5006		       a6 81		      ldx	Platform
     15  5008		       bd a7 f0 	      lda	colvec,x
     16  500b		       85 dc		      sta	colour_table
     17  500d		       bd a8 f0 	      lda	colvec+1,x
     18  5010		       85 dd		      sta	colour_table+1
     19  5012
      0  5012					      RESYNC
      1  5012
      2  5012		       a9 02		      lda	#%10
      3  5014		       85 41		      sta	VBLANK
      4  5016
      5  5016		       a2 08		      ldx	#8
      6  5018				   .loopResync
      0  5018					      VERTICAL_SYNC
      1  5018		       a9 0e		      lda	#%1110
      2  501a		       85 42	   .VSLP1     sta	WSYNC
      3  501c		       85 40		      sta	VSYNC
      4  501e		       4a		      lsr
      5  501f		       d0 f9		      bne	.VSLP1
      8  5021
      9  5021		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  5023		       a5 81		      lda	Platform
     11  5025		       49 02		      eor	#PAL_50
     12  5027		       d0 02		      bne	.ntsc
     13  5029		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  502b				   .ntsc
     15  502b				   .loopWait
     16  502b		       85 42		      sta	WSYNC
     17  502d		       85 42		      sta	WSYNC
     18  502f		       88		      dey
     19  5030		       d0 f9		      bne	.loopWait
     20  5032		       ca		      dex
     21  5033		       d0 e3		      bne	.loopResync
     21  5035
     22  5035				   RestartFrame
     23  5035		       a9 0e		      lda	#%1110	; VSYNC ON
     24  5037		       85 42	   .loopVSync2 sta	WSYNC
     25  5039		       85 40		      sta	VSYNC
     26  503b		       4a		      lsr
     27  503c		       d0 f9		      bne	.loopVSync2	; branch until VYSNC has been reset
     28  503e
     29  503e							;------------------------------------------------------------------
     30  503e
     31  503e		       a6 81		      ldx	Platform
     32  5040		       bc 65 fc 	      ldy	VBlankTime,x
     33  5043		       8c 96 02 	      sty	TIM64T
     34  5046
     35  5046		       85 42	   VerticalBlank sta	WSYNC
     36  5048		       ad 84 02 	      lda	INTIM
     37  504b		       d0 f9		      bne	VerticalBlank
     38  504d		       85 41		      sta	VBLANK
     39  504f
     40  504f
     41  504f							;------------------------------------------------------------------
     42  504f
     43  504f							; Do X scanlines of color-changing (our picture)
     44  504f
     45  504f		       a0 77		      ldy	#119	; this counts our scanline number
     46  5051		       a2 03	   SokoLogo   ldx	#3
     47  5053		       b1 dc	   triplet    lda	(colour_table),y
     48  5055		       85 42		      sta	WSYNC
     49  5057		       85 48		      sta	COLUPF	; 3
     50  5059
     51  5059		       b9 9b f1 	      lda	COL_0,y	; 5
     52  505c		       85 4d		      sta	PF0	; 3   @11
     53  505e		       b9 13 f2 	      lda	COL_1,y	; 5
     54  5061		       85 4e		      sta	PF1	; 3   @19
     55  5063		       b9 8b f2 	      lda	COL_2,y	; 5
     56  5066		       85 4f		      sta	PF2	; 3   @27
     57  5068
     58  5068		       b9 03 f3 	      lda	COL_3,y	; 5
     59  506b		       85 4d		      sta	PF0	; 3   @35
      0  506d					      SLEEP	2	; @37
      1  506d				   .CYCLES    SET	2
      2  506d
      3  506d				  -	      IF	.CYCLES < 2
      4  506d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  506d				  -	      ERR
      6  506d					      ENDIF
      7  506d
      8  506d				  -	      IF	.CYCLES & 1
      9  506d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  506d				  -	      nop	0
     11  506d				  -	      ELSE
     12  506d				  -	      bit	VSYNC
     13  506d				  -	      ENDIF
     14  506d				  -.CYCLES    SET	.CYCLES - 3
     15  506d					      ENDIF
     16  506d
     17  506d					      REPEAT	.CYCLES / 2
     18  506d		       ea		      nop
     19  506e					      REPEND
     61  506e		       b9 7b f3 	      lda	COL_4,y	; 5
     62  5071		       85 4e		      sta	PF1	; 3   @45
      0  5073					      SLEEP	3	; @45
      1  5073				   .CYCLES    SET	3
      2  5073
      3  5073				  -	      IF	.CYCLES < 2
      4  5073				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  5073				  -	      ERR
      6  5073					      ENDIF
      7  5073
      8  5073					      IF	.CYCLES & 1
      9  5073					      IFNCONST	NO_ILLEGAL_OPCODES
     10  5073		       04 00		      nop	0
     11  5075				  -	      ELSE
     12  5075				  -	      bit	VSYNC
     13  5075					      ENDIF
     14  5075				   .CYCLES    SET	.CYCLES - 3
     15  5075					      ENDIF
     16  5075
     17  5075				  -	      REPEAT	.CYCLES / 2
     18  5075				  -	      nop
     19  5075					      REPEND
     64  5075		       b9 f3 f3 	      lda	COL_5,y	; 5
     65  5078		       85 4f		      sta	PF2	; 3
     66  507a
     67  507a		       88		      dey		; 2
     68  507b		       ca		      dex		; 2
     69  507c		       d0 d5		      bne	triplet	; 2(3)
     70  507e
     71  507e		       c0 ff		      cpy	#-1	; 2
     72  5080		       d0 cf		      bne	SokoLogo	; 2(3)
     73  5082
     74  5082		       a9 00		      lda	#0
     75  5084		       85 4d		      sta	PF0
     76  5086		       85 4e		      sta	PF1
     77  5088		       85 4f		      sta	PF2
     78  508a
     79  508a		       a6 81		      ldx	Platform
     80  508c		       bd a3 f0 	      lda	OverscanTime2,x
     81  508f		       8d 96 02 	      sta	TIM64T
     82  5092
     83  5092				  -	      if	0
     84  5092				  -	      sta	WSYNC
     85  5092				  -	      sta	WSYNC
     86  5092				  -	      sta	WSYNC
     87  5092				  -	      sta	WSYNC
     88  5092				  -	      sta	WSYNC
     89  5092				  -	      SLEEP	8
     90  5092				  -	      jsr	SokoScreen
     91  5092				  -
     92  5092				  -	      lda	#0
     93  5092				  -	      sta	BoardScrollX
     94  5092				  -	      sta	BoardScrollY
     95  5092					      endif
     96  5092
     97  5092							;		ldy #63
     98  5092							;bot2		 sta WSYNC
     99  5092							;		dey
    100  5092							;		bpl bot2
    101  5092
    102  5092							;--------------------------------------------------------------------------
    103  5092
    104  5092							;		lda #0
    105  5092							;		sta PF0
    106  5092							;		sta PF1
    107  5092							;		sta PF2
    108  5092
    109  5092
    110  5092
    111  5092							; D1 VBLANK turns off beam
    112  5092							; It needs to be turned on 37 scanlines later
    113  5092
    114  5092				   oscan
    115  5092		       ad 84 02 	      lda	INTIM
    116  5095		       d0 fb		      bne	oscan
    117  5097
    118  5097		       a9 42		      lda	#%01000010	; bit6 is not required
    119  5099		       85 41		      sta	VBLANK	; end of screen - enter blanking
    120  509b
    121  509b		       a5 4c		      lda	INPT4
    122  509d		       10 03		      bpl	ret
    123  509f
    124  509f		       4c 35 f0 	      jmp	RestartFrame
    125  50a2
    126  50a2		       60	   ret	      rts
    127  50a3
    128  50a3				   OverscanTime2
    129  50a3		       83 83		      .byte.b	131, 131
    130  50a5		       8b 8b		      .byte.b	139, 139
    131  50a7
    132  50a7				   colvec
    133  50a7		       23 f1 ab f0	      .word.w	colr_ntsc, colr_pal
    134  50ab
    135  50ab
    136  50ab					      MAC	lumtable
    137  50ab							; {4} MIN LUM 1
    138  50ab							; {5} MIN LUM 2
    139  50ab							; {6} MIN LUM 3
    140  50ab
    141  50ab				   .LUM1      SET	{4}
    142  50ab				   .LUM2      SET	{5}
    143  50ab				   .LUM3      SET	{6}
    144  50ab
    145  50ab				   .STEP1     =	256*($C-{4})/8
    146  50ab				   .STEP2     =	256*($C-{5})/8
    147  50ab				   .STEP3     =	256*($C-{6})/8
    148  50ab
    149  50ab					      REPEAT	8
    150  50ab					      REPEAT	5
    151  50ab					      .byte	{1}+{4}+(.LUM1/256/5)
    152  50ab					      .byte	{2}+{5}+(.LUM2/256/5)
    153  50ab					      .byte	{3}+{6}+(.LUM3/256/5)
    154  50ab				   .LUM1      SET	.LUM1 + .STEP1
    155  50ab				   .LUM2      SET	.LUM2 + .STEP2
    156  50ab				   .LUM3      SET	.LUM3 + .STEP3
    157  50ab					      REPEND
    158  50ab					      REPEND
    159  50ab					      ENDM		;{1}{2}{3} base colours
    160  50ab
      0  50ab				   colr_pal   LUMTABLE	$b0,$60,$50,0,8,4	;2,4,6
      1  50ab
      2  50ab
      3  50ab
      4  50ab
      5  50ab				   .LUM1      SET	0
      6  50ab				   .LUM2      SET	8
      7  50ab				   .LUM3      SET	4
      8  50ab
      9  50ab		       01 80	   .STEP1     =	256*($C-0)/8
     10  50ab		       00 80	   .STEP2     =	256*($C-8)/8
     11  50ab		       01 00	   .STEP3     =	256*($C-4)/8
     12  50ab
     13  50ab					      REPEAT	8
     14  50ab					      REPEAT	5
     15  50ab		       b0		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50ac		       68		      .byte.b	$60+8+(.LUM2/256/5)
     17  50ad		       54		      .byte.b	$50+4+(.LUM3/256/5)
     18  50ad				   .LUM1      SET	.LUM1 + .STEP1
     19  50ad				   .LUM2      SET	.LUM2 + .STEP2
     20  50ad				   .LUM3      SET	.LUM3 + .STEP3
     14  50ad					      REPEND
     15  50ae		       b0		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50af		       68		      .byte.b	$60+8+(.LUM2/256/5)
     17  50b0		       54		      .byte.b	$50+4+(.LUM3/256/5)
     18  50b0				   .LUM1      SET	.LUM1 + .STEP1
     19  50b0				   .LUM2      SET	.LUM2 + .STEP2
     20  50b0				   .LUM3      SET	.LUM3 + .STEP3
     14  50b0					      REPEND
     15  50b1		       b0		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50b2		       68		      .byte.b	$60+8+(.LUM2/256/5)
     17  50b3		       54		      .byte.b	$50+4+(.LUM3/256/5)
     18  50b3				   .LUM1      SET	.LUM1 + .STEP1
     19  50b3				   .LUM2      SET	.LUM2 + .STEP2
     20  50b3				   .LUM3      SET	.LUM3 + .STEP3
     14  50b3					      REPEND
     15  50b4		       b0		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50b5		       68		      .byte.b	$60+8+(.LUM2/256/5)
     17  50b6		       54		      .byte.b	$50+4+(.LUM3/256/5)
     18  50b6				   .LUM1      SET	.LUM1 + .STEP1
     19  50b6				   .LUM2      SET	.LUM2 + .STEP2
     20  50b6				   .LUM3      SET	.LUM3 + .STEP3
     14  50b6					      REPEND
     15  50b7		       b1		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50b8		       68		      .byte.b	$60+8+(.LUM2/256/5)
     17  50b9		       54		      .byte.b	$50+4+(.LUM3/256/5)
     18  50b9				   .LUM1      SET	.LUM1 + .STEP1
     19  50b9				   .LUM2      SET	.LUM2 + .STEP2
     20  50b9				   .LUM3      SET	.LUM3 + .STEP3
     21  50ba					      REPEND
     13  50ba					      REPEND
     14  50ba					      REPEAT	5
     15  50ba		       b1		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50bb		       68		      .byte.b	$60+8+(.LUM2/256/5)
     17  50bc		       55		      .byte.b	$50+4+(.LUM3/256/5)
     18  50bc				   .LUM1      SET	.LUM1 + .STEP1
     19  50bc				   .LUM2      SET	.LUM2 + .STEP2
     20  50bc				   .LUM3      SET	.LUM3 + .STEP3
     14  50bc					      REPEND
     15  50bd		       b1		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50be		       68		      .byte.b	$60+8+(.LUM2/256/5)
     17  50bf		       55		      .byte.b	$50+4+(.LUM3/256/5)
     18  50bf				   .LUM1      SET	.LUM1 + .STEP1
     19  50bf				   .LUM2      SET	.LUM2 + .STEP2
     20  50bf				   .LUM3      SET	.LUM3 + .STEP3
     14  50bf					      REPEND
     15  50c0		       b2		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50c1		       68		      .byte.b	$60+8+(.LUM2/256/5)
     17  50c2		       55		      .byte.b	$50+4+(.LUM3/256/5)
     18  50c2				   .LUM1      SET	.LUM1 + .STEP1
     19  50c2				   .LUM2      SET	.LUM2 + .STEP2
     20  50c2				   .LUM3      SET	.LUM3 + .STEP3
     14  50c2					      REPEND
     15  50c3		       b2		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50c4		       68		      .byte.b	$60+8+(.LUM2/256/5)
     17  50c5		       55		      .byte.b	$50+4+(.LUM3/256/5)
     18  50c5				   .LUM1      SET	.LUM1 + .STEP1
     19  50c5				   .LUM2      SET	.LUM2 + .STEP2
     20  50c5				   .LUM3      SET	.LUM3 + .STEP3
     14  50c5					      REPEND
     15  50c6		       b2		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50c7		       68		      .byte.b	$60+8+(.LUM2/256/5)
     17  50c8		       55		      .byte.b	$50+4+(.LUM3/256/5)
     18  50c8				   .LUM1      SET	.LUM1 + .STEP1
     19  50c8				   .LUM2      SET	.LUM2 + .STEP2
     20  50c8				   .LUM3      SET	.LUM3 + .STEP3
     21  50c9					      REPEND
     13  50c9					      REPEND
     14  50c9					      REPEAT	5
     15  50c9		       b3		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50ca		       69		      .byte.b	$60+8+(.LUM2/256/5)
     17  50cb		       56		      .byte.b	$50+4+(.LUM3/256/5)
     18  50cb				   .LUM1      SET	.LUM1 + .STEP1
     19  50cb				   .LUM2      SET	.LUM2 + .STEP2
     20  50cb				   .LUM3      SET	.LUM3 + .STEP3
     14  50cb					      REPEND
     15  50cc		       b3		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50cd		       69		      .byte.b	$60+8+(.LUM2/256/5)
     17  50ce		       56		      .byte.b	$50+4+(.LUM3/256/5)
     18  50ce				   .LUM1      SET	.LUM1 + .STEP1
     19  50ce				   .LUM2      SET	.LUM2 + .STEP2
     20  50ce				   .LUM3      SET	.LUM3 + .STEP3
     14  50ce					      REPEND
     15  50cf		       b3		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50d0		       69		      .byte.b	$60+8+(.LUM2/256/5)
     17  50d1		       56		      .byte.b	$50+4+(.LUM3/256/5)
     18  50d1				   .LUM1      SET	.LUM1 + .STEP1
     19  50d1				   .LUM2      SET	.LUM2 + .STEP2
     20  50d1				   .LUM3      SET	.LUM3 + .STEP3
     14  50d1					      REPEND
     15  50d2		       b3		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50d3		       69		      .byte.b	$60+8+(.LUM2/256/5)
     17  50d4		       56		      .byte.b	$50+4+(.LUM3/256/5)
     18  50d4				   .LUM1      SET	.LUM1 + .STEP1
     19  50d4				   .LUM2      SET	.LUM2 + .STEP2
     20  50d4				   .LUM3      SET	.LUM3 + .STEP3
     14  50d4					      REPEND
     15  50d5		       b4		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50d6		       69		      .byte.b	$60+8+(.LUM2/256/5)
     17  50d7		       56		      .byte.b	$50+4+(.LUM3/256/5)
     18  50d7				   .LUM1      SET	.LUM1 + .STEP1
     19  50d7				   .LUM2      SET	.LUM2 + .STEP2
     20  50d7				   .LUM3      SET	.LUM3 + .STEP3
     21  50d8					      REPEND
     13  50d8					      REPEND
     14  50d8					      REPEAT	5
     15  50d8		       b4		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50d9		       69		      .byte.b	$60+8+(.LUM2/256/5)
     17  50da		       57		      .byte.b	$50+4+(.LUM3/256/5)
     18  50da				   .LUM1      SET	.LUM1 + .STEP1
     19  50da				   .LUM2      SET	.LUM2 + .STEP2
     20  50da				   .LUM3      SET	.LUM3 + .STEP3
     14  50da					      REPEND
     15  50db		       b4		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50dc		       69		      .byte.b	$60+8+(.LUM2/256/5)
     17  50dd		       57		      .byte.b	$50+4+(.LUM3/256/5)
     18  50dd				   .LUM1      SET	.LUM1 + .STEP1
     19  50dd				   .LUM2      SET	.LUM2 + .STEP2
     20  50dd				   .LUM3      SET	.LUM3 + .STEP3
     14  50dd					      REPEND
     15  50de		       b5		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50df		       69		      .byte.b	$60+8+(.LUM2/256/5)
     17  50e0		       57		      .byte.b	$50+4+(.LUM3/256/5)
     18  50e0				   .LUM1      SET	.LUM1 + .STEP1
     19  50e0				   .LUM2      SET	.LUM2 + .STEP2
     20  50e0				   .LUM3      SET	.LUM3 + .STEP3
     14  50e0					      REPEND
     15  50e1		       b5		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50e2		       69		      .byte.b	$60+8+(.LUM2/256/5)
     17  50e3		       57		      .byte.b	$50+4+(.LUM3/256/5)
     18  50e3				   .LUM1      SET	.LUM1 + .STEP1
     19  50e3				   .LUM2      SET	.LUM2 + .STEP2
     20  50e3				   .LUM3      SET	.LUM3 + .STEP3
     14  50e3					      REPEND
     15  50e4		       b5		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50e5		       69		      .byte.b	$60+8+(.LUM2/256/5)
     17  50e6		       57		      .byte.b	$50+4+(.LUM3/256/5)
     18  50e6				   .LUM1      SET	.LUM1 + .STEP1
     19  50e6				   .LUM2      SET	.LUM2 + .STEP2
     20  50e6				   .LUM3      SET	.LUM3 + .STEP3
     21  50e7					      REPEND
     13  50e7					      REPEND
     14  50e7					      REPEAT	5
     15  50e7		       b6		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50e8		       6a		      .byte.b	$60+8+(.LUM2/256/5)
     17  50e9		       58		      .byte.b	$50+4+(.LUM3/256/5)
     18  50e9				   .LUM1      SET	.LUM1 + .STEP1
     19  50e9				   .LUM2      SET	.LUM2 + .STEP2
     20  50e9				   .LUM3      SET	.LUM3 + .STEP3
     14  50e9					      REPEND
     15  50ea		       b6		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50eb		       6a		      .byte.b	$60+8+(.LUM2/256/5)
     17  50ec		       58		      .byte.b	$50+4+(.LUM3/256/5)
     18  50ec				   .LUM1      SET	.LUM1 + .STEP1
     19  50ec				   .LUM2      SET	.LUM2 + .STEP2
     20  50ec				   .LUM3      SET	.LUM3 + .STEP3
     14  50ec					      REPEND
     15  50ed		       b6		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50ee		       6a		      .byte.b	$60+8+(.LUM2/256/5)
     17  50ef		       58		      .byte.b	$50+4+(.LUM3/256/5)
     18  50ef				   .LUM1      SET	.LUM1 + .STEP1
     19  50ef				   .LUM2      SET	.LUM2 + .STEP2
     20  50ef				   .LUM3      SET	.LUM3 + .STEP3
     14  50ef					      REPEND
     15  50f0		       b6		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50f1		       6a		      .byte.b	$60+8+(.LUM2/256/5)
     17  50f2		       58		      .byte.b	$50+4+(.LUM3/256/5)
     18  50f2				   .LUM1      SET	.LUM1 + .STEP1
     19  50f2				   .LUM2      SET	.LUM2 + .STEP2
     20  50f2				   .LUM3      SET	.LUM3 + .STEP3
     14  50f2					      REPEND
     15  50f3		       b7		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50f4		       6a		      .byte.b	$60+8+(.LUM2/256/5)
     17  50f5		       58		      .byte.b	$50+4+(.LUM3/256/5)
     18  50f5				   .LUM1      SET	.LUM1 + .STEP1
     19  50f5				   .LUM2      SET	.LUM2 + .STEP2
     20  50f5				   .LUM3      SET	.LUM3 + .STEP3
     21  50f6					      REPEND
     13  50f6					      REPEND
     14  50f6					      REPEAT	5
     15  50f6		       b7		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50f7		       6a		      .byte.b	$60+8+(.LUM2/256/5)
     17  50f8		       59		      .byte.b	$50+4+(.LUM3/256/5)
     18  50f8				   .LUM1      SET	.LUM1 + .STEP1
     19  50f8				   .LUM2      SET	.LUM2 + .STEP2
     20  50f8				   .LUM3      SET	.LUM3 + .STEP3
     14  50f8					      REPEND
     15  50f9		       b7		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50fa		       6a		      .byte.b	$60+8+(.LUM2/256/5)
     17  50fb		       59		      .byte.b	$50+4+(.LUM3/256/5)
     18  50fb				   .LUM1      SET	.LUM1 + .STEP1
     19  50fb				   .LUM2      SET	.LUM2 + .STEP2
     20  50fb				   .LUM3      SET	.LUM3 + .STEP3
     14  50fb					      REPEND
     15  50fc		       b8		      .byte.b	$b0+0+(.LUM1/256/5)
     16  50fd		       6a		      .byte.b	$60+8+(.LUM2/256/5)
     17  50fe		       59		      .byte.b	$50+4+(.LUM3/256/5)
     18  50fe				   .LUM1      SET	.LUM1 + .STEP1
     19  50fe				   .LUM2      SET	.LUM2 + .STEP2
     20  50fe				   .LUM3      SET	.LUM3 + .STEP3
     14  50fe					      REPEND
     15  50ff		       b8		      .byte.b	$b0+0+(.LUM1/256/5)
     16  5100		       6a		      .byte.b	$60+8+(.LUM2/256/5)
     17  5101		       59		      .byte.b	$50+4+(.LUM3/256/5)
     18  5101				   .LUM1      SET	.LUM1 + .STEP1
     19  5101				   .LUM2      SET	.LUM2 + .STEP2
     20  5101				   .LUM3      SET	.LUM3 + .STEP3
     14  5101					      REPEND
     15  5102		       b8		      .byte.b	$b0+0+(.LUM1/256/5)
     16  5103		       6a		      .byte.b	$60+8+(.LUM2/256/5)
     17  5104		       59		      .byte.b	$50+4+(.LUM3/256/5)
     18  5104				   .LUM1      SET	.LUM1 + .STEP1
     19  5104				   .LUM2      SET	.LUM2 + .STEP2
     20  5104				   .LUM3      SET	.LUM3 + .STEP3
     21  5105					      REPEND
     13  5105					      REPEND
     14  5105					      REPEAT	5
     15  5105		       b9		      .byte.b	$b0+0+(.LUM1/256/5)
     16  5106		       6b		      .byte.b	$60+8+(.LUM2/256/5)
     17  5107		       5a		      .byte.b	$50+4+(.LUM3/256/5)
     18  5107				   .LUM1      SET	.LUM1 + .STEP1
     19  5107				   .LUM2      SET	.LUM2 + .STEP2
     20  5107				   .LUM3      SET	.LUM3 + .STEP3
     14  5107					      REPEND
     15  5108		       b9		      .byte.b	$b0+0+(.LUM1/256/5)
     16  5109		       6b		      .byte.b	$60+8+(.LUM2/256/5)
     17  510a		       5a		      .byte.b	$50+4+(.LUM3/256/5)
     18  510a				   .LUM1      SET	.LUM1 + .STEP1
     19  510a				   .LUM2      SET	.LUM2 + .STEP2
     20  510a				   .LUM3      SET	.LUM3 + .STEP3
     14  510a					      REPEND
     15  510b		       b9		      .byte.b	$b0+0+(.LUM1/256/5)
     16  510c		       6b		      .byte.b	$60+8+(.LUM2/256/5)
     17  510d		       5a		      .byte.b	$50+4+(.LUM3/256/5)
     18  510d				   .LUM1      SET	.LUM1 + .STEP1
     19  510d				   .LUM2      SET	.LUM2 + .STEP2
     20  510d				   .LUM3      SET	.LUM3 + .STEP3
     14  510d					      REPEND
     15  510e		       b9		      .byte.b	$b0+0+(.LUM1/256/5)
     16  510f		       6b		      .byte.b	$60+8+(.LUM2/256/5)
     17  5110		       5a		      .byte.b	$50+4+(.LUM3/256/5)
     18  5110				   .LUM1      SET	.LUM1 + .STEP1
     19  5110				   .LUM2      SET	.LUM2 + .STEP2
     20  5110				   .LUM3      SET	.LUM3 + .STEP3
     14  5110					      REPEND
     15  5111		       ba		      .byte.b	$b0+0+(.LUM1/256/5)
     16  5112		       6b		      .byte.b	$60+8+(.LUM2/256/5)
     17  5113		       5a		      .byte.b	$50+4+(.LUM3/256/5)
     18  5113				   .LUM1      SET	.LUM1 + .STEP1
     19  5113				   .LUM2      SET	.LUM2 + .STEP2
     20  5113				   .LUM3      SET	.LUM3 + .STEP3
     21  5114					      REPEND
     13  5114					      REPEND
     14  5114					      REPEAT	5
     15  5114		       ba		      .byte.b	$b0+0+(.LUM1/256/5)
     16  5115		       6b		      .byte.b	$60+8+(.LUM2/256/5)
     17  5116		       5b		      .byte.b	$50+4+(.LUM3/256/5)
     18  5116				   .LUM1      SET	.LUM1 + .STEP1
     19  5116				   .LUM2      SET	.LUM2 + .STEP2
     20  5116				   .LUM3      SET	.LUM3 + .STEP3
     14  5116					      REPEND
     15  5117		       ba		      .byte.b	$b0+0+(.LUM1/256/5)
     16  5118		       6b		      .byte.b	$60+8+(.LUM2/256/5)
     17  5119		       5b		      .byte.b	$50+4+(.LUM3/256/5)
     18  5119				   .LUM1      SET	.LUM1 + .STEP1
     19  5119				   .LUM2      SET	.LUM2 + .STEP2
     20  5119				   .LUM3      SET	.LUM3 + .STEP3
     14  5119					      REPEND
     15  511a		       bb		      .byte.b	$b0+0+(.LUM1/256/5)
     16  511b		       6b		      .byte.b	$60+8+(.LUM2/256/5)
     17  511c		       5b		      .byte.b	$50+4+(.LUM3/256/5)
     18  511c				   .LUM1      SET	.LUM1 + .STEP1
     19  511c				   .LUM2      SET	.LUM2 + .STEP2
     20  511c				   .LUM3      SET	.LUM3 + .STEP3
     14  511c					      REPEND
     15  511d		       bb		      .byte.b	$b0+0+(.LUM1/256/5)
     16  511e		       6b		      .byte.b	$60+8+(.LUM2/256/5)
     17  511f		       5b		      .byte.b	$50+4+(.LUM3/256/5)
     18  511f				   .LUM1      SET	.LUM1 + .STEP1
     19  511f				   .LUM2      SET	.LUM2 + .STEP2
     20  511f				   .LUM3      SET	.LUM3 + .STEP3
     14  511f					      REPEND
     15  5120		       bb		      .byte.b	$b0+0+(.LUM1/256/5)
     16  5121		       6b		      .byte.b	$60+8+(.LUM2/256/5)
     17  5122		       5b		      .byte.b	$50+4+(.LUM3/256/5)
     18  5122				   .LUM1      SET	.LUM1 + .STEP1
     19  5122				   .LUM2      SET	.LUM2 + .STEP2
     20  5122				   .LUM3      SET	.LUM3 + .STEP3
     21  5123					      REPEND
     22  5123					      REPEND
      0  5123				   colr_ntsc  LUMTABLE	$80,$30,$B0,0,8,4
      1  5123
      2  5123
      3  5123
      4  5123
      5  5123				   .LUM1      SET	0
      6  5123				   .LUM2      SET	8
      7  5123				   .LUM3      SET	4
      8  5123
      9  5123		       01 80	   .STEP1     =	256*($C-0)/8
     10  5123		       00 80	   .STEP2     =	256*($C-8)/8
     11  5123		       01 00	   .STEP3     =	256*($C-4)/8
     12  5123
     13  5123					      REPEAT	8
     14  5123					      REPEAT	5
     15  5123		       80		      .byte.b	$80+0+(.LUM1/256/5)
     16  5124		       38		      .byte.b	$30+8+(.LUM2/256/5)
     17  5125		       b4		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5125				   .LUM1      SET	.LUM1 + .STEP1
     19  5125				   .LUM2      SET	.LUM2 + .STEP2
     20  5125				   .LUM3      SET	.LUM3 + .STEP3
     14  5125					      REPEND
     15  5126		       80		      .byte.b	$80+0+(.LUM1/256/5)
     16  5127		       38		      .byte.b	$30+8+(.LUM2/256/5)
     17  5128		       b4		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5128				   .LUM1      SET	.LUM1 + .STEP1
     19  5128				   .LUM2      SET	.LUM2 + .STEP2
     20  5128				   .LUM3      SET	.LUM3 + .STEP3
     14  5128					      REPEND
     15  5129		       80		      .byte.b	$80+0+(.LUM1/256/5)
     16  512a		       38		      .byte.b	$30+8+(.LUM2/256/5)
     17  512b		       b4		      .byte.b	$B0+4+(.LUM3/256/5)
     18  512b				   .LUM1      SET	.LUM1 + .STEP1
     19  512b				   .LUM2      SET	.LUM2 + .STEP2
     20  512b				   .LUM3      SET	.LUM3 + .STEP3
     14  512b					      REPEND
     15  512c		       80		      .byte.b	$80+0+(.LUM1/256/5)
     16  512d		       38		      .byte.b	$30+8+(.LUM2/256/5)
     17  512e		       b4		      .byte.b	$B0+4+(.LUM3/256/5)
     18  512e				   .LUM1      SET	.LUM1 + .STEP1
     19  512e				   .LUM2      SET	.LUM2 + .STEP2
     20  512e				   .LUM3      SET	.LUM3 + .STEP3
     14  512e					      REPEND
     15  512f		       81		      .byte.b	$80+0+(.LUM1/256/5)
     16  5130		       38		      .byte.b	$30+8+(.LUM2/256/5)
     17  5131		       b4		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5131				   .LUM1      SET	.LUM1 + .STEP1
     19  5131				   .LUM2      SET	.LUM2 + .STEP2
     20  5131				   .LUM3      SET	.LUM3 + .STEP3
     21  5132					      REPEND
     13  5132					      REPEND
     14  5132					      REPEAT	5
     15  5132		       81		      .byte.b	$80+0+(.LUM1/256/5)
     16  5133		       38		      .byte.b	$30+8+(.LUM2/256/5)
     17  5134		       b5		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5134				   .LUM1      SET	.LUM1 + .STEP1
     19  5134				   .LUM2      SET	.LUM2 + .STEP2
     20  5134				   .LUM3      SET	.LUM3 + .STEP3
     14  5134					      REPEND
     15  5135		       81		      .byte.b	$80+0+(.LUM1/256/5)
     16  5136		       38		      .byte.b	$30+8+(.LUM2/256/5)
     17  5137		       b5		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5137				   .LUM1      SET	.LUM1 + .STEP1
     19  5137				   .LUM2      SET	.LUM2 + .STEP2
     20  5137				   .LUM3      SET	.LUM3 + .STEP3
     14  5137					      REPEND
     15  5138		       82		      .byte.b	$80+0+(.LUM1/256/5)
     16  5139		       38		      .byte.b	$30+8+(.LUM2/256/5)
     17  513a		       b5		      .byte.b	$B0+4+(.LUM3/256/5)
     18  513a				   .LUM1      SET	.LUM1 + .STEP1
     19  513a				   .LUM2      SET	.LUM2 + .STEP2
     20  513a				   .LUM3      SET	.LUM3 + .STEP3
     14  513a					      REPEND
     15  513b		       82		      .byte.b	$80+0+(.LUM1/256/5)
     16  513c		       38		      .byte.b	$30+8+(.LUM2/256/5)
     17  513d		       b5		      .byte.b	$B0+4+(.LUM3/256/5)
     18  513d				   .LUM1      SET	.LUM1 + .STEP1
     19  513d				   .LUM2      SET	.LUM2 + .STEP2
     20  513d				   .LUM3      SET	.LUM3 + .STEP3
     14  513d					      REPEND
     15  513e		       82		      .byte.b	$80+0+(.LUM1/256/5)
     16  513f		       38		      .byte.b	$30+8+(.LUM2/256/5)
     17  5140		       b5		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5140				   .LUM1      SET	.LUM1 + .STEP1
     19  5140				   .LUM2      SET	.LUM2 + .STEP2
     20  5140				   .LUM3      SET	.LUM3 + .STEP3
     21  5141					      REPEND
     13  5141					      REPEND
     14  5141					      REPEAT	5
     15  5141		       83		      .byte.b	$80+0+(.LUM1/256/5)
     16  5142		       39		      .byte.b	$30+8+(.LUM2/256/5)
     17  5143		       b6		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5143				   .LUM1      SET	.LUM1 + .STEP1
     19  5143				   .LUM2      SET	.LUM2 + .STEP2
     20  5143				   .LUM3      SET	.LUM3 + .STEP3
     14  5143					      REPEND
     15  5144		       83		      .byte.b	$80+0+(.LUM1/256/5)
     16  5145		       39		      .byte.b	$30+8+(.LUM2/256/5)
     17  5146		       b6		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5146				   .LUM1      SET	.LUM1 + .STEP1
     19  5146				   .LUM2      SET	.LUM2 + .STEP2
     20  5146				   .LUM3      SET	.LUM3 + .STEP3
     14  5146					      REPEND
     15  5147		       83		      .byte.b	$80+0+(.LUM1/256/5)
     16  5148		       39		      .byte.b	$30+8+(.LUM2/256/5)
     17  5149		       b6		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5149				   .LUM1      SET	.LUM1 + .STEP1
     19  5149				   .LUM2      SET	.LUM2 + .STEP2
     20  5149				   .LUM3      SET	.LUM3 + .STEP3
     14  5149					      REPEND
     15  514a		       83		      .byte.b	$80+0+(.LUM1/256/5)
     16  514b		       39		      .byte.b	$30+8+(.LUM2/256/5)
     17  514c		       b6		      .byte.b	$B0+4+(.LUM3/256/5)
     18  514c				   .LUM1      SET	.LUM1 + .STEP1
     19  514c				   .LUM2      SET	.LUM2 + .STEP2
     20  514c				   .LUM3      SET	.LUM3 + .STEP3
     14  514c					      REPEND
     15  514d		       84		      .byte.b	$80+0+(.LUM1/256/5)
     16  514e		       39		      .byte.b	$30+8+(.LUM2/256/5)
     17  514f		       b6		      .byte.b	$B0+4+(.LUM3/256/5)
     18  514f				   .LUM1      SET	.LUM1 + .STEP1
     19  514f				   .LUM2      SET	.LUM2 + .STEP2
     20  514f				   .LUM3      SET	.LUM3 + .STEP3
     21  5150					      REPEND
     13  5150					      REPEND
     14  5150					      REPEAT	5
     15  5150		       84		      .byte.b	$80+0+(.LUM1/256/5)
     16  5151		       39		      .byte.b	$30+8+(.LUM2/256/5)
     17  5152		       b7		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5152				   .LUM1      SET	.LUM1 + .STEP1
     19  5152				   .LUM2      SET	.LUM2 + .STEP2
     20  5152				   .LUM3      SET	.LUM3 + .STEP3
     14  5152					      REPEND
     15  5153		       84		      .byte.b	$80+0+(.LUM1/256/5)
     16  5154		       39		      .byte.b	$30+8+(.LUM2/256/5)
     17  5155		       b7		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5155				   .LUM1      SET	.LUM1 + .STEP1
     19  5155				   .LUM2      SET	.LUM2 + .STEP2
     20  5155				   .LUM3      SET	.LUM3 + .STEP3
     14  5155					      REPEND
     15  5156		       85		      .byte.b	$80+0+(.LUM1/256/5)
     16  5157		       39		      .byte.b	$30+8+(.LUM2/256/5)
     17  5158		       b7		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5158				   .LUM1      SET	.LUM1 + .STEP1
     19  5158				   .LUM2      SET	.LUM2 + .STEP2
     20  5158				   .LUM3      SET	.LUM3 + .STEP3
     14  5158					      REPEND
     15  5159		       85		      .byte.b	$80+0+(.LUM1/256/5)
     16  515a		       39		      .byte.b	$30+8+(.LUM2/256/5)
     17  515b		       b7		      .byte.b	$B0+4+(.LUM3/256/5)
     18  515b				   .LUM1      SET	.LUM1 + .STEP1
     19  515b				   .LUM2      SET	.LUM2 + .STEP2
     20  515b				   .LUM3      SET	.LUM3 + .STEP3
     14  515b					      REPEND
     15  515c		       85		      .byte.b	$80+0+(.LUM1/256/5)
     16  515d		       39		      .byte.b	$30+8+(.LUM2/256/5)
     17  515e		       b7		      .byte.b	$B0+4+(.LUM3/256/5)
     18  515e				   .LUM1      SET	.LUM1 + .STEP1
     19  515e				   .LUM2      SET	.LUM2 + .STEP2
     20  515e				   .LUM3      SET	.LUM3 + .STEP3
     21  515f					      REPEND
     13  515f					      REPEND
     14  515f					      REPEAT	5
     15  515f		       86		      .byte.b	$80+0+(.LUM1/256/5)
     16  5160		       3a		      .byte.b	$30+8+(.LUM2/256/5)
     17  5161		       b8		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5161				   .LUM1      SET	.LUM1 + .STEP1
     19  5161				   .LUM2      SET	.LUM2 + .STEP2
     20  5161				   .LUM3      SET	.LUM3 + .STEP3
     14  5161					      REPEND
     15  5162		       86		      .byte.b	$80+0+(.LUM1/256/5)
     16  5163		       3a		      .byte.b	$30+8+(.LUM2/256/5)
     17  5164		       b8		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5164				   .LUM1      SET	.LUM1 + .STEP1
     19  5164				   .LUM2      SET	.LUM2 + .STEP2
     20  5164				   .LUM3      SET	.LUM3 + .STEP3
     14  5164					      REPEND
     15  5165		       86		      .byte.b	$80+0+(.LUM1/256/5)
     16  5166		       3a		      .byte.b	$30+8+(.LUM2/256/5)
     17  5167		       b8		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5167				   .LUM1      SET	.LUM1 + .STEP1
     19  5167				   .LUM2      SET	.LUM2 + .STEP2
     20  5167				   .LUM3      SET	.LUM3 + .STEP3
     14  5167					      REPEND
     15  5168		       86		      .byte.b	$80+0+(.LUM1/256/5)
     16  5169		       3a		      .byte.b	$30+8+(.LUM2/256/5)
     17  516a		       b8		      .byte.b	$B0+4+(.LUM3/256/5)
     18  516a				   .LUM1      SET	.LUM1 + .STEP1
     19  516a				   .LUM2      SET	.LUM2 + .STEP2
     20  516a				   .LUM3      SET	.LUM3 + .STEP3
     14  516a					      REPEND
     15  516b		       87		      .byte.b	$80+0+(.LUM1/256/5)
     16  516c		       3a		      .byte.b	$30+8+(.LUM2/256/5)
     17  516d		       b8		      .byte.b	$B0+4+(.LUM3/256/5)
     18  516d				   .LUM1      SET	.LUM1 + .STEP1
     19  516d				   .LUM2      SET	.LUM2 + .STEP2
     20  516d				   .LUM3      SET	.LUM3 + .STEP3
     21  516e					      REPEND
     13  516e					      REPEND
     14  516e					      REPEAT	5
     15  516e		       87		      .byte.b	$80+0+(.LUM1/256/5)
     16  516f		       3a		      .byte.b	$30+8+(.LUM2/256/5)
     17  5170		       b9		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5170				   .LUM1      SET	.LUM1 + .STEP1
     19  5170				   .LUM2      SET	.LUM2 + .STEP2
     20  5170				   .LUM3      SET	.LUM3 + .STEP3
     14  5170					      REPEND
     15  5171		       87		      .byte.b	$80+0+(.LUM1/256/5)
     16  5172		       3a		      .byte.b	$30+8+(.LUM2/256/5)
     17  5173		       b9		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5173				   .LUM1      SET	.LUM1 + .STEP1
     19  5173				   .LUM2      SET	.LUM2 + .STEP2
     20  5173				   .LUM3      SET	.LUM3 + .STEP3
     14  5173					      REPEND
     15  5174		       88		      .byte.b	$80+0+(.LUM1/256/5)
     16  5175		       3a		      .byte.b	$30+8+(.LUM2/256/5)
     17  5176		       b9		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5176				   .LUM1      SET	.LUM1 + .STEP1
     19  5176				   .LUM2      SET	.LUM2 + .STEP2
     20  5176				   .LUM3      SET	.LUM3 + .STEP3
     14  5176					      REPEND
     15  5177		       88		      .byte.b	$80+0+(.LUM1/256/5)
     16  5178		       3a		      .byte.b	$30+8+(.LUM2/256/5)
     17  5179		       b9		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5179				   .LUM1      SET	.LUM1 + .STEP1
     19  5179				   .LUM2      SET	.LUM2 + .STEP2
     20  5179				   .LUM3      SET	.LUM3 + .STEP3
     14  5179					      REPEND
     15  517a		       88		      .byte.b	$80+0+(.LUM1/256/5)
     16  517b		       3a		      .byte.b	$30+8+(.LUM2/256/5)
     17  517c		       b9		      .byte.b	$B0+4+(.LUM3/256/5)
     18  517c				   .LUM1      SET	.LUM1 + .STEP1
     19  517c				   .LUM2      SET	.LUM2 + .STEP2
     20  517c				   .LUM3      SET	.LUM3 + .STEP3
     21  517d					      REPEND
     13  517d					      REPEND
     14  517d					      REPEAT	5
     15  517d		       89		      .byte.b	$80+0+(.LUM1/256/5)
     16  517e		       3b		      .byte.b	$30+8+(.LUM2/256/5)
     17  517f		       ba		      .byte.b	$B0+4+(.LUM3/256/5)
     18  517f				   .LUM1      SET	.LUM1 + .STEP1
     19  517f				   .LUM2      SET	.LUM2 + .STEP2
     20  517f				   .LUM3      SET	.LUM3 + .STEP3
     14  517f					      REPEND
     15  5180		       89		      .byte.b	$80+0+(.LUM1/256/5)
     16  5181		       3b		      .byte.b	$30+8+(.LUM2/256/5)
     17  5182		       ba		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5182				   .LUM1      SET	.LUM1 + .STEP1
     19  5182				   .LUM2      SET	.LUM2 + .STEP2
     20  5182				   .LUM3      SET	.LUM3 + .STEP3
     14  5182					      REPEND
     15  5183		       89		      .byte.b	$80+0+(.LUM1/256/5)
     16  5184		       3b		      .byte.b	$30+8+(.LUM2/256/5)
     17  5185		       ba		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5185				   .LUM1      SET	.LUM1 + .STEP1
     19  5185				   .LUM2      SET	.LUM2 + .STEP2
     20  5185				   .LUM3      SET	.LUM3 + .STEP3
     14  5185					      REPEND
     15  5186		       89		      .byte.b	$80+0+(.LUM1/256/5)
     16  5187		       3b		      .byte.b	$30+8+(.LUM2/256/5)
     17  5188		       ba		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5188				   .LUM1      SET	.LUM1 + .STEP1
     19  5188				   .LUM2      SET	.LUM2 + .STEP2
     20  5188				   .LUM3      SET	.LUM3 + .STEP3
     14  5188					      REPEND
     15  5189		       8a		      .byte.b	$80+0+(.LUM1/256/5)
     16  518a		       3b		      .byte.b	$30+8+(.LUM2/256/5)
     17  518b		       ba		      .byte.b	$B0+4+(.LUM3/256/5)
     18  518b				   .LUM1      SET	.LUM1 + .STEP1
     19  518b				   .LUM2      SET	.LUM2 + .STEP2
     20  518b				   .LUM3      SET	.LUM3 + .STEP3
     21  518c					      REPEND
     13  518c					      REPEND
     14  518c					      REPEAT	5
     15  518c		       8a		      .byte.b	$80+0+(.LUM1/256/5)
     16  518d		       3b		      .byte.b	$30+8+(.LUM2/256/5)
     17  518e		       bb		      .byte.b	$B0+4+(.LUM3/256/5)
     18  518e				   .LUM1      SET	.LUM1 + .STEP1
     19  518e				   .LUM2      SET	.LUM2 + .STEP2
     20  518e				   .LUM3      SET	.LUM3 + .STEP3
     14  518e					      REPEND
     15  518f		       8a		      .byte.b	$80+0+(.LUM1/256/5)
     16  5190		       3b		      .byte.b	$30+8+(.LUM2/256/5)
     17  5191		       bb		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5191				   .LUM1      SET	.LUM1 + .STEP1
     19  5191				   .LUM2      SET	.LUM2 + .STEP2
     20  5191				   .LUM3      SET	.LUM3 + .STEP3
     14  5191					      REPEND
     15  5192		       8b		      .byte.b	$80+0+(.LUM1/256/5)
     16  5193		       3b		      .byte.b	$30+8+(.LUM2/256/5)
     17  5194		       bb		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5194				   .LUM1      SET	.LUM1 + .STEP1
     19  5194				   .LUM2      SET	.LUM2 + .STEP2
     20  5194				   .LUM3      SET	.LUM3 + .STEP3
     14  5194					      REPEND
     15  5195		       8b		      .byte.b	$80+0+(.LUM1/256/5)
     16  5196		       3b		      .byte.b	$30+8+(.LUM2/256/5)
     17  5197		       bb		      .byte.b	$B0+4+(.LUM3/256/5)
     18  5197				   .LUM1      SET	.LUM1 + .STEP1
     19  5197				   .LUM2      SET	.LUM2 + .STEP2
     20  5197				   .LUM3      SET	.LUM3 + .STEP3
     14  5197					      REPEND
     15  5198		       8b		      .byte.b	$80+0+(.LUM1/256/5)
     16  5199		       3b		      .byte.b	$30+8+(.LUM2/256/5)
     17  519a		       bb		      .byte.b	$B0+4+(.LUM3/256/5)
     18  519a				   .LUM1      SET	.LUM1 + .STEP1
     19  519a				   .LUM2      SET	.LUM2 + .STEP2
     20  519a				   .LUM3      SET	.LUM3 + .STEP3
     21  519b					      REPEND
     22  519b					      REPEND
    163  519b
------- FILE titleData.asm LEVEL 3 PASS 4
      0  519b					      include	"titleData.asm"
      1  519b				   COL_0
      2  519b		       c0		      .byte.b	192	;R (39)
      3  519c		       c0		      .byte.b	192	;G
      4  519d		       c0		      .byte.b	192	;B
      5  519e		       e0		      .byte.b	224	;R (38)
      6  519f		       e0		      .byte.b	224	;G
      7  51a0		       e0		      .byte.b	224	;B
      8  51a1		       20		      .byte.b	32	;R (37)
      9  51a2		       e0		      .byte.b	224	;G
     10  51a3		       e0		      .byte.b	224	;B
     11  51a4		       30		      .byte.b	48	;R (36)
     12  51a5		       30		      .byte.b	48	;G
     13  51a6		       30		      .byte.b	48	;B
     14  51a7		       f0		      .byte.b	240	;R (35)
     15  51a8		       10		      .byte.b	16	;G
     16  51a9		       d0		      .byte.b	208	;B
     17  51aa		       f0		      .byte.b	240	;R (34)
     18  51ab		       10		      .byte.b	16	;G
     19  51ac		       d0		      .byte.b	208	;B
     20  51ad		       f0		      .byte.b	240	;R (33)
     21  51ae		       10		      .byte.b	16	;G
     22  51af		       d0		      .byte.b	208	;B
     23  51b0		       f0		      .byte.b	240	;R (32)
     24  51b1		       10		      .byte.b	16	;G
     25  51b2		       d0		      .byte.b	208	;B
     26  51b3		       f0		      .byte.b	240	;R (31)
     27  51b4		       10		      .byte.b	16	;G
     28  51b5		       d0		      .byte.b	208	;B
     29  51b6		       f0		      .byte.b	240	;R (30)
     30  51b7		       10		      .byte.b	16	;G
     31  51b8		       10		      .byte.b	16	;B
     32  51b9		       f0		      .byte.b	240	;R (29)
     33  51ba		       10		      .byte.b	16	;G
     34  51bb		       10		      .byte.b	16	;B
     35  51bc		       f0		      .byte.b	240	;R (28)
     36  51bd		       10		      .byte.b	16	;G
     37  51be		       10		      .byte.b	16	;B
     38  51bf		       f0		      .byte.b	240	;R (27)
     39  51c0		       10		      .byte.b	16	;G
     40  51c1		       10		      .byte.b	16	;B
     41  51c2		       f0		      .byte.b	240	;R (26)
     42  51c3		       10		      .byte.b	16	;G
     43  51c4		       10		      .byte.b	16	;B
     44  51c5		       f0		      .byte.b	240	;R (25)
     45  51c6		       10		      .byte.b	16	;G
     46  51c7		       10		      .byte.b	16	;B
     47  51c8		       f0		      .byte.b	240	;R (24)
     48  51c9		       10		      .byte.b	16	;G
     49  51ca		       10		      .byte.b	16	;B
     50  51cb		       f0		      .byte.b	240	;R (23)
     51  51cc		       10		      .byte.b	16	;G
     52  51cd		       10		      .byte.b	16	;B
     53  51ce		       90		      .byte.b	144	;R (22)
     54  51cf		       70		      .byte.b	112	;G
     55  51d0		       10		      .byte.b	16	;B
     56  51d1		       10		      .byte.b	16	;R (21)
     57  51d2		       f0		      .byte.b	240	;G
     58  51d3		       10		      .byte.b	16	;B
     59  51d4		       90		      .byte.b	144	;R (20)
     60  51d5		       70		      .byte.b	112	;G
     61  51d6		       90		      .byte.b	144	;B
     62  51d7		       90		      .byte.b	144	;R (19)
     63  51d8		       70		      .byte.b	112	;G
     64  51d9		       90		      .byte.b	144	;B
     65  51da		       d0		      .byte.b	208	;R (18)
     66  51db		       30		      .byte.b	48	;G
     67  51dc		       d0		      .byte.b	208	;B
     68  51dd		       d0		      .byte.b	208	;R (17)
     69  51de		       30		      .byte.b	48	;G
     70  51df		       d0		      .byte.b	208	;B
     71  51e0		       50		      .byte.b	80	;R (16)
     72  51e1		       30		      .byte.b	48	;G
     73  51e2		       50		      .byte.b	80	;B
     74  51e3		       50		      .byte.b	80	;R (15)
     75  51e4		       30		      .byte.b	48	;G
     76  51e5		       50		      .byte.b	80	;B
     77  51e6		       50		      .byte.b	80	;R (14)
     78  51e7		       30		      .byte.b	48	;G
     79  51e8		       50		      .byte.b	80	;B
     80  51e9		       50		      .byte.b	80	;R (13)
     81  51ea		       30		      .byte.b	48	;G
     82  51eb		       50		      .byte.b	80	;B
     83  51ec		       d0		      .byte.b	208	;R (12)
     84  51ed		       30		      .byte.b	48	;G
     85  51ee		       d0		      .byte.b	208	;B
     86  51ef		       d0		      .byte.b	208	;R (11)
     87  51f0		       30		      .byte.b	48	;G
     88  51f1		       d0		      .byte.b	208	;B
     89  51f2		       d0		      .byte.b	208	;R (10)
     90  51f3		       30		      .byte.b	48	;G
     91  51f4		       d0		      .byte.b	208	;B
     92  51f5		       d0		      .byte.b	208	;R (9)
     93  51f6		       30		      .byte.b	48	;G
     94  51f7		       d0		      .byte.b	208	;B
     95  51f8		       90		      .byte.b	144	;R (8)
     96  51f9		       70		      .byte.b	112	;G
     97  51fa		       90		      .byte.b	144	;B
     98  51fb		       90		      .byte.b	144	;R (7)
     99  51fc		       70		      .byte.b	112	;G
    100  51fd		       90		      .byte.b	144	;B
    101  51fe		       10		      .byte.b	16	;R (6)
    102  51ff		       f0		      .byte.b	240	;G
    103  5200		       10		      .byte.b	16	;B
    104  5201		       10		      .byte.b	16	;R (5)
    105  5202		       f0		      .byte.b	240	;G
    106  5203		       10		      .byte.b	16	;B
    107  5204		       10		      .byte.b	16	;R (4)
    108  5205		       f0		      .byte.b	240	;G
    109  5206		       10		      .byte.b	16	;B
    110  5207		       20		      .byte.b	32	;R (3)
    111  5208		       e0		      .byte.b	224	;G
    112  5209		       20		      .byte.b	32	;B
    113  520a		       20		      .byte.b	32	;R (2)
    114  520b		       e0		      .byte.b	224	;G
    115  520c		       20		      .byte.b	32	;B
    116  520d		       e0		      .byte.b	224	;R (1)
    117  520e		       e0		      .byte.b	224	;G
    118  520f		       e0		      .byte.b	224	;B
    119  5210		       c0		      .byte.b	192	;R (0)
    120  5211		       c0		      .byte.b	192	;G
    121  5212		       c0		      .byte.b	192	;B
    122  5213				   COL_1
    123  5213		       ff		      .byte.b	255	;R (39)
    124  5214		       ff		      .byte.b	255	;G
    125  5215		       ff		      .byte.b	255	;B
    126  5216		       ff		      .byte.b	255	;R (38)
    127  5217		       ff		      .byte.b	255	;G
    128  5218		       ff		      .byte.b	255	;B
    129  5219		       00		      .byte.b	0	;R (37)
    130  521a		       ff		      .byte.b	255	;G
    131  521b		       ff		      .byte.b	255	;B
    132  521c		       00		      .byte.b	0	;R (36)
    133  521d		       f3		      .byte.b	243	;G
    134  521e		       f3		      .byte.b	243	;B
    135  521f		       0c		      .byte.b	12	;R (35)
    136  5220		       71		      .byte.b	113	;G
    137  5221		       7d		      .byte.b	125	;B
    138  5222		       0c		      .byte.b	12	;R (34)
    139  5223		       71		      .byte.b	113	;G
    140  5224		       7d		      .byte.b	125	;B
    141  5225		       9c		      .byte.b	156	;R (33)
    142  5226		       21		      .byte.b	33	;G
    143  5227		       bd		      .byte.b	189	;B
    144  5228		       9c		      .byte.b	156	;R (32)
    145  5229		       21		      .byte.b	33	;G
    146  522a		       bd		      .byte.b	189	;B
    147  522b		       9e		      .byte.b	158	;R (31)
    148  522c		       20		      .byte.b	32	;G
    149  522d		       be		      .byte.b	190	;B
    150  522e		       de		      .byte.b	222	;R (30)
    151  522f		       00		      .byte.b	0	;G
    152  5230		       de		      .byte.b	222	;B
    153  5231		       d2		      .byte.b	210	;R (29)
    154  5232		       00		      .byte.b	0	;G
    155  5233		       d2		      .byte.b	210	;B
    156  5234		       d6		      .byte.b	214	;R (28)
    157  5235		       00		      .byte.b	0	;G
    158  5236		       d2		      .byte.b	210	;B
    159  5237		       d6		      .byte.b	214	;R (27)
    160  5238		       00		      .byte.b	0	;G
    161  5239		       d2		      .byte.b	210	;B
    162  523a		       d6		      .byte.b	214	;R (26)
    163  523b		       00		      .byte.b	0	;G
    164  523c		       d2		      .byte.b	210	;B
    165  523d		       d6		      .byte.b	214	;R (25)
    166  523e		       00		      .byte.b	0	;G
    167  523f		       d2		      .byte.b	210	;B
    168  5240		       d6		      .byte.b	214	;R (24)
    169  5241		       00		      .byte.b	0	;G
    170  5242		       d2		      .byte.b	210	;B
    171  5243		       d6		      .byte.b	214	;R (23)
    172  5244		       00		      .byte.b	0	;G
    173  5245		       d2		      .byte.b	210	;B
    174  5246		       d6		      .byte.b	214	;R (22)
    175  5247		       00		      .byte.b	0	;G
    176  5248		       d2		      .byte.b	210	;B
    177  5249		       d6		      .byte.b	214	;R (21)
    178  524a		       00		      .byte.b	0	;G
    179  524b		       d2		      .byte.b	210	;B
    180  524c		       d6		      .byte.b	214	;R (20)
    181  524d		       00		      .byte.b	0	;G
    182  524e		       d2		      .byte.b	210	;B
    183  524f		       d6		      .byte.b	214	;R (19)
    184  5250		       00		      .byte.b	0	;G
    185  5251		       d2		      .byte.b	210	;B
    186  5252		       96		      .byte.b	150	;R (18)
    187  5253		       20		      .byte.b	32	;G
    188  5254		       92		      .byte.b	146	;B
    189  5255		       12		      .byte.b	18	;R (17)
    190  5256		       64		      .byte.b	100	;G
    191  5257		       12		      .byte.b	18	;B
    192  5258		       12		      .byte.b	18	;R (16)
    193  5259		       e4		      .byte.b	228	;G
    194  525a		       12		      .byte.b	18	;B
    195  525b		       12		      .byte.b	18	;R (15)
    196  525c		       e4		      .byte.b	228	;G
    197  525d		       12		      .byte.b	18	;B
    198  525e		       12		      .byte.b	18	;R (14)
    199  525f		       e4		      .byte.b	228	;G
    200  5260		       12		      .byte.b	18	;B
    201  5261		       12		      .byte.b	18	;R (13)
    202  5262		       e4		      .byte.b	228	;G
    203  5263		       12		      .byte.b	18	;B
    204  5264		       12		      .byte.b	18	;R (12)
    205  5265		       64		      .byte.b	100	;G
    206  5266		       12		      .byte.b	18	;B
    207  5267		       12		      .byte.b	18	;R (11)
    208  5268		       64		      .byte.b	100	;G
    209  5269		       12		      .byte.b	18	;B
    210  526a		       12		      .byte.b	18	;R (10)
    211  526b		       64		      .byte.b	100	;G
    212  526c		       12		      .byte.b	18	;B
    213  526d		       9a		      .byte.b	154	;R (9)
    214  526e		       20		      .byte.b	32	;G
    215  526f		       9a		      .byte.b	154	;B
    216  5270		       da		      .byte.b	218	;R (8)
    217  5271		       00		      .byte.b	0	;G
    218  5272		       da		      .byte.b	218	;B
    219  5273		       fe		      .byte.b	254	;R (7)
    220  5274		       00		      .byte.b	0	;G
    221  5275		       fe		      .byte.b	254	;B
    222  5276		       ee		      .byte.b	238	;R (6)
    223  5277		       00		      .byte.b	0	;G
    224  5278		       ee		      .byte.b	238	;B
    225  5279		       6e		      .byte.b	110	;R (5)
    226  527a		       80		      .byte.b	128	;G
    227  527b		       6e		      .byte.b	110	;B
    228  527c		       24		      .byte.b	36	;R (4)
    229  527d		       c9		      .byte.b	201	;G
    230  527e		       24		      .byte.b	36	;B
    231  527f		       00		      .byte.b	0	;R (3)
    232  5280		       ff		      .byte.b	255	;G
    233  5281		       00		      .byte.b	0	;B
    234  5282		       00		      .byte.b	0	;R (2)
    235  5283		       ff		      .byte.b	255	;G
    236  5284		       00		      .byte.b	0	;B
    237  5285		       ff		      .byte.b	255	;R (1)
    238  5286		       ff		      .byte.b	255	;G
    239  5287		       ff		      .byte.b	255	;B
    240  5288		       ff		      .byte.b	255	;R (0)
    241  5289		       ff		      .byte.b	255	;G
    242  528a		       ff		      .byte.b	255	;B
    243  528b				   COL_2
    244  528b		       ff		      .byte.b	255	;R (39)
    245  528c		       ff		      .byte.b	255	;G
    246  528d		       ff		      .byte.b	255	;B
    247  528e		       ff		      .byte.b	255	;R (38)
    248  528f		       ff		      .byte.b	255	;G
    249  5290		       ff		      .byte.b	255	;B
    250  5291		       00		      .byte.b	0	;R (37)
    251  5292		       ff		      .byte.b	255	;G
    252  5293		       ff		      .byte.b	255	;B
    253  5294		       00		      .byte.b	0	;R (36)
    254  5295		       26		      .byte.b	38	;G
    255  5296		       26		      .byte.b	38	;B
    256  5297		       d9		      .byte.b	217	;R (35)
    257  5298		       04		      .byte.b	4	;G
    258  5299		       dd		      .byte.b	221	;B
    259  529a		       d9		      .byte.b	217	;R (34)
    260  529b		       04		      .byte.b	4	;G
    261  529c		       dd		      .byte.b	221	;B
    262  529d		       e9		      .byte.b	233	;R (33)
    263  529e		       04		      .byte.b	4	;G
    264  529f		       ed		      .byte.b	237	;B
    265  52a0		       e9		      .byte.b	233	;R (32)
    266  52a1		       04		      .byte.b	4	;G
    267  52a2		       ed		      .byte.b	237	;B
    268  52a3		       e9		      .byte.b	233	;R (31)
    269  52a4		       04		      .byte.b	4	;G
    270  52a5		       ed		      .byte.b	237	;B
    271  52a6		       ed		      .byte.b	237	;R (30)
    272  52a7		       00		      .byte.b	0	;G
    273  52a8		       ed		      .byte.b	237	;B
    274  52a9		       2f		      .byte.b	47	;R (29)
    275  52aa		       80		      .byte.b	128	;G
    276  52ab		       af		      .byte.b	175	;B
    277  52ac		       2f		      .byte.b	47	;R (28)
    278  52ad		       80		      .byte.b	128	;G
    279  52ae		       af		      .byte.b	175	;B
    280  52af		       2f		      .byte.b	47	;R (27)
    281  52b0		       80		      .byte.b	128	;G
    282  52b1		       af		      .byte.b	175	;B
    283  52b2		       27		      .byte.b	39	;R (26)
    284  52b3		       90		      .byte.b	144	;G
    285  52b4		       b7		      .byte.b	183	;B
    286  52b5		       27		      .byte.b	39	;R (25)
    287  52b6		       90		      .byte.b	144	;G
    288  52b7		       b7		      .byte.b	183	;B
    289  52b8		       27		      .byte.b	39	;R (24)
    290  52b9		       90		      .byte.b	144	;G
    291  52ba		       b7		      .byte.b	183	;B
    292  52bb		       3b		      .byte.b	59	;R (23)
    293  52bc		       80		      .byte.b	128	;G
    294  52bd		       a3		      .byte.b	163	;B
    295  52be		       3b		      .byte.b	59	;R (22)
    296  52bf		       80		      .byte.b	128	;G
    297  52c0		       a3		      .byte.b	163	;B
    298  52c1		       b7		      .byte.b	183	;R (21)
    299  52c2		       00		      .byte.b	0	;G
    300  52c3		       27		      .byte.b	39	;B
    301  52c4		       b7		      .byte.b	183	;R (20)
    302  52c5		       00		      .byte.b	0	;G
    303  52c6		       27		      .byte.b	39	;B
    304  52c7		       b7		      .byte.b	183	;R (19)
    305  52c8		       00		      .byte.b	0	;G
    306  52c9		       27		      .byte.b	39	;B
    307  52ca		       b7		      .byte.b	183	;R (18)
    308  52cb		       00		      .byte.b	0	;G
    309  52cc		       27		      .byte.b	39	;B
    310  52cd		       af		      .byte.b	175	;R (17)
    311  52ce		       00		      .byte.b	0	;G
    312  52cf		       2f		      .byte.b	47	;B
    313  52d0		       af		      .byte.b	175	;R (16)
    314  52d1		       00		      .byte.b	0	;G
    315  52d2		       2f		      .byte.b	47	;B
    316  52d3		       ad		      .byte.b	173	;R (15)
    317  52d4		       00		      .byte.b	0	;G
    318  52d5		       2d		      .byte.b	45	;B
    319  52d6		       ad		      .byte.b	173	;R (14)
    320  52d7		       00		      .byte.b	0	;G
    321  52d8		       2d		      .byte.b	45	;B
    322  52d9		       ad		      .byte.b	173	;R (13)
    323  52da		       00		      .byte.b	0	;G
    324  52db		       2d		      .byte.b	45	;B
    325  52dc		       a9		      .byte.b	169	;R (12)
    326  52dd		       04		      .byte.b	4	;G
    327  52de		       29		      .byte.b	41	;B
    328  52df		       a9		      .byte.b	169	;R (11)
    329  52e0		       04		      .byte.b	4	;G
    330  52e1		       29		      .byte.b	41	;B
    331  52e2		       a9		      .byte.b	169	;R (10)
    332  52e3		       04		      .byte.b	4	;G
    333  52e4		       29		      .byte.b	41	;B
    334  52e5		       69		      .byte.b	105	;R (9)
    335  52e6		       04		      .byte.b	4	;G
    336  52e7		       69		      .byte.b	105	;B
    337  52e8		       79		      .byte.b	121	;R (8)
    338  52e9		       04		      .byte.b	4	;G
    339  52ea		       79		      .byte.b	121	;B
    340  52eb		       f9		      .byte.b	249	;R (7)
    341  52ec		       04		      .byte.b	4	;G
    342  52ed		       f9		      .byte.b	249	;B
    343  52ee		       d9		      .byte.b	217	;R (6)
    344  52ef		       04		      .byte.b	4	;G
    345  52f0		       d9		      .byte.b	217	;B
    346  52f1		       d9		      .byte.b	217	;R (5)
    347  52f2		       04		      .byte.b	4	;G
    348  52f3		       d9		      .byte.b	217	;B
    349  52f4		       99		      .byte.b	153	;R (4)
    350  52f5		       44		      .byte.b	68	;G
    351  52f6		       99		      .byte.b	153	;B
    352  52f7		       00		      .byte.b	0	;R (3)
    353  52f8		       ff		      .byte.b	255	;G
    354  52f9		       00		      .byte.b	0	;B
    355  52fa		       00		      .byte.b	0	;R (2)
    356  52fb		       ff		      .byte.b	255	;G
    357  52fc		       00		      .byte.b	0	;B
    358  52fd		       ff		      .byte.b	255	;R (1)
    359  52fe		       ff		      .byte.b	255	;G
    360  52ff		       ff		      .byte.b	255	;B
    361  5300		       ff		      .byte.b	255	;R (0)
    362  5301		       ff		      .byte.b	255	;G
    363  5302		       ff		      .byte.b	255	;B
    364  5303				   COL_3
    365  5303		       f0		      .byte.b	240	;R (39)
    366  5304		       f0		      .byte.b	240	;G
    367  5305		       f0		      .byte.b	240	;B
    368  5306		       f0		      .byte.b	240	;R (38)
    369  5307		       f0		      .byte.b	240	;G
    370  5308		       f0		      .byte.b	240	;B
    371  5309		       00		      .byte.b	0	;R (37)
    372  530a		       f0		      .byte.b	240	;G
    373  530b		       f0		      .byte.b	240	;B
    374  530c		       00		      .byte.b	0	;R (36)
    375  530d		       30		      .byte.b	48	;G
    376  530e		       30		      .byte.b	48	;B
    377  530f		       c0		      .byte.b	192	;R (35)
    378  5310		       e0		      .byte.b	224	;G
    379  5311		       20		      .byte.b	32	;B
    380  5312		       c0		      .byte.b	192	;R (34)
    381  5313		       e0		      .byte.b	224	;G
    382  5314		       20		      .byte.b	32	;B
    383  5315		       c0		      .byte.b	192	;R (33)
    384  5316		       e0		      .byte.b	224	;G
    385  5317		       20		      .byte.b	32	;B
    386  5318		       c0		      .byte.b	192	;R (32)
    387  5319		       e0		      .byte.b	224	;G
    388  531a		       20		      .byte.b	32	;B
    389  531b		       d0		      .byte.b	208	;R (31)
    390  531c		       c0		      .byte.b	192	;G
    391  531d		       10		      .byte.b	16	;B
    392  531e		       50		      .byte.b	80	;R (30)
    393  531f		       40		      .byte.b	64	;G
    394  5320		       10		      .byte.b	16	;B
    395  5321		       50		      .byte.b	80	;R (29)
    396  5322		       40		      .byte.b	64	;G
    397  5323		       10		      .byte.b	16	;B
    398  5324		       50		      .byte.b	80	;R (28)
    399  5325		       40		      .byte.b	64	;G
    400  5326		       10		      .byte.b	16	;B
    401  5327		       50		      .byte.b	80	;R (27)
    402  5328		       40		      .byte.b	64	;G
    403  5329		       10		      .byte.b	16	;B
    404  532a		       50		      .byte.b	80	;R (26)
    405  532b		       40		      .byte.b	64	;G
    406  532c		       10		      .byte.b	16	;B
    407  532d		       50		      .byte.b	80	;R (25)
    408  532e		       40		      .byte.b	64	;G
    409  532f		       10		      .byte.b	16	;B
    410  5330		       50		      .byte.b	80	;R (24)
    411  5331		       40		      .byte.b	64	;G
    412  5332		       10		      .byte.b	16	;B
    413  5333		       d0		      .byte.b	208	;R (23)
    414  5334		       c0		      .byte.b	192	;G
    415  5335		       10		      .byte.b	16	;B
    416  5336		       d0		      .byte.b	208	;R (22)
    417  5337		       c0		      .byte.b	192	;G
    418  5338		       10		      .byte.b	16	;B
    419  5339		       d0		      .byte.b	208	;R (21)
    420  533a		       c0		      .byte.b	192	;G
    421  533b		       10		      .byte.b	16	;B
    422  533c		       d0		      .byte.b	208	;R (20)
    423  533d		       c0		      .byte.b	192	;G
    424  533e		       10		      .byte.b	16	;B
    425  533f		       d0		      .byte.b	208	;R (19)
    426  5340		       c0		      .byte.b	192	;G
    427  5341		       10		      .byte.b	16	;B
    428  5342		       d0		      .byte.b	208	;R (18)
    429  5343		       c0		      .byte.b	192	;G
    430  5344		       10		      .byte.b	16	;B
    431  5345		       50		      .byte.b	80	;R (17)
    432  5346		       40		      .byte.b	64	;G
    433  5347		       10		      .byte.b	16	;B
    434  5348		       50		      .byte.b	80	;R (16)
    435  5349		       40		      .byte.b	64	;G
    436  534a		       10		      .byte.b	16	;B
    437  534b		       50		      .byte.b	80	;R (15)
    438  534c		       40		      .byte.b	64	;G
    439  534d		       10		      .byte.b	16	;B
    440  534e		       50		      .byte.b	80	;R (14)
    441  534f		       40		      .byte.b	64	;G
    442  5350		       10		      .byte.b	16	;B
    443  5351		       50		      .byte.b	80	;R (13)
    444  5352		       40		      .byte.b	64	;G
    445  5353		       10		      .byte.b	16	;B
    446  5354		       50		      .byte.b	80	;R (12)
    447  5355		       40		      .byte.b	64	;G
    448  5356		       10		      .byte.b	16	;B
    449  5357		       50		      .byte.b	80	;R (11)
    450  5358		       40		      .byte.b	64	;G
    451  5359		       10		      .byte.b	16	;B
    452  535a		       50		      .byte.b	80	;R (10)
    453  535b		       40		      .byte.b	64	;G
    454  535c		       10		      .byte.b	16	;B
    455  535d		       50		      .byte.b	80	;R (9)
    456  535e		       40		      .byte.b	64	;G
    457  535f		       10		      .byte.b	16	;B
    458  5360		       d0		      .byte.b	208	;R (8)
    459  5361		       c0		      .byte.b	192	;G
    460  5362		       10		      .byte.b	16	;B
    461  5363		       d0		      .byte.b	208	;R (7)
    462  5364		       c0		      .byte.b	192	;G
    463  5365		       10		      .byte.b	16	;B
    464  5366		       d0		      .byte.b	208	;R (6)
    465  5367		       c0		      .byte.b	192	;G
    466  5368		       10		      .byte.b	16	;B
    467  5369		       d0		      .byte.b	208	;R (5)
    468  536a		       c0		      .byte.b	192	;G
    469  536b		       10		      .byte.b	16	;B
    470  536c		       c0		      .byte.b	192	;R (4)
    471  536d		       e0		      .byte.b	224	;G
    472  536e		       00		      .byte.b	0	;B
    473  536f		       00		      .byte.b	0	;R (3)
    474  5370		       f0		      .byte.b	240	;G
    475  5371		       00		      .byte.b	0	;B
    476  5372		       00		      .byte.b	0	;R (2)
    477  5373		       f0		      .byte.b	240	;G
    478  5374		       00		      .byte.b	0	;B
    479  5375		       f0		      .byte.b	240	;R (1)
    480  5376		       f0		      .byte.b	240	;G
    481  5377		       f0		      .byte.b	240	;B
    482  5378		       f0		      .byte.b	240	;R (0)
    483  5379		       f0		      .byte.b	240	;G
    484  537a		       f0		      .byte.b	240	;B
    485  537b				   COL_4
    486  537b		       ff		      .byte.b	255	;R (39)
    487  537c		       ff		      .byte.b	255	;G
    488  537d		       ff		      .byte.b	255	;B
    489  537e		       ff		      .byte.b	255	;R (38)
    490  537f		       ff		      .byte.b	255	;G
    491  5380		       ff		      .byte.b	255	;B
    492  5381		       00		      .byte.b	0	;R (37)
    493  5382		       ff		      .byte.b	255	;G
    494  5383		       ff		      .byte.b	255	;B
    495  5384		       00		      .byte.b	0	;R (36)
    496  5385		       79		      .byte.b	121	;G
    497  5386		       79		      .byte.b	121	;B
    498  5387		       86		      .byte.b	134	;R (35)
    499  5388		       be		      .byte.b	190	;G
    500  5389		       38		      .byte.b	56	;B
    501  538a		       86		      .byte.b	134	;R (34)
    502  538b		       be		      .byte.b	190	;G
    503  538c		       38		      .byte.b	56	;B
    504  538d		       ce		      .byte.b	206	;R (33)
    505  538e		       de		      .byte.b	222	;G
    506  538f		       10		      .byte.b	16	;B
    507  5390		       ee		      .byte.b	238	;R (32)
    508  5391		       ee		      .byte.b	238	;G
    509  5392		       00		      .byte.b	0	;B
    510  5393		       ef		      .byte.b	239	;R (31)
    511  5394		       ef		      .byte.b	239	;G
    512  5395		       00		      .byte.b	0	;B
    513  5396		       6f		      .byte.b	111	;R (30)
    514  5397		       ef		      .byte.b	239	;G
    515  5398		       80		      .byte.b	128	;B
    516  5399		       29		      .byte.b	41	;R (29)
    517  539a		       e9		      .byte.b	233	;G
    518  539b		       c2		      .byte.b	194	;B
    519  539c		       29		      .byte.b	41	;R (28)
    520  539d		       e9		      .byte.b	233	;G
    521  539e		       c2		      .byte.b	194	;B
    522  539f		       29		      .byte.b	41	;R (27)
    523  53a0		       e9		      .byte.b	233	;G
    524  53a1		       c2		      .byte.b	194	;B
    525  53a2		       29		      .byte.b	41	;R (26)
    526  53a3		       e9		      .byte.b	233	;G
    527  53a4		       c2		      .byte.b	194	;B
    528  53a5		       69		      .byte.b	105	;R (25)
    529  53a6		       e9		      .byte.b	233	;G
    530  53a7		       82		      .byte.b	130	;B
    531  53a8		       69		      .byte.b	105	;R (24)
    532  53a9		       e9		      .byte.b	233	;G
    533  53aa		       82		      .byte.b	130	;B
    534  53ab		       69		      .byte.b	105	;R (23)
    535  53ac		       69		      .byte.b	105	;G
    536  53ad		       02		      .byte.b	2	;B
    537  53ae		       e9		      .byte.b	233	;R (22)
    538  53af		       e9		      .byte.b	233	;G
    539  53b0		       02		      .byte.b	2	;B
    540  53b1		       c9		      .byte.b	201	;R (21)
    541  53b2		       c9		      .byte.b	201	;G
    542  53b3		       12		      .byte.b	18	;B
    543  53b4		       c9		      .byte.b	201	;R (20)
    544  53b5		       c9		      .byte.b	201	;G
    545  53b6		       12		      .byte.b	18	;B
    546  53b7		       c9		      .byte.b	201	;R (19)
    547  53b8		       c9		      .byte.b	201	;G
    548  53b9		       12		      .byte.b	18	;B
    549  53ba		       49		      .byte.b	73	;R (18)
    550  53bb		       49		      .byte.b	73	;G
    551  53bc		       12		      .byte.b	18	;B
    552  53bd		       e9		      .byte.b	233	;R (17)
    553  53be		       29		      .byte.b	41	;G
    554  53bf		       02		      .byte.b	2	;B
    555  53c0		       e9		      .byte.b	233	;R (16)
    556  53c1		       29		      .byte.b	41	;G
    557  53c2		       02		      .byte.b	2	;B
    558  53c3		       e9		      .byte.b	233	;R (15)
    559  53c4		       29		      .byte.b	41	;G
    560  53c5		       02		      .byte.b	2	;B
    561  53c6		       e9		      .byte.b	233	;R (14)
    562  53c7		       29		      .byte.b	41	;G
    563  53c8		       02		      .byte.b	2	;B
    564  53c9		       e9		      .byte.b	233	;R (13)
    565  53ca		       29		      .byte.b	41	;G
    566  53cb		       02		      .byte.b	2	;B
    567  53cc		       e9		      .byte.b	233	;R (12)
    568  53cd		       29		      .byte.b	41	;G
    569  53ce		       02		      .byte.b	2	;B
    570  53cf		       e9		      .byte.b	233	;R (11)
    571  53d0		       69		      .byte.b	105	;G
    572  53d1		       02		      .byte.b	2	;B
    573  53d2		       e9		      .byte.b	233	;R (10)
    574  53d3		       69		      .byte.b	105	;G
    575  53d4		       02		      .byte.b	2	;B
    576  53d5		       6d		      .byte.b	109	;R (9)
    577  53d6		       6d		      .byte.b	109	;G
    578  53d7		       00		      .byte.b	0	;B
    579  53d8		       dd		      .byte.b	221	;R (8)
    580  53d9		       cd		      .byte.b	205	;G
    581  53da		       00		      .byte.b	0	;B
    582  53db		       df		      .byte.b	223	;R (7)
    583  53dc		       cf		      .byte.b	207	;G
    584  53dd		       00		      .byte.b	0	;B
    585  53de		       df		      .byte.b	223	;R (6)
    586  53df		       c7		      .byte.b	199	;G
    587  53e0		       00		      .byte.b	0	;B
    588  53e1		       9f		      .byte.b	159	;R (5)
    589  53e2		       87		      .byte.b	135	;G
    590  53e3		       00		      .byte.b	0	;B
    591  53e4		       be		      .byte.b	190	;R (4)
    592  53e5		       82		      .byte.b	130	;G
    593  53e6		       00		      .byte.b	0	;B
    594  53e7		       3f		      .byte.b	63	;R (3)
    595  53e8		       c0		      .byte.b	192	;G
    596  53e9		       00		      .byte.b	0	;B
    597  53ea		       1f		      .byte.b	31	;R (2)
    598  53eb		       e0		      .byte.b	224	;G
    599  53ec		       00		      .byte.b	0	;B
    600  53ed		       ff		      .byte.b	255	;R (1)
    601  53ee		       ff		      .byte.b	255	;G
    602  53ef		       ff		      .byte.b	255	;B
    603  53f0		       ff		      .byte.b	255	;R (0)
    604  53f1		       ff		      .byte.b	255	;G
    605  53f2		       ff		      .byte.b	255	;B
    606  53f3				   COL_5
    607  53f3		       3f		      .byte.b	63	;R (39)
    608  53f4		       3f		      .byte.b	63	;G
    609  53f5		       3f		      .byte.b	63	;B
    610  53f6		       7f		      .byte.b	127	;R (38)
    611  53f7		       7f		      .byte.b	127	;G
    612  53f8		       7f		      .byte.b	127	;B
    613  53f9		       40		      .byte.b	64	;R (37)
    614  53fa		       7f		      .byte.b	127	;G
    615  53fb		       7f		      .byte.b	127	;B
    616  53fc		       c0		      .byte.b	192	;R (36)
    617  53fd		       f3		      .byte.b	243	;G
    618  53fe		       f3		      .byte.b	243	;B
    619  53ff		       8c		      .byte.b	140	;R (35)
    620  5400		       ef		      .byte.b	239	;G
    621  5401		       e3		      .byte.b	227	;B
    622  5402		       8c		      .byte.b	140	;R (34)
    623  5403		       ef		      .byte.b	239	;G
    624  5404		       e3		      .byte.b	227	;B
    625  5405		       8e		      .byte.b	142	;R (33)
    626  5406		       ef		      .byte.b	239	;G
    627  5407		       e1		      .byte.b	225	;B
    628  5408		       8e		      .byte.b	142	;R (32)
    629  5409		       ef		      .byte.b	239	;G
    630  540a		       e1		      .byte.b	225	;B
    631  540b		       9e		      .byte.b	158	;R (31)
    632  540c		       9e		      .byte.b	158	;G
    633  540d		       c0		      .byte.b	192	;B
    634  540e		       9e		      .byte.b	158	;R (30)
    635  540f		       9e		      .byte.b	158	;G
    636  5410		       c0		      .byte.b	192	;B
    637  5411		       92		      .byte.b	146	;R (29)
    638  5412		       92		      .byte.b	146	;G
    639  5413		       c8		      .byte.b	200	;B
    640  5414		       92		      .byte.b	146	;R (28)
    641  5415		       92		      .byte.b	146	;G
    642  5416		       c8		      .byte.b	200	;B
    643  5417		       92		      .byte.b	146	;R (27)
    644  5418		       92		      .byte.b	146	;G
    645  5419		       c8		      .byte.b	200	;B
    646  541a		       92		      .byte.b	146	;R (26)
    647  541b		       92		      .byte.b	146	;G
    648  541c		       c8		      .byte.b	200	;B
    649  541d		       92		      .byte.b	146	;R (25)
    650  541e		       92		      .byte.b	146	;G
    651  541f		       c8		      .byte.b	200	;B
    652  5420		       92		      .byte.b	146	;R (24)
    653  5421		       92		      .byte.b	146	;G
    654  5422		       c8		      .byte.b	200	;B
    655  5423		       92		      .byte.b	146	;R (23)
    656  5424		       92		      .byte.b	146	;G
    657  5425		       c8		      .byte.b	200	;B
    658  5426		       92		      .byte.b	146	;R (22)
    659  5427		       92		      .byte.b	146	;G
    660  5428		       c8		      .byte.b	200	;B
    661  5429		       92		      .byte.b	146	;R (21)
    662  542a		       92		      .byte.b	146	;G
    663  542b		       c8		      .byte.b	200	;B
    664  542c		       92		      .byte.b	146	;R (20)
    665  542d		       92		      .byte.b	146	;G
    666  542e		       c8		      .byte.b	200	;B
    667  542f		       92		      .byte.b	146	;R (19)
    668  5430		       92		      .byte.b	146	;G
    669  5431		       c8		      .byte.b	200	;B
    670  5432		       92		      .byte.b	146	;R (18)
    671  5433		       92		      .byte.b	146	;G
    672  5434		       c8		      .byte.b	200	;B
    673  5435		       92		      .byte.b	146	;R (17)
    674  5436		       92		      .byte.b	146	;G
    675  5437		       c8		      .byte.b	200	;B
    676  5438		       92		      .byte.b	146	;R (16)
    677  5439		       92		      .byte.b	146	;G
    678  543a		       c8		      .byte.b	200	;B
    679  543b		       92		      .byte.b	146	;R (15)
    680  543c		       92		      .byte.b	146	;G
    681  543d		       c8		      .byte.b	200	;B
    682  543e		       92		      .byte.b	146	;R (14)
    683  543f		       92		      .byte.b	146	;G
    684  5440		       c8		      .byte.b	200	;B
    685  5441		       92		      .byte.b	146	;R (13)
    686  5442		       92		      .byte.b	146	;G
    687  5443		       c8		      .byte.b	200	;B
    688  5444		       92		      .byte.b	146	;R (12)
    689  5445		       92		      .byte.b	146	;G
    690  5446		       c8		      .byte.b	200	;B
    691  5447		       92		      .byte.b	146	;R (11)
    692  5448		       92		      .byte.b	146	;G
    693  5449		       c8		      .byte.b	200	;B
    694  544a		       92		      .byte.b	146	;R (10)
    695  544b		       92		      .byte.b	146	;G
    696  544c		       c8		      .byte.b	200	;B
    697  544d		       96		      .byte.b	150	;R (9)
    698  544e		       96		      .byte.b	150	;G
    699  544f		       c0		      .byte.b	192	;B
    700  5450		       96		      .byte.b	150	;R (8)
    701  5451		       96		      .byte.b	150	;G
    702  5452		       c0		      .byte.b	192	;B
    703  5453		       9e		      .byte.b	158	;R (7)
    704  5454		       9e		      .byte.b	158	;G
    705  5455		       c0		      .byte.b	192	;B
    706  5456		       9e		      .byte.b	158	;R (6)
    707  5457		       9c		      .byte.b	156	;G
    708  5458		       c0		      .byte.b	192	;B
    709  5459		       9e		      .byte.b	158	;R (5)
    710  545a		       9c		      .byte.b	156	;G
    711  545b		       c0		      .byte.b	192	;B
    712  545c		       ef		      .byte.b	239	;R (4)
    713  545d		       88		      .byte.b	136	;G
    714  545e		       80		      .byte.b	128	;B
    715  545f		       7f		      .byte.b	127	;R (3)
    716  5460		       40		      .byte.b	64	;G
    717  5461		       40		      .byte.b	64	;B
    718  5462		       7f		      .byte.b	127	;R (2)
    719  5463		       40		      .byte.b	64	;G
    720  5464		       40		      .byte.b	64	;B
    721  5465		       7f		      .byte.b	127	;R (1)
    722  5466		       7f		      .byte.b	127	;G
    723  5467		       7f		      .byte.b	127	;B
    724  5468		       3f		      .byte.b	63	;R (0)
    725  5469		       3f		      .byte.b	63	;G
    726  546a		       3f		      .byte.b	63	;B
------- FILE titleScreen.asm
    165  546b
      0  546b					      CHECK_BANK_SIZE	"INITBANK"
      1  546b		       04 6b	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $46b , FREE= $395
      2  546b					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  546b				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  546b				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  546b				  -	      ERR
      6  546b					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 4
      0  546b					      include	"BANK_INITBANK.asm"	; MUST be after banks that include levels -- otherwise MAX_LEVELBANK is not calculated properly
      1  546b							;    Sokoboo - a Sokoban implementation
      2  546b							;    using a generic tile-based display engine for the Atari 2600
      3  546b							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  546b							;
      5  546b							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  546b							;
      7  546b							;    Code related to the generic tile-based display engine was developed by
      8  546b							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  546b							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  546b							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  546b							;
     12  546b							;    Code related to music and sound effects uses the TIATracker music player
     13  546b							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  546b							;    directory for Apache licensing details.
     15  546b							;
     16  546b							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  546b							;    See the copyright notices in the License directory for a list of level
     18  546b							;    contributors.
     19  546b							;
     20  546b							;    Except where otherwise indicated, this software is released under the
     21  546b							;    following licensing arrangement...
     22  546b							;
     23  546b							;    This program is free software: you can redistribute it and/or modify
     24  546b							;    it under the terms of the GNU General Public License as published by
     25  546b							;    the Free Software Foundation, either version 3 of the License, or
     26  546b							;    (at your option) any later version.
     27  546b							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  546b
     29  546b							;    This program is distributed in the hope that it will be useful,
     30  546b							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  546b							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  546b							;    GNU General Public License for more details.
     33  546b
      0  546b					      NEWBANK	INITBANK
      1  5b0b ????				      SEG	INITBANK
      2  5800					      ORG	ORIGIN
      3  5800					      RORG	$F000
      4  5800				   BANK_START SET	*
      5  5800				   INITBANK   SET	ORIGIN / 2048
      6  5800				   ORIGIN     SET	ORIGIN + 2048
      7  5800				   _CURRENT_BANK SET	INITBANK
     35  5800
     36  5800		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
     37  5801
      0  5801					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  5801		       00 0b	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  5801					      SUBROUTINE
      3  5801				   BoardLineStartLO
     39  5801
     40  5801							; Gives the start address (LO) of each board line
     41  5801					      if	1
     42  5801				   .BOARD_LOCATION SET	Board
     43  5801					      REPEAT	SIZE_BOARD_Y
     44  5801				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5801				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5801					      ENDIF
     47  5801		       00		      .byte.b	<.BOARD_LOCATION
     48  5801				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5801					      REPEND
     44  5802				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5802				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5802					      ENDIF
     47  5802		       28		      .byte.b	<.BOARD_LOCATION
     48  5802				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5802					      REPEND
     44  5803				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5803				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5803					      ENDIF
     47  5803		       50		      .byte.b	<.BOARD_LOCATION
     48  5803				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5803					      REPEND
     44  5804				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5804				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5804					      ENDIF
     47  5804		       78		      .byte.b	<.BOARD_LOCATION
     48  5804				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5804					      REPEND
     44  5805				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5805				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5805					      ENDIF
     47  5805		       a0		      .byte.b	<.BOARD_LOCATION
     48  5805				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5805					      REPEND
     44  5806				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5806				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5806					      ENDIF
     47  5806		       c8		      .byte.b	<.BOARD_LOCATION
     48  5806				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5806					      REPEND
     44  5807					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5807				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5807					      ENDIF
     47  5807		       00		      .byte.b	<.BOARD_LOCATION
     48  5807				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5807					      REPEND
     44  5808				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5808				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5808					      ENDIF
     47  5808		       28		      .byte.b	<.BOARD_LOCATION
     48  5808				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5808					      REPEND
     44  5809				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5809				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5809					      ENDIF
     47  5809		       50		      .byte.b	<.BOARD_LOCATION
     48  5809				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5809					      REPEND
     44  580a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  580a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  580a					      ENDIF
     47  580a		       78		      .byte.b	<.BOARD_LOCATION
     48  580a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  580a					      REPEND
     44  580b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  580b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  580b					      ENDIF
     47  580b		       a0		      .byte.b	<.BOARD_LOCATION
     48  580b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  580b					      REPEND
     44  580c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  580c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  580c					      ENDIF
     47  580c		       c8		      .byte.b	<.BOARD_LOCATION
     48  580c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  580c					      REPEND
     44  580d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  580d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  580d					      ENDIF
     47  580d		       00		      .byte.b	<.BOARD_LOCATION
     48  580d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  580d					      REPEND
     44  580e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  580e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  580e					      ENDIF
     47  580e		       28		      .byte.b	<.BOARD_LOCATION
     48  580e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  580e					      REPEND
     44  580f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  580f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  580f					      ENDIF
     47  580f		       50		      .byte.b	<.BOARD_LOCATION
     48  580f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  580f					      REPEND
     44  5810				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5810				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5810					      ENDIF
     47  5810		       78		      .byte.b	<.BOARD_LOCATION
     48  5810				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5810					      REPEND
     44  5811				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5811				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5811					      ENDIF
     47  5811		       a0		      .byte.b	<.BOARD_LOCATION
     48  5811				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5811					      REPEND
     44  5812				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5812				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5812					      ENDIF
     47  5812		       c8		      .byte.b	<.BOARD_LOCATION
     48  5812				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5812					      REPEND
     44  5813					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5813				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5813					      ENDIF
     47  5813		       00		      .byte.b	<.BOARD_LOCATION
     48  5813				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5813					      REPEND
     44  5814				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5814				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5814					      ENDIF
     47  5814		       28		      .byte.b	<.BOARD_LOCATION
     48  5814				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5814					      REPEND
     44  5815				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5815				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5815					      ENDIF
     47  5815		       50		      .byte.b	<.BOARD_LOCATION
     48  5815				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  5815					      REPEND
     44  5816				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  5816				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  5816					      ENDIF
     47  5816		       78		      .byte.b	<.BOARD_LOCATION
     48  5816				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     49  5817					      REPEND
      0  5817					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  5817					      LIST	ON
     51  5817
     52  5817		       03 a0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     53  5817					      endif
     54  5817
     55  5817							;------------------------------------------------------------------------------
     56  5817
     57  5817				   BoardLineStartHiR
     58  5817
     59  5817							; Gives the start address (HI) of each board line
     60  5817							; Note this caters for the memory wrapping when we go from bank to bank, as
     61  5817							; the board overlays multiple banks!
     62  5817
     63  5817				   .BOARD_LOCATION SET	Board
     64  5817					      REPEAT	SIZE_BOARD_Y
     65  5817				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5817				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5817					      ENDIF
     68  5817		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5817				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5817					      REPEND
     65  5818				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5818				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5818					      ENDIF
     68  5818		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5818				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5818					      REPEND
     65  5819				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5819				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5819					      ENDIF
     68  5819		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5819				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5819					      REPEND
     65  581a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  581a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  581a					      ENDIF
     68  581a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  581a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  581a					      REPEND
     65  581b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  581b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  581b					      ENDIF
     68  581b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  581b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  581b					      REPEND
     65  581c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  581c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  581c					      ENDIF
     68  581c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  581c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  581c					      REPEND
     65  581d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  581d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  581d					      ENDIF
     68  581d		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  581d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  581d					      REPEND
     65  581e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  581e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  581e					      ENDIF
     68  581e		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  581e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  581e					      REPEND
     65  581f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  581f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  581f					      ENDIF
     68  581f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  581f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  581f					      REPEND
     65  5820				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5820				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5820					      ENDIF
     68  5820		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5820				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5820					      REPEND
     65  5821				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5821				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5821					      ENDIF
     68  5821		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5821				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5821					      REPEND
     65  5822				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5822				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5822					      ENDIF
     68  5822		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5822				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5822					      REPEND
     65  5823					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5823				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5823					      ENDIF
     68  5823		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5823				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5823					      REPEND
     65  5824				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5824				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5824					      ENDIF
     68  5824		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5824				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5824					      REPEND
     65  5825				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5825				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5825					      ENDIF
     68  5825		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5825				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5825					      REPEND
     65  5826				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5826				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5826					      ENDIF
     68  5826		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5826				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5826					      REPEND
     65  5827				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5827				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5827					      ENDIF
     68  5827		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5827				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5827					      REPEND
     65  5828				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5828				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5828					      ENDIF
     68  5828		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5828				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5828					      REPEND
     65  5829					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  5829				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  5829					      ENDIF
     68  5829		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  5829				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  5829					      REPEND
     65  582a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  582a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  582a					      ENDIF
     68  582a		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  582a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  582a					      REPEND
     65  582b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  582b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  582b					      ENDIF
     68  582b		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  582b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  582b					      REPEND
     65  582c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  582c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  582c					      ENDIF
     68  582c		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  582c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     70  582d					      REPEND
      0  582d					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  582d					      LIST	ON
     72  582d							;------------------------------------------------------------------------------
     73  582d
     74  582d				   BoardLineStartHiW
     75  582d
     76  582d							; Gives the start address (HI) of each board line
     77  582d							; Note this caters for the memory wrapping when we go from bank to bank, as
     78  582d							; the board overlays multiple banks!
     79  582d
     80  582d				   .BOARD_LOCATION SET	Board
     81  582d					      REPEAT	SIZE_BOARD_Y
     82  582d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  582d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  582d					      ENDIF
     85  582d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  582d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  582d					      REPEND
     82  582e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  582e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  582e					      ENDIF
     85  582e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  582e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  582e					      REPEND
     82  582f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  582f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  582f					      ENDIF
     85  582f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  582f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  582f					      REPEND
     82  5830				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5830				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5830					      ENDIF
     85  5830		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5830				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5830					      REPEND
     82  5831				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5831				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5831					      ENDIF
     85  5831		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5831				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5831					      REPEND
     82  5832				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5832				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5832					      ENDIF
     85  5832		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5832				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5832					      REPEND
     82  5833					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5833				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5833					      ENDIF
     85  5833		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5833				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5833					      REPEND
     82  5834				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5834				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5834					      ENDIF
     85  5834		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5834				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5834					      REPEND
     82  5835				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5835				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5835					      ENDIF
     85  5835		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5835				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5835					      REPEND
     82  5836				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5836				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5836					      ENDIF
     85  5836		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5836				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5836					      REPEND
     82  5837				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5837				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5837					      ENDIF
     85  5837		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5837				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5837					      REPEND
     82  5838				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5838				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5838					      ENDIF
     85  5838		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5838				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5838					      REPEND
     82  5839					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5839				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5839					      ENDIF
     85  5839		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5839				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5839					      REPEND
     82  583a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  583a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  583a					      ENDIF
     85  583a		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  583a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  583a					      REPEND
     82  583b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  583b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  583b					      ENDIF
     85  583b		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  583b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  583b					      REPEND
     82  583c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  583c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  583c					      ENDIF
     85  583c		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  583c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  583c					      REPEND
     82  583d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  583d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  583d					      ENDIF
     85  583d		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  583d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  583d					      REPEND
     82  583e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  583e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  583e					      ENDIF
     85  583e		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  583e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  583e					      REPEND
     82  583f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  583f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  583f					      ENDIF
     85  583f		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  583f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  583f					      REPEND
     82  5840				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5840				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5840					      ENDIF
     85  5840		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5840				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5840					      REPEND
     82  5841				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5841				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5841					      ENDIF
     85  5841		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5841				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  5841					      REPEND
     82  5842				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  5842				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  5842					      ENDIF
     85  5842		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  5842				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     87  5843					      REPEND
      0  5843					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  5843					      LIST	ON
     89  5843
     90  5843							;------------------------------------------------------------------------------
     91  5843				  -	      IF	MULTI_BANK_BOARD = YES
     92  5843				  -BoardBank
     93  5843					      ENDIF
     94  5843							; Gives the RAM bank of the start of the board row for a given row.
     95  5843
     96  5843				   .BOARD_LOCATION SET	Board - RAM_3E
     97  5843					      REPEAT	SIZE_BOARD_Y
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  5843					      REPEND
     98  5843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  5843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  5843					      ENDIF
    101  5843				  -	      IF	MULTI_BANK_BOARD = YES
    102  5843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  5843					      ENDIF
    104  5843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
    105  5843					      REPEND
    106  5843				  -	      IF	MULTI_BANK_BOARD = YES
    107  5843				  -	      CHECKPAGEX	BoardBank, "BoardBank in BANK_INITBANK.asm"
    108  5843					      ENDIF
    109  5843
    110  5843
    111  5843							;------------------------------------------------------------------------------
    112  5843
    113  5843				   CopyROMShadowToRAM_F000
    114  5843		       a9 f0		      lda	#>$F000
    115  5845
      0  5845					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  5845		       00 0b	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  5845					      SUBROUTINE
      3  5845				   CopyROMShadowToRAM
    117  5845
    118  5845							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
    119  5845							; the variable definitions are in the ROM shadow because this allows auto-initialisation
    120  5845							; of the variable contents from ROM declarations, but still allows access to them as
    121  5845							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
    122  5845							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
    123  5845							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
    124  5845							; code co-lives in all banks and may run even as bankswitching occurs between those
    125  5845							; banks -- by the very code itself.
    126  5845
    127  5845							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
    128  5845		       85 c3		      sta	Board_AddressR+1
    129  5847		       86 dd		      stx	O_ROM_Source_Bank	; source bank
    130  5849		       84 c7		      sty	RAM_Bank	; destination bank
    131  584b
    132  584b		       a0 00		      ldy	#0
    133  584d		       84 c2		      sty	Board_AddressR
    134  584f		       84 c4		      sty	Board_AddressW
    135  5851		       a9 14		      lda	#>($1000+RAM_WRITE)
    136  5853		       85 c5		      sta	Board_AddressW+1
    137  5855
    138  5855							; Iterate 4 pages (1K) for complete bank copy
    139  5855
    140  5855		       a9 04		      lda	#4
    141  5857		       85 dc		      sta	O_CopyCount
    142  5859
    143  5859		       84 de	   CopyPage   sty	O_Index
    144  585b		       a5 dd		      lda	O_ROM_Source_Bank
    145  585d		       20 0f f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    146  5860							;tax
    147  5860		       a4 de		      ldy	O_Index
    148  5862		       a6 c7		      ldx	RAM_Bank
    149  5864		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    150  5867
    151  5867		       a4 de		      ldy	O_Index
    152  5869		       c8		      iny
    153  586a		       d0 ed		      bne	CopyPage
    154  586c
    155  586c		       e6 c3		      inc	Board_AddressR+1
    156  586e		       e6 c5		      inc	Board_AddressW+1
    157  5870
    158  5870		       c6 dc		      dec	O_CopyCount
    159  5872		       d0 e5		      bne	CopyPage
    160  5874
    161  5874		       a4 c7		      ldy	RAM_Bank	; TODO: remove!?
    162  5876		       60		      rts
    163  5877
    164  5877
    165  5877							;------------------------------------------------------------------------------
      0  5877					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  5877		       00 0b	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  5877					      SUBROUTINE
      3  5877				   SetPlatformColours
    167  5877
    168  5877							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    169  5877							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    170  5877							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    171  5877							; addressing will not violate the page-crossing restriction of 3E.
    172  5877
    173  5877							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    174  5877
    175  5877		       a9 00		      lda	#<DrawTheScreen	; = 0
    176  5879		       85 c4		      sta	Board_AddressW
    177  587b		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    178  587d		       85 c5		      sta	Board_AddressW+1
    179  587f
    180  587f							; first, set the x index (with last one being a RTS ($60))
    181  587f
    182  587f		       a6 c7		      ldx	RAM_Bank
    183  5881		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    184  5883		       d0 07		      bne	.skipPatch
    185  5885		       a9 60		      lda	#$60	; rts
    186  5887		       a0 41		      ldy	#<SELFMOD_X
    187  5889		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    188  588c				   .skipPatch
    189  588c
    190  588c		       a2 02		      ldx	#3-1
    191  588e				   .loopColor
    192  588e		       86 dc		      stx	colorIdx
    193  5890							; set PF colors
    194  5890		       b5 bf		      lda	color,x
    195  5892		       bc b7 f0 	      ldy	SelfModColOfsTbl,x
    196  5895							;tax
    197  5895		       a6 c7		      ldx	RAM_Bank
    198  5897		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy PF colour RED/GREEN/BLUE to self-modifying RAM
    199  589a							; set player colors
    200  589a		       a6 dc		      ldx	colorIdx
    201  589c		       bd ba f0 	      lda	SelfModePlayerTbl,x
    202  589f		       a4 81		      ldy	Platform
    203  58a1		       c0 02		      cpy	#PAL
    204  58a3		       90 02		      bcc	.platform0
    205  58a5		       69 17		      adc	#LINES_PER_CHAR-1	; C==1!
    206  58a7				   .platform0
    207  58a7		       bc bd f0 	      ldy	SelfModPlayerColOfsTbl,x
    208  58aa							;tax
    209  58aa		       a6 c7		      ldx	RAM_Bank
    210  58ac		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy player colour RED/GREEN/BLUE to self-modifying RAM
    211  58af							; loop
    212  58af		       a6 dc		      ldx	colorIdx
    213  58b1		       ca		      dex
    214  58b2		       10 da		      bpl	.loopColor
    215  58b4
    216  58b4		       a4 c7		      ldy	RAM_Bank
    217  58b6		       60		      rts
    218  58b7
    219  58b7				   SelfModColOfsTbl
    220  58b7		       53 86 1c 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    221  58ba				   SelfModePlayerTbl
    222  58ba		       bf b7 af 	      .byte.b	<SpriteColourBLUE, <SpriteColourGREEN, <SpriteColourRED
    223  58bd				   SelfModPlayerColOfsTbl
    224  58bd		       4c 7f 15 	      .byte.b	<(SELFMOD_PLAYERCOL_BLUE+1), <(SELFMOD_PLAYERCOL_GREEN+1), <(SELFMOD_PLAYERCOL_RED+1)
    225  58c0
    226  58c0
    227  58c0				   DrawLineStartLO
    228  58c0
    229  58c0							; Gives the start address of each line in the draw flags buffer
    230  58c0
    231  58c0				   .DRAW_LOCATION SET	DrawFlag
    232  58c0					      REPEAT	SCREEN_LINES
    233  58c0		       50		      .byte.b	<.DRAW_LOCATION
    234  58c0				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c0					      REPEND
    233  58c1		       5a		      .byte.b	<.DRAW_LOCATION
    234  58c1				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c1					      REPEND
    233  58c2		       64		      .byte.b	<.DRAW_LOCATION
    234  58c2				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c2					      REPEND
    233  58c3		       6e		      .byte.b	<.DRAW_LOCATION
    234  58c3				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c3					      REPEND
    233  58c4		       78		      .byte.b	<.DRAW_LOCATION
    234  58c4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c4					      REPEND
    233  58c5		       82		      .byte.b	<.DRAW_LOCATION
    234  58c5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c5					      REPEND
    233  58c6		       8c		      .byte.b	<.DRAW_LOCATION
    234  58c6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  58c6					      REPEND
    233  58c7		       96		      .byte.b	<.DRAW_LOCATION
    234  58c7				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    235  58c8					      REPEND
    236  58c8
    237  58c8
    238  58c8							;------------------------------------------------------------------------------
    239  58c8
      0  58c8					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  58c8		       00 0b	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  58c8					      SUBROUTINE
      3  58c8				   GetBoardAddressRW
    241  58c8							; Must share same bank as BoardLineStart tables
    242  58c8
    243  58c8		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    244  58cb		       85 c2		      sta	Board_AddressR	; 3
    245  58cd		       85 c4		      sta	Board_AddressW	; 3
    246  58cf		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    247  58d2		       85 c3		      sta	Board_AddressR+1	; 3	     READ address
    248  58d4		       09 04		      ora	#>RAM_WRITE	; 2
    249  58d6		       85 c5		      sta	Board_AddressW+1	; 3	     WRITE address
    250  58d8				  -	      IF	MULTI_BANK_BOARD = YES
    251  58d8				  -	      ldx	BoardBank,y	; 4 = 26    switch this on return
    252  58d8					      ELSE
    253  58d8		       a2 0d		      ldx	#BANK_BOARD	; 2
    254  58da					      ENDIF
    255  58da		       60		      rts		; 6 = 32[-2]
    256  58db
    257  58db							;------------------------------------------------------------------------------
    258  58db
      0  58db					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  58db		       00 0b	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  58db					      SUBROUTINE
      3  58db				   GetBoardAddressR
    260  58db
    261  58db		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    262  58de		       85 c2		      sta	Board_AddressR	; 3
    263  58e0		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    264  58e3		       85 c3		      sta	Board_AddressR+1	; 3	 READ address
    265  58e5				  -	      IF	MULTI_BANK_BOARD = YES
    266  58e5				  -	      lda	BoardBank,y	; 4	 switch this on return
    267  58e5					      ELSE
    268  58e5		       a9 0d		      lda	#BANK_BOARD	; 2
    269  58e7					      ENDIF
    270  58e7		       60		      rts		; 6[-2]
    271  58e8
    272  58e8							;------------------------------------------------------------------------------
    273  58e8
      0  58e8					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  58e8		       00 0b	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  58e8					      SUBROUTINE
      3  58e8				   GetBoardAddressW
    275  58e8
    276  58e8							; Must share same bank as BoardLineStart tables
    277  58e8
    278  58e8		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    279  58eb		       85 c4		      sta	Board_AddressW	;3
    280  58ed		       b9 2d f0 	      lda	BoardLineStartHiW,y	;4
    281  58f0		       85 c5		      sta	Board_AddressW+1	;3 WRITE address
    282  58f2				  -	      IF	MULTI_BANK_BOARD = YES
    283  58f2				  -	      ldx	BoardBank,y	;4 switch this on return
    284  58f2					      ELSE
    285  58f2		       a2 0d		      ldx	#BANK_BOARD	;2
    286  58f4					      ENDIF
    287  58f4		       60	   QRet       rts		;6
    288  58f5
    289  58f5							;-------------------------------------------------------------------------------
    290  58f5
    291  58f5
    292  58f5							;------------------------------------------------------------------------------
    293  58f5
      0  58f5					      DEFINE_SUBROUTINE	PushBox	; in INITBANK
      1  58f5		       00 0b	   BANK_PushBox =	_CURRENT_BANK
      2  58f5					      SUBROUTINE
      3  58f5				   PushBox
    295  58f5
    296  58f5							; X = restoration character for square we are moving TO
    297  58f5							; so, if X = CHARACTER_TARGET AND we move, THEN we are pushing a box off a target
    298  58f5
    299  58f5		       85 c6		      sta	ROM_Bank
    300  58f7
    301  58f7		       a5 a5		      lda	ManPushCounter
    302  58f9		       c9 01		      cmp	#PUSH_LIMIT
    303  58fb		       90 6c		      bcc	cannotPush
    304  58fd
    305  58fd		       86 de		      stx	restorationCharacter	; BOX'S NEW CHAR
    306  58ff
    307  58ff							; Determine if the box is pushable
    308  58ff							; we use the joystick to calculate the subsequent square
    309  58ff
    310  58ff		       a5 90		      lda	BufferedJoystick
    311  5901		       4a		      lsr
    312  5902		       4a		      lsr
    313  5903		       4a		      lsr
    314  5904		       4a		      lsr
    315  5905		       48		      pha
    316  5906		       a8		      tay
    317  5907
    318  5907		       18		      clc
    319  5908		       a5 8d		      lda	POS_Y_NEW
    320  590a		       79 9a f2 	      adc	JoyMoveY,y
    321  590d		       a8		      tay
    322  590e		       20 c8 f0 	      jsr	GetBoardAddressRW
    323  5911
    324  5911		       68		      pla
    325  5912		       a8		      tay
    326  5913
    327  5913		       18		      clc
    328  5914		       a5 8c		      lda	POS_X_NEW
    329  5916		       79 8e f2 	      adc	JoyMoveX,y
    330  5919		       48		      pha
    331  591a		       a8		      tay
    332  591b
    333  591b				  -	      IF	MULTI_BANK_BOARD = YES
    334  591b				  -	      lda	RAM_Bank
    335  591b					      ELSE
    336  591b		       a9 0d		      lda	#BANK_BOARD	; 2
    337  591d					      ENDIF
    338  591d		       20 14 f8 	      jsr	GetBoardCharacter	;6+20(A)
    339  5920		       68		      pla
    340  5921		       a8		      tay
    341  5922
    342  5922		       a9 02		      lda	#CHARACTER_BOX
    343  5924		       e0 00		      cpx	#CHARACTER_BLANK
    344  5926		       f0 13		      beq	canPushTarget
    345  5928
    346  5928		       e0 03		      cpx	#CHARACTER_TARGET
    347  592a		       f0 04		      beq	decreaseTargets
    348  592c		       e0 04		      cpx	#CHARACTER_TARGET2
    349  592e		       d0 39		      bne	cannotPush
    350  5930
    351  5930							; Box is now on a target - so decrease the remaining targets
    352  5930
    353  5930		       f8	   decreaseTargets sed
    354  5931		       38		      sec
    355  5932		       a5 bb		      lda	targetsRequired
    356  5934		       e9 01		      sbc	#1
    357  5936		       85 bb		      sta	targetsRequired
    358  5938		       d8		      cld
    359  5939
    360  5939		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    361  593b		       48	   canPushTarget pha
    362  593c
    363  593c							; If the box *WAS* on a target (restoration character = CHARACTER_TARGET)
    364  593c							; then we increase targets (as there is one more to get)
    365  593c
    366  593c		       a5 de		      lda	restorationCharacter
    367  593e		       c9 03		      cmp	#CHARACTER_TARGET
    368  5940		       d0 09		      bne	notOnTargetAlready
    369  5942
    370  5942							; increase the required targets as box is leaving one
    371  5942
    372  5942		       f8		      sed
    373  5943		       18		      clc
    374  5944		       a5 bb		      lda	targetsRequired
    375  5946		       69 01		      adc	#1
    376  5948		       85 bb		      sta	targetsRequired
    377  594a		       d8		      cld
    378  594b
    379  594b				   notOnTargetAlready
    380  594b
    381  594b
    382  594b		       68		      pla
    383  594c
    384  594c
    385  594c				  -	      IF	MULTI_BANK_BOARD = YES
    386  594c				  -	      ldx	RAM_Bank
    387  594c					      ELSE
    388  594c		       a2 0d		      ldx	#BANK_BOARD	; 2
    389  594e					      ENDIF
    390  594e		       20 1d f8 	      jsr	PutBoardCharacter	;6+21(A)
    391  5951
    392  5951		       a5 8f		      lda	POS_VAR	; player's restoration character
    393  5953		       48		      pha
    394  5954
    395  5954		       a6 8d		      ldx	POS_Y_NEW
    396  5956		       86 8b		      stx	POS_Y
    397  5958		       a4 8c		      ldy	POS_X_NEW
    398  595a		       84 8a		      sty	POS_X
    399  595c		       a5 de		      lda	restorationCharacter
    400  595e		       85 8f		      sta	POS_VAR
    401  5960
    402  5960		       20 02 f9 	      jsr	RestoreOriginalCharacter	; put back BOX's restoration character
    403  5963
    404  5963		       68		      pla
    405  5964		       85 8f		      sta	POS_VAR
    406  5966
    407  5966							;START_SOUND SOUND_BOX
    408  5966
    409  5966		       4c 61 f9 	      jmp	MovePlayer	; now there's a gap, player should move in
    410  5969
    411  5969		       e6 a5	   cannotPush inc	ManPushCounter
    412  596b		       60		      rts
    413  596c
    414  596c							;------------------------------------------------------------------------------
    415  596c
    416  596c							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    417  596c							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    418  596c
    419  596c							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    420  596c
    421  596c							; if the creature dies then jump NextObject
    422  596c
    423  596c
    424  596c
    425  596c		       ff	   RDirY      .byte.b	-1	;,0,1,0
    426  596d		       00 01	   RDirX      .byte.b	0,1	;,0,-1
    427  596f		       00 ff 01 00 DirPushModX .byte.b	0,-1,1,0
    428  5973		       ff 00 00 01 DirPushModY .byte.b	-1,0,0,1
    429  5977		       01 02 03 00*Directional .byte.b	1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    430  5985
    431  5985
    432  5985							;------------------------------------------------------------------------------
    433  5985
    434  5985							; the auto-calculation of these was causing DASM to get confused and abort assembling.
    435  5985							; I don't particularly know why; probably because of the level variable-size array and the values
    436  5985							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    437  5985
    438  5985		       00 00	   MANMODE_STARTUP =	0
    439  5985		       00 01	   MANMODE_NORMAL =	1
    440  5985		       00 02	   MANMODE_DEAD =	2
    441  5985		       00 03	   MANMODE_WAITING =	3
    442  5985		       00 04	   MANMODE_WAITING2 =	4
    443  5985		       00 05	   MANMODE_WAITING_NT =	5
    444  5985		       00 06	   MANMODE_WAITING_NT2 =	6
    445  5985		       00 07	   MANMODE_NEXTLEVEL =	7
    446  5985		       00 08	   MANMODE_NEXTLEVEL2 =	8
    447  5985		       00 09	   MANMODE_SWITCH =	9
    448  5985
      0  5985					      DEFINE_SUBROUTINE	ManProcess
      1  5985		       00 0b	   BANK_ManProcess =	_CURRENT_BANK
      2  5985					      SUBROUTINE
      3  5985				   ManProcess
    450  5985
    451  5985							; ManMode tells the player what it is currently doing.  State machine.
    452  5985
    453  5985							; Check the switches....
    454  5985							; RESET to restart this level
    455  5985							; SELECT to start next level
    456  5985
    457  5985		       ad 82 02 	      lda	SWCHB
    458  5988		       29 03		      and	#3
    459  598a		       aa		      tax
    460  598b		       bd a4 f1 	      lda	newMode,x
    461  598e		       30 02		      bmi	skipModeChange
    462  5990		       85 9f		      sta	ManMode
    463  5992				   skipModeChange
    464  5992
    465  5992		       20 00 f8 	      jsr	DrawTimeFromROM	; Z-flag == 0!
    466  5995
    467  5995		       a4 9f		      ldy	ManMode
    468  5997		       b9 a8 f1 	      lda	ManActionLO,y
    469  599a		       85 dc		      sta	actionVector
    470  599c		       b9 b2 f1 	      lda	ManActionHI,y
    471  599f		       85 dd		      sta	actionVector+1
    472  59a1		       6c dc 00 	      jmp	(actionVector)
    473  59a4
    474  59a4		       ff 09 04 ff newMode    .byte.b	-1, MANMODE_SWITCH, MANMODE_WAITING2, -1
    475  59a8
    476  59a8				   ManActionLO
    477  59a8		       bc		      .byte.b	<manStartup	; 0		 no timer
    478  59a9		       f3		      .byte.b	<normalMan	; 1		 timer
    479  59aa		       f8		      .byte.b	<deadMan	; 2		 timer
    480  59ab		       ec		      .byte.b	<waitingMan	; 3		 timer
    481  59ac		       ec		      .byte.b	<waitingManPress	; 4		 timer
    482  59ad		       ec		      .byte.b	<waitingMan	; 5		 no timer
    483  59ae		       ec		      .byte.b	<waitingManPress	; 6		 no timer
    484  59af		       69		      .byte.b	<nextLevelMan	; 7		 no timer
    485  59b0		       7a		      .byte.b	<nextLevelMan2	; 8		 no timer
    486  59b1		       85		      .byte.b	<switchLevels	; 9		 no timer
    487  59b2
    488  59b2				   ManActionHI
    489  59b2		       f1		      .byte.b	>manStartup	; no timer
    490  59b3		       f1		      .byte.b	>normalMan	; timer
    491  59b4		       f1		      .byte.b	>deadMan	; timer
    492  59b5		       f1		      .byte.b	>waitingMan	; timer
    493  59b6		       f1		      .byte.b	>waitingManPress	; timer
    494  59b7		       f1		      .byte.b	>waitingMan	; no timer
    495  59b8		       f1		      .byte.b	>waitingManPress	; no timer
    496  59b9		       fc		      .byte.b	>nextLevelMan	; no timer
    497  59ba		       fc		      .byte.b	>nextLevelMan2	; no timer
    498  59bb		       fc		      .byte.b	>switchLevels	;9  no timer
    499  59bc
    500  59bc							;------------------------------------------------------------------------------
      0  59bc					      DEFINE_SUBROUTINE	manStartup
      1  59bc		       00 0b	   BANK_manStartup =	_CURRENT_BANK
      2  59bc					      SUBROUTINE
      3  59bc				   manStartup
    502  59bc
    503  59bc		       a5 9b		      lda	ManX
    504  59be		       85 8a		      sta	POS_X
    505  59c0		       a5 9c		      lda	ManY
    506  59c2		       85 8b		      sta	POS_Y
    507  59c4
    508  59c4				  -	      if	0
    509  59c4				  -anotherC   inc	POS_X
    510  59c4				  -	      lda	#CHARACTER_2
    511  59c4				  -	      sta	POS_Type
    512  59c4				  -	      lda	#BANK_manStartup
    513  59c4				  -	      jsr	PutBoardCharacterFromROM
    514  59c4				  -	      inc	POS_Type
    515  59c4				  -	      lda	POS_Type
    516  59c4				  -	      cmp	#CHARACTER_2
    517  59c4				  -			;bcc anotherC
    518  59c4					      endif
    519  59c4
    520  59c4
    521  59c4		       a5 9b		      lda	ManX
    522  59c6		       85 8c		      sta	POS_X_NEW	;NewX
    523  59c8		       85 8a		      sta	POS_X
    524  59ca		       a5 9c		      lda	ManY
    525  59cc		       85 8d		      sta	POS_Y_NEW	;NewY
    526  59ce		       85 8b		      sta	POS_Y
    527  59d0
    528  59d0		       e6 9a		      inc	manAnimationIndex
    529  59d2		       a6 9a		      ldx	manAnimationIndex	; animation index
    530  59d4		       bd e4 f1 	      lda	.ManStartup-1,x
    531  59d7		       30 09		      bmi	CreateThePlayer
    532  59d9		       85 8e		      sta	POS_Type
    533  59db
    534  59db		       a9 ff		      lda	#$FF
    535  59dd		       85 a0		      sta	ManDelayCount	; anything, just non-0
    536  59df
    537  59df		       4c 3a f8 	      jmp	PutBoardCharacterFromRAM	;70 --> switches this bank out but who cares!
    538  59e2
    539  59e2				   CreateThePlayer
    540  59e2
    541  59e2		       e6 9f		      inc	ManMode	; --> MANMODE_NORMAL
    542  59e4				   RTS_CF
    543  59e4		       60		      rts
    544  59e5
    545  59e5				   .ManStartup
    546  59e5		       09		      .byte.b	CHARACTER_NOGO
    547  59e6		       09		      .byte.b	CHARACTER_NOGO
    548  59e7		       06		      .byte.b	CHARACTER_STEEL
    549  59e8							;    .byte CHARACTER_STEEL
    550  59e8		       09		      .byte.b	CHARACTER_NOGO
    551  59e9							;    .byte CHARACTER_NOGO
    552  59e9		       06		      .byte.b	CHARACTER_STEEL
    553  59ea							;    .byte CHARACTER_NOGO
    554  59ea							;    .byte CHARACTER_STEEL
    555  59ea							;    .byte CHARACTER_NOGO
    556  59ea							;    .byte CHARACTER_STEEL
    557  59ea							;    .byte CHARACTER_NOGO
    558  59ea							;    .byte CHARACTER_STEEL
    559  59ea							;    .byte CHARACTER_NOGO
    560  59ea							;    .byte CHARACTER_STEEL
    561  59ea							;    .byte CHARACTER_NOGO
    562  59ea							;    .byte CHARACTER_STEEL
    563  59ea							;.byte CHARACTER_NOGO
    564  59ea		       05		      .byte.b	CHARACTER_MANOCCUPIED
    565  59eb		       ff		      .byte.b	-1
    566  59ec
    567  59ec							;------------------------------------------------------------------------------
    568  59ec
    569  59ec				   waitingMan
    570  59ec				   waitingManPress
    571  59ec
    572  59ec							;		  lda #50
    573  59ec							;		  sta ColourTimer
    574  59ec
    575  59ec
    576  59ec		       a5 cc		      lda	NextLevelTrigger
    577  59ee		       09 40		      ora	#BIT_NEXTLIFE
    578  59f0		       85 cc		      sta	NextLevelTrigger
    579  59f2		       60		      rts
    580  59f3
    581  59f3
    582  59f3							;------------------------------------------------------------------------------
    583  59f3							; Normal man state
    584  59f3
    585  59f3
    586  59f3				   normalMan
    587  59f3
    588  59f3							; Timer is still running, so we see if the player is to die for any reason
    589  59f3
    590  59f3							;		  bit demoMode
    591  59f3							;		  bmi stayAlive
    592  59f3							; SELECT pressed?
    593  59f3							;		  lda SWCHB
    594  59f3							;		  eor #$FF
    595  59f3							;		  and #3
    596  59f3							;		  bne Time0			  ; EITHER select or reset are pressed
    597  59f3							;		  lsr
    598  59f3							;		  lsr
    599  59f3							;		  bcc Time0			  ; suicide!
    600  59f3				   stayAlive
    601  59f3
    602  59f3							;------------------------------------------------------------------------------
    603  59f3
    604  59f3							;ldx ManY
    605  59f3							;ldy ManX
    606  59f3
    607  59f3							;lda BoardLineStartLO,x
    608  59f3							;sta Board_AddressR
    609  59f3							;lda BoardLineStartHiR,x
    610  59f3							;sta Board_AddressR+1
    611  59f3
    612  59f3				  -	      IF	MULTI_BANK_BOARD = YES
    613  59f3				  -			;lda BoardBank,x		  ;4
    614  59f3				  -			;sta RAM_Bank			  ;3
    615  59f3					      ELSE
    616  59f3							;lda #BANK_BOARD		  ;2
    617  59f3					      ENDIF
    618  59f3							;jsr GetBoardCharacter 	  ;6+20(A)
    619  59f3
    620  59f3							;lda CharToType,x
    621  59f3							;cmp #TYPE_MAN
    622  59f3							;beq PlayerAlive
    623  59f3		       4c 03 f2 	      jmp	PlayerAlive	;sok
    624  59f6
    625  59f6							; character he's on isn't a MAN character, so he dies...
    626  59f6
    627  59f6				   Time0
    628  59f6
    629  59f6		       e6 9f		      inc	ManMode	; #1 -- player dead!
    630  59f8
    631  59f8
    632  59f8		       a5 9b	   deadMan    lda	ManX
    633  59fa		       85 8a		      sta	POS_X
    634  59fc		       a5 9c		      lda	ManY
    635  59fe		       85 8b		      sta	POS_Y
    636  5a00
    637  5a00							;jsr BlankPlayerFrame
    638  5a00
    639  5a00							; and becomes a man waiting for resurrection...
    640  5a00
    641  5a00		       e6 9f		      inc	ManMode
    642  5a02
    643  5a02				   timeTooShortToDie
    644  5a02		       60		      rts
    645  5a03
    646  5a03							;------------------------------------------------------------------------------
    647  5a03
    648  5a03				   PlayerAlive
    649  5a03
    650  5a03							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    651  5a03							; before exiting via (for example) look-around option :)
    652  5a03
    653  5a03		       a5 9b		      lda	ManX
    654  5a05		       85 8c		      sta	POS_X_NEW
    655  5a07		       a5 9c		      lda	ManY
    656  5a09		       85 8d		      sta	POS_Y_NEW
    657  5a0b
    658  5a0b
    659  5a0b
    660  5a0b							;------------------------------------------------------------------------------
    661  5a0b							; Look around is triggered by holding down the fire button for a while, without any other
    662  5a0b							; joystick directions chosen. The variable LookingAround has a negative value ($FF) when looking
    663  5a0b							; is active. Otherwise, it is counting down to the time where it will trigger.
    664  5a0b
    665  5a0b		       00 00	   LOOK_DELAY =	0
    666  5a0b
    667  5a0b
    668  5a0b							;------------------------------------------------------------------------------
    669  5a0b							; Take-back is a press/release of the button, with the press being limited in duratino
    670  5a0b							; to allow the action to be "cancelled". Meanwhile, a button press + direction triggers
    671  5a0b							; "look-around mode"
    672  5a0b
    673  5a0b		       a5 92		      lda	BufferedButton
    674  5a0d		       30 36		      bmi	noLook	; button?
    675  5a0f
    676  5a0f							; button pressed, so in looking-around mode
    677  5a0f
    678  5a0f		       a2 ff		      ldx	#$FF
    679  5a11		       86 92		      stx	BufferedButton	; "release" button
    680  5a13
    681  5a13		       a5 a6		      lda	LookingAround
    682  5a15		       30 02		      bmi	LookAround
    683  5a17		       86 a6		      stx	LookingAround
    684  5a19				   LookAround
    685  5a19
    686  5a19							; Use the joystick as a window-scroller to change the viewport
    687  5a19
    688  5a19		       a5 90		      lda	BufferedJoystick
    689  5a1b		       4a		      lsr
    690  5a1c		       4a		      lsr
    691  5a1d		       4a		      lsr
    692  5a1e		       4a		      lsr
    693  5a1f		       a8		      tay
    694  5a20
    695  5a20		       b9 8e f2 	      lda	JoyMoveX,y
    696  5a23		       19 9a f2 	      ora	JoyMoveY,y
    697  5a26		       f0 1c		      beq	AbandonY
    698  5a28
    699  5a28		       a9 fe		      lda	#$FE
    700  5a2a		       85 a6		      sta	LookingAround
    701  5a2c
    702  5a2c		       b9 8e f2 	      lda	JoyMoveX,y
    703  5a2f							;asl
    704  5a2f		       18		      clc
    705  5a30		       65 97		      adc	BoardScrollX
    706  5a32		       c5 94		      cmp	BoardEdge_Right
    707  5a34		       b0 02		      bcs	AbandonX
    708  5a36		       85 97		      sta	BoardScrollX
    709  5a38
    710  5a38		       b9 9a f2    AbandonX   lda	JoyMoveY,y
    711  5a3b							;asl
    712  5a3b		       18		      clc
    713  5a3c		       65 96		      adc	BoardScrollY
    714  5a3e		       c5 95		      cmp	BoardEdge_Bottom
    715  5a40		       b0 02		      bcs	AbandonY
    716  5a42		       85 96		      sta	BoardScrollY
    717  5a44
    718  5a44		       60	   AbandonY   rts
    719  5a45
    720  5a45		       a5 a6	   noLook     lda	LookingAround
    721  5a47		       c9 ff		      cmp	#$FF
    722  5a49		       d0 00		      bne	bProcComp
    723  5a4b
    724  5a4b							; button was presssed and now released and we didn't actually look around
    725  5a4b							; TODO -- takeback here
    726  5a4b							;jsr restorePreviousManPosition
    727  5a4b							;lda #2
    728  5a4b							;sta ColourTimer
    729  5a4b
    730  5a4b		       a2 00	   bProcComp  ldx	#0
    731  5a4d		       86 a6		      stx	LookingAround
    732  5a4f
    733  5a4f							;------------------------------------------------------------------------------
    734  5a4f
    735  5a4f							; control the scrolling via the joystick
    736  5a4f
    737  5a4f		       a5 a4		      lda	ManLastDirection
    738  5a51		       29 07		      and	#DIRECTION_BITS
    739  5a53		       a8		      tay
    740  5a54
    741  5a54		       a5 90		      lda	BufferedJoystick	; joystick
    742  5a56		       25 91		      and	BufferedJoystick+1
    743  5a58
    744  5a58		       a2 00		      ldx	#0
    745  5a5a		       0a	   .loopDirs  asl
    746  5a5b		       90 07		      bcc	.dirFound
    747  5a5d		       88		      dey
    748  5a5e		       e8		      inx
    749  5a5f		       e0 04		      cpx	#4
    750  5a61		       d0 f7		      bne	.loopDirs
    751  5a63		       18		      clc
    752  5a64				   .dirFound
    753  5a64		       a5 8c		      lda	POS_X_NEW	;NewX
    754  5a66		       7d a7 f2 	      adc	JoyDirX,x
    755  5a69		       85 8c		      sta	POS_X_NEW	;NewX
    756  5a6b		       a5 8d		      lda	POS_Y_NEW	;NewY
    757  5a6d		       18		      clc
    758  5a6e		       7d a5 f2 	      adc	JoyDirY,x
    759  5a71		       85 8d		      sta	POS_Y_NEW	;NewY
    760  5a73
    761  5a73		       98		      tya
    762  5a74		       f0 12		      beq	noMovement	; animation OK
    763  5a76
    764  5a76		       8a		      txa
    765  5a77		       45 a4		      eor	ManLastDirection
    766  5a79		       29 07		      and	#DIRECTION_BITS
    767  5a7b		       45 a4		      eor	ManLastDirection
    768  5a7d		       85 a4		      sta	ManLastDirection
    769  5a7f		       bd 89 f2 	      lda	ManAnimTblLo,x
    770  5a82		       85 a1		      sta	ManAnimation
    771  5a84							;lda ManAnimTblHi,x
    772  5a84							;sta ManAnimation+1
    773  5a84		       a9 00		      lda	#0
    774  5a86		       85 a0		      sta	ManDelayCount
    775  5a88				   phase0		;jsr MovePlayer
    776  5a88				   noMovement		;ldx MAN_Player
    777  5a88
    778  5a88		       60	   DFS_rts    rts
    779  5a89
    780  5a89
    781  5a89				   ManAnimTblLo
    782  5a89		       00 00 00 00*	      .byte.b	AnimateRIGHT-Manimate, AnimateLEFT-Manimate, AnimateUP-Manimate, AnimateUP-Manimate, AnimateSTOPPED-Manimate
    783  5a8e							;ManAnimTblHi
    784  5a8e							;    .byte   >AnimateRIGHT, >AnimateLEFT, >AnimateUP, >AnimateUP, >AnimateSTOPPED
    785  5a8e
    786  5a8e
    787  5a8e
    788  5a8e		       00 00 00 00*JoyMoveX   .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1	;,0, 0,0,0
    789  5a9a		       00 00 00 00*JoyMoveY   .byte.b	0,0,0,0,0,1,-1,0,0, 1,-1	;, 0,0,1,-1,0
    790  5aa5
    791  5aa5				   JoyDirY
    792  5aa5		       00 00		      .byte.b	0,0	;,1,-1,0
    793  5aa7				   JoyDirX
    794  5aa7		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
    795  5aac
    796  5aac
    797  5aac							;------------------------------------------------------------------------------
    798  5aac
    799  5aac
      0  5aac					      DEFINE_SUBROUTINE	DrawFullScreen	; = 2568[-96]
      1  5aac		       00 0b	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  5aac					      SUBROUTINE
      3  5aac				   DrawFullScreen
    801  5aac
    802  5aac							; 83[-7] + 2484[-89] = 2567[-96]
    803  5aac
    804  5aac
    805  5aac		       ad 84 02 	      lda	INTIM	; 4
    806  5aaf		       c9 27		      cmp	#SEGTIME_BDF	; 2
    807  5ab1		       90 d5		      bcc	DFS_rts	; 2/3
      0  5ab3					      STRESS_TIME	SEGTIME_BDF
      1  5ab3				  -	      IF	TEST_SEGTIME_BDF = 1
      2  5ab3				  -
      3  5ab3				  -
      4  5ab3				  -
      5  5ab3				  -
      6  5ab3				  -
      7  5ab3				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  5ab3				  -	      bne	. - 7
      9  5ab3					      ENDIF
    809  5ab3
    810  5ab3		       a9 f4		      lda	#>( DrawFlag + RAM_WRITE )	; 2
    811  5ab5		       85 dd		      sta	BDF_DrawFlagAddress+1	; 3
    812  5ab7		       85 df		      sta	BDF_DrawFlagAddress2+1	; 3
    813  5ab9
    814  5ab9		       ba		      tsx		; 2
    815  5aba		       86 e6		      stx	DHS_Stack	; 3
    816  5abc
    817  5abc		       e6 89		      inc	ScreenDrawPhase	; 5
    818  5abe
    819  5abe		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
    820  5abf		       a2 08		      ldx	#SCREEN_LINES	; 2
    821  5ac1		       8a		      txa		; 2 = *32
    822  5ac2
    823  5ac2							; fall through
    824  5ac2
    825  5ac2							;------------------------------------------------------------------------------
    826  5ac2
      0  5ac2					      DEFINE_SUBROUTINE	DrawScreenRowPreparation	; = *59[-7 if not multi-bank-board]
      1  5ac2		       00 0b	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  5ac2					      SUBROUTINE
      3  5ac2				   DrawScreenRowPreparation
    828  5ac2
    829  5ac2							;clc
    830  5ac2		       ca		      dex		; 2
    831  5ac3		       86 e5		      stx	DHS_Line	; 3
    832  5ac5		       65 96		      adc	BoardScrollY	; 3	     the Y offset of screen into board
    833  5ac7		       a8		      tay		; 2 = 10
    834  5ac8
    835  5ac8							;clc
    836  5ac8		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
    837  5acb		       65 97		      adc	BoardScrollX	; 3	     the X offset of screen into board
    838  5acd		       85 e0		      sta	BDF_BoardAddress	; 3
    839  5acf		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    840  5ad1		       85 e2		      sta	BDF_BoardAddress2	; 3
    841  5ad3
    842  5ad3		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
    843  5ad6		       85 e1		      sta	BDF_BoardAddress+1	; 3
    844  5ad8		       85 e3		      sta	BDF_BoardAddress2+1	; 3 = 25
    845  5ada
    846  5ada		       bd c0 f0 	      lda	DrawLineStartLO,x	; 4
    847  5add		       85 dc		      sta	BDF_DrawFlagAddress	; 3
    848  5adf		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    849  5ae1		       85 de		      sta	BDF_DrawFlagAddress2	; 3 = 12
    850  5ae3
    851  5ae3				  -	      IF	MULTI_BANK_BOARD = YES
    852  5ae3				  -	      lda	BoardBank-1,y	; 4
    853  5ae3				  -	      sta	BDF_BoardBank	; 3
    854  5ae3					      ENDIF
    855  5ae3		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
    856  5ae5		       4c 65 fa 	      jmp	CopyRow2	; 3 = 12[-7]
    857  5ae8
    858  5ae8							;------------------------------------------------------------------------------
    859  5ae8
      0  5ae8					      DEFINE_SUBROUTINE	VectorProcess	;=19(A)
      1  5ae8		       00 0b	   BANK_VectorProcess =	_CURRENT_BANK
      2  5ae8					      SUBROUTINE
      3  5ae8				   VectorProcess
    861  5ae8
    862  5ae8							;sta ROM_Bank			  ;3		  processors can assume bank is stored
    863  5ae8
    864  5ae8		       bd f6 f2 	      lda	OSPointerHI,x	;4
    865  5aeb		       85 dd		      sta	POS_Vector+1	;3
    866  5aed		       bd f5 f2 	      lda	OSPointerLO,x	;4
    867  5af0		       85 dc		      sta	POS_Vector	;3
    868  5af2
    869  5af2		       6c dc 00 	      jmp	(POS_Vector)	;5 = 19	 vector to processor for particular object type
    870  5af5							;		 NOTE: Bank is either INITBANK or FIXED.
    871  5af5
    872  5af5
    873  5af5				   OBJTYPE    SET	0
    874  5af5					      MAC	define
    875  5af5				   TYPE_{1}   =	OBJTYPE
    876  5af5				   OBJTYPE    .SET	OBJTYPE + 1
    877  5af5					      ENDM
    878  5af5
    879  5af5							; If adding/removing types, the following must also be updated...
    880  5af5							;   InitialFace[...]		     in UnpackLevel.asm
    881  5af5							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
    882  5af5							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
    883  5af5							;   OSPointerLO[...]		     in BANK_INITBANK.asm
    884  5af5							;   OSPointerHI[...]		     in BANK_INITBANK.asm
    885  5af5							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
    886  5af5							;   Sortable[...]		     in BANK_FIXED.asm
    887  5af5
    888  5af5
      0  5af5					      DEFINE	MAN
      1  5af5		       00 00	   TYPE_MAN   =	OBJTYPE
      2  5af5				   OBJTYPE    .SET	OBJTYPE + 1
    890  5af5							;DEFINE CIRCLE
    891  5af5							;DEFINE CIRCLE_HELPER
    892  5af5							;DEFINE CIRCLE_DRAWER
    893  5af5
      0  5af5					      DEFINE	MAXIMUM
      1  5af5		       00 01	   TYPE_MAXIMUM =	OBJTYPE
      2  5af5				   OBJTYPE    .SET	OBJTYPE + 1
    895  5af5
    896  5af5
      0  5af5					      DEFINE_SUBROUTINE	OSPointerLO
      1  5af5		       00 0b	   BANK_OSPointerLO =	_CURRENT_BANK
      2  5af5					      SUBROUTINE
      3  5af5				   OSPointerLO
    898  5af5		       d0		      .byte.b	<PROCESS_MAN
    899  5af6							;.byte <PROCESS_CIRCLE
    900  5af6							;.byte <PROCESS_CIRCLE_HELPER
    901  5af6
    902  5af6				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
    903  5af6				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
    904  5af6				  -	      ERR
    905  5af6					      ENDIF
    906  5af6
    907  5af6
      0  5af6					      DEFINE_SUBROUTINE	OSPointerHI
      1  5af6		       00 0b	   BANK_OSPointerHI =	_CURRENT_BANK
      2  5af6					      SUBROUTINE
      3  5af6				   OSPointerHI
    909  5af6		       f8		      .byte.b	>PROCESS_MAN
    910  5af7							;.byte >PROCESS_CIRCLE
    911  5af7							;.byte >PROCESS_CIRCLE_HELPER
    912  5af7
    913  5af7				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
    914  5af7				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
    915  5af7				  -	      ERR
    916  5af7					      ENDIF
    917  5af7
    918  5af7							;------------------------------------------------------------------------------
    919  5af7
      0  5af7					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  5af7		       00 0b	   BANK_MoveVecLO =	_CURRENT_BANK
      2  5af7					      SUBROUTINE
      3  5af7				   MoveVecLO
    921  5af7
    922  5af7		       8d		      .byte.b	<MOVE_BLANK
    923  5af8		       8d		      .byte.b	<MOVE_SOIL
    924  5af9		       d7		      .byte.b	<MOVE_BOX
    925  5afa		       8d		      .byte.b	<MOVE_TARGET
    926  5afb		       8d		      .byte.b	<MOVE_TARGET
    927  5afc		       d2		      .byte.b	<MOVE_GENERIC	;man occupied
    928  5afd		       d2		      .byte.b	<MOVE_GENERIC	;steel
    929  5afe		       d2		      .byte.b	<MOVE_GENERIC	;wall
    930  5aff		       e2		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
    931  5b00		       d2		      .byte.b	<MOVE_GENERIC	;nogo
    932  5b01
    933  5b01				  -	      if	DIGITS
    934  5b01				  -	      REPEAT	10	; DIGITS 0-9
    935  5b01				  -	      .byte	<MOVE_BLANK
    936  5b01				  -	      REPEND
    937  5b01					      endif
    938  5b01
    939  5b01				  -	      if	TROPHY
    940  5b01				  -	      REPEAT	20	; 4x5
    941  5b01				  -	      .byte	<MOVE_BLANK
    942  5b01				  -	      REPEND
    943  5b01					      endif
    944  5b01
    945  5b01				  -	      IF	* - MoveVecLO != CHARACTER_MAXIMUM
    946  5b01				  -	      ECHO	"ERROR: Incorrect number of entries in MoveVecLO table!"
    947  5b01				  -	      ERR
    948  5b01					      ENDIF
    949  5b01
    950  5b01
      0  5b01					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  5b01		       00 0b	   BANK_MoveVecHI =	_CURRENT_BANK
      2  5b01					      SUBROUTINE
      3  5b01				   MoveVecHI
    952  5b01
    953  5b01		       f9		      .byte.b	>MOVE_BLANK
    954  5b02		       f9		      .byte.b	>MOVE_SOIL
    955  5b03		       f9		      .byte.b	>MOVE_BOX
    956  5b04		       f9		      .byte.b	>MOVE_TARGET
    957  5b05		       f9		      .byte.b	>MOVE_TARGET
    958  5b06		       f9		      .byte.b	>MOVE_GENERIC	;man occupied
    959  5b07		       f9		      .byte.b	>MOVE_GENERIC	;steel
    960  5b08		       f9		      .byte.b	>MOVE_GENERIC	;wall
    961  5b09		       f9		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
    962  5b0a		       f9		      .byte.b	>MOVE_GENERIC	;nogo
    963  5b0b
    964  5b0b				  -	      if	DIGITS
    965  5b0b				  -	      REPEAT	10	; DIGITS 0-9
    966  5b0b				  -	      .byte	>MOVE_BLANK
    967  5b0b				  -	      REPEND
    968  5b0b					      endif
    969  5b0b
    970  5b0b				  -	      if	TROPHY
    971  5b0b				  -	      REPEAT	20	; 4x5
    972  5b0b				  -	      .byte	>MOVE_BLANK
    973  5b0b				  -	      REPEND
    974  5b0b					      endif
    975  5b0b
    976  5b0b				  -	      IF	* - MoveVecHI != CHARACTER_MAXIMUM
    977  5b0b				  -	      ECHO	"ERROR: Incorrect number of entries in MoveVecHI table!"
    978  5b0b				  -	      ERR
    979  5b0b					      ENDIF
    980  5b0b
    981  5b0b
      0  5b0b					      CHECK_BANK_SIZE	"INITBANK"
      1  5b0b		       03 0b	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $30b , FREE= $4f5
      2  5b0b					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  5b0b				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  5b0b				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  5b0b				  -	      ERR
      6  5b0b					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_FIXED.asm LEVEL 2 PASS 4
      0  5b0b					      include	"BANK_FIXED.asm"
      1  5b0b							;    Sokoboo - a Sokoban implementation
      2  5b0b							;    using a generic tile-based display engine for the Atari 2600
      3  5b0b							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  5b0b							;
      5  5b0b							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  5b0b							;
      7  5b0b							;    Code related to the generic tile-based display engine was developed by
      8  5b0b							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  5b0b							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  5b0b							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  5b0b							;
     12  5b0b							;    Code related to music and sound effects uses the TIATracker music player
     13  5b0b							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  5b0b							;    directory for Apache licensing details.
     15  5b0b							;
     16  5b0b							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  5b0b							;    See the copyright notices in the License directory for a list of level
     18  5b0b							;    contributors.
     19  5b0b							;
     20  5b0b							;    Except where otherwise indicated, this software is released under the
     21  5b0b							;    following licensing arrangement...
     22  5b0b							;
     23  5b0b							;    This program is free software: you can redistribute it and/or modify
     24  5b0b							;    it under the terms of the GNU General Public License as published by
     25  5b0b							;    the Free Software Foundation, either version 3 of the License, or
     26  5b0b							;    (at your option) any later version.
     27  5b0b							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  5b0b
     29  5b0b							;    This program is distributed in the hope that it will be useful,
     30  5b0b							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  5b0b							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  5b0b							;    GNU General Public License for more details.
     33  5b0b
     34  5b0b							;------------------------------------------------------------------------------
     35  5b0b							;###############################  FIXED BANK  #################################
     36  5b0b							;------------------------------------------------------------------------------
     37  5b0b
     38  5b0b
     39  5b0b				   ORIGIN     SET	FIXED_BANK
     40  5b0b
      0  5b0b					      NEWBANK	THE_FIXED_BANK
      1  7e60 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
     42  7800					      RORG	$f800
     43  7800
     44  7800
     45  7800
     46  7800							;------------------------------------------------------------------------------
     47  7800
      0  7800					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  7800		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  7800					      SUBROUTINE
      3  7800				   DrawTimeFromROM
     49  7800
     50  7800		       a9 09		      lda	#BANK_SCORING
     51  7802		       85 3e		      sta	SET_BANK_RAM
     52  7804		       20 cb f2 	      jsr	DrawTime
     53  7807		       20 b6 f2 	      jsr	DrawTargetsRequired
     54  780a		       a5 c6		      lda	ROM_Bank
     55  780c		       85 3f		      sta	SET_BANK
     56  780e		       60		      rts
     57  780f
     58  780f							;------------------------------------------------------------------------------
     59  780f
      0  780f					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  780f		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  780f					      SUBROUTINE
      3  780f				   GetROMByte
     61  780f
     62  780f							; a = ROM bank to retrieve
     63  780f							; y = page index
     64  780f							; ROM_Bank = bank to return to
     65  780f							; (Board_AddressR) = page
     66  780f							; out a = byte from (Board_AddressR)
     67  780f
     68  780f		       85 3f		      sta	SET_BANK	;3
     69  7811		       4c 16 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
     70  7814
     71  7814							;------------------------------------------------------------------------------
     72  7814
      0  7814					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7814		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7814					      SUBROUTINE
      3  7814				   GetBoardCharacter
     74  7814
     75  7814							; call from ROM bank
     76  7814							; switches back to ROM_Bank on exit
     77  7814
     78  7814							; pass A = bank containing character
     79  7814							; Y = x character position
     80  7814							; (Board_AddressR) points to character position
     81  7814							; returns character from board
     82  7814
     83  7814
     84  7814		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
     85  7816
     86  7816				   GetBoardCharacter2		;=17(A)
     87  7816
     88  7816		       b3 c2		      lax	(Board_AddressR),y	;5
     89  7818		       a4 c6		      ldy	ROM_Bank	;3
     90  781a		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
     91  781c		       60		      rts		;6   and go back
     92  781d
     93  781d							;---------------------------------------------------------------------------
     94  781d
      0  781d					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  781d		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  781d					      SUBROUTINE
      3  781d				   PutBoardCharacter
     96  781d
     97  781d		       86 3e		      stx	SET_BANK_RAM	; 3
     98  781f
     99  781f				   PutBoardCharacterSB		; =18
    100  781f		       91 c4		      sta	(Board_AddressW),y	; 6
    101  7821		       a5 c6		      lda	ROM_Bank	; 3
    102  7823		       85 3f		      sta	SET_BANK	; 3
    103  7825		       60		      rts		; 6 = 21
    104  7826
    105  7826							;---------------------------------------------------------------------------
    106  7826
      0  7826					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  7826		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  7826					      SUBROUTINE
      3  7826				   GetBoardCharacter__CALL_FROM_RAM__
    108  7826
    109  7826		       a4 8b		      ldy	POS_Y	;3
    110  7828
    111  7828		       a9 0b		      lda	#BANK_GetBoardAddressR	;
    112  782a		       85 3f		      sta	SET_BANK	;
    113  782c		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    114  782f
    115  782f
    116  782f							;DEFINE_SUBROUTINE PartialGetBoardCharacter ;=23
    117  782f
    118  782f		       85 3e		      sta	SET_BANK_RAM	;3
    119  7831		       a4 8a		      ldy	POS_X	;3
    120  7833		       b3 c2		      lax	(Board_AddressR),y	;5
    121  7835		       a4 c7		      ldy	RAM_Bank	;3
    122  7837		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    123  7839		       60		      rts		;6		 and go back
    124  783a
    125  783a							;---------------------------------------------------------------------------
    126  783a
      0  783a					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  783a		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  783a					      SUBROUTINE
      3  783a				   PutBoardCharacterFromRAM
    128  783a
    129  783a							; POS_Y  = row
    130  783a							; POS_Type = character to write
    131  783a							; POS_X     = column
    132  783a							; RAM_Bank = caller's bank
    133  783a
    134  783a		       a4 8b		      ldy	POS_Y	;3
    135  783c
    136  783c		       a9 0b		      lda	#BANK_GetBoardAddressW	;
    137  783e		       85 3f		      sta	SET_BANK	;
    138  7840		       20 e8 f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
    139  7843
    140  7843		       86 3e		      stx	SET_BANK_RAM	;3
    141  7845
    142  7845		       a4 8a		      ldy	POS_X	;3
    143  7847		       a5 8e		      lda	POS_Type	;3
    144  7849		       91 c4		      sta	(Board_AddressW),y	;6
    145  784b		       a4 c7		      ldy	RAM_Bank	;3
    146  784d		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    147  784f		       60		      rts		;6
    148  7850
    149  7850
      0  7850					      DEFINE_SUBROUTINE	PutBoardCharacterFromROM
      1  7850		       00 0f	   BANK_PutBoardCharacterFromROM =	_CURRENT_BANK
      2  7850					      SUBROUTINE
      3  7850				   PutBoardCharacterFromROM
    151  7850		       48		      pha
    152  7851		       20 3a f8 	      jsr	PutBoardCharacterFromRAM
    153  7854		       68		      pla
    154  7855		       85 3f		      sta	SET_BANK
    155  7857		       60		      rts
    156  7858
    157  7858							;---------------------------------------------------------------------------
    158  7858
      0  7858					      DEFINE_SUBROUTINE	ProcessObjStack	; 15 minimum segtime abort
      1  7858		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  7858					      SUBROUTINE
      3  7858				   ProcessObjStack
    160  7858
    161  7858		       ad 84 02 	      lda	INTIM	;4
    162  785b		       c9 04		      cmp	#MINIMUM_SEGTIME	;2
    163  785d		       90 3b		      bcc	EarlyAbort	;2/3= 8
      0  785f					      STRESS_TIME	MINIMUM_SEGTIME
      1  785f				  -	      IF	TEST_MINIMUM_SEGTIME = 1
      2  785f				  -
      3  785f				  -
      4  785f				  -
      5  785f				  -
      6  785f				  -
      7  785f				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  785f				  -	      bne	. - 7
      9  785f					      ENDIF
    165  785f
    166  785f		       a5 85		      lda	ObjStackNum	;3
    167  7861		       49 01		      eor	#1	;2
    168  7863		       aa		      tax		;2
    169  7864
    170  7864		       a5 cf		      lda	ObjIterator	;3
    171  7866		       d5 86		      cmp	ObjStackPtr,x	;5
    172  7868		       b0 2e		      bcs	nextPhase	;2/3
    173  786a
    174  786a
    175  786a							; Process an object...
    176  786a							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    177  786a
    178  786a		       bc 5f f9 	      ldy	BankObjStack,x	;4
    179  786d		       84 3e		      sty	SET_BANK_RAM	;3
    180  786f
    181  786f		       aa		      tax		;2
    182  7870		       bc 80 11 	      ldy	SortedObjPtr,x	;4		 indirect object pointer list (sorted)
    183  7873
    184  7873		       b9 00 10 	      lda	ObjStackX,y	;4
    185  7876		       85 8a		      sta	POS_X	;3
    186  7878		       b9 80 10 	      lda	ObjStackY,y	;4
    187  787b		       85 8b		      sta	POS_Y	;3
    188  787d		       b9 00 11 	      lda	ObjStackVar,y	;4
    189  7880		       85 8f		      sta	POS_VAR	;3
    190  7882		       be 00 12 	      ldx	ObjStackType,y	;4
    191  7885		       86 8e		      stx	POS_Type	;3
    192  7887
    193  7887		       a9 0b		      lda	#BANK_VectorProcess	;2
    194  7889		       85 3f		      sta	SET_BANK	;3
    195  788b
    196  788b		       bd f6 f2 	      lda	OSPointerHI,x	;4
    197  788e		       85 dd		      sta	POS_Vector+1	;3
    198  7890		       bd f5 f2 	      lda	OSPointerLO,x	;4
    199  7893		       85 dc		      sta	POS_Vector	;3
    200  7895
    201  7895		       6c dc 00 	      jmp	(POS_Vector)	;5 = 82	 vector to processor for particular object type
    202  7898
    203  7898
    204  7898							;---------------------------------------------------------------------------
    205  7898							; Now process the blank stack.  This stack holds all the recently blanked squares
    206  7898							; and determines (and moves) BOXs or TARGETs into these squares.  The space vacated
    207  7898							; by these objects are added again to the blank stack.
    208  7898
    209  7898				   nextPhase
    210  7898
    211  7898							;clc
    212  7898							;lda circle_d
    213  7898							;adc #255
    214  7898							;sta circle_d
    215  7898							;bcc nocirc
    216  7898							;nocirc
    217  7898
    218  7898		       e6 89		      inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    219  789a		       60	   EarlyAbort rts		;6
    220  789b
    221  789b							;---------------------------------------------------------------------------
    222  789b
      0  789b					      DEFINE_SUBROUTINE	SwitchObjects	;=72
      1  789b		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  789b					      SUBROUTINE
      3  789b				   SwitchObjects
    224  789b
    225  789b							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    226  789b							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    227  789b							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    228  789b
    229  789b		       ad 84 02 	      lda	INTIM	; 4
    230  789e		       c9 02		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    231  78a0		       90 f8		      bcc	EarlyAbort	; 2/3= 8
      0  78a2					      STRESS_TIME	SEGTIME_SWITCHOBJECTS
      1  78a2				  -	      IF	TEST_SEGTIME_SWITCHOBJECTS = 1
      2  78a2				  -
      3  78a2				  -
      4  78a2				  -
      5  78a2				  -
      6  78a2				  -
      7  78a2				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  78a2				  -	      bne	. - 7
      9  78a2					      ENDIF
    233  78a2
    234  78a2							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    235  78a2							; we're at the throttle cutoff do we switch game-frames.
    236  78a2
    237  78a2							;sec
    238  78a2		       a5 b9		      lda	Throttle	;3
    239  78a4		       e9 a0		      sbc	#MAX_THROTTLE	;2
    240  78a6		       90 f2		      bcc	EarlyAbort	;2/3		 plenty of time left!
    241  78a8
    242  78a8							; Time is up. But we may be in a level which requires perfect sorting
    243  78a8							; So we check for these levels, and wait for the sort to complete for those.
    244  78a8
    245  78a8		       24 b8		      bit	levelDisplay	;3
    246  78aa		       50 08		      bvc	keepFractional	;2/3		 screen does not require complete sort
    247  78ac
    248  78ac							; We have a level which requires the sort to go to completion
    249  78ac							; Check to see if the sort is finished...
    250  78ac
    251  78ac		       a4 ce		      ldy	sortPtr	;3
    252  78ae		       d0 ea		      bne	EarlyAbort	;2/3		 sort still in progress, so wait
    253  78b0		       a4 cd		      ldy	sortRequired	;3
    254  78b2		       10 e6		      bpl	EarlyAbort	;2/3		 sort still in progress, so wait
    255  78b4
    256  78b4		       85 b9	   keepFractional sta	Throttle	;3		 save fractional 'left over' bit
    257  78b6
    258  78b6							; Pause the game with B/W switch:
    259  78b6
    260  78b6		       a5 80		      lda	gameMode
    261  78b8		       30 14		      bmi	.paused	; pause flag set
    262  78ba
    263  78ba							; Now that we have completed processing the object stack, we switch
    264  78ba							; the stack bank pointers for the next time around.
    265  78ba
    266  78ba		       a5 85		      lda	ObjStackNum	;3
    267  78bc		       49 01		      eor	#1	;2
    268  78be		       aa		      tax		;2
    269  78bf		       86 85		      stx	ObjStackNum	;3		 swap stacks @here
    270  78c1
    271  78c1							; STOP the sort so it doesn't corrupt the "other" object stack. Sort may get a look-in immediately after
    272  78c1							; this code is finished, so we don't want it to do something unexpected!
    273  78c1
    274  78c1		       a0 ff		      ldy	#<(-1)	;2
    275  78c3		       84 cd		      sty	sortRequired	;3
    276  78c5		       c8		      iny		;2		 Y==0
    277  78c6		       84 ce		      sty	sortPtr	;3
    278  78c8
    279  78c8							; Initialise the iterator and stack pointer for next time around.
    280  78c8							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    281  78c8							; necessary to initialise both.
    282  78c8
    283  78c8		       84 cf		      sty	ObjIterator	;3		 Y==0
    284  78ca		       94 86		      sty	ObjStackPtr,x	;4
    285  78cc
    286  78cc		       84 89		      sty	ScreenDrawPhase	;3
    287  78ce				   .paused
    288  78ce		       60	   quickExit  rts		;6
    289  78cf
    290  78cf							;---------------------------------------------------------------------------
    291  78cf
    292  78cf				  -	      if	0
    293  78cf				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE_DRAWER
    294  78cf				  -
    295  78cf				  -	      ldy	#CHARACTER_BLANK
    296  78cf				  -	      lda	circle_d+1
    297  78cf				  -			;jsr DrawCircle
    298  78cf				  -			;bcc finCircle
    299  78cf				  -			;lda #TYPE_CIRCLE_DRAWER
    300  78cf				  -			;sta POS_Type
    301  78cf				  -			;jsr InsertObjectStack
    302  78cf				  -finCircle  jmp	NextObject
    303  78cf				  -
    304  78cf				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE_HELPER
    305  78cf				  -
    306  78cf				  -	      lda	INTIM
    307  78cf				  -	      cmp	#SEGTIME_CIRCLE_HELPER
    308  78cf				  -	      bcc	EarlyAbort
    309  78cf				  -
    310  78cf				  -
    311  78cf				  -	      jmp	NextObject	; and die
    312  78cf				  -
    313  78cf				  -
    314  78cf				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE
    315  78cf				  -
    316  78cf				  -	      lda	INTIM
    317  78cf				  -	      cmp	#SEGTIME_CIRCLE
    318  78cf				  -	      bcc	EarlyAbort
    319  78cf				  -
    320  78cf				  -	      clc
    321  78cf				  -	      lda	circle_d
    322  78cf				  -	      adc	#255
    323  78cf				  -	      sta	circle_d
    324  78cf				  -	      bcc	inactiveCircle
    325  78cf				  -
    326  78cf				  -	      inc	circle_d+1
    327  78cf				  -	      lda	circle_d+1
    328  78cf				  -	      cmp	#20
    329  78cf				  -	      beq	circleComplete
    330  78cf				  -			; time to fire off another "ring" of the clearing circle
    331  78cf				  -
    332  78cf				  -			;sta POS_VAR		    ; diameter for helper to use
    333  78cf				  -			;lda #TYPE_CIRCLE_HELPER
    334  78cf				  -			;sta POS_Type
    335  78cf				  -			;jsr InsertObjectStack
    336  78cf				  -
    337  78cf				  -
    338  78cf				  -			; a = radius
    339  78cf				  -
    340  78cf				  -	      ldy	#CHARACTER_BLANK
    341  78cf				  -	      sty	circ_char
    342  78cf				  -
    343  78cf				  -	      lda	circle_d+1
    344  78cf				  -	      sec
    345  78cf				  -	      sbc	#1
    346  78cf				  -	      sta	circ_x
    347  78cf				  -	      eor	#255
    348  78cf				  -	      clc
    349  78cf				  -	      adc	#1
    350  78cf				  -	      sta	circ_scratch	; "d" --> "1-r" in unit terms
    351  78cf				  -
    352  78cf				  -	      lda	#0
    353  78cf				  -	      sta	circ_y
    354  78cf				  -
    355  78cf				  -			;lda circle_d+1		     ; radius
    356  78cf				  -			;lda #TYPE_CIRCLE_DRAWER
    357  78cf				  -			;sta POS_Type
    358  78cf				  -			;jsr InsertObjectStack
    359  78cf				  -
    360  78cf				  -	      ldy	#CHARACTER_BLANK
    361  78cf				  -	      lda	circle_d+1
    362  78cf				  -			;	      sec
    363  78cf				  -			;	      sbc #1
    364  78cf				  -	      jsr	DrawCircle
    365  78cf				  -
    366  78cf				  -			;	      ldy #CHARACTER_STEEL
    367  78cf				  -			;		sty circ_char
    368  78cf				  -	      lda	circle_d+1
    369  78cf				  -	      sta	circ_x
    370  78cf				  -	      eor	#255
    371  78cf				  -	      clc
    372  78cf				  -	      adc	#1
    373  78cf				  -	      sta	circ_scratch	; "d" --> "1-r" in unit terms
    374  78cf				  -
    375  78cf				  -	      lda	#0
    376  78cf				  -	      sta	circ_y
    377  78cf				  -
    378  78cf				  -			;lda circle_d+1		     ; radius
    379  78cf				  -			;lda #TYPE_CIRCLE_DRAWER
    380  78cf				  -			;sta POS_Type
    381  78cf				  -			;jsr InsertObjectStack
    382  78cf				  -
    383  78cf				  -			;	      ldy #CHARACTER_BLANK
    384  78cf				  -			;	      lda circle_d+1
    385  78cf				  -			;	      ;jsr DrawCircle
    386  78cf				  -
    387  78cf				  -
    388  78cf				  -
    389  78cf				  -			;			      inc circle_d+1
    390  78cf				  -			;			      ldy #CHARACTER_STEEL
    391  78cf				  -			;			      lda circle_d+1
    392  78cf				  -			;			      jsr DrawCircle
    393  78cf				  -
    394  78cf				  -inactiveCircle lda	#TYPE_CIRCLE
    395  78cf				  -	      sta	POS_Type
    396  78cf				  -	      jsr	InsertObjectStack
    397  78cf				  -
    398  78cf				  -circleComplete jmp	NextObject
    399  78cf					      endif
    400  78cf
    401  78cf							;---------------------------------------------------------------------------
    402  78cf
    403  78cf		       60	   EarlyAbort4 rts
    404  78d0
      0  78d0					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  78d0		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  78d0					      SUBROUTINE
      3  78d0				   PROCESS_MAN
    406  78d0
    407  78d0		       ad 84 02 	      lda	INTIM
    408  78d3		       c9 18		      cmp	#SEGTIME_MAN
    409  78d5		       90 f8		      bcc	EarlyAbort4
      0  78d7					      STRESS_TIME	SEGTIME_MAN
      1  78d7				  -	      IF	TEST_SEGTIME_MAN = 1
      2  78d7				  -
      3  78d7				  -
      4  78d7				  -
      5  78d7				  -
      6  78d7				  -
      7  78d7				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  78d7				  -	      bne	. - 7
      9  78d7					      ENDIF
    411  78d7
    412  78d7		       a9 0b		      lda	#BANK_ManProcess
    413  78d9		       85 c6		      sta	ROM_Bank
    414  78db		       85 3f		      sta	SET_BANK
    415  78dd		       20 85 f1 	      jsr	ManProcess
    416  78e0
    417  78e0		       20 61 f9 	      jsr	MovePlayer	; 6+{}
    418  78e3
    419  78e3		       a5 9f		      lda	ManMode
    420  78e5		       c9 07		      cmp	#MANMODE_NEXTLEVEL	; kludge
    421  78e7		       b0 08		      bcs	notComplete
    422  78e9		       a5 bb		      lda	targetsRequired
    423  78eb		       d0 04		      bne	notComplete
    424  78ed		       a9 07		      lda	#MANMODE_NEXTLEVEL
    425  78ef		       85 9f		      sta	ManMode
    426  78f1				   notComplete
    427  78f1
    428  78f1
    429  78f1		       a9 03		      lda	#BANK_TrackPlayer	;
    430  78f3		       85 3f		      sta	SET_BANK	;
    431  78f5		       20 b7 f4 	      jsr	TrackPlayer	;11+145
    432  78f8
    433  78f8		       a9 00		      lda	#TYPE_MAN	; 2
    434  78fa		       85 8e		      sta	POS_Type	; 3
    435  78fc
    436  78fc		       20 31 f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    437  78ff		       4c 24 f9    gnobj      jmp	NextObject
    438  7902
    439  7902							;---------------------------------------------------------------------------
    440  7902
      0  7902					      DEFINE_SUBROUTINE	RestoreOriginalCharacter	;=93[-2](A)
      1  7902		       00 0f	   BANK_RestoreOriginalCharacter =	_CURRENT_BANK
      2  7902					      SUBROUTINE
      3  7902				   RestoreOriginalCharacter
    442  7902
    443  7902		       a6 8b		      ldx	POS_Y	;3
    444  7904		       a4 8a		      ldy	POS_X	;3
    445  7906
    446  7906		       a9 0b		      lda	#BANK_BoardLineStartLO	;2
    447  7908		       85 3f		      sta	SET_BANK	;3
    448  790a
    449  790a		       bd 01 f0 	      lda	BoardLineStartLO,x	;4
    450  790d		       85 c4		      sta	Board_AddressW	;3
    451  790f		       bd 2d f0 	      lda	BoardLineStartHiW,x	;4
    452  7912		       85 c5		      sta	Board_AddressW+1	;3 WRITE address
    453  7914				  -	      IF	MULTI_BANK_BOARD = YES
    454  7914				  -	      lda	BoardBank,x	;4 switch this on return
    455  7914					      ELSE
    456  7914		       a9 0d		      lda	#BANK_BOARD	;2
    457  7916					      ENDIF
    458  7916		       85 3e		      sta	SET_BANK_RAM	;3
    459  7918
    460  7918		       a5 8f		      lda	POS_VAR
    461  791a		       91 c4		      sta	(Board_AddressW),y	;6 clear vacated board position
    462  791c
    463  791c		       a5 c6		      lda	ROM_Bank	;3
    464  791e		       85 3f		      sta	SET_BANK	;3
    465  7920		       60	   EarlyAbortBOX rts		;6
    466  7921
    467  7921
    468  7921							;---------------------------------------------------------------------------
    469  7921
    470  7921							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    471  7921							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    472  7921
    473  7921							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    474  7921
    475  7921							; if the creature dies then jump NextObject
    476  7921
    477  7921
    478  7921		       20 31 f9    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    479  7924
    480  7924		       e6 cf	   NextObject inc	ObjIterator	; 5
    481  7926							;		  dec ObjStackPtr,x		  ; 6
    482  7926		       4c 58 f8 	      jmp	ProcessObjStack	; 3 = 16
    483  7929
    484  7929							;---------------------------------------------------------------------------
    485  7929
      0  7929					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  7929		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  7929					      SUBROUTINE
      3  7929				   InsertObjectStackFromRAM
    487  7929
    488  7929		       20 31 f9 	      jsr	InsertObjectStack	;6+76(B)
    489  792c		       a5 c7		      lda	RAM_Bank	;3
    490  792e		       85 3e		      sta	SET_BANK_RAM	;3
    491  7930
    492  7930		       60	   NotEnoughTime rts		;6
    493  7931
    494  7931							;---------------------------------------------------------------------------
    495  7931
      0  7931					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  7931		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  7931					      SUBROUTINE
      3  7931				   InsertObjectStack
    497  7931							; POS_X     x position
    498  7931							; POS_Y     y position
    499  7931							; POS_VAR   direction or other variable
    500  7931							; POS_Type  type of object
    501  7931
    502  7931		       a6 85		      ldx	ObjStackNum	; 3
    503  7933		       bc 5f f9 	      ldy	BankObjStack,x	; 4
    504  7936		       84 3e		      sty	SET_BANK_RAM	; 3
    505  7938		       b4 86		      ldy	ObjStackPtr,x	; 4 = 14
    506  793a
    507  793a
    508  793a		       a5 8b		      lda	POS_Y	; 3
    509  793c		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    510  793f		       a5 8a		      lda	POS_X	; 3
    511  7941		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    512  7944		       a5 8f		      lda	POS_VAR	; 3
    513  7946		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    514  7949		       a5 8e		      lda	POS_Type	; 3
    515  794b		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    516  794e
    517  794e							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    518  794e							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    519  794e							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    520  794e
    521  794e
    522  794e				  -	      IF	TYPE_MAN != 0
    523  794e				  -	      cmp	#TYPE_MAN	; 2
    524  794e					      ENDIF
    525  794e		       f0 04		      beq	alwaysAllowMan	; 2/3
    526  7950
    527  7950		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    528  7952		       b0 06		      bcs	insertDone	; 2/3= 6    no room -- drop object
    529  7954				   alwaysAllowMan
    530  7954
    531  7954		       98		      tya		; 2
    532  7955		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    533  7958
    534  7958		       f6 86		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    535  795a
    536  795a		       a4 c6	   insertDone ldy	ROM_Bank	; 3
    537  795c		       84 3f		      sty	SET_BANK	; 3
    538  795e
    539  795e				   ManIsDead2
    540  795e
    541  795e
    542  795e
    543  795e		       60		      rts		; 6 = 29
    544  795f
    545  795f							;---------------------------------------------------------------------------
    546  795f
    547  795f		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    548  7961
    549  7961							;---------------------------------------------------------------------------
    550  7961
    551  7961				   MovePlayer
    552  7961		       a5 9f		      lda	ManMode
    553  7963		       c9 02		      cmp	#MANMODE_DEAD
    554  7965		       b0 f7		      bcs	ManIsDead2
    555  7967
    556  7967		       a4 8d		      ldy	POS_Y_NEW
    557  7969
    558  7969		       a9 0b		      lda	#BANK_GetBoardAddressRW	;2
    559  796b		       85 3f		      sta	SET_BANK	;3
    560  796d		       85 c6		      sta	ROM_Bank	;3
    561  796f		       20 c8 f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    562  7972				  -	      IF	MULTI_BANK_BOARD = YES
    563  7972				  -	      stx	RAM_Bank
    564  7972					      ENDIF
    565  7972		       86 3e		      stx	SET_BANK_RAM	; 3
    566  7974
    567  7974		       a4 8c		      ldy	POS_X_NEW
    568  7976		       b3 c2		      lax	(Board_AddressR),y
    569  7978
    570  7978		       a9 0b		      lda	#BANK_MoveVecLO
    571  797a		       85 3f		      sta	SET_BANK
    572  797c
    573  797c		       bd f7 f2 	      lda	MoveVecLO,x
    574  797f		       85 dc		      sta	MAN_Move
    575  7981		       bd 01 f3 	      lda	MoveVecHI,x
    576  7984		       85 dd		      sta	MAN_Move+1
    577  7986
    578  7986				  -	      IF	MULTI_BANK_BOARD = YES
    579  7986				  -	      lda	RAM_Bank
    580  7986					      ELSE
    581  7986		       a9 0d		      lda	#BANK_BOARD
    582  7988					      ENDIF
    583  7988		       85 3e		      sta	SET_BANK_RAM
    584  798a		       6c dc 00 	      jmp	(MAN_Move)
    585  798d
    586  798d							;---------------------------------------------------------------------------
    587  798d
      0  798d					      DEFINE_SUBROUTINE	MOVE_BLANK
      1  798d		       00 0f	   BANK_MOVE_BLANK =	_CURRENT_BANK
      2  798d					      SUBROUTINE
      3  798d				   MOVE_BLANK
      0  798d					      DEFINE_SUBROUTINE	MOVE_SOIL
      1  798d		       00 0f	   BANK_MOVE_SOIL =	_CURRENT_BANK
      2  798d					      SUBROUTINE
      3  798d				   MOVE_SOIL
      0  798d					      DEFINE_SUBROUTINE	MOVE_TARGET
      1  798d		       00 0f	   BANK_MOVE_TARGET =	_CURRENT_BANK
      2  798d					      SUBROUTINE
      3  798d				   MOVE_TARGET
    591  798d
    592  798d		       a4 8c		      ldy	POS_X_NEW
    593  798f		       b1 c2		      lda	(Board_AddressR),y	; what's on the board under man?
    594  7991		       48		      pha
    595  7992
    596  7992		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    597  7994		       91 c4		      sta	(Board_AddressW),y
    598  7996
    599  7996		       a6 9c		      ldx	ManY
    600  7998		       86 8b		      stx	POS_Y
    601  799a		       a4 9b		      ldy	ManX
    602  799c		       84 8a		      sty	POS_X
    603  799e
    604  799e		       20 02 f9 	      jsr	RestoreOriginalCharacter
    605  79a1
    606  79a1		       68		      pla
    607  79a2		       85 8f		      sta	POS_VAR	; save 'restore' characte
    608  79a4
    609  79a4		       a9 0e		      lda	#BANK_TAKEBACK
    610  79a6		       85 3e		      sta	SET_BANK_RAM
    611  79a8
    612  79a8		       a6 be		      ldx	moveCounterBinary
    613  79aa
    614  79aa		       a5 8c		      lda	POS_X_NEW
    615  79ac		       85 9b		      sta	ManX
    616  79ae		       9d 00 14 	      sta	RAM_WRITE+TakeBackX,x
    617  79b1
    618  79b1		       a5 8d		      lda	POS_Y_NEW
    619  79b3		       85 9c		      sta	ManY	; actually MOVE!
    620  79b5		       9d 00 15 	      sta	RAM_WRITE+TakeBackY,x
    621  79b8
    622  79b8		       a5 8f		      lda	POS_VAR	; replace char
    623  79ba		       9d 00 16 	      sta	RAM_WRITE+TakeBackA,x
    624  79bd
    625  79bd		       a5 c7		      lda	RAM_Bank
    626  79bf		       85 3e		      sta	SET_BANK_RAM
    627  79c1
    628  79c1							; Move counter..
    629  79c1
    630  79c1		       e6 be		      inc	moveCounterBinary
    631  79c3
    632  79c3		       f8		      sed
    633  79c4		       18		      clc
    634  79c5		       a5 bc		      lda	moveCounter
    635  79c7		       69 01		      adc	#1
    636  79c9		       85 bc		      sta	moveCounter
    637  79cb		       a5 bd		      lda	moveCounter+1
    638  79cd		       69 00		      adc	#0
    639  79cf		       85 bd		      sta	moveCounter+1
    640  79d1		       d8		      cld
    641  79d2
    642  79d2		       a9 00	   MOVE_GENERIC lda	#0	; 2
    643  79d4		       85 a5		      sta	ManPushCounter	; 3
    644  79d6
    645  79d6		       60	   timeExit   rts		; 6 = 11
    646  79d7
    647  79d7							;---------------------------------------------------------------------------
    648  79d7
      0  79d7					      DEFINE_SUBROUTINE	MOVE_BOX
      1  79d7		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  79d7					      SUBROUTINE
      3  79d7				   MOVE_BOX
    650  79d7
    651  79d7		       a2 00		      ldx	#CHARACTER_BLANK	; restoration character
    652  79d9		       a9 0b		      lda	#BANK_PushBox
    653  79db		       85 c6		      sta	ROM_Bank
    654  79dd		       85 3f		      sta	SET_BANK
    655  79df		       4c f5 f0 	      jmp	PushBox
    656  79e2
      0  79e2					      DEFINE_SUBROUTINE	MOVE_BOX_ON_TARGET
      1  79e2		       00 0f	   BANK_MOVE_BOX_ON_TARGET =	_CURRENT_BANK
      2  79e2					      SUBROUTINE
      3  79e2				   MOVE_BOX_ON_TARGET
    658  79e2
    659  79e2		       a2 03		      ldx	#CHARACTER_TARGET	; restoration character
    660  79e4		       a9 0b		      lda	#BANK_PushBox
    661  79e6		       85 c6		      sta	ROM_Bank
    662  79e8		       85 3f		      sta	SET_BANK
    663  79ea		       4c f5 f0 	      jmp	PushBox
    664  79ed
    665  79ed							;---------------------------------------------------------------------------
    666  79ed
      0  79ed					      DEFINE_SUBROUTINE	restorePreviousManPosition
      1  79ed		       00 0f	   BANK_restorePreviousManPosition =	_CURRENT_BANK
      2  79ed					      SUBROUTINE
      3  79ed				   restorePreviousManPosition
    668  79ed
    669  79ed		       a6 be		      ldx	moveCounterBinary
    670  79ef		       f0 21		      beq	noMovesToTake
    671  79f1		       ca		      dex
    672  79f2		       c6 be		      dec	moveCounterBinary
    673  79f4
    674  79f4		       a9 0e		      lda	#BANK_TAKEBACK
    675  79f6		       85 3e		      sta	SET_BANK_RAM
    676  79f8
    677  79f8		       bd 00 10 	      lda	TakeBackX,x
    678  79fb		       85 8a		      sta	POS_X
    679  79fd		       85 8c		      sta	POS_X_NEW
    680  79ff		       bd 00 11 	      lda	TakeBackY,x
    681  7a02		       85 8b		      sta	POS_Y
    682  7a04		       85 8d		      sta	POS_Y_NEW
    683  7a06		       bd 00 12 	      lda	TakeBackA,x
    684  7a09		       85 8f		      sta	POS_VAR
    685  7a0b
    686  7a0b							; Put character @ X,Y
    687  7a0b		       20 02 f9 	      jsr	RestoreOriginalCharacter
    688  7a0e
    689  7a0e		       a5 c6		      lda	ROM_Bank
    690  7a10		       85 3f		      sta	SET_BANK
    691  7a12
    692  7a12		       60	   noMovesToTake rts
    693  7a13
    694  7a13							;---------------------------------------------------------------------------
    695  7a13
      0  7a13					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7a13		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7a13					      SUBROUTINE
      3  7a13				   StealCharDraw
    697  7a13
    698  7a13		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    699  7a15		       85 3e		      sta	SET_BANK_RAM	; 3
    700  7a17		       a4 84		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    701  7a19		       10 35		      bpl	EnterStealCharDraw	; 3 = 10(11)
    702  7a1b
    703  7a1b				   ExitStealCharDraw
    704  7a1b
    705  7a1b							; fall through...
    706  7a1b
    707  7a1b							;---------------------------------------------------------------------------
    708  7a1b
      0  7a1b					      DEFINE_SUBROUTINE	TimeSlice
      1  7a1b		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7a1b					      SUBROUTINE
      3  7a1b				   TimeSlice
    710  7a1b
    711  7a1b							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    712  7a1b							; going ahead if there's insufficient time. This allows the previous character drawing to
    713  7a1b							; be much smaller in time, as they don't have to include the timeslice code overhead.
    714  7a1b
    715  7a1b		       ad 84 02 	      lda	INTIM	; 4
    716  7a1e		       c9 05		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    717  7a20		       90 b4		      bcc	timeExit	; 2(3)
    718  7a22
    719  7a22							; Uses the phase variable to vector to the correct processing code for the given timeslice
    720  7a22							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    721  7a22							; it should increment ScreenDrawPhase.
    722  7a22
    723  7a22							; Switched-in bank(s) are undefined after this function is called!
    724  7a22
    725  7a22		       a9 03		      lda	#BANK_TS_PhaseVectorLO	; 2
    726  7a24		       85 3f		      sta	SET_BANK	; 3
    727  7a26
    728  7a26		       a6 89		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    729  7a28		       bd 3e f5 	      lda	TS_PhaseVectorLO,x	; 4
    730  7a2b		       85 dc		      sta	TS_Vector	; 3
    731  7a2d		       bd 43 f5 	      lda	TS_PhaseVectorHI,x	; 4
    732  7a30		       85 dd		      sta	TS_Vector+1	; 3
    733  7a32
    734  7a32		       bd 48 f5 	      lda	TS_PhaseBank,x	; 4
    735  7a35		       85 3f		      sta	SET_BANK	; 3		 switch bank
    736  7a37
    737  7a37		       6c dc 00 	      jmp	(TS_Vector)	; 3 = 40	 vector to timeslice handler
    738  7a3a
    739  7a3a							; = 55 minimum return time (if segtime abort)
    740  7a3a
    741  7a3a							;---------------------------------------------------------------------------
    742  7a3a
    743  7a3a
    744  7a3a				   DrawAnother
    745  7a3a
    746  7a3a		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    747  7a3c		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    748  7a3e
    749  7a3e		       a4 84		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    750  7a40
    751  7a40		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    752  7a43		       bd a0 f0 	      lda	ScreenBuffer,x	; 4	     new character to draw
    753  7a46		       29 7f		      and	#~128	; 2
    754  7a48		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    755  7a4b
    756  7a4b		       88		      dey		; 2
    757  7a4c		       84 84		      sty	DrawStackPointer	; 3	     one less to draw
    758  7a4e		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7
    759  7a50
    760  7a50				   EnterStealCharDraw		;	     RAM bank MUST be at BANK_DRAW_BUFFERS
    761  7a50
    762  7a50		       ad 84 02 	      lda	INTIM	; 4
    763  7a53		       c9 05		      cmp	#SEGTIME_SCD_MIN	; 2
    764  7a55		       90 c4		      bcc	ExitStealCharDraw	; 2/3= 8
    765  7a57
    766  7a57		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    767  7a5a		       bc a0 f0 	      ldy	ScreenBuffer,x	; 4 =	8    new character to draw
    768  7a5d
    769  7a5d		       bd 00 f2 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
    770  7a60		       85 3e		      sta	SET_BANK_RAM	; 3
    771  7a62		       4c 41 f1 	      jmp	StealPart3	; 3 = 10    --> 18 cycles after check for SEGTIME_SCD_MIN
    772  7a65
    773  7a65
    774  7a65
    775  7a65
      0  7a65					      DEFINE_SUBROUTINE	DrawFullScreenMain	;=2484[-89]
      1  7a65		       00 0f	   BANK_DrawFullScreenMain =	_CURRENT_BANK
      2  7a65					      SUBROUTINE
      3  7a65				   DrawFullScreenMain
    777  7a65
    778  7a65							; Check the screen for all those characters that need to be redrawn
    779  7a65							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
    780  7a65							; the drawflags array is different to the ScreenBuffer array entry, then the
    781  7a65							; screenbuffer will need redrawing.
    782  7a65
    783  7a65				   CopyRow2
    784  7a65
    785  7a65				  -	      IF	MULTI_BANK_BOARD = YES
    786  7a65				  -	      lda	BDF_BoardBank	; 3
    787  7a65					      ELSE
    788  7a65		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
    789  7a67					      ENDIF
    790  7a67		       85 3e		      sta	SET_BANK_RAM	; 3
    791  7a69		       b3 e0		      lax	(BDF_BoardAddress),y	; 5
    792  7a6b		       9a		      txs		; 2
    793  7a6c		       b3 e2		      lax	(BDF_BoardAddress2),y	; 5(= 18[-1])
    794  7a6e
    795  7a6e		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    796  7a70		       85 3e		      sta	SET_BANK_RAM	; 3
    797  7a72		       bd cd f1 	      lda	CharReplacement,x	; 4
    798  7a75		       91 de		      sta	(BDF_DrawFlagAddress2),y	; 6
    799  7a77		       ba		      tsx		; 2
    800  7a78		       bd cd f1 	      lda	CharReplacement,x	; 4
    801  7a7b		       91 dc		      sta	(BDF_DrawFlagAddress),y	; 6(= 27)
    802  7a7d
    803  7a7d		       88		      dey		; 2
    804  7a7e		       10 e5		      bpl	CopyRow2	; 2/3=49/50[-1]
    805  7a80							; total: 5*(50[-1])-1 = 244 *OR*  249 (MB)
    806  7a80
    807  7a80		       a7 e5		      lax	DHS_Line	; 3
    808  7a82		       f0 07		      beq	.exitCopy	; 2/3= 5/6
    809  7a84
    810  7a84		       a0 0b		      ldy	#BANK_DrawScreenRowPreparation	;2
    811  7a86		       84 3f		      sty	SET_BANK	; 3
    812  7a88		       4c c2 f2 	      jmp	DrawScreenRowPreparation	;55[-7] = 60[-7]
    813  7a8b
    814  7a8b							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
    815  7a8b
    816  7a8b
      0  7a8b					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7a8b					      LIST	ON
    818  7a8b
    819  7a8b		       a6 e6	   .exitCopy  ldx	DHS_Stack	; 3
    820  7a8d		       9a		      txs		; 2
    821  7a8e
    822  7a8e							; fall through
    823  7a8e
      0  7a8e					      DEFINE_SUBROUTINE	BuildDrawStack
      1  7a8e		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7a8e					      SUBROUTINE
      3  7a8e				   BuildDrawStack
    825  7a8e
    826  7a8e		       a9 08		      lda	#BANK_DRAW_BUFFERS
    827  7a90		       85 3e		      sta	SET_BANK_RAM
    828  7a92		       4c f1 f0 	      jmp	DrawStackUpdate
    829  7a95
    830  7a95							;---------------------------------------------------------------------------
    831  7a95
      0  7a95					      DEFINE_SUBROUTINE	DrawAIntoStack
      1  7a95		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7a95					      SUBROUTINE
      3  7a95				   DrawAIntoStack
    833  7a95
    834  7a95		       a9 08		      lda	#BANK_DRAW_BUFFERS
    835  7a97		       85 3e		      sta	SET_BANK_RAM
    836  7a99		       4c 1a f1 	      jmp	DrawIntoStack
    837  7a9c
    838  7a9c
    839  7a9c							;---------------------------------------------------------------------------
    840  7a9c
    841  7a9c
    842  7a9c				   Reset
      0  7a9c					      CLEAN_START
      1  7a9c		       78		      sei
      2  7a9d		       d8		      cld
      3  7a9e
      4  7a9e		       a2 00		      ldx	#0
      5  7aa0		       8a		      txa
      6  7aa1		       a8		      tay
      7  7aa2		       ca	   .CLEAR_STACK dex
      8  7aa3		       9a		      txs
      9  7aa4		       48		      pha
     10  7aa5		       d0 fb		      bne	.CLEAR_STACK
     11  7aa7
    844  7aa7
    845  7aa7							;lda #2
    846  7aa7							;sta VSYNC
    847  7aa7							;lda #%01000010		  ; bit6 is not required
    848  7aa7							;sta VBLANK			  ; end of screen - enter blanking
    849  7aa7
    850  7aa7							; Scoring bank is copied once (not per game, not per level...)
    851  7aa7							; otherwise non-SaveKey high score gets zapped
    852  7aa7
    853  7aa7		       a2 02		      ldx	#ROM_SHADOW_OF_BANK_SCORING
    854  7aa9		       a0 09		      ldy	#BANK_SCORING
    855  7aab		       20 98 fc 	      jsr	CopyROM2RAM_F000
    856  7aae
    857  7aae				   Restart		; go here on RESET + SELECT
    858  7aae
    859  7aae
    860  7aae				   Title
    861  7aae		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
    862  7ab0		       9a		      txs
    863  7ab1
    864  7ab1							; temporary vars from title screen are used to init level
    865  7ab1		       a9 03		      lda	#BANK_Cart_Init	; 2
    866  7ab3		       85 3f		      sta	SET_BANK	; 3
    867  7ab5		       20 c2 f3 	      jsr	Cart_Init	; 6+x
    868  7ab8
    869  7ab8
    870  7ab8							;---------------------------------------------------------------------------
    871  7ab8
    872  7ab8
    873  7ab8		       f0 00	   SEGMENT_DECODE_LEVEL_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
    874  7ab8
    875  7ab8		       a2 03		      ldx	#BANK_DECODE_LEVEL_SHADOW
    876  7aba		       a0 0a		      ldy	#BANK_DECODE_LEVEL
    877  7abc		       20 98 fc 	      jsr	CopyROM2RAM_F000
    878  7abf
    879  7abf
    880  7abf							;---------------------------------------------------------------------------
    881  7abf							; Once-only game initialisation goes here...
    882  7abf							; now we have two players so things get a bit tricky
    883  7abf
    884  7abf		       a9 09		      lda	#BANK_SCORING
    885  7ac1		       85 3e		      sta	SET_BANK_RAM
    886  7ac3		       20 63 f3 	      jsr	GameInitialise
    887  7ac6
    888  7ac6
    889  7ac6							;---------------------------------------------------------------------------
    890  7ac6
------- FILE sound/intro1_init.asm LEVEL 3 PASS 4
      0  7ac6					      include	"sound/intro1_init.asm"
      1  7ac6							; TIATracker music player
      2  7ac6							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7ac6							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7ac6							; Email: andre.wichmann@gmx.de
      5  7ac6							;
      6  7ac6							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7ac6							; you may not use this file except in compliance with the License.
      8  7ac6							; You may obtain a copy of the License at
      9  7ac6							;
     10  7ac6							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7ac6							;
     12  7ac6							; Unless required by applicable law or agreed to in writing, software
     13  7ac6							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7ac6							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7ac6							; See the License for the specific language governing permissions and
     16  7ac6							; limitations under the License.
     17  7ac6
     18  7ac6							; Song author: 
     19  7ac6							; Song name: 
     20  7ac6
     21  7ac6							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7ac6
     23  7ac6							; =====================================================================
     24  7ac6							; Initialize music.
     25  7ac6							; Set tt_cur_pat_index_c0/1 to the indexes of the first patterns from
     26  7ac6							; tt_SequenceTable for each channel.
     27  7ac6							; Set tt_timer and tt_cur_note_index_c0/1 to 0.
     28  7ac6							; All other variables can start with any value.
     29  7ac6							; =====================================================================
     30  7ac6		       a9 00		      lda	#0
     31  7ac8		       85 d2		      sta	tt_cur_pat_index_c0
     32  7aca		       a9 05		      lda	#5
     33  7acc		       85 d3		      sta	tt_cur_pat_index_c1
     34  7ace							; the rest should be 0 already from startup code. If not,
     35  7ace							; set the following variables to 0 manually:
     36  7ace							; - tt_timer
     37  7ace							; - tt_cur_pat_index_c0
     38  7ace							; - tt_cur_pat_index_c1
     39  7ace							; - tt_cur_note_index_c0
     40  7ace							; - tt_cur_note_index_c1
     41  7ace
------- FILE BANK_FIXED.asm
    892  7ace
      0  7ace					      SET_PLATFORM
      1  7ace
      2  7ace
      3  7ace
      4  7ace
      5  7ace		       ad 82 02 	      lda	SWCHB
      6  7ad1		       2a		      rol
      7  7ad2		       2a		      rol
      8  7ad3		       2a		      rol
      9  7ad4		       29 03		      and	#%11
     10  7ad6		       49 02		      eor	#PAL
     11  7ad8		       85 81		      sta	Platform
    894  7ada
    895  7ada		       a9 0a		      lda	#BANK_TitleScreen
    896  7adc		       85 3f		      sta	SET_BANK
    897  7ade		       20 00 f0 	      jsr	TitleSequence
    898  7ae1
    899  7ae1				   RestartLevelNextPlayer
    900  7ae1
    901  7ae1
    902  7ae1							; a player has lost a life.
    903  7ae1							; store his vars, swap to other player, continue
    904  7ae1
    905  7ae1							;lda #BANK_SCORING
    906  7ae1							;sta SET_BANK_RAM
    907  7ae1							;jsr SwapPlayers
    908  7ae1
    909  7ae1		       a9 03		      lda	#BANK_SwapPlayersGeneric
    910  7ae3		       85 3f		      sta	SET_BANK
    911  7ae5		       20 19 f4 	      jsr	SwapPlayersGeneric
    912  7ae8
    913  7ae8				   NextLevelLevel
    914  7ae8				   skipDemoCheck
    915  7ae8
    916  7ae8							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
    917  7ae8							; including those for general systems function. But NOT those which do not need re-initialising between
    918  7ae8							; levels.
    919  7ae8		       a9 03		      lda	#BANK_LevelInit	; 2
    920  7aea		       85 3f		      sta	SET_BANK	; 3
    921  7aec		       20 68 f4 	      jsr	LevelInit	; 6+x
    922  7aef
    923  7aef		       a9 00		      lda	#0
    924  7af1		       85 dc		      sta	base_x
    925  7af3		       85 dd		      sta	base_y
    926  7af5
    927  7af5		       20 00 f8 	      jsr	DrawTimeFromROM	; Z-flag == 0!
    928  7af8
    929  7af8		       a9 0a		      lda	#BANK_DECODE_LEVEL
    930  7afa		       85 3e		      sta	SET_BANK_RAM
    931  7afc		       20 5f f2 	      jsr	UnpackLevel
    932  7aff
    933  7aff							; TODO now we KNOW the width, we can set the top left accordingly and re-unpack
    934  7aff
    935  7aff		       a9 28		      lda	#SIZE_BOARD_X
    936  7b01		       85 94		      sta	BoardLimit_Width
    937  7b03		       a9 16		      lda	#SIZE_BOARD_Y
    938  7b05		       85 95		      sta	BoardLimit_Height
    939  7b07
    940  7b07							; Setup player animation and scroll limits.
    941  7b07							; Mangle the board colours based on level
    942  7b07
    943  7b07		       a9 03		      lda	#BANK_CreateCreatures	; 2
    944  7b09		       85 3f		      sta	SET_BANK	; 3
    945  7b0b		       20 31 f4 	      jsr	CreateCreatures	; 6+x
    946  7b0e
    947  7b0e							; Setup the various digit and display pointers
    948  7b0e							; Grab current player's score/level from backup
    949  7b0e
    950  7b0e		       a9 09		      lda	#BANK_SCORING
    951  7b10		       85 3e		      sta	SET_BANK_RAM
    952  7b12		       20 91 f2 	      jsr	GeneralScoringSetups
    953  7b15							;lda ROM_Bank
    954  7b15							;sta SET_BANK
    955  7b15
    956  7b15							; copy the screen draw ROM shadow to RAM
    957  7b15
    958  7b15		       a0 07		      ldy	#SCREEN_LINES-1
    959  7b17		       a2 00	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
    960  7b19		       20 98 fc 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
    961  7b1c		       20 77 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
    962  7b1f		       88		      dey
    963  7b20		       10 f5		      bpl	CopyScreenBanks
    964  7b22
    965  7b22		       a2 01		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    966  7b24		       a0 08		      ldy	#BANK_DRAW_BUFFERS
    967  7b26		       20 43 f0 	      jsr	CopyROMShadowToRAM_F000
    968  7b29
    969  7b29							;---------------------------------------------------------------------------
    970  7b29
    971  7b29		       a9 03		      lda	#BANK_Resync	; 2
    972  7b2b		       85 3f		      sta	SET_BANK	; 3
    973  7b2d		       20 93 f4 	      jsr	Resync	; 6+x
    974  7b30
    975  7b30				   NewFrameStart
    976  7b30
    977  7b30		       24 cc		      bit	NextLevelTrigger
    978  7b32		       10 b4		      bpl	NextLevelLevel	; game-triggered next level
    979  7b34		       70 ab		      bvs	RestartLevelNextPlayer	; loss of life
    980  7b36
    981  7b36							; Note: VSYNC must NOT be on when starting a new level! Else you get annoying TV signals.
    982  7b36
    983  7b36		       a9 0e		      lda	#%1110	; VSYNC ON
    984  7b38		       85 42	   .loopVSync sta	WSYNC
    985  7b3a		       85 40		      sta	VSYNC
    986  7b3c		       4a		      lsr
    987  7b3d		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
    988  7b3f
    989  7b3f							; moved *after* the loop since this allows to *increase* timer values by 1!
    990  7b3f
    991  7b3f		       a6 81		      ldx	Platform
    992  7b41		       bc 65 fc 	      ldy	VBlankTime,x
    993  7b44		       8c 96 02 	      sty	TIM64T
    994  7b47
    995  7b47
------- FILE sound/intro1_player.asm LEVEL 3 PASS 4
      0  7b47					      include	"sound/intro1_player.asm"
      1  7b47							; TIATracker music player
      2  7b47							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7b47							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7b47							; Email: andre.wichmann@gmx.de
      5  7b47							;
      6  7b47							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7b47							; you may not use this file except in compliance with the License.
      8  7b47							; You may obtain a copy of the License at
      9  7b47							;
     10  7b47							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7b47							;
     12  7b47							; Unless required by applicable law or agreed to in writing, software
     13  7b47							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7b47							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7b47							; See the License for the specific language governing permissions and
     16  7b47							; limitations under the License.
     17  7b47
     18  7b47							; Song author: 
     19  7b47							; Song name: 
     20  7b47
     21  7b47							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7b47
     23  7b47							; =====================================================================
     24  7b47							; TIATracker Player
     25  7b47							; =====================================================================
     26  7b47				   tt_PlayerStart
     27  7b47
     28  7b47							; PLANNED PLAYER VARIANTS:
     29  7b47							; - RAM, speed, player ROM: c0/c1 patterns have same length
     30  7b47							; - RAM: Pack 2 values (out of cur_pat_index, cur_note_index, envelope_index)
     31  7b47							;	 into one and use lsr/asl to unpack them, allowing only ranges of
     32  7b47							;	 16/16 or 32/8 for them, depending on number of patterns, max
     33  7b47							;	 pattern size and max ADSR size
     34  7b47							; - ROM: Check if tt_SequenceTable can hold ptrs directly without indexing
     35  7b47							;	 tt_PatternPtrLo/Hi. Can be smaller if not many patterns get repeated
     36  7b47							;	 (saves table and decode routine)
     37  7b47							; - Speed: Inline tt_CalcInsIndex
     38  7b47							; - Speed: Store ptr to current note in RAM instead of reconstructing it?
     39  7b47							;	 Might also save the need for cur_note_index
     40  7b47
     41  7b47
     42  7b47							; ---------------------------------------------------------------------
     43  7b47							; Helper macro: Retrieves current note. May advance pattern if needed.
     44  7b47							; Becomes a subroutine if TT_USE_OVERLAY is used.
     45  7b47							; ---------------------------------------------------------------------
     46  7b47					      MAC	tt_fetch_current_note
     47  7b47							; construct ptr to pattern
     48  7b47				   .constructPatPtr
     49  7b47					      ldy	tt_cur_pat_index_c0,x	; get current pattern (index into tt_SequenceTable)
     50  7b47					      lda	tt_SequenceTable,y
     51  7b47					      IF	TT_USE_GOTO = 1
     52  7b47					      bpl	.noPatternGoto
     53  7b47					      and	#%01111111	; mask out goto bit to get pattern number
     54  7b47					      sta	tt_cur_pat_index_c0,x	; store goto'ed pattern index
     55  7b47					      bpl	.constructPatPtr	; unconditional
     56  7b47				   .noPatternGoto
     57  7b47					      ENDIF
     58  7b47					      tay
     59  7b47					      lda	tt_PatternPtrLo,y
     60  7b47					      sta	tt_ptr
     61  7b47					      lda	tt_PatternPtrHi,y
     62  7b47					      sta	tt_ptr+1
     63  7b47							; get new note
     64  7b47					      IF	TT_USE_OVERLAY = 0
     65  7b47					      ldy	tt_cur_note_index_c0,x
     66  7b47					      ELSE
     67  7b47							; If the V flag is set and if the new note is an instrument,
     68  7b47							; it means it got pre-fetched by an overlay percussion, it has
     69  7b47							; to remain in sustain.
     70  7b47					      clv
     71  7b47							; check if note had been pre-fetched by overlay perc already
     72  7b47					      lda	tt_cur_note_index_c0,x
     73  7b47					      bpl	.notPrefetched
     74  7b47							; If so, remove flag
     75  7b47					      and	#%01111111
     76  7b47					      sta	tt_cur_note_index_c0,x
     77  7b47							; Set V flag for later
     78  7b47					      bit	tt_Bit6Set
     79  7b47				   .notPrefetched
     80  7b47					      tay
     81  7b47					      ENDIF
     82  7b47					      lda	(tt_ptr),y
     83  7b47							; pre-process new note
     84  7b47							; 7..5: instrument (1..7), 4..0 (0..31): frequency
     85  7b47							; 0/0: End of pattern
     86  7b47					      bne	.noEndOfPattern
     87  7b47							; End of pattern: Advance to next pattern
     88  7b47					      sta	tt_cur_note_index_c0,x	; a is 0
     89  7b47					      inc	tt_cur_pat_index_c0,x
     90  7b47					      bne	.constructPatPtr	; unconditional
     91  7b47				   .noEndOfPattern
     92  7b47					      ENDM
     93  7b47
     94  7b47
     95  7b47							; ---------------------------------------------------------------------
     96  7b47							; Music player entry. Call once per frame.
     97  7b47							; ---------------------------------------------------------------------
     98  7b47				   tt_Player  SUBROUTINE
     99  7b47							; ==================== Sequencer ====================
    100  7b47							; Decrease speed timer
    101  7b47		       c6 d1		      dec	tt_timer
    102  7b49		       10 6e		      bpl	.noNewNote
    103  7b4b
    104  7b4b							; Timer ran out: Do sequencer
    105  7b4b							; Advance to next note
    106  7b4b		       a2 01		      ldx	#1	; 2 channels
    107  7b4d				   .advanceLoop
    108  7b4d					      IF	TT_USE_OVERLAY = 1
    109  7b4d		       20 63 fb 	      jsr	tt_FetchNote
    110  7b50				  -	      ELSE
    111  7b50				  -	      TT_FETCH_CURRENT_NOTE
    112  7b50					      ENDIF
    113  7b50							; Parse new note from pattern
    114  7b50		       c9 10		      cmp	#TT_INS_PAUSE
    115  7b52					      IF	TT_USE_SLIDE = 0
    116  7b52		       90 55		      bcc	.finishedNewNote
    117  7b54		       d0 3d		      bne	.newNote
    118  7b56				  -	      ELSE
    119  7b56				  -	      beq	.pause
    120  7b56				  -	      bcs	.newNote
    121  7b56				  -
    122  7b56				  -			; --- slide/hold ---
    123  7b56				  -			; Adjust frequency and hold note in sustain.
    124  7b56				  -			; composer/tracker has to make sure that no unwanted
    125  7b56				  -			; under/overflow happens.
    126  7b56				  -			; Note: f = f + (8-(16-x)) = x + f - 8
    127  7b56				  -	      adc	tt_cur_ins_c0,x	; carry is clear after cmp
    128  7b56				  -	      sec
    129  7b56				  -	      sbc	#8
    130  7b56				  -	      sta	tt_cur_ins_c0,x
    131  7b56				  -	      bcs	.finishedNewNote	; unconditional, since legally no underflow can happen (ins>0 or HOLD for ins=0)
    132  7b56					      ENDIF
    133  7b56
    134  7b56							; --- pause ---
    135  7b56				   .pause
    136  7b56							; Get release index for current instrument. Since a pause can
    137  7b56							; only follow an instrument, we don't need to handle percussion
    138  7b56							; or commands.
    139  7b56		       b5 d8		      lda	tt_cur_ins_c0,x
    140  7b58		       20 f1 fb 	      jsr	tt_CalcInsIndex
    141  7b5b		       b9 af fc 	      lda	tt_InsReleaseIndexes-1,y	; -1 b/c instruments start at #1
    142  7b5e							; Put it into release. Skip junk byte so index no longer indicates
    143  7b5e							; sustain phase.
    144  7b5e		       18		      clc
    145  7b5f		       69 01		      adc	#1
    146  7b61		       90 44		      bcc	.storeADIndex	; unconditional
    147  7b63
    148  7b63							; ---------------------------------------------------------------------
    149  7b63							; Helper subroutine to minimize ROM footprint. Will be inlined if
    150  7b63							; TT_USE_OVERLAY is not used.
    151  7b63							; Interleaved here so player can be inlined.
    152  7b63							; ---------------------------------------------------------------------
    153  7b63					      IF	TT_USE_OVERLAY = 1
    154  7b63				   tt_FetchNote
      0  7b63					      TT_FETCH_CURRENT_NOTE
      1  7b63
      2  7b63				   .constructPatPtr
      3  7b63		       b4 d2		      ldy	tt_cur_pat_index_c0,x
      4  7b65		       b9 c2 fd 	      lda	tt_SequenceTable,y
      5  7b68					      IF	TT_USE_GOTO = 1
      6  7b68		       10 06		      bpl	.noPatternGoto
      7  7b6a		       29 7f		      and	#%01111111
      8  7b6c		       95 d2		      sta	tt_cur_pat_index_c0,x
      9  7b6e		       10 f3		      bpl	.constructPatPtr
     10  7b70				   .noPatternGoto
     11  7b70					      ENDIF
     12  7b70		       a8		      tay
     13  7b71		       b9 b8 fd 	      lda	tt_PatternPtrLo,y
     14  7b74		       85 da		      sta	tt_ptr
     15  7b76		       b9 bd fd 	      lda	tt_PatternPtrHi,y
     16  7b79		       85 db		      sta	tt_ptr+1
     17  7b7b
     18  7b7b				  -	      IF	TT_USE_OVERLAY = 0
     19  7b7b				  -	      ldy	tt_cur_note_index_c0,x
     20  7b7b					      ELSE
     21  7b7b
     22  7b7b
     23  7b7b
     24  7b7b		       b8		      clv
     25  7b7c
     26  7b7c		       b5 d4		      lda	tt_cur_note_index_c0,x
     27  7b7e		       10 07		      bpl	.notPrefetched
     28  7b80
     29  7b80		       29 7f		      and	#%01111111
     30  7b82		       95 d4		      sta	tt_cur_note_index_c0,x
     31  7b84
     32  7b84		       2c f7 fb 	      bit	tt_Bit6Set
     33  7b87				   .notPrefetched
     34  7b87		       a8		      tay
     35  7b88					      ENDIF
     36  7b88		       b1 da		      lda	(tt_ptr),y
     37  7b8a
     38  7b8a
     39  7b8a
     40  7b8a		       d0 06		      bne	.noEndOfPattern
     41  7b8c
     42  7b8c		       95 d4		      sta	tt_cur_note_index_c0,x
     43  7b8e		       f6 d2		      inc	tt_cur_pat_index_c0,x
     44  7b90		       d0 d1		      bne	.constructPatPtr
     45  7b92				   .noEndOfPattern
    156  7b92		       60		      rts
    157  7b93					      ENDIF
    158  7b93
    159  7b93
    160  7b93							; --- start instrument or percussion ---
    161  7b93				   .newNote
    162  7b93		       95 d8		      sta	tt_cur_ins_c0,x	; set new instrument
    163  7b95							; Instrument or percussion?
    164  7b95		       c9 20		      cmp	#TT_FREQ_MASK+1
    165  7b97		       b0 06		      bcs	.startInstrument
    166  7b99
    167  7b99							; --- start percussion ---
    168  7b99							; Get index of envelope
    169  7b99		       a8		      tay
    170  7b9a							; -TT_FIRST_PERC because percussion start with TT_FIRST_PERC
    171  7b9a		       b9 d3 fc 	      lda	tt_PercIndexes-TT_FIRST_PERC,y
    172  7b9d		       d0 08		      bne	.storeADIndex	; unconditional, since index values are >0
    173  7b9f
    174  7b9f							; --- start instrument ---
    175  7b9f				   .startInstrument
    176  7b9f					      IF	TT_USE_OVERLAY = 1
    177  7b9f							; If V flag is set, this note had been pre-fetched. That means
    178  7b9f							; it should remain in sustain.
    179  7b9f		       70 08		      bvs	.finishedNewNote
    180  7ba1					      ENDIF
    181  7ba1							; Put note into attack/decay
    182  7ba1		       20 f1 fb 	      jsr	tt_CalcInsIndex
    183  7ba4		       b9 a5 fc 	      lda	tt_InsADIndexes-1,y	; -1 because instruments start at #1
    184  7ba7				   .storeADIndex
    185  7ba7		       95 d6		      sta	tt_envelope_index_c0,x
    186  7ba9
    187  7ba9							; --- Finished parsing new note ---
    188  7ba9				   .finishedNewNote
    189  7ba9							; increase note index into pattern
    190  7ba9		       f6 d4		      inc	tt_cur_note_index_c0,x
    191  7bab							; loop over channels
    192  7bab				   .sequencerNextChannel
    193  7bab		       ca		      dex
    194  7bac		       10 9f		      bpl	.advanceLoop
    195  7bae
    196  7bae							; Reset timer value
    197  7bae				  -	      IF	TT_GLOBAL_SPEED = 0
    198  7bae				  -			; Get timer value for current pattern in channel 0
    199  7bae				  -	      ldx	tt_cur_pat_index_c0	; get current pattern (index into tt_SequenceTable)
    200  7bae				  -	      ldy	tt_SequenceTable,x	; Current pattern index now in y
    201  7bae				  -	      IF	TT_USE_FUNKTEMPO = 0
    202  7bae				  -	      lda	tt_PatternSpeeds,y
    203  7bae				  -	      sta	tt_timer
    204  7bae				  -	      ELSE
    205  7bae				  -			; Test for odd/even frame
    206  7bae				  -	      lda	tt_cur_note_index_c0
    207  7bae				  -	      lsr
    208  7bae				  -	      lda	tt_PatternSpeeds,y	; does not affect carry flag
    209  7bae				  -	      bcc	.evenFrame
    210  7bae				  -	      and	#$0f	; does not affect carry flag
    211  7bae				  -	      bcs	.storeFunkTempo
    212  7bae				  -.evenFrame
    213  7bae				  -	      lsr
    214  7bae				  -	      lsr
    215  7bae				  -	      lsr
    216  7bae				  -	      lsr
    217  7bae				  -.storeFunkTempo
    218  7bae				  -	      sta	tt_timer
    219  7bae				  -	      ENDIF		; TT_USE_FUNKTEMPO = 0
    220  7bae				  -
    221  7bae					      ELSE
    222  7bae							; Global tempo
    223  7bae		       a2 04		      ldx	#TT_SPEED-1
    224  7bb0					      IF	TT_USE_FUNKTEMPO = 1
    225  7bb0		       a5 d4		      lda	tt_cur_note_index_c0
    226  7bb2		       4a		      lsr
    227  7bb3		       90 02		      bcc	.noOddFrame
    228  7bb5		       a2 03		      ldx	#TT_ODD_SPEED-1
    229  7bb7				   .noOddFrame
    230  7bb7					      ENDIF		; TT_USE_FUNKTEMPO = 1
    231  7bb7		       86 d1		      stx	tt_timer
    232  7bb9					      ENDIF		; TT_GLOBAL_SPEED = 0
    233  7bb9
    234  7bb9							; No new note to process
    235  7bb9				   .noNewNote
    236  7bb9
    237  7bb9							; ==================== Update registers ====================
    238  7bb9		       a2 01		      ldx	#1	; 2 channels
    239  7bbb				   .updateLoop
    240  7bbb							; Percussion or melodic instrument?
    241  7bbb		       b5 d8		      lda	tt_cur_ins_c0,x
    242  7bbd				  -	      IF	TT_STARTS_WITH_NOTES = 0
    243  7bbd				  -			; This branch can be removed if track starts with a note in each channel
    244  7bbd				  -	      beq	.afterAudioUpdate
    245  7bbd					      ENDIF
    246  7bbd		       c9 20		      cmp	#TT_FREQ_MASK+1
    247  7bbf		       b0 37		      bcs	.instrument	; Melodic instrument
    248  7bc1
    249  7bc1							; --- Percussion: Get envelope index ---
    250  7bc1		       b4 d6		      ldy	tt_envelope_index_c0,x
    251  7bc3							; Set AUDC and AUDV value from envelope
    252  7bc3		       b9 fc fc 	      lda	tt_PercCtrlVolTable-1,y	; -1 because values are stored +1
    253  7bc6		       f0 02		      beq	.endOfPercussion	; 0 means end of percussion data
    254  7bc8		       f6 d6		      inc	tt_envelope_index_c0,x	; if end not reached: advance index
    255  7bca				   .endOfPercussion
    256  7bca		       95 59		      sta	AUDV0,x
    257  7bcc		       4a		      lsr
    258  7bcd		       4a		      lsr
    259  7bce		       4a		      lsr
    260  7bcf		       4a		      lsr
    261  7bd0		       95 55		      sta	AUDC0,x
    262  7bd2							; Set AUDF
    263  7bd2		       b9 e6 fc 	      lda	tt_PercFreqTable-1,y	; -1 because values are stored +1
    264  7bd5							; Bit 7 (overlay) might be set, but is unused in AUDF
    265  7bd5		       95 57		      sta	AUDF0,x
    266  7bd7					      IF	TT_USE_OVERLAY = 1
    267  7bd7		       10 48		      bpl	.afterAudioUpdate
    268  7bd9							; Overlay percussion: Fetch next note out of order
    269  7bd9		       20 63 fb 	      jsr	tt_FetchNote
    270  7bdc							; Only do something if it's a melodic instrument
    271  7bdc		       c9 20		      cmp	#TT_FREQ_MASK+1
    272  7bde		       90 41		      bcc	.afterAudioUpdate
    273  7be0							; Instrument: Put into sustain
    274  7be0		       95 d8		      sta	tt_cur_ins_c0,x	; set new instrument
    275  7be2		       20 f1 fb 	      jsr	tt_CalcInsIndex
    276  7be5		       b9 aa fc 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start at #1
    277  7be8		       95 d6		      sta	tt_envelope_index_c0,x
    278  7bea							; Set prefetch flag. asl-sec-ror is smaller than lda-ora #128-sta
    279  7bea		       16 d4		      asl	tt_cur_note_index_c0,x
    280  7bec		       38		      sec
    281  7bed		       76 d4		      ror	tt_cur_note_index_c0,x
    282  7bef		       30 30		      bmi	.afterAudioUpdate	; unconditional
    283  7bf1				  -	      ELSE
    284  7bf1				  -	      jmp	.afterAudioUpdate
    285  7bf1					      ENDIF
    286  7bf1
    287  7bf1
    288  7bf1							; ---------------------------------------------------------------------
    289  7bf1							; Helper subroutine to minimize ROM footprint.
    290  7bf1							; Interleaved here so player routine can be inlined.
    291  7bf1							; ---------------------------------------------------------------------
    292  7bf1				   tt_CalcInsIndex
    293  7bf1							; move upper 3 bits to lower 3
    294  7bf1		       4a		      lsr
    295  7bf2		       4a		      lsr
    296  7bf3		       4a		      lsr
    297  7bf4		       4a		      lsr
    298  7bf5		       4a		      lsr
    299  7bf6		       a8		      tay
    300  7bf7				   tt_Bit6Set		; This opcode has bit #6 set, for use with bit instruction
    301  7bf7		       60		      rts
    302  7bf8
    303  7bf8
    304  7bf8				   .instrument
    305  7bf8							; --- Melodic instrument ---
    306  7bf8							; Compute index into ADSR indexes and master Ctrl tables
    307  7bf8		       20 f1 fb 	      jsr	tt_CalcInsIndex
    308  7bfb							; Set AUDC with master value for this instrument, while we are at it
    309  7bfb		       b9 a0 fc 	      lda	tt_InsCtrlTable-1,y	; -1 because instruments start with #1
    310  7bfe		       95 55		      sta	AUDC0,x
    311  7c00							; advance ADSR counter and compare to end of Sustain
    312  7c00		       b5 d6		      lda	tt_envelope_index_c0,x
    313  7c02		       d9 af fc 	      cmp	tt_InsReleaseIndexes-1,y	; -1 because instruments start with #1
    314  7c05		       d0 03		      bne	.noEndOfSustain
    315  7c07							; End of sustain: Go back to start of sustain
    316  7c07		       b9 aa fc 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start with #1
    317  7c0a				   .noEndOfSustain
    318  7c0a		       a8		      tay
    319  7c0b							; Set volume from envelope
    320  7c0b		       b9 b5 fc 	      lda	tt_InsFreqVolTable,y
    321  7c0e		       f0 01		      beq	.endOfEnvelope	; 0 means end of release has been reached:
    322  7c10		       c8		      iny		; advance index otherwise
    323  7c11				   .endOfEnvelope
    324  7c11		       94 d6		      sty	tt_envelope_index_c0,x
    325  7c13		       95 59		      sta	AUDV0,x
    326  7c15							; Now adjust frequency with ADSR value from envelope
    327  7c15		       4a		      lsr
    328  7c16		       4a		      lsr
    329  7c17		       4a		      lsr
    330  7c18		       4a		      lsr
    331  7c19		       18		      clc
    332  7c1a		       75 d8		      adc	tt_cur_ins_c0,x
    333  7c1c		       38		      sec
    334  7c1d		       e9 08		      sbc	#8
    335  7c1f		       95 57		      sta	AUDF0,x
    336  7c21
    337  7c21				   .afterAudioUpdate
    338  7c21							; loop over channels
    339  7c21		       ca		      dex
    340  7c22		       10 97		      bpl	.updateLoop
    341  7c24
 Music player size:  $dd
    342  7c24					      echo	"Music player size: ", *-tt_PlayerStart
------- FILE BANK_FIXED.asm
    997  7c24
    998  7c24		       20 13 fa 	      jsr	StealCharDraw	; NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
    999  7c27
   1000  7c27							;---------------------------------------------------------------------------
   1001  7c27							; START OF DISPLAY
   1002  7c27
   1003  7c27		       a9 09		      lda	#BANK_SCORING	; 2
   1004  7c29		       85 3e		      sta	SET_BANK_RAM	; 3
   1005  7c2b		       20 d5 f1 	      jsr	DrawDigits	; 6 = 11
   1006  7c2e
   1007  7c2e
   1008  7c2e							;---------------------------------------------------------------------------
   1009  7c2e							; A 42-cycle timing window in the screen draw code.  Perform any general
   1010  7c2e							; per-frame code here, provided it takes exactly 42 cycles to execute.
   1011  7c2e							; TJ: Well, not exactly 42 cycles, but it works! :)
   1012  7c2e							;	 @09
   1013  7c2e							;sta COLUBK		      ; 3     value comes from subroutine
   1014  7c2e							; + the 'black' left-side of top screen colour change when look-around is actually a HMOVE bar, so we can't fix it :)
   1015  7c2e
   1016  7c2e							;		  inc Throttle		      ; 5     speed limiter
      0  7c2e					      SLEEP	2	;	 TODO: optimize for space
      1  7c2e				   .CYCLES    SET	2
      2  7c2e
      3  7c2e				  -	      IF	.CYCLES < 2
      4  7c2e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c2e				  -	      ERR
      6  7c2e					      ENDIF
      7  7c2e
      8  7c2e				  -	      IF	.CYCLES & 1
      9  7c2e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c2e				  -	      nop	0
     11  7c2e				  -	      ELSE
     12  7c2e				  -	      bit	VSYNC
     13  7c2e				  -	      ENDIF
     14  7c2e				  -.CYCLES    SET	.CYCLES - 3
     15  7c2e					      ENDIF
     16  7c2e
     17  7c2e					      REPEAT	.CYCLES / 2
     18  7c2e		       ea		      nop
     19  7c2f					      REPEND
   1018  7c2f
   1019  7c2f		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
   1020  7c31		       ca		      dex		; 2	 = $6f, stars effect!
   1021  7c32		       86 62		      stx	HMM0	; 3	 @24, exactly 21 cycles after the HMOVE
   1022  7c34
   1023  7c34		       85 44		      sta	NUSIZ0	; 3
   1024  7c36		       84 65		      sty	VDELP0	; 3	 y = 0!
   1025  7c38
   1026  7c38		       c8		      iny		; 2	 this relies on Y == 0 before...
   1027  7c39		       c4 c9		      cpy	extraLifeTimer	; 3	 ..,and bit 0 is set in A
   1028  7c3b		       69 02		      adc	#2	; 2
   1029  7c3d		       85 5d		      sta	ENAM0	; 3	 dis/enable Cosmic Ark star effect
   1030  7c3f
   1031  7c3f		       a5 a4		      lda	ManLastDirection	; 3
   1032  7c41		       85 4b		      sta	REFP0	; 3
   1033  7c43
   1034  7c43		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
   1035  7c45		       85 3f		      sta	SET_BANK	; testing
   1036  7c47		       85 3e		      sta	SET_BANK_RAM	; 3
   1037  7c49		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1038  7c4c							;	 @66
   1039  7c4c		       a9 03		      lda	#BANK_PostScreenCleanup	; 2
   1040  7c4e		       85 3f		      sta	SET_BANK	; 3
   1041  7c50		       20 59 f5 	      jsr	PostScreenCleanup	; 6+x
   1042  7c53
   1043  7c53		       a9 00		      lda	#BANK_SelfModDrawPlayers	; 2
   1044  7c55		       85 3f		      sta	SET_BANK	; 3
   1045  7c57		       20 8c f2 	      jsr	SelfModDrawPlayers	; 6+x
   1046  7c5a
   1047  7c5a		       20 13 fa 	      jsr	StealCharDraw
   1048  7c5d
   1049  7c5d		       ad 84 02    OverscanBD lda	INTIM	;4
   1050  7c60		       d0 fb		      bne	OverscanBD	;2/3
   1051  7c62		       4c 30 fb 	      jmp	NewFrameStart
   1052  7c65				   VBlankTime
   1053  7c65		       32 32		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
   1054  7c67		       55 55		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_PAL
   1055  7c69
   1056  7c69
   1057  7c69				  -	      if	0
   1058  7c69				  -	      DEFINE_SUBROUTINE	SokoScreen
   1059  7c69				  -
   1060  7c69				  -
   1061  7c69				  -
   1062  7c69				  -			;---------------------------------------------------------------------------
   1063  7c69				  -			; A 42-cycle timing window in the screen draw code.  Perform any general
   1064  7c69				  -			; per-frame code here, provided it takes exactly 42 cycles to execute.
   1065  7c69				  -			; TJ: Well, not exactly 42 cycles, but it works! :)
   1066  7c69				  -			;	 @09
   1067  7c69				  -			;sta COLUBK		      ; 3     value comes from subroutine
   1068  7c69				  -			; + the 'black' left-side of top screen colour change when look-around is actually a HMOVE bar, so we can't fix it :)
   1069  7c69				  -
   1070  7c69				  -			;		  inc Throttle		      ; 5     speed limiter
   1071  7c69				  -	      SLEEP	5	;	 TODO: optimize for space
   1072  7c69				  -
   1073  7c69				  -	      lda	#%00010101	; 2	 double width missile, double width player
   1074  7c69				  -	      dex		; 2	 = $6f, stars effect!
   1075  7c69				  -	      stx	HMM0	; 3	 @24, exactly 21 cycles after the HMOVE
   1076  7c69				  -
   1077  7c69				  -	      sta	NUSIZ0	; 3
   1078  7c69				  -	      sty	VDELP0	; 3	 y = 0!
   1079  7c69				  -
   1080  7c69				  -	      iny		; 2	 this relies on Y == 0 before...
   1081  7c69				  -	      cpy	extraLifeTimer	; 3	 ..,and bit 0 is set in A
   1082  7c69				  -	      adc	#2	; 2
   1083  7c69				  -	      sta	ENAM0	; 3	 dis/enable Cosmic Ark star effect
   1084  7c69				  -
   1085  7c69				  -	      lda	ManLastDirection	; 3
   1086  7c69				  -	      sta	REFP0	; 3		    lda #BANK_SCREENMARKII1	; 2
   1087  7c69				  -	      sta	SET_BANK_RAM	; 3
   1088  7c69				  -	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1089  7c69				  -			;	 @66
   1090  7c69				  -	      lda	#BANK_PostScreenCleanup	; 2
   1091  7c69				  -	      sta	SET_BANK	; 3
   1092  7c69				  -	      jsr	PostScreenCleanup	; 6+x
   1093  7c69				  -
   1094  7c69				  -	      lda	#BANK_SelfModDrawPlayers	; 2
   1095  7c69				  -	      sta	SET_BANK	; 3
   1096  7c69				  -	      jsr	SelfModDrawPlayers	; 6+x
   1097  7c69				  -
   1098  7c69				  -frame
   1099  7c69				  -	      jsr	StealCharDraw
   1100  7c69				  -	      lda	INTIM
   1101  7c69				  -	      bne	frame
   1102  7c69				  -
   1103  7c69				  -
   1104  7c69				  -	      lda	#BANK_TitleScreen
   1105  7c69				  -	      sta	SET_BANK
   1106  7c69				  -	      rts
   1107  7c69					      endif
   1108  7c69
   1109  7c69							;---------------------------------------------------------------------------
   1110  7c69
      0  7c69					      DEFINE_SUBROUTINE	nextLevelMan
      1  7c69		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7c69					      SUBROUTINE
      3  7c69				   nextLevelMan
   1112  7c69
   1113  7c69		       a9 14		      lda	#20
   1114  7c6b		       85 a8		      sta	DelayEndOfLevel
   1115  7c6d		       a9 14		      lda	#20
   1116  7c6f		       85 c8		      sta	ColourTimer
   1117  7c71
   1118  7c71
   1119  7c71		       a9 00		      lda	#0
   1120  7c73		       85 aa		      sta	circle_d
   1121  7c75		       85 ab		      sta	circle_d+1
   1122  7c77
   1123  7c77				  -	      if	0
   1124  7c77				  -
   1125  7c77				  -			; Fire up a circle-drawing special-effect object...
   1126  7c77				  -
   1127  7c77				  -
   1128  7c77				  -	      lda	#TYPE_CIRCLE
   1129  7c77				  -	      sta	POS_Type
   1130  7c77				  -	      jsr	InsertObjectStack
   1131  7c77				  -
   1132  7c77					      endif
   1133  7c77
   1134  7c77
   1135  7c77				  -	      if	0
   1136  7c77				  -	      lda	#$08
   1137  7c77				  -	      sta	color
   1138  7c77				  -	      lda	#$04
   1139  7c77				  -	      sta	color+1
   1140  7c77				  -	      lda	#$0A
   1141  7c77				  -	      sta	color+2
   1142  7c77					      endif
   1143  7c77		       e6 9f		      inc	ManMode
   1144  7c79		       60		      rts
   1145  7c7a
      0  7c7a					      DEFINE_SUBROUTINE	nextLevelMan2
      1  7c7a		       00 0f	   BANK_nextLevelMan2 =	_CURRENT_BANK
      2  7c7a					      SUBROUTINE
      3  7c7a				   nextLevelMan2
   1147  7c7a
   1148  7c7a				  -	      if	0
   1149  7c7a				  -	      ldy	#SCREEN_LINES-1
   1150  7c7a				  -CopyScreenBank2 ldx	#ROM_SHADOW_OF_RAMBANK_CODE
   1151  7c7a				  -	      sty	RAM_Bank
   1152  7c7a				  -	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
   1153  7c7a				  -	      dey
   1154  7c7a				  -	      bpl	CopyScreenBank2
   1155  7c7a				  -
   1156  7c7a				  -	      ldx	#2
   1157  7c7a				  -fade       lda	color,x
   1158  7c7a				  -	      and	#$F
   1159  7c7a				  -	      bne	nz
   1160  7c7a				  -	      lda	#1
   1161  7c7a				  -	      sta	color,x
   1162  7c7a				  -nz	      dec	color,x
   1163  7c7a				  -zalready   dex
   1164  7c7a				  -	      bpl	fade
   1165  7c7a					      endif
   1166  7c7a
   1167  7c7a							;dec DelayEndOfLevel
   1168  7c7a							;beq goNL3
   1169  7c7a
   1170  7c7a		       e6 ab		      inc	circle_d+1
   1171  7c7c		       a5 ab		      lda	circle_d+1
   1172  7c7e		       c9 14		      cmp	#20
   1173  7c80		       b0 01		      bcs	goNL3
   1174  7c82
   1175  7c82
   1176  7c82		       60		      rts
   1177  7c83
   1178  7c83				   goNL3
   1179  7c83		       e6 9f		      inc	ManMode
   1180  7c85
      0  7c85					      DEFINE_SUBROUTINE	switchLevels
      1  7c85		       00 0f	   BANK_switchLevels =	_CURRENT_BANK
      2  7c85					      SUBROUTINE
      3  7c85				   switchLevels
   1182  7c85
   1183  7c85							;lda #BANK_NextLevelX
   1184  7c85							;sta SET_BANK
   1185  7c85							;jmp NextLevelX
   1186  7c85
   1187  7c85							; Now do the actual switching
   1188  7c85
   1189  7c85		       a5 cc		      lda	NextLevelTrigger
   1190  7c87		       29 7f		      and	#<(~BIT_NEXTLEVEL)
   1191  7c89		       85 cc		      sta	NextLevelTrigger
   1192  7c8b
   1193  7c8b							; Next level is due. Point to the next level, but if we're at the end of playable levels,
   1194  7c8b							; then increment the level number. This is completely circular, so we eventually wrap
   1195  7c8b							; the level back to 0 and start afresh.
   1196  7c8b
   1197  7c8b		       e6 b6		      inc	levelX
   1198  7c8d		       a5 b6		      lda	levelX
   1199  7c8f		       c9 9d		      cmp	#MAX_LEVEL_NUMBER
   1200  7c91		       90 02		      bcc	.level_ok
   1201  7c93		       a9 00		      lda	#0
   1202  7c95		       85 b6	   .level_ok  sta	levelX
   1203  7c97		       60		      rts
   1204  7c98
   1205  7c98							;---------------------------------------------------------------------------
   1206  7c98
   1207  7c98
      0  7c98					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7c98		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7c98					      SUBROUTINE
      3  7c98				   CopyROM2RAM_F000
   1209  7c98
   1210  7c98		       a9 0b		      lda	#BANK_CopyROMShadowToRAM
   1211  7c9a		       85 3f		      sta	SET_BANK
   1212  7c9c		       85 c6		      sta	ROM_Bank
   1213  7c9e		       4c 43 f0 	      jmp	CopyROMShadowToRAM_F000
   1214  7ca1
   1215  7ca1
   1216  7ca1							;---------------------------------------------------------------------------
   1217  7ca1
   1218  7ca1							;---------------------------------------------------------------------------
   1219  7ca1
   1220  7ca1							;include "circle.asm"
------- FILE sound/intro1_trackdata.asm LEVEL 3 PASS 4
      0  7ca1					      include	"sound/intro1_trackdata.asm"
      1  7ca1							; TIATracker music player
      2  7ca1							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7ca1							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7ca1							; Email: andre.wichmann@gmx.de
      5  7ca1							;
      6  7ca1							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7ca1							; you may not use this file except in compliance with the License.
      8  7ca1							; You may obtain a copy of the License at
      9  7ca1							;
     10  7ca1							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7ca1							;
     12  7ca1							; Unless required by applicable law or agreed to in writing, software
     13  7ca1							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7ca1							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7ca1							; See the License for the specific language governing permissions and
     16  7ca1							; limitations under the License.
     17  7ca1
     18  7ca1							; Song author: 
     19  7ca1							; Song name: 
     20  7ca1
     21  7ca1							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7ca1
     23  7ca1							; =====================================================================
     24  7ca1							; TIATracker melodic and percussion instruments, patterns and sequencer
     25  7ca1							; data.
     26  7ca1							; =====================================================================
     27  7ca1				   tt_TrackDataStart
     28  7ca1
     29  7ca1							; =====================================================================
     30  7ca1							; Melodic instrument definitions (up to 7). tt_envelope_index_c0/1 hold
     31  7ca1							; the index values into these tables for the current instruments played
     32  7ca1							; in channel 0 and 1.
     33  7ca1							; 
     34  7ca1							; Each instrument is defined by:
     35  7ca1							; - tt_InsCtrlTable: the AUDC value
     36  7ca1							; - tt_InsADIndexes: the index of the start of the ADSR envelope as
     37  7ca1							;	 defined in tt_InsFreqVolTable
     38  7ca1							; - tt_InsSustainIndexes: the index of the start of the Sustain phase
     39  7ca1							;	 of the envelope
     40  7ca1							; - tt_InsReleaseIndexes: the index of the start of the Release phase
     41  7ca1							; - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
     42  7ca1							;	 the envelope
     43  7ca1							; =====================================================================
     44  7ca1
     45  7ca1							; Instrument master CTRL values
     46  7ca1				   tt_InsCtrlTable
     47  7ca1		       07 04 0c 04*	      dc.b	$07, $04, $0c, $04, $0c
     48  7ca6
     49  7ca6
     50  7ca6							; Instrument Attack/Decay start indexes into ADSR tables.
     51  7ca6				   tt_InsADIndexes
     52  7ca6		       00 0e 0e 1e*	      dc.b	$00, $0e, $0e, $1e, $1e
     53  7cab
     54  7cab
     55  7cab							; Instrument Sustain start indexes into ADSR tables
     56  7cab				   tt_InsSustainIndexes
     57  7cab		       08 19 19 2b*	      dc.b	$08, $19, $19, $2b, $2b
     58  7cb0
     59  7cb0
     60  7cb0							; Instrument Release start indexes into ADSR tables
     61  7cb0							; Caution: Values are stored with an implicit -1 modifier! To get the
     62  7cb0							; real index, add 1.
     63  7cb0				   tt_InsReleaseIndexes
     64  7cb0		       09 1b 1b 2c*	      dc.b	$09, $1b, $1b, $2c, $2c
     65  7cb5
     66  7cb5
     67  7cb5							; AUDVx and AUDFx ADSR envelope values.
     68  7cb5							; Each byte encodes the frequency and volume:
     69  7cb5							; - Bits 7..4: Freqency modifier for the current note ([-8..7]),
     70  7cb5							;	 8 means no change. Bit 7 is the sign bit.
     71  7cb5							; - Bits 3..0: Volume
     72  7cb5							; Between sustain and release is one byte that is not used and
     73  7cb5							; can be any value.
     74  7cb5							; The end of the release phase is encoded by a 0.
     75  7cb5				   tt_InsFreqVolTable
     76  7cb5							; 0: Pizzicato bassb
     77  7cb5		       8a 8a 89 88*	      dc.b	$8a, $8a, $89, $88, $86, $85, $85, $84
     78  7cbd		       83 00 83 83*	      dc.b	$83, $00, $83, $83, $83, $00
     79  7cc3							; 1+2: Square2
     80  7cc3		       8c 8c 8b 89*	      dc.b	$8c, $8c, $8b, $89, $87, $85, $84, $83
     81  7ccb		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $00, $81, $00
     82  7cd3							; 3+4: Square
     83  7cd3		       85 85 85 85*	      dc.b	$85, $85, $85, $85, $84, $83, $83, $82
     84  7cdb		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $81, $00, $80
     85  7ce3		       00		      dc.b	$00
     86  7ce4
     87  7ce4
     88  7ce4
     89  7ce4							; =====================================================================
     90  7ce4							; Percussion instrument definitions (up to 15)
     91  7ce4							;
     92  7ce4							; Each percussion instrument is defined by:
     93  7ce4							; - tt_PercIndexes: The index of the first percussion frame as defined
     94  7ce4							;	 in tt_PercFreqTable and tt_PercCtrlVolTable
     95  7ce4							; - tt_PercFreqTable: The AUDF frequency value
     96  7ce4							; - tt_PercCtrlVolTable: The AUDV volume and AUDC values
     97  7ce4							; =====================================================================
     98  7ce4
     99  7ce4							; Indexes into percussion definitions signifying the first frame for
    100  7ce4							; each percussion in tt_PercFreqTable.
    101  7ce4							; Caution: Values are stored with an implicit +1 modifier! To get the
    102  7ce4							; real index, subtract 1.
    103  7ce4				   tt_PercIndexes
    104  7ce4		       01 0a 0c 	      dc.b	$01, $0a, $0c
    105  7ce7
    106  7ce7
    107  7ce7							; The AUDF frequency values for the percussion instruments.
    108  7ce7							; If the second to last value is negative (>=128), it means it's an
    109  7ce7							; "overlay" percussion, i.e. the player fetches the next instrument note
    110  7ce7							; immediately and starts it in the sustain phase next frame. (Needs
    111  7ce7							; TT_USE_OVERLAY)
    112  7ce7				   tt_PercFreqTable
    113  7ce7							; 0: Kick
    114  7ce7		       00 01 02 03*	      dc.b	$00, $01, $02, $03, $04, $05, $06, $87
    115  7cef		       00		      dc.b	$00
    116  7cf0							; 1: HH
    117  7cf0		       80 00		      dc.b	$80, $00
    118  7cf2							; 2: Snare
    119  7cf2		       01 03 06 0e*	      dc.b	$01, $03, $06, $0e, $13, $11, $15, $14
    120  7cfa		       17 1b 00 	      dc.b	$17, $1b, $00
    121  7cfd
    122  7cfd
    123  7cfd							; The AUDCx and AUDVx volume values for the percussion instruments.
    124  7cfd							; - Bits 7..4: AUDC value
    125  7cfd							; - Bits 3..0: AUDV value
    126  7cfd							; 0 means end of percussion data.
    127  7cfd				   tt_PercCtrlVolTable
    128  7cfd							; 0: Kick
    129  7cfd		       ee ed ed eb*	      dc.b	$ee, $ed, $ed, $eb, $e9, $e8, $e8, $e6
    130  7d05		       00		      dc.b	$00
    131  7d06							; 1: HH
    132  7d06		       87 00		      dc.b	$87, $00
    133  7d08							; 2: Snare
    134  7d08		       8b 8a 8a 8a*	      dc.b	$8b, $8a, $8a, $8a, $8a, $8a, $89, $88
    135  7d10		       87 86 00 	      dc.b	$87, $86, $00
    136  7d13
    137  7d13
    138  7d13
    139  7d13							; =====================================================================
    140  7d13							; Track definition
    141  7d13							; The track is defined by:
    142  7d13							; - tt_PatternX (X=0, 1, ...): Pattern definitions
    143  7d13							; - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
    144  7d13							;	 as index values
    145  7d13							; - tt_SequenceTable: The order in which the patterns should be played,
    146  7d13							;	 i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
    147  7d13							;	 for all channels and sub-tracks. The variables
    148  7d13							;	 tt_cur_pat_index_c0/1 hold an index into tt_SequenceTable for
    149  7d13							;	 each channel.
    150  7d13							;
    151  7d13							; So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
    152  7d13							; in turn point to pattern definitions (tt_PatternX) in which the notes
    153  7d13							; to play are specified.
    154  7d13							; =====================================================================
    155  7d13
    156  7d13							; ---------------------------------------------------------------------
    157  7d13							; Pattern definitions, one table per pattern. tt_cur_note_index_c0/1
    158  7d13							; hold the index values into these tables for the current pattern
    159  7d13							; played in channel 0 and 1.
    160  7d13							;
    161  7d13							; A pattern is a sequence of notes (one byte per note) ending with a 0.
    162  7d13							; A note can be either:
    163  7d13							; - Pause: Put melodic instrument into release. Must only follow a
    164  7d13							;	 melodic instrument.
    165  7d13							; - Hold: Continue to play last note (or silence). Default "empty" note.
    166  7d13							; - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
    167  7d13							;	 by -7..+7 and keep playing it
    168  7d13							; - Play new note with melodic instrument
    169  7d13							; - Play new note with percussion instrument
    170  7d13							; - End of pattern
    171  7d13							;
    172  7d13							; A note is defined by:
    173  7d13							; - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
    174  7d13							;	 and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
    175  7d13							;	 defined as:
    176  7d13							;	 - 0: End of pattern
    177  7d13							;	 - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
    178  7d13							;	 - 8: Hold
    179  7d13							;	 - 16: Pause
    180  7d13							;	 - [17..31]: Play percussion instrument 1..15
    181  7d13							;
    182  7d13							; The tracker must ensure that a pause only follows a melodic
    183  7d13							; instrument or a hold/slide.
    184  7d13							; ---------------------------------------------------------------------
    185  7d13		       00 1f	   TT_FREQ_MASK =	%00011111
    186  7d13		       00 08	   TT_INS_HOLD =	8
    187  7d13		       00 10	   TT_INS_PAUSE =	16
    188  7d13		       00 11	   TT_FIRST_PERC =	17
    189  7d13
    190  7d13							; Intro left
    191  7d13				   tt_pattern0
    192  7d13		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $3e, $08
    193  7d1b		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $3e, $08
    194  7d23		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $12, $3e
    195  7d2b		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $13, $08
    196  7d33		       00		      dc.b	$00
    197  7d34
    198  7d34							; Intro2 L
    199  7d34				   tt_pattern1
    200  7d34		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    201  7d3c		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    202  7d44		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    203  7d4c		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    204  7d54		       00		      dc.b	$00
    205  7d55
    206  7d55							; Intro2-fill L
    207  7d55				   tt_pattern2
    208  7d55		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    209  7d5d		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    210  7d65		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    211  7d6d		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    212  7d75		       00		      dc.b	$00
    213  7d76
    214  7d76							; Intro right
    215  7d76				   tt_pattern3
    216  7d76		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $73, $08
    217  7d7e		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $73, $08, $73, $08
    218  7d86		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $b3, $08
    219  7d8e		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    220  7d96		       00		      dc.b	$00
    221  7d97
    222  7d97							; Intro2 R
    223  7d97				   tt_pattern4
    224  7d97		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    225  7d9f		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    226  7da7		       b3 08 73 08*	      dc.b	$b3, $08, $73, $08, $b3, $08, $73, $08
    227  7daf		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    228  7db7		       00		      dc.b	$00
    229  7db8
    230  7db8
    231  7db8
    232  7db8
    233  7db8							; Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
    234  7db8							; Each byte encodes the speed of one pattern in the order
    235  7db8							; of the tt_PatternPtr tables below.
    236  7db8							; If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
    237  7db8							; the even speed and the high nibble the odd speed.
    238  7db8				  -	      IF	TT_GLOBAL_SPEED = 0
    239  7db8				  -tt_PatternSpeeds
    240  7db8				  -%%PATTERNSPEEDS%%
    241  7db8					      ENDIF
    242  7db8
    243  7db8
    244  7db8							; ---------------------------------------------------------------------
    245  7db8							; Pattern pointers look-up table.
    246  7db8							; ---------------------------------------------------------------------
    247  7db8				   tt_PatternPtrLo
    248  7db8		       13 34 55 76	      dc.b	<tt_pattern0, <tt_pattern1, <tt_pattern2, <tt_pattern3
    249  7dbc		       97		      dc.b	<tt_pattern4
    250  7dbd				   tt_PatternPtrHi
    251  7dbd		       fd fd fd fd	      dc.b	>tt_pattern0, >tt_pattern1, >tt_pattern2, >tt_pattern3
    252  7dc1		       fd		      dc.b	>tt_pattern4
    253  7dc2
    254  7dc2
    255  7dc2							; ---------------------------------------------------------------------
    256  7dc2							; Pattern sequence table. Each byte is an index into the
    257  7dc2							; tt_PatternPtrLo/Hi tables where the pointers to the pattern
    258  7dc2							; definitions can be found. When a pattern has been played completely,
    259  7dc2							; the next byte from this table is used to get the address of the next
    260  7dc2							; pattern to play. tt_cur_pat_index_c0/1 hold the current index values
    261  7dc2							; into this table for channels 0 and 1.
    262  7dc2							; If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
    263  7dc2							; number encoded in bits 6..0 (i.e. value AND %01111111).
    264  7dc2							; ---------------------------------------------------------------------
    265  7dc2				   tt_SequenceTable
    266  7dc2							; ---------- Channel 0 ----------
    267  7dc2		       00 00 01 02*	      dc.b	$00, $00, $01, $02, $80
    268  7dc7
    269  7dc7
    270  7dc7							; ---------- Channel 1 ----------
    271  7dc7		       03 04 03 04*	      dc.b	$03, $04, $03, $04, $85
    272  7dcc
    273  7dcc
 Track size:  $12b
    274  7dcc					      echo	"Track size: ", *-tt_TrackDataStart
------- FILE BANK_FIXED.asm
   1222  7dcc
------- FILE characterset/character_BOX.asm LEVEL 3 PASS 4
      0  7dcc					      include	"characterset/character_BOX.asm"
      1  7dcc							;    Sokoboo - a Sokoban implementation
      2  7dcc							;    using a generic tile-based display engine for the Atari 2600
      3  7dcc							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7dcc							;
      5  7dcc							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7dcc							;
      7  7dcc							;    Code related to the generic tile-based display engine was developed by
      8  7dcc							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7dcc							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7dcc							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7dcc							;
     12  7dcc							;    Code related to music and sound effects uses the TIATracker music player
     13  7dcc							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7dcc							;    directory for Apache licensing details.
     15  7dcc							;
     16  7dcc							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7dcc							;    See the copyright notices in the License directory for a list of level
     18  7dcc							;    contributors.
     19  7dcc							;
     20  7dcc							;    Except where otherwise indicated, this software is released under the
     21  7dcc							;    following licensing arrangement...
     22  7dcc							;
     23  7dcc							;    This program is free software: you can redistribute it and/or modify
     24  7dcc							;    it under the terms of the GNU General Public License as published by
     25  7dcc							;    the Free Software Foundation, either version 3 of the License, or
     26  7dcc							;    (at your option) any later version.
     27  7dcc							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7dcc
     29  7dcc							;    This program is distributed in the hope that it will be useful,
     30  7dcc							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7dcc							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7dcc							;    GNU General Public License for more details.
     33  7dcc
      0  7dcc					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  7dcc					      LIST	ON
     35  7dcc				   CHARACTERSHAPE_BOX
     36  7dcc				  -	      if	MIRRORED_BOX = NO
     37  7dcc				  -CHARACTERSHAPE_BOX_MIRRORED
     38  7dcc					      endif
     39  7dcc		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%10011001,%11111111,%11111111,%0	;R
     40  7dd4		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     41  7ddc		       00 00 00 00*	      .byte.b	%0,%0,%0,0,%0,%0,%0,0	;B
     42  7de4
     43  7de4							;--------------------------------------------------------------------------
     44  7de4					      if	MIRRORED_BOX = YES
      0  7de4					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
     10  7de4					      LIST	ON
     46  7de4				   CHARACTERSHAPE_BOX_MIRRORED
     47  7de4		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%10011001,%11111111,%11111111,%0	;R
     48  7dec		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     49  7df4		       00 00 00 00*	      .byte.b	%0,%0,0,0,%0,%0,%0,0	;B
     50  7dfc					      endif
     51  7dfc
      0  7dfc					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_BOX_ON_TARGET
 REQUESTED SIZE =  $18
 WASTED SPACE =  $4
 PAGEBREAK LOCATION =  $fe00
     10  7e00					      LIST	ON
     53  7e00				   CHARACTERSHAPE_BOX_ON_TARGET
     54  7e00				  -	      if	MIRRORED_BOX = NO
     55  7e00				  -CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     56  7e00					      endif
     57  7e00		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     58  7e08		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     59  7e10		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,%01100110,%0,%0,0	;B
     60  7e18
     61  7e18							;--------------------------------------------------------------------------
     62  7e18					      if	MIRRORED_BOX = YES
      0  7e18					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED", LINES_PER_CHAR
     10  7e18					      LIST	ON
     64  7e18				   CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     65  7e18		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     66  7e20		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     67  7e28		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,%01100110,0,%0,%0	;B
     68  7e30					      endif
------- FILE BANK_FIXED.asm
------- FILE characterset/character_WALL.asm LEVEL 3 PASS 4
      0  7e30					      include	"characterset/character_WALL.asm"
      1  7e30							;    Sokoboo - a Sokoban implementation
      2  7e30							;    using a generic tile-based display engine for the Atari 2600
      3  7e30							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7e30							;
      5  7e30							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7e30							;
      7  7e30							;    Code related to the generic tile-based display engine was developed by
      8  7e30							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7e30							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7e30							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7e30							;
     12  7e30							;    Code related to music and sound effects uses the TIATracker music player
     13  7e30							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7e30							;    directory for Apache licensing details.
     15  7e30							;
     16  7e30							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7e30							;    See the copyright notices in the License directory for a list of level
     18  7e30							;    contributors.
     19  7e30							;
     20  7e30							;    Except where otherwise indicated, this software is released under the
     21  7e30							;    following licensing arrangement...
     22  7e30							;
     23  7e30							;    This program is free software: you can redistribute it and/or modify
     24  7e30							;    it under the terms of the GNU General Public License as published by
     25  7e30							;    the Free Software Foundation, either version 3 of the License, or
     26  7e30							;    (at your option) any later version.
     27  7e30							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7e30
     29  7e30							;    This program is distributed in the hope that it will be useful,
     30  7e30							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7e30							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7e30							;    GNU General Public License for more details.
     33  7e30
      0  7e30					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  7e30					      LIST	ON
     35  7e30
     36  7e30		       00 00	   BRICK_WALL_DEF =	0
     37  7e30
     38  7e30				   CHARACTERSHAPE_WALL
     39  7e30				   CHARACTERSHAPE_WALL0
     40  7e30
     41  7e30
     42  7e30
     43  7e30				  -	      if	MIRRORED_WALL = NO
     44  7e30				  -CHARACTERSHAPE_WALL_MIRRORED
     45  7e30				  -CHARACTERSHAPE_WALL0_MIRRORED
     46  7e30					      endif
     47  7e30
     48  7e30					      if	BRICK_WALL_DEF = 0
     49  7e30		       00 ee ee ee*	      .byte.b	%00000000,%11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;R
     50  7e38		       ee ee ee ee*	      .byte.b	%11101110,%11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;G
     51  7e40		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     52  7e48					      endif
     53  7e48
     54  7e48
     55  7e48
     56  7e48							;--------------------------------------------------------------------------
     57  7e48					      if	MIRRORED_WALL = YES
      0  7e48					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  7e48					      LIST	ON
     59  7e48				   CHARACTERSHAPE_WALL_MIRRORED
     60  7e48				   CHARACTERSHAPE_WALL0_MIRRORED
     61  7e48
     62  7e48					      if	BRICK_WALL_DEF = 0
     63  7e48		       00 77 77 77*	      .byte.b	%00000000,%01110111,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;R
     64  7e50		       77 77 77 77*	      .byte.b	%01110111,%01110111,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;G
     65  7e58		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     66  7e60					      endif
     67  7e60
     68  7e60
     69  7e60					      endif
------- FILE BANK_FIXED.asm
   1225  7e60
   1226  7e60				  -	      if	DIGITS
   1227  7e60				  -	      include	"characterset/character_9.asm"
   1228  7e60				  -	      include	"characterset/character_8.asm"
   1229  7e60				  -	      include	"characterset/character_7.asm"
   1230  7e60				  -	      include	"characterset/character_6.asm"
   1231  7e60				  -	      include	"characterset/character_5.asm"
   1232  7e60				  -	      include	"characterset/character_4.asm"
   1233  7e60				  -	      include	"characterset/character_3.asm"
   1234  7e60				  -	      include	"characterset/character_2.asm"
   1235  7e60				  -	      include	"characterset/character_1.asm"
   1236  7e60				  -	      include	"characterset/character_0.asm"
   1237  7e60					      endif
   1238  7e60
   1239  7e60				  -	      if	TROPHY
   1240  7e60				  -	      include	"trophyData.asm"
   1241  7e60					      endif
   1242  7e60
   1243  7e60
   1244  7e60
   1245  7e60
 FREE BYTES IN FIXED BANK =  $19b
   1246  7e60					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1247  7e60
   1248  7e60							;---------------------------------------------------------------------------
   1249  7e60							; The reset vectors
   1250  7e60							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1251  7e60
   1252  8000 ????				      SEG	InterruptVectors
   1253  7ffc					      ORG	FIXED_BANK + $7FC
   1254  7ffc					      RORG	$7ffC
   1255  7ffc
   1256  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1257  7ffc		       9c fa		      .word.w	Reset	; RESET
   1258  7ffe		       9c fa		      .word.w	Reset	; IRQ	      (not used)
   1259  8000
   1260  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
    860  8000
    861  8000					      END
