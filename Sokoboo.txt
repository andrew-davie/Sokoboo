------- FILE ./sokoboo.asm LEVEL 1 PASS 4
      1  8000 ????						;    Sokoboo - a Sokoban implementation
      2  8000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  8000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  8000 ????						;
      5  8000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  8000 ????						;
      7  8000 ????						;    Code related to the generic tile-based display engine was developed by
      8  8000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  8000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  8000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  8000 ????						;
     12  8000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  8000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  8000 ????						;    directory for Apache licensing details.
     15  8000 ????						;
     16  8000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  8000 ????						;    See the copyright notices in the License directory for a list of level
     18  8000 ????						;    contributors.
     19  8000 ????						;
     20  8000 ????						;    Except where otherwise indicated, this software is released under the
     21  8000 ????						;    following licensing arrangement...
     22  8000 ????						;
     23  8000 ????						;    This program is free software: you can redistribute it and/or modify
     24  8000 ????						;    it under the terms of the GNU General Public License as published by
     25  8000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  8000 ????						;    (at your option) any later version.
     27  8000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  8000 ????
     29  8000 ????						;    This program is distributed in the hope that it will be useful,
     30  8000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  8000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  8000 ????						;    GNU General Public License for more details.
     33  8000 ????
     34  8000 ????
     35  8000 ????
     36  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
     37  8000 ????
     38  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; This file defines hardware registers and memory mapping for the
      7  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
      8  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  8000 ????						; available at at http://www.atari2600.org/dasm
     10  8000 ????						;
     11  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     12  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     13  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     14  8000 ????						; with your views.  Please contribute, if you think you can improve this
     15  8000 ????						; file!
     16  8000 ????						;
     17  8000 ????						; Latest Revisions...
     18  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     19  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     20  8000 ????						;			    This will allow conditional code to verify VCS.H being
     21  8000 ????						;			    used for code assembly.
     22  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     23  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     24  8000 ????						;			 mirrored reading/writing differences.	This is more a
     25  8000 ????						;			 readability issue, and binary compatibility with disassembled
     26  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     27  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     28  8000 ????						;			 which was broken by the use of segments in this file, as
     29  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     30  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     31  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     32  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     33  8000 ????						;						   it is safe to leave it undefined, and the base address will
     34  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     35  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     36  8000 ????						;			  - register definitions are now generated through assignment
     37  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     38  8000 ????						;			    address architecture.
     39  8000 ????						; 1.0	22/MAR/2003		Initial release
     40  8000 ????
     41  8000 ????
     42  8000 ????						;-------------------------------------------------------------------------------
     43  8000 ????
     44  8000 ????						; TIA_BASE_ADDRESS
     45  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     46  8000 ????						; Normally 0, the base address should (externally, before including this file)
     47  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     48  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     49  8000 ????						; < $40 as a bankswitch.
     50  8000 ????
     51  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     52  8000 ????			  -TIA_BASE_ADDRESS =	0
     53  8000 ????				      ENDIF
     54  8000 ????
     55  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     56  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     57  8000 ????						; *OR* by declaring the label before including this file, eg:
     58  8000 ????						; TIA_BASE_ADDRESS = $40
     59  8000 ????						;   include "vcs.h"
     60  8000 ????
     61  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     62  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     63  8000 ????						; for the mirrored ROM hardware registers.
     64  8000 ????
     65  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     66  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     67  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     68  8000 ????
     69  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     70  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     71  8000 ????				      ENDIF
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     74  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????						;-------------------------------------------------------------------------------
     78  8000 ????
     79 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     80 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     81 U0040
     82 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     83 U0040
     84 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     85 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     86 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     87 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     88 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     89 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     90 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     91 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     92 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     93 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     94 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     95 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
     96 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
     97 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
     98 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
     99 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    100 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    101 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    102 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    103 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    104 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    105 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    106 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    107 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    108 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    109 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    110 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    111 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    112 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    113 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    114 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    115 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    116 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    117 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    118 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    119 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    120 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    121 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    122 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    123 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    124 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    125 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    126 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    127 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    128 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    129 U006d
    130 U006d							;-------------------------------------------------------------------------------
    131 U006d
    132 U004e ????				      SEG.U	TIA_REGISTERS_READ
    133 U0040					      ORG	TIA_BASE_READ_ADDRESS
    134 U0040
    135 U0040							;											bit 7	 bit 6
    136 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    137 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    138 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    139 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    140 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    141 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    142 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    143 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    144 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    145 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    146 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    147 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    148 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    149 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    150 U004e
    151 U004e							;-------------------------------------------------------------------------------
    152 U004e
    153 U0298 ????				      SEG.U	RIOT
    154 U0280					      ORG	$280
    155 U0280
    156 U0280							; RIOT MEMORY MAP
    157 U0280
    158 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    159 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    160 U0281
    161 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    162 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    163 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    164 U0284		       00	   INTIM      ds	1	; $284		Timer output
    165 U0285
    166 U0285		       00	   TIMINT     ds	1	; $285
    167 U0286
    168 U0286							; Unused/undefined registers ($285-$294)
    169 U0286
    170 U0286		       00		      ds	1	; $286
    171 U0287		       00		      ds	1	; $287
    172 U0288		       00		      ds	1	; $288
    173 U0289		       00		      ds	1	; $289
    174 U028a		       00		      ds	1	; $28A
    175 U028b		       00		      ds	1	; $28B
    176 U028c		       00		      ds	1	; $28C
    177 U028d		       00		      ds	1	; $28D
    178 U028e		       00		      ds	1	; $28E
    179 U028f		       00		      ds	1	; $28F
    180 U0290		       00		      ds	1	; $290
    181 U0291		       00		      ds	1	; $291
    182 U0292		       00		      ds	1	; $292
    183 U0293		       00		      ds	1	; $293
    184 U0294
    185 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    186 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    187 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    188 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    189 U0298
    190 U0298							;-------------------------------------------------------------------------------
    191 U0298							; The following required for back-compatibility with code which does not use
    192 U0298							; segments.
    193 U0298
    194  0000 ????				      SEG
    195  0000 ????
    196  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  0000 ????				      include	"macro.h"
      1  0000 ????
      2  0000 ????						; MACRO.H
      3  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      4  0000 ????
      5  0000 ????	       00 6a	   VERSION_MACRO =	106
      6  0000 ????
      7  0000 ????						;
      8  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      9  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     10  0000 ????						;
     11  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     12  0000 ????						; It is distributed as a companion machine-specific support package
     13  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     14  0000 ????						; available at at http://www.atari2600.org/dasm
     15  0000 ????						;
     16  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     17  0000 ????						; contents, or would like to add something, please write to me
     18  0000 ????						; (atari2600@taswegian.com) with your contribution.
     19  0000 ????						;
     20  0000 ????						; Latest Revisions...
     21  0000 ????						;
     22  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     23  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     25  0000 ????						;			   used for code assembly.
     26  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  0000 ????						;
     28  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  0000 ????						;
     30  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  0000 ????						;			   (standardised macro for vertical synch code)
     32  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     33  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  0000 ????						; 1.0	22/MAR/2003		Initial release
     35  0000 ????
     36  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     37  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     39  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  0000 ????						;   registers and require them to be defined first).
     41  0000 ????
     42  0000 ????						; Available macros...
     43  0000 ????						;   SLEEP n		 - sleep for n cycles
     44  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  0000 ????
     48  0000 ????						;-------------------------------------------------------------------------------
     49  0000 ????						; SLEEP duration
     50  0000 ????						; Original author: Thomas Jentzsch
     51  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  0000 ????						; useful for code where precise timing is required.
     53  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  0000 ????
     57  0000 ????				      MAC	sleep
     58  0000 ????			   .CYCLES    SET	{1}
     59  0000 ????
     60  0000 ????				      IF	.CYCLES < 2
     61  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  0000 ????				      ERR
     63  0000 ????				      ENDIF
     64  0000 ????
     65  0000 ????				      IF	.CYCLES & 1
     66  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  0000 ????				      nop	0
     68  0000 ????				      ELSE
     69  0000 ????				      bit	VSYNC
     70  0000 ????				      ENDIF
     71  0000 ????			   .CYCLES    SET	.CYCLES - 3
     72  0000 ????				      ENDIF
     73  0000 ????
     74  0000 ????				      REPEAT	.CYCLES / 2
     75  0000 ????				      nop
     76  0000 ????				      REPEND
     77  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  0000 ????
     79  0000 ????						;-------------------------------------------------------------------------------
     80  0000 ????						; VERTICAL_SYNC
     81  0000 ????						; revised version by Edwin Blink -- saves bytes!
     82  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     83  0000 ????						; Note: Alters the accumulator
     84  0000 ????
     85  0000 ????						; OUT: A = 0
     86  0000 ????
     87  0000 ????				      MAC	vertical_sync
     88  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     89  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     90  0000 ????				      sta	VSYNC
     91  0000 ????				      lsr
     92  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????						;-------------------------------------------------------------------------------
     96  0000 ????						; CLEAN_START
     97  0000 ????						; Original author: Andrew Davie
     98  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     99  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    100  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    101  0000 ????						; Use as very first section of code on boot (ie: at reset)
    102  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    103  0000 ????
    104  0000 ????				      MAC	clean_start
    105  0000 ????				      sei
    106  0000 ????				      cld
    107  0000 ????
    108  0000 ????				      ldx	#0
    109  0000 ????				      txa
    110  0000 ????				      tay
    111  0000 ????			   .CLEAR_STACK dex
    112  0000 ????				      txs
    113  0000 ????				      pha
    114  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    115  0000 ????
    116  0000 ????				      ENDM
    117  0000 ????
    118  0000 ????						;-------------------------------------------------------
    119  0000 ????						; SET_POINTER
    120  0000 ????						; Original author: Manuel Rotschkar
    121  0000 ????						;
    122  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    123  0000 ????						;
    124  0000 ????						; Usage: SET_POINTER pointer, address
    125  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    126  0000 ????						;
    127  0000 ????						; Note: Alters the accumulator, NZ flags
    128  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    129  0000 ????						; IN 2: absolute address
    130  0000 ????
    131  0000 ????				      MAC	set_pointer
    132  0000 ????			   .POINTER   SET	{1}
    133  0000 ????			   .ADDRESS   SET	{2}
    134  0000 ????
    135  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    136  0000 ????				      STA	.POINTER	; Store in pointer
    137  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    138  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    139  0000 ????
    140  0000 ????				      ENDM
    141  0000 ????
    142  0000 ????						;-------------------------------------------------------
    143  0000 ????						; BOUNDARY byte#
    144  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    145  0000 ????						;
    146  0000 ????						; Push data to a certain position inside a page and keep count of how
    147  0000 ????						; many free bytes the programmer will have.
    148  0000 ????						;
    149  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    150  0000 ????
    151  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    152  0000 ????			   .FREE_BYTES SET	0
    153  0000 ????				      MAC	boundary
    154  0000 ????				      REPEAT	256
    155  0000 ????				      IF	<. % {1} = 0
    156  0000 ????				      MEXIT
    157  0000 ????				      ELSE
    158  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    159  0000 ????				      .byte	$00
    160  0000 ????				      ENDIF
    161  0000 ????				      REPEND
    162  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    163  0000 ????				      ENDM
    164  0000 ????
    165  0000 ????
    166  0000 ????						; EOF
------- FILE ./sokoboo.asm
     41  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34  0000 ????						; segtime optimization (averages):
     35  0000 ????						;   lost time = segtime/2 * 64
     36  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
     37  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
     38  0000 ????						;
     39  0000 ????						; segtime = 2:
     40  0000 ????						;   lost time = 64
     41  0000 ????						;   num-segments = 28
     42  0000 ????						;   overhead = 224!
     43  0000 ????						; segtime = 3:
     44  0000 ????						;   lost time = 96
     45  0000 ????						;   num-segments = 18
     46  0000 ????						;   overhead = 144!
     47  0000 ????						; segtime = 4: 	     <--!!!
     48  0000 ????						;   lost time = 128!
     49  0000 ????						;   num-segments = 28
     50  0000 ????						;   overhead = 112
     51  0000 ????						; segtime = 5:
     52  0000 ????						;   lost time = 160!
     53  0000 ????						;   num-segments = 11
     54  0000 ????						;   overhead = 88
     55  0000 ????						; segtime = 6:
     56  0000 ????						;   lost time = 192!
     57  0000 ????						;   num-segments = 9
     58  0000 ????						;   overhead = 72
     59  0000 ????						; segtime = 7:
     60  0000 ????						;   lost time = 224!
     61  0000 ????						;   num-segments = 8
     62  0000 ????						;   overhead = 64
     63  0000 ????						; segtime = 10:
     64  0000 ????						;   lost time = 320!
     65  0000 ????						;   num-segments = 5
     66  0000 ????						;   overhead = 40
     67  0000 ????						; segtime = 20:
     68  0000 ????						;   lost time = 640!
     69  0000 ????						;   num-segments = 2
     70  0000 ????						;   overhead = 16
     71  0000 ????						; segtime = 40:
     72  0000 ????						;   lost time = 1280!
     73  0000 ????						;   num-segments = 1
     74  0000 ????						;   overhead = 8
     75  0000 ????
     76  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     77  0000 ????						; below wasted time increases rapidly, above only moderately
     78  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     79  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     80  0000 ????						;  so larger segtimes are not that bad then
     81  0000 ????
     82  0000 ????
     83  0000 ????				      MAC	segtime
     84  0000 ????			   {1}	      SET	{2}
     85  0000 ????			   TEST_{1}   =	0
     86  0000 ????				      ENDM
     87  0000 ????
     88  0000 ????				      MAC	xsegtime
     89  0000 ????			   {1}	      SET	{2}-1
     90  0000 ????			   TEST_{1}   =	1
     91  0000 ????				      ENDM
     92  0000 ????
     93  0000 ????						;@TJ -- SIMPLY PUT AN X IN FRONT OF THE LINE(S) YOU WANT TO TEST
     94  0000 ????						; eg: XSEGTIME SEGTIME_BOX1,5
     95  0000 ????						; No other action required.  All code enables/disables automatically.
     96  0000 ????
     97  0000 ????						; 2012/02/11 -- experimental reduction in times (but not stress tested)
     98  0000 ????						; due to separation of timeslice overhead to separate check
     99  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_SCD_DIRECT,8	; TODO: 392@12/2/2012
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	8
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_QUICK,9	; TODO: 414@12/2/2012
      1  0000 ????			   SEGTIME_SCD_QUICK SET	9
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_SLOW,12	; TODO: cycles: ~635 @12/2/2012.
      1  0000 ????			   SEGTIME_SCD_SLOW SET	12
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_PF0,5	; TODO: cycle counted ~126 @12/2/2012
      1  0000 ????			   SEGTIME_SCD_PF0 SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_MIN,SEGTIME_SCD_PF0	; * MINIMUM TIME OF THE ABOVE + 1
      1  0000 ????			   SEGTIME_SCD_MIN SET	SEGTIME_SCD_PF0
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_MIN =	0
    105  0000 ????
    106  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
    107  0000 ????			  -	      SEGTIME	SEGTIME_BDF,42	; * 5/8/11 stress tested DHS->DS
    108  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BDF,41	; * 7/8/11
      1  0000 ????			   SEGTIME_BDF SET	41
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
    110  0000 ????				      ENDIF
    111  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BDS,4	; *AD 11/8/11
      1  0000 ????			   SEGTIME_BDS SET	4
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME	SEGTIME_DSL,5	; * 9/8/11 unrolled once
      1  0000 ????			   SEGTIME_DSL SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
    114  0000 ????
    115  0000 ????
    116  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SORT_TIME,3	;     157(A)->2.45
      1  0000 ????			   MINIMUM_SORT_TIME SET	3
      2  0000 ????	       00 00	   TEST_MINIMUM_SORT_TIME =	0
    118  0000 ????
    119  0000 ????
    120  0000 ????						;following will lock-up system if used as 'XSEGTIME'.
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIME,4	; processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	4
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
    122  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIMEBLANK,16	;17		 ; * 7/8/11	 993(A)->15.5
      1  0000 ????			   MINIMUM_SEGTIMEBLANK SET	16
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIMEBLANK =	0
    124  0000 ????
    125  0000 ????						; MINIMUM_SEGTIME
    126  0000 ????						; MINIMUM_SEGTIMEBLANK
    127  0000 ????						; SEGTIME_BDF
    128  0000 ????						; SEGTIME_BDS
    129  0000 ????						; SEGTIME_DSL
    130  0000 ????						; SEGTIME_SWITCHOBJECTS
    131  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MINIMUM_TIMESLICE,MINIMUM_SEGTIME+1	; MINIMUM of the TIMESLICE segments listed above
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	MINIMUM_SEGTIME+1
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    133  0000 ????
    134  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    135  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    136  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    137  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    138  0000 ????						; uses ...
    139  0000 ????
    140  0000 ????
    141  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    142  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    143  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    144  0000 ????
    145  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    146  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    147  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,24	;<< using this as XSEGTIME stops player working ...?!
      1  0000 ????			   SEGTIME_MAN SET	24
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE, 10	; drawing circle creature
      1  0000 ????			   SEGTIME_CIRCLE SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE_HELPER, 10	; drawing circle creature's helper
      1  0000 ????			   SEGTIME_CIRCLE_HELPER SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE_HELPER =	0
    151  0000 ????
    152  0000 ????						; TJ: I should only prevent processes with an extra check (e.g. get TARGET)
    153  0000 ????
    154  0000 ????						; push BOX is slowest (besides get TARGET which has an extra timer check)
    155  0000 ????						; if we add another check for it, SEGTIME_MAN reduces by ~5
    156  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_GET_TARGET,17	; * 14/8/11, required if UpdateScore loops (e.g. 9990->10000)
      1  0000 ????			   SEGTIME_GET_TARGET SET	17
      2  0000 ????	       00 00	   TEST_SEGTIME_GET_TARGET =	0
      0  0000 ????				      SEGTIME	SEGTIME_SWITCHOBJECTS,3	; 16/8/11 by calculation. 72 cycles -->  ceil(72/64)+1 --> 3 Object stack switchover
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	3
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
------- FILE ./sokoboo.asm
     43  0000 ????
     44  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     45  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     46  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     47  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     48  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     49  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     50  0000 ????
     51  0000 ????	       00 01	   YES	      =	1
     52  0000 ????	       00 00	   NO	      =	0
     53  0000 ????
     54  0000 ????	       00 00	   DEBUG      =	NO
     55  0000 ????
     56  0000 ????	       00 00	   TJ_MODE    =	NO	; some changes which TJ prefers
     57  0000 ????	       00 01	   AD_MODE    =	YES	; some changes which AD prefers
     58  0000 ????
     59  0000 ????			  -	      IF	TJ_MODE && AD_MODE
     60  0000 ????			  -	      ECHO	"ERROR: Both TJ_MODE and AD_MODE set. Can't do both TJ and AD at the same time!"
     61  0000 ????			  -	      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????
     65  0000 ????						; Note: you may also need to change the emulator "-format" switch in the Makefile.
     66  0000 ????
     67  0000 ????			   NTSC_MODE  SET	NO
     68  0000 ????
     69  0000 ????			  -	      IF	TJ_MODE
     70  0000 ????			  -NTSC_MODE  SET	NO	; force NTSC or PAL for difficulty switch
     71  0000 ????				      ENDIF
     72  0000 ????				      IF	AD_MODE
     73  0000 ????			   NTSC_MODE  SET	NO
     74  0000 ????				      ENDIF
     75  0000 ????
     76  0000 ????
     77  0000 ????
     78  0000 ????						;===================================
     79  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     80  0000 ????						;===================================
     81  0000 ????
     82  0000 ????						;-------------------------------------------------------------------------------
     83  0000 ????						; The following should be YES for the final or DEMO version
     84  0000 ????			   EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
     85  0000 ????
     86  0000 ????						;-------------------------------------------------------------------------------
     87  0000 ????						; The following are optional YES/NO depending on phase of the moon
     88  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     89  0000 ????						;-------------------------------------------------------------------------------
     90  0000 ????
     91  0000 ????	       00 01	   NUMPLAYERS =	1	; 1-indexed
     92  0000 ????	       00 05	   NUM_LEVELS =	5
     93  0000 ????			   NUM_LIVES  SET	3	; use -1 for unlimited lives
     94  0000 ????
     95  0000 ????			   DEMO_DELAY SET	1	; number of music loops without joystick input before demo kicks in
     96  0000 ????
     97  0000 ????						;-------------------------------------------------------------------------------
     98  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     99  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
    100  0000 ????			  -	      IF	FINAL_VERSION = YES
    101  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
    102  0000 ????			  -SHOWTARGETP SET	NO	; debug show TARGET on P
    103  0000 ????			  -
    104  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
    105  0000 ????			  -DEMO_DELAY SET	2	; number of music loops without joystick input before demo kicks in
    106  0000 ????			  -NTSC_MODE  SET	YES	; mmh
    107  0000 ????				      ENDIF
    108  0000 ????
    109  0000 ????						;-------------------------------------------------------------------------------
    110  0000 ????
    111  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
    112  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
    113  0000 ????
    114  0000 ????
    115  0000 ????	       00 01	   PUSH_LIMIT =	1	; slowdown when pushing on a BOX
    116  0000 ????
    117  0000 ????						; time bonus countdown constants:
    118  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
    119  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
    120  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
    121  0000 ????
    122  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
    123  0000 ????
    124  0000 ????	       00 03	   FACE_LEFT  =	3
    125  0000 ????
    126  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
    127  0000 ????
    128  0000 ????						;scoring flags contants:
    129  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
    130  0000 ????	       00 00	   DISPLAY_TIME =	%00
    131  0000 ????	       00 01	   DISPLAY_SCORE =	%01
    132  0000 ????	       00 02	   DISPLAY_LIVES =	%10
    133  0000 ????	       00 03	   DISPLAY_HIGH =	%11
    134  0000 ????
    135  0000 ????						;------------------------------------------------------------------------------
    136  0000 ????
    137  0000 ????	       00 01	   MIRRORED_BOX =	YES
    138  0000 ????	       00 01	   MIRRORED_STEEL =	YES
    139  0000 ????	       00 01	   MIRRORED_WALL =	YES
    140  0000 ????
    141  0000 ????						;------------------------------------------------------------------------------
    142  0000 ????
    143  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    144  0000 ????
    145  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    146  0000 ????	       00 15	   LINES_PER_CHAR =	21	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    147  0000 ????
    148  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    149  0000 ????
    150  0000 ????
    151  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    152  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    153  0000 ????
    154  0000 ????
    155  0000 ????						; color constants:
    156  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    157  0000 ????
    158  0000 ????	       00 10	   YELLOW_NTSC =	$10
    159  0000 ????	       00 20	   YELLOW_PAL =	$20
    160  0000 ????
    161  0000 ????
    162  0000 ????	       10 00	   RAM_3E     =	$1000
    163  0000 ????	       04 00	   RAM_SIZE   =	$400
    164  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    165  0000 ????
    166  0000 ????
    167  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    168  0000 ????
    169  0000 ????
    170  0000 ????						; Platform constants:
    171  0000 ????	       00 02	   PAL	      =	%10
    172  0000 ????	       00 02	   PAL_50     =	PAL|0
    173  0000 ????	       00 03	   PAL_60     =	PAL|1
    174  0000 ????
    175  0000 ????
    176  0000 ????				      IF	L276
    177  0000 ????	       00 3e	   VBLANK_TIM_NTSC =	62	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    178  0000 ????			  -	      ELSE
    179  0000 ????			  -VBLANK_TIM_NTSC =	45	; NTSC 262
    180  0000 ????				      ENDIF
    181  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    182  0000 ????
    183  0000 ????				      IF	L276
    184  0000 ????	       00 33	   OVERSCAN_TIM_NTSC =	51	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    185  0000 ????			  -	      ELSE
    186  0000 ????			  -OVERSCAN_TIM_NTSC =	51	; NTSC 262
    187  0000 ????				      ENDIF
    188  0000 ????	       00 46	   OVERSCAN_TIM_PAL =	70	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    189  0000 ????
    190  0000 ????				      IF	L276
    191  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    192  0000 ????			  -	      ELSE
    193  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    194  0000 ????				      ENDIF
    195  0000 ????	       01 38	   SCANLINES_PAL =	312
    196  0000 ????
    197  0000 ????
    198  0000 ????						;------------------------------------------------------------------------------
    199  0000 ????						; MACRO definitions
    200  0000 ????
    201  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    202  0000 ????
    203  0000 ????				      MAC	newbank
    204  0000 ????				      SEG	{1}
    205  0000 ????				      ORG	ORIGIN
    206  0000 ????				      RORG	$F000
    207  0000 ????			   BANK_START SET	*
    208  0000 ????			   {1}	      SET	ORIGIN / 2048
    209  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    210  0000 ????			   _CURRENT_BANK SET	{1}
    211  0000 ????				      ENDM		; bank name
    212  0000 ????
    213  0000 ????				      MAC	define_1k_segment
    214  0000 ????				      ALIGN	$400
    215  0000 ????			   SEGMENT_{1} SET	*
    216  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    217  0000 ????				      ENDM		; {seg name}
    218  0000 ????
    219  0000 ????				      MAC	check_bank_size
    220  0000 ????			   .TEMP      =	* - BANK_START
    221  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    222  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    223  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    224  0000 ????				      ERR
    225  0000 ????				      endif
    226  0000 ????				      ENDM		; name
    227  0000 ????
    228  0000 ????
    229  0000 ????				      MAC	check_half_bank_size
    230  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    231  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    232  0000 ????			   .TEMP      =	* - BANK_START
    233  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    234  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    235  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    236  0000 ????				      ERR
    237  0000 ????				      endif
    238  0000 ????				      ENDM		; name
    239  0000 ????
    240  0000 ????
    241  0000 ????				      MAC	overlay
    242  0000 ????				      SEG.U	OVERLAY_{1}
    243  0000 ????				      org	Overlay
    244  0000 ????				      ENDM		; {name}
    245  0000 ????
    246  0000 ????						;--------------------------------------------------------------------------
    247  0000 ????
    248  0000 ????				      MAC	validate_overlay
    249  0000 ????				      LIST	OFF
    250  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    251  0000 ????				      ERR
    252  0000 ????				      endif
    253  0000 ????				      LIST	ON
    254  0000 ????				      ENDM
    255  0000 ????
    256  0000 ????						;--------------------------------------------------------------------------
    257  0000 ????						; Macro inserts a page break if the object would overlap a page
    258  0000 ????
    259  0000 ????				      MAC	optional_pagebreak
    260  0000 ????				      LIST	OFF
    261  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    262  0000 ????			   EARLY_LOCATION SET	*
    263  0000 ????				      ALIGN	256
    264  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    265  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    266  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    267  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    268  0000 ????				      ENDIF
    269  0000 ????				      LIST	ON
    270  0000 ????				      ENDM		; { string, size }
    271  0000 ????
    272  0000 ????
    273  0000 ????				      MAC	check_page_crossing
    274  0000 ????				      LIST	OFF
    275  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    276  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    277  0000 ????				      endif
    278  0000 ????				      LIST	ON
    279  0000 ????				      ENDM
    280  0000 ????
    281  0000 ????				      MAC	checkpage
    282  0000 ????				      LIST	OFF
    283  0000 ????				      IF	>. != >{1}
    284  0000 ????				      ECHO	""
    285  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    286  0000 ????				      ECHO	""
    287  0000 ????				      ERR
    288  0000 ????				      ENDIF
    289  0000 ????				      LIST	ON
    290  0000 ????				      ENDM
    291  0000 ????
    292  0000 ????				      MAC	checkpagex
    293  0000 ????				      LIST	OFF
    294  0000 ????				      IF	>. != >{1}
    295  0000 ????				      ECHO	""
    296  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    297  0000 ????				      ECHO	{2}
    298  0000 ????				      ECHO	""
    299  0000 ????				      ERR
    300  0000 ????				      ENDIF
    301  0000 ????				      LIST	ON
    302  0000 ????				      ENDM
    303  0000 ????
    304  0000 ????
    305  0000 ????				      MAC	checkpage_bne
    306  0000 ????				      LIST	OFF
    307  0000 ????				      IF	0	;>(. + 2) != >{1}
    308  0000 ????				      ECHO	""
    309  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    310  0000 ????				      ECHO	""
    311  0000 ????				      ERR
    312  0000 ????				      ENDIF
    313  0000 ????				      LIST	ON
    314  0000 ????				      bne	{1}
    315  0000 ????				      ENDM
    316  0000 ????
    317  0000 ????				      MAC	checkpage_bpl
    318  0000 ????				      LIST	OFF
    319  0000 ????				      IF	(>(.+2 )) != >{1}
    320  0000 ????				      ECHO	""
    321  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    322  0000 ????				      ECHO	""
    323  0000 ????				      ERR
    324  0000 ????				      ENDIF
    325  0000 ????				      LIST	ON
    326  0000 ????				      bpl	{1}
    327  0000 ????				      ENDM
    328  0000 ????
    329  0000 ????				      MAC	align_free
    330  0000 ????			   FREE       SET	FREE - .
    331  0000 ????				      align	{1}
    332  0000 ????			   FREE       SET	FREE + .
    333  0000 ????				      echo	"@", ., ":", FREE
    334  0000 ????				      ENDM
    335  0000 ????
    336  0000 ????				      MAC	stress_time
    337  0000 ????				      IF	TEST_{1} = 1
    338  0000 ????
    339  0000 ????
    340  0000 ????						;LIST OFF
    341  0000 ????						; has to be put *directly* after cmp #SEGTIME_... , bcc abort
    342  0000 ????						;LIST ON
    343  0000 ????				      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
    344  0000 ????				      bne	. - 7	; branches to lda INTIM
    345  0000 ????				      ENDIF
    346  0000 ????				      ENDM
    347  0000 ????
    348  0000 ????			   IDENTITY   SET	0
    349  0000 ????				      MAC	ident
    350  0000 ????				      if	DEBUG=YES
    351  0000 ????				      lda	#IDENTITY
    352  0000 ????				      sta	debug_ident
    353  0000 ????				      lda	{1}
    354  0000 ????				      sta	debug_object
    355  0000 ????				      endif
    356  0000 ????			   IDENTITY   SET	IDENTITY + 1
    357  0000 ????				      ENDM		; {object}
    358  0000 ????
    359  0000 ????						;--------------------------------------------------------------------------
    360  0000 ????
    361  0000 ????				      MAC	vector
    362  0000 ????				      .word	{1}
    363  0000 ????				      ENDM		; just a word pointer to code
    364  0000 ????
    365  0000 ????
    366  0000 ????				      MAC	define_subroutine
    367  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    368  0000 ????				      SUBROUTINE		; keep everything local
    369  0000 ????			   {1}			; entry point
    370  0000 ????				      ENDM		; name of subroutine
    371  0000 ????
    372  0000 ????
    373  0000 ????
    374  0000 ????						;--------------------------------------------------------------------------
    375  0000 ????
    376  0000 ????				      MAC	newrambank
    377  0000 ????				      SEG.U	{1}
    378  0000 ????				      ORG	ORIGIN
    379  0000 ????				      RORG	RAM_3E
    380  0000 ????			   BANK_START SET	*
    381  0000 ????			   {1}	      SET	ORIGIN / RAM_SIZE
    382  0000 ????			   ORIGIN     SET	ORIGIN + RAM_SIZE
    383  0000 ????				      ENDM		; bank name
    384  0000 ????
    385  0000 ????				      MAC	validate_ram_size
    386  0000 ????				      if	* - RAM_3E > RAM_SIZE
    387  0000 ????				      ERR
    388  0000 ????				      endif
    389  0000 ????				      ENDM
    390  0000 ????
    391  0000 ????				      MAC	next_random
    392  0000 ????						; update random value:
    393  0000 ????				      lda	rnd	; 3
    394  0000 ????				      lsr		; 2
    395  0000 ????				      IFCONST	rndHi
    396  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    397  0000 ????				      ENDIF
    398  0000 ????				      bcc	.skipEOR	; 2/3
    399  0000 ????				      eor	#RND_EOR_VAL	; 2
    400  0000 ????			   .skipEOR
    401  0000 ????				      sta	rnd	; 3 = 14/19
    402  0000 ????				      ENDM
    403  0000 ????
    404  0000 ????				      MAC	resync
    405  0000 ????						; resync screen, X and Y == 0 afterwards
    406  0000 ????				      lda	#%10	; make sure VBLANK is ON
    407  0000 ????				      sta	VBLANK
    408  0000 ????
    409  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    410  0000 ????			   .loopResync
    411  0000 ????				      VERTICAL_SYNC
    412  0000 ????
    413  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    414  0000 ????				      lda	Platform
    415  0000 ????				      eor	#PAL_50	; PAL-50?
    416  0000 ????				      bne	.ntsc
    417  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    418  0000 ????			   .ntsc
    419  0000 ????			   .loopWait
    420  0000 ????				      sta	WSYNC
    421  0000 ????				      sta	WSYNC
    422  0000 ????				      dey
    423  0000 ????				      bne	.loopWait
    424  0000 ????				      dex
    425  0000 ????				      bne	.loopResync
    426  0000 ????				      ENDM
    427  0000 ????
    428  0000 ????				      MAC	set_platform
    429  0000 ????						; 00 = NTSC
    430  0000 ????						; 01 = NTSC
    431  0000 ????						; 10 = PAL-50
    432  0000 ????						; 11 = PAL-60
    433  0000 ????				      lda	SWCHB
    434  0000 ????				      rol
    435  0000 ????				      rol
    436  0000 ????				      rol
    437  0000 ????				      and	#%11
    438  0000 ????				      if	NTSC_MODE = NO
    439  0000 ????				      eor	#PAL
    440  0000 ????				      endif
    441  0000 ????				      lda	#0	;tmp
    442  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    443  0000 ????				      ENDM
    444  0000 ????
    445  0000 ????						;  IF TJ_MODE
    446  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM ; = 29
    447  0000 ????						;	  ldy #{1}			  ; 2	  read bank
    448  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    449  0000 ????						;	  jsr GetRAMByteFromRAM 	  ;25
    450  0000 ????						;    ENDM
    451  0000 ????						;
    452  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM ; = 30
    453  0000 ????						;	  ldy #{1}			  ; 2	  write bank
    454  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    455  0000 ????						;	  jsr PutRAMByteFromRAM 	  ;26
    456  0000 ????						;    ENDM
    457  0000 ????						;
    458  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM_ADR ; = 39
    459  0000 ????						;	  ldx #<{1}			  ; 2
    460  0000 ????						;	  stx addressR			  ; 3
    461  0000 ????						;	  ldx #>{1}			  ; 2
    462  0000 ????						;	  stx addressR+1		  ; 3
    463  0000 ????						;	  GET_RAM_BYTE_FROM_RAM {2}, {3}  ;29
    464  0000 ????						;    ENDM
    465  0000 ????						;
    466  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM_ADR ; = 40
    467  0000 ????						;	  ldx #<{1}			  ; 2
    468  0000 ????						;	  stx addressW			  ; 3
    469  0000 ????						;	  ldx #>({1}+RAM_WRITE) 	  ; 2
    470  0000 ????						;	  stx addressW+1		  ; 3
    471  0000 ????						;	  PUT_RAM_BYTE_FROM_RAM {2}, {3}  ;30
    472  0000 ????						;    ENDM
    473  0000 ????						;  ENDIF
    474  0000 ????
    475  0000 ????				      MAC	nop_b
    476  0000 ????				      .byte	$82
    477  0000 ????				      ENDM		; unused
    478  0000 ????
    479  0000 ????				      MAC	nop_w
    480  0000 ????				      .byte	$0c
    481  0000 ????				      ENDM
    482  0000 ????
    483  0000 ????						;------------------------------------------------------------------------------
    484  0000 ????
    485  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 4
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????						;    Sokoboo - a Sokoban implementation
      2  0000 ????						;    using a generic tile-based display engine for the Atari 2600
      3  0000 ????						;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0000 ????						;
      5  0000 ????						;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0000 ????						;
      7  0000 ????						;    Code related to the generic tile-based display engine was developed by
      8  0000 ????						;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0000 ????						;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0000 ????						;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0000 ????						;
     12  0000 ????						;    Code related to music and sound effects uses the TIATracker music player
     13  0000 ????						;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0000 ????						;    directory for Apache licensing details.
     15  0000 ????						;
     16  0000 ????						;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0000 ????						;    See the copyright notices in the License directory for a list of level
     18  0000 ????						;    contributors.
     19  0000 ????						;
     20  0000 ????						;    Except where otherwise indicated, this software is released under the
     21  0000 ????						;    following licensing arrangement...
     22  0000 ????						;
     23  0000 ????						;    This program is free software: you can redistribute it and/or modify
     24  0000 ????						;    it under the terms of the GNU General Public License as published by
     25  0000 ????						;    the Free Software Foundation, either version 3 of the License, or
     26  0000 ????						;    (at your option) any later version.
     27  0000 ????						;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0000 ????
     29  0000 ????						;    This program is distributed in the hope that it will be useful,
     30  0000 ????						;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0000 ????						;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0000 ????						;    GNU General Public License for more details.
     33  0000 ????
     34 U00f6 ????				      SEG.U	variables
     35 U0080					      ORG	$80
     36 U0080
     37 U0080
     38 U0080		       00 40	   GAMEMODE_2600 =	64
     39 U0080		       00 80	   GAMEMODE_PAUSED =	128
     40 U0080
     41 U0080		       00	   gameMode   ds	1	; bit7=0: 7800; bit7=1: 2600.	bit 6=1: paused: bit3: toggle bit for B/W
     42 U0081		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     43 U0082							; above variables are preserved ALL the time!
     44 U0082
     45 U0082		       00	   rnd	      ds	1
     46 U0083		       00	   rndHi      ds	1	; to get better random values
     47 U0084
     48 U0084		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     49 U0085		       00	   ObjStackNum ds	1	; which stack in use
     50 U0086		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     51 U0088		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     52 U0089		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     53 U008a
     54 U008a		       00	   POS_X      ds	1
     55 U008b		       00	   POS_Y      ds	1
     56 U008c		       00	   POS_X_NEW  ds	1
     57 U008d		       00	   POS_Y_NEW  ds	1
     58 U008e		       00	   POS_Type   ds	1
     59 U008f		       00	   POS_VAR    ds	1
     60 U0090
     61 U0090		       00 00	   BufferedJoystick ds	2	; player joystick input
     62 U0092		       00 00	   BufferedButton ds	2	; player button press
     63 U0094
     64 U0094							; Scrolling is limited to only show board within the following area...
     65 U0094		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in UnpackLevel)
     66 U0095		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in UnpackLevel)
     67 U0096		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     68 U0097		       00	   BoardScrollX ds	1	; scroll position in board (X)
     69 U0097		       00 94	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     70 U0097		       00 95	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     71 U0098		       00	   scrollBits ds	1
     72 U0099
     73 U0099		       00	   whichPlayer ds	1	; 0 = P1, 1 = P2
     74 U009a		       00	   manAnimationIndex ds	1
     75 U009b		       00	   ManX       ds	1
     76 U009c		       00	   ManY       ds	1
     77 U009d		       00	   ManDrawX   ds	1
     78 U009e		       00	   ManDrawY   ds	1
     79 U009f		       00	   ManMode    ds	1
     80 U00a0		       00	   ManDelayCount ds	1
     81 U00a1		       00 00	   ManAnimation ds	2
     82 U00a3		       00	   ManAnimationFrameLO ds	1
     83 U00a4		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     84 U00a5		       00	   ManPushCounter ds	1
     85 U00a6		       00	   LookingAround ds	1
     86 U00a7		       00	   ManCount   ds	1	; player life counter
     87 U00a8		       00	   DelayEndOfLevel ds	1
     88 U00a9		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     89 U00aa		       00 00	   circle_d   ds	2
     90 U00ac		       00	   circ_x     ds	1
     91 U00ad		       00	   circ_y     ds	1
     92 U00ae		       00	   circ_char  ds	1
     93 U00af		       00	   circ_scratch ds	1
     94 U00b0		       00	   LEVEL_bank ds	1
     95 U00b1							;---------------------------------------------------------------------------
     96 U00b1							; 2 (shared) demo mode variables:
     97 U00b1		       00 a9	   demoMode   =	jtoggle	; bit 7==1 => demo mode
     98 U00b1		       00 a9	   moveLen    =	jtoggle	; bits 0..6
     99 U00b1		       00 99	   moveIdx    =	whichPlayer
    100 U00b1
    101 U00b1		       00	   LastSpriteY ds	1
    102 U00b2
    103 U00b2		       00	   timer      ds	1
    104 U00b3
    105 U00b3		       00	   BGColour   ds	1
    106 U00b4
    107 U00b4							; levelx and level have to be consecutive variables!
    108 U00b4		       00	   levelX     ds	1	; current player's level (other in scoring bank)
    109 U00b5		       00	   level      ds	1	; current player's level (other in scoring bank)
    110 U00b6		       00	   levelDisplay ds	1	; what to display as the level ID
    111 U00b7		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
    112 U00b8		       00	   ThrottleSpeed ds	1	; system-dependant throttle speed
    113 U00b9
    114 U00b9		       00	   targetsRequired ds	1	; number of un-targeted left to go
    115 U00ba		       00	   moveCounter ds	1	; BCD seconds for level
    116 U00bb		       00	   moveCounterHi ds	1
    117 U00bc		       00	   moveCounterBinary ds	1
    118 U00bd		       00 00 00    color      ds	3	; RGB for NTSC, RGB for PAL
    119 U00c0		       00 00	   Board_AddressR ds	2
    120 U00c2		       00 00	   Board_AddressW ds	2
    121 U00c4		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
    122 U00c5		       00	   RAM_Bank   ds	1
    123 U00c6
    124 U00c6		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
    125 U00c7		       00	   extraLifeTimer ds	1	; should be 5 seconds!
    126 U00c8
    127 U00c8							; extraLifeTimer:
    128 U00c8							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
    129 U00c8
    130 U00c8		       00	   scoringTimer ds	1	; times the various score displays
    131 U00c9		       00	   scoringFlags ds	1	; scoring flags are stored here
    132 U00ca
    133 U00ca							; scoringFlags:
    134 U00ca							; D7		 Extra TARGETs in effect (TARGETs collected over requirement score more) ASSUMED BPL/BMI usage
    135 U00ca							; D6		 unused
    136 U00ca							; D5		 unused
    137 U00ca							; D4		 unused
    138 U00ca							; D3		 unused
    139 U00ca							; D2		 unused
    140 U00ca							; D1	 D1-D0	 Which display kernel to use for scoring
    141 U00ca							; D0		 0 = 2x4     used for TARGETs/time
    142 U00ca							;		 1 = 1x6     used for score
    143 U00ca							;		 2 = 3x2     used for level/lives/player
    144 U00ca
    145 U00ca		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    146 U00ca		       00 80	   BIT_NEXTLEVEL =	128
    147 U00ca		       00 40	   BIT_NEXTLIFE =	64
    148 U00cb
    149 U00cb							;---------------------------------------------------------------------------
    150 U00cb
    151 U00cb		       00	   sortRequired ds	1
    152 U00cc		       00	   sortPtr    ds	1
    153 U00cd
    154 U00cd							;------------------------------------------------------------------------------
    155 U00cd
    156 U00cd		       00	   ObjIterator ds	1	; count UP iterator over objects
    157 U00ce		       00	   DSL	      ds	1	; stack line counter
    158 U00cf
------- FILE sound/intro1_variables.asm LEVEL 3 PASS 4
      0 U00cf					      include	"sound/intro1_variables.asm"
      1 U00cf							; TIATracker music player
      2 U00cf							; Copyright 2016 Andre "Kylearan" Wichmann
      3 U00cf							; Website: https://bitbucket.org/kylearan/tiatracker
      4 U00cf							; Email: andre.wichmann@gmx.de
      5 U00cf							;
      6 U00cf							; Licensed under the Apache License, Version 2.0 (the "License");
      7 U00cf							; you may not use this file except in compliance with the License.
      8 U00cf							; You may obtain a copy of the License at
      9 U00cf							;
     10 U00cf							;   http://www.apache.org/licenses/LICENSE-2.0
     11 U00cf							;
     12 U00cf							; Unless required by applicable law or agreed to in writing, software
     13 U00cf							; distributed under the License is distributed on an "AS IS" BASIS,
     14 U00cf							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15 U00cf							; See the License for the specific language governing permissions and
     16 U00cf							; limitations under the License.
     17 U00cf
     18 U00cf							; Song author: 
     19 U00cf							; Song name: 
     20 U00cf
     21 U00cf							; @com.wudsn.ide.asm.hardware=ATARI2600
     22 U00cf
     23 U00cf							; =====================================================================
     24 U00cf							; Flags
     25 U00cf							; =====================================================================
     26 U00cf
     27 U00cf							; 1: Global song speed, 0: Each pattern has individual speed
     28 U00cf		       00 01	   TT_GLOBAL_SPEED =	1
     29 U00cf							; duration (number of TV frames) of a note
     30 U00cf		       00 05	   TT_SPEED   =	5
     31 U00cf							; duration of odd frames (needs TT_USE_FUNKTEMPO)
     32 U00cf		       00 04	   TT_ODD_SPEED =	4
     33 U00cf
     34 U00cf							; 1: Overlay percussion, +40 bytes
     35 U00cf		       00 01	   TT_USE_OVERLAY =	1
     36 U00cf							; 1: Melodic instrument slide, +9 bytes
     37 U00cf		       00 00	   TT_USE_SLIDE =	0
     38 U00cf							; 1: Goto pattern, +8 bytes
     39 U00cf		       00 01	   TT_USE_GOTO =	1
     40 U00cf							; 1: Odd/even rows have different SPEED values, +7 bytes
     41 U00cf		       00 01	   TT_USE_FUNKTEMPO =	1
     42 U00cf							; If the very first notes played on each channel are not PAUSE, HOLD or
     43 U00cf							; SLIDE, i.e. if they start with an instrument or percussion, then set
     44 U00cf							; this flag to 0 to save 2 bytes.
     45 U00cf							; 0: +2 bytes
     46 U00cf		       00 01	   TT_STARTS_WITH_NOTES =	1
     47 U00cf
     48 U00cf
     49 U00cf							; =====================================================================
     50 U00cf							; Permanent variables. These are states needed by the player.
     51 U00cf							; =====================================================================
     52 U00cf		       00	   tt_timer   ds	1	; current music timer value
     53 U00d0		       00	   tt_cur_pat_index_c0 ds	1	; current pattern index into tt_SequenceTable
     54 U00d1		       00	   tt_cur_pat_index_c1 ds	1
     55 U00d2		       00	   tt_cur_note_index_c0 ds	1	; note index into current pattern
     56 U00d3		       00	   tt_cur_note_index_c1 ds	1
     57 U00d4		       00	   tt_envelope_index_c0 ds	1	; index into ADSR envelope
     58 U00d5		       00	   tt_envelope_index_c1 ds	1
     59 U00d6		       00	   tt_cur_ins_c0 ds	1	; current instrument
     60 U00d7		       00	   tt_cur_ins_c1 ds	1
     61 U00d8
     62 U00d8
     63 U00d8							; =====================================================================
     64 U00d8							; Temporary variables. These will be overwritten during a call to the
     65 U00d8							; player routine, but can be used between calls for other things.
     66 U00d8							; =====================================================================
     67 U00d8		       00 00	   tt_ptr     ds	2
------- FILE zeropage.asm
    160 U00da
    161 U00da
    162 U00da
    163 U00da				   OVERLAY_SIZE SET	16
    164 U00da
    165 U00da
    166 U00da
    167 U00da							; This overlay variable is used for the overlay variables.  That's OK.
    168 U00da							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    169 U00da							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    170 U00da							; (especially the latter ones) are only used in rare occasions.
    171 U00da
    172 U00da							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    173 U00da							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    174 U00da
    175 U00da		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00ea					      VALIDATE_OVERLAY
      5 U00ea					      LIST	ON
    177 U00ea
    178 U00ea
    179 U00ea		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    180 U00f6
 FREE BYTES IN ZERO PAGE =  $9
    181 U00f6					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    182 U00f6				  -	      IF	* > $FF
    183 U00f6				  -	      ERR
    184 U00f6					      ENDIF
------- FILE ./sokoboo.asm
    487 U00f6
    488 U00f6
    489 U00f6							;------------------------------------------------------------------------------
    490 U00f6							; OVERLAYS!
    491 U00f6							; These variables are overlays, and should be managed with care
    492 U00f6							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    493 U00f6
    494 U00f6							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    495 U00f6							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    496 U00f6
    497 U00f6							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    498 U00f6
    499 U00f6
    500 U00f6
    501 U00f6							;------------------------------------------------------------------------------
      0 U00f6					      OVERLAY	BuildDrawFlags
      1 U00e5 ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00da					      org	Overlay
    503 U00da
    504 U00da		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    505 U00dc		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    506 U00de		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    507 U00e0		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    508 U00e2							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    509 U00e2		       00	   BDF_BoardBank ds	1	; holds bank of current line
    510 U00e3							;  ENDIF
    511 U00e3		       00	   DHS_Line   ds	1
    512 U00e4		       00	   DHS_Stack  ds	1	; for restoring SP
    513 U00e5							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e5					      VALIDATE_OVERLAY
      5 U00e5					      LIST	ON
    515 U00e5
    516 U00e5							;------------------------------------------------------------------------------
    517 U00e5
      0 U00e5					      OVERLAY	Process
      1 U00dd ????				      SEG.U	OVERLAY_Process
      2 U00da					      org	Overlay
    519 U00da
    520 U00da		       00	   BOXLeft    ds	1
    521 U00db		       00	   BOXRight   ds	1
    522 U00dc		       00	   restorationCharacter ds	1
    523 U00dd
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    525 U00dd
    526 U00dd							;------------------------------------------------------------------------------
    527 U00dd
      0 U00dd					      OVERLAY	Animate
      1 U00db ????				      SEG.U	OVERLAY_Animate
      2 U00da					      org	Overlay
    529 U00da		       00	   halftimer  ds	1
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    531 U00db
    532 U00db							;------------------------------------------------------------------------------
    533 U00db
      0 U00db					      OVERLAY	TimeSlice
      1 U00dc ????				      SEG.U	OVERLAY_TimeSlice
      2 U00da					      org	Overlay
    535 U00da
    536 U00da		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    537 U00dc							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    539 U00dc
    540 U00dc							;------------------------------------------------------------------------------
    541 U00dc
      0 U00dc					      OVERLAY	CopyROMShadowToRAM
      1 U00dd ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00da					      org	Overlay
    543 U00da
    544 U00da		       00	   O_CopyCount ds	1
    545 U00db		       00	   O_ROM_Source_Bank ds	1
    546 U00dc		       00	   O_Index    ds	1
    547 U00dd							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    549 U00dd
    550 U00dd							;------------------------------------------------------------------------------
    551 U00dd
      0 U00dd					      OVERLAY	Scoring
      1 U00db ????				      SEG.U	OVERLAY_Scoring
      2 U00da					      org	Overlay
    553 U00da		       00	   tmpStack   ds	1
    554 U00da		       00 da	   newDisplay =	tmpStack
    555 U00db							; also for UpdateTimer
    556 U00db		       00 da	   tmpSound   =	tmpStack
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    558 U00db
    559 U00db
    560 U00db							;------------------------------------------------------------------------------
    561 U00db
      0 U00db					      OVERLAY	SaveKey
      1 U00e3 ????				      SEG.U	OVERLAY_SaveKey
      2 U00da					      org	Overlay
    563 U00da
    564 U00da		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    565 U00dd		       00 00 00    highScoreSK ds	3
    566 U00e0		       00	   startingLevel ds	1	; levelx * 5
    567 U00e1		       00	   startLevel ds	1
    568 U00e2		       00	   offsetSK   ds	1	; for calculating the SK slot address
    569 U00e3
      0 U00e3					      VALIDATE_OVERLAY
      5 U00e3					      LIST	ON
    571 U00e3
    572 U00e3							;------------------------------------------------------------------------------
    573 U00e3
      0 U00e3					      OVERLAY	DrawMan
      1 U00dc ????				      SEG.U	OVERLAY_DrawMan
      2 U00da					      org	Overlay
    575 U00da
    576 U00da		       00 00	   MAN_Move   ds	2
    577 U00dc
    578 U00dc							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    580 U00dc
    581 U00dc							;------------------------------------------------------------------------------
    582 U00dc
      0 U00dc					      OVERLAY	ProcessObjStack
      1 U00dc ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00da					      org	Overlay
    584 U00da
    585 U00da		       00 00	   POS_Vector ds	2
    586 U00dc
    587 U00dc							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    589 U00dc
    590 U00dc							;------------------------------------------------------------------------------
    591 U00dc
      0 U00dc					      OVERLAY	ScoreLineOverlay
      1 U00e9 ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00da					      org	Overlay
    593 U00da
    594 U00da		       00 00	   S0	      ds	2	; used for addressing digits of score
    595 U00dc		       00 00	   S1	      ds	2
    596 U00de		       00 00	   S2	      ds	2
    597 U00e0		       00 00	   S3	      ds	2
    598 U00e2		       00 00	   S4	      ds	2
    599 U00e4		       00 00	   S5	      ds	2
    600 U00e6
    601 U00e6		       00	   stkp       ds	1
    602 U00e7		       00	   sreg       ds	1
    603 U00e8		       00	   loop       ds	1
    604 U00e9
    605 U00e9							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e9					      VALIDATE_OVERLAY
      5 U00e9					      LIST	ON
    607 U00e9
    608 U00e9							;------------------------------------------------------------------------------
    609 U00e9
    610 U00e9
      0 U00e9					      OVERLAY	UnpackLevelOverlay
      1 U00df ????				      SEG.U	OVERLAY_UnpackLevelOverlay
      2 U00da					      org	Overlay
    612 U00da
    613 U00da		       00	   base_x     ds	1
    614 U00db		       00	   base_y     ds	1
    615 U00dc		       00	   upk_length ds	1
    616 U00dd		       00	   upk_column ds	1
    617 U00de		       00	   upk_temp   ds	1
    618 U00df
    619 U00df							;ECHO "FREE BYTES IN UnpackLevelOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00df					      VALIDATE_OVERLAY
      5 U00df					      LIST	ON
    621 U00df
    622 U00df							;------------------------------------------------------------------------------
    623 U00df
      0 U00df					      OVERLAY	ManProcessing
      1 U00dc ????				      SEG.U	OVERLAY_ManProcessing
      2 U00da					      org	Overlay
    625 U00da		       00 00	   actionVector ds	2
      0 U00dc					      VALIDATE_OVERLAY
      5 U00dc					      LIST	ON
    627 U00dc
      0 U00dc					      OVERLAY	SetPlatformColours
      1 U00db ????				      SEG.U	OVERLAY_SetPlatformColours
      2 U00da					      org	Overlay
    629 U00da		       00	   colorIdx   ds	1
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    631 U00db
      0 U00db					      OVERLAY	SwapPlayers
      1 U00db ????				      SEG.U	OVERLAY_SwapPlayers
      2 U00da					      org	Overlay
    633 U00da		       00	   tmpX       ds	1
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    635 U00db
      0 U00db					      OVERLAY	DrawIntoStack
      1 U00db ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00da					      org	Overlay
    637 U00da		       00	   save_SP    ds	1
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    639 U00db
    640 U00db							;------------------------------------------------------------------------------
    641 U00db							;##############################################################################
    642 U00db							;------------------------------------------------------------------------------
    643 U00db
    644 U00db							; NOW THE VERY INTERESTING '3E' RAM BANKS
    645 U00db							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    646 U00db
    647 U00db				   ORIGIN     SET	0
      0 U00db					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN / RAM_SIZE
      6 U0000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    649 U0000
    650 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    651 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    652 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    653 U0000
    654 U0000		       00 54	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    655 U0000
    656 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    657 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    658 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    659 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    660 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    661 U0000
    662 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    663 U0000							; is that we can use that code to switch between banks, and the system will happily
    664 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    665 U0000
    666 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    667 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    668 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    669 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    670 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    671 U0000
    672 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    673 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    674 U0000							; part of the draw routine *every* scanline (though the system currently uses
    675 U0000							; one colour shared between both players).
    676 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    678 U0000
    679 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    680 U0000							; accessed via the above labels but with the appropriate bank switched in.
    681 U0000
    682 U0000							;------------------------------------------------------------------------------
    683 U0000
    684 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    684 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    684 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    684 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1000				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    684 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    684 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    684 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    687 U1c00					      REPEND
    688 U1c00
    689 U1c00							;------------------------------------------------------------------------------
    690 U1c00							;##############################################################################
    691 U1c00							;------------------------------------------------------------------------------
    692 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN / RAM_SIZE
      6 U2000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    694 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    695 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    697 U2000
    698 U2000							;------------------------------------------------------------------------------
    699 U2000							;##############################################################################
    700 U2000							;------------------------------------------------------------------------------
    701 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN / RAM_SIZE
      6 U2400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    703 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    704 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    706 U2400
    707 U2400							;------------------------------------------------------------------------------
    708 U2400							;##############################################################################
    709 U2400							;------------------------------------------------------------------------------
    710 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_LEVEL
      1 U2800 ????				      SEG.U	BANK_DECODE_LEVEL
      2 U2800					      ORG	ORIGIN
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_LEVEL SET	ORIGIN / RAM_SIZE
      6 U2800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    712 U2800							; VARS DEFINED IN BANK_DECODE_LEVEL_SHADOW
    713 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    715 U2800
    716 U2800							;------------------------------------------------------------------------------
    717 U2800							;##############################################################################
    718 U2800							;------------------------------------------------------------------------------
    719 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN / RAM_SIZE
      6 U2c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
    721 U2c00
    722 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    723 U2c00							; position of something that needs to be processed.  These things include anything
    724 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    725 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    726 U2c00							; one for the next processing iteration.
    727 U2c00
    728 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    729 U2c00
    730 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    731 U2c00
    732 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    733 U2c00
    734 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    735 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    736 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    737 U2d80
    738 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    739 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    740 U2e00
    741 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    742 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    743 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    744 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    746 U2e80
    747 U2e80							;------------------------------------------------------------------------------
    748 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN / RAM_SIZE
      6 U3000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    750 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    752 U3000
    753 U3000							;------------------------------------------------------------------------------
    754 U3000							;##############################################################################
    755 U3000							;------------------------------------------------------------------------------
    756 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U37a0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN / RAM_SIZE
      6 U3400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    758 U3400
    759 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    760 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    761 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    762 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    763 U3400							; when accessing.
    764 U3400
    765 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    766 U3400							; automatically based on the sizes set in these constants. The board may overlay
    767 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    768 U3400							; we're doing OK.
    769 U3400
    770 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    771 U3400
    772 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    773 U3400
    774 U3400		       00 28	   SIZE_BOARD_X =	40
    775 U3400		       00 16	   SIZE_BOARD_Y =	22
    776 U3400				  -	      if	0
    777 U3400				  -			; have to precalculate it here, else DASM freaks out:
    778 U3400				  -.BOARD_SIZE SET	0
    779 U3400				  -.BOARD_LOCATION SET	0
    780 U3400				  -	      REPEAT	SIZE_BOARD_Y
    781 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    782 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    783 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    784 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    785 U3400				  -	      ENDIF
    786 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    787 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    788 U3400				  -	      REPEND
    789 U3400				  -
    790 U3400				  -SIZE_BOARD =	.BOARD_SIZE
    791 U3400					      endif
    792 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    793 U3400				  -MULTI_BANK_BOARD =	YES
    794 U3400					      ELSE
    795 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    796 U3400					      ENDIF
    797 U3400
    798 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    799 U37a0							; 1024 byte chunks, switching RAM
    800 U37a0							; banks as we go.  In other words,
    801 U37a0							; this overlaps multiple banks!
    802 U37a0
      0 U37a0					      NEWRAMBANK	BANK_TAKEBACK
      1 U3b00 ????				      SEG.U	BANK_TAKEBACK
      2 U3800					      ORG	ORIGIN
      3 U3800					      RORG	RAM_3E
      4 U3800				   BANK_START SET	*
      5 U3800				   BANK_TAKEBACK SET	ORIGIN / RAM_SIZE
      6 U3800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    804 U3800		       00 00 00 00*TakeBackX  ds	256
    805 U3900		       00 00 00 00*TakeBackY  ds	256
    806 U3a00		       00 00 00 00*TakeBackA  ds	256
    807 U3b00
    808 U3b00							; free space here (but hard to use)
    809 U3b00							; So we need to calculate where the next free bank is!
    810 U3b00							; TODO: This looks dodgy.  Check..
    811 U3b00
    812 U3b00				   ORIGIN     SET	( * + RAM_SIZE - 1 ) / RAM_SIZE
    813 U3b00				   ORIGIN     SET	ORIGIN * RAM_SIZE
    814 U3b00
    815 U3b00
    816 U3b00
    817 U3b00							;------------------------------------------------------------------------------
    818 U3b00							;##############################################################################
    819 U3b00							;------------------------------------------------------------------------------
    820 U3b00
    821 U3b00							;------------------------------------------------------------------------------
    822 U3b00
    823 U3b00							;    IFNCONST MAX_LEVEL_SIZE
    824 U3b00				   MAX_LEVEL_SIZE SET	0
    825 U3b00							;    ENDIF
    826 U3b00
    827 U3b00					      MAC	start_level
    828 U3b00				   LEVEL_START SET	*
    829 U3b00				   BANK_LEVEL_{1} =	_CURRENT_BANK
    830 U3b00				   LEVEL_{1}  SUBROUTINE
    831 U3b00				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
    832 U3b00							; ECHO "current MAX_LEVEL_NUMBER = ", MAX_LEVEL_NUMBER
    833 U3b00					      ENDM		; {name}
    834 U3b00
    835 U3b00
    836 U3b00					      MAC	end_level
    837 U3b00					      .byte	0
    838 U3b00				   LEVEL_SIZE_{1} =	* - LEVEL_START
    839 U3b00					      IF	LEVEL_SIZE_{1} > MAX_LEVEL_SIZE
    840 U3b00				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_{1}
    841 U3b00					      ENDIF
    842 U3b00					      ENDM		; {name}
    843 U3b00
    844 U3b00
    845 U3b00					      MAC	defl
    846 U3b00					      START_LEVEL	{1}
    847 U3b00					      .byte	{2},0
    848 U3b00					      END_LEVEL	{1}
    849 U3b00					      ENDM
    850 U3b00
    851 U3b00							;--------------------------------------------------------------------------------
    852 U3b00
    853 U3b00				   ORIGIN     SET	$00000
    854 U3b00
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 4
      0 U3b00					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1 U3b00							;    Sokoboo - a Sokoban implementation
      2 U3b00							;    using a generic tile-based display engine for the Atari 2600
      3 U3b00							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4 U3b00							;
      5 U3b00							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6 U3b00							;
      7 U3b00							;    Code related to the generic tile-based display engine was developed by
      8 U3b00							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9 U3b00							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10 U3b00							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11 U3b00							;
     12 U3b00							;    Code related to music and sound effects uses the TIATracker music player
     13 U3b00							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14 U3b00							;    directory for Apache licensing details.
     15 U3b00							;
     16 U3b00							;    Some level data incorporated in this program were created by Lee J Haywood.
     17 U3b00							;    See the copyright notices in the License directory for a list of level
     18 U3b00							;    contributors.
     19 U3b00							;
     20 U3b00							;    Except where otherwise indicated, this software is released under the
     21 U3b00							;    following licensing arrangement...
     22 U3b00							;
     23 U3b00							;    This program is free software: you can redistribute it and/or modify
     24 U3b00							;    it under the terms of the GNU General Public License as published by
     25 U3b00							;    the Free Software Foundation, either version 3 of the License, or
     26 U3b00							;    (at your option) any later version.
     27 U3b00							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28 U3b00
     29 U3b00							;    This program is distributed in the hope that it will be useful,
     30 U3b00							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31 U3b00							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32 U3b00							;    GNU General Public License for more details.
     33 U3b00
     34 U3b00							;------------------------------------------------------------------------------
     35 U3b00							;##############################################################################
     36 U3b00							;------------------------------------------------------------------------------
      0 U3b00					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  03e9 ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
     38  0000
     39  0000							; This is essentially a ROM mirror of a RAM bank.
     40  0000							; The contents of this bank are copied to each of the ROW banks on startup, and
     41  0000							; this gives a 1:1 correspondence between the data/addresses defined here, and
     42  0000							; the addresses in the switched-in RAM bank.
     43  0000
     44  0000							; Note: Bankswitching code between any of these banks guarantees the code can
     45  0000							; continue to run -- because, of course, the same code is still at the same
     46  0000							; memory address.
     47  0000
     48  0000		       00 01	   _PROFILE_DRAW =	YES
     49  0000
     50  0000					      MAC	profile_draw
     51  0000					      IF	_PROFILE_DRAW
     52  0000					      inc	Profile{1}
     53  0000					      bne	$skip
     54  0000					      inc	Profile{1}+1
     55  0000				   $skip
     56  0000					      ENDIF
     57  0000					      ENDM		; {label}
     58  0000
     59  0000
      0  0000					      DEFINE_SUBROUTINE	DrawTheScreen
      1  0000		       00 00	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  0000					      SUBROUTINE
      3  0000				   DrawTheScreen
     61  0000
     62  0000							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     63  0000							; A refactor of the kernel to improve the timing.
     64  0000							; Experimental refactor to remove the blank line...
     65  0000
     66  0000							; adjust here so that the first line of the kernel starts exactly at cycle 67
     67  0000							; (since TJ said it could start up to 5 cycles earlier than #67).
     68  0000
     69  0000							; TODO: remove GRP1 and COLUP1 access (or use higher resolution player)
     70  0000							;	     @57
      0  0000					      SLEEP	3	; 3
      1  0000				   .CYCLES    SET	3
      2  0000
      3  0000				  -	      IF	.CYCLES < 2
      4  0000				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0000				  -	      ERR
      6  0000					      ENDIF
      7  0000
      8  0000					      IF	.CYCLES & 1
      9  0000					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0000		       04 00		      nop	0
     11  0002				  -	      ELSE
     12  0002				  -	      bit	VSYNC
     13  0002					      ENDIF
     14  0002				   .CYCLES    SET	.CYCLES - 3
     15  0002					      ENDIF
     16  0002
     17  0002				  -	      REPEAT	.CYCLES / 2
     18  0002				  -	      nop
     19  0002					      REPEND
     72  0002
     73  0002		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     74  0004		       10 3e		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     75  0006
     76  0006				   Proc2		; 5
      0  0006					      SLEEP	3	; 3	     @64
      1  0006				   .CYCLES    SET	3
      2  0006
      3  0006				  -	      IF	.CYCLES < 2
      4  0006				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0006				  -	      ERR
      6  0006					      ENDIF
      7  0006
      8  0006					      IF	.CYCLES & 1
      9  0006					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0006		       04 00		      nop	0
     11  0008				  -	      ELSE
     12  0008				  -	      bit	VSYNC
     13  0008					      ENDIF
     14  0008				   .CYCLES    SET	.CYCLES - 3
     15  0008					      ENDIF
     16  0008
     17  0008				  -	      REPEAT	.CYCLES / 2
     18  0008				  -	      nop
     19  0008					      REPEND
     78  0008		       10 3c		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     79  000a
     80  000a				   ScanRED		;	     @60
     81  000a		       b9 7e f3    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     82  000d		       85 4d		      sta	PF0	; 3	     @67
     83  000f		       b9 00 f3 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     84  0012		       85 4e		      sta	PF1	; 3 = 14    @74
     85  0014				   SELFMOD_PLAYERCOL_RED
     86  0014		       b9 af f0 	      lda	SpriteColourRED,y	; 4
     87  0017		       85 46		      sta	COLUP0	; 3	     @05
     88  0019		       85 47		      sta	COLUP1	; 3 = 10    @08
     89  001b
     90  001b							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     91  001b
     92  001b				   SELFMOD_RED
     93  001b		       a9 00		      lda	#0	; 2
     94  001d		       85 48		      sta	COLUPF	; 3 =	5    @13
     95  001f
     96  001f				   SELFMOD_PLAYER0_RED
     97  001f		       b9 7e f3 	      lda	ShapePlayerRED,y	; 4
     98  0022		       85 5b		      sta	GRP0	; 3 =	7    @20
     99  0024
    100  0024		       b9 15 f3 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
    101  0027		       85 4f		      sta	PF2	; 3 =	7    @27
    102  0029
    103  0029		       b9 7e f3    SM_PF0_REDr lda	CHARACTERSHAPE_BLANK,y	; 4
    104  002c		       85 4d		      sta	PF0	; 3	     @34
    105  002e		       b9 2a f3 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
    106  0031		       85 4e		      sta	PF1	; 3	     @41
    107  0033		       b9 3f f3 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
    108  0036		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
    109  0038
    110  0038				   SELFMOD_PLAYER1_RED
    111  0038		       b9 7e f3 	      lda	ShapePlayerRED,y	; 4
    112  003b		       8d 5c 00 	      sta.w	GRP1	; 4 =	8    @56   VDELed!
    113  003e
    114  003e		       88		      dey		; 2
    115  003f		       10 c5		      bpl	Proc2	; 2(3)      --> 61 if taken
    116  0041
    117  0041		       e8	   SELFMOD_X  inx		; 2
    118  0042		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
    119  0044							;EXIT_RETURN_HERE
    120  0044				   NextALineStart
    121  0044		       a0 06		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
    122  0046				   ScanBLUEBD		;	     @67     let's start as late as possible
    123  0046
    124  0046							;------------------------------------------------------------------------------
    125  0046
    126  0046		       b9 7e f3    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
    127  0049		       85 4d		      sta	PF0	; 3 =	7    @74
    128  004b				   SELFMOD_PLAYERCOL_BLUE
    129  004b		       b9 bd f0 	      lda	SpriteColourBLUE,y	; 4
    130  004e		       85 47		      sta	COLUP1	; 3	     @05
    131  0050		       85 46		      sta	COLUP0	; 3 = 10    @08
    132  0052
    133  0052				   SELFMOD_BLUE
    134  0052		       a9 00		      lda	#0	; 2
    135  0054		       85 48		      sta	COLUPF	; 3 =	5    @13
    136  0056
    137  0056				   SELFMOD_PLAYER0_BLUE
    138  0056		       b9 7e f3 	      lda	ShapePlayerBLUE,y	; 4
    139  0059		       85 5b		      sta	GRP0	; 3 =	7    @20
    140  005b
    141  005b		       b9 0e f3 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    142  005e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    143  0060		       b9 23 f3 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    144  0063		       85 4f		      sta	PF2	; 3 = 14    @34
    145  0065
    146  0065		       b9 7e f3    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    147  0068		       85 4d		      sta	PF0	; 3	     @41
    148  006a		       b9 38 f3 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    149  006d		       85 4e		      sta	PF1	; 3	     @48
    150  006f		       b9 4d f3 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    151  0072		       85 4f		      sta	PF2	; 3 = 21    @55
    152  0074
    153  0074				   SELFMOD_PLAYER1_BLUE
    154  0074		       b9 7e f3 	      lda	ShapePlayerBLUE,y	; 4
    155  0077		       85 5c		      sta	GRP1	; 3 =	7    VDELed! @62
    156  0079
    157  0079							;------------------------------------------------------------------------------
    158  0079
    159  0079				   ScanGREEN		;	     @62
    160  0079		       b9 7e f3    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    161  007c		       85 4d		      sta	PF0	; 3 =	7    @69
    162  007e				   SELFMOD_PLAYERCOL_GREEN
    163  007e		       b9 b6 f0 	      lda	SpriteColourGREEN,y	; 4
    164  0081		       85 47		      sta	COLUP1	; 3	     @00
    165  0083		       85 46		      sta	COLUP0	; 3 = 10    @03
    166  0085
    167  0085				   SELFMOD_GREEN
    168  0085		       a9 00		      lda	#0	; 2
    169  0087		       85 48		      sta	COLUPF	; 3 =	5    @08
    170  0089
    171  0089				   SELFMOD_PLAYER0_GREEN
    172  0089		       b9 7e f3 	      lda	ShapePlayerGREEN,y	; 4
    173  008c		       85 5b		      sta	GRP0	; 3 =	7    @15
    174  008e
    175  008e		       b9 07 f3 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    176  0091		       85 4e		      sta	PF1	; 3	     @22
    177  0093		       b9 1c f3 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    178  0096		       85 4f		      sta	PF2	; 3 = 14    @29
    179  0098
    180  0098		       b9 7e f3    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    181  009b		       85 4d		      sta	PF0	; 3	     @36
    182  009d		       b9 31 f3 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    183  00a0		       85 4e		      sta	PF1	; 3	     @43
    184  00a2		       b9 46 f3 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    185  00a5		       85 4f		      sta	PF2	; 3 = 21    @50
    186  00a7
    187  00a7				   SELFMOD_PLAYER1_GREEN
    188  00a7		       b9 7e f3 	      lda	ShapePlayerGREEN,y	; 4
    189  00aa		       85 5c		      sta	GRP1	; 3 =	7    @57     VDELed!
    190  00ac
    191  00ac		       4c 0a f0 	      jmp	ScanRED	; 3	     @60
    192  00af
    193  00af							;------------------------------------------------------------------------------
    194  00af
    195  00af							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    196  00af
    197  00af		       f3 7e	   ShapePlayer =	PLAYER_BLANK
    198  00af		       f3 7e	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    199  00af		       f3 7e	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    200  00af		       f3 7e	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    201  00af
    202  00af		       f3 7e	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    203  00af		       f3 7e	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    204  00af
------- FILE playerColour.asm LEVEL 3 PASS 4
      0  00af					      include	"playerColour.asm"	; 1 * LINES_PER_CHAR bytes
      1  00af							;;    Sokoboo - a Sokoban implementation
      2  00af							;    using a generic tile-based display engine for the Atari 2600
      3  00af							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  00af							;
      5  00af							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  00af							;
      7  00af							;    Code related to the generic tile-based display engine was developed by
      8  00af							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  00af							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  00af							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  00af							;
     12  00af							;    Code related to music and sound effects uses the TIATracker music player
     13  00af							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  00af							;    directory for Apache licensing details.
     15  00af							;
     16  00af							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  00af							;    See the copyright notices in the License directory for a list of level
     18  00af							;    contributors.
     19  00af							;
     20  00af							;    Except where otherwise indicated, this software is released under the
     21  00af							;    following licensing arrangement...
     22  00af							;
     23  00af							;    This program is free software: you can redistribute it and/or modify
     24  00af							;    it under the terms of the GNU General Public License as published by
     25  00af							;    the Free Software Foundation, either version 3 of the License, or
     26  00af							;    (at your option) any later version.
     27  00af							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  00af
     29  00af							;    This program is distributed in the hope that it will be useful,
     30  00af							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  00af							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  00af							;    GNU General Public License for more details.
     33  00af
      0  00af					      OPTIONAL_PAGEBREAK	"SpriteColour", LINES_PER_CHAR*2
     10  00af					      LIST	ON
     35  00af
     36  00af		       00 10	   YELLOW_NTSC =	$10	; hair
     37  00af		       00 30	   ORANGE_NTSC =	$30	; skin
     38  00af		       00 40	   RED_NTSC   =	$40	; shirt
     39  00af		       00 a4	   BLUE_NTSC  =	$A4
     40  00af
     41  00af		       00 20	   YELLOW_PAL =	$20
     42  00af		       00 40	   ORANGE_PAL =	$40
     43  00af		       00 60	   RED_PAL    =	$60
     44  00af
     45  00af				   SpriteColour
     46  00af							; NTSC
     47  00af							;SpriteColourRED
     48  00af							;    .byte RED_NTSC|$6       ; 0 feet
     49  00af							;    .byte WHITE	      ; 3
     50  00af							;    .byte RED_NTSC|$4       ; 6
     51  00af							;    .byte RED_NTSC|$4       ; 9
     52  00af							;    .byte ORANGE_NTSC|$6    ;12
     53  00af							;    .byte ORANGE_NTSC|$8    ;15
     54  00af							;    .byte WHITE	      ;18
     55  00af							;SpriteColourGREEN
     56  00af							;    .byte RED_NTSC|$4       ; 1
     57  00af							;    .byte WHITE	      ; 4
     58  00af							;    .byte WHITE	      ; 7
     59  00af							;    .byte WHITE	      ;10
     60  00af							;    .byte ORANGE_NTSC|$8    ;13
     61  00af							;    .byte ORANGE_NTSC|$6    ;16
     62  00af							;    .byte WHITE	      ;19
     63  00af							;SpriteColourBLUE
     64  00af							;    .byte WHITE	      ; 2
     65  00af							;    .byte RED_NTSC|$4       ; 5
     66  00af							;    .byte RED_NTSC|$4       ; 8
     67  00af							;    .byte ORANGE_NTSC|$4    ;11 neck
     68  00af							;    .byte ORANGE_NTSC|$a    ;14
     69  00af							;    .byte YELLOW_NTSC|$c    ;17 hair
     70  00af							;    .byte WHITE	      ;20
     71  00af
     72  00af				   SpriteColourRED
     73  00af		       76		      .byte.b	$76
     74  00b0		       76		      .byte.b	$76
     75  00b1		       76		      .byte.b	$76
     76  00b2		       76		      .byte.b	$76
     77  00b3		       76		      .byte.b	$76
     78  00b4		       76		      .byte.b	$76
     79  00b5		       76		      .byte.b	$76
     80  00b6
     81  00b6							;  .byte #$1C;0
     82  00b6							;  .byte #$78;3
     83  00b6							;  .byte #$52;6
     84  00b6							;  .byte #$52;9
     85  00b6							;  .byte #$0C;12
     86  00b6							;  .byte #$4A;15
     87  00b6							;  .byte #$1A;18
     88  00b6				   SpriteColourGREEN
     89  00b6		       7a		      .byte.b	$7A
     90  00b7		       7a		      .byte.b	$7A
     91  00b8		       7a		      .byte.b	$7A
     92  00b9		       7a		      .byte.b	$7A
     93  00ba		       7a		      .byte.b	$7A
     94  00bb		       7a		      .byte.b	$7A
     95  00bc		       7a		      .byte.b	$7A
     96  00bd				   SpriteColourBLUE
     97  00bd		       2a		      .byte.b	$2A
     98  00be		       2a		      .byte.b	$2A
     99  00bf		       2a		      .byte.b	$2A
    100  00c0		       2a		      .byte.b	$2A
    101  00c1		       2a		      .byte.b	$2A
    102  00c2		       2a		      .byte.b	$2A
    103  00c3		       2a		      .byte.b	$2A
    104  00c4
    105  00c4					      REPEAT	21
    106  00c4		       26		      .byte.b	$20|$6	; 2
    105  00c4					      REPEND
    106  00c5		       26		      .byte.b	$20|$6	; 2
    105  00c5					      REPEND
    106  00c6		       26		      .byte.b	$20|$6	; 2
    105  00c6					      REPEND
    106  00c7		       26		      .byte.b	$20|$6	; 2
    105  00c7					      REPEND
    106  00c8		       26		      .byte.b	$20|$6	; 2
    105  00c8					      REPEND
    106  00c9		       26		      .byte.b	$20|$6	; 2
    105  00c9					      REPEND
    106  00ca		       26		      .byte.b	$20|$6	; 2
    105  00ca					      REPEND
    106  00cb		       26		      .byte.b	$20|$6	; 2
    105  00cb					      REPEND
    106  00cc		       26		      .byte.b	$20|$6	; 2
    105  00cc					      REPEND
    106  00cd		       26		      .byte.b	$20|$6	; 2
    105  00cd					      REPEND
    106  00ce		       26		      .byte.b	$20|$6	; 2
    105  00ce					      REPEND
    106  00cf		       26		      .byte.b	$20|$6	; 2
    105  00cf					      REPEND
    106  00d0		       26		      .byte.b	$20|$6	; 2
    105  00d0					      REPEND
    106  00d1		       26		      .byte.b	$20|$6	; 2
    105  00d1					      REPEND
    106  00d2		       26		      .byte.b	$20|$6	; 2
    105  00d2					      REPEND
    106  00d3		       26		      .byte.b	$20|$6	; 2
    105  00d3					      REPEND
    106  00d4		       26		      .byte.b	$20|$6	; 2
    105  00d4					      REPEND
    106  00d5		       26		      .byte.b	$20|$6	; 2
    105  00d5					      REPEND
    106  00d6		       26		      .byte.b	$20|$6	; 2
    105  00d6					      REPEND
    106  00d7		       26		      .byte.b	$20|$6	; 2
    105  00d7					      REPEND
    106  00d8		       26		      .byte.b	$20|$6	; 2
    107  00d9					      REPEND
    108  00d9
    109  00d9							; PAL
    110  00d9							;    .byte RED_PAL|$6	      ; 0 feet
    111  00d9							;    .byte WHITE	      ; 3
    112  00d9							;    .byte RED_PAL|$4	      ; 6
    113  00d9							;    .byte RED_PAL|$4	      ; 9
    114  00d9							;    .byte ORANGE_PAL|$4     ;12
    115  00d9							;    .byte ORANGE_PAL|$6     ;15
    116  00d9							;    .byte WHITE	      ;18
    117  00d9							;
    118  00d9							;    .byte RED_PAL|$4	      ; 1
    119  00d9							;    .byte WHITE	      ; 4
    120  00d9							;    .byte WHITE	      ; 7
    121  00d9							;    .byte WHITE	      ;10
    122  00d9							;    .byte ORANGE_PAL|$6     ;13
    123  00d9							;    .byte ORANGE_PAL|$4     ;16
    124  00d9							;    .byte WHITE	      ;19
    125  00d9							;
    126  00d9							;    .byte WHITE	      ; 2
    127  00d9							;    .byte RED_PAL|$4	      ; 5
    128  00d9							;    .byte RED_PAL|$4	      ; 8
    129  00d9							;    .byte ORANGE_PAL|$2     ;11 neck
    130  00d9							;    .byte ORANGE_PAL|$8     ;14
    131  00d9							;    .byte YELLOW_PAL|$c     ;17 hair
    132  00d9							;    .byte WHITE	      ;20
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    206  00d9
    207  00d9
    208  00d9							;------------------------------------------------------------------------------
    209  00d9
    210  00d9							;*** Ideas: ***
    211  00d9							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    212  00d9							;   13.5% on average), also unrolling would be more effective than now
    213  00d9							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    214  00d9							;   see EXPERIMENTAL)
    215  00d9							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    216  00d9							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    217  00d9							;   bidirectional linked list instead)
    218  00d9							; - calculate mirrored gfx data into RAM (saves ROM)
    219  00d9
    220  00d9							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    221  00d9							;currently:
    222  00d9							; 72%*539 (!unrolled)
    223  00d9							;+ 8%*304 (unrolled)
    224  00d9							;+20%*269 (unrolled)
    225  00d9							;--------
    226  00d9							;=   ~466.2 cycles on average
    227  00d9
    228  00d9							;alternative #1:
    229  00d9							; 72%*522 (unrolled)
    230  00d9							;+ 8%*352 (!unrolled)
    231  00d9							;+20%*307 (!unrolled)
    232  00d9							;--------
    233  00d9							;=   ~465.4 cycles on average
    234  00d9
    235  00d9
    236  00d9		       00 01	   MIRROR     =	1
    237  00d9		       00 80	   DIRECT     =	$80
    238  00d9
    239  00d9							;------------------------------------------------------------------------------
    240  00d9							; Here we don't draw into a buffer, but directly patch the kernel
    241  00d9							; VERY fast!
    242  00d9							;
    243  00d9							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    244  00d9							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    245  00d9
    246  00d9				   PF0Draw		; 25 cycles until here
    247  00d9
    248  00d9		       ae 84 02 	      ldx	INTIM	; 4
    249  00dc		       e0 05		      cpx	#SEGTIME_SCD_PF0	; 2
    250  00de		       90 72		      bcc	ExitDraw	; 2(3)=8
      0  00e0					      STRESS_TIME	SEGTIME_SCD_PF0	; ok!
      1  00e0				  -	      IF	TEST_SEGTIME_SCD_PF0 = 1
      2  00e0				  -
      3  00e0				  -
      4  00e0				  -
      5  00e0				  -
      6  00e0				  -
      7  00e0				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  00e0				  -	      bne	. - 7
      9  00e0					      ENDIF
    252  00e0
    253  00e0		       29 7f		      and	#<(~DIRECT)	; 2
    254  00e2		       aa		      tax		; 2 =	4
    255  00e3
    256  00e3		       98		      tya		; 2
    257  00e4		       0a		      asl		; 2	     no mirrored chars in PF0
    258  00e5		       a8		      tay		; 2 =	6
    259  00e6							;		  clc				  ; 2
    260  00e6
    261  00e6		       b9 d1 f3 	      lda	CharacterDataVecHI,y	; 4
    262  00e9		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    263  00ec		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    264  00ef		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19
    265  00f2
    266  00f2		       b9 bd f3 	      lda	CharacterDataVecLO,y	; 4
    267  00f5		       9d 0b f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    268  00f8		       69 06		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    269  00fa		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    270  00fd		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    271  00ff		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23
    272  0102
    273  0102		       4c 2f fa 	      jmp	DrawAnother	; 3 =	3
    274  0105
    275  0105							; Timing for PF0Draw
    276  0105							; 7+63 = 70
    277  0105							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    278  0105
    279  0105
    280  0105							;------------------------------------------------------------------------------
    281  0105							; Direct draw draws to PF0, which only has one active member of the character
    282  0105							; pair -- so it can be a direct copy.	Quicker still!
    283  0105
    284  0105				   DirectDraw		; 37 cycles until here
    285  0105
    286  0105							;ldy #16
    287  0105		       ad 84 02 	      lda	INTIM	; 4
    288  0108		       c9 08		      cmp	#SEGTIME_SCD_DIRECT	; 2
    289  010a		       90 46		      bcc	ExitDraw	; 2(3)=8
      0  010c					      STRESS_TIME	SEGTIME_SCD_DIRECT	; ok!
      1  010c				  -	      IF	TEST_SEGTIME_SCD_DIRECT = 1
      2  010c				  -
      3  010c				  -
      4  010c				  -
      5  010c				  -
      6  010c				  -
      7  010c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  010c				  -	      bne	. - 7
      9  010c					      ENDIF
    291  010c
    292  010c							; TIME REQUIRED FROM HERE (9/JAN)
    293  010c							; 16 + 20 + 20 + 2 + ( 7 * 32 ) - 1  + (42 SUFFIX)
    294  010c							; = 323 --> /64 = 5.04 USE 7
    295  010c
    296  010c		       b9 d1 f3 	      lda	CharacterDataVecHI,y	; 4
    297  010f		       8d 3c f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    298  0112		       8d 42 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    299  0115		       8d 48 f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    300  0118
    301  0118		       b9 bd f3 	      lda	CharacterDataVecLO,y	; 4
    302  011b		       8d 3b f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    303  011e		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    304  0120		       8d 41 f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    305  0123		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    306  0125		       8d 47 f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    307  0128
    308  0128		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    309  012b		       8d 3e f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    310  012e		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    311  0130		       8d 44 f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    312  0133		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    313  0135		       8d 4a f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    314  0138
    315  0138		       a0 06		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    316  013a				   TSFill3
    317  013a		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    318  013d		       99 00 f7    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    319  0140		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    320  0143		       99 00 f7    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    321  0146		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    322  0149		       99 00 f7    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    323  014c
    324  014c		       88		      dey		; 2
      0  014d					      CHECKPAGE_BPL	TSFill3	; 3(2)=5
      8  014d					      LIST	ON
      9  014d		       10 eb		      bpl	TSFill3
    326  014f
    327  014f		       4c 2f fa 	      jmp	DrawAnother	; 3
    328  0152
    329  0152							; Timing for DirectDraw
    330  0152							; 17+8+16+20+20+2+(32*7)-1+3 = 309 (was: 302 + 3)
    331  0152							; total: 37+309+6 = 352 => 352/64 + 1.4 = 6.90 = 7 (= SEGTIME_SLOWDRAW-5)
    332  0152
    333  0152				   ExitDraw
    334  0152		       60		      rts
    335  0153
    336  0153							;------------------------------------------------------------------------------
      0  0153					      DEFINE_SUBROUTINE	StealPart3	; 18 CYCLES HERE
      1  0153		       00 00	   BANK_StealPart3 =	_CURRENT_BANK
      2  0153					      SUBROUTINE
      3  0153				   StealPart3
    338  0153
    339  0153		       bd ee f1 	      lda	MOD10,x	; 4
    340  0156		       30 81		      bmi	PF0Draw	; 2/3
    341  0158		       4a		      lsr		; 2
    342  0159		       aa		      tax		; 2
    343  015a		       98		      tya		; 2
    344  015b		       2a		      rol		; 2	     allows for mirrored char = * | 1
    345  015c		       a8		      tay		; 2
    346  015d		       b0 a6		      bcs	DirectDraw	; 2(3)      when draw stack was built, bit 7 flags direct-drawn character
    347  015f							;	     => +19 starting DirectDraw BUT WHO CARES AS IT'S ONLY AFTER THAT COUNTS
    348  015f
    349  015f		       b9 d1 f3 	      lda	CharacterDataVecHI,y	; 4
    350  0162		       10 38		      bpl	QuickDraw	; 2(3)=42   special-case blank characters for extra speed
    351  0164							;	     => 42 starting QuickDraw
    352  0164		       8d 8d f5 	      sta	SMEOR1+RAM_WRITE+2	; 4 =	4
    353  0167
    354  0167		       ad 84 02 	      lda	INTIM	; 4
    355  016a		       c9 0c		      cmp	#SEGTIME_SCD_SLOW	; 2
    356  016c		       90 e4		      bcc	ExitDraw	; 2(3)=8
      0  016e					      STRESS_TIME	SEGTIME_SCD_SLOW	; ok!
      1  016e				  -	      IF	TEST_SEGTIME_SCD_SLOW = 1
      2  016e				  -
      3  016e				  -
      4  016e				  -
      5  016e				  -
      6  016e				  -
      7  016e				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  016e				  -	      bne	. - 7
      9  016e					      ENDIF
    358  016e
    359  016e							; TIME REQUIRED FROM HERE (9/JAN)
    360  016e							; 8 + 16 + 8 + 2 + (21 * 23) -1 + (42 OVERHEAD WHEN RETURNING)
    361  016e							; = 558 --> /64 = 8.71 INTIM --> USE 10
    362  016e
    363  016e		       b9 bd f3 	      lda	CharacterDataVecLO,y	; 4
    364  0171		       8d 8c f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    365  0174
    366  0174		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    367  0177		       8d 89 f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    368  017a		       8d 91 f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    369  017d		       8d 94 f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    370  0180
    371  0180		       bd e6 f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    372  0183		       8d 8f f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    373  0186
    374  0186		       a0 14	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2
    375  0188
    376  0188							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    377  0188							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    378  0188
    379  0188				   TSFill
    380  0188
    381  0188		       b9 00 f3    SMLOAD     lda	ScreenBitmap,y	; 4
    382  018b		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    383  018e		       29 00	   SMMASK     and	#0	; 2
    384  0190		       59 00 f3    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    385  0193		       99 00 f7    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    386  0196
    387  0196		       88		      dey		; 2
      0  0197					      CHECKPAGE_BPL	TSFill	; 3(2)=5
      8  0197					      LIST	ON
      9  0197		       10 ef		      bpl	TSFill
    389  0199
    390  0199		       4c 2f fa 	      jmp	DrawAnother	; 3
    391  019c
    392  019c							; Timing for "SLOW" draw
    393  019c							; 22+4+8+8+16+8+2+(21*24)-1+3 = 574 (was: 566 + 3)
    394  019c							; total: 37+574+6 = 617 => 628/64 + 1.4 = 11.04 = 12 (= SEGTIME_SLOWDRAW)
    395  019c
    396  019c
    397  019c							;------------------------------------------------------------------------------
    398  019c							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    399  019c							; existing character data, so can be special-cased from the normal character
    400  019c							; draw, saving roughly 230 cycles.
    401  019c
    402  019c				   QuickDraw		; 42 cycles until here
    403  019c
    404  019c		       ad 84 02 	      lda	INTIM	; 4
    405  019f		       c9 09		      cmp	#SEGTIME_SCD_QUICK	; 2	     SEE TIMING CALCS BELOW
    406  01a1		       90 af		      bcc	ExitDraw	; 2(3)=8
      0  01a3					      STRESS_TIME	SEGTIME_SCD_QUICK	; ok!
      1  01a3				  -	      IF	TEST_SEGTIME_SCD_QUICK = 1
      2  01a3				  -
      3  01a3				  -
      4  01a3				  -
      5  01a3				  -
      6  01a3				  -
      7  01a3				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  01a3				  -	      bne	. - 7
      9  01a3					      ENDIF
    408  01a3
    409  01a3							; TIME REQUIRED FROM HERE (9/JAN)
    410  01a3							;   = 32 + 4 + 2 + ( 7 * 38 ) - 1 + 3	+ (42 SUFFIX)
    411  01a3							;   = 348 --> /64 = 5.43. USE 7
    412  01a3
    413  01a3		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    414  01a6		       8d c3 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    415  01a9		       8d c6 f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    416  01ac		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    417  01ae		       8d ca f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    418  01b1		       8d cd f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    419  01b4		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    420  01b6		       8d d1 f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    421  01b9		       8d d4 f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32
    422  01bc
    423  01bc		       bc e4 f1 	      ldy	CharMask,x	; 4 =	4    masks out left or right
    424  01bf
    425  01bf		       a2 06		      ldx	#LINES_PER_CHAR/3 - 1	; 2 =	2
    426  01c1				   TSFill2
    427  01c1		       98		      tya		; 2
    428  01c2		       3d 00 f3    SM2LOAD    and	ScreenBitmap,x	; 4+
    429  01c5		       9d 00 f7    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    430  01c8		       98		      tya		; 2
    431  01c9		       3d 00 f3    SM2LOADb   and	ScreenBitmap,x	; 4+
    432  01cc		       9d 00 f7    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    433  01cf		       98		      tya		; 2
    434  01d0		       3d 00 f3    SM2LOADc   and	ScreenBitmap,x	; 4+
    435  01d3		       9d 00 f7    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33
    436  01d6
    437  01d6		       ca		      dex		; 2
      0  01d7					      CHECKPAGE_BPL	TSFill2	; 3(2)=5
      8  01d7					      LIST	ON
      9  01d7		       10 e8		      bpl	TSFill2
    439  01d9
    440  01d9		       4c 2f fa 	      jmp	DrawAnother	; 3
    441  01dc
    442  01dc							; Timing for QuickDraw
    443  01dc							; 23+8+32+4+2+(7*38)-1+3 = 337 (was: 330 + 3)
    444  01dc							; total: 37+337+6 = 380 => 380/64 + 1.4 = 7.34 = 8 (= SEGTIME_SLOWDRAW-4)
    445  01dc
    446  01dc
    447  01dc							;------------------------------------------------------------------------------
    448  01dc
    449  01dc
    450  01dc				   CharAddressLO		;[abs char location % 10]
    451  01dc
    452  01dc							; Gives the absolute screen buffer address of the first line of the given character
    453  01dc							; Where character number is 0-9
    454  01dc
    455  01dc		       00		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    456  01dd		       00		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    457  01de		       15		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    458  01df		       15		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    459  01e0		       2a		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    460  01e1		       2a		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    461  01e2		       3f		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    462  01e3		       3f		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    463  01e4							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    464  01e4							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    465  01e4
    466  01e4				   CharMask		; [abs char location % 10]
    467  01e4
    468  01e4							; Gives the mask for any char of the screen (per row)
    469  01e4							; Note, this is hardwired to the screen format of 6 bytes/line
    470  01e4
    471  01e4		       0f		      .byte.b	$0F	; 1
    472  01e5		       f0		      .byte.b	$F0	; 2
    473  01e6				   CharMaskNeg
    474  01e6		       f0		      .byte.b	$F0	; 3/1
    475  01e7		       0f		      .byte.b	$0F	; 4/2
    476  01e8		       0f		      .byte.b	$0F	; 6/3
    477  01e9		       f0		      .byte.b	$F0	; 7/4
    478  01ea		       f0		      .byte.b	$F0	; 8/6
    479  01eb		       0f		      .byte.b	$0F	; 9/7
    480  01ec		       0f		      .byte.b	$0F	; -/8
    481  01ed		       f0		      .byte.b	$F0	; -/9
    482  01ee				   MOD10
    483  01ee					      REPEAT	SCREEN_LINES
    484  01ee							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  01ee							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  01ee		       80		      .byte.b	DIRECT
    487  01ef		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  01f3		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  01f4		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  01f4					      REPEND
    484  01f8							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  01f8							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  01f8		       80		      .byte.b	DIRECT
    487  01f9		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  01fd		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  01fe		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  01fe					      REPEND
    484  0202							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0202							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0202		       80		      .byte.b	DIRECT
    487  0203		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0207		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0208		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0208					      REPEND
    484  020c							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  020c							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  020c		       80		      .byte.b	DIRECT
    487  020d		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0211		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0212		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0212					      REPEND
    484  0216							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0216							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0216		       80		      .byte.b	DIRECT
    487  0217		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  021b		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  021c		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  021c					      REPEND
    484  0220							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0220							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0220		       80		      .byte.b	DIRECT
    487  0221		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0225		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0226		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0226					      REPEND
    484  022a							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  022a							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  022a		       80		      .byte.b	DIRECT
    487  022b		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  022f		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  0230		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    483  0230					      REPEND
    484  0234							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    485  0234							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    486  0234		       80		      .byte.b	DIRECT
    487  0235		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    488  0239		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    489  023a		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    490  023e					      REPEND
    491  023e
    492  023e							;------------------------------------------------------------------------------
    493  023e
------- FILE characterset/target.asm LEVEL 3 PASS 4
      0  023e					      include	"characterset/target.asm"	; 2 * LINES_PER_CHAR + 2 bytes
      1  023e							;    Sokoboo - a Sokoban implementation
      2  023e							;    using a generic tile-based display engine for the Atari 2600
      3  023e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  023e							;
      5  023e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  023e							;
      7  023e							;    Code related to the generic tile-based display engine was developed by
      8  023e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  023e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  023e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  023e							;
     12  023e							;    Code related to music and sound effects uses the TIATracker music player
     13  023e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  023e							;    directory for Apache licensing details.
     15  023e							;
     16  023e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  023e							;    See the copyright notices in the License directory for a list of level
     18  023e							;    contributors.
     19  023e							;
     20  023e							;    Except where otherwise indicated, this software is released under the
     21  023e							;    following licensing arrangement...
     22  023e							;
     23  023e							;    This program is free software: you can redistribute it and/or modify
     24  023e							;    it under the terms of the GNU General Public License as published by
     25  023e							;    the Free Software Foundation, either version 3 of the License, or
     26  023e							;    (at your option) any later version.
     27  023e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  023e
     29  023e							;    This program is distributed in the hope that it will be useful,
     30  023e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  023e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  023e							;    GNU General Public License for more details.
     33  023e
     34  023e		       00 02	   TARGET_DEF =	2
     35  023e
     36  023e					      if	TARGET_DEF = 2
     37  023e
      0  023e					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET", LINES_PER_CHAR+1
     10  023e					      LIST	ON
     39  023e							;CHARACTERSHAPE_TARGET2_MIRRORED
     40  023e							;    .byte %00000000
     41  023e				   CHARACTERSHAPE_TARGET
     42  023e				   CHARACTERSHAPE_TARGET_MIRRORED
     43  023e		       00		      .byte.b	%00000000
     44  023f		       66		      .byte.b	%01100110
     45  0240		       66		      .byte.b	%01100110
     46  0241		       66		      .byte.b	%01100110
     47  0242		       66		      .byte.b	%01100110
     48  0243		       00		      .byte.b	%00000000
     49  0244		       00		      .byte.b	%00000000	;R
     50  0245		       00		      .byte.b	%00000000
     51  0246		       66		      .byte.b	%01100110
     52  0247		       66		      .byte.b	%01100110
     53  0248		       66		      .byte.b	%01100110
     54  0249		       66		      .byte.b	%01100110
     55  024a		       00		      .byte.b	%00000000
     56  024b		       00		      .byte.b	%00000000	;B
     57  024c		       00		      .byte.b	%00000000
     58  024d		       66		      .byte.b	%01100110
     59  024e		       66		      .byte.b	%01100110
     60  024f		       66		      .byte.b	%01100110
     61  0250		       66		      .byte.b	%01100110
     62  0251		       00		      .byte.b	%00000000
     63  0252							;    .byte %00000000 ;G
     64  0252
     65  0252							;--------------------------------------------------------------------------
     66  0252							;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_TARGET_MIRRORED", LINES_PER_CHAR+1
     67  0252
     68  0252				   CHARACTERSHAPE_TARGET2
     69  0252				   CHARACTERSHAPE_TARGET2_MIRRORED
     70  0252		       00 00 00 00*	      ds	21,0
     71  0267
      0  0267					      CHECKPAGE	CHARACTERSHAPE_TARGET2	; since we share one byte!
      8  0267					      LIST	ON
     73  0267
     74  0267					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE characterset/Brick_Wall.asm LEVEL 3 PASS 4
      0  0267					      include	"characterset/Brick_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      1  0267							;    Sokoboo - a Sokoban implementation
      2  0267							;    using a generic tile-based display engine for the Atari 2600
      3  0267							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0267							;
      5  0267							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0267							;
      7  0267							;    Code related to the generic tile-based display engine was developed by
      8  0267							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0267							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0267							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0267							;
     12  0267							;    Code related to music and sound effects uses the TIATracker music player
     13  0267							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0267							;    directory for Apache licensing details.
     15  0267							;
     16  0267							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0267							;    See the copyright notices in the License directory for a list of level
     18  0267							;    contributors.
     19  0267							;
     20  0267							;    Except where otherwise indicated, this software is released under the
     21  0267							;    following licensing arrangement...
     22  0267							;
     23  0267							;    This program is free software: you can redistribute it and/or modify
     24  0267							;    it under the terms of the GNU General Public License as published by
     25  0267							;    the Free Software Foundation, either version 3 of the License, or
     26  0267							;    (at your option) any later version.
     27  0267							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0267
     29  0267							;    This program is distributed in the hope that it will be useful,
     30  0267							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0267							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0267							;    GNU General Public License for more details.
     33  0267
      0  0267					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  0267					      LIST	ON
     35  0267
     36  0267		       00 00	   BRICK_WALL_DEF =	0
     37  0267
     38  0267				   CHARACTERSHAPE_WALL
     39  0267				   CHARACTERSHAPE_WALL0
     40  0267
     41  0267
     42  0267
     43  0267				  -	      if	MIRRORED_WALL = NO
     44  0267				  -CHARACTERSHAPE_WALL_MIRRORED
     45  0267				  -CHARACTERSHAPE_WALL0_MIRRORED
     46  0267					      endif
     47  0267
     48  0267					      if	BRICK_WALL_DEF = 0
     49  0267		       00 ee ee 00*	      .byte.b	%00000000,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;R
     50  026e		       ee ee ee 00*	      .byte.b	%11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;G
     51  0275		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     52  027c					      endif
     53  027c
     54  027c
     55  027c
     56  027c							;--------------------------------------------------------------------------
     57  027c					      if	MIRRORED_WALL = YES
      0  027c					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  027c					      LIST	ON
     59  027c				   CHARACTERSHAPE_WALL_MIRRORED
     60  027c				   CHARACTERSHAPE_WALL0_MIRRORED
     61  027c
     62  027c					      if	BRICK_WALL_DEF = 0
     63  027c		       00 77 77 00*	      .byte.b	%00000000,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;R
     64  0283		       77 77 77 00*	      .byte.b	%01110111,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;G
     65  028a		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     66  0291					      endif
     67  0291
     68  0291
     69  0291					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    496  0291		       00 00 00 00*	      ds	30	; todo - fixes a graphical glitch so we have a page boundary issue somewhwere
    497  02af
    498  02af
      0  02af					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
 PAGE BREAK INSERTED FOR  SCREEN_BITMAP
 REQUESTED SIZE =  $54
 WASTED SPACE =  $51
 PAGEBREAK LOCATION =  $f300
     10  0300					      LIST	ON
    500  0300
    501  0300		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,$0	; character bitmap row (10 chars wide)
    502  0300		       f3 00	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    503  0300		       f3 07	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    504  0300		       f3 0e	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    505  0354
      0  0354					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  0354					      LIST	ON
    507  0354
    508  0354							;--------------------------------------------------------------------------
    509  0354							;    CHARACTER_SET
    510  0354
    511  0354							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    512  0354
    513  0354
      0  0354					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  0354		       00 00	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  0354					      SUBROUTINE
      3  0354				   SelfModDrawPlayers
    515  0354
    516  0354							; Now the player(s) have animated, update the appropriate shape pointers
    517  0354							; in the draw code.
    518  0354
    519  0354							; Sets the shapes to a blank player -- effectively erasing
    520  0354		       a5 b1		      lda	LastSpriteY
    521  0356		       a2 7e		      ldx	#<PLAYER_BLANK
    522  0358		       20 67 f3 	      jsr	SetSelfModPlayer
    523  035b
    524  035b							; Now we've erased, we write the new shape
    525  035b
    526  035b							;		  sec
    527  035b							;		  lda ManDrawX
    528  035b							;		  sbc BoardScrollX
    529  035b							;		  cmp #SCREEN_WIDTH			  ; disabled because we assume always onscreen
    530  035b							;		  bcs NoMod				  ; skip if off visible screen
    531  035b
    532  035b		       a5 9d		      lda	ManDrawX
    533  035d		       c9 0a		      cmp	#SCREEN_WIDTH	; disabled because we assume always onscreen
    534  035f		       b0 1c		      bcs	NoMod	; skip if off visible screen
    535  0361
    536  0361							;lda LookingAround
    537  0361							;bne NoMod
    538  0361
    539  0361		       a5 9e		      lda	ManDrawY
    540  0363		       85 b1		      sta	LastSpriteY
    541  0365
    542  0365		       a6 a3		      ldx	ManAnimationFrameLO
    543  0367
    544  0367				   SetSelfModPlayer
    545  0367		       c9 08		      cmp	#SCREEN_LINES	; only erase/draw if was/is onscreen
    546  0369		       b0 12		      bcs	NoMod
    547  036b		       69 00		      adc	#BANK_SCREENMARKII1
    548  036d		       85 3e		      sta	SET_BANK_RAM	; switch old/new bank in
    549  036f
    550  036f		       8a		      txa
    551  0370		       8d 20 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1	; lo of frame
    552  0373		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    553  0375		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    554  0378		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    555  037a		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    556  037d
    557  037d				   NoMod
    558  037d		       60		      rts
    559  037e
    560  037e
      0  037e					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  037e
      2  037e
      3  037e		       03 7e	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $37e , FREE= $82
      4  037e					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  037e				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  037e				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  037e				  -	      ERR
      8  037e					      endif
    562  037e
------- FILE player.asm LEVEL 3 PASS 4
      0  037e					      include	"player.asm"	; 6 * LINES_PER_CHAR	       MUST FOLLOW DIRT.ASM as data is shared
      1  037e							;    Sokoboo - a Sokoban implementation
      2  037e							;    using a generic tile-based display engine for the Atari 2600
      3  037e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  037e							;
      5  037e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  037e							;
      7  037e							;    Code related to the generic tile-based display engine was developed by
      8  037e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  037e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  037e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  037e							;
     12  037e							;    Code related to music and sound effects uses the TIATracker music player
     13  037e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  037e							;    directory for Apache licensing details.
     15  037e							;
     16  037e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  037e							;    See the copyright notices in the License directory for a list of level
     18  037e							;    contributors.
     19  037e							;
     20  037e							;    Except where otherwise indicated, this software is released under the
     21  037e							;    following licensing arrangement...
     22  037e							;
     23  037e							;    This program is free software: you can redistribute it and/or modify
     24  037e							;    it under the terms of the GNU General Public License as published by
     25  037e							;    the Free Software Foundation, either version 3 of the License, or
     26  037e							;    (at your option) any later version.
     27  037e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  037e
     29  037e							;    This program is distributed in the hope that it will be useful,
     30  037e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  037e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  037e							;    GNU General Public License for more details.
     33  037e
     34  037e							;    OPTIONAL_PAGEBREAK "PLAYER", LINES_PER_CHAR * 6 - 1
     35  037e
     36  037e
     37  037e		       f3 7e	   PLAYER_BLANK =	.
     38  037e					      REPEAT	LINES_PER_CHAR	;-1  ; as we have a "0" in the line below
     39  037e		       00		      .byte.b	0
     38  037e					      REPEND
     39  037f		       00		      .byte.b	0
     38  037f					      REPEND
     39  0380		       00		      .byte.b	0
     38  0380					      REPEND
     39  0381		       00		      .byte.b	0
     38  0381					      REPEND
     39  0382		       00		      .byte.b	0
     38  0382					      REPEND
     39  0383		       00		      .byte.b	0
     38  0383					      REPEND
     39  0384		       00		      .byte.b	0
     38  0384					      REPEND
     39  0385		       00		      .byte.b	0
     38  0385					      REPEND
     39  0386		       00		      .byte.b	0
     38  0386					      REPEND
     39  0387		       00		      .byte.b	0
     38  0387					      REPEND
     39  0388		       00		      .byte.b	0
     38  0388					      REPEND
     39  0389		       00		      .byte.b	0
     38  0389					      REPEND
     39  038a		       00		      .byte.b	0
     38  038a					      REPEND
     39  038b		       00		      .byte.b	0
     38  038b					      REPEND
     39  038c		       00		      .byte.b	0
     38  038c					      REPEND
     39  038d		       00		      .byte.b	0
     38  038d					      REPEND
     39  038e		       00		      .byte.b	0
     38  038e					      REPEND
     39  038f		       00		      .byte.b	0
     38  038f					      REPEND
     39  0390		       00		      .byte.b	0
     38  0390					      REPEND
     39  0391		       00		      .byte.b	0
     38  0391					      REPEND
     39  0392		       00		      .byte.b	0
     40  0393					      REPEND
     41  0393
     42  0393				   PLAYER_RIGHT0
     43  0393
     44  0393					      if	1
     45  0393		       18		      .byte.b	%00011000	;20
     46  0394		       18		      .byte.b	%00011000	;20
     47  0395		       7e		      .byte.b	%01111110	;20
     48  0396		       7e		      .byte.b	%01111110	;20
     49  0397		       7e		      .byte.b	%01111110	;20
     50  0398		       18		      .byte.b	%00011000	;20
     51  0399		       18		      .byte.b	%00011000	;20
     52  039a
     53  039a		       18		      .byte.b	%00011000	;20
     54  039b		       18		      .byte.b	%00011000	;20
     55  039c		       7e		      .byte.b	%01111110	;20
     56  039d		       7e		      .byte.b	%01111110	;20
     57  039e		       7e		      .byte.b	%01111110	;20
     58  039f		       18		      .byte.b	%00011000	;20
     59  03a0		       18		      .byte.b	%00011000	;20
     60  03a1
     61  03a1		       18		      .byte.b	%00011000	;20
     62  03a2		       18		      .byte.b	%00011000	;20
     63  03a3		       7e		      .byte.b	%01111110	;20
     64  03a4		       7e		      .byte.b	%01111110	;20
     65  03a5		       7e		      .byte.b	%01111110	;20
     66  03a6		       18		      .byte.b	%00011000	;20
     67  03a7		       18		      .byte.b	%00011000	;20
     68  03a8
     69  03a8				  -	      else
     70  03a8				  -			;push
     71  03a8				  -	      .byte	#%01110000	;$1C 0
     72  03a8				  -	      .byte	#%01110000	;$78 3
     73  03a8				  -	      .byte	#%00010000	;$52 6
     74  03a8				  -	      .byte	#%00111100	;$52 9
     75  03a8				  -	      .byte	#%00011001	;$0C 12
     76  03a8				  -	      .byte	#%00001100	;$4A 15
     77  03a8				  -	      .byte	#%00001111	;$1A18
     78  03a8				  -
     79  03a8				  -	      .byte	#%10100000	;$1C 1
     80  03a8				  -	      .byte	#%00111000	;$78 4
     81  03a8				  -	      .byte	#%00111000	;$52 7
     82  03a8				  -	      .byte	#%00111100	;$56 10
     83  03a8				  -	      .byte	#%00001000	;$4A 13
     84  03a8				  -	      .byte	#%00001100	;$4A 16
     85  03a8				  -	      .byte	#%00001100	;$1C 19
     86  03a8				  -
     87  03a8				  -	      .byte	#%11010000	;$78 2
     88  03a8				  -	      .byte	#%00101000	;$78 5
     89  03a8				  -	      .byte	#%00111000	;$52 8
     90  03a8				  -	      .byte	#%00011111	;$56 11
     91  03a8				  -	      .byte	#%00001000	;$4A 14
     92  03a8				  -	      .byte	#%00011010	;$4A 17
     93  03a8				  -	      .byte	#%00001100	;$1C 20
     94  03a8				  -
     95  03a8					      endif
     96  03a8
     97  03a8				  -	      IF	0
     98  03a8				  -			;---Graphics Data from PlayerPal 2600---
     99  03a8				  -
    100  03a8				  -Frame0
    101  03a8				  -	      .byte	#%01110011	;$1C
    102  03a8				  -	      .byte	#%00100110	;$1C
    103  03a8				  -	      .byte	#%00110100	;$78
    104  03a8				  -	      .byte	#%00010100	;$78
    105  03a8				  -	      .byte	#%00011100	;$78
    106  03a8				  -	      .byte	#%00001000	;$78
    107  03a8				  -	      .byte	#%00010000	;$52
    108  03a8				  -	      .byte	#%00111000	;$52
    109  03a8				  -	      .byte	#%00111000	;$52
    110  03a8				  -	      .byte	#%10111000	;$52
    111  03a8				  -	      .byte	#%01111000	;$56
    112  03a8				  -	      .byte	#%00110000	;$56
    113  03a8				  -	      .byte	#%00111100	;$0C
    114  03a8				  -	      .byte	#%00110010	;$4A
    115  03a8				  -	      .byte	#%00010000	;$4A
    116  03a8				  -	      .byte	#%00011000	;$4A
    117  03a8				  -	      .byte	#%00011000	;$4A
    118  03a8				  -	      .byte	#%00110100	;$4A
    119  03a8				  -	      .byte	#%00011110	;$1A
    120  03a8				  -	      .byte	#%00011000	;$1C
    121  03a8				  -	      .byte	#%00011000	;$1C
    122  03a8				  -Frame1
    123  03a8				  -	      .byte	#%00110110	;$1C
    124  03a8				  -	      .byte	#%00100100	;$1C
    125  03a8				  -	      .byte	#%00010100	;$78
    126  03a8				  -	      .byte	#%00010100	;$78
    127  03a8				  -	      .byte	#%00011100	;$78
    128  03a8				  -	      .byte	#%00001000	;$78
    129  03a8				  -	      .byte	#%00010000	;$52
    130  03a8				  -	      .byte	#%00111000	;$52
    131  03a8				  -	      .byte	#%00011000	;$52
    132  03a8				  -	      .byte	#%01111000	;$52
    133  03a8				  -	      .byte	#%00111000	;$56
    134  03a8				  -	      .byte	#%00110110	;$56
    135  03a8				  -	      .byte	#%00111100	;$0C
    136  03a8				  -	      .byte	#%00010000	;$4A
    137  03a8				  -	      .byte	#%00010000	;$4A
    138  03a8				  -	      .byte	#%00011000	;$4A
    139  03a8				  -	      .byte	#%00011000	;$4A
    140  03a8				  -	      .byte	#%00110100	;$4A
    141  03a8				  -	      .byte	#%00011110	;$1A
    142  03a8				  -	      .byte	#%00011000	;$1C
    143  03a8				  -	      .byte	#%00011000	;$1C
    144  03a8				  -Frame2
    145  03a8				  -	      .byte	#%00011000	;$1C
    146  03a8				  -	      .byte	#%00110000	;$1C
    147  03a8				  -	      .byte	#%01010000	;$78
    148  03a8				  -	      .byte	#%00111000	;$78
    149  03a8				  -	      .byte	#%00011000	;$78
    150  03a8				  -	      .byte	#%00001000	;$78
    151  03a8				  -	      .byte	#%00010000	;$52
    152  03a8				  -	      .byte	#%00111000	;$52
    153  03a8				  -	      .byte	#%00111000	;$52
    154  03a8				  -	      .byte	#%00111100	;$52
    155  03a8				  -	      .byte	#%00110100	;$56
    156  03a8				  -	      .byte	#%00111100	;$56
    157  03a8				  -	      .byte	#%00111000	;$0C
    158  03a8				  -	      .byte	#%00010000	;$4A
    159  03a8				  -	      .byte	#%00010000	;$4A
    160  03a8				  -	      .byte	#%00011000	;$4A
    161  03a8				  -	      .byte	#%00011000	;$4A
    162  03a8				  -	      .byte	#%00110100	;$4A
    163  03a8				  -	      .byte	#%00011110	;$1A
    164  03a8				  -	      .byte	#%00011000	;$1C
    165  03a8				  -	      .byte	#%00011000	;$1C
    166  03a8				  -Frame3
    167  03a8				  -	      .byte	#%01110000	;$1C
    168  03a8				  -	      .byte	#%10100000	;$1C
    169  03a8				  -	      .byte	#%11010000	;$78
    170  03a8				  -	      .byte	#%01110000	;$78
    171  03a8				  -	      .byte	#%00111000	;$78
    172  03a8				  -	      .byte	#%00101000	;$78
    173  03a8				  -	      .byte	#%00010000	;$52
    174  03a8				  -	      .byte	#%00111000	;$52
    175  03a8				  -	      .byte	#%00111000	;$52
    176  03a8				  -	      .byte	#%00111100	;$52
    177  03a8				  -	      .byte	#%00111100	;$56
    178  03a8				  -	      .byte	#%00011111	;$56
    179  03a8				  -	      .byte	#%00011001	;$0C
    180  03a8				  -	      .byte	#%00001000	;$4A
    181  03a8				  -	      .byte	#%00001000	;$4A
    182  03a8				  -	      .byte	#%00001100	;$4A
    183  03a8				  -	      .byte	#%00001100	;$4A
    184  03a8				  -	      .byte	#%00011010	;$4A
    185  03a8				  -	      .byte	#%00001111	;$1A
    186  03a8				  -	      .byte	#%00001100	;$1C
    187  03a8				  -	      .byte	#%00001100	;$1C
    188  03a8				  -Frame4
    189  03a8				  -	      .byte	#%00110110	;$1C
    190  03a8				  -	      .byte	#%00010100	;$1C
    191  03a8				  -	      .byte	#%00010100	;$78
    192  03a8				  -	      .byte	#%00010100	;$78
    193  03a8				  -	      .byte	#%00011100	;$78
    194  03a8				  -	      .byte	#%00001100	;$78
    195  03a8				  -	      .byte	#%00010000	;$52
    196  03a8				  -	      .byte	#%00011000	;$52
    197  03a8				  -	      .byte	#%00011100	;$52
    198  03a8				  -	      .byte	#%00111100	;$52
    199  03a8				  -	      .byte	#%00111100	;$56
    200  03a8				  -	      .byte	#%00111100	;$56
    201  03a8				  -	      .byte	#%00111110	;$0C
    202  03a8				  -	      .byte	#%01011010	;$4A
    203  03a8				  -	      .byte	#%10010001	;$4A
    204  03a8				  -	      .byte	#%10011001	;$4A
    205  03a8				  -	      .byte	#%00011000	;$4A
    206  03a8				  -	      .byte	#%00011000	;$4A
    207  03a8				  -	      .byte	#%00011100	;$1A
    208  03a8				  -	      .byte	#%00011000	;$1C
    209  03a8				  -	      .byte	#%00010000	;$1C
    210  03a8				  -Frame5
    211  03a8				  -	      .byte	#%00110110	;$1C
    212  03a8				  -	      .byte	#%00010100	;$1C
    213  03a8				  -	      .byte	#%00010100	;$78
    214  03a8				  -	      .byte	#%00010100	;$78
    215  03a8				  -	      .byte	#%00011100	;$78
    216  03a8				  -	      .byte	#%01001101	;$78
    217  03a8				  -	      .byte	#%01010001	;$52
    218  03a8				  -	      .byte	#%01011011	;$52
    219  03a8				  -	      .byte	#%01011110	;$52
    220  03a8				  -	      .byte	#%00111100	;$52
    221  03a8				  -	      .byte	#%00111100	;$56
    222  03a8				  -	      .byte	#%00011100	;$56
    223  03a8				  -	      .byte	#%00011000	;$0C
    224  03a8				  -	      .byte	#%00011000	;$4A
    225  03a8				  -	      .byte	#%00011000	;$4A
    226  03a8				  -	      .byte	#%00111000	;$4A
    227  03a8				  -	      .byte	#%00001000	;$4A
    228  03a8				  -	      .byte	#%00000000	;$4A
    229  03a8				  -	      .byte	#%00000000	;$1A
    230  03a8				  -	      .byte	#%00000000	;$1C
    231  03a8				  -	      .byte	#%00000000	;$1C
    232  03a8				  -			;---End Graphics Data---
    233  03a8				  -
    234  03a8				  -
    235  03a8				  -			;---Color Data from PlayerPal 2600---
    236  03a8				  -
    237  03a8				  -ColorFrame0
    238  03a8				  -	      .byte	#$1C	;
    239  03a8				  -	      .byte	#$1C	;
    240  03a8				  -	      .byte	#$78	;
    241  03a8				  -	      .byte	#$78	;
    242  03a8				  -	      .byte	#$78	;
    243  03a8				  -	      .byte	#$78	;
    244  03a8				  -	      .byte	#$52	;
    245  03a8				  -	      .byte	#$52	;
    246  03a8				  -	      .byte	#$52	;
    247  03a8				  -	      .byte	#$52	;
    248  03a8				  -	      .byte	#$56	;
    249  03a8				  -	      .byte	#$56	;
    250  03a8				  -	      .byte	#$0C	;
    251  03a8				  -	      .byte	#$4A	;
    252  03a8				  -	      .byte	#$4A	;
    253  03a8				  -	      .byte	#$4A	;
    254  03a8				  -	      .byte	#$4A	;
    255  03a8				  -	      .byte	#$4A	;
    256  03a8				  -	      .byte	#$1A	;
    257  03a8				  -	      .byte	#$1C	;
    258  03a8				  -	      .byte	#$1C	;
    259  03a8				  -ColorFrame1
    260  03a8				  -	      .byte	#$1C	;
    261  03a8				  -	      .byte	#$1C	;
    262  03a8				  -	      .byte	#$78	;
    263  03a8				  -	      .byte	#$78	;
    264  03a8				  -	      .byte	#$78	;
    265  03a8				  -	      .byte	#$78	;
    266  03a8				  -	      .byte	#$52	;
    267  03a8				  -	      .byte	#$52	;
    268  03a8				  -	      .byte	#$52	;
    269  03a8				  -	      .byte	#$52	;
    270  03a8				  -	      .byte	#$56	;
    271  03a8				  -	      .byte	#$56	;
    272  03a8				  -	      .byte	#$0C	;
    273  03a8				  -	      .byte	#$4A	;
    274  03a8				  -	      .byte	#$4A	;
    275  03a8				  -	      .byte	#$4A	;
    276  03a8				  -	      .byte	#$4A	;
    277  03a8				  -	      .byte	#$4A	;
    278  03a8				  -	      .byte	#$1A	;
    279  03a8				  -	      .byte	#$1C	;
    280  03a8				  -	      .byte	#$1C	;
    281  03a8				  -ColorFrame2
    282  03a8				  -	      .byte	#$1C	;
    283  03a8				  -	      .byte	#$1C	;
    284  03a8				  -	      .byte	#$78	;
    285  03a8				  -	      .byte	#$78	;
    286  03a8				  -	      .byte	#$78	;
    287  03a8				  -	      .byte	#$78	;
    288  03a8				  -	      .byte	#$52	;
    289  03a8				  -	      .byte	#$52	;
    290  03a8				  -	      .byte	#$52	;
    291  03a8				  -	      .byte	#$52	;
    292  03a8				  -	      .byte	#$56	;
    293  03a8				  -	      .byte	#$56	;
    294  03a8				  -	      .byte	#$0C	;
    295  03a8				  -	      .byte	#$4A	;
    296  03a8				  -	      .byte	#$4A	;
    297  03a8				  -	      .byte	#$4A	;
    298  03a8				  -	      .byte	#$4A	;
    299  03a8				  -	      .byte	#$4A	;
    300  03a8				  -	      .byte	#$1A	;
    301  03a8				  -	      .byte	#$1C	;
    302  03a8				  -	      .byte	#$1C	;
    303  03a8				  -ColorFrame3
    304  03a8				  -	      .byte	#$1C	;
    305  03a8				  -	      .byte	#$1C	;
    306  03a8				  -	      .byte	#$78	;
    307  03a8				  -	      .byte	#$78	;
    308  03a8				  -	      .byte	#$78	;
    309  03a8				  -	      .byte	#$78	;
    310  03a8				  -	      .byte	#$52	;
    311  03a8				  -	      .byte	#$52	;
    312  03a8				  -	      .byte	#$52	;
    313  03a8				  -	      .byte	#$52	;
    314  03a8				  -	      .byte	#$56	;
    315  03a8				  -	      .byte	#$56	;
    316  03a8				  -	      .byte	#$0C	;
    317  03a8				  -	      .byte	#$4A	;
    318  03a8				  -	      .byte	#$4A	;
    319  03a8				  -	      .byte	#$4A	;
    320  03a8				  -	      .byte	#$4A	;
    321  03a8				  -	      .byte	#$4A	;
    322  03a8				  -	      .byte	#$1A	;
    323  03a8				  -	      .byte	#$1C	;
    324  03a8				  -	      .byte	#$1C	;
    325  03a8				  -ColorFrame4
    326  03a8				  -	      .byte	#$1C	;
    327  03a8				  -	      .byte	#$1C	;
    328  03a8				  -	      .byte	#$78	;
    329  03a8				  -	      .byte	#$78	;
    330  03a8				  -	      .byte	#$78	;
    331  03a8				  -	      .byte	#$78	;
    332  03a8				  -	      .byte	#$52	;
    333  03a8				  -	      .byte	#$52	;
    334  03a8				  -	      .byte	#$52	;
    335  03a8				  -	      .byte	#$52	;
    336  03a8				  -	      .byte	#$56	;
    337  03a8				  -	      .byte	#$56	;
    338  03a8				  -	      .byte	#$0C	;
    339  03a8				  -	      .byte	#$4A	;
    340  03a8				  -	      .byte	#$4A	;
    341  03a8				  -	      .byte	#$4A	;
    342  03a8				  -	      .byte	#$4A	;
    343  03a8				  -	      .byte	#$4A	;
    344  03a8				  -	      .byte	#$1A	;
    345  03a8				  -	      .byte	#$1C	;
    346  03a8				  -	      .byte	#$1C	;
    347  03a8				  -ColorFrame5
    348  03a8				  -	      .byte	#$1C	;
    349  03a8				  -	      .byte	#$1C	;
    350  03a8				  -	      .byte	#$78	;
    351  03a8				  -	      .byte	#$78	;
    352  03a8				  -	      .byte	#$78	;
    353  03a8				  -	      .byte	#$78	;
    354  03a8				  -	      .byte	#$52	;
    355  03a8				  -	      .byte	#$52	;
    356  03a8				  -	      .byte	#$52	;
    357  03a8				  -	      .byte	#$52	;
    358  03a8				  -	      .byte	#$56	;
    359  03a8				  -	      .byte	#$56	;
    360  03a8				  -	      .byte	#$0C	;
    361  03a8				  -	      .byte	#$4A	;
    362  03a8				  -	      .byte	#$4A	;
    363  03a8				  -	      .byte	#$4A	;
    364  03a8				  -	      .byte	#$4A	;
    365  03a8				  -	      .byte	#$4A	;
    366  03a8				  -	      .byte	#$1A	;
    367  03a8				  -	      .byte	#$1C	;
    368  03a8				  -	      .byte	#$1C	;
    369  03a8				  -			;---End Color Data---
    370  03a8					      ENDIF
    371  03a8
    372  03a8
    373  03a8							;.byte %00011000  ;  XXX   ; 0
    374  03a8							;.byte %00111100  ;XXXXXX  ; 1
    375  03a8							;.byte %01110100  ;XXXX X  ; 2 etc.
    376  03a8							;.byte %01111100  ;XXXXXX  ; 3
    377  03a8							;.byte %00111000  ;XXXXX   ;4
    378  03a8							;.byte %01111100  ; XXXXX  ;5
    379  03a8							;.byte %00111000  ;  XXX   ;6
    380  03a8							;.byte %11111000  ;XXXXX   ;7
    381  03a8							;.byte %11111100  ;XXXXXX  ;8
    382  03a8							;.byte %11111100  ;XXXXXX  ;9 etc.
    383  03a8							;.byte %10000100  ;X	 X  ;10
    384  03a8							;.byte %11111100  ;XXXXXX  ;11
    385  03a8							;.byte %00001100  ;	XX  ;12
    386  03a8							;.byte %01111100  ; XXXXX  ;13
    387  03a8							;.byte %01111100  ; XXXXX  ;14
    388  03a8							;.byte %01111000  ; XXXX   ;15
    389  03a8							;.byte %01111000  ; XXXX   ;16 etc.
    390  03a8							;.byte %11111000  ;XXXXX   ;17
    391  03a8							;.byte %11101100  ;XXX XX  ;18
    392  03a8							;.byte %10111100  ;X XXXX  ;19
    393  03a8							;.byte %11001100  ;XX	XX   20
    394  03a8
    395  03a8							;---Graphics Data from PlayerPal 2600---
    396  03a8
    397  03a8				   PLAYER_RIGHT1
    398  03a8				   PLAYER_STAND
    399  03a8				   PLAYER_BLINK
    400  03a8				   PLAYER_TAP0
    401  03a8				   PLAYER_TAP1
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE characterset/filler.asm LEVEL 3 PASS 4
      0  03a8					      include	"characterset/filler.asm"	; 2 * LINES_PER_CHAR bytes
      1  03a8							;    Sokoboo - a Sokoban implementation
      2  03a8							;    using a generic tile-based display engine for the Atari 2600
      3  03a8							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  03a8							;
      5  03a8							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  03a8							;
      7  03a8							;    Code related to the generic tile-based display engine was developed by
      8  03a8							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  03a8							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  03a8							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  03a8							;
     12  03a8							;    Code related to music and sound effects uses the TIATracker music player
     13  03a8							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  03a8							;    directory for Apache licensing details.
     15  03a8							;
     16  03a8							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  03a8							;    See the copyright notices in the License directory for a list of level
     18  03a8							;    contributors.
     19  03a8							;
     20  03a8							;    Except where otherwise indicated, this software is released under the
     21  03a8							;    following licensing arrangement...
     22  03a8							;
     23  03a8							;    This program is free software: you can redistribute it and/or modify
     24  03a8							;    it under the terms of the GNU General Public License as published by
     25  03a8							;    the Free Software Foundation, either version 3 of the License, or
     26  03a8							;    (at your option) any later version.
     27  03a8							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  03a8
     29  03a8							;    This program is distributed in the hope that it will be useful,
     30  03a8							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  03a8							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  03a8							;    GNU General Public License for more details.
     33  03a8
      0  03a8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  03a8					      LIST	ON
     35  03a8				   CHARACTERSHAPE_SOIL
     36  03a8				   CHARACTERSHAPE_SOIL_MIRRORED
     37  03a8		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
     38  03af		       ff		      .byte.b	%11111111
     39  03b0		       ff		      .byte.b	%11111111
     40  03b1		       ff		      .byte.b	%11111111
     41  03b2		       ff		      .byte.b	%11111111
     42  03b3		       ff		      .byte.b	%11111111
     43  03b4		       ff		      .byte.b	%11111111
     44  03b5		       ff		      .byte.b	%11111111
     45  03b6		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    565  03bd							;------------------------------------------------------------------------------
    566  03bd
    567  03bd							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    568  03bd
    569  03bd							;------------------------------------------------------------------------------
    570  03bd
    571  03bd
    572  03bd
    573  03bd							;	 CHECK_HALF_BANK_SIZE "ROM_SHADOW_OF_RAMBANK_CODE"
    574  03bd
    575  03bd				   OBJTYPE    SET	0
    576  03bd					      MAC	define_character
    577  03bd				   CHARACTER_{1} =	OBJTYPE
    578  03bd				   OBJTYPE    .SET	OBJTYPE + 1
    579  03bd					      ENDM
    580  03bd
    581  03bd							; Modifications to character #/order must also ensure the following are correct...
    582  03bd							;   CharacterDataVecLO/HI	   in BANK_FIXED.asm
    583  03bd							;   MoveVecLO/HI		   in BANK_INITBANK
    584  03bd							;   CharReplacement		   in BANK_ROM_SHADOW_DRAWBUFFERS
    585  03bd
      0  03bd					      DEFINE_CHARACTER	BLANK
      1  03bd		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  03bd				   OBJTYPE    .SET	OBJTYPE + 1
      0  03bd					      DEFINE_CHARACTER	SOIL
      1  03bd		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  03bd				   OBJTYPE    .SET	OBJTYPE + 1
      0  03bd					      DEFINE_CHARACTER	BOX
      1  03bd		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  03bd				   OBJTYPE    .SET	OBJTYPE + 1
      0  03bd					      DEFINE_CHARACTER	TARGET
      1  03bd		       00 03	   CHARACTER_TARGET =	OBJTYPE
      2  03bd				   OBJTYPE    .SET	OBJTYPE + 1
      0  03bd					      DEFINE_CHARACTER	TARGET2
      1  03bd		       00 04	   CHARACTER_TARGET2 =	OBJTYPE
      2  03bd				   OBJTYPE    .SET	OBJTYPE + 1
      0  03bd					      DEFINE_CHARACTER	MANOCCUPIED
      1  03bd		       00 05	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  03bd				   OBJTYPE    .SET	OBJTYPE + 1
      0  03bd					      DEFINE_CHARACTER	STEEL
      1  03bd		       00 06	   CHARACTER_STEEL =	OBJTYPE
      2  03bd				   OBJTYPE    .SET	OBJTYPE + 1
      0  03bd					      DEFINE_CHARACTER	WALL
      1  03bd		       00 07	   CHARACTER_WALL =	OBJTYPE
      2  03bd				   OBJTYPE    .SET	OBJTYPE + 1
      0  03bd					      DEFINE_CHARACTER	BOX_ON_TARGET
      1  03bd		       00 08	   CHARACTER_BOX_ON_TARGET =	OBJTYPE
      2  03bd				   OBJTYPE    .SET	OBJTYPE + 1
      0  03bd					      DEFINE_CHARACTER	NOGO
      1  03bd		       00 09	   CHARACTER_NOGO =	OBJTYPE
      2  03bd				   OBJTYPE    .SET	OBJTYPE + 1
    596  03bd
      0  03bd					      DEFINE_CHARACTER	MAXIMUM
      1  03bd		       00 0a	   CHARACTER_MAXIMUM =	OBJTYPE
      2  03bd				   OBJTYPE    .SET	OBJTYPE + 1
    598  03bd
    599  03bd
    600  03bd
    601  03bd				   CharacterDataVecLO
    602  03bd
    603  03bd							; Two entries per character.  2nd is ptr to mirrored character
    604  03bd							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
    605  03bd
    606  03bd		       7e		      .byte.b	<CHARACTERSHAPE_BLANK
    607  03be		       7e		      .byte.b	<CHARACTERSHAPE_BLANK
    608  03bf		       a8		      .byte.b	<CHARACTERSHAPE_SOIL
    609  03c0		       a8		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
    610  03c1		       89		      .byte.b	<CHARACTERSHAPE_BOX
    611  03c2		       9e		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
    612  03c3		       3e		      .byte.b	<CHARACTERSHAPE_TARGET
    613  03c4		       3e		      .byte.b	<CHARACTERSHAPE_TARGET_MIRRORED
    614  03c5		       52		      .byte.b	<CHARACTERSHAPE_TARGET2
    615  03c6		       52		      .byte.b	<CHARACTERSHAPE_TARGET2_MIRRORED
    616  03c7		       7e		      .byte.b	<CHARACTERSHAPE_BLANK	; man occupied
    617  03c8		       7e		      .byte.b	<CHARACTERSHAPE_BLANK
    618  03c9		       dd		      .byte.b	<CHARACTERSHAPE_STEEL
    619  03ca		       00		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
    620  03cb		       67		      .byte.b	<CHARACTERSHAPE_WALL
    621  03cc		       7c		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
    622  03cd		       b3		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET
    623  03ce		       c8		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    624  03cf		       7e		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    625  03d0		       7e		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    626  03d1
    627  03d1				  -	      IF	* - CharacterDataVecLO != CHARACTER_MAXIMUM*2
    628  03d1				  -	      ECHO	"ERROR: Incorrect CharacterDataVecLO table!"
    629  03d1				  -	      ERR
    630  03d1					      ENDIF
    631  03d1
    632  03d1							;---------------------------------------------------------------------------
    633  03d1
    634  03d1				   CharacterDataVecHI
    635  03d1
    636  03d1		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    637  03d2		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    638  03d3		       f3		      .byte.b	>CHARACTERSHAPE_SOIL
    639  03d4		       f3		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
    640  03d5		       fc		      .byte.b	>CHARACTERSHAPE_BOX
    641  03d6		       fc		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
    642  03d7		       f2		      .byte.b	>CHARACTERSHAPE_TARGET
    643  03d8		       f2		      .byte.b	>CHARACTERSHAPE_TARGET_MIRRORED
    644  03d9		       f2		      .byte.b	>CHARACTERSHAPE_TARGET2
    645  03da		       f2		      .byte.b	>CHARACTERSHAPE_TARGET2_MIRRORED
    646  03db		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; man occupied
    647  03dc		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    648  03dd		       fc		      .byte.b	>CHARACTERSHAPE_STEEL
    649  03de		       fd		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
    650  03df		       f2		      .byte.b	>CHARACTERSHAPE_WALL
    651  03e0		       f2		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
    652  03e1		       fc		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET
    653  03e2		       fc		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    654  03e3		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    655  03e4		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
    656  03e5
    657  03e5				  -	      IF	* - CharacterDataVecHI != CHARACTER_MAXIMUM*2
    658  03e5				  -	      ECHO	"ERROR: Incorrect CharacterDataVecHI table!"
    659  03e5				  -	      ERR
    660  03e5					      ENDIF
    661  03e5
    662  03e5							; Here there's another 1K of usable ROM....
    663  03e5							; BUT!!! WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    664  03e5
    665  03e5
    666  03e5							;-----------------------------------------------------------
    667  03e5							; Stella 3E autodetect signature, can live anywhere
    668  03e5		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
    669  03e9							;-----------------------------------------------------------
    670  03e9
      0  03e9					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  03e9		       03 e9	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $3e9 , FREE= $417
      2  03e9					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  03e9				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  03e9				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  03e9				  -	      ERR
      6  03e9					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 4
      0  03e9					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  03e9							;    Sokoboo - a Sokoban implementation
      2  03e9							;    using a generic tile-based display engine for the Atari 2600
      3  03e9							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  03e9							;
      5  03e9							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  03e9							;
      7  03e9							;    Code related to the generic tile-based display engine was developed by
      8  03e9							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  03e9							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  03e9							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  03e9							;
     12  03e9							;    Code related to music and sound effects uses the TIATracker music player
     13  03e9							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  03e9							;    directory for Apache licensing details.
     15  03e9							;
     16  03e9							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  03e9							;    See the copyright notices in the License directory for a list of level
     18  03e9							;    contributors.
     19  03e9							;
     20  03e9							;    Except where otherwise indicated, this software is released under the
     21  03e9							;    following licensing arrangement...
     22  03e9							;
     23  03e9							;    This program is free software: you can redistribute it and/or modify
     24  03e9							;    it under the terms of the GNU General Public License as published by
     25  03e9							;    the Free Software Foundation, either version 3 of the License, or
     26  03e9							;    (at your option) any later version.
     27  03e9							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  03e9
     29  03e9							;    This program is distributed in the hope that it will be useful,
     30  03e9							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  03e9							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  03e9							;    GNU General Public License for more details.
     33  03e9
     34  03e9							;------------------------------------------------------------------------------
     35  03e9							;##############################################################################
     36  03e9							;------------------------------------------------------------------------------
     37  03e9
      0  03e9					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  0a50 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
     39  0800
     40  0800							; NOTE: Access to these buffers must NOT overlap pages...
     41  0800							; NOTE: We get auto-initialisation of these variables from the ROM values by
     42  0800							; copying the whole bank into the RAM bank.  Neato.
     43  0800
     44  0800		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     45  0800
     46  0800
     47  0800
     48  0800		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     49  0850		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     50  08a0
      0  08a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  08a0					      LIST	ON
     52  08a0
     53  08a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     54  08a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     55  08a0							; what we want to happen!
     56  08a0
     57  08a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
     58  08f0
     59  08f0
     60  08f0							;------------------------------------------------------------------------------
     61  08f0							; RAM-BASED SUBROUTINES...
     62  08f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     63  08f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     64  08f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     65  08f0							; the RAM-based routine.
     66  08f0
     67  08f0
     68  08f0
     69  08f0							;------------------------------------------------------------------------------
     70  08f0
     71  08f0
     72  08f0		       60	   waitForDraw rts		; 6
     73  08f1
     74  08f1							;------------------------------------------------------------------------------
     75  08f1
      0  08f1					      DEFINE_SUBROUTINE	DrawStackUpdate	;=196 (+13 for fall-through bit)
      1  08f1		       00 01	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  08f1					      SUBROUTINE
      3  08f1				   DrawStackUpdate
     77  08f1
     78  08f1							; Parse the DrawFlags buffer and create a draw stack
     79  08f1							; so that the actual draw doesn't need to scan for characters to draw.
     80  08f1
     81  08f1
     82  08f1							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     83  08f1							; symptoms would be missing parts of screen when scrolling.
     84  08f1							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     85  08f1							; disabled for sokoban 27/7/2019
     86  08f1
     87  08f1							;lda DrawStackPointer
     88  08f1							;bpl waitForDraw		  ; Wait for previously not-drawn characters to be drawn
     89  08f1
     90  08f1		       ad 84 02 	      lda	INTIM	;4
     91  08f4		       c9 04		      cmp	#SEGTIME_BDS	;2
     92  08f6		       90 f8		      bcc	waitForDraw	;2/3
      0  08f8					      STRESS_TIME	SEGTIME_BDS
      1  08f8				  -	      IF	TEST_SEGTIME_BDS = 1
      2  08f8				  -
      3  08f8				  -
      4  08f8				  -
      5  08f8				  -
      6  08f8				  -
      7  08f8				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  08f8				  -	      bne	. - 7
      9  08f8					      ENDIF
     94  08f8
     95  08f8
     96  08f8							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
     97  08f8							; moving into the middle of dirt, or BOXs when pushing, or TARGETs when grabbing.
     98  08f8
     99  08f8							;		  sec		 already set
    100  08f8		       a5 9c		      lda	ManY	;3
    101  08fa		       e5 96		      sbc	BoardScrollY	;3
    102  08fc		       85 9e		      sta	ManDrawY	;3
    103  08fe
    104  08fe		       38		      sec		;2
    105  08ff		       a5 9b		      lda	ManX	;3
    106  0901		       e5 97		      sbc	BoardScrollX	;3
    107  0903		       c9 0a		      cmp	#SCREEN_WIDTH	;2
    108  0905		       90 06		      bcc	onsc	;2/3
    109  0907
    110  0907							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
    111  0907							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
    112  0907							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
    113  0907
    114  0907		       a9 08		      lda	#SCREEN_LINES	;2
    115  0909		       85 9e		      sta	ManDrawY	;3
    116  090b		       d0 02		      bne	skipsc	;3		  unconditional
    117  090d
    118  090d		       85 9d	   onsc       sta	ManDrawX	;3
    119  090f				   skipsc
    120  090f
    121  090f		       e6 b2		      inc	timer	;5
    122  0911		       20 d7 f1 	      jsr	AnimateCharReplacements2	;3+28
    123  0914
    124  0914		       e6 89		      inc	ScreenDrawPhase	;5
    125  0916
    126  0916		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
    127  0918		       85 ce		      sta	DSL	;3
    128  091a
    129  091a							; fall through...
    130  091a							;---------------------------------------------------------------------------
    131  091a
      0  091a					      DEFINE_SUBROUTINE	DrawIntoStack
      1  091a		       00 01	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  091a					      SUBROUTINE
      3  091a				   DrawIntoStack
    133  091a
    134  091a		       ba		      tsx		;2
    135  091b		       86 da		      stx	save_SP	;3
    136  091d		       a6 84		      ldx	DrawStackPointer	;3
    137  091f		       9a		      txs		;2 = 10
    138  0920
    139  0920		       a4 ce		      ldy	DSL	;3
    140  0922
    141  0922							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    142  0922							; + exit cost which is +10 cycles
    143  0922							; TJ: I count 63
    144  0922							;   + 14 for the wtf2 exit
    145  0922							;   + 22 for the end of loop exit
    146  0922
    147  0922							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    148  0922							; For 80 iterations that is 640 cycles, just for checking INTIM
    149  0922							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    150  0922							; it also will require a lot of CPU time for updating the screen data.
    151  0922
    152  0922							; TODO: optimize!
    153  0922							;
    154  0922							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    155  0922							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    156  0922							; costs some detection time here, but saves ~240 cylces for drawing the two
    157  0922
    158  0922		       ad 84 02    .loopDrawStack lda	INTIM	;4
    159  0925		       c9 05		      cmp	#SEGTIME_DSL	;2
    160  0927		       90 4b		      bcc	.exitDrawStack	;2/3= 8/9
      0  0929					      STRESS_TIME	SEGTIME_DSL
      1  0929				  -	      IF	TEST_SEGTIME_DSL = 1
      2  0929				  -
      3  0929				  -
      4  0929				  -
      5  0929				  -
      6  0929				  -
      7  0929				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  0929				  -	      bne	. - 7
      9  0929					      ENDIF
    162  0929
    163  0929		       b9 50 f0 	      lda	DrawFlag,y	;4
    164  092c		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    165  092f		       f0 16		      beq	.next0	;2/3=10/11	 yes, so we don't draw anything
    166  0931
    167  0931							; Character is NOT the same. Figure out how it should be drawn.
    168  0931							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    169  0931							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    170  0931							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    171  0931
    172  0931		       be 7d f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    173  0934		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    174  0937		       d0 05		      bne	.notPaired0	;2/3=10/11
    175  0939
    176  0939							; Consider two 'paired' characters. Either A:A or A:B
    177  0939							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    178  0939							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    179  0939							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    180  0939							; on the comparison, so the character will not be added to the draw stack. So our first character will
    181  0939							; do the job of drawing BOTH characters to the screen.
    182  0939
    183  0939		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    184  093c		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    185  093e
    186  093e							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    187  093e							; the last write(below) marks the character as to be direct-drawn.
    188  093e
    189  093e		       99 a0 f4    .notPaired0 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    190  0941
    191  0941							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    192  0941
    193  0941		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    194  0942		       98		      tya		;2
    195  0943		       ba		      tsx		;2		 << now X holds drawstackpointer
    196  0944		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    197  0947
    198  0947		       88	   .next0     dey		;2
    199  0948		       30 21		      bmi	.finishedDrawStack	;2/3= 4/5
    200  094a
    201  094a							; unrolled 2nd loop:
    202  094a		       b9 50 f0 	      lda	DrawFlag,y	;4
    203  094d		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    204  0950		       f0 16		      beq	.next1	;2/3=10/11	 yes, so we don't draw anything
    205  0952
    206  0952		       be 7d f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    207  0955		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    208  0958		       d0 05		      bne	.notPaired1	;2/3=10/11
    209  095a
    210  095a		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    211  095d		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    212  095f
    213  095f		       99 a0 f4    .notPaired1 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    214  0962
    215  0962		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    216  0963		       98		      tya		;2
    217  0964		       ba		      tsx		;2
    218  0965		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    219  0968
    220  0968		       88	   .next1     dey		;2
    221  0969		       10 b7		      bpl	.loopDrawStack	;2/3= 4/5
    222  096b							;worst case: 111-4
    223  096b							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    224  096b
    225  096b							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    226  096b
    227  096b				   .finishedDrawStack
    228  096b		       e6 89		      inc	ScreenDrawPhase	;5 =  5
    229  096d		       ba		      tsx		;2
    230  096e		       86 84		      stx	DrawStackPointer	;3
    231  0970		       a6 da		      ldx	save_SP	;3
    232  0972		       9a		      txs		;2 = 10
    233  0973
    234  0973							;jmp SwitchObjects
    235  0973
    236  0973		       60		      rts		;6 =  6
    237  0974
    238  0974				   .exitDrawStack
    239  0974		       84 ce		      sty	DSL	;3 =  3
    240  0976		       ba		      tsx		;2
    241  0977		       86 84		      stx	DrawStackPointer	;3
    242  0979		       a6 da		      ldx	save_SP	;3
    243  097b		       9a		      txs		;2 = 10
    244  097c		       60		      rts		;6 =  6
    245  097d
    246  097d				   PairedCharacter
    247  097d
    248  097d				   SOFF       SET	0
    249  097d					      REPEAT	SCREEN_LINES
    250  097d		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  097d				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  097d					      REPEND
    250  0987		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  0987				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  0987					      REPEND
    250  0991		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  0991				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  0991					      REPEND
    250  099b		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  099b				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  099b					      REPEND
    250  09a5		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  09a5				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  09a5					      REPEND
    250  09af		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  09af				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  09af					      REPEND
    250  09b9		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  09b9				   SOFF       SET	SOFF + SCREEN_WIDTH
    249  09b9					      REPEND
    250  09c3		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    251  09c3				   SOFF       SET	SOFF + SCREEN_WIDTH
    252  09cd					      REPEND
    253  09cd
    254  09cd							;------------------------------------------------------------------------------
    255  09cd							; Gives character replacements used during screen drawing.
    256  09cd							; The character from the board is morphed via this array into an actual character
    257  09cd							; to draw.  This allows global animation and replacment of characters without
    258  09cd							; individual objects needing to do this.  Note, the draw-time replacement happens,
    259  09cd							; not board-time.
    260  09cd
    261  09cd				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    262  09cd
    263  09cd							; Converts a character # to an animated creature type
    264  09cd							; The array is indexed by CHARACTER_...
    265  09cd
    266  09cd		       00		      .byte.b	CHARACTER_BLANK	;  0
    267  09ce		       01		      .byte.b	CHARACTER_SOIL	;  1
    268  09cf		       02		      .byte.b	CHARACTER_BOX	;  2
    269  09d0		       03	   ANIM_TARGET .byte.b	CHARACTER_TARGET	;  3  XOR'd to give flashing target squares
    270  09d1		       04		      .byte.b	CHARACTER_TARGET2	;  4
    271  09d2		       05		      .byte.b	CHARACTER_MANOCCUPIED	;  5
    272  09d3		       06		      .byte.b	CHARACTER_STEEL	;  6
    273  09d4		       07		      .byte.b	CHARACTER_WALL	;  7
    274  09d5		       08		      .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    275  09d6		       00		      .byte.b	CHARACTER_BLANK	;  9
    276  09d7
    277  09d7				  -	      IF	(* - CharReplacement != CHARACTER_MAXIMUM)
    278  09d7				  -	      ECHO	"ERROR: Incorrect CharReplacement table!"
    279  09d7				  -	      ERR
    280  09d7					      ENDIF
      0  09d7					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  09d7					      LIST	ON
    282  09d7
      0  09d7					      DEFINE_SUBROUTINE	AnimateCharReplacements2	;139
      1  09d7		       00 01	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  09d7					      SUBROUTINE
      3  09d7				   AnimateCharReplacements2
    284  09d7
    285  09d7							; This manages character animation on a per-object basis.  Morph/animate these
    286  09d7							; characters individually or as required.  Change will affect all characters
    287  09d7							; of the same type in the visible display.
    288  09d7
    289  09d7							; -------------------------------------------
    290  09d7
    291  09d7							; handle the non-mandatory animating things
    292  09d7
    293  09d7		       a5 b2		      lda	timer	;3
    294  09d9		       29 01		      and	#1	;2
    295  09db		       d0 0c		      bne	nothingAnimates	;2/3
    296  09dd
    297  09dd		       a5 98		      lda	scrollBits	;3
    298  09df		       d0 08		      bne	nothingAnimates	;2/3		 DON'T animate if we scrolled
    299  09e1
    300  09e1		       ad d0 f1 	      lda	ANIM_TARGET	;4
    301  09e4		       49 07		      eor	#CHARACTER_TARGET^CHARACTER_TARGET2	;2
    302  09e6		       8d d0 f5 	      sta	ANIM_TARGET + RAM_WRITE	;4 = 22	 TARGET
    303  09e9
    304  09e9		       60	   nothingAnimates rts		;6 = 28 if animating, less if not
    305  09ea
    306  09ea							;------------------------------------------------------------------------------
    307  09ea
    308  09ea
      0  09ea					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
 PAGE BREAK INSERTED FOR  ROW_BankChar
 REQUESTED SIZE =  $50
 WASTED SPACE =  $16
 PAGEBREAK LOCATION =  $f200
     10  0a00					      LIST	ON
      0  0a00					      DEFINE_SUBROUTINE	ROW_BankChar
      1  0a00		       00 01	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  0a00					      SUBROUTINE
      3  0a00				   ROW_BankChar
    311  0a00
    312  0a00				   .BANK      SET	BANK_SCREENMARKII1
    313  0a00					      REPEAT	SCREEN_LINES
    314  0a00					      REPEAT	SCREEN_WIDTH
    315  0a00		       00		      .byte.b	.BANK
    314  0a00					      REPEND
    315  0a01		       00		      .byte.b	.BANK
    314  0a01					      REPEND
    315  0a02		       00		      .byte.b	.BANK
    314  0a02					      REPEND
    315  0a03		       00		      .byte.b	.BANK
    314  0a03					      REPEND
    315  0a04		       00		      .byte.b	.BANK
    314  0a04					      REPEND
    315  0a05		       00		      .byte.b	.BANK
    314  0a05					      REPEND
    315  0a06		       00		      .byte.b	.BANK
    314  0a06					      REPEND
    315  0a07		       00		      .byte.b	.BANK
    314  0a07					      REPEND
    315  0a08		       00		      .byte.b	.BANK
    314  0a08					      REPEND
    315  0a09		       00		      .byte.b	.BANK
    316  0a0a					      REPEND
    317  0a0a				   .BANK      SET	.BANK + 1
    313  0a0a					      REPEND
    314  0a0a					      REPEAT	SCREEN_WIDTH
    315  0a0a		       01		      .byte.b	.BANK
    314  0a0a					      REPEND
    315  0a0b		       01		      .byte.b	.BANK
    314  0a0b					      REPEND
    315  0a0c		       01		      .byte.b	.BANK
    314  0a0c					      REPEND
    315  0a0d		       01		      .byte.b	.BANK
    314  0a0d					      REPEND
    315  0a0e		       01		      .byte.b	.BANK
    314  0a0e					      REPEND
    315  0a0f		       01		      .byte.b	.BANK
    314  0a0f					      REPEND
    315  0a10		       01		      .byte.b	.BANK
    314  0a10					      REPEND
    315  0a11		       01		      .byte.b	.BANK
    314  0a11					      REPEND
    315  0a12		       01		      .byte.b	.BANK
    314  0a12					      REPEND
    315  0a13		       01		      .byte.b	.BANK
    316  0a14					      REPEND
    317  0a14				   .BANK      SET	.BANK + 1
    313  0a14					      REPEND
    314  0a14					      REPEAT	SCREEN_WIDTH
    315  0a14		       02		      .byte.b	.BANK
    314  0a14					      REPEND
    315  0a15		       02		      .byte.b	.BANK
    314  0a15					      REPEND
    315  0a16		       02		      .byte.b	.BANK
    314  0a16					      REPEND
    315  0a17		       02		      .byte.b	.BANK
    314  0a17					      REPEND
    315  0a18		       02		      .byte.b	.BANK
    314  0a18					      REPEND
    315  0a19		       02		      .byte.b	.BANK
    314  0a19					      REPEND
    315  0a1a		       02		      .byte.b	.BANK
    314  0a1a					      REPEND
    315  0a1b		       02		      .byte.b	.BANK
    314  0a1b					      REPEND
    315  0a1c		       02		      .byte.b	.BANK
    314  0a1c					      REPEND
    315  0a1d		       02		      .byte.b	.BANK
    316  0a1e					      REPEND
    317  0a1e				   .BANK      SET	.BANK + 1
    313  0a1e					      REPEND
    314  0a1e					      REPEAT	SCREEN_WIDTH
    315  0a1e		       03		      .byte.b	.BANK
    314  0a1e					      REPEND
    315  0a1f		       03		      .byte.b	.BANK
    314  0a1f					      REPEND
    315  0a20		       03		      .byte.b	.BANK
    314  0a20					      REPEND
    315  0a21		       03		      .byte.b	.BANK
    314  0a21					      REPEND
    315  0a22		       03		      .byte.b	.BANK
    314  0a22					      REPEND
    315  0a23		       03		      .byte.b	.BANK
    314  0a23					      REPEND
    315  0a24		       03		      .byte.b	.BANK
    314  0a24					      REPEND
    315  0a25		       03		      .byte.b	.BANK
    314  0a25					      REPEND
    315  0a26		       03		      .byte.b	.BANK
    314  0a26					      REPEND
    315  0a27		       03		      .byte.b	.BANK
    316  0a28					      REPEND
    317  0a28				   .BANK      SET	.BANK + 1
    313  0a28					      REPEND
    314  0a28					      REPEAT	SCREEN_WIDTH
    315  0a28		       04		      .byte.b	.BANK
    314  0a28					      REPEND
    315  0a29		       04		      .byte.b	.BANK
    314  0a29					      REPEND
    315  0a2a		       04		      .byte.b	.BANK
    314  0a2a					      REPEND
    315  0a2b		       04		      .byte.b	.BANK
    314  0a2b					      REPEND
    315  0a2c		       04		      .byte.b	.BANK
    314  0a2c					      REPEND
    315  0a2d		       04		      .byte.b	.BANK
    314  0a2d					      REPEND
    315  0a2e		       04		      .byte.b	.BANK
    314  0a2e					      REPEND
    315  0a2f		       04		      .byte.b	.BANK
    314  0a2f					      REPEND
    315  0a30		       04		      .byte.b	.BANK
    314  0a30					      REPEND
    315  0a31		       04		      .byte.b	.BANK
    316  0a32					      REPEND
    317  0a32				   .BANK      SET	.BANK + 1
    313  0a32					      REPEND
    314  0a32					      REPEAT	SCREEN_WIDTH
    315  0a32		       05		      .byte.b	.BANK
    314  0a32					      REPEND
    315  0a33		       05		      .byte.b	.BANK
    314  0a33					      REPEND
    315  0a34		       05		      .byte.b	.BANK
    314  0a34					      REPEND
    315  0a35		       05		      .byte.b	.BANK
    314  0a35					      REPEND
    315  0a36		       05		      .byte.b	.BANK
    314  0a36					      REPEND
    315  0a37		       05		      .byte.b	.BANK
    314  0a37					      REPEND
    315  0a38		       05		      .byte.b	.BANK
    314  0a38					      REPEND
    315  0a39		       05		      .byte.b	.BANK
    314  0a39					      REPEND
    315  0a3a		       05		      .byte.b	.BANK
    314  0a3a					      REPEND
    315  0a3b		       05		      .byte.b	.BANK
    316  0a3c					      REPEND
    317  0a3c				   .BANK      SET	.BANK + 1
    313  0a3c					      REPEND
    314  0a3c					      REPEAT	SCREEN_WIDTH
    315  0a3c		       06		      .byte.b	.BANK
    314  0a3c					      REPEND
    315  0a3d		       06		      .byte.b	.BANK
    314  0a3d					      REPEND
    315  0a3e		       06		      .byte.b	.BANK
    314  0a3e					      REPEND
    315  0a3f		       06		      .byte.b	.BANK
    314  0a3f					      REPEND
    315  0a40		       06		      .byte.b	.BANK
    314  0a40					      REPEND
    315  0a41		       06		      .byte.b	.BANK
    314  0a41					      REPEND
    315  0a42		       06		      .byte.b	.BANK
    314  0a42					      REPEND
    315  0a43		       06		      .byte.b	.BANK
    314  0a43					      REPEND
    315  0a44		       06		      .byte.b	.BANK
    314  0a44					      REPEND
    315  0a45		       06		      .byte.b	.BANK
    316  0a46					      REPEND
    317  0a46				   .BANK      SET	.BANK + 1
    313  0a46					      REPEND
    314  0a46					      REPEAT	SCREEN_WIDTH
    315  0a46		       07		      .byte.b	.BANK
    314  0a46					      REPEND
    315  0a47		       07		      .byte.b	.BANK
    314  0a47					      REPEND
    315  0a48		       07		      .byte.b	.BANK
    314  0a48					      REPEND
    315  0a49		       07		      .byte.b	.BANK
    314  0a49					      REPEND
    315  0a4a		       07		      .byte.b	.BANK
    314  0a4a					      REPEND
    315  0a4b		       07		      .byte.b	.BANK
    314  0a4b					      REPEND
    315  0a4c		       07		      .byte.b	.BANK
    314  0a4c					      REPEND
    315  0a4d		       07		      .byte.b	.BANK
    314  0a4d					      REPEND
    315  0a4e		       07		      .byte.b	.BANK
    314  0a4e					      REPEND
    315  0a4f		       07		      .byte.b	.BANK
    316  0a50					      REPEND
    317  0a50				   .BANK      SET	.BANK + 1
    318  0a50					      REPEND
    319  0a50
      0  0a50					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  0a50
      2  0a50
      3  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $250 , FREE= $1b0
      4  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0a50				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0a50				  -	      ERR
      8  0a50					      endif
    321  0a50
    322  0a50
      0  0a50					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $250 , FREE= $5b0
      2  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0a50				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0a50				  -	      ERR
      6  0a50					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 4
      0  0a50					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  0a50							;    Sokoboo - a Sokoban implementation
      2  0a50							;    using a generic tile-based display engine for the Atari 2600
      3  0a50							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  0a50							;
      5  0a50							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  0a50							;
      7  0a50							;    Code related to the generic tile-based display engine was developed by
      8  0a50							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  0a50							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  0a50							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  0a50							;
     12  0a50							;    Code related to music and sound effects uses the TIATracker music player
     13  0a50							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  0a50							;    directory for Apache licensing details.
     15  0a50							;
     16  0a50							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  0a50							;    See the copyright notices in the License directory for a list of level
     18  0a50							;    contributors.
     19  0a50							;
     20  0a50							;    Except where otherwise indicated, this software is released under the
     21  0a50							;    following licensing arrangement...
     22  0a50							;
     23  0a50							;    This program is free software: you can redistribute it and/or modify
     24  0a50							;    it under the terms of the GNU General Public License as published by
     25  0a50							;    the Free Software Foundation, either version 3 of the License, or
     26  0a50							;    (at your option) any later version.
     27  0a50							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  0a50
     29  0a50							;    This program is distributed in the hope that it will be useful,
     30  0a50							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  0a50							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  0a50							;    GNU General Public License for more details.
     33  0a50
     34  0a50							;------------------------------------------------------------------------------
     35  0a50							;##############################################################################
     36  0a50							;------------------------------------------------------------------------------
      0  0a50					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  139d ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
     38  1000
     39  1000
     40  1000		       00 9a	   SCORE_COL  =	$9a	;WHITE ;-2
     41  1000		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
     42  1000		       00 66	   SCORE_COL_HIGH_PAL =	$66
     43  1000
     44  1000
     45  1000				   DigitVectorLOr
     46  1000		       31 3f 4d 38*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     47  100a		       00 07 0e 15	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     48  100e				   DigitVectorLO
     49  100e		       53 61 6e 5a*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     50  1018		       37		      .byte.b	<BLANKL-1
     51  1019
     52  1019
     53  1019		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     54  1019		       00 0b	   ID_TARGET  =	11
     55  1019		       00 0c	   ID_EXTRA   =	12
     56  1019		       00 0d	   ID_CLOCK   =	13
     57  1019		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     58  1019
     59  1019							; score patch adresses:
     60  1019				   SMTblLSB
     61  1019				   SMTblTargets
     62  1019		       52 48		      .byte.b	SM_TARGET0+1-SM_BASE, SM_TARGET2+1-SM_BASE
     63  101b				   SMTblTime
     64  101b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     65  101d				   SMTblScore
     66  101d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     67  1020				   SMTblMSB
     68  1020		       4d 43		      .byte.b	SM_TARGET1+1-SM_BASE, SM_TARGET3+1-SM_BASE
     69  1022		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     70  1024		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     71  1027
     72  1027		       00 00	   SM_OFS_TARGETS =	SMTblTargets - SMTblLSB
     73  1027		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     74  1027		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     75  1027
     76  1027				   CharVectorLO
     77  1027		       37		      .byte.b	<BLANKL-1
     78  1028		       ad ad ad ad	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     79  102c		       ad ad ad ad	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     80  1030		       ad ad ad ad	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     81  1034		       ad ad ad ad	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     82  1038							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     83  1038
     84  1038							; Digit shape definitions are at start of bank so that we don't have page boundary
     85  1038							; crossing issues.
     86  1038
     87  1038							;	  .byte 0	      ; required!
     88  1038
     89  1038		       00 07	   DIGIT_H    =	7	; height of a score digit
     90  1038
     91  1038		       00 00 00 00*BLANKL     ds	7,0
     92  103f
     93  103f
     94  103f
     95  103f				   NineL
     96  103f		       1e		      .byte.b	%00011110
     97  1040		       02		      .byte.b	%00000010
     98  1041		       02		      .byte.b	%00000010
     99  1042		       fe		      .byte.b	%11111110
    100  1043		       82		      .byte.b	%10000010
    101  1044		       82		      .byte.b	%10000010
    102  1045		       fe		      .byte.b	%11111110
    103  1046
    104  1046				   SixL
    105  1046		       fe		      .byte.b	%11111110
    106  1047		       82		      .byte.b	%10000010
    107  1048		       82		      .byte.b	%10000010
    108  1049		       fe		      .byte.b	%11111110
    109  104a		       80		      .byte.b	%10000000
    110  104b		       80		      .byte.b	%10000000
    111  104c		       f0		      .byte.b	%11110000
    112  104d
    113  104d							;    .byte %01111100
    114  104d							;    .byte %11000010
    115  104d							;    .byte %11000010
    116  104d							;    .byte %11111100
    117  104d							;    .byte %11000000
    118  104d							;    .byte %01100000
    119  104d							;    .byte %00111000
    120  104d				   EightL
    121  104d
    122  104d
    123  104d		       fe		      .byte.b	%11111110
    124  104e		       82		      .byte.b	%10000010
    125  104f		       82		      .byte.b	%10000010
    126  1050		       fe		      .byte.b	%11111110
    127  1051		       82		      .byte.b	%10000010
    128  1052		       82		      .byte.b	%10000010
    129  1053		       fe		      .byte.b	%11111110
    130  1054
    131  1054							;  .byte %01111100
    132  1054							;  .byte %10000110
    133  1054							;  .byte %10000110
    134  1054							;  .byte %01111100
    135  1054							;  .byte %01000110
    136  1054							;  .byte %01000110
    137  1054							;  .byte %00111100
    138  1054				   ZeroL
    139  1054							;  .byte %01111100
    140  1054							;  .byte %10000110
    141  1054							;  .byte %10000110
    142  1054							;  .byte %10000110
    143  1054							;  .byte %10000110
    144  1054							;  .byte %01000110
    145  1054							;  .byte %00111100
    146  1054
    147  1054		       fe		      .byte.b	%11111110
    148  1055		       82		      .byte.b	%10000010
    149  1056		       82		      .byte.b	%10000010
    150  1057		       82		      .byte.b	%10000010
    151  1058		       82		      .byte.b	%10000010
    152  1059		       82		      .byte.b	%10000010
    153  105a		       fe		      .byte.b	%11111110
    154  105b
    155  105b				   ThreeL
    156  105b		       fe		      .byte.b	%11111110
    157  105c		       02		      .byte.b	%00000010
    158  105d		       02		      .byte.b	%00000010
    159  105e		       1e		      .byte.b	%00011110
    160  105f		       02		      .byte.b	%00000010
    161  1060		       02		      .byte.b	%00000010
    162  1061		       fe		      .byte.b	%11111110
    163  1062				   OneL
    164  1062		       10		      .byte.b	%00010000
    165  1063		       10		      .byte.b	%00010000
    166  1064		       10		      .byte.b	%00010000
    167  1065		       10		      .byte.b	%00010000
    168  1066		       10		      .byte.b	%00010000
    169  1067		       10		      .byte.b	%00010000
    170  1068		       10		      .byte.b	%00010000
    171  1069
    172  1069				   SevenL
    173  1069
    174  1069		       10		      .byte.b	%00010000
    175  106a		       10		      .byte.b	%00010000
    176  106b		       10		      .byte.b	%00010000
    177  106c		       1e		      .byte.b	%00011110
    178  106d		       02		      .byte.b	%00000010
    179  106e		       02		      .byte.b	%00000010
    180  106f							;  .byte %11111110
    181  106f
    182  106f							;    .byte %00010000
    183  106f							;    .byte %00010000
    184  106f							;    .byte %00010000
    185  106f							;    .byte %00011000
    186  106f							;    .byte %00001100
    187  106f							;    .byte %10000110
    188  106f							;    ;.byte %11111110
    189  106f				   TwoL
    190  106f		       fe		      .byte.b	%11111110
    191  1070		       80		      .byte.b	%10000000
    192  1071		       80		      .byte.b	%10000000
    193  1072		       fe		      .byte.b	%11111110
    194  1073		       02		      .byte.b	%00000010
    195  1074		       02		      .byte.b	%00000010
    196  1075		       fe		      .byte.b	%11111110
    197  1076
    198  1076				   FiveL
    199  1076		       fe		      .byte.b	%11111110
    200  1077		       02		      .byte.b	%00000010
    201  1078		       02		      .byte.b	%00000010
    202  1079		       fe		      .byte.b	%11111110
    203  107a		       80		      .byte.b	%10000000
    204  107b		       80		      .byte.b	%10000000
    205  107c		       f0		      .byte.b	%11110000
    206  107d
    207  107d				   FourL
    208  107d		       10		      .byte.b	%00010000
    209  107e		       10		      .byte.b	%00010000
    210  107f		       10		      .byte.b	%00010000
    211  1080		       fe		      .byte.b	%11111110
    212  1081		       90		      .byte.b	%10010000
    213  1082		       90		      .byte.b	%10010000
    214  1083		       90		      .byte.b	%10010000
    215  1084
    216  1084
    217  1084				   ZL
    218  1084		       7f		      .byte.b	%01111111
    219  1085		       40		      .byte.b	%01000000
    220  1086		       40		      .byte.b	%01000000
    221  1087		       7f		      .byte.b	%01111111
    222  1088		       01		      .byte.b	%00000001
    223  1089		       01		      .byte.b	%00000001
    224  108a		       0f		      .byte.b	%00001111
    225  108b
    226  108b				   EL
    227  108b		       7f		      .byte.b	%01111111
    228  108c		       40		      .byte.b	%01000000
    229  108d		       40		      .byte.b	%01000000
    230  108e		       78		      .byte.b	%01111000
    231  108f		       40		      .byte.b	%01000000
    232  1090		       40		      .byte.b	%01000000
    233  1091		       7f		      .byte.b	%01111111
    234  1092
    235  1092				   RL
    236  1092		       48		      .byte.b	%01001000
    237  1093		       48		      .byte.b	%01001000
    238  1094		       48		      .byte.b	%01001000
    239  1095		       7f		      .byte.b	%01111111
    240  1096		       41		      .byte.b	%01000001
    241  1097		       41		      .byte.b	%01000001
    242  1098		       7f		      .byte.b	%01111111
    243  1099
    244  1099				   PL
    245  1099		       40		      .byte.b	%01000000
    246  109a		       40		      .byte.b	%01000000
    247  109b		       40		      .byte.b	%01000000
    248  109c		       7f		      .byte.b	%01111111
    249  109d		       41		      .byte.b	%01000001
    250  109e		       41		      .byte.b	%01000001
    251  109f		       7f		      .byte.b	%01111111
    252  10a0
    253  10a0				   AL
    254  10a0		       41		      .byte.b	%01000001
    255  10a1		       41		      .byte.b	%01000001
    256  10a2		       41		      .byte.b	%01000001
    257  10a3		       7f		      .byte.b	%01111111
    258  10a4		       41		      .byte.b	%01000001
    259  10a5		       41		      .byte.b	%01000001
    260  10a6		       7f		      .byte.b	%01111111
    261  10a7
    262  10a7				   GL
    263  10a7		       7f		      .byte.b	%01111111
    264  10a8		       41		      .byte.b	%01000001
    265  10a9		       41		      .byte.b	%01000001
    266  10aa		       4f		      .byte.b	%01001111
    267  10ab		       40		      .byte.b	%01000000
    268  10ac		       40		      .byte.b	%01000000
    269  10ad		       7f		      .byte.b	%01111111
    270  10ae
    271  10ae
    272  10ae							; level "name" characters (left only!):
    273  10ae
    274  10ae				   CharN
    275  10ae				   CharK
    276  10ae				   CharH
    277  10ae				   CharA
    278  10ae				   CharJ
    279  10ae				   CharP
    280  10ae				   CharB
    281  10ae				   CharO
    282  10ae				   CharC
    283  10ae				   CharI
    284  10ae				   CharD
    285  10ae				   CharG
    286  10ae				   CharE
    287  10ae				   CharL
    288  10ae				   CharF
    289  10ae				   CharM
    290  10ae		       00 00 00 00*	      ds	7,0
    291  10b5
    292  10b5				   charPlace
    293  10b5		       0c		      .byte.b	%00001100
    294  10b6		       0c		      .byte.b	%00001100
    295  10b7		       0c		      .byte.b	%00001100
    296  10b8		       0c		      .byte.b	%00001100
    297  10b9		       0c		      .byte.b	%00001100
    298  10ba		       00		      .byte.b	%00000000
    299  10bb		       0c		      .byte.b	%00001100
    300  10bc
    301  10bc							;-------------------------------------------------------------------------------------
    302  10bc				   PosTbl
    303  10bc		       40		      .byte.b	$40
    304  10bd		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    305  10c5		       b9		      .byte.b	$b9
    306  10c6
    307  10c6
    308  10c6							;------------------------------------------------------------------------------
    309  10c6							; RAM-BASED SUBROUTINES...
    310  10c6							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    311  10c6							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    312  10c6							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    313  10c6							; the RAM-based routine.
    314  10c6
    315  1100		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    316  1100
    317  1100		       f1 00	   SM_BASE    =	.
    318  1100
    319  1100							;#IF 0 ;{
    320  1100							;    DEFINE_SUBROUTINE Score3x3
    321  1100							;
    322  1100							;	  sta	  RESP0
    323  1100							;	   sta	   RESP1
    324  1100							;	   lda	   #$$000
    325  1100							;	    sta     GRP0
    326  1100							;	    lda     #$$009
    327  1100							;	    sta     GRP1
    328  1100							;	    lda     #$$202
    329  1100							;	    sta     ENABL
    330  1100							;	    nop
    331  1100							;	    nop
    332  1100							;	    nop
    333  1100							;	    lda     #$$016
    334  1100							;	    ldy     #$$100
    335  1100							;	    ldx     #$$109
    336  1100							;	    sta     GRP0    ; Critical time is right here
    337  1100							;	    stx     GRP1
    338  1100							;	    sty     GRP0
    339  1100							;	    sta     RESP0
    340  1100							;	    sta     RESP1
    341  1100							;	    ldx     #$$116
    342  1100							;	    lda     #$$209
    343  1100							;	    stx     GRP0
    344  1100							;	    sta     GRP1
    345  1100							;	    lda     #$$200
    346  1100							;	    sta     GRP0
    347  1100							;	    sta     RESP0
    348  1100							;	    sta     RESP1
    349  1100							;	    lda     #$$216
    350  1100							;	    nop
    351  1100							;	    sta     GRP0
    352  1100							;
    353  1100							;	      rts
    354  1100							;#ENDIF ;}
    355  1100
    356  1100
    357  1100							;------------------------------------------------------------------------------
    358  1100				   Score1x6Fix SUBROUTINE
      0  1100					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  1100		       00 02	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  1100					      SUBROUTINE
      3  1100				   DrawDigits1x6
    360  1100							;					     @07
    361  1100		       ba		      tsx		; 2
    362  1101
    363  1101		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 58    @65
    364  1104
    365  1104		       86 da		      stx	tmpStack	; 3 =	3
    366  1106
    367  1106				   LoopDraw1x6		;
    368  1106				   SMDIGIT0
    369  1106		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    370  1109		       85 42		      sta	WSYNC	; 3
    371  110b							;---------------------------------------------------------------
    372  110b		       85 6a		      sta	HMOVE	; 3
      0  110d					      SLEEP	3	; 3 =	6
      1  110d				   .CYCLES    SET	3
      2  110d
      3  110d				  -	      IF	.CYCLES < 2
      4  110d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  110d				  -	      ERR
      6  110d					      ENDIF
      7  110d
      8  110d					      IF	.CYCLES & 1
      9  110d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  110d		       04 00		      nop	0
     11  110f				  -	      ELSE
     12  110f				  -	      bit	VSYNC
     13  110f					      ENDIF
     14  110f				   .CYCLES    SET	.CYCLES - 3
     15  110f					      ENDIF
     16  110f
     17  110f				  -	      REPEAT	.CYCLES / 2
     18  110f				  -	      nop
     19  110f					      REPEND
    374  110f		       85 5b		      sta	GRP0	; 3
    375  1111				   SMDIGIT1
    376  1111		       b9 53 f0 	      lda	ZeroL-1,y	; 4
    377  1114		       85 5c		      sta	GRP1	; 3
    378  1116				   SMDIGIT2
    379  1116		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    380  1119		       85 5b		      sta	GRP0	; 3 = 17
    381  111b				   SMDIGIT5
    382  111b		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    383  111e		       9a		      txs		; 2
    384  111f				   SMDIGIT3
    385  111f		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    386  1122				   SMDIGIT4
    387  1122		       b9 31 f3 	      lda	ZeroR-1,y	; 4
    388  1125		       85 6b		      sta	HMCLR	; 3
    389  1127		       86 5c		      stx	GRP1	; 3
    390  1129		       85 5b		      sta	GRP0	; 3 = 23
    391  112b
    392  112b		       ba		      tsx		; 2
    393  112c		       86 5c		      stx	GRP1	; 3
    394  112e		       85 5b		      sta	GRP0	; 3 =	8
    395  1130
    396  1130		       88		      dey		; 2
      0  1131					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  1131					      LIST	ON
      9  1131		       d0 d3		      bne	LoopDraw1x6
    398  1133
    399  1133		       a6 da		      ldx	tmpStack	; 3
    400  1135		       9a		      txs		; 2
    401  1136				   ExitDigitKernel6
      0  1136					      SLEEP	3	; 3
      1  1136				   .CYCLES    SET	3
      2  1136
      3  1136				  -	      IF	.CYCLES < 2
      4  1136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1136				  -	      ERR
      6  1136					      ENDIF
      7  1136
      8  1136					      IF	.CYCLES & 1
      9  1136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1136		       04 00		      nop	0
     11  1138				  -	      ELSE
     12  1138				  -	      bit	VSYNC
     13  1138					      ENDIF
     14  1138				   .CYCLES    SET	.CYCLES - 3
     15  1138					      ENDIF
     16  1138
     17  1138				  -	      REPEAT	.CYCLES / 2
     18  1138				  -	      nop
     19  1138					      REPEND
    403  1138		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    404  113b
    405  113b
    406  113b							;------------------------------------------------------------------------------
    407  113b				   Score2x4Fix SUBROUTINE
      0  113b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  113b		       00 02	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  113b					      SUBROUTINE
      3  113b				   DrawDigits2x4
    409  113b
    410  113b
    411  113b							; Subroutine by Thomas Jentzsch.  Magic!
    412  113b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    413  113b
    414  113b							;sta COLUBK
    415  113b
    416  113b		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 56    @63
    417  113e
    418  113e		       85 6a		      sta	HMOVE	; 3
      0  1140					      SLEEP	4	; 4  =  7
      1  1140				   .CYCLES    SET	4
      2  1140
      3  1140				  -	      IF	.CYCLES < 2
      4  1140				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1140				  -	      ERR
      6  1140					      ENDIF
      7  1140
      8  1140				  -	      IF	.CYCLES & 1
      9  1140				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1140				  -	      nop	0
     11  1140				  -	      ELSE
     12  1140				  -	      bit	VSYNC
     13  1140				  -	      ENDIF
     14  1140				  -.CYCLES    SET	.CYCLES - 3
     15  1140					      ENDIF
     16  1140
     17  1140					      REPEAT	.CYCLES / 2
     18  1140		       ea		      nop
     17  1140					      REPEND
     18  1141		       ea		      nop
     19  1142					      REPEND
    420  1142
    421  1142				   LoopDraw2x4		;	     @70
    422  1142				   SM_TARGET3
    423  1142		       b9 07 f3 	      lda	DequalsR-1,y	; 4		     G
    424  1145							;---------------------------------------------------------------
    425  1145		       85 5b		      sta	GRP0	; 3
    426  1147				   SM_TARGET2
    427  1147		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     A
    428  114a		       85 5c		      sta	GRP1	; 3
    429  114c				   SM_TARGET1
    430  114c		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     M
    431  114f		       85 5b		      sta	GRP0	; 3
    432  1151				   SM_TARGET0
    433  1151		       be 53 f0 	      ldx	ZeroL-1,y	; 4		     E
    434  1154		       85 50		      sta	RESP0	; 3 = 28    @22
    435  1156		       85 51		      sta	RESP1	; 3 =	3    @25
    436  1158				   SM_Time3
    437  1158		       b9 15 f3 	      lda	ClockR-1,y	; 4		     O
    438  115b		       86 5c		      stx	GRP1	; 3
    439  115d		       85 5b		      sta	GRP0	; 3
    440  115f				   SM_Time2
    441  115f		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     V
    442  1162		       85 5c		      sta	GRP1	; 3
    443  1164				   SM_Time1
    444  1164		       b9 31 f3 	      lda	ZeroR-1,y	; 4		     E
    445  1167		       85 5b		      sta	GRP0	; 3
    446  1169		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    447  116b		       85 51		      sta	RESP1	; 3 =	3    @55
    448  116d				   SM_Time0
    449  116d		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     R
    450  1170		       85 5c		      sta	GRP1	; 3
    451  1172		       85 5b		      sta	GRP0	; 3
    452  1174		       88		      dey		; 2
      0  1175					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  1175					      LIST	ON
      9  1175		       d0 cb		      bne	LoopDraw2x4
    454  1177
    455  1177				   ExitDigitKernel		;	     @69
    456  1177		       84 5b		      sty	GRP0	; 3
    457  1179		       84 5c		      sty	GRP1	; 3
    458  117b							;---------------------------------------------------------------
    459  117b		       84 5b		      sty	GRP0	; 3	     @02
    460  117d
    461  117d							; Contribution by Thomas Jentzsch
    462  117d							; Rewrite/Optimised for single sprite AD
    463  117d
    464  117d		       a6 9d		      ldx	ManDrawX	; 3
    465  117f		       bd bc f0 	      lda	PosTbl,x	; 4
    466  1182		       85 60		      sta	HMP0	; 3
    467  1184		       29 0f		      and	#$0f	; 2
    468  1186		       f0 04		      beq	.zeroPos	; 2/3=15
    469  1188		       aa		      tax		; 2
    470  1189				   .loopWait
    471  1189		       ca		      dex		; 2
    472  118a		       d0 fd		      bne	.loopWait	; 2/3= 6
    473  118c				   .zeroPos
    474  118c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    475  118e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    476  1190		       a5 b3		      lda	BGColour	; 3
    477  1192		       86 62		      stx	HMM0	; 3	     for extra life stars!
    478  1194		       85 42		      sta	WSYNC	; 3
    479  1196							;---------------------------------------------------------------
    480  1196		       85 6a		      sta	HMOVE	; 3
    481  1198		       60		      rts		; 6	     @09
    482  1199
    483  1199							;------------------------------------------------------------------------------
    484  1199				   Score3x2Fix SUBROUTINE
      0  1199					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  1199		       00 02	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  1199					      SUBROUTINE
      3  1199				   DrawDigits3x2
    486  1199							;					     @07
    487  1199		       a9 16		      lda	#%010110	; 2
    488  119b		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    489  119d		       20 f4 f1 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    490  11a0
    491  11a0		       a9 00		      lda	#0
    492  11a2		       85 66		      sta	VDELP1
    493  11a4				   LoopDraw3x2		;
    494  11a4		       85 42		      sta	WSYNC	; 3
    495  11a6							;---------------------------------------------------------------
    496  11a6		       85 6a		      sta	HMOVE	; 3 =	3
    497  11a8		       b9 ad f0 	      lda	CharP-1,y	; 4
    498  11ab		       85 5b		      sta	GRP0	; 3
    499  11ad				   SMPLAYER
    500  11ad		       b9 3f f3 	      lda	OneR-1,y	; 4
    501  11b0		       85 5c		      sta	GRP1	; 3 = 14    @17
    502  11b2		       b9 b4 f0 	      lda	charPlace-1,y	; 4
    503  11b5				   SMMEN
    504  11b5		       be 38 f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  11b8					      SLEEP	5	;   =	5
      1  11b8				   .CYCLES    SET	5
      2  11b8
      3  11b8				  -	      IF	.CYCLES < 2
      4  11b8				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11b8				  -	      ERR
      6  11b8					      ENDIF
      7  11b8
      8  11b8					      IF	.CYCLES & 1
      9  11b8					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11b8		       04 00		      nop	0
     11  11ba				  -	      ELSE
     12  11ba				  -	      bit	VSYNC
     13  11ba					      ENDIF
     14  11ba				   .CYCLES    SET	.CYCLES - 3
     15  11ba					      ENDIF
     16  11ba
     17  11ba					      REPEAT	.CYCLES / 2
     18  11ba		       ea		      nop
     19  11bb					      REPEND
    506  11bb		       85 5b		      sta	GRP0	; 3
    507  11bd				   SMLEVELX
    508  11bd		       b9 ad f0 	      lda	CharA-1,y	; 4
    509  11c0		       85 6b		      sta	HMCLR	; 3 = 10    @40
    510  11c2		       86 5c		      stx	GRP1	; 3 =	3    @43
    511  11c4		       85 5b		      sta	GRP0	; 3
    512  11c6				   SMLEVEL
    513  11c6		       b9 3f f3 	      lda	OneR-1,y	; 4
    514  11c9		       85 5c		      sta	GRP1	; 3 = 10    @53
    515  11cb
    516  11cb		       88		      dey		; 2
      0  11cc					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  11cc					      LIST	ON
      9  11cc		       d0 d6		      bne	LoopDraw3x2
    518  11ce							;					     @57
      0  11ce					      SLEEP	3	; 3
      1  11ce				   .CYCLES    SET	3
      2  11ce
      3  11ce				  -	      IF	.CYCLES < 2
      4  11ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11ce				  -	      ERR
      6  11ce					      ENDIF
      7  11ce
      8  11ce					      IF	.CYCLES & 1
      9  11ce					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11ce		       04 00		      nop	0
     11  11d0				  -	      ELSE
     12  11d0				  -	      bit	VSYNC
     13  11d0					      ENDIF
     14  11d0				   .CYCLES    SET	.CYCLES - 3
     15  11d0					      ENDIF
     16  11d0
     17  11d0				  -	      REPEAT	.CYCLES / 2
     18  11d0				  -	      nop
     19  11d0					      REPEND
    520  11d0		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    521  11d3
    522  11d3
    523  11d3							;------------------------------------------------------------------------------
      0  11d3					      DEFINE_SUBROUTINE	DrawDigits
      1  11d3		       00 02	   BANK_DrawDigits =	_CURRENT_BANK
      2  11d3					      SUBROUTINE
      3  11d3				   DrawDigits
    525  11d3
    526  11d3				   VblankLoopGame
    527  11d3		       ac 84 02 	      ldy	INTIM
    528  11d6		       d0 fb		      bne	VblankLoopGame
    529  11d8
    530  11d8		       84 41		      sty	VBLANK	; 3	     <-- 0
    531  11da		       a5 c9		      lda	scoringFlags	; 3
    532  11dc		       29 03		      and	#DISPLAY_FLAGS	; 2
    533  11de		       aa		      tax		; 2
    534  11df
    535  11df							;    DEFINE_SUBROUTINE DrawDigit2
    536  11df							;
    537  11df							;    ; Generic interface to scoring routine
    538  11df
    539  11df		       bd ea f1 	      lda	ScoreKernelLo,x	; 4
    540  11e2
    541  11e2		       85 42		      sta	WSYNC	; 3
    542  11e4							;---------------------------------------------------------------
    543  11e4		       8d e8 f5 	      sta	SMJUMP+1+RAM_WRITE	; 4
    544  11e7				   SMJUMP
    545  11e7		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    546  11ea
    547  11ea				   ScoreKernelLo
    548  11ea		       3b		      .byte.b	<Score2x4Fix	; TARGETs, time
    549  11eb		       00		      .byte.b	<Score1x6Fix	; score
    550  11ec		       99		      .byte.b	<Score3x2Fix	; player, lives, level
    551  11ed		       00		      .byte.b	<Score1x6Fix	; high score
    552  11ee
      0  11ee					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  11ee					      LIST	ON
    554  11ee
    555  11ee							;------------------------------------------------------------------------------
      0  11ee					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  11ee		       00 02	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  11ee					      SUBROUTINE
      3  11ee				   PrepareDrawDigits
    557  11ee							;					     @13
    558  11ee		       a0 d1		      ldy	#$d1	; 2
    559  11f0		       a9 13		      lda	#%010011	; 2
    560  11f2		       85 66		      sta	VDELP1	; 3 =	7
    561  11f4				   PrepareDrawDigits2		;	    @17/20
    562  11f4		       84 65		      sty	VDELP0	; 3 =	3
    563  11f6
    564  11f6		       85 45		      sta	NUSIZ1	; 3
    565  11f8		       85 44		      sta	NUSIZ0	; 3 =	6
    566  11fa
    567  11fa		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    568  11fd		       85 50		      sta	RESP0	; 3	     @33/36
    569  11ff		       85 51		      sta	RESP1	; 3 = 10    @36/39
    570  1201
    571  1201		       84 60		      sty	HMP0	; 3
    572  1203		       c8		      iny		; 2
    573  1204		       84 61		      sty	HMP1	; 3 =	8
    574  1206				   SMCOLOR
    575  1206		       a0 9a		      ldy	#SCORE_COL	; 2
    576  1208		       84 46		      sty	COLUP0	; 3
    577  120a		       84 47		      sty	COLUP1	; 3 =	8
    578  120c
    579  120c		       a0 07		      ldy	#DIGIT_H	; 2
    580  120e		       60		      rts		; 6 =	8
    581  120f							; total: 27
    582  120f
    583  120f
    584  120f							;------------------------------------------------------------------------------
      0  120f					      DEFINE_SUBROUTINE	UpdateScore
      1  120f		       00 02	   BANK_UpdateScore =	_CURRENT_BANK
      2  120f					      SUBROUTINE
      3  120f				   UpdateScore
    586  120f							; a = added score value
    587  120f
    588  120f							; initially switch to score:
    589  120f		       a0 01		      ldy	#DISPLAY_SCORE
    590  1211		       84 da		      sty	newDisplay
    591  1213
    592  1213		       18		      clc
    593  1214		       f8		      sed
    594  1215		       a0 04		      ldy	#SM_OFS_SCORE
    595  1217				   .loopScore
    596  1217		       79 8a f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    597  121a		       99 8a f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    598  121d		       08		      php
    599  121e							; *** bonus life every 500 points: ***
    600  121e							;	  cpy #SM_OFS_SCORE+1
    601  121e							;	  bne .skipBonusLife
    602  121e							;	  tax
    603  121e
    604  121e							;	  and #$0f
    605  121e							;	  beq .bonusLife		      ; 000?
    606  121e							;	  cmp #$05
    607  121e							;	  bne .noBonusLife		      ; 500?
    608  121e							;.bonusLife:
    609  121e							; add extra life, limited to 9
    610  121e
    611  121e							;	  lda ManCount
    612  121e							;	  and #$0f
    613  121e							;	  cmp #9
    614  121e							;	  bcs .noBonusLife
    615  121e							;	  inc ManCount
    616  121e
    617  121e							; bonus life has priority over score:
    618  121e							;	  lda #DISPLAY_LIVES
    619  121e							;	  sta newDisplay
    620  121e							;lda #EXTRA_LIFE_TIMER
    621  121e							;sta extraLifeTimer
    622  121e
    623  121e				   .noBonusLife
    624  121e		       8a		      txa
    625  121f				   .skipBonusLife
    626  121f		       20 d4 f2 	      jsr	SetupBCDPtr
    627  1222		       28		      plp
    628  1223		       a9 00		      lda	#0
    629  1225		       b0 f0		      bcs	.loopScore
    630  1227		       d8		      cld
    631  1228
    632  1228							; switch display
    633  1228		       a5 c9		      lda	scoringFlags
    634  122a		       29 03		      and	#DISPLAY_FLAGS
    635  122c		       c5 da		      cmp	newDisplay	; lower priority than current?
    636  122e		       f0 08		      beq	.restartTime
    637  1230		       b0 0a		      bcs	.skipNew
    638  1232		       45 c9		      eor	scoringFlags	; remove existing score mode
    639  1234		       05 da		      ora	newDisplay	; switch to new score mode
    640  1236		       85 c9		      sta	scoringFlags
    641  1238				   .restartTime
    642  1238		       a9 3c		      lda	#SCORING_TIMER	; maybe always restart timer?
    643  123a		       85 c8		      sta	scoringTimer
    644  123c				   .skipNew
    645  123c
    646  123c		       60		      rts
    647  123d
    648  123d							;---------------------------------------------------------------------------
    649  123d
      0  123d					      DEFINE_SUBROUTINE	SwapPlayers
      1  123d		       00 02	   BANK_SwapPlayers =	_CURRENT_BANK
      2  123d					      SUBROUTINE
      3  123d				   SwapPlayers
    651  123d
    652  123d							; assume no new high score:
    653  123d		       a0 ff		      ldy	#-1
    654  123f		       84 dd		      sty	highScoreSK
    655  1241
    656  1241							; update highscore after last live:
    657  1241		       a5 a7		      lda	ManCount
    658  1243		       29 0f		      and	#$0f	; player has lives left?
    659  1245		       d0 1c		      bne	.playerAlive	; YES, so we don't check high score
    660  1247
    661  1247							; check for a new high score:
    662  1247							;	  ldy #-1
    663  1247		       18		      clc		; score has to be at least 1 bigger!
    664  1248				   .loopCheckHighScore
    665  1248		       c8		      iny
    666  1249		       b9 8e f3 	      lda	ScoreCurrent,y
    667  124c		       f9 98 f3 	      sbc	HighScore,y
    668  124f		       98		      tya
    669  1250		       49 02		      eor	#2
    670  1252		       d0 f4		      bne	.loopCheckHighScore
    671  1254		       90 0d		      bcc	.noHighScore
    672  1256
    673  1256							; new high score, update:
    674  1256		       a2 04		      ldx	#5-1
    675  1258				   .loopSetHighScore
    676  1258		       bd 8e f3 	      lda	ScoreCurrent,x
    677  125b		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
    678  125e		       95 dd		      sta	highScoreSK,x
    679  1260		       ca		      dex
    680  1261		       10 f5		      bpl	.loopSetHighScore
    681  1263				   .noHighScore
    682  1263
    683  1263				   .playerAlive
    684  1263		       a5 a7		      lda	ManCount
    685  1265		       29 f0		      and	#$f0	; other player has lives left?
    686  1267		       f0 21		      beq	.otherPlayerDead	; NO, so we don't swap scores
    687  1269
    688  1269							; save the current player variables to the player's backup:
    689  1269		       a0 02		      ldy	#3-1
    690  126b				   .swapScore
    691  126b		       be 93 f3 	      ldx	PlayerScores,y
    692  126e		       b9 8e f3 	      lda	ScoreCurrent,y
    693  1271		       99 93 f7 	      sta	PlayerScores+RAM_WRITE,y
    694  1274		       8a		      txa
    695  1275		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
    696  1278		       88		      dey
    697  1279		       10 f0		      bpl	.swapScore
    698  127b
    699  127b							; swap levelx and level:
    700  127b		       a2 01		      ldx	#1
    701  127d				   .loopLevelXLevel
    702  127d		       bc 96 f3 	      ldy	PlayerLevelX,x
    703  1280		       b5 b4		      lda	levelX,x
    704  1282		       9d 96 f7 	      sta	PlayerLevelX+RAM_WRITE,x
    705  1285		       94 b4		      sty	levelX,x
    706  1287		       ca		      dex
    707  1288		       10 f3		      bpl	.loopLevelXLevel
    708  128a
    709  128a				   .otherPlayerDead
    710  128a		       60		      rts
    711  128b
    712  128b							;---------------------------------------------------------------------------
    713  128b
    714  128b				   HighScoreColTbl
    715  128b		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    716  128d		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    717  128f
      0  128f					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  128f		       00 02	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  128f					      SUBROUTINE
      3  128f				   GeneralScoringSetups
    719  128f
    720  128f		       a0 04		      ldy	#SM_OFS_SCORE
    721  1291				   .loopScore2
    722  1291		       a5 c9		      lda	scoringFlags
    723  1293		       29 03		      and	#DISPLAY_FLAGS
    724  1295		       c9 03		      cmp	#DISPLAY_HIGH
    725  1297		       a6 81		      ldx	Platform
    726  1299		       bd 8b f2 	      lda	HighScoreColTbl,x
    727  129c		       aa		      tax
    728  129d		       b9 94 f3 	      lda	HighScore-SM_OFS_SCORE,y
    729  12a0		       b0 05		      bcs	.showHighScore
    730  12a2		       a2 9a		      ldx	#SCORE_COL
    731  12a4		       b9 8a f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    732  12a7				   .showHighScore
    733  12a7		       8e 07 f6 	      stx	SMCOLOR+1+RAM_WRITE
    734  12aa		       20 d4 f2 	      jsr	SetupBCDPtr
    735  12ad		       c0 07		      cpy	#SM_OFS_SCORE+3
    736  12af		       90 e0		      bcc	.loopScore2
    737  12b1
    738  12b1							; display number of lives in leftmost digit of middle score XX nX XX
    739  12b1
    740  12b1							;lda ManCount
    741  12b1							;and #$0f
    742  12b1							;tay
    743  12b1							;lda DigitVectorLOr,y
    744  12b1							;sta SMMEN+1+RAM_WRITE
    745  12b1
    746  12b1							; modify player number pointer (Xp XX XX)
    747  12b1
    748  12b1							;ldy whichPlayer
    749  12b1							;lda DigitVectorLOr+1,y
    750  12b1							;sta SMPLAYER+1+RAM_WRITE
    751  12b1
    752  12b1							; fall through
    753  12b1
    754  12b1							;    ;---------------------------------------------------------------------------
    755  12b1
    756  12b1							; modify levelx character pointer (XX XX cX)
    757  12b1
    758  12b1							;ldx #<charPlace-1
    759  12b1							;lda levelDisplay
    760  12b1							;cmp #$80
    761  12b1							;and #$1f
    762  12b1							;tay
    763  12b1							;bcs .intermission
    764  12b1							;ldx CharVectorLO,y
    765  12b1							;ldy level
    766  12b1							;.intermission
    767  12b1							;stx SMLEVELX+1+RAM_WRITE
    768  12b1
    769  12b1							; modify level number pointer (XX XX Xl)
    770  12b1
    771  12b1							;lda DigitVectorLOr+1,y
    772  12b1							;sta SMLEVEL+1+RAM_WRITE
    773  12b1
    774  12b1							;---------------------------------------------------------------------------
    775  12b1
    776  12b1		       4c cb f2 	      jmp	SetupTimePtr	; modify time pointers
    777  12b4
    778  12b4							;------------------------------------------------------------------------------
    779  12b4							;    DEFINE_SUBROUTINE SetupGameOverPtr
    780  12b4
    781  12b4							;		  ldy #8-1
    782  12b4							;.loopGameOver:
    783  12b4							;		  ldx SMGameOverOfs,y
    784  12b4							;		  lda SMGameOverPtr,y
    785  12b4							;		  sta SM_BASE+1+RAM_WRITE,x
    786  12b4							;		  dey
    787  12b4							;		  bpl .loopGameOver
    788  12b4
    789  12b4							;		  rts
    790  12b4
    791  12b4							;SMGameOverOfs:
    792  12b4							;		  .byte <SM_TARGET3-SM_BASE, <SM_TARGET2-SM_BASE
    793  12b4							;		  .byte <SM_TARGET1-SM_BASE, <SM_TARGET0-SM_BASE
    794  12b4							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    795  12b4							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    796  12b4							;SMGameOverPtr:
    797  12b4							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    798  12b4							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    799  12b4
    800  12b4							;------------------------------------------------------------------------------
    801  12b4
      0  12b4					      DEFINE_SUBROUTINE	DrawTargetsRequired
      1  12b4		       00 02	   BANK_DrawTargetsRequired =	_CURRENT_BANK
      2  12b4					      SUBROUTINE
      3  12b4				   DrawTargetsRequired
    803  12b4							; Show current TARGET counter in the top left
    804  12b4
    805  12b4		       a0 00		      ldy	#SM_OFS_TARGETS
    806  12b6		       a5 b9		      lda	targetsRequired
    807  12b8		       20 d4 f2 	      jsr	SetupBCDPtr
    808  12bb
    809  12bb		       a9 b0		      lda	#ID_TARGET<<4	; if no extra targets, display the normal icon
    810  12bd		       24 c9		      bit	scoringFlags	;
    811  12bf		       10 13		      bpl	SetupBCDPtr
    812  12c1		       a9 c0		      lda	#ID_EXTRA<<4	; otherwise, display the extra icon
    813  12c3		       50 0f		      bvc	SetupBCDPtr
    814  12c5		       09 01		      ora	#1	; display 1xx targets
    815  12c7		       d0 0b		      bne	SetupBCDPtr	; unconditional
    816  12c9
    817  12c9							;------------------------------------------------------------------------------
      0  12c9					      DEFINE_SUBROUTINE	DrawTime
      1  12c9		       00 02	   BANK_DrawTime =	_CURRENT_BANK
      2  12c9					      SUBROUTINE
      3  12c9				   DrawTime
    819  12c9
    820  12c9							; mid-digit-change, but we may be required to flash/display
    821  12c9		       a0 02		      ldy	#SM_OFS_TIME
    822  12cb							;------------------------------------------------------------------------------
      0  12cb					      DEFINE_SUBROUTINE	SetupTimePtr
      1  12cb		       00 02	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  12cb					      SUBROUTINE
      3  12cb				   SetupTimePtr
    824  12cb
    825  12cb		       a5 ba		      lda	moveCounter
    826  12cd		       20 d4 f2 	      jsr	SetupBCDPtr
    827  12d0		       a5 bb		      lda	moveCounter+1
    828  12d2		       09 d0		      ora	#ID_CLOCK<<4
    829  12d4
    830  12d4							; fall through
    831  12d4
    832  12d4							;------------------------------------------------------------------------------
      0  12d4					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  12d4		       00 02	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  12d4					      SUBROUTINE
      3  12d4				   SetupBCDPtr
    834  12d4
    835  12d4							; a = BCD value
    836  12d4							; y = SM table offset
    837  12d4
    838  12d4		       48		      pha
    839  12d5		       29 0f		      and	#$0f
    840  12d7		       aa		      tax
    841  12d8		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    842  12db		       be 19 f0 	      ldx	SMTblLSB,y
    843  12de		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    844  12e1		       68		      pla
    845  12e2		       4a		      lsr
    846  12e3		       4a		      lsr
    847  12e4		       4a		      lsr
    848  12e5		       4a		      lsr
    849  12e6		       aa		      tax
    850  12e7		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    851  12ea		       be 20 f0 	      ldx	SMTblMSB,y
    852  12ed		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    853  12f0
    854  12f0		       c8		      iny
    855  12f1
    856  12f1		       a5 c4		      lda	ROM_Bank
    857  12f3				   RTS
    858  12f3		       60		      rts
    859  12f4
      0  12f4					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
 PAGE BREAK INSERTED FOR  LeftDigits
 REQUESTED SIZE =  $5b
 WASTED SPACE =  $c
 PAGEBREAK LOCATION =  $f300
     10  1300					      LIST	ON
    861  1300
    862  1300					      IF	<. = 0
    863  1300		       00		      .byte.b	0	; required!
    864  1301					      ENDIF
    865  1301
    866  1301				   BLANKR
    867  1301		       00 00 00 00*	      .ds	DIGIT_H, 0
    868  1308
    869  1308				   DequalsR
    870  1308		       00		      .byte.b	%00000000
    871  1309		       00		      .byte.b	%00000000
    872  130a		       f0		      .byte.b	%11110000
    873  130b		       00		      .byte.b	%00000000
    874  130c		       f0		      .byte.b	%11110000
    875  130d		       00		      .byte.b	%00000000
    876  130e		       f0		      .byte.b	%11110000
    877  130f				   DplusR
    878  130f		       10		      .byte.b	%00010000
    879  1310		       28		      .byte.b	%00101000
    880  1311		       6c		      .byte.b	%01101100
    881  1312		       c6		      .byte.b	%11000110
    882  1313		       6c		      .byte.b	%01101100
    883  1314		       28		      .byte.b	%00101000
    884  1315		       10		      .byte.b	%00010000
    885  1316
    886  1316				   ClockR
    887  1316		       00		      .byte.b	%00000000
    888  1317		       48		      .byte.b	%01001000
    889  1318		       fc		      .byte.b	%11111100
    890  1319		       48		      .byte.b	%01001000
    891  131a		       48		      .byte.b	%01001000
    892  131b		       fc		      .byte.b	%11111100
    893  131c		       48		      .byte.b	%01001000
    894  131d				   NineR
    895  131d		       0f		      .byte.b	%00001111
    896  131e		       01		      .byte.b	%00000001
    897  131f		       01		      .byte.b	%00000001
    898  1320		       7f		      .byte.b	%01111111
    899  1321		       41		      .byte.b	%01000001
    900  1322		       41		      .byte.b	%01000001
    901  1323		       7f		      .byte.b	%01111111
    902  1324				   SixR
    903  1324		       7f		      .byte.b	%01111111
    904  1325		       41		      .byte.b	%01000001
    905  1326		       41		      .byte.b	%01000001
    906  1327		       7f		      .byte.b	%01111111
    907  1328		       40		      .byte.b	%01000000
    908  1329		       40		      .byte.b	%01000000
    909  132a		       78		      .byte.b	%01111000
    910  132b				   EightR
    911  132b							;  .byte %00111110
    912  132b							;  .byte %01000011
    913  132b							;  .byte %01000011
    914  132b							;  .byte %00111110
    915  132b							;  .byte %00100011
    916  132b							;  .byte %00100011
    917  132b							;  .byte %00011110
    918  132b
    919  132b
    920  132b		       7f		      .byte.b	%01111111
    921  132c		       41		      .byte.b	%01000001
    922  132d		       41		      .byte.b	%01000001
    923  132e		       7f		      .byte.b	%01111111
    924  132f		       41		      .byte.b	%01000001
    925  1330		       41		      .byte.b	%01000001
    926  1331		       7f		      .byte.b	%01111111
    927  1332
    928  1332				   ZeroR
    929  1332		       7f		      .byte.b	%01111111
    930  1333		       41		      .byte.b	%01000001
    931  1334		       41		      .byte.b	%01000001
    932  1335		       41		      .byte.b	%01000001
    933  1336		       41		      .byte.b	%01000001
    934  1337		       41		      .byte.b	%01000001
    935  1338		       7f		      .byte.b	%01111111
    936  1339
    937  1339							;	  .byte %00111110
    938  1339							;	  .byte %01000011
    939  1339							;	  .byte %01000011
    940  1339							;	  .byte %01000011
    941  1339							;	  .byte %01000011
    942  1339							;	  .byte %00100011
    943  1339							;	  .byte %00011110
    944  1339				   ThreeR
    945  1339		       7f		      .byte.b	%01111111
    946  133a		       01		      .byte.b	%00000001
    947  133b		       01		      .byte.b	%00000001
    948  133c		       0f		      .byte.b	%00001111
    949  133d		       01		      .byte.b	%00000001
    950  133e		       01		      .byte.b	%00000001
    951  133f		       7f		      .byte.b	%01111111
    952  1340				   OneR
    953  1340		       08		      .byte.b	%00001000
    954  1341		       08		      .byte.b	%00001000
    955  1342		       08		      .byte.b	%00001000
    956  1343		       08		      .byte.b	%00001000
    957  1344		       08		      .byte.b	%00001000
    958  1345		       08		      .byte.b	%00001000
    959  1346		       08		      .byte.b	%00001000
    960  1347
    961  1347				   SevenR
    962  1347		       08		      .byte.b	%00001000
    963  1348		       08		      .byte.b	%00001000
    964  1349		       08		      .byte.b	%00001000
    965  134a		       0f		      .byte.b	%00001111
    966  134b		       01		      .byte.b	%00000001
    967  134c		       01		      .byte.b	%00000001
    968  134d		       7f		      .byte.b	%01111111
    969  134e
    970  134e				   TwoR
    971  134e		       7f		      .byte.b	%01111111
    972  134f		       40		      .byte.b	%01000000
    973  1350		       40		      .byte.b	%01000000
    974  1351		       7f		      .byte.b	%01111111
    975  1352		       01		      .byte.b	%00000001
    976  1353		       01		      .byte.b	%00000001
    977  1354		       7f		      .byte.b	%01111111
    978  1355				   FiveR
    979  1355		       7f		      .byte.b	%01111111
    980  1356		       01		      .byte.b	%00000001
    981  1357		       01		      .byte.b	%00000001
    982  1358		       7f		      .byte.b	%01111111
    983  1359		       40		      .byte.b	%01000000
    984  135a		       40		      .byte.b	%01000000
    985  135b		       78		      .byte.b	%01111000
    986  135c				   FourR
    987  135c		       08		      .byte.b	%00001000
    988  135d		       08		      .byte.b	%00001000
    989  135e		       08		      .byte.b	%00001000
    990  135f		       7f		      .byte.b	%01111111
    991  1360		       48		      .byte.b	%01001000
    992  1361		       48		      .byte.b	%01001000
    993  1362		       48		      .byte.b	%01001000
    994  1363
    995  1363							;CharAL:
    996  1363							;    .byte %11100110
    997  1363							;    .byte %11100110
    998  1363							;    .byte %11111110
    999  1363							;    .byte %11100110
   1000  1363							;    .byte %11100110
   1001  1363							;    .byte %01111100
   1002  1363							;    .byte %00111000
   1003  1363							;CharEL:
   1004  1363							;    .byte %11111110
   1005  1363							;    .byte %11111110
   1006  1363							;    .byte %11100000
   1007  1363							;    .byte %11100000
   1008  1363							;    .byte %11111100
   1009  1363							;    .byte %11100000
   1010  1363							;    .byte %11111110
   1011  1363							;CharRL:
   1012  1363							;    .byte %11100110
   1013  1363							;    .byte %11100110
   1014  1363							;    .byte %11111100
   1015  1363							;    .byte %11111100
   1016  1363							;    .byte %11100110
   1017  1363							;    .byte %11100110
   1018  1363							;    .byte %11111100
   1019  1363							;CharVL:
   1020  1363							;    .byte %00111000
   1021  1363							;    .byte %01111100
   1022  1363							;    .byte %11100110
   1023  1363							;    .byte %11100110
   1024  1363							;    .byte %11100110
   1025  1363							;    .byte %11100110
   1026  1363							;    .byte %11100110
   1027  1363
      0  1363					      CHECKPAGE	BLANKR
      8  1363					      LIST	ON
   1029  1363
   1030  1363							;---------------------------------------------------------------------------
   1031  1363
      0  1363					      DEFINE_SUBROUTINE	GameInitialise
      1  1363		       00 02	   BANK_GameInitialise =	_CURRENT_BANK
      2  1363					      SUBROUTINE
      3  1363				   GameInitialise
   1033  1363
   1034  1363							; copy loaded SK high score into scoring RAM:
   1035  1363		       a2 02		      ldx	#3-1
   1036  1365				   .loopCopyHighScore
   1037  1365		       b5 dd		      lda	highScoreSK,x
   1038  1367		       c9 ff		      cmp	#$ff
   1039  1369		       f0 06		      beq	.noSaveKey
   1040  136b		       9d 98 f7 	      sta	HighScore+RAM_WRITE,x
   1041  136e		       ca		      dex
   1042  136f		       10 f4		      bpl	.loopCopyHighScore
   1043  1371				   .noSaveKey
   1044  1371
   1045  1371							; clear both players scores
   1046  1371		       a0 05		      ldy	#2*3-1
   1047  1373		       a9 00		      lda	#0
   1048  1375				   .loopClearScore
   1049  1375		       99 8e f7 	      sta	ScoreCurrent+RAM_WRITE,y
   1050  1378		       88		      dey
   1051  1379		       10 fa		      bpl	.loopClearScore
   1052  137b
   1053  137b							; copy levelX and level for other player and SaveKey:
   1054  137b		       a5 b4		      lda	levelX
   1055  137d		       8d 96 f7 	      sta	PlayerLevelX+RAM_WRITE
   1056  1380		       a5 e0		      lda	startingLevel
   1057  1382		       8d 91 f7 	      sta	StartLevelX+RAM_WRITE
   1058  1385		       a5 b5		      lda	level
   1059  1387		       8d 97 f7 	      sta	PlayerLevel+RAM_WRITE
   1060  138a		       8d 92 f7 	      sta	StartLevel+RAM_WRITE
   1061  138d		       60		      rts
   1062  138e
   1063  138e							;---------------------------------------------------------------------------
   1064  138e
   1065  138e		       00 00 00    ScoreCurrent ds	3, 0
   1066  1391							; start levelx and level have to be after ScoreCurrent!
   1067  1391		       00	   StartLevelX .byte.b	0
   1068  1392		       00	   StartLevel .byte.b	0
   1069  1393		       00 00 00    PlayerScores ds	3, 0
   1070  1396							; levelx and level have to be consecutive variables!
   1071  1396		       00	   PlayerLevelX .byte.b	0
   1072  1397		       00	   PlayerLevel .byte.b	0
   1073  1398		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
   1074  139d
   1075  139d
   1076  139d
   1077  139d							;------------------------------------------------------------------------------
   1078  139d
      0  139d					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  139d
      2  139d
      3  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $39d , FREE= $63
      4  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  139d				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  139d				  -	      ERR
      8  139d					      endif
   1080  139d
   1081  139d							;------------------------------------------------------------------------------
   1082  139d
   1083  139d							; LEVEL DATA banks can go anywhere - *EXCEPT* for the same bank as the level
   1084  139d							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_LEVEL_SIZE
   1085  139d							; which is used as a buffer size inside UnpackLevel.  It's not important if
   1086  139d							; this is defined before or after, as once the levels have processed it will be
   1087  139d							; correct. Note, that levels should all be defined BEFORE *OR* AFTER the
   1088  139d							; UnpackLevel code -- but that they should not be both, nor in the same bank.
   1089  139d							; TODO: verify above is still valid
   1090  139d
   1091  139d
      0  139d					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  139d		       03 9d	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $39d , FREE= $463
      2  139d					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  139d				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  139d				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  139d				  -	      ERR
      6  139d					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 4
      0  139d					      include	"BANK_GENERIC.asm"
      1  139d							;    Sokoboo - a Sokoban implementation
      2  139d							;    using a generic tile-based display engine for the Atari 2600
      3  139d							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  139d							;
      5  139d							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  139d							;
      7  139d							;    Code related to the generic tile-based display engine was developed by
      8  139d							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  139d							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  139d							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  139d							;
     12  139d							;    Code related to music and sound effects uses the TIATracker music player
     13  139d							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  139d							;    directory for Apache licensing details.
     15  139d							;
     16  139d							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  139d							;    See the copyright notices in the License directory for a list of level
     18  139d							;    contributors.
     19  139d							;
     20  139d							;    Except where otherwise indicated, this software is released under the
     21  139d							;    following licensing arrangement...
     22  139d							;
     23  139d							;    This program is free software: you can redistribute it and/or modify
     24  139d							;    it under the terms of the GNU General Public License as published by
     25  139d							;    the Free Software Foundation, either version 3 of the License, or
     26  139d							;    (at your option) any later version.
     27  139d							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  139d
     29  139d							;    This program is distributed in the hope that it will be useful,
     30  139d							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  139d							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  139d							;    GNU General Public License for more details.
     33  139d
     34  139d							;------------------------------------------------------------------------------
     35  139d							;##############################################################################
     36  139d							;------------------------------------------------------------------------------
     37  139d
      0  139d					      NEWBANK	GENERIC_BANK_1
      1  1f1e ????				      SEG	GENERIC_BANK_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	GENERIC_BANK_1
     39  1800
     40  1800
     41  1800
      0  1800					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  1800					      ALIGN	$400
      2  1800				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  1800				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
------- FILE DecodeLevel.asm LEVEL 3 PASS 4
      0  1800					      include	"DecodeLevel.asm"
      1  1800							;    Sokoboo - a Sokoban implementation
      2  1800							;    using a generic tile-based display engine for the Atari 2600
      3  1800							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1800							;
      5  1800							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1800							;
      7  1800							;    Code related to the generic tile-based display engine was developed by
      8  1800							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1800							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1800							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1800							;
     12  1800							;    Code related to music and sound effects uses the TIATracker music player
     13  1800							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1800							;    directory for Apache licensing details.
     15  1800							;
     16  1800							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1800							;    See the copyright notices in the License directory for a list of level
     18  1800							;    contributors.
     19  1800							;
     20  1800							;    Except where otherwise indicated, this software is released under the
     21  1800							;    following licensing arrangement...
     22  1800							;
     23  1800							;    This program is free software: you can redistribute it and/or modify
     24  1800							;    it under the terms of the GNU General Public License as published by
     25  1800							;    the Free Software Foundation, either version 3 of the License, or
     26  1800							;    (at your option) any later version.
     27  1800							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1800
     29  1800							;    This program is distributed in the hope that it will be useful,
     30  1800							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1800							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1800							;    GNU General Public License for more details.
     33  1800
     34  1800				   LEVELNUM   SET	0
     35  1800				   NUMBEROFLEVELS SET	0
     36  1800		       00 03	   LEVEL_DEFINITION_SIZE =	3
     37  1800
     38  1800					      MAC	add_level
     39  1800				   LEVEL_ACTIVE_{1} SET	1
     40  1800				   LEVEL_NAMED_{1} =	LEVELNUM
     41  1800					      .byte	<LEVEL_{1}
     42  1800					      .byte	>LEVEL_{1}
     43  1800					      .byte	BANK_LEVEL_{1}
     44  1800							;.byte LEVEL_SIZE_{1}
     45  1800				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
     46  1800				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     47  1800					      ENDM		; {name}
     48  1800
     49  1800				   LevelInformation
     50  1800
     51  1800							; The ordering here corresponds to the ordering when playing...
     52  1800
      0  1800					      ADD_LEVEL	_001_L
      1  1800				   LEVEL_ACTIVE__001_L SET	1
      2  1800		       00 00	   LEVEL_NAMED__001_L =	LEVELNUM
      3  1800		       00		      .byte.b	<LEVEL__001_L
      4  1801		       f0		      .byte.b	>LEVEL__001_L
      5  1802		       04		      .byte.b	BANK_LEVEL__001_L
      6  1803
      7  1803				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1803				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1803					      ADD_LEVEL	_001_R
      1  1803				   LEVEL_ACTIVE__001_R SET	1
      2  1803		       00 03	   LEVEL_NAMED__001_R =	LEVELNUM
      3  1803		       13		      .byte.b	<LEVEL__001_R
      4  1804		       f0		      .byte.b	>LEVEL__001_R
      5  1805		       04		      .byte.b	BANK_LEVEL__001_R
      6  1806
      7  1806				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1806				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1806					      ADD_LEVEL	_002_L
      1  1806				   LEVEL_ACTIVE__002_L SET	1
      2  1806		       00 06	   LEVEL_NAMED__002_L =	LEVELNUM
      3  1806		       20		      .byte.b	<LEVEL__002_L
      4  1807		       f0		      .byte.b	>LEVEL__002_L
      5  1808		       04		      .byte.b	BANK_LEVEL__002_L
      6  1809
      7  1809				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1809				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1809					      ADD_LEVEL	_002_R
      1  1809				   LEVEL_ACTIVE__002_R SET	1
      2  1809		       00 09	   LEVEL_NAMED__002_R =	LEVELNUM
      3  1809		       3a		      .byte.b	<LEVEL__002_R
      4  180a		       f0		      .byte.b	>LEVEL__002_R
      5  180b		       04		      .byte.b	BANK_LEVEL__002_R
      6  180c
      7  180c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  180c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  180c					      ADD_LEVEL	_003_L
      1  180c				   LEVEL_ACTIVE__003_L SET	1
      2  180c		       00 0c	   LEVEL_NAMED__003_L =	LEVELNUM
      3  180c		       63		      .byte.b	<LEVEL__003_L
      4  180d		       f0		      .byte.b	>LEVEL__003_L
      5  180e		       04		      .byte.b	BANK_LEVEL__003_L
      6  180f
      7  180f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  180f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  180f					      ADD_LEVEL	_003_R
      1  180f				   LEVEL_ACTIVE__003_R SET	1
      2  180f		       00 0f	   LEVEL_NAMED__003_R =	LEVELNUM
      3  180f		       90		      .byte.b	<LEVEL__003_R
      4  1810		       f0		      .byte.b	>LEVEL__003_R
      5  1811		       04		      .byte.b	BANK_LEVEL__003_R
      6  1812
      7  1812				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1812				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1812					      ADD_LEVEL	_004_L
      1  1812				   LEVEL_ACTIVE__004_L SET	1
      2  1812		       00 12	   LEVEL_NAMED__004_L =	LEVELNUM
      3  1812		       bb		      .byte.b	<LEVEL__004_L
      4  1813		       f0		      .byte.b	>LEVEL__004_L
      5  1814		       04		      .byte.b	BANK_LEVEL__004_L
      6  1815
      7  1815				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1815				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1815					      ADD_LEVEL	_004_R
      1  1815				   LEVEL_ACTIVE__004_R SET	1
      2  1815		       00 15	   LEVEL_NAMED__004_R =	LEVELNUM
      3  1815		       df		      .byte.b	<LEVEL__004_R
      4  1816		       f0		      .byte.b	>LEVEL__004_R
      5  1817		       04		      .byte.b	BANK_LEVEL__004_R
      6  1818
      7  1818				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1818				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1818					      ADD_LEVEL	_005_L
      1  1818				   LEVEL_ACTIVE__005_L SET	1
      2  1818		       00 18	   LEVEL_NAMED__005_L =	LEVELNUM
      3  1818		       fc		      .byte.b	<LEVEL__005_L
      4  1819		       f0		      .byte.b	>LEVEL__005_L
      5  181a		       04		      .byte.b	BANK_LEVEL__005_L
      6  181b
      7  181b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  181b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  181b					      ADD_LEVEL	_005_R
      1  181b				   LEVEL_ACTIVE__005_R SET	1
      2  181b		       00 1b	   LEVEL_NAMED__005_R =	LEVELNUM
      3  181b		       2f		      .byte.b	<LEVEL__005_R
      4  181c		       f1		      .byte.b	>LEVEL__005_R
      5  181d		       04		      .byte.b	BANK_LEVEL__005_R
      6  181e
      7  181e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  181e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  181e					      ADD_LEVEL	_006_L
      1  181e				   LEVEL_ACTIVE__006_L SET	1
      2  181e		       00 1e	   LEVEL_NAMED__006_L =	LEVELNUM
      3  181e		       6f		      .byte.b	<LEVEL__006_L
      4  181f		       f1		      .byte.b	>LEVEL__006_L
      5  1820		       04		      .byte.b	BANK_LEVEL__006_L
      6  1821
      7  1821				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1821				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1821					      ADD_LEVEL	_006_R
      1  1821				   LEVEL_ACTIVE__006_R SET	1
      2  1821		       00 21	   LEVEL_NAMED__006_R =	LEVELNUM
      3  1821		       ab		      .byte.b	<LEVEL__006_R
      4  1822		       f1		      .byte.b	>LEVEL__006_R
      5  1823		       04		      .byte.b	BANK_LEVEL__006_R
      6  1824
      7  1824				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1824				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1824					      ADD_LEVEL	_007_L
      1  1824				   LEVEL_ACTIVE__007_L SET	1
      2  1824		       00 24	   LEVEL_NAMED__007_L =	LEVELNUM
      3  1824		       ea		      .byte.b	<LEVEL__007_L
      4  1825		       f1		      .byte.b	>LEVEL__007_L
      5  1826		       04		      .byte.b	BANK_LEVEL__007_L
      6  1827
      7  1827				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1827				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1827					      ADD_LEVEL	_007_R
      1  1827				   LEVEL_ACTIVE__007_R SET	1
      2  1827		       00 27	   LEVEL_NAMED__007_R =	LEVELNUM
      3  1827		       18		      .byte.b	<LEVEL__007_R
      4  1828		       f2		      .byte.b	>LEVEL__007_R
      5  1829		       04		      .byte.b	BANK_LEVEL__007_R
      6  182a
      7  182a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  182a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  182a					      ADD_LEVEL	_008_L
      1  182a				   LEVEL_ACTIVE__008_L SET	1
      2  182a		       00 2a	   LEVEL_NAMED__008_L =	LEVELNUM
      3  182a		       4c		      .byte.b	<LEVEL__008_L
      4  182b		       f2		      .byte.b	>LEVEL__008_L
      5  182c		       04		      .byte.b	BANK_LEVEL__008_L
      6  182d
      7  182d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  182d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  182d					      ADD_LEVEL	_008_R
      1  182d				   LEVEL_ACTIVE__008_R SET	1
      2  182d		       00 2d	   LEVEL_NAMED__008_R =	LEVELNUM
      3  182d		       83		      .byte.b	<LEVEL__008_R
      4  182e		       f2		      .byte.b	>LEVEL__008_R
      5  182f		       04		      .byte.b	BANK_LEVEL__008_R
      6  1830
      7  1830				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1830				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1830					      ADD_LEVEL	_009_L
      1  1830				   LEVEL_ACTIVE__009_L SET	1
      2  1830		       00 30	   LEVEL_NAMED__009_L =	LEVELNUM
      3  1830		       b5		      .byte.b	<LEVEL__009_L
      4  1831		       f2		      .byte.b	>LEVEL__009_L
      5  1832		       04		      .byte.b	BANK_LEVEL__009_L
      6  1833
      7  1833				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1833				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1833					      ADD_LEVEL	_009_R
      1  1833				   LEVEL_ACTIVE__009_R SET	1
      2  1833		       00 33	   LEVEL_NAMED__009_R =	LEVELNUM
      3  1833		       e8		      .byte.b	<LEVEL__009_R
      4  1834		       f2		      .byte.b	>LEVEL__009_R
      5  1835		       04		      .byte.b	BANK_LEVEL__009_R
      6  1836
      7  1836				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1836				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1836					      ADD_LEVEL	_010_L
      1  1836				   LEVEL_ACTIVE__010_L SET	1
      2  1836		       00 36	   LEVEL_NAMED__010_L =	LEVELNUM
      3  1836		       19		      .byte.b	<LEVEL__010_L
      4  1837		       f3		      .byte.b	>LEVEL__010_L
      5  1838		       04		      .byte.b	BANK_LEVEL__010_L
      6  1839
      7  1839				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1839				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1839					      ADD_LEVEL	_010_R
      1  1839				   LEVEL_ACTIVE__010_R SET	1
      2  1839		       00 39	   LEVEL_NAMED__010_R =	LEVELNUM
      3  1839		       54		      .byte.b	<LEVEL__010_R
      4  183a		       f3		      .byte.b	>LEVEL__010_R
      5  183b		       04		      .byte.b	BANK_LEVEL__010_R
      6  183c
      7  183c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  183c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  183c					      ADD_LEVEL	_011_L
      1  183c				   LEVEL_ACTIVE__011_L SET	1
      2  183c		       00 3c	   LEVEL_NAMED__011_L =	LEVELNUM
      3  183c		       88		      .byte.b	<LEVEL__011_L
      4  183d		       f3		      .byte.b	>LEVEL__011_L
      5  183e		       04		      .byte.b	BANK_LEVEL__011_L
      6  183f
      7  183f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  183f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  183f					      ADD_LEVEL	_011_R
      1  183f				   LEVEL_ACTIVE__011_R SET	1
      2  183f		       00 3f	   LEVEL_NAMED__011_R =	LEVELNUM
      3  183f		       bc		      .byte.b	<LEVEL__011_R
      4  1840		       f3		      .byte.b	>LEVEL__011_R
      5  1841		       04		      .byte.b	BANK_LEVEL__011_R
      6  1842
      7  1842				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1842				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1842					      ADD_LEVEL	_012_L
      1  1842				   LEVEL_ACTIVE__012_L SET	1
      2  1842		       00 42	   LEVEL_NAMED__012_L =	LEVELNUM
      3  1842		       f7		      .byte.b	<LEVEL__012_L
      4  1843		       f3		      .byte.b	>LEVEL__012_L
      5  1844		       04		      .byte.b	BANK_LEVEL__012_L
      6  1845
      7  1845				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1845				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1845					      ADD_LEVEL	_012_R
      1  1845				   LEVEL_ACTIVE__012_R SET	1
      2  1845		       00 45	   LEVEL_NAMED__012_R =	LEVELNUM
      3  1845		       28		      .byte.b	<LEVEL__012_R
      4  1846		       f4		      .byte.b	>LEVEL__012_R
      5  1847		       04		      .byte.b	BANK_LEVEL__012_R
      6  1848
      7  1848				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1848				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1848					      ADD_LEVEL	_013_L
      1  1848				   LEVEL_ACTIVE__013_L SET	1
      2  1848		       00 48	   LEVEL_NAMED__013_L =	LEVELNUM
      3  1848		       65		      .byte.b	<LEVEL__013_L
      4  1849		       f4		      .byte.b	>LEVEL__013_L
      5  184a		       04		      .byte.b	BANK_LEVEL__013_L
      6  184b
      7  184b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  184b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  184b					      ADD_LEVEL	_013_R
      1  184b				   LEVEL_ACTIVE__013_R SET	1
      2  184b		       00 4b	   LEVEL_NAMED__013_R =	LEVELNUM
      3  184b		       a5		      .byte.b	<LEVEL__013_R
      4  184c		       f4		      .byte.b	>LEVEL__013_R
      5  184d		       04		      .byte.b	BANK_LEVEL__013_R
      6  184e
      7  184e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  184e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  184e					      ADD_LEVEL	_014_L
      1  184e				   LEVEL_ACTIVE__014_L SET	1
      2  184e		       00 4e	   LEVEL_NAMED__014_L =	LEVELNUM
      3  184e		       d9		      .byte.b	<LEVEL__014_L
      4  184f		       f4		      .byte.b	>LEVEL__014_L
      5  1850		       04		      .byte.b	BANK_LEVEL__014_L
      6  1851
      7  1851				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1851				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1851					      ADD_LEVEL	_014_R
      1  1851				   LEVEL_ACTIVE__014_R SET	1
      2  1851		       00 51	   LEVEL_NAMED__014_R =	LEVELNUM
      3  1851		       1d		      .byte.b	<LEVEL__014_R
      4  1852		       f5		      .byte.b	>LEVEL__014_R
      5  1853		       04		      .byte.b	BANK_LEVEL__014_R
      6  1854
      7  1854				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1854				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1854					      ADD_LEVEL	_015_L
      1  1854				   LEVEL_ACTIVE__015_L SET	1
      2  1854		       00 54	   LEVEL_NAMED__015_L =	LEVELNUM
      3  1854		       61		      .byte.b	<LEVEL__015_L
      4  1855		       f5		      .byte.b	>LEVEL__015_L
      5  1856		       04		      .byte.b	BANK_LEVEL__015_L
      6  1857
      7  1857				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1857				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1857					      ADD_LEVEL	_015_R
      1  1857				   LEVEL_ACTIVE__015_R SET	1
      2  1857		       00 57	   LEVEL_NAMED__015_R =	LEVELNUM
      3  1857		       97		      .byte.b	<LEVEL__015_R
      4  1858		       f5		      .byte.b	>LEVEL__015_R
      5  1859		       04		      .byte.b	BANK_LEVEL__015_R
      6  185a
      7  185a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  185a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  185a					      ADD_LEVEL	_016_L
      1  185a				   LEVEL_ACTIVE__016_L SET	1
      2  185a		       00 5a	   LEVEL_NAMED__016_L =	LEVELNUM
      3  185a		       dd		      .byte.b	<LEVEL__016_L
      4  185b		       f5		      .byte.b	>LEVEL__016_L
      5  185c		       04		      .byte.b	BANK_LEVEL__016_L
      6  185d
      7  185d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  185d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  185d					      ADD_LEVEL	_016_R
      1  185d				   LEVEL_ACTIVE__016_R SET	1
      2  185d		       00 5d	   LEVEL_NAMED__016_R =	LEVELNUM
      3  185d		       15		      .byte.b	<LEVEL__016_R
      4  185e		       f6		      .byte.b	>LEVEL__016_R
      5  185f		       04		      .byte.b	BANK_LEVEL__016_R
      6  1860
      7  1860				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1860				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1860					      ADD_LEVEL	_017_L
      1  1860				   LEVEL_ACTIVE__017_L SET	1
      2  1860		       00 60	   LEVEL_NAMED__017_L =	LEVELNUM
      3  1860		       49		      .byte.b	<LEVEL__017_L
      4  1861		       f6		      .byte.b	>LEVEL__017_L
      5  1862		       04		      .byte.b	BANK_LEVEL__017_L
      6  1863
      7  1863				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1863				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1863					      ADD_LEVEL	_017_R
      1  1863				   LEVEL_ACTIVE__017_R SET	1
      2  1863		       00 63	   LEVEL_NAMED__017_R =	LEVELNUM
      3  1863		       94		      .byte.b	<LEVEL__017_R
      4  1864		       f6		      .byte.b	>LEVEL__017_R
      5  1865		       04		      .byte.b	BANK_LEVEL__017_R
      6  1866
      7  1866				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1866				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1866					      ADD_LEVEL	_018_L
      1  1866				   LEVEL_ACTIVE__018_L SET	1
      2  1866		       00 66	   LEVEL_NAMED__018_L =	LEVELNUM
      3  1866		       d8		      .byte.b	<LEVEL__018_L
      4  1867		       f6		      .byte.b	>LEVEL__018_L
      5  1868		       04		      .byte.b	BANK_LEVEL__018_L
      6  1869
      7  1869				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1869				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1869					      ADD_LEVEL	_018_R
      1  1869				   LEVEL_ACTIVE__018_R SET	1
      2  1869		       00 69	   LEVEL_NAMED__018_R =	LEVELNUM
      3  1869		       0d		      .byte.b	<LEVEL__018_R
      4  186a		       f7		      .byte.b	>LEVEL__018_R
      5  186b		       04		      .byte.b	BANK_LEVEL__018_R
      6  186c
      7  186c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  186c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  186c					      ADD_LEVEL	_019_L
      1  186c				   LEVEL_ACTIVE__019_L SET	1
      2  186c		       00 6c	   LEVEL_NAMED__019_L =	LEVELNUM
      3  186c		       4a		      .byte.b	<LEVEL__019_L
      4  186d		       f7		      .byte.b	>LEVEL__019_L
      5  186e		       04		      .byte.b	BANK_LEVEL__019_L
      6  186f
      7  186f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  186f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  186f					      ADD_LEVEL	_019_R
      1  186f				   LEVEL_ACTIVE__019_R SET	1
      2  186f		       00 6f	   LEVEL_NAMED__019_R =	LEVELNUM
      3  186f		       86		      .byte.b	<LEVEL__019_R
      4  1870		       f7		      .byte.b	>LEVEL__019_R
      5  1871		       04		      .byte.b	BANK_LEVEL__019_R
      6  1872
      7  1872				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1872				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1872					      ADD_LEVEL	_020_L
      1  1872				   LEVEL_ACTIVE__020_L SET	1
      2  1872		       00 72	   LEVEL_NAMED__020_L =	LEVELNUM
      3  1872		       00		      .byte.b	<LEVEL__020_L
      4  1873		       f0		      .byte.b	>LEVEL__020_L
      5  1874		       05		      .byte.b	BANK_LEVEL__020_L
      6  1875
      7  1875				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1875				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1875					      ADD_LEVEL	_020_R
      1  1875				   LEVEL_ACTIVE__020_R SET	1
      2  1875		       00 75	   LEVEL_NAMED__020_R =	LEVELNUM
      3  1875		       40		      .byte.b	<LEVEL__020_R
      4  1876		       f0		      .byte.b	>LEVEL__020_R
      5  1877		       05		      .byte.b	BANK_LEVEL__020_R
      6  1878
      7  1878				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1878				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1878					      ADD_LEVEL	_021_L
      1  1878				   LEVEL_ACTIVE__021_L SET	1
      2  1878		       00 78	   LEVEL_NAMED__021_L =	LEVELNUM
      3  1878		       81		      .byte.b	<LEVEL__021_L
      4  1879		       f0		      .byte.b	>LEVEL__021_L
      5  187a		       05		      .byte.b	BANK_LEVEL__021_L
      6  187b
      7  187b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  187b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  187b					      ADD_LEVEL	_021_R
      1  187b				   LEVEL_ACTIVE__021_R SET	1
      2  187b		       00 7b	   LEVEL_NAMED__021_R =	LEVELNUM
      3  187b		       d8		      .byte.b	<LEVEL__021_R
      4  187c		       f0		      .byte.b	>LEVEL__021_R
      5  187d		       05		      .byte.b	BANK_LEVEL__021_R
      6  187e
      7  187e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  187e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  187e					      ADD_LEVEL	_022_L
      1  187e				   LEVEL_ACTIVE__022_L SET	1
      2  187e		       00 7e	   LEVEL_NAMED__022_L =	LEVELNUM
      3  187e		       0d		      .byte.b	<LEVEL__022_L
      4  187f		       f1		      .byte.b	>LEVEL__022_L
      5  1880		       05		      .byte.b	BANK_LEVEL__022_L
      6  1881
      7  1881				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1881				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1881					      ADD_LEVEL	_022_R
      1  1881				   LEVEL_ACTIVE__022_R SET	1
      2  1881		       00 81	   LEVEL_NAMED__022_R =	LEVELNUM
      3  1881		       54		      .byte.b	<LEVEL__022_R
      4  1882		       f1		      .byte.b	>LEVEL__022_R
      5  1883		       05		      .byte.b	BANK_LEVEL__022_R
      6  1884
      7  1884				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1884				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1884					      ADD_LEVEL	_023_L
      1  1884				   LEVEL_ACTIVE__023_L SET	1
      2  1884		       00 84	   LEVEL_NAMED__023_L =	LEVELNUM
      3  1884		       91		      .byte.b	<LEVEL__023_L
      4  1885		       f1		      .byte.b	>LEVEL__023_L
      5  1886		       05		      .byte.b	BANK_LEVEL__023_L
      6  1887
      7  1887				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1887				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1887					      ADD_LEVEL	_023_R
      1  1887				   LEVEL_ACTIVE__023_R SET	1
      2  1887		       00 87	   LEVEL_NAMED__023_R =	LEVELNUM
      3  1887		       d3		      .byte.b	<LEVEL__023_R
      4  1888		       f1		      .byte.b	>LEVEL__023_R
      5  1889		       05		      .byte.b	BANK_LEVEL__023_R
      6  188a
      7  188a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  188a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     99  188a
      0  188a					      ADD_LEVEL	_050_L
      1  188a				   LEVEL_ACTIVE__050_L SET	1
      2  188a		       00 8a	   LEVEL_NAMED__050_L =	LEVELNUM
      3  188a		       16		      .byte.b	<LEVEL__050_L
      4  188b		       f2		      .byte.b	>LEVEL__050_L
      5  188c		       05		      .byte.b	BANK_LEVEL__050_L
      6  188d
      7  188d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  188d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  188d					      ADD_LEVEL	_050_R
      1  188d				   LEVEL_ACTIVE__050_R SET	1
      2  188d		       00 8d	   LEVEL_NAMED__050_R =	LEVELNUM
      3  188d		       64		      .byte.b	<LEVEL__050_R
      4  188e		       f2		      .byte.b	>LEVEL__050_R
      5  188f		       05		      .byte.b	BANK_LEVEL__050_R
      6  1890
      7  1890				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1890				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1890					      ADD_LEVEL	_051_L
      1  1890				   LEVEL_ACTIVE__051_L SET	1
      2  1890		       00 90	   LEVEL_NAMED__051_L =	LEVELNUM
      3  1890		       9e		      .byte.b	<LEVEL__051_L
      4  1891		       f2		      .byte.b	>LEVEL__051_L
      5  1892		       05		      .byte.b	BANK_LEVEL__051_L
      6  1893
      7  1893				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1893				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1893					      ADD_LEVEL	_051_R
      1  1893				   LEVEL_ACTIVE__051_R SET	1
      2  1893		       00 93	   LEVEL_NAMED__051_R =	LEVELNUM
      3  1893		       f2		      .byte.b	<LEVEL__051_R
      4  1894		       f2		      .byte.b	>LEVEL__051_R
      5  1895		       05		      .byte.b	BANK_LEVEL__051_R
      6  1896
      7  1896				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1896				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1896					      ADD_LEVEL	_052_L
      1  1896				   LEVEL_ACTIVE__052_L SET	1
      2  1896		       00 96	   LEVEL_NAMED__052_L =	LEVELNUM
      3  1896		       44		      .byte.b	<LEVEL__052_L
      4  1897		       f3		      .byte.b	>LEVEL__052_L
      5  1898		       05		      .byte.b	BANK_LEVEL__052_L
      6  1899
      7  1899				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1899				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1899					      ADD_LEVEL	_052_R
      1  1899				   LEVEL_ACTIVE__052_R SET	1
      2  1899		       00 99	   LEVEL_NAMED__052_R =	LEVELNUM
      3  1899		       7f		      .byte.b	<LEVEL__052_R
      4  189a		       f3		      .byte.b	>LEVEL__052_R
      5  189b		       05		      .byte.b	BANK_LEVEL__052_R
      6  189c
      7  189c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  189c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  189c					      ADD_LEVEL	_053_L
      1  189c				   LEVEL_ACTIVE__053_L SET	1
      2  189c		       00 9c	   LEVEL_NAMED__053_L =	LEVELNUM
      3  189c		       c8		      .byte.b	<LEVEL__053_L
      4  189d		       f3		      .byte.b	>LEVEL__053_L
      5  189e		       05		      .byte.b	BANK_LEVEL__053_L
      6  189f
      7  189f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  189f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  189f					      ADD_LEVEL	_053_R
      1  189f				   LEVEL_ACTIVE__053_R SET	1
      2  189f		       00 9f	   LEVEL_NAMED__053_R =	LEVELNUM
      3  189f		       1e		      .byte.b	<LEVEL__053_R
      4  18a0		       f4		      .byte.b	>LEVEL__053_R
      5  18a1		       05		      .byte.b	BANK_LEVEL__053_R
      6  18a2
      7  18a2				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a2				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a2					      ADD_LEVEL	_054_L
      1  18a2				   LEVEL_ACTIVE__054_L SET	1
      2  18a2		       00 a2	   LEVEL_NAMED__054_L =	LEVELNUM
      3  18a2		       6c		      .byte.b	<LEVEL__054_L
      4  18a3		       f4		      .byte.b	>LEVEL__054_L
      5  18a4		       05		      .byte.b	BANK_LEVEL__054_L
      6  18a5
      7  18a5				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a5				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a5					      ADD_LEVEL	_054_R
      1  18a5				   LEVEL_ACTIVE__054_R SET	1
      2  18a5		       00 a5	   LEVEL_NAMED__054_R =	LEVELNUM
      3  18a5		       b9		      .byte.b	<LEVEL__054_R
      4  18a6		       f4		      .byte.b	>LEVEL__054_R
      5  18a7		       05		      .byte.b	BANK_LEVEL__054_R
      6  18a8
      7  18a8				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a8				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a8					      ADD_LEVEL	_055_L
      1  18a8				   LEVEL_ACTIVE__055_L SET	1
      2  18a8		       00 a8	   LEVEL_NAMED__055_L =	LEVELNUM
      3  18a8		       03		      .byte.b	<LEVEL__055_L
      4  18a9		       f5		      .byte.b	>LEVEL__055_L
      5  18aa		       05		      .byte.b	BANK_LEVEL__055_L
      6  18ab
      7  18ab				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ab				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ab					      ADD_LEVEL	_055_R
      1  18ab				   LEVEL_ACTIVE__055_R SET	1
      2  18ab		       00 ab	   LEVEL_NAMED__055_R =	LEVELNUM
      3  18ab		       5e		      .byte.b	<LEVEL__055_R
      4  18ac		       f5		      .byte.b	>LEVEL__055_R
      5  18ad		       05		      .byte.b	BANK_LEVEL__055_R
      6  18ae
      7  18ae				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ae				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ae					      ADD_LEVEL	_056_L
      1  18ae				   LEVEL_ACTIVE__056_L SET	1
      2  18ae		       00 ae	   LEVEL_NAMED__056_L =	LEVELNUM
      3  18ae		       b4		      .byte.b	<LEVEL__056_L
      4  18af		       f5		      .byte.b	>LEVEL__056_L
      5  18b0		       05		      .byte.b	BANK_LEVEL__056_L
      6  18b1
      7  18b1				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b1				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18b1					      ADD_LEVEL	_056_R
      1  18b1				   LEVEL_ACTIVE__056_R SET	1
      2  18b1		       00 b1	   LEVEL_NAMED__056_R =	LEVELNUM
      3  18b1		       0f		      .byte.b	<LEVEL__056_R
      4  18b2		       f6		      .byte.b	>LEVEL__056_R
      5  18b3		       05		      .byte.b	BANK_LEVEL__056_R
      6  18b4
      7  18b4				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b4				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18b4					      ADD_LEVEL	_057_L
      1  18b4				   LEVEL_ACTIVE__057_L SET	1
      2  18b4		       00 b4	   LEVEL_NAMED__057_L =	LEVELNUM
      3  18b4		       6b		      .byte.b	<LEVEL__057_L
      4  18b5		       f6		      .byte.b	>LEVEL__057_L
      5  18b6		       05		      .byte.b	BANK_LEVEL__057_L
      6  18b7
      7  18b7				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b7				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    115  18b7
      0  18b7					      ADD_LEVEL	_060_R
      1  18b7				   LEVEL_ACTIVE__060_R SET	1
      2  18b7		       00 b7	   LEVEL_NAMED__060_R =	LEVELNUM
      3  18b7		       00		      .byte.b	<LEVEL__060_R
      4  18b8		       f0		      .byte.b	>LEVEL__060_R
      5  18b9		       06		      .byte.b	BANK_LEVEL__060_R
      6  18ba
      7  18ba				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ba				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ba					      ADD_LEVEL	_061_R
      1  18ba				   LEVEL_ACTIVE__061_R SET	1
      2  18ba		       00 ba	   LEVEL_NAMED__061_R =	LEVELNUM
      3  18ba		       9e		      .byte.b	<LEVEL__061_R
      4  18bb		       f0		      .byte.b	>LEVEL__061_R
      5  18bc		       06		      .byte.b	BANK_LEVEL__061_R
      6  18bd
      7  18bd				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18bd				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18bd					      ADD_LEVEL	_061_L
      1  18bd				   LEVEL_ACTIVE__061_L SET	1
      2  18bd		       00 bd	   LEVEL_NAMED__061_L =	LEVELNUM
      3  18bd		       49		      .byte.b	<LEVEL__061_L
      4  18be		       f0		      .byte.b	>LEVEL__061_L
      5  18bf		       06		      .byte.b	BANK_LEVEL__061_L
      6  18c0
      7  18c0				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c0				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c0					      ADD_LEVEL	_062_L
      1  18c0				   LEVEL_ACTIVE__062_L SET	1
      2  18c0		       00 c0	   LEVEL_NAMED__062_L =	LEVELNUM
      3  18c0		       e8		      .byte.b	<LEVEL__062_L
      4  18c1		       f0		      .byte.b	>LEVEL__062_L
      5  18c2		       06		      .byte.b	BANK_LEVEL__062_L
      6  18c3
      7  18c3				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c3				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c3					      ADD_LEVEL	_062_R
      1  18c3				   LEVEL_ACTIVE__062_R SET	1
      2  18c3		       00 c3	   LEVEL_NAMED__062_R =	LEVELNUM
      3  18c3		       40		      .byte.b	<LEVEL__062_R
      4  18c4		       f1		      .byte.b	>LEVEL__062_R
      5  18c5		       06		      .byte.b	BANK_LEVEL__062_R
      6  18c6
      7  18c6				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c6				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c6					      ADD_LEVEL	_063_L
      1  18c6				   LEVEL_ACTIVE__063_L SET	1
      2  18c6		       00 c6	   LEVEL_NAMED__063_L =	LEVELNUM
      3  18c6		       8d		      .byte.b	<LEVEL__063_L
      4  18c7		       f1		      .byte.b	>LEVEL__063_L
      5  18c8		       06		      .byte.b	BANK_LEVEL__063_L
      6  18c9
      7  18c9				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c9				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c9					      ADD_LEVEL	_063_R
      1  18c9				   LEVEL_ACTIVE__063_R SET	1
      2  18c9		       00 c9	   LEVEL_NAMED__063_R =	LEVELNUM
      3  18c9		       de		      .byte.b	<LEVEL__063_R
      4  18ca		       f1		      .byte.b	>LEVEL__063_R
      5  18cb		       06		      .byte.b	BANK_LEVEL__063_R
      6  18cc
      7  18cc				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18cc				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18cc					      ADD_LEVEL	_064_R
      1  18cc				   LEVEL_ACTIVE__064_R SET	1
      2  18cc		       00 cc	   LEVEL_NAMED__064_R =	LEVELNUM
      3  18cc		       8d		      .byte.b	<LEVEL__064_R
      4  18cd		       f2		      .byte.b	>LEVEL__064_R
      5  18ce		       06		      .byte.b	BANK_LEVEL__064_R
      6  18cf
      7  18cf				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18cf				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18cf					      ADD_LEVEL	_064_L
      1  18cf				   LEVEL_ACTIVE__064_L SET	1
      2  18cf		       00 cf	   LEVEL_NAMED__064_L =	LEVELNUM
      3  18cf		       31		      .byte.b	<LEVEL__064_L
      4  18d0		       f2		      .byte.b	>LEVEL__064_L
      5  18d1		       06		      .byte.b	BANK_LEVEL__064_L
      6  18d2
      7  18d2				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18d2				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18d2					      ADD_LEVEL	_065_R
      1  18d2				   LEVEL_ACTIVE__065_R SET	1
      2  18d2		       00 d2	   LEVEL_NAMED__065_R =	LEVELNUM
      3  18d2		       33		      .byte.b	<LEVEL__065_R
      4  18d3		       f3		      .byte.b	>LEVEL__065_R
      5  18d4		       06		      .byte.b	BANK_LEVEL__065_R
      6  18d5
      7  18d5				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18d5				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18d5					      ADD_LEVEL	_065_L
      1  18d5				   LEVEL_ACTIVE__065_L SET	1
      2  18d5		       00 d5	   LEVEL_NAMED__065_L =	LEVELNUM
      3  18d5		       da		      .byte.b	<LEVEL__065_L
      4  18d6		       f2		      .byte.b	>LEVEL__065_L
      5  18d7		       06		      .byte.b	BANK_LEVEL__065_L
      6  18d8
      7  18d8				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18d8				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18d8					      ADD_LEVEL	_066_R
      1  18d8				   LEVEL_ACTIVE__066_R SET	1
      2  18d8		       00 d8	   LEVEL_NAMED__066_R =	LEVELNUM
      3  18d8		       d7		      .byte.b	<LEVEL__066_R
      4  18d9		       f3		      .byte.b	>LEVEL__066_R
      5  18da		       06		      .byte.b	BANK_LEVEL__066_R
      6  18db
      7  18db				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18db				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18db					      ADD_LEVEL	_066_L
      1  18db				   LEVEL_ACTIVE__066_L SET	1
      2  18db		       00 db	   LEVEL_NAMED__066_L =	LEVELNUM
      3  18db		       7c		      .byte.b	<LEVEL__066_L
      4  18dc		       f3		      .byte.b	>LEVEL__066_L
      5  18dd		       06		      .byte.b	BANK_LEVEL__066_L
      6  18de
      7  18de				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18de				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18de					      ADD_LEVEL	_067_R
      1  18de				   LEVEL_ACTIVE__067_R SET	1
      2  18de		       00 de	   LEVEL_NAMED__067_R =	LEVELNUM
      3  18de		       7c		      .byte.b	<LEVEL__067_R
      4  18df		       f4		      .byte.b	>LEVEL__067_R
      5  18e0		       06		      .byte.b	BANK_LEVEL__067_R
      6  18e1
      7  18e1				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18e1				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18e1					      ADD_LEVEL	_067_L
      1  18e1				   LEVEL_ACTIVE__067_L SET	1
      2  18e1		       00 e1	   LEVEL_NAMED__067_L =	LEVELNUM
      3  18e1		       2e		      .byte.b	<LEVEL__067_L
      4  18e2		       f4		      .byte.b	>LEVEL__067_L
      5  18e3		       06		      .byte.b	BANK_LEVEL__067_L
      6  18e4
      7  18e4				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18e4				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18e4					      ADD_LEVEL	_068_R
      1  18e4				   LEVEL_ACTIVE__068_R SET	1
      2  18e4		       00 e4	   LEVEL_NAMED__068_R =	LEVELNUM
      3  18e4		       37		      .byte.b	<LEVEL__068_R
      4  18e5		       f5		      .byte.b	>LEVEL__068_R
      5  18e6		       06		      .byte.b	BANK_LEVEL__068_R
      6  18e7
      7  18e7				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18e7				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18e7					      ADD_LEVEL	_068_L
      1  18e7				   LEVEL_ACTIVE__068_L SET	1
      2  18e7		       00 e7	   LEVEL_NAMED__068_L =	LEVELNUM
      3  18e7		       e2		      .byte.b	<LEVEL__068_L
      4  18e8		       f4		      .byte.b	>LEVEL__068_L
      5  18e9		       06		      .byte.b	BANK_LEVEL__068_L
      6  18ea
      7  18ea				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ea				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ea					      ADD_LEVEL	_069_R
      1  18ea				   LEVEL_ACTIVE__069_R SET	1
      2  18ea		       00 ea	   LEVEL_NAMED__069_R =	LEVELNUM
      3  18ea		       dd		      .byte.b	<LEVEL__069_R
      4  18eb		       f5		      .byte.b	>LEVEL__069_R
      5  18ec		       06		      .byte.b	BANK_LEVEL__069_R
      6  18ed
      7  18ed				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ed				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ed					      ADD_LEVEL	_069_L
      1  18ed				   LEVEL_ACTIVE__069_L SET	1
      2  18ed		       00 ed	   LEVEL_NAMED__069_L =	LEVELNUM
      3  18ed		       8e		      .byte.b	<LEVEL__069_L
      4  18ee		       f5		      .byte.b	>LEVEL__069_L
      5  18ef		       06		      .byte.b	BANK_LEVEL__069_L
      6  18f0
      7  18f0				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f0				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    135  18f0
      0  18f0					      ADD_LEVEL	_103_Arielle
      1  18f0				   LEVEL_ACTIVE__103_Arielle SET	1
      2  18f0		       00 f0	   LEVEL_NAMED__103_Arielle =	LEVELNUM
      3  18f0		       ef		      .byte.b	<LEVEL__103_Arielle
      4  18f1		       f1		      .byte.b	>LEVEL__103_Arielle
      5  18f2		       07		      .byte.b	BANK_LEVEL__103_Arielle
      6  18f3
      7  18f3				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f3				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18f3					      ADD_LEVEL	_103_Ajalae
      1  18f3				   LEVEL_ACTIVE__103_Ajalae SET	1
      2  18f3		       00 f3	   LEVEL_NAMED__103_Ajalae =	LEVELNUM
      3  18f3		       a7		      .byte.b	<LEVEL__103_Ajalae
      4  18f4		       f1		      .byte.b	>LEVEL__103_Ajalae
      5  18f5		       07		      .byte.b	BANK_LEVEL__103_Ajalae
      6  18f6
      7  18f6				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f6				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18f6					      ADD_LEVEL	_103_Adin
      1  18f6				   LEVEL_ACTIVE__103_Adin SET	1
      2  18f6		       00 f6	   LEVEL_NAMED__103_Adin =	LEVELNUM
      3  18f6		       5b		      .byte.b	<LEVEL__103_Adin
      4  18f7		       f1		      .byte.b	>LEVEL__103_Adin
      5  18f8		       07		      .byte.b	BANK_LEVEL__103_Adin
      6  18f9
      7  18f9				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18f9				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18f9					      ADD_LEVEL	_102_Raven
      1  18f9				   LEVEL_ACTIVE__102_Raven SET	1
      2  18f9		       00 f9	   LEVEL_NAMED__102_Raven =	LEVELNUM
      3  18f9		       ec		      .byte.b	<LEVEL__102_Raven
      4  18fa		       f0		      .byte.b	>LEVEL__102_Raven
      5  18fb		       07		      .byte.b	BANK_LEVEL__102_Raven
      6  18fc
      7  18fc				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18fc				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18fc					      ADD_LEVEL	_102_Oralia
      1  18fc				   LEVEL_ACTIVE__102_Oralia SET	1
      2  18fc		       00 fc	   LEVEL_NAMED__102_Oralia =	LEVELNUM
      3  18fc		       a7		      .byte.b	<LEVEL__102_Oralia
      4  18fd		       f0		      .byte.b	>LEVEL__102_Oralia
      5  18fe		       07		      .byte.b	BANK_LEVEL__102_Oralia
      6  18ff
      7  18ff				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ff				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ff					      ADD_LEVEL	_102_Natalie
      1  18ff				   LEVEL_ACTIVE__102_Natalie SET	1
      2  18ff		       00 ff	   LEVEL_NAMED__102_Natalie =	LEVELNUM
      3  18ff		       00		      .byte.b	<LEVEL__102_Natalie
      4  1900		       f0		      .byte.b	>LEVEL__102_Natalie
      5  1901		       07		      .byte.b	BANK_LEVEL__102_Natalie
      6  1902
      7  1902				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1902				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1902					      ADD_LEVEL	_102_Mirabel
      1  1902				   LEVEL_ACTIVE__102_Mirabel SET	1
      2  1902		       01 02	   LEVEL_NAMED__102_Mirabel =	LEVELNUM
      3  1902		       47		      .byte.b	<LEVEL__102_Mirabel
      4  1903		       f0		      .byte.b	>LEVEL__102_Mirabel
      5  1904		       07		      .byte.b	BANK_LEVEL__102_Mirabel
      6  1905
      7  1905				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1905				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1905					      ADD_LEVEL	_1XJH_Tara_Gelson
      1  1905				   LEVEL_ACTIVE__1XJH_Tara_Gelson SET	1
      2  1905		       01 05	   LEVEL_NAMED__1XJH_Tara_Gelson =	LEVELNUM
      3  1905		       40		      .byte.b	<LEVEL__1XJH_Tara_Gelson
      4  1906		       f2		      .byte.b	>LEVEL__1XJH_Tara_Gelson
      5  1907		       07		      .byte.b	BANK_LEVEL__1XJH_Tara_Gelson
      6  1908
      7  1908				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1908				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1908					      ADD_LEVEL	_1R7X_Alison
      1  1908				   LEVEL_ACTIVE__1R7X_Alison SET	1
      2  1908		       01 08	   LEVEL_NAMED__1R7X_Alison =	LEVELNUM
      3  1908		       7b		      .byte.b	<LEVEL__1R7X_Alison
      4  1909		       f2		      .byte.b	>LEVEL__1R7X_Alison
      5  190a		       07		      .byte.b	BANK_LEVEL__1R7X_Alison
      6  190b
      7  190b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  190b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  190b					      ADD_LEVEL	_1KWD_Cecile_Clayworth
      1  190b				   LEVEL_ACTIVE__1KWD_Cecile_Clayworth SET	1
      2  190b		       01 0b	   LEVEL_NAMED__1KWD_Cecile_Clayworth =	LEVELNUM
      3  190b		       a9		      .byte.b	<LEVEL__1KWD_Cecile_Clayworth
      4  190c		       f2		      .byte.b	>LEVEL__1KWD_Cecile_Clayworth
      5  190d		       07		      .byte.b	BANK_LEVEL__1KWD_Cecile_Clayworth
      6  190e
      7  190e				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  190e				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  190e					      ADD_LEVEL	_1EKT_Samantha_Gelson
      1  190e				   LEVEL_ACTIVE__1EKT_Samantha_Gelson SET	1
      2  190e		       01 0e	   LEVEL_NAMED__1EKT_Samantha_Gelson =	LEVELNUM
      3  190e		       de		      .byte.b	<LEVEL__1EKT_Samantha_Gelson
      4  190f		       f2		      .byte.b	>LEVEL__1EKT_Samantha_Gelson
      5  1910		       07		      .byte.b	BANK_LEVEL__1EKT_Samantha_Gelson
      6  1911
      7  1911				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1911				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1911					      ADD_LEVEL	_0VM5_Andrea_Wadd
      1  1911				   LEVEL_ACTIVE__0VM5_Andrea_Wadd SET	1
      2  1911		       01 11	   LEVEL_NAMED__0VM5_Andrea_Wadd =	LEVELNUM
      3  1911		       18		      .byte.b	<LEVEL__0VM5_Andrea_Wadd
      4  1912		       f3		      .byte.b	>LEVEL__0VM5_Andrea_Wadd
      5  1913		       07		      .byte.b	BANK_LEVEL__0VM5_Andrea_Wadd
      6  1914
      7  1914				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1914				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1914					      ADD_LEVEL	_0PAL_Jill_Leatherby
      1  1914				   LEVEL_ACTIVE__0PAL_Jill_Leatherby SET	1
      2  1914		       01 14	   LEVEL_NAMED__0PAL_Jill_Leatherby =	LEVELNUM
      3  1914		       46		      .byte.b	<LEVEL__0PAL_Jill_Leatherby
      4  1915		       f3		      .byte.b	>LEVEL__0PAL_Jill_Leatherby
      5  1916		       07		      .byte.b	BANK_LEVEL__0PAL_Jill_Leatherby
      6  1917
      7  1917				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1917				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1917					      ADD_LEVEL	_0IZ1_Sophia
      1  1917				   LEVEL_ACTIVE__0IZ1_Sophia SET	1
      2  1917		       01 17	   LEVEL_NAMED__0IZ1_Sophia =	LEVELNUM
      3  1917		       71		      .byte.b	<LEVEL__0IZ1_Sophia
      4  1918		       f3		      .byte.b	>LEVEL__0IZ1_Sophia
      5  1919		       07		      .byte.b	BANK_LEVEL__0IZ1_Sophia
      6  191a
      7  191a				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  191a				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  191a					      ADD_LEVEL	_0CNH_Alice
      1  191a				   LEVEL_ACTIVE__0CNH_Alice SET	1
      2  191a		       01 1a	   LEVEL_NAMED__0CNH_Alice =	LEVELNUM
      3  191a		       9d		      .byte.b	<LEVEL__0CNH_Alice
      4  191b		       f3		      .byte.b	>LEVEL__0CNH_Alice
      5  191c		       07		      .byte.b	BANK_LEVEL__0CNH_Alice
      6  191d
      7  191d				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  191d				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  191d					      ADD_LEVEL	Thomas_Reinke16
      1  191d				   LEVEL_ACTIVE_Thomas_Reinke16 SET	1
      2  191d		       01 1d	   LEVEL_NAMED_Thomas_Reinke16 =	LEVELNUM
      3  191d		       6d		      .byte.b	<LEVEL_Thomas_Reinke16
      4  191e		       f5		      .byte.b	>LEVEL_Thomas_Reinke16
      5  191f		       07		      .byte.b	BANK_LEVEL_Thomas_Reinke16
      6  1920
      7  1920				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1920				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1920					      ADD_LEVEL	bDarcy_Burnsell101
      1  1920				   LEVEL_ACTIVE_bDarcy_Burnsell101 SET	1
      2  1920		       01 20	   LEVEL_NAMED_bDarcy_Burnsell101 =	LEVELNUM
      3  1920		       f3		      .byte.b	<LEVEL_bDarcy_Burnsell101
      4  1921		       f4		      .byte.b	>LEVEL_bDarcy_Burnsell101
      5  1922		       07		      .byte.b	BANK_LEVEL_bDarcy_Burnsell101
      6  1923
      7  1923				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1923				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1923					      ADD_LEVEL	bAlfa_DrFogh
      1  1923				   LEVEL_ACTIVE_bAlfa_DrFogh SET	1
      2  1923		       01 23	   LEVEL_NAMED_bAlfa_DrFogh =	LEVELNUM
      3  1923		       ca		      .byte.b	<LEVEL_bAlfa_DrFogh
      4  1924		       f3		      .byte.b	>LEVEL_bAlfa_DrFogh
      5  1925		       07		      .byte.b	BANK_LEVEL_bAlfa_DrFogh
      6  1926
      7  1926				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1926				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1926					      ADD_LEVEL	bAislin101
      1  1926				   LEVEL_ACTIVE_bAislin101 SET	1
      2  1926		       01 26	   LEVEL_NAMED_bAislin101 =	LEVELNUM
      3  1926		       30		      .byte.b	<LEVEL_bAislin101
      4  1927		       f5		      .byte.b	>LEVEL_bAislin101
      5  1928		       07		      .byte.b	BANK_LEVEL_bAislin101
      6  1929
      7  1929				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1929				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1929					      ADD_LEVEL	b51X_Sharpen
      1  1929				   LEVEL_ACTIVE_b51X_Sharpen SET	1
      2  1929		       01 29	   LEVEL_NAMED_b51X_Sharpen =	LEVELNUM
      3  1929		       72		      .byte.b	<LEVEL_b51X_Sharpen
      4  192a		       f4		      .byte.b	>LEVEL_b51X_Sharpen
      5  192b		       07		      .byte.b	BANK_LEVEL_b51X_Sharpen
      6  192c
      7  192c				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  192c				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
    156  192c							;    ADD_LEVEL b82X_Sharpen
    157  192c
    158  192c
    159  192c				   finX
    160  192c							; now put the soil in - fill from the outsides
    161  192c
    162  192c		       a9 01		      lda	#CHARACTER_SOIL
    163  192e		       85 8e		      sta	POS_Type
    164  1930
    165  1930		       a9 15		      lda	#SIZE_BOARD_Y-1
    166  1932		       85 8b		      sta	POS_Y
    167  1934
    168  1934		       a9 27	   xlin       lda	#SIZE_BOARD_X-1
    169  1936		       85 8a		      sta	POS_X
    170  1938		       20 23 f8    zap1       jsr	GetBoardCharacter__CALL_FROM_RAM__
    171  193b		       c9 01		      cmp	#CHARACTER_SOIL
    172  193d		       f0 07		      beq	kg2a
    173  193f		       c9 00		      cmp	#0
    174  1941		       d0 07		      bne	endzap1
    175  1943		       20 37 f8 	      jsr	PutBoardCharacterFromRAM
    176  1946		       c6 8a	   kg2a       dec	POS_X
    177  1948		       10 ee		      bpl	zap1
    178  194a
    179  194a		       a9 00	   endzap1    lda	#0
    180  194c		       85 8a		      sta	POS_X
    181  194e		       20 23 f8    zap2       jsr	GetBoardCharacter__CALL_FROM_RAM__
    182  1951		       c9 01		      cmp	#CHARACTER_SOIL
    183  1953		       f0 07		      beq	kg2
    184  1955		       c9 00		      cmp	#0
    185  1957		       d0 0b		      bne	endzap2
    186  1959		       20 37 f8 	      jsr	PutBoardCharacterFromRAM
    187  195c		       e6 8a	   kg2	      inc	POS_X
    188  195e		       a5 8a		      lda	POS_X
    189  1960		       c9 28		      cmp	#SIZE_BOARD_X
    190  1962		       d0 ea		      bne	zap2
    191  1964
    192  1964		       c6 8b	   endzap2    dec	POS_Y
    193  1966		       10 cc		      bpl	xlin
    194  1968
    195  1968
    196  1968		       a9 27		      lda	#SIZE_BOARD_X-1
    197  196a		       85 8a		      sta	POS_X
    198  196c
    199  196c		       a9 15	   ylin       lda	#SIZE_BOARD_Y-1
    200  196e		       85 8b		      sta	POS_Y
    201  1970		       20 23 f8    zapy1      jsr	GetBoardCharacter__CALL_FROM_RAM__
    202  1973		       c9 01		      cmp	#CHARACTER_SOIL
    203  1975		       f0 07		      beq	kg3
    204  1977		       c9 00		      cmp	#0
    205  1979		       d0 07		      bne	endzapy1
    206  197b		       20 37 f8 	      jsr	PutBoardCharacterFromRAM
    207  197e		       c6 8b	   kg3	      dec	POS_Y
    208  1980		       10 ee		      bpl	zapy1
    209  1982
    210  1982		       a9 00	   endzapy1   lda	#0
    211  1984		       85 8b		      sta	POS_Y
    212  1986		       20 23 f8    zapy2      jsr	GetBoardCharacter__CALL_FROM_RAM__
    213  1989		       c9 01		      cmp	#CHARACTER_SOIL
    214  198b		       f0 07		      beq	kg3b
    215  198d		       c9 00		      cmp	#0
    216  198f		       d0 0b		      bne	endzapy2
    217  1991		       20 37 f8 	      jsr	PutBoardCharacterFromRAM
    218  1994		       e6 8b	   kg3b       inc	POS_Y
    219  1996		       a5 8b		      lda	POS_Y
    220  1998		       c9 16		      cmp	#SIZE_BOARD_Y
    221  199a		       d0 ea		      bne	zapy2
    222  199c
    223  199c		       c6 8a	   endzapy2   dec	POS_X
    224  199e		       10 cc		      bpl	ylin
    225  19a0		       60		      rts
    226  19a1
      0  19a1					      DEFINE_SUBROUTINE	RegisterOneMoreTarget
      1  19a1		       00 03	   BANK_RegisterOneMoreTarget =	_CURRENT_BANK
      2  19a1					      SUBROUTINE
      3  19a1				   RegisterOneMoreTarget
    228  19a1
    229  19a1		       f8		      sed
    230  19a2		       18		      clc
    231  19a3		       a5 b9		      lda	targetsRequired
    232  19a5		       69 01		      adc	#1
    233  19a7		       85 b9		      sta	targetsRequired
    234  19a9		       d8		      cld
    235  19aa		       60		      rts
    236  19ab
    237  19ab							;A	 steel wall
    238  19ab							;B	 soil (surround)
    239  19ab							;C	 box
    240  19ab
    241  19ab
    242  19ab				   C1
    243  19ab		       b6 2a a8 48	      .byte.b	$b6,$2A,$a8,$48
    244  19af		       c8 78 28 98	      .byte.b	$C8,$78,$28,$98
    245  19b3				   C2
    246  19b3		       62 a4 22 84	      .byte.b	$62,$A4,$22,$84
    247  19b7		       44 82 f4 64	      .byte.b	$44,$82,$F4,$64
    248  19bb				   C3
    249  19bb		       2a 7a f8 b8	      .byte.b	$2a,$7A,$f8,$B8
    250  19bf		       fc c6 98 ea	      .byte.b	$FC,$C6,$98,$Ea
    251  19c3
    252  19c3							; C6 44 2A	 browns
    253  19c3							; BA 96 E8	 ice blues
    254  19c3
    255  19c3
      0  19c3					      DEFINE_SUBROUTINE	UnpackLevel
      1  19c3		       00 03	   BANK_UnpackLevel =	_CURRENT_BANK
      2  19c3					      SUBROUTINE
      3  19c3				   UnpackLevel
    257  19c3
    258  19c3		       85 c5		      sta	RAM_Bank
    259  19c5
    260  19c5							; has to be done before decoding the level to have the platform right:
      0  19c5					      SET_PLATFORM
      1  19c5
      2  19c5
      3  19c5
      4  19c5
      5  19c5		       ad 82 02 	      lda	SWCHB
      6  19c8		       2a		      rol
      7  19c9		       2a		      rol
      8  19ca		       2a		      rol
      9  19cb		       29 03		      and	#%11
     10  19cd					      if	NTSC_MODE = NO
     11  19cd		       49 02		      eor	#PAL
     12  19cf					      endif
     13  19cf		       a9 00		      lda	#0
     14  19d1		       85 81		      sta	Platform
    262  19d3
    263  19d3		       a9 01		      lda	#CHARACTER_SOIL
    264  19d5		       85 8e		      sta	POS_Type
    265  19d7
    266  19d7		       a9 15		      lda	#SIZE_BOARD_Y-1
    267  19d9		       85 8b		      sta	POS_Y
    268  19db		       a9 27	   xyLine     lda	#SIZE_BOARD_X-1
    269  19dd		       85 8a		      sta	POS_X
    270  19df		       20 37 f8    xyClear    jsr	PutBoardCharacterFromRAM
    271  19e2		       c6 8a		      dec	POS_X
    272  19e4		       10 f9		      bpl	xyClear
    273  19e6		       c6 8b		      dec	POS_Y
    274  19e8		       10 f1		      bpl	xyLine
    275  19ea
    276  19ea		       a9 06		      lda	#6
    277  19ec		       85 da		      sta	base_x
    278  19ee		       85 db		      sta	base_y
    279  19f0
    280  19f0		       a5 ca		      lda	NextLevelTrigger
    281  19f2		       09 80		      ora	#BIT_NEXTLEVEL
    282  19f4		       85 ca		      sta	NextLevelTrigger
    283  19f6
    284  19f6		       a5 b4		      lda	levelX
    285  19f8		       0a		      asl
    286  19f9		       65 b4		      adc	levelX
    287  19fb		       a8		      tay
    288  19fc		       38		      sec
    289  19fd		       b9 00 f0 	      lda	LevelInformation,y
    290  1a00		       e9 01		      sbc	#1
    291  1a02		       85 c0		      sta	Board_AddressR
    292  1a04		       b9 01 f0 	      lda	LevelInformation+1,y
    293  1a07		       e9 00		      sbc	#0
    294  1a09		       85 c1		      sta	Board_AddressR+1
    295  1a0b		       b9 02 f0 	      lda	LevelInformation+2,y
    296  1a0e		       85 b0		      sta	LEVEL_bank
    297  1a10
    298  1a10		       a9 03		      lda	#BANK_UnpackLevel	; the *ROM* bank of this routine (NOT RAM)
    299  1a12		       85 c4		      sta	ROM_Bank	; GetROMByte returns to this bank
    300  1a14
    301  1a14		       a5 b4		      lda	levelX
    302  1a16		       29 07		      and	#7
    303  1a18		       aa		      tax
    304  1a19		       bd ab f1 	      lda	C1,x
    305  1a1c		       85 bd		      sta	color
    306  1a1e		       bd b3 f1 	      lda	C2,x
    307  1a21		       85 be		      sta	color+1
    308  1a23		       bd bb f1 	      lda	C3,x
    309  1a26		       85 bf		      sta	color+2
    310  1a28
    311  1a28							;NEXT_RANDOM
    312  1a28							;and #$F0
    313  1a28							;ora #$A
    314  1a28							;lda #$ba
    315  1a28							;sta color
    316  1a28							;lda #$96
    317  1a28							;lda #$A0
    318  1a28							;sta color+1
    319  1a28							;lda #$e8 ;lda #$9C
    320  1a28							;sta color+2
    321  1a28
    322  1a28							; good colours
    323  1a28
    324  1a28
    325  1a28		       a9 00		      lda	#$00
    326  1a2a		       85 ba		      sta	moveCounter
    327  1a2c		       85 bb		      sta	moveCounterHi
    328  1a2e		       85 bc		      sta	moveCounterBinary
    329  1a30
    330  1a30		       a9 00		      lda	#$00	; BCD reminder!
    331  1a32		       85 b9		      sta	targetsRequired	; # of targets that do NOT have boxes on them
    332  1a34
    333  1a34							;lda #SIZE_BOARD_X
    334  1a34							;sta BoardLimit_Width
    335  1a34							;lda #SIZE_BOARD_Y
    336  1a34							;sta BoardLimit_Height
    337  1a34							;lda #$5
    338  1a34							;sta targetsRequired		   ;	   should never be 0
    339  1a34
    340  1a34		       a9 18		      lda	#24	; arbitrary
    341  1a36		       85 b8		      sta	ThrottleSpeed
    342  1a38
    343  1a38							; first fill bg with character_soil
    344  1a38							; then rle unpack level
    345  1a38							; change level colours
    346  1a38
    347  1a38		       a9 00		      lda	#0
    348  1a3a		       85 8a		      sta	POS_X
    349  1a3c		       85 8b		      sta	POS_Y
    350  1a3e		       85 94		      sta	BoardLimit_Width
    351  1a40		       85 95		      sta	BoardLimit_Height
    352  1a42
    353  1a42				   GetNextItem
    354  1a42
    355  1a42		       a9 01		      lda	#1
    356  1a44		       85 dc		      sta	upk_length
    357  1a46		       a9 00		      lda	#0
    358  1a48		       85 dd		      sta	upk_column	; reuse var - this flags a digit already
    359  1a4a
    360  1a4a		       e6 c0	   Get2       inc	Board_AddressR
    361  1a4c		       d0 02		      bne	addrOK
    362  1a4e		       e6 c1		      inc	Board_AddressR+1
    363  1a50				   addrOK
    364  1a50
    365  1a50		       a5 b0		      lda	LEVEL_bank
    366  1a52		       a0 00		      ldy	#0
    367  1a54		       20 0c f8 	      jsr	GetROMByte
    368  1a57		       85 de		      sta	upk_temp	;scratch
    369  1a59
    370  1a59
    371  1a59		       c9 00		      cmp	#0
    372  1a5b		       d0 03		      bne	parse
    373  1a5d		       4c 2c f1 	      jmp	finX
    374  1a60				   parse
    375  1a60		       c9 3a		      cmp	#"9"+1
    376  1a62		       b0 1e		      bcs	notDigit
    377  1a64		       c9 30		      cmp	#"0"
    378  1a66		       90 1a		      bcc	notDigit
    379  1a68
    380  1a68		       a5 dd		      lda	upk_column
    381  1a6a		       f0 09		      beq	firstDig
    382  1a6c
    383  1a6c		       a5 dc		      lda	upk_length
    384  1a6e		       0a		      asl
    385  1a6f		       0a		      asl
    386  1a70		       0a		      asl
    387  1a71		       65 dc		      adc	upk_length
    388  1a73		       65 dc		      adc	upk_length
    389  1a75
    390  1a75		       18	   firstDig   clc
    391  1a76		       65 de		      adc	upk_temp
    392  1a78		       38		      sec
    393  1a79		       e9 30		      sbc	#"0"
    394  1a7b		       85 dc		      sta	upk_length
    395  1a7d		       e6 dd		      inc	upk_column	; flag we have seen a digit
    396  1a7f		       4c 4a f2 	      jmp	Get2
    397  1a82
    398  1a82		       c9 7c	   notDigit   cmp	#"|"	; newline
    399  1a84		       d0 11		      bne	checkWall
    400  1a86
    401  1a86							; Handle new-line
    402  1a86		       a9 00		      lda	#0
    403  1a88		       85 8a		      sta	POS_X
    404  1a8a		       e6 8b		      inc	POS_Y
    405  1a8c
    406  1a8c
    407  1a8c		       a5 8b		      lda	POS_Y
    408  1a8e		       c5 95		      cmp	BoardLimit_Height
    409  1a90		       90 02		      bcc	wOK2
    410  1a92		       85 95		      sta	BoardLimit_Height	;???^^^
    411  1a94				   wOK2
    412  1a94
    413  1a94		       4c 42 f2 	      jmp	GetNextItem
    414  1a97
    415  1a97		       c9 23	   checkWall  cmp	#"#"	; wall
    416  1a99		       d0 09		      bne	checkForGap
    417  1a9b		       a5 b4		      lda	levelX
    418  1a9d		       29 01		      and	#1
    419  1a9f		       18		      clc
    420  1aa0		       69 06		      adc	#CHARACTER_STEEL
    421  1aa2		       d0 66		      bne	WriteChars
    422  1aa4
    423  1aa4		       c9 20	   checkForGap cmp	#32
    424  1aa6		       f0 08		      beq	writeGap
    425  1aa8		       c9 2d		      cmp	#"-"
    426  1aaa		       f0 04		      beq	writeGap
    427  1aac		       c9 5f		      cmp	#"_"
    428  1aae		       d0 05		      bne	checkForMan
    429  1ab0
    430  1ab0		       a9 00	   writeGap   lda	#CHARACTER_BLANK
    431  1ab2		       4c 0a f3 	      jmp	WriteChars
    432  1ab5
    433  1ab5				   checkForMan
    434  1ab5		       c9 2b		      cmp	#"+"	; player on goal square
    435  1ab7		       d0 07		      bne	notPlayerGoal
    436  1ab9
    437  1ab9		       20 a1 f1 	      jsr	RegisterOneMoreTarget
    438  1abc
    439  1abc							; put goal square, init player with POS_VAR = CHARACTER_TARGET
    440  1abc
    441  1abc		       a9 03		      lda	#CHARACTER_TARGET
    442  1abe		       d0 06		      bne	genPlayer
    443  1ac0
    444  1ac0				   notPlayerGoal
    445  1ac0		       c9 40		      cmp	#"@"	; player on normal square
    446  1ac2		       d0 2d		      bne	checkBox
    447  1ac4
    448  1ac4		       a9 00		      lda	#CHARACTER_BLANK
    449  1ac6
    450  1ac6				   genPlayer
    451  1ac6
    452  1ac6		       85 8f		      sta	POS_VAR	; character man is on
    453  1ac8
    454  1ac8		       18		      clc
    455  1ac9		       a5 8a		      lda	POS_X
    456  1acb		       48		      pha
    457  1acc		       65 da		      adc	base_x
    458  1ace		       85 8a		      sta	POS_X
    459  1ad0		       85 9b		      sta	ManX
    460  1ad2
    461  1ad2		       a5 8b		      lda	POS_Y
    462  1ad4		       48		      pha
    463  1ad5		       65 db		      adc	base_y
    464  1ad7		       85 8b		      sta	POS_Y
    465  1ad9		       85 9c		      sta	ManY
    466  1adb
    467  1adb							; POS_X     x position
    468  1adb							; POS_Y     y position
    469  1adb							; POS_VAR   CHARACTER UNDER MAN TO RESTORE
    470  1adb							; POS_Type  type of object
    471  1adb
    472  1adb		       a9 00		      lda	#TYPE_MAN
    473  1add		       85 8e		      sta	POS_Type	;	 creature TYPE
    474  1adf		       20 1e f9 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    475  1ae2
    476  1ae2		       a9 00		      lda	#0
    477  1ae4		       85 9a		      sta	manAnimationIndex
    478  1ae6
    479  1ae6		       68		      pla
    480  1ae7		       85 8b		      sta	POS_Y
    481  1ae9		       68		      pla
    482  1aea		       85 8a		      sta	POS_X
    483  1aec
    484  1aec		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    485  1aee		       4c 0a f3 	      jmp	WriteChars
    486  1af1
    487  1af1		       c9 24	   checkBox   cmp	#"$"
    488  1af3		       d0 04		      bne	checkBoxTarget
    489  1af5
    490  1af5		       a9 02		      lda	#CHARACTER_BOX
    491  1af7		       d0 11		      bne	WriteChars
    492  1af9
    493  1af9		       c9 2a	   checkBoxTarget cmp	#"*"
    494  1afb		       d0 04		      bne	checkTarget
    495  1afd
    496  1afd		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    497  1aff		       d0 09		      bne	WriteChars
    498  1b01
    499  1b01		       c9 2e	   checkTarget cmp	#"."
    500  1b03		       f0 03		      beq	targ
    501  1b05		       4c 42 f2 	      jmp	GetNextItem
    502  1b08				   targ
    503  1b08
    504  1b08		       a9 03		      lda	#CHARACTER_TARGET
    505  1b0a
    506  1b0a		       85 8e	   WriteChars sta	POS_Type
    507  1b0c
    508  1b0c		       18	   Wc2x       clc
    509  1b0d		       a5 8a		      lda	POS_X
    510  1b0f		       48		      pha
    511  1b10		       65 da		      adc	base_x
    512  1b12		       85 8a		      sta	POS_X
    513  1b14
    514  1b14		       a5 8b		      lda	POS_Y
    515  1b16		       48		      pha
    516  1b17		       65 db		      adc	base_y
    517  1b19		       85 8b		      sta	POS_Y
    518  1b1b
    519  1b1b		       20 37 f8 	      jsr	PutBoardCharacterFromRAM
    520  1b1e
    521  1b1e		       a5 8e		      lda	POS_Type
    522  1b20		       c9 03		      cmp	#CHARACTER_TARGET
    523  1b22		       d0 03		      bne	notargdet
    524  1b24		       20 a1 f1 	      jsr	RegisterOneMoreTarget
    525  1b27				   notargdet
    526  1b27
    527  1b27		       68		      pla
    528  1b28		       85 8b		      sta	POS_Y
    529  1b2a		       68		      pla
    530  1b2b		       85 8a		      sta	POS_X
    531  1b2d
    532  1b2d		       18		      clc
    533  1b2e		       69 01		      adc	#1
    534  1b30		       85 8a		      sta	POS_X
    535  1b32
    536  1b32		       c5 94		      cmp	BoardLimit_Width
    537  1b34		       90 02		      bcc	wOK
    538  1b36		       85 94		      sta	BoardLimit_Width
    539  1b38				   wOK
    540  1b38
    541  1b38		       c6 dc		      dec	upk_length
    542  1b3a		       d0 d0		      bne	Wc2x
    543  1b3c		       4c 42 f2 	      jmp	GetNextItem
    544  1b3f
    545  1b3f				   finishedUnpack
    546  1b3f
    547  1b3f		       60		      rts
    548  1b3f					      endif
------- FILE BANK_GENERIC.asm
     44  1b40
      0  1b40					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_LEVEL)"
      1  1b40
      2  1b40
      3  1b40		       03 40	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_LEVEL) (1K) SIZE =  $340 , FREE= $c0
      4  1b40					      ECHO	"GENERIC_BANK_1 (DECODE_LEVEL)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1b40				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1b40				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1b40				  -	      ERR
      8  1b40					      endif
     46  1b40
     47  1b40							;------------------------------------------------------------------------------
     48  1b40							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     49  1b40							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     50  1b40							; bank finishes.  Just continue on from where it left off...
     51  1b40							;------------------------------------------------------------------------------
     52  1b40
      0  1b40					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  1b40		       00 03	   BANK_Cart_Init =	_CURRENT_BANK
      2  1b40					      SUBROUTINE
      3  1b40				   Cart_Init
     54  1b40
     55  1b40							; Note the variables from the title selection are incredibly transient an can be stomped
     56  1b40							; at any time.  So they need to be used immediately.
     57  1b40
     58  1b40
     59  1b40							; odd usage below is to prevent any possibility of variable stomping/assumptions
     60  1b40
     61  1b40		       a9 01		      lda	#1
     62  1b42		       a2 00		      ldx	#0	;sLevel				      ; level # from title select
     63  1b44		       a0 00		      ldy	#0	;sJoysticks
     64  1b46		       84 a9		      sty	jtoggle
     65  1b48		       86 b5		      stx	level
     66  1b4a		       85 a7		      sta	ManCount	; = #players
     67  1b4c		       a9 00		      lda	#0
     68  1b4e		       85 b4		      sta	levelX	; make an immediate copy to safe variables!
     69  1b50		       85 e0		      sta	startingLevel
     70  1b52
     71  1b52							; multiply with LEVEL_DEFINITION_SIZE (5):
     72  1b52		       0a		      asl
     73  1b53		       0a		      asl
     74  1b54		       85 b4		      sta	levelX
     75  1b56
     76  1b56		       a9 01		      lda	#1
     77  1b58		       85 99		      sta	whichPlayer	; will switch to 0 on 1st go
     78  1b5a
     79  1b5a		       a9 30		      lda	#NUM_LIVES<<4	; 3 lives
     80  1b5c		       a6 a7		      ldx	ManCount	; = sPlayers
     81  1b5e		       f0 02		      beq	opg
     82  1b60		       a9 33		      lda	#NUM_LIVES<<4|NUM_LIVES
     83  1b62		       85 a7	   opg	      sta	ManCount	; P2P1 nybble each
     84  1b64
     85  1b64							;---------------------------------------------------------------------------
     86  1b64
     87  1b64		       a9 00		      lda	#0
     88  1b66		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     89  1b69		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     90  1b6c		       85 6b		      sta	HMCLR
     91  1b6e
     92  1b6e							; cleanup remains of title screen
     93  1b6e		       85 5b		      sta	GRP0
     94  1b70		       85 5c		      sta	GRP1
     95  1b72		       85 5b		      sta	GRP0
     96  1b74
     97  1b74		       85 89		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     98  1b76		       85 aa		      sta	circle_d
     99  1b78		       85 ab		      sta	circle_d+1
    100  1b7a
    101  1b7a							;    IFCONST DEBUG_CREATURE
    102  1b7a							;		  sta worstTime
    103  1b7a							;    ENDIF
    104  1b7a
    105  1b7a		       a9 04		      lda	#%100	; players/missiles BEHIND BG
    106  1b7c		       85 4a		      sta	CTRLPF
    107  1b7e		       85 82		      sta	rnd	; anything non-0
    108  1b80
    109  1b80		       a9 ff		      lda	#$FF
    110  1b82		       85 84		      sta	DrawStackPointer
    111  1b84		       85 92		      sta	BufferedButton
    112  1b86		       85 93		      sta	BufferedButton+1
    113  1b88
    114  1b88		       a9 07		      lda	#DIRECTION_BITS
    115  1b8a		       85 a4		      sta	ManLastDirection
    116  1b8c
    117  1b8c		       a9 00		      lda	#0
    118  1b8e							;		  sta ObjStackPtr		  ; object stack index of last entry
    119  1b8e							;		  sta ObjStackPtr+1
    120  1b8e							;		  sta ObjStackNum
    121  1b8e							;		  sta ObjIterator
    122  1b8e
    123  1b8e		       85 cc		      sta	sortPtr
    124  1b90		       a9 ff		      lda	#<(-1)
    125  1b92		       85 cb		      sta	sortRequired
    126  1b94
    127  1b94							; read high score from SaveKey and store in highScoreSK,
    128  1b94							; which is transferred to high score variable in RAM by GeneralScoringSetups
    129  1b94		       4c fd f5 	      jmp	ReadSaveKey
    130  1b97
    131  1b97							;LEVEL0CREATURE  .byte TYPE_MAN,	  0,	  3,	  5
    132  1b97							;		  .byte -1
    133  1b97
    134  1b97							;------------------------------------------------------------------------------
    135  1b97
      0  1b97					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  1b97		       00 03	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  1b97					      SUBROUTINE
      3  1b97				   SwapPlayersGeneric
    137  1b97
    138  1b97							; at the start of a level (or player, doesn't matter) we grab the current state of the colour/B&W switch
    139  1b97							; into the gameMode variable.
    140  1b97
    141  1b97		       a5 80		      lda	gameMode
    142  1b99		       29 77		      and	#~(BW_SWITCH|GAMEMODE_PAUSED)
    143  1b9b		       85 80		      sta	gameMode
    144  1b9d		       ad 82 02 	      lda	SWCHB
    145  1ba0		       29 08		      and	#BW_SWITCH
    146  1ba2		       05 80		      ora	gameMode	; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    147  1ba4		       85 80		      sta	gameMode	; also, BIT7=0 -- system is NOT paused
    148  1ba6
    149  1ba6
    150  1ba6							; restart level
    151  1ba6		       a5 ca		      lda	NextLevelTrigger
    152  1ba8		       29 bf		      and	#<(~BIT_NEXTLIFE)
    153  1baa		       85 ca		      sta	NextLevelTrigger
    154  1bac
    155  1bac							; if new high score was set by SwapPlayers, update it:
    156  1bac
    157  1bac		       4c 23 f6 	      jmp	WriteSaveKey
    158  1baf
    159  1baf
    160  1baf							;------------------------------------------------------------------------------
    161  1baf
      0  1baf					      DEFINE_SUBROUTINE	CreateCreatures
      1  1baf		       00 03	   BANK_CreateCreatures =	_CURRENT_BANK
      2  1baf					      SUBROUTINE
      3  1baf				   CreateCreatures
    163  1baf
    164  1baf							; Calculate rightmost value for scrolling edge.  .
    165  1baf
    166  1baf		       85 c4		      sta	ROM_Bank
    167  1bb1
    168  1bb1		       38		      sec
    169  1bb2		       a5 94		      lda	BoardLimit_Width
    170  1bb4		       e9 09		      sbc	#SCREEN_WIDTH-1
    171  1bb6		       85 94		      sta	BoardEdge_Right	; absolute rightmost scroll value
    172  1bb8
    173  1bb8							;		  sec			     already set
    174  1bb8		       a5 95		      lda	BoardLimit_Height
    175  1bba		       e9 07		      sbc	#SCREEN_LINES-1
    176  1bbc		       85 95		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    177  1bbe
    178  1bbe							; kludge position scroll roughly at player
    179  1bbe
    180  1bbe							;		  sec			 already set
    181  1bbe		       a5 9b		      lda	ManX
    182  1bc0		       e9 05		      sbc	#5
    183  1bc2		       b0 02		      bcs	notL0
    184  1bc4		       a9 00		      lda	#0
    185  1bc6		       85 97	   notL0      sta	BoardScrollX
    186  1bc8
    187  1bc8
    188  1bc8		       38		      sec
    189  1bc9		       a5 9c		      lda	ManY
    190  1bcb		       e9 03		      sbc	#3	; TJ: why 5???
    191  1bcd		       b0 02		      bcs	notU0
    192  1bcf		       a9 00		      lda	#0
    193  1bd1		       85 96	   notU0      sta	BoardScrollY
    194  1bd3
    195  1bd3		       a9 00		      lda	#0
    196  1bd5		       85 9f		      sta	ManMode
    197  1bd7		       85 a0		      sta	ManDelayCount
    198  1bd9
    199  1bd9		       a9 1a		      lda	#AnimateBLANK-Manimate	;0 ;<AnimateBLANK ;STAND
    200  1bdb		       85 a1		      sta	ManAnimation
    201  1bdd							;lda #>AnimateBLANK ;
    202  1bdd							;sta ManAnimation+1
    203  1bdd
    204  1bdd		       a9 ff		      lda	#$FF
    205  1bdf		       85 b1		      sta	LastSpriteY
    206  1be1
    207  1be1		       a9 07		      lda	#DIRECTION_BITS
    208  1be3		       85 a4		      sta	ManLastDirection
    209  1be5		       60		      rts
    210  1be6
    211  1be6							;-------------------------------------------------------------------------------------
    212  1be6
      0  1be6					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  1be6		       00 03	   BANK_LevelInit =	_CURRENT_BANK
      2  1be6					      SUBROUTINE
      3  1be6				   LevelInit
    214  1be6
    215  1be6		       a9 00		      lda	#0
    216  1be8		       85 86		      sta	ObjStackPtr
    217  1bea		       85 87		      sta	ObjStackPtr+1	; kill all creatures
    218  1bec		       85 85		      sta	ObjStackNum
    219  1bee		       85 cd		      sta	ObjIterator
    220  1bf0
    221  1bf0		       85 98		      sta	scrollBits
    222  1bf2		       85 89		      sta	ScreenDrawPhase
    223  1bf4
    224  1bf4		       85 b3		      sta	BGColour
    225  1bf6		       85 c6		      sta	ColourTimer
    226  1bf8
    227  1bf8		       85 59		      sta	AUDV0
    228  1bfa		       85 5a		      sta	AUDV1	; turn off music while levels init
    229  1bfc							;		  sta AUDC0
    230  1bfc
    231  1bfc		       85 a4		      sta	ManLastDirection
    232  1bfe		       85 a5		      sta	ManPushCounter
    233  1c00
    234  1c00		       85 cc		      sta	sortPtr	; sort stopped
    235  1c02		       a9 ff		      lda	#<(-1)
    236  1c04		       85 cb		      sta	sortRequired	; nothing needed
    237  1c06		       85 84		      sta	DrawStackPointer
    238  1c08
    239  1c08		       a9 00		      lda	#DISPLAY_TIME	;DISPLAY_SCORE
    240  1c0a		       85 c9		      sta	scoringFlags
    241  1c0c		       a9 00		      lda	#0	;SCORING_TIMER_FIRST		      ; We want the first timer display to be long, to show level and lives
    242  1c0e		       85 c8		      sta	scoringTimer
    243  1c10		       60		      rts
    244  1c11
    245  1c11							;-------------------------------------------------------------------------------------
    246  1c11
      0  1c11					      DEFINE_SUBROUTINE	Resync
      1  1c11		       00 03	   BANK_Resync =	_CURRENT_BANK
      2  1c11					      SUBROUTINE
      3  1c11				   Resync
      0  1c11					      RESYNC
      1  1c11
      2  1c11		       a9 02		      lda	#%10
      3  1c13		       85 41		      sta	VBLANK
      4  1c15
      5  1c15		       a2 08		      ldx	#8
      6  1c17				   .loopResync
      0  1c17					      VERTICAL_SYNC
      1  1c17		       a9 0e		      lda	#%1110
      2  1c19		       85 42	   .VSLP1     sta	WSYNC
      3  1c1b		       85 40		      sta	VSYNC
      4  1c1d		       4a		      lsr
      5  1c1e		       d0 f9		      bne	.VSLP1
      8  1c20
      9  1c20		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  1c22		       a5 81		      lda	Platform
     11  1c24		       49 02		      eor	#PAL_50
     12  1c26		       d0 02		      bne	.ntsc
     13  1c28		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  1c2a				   .ntsc
     15  1c2a				   .loopWait
     16  1c2a		       85 42		      sta	WSYNC
     17  1c2c		       85 42		      sta	WSYNC
     18  1c2e		       88		      dey
     19  1c2f		       d0 f9		      bne	.loopWait
     20  1c31		       ca		      dex
     21  1c32		       d0 e3		      bne	.loopResync
    249  1c34		       60	   Ret	      rts
    250  1c35
    251  1c35							;---------------------------------------------------------------------------
    252  1c35
      0  1c35					      DEFINE_SUBROUTINE	TrackPlayer	; =145; in GENERIC_BANK_1
      1  1c35		       00 03	   BANK_TrackPlayer =	_CURRENT_BANK
      2  1c35					      SUBROUTINE
      3  1c35				   TrackPlayer
    254  1c35
    255  1c35		       a5 a6		      lda	LookingAround	; 3
    256  1c37		       d0 fb		      bne	Ret	; 2/3=5/6   don't track when looking around
    257  1c39
    258  1c39							; Contribution by Thomas Jentzsch
    259  1c39
    260  1c39							; scrolling constants:
    261  1c39		       00 03	   .SCRL_START_LEFT =	3	; 3
    262  1c39		       00 03	   .SCRL_STOP_LEFT =	3	;SCREEN_WIDTH-5		    ; 5 scrolls 5-3+1 = 3 pixel
    263  1c39		       00 07	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT	; 7
    264  1c39		       00 07	   .SCRL_STOP_RIGHT =	SCREEN_WIDTH-.SCRL_STOP_LEFT	; 5
    265  1c39		       00 11	   .SCRL_LEFT_BIT =	%00010001
    266  1c39		       00 22	   .SCRL_RIGHT_BIT =	%00100010
    267  1c39		       00 33	   .SCRL_X_BITS =	.SCRL_LEFT_BIT|.SCRL_RIGHT_BIT
    268  1c39
    269  1c39		       00 02	   .SCRL_START_UP =	2	; 2
    270  1c39		       00 02	   .SCRL_STOP_UP =	2	;SCREEN_LINES-5		    ; 3 scrolls 3-2+1 = 2 pixel
    271  1c39		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP	; 6
    272  1c39		       00 06	   .SCRL_STOP_DOWN =	SCREEN_LINES-.SCRL_STOP_UP	; 5
    273  1c39		       00 44	   .SCRL_UP_BIT =	%01000100
    274  1c39		       00 88	   .SCRL_DOWN_BIT =	%10001000
    275  1c39		       00 cc	   .SCRL_Y_BITS =	.SCRL_UP_BIT|.SCRL_DOWN_BIT
    276  1c39
    277  1c39							; *** horizontal scrolling (unoptimized version): ***
    278  1c39
    279  1c39							; check for enabling horizontal scrolling:
    280  1c39		       a5 9b		      lda	ManX	; 3
    281  1c3b		       38		      sec		; 2
    282  1c3c		       e5 97		      sbc	BoardScrollX	; 3
    283  1c3e		       a8		      tay		; 2	     for later use
    284  1c3f		       a9 11		      lda	#.SCRL_LEFT_BIT	; 2
    285  1c41		       c0 03		      cpy	#.SCRL_START_LEFT	; 2	     <3?
    286  1c43		       30 06		      bmi	.startXScroll	; 2/3	     yes, scroll left
    287  1c45		       c0 07		      cpy	#.SCRL_START_RIGHT	; 2	     <8?
    288  1c47		       30 08		      bmi	.skipStartXScroll	; 2/3	     no
    289  1c49		       a9 22		      lda	#.SCRL_RIGHT_BIT	; 2 = 22    yes, scroll right
    290  1c4b				   .startXScroll
    291  1c4b		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    292  1c4d		       05 98		      ora	scrollBits	; 3
    293  1c4f		       85 98		      sta	scrollBits	; 3 =	8
    294  1c51				   .skipStartXScroll
    295  1c51
    296  1c51							; do horizontal scrolling:
    297  1c51		       a5 98		      lda	scrollBits	; 3
    298  1c53		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    299  1c55		       f0 23		      beq	.skipXScroll	; 2/3
    300  1c57		       29 22		      and	#.SCRL_RIGHT_BIT	; 2
    301  1c59		       d0 0c		      bne	.xScrollRight	; 2/3=11/12
    302  1c5b
    303  1c5b							; scroll left:
    304  1c5b		       a5 97		      lda	BoardScrollX	; 3	     already at left edge?
    305  1c5d		       f0 15		      beq	.stopXScroll	; 2
    306  1c5f		       c6 97		      dec	BoardScrollX	; 5
    307  1c61		       c0 02		      cpy	#.SCRL_STOP_LEFT-1	; 2
    308  1c63		       10 0f		      bpl	.stopXScroll	; 2/3=15
    309  1c65		       30 13		      bmi	.skipXScroll	; 3
    310  1c67							;---------------------------------------
    311  1c67				   .xScrollRight
    312  1c67		       a6 97		      ldx	BoardScrollX	; 3
    313  1c69		       e8		      inx		; 2
    314  1c6a		       e4 94		      cpx	BoardEdge_Right	; 3	     already at right edge?
    315  1c6c		       10 06		      bpl	.stopXScroll	; 2/3
    316  1c6e		       86 97		      stx	BoardScrollX	; 3
    317  1c70		       c0 08		      cpy	#.SCRL_STOP_RIGHT+1	; 2
    318  1c72		       10 06		      bpl	.skipXScroll	; 2/3=17/18
    319  1c74				   .stopXScroll
    320  1c74		       a5 98		      lda	scrollBits	; 3
    321  1c76		       29 fc		      and	#(~(.SCRL_X_BITS >> 4))	; 2
    322  1c78		       85 98		      sta	scrollBits	; 3 =	8
    323  1c7a				   .skipXScroll
    324  1c7a							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    325  1c7a
    326  1c7a							; *** vertical scrolling (unoptimized version): ***
    327  1c7a
    328  1c7a							; check for enabling vertical scrolling:
    329  1c7a		       a5 9c		      lda	ManY	; 3
    330  1c7c		       38		      sec		; 2
    331  1c7d		       e5 96		      sbc	BoardScrollY	; 3
    332  1c7f		       a8		      tay		; 2	     for later use
    333  1c80		       a9 44		      lda	#.SCRL_UP_BIT	; 2
    334  1c82		       c0 02		      cpy	#.SCRL_START_UP	; 2	     <2?
    335  1c84		       30 06		      bmi	.startYScroll	; 2/3	     yes, scroll up
    336  1c86		       c0 06		      cpy	#.SCRL_START_DOWN	; 2	     <6?
    337  1c88		       30 08		      bmi	.skipStartYScroll	; 2/3
    338  1c8a		       a9 88		      lda	#.SCRL_DOWN_BIT	; 2 = 22    yes, scroll down
    339  1c8c				   .startYScroll
    340  1c8c		       29 0c		      and	#.SCRL_Y_BITS >> 4	; 2
    341  1c8e		       05 98		      ora	scrollBits	; 3
    342  1c90		       85 98		      sta	scrollBits	; 3 =	8
    343  1c92				   .skipStartYScroll
    344  1c92
    345  1c92							; do vertical scrolling:
    346  1c92		       a5 98		      lda	scrollBits	; 3
    347  1c94		       29 cc		      and	#.SCRL_Y_BITS	; 2
    348  1c96		       f0 23		      beq	.skipYScroll	; 2/3
    349  1c98		       29 88		      and	#.SCRL_DOWN_BIT	; 2
    350  1c9a		       d0 0c		      bne	.yScrollDown	; 2/3=11/12
    351  1c9c
    352  1c9c							; scroll up
    353  1c9c		       a5 96		      lda	BoardScrollY	; 3
    354  1c9e		       f0 15		      beq	.stopYScroll	; 2
    355  1ca0		       c6 96		      dec	BoardScrollY	; 5
    356  1ca2		       c0 01		      cpy	#.SCRL_STOP_UP-1	; 2
    357  1ca4		       10 0f		      bpl	.stopYScroll	; 2/3=15
    358  1ca6		       30 13		      bmi	.skipYScroll	; 3
    359  1ca8							;---------------------------------------
    360  1ca8				   .yScrollDown
    361  1ca8		       a6 96		      ldx	BoardScrollY	; 3
    362  1caa		       e8		      inx		; 2
    363  1cab		       e4 95		      cpx	BoardEdge_Bottom	;     ; 3
    364  1cad		       10 06		      bpl	.stopYScroll	; 2/3
    365  1caf		       86 96		      stx	BoardScrollY	; 3
    366  1cb1		       c0 07		      cpy	#.SCRL_STOP_DOWN+1	; 2
    367  1cb3		       10 06		      bpl	.skipYScroll	; 2/3=17/18
    368  1cb5				   .stopYScroll
    369  1cb5		       a5 98		      lda	scrollBits	; 3
    370  1cb7		       29 f3		      and	#(~(.SCRL_Y_BITS >> 4))	; 2
    371  1cb9		       85 98		      sta	scrollBits	; 3 =	8
    372  1cbb				   .skipYScroll
    373  1cbb							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    374  1cbb
    375  1cbb		       60	   EarlyAbortx rts		; 6 =	6
    376  1cbc							; total: 5+67*2+6 = 145
    377  1cbc
    378  1cbc							;------------------------------------------------------------------------------
    379  1cbc
    380  1cbc
    381  1cbc
    382  1cbc							; worst case time from positive last check to rts: 123
    383  1cbc							; cycles until 0-check: 15
    384  1cbc							; minimum cycles available after last positive check until timer turns 0: (MINIMUM_SORT_TIME-1)*64+1
    385  1cbc							; MINIMUM_SORT_TIME = 3 = 129
    386  1cbc							; MINIMUM_SORT_TIME = 4 = 193 <- ok
    387  1cbc
    388  1cbc							;------------------------------------------------------------------------------
    389  1cbc
    390  1cbc							; This is a GOOD home for these tables.
    391  1cbc
      0  1cbc					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  1cbc		       00 03	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  1cbc					      SUBROUTINE
      3  1cbc				   TS_PhaseVectorLO
    393  1cbc
    394  1cbc							; Gives LO byte of addresses of subroutines for timeslice processing
    395  1cbc
    396  1cbc		       4d		      .byte.b	<ProcessObjStack
    397  1cbd		       a4		      .byte.b	<DrawFullScreen
    398  1cbe		       83		      .byte.b	<BuildDrawStack
    399  1cbf		       8a		      .byte.b	<DrawAIntoStack
    400  1cc0		       90		      .byte.b	<SwitchObjects
    401  1cc1
    402  1cc1				   TS_PhaseVectorHI
    403  1cc1
    404  1cc1							; Gives HI byte of addresses of subroutines for timeslice processing
    405  1cc1
    406  1cc1		       f8		      .byte.b	>ProcessObjStack
    407  1cc2		       f2		      .byte.b	>DrawFullScreen
    408  1cc3		       fa		      .byte.b	>BuildDrawStack
    409  1cc4		       fa		      .byte.b	>DrawAIntoStack
    410  1cc5		       f8		      .byte.b	>SwitchObjects
    411  1cc6
    412  1cc6				   TS_PhaseBank
    413  1cc6
    414  1cc6							; Gives bank of subroutines for timeslice processing
    415  1cc6
    416  1cc6		       0f		      .byte.b	BANK_ProcessObjStack
    417  1cc7		       09		      .byte.b	BANK_DrawFullScreen
    418  1cc8		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    419  1cc9		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    420  1cca		       0f		      .byte.b	BANK_SwitchObjects
    421  1ccb
    422  1ccb							;------------------------------------------------------------------------------
    423  1ccb		       02 02	   lookColour2 .byte.b	$02, $02
    424  1ccd		       04 04		      .byte.b	$04, $04
    425  1ccf
    426  1ccf				   OverscanTime
    427  1ccf		       33 33		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    428  1cd1		       46 33		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    429  1cd3
    430  1cd3
    431  1cd3
    432  1cd3
      0  1cd3					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  1cd3		       00 03	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  1cd3					      SUBROUTINE
      3  1cd3				   PostScreenCleanup
    434  1cd3
    435  1cd3		       c8		      iny		; --> 0
    436  1cd4
    437  1cd4		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    438  1cd6							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    439  1cd6
    440  1cd6		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    441  1cd8							; TJ: no idea why, but you had removed it in revision 758 ;)
    442  1cd8							; completely accidental -- one of our cats may have deleted it.
    443  1cd8		       84 4e		      sty	PF1
    444  1cda		       84 4f		      sty	PF2
    445  1cdc		       84 5d		      sty	ENAM0
    446  1cde		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    447  1ce0		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    448  1ce2
    449  1ce2
    450  1ce2
    451  1ce2							; D1 VBLANK turns off beam
    452  1ce2							; It needs to be turned on 37 scanlines later
    453  1ce2
    454  1ce2		       a9 42		      lda	#%01000010	; bit6 is not required
    455  1ce4		       85 41		      sta	VBLANK	; end of screen - enter blanking
    456  1ce6
    457  1ce6							;------------------------------------------------------------------------------
    458  1ce6							; This is where the PAL system has a bit of extra time on a per-frame basis.
    459  1ce6
    460  1ce6		       a6 81		      ldx	Platform
    461  1ce8		       bd cf f4 	      lda	OverscanTime,x
    462  1ceb		       8d 96 02 	      sta	TIM64T
    463  1cee
    464  1cee							; Background colour priorities. Increasing order of priority...
    465  1cee							;	black -- nothing happening
    466  1cee							;	looking around			     lookingAround<0		     BLUE
    467  1cee							;	when paused			     gameMode... BIT7		     RED
    468  1cee							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    469  1cee
    470  1cee
    471  1cee							;		  lda LookingAround
    472  1cee							;		  bpl nolooker			  ; if not looking around, that will do nicely
    473  1cee							;		  ldy #0 ;sok
    474  1cee							;;		   ldy lookColour2,x		   ; otherwise, use the lookaround colour as the base
    475  1cee							;nolooker	  sty BGColour			  ; 'BASE' colour pause reverts TO when unpaused
    476  1cee
    477  1cee		       a5 b8		      lda	ThrottleSpeed
    478  1cf0		       18		      clc
    479  1cf1		       65 b7		      adc	Throttle
    480  1cf3		       b0 02		      bcs	noVerflo
    481  1cf5		       85 b7		      sta	Throttle
    482  1cf7				   noVerflo
    483  1cf7
    484  1cf7
    485  1cf7							;----------------------------------------------------------------------------------------------
    486  1cf7							; handle pause button for 2600 and 7800
    487  1cf7
    488  1cf7							; Timings:  NOT including palette setting or platform detect
    489  1cf7							; 2600:     no button press:	 11 cycles
    490  1cf7							;	     with button press:  21 cycles
    491  1cf7							; 7800      no button press:	 16 cycles
    492  1cf7							;	     with button press:  21 cycles
    493  1cf7
    494  1cf7
    495  1cf7
    496  1cf7		       00 08	   BW_SWITCH  =	$08	; NOTE: Shares bit position with SWCHB COLOUR/B&W SWITCH
    497  1cf7
    498  1cf7		       24 80		      bit	gameMode
    499  1cf9		       50 0b		      bvc	.pause7800	; 7800 platform
    500  1cfb
    501  1cfb							; 2600 pause logic...
    502  1cfb
    503  1cfb		       ad 82 02 	      lda	SWCHB
    504  1cfe		       45 80		      eor	gameMode
    505  1d00		       29 08		      and	#BW_SWITCH
    506  1d02		       f0 17		      beq	.setPauseCol	; no different to original state = no pause change
    507  1d04		       d0 0f		      bne	.buttonDown	; unconditional
    508  1d06
    509  1d06							; 7800 pause logic...
    510  1d06
    511  1d06							; When the button is pressed, we check if it's the FIRST time it's pressed.
    512  1d06							; This FIRST time is indicated by the PFLAG7800 being clear.  If it's the first time, we toggle the pause
    513  1d06							; flag (BIT6) AND we toggle the PFLAG7800 so continued button-down does nothing.  When the button is
    514  1d06							; released, then we again toggle the PFLAG7800, allowing a FIRST time check once again, when the button
    515  1d06							; is next pressed.
    516  1d06
    517  1d06		       a9 08	   .pause7800 lda	#BW_SWITCH
    518  1d08		       2c 82 02 	      bit	SWCHB
    519  1d0b		       f0 04		      beq	.pausePress
    520  1d0d		       05 80		      ora	gameMode	; not pressed, so enable first time press
    521  1d0f		       d0 08		      bne	.fixPause	; unconditional
    522  1d11
    523  1d11		       24 80	   .pausePress bit	gameMode
    524  1d13		       f0 06		      beq	.setPauseCol	; NOT the first time in pause - so do nothing new
    525  1d15
    526  1d15							; Button is down, and we have detected it as a FIRST-TIME button press.
    527  1d15
    528  1d15		       45 80	   .buttonDown eor	gameMode	; toggle first time flag(7800) or current switch state(2600)
    529  1d17		       49 80		      eor	#GAMEMODE_PAUSED	; toggle pause flag
    530  1d19		       85 80	   .fixPause  sta	gameMode
    531  1d1b
    532  1d1b		       a5 80	   .setPauseCol lda	gameMode	; are we paused?
    533  1d1d		       10 07		      bpl	.exitPause	; only show pause colour when actually paused
    534  1d1f
    535  1d1f		       a6 81		      ldx	Platform
    536  1d21		       bd 8e f5 	      lda	pscol,x
    537  1d24		       85 b3		      sta	BGColour	; set main screen background colour.  RED is paused.
    538  1d26
    539  1d26				   .exitPause
    540  1d26
    541  1d26							;----------------------------------------------------------------------------------------------
    542  1d26
    543  1d26							; has to be done AFTER screen display, because it disables the effect!
    544  1d26		       a5 82		      lda	rnd	; 3	 randomly reposition the Cosmic Ark missile
    545  1d28		       85 62		      sta	HMM0	; 3	 this assumes that HMOVE is called at least once/frame
    546  1d2a
    547  1d2a							; "Flash" has highest BG colour priority
    548  1d2a
    549  1d2a		       a6 c6		      ldx	ColourTimer
    550  1d2c		       f0 04		      beq	noFlashBG
    551  1d2e		       c6 c6		      dec	ColourTimer
    552  1d30		       a2 c0		      ldx	#$C0
    553  1d32		       86 b3	   noFlashBG  stx	BGColour
    554  1d34
    555  1d34							; Handle the player joystick reading. We do it *every frame* so that we can incorporate a two-frame
    556  1d34							; buffer.  This is designed to give a little better responsiveness to the 'quick tap' movement.
    557  1d34
    558  1d34		       a5 90		      lda	BufferedJoystick	; previous frame
    559  1d36		       85 91		      sta	BufferedJoystick+1	; -> buffered
    560  1d38
    561  1d38
    562  1d38							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    563  1d38							; P2 is shifted UP, so we don't need to worry in usage elsewhere (it's same format as a P1 joystick)
    564  1d38
    565  1d38		       a5 99		      lda	whichPlayer	; 3
    566  1d3a		       25 a9		      and	jtoggle	; 3
    567  1d3c		       aa		      tax		; 2
    568  1d3d
    569  1d3d		       b5 4c		      lda	INPT4,x	; 4
    570  1d3f		       25 92		      and	BufferedButton
    571  1d41		       85 92		      sta	BufferedButton	; 3 = 15
    572  1d43
    573  1d43		       ad 80 02 	      lda	SWCHA	; 4
    574  1d46
    575  1d46		       ca		      dex		; 2
    576  1d47		       30 04		      bmi	notP2	; 2/3= 8/9
    577  1d49
    578  1d49		       0a		      asl		; 2
    579  1d4a		       0a		      asl		; 2
    580  1d4b		       0a		      asl		; 2
    581  1d4c		       0a		      asl		; 2 =	8
    582  1d4d		       85 90	   notP2      sta	BufferedJoystick	; 3
    583  1d4f
    584  1d4f
    585  1d4f							; "Scoring timer" reset stomp comment
    586  1d4f
    587  1d4f		       a5 c8		      lda	scoringTimer
    588  1d51		       f0 0a		      beq	timer0now
    589  1d53		       c6 c8		      dec	scoringTimer
    590  1d55		       d0 06		      bne	timer0now
    591  1d57		       a5 c9		      lda	scoringFlags
    592  1d59		       29 fc		      and	#<(~DISPLAY_FLAGS)	;	 switches to time display
    593  1d5b		       85 c9		      sta	scoringFlags
    594  1d5d				   timer0now
    595  1d5d
    596  1d5d							; fall through
    597  1d5d
    598  1d5d							;-------------------------------------------------------------------------------------
    599  1d5d							; Player animation happens *every* frame so that we get good animation speeds.  Note that
    600  1d5d							; the player animation consists of running a small animation 'program', and then actually drawing
    601  1d5d							; the player.	The draw is the neat bit, because all it does is update some self-modifying pointers
    602  1d5d							; inside the actual draw kernel in the appropriate bank.
    603  1d5d
    604  1d5d
      0  1d5d					      DEFINE_SUBROUTINE	AnimatePlayers	; in GENERIC_BANK_1
      1  1d5d		       00 03	   BANK_AnimatePlayers =	_CURRENT_BANK
      2  1d5d					      SUBROUTINE
      3  1d5d				   AnimatePlayers
    606  1d5d
    607  1d5d							; Optimised 7/1/2012 -- single page tables
    608  1d5d
    609  1d5d							; This interesting code performs the animations for the player(s) and sets the
    610  1d5d							; pointers INSIDE the row bank for the draw code to point to the correct player
    611  1d5d							; shape.  Kind of neat, as it doesn't require any shape copying (=speed!)
    612  1d5d
    613  1d5d
    614  1d5d							; Cycle the player through his animation list.  The animation of a player is a direct
    615  1d5d							; pointer to the actual shape used to display the player.  This shape is in turn
    616  1d5d							; written to the current bank's self-modifying locations for the draw.  Since
    617  1d5d							; we are effectively drawing from this current bank, the same code can be used
    618  1d5d							; to 'undraw' the player as required.
    619  1d5d
    620  1d5d
    621  1d5d							; x = player index
    622  1d5d							; sets ManAnimation = FRAME to display for player
    623  1d5d							; ManAnimation = index of player program into Manimate list
    624  1d5d
    625  1d5d		       24 80		      bit	gameMode
    626  1d5f		       30 2c		      bmi	AnimationOK	; don't animate during pause
    627  1d61
    628  1d61		       c6 a0		      dec	ManDelayCount
    629  1d63		       10 28		      bpl	AnimationOK
    630  1d65
    631  1d65		       a4 a1	   ReloadAnimation ldy	ManAnimation
    632  1d67		       b9 00 f7    ContinueAnim lda	Manimate,y	; delay count
    633  1d6a		       d0 07		      bne	NewFrameOK
    634  1d6c		       b9 01 f7 	      lda	Manimate+1,y
    635  1d6f		       a8		      tay
    636  1d70		       4c 67 f5 	      jmp	ContinueAnim
    637  1d73
    638  1d73		       10 0d	   NewFrameOK bpl	doDelay
    639  1d75
    640  1d75		       c8		      iny		; handle a REFLECT
    641  1d76		       a5 a4		      lda	ManLastDirection
    642  1d78		       29 f7		      and	#%11110111
    643  1d7a		       19 00 f7 	      ora	Manimate,y
    644  1d7d		       85 a4		      sta	ManLastDirection
    645  1d7f
    646  1d7f		       c8		      iny
    647  1d80		       d0 e5		      bne	ContinueAnim
    648  1d82
    649  1d82		       85 a0	   doDelay    sta	ManDelayCount
    650  1d84
    651  1d84		       c8		      iny
    652  1d85		       b9 00 f7 	      lda	Manimate,y
    653  1d88		       85 a3		      sta	ManAnimationFrameLO
    654  1d8a
    655  1d8a		       c8		      iny
    656  1d8b		       84 a1		      sty	ManAnimation
    657  1d8d
    658  1d8d		       60	   AnimationOK rts
    659  1d8e
    660  1d8e
    661  1d8e
    662  1d8e		       40 40	   pscol      .byte.b	$40, $40
    663  1d90		       60 60		      .byte.b	$60, $60
    664  1d92
    665  1d92							;------------------------------------------------------------------------------
    666  1d92
------- FILE i2c_v2.2.inc LEVEL 3 PASS 4
      0  1d92					      include	"i2c_v2.2.inc"
      1  1d92							;
      2  1d92							; i2c_v2.2.inc
      3  1d92							;
      4  1d92							;
      5  1d92							; AtariVox EEPROM Driver
      6  1d92							;
      7  1d92							; By Alex Herbert, 2004
      8  1d92							;
      9  1d92							; Optimisations by Thomas Jentzsch, 2006/2008
     10  1d92							;
     11  1d92
     12  1d92
     13  1d92							; I/O Constants
     14  1d92
     15  1d92		       00 04	   I2C_SDA_MASK equ	$04
     16  1d92		       00 08	   I2C_SCL_MASK equ	$08
     17  1d92
     18  1d92
     19  1d92							; Signalling Macros
     20  1d92
     21  1d92							;  MAC     I2C_SCL_0
     22  1d92							;    lda     #$00
     23  1d92							;    sta     SWCHA
     24  1d92							;  ENDM
     25  1d92
     26  1d92							;  MAC     I2C_SCL_1
     27  1d92							;    lda     #I2C_SCL_MASK
     28  1d92							;    sta     SWCHA
     29  1d92							;  ENDM
     30  1d92
     31  1d92							;  MAC     I2C_SDA_IN
     32  1d92							;    lda     #I2C_SCL_MASK
     33  1d92							;    sta     SWACNT
     34  1d92							;  ENDM
     35  1d92
     36  1d92							;  MAC     I2C_SDA_OUT
     37  1d92							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  1d92							;    sta     SWACNT
     39  1d92							;  ENDM
     40  1d92
     41  1d92
     42  1d92					      MAC	i2c_start
     43  1d92							; I2C_SCL_1
     44  1d92					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  1d92					      sta	SWCHA	; 4
     46  1d92							; I2C_SDA_OUT
     47  1d92					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  1d92					      sta	SWACNT	; 4
     49  1d92							; total: 12 cycles
     50  1d92					      ENDM
     51  1d92
     52  1d92
     53  1d92					      MAC	i2c_txbit
     54  1d92							; I2C_SCL_0
     55  1d92					      lda	#%0011	; 2
     56  1d92					      sta	SWCHA	; 4
     57  1d92							; set bit
     58  1d92					      adc	#%1000	; 2
     59  1d92					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  1d92							; I2C_SCL_1
     61  1d92					      lda	#I2C_SCL_MASK	; 2
     62  1d92					      sta	SWCHA	; 4
     63  1d92							; total: 18 cycles
     64  1d92					      ENDM
     65  1d92
     66  1d92
     67  1d92					      MAC	i2c_txnack
     68  1d92							; I2C_SCL_0
     69  1d92					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  1d92					      sta	SWCHA	; 4
     71  1d92							; I2C_SDA_IN
     72  1d92					      lsr		; 2	     I2C_SCL_MASK
     73  1d92					      sta	SWACNT	; 4
     74  1d92							; I2C_SCL_1
     75  1d92					      nop		; 2	     required for timing!
     76  1d92					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  1d92							; total: 18 cycles
     78  1d92					      ENDM
     79  1d92
     80  1d92
     81  1d92							; Subroutine Macros
     82  1d92
     83  1d92					      MAC	i2c_subs
     84  1d92
     85  1d92				   i2c_startread
     86  1d92							; use V to flag if previous byte needs ACK
     87  1d92					      ldy	#%10100001	; 2	     eeprom read command
     88  1d92					      .byte	$2c	; 2
     89  1d92				   i2c_startwrite
     90  1d92					      ldy	#%10100000	; 2	     eeprom write command
     91  1d92					      I2C_START		;12	     start signal (clears V flag)
     92  1d92					      tya		; 2 = 16
     93  1d92				   i2c_txbyte
     94  1d92					      eor	#$ff	; 2	     invert data byte
     95  1d92					      sec		; 2
     96  1d92					      rol		; 2 =	6    shift loop bit into a
     97  1d92				   i2c_txbyteloop
     98  1d92					      tay		; 2
     99  1d92					      I2C_TXBIT		;18	     transmit
    100  1d92					      tya		; 2
    101  1d92					      asl		; 2	     shift next bit into C
    102  1d92					      bne	i2c_txbyteloop	; 2= 26/27
    103  1d92
    104  1d92							; receive acknowledge bit
    105  1d92
    106  1d92					      beq	i2c_rxbit	;43 = 43
    107  1d92							; i2c_txbyte: 264 cycles
    108  1d92							;-------------------------------------------------------------------------------
    109  1d92
    110  1d92				   i2c_rxbyte
    111  1d92					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  1d92					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  1d92
    114  1d92				   i2c_rxskipack
    115  1d92					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  1d92
    117  1d92					      lda	#1	; 2
    118  1d92				   i2c_rxbyteloop
    119  1d92					      tay		; 2 =	2
    120  1d92				   i2c_rxbit		;	     receive bit in C
    121  1d92					      I2C_TXNACK		;18 = 18
    122  1d92
    123  1d92					      lda	SWCHA	; 4
    124  1d92					      lsr		; 2
    125  1d92					      lsr		; 2
    126  1d92					      lsr		; 2 = 10    C = SDA
    127  1d92
    128  1d92					      tya		; 2
    129  1d92					      rol		; 2	     rotate into Y
    130  1d92					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  1d92
    132  1d92							; received byte in A
    133  1d92					      rts		; 6 =	6
    134  1d92							; i2c_rxbit:  40 cycles
    135  1d92							; i2c_rxbyte: 310/333 cycles
    136  1d92							;-------------------------------------------------------------------------------
    137  1d92
    138  1d92				   i2c_stopread
    139  1d92					      bvc	i2c_stopwrite	; 2
    140  1d92					      ldy	#$80	; 2
    141  1d92					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  1d92
    143  1d92				   i2c_stopwrite
    144  1d92					      jsr	i2c_txack	;30
    145  1d92
    146  1d92							; return port to input mode
    147  1d92					      lda	#0	; 2	     0
    148  1d92					      sta	SWACNT	; 4
    149  1d92					      rts		; 6 = 12
    150  1d92							; i2c_stopread:  45/92
    151  1d92							; i2c_stopwrite: 42
    152  1d92							;-------------------------------------------------------------------------------
    153  1d92
    154  1d92				   i2c_txack
    155  1d92							; I2C_SCL_0
    156  1d92					      lda	#0	; 2	     $00
    157  1d92					      sta	SWCHA	; 4
    158  1d92							; I2C_SDA_OUT
    159  1d92					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  1d92					      sta	SWACNT	; 4
    161  1d92							; I2C_SCL_1
    162  1d92					      asl		; 2	     I2C_SCL_MASK
    163  1d92					      sta	SWCHA	; 4
    164  1d92
    165  1d92					      rts		; 6
    166  1d92							; total: 24 cycles
    167  1d92							;-------------------------------------------------------------------------------
    168  1d92
    169  1d92					      ENDM
    170  1d92
    171  1d92
    172  1d92
------- FILE BANK_GENERIC.asm
    668  1d92
      0  1d92					      i2c_subs
      1  1d92
      2  1d92				   i2c_startread
      3  1d92
      4  1d92		       a0 a1		      ldy	#%10100001
      5  1d94		       2c		      .byte.b	$2c
      6  1d95				   i2c_startwrite
      7  1d95		       a0 a0		      ldy	#%10100000
      0  1d97					      I2C_START
      1  1d97
      2  1d97		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  1d99		       8d 80 02 	      sta	SWCHA
      4  1d9c
      5  1d9c		       4a		      lsr
      6  1d9d		       8d 81 02 	      sta	SWACNT
      7  1da0
      9  1da0		       98		      tya
     10  1da1				   i2c_txbyte
     11  1da1		       49 ff		      eor	#$ff
     12  1da3		       38		      sec
     13  1da4		       2a		      rol
     14  1da5				   i2c_txbyteloop
     15  1da5		       a8		      tay
      0  1da6					      I2C_TXBIT
      1  1da6
      2  1da6		       a9 03		      lda	#%0011
      3  1da8		       8d 80 02 	      sta	SWCHA
      4  1dab
      5  1dab		       69 08		      adc	#%1000
      6  1dad		       8d 81 02 	      sta	SWACNT
      7  1db0
      8  1db0		       a9 08		      lda	#I2C_SCL_MASK
      9  1db2		       8d 80 02 	      sta	SWCHA
     10  1db5
     17  1db5		       98		      tya
     18  1db6		       0a		      asl
     19  1db7		       d0 ec		      bne	i2c_txbyteloop
     20  1db9
     21  1db9
     22  1db9
     23  1db9		       f0 0b		      beq	i2c_rxbit
     24  1dbb
     25  1dbb
     26  1dbb
     27  1dbb				   i2c_rxbyte
     28  1dbb		       50 03		      bvc	i2c_rxskipack
     29  1dbd		       20 ee f5 	      jsr	i2c_txack
     30  1dc0
     31  1dc0				   i2c_rxskipack
     32  1dc0		       2c bb f5 	      bit	i2c_rxbyte
     33  1dc3
     34  1dc3		       a9 01		      lda	#1
     35  1dc5				   i2c_rxbyteloop
     36  1dc5		       a8		      tay
     37  1dc6				   i2c_rxbit
      0  1dc6					      I2C_TXNACK
      1  1dc6
      2  1dc6		       a9 10		      lda	#I2C_SCL_MASK*2
      3  1dc8		       8d 80 02 	      sta	SWCHA
      4  1dcb
      5  1dcb		       4a		      lsr
      6  1dcc		       8d 81 02 	      sta	SWACNT
      7  1dcf
      8  1dcf		       ea		      nop
      9  1dd0		       8d 80 02 	      sta	SWCHA
     10  1dd3
     39  1dd3
     40  1dd3		       ad 80 02 	      lda	SWCHA
     41  1dd6		       4a		      lsr
     42  1dd7		       4a		      lsr
     43  1dd8		       4a		      lsr
     44  1dd9
     45  1dd9		       98		      tya
     46  1dda		       2a		      rol
     47  1ddb		       90 e8		      bcc	i2c_rxbyteloop
     48  1ddd
     49  1ddd
     50  1ddd		       60		      rts
     51  1dde
     52  1dde
     53  1dde
     54  1dde
     55  1dde				   i2c_stopread
     56  1dde		       50 05		      bvc	i2c_stopwrite
     57  1de0		       a0 80		      ldy	#$80
     58  1de2		       20 c6 f5 	      jsr	i2c_rxbit
     59  1de5
     60  1de5				   i2c_stopwrite
     61  1de5		       20 ee f5 	      jsr	i2c_txack
     62  1de8
     63  1de8
     64  1de8		       a9 00		      lda	#0
     65  1dea		       8d 81 02 	      sta	SWACNT
     66  1ded		       60		      rts
     67  1dee
     68  1dee
     69  1dee
     70  1dee
     71  1dee				   i2c_txack
     72  1dee
     73  1dee		       a9 00		      lda	#0
     74  1df0		       8d 80 02 	      sta	SWCHA
     75  1df3
     76  1df3		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  1df5		       8d 81 02 	      sta	SWACNT
     78  1df8
     79  1df8		       0a		      asl
     80  1df9		       8d 80 02 	      sta	SWCHA
     81  1dfc
     82  1dfc		       60		      rts
     83  1dfd
     84  1dfd
     85  1dfd
    670  1dfd
    671  1dfd				   HandleSaveKey SUBROUTINE
    672  1dfd
    673  1dfd		       2f 00	   SAVEKEY_ADR =	$2F00	;	     tentative address for Sokoban (64 bytes)
    674  1dfd
    675  1dfd							;------------------------------------------------------------------------------
      0  1dfd					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  1dfd		       00 03	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  1dfd					      SUBROUTINE
      3  1dfd				   ReadSaveKey
    677  1dfd
    678  1dfd							; assume no SaveKey found:
    679  1dfd		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    680  1dff		       85 df		      sta	highScoreSK+2	; 3
    681  1e01
    682  1e01							; setup SaveKey:
    683  1e01		       a5 e0		      lda	startingLevel	; 3	     load start levelX*5 and level
    684  1e03		       a6 b5		      ldx	level	; 3
    685  1e05		       20 3e f6 	      jsr	SetupSaveKey	;6+853
    686  1e08		       90 52		      bcc	NoSKfound	; 2/3
    687  1e0a
    688  1e0a							;    lda     #$34
    689  1e0a							;    sta     COLUBK
    690  1e0a
    691  1e0a							; start read
    692  1e0a		       20 e5 f5 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    693  1e0d		       20 92 f5 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    694  1e10
    695  1e10							; read high score:
    696  1e10		       a2 02		      ldx	#3-1	; 2 = 1187
    697  1e12				   .loopRead
    698  1e12		       20 bb f5 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    699  1e15		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    700  1e17		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    701  1e19		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    702  1e1b				   .skipEmpty
    703  1e1b		       95 dd		      sta	highScoreSK,x	; 4
    704  1e1d		       ca		      dex		; 2
    705  1e1e		       10 f2		      bpl	.loopRead	; 2/3= 354
    706  1e20
    707  1e20							; stop read:
    708  1e20		       4c de f5 	      jmp	i2c_stopread	;3+92=95    terminate read
    709  1e23
    710  1e23							;------------------------------------------------------------------------------
      0  1e23					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  1e23		       00 03	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  1e23					      SUBROUTINE
      3  1e23				   WriteSaveKey
    712  1e23
    713  1e23							; check if new high score:
    714  1e23		       a6 dd		      ldx	highScoreSK	; 3
    715  1e25		       e8		      inx		; 2
    716  1e26		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    717  1e28
    718  1e28							; setup SaveKey:
    719  1e28		       a5 e0		      lda	startingLevel	; 3	     load start levelX*5 and level
    720  1e2a		       a6 e1		      ldx	startLevel	; 3
    721  1e2c		       20 3e f6 	      jsr	SetupSaveKey	; 6+853
    722  1e2f		       90 2b		      bcc	NoSKfound	; 2/3
    723  1e31
    724  1e31							;    lda     #$64
    725  1e31							;    sta     COLUBK
    726  1e31
    727  1e31							; write high score:
    728  1e31		       a2 02		      ldx	#3-1	; 2 = 841
    729  1e33				   .loopWrite
    730  1e33		       b5 dd		      lda	highScoreSK,x	; 4
    731  1e35		       20 a1 f5 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    732  1e38		       ca		      dex		; 2
    733  1e39		       10 f8		      bpl	.loopWrite	; 2/3= 837
    734  1e3b
    735  1e3b							; stop write:
    736  1e3b		       4c e5 f5 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    737  1e3e
    738  1e3e
    739  1e3e							;------------------------------------------------------------------------------
      0  1e3e					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  1e3e		       00 03	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  1e3e					      SUBROUTINE
      3  1e3e				   SetupSaveKey
    741  1e3e
    742  1e3e							; calculate slot;
    743  1e3e							; a = levelX
    744  1e3e							; x = level (0..4)
    745  1e3e		       85 e2		      sta	offsetSK	; 3
    746  1e40		       8a		      txa		; 2
    747  1e41		       18		      clc		; 2
    748  1e42		       65 e2		      adc	offsetSK	; 3
    749  1e44		       85 e2		      sta	offsetSK	; 3
    750  1e46		       0a		      asl		; 2	     multiply by 3
    751  1e47		       65 e2		      adc	offsetSK	; 3
    752  1e49		       69 00		      adc	#<SAVEKEY_ADR	; 2
    753  1e4b		       aa		      tax		; 2 = 22
    754  1e4c							; detect SaveKey:
    755  1e4c		       20 95 f5 	      jsr	i2c_startwrite	;6+280
    756  1e4f		       d0 0a		      bne	.exitSK	; 2/3
    757  1e51
    758  1e51							; setup address:
    759  1e51		       b8		      clv		; 2
    760  1e52		       a9 2f		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    761  1e54		       20 a1 f5 	      jsr	i2c_txbyte	;6+264
    762  1e57		       8a		      txa		; 2	     x = lower byte offset
    763  1e58		       4c a1 f5 	      jmp	i2c_txbyte	;3+264      returns C==1
    764  1e5b
    765  1e5b				   .exitSK
    766  1e5b		       18		      clc
    767  1e5c				   NoSKfound
    768  1e5c		       60		      rts
    769  1e5c					      ENDIF
    770  1e5d
    771  1f00		       00 00 00 00*	      align	256
    772  1f00
    773  1f00				   Manimate
    774  1f00				   AnimateSTAND
    775  1f00				   AnimateRIGHT
    776  1f00				   AnimateLEFT
    777  1f00				   AnimateUP
    778  1f00				   AnimateSTOPPED
    779  1f00		       7f		      .byte.b	127
    780  1f01		       93		      .byte.b	<PLAYER_RIGHT0	;PLAYER_STAND
    781  1f02							;.byte 10
    782  1f02							;.byte < PLAYER_BLINK
    783  1f02							;.byte 127
    784  1f02							;.byte < PLAYER_STAND
    785  1f02							;.byte 0
    786  1f02							;.word AnimateTAP
    787  1f02
    788  1f02				   AnimateTAP
    789  1f02							;.byte 128, %0 		  ; reflect off, always tap with left foot
    790  1f02							;.byte 8
    791  1f02							;.byte < PLAYER_TAP0
    792  1f02							;.byte 8
    793  1f02							;.byte < PLAYER_TAP1
    794  1f02							;.byte 8
    795  1f02							;.byte < PLAYER_TAP0
    796  1f02							;.byte 8
    797  1f02							;.byte < PLAYER_TAP1
    798  1f02							;.byte 8
    799  1f02							;.byte < PLAYER_TAP0
    800  1f02							;.byte 8
    801  1f02							;.byte < PLAYER_TAP1
    802  1f02		       00		      .byte.b	0
    803  1f03		       00		      .byte.b	AnimateSTAND-Manimate	;word AnimateSTAND
    804  1f04
    805  1f04							;AnimateRIGHT
    806  1f04		       80 00		      .byte.b	128, %0	; reflect off
    807  1f06		       05		      .byte.b	5
    808  1f07		       93		      .byte.b	< PLAYER_RIGHT0
    809  1f08		       05		      .byte.b	5
    810  1f09		       a8		      .byte.b	< PLAYER_RIGHT1
    811  1f0a		       00		      .byte.b	0
    812  1f0b		       00		      .byte.b	AnimateRIGHT-Manimate	;word AnimateRIGHT
    813  1f0c
    814  1f0c							;AnimateLEFT
    815  1f0c		       80 08		      .byte.b	128, %1000	; reflect ON
    816  1f0e		       05		      .byte.b	5
    817  1f0f		       93		      .byte.b	< PLAYER_RIGHT0
    818  1f10		       05		      .byte.b	5
    819  1f11		       a8		      .byte.b	< PLAYER_RIGHT1
    820  1f12		       00		      .byte.b	0
    821  1f13		       00		      .byte.b	AnimateLEFT-Manimate	;word AnimateLEFT
    822  1f14
    823  1f14							;AnimateUP
    824  1f14							;    .byte 128, %0		   ; reflect off
    825  1f14							;    .byte 5
    826  1f14							;    .byte < PLAYER_TAP
    827  1f14							;    .byte 128, %1000
    828  1f14							;    .byte 5
    829  1f14							;    .byte < PLAYER_TAP
    830  1f14							;    .byte 0
    831  1f14							;    .word AnimateUP
    832  1f14
    833  1f14							;AnimateUP
    834  1f14		       05		      .byte.b	5
    835  1f15		       93		      .byte.b	< PLAYER_RIGHT0
    836  1f16		       05		      .byte.b	5
    837  1f17		       a8		      .byte.b	< PLAYER_RIGHT1
    838  1f18		       00		      .byte.b	0
    839  1f19		       00		      .byte.b	AnimateUP-Manimate	;word AnimateUP
    840  1f1a
    841  1f1a				   AnimateBLANK
    842  1f1a		       7f		      .byte.b	127
    843  1f1b		       7e		      .byte.b	< PLAYER_BLANK
    844  1f1c		       00		      .byte.b	0
    845  1f1d		       1a		      .byte.b	AnimateBLANK-Manimate	;word AnimateBLANK
    846  1f1e
    847  1f1e				   AnimateEND
      0  1f1e					      CHECKPAGEX	Manimate, "AnimateEND @ BANK_GENERIC"
      9  1f1e					      LIST	ON
    849  1f1e
    850  1f1e
      0  1f1e					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  1f1e		       07 1e	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $71e , FREE= $e2
      2  1f1e					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1f1e				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1f1e				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1f1e				  -	      ERR
      6  1f1e					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS1.asm LEVEL 2 PASS 4
      0  1f1e					      include	"BANK_LEVELS1.asm"
      1  1f1e							;    Sokoboo - a Sokoban implementation
      2  1f1e							;    using a generic tile-based display engine for the Atari 2600
      3  1f1e							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  1f1e							;
      5  1f1e							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  1f1e							;
      7  1f1e							;    Code related to the generic tile-based display engine was developed by
      8  1f1e							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  1f1e							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  1f1e							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  1f1e							;
     12  1f1e							;    Code related to music and sound effects uses the TIATracker music player
     13  1f1e							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  1f1e							;    directory for Apache licensing details.
     15  1f1e							;
     16  1f1e							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  1f1e							;    See the copyright notices in the License directory for a list of level
     18  1f1e							;    contributors.
     19  1f1e							;
     20  1f1e							;    Except where otherwise indicated, this software is released under the
     21  1f1e							;    following licensing arrangement...
     22  1f1e							;
     23  1f1e							;    This program is free software: you can redistribute it and/or modify
     24  1f1e							;    it under the terms of the GNU General Public License as published by
     25  1f1e							;    the Free Software Foundation, either version 3 of the License, or
     26  1f1e							;    (at your option) any later version.
     27  1f1e							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  1f1e
     29  1f1e							;    This program is distributed in the hope that it will be useful,
     30  1f1e							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  1f1e							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  1f1e							;    GNU General Public License for more details.
     33  1f1e
      0  1f1e					      NEWBANK	LEVELS1
      1  27d7 ????				      SEG	LEVELS1
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   LEVELS1    SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	LEVELS1
     35  2000
     36  2000							; "SOKWHOLE" collection...
     37  2000
      0  2000					      DEFL	_001_L, "3#|#@#|#$#|#.#|3#"
      0  2000					      START_LEVEL	_001_L
      1  2000				   LEVEL_START SET	*
      2  2000		       00 04	   BANK_LEVEL__001_L =	_CURRENT_BANK
      3  2000				   LEVEL__001_L SUBROUTINE
      4  2000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2000
      2  2000		       33 23 7c 23*	      .byte.b	"3#|#@#|#$#|#.#|3#",0
      0  2012					      END_LEVEL	_001_L
      1  2012		       00		      .byte.b	0
      2  2012		       00 13	   LEVEL_SIZE__001_L =	* - LEVEL_START
      3  2013					      IF	LEVEL_SIZE__001_L > MAX_LEVEL_SIZE
      4  2013				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_L
      5  2013					      ENDIF
      0  2013					      DEFL	_001_R, "5#|#.$@#|5#"
      0  2013					      START_LEVEL	_001_R
      1  2013				   LEVEL_START SET	*
      2  2013		       00 04	   BANK_LEVEL__001_R =	_CURRENT_BANK
      3  2013				   LEVEL__001_R SUBROUTINE
      4  2013				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2013
      2  2013		       35 23 7c 23*	      .byte.b	"5#|#.$@#|5#",0
      0  201f					      END_LEVEL	_001_R
      1  201f		       00		      .byte.b	0
      2  201f		       00 0d	   LEVEL_SIZE__001_R =	* - LEVEL_START
      3  2020				  -	      IF	LEVEL_SIZE__001_R > MAX_LEVEL_SIZE
      4  2020				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_R
      5  2020					      ENDIF
      0  2020					      DEFL	_002_L, "3#2-|#.3#|#*$-#|#2-@#|5#"
      0  2020					      START_LEVEL	_002_L
      1  2020				   LEVEL_START SET	*
      2  2020		       00 04	   BANK_LEVEL__002_L =	_CURRENT_BANK
      3  2020				   LEVEL__002_L SUBROUTINE
      4  2020				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2020
      2  2020		       33 23 32 2d*	      .byte.b	"3#2-|#.3#|#*$-#|#2-@#|5#",0
      0  2039					      END_LEVEL	_002_L
      1  2039		       00		      .byte.b	0
      2  2039		       00 1a	   LEVEL_SIZE__002_L =	* - LEVEL_START
      3  203a					      IF	LEVEL_SIZE__002_L > MAX_LEVEL_SIZE
      4  203a				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_L
      5  203a					      ENDIF
      0  203a					      DEFL	_002_R, "2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#"
      0  203a					      START_LEVEL	_002_R
      1  203a				   LEVEL_START SET	*
      2  203a		       00 04	   BANK_LEVEL__002_R =	_CURRENT_BANK
      3  203a				   LEVEL__002_R SUBROUTINE
      4  203a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  203a
      2  203a		       32 2d 35 23*	      .byte.b	"2-5#-|3#3-2#|#.*-#@-#|2#$3#-#|-#5-#|-7#",0
      0  2062					      END_LEVEL	_002_R
      1  2062		       00		      .byte.b	0
      2  2062		       00 29	   LEVEL_SIZE__002_R =	* - LEVEL_START
      3  2063					      IF	LEVEL_SIZE__002_R > MAX_LEVEL_SIZE
      4  2063				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_R
      5  2063					      ENDIF
      0  2063					      DEFL	_003_L, "4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-"
      0  2063					      START_LEVEL	_003_L
      1  2063				   LEVEL_START SET	*
      2  2063		       00 04	   BANK_LEVEL__003_L =	_CURRENT_BANK
      3  2063				   LEVEL__003_L SUBROUTINE
      4  2063				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2063
      2  2063		       34 2d 35 23*	      .byte.b	"4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-",0
      0  208f					      END_LEVEL	_003_L
      1  208f		       00		      .byte.b	0
      2  208f		       00 2d	   LEVEL_SIZE__003_L =	* - LEVEL_START
      3  2090					      IF	LEVEL_SIZE__003_L > MAX_LEVEL_SIZE
      4  2090				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_L
      5  2090					      ENDIF
      0  2090					      DEFL	_003_R, "9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-"
      0  2090					      START_LEVEL	_003_R
      1  2090				   LEVEL_START SET	*
      2  2090		       00 04	   BANK_LEVEL__003_R =	_CURRENT_BANK
      3  2090				   LEVEL__003_R SUBROUTINE
      4  2090				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2090
      2  2090		       39 23 7c 23*	      .byte.b	"9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-",0
      0  20ba					      END_LEVEL	_003_R
      1  20ba		       00		      .byte.b	0
      2  20ba		       00 2b	   LEVEL_SIZE__003_R =	* - LEVEL_START
      3  20bb				  -	      IF	LEVEL_SIZE__003_R > MAX_LEVEL_SIZE
      4  20bb				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_R
      5  20bb					      ENDIF
      0  20bb					      DEFL	_004_L, "5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-"
      0  20bb					      START_LEVEL	_004_L
      1  20bb				   LEVEL_START SET	*
      2  20bb		       00 04	   BANK_LEVEL__004_L =	_CURRENT_BANK
      3  20bb				   LEVEL__004_L SUBROUTINE
      4  20bb				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20bb
      2  20bb		       35 23 2d 7c*	      .byte.b	"5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-",0
      0  20de					      END_LEVEL	_004_L
      1  20de		       00		      .byte.b	0
      2  20de		       00 24	   LEVEL_SIZE__004_L =	* - LEVEL_START
      3  20df				  -	      IF	LEVEL_SIZE__004_L > MAX_LEVEL_SIZE
      4  20df				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_L
      5  20df					      ENDIF
      0  20df					      DEFL	_004_R, "-6#|-#4-#|2#-$*$#|#@$3.#|7#"
      0  20df					      START_LEVEL	_004_R
      1  20df				   LEVEL_START SET	*
      2  20df		       00 04	   BANK_LEVEL__004_R =	_CURRENT_BANK
      3  20df				   LEVEL__004_R SUBROUTINE
      4  20df				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20df
      2  20df		       2d 36 23 7c*	      .byte.b	"-6#|-#4-#|2#-$*$#|#@$3.#|7#",0
      0  20fb					      END_LEVEL	_004_R
      1  20fb		       00		      .byte.b	0
      2  20fb		       00 1d	   LEVEL_SIZE__004_R =	* - LEVEL_START
      3  20fc				  -	      IF	LEVEL_SIZE__004_R > MAX_LEVEL_SIZE
      4  20fc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_R
      5  20fc					      ENDIF
      0  20fc					      DEFL	_005_L, "3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-"
      0  20fc					      START_LEVEL	_005_L
      1  20fc				   LEVEL_START SET	*
      2  20fc		       00 04	   BANK_LEVEL__005_L =	_CURRENT_BANK
      3  20fc				   LEVEL__005_L SUBROUTINE
      4  20fc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20fc
      2  20fc		       33 2d 35 23*	      .byte.b	"3-5#|3-#.$-#|3-#.$-#|4#.#-#|#@$-*2-#|2#3-3#|-5#2-",0
      0  212e					      END_LEVEL	_005_L
      1  212e		       00		      .byte.b	0
      2  212e		       00 33	   LEVEL_SIZE__005_L =	* - LEVEL_START
      3  212f					      IF	LEVEL_SIZE__005_L > MAX_LEVEL_SIZE
      4  212f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_L
      5  212f					      ENDIF
      0  212f					      DEFL	_005_R, "6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-"
      0  212f					      START_LEVEL	_005_R
      1  212f				   LEVEL_START SET	*
      2  212f		       00 04	   BANK_LEVEL__005_R =	_CURRENT_BANK
      3  212f				   LEVEL__005_R SUBROUTINE
      4  212f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  212f
      2  212f		       36 23 32 2d*	      .byte.b	"6#2-|#2-@-2#-|#-2#$-2#|#-2#.$-#|#-$3.-#|2#2-#$2#|-2#3-#-|2-5#-",0
      0  216e					      END_LEVEL	_005_R
      1  216e		       00		      .byte.b	0
      2  216e		       00 40	   LEVEL_SIZE__005_R =	* - LEVEL_START
      3  216f					      IF	LEVEL_SIZE__005_R > MAX_LEVEL_SIZE
      4  216f				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__005_R
      5  216f					      ENDIF
      0  216f					      DEFL	_006_L, "5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-"
      0  216f					      START_LEVEL	_006_L
      1  216f				   LEVEL_START SET	*
      2  216f		       00 04	   BANK_LEVEL__006_L =	_CURRENT_BANK
      3  216f				   LEVEL__006_L SUBROUTINE
      4  216f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  216f
      2  216f		       35 23 33 2d*	      .byte.b	"5#3-|#3-3#-|#-#-$.#-|#-#-$.#-|#-#-.*2#|#2-#-$@#|#4-3#|6#2-",0
      0  21aa					      END_LEVEL	_006_L
      1  21aa		       00		      .byte.b	0
      2  21aa		       00 3c	   LEVEL_SIZE__006_L =	* - LEVEL_START
      3  21ab				  -	      IF	LEVEL_SIZE__006_L > MAX_LEVEL_SIZE
      4  21ab				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_L
      5  21ab					      ENDIF
      0  21ab					      DEFL	_006_R, "3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-"
      0  21ab					      START_LEVEL	_006_R
      1  21ab				   LEVEL_START SET	*
      2  21ab		       00 04	   BANK_LEVEL__006_R =	_CURRENT_BANK
      3  21ab				   LEVEL__006_R SUBROUTINE
      4  21ab				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21ab
      2  21ab		       33 23 34 2d*	      .byte.b	"3#4-|#@5#|#$4-#|#2.$#-#|2#*.$-#|-#-.-2#|-2#$-#-|2-#2-#-|2-4#-",0
      0  21e9					      END_LEVEL	_006_R
      1  21e9		       00		      .byte.b	0
      2  21e9		       00 3f	   LEVEL_SIZE__006_R =	* - LEVEL_START
      3  21ea				  -	      IF	LEVEL_SIZE__006_R > MAX_LEVEL_SIZE
      4  21ea				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__006_R
      5  21ea					      ENDIF
      0  21ea					      DEFL	_007_L, "6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#"
      0  21ea					      START_LEVEL	_007_L
      1  21ea				   LEVEL_START SET	*
      2  21ea		       00 04	   BANK_LEVEL__007_L =	_CURRENT_BANK
      3  21ea				   LEVEL__007_L SUBROUTINE
      4  21ea				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21ea
      2  21ea		       36 23 2d 7c*	      .byte.b	"6#-|#4-#-|#@-*-#-|#-*.3#|2#-$2-#|-2#3-#|2-5#",0
      0  2217					      END_LEVEL	_007_L
      1  2217		       00		      .byte.b	0
      2  2217		       00 2e	   LEVEL_SIZE__007_L =	* - LEVEL_START
      3  2218				  -	      IF	LEVEL_SIZE__007_L > MAX_LEVEL_SIZE
      4  2218				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_L
      5  2218					      ENDIF
      0  2218					      DEFL	_007_R, "4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#"
      0  2218					      START_LEVEL	_007_R
      1  2218				   LEVEL_START SET	*
      2  2218		       00 04	   BANK_LEVEL__007_R =	_CURRENT_BANK
      3  2218				   LEVEL__007_R SUBROUTINE
      4  2218				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2218
      2  2218		       34 23 34 2d*	      .byte.b	"4#4-|#2-2#3-|#-$.2#2-|#2-*.3#|#2-2*$-#|3#3-@#|2-6#",0
      0  224b					      END_LEVEL	_007_R
      1  224b		       00		      .byte.b	0
      2  224b		       00 34	   LEVEL_SIZE__007_R =	* - LEVEL_START
      3  224c				  -	      IF	LEVEL_SIZE__007_R > MAX_LEVEL_SIZE
      4  224c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__007_R
      5  224c					      ENDIF
      0  224c					      DEFL	_008_L, "2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-"
      0  224c					      START_LEVEL	_008_L
      1  224c				   LEVEL_START SET	*
      2  224c		       00 04	   BANK_LEVEL__008_L =	_CURRENT_BANK
      3  224c				   LEVEL__008_L SUBROUTINE
      4  224c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  224c
      2  224c		       32 2d 35 23*	      .byte.b	"2-5#|2-#3-#|-2#.*-#|2#@$.2#|#-$2-#-|#-2#-#-|#4-#-|6#-",0
      0  2282					      END_LEVEL	_008_L
      1  2282		       00		      .byte.b	0
      2  2282		       00 37	   LEVEL_SIZE__008_L =	* - LEVEL_START
      3  2283				  -	      IF	LEVEL_SIZE__008_L > MAX_LEVEL_SIZE
      4  2283				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_L
      5  2283					      ENDIF
      0  2283					      DEFL	_008_R, "-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#"
      0  2283					      START_LEVEL	_008_R
      1  2283				   LEVEL_START SET	*
      2  2283		       00 04	   BANK_LEVEL__008_R =	_CURRENT_BANK
      3  2283				   LEVEL__008_R SUBROUTINE
      4  2283				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2283
      2  2283		       2d 35 23 33*	      .byte.b	"-5#3-|2#3-2#2-|#-$-*-2#-|#2-*.$-2#|3#2.-$@#|2-7#",0
      0  22b4					      END_LEVEL	_008_R
      1  22b4		       00		      .byte.b	0
      2  22b4		       00 32	   LEVEL_SIZE__008_R =	* - LEVEL_START
      3  22b5				  -	      IF	LEVEL_SIZE__008_R > MAX_LEVEL_SIZE
      4  22b5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__008_R
      5  22b5					      ENDIF
      0  22b5					      DEFL	_009_L, "-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#"
      0  22b5					      START_LEVEL	_009_L
      1  22b5				   LEVEL_START SET	*
      2  22b5		       00 04	   BANK_LEVEL__009_L =	_CURRENT_BANK
      3  22b5				   LEVEL__009_L SUBROUTINE
      4  22b5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22b5
      2  22b5		       2d 35 23 2d*	      .byte.b	"-5#-|2#-$.2#|#@$-.-#|2#-$.$#|-#-$2.#|-2#-$.#|2-5#",0
      0  22e7					      END_LEVEL	_009_L
      1  22e7		       00		      .byte.b	0
      2  22e7		       00 33	   LEVEL_SIZE__009_L =	* - LEVEL_START
      3  22e8				  -	      IF	LEVEL_SIZE__009_L > MAX_LEVEL_SIZE
      4  22e8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_L
      5  22e8					      ENDIF
      0  22e8					      DEFL	_009_R, "-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#"
      0  22e8					      START_LEVEL	_009_R
      1  22e8				   LEVEL_START SET	*
      2  22e8		       00 04	   BANK_LEVEL__009_R =	_CURRENT_BANK
      3  22e8				   LEVEL__009_R SUBROUTINE
      4  22e8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22e8
      2  22e8		       2d 33 23 33*	      .byte.b	"-3#3-|2#@4#|#-$3-#|#2-$2*#|2#2-*.#|-2#2-.#|2-5#",0
      0  2318					      END_LEVEL	_009_R
      1  2318		       00		      .byte.b	0
      2  2318		       00 31	   LEVEL_SIZE__009_R =	* - LEVEL_START
      3  2319				  -	      IF	LEVEL_SIZE__009_R > MAX_LEVEL_SIZE
      4  2319				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__009_R
      5  2319					      ENDIF
      0  2319					      DEFL	_010_L, "2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-"
      0  2319					      START_LEVEL	_010_L
      1  2319				   LEVEL_START SET	*
      2  2319		       00 04	   BANK_LEVEL__010_L =	_CURRENT_BANK
      3  2319				   LEVEL__010_L SUBROUTINE
      4  2319				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2319
      2  2319		       32 2d 33 23*	      .byte.b	"2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-",0
      0  2353					      END_LEVEL	_010_L
      1  2353		       00		      .byte.b	0
      2  2353		       00 3b	   LEVEL_SIZE__010_L =	* - LEVEL_START
      3  2354				  -	      IF	LEVEL_SIZE__010_L > MAX_LEVEL_SIZE
      4  2354				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_L
      5  2354					      ENDIF
      0  2354					      DEFL	_010_R, "4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-"
      0  2354					      START_LEVEL	_010_R
      1  2354				   LEVEL_START SET	*
      2  2354		       00 04	   BANK_LEVEL__010_R =	_CURRENT_BANK
      3  2354				   LEVEL__010_R SUBROUTINE
      4  2354				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2354
      2  2354		       34 23 32 2d*	      .byte.b	"4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-",0
      0  2387					      END_LEVEL	_010_R
      1  2387		       00		      .byte.b	0
      2  2387		       00 34	   LEVEL_SIZE__010_R =	* - LEVEL_START
      3  2388				  -	      IF	LEVEL_SIZE__010_R > MAX_LEVEL_SIZE
      4  2388				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_R
      5  2388					      ENDIF
      0  2388					      DEFL	_011_L, "-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-"
      0  2388					      START_LEVEL	_011_L
      1  2388				   LEVEL_START SET	*
      2  2388		       00 04	   BANK_LEVEL__011_L =	_CURRENT_BANK
      3  2388				   LEVEL__011_L SUBROUTINE
      4  2388				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2388
      2  2388		       2d 34 23 32*	      .byte.b	"-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-",0
      0  23bb					      END_LEVEL	_011_L
      1  23bb		       00		      .byte.b	0
      2  23bb		       00 34	   LEVEL_SIZE__011_L =	* - LEVEL_START
      3  23bc				  -	      IF	LEVEL_SIZE__011_L > MAX_LEVEL_SIZE
      4  23bc				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_L
      5  23bc					      ENDIF
      0  23bc					      DEFL	_011_R, "2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#"
      0  23bc					      START_LEVEL	_011_R
      1  23bc				   LEVEL_START SET	*
      2  23bc		       00 04	   BANK_LEVEL__011_R =	_CURRENT_BANK
      3  23bc				   LEVEL__011_R SUBROUTINE
      4  23bc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23bc
      2  23bc		       32 2d 33 23*	      .byte.b	"2-3#-|-2#@#-|2#-$#-|#-$-2#|#-.*.#|#-*2.#|#-$-$#|2#3-#|-5#",0
      0  23f6					      END_LEVEL	_011_R
      1  23f6		       00		      .byte.b	0
      2  23f6		       00 3b	   LEVEL_SIZE__011_R =	* - LEVEL_START
      3  23f7				  -	      IF	LEVEL_SIZE__011_R > MAX_LEVEL_SIZE
      4  23f7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_R
      5  23f7					      ENDIF
      0  23f7					      DEFL	_012_L, "7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#"
      0  23f7					      START_LEVEL	_012_L
      1  23f7				   LEVEL_START SET	*
      2  23f7		       00 04	   BANK_LEVEL__012_L =	_CURRENT_BANK
      3  23f7				   LEVEL__012_L SUBROUTINE
      4  23f7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23f7
      2  23f7		       37 23 33 2d*	      .byte.b	"7#3-|#5-2#2-|#-3$2.#2-|2#2-.*$3#|-3#2.-$@#|3-7#",0
      0  2427					      END_LEVEL	_012_L
      1  2427		       00		      .byte.b	0
      2  2427		       00 31	   LEVEL_SIZE__012_L =	* - LEVEL_START
      3  2428				  -	      IF	LEVEL_SIZE__012_L > MAX_LEVEL_SIZE
      4  2428				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_L
      5  2428					      ENDIF
      0  2428					      DEFL	_012_R, "-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-"
      0  2428					      START_LEVEL	_012_R
      1  2428				   LEVEL_START SET	*
      2  2428		       00 04	   BANK_LEVEL__012_R =	_CURRENT_BANK
      3  2428				   LEVEL__012_R SUBROUTINE
      4  2428				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2428
      2  2428		       2d 36 23 32*	      .byte.b	"-6#2-|2#2-.-2#-|#@$-*$-2#|2#-$.$2-#|-3#.*2-#|3-#.2-2#|3-5#-",0
      0  2464					      END_LEVEL	_012_R
      1  2464		       00		      .byte.b	0
      2  2464		       00 3d	   LEVEL_SIZE__012_R =	* - LEVEL_START
      3  2465				  -	      IF	LEVEL_SIZE__012_R > MAX_LEVEL_SIZE
      4  2465				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__012_R
      5  2465					      ENDIF
      0  2465					      DEFL	_013_L, "2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-"
      0  2465					      START_LEVEL	_013_L
      1  2465				   LEVEL_START SET	*
      2  2465		       00 04	   BANK_LEVEL__013_L =	_CURRENT_BANK
      3  2465				   LEVEL__013_L SUBROUTINE
      4  2465				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2465
      2  2465		       32 2d 35 23*	      .byte.b	"2-5#-|2-#3-2#|2-#-.2-#|3#2*2.#|#@$2-$-#|3#-$2-#|2-2#2-2#|3-4#-",0
      0  24a4					      END_LEVEL	_013_L
      1  24a4		       00		      .byte.b	0
      2  24a4		       00 40	   LEVEL_SIZE__013_L =	* - LEVEL_START
      3  24a5				  -	      IF	LEVEL_SIZE__013_L > MAX_LEVEL_SIZE
      4  24a5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_L
      5  24a5					      ENDIF
      0  24a5					      DEFL	_013_R, "-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-"
      0  24a5					      START_LEVEL	_013_R
      1  24a5				   LEVEL_START SET	*
      2  24a5		       00 04	   BANK_LEVEL__013_R =	_CURRENT_BANK
      3  24a5				   LEVEL__013_R SUBROUTINE
      4  24a5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24a5
      2  24a5		       2d 35 23 32*	      .byte.b	"-5#2-|2#3-2#-|#-$3-2#|#-.2*.-#|#3-$*-#|5#@2#|4-3#-",0
      0  24d8					      END_LEVEL	_013_R
      1  24d8		       00		      .byte.b	0
      2  24d8		       00 34	   LEVEL_SIZE__013_R =	* - LEVEL_START
      3  24d9				  -	      IF	LEVEL_SIZE__013_R > MAX_LEVEL_SIZE
      4  24d9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__013_R
      5  24d9					      ENDIF
      0  24d9					      DEFL	_014_L, "6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#"
      0  24d9					      START_LEVEL	_014_L
      1  24d9				   LEVEL_START SET	*
      2  24d9		       00 04	   BANK_LEVEL__014_L =	_CURRENT_BANK
      3  24d9				   LEVEL__014_L SUBROUTINE
      4  24d9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24d9
      2  24d9		       36 23 34 2d*	      .byte.b	"6#4-|#@3-2#3-|#-2#$-4#|#-#-$-*2-#|#-$-2.*2-#|5#2.$-#|4-2#.$-#|5-5#",0
      0  251c					      END_LEVEL	_014_L
      1  251c		       00		      .byte.b	0
      2  251c		       00 44	   LEVEL_SIZE__014_L =	* - LEVEL_START
      3  251d					      IF	LEVEL_SIZE__014_L > MAX_LEVEL_SIZE
      4  251d				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_L
      5  251d					      ENDIF
      0  251d					      DEFL	_014_R, "6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-"
      0  251d					      START_LEVEL	_014_R
      1  251d				   LEVEL_START SET	*
      2  251d		       00 04	   BANK_LEVEL__014_R =	_CURRENT_BANK
      3  251d				   LEVEL__014_R SUBROUTINE
      4  251d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  251d
      2  251d		       36 23 33 2d*	      .byte.b	"6#3-|#4-4#|#2-#2-$@#|#-$.*-3#|2#-.*-#2-|-2#.$-#2-|2-#.$-#2-|2-5#2-",0
      0  2560					      END_LEVEL	_014_R
      1  2560		       00		      .byte.b	0
      2  2560		       00 44	   LEVEL_SIZE__014_R =	* - LEVEL_START
      3  2561				  -	      IF	LEVEL_SIZE__014_R > MAX_LEVEL_SIZE
      4  2561				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__014_R
      5  2561					      ENDIF
      0  2561					      DEFL	_015_L, "2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#"
      0  2561					      START_LEVEL	_015_L
      1  2561				   LEVEL_START SET	*
      2  2561		       00 04	   BANK_LEVEL__015_L =	_CURRENT_BANK
      3  2561				   LEVEL__015_L SUBROUTINE
      4  2561				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2561
      2  2561		       32 2d 35 23*	      .byte.b	"2-5#|3#3-#|#@#-$-#|#$*.-2#|#2.*$-#|2#-*2-#|-#4-#|-6#",0
      0  2596					      END_LEVEL	_015_L
      1  2596		       00		      .byte.b	0
      2  2596		       00 36	   LEVEL_SIZE__015_L =	* - LEVEL_START
      3  2597				  -	      IF	LEVEL_SIZE__015_L > MAX_LEVEL_SIZE
      4  2597				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_L
      5  2597					      ENDIF
      0  2597					      DEFL	_015_R, "3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-"
      0  2597					      START_LEVEL	_015_R
      1  2597				   LEVEL_START SET	*
      2  2597		       00 04	   BANK_LEVEL__015_R =	_CURRENT_BANK
      3  2597				   LEVEL__015_R SUBROUTINE
      4  2597				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2597
      2  2597		       33 2d 35 23*	      .byte.b	"3-5#|2-2#3-#|2-#4-#|3#-$3#|#.*.*-#-|2#-*2-#-|-#2-$-#-|-3#@2#-|3-3#2-",0
      0  25dc					      END_LEVEL	_015_R
      1  25dc		       00		      .byte.b	0
      2  25dc		       00 46	   LEVEL_SIZE__015_R =	* - LEVEL_START
      3  25dd					      IF	LEVEL_SIZE__015_R > MAX_LEVEL_SIZE
      4  25dd				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__015_R
      5  25dd					      ENDIF
      0  25dd					      DEFL	_016_L, "4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-"
      0  25dd					      START_LEVEL	_016_L
      1  25dd				   LEVEL_START SET	*
      2  25dd		       00 04	   BANK_LEVEL__016_L =	_CURRENT_BANK
      3  25dd				   LEVEL__016_L SUBROUTINE
      4  25dd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  25dd
      2  25dd		       34 2d 33 23*	      .byte.b	"4-3#2-|5#.3#|#4.*2-#|#$#-*-$-#|#@$-2$-2#|2#4-2#-|-6#2-",0
      0  2614					      END_LEVEL	_016_L
      1  2614		       00		      .byte.b	0
      2  2614		       00 38	   LEVEL_SIZE__016_L =	* - LEVEL_START
      3  2615				  -	      IF	LEVEL_SIZE__016_L > MAX_LEVEL_SIZE
      4  2615				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_L
      5  2615					      ENDIF
      0  2615					      DEFL	_016_R, "5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-"
      0  2615					      START_LEVEL	_016_R
      1  2615				   LEVEL_START SET	*
      2  2615		       00 04	   BANK_LEVEL__016_R =	_CURRENT_BANK
      3  2615				   LEVEL__016_R SUBROUTINE
      4  2615				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2615
      2  2615		       35 23 2d 7c*	      .byte.b	"5#-|#.2-#-|#.$-#-|#.*-2#|#*-$@#|#2-$-#|2#2-2#|-4#-",0
      0  2648					      END_LEVEL	_016_R
      1  2648		       00		      .byte.b	0
      2  2648		       00 34	   LEVEL_SIZE__016_R =	* - LEVEL_START
      3  2649				  -	      IF	LEVEL_SIZE__016_R > MAX_LEVEL_SIZE
      4  2649				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__016_R
      5  2649					      ENDIF
      0  2649					      DEFL	_017_L, "5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-"
      0  2649					      START_LEVEL	_017_L
      1  2649				   LEVEL_START SET	*
      2  2649		       00 04	   BANK_LEVEL__017_L =	_CURRENT_BANK
      3  2649				   LEVEL__017_L SUBROUTINE
      4  2649				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2649
      2  2649		       35 23 34 2d*	      .byte.b	"5#4-|#3-2#3-|#$3-2#2-|#2.*$-#2-|2#2*.-3#|-#.$2-$@#|-#2-#-3#|-#4-#2-|-6#2-",0
      0  2693					      END_LEVEL	_017_L
      1  2693		       00		      .byte.b	0
      2  2693		       00 4b	   LEVEL_SIZE__017_L =	* - LEVEL_START
      3  2694					      IF	LEVEL_SIZE__017_L > MAX_LEVEL_SIZE
      4  2694				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_L
      5  2694					      ENDIF
      0  2694					      DEFL	_017_R, "3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-"
      0  2694					      START_LEVEL	_017_R
      1  2694				   LEVEL_START SET	*
      2  2694		       00 04	   BANK_LEVEL__017_R =	_CURRENT_BANK
      3  2694				   LEVEL__017_R SUBROUTINE
      4  2694				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2694
      2  2694		       33 2d 34 23*	      .byte.b	"3-4#-|3-#2-#-|-3#2-#-|-#.*.-#-|3#2*.#-|#3-2$2#|#-#2-$@#|#3-4#|5#3-",0
      0  26d7					      END_LEVEL	_017_R
      1  26d7		       00		      .byte.b	0
      2  26d7		       00 44	   LEVEL_SIZE__017_R =	* - LEVEL_START
      3  26d8				  -	      IF	LEVEL_SIZE__017_R > MAX_LEVEL_SIZE
      4  26d8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__017_R
      5  26d8					      ENDIF
      0  26d8					      DEFL	_018_L, "6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#"
      0  26d8					      START_LEVEL	_018_L
      1  26d8				   LEVEL_START SET	*
      2  26d8		       00 04	   BANK_LEVEL__018_L =	_CURRENT_BANK
      3  26d8				   LEVEL__018_L SUBROUTINE
      4  26d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  26d8
      2  26d8		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$2.-3#|2#-3*2.#|#-$2-$*$#|#4-#@-#|9#",0
      0  270c					      END_LEVEL	_018_L
      1  270c		       00		      .byte.b	0
      2  270c		       00 35	   LEVEL_SIZE__018_L =	* - LEVEL_START
      3  270d				  -	      IF	LEVEL_SIZE__018_L > MAX_LEVEL_SIZE
      4  270d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_L
      5  270d					      ENDIF
      0  270d					      DEFL	_018_R, "-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#"
      0  270d					      START_LEVEL	_018_R
      1  270d				   LEVEL_START SET	*
      2  270d		       00 04	   BANK_LEVEL__018_R =	_CURRENT_BANK
      3  270d				   LEVEL__018_R SUBROUTINE
      4  270d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  270d
      2  270d		       2d 34 23 33*	      .byte.b	"-4#3-|-#2-2#2-|2#-*.2#-|#-$.*@2#|#2-$2*-#|#4-#-#|3#4-#|2-6#",0
      0  2749					      END_LEVEL	_018_R
      1  2749		       00		      .byte.b	0
      2  2749		       00 3d	   LEVEL_SIZE__018_R =	* - LEVEL_START
      3  274a				  -	      IF	LEVEL_SIZE__018_R > MAX_LEVEL_SIZE
      4  274a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__018_R
      5  274a					      ENDIF
      0  274a					      DEFL	_019_L, "4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#"
      0  274a					      START_LEVEL	_019_L
      1  274a				   LEVEL_START SET	*
      2  274a		       00 04	   BANK_LEVEL__019_L =	_CURRENT_BANK
      3  274a				   LEVEL__019_L SUBROUTINE
      4  274a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  274a
      2  274a		       34 2d 35 23*	      .byte.b	"4-5#-|2-3#-*.#-|2-#-$-2.#-|3#-2$*$2#|#@$2-2.2-#|6#3-#|5-5#",0
      0  2785					      END_LEVEL	_019_L
      1  2785		       00		      .byte.b	0
      2  2785		       00 3c	   LEVEL_SIZE__019_L =	* - LEVEL_START
      3  2786				  -	      IF	LEVEL_SIZE__019_L > MAX_LEVEL_SIZE
      4  2786				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_L
      5  2786					      ENDIF
      0  2786					      DEFL	_019_R, "2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#"
      0  2786					      START_LEVEL	_019_R
      1  2786				   LEVEL_START SET	*
      2  2786		       00 04	   BANK_LEVEL__019_R =	_CURRENT_BANK
      3  2786				   LEVEL__019_R SUBROUTINE
      4  2786				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2786
      2  2786		       32 2d 37 23*	      .byte.b	"2-7#2-|2-#5-2#-|2-#-$*#$-#-|3#-$.*.*#-|#@$-3.$-2#|5#.$3-#|4-2#-2#-#|5-#4-#|5-6#",0
      0  27d6					      END_LEVEL	_019_R
      1  27d6		       00		      .byte.b	0
      2  27d6		       00 51	   LEVEL_SIZE__019_R =	* - LEVEL_START
      3  27d7					      IF	LEVEL_SIZE__019_R > MAX_LEVEL_SIZE
      4  27d7				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__019_R
      5  27d7					      ENDIF
     76  27d7
      0  27d7					      CHECK_BANK_SIZE	"LEVELS1"
      1  27d7		       07 d7	   .TEMP      =	* - BANK_START
 LEVELS1 (2K) SIZE =  $7d7 , FREE= $29
      2  27d7					      ECHO	"LEVELS1", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  27d7				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  27d7				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  27d7				  -	      ERR
      6  27d7					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS2.asm LEVEL 2 PASS 4
      0  27d7					      include	"BANK_LEVELS2.asm"
      1  27d7							;    Sokoboo - a Sokoban implementation
      2  27d7							;    using a generic tile-based display engine for the Atari 2600
      3  27d7							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  27d7							;
      5  27d7							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  27d7							;
      7  27d7							;    Code related to the generic tile-based display engine was developed by
      8  27d7							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  27d7							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  27d7							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  27d7							;
     12  27d7							;    Code related to music and sound effects uses the TIATracker music player
     13  27d7							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  27d7							;    directory for Apache licensing details.
     15  27d7							;
     16  27d7							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  27d7							;    See the copyright notices in the License directory for a list of level
     18  27d7							;    contributors.
     19  27d7							;
     20  27d7							;    Except where otherwise indicated, this software is released under the
     21  27d7							;    following licensing arrangement...
     22  27d7							;
     23  27d7							;    This program is free software: you can redistribute it and/or modify
     24  27d7							;    it under the terms of the GNU General Public License as published by
     25  27d7							;    the Free Software Foundation, either version 3 of the License, or
     26  27d7							;    (at your option) any later version.
     27  27d7							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  27d7
     29  27d7							;    This program is distributed in the hope that it will be useful,
     30  27d7							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  27d7							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  27d7							;    GNU General Public License for more details.
     33  27d7
      0  27d7					      NEWBANK	LEVELS2
      1  2ec2 ????				      SEG	LEVELS2
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   LEVELS2    SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	LEVELS2
     35  2800
      0  2800					      DEFL	_020_L, "-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-"
      0  2800					      START_LEVEL	_020_L
      1  2800				   LEVEL_START SET	*
      2  2800		       00 05	   BANK_LEVEL__020_L =	_CURRENT_BANK
      3  2800				   LEVEL__020_L SUBROUTINE
      4  2800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2800
      2  2800		       2d 36 23 2d*	      .byte.b	"-6#-|-#4-#-|-#-2$-#-|2#-.$3#|#@$.3-#|3#*.*$#|#4-2.#|#3-4#|5#3-",0
      0  283f					      END_LEVEL	_020_L
      1  283f		       00		      .byte.b	0
      2  283f		       00 40	   LEVEL_SIZE__020_L =	* - LEVEL_START
      3  2840				  -	      IF	LEVEL_SIZE__020_L > MAX_LEVEL_SIZE
      4  2840				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_L
      5  2840					      ENDIF
      0  2840					      DEFL	_020_R, "5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-"
      0  2840					      START_LEVEL	_020_R
      1  2840				   LEVEL_START SET	*
      2  2840		       00 05	   BANK_LEVEL__020_R =	_CURRENT_BANK
      3  2840				   LEVEL__020_R SUBROUTINE
      4  2840				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2840
      2  2840		       35 2d 34 23*	      .byte.b	"5-4#|6#2-#|#3-#3-#|#-#$.*$-#|#2-3.-2#|#-2$*2-#-|2#@$.-2#-|-6#2-",0
      0  2880					      END_LEVEL	_020_R
      1  2880		       00		      .byte.b	0
      2  2880		       00 41	   LEVEL_SIZE__020_R =	* - LEVEL_START
      3  2881				  -	      IF	LEVEL_SIZE__020_R > MAX_LEVEL_SIZE
      4  2881				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__020_R
      5  2881					      ENDIF
      0  2881					      DEFL	_021_L, "4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-"
      0  2881					      START_LEVEL	_021_L
      1  2881				   LEVEL_START SET	*
      2  2881		       00 05	   BANK_LEVEL__021_L =	_CURRENT_BANK
      3  2881				   LEVEL__021_L SUBROUTINE
      4  2881				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2881
      2  2881		       34 2d 34 23*	      .byte.b	"4-4#3-|4-#2-#3-|5#-$2#2-|#@$3.*.#2-|2#-#-$2.3#|-#-#2$*-$-#|-#-$2-.3-#|-4#-*2-2#|4-6#-",0
      0  28d7					      END_LEVEL	_021_L
      1  28d7		       00		      .byte.b	0
      2  28d7		       00 57	   LEVEL_SIZE__021_L =	* - LEVEL_START
      3  28d8					      IF	LEVEL_SIZE__021_L > MAX_LEVEL_SIZE
      4  28d8				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_L
      5  28d8					      ENDIF
      0  28d8					      DEFL	_021_R, "-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-"
      0  28d8					      START_LEVEL	_021_R
      1  28d8				   LEVEL_START SET	*
      2  28d8		       00 05	   BANK_LEVEL__021_R =	_CURRENT_BANK
      3  28d8				   LEVEL__021_R SUBROUTINE
      4  28d8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  28d8
      2  28d8		       2d 34 23 33*	      .byte.b	"-4#3-|2#@-4#|#-3$2-#|#.*.$2-#|#-.*2-2#|2#.3-#-|-6#-",0
      0  290c					      END_LEVEL	_021_R
      1  290c		       00		      .byte.b	0
      2  290c		       00 35	   LEVEL_SIZE__021_R =	* - LEVEL_START
      3  290d				  -	      IF	LEVEL_SIZE__021_R > MAX_LEVEL_SIZE
      4  290d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__021_R
      5  290d					      ENDIF
      0  290d					      DEFL	_022_L, "3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-"
      0  290d					      START_LEVEL	_022_L
      1  290d				   LEVEL_START SET	*
      2  290d		       00 05	   BANK_LEVEL__022_L =	_CURRENT_BANK
      3  290d				   LEVEL__022_L SUBROUTINE
      4  290d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  290d
      2  290d		       33 2d 33 23*	      .byte.b	"3-3#2-|3-#@2#-|2-2#$-2#|3#2.*-#|#2-2$.*#|#-#$-.-#|#3-$.-#|2#4-2#|-6#-",0
      0  2953					      END_LEVEL	_022_L
      1  2953		       00		      .byte.b	0
      2  2953		       00 47	   LEVEL_SIZE__022_L =	* - LEVEL_START
      3  2954				  -	      IF	LEVEL_SIZE__022_L > MAX_LEVEL_SIZE
      4  2954				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_L
      5  2954					      ENDIF
      0  2954					      DEFL	_022_R, "-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-"
      0  2954					      START_LEVEL	_022_R
      1  2954				   LEVEL_START SET	*
      2  2954		       00 05	   BANK_LEVEL__022_R =	_CURRENT_BANK
      3  2954				   LEVEL__022_R SUBROUTINE
      4  2954				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2954
      2  2954		       2d 33 23 34*	      .byte.b	"-3#4-|-#@2#3-|2#$-4#|#2-2$2-#|#-$.*$-#|#2-3.-#|4#.3#|3-3#2-",0
      0  2990					      END_LEVEL	_022_R
      1  2990		       00		      .byte.b	0
      2  2990		       00 3d	   LEVEL_SIZE__022_R =	* - LEVEL_START
      3  2991				  -	      IF	LEVEL_SIZE__022_R > MAX_LEVEL_SIZE
      4  2991				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__022_R
      5  2991					      ENDIF
      0  2991					      DEFL	_023_L, "6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#"
      0  2991					      START_LEVEL	_023_L
      1  2991				   LEVEL_START SET	*
      2  2991		       00 05	   BANK_LEVEL__023_L =	_CURRENT_BANK
      3  2991				   LEVEL__023_L SUBROUTINE
      4  2991				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2991
      2  2991		       36 23 33 2d*	      .byte.b	"6#3-|#4-2#2-|#-$-$-2#-|2#-$.$+2#|-#-2.*.-#|-2#$#-#-#|2-#5-#|2-7#",0
      0  29d2					      END_LEVEL	_023_L
      1  29d2		       00		      .byte.b	0
      2  29d2		       00 42	   LEVEL_SIZE__023_L =	* - LEVEL_START
      3  29d3				  -	      IF	LEVEL_SIZE__023_L > MAX_LEVEL_SIZE
      4  29d3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_L
      5  29d3					      ENDIF
      0  29d3					      DEFL	_023_R, "7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-"
      0  29d3					      START_LEVEL	_023_R
      1  29d3				   LEVEL_START SET	*
      2  29d3		       00 05	   BANK_LEVEL__023_R =	_CURRENT_BANK
      3  29d3				   LEVEL__023_R SUBROUTINE
      4  29d3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  29d3
      2  29d3		       37 23 32 2d*	      .byte.b	"7#2-|#5-#2-|#2-#2$#2-|#-$-$.3#|2#+2*.*.#|-2#3-3#|2-#2-2#2-|2-4#3-",0
      0  2a15					      END_LEVEL	_023_R
      1  2a15		       00		      .byte.b	0
      2  2a15		       00 43	   LEVEL_SIZE__023_R =	* - LEVEL_START
      3  2a16				  -	      IF	LEVEL_SIZE__023_R > MAX_LEVEL_SIZE
      4  2a16				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__023_R
      5  2a16					      ENDIF
     44  2a16
      0  2a16					      DEFL	_050_L, "4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#"
      0  2a16					      START_LEVEL	_050_L
      1  2a16				   LEVEL_START SET	*
      2  2a16		       00 05	   BANK_LEVEL__050_L =	_CURRENT_BANK
      3  2a16				   LEVEL__050_L SUBROUTINE
      4  2a16				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a16
      2  2a16		       34 2d 35 23*	      .byte.b	"4-5#3-|4-#-@-#3-|4-#$.$2#2-|-4#-*2-#2-|2#4-*.*3#|#2-$-#2.-$-#|#3-3#4-#|5#-6#",0
      0  2a63					      END_LEVEL	_050_L
      1  2a63		       00		      .byte.b	0
      2  2a63		       00 4e	   LEVEL_SIZE__050_L =	* - LEVEL_START
      3  2a64				  -	      IF	LEVEL_SIZE__050_L > MAX_LEVEL_SIZE
      4  2a64				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_L
      5  2a64					      ENDIF
      0  2a64					      DEFL	_050_R, "8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#"
      0  2a64					      START_LEVEL	_050_R
      1  2a64				   LEVEL_START SET	*
      2  2a64		       00 05	   BANK_LEVEL__050_R =	_CURRENT_BANK
      3  2a64				   LEVEL__050_R SUBROUTINE
      4  2a64				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a64
      2  2a64		       38 23 7c 23*	      .byte.b	"8#|#4-@-#|#2-$*2$#|#-$*2.-#|#*2.$*.#|#2-*#2-#|#-$.3-#|8#",0
      0  2a9d					      END_LEVEL	_050_R
      1  2a9d		       00		      .byte.b	0
      2  2a9d		       00 3a	   LEVEL_SIZE__050_R =	* - LEVEL_START
      3  2a9e				  -	      IF	LEVEL_SIZE__050_R > MAX_LEVEL_SIZE
      4  2a9e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__050_R
      5  2a9e					      ENDIF
      0  2a9e					      DEFL	_051_L, "-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#"
      0  2a9e					      START_LEVEL	_051_L
      1  2a9e				   LEVEL_START SET	*
      2  2a9e		       00 05	   BANK_LEVEL__051_L =	_CURRENT_BANK
      3  2a9e				   LEVEL__051_L SUBROUTINE
      4  2a9e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2a9e
      2  2a9e		       2d 36 23 34*	      .byte.b	"-6#4-|-#2-@-#4-|-#$-*-2#3-|2#-3*.#3-|#2-.*.-#3-|#-#2$2.4#|#4-$-$2-#|3#2-2#3-#|2-9#",0
      0  2af1					      END_LEVEL	_051_L
      1  2af1		       00		      .byte.b	0
      2  2af1		       00 54	   LEVEL_SIZE__051_L =	* - LEVEL_START
      3  2af2				  -	      IF	LEVEL_SIZE__051_L > MAX_LEVEL_SIZE
      4  2af2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_L
      5  2af2					      ENDIF
      0  2af2					      DEFL	_051_R, "-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-"
      0  2af2					      START_LEVEL	_051_R
      1  2af2				   LEVEL_START SET	*
      2  2af2		       00 05	   BANK_LEVEL__051_R =	_CURRENT_BANK
      3  2af2				   LEVEL__051_R SUBROUTINE
      4  2af2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2af2
      2  2af2		       2d 38 23 2d*	      .byte.b	"-8#-|-#3-#2-#-|2#$-.$2-2#|#-$.*#$2-#|#-*.3-#-#|#3.#$3-#|3#-$@4#|2-#2-2#3-|2-4#4-",0
      0  2b43					      END_LEVEL	_051_R
      1  2b43		       00		      .byte.b	0
      2  2b43		       00 52	   LEVEL_SIZE__051_R =	* - LEVEL_START
      3  2b44				  -	      IF	LEVEL_SIZE__051_R > MAX_LEVEL_SIZE
      4  2b44				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__051_R
      5  2b44					      ENDIF
      0  2b44					      DEFL	_052_L, "5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-"
      0  2b44					      START_LEVEL	_052_L
      1  2b44				   LEVEL_START SET	*
      2  2b44		       00 05	   BANK_LEVEL__052_L =	_CURRENT_BANK
      3  2b44				   LEVEL__052_L SUBROUTINE
      4  2b44				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b44
      2  2b44		       35 23 36 2d*	      .byte.b	"5#6-|#.*.2#5-|#@*2.6#|#-*-2$4-#|2#-$3-$2-#|-3#2-5#|3-4#4-",0
      0  2b7e					      END_LEVEL	_052_L
      1  2b7e		       00		      .byte.b	0
      2  2b7e		       00 3b	   LEVEL_SIZE__052_L =	* - LEVEL_START
      3  2b7f				  -	      IF	LEVEL_SIZE__052_L > MAX_LEVEL_SIZE
      4  2b7f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_L
      5  2b7f					      ENDIF
      0  2b7f					      DEFL	_052_R, "2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-"
      0  2b7f					      START_LEVEL	_052_R
      1  2b7f				   LEVEL_START SET	*
      2  2b7f		       00 05	   BANK_LEVEL__052_R =	_CURRENT_BANK
      3  2b7f				   LEVEL__052_R SUBROUTINE
      4  2b7f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2b7f
      2  2b7f		       32 2d 37 23*	      .byte.b	"2-7#|2-#4-@#|2-#-2$2-#|4#*.$-#|#3.*.$2#|#-#-#2-#-|#2-$3-#-|5#2-#-|4-4#-",0
      0  2bc7					      END_LEVEL	_052_R
      1  2bc7		       00		      .byte.b	0
      2  2bc7		       00 49	   LEVEL_SIZE__052_R =	* - LEVEL_START
      3  2bc8				  -	      IF	LEVEL_SIZE__052_R > MAX_LEVEL_SIZE
      4  2bc8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__052_R
      5  2bc8					      ENDIF
      0  2bc8					      DEFL	_053_L, "6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-"
      0  2bc8					      START_LEVEL	_053_L
      1  2bc8				   LEVEL_START SET	*
      2  2bc8		       00 05	   BANK_LEVEL__053_L =	_CURRENT_BANK
      3  2bc8				   LEVEL__053_L SUBROUTINE
      4  2bc8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2bc8
      2  2bc8		       36 23 36 2d*	      .byte.b	"6#6-|#4-4#3-|#2-2$-$-#3-|#2-#-#.-2#2-|2#$#-$.*.3#|-#@$2-.#2.-#|-4#6-#|4-4#2-2#|7-4#-",0
      0  2c1d					      END_LEVEL	_053_L
      1  2c1d		       00		      .byte.b	0
      2  2c1d		       00 56	   LEVEL_SIZE__053_L =	* - LEVEL_START
      3  2c1e				  -	      IF	LEVEL_SIZE__053_L > MAX_LEVEL_SIZE
      4  2c1e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_L
      5  2c1e					      ENDIF
      0  2c1e					      DEFL	_053_R, "5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-"
      0  2c1e					      START_LEVEL	_053_R
      1  2c1e				   LEVEL_START SET	*
      2  2c1e		       00 05	   BANK_LEVEL__053_R =	_CURRENT_BANK
      3  2c1e				   LEVEL__053_R SUBROUTINE
      4  2c1e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c1e
      2  2c1e		       35 2d 35 23*	      .byte.b	"5-5#|3-3#3-#|-3#3-#-#|2#.$.*2$-#|#2.*3.#-#|2#2$-.-$-#|-#-2$5#|-#@2-#4-|-5#4-",0
      0  2c6b					      END_LEVEL	_053_R
      1  2c6b		       00		      .byte.b	0
      2  2c6b		       00 4e	   LEVEL_SIZE__053_R =	* - LEVEL_START
      3  2c6c				  -	      IF	LEVEL_SIZE__053_R > MAX_LEVEL_SIZE
      4  2c6c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__053_R
      5  2c6c					      ENDIF
      0  2c6c					      DEFL	_054_L, "-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-"
      0  2c6c					      START_LEVEL	_054_L
      1  2c6c				   LEVEL_START SET	*
      2  2c6c		       00 05	   BANK_LEVEL__054_L =	_CURRENT_BANK
      3  2c6c				   LEVEL__054_L SUBROUTINE
      4  2c6c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2c6c
      2  2c6c		       2d 38 23 32*	      .byte.b	"-8#2-|2#@-.*.-#2-|#-2$#*2-3#|#3-$2.*2-#|3#2-$.$2-#|-#-$-#.4#|-#3-3#3-|-5#5-",0
      0  2cb8					      END_LEVEL	_054_L
      1  2cb8		       00		      .byte.b	0
      2  2cb8		       00 4d	   LEVEL_SIZE__054_L =	* - LEVEL_START
      3  2cb9				  -	      IF	LEVEL_SIZE__054_L > MAX_LEVEL_SIZE
      4  2cb9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_L
      5  2cb9					      ENDIF
      0  2cb9					      DEFL	_054_R, "2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-"
      0  2cb9					      START_LEVEL	_054_R
      1  2cb9				   LEVEL_START SET	*
      2  2cb9		       00 05	   BANK_LEVEL__054_R =	_CURRENT_BANK
      3  2cb9				   LEVEL__054_R SUBROUTINE
      4  2cb9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2cb9
      2  2cb9		       32 2d 34 23*	      .byte.b	"2-4#5-|3#2-6#|#-$-.#.-$-#|#2-$3.2$@#|#2-.*$.-$-#|3#$.-5#|2-#3-#4-|2-5#4-",0
      0  2d02					      END_LEVEL	_054_R
      1  2d02		       00		      .byte.b	0
      2  2d02		       00 4a	   LEVEL_SIZE__054_R =	* - LEVEL_START
      3  2d03				  -	      IF	LEVEL_SIZE__054_R > MAX_LEVEL_SIZE
      4  2d03				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__054_R
      5  2d03					      ENDIF
      0  2d03					      DEFL	_055_L, "2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-"
      0  2d03					      START_LEVEL	_055_L
      1  2d03				   LEVEL_START SET	*
      2  2d03		       00 05	   BANK_LEVEL__055_L =	_CURRENT_BANK
      3  2d03				   LEVEL__055_L SUBROUTINE
      4  2d03				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d03
      2  2d03		       32 2d 34 23*	      .byte.b	"2-4#6-|2-#2-2#5-|3#2.-#-4#|#-$.*-#-#2-#|#-$*.*3#$-#|#2-$3.4-#|#3-2$#$3-#|4#-@#2-3#|3-7#2-",0
      0  2d5d					      END_LEVEL	_055_L
      1  2d5d		       00		      .byte.b	0
      2  2d5d		       00 5b	   LEVEL_SIZE__055_L =	* - LEVEL_START
      3  2d5e					      IF	LEVEL_SIZE__055_L > MAX_LEVEL_SIZE
      4  2d5e				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_L
      5  2d5e					      ENDIF
      0  2d5e					      DEFL	_055_R, "5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-"
      0  2d5e					      START_LEVEL	_055_R
      1  2d5e				   LEVEL_START SET	*
      2  2d5e		       00 05	   BANK_LEVEL__055_R =	_CURRENT_BANK
      3  2d5e				   LEVEL__055_R SUBROUTINE
      4  2d5e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2d5e
      2  2d5e		       35 2d 34 23*	      .byte.b	"5-4#2-|5-#2-#2-|-5#2-2#-|-#2-$2-$-2#|2#$-.#4-#|#3-*#$#$-#|#2-*2.-$@2#|2#3.-4#-|-6#4-",0
      0  2db3					      END_LEVEL	_055_R
      1  2db3		       00		      .byte.b	0
      2  2db3		       00 56	   LEVEL_SIZE__055_R =	* - LEVEL_START
      3  2db4				  -	      IF	LEVEL_SIZE__055_R > MAX_LEVEL_SIZE
      4  2db4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__055_R
      5  2db4					      ENDIF
      0  2db4					      DEFL	_056_L, "6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#"
      0  2db4					      START_LEVEL	_056_L
      1  2db4				   LEVEL_START SET	*
      2  2db4		       00 05	   BANK_LEVEL__056_L =	_CURRENT_BANK
      3  2db4				   LEVEL__056_L SUBROUTINE
      4  2db4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2db4
      2  2db4		       36 2d 35 23*	      .byte.b	"6-5#-|6-#3-#-|-6#$#-#-|2#.*.#2-#-2#|#2-3.*@$2-#|#2-*.#-2$2-#|#-2$-3#3-#|#2-3#-#3-#|4#3-5#",0
      0  2e0e					      END_LEVEL	_056_L
      1  2e0e		       00		      .byte.b	0
      2  2e0e		       00 5b	   LEVEL_SIZE__056_L =	* - LEVEL_START
      3  2e0f				  -	      IF	LEVEL_SIZE__056_L > MAX_LEVEL_SIZE
      4  2e0f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_L
      5  2e0f					      ENDIF
      0  2e0f					      DEFL	_056_R, "-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-"
      0  2e0f					      START_LEVEL	_056_R
      1  2e0f				   LEVEL_START SET	*
      2  2e0f		       00 05	   BANK_LEVEL__056_R =	_CURRENT_BANK
      3  2e0f				   LEVEL__056_R SUBROUTINE
      4  2e0f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e0f
      2  2e0f		       2d 34 23 2d*	      .byte.b	"-4#-6#-|-#2-#-#4-#-|-#2-3#-2#$2#|-#$2-@#-2#2-#|2#-2$4.3-#|#2-#3-2.4#|#2-2$5#3-|#4-#7-|6#7-",0
      0  2e6a					      END_LEVEL	_056_R
      1  2e6a		       00		      .byte.b	0
      2  2e6a		       00 5c	   LEVEL_SIZE__056_R =	* - LEVEL_START
      3  2e6b					      IF	LEVEL_SIZE__056_R > MAX_LEVEL_SIZE
      4  2e6b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__056_R
      5  2e6b					      ENDIF
      0  2e6b					      DEFL	_057_L, "5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-"
      0  2e6b					      START_LEVEL	_057_L
      1  2e6b				   LEVEL_START SET	*
      2  2e6b		       00 05	   BANK_LEVEL__057_L =	_CURRENT_BANK
      3  2e6b				   LEVEL__057_L SUBROUTINE
      4  2e6b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2e6b
      2  2e6b		       35 2d 36 23*	      .byte.b	"5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-",0
      0  2ec1					      END_LEVEL	_057_L
      1  2ec1		       00		      .byte.b	0
      2  2ec1		       00 57	   LEVEL_SIZE__057_L =	* - LEVEL_START
      3  2ec2				  -	      IF	LEVEL_SIZE__057_L > MAX_LEVEL_SIZE
      4  2ec2				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_L
      5  2ec2					      ENDIF
     60  2ec2
      0  2ec2					      CHECK_BANK_SIZE	"LEVELS2"
      1  2ec2		       06 c2	   .TEMP      =	* - BANK_START
 LEVELS2 (2K) SIZE =  $6c2 , FREE= $13e
      2  2ec2					      ECHO	"LEVELS2", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2ec2				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2ec2				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2ec2				  -	      ERR
      6  2ec2					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS3.asm LEVEL 2 PASS 4
      0  2ec2					      include	"BANK_LEVELS3.asm"
      1  2ec2							;    Sokoboo - a Sokoban implementation
      2  2ec2							;    using a generic tile-based display engine for the Atari 2600
      3  2ec2							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  2ec2							;
      5  2ec2							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  2ec2							;
      7  2ec2							;    Code related to the generic tile-based display engine was developed by
      8  2ec2							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  2ec2							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  2ec2							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  2ec2							;
     12  2ec2							;    Code related to music and sound effects uses the TIATracker music player
     13  2ec2							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  2ec2							;    directory for Apache licensing details.
     15  2ec2							;
     16  2ec2							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  2ec2							;    See the copyright notices in the License directory for a list of level
     18  2ec2							;    contributors.
     19  2ec2							;
     20  2ec2							;    Except where otherwise indicated, this software is released under the
     21  2ec2							;    following licensing arrangement...
     22  2ec2							;
     23  2ec2							;    This program is free software: you can redistribute it and/or modify
     24  2ec2							;    it under the terms of the GNU General Public License as published by
     25  2ec2							;    the Free Software Foundation, either version 3 of the License, or
     26  2ec2							;    (at your option) any later version.
     27  2ec2							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  2ec2
     29  2ec2							;    This program is distributed in the hope that it will be useful,
     30  2ec2							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  2ec2							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  2ec2							;    GNU General Public License for more details.
     33  2ec2
      0  2ec2					      NEWBANK	LEVELS3
      1  362c ????				      SEG	LEVELS3
      2  3000					      ORG	ORIGIN
      3  3000					      RORG	$F000
      4  3000				   BANK_START SET	*
      5  3000				   LEVELS3    SET	ORIGIN / 2048
      6  3000				   ORIGIN     SET	ORIGIN + 2048
      7  3000				   _CURRENT_BANK SET	LEVELS3
     35  3000
      0  3000					      DEFL	_060_R, "3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#"
      0  3000					      START_LEVEL	_060_R
      1  3000				   LEVEL_START SET	*
      2  3000		       00 06	   BANK_LEVEL__060_R =	_CURRENT_BANK
      3  3000				   LEVEL__060_R SUBROUTINE
      4  3000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3000
      2  3000		       33 2d 36 23*	      .byte.b	"3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#",0
      0  3048					      END_LEVEL	_060_R
      1  3048		       00		      .byte.b	0
      2  3048		       00 49	   LEVEL_SIZE__060_R =	* - LEVEL_START
      3  3049				  -	      IF	LEVEL_SIZE__060_R > MAX_LEVEL_SIZE
      4  3049				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__060_R
      5  3049					      ENDIF
      0  3049					      DEFL	_061_L, "10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#"
      0  3049					      START_LEVEL	_061_L
      1  3049				   LEVEL_START SET	*
      2  3049		       00 06	   BANK_LEVEL__061_L =	_CURRENT_BANK
      3  3049				   LEVEL__061_L SUBROUTINE
      4  3049				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3049
      2  3049		       31 30 23 2d*	      .byte.b	"10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#",0
      0  309d					      END_LEVEL	_061_L
      1  309d		       00		      .byte.b	0
      2  309d		       00 55	   LEVEL_SIZE__061_L =	* - LEVEL_START
      3  309e				  -	      IF	LEVEL_SIZE__061_L > MAX_LEVEL_SIZE
      4  309e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_L
      5  309e					      ENDIF
      0  309e					      DEFL	_061_R, "4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#"
      0  309e					      START_LEVEL	_061_R
      1  309e				   LEVEL_START SET	*
      2  309e		       00 06	   BANK_LEVEL__061_R =	_CURRENT_BANK
      3  309e				   LEVEL__061_R SUBROUTINE
      4  309e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  309e
      2  309e		       34 2d 35 23*	      .byte.b	"4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#",0
      0  30e7					      END_LEVEL	_061_R
      1  30e7		       00		      .byte.b	0
      2  30e7		       00 4a	   LEVEL_SIZE__061_R =	* - LEVEL_START
      3  30e8				  -	      IF	LEVEL_SIZE__061_R > MAX_LEVEL_SIZE
      4  30e8				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_R
      5  30e8					      ENDIF
      0  30e8					      DEFL	_062_L, "-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#"
      0  30e8					      START_LEVEL	_062_L
      1  30e8				   LEVEL_START SET	*
      2  30e8		       00 06	   BANK_LEVEL__062_L =	_CURRENT_BANK
      3  30e8				   LEVEL__062_L SUBROUTINE
      4  30e8				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  30e8
      2  30e8		       2d 35 23 36*	      .byte.b	"-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#",0
      0  313f					      END_LEVEL	_062_L
      1  313f		       00		      .byte.b	0
      2  313f		       00 58	   LEVEL_SIZE__062_L =	* - LEVEL_START
      3  3140				  -	      IF	LEVEL_SIZE__062_L > MAX_LEVEL_SIZE
      4  3140				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_L
      5  3140					      ENDIF
      0  3140					      DEFL	_062_R, "5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-"
      0  3140					      START_LEVEL	_062_R
      1  3140				   LEVEL_START SET	*
      2  3140		       00 06	   BANK_LEVEL__062_R =	_CURRENT_BANK
      3  3140				   LEVEL__062_R SUBROUTINE
      4  3140				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3140
      2  3140		       35 2d 35 23*	      .byte.b	"5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-",0
      0  318c					      END_LEVEL	_062_R
      1  318c		       00		      .byte.b	0
      2  318c		       00 4d	   LEVEL_SIZE__062_R =	* - LEVEL_START
      3  318d				  -	      IF	LEVEL_SIZE__062_R > MAX_LEVEL_SIZE
      4  318d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_R
      5  318d					      ENDIF
      0  318d					      DEFL	_063_L, "2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#"
      0  318d					      START_LEVEL	_063_L
      1  318d				   LEVEL_START SET	*
      2  318d		       00 06	   BANK_LEVEL__063_L =	_CURRENT_BANK
      3  318d				   LEVEL__063_L SUBROUTINE
      4  318d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  318d
      2  318d		       32 2d 35 23*	      .byte.b	"2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#",0
      0  31dd					      END_LEVEL	_063_L
      1  31dd		       00		      .byte.b	0
      2  31dd		       00 51	   LEVEL_SIZE__063_L =	* - LEVEL_START
      3  31de				  -	      IF	LEVEL_SIZE__063_L > MAX_LEVEL_SIZE
      4  31de				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_L
      5  31de					      ENDIF
      0  31de					      DEFL	_063_R, "2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-"
      0  31de					      START_LEVEL	_063_R
      1  31de				   LEVEL_START SET	*
      2  31de		       00 06	   BANK_LEVEL__063_R =	_CURRENT_BANK
      3  31de				   LEVEL__063_R SUBROUTINE
      4  31de				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  31de
      2  31de		       32 2d 36 23*	      .byte.b	"2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-",0
      0  3230					      END_LEVEL	_063_R
      1  3230		       00		      .byte.b	0
      2  3230		       00 53	   LEVEL_SIZE__063_R =	* - LEVEL_START
      3  3231				  -	      IF	LEVEL_SIZE__063_R > MAX_LEVEL_SIZE
      4  3231				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_R
      5  3231					      ENDIF
      0  3231					      DEFL	_064_L, "-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-"
      0  3231					      START_LEVEL	_064_L
      1  3231				   LEVEL_START SET	*
      2  3231		       00 06	   BANK_LEVEL__064_L =	_CURRENT_BANK
      3  3231				   LEVEL__064_L SUBROUTINE
      4  3231				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3231
      2  3231		       2d 38 23 33*	      .byte.b	"-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-",0
      0  328c					      END_LEVEL	_064_L
      1  328c		       00		      .byte.b	0
      2  328c		       00 5c	   LEVEL_SIZE__064_L =	* - LEVEL_START
      3  328d				  -	      IF	LEVEL_SIZE__064_L > MAX_LEVEL_SIZE
      4  328d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_L
      5  328d					      ENDIF
      0  328d					      DEFL	_064_R, "4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-"
      0  328d					      START_LEVEL	_064_R
      1  328d				   LEVEL_START SET	*
      2  328d		       00 06	   BANK_LEVEL__064_R =	_CURRENT_BANK
      3  328d				   LEVEL__064_R SUBROUTINE
      4  328d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  328d
      2  328d		       34 23 2d 36*	      .byte.b	"4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-",0
      0  32d9					      END_LEVEL	_064_R
      1  32d9		       00		      .byte.b	0
      2  32d9		       00 4d	   LEVEL_SIZE__064_R =	* - LEVEL_START
      3  32da				  -	      IF	LEVEL_SIZE__064_R > MAX_LEVEL_SIZE
      4  32da				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_R
      5  32da					      ENDIF
      0  32da					      DEFL	_065_L, "2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-"
      0  32da					      START_LEVEL	_065_L
      1  32da				   LEVEL_START SET	*
      2  32da		       00 06	   BANK_LEVEL__065_L =	_CURRENT_BANK
      3  32da				   LEVEL__065_L SUBROUTINE
      4  32da				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  32da
      2  32da		       32 2d 35 23*	      .byte.b	"2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-",0
      0  3332					      END_LEVEL	_065_L
      1  3332		       00		      .byte.b	0
      2  3332		       00 59	   LEVEL_SIZE__065_L =	* - LEVEL_START
      3  3333				  -	      IF	LEVEL_SIZE__065_L > MAX_LEVEL_SIZE
      4  3333				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_L
      5  3333					      ENDIF
      0  3333					      DEFL	_065_R, "3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#"
      0  3333					      START_LEVEL	_065_R
      1  3333				   LEVEL_START SET	*
      2  3333		       00 06	   BANK_LEVEL__065_R =	_CURRENT_BANK
      3  3333				   LEVEL__065_R SUBROUTINE
      4  3333				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3333
      2  3333		       33 2d 35 23*	      .byte.b	"3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#",0
      0  337b					      END_LEVEL	_065_R
      1  337b		       00		      .byte.b	0
      2  337b		       00 49	   LEVEL_SIZE__065_R =	* - LEVEL_START
      3  337c				  -	      IF	LEVEL_SIZE__065_R > MAX_LEVEL_SIZE
      4  337c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_R
      5  337c					      ENDIF
      0  337c					      DEFL	_066_L, "10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-"
      0  337c					      START_LEVEL	_066_L
      1  337c				   LEVEL_START SET	*
      2  337c		       00 06	   BANK_LEVEL__066_L =	_CURRENT_BANK
      3  337c				   LEVEL__066_L SUBROUTINE
      4  337c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  337c
      2  337c		       31 30 23 33*	      .byte.b	"10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-",0
      0  33d6					      END_LEVEL	_066_L
      1  33d6		       00		      .byte.b	0
      2  33d6		       00 5b	   LEVEL_SIZE__066_L =	* - LEVEL_START
      3  33d7				  -	      IF	LEVEL_SIZE__066_L > MAX_LEVEL_SIZE
      4  33d7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_L
      5  33d7					      ENDIF
      0  33d7					      DEFL	_066_R, "2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#"
      0  33d7					      START_LEVEL	_066_R
      1  33d7				   LEVEL_START SET	*
      2  33d7		       00 06	   BANK_LEVEL__066_R =	_CURRENT_BANK
      3  33d7				   LEVEL__066_R SUBROUTINE
      4  33d7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  33d7
      2  33d7		       32 2d 35 23*	      .byte.b	"2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#",0
      0  342d					      END_LEVEL	_066_R
      1  342d		       00		      .byte.b	0
      2  342d		       00 57	   LEVEL_SIZE__066_R =	* - LEVEL_START
      3  342e				  -	      IF	LEVEL_SIZE__066_R > MAX_LEVEL_SIZE
      4  342e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_R
      5  342e					      ENDIF
      0  342e					      DEFL	_067_L, "8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#"
      0  342e					      START_LEVEL	_067_L
      1  342e				   LEVEL_START SET	*
      2  342e		       00 06	   BANK_LEVEL__067_L =	_CURRENT_BANK
      3  342e				   LEVEL__067_L SUBROUTINE
      4  342e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  342e
      2  342e		       38 23 33 2d*	      .byte.b	"8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#",0
      0  347b					      END_LEVEL	_067_L
      1  347b		       00		      .byte.b	0
      2  347b		       00 4e	   LEVEL_SIZE__067_L =	* - LEVEL_START
      3  347c				  -	      IF	LEVEL_SIZE__067_L > MAX_LEVEL_SIZE
      4  347c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_L
      5  347c					      ENDIF
      0  347c					      DEFL	_067_R, "7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-"
      0  347c					      START_LEVEL	_067_R
      1  347c				   LEVEL_START SET	*
      2  347c		       00 06	   BANK_LEVEL__067_R =	_CURRENT_BANK
      3  347c				   LEVEL__067_R SUBROUTINE
      4  347c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  347c
      2  347c		       37 23 32 2d*	      .byte.b	"7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-",0
      0  34e1					      END_LEVEL	_067_R
      1  34e1		       00		      .byte.b	0
      2  34e1		       00 66	   LEVEL_SIZE__067_R =	* - LEVEL_START
      3  34e2					      IF	LEVEL_SIZE__067_R > MAX_LEVEL_SIZE
      4  34e2				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_R
      5  34e2					      ENDIF
      0  34e2					      DEFL	_068_L, "10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-"
      0  34e2					      START_LEVEL	_068_L
      1  34e2				   LEVEL_START SET	*
      2  34e2		       00 06	   BANK_LEVEL__068_L =	_CURRENT_BANK
      3  34e2				   LEVEL__068_L SUBROUTINE
      4  34e2				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  34e2
      2  34e2		       31 30 23 7c*	      .byte.b	"10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-",0
      0  3536					      END_LEVEL	_068_L
      1  3536		       00		      .byte.b	0
      2  3536		       00 55	   LEVEL_SIZE__068_L =	* - LEVEL_START
      3  3537				  -	      IF	LEVEL_SIZE__068_L > MAX_LEVEL_SIZE
      4  3537				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_L
      5  3537					      ENDIF
      0  3537					      DEFL	_068_R, "5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-"
      0  3537					      START_LEVEL	_068_R
      1  3537				   LEVEL_START SET	*
      2  3537		       00 06	   BANK_LEVEL__068_R =	_CURRENT_BANK
      3  3537				   LEVEL__068_R SUBROUTINE
      4  3537				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3537
      2  3537		       35 2d 35 23*	      .byte.b	"5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-",0
      0  358d					      END_LEVEL	_068_R
      1  358d		       00		      .byte.b	0
      2  358d		       00 57	   LEVEL_SIZE__068_R =	* - LEVEL_START
      3  358e				  -	      IF	LEVEL_SIZE__068_R > MAX_LEVEL_SIZE
      4  358e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_R
      5  358e					      ENDIF
      0  358e					      DEFL	_069_L, "-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#"
      0  358e					      START_LEVEL	_069_L
      1  358e				   LEVEL_START SET	*
      2  358e		       00 06	   BANK_LEVEL__069_L =	_CURRENT_BANK
      3  358e				   LEVEL__069_L SUBROUTINE
      4  358e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  358e
      2  358e		       2d 36 23 33*	      .byte.b	"-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#",0
      0  35dc					      END_LEVEL	_069_L
      1  35dc		       00		      .byte.b	0
      2  35dc		       00 4f	   LEVEL_SIZE__069_L =	* - LEVEL_START
      3  35dd				  -	      IF	LEVEL_SIZE__069_L > MAX_LEVEL_SIZE
      4  35dd				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_L
      5  35dd					      ENDIF
      0  35dd					      DEFL	_069_R, "2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-"
      0  35dd					      START_LEVEL	_069_R
      1  35dd				   LEVEL_START SET	*
      2  35dd		       00 06	   BANK_LEVEL__069_R =	_CURRENT_BANK
      3  35dd				   LEVEL__069_R SUBROUTINE
      4  35dd				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  35dd
      2  35dd		       32 2d 35 23*	      .byte.b	"2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-",0
      0  362b					      END_LEVEL	_069_R
      1  362b		       00		      .byte.b	0
      2  362b		       00 4f	   LEVEL_SIZE__069_R =	* - LEVEL_START
      3  362c				  -	      IF	LEVEL_SIZE__069_R > MAX_LEVEL_SIZE
      4  362c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_R
      5  362c					      ENDIF
     55  362c
     56  362c
     57  362c
      0  362c					      CHECK_BANK_SIZE	"LEVELS3 -- full 2K"
      1  362c		       06 2c	   .TEMP      =	* - BANK_START
 LEVELS3 -- full 2K (2K) SIZE =  $62c , FREE= $1d4
      2  362c					      ECHO	"LEVELS3 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  362c				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  362c				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  362c				  -	      ERR
      6  362c					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS4.asm LEVEL 2 PASS 4
      0  362c					      include	"BANK_LEVELS4.asm"
      1  362c							;    Sokoboo - a Sokoban implementation
      2  362c							;    using a generic tile-based display engine for the Atari 2600
      3  362c							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  362c							;
      5  362c							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  362c							;
      7  362c							;    Code related to the generic tile-based display engine was developed by
      8  362c							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  362c							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  362c							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  362c							;
     12  362c							;    Code related to music and sound effects uses the TIATracker music player
     13  362c							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  362c							;    directory for Apache licensing details.
     15  362c							;
     16  362c							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  362c							;    See the copyright notices in the License directory for a list of level
     18  362c							;    contributors.
     19  362c							;
     20  362c							;    Except where otherwise indicated, this software is released under the
     21  362c							;    following licensing arrangement...
     22  362c							;
     23  362c							;    This program is free software: you can redistribute it and/or modify
     24  362c							;    it under the terms of the GNU General Public License as published by
     25  362c							;    the Free Software Foundation, either version 3 of the License, or
     26  362c							;    (at your option) any later version.
     27  362c							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  362c
     29  362c							;    This program is distributed in the hope that it will be useful,
     30  362c							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  362c							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  362c							;    GNU General Public License for more details.
     33  362c
     34  362c							; level definitions
     35  362c							; Sample level definitions.
     36  362c							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
     37  362c							; have as many banks as you like.
     38  362c
      0  362c					      NEWBANK	LEVELS4
      1  3db3 ????				      SEG	LEVELS4
      2  3800					      ORG	ORIGIN
      3  3800					      RORG	$F000
      4  3800				   BANK_START SET	*
      5  3800				   LEVELS4    SET	ORIGIN / 2048
      6  3800				   ORIGIN     SET	ORIGIN + 2048
      7  3800				   _CURRENT_BANK SET	LEVELS4
     40  3800
     41  3800							; Level definitions
     42  3800
     43  3800							; "sokhard" collection
     44  3800
      0  3800					      START_LEVEL	_102_Natalie
      1  3800				   LEVEL_START SET	*
      2  3800		       00 07	   BANK_LEVEL__102_Natalie =	_CURRENT_BANK
      3  3800				   LEVEL__102_Natalie SUBROUTINE
      4  3800				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3800
     46  3800		       31 31 23 7c*	      .byte.b	"11#|2#2-#@4.#|2#3-2$.2*#|2#-$2-2$#.#|#2-$#-#2-.#|#2-$-#-2#-#|#9-#|11#",0
      0  3846					      END_LEVEL	_102_Natalie
      1  3846		       00		      .byte.b	0
      2  3846		       00 47	   LEVEL_SIZE__102_Natalie =	* - LEVEL_START
      3  3847				  -	      IF	LEVEL_SIZE__102_Natalie > MAX_LEVEL_SIZE
      4  3847				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Natalie
      5  3847					      ENDIF
     48  3847
      0  3847					      START_LEVEL	_102_Mirabel
      1  3847				   LEVEL_START SET	*
      2  3847		       00 07	   BANK_LEVEL__102_Mirabel =	_CURRENT_BANK
      3  3847				   LEVEL__102_Mirabel SUBROUTINE
      4  3847				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3847
     50  3847		       31 31 23 7c*	      .byte.b	"11#|6#3-2#|2#2-2#$2-2#|2#2-#-2$-2#|#7-3#|#.-#$-#-3#|#.#.-#2-$-#|#3.#-2$#@#|#-2.4-$-#|#2-8#|11#",0
      0  38a6					      END_LEVEL	_102_Mirabel
      1  38a6		       00		      .byte.b	0
      2  38a6		       00 60	   LEVEL_SIZE__102_Mirabel =	* - LEVEL_START
      3  38a7				  -	      IF	LEVEL_SIZE__102_Mirabel > MAX_LEVEL_SIZE
      4  38a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Mirabel
      5  38a7					      ENDIF
     52  38a7
      0  38a7					      START_LEVEL	_102_Oralia
      1  38a7				   LEVEL_START SET	*
      2  38a7		       00 07	   BANK_LEVEL__102_Oralia =	_CURRENT_BANK
      3  38a7				   LEVEL__102_Oralia SUBROUTINE
      4  38a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  38a7
     54  38a7		       39 23 7c 23*	      .byte.b	"9#|#2.$.#2-#|#4.2*-#|#-$.2#2-#|2#-$2-$-#|4#$-$-#|#-$3-$-#|#5-#@#|9#",0
      0  38eb					      END_LEVEL	_102_Oralia
      1  38eb		       00		      .byte.b	0
      2  38eb		       00 45	   LEVEL_SIZE__102_Oralia =	* - LEVEL_START
      3  38ec				  -	      IF	LEVEL_SIZE__102_Oralia > MAX_LEVEL_SIZE
      4  38ec				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Oralia
      5  38ec					      ENDIF
     56  38ec
     57  38ec
     58  38ec							;---------------------------------------------------------------------------------------------------
     59  38ec							; IMAGE IS ABOVE DEFINITION
     60  38ec
     61  38ec							;  ###########
     62  38ec							;  #  #      #
     63  38ec							;  # $# $ $$ #
     64  38ec							;  #  ##$#$  #
     65  38ec							;  #  $    #@#
     66  38ec							;  # $## #  ##
     67  38ec							;  ##	# .## #
     68  38ec							;  ##$ #.*. ##
     69  38ec							;  # ..*. *. #
     70  38ec							;  # # .. #  #
     71  38ec							;  ###########
     72  38ec
      0  38ec					      START_LEVEL	_102_Raven
      1  38ec				   LEVEL_START SET	*
      2  38ec		       00 07	   BANK_LEVEL__102_Raven =	_CURRENT_BANK
      3  38ec				   LEVEL__102_Raven SUBROUTINE
      4  38ec				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  38ec
     74  38ec		       31 31 23 7c*	      .byte.b	"11#|#2-#6-#|#-$#-$-2$-#|#2-2#$#$2-#|#2-$4-#@#|#-$2#-#2-2#|2#2-#-.2#-#|2#$-#.*.-2#|#-2.*.-*.-#|#-#-2.-#2-#|11#",0
      0  395a					      END_LEVEL	_102_Raven
      1  395a		       00		      .byte.b	0
      2  395a		       00 6f	   LEVEL_SIZE__102_Raven =	* - LEVEL_START
      3  395b					      IF	LEVEL_SIZE__102_Raven > MAX_LEVEL_SIZE
      4  395b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Raven
      5  395b					      ENDIF
     76  395b
     77  395b							;  ############
     78  395b							;  #@##. #  # #
     79  395b							;  #**..$#    #
     80  395b							;  #. $..#  # #
     81  395b							;  # $#.$#$$$ #
     82  395b							;  #	      ##
     83  395b							;  #  ##  #   #
     84  395b							;  ############
     85  395b
      0  395b					      START_LEVEL	_103_Adin
      1  395b				   LEVEL_START SET	*
      2  395b		       00 07	   BANK_LEVEL__103_Adin =	_CURRENT_BANK
      3  395b				   LEVEL__103_Adin SUBROUTINE
      4  395b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  395b
     87  395b		       31 32 23 7c*	      .byte.b	"12#|#@2#.-#2-#-#|#2*2.$#4-#|#.-$2.#2-#-#|#-$#.$#3$-#|#9-2#|#2-2#2-#3-#|12#",0
      0  39a6					      END_LEVEL	_103_Adin
      1  39a6		       00		      .byte.b	0
      2  39a6		       00 4c	   LEVEL_SIZE__103_Adin =	* - LEVEL_START
      3  39a7				  -	      IF	LEVEL_SIZE__103_Adin > MAX_LEVEL_SIZE
      4  39a7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Adin
      5  39a7					      ENDIF
     89  39a7
     90  39a7							;  #######___
     91  39a7							;  #	  #___
     92  39a7							;  #	$$#___
     93  39a7							;  #.*  .#___
     94  39a7							;  #$*$#*###_
     95  39a7							;  #@*... .#_
     96  39a7							;  #####$ .##
     97  39a7							;  ___# $ $ #
     98  39a7							;  ___#     #
     99  39a7							;  ___#######	(_ = modified by boo from wall)
    100  39a7
      0  39a7					      START_LEVEL	_103_Ajalae
      1  39a7				   LEVEL_START SET	*
      2  39a7		       00 07	   BANK_LEVEL__103_Ajalae =	_CURRENT_BANK
      3  39a7				   LEVEL__103_Ajalae SUBROUTINE
      4  39a7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  39a7
    102  39a7		       37 23 7c 23*	      .byte.b	"7#|#5-#|#3-2$#|#.*2-.#|#$*$#*3#|#@*3.-.#|5#$-.2#|3-#-$-$-#|3-#5-#|3-7#",0
      0  39ee					      END_LEVEL	_103_Ajalae
      1  39ee		       00		      .byte.b	0
      2  39ee		       00 48	   LEVEL_SIZE__103_Ajalae =	* - LEVEL_START
      3  39ef				  -	      IF	LEVEL_SIZE__103_Ajalae > MAX_LEVEL_SIZE
      4  39ef				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Ajalae
      5  39ef					      ENDIF
    104  39ef
    105  39ef							;  ############
    106  39ef							;  #@#  #     #
    107  39ef							;  #  # #$#$# #
    108  39ef							;  # *$       #
    109  39ef							;  #..##$#$   #
    110  39ef							;  #..#. #  $ #
    111  39ef							;  #....# $$$##
    112  39ef							;  #	       #
    113  39ef							;  ############
    114  39ef
      0  39ef					      START_LEVEL	_103_Arielle
      1  39ef				   LEVEL_START SET	*
      2  39ef		       00 07	   BANK_LEVEL__103_Arielle =	_CURRENT_BANK
      3  39ef				   LEVEL__103_Arielle SUBROUTINE
      4  39ef				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  39ef
    116  39ef		       31 32 23 7c*	      .byte.b	"12#|#@#2-#5-#|#2-#-#$#$#-#|#-*$7-#|#2.2#$#$3-#|#2.#.-#2-$-#|#4.#-3$2#|#10-#|12#",0
      0  3a3f					      END_LEVEL	_103_Arielle
      1  3a3f		       00		      .byte.b	0
      2  3a3f		       00 51	   LEVEL_SIZE__103_Arielle =	* - LEVEL_START
      3  3a40				  -	      IF	LEVEL_SIZE__103_Arielle > MAX_LEVEL_SIZE
      4  3a40				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Arielle
      5  3a40					      ENDIF
    118  3a40
    119  3a40
    120  3a40
      0  3a40					      START_LEVEL	_1XJH_Tara_Gelson
      1  3a40				   LEVEL_START SET	*
      2  3a40		       00 07	   BANK_LEVEL__1XJH_Tara_Gelson =	_CURRENT_BANK
      3  3a40				   LEVEL__1XJH_Tara_Gelson SUBROUTINE
      4  3a40				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a40
    122  3a40		       38 23 7c 23*	      .byte.b	"8#|#2-#2-*#|#2-*-*-#|#-*$-$-#|#2-.#.-#|#3-#-*#|2#-@3-#|8#",0
      0  3a7a					      END_LEVEL	_1XJH_Tara_Gelson
      1  3a7a		       00		      .byte.b	0
      2  3a7a		       00 3b	   LEVEL_SIZE__1XJH_Tara_Gelson =	* - LEVEL_START
      3  3a7b				  -	      IF	LEVEL_SIZE__1XJH_Tara_Gelson > MAX_LEVEL_SIZE
      4  3a7b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1XJH_Tara_Gelson
      5  3a7b					      ENDIF
    124  3a7b
      0  3a7b					      START_LEVEL	_1R7X_Alison
      1  3a7b				   LEVEL_START SET	*
      2  3a7b		       00 07	   BANK_LEVEL__1R7X_Alison =	_CURRENT_BANK
      3  3a7b				   LEVEL__1R7X_Alison SUBROUTINE
      4  3a7b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3a7b
    126  3a7b		       37 23 7c 23*	      .byte.b	"7#|#2-.2-#|#-$*2$#|#-2.$.#|#@*-$-#|2#.3-#|7#",0
      0  3aa8					      END_LEVEL	_1R7X_Alison
      1  3aa8		       00		      .byte.b	0
      2  3aa8		       00 2e	   LEVEL_SIZE__1R7X_Alison =	* - LEVEL_START
      3  3aa9				  -	      IF	LEVEL_SIZE__1R7X_Alison > MAX_LEVEL_SIZE
      4  3aa9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1R7X_Alison
      5  3aa9					      ENDIF
    128  3aa9
      0  3aa9					      START_LEVEL	_1KWD_Cecile_Clayworth
      1  3aa9				   LEVEL_START SET	*
      2  3aa9		       00 07	   BANK_LEVEL__1KWD_Cecile_Clayworth =	_CURRENT_BANK
      3  3aa9				   LEVEL__1KWD_Cecile_Clayworth SUBROUTINE
      4  3aa9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3aa9
    130  3aa9		       38 23 7c 33*	      .byte.b	"8#|3#.2-.#|#-$4-#|#-*2#2$#|#3-$-+#|#-*.-*-#|#6-#|8#",0
      0  3add					      END_LEVEL	_1KWD_Cecile_Clayworth
      1  3add		       00		      .byte.b	0
      2  3add		       00 35	   LEVEL_SIZE__1KWD_Cecile_Clayworth =	* - LEVEL_START
      3  3ade				  -	      IF	LEVEL_SIZE__1KWD_Cecile_Clayworth > MAX_LEVEL_SIZE
      4  3ade				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1KWD_Cecile_Clayworth
      5  3ade					      ENDIF
    132  3ade
      0  3ade					      START_LEVEL	_1EKT_Samantha_Gelson
      1  3ade				   LEVEL_START SET	*
      2  3ade		       00 07	   BANK_LEVEL__1EKT_Samantha_Gelson =	_CURRENT_BANK
      3  3ade				   LEVEL__1EKT_Samantha_Gelson SUBROUTINE
      4  3ade				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3ade
    134  3ade		       38 23 7c 23*	      .byte.b	"8#|#-*3-.#|#2-$-*-#|#-.$-$-#|#*-*2-*#|#.#-#2-#|#4-@-#|8#",0
      0  3b17					      END_LEVEL	_1EKT_Samantha_Gelson
      1  3b17		       00		      .byte.b	0
      2  3b17		       00 3a	   LEVEL_SIZE__1EKT_Samantha_Gelson =	* - LEVEL_START
      3  3b18				  -	      IF	LEVEL_SIZE__1EKT_Samantha_Gelson > MAX_LEVEL_SIZE
      4  3b18				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1EKT_Samantha_Gelson
      5  3b18					      ENDIF
    136  3b18
      0  3b18					      START_LEVEL	_0VM5_Andrea_Wadd
      1  3b18				   LEVEL_START SET	*
      2  3b18		       00 07	   BANK_LEVEL__0VM5_Andrea_Wadd =	_CURRENT_BANK
      3  3b18				   LEVEL__0VM5_Andrea_Wadd SUBROUTINE
      4  3b18				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b18
    138  3b18		       37 23 7c 23*	      .byte.b	"7#|#3-#-#|#-$*2-#|#-.-+-#|#-*2$-#|2#2-.-#|7#",0
      0  3b45					      END_LEVEL	_0VM5_Andrea_Wadd
      1  3b45		       00		      .byte.b	0
      2  3b45		       00 2e	   LEVEL_SIZE__0VM5_Andrea_Wadd =	* - LEVEL_START
      3  3b46				  -	      IF	LEVEL_SIZE__0VM5_Andrea_Wadd > MAX_LEVEL_SIZE
      4  3b46				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0VM5_Andrea_Wadd
      5  3b46					      ENDIF
    140  3b46
      0  3b46					      START_LEVEL	_0PAL_Jill_Leatherby
      1  3b46				   LEVEL_START SET	*
      2  3b46		       00 07	   BANK_LEVEL__0PAL_Jill_Leatherby =	_CURRENT_BANK
      3  3b46				   LEVEL__0PAL_Jill_Leatherby SUBROUTINE
      4  3b46				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b46
    142  3b46		       37 23 7c 23*	      .byte.b	"7#|#3-3#|#2-2*-#|#3-$-#|#2-$2.#|3#@2-#|7#",0
      0  3b70					      END_LEVEL	_0PAL_Jill_Leatherby
      1  3b70		       00		      .byte.b	0
      2  3b70		       00 2b	   LEVEL_SIZE__0PAL_Jill_Leatherby =	* - LEVEL_START
      3  3b71				  -	      IF	LEVEL_SIZE__0PAL_Jill_Leatherby > MAX_LEVEL_SIZE
      4  3b71				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0PAL_Jill_Leatherby
      5  3b71					      ENDIF
    144  3b71
      0  3b71					      START_LEVEL	_0IZ1_Sophia
      1  3b71				   LEVEL_START SET	*
      2  3b71		       00 07	   BANK_LEVEL__0IZ1_Sophia =	_CURRENT_BANK
      3  3b71				   LEVEL__0IZ1_Sophia SUBROUTINE
      4  3b71				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b71
    146  3b71		       37 23 7c 23*	      .byte.b	"7#|#5-#|#@$.#-#|#*$2-.#|#-2$2-#|#-.-.-#|7#",0
      0  3b9c					      END_LEVEL	_0IZ1_Sophia
      1  3b9c		       00		      .byte.b	0
      2  3b9c		       00 2c	   LEVEL_SIZE__0IZ1_Sophia =	* - LEVEL_START
      3  3b9d				  -	      IF	LEVEL_SIZE__0IZ1_Sophia > MAX_LEVEL_SIZE
      4  3b9d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0IZ1_Sophia
      5  3b9d					      ENDIF
    148  3b9d
      0  3b9d					      START_LEVEL	_0CNH_Alice
      1  3b9d				   LEVEL_START SET	*
      2  3b9d		       00 07	   BANK_LEVEL__0CNH_Alice =	_CURRENT_BANK
      3  3b9d				   LEVEL__0CNH_Alice SUBROUTINE
      4  3b9d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3b9d
    150  3b9d		       37 23 7c 23*	      .byte.b	"7#|#.4-#|#$*-#-#|#.2-$*#|#-.$2-#|#@-*2-#|7#",0
      0  3bc9					      END_LEVEL	_0CNH_Alice
      1  3bc9		       00		      .byte.b	0
      2  3bc9		       00 2d	   LEVEL_SIZE__0CNH_Alice =	* - LEVEL_START
      3  3bca				  -	      IF	LEVEL_SIZE__0CNH_Alice > MAX_LEVEL_SIZE
      4  3bca				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0CNH_Alice
      5  3bca					      ENDIF
    152  3bca
    153  3bca							;  START_LEVEL TowC
    154  3bca							;   .byte "4-5#|4-#3-#|4-#$2-#|2-3#2-$2#|2-#2-$-$-#|3#-#-2#-#3-6#|#3-#-2#-5#2-2.#|#-$2-$10-2.#|5#-3#-#@2#2-2.#|4-#5-9#|4-7#",0
    155  3bca							;  END_LEVEL TowC
    156  3bca
    157  3bca							;  START_LEVEL SimpleC
    158  3bca							;  .byte "7#|#.@-#-#|#$*-$-#|#3-$-#|#-..--#|#--*--#|7#",0
    159  3bca							;  END_LEVEL SimpleC
    160  3bca
      0  3bca					      START_LEVEL	bAlfa_DrFogh
      1  3bca				   LEVEL_START SET	*
      2  3bca		       00 07	   BANK_LEVEL_bAlfa_DrFogh =	_CURRENT_BANK
      3  3bca				   LEVEL_bAlfa_DrFogh SUBROUTINE
      4  3bca				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3bca
    162  3bca		       32 2d 34 23*	      .byte.b	"2-4#2-4#|-2#2-2#-#2-#|-#4-3#2-2#|2#2-2*2-#.2-2#|#2-*2-*-#*#2-#|#-*4-2*2-#-#|#-*-2#-*3-#-#|2#-*2-*#*#-#-#|-#$-2*-#-*-#-#|-#@#2-2#5-#|-2#2-4#2-3#|2-#2-#2-4#|2-#2-#|2-4#",0
      0  3c71					      END_LEVEL	bAlfa_DrFogh
      1  3c71		       00		      .byte.b	0
      2  3c71		       00 a8	   LEVEL_SIZE_bAlfa_DrFogh =	* - LEVEL_START
      3  3c72					      IF	LEVEL_SIZE_bAlfa_DrFogh > MAX_LEVEL_SIZE
      4  3c72				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAlfa_DrFogh
      5  3c72					      ENDIF
    164  3c72
      0  3c72					      START_LEVEL	b51X_Sharpen
      1  3c72				   LEVEL_START SET	*
      2  3c72		       00 07	   BANK_LEVEL_b51X_Sharpen =	_CURRENT_BANK
      3  3c72				   LEVEL_b51X_Sharpen SUBROUTINE
      4  3c72				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3c72
    166  3c72		       2d 39 23 33*	      .byte.b	"-9#3-|-#7-#3-|-#-$-2$-$#3-|3#$#2-$-#3-|#.#3-2$-2#2-|#.3#3-$-#2-|#.#.-$-2#-3#|#3.$-$2#-$-#|#3.$3-$2-@#|#2.3#$3#-2#|#4.#5-#-|12#-",0
      0  3cf2					      END_LEVEL	b51X_Sharpen
      1  3cf2		       00		      .byte.b	0
      2  3cf2		       00 81	   LEVEL_SIZE_b51X_Sharpen =	* - LEVEL_START
      3  3cf3				  -	      IF	LEVEL_SIZE_b51X_Sharpen > MAX_LEVEL_SIZE
      4  3cf3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_b51X_Sharpen
      5  3cf3					      ENDIF
    168  3cf3
      0  3cf3					      START_LEVEL	bDarcy_Burnsell101
      1  3cf3				   LEVEL_START SET	*
      2  3cf3		       00 07	   BANK_LEVEL_bDarcy_Burnsell101 =	_CURRENT_BANK
      3  3cf3				   LEVEL_bDarcy_Burnsell101 SUBROUTINE
      4  3cf3				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3cf3
    170  3cf3		       38 23 7c 23*	      .byte.b	"8#|#2-.-$@#|#.#$*2$#|#2-.-*-#|#2$-2$.#|#.#-#2-#|#.2-.-.#|8#",0
      0  3d2f					      END_LEVEL	bDarcy_Burnsell101
      1  3d2f		       00		      .byte.b	0
      2  3d2f		       00 3d	   LEVEL_SIZE_bDarcy_Burnsell101 =	* - LEVEL_START
      3  3d30				  -	      IF	LEVEL_SIZE_bDarcy_Burnsell101 > MAX_LEVEL_SIZE
      4  3d30				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bDarcy_Burnsell101
      5  3d30					      ENDIF
    172  3d30
      0  3d30					      START_LEVEL	bAislin101
      1  3d30				   LEVEL_START SET	*
      2  3d30		       00 07	   BANK_LEVEL_bAislin101 =	_CURRENT_BANK
      3  3d30				   LEVEL_bAislin101 SUBROUTINE
      4  3d30				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d30
    174  3d30		       38 23 7c 32*	      .byte.b	"8#|2#-*-*.#|#2.$-$*#|#-.#-*.#|2#-$-$2#|#-#$-$-#|#2.2-$@#|8#",0
      0  3d6c					      END_LEVEL	bAislin101
      1  3d6c		       00		      .byte.b	0
      2  3d6c		       00 3d	   LEVEL_SIZE_bAislin101 =	* - LEVEL_START
      3  3d6d				  -	      IF	LEVEL_SIZE_bAislin101 > MAX_LEVEL_SIZE
      4  3d6d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAislin101
      5  3d6d					      ENDIF
    176  3d6d
    177  3d6d							;  START_LEVEL b82X_Sharpen
    178  3d6d							;  .byte "-11#8-|-#5-#3-2#7-|-#-$-$-$-#2-5#3-|-3#2-5#5-#3-|-#4.#5-3#-#3-|-#.4#2-4#3-#3-|-#4.4-#2-$-2#3-|-#-3.#3-#-3$5#|3#.7#2-$@$3-#|#-$3-5#-$-2#3-#|#-#.#-$6-$3#$-#|#-#.8#2-#2-$-#|#-#3.7-2#-2$-#|#3-7#-$-#-#2-#|5#5-#7-2#|10-9#-",0
    179  3d6d							;  END_LEVEL b82X_Sharpen
    180  3d6d
      0  3d6d					      START_LEVEL	Thomas_Reinke16
      1  3d6d				   LEVEL_START SET	*
      2  3d6d		       00 07	   BANK_LEVEL_Thomas_Reinke16 =	_CURRENT_BANK
      3  3d6d				   LEVEL_Thomas_Reinke16 SUBROUTINE
      4  3d6d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  3d6d
    182  3d6d		       2d 35 23 7c*	      .byte.b	"-5#|2#3-3#|#6-2#|#-#-2#2-#|#2.*2-#-#|#2-*2-#-#|3#*2$2-#|2-#@-4#|2-4#",0
      0  3db2					      END_LEVEL	Thomas_Reinke16
      1  3db2		       00		      .byte.b	0
      2  3db2		       00 46	   LEVEL_SIZE_Thomas_Reinke16 =	* - LEVEL_START
      3  3db3				  -	      IF	LEVEL_SIZE_Thomas_Reinke16 > MAX_LEVEL_SIZE
      4  3db3				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_Thomas_Reinke16
      5  3db3					      ENDIF
    184  3db3
    185  3db3							;Level element	Character	ASCII Code
    186  3db3							;Wall	#	0x23
    187  3db3							;Player	@	0x40
    188  3db3							;Player on goal square	+	0x2b
    189  3db3							;Box	$	0x24
    190  3db3							;Box on goal square	*	0x2a
    191  3db3							;Goal square	.	0x2e
    192  3db3							;Floor	(Space)	0x20 or underscore
    193  3db3
    194  3db3							;This level ("Claire", by Lee J Haywood):
    195  3db3
    196  3db3							;#######
    197  3db3							;#.@ # #
    198  3db3							;#$* $ #
    199  3db3							;#   $ #
    200  3db3							;# ..	#
    201  3db3							;#  *	#
    202  3db3							;#######
    203  3db3							;runlength encoded looks like this:
    204  3db3
    205  3db3							;The rows of the level are separated by "|"s. There has been a discussion in the Yahoo Group about what character should represent an empty square in May 2006. Finally the hyphen has been elected to be the standard character for an empty square. Nevertheless, programs are encouraged to support both, hyphens and underscores.
    206  3db3
    207  3db3							;If only two level elements are grouped together they may be run length encoded, but needn't to. Example:
    208  3db3
    209  3db3
      0  3db3					      CHECK_BANK_SIZE	"LEVELS4 -- full 2K"
      1  3db3		       05 b3	   .TEMP      =	* - BANK_START
 LEVELS4 -- full 2K (2K) SIZE =  $5b3 , FREE= $24d
      2  3db3					      ECHO	"LEVELS4 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  3db3				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  3db3				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  3db3				  -	      ERR
      6  3db3					      endif
------- FILE ./sokoboo.asm
------- FILE test.asm LEVEL 2 PASS 4
      0  3db3					      include	"test.asm"
      0  3db3					      NEWBANK	TITLESCREEN
      1  442c ????				      SEG	TITLESCREEN
      2  4000					      ORG	ORIGIN
      3  4000					      RORG	$F000
      4  4000				   BANK_START SET	*
      5  4000				   TITLESCREEN SET	ORIGIN / 2048
      6  4000				   ORIGIN     SET	ORIGIN + 2048
      7  4000				   _CURRENT_BANK SET	TITLESCREEN
      0  4000					      DEFINE_SUBROUTINE	TitleScreen
      1  4000		       00 08	   BANK_TitleScreen =	_CURRENT_BANK
      2  4000					      SUBROUTINE
      3  4000				   TitleScreen
      3  4000
      4  4000							; Start of new frame
      5  4000
      6  4000							; Start of vertical blank processing
      7  4000
      8  4000				   TitleSequence
      9  4000
     10  4000		       a9 00		      lda	#%00000000
     11  4002		       85 4a		      sta	CTRLPF	; copy playfield
     12  4004		       a9 00		      lda	#$0
     13  4006		       85 49		      sta	COLUBK	; set the background color (sky)
     14  4008		       a9 00		      lda	#0
     15  400a		       85 41		      sta	VBLANK
     16  400c		       a9 02		      lda	#2
     17  400e		       85 40		      sta	VSYNC
     18  4010		       85 42		      sta	WSYNC
     19  4012		       85 42		      sta	WSYNC
     20  4014		       85 42		      sta	WSYNC	; 3 scanlines of VSYNC signal
     21  4016
     22  4016		       a9 00		      lda	#0
     23  4018		       85 40		      sta	VSYNC
     24  401a
     25  401a							;------------------------------------------------------------------
     26  401a
     27  401a							; 37 scanlines of vertical blank...
     28  401a
     29  401a
     30  401a
     31  401a		       a2 00		      ldx	#0
     32  401c		       85 42	   VerticalBlank sta	WSYNC
     33  401e		       e8		      inx
     34  401f		       e0 25		      cpx	#37
     35  4021		       d0 f9		      bne	VerticalBlank
     36  4023
     37  4023
     38  4023							;------------------------------------------------------------------
     39  4023
     40  4023							; Do 192 scanlines of color-changing (our picture)
     41  4023
     42  4023
     43  4023		       a0 14		      ldy	#20
     44  4025		       85 42	   bot	      sta	WSYNC
     45  4027		       88		      dey
     46  4028		       10 fb		      bpl	bot
     47  402a
     48  402a
     49  402a		       a0 77		      ldy	#119	; this counts our scanline number
     50  402c				   SokoLogo
     51  402c		       85 42		      sta	WSYNC
     52  402e							;sty COLUBK
     53  402e		       b9 e4 f0 	      lda	colr,y	;#$ca	   ; 2
     54  4031		       85 48		      sta	COLUPF	; 3 @ 5
     55  4033
     56  4033		       b9 5c f1 	      lda	COL_0,y	; 5
     57  4036		       85 4d		      sta	PF0	; 3   @13
     58  4038		       b9 d4 f1 	      lda	COL_1,y	; 5
     59  403b		       85 4e		      sta	PF1	; 3   @21
     60  403d		       b9 4c f2 	      lda	COL_2,y	; 5
     61  4040		       85 4f		      sta	PF2	; 3   @29
     62  4042
     63  4042							; @29
     64  4042
     65  4042		       b9 c4 f2 	      lda	COL_3,y	; 5
     66  4045		       85 4d		      sta	PF0	; 3 @ 37
      0  4047					      SLEEP	2	; @39
      1  4047				   .CYCLES    SET	2
      2  4047
      3  4047				  -	      IF	.CYCLES < 2
      4  4047				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4047				  -	      ERR
      6  4047					      ENDIF
      7  4047
      8  4047				  -	      IF	.CYCLES & 1
      9  4047				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4047				  -	      nop	0
     11  4047				  -	      ELSE
     12  4047				  -	      bit	VSYNC
     13  4047				  -	      ENDIF
     14  4047				  -.CYCLES    SET	.CYCLES - 3
     15  4047					      ENDIF
     16  4047
     17  4047					      REPEAT	.CYCLES / 2
     18  4047		       ea		      nop
     19  4048					      REPEND
     68  4048		       b9 3c f3 	      lda	COL_4,y	; 5
     69  404b		       85 4e		      sta	PF1	; 3 @47
      0  404d					      SLEEP	3
      1  404d				   .CYCLES    SET	3
      2  404d
      3  404d				  -	      IF	.CYCLES < 2
      4  404d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  404d				  -	      ERR
      6  404d					      ENDIF
      7  404d
      8  404d					      IF	.CYCLES & 1
      9  404d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  404d		       04 00		      nop	0
     11  404f				  -	      ELSE
     12  404f				  -	      bit	VSYNC
     13  404f					      ENDIF
     14  404f				   .CYCLES    SET	.CYCLES - 3
     15  404f					      ENDIF
     16  404f
     17  404f				  -	      REPEAT	.CYCLES / 2
     18  404f				  -	      nop
     19  404f					      REPEND
     71  404f		       b9 b4 f3 	      lda	COL_5,y
     72  4052		       85 4f		      sta	PF2
     73  4054
     74  4054		       88		      dey
     75  4055							;2
     76  4055		       85 42		      sta	WSYNC
     77  4057		       b9 e4 f0 	      lda	colr,y	;#$74
     78  405a		       85 48		      sta	COLUPF	; set playfield color (cloud)
     79  405c
     80  405c		       b9 5c f1 	      lda	COL_0,y	; 5
     81  405f		       85 4d		      sta	PF0	; 3   @13
     82  4061		       b9 d4 f1 	      lda	COL_1,y	; 5
     83  4064		       85 4e		      sta	PF1	; 3   @21
     84  4066		       b9 4c f2 	      lda	COL_2,y	; 5
     85  4069		       85 4f		      sta	PF2	; 3   @29
     86  406b
     87  406b							; @29
     88  406b
     89  406b		       b9 c4 f2 	      lda	COL_3,y	; 5
     90  406e		       85 4d		      sta	PF0	; 3 @ 37
      0  4070					      SLEEP	2	; @39
      1  4070				   .CYCLES    SET	2
      2  4070
      3  4070				  -	      IF	.CYCLES < 2
      4  4070				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4070				  -	      ERR
      6  4070					      ENDIF
      7  4070
      8  4070				  -	      IF	.CYCLES & 1
      9  4070				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4070				  -	      nop	0
     11  4070				  -	      ELSE
     12  4070				  -	      bit	VSYNC
     13  4070				  -	      ENDIF
     14  4070				  -.CYCLES    SET	.CYCLES - 3
     15  4070					      ENDIF
     16  4070
     17  4070					      REPEAT	.CYCLES / 2
     18  4070		       ea		      nop
     19  4071					      REPEND
     92  4071		       b9 3c f3 	      lda	COL_4,y	; 5
     93  4074		       85 4e		      sta	PF1	; 3 @47
      0  4076					      SLEEP	3
      1  4076				   .CYCLES    SET	3
      2  4076
      3  4076				  -	      IF	.CYCLES < 2
      4  4076				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4076				  -	      ERR
      6  4076					      ENDIF
      7  4076
      8  4076					      IF	.CYCLES & 1
      9  4076					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4076		       04 00		      nop	0
     11  4078				  -	      ELSE
     12  4078				  -	      bit	VSYNC
     13  4078					      ENDIF
     14  4078				   .CYCLES    SET	.CYCLES - 3
     15  4078					      ENDIF
     16  4078
     17  4078				  -	      REPEAT	.CYCLES / 2
     18  4078				  -	      nop
     19  4078					      REPEND
     95  4078		       b9 b4 f3 	      lda	COL_5,y
     96  407b		       85 4f		      sta	PF2
     97  407d
     98  407d		       88		      dey
     99  407e							;3
    100  407e		       85 42		      sta	WSYNC
    101  4080		       b9 e4 f0 	      lda	colr,y	;#$2a
    102  4083		       85 48		      sta	COLUPF	; set playfield color (cloud)
    103  4085
    104  4085		       b9 5c f1 	      lda	COL_0,y	; 5
    105  4088		       85 4d		      sta	PF0	; 3   @13
    106  408a		       b9 d4 f1 	      lda	COL_1,y	; 5
    107  408d		       85 4e		      sta	PF1	; 3   @21
    108  408f		       b9 4c f2 	      lda	COL_2,y	; 5
    109  4092		       85 4f		      sta	PF2	; 3   @29
    110  4094
    111  4094							; @29
    112  4094
    113  4094		       b9 c4 f2 	      lda	COL_3,y	; 5
    114  4097		       85 4d		      sta	PF0	; 3 @ 37
      0  4099					      SLEEP	2	; @39
      1  4099				   .CYCLES    SET	2
      2  4099
      3  4099				  -	      IF	.CYCLES < 2
      4  4099				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4099				  -	      ERR
      6  4099					      ENDIF
      7  4099
      8  4099				  -	      IF	.CYCLES & 1
      9  4099				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4099				  -	      nop	0
     11  4099				  -	      ELSE
     12  4099				  -	      bit	VSYNC
     13  4099				  -	      ENDIF
     14  4099				  -.CYCLES    SET	.CYCLES - 3
     15  4099					      ENDIF
     16  4099
     17  4099					      REPEAT	.CYCLES / 2
     18  4099		       ea		      nop
     19  409a					      REPEND
    116  409a		       b9 3c f3 	      lda	COL_4,y	; 5
    117  409d		       85 4e		      sta	PF1	; 3 @47
      0  409f					      SLEEP	3
      1  409f				   .CYCLES    SET	3
      2  409f
      3  409f				  -	      IF	.CYCLES < 2
      4  409f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  409f				  -	      ERR
      6  409f					      ENDIF
      7  409f
      8  409f					      IF	.CYCLES & 1
      9  409f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  409f		       04 00		      nop	0
     11  40a1				  -	      ELSE
     12  40a1				  -	      bit	VSYNC
     13  40a1					      ENDIF
     14  40a1				   .CYCLES    SET	.CYCLES - 3
     15  40a1					      ENDIF
     16  40a1
     17  40a1				  -	      REPEAT	.CYCLES / 2
     18  40a1				  -	      nop
     19  40a1					      REPEND
    119  40a1		       b9 b4 f3 	      lda	COL_5,y
    120  40a4		       85 4f		      sta	PF2
    121  40a6
    122  40a6		       88		      dey
    123  40a7		       c0 ff		      cpy	#$FF
    124  40a9		       f0 03		      beq	noGo
    125  40ab		       4c 2c f0 	      jmp	SokoLogo
    126  40ae				   noGo
    127  40ae
      0  40ae					      SLEEP	20
      1  40ae				   .CYCLES    SET	20
      2  40ae
      3  40ae				  -	      IF	.CYCLES < 2
      4  40ae				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  40ae				  -	      ERR
      6  40ae					      ENDIF
      7  40ae
      8  40ae				  -	      IF	.CYCLES & 1
      9  40ae				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  40ae				  -	      nop	0
     11  40ae				  -	      ELSE
     12  40ae				  -	      bit	VSYNC
     13  40ae				  -	      ENDIF
     14  40ae				  -.CYCLES    SET	.CYCLES - 3
     15  40ae					      ENDIF
     16  40ae
     17  40ae					      REPEAT	.CYCLES / 2
     18  40ae		       ea		      nop
     17  40ae					      REPEND
     18  40af		       ea		      nop
     17  40af					      REPEND
     18  40b0		       ea		      nop
     17  40b0					      REPEND
     18  40b1		       ea		      nop
     17  40b1					      REPEND
     18  40b2		       ea		      nop
     17  40b2					      REPEND
     18  40b3		       ea		      nop
     17  40b3					      REPEND
     18  40b4		       ea		      nop
     17  40b4					      REPEND
     18  40b5		       ea		      nop
     17  40b5					      REPEND
     18  40b6		       ea		      nop
     17  40b6					      REPEND
     18  40b7		       ea		      nop
     19  40b8					      REPEND
    129  40b8		       a9 00		      lda	#0
    130  40ba		       85 4d		      sta	PF0
    131  40bc		       85 4e		      sta	PF1
    132  40be		       85 4f		      sta	PF2
    133  40c0
    134  40c0		       a0 3f		      ldy	#63
    135  40c2		       85 42	   bot2       sta	WSYNC
    136  40c4		       88		      dey
    137  40c5		       10 fb		      bpl	bot2
    138  40c7
    139  40c7							;--------------------------------------------------------------------------
    140  40c7
    141  40c7		       a9 00		      lda	#0
    142  40c9		       85 4d		      sta	PF0
    143  40cb		       85 4e		      sta	PF1
    144  40cd		       85 4f		      sta	PF2
    145  40cf
    146  40cf
    147  40cf		       a9 42		      lda	#%01000010
    148  40d1
    149  40d1		       85 41		      sta	VBLANK	; end of screen - enter blanking
    150  40d3
    151  40d3
    152  40d3
    153  40d3							; 30 scanlines of overscan...
    154  40d3
    155  40d3
    156  40d3
    157  40d3		       a2 00		      ldx	#0
    158  40d5
    159  40d5				   Overscan
    160  40d5
    161  40d5		       85 42		      sta	WSYNC
    162  40d7
    163  40d7		       e8		      inx
    164  40d8
    165  40d8		       e0 1e		      cpx	#30
    166  40da
    167  40da		       d0 f9		      bne	Overscan
    168  40dc
    169  40dc		       a5 4c		      lda	INPT4
    170  40de		       10 03		      bpl	ret
    171  40e0
    172  40e0		       4c 00 f0 	      jmp	TitleSequence
    173  40e3
    174  40e3		       60	   ret	      rts
    175  40e4
    176  40e4
    177  40e4							;
    178  40e4
    179  40e4				   colr
    180  40e4		       c6 74 26 	      .byte.b	$C6,$74,$26
    181  40e7		       c6 74 26 	      .byte.b	$C6,$74,$26
    182  40ea		       c6 74 26 	      .byte.b	$C6,$74,$26
    183  40ed		       c6 74 26 	      .byte.b	$C6,$74,$26
    184  40f0		       c6 74 26 	      .byte.b	$C6,$74,$26
    185  40f3		       c6 74 26 	      .byte.b	$C6,$74,$26
    186  40f6		       c6 74 26 	      .byte.b	$C6,$74,$26
    187  40f9		       c6 74 26 	      .byte.b	$C6,$74,$26
    188  40fc		       c6 74 26 	      .byte.b	$C6,$74,$26
    189  40ff		       c6 74 26 	      .byte.b	$C6,$74,$26
    190  4102
    191  4102		       ca 74 2a 	      .byte.b	$CA,$74,$2A
    192  4105		       ca 74 2a 	      .byte.b	$CA,$74,$2A
    193  4108		       ca 74 2a 	      .byte.b	$CA,$74,$2A
    194  410b		       ca 74 2a 	      .byte.b	$CA,$74,$2A
    195  410e		       ca 74 2a 	      .byte.b	$CA,$74,$2A
    196  4111		       ca 74 2a 	      .byte.b	$CA,$74,$2A
    197  4114		       ca 74 2a 	      .byte.b	$CA,$74,$2A
    198  4117		       ca 74 2a 	      .byte.b	$CA,$74,$2A
    199  411a		       ca 74 2a 	      .byte.b	$CA,$74,$2A
    200  411d		       ca 74 2a 	      .byte.b	$CA,$74,$2A
    201  4120
    202  4120		       1a 24 2a 	      .byte.b	$1A,$24,$2A
    203  4123		       1a 24 2a 	      .byte.b	$1A,$24,$2A
    204  4126		       1a 24 2a 	      .byte.b	$1A,$24,$2A
    205  4129		       1a 24 2a 	      .byte.b	$1A,$24,$2A
    206  412c		       1a 24 2a 	      .byte.b	$1A,$24,$2A
    207  412f		       1a 24 68 	      .byte.b	$1A,$24,$68
    208  4132		       1a 24 68 	      .byte.b	$1A,$24,$68
    209  4135		       1a 24 68 	      .byte.b	$1A,$24,$68
    210  4138		       1a 24 68 	      .byte.b	$1A,$24,$68
    211  413b		       1a 24 68 	      .byte.b	$1A,$24,$68
    212  413e
    213  413e		       28 74 68 	      .byte.b	$28,$74,$68
    214  4141		       28 74 68 	      .byte.b	$28,$74,$68
    215  4144		       28 74 68 	      .byte.b	$28,$74,$68
    216  4147		       28 74 68 	      .byte.b	$28,$74,$68
    217  414a		       28 74 68 	      .byte.b	$28,$74,$68
    218  414d		       28 74 4a 	      .byte.b	$28,$74,$4A
    219  4150		       28 74 4a 	      .byte.b	$28,$74,$4A
    220  4153		       28 74 4a 	      .byte.b	$28,$74,$4A
    221  4156		       28 74 4a 	      .byte.b	$28,$74,$4A
    222  4159		       28 74 4a 	      .byte.b	$28,$74,$4A
    223  415c
    224  415c				   COL_0
    225  415c
    226  415c
    227  415c
    228  415c
    229  415c
    230  415c		       80		      .byte.b	128	;R
    231  415d		       f0		      .byte.b	240	;G
    232  415e		       80		      .byte.b	128	;B
    233  415f		       80		      .byte.b	128	;R
    234  4160		       f0		      .byte.b	240	;G
    235  4161		       80		      .byte.b	128	;B
    236  4162		       80		      .byte.b	128	;R
    237  4163		       f0		      .byte.b	240	;G
    238  4164		       80		      .byte.b	128	;B
    239  4165		       00		      .byte.b	0	;R
    240  4166		       00		      .byte.b	0	;G
    241  4167		       00		      .byte.b	0	;B
    242  4168		       30		      .byte.b	48	;R
    243  4169		       70		      .byte.b	112	;G
    244  416a		       30		      .byte.b	48	;B
    245  416b		       10		      .byte.b	16	;R
    246  416c		       50		      .byte.b	80	;G
    247  416d		       30		      .byte.b	48	;B
    248  416e		       60		      .byte.b	96	;R
    249  416f		       e0		      .byte.b	224	;G
    250  4170		       70		      .byte.b	112	;B
    251  4171		       30		      .byte.b	48	;R
    252  4172		       b0		      .byte.b	176	;G
    253  4173		       70		      .byte.b	112	;B
    254  4174		       50		      .byte.b	80	;R
    255  4175		       d0		      .byte.b	208	;G
    256  4176		       70		      .byte.b	112	;B
    257  4177		       80		      .byte.b	128	;R
    258  4178		       80		      .byte.b	128	;G
    259  4179		       c0		      .byte.b	192	;B
    260  417a		       c0		      .byte.b	192	;R
    261  417b		       c0		      .byte.b	192	;G
    262  417c		       c0		      .byte.b	192	;B
    263  417d		       40		      .byte.b	64	;R
    264  417e		       40		      .byte.b	64	;G
    265  417f		       c0		      .byte.b	192	;B
    266  4180		       80		      .byte.b	128	;R
    267  4181		       80		      .byte.b	128	;G
    268  4182		       c0		      .byte.b	192	;B
    269  4183		       80		      .byte.b	128	;R
    270  4184		       80		      .byte.b	128	;G
    271  4185		       c0		      .byte.b	192	;B
    272  4186		       c0		      .byte.b	192	;R
    273  4187		       c0		      .byte.b	192	;G
    274  4188		       c0		      .byte.b	192	;B
    275  4189		       40		      .byte.b	64	;R
    276  418a		       40		      .byte.b	64	;G
    277  418b		       c0		      .byte.b	192	;B
    278  418c		       80		      .byte.b	128	;R
    279  418d		       80		      .byte.b	128	;G
    280  418e		       c0		      .byte.b	192	;B
    281  418f		       80		      .byte.b	128	;R
    282  4190		       80		      .byte.b	128	;G
    283  4191		       c0		      .byte.b	192	;B
    284  4192		       c0		      .byte.b	192	;R
    285  4193		       c0		      .byte.b	192	;G
    286  4194		       c0		      .byte.b	192	;B
    287  4195		       40		      .byte.b	64	;R
    288  4196		       40		      .byte.b	64	;G
    289  4197		       e0		      .byte.b	224	;B
    290  4198		       a0		      .byte.b	160	;R
    291  4199		       a0		      .byte.b	160	;G
    292  419a		       e0		      .byte.b	224	;B
    293  419b		       60		      .byte.b	96	;R
    294  419c		       e0		      .byte.b	224	;G
    295  419d		       70		      .byte.b	112	;B
    296  419e		       10		      .byte.b	16	;R
    297  419f		       30		      .byte.b	48	;G
    298  41a0		       10		      .byte.b	16	;B
    299  41a1		       10		      .byte.b	16	;R
    300  41a2		       30		      .byte.b	48	;G
    301  41a3		       10		      .byte.b	16	;B
    302  41a4		       10		      .byte.b	16	;R
    303  41a5		       30		      .byte.b	48	;G
    304  41a6		       10		      .byte.b	16	;B
    305  41a7		       00		      .byte.b	0	;R
    306  41a8		       20		      .byte.b	32	;G
    307  41a9		       10		      .byte.b	16	;B
    308  41aa		       10		      .byte.b	16	;R
    309  41ab		       30		      .byte.b	48	;G
    310  41ac		       10		      .byte.b	16	;B
    311  41ad		       20		      .byte.b	32	;R
    312  41ae		       60		      .byte.b	96	;G
    313  41af		       30		      .byte.b	48	;B
    314  41b0		       30		      .byte.b	48	;R
    315  41b1		       70		      .byte.b	112	;G
    316  41b2		       30		      .byte.b	48	;B
    317  41b3		       10		      .byte.b	16	;R
    318  41b4		       50		      .byte.b	80	;G
    319  41b5		       30		      .byte.b	48	;B
    320  41b6		       20		      .byte.b	32	;R
    321  41b7		       e0		      .byte.b	224	;G
    322  41b8		       30		      .byte.b	48	;B
    323  41b9		       a0		      .byte.b	160	;R
    324  41ba		       a0		      .byte.b	160	;G
    325  41bb		       e0		      .byte.b	224	;B
    326  41bc		       40		      .byte.b	64	;R
    327  41bd		       40		      .byte.b	64	;G
    328  41be		       e0		      .byte.b	224	;B
    329  41bf		       40		      .byte.b	64	;R
    330  41c0		       40		      .byte.b	64	;G
    331  41c1		       c0		      .byte.b	192	;B
    332  41c2		       00		      .byte.b	0	;R
    333  41c3		       00		      .byte.b	0	;G
    334  41c4		       00		      .byte.b	0	;B
    335  41c5		       00		      .byte.b	0	;R
    336  41c6		       00		      .byte.b	0	;G
    337  41c7		       00		      .byte.b	0	;B
    338  41c8		       00		      .byte.b	0	;R
    339  41c9		       00		      .byte.b	0	;G
    340  41ca		       00		      .byte.b	0	;B
    341  41cb		       00		      .byte.b	0	;R
    342  41cc		       c0		      .byte.b	192	;G
    343  41cd		       00		      .byte.b	0	;B
    344  41ce		       00		      .byte.b	0	;R
    345  41cf		       c0		      .byte.b	192	;G
    346  41d0		       00		      .byte.b	0	;B
    347  41d1		       00		      .byte.b	0	;R
    348  41d2		       c0		      .byte.b	192	;G
    349  41d3		       00		      .byte.b	0	;B
    350  41d4				   COL_1
    351  41d4		       f8		      .byte.b	248	;R
    352  41d5		       c0		      .byte.b	192	;G
    353  41d6		       c7		      .byte.b	199	;B
    354  41d7		       f8		      .byte.b	248	;R
    355  41d8		       c0		      .byte.b	192	;G
    356  41d9		       c7		      .byte.b	199	;B
    357  41da		       f8		      .byte.b	248	;R
    358  41db		       c0		      .byte.b	192	;G
    359  41dc		       c7		      .byte.b	199	;B
    360  41dd		       00		      .byte.b	0	;R
    361  41de		       00		      .byte.b	0	;G
    362  41df		       00		      .byte.b	0	;B
    363  41e0		       30		      .byte.b	48	;R
    364  41e1		       09		      .byte.b	9	;G
    365  41e2		       01		      .byte.b	1	;B
    366  41e3		       30		      .byte.b	48	;R
    367  41e4		       09		      .byte.b	9	;G
    368  41e5		       01		      .byte.b	1	;B
    369  41e6		       70		      .byte.b	112	;R
    370  41e7		       09		      .byte.b	9	;G
    371  41e8		       01		      .byte.b	1	;B
    372  41e9		       78		      .byte.b	120	;R
    373  41ea		       05		      .byte.b	5	;G
    374  41eb		       01		      .byte.b	1	;B
    375  41ec		       78		      .byte.b	120	;R
    376  41ed		       05		      .byte.b	5	;G
    377  41ee		       01		      .byte.b	1	;B
    378  41ef		       78		      .byte.b	120	;R
    379  41f0		       85		      .byte.b	133	;G
    380  41f1		       01		      .byte.b	1	;B
    381  41f2		       4c		      .byte.b	76	;R
    382  41f3		       a3		      .byte.b	163	;G
    383  41f4		       01		      .byte.b	1	;B
    384  41f5		       4c		      .byte.b	76	;R
    385  41f6		       a3		      .byte.b	163	;G
    386  41f7		       01		      .byte.b	1	;B
    387  41f8		       4c		      .byte.b	76	;R
    388  41f9		       a3		      .byte.b	163	;G
    389  41fa		       01		      .byte.b	1	;B
    390  41fb		       44		      .byte.b	68	;R
    391  41fc		       a3		      .byte.b	163	;G
    392  41fd		       01		      .byte.b	1	;B
    393  41fe		       44		      .byte.b	68	;R
    394  41ff		       a3		      .byte.b	163	;G
    395  4200		       01		      .byte.b	1	;B
    396  4201		       44		      .byte.b	68	;R
    397  4202		       a3		      .byte.b	163	;G
    398  4203		       01		      .byte.b	1	;B
    399  4204		       44		      .byte.b	68	;R
    400  4205		       a3		      .byte.b	163	;G
    401  4206		       01		      .byte.b	1	;B
    402  4207		       44		      .byte.b	68	;R
    403  4208		       a3		      .byte.b	163	;G
    404  4209		       01		      .byte.b	1	;B
    405  420a		       44		      .byte.b	68	;R
    406  420b		       a3		      .byte.b	163	;G
    407  420c		       01		      .byte.b	1	;B
    408  420d		       44		      .byte.b	68	;R
    409  420e		       a3		      .byte.b	163	;G
    410  420f		       01		      .byte.b	1	;B
    411  4210		       44		      .byte.b	68	;R
    412  4211		       a3		      .byte.b	163	;G
    413  4212		       01		      .byte.b	1	;B
    414  4213		       44		      .byte.b	68	;R
    415  4214		       23		      .byte.b	35	;G
    416  4215		       01		      .byte.b	1	;B
    417  4216		       44		      .byte.b	68	;R
    418  4217		       23		      .byte.b	35	;G
    419  4218		       01		      .byte.b	1	;B
    420  4219		       44		      .byte.b	68	;R
    421  421a		       23		      .byte.b	35	;G
    422  421b		       01		      .byte.b	1	;B
    423  421c		       44		      .byte.b	68	;R
    424  421d		       23		      .byte.b	35	;G
    425  421e		       01		      .byte.b	1	;B
    426  421f		       44		      .byte.b	68	;R
    427  4220		       23		      .byte.b	35	;G
    428  4221		       01		      .byte.b	1	;B
    429  4222		       44		      .byte.b	68	;R
    430  4223		       23		      .byte.b	35	;G
    431  4224		       01		      .byte.b	1	;B
    432  4225		       64		      .byte.b	100	;R
    433  4226		       13		      .byte.b	19	;G
    434  4227		       01		      .byte.b	1	;B
    435  4228		       24		      .byte.b	36	;R
    436  4229		       13		      .byte.b	19	;G
    437  422a		       01		      .byte.b	1	;B
    438  422b		       24		      .byte.b	36	;R
    439  422c		       13		      .byte.b	19	;G
    440  422d		       01		      .byte.b	1	;B
    441  422e		       3c		      .byte.b	60	;R
    442  422f		       03		      .byte.b	3	;G
    443  4230		       01		      .byte.b	1	;B
    444  4231		       1c		      .byte.b	28	;R
    445  4232		       c3		      .byte.b	195	;G
    446  4233		       01		      .byte.b	1	;B
    447  4234		       dc		      .byte.b	220	;R
    448  4235		       e3		      .byte.b	227	;G
    449  4236		       c1		      .byte.b	193	;B
    450  4237		       9c		      .byte.b	156	;R
    451  4238		       a3		      .byte.b	163	;G
    452  4239		       c1		      .byte.b	193	;B
    453  423a		       cc		      .byte.b	204	;R
    454  423b		       e3		      .byte.b	227	;G
    455  423c		       c1		      .byte.b	193	;B
    456  423d		       88		      .byte.b	136	;R
    457  423e		       a5		      .byte.b	165	;G
    458  423f		       c1		      .byte.b	193	;B
    459  4240		       00		      .byte.b	0	;R
    460  4241		       00		      .byte.b	0	;G
    461  4242		       00		      .byte.b	0	;B
    462  4243		       7e		      .byte.b	126	;R
    463  4244		       f0		      .byte.b	240	;G
    464  4245		       71		      .byte.b	113	;B
    465  4246		       7e		      .byte.b	126	;R
    466  4247		       f0		      .byte.b	240	;G
    467  4248		       71		      .byte.b	113	;B
    468  4249		       7e		      .byte.b	126	;R
    469  424a		       f0		      .byte.b	240	;G
    470  424b		       71		      .byte.b	113	;B
    471  424c				   COL_2
    472  424c		       3f		      .byte.b	63	;R
    473  424d		       c7		      .byte.b	199	;G
    474  424e		       f8		      .byte.b	248	;B
    475  424f		       3f		      .byte.b	63	;R
    476  4250		       c7		      .byte.b	199	;G
    477  4251		       f8		      .byte.b	248	;B
    478  4252		       3f		      .byte.b	63	;R
    479  4253		       c7		      .byte.b	199	;G
    480  4254		       f8		      .byte.b	248	;B
    481  4255		       00		      .byte.b	0	;R
    482  4256		       00		      .byte.b	0	;G
    483  4257		       00		      .byte.b	0	;B
    484  4258		       60		      .byte.b	96	;R
    485  4259		       ed		      .byte.b	237	;G
    486  425a		       0c		      .byte.b	12	;B
    487  425b		       60		      .byte.b	96	;R
    488  425c		       ed		      .byte.b	237	;G
    489  425d		       0c		      .byte.b	12	;B
    490  425e		       70		      .byte.b	112	;R
    491  425f		       fd		      .byte.b	253	;G
    492  4260		       04		      .byte.b	4	;B
    493  4261		       f0		      .byte.b	240	;R
    494  4262		       ff		      .byte.b	255	;G
    495  4263		       06		      .byte.b	6	;B
    496  4264		       f0		      .byte.b	240	;R
    497  4265		       ff		      .byte.b	255	;G
    498  4266		       06		      .byte.b	6	;B
    499  4267		       f0		      .byte.b	240	;R
    500  4268		       ff		      .byte.b	255	;G
    501  4269		       06		      .byte.b	6	;B
    502  426a		       90		      .byte.b	144	;R
    503  426b		       bf		      .byte.b	191	;G
    504  426c		       07		      .byte.b	7	;B
    505  426d		       90		      .byte.b	144	;R
    506  426e		       bf		      .byte.b	191	;G
    507  426f		       07		      .byte.b	7	;B
    508  4270		       90		      .byte.b	144	;R
    509  4271		       bf		      .byte.b	191	;G
    510  4272		       07		      .byte.b	7	;B
    511  4273		       10		      .byte.b	16	;R
    512  4274		       37		      .byte.b	55	;G
    513  4275		       03		      .byte.b	3	;B
    514  4276		       10		      .byte.b	16	;R
    515  4277		       37		      .byte.b	55	;G
    516  4278		       03		      .byte.b	3	;B
    517  4279		       10		      .byte.b	16	;R
    518  427a		       37		      .byte.b	55	;G
    519  427b		       03		      .byte.b	3	;B
    520  427c		       10		      .byte.b	16	;R
    521  427d		       33		      .byte.b	51	;G
    522  427e		       01		      .byte.b	1	;B
    523  427f		       10		      .byte.b	16	;R
    524  4280		       33		      .byte.b	51	;G
    525  4281		       01		      .byte.b	1	;B
    526  4282		       10		      .byte.b	16	;R
    527  4283		       37		      .byte.b	55	;G
    528  4284		       03		      .byte.b	3	;B
    529  4285		       10		      .byte.b	16	;R
    530  4286		       37		      .byte.b	55	;G
    531  4287		       03		      .byte.b	3	;B
    532  4288		       10		      .byte.b	16	;R
    533  4289		       37		      .byte.b	55	;G
    534  428a		       03		      .byte.b	3	;B
    535  428b		       10		      .byte.b	16	;R
    536  428c		       3f		      .byte.b	63	;G
    537  428d		       03		      .byte.b	3	;B
    538  428e		       10		      .byte.b	16	;R
    539  428f		       3f		      .byte.b	63	;G
    540  4290		       07		      .byte.b	7	;B
    541  4291		       10		      .byte.b	16	;R
    542  4292		       3f		      .byte.b	63	;G
    543  4293		       07		      .byte.b	7	;B
    544  4294		       10		      .byte.b	16	;R
    545  4295		       3f		      .byte.b	63	;G
    546  4296		       06		      .byte.b	6	;B
    547  4297		       10		      .byte.b	16	;R
    548  4298		       3f		      .byte.b	63	;G
    549  4299		       06		      .byte.b	6	;B
    550  429a		       10		      .byte.b	16	;R
    551  429b		       3f		      .byte.b	63	;G
    552  429c		       06		      .byte.b	6	;B
    553  429d		       30		      .byte.b	48	;R
    554  429e		       7d		      .byte.b	125	;G
    555  429f		       04		      .byte.b	4	;B
    556  42a0		       20		      .byte.b	32	;R
    557  42a1		       6d		      .byte.b	109	;G
    558  42a2		       04		      .byte.b	4	;B
    559  42a3		       20		      .byte.b	32	;R
    560  42a4		       6d		      .byte.b	109	;G
    561  42a5		       04		      .byte.b	4	;B
    562  42a6		       e0		      .byte.b	224	;R
    563  42a7		       ed		      .byte.b	237	;G
    564  42a8		       04		      .byte.b	4	;B
    565  42a9		       c0		      .byte.b	192	;R
    566  42aa		       dd		      .byte.b	221	;G
    567  42ab		       0c		      .byte.b	12	;B
    568  42ac		       c0		      .byte.b	192	;R
    569  42ad		       dd		      .byte.b	221	;G
    570  42ae		       0c		      .byte.b	12	;B
    571  42af		       c0		      .byte.b	192	;R
    572  42b0		       dd		      .byte.b	221	;G
    573  42b1		       0c		      .byte.b	12	;B
    574  42b2		       80		      .byte.b	128	;R
    575  42b3		       9d		      .byte.b	157	;G
    576  42b4		       0c		      .byte.b	12	;B
    577  42b5		       80		      .byte.b	128	;R
    578  42b6		       9d		      .byte.b	157	;G
    579  42b7		       0c		      .byte.b	12	;B
    580  42b8		       00		      .byte.b	0	;R
    581  42b9		       00		      .byte.b	0	;G
    582  42ba		       00		      .byte.b	0	;B
    583  42bb		       fc		      .byte.b	252	;R
    584  42bc		       1c		      .byte.b	28	;G
    585  42bd		       e3		      .byte.b	227	;B
    586  42be		       fc		      .byte.b	252	;R
    587  42bf		       1c		      .byte.b	28	;G
    588  42c0		       e3		      .byte.b	227	;B
    589  42c1		       fc		      .byte.b	252	;R
    590  42c2		       1c		      .byte.b	28	;G
    591  42c3		       e3		      .byte.b	227	;B
    592  42c4				   COL_3
    593  42c4		       00		      .byte.b	0	;R
    594  42c5		       10		      .byte.b	16	;G
    595  42c6		       10		      .byte.b	16	;B
    596  42c7		       00		      .byte.b	0	;R
    597  42c8		       10		      .byte.b	16	;G
    598  42c9		       10		      .byte.b	16	;B
    599  42ca		       00		      .byte.b	0	;R
    600  42cb		       10		      .byte.b	16	;G
    601  42cc		       10		      .byte.b	16	;B
    602  42cd		       00		      .byte.b	0	;R
    603  42ce		       00		      .byte.b	0	;G
    604  42cf		       00		      .byte.b	0	;B
    605  42d0		       c0		      .byte.b	192	;R
    606  42d1		       c0		      .byte.b	192	;G
    607  42d2		       c0		      .byte.b	192	;B
    608  42d3		       c0		      .byte.b	192	;R
    609  42d4		       c0		      .byte.b	192	;G
    610  42d5		       c0		      .byte.b	192	;B
    611  42d6		       c0		      .byte.b	192	;R
    612  42d7		       c0		      .byte.b	192	;G
    613  42d8		       c0		      .byte.b	192	;B
    614  42d9		       c0		      .byte.b	192	;R
    615  42da		       d0		      .byte.b	208	;G
    616  42db		       c0		      .byte.b	192	;B
    617  42dc		       c0		      .byte.b	192	;R
    618  42dd		       d0		      .byte.b	208	;G
    619  42de		       c0		      .byte.b	192	;B
    620  42df		       c0		      .byte.b	192	;R
    621  42e0		       d0		      .byte.b	208	;G
    622  42e1		       c0		      .byte.b	192	;B
    623  42e2		       50		      .byte.b	80	;R
    624  42e3		       f0		      .byte.b	240	;G
    625  42e4		       40		      .byte.b	64	;B
    626  42e5		       50		      .byte.b	80	;R
    627  42e6		       f0		      .byte.b	240	;G
    628  42e7		       40		      .byte.b	64	;B
    629  42e8		       50		      .byte.b	80	;R
    630  42e9		       f0		      .byte.b	240	;G
    631  42ea		       40		      .byte.b	64	;B
    632  42eb		       50		      .byte.b	80	;R
    633  42ec		       f0		      .byte.b	240	;G
    634  42ed		       40		      .byte.b	64	;B
    635  42ee		       50		      .byte.b	80	;R
    636  42ef		       f0		      .byte.b	240	;G
    637  42f0		       40		      .byte.b	64	;B
    638  42f1		       50		      .byte.b	80	;R
    639  42f2		       f0		      .byte.b	240	;G
    640  42f3		       40		      .byte.b	64	;B
    641  42f4		       d0		      .byte.b	208	;R
    642  42f5		       f0		      .byte.b	240	;G
    643  42f6		       c0		      .byte.b	192	;B
    644  42f7		       d0		      .byte.b	208	;R
    645  42f8		       f0		      .byte.b	240	;G
    646  42f9		       c0		      .byte.b	192	;B
    647  42fa		       d0		      .byte.b	208	;R
    648  42fb		       f0		      .byte.b	240	;G
    649  42fc		       c0		      .byte.b	192	;B
    650  42fd		       d0		      .byte.b	208	;R
    651  42fe		       f0		      .byte.b	240	;G
    652  42ff		       c0		      .byte.b	192	;B
    653  4300		       d0		      .byte.b	208	;R
    654  4301		       f0		      .byte.b	240	;G
    655  4302		       c0		      .byte.b	192	;B
    656  4303		       d0		      .byte.b	208	;R
    657  4304		       f0		      .byte.b	240	;G
    658  4305		       c0		      .byte.b	192	;B
    659  4306		       50		      .byte.b	80	;R
    660  4307		       f0		      .byte.b	240	;G
    661  4308		       40		      .byte.b	64	;B
    662  4309		       50		      .byte.b	80	;R
    663  430a		       f0		      .byte.b	240	;G
    664  430b		       40		      .byte.b	64	;B
    665  430c		       50		      .byte.b	80	;R
    666  430d		       f0		      .byte.b	240	;G
    667  430e		       40		      .byte.b	64	;B
    668  430f		       50		      .byte.b	80	;R
    669  4310		       f0		      .byte.b	240	;G
    670  4311		       40		      .byte.b	64	;B
    671  4312		       50		      .byte.b	80	;R
    672  4313		       f0		      .byte.b	240	;G
    673  4314		       40		      .byte.b	64	;B
    674  4315		       50		      .byte.b	80	;R
    675  4316		       f0		      .byte.b	240	;G
    676  4317		       40		      .byte.b	64	;B
    677  4318		       50		      .byte.b	80	;R
    678  4319		       f0		      .byte.b	240	;G
    679  431a		       40		      .byte.b	64	;B
    680  431b		       50		      .byte.b	80	;R
    681  431c		       f0		      .byte.b	240	;G
    682  431d		       40		      .byte.b	64	;B
    683  431e		       d0		      .byte.b	208	;R
    684  431f		       f0		      .byte.b	240	;G
    685  4320		       c0		      .byte.b	192	;B
    686  4321		       d0		      .byte.b	208	;R
    687  4322		       f0		      .byte.b	240	;G
    688  4323		       c0		      .byte.b	192	;B
    689  4324		       d0		      .byte.b	208	;R
    690  4325		       f0		      .byte.b	240	;G
    691  4326		       c0		      .byte.b	192	;B
    692  4327		       d0		      .byte.b	208	;R
    693  4328		       f0		      .byte.b	240	;G
    694  4329		       c0		      .byte.b	192	;B
    695  432a		       d0		      .byte.b	208	;R
    696  432b		       f0		      .byte.b	240	;G
    697  432c		       c0		      .byte.b	192	;B
    698  432d		       c0		      .byte.b	192	;R
    699  432e		       d0		      .byte.b	208	;G
    700  432f		       c0		      .byte.b	192	;B
    701  4330		       00		      .byte.b	0	;R
    702  4331		       00		      .byte.b	0	;G
    703  4332		       00		      .byte.b	0	;B
    704  4333		       00		      .byte.b	0	;R
    705  4334		       70		      .byte.b	112	;G
    706  4335		       70		      .byte.b	112	;B
    707  4336		       00		      .byte.b	0	;R
    708  4337		       70		      .byte.b	112	;G
    709  4338		       70		      .byte.b	112	;B
    710  4339		       00		      .byte.b	0	;R
    711  433a		       70		      .byte.b	112	;G
    712  433b		       70		      .byte.b	112	;B
    713  433c				   COL_4
    714  433c		       1f		      .byte.b	31	;R
    715  433d		       fc		      .byte.b	252	;G
    716  433e		       1c		      .byte.b	28	;B
    717  433f		       1f		      .byte.b	31	;R
    718  4340		       fc		      .byte.b	252	;G
    719  4341		       1c		      .byte.b	28	;B
    720  4342		       1f		      .byte.b	31	;R
    721  4343		       fc		      .byte.b	252	;G
    722  4344		       1c		      .byte.b	28	;B
    723  4345		       00		      .byte.b	0	;R
    724  4346		       00		      .byte.b	0	;G
    725  4347		       00		      .byte.b	0	;B
    726  4348		       80		      .byte.b	128	;R
    727  4349		       c1		      .byte.b	193	;G
    728  434a		       86		      .byte.b	134	;B
    729  434b		       80		      .byte.b	128	;R
    730  434c		       c1		      .byte.b	193	;G
    731  434d		       86		      .byte.b	134	;B
    732  434e		       c0		      .byte.b	192	;R
    733  434f		       e1		      .byte.b	225	;G
    734  4350		       ce		      .byte.b	206	;B
    735  4351		       e0		      .byte.b	224	;R
    736  4352		       f0		      .byte.b	240	;G
    737  4353		       ef		      .byte.b	239	;B
    738  4354		       e0		      .byte.b	224	;R
    739  4355		       f0		      .byte.b	240	;G
    740  4356		       ef		      .byte.b	239	;B
    741  4357		       e0		      .byte.b	224	;R
    742  4358		       f0		      .byte.b	240	;G
    743  4359		       ef		      .byte.b	239	;B
    744  435a		       20		      .byte.b	32	;R
    745  435b		       74		      .byte.b	116	;G
    746  435c		       29		      .byte.b	41	;B
    747  435d		       20		      .byte.b	32	;R
    748  435e		       34		      .byte.b	52	;G
    749  435f		       29		      .byte.b	41	;B
    750  4360		       20		      .byte.b	32	;R
    751  4361		       34		      .byte.b	52	;G
    752  4362		       29		      .byte.b	41	;B
    753  4363		       60		      .byte.b	96	;R
    754  4364		       74		      .byte.b	116	;G
    755  4365		       68		      .byte.b	104	;B
    756  4366		       60		      .byte.b	96	;R
    757  4367		       74		      .byte.b	116	;G
    758  4368		       68		      .byte.b	104	;B
    759  4369		       60		      .byte.b	96	;R
    760  436a		       74		      .byte.b	116	;G
    761  436b		       68		      .byte.b	104	;B
    762  436c		       e0		      .byte.b	224	;R
    763  436d		       f4		      .byte.b	244	;G
    764  436e		       e8		      .byte.b	232	;B
    765  436f		       e0		      .byte.b	224	;R
    766  4370		       f4		      .byte.b	244	;G
    767  4371		       e8		      .byte.b	232	;B
    768  4372		       c0		      .byte.b	192	;R
    769  4373		       e4		      .byte.b	228	;G
    770  4374		       c8		      .byte.b	200	;B
    771  4375		       c0		      .byte.b	192	;R
    772  4376		       e4		      .byte.b	228	;G
    773  4377		       c8		      .byte.b	200	;B
    774  4378		       c0		      .byte.b	192	;R
    775  4379		       e4		      .byte.b	228	;G
    776  437a		       c8		      .byte.b	200	;B
    777  437b		       c0		      .byte.b	192	;R
    778  437c		       e4		      .byte.b	228	;G
    779  437d		       c8		      .byte.b	200	;B
    780  437e		       20		      .byte.b	32	;R
    781  437f		       34		      .byte.b	52	;G
    782  4380		       28		      .byte.b	40	;B
    783  4381		       20		      .byte.b	32	;R
    784  4382		       34		      .byte.b	52	;G
    785  4383		       28		      .byte.b	40	;B
    786  4384		       20		      .byte.b	32	;R
    787  4385		       34		      .byte.b	52	;G
    788  4386		       28		      .byte.b	40	;B
    789  4387		       20		      .byte.b	32	;R
    790  4388		       34		      .byte.b	52	;G
    791  4389		       28		      .byte.b	40	;B
    792  438a		       20		      .byte.b	32	;R
    793  438b		       34		      .byte.b	52	;G
    794  438c		       28		      .byte.b	40	;B
    795  438d		       60		      .byte.b	96	;R
    796  438e		       72		      .byte.b	114	;G
    797  438f		       6c		      .byte.b	108	;B
    798  4390		       60		      .byte.b	96	;R
    799  4391		       72		      .byte.b	114	;G
    800  4392		       64		      .byte.b	100	;B
    801  4393		       60		      .byte.b	96	;R
    802  4394		       72		      .byte.b	114	;G
    803  4395		       64		      .byte.b	100	;B
    804  4396		       e0		      .byte.b	224	;R
    805  4397		       f0		      .byte.b	240	;G
    806  4398		       e7		      .byte.b	231	;B
    807  4399		       c0		      .byte.b	192	;R
    808  439a		       e0		      .byte.b	224	;G
    809  439b		       c3		      .byte.b	195	;B
    810  439c		       c0		      .byte.b	192	;R
    811  439d		       e0		      .byte.b	224	;G
    812  439e		       c3		      .byte.b	195	;B
    813  439f		       c0		      .byte.b	192	;R
    814  43a0		       e0		      .byte.b	224	;G
    815  43a1		       c3		      .byte.b	195	;B
    816  43a2		       80		      .byte.b	128	;R
    817  43a3		       c0		      .byte.b	192	;G
    818  43a4		       81		      .byte.b	129	;B
    819  43a5		       80		      .byte.b	128	;R
    820  43a6		       c0		      .byte.b	192	;G
    821  43a7		       81		      .byte.b	129	;B
    822  43a8		       00		      .byte.b	0	;R
    823  43a9		       00		      .byte.b	0	;G
    824  43aa		       00		      .byte.b	0	;B
    825  43ab		       07		      .byte.b	7	;R
    826  43ac		       3f		      .byte.b	63	;G
    827  43ad		       07		      .byte.b	7	;B
    828  43ae		       07		      .byte.b	7	;R
    829  43af		       3f		      .byte.b	63	;G
    830  43b0		       07		      .byte.b	7	;B
    831  43b1		       07		      .byte.b	7	;R
    832  43b2		       3f		      .byte.b	63	;G
    833  43b3		       07		      .byte.b	7	;B
    834  43b4				   COL_5
    835  43b4		       f1		      .byte.b	241	;R
    836  43b5		       70		      .byte.b	112	;G
    837  43b6		       8e		      .byte.b	142	;B
    838  43b7		       f1		      .byte.b	241	;R
    839  43b8		       70		      .byte.b	112	;G
    840  43b9		       8e		      .byte.b	142	;B
    841  43ba		       f1		      .byte.b	241	;R
    842  43bb		       70		      .byte.b	112	;G
    843  43bc		       8e		      .byte.b	142	;B
    844  43bd		       00		      .byte.b	0	;R
    845  43be		       00		      .byte.b	0	;G
    846  43bf		       00		      .byte.b	0	;B
    847  43c0		       18		      .byte.b	24	;R
    848  43c1		       20		      .byte.b	32	;G
    849  43c2		       18		      .byte.b	24	;B
    850  43c3		       18		      .byte.b	24	;R
    851  43c4		       20		      .byte.b	32	;G
    852  43c5		       18		      .byte.b	24	;B
    853  43c6		       1c		      .byte.b	28	;R
    854  43c7		       20		      .byte.b	32	;G
    855  43c8		       1c		      .byte.b	28	;B
    856  43c9		       3c		      .byte.b	60	;R
    857  43ca		       41		      .byte.b	65	;G
    858  43cb		       3c		      .byte.b	60	;B
    859  43cc		       3c		      .byte.b	60	;R
    860  43cd		       41		      .byte.b	65	;G
    861  43ce		       3c		      .byte.b	60	;B
    862  43cf		       3c		      .byte.b	60	;R
    863  43d0		       41		      .byte.b	65	;G
    864  43d1		       3c		      .byte.b	60	;B
    865  43d2		       64		      .byte.b	100	;R
    866  43d3		       8a		      .byte.b	138	;G
    867  43d4		       65		      .byte.b	101	;B
    868  43d5		       64		      .byte.b	100	;R
    869  43d6		       8a		      .byte.b	138	;G
    870  43d7		       65		      .byte.b	101	;B
    871  43d8		       64		      .byte.b	100	;R
    872  43d9		       8a		      .byte.b	138	;G
    873  43da		       65		      .byte.b	101	;B
    874  43db		       44		      .byte.b	68	;R
    875  43dc		       8a		      .byte.b	138	;G
    876  43dd		       45		      .byte.b	69	;B
    877  43de		       44		      .byte.b	68	;R
    878  43df		       8a		      .byte.b	138	;G
    879  43e0		       45		      .byte.b	69	;B
    880  43e1		       44		      .byte.b	68	;R
    881  43e2		       8a		      .byte.b	138	;G
    882  43e3		       45		      .byte.b	69	;B
    883  43e4		       44		      .byte.b	68	;R
    884  43e5		       8a		      .byte.b	138	;G
    885  43e6		       45		      .byte.b	69	;B
    886  43e7		       44		      .byte.b	68	;R
    887  43e8		       8a		      .byte.b	138	;G
    888  43e9		       45		      .byte.b	69	;B
    889  43ea		       44		      .byte.b	68	;R
    890  43eb		       8a		      .byte.b	138	;G
    891  43ec		       45		      .byte.b	69	;B
    892  43ed		       44		      .byte.b	68	;R
    893  43ee		       8a		      .byte.b	138	;G
    894  43ef		       45		      .byte.b	69	;B
    895  43f0		       44		      .byte.b	68	;R
    896  43f1		       8a		      .byte.b	138	;G
    897  43f2		       45		      .byte.b	69	;B
    898  43f3		       44		      .byte.b	68	;R
    899  43f4		       8a		      .byte.b	138	;G
    900  43f5		       45		      .byte.b	69	;B
    901  43f6		       44		      .byte.b	68	;R
    902  43f7		       8a		      .byte.b	138	;G
    903  43f8		       45		      .byte.b	69	;B
    904  43f9		       44		      .byte.b	68	;R
    905  43fa		       8a		      .byte.b	138	;G
    906  43fb		       45		      .byte.b	69	;B
    907  43fc		       44		      .byte.b	68	;R
    908  43fd		       8a		      .byte.b	138	;G
    909  43fe		       45		      .byte.b	69	;B
    910  43ff		       44		      .byte.b	68	;R
    911  4400		       8a		      .byte.b	138	;G
    912  4401		       45		      .byte.b	69	;B
    913  4402		       44		      .byte.b	68	;R
    914  4403		       8a		      .byte.b	138	;G
    915  4404		       45		      .byte.b	69	;B
    916  4405		       4c		      .byte.b	76	;R
    917  4406		       92		      .byte.b	146	;G
    918  4407		       4d		      .byte.b	77	;B
    919  4408		       48		      .byte.b	72	;R
    920  4409		       92		      .byte.b	146	;G
    921  440a		       49		      .byte.b	73	;B
    922  440b		       48		      .byte.b	72	;R
    923  440c		       92		      .byte.b	146	;G
    924  440d		       49		      .byte.b	73	;B
    925  440e		       78		      .byte.b	120	;R
    926  440f		       82		      .byte.b	130	;G
    927  4410		       79		      .byte.b	121	;B
    928  4411		       70		      .byte.b	112	;R
    929  4412		       82		      .byte.b	130	;G
    930  4413		       71		      .byte.b	113	;B
    931  4414		       70		      .byte.b	112	;R
    932  4415		       82		      .byte.b	130	;G
    933  4416		       71		      .byte.b	113	;B
    934  4417		       70		      .byte.b	112	;R
    935  4418		       82		      .byte.b	130	;G
    936  4419		       71		      .byte.b	113	;B
    937  441a		       60		      .byte.b	96	;R
    938  441b		       82		      .byte.b	130	;G
    939  441c		       61		      .byte.b	97	;B
    940  441d		       20		      .byte.b	32	;R
    941  441e		       41		      .byte.b	65	;G
    942  441f		       20		      .byte.b	32	;B
    943  4420		       00		      .byte.b	0	;R
    944  4421		       00		      .byte.b	0	;G
    945  4422		       00		      .byte.b	0	;B
    946  4423		       c7		      .byte.b	199	;R
    947  4424		       c0		      .byte.b	192	;G
    948  4425		       38		      .byte.b	56	;B
    949  4426		       c7		      .byte.b	199	;R
    950  4427		       c0		      .byte.b	192	;G
    951  4428		       38		      .byte.b	56	;B
    952  4429		       c7		      .byte.b	199	;R
    953  442a		       c0		      .byte.b	192	;G
    954  442b		       38		      .byte.b	56	;B
    955  442c
    956  442c
    957  442c
      0  442c					      CHECK_BANK_SIZE	"INITBANK"
      1  442c		       04 2c	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $42c , FREE= $3d4
      2  442c					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  442c				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  442c				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  442c				  -	      ERR
      6  442c					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 4
      0  442c					      include	"BANK_INITBANK.asm"	; MUST be after banks that include levels -- otherwise MAX_LEVELBANK is not calculated properly
      1  442c							;    Sokoboo - a Sokoban implementation
      2  442c							;    using a generic tile-based display engine for the Atari 2600
      3  442c							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  442c							;
      5  442c							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  442c							;
      7  442c							;    Code related to the generic tile-based display engine was developed by
      8  442c							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  442c							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  442c							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  442c							;
     12  442c							;    Code related to music and sound effects uses the TIATracker music player
     13  442c							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  442c							;    directory for Apache licensing details.
     15  442c							;
     16  442c							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  442c							;    See the copyright notices in the License directory for a list of level
     18  442c							;    contributors.
     19  442c							;
     20  442c							;    Except where otherwise indicated, this software is released under the
     21  442c							;    following licensing arrangement...
     22  442c							;
     23  442c							;    This program is free software: you can redistribute it and/or modify
     24  442c							;    it under the terms of the GNU General Public License as published by
     25  442c							;    the Free Software Foundation, either version 3 of the License, or
     26  442c							;    (at your option) any later version.
     27  442c							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  442c
     29  442c							;    This program is distributed in the hope that it will be useful,
     30  442c							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  442c							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  442c							;    GNU General Public License for more details.
     33  442c
      0  442c					      NEWBANK	INITBANK
      1  4b03 ????				      SEG	INITBANK
      2  4800					      ORG	ORIGIN
      3  4800					      RORG	$F000
      4  4800				   BANK_START SET	*
      5  4800				   INITBANK   SET	ORIGIN / 2048
      6  4800				   ORIGIN     SET	ORIGIN + 2048
      7  4800				   _CURRENT_BANK SET	INITBANK
     35  4800
     36  4800		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
     37  4801
      0  4801					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  4801		       00 09	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  4801					      SUBROUTINE
      3  4801				   BoardLineStartLO
     39  4801
     40  4801							; Gives the start address (LO) of each board line
     41  4801					      if	1
     42  4801				   .BOARD_LOCATION SET	Board
     43  4801					      REPEAT	SIZE_BOARD_Y
     44  4801				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4801				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4801					      ENDIF
     47  4801		       00		      .byte.b	<.BOARD_LOCATION
     48  4801				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4801					      REPEND
     44  4802				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4802				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4802					      ENDIF
     47  4802		       28		      .byte.b	<.BOARD_LOCATION
     48  4802				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4802					      REPEND
     44  4803				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4803				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4803					      ENDIF
     47  4803		       50		      .byte.b	<.BOARD_LOCATION
     48  4803				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4803					      REPEND
     44  4804				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4804				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4804					      ENDIF
     47  4804		       78		      .byte.b	<.BOARD_LOCATION
     48  4804				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4804					      REPEND
     44  4805				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4805				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4805					      ENDIF
     47  4805		       a0		      .byte.b	<.BOARD_LOCATION
     48  4805				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4805					      REPEND
     44  4806				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4806				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4806					      ENDIF
     47  4806		       c8		      .byte.b	<.BOARD_LOCATION
     48  4806				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4806					      REPEND
     44  4807					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4807				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4807					      ENDIF
     47  4807		       00		      .byte.b	<.BOARD_LOCATION
     48  4807				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4807					      REPEND
     44  4808				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4808				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4808					      ENDIF
     47  4808		       28		      .byte.b	<.BOARD_LOCATION
     48  4808				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4808					      REPEND
     44  4809				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4809				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4809					      ENDIF
     47  4809		       50		      .byte.b	<.BOARD_LOCATION
     48  4809				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4809					      REPEND
     44  480a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  480a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  480a					      ENDIF
     47  480a		       78		      .byte.b	<.BOARD_LOCATION
     48  480a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  480a					      REPEND
     44  480b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  480b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  480b					      ENDIF
     47  480b		       a0		      .byte.b	<.BOARD_LOCATION
     48  480b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  480b					      REPEND
     44  480c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  480c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  480c					      ENDIF
     47  480c		       c8		      .byte.b	<.BOARD_LOCATION
     48  480c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  480c					      REPEND
     44  480d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  480d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  480d					      ENDIF
     47  480d		       00		      .byte.b	<.BOARD_LOCATION
     48  480d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  480d					      REPEND
     44  480e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  480e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  480e					      ENDIF
     47  480e		       28		      .byte.b	<.BOARD_LOCATION
     48  480e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  480e					      REPEND
     44  480f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  480f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  480f					      ENDIF
     47  480f		       50		      .byte.b	<.BOARD_LOCATION
     48  480f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  480f					      REPEND
     44  4810				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4810				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4810					      ENDIF
     47  4810		       78		      .byte.b	<.BOARD_LOCATION
     48  4810				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4810					      REPEND
     44  4811				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4811				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4811					      ENDIF
     47  4811		       a0		      .byte.b	<.BOARD_LOCATION
     48  4811				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4811					      REPEND
     44  4812				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4812				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4812					      ENDIF
     47  4812		       c8		      .byte.b	<.BOARD_LOCATION
     48  4812				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4812					      REPEND
     44  4813					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4813				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4813					      ENDIF
     47  4813		       00		      .byte.b	<.BOARD_LOCATION
     48  4813				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4813					      REPEND
     44  4814				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4814				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4814					      ENDIF
     47  4814		       28		      .byte.b	<.BOARD_LOCATION
     48  4814				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4814					      REPEND
     44  4815				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4815				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4815					      ENDIF
     47  4815		       50		      .byte.b	<.BOARD_LOCATION
     48  4815				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     43  4815					      REPEND
     44  4816				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     45  4816				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     46  4816					      ENDIF
     47  4816		       78		      .byte.b	<.BOARD_LOCATION
     48  4816				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     49  4817					      REPEND
      0  4817					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  4817					      LIST	ON
     51  4817
     52  4817		       03 a0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     53  4817					      endif
     54  4817
     55  4817							;------------------------------------------------------------------------------
     56  4817
     57  4817				   BoardLineStartHiR
     58  4817
     59  4817							; Gives the start address (HI) of each board line
     60  4817							; Note this caters for the memory wrapping when we go from bank to bank, as
     61  4817							; the board overlays multiple banks!
     62  4817
     63  4817				   .BOARD_LOCATION SET	Board
     64  4817					      REPEAT	SIZE_BOARD_Y
     65  4817				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4817				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4817					      ENDIF
     68  4817		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4817				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4817					      REPEND
     65  4818				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4818				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4818					      ENDIF
     68  4818		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4818				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4818					      REPEND
     65  4819				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4819				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4819					      ENDIF
     68  4819		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4819				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4819					      REPEND
     65  481a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  481a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  481a					      ENDIF
     68  481a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  481a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  481a					      REPEND
     65  481b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  481b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  481b					      ENDIF
     68  481b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  481b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  481b					      REPEND
     65  481c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  481c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  481c					      ENDIF
     68  481c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  481c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  481c					      REPEND
     65  481d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  481d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  481d					      ENDIF
     68  481d		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  481d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  481d					      REPEND
     65  481e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  481e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  481e					      ENDIF
     68  481e		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  481e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  481e					      REPEND
     65  481f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  481f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  481f					      ENDIF
     68  481f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  481f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  481f					      REPEND
     65  4820				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4820				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4820					      ENDIF
     68  4820		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4820				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4820					      REPEND
     65  4821				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4821				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4821					      ENDIF
     68  4821		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4821				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4821					      REPEND
     65  4822				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4822				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4822					      ENDIF
     68  4822		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4822				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4822					      REPEND
     65  4823					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4823				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4823					      ENDIF
     68  4823		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4823				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4823					      REPEND
     65  4824				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4824				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4824					      ENDIF
     68  4824		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4824				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4824					      REPEND
     65  4825				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4825				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4825					      ENDIF
     68  4825		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4825				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4825					      REPEND
     65  4826				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4826				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4826					      ENDIF
     68  4826		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4826				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4826					      REPEND
     65  4827				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4827				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4827					      ENDIF
     68  4827		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4827				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4827					      REPEND
     65  4828				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4828				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4828					      ENDIF
     68  4828		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4828				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4828					      REPEND
     65  4829					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  4829				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  4829					      ENDIF
     68  4829		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  4829				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  4829					      REPEND
     65  482a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  482a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  482a					      ENDIF
     68  482a		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  482a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  482a					      REPEND
     65  482b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  482b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  482b					      ENDIF
     68  482b		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  482b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     64  482b					      REPEND
     65  482c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  482c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  482c					      ENDIF
     68  482c		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     69  482c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     70  482d					      REPEND
      0  482d					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  482d					      LIST	ON
     72  482d							;------------------------------------------------------------------------------
     73  482d
     74  482d				   BoardLineStartHiW
     75  482d
     76  482d							; Gives the start address (HI) of each board line
     77  482d							; Note this caters for the memory wrapping when we go from bank to bank, as
     78  482d							; the board overlays multiple banks!
     79  482d
     80  482d				   .BOARD_LOCATION SET	Board
     81  482d					      REPEAT	SIZE_BOARD_Y
     82  482d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  482d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  482d					      ENDIF
     85  482d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  482d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  482d					      REPEND
     82  482e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  482e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  482e					      ENDIF
     85  482e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  482e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  482e					      REPEND
     82  482f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  482f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  482f					      ENDIF
     85  482f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  482f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  482f					      REPEND
     82  4830				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4830				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4830					      ENDIF
     85  4830		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4830				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  4830					      REPEND
     82  4831				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4831				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4831					      ENDIF
     85  4831		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4831				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  4831					      REPEND
     82  4832				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4832				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4832					      ENDIF
     85  4832		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4832				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  4832					      REPEND
     82  4833					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4833				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4833					      ENDIF
     85  4833		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4833				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  4833					      REPEND
     82  4834				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4834				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4834					      ENDIF
     85  4834		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4834				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  4834					      REPEND
     82  4835				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4835				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4835					      ENDIF
     85  4835		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4835				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  4835					      REPEND
     82  4836				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4836				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4836					      ENDIF
     85  4836		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4836				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  4836					      REPEND
     82  4837				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4837				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4837					      ENDIF
     85  4837		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4837				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  4837					      REPEND
     82  4838				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4838				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4838					      ENDIF
     85  4838		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4838				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  4838					      REPEND
     82  4839					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4839				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4839					      ENDIF
     85  4839		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4839				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  4839					      REPEND
     82  483a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  483a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  483a					      ENDIF
     85  483a		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  483a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  483a					      REPEND
     82  483b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  483b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  483b					      ENDIF
     85  483b		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  483b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  483b					      REPEND
     82  483c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  483c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  483c					      ENDIF
     85  483c		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  483c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  483c					      REPEND
     82  483d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  483d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  483d					      ENDIF
     85  483d		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  483d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  483d					      REPEND
     82  483e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  483e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  483e					      ENDIF
     85  483e		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  483e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  483e					      REPEND
     82  483f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  483f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  483f					      ENDIF
     85  483f		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  483f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  483f					      REPEND
     82  4840				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4840				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4840					      ENDIF
     85  4840		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4840				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  4840					      REPEND
     82  4841				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4841				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4841					      ENDIF
     85  4841		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4841				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     81  4841					      REPEND
     82  4842				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     83  4842				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     84  4842					      ENDIF
     85  4842		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     86  4842				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     87  4843					      REPEND
      0  4843					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  4843					      LIST	ON
     89  4843
     90  4843							;------------------------------------------------------------------------------
     91  4843				  -	      IF	MULTI_BANK_BOARD = YES
     92  4843				  -BoardBank
     93  4843					      ENDIF
     94  4843							; Gives the RAM bank of the start of the board row for a given row.
     95  4843
     96  4843				   .BOARD_LOCATION SET	Board - RAM_3E
     97  4843					      REPEAT	SIZE_BOARD_Y
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     97  4843					      REPEND
     98  4843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     99  4843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    100  4843					      ENDIF
    101  4843				  -	      IF	MULTI_BANK_BOARD = YES
    102  4843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
    103  4843					      ENDIF
    104  4843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
    105  4843					      REPEND
    106  4843				  -	      IF	MULTI_BANK_BOARD = YES
    107  4843				  -	      CHECKPAGEX	BoardBank, "BoardBank in BANK_INITBANK.asm"
    108  4843					      ENDIF
    109  4843
    110  4843
    111  4843							;------------------------------------------------------------------------------
    112  4843
    113  4843				   CopyROMShadowToRAM_F000
    114  4843		       a9 f0		      lda	#>$F000
    115  4845
      0  4845					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  4845		       00 09	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  4845					      SUBROUTINE
      3  4845				   CopyROMShadowToRAM
    117  4845
    118  4845							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
    119  4845							; the variable definitions are in the ROM shadow because this allows auto-initialisation
    120  4845							; of the variable contents from ROM declarations, but still allows access to them as
    121  4845							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
    122  4845							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
    123  4845							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
    124  4845							; code co-lives in all banks and may run even as bankswitching occurs between those
    125  4845							; banks -- by the very code itself.
    126  4845
    127  4845							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
    128  4845		       85 c1		      sta	Board_AddressR+1
    129  4847		       86 db		      stx	O_ROM_Source_Bank	; source bank
    130  4849		       84 c5		      sty	RAM_Bank	; destination bank
    131  484b
    132  484b		       a0 00		      ldy	#0
    133  484d		       84 c0		      sty	Board_AddressR
    134  484f		       84 c2		      sty	Board_AddressW
    135  4851		       a9 14		      lda	#>($1000+RAM_WRITE)
    136  4853		       85 c3		      sta	Board_AddressW+1
    137  4855
    138  4855							; Iterate 4 pages (1K) for complete bank copy
    139  4855
    140  4855		       a9 04		      lda	#4
    141  4857		       85 da		      sta	O_CopyCount
    142  4859
    143  4859		       84 dc	   CopyPage   sty	O_Index
    144  485b		       a5 db		      lda	O_ROM_Source_Bank
    145  485d		       20 0c f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    146  4860							;tax
    147  4860		       a4 dc		      ldy	O_Index
    148  4862		       a6 c5		      ldx	RAM_Bank
    149  4864		       20 1a f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    150  4867
    151  4867		       a4 dc		      ldy	O_Index
    152  4869		       c8		      iny
    153  486a		       d0 ed		      bne	CopyPage
    154  486c
    155  486c		       e6 c1		      inc	Board_AddressR+1
    156  486e		       e6 c3		      inc	Board_AddressW+1
    157  4870
    158  4870		       c6 da		      dec	O_CopyCount
    159  4872		       d0 e5		      bne	CopyPage
    160  4874
    161  4874		       a4 c5		      ldy	RAM_Bank	; TODO: remove!?
    162  4876		       60		      rts
    163  4877
    164  4877
    165  4877							;------------------------------------------------------------------------------
      0  4877					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  4877		       00 09	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  4877					      SUBROUTINE
      3  4877				   SetPlatformColours
    167  4877
    168  4877							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    169  4877							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    170  4877							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    171  4877							; addressing will not violate the page-crossing restriction of 3E.
    172  4877
    173  4877							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    174  4877
    175  4877		       a9 00		      lda	#<DrawTheScreen	; = 0
    176  4879		       85 c2		      sta	Board_AddressW
    177  487b		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    178  487d		       85 c3		      sta	Board_AddressW+1
    179  487f
    180  487f							; first, set the x index (with last one being a RTS ($60))
    181  487f
    182  487f		       a6 c5		      ldx	RAM_Bank
    183  4881		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    184  4883		       d0 07		      bne	.skipPatch
    185  4885		       a9 60		      lda	#$60	; rts
    186  4887		       a0 41		      ldy	#<SELFMOD_X
    187  4889		       20 1a f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    188  488c				   .skipPatch
    189  488c
    190  488c		       a2 02		      ldx	#3-1
    191  488e				   .loopColor
    192  488e		       86 da		      stx	colorIdx
    193  4890							; set PF colors
    194  4890		       b5 bd		      lda	color,x
    195  4892		       bc b7 f0 	      ldy	SelfModColOfsTbl,x
    196  4895							;tax
    197  4895		       a6 c5		      ldx	RAM_Bank
    198  4897		       20 1a f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy PF colour RED/GREEN/BLUE to self-modifying RAM
    199  489a							; set player colors
    200  489a		       a6 da		      ldx	colorIdx
    201  489c		       bd ba f0 	      lda	SelfModePlayerTbl,x
    202  489f		       a4 81		      ldy	Platform
    203  48a1		       c0 02		      cpy	#PAL
    204  48a3		       90 02		      bcc	.platform0
    205  48a5		       69 14		      adc	#LINES_PER_CHAR-1	; C==1!
    206  48a7				   .platform0
    207  48a7		       bc bd f0 	      ldy	SelfModPlayerColOfsTbl,x
    208  48aa							;tax
    209  48aa		       a6 c5		      ldx	RAM_Bank
    210  48ac		       20 1a f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy player colour RED/GREEN/BLUE to self-modifying RAM
    211  48af							; loop
    212  48af		       a6 da		      ldx	colorIdx
    213  48b1		       ca		      dex
    214  48b2		       10 da		      bpl	.loopColor
    215  48b4
    216  48b4		       a4 c5		      ldy	RAM_Bank
    217  48b6		       60		      rts
    218  48b7
    219  48b7				   SelfModColOfsTbl
    220  48b7		       53 86 1c 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    221  48ba				   SelfModePlayerTbl
    222  48ba		       bd b6 af 	      .byte.b	<SpriteColourBLUE, <SpriteColourGREEN, <SpriteColourRED
    223  48bd				   SelfModPlayerColOfsTbl
    224  48bd		       4c 7f 15 	      .byte.b	<(SELFMOD_PLAYERCOL_BLUE+1), <(SELFMOD_PLAYERCOL_GREEN+1), <(SELFMOD_PLAYERCOL_RED+1)
    225  48c0
    226  48c0
    227  48c0				   DrawLineStartLO
    228  48c0
    229  48c0							; Gives the start address of each line in the draw flags buffer
    230  48c0
    231  48c0				   .DRAW_LOCATION SET	DrawFlag
    232  48c0					      REPEAT	SCREEN_LINES
    233  48c0		       50		      .byte.b	<.DRAW_LOCATION
    234  48c0				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  48c0					      REPEND
    233  48c1		       5a		      .byte.b	<.DRAW_LOCATION
    234  48c1				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  48c1					      REPEND
    233  48c2		       64		      .byte.b	<.DRAW_LOCATION
    234  48c2				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  48c2					      REPEND
    233  48c3		       6e		      .byte.b	<.DRAW_LOCATION
    234  48c3				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  48c3					      REPEND
    233  48c4		       78		      .byte.b	<.DRAW_LOCATION
    234  48c4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  48c4					      REPEND
    233  48c5		       82		      .byte.b	<.DRAW_LOCATION
    234  48c5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  48c5					      REPEND
    233  48c6		       8c		      .byte.b	<.DRAW_LOCATION
    234  48c6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    232  48c6					      REPEND
    233  48c7		       96		      .byte.b	<.DRAW_LOCATION
    234  48c7				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    235  48c8					      REPEND
    236  48c8
    237  48c8
    238  48c8							;------------------------------------------------------------------------------
    239  48c8
      0  48c8					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  48c8		       00 09	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  48c8					      SUBROUTINE
      3  48c8				   GetBoardAddressRW
    241  48c8							; Must share same bank as BoardLineStart tables
    242  48c8
    243  48c8		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    244  48cb		       85 c0		      sta	Board_AddressR	; 3
    245  48cd		       85 c2		      sta	Board_AddressW	; 3
    246  48cf		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    247  48d2		       85 c1		      sta	Board_AddressR+1	; 3	     READ address
    248  48d4		       09 04		      ora	#>RAM_WRITE	; 2
    249  48d6		       85 c3		      sta	Board_AddressW+1	; 3	     WRITE address
    250  48d8				  -	      IF	MULTI_BANK_BOARD = YES
    251  48d8				  -	      ldx	BoardBank,y	; 4 = 26    switch this on return
    252  48d8					      ELSE
    253  48d8		       a2 0d		      ldx	#BANK_BOARD	; 2
    254  48da					      ENDIF
    255  48da		       60		      rts		; 6 = 32[-2]
    256  48db
    257  48db							;------------------------------------------------------------------------------
    258  48db
      0  48db					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  48db		       00 09	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  48db					      SUBROUTINE
      3  48db				   GetBoardAddressR
    260  48db
    261  48db		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    262  48de		       85 c0		      sta	Board_AddressR	; 3
    263  48e0		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    264  48e3		       85 c1		      sta	Board_AddressR+1	; 3	 READ address
    265  48e5				  -	      IF	MULTI_BANK_BOARD = YES
    266  48e5				  -	      lda	BoardBank,y	; 4	 switch this on return
    267  48e5					      ELSE
    268  48e5		       a9 0d		      lda	#BANK_BOARD	; 2
    269  48e7					      ENDIF
    270  48e7		       60		      rts		; 6[-2]
    271  48e8
    272  48e8							;------------------------------------------------------------------------------
    273  48e8
      0  48e8					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  48e8		       00 09	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  48e8					      SUBROUTINE
      3  48e8				   GetBoardAddressW
    275  48e8
    276  48e8							; Must share same bank as BoardLineStart tables
    277  48e8
    278  48e8		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    279  48eb		       85 c2		      sta	Board_AddressW	;3
    280  48ed		       b9 2d f0 	      lda	BoardLineStartHiW,y	;4
    281  48f0		       85 c3		      sta	Board_AddressW+1	;3 WRITE address
    282  48f2				  -	      IF	MULTI_BANK_BOARD = YES
    283  48f2				  -	      ldx	BoardBank,y	;4 switch this on return
    284  48f2					      ELSE
    285  48f2		       a2 0d		      ldx	#BANK_BOARD	;2
    286  48f4					      ENDIF
    287  48f4		       60	   QRet       rts		;6
    288  48f5
    289  48f5							;-------------------------------------------------------------------------------
    290  48f5
    291  48f5
    292  48f5							;------------------------------------------------------------------------------
    293  48f5
      0  48f5					      DEFINE_SUBROUTINE	PushBox	; in INITBANK
      1  48f5		       00 09	   BANK_PushBox =	_CURRENT_BANK
      2  48f5					      SUBROUTINE
      3  48f5				   PushBox
    295  48f5
    296  48f5							; X = restoration character for square we are moving TO
    297  48f5							; so, if X = CHARACTER_TARGET AND we move, THEN we are pushing a box off a target
    298  48f5
    299  48f5		       85 c4		      sta	ROM_Bank
    300  48f7
    301  48f7		       a5 a5		      lda	ManPushCounter
    302  48f9		       c9 01		      cmp	#PUSH_LIMIT
    303  48fb		       90 6c		      bcc	cannotPush
    304  48fd
    305  48fd		       86 dc		      stx	restorationCharacter	; BOX'S NEW CHAR
    306  48ff
    307  48ff							; Determine if the box is pushable
    308  48ff							; we use the joystick to calculate the subsequent square
    309  48ff
    310  48ff		       a5 90		      lda	BufferedJoystick
    311  4901		       4a		      lsr
    312  4902		       4a		      lsr
    313  4903		       4a		      lsr
    314  4904		       4a		      lsr
    315  4905		       48		      pha
    316  4906		       a8		      tay
    317  4907
    318  4907		       18		      clc
    319  4908		       a5 8d		      lda	POS_Y_NEW
    320  490a		       79 92 f2 	      adc	JoyMoveY,y
    321  490d		       a8		      tay
    322  490e		       20 c8 f0 	      jsr	GetBoardAddressRW
    323  4911
    324  4911		       68		      pla
    325  4912		       a8		      tay
    326  4913
    327  4913		       18		      clc
    328  4914		       a5 8c		      lda	POS_X_NEW
    329  4916		       79 86 f2 	      adc	JoyMoveX,y
    330  4919		       48		      pha
    331  491a		       a8		      tay
    332  491b
    333  491b				  -	      IF	MULTI_BANK_BOARD = YES
    334  491b				  -	      lda	RAM_Bank
    335  491b					      ELSE
    336  491b		       a9 0d		      lda	#BANK_BOARD	; 2
    337  491d					      ENDIF
    338  491d		       20 11 f8 	      jsr	GetBoardCharacter	;6+20(A)
    339  4920		       68		      pla
    340  4921		       a8		      tay
    341  4922
    342  4922		       a9 02		      lda	#CHARACTER_BOX
    343  4924		       e0 00		      cpx	#CHARACTER_BLANK
    344  4926		       f0 13		      beq	canPushTarget
    345  4928
    346  4928		       e0 03		      cpx	#CHARACTER_TARGET
    347  492a		       f0 04		      beq	decreaseTargets
    348  492c		       e0 04		      cpx	#CHARACTER_TARGET2
    349  492e		       d0 39		      bne	cannotPush
    350  4930
    351  4930							; Box is now on a target - so decrease the remaining targets
    352  4930
    353  4930		       f8	   decreaseTargets sed
    354  4931		       38		      sec
    355  4932		       a5 b9		      lda	targetsRequired
    356  4934		       e9 01		      sbc	#1
    357  4936		       85 b9		      sta	targetsRequired
    358  4938		       d8		      cld
    359  4939
    360  4939		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    361  493b		       48	   canPushTarget pha
    362  493c
    363  493c							; If the box *WAS* on a target (restoration character = CHARACTER_TARGET)
    364  493c							; then we increase targets (as there is one more to get)
    365  493c
    366  493c		       a5 dc		      lda	restorationCharacter
    367  493e		       c9 03		      cmp	#CHARACTER_TARGET
    368  4940		       d0 09		      bne	notOnTargetAlready
    369  4942
    370  4942							; increase the required targets as box is leaving one
    371  4942
    372  4942		       f8		      sed
    373  4943		       18		      clc
    374  4944		       a5 b9		      lda	targetsRequired
    375  4946		       69 01		      adc	#1
    376  4948		       85 b9		      sta	targetsRequired
    377  494a		       d8		      cld
    378  494b
    379  494b				   notOnTargetAlready
    380  494b
    381  494b
    382  494b		       68		      pla
    383  494c
    384  494c
    385  494c				  -	      IF	MULTI_BANK_BOARD = YES
    386  494c				  -	      ldx	RAM_Bank
    387  494c					      ELSE
    388  494c		       a2 0d		      ldx	#BANK_BOARD	; 2
    389  494e					      ENDIF
    390  494e		       20 1a f8 	      jsr	PutBoardCharacter	;6+21(A)
    391  4951
    392  4951		       a5 8f		      lda	POS_VAR	; player's restoration character
    393  4953		       48		      pha
    394  4954
    395  4954		       a6 8d		      ldx	POS_Y_NEW
    396  4956		       86 8b		      stx	POS_Y
    397  4958		       a4 8c		      ldy	POS_X_NEW
    398  495a		       84 8a		      sty	POS_X
    399  495c		       a5 dc		      lda	restorationCharacter
    400  495e		       85 8f		      sta	POS_VAR
    401  4960
    402  4960		       20 f7 f8 	      jsr	RestoreOriginalCharacter	; put back BOX's restoration character
    403  4963
    404  4963		       68		      pla
    405  4964		       85 8f		      sta	POS_VAR
    406  4966
    407  4966							;START_SOUND SOUND_BOX
    408  4966
    409  4966		       4c 56 f9 	      jmp	MovePlayer	; now there's a gap, player should move in
    410  4969
    411  4969		       e6 a5	   cannotPush inc	ManPushCounter
    412  496b		       60		      rts
    413  496c
    414  496c							;------------------------------------------------------------------------------
    415  496c
    416  496c							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    417  496c							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    418  496c
    419  496c							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    420  496c
    421  496c							; if the creature dies then jump NextObject
    422  496c
    423  496c
    424  496c
    425  496c		       ff	   RDirY      .byte.b	-1	;,0,1,0
    426  496d		       00 01	   RDirX      .byte.b	0,1	;,0,-1
    427  496f		       00 ff 01 00 DirPushModX .byte.b	0,-1,1,0
    428  4973		       ff 00 00 01 DirPushModY .byte.b	-1,0,0,1
    429  4977		       01 02 03 00*Directional .byte.b	1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    430  4985
    431  4985
    432  4985							;------------------------------------------------------------------------------
    433  4985
    434  4985							; the auto-calculation of these was causing DASM to get confused and abort assembling.
    435  4985							; I don't particularly know why; probably because of the level variable-size array and the values
    436  4985							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    437  4985
    438  4985		       00 00	   MANMODE_STARTUP =	0
    439  4985		       00 01	   MANMODE_NORMAL =	1
    440  4985		       00 02	   MANMODE_DEAD =	2
    441  4985		       00 03	   MANMODE_WAITING =	3
    442  4985		       00 04	   MANMODE_WAITING2 =	4
    443  4985		       00 05	   MANMODE_WAITING_NT =	5
    444  4985		       00 06	   MANMODE_WAITING_NT2 =	6
    445  4985		       00 07	   MANMODE_NEXTLEVEL =	7
    446  4985		       00 08	   MANMODE_NEXTLEVEL2 =	8
    447  4985		       00 09	   MANMODE_SWITCH =	9
    448  4985
      0  4985					      DEFINE_SUBROUTINE	ManProcess
      1  4985		       00 09	   BANK_ManProcess =	_CURRENT_BANK
      2  4985					      SUBROUTINE
      3  4985				   ManProcess
    450  4985
    451  4985							; ManMode tells the player what it is currently doing.  State machine.
    452  4985
    453  4985							; Check the switches....
    454  4985							; RESET to restart this level
    455  4985							; SELECT to start next level
    456  4985
    457  4985		       ad 82 02 	      lda	SWCHB
    458  4988		       29 03		      and	#3
    459  498a		       aa		      tax
    460  498b		       bd a4 f1 	      lda	newMode,x
    461  498e		       30 02		      bmi	skipModeChange
    462  4990		       85 9f		      sta	ManMode
    463  4992				   skipModeChange
    464  4992
    465  4992		       20 00 f8 	      jsr	DrawTimeFromROM	; Z-flag == 0!
    466  4995
    467  4995		       a4 9f		      ldy	ManMode
    468  4997		       b9 a8 f1 	      lda	ManActionLO,y
    469  499a		       85 da		      sta	actionVector
    470  499c		       b9 b2 f1 	      lda	ManActionHI,y
    471  499f		       85 db		      sta	actionVector+1
    472  49a1		       6c da 00 	      jmp	(actionVector)
    473  49a4
    474  49a4		       ff 09 04 ff newMode    .byte.b	-1, MANMODE_SWITCH, MANMODE_WAITING2, -1
    475  49a8
    476  49a8				   ManActionLO
    477  49a8		       bc		      .byte.b	<manStartup	; 0		 no timer
    478  49a9		       eb		      .byte.b	<normalMan	; 1		 timer
    479  49aa		       f0		      .byte.b	<deadMan	; 2		 timer
    480  49ab		       e4		      .byte.b	<waitingMan	; 3		 timer
    481  49ac		       e4		      .byte.b	<waitingManPress	; 4		 timer
    482  49ad		       e4		      .byte.b	<waitingMan	; 5		 no timer
    483  49ae		       e4		      .byte.b	<waitingManPress	; 6		 no timer
    484  49af		       51		      .byte.b	<nextLevelMan	; 7		 no timer
    485  49b0		       62		      .byte.b	<nextLevelMan2	; 8		 no timer
    486  49b1		       6d		      .byte.b	<switchLevels	; 9		 no timer
    487  49b2
    488  49b2				   ManActionHI
    489  49b2		       f1		      .byte.b	>manStartup	; no timer
    490  49b3		       f1		      .byte.b	>normalMan	; timer
    491  49b4		       f1		      .byte.b	>deadMan	; timer
    492  49b5		       f1		      .byte.b	>waitingMan	; timer
    493  49b6		       f1		      .byte.b	>waitingManPress	; timer
    494  49b7		       f1		      .byte.b	>waitingMan	; no timer
    495  49b8		       f1		      .byte.b	>waitingManPress	; no timer
    496  49b9		       fc		      .byte.b	>nextLevelMan	; no timer
    497  49ba		       fc		      .byte.b	>nextLevelMan2	; no timer
    498  49bb		       fc		      .byte.b	>switchLevels	;9  no timer
    499  49bc
    500  49bc							;------------------------------------------------------------------------------
      0  49bc					      DEFINE_SUBROUTINE	manStartup
      1  49bc		       00 09	   BANK_manStartup =	_CURRENT_BANK
      2  49bc					      SUBROUTINE
      3  49bc				   manStartup
    502  49bc
    503  49bc		       a5 9b		      lda	ManX
    504  49be		       85 8c		      sta	POS_X_NEW	;NewX
    505  49c0		       85 8a		      sta	POS_X
    506  49c2		       a5 9c		      lda	ManY
    507  49c4		       85 8d		      sta	POS_Y_NEW	;NewY
    508  49c6		       85 8b		      sta	POS_Y
    509  49c8
    510  49c8		       e6 9a		      inc	manAnimationIndex
    511  49ca		       a6 9a		      ldx	manAnimationIndex	; animation index
    512  49cc		       bd dc f1 	      lda	.ManStartup-1,x
    513  49cf		       30 09		      bmi	CreateThePlayer
    514  49d1		       85 8e		      sta	POS_Type
    515  49d3
    516  49d3		       a9 ff		      lda	#$FF
    517  49d5		       85 a0		      sta	ManDelayCount	; anything, just non-0
    518  49d7
    519  49d7		       4c 37 f8 	      jmp	PutBoardCharacterFromRAM	;70 --> switches this bank out but who cares!
    520  49da
    521  49da				   CreateThePlayer
    522  49da
    523  49da		       e6 9f		      inc	ManMode	; --> MANMODE_NORMAL
    524  49dc				   RTS_CF
    525  49dc		       60		      rts
    526  49dd
    527  49dd				   .ManStartup
    528  49dd		       09		      .byte.b	CHARACTER_NOGO
    529  49de		       09		      .byte.b	CHARACTER_NOGO
    530  49df		       06		      .byte.b	CHARACTER_STEEL
    531  49e0							;    .byte CHARACTER_STEEL
    532  49e0		       09		      .byte.b	CHARACTER_NOGO
    533  49e1							;    .byte CHARACTER_NOGO
    534  49e1		       06		      .byte.b	CHARACTER_STEEL
    535  49e2							;    .byte CHARACTER_NOGO
    536  49e2							;    .byte CHARACTER_STEEL
    537  49e2							;    .byte CHARACTER_NOGO
    538  49e2							;    .byte CHARACTER_STEEL
    539  49e2							;    .byte CHARACTER_NOGO
    540  49e2							;    .byte CHARACTER_STEEL
    541  49e2							;    .byte CHARACTER_NOGO
    542  49e2							;    .byte CHARACTER_STEEL
    543  49e2							;    .byte CHARACTER_NOGO
    544  49e2							;    .byte CHARACTER_STEEL
    545  49e2							;.byte CHARACTER_NOGO
    546  49e2		       05		      .byte.b	CHARACTER_MANOCCUPIED
    547  49e3		       ff		      .byte.b	-1
    548  49e4
    549  49e4							;------------------------------------------------------------------------------
    550  49e4
    551  49e4				   waitingMan
    552  49e4				   waitingManPress
    553  49e4
    554  49e4							;		  lda #50
    555  49e4							;		  sta ColourTimer
    556  49e4
    557  49e4
    558  49e4		       a5 ca		      lda	NextLevelTrigger
    559  49e6		       09 40		      ora	#BIT_NEXTLIFE
    560  49e8		       85 ca		      sta	NextLevelTrigger
    561  49ea		       60		      rts
    562  49eb
    563  49eb
    564  49eb							;------------------------------------------------------------------------------
    565  49eb							; Normal man state
    566  49eb
    567  49eb
    568  49eb				   normalMan
    569  49eb
    570  49eb							; Timer is still running, so we see if the player is to die for any reason
    571  49eb
    572  49eb							;		  bit demoMode
    573  49eb							;		  bmi stayAlive
    574  49eb							; SELECT pressed?
    575  49eb							;		  lda SWCHB
    576  49eb							;		  eor #$FF
    577  49eb							;		  and #3
    578  49eb							;		  bne Time0			  ; EITHER select or reset are pressed
    579  49eb							;		  lsr
    580  49eb							;		  lsr
    581  49eb							;		  bcc Time0			  ; suicide!
    582  49eb				   stayAlive
    583  49eb
    584  49eb							;------------------------------------------------------------------------------
    585  49eb
    586  49eb							;ldx ManY
    587  49eb							;ldy ManX
    588  49eb
    589  49eb							;lda BoardLineStartLO,x
    590  49eb							;sta Board_AddressR
    591  49eb							;lda BoardLineStartHiR,x
    592  49eb							;sta Board_AddressR+1
    593  49eb
    594  49eb				  -	      IF	MULTI_BANK_BOARD = YES
    595  49eb				  -			;lda BoardBank,x		  ;4
    596  49eb				  -			;sta RAM_Bank			  ;3
    597  49eb					      ELSE
    598  49eb							;lda #BANK_BOARD		  ;2
    599  49eb					      ENDIF
    600  49eb							;jsr GetBoardCharacter 	  ;6+20(A)
    601  49eb
    602  49eb							;lda CharToType,x
    603  49eb							;cmp #TYPE_MAN
    604  49eb							;beq PlayerAlive
    605  49eb		       4c fb f1 	      jmp	PlayerAlive	;sok
    606  49ee
    607  49ee							; character he's on isn't a MAN character, so he dies...
    608  49ee
    609  49ee				   Time0
    610  49ee
    611  49ee		       e6 9f		      inc	ManMode	; #1 -- player dead!
    612  49f0
    613  49f0
    614  49f0		       a5 9b	   deadMan    lda	ManX
    615  49f2		       85 8a		      sta	POS_X
    616  49f4		       a5 9c		      lda	ManY
    617  49f6		       85 8b		      sta	POS_Y
    618  49f8
    619  49f8							;jsr BlankPlayerFrame
    620  49f8
    621  49f8							; and becomes a man waiting for resurrection...
    622  49f8
    623  49f8		       e6 9f		      inc	ManMode
    624  49fa
    625  49fa				   timeTooShortToDie
    626  49fa		       60		      rts
    627  49fb
    628  49fb							;------------------------------------------------------------------------------
    629  49fb
    630  49fb				   PlayerAlive
    631  49fb
    632  49fb							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    633  49fb							; before exiting via (for example) look-around option :)
    634  49fb
    635  49fb		       a5 9b		      lda	ManX
    636  49fd		       85 8c		      sta	POS_X_NEW
    637  49ff		       a5 9c		      lda	ManY
    638  4a01		       85 8d		      sta	POS_Y_NEW
    639  4a03
    640  4a03
    641  4a03
    642  4a03							;------------------------------------------------------------------------------
    643  4a03							; Look around is triggered by holding down the fire button for a while, without any other
    644  4a03							; joystick directions chosen. The variable LookingAround has a negative value ($FF) when looking
    645  4a03							; is active. Otherwise, it is counting down to the time where it will trigger.
    646  4a03
    647  4a03		       00 00	   LOOK_DELAY =	0
    648  4a03
    649  4a03
    650  4a03							;------------------------------------------------------------------------------
    651  4a03							; Take-back is a press/release of the button, with the press being limited in duratino
    652  4a03							; to allow the action to be "cancelled". Meanwhile, a button press + direction triggers
    653  4a03							; "look-around mode"
    654  4a03
    655  4a03		       a5 92		      lda	BufferedButton
    656  4a05		       30 36		      bmi	noLook	; button?
    657  4a07
    658  4a07							; button pressed, so in looking-around mode
    659  4a07
    660  4a07		       a2 ff		      ldx	#$FF
    661  4a09		       86 92		      stx	BufferedButton	; "release" button
    662  4a0b
    663  4a0b		       a5 a6		      lda	LookingAround
    664  4a0d		       30 02		      bmi	LookAround
    665  4a0f		       86 a6		      stx	LookingAround
    666  4a11				   LookAround
    667  4a11
    668  4a11							; Use the joystick as a window-scroller to change the viewport
    669  4a11
    670  4a11		       a5 90		      lda	BufferedJoystick
    671  4a13		       4a		      lsr
    672  4a14		       4a		      lsr
    673  4a15		       4a		      lsr
    674  4a16		       4a		      lsr
    675  4a17		       a8		      tay
    676  4a18
    677  4a18		       b9 86 f2 	      lda	JoyMoveX,y
    678  4a1b		       19 92 f2 	      ora	JoyMoveY,y
    679  4a1e		       f0 1c		      beq	AbandonY
    680  4a20
    681  4a20		       a9 fe		      lda	#$FE
    682  4a22		       85 a6		      sta	LookingAround
    683  4a24
    684  4a24		       b9 86 f2 	      lda	JoyMoveX,y
    685  4a27							;asl
    686  4a27		       18		      clc
    687  4a28		       65 97		      adc	BoardScrollX
    688  4a2a		       c5 94		      cmp	BoardEdge_Right
    689  4a2c		       b0 02		      bcs	AbandonX
    690  4a2e		       85 97		      sta	BoardScrollX
    691  4a30
    692  4a30		       b9 92 f2    AbandonX   lda	JoyMoveY,y
    693  4a33							;asl
    694  4a33		       18		      clc
    695  4a34		       65 96		      adc	BoardScrollY
    696  4a36		       c5 95		      cmp	BoardEdge_Bottom
    697  4a38		       b0 02		      bcs	AbandonY
    698  4a3a		       85 96		      sta	BoardScrollY
    699  4a3c
    700  4a3c		       60	   AbandonY   rts
    701  4a3d
    702  4a3d		       a5 a6	   noLook     lda	LookingAround
    703  4a3f		       c9 ff		      cmp	#$FF
    704  4a41		       d0 00		      bne	bProcComp
    705  4a43
    706  4a43							; button was presssed and now released and we didn't actually look around
    707  4a43							; TODO -- takeback here
    708  4a43							;jsr restorePreviousManPosition
    709  4a43							;lda #2
    710  4a43							;sta ColourTimer
    711  4a43
    712  4a43		       a2 00	   bProcComp  ldx	#0
    713  4a45		       86 a6		      stx	LookingAround
    714  4a47
    715  4a47							;------------------------------------------------------------------------------
    716  4a47
    717  4a47							; control the scrolling via the joystick
    718  4a47
    719  4a47		       a5 a4		      lda	ManLastDirection
    720  4a49		       29 07		      and	#DIRECTION_BITS
    721  4a4b		       a8		      tay
    722  4a4c
    723  4a4c		       a5 90		      lda	BufferedJoystick	; joystick
    724  4a4e		       25 91		      and	BufferedJoystick+1
    725  4a50
    726  4a50		       a2 00		      ldx	#0
    727  4a52		       0a	   .loopDirs  asl
    728  4a53		       90 07		      bcc	.dirFound
    729  4a55		       88		      dey
    730  4a56		       e8		      inx
    731  4a57		       e0 04		      cpx	#4
    732  4a59		       d0 f7		      bne	.loopDirs
    733  4a5b		       18		      clc
    734  4a5c				   .dirFound
    735  4a5c		       a5 8c		      lda	POS_X_NEW	;NewX
    736  4a5e		       7d 9f f2 	      adc	JoyDirX,x
    737  4a61		       85 8c		      sta	POS_X_NEW	;NewX
    738  4a63		       a5 8d		      lda	POS_Y_NEW	;NewY
    739  4a65		       18		      clc
    740  4a66		       7d 9d f2 	      adc	JoyDirY,x
    741  4a69		       85 8d		      sta	POS_Y_NEW	;NewY
    742  4a6b
    743  4a6b		       98		      tya
    744  4a6c		       f0 12		      beq	noMovement	; animation OK
    745  4a6e
    746  4a6e		       8a		      txa
    747  4a6f		       45 a4		      eor	ManLastDirection
    748  4a71		       29 07		      and	#DIRECTION_BITS
    749  4a73		       45 a4		      eor	ManLastDirection
    750  4a75		       85 a4		      sta	ManLastDirection
    751  4a77		       bd 81 f2 	      lda	ManAnimTblLo,x
    752  4a7a		       85 a1		      sta	ManAnimation
    753  4a7c							;lda ManAnimTblHi,x
    754  4a7c							;sta ManAnimation+1
    755  4a7c		       a9 00		      lda	#0
    756  4a7e		       85 a0		      sta	ManDelayCount
    757  4a80				   phase0		;jsr MovePlayer
    758  4a80				   noMovement		;ldx MAN_Player
    759  4a80
    760  4a80		       60	   DFS_rts    rts
    761  4a81
    762  4a81
    763  4a81				   ManAnimTblLo
    764  4a81		       00 00 00 00*	      .byte.b	AnimateRIGHT-Manimate, AnimateLEFT-Manimate, AnimateUP-Manimate, AnimateUP-Manimate, AnimateSTOPPED-Manimate
    765  4a86							;ManAnimTblHi
    766  4a86							;    .byte   >AnimateRIGHT, >AnimateLEFT, >AnimateUP, >AnimateUP, >AnimateSTOPPED
    767  4a86
    768  4a86
    769  4a86
    770  4a86		       00 00 00 00*JoyMoveX   .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1	;,0, 0,0,0
    771  4a92		       00 00 00 00*JoyMoveY   .byte.b	0,0,0,0,0,1,-1,0,0, 1,-1	;, 0,0,1,-1,0
    772  4a9d
    773  4a9d				   JoyDirY
    774  4a9d		       00 00		      .byte.b	0,0	;,1,-1,0
    775  4a9f				   JoyDirX
    776  4a9f		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
    777  4aa4
    778  4aa4
    779  4aa4							;------------------------------------------------------------------------------
    780  4aa4
    781  4aa4
      0  4aa4					      DEFINE_SUBROUTINE	DrawFullScreen	; = 2568[-96]
      1  4aa4		       00 09	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  4aa4					      SUBROUTINE
      3  4aa4				   DrawFullScreen
    783  4aa4
    784  4aa4							; 83[-7] + 2484[-89] = 2567[-96]
    785  4aa4
    786  4aa4
    787  4aa4		       ad 84 02 	      lda	INTIM	; 4
    788  4aa7		       c9 29		      cmp	#SEGTIME_BDF	; 2
    789  4aa9		       90 d5		      bcc	DFS_rts	; 2/3
      0  4aab					      STRESS_TIME	SEGTIME_BDF
      1  4aab				  -	      IF	TEST_SEGTIME_BDF = 1
      2  4aab				  -
      3  4aab				  -
      4  4aab				  -
      5  4aab				  -
      6  4aab				  -
      7  4aab				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  4aab				  -	      bne	. - 7
      9  4aab					      ENDIF
    791  4aab
    792  4aab		       a9 f4		      lda	#>( DrawFlag + RAM_WRITE )	; 2
    793  4aad		       85 db		      sta	BDF_DrawFlagAddress+1	; 3
    794  4aaf		       85 dd		      sta	BDF_DrawFlagAddress2+1	; 3
    795  4ab1
    796  4ab1		       ba		      tsx		; 2
    797  4ab2		       86 e4		      stx	DHS_Stack	; 3
    798  4ab4
    799  4ab4		       e6 89		      inc	ScreenDrawPhase	; 5
    800  4ab6
    801  4ab6		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
    802  4ab7		       a2 08		      ldx	#SCREEN_LINES	; 2
    803  4ab9		       8a		      txa		; 2 = 31
    804  4aba
    805  4aba							; fall through
    806  4aba
    807  4aba							;------------------------------------------------------------------------------
    808  4aba
      0  4aba					      DEFINE_SUBROUTINE	DrawScreenRowPreparation	; = 52[-7]
      1  4aba		       00 09	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  4aba					      SUBROUTINE
      3  4aba				   DrawScreenRowPreparation
    810  4aba
    811  4aba							;clc
    812  4aba		       ca		      dex		; 2
    813  4abb		       86 e3		      stx	DHS_Line	; 3
    814  4abd		       65 96		      adc	BoardScrollY	; 3	     the Y offset of screen into board
    815  4abf		       a8		      tay		; 2 = 10
    816  4ac0
    817  4ac0							;clc
    818  4ac0		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
    819  4ac3		       65 97		      adc	BoardScrollX	; 3	     the X offset of screen into board
    820  4ac5		       85 de		      sta	BDF_BoardAddress	; 3
    821  4ac7		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    822  4ac9		       85 e0		      sta	BDF_BoardAddress2	; 3
    823  4acb
    824  4acb		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
    825  4ace		       85 df		      sta	BDF_BoardAddress+1	; 3
    826  4ad0		       85 e1		      sta	BDF_BoardAddress2+1	; 3 = 25
    827  4ad2
    828  4ad2		       bd c0 f0 	      lda	DrawLineStartLO,x	; 4
    829  4ad5		       85 da		      sta	BDF_DrawFlagAddress	; 3
    830  4ad7		       69 05		      adc	#SCREEN_WIDTH/2	; 2
    831  4ad9		       85 dc		      sta	BDF_DrawFlagAddress2	; 3 = 12
    832  4adb
    833  4adb				  -	      IF	MULTI_BANK_BOARD = YES
    834  4adb				  -	      lda	BoardBank-1,y	; 4
    835  4adb				  -	      sta	BDF_BoardBank	; 3
    836  4adb					      ENDIF
    837  4adb		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
    838  4add		       4c 5a fa 	      jmp	CopyRow2	; 3 = 12[-7]
    839  4ae0
    840  4ae0							;------------------------------------------------------------------------------
    841  4ae0
      0  4ae0					      DEFINE_SUBROUTINE	VectorProcess	;=19(A)
      1  4ae0		       00 09	   BANK_VectorProcess =	_CURRENT_BANK
      2  4ae0					      SUBROUTINE
      3  4ae0				   VectorProcess
    843  4ae0
    844  4ae0							;sta ROM_Bank			  ;3		  processors can assume bank is stored
    845  4ae0
    846  4ae0		       bd ee f2 	      lda	OSPointerHI,x	;4
    847  4ae3		       85 db		      sta	POS_Vector+1	;3
    848  4ae5		       bd ed f2 	      lda	OSPointerLO,x	;4
    849  4ae8		       85 da		      sta	POS_Vector	;3
    850  4aea
    851  4aea		       6c da 00 	      jmp	(POS_Vector)	;5 = 19	 vector to processor for particular object type
    852  4aed							;		 NOTE: Bank is either INITBANK or FIXED.
    853  4aed
    854  4aed
    855  4aed				   OBJTYPE    SET	0
    856  4aed					      MAC	define
    857  4aed				   TYPE_{1}   =	OBJTYPE
    858  4aed				   OBJTYPE    .SET	OBJTYPE + 1
    859  4aed					      ENDM
    860  4aed
    861  4aed							; If adding/removing types, the following must also be updated...
    862  4aed							;   InitialFace[...]		     in UnpackLevel.asm
    863  4aed							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
    864  4aed							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
    865  4aed							;   OSPointerLO[...]		     in BANK_INITBANK.asm
    866  4aed							;   OSPointerHI[...]		     in BANK_INITBANK.asm
    867  4aed							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
    868  4aed							;   Sortable[...]		     in BANK_FIXED.asm
    869  4aed
    870  4aed
      0  4aed					      DEFINE	MAN
      1  4aed		       00 00	   TYPE_MAN   =	OBJTYPE
      2  4aed				   OBJTYPE    .SET	OBJTYPE + 1
    872  4aed							;DEFINE CIRCLE
    873  4aed							;DEFINE CIRCLE_HELPER
    874  4aed							;DEFINE CIRCLE_DRAWER
    875  4aed
      0  4aed					      DEFINE	MAXIMUM
      1  4aed		       00 01	   TYPE_MAXIMUM =	OBJTYPE
      2  4aed				   OBJTYPE    .SET	OBJTYPE + 1
    877  4aed
    878  4aed
      0  4aed					      DEFINE_SUBROUTINE	OSPointerLO
      1  4aed		       00 09	   BANK_OSPointerLO =	_CURRENT_BANK
      2  4aed					      SUBROUTINE
      3  4aed				   OSPointerLO
    880  4aed		       c5		      .byte.b	<PROCESS_MAN
    881  4aee							;.byte <PROCESS_CIRCLE
    882  4aee							;.byte <PROCESS_CIRCLE_HELPER
    883  4aee
    884  4aee				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
    885  4aee				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
    886  4aee				  -	      ERR
    887  4aee					      ENDIF
    888  4aee
    889  4aee
      0  4aee					      DEFINE_SUBROUTINE	OSPointerHI
      1  4aee		       00 09	   BANK_OSPointerHI =	_CURRENT_BANK
      2  4aee					      SUBROUTINE
      3  4aee				   OSPointerHI
    891  4aee		       f8		      .byte.b	>PROCESS_MAN
    892  4aef							;.byte >PROCESS_CIRCLE
    893  4aef							;.byte >PROCESS_CIRCLE_HELPER
    894  4aef
    895  4aef				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
    896  4aef				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
    897  4aef				  -	      ERR
    898  4aef					      ENDIF
    899  4aef
    900  4aef							;------------------------------------------------------------------------------
    901  4aef
      0  4aef					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  4aef		       00 09	   BANK_MoveVecLO =	_CURRENT_BANK
      2  4aef					      SUBROUTINE
      3  4aef				   MoveVecLO
    903  4aef
    904  4aef		       82		      .byte.b	<MOVE_BLANK
    905  4af0		       82		      .byte.b	<MOVE_SOIL
    906  4af1		       cc		      .byte.b	<MOVE_BOX
    907  4af2		       82		      .byte.b	<MOVE_TARGET
    908  4af3		       82		      .byte.b	<MOVE_TARGET
    909  4af4		       c7		      .byte.b	<MOVE_GENERIC	;man occupied
    910  4af5		       c7		      .byte.b	<MOVE_GENERIC	;steel
    911  4af6		       c7		      .byte.b	<MOVE_GENERIC	;wall
    912  4af7		       d7		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
    913  4af8		       c7		      .byte.b	<MOVE_GENERIC	;nogo
    914  4af9
    915  4af9				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
    916  4af9				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
    917  4af9				  -	      ERR
    918  4af9					      ENDIF
    919  4af9
    920  4af9
    921  4af9
      0  4af9					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  4af9		       00 09	   BANK_MoveVecHI =	_CURRENT_BANK
      2  4af9					      SUBROUTINE
      3  4af9				   MoveVecHI
    923  4af9
    924  4af9		       f9		      .byte.b	>MOVE_BLANK
    925  4afa		       f9		      .byte.b	>MOVE_SOIL
    926  4afb		       f9		      .byte.b	>MOVE_BOX
    927  4afc		       f9		      .byte.b	>MOVE_TARGET
    928  4afd		       f9		      .byte.b	>MOVE_TARGET
    929  4afe		       f9		      .byte.b	>MOVE_GENERIC	;man occupied
    930  4aff		       f9		      .byte.b	>MOVE_GENERIC	;steel
    931  4b00		       f9		      .byte.b	>MOVE_GENERIC	;wall
    932  4b01		       f9		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
    933  4b02		       f9		      .byte.b	>MOVE_GENERIC	;nogo
    934  4b03
    935  4b03				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
    936  4b03				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
    937  4b03				  -	      EXIT
    938  4b03					      ENDIF
    939  4b03
    940  4b03
    941  4b03
      0  4b03					      CHECK_BANK_SIZE	"INITBANK"
      1  4b03		       03 03	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $303 , FREE= $4fd
      2  4b03					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  4b03				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  4b03				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  4b03				  -	      ERR
      6  4b03					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_FIXED.asm LEVEL 2 PASS 4
      0  4b03					      include	"BANK_FIXED.asm"
      1  4b03							;    Sokoboo - a Sokoban implementation
      2  4b03							;    using a generic tile-based display engine for the Atari 2600
      3  4b03							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  4b03							;
      5  4b03							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  4b03							;
      7  4b03							;    Code related to the generic tile-based display engine was developed by
      8  4b03							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  4b03							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  4b03							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  4b03							;
     12  4b03							;    Code related to music and sound effects uses the TIATracker music player
     13  4b03							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  4b03							;    directory for Apache licensing details.
     15  4b03							;
     16  4b03							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  4b03							;    See the copyright notices in the License directory for a list of level
     18  4b03							;    contributors.
     19  4b03							;
     20  4b03							;    Except where otherwise indicated, this software is released under the
     21  4b03							;    following licensing arrangement...
     22  4b03							;
     23  4b03							;    This program is free software: you can redistribute it and/or modify
     24  4b03							;    it under the terms of the GNU General Public License as published by
     25  4b03							;    the Free Software Foundation, either version 3 of the License, or
     26  4b03							;    (at your option) any later version.
     27  4b03							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  4b03
     29  4b03							;    This program is distributed in the hope that it will be useful,
     30  4b03							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  4b03							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  4b03							;    GNU General Public License for more details.
     33  4b03
     34  4b03							;------------------------------------------------------------------------------
     35  4b03							;###############################  FIXED BANK  #################################
     36  4b03							;------------------------------------------------------------------------------
     37  4b03
     38  4b03
     39  4b03				   ORIGIN     SET	FIXED_BANK
     40  4b03
      0  4b03					      NEWBANK	THE_FIXED_BANK
      1  7e40 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
     42  7800					      RORG	$f800
     43  7800
     44  7800
     45  7800
     46  7800							;------------------------------------------------------------------------------
     47  7800
      0  7800					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  7800		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  7800					      SUBROUTINE
      3  7800				   DrawTimeFromROM
     49  7800
     50  7800		       a9 09		      lda	#BANK_SCORING
     51  7802		       85 3e		      sta	SET_BANK_RAM
     52  7804							;jsr DrawTime
     53  7804		       20 b4 f2 	      jsr	DrawTargetsRequired
     54  7807		       a5 c4		      lda	ROM_Bank
     55  7809		       85 3f		      sta	SET_BANK
     56  780b		       60		      rts
     57  780c
     58  780c							;------------------------------------------------------------------------------
     59  780c
      0  780c					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  780c		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  780c					      SUBROUTINE
      3  780c				   GetROMByte
     61  780c
     62  780c							; a = ROM bank to retrieve
     63  780c							; y = page index
     64  780c							; ROM_Bank = bank to return to
     65  780c							; (Board_AddressR) = page
     66  780c							; out a = byte from (Board_AddressR)
     67  780c
     68  780c		       85 3f		      sta	SET_BANK	;3
     69  780e		       4c 13 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
     70  7811
     71  7811							;------------------------------------------------------------------------------
     72  7811
      0  7811					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7811		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7811					      SUBROUTINE
      3  7811				   GetBoardCharacter
     74  7811
     75  7811							; call from ROM bank
     76  7811							; switches back to ROM_Bank on exit
     77  7811
     78  7811							; pass A = bank containing character
     79  7811							; Y = x character position
     80  7811							; (Board_AddressR) points to character position
     81  7811							; returns character from board
     82  7811
     83  7811
     84  7811		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
     85  7813
     86  7813				   GetBoardCharacter2		;=17(A)
     87  7813
     88  7813		       b3 c0		      lax	(Board_AddressR),y	;5
     89  7815		       a4 c4		      ldy	ROM_Bank	;3
     90  7817		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
     91  7819		       60		      rts		;6   and go back
     92  781a
     93  781a							;---------------------------------------------------------------------------
     94  781a
      0  781a					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  781a		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  781a					      SUBROUTINE
      3  781a				   PutBoardCharacter
     96  781a
     97  781a		       86 3e		      stx	SET_BANK_RAM	; 3
     98  781c
     99  781c				   PutBoardCharacterSB		; =18
    100  781c		       91 c2		      sta	(Board_AddressW),y	; 6
    101  781e		       a5 c4		      lda	ROM_Bank	; 3
    102  7820		       85 3f		      sta	SET_BANK	; 3
    103  7822		       60		      rts		; 6 = 21
    104  7823
    105  7823							;---------------------------------------------------------------------------
    106  7823
      0  7823					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  7823		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  7823					      SUBROUTINE
      3  7823				   GetBoardCharacter__CALL_FROM_RAM__
    108  7823
    109  7823		       a4 8b		      ldy	POS_Y	;3
    110  7825
    111  7825		       a9 09		      lda	#BANK_GetBoardAddressR	;
    112  7827		       85 3f		      sta	SET_BANK	;
    113  7829		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
    114  782c
    115  782c
    116  782c							;DEFINE_SUBROUTINE PartialGetBoardCharacter ;=23
    117  782c
    118  782c		       85 3e		      sta	SET_BANK_RAM	;3
    119  782e		       a4 8a		      ldy	POS_X	;3
    120  7830		       b3 c0		      lax	(Board_AddressR),y	;5
    121  7832		       a4 c5		      ldy	RAM_Bank	;3
    122  7834		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
    123  7836		       60		      rts		;6		 and go back
    124  7837
    125  7837							;---------------------------------------------------------------------------
    126  7837
      0  7837					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  7837		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  7837					      SUBROUTINE
      3  7837				   PutBoardCharacterFromRAM
    128  7837
    129  7837							; POS_Y  = row
    130  7837							; POS_Type = character to write
    131  7837							; POS_X     = column
    132  7837							; RAM_Bank = caller's bank
    133  7837
    134  7837		       a4 8b		      ldy	POS_Y	;3
    135  7839
    136  7839		       a9 09		      lda	#BANK_GetBoardAddressW	;
    137  783b		       85 3f		      sta	SET_BANK	;
    138  783d		       20 e8 f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
    139  7840
    140  7840		       86 3e		      stx	SET_BANK_RAM	;3
    141  7842
    142  7842		       a4 8a		      ldy	POS_X	;3
    143  7844		       a5 8e		      lda	POS_Type	;3
    144  7846		       91 c2		      sta	(Board_AddressW),y	;6
    145  7848		       a4 c5		      ldy	RAM_Bank	;3
    146  784a		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    147  784c		       60		      rts		;6
    148  784d
    149  784d
    150  784d							;---------------------------------------------------------------------------
    151  784d
      0  784d					      DEFINE_SUBROUTINE	ProcessObjStack	; 15 minimum segtime abort
      1  784d		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  784d					      SUBROUTINE
      3  784d				   ProcessObjStack
    153  784d
    154  784d		       ad 84 02 	      lda	INTIM	;4
    155  7850		       c9 04		      cmp	#MINIMUM_SEGTIME	;2
    156  7852		       90 3b		      bcc	EarlyAbort	;2/3= 8
      0  7854					      STRESS_TIME	MINIMUM_SEGTIME
      1  7854				  -	      IF	TEST_MINIMUM_SEGTIME = 1
      2  7854				  -
      3  7854				  -
      4  7854				  -
      5  7854				  -
      6  7854				  -
      7  7854				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7854				  -	      bne	. - 7
      9  7854					      ENDIF
    158  7854
    159  7854		       a5 85		      lda	ObjStackNum	;3
    160  7856		       49 01		      eor	#1	;2
    161  7858		       aa		      tax		;2
    162  7859
    163  7859		       a5 cd		      lda	ObjIterator	;3
    164  785b		       d5 86		      cmp	ObjStackPtr,x	;5
    165  785d		       b0 2e		      bcs	nextPhase	;2/3
    166  785f
    167  785f
    168  785f							; Process an object...
    169  785f							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    170  785f
    171  785f		       bc 54 f9 	      ldy	BankObjStack,x	;4
    172  7862		       84 3e		      sty	SET_BANK_RAM	;3
    173  7864
    174  7864		       aa		      tax		;2
    175  7865		       bc 80 11 	      ldy	SortedObjPtr,x	;4		 indirect object pointer list (sorted)
    176  7868
    177  7868		       b9 00 10 	      lda	ObjStackX,y	;4
    178  786b		       85 8a		      sta	POS_X	;3
    179  786d		       b9 80 10 	      lda	ObjStackY,y	;4
    180  7870		       85 8b		      sta	POS_Y	;3
    181  7872		       b9 00 11 	      lda	ObjStackVar,y	;4
    182  7875		       85 8f		      sta	POS_VAR	;3
    183  7877		       be 00 12 	      ldx	ObjStackType,y	;4
    184  787a		       86 8e		      stx	POS_Type	;3
    185  787c
    186  787c		       a9 09		      lda	#BANK_VectorProcess	;2
    187  787e		       85 3f		      sta	SET_BANK	;3
    188  7880
    189  7880		       bd ee f2 	      lda	OSPointerHI,x	;4
    190  7883		       85 db		      sta	POS_Vector+1	;3
    191  7885		       bd ed f2 	      lda	OSPointerLO,x	;4
    192  7888		       85 da		      sta	POS_Vector	;3
    193  788a
    194  788a		       6c da 00 	      jmp	(POS_Vector)	;5 = 82	 vector to processor for particular object type
    195  788d
    196  788d
    197  788d							;---------------------------------------------------------------------------
    198  788d							; Now process the blank stack.  This stack holds all the recently blanked squares
    199  788d							; and determines (and moves) BOXs or TARGETs into these squares.  The space vacated
    200  788d							; by these objects are added again to the blank stack.
    201  788d
    202  788d				   nextPhase
    203  788d
    204  788d							;clc
    205  788d							;lda circle_d
    206  788d							;adc #255
    207  788d							;sta circle_d
    208  788d							;bcc nocirc
    209  788d							;nocirc
    210  788d
    211  788d		       e6 89		      inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    212  788f		       60	   EarlyAbort rts		;6
    213  7890
    214  7890							;---------------------------------------------------------------------------
    215  7890
      0  7890					      DEFINE_SUBROUTINE	SwitchObjects	;=72
      1  7890		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  7890					      SUBROUTINE
      3  7890				   SwitchObjects
    217  7890
    218  7890							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    219  7890							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    220  7890							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    221  7890
    222  7890		       ad 84 02 	      lda	INTIM	; 4
    223  7893		       c9 03		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    224  7895		       90 f8		      bcc	EarlyAbort	; 2/3= 8
      0  7897					      STRESS_TIME	SEGTIME_SWITCHOBJECTS
      1  7897				  -	      IF	TEST_SEGTIME_SWITCHOBJECTS = 1
      2  7897				  -
      3  7897				  -
      4  7897				  -
      5  7897				  -
      6  7897				  -
      7  7897				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7897				  -	      bne	. - 7
      9  7897					      ENDIF
    226  7897
    227  7897							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    228  7897							; we're at the throttle cutoff do we switch game-frames.
    229  7897
    230  7897							;sec
    231  7897		       a5 b7		      lda	Throttle	;3
    232  7899		       e9 a0		      sbc	#MAX_THROTTLE	;2
    233  789b		       90 f2		      bcc	EarlyAbort	;2/3		 plenty of time left!
    234  789d
    235  789d							; Time is up. But we may be in a level which requires perfect sorting
    236  789d							; So we check for these levels, and wait for the sort to complete for those.
    237  789d
    238  789d		       24 b6		      bit	levelDisplay	;3
    239  789f		       50 08		      bvc	keepFractional	;2/3		 screen does not require complete sort
    240  78a1
    241  78a1							; We have a level which requires the sort to go to completion
    242  78a1							; Check to see if the sort is finished...
    243  78a1
    244  78a1		       a4 cc		      ldy	sortPtr	;3
    245  78a3		       d0 ea		      bne	EarlyAbort	;2/3		 sort still in progress, so wait
    246  78a5		       a4 cb		      ldy	sortRequired	;3
    247  78a7		       10 e6		      bpl	EarlyAbort	;2/3		 sort still in progress, so wait
    248  78a9
    249  78a9		       85 b7	   keepFractional sta	Throttle	;3		 save fractional 'left over' bit
    250  78ab
    251  78ab							; Pause the game with B/W switch:
    252  78ab
    253  78ab		       a5 80		      lda	gameMode
    254  78ad		       30 14		      bmi	.paused	; pause flag set
    255  78af
    256  78af							; Now that we have completed processing the object stack, we switch
    257  78af							; the stack bank pointers for the next time around.
    258  78af
    259  78af		       a5 85		      lda	ObjStackNum	;3
    260  78b1		       49 01		      eor	#1	;2
    261  78b3		       aa		      tax		;2
    262  78b4		       86 85		      stx	ObjStackNum	;3		 swap stacks @here
    263  78b6
    264  78b6							; STOP the sort so it doesn't corrupt the "other" object stack. Sort may get a look-in immediately after
    265  78b6							; this code is finished, so we don't want it to do something unexpected!
    266  78b6
    267  78b6		       a0 ff		      ldy	#<(-1)	;2
    268  78b8		       84 cb		      sty	sortRequired	;3
    269  78ba		       c8		      iny		;2		 Y==0
    270  78bb		       84 cc		      sty	sortPtr	;3
    271  78bd
    272  78bd							; Initialise the iterator and stack pointer for next time around.
    273  78bd							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    274  78bd							; necessary to initialise both.
    275  78bd
    276  78bd		       84 cd		      sty	ObjIterator	;3		 Y==0
    277  78bf		       94 86		      sty	ObjStackPtr,x	;4
    278  78c1
    279  78c1		       84 89		      sty	ScreenDrawPhase	;3
    280  78c3				   .paused
    281  78c3		       60	   quickExit  rts		;6
    282  78c4
    283  78c4							;---------------------------------------------------------------------------
    284  78c4
    285  78c4				  -	      if	0
    286  78c4				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE_DRAWER
    287  78c4				  -
    288  78c4				  -	      ldy	#CHARACTER_BLANK
    289  78c4				  -	      lda	circle_d+1
    290  78c4				  -			;jsr DrawCircle
    291  78c4				  -			;bcc finCircle
    292  78c4				  -			;lda #TYPE_CIRCLE_DRAWER
    293  78c4				  -			;sta POS_Type
    294  78c4				  -			;jsr InsertObjectStack
    295  78c4				  -finCircle  jmp	NextObject
    296  78c4				  -
    297  78c4				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE_HELPER
    298  78c4				  -
    299  78c4				  -	      lda	INTIM
    300  78c4				  -	      cmp	#SEGTIME_CIRCLE_HELPER
    301  78c4				  -	      bcc	EarlyAbort
    302  78c4				  -
    303  78c4				  -
    304  78c4				  -	      jmp	NextObject	; and die
    305  78c4				  -
    306  78c4				  -
    307  78c4				  -	      DEFINE_SUBROUTINE	PROCESS_CIRCLE
    308  78c4				  -
    309  78c4				  -	      lda	INTIM
    310  78c4				  -	      cmp	#SEGTIME_CIRCLE
    311  78c4				  -	      bcc	EarlyAbort
    312  78c4				  -
    313  78c4				  -	      clc
    314  78c4				  -	      lda	circle_d
    315  78c4				  -	      adc	#255
    316  78c4				  -	      sta	circle_d
    317  78c4				  -	      bcc	inactiveCircle
    318  78c4				  -
    319  78c4				  -	      inc	circle_d+1
    320  78c4				  -	      lda	circle_d+1
    321  78c4				  -	      cmp	#20
    322  78c4				  -	      beq	circleComplete
    323  78c4				  -			; time to fire off another "ring" of the clearing circle
    324  78c4				  -
    325  78c4				  -			;sta POS_VAR		    ; diameter for helper to use
    326  78c4				  -			;lda #TYPE_CIRCLE_HELPER
    327  78c4				  -			;sta POS_Type
    328  78c4				  -			;jsr InsertObjectStack
    329  78c4				  -
    330  78c4				  -
    331  78c4				  -			; a = radius
    332  78c4				  -
    333  78c4				  -	      ldy	#CHARACTER_BLANK
    334  78c4				  -	      sty	circ_char
    335  78c4				  -
    336  78c4				  -	      lda	circle_d+1
    337  78c4				  -	      sec
    338  78c4				  -	      sbc	#1
    339  78c4				  -	      sta	circ_x
    340  78c4				  -	      eor	#255
    341  78c4				  -	      clc
    342  78c4				  -	      adc	#1
    343  78c4				  -	      sta	circ_scratch	; "d" --> "1-r" in unit terms
    344  78c4				  -
    345  78c4				  -	      lda	#0
    346  78c4				  -	      sta	circ_y
    347  78c4				  -
    348  78c4				  -			;lda circle_d+1		     ; radius
    349  78c4				  -			;lda #TYPE_CIRCLE_DRAWER
    350  78c4				  -			;sta POS_Type
    351  78c4				  -			;jsr InsertObjectStack
    352  78c4				  -
    353  78c4				  -	      ldy	#CHARACTER_BLANK
    354  78c4				  -	      lda	circle_d+1
    355  78c4				  -			;	      sec
    356  78c4				  -			;	      sbc #1
    357  78c4				  -	      jsr	DrawCircle
    358  78c4				  -
    359  78c4				  -			;	      ldy #CHARACTER_STEEL
    360  78c4				  -			;		sty circ_char
    361  78c4				  -	      lda	circle_d+1
    362  78c4				  -	      sta	circ_x
    363  78c4				  -	      eor	#255
    364  78c4				  -	      clc
    365  78c4				  -	      adc	#1
    366  78c4				  -	      sta	circ_scratch	; "d" --> "1-r" in unit terms
    367  78c4				  -
    368  78c4				  -	      lda	#0
    369  78c4				  -	      sta	circ_y
    370  78c4				  -
    371  78c4				  -			;lda circle_d+1		     ; radius
    372  78c4				  -			;lda #TYPE_CIRCLE_DRAWER
    373  78c4				  -			;sta POS_Type
    374  78c4				  -			;jsr InsertObjectStack
    375  78c4				  -
    376  78c4				  -			;	      ldy #CHARACTER_BLANK
    377  78c4				  -			;	      lda circle_d+1
    378  78c4				  -			;	      ;jsr DrawCircle
    379  78c4				  -
    380  78c4				  -
    381  78c4				  -
    382  78c4				  -			;			      inc circle_d+1
    383  78c4				  -			;			      ldy #CHARACTER_STEEL
    384  78c4				  -			;			      lda circle_d+1
    385  78c4				  -			;			      jsr DrawCircle
    386  78c4				  -
    387  78c4				  -inactiveCircle lda	#TYPE_CIRCLE
    388  78c4				  -	      sta	POS_Type
    389  78c4				  -	      jsr	InsertObjectStack
    390  78c4				  -
    391  78c4				  -circleComplete jmp	NextObject
    392  78c4					      endif
    393  78c4
    394  78c4							;---------------------------------------------------------------------------
    395  78c4
    396  78c4		       60	   EarlyAbort4 rts
    397  78c5
      0  78c5					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  78c5		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  78c5					      SUBROUTINE
      3  78c5				   PROCESS_MAN
    399  78c5
    400  78c5		       ad 84 02 	      lda	INTIM
    401  78c8		       c9 18		      cmp	#SEGTIME_MAN
    402  78ca		       90 f8		      bcc	EarlyAbort4
      0  78cc					      STRESS_TIME	SEGTIME_MAN
      1  78cc				  -	      IF	TEST_SEGTIME_MAN = 1
      2  78cc				  -
      3  78cc				  -
      4  78cc				  -
      5  78cc				  -
      6  78cc				  -
      7  78cc				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  78cc				  -	      bne	. - 7
      9  78cc					      ENDIF
    404  78cc
    405  78cc		       a9 09		      lda	#BANK_ManProcess
    406  78ce		       85 c4		      sta	ROM_Bank
    407  78d0		       85 3f		      sta	SET_BANK
    408  78d2		       20 85 f1 	      jsr	ManProcess
    409  78d5
    410  78d5		       20 56 f9 	      jsr	MovePlayer	; 6+{}
    411  78d8
    412  78d8		       a5 9f		      lda	ManMode
    413  78da		       c9 07		      cmp	#MANMODE_NEXTLEVEL	; kludge
    414  78dc		       b0 08		      bcs	notComplete
    415  78de		       a5 b9		      lda	targetsRequired
    416  78e0		       d0 04		      bne	notComplete
    417  78e2		       a9 07		      lda	#MANMODE_NEXTLEVEL
    418  78e4		       85 9f		      sta	ManMode
    419  78e6				   notComplete
    420  78e6
    421  78e6
    422  78e6		       a9 03		      lda	#BANK_TrackPlayer	;
    423  78e8		       85 3f		      sta	SET_BANK	;
    424  78ea		       20 35 f4 	      jsr	TrackPlayer	;11+145
    425  78ed
    426  78ed		       a9 00		      lda	#TYPE_MAN	; 2
    427  78ef		       85 8e		      sta	POS_Type	; 3
    428  78f1
    429  78f1		       20 26 f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    430  78f4		       4c 19 f9    gnobj      jmp	NextObject
    431  78f7
    432  78f7							;---------------------------------------------------------------------------
    433  78f7
      0  78f7					      DEFINE_SUBROUTINE	RestoreOriginalCharacter	;=93[-2](A)
      1  78f7		       00 0f	   BANK_RestoreOriginalCharacter =	_CURRENT_BANK
      2  78f7					      SUBROUTINE
      3  78f7				   RestoreOriginalCharacter
    435  78f7
    436  78f7		       a6 8b		      ldx	POS_Y	;3
    437  78f9		       a4 8a		      ldy	POS_X	;3
    438  78fb
    439  78fb		       a9 09		      lda	#BANK_BoardLineStartLO	;2
    440  78fd		       85 3f		      sta	SET_BANK	;3
    441  78ff
    442  78ff		       bd 01 f0 	      lda	BoardLineStartLO,x	;4
    443  7902		       85 c2		      sta	Board_AddressW	;3
    444  7904		       bd 2d f0 	      lda	BoardLineStartHiW,x	;4
    445  7907		       85 c3		      sta	Board_AddressW+1	;3 WRITE address
    446  7909				  -	      IF	MULTI_BANK_BOARD = YES
    447  7909				  -	      lda	BoardBank,x	;4 switch this on return
    448  7909					      ELSE
    449  7909		       a9 0d		      lda	#BANK_BOARD	;2
    450  790b					      ENDIF
    451  790b		       85 3e		      sta	SET_BANK_RAM	;3
    452  790d
    453  790d		       a5 8f		      lda	POS_VAR
    454  790f		       91 c2		      sta	(Board_AddressW),y	;6 clear vacated board position
    455  7911
    456  7911		       a5 c4		      lda	ROM_Bank	;3
    457  7913		       85 3f		      sta	SET_BANK	;3
    458  7915		       60	   EarlyAbortBOX rts		;6
    459  7916
    460  7916
    461  7916							;---------------------------------------------------------------------------
    462  7916
    463  7916							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    464  7916							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    465  7916
    466  7916							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    467  7916
    468  7916							; if the creature dies then jump NextObject
    469  7916
    470  7916
    471  7916		       20 26 f9    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    472  7919
    473  7919		       e6 cd	   NextObject inc	ObjIterator	; 5
    474  791b							;		  dec ObjStackPtr,x		  ; 6
    475  791b		       4c 4d f8 	      jmp	ProcessObjStack	; 3 = 16
    476  791e
    477  791e							;---------------------------------------------------------------------------
    478  791e
      0  791e					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  791e		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  791e					      SUBROUTINE
      3  791e				   InsertObjectStackFromRAM
    480  791e
    481  791e		       20 26 f9 	      jsr	InsertObjectStack	;6+76(B)
    482  7921		       a5 c5		      lda	RAM_Bank	;3
    483  7923		       85 3e		      sta	SET_BANK_RAM	;3
    484  7925
    485  7925		       60	   NotEnoughTime rts		;6
    486  7926
    487  7926							;---------------------------------------------------------------------------
    488  7926
      0  7926					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  7926		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  7926					      SUBROUTINE
      3  7926				   InsertObjectStack
    490  7926							; POS_X     x position
    491  7926							; POS_Y     y position
    492  7926							; POS_VAR   direction or other variable
    493  7926							; POS_Type  type of object
    494  7926
    495  7926		       a6 85		      ldx	ObjStackNum	; 3
    496  7928		       bc 54 f9 	      ldy	BankObjStack,x	; 4
    497  792b		       84 3e		      sty	SET_BANK_RAM	; 3
    498  792d		       b4 86		      ldy	ObjStackPtr,x	; 4 = 14
    499  792f
    500  792f
    501  792f		       a5 8b		      lda	POS_Y	; 3
    502  7931		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    503  7934		       a5 8a		      lda	POS_X	; 3
    504  7936		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    505  7939		       a5 8f		      lda	POS_VAR	; 3
    506  793b		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    507  793e		       a5 8e		      lda	POS_Type	; 3
    508  7940		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    509  7943
    510  7943							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    511  7943							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    512  7943							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    513  7943
    514  7943
    515  7943				  -	      IF	TYPE_MAN != 0
    516  7943				  -	      cmp	#TYPE_MAN	; 2
    517  7943					      ENDIF
    518  7943		       f0 04		      beq	alwaysAllowMan	; 2/3
    519  7945
    520  7945		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    521  7947		       b0 06		      bcs	insertDone	; 2/3= 6    no room -- drop object
    522  7949				   alwaysAllowMan
    523  7949
    524  7949		       98		      tya		; 2
    525  794a		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    526  794d
    527  794d		       f6 86		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    528  794f
    529  794f		       a4 c4	   insertDone ldy	ROM_Bank	; 3
    530  7951		       84 3f		      sty	SET_BANK	; 3
    531  7953
    532  7953				   ManIsDead2
    533  7953
    534  7953
    535  7953
    536  7953		       60		      rts		; 6 = 29
    537  7954
    538  7954							;---------------------------------------------------------------------------
    539  7954
    540  7954		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    541  7956
    542  7956							;---------------------------------------------------------------------------
    543  7956
    544  7956				   MovePlayer
    545  7956		       a5 9f		      lda	ManMode
    546  7958		       c9 02		      cmp	#MANMODE_DEAD
    547  795a		       b0 f7		      bcs	ManIsDead2
    548  795c
    549  795c		       a4 8d		      ldy	POS_Y_NEW
    550  795e
    551  795e		       a9 09		      lda	#BANK_GetBoardAddressRW	;2
    552  7960		       85 3f		      sta	SET_BANK	;3
    553  7962		       85 c4		      sta	ROM_Bank	;3
    554  7964		       20 c8 f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    555  7967				  -	      IF	MULTI_BANK_BOARD = YES
    556  7967				  -	      stx	RAM_Bank
    557  7967					      ENDIF
    558  7967		       86 3e		      stx	SET_BANK_RAM	; 3
    559  7969
    560  7969		       a4 8c		      ldy	POS_X_NEW
    561  796b		       b3 c0		      lax	(Board_AddressR),y
    562  796d
    563  796d		       a9 09		      lda	#BANK_MoveVecLO
    564  796f		       85 3f		      sta	SET_BANK
    565  7971
    566  7971		       bd ef f2 	      lda	MoveVecLO,x
    567  7974		       85 da		      sta	MAN_Move
    568  7976		       bd f9 f2 	      lda	MoveVecHI,x
    569  7979		       85 db		      sta	MAN_Move+1
    570  797b
    571  797b				  -	      IF	MULTI_BANK_BOARD = YES
    572  797b				  -	      lda	RAM_Bank
    573  797b					      ELSE
    574  797b		       a9 0d		      lda	#BANK_BOARD
    575  797d					      ENDIF
    576  797d		       85 3e		      sta	SET_BANK_RAM
    577  797f		       6c da 00 	      jmp	(MAN_Move)
    578  7982
    579  7982							;---------------------------------------------------------------------------
    580  7982
      0  7982					      DEFINE_SUBROUTINE	MOVE_BLANK
      1  7982		       00 0f	   BANK_MOVE_BLANK =	_CURRENT_BANK
      2  7982					      SUBROUTINE
      3  7982				   MOVE_BLANK
      0  7982					      DEFINE_SUBROUTINE	MOVE_SOIL
      1  7982		       00 0f	   BANK_MOVE_SOIL =	_CURRENT_BANK
      2  7982					      SUBROUTINE
      3  7982				   MOVE_SOIL
      0  7982					      DEFINE_SUBROUTINE	MOVE_TARGET
      1  7982		       00 0f	   BANK_MOVE_TARGET =	_CURRENT_BANK
      2  7982					      SUBROUTINE
      3  7982				   MOVE_TARGET
    584  7982
    585  7982		       a4 8c		      ldy	POS_X_NEW
    586  7984		       b1 c0		      lda	(Board_AddressR),y	; what's on the board under man?
    587  7986		       48		      pha
    588  7987
    589  7987		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    590  7989		       91 c2		      sta	(Board_AddressW),y
    591  798b
    592  798b		       a6 9c		      ldx	ManY
    593  798d		       86 8b		      stx	POS_Y
    594  798f		       a4 9b		      ldy	ManX
    595  7991		       84 8a		      sty	POS_X
    596  7993
    597  7993		       20 f7 f8 	      jsr	RestoreOriginalCharacter
    598  7996
    599  7996		       68		      pla
    600  7997		       85 8f		      sta	POS_VAR	; save 'restore' characte
    601  7999
    602  7999		       a9 0e		      lda	#BANK_TAKEBACK
    603  799b		       85 3e		      sta	SET_BANK_RAM
    604  799d
    605  799d		       a6 bc		      ldx	moveCounterBinary
    606  799f
    607  799f		       a5 8c		      lda	POS_X_NEW
    608  79a1		       85 9b		      sta	ManX
    609  79a3		       9d 00 14 	      sta	RAM_WRITE+TakeBackX,x
    610  79a6
    611  79a6		       a5 8d		      lda	POS_Y_NEW
    612  79a8		       85 9c		      sta	ManY	; actually MOVE!
    613  79aa		       9d 00 15 	      sta	RAM_WRITE+TakeBackY,x
    614  79ad
    615  79ad		       a5 8f		      lda	POS_VAR	; replace char
    616  79af		       9d 00 16 	      sta	RAM_WRITE+TakeBackA,x
    617  79b2
    618  79b2		       a5 c5		      lda	RAM_Bank
    619  79b4		       85 3e		      sta	SET_BANK_RAM
    620  79b6
    621  79b6							; Move counter..
    622  79b6
    623  79b6		       e6 bc		      inc	moveCounterBinary
    624  79b8
    625  79b8		       f8		      sed
    626  79b9		       18		      clc
    627  79ba		       a5 ba		      lda	moveCounter
    628  79bc		       69 01		      adc	#1
    629  79be		       85 ba		      sta	moveCounter
    630  79c0		       a5 bb		      lda	moveCounter+1
    631  79c2		       69 00		      adc	#0
    632  79c4		       85 bb		      sta	moveCounter+1
    633  79c6		       d8		      cld
    634  79c7
    635  79c7		       a9 00	   MOVE_GENERIC lda	#0	; 2
    636  79c9		       85 a5		      sta	ManPushCounter	; 3
    637  79cb
    638  79cb		       60	   timeExit   rts		; 6 = 11
    639  79cc
    640  79cc							;---------------------------------------------------------------------------
    641  79cc
      0  79cc					      DEFINE_SUBROUTINE	MOVE_BOX
      1  79cc		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  79cc					      SUBROUTINE
      3  79cc				   MOVE_BOX
    643  79cc
    644  79cc		       a2 00		      ldx	#CHARACTER_BLANK	; restoration character
    645  79ce		       a9 09		      lda	#BANK_PushBox
    646  79d0		       85 c4		      sta	ROM_Bank
    647  79d2		       85 3f		      sta	SET_BANK
    648  79d4		       4c f5 f0 	      jmp	PushBox
    649  79d7
      0  79d7					      DEFINE_SUBROUTINE	MOVE_BOX_ON_TARGET
      1  79d7		       00 0f	   BANK_MOVE_BOX_ON_TARGET =	_CURRENT_BANK
      2  79d7					      SUBROUTINE
      3  79d7				   MOVE_BOX_ON_TARGET
    651  79d7
    652  79d7		       a2 03		      ldx	#CHARACTER_TARGET	; restoration character
    653  79d9		       a9 09		      lda	#BANK_PushBox
    654  79db		       85 c4		      sta	ROM_Bank
    655  79dd		       85 3f		      sta	SET_BANK
    656  79df		       4c f5 f0 	      jmp	PushBox
    657  79e2
    658  79e2							;---------------------------------------------------------------------------
    659  79e2
      0  79e2					      DEFINE_SUBROUTINE	restorePreviousManPosition
      1  79e2		       00 0f	   BANK_restorePreviousManPosition =	_CURRENT_BANK
      2  79e2					      SUBROUTINE
      3  79e2				   restorePreviousManPosition
    661  79e2
    662  79e2		       a6 bc		      ldx	moveCounterBinary
    663  79e4		       f0 21		      beq	noMovesToTake
    664  79e6		       ca		      dex
    665  79e7		       c6 bc		      dec	moveCounterBinary
    666  79e9
    667  79e9		       a9 0e		      lda	#BANK_TAKEBACK
    668  79eb		       85 3e		      sta	SET_BANK_RAM
    669  79ed
    670  79ed		       bd 00 10 	      lda	TakeBackX,x
    671  79f0		       85 8a		      sta	POS_X
    672  79f2		       85 8c		      sta	POS_X_NEW
    673  79f4		       bd 00 11 	      lda	TakeBackY,x
    674  79f7		       85 8b		      sta	POS_Y
    675  79f9		       85 8d		      sta	POS_Y_NEW
    676  79fb		       bd 00 12 	      lda	TakeBackA,x
    677  79fe		       85 8f		      sta	POS_VAR
    678  7a00
    679  7a00							; Put character @ X,Y
    680  7a00		       20 f7 f8 	      jsr	RestoreOriginalCharacter
    681  7a03
    682  7a03		       a5 c4		      lda	ROM_Bank
    683  7a05		       85 3f		      sta	SET_BANK
    684  7a07
    685  7a07		       60	   noMovesToTake rts
    686  7a08
    687  7a08							;---------------------------------------------------------------------------
    688  7a08
      0  7a08					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7a08		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7a08					      SUBROUTINE
      3  7a08				   StealCharDraw
    690  7a08
    691  7a08		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    692  7a0a		       85 3e		      sta	SET_BANK_RAM	; 3
    693  7a0c		       a4 84		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    694  7a0e		       10 35		      bpl	EnterStealCharDraw	; 3 = 10(11)
    695  7a10
    696  7a10				   ExitStealCharDraw
    697  7a10
    698  7a10							; fall through...
    699  7a10
    700  7a10							;---------------------------------------------------------------------------
    701  7a10
      0  7a10					      DEFINE_SUBROUTINE	TimeSlice
      1  7a10		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7a10					      SUBROUTINE
      3  7a10				   TimeSlice
    703  7a10
    704  7a10							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    705  7a10							; going ahead if there's insufficient time. This allows the previous character drawing to
    706  7a10							; be much smaller in time, as they don't have to include the timeslice code overhead.
    707  7a10
    708  7a10		       ad 84 02 	      lda	INTIM	; 4
    709  7a13		       c9 05		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    710  7a15		       90 b4		      bcc	timeExit	; 2(3)
    711  7a17
    712  7a17							; Uses the phase variable to vector to the correct processing code for the given timeslice
    713  7a17							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    714  7a17							; it should increment ScreenDrawPhase.
    715  7a17
    716  7a17							; Switched-in bank(s) are undefined after this function is called!
    717  7a17
    718  7a17		       a9 03		      lda	#BANK_TS_PhaseVectorLO	; 2
    719  7a19		       85 3f		      sta	SET_BANK	; 3
    720  7a1b
    721  7a1b		       a6 89		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    722  7a1d		       bd bc f4 	      lda	TS_PhaseVectorLO,x	; 4
    723  7a20		       85 da		      sta	TS_Vector	; 3
    724  7a22		       bd c1 f4 	      lda	TS_PhaseVectorHI,x	; 4
    725  7a25		       85 db		      sta	TS_Vector+1	; 3
    726  7a27
    727  7a27		       bd c6 f4 	      lda	TS_PhaseBank,x	; 4
    728  7a2a		       85 3f		      sta	SET_BANK	; 3		 switch bank
    729  7a2c
    730  7a2c		       6c da 00 	      jmp	(TS_Vector)	; 3 = 40	 vector to timeslice handler
    731  7a2f
    732  7a2f							; = 55 minimum return time (if segtime abort)
    733  7a2f
    734  7a2f							;---------------------------------------------------------------------------
    735  7a2f
    736  7a2f
    737  7a2f				   DrawAnother
    738  7a2f
    739  7a2f		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    740  7a31		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    741  7a33
    742  7a33		       a4 84		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    743  7a35
    744  7a35		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    745  7a38		       bd a0 f0 	      lda	ScreenBuffer,x	; 4	     new character to draw
    746  7a3b		       29 7f		      and	#~128	; 2
    747  7a3d		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    748  7a40
    749  7a40		       88		      dey		; 2
    750  7a41		       84 84		      sty	DrawStackPointer	; 3	     one less to draw
    751  7a43		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7
    752  7a45
    753  7a45				   EnterStealCharDraw		;	     RAM bank MUST be at BANK_DRAW_BUFFERS
    754  7a45
    755  7a45		       ad 84 02 	      lda	INTIM	; 4
    756  7a48		       c9 05		      cmp	#SEGTIME_SCD_MIN	; 2
    757  7a4a		       90 c4		      bcc	ExitStealCharDraw	; 2/3= 8
    758  7a4c
    759  7a4c		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    760  7a4f		       bc a0 f0 	      ldy	ScreenBuffer,x	; 4 =	8    new character to draw
    761  7a52
    762  7a52		       bd 00 f2 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
    763  7a55		       85 3e		      sta	SET_BANK_RAM	; 3
    764  7a57		       4c 53 f1 	      jmp	StealPart3	; 3 = 10    --> 18 cycles after check for SEGTIME_SCD_MIN
    765  7a5a
    766  7a5a
    767  7a5a
    768  7a5a
      0  7a5a					      DEFINE_SUBROUTINE	DrawFullScreenMain	;=2484[-89]
      1  7a5a		       00 0f	   BANK_DrawFullScreenMain =	_CURRENT_BANK
      2  7a5a					      SUBROUTINE
      3  7a5a				   DrawFullScreenMain
    770  7a5a
    771  7a5a							; Check the screen for all those characters that need to be redrawn
    772  7a5a							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
    773  7a5a							; the drawflags array is different to the ScreenBuffer array entry, then the
    774  7a5a							; screenbuffer will need redrawing.
    775  7a5a
    776  7a5a				   CopyRow2
    777  7a5a
    778  7a5a				  -	      IF	MULTI_BANK_BOARD = YES
    779  7a5a				  -	      lda	BDF_BoardBank	; 3
    780  7a5a					      ELSE
    781  7a5a		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
    782  7a5c					      ENDIF
    783  7a5c		       85 3e		      sta	SET_BANK_RAM	; 3
    784  7a5e		       b3 de		      lax	(BDF_BoardAddress),y	; 5
    785  7a60		       9a		      txs		; 2
    786  7a61		       b3 e0		      lax	(BDF_BoardAddress2),y	; 5(= 18[-1])
    787  7a63
    788  7a63		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    789  7a65		       85 3e		      sta	SET_BANK_RAM	; 3
    790  7a67		       bd cd f1 	      lda	CharReplacement,x	; 4
    791  7a6a		       91 dc		      sta	(BDF_DrawFlagAddress2),y	; 6
    792  7a6c		       ba		      tsx		; 2
    793  7a6d		       bd cd f1 	      lda	CharReplacement,x	; 4
    794  7a70		       91 da		      sta	(BDF_DrawFlagAddress),y	; 6(= 27)
    795  7a72
    796  7a72		       88		      dey		; 2
    797  7a73		       10 e5		      bpl	CopyRow2	; 2/3=49/50[-1]
    798  7a75							; total: 5*49[-1]-1 = 244[-5]
    799  7a75
    800  7a75		       a7 e3		      lax	DHS_Line	; 3
    801  7a77		       f0 07		      beq	.exitCopy	; 2/3= 5/6
    802  7a79
    803  7a79		       a0 09		      ldy	#BANK_DrawScreenRowPreparation	;2
    804  7a7b		       84 3f		      sty	SET_BANK	; 3
    805  7a7d		       4c ba f2 	      jmp	DrawScreenRowPreparation	;55[-7] = 60[-7]
    806  7a80
    807  7a80							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
    808  7a80
    809  7a80
      0  7a80					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7a80					      LIST	ON
    811  7a80
    812  7a80		       a6 e4	   .exitCopy  ldx	DHS_Stack	; 3
    813  7a82		       9a		      txs		; 2
    814  7a83
    815  7a83							; fall through
    816  7a83
      0  7a83					      DEFINE_SUBROUTINE	BuildDrawStack
      1  7a83		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7a83					      SUBROUTINE
      3  7a83				   BuildDrawStack
    818  7a83
    819  7a83		       a9 08		      lda	#BANK_DRAW_BUFFERS
    820  7a85		       85 3e		      sta	SET_BANK_RAM
    821  7a87		       4c f1 f0 	      jmp	DrawStackUpdate
    822  7a8a
    823  7a8a							;---------------------------------------------------------------------------
    824  7a8a
      0  7a8a					      DEFINE_SUBROUTINE	DrawAIntoStack
      1  7a8a		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7a8a					      SUBROUTINE
      3  7a8a				   DrawAIntoStack
    826  7a8a
    827  7a8a		       a9 08		      lda	#BANK_DRAW_BUFFERS
    828  7a8c		       85 3e		      sta	SET_BANK_RAM
    829  7a8e		       4c 1a f1 	      jmp	DrawIntoStack
    830  7a91
    831  7a91
    832  7a91							;---------------------------------------------------------------------------
    833  7a91
    834  7a91
    835  7a91				   Reset
      0  7a91					      CLEAN_START
      1  7a91		       78		      sei
      2  7a92		       d8		      cld
      3  7a93
      4  7a93		       a2 00		      ldx	#0
      5  7a95		       8a		      txa
      6  7a96		       a8		      tay
      7  7a97		       ca	   .CLEAR_STACK dex
      8  7a98		       9a		      txs
      9  7a99		       48		      pha
     10  7a9a		       d0 fb		      bne	.CLEAR_STACK
     11  7a9c
    837  7a9c
    838  7a9c							; Scoring bank is copied once (not per game, not per level...)
    839  7a9c							; otherwise non-SaveKey high score gets zapped
    840  7a9c
    841  7a9c		       a2 02		      ldx	#ROM_SHADOW_OF_BANK_SCORING
    842  7a9e		       a0 09		      ldy	#BANK_SCORING
    843  7aa0		       20 80 fc 	      jsr	CopyROM2RAM_F000
    844  7aa3
    845  7aa3				   Restart		; go here on RESET + SELECT
    846  7aa3
    847  7aa3
    848  7aa3				   Title
    849  7aa3		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
    850  7aa5		       9a		      txs
    851  7aa6
    852  7aa6							; temporary vars from title screen are used to init level
    853  7aa6		       a9 03		      lda	#BANK_Cart_Init	; 2
    854  7aa8		       85 3f		      sta	SET_BANK	; 3
    855  7aaa		       20 40 f3 	      jsr	Cart_Init	; 6+x
    856  7aad
    857  7aad
    858  7aad							;---------------------------------------------------------------------------
    859  7aad
    860  7aad
    861  7aad		       f0 00	   SEGMENT_DECODE_LEVEL_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
    862  7aad
    863  7aad		       a2 03		      ldx	#BANK_DECODE_LEVEL_SHADOW
    864  7aaf		       a0 0a		      ldy	#BANK_DECODE_LEVEL
    865  7ab1		       20 80 fc 	      jsr	CopyROM2RAM_F000
    866  7ab4
    867  7ab4
    868  7ab4							;---------------------------------------------------------------------------
    869  7ab4							; Once-only game initialisation goes here...
    870  7ab4							; now we have two players so things get a bit tricky
    871  7ab4
    872  7ab4		       a9 09		      lda	#BANK_SCORING
    873  7ab6		       85 3e		      sta	SET_BANK_RAM
    874  7ab8		       20 63 f3 	      jsr	GameInitialise
    875  7abb
    876  7abb
    877  7abb							;---------------------------------------------------------------------------
    878  7abb
------- FILE sound/intro1_init.asm LEVEL 3 PASS 4
      0  7abb					      include	"sound/intro1_init.asm"
      1  7abb							; TIATracker music player
      2  7abb							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7abb							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7abb							; Email: andre.wichmann@gmx.de
      5  7abb							;
      6  7abb							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7abb							; you may not use this file except in compliance with the License.
      8  7abb							; You may obtain a copy of the License at
      9  7abb							;
     10  7abb							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7abb							;
     12  7abb							; Unless required by applicable law or agreed to in writing, software
     13  7abb							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7abb							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7abb							; See the License for the specific language governing permissions and
     16  7abb							; limitations under the License.
     17  7abb
     18  7abb							; Song author: 
     19  7abb							; Song name: 
     20  7abb
     21  7abb							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7abb
     23  7abb							; =====================================================================
     24  7abb							; Initialize music.
     25  7abb							; Set tt_cur_pat_index_c0/1 to the indexes of the first patterns from
     26  7abb							; tt_SequenceTable for each channel.
     27  7abb							; Set tt_timer and tt_cur_note_index_c0/1 to 0.
     28  7abb							; All other variables can start with any value.
     29  7abb							; =====================================================================
     30  7abb		       a9 00		      lda	#0
     31  7abd		       85 d0		      sta	tt_cur_pat_index_c0
     32  7abf		       a9 05		      lda	#5
     33  7ac1		       85 d1		      sta	tt_cur_pat_index_c1
     34  7ac3							; the rest should be 0 already from startup code. If not,
     35  7ac3							; set the following variables to 0 manually:
     36  7ac3							; - tt_timer
     37  7ac3							; - tt_cur_pat_index_c0
     38  7ac3							; - tt_cur_pat_index_c1
     39  7ac3							; - tt_cur_note_index_c0
     40  7ac3							; - tt_cur_note_index_c1
     41  7ac3
------- FILE BANK_FIXED.asm
    880  7ac3
    881  7ac3		       a9 08		      lda	#BANK_TitleScreen
    882  7ac5		       85 3f		      sta	SET_BANK
    883  7ac7		       20 00 f0 	      jsr	TitleSequence
    884  7aca
    885  7aca				   RestartLevelNextPlayer
    886  7aca
    887  7aca
    888  7aca							; a player has lost a life.
    889  7aca							; store his vars, swap to other player, continue
    890  7aca
    891  7aca							;lda #BANK_SCORING
    892  7aca							;sta SET_BANK_RAM
    893  7aca							;jsr SwapPlayers
    894  7aca
    895  7aca		       a9 03		      lda	#BANK_SwapPlayersGeneric
    896  7acc		       85 3f		      sta	SET_BANK
    897  7ace		       20 97 f3 	      jsr	SwapPlayersGeneric
    898  7ad1
    899  7ad1				   NextLevelLevel
    900  7ad1				   skipDemoCheck
    901  7ad1
    902  7ad1							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
    903  7ad1							; including those for general systems function. But NOT those which do not need re-initialising between
    904  7ad1							; levels.
    905  7ad1		       a9 03		      lda	#BANK_LevelInit	; 2
    906  7ad3		       85 3f		      sta	SET_BANK	; 3
    907  7ad5		       20 e6 f3 	      jsr	LevelInit	; 6+x
    908  7ad8
    909  7ad8		       a9 00		      lda	#0
    910  7ada		       85 da		      sta	base_x
    911  7adc		       85 db		      sta	base_y
    912  7ade
    913  7ade		       a9 0a		      lda	#BANK_DECODE_LEVEL
    914  7ae0		       85 3e		      sta	SET_BANK_RAM
    915  7ae2		       20 c3 f1 	      jsr	UnpackLevel
    916  7ae5
    917  7ae5							; TODO now we KNOW the width, we can set the top left accordingly and re-unpack
    918  7ae5
    919  7ae5		       a9 28		      lda	#SIZE_BOARD_X
    920  7ae7		       85 94		      sta	BoardLimit_Width
    921  7ae9		       a9 16		      lda	#SIZE_BOARD_Y
    922  7aeb		       85 95		      sta	BoardLimit_Height
    923  7aed
    924  7aed							; Setup player animation and scroll limits.
    925  7aed							; Mangle the board colours based on level
    926  7aed
    927  7aed		       a9 03		      lda	#BANK_CreateCreatures	; 2
    928  7aef		       85 3f		      sta	SET_BANK	; 3
    929  7af1		       20 af f3 	      jsr	CreateCreatures	; 6+x
    930  7af4
    931  7af4							; Setup the various digit and display pointers
    932  7af4							; Grab current player's score/level from backup
    933  7af4
    934  7af4		       a9 09		      lda	#BANK_SCORING
    935  7af6		       85 3e		      sta	SET_BANK_RAM
    936  7af8		       20 8f f2 	      jsr	GeneralScoringSetups
    937  7afb							;lda ROM_Bank
    938  7afb							;sta SET_BANK
    939  7afb
    940  7afb							; copy the screen draw ROM shadow to RAM
    941  7afb
    942  7afb		       a0 07		      ldy	#SCREEN_LINES-1
    943  7afd		       a2 00	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
    944  7aff		       20 80 fc 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
    945  7b02		       20 77 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
    946  7b05		       88		      dey
    947  7b06		       10 f5		      bpl	CopyScreenBanks
    948  7b08
    949  7b08		       a2 01		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    950  7b0a		       a0 08		      ldy	#BANK_DRAW_BUFFERS
    951  7b0c		       20 43 f0 	      jsr	CopyROMShadowToRAM_F000
    952  7b0f
    953  7b0f							;---------------------------------------------------------------------------
    954  7b0f
    955  7b0f		       a9 03		      lda	#BANK_Resync	; 2
    956  7b11		       85 3f		      sta	SET_BANK	; 3
    957  7b13		       20 11 f4 	      jsr	Resync	; 6+x
    958  7b16
    959  7b16
    960  7b16
    961  7b16				   NewFrameStart
    962  7b16
    963  7b16		       24 ca		      bit	NextLevelTrigger
    964  7b18		       10 b7		      bpl	NextLevelLevel	; game-triggered next level
    965  7b1a		       70 ae		      bvs	RestartLevelNextPlayer	; loss of life
    966  7b1c
    967  7b1c							; Note: VSYNC must NOT be on when starting a new level! Else you get annoying TV signals.
    968  7b1c
    969  7b1c		       a9 0e		      lda	#%1110	; VSYNC ON
    970  7b1e		       85 42	   .loopVSync sta	WSYNC
    971  7b20		       85 40		      sta	VSYNC
    972  7b22		       4a		      lsr
    973  7b23		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
    974  7b25
    975  7b25							; moved *after* the loop since this allows to *increase* timer values by 1!
    976  7b25
    977  7b25		       a6 81		      ldx	Platform
    978  7b27		       bc 4d fc 	      ldy	VBlankTime,x
    979  7b2a		       8c 96 02 	      sty	TIM64T
    980  7b2d
    981  7b2d
------- FILE sound/intro1_player.asm LEVEL 3 PASS 4
      0  7b2d					      include	"sound/intro1_player.asm"
      1  7b2d							; TIATracker music player
      2  7b2d							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7b2d							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7b2d							; Email: andre.wichmann@gmx.de
      5  7b2d							;
      6  7b2d							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7b2d							; you may not use this file except in compliance with the License.
      8  7b2d							; You may obtain a copy of the License at
      9  7b2d							;
     10  7b2d							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7b2d							;
     12  7b2d							; Unless required by applicable law or agreed to in writing, software
     13  7b2d							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7b2d							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7b2d							; See the License for the specific language governing permissions and
     16  7b2d							; limitations under the License.
     17  7b2d
     18  7b2d							; Song author: 
     19  7b2d							; Song name: 
     20  7b2d
     21  7b2d							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7b2d
     23  7b2d							; =====================================================================
     24  7b2d							; TIATracker Player
     25  7b2d							; =====================================================================
     26  7b2d				   tt_PlayerStart
     27  7b2d
     28  7b2d							; PLANNED PLAYER VARIANTS:
     29  7b2d							; - RAM, speed, player ROM: c0/c1 patterns have same length
     30  7b2d							; - RAM: Pack 2 values (out of cur_pat_index, cur_note_index, envelope_index)
     31  7b2d							;	 into one and use lsr/asl to unpack them, allowing only ranges of
     32  7b2d							;	 16/16 or 32/8 for them, depending on number of patterns, max
     33  7b2d							;	 pattern size and max ADSR size
     34  7b2d							; - ROM: Check if tt_SequenceTable can hold ptrs directly without indexing
     35  7b2d							;	 tt_PatternPtrLo/Hi. Can be smaller if not many patterns get repeated
     36  7b2d							;	 (saves table and decode routine)
     37  7b2d							; - Speed: Inline tt_CalcInsIndex
     38  7b2d							; - Speed: Store ptr to current note in RAM instead of reconstructing it?
     39  7b2d							;	 Might also save the need for cur_note_index
     40  7b2d
     41  7b2d
     42  7b2d							; ---------------------------------------------------------------------
     43  7b2d							; Helper macro: Retrieves current note. May advance pattern if needed.
     44  7b2d							; Becomes a subroutine if TT_USE_OVERLAY is used.
     45  7b2d							; ---------------------------------------------------------------------
     46  7b2d					      MAC	tt_fetch_current_note
     47  7b2d							; construct ptr to pattern
     48  7b2d				   .constructPatPtr
     49  7b2d					      ldy	tt_cur_pat_index_c0,x	; get current pattern (index into tt_SequenceTable)
     50  7b2d					      lda	tt_SequenceTable,y
     51  7b2d					      IF	TT_USE_GOTO = 1
     52  7b2d					      bpl	.noPatternGoto
     53  7b2d					      and	#%01111111	; mask out goto bit to get pattern number
     54  7b2d					      sta	tt_cur_pat_index_c0,x	; store goto'ed pattern index
     55  7b2d					      bpl	.constructPatPtr	; unconditional
     56  7b2d				   .noPatternGoto
     57  7b2d					      ENDIF
     58  7b2d					      tay
     59  7b2d					      lda	tt_PatternPtrLo,y
     60  7b2d					      sta	tt_ptr
     61  7b2d					      lda	tt_PatternPtrHi,y
     62  7b2d					      sta	tt_ptr+1
     63  7b2d							; get new note
     64  7b2d					      IF	TT_USE_OVERLAY = 0
     65  7b2d					      ldy	tt_cur_note_index_c0,x
     66  7b2d					      ELSE
     67  7b2d							; If the V flag is set and if the new note is an instrument,
     68  7b2d							; it means it got pre-fetched by an overlay percussion, it has
     69  7b2d							; to remain in sustain.
     70  7b2d					      clv
     71  7b2d							; check if note had been pre-fetched by overlay perc already
     72  7b2d					      lda	tt_cur_note_index_c0,x
     73  7b2d					      bpl	.notPrefetched
     74  7b2d							; If so, remove flag
     75  7b2d					      and	#%01111111
     76  7b2d					      sta	tt_cur_note_index_c0,x
     77  7b2d							; Set V flag for later
     78  7b2d					      bit	tt_Bit6Set
     79  7b2d				   .notPrefetched
     80  7b2d					      tay
     81  7b2d					      ENDIF
     82  7b2d					      lda	(tt_ptr),y
     83  7b2d							; pre-process new note
     84  7b2d							; 7..5: instrument (1..7), 4..0 (0..31): frequency
     85  7b2d							; 0/0: End of pattern
     86  7b2d					      bne	.noEndOfPattern
     87  7b2d							; End of pattern: Advance to next pattern
     88  7b2d					      sta	tt_cur_note_index_c0,x	; a is 0
     89  7b2d					      inc	tt_cur_pat_index_c0,x
     90  7b2d					      bne	.constructPatPtr	; unconditional
     91  7b2d				   .noEndOfPattern
     92  7b2d					      ENDM
     93  7b2d
     94  7b2d
     95  7b2d							; ---------------------------------------------------------------------
     96  7b2d							; Music player entry. Call once per frame.
     97  7b2d							; ---------------------------------------------------------------------
     98  7b2d				   tt_Player  SUBROUTINE
     99  7b2d							; ==================== Sequencer ====================
    100  7b2d							; Decrease speed timer
    101  7b2d		       c6 cf		      dec	tt_timer
    102  7b2f		       10 6e		      bpl	.noNewNote
    103  7b31
    104  7b31							; Timer ran out: Do sequencer
    105  7b31							; Advance to next note
    106  7b31		       a2 01		      ldx	#1	; 2 channels
    107  7b33				   .advanceLoop
    108  7b33					      IF	TT_USE_OVERLAY = 1
    109  7b33		       20 49 fb 	      jsr	tt_FetchNote
    110  7b36				  -	      ELSE
    111  7b36				  -	      TT_FETCH_CURRENT_NOTE
    112  7b36					      ENDIF
    113  7b36							; Parse new note from pattern
    114  7b36		       c9 10		      cmp	#TT_INS_PAUSE
    115  7b38					      IF	TT_USE_SLIDE = 0
    116  7b38		       90 55		      bcc	.finishedNewNote
    117  7b3a		       d0 3d		      bne	.newNote
    118  7b3c				  -	      ELSE
    119  7b3c				  -	      beq	.pause
    120  7b3c				  -	      bcs	.newNote
    121  7b3c				  -
    122  7b3c				  -			; --- slide/hold ---
    123  7b3c				  -			; Adjust frequency and hold note in sustain.
    124  7b3c				  -			; composer/tracker has to make sure that no unwanted
    125  7b3c				  -			; under/overflow happens.
    126  7b3c				  -			; Note: f = f + (8-(16-x)) = x + f - 8
    127  7b3c				  -	      adc	tt_cur_ins_c0,x	; carry is clear after cmp
    128  7b3c				  -	      sec
    129  7b3c				  -	      sbc	#8
    130  7b3c				  -	      sta	tt_cur_ins_c0,x
    131  7b3c				  -	      bcs	.finishedNewNote	; unconditional, since legally no underflow can happen (ins>0 or HOLD for ins=0)
    132  7b3c					      ENDIF
    133  7b3c
    134  7b3c							; --- pause ---
    135  7b3c				   .pause
    136  7b3c							; Get release index for current instrument. Since a pause can
    137  7b3c							; only follow an instrument, we don't need to handle percussion
    138  7b3c							; or commands.
    139  7b3c		       b5 d6		      lda	tt_cur_ins_c0,x
    140  7b3e		       20 d7 fb 	      jsr	tt_CalcInsIndex
    141  7b41		       b9 23 fd 	      lda	tt_InsReleaseIndexes-1,y	; -1 b/c instruments start at #1
    142  7b44							; Put it into release. Skip junk byte so index no longer indicates
    143  7b44							; sustain phase.
    144  7b44		       18		      clc
    145  7b45		       69 01		      adc	#1
    146  7b47		       90 44		      bcc	.storeADIndex	; unconditional
    147  7b49
    148  7b49							; ---------------------------------------------------------------------
    149  7b49							; Helper subroutine to minimize ROM footprint. Will be inlined if
    150  7b49							; TT_USE_OVERLAY is not used.
    151  7b49							; Interleaved here so player can be inlined.
    152  7b49							; ---------------------------------------------------------------------
    153  7b49					      IF	TT_USE_OVERLAY = 1
    154  7b49				   tt_FetchNote
      0  7b49					      TT_FETCH_CURRENT_NOTE
      1  7b49
      2  7b49				   .constructPatPtr
      3  7b49		       b4 d0		      ldy	tt_cur_pat_index_c0,x
      4  7b4b		       b9 36 fe 	      lda	tt_SequenceTable,y
      5  7b4e					      IF	TT_USE_GOTO = 1
      6  7b4e		       10 06		      bpl	.noPatternGoto
      7  7b50		       29 7f		      and	#%01111111
      8  7b52		       95 d0		      sta	tt_cur_pat_index_c0,x
      9  7b54		       10 f3		      bpl	.constructPatPtr
     10  7b56				   .noPatternGoto
     11  7b56					      ENDIF
     12  7b56		       a8		      tay
     13  7b57		       b9 2c fe 	      lda	tt_PatternPtrLo,y
     14  7b5a		       85 d8		      sta	tt_ptr
     15  7b5c		       b9 31 fe 	      lda	tt_PatternPtrHi,y
     16  7b5f		       85 d9		      sta	tt_ptr+1
     17  7b61
     18  7b61				  -	      IF	TT_USE_OVERLAY = 0
     19  7b61				  -	      ldy	tt_cur_note_index_c0,x
     20  7b61					      ELSE
     21  7b61
     22  7b61
     23  7b61
     24  7b61		       b8		      clv
     25  7b62
     26  7b62		       b5 d2		      lda	tt_cur_note_index_c0,x
     27  7b64		       10 07		      bpl	.notPrefetched
     28  7b66
     29  7b66		       29 7f		      and	#%01111111
     30  7b68		       95 d2		      sta	tt_cur_note_index_c0,x
     31  7b6a
     32  7b6a		       2c dd fb 	      bit	tt_Bit6Set
     33  7b6d				   .notPrefetched
     34  7b6d		       a8		      tay
     35  7b6e					      ENDIF
     36  7b6e		       b1 d8		      lda	(tt_ptr),y
     37  7b70
     38  7b70
     39  7b70
     40  7b70		       d0 06		      bne	.noEndOfPattern
     41  7b72
     42  7b72		       95 d2		      sta	tt_cur_note_index_c0,x
     43  7b74		       f6 d0		      inc	tt_cur_pat_index_c0,x
     44  7b76		       d0 d1		      bne	.constructPatPtr
     45  7b78				   .noEndOfPattern
    156  7b78		       60		      rts
    157  7b79					      ENDIF
    158  7b79
    159  7b79
    160  7b79							; --- start instrument or percussion ---
    161  7b79				   .newNote
    162  7b79		       95 d6		      sta	tt_cur_ins_c0,x	; set new instrument
    163  7b7b							; Instrument or percussion?
    164  7b7b		       c9 20		      cmp	#TT_FREQ_MASK+1
    165  7b7d		       b0 06		      bcs	.startInstrument
    166  7b7f
    167  7b7f							; --- start percussion ---
    168  7b7f							; Get index of envelope
    169  7b7f		       a8		      tay
    170  7b80							; -TT_FIRST_PERC because percussion start with TT_FIRST_PERC
    171  7b80		       b9 47 fd 	      lda	tt_PercIndexes-TT_FIRST_PERC,y
    172  7b83		       d0 08		      bne	.storeADIndex	; unconditional, since index values are >0
    173  7b85
    174  7b85							; --- start instrument ---
    175  7b85				   .startInstrument
    176  7b85					      IF	TT_USE_OVERLAY = 1
    177  7b85							; If V flag is set, this note had been pre-fetched. That means
    178  7b85							; it should remain in sustain.
    179  7b85		       70 08		      bvs	.finishedNewNote
    180  7b87					      ENDIF
    181  7b87							; Put note into attack/decay
    182  7b87		       20 d7 fb 	      jsr	tt_CalcInsIndex
    183  7b8a		       b9 19 fd 	      lda	tt_InsADIndexes-1,y	; -1 because instruments start at #1
    184  7b8d				   .storeADIndex
    185  7b8d		       95 d4		      sta	tt_envelope_index_c0,x
    186  7b8f
    187  7b8f							; --- Finished parsing new note ---
    188  7b8f				   .finishedNewNote
    189  7b8f							; increase note index into pattern
    190  7b8f		       f6 d2		      inc	tt_cur_note_index_c0,x
    191  7b91							; loop over channels
    192  7b91				   .sequencerNextChannel
    193  7b91		       ca		      dex
    194  7b92		       10 9f		      bpl	.advanceLoop
    195  7b94
    196  7b94							; Reset timer value
    197  7b94				  -	      IF	TT_GLOBAL_SPEED = 0
    198  7b94				  -			; Get timer value for current pattern in channel 0
    199  7b94				  -	      ldx	tt_cur_pat_index_c0	; get current pattern (index into tt_SequenceTable)
    200  7b94				  -	      ldy	tt_SequenceTable,x	; Current pattern index now in y
    201  7b94				  -	      IF	TT_USE_FUNKTEMPO = 0
    202  7b94				  -	      lda	tt_PatternSpeeds,y
    203  7b94				  -	      sta	tt_timer
    204  7b94				  -	      ELSE
    205  7b94				  -			; Test for odd/even frame
    206  7b94				  -	      lda	tt_cur_note_index_c0
    207  7b94				  -	      lsr
    208  7b94				  -	      lda	tt_PatternSpeeds,y	; does not affect carry flag
    209  7b94				  -	      bcc	.evenFrame
    210  7b94				  -	      and	#$0f	; does not affect carry flag
    211  7b94				  -	      bcs	.storeFunkTempo
    212  7b94				  -.evenFrame
    213  7b94				  -	      lsr
    214  7b94				  -	      lsr
    215  7b94				  -	      lsr
    216  7b94				  -	      lsr
    217  7b94				  -.storeFunkTempo
    218  7b94				  -	      sta	tt_timer
    219  7b94				  -	      ENDIF		; TT_USE_FUNKTEMPO = 0
    220  7b94				  -
    221  7b94					      ELSE
    222  7b94							; Global tempo
    223  7b94		       a2 04		      ldx	#TT_SPEED-1
    224  7b96					      IF	TT_USE_FUNKTEMPO = 1
    225  7b96		       a5 d2		      lda	tt_cur_note_index_c0
    226  7b98		       4a		      lsr
    227  7b99		       90 02		      bcc	.noOddFrame
    228  7b9b		       a2 03		      ldx	#TT_ODD_SPEED-1
    229  7b9d				   .noOddFrame
    230  7b9d					      ENDIF		; TT_USE_FUNKTEMPO = 1
    231  7b9d		       86 cf		      stx	tt_timer
    232  7b9f					      ENDIF		; TT_GLOBAL_SPEED = 0
    233  7b9f
    234  7b9f							; No new note to process
    235  7b9f				   .noNewNote
    236  7b9f
    237  7b9f							; ==================== Update registers ====================
    238  7b9f		       a2 01		      ldx	#1	; 2 channels
    239  7ba1				   .updateLoop
    240  7ba1							; Percussion or melodic instrument?
    241  7ba1		       b5 d6		      lda	tt_cur_ins_c0,x
    242  7ba3				  -	      IF	TT_STARTS_WITH_NOTES = 0
    243  7ba3				  -			; This branch can be removed if track starts with a note in each channel
    244  7ba3				  -	      beq	.afterAudioUpdate
    245  7ba3					      ENDIF
    246  7ba3		       c9 20		      cmp	#TT_FREQ_MASK+1
    247  7ba5		       b0 37		      bcs	.instrument	; Melodic instrument
    248  7ba7
    249  7ba7							; --- Percussion: Get envelope index ---
    250  7ba7		       b4 d4		      ldy	tt_envelope_index_c0,x
    251  7ba9							; Set AUDC and AUDV value from envelope
    252  7ba9		       b9 70 fd 	      lda	tt_PercCtrlVolTable-1,y	; -1 because values are stored +1
    253  7bac		       f0 02		      beq	.endOfPercussion	; 0 means end of percussion data
    254  7bae		       f6 d4		      inc	tt_envelope_index_c0,x	; if end not reached: advance index
    255  7bb0				   .endOfPercussion
    256  7bb0		       95 59		      sta	AUDV0,x
    257  7bb2		       4a		      lsr
    258  7bb3		       4a		      lsr
    259  7bb4		       4a		      lsr
    260  7bb5		       4a		      lsr
    261  7bb6		       95 55		      sta	AUDC0,x
    262  7bb8							; Set AUDF
    263  7bb8		       b9 5a fd 	      lda	tt_PercFreqTable-1,y	; -1 because values are stored +1
    264  7bbb							; Bit 7 (overlay) might be set, but is unused in AUDF
    265  7bbb		       95 57		      sta	AUDF0,x
    266  7bbd					      IF	TT_USE_OVERLAY = 1
    267  7bbd		       10 48		      bpl	.afterAudioUpdate
    268  7bbf							; Overlay percussion: Fetch next note out of order
    269  7bbf		       20 49 fb 	      jsr	tt_FetchNote
    270  7bc2							; Only do something if it's a melodic instrument
    271  7bc2		       c9 20		      cmp	#TT_FREQ_MASK+1
    272  7bc4		       90 41		      bcc	.afterAudioUpdate
    273  7bc6							; Instrument: Put into sustain
    274  7bc6		       95 d6		      sta	tt_cur_ins_c0,x	; set new instrument
    275  7bc8		       20 d7 fb 	      jsr	tt_CalcInsIndex
    276  7bcb		       b9 1e fd 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start at #1
    277  7bce		       95 d4		      sta	tt_envelope_index_c0,x
    278  7bd0							; Set prefetch flag. asl-sec-ror is smaller than lda-ora #128-sta
    279  7bd0		       16 d2		      asl	tt_cur_note_index_c0,x
    280  7bd2		       38		      sec
    281  7bd3		       76 d2		      ror	tt_cur_note_index_c0,x
    282  7bd5		       30 30		      bmi	.afterAudioUpdate	; unconditional
    283  7bd7				  -	      ELSE
    284  7bd7				  -	      jmp	.afterAudioUpdate
    285  7bd7					      ENDIF
    286  7bd7
    287  7bd7
    288  7bd7							; ---------------------------------------------------------------------
    289  7bd7							; Helper subroutine to minimize ROM footprint.
    290  7bd7							; Interleaved here so player routine can be inlined.
    291  7bd7							; ---------------------------------------------------------------------
    292  7bd7				   tt_CalcInsIndex
    293  7bd7							; move upper 3 bits to lower 3
    294  7bd7		       4a		      lsr
    295  7bd8		       4a		      lsr
    296  7bd9		       4a		      lsr
    297  7bda		       4a		      lsr
    298  7bdb		       4a		      lsr
    299  7bdc		       a8		      tay
    300  7bdd				   tt_Bit6Set		; This opcode has bit #6 set, for use with bit instruction
    301  7bdd		       60		      rts
    302  7bde
    303  7bde
    304  7bde				   .instrument
    305  7bde							; --- Melodic instrument ---
    306  7bde							; Compute index into ADSR indexes and master Ctrl tables
    307  7bde		       20 d7 fb 	      jsr	tt_CalcInsIndex
    308  7be1							; Set AUDC with master value for this instrument, while we are at it
    309  7be1		       b9 14 fd 	      lda	tt_InsCtrlTable-1,y	; -1 because instruments start with #1
    310  7be4		       95 55		      sta	AUDC0,x
    311  7be6							; advance ADSR counter and compare to end of Sustain
    312  7be6		       b5 d4		      lda	tt_envelope_index_c0,x
    313  7be8		       d9 23 fd 	      cmp	tt_InsReleaseIndexes-1,y	; -1 because instruments start with #1
    314  7beb		       d0 03		      bne	.noEndOfSustain
    315  7bed							; End of sustain: Go back to start of sustain
    316  7bed		       b9 1e fd 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start with #1
    317  7bf0				   .noEndOfSustain
    318  7bf0		       a8		      tay
    319  7bf1							; Set volume from envelope
    320  7bf1		       b9 29 fd 	      lda	tt_InsFreqVolTable,y
    321  7bf4		       f0 01		      beq	.endOfEnvelope	; 0 means end of release has been reached:
    322  7bf6		       c8		      iny		; advance index otherwise
    323  7bf7				   .endOfEnvelope
    324  7bf7		       94 d4		      sty	tt_envelope_index_c0,x
    325  7bf9		       95 59		      sta	AUDV0,x
    326  7bfb							; Now adjust frequency with ADSR value from envelope
    327  7bfb		       4a		      lsr
    328  7bfc		       4a		      lsr
    329  7bfd		       4a		      lsr
    330  7bfe		       4a		      lsr
    331  7bff		       18		      clc
    332  7c00		       75 d6		      adc	tt_cur_ins_c0,x
    333  7c02		       38		      sec
    334  7c03		       e9 08		      sbc	#8
    335  7c05		       95 57		      sta	AUDF0,x
    336  7c07
    337  7c07				   .afterAudioUpdate
    338  7c07							; loop over channels
    339  7c07		       ca		      dex
    340  7c08		       10 97		      bpl	.updateLoop
    341  7c0a
 Music player size:  $dd
    342  7c0a					      echo	"Music player size: ", *-tt_PlayerStart
------- FILE BANK_FIXED.asm
    983  7c0a
    984  7c0a		       20 08 fa 	      jsr	StealCharDraw	; NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
    985  7c0d
    986  7c0d							;---------------------------------------------------------------------------
    987  7c0d							; START OF DISPLAY
    988  7c0d
    989  7c0d		       a9 09		      lda	#BANK_SCORING	; 2
    990  7c0f		       85 3e		      sta	SET_BANK_RAM	; 3
    991  7c11		       20 d3 f1 	      jsr	DrawDigits	; 6 = 11
    992  7c14
    993  7c14							;---------------------------------------------------------------------------
    994  7c14							; A 42-cycle timing window in the screen draw code.  Perform any general
    995  7c14							; per-frame code here, provided it takes exactly 42 cycles to execute.
    996  7c14							; TJ: Well, not exactly 42 cycles, but it works! :)
    997  7c14							;	 @09
    998  7c14		       85 49		      sta	COLUBK	; 3	 value comes from subroutine
    999  7c16							; + the 'black' left-side of top screen colour change when look-around is actually a HMOVE bar, so we can't fix it :)
   1000  7c16
   1001  7c16							;		  inc Throttle		      ; 5     speed limiter
      0  7c16					      SLEEP	5	;	 TODO: optimize for space
      1  7c16				   .CYCLES    SET	5
      2  7c16
      3  7c16				  -	      IF	.CYCLES < 2
      4  7c16				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c16				  -	      ERR
      6  7c16					      ENDIF
      7  7c16
      8  7c16					      IF	.CYCLES & 1
      9  7c16					      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c16		       04 00		      nop	0
     11  7c18				  -	      ELSE
     12  7c18				  -	      bit	VSYNC
     13  7c18					      ENDIF
     14  7c18				   .CYCLES    SET	.CYCLES - 3
     15  7c18					      ENDIF
     16  7c18
     17  7c18					      REPEAT	.CYCLES / 2
     18  7c18		       ea		      nop
     19  7c19					      REPEND
   1003  7c19
   1004  7c19		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
   1005  7c1b		       ca		      dex		; 2	 = $6f, stars effect!
   1006  7c1c		       86 62		      stx	HMM0	; 3	 @24, exactly 21 cycles after the HMOVE
   1007  7c1e
   1008  7c1e		       85 44		      sta	NUSIZ0	; 3
   1009  7c20		       84 65		      sty	VDELP0	; 3	 y = 0!
   1010  7c22
   1011  7c22		       c8		      iny		; 2	 this relies on Y == 0 before...
   1012  7c23		       c4 c7		      cpy	extraLifeTimer	; 3	 ..,and bit 0 is set in A
   1013  7c25		       69 02		      adc	#2	; 2
   1014  7c27		       85 5d		      sta	ENAM0	; 3	 dis/enable Cosmic Ark star effect
   1015  7c29
   1016  7c29		       a5 a4		      lda	ManLastDirection	; 3
   1017  7c2b		       85 4b		      sta	REFP0	; 3
   1018  7c2d
   1019  7c2d		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
   1020  7c2f		       85 3e		      sta	SET_BANK_RAM	; 3
   1021  7c31		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
   1022  7c34							;	 @66
   1023  7c34		       a9 03		      lda	#BANK_PostScreenCleanup	; 2
   1024  7c36		       85 3f		      sta	SET_BANK	; 3
   1025  7c38		       20 d3 f4 	      jsr	PostScreenCleanup	; 6+x
   1026  7c3b
   1027  7c3b		       a9 00		      lda	#BANK_SelfModDrawPlayers	; 2
   1028  7c3d		       85 3f		      sta	SET_BANK	; 3
   1029  7c3f		       20 54 f3 	      jsr	SelfModDrawPlayers	; 6+x
   1030  7c42
   1031  7c42		       20 08 fa 	      jsr	StealCharDraw
   1032  7c45
   1033  7c45		       ad 84 02    OverscanBD lda	INTIM	;4
   1034  7c48		       d0 fb		      bne	OverscanBD	;2/3
   1035  7c4a		       4c 16 fb 	      jmp	NewFrameStart
   1036  7c4d				   VBlankTime
   1037  7c4d		       3e 3e		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
   1038  7c4f		       55 55		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_PAL
   1039  7c51
   1040  7c51							;---------------------------------------------------------------------------
   1041  7c51
   1042  7c51
      0  7c51					      DEFINE_SUBROUTINE	nextLevelMan
      1  7c51		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7c51					      SUBROUTINE
      3  7c51				   nextLevelMan
   1044  7c51
   1045  7c51		       a9 14		      lda	#20
   1046  7c53		       85 a8		      sta	DelayEndOfLevel
   1047  7c55		       a9 14		      lda	#20
   1048  7c57		       85 c6		      sta	ColourTimer
   1049  7c59
   1050  7c59
   1051  7c59		       a9 00		      lda	#0
   1052  7c5b		       85 aa		      sta	circle_d
   1053  7c5d		       85 ab		      sta	circle_d+1
   1054  7c5f
   1055  7c5f				  -	      if	0
   1056  7c5f				  -
   1057  7c5f				  -			; Fire up a circle-drawing special-effect object...
   1058  7c5f				  -
   1059  7c5f				  -
   1060  7c5f				  -	      lda	#TYPE_CIRCLE
   1061  7c5f				  -	      sta	POS_Type
   1062  7c5f				  -	      jsr	InsertObjectStack
   1063  7c5f				  -
   1064  7c5f					      endif
   1065  7c5f
   1066  7c5f
   1067  7c5f				  -	      if	0
   1068  7c5f				  -	      lda	#$08
   1069  7c5f				  -	      sta	color
   1070  7c5f				  -	      lda	#$04
   1071  7c5f				  -	      sta	color+1
   1072  7c5f				  -	      lda	#$0A
   1073  7c5f				  -	      sta	color+2
   1074  7c5f					      endif
   1075  7c5f		       e6 9f		      inc	ManMode
   1076  7c61		       60		      rts
   1077  7c62
      0  7c62					      DEFINE_SUBROUTINE	nextLevelMan2
      1  7c62		       00 0f	   BANK_nextLevelMan2 =	_CURRENT_BANK
      2  7c62					      SUBROUTINE
      3  7c62				   nextLevelMan2
   1079  7c62
   1080  7c62				  -	      if	0
   1081  7c62				  -	      ldy	#SCREEN_LINES-1
   1082  7c62				  -CopyScreenBank2 ldx	#ROM_SHADOW_OF_RAMBANK_CODE
   1083  7c62				  -	      sty	RAM_Bank
   1084  7c62				  -	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
   1085  7c62				  -	      dey
   1086  7c62				  -	      bpl	CopyScreenBank2
   1087  7c62				  -
   1088  7c62				  -	      ldx	#2
   1089  7c62				  -fade       lda	color,x
   1090  7c62				  -	      and	#$F
   1091  7c62				  -	      bne	nz
   1092  7c62				  -	      lda	#1
   1093  7c62				  -	      sta	color,x
   1094  7c62				  -nz	      dec	color,x
   1095  7c62				  -zalready   dex
   1096  7c62				  -	      bpl	fade
   1097  7c62					      endif
   1098  7c62
   1099  7c62							;dec DelayEndOfLevel
   1100  7c62							;beq goNL3
   1101  7c62
   1102  7c62		       e6 ab		      inc	circle_d+1
   1103  7c64		       a5 ab		      lda	circle_d+1
   1104  7c66		       c9 14		      cmp	#20
   1105  7c68		       b0 01		      bcs	goNL3
   1106  7c6a
   1107  7c6a
   1108  7c6a		       60		      rts
   1109  7c6b
   1110  7c6b				   goNL3
   1111  7c6b		       e6 9f		      inc	ManMode
   1112  7c6d
      0  7c6d					      DEFINE_SUBROUTINE	switchLevels
      1  7c6d		       00 0f	   BANK_switchLevels =	_CURRENT_BANK
      2  7c6d					      SUBROUTINE
      3  7c6d				   switchLevels
   1114  7c6d
   1115  7c6d							;lda #BANK_NextLevelX
   1116  7c6d							;sta SET_BANK
   1117  7c6d							;jmp NextLevelX
   1118  7c6d
   1119  7c6d							; Now do the actual switching
   1120  7c6d
   1121  7c6d		       a5 ca		      lda	NextLevelTrigger
   1122  7c6f		       29 7f		      and	#<(~BIT_NEXTLEVEL)
   1123  7c71		       85 ca		      sta	NextLevelTrigger
   1124  7c73
   1125  7c73							; Next level is due. Point to the next level, but if we're at the end of playable levels,
   1126  7c73							; then increment the level number. This is completely circular, so we eventually wrap
   1127  7c73							; the level back to 0 and start afresh.
   1128  7c73
   1129  7c73		       e6 b4		      inc	levelX
   1130  7c75		       a5 b4		      lda	levelX
   1131  7c77		       c9 64		      cmp	#NUMBEROFLEVELS
   1132  7c79		       90 02		      bcc	.level_ok
   1133  7c7b		       a9 00		      lda	#0
   1134  7c7d		       85 b4	   .level_ok  sta	levelX
   1135  7c7f		       60		      rts
   1136  7c80
   1137  7c80							;---------------------------------------------------------------------------
   1138  7c80
   1139  7c80
      0  7c80					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7c80		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7c80					      SUBROUTINE
      3  7c80				   CopyROM2RAM_F000
   1141  7c80
   1142  7c80		       a9 09		      lda	#BANK_CopyROMShadowToRAM
   1143  7c82		       85 3f		      sta	SET_BANK
   1144  7c84		       85 c4		      sta	ROM_Bank
   1145  7c86		       4c 43 f0 	      jmp	CopyROMShadowToRAM_F000
   1146  7c89
   1147  7c89
   1148  7c89							;---------------------------------------------------------------------------
   1149  7c89
------- FILE characterset/BOX.asm LEVEL 3 PASS 4
      0  7c89					      include	"characterset/BOX.asm"	; 2 * LINES_PER_CHAR bytes
      1  7c89							;    Sokoboo - a Sokoban implementation
      2  7c89							;    using a generic tile-based display engine for the Atari 2600
      3  7c89							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7c89							;
      5  7c89							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7c89							;
      7  7c89							;    Code related to the generic tile-based display engine was developed by
      8  7c89							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7c89							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7c89							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7c89							;
     12  7c89							;    Code related to music and sound effects uses the TIATracker music player
     13  7c89							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7c89							;    directory for Apache licensing details.
     15  7c89							;
     16  7c89							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7c89							;    See the copyright notices in the License directory for a list of level
     18  7c89							;    contributors.
     19  7c89							;
     20  7c89							;    Except where otherwise indicated, this software is released under the
     21  7c89							;    following licensing arrangement...
     22  7c89							;
     23  7c89							;    This program is free software: you can redistribute it and/or modify
     24  7c89							;    it under the terms of the GNU General Public License as published by
     25  7c89							;    the Free Software Foundation, either version 3 of the License, or
     26  7c89							;    (at your option) any later version.
     27  7c89							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7c89
     29  7c89							;    This program is distributed in the hope that it will be useful,
     30  7c89							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7c89							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7c89							;    GNU General Public License for more details.
     33  7c89
      0  7c89					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  7c89					      LIST	ON
     35  7c89				   CHARACTERSHAPE_BOX
     36  7c89				  -	      if	MIRRORED_BOX = NO
     37  7c89				  -CHARACTERSHAPE_BOX_MIRRORED
     38  7c89					      endif
     39  7c89		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
     40  7c90		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     41  7c97		       00 00 00 00*	      .byte.b	%0,%0,%0,0,%0,%0,%0	;B
     42  7c9e
     43  7c9e							;--------------------------------------------------------------------------
     44  7c9e					      if	MIRRORED_BOX = YES
      0  7c9e					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
     10  7c9e					      LIST	ON
     46  7c9e				   CHARACTERSHAPE_BOX_MIRRORED
     47  7c9e		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
     48  7ca5		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     49  7cac		       00 00 00 00*	      .byte.b	%0,%0,0,0,%0,%0,%0	;B
     50  7cb3					      endif
     51  7cb3
      0  7cb3					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET", LINES_PER_CHAR
     10  7cb3					      LIST	ON
     53  7cb3				   CHARACTERSHAPE_BOX_ON_TARGET
     54  7cb3				  -	      if	MIRRORED_BOX = NO
     55  7cb3				  -CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     56  7cb3					      endif
     57  7cb3		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     58  7cba		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     59  7cc1		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,0,%0,%0	;B
     60  7cc8
     61  7cc8							;--------------------------------------------------------------------------
     62  7cc8					      if	MIRRORED_BOX = YES
      0  7cc8					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED", LINES_PER_CHAR
     10  7cc8					      LIST	ON
     64  7cc8				   CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     65  7cc8		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     66  7ccf		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     67  7cd6		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,0,%0,%0	;B
     68  7cdd					      endif
------- FILE BANK_FIXED.asm
------- FILE characterset/Steel_Wall.asm LEVEL 3 PASS 4
      0  7cdd					      include	"characterset/Steel_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      1  7cdd							;    Sokoboo - a Sokoban implementation
      2  7cdd							;    using a generic tile-based display engine for the Atari 2600
      3  7cdd							;    Sokoban (倉庫番)™ is © Falcon Co., Ltd.
      4  7cdd							;
      5  7cdd							;    Code related to this Sokoban™ implementation was developed by Andrew Davie.
      6  7cdd							;
      7  7cdd							;    Code related to the generic tile-based display engine was developed by
      8  7cdd							;    Andrew Davie and Thomas Jentzsch during 2003-2011 and is
      9  7cdd							;    Copyright(C)2003-2019 Thomas Jentzsch and Andrew Davie - contacts details:
     10  7cdd							;    Andrew Davie (andrew@taswegian.com), Thomas Jentzsch (tjentzsch@yahoo.de).
     11  7cdd							;
     12  7cdd							;    Code related to music and sound effects uses the TIATracker music player
     13  7cdd							;    Copyright 2016 Andre "Kylearan" Wichmann - see source code in the "sound"
     14  7cdd							;    directory for Apache licensing details.
     15  7cdd							;
     16  7cdd							;    Some level data incorporated in this program were created by Lee J Haywood.
     17  7cdd							;    See the copyright notices in the License directory for a list of level
     18  7cdd							;    contributors.
     19  7cdd							;
     20  7cdd							;    Except where otherwise indicated, this software is released under the
     21  7cdd							;    following licensing arrangement...
     22  7cdd							;
     23  7cdd							;    This program is free software: you can redistribute it and/or modify
     24  7cdd							;    it under the terms of the GNU General Public License as published by
     25  7cdd							;    the Free Software Foundation, either version 3 of the License, or
     26  7cdd							;    (at your option) any later version.
     27  7cdd							;    see https://www.gnu.org/licenses/gpl-3.0.en.html
     28  7cdd
     29  7cdd							;    This program is distributed in the hope that it will be useful,
     30  7cdd							;    but WITHOUT ANY WARRANTY; without even the implied warranty of
     31  7cdd							;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     32  7cdd							;    GNU General Public License for more details.
     33  7cdd
     34  7cdd							;--------------------------------------------------------------------------
      0  7cdd					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
     10  7cdd					      LIST	ON
     36  7cdd				   CHARACTERSHAPE_STEEL
     37  7cdd		       00 88 00 00*	      .byte.b	%00000000,%10001000,%00000000,%00000000,%00100010,%00000000,%00000000	;R
     38  7ce4		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;G
     39  7ceb		       ff ff 77 ff*	      .byte.b	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;B
     40  7cf2
     41  7cf2							;--------------------------------------------------------------------------
      0  7cf2					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_STEEL_MIRRORED
 REQUESTED SIZE =  $15
 WASTED SPACE =  $e
 PAGEBREAK LOCATION =  $fd00
     10  7d00					      LIST	ON
     43  7d00				   CHARACTERSHAPE_STEEL_MIRRORED
     44  7d00		       00 11 00 00*	      .byte.b	%00000000,%00010001,%00000000,%00000000,%01000100,%00000000,%00000000	;R
     45  7d07		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;G
     46  7d0e		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;B
------- FILE BANK_FIXED.asm
   1152  7d15							;---------------------------------------------------------------------------
   1153  7d15
   1154  7d15							;include "circle.asm"
   1155  7d15							;#include "characterset/Brick_Wall.asm"    ; 2 * LINES_PER_CHAR bytes
------- FILE sound/intro1_trackdata.asm LEVEL 3 PASS 4
      0  7d15					      include	"sound/intro1_trackdata.asm"
      1  7d15							; TIATracker music player
      2  7d15							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7d15							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7d15							; Email: andre.wichmann@gmx.de
      5  7d15							;
      6  7d15							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7d15							; you may not use this file except in compliance with the License.
      8  7d15							; You may obtain a copy of the License at
      9  7d15							;
     10  7d15							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7d15							;
     12  7d15							; Unless required by applicable law or agreed to in writing, software
     13  7d15							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7d15							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7d15							; See the License for the specific language governing permissions and
     16  7d15							; limitations under the License.
     17  7d15
     18  7d15							; Song author: 
     19  7d15							; Song name: 
     20  7d15
     21  7d15							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7d15
     23  7d15							; =====================================================================
     24  7d15							; TIATracker melodic and percussion instruments, patterns and sequencer
     25  7d15							; data.
     26  7d15							; =====================================================================
     27  7d15				   tt_TrackDataStart
     28  7d15
     29  7d15							; =====================================================================
     30  7d15							; Melodic instrument definitions (up to 7). tt_envelope_index_c0/1 hold
     31  7d15							; the index values into these tables for the current instruments played
     32  7d15							; in channel 0 and 1.
     33  7d15							; 
     34  7d15							; Each instrument is defined by:
     35  7d15							; - tt_InsCtrlTable: the AUDC value
     36  7d15							; - tt_InsADIndexes: the index of the start of the ADSR envelope as
     37  7d15							;	 defined in tt_InsFreqVolTable
     38  7d15							; - tt_InsSustainIndexes: the index of the start of the Sustain phase
     39  7d15							;	 of the envelope
     40  7d15							; - tt_InsReleaseIndexes: the index of the start of the Release phase
     41  7d15							; - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
     42  7d15							;	 the envelope
     43  7d15							; =====================================================================
     44  7d15
     45  7d15							; Instrument master CTRL values
     46  7d15				   tt_InsCtrlTable
     47  7d15		       07 04 0c 04*	      dc.b	$07, $04, $0c, $04, $0c
     48  7d1a
     49  7d1a
     50  7d1a							; Instrument Attack/Decay start indexes into ADSR tables.
     51  7d1a				   tt_InsADIndexes
     52  7d1a		       00 0e 0e 1e*	      dc.b	$00, $0e, $0e, $1e, $1e
     53  7d1f
     54  7d1f
     55  7d1f							; Instrument Sustain start indexes into ADSR tables
     56  7d1f				   tt_InsSustainIndexes
     57  7d1f		       08 19 19 2b*	      dc.b	$08, $19, $19, $2b, $2b
     58  7d24
     59  7d24
     60  7d24							; Instrument Release start indexes into ADSR tables
     61  7d24							; Caution: Values are stored with an implicit -1 modifier! To get the
     62  7d24							; real index, add 1.
     63  7d24				   tt_InsReleaseIndexes
     64  7d24		       09 1b 1b 2c*	      dc.b	$09, $1b, $1b, $2c, $2c
     65  7d29
     66  7d29
     67  7d29							; AUDVx and AUDFx ADSR envelope values.
     68  7d29							; Each byte encodes the frequency and volume:
     69  7d29							; - Bits 7..4: Freqency modifier for the current note ([-8..7]),
     70  7d29							;	 8 means no change. Bit 7 is the sign bit.
     71  7d29							; - Bits 3..0: Volume
     72  7d29							; Between sustain and release is one byte that is not used and
     73  7d29							; can be any value.
     74  7d29							; The end of the release phase is encoded by a 0.
     75  7d29				   tt_InsFreqVolTable
     76  7d29							; 0: Pizzicato bassb
     77  7d29		       8a 8a 89 88*	      dc.b	$8a, $8a, $89, $88, $86, $85, $85, $84
     78  7d31		       83 00 83 83*	      dc.b	$83, $00, $83, $83, $83, $00
     79  7d37							; 1+2: Square2
     80  7d37		       8c 8c 8b 89*	      dc.b	$8c, $8c, $8b, $89, $87, $85, $84, $83
     81  7d3f		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $00, $81, $00
     82  7d47							; 3+4: Square
     83  7d47		       85 85 85 85*	      dc.b	$85, $85, $85, $85, $84, $83, $83, $82
     84  7d4f		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $81, $00, $80
     85  7d57		       00		      dc.b	$00
     86  7d58
     87  7d58
     88  7d58
     89  7d58							; =====================================================================
     90  7d58							; Percussion instrument definitions (up to 15)
     91  7d58							;
     92  7d58							; Each percussion instrument is defined by:
     93  7d58							; - tt_PercIndexes: The index of the first percussion frame as defined
     94  7d58							;	 in tt_PercFreqTable and tt_PercCtrlVolTable
     95  7d58							; - tt_PercFreqTable: The AUDF frequency value
     96  7d58							; - tt_PercCtrlVolTable: The AUDV volume and AUDC values
     97  7d58							; =====================================================================
     98  7d58
     99  7d58							; Indexes into percussion definitions signifying the first frame for
    100  7d58							; each percussion in tt_PercFreqTable.
    101  7d58							; Caution: Values are stored with an implicit +1 modifier! To get the
    102  7d58							; real index, subtract 1.
    103  7d58				   tt_PercIndexes
    104  7d58		       01 0a 0c 	      dc.b	$01, $0a, $0c
    105  7d5b
    106  7d5b
    107  7d5b							; The AUDF frequency values for the percussion instruments.
    108  7d5b							; If the second to last value is negative (>=128), it means it's an
    109  7d5b							; "overlay" percussion, i.e. the player fetches the next instrument note
    110  7d5b							; immediately and starts it in the sustain phase next frame. (Needs
    111  7d5b							; TT_USE_OVERLAY)
    112  7d5b				   tt_PercFreqTable
    113  7d5b							; 0: Kick
    114  7d5b		       00 01 02 03*	      dc.b	$00, $01, $02, $03, $04, $05, $06, $87
    115  7d63		       00		      dc.b	$00
    116  7d64							; 1: HH
    117  7d64		       80 00		      dc.b	$80, $00
    118  7d66							; 2: Snare
    119  7d66		       01 03 06 0e*	      dc.b	$01, $03, $06, $0e, $13, $11, $15, $14
    120  7d6e		       17 1b 00 	      dc.b	$17, $1b, $00
    121  7d71
    122  7d71
    123  7d71							; The AUDCx and AUDVx volume values for the percussion instruments.
    124  7d71							; - Bits 7..4: AUDC value
    125  7d71							; - Bits 3..0: AUDV value
    126  7d71							; 0 means end of percussion data.
    127  7d71				   tt_PercCtrlVolTable
    128  7d71							; 0: Kick
    129  7d71		       ee ed ed eb*	      dc.b	$ee, $ed, $ed, $eb, $e9, $e8, $e8, $e6
    130  7d79		       00		      dc.b	$00
    131  7d7a							; 1: HH
    132  7d7a		       87 00		      dc.b	$87, $00
    133  7d7c							; 2: Snare
    134  7d7c		       8b 8a 8a 8a*	      dc.b	$8b, $8a, $8a, $8a, $8a, $8a, $89, $88
    135  7d84		       87 86 00 	      dc.b	$87, $86, $00
    136  7d87
    137  7d87
    138  7d87
    139  7d87							; =====================================================================
    140  7d87							; Track definition
    141  7d87							; The track is defined by:
    142  7d87							; - tt_PatternX (X=0, 1, ...): Pattern definitions
    143  7d87							; - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
    144  7d87							;	 as index values
    145  7d87							; - tt_SequenceTable: The order in which the patterns should be played,
    146  7d87							;	 i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
    147  7d87							;	 for all channels and sub-tracks. The variables
    148  7d87							;	 tt_cur_pat_index_c0/1 hold an index into tt_SequenceTable for
    149  7d87							;	 each channel.
    150  7d87							;
    151  7d87							; So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
    152  7d87							; in turn point to pattern definitions (tt_PatternX) in which the notes
    153  7d87							; to play are specified.
    154  7d87							; =====================================================================
    155  7d87
    156  7d87							; ---------------------------------------------------------------------
    157  7d87							; Pattern definitions, one table per pattern. tt_cur_note_index_c0/1
    158  7d87							; hold the index values into these tables for the current pattern
    159  7d87							; played in channel 0 and 1.
    160  7d87							;
    161  7d87							; A pattern is a sequence of notes (one byte per note) ending with a 0.
    162  7d87							; A note can be either:
    163  7d87							; - Pause: Put melodic instrument into release. Must only follow a
    164  7d87							;	 melodic instrument.
    165  7d87							; - Hold: Continue to play last note (or silence). Default "empty" note.
    166  7d87							; - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
    167  7d87							;	 by -7..+7 and keep playing it
    168  7d87							; - Play new note with melodic instrument
    169  7d87							; - Play new note with percussion instrument
    170  7d87							; - End of pattern
    171  7d87							;
    172  7d87							; A note is defined by:
    173  7d87							; - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
    174  7d87							;	 and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
    175  7d87							;	 defined as:
    176  7d87							;	 - 0: End of pattern
    177  7d87							;	 - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
    178  7d87							;	 - 8: Hold
    179  7d87							;	 - 16: Pause
    180  7d87							;	 - [17..31]: Play percussion instrument 1..15
    181  7d87							;
    182  7d87							; The tracker must ensure that a pause only follows a melodic
    183  7d87							; instrument or a hold/slide.
    184  7d87							; ---------------------------------------------------------------------
    185  7d87		       00 1f	   TT_FREQ_MASK =	%00011111
    186  7d87		       00 08	   TT_INS_HOLD =	8
    187  7d87		       00 10	   TT_INS_PAUSE =	16
    188  7d87		       00 11	   TT_FIRST_PERC =	17
    189  7d87
    190  7d87							; Intro left
    191  7d87				   tt_pattern0
    192  7d87		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $3e, $08
    193  7d8f		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $3e, $08
    194  7d97		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $12, $3e
    195  7d9f		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $13, $08
    196  7da7		       00		      dc.b	$00
    197  7da8
    198  7da8							; Intro2 L
    199  7da8				   tt_pattern1
    200  7da8		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    201  7db0		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    202  7db8		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    203  7dc0		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    204  7dc8		       00		      dc.b	$00
    205  7dc9
    206  7dc9							; Intro2-fill L
    207  7dc9				   tt_pattern2
    208  7dc9		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    209  7dd1		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    210  7dd9		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    211  7de1		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    212  7de9		       00		      dc.b	$00
    213  7dea
    214  7dea							; Intro right
    215  7dea				   tt_pattern3
    216  7dea		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $73, $08
    217  7df2		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $73, $08, $73, $08
    218  7dfa		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $b3, $08
    219  7e02		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    220  7e0a		       00		      dc.b	$00
    221  7e0b
    222  7e0b							; Intro2 R
    223  7e0b				   tt_pattern4
    224  7e0b		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    225  7e13		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    226  7e1b		       b3 08 73 08*	      dc.b	$b3, $08, $73, $08, $b3, $08, $73, $08
    227  7e23		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    228  7e2b		       00		      dc.b	$00
    229  7e2c
    230  7e2c
    231  7e2c
    232  7e2c
    233  7e2c							; Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
    234  7e2c							; Each byte encodes the speed of one pattern in the order
    235  7e2c							; of the tt_PatternPtr tables below.
    236  7e2c							; If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
    237  7e2c							; the even speed and the high nibble the odd speed.
    238  7e2c				  -	      IF	TT_GLOBAL_SPEED = 0
    239  7e2c				  -tt_PatternSpeeds
    240  7e2c				  -%%PATTERNSPEEDS%%
    241  7e2c					      ENDIF
    242  7e2c
    243  7e2c
    244  7e2c							; ---------------------------------------------------------------------
    245  7e2c							; Pattern pointers look-up table.
    246  7e2c							; ---------------------------------------------------------------------
    247  7e2c				   tt_PatternPtrLo
    248  7e2c		       87 a8 c9 ea	      dc.b	<tt_pattern0, <tt_pattern1, <tt_pattern2, <tt_pattern3
    249  7e30		       0b		      dc.b	<tt_pattern4
    250  7e31				   tt_PatternPtrHi
    251  7e31		       fd fd fd fd	      dc.b	>tt_pattern0, >tt_pattern1, >tt_pattern2, >tt_pattern3
    252  7e35		       fe		      dc.b	>tt_pattern4
    253  7e36
    254  7e36
    255  7e36							; ---------------------------------------------------------------------
    256  7e36							; Pattern sequence table. Each byte is an index into the
    257  7e36							; tt_PatternPtrLo/Hi tables where the pointers to the pattern
    258  7e36							; definitions can be found. When a pattern has been played completely,
    259  7e36							; the next byte from this table is used to get the address of the next
    260  7e36							; pattern to play. tt_cur_pat_index_c0/1 hold the current index values
    261  7e36							; into this table for channels 0 and 1.
    262  7e36							; If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
    263  7e36							; number encoded in bits 6..0 (i.e. value AND %01111111).
    264  7e36							; ---------------------------------------------------------------------
    265  7e36				   tt_SequenceTable
    266  7e36							; ---------- Channel 0 ----------
    267  7e36		       00 00 01 02*	      dc.b	$00, $00, $01, $02, $80
    268  7e3b
    269  7e3b
    270  7e3b							; ---------- Channel 1 ----------
    271  7e3b		       03 04 03 04*	      dc.b	$03, $04, $03, $04, $85
    272  7e40
    273  7e40
 Track size:  $12b
    274  7e40					      echo	"Track size: ", *-tt_TrackDataStart
------- FILE BANK_FIXED.asm
   1157  7e40
 FREE BYTES IN FIXED BANK =  $1bb
   1158  7e40					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1159  7e40
   1160  7e40							;---------------------------------------------------------------------------
   1161  7e40							; The reset vectors
   1162  7e40							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1163  7e40
   1164  8000 ????				      SEG	InterruptVectors
   1165  7ffc					      ORG	FIXED_BANK + $7FC
   1166  7ffc					      RORG	$7ffC
   1167  7ffc
   1168  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1169  7ffc		       91 fa		      .word.w	Reset	; RESET
   1170  7ffe		       91 fa		      .word.w	Reset	; IRQ	      (not used)
   1171  8000
   1172  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
    866  8000
    867  8000					      END
