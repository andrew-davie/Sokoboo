------- FILE ./sokoboo.asm LEVEL 1 PASS 3
      1  8000 ????
      2  8000 ????
      3  8000 ????	       00 40	   TIA_BASE_ADDRESS =	$40
      4  8000 ????
      5  8000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8000 ????				      include	"vcs.h"
      1  8000 ????						; VCS.H
      2  8000 ????						; Version 1.05, 13/November/2003
      3  8000 ????
      4  8000 ????	       00 69	   VERSION_VCS =	105
      5  8000 ????
      6  8000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  8000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  8000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  8000 ????						;
     10  8000 ????						; This file defines hardware registers and memory mapping for the
     11  8000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  8000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  8000 ????						; available at at http://www.atari2600.org/dasm
     14  8000 ????						;
     15  8000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  8000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  8000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  8000 ????						; with your views.  Please contribute, if you think you can improve this
     19  8000 ????						; file!
     20  8000 ????						;
     21  8000 ????						; Latest Revisions...
     22  8000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  8000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  8000 ????						;			    This will allow conditional code to verify VCS.H being
     25  8000 ????						;			    used for code assembly.
     26  8000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  8000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  8000 ????						;			 mirrored reading/writing differences.	This is more a
     29  8000 ????						;			 readability issue, and binary compatibility with disassembled
     30  8000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  8000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  8000 ????						;			 which was broken by the use of segments in this file, as
     33  8000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  8000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  8000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  8000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  8000 ????						;						   it is safe to leave it undefined, and the base address will
     38  8000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  8000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  8000 ????						;			  - register definitions are now generated through assignment
     41  8000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  8000 ????						;			    address architecture.
     43  8000 ????						; 1.0	22/MAR/2003		Initial release
     44  8000 ????
     45  8000 ????
     46  8000 ????						;-------------------------------------------------------------------------------
     47  8000 ????
     48  8000 ????						; TIA_BASE_ADDRESS
     49  8000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  8000 ????						; Normally 0, the base address should (externally, before including this file)
     51  8000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  8000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  8000 ????						; < $40 as a bankswitch.
     54  8000 ????
     55  8000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     56  8000 ????			  -TIA_BASE_ADDRESS =	0
     57  8000 ????				      ENDIF
     58  8000 ????
     59  8000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  8000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  8000 ????						; *OR* by declaring the label before including this file, eg:
     62  8000 ????						; TIA_BASE_ADDRESS = $40
     63  8000 ????						;   include "vcs.h"
     64  8000 ????
     65  8000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  8000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  8000 ????						; for the mirrored ROM hardware registers.
     68  8000 ????
     69  8000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  8000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     71  8000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  8000 ????
     73  8000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     74  8000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  8000 ????				      ENDIF
     76  8000 ????
     77  8000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  8000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  8000 ????				      ENDIF
     80  8000 ????
     81  8000 ????						;-------------------------------------------------------------------------------
     82  8000 ????
     83 U006d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0040					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0040
     86 U0040							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0040
     88 U0040		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0041		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0042		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0043		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0044		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0045		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0046		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0047		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0048		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0049		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U004a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U004b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U004c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U004d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U004e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U004f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0050		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0051		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0052		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0053		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0054		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0055		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0056		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0057		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0058		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0059		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U005a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U005b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U005c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U005d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U005e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U005f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0060		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0061		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0062		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0063		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0064		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0065		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0066		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0067		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0068		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0069		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U006a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U006b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U006c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U006d
    134 U006d							;-------------------------------------------------------------------------------
    135 U006d
    136 U004e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0040					      ORG	TIA_BASE_READ_ADDRESS
    138 U0040
    139 U0040							;											bit 7	 bit 6
    140 U0040		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0041		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0042		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0043		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0044		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0045		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0046		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0047		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0048		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0049		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U004a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U004b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U004c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U004d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U004e
    155 U004e							;-------------------------------------------------------------------------------
    156 U004e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE ./sokoboo.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  0000 ????
      4  0000 ????	       00 6a	   VERSION_MACRO =	106
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	22/MAR/2003		Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Andrew Davie
     97  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  0000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  0000 ????						; Use as very first section of code on boot (ie: at reset)
    101  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  0000 ????
    103  0000 ????				      MAC	clean_start
    104  0000 ????				      sei
    105  0000 ????				      cld
    106  0000 ????
    107  0000 ????				      ldx	#0
    108  0000 ????				      txa
    109  0000 ????				      tay
    110  0000 ????			   .CLEAR_STACK dex
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  0000 ????
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	0
    151  0000 ????			   .FREE_BYTES SET	0
    152  0000 ????				      MAC	boundary
    153  0000 ????				      REPEAT	256
    154  0000 ????				      IF	<. % {1} = 0
    155  0000 ????				      MEXIT
    156  0000 ????				      ELSE
    157  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    158  0000 ????				      .byte	$00
    159  0000 ????				      ENDIF
    160  0000 ????				      REPEND
    161  0000 ????			   __DASM__TOTAL_FREE_MEMORY SET	__DASM__TOTAL_FREE_MEMORY + .FREE_BYTES
    162  0000 ????				      ENDM
    163  0000 ????
    164  0000 ????
    165  0000 ????						; EOF
------- FILE ./sokoboo.asm
      8  0000 ????
------- FILE segtime.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"segtime.asm"
      1  0000 ????						; segtime optimization (averages):
      2  0000 ????						;   lost time = segtime/2 * 64
      3  0000 ????						;   num-segments = (vblank + overscan time) (NTSC 276=62+51=113) / 2 / segtime
      4  0000 ????						;   overhead: num-segments * 8 (assuming minimal INTIM check only)
      5  0000 ????						;
      6  0000 ????						; segtime = 2:
      7  0000 ????						;   lost time = 64
      8  0000 ????						;   num-segments = 28
      9  0000 ????						;   overhead = 224!
     10  0000 ????						; segtime = 3:
     11  0000 ????						;   lost time = 96
     12  0000 ????						;   num-segments = 18
     13  0000 ????						;   overhead = 144!
     14  0000 ????						; segtime = 4: 	     <--!!!
     15  0000 ????						;   lost time = 128!
     16  0000 ????						;   num-segments = 28
     17  0000 ????						;   overhead = 112
     18  0000 ????						; segtime = 5:
     19  0000 ????						;   lost time = 160!
     20  0000 ????						;   num-segments = 11
     21  0000 ????						;   overhead = 88
     22  0000 ????						; segtime = 6:
     23  0000 ????						;   lost time = 192!
     24  0000 ????						;   num-segments = 9
     25  0000 ????						;   overhead = 72
     26  0000 ????						; segtime = 7:
     27  0000 ????						;   lost time = 224!
     28  0000 ????						;   num-segments = 8
     29  0000 ????						;   overhead = 64
     30  0000 ????						; segtime = 10:
     31  0000 ????						;   lost time = 320!
     32  0000 ????						;   num-segments = 5
     33  0000 ????						;   overhead = 40
     34  0000 ????						; segtime = 20:
     35  0000 ????						;   lost time = 640!
     36  0000 ????						;   num-segments = 2
     37  0000 ????						;   overhead = 16
     38  0000 ????						; segtime = 40:
     39  0000 ????						;   lost time = 1280!
     40  0000 ????						;   num-segments = 1
     41  0000 ????						;   overhead = 8
     42  0000 ????
     43  0000 ????						; optimal INTIM segtime is 4 + 1 = 5,
     44  0000 ????						; below wasted time increases rapidly, above only moderately
     45  0000 ????						; if the overhead becomes larger, optimal segtimes will increase too
     46  0000 ????						; also the lost time will become smaller, if smaller segments can be used instead,
     47  0000 ????						;  so larger segtimes are not that bad then
     48  0000 ????
     49  0000 ????
     50  0000 ????				      MAC	segtime
     51  0000 ????			   {1}	      SET	{2}
     52  0000 ????			   TEST_{1}   =	0
     53  0000 ????				      ENDM
     54  0000 ????
     55  0000 ????				      MAC	xsegtime
     56  0000 ????			   {1}	      SET	{2}-1
     57  0000 ????			   TEST_{1}   =	1
     58  0000 ????				      ENDM
     59  0000 ????
     60  0000 ????						;@TJ -- SIMPLY PUT AN X IN FRONT OF THE LINE(S) YOU WANT TO TEST
     61  0000 ????						; eg: XSEGTIME SEGTIME_BOX1,5
     62  0000 ????						; No other action required.  All code enables/disables automatically.
     63  0000 ????
     64  0000 ????						; 2012/02/11 -- experimental reduction in times (but not stress tested)
     65  0000 ????						; due to separation of timeslice overhead to separate check
     66  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_SCD_DIRECT,8	; TODO: 392@12/2/2012
      1  0000 ????			   SEGTIME_SCD_DIRECT SET	8
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_DIRECT =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_QUICK,9	; TODO: 414@12/2/2012
      1  0000 ????			   SEGTIME_SCD_QUICK SET	9
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_QUICK =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_SLOW,12	; TODO: cycles: ~635 @12/2/2012.
      1  0000 ????			   SEGTIME_SCD_SLOW SET	12
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_SLOW =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_PF0,5	; TODO: cycle counted ~126 @12/2/2012
      1  0000 ????			   SEGTIME_SCD_PF0 SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_PF0 =	0
      0  0000 ????				      SEGTIME	SEGTIME_SCD_MIN,SEGTIME_SCD_PF0	; * MINIMUM TIME OF THE ABOVE + 1
      1  0000 ????			   SEGTIME_SCD_MIN SET	SEGTIME_SCD_PF0
      2  0000 ????	       00 00	   TEST_SEGTIME_SCD_MIN =	0
     72  0000 ????
     73  0000 ????			  -	      IF	MULTI_BANK_BOARD = YES
     74  0000 ????			  -	      SEGTIME	SEGTIME_BDF,42	; * 5/8/11 stress tested DHS->DS
     75  0000 ????				      ELSE
      0  0000 ????				      SEGTIME	SEGTIME_BDF,41	; * 7/8/11
      1  0000 ????			   SEGTIME_BDF SET	41
      2  0000 ????	       00 00	   TEST_SEGTIME_BDF =	0
     77  0000 ????				      ENDIF
     78  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_BDS,5	; *AD 11/8/11
      1  0000 ????			   SEGTIME_BDS SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_BDS =	0
      0  0000 ????				      SEGTIME	SEGTIME_DSL,5	; * 9/8/11 unrolled once
      1  0000 ????			   SEGTIME_DSL SET	5
      2  0000 ????	       00 00	   TEST_SEGTIME_DSL =	0
     81  0000 ????
     82  0000 ????
     83  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SORT_TIME,3	;     157(A)->2.45
      1  0000 ????			   MINIMUM_SORT_TIME SET	3
      2  0000 ????	       00 00	   TEST_MINIMUM_SORT_TIME =	0
     85  0000 ????
     86  0000 ????
     87  0000 ????						;following will lock-up system if used as 'XSEGTIME'.
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIME,4	; processing slice minimum requirement
      1  0000 ????			   MINIMUM_SEGTIME SET	4
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIME =	0
     89  0000 ????
      0  0000 ????				      SEGTIME	MINIMUM_SEGTIMEBLANK,16	;17		 ; * 7/8/11	 993(A)->15.5
      1  0000 ????			   MINIMUM_SEGTIMEBLANK SET	16
      2  0000 ????	       00 00	   TEST_MINIMUM_SEGTIMEBLANK =	0
     91  0000 ????
     92  0000 ????						; MINIMUM_SEGTIME
     93  0000 ????						; MINIMUM_SEGTIMEBLANK
     94  0000 ????						; SEGTIME_BDF
     95  0000 ????						; SEGTIME_BDS
     96  0000 ????						; SEGTIME_DSL
     97  0000 ????						; SEGTIME_SWITCHOBJECTS
     98  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MINIMUM_TIMESLICE,MINIMUM_SEGTIME+1	; MINIMUM of the TIMESLICE segments listed above
      1  0000 ????			   SEGTIME_MINIMUM_TIMESLICE SET	MINIMUM_SEGTIME+1
      2  0000 ????	       00 00	   TEST_SEGTIME_MINIMUM_TIMESLICE =	0
    100  0000 ????
    101  0000 ????						; Note: we add 1 to the minimum because there's a bit of overhead at the start of the timeslice code which vectors
    102  0000 ????						; to the appropriate timeslice.  That timeslice then checks the segtime again -- and in the case of the minimum we
    103  0000 ????						; will already have used 55 cycles of the available timeslice to get to the segtime check. Given that there are only
    104  0000 ????						; 9 spare cycles in the 'unit' left, it's probably more efficient to abort earlier and save those 55 cycles for other
    105  0000 ????						; uses ...
    106  0000 ????
    107  0000 ????
    108  0000 ????						; The following timings have been physicaly timed via code/debugger... the comment shows the worst observed time.
    109  0000 ????						; Generally the allocated segtime should be a bit bigger than the worst observed, to cater for the minor code
    110  0000 ????						; outside the creature itself which might otherwise cause screen time over-run.
    111  0000 ????
    112  0000 ????						; The following are NOT object-related and timing is a bit of manual guesswork/calculation
    113  0000 ????						; Comment may indicate at what value a glitch was DEFINITELY seen. These timings may not be optimal.
    114  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_MAN,24	;<< using this as XSEGTIME stops player working ...?!
      1  0000 ????			   SEGTIME_MAN SET	24
      2  0000 ????	       00 00	   TEST_SEGTIME_MAN =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE, 10	; drawing circle creature
      1  0000 ????			   SEGTIME_CIRCLE SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE =	0
      0  0000 ????				      SEGTIME	SEGTIME_CIRCLE_HELPER, 10	; drawing circle creature's helper
      1  0000 ????			   SEGTIME_CIRCLE_HELPER SET	10
      2  0000 ????	       00 00	   TEST_SEGTIME_CIRCLE_HELPER =	0
    118  0000 ????
    119  0000 ????						; TJ: I should only prevent processes with an extra check (e.g. get TARGET)
    120  0000 ????
    121  0000 ????						; push BOX is slowest (besides get TARGET which has an extra timer check)
    122  0000 ????						; if we add another check for it, SEGTIME_MAN reduces by ~5
    123  0000 ????
      0  0000 ????				      SEGTIME	SEGTIME_GET_TARGET,17	; * 14/8/11, required if UpdateScore loops (e.g. 9990->10000)
      1  0000 ????			   SEGTIME_GET_TARGET SET	17
      2  0000 ????	       00 00	   TEST_SEGTIME_GET_TARGET =	0
      0  0000 ????				      SEGTIME	SEGTIME_SWITCHOBJECTS,3	; 16/8/11 by calculation. 72 cycles -->  ceil(72/64)+1 --> 3 Object stack switchover
      1  0000 ????			   SEGTIME_SWITCHOBJECTS SET	3
      2  0000 ????	       00 00	   TEST_SEGTIME_SWITCHOBJECTS =	0
------- FILE ./sokoboo.asm
     10  0000 ????
     11  0000 ????						;FIXED_BANK		 = 3 * 2048	      ;-->  8K ROM tested OK
     12  0000 ????						;FIXED_BANK		  = 7 * 2048	      ;-->  16K ROM tested OK
     13  0000 ????	       78 00	   FIXED_BANK =	15 * 2048	; ->> 32K
     14  0000 ????						;FIXED_BANK		 = 239 * 2048	      ;--> 480K ROM tested OK (KK/CC2 compatibility)
     15  0000 ????						;FIXED_BANK		 = 127 * 2048	      ;--> 256K ROM tested OK
     16  0000 ????						;FIXED_BANK		 = 255 * 2048	      ;--> 512K ROM tested OK (CC2 can't handle this)
     17  0000 ????
     18  0000 ????	       00 01	   YES	      =	1
     19  0000 ????	       00 00	   NO	      =	0
     20  0000 ????
     21  0000 ????	       00 00	   DEBUG      =	NO
     22  0000 ????
     23  0000 ????	       00 00	   TJ_MODE    =	NO	; some changes which TJ prefers
     24  0000 ????	       00 01	   AD_MODE    =	YES	; some changes which AD prefers
     25  0000 ????
     26  0000 ????			  -	      IF	TJ_MODE && AD_MODE
     27  0000 ????			  -	      ECHO	"ERROR: Both TJ_MODE and AD_MODE set. Can't do both TJ and AD at the same time!"
     28  0000 ????			  -	      ERR
     29  0000 ????				      ENDIF
     30  0000 ????
     31  0000 ????
     32  0000 ????						; Note: you may also need to change the emulator "-format" switch in the Makefile.
     33  0000 ????
     34  0000 ????			   NTSC_MODE  SET	NO
     35  0000 ????
     36  0000 ????			  -	      IF	TJ_MODE
     37  0000 ????			  -NTSC_MODE  SET	NO	; force NTSC or PAL for difficulty switch
     38  0000 ????				      ENDIF
     39  0000 ????				      IF	AD_MODE
     40  0000 ????			   NTSC_MODE  SET	NO
     41  0000 ????				      ENDIF
     42  0000 ????
     43  0000 ????
     44  0000 ????
     45  0000 ????						;===================================
     46  0000 ????	       00 00	   FINAL_VERSION =	NO	; this OVERRIDES any selections below and sets everything correct for a final release
     47  0000 ????						;===================================
     48  0000 ????
     49  0000 ????						;-------------------------------------------------------------------------------
     50  0000 ????						; The following should be YES for the final or DEMO version
     51  0000 ????			   EMBED_COPYRIGHT SET	YES	; place embedded copyright notice in binary (hex string)
     52  0000 ????
     53  0000 ????						;-------------------------------------------------------------------------------
     54  0000 ????						; The following are optional YES/NO depending on phase of the moon
     55  0000 ????			   L276       SET	YES	; use 276 line display for NTSC
     56  0000 ????						;-------------------------------------------------------------------------------
     57  0000 ????
     58  0000 ????	       00 01	   NUMPLAYERS =	1	; 1-indexed
     59  0000 ????	       00 05	   NUM_LEVELS =	5
     60  0000 ????			   NUM_LIVES  SET	3	; use -1 for unlimited lives
     61  0000 ????
     62  0000 ????			   DEMO_DELAY SET	1	; number of music loops without joystick input before demo kicks in
     63  0000 ????
     64  0000 ????						;-------------------------------------------------------------------------------
     65  0000 ????						; DO NOT MODIFY THE BELOW SETTINGS -- USE THE ONES ABOVE!
     66  0000 ????						; Here we make sure everyting is OK based on the single switch -- less chance for accidents
     67  0000 ????			  -	      IF	FINAL_VERSION = YES
     68  0000 ????			  -L276       SET	YES	; use 276 line display for NTSC
     69  0000 ????			  -SHOWTARGETP SET	NO	; debug show TARGET on P
     70  0000 ????			  -
     71  0000 ????			  -NUM_LIVES  SET	3	; use -1 for unlimited lives
     72  0000 ????			  -DEMO_DELAY SET	2	; number of music loops without joystick input before demo kicks in
     73  0000 ????			  -NTSC_MODE  SET	YES	; mmh
     74  0000 ????				      ENDIF
     75  0000 ????
     76  0000 ????						;-------------------------------------------------------------------------------
     77  0000 ????
     78  0000 ????	       00 01	   COMPILE_ILLEGALOPCODES =	1
     79  0000 ????	       00 0c	   RESERVED_FOR_STACK =	12	; bytes guaranteed not overwritten by variable use
     80  0000 ????
     81  0000 ????
     82  0000 ????	       00 01	   PUSH_LIMIT =	1	; slowdown when pushing on a BOX
     83  0000 ????
     84  0000 ????						; time bonus countdown constants:
     85  0000 ????	       00 ff	   EXTRA_LIFE_TIMER =	255	; Cosmic Ark star effect on extra life. Should be 5 seconds like in original
     86  0000 ????	       00 3c	   SCORING_TIMER =	60	; ~1.0 second
     87  0000 ????	       00 96	   SCORING_TIMER_FIRST =	150	; begin level timer is long to show level/lives clearly
     88  0000 ????
     89  0000 ????	       00 07	   DIRECTION_BITS =	%111	; for ManLastDirection
     90  0000 ????
     91  0000 ????	       00 03	   FACE_LEFT  =	3
     92  0000 ????
     93  0000 ????	       00 a0	   MAX_THROTTLE =	160	; must be small enough to allow ~2 * max add value overflow (<256 - 2*max throttle value!)
     94  0000 ????
     95  0000 ????						;scoring flags contants:
     96  0000 ????	       00 03	   DISPLAY_FLAGS =	%11
     97  0000 ????	       00 00	   DISPLAY_TIME =	%00
     98  0000 ????	       00 01	   DISPLAY_SCORE =	%01
     99  0000 ????	       00 02	   DISPLAY_LIVES =	%10
    100  0000 ????	       00 03	   DISPLAY_HIGH =	%11
    101  0000 ????
    102  0000 ????						;------------------------------------------------------------------------------
    103  0000 ????
    104  0000 ????	       00 01	   MIRRORED_BOX =	YES
    105  0000 ????	       00 01	   MIRRORED_STEEL =	YES
    106  0000 ????	       00 01	   MIRRORED_WALL =	YES
    107  0000 ????
    108  0000 ????						;------------------------------------------------------------------------------
    109  0000 ????
    110  0000 ????	       00 0a	   SCREEN_WIDTH =	10	; board characters per line (DIFFICULT TO CHANGE)
    111  0000 ????
    112  0000 ????	       00 08	   SCREEN_LINES =	8	; number of scanlines in screen buffer
    113  0000 ????	       00 15	   LINES_PER_CHAR =	21	; MULTIPLE OF 3 SO RGB INTERFACES CHARS OK
    114  0000 ????
    115  0000 ????	       00 50	   SCREEN_ARRAY_SIZE =	SCREEN_WIDTH * SCREEN_LINES
    116  0000 ????
    117  0000 ????
    118  0000 ????	       00 3f	   SET_BANK   =	$3F	; write address to switch ROM banks
    119  0000 ????	       00 3e	   SET_BANK_RAM =	$3E	; write address to switch RAM banks
    120  0000 ????
    121  0000 ????
    122  0000 ????						; color constants:
    123  0000 ????	       00 0e	   WHITE      =	$0e	; bright white, for NTSC and PAL
    124  0000 ????
    125  0000 ????	       00 10	   YELLOW_NTSC =	$10
    126  0000 ????	       00 20	   YELLOW_PAL =	$20
    127  0000 ????
    128  0000 ????
    129  0000 ????	       10 00	   RAM_3E     =	$1000
    130  0000 ????	       04 00	   RAM_SIZE   =	$400
    131  0000 ????	       04 00	   RAM_WRITE  =	$400	; add this to RAM address when doing writes
    132  0000 ????
    133  0000 ????
    134  0000 ????	       00 b4	   RND_EOR_VAL =	$b4
    135  0000 ????
    136  0000 ????
    137  0000 ????						; Platform constants:
    138  0000 ????	       00 02	   PAL	      =	%10
    139  0000 ????	       00 02	   PAL_50     =	PAL|0
    140  0000 ????	       00 03	   PAL_60     =	PAL|1
    141  0000 ????
    142  0000 ????
    143  0000 ????				      IF	L276
    144  0000 ????	       00 3e	   VBLANK_TIM_NTSC =	62	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    145  0000 ????			  -	      ELSE
    146  0000 ????			  -VBLANK_TIM_NTSC =	45	; NTSC 262
    147  0000 ????				      ENDIF
    148  0000 ????	       00 55	   VBLANK_TIM_PAL =	85	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    149  0000 ????
    150  0000 ????				      IF	L276
    151  0000 ????	       00 33	   OVERSCAN_TIM_NTSC =	51	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    152  0000 ????			  -	      ELSE
    153  0000 ????			  -OVERSCAN_TIM_NTSC =	51	; NTSC 262
    154  0000 ????				      ENDIF
    155  0000 ????	       00 46	   OVERSCAN_TIM_PAL =	70	; PAL 312 (we could increase this too, if we want to, but I suppose the used vertical screen size would become very small then)
    156  0000 ????
    157  0000 ????				      IF	L276
    158  0000 ????	       01 14	   SCANLINES_NTSC =	276	; NTSC 276 (Desert Falcon does 280, so this should be pretty safe)
    159  0000 ????			  -	      ELSE
    160  0000 ????			  -SCANLINES_NTSC =	262	; NTSC 262
    161  0000 ????				      ENDIF
    162  0000 ????	       01 38	   SCANLINES_PAL =	312
    163  0000 ????
    164  0000 ????
    165  0000 ????						;------------------------------------------------------------------------------
    166  0000 ????						; MACRO definitions
    167  0000 ????
    168  0000 ????	       08 00	   ROM_BANK_SIZE =	$800
    169  0000 ????
    170  0000 ????				      MAC	newbank
    171  0000 ????				      SEG	{1}
    172  0000 ????				      ORG	ORIGIN
    173  0000 ????				      RORG	$F000
    174  0000 ????			   BANK_START SET	*
    175  0000 ????			   {1}	      SET	ORIGIN / 2048
    176  0000 ????			   ORIGIN     SET	ORIGIN + 2048
    177  0000 ????			   _CURRENT_BANK SET	{1}
    178  0000 ????				      ENDM		; bank name
    179  0000 ????
    180  0000 ????				      MAC	define_1k_segment
    181  0000 ????				      ALIGN	$400
    182  0000 ????			   SEGMENT_{1} SET	*
    183  0000 ????			   BANK_{1}   SET	_CURRENT_BANK
    184  0000 ????				      ENDM		; {seg name}
    185  0000 ????
    186  0000 ????				      MAC	check_bank_size
    187  0000 ????			   .TEMP      =	* - BANK_START
    188  0000 ????				      ECHO	{1}, "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
    189  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE
    190  0000 ????				      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
    191  0000 ????				      ERR
    192  0000 ????				      endif
    193  0000 ????				      ENDM		; name
    194  0000 ????
    195  0000 ????
    196  0000 ????				      MAC	check_half_bank_size
    197  0000 ????						; This macro is for checking the first 1K of ROM bank data that is to be copied to RAM.
    198  0000 ????						; Note that these ROM banks can contain 2K, so this macro will generally go 'halfway'
    199  0000 ????			   .TEMP      =	* - BANK_START
    200  0000 ????				      ECHO	{1}, "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
    201  0000 ????				      if	( .TEMP ) > ROM_BANK_SIZE/2
    202  0000 ????				      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
    203  0000 ????				      ERR
    204  0000 ????				      endif
    205  0000 ????				      ENDM		; name
    206  0000 ????
    207  0000 ????
    208  0000 ????				      MAC	overlay
    209  0000 ????				      SEG.U	OVERLAY_{1}
    210  0000 ????				      org	Overlay
    211  0000 ????				      ENDM		; {name}
    212  0000 ????
    213  0000 ????						;--------------------------------------------------------------------------
    214  0000 ????
    215  0000 ????				      MAC	validate_overlay
    216  0000 ????				      LIST	OFF
    217  0000 ????				      if	* - Overlay > OVERLAY_SIZE
    218  0000 ????				      ERR
    219  0000 ????				      endif
    220  0000 ????				      LIST	ON
    221  0000 ????				      ENDM
    222  0000 ????
    223  0000 ????						;--------------------------------------------------------------------------
    224  0000 ????						; Macro inserts a page break if the object would overlap a page
    225  0000 ????
    226  0000 ????				      MAC	optional_pagebreak
    227  0000 ????				      LIST	OFF
    228  0000 ????				      IF	(>( * + {2} -1 )) > ( >* )
    229  0000 ????			   EARLY_LOCATION SET	*
    230  0000 ????				      ALIGN	256
    231  0000 ????				      ECHO	"PAGE BREAK INSERTED FOR ", {1}
    232  0000 ????				      ECHO	"REQUESTED SIZE = ", {2}
    233  0000 ????				      ECHO	"WASTED SPACE = ", *-EARLY_LOCATION
    234  0000 ????				      ECHO	"PAGEBREAK LOCATION = ", *
    235  0000 ????				      ENDIF
    236  0000 ????				      LIST	ON
    237  0000 ????				      ENDM		; { string, size }
    238  0000 ????
    239  0000 ????
    240  0000 ????				      MAC	check_page_crossing
    241  0000 ????				      LIST	OFF
    242  0000 ????				      if	( >BLOCK_END != >BLOCK_START )
    243  0000 ????				      ECHO	"PAGE CROSSING @ ", BLOCK_START
    244  0000 ????				      endif
    245  0000 ????				      LIST	ON
    246  0000 ????				      ENDM
    247  0000 ????
    248  0000 ????				      MAC	checkpage
    249  0000 ????				      LIST	OFF
    250  0000 ????				      IF	>. != >{1}
    251  0000 ????				      ECHO	""
    252  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    253  0000 ????				      ECHO	""
    254  0000 ????				      ERR
    255  0000 ????				      ENDIF
    256  0000 ????				      LIST	ON
    257  0000 ????				      ENDM
    258  0000 ????
    259  0000 ????				      MAC	checkpagex
    260  0000 ????				      LIST	OFF
    261  0000 ????				      IF	>. != >{1}
    262  0000 ????				      ECHO	""
    263  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ") @ {0}"
    264  0000 ????				      ECHO	{2}
    265  0000 ????				      ECHO	""
    266  0000 ????				      ERR
    267  0000 ????				      ENDIF
    268  0000 ????				      LIST	ON
    269  0000 ????				      ENDM
    270  0000 ????
    271  0000 ????
    272  0000 ????				      MAC	checkpage_bne
    273  0000 ????				      LIST	OFF
    274  0000 ????				      IF	0	;>(. + 2) != >{1}
    275  0000 ????				      ECHO	""
    276  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    277  0000 ????				      ECHO	""
    278  0000 ????				      ERR
    279  0000 ????				      ENDIF
    280  0000 ????				      LIST	ON
    281  0000 ????				      bne	{1}
    282  0000 ????				      ENDM
    283  0000 ????
    284  0000 ????				      MAC	checkpage_bpl
    285  0000 ????				      LIST	OFF
    286  0000 ????				      IF	(>(.+2 )) != >{1}
    287  0000 ????				      ECHO	""
    288  0000 ????				      ECHO	"ERROR: different pages! (", {1}, ",", ., ")"
    289  0000 ????				      ECHO	""
    290  0000 ????				      ERR
    291  0000 ????				      ENDIF
    292  0000 ????				      LIST	ON
    293  0000 ????				      bpl	{1}
    294  0000 ????				      ENDM
    295  0000 ????
    296  0000 ????				      MAC	align_free
    297  0000 ????			   FREE       SET	FREE - .
    298  0000 ????				      align	{1}
    299  0000 ????			   FREE       SET	FREE + .
    300  0000 ????				      echo	"@", ., ":", FREE
    301  0000 ????				      ENDM
    302  0000 ????
    303  0000 ????				      MAC	stress_time
    304  0000 ????				      IF	TEST_{1} = 1
    305  0000 ????
    306  0000 ????
    307  0000 ????						;LIST OFF
    308  0000 ????						; has to be put *directly* after cmp #SEGTIME_... , bcc abort
    309  0000 ????						;LIST ON
    310  0000 ????				      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
    311  0000 ????				      bne	. - 7	; branches to lda INTIM
    312  0000 ????				      ENDIF
    313  0000 ????				      ENDM
    314  0000 ????
    315  0000 ????			   IDENTITY   SET	0
    316  0000 ????				      MAC	ident
    317  0000 ????				      if	DEBUG=YES
    318  0000 ????				      lda	#IDENTITY
    319  0000 ????				      sta	debug_ident
    320  0000 ????				      lda	{1}
    321  0000 ????				      sta	debug_object
    322  0000 ????				      endif
    323  0000 ????			   IDENTITY   SET	IDENTITY + 1
    324  0000 ????				      ENDM		; {object}
    325  0000 ????
    326  0000 ????						;--------------------------------------------------------------------------
    327  0000 ????
    328  0000 ????				      MAC	vector
    329  0000 ????				      .word	{1}
    330  0000 ????				      ENDM		; just a word pointer to code
    331  0000 ????
    332  0000 ????
    333  0000 ????				      MAC	define_subroutine
    334  0000 ????			   BANK_{1}   =	_CURRENT_BANK	; bank in which this subroutine resides
    335  0000 ????				      SUBROUTINE		; keep everything local
    336  0000 ????			   {1}			; entry point
    337  0000 ????				      ENDM		; name of subroutine
    338  0000 ????
    339  0000 ????
    340  0000 ????
    341  0000 ????						;--------------------------------------------------------------------------
    342  0000 ????
    343  0000 ????				      MAC	newrambank
    344  0000 ????				      SEG.U	{1}
    345  0000 ????				      ORG	ORIGIN
    346  0000 ????				      RORG	RAM_3E
    347  0000 ????			   BANK_START SET	*
    348  0000 ????			   {1}	      SET	ORIGIN / RAM_SIZE
    349  0000 ????			   ORIGIN     SET	ORIGIN + RAM_SIZE
    350  0000 ????				      ENDM		; bank name
    351  0000 ????
    352  0000 ????				      MAC	validate_ram_size
    353  0000 ????				      if	* - RAM_3E > RAM_SIZE
    354  0000 ????				      ERR
    355  0000 ????				      endif
    356  0000 ????				      ENDM
    357  0000 ????
    358  0000 ????				      MAC	next_random
    359  0000 ????						; update random value:
    360  0000 ????				      lda	rnd	; 3
    361  0000 ????				      lsr		; 2
    362  0000 ????				      IFCONST	rndHi
    363  0000 ????				      ror	rndHi	; 5	 16 bit LFSR
    364  0000 ????				      ENDIF
    365  0000 ????				      bcc	.skipEOR	; 2/3
    366  0000 ????				      eor	#RND_EOR_VAL	; 2
    367  0000 ????			   .skipEOR
    368  0000 ????				      sta	rnd	; 3 = 14/19
    369  0000 ????				      ENDM
    370  0000 ????
    371  0000 ????				      MAC	resync
    372  0000 ????						; resync screen, X and Y == 0 afterwards
    373  0000 ????				      lda	#%10	; make sure VBLANK is ON
    374  0000 ????				      sta	VBLANK
    375  0000 ????
    376  0000 ????				      ldx	#8	; 5 or more RESYNC_FRAMES
    377  0000 ????			   .loopResync
    378  0000 ????				      VERTICAL_SYNC
    379  0000 ????
    380  0000 ????				      ldy	#SCANLINES_NTSC/2 - 2
    381  0000 ????				      lda	Platform
    382  0000 ????				      eor	#PAL_50	; PAL-50?
    383  0000 ????				      bne	.ntsc
    384  0000 ????				      ldy	#SCANLINES_PAL/2 - 2
    385  0000 ????			   .ntsc
    386  0000 ????			   .loopWait
    387  0000 ????				      sta	WSYNC
    388  0000 ????				      sta	WSYNC
    389  0000 ????				      dey
    390  0000 ????				      bne	.loopWait
    391  0000 ????				      dex
    392  0000 ????				      bne	.loopResync
    393  0000 ????				      ENDM
    394  0000 ????
    395  0000 ????				      MAC	set_platform
    396  0000 ????						; 00 = NTSC
    397  0000 ????						; 01 = NTSC
    398  0000 ????						; 10 = PAL-50
    399  0000 ????						; 11 = PAL-60
    400  0000 ????				      lda	SWCHB
    401  0000 ????				      rol
    402  0000 ????				      rol
    403  0000 ????				      rol
    404  0000 ????				      and	#%11
    405  0000 ????				      if	NTSC_MODE = NO
    406  0000 ????				      eor	#PAL
    407  0000 ????				      endif
    408  0000 ????				      lda	#0	;tmp
    409  0000 ????				      sta	Platform	; P1 difficulty --> TV system (0=NTSC, 1=PAL)
    410  0000 ????				      ENDM
    411  0000 ????
    412  0000 ????						;  IF TJ_MODE
    413  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM ; = 29
    414  0000 ????						;	  ldy #{1}			  ; 2	  read bank
    415  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    416  0000 ????						;	  jsr GetRAMByteFromRAM 	  ;25
    417  0000 ????						;    ENDM
    418  0000 ????						;
    419  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM ; = 30
    420  0000 ????						;	  ldy #{1}			  ; 2	  write bank
    421  0000 ????						;	  ldx #{2}			  ; 2	  return bank
    422  0000 ????						;	  jsr PutRAMByteFromRAM 	  ;26
    423  0000 ????						;    ENDM
    424  0000 ????						;
    425  0000 ????						;    MAC GET_RAM_BYTE_FROM_RAM_ADR ; = 39
    426  0000 ????						;	  ldx #<{1}			  ; 2
    427  0000 ????						;	  stx addressR			  ; 3
    428  0000 ????						;	  ldx #>{1}			  ; 2
    429  0000 ????						;	  stx addressR+1		  ; 3
    430  0000 ????						;	  GET_RAM_BYTE_FROM_RAM {2}, {3}  ;29
    431  0000 ????						;    ENDM
    432  0000 ????						;
    433  0000 ????						;    MAC PUT_RAM_BYTE_FROM_RAM_ADR ; = 40
    434  0000 ????						;	  ldx #<{1}			  ; 2
    435  0000 ????						;	  stx addressW			  ; 3
    436  0000 ????						;	  ldx #>({1}+RAM_WRITE) 	  ; 2
    437  0000 ????						;	  stx addressW+1		  ; 3
    438  0000 ????						;	  PUT_RAM_BYTE_FROM_RAM {2}, {3}  ;30
    439  0000 ????						;    ENDM
    440  0000 ????						;  ENDIF
    441  0000 ????
    442  0000 ????				      MAC	nop_b
    443  0000 ????				      .byte	$82
    444  0000 ????				      ENDM		; unused
    445  0000 ????
    446  0000 ????				      MAC	nop_w
    447  0000 ????				      .byte	$0c
    448  0000 ????				      ENDM
    449  0000 ????
    450  0000 ????						;------------------------------------------------------------------------------
    451  0000 ????
    452  0000 ????
------- FILE zeropage.asm LEVEL 2 PASS 3
      0  0000 ????				      include	"zeropage.asm"
      1  0000 ????
      2 U00f4 ????				      SEG.U	variables
      3 U0080					      ORG	$80
      4 U0080
      5 U0080
      6 U0080		       00 40	   GAMEMODE_2600 =	64
      7 U0080		       00 80	   GAMEMODE_PAUSED =	128
      8 U0080
      9 U0080		       00	   gameMode   ds	1	; bit7=0: 7800; bit7=1: 2600.	bit 6=1: paused: bit3: toggle bit for B/W
     10 U0081		       00	   Platform   ds	1	; TV system (%0x=NTSC, %10=PAL-50, %11=PAL-60)
     11 U0082							; above variables are preserved ALL the time!
     12 U0082
     13 U0082		       00	   rnd	      ds	1
     14 U0083		       00	   rndHi      ds	1	; to get better random values
     15 U0084
     16 U0084		       00	   DrawStackPointer ds	1	; points to start entry of drawing stack (-1 = nothing to draw)
     17 U0085		       00	   ObjStackNum ds	1	; which stack in use
     18 U0086		       00 00	   ObjStackPtr ds	2	; index to objects on object stack (0 = empty)
     19 U0088		       00	   BlankStackPtr ds	1	; index to blank object stack (0=empty)
     20 U0089		       00	   ScreenDrawPhase ds	1	; phase of screen drawing
     21 U008a
     22 U008a		       00	   POS_X      ds	1
     23 U008b		       00	   POS_Y      ds	1
     24 U008c		       00	   POS_X_NEW  ds	1
     25 U008d		       00	   POS_Y_NEW  ds	1
     26 U008e		       00	   POS_Type   ds	1
     27 U008f		       00	   POS_VAR    ds	1
     28 U0090
     29 U0090		       00 00	   BufferedJoystick ds	2	; player joystick input
     30 U0092		       00 00	   BufferedButton ds	2	; player button press
     31 U0094
     32 U0094							; Scrolling is limited to only show board within the following area...
     33 U0094		       00	   BoardLimit_Width ds	1	; width of current playfield (only used in UnpackLevel)
     34 U0095		       00	   BoardLimit_Height ds	1	; height of current playfield (only used in UnpackLevel)
     35 U0096		       00	   BoardScrollY ds	1	; scroll position in board (Y)
     36 U0097		       00	   BoardScrollX ds	1	; scroll position in board (X)
     37 U0097		       00 94	   BoardEdge_Right =	BoardLimit_Width	; absolute rightmost scroll value
     38 U0097		       00 95	   BoardEdge_Bottom =	BoardLimit_Height	; absolute bottommost scroll value
     39 U0098		       00	   scrollBits ds	1
     40 U0099
     41 U0099		       00	   whichPlayer ds	1	; 0 = P1, 1 = P2
     42 U009a		       00	   manAnimationIndex ds	1
     43 U009b		       00	   ManX       ds	1
     44 U009c		       00	   ManY       ds	1
     45 U009d		       00	   ManDrawX   ds	1
     46 U009e		       00	   ManDrawY   ds	1
     47 U009f		       00	   ManMode    ds	1
     48 U00a0		       00	   ManDelayCount ds	1
     49 U00a1		       00 00	   ManAnimation ds	2
     50 U00a3		       00	   ManAnimationFrameLO ds	1
     51 U00a4		       00	   ManLastDirection ds	1	; so we don't overwrite animations in-progress
     52 U00a5		       00	   ManPushCounter ds	1
     53 U00a6		       00	   LookingAround ds	1
     54 U00a7		       00	   ManCount   ds	1	; player life counter
     55 U00a8		       00	   jtoggle    ds	1	; 0/1 toggles joystick on player swapping
     56 U00a9		       00 00	   circle_d   ds	2
     57 U00ab		       00	   circ_x     ds	1
     58 U00ac		       00	   circ_y     ds	1
     59 U00ad		       00	   circ_char  ds	1
     60 U00ae		       00	   circ_scratch ds	1
     61 U00af		       00	   LEVEL_bank ds	1
     62 U00b0							;---------------------------------------------------------------------------
     63 U00b0							; 2 (shared) demo mode variables:
     64 U00b0		       00 a8	   demoMode   =	jtoggle	; bit 7==1 => demo mode
     65 U00b0		       00 a8	   moveLen    =	jtoggle	; bits 0..6
     66 U00b0		       00 99	   moveIdx    =	whichPlayer
     67 U00b0
     68 U00b0		       00	   LastSpriteY ds	1
     69 U00b1
     70 U00b1		       00	   timer      ds	1
     71 U00b2
     72 U00b2		       00	   BGColour   ds	1
     73 U00b3
     74 U00b3							; levelx and level have to be consecutive variables!
     75 U00b3		       00	   levelX     ds	1	; current player's level (other in scoring bank)
     76 U00b4		       00	   level      ds	1	; current player's level (other in scoring bank)
     77 U00b5		       00	   levelDisplay ds	1	; what to display as the level ID
     78 U00b6		       00	   Throttle   ds	1	; frame throttle to prevent super-speeds
     79 U00b7		       00	   ThrottleSpeed ds	1	; system-dependant throttle speed
     80 U00b8
     81 U00b8		       00	   targetsRequired ds	1	; number of un-targeted left to go
     82 U00b9		       00	   moveCounter ds	1	; BCD seconds for level
     83 U00ba		       00	   moveCounterHi ds	1
     84 U00bb		       00 00 00    color      ds	3	; RGB for NTSC, RGB for PAL
     85 U00be		       00 00	   Board_AddressR ds	2
     86 U00c0		       00 00	   Board_AddressW ds	2
     87 U00c2		       00	   ROM_Bank   ds	1	; last switched ROM bank (not accessible if RAM subsequently switched)
     88 U00c3		       00	   RAM_Bank   ds	1
     89 U00c4
     90 U00c4		       00	   ColourTimer ds	1	; colour of BG in scoring area to show level flash/complete
     91 U00c5		       00	   extraLifeTimer ds	1	; should be 5 seconds!
     92 U00c6
     93 U00c6							; extraLifeTimer:
     94 U00c6							;   When non-zero causes Cosmic Ark star effect in background. Used to indicate extra life.
     95 U00c6
     96 U00c6		       00	   scoringTimer ds	1	; times the various score displays
     97 U00c7		       00	   scoringFlags ds	1	; scoring flags are stored here
     98 U00c8
     99 U00c8							; scoringFlags:
    100 U00c8							; D7		 Extra TARGETs in effect (TARGETs collected over requirement score more) ASSUMED BPL/BMI usage
    101 U00c8							; D6		 unused
    102 U00c8							; D5		 unused
    103 U00c8							; D4		 unused
    104 U00c8							; D3		 unused
    105 U00c8							; D2		 unused
    106 U00c8							; D1	 D1-D0	 Which display kernel to use for scoring
    107 U00c8							; D0		 0 = 2x4     used for TARGETs/time
    108 U00c8							;		 1 = 1x6     used for score
    109 U00c8							;		 2 = 3x2     used for level/lives/player
    110 U00c8
    111 U00c8		       00	   NextLevelTrigger ds	1	; d7 -- next level.  d6 -- loss of life
    112 U00c8		       00 80	   BIT_NEXTLEVEL =	128
    113 U00c8		       00 40	   BIT_NEXTLIFE =	64
    114 U00c9
    115 U00c9							;---------------------------------------------------------------------------
    116 U00c9
    117 U00c9		       00	   sortRequired ds	1
    118 U00ca		       00	   sortPtr    ds	1
    119 U00cb
    120 U00cb							;------------------------------------------------------------------------------
    121 U00cb
    122 U00cb		       00	   ObjIterator ds	1	; count UP iterator over objects
    123 U00cc		       00	   DSL	      ds	1	; stack line counter
    124 U00cd
------- FILE sound/intro1_variables.asm LEVEL 3 PASS 3
      0 U00cd					      include	"sound/intro1_variables.asm"
      1 U00cd							; TIATracker music player
      2 U00cd							; Copyright 2016 Andre "Kylearan" Wichmann
      3 U00cd							; Website: https://bitbucket.org/kylearan/tiatracker
      4 U00cd							; Email: andre.wichmann@gmx.de
      5 U00cd							;
      6 U00cd							; Licensed under the Apache License, Version 2.0 (the "License");
      7 U00cd							; you may not use this file except in compliance with the License.
      8 U00cd							; You may obtain a copy of the License at
      9 U00cd							;
     10 U00cd							;   http://www.apache.org/licenses/LICENSE-2.0
     11 U00cd							;
     12 U00cd							; Unless required by applicable law or agreed to in writing, software
     13 U00cd							; distributed under the License is distributed on an "AS IS" BASIS,
     14 U00cd							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15 U00cd							; See the License for the specific language governing permissions and
     16 U00cd							; limitations under the License.
     17 U00cd
     18 U00cd							; Song author: 
     19 U00cd							; Song name: 
     20 U00cd
     21 U00cd							; @com.wudsn.ide.asm.hardware=ATARI2600
     22 U00cd
     23 U00cd							; =====================================================================
     24 U00cd							; Flags
     25 U00cd							; =====================================================================
     26 U00cd
     27 U00cd							; 1: Global song speed, 0: Each pattern has individual speed
     28 U00cd		       00 01	   TT_GLOBAL_SPEED =	1
     29 U00cd							; duration (number of TV frames) of a note
     30 U00cd		       00 05	   TT_SPEED   =	5
     31 U00cd							; duration of odd frames (needs TT_USE_FUNKTEMPO)
     32 U00cd		       00 04	   TT_ODD_SPEED =	4
     33 U00cd
     34 U00cd							; 1: Overlay percussion, +40 bytes
     35 U00cd		       00 01	   TT_USE_OVERLAY =	1
     36 U00cd							; 1: Melodic instrument slide, +9 bytes
     37 U00cd		       00 00	   TT_USE_SLIDE =	0
     38 U00cd							; 1: Goto pattern, +8 bytes
     39 U00cd		       00 01	   TT_USE_GOTO =	1
     40 U00cd							; 1: Odd/even rows have different SPEED values, +7 bytes
     41 U00cd		       00 01	   TT_USE_FUNKTEMPO =	1
     42 U00cd							; If the very first notes played on each channel are not PAUSE, HOLD or
     43 U00cd							; SLIDE, i.e. if they start with an instrument or percussion, then set
     44 U00cd							; this flag to 0 to save 2 bytes.
     45 U00cd							; 0: +2 bytes
     46 U00cd		       00 01	   TT_STARTS_WITH_NOTES =	1
     47 U00cd
     48 U00cd
     49 U00cd							; =====================================================================
     50 U00cd							; Permanent variables. These are states needed by the player.
     51 U00cd							; =====================================================================
     52 U00cd		       00	   tt_timer   ds	1	; current music timer value
     53 U00ce		       00	   tt_cur_pat_index_c0 ds	1	; current pattern index into tt_SequenceTable
     54 U00cf		       00	   tt_cur_pat_index_c1 ds	1
     55 U00d0		       00	   tt_cur_note_index_c0 ds	1	; note index into current pattern
     56 U00d1		       00	   tt_cur_note_index_c1 ds	1
     57 U00d2		       00	   tt_envelope_index_c0 ds	1	; index into ADSR envelope
     58 U00d3		       00	   tt_envelope_index_c1 ds	1
     59 U00d4		       00	   tt_cur_ins_c0 ds	1	; current instrument
     60 U00d5		       00	   tt_cur_ins_c1 ds	1
     61 U00d6
     62 U00d6
     63 U00d6							; =====================================================================
     64 U00d6							; Temporary variables. These will be overwritten during a call to the
     65 U00d6							; player routine, but can be used between calls for other things.
     66 U00d6							; =====================================================================
     67 U00d6		       00 00	   tt_ptr     ds	2
------- FILE zeropage.asm
    126 U00d8
    127 U00d8
    128 U00d8
    129 U00d8				   OVERLAY_SIZE SET	16
    130 U00d8
    131 U00d8
    132 U00d8
    133 U00d8							; This overlay variable is used for the overlay variables.  That's OK.
    134 U00d8							; However, it is positioned at the END of the variables so, if on the off chance we're overlapping
    135 U00d8							; stack space and variable, it is LIKELY that that won't be a problem, as the temp variables
    136 U00d8							; (especially the latter ones) are only used in rare occasions.
    137 U00d8
    138 U00d8							; FOR SAFETY, DO NOT USE THIS AREA DIRECTLY (ie: NEVER reference 'Overlay' in the code)
    139 U00d8							; ADD AN OVERLAY FOR EACH ROUTINE'S USE, SO CLASHES CAN BE EASILY CHECKED
    140 U00d8
    141 U00d8		       00 00 00 00*Overlay    ds	OVERLAY_SIZE	;--> overlay (share) variables
      0 U00e8					      VALIDATE_OVERLAY
      5 U00e8					      LIST	ON
    143 U00e8
    144 U00e8
    145 U00e8		       00 00 00 00*	      ds	RESERVED_FOR_STACK
    146 U00f4
 FREE BYTES IN ZERO PAGE =  $b
    147 U00f4					      ECHO	"FREE BYTES IN ZERO PAGE = ", $FF - *
    148 U00f4				  -	      IF	* > $FF
    149 U00f4				  -	      ERR
    150 U00f4					      ENDIF
------- FILE ./sokoboo.asm
    454 U00f4
    455 U00f4
    456 U00f4							;------------------------------------------------------------------------------
    457 U00f4							; OVERLAYS!
    458 U00f4							; These variables are overlays, and should be managed with care
    459 U00f4							; That is, variables are ALREADY DEFINED, and we're reusing RAM for other purposes
    460 U00f4
    461 U00f4							; EACH OF THESE ARE VARIABLES (TEMPORARY) USED BY ONE ROUTINE (AND IT'S SUBROUTINES)
    462 U00f4							; THAT IS, LOCAL VARIABLES.  USE 'EM FREELY, THEY COST NOTHING
    463 U00f4
    464 U00f4							; TOTAL SPACE USED BY ANY OVERLAY GROUP SHOULD BE <= SIZE OF 'Overlay'
    465 U00f4
    466 U00f4
    467 U00f4
    468 U00f4							;------------------------------------------------------------------------------
      0 U00f4					      OVERLAY	BuildDrawFlags
      1 U00e3 ????				      SEG.U	OVERLAY_BuildDrawFlags
      2 U00d8					      org	Overlay
    470 U00d8
    471 U00d8		       00 00	   BDF_DrawFlagAddress ds	2	; destination address of draw flag (mirrors ScreenBuffer)
    472 U00da		       00 00	   BDF_DrawFlagAddress2 ds	2	; dito + SCREEN_WIDTH/2
    473 U00dc		       00 00	   BDF_BoardAddress ds	2	; source address from Board
    474 U00de		       00 00	   BDF_BoardAddress2 ds	2	; dito + SCREEN_WIDTH/2
    475 U00e0							;  IF MULTI_BANK_BOARD = YES		      ; commented, else DASM freaks out because MULTI_BANK_BOARD is calculated below
    476 U00e0		       00	   BDF_BoardBank ds	1	; holds bank of current line
    477 U00e1							;  ENDIF
    478 U00e1		       00	   DHS_Line   ds	1
    479 U00e2		       00	   DHS_Stack  ds	1	; for restoring SP
    480 U00e3							;ECHO "FREE BYTES IN OVERLAY_BuildDrawFlags = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e3					      VALIDATE_OVERLAY
      5 U00e3					      LIST	ON
    482 U00e3
    483 U00e3							;------------------------------------------------------------------------------
    484 U00e3
      0 U00e3					      OVERLAY	Process
      1 U00db ????				      SEG.U	OVERLAY_Process
      2 U00d8					      org	Overlay
    486 U00d8
    487 U00d8		       00	   BOXLeft    ds	1
    488 U00d9		       00	   BOXRight   ds	1
    489 U00da		       00	   restorationCharacter ds	1
    490 U00db
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    492 U00db
    493 U00db							;------------------------------------------------------------------------------
    494 U00db
      0 U00db					      OVERLAY	Animate
      1 U00d9 ????				      SEG.U	OVERLAY_Animate
      2 U00d8					      org	Overlay
    496 U00d8		       00	   halftimer  ds	1
      0 U00d9					      VALIDATE_OVERLAY
      5 U00d9					      LIST	ON
    498 U00d9
    499 U00d9							;------------------------------------------------------------------------------
    500 U00d9
      0 U00d9					      OVERLAY	TimeSlice
      1 U00da ????				      SEG.U	OVERLAY_TimeSlice
      2 U00d8					      org	Overlay
    502 U00d8
    503 U00d8		       00 00	   TS_Vector  ds	2	; vector to correct processing code
    504 U00da							;ECHO "FREE BYTES IN OVERLAY_TimeSlice = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00da					      VALIDATE_OVERLAY
      5 U00da					      LIST	ON
    506 U00da
    507 U00da							;------------------------------------------------------------------------------
    508 U00da
      0 U00da					      OVERLAY	CopyROMShadowToRAM
      1 U00db ????				      SEG.U	OVERLAY_CopyROMShadowToRAM
      2 U00d8					      org	Overlay
    510 U00d8
    511 U00d8		       00	   O_CopyCount ds	1
    512 U00d9		       00	   O_ROM_Source_Bank ds	1
    513 U00da		       00	   O_Index    ds	1
    514 U00db							;ECHO "FREE BYTES IN OVERLAY_CopyROMShadowToRAM = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00db					      VALIDATE_OVERLAY
      5 U00db					      LIST	ON
    516 U00db
    517 U00db							;------------------------------------------------------------------------------
    518 U00db
      0 U00db					      OVERLAY	Scoring
      1 U00da ????				      SEG.U	OVERLAY_Scoring
      2 U00d8					      org	Overlay
    520 U00d8		       00	   tmpStack   ds	1
    521 U00d8		       00 d8	   newDisplay =	tmpStack
    522 U00d9							; also for UpdateTimer
    523 U00d9		       00 d8	   tmpSound   =	tmpStack
    524 U00d9		       00	   timerLoops ds	1
      0 U00da					      VALIDATE_OVERLAY
      5 U00da					      LIST	ON
    526 U00da
    527 U00da
    528 U00da							;------------------------------------------------------------------------------
    529 U00da
      0 U00da					      OVERLAY	SaveKey
      1 U00e1 ????				      SEG.U	OVERLAY_SaveKey
      2 U00d8					      org	Overlay
    531 U00d8
    532 U00d8		       00 00 00    dummySK    ds	3	; avoid getting overwritten by CopyROMShadowToRAM
    533 U00db		       00 00 00    highScoreSK ds	3
    534 U00de		       00	   startingLevel ds	1	; levelx * 5
    535 U00df		       00	   startLevel ds	1
    536 U00e0		       00	   offsetSK   ds	1	; for calculating the SK slot address
    537 U00e1
      0 U00e1					      VALIDATE_OVERLAY
      5 U00e1					      LIST	ON
    539 U00e1
    540 U00e1							;------------------------------------------------------------------------------
    541 U00e1
      0 U00e1					      OVERLAY	DrawMan
      1 U00da ????				      SEG.U	OVERLAY_DrawMan
      2 U00d8					      org	Overlay
    543 U00d8
    544 U00d8		       00 00	   MAN_Move   ds	2
    545 U00da
    546 U00da							;ECHO "FREE BYTES IN OVERLAY_DrawMan = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00da					      VALIDATE_OVERLAY
      5 U00da					      LIST	ON
    548 U00da
    549 U00da							;------------------------------------------------------------------------------
    550 U00da
      0 U00da					      OVERLAY	ProcessObjStack
      1 U00da ????				      SEG.U	OVERLAY_ProcessObjStack
      2 U00d8					      org	Overlay
    552 U00d8
    553 U00d8		       00 00	   POS_Vector ds	2
    554 U00da
    555 U00da							;ECHO "FREE BYTES IN OVERLAY_ProcessObjStack = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00da					      VALIDATE_OVERLAY
      5 U00da					      LIST	ON
    557 U00da
    558 U00da							;------------------------------------------------------------------------------
    559 U00da
      0 U00da					      OVERLAY	ScoreLineOverlay
      1 U00e7 ????				      SEG.U	OVERLAY_ScoreLineOverlay
      2 U00d8					      org	Overlay
    561 U00d8
    562 U00d8		       00 00	   S0	      ds	2	; used for addressing digits of score
    563 U00da		       00 00	   S1	      ds	2
    564 U00dc		       00 00	   S2	      ds	2
    565 U00de		       00 00	   S3	      ds	2
    566 U00e0		       00 00	   S4	      ds	2
    567 U00e2		       00 00	   S5	      ds	2
    568 U00e4
    569 U00e4		       00	   stkp       ds	1
    570 U00e5		       00	   sreg       ds	1
    571 U00e6		       00	   loop       ds	1
    572 U00e7
    573 U00e7							;ECHO "FREE BYTES IN ScoreLineOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00e7					      VALIDATE_OVERLAY
      5 U00e7					      LIST	ON
    575 U00e7
    576 U00e7							;------------------------------------------------------------------------------
    577 U00e7
    578 U00e7
      0 U00e7					      OVERLAY	UnpackLevelOverlay
      1 U00dd ????				      SEG.U	OVERLAY_UnpackLevelOverlay
      2 U00d8					      org	Overlay
    580 U00d8
    581 U00d8		       00	   base_x     ds	1
    582 U00d9		       00	   base_y     ds	1
    583 U00da		       00	   upk_length ds	1
    584 U00db		       00	   upk_column ds	1
    585 U00dc		       00	   upk_temp   ds	1
    586 U00dd
    587 U00dd							;ECHO "FREE BYTES IN UnpackLevelOverlay = ", OVERLAY_SIZE - ( * - Overlay )
      0 U00dd					      VALIDATE_OVERLAY
      5 U00dd					      LIST	ON
    589 U00dd
    590 U00dd							;------------------------------------------------------------------------------
    591 U00dd
      0 U00dd					      OVERLAY	ManProcessing
      1 U00da ????				      SEG.U	OVERLAY_ManProcessing
      2 U00d8					      org	Overlay
    593 U00d8		       00 00	   actionVector ds	2
      0 U00da					      VALIDATE_OVERLAY
      5 U00da					      LIST	ON
    595 U00da
      0 U00da					      OVERLAY	SetPlatformColours
      1 U00d9 ????				      SEG.U	OVERLAY_SetPlatformColours
      2 U00d8					      org	Overlay
    597 U00d8		       00	   colorIdx   ds	1
      0 U00d9					      VALIDATE_OVERLAY
      5 U00d9					      LIST	ON
    599 U00d9
      0 U00d9					      OVERLAY	SwapPlayers
      1 U00d9 ????				      SEG.U	OVERLAY_SwapPlayers
      2 U00d8					      org	Overlay
    601 U00d8		       00	   tmpX       ds	1
      0 U00d9					      VALIDATE_OVERLAY
      5 U00d9					      LIST	ON
    603 U00d9
      0 U00d9					      OVERLAY	DrawIntoStack
      1 U00d9 ????				      SEG.U	OVERLAY_DrawIntoStack
      2 U00d8					      org	Overlay
    605 U00d8		       00	   save_SP    ds	1
      0 U00d9					      VALIDATE_OVERLAY
      5 U00d9					      LIST	ON
    607 U00d9
    608 U00d9							;------------------------------------------------------------------------------
    609 U00d9							;##############################################################################
    610 U00d9							;------------------------------------------------------------------------------
    611 U00d9
    612 U00d9							; NOW THE VERY INTERESTING '3E' RAM BANKS
    613 U00d9							; EACH BANK HAS A READ-ADDRESS AND A WRITE-ADDRESS, WITH 2k TOTAL
    614 U00d9
    615 U00d9				   ORIGIN     SET	0
      0 U00d9					      NEWRAMBANK	BANK_SCREENMARKII1
      1 U0000 ????				      SEG.U	BANK_SCREENMARKII1
      2 U0000					      ORG	ORIGIN
      3 U0000					      RORG	RAM_3E
      4 U0000				   BANK_START SET	*
      5 U0000				   BANK_SCREENMARKII1 SET	ORIGIN / RAM_SIZE
      6 U0000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    617 U0000
    618 U0000							; NOTE: THIS BANK JUST *LOOKS* EMPTY.
    619 U0000							; It actually contains everything copied from the ROM copy of the ROW RAM banks.
    620 U0000							; The variable definitions are also in that ROM bank (even though they're RAM :)
    621 U0000
    622 U0000		       00 54	   SCREEN_BITMAP_SIZE =	4 * LINES_PER_CHAR
    623 U0000
    624 U0000							; These banks (there are #SCREEN_LINES of them) hold a RAM copy of the screen draw
    625 U0000							; code.  This code is self-modifying, in that the colour values for each scanline
    626 U0000							; are set to NTSC or PAL values on startup -- thus, the single binary can run
    627 U0000							; on either format system.  The main purpose for copying the draw code to RAM,
    628 U0000							; though, is to free up space in the fixed bank (which is incredibly valuable).
    629 U0000
    630 U0000							; A neat feature of having multiple copies of the same code in different RAM banks
    631 U0000							; is that we can use that code to switch between banks, and the system will happily
    632 U0000							; execute the next instruction from the newly switched-in bank without a problem.
    633 U0000
    634 U0000							; Now we have the actual graphics data for each of the rows.  This consists of an
    635 U0000							; actual bitmap (in exact PF-style format, 6 bytes per line) into which the
    636 U0000							; character shapes are masked/copied. The depth of the character shapes may be
    637 U0000							; changed by changing the #LINES_PER_CHAR value.  Note that this depth should be
    638 U0000							; a multiple of 3, so that the RGB scanlines match at character joins.
    639 U0000
    640 U0000							; The next part of the graphics data is a bitmap sprite buffer -- space for two
    641 U0000							; sprites' graphics shape and colour data.  The shape and colour may be set as
    642 U0000							; part of the draw routine *every* scanline (though the system currently uses
    643 U0000							; one colour shared between both players).
    644 U0000
      0 U0000					      VALIDATE_RAM_SIZE
      1 U0000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0000				  -	      ERR
      3 U0000					      endif
    646 U0000
    647 U0000							; We have one bank for each screen row.  These banks are duplicates of the above,
    648 U0000							; accessed via the above labels but with the appropriate bank switched in.
    649 U0000
    650 U0000							;------------------------------------------------------------------------------
    651 U0000
    652 U0000					      REPEAT	SCREEN_LINES - 1
      0 U0000					      NEWRAMBANK	.DUMMY
      1 U1c00 ????				      SEG.U	.DUMMY
      2 U0400					      ORG	ORIGIN
      3 U0400					      RORG	RAM_3E
      4 U0400				   BANK_START SET	*
      5 U0400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0400					      VALIDATE_RAM_SIZE
      1 U0400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0400				  -	      ERR
      3 U0400					      endif
    652 U0400					      REPEND
      0 U0400					      NEWRAMBANK	.DUMMY
      1 U0400					      SEG.U	.DUMMY
      2 U0800					      ORG	ORIGIN
      3 U0800					      RORG	RAM_3E
      4 U0800				   BANK_START SET	*
      5 U0800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0800					      VALIDATE_RAM_SIZE
      1 U0800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0800				  -	      ERR
      3 U0800					      endif
    652 U0800					      REPEND
      0 U0800					      NEWRAMBANK	.DUMMY
      1 U0800					      SEG.U	.DUMMY
      2 U0c00					      ORG	ORIGIN
      3 U0c00					      RORG	RAM_3E
      4 U0c00				   BANK_START SET	*
      5 U0c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U0c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U0c00					      VALIDATE_RAM_SIZE
      1 U0c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U0c00				  -	      ERR
      3 U0c00					      endif
    652 U0c00					      REPEND
      0 U0c00					      NEWRAMBANK	.DUMMY
      1 U0c00					      SEG.U	.DUMMY
      2 U1000					      ORG	ORIGIN
      3 U1000					      RORG	RAM_3E
      4 U1000				   BANK_START SET	*
      5 U1000				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1000				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1000					      VALIDATE_RAM_SIZE
      1 U1000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1000				  -	      ERR
      3 U1000					      endif
    652 U1000					      REPEND
      0 U1000					      NEWRAMBANK	.DUMMY
      1 U1000					      SEG.U	.DUMMY
      2 U1400					      ORG	ORIGIN
      3 U1400					      RORG	RAM_3E
      4 U1400				   BANK_START SET	*
      5 U1400				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1400				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1400					      VALIDATE_RAM_SIZE
      1 U1400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1400				  -	      ERR
      3 U1400					      endif
    652 U1400					      REPEND
      0 U1400					      NEWRAMBANK	.DUMMY
      1 U1400					      SEG.U	.DUMMY
      2 U1800					      ORG	ORIGIN
      3 U1800					      RORG	RAM_3E
      4 U1800				   BANK_START SET	*
      5 U1800				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1800				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1800					      VALIDATE_RAM_SIZE
      1 U1800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1800				  -	      ERR
      3 U1800					      endif
    652 U1800					      REPEND
      0 U1800					      NEWRAMBANK	.DUMMY
      1 U1800					      SEG.U	.DUMMY
      2 U1c00					      ORG	ORIGIN
      3 U1c00					      RORG	RAM_3E
      4 U1c00				   BANK_START SET	*
      5 U1c00				   .DUMMY     SET	ORIGIN / RAM_SIZE
      6 U1c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
      0 U1c00					      VALIDATE_RAM_SIZE
      1 U1c00				  -	      if	* - RAM_3E > RAM_SIZE
      2 U1c00				  -	      ERR
      3 U1c00					      endif
    655 U1c00					      REPEND
    656 U1c00
    657 U1c00							;------------------------------------------------------------------------------
    658 U1c00							;##############################################################################
    659 U1c00							;------------------------------------------------------------------------------
    660 U1c00
      0 U1c00					      NEWRAMBANK	BANK_DRAW_BUFFERS
      1 U2000 ????				      SEG.U	BANK_DRAW_BUFFERS
      2 U2000					      ORG	ORIGIN
      3 U2000					      RORG	RAM_3E
      4 U2000				   BANK_START SET	*
      5 U2000				   BANK_DRAW_BUFFERS SET	ORIGIN / RAM_SIZE
      6 U2000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    662 U2000							; VARS DEFINED IN ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    663 U2000							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2000					      VALIDATE_RAM_SIZE
      1 U2000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2000				  -	      ERR
      3 U2000					      endif
    665 U2000
    666 U2000							;------------------------------------------------------------------------------
    667 U2000							;##############################################################################
    668 U2000							;------------------------------------------------------------------------------
    669 U2000
      0 U2000					      NEWRAMBANK	BANK_SCORING
      1 U2400 ????				      SEG.U	BANK_SCORING
      2 U2400					      ORG	ORIGIN
      3 U2400					      RORG	RAM_3E
      4 U2400				   BANK_START SET	*
      5 U2400				   BANK_SCORING SET	ORIGIN / RAM_SIZE
      6 U2400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    671 U2400							; VARS DEFINED IN ROM_SHADOW_OF_BANK_SCORING
    672 U2400							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2400					      VALIDATE_RAM_SIZE
      1 U2400				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2400				  -	      ERR
      3 U2400					      endif
    674 U2400
    675 U2400							;------------------------------------------------------------------------------
    676 U2400							;##############################################################################
    677 U2400							;------------------------------------------------------------------------------
    678 U2400
      0 U2400					      NEWRAMBANK	BANK_DECODE_LEVEL
      1 U2800 ????				      SEG.U	BANK_DECODE_LEVEL
      2 U2800					      ORG	ORIGIN
      3 U2800					      RORG	RAM_3E
      4 U2800				   BANK_START SET	*
      5 U2800				   BANK_DECODE_LEVEL SET	ORIGIN / RAM_SIZE
      6 U2800				   ORIGIN     SET	ORIGIN + RAM_SIZE
    680 U2800							; VARS DEFINED IN BANK_DECODE_LEVEL_SHADOW
    681 U2800							; SELF-MODIFYING SUBROUTINES MAY BE PRESENT IN THIS BANK TOO!
      0 U2800					      VALIDATE_RAM_SIZE
      1 U2800				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2800				  -	      ERR
      3 U2800					      endif
    683 U2800
    684 U2800							;------------------------------------------------------------------------------
    685 U2800							;##############################################################################
    686 U2800							;------------------------------------------------------------------------------
    687 U2800
      0 U2800					      NEWRAMBANK	BANK_OBJSTACK
      1 U2e80 ????				      SEG.U	BANK_OBJSTACK
      2 U2c00					      ORG	ORIGIN
      3 U2c00					      RORG	RAM_3E
      4 U2c00				   BANK_START SET	*
      5 U2c00				   BANK_OBJSTACK SET	ORIGIN / RAM_SIZE
      6 U2c00				   ORIGIN     SET	ORIGIN + RAM_SIZE
    689 U2c00
    690 U2c00							; The objects are a list of X,Y positions into the BOARD.  Each of these is a board
    691 U2c00							; position of something that needs to be processed.  These things include anything
    692 U2c00							; that animates.  Objects which no longer need processing do not re-add themselves
    693 U2c00							; to the object stack.  There are two stacks -- the one being processed, and the
    694 U2c00							; one for the next processing iteration.
    695 U2c00
    696 U2c00							; Note: These are referenced by ObjStackNum, as is the BLANK_STACK paired bank set.
    697 U2c00
    698 U2c00		       00 80	   OBJ_STACK_SIZE =	128
    699 U2c00
    700 U2c00							; WARNING: THESE MUST NOT CROSS PAGE BOUNDARIES!!!
    701 U2c00
    702 U2c00		       00 00 00 00*ObjStackX  ds	OBJ_STACK_SIZE
    703 U2c80		       00 00 00 00*ObjStackY  ds	OBJ_STACK_SIZE
    704 U2d00		       00 00 00 00*ObjStackVar ds	OBJ_STACK_SIZE	; for general use
    705 U2d80
    706 U2d80							; SortedObjPtr is now in the middle of a page, thus allowing to address with -1
    707 U2d80		       00 00 00 00*SortedObjPtr ds	OBJ_STACK_SIZE	; list of indexes of objects (sorted)
    708 U2e00
    709 U2e00		       00 00 00 00*ObjStackType ds	OBJ_STACK_SIZE	; type of object
    710 U2e80
 FREE RAM IN BANK_OBJSTACK =  $180
    711 U2e80					      ECHO	"FREE RAM IN BANK_OBJSTACK = ", RAM_SIZE - ( * - BANK_START )
    712 U2e80
      0 U2e80					      VALIDATE_RAM_SIZE
      1 U2e80				  -	      if	* - RAM_3E > RAM_SIZE
      2 U2e80				  -	      ERR
      3 U2e80					      endif
    714 U2e80
    715 U2e80							;------------------------------------------------------------------------------
    716 U2e80
      0 U2e80					      NEWRAMBANK	BANK_OBJSTACK2
      1 U3000 ????				      SEG.U	BANK_OBJSTACK2
      2 U3000					      ORG	ORIGIN
      3 U3000					      RORG	RAM_3E
      4 U3000				   BANK_START SET	*
      5 U3000				   BANK_OBJSTACK2 SET	ORIGIN / RAM_SIZE
      6 U3000				   ORIGIN     SET	ORIGIN + RAM_SIZE
    718 U3000							; THIS IS A MIRROR OF BANK_OBJSTACK -- DO NOT MODIFY OR USE!!
      0 U3000					      VALIDATE_RAM_SIZE
      1 U3000				  -	      if	* - RAM_3E > RAM_SIZE
      2 U3000				  -	      ERR
      3 U3000					      endif
    720 U3000
    721 U3000							;------------------------------------------------------------------------------
    722 U3000							;##############################################################################
    723 U3000							;------------------------------------------------------------------------------
    724 U3000
      0 U3000					      NEWRAMBANK	BANK_BOARD
      1 U37a0 ????				      SEG.U	BANK_BOARD
      2 U3400					      ORG	ORIGIN
      3 U3400					      RORG	RAM_3E
      4 U3400				   BANK_START SET	*
      5 U3400				   BANK_BOARD SET	ORIGIN / RAM_SIZE
      6 U3400				   ORIGIN     SET	ORIGIN + RAM_SIZE
    726 U3400
    727 U3400							; Now the interesting 'BOARD' -- which in reality is a free-form system of M*N
    728 U3400							; rows and columns.  We need to reserve enough RAM for the board's entirety, but
    729 U3400							; don't really care much how it overlaps the 1K bank limit.  The code accessing
    730 U3400							; the board *MUST* calculate and take account of the correct RAM bank to switch
    731 U3400							; when accessing.
    732 U3400
    733 U3400							; The system is fairly free-form, in that it rearranges the memory and tables
    734 U3400							; automatically based on the sizes set in these constants. The board may overlay
    735 U3400							; MULTIPLE banks -- just as long as any particular LINE does not cross a bank
    736 U3400							; we're doing OK.
    737 U3400
    738 U3400							; NOTE: Assumption is that board lines CANNOT CROSS page boundaries.
    739 U3400
    740 U3400							; now fits into one single bank (if we don't reserve too much space for code)
    741 U3400
    742 U3400		       00 28	   SIZE_BOARD_X =	40
    743 U3400		       00 16	   SIZE_BOARD_Y =	22
    744 U3400
    745 U3400							; have to precalculate it here, else DASM freaks out:
    746 U3400				   .BOARD_SIZE SET	0
    747 U3400				   .BOARD_LOCATION SET	0
    748 U3400					      REPEAT	SIZE_BOARD_Y
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				   .BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    748 U3400					      REPEND
    749 U3400				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
    750 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE - .BOARD_LOCATION
    751 U3400				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
    752 U3400				  -.BOARD_SIZE SET	.BOARD_SIZE + .BOARD_LOCATION
    753 U3400					      ENDIF
    754 U3400				   .BOARD_SIZE SET	.BOARD_SIZE + SIZE_BOARD_X
    755 U3400				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
    756 U3400					      REPEND
    757 U3400
    758 U3400		       03 a0	   SIZE_BOARD =	.BOARD_SIZE
    759 U3400
    760 U3400				  -	      IF	SIZE_BOARD > RAM_SIZE
    761 U3400				  -MULTI_BANK_BOARD =	YES
    762 U3400					      ELSE
    763 U3400		       00 00	   MULTI_BANK_BOARD =	NO	; timings: [-..]
    764 U3400					      ENDIF
    765 U3400
    766 U3400		       00 00 00 00*Board      ds	SIZE_BOARD	; Note, we can only access this in
    767 U37a0							; 1024 byte chunks, switching RAM
    768 U37a0							; banks as we go.  In other words,
    769 U37a0							; this overlaps multiple banks!
    770 U37a0
    771 U37a0
    772 U37a0							; free space here (but hard to use)
    773 U37a0							; So we need to calculate where the next free bank is!
    774 U37a0							; TODO: This looks dodgy.  Check..
    775 U37a0
    776 U37a0				   ORIGIN     SET	( * + RAM_SIZE - 1 ) / RAM_SIZE
    777 U37a0				   ORIGIN     SET	ORIGIN * RAM_SIZE
    778 U37a0
    779 U37a0
    780 U37a0
    781 U37a0							;------------------------------------------------------------------------------
    782 U37a0							;##############################################################################
    783 U37a0							;------------------------------------------------------------------------------
    784 U37a0
    785 U37a0							;------------------------------------------------------------------------------
    786 U37a0
    787 U37a0							;    IFNCONST MAX_LEVEL_SIZE
    788 U37a0				   MAX_LEVEL_SIZE SET	0
    789 U37a0							;    ENDIF
    790 U37a0
    791 U37a0					      MAC	start_level
    792 U37a0				   LEVEL_START SET	*
    793 U37a0				   BANK_LEVEL_{1} =	_CURRENT_BANK
    794 U37a0				   LEVEL_{1}  SUBROUTINE
    795 U37a0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
    796 U37a0							; ECHO "current MAX_LEVEL_NUMBER = ", MAX_LEVEL_NUMBER
    797 U37a0					      ENDM		; {name}
    798 U37a0
    799 U37a0
    800 U37a0					      MAC	end_level
    801 U37a0					      .byte	0
    802 U37a0				   LEVEL_SIZE_{1} =	* - LEVEL_START
    803 U37a0					      IF	LEVEL_SIZE_{1} > MAX_LEVEL_SIZE
    804 U37a0				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_{1}
    805 U37a0					      ENDIF
    806 U37a0					      ENDM		; {name}
    807 U37a0
    808 U37a0							;--------------------------------------------------------------------------------
    809 U37a0
    810 U37a0				   ORIGIN     SET	$00000
    811 U37a0
    812 U37a0					      include	"BANK_Demo.asm"	; upper half of BANK_TITLE_LOGO
------- FILE BANK_ROM_SHADOW_RAMBANK.asm LEVEL 2 PASS 3
      0 U37a0					      include	"BANK_ROM_SHADOW_RAMBANK.asm"
      1 U37a0							;------------------------------------------------------------------------------
      2 U37a0							;##############################################################################
      3 U37a0							;------------------------------------------------------------------------------
      0 U37a0					      NEWBANK	ROM_SHADOW_OF_RAMBANK_CODE
      1  0348 ????				      SEG	ROM_SHADOW_OF_RAMBANK_CODE
      2  0000					      ORG	ORIGIN
      3  0000					      RORG	$F000
      4  0000				   BANK_START SET	*
      5  0000				   ROM_SHADOW_OF_RAMBANK_CODE SET	ORIGIN / 2048
      6  0000				   ORIGIN     SET	ORIGIN + 2048
      7  0000				   _CURRENT_BANK SET	ROM_SHADOW_OF_RAMBANK_CODE
      5  0000
      6  0000							; This is essentially a ROM mirror of a RAM bank.
      7  0000							; The contents of this bank are copied to each of the ROW banks on startup, and
      8  0000							; this gives a 1:1 correspondence between the data/addresses defined here, and
      9  0000							; the addresses in the switched-in RAM bank.
     10  0000
     11  0000							; Note: Bankswitching code between any of these banks guarantees the code can
     12  0000							; continue to run -- because, of course, the same code is still at the same
     13  0000							; memory address.
     14  0000
     15  0000		       00 01	   _PROFILE_DRAW =	YES
     16  0000
     17  0000					      MAC	profile_draw
     18  0000					      IF	_PROFILE_DRAW
     19  0000					      inc	Profile{1}
     20  0000					      bne	$skip
     21  0000					      inc	Profile{1}+1
     22  0000				   $skip
     23  0000					      ENDIF
     24  0000					      ENDM		; {label}
     25  0000
     26  0000
      0  0000					      DEFINE_SUBROUTINE	DrawTheScreen
      1  0000		       00 00	   BANK_DrawTheScreen =	_CURRENT_BANK
      2  0000					      SUBROUTINE
      3  0000				   DrawTheScreen
     28  0000
     29  0000							; Thomas Jentzsch strikes again.  And Andrew Davie too ;)
     30  0000							; A refactor of the kernel to improve the timing.
     31  0000							; Experimental refactor to remove the blank line...
     32  0000
     33  0000							; adjust here so that the first line of the kernel starts exactly at cycle 67
     34  0000							; (since TJ said it could start up to 5 cycles earlier than #67).
     35  0000
     36  0000							; TODO: remove GRP1 and COLUP1 access (or use higher resolution player)
     37  0000							;	     @57
      0  0000					      SLEEP	3	; 3
      1  0000				   .CYCLES    SET	3
      2  0000
      3  0000				  -	      IF	.CYCLES < 2
      4  0000				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0000				  -	      ERR
      6  0000					      ENDIF
      7  0000
      8  0000					      IF	.CYCLES & 1
      9  0000					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0000		       04 00		      nop	0
     11  0002				  -	      ELSE
     12  0002				  -	      bit	VSYNC
     13  0002					      ENDIF
     14  0002				   .CYCLES    SET	.CYCLES - 3
     15  0002					      ENDIF
     16  0002
     17  0002				  -	      REPEAT	.CYCLES / 2
     18  0002				  -	      nop
     19  0002					      REPEND
     39  0002
     40  0002		       a2 00		      ldx	#<(BANK_SCREENMARKII1)	; 2		     == 0!!!
     41  0004		       10 3e		      bpl	NextALineStart	; 3 =	8    @65     unconditional
     42  0006
     43  0006				   Proc2		; 5
      0  0006					      SLEEP	3	; 3	     @64
      1  0006				   .CYCLES    SET	3
      2  0006
      3  0006				  -	      IF	.CYCLES < 2
      4  0006				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  0006				  -	      ERR
      6  0006					      ENDIF
      7  0006
      8  0006					      IF	.CYCLES & 1
      9  0006					      IFNCONST	NO_ILLEGAL_OPCODES
     10  0006		       04 00		      nop	0
     11  0008				  -	      ELSE
     12  0008				  -	      bit	VSYNC
     13  0008					      ENDIF
     14  0008				   .CYCLES    SET	.CYCLES - 3
     15  0008					      ENDIF
     16  0008
     17  0008				  -	      REPEAT	.CYCLES / 2
     18  0008				  -	      nop
     19  0008					      REPEND
     45  0008		       10 3c		      bpl	ScanBLUEBD	; 3 = 11    @67     unconditional
     46  000a
     47  000a				   ScanRED		;	     @60
     48  000a		       b9 05 f3    SM_PF0_REDl lda	CHARACTERSHAPE_BLANK,y	; 4
     49  000d		       85 4d		      sta	PF0	; 3	     @67
     50  000f		       b9 87 f2 	      lda	ScreenBitmapRED+0*LINES_PER_CHAR,y	; 4
     51  0012		       85 4e		      sta	PF1	; 3 = 14    @74
     52  0014				   SELFMOD_PLAYERCOL_RED
     53  0014		       b9 af f0 	      lda	SpriteColourRED,y	; 4
     54  0017		       85 46		      sta	COLUP0	; 3	     @05
     55  0019		       85 47		      sta	COLUP1	; 3 = 10    @08
     56  001b
     57  001b							; TIMING COUNTS ARE WRONG FROM HERE, DUE TO ABOVE CYCLE LOSS
     58  001b
     59  001b				   SELFMOD_RED
     60  001b		       a9 00		      lda	#0	; 2
     61  001d		       85 48		      sta	COLUPF	; 3 =	5    @13
     62  001f
     63  001f				   SELFMOD_PLAYER0_RED
     64  001f		       b9 05 f3 	      lda	ShapePlayerRED,y	; 4
     65  0022		       85 5b		      sta	GRP0	; 3 =	7    @20
     66  0024
     67  0024		       b9 9c f2 	      lda	ScreenBitmapRED+1*LINES_PER_CHAR,y	; 4
     68  0027		       85 4f		      sta	PF2	; 3 =	7    @27
     69  0029
     70  0029		       b9 05 f3    SM_PF0_REDr lda	CHARACTERSHAPE_BLANK,y	; 4
     71  002c		       85 4d		      sta	PF0	; 3	     @34
     72  002e		       b9 b1 f2 	      lda	ScreenBitmapRED+2*LINES_PER_CHAR,y	; 4
     73  0031		       85 4e		      sta	PF1	; 3	     @41
     74  0033		       b9 c6 f2 	      lda	ScreenBitmapRED+3*LINES_PER_CHAR,y	; 4
     75  0036		       85 4f		      sta	PF2	; 3 = 21    @48     must be >=48! :-)
     76  0038
     77  0038				   SELFMOD_PLAYER1_RED
     78  0038		       b9 05 f3 	      lda	ShapePlayerRED,y	; 4
     79  003b		       8d 5c 00 	      sta.w	GRP1	; 4 =	8    @56   VDELed!
     80  003e
     81  003e		       88		      dey		; 2
     82  003f		       10 c5		      bpl	Proc2	; 2(3)      --> 61 if taken
     83  0041
     84  0041		       e8	   SELFMOD_X  inx		; 2
     85  0042		       86 3e		      stx	SET_BANK_RAM	; 3	     SWITCH TO CORRECT ROW BANK (OR EXIT BANK)
     86  0044							;EXIT_RETURN_HERE
     87  0044				   NextALineStart
     88  0044		       a0 06		      ldy	#LINES_PER_CHAR/3-1	; 2 = 11    @67
     89  0046				   ScanBLUEBD		;	     @67     let's start as late as possible
     90  0046
     91  0046							;------------------------------------------------------------------------------
     92  0046
     93  0046		       b9 05 f3    SM_PF0_BLUEl lda	CHARACTERSHAPE_BLANK,y	; 4
     94  0049		       85 4d		      sta	PF0	; 3 =	7    @74
     95  004b				   SELFMOD_PLAYERCOL_BLUE
     96  004b		       b9 bd f0 	      lda	SpriteColourBLUE,y	; 4
     97  004e		       85 47		      sta	COLUP1	; 3	     @05
     98  0050		       85 46		      sta	COLUP0	; 3 = 10    @08
     99  0052
    100  0052				   SELFMOD_BLUE
    101  0052		       a9 00		      lda	#0	; 2
    102  0054		       85 48		      sta	COLUPF	; 3 =	5    @13
    103  0056
    104  0056				   SELFMOD_PLAYER0_BLUE
    105  0056		       b9 05 f3 	      lda	ShapePlayerBLUE,y	; 4
    106  0059		       85 5b		      sta	GRP0	; 3 =	7    @20
    107  005b
    108  005b		       b9 95 f2 	      lda	ScreenBitmapBLUE+0*LINES_PER_CHAR,y	; 4
    109  005e		       85 4e		      sta	PF1	; 3	     @27     <=27! :-)
    110  0060		       b9 aa f2 	      lda	ScreenBitmapBLUE+1*LINES_PER_CHAR,y	; 4
    111  0063		       85 4f		      sta	PF2	; 3 = 14    @34
    112  0065
    113  0065		       b9 05 f3    SM_PF0_BLUEr lda	CHARACTERSHAPE_BLANK,y	; 4
    114  0068		       85 4d		      sta	PF0	; 3	     @41
    115  006a		       b9 bf f2 	      lda	ScreenBitmapBLUE+2*LINES_PER_CHAR,y	; 4
    116  006d		       85 4e		      sta	PF1	; 3	     @48
    117  006f		       b9 d4 f2 	      lda	ScreenBitmapBLUE+3*LINES_PER_CHAR,y	; 4
    118  0072		       85 4f		      sta	PF2	; 3 = 21    @55
    119  0074
    120  0074				   SELFMOD_PLAYER1_BLUE
    121  0074		       b9 05 f3 	      lda	ShapePlayerBLUE,y	; 4
    122  0077		       85 5c		      sta	GRP1	; 3 =	7    VDELed! @62
    123  0079
    124  0079							;------------------------------------------------------------------------------
    125  0079
    126  0079				   ScanGREEN		;	     @62
    127  0079		       b9 05 f3    SM_PF0_GREENl lda	CHARACTERSHAPE_BLANK,y	; 4
    128  007c		       85 4d		      sta	PF0	; 3 =	7    @69
    129  007e				   SELFMOD_PLAYERCOL_GREEN
    130  007e		       b9 b6 f0 	      lda	SpriteColourGREEN,y	; 4
    131  0081		       85 47		      sta	COLUP1	; 3	     @00
    132  0083		       85 46		      sta	COLUP0	; 3 = 10    @03
    133  0085
    134  0085				   SELFMOD_GREEN
    135  0085		       a9 00		      lda	#0	; 2
    136  0087		       85 48		      sta	COLUPF	; 3 =	5    @08
    137  0089
    138  0089				   SELFMOD_PLAYER0_GREEN
    139  0089		       b9 05 f3 	      lda	ShapePlayerGREEN,y	; 4
    140  008c		       85 5b		      sta	GRP0	; 3 =	7    @15
    141  008e
    142  008e		       b9 8e f2 	      lda	ScreenBitmapGREEN+0*LINES_PER_CHAR,y	; 4
    143  0091		       85 4e		      sta	PF1	; 3	     @22
    144  0093		       b9 a3 f2 	      lda	ScreenBitmapGREEN+1*LINES_PER_CHAR,y	; 4
    145  0096		       85 4f		      sta	PF2	; 3 = 14    @29
    146  0098
    147  0098		       b9 05 f3    SM_PF0_GREENr lda	CHARACTERSHAPE_BLANK,y	; 4
    148  009b		       85 4d		      sta	PF0	; 3	     @36
    149  009d		       b9 b8 f2 	      lda	ScreenBitmapGREEN+2*LINES_PER_CHAR,y	; 4
    150  00a0		       85 4e		      sta	PF1	; 3	     @43
    151  00a2		       b9 cd f2 	      lda	ScreenBitmapGREEN+3*LINES_PER_CHAR,y	; 4
    152  00a5		       85 4f		      sta	PF2	; 3 = 21    @50
    153  00a7
    154  00a7				   SELFMOD_PLAYER1_GREEN
    155  00a7		       b9 05 f3 	      lda	ShapePlayerGREEN,y	; 4
    156  00aa		       85 5c		      sta	GRP1	; 3 =	7    @57     VDELed!
    157  00ac
    158  00ac		       4c 0a f0 	      jmp	ScanRED	; 3	     @60
    159  00af
    160  00af							;------------------------------------------------------------------------------
    161  00af
    162  00af							;     OPTIONAL_PAGEBREAK "PLAYER BLANK SHAPE", LINES_PER_CHAR
    163  00af
    164  00af		       f3 05	   ShapePlayer =	PLAYER_BLANK
    165  00af		       f3 05	   ShapePlayerBLUE =	ShapePlayer	; low adresses patched
    166  00af		       f3 05	   ShapePlayerGREEN =	ShapePlayer	; low adresses patched
    167  00af		       f3 05	   ShapePlayerRED =	ShapePlayer	; low adresses patched
    168  00af
    169  00af		       f3 05	   CHARACTERSHAPE_MANOCCUPIED =	PLAYER_BLANK
    170  00af		       f3 05	   CHARACTERSHAPE_BLANK =	PLAYER_BLANK
    171  00af
------- FILE playerColour.asm LEVEL 3 PASS 3
      0  00af					      include	"playerColour.asm"	; 1 * LINES_PER_CHAR bytes
      0  00af					      OPTIONAL_PAGEBREAK	"SpriteColour", LINES_PER_CHAR*2
     10  00af					      LIST	ON
      2  00af
      3  00af		       00 10	   YELLOW_NTSC =	$10	; hair
      4  00af		       00 30	   ORANGE_NTSC =	$30	; skin
      5  00af		       00 40	   RED_NTSC   =	$40	; shirt
      6  00af		       00 a4	   BLUE_NTSC  =	$A4
      7  00af
      8  00af		       00 20	   YELLOW_PAL =	$20
      9  00af		       00 40	   ORANGE_PAL =	$40
     10  00af		       00 60	   RED_PAL    =	$60
     11  00af
     12  00af				   SpriteColour
     13  00af							; NTSC
     14  00af							;SpriteColourRED
     15  00af							;    .byte RED_NTSC|$6       ; 0 feet
     16  00af							;    .byte WHITE	      ; 3
     17  00af							;    .byte RED_NTSC|$4       ; 6
     18  00af							;    .byte RED_NTSC|$4       ; 9
     19  00af							;    .byte ORANGE_NTSC|$6    ;12
     20  00af							;    .byte ORANGE_NTSC|$8    ;15
     21  00af							;    .byte WHITE	      ;18
     22  00af							;SpriteColourGREEN
     23  00af							;    .byte RED_NTSC|$4       ; 1
     24  00af							;    .byte WHITE	      ; 4
     25  00af							;    .byte WHITE	      ; 7
     26  00af							;    .byte WHITE	      ;10
     27  00af							;    .byte ORANGE_NTSC|$8    ;13
     28  00af							;    .byte ORANGE_NTSC|$6    ;16
     29  00af							;    .byte WHITE	      ;19
     30  00af							;SpriteColourBLUE
     31  00af							;    .byte WHITE	      ; 2
     32  00af							;    .byte RED_NTSC|$4       ; 5
     33  00af							;    .byte RED_NTSC|$4       ; 8
     34  00af							;    .byte ORANGE_NTSC|$4    ;11 neck
     35  00af							;    .byte ORANGE_NTSC|$a    ;14
     36  00af							;    .byte YELLOW_NTSC|$c    ;17 hair
     37  00af							;    .byte WHITE	      ;20
     38  00af
     39  00af				   SpriteColourRED
     40  00af		       0e		      .byte.b	WHITE
     41  00b0		       0e		      .byte.b	WHITE
     42  00b1		       0e		      .byte.b	WHITE
     43  00b2		       0e		      .byte.b	WHITE
     44  00b3		       0e		      .byte.b	WHITE
     45  00b4		       0e		      .byte.b	WHITE
     46  00b5		       0e		      .byte.b	WHITE
     47  00b6
     48  00b6							;  .byte #$1C;0
     49  00b6							;  .byte #$78;3
     50  00b6							;  .byte #$52;6
     51  00b6							;  .byte #$52;9
     52  00b6							;  .byte #$0C;12
     53  00b6							;  .byte #$4A;15
     54  00b6							;  .byte #$1A;18
     55  00b6				   SpriteColourGREEN
     56  00b6		       0e		      .byte.b	WHITE
     57  00b7		       0e		      .byte.b	WHITE
     58  00b8		       0e		      .byte.b	WHITE
     59  00b9		       0e		      .byte.b	WHITE
     60  00ba		       0e		      .byte.b	WHITE
     61  00bb		       0e		      .byte.b	WHITE
     62  00bc		       0e		      .byte.b	WHITE
     63  00bd				   SpriteColourBLUE
     64  00bd		       0e		      .byte.b	WHITE
     65  00be		       0e		      .byte.b	WHITE
     66  00bf		       0e		      .byte.b	WHITE
     67  00c0		       0e		      .byte.b	WHITE
     68  00c1		       0e		      .byte.b	WHITE
     69  00c2		       0e		      .byte.b	WHITE
     70  00c3		       0e		      .byte.b	WHITE
     71  00c4
     72  00c4					      REPEAT	21
     73  00c4		       26		      .byte.b	$20|$6	; 2
     72  00c4					      REPEND
     73  00c5		       26		      .byte.b	$20|$6	; 2
     72  00c5					      REPEND
     73  00c6		       26		      .byte.b	$20|$6	; 2
     72  00c6					      REPEND
     73  00c7		       26		      .byte.b	$20|$6	; 2
     72  00c7					      REPEND
     73  00c8		       26		      .byte.b	$20|$6	; 2
     72  00c8					      REPEND
     73  00c9		       26		      .byte.b	$20|$6	; 2
     72  00c9					      REPEND
     73  00ca		       26		      .byte.b	$20|$6	; 2
     72  00ca					      REPEND
     73  00cb		       26		      .byte.b	$20|$6	; 2
     72  00cb					      REPEND
     73  00cc		       26		      .byte.b	$20|$6	; 2
     72  00cc					      REPEND
     73  00cd		       26		      .byte.b	$20|$6	; 2
     72  00cd					      REPEND
     73  00ce		       26		      .byte.b	$20|$6	; 2
     72  00ce					      REPEND
     73  00cf		       26		      .byte.b	$20|$6	; 2
     72  00cf					      REPEND
     73  00d0		       26		      .byte.b	$20|$6	; 2
     72  00d0					      REPEND
     73  00d1		       26		      .byte.b	$20|$6	; 2
     72  00d1					      REPEND
     73  00d2		       26		      .byte.b	$20|$6	; 2
     72  00d2					      REPEND
     73  00d3		       26		      .byte.b	$20|$6	; 2
     72  00d3					      REPEND
     73  00d4		       26		      .byte.b	$20|$6	; 2
     72  00d4					      REPEND
     73  00d5		       26		      .byte.b	$20|$6	; 2
     72  00d5					      REPEND
     73  00d6		       26		      .byte.b	$20|$6	; 2
     72  00d6					      REPEND
     73  00d7		       26		      .byte.b	$20|$6	; 2
     72  00d7					      REPEND
     73  00d8		       26		      .byte.b	$20|$6	; 2
     74  00d9					      REPEND
     75  00d9
     76  00d9							; PAL
     77  00d9							;    .byte RED_PAL|$6	      ; 0 feet
     78  00d9							;    .byte WHITE	      ; 3
     79  00d9							;    .byte RED_PAL|$4	      ; 6
     80  00d9							;    .byte RED_PAL|$4	      ; 9
     81  00d9							;    .byte ORANGE_PAL|$4     ;12
     82  00d9							;    .byte ORANGE_PAL|$6     ;15
     83  00d9							;    .byte WHITE	      ;18
     84  00d9							;
     85  00d9							;    .byte RED_PAL|$4	      ; 1
     86  00d9							;    .byte WHITE	      ; 4
     87  00d9							;    .byte WHITE	      ; 7
     88  00d9							;    .byte WHITE	      ;10
     89  00d9							;    .byte ORANGE_PAL|$6     ;13
     90  00d9							;    .byte ORANGE_PAL|$4     ;16
     91  00d9							;    .byte WHITE	      ;19
     92  00d9							;
     93  00d9							;    .byte WHITE	      ; 2
     94  00d9							;    .byte RED_PAL|$4	      ; 5
     95  00d9							;    .byte RED_PAL|$4	      ; 8
     96  00d9							;    .byte ORANGE_PAL|$2     ;11 neck
     97  00d9							;    .byte ORANGE_PAL|$8     ;14
     98  00d9							;    .byte YELLOW_PAL|$c     ;17 hair
     99  00d9							;    .byte WHITE	      ;20
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    173  00d9
    174  00d9
    175  00d9							;------------------------------------------------------------------------------
    176  00d9
    177  00d9							;*** Ideas: ***
    178  00d9							; - separate data for left and right nibble (saves 88 cycles, 63 cycles or
    179  00d9							;   13.5% on average), also unrolling would be more effective than now
    180  00d9							; - use CharacterDataVecHI for mirrored/unmirrored (saves cycles and bytes,
    181  00d9							;   see EXPERIMENTAL)
    182  00d9							; - special QuickDraw routine for PF0 (~165 cycles, but only ~2% usage)
    183  00d9							; - stack AI (reordering for less setup code and cycle usage, maybe better use
    184  00d9							;   bidirectional linked list instead)
    185  00d9							; - calculate mirrored gfx data into RAM (saves ROM)
    186  00d9
    187  00d9							;*** average cycle calculation (10% blanks, all columns equally frequent): ***
    188  00d9							;currently:
    189  00d9							; 72%*539 (!unrolled)
    190  00d9							;+ 8%*304 (unrolled)
    191  00d9							;+20%*269 (unrolled)
    192  00d9							;--------
    193  00d9							;=   ~466.2 cycles on average
    194  00d9
    195  00d9							;alternative #1:
    196  00d9							; 72%*522 (unrolled)
    197  00d9							;+ 8%*352 (!unrolled)
    198  00d9							;+20%*307 (!unrolled)
    199  00d9							;--------
    200  00d9							;=   ~465.4 cycles on average
    201  00d9
    202  00d9
    203  00d9		       00 01	   MIRROR     =	1
    204  00d9		       00 80	   DIRECT     =	$80
    205  00d9
    206  00d9							;------------------------------------------------------------------------------
    207  00d9							; Here we don't draw into a buffer, but directly patch the kernel
    208  00d9							; VERY fast!
    209  00d9							;
    210  00d9							; TODO: check if DirectDraw for PF1/2 can be handle efficiently like this too
    211  00d9							; Problem: SlowDraw cannot assume that the other nibble is set correctly anymore
    212  00d9
    213  00d9				   PF0Draw		; 25 cycles until here
    214  00d9
    215  00d9		       ae 84 02 	      ldx	INTIM	; 4
    216  00dc		       e0 05		      cpx	#SEGTIME_SCD_PF0	; 2
    217  00de		       90 72		      bcc	ExitDraw	; 2(3)=8
      0  00e0					      STRESS_TIME	SEGTIME_SCD_PF0	; ok!
      1  00e0				  -	      IF	TEST_SEGTIME_SCD_PF0 = 1
      2  00e0				  -
      3  00e0				  -
      4  00e0				  -
      5  00e0				  -
      6  00e0				  -
      7  00e0				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  00e0				  -	      bne	. - 7
      9  00e0					      ENDIF
    219  00e0
    220  00e0		       29 7f		      and	#<(~DIRECT)	; 2
    221  00e2		       aa		      tax		; 2 =	4
    222  00e3
    223  00e3		       98		      tya		; 2
    224  00e4		       0a		      asl		; 2	     no mirrored chars in PF0
    225  00e5		       a8		      tay		; 2 =	6
    226  00e6							;		  clc				  ; 2
    227  00e6
    228  00e6		       b9 89 fc 	      lda	CharacterDataVecHI,y	; 4
    229  00e9		       9d 0c f4 	      sta	SM_PF0_REDl +RAM_WRITE+2,x	; 5
    230  00ec		       9d 7b f4 	      sta	SM_PF0_GREENl+RAM_WRITE+2,x	; 5
    231  00ef		       9d 48 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+2,x	; 5 = 19
    232  00f2
    233  00f2		       b9 75 fc 	      lda	CharacterDataVecLO,y	; 4
    234  00f5		       9d 0b f4 	      sta	SM_PF0_REDl +RAM_WRITE+1,x	; 5
    235  00f8		       69 06		      adc	#LINES_PER_CHAR/3-1	; 2	     CF is set!
    236  00fa		       9d 7a f4 	      sta	SM_PF0_GREENl+RAM_WRITE+1,x	; 5
    237  00fd		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    238  00ff		       9d 47 f4 	      sta	SM_PF0_BLUEl +RAM_WRITE+1,x	; 5 = 23
    239  0102
    240  0102		       4c 60 fa 	      jmp	DrawAnother	; 3 =	3
    241  0105
    242  0105							; Timing for PF0Draw
    243  0105							; 7+63 = 70
    244  0105							; total: 37+70+6 = 113 => 113/64 + 1.4 = 3.17 = 4 (or 3?)
    245  0105
    246  0105
    247  0105							;------------------------------------------------------------------------------
    248  0105							; Direct draw draws to PF0, which only has one active member of the character
    249  0105							; pair -- so it can be a direct copy.	Quicker still!
    250  0105
    251  0105				   DirectDraw		; 37 cycles until here
    252  0105
    253  0105							;ldy #16
    254  0105		       ad 84 02 	      lda	INTIM	; 4
    255  0108		       c9 08		      cmp	#SEGTIME_SCD_DIRECT	; 2
    256  010a		       90 46		      bcc	ExitDraw	; 2(3)=8
      0  010c					      STRESS_TIME	SEGTIME_SCD_DIRECT	; ok!
      1  010c				  -	      IF	TEST_SEGTIME_SCD_DIRECT = 1
      2  010c				  -
      3  010c				  -
      4  010c				  -
      5  010c				  -
      6  010c				  -
      7  010c				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  010c				  -	      bne	. - 7
      9  010c					      ENDIF
    258  010c
    259  010c							; TIME REQUIRED FROM HERE (9/JAN)
    260  010c							; 16 + 20 + 20 + 2 + ( 7 * 32 ) - 1  + (42 SUFFIX)
    261  010c							; = 323 --> /64 = 5.04 USE 7
    262  010c
    263  010c		       b9 89 fc 	      lda	CharacterDataVecHI,y	; 4
    264  010f		       8d 3c f5 	      sta	SM3LOAD+RAM_WRITE+2	; 4
    265  0112		       8d 42 f5 	      sta	SM3LOADb+RAM_WRITE+2	; 4
    266  0115		       8d 48 f5 	      sta	SM3LOADc+RAM_WRITE+2	; 4 = 16
    267  0118
    268  0118		       b9 75 fc 	      lda	CharacterDataVecLO,y	; 4
    269  011b		       8d 3b f5 	      sta	SM3LOAD+RAM_WRITE+1	; 4
    270  011e		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    271  0120		       8d 41 f5 	      sta	SM3LOADb+RAM_WRITE+1	; 4
    272  0123		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    273  0125		       8d 47 f5 	      sta	SM3LOADc+RAM_WRITE+1	; 4 = 20
    274  0128
    275  0128		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    276  012b		       8d 3e f5 	      sta	SM3STORE+RAM_WRITE+1	; 4
    277  012e		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    278  0130		       8d 44 f5 	      sta	SM3STOREb+RAM_WRITE+1	; 4
    279  0133		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    280  0135		       8d 4a f5 	      sta	SM3STOREc+RAM_WRITE+1	; 4 = 20
    281  0138
    282  0138		       a0 06		      ldy	#LINES_PER_CHAR/3 - 1	; 2 =	2
    283  013a				   TSFill3
    284  013a		       b9 00 f0    SM3LOAD    lda	$F000,y	; 4+
    285  013d		       99 87 f6    SM3STORE   sta	ScreenBitmap+RAM_WRITE,y	; 5
    286  0140		       b9 00 f0    SM3LOADb   lda	$F000,y	; 4+
    287  0143		       99 87 f6    SM3STOREb  sta	ScreenBitmap+RAM_WRITE,y	; 5
    288  0146		       b9 00 f0    SM3LOADc   lda	$F000,y	; 4+
    289  0149		       99 87 f6    SM3STOREc  sta	ScreenBitmap+RAM_WRITE,y	; 5 = 27
    290  014c
    291  014c		       88		      dey		; 2
      0  014d					      CHECKPAGE_BPL	TSFill3	; 3(2)=5
      8  014d					      LIST	ON
      9  014d		       10 eb		      bpl	TSFill3
    293  014f
    294  014f		       4c 60 fa 	      jmp	DrawAnother	; 3
    295  0152
    296  0152							; Timing for DirectDraw
    297  0152							; 17+8+16+20+20+2+(32*7)-1+3 = 309 (was: 302 + 3)
    298  0152							; total: 37+309+6 = 352 => 352/64 + 1.4 = 6.90 = 7 (= SEGTIME_SLOWDRAW-5)
    299  0152
    300  0152				   ExitDraw
    301  0152		       60		      rts
    302  0153
    303  0153							;------------------------------------------------------------------------------
      0  0153					      DEFINE_SUBROUTINE	StealPart3	; 18 CYCLES HERE
      1  0153		       00 00	   BANK_StealPart3 =	_CURRENT_BANK
      2  0153					      SUBROUTINE
      3  0153				   StealPart3
    305  0153
    306  0153		       bd ee f1 	      lda	MOD10,x	; 4
    307  0156		       30 81		      bmi	PF0Draw	; 2/3
    308  0158		       4a		      lsr		; 2
    309  0159		       aa		      tax		; 2
    310  015a		       98		      tya		; 2
    311  015b		       2a		      rol		; 2	     allows for mirrored char = * | 1
    312  015c		       a8		      tay		; 2
    313  015d		       b0 a6		      bcs	DirectDraw	; 2(3)      when draw stack was built, bit 7 flags direct-drawn character
    314  015f							;	     => +19 starting DirectDraw BUT WHO CARES AS IT'S ONLY AFTER THAT COUNTS
    315  015f
    316  015f		       b9 89 fc 	      lda	CharacterDataVecHI,y	; 4
    317  0162		       10 38		      bpl	QuickDraw	; 2(3)=42   special-case blank characters for extra speed
    318  0164							;	     => 42 starting QuickDraw
    319  0164		       8d 8d f5 	      sta	SMEOR1+RAM_WRITE+2	; 4 =	4
    320  0167
    321  0167		       ad 84 02 	      lda	INTIM	; 4
    322  016a		       c9 0c		      cmp	#SEGTIME_SCD_SLOW	; 2
    323  016c		       90 e4		      bcc	ExitDraw	; 2(3)=8
      0  016e					      STRESS_TIME	SEGTIME_SCD_SLOW	; ok!
      1  016e				  -	      IF	TEST_SEGTIME_SCD_SLOW = 1
      2  016e				  -
      3  016e				  -
      4  016e				  -
      5  016e				  -
      6  016e				  -
      7  016e				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  016e				  -	      bne	. - 7
      9  016e					      ENDIF
    325  016e
    326  016e							; TIME REQUIRED FROM HERE (9/JAN)
    327  016e							; 8 + 16 + 8 + 2 + (21 * 23) -1 + (42 OVERHEAD WHEN RETURNING)
    328  016e							; = 558 --> /64 = 8.71 INTIM --> USE 10
    329  016e
    330  016e		       b9 75 fc 	      lda	CharacterDataVecLO,y	; 4
    331  0171		       8d 8c f5 	      sta	SMEOR1+RAM_WRITE+1	; 4 =	8
    332  0174
    333  0174		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    334  0177		       8d 89 f5 	      sta	SMLOAD+RAM_WRITE+1	; 4
    335  017a		       8d 91 f5 	      sta	SMEOR2+RAM_WRITE+1	; 4
    336  017d		       8d 94 f5 	      sta	SMSTORE+RAM_WRITE+1	; 4 = 16
    337  0180
    338  0180		       bd e6 f1 	      lda	CharMaskNeg,x	; 4	     masks out left or right
    339  0183		       8d 8f f5 	      sta	SMMASK+RAM_WRITE+1	; 4 =	8
    340  0186
    341  0186		       a0 14	   SlowDraw   ldy	#LINES_PER_CHAR - 1	; 2 =	2
    342  0188
    343  0188							; A very nice bit of Thomas Jentzsch replacement magic giving 77 cycle savings.
    344  0188							; Rewrite for self-modification by Andrew Davie giving another 90 cycles :)
    345  0188
    346  0188				   TSFill
    347  0188
    348  0188		       b9 87 f2    SMLOAD     lda	ScreenBitmap,y	; 4
    349  018b		       59 00 f0    SMEOR1     eor	$F000,y	; 4
    350  018e		       29 00	   SMMASK     and	#0	; 2
    351  0190		       59 87 f2    SMEOR2     eor	ScreenBitmap,y	; 4	     using ScreenBitmap here avoids setting high-pointer
    352  0193		       99 87 f6    SMSTORE    sta	ScreenBitmap+RAM_WRITE,y	; 5 = 19
    353  0196
    354  0196		       88		      dey		; 2
      0  0197					      CHECKPAGE_BPL	TSFill	; 3(2)=5
      8  0197					      LIST	ON
      9  0197		       10 ef		      bpl	TSFill
    356  0199
    357  0199		       4c 60 fa 	      jmp	DrawAnother	; 3
    358  019c
    359  019c							; Timing for "SLOW" draw
    360  019c							; 22+4+8+8+16+8+2+(21*24)-1+3 = 574 (was: 566 + 3)
    361  019c							; total: 37+574+6 = 617 => 628/64 + 1.4 = 11.04 = 12 (= SEGTIME_SLOWDRAW)
    362  019c
    363  019c
    364  019c							;------------------------------------------------------------------------------
    365  019c							; QuickDraw is for drawing BLANK characters.  It just has to mask out the
    366  019c							; existing character data, so can be special-cased from the normal character
    367  019c							; draw, saving roughly 230 cycles.
    368  019c
    369  019c				   QuickDraw		; 42 cycles until here
    370  019c
    371  019c		       ad 84 02 	      lda	INTIM	; 4
    372  019f		       c9 09		      cmp	#SEGTIME_SCD_QUICK	; 2	     SEE TIMING CALCS BELOW
    373  01a1		       90 af		      bcc	ExitDraw	; 2(3)=8
      0  01a3					      STRESS_TIME	SEGTIME_SCD_QUICK	; ok!
      1  01a3				  -	      IF	TEST_SEGTIME_SCD_QUICK = 1
      2  01a3				  -
      3  01a3				  -
      4  01a3				  -
      5  01a3				  -
      6  01a3				  -
      7  01a3				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  01a3				  -	      bne	. - 7
      9  01a3					      ENDIF
    375  01a3
    376  01a3							; TIME REQUIRED FROM HERE (9/JAN)
    377  01a3							;   = 32 + 4 + 2 + ( 7 * 38 ) - 1 + 3	+ (42 SUFFIX)
    378  01a3							;   = 348 --> /64 = 5.43. USE 7
    379  01a3
    380  01a3		       bd dc f1 	      lda	CharAddressLO,x	; 4	     ScreenBitmap(COL) LO byte
    381  01a6		       8d c3 f5 	      sta	SM2LOAD+RAM_WRITE+1	; 4
    382  01a9		       8d c6 f5 	      sta	SM2STORE+RAM_WRITE+1	; 4
    383  01ac		       69 06		      adc	#LINES_PER_CHAR/3 - 1	; 2	     CF is set!
    384  01ae		       8d ca f5 	      sta	SM2LOADb+RAM_WRITE+1	; 4
    385  01b1		       8d cd f5 	      sta	SM2STOREb+RAM_WRITE+1	; 4
    386  01b4		       69 07		      adc	#LINES_PER_CHAR/3	; 2
    387  01b6		       8d d1 f5 	      sta	SM2LOADc+RAM_WRITE+1	; 4
    388  01b9		       8d d4 f5 	      sta	SM2STOREc+RAM_WRITE+1	; 4 = 32
    389  01bc
    390  01bc		       bc e4 f1 	      ldy	CharMask,x	; 4 =	4    masks out left or right
    391  01bf
    392  01bf		       a2 06		      ldx	#LINES_PER_CHAR/3 - 1	; 2 =	2
    393  01c1				   TSFill2
    394  01c1		       98		      tya		; 2
    395  01c2		       3d 87 f2    SM2LOAD    and	ScreenBitmap,x	; 4+
    396  01c5		       9d 87 f6    SM2STORE   sta	ScreenBitmap+RAM_WRITE,x	; 5
    397  01c8		       98		      tya		; 2
    398  01c9		       3d 87 f2    SM2LOADb   and	ScreenBitmap,x	; 4+
    399  01cc		       9d 87 f6    SM2STOREb  sta	ScreenBitmap+RAM_WRITE,x	; 5
    400  01cf		       98		      tya		; 2
    401  01d0		       3d 87 f2    SM2LOADc   and	ScreenBitmap,x	; 4+
    402  01d3		       9d 87 f6    SM2STOREc  sta	ScreenBitmap+RAM_WRITE,x	; 5 = 33
    403  01d6
    404  01d6		       ca		      dex		; 2
      0  01d7					      CHECKPAGE_BPL	TSFill2	; 3(2)=5
      8  01d7					      LIST	ON
      9  01d7		       10 e8		      bpl	TSFill2
    406  01d9
    407  01d9		       4c 60 fa 	      jmp	DrawAnother	; 3
    408  01dc
    409  01dc							; Timing for QuickDraw
    410  01dc							; 23+8+32+4+2+(7*38)-1+3 = 337 (was: 330 + 3)
    411  01dc							; total: 37+337+6 = 380 => 380/64 + 1.4 = 7.34 = 8 (= SEGTIME_SLOWDRAW-4)
    412  01dc
    413  01dc
    414  01dc							;------------------------------------------------------------------------------
    415  01dc
    416  01dc
    417  01dc				   CharAddressLO		;[abs char location % 10]
    418  01dc
    419  01dc							; Gives the absolute screen buffer address of the first line of the given character
    420  01dc							; Where character number is 0-9
    421  01dc
    422  01dc		       87		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 1
    423  01dd		       87		      .byte.b	< ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 2
    424  01de		       9c		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 3
    425  01df		       9c		      .byte.b	< ( ScreenBitmap + ( 1 * LINES_PER_CHAR ))	; 4
    426  01e0		       b1		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 6
    427  01e1		       b1		      .byte.b	< ( ScreenBitmap + ( 2 * LINES_PER_CHAR ))	; 7
    428  01e2		       c6		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 8
    429  01e3		       c6		      .byte.b	< ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 9
    430  01e4							;	      .byte < ( ScreenBitmap + ( 0 * LINES_PER_CHAR ))	; 0 PF0
    431  01e4							;	      .byte < ( ScreenBitmap + ( 3 * LINES_PER_CHAR ))	; 5 PF0
    432  01e4
    433  01e4				   CharMask		; [abs char location % 10]
    434  01e4
    435  01e4							; Gives the mask for any char of the screen (per row)
    436  01e4							; Note, this is hardwired to the screen format of 6 bytes/line
    437  01e4
    438  01e4		       0f		      .byte.b	$0F	; 1
    439  01e5		       f0		      .byte.b	$F0	; 2
    440  01e6				   CharMaskNeg
    441  01e6		       f0		      .byte.b	$F0	; 3/1
    442  01e7		       0f		      .byte.b	$0F	; 4/2
    443  01e8		       0f		      .byte.b	$0F	; 6/3
    444  01e9		       f0		      .byte.b	$F0	; 7/4
    445  01ea		       f0		      .byte.b	$F0	; 8/6
    446  01eb		       0f		      .byte.b	$0F	; 9/7
    447  01ec		       0f		      .byte.b	$0F	; -/8
    448  01ed		       f0		      .byte.b	$F0	; -/9
    449  01ee				   MOD10
    450  01ee					      REPEAT	SCREEN_LINES
    451  01ee							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    452  01ee							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  01ee		       80		      .byte.b	DIRECT
    454  01ef		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  01f3		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    456  01f4		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    450  01f4					      REPEND
    451  01f8							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    452  01f8							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  01f8		       80		      .byte.b	DIRECT
    454  01f9		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  01fd		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    456  01fe		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    450  01fe					      REPEND
    451  0202							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    452  0202							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  0202		       80		      .byte.b	DIRECT
    454  0203		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  0207		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    456  0208		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    450  0208					      REPEND
    451  020c							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    452  020c							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  020c		       80		      .byte.b	DIRECT
    454  020d		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  0211		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    456  0212		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    450  0212					      REPEND
    451  0216							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    452  0216							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  0216		       80		      .byte.b	DIRECT
    454  0217		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  021b		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    456  021c		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    450  021c					      REPEND
    451  0220							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    452  0220							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  0220		       80		      .byte.b	DIRECT
    454  0221		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  0225		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    456  0226		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    450  0226					      REPEND
    451  022a							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    452  022a							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  022a		       80		      .byte.b	DIRECT
    454  022b		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  022f		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    456  0230		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    450  0230					      REPEND
    451  0234							;	  .byte (8*2), MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    452  0234							;	  .byte (9*2), MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    453  0234		       80		      .byte.b	DIRECT
    454  0235		       01 03 04 06	      .byte.b	MIRROR+0*2, MIRROR+1*2, 2*2, 3*2
    455  0239		       9f		      .byte.b	DIRECT+SM_PF0_BLUEr-SM_PF0_BLUEl	; works only if distances between PF= writes are identical!
    456  023a		       09 0b 0c 0e	      .byte.b	MIRROR+4*2, MIRROR+5*2, 6*2, 7*2
    457  023e					      REPEND
    458  023e
    459  023e							;------------------------------------------------------------------------------
    460  023e
------- FILE target.asm LEVEL 3 PASS 3
      0  023e					      include	"target.asm"	; 2 * LINES_PER_CHAR + 2 bytes
      1  023e		       00 02	   TARGET_DEF =	2
      2  023e
      3  023e					      if	TARGET_DEF = 2
      4  023e
      0  023e					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_TARGET", LINES_PER_CHAR+1
     10  023e					      LIST	ON
      6  023e				   CHARACTERSHAPE_TARGET2_MIRRORED
      7  023e		       00		      .byte.b	%00000000
      8  023f				   CHARACTERSHAPE_TARGET_MIRRORED
      9  023f		       00		      .byte.b	%00000000
     10  0240		       66		      .byte.b	%01100110
     11  0241		       66		      .byte.b	%01100110
     12  0242		       66		      .byte.b	%01100110
     13  0243		       66		      .byte.b	%01100110
     14  0244		       00		      .byte.b	%00000000
     15  0245		       00		      .byte.b	%00000000	;R
     16  0246		       00		      .byte.b	%00000000
     17  0247		       66		      .byte.b	%01100110
     18  0248		       66		      .byte.b	%01100110
     19  0249		       66		      .byte.b	%01100110
     20  024a		       66		      .byte.b	%01100110
     21  024b		       00		      .byte.b	%00000000
     22  024c		       00		      .byte.b	%00000000	;B
     23  024d		       00		      .byte.b	%00000000
     24  024e		       66		      .byte.b	%01100110
     25  024f		       66		      .byte.b	%01100110
     26  0250		       66		      .byte.b	%01100110
     27  0251		       66		      .byte.b	%01100110
     28  0252		       00		      .byte.b	%00000000
     29  0253							;    .byte %00000000 ;G
     30  0253
     31  0253							;--------------------------------------------------------------------------
     32  0253							;     OPTIONAL_PAGEBREAK "CHARACTERSHAPE_TARGET_MIRRORED", LINES_PER_CHAR+1
     33  0253				   CHARACTERSHAPE_TARGET2
     34  0253		       00		      .byte.b	%00000000
     35  0254				   CHARACTERSHAPE_TARGET
     36  0254		       00		      .byte.b	%00000000
     37  0255		       66		      .byte.b	%01100110
     38  0256		       66		      .byte.b	%01100110
     39  0257		       66		      .byte.b	%01100110
     40  0258		       66		      .byte.b	%01100110
     41  0259		       00		      .byte.b	%00000000
     42  025a		       00		      .byte.b	%00000000	;R
     43  025b		       00		      .byte.b	%00000000
     44  025c		       66		      .byte.b	%01100110
     45  025d		       66		      .byte.b	%01100110
     46  025e		       66		      .byte.b	%01100110
     47  025f		       66		      .byte.b	%01100110
     48  0260		       00		      .byte.b	%00000000
     49  0261		       00		      .byte.b	%00000000	;B
     50  0262		       00		      .byte.b	%00000000
     51  0263		       66		      .byte.b	%01100110
     52  0264		       66		      .byte.b	%01100110
     53  0265		       66		      .byte.b	%01100110
     54  0266		       66		      .byte.b	%01100110
     55  0267		       00		      .byte.b	%00000000
     56  0268		       00		      .byte.b	%00000000	;G
     57  0269
      0  0269					      CHECKPAGE	CHARACTERSHAPE_TARGET2	; since we share one byte!
      8  0269					      LIST	ON
     59  0269
     60  0269					      endif
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    462  0269		       00 00 00 00*	      ds	30	; todo - fixes a graphical glitch so we have a page boundary issue somewhwere
    463  0287
    464  0287
      0  0287					      OPTIONAL_PAGEBREAK	"SCREEN_BITMAP", SCREEN_BITMAP_SIZE
     10  0287					      LIST	ON
    466  0287
    467  0287		       00 00 00 00*ScreenBitmap ds	SCREEN_BITMAP_SIZE,$0	; character bitmap row (10 chars wide)
    468  0287		       f2 87	   ScreenBitmapRED =	ScreenBitmap + LINES_PER_CHAR/3*0
    469  0287		       f2 8e	   ScreenBitmapGREEN =	ScreenBitmap + LINES_PER_CHAR/3*1
    470  0287		       f2 95	   ScreenBitmapBLUE =	ScreenBitmap + LINES_PER_CHAR/3*2
    471  02db
      0  02db					      CHECKPAGEX	ScreenBitmap, "ScreenBitmap"
      9  02db					      LIST	ON
    473  02db
    474  02db							;--------------------------------------------------------------------------
    475  02db							;    CHARACTER_SET
    476  02db
    477  02db							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    478  02db
    479  02db
      0  02db					      DEFINE_SUBROUTINE	SelfModDrawPlayers	; copied to ROW RAM BANKS
      1  02db		       00 00	   BANK_SelfModDrawPlayers =	_CURRENT_BANK
      2  02db					      SUBROUTINE
      3  02db				   SelfModDrawPlayers
    481  02db
    482  02db							; Now the player(s) have animated, update the appropriate shape pointers
    483  02db							; in the draw code.
    484  02db
    485  02db							; Sets the shapes to a blank player -- effectively erasing
    486  02db		       a5 b0		      lda	LastSpriteY
    487  02dd		       a2 05		      ldx	#<PLAYER_BLANK
    488  02df		       20 ee f2 	      jsr	SetSelfModPlayer
    489  02e2
    490  02e2							; Now we've erased, we write the new shape
    491  02e2
    492  02e2							;		  sec
    493  02e2							;		  lda ManDrawX
    494  02e2							;		  sbc BoardScrollX
    495  02e2							;		  cmp #SCREEN_WIDTH			  ; disabled because we assume always onscreen
    496  02e2							;		  bcs NoMod				  ; skip if off visible screen
    497  02e2
    498  02e2		       a5 9d		      lda	ManDrawX
    499  02e4		       c9 0a		      cmp	#SCREEN_WIDTH	; disabled because we assume always onscreen
    500  02e6		       b0 1c		      bcs	NoMod	; skip if off visible screen
    501  02e8
    502  02e8							;lda LookingAround
    503  02e8							;bne NoMod
    504  02e8
    505  02e8		       a5 9e		      lda	ManDrawY
    506  02ea		       85 b0		      sta	LastSpriteY
    507  02ec
    508  02ec		       a6 a3		      ldx	ManAnimationFrameLO
    509  02ee
    510  02ee				   SetSelfModPlayer
    511  02ee		       c9 08		      cmp	#SCREEN_LINES	; only erase/draw if was/is onscreen
    512  02f0		       b0 12		      bcs	NoMod
    513  02f2		       69 00		      adc	#BANK_SCREENMARKII1
    514  02f4		       85 3e		      sta	SET_BANK_RAM	; switch old/new bank in
    515  02f6
    516  02f6		       8a		      txa
    517  02f7		       8d 20 f4 	      sta	SELFMOD_PLAYER0_RED+RAM_WRITE+1	; lo of frame
    518  02fa		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    519  02fc		       8d 8a f4 	      sta	SELFMOD_PLAYER0_GREEN+RAM_WRITE+1
    520  02ff		       69 07		      adc	#LINES_PER_CHAR/3	;boo-1
    521  0301		       8d 57 f4 	      sta	SELFMOD_PLAYER0_BLUE+RAM_WRITE+1
    522  0304
    523  0304				   NoMod
    524  0304		       60		      rts
    525  0305
      0  0305					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE (1K)"
      1  0305
      2  0305
      3  0305		       03 05	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE (1K) (1K) SIZE =  $305 , FREE= $fb
      4  0305					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE (1K)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0305				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0305				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0305				  -	      ERR
      8  0305					      endif
    527  0305
------- FILE player.asm LEVEL 3 PASS 3
      0  0305					      include	"player.asm"	; 6 * LINES_PER_CHAR	       MUST FOLLOW DIRT.ASM as data is shared
      1  0305							;    OPTIONAL_PAGEBREAK "PLAYER", LINES_PER_CHAR * 6 - 1
      2  0305
      3  0305
      4  0305		       f3 05	   PLAYER_BLANK =	.
      5  0305					      REPEAT	LINES_PER_CHAR	;-1  ; as we have a "0" in the line below
      6  0305		       00		      .byte.b	0
      5  0305					      REPEND
      6  0306		       00		      .byte.b	0
      5  0306					      REPEND
      6  0307		       00		      .byte.b	0
      5  0307					      REPEND
      6  0308		       00		      .byte.b	0
      5  0308					      REPEND
      6  0309		       00		      .byte.b	0
      5  0309					      REPEND
      6  030a		       00		      .byte.b	0
      5  030a					      REPEND
      6  030b		       00		      .byte.b	0
      5  030b					      REPEND
      6  030c		       00		      .byte.b	0
      5  030c					      REPEND
      6  030d		       00		      .byte.b	0
      5  030d					      REPEND
      6  030e		       00		      .byte.b	0
      5  030e					      REPEND
      6  030f		       00		      .byte.b	0
      5  030f					      REPEND
      6  0310		       00		      .byte.b	0
      5  0310					      REPEND
      6  0311		       00		      .byte.b	0
      5  0311					      REPEND
      6  0312		       00		      .byte.b	0
      5  0312					      REPEND
      6  0313		       00		      .byte.b	0
      5  0313					      REPEND
      6  0314		       00		      .byte.b	0
      5  0314					      REPEND
      6  0315		       00		      .byte.b	0
      5  0315					      REPEND
      6  0316		       00		      .byte.b	0
      5  0316					      REPEND
      6  0317		       00		      .byte.b	0
      5  0317					      REPEND
      6  0318		       00		      .byte.b	0
      5  0318					      REPEND
      6  0319		       00		      .byte.b	0
      7  031a					      REPEND
      8  031a
      9  031a				   PLAYER_RIGHT0
     10  031a							;  X XX
     11  031a							;  XXXX
     12  031a							;  XXX
     13  031a							;  XXX
     14  031a							;   XX
     15  031a							;   XX
     16  031a							;   XX
     17  031a							;   XX
     18  031a							;   XXX
     19  031a							;   XXX
     20  031a							;   XX
     21  031a							;   XX
     22  031a							;   XX
     23  031a							;   XX
     24  031a							;  XXXX
     25  031a							;  XXX X
     26  031a							;  XXX X
     27  031a							;  XXX X
     28  031a							;  XXXX
     29  031a							;   XX
     30  031a							;
     31  031a							;---Graphics Data from PlayerPal 2600---
     32  031a
     33  031a
     34  031a					      if	1
     35  031a		       18		      .byte.b	%00011000	;20
     36  031b		       18		      .byte.b	%00011000	;20
     37  031c		       7e		      .byte.b	%01111110	;20
     38  031d		       7e		      .byte.b	%01111110	;20
     39  031e		       7e		      .byte.b	%01111110	;20
     40  031f		       18		      .byte.b	%00011000	;20
     41  0320		       18		      .byte.b	%00011000	;20
     42  0321
     43  0321		       18		      .byte.b	%00011000	;20
     44  0322		       18		      .byte.b	%00011000	;20
     45  0323		       7e		      .byte.b	%01111110	;20
     46  0324		       7e		      .byte.b	%01111110	;20
     47  0325		       7e		      .byte.b	%01111110	;20
     48  0326		       18		      .byte.b	%00011000	;20
     49  0327		       18		      .byte.b	%00011000	;20
     50  0328
     51  0328		       18		      .byte.b	%00011000	;20
     52  0329		       18		      .byte.b	%00011000	;20
     53  032a		       7e		      .byte.b	%01111110	;20
     54  032b		       7e		      .byte.b	%01111110	;20
     55  032c		       7e		      .byte.b	%01111110	;20
     56  032d		       18		      .byte.b	%00011000	;20
     57  032e		       18		      .byte.b	%00011000	;20
     58  032f
     59  032f				  -	      else
     60  032f				  -			;push
     61  032f				  -	      .byte	#%01110000	;$1C 0
     62  032f				  -	      .byte	#%01110000	;$78 3
     63  032f				  -	      .byte	#%00010000	;$52 6
     64  032f				  -	      .byte	#%00111100	;$52 9
     65  032f				  -	      .byte	#%00011001	;$0C 12
     66  032f				  -	      .byte	#%00001100	;$4A 15
     67  032f				  -	      .byte	#%00001111	;$1A18
     68  032f				  -
     69  032f				  -	      .byte	#%10100000	;$1C 1
     70  032f				  -	      .byte	#%00111000	;$78 4
     71  032f				  -	      .byte	#%00111000	;$52 7
     72  032f				  -	      .byte	#%00111100	;$56 10
     73  032f				  -	      .byte	#%00001000	;$4A 13
     74  032f				  -	      .byte	#%00001100	;$4A 16
     75  032f				  -	      .byte	#%00001100	;$1C 19
     76  032f				  -
     77  032f				  -	      .byte	#%11010000	;$78 2
     78  032f				  -	      .byte	#%00101000	;$78 5
     79  032f				  -	      .byte	#%00111000	;$52 8
     80  032f				  -	      .byte	#%00011111	;$56 11
     81  032f				  -	      .byte	#%00001000	;$4A 14
     82  032f				  -	      .byte	#%00011010	;$4A 17
     83  032f				  -	      .byte	#%00001100	;$1C 20
     84  032f				  -
     85  032f					      endif
     86  032f
     87  032f				  -	      IF	0
     88  032f				  -			;---Graphics Data from PlayerPal 2600---
     89  032f				  -
     90  032f				  -Frame0
     91  032f				  -	      .byte	#%01110011	;$1C
     92  032f				  -	      .byte	#%00100110	;$1C
     93  032f				  -	      .byte	#%00110100	;$78
     94  032f				  -	      .byte	#%00010100	;$78
     95  032f				  -	      .byte	#%00011100	;$78
     96  032f				  -	      .byte	#%00001000	;$78
     97  032f				  -	      .byte	#%00010000	;$52
     98  032f				  -	      .byte	#%00111000	;$52
     99  032f				  -	      .byte	#%00111000	;$52
    100  032f				  -	      .byte	#%10111000	;$52
    101  032f				  -	      .byte	#%01111000	;$56
    102  032f				  -	      .byte	#%00110000	;$56
    103  032f				  -	      .byte	#%00111100	;$0C
    104  032f				  -	      .byte	#%00110010	;$4A
    105  032f				  -	      .byte	#%00010000	;$4A
    106  032f				  -	      .byte	#%00011000	;$4A
    107  032f				  -	      .byte	#%00011000	;$4A
    108  032f				  -	      .byte	#%00110100	;$4A
    109  032f				  -	      .byte	#%00011110	;$1A
    110  032f				  -	      .byte	#%00011000	;$1C
    111  032f				  -	      .byte	#%00011000	;$1C
    112  032f				  -Frame1
    113  032f				  -	      .byte	#%00110110	;$1C
    114  032f				  -	      .byte	#%00100100	;$1C
    115  032f				  -	      .byte	#%00010100	;$78
    116  032f				  -	      .byte	#%00010100	;$78
    117  032f				  -	      .byte	#%00011100	;$78
    118  032f				  -	      .byte	#%00001000	;$78
    119  032f				  -	      .byte	#%00010000	;$52
    120  032f				  -	      .byte	#%00111000	;$52
    121  032f				  -	      .byte	#%00011000	;$52
    122  032f				  -	      .byte	#%01111000	;$52
    123  032f				  -	      .byte	#%00111000	;$56
    124  032f				  -	      .byte	#%00110110	;$56
    125  032f				  -	      .byte	#%00111100	;$0C
    126  032f				  -	      .byte	#%00010000	;$4A
    127  032f				  -	      .byte	#%00010000	;$4A
    128  032f				  -	      .byte	#%00011000	;$4A
    129  032f				  -	      .byte	#%00011000	;$4A
    130  032f				  -	      .byte	#%00110100	;$4A
    131  032f				  -	      .byte	#%00011110	;$1A
    132  032f				  -	      .byte	#%00011000	;$1C
    133  032f				  -	      .byte	#%00011000	;$1C
    134  032f				  -Frame2
    135  032f				  -	      .byte	#%00011000	;$1C
    136  032f				  -	      .byte	#%00110000	;$1C
    137  032f				  -	      .byte	#%01010000	;$78
    138  032f				  -	      .byte	#%00111000	;$78
    139  032f				  -	      .byte	#%00011000	;$78
    140  032f				  -	      .byte	#%00001000	;$78
    141  032f				  -	      .byte	#%00010000	;$52
    142  032f				  -	      .byte	#%00111000	;$52
    143  032f				  -	      .byte	#%00111000	;$52
    144  032f				  -	      .byte	#%00111100	;$52
    145  032f				  -	      .byte	#%00110100	;$56
    146  032f				  -	      .byte	#%00111100	;$56
    147  032f				  -	      .byte	#%00111000	;$0C
    148  032f				  -	      .byte	#%00010000	;$4A
    149  032f				  -	      .byte	#%00010000	;$4A
    150  032f				  -	      .byte	#%00011000	;$4A
    151  032f				  -	      .byte	#%00011000	;$4A
    152  032f				  -	      .byte	#%00110100	;$4A
    153  032f				  -	      .byte	#%00011110	;$1A
    154  032f				  -	      .byte	#%00011000	;$1C
    155  032f				  -	      .byte	#%00011000	;$1C
    156  032f				  -Frame3
    157  032f				  -	      .byte	#%01110000	;$1C
    158  032f				  -	      .byte	#%10100000	;$1C
    159  032f				  -	      .byte	#%11010000	;$78
    160  032f				  -	      .byte	#%01110000	;$78
    161  032f				  -	      .byte	#%00111000	;$78
    162  032f				  -	      .byte	#%00101000	;$78
    163  032f				  -	      .byte	#%00010000	;$52
    164  032f				  -	      .byte	#%00111000	;$52
    165  032f				  -	      .byte	#%00111000	;$52
    166  032f				  -	      .byte	#%00111100	;$52
    167  032f				  -	      .byte	#%00111100	;$56
    168  032f				  -	      .byte	#%00011111	;$56
    169  032f				  -	      .byte	#%00011001	;$0C
    170  032f				  -	      .byte	#%00001000	;$4A
    171  032f				  -	      .byte	#%00001000	;$4A
    172  032f				  -	      .byte	#%00001100	;$4A
    173  032f				  -	      .byte	#%00001100	;$4A
    174  032f				  -	      .byte	#%00011010	;$4A
    175  032f				  -	      .byte	#%00001111	;$1A
    176  032f				  -	      .byte	#%00001100	;$1C
    177  032f				  -	      .byte	#%00001100	;$1C
    178  032f				  -Frame4
    179  032f				  -	      .byte	#%00110110	;$1C
    180  032f				  -	      .byte	#%00010100	;$1C
    181  032f				  -	      .byte	#%00010100	;$78
    182  032f				  -	      .byte	#%00010100	;$78
    183  032f				  -	      .byte	#%00011100	;$78
    184  032f				  -	      .byte	#%00001100	;$78
    185  032f				  -	      .byte	#%00010000	;$52
    186  032f				  -	      .byte	#%00011000	;$52
    187  032f				  -	      .byte	#%00011100	;$52
    188  032f				  -	      .byte	#%00111100	;$52
    189  032f				  -	      .byte	#%00111100	;$56
    190  032f				  -	      .byte	#%00111100	;$56
    191  032f				  -	      .byte	#%00111110	;$0C
    192  032f				  -	      .byte	#%01011010	;$4A
    193  032f				  -	      .byte	#%10010001	;$4A
    194  032f				  -	      .byte	#%10011001	;$4A
    195  032f				  -	      .byte	#%00011000	;$4A
    196  032f				  -	      .byte	#%00011000	;$4A
    197  032f				  -	      .byte	#%00011100	;$1A
    198  032f				  -	      .byte	#%00011000	;$1C
    199  032f				  -	      .byte	#%00010000	;$1C
    200  032f				  -Frame5
    201  032f				  -	      .byte	#%00110110	;$1C
    202  032f				  -	      .byte	#%00010100	;$1C
    203  032f				  -	      .byte	#%00010100	;$78
    204  032f				  -	      .byte	#%00010100	;$78
    205  032f				  -	      .byte	#%00011100	;$78
    206  032f				  -	      .byte	#%01001101	;$78
    207  032f				  -	      .byte	#%01010001	;$52
    208  032f				  -	      .byte	#%01011011	;$52
    209  032f				  -	      .byte	#%01011110	;$52
    210  032f				  -	      .byte	#%00111100	;$52
    211  032f				  -	      .byte	#%00111100	;$56
    212  032f				  -	      .byte	#%00011100	;$56
    213  032f				  -	      .byte	#%00011000	;$0C
    214  032f				  -	      .byte	#%00011000	;$4A
    215  032f				  -	      .byte	#%00011000	;$4A
    216  032f				  -	      .byte	#%00111000	;$4A
    217  032f				  -	      .byte	#%00001000	;$4A
    218  032f				  -	      .byte	#%00000000	;$4A
    219  032f				  -	      .byte	#%00000000	;$1A
    220  032f				  -	      .byte	#%00000000	;$1C
    221  032f				  -	      .byte	#%00000000	;$1C
    222  032f				  -			;---End Graphics Data---
    223  032f				  -
    224  032f				  -
    225  032f				  -			;---Color Data from PlayerPal 2600---
    226  032f				  -
    227  032f				  -ColorFrame0
    228  032f				  -	      .byte	#$1C	;
    229  032f				  -	      .byte	#$1C	;
    230  032f				  -	      .byte	#$78	;
    231  032f				  -	      .byte	#$78	;
    232  032f				  -	      .byte	#$78	;
    233  032f				  -	      .byte	#$78	;
    234  032f				  -	      .byte	#$52	;
    235  032f				  -	      .byte	#$52	;
    236  032f				  -	      .byte	#$52	;
    237  032f				  -	      .byte	#$52	;
    238  032f				  -	      .byte	#$56	;
    239  032f				  -	      .byte	#$56	;
    240  032f				  -	      .byte	#$0C	;
    241  032f				  -	      .byte	#$4A	;
    242  032f				  -	      .byte	#$4A	;
    243  032f				  -	      .byte	#$4A	;
    244  032f				  -	      .byte	#$4A	;
    245  032f				  -	      .byte	#$4A	;
    246  032f				  -	      .byte	#$1A	;
    247  032f				  -	      .byte	#$1C	;
    248  032f				  -	      .byte	#$1C	;
    249  032f				  -ColorFrame1
    250  032f				  -	      .byte	#$1C	;
    251  032f				  -	      .byte	#$1C	;
    252  032f				  -	      .byte	#$78	;
    253  032f				  -	      .byte	#$78	;
    254  032f				  -	      .byte	#$78	;
    255  032f				  -	      .byte	#$78	;
    256  032f				  -	      .byte	#$52	;
    257  032f				  -	      .byte	#$52	;
    258  032f				  -	      .byte	#$52	;
    259  032f				  -	      .byte	#$52	;
    260  032f				  -	      .byte	#$56	;
    261  032f				  -	      .byte	#$56	;
    262  032f				  -	      .byte	#$0C	;
    263  032f				  -	      .byte	#$4A	;
    264  032f				  -	      .byte	#$4A	;
    265  032f				  -	      .byte	#$4A	;
    266  032f				  -	      .byte	#$4A	;
    267  032f				  -	      .byte	#$4A	;
    268  032f				  -	      .byte	#$1A	;
    269  032f				  -	      .byte	#$1C	;
    270  032f				  -	      .byte	#$1C	;
    271  032f				  -ColorFrame2
    272  032f				  -	      .byte	#$1C	;
    273  032f				  -	      .byte	#$1C	;
    274  032f				  -	      .byte	#$78	;
    275  032f				  -	      .byte	#$78	;
    276  032f				  -	      .byte	#$78	;
    277  032f				  -	      .byte	#$78	;
    278  032f				  -	      .byte	#$52	;
    279  032f				  -	      .byte	#$52	;
    280  032f				  -	      .byte	#$52	;
    281  032f				  -	      .byte	#$52	;
    282  032f				  -	      .byte	#$56	;
    283  032f				  -	      .byte	#$56	;
    284  032f				  -	      .byte	#$0C	;
    285  032f				  -	      .byte	#$4A	;
    286  032f				  -	      .byte	#$4A	;
    287  032f				  -	      .byte	#$4A	;
    288  032f				  -	      .byte	#$4A	;
    289  032f				  -	      .byte	#$4A	;
    290  032f				  -	      .byte	#$1A	;
    291  032f				  -	      .byte	#$1C	;
    292  032f				  -	      .byte	#$1C	;
    293  032f				  -ColorFrame3
    294  032f				  -	      .byte	#$1C	;
    295  032f				  -	      .byte	#$1C	;
    296  032f				  -	      .byte	#$78	;
    297  032f				  -	      .byte	#$78	;
    298  032f				  -	      .byte	#$78	;
    299  032f				  -	      .byte	#$78	;
    300  032f				  -	      .byte	#$52	;
    301  032f				  -	      .byte	#$52	;
    302  032f				  -	      .byte	#$52	;
    303  032f				  -	      .byte	#$52	;
    304  032f				  -	      .byte	#$56	;
    305  032f				  -	      .byte	#$56	;
    306  032f				  -	      .byte	#$0C	;
    307  032f				  -	      .byte	#$4A	;
    308  032f				  -	      .byte	#$4A	;
    309  032f				  -	      .byte	#$4A	;
    310  032f				  -	      .byte	#$4A	;
    311  032f				  -	      .byte	#$4A	;
    312  032f				  -	      .byte	#$1A	;
    313  032f				  -	      .byte	#$1C	;
    314  032f				  -	      .byte	#$1C	;
    315  032f				  -ColorFrame4
    316  032f				  -	      .byte	#$1C	;
    317  032f				  -	      .byte	#$1C	;
    318  032f				  -	      .byte	#$78	;
    319  032f				  -	      .byte	#$78	;
    320  032f				  -	      .byte	#$78	;
    321  032f				  -	      .byte	#$78	;
    322  032f				  -	      .byte	#$52	;
    323  032f				  -	      .byte	#$52	;
    324  032f				  -	      .byte	#$52	;
    325  032f				  -	      .byte	#$52	;
    326  032f				  -	      .byte	#$56	;
    327  032f				  -	      .byte	#$56	;
    328  032f				  -	      .byte	#$0C	;
    329  032f				  -	      .byte	#$4A	;
    330  032f				  -	      .byte	#$4A	;
    331  032f				  -	      .byte	#$4A	;
    332  032f				  -	      .byte	#$4A	;
    333  032f				  -	      .byte	#$4A	;
    334  032f				  -	      .byte	#$1A	;
    335  032f				  -	      .byte	#$1C	;
    336  032f				  -	      .byte	#$1C	;
    337  032f				  -ColorFrame5
    338  032f				  -	      .byte	#$1C	;
    339  032f				  -	      .byte	#$1C	;
    340  032f				  -	      .byte	#$78	;
    341  032f				  -	      .byte	#$78	;
    342  032f				  -	      .byte	#$78	;
    343  032f				  -	      .byte	#$78	;
    344  032f				  -	      .byte	#$52	;
    345  032f				  -	      .byte	#$52	;
    346  032f				  -	      .byte	#$52	;
    347  032f				  -	      .byte	#$52	;
    348  032f				  -	      .byte	#$56	;
    349  032f				  -	      .byte	#$56	;
    350  032f				  -	      .byte	#$0C	;
    351  032f				  -	      .byte	#$4A	;
    352  032f				  -	      .byte	#$4A	;
    353  032f				  -	      .byte	#$4A	;
    354  032f				  -	      .byte	#$4A	;
    355  032f				  -	      .byte	#$4A	;
    356  032f				  -	      .byte	#$1A	;
    357  032f				  -	      .byte	#$1C	;
    358  032f				  -	      .byte	#$1C	;
    359  032f				  -			;---End Color Data---
    360  032f					      ENDIF
    361  032f
    362  032f
    363  032f							;.byte %00011000  ;  XXX   ; 0
    364  032f							;.byte %00111100  ;XXXXXX  ; 1
    365  032f							;.byte %01110100  ;XXXX X  ; 2 etc.
    366  032f							;.byte %01111100  ;XXXXXX  ; 3
    367  032f							;.byte %00111000  ;XXXXX   ;4
    368  032f							;.byte %01111100  ; XXXXX  ;5
    369  032f							;.byte %00111000  ;  XXX   ;6
    370  032f							;.byte %11111000  ;XXXXX   ;7
    371  032f							;.byte %11111100  ;XXXXXX  ;8
    372  032f							;.byte %11111100  ;XXXXXX  ;9 etc.
    373  032f							;.byte %10000100  ;X	 X  ;10
    374  032f							;.byte %11111100  ;XXXXXX  ;11
    375  032f							;.byte %00001100  ;	XX  ;12
    376  032f							;.byte %01111100  ; XXXXX  ;13
    377  032f							;.byte %01111100  ; XXXXX  ;14
    378  032f							;.byte %01111000  ; XXXX   ;15
    379  032f							;.byte %01111000  ; XXXX   ;16 etc.
    380  032f							;.byte %11111000  ;XXXXX   ;17
    381  032f							;.byte %11101100  ;XXX XX  ;18
    382  032f							;.byte %10111100  ;X XXXX  ;19
    383  032f							;.byte %11001100  ;XX	XX   20
    384  032f
    385  032f							;---Graphics Data from PlayerPal 2600---
    386  032f
    387  032f				   PLAYER_RIGHT1
    388  032f				   PLAYER_STAND
    389  032f				   PLAYER_BLINK
    390  032f				   PLAYER_TAP0
    391  032f				   PLAYER_TAP1
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
------- FILE filler.asm LEVEL 3 PASS 3
      0  032f					      include	"filler.asm"	; 2 * LINES_PER_CHAR bytes
      1  032f
      0  032f					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_SOIL", LINES_PER_CHAR
     10  032f					      LIST	ON
      3  032f				   CHARACTERSHAPE_SOIL
      4  032f				   CHARACTERSHAPE_SOIL_MIRRORED
      5  032f		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
      6  0336		       ff		      .byte.b	%11111111
      7  0337		       ff		      .byte.b	%11111111
      8  0338		       ff		      .byte.b	%11111111
      9  0339		       ff		      .byte.b	%11111111
     10  033a		       ff		      .byte.b	%11111111
     11  033b		       ff		      .byte.b	%11111111
     12  033c		       ff		      .byte.b	%11111111
     13  033d		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0
------- FILE BANK_ROM_SHADOW_RAMBANK.asm
    530  0344							;------------------------------------------------------------------------------
    531  0344
    532  0344							;ECHO "TOTAL ROW-BANK CODE REQUIREMENT = ", * - BANK_START
    533  0344
    534  0344							;------------------------------------------------------------------------------
    535  0344
    536  0344
    537  0344
    538  0344							;	 CHECK_HALF_BANK_SIZE "ROM_SHADOW_OF_RAMBANK_CODE"
    539  0344
    540  0344
    541  0344							; Here there's another 1K of usable ROM....
    542  0344							; BUT!!! WE CAN'T HAVE ANYTHING REQUIRED IN THE ROM_SHADOW (IN RAM) IN THIS HALF
    543  0344
    544  0344							;-----------------------------------------------------------
    545  0344							; Stella 3E autodetect signature, can live anywhere
    546  0344		       85 3e a9 00	      .byte.b	$85, $3E, $A9, $00
    547  0348							;-----------------------------------------------------------
    548  0348
      0  0348					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K"
      1  0348		       03 48	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_RAMBANK_CODE -- full 2K (2K) SIZE =  $348 , FREE= $4b8
      2  0348					      ECHO	"ROM_SHADOW_OF_RAMBANK_CODE -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0348				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0348				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0348				  -	      ERR
      6  0348					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm LEVEL 2 PASS 3
      0  0348					      include	"BANK_ROM_SHADOW_DRAWBUFFERS.asm"
      1  0348							;------------------------------------------------------------------------------
      2  0348							;##############################################################################
      3  0348							;------------------------------------------------------------------------------
      4  0348
      0  0348					      NEWBANK	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      1  0ff0 ????				      SEG	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      2  0800					      ORG	ORIGIN
      3  0800					      RORG	$F000
      4  0800				   BANK_START SET	*
      5  0800				   ROM_SHADOW_OF_BANK_DRAW_BUFFERS SET	ORIGIN / 2048
      6  0800				   ORIGIN     SET	ORIGIN + 2048
      7  0800				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_DRAW_BUFFERS
      6  0800
      7  0800							; NOTE: Access to these buffers must NOT overlap pages...
      8  0800							; NOTE: We get auto-initialisation of these variables from the ROM values by
      9  0800							; copying the whole bank into the RAM bank.  Neato.
     10  0800
     11  0800		       00 50	   DRAW_STACK_SIZE =	SCREEN_ARRAY_SIZE	; <-- TJ TRY CHANGING THIS TO (SAY) 15  (!!)
     12  0800
     13  0800
     14  0800
     15  0800		       00 00 00 00*DrawStack  ds	DRAW_STACK_SIZE,0	; a stack of character #'s to draw
     16  0850		       00 00 00 00*DrawFlag   ds	SCREEN_ARRAY_SIZE,0	; holds new character to draw at position
     17  08a0
      0  08a0					      OPTIONAL_PAGEBREAK	"ScreenBuffer", SCREEN_ARRAY_SIZE
     10  08a0					      LIST	ON
     19  08a0
     20  08a0							; D7 of ScreenBuffer indicates if a DirectDraw is to be used to draw this character
     21  08a0							; Note: this may actually cause two characters to be drawn -- for the price of one.  This is *exactly*
     22  08a0							; what we want to happen!
     23  08a0
     24  08a0		       00 00 00 00*ScreenBuffer ds	SCREEN_ARRAY_SIZE,0	; the char buffer for delta-drawing
     25  08f0
     26  08f0
     27  08f0
     28  08f0							;------------------------------------------------------------------------------
     29  08f0							; RAM-BASED SUBROUTINES...
     30  08f0							; NOTE: When calling these routines, remember you are actually calling the ROM routine
     31  08f0							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
     32  08f0							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
     33  08f0							; the RAM-based routine.
     34  08f0
     35  08f0
     36  08f0
     37  08f0							;------------------------------------------------------------------------------
     38  08f0
     39  08f0
     40  08f0		       60	   waitForDraw rts		; 6
     41  08f1
     42  08f1							;------------------------------------------------------------------------------
     43  08f1
      0  08f1					      DEFINE_SUBROUTINE	DrawStackUpdate	;=196 (+13 for fall-through bit)
      1  08f1		       00 01	   BANK_DrawStackUpdate =	_CURRENT_BANK
      2  08f1					      SUBROUTINE
      3  08f1				   DrawStackUpdate
     45  08f1
     46  08f1							; Parse the DrawFlags buffer and create a draw stack
     47  08f1							; so that the actual draw doesn't need to scan for characters to draw.
     48  08f1
     49  08f1
     50  08f1							;@TJ -- let's see if we see any bad lag/shear in screen drawing without this wait in.
     51  08f1							; symptoms would be missing parts of screen when scrolling.
     52  08f1							; Gameplay (not visual) lag noticed - re-enabled 11/8/11
     53  08f1							; disabled for sokoban 27/7/2019
     54  08f1
     55  08f1		       a5 84		      lda	DrawStackPointer
     56  08f3							;bpl waitForDraw		  ; Wait for previously not-drawn characters to be drawn
     57  08f3
     58  08f3		       ad 84 02 	      lda	INTIM	;4
     59  08f6		       c9 05		      cmp	#SEGTIME_BDS	;2
     60  08f8		       90 f6		      bcc	waitForDraw	;2/3
      0  08fa					      STRESS_TIME	SEGTIME_BDS
      1  08fa				  -	      IF	TEST_SEGTIME_BDS = 1
      2  08fa				  -
      3  08fa				  -
      4  08fa				  -
      5  08fa				  -
      6  08fa				  -
      7  08fa				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  08fa				  -	      bne	. - 7
      9  08fa					      ENDIF
     62  08fa
     63  08fa
     64  08fa							; Now that all characters are drawn, recalculate/move sprite. Doing this here prevents the player
     65  08fa							; moving into the middle of dirt, or BOXs when pushing, or TARGETs when grabbing.
     66  08fa
     67  08fa							;		  sec		 already set
     68  08fa		       a5 9c		      lda	ManY	;3
     69  08fc		       e5 96		      sbc	BoardScrollY	;3
     70  08fe		       85 9e		      sta	ManDrawY	;3
     71  0900
     72  0900		       38		      sec		;2
     73  0901		       a5 9b		      lda	ManX	;3
     74  0903		       e5 97		      sbc	BoardScrollX	;3
     75  0905		       c9 0a		      cmp	#SCREEN_WIDTH	;2
     76  0907		       90 06		      bcc	onsc	;2/3
     77  0909
     78  0909							; if the man is offscreen, we have a timing issue between the horizontal positioning code and the player
     79  0909							; draw code.  The following gets around this by setting the Y offscreen (causing the player draw code to
     80  0909							; blank the graphic) and leaving the X alone (so we don't see a brief flash in left of screen).
     81  0909
     82  0909		       a9 08		      lda	#SCREEN_LINES	;2
     83  090b		       85 9e		      sta	ManDrawY	;3
     84  090d		       d0 02		      bne	skipsc	;3		  unconditional
     85  090f
     86  090f		       85 9d	   onsc       sta	ManDrawX	;3
     87  0911				   skipsc
     88  0911
     89  0911		       e6 b1		      inc	timer	;5
     90  0913		       4c 9d fc 	      jmp	AnimateCharReplacements2	;3+139
     91  0916				   retAnim
     92  0916
     93  0916		       e6 89		      inc	ScreenDrawPhase	;5
     94  0918
     95  0918		       a9 4f		      lda	#SCREEN_ARRAY_SIZE-1	;2
     96  091a		       85 cc		      sta	DSL	;3
     97  091c
     98  091c							; fall through...
     99  091c							;---------------------------------------------------------------------------
    100  091c
      0  091c					      DEFINE_SUBROUTINE	DrawIntoStack
      1  091c		       00 01	   BANK_DrawIntoStack =	_CURRENT_BANK
      2  091c					      SUBROUTINE
      3  091c				   DrawIntoStack
    102  091c
    103  091c		       ba		      tsx		;2
    104  091d		       86 d8		      stx	save_SP	;3
    105  091f		       a6 84		      ldx	DrawStackPointer	;3
    106  0921		       9a		      txs		;2 = 10
    107  0922
    108  0922		       a4 cc		      ldy	DSL	;3
    109  0924
    110  0924							; worst-case DrawStackOne loop = 61 cycles per character (+11 for first one)
    111  0924							; + exit cost which is +10 cycles
    112  0924							; TJ: I count 63
    113  0924							;   + 14 for the wtf2 exit
    114  0924							;   + 22 for the end of loop exit
    115  0924
    116  0924							; This loops 80 times/frame and is called 1-2 times/frame, so any saving inside the loop will make up for a lot of overhead outside
    117  0924							; For 80 iterations that is 640 cycles, just for checking INTIM
    118  0924							; Worst case we would have ~5000. Though that will most likely never happen, we have to optimize for it, since
    119  0924							; it also will require a lot of CPU time for updating the screen data.
    120  0924
    121  0924							; TODO: optimize!
    122  0924							;
    123  0924							; idea #4: the mixed draw idea (two different characters have to be redrawn),
    124  0924							; first do a QuickDraw and then a SlowDraw, faster than two SlowDraws
    125  0924							; costs some detection time here, but saves ~240 cylces for drawing the two
    126  0924
    127  0924		       ad 84 02    .loopDrawStack lda	INTIM	;4
    128  0927		       c9 05		      cmp	#SEGTIME_DSL	;2
    129  0929		       90 4d		      bcc	.exitDrawStack	;2/3= 8/9
      0  092b					      STRESS_TIME	SEGTIME_DSL
      1  092b				  -	      IF	TEST_SEGTIME_DSL = 1
      2  092b				  -
      3  092b				  -
      4  092b				  -
      5  092b				  -
      6  092b				  -
      7  092b				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  092b				  -	      bne	. - 7
      9  092b					      ENDIF
    131  092b
    132  092b		       b9 50 f0 	      lda	DrawFlag,y	;4
    133  092e		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    134  0931		       f0 16		      beq	.next0	;2/3=10/11	 yes, so we don't draw anything
    135  0933
    136  0933							; Character is NOT the same. Figure out how it should be drawn.
    137  0933							; If it is in column 0 or 5 then it can be DirectDrawn (indirectly found by a A:A compare)
    138  0933							; If it is the same as its paired character (sharing same PF byte) then it can be DirectDrawn
    139  0933							; The top bit of the ScreenBuffer character indicates the DirectDrawn hint
    140  0933
    141  0933		       be 81 f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    142  0936		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    143  0939		       d0 05		      bne	.notPaired0	;2/3=10/11
    144  093b
    145  093b							; Consider two 'paired' characters. Either A:A or A:B
    146  093b							; When we're scanning, and we check the first, if they are NOT paired, then the second character
    147  093b							; can be considered in isolation -- its check comes later, will determine itself if the pair can be written
    148  093b							; If, however, the first character IS paired, then the write below will cause the second check to FAIL
    149  093b							; on the comparison, so the character will not be added to the draw stack. So our first character will
    150  093b							; do the job of drawing BOTH characters to the screen.
    151  093b
    152  093b		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    153  093e		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    154  0940
    155  0940							; In the case of columns 0 and 5, the X and Y registers will be the same -- no problemo, because
    156  0940							; the last write(below) marks the character as to be direct-drawn.
    157  0940
    158  0940		       99 a0 f4    .notPaired0 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    159  0943
    160  0943							; The following 'pla' really just increments the draw-stack pointer.  Value is unimportant. Unusual!
    161  0943
    162  0943		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    163  0944		       98		      tya		;2
    164  0945		       ba		      tsx		;2		 << now X holds drawstackpointer
    165  0946		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    166  0949
    167  0949		       88	   .next0     dey		;2
    168  094a		       30 21		      bmi	.finishedDrawStack	;2/3= 4/5
    169  094c
    170  094c							; unrolled 2nd loop:
    171  094c		       b9 50 f0 	      lda	DrawFlag,y	;4
    172  094f		       d9 a0 f0 	      cmp	ScreenBuffer,y	;4		 Is the character already there the same as the new one?
    173  0952		       f0 16		      beq	.next1	;2/3=10/11	 yes, so we don't draw anything
    174  0954
    175  0954		       be 81 f1 	      ldx	PairedCharacter,y	;4		 the "paired" character for this one
    176  0957		       dd 50 f0 	      cmp	DrawFlag,x	;4		 same as partner character in new drawn screen?
    177  095a		       d0 05		      bne	.notPaired1	;2/3=10/11
    178  095c
    179  095c		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	;5		 mark paired character as drawn already (!!)
    180  095f		       09 80		      ora	#$80	;2 =  7	 DirectDraw this character 'pair'
    181  0961
    182  0961		       99 a0 f4    .notPaired1 sta	ScreenBuffer+RAM_WRITE,y	;5		 NEW character to draw + DirectDraw flag (128)
    183  0964
    184  0964		       68		      pla		;4		 ASSUMPTION IS WE DON'T OvERFLOW DRAW STACK
    185  0965		       98		      tya		;2
    186  0966		       ba		      tsx		;2
    187  0967		       9d 00 f4 	      sta	DrawStack+RAM_WRITE,x	;5 = 18	 index of character to draw
    188  096a
    189  096a		       88	   .next1     dey		;2
    190  096b		       10 b7		      bpl	.loopDrawStack	;2/3= 4/5
    191  096d							;worst case: 111-4
    192  096d							;40 loops(-4), max. 2 calls(+20) -> -160+40=-120, +8 bytes
    193  096d
    194  096d							; THE FOLLOWING OPTIMISATION IS STUFFED IF PROCESSOBJSTACK is not first in the vector processor!
    195  096d
    196  096d				   .finishedDrawStack
    197  096d		       e6 89		      inc	ScreenDrawPhase	;5 =  5
    198  096f		       ba		      tsx		;2
    199  0970		       86 84		      stx	DrawStackPointer	;3
    200  0972		       a6 d8		      ldx	save_SP	;3
    201  0974		       9a		      txs		;2 = 10
    202  0975
    203  0975		       4c 96 f8 	      jmp	SwitchObjects
    204  0978
    205  0978							;rts				  ;6 =	6
    206  0978
    207  0978				   .exitDrawStack
    208  0978		       84 cc		      sty	DSL	;3 =  3
    209  097a		       ba		      tsx		;2
    210  097b		       86 84		      stx	DrawStackPointer	;3
    211  097d		       a6 d8		      ldx	save_SP	;3
    212  097f		       9a		      txs		;2 = 10
    213  0980		       60		      rts		;6 =  6
    214  0981
    215  0981				   PairedCharacter
    216  0981
    217  0981				   SOFF       SET	0
    218  0981					      REPEAT	SCREEN_LINES
    219  0981		       00 02 01 04*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    220  0981				   SOFF       SET	SOFF + SCREEN_WIDTH
    218  0981					      REPEND
    219  098b		       0a 0c 0b 0e*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    220  098b				   SOFF       SET	SOFF + SCREEN_WIDTH
    218  098b					      REPEND
    219  0995		       14 16 15 18*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    220  0995				   SOFF       SET	SOFF + SCREEN_WIDTH
    218  0995					      REPEND
    219  099f		       1e 20 1f 22*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    220  099f				   SOFF       SET	SOFF + SCREEN_WIDTH
    218  099f					      REPEND
    219  09a9		       28 2a 29 2c*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    220  09a9				   SOFF       SET	SOFF + SCREEN_WIDTH
    218  09a9					      REPEND
    219  09b3		       32 34 33 36*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    220  09b3				   SOFF       SET	SOFF + SCREEN_WIDTH
    218  09b3					      REPEND
    219  09bd		       3c 3e 3d 40*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    220  09bd				   SOFF       SET	SOFF + SCREEN_WIDTH
    218  09bd					      REPEND
    219  09c7		       46 48 47 4a*	      .byte.b	SOFF,SOFF+2,SOFF+1,SOFF+4,SOFF+3,SOFF+5,SOFF+7,SOFF+6,SOFF+9,SOFF+8
    220  09c7				   SOFF       SET	SOFF + SCREEN_WIDTH
    221  09d1					      REPEND
    222  09d1
    223  09d1							;------------------------------------------------------------------------------
    224  09d1							; Gives character replacements used during screen drawing.
    225  09d1							; The character from the board is morphed via this array into an actual character
    226  09d1							; to draw.  This allows global animation and replacment of characters without
    227  09d1							; individual objects needing to do this.  Note, the draw-time replacement happens,
    228  09d1							; not board-time.
    229  09d1
    230  09d1				   CharReplacement		; in RAM -- BANK_DRAW_BUFFERS
    231  09d1
    232  09d1							; Converts a character # to an animated creature type
    233  09d1							; The array is indexed by CHARACTER_...
    234  09d1
    235  09d1		       00		      .byte.b	CHARACTER_BLANK	;  0
    236  09d2		       01		      .byte.b	CHARACTER_SOIL	;  1
    237  09d3		       02		      .byte.b	CHARACTER_BOX	;  2
    238  09d4		       03	   ANIM_TARGET .byte.b	CHARACTER_TARGET	;  3  XOR'd to give flashing target squares
    239  09d5		       04		      .byte.b	CHARACTER_TARGET2	;  4
    240  09d6		       05		      .byte.b	CHARACTER_MANOCCUPIED	;  5
    241  09d7		       06		      .byte.b	CHARACTER_STEEL	;  6
    242  09d8		       07		      .byte.b	CHARACTER_WALL	;  7
    243  09d9		       08		      .byte.b	CHARACTER_BOX_ON_TARGET	;  8	 box on target
    244  09da		       00		      .byte.b	CHARACTER_BLANK	;  9
    245  09db
    246  09db				  -	      IF	(* - CharReplacement != CHARACTER_MAXIMUM)
    247  09db				  -	      ECHO	"ERROR: Incorrect CharReplacement table!"
    248  09db				  -	      ERR
    249  09db					      ENDIF
      0  09db					      CHECKPAGEX	CharReplacement, "CharReplacement in BANK_ROM_SHADOW_DRAWBUFFERS"
      9  09db					      LIST	ON
    251  09db
    252  09db							;------------------------------------------------------------------------------
    253  09db
    254  09db
      0  09db					      OPTIONAL_PAGEBREAK	"ROW_BankChar", SCREEN_LINES * SCREEN_WIDTH
 PAGE BREAK INSERTED FOR  ROW_BankChar
 REQUESTED SIZE =  $50
 WASTED SPACE =  $25
 PAGEBREAK LOCATION =  $f200
     10  0a00					      LIST	ON
      0  0a00					      DEFINE_SUBROUTINE	ROW_BankChar
      1  0a00		       00 01	   BANK_ROW_BankChar =	_CURRENT_BANK
      2  0a00					      SUBROUTINE
      3  0a00				   ROW_BankChar
    257  0a00
    258  0a00				   .BANK      SET	BANK_SCREENMARKII1
    259  0a00					      REPEAT	SCREEN_LINES
    260  0a00					      REPEAT	SCREEN_WIDTH
    261  0a00		       00		      .byte.b	.BANK
    260  0a00					      REPEND
    261  0a01		       00		      .byte.b	.BANK
    260  0a01					      REPEND
    261  0a02		       00		      .byte.b	.BANK
    260  0a02					      REPEND
    261  0a03		       00		      .byte.b	.BANK
    260  0a03					      REPEND
    261  0a04		       00		      .byte.b	.BANK
    260  0a04					      REPEND
    261  0a05		       00		      .byte.b	.BANK
    260  0a05					      REPEND
    261  0a06		       00		      .byte.b	.BANK
    260  0a06					      REPEND
    261  0a07		       00		      .byte.b	.BANK
    260  0a07					      REPEND
    261  0a08		       00		      .byte.b	.BANK
    260  0a08					      REPEND
    261  0a09		       00		      .byte.b	.BANK
    262  0a0a					      REPEND
    263  0a0a				   .BANK      SET	.BANK + 1
    259  0a0a					      REPEND
    260  0a0a					      REPEAT	SCREEN_WIDTH
    261  0a0a		       01		      .byte.b	.BANK
    260  0a0a					      REPEND
    261  0a0b		       01		      .byte.b	.BANK
    260  0a0b					      REPEND
    261  0a0c		       01		      .byte.b	.BANK
    260  0a0c					      REPEND
    261  0a0d		       01		      .byte.b	.BANK
    260  0a0d					      REPEND
    261  0a0e		       01		      .byte.b	.BANK
    260  0a0e					      REPEND
    261  0a0f		       01		      .byte.b	.BANK
    260  0a0f					      REPEND
    261  0a10		       01		      .byte.b	.BANK
    260  0a10					      REPEND
    261  0a11		       01		      .byte.b	.BANK
    260  0a11					      REPEND
    261  0a12		       01		      .byte.b	.BANK
    260  0a12					      REPEND
    261  0a13		       01		      .byte.b	.BANK
    262  0a14					      REPEND
    263  0a14				   .BANK      SET	.BANK + 1
    259  0a14					      REPEND
    260  0a14					      REPEAT	SCREEN_WIDTH
    261  0a14		       02		      .byte.b	.BANK
    260  0a14					      REPEND
    261  0a15		       02		      .byte.b	.BANK
    260  0a15					      REPEND
    261  0a16		       02		      .byte.b	.BANK
    260  0a16					      REPEND
    261  0a17		       02		      .byte.b	.BANK
    260  0a17					      REPEND
    261  0a18		       02		      .byte.b	.BANK
    260  0a18					      REPEND
    261  0a19		       02		      .byte.b	.BANK
    260  0a19					      REPEND
    261  0a1a		       02		      .byte.b	.BANK
    260  0a1a					      REPEND
    261  0a1b		       02		      .byte.b	.BANK
    260  0a1b					      REPEND
    261  0a1c		       02		      .byte.b	.BANK
    260  0a1c					      REPEND
    261  0a1d		       02		      .byte.b	.BANK
    262  0a1e					      REPEND
    263  0a1e				   .BANK      SET	.BANK + 1
    259  0a1e					      REPEND
    260  0a1e					      REPEAT	SCREEN_WIDTH
    261  0a1e		       03		      .byte.b	.BANK
    260  0a1e					      REPEND
    261  0a1f		       03		      .byte.b	.BANK
    260  0a1f					      REPEND
    261  0a20		       03		      .byte.b	.BANK
    260  0a20					      REPEND
    261  0a21		       03		      .byte.b	.BANK
    260  0a21					      REPEND
    261  0a22		       03		      .byte.b	.BANK
    260  0a22					      REPEND
    261  0a23		       03		      .byte.b	.BANK
    260  0a23					      REPEND
    261  0a24		       03		      .byte.b	.BANK
    260  0a24					      REPEND
    261  0a25		       03		      .byte.b	.BANK
    260  0a25					      REPEND
    261  0a26		       03		      .byte.b	.BANK
    260  0a26					      REPEND
    261  0a27		       03		      .byte.b	.BANK
    262  0a28					      REPEND
    263  0a28				   .BANK      SET	.BANK + 1
    259  0a28					      REPEND
    260  0a28					      REPEAT	SCREEN_WIDTH
    261  0a28		       04		      .byte.b	.BANK
    260  0a28					      REPEND
    261  0a29		       04		      .byte.b	.BANK
    260  0a29					      REPEND
    261  0a2a		       04		      .byte.b	.BANK
    260  0a2a					      REPEND
    261  0a2b		       04		      .byte.b	.BANK
    260  0a2b					      REPEND
    261  0a2c		       04		      .byte.b	.BANK
    260  0a2c					      REPEND
    261  0a2d		       04		      .byte.b	.BANK
    260  0a2d					      REPEND
    261  0a2e		       04		      .byte.b	.BANK
    260  0a2e					      REPEND
    261  0a2f		       04		      .byte.b	.BANK
    260  0a2f					      REPEND
    261  0a30		       04		      .byte.b	.BANK
    260  0a30					      REPEND
    261  0a31		       04		      .byte.b	.BANK
    262  0a32					      REPEND
    263  0a32				   .BANK      SET	.BANK + 1
    259  0a32					      REPEND
    260  0a32					      REPEAT	SCREEN_WIDTH
    261  0a32		       05		      .byte.b	.BANK
    260  0a32					      REPEND
    261  0a33		       05		      .byte.b	.BANK
    260  0a33					      REPEND
    261  0a34		       05		      .byte.b	.BANK
    260  0a34					      REPEND
    261  0a35		       05		      .byte.b	.BANK
    260  0a35					      REPEND
    261  0a36		       05		      .byte.b	.BANK
    260  0a36					      REPEND
    261  0a37		       05		      .byte.b	.BANK
    260  0a37					      REPEND
    261  0a38		       05		      .byte.b	.BANK
    260  0a38					      REPEND
    261  0a39		       05		      .byte.b	.BANK
    260  0a39					      REPEND
    261  0a3a		       05		      .byte.b	.BANK
    260  0a3a					      REPEND
    261  0a3b		       05		      .byte.b	.BANK
    262  0a3c					      REPEND
    263  0a3c				   .BANK      SET	.BANK + 1
    259  0a3c					      REPEND
    260  0a3c					      REPEAT	SCREEN_WIDTH
    261  0a3c		       06		      .byte.b	.BANK
    260  0a3c					      REPEND
    261  0a3d		       06		      .byte.b	.BANK
    260  0a3d					      REPEND
    261  0a3e		       06		      .byte.b	.BANK
    260  0a3e					      REPEND
    261  0a3f		       06		      .byte.b	.BANK
    260  0a3f					      REPEND
    261  0a40		       06		      .byte.b	.BANK
    260  0a40					      REPEND
    261  0a41		       06		      .byte.b	.BANK
    260  0a41					      REPEND
    261  0a42		       06		      .byte.b	.BANK
    260  0a42					      REPEND
    261  0a43		       06		      .byte.b	.BANK
    260  0a43					      REPEND
    261  0a44		       06		      .byte.b	.BANK
    260  0a44					      REPEND
    261  0a45		       06		      .byte.b	.BANK
    262  0a46					      REPEND
    263  0a46				   .BANK      SET	.BANK + 1
    259  0a46					      REPEND
    260  0a46					      REPEAT	SCREEN_WIDTH
    261  0a46		       07		      .byte.b	.BANK
    260  0a46					      REPEND
    261  0a47		       07		      .byte.b	.BANK
    260  0a47					      REPEND
    261  0a48		       07		      .byte.b	.BANK
    260  0a48					      REPEND
    261  0a49		       07		      .byte.b	.BANK
    260  0a49					      REPEND
    261  0a4a		       07		      .byte.b	.BANK
    260  0a4a					      REPEND
    261  0a4b		       07		      .byte.b	.BANK
    260  0a4b					      REPEND
    261  0a4c		       07		      .byte.b	.BANK
    260  0a4c					      REPEND
    261  0a4d		       07		      .byte.b	.BANK
    260  0a4d					      REPEND
    261  0a4e		       07		      .byte.b	.BANK
    260  0a4e					      REPEND
    261  0a4f		       07		      .byte.b	.BANK
    262  0a50					      REPEND
    263  0a50				   .BANK      SET	.BANK + 1
    264  0a50					      REPEND
    265  0a50
    266  0a50
    267  0a50
    268  0a50
      0  0a50					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS"
      1  0a50
      2  0a50
      3  0a50		       02 50	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS (1K) SIZE =  $250 , FREE= $1b0
      4  0a50					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  0a50				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  0a50				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  0a50				  -	      ERR
      8  0a50					      endif
    270  0a50
    271  0a50
------- FILE LevelBank1.asm LEVEL 3 PASS 3
      0  0a50					      include	"LevelBank1.asm"
      1  0a50							; Level definitions
      2  0a50
      3  0a50							; "sokhard" collection
      4  0a50
      0  0a50					      START_LEVEL	_102_Natalie
      1  0a50				   LEVEL_START SET	*
      2  0a50		       00 01	   BANK_LEVEL__102_Natalie =	_CURRENT_BANK
      3  0a50				   LEVEL__102_Natalie SUBROUTINE
      4  0a50				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0a50
      6  0a50		       31 31 23 7c*	      .byte.b	"11#|2#2-#@4.#|2#3-2$.2*#|2#-$2-2$#.#|#2-$#-#2-.#|#2-$-#-2#-#|#9-#|11#",0
      0  0a96					      END_LEVEL	_102_Natalie
      1  0a96		       00		      .byte.b	0
      2  0a96		       00 47	   LEVEL_SIZE__102_Natalie =	* - LEVEL_START
      3  0a97					      IF	LEVEL_SIZE__102_Natalie > MAX_LEVEL_SIZE
      4  0a97				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Natalie
      5  0a97					      ENDIF
      8  0a97
      0  0a97					      START_LEVEL	_102_Mirabel
      1  0a97				   LEVEL_START SET	*
      2  0a97		       00 01	   BANK_LEVEL__102_Mirabel =	_CURRENT_BANK
      3  0a97				   LEVEL__102_Mirabel SUBROUTINE
      4  0a97				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0a97
     10  0a97		       31 31 23 7c*	      .byte.b	"11#|6#3-2#|2#2-2#$2-2#|2#2-#-2$-2#|#7-3#|#.-#$-#-3#|#.#.-#2-$-#|#3.#-2$#@#|#-2.4-$-#|#2-8#|11#",0
      0  0af6					      END_LEVEL	_102_Mirabel
      1  0af6		       00		      .byte.b	0
      2  0af6		       00 60	   LEVEL_SIZE__102_Mirabel =	* - LEVEL_START
      3  0af7					      IF	LEVEL_SIZE__102_Mirabel > MAX_LEVEL_SIZE
      4  0af7				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Mirabel
      5  0af7					      ENDIF
     12  0af7
      0  0af7					      START_LEVEL	_102_Oralia
      1  0af7				   LEVEL_START SET	*
      2  0af7		       00 01	   BANK_LEVEL__102_Oralia =	_CURRENT_BANK
      3  0af7				   LEVEL__102_Oralia SUBROUTINE
      4  0af7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0af7
     14  0af7		       39 23 7c 23*	      .byte.b	"9#|#2.$.#2-#|#4.2*-#|#-$.2#2-#|2#-$2-$-#|4#$-$-#|#-$3-$-#|#5-#@#|9#",0
      0  0b3b					      END_LEVEL	_102_Oralia
      1  0b3b		       00		      .byte.b	0
      2  0b3b		       00 45	   LEVEL_SIZE__102_Oralia =	* - LEVEL_START
      3  0b3c				  -	      IF	LEVEL_SIZE__102_Oralia > MAX_LEVEL_SIZE
      4  0b3c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Oralia
      5  0b3c					      ENDIF
     16  0b3c
     17  0b3c
     18  0b3c							;---------------------------------------------------------------------------------------------------
     19  0b3c							; IMAGE IS ABOVE DEFINITION
     20  0b3c
     21  0b3c							;  ###########
     22  0b3c							;  #  #      #
     23  0b3c							;  # $# $ $$ #
     24  0b3c							;  #  ##$#$  #
     25  0b3c							;  #  $    #@#
     26  0b3c							;  # $## #  ##
     27  0b3c							;  ##	# .## #
     28  0b3c							;  ##$ #.*. ##
     29  0b3c							;  # ..*. *. #
     30  0b3c							;  # # .. #  #
     31  0b3c							;  ###########
     32  0b3c
      0  0b3c					      START_LEVEL	_102_Raven
      1  0b3c				   LEVEL_START SET	*
      2  0b3c		       00 01	   BANK_LEVEL__102_Raven =	_CURRENT_BANK
      3  0b3c				   LEVEL__102_Raven SUBROUTINE
      4  0b3c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0b3c
     34  0b3c		       31 31 23 7c*	      .byte.b	"11#|#2-#6-#|#-$#-$-2$-#|#2-2#$#$2-#|#2-$4-#@#|#-$2#-#2-2#|2#2-#-.2#-#|2#$-#.*.-2#|#-2.*.-*.-#|#-#-2.-#2-#|11#",0
      0  0baa					      END_LEVEL	_102_Raven
      1  0baa		       00		      .byte.b	0
      2  0baa		       00 6f	   LEVEL_SIZE__102_Raven =	* - LEVEL_START
      3  0bab					      IF	LEVEL_SIZE__102_Raven > MAX_LEVEL_SIZE
      4  0bab				   MAX_LEVEL_SIZE SET	LEVEL_SIZE__102_Raven
      5  0bab					      ENDIF
     36  0bab
     37  0bab							;  ############
     38  0bab							;  #@##. #  # #
     39  0bab							;  #**..$#    #
     40  0bab							;  #. $..#  # #
     41  0bab							;  # $#.$#$$$ #
     42  0bab							;  #	      ##
     43  0bab							;  #  ##  #   #
     44  0bab							;  ############
     45  0bab
      0  0bab					      START_LEVEL	_103_Adin
      1  0bab				   LEVEL_START SET	*
      2  0bab		       00 01	   BANK_LEVEL__103_Adin =	_CURRENT_BANK
      3  0bab				   LEVEL__103_Adin SUBROUTINE
      4  0bab				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0bab
     47  0bab		       31 32 23 7c*	      .byte.b	"12#|#@2#.-#2-#-#|#2*2.$#4-#|#.-$2.#2-#-#|#-$#.$#3$-#|#9-2#|#2-2#2-#3-#|12#",0
      0  0bf6					      END_LEVEL	_103_Adin
      1  0bf6		       00		      .byte.b	0
      2  0bf6		       00 4c	   LEVEL_SIZE__103_Adin =	* - LEVEL_START
      3  0bf7				  -	      IF	LEVEL_SIZE__103_Adin > MAX_LEVEL_SIZE
      4  0bf7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Adin
      5  0bf7					      ENDIF
     49  0bf7
     50  0bf7							;  #######___
     51  0bf7							;  #	  #___
     52  0bf7							;  #	$$#___
     53  0bf7							;  #.*  .#___
     54  0bf7							;  #$*$#*###_
     55  0bf7							;  #@*... .#_
     56  0bf7							;  #####$ .##
     57  0bf7							;  ___# $ $ #
     58  0bf7							;  ___#     #
     59  0bf7							;  ___#######	(_ = modified by boo from wall)
     60  0bf7
      0  0bf7					      START_LEVEL	_103_Ajalae
      1  0bf7				   LEVEL_START SET	*
      2  0bf7		       00 01	   BANK_LEVEL__103_Ajalae =	_CURRENT_BANK
      3  0bf7				   LEVEL__103_Ajalae SUBROUTINE
      4  0bf7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0bf7
     62  0bf7		       37 23 7c 23*	      .byte.b	"7#|#5-#|#3-2$#|#.*2-.#|#$*$#*3#|#@*3.-.#|5#$-.2#|3-#-$-$-#|3-#5-#|3-7#",0
      0  0c3e					      END_LEVEL	_103_Ajalae
      1  0c3e		       00		      .byte.b	0
      2  0c3e		       00 48	   LEVEL_SIZE__103_Ajalae =	* - LEVEL_START
      3  0c3f				  -	      IF	LEVEL_SIZE__103_Ajalae > MAX_LEVEL_SIZE
      4  0c3f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Ajalae
      5  0c3f					      ENDIF
     64  0c3f
     65  0c3f							;  ############
     66  0c3f							;  #@#  #     #
     67  0c3f							;  #  # #$#$# #
     68  0c3f							;  # *$       #
     69  0c3f							;  #..##$#$   #
     70  0c3f							;  #..#. #  $ #
     71  0c3f							;  #....# $$$##
     72  0c3f							;  #	       #
     73  0c3f							;  ############
     74  0c3f
      0  0c3f					      START_LEVEL	_103_Arielle
      1  0c3f				   LEVEL_START SET	*
      2  0c3f		       00 01	   BANK_LEVEL__103_Arielle =	_CURRENT_BANK
      3  0c3f				   LEVEL__103_Arielle SUBROUTINE
      4  0c3f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0c3f
     76  0c3f		       31 32 23 7c*	      .byte.b	"12#|#@#2-#5-#|#2-#-#$#$#-#|#-*$7-#|#2.2#$#$3-#|#2.#.-#2-$-#|#4.#-3$2#|#10-#|12#",0
      0  0c8f					      END_LEVEL	_103_Arielle
      1  0c8f		       00		      .byte.b	0
      2  0c8f		       00 51	   LEVEL_SIZE__103_Arielle =	* - LEVEL_START
      3  0c90				  -	      IF	LEVEL_SIZE__103_Arielle > MAX_LEVEL_SIZE
      4  0c90				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__103_Arielle
      5  0c90					      ENDIF
     78  0c90
     79  0c90
     80  0c90							; earlier levels
      0  0c90					      START_LEVEL	_057_L
      1  0c90				   LEVEL_START SET	*
      2  0c90		       00 01	   BANK_LEVEL__057_L =	_CURRENT_BANK
      3  0c90				   LEVEL__057_L SUBROUTINE
      4  0c90				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0c90
     82  0c90		       35 2d 36 23*	      .byte.b	"5-6#|4#-#-.2-#|#2-#-#-2.-#|#2-3#2*.-#|#-$-#-*-$2#|#-$-@*.2-#-|#-2$-2#2-#-|#4-5#-|6#5-",0
      0  0ce6					      END_LEVEL	_057_L
      1  0ce6		       00		      .byte.b	0
      2  0ce6		       00 57	   LEVEL_SIZE__057_L =	* - LEVEL_START
      3  0ce7				  -	      IF	LEVEL_SIZE__057_L > MAX_LEVEL_SIZE
      4  0ce7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__057_L
      5  0ce7					      ENDIF
     84  0ce7
      0  0ce7					      START_LEVEL	_1XJH_Tara_Gelson
      1  0ce7				   LEVEL_START SET	*
      2  0ce7		       00 01	   BANK_LEVEL__1XJH_Tara_Gelson =	_CURRENT_BANK
      3  0ce7				   LEVEL__1XJH_Tara_Gelson SUBROUTINE
      4  0ce7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0ce7
     86  0ce7		       38 23 7c 23*	      .byte.b	"8#|#2-#2-*#|#2-*-*-#|#-*$-$-#|#2-.#.-#|#3-#-*#|2#-@3-#|8#",0
      0  0d21					      END_LEVEL	_1XJH_Tara_Gelson
      1  0d21		       00		      .byte.b	0
      2  0d21		       00 3b	   LEVEL_SIZE__1XJH_Tara_Gelson =	* - LEVEL_START
      3  0d22				  -	      IF	LEVEL_SIZE__1XJH_Tara_Gelson > MAX_LEVEL_SIZE
      4  0d22				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1XJH_Tara_Gelson
      5  0d22					      ENDIF
     88  0d22
      0  0d22					      START_LEVEL	_1R7X_Alison
      1  0d22				   LEVEL_START SET	*
      2  0d22		       00 01	   BANK_LEVEL__1R7X_Alison =	_CURRENT_BANK
      3  0d22				   LEVEL__1R7X_Alison SUBROUTINE
      4  0d22				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0d22
     90  0d22		       37 23 7c 23*	      .byte.b	"7#|#2-.2-#|#-$*2$#|#-2.$.#|#@*-$-#|2#.3-#|7#",0
      0  0d4f					      END_LEVEL	_1R7X_Alison
      1  0d4f		       00		      .byte.b	0
      2  0d4f		       00 2e	   LEVEL_SIZE__1R7X_Alison =	* - LEVEL_START
      3  0d50				  -	      IF	LEVEL_SIZE__1R7X_Alison > MAX_LEVEL_SIZE
      4  0d50				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1R7X_Alison
      5  0d50					      ENDIF
     92  0d50
      0  0d50					      START_LEVEL	_1KWD_Cecile_Clayworth
      1  0d50				   LEVEL_START SET	*
      2  0d50		       00 01	   BANK_LEVEL__1KWD_Cecile_Clayworth =	_CURRENT_BANK
      3  0d50				   LEVEL__1KWD_Cecile_Clayworth SUBROUTINE
      4  0d50				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0d50
     94  0d50		       38 23 7c 33*	      .byte.b	"8#|3#.2-.#|#-$4-#|#-*2#2$#|#3-$-+#|#-*.-*-#|#6-#|8#",0
      0  0d84					      END_LEVEL	_1KWD_Cecile_Clayworth
      1  0d84		       00		      .byte.b	0
      2  0d84		       00 35	   LEVEL_SIZE__1KWD_Cecile_Clayworth =	* - LEVEL_START
      3  0d85				  -	      IF	LEVEL_SIZE__1KWD_Cecile_Clayworth > MAX_LEVEL_SIZE
      4  0d85				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1KWD_Cecile_Clayworth
      5  0d85					      ENDIF
     96  0d85
      0  0d85					      START_LEVEL	_1EKT_Samantha_Gelson
      1  0d85				   LEVEL_START SET	*
      2  0d85		       00 01	   BANK_LEVEL__1EKT_Samantha_Gelson =	_CURRENT_BANK
      3  0d85				   LEVEL__1EKT_Samantha_Gelson SUBROUTINE
      4  0d85				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0d85
     98  0d85		       38 23 7c 23*	      .byte.b	"8#|#-*3-.#|#2-$-*-#|#-.$-$-#|#*-*2-*#|#.#-#2-#|#4-@-#|8#",0
      0  0dbe					      END_LEVEL	_1EKT_Samantha_Gelson
      1  0dbe		       00		      .byte.b	0
      2  0dbe		       00 3a	   LEVEL_SIZE__1EKT_Samantha_Gelson =	* - LEVEL_START
      3  0dbf				  -	      IF	LEVEL_SIZE__1EKT_Samantha_Gelson > MAX_LEVEL_SIZE
      4  0dbf				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__1EKT_Samantha_Gelson
      5  0dbf					      ENDIF
    100  0dbf
    101  0dbf							; "sokwhole" collection
    102  0dbf
    103  0dbf							;  ######
    104  0dbf							;  #..$ #
    105  0dbf							;####.*  ##
    106  0dbf							;#  $$*   ###
    107  0dbf							;#   .+#$$$ #
    108  0dbf							;#####.*    #
    109  0dbf							;   ####   #
    110  0dbf							;	#####
    111  0dbf
      0  0dbf					      START_LEVEL	_060_R
      1  0dbf				   LEVEL_START SET	*
      2  0dbf		       00 01	   BANK_LEVEL__060_R =	_CURRENT_BANK
      3  0dbf				   LEVEL__060_R SUBROUTINE
      4  0dbf				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0dbf
    113  0dbf		       33 2d 36 23*	      .byte.b	"3-6#3-|3-#2.$-#3-|4#.*2-2#2-|#2-2$*3-3#|#3-.+#3$-#|5#.*4-#|4-4#3-#|7-5#",0
      0  0e07					      END_LEVEL	_060_R
      1  0e07		       00		      .byte.b	0
      2  0e07		       00 49	   LEVEL_SIZE__060_R =	* - LEVEL_START
      3  0e08				  -	      IF	LEVEL_SIZE__060_R > MAX_LEVEL_SIZE
      4  0e08				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__060_R
      5  0e08					      ENDIF
    115  0e08
    116  0e08							;  ##########
    117  0e08							;  #  #  @  #
    118  0e08							;  #  # $ #*##
    119  0e08							;  # $ #** ..#
    120  0e08							;  #	 $.*.$#
    121  0e08							;  #### ..$  #
    122  0e08							;     ### $  #
    123  0e08							;	 ##   #
    124  0e08							;	  #####
    125  0e08
      0  0e08					      START_LEVEL	_061_L
      1  0e08				   LEVEL_START SET	*
      2  0e08		       00 01	   BANK_LEVEL__061_L =	_CURRENT_BANK
      3  0e08				   LEVEL__061_L SUBROUTINE
      4  0e08				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0e08
    127  0e08		       31 30 23 2d*	      .byte.b	"10#-|#2-#2-@2-#-|#2-#-$-#*2#|#-$-#2*-2.#|#4-$.*.$#|4#-2.$2-#|3-3#-$2-#|5-2#3-#|6-5#",0
      0  0e5c					      END_LEVEL	_061_L
      1  0e5c		       00		      .byte.b	0
      2  0e5c		       00 55	   LEVEL_SIZE__061_L =	* - LEVEL_START
      3  0e5d				  -	      IF	LEVEL_SIZE__061_L > MAX_LEVEL_SIZE
      4  0e5d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_L
      5  0e5d					      ENDIF
    129  0e5d
    130  0e5d							;  #####
    131  0e5d							; ##.	#
    132  0e5d							;####.*# ####
    133  0e5d							;#   ...  $@##
    134  0e5d							;#  $ $.$$$$ #
    135  0e5d							;######.#    #
    136  0e5d							;   #####  #
    137  0e5d							;	 ####
    138  0e5d
      0  0e5d					      START_LEVEL	_061_R
      1  0e5d				   LEVEL_START SET	*
      2  0e5d		       00 01	   BANK_LEVEL__061_R =	_CURRENT_BANK
      3  0e5d				   LEVEL__061_R SUBROUTINE
      4  0e5d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0e5d
    140  0e5d		       34 2d 35 23*	      .byte.b	"4-5#4-|3-2#.2-#4-|4#.*#-4#-|#3-3.2-$@2#|#2-$-$.4$-#|6#.#4-#|5-5#2-#|9-4#",0
      0  0ea6					      END_LEVEL	_061_R
      1  0ea6		       00		      .byte.b	0
      2  0ea6		       00 4a	   LEVEL_SIZE__061_R =	* - LEVEL_START
      3  0ea7				  -	      IF	LEVEL_SIZE__061_R > MAX_LEVEL_SIZE
      4  0ea7				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__061_R
      5  0ea7					      ENDIF
    142  0ea7
    143  0ea7							;  #####
    144  0ea7							;  #	#####
    145  0ea7							;  #$$ #   #
    146  0ea7							; ## #  $  ##
    147  0ea7							; #	 *#  #
    148  0ea7							; #   # .#..##
    149  0ea7							; #####$***. #
    150  0ea7							;     #@$ .  #
    151  0ea7							;     ########
    152  0ea7
      0  0ea7					      START_LEVEL	_062_L
      1  0ea7				   LEVEL_START SET	*
      2  0ea7		       00 01	   BANK_LEVEL__062_L =	_CURRENT_BANK
      3  0ea7				   LEVEL__062_L SUBROUTINE
      4  0ea7				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0ea7
    154  0ea7		       2d 35 23 36*	      .byte.b	"-5#6-|-#3-5#2-|-#2$-#3-#2-|2#-#2-$2-2#-|#5-*#2-#-|#3-#-.#2.2#|5#$3*.-#|4-#@$-.2-#|4-8#",0
      0  0efe					      END_LEVEL	_062_L
      1  0efe		       00		      .byte.b	0
      2  0efe		       00 58	   LEVEL_SIZE__062_L =	* - LEVEL_START
      3  0eff				  -	      IF	LEVEL_SIZE__062_L > MAX_LEVEL_SIZE
      4  0eff				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_L
      5  0eff					      ENDIF
    156  0eff
    157  0eff
    158  0eff							;  #####
    159  0eff							;###@..#
    160  0eff							;###	*##
    161  0eff							;#  $$*.#
    162  0eff							;##  $...#
    163  0eff							;# $  $ ##
    164  0eff							;#  $####
    165  0eff							;#   #
    166  0eff							;#####
    167  0eff
      0  0eff					      START_LEVEL	_062_R
      1  0eff				   LEVEL_START SET	*
      2  0eff		       00 01	   BANK_LEVEL__062_R =	_CURRENT_BANK
      3  0eff				   LEVEL__062_R SUBROUTINE
      4  0eff				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0eff
    169  0eff		       35 2d 35 23*	      .byte.b	"5-5#|3-3#@2.#|-3#3-*2#|-#2-2$*.#-|2#2-$3.#-|#-$2-$-2#-|#2-$4#2-|#3-#5-|5#5-",0
      0  0f4b					      END_LEVEL	_062_R
      1  0f4b		       00		      .byte.b	0
      2  0f4b		       00 4d	   LEVEL_SIZE__062_R =	* - LEVEL_START
      3  0f4c				  -	      IF	LEVEL_SIZE__062_R > MAX_LEVEL_SIZE
      4  0f4c				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__062_R
      5  0f4c					      ENDIF
    171  0f4c
    172  0f4c							;  #####
    173  0f4c							;  #	#######
    174  0f4c							;  #  $@##   #
    175  0f4c							;####$#*.# # #
    176  0f4c							;#  $.#.*  # #
    177  0f4c							;#   .*.$$$  #
    178  0f4c							;###.*       #
    179  0f4c							;  ###########
    180  0f4c
      0  0f4c					      START_LEVEL	_063_L
      1  0f4c				   LEVEL_START SET	*
      2  0f4c		       00 01	   BANK_LEVEL__063_L =	_CURRENT_BANK
      3  0f4c				   LEVEL__063_L SUBROUTINE
      4  0f4c				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0f4c
    182  0f4c		       32 2d 35 23*	      .byte.b	"2-5#6-|2-#3-7#|2-#2-$@2#3-#|4#$#*.#-#-#|#2-$.#.*2-#-#|#3-.*.3$2-#|3#.*7-#|2-11#",0
      0  0f9c					      END_LEVEL	_063_L
      1  0f9c		       00		      .byte.b	0
      2  0f9c		       00 51	   LEVEL_SIZE__063_L =	* - LEVEL_START
      3  0f9d				  -	      IF	LEVEL_SIZE__063_L > MAX_LEVEL_SIZE
      4  0f9d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_L
      5  0f9d					      ENDIF
    184  0f9d
    185  0f9d							;  ######
    186  0f9d							;  # +. #
    187  0f9d							;  #$*$ ####
    188  0f9d							; ##...#   #
    189  0f9d							;## $.*.   #
    190  0f9d							;# $ #$## ##
    191  0f9d							;# $$	   #
    192  0f9d							;#	 ###
    193  0f9d							;########
    194  0f9d
      0  0f9d					      START_LEVEL	_063_R
      1  0f9d				   LEVEL_START SET	*
      2  0f9d		       00 01	   BANK_LEVEL__063_R =	_CURRENT_BANK
      3  0f9d				   LEVEL__063_R SUBROUTINE
      4  0f9d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  0f9d
    196  0f9d		       32 2d 36 23*	      .byte.b	"2-6#3-|2-#-+.-#3-|2-#$*$-4#|-2#3.#3-#|2#-$.*.3-#|#-$-#$2#-2#|#-2$5-#-|#6-3#-|8#3-",0
      0  0fef					      END_LEVEL	_063_R
      1  0fef		       00		      .byte.b	0
      2  0fef		       00 53	   LEVEL_SIZE__063_R =	* - LEVEL_START
      3  0ff0				  -	      IF	LEVEL_SIZE__063_R > MAX_LEVEL_SIZE
      4  0ff0				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__063_R
      5  0ff0					      ENDIF
    198  0ff0
    199  0ff0
    200  0ff0							;------------------------------------------------------------------------------
------- FILE BANK_ROM_SHADOW_DRAWBUFFERS.asm
    273  0ff0
      0  0ff0					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K"
      1  0ff0		       07 f0	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K (2K) SIZE =  $7f0 , FREE= $10
      2  0ff0					      ECHO	"ROM_SHADOW_OF_BANK_DRAW_BUFFERS -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  0ff0				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  0ff0				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  0ff0				  -	      ERR
      6  0ff0					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_ROM_SHADOW_SCORING.asm LEVEL 2 PASS 3
      0  0ff0					      include	"BANK_ROM_SHADOW_SCORING.asm"
      1  0ff0							;------------------------------------------------------------------------------
      2  0ff0							;##############################################################################
      3  0ff0							;------------------------------------------------------------------------------
      0  0ff0					      NEWBANK	ROM_SHADOW_OF_BANK_SCORING
      1  17d1 ????				      SEG	ROM_SHADOW_OF_BANK_SCORING
      2  1000					      ORG	ORIGIN
      3  1000					      RORG	$F000
      4  1000				   BANK_START SET	*
      5  1000				   ROM_SHADOW_OF_BANK_SCORING SET	ORIGIN / 2048
      6  1000				   ORIGIN     SET	ORIGIN + 2048
      7  1000				   _CURRENT_BANK SET	ROM_SHADOW_OF_BANK_SCORING
      5  1000
      6  1000
      7  1000		       00 9a	   SCORE_COL  =	$9a	;WHITE ;-2
      8  1000		       00 44	   SCORE_COL_HIGH_NTSC =	$44	; works for SECAM and NTSC
      9  1000		       00 66	   SCORE_COL_HIGH_PAL =	$66
     10  1000
     11  1000
     12  1000				   DigitVectorLOr
     13  1000		       50 5e 6c 57*	      .byte.b	<ZeroR-1, <OneR-1, <TwoR-1, <ThreeR-1, <FourR-1, <FiveR-1, <SixR-1, <SevenR-1, <EightR-1, <NineR-1
     14  100a		       1f 26 2d 34	      .byte.b	<BLANKR-1, <DequalsR-1, <DplusR-1, <ClockR-1
     15  100e				   DigitVectorLO
     16  100e		       53 61 6e 5a*	      .byte.b	<ZeroL-1, <OneL-1, <TwoL-1, <ThreeL-1, <FourL-1, <FiveL-1, <SixL-1, <SevenL-1, <EightL-1, <NineL-1
     17  1018		       37		      .byte.b	<BLANKL-1
     18  1019
     19  1019
     20  1019		       00 0a	   ID_BLANK   =	10	; DO NOT MAKE 0
     21  1019		       00 0b	   ID_TARGET  =	11
     22  1019		       00 0c	   ID_EXTRA   =	12
     23  1019		       00 0d	   ID_CLOCK   =	13
     24  1019		       00 1b	   ID_HEAD    =	ID_BLANK+16+1
     25  1019
     26  1019							; score patch adresses:
     27  1019				   SMTblLSB
     28  1019				   SMTblTargets
     29  1019		       52 48		      .byte.b	SM_TARGET0+1-SM_BASE, SM_TARGET2+1-SM_BASE
     30  101b				   SMTblTime
     31  101b		       6e 60		      .byte.b	SM_Time0+1-SM_BASE, SM_Time2+1-SM_BASE
     32  101d				   SMTblScore
     33  101d		       1c 20 12 	      .byte.b	SMDIGIT5+1-SM_BASE, SMDIGIT3+1-SM_BASE, SMDIGIT1+1-SM_BASE
     34  1020				   SMTblMSB
     35  1020		       4d 43		      .byte.b	SM_TARGET1+1-SM_BASE, SM_TARGET3+1-SM_BASE
     36  1022		       65 59		      .byte.b	SM_Time1+1-SM_BASE, SM_Time3+1-SM_BASE
     37  1024		       23 17 07 	      .byte.b	SMDIGIT4+1-SM_BASE, SMDIGIT2+1-SM_BASE, SMDIGIT0+1-SM_BASE
     38  1027
     39  1027		       00 00	   SM_OFS_TARGETS =	SMTblTargets - SMTblLSB
     40  1027		       00 02	   SM_OFS_TIME =	SMTblTime - SMTblLSB
     41  1027		       00 04	   SM_OFS_SCORE =	SMTblScore - SMTblLSB
     42  1027
     43  1027				   CharVectorLO
     44  1027		       37		      .byte.b	<BLANKL-1
     45  1028		       83 83 83 83	      .byte.b	<CharA-1, <CharB-1, <CharC-1, <CharD-1
     46  102c		       83 83 83 83	      .byte.b	<CharE-1, <CharF-1, <CharG-1, <CharH-1
     47  1030		       83 83 83 83	      .byte.b	<CharI-1, <CharJ-1, <CharK-1, <CharL-1
     48  1034		       83 83 83 83	      .byte.b	<CharM-1, <CharN-1, <CharO-1, <CharP-1
     49  1038							;    .byte   <OneL-1,	<TwoL-1,  <ThreeL-1,<FourL-1
     50  1038
     51  1038							; Digit shape definitions are at start of bank so that we don't have page boundary
     52  1038							; crossing issues.
     53  1038
     54  1038							;	  .byte 0	      ; required!
     55  1038
     56  1038		       00 07	   DIGIT_H    =	7	; height of a score digit
     57  1038
     58  1038		       00 00 00 00*BLANKL     ds	7,0
     59  103f
     60  103f
     61  103f
     62  103f				   NineL
     63  103f		       1e		      .byte.b	%00011110
     64  1040		       02		      .byte.b	%00000010
     65  1041		       02		      .byte.b	%00000010
     66  1042		       fe		      .byte.b	%11111110
     67  1043		       82		      .byte.b	%10000010
     68  1044		       82		      .byte.b	%10000010
     69  1045		       fe		      .byte.b	%11111110
     70  1046
     71  1046				   SixL
     72  1046		       fe		      .byte.b	%11111110
     73  1047		       82		      .byte.b	%10000010
     74  1048		       82		      .byte.b	%10000010
     75  1049		       fe		      .byte.b	%11111110
     76  104a		       80		      .byte.b	%10000000
     77  104b		       80		      .byte.b	%10000000
     78  104c		       f0		      .byte.b	%11110000
     79  104d
     80  104d							;    .byte %01111100
     81  104d							;    .byte %11000010
     82  104d							;    .byte %11000010
     83  104d							;    .byte %11111100
     84  104d							;    .byte %11000000
     85  104d							;    .byte %01100000
     86  104d							;    .byte %00111000
     87  104d				   EightL
     88  104d
     89  104d
     90  104d		       fe		      .byte.b	%11111110
     91  104e		       82		      .byte.b	%10000010
     92  104f		       82		      .byte.b	%10000010
     93  1050		       fe		      .byte.b	%11111110
     94  1051		       82		      .byte.b	%10000010
     95  1052		       82		      .byte.b	%10000010
     96  1053		       fe		      .byte.b	%11111110
     97  1054
     98  1054							;  .byte %01111100
     99  1054							;  .byte %10000110
    100  1054							;  .byte %10000110
    101  1054							;  .byte %01111100
    102  1054							;  .byte %01000110
    103  1054							;  .byte %01000110
    104  1054							;  .byte %00111100
    105  1054				   ZeroL
    106  1054							;  .byte %01111100
    107  1054							;  .byte %10000110
    108  1054							;  .byte %10000110
    109  1054							;  .byte %10000110
    110  1054							;  .byte %10000110
    111  1054							;  .byte %01000110
    112  1054							;  .byte %00111100
    113  1054
    114  1054		       fe		      .byte.b	%11111110
    115  1055		       82		      .byte.b	%10000010
    116  1056		       82		      .byte.b	%10000010
    117  1057		       82		      .byte.b	%10000010
    118  1058		       82		      .byte.b	%10000010
    119  1059		       82		      .byte.b	%10000010
    120  105a		       fe		      .byte.b	%11111110
    121  105b
    122  105b				   ThreeL
    123  105b		       fe		      .byte.b	%11111110
    124  105c		       02		      .byte.b	%00000010
    125  105d		       02		      .byte.b	%00000010
    126  105e		       1e		      .byte.b	%00011110
    127  105f		       02		      .byte.b	%00000010
    128  1060		       02		      .byte.b	%00000010
    129  1061		       fe		      .byte.b	%11111110
    130  1062				   OneL
    131  1062		       10		      .byte.b	%00010000
    132  1063		       10		      .byte.b	%00010000
    133  1064		       10		      .byte.b	%00010000
    134  1065		       10		      .byte.b	%00010000
    135  1066		       10		      .byte.b	%00010000
    136  1067		       10		      .byte.b	%00010000
    137  1068		       10		      .byte.b	%00010000
    138  1069
    139  1069				   SevenL
    140  1069
    141  1069		       10		      .byte.b	%00010000
    142  106a		       10		      .byte.b	%00010000
    143  106b		       10		      .byte.b	%00010000
    144  106c		       1e		      .byte.b	%00011110
    145  106d		       02		      .byte.b	%00000010
    146  106e		       02		      .byte.b	%00000010
    147  106f							;  .byte %11111110
    148  106f
    149  106f							;    .byte %00010000
    150  106f							;    .byte %00010000
    151  106f							;    .byte %00010000
    152  106f							;    .byte %00011000
    153  106f							;    .byte %00001100
    154  106f							;    .byte %10000110
    155  106f							;    ;.byte %11111110
    156  106f				   TwoL
    157  106f		       fe		      .byte.b	%11111110
    158  1070		       80		      .byte.b	%10000000
    159  1071		       80		      .byte.b	%10000000
    160  1072		       fe		      .byte.b	%11111110
    161  1073		       02		      .byte.b	%00000010
    162  1074		       02		      .byte.b	%00000010
    163  1075		       fe		      .byte.b	%11111110
    164  1076
    165  1076				   FiveL
    166  1076		       fe		      .byte.b	%11111110
    167  1077		       02		      .byte.b	%00000010
    168  1078		       02		      .byte.b	%00000010
    169  1079		       fe		      .byte.b	%11111110
    170  107a		       80		      .byte.b	%10000000
    171  107b		       80		      .byte.b	%10000000
    172  107c		       f0		      .byte.b	%11110000
    173  107d
    174  107d				   FourL
    175  107d		       10		      .byte.b	%00010000
    176  107e		       10		      .byte.b	%00010000
    177  107f		       10		      .byte.b	%00010000
    178  1080		       fe		      .byte.b	%11111110
    179  1081		       90		      .byte.b	%10010000
    180  1082		       90		      .byte.b	%10010000
    181  1083		       90		      .byte.b	%10010000
    182  1084
    183  1084							; level "name" characters (left only!):
    184  1084
    185  1084				   CharN
    186  1084				   CharK
    187  1084				   CharH
    188  1084				   CharA
    189  1084				   CharJ
    190  1084				   CharP
    191  1084				   CharB
    192  1084				   CharO
    193  1084				   CharC
    194  1084				   CharI
    195  1084				   CharD
    196  1084				   CharG
    197  1084				   CharE
    198  1084				   CharL
    199  1084				   CharF
    200  1084				   CharM
    201  1084		       00 00 00 00*	      ds	7,0
    202  108b
    203  108b				   charPlace
    204  108b		       0c		      .byte.b	%00001100
    205  108c		       0c		      .byte.b	%00001100
    206  108d		       0c		      .byte.b	%00001100
    207  108e		       0c		      .byte.b	%00001100
    208  108f		       0c		      .byte.b	%00001100
    209  1090		       00		      .byte.b	%00000000
    210  1091		       0c		      .byte.b	%00001100
    211  1092
    212  1092							;-------------------------------------------------------------------------------------
    213  1092				   PosTbl
    214  1092		       40		      .byte.b	$40
    215  1093		       31 22 13 04*	      .byte.b	$31, $22, $13, $04, $f5, $e6, $d7, $c8
    216  109b		       b9		      .byte.b	$b9
    217  109c
    218  109c
    219  109c							;------------------------------------------------------------------------------
    220  109c							; RAM-BASED SUBROUTINES...
    221  109c							; NOTE: When calling these routines, remember you are actually calling the ROM routine
    222  109c							; as it is the ROM bank that is switched in.  The first thing to do to access the RAM
    223  109c							; is to switch the appropriate RAM bank in.  It would be nicer to be able to direct-call
    224  109c							; the RAM-based routine.
    225  109c
    226  1100		       00 00 00 00*	      ALIGN	256	; so SM code needs no HI table
    227  1100
    228  1100		       f1 00	   SM_BASE    =	.
    229  1100
    230  1100							;#IF 0 ;{
    231  1100							;    DEFINE_SUBROUTINE Score3x3
    232  1100							;
    233  1100							;	  sta	  RESP0
    234  1100							;	   sta	   RESP1
    235  1100							;	   lda	   #$$000
    236  1100							;	    sta     GRP0
    237  1100							;	    lda     #$$009
    238  1100							;	    sta     GRP1
    239  1100							;	    lda     #$$202
    240  1100							;	    sta     ENABL
    241  1100							;	    nop
    242  1100							;	    nop
    243  1100							;	    nop
    244  1100							;	    lda     #$$016
    245  1100							;	    ldy     #$$100
    246  1100							;	    ldx     #$$109
    247  1100							;	    sta     GRP0    ; Critical time is right here
    248  1100							;	    stx     GRP1
    249  1100							;	    sty     GRP0
    250  1100							;	    sta     RESP0
    251  1100							;	    sta     RESP1
    252  1100							;	    ldx     #$$116
    253  1100							;	    lda     #$$209
    254  1100							;	    stx     GRP0
    255  1100							;	    sta     GRP1
    256  1100							;	    lda     #$$200
    257  1100							;	    sta     GRP0
    258  1100							;	    sta     RESP0
    259  1100							;	    sta     RESP1
    260  1100							;	    lda     #$$216
    261  1100							;	    nop
    262  1100							;	    sta     GRP0
    263  1100							;
    264  1100							;	      rts
    265  1100							;#ENDIF ;}
    266  1100
    267  1100
    268  1100							;------------------------------------------------------------------------------
    269  1100				   Score1x6Fix SUBROUTINE
      0  1100					      DEFINE_SUBROUTINE	DrawDigits1x6
      1  1100		       00 02	   BANK_DrawDigits1x6 =	_CURRENT_BANK
      2  1100					      SUBROUTINE
      3  1100				   DrawDigits1x6
    271  1100							;					     @07
    272  1100		       ba		      tsx		; 2
    273  1101
    274  1101		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 58    @65
    275  1104
    276  1104		       86 d8		      stx	tmpStack	; 3 =	3
    277  1106
    278  1106				   LoopDraw1x6		;
    279  1106				   SMDIGIT0
    280  1106		       b9 50 f3 	      lda	ZeroR-1,y	; 4
    281  1109		       85 42		      sta	WSYNC	; 3
    282  110b							;---------------------------------------------------------------
    283  110b		       85 6a		      sta	HMOVE	; 3
      0  110d					      SLEEP	3	; 3 =	6
      1  110d				   .CYCLES    SET	3
      2  110d
      3  110d				  -	      IF	.CYCLES < 2
      4  110d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  110d				  -	      ERR
      6  110d					      ENDIF
      7  110d
      8  110d					      IF	.CYCLES & 1
      9  110d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  110d		       04 00		      nop	0
     11  110f				  -	      ELSE
     12  110f				  -	      bit	VSYNC
     13  110f					      ENDIF
     14  110f				   .CYCLES    SET	.CYCLES - 3
     15  110f					      ENDIF
     16  110f
     17  110f				  -	      REPEAT	.CYCLES / 2
     18  110f				  -	      nop
     19  110f					      REPEND
    285  110f		       85 5b		      sta	GRP0	; 3
    286  1111				   SMDIGIT1
    287  1111		       b9 53 f0 	      lda	ZeroL-1,y	; 4
    288  1114		       85 5c		      sta	GRP1	; 3
    289  1116				   SMDIGIT2
    290  1116		       b9 50 f3 	      lda	ZeroR-1,y	; 4
    291  1119		       85 5b		      sta	GRP0	; 3 = 17
    292  111b				   SMDIGIT5
    293  111b		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    294  111e		       9a		      txs		; 2
    295  111f				   SMDIGIT3
    296  111f		       be 53 f0 	      ldx	ZeroL-1,y	; 4
    297  1122				   SMDIGIT4
    298  1122		       b9 50 f3 	      lda	ZeroR-1,y	; 4
    299  1125		       85 6b		      sta	HMCLR	; 3
    300  1127		       86 5c		      stx	GRP1	; 3
    301  1129		       85 5b		      sta	GRP0	; 3 = 23
    302  112b
    303  112b		       ba		      tsx		; 2
    304  112c		       86 5c		      stx	GRP1	; 3
    305  112e		       85 5b		      sta	GRP0	; 3 =	8
    306  1130
    307  1130		       88		      dey		; 2
      0  1131					      CHECKPAGE_BNE	LoopDraw1x6	;2/3= 5    @58/59
      8  1131					      LIST	ON
      9  1131		       d0 d3		      bne	LoopDraw1x6
    309  1133
    310  1133		       a6 d8		      ldx	tmpStack	; 3
    311  1135		       9a		      txs		; 2
    312  1136				   ExitDigitKernel6
      0  1136					      SLEEP	3	; 3
      1  1136				   .CYCLES    SET	3
      2  1136
      3  1136				  -	      IF	.CYCLES < 2
      4  1136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1136				  -	      ERR
      6  1136					      ENDIF
      7  1136
      8  1136					      IF	.CYCLES & 1
      9  1136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1136		       04 00		      nop	0
     11  1138				  -	      ELSE
     12  1138				  -	      bit	VSYNC
     13  1138					      ENDIF
     14  1138				   .CYCLES    SET	.CYCLES - 3
     15  1138					      ENDIF
     16  1138
     17  1138				  -	      REPEAT	.CYCLES / 2
     18  1138				  -	      nop
     19  1138					      REPEND
    314  1138		       4c 77 f1 	      jmp	ExitDigitKernel	; 3 = 11    @69
    315  113b
    316  113b
    317  113b							;------------------------------------------------------------------------------
    318  113b				   Score2x4Fix SUBROUTINE
      0  113b					      DEFINE_SUBROUTINE	DrawDigits2x4
      1  113b		       00 02	   BANK_DrawDigits2x4 =	_CURRENT_BANK
      2  113b					      SUBROUTINE
      3  113b				   DrawDigits2x4
    320  113b
    321  113b
    322  113b							; Subroutine by Thomas Jentzsch.  Magic!
    323  113b							; This subroutine draws two 4-digit scores on the screen, side-by-side. Amazing!
    324  113b
    325  113b							;sta COLUBK
    326  113b
    327  113b		       20 ee f1 	      jsr	PrepareDrawDigits	;56 = 56    @63
    328  113e
    329  113e		       85 6a		      sta	HMOVE	; 3
      0  1140					      SLEEP	4	; 4  =  7
      1  1140				   .CYCLES    SET	4
      2  1140
      3  1140				  -	      IF	.CYCLES < 2
      4  1140				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1140				  -	      ERR
      6  1140					      ENDIF
      7  1140
      8  1140				  -	      IF	.CYCLES & 1
      9  1140				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1140				  -	      nop	0
     11  1140				  -	      ELSE
     12  1140				  -	      bit	VSYNC
     13  1140				  -	      ENDIF
     14  1140				  -.CYCLES    SET	.CYCLES - 3
     15  1140					      ENDIF
     16  1140
     17  1140					      REPEAT	.CYCLES / 2
     18  1140		       ea		      nop
     17  1140					      REPEND
     18  1141		       ea		      nop
     19  1142					      REPEND
    331  1142
    332  1142				   LoopDraw2x4		;	     @70
    333  1142				   SM_TARGET3
    334  1142		       b9 26 f3 	      lda	DequalsR-1,y	; 4		     G
    335  1145							;---------------------------------------------------------------
    336  1145		       85 5b		      sta	GRP0	; 3
    337  1147				   SM_TARGET2
    338  1147		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     A
    339  114a		       85 5c		      sta	GRP1	; 3
    340  114c				   SM_TARGET1
    341  114c		       b9 50 f3 	      lda	ZeroR-1,y	; 4		     M
    342  114f		       85 5b		      sta	GRP0	; 3
    343  1151				   SM_TARGET0
    344  1151		       be 53 f0 	      ldx	ZeroL-1,y	; 4		     E
    345  1154		       85 50		      sta	RESP0	; 3 = 28    @22
    346  1156		       85 51		      sta	RESP1	; 3 =	3    @25
    347  1158				   SM_Time3
    348  1158		       b9 34 f3 	      lda	ClockR-1,y	; 4		     O
    349  115b		       86 5c		      stx	GRP1	; 3
    350  115d		       85 5b		      sta	GRP0	; 3
    351  115f				   SM_Time2
    352  115f		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     V
    353  1162		       85 5c		      sta	GRP1	; 3
    354  1164				   SM_Time1
    355  1164		       b9 50 f3 	      lda	ZeroR-1,y	; 4		     E
    356  1167		       85 5b		      sta	GRP0	; 3
    357  1169		       85 50		      sta	RESP0	; 3 = 27    @52 (was 54)
    358  116b		       85 51		      sta	RESP1	; 3 =	3    @55
    359  116d				   SM_Time0
    360  116d		       b9 53 f0 	      lda	ZeroL-1,y	; 4		     R
    361  1170		       85 5c		      sta	GRP1	; 3
    362  1172		       85 5b		      sta	GRP0	; 3
    363  1174		       88		      dey		; 2
      0  1175					      CHECKPAGE_BNE	LoopDraw2x4	;2/3=15    @70
      8  1175					      LIST	ON
      9  1175		       d0 cb		      bne	LoopDraw2x4
    365  1177
    366  1177				   ExitDigitKernel		;	     @69
    367  1177		       84 5b		      sty	GRP0	; 3
    368  1179		       84 5c		      sty	GRP1	; 3
    369  117b							;---------------------------------------------------------------
    370  117b		       84 5b		      sty	GRP0	; 3	     @02
    371  117d
    372  117d							; Contribution by Thomas Jentzsch
    373  117d							; Rewrite/Optimised for single sprite AD
    374  117d
    375  117d		       a6 9d		      ldx	ManDrawX	; 3
    376  117f		       bd 92 f0 	      lda	PosTbl,x	; 4
    377  1182		       85 60		      sta	HMP0	; 3
    378  1184		       29 0f		      and	#$0f	; 2
    379  1186		       f0 04		      beq	.zeroPos	; 2/3=15
    380  1188		       aa		      tax		; 2
    381  1189				   .loopWait
    382  1189		       ca		      dex		; 2
    383  118a		       d0 fd		      bne	.loopWait	; 2/3= 6
    384  118c				   .zeroPos
    385  118c		       a2 70		      ldx	#$70	; 2	     magic value #1 for Cosmic Ark stars
    386  118e		       85 50		      sta	RESP0	; 3 =	5    @22..67 (@look around!)
    387  1190		       a5 b2		      lda	BGColour	; 3
    388  1192		       86 62		      stx	HMM0	; 3	     for extra life stars!
    389  1194		       85 42		      sta	WSYNC	; 3
    390  1196							;---------------------------------------------------------------
    391  1196		       85 6a		      sta	HMOVE	; 3
    392  1198		       60		      rts		; 6	     @09
    393  1199
    394  1199							;------------------------------------------------------------------------------
    395  1199				   Score3x2Fix SUBROUTINE
      0  1199					      DEFINE_SUBROUTINE	DrawDigits3x2
      1  1199		       00 02	   BANK_DrawDigits3x2 =	_CURRENT_BANK
      2  1199					      SUBROUTINE
      3  1199				   DrawDigits3x2
    397  1199							;					     @07
    398  1199		       a9 16		      lda	#%010110	; 2
    399  119b		       a0 ef		      ldy	#$f0-1	; 2		     moved slightly out of center to match 1x6 display position
    400  119d		       20 f4 f1 	      jsr	PrepareDrawDigits2	;49 = 53    @60
    401  11a0
    402  11a0		       a9 00		      lda	#0
    403  11a2		       85 66		      sta	VDELP1
    404  11a4				   LoopDraw3x2		;
    405  11a4		       85 42		      sta	WSYNC	; 3
    406  11a6							;---------------------------------------------------------------
    407  11a6		       85 6a		      sta	HMOVE	; 3 =	3
    408  11a8		       b9 83 f0 	      lda	CharP-1,y	; 4
    409  11ab		       85 5b		      sta	GRP0	; 3
    410  11ad				   SMPLAYER
    411  11ad		       b9 5e f3 	      lda	OneR-1,y	; 4
    412  11b0		       85 5c		      sta	GRP1	; 3 = 14    @17
    413  11b2		       b9 8a f0 	      lda	charPlace-1,y	; 4
    414  11b5				   SMMEN
    415  11b5		       be 57 f3 	      ldx	ThreeR-1,y	; 4 =	8
      0  11b8					      SLEEP	5	;   =	5
      1  11b8				   .CYCLES    SET	5
      2  11b8
      3  11b8				  -	      IF	.CYCLES < 2
      4  11b8				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11b8				  -	      ERR
      6  11b8					      ENDIF
      7  11b8
      8  11b8					      IF	.CYCLES & 1
      9  11b8					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11b8		       04 00		      nop	0
     11  11ba				  -	      ELSE
     12  11ba				  -	      bit	VSYNC
     13  11ba					      ENDIF
     14  11ba				   .CYCLES    SET	.CYCLES - 3
     15  11ba					      ENDIF
     16  11ba
     17  11ba					      REPEAT	.CYCLES / 2
     18  11ba		       ea		      nop
     19  11bb					      REPEND
    417  11bb		       85 5b		      sta	GRP0	; 3
    418  11bd				   SMLEVELX
    419  11bd		       b9 83 f0 	      lda	CharA-1,y	; 4
    420  11c0		       85 6b		      sta	HMCLR	; 3 = 10    @40
    421  11c2		       86 5c		      stx	GRP1	; 3 =	3    @43
    422  11c4		       85 5b		      sta	GRP0	; 3
    423  11c6				   SMLEVEL
    424  11c6		       b9 5e f3 	      lda	OneR-1,y	; 4
    425  11c9		       85 5c		      sta	GRP1	; 3 = 10    @53
    426  11cb
    427  11cb		       88		      dey		; 2
      0  11cc					      CHECKPAGE_BNE	LoopDraw3x2	;2/3= 5    @58
      8  11cc					      LIST	ON
      9  11cc		       d0 d6		      bne	LoopDraw3x2
    429  11ce							;					     @57
      0  11ce					      SLEEP	3	; 3
      1  11ce				   .CYCLES    SET	3
      2  11ce
      3  11ce				  -	      IF	.CYCLES < 2
      4  11ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  11ce				  -	      ERR
      6  11ce					      ENDIF
      7  11ce
      8  11ce					      IF	.CYCLES & 1
      9  11ce					      IFNCONST	NO_ILLEGAL_OPCODES
     10  11ce		       04 00		      nop	0
     11  11d0				  -	      ELSE
     12  11d0				  -	      bit	VSYNC
     13  11d0					      ENDIF
     14  11d0				   .CYCLES    SET	.CYCLES - 3
     15  11d0					      ENDIF
     16  11d0
     17  11d0				  -	      REPEAT	.CYCLES / 2
     18  11d0				  -	      nop
     19  11d0					      REPEND
    431  11d0		       4c 36 f1 	      jmp	ExitDigitKernel6	; 9 = 12    @69  'BEQ' WAS A DANGEROUS ASSUMPTION OF STATUS FLAG!!
    432  11d3
    433  11d3
    434  11d3							;------------------------------------------------------------------------------
      0  11d3					      DEFINE_SUBROUTINE	DrawDigits
      1  11d3		       00 02	   BANK_DrawDigits =	_CURRENT_BANK
      2  11d3					      SUBROUTINE
      3  11d3				   DrawDigits
    436  11d3
    437  11d3				   VblankLoopGame
    438  11d3		       ac 84 02 	      ldy	INTIM
    439  11d6		       d0 fb		      bne	VblankLoopGame
    440  11d8
    441  11d8		       84 41		      sty	VBLANK	; 3	     <-- 0
    442  11da		       a5 c7		      lda	scoringFlags	; 3
    443  11dc		       29 03		      and	#DISPLAY_FLAGS	; 2
    444  11de		       aa		      tax		; 2
    445  11df
    446  11df							;    DEFINE_SUBROUTINE DrawDigit2
    447  11df							;
    448  11df							;    ; Generic interface to scoring routine
    449  11df
    450  11df		       bd ea f1 	      lda	ScoreKernelLo,x	; 4
    451  11e2
    452  11e2		       85 42		      sta	WSYNC	; 3
    453  11e4							;---------------------------------------------------------------
    454  11e4		       8d e8 f5 	      sta	SMJUMP+1+RAM_WRITE	; 4
    455  11e7				   SMJUMP
    456  11e7		       4c 00 f1 	      jmp	DrawDigits1x6	; 3 =	7    @07
    457  11ea
    458  11ea				   ScoreKernelLo
    459  11ea		       3b		      .byte.b	<Score2x4Fix	; TARGETs, time
    460  11eb		       00		      .byte.b	<Score1x6Fix	; score
    461  11ec		       99		      .byte.b	<Score3x2Fix	; player, lives, level
    462  11ed		       00		      .byte.b	<Score1x6Fix	; high score
    463  11ee
      0  11ee					      CHECKPAGE	DrawDigits1x6	; AD: the jump requires all in the same page, so let's enforce that
      8  11ee					      LIST	ON
    465  11ee
    466  11ee							;------------------------------------------------------------------------------
      0  11ee					      DEFINE_SUBROUTINE	PrepareDrawDigits
      1  11ee		       00 02	   BANK_PrepareDrawDigits =	_CURRENT_BANK
      2  11ee					      SUBROUTINE
      3  11ee				   PrepareDrawDigits
    468  11ee							;					     @13
    469  11ee		       a0 d1		      ldy	#$d1	; 2
    470  11f0		       a9 13		      lda	#%010011	; 2
    471  11f2		       85 66		      sta	VDELP1	; 3 =	7
    472  11f4				   PrepareDrawDigits2		;	    @17/20
    473  11f4		       84 65		      sty	VDELP0	; 3 =	3
    474  11f6
    475  11f6		       85 45		      sta	NUSIZ1	; 3
    476  11f8		       85 44		      sta	NUSIZ0	; 3 =	6
    477  11fa
    478  11fa		       8d 4b 00 	      sta.w	REFP0	; 4		     bit 3 is always clear
    479  11fd		       85 50		      sta	RESP0	; 3	     @33/36
    480  11ff		       85 51		      sta	RESP1	; 3 = 10    @36/39
    481  1201
    482  1201		       84 60		      sty	HMP0	; 3
    483  1203		       c8		      iny		; 2
    484  1204		       84 61		      sty	HMP1	; 3 =	8
    485  1206				   SMCOLOR
    486  1206		       a0 9a		      ldy	#SCORE_COL	; 2
    487  1208		       84 46		      sty	COLUP0	; 3
    488  120a		       84 47		      sty	COLUP1	; 3 =	8
    489  120c
    490  120c		       a0 07		      ldy	#DIGIT_H	; 2
    491  120e		       60		      rts		; 6 =	8
    492  120f							; total: 27
    493  120f
    494  120f
    495  120f							;------------------------------------------------------------------------------
      0  120f					      DEFINE_SUBROUTINE	UpdateScore
      1  120f		       00 02	   BANK_UpdateScore =	_CURRENT_BANK
      2  120f					      SUBROUTINE
      3  120f				   UpdateScore
    497  120f							; a = added score value
    498  120f
    499  120f							; initially switch to score:
    500  120f		       a0 01		      ldy	#DISPLAY_SCORE
    501  1211		       84 d8		      sty	newDisplay
    502  1213
    503  1213		       18		      clc
    504  1214		       f8		      sed
    505  1215		       a0 04		      ldy	#SM_OFS_SCORE
    506  1217				   .loopScore
    507  1217		       79 a9 f3 	      adc	ScoreCurrent-SM_OFS_SCORE,y
    508  121a		       99 a9 f7 	      sta	ScoreCurrent-SM_OFS_SCORE+RAM_WRITE,y
    509  121d		       08		      php
    510  121e							; *** bonus life every 500 points: ***
    511  121e							;	  cpy #SM_OFS_SCORE+1
    512  121e							;	  bne .skipBonusLife
    513  121e							;	  tax
    514  121e
    515  121e							;	  and #$0f
    516  121e							;	  beq .bonusLife		      ; 000?
    517  121e							;	  cmp #$05
    518  121e							;	  bne .noBonusLife		      ; 500?
    519  121e							;.bonusLife:
    520  121e							; add extra life, limited to 9
    521  121e
    522  121e							;	  lda ManCount
    523  121e							;	  and #$0f
    524  121e							;	  cmp #9
    525  121e							;	  bcs .noBonusLife
    526  121e							;	  inc ManCount
    527  121e
    528  121e							; bonus life has priority over score:
    529  121e							;	  lda #DISPLAY_LIVES
    530  121e							;	  sta newDisplay
    531  121e							;lda #EXTRA_LIFE_TIMER
    532  121e							;sta extraLifeTimer
    533  121e
    534  121e				   .noBonusLife
    535  121e		       8a		      txa
    536  121f				   .skipBonusLife
    537  121f		       20 00 f3 	      jsr	SetupBCDPtr
    538  1222		       28		      plp
    539  1223		       a9 00		      lda	#0
    540  1225		       b0 f0		      bcs	.loopScore
    541  1227		       d8		      cld
    542  1228
    543  1228							; switch display
    544  1228		       a5 c7		      lda	scoringFlags
    545  122a		       29 03		      and	#DISPLAY_FLAGS
    546  122c		       c5 d8		      cmp	newDisplay	; lower priority than current?
    547  122e		       f0 08		      beq	.restartTime
    548  1230		       b0 0a		      bcs	.skipNew
    549  1232		       45 c7		      eor	scoringFlags	; remove existing score mode
    550  1234		       05 d8		      ora	newDisplay	; switch to new score mode
    551  1236		       85 c7		      sta	scoringFlags
    552  1238				   .restartTime
    553  1238		       a9 3c		      lda	#SCORING_TIMER	; maybe always restart timer?
    554  123a		       85 c6		      sta	scoringTimer
    555  123c				   .skipNew
    556  123c
    557  123c		       60		      rts
    558  123d
    559  123d							;---------------------------------------------------------------------------
    560  123d
      0  123d					      DEFINE_SUBROUTINE	SwapPlayers
      1  123d		       00 02	   BANK_SwapPlayers =	_CURRENT_BANK
      2  123d					      SUBROUTINE
      3  123d				   SwapPlayers
    562  123d
    563  123d							; assume no new high score:
    564  123d		       a0 ff		      ldy	#-1
    565  123f		       84 db		      sty	highScoreSK
    566  1241
    567  1241							; update highscore after last live:
    568  1241		       a5 a7		      lda	ManCount
    569  1243		       29 0f		      and	#$0f	; player has lives left?
    570  1245		       d0 1c		      bne	.playerAlive	; YES, so we don't check high score
    571  1247
    572  1247							; check for a new high score:
    573  1247							;	  ldy #-1
    574  1247		       18		      clc		; score has to be at least 1 bigger!
    575  1248				   .loopCheckHighScore
    576  1248		       c8		      iny
    577  1249		       b9 ad f3 	      lda	ScoreCurrent,y
    578  124c		       f9 b7 f3 	      sbc	HighScore,y
    579  124f		       98		      tya
    580  1250		       49 02		      eor	#2
    581  1252		       d0 f4		      bne	.loopCheckHighScore
    582  1254		       90 0d		      bcc	.noHighScore
    583  1256
    584  1256							; new high score, update:
    585  1256		       a2 04		      ldx	#5-1
    586  1258				   .loopSetHighScore
    587  1258		       bd ad f3 	      lda	ScoreCurrent,x
    588  125b		       9d b7 f7 	      sta	HighScore+RAM_WRITE,x
    589  125e		       95 db		      sta	highScoreSK,x
    590  1260		       ca		      dex
    591  1261		       10 f5		      bpl	.loopSetHighScore
    592  1263				   .noHighScore
    593  1263
    594  1263				   .playerAlive
    595  1263		       a5 a7		      lda	ManCount
    596  1265		       29 f0		      and	#$f0	; other player has lives left?
    597  1267		       f0 21		      beq	.otherPlayerDead	; NO, so we don't swap scores
    598  1269
    599  1269							; save the current player variables to the player's backup:
    600  1269		       a0 02		      ldy	#3-1
    601  126b				   .swapScore
    602  126b		       be b2 f3 	      ldx	PlayerScores,y
    603  126e		       b9 ad f3 	      lda	ScoreCurrent,y
    604  1271		       99 b2 f7 	      sta	PlayerScores+RAM_WRITE,y
    605  1274		       8a		      txa
    606  1275		       99 ad f7 	      sta	ScoreCurrent+RAM_WRITE,y
    607  1278		       88		      dey
    608  1279		       10 f0		      bpl	.swapScore
    609  127b
    610  127b							; swap levelx and level:
    611  127b		       a2 01		      ldx	#1
    612  127d				   .loopLevelXLevel
    613  127d		       bc b5 f3 	      ldy	PlayerLevelX,x
    614  1280		       b5 b3		      lda	levelX,x
    615  1282		       9d b5 f7 	      sta	PlayerLevelX+RAM_WRITE,x
    616  1285		       94 b3		      sty	levelX,x
    617  1287		       ca		      dex
    618  1288		       10 f3		      bpl	.loopLevelXLevel
    619  128a
    620  128a				   .otherPlayerDead
    621  128a		       60		      rts
    622  128b
    623  128b							;---------------------------------------------------------------------------
    624  128b
    625  128b				   HighScoreColTbl
    626  128b		       44 44		      .byte.b	SCORE_COL_HIGH_NTSC, SCORE_COL_HIGH_NTSC
    627  128d		       66 66		      .byte.b	SCORE_COL_HIGH_PAL, SCORE_COL_HIGH_PAL
    628  128f
      0  128f					      DEFINE_SUBROUTINE	GeneralScoringSetups
      1  128f		       00 02	   BANK_GeneralScoringSetups =	_CURRENT_BANK
      2  128f					      SUBROUTINE
      3  128f				   GeneralScoringSetups
    630  128f
    631  128f		       a0 04		      ldy	#SM_OFS_SCORE
    632  1291				   .loopScore2
    633  1291		       a5 c7		      lda	scoringFlags
    634  1293		       29 03		      and	#DISPLAY_FLAGS
    635  1295		       c9 03		      cmp	#DISPLAY_HIGH
    636  1297		       a6 81		      ldx	Platform
    637  1299		       bd 8b f2 	      lda	HighScoreColTbl,x
    638  129c		       aa		      tax
    639  129d		       b9 b3 f3 	      lda	HighScore-SM_OFS_SCORE,y
    640  12a0		       b0 05		      bcs	.showHighScore
    641  12a2		       a2 9a		      ldx	#SCORE_COL
    642  12a4		       b9 a9 f3 	      lda	ScoreCurrent-SM_OFS_SCORE,y
    643  12a7				   .showHighScore
    644  12a7		       8e 07 f6 	      stx	SMCOLOR+1+RAM_WRITE
    645  12aa		       20 00 f3 	      jsr	SetupBCDPtr
    646  12ad		       c0 07		      cpy	#SM_OFS_SCORE+3
    647  12af		       90 e0		      bcc	.loopScore2
    648  12b1
    649  12b1							; display number of lives in leftmost digit of middle score XX nX XX
    650  12b1
    651  12b1		       a5 a7		      lda	ManCount
    652  12b3		       29 0f		      and	#$0f
    653  12b5		       a8		      tay
    654  12b6		       b9 00 f0 	      lda	DigitVectorLOr,y
    655  12b9		       8d b6 f5 	      sta	SMMEN+1+RAM_WRITE
    656  12bc
    657  12bc							; modify player number pointer (Xp XX XX)
    658  12bc
    659  12bc		       a4 99		      ldy	whichPlayer
    660  12be		       b9 01 f0 	      lda	DigitVectorLOr+1,y
    661  12c1		       8d ae f5 	      sta	SMPLAYER+1+RAM_WRITE
    662  12c4
    663  12c4							; fall through
    664  12c4
    665  12c4							;    ;---------------------------------------------------------------------------
    666  12c4
    667  12c4							; modify levelx character pointer (XX XX cX)
    668  12c4
    669  12c4		       a2 8a		      ldx	#<charPlace-1
    670  12c6		       a5 b5		      lda	levelDisplay
    671  12c8		       c9 80		      cmp	#$80
    672  12ca		       29 1f		      and	#$1f
    673  12cc		       a8		      tay
    674  12cd		       b0 05		      bcs	.intermission
    675  12cf		       be 27 f0 	      ldx	CharVectorLO,y
    676  12d2		       a4 b4		      ldy	level
    677  12d4				   .intermission
    678  12d4		       8e be f5 	      stx	SMLEVELX+1+RAM_WRITE
    679  12d7
    680  12d7							; modify level number pointer (XX XX Xl)
    681  12d7
    682  12d7		       b9 01 f0 	      lda	DigitVectorLOr+1,y
    683  12da		       8d c7 f5 	      sta	SMLEVEL+1+RAM_WRITE
    684  12dd
    685  12dd							;---------------------------------------------------------------------------
    686  12dd
    687  12dd		       4c f7 f2 	      jmp	SetupTimePtr	; modify time pointers
    688  12e0
    689  12e0							;------------------------------------------------------------------------------
    690  12e0							;    DEFINE_SUBROUTINE SetupGameOverPtr
    691  12e0
    692  12e0							;		  ldy #8-1
    693  12e0							;.loopGameOver:
    694  12e0							;		  ldx SMGameOverOfs,y
    695  12e0							;		  lda SMGameOverPtr,y
    696  12e0							;		  sta SM_BASE+1+RAM_WRITE,x
    697  12e0							;		  dey
    698  12e0							;		  bpl .loopGameOver
    699  12e0
    700  12e0							;		  rts
    701  12e0
    702  12e0							;SMGameOverOfs:
    703  12e0							;		  .byte <SM_TARGET3-SM_BASE, <SM_TARGET2-SM_BASE
    704  12e0							;		  .byte <SM_TARGET1-SM_BASE, <SM_TARGET0-SM_BASE
    705  12e0							;		  .byte <SM_Time3-SM_BASE, <SM_Time2-SM_BASE
    706  12e0							;		  .byte <SM_Time1-SM_BASE, <SM_Time0-SM_BASE
    707  12e0							;SMGameOverPtr:
    708  12e0							;		  .byte <CharG-1, <CharAL-1, <CharM-1, <CharEL-1
    709  12e0							;		  .byte <CharO-1, <CharVL-1, <CharE-1, <CharRL-1
    710  12e0
    711  12e0							;------------------------------------------------------------------------------
    712  12e0
      0  12e0					      DEFINE_SUBROUTINE	DrawTargetsRequired
      1  12e0		       00 02	   BANK_DrawTargetsRequired =	_CURRENT_BANK
      2  12e0					      SUBROUTINE
      3  12e0				   DrawTargetsRequired
    714  12e0							; Show current TARGET counter in the top left
    715  12e0
    716  12e0		       a0 00		      ldy	#SM_OFS_TARGETS
    717  12e2		       a5 b8		      lda	targetsRequired
    718  12e4		       20 00 f3 	      jsr	SetupBCDPtr
    719  12e7
    720  12e7		       a9 b0		      lda	#ID_TARGET<<4	; if no extra targets, display the normal icon
    721  12e9		       24 c7		      bit	scoringFlags	;
    722  12eb		       10 13		      bpl	SetupBCDPtr
    723  12ed		       a9 c0		      lda	#ID_EXTRA<<4	; otherwise, display the extra icon
    724  12ef		       50 0f		      bvc	SetupBCDPtr
    725  12f1		       09 01		      ora	#1	; display 1xx targets
    726  12f3		       d0 0b		      bne	SetupBCDPtr	; unconditional
    727  12f5
    728  12f5							;------------------------------------------------------------------------------
      0  12f5					      DEFINE_SUBROUTINE	DrawTime
      1  12f5		       00 02	   BANK_DrawTime =	_CURRENT_BANK
      2  12f5					      SUBROUTINE
      3  12f5				   DrawTime
    730  12f5
    731  12f5							; mid-digit-change, but we may be required to flash/display
    732  12f5		       a0 02		      ldy	#SM_OFS_TIME
    733  12f7							;------------------------------------------------------------------------------
      0  12f7					      DEFINE_SUBROUTINE	SetupTimePtr
      1  12f7		       00 02	   BANK_SetupTimePtr =	_CURRENT_BANK
      2  12f7					      SUBROUTINE
      3  12f7				   SetupTimePtr
    735  12f7
    736  12f7		       a5 b9		      lda	moveCounter
    737  12f9		       20 00 f3 	      jsr	SetupBCDPtr
    738  12fc		       a5 ba		      lda	moveCounter+1
    739  12fe		       09 d0		      ora	#ID_CLOCK<<4
    740  1300
    741  1300							; fall through
    742  1300
    743  1300							;------------------------------------------------------------------------------
      0  1300					      DEFINE_SUBROUTINE	SetupBCDPtr
      1  1300		       00 02	   BANK_SetupBCDPtr =	_CURRENT_BANK
      2  1300					      SUBROUTINE
      3  1300				   SetupBCDPtr
    745  1300
    746  1300							; a = BCD value
    747  1300							; y = SM table offset
    748  1300
    749  1300		       48		      pha
    750  1301		       29 0f		      and	#$0f
    751  1303		       aa		      tax
    752  1304		       bd 0e f0 	      lda	DigitVectorLO,x	; low nibble: left aligned chars
    753  1307		       be 19 f0 	      ldx	SMTblLSB,y
    754  130a		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    755  130d		       68		      pla
    756  130e		       4a		      lsr
    757  130f		       4a		      lsr
    758  1310		       4a		      lsr
    759  1311		       4a		      lsr
    760  1312		       aa		      tax
    761  1313		       bd 00 f0 	      lda	DigitVectorLOr,x	; high nibble: right aligned chars
    762  1316		       be 20 f0 	      ldx	SMTblMSB,y
    763  1319		       9d 00 f5 	      sta	SM_BASE+RAM_WRITE,x
    764  131c
    765  131c		       c8		      iny
    766  131d
    767  131d		       a5 c2		      lda	ROM_Bank
    768  131f				   RTS
    769  131f		       60		      rts
    770  1320
      0  1320					      OPTIONAL_PAGEBREAK	"LeftDigits", (DIGIT_H*13)	; cannot index across page!
     10  1320					      LIST	ON
    772  1320
    773  1320				  -	      IF	<. = 0
    774  1320				  -	      .byte	0	; required!
    775  1320					      ENDIF
    776  1320
    777  1320				   BLANKR
    778  1320		       00 00 00 00*	      .ds	DIGIT_H, 0
    779  1327
    780  1327				   DequalsR
    781  1327		       00		      .byte.b	%00000000
    782  1328		       00		      .byte.b	%00000000
    783  1329		       f0		      .byte.b	%11110000
    784  132a		       00		      .byte.b	%00000000
    785  132b		       f0		      .byte.b	%11110000
    786  132c		       00		      .byte.b	%00000000
    787  132d		       f0		      .byte.b	%11110000
    788  132e				   DplusR
    789  132e		       10		      .byte.b	%00010000
    790  132f		       28		      .byte.b	%00101000
    791  1330		       6c		      .byte.b	%01101100
    792  1331		       c6		      .byte.b	%11000110
    793  1332		       6c		      .byte.b	%01101100
    794  1333		       28		      .byte.b	%00101000
    795  1334		       10		      .byte.b	%00010000
    796  1335
    797  1335				   ClockR
    798  1335		       00		      .byte.b	%00000000
    799  1336		       48		      .byte.b	%01001000
    800  1337		       fc		      .byte.b	%11111100
    801  1338		       48		      .byte.b	%01001000
    802  1339		       48		      .byte.b	%01001000
    803  133a		       fc		      .byte.b	%11111100
    804  133b		       48		      .byte.b	%01001000
    805  133c				   NineR
    806  133c		       0f		      .byte.b	%00001111
    807  133d		       01		      .byte.b	%00000001
    808  133e		       01		      .byte.b	%00000001
    809  133f		       7f		      .byte.b	%01111111
    810  1340		       41		      .byte.b	%01000001
    811  1341		       41		      .byte.b	%01000001
    812  1342		       7f		      .byte.b	%01111111
    813  1343				   SixR
    814  1343		       7f		      .byte.b	%01111111
    815  1344		       41		      .byte.b	%01000001
    816  1345		       41		      .byte.b	%01000001
    817  1346		       7f		      .byte.b	%01111111
    818  1347		       40		      .byte.b	%01000000
    819  1348		       40		      .byte.b	%01000000
    820  1349		       78		      .byte.b	%01111000
    821  134a				   EightR
    822  134a							;  .byte %00111110
    823  134a							;  .byte %01000011
    824  134a							;  .byte %01000011
    825  134a							;  .byte %00111110
    826  134a							;  .byte %00100011
    827  134a							;  .byte %00100011
    828  134a							;  .byte %00011110
    829  134a
    830  134a
    831  134a		       7f		      .byte.b	%01111111
    832  134b		       41		      .byte.b	%01000001
    833  134c		       41		      .byte.b	%01000001
    834  134d		       7f		      .byte.b	%01111111
    835  134e		       41		      .byte.b	%01000001
    836  134f		       41		      .byte.b	%01000001
    837  1350		       7f		      .byte.b	%01111111
    838  1351
    839  1351				   ZeroR
    840  1351		       7f		      .byte.b	%01111111
    841  1352		       41		      .byte.b	%01000001
    842  1353		       41		      .byte.b	%01000001
    843  1354		       41		      .byte.b	%01000001
    844  1355		       41		      .byte.b	%01000001
    845  1356		       41		      .byte.b	%01000001
    846  1357		       7f		      .byte.b	%01111111
    847  1358
    848  1358							;	  .byte %00111110
    849  1358							;	  .byte %01000011
    850  1358							;	  .byte %01000011
    851  1358							;	  .byte %01000011
    852  1358							;	  .byte %01000011
    853  1358							;	  .byte %00100011
    854  1358							;	  .byte %00011110
    855  1358				   ThreeR
    856  1358		       7f		      .byte.b	%01111111
    857  1359		       01		      .byte.b	%00000001
    858  135a		       01		      .byte.b	%00000001
    859  135b		       0f		      .byte.b	%00001111
    860  135c		       01		      .byte.b	%00000001
    861  135d		       01		      .byte.b	%00000001
    862  135e		       7f		      .byte.b	%01111111
    863  135f				   OneR
    864  135f		       08		      .byte.b	%00001000
    865  1360		       08		      .byte.b	%00001000
    866  1361		       08		      .byte.b	%00001000
    867  1362		       08		      .byte.b	%00001000
    868  1363		       08		      .byte.b	%00001000
    869  1364		       08		      .byte.b	%00001000
    870  1365		       08		      .byte.b	%00001000
    871  1366
    872  1366				   SevenR
    873  1366		       08		      .byte.b	%00001000
    874  1367		       08		      .byte.b	%00001000
    875  1368		       08		      .byte.b	%00001000
    876  1369		       0f		      .byte.b	%00001111
    877  136a		       01		      .byte.b	%00000001
    878  136b		       01		      .byte.b	%00000001
    879  136c		       7f		      .byte.b	%01111111
    880  136d
    881  136d				   TwoR
    882  136d		       7f		      .byte.b	%01111111
    883  136e		       40		      .byte.b	%01000000
    884  136f		       40		      .byte.b	%01000000
    885  1370		       7f		      .byte.b	%01111111
    886  1371		       01		      .byte.b	%00000001
    887  1372		       01		      .byte.b	%00000001
    888  1373		       7f		      .byte.b	%01111111
    889  1374				   FiveR
    890  1374		       7f		      .byte.b	%01111111
    891  1375		       01		      .byte.b	%00000001
    892  1376		       01		      .byte.b	%00000001
    893  1377		       7f		      .byte.b	%01111111
    894  1378		       40		      .byte.b	%01000000
    895  1379		       40		      .byte.b	%01000000
    896  137a		       78		      .byte.b	%01111000
    897  137b				   FourR
    898  137b		       08		      .byte.b	%00001000
    899  137c		       08		      .byte.b	%00001000
    900  137d		       08		      .byte.b	%00001000
    901  137e		       7f		      .byte.b	%01111111
    902  137f		       48		      .byte.b	%01001000
    903  1380		       48		      .byte.b	%01001000
    904  1381		       48		      .byte.b	%01001000
    905  1382
    906  1382							;CharAL:
    907  1382							;    .byte %11100110
    908  1382							;    .byte %11100110
    909  1382							;    .byte %11111110
    910  1382							;    .byte %11100110
    911  1382							;    .byte %11100110
    912  1382							;    .byte %01111100
    913  1382							;    .byte %00111000
    914  1382							;CharEL:
    915  1382							;    .byte %11111110
    916  1382							;    .byte %11111110
    917  1382							;    .byte %11100000
    918  1382							;    .byte %11100000
    919  1382							;    .byte %11111100
    920  1382							;    .byte %11100000
    921  1382							;    .byte %11111110
    922  1382							;CharRL:
    923  1382							;    .byte %11100110
    924  1382							;    .byte %11100110
    925  1382							;    .byte %11111100
    926  1382							;    .byte %11111100
    927  1382							;    .byte %11100110
    928  1382							;    .byte %11100110
    929  1382							;    .byte %11111100
    930  1382							;CharVL:
    931  1382							;    .byte %00111000
    932  1382							;    .byte %01111100
    933  1382							;    .byte %11100110
    934  1382							;    .byte %11100110
    935  1382							;    .byte %11100110
    936  1382							;    .byte %11100110
    937  1382							;    .byte %11100110
    938  1382
      0  1382					      CHECKPAGE	BLANKR
      8  1382					      LIST	ON
    940  1382
    941  1382							;---------------------------------------------------------------------------
    942  1382
      0  1382					      DEFINE_SUBROUTINE	GameInitialise
      1  1382		       00 02	   BANK_GameInitialise =	_CURRENT_BANK
      2  1382					      SUBROUTINE
      3  1382				   GameInitialise
    944  1382
    945  1382							; copy loaded SK high score into scoring RAM:
    946  1382		       a2 02		      ldx	#3-1
    947  1384				   .loopCopyHighScore
    948  1384		       b5 db		      lda	highScoreSK,x
    949  1386		       c9 ff		      cmp	#$ff
    950  1388		       f0 06		      beq	.noSaveKey
    951  138a		       9d b7 f7 	      sta	HighScore+RAM_WRITE,x
    952  138d		       ca		      dex
    953  138e		       10 f4		      bpl	.loopCopyHighScore
    954  1390				   .noSaveKey
    955  1390
    956  1390							; clear both players scores
    957  1390		       a0 05		      ldy	#2*3-1
    958  1392		       a9 00		      lda	#0
    959  1394				   .loopClearScore
    960  1394		       99 ad f7 	      sta	ScoreCurrent+RAM_WRITE,y
    961  1397		       88		      dey
    962  1398		       10 fa		      bpl	.loopClearScore
    963  139a
    964  139a							; copy levelX and level for other player and SaveKey:
    965  139a		       a5 b3		      lda	levelX
    966  139c		       8d b5 f7 	      sta	PlayerLevelX+RAM_WRITE
    967  139f		       a5 de		      lda	startingLevel
    968  13a1		       8d b0 f7 	      sta	StartLevelX+RAM_WRITE
    969  13a4		       a5 b4		      lda	level
    970  13a6		       8d b6 f7 	      sta	PlayerLevel+RAM_WRITE
    971  13a9		       8d b1 f7 	      sta	StartLevel+RAM_WRITE
    972  13ac		       60		      rts
    973  13ad
    974  13ad							;---------------------------------------------------------------------------
    975  13ad
    976  13ad		       00 00 00    ScoreCurrent ds	3, 0
    977  13b0							; start levelx and level have to be after ScoreCurrent!
    978  13b0		       00	   StartLevelX .byte.b	0
    979  13b1		       00	   StartLevel .byte.b	0
    980  13b2		       00 00 00    PlayerScores ds	3, 0
    981  13b5							; levelx and level have to be consecutive variables!
    982  13b5		       00	   PlayerLevelX .byte.b	0
    983  13b6		       00	   PlayerLevel .byte.b	0
    984  13b7		       00 00 00 00*HighScore  ds	3+2, 0	; two extra bytes to save code
    985  13bc
    986  13bc
    987  13bc
    988  13bc							;------------------------------------------------------------------------------
    989  13bc
      0  13bc					      CHECK_HALF_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING"
      1  13bc
      2  13bc
      3  13bc		       03 bc	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING (1K) SIZE =  $3bc , FREE= $44
      4  13bc					      ECHO	"ROM_SHADOW_OF_BANK_SCORING", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  13bc				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  13bc				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  13bc				  -	      ERR
      8  13bc					      endif
    991  13bc
    992  13bc							;------------------------------------------------------------------------------
    993  13bc
    994  13bc							; LEVEL DATA banks can go anywhere - *EXCEPT* for the same bank as the level
    995  13bc							; decoder.  Ironic, isn't it?	They calculate a constant -- MAX_LEVEL_SIZE
    996  13bc							; which is used as a buffer size inside UnpackLevel.  It's not important if
    997  13bc							; this is defined before or after, as once the levels have processed it will be
    998  13bc							; correct. Note, that levels should all be defined BEFORE *OR* AFTER the
    999  13bc							; UnpackLevel code -- but that they should not be both, nor in the same bank.
   1000  13bc							; TODO: verify above is still valid
   1001  13bc
------- FILE LevelBank0.asm LEVEL 3 PASS 3
      0  13bc					      include	"LevelBank0.asm"
      1  13bc							; level definitions
      2  13bc							; Sample level definitions.
      3  13bc							; Any level can be in any bank.  System auto-calculates required bank buffer size in RAM.
      4  13bc							; have as many banks as you like.
      5  13bc
      0  13bc					      START_LEVEL	_0VM5_Andrea_Wadd
      1  13bc				   LEVEL_START SET	*
      2  13bc		       00 02	   BANK_LEVEL__0VM5_Andrea_Wadd =	_CURRENT_BANK
      3  13bc				   LEVEL__0VM5_Andrea_Wadd SUBROUTINE
      4  13bc				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  13bc
      7  13bc		       37 23 7c 23*	      .byte.b	"7#|#3-#-#|#-$*2-#|#-.-+-#|#-*2$-#|2#2-.-#|7#",0
      0  13e9					      END_LEVEL	_0VM5_Andrea_Wadd
      1  13e9		       00		      .byte.b	0
      2  13e9		       00 2e	   LEVEL_SIZE__0VM5_Andrea_Wadd =	* - LEVEL_START
      3  13ea				  -	      IF	LEVEL_SIZE__0VM5_Andrea_Wadd > MAX_LEVEL_SIZE
      4  13ea				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0VM5_Andrea_Wadd
      5  13ea					      ENDIF
      9  13ea
      0  13ea					      START_LEVEL	_0PAL_Jill_Leatherby
      1  13ea				   LEVEL_START SET	*
      2  13ea		       00 02	   BANK_LEVEL__0PAL_Jill_Leatherby =	_CURRENT_BANK
      3  13ea				   LEVEL__0PAL_Jill_Leatherby SUBROUTINE
      4  13ea				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  13ea
     11  13ea		       37 23 7c 23*	      .byte.b	"7#|#3-3#|#2-2*-#|#3-$-#|#2-$2.#|3#@2-#|7#",0
      0  1414					      END_LEVEL	_0PAL_Jill_Leatherby
      1  1414		       00		      .byte.b	0
      2  1414		       00 2b	   LEVEL_SIZE__0PAL_Jill_Leatherby =	* - LEVEL_START
      3  1415				  -	      IF	LEVEL_SIZE__0PAL_Jill_Leatherby > MAX_LEVEL_SIZE
      4  1415				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0PAL_Jill_Leatherby
      5  1415					      ENDIF
     13  1415
      0  1415					      START_LEVEL	_0IZ1_Sophia
      1  1415				   LEVEL_START SET	*
      2  1415		       00 02	   BANK_LEVEL__0IZ1_Sophia =	_CURRENT_BANK
      3  1415				   LEVEL__0IZ1_Sophia SUBROUTINE
      4  1415				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  1415
     15  1415		       37 23 7c 23*	      .byte.b	"7#|#5-#|#@$.#-#|#*$2-.#|#-2$2-#|#-.-.-#|7#",0
      0  1440					      END_LEVEL	_0IZ1_Sophia
      1  1440		       00		      .byte.b	0
      2  1440		       00 2c	   LEVEL_SIZE__0IZ1_Sophia =	* - LEVEL_START
      3  1441				  -	      IF	LEVEL_SIZE__0IZ1_Sophia > MAX_LEVEL_SIZE
      4  1441				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0IZ1_Sophia
      5  1441					      ENDIF
     17  1441
      0  1441					      START_LEVEL	_0CNH_Alice
      1  1441				   LEVEL_START SET	*
      2  1441		       00 02	   BANK_LEVEL__0CNH_Alice =	_CURRENT_BANK
      3  1441				   LEVEL__0CNH_Alice SUBROUTINE
      4  1441				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  1441
     19  1441		       37 23 7c 23*	      .byte.b	"7#|#.4-#|#$*-#-#|#.2-$*#|#-.$2-#|#@-*2-#|7#",0
      0  146d					      END_LEVEL	_0CNH_Alice
      1  146d		       00		      .byte.b	0
      2  146d		       00 2d	   LEVEL_SIZE__0CNH_Alice =	* - LEVEL_START
      3  146e				  -	      IF	LEVEL_SIZE__0CNH_Alice > MAX_LEVEL_SIZE
      4  146e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__0CNH_Alice
      5  146e					      ENDIF
     21  146e
      0  146e					      START_LEVEL	TowC
      1  146e				   LEVEL_START SET	*
      2  146e		       00 02	   BANK_LEVEL_TowC =	_CURRENT_BANK
      3  146e				   LEVEL_TowC SUBROUTINE
      4  146e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  146e
     23  146e		       34 2d 35 23*	      .byte.b	"4-5#|4-#3-#|4-#$2-#|2-3#2-$2#|2-#2-$-$-#|3#-#-2#-#3-6#|#3-#-2#-5#2-2.#|#-$2-$10-2.#|5#-3#-#@2#2-2.#|4-#5-9#|4-7#",0
      0  14df					      END_LEVEL	TowC
      1  14df		       00		      .byte.b	0
      2  14df		       00 72	   LEVEL_SIZE_TowC =	* - LEVEL_START
      3  14e0					      IF	LEVEL_SIZE_TowC > MAX_LEVEL_SIZE
      4  14e0				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_TowC
      5  14e0					      ENDIF
     25  14e0
      0  14e0					      START_LEVEL	SimpleC
      1  14e0				   LEVEL_START SET	*
      2  14e0		       00 02	   BANK_LEVEL_SimpleC =	_CURRENT_BANK
      3  14e0				   LEVEL_SimpleC SUBROUTINE
      4  14e0				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  14e0
     27  14e0		       37 23 7c 23*	      .byte.b	"7#|#.@-#-#|#$*-$-#|#3-$-#|#-..--#|#--*--#|7#",0
      0  150d					      END_LEVEL	SimpleC
      1  150d		       00		      .byte.b	0
      2  150d		       00 2e	   LEVEL_SIZE_SimpleC =	* - LEVEL_START
      3  150e				  -	      IF	LEVEL_SIZE_SimpleC > MAX_LEVEL_SIZE
      4  150e				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_SimpleC
      5  150e					      ENDIF
     29  150e
      0  150e					      START_LEVEL	bAlfa_DrFogh
      1  150e				   LEVEL_START SET	*
      2  150e		       00 02	   BANK_LEVEL_bAlfa_DrFogh =	_CURRENT_BANK
      3  150e				   LEVEL_bAlfa_DrFogh SUBROUTINE
      4  150e				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  150e
     31  150e		       32 2d 34 23*	      .byte.b	"2-4#2-4#|-2#2-2#-#2-#|-#4-3#2-2#|2#2-2*2-#.2-2#|#2-*2-*-#*#2-#|#-*4-2*2-#-#|#-*-2#-*3-#-#|2#-*2-*#*#-#-#|-#$-2*-#-*-#-#|-#@#2-2#5-#|-2#2-4#2-3#|2-#2-#2-4#|2-#2-#|2-4#",0
      0  15b5					      END_LEVEL	bAlfa_DrFogh
      1  15b5		       00		      .byte.b	0
      2  15b5		       00 a8	   LEVEL_SIZE_bAlfa_DrFogh =	* - LEVEL_START
      3  15b6					      IF	LEVEL_SIZE_bAlfa_DrFogh > MAX_LEVEL_SIZE
      4  15b6				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAlfa_DrFogh
      5  15b6					      ENDIF
     33  15b6
      0  15b6					      START_LEVEL	b51X_Sharpen
      1  15b6				   LEVEL_START SET	*
      2  15b6		       00 02	   BANK_LEVEL_b51X_Sharpen =	_CURRENT_BANK
      3  15b6				   LEVEL_b51X_Sharpen SUBROUTINE
      4  15b6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  15b6
     35  15b6		       2d 39 23 33*	      .byte.b	"-9#3-|-#7-#3-|-#-$-2$-$#3-|3#$#2-$-#3-|#.#3-2$-2#2-|#.3#3-$-#2-|#.#.-$-2#-3#|#3.$-$2#-$-#|#3.$3-$2-@#|#2.3#$3#-2#|#4.#5-#-|12#-",0
      0  1636					      END_LEVEL	b51X_Sharpen
      1  1636		       00		      .byte.b	0
      2  1636		       00 81	   LEVEL_SIZE_b51X_Sharpen =	* - LEVEL_START
      3  1637				  -	      IF	LEVEL_SIZE_b51X_Sharpen > MAX_LEVEL_SIZE
      4  1637				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_b51X_Sharpen
      5  1637					      ENDIF
     37  1637
      0  1637					      START_LEVEL	bDarcy_Burnsell101
      1  1637				   LEVEL_START SET	*
      2  1637		       00 02	   BANK_LEVEL_bDarcy_Burnsell101 =	_CURRENT_BANK
      3  1637				   LEVEL_bDarcy_Burnsell101 SUBROUTINE
      4  1637				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  1637
     39  1637		       38 23 7c 23*	      .byte.b	"8#|#2-.-$@#|#.#$*2$#|#2-.-*-#|#2$-2$.#|#.#-#2-#|#.2-.-.#|8#",0
      0  1673					      END_LEVEL	bDarcy_Burnsell101
      1  1673		       00		      .byte.b	0
      2  1673		       00 3d	   LEVEL_SIZE_bDarcy_Burnsell101 =	* - LEVEL_START
      3  1674				  -	      IF	LEVEL_SIZE_bDarcy_Burnsell101 > MAX_LEVEL_SIZE
      4  1674				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bDarcy_Burnsell101
      5  1674					      ENDIF
     41  1674
      0  1674					      START_LEVEL	bAislin101
      1  1674				   LEVEL_START SET	*
      2  1674		       00 02	   BANK_LEVEL_bAislin101 =	_CURRENT_BANK
      3  1674				   LEVEL_bAislin101 SUBROUTINE
      4  1674				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  1674
     43  1674		       38 23 7c 32*	      .byte.b	"8#|2#-*-*.#|#2.$-$*#|#-.#-*.#|2#-$-$2#|#-#$-$-#|#2.2-$@#|8#",0
      0  16b0					      END_LEVEL	bAislin101
      1  16b0		       00		      .byte.b	0
      2  16b0		       00 3d	   LEVEL_SIZE_bAislin101 =	* - LEVEL_START
      3  16b1				  -	      IF	LEVEL_SIZE_bAislin101 > MAX_LEVEL_SIZE
      4  16b1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_bAislin101
      5  16b1					      ENDIF
     45  16b1
      0  16b1					      START_LEVEL	b82X_Sharpen
      1  16b1				   LEVEL_START SET	*
      2  16b1		       00 02	   BANK_LEVEL_b82X_Sharpen =	_CURRENT_BANK
      3  16b1				   LEVEL_b82X_Sharpen SUBROUTINE
      4  16b1				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  16b1
     47  16b1		       2d 31 31 23*	      .byte.b	"-11#8-|-#5-#3-2#7-|-#-$-$-$-#2-5#3-|-3#2-5#5-#3-|-#4.#5-3#-#3-|-#.4#2-4#3-#3-|-#4.4-#2-$-2#3-|-#-3.#3-#-3$5#|3#.7#2-$@$3-#|#-$3-5#-$-2#3-#|#-#.#-$6-$3#$-#|#-#.8#2-#2-$-#|#-#3.7-2#-2$-#|#3-7#-$-#-#2-#|5#5-#7-2#|10-9#-",0
      0  178a					      END_LEVEL	b82X_Sharpen
      1  178a		       00		      .byte.b	0
      2  178a		       00 da	   LEVEL_SIZE_b82X_Sharpen =	* - LEVEL_START
      3  178b					      IF	LEVEL_SIZE_b82X_Sharpen > MAX_LEVEL_SIZE
      4  178b				   MAX_LEVEL_SIZE SET	LEVEL_SIZE_b82X_Sharpen
      5  178b					      ENDIF
     49  178b
      0  178b					      START_LEVEL	Thomas_Reinke16
      1  178b				   LEVEL_START SET	*
      2  178b		       00 02	   BANK_LEVEL_Thomas_Reinke16 =	_CURRENT_BANK
      3  178b				   LEVEL_Thomas_Reinke16 SUBROUTINE
      4  178b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  178b
     51  178b		       2d 35 23 7c*	      .byte.b	"-5#|2#3-3#|#6-2#|#-#-2#2-#|#2.*2-#-#|#2-*2-#-#|3#*2$2-#|2-#@-4#|2-4#",0
      0  17d0					      END_LEVEL	Thomas_Reinke16
      1  17d0		       00		      .byte.b	0
      2  17d0		       00 46	   LEVEL_SIZE_Thomas_Reinke16 =	* - LEVEL_START
      3  17d1				  -	      IF	LEVEL_SIZE_Thomas_Reinke16 > MAX_LEVEL_SIZE
      4  17d1				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE_Thomas_Reinke16
      5  17d1					      ENDIF
     53  17d1
     54  17d1							;Level element	Character	ASCII Code
     55  17d1							;Wall	#	0x23
     56  17d1							;Player	@	0x40
     57  17d1							;Player on goal square	+	0x2b
     58  17d1							;Box	$	0x24
     59  17d1							;Box on goal square	*	0x2a
     60  17d1							;Goal square	.	0x2e
     61  17d1							;Floor	(Space)	0x20 or underscore
     62  17d1
     63  17d1							;This level ("Claire", by Lee J Haywood):
     64  17d1
     65  17d1							;#######
     66  17d1							;#.@ # #
     67  17d1							;#$* $ #
     68  17d1							;#   $ #
     69  17d1							;# ..	#
     70  17d1							;#  *	#
     71  17d1							;#######
     72  17d1							;runlength encoded looks like this:
     73  17d1
     74  17d1							;The rows of the level are separated by "|"s. There has been a discussion in the Yahoo Group about what character should represent an empty square in May 2006. Finally the hyphen has been elected to be the standard character for an empty square. Nevertheless, programs are encouraged to support both, hyphens and underscores.
     75  17d1
     76  17d1							;If only two level elements are grouped together they may be run length encoded, but needn't to. Example:
     77  17d1
     78  17d1
     79  17d1							; ECHO "MAX LEVEL SIZE = ", MAX_LEVEL_SIZE
------- FILE BANK_ROM_SHADOW_SCORING.asm
   1003  17d1
      0  17d1					      CHECK_BANK_SIZE	"ROM_SHADOW_OF_BANK_SCORING -- full 2K"
      1  17d1		       07 d1	   .TEMP      =	* - BANK_START
 ROM_SHADOW_OF_BANK_SCORING -- full 2K (2K) SIZE =  $7d1 , FREE= $2f
      2  17d1					      ECHO	"ROM_SHADOW_OF_BANK_SCORING -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  17d1				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  17d1				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  17d1				  -	      ERR
      6  17d1					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_GENERIC.asm LEVEL 2 PASS 3
      0  17d1					      include	"BANK_GENERIC.asm"
      1  17d1							;------------------------------------------------------------------------------
      2  17d1							;##############################################################################
      3  17d1							;------------------------------------------------------------------------------
      4  17d1
      0  17d1					      NEWBANK	GENERIC_BANK_1
      1  1e1e ????				      SEG	GENERIC_BANK_1
      2  1800					      ORG	ORIGIN
      3  1800					      RORG	$F000
      4  1800				   BANK_START SET	*
      5  1800				   GENERIC_BANK_1 SET	ORIGIN / 2048
      6  1800				   ORIGIN     SET	ORIGIN + 2048
      7  1800				   _CURRENT_BANK SET	GENERIC_BANK_1
      6  1800
      7  1800
      8  1800
      0  1800					      DEFINE_1K_SEGMENT	DECODE_LEVEL_SHADOW
      1  1800					      ALIGN	$400
      2  1800				   SEGMENT_DECODE_LEVEL_SHADOW SET	*
      3  1800				   BANK_DECODE_LEVEL_SHADOW SET	_CURRENT_BANK
------- FILE DecodeLevel.asm LEVEL 3 PASS 3
      0  1800					      include	"DecodeLevel.asm"
      1  1800
      2  1800				   LEVELNUM   SET	0
      3  1800				   NUMBEROFLEVELS SET	0
      4  1800		       00 04	   LEVEL_DEFINITION_SIZE =	4
      5  1800
      6  1800					      MAC	add_level
      7  1800				   LEVEL_ACTIVE_{1} SET	1
      8  1800				   LEVEL_NAMED_{1} =	LEVELNUM
      9  1800					      .byte	<LEVEL_{1}
     10  1800					      .byte	>LEVEL_{1}
     11  1800					      .byte	BANK_LEVEL_{1}
     12  1800					      .byte	LEVEL_SIZE_{1}
     13  1800				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
     14  1800				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     15  1800					      ENDM		; {name}
     16  1800
     17  1800				   LevelInformation
     18  1800
     19  1800							; The ordering here corresponds to the ordering when playing...
     20  1800
      0  1800					      ADD_LEVEL	b82X_Sharpen
      1  1800				   LEVEL_ACTIVE_b82X_Sharpen SET	1
      2  1800		       00 00	   LEVEL_NAMED_b82X_Sharpen =	LEVELNUM
      3  1800		       b1		      .byte.b	<LEVEL_b82X_Sharpen
      4  1801		       f6		      .byte.b	>LEVEL_b82X_Sharpen
      5  1802		       02		      .byte.b	BANK_LEVEL_b82X_Sharpen
      6  1803		       da		      .byte.b	LEVEL_SIZE_b82X_Sharpen
      7  1803				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1803				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1804					      ADD_LEVEL	_001_L
      1  1804				   LEVEL_ACTIVE__001_L SET	1
      2  1804		       00 04	   LEVEL_NAMED__001_L =	LEVELNUM
      3  1804		       00		      .byte.b	<LEVEL__001_L
      4  1805		       f0		      .byte.b	>LEVEL__001_L
      5  1806		       04		      .byte.b	BANK_LEVEL__001_L
      6  1807		       13		      .byte.b	LEVEL_SIZE__001_L
      7  1807				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1807				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1808					      ADD_LEVEL	_002_L
      1  1808				   LEVEL_ACTIVE__002_L SET	1
      2  1808		       00 08	   LEVEL_NAMED__002_L =	LEVELNUM
      3  1808		       13		      .byte.b	<LEVEL__002_L
      4  1809		       f0		      .byte.b	>LEVEL__002_L
      5  180a		       04		      .byte.b	BANK_LEVEL__002_L
      6  180b		       1a		      .byte.b	LEVEL_SIZE__002_L
      7  180b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  180b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  180c					      ADD_LEVEL	_003_L
      1  180c				   LEVEL_ACTIVE__003_L SET	1
      2  180c		       00 0c	   LEVEL_NAMED__003_L =	LEVELNUM
      3  180c		       2d		      .byte.b	<LEVEL__003_L
      4  180d		       f0		      .byte.b	>LEVEL__003_L
      5  180e		       04		      .byte.b	BANK_LEVEL__003_L
      6  180f		       2d		      .byte.b	LEVEL_SIZE__003_L
      7  180f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  180f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1810					      ADD_LEVEL	_003_R
      1  1810				   LEVEL_ACTIVE__003_R SET	1
      2  1810		       00 10	   LEVEL_NAMED__003_R =	LEVELNUM
      3  1810		       5a		      .byte.b	<LEVEL__003_R
      4  1811		       f0		      .byte.b	>LEVEL__003_R
      5  1812		       04		      .byte.b	BANK_LEVEL__003_R
      6  1813		       2b		      .byte.b	LEVEL_SIZE__003_R
      7  1813				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1813				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1814					      ADD_LEVEL	_004_L
      1  1814				   LEVEL_ACTIVE__004_L SET	1
      2  1814		       00 14	   LEVEL_NAMED__004_L =	LEVELNUM
      3  1814		       85		      .byte.b	<LEVEL__004_L
      4  1815		       f0		      .byte.b	>LEVEL__004_L
      5  1816		       04		      .byte.b	BANK_LEVEL__004_L
      6  1817		       24		      .byte.b	LEVEL_SIZE__004_L
      7  1817				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1817				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1818					      ADD_LEVEL	_004_R
      1  1818				   LEVEL_ACTIVE__004_R SET	1
      2  1818		       00 18	   LEVEL_NAMED__004_R =	LEVELNUM
      3  1818		       a9		      .byte.b	<LEVEL__004_R
      4  1819		       f0		      .byte.b	>LEVEL__004_R
      5  181a		       04		      .byte.b	BANK_LEVEL__004_R
      6  181b		       1d		      .byte.b	LEVEL_SIZE__004_R
      7  181b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  181b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     28  181c
      0  181c					      ADD_LEVEL	_010_L
      1  181c				   LEVEL_ACTIVE__010_L SET	1
      2  181c		       00 1c	   LEVEL_NAMED__010_L =	LEVELNUM
      3  181c		       c6		      .byte.b	<LEVEL__010_L
      4  181d		       f0		      .byte.b	>LEVEL__010_L
      5  181e		       04		      .byte.b	BANK_LEVEL__010_L
      6  181f		       3b		      .byte.b	LEVEL_SIZE__010_L
      7  181f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  181f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1820					      ADD_LEVEL	_010_R
      1  1820				   LEVEL_ACTIVE__010_R SET	1
      2  1820		       00 20	   LEVEL_NAMED__010_R =	LEVELNUM
      3  1820		       01		      .byte.b	<LEVEL__010_R
      4  1821		       f1		      .byte.b	>LEVEL__010_R
      5  1822		       04		      .byte.b	BANK_LEVEL__010_R
      6  1823		       34		      .byte.b	LEVEL_SIZE__010_R
      7  1823				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1823				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1824					      ADD_LEVEL	_011_L
      1  1824				   LEVEL_ACTIVE__011_L SET	1
      2  1824		       00 24	   LEVEL_NAMED__011_L =	LEVELNUM
      3  1824		       35		      .byte.b	<LEVEL__011_L
      4  1825		       f1		      .byte.b	>LEVEL__011_L
      5  1826		       04		      .byte.b	BANK_LEVEL__011_L
      6  1827		       34		      .byte.b	LEVEL_SIZE__011_L
      7  1827				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1827				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     32  1828
      0  1828					      ADD_LEVEL	_057_L
      1  1828				   LEVEL_ACTIVE__057_L SET	1
      2  1828		       00 28	   LEVEL_NAMED__057_L =	LEVELNUM
      3  1828		       90		      .byte.b	<LEVEL__057_L
      4  1829		       f4		      .byte.b	>LEVEL__057_L
      5  182a		       01		      .byte.b	BANK_LEVEL__057_L
      6  182b		       57		      .byte.b	LEVEL_SIZE__057_L
      7  182b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  182b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     34  182c
      0  182c					      ADD_LEVEL	_060_R
      1  182c				   LEVEL_ACTIVE__060_R SET	1
      2  182c		       00 2c	   LEVEL_NAMED__060_R =	LEVELNUM
      3  182c		       bf		      .byte.b	<LEVEL__060_R
      4  182d		       f5		      .byte.b	>LEVEL__060_R
      5  182e		       01		      .byte.b	BANK_LEVEL__060_R
      6  182f		       49		      .byte.b	LEVEL_SIZE__060_R
      7  182f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  182f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     36  1830
      0  1830					      ADD_LEVEL	_061_R
      1  1830				   LEVEL_ACTIVE__061_R SET	1
      2  1830		       00 30	   LEVEL_NAMED__061_R =	LEVELNUM
      3  1830		       5d		      .byte.b	<LEVEL__061_R
      4  1831		       f6		      .byte.b	>LEVEL__061_R
      5  1832		       01		      .byte.b	BANK_LEVEL__061_R
      6  1833		       4a		      .byte.b	LEVEL_SIZE__061_R
      7  1833				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1833				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1834					      ADD_LEVEL	_061_L
      1  1834				   LEVEL_ACTIVE__061_L SET	1
      2  1834		       00 34	   LEVEL_NAMED__061_L =	LEVELNUM
      3  1834		       08		      .byte.b	<LEVEL__061_L
      4  1835		       f6		      .byte.b	>LEVEL__061_L
      5  1836		       01		      .byte.b	BANK_LEVEL__061_L
      6  1837		       55		      .byte.b	LEVEL_SIZE__061_L
      7  1837				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1837				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1838					      ADD_LEVEL	_062_L
      1  1838				   LEVEL_ACTIVE__062_L SET	1
      2  1838		       00 38	   LEVEL_NAMED__062_L =	LEVELNUM
      3  1838		       a7		      .byte.b	<LEVEL__062_L
      4  1839		       f6		      .byte.b	>LEVEL__062_L
      5  183a		       01		      .byte.b	BANK_LEVEL__062_L
      6  183b		       58		      .byte.b	LEVEL_SIZE__062_L
      7  183b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  183b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  183c					      ADD_LEVEL	_062_R
      1  183c				   LEVEL_ACTIVE__062_R SET	1
      2  183c		       00 3c	   LEVEL_NAMED__062_R =	LEVELNUM
      3  183c		       ff		      .byte.b	<LEVEL__062_R
      4  183d		       f6		      .byte.b	>LEVEL__062_R
      5  183e		       01		      .byte.b	BANK_LEVEL__062_R
      6  183f		       4d		      .byte.b	LEVEL_SIZE__062_R
      7  183f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  183f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1840					      ADD_LEVEL	_063_L
      1  1840				   LEVEL_ACTIVE__063_L SET	1
      2  1840		       00 40	   LEVEL_NAMED__063_L =	LEVELNUM
      3  1840		       4c		      .byte.b	<LEVEL__063_L
      4  1841		       f7		      .byte.b	>LEVEL__063_L
      5  1842		       01		      .byte.b	BANK_LEVEL__063_L
      6  1843		       51		      .byte.b	LEVEL_SIZE__063_L
      7  1843				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1843				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1844					      ADD_LEVEL	_063_R
      1  1844				   LEVEL_ACTIVE__063_R SET	1
      2  1844		       00 44	   LEVEL_NAMED__063_R =	LEVELNUM
      3  1844		       9d		      .byte.b	<LEVEL__063_R
      4  1845		       f7		      .byte.b	>LEVEL__063_R
      5  1846		       01		      .byte.b	BANK_LEVEL__063_R
      6  1847		       53		      .byte.b	LEVEL_SIZE__063_R
      7  1847				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1847				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1848					      ADD_LEVEL	_064_R
      1  1848				   LEVEL_ACTIVE__064_R SET	1
      2  1848		       00 48	   LEVEL_NAMED__064_R =	LEVELNUM
      3  1848		       c5		      .byte.b	<LEVEL__064_R
      4  1849		       f1		      .byte.b	>LEVEL__064_R
      5  184a		       04		      .byte.b	BANK_LEVEL__064_R
      6  184b		       4d		      .byte.b	LEVEL_SIZE__064_R
      7  184b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  184b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  184c					      ADD_LEVEL	_064_L
      1  184c				   LEVEL_ACTIVE__064_L SET	1
      2  184c		       00 4c	   LEVEL_NAMED__064_L =	LEVELNUM
      3  184c		       69		      .byte.b	<LEVEL__064_L
      4  184d		       f1		      .byte.b	>LEVEL__064_L
      5  184e		       04		      .byte.b	BANK_LEVEL__064_L
      6  184f		       5c		      .byte.b	LEVEL_SIZE__064_L
      7  184f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  184f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1850					      ADD_LEVEL	_065_R
      1  1850				   LEVEL_ACTIVE__065_R SET	1
      2  1850		       00 50	   LEVEL_NAMED__065_R =	LEVELNUM
      3  1850		       6b		      .byte.b	<LEVEL__065_R
      4  1851		       f2		      .byte.b	>LEVEL__065_R
      5  1852		       04		      .byte.b	BANK_LEVEL__065_R
      6  1853		       49		      .byte.b	LEVEL_SIZE__065_R
      7  1853				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1853				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1854					      ADD_LEVEL	_065_L
      1  1854				   LEVEL_ACTIVE__065_L SET	1
      2  1854		       00 54	   LEVEL_NAMED__065_L =	LEVELNUM
      3  1854		       12		      .byte.b	<LEVEL__065_L
      4  1855		       f2		      .byte.b	>LEVEL__065_L
      5  1856		       04		      .byte.b	BANK_LEVEL__065_L
      6  1857		       59		      .byte.b	LEVEL_SIZE__065_L
      7  1857				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1857				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1858					      ADD_LEVEL	_066_R
      1  1858				   LEVEL_ACTIVE__066_R SET	1
      2  1858		       00 58	   LEVEL_NAMED__066_R =	LEVELNUM
      3  1858		       0f		      .byte.b	<LEVEL__066_R
      4  1859		       f3		      .byte.b	>LEVEL__066_R
      5  185a		       04		      .byte.b	BANK_LEVEL__066_R
      6  185b		       57		      .byte.b	LEVEL_SIZE__066_R
      7  185b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  185b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  185c					      ADD_LEVEL	_066_L
      1  185c				   LEVEL_ACTIVE__066_L SET	1
      2  185c		       00 5c	   LEVEL_NAMED__066_L =	LEVELNUM
      3  185c		       b4		      .byte.b	<LEVEL__066_L
      4  185d		       f2		      .byte.b	>LEVEL__066_L
      5  185e		       04		      .byte.b	BANK_LEVEL__066_L
      6  185f		       5b		      .byte.b	LEVEL_SIZE__066_L
      7  185f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  185f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1860					      ADD_LEVEL	_067_R
      1  1860				   LEVEL_ACTIVE__067_R SET	1
      2  1860		       00 60	   LEVEL_NAMED__067_R =	LEVELNUM
      3  1860		       b4		      .byte.b	<LEVEL__067_R
      4  1861		       f3		      .byte.b	>LEVEL__067_R
      5  1862		       04		      .byte.b	BANK_LEVEL__067_R
      6  1863		       66		      .byte.b	LEVEL_SIZE__067_R
      7  1863				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1863				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1864					      ADD_LEVEL	_067_L
      1  1864				   LEVEL_ACTIVE__067_L SET	1
      2  1864		       00 64	   LEVEL_NAMED__067_L =	LEVELNUM
      3  1864		       66		      .byte.b	<LEVEL__067_L
      4  1865		       f3		      .byte.b	>LEVEL__067_L
      5  1866		       04		      .byte.b	BANK_LEVEL__067_L
      6  1867		       4e		      .byte.b	LEVEL_SIZE__067_L
      7  1867				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1867				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1868					      ADD_LEVEL	_068_R
      1  1868				   LEVEL_ACTIVE__068_R SET	1
      2  1868		       00 68	   LEVEL_NAMED__068_R =	LEVELNUM
      3  1868		       6f		      .byte.b	<LEVEL__068_R
      4  1869		       f4		      .byte.b	>LEVEL__068_R
      5  186a		       04		      .byte.b	BANK_LEVEL__068_R
      6  186b		       57		      .byte.b	LEVEL_SIZE__068_R
      7  186b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  186b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  186c					      ADD_LEVEL	_068_L
      1  186c				   LEVEL_ACTIVE__068_L SET	1
      2  186c		       00 6c	   LEVEL_NAMED__068_L =	LEVELNUM
      3  186c		       1a		      .byte.b	<LEVEL__068_L
      4  186d		       f4		      .byte.b	>LEVEL__068_L
      5  186e		       04		      .byte.b	BANK_LEVEL__068_L
      6  186f		       55		      .byte.b	LEVEL_SIZE__068_L
      7  186f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  186f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1870					      ADD_LEVEL	_069_R
      1  1870				   LEVEL_ACTIVE__069_R SET	1
      2  1870		       00 70	   LEVEL_NAMED__069_R =	LEVELNUM
      3  1870		       15		      .byte.b	<LEVEL__069_R
      4  1871		       f5		      .byte.b	>LEVEL__069_R
      5  1872		       04		      .byte.b	BANK_LEVEL__069_R
      6  1873		       4f		      .byte.b	LEVEL_SIZE__069_R
      7  1873				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1873				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1874					      ADD_LEVEL	_069_L
      1  1874				   LEVEL_ACTIVE__069_L SET	1
      2  1874		       00 74	   LEVEL_NAMED__069_L =	LEVELNUM
      3  1874		       c6		      .byte.b	<LEVEL__069_L
      4  1875		       f4		      .byte.b	>LEVEL__069_L
      5  1876		       04		      .byte.b	BANK_LEVEL__069_L
      6  1877		       4f		      .byte.b	LEVEL_SIZE__069_L
      7  1877				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1877				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     55  1878
      0  1878					      ADD_LEVEL	_103_Arielle
      1  1878				   LEVEL_ACTIVE__103_Arielle SET	1
      2  1878		       00 78	   LEVEL_NAMED__103_Arielle =	LEVELNUM
      3  1878		       3f		      .byte.b	<LEVEL__103_Arielle
      4  1879		       f4		      .byte.b	>LEVEL__103_Arielle
      5  187a		       01		      .byte.b	BANK_LEVEL__103_Arielle
      6  187b		       51		      .byte.b	LEVEL_SIZE__103_Arielle
      7  187b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  187b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  187c					      ADD_LEVEL	_103_Ajalae
      1  187c				   LEVEL_ACTIVE__103_Ajalae SET	1
      2  187c		       00 7c	   LEVEL_NAMED__103_Ajalae =	LEVELNUM
      3  187c		       f7		      .byte.b	<LEVEL__103_Ajalae
      4  187d		       f3		      .byte.b	>LEVEL__103_Ajalae
      5  187e		       01		      .byte.b	BANK_LEVEL__103_Ajalae
      6  187f		       48		      .byte.b	LEVEL_SIZE__103_Ajalae
      7  187f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  187f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1880					      ADD_LEVEL	_103_Adin
      1  1880				   LEVEL_ACTIVE__103_Adin SET	1
      2  1880		       00 80	   LEVEL_NAMED__103_Adin =	LEVELNUM
      3  1880		       ab		      .byte.b	<LEVEL__103_Adin
      4  1881		       f3		      .byte.b	>LEVEL__103_Adin
      5  1882		       01		      .byte.b	BANK_LEVEL__103_Adin
      6  1883		       4c		      .byte.b	LEVEL_SIZE__103_Adin
      7  1883				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1883				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1884					      ADD_LEVEL	_102_Raven
      1  1884				   LEVEL_ACTIVE__102_Raven SET	1
      2  1884		       00 84	   LEVEL_NAMED__102_Raven =	LEVELNUM
      3  1884		       3c		      .byte.b	<LEVEL__102_Raven
      4  1885		       f3		      .byte.b	>LEVEL__102_Raven
      5  1886		       01		      .byte.b	BANK_LEVEL__102_Raven
      6  1887		       6f		      .byte.b	LEVEL_SIZE__102_Raven
      7  1887				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1887				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1888					      ADD_LEVEL	_102_Oralia
      1  1888				   LEVEL_ACTIVE__102_Oralia SET	1
      2  1888		       00 88	   LEVEL_NAMED__102_Oralia =	LEVELNUM
      3  1888		       f7		      .byte.b	<LEVEL__102_Oralia
      4  1889		       f2		      .byte.b	>LEVEL__102_Oralia
      5  188a		       01		      .byte.b	BANK_LEVEL__102_Oralia
      6  188b		       45		      .byte.b	LEVEL_SIZE__102_Oralia
      7  188b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  188b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  188c					      ADD_LEVEL	_102_Natalie
      1  188c				   LEVEL_ACTIVE__102_Natalie SET	1
      2  188c		       00 8c	   LEVEL_NAMED__102_Natalie =	LEVELNUM
      3  188c		       50		      .byte.b	<LEVEL__102_Natalie
      4  188d		       f2		      .byte.b	>LEVEL__102_Natalie
      5  188e		       01		      .byte.b	BANK_LEVEL__102_Natalie
      6  188f		       47		      .byte.b	LEVEL_SIZE__102_Natalie
      7  188f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  188f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1890					      ADD_LEVEL	_102_Mirabel
      1  1890				   LEVEL_ACTIVE__102_Mirabel SET	1
      2  1890		       00 90	   LEVEL_NAMED__102_Mirabel =	LEVELNUM
      3  1890		       97		      .byte.b	<LEVEL__102_Mirabel
      4  1891		       f2		      .byte.b	>LEVEL__102_Mirabel
      5  1892		       01		      .byte.b	BANK_LEVEL__102_Mirabel
      6  1893		       60		      .byte.b	LEVEL_SIZE__102_Mirabel
      7  1893				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1893				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1894					      ADD_LEVEL	_1XJH_Tara_Gelson
      1  1894				   LEVEL_ACTIVE__1XJH_Tara_Gelson SET	1
      2  1894		       00 94	   LEVEL_NAMED__1XJH_Tara_Gelson =	LEVELNUM
      3  1894		       e7		      .byte.b	<LEVEL__1XJH_Tara_Gelson
      4  1895		       f4		      .byte.b	>LEVEL__1XJH_Tara_Gelson
      5  1896		       01		      .byte.b	BANK_LEVEL__1XJH_Tara_Gelson
      6  1897		       3b		      .byte.b	LEVEL_SIZE__1XJH_Tara_Gelson
      7  1897				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  1897				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  1898					      ADD_LEVEL	_1R7X_Alison
      1  1898				   LEVEL_ACTIVE__1R7X_Alison SET	1
      2  1898		       00 98	   LEVEL_NAMED__1R7X_Alison =	LEVELNUM
      3  1898		       22		      .byte.b	<LEVEL__1R7X_Alison
      4  1899		       f5		      .byte.b	>LEVEL__1R7X_Alison
      5  189a		       01		      .byte.b	BANK_LEVEL__1R7X_Alison
      6  189b		       2e		      .byte.b	LEVEL_SIZE__1R7X_Alison
      7  189b				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  189b				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  189c					      ADD_LEVEL	_1KWD_Cecile_Clayworth
      1  189c				   LEVEL_ACTIVE__1KWD_Cecile_Clayworth SET	1
      2  189c		       00 9c	   LEVEL_NAMED__1KWD_Cecile_Clayworth =	LEVELNUM
      3  189c		       50		      .byte.b	<LEVEL__1KWD_Cecile_Clayworth
      4  189d		       f5		      .byte.b	>LEVEL__1KWD_Cecile_Clayworth
      5  189e		       01		      .byte.b	BANK_LEVEL__1KWD_Cecile_Clayworth
      6  189f		       35		      .byte.b	LEVEL_SIZE__1KWD_Cecile_Clayworth
      7  189f				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  189f				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a0					      ADD_LEVEL	_1EKT_Samantha_Gelson
      1  18a0				   LEVEL_ACTIVE__1EKT_Samantha_Gelson SET	1
      2  18a0		       00 a0	   LEVEL_NAMED__1EKT_Samantha_Gelson =	LEVELNUM
      3  18a0		       85		      .byte.b	<LEVEL__1EKT_Samantha_Gelson
      4  18a1		       f5		      .byte.b	>LEVEL__1EKT_Samantha_Gelson
      5  18a2		       01		      .byte.b	BANK_LEVEL__1EKT_Samantha_Gelson
      6  18a3		       3a		      .byte.b	LEVEL_SIZE__1EKT_Samantha_Gelson
      7  18a3				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a3				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a4					      ADD_LEVEL	_0VM5_Andrea_Wadd
      1  18a4				   LEVEL_ACTIVE__0VM5_Andrea_Wadd SET	1
      2  18a4		       00 a4	   LEVEL_NAMED__0VM5_Andrea_Wadd =	LEVELNUM
      3  18a4		       bc		      .byte.b	<LEVEL__0VM5_Andrea_Wadd
      4  18a5		       f3		      .byte.b	>LEVEL__0VM5_Andrea_Wadd
      5  18a6		       02		      .byte.b	BANK_LEVEL__0VM5_Andrea_Wadd
      6  18a7		       2e		      .byte.b	LEVEL_SIZE__0VM5_Andrea_Wadd
      7  18a7				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18a7				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18a8					      ADD_LEVEL	_0PAL_Jill_Leatherby
      1  18a8				   LEVEL_ACTIVE__0PAL_Jill_Leatherby SET	1
      2  18a8		       00 a8	   LEVEL_NAMED__0PAL_Jill_Leatherby =	LEVELNUM
      3  18a8		       ea		      .byte.b	<LEVEL__0PAL_Jill_Leatherby
      4  18a9		       f3		      .byte.b	>LEVEL__0PAL_Jill_Leatherby
      5  18aa		       02		      .byte.b	BANK_LEVEL__0PAL_Jill_Leatherby
      6  18ab		       2b		      .byte.b	LEVEL_SIZE__0PAL_Jill_Leatherby
      7  18ab				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18ab				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18ac					      ADD_LEVEL	_0IZ1_Sophia
      1  18ac				   LEVEL_ACTIVE__0IZ1_Sophia SET	1
      2  18ac		       00 ac	   LEVEL_NAMED__0IZ1_Sophia =	LEVELNUM
      3  18ac		       15		      .byte.b	<LEVEL__0IZ1_Sophia
      4  18ad		       f4		      .byte.b	>LEVEL__0IZ1_Sophia
      5  18ae		       02		      .byte.b	BANK_LEVEL__0IZ1_Sophia
      6  18af		       2c		      .byte.b	LEVEL_SIZE__0IZ1_Sophia
      7  18af				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18af				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18b0					      ADD_LEVEL	_0CNH_Alice
      1  18b0				   LEVEL_ACTIVE__0CNH_Alice SET	1
      2  18b0		       00 b0	   LEVEL_NAMED__0CNH_Alice =	LEVELNUM
      3  18b0		       41		      .byte.b	<LEVEL__0CNH_Alice
      4  18b1		       f4		      .byte.b	>LEVEL__0CNH_Alice
      5  18b2		       02		      .byte.b	BANK_LEVEL__0CNH_Alice
      6  18b3		       2d		      .byte.b	LEVEL_SIZE__0CNH_Alice
      7  18b3				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b3				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18b4					      ADD_LEVEL	TowC
      1  18b4				   LEVEL_ACTIVE_TowC SET	1
      2  18b4		       00 b4	   LEVEL_NAMED_TowC =	LEVELNUM
      3  18b4		       6e		      .byte.b	<LEVEL_TowC
      4  18b5		       f4		      .byte.b	>LEVEL_TowC
      5  18b6		       02		      .byte.b	BANK_LEVEL_TowC
      6  18b7		       72		      .byte.b	LEVEL_SIZE_TowC
      7  18b7				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18b7				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18b8					      ADD_LEVEL	SimpleC
      1  18b8				   LEVEL_ACTIVE_SimpleC SET	1
      2  18b8		       00 b8	   LEVEL_NAMED_SimpleC =	LEVELNUM
      3  18b8		       e0		      .byte.b	<LEVEL_SimpleC
      4  18b9		       f4		      .byte.b	>LEVEL_SimpleC
      5  18ba		       02		      .byte.b	BANK_LEVEL_SimpleC
      6  18bb		       2e		      .byte.b	LEVEL_SIZE_SimpleC
      7  18bb				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18bb				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18bc					      ADD_LEVEL	Thomas_Reinke16
      1  18bc				   LEVEL_ACTIVE_Thomas_Reinke16 SET	1
      2  18bc		       00 bc	   LEVEL_NAMED_Thomas_Reinke16 =	LEVELNUM
      3  18bc		       8b		      .byte.b	<LEVEL_Thomas_Reinke16
      4  18bd		       f7		      .byte.b	>LEVEL_Thomas_Reinke16
      5  18be		       02		      .byte.b	BANK_LEVEL_Thomas_Reinke16
      6  18bf		       46		      .byte.b	LEVEL_SIZE_Thomas_Reinke16
      7  18bf				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18bf				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c0					      ADD_LEVEL	bDarcy_Burnsell101
      1  18c0				   LEVEL_ACTIVE_bDarcy_Burnsell101 SET	1
      2  18c0		       00 c0	   LEVEL_NAMED_bDarcy_Burnsell101 =	LEVELNUM
      3  18c0		       37		      .byte.b	<LEVEL_bDarcy_Burnsell101
      4  18c1		       f6		      .byte.b	>LEVEL_bDarcy_Burnsell101
      5  18c2		       02		      .byte.b	BANK_LEVEL_bDarcy_Burnsell101
      6  18c3		       3d		      .byte.b	LEVEL_SIZE_bDarcy_Burnsell101
      7  18c3				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c3				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c4					      ADD_LEVEL	bAlfa_DrFogh
      1  18c4				   LEVEL_ACTIVE_bAlfa_DrFogh SET	1
      2  18c4		       00 c4	   LEVEL_NAMED_bAlfa_DrFogh =	LEVELNUM
      3  18c4		       0e		      .byte.b	<LEVEL_bAlfa_DrFogh
      4  18c5		       f5		      .byte.b	>LEVEL_bAlfa_DrFogh
      5  18c6		       02		      .byte.b	BANK_LEVEL_bAlfa_DrFogh
      6  18c7		       a8		      .byte.b	LEVEL_SIZE_bAlfa_DrFogh
      7  18c7				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18c7				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18c8					      ADD_LEVEL	bAislin101
      1  18c8				   LEVEL_ACTIVE_bAislin101 SET	1
      2  18c8		       00 c8	   LEVEL_NAMED_bAislin101 =	LEVELNUM
      3  18c8		       74		      .byte.b	<LEVEL_bAislin101
      4  18c9		       f6		      .byte.b	>LEVEL_bAislin101
      5  18ca		       02		      .byte.b	BANK_LEVEL_bAislin101
      6  18cb		       3d		      .byte.b	LEVEL_SIZE_bAislin101
      7  18cb				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18cb				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
      0  18cc					      ADD_LEVEL	b51X_Sharpen
      1  18cc				   LEVEL_ACTIVE_b51X_Sharpen SET	1
      2  18cc		       00 cc	   LEVEL_NAMED_b51X_Sharpen =	LEVELNUM
      3  18cc		       b6		      .byte.b	<LEVEL_b51X_Sharpen
      4  18cd		       f5		      .byte.b	>LEVEL_b51X_Sharpen
      5  18ce		       02		      .byte.b	BANK_LEVEL_b51X_Sharpen
      6  18cf		       81		      .byte.b	LEVEL_SIZE_b51X_Sharpen
      7  18cf				   LEVELNUM   SET	LEVELNUM + LEVEL_DEFINITION_SIZE
      8  18cf				   NUMBEROFLEVELS SET	NUMBEROFLEVELS + 1
     78  18d0
     79  18d0
     80  18d0				   finX
     81  18d0							; now put the soil in - fill from the outsides
     82  18d0
     83  18d0		       a9 01		      lda	#CHARACTER_SOIL
     84  18d2		       85 8e		      sta	POS_Type
     85  18d4
     86  18d4		       a9 15		      lda	#SIZE_BOARD_Y-1
     87  18d6		       85 8b		      sta	POS_Y
     88  18d8
     89  18d8		       a9 27	   xlin       lda	#SIZE_BOARD_X-1
     90  18da		       85 8a		      sta	POS_X
     91  18dc		       20 29 f8    zap1       jsr	GetBoardCharacter__CALL_FROM_RAM__
     92  18df		       c9 01		      cmp	#CHARACTER_SOIL
     93  18e1		       f0 07		      beq	kg2a
     94  18e3		       c9 00		      cmp	#0
     95  18e5		       d0 07		      bne	endzap1
     96  18e7		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
     97  18ea		       c6 8a	   kg2a       dec	POS_X
     98  18ec		       10 ee		      bpl	zap1
     99  18ee
    100  18ee		       a9 00	   endzap1    lda	#0
    101  18f0		       85 8a		      sta	POS_X
    102  18f2		       20 29 f8    zap2       jsr	GetBoardCharacter__CALL_FROM_RAM__
    103  18f5		       c9 01		      cmp	#CHARACTER_SOIL
    104  18f7		       f0 07		      beq	kg2
    105  18f9		       c9 00		      cmp	#0
    106  18fb		       d0 0b		      bne	endzap2
    107  18fd		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    108  1900		       e6 8a	   kg2	      inc	POS_X
    109  1902		       a5 8a		      lda	POS_X
    110  1904		       c9 28		      cmp	#SIZE_BOARD_X
    111  1906		       d0 ea		      bne	zap2
    112  1908
    113  1908		       c6 8b	   endzap2    dec	POS_Y
    114  190a		       10 cc		      bpl	xlin
    115  190c
    116  190c
    117  190c		       a9 27		      lda	#SIZE_BOARD_X-1
    118  190e		       85 8a		      sta	POS_X
    119  1910
    120  1910		       a9 15	   ylin       lda	#SIZE_BOARD_Y-1
    121  1912		       85 8b		      sta	POS_Y
    122  1914		       20 29 f8    zapy1      jsr	GetBoardCharacter__CALL_FROM_RAM__
    123  1917		       c9 01		      cmp	#CHARACTER_SOIL
    124  1919		       f0 07		      beq	kg3
    125  191b		       c9 00		      cmp	#0
    126  191d		       d0 07		      bne	endzapy1
    127  191f		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    128  1922		       c6 8b	   kg3	      dec	POS_Y
    129  1924		       10 ee		      bpl	zapy1
    130  1926
    131  1926		       a9 00	   endzapy1   lda	#0
    132  1928		       85 8b		      sta	POS_Y
    133  192a		       20 29 f8    zapy2      jsr	GetBoardCharacter__CALL_FROM_RAM__
    134  192d		       c9 01		      cmp	#CHARACTER_SOIL
    135  192f		       f0 07		      beq	kg3b
    136  1931		       c9 00		      cmp	#0
    137  1933		       d0 0b		      bne	endzapy2
    138  1935		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    139  1938		       e6 8b	   kg3b       inc	POS_Y
    140  193a		       a5 8b		      lda	POS_Y
    141  193c		       c9 16		      cmp	#SIZE_BOARD_Y
    142  193e		       d0 ea		      bne	zapy2
    143  1940
    144  1940		       c6 8a	   endzapy2   dec	POS_X
    145  1942		       10 cc		      bpl	ylin
    146  1944		       60		      rts
    147  1945
      0  1945					      DEFINE_SUBROUTINE	RegisterOneMoreTarget
      1  1945		       00 03	   BANK_RegisterOneMoreTarget =	_CURRENT_BANK
      2  1945					      SUBROUTINE
      3  1945				   RegisterOneMoreTarget
    149  1945
    150  1945		       f8		      sed
    151  1946		       18		      clc
    152  1947		       a5 b8		      lda	targetsRequired
    153  1949		       69 01		      adc	#1
    154  194b		       85 b8		      sta	targetsRequired
    155  194d		       d8		      cld
    156  194e		       60		      rts
    157  194f
    158  194f
      0  194f					      DEFINE_SUBROUTINE	UnpackLevel
      1  194f		       00 03	   BANK_UnpackLevel =	_CURRENT_BANK
      2  194f					      SUBROUTINE
      3  194f				   UnpackLevel
    160  194f
    161  194f		       85 c3		      sta	RAM_Bank
    162  1951
    163  1951							; has to be done before decoding the level to have the platform right:
      0  1951					      SET_PLATFORM
      1  1951
      2  1951
      3  1951
      4  1951
      5  1951		       ad 82 02 	      lda	SWCHB
      6  1954		       2a		      rol
      7  1955		       2a		      rol
      8  1956		       2a		      rol
      9  1957		       29 03		      and	#%11
     10  1959					      if	NTSC_MODE = NO
     11  1959		       49 02		      eor	#PAL
     12  195b					      endif
     13  195b		       a9 00		      lda	#0
     14  195d		       85 81		      sta	Platform
    165  195f
    166  195f		       a9 00		      lda	#CHARACTER_BLANK
    167  1961		       85 8e		      sta	POS_Type
    168  1963
    169  1963		       a9 15		      lda	#SIZE_BOARD_Y-1
    170  1965		       85 8b		      sta	POS_Y
    171  1967		       a9 27	   xyLine     lda	#SIZE_BOARD_X-1
    172  1969		       85 8a		      sta	POS_X
    173  196b		       20 3d f8    xyClear    jsr	PutBoardCharacterFromRAM
    174  196e		       c6 8a		      dec	POS_X
    175  1970		       10 f9		      bpl	xyClear
    176  1972		       c6 8b		      dec	POS_Y
    177  1974		       10 f1		      bpl	xyLine
    178  1976
    179  1976		       a9 06		      lda	#6
    180  1978		       85 d8		      sta	base_x
    181  197a		       85 d9		      sta	base_y
    182  197c
    183  197c		       a5 c8		      lda	NextLevelTrigger
    184  197e		       09 80		      ora	#BIT_NEXTLEVEL
    185  1980		       85 c8		      sta	NextLevelTrigger
    186  1982
    187  1982		       a4 b3		      ldy	levelX
    188  1984		       38		      sec
    189  1985		       b9 00 f0 	      lda	LevelInformation,y
    190  1988		       e9 01		      sbc	#1
    191  198a		       85 be		      sta	Board_AddressR
    192  198c		       b9 01 f0 	      lda	LevelInformation+1,y
    193  198f		       e9 00		      sbc	#0
    194  1991		       85 bf		      sta	Board_AddressR+1
    195  1993		       b9 02 f0 	      lda	LevelInformation+2,y
    196  1996		       85 af		      sta	LEVEL_bank
    197  1998
    198  1998		       a9 03		      lda	#BANK_UnpackLevel	; the *ROM* bank of this routine (NOT RAM)
    199  199a		       85 c2		      sta	ROM_Bank	; GetROMByte returns to this bank
    200  199c
    201  199c							;NEXT_RANDOM
    202  199c							;and #$F0
    203  199c							;ora #$A
    204  199c		       a9 8a		      lda	#$8a	;ba
    205  199e		       85 bb		      sta	color
    206  19a0		       a9 44		      lda	#$44
    207  19a2							;lda #$A0
    208  19a2		       85 bc		      sta	color+1
    209  19a4		       a9 2a		      lda	#$2a	;lda #$9C
    210  19a6		       85 bd		      sta	color+2
    211  19a8
    212  19a8		       a9 00		      lda	#$00
    213  19aa		       85 b9		      sta	moveCounter
    214  19ac		       85 ba		      sta	moveCounterHi
    215  19ae
    216  19ae		       a9 00		      lda	#$00	; BCD reminder!
    217  19b0		       85 b8		      sta	targetsRequired	; # of targets that do NOT have boxes on them
    218  19b2
    219  19b2							;lda #SIZE_BOARD_X
    220  19b2							;sta BoardLimit_Width
    221  19b2							;lda #SIZE_BOARD_Y
    222  19b2							;sta BoardLimit_Height
    223  19b2							;lda #$5
    224  19b2							;sta targetsRequired		   ;	   should never be 0
    225  19b2
    226  19b2		       a9 18		      lda	#24	; arbitrary
    227  19b4		       85 b7		      sta	ThrottleSpeed
    228  19b6
    229  19b6							; first fill bg with character_soil
    230  19b6							; then rle unpack level
    231  19b6							; change level colours
    232  19b6
    233  19b6		       a9 00		      lda	#0
    234  19b8		       85 8a		      sta	POS_X
    235  19ba		       85 8b		      sta	POS_Y
    236  19bc		       85 94		      sta	BoardLimit_Width
    237  19be		       85 95		      sta	BoardLimit_Height
    238  19c0
    239  19c0				   GetNextItem
    240  19c0
    241  19c0		       a9 01		      lda	#1
    242  19c2		       85 da		      sta	upk_length
    243  19c4		       a9 00		      lda	#0
    244  19c6		       85 db		      sta	upk_column	; reuse var - this flags a digit already
    245  19c8
    246  19c8		       e6 be	   Get2       inc	Board_AddressR
    247  19ca		       d0 02		      bne	addrOK
    248  19cc		       e6 bf		      inc	Board_AddressR+1
    249  19ce				   addrOK
    250  19ce
    251  19ce		       a5 af		      lda	LEVEL_bank
    252  19d0		       a0 00		      ldy	#0
    253  19d2		       20 12 f8 	      jsr	GetROMByte
    254  19d5		       85 dc		      sta	upk_temp	;scratch
    255  19d7
    256  19d7
    257  19d7		       c9 00		      cmp	#0
    258  19d9		       d0 03		      bne	parse
    259  19db		       4c d0 f0 	      jmp	finX
    260  19de				   parse
    261  19de		       c9 3a		      cmp	#"9"+1
    262  19e0		       b0 1e		      bcs	notDigit
    263  19e2		       c9 30		      cmp	#"0"
    264  19e4		       90 1a		      bcc	notDigit
    265  19e6
    266  19e6		       a5 db		      lda	upk_column
    267  19e8		       f0 09		      beq	firstDig
    268  19ea
    269  19ea		       a5 da		      lda	upk_length
    270  19ec		       0a		      asl
    271  19ed		       0a		      asl
    272  19ee		       0a		      asl
    273  19ef		       65 da		      adc	upk_length
    274  19f1		       65 da		      adc	upk_length
    275  19f3
    276  19f3		       18	   firstDig   clc
    277  19f4		       65 dc		      adc	upk_temp
    278  19f6		       38		      sec
    279  19f7		       e9 30		      sbc	#"0"
    280  19f9		       85 da		      sta	upk_length
    281  19fb		       e6 db		      inc	upk_column	; flag we have seen a digit
    282  19fd		       4c c8 f1 	      jmp	Get2
    283  1a00
    284  1a00		       c9 7c	   notDigit   cmp	#"|"	; newline
    285  1a02		       d0 11		      bne	checkWall
    286  1a04
    287  1a04							; Handle new-line
    288  1a04		       a9 00		      lda	#0
    289  1a06		       85 8a		      sta	POS_X
    290  1a08		       e6 8b		      inc	POS_Y
    291  1a0a
    292  1a0a
    293  1a0a		       a5 8b		      lda	POS_Y
    294  1a0c		       c5 95		      cmp	BoardLimit_Height
    295  1a0e		       90 02		      bcc	wOK2
    296  1a10		       85 95		      sta	BoardLimit_Height	;???^^^
    297  1a12				   wOK2
    298  1a12
    299  1a12		       4c c0 f1 	      jmp	GetNextItem
    300  1a15
    301  1a15		       c9 23	   checkWall  cmp	#"#"	; wall
    302  1a17		       d0 04		      bne	checkForGap
    303  1a19		       a9 07		      lda	#CHARACTER_WALL
    304  1a1b		       d0 66		      bne	WriteChars
    305  1a1d
    306  1a1d		       c9 20	   checkForGap cmp	#32
    307  1a1f		       f0 08		      beq	writeGap
    308  1a21		       c9 2d		      cmp	#"-"
    309  1a23		       f0 04		      beq	writeGap
    310  1a25		       c9 5f		      cmp	#"_"
    311  1a27		       d0 05		      bne	checkForMan
    312  1a29
    313  1a29		       a9 00	   writeGap   lda	#CHARACTER_BLANK
    314  1a2b		       4c 83 f2 	      jmp	WriteChars
    315  1a2e
    316  1a2e				   checkForMan
    317  1a2e		       c9 2b		      cmp	#"+"	; player on goal square
    318  1a30		       d0 07		      bne	notPlayerGoal
    319  1a32
    320  1a32		       20 45 f1 	      jsr	RegisterOneMoreTarget
    321  1a35
    322  1a35							; put goal square, init player with POS_VAR = CHARACTER_TARGET
    323  1a35
    324  1a35		       a9 03		      lda	#CHARACTER_TARGET
    325  1a37		       d0 06		      bne	genPlayer
    326  1a39
    327  1a39				   notPlayerGoal
    328  1a39		       c9 40		      cmp	#"@"	; player on normal square
    329  1a3b		       d0 2d		      bne	checkBox
    330  1a3d
    331  1a3d		       a9 00		      lda	#CHARACTER_BLANK
    332  1a3f
    333  1a3f				   genPlayer
    334  1a3f
    335  1a3f		       85 8f		      sta	POS_VAR	; character man is on
    336  1a41
    337  1a41		       18		      clc
    338  1a42		       a5 8a		      lda	POS_X
    339  1a44		       48		      pha
    340  1a45		       65 d8		      adc	base_x
    341  1a47		       85 8a		      sta	POS_X
    342  1a49		       85 9b		      sta	ManX
    343  1a4b
    344  1a4b		       a5 8b		      lda	POS_Y
    345  1a4d		       48		      pha
    346  1a4e		       65 d9		      adc	base_y
    347  1a50		       85 8b		      sta	POS_Y
    348  1a52		       85 9c		      sta	ManY
    349  1a54
    350  1a54							; POS_X     x position
    351  1a54							; POS_Y     y position
    352  1a54							; POS_VAR   CHARACTER UNDER MAN TO RESTORE
    353  1a54							; POS_Type  type of object
    354  1a54
    355  1a54		       a9 00		      lda	#TYPE_MAN
    356  1a56		       85 8e		      sta	POS_Type	;	 creature TYPE
    357  1a58		       20 8c f9 	      jsr	InsertObjectStackFromRAM	;6+94(B)
    358  1a5b
    359  1a5b		       a9 00		      lda	#0
    360  1a5d		       85 9a		      sta	manAnimationIndex
    361  1a5f
    362  1a5f		       68		      pla
    363  1a60		       85 8b		      sta	POS_Y
    364  1a62		       68		      pla
    365  1a63		       85 8a		      sta	POS_X
    366  1a65
    367  1a65		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    368  1a67		       4c 83 f2 	      jmp	WriteChars
    369  1a6a
    370  1a6a		       c9 24	   checkBox   cmp	#"$"
    371  1a6c		       d0 04		      bne	checkBoxTarget
    372  1a6e
    373  1a6e		       a9 02		      lda	#CHARACTER_BOX
    374  1a70		       d0 11		      bne	WriteChars
    375  1a72
    376  1a72		       c9 2a	   checkBoxTarget cmp	#"*"
    377  1a74		       d0 04		      bne	checkTarget
    378  1a76
    379  1a76		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    380  1a78		       d0 09		      bne	WriteChars
    381  1a7a
    382  1a7a		       c9 2e	   checkTarget cmp	#"."
    383  1a7c		       f0 03		      beq	targ
    384  1a7e		       4c c0 f1 	      jmp	GetNextItem
    385  1a81				   targ
    386  1a81
    387  1a81		       a9 03		      lda	#CHARACTER_TARGET
    388  1a83
    389  1a83		       85 8e	   WriteChars sta	POS_Type
    390  1a85
    391  1a85		       18	   Wc2x       clc
    392  1a86		       a5 8a		      lda	POS_X
    393  1a88		       48		      pha
    394  1a89		       65 d8		      adc	base_x
    395  1a8b		       85 8a		      sta	POS_X
    396  1a8d
    397  1a8d		       a5 8b		      lda	POS_Y
    398  1a8f		       48		      pha
    399  1a90		       65 d9		      adc	base_y
    400  1a92		       85 8b		      sta	POS_Y
    401  1a94
    402  1a94		       20 3d f8 	      jsr	PutBoardCharacterFromRAM
    403  1a97
    404  1a97		       a5 8e		      lda	POS_Type
    405  1a99		       c9 03		      cmp	#CHARACTER_TARGET
    406  1a9b		       d0 03		      bne	notargdet
    407  1a9d		       20 45 f1 	      jsr	RegisterOneMoreTarget
    408  1aa0				   notargdet
    409  1aa0
    410  1aa0		       68		      pla
    411  1aa1		       85 8b		      sta	POS_Y
    412  1aa3		       68		      pla
    413  1aa4		       85 8a		      sta	POS_X
    414  1aa6
    415  1aa6		       18		      clc
    416  1aa7		       69 01		      adc	#1
    417  1aa9		       85 8a		      sta	POS_X
    418  1aab
    419  1aab		       c5 94		      cmp	BoardLimit_Width
    420  1aad		       90 02		      bcc	wOK
    421  1aaf		       85 94		      sta	BoardLimit_Width
    422  1ab1				   wOK
    423  1ab1
    424  1ab1		       c6 da		      dec	upk_length
    425  1ab3		       d0 d0		      bne	Wc2x
    426  1ab5		       4c c0 f1 	      jmp	GetNextItem
    427  1ab8
    428  1ab8				   finishedUnpack
    429  1ab8
    430  1ab8		       60		      rts
    431  1ab8					      endif
------- FILE BANK_GENERIC.asm
     11  1ab9
      0  1ab9					      CHECK_HALF_BANK_SIZE	"GENERIC_BANK_1 (DECODE_LEVEL)"
      1  1ab9
      2  1ab9
      3  1ab9		       02 b9	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 (DECODE_LEVEL) (1K) SIZE =  $2b9 , FREE= $147
      4  1ab9					      ECHO	"GENERIC_BANK_1 (DECODE_LEVEL)", "(1K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE/2 - .TEMP
      5  1ab9				  -	      if	( .TEMP ) > ROM_BANK_SIZE/2
      6  1ab9				  -	      ECHO	"HALF-BANK OVERFLOW @ ", * - ORIGIN
      7  1ab9				  -	      ERR
      8  1ab9					      endif
     13  1ab9
     14  1ab9							;------------------------------------------------------------------------------
     15  1ab9							; ... the above is a RAM-copied section -- the following is ROM-only.	Note that
     16  1ab9							; we do not configure a 1K boundary, as we con't really care when the above 'RAM'
     17  1ab9							; bank finishes.  Just continue on from where it left off...
     18  1ab9							;------------------------------------------------------------------------------
     19  1ab9
      0  1ab9					      DEFINE_SUBROUTINE	Cart_Init	; in GENERIC_BANK_1
      1  1ab9		       00 03	   BANK_Cart_Init =	_CURRENT_BANK
      2  1ab9					      SUBROUTINE
      3  1ab9				   Cart_Init
     21  1ab9
     22  1ab9							; Note the variables from the title selection are incredibly transient an can be stomped
     23  1ab9							; at any time.  So they need to be used immediately.
     24  1ab9
     25  1ab9
     26  1ab9							; odd usage below is to prevent any possibility of variable stomping/assumptions
     27  1ab9
     28  1ab9		       a9 01		      lda	#1
     29  1abb		       a2 00		      ldx	#0	;sLevel				      ; level # from title select
     30  1abd		       a0 00		      ldy	#0	;sJoysticks
     31  1abf		       84 a8		      sty	jtoggle
     32  1ac1		       86 b4		      stx	level
     33  1ac3		       85 a7		      sta	ManCount	; = #players
     34  1ac5		       a9 00		      lda	#0
     35  1ac7		       85 b3		      sta	levelX	; make an immediate copy to safe variables!
     36  1ac9		       85 de		      sta	startingLevel
     37  1acb
     38  1acb							; multiply with LEVEL_DEFINITION_SIZE (5):
     39  1acb		       0a		      asl
     40  1acc		       0a		      asl
     41  1acd		       85 b3		      sta	levelX
     42  1acf
     43  1acf		       a9 01		      lda	#1
     44  1ad1		       85 99		      sta	whichPlayer	; will switch to 0 on 1st go
     45  1ad3
     46  1ad3		       a9 30		      lda	#NUM_LIVES<<4	; 3 lives
     47  1ad5		       a6 a7		      ldx	ManCount	; = sPlayers
     48  1ad7		       f0 02		      beq	opg
     49  1ad9		       a9 33		      lda	#NUM_LIVES<<4|NUM_LIVES
     50  1adb		       85 a7	   opg	      sta	ManCount	; P2P1 nybble each
     51  1add
     52  1add							;---------------------------------------------------------------------------
     53  1add
     54  1add		       a9 00		      lda	#0
     55  1adf		       8d 83 02 	      sta	SWBCNT	; console I/O always set to INPUT
     56  1ae2		       8d 81 02 	      sta	SWACNT	; set controller I/O to INPUT
     57  1ae5		       85 6b		      sta	HMCLR
     58  1ae7
     59  1ae7							; cleanup remains of title screen
     60  1ae7		       85 5b		      sta	GRP0
     61  1ae9		       85 5c		      sta	GRP1
     62  1aeb		       85 5b		      sta	GRP0
     63  1aed
     64  1aed		       85 89		      sta	ScreenDrawPhase	; sequences the sections of gameplay/screen drawing
     65  1aef		       85 a9		      sta	circle_d
     66  1af1		       85 aa		      sta	circle_d+1
     67  1af3
     68  1af3							;    IFCONST DEBUG_CREATURE
     69  1af3							;		  sta worstTime
     70  1af3							;    ENDIF
     71  1af3
     72  1af3		       a9 04		      lda	#%100	; players/missiles BEHIND BG
     73  1af5		       85 4a		      sta	CTRLPF
     74  1af7		       85 82		      sta	rnd	; anything non-0
     75  1af9
     76  1af9		       a9 ff		      lda	#$FF
     77  1afb		       85 84		      sta	DrawStackPointer
     78  1afd		       85 92		      sta	BufferedButton
     79  1aff		       85 93		      sta	BufferedButton+1
     80  1b01
     81  1b01		       a9 07		      lda	#DIRECTION_BITS
     82  1b03		       85 a4		      sta	ManLastDirection
     83  1b05
     84  1b05		       a9 00		      lda	#0
     85  1b07							;		  sta ObjStackPtr		  ; object stack index of last entry
     86  1b07							;		  sta ObjStackPtr+1
     87  1b07							;		  sta ObjStackNum
     88  1b07							;		  sta ObjIterator
     89  1b07
     90  1b07		       85 ca		      sta	sortPtr
     91  1b09		       a9 ff		      lda	#<(-1)
     92  1b0b		       85 c9		      sta	sortRequired
     93  1b0d
     94  1b0d							; read high score from SaveKey and store in highScoreSK,
     95  1b0d							; which is transferred to high score variable in RAM by GeneralScoringSetups
     96  1b0d		       4c 76 f5 	      jmp	ReadSaveKey
     97  1b10
     98  1b10							;LEVEL0CREATURE  .byte TYPE_MAN,	  0,	  3,	  5
     99  1b10							;		  .byte -1
    100  1b10
    101  1b10							;------------------------------------------------------------------------------
    102  1b10
      0  1b10					      DEFINE_SUBROUTINE	SwapPlayersGeneric
      1  1b10		       00 03	   BANK_SwapPlayersGeneric =	_CURRENT_BANK
      2  1b10					      SUBROUTINE
      3  1b10				   SwapPlayersGeneric
    104  1b10
    105  1b10							; at the start of a level (or player, doesn't matter) we grab the current state of the colour/B&W switch
    106  1b10							; into the gameMode variable.
    107  1b10
    108  1b10		       a5 80		      lda	gameMode
    109  1b12		       29 77		      and	#~(BW_SWITCH|GAMEMODE_PAUSED)
    110  1b14		       85 80		      sta	gameMode
    111  1b16		       ad 82 02 	      lda	SWCHB
    112  1b19		       29 08		      and	#BW_SWITCH
    113  1b1b		       05 80		      ora	gameMode	; COLOR/B&W @start of level stored in gameMode -- so now we just detect a CHANGE is pause
    114  1b1d		       85 80		      sta	gameMode	; also, BIT7=0 -- system is NOT paused
    115  1b1f
    116  1b1f
    117  1b1f							; restart level
    118  1b1f		       a5 c8		      lda	NextLevelTrigger
    119  1b21		       29 bf		      and	#<(~BIT_NEXTLIFE)
    120  1b23		       85 c8		      sta	NextLevelTrigger
    121  1b25
    122  1b25							; if new high score was set by SwapPlayers, update it:
    123  1b25
    124  1b25		       4c 9c f5 	      jmp	WriteSaveKey
    125  1b28
    126  1b28
    127  1b28							;------------------------------------------------------------------------------
    128  1b28
      0  1b28					      DEFINE_SUBROUTINE	CreateCreatures
      1  1b28		       00 03	   BANK_CreateCreatures =	_CURRENT_BANK
      2  1b28					      SUBROUTINE
      3  1b28				   CreateCreatures
    130  1b28
    131  1b28							; Calculate rightmost value for scrolling edge.  .
    132  1b28
    133  1b28		       85 c2		      sta	ROM_Bank
    134  1b2a
    135  1b2a		       38		      sec
    136  1b2b		       a5 94		      lda	BoardLimit_Width
    137  1b2d		       e9 09		      sbc	#SCREEN_WIDTH-1
    138  1b2f		       85 94		      sta	BoardEdge_Right	; absolute rightmost scroll value
    139  1b31
    140  1b31							;		  sec			     already set
    141  1b31		       a5 95		      lda	BoardLimit_Height
    142  1b33		       e9 07		      sbc	#SCREEN_LINES-1
    143  1b35		       85 95		      sta	BoardEdge_Bottom	; absolute bottommost scroll value
    144  1b37
    145  1b37							; kludge position scroll roughly at player
    146  1b37
    147  1b37							;		  sec			 already set
    148  1b37		       a5 9b		      lda	ManX
    149  1b39		       e9 05		      sbc	#5
    150  1b3b		       b0 02		      bcs	notL0
    151  1b3d		       a9 00		      lda	#0
    152  1b3f		       85 97	   notL0      sta	BoardScrollX
    153  1b41
    154  1b41
    155  1b41		       38		      sec
    156  1b42		       a5 9c		      lda	ManY
    157  1b44		       e9 05		      sbc	#5	; TJ: why 5???
    158  1b46		       b0 02		      bcs	notU0
    159  1b48		       a9 00		      lda	#0
    160  1b4a		       85 96	   notU0      sta	BoardScrollY
    161  1b4c
    162  1b4c		       a9 00		      lda	#0
    163  1b4e		       85 9f		      sta	ManMode
    164  1b50		       85 a0		      sta	ManDelayCount
    165  1b52
    166  1b52		       a9 1a		      lda	#AnimateBLANK-Manimate	;0 ;<AnimateBLANK ;STAND
    167  1b54		       85 a1		      sta	ManAnimation
    168  1b56							;lda #>AnimateBLANK ;
    169  1b56							;sta ManAnimation+1
    170  1b56
    171  1b56		       a9 ff		      lda	#$FF
    172  1b58		       85 b0		      sta	LastSpriteY
    173  1b5a
    174  1b5a		       a9 07		      lda	#DIRECTION_BITS
    175  1b5c		       85 a4		      sta	ManLastDirection
    176  1b5e		       60		      rts
    177  1b5f
    178  1b5f							;-------------------------------------------------------------------------------------
    179  1b5f
      0  1b5f					      DEFINE_SUBROUTINE	LevelInit	; in GENERIC_BANK_1
      1  1b5f		       00 03	   BANK_LevelInit =	_CURRENT_BANK
      2  1b5f					      SUBROUTINE
      3  1b5f				   LevelInit
    181  1b5f
    182  1b5f		       a9 00		      lda	#0
    183  1b61		       85 86		      sta	ObjStackPtr
    184  1b63		       85 87		      sta	ObjStackPtr+1	; kill all creatures
    185  1b65		       85 85		      sta	ObjStackNum
    186  1b67		       85 cb		      sta	ObjIterator
    187  1b69
    188  1b69		       85 98		      sta	scrollBits
    189  1b6b		       85 89		      sta	ScreenDrawPhase
    190  1b6d
    191  1b6d		       85 b2		      sta	BGColour
    192  1b6f		       85 c4		      sta	ColourTimer
    193  1b71
    194  1b71		       85 59		      sta	AUDV0
    195  1b73		       85 5a		      sta	AUDV1	; turn off music while levels init
    196  1b75							;		  sta AUDC0
    197  1b75
    198  1b75		       85 a4		      sta	ManLastDirection
    199  1b77		       85 a5		      sta	ManPushCounter
    200  1b79
    201  1b79		       85 ca		      sta	sortPtr	; sort stopped
    202  1b7b		       a9 ff		      lda	#<(-1)
    203  1b7d		       85 c9		      sta	sortRequired	; nothing needed
    204  1b7f		       85 84		      sta	DrawStackPointer
    205  1b81
    206  1b81		       a9 02		      lda	#DISPLAY_LIVES
    207  1b83		       85 c7		      sta	scoringFlags
    208  1b85		       a9 96		      lda	#SCORING_TIMER_FIRST	; We want the first timer display to be long, to show level and lives
    209  1b87		       85 c6		      sta	scoringTimer
    210  1b89		       60		      rts
    211  1b8a
    212  1b8a							;-------------------------------------------------------------------------------------
    213  1b8a
      0  1b8a					      DEFINE_SUBROUTINE	Resync
      1  1b8a		       00 03	   BANK_Resync =	_CURRENT_BANK
      2  1b8a					      SUBROUTINE
      3  1b8a				   Resync
      0  1b8a					      RESYNC
      1  1b8a
      2  1b8a		       a9 02		      lda	#%10
      3  1b8c		       85 41		      sta	VBLANK
      4  1b8e
      5  1b8e		       a2 08		      ldx	#8
      6  1b90				   .loopResync
      0  1b90					      VERTICAL_SYNC
      1  1b90		       a9 0e		      lda	#%1110
      2  1b92		       85 42	   .VSLP1     sta	WSYNC
      3  1b94		       85 40		      sta	VSYNC
      4  1b96		       4a		      lsr
      5  1b97		       d0 f9		      bne	.VSLP1
      8  1b99
      9  1b99		       a0 88		      ldy	#SCANLINES_NTSC/2 - 2
     10  1b9b		       a5 81		      lda	Platform
     11  1b9d		       49 02		      eor	#PAL_50
     12  1b9f		       d0 02		      bne	.ntsc
     13  1ba1		       a0 9a		      ldy	#SCANLINES_PAL/2 - 2
     14  1ba3				   .ntsc
     15  1ba3				   .loopWait
     16  1ba3		       85 42		      sta	WSYNC
     17  1ba5		       85 42		      sta	WSYNC
     18  1ba7		       88		      dey
     19  1ba8		       d0 f9		      bne	.loopWait
     20  1baa		       ca		      dex
     21  1bab		       d0 e3		      bne	.loopResync
    216  1bad		       60	   Ret	      rts
    217  1bae
    218  1bae							;---------------------------------------------------------------------------
    219  1bae
      0  1bae					      DEFINE_SUBROUTINE	TrackPlayer	; =145; in GENERIC_BANK_1
      1  1bae		       00 03	   BANK_TrackPlayer =	_CURRENT_BANK
      2  1bae					      SUBROUTINE
      3  1bae				   TrackPlayer
    221  1bae
    222  1bae		       a5 a6		      lda	LookingAround	; 3
    223  1bb0		       30 fb		      bmi	Ret	; 2/3=5/6   don't track when looking around
    224  1bb2
    225  1bb2							; Contribution by Thomas Jentzsch
    226  1bb2
    227  1bb2							; scrolling constants:
    228  1bb2		       00 03	   .SCRL_START_LEFT =	3	; 3
    229  1bb2		       00 03	   .SCRL_STOP_LEFT =	3	;SCREEN_WIDTH-5		    ; 5 scrolls 5-3+1 = 3 pixel
    230  1bb2		       00 07	   .SCRL_START_RIGHT =	SCREEN_WIDTH-.SCRL_START_LEFT	; 7
    231  1bb2		       00 07	   .SCRL_STOP_RIGHT =	SCREEN_WIDTH-.SCRL_STOP_LEFT	; 5
    232  1bb2		       00 11	   .SCRL_LEFT_BIT =	%00010001
    233  1bb2		       00 22	   .SCRL_RIGHT_BIT =	%00100010
    234  1bb2		       00 33	   .SCRL_X_BITS =	.SCRL_LEFT_BIT|.SCRL_RIGHT_BIT
    235  1bb2
    236  1bb2		       00 02	   .SCRL_START_UP =	2	; 2
    237  1bb2		       00 02	   .SCRL_STOP_UP =	2	;SCREEN_LINES-5		    ; 3 scrolls 3-2+1 = 2 pixel
    238  1bb2		       00 06	   .SCRL_START_DOWN =	SCREEN_LINES-.SCRL_START_UP	; 6
    239  1bb2		       00 06	   .SCRL_STOP_DOWN =	SCREEN_LINES-.SCRL_STOP_UP	; 5
    240  1bb2		       00 44	   .SCRL_UP_BIT =	%01000100
    241  1bb2		       00 88	   .SCRL_DOWN_BIT =	%10001000
    242  1bb2		       00 cc	   .SCRL_Y_BITS =	.SCRL_UP_BIT|.SCRL_DOWN_BIT
    243  1bb2
    244  1bb2							; *** horizontal scrolling (unoptimized version): ***
    245  1bb2
    246  1bb2							; check for enabling horizontal scrolling:
    247  1bb2		       a5 9b		      lda	ManX	; 3
    248  1bb4		       38		      sec		; 2
    249  1bb5		       e5 97		      sbc	BoardScrollX	; 3
    250  1bb7		       a8		      tay		; 2	     for later use
    251  1bb8		       a9 11		      lda	#.SCRL_LEFT_BIT	; 2
    252  1bba		       c0 03		      cpy	#.SCRL_START_LEFT	; 2	     <3?
    253  1bbc		       30 06		      bmi	.startXScroll	; 2/3	     yes, scroll left
    254  1bbe		       c0 07		      cpy	#.SCRL_START_RIGHT	; 2	     <8?
    255  1bc0		       30 08		      bmi	.skipStartXScroll	; 2/3	     no
    256  1bc2		       a9 22		      lda	#.SCRL_RIGHT_BIT	; 2 = 22    yes, scroll right
    257  1bc4				   .startXScroll
    258  1bc4		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    259  1bc6		       05 98		      ora	scrollBits	; 3
    260  1bc8		       85 98		      sta	scrollBits	; 3 =	8
    261  1bca				   .skipStartXScroll
    262  1bca
    263  1bca							; do horizontal scrolling:
    264  1bca		       a5 98		      lda	scrollBits	; 3
    265  1bcc		       29 03		      and	#.SCRL_X_BITS >> 4	; 2
    266  1bce		       f0 23		      beq	.skipXScroll	; 2/3
    267  1bd0		       29 22		      and	#.SCRL_RIGHT_BIT	; 2
    268  1bd2		       d0 0c		      bne	.xScrollRight	; 2/3=11/12
    269  1bd4
    270  1bd4							; scroll left:
    271  1bd4		       a5 97		      lda	BoardScrollX	; 3	     already at left edge?
    272  1bd6		       f0 15		      beq	.stopXScroll	; 2
    273  1bd8		       c6 97		      dec	BoardScrollX	; 5
    274  1bda		       c0 02		      cpy	#.SCRL_STOP_LEFT-1	; 2
    275  1bdc		       10 0f		      bpl	.stopXScroll	; 2/3=15
    276  1bde		       30 13		      bmi	.skipXScroll	; 3
    277  1be0							;---------------------------------------
    278  1be0				   .xScrollRight
    279  1be0		       a6 97		      ldx	BoardScrollX	; 3
    280  1be2		       e8		      inx		; 2
    281  1be3		       e4 94		      cpx	BoardEdge_Right	; 3	     already at right edge?
    282  1be5		       10 06		      bpl	.stopXScroll	; 2/3
    283  1be7		       86 97		      stx	BoardScrollX	; 3
    284  1be9		       c0 08		      cpy	#.SCRL_STOP_RIGHT+1	; 2
    285  1beb		       10 06		      bpl	.skipXScroll	; 2/3=17/18
    286  1bed				   .stopXScroll
    287  1bed		       a5 98		      lda	scrollBits	; 3
    288  1bef		       29 fc		      and	#(~(.SCRL_X_BITS >> 4))	; 2
    289  1bf1		       85 98		      sta	scrollBits	; 3 =	8
    290  1bf3				   .skipXScroll
    291  1bf3							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    292  1bf3
    293  1bf3							; *** vertical scrolling (unoptimized version): ***
    294  1bf3
    295  1bf3							; check for enabling vertical scrolling:
    296  1bf3		       a5 9c		      lda	ManY	; 3
    297  1bf5		       38		      sec		; 2
    298  1bf6		       e5 96		      sbc	BoardScrollY	; 3
    299  1bf8		       a8		      tay		; 2	     for later use
    300  1bf9		       a9 44		      lda	#.SCRL_UP_BIT	; 2
    301  1bfb		       c0 02		      cpy	#.SCRL_START_UP	; 2	     <2?
    302  1bfd		       30 06		      bmi	.startYScroll	; 2/3	     yes, scroll up
    303  1bff		       c0 06		      cpy	#.SCRL_START_DOWN	; 2	     <6?
    304  1c01		       30 08		      bmi	.skipStartYScroll	; 2/3
    305  1c03		       a9 88		      lda	#.SCRL_DOWN_BIT	; 2 = 22    yes, scroll down
    306  1c05				   .startYScroll
    307  1c05		       29 0c		      and	#.SCRL_Y_BITS >> 4	; 2
    308  1c07		       05 98		      ora	scrollBits	; 3
    309  1c09		       85 98		      sta	scrollBits	; 3 =	8
    310  1c0b				   .skipStartYScroll
    311  1c0b
    312  1c0b							; do vertical scrolling:
    313  1c0b		       a5 98		      lda	scrollBits	; 3
    314  1c0d		       29 cc		      and	#.SCRL_Y_BITS	; 2
    315  1c0f		       f0 23		      beq	.skipYScroll	; 2/3
    316  1c11		       29 88		      and	#.SCRL_DOWN_BIT	; 2
    317  1c13		       d0 0c		      bne	.yScrollDown	; 2/3=11/12
    318  1c15
    319  1c15							; scroll up
    320  1c15		       a5 96		      lda	BoardScrollY	; 3
    321  1c17		       f0 15		      beq	.stopYScroll	; 2
    322  1c19		       c6 96		      dec	BoardScrollY	; 5
    323  1c1b		       c0 01		      cpy	#.SCRL_STOP_UP-1	; 2
    324  1c1d		       10 0f		      bpl	.stopYScroll	; 2/3=15
    325  1c1f		       30 13		      bmi	.skipYScroll	; 3
    326  1c21							;---------------------------------------
    327  1c21				   .yScrollDown
    328  1c21		       a6 96		      ldx	BoardScrollY	; 3
    329  1c23		       e8		      inx		; 2
    330  1c24		       e4 95		      cpx	BoardEdge_Bottom	;     ; 3
    331  1c26		       10 06		      bpl	.stopYScroll	; 2/3
    332  1c28		       86 96		      stx	BoardScrollY	; 3
    333  1c2a		       c0 07		      cpy	#.SCRL_STOP_DOWN+1	; 2
    334  1c2c		       10 06		      bpl	.skipYScroll	; 2/3=17/18
    335  1c2e				   .stopYScroll
    336  1c2e		       a5 98		      lda	scrollBits	; 3
    337  1c30		       29 f3		      and	#(~(.SCRL_Y_BITS >> 4))	; 2
    338  1c32		       85 98		      sta	scrollBits	; 3 =	8
    339  1c34				   .skipYScroll
    340  1c34							; worst case: 22 + 8 + 12 + 17 + 8 = 67
    341  1c34
    342  1c34		       60	   EarlyAbortx rts		; 6 =	6
    343  1c35							; total: 5+67*2+6 = 145
    344  1c35
    345  1c35							;------------------------------------------------------------------------------
    346  1c35
    347  1c35
    348  1c35
    349  1c35							; worst case time from positive last check to rts: 123
    350  1c35							; cycles until 0-check: 15
    351  1c35							; minimum cycles available after last positive check until timer turns 0: (MINIMUM_SORT_TIME-1)*64+1
    352  1c35							; MINIMUM_SORT_TIME = 3 = 129
    353  1c35							; MINIMUM_SORT_TIME = 4 = 193 <- ok
    354  1c35
    355  1c35							;------------------------------------------------------------------------------
    356  1c35
    357  1c35							; This is a GOOD home for these tables.
    358  1c35
      0  1c35					      DEFINE_SUBROUTINE	TS_PhaseVectorLO
      1  1c35		       00 03	   BANK_TS_PhaseVectorLO =	_CURRENT_BANK
      2  1c35					      SUBROUTINE
      3  1c35				   TS_PhaseVectorLO
    360  1c35
    361  1c35							; Gives LO byte of addresses of subroutines for timeslice processing
    362  1c35
    363  1c35		       53		      .byte.b	<ProcessObjStack
    364  1c36		       d8		      .byte.b	<DrawFullScreen
    365  1c37		       b4		      .byte.b	<BuildDrawStack
    366  1c38		       bb		      .byte.b	<DrawAIntoStack
    367  1c39		       96		      .byte.b	<SwitchObjects
    368  1c3a
    369  1c3a				   TS_PhaseVectorHI
    370  1c3a
    371  1c3a							; Gives HI byte of addresses of subroutines for timeslice processing
    372  1c3a
    373  1c3a		       f8		      .byte.b	>ProcessObjStack
    374  1c3b		       f2		      .byte.b	>DrawFullScreen
    375  1c3c		       fa		      .byte.b	>BuildDrawStack
    376  1c3d		       fa		      .byte.b	>DrawAIntoStack
    377  1c3e		       f8		      .byte.b	>SwitchObjects
    378  1c3f
    379  1c3f				   TS_PhaseBank
    380  1c3f
    381  1c3f							; Gives bank of subroutines for timeslice processing
    382  1c3f
    383  1c3f		       0f		      .byte.b	BANK_ProcessObjStack
    384  1c40		       05		      .byte.b	BANK_DrawFullScreen
    385  1c41		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack
    386  1c42		       08		      .byte.b	BANK_DRAW_BUFFERS	;BANK_BuildDrawStack2
    387  1c43		       0f		      .byte.b	BANK_SwitchObjects
    388  1c44
    389  1c44							;------------------------------------------------------------------------------
    390  1c44		       02 02	   lookColour2 .byte.b	$02, $02
    391  1c46		       04 04		      .byte.b	$04, $04
    392  1c48
    393  1c48				   OverscanTime
    394  1c48		       33 33		      .byte.b	OVERSCAN_TIM_NTSC, OVERSCAN_TIM_NTSC
    395  1c4a		       46 33		      .byte.b	OVERSCAN_TIM_PAL, OVERSCAN_TIM_NTSC
    396  1c4c
    397  1c4c
    398  1c4c
    399  1c4c
      0  1c4c					      DEFINE_SUBROUTINE	PostScreenCleanup
      1  1c4c		       00 03	   BANK_PostScreenCleanup =	_CURRENT_BANK
      2  1c4c					      SUBROUTINE
      3  1c4c				   PostScreenCleanup
    401  1c4c
    402  1c4c		       c8		      iny		; --> 0
    403  1c4d
    404  1c4d		       84 49		      sty	COLUBK	; starts colour change bottom score area, wraps to top score area
    405  1c4f							; + moved here so we don't see a minor colour artefact bottom of screen when look-arounding
    406  1c4f
    407  1c4f		       84 4d		      sty	PF0	; why wasn't this here?  I saw colour glitching in score area!
    408  1c51							; TJ: no idea why, but you had removed it in revision 758 ;)
    409  1c51							; completely accidental -- one of our cats may have deleted it.
    410  1c51		       84 4e		      sty	PF1
    411  1c53		       84 4f		      sty	PF2
    412  1c55		       84 5d		      sty	ENAM0
    413  1c57		       84 5b		      sty	GRP0	; when look-scrolling, we can see feet at the top if these aren't here
    414  1c59		       84 5c		      sty	GRP1	; 30/12/2011 -- fix dots @ top!
    415  1c5b
    416  1c5b
    417  1c5b
    418  1c5b							; D1 VBLANK turns off beam
    419  1c5b							; It needs to be turned on 37 scanlines later
    420  1c5b
    421  1c5b		       a9 42		      lda	#%01000010	; bit6 is not required
    422  1c5d		       85 41		      sta	VBLANK	; end of screen - enter blanking
    423  1c5f
    424  1c5f							;------------------------------------------------------------------------------
    425  1c5f							; This is where the PAL system has a bit of extra time on a per-frame basis.
    426  1c5f
    427  1c5f		       a6 81		      ldx	Platform
    428  1c61		       bd 48 f4 	      lda	OverscanTime,x
    429  1c64		       8d 96 02 	      sta	TIM64T
    430  1c67
    431  1c67							; Background colour priorities. Increasing order of priority...
    432  1c67							;	black -- nothing happening
    433  1c67							;	looking around			     lookingAround<0		     BLUE
    434  1c67							;	when paused			     gameMode... BIT7		     RED
    435  1c67							;	when the door opens (flash)	     ColourTimer>0		     WHITE
    436  1c67
    437  1c67
    438  1c67							;		  lda LookingAround
    439  1c67							;		  bpl nolooker			  ; if not looking around, that will do nicely
    440  1c67							;		  ldy #0 ;sok
    441  1c67							;;		   ldy lookColour2,x		   ; otherwise, use the lookaround colour as the base
    442  1c67							;nolooker	  sty BGColour			  ; 'BASE' colour pause reverts TO when unpaused
    443  1c67
    444  1c67		       a5 b7		      lda	ThrottleSpeed
    445  1c69		       18		      clc
    446  1c6a		       65 b6		      adc	Throttle
    447  1c6c		       b0 02		      bcs	noVerflo
    448  1c6e		       85 b6		      sta	Throttle
    449  1c70				   noVerflo
    450  1c70
    451  1c70
    452  1c70							;----------------------------------------------------------------------------------------------
    453  1c70							; handle pause button for 2600 and 7800
    454  1c70
    455  1c70							; Timings:  NOT including palette setting or platform detect
    456  1c70							; 2600:     no button press:	 11 cycles
    457  1c70							;	     with button press:  21 cycles
    458  1c70							; 7800      no button press:	 16 cycles
    459  1c70							;	     with button press:  21 cycles
    460  1c70
    461  1c70
    462  1c70
    463  1c70		       00 08	   BW_SWITCH  =	$08	; NOTE: Shares bit position with SWCHB COLOUR/B&W SWITCH
    464  1c70
    465  1c70		       24 80		      bit	gameMode
    466  1c72		       50 0b		      bvc	.pause7800	; 7800 platform
    467  1c74
    468  1c74							; 2600 pause logic...
    469  1c74
    470  1c74		       ad 82 02 	      lda	SWCHB
    471  1c77		       45 80		      eor	gameMode
    472  1c79		       29 08		      and	#BW_SWITCH
    473  1c7b		       f0 17		      beq	.setPauseCol	; no different to original state = no pause change
    474  1c7d		       d0 0f		      bne	.buttonDown	; unconditional
    475  1c7f
    476  1c7f							; 7800 pause logic...
    477  1c7f
    478  1c7f							; When the button is pressed, we check if it's the FIRST time it's pressed.
    479  1c7f							; This FIRST time is indicated by the PFLAG7800 being clear.  If it's the first time, we toggle the pause
    480  1c7f							; flag (BIT6) AND we toggle the PFLAG7800 so continued button-down does nothing.  When the button is
    481  1c7f							; released, then we again toggle the PFLAG7800, allowing a FIRST time check once again, when the button
    482  1c7f							; is next pressed.
    483  1c7f
    484  1c7f		       a9 08	   .pause7800 lda	#BW_SWITCH
    485  1c81		       2c 82 02 	      bit	SWCHB
    486  1c84		       f0 04		      beq	.pausePress
    487  1c86		       05 80		      ora	gameMode	; not pressed, so enable first time press
    488  1c88		       d0 08		      bne	.fixPause	; unconditional
    489  1c8a
    490  1c8a		       24 80	   .pausePress bit	gameMode
    491  1c8c		       f0 06		      beq	.setPauseCol	; NOT the first time in pause - so do nothing new
    492  1c8e
    493  1c8e							; Button is down, and we have detected it as a FIRST-TIME button press.
    494  1c8e
    495  1c8e		       45 80	   .buttonDown eor	gameMode	; toggle first time flag(7800) or current switch state(2600)
    496  1c90		       49 80		      eor	#GAMEMODE_PAUSED	; toggle pause flag
    497  1c92		       85 80	   .fixPause  sta	gameMode
    498  1c94
    499  1c94		       a5 80	   .setPauseCol lda	gameMode	; are we paused?
    500  1c96		       10 07		      bpl	.exitPause	; only show pause colour when actually paused
    501  1c98
    502  1c98		       a6 81		      ldx	Platform
    503  1c9a		       bd 07 f5 	      lda	pscol,x
    504  1c9d		       85 b2		      sta	BGColour	; set main screen background colour.  RED is paused.
    505  1c9f
    506  1c9f				   .exitPause
    507  1c9f
    508  1c9f							;----------------------------------------------------------------------------------------------
    509  1c9f
    510  1c9f							; has to be done AFTER screen display, because it disables the effect!
    511  1c9f		       a5 82		      lda	rnd	; 3	 randomly reposition the Cosmic Ark missile
    512  1ca1		       85 62		      sta	HMM0	; 3	 this assumes that HMOVE is called at least once/frame
    513  1ca3
    514  1ca3							; "Flash" has highest BG colour priority
    515  1ca3
    516  1ca3		       a6 c4		      ldx	ColourTimer
    517  1ca5		       f0 04		      beq	noFlashBG
    518  1ca7		       c6 c4		      dec	ColourTimer
    519  1ca9		       a2 0e		      ldx	#WHITE
    520  1cab		       86 b2	   noFlashBG  stx	BGColour
    521  1cad
    522  1cad							; Handle the player joystick reading. We do it *every frame* so that we can incorporate a two-frame
    523  1cad							; buffer.  This is designed to give a little better responsiveness to the 'quick tap' movement.
    524  1cad
    525  1cad		       a5 90		      lda	BufferedJoystick	; previous frame
    526  1caf		       85 91		      sta	BufferedJoystick+1	; -> buffered
    527  1cb1
    528  1cb1
    529  1cb1							; Create a 'standardised' joystick with D4-D7 having bits CLEAR if the appropriate direction is chosen.
    530  1cb1							; P2 is shifted UP, so we don't need to worry in usage elsewhere (it's same format as a P1 joystick)
    531  1cb1
    532  1cb1		       a5 99		      lda	whichPlayer	; 3
    533  1cb3		       25 a8		      and	jtoggle	; 3
    534  1cb5		       aa		      tax		; 2
    535  1cb6
    536  1cb6		       b5 4c		      lda	INPT4,x	; 4
    537  1cb8		       25 92		      and	BufferedButton
    538  1cba		       85 92		      sta	BufferedButton	; 3 = 15
    539  1cbc
    540  1cbc		       ad 80 02 	      lda	SWCHA	; 4
    541  1cbf
    542  1cbf		       ca		      dex		; 2
    543  1cc0		       30 04		      bmi	notP2	; 2/3= 8/9
    544  1cc2
    545  1cc2		       0a		      asl		; 2
    546  1cc3		       0a		      asl		; 2
    547  1cc4		       0a		      asl		; 2
    548  1cc5		       0a		      asl		; 2 =	8
    549  1cc6		       85 90	   notP2      sta	BufferedJoystick	; 3
    550  1cc8
    551  1cc8
    552  1cc8							; "Scoring timer" reset stomp comment
    553  1cc8
    554  1cc8		       a5 c6		      lda	scoringTimer
    555  1cca		       f0 0a		      beq	timer0now
    556  1ccc		       c6 c6		      dec	scoringTimer
    557  1cce		       d0 06		      bne	timer0now
    558  1cd0		       a5 c7		      lda	scoringFlags
    559  1cd2		       29 fc		      and	#<(~DISPLAY_FLAGS)	;	 switches to time display
    560  1cd4		       85 c7		      sta	scoringFlags
    561  1cd6				   timer0now
    562  1cd6
    563  1cd6							; fall through
    564  1cd6
    565  1cd6							;-------------------------------------------------------------------------------------
    566  1cd6							; Player animation happens *every* frame so that we get good animation speeds.  Note that
    567  1cd6							; the player animation consists of running a small animation 'program', and then actually drawing
    568  1cd6							; the player.	The draw is the neat bit, because all it does is update some self-modifying pointers
    569  1cd6							; inside the actual draw kernel in the appropriate bank.
    570  1cd6
    571  1cd6
      0  1cd6					      DEFINE_SUBROUTINE	AnimatePlayers	; in GENERIC_BANK_1
      1  1cd6		       00 03	   BANK_AnimatePlayers =	_CURRENT_BANK
      2  1cd6					      SUBROUTINE
      3  1cd6				   AnimatePlayers
    573  1cd6
    574  1cd6							; Optimised 7/1/2012 -- single page tables
    575  1cd6
    576  1cd6							; This interesting code performs the animations for the player(s) and sets the
    577  1cd6							; pointers INSIDE the row bank for the draw code to point to the correct player
    578  1cd6							; shape.  Kind of neat, as it doesn't require any shape copying (=speed!)
    579  1cd6
    580  1cd6
    581  1cd6							; Cycle the player through his animation list.  The animation of a player is a direct
    582  1cd6							; pointer to the actual shape used to display the player.  This shape is in turn
    583  1cd6							; written to the current bank's self-modifying locations for the draw.  Since
    584  1cd6							; we are effectively drawing from this current bank, the same code can be used
    585  1cd6							; to 'undraw' the player as required.
    586  1cd6
    587  1cd6
    588  1cd6							; x = player index
    589  1cd6							; sets ManAnimation = FRAME to display for player
    590  1cd6							; ManAnimation = index of player program into Manimate list
    591  1cd6
    592  1cd6		       24 80		      bit	gameMode
    593  1cd8		       30 2c		      bmi	AnimationOK	; don't animate during pause
    594  1cda
    595  1cda		       c6 a0		      dec	ManDelayCount
    596  1cdc		       10 28		      bpl	AnimationOK
    597  1cde
    598  1cde		       a4 a1	   ReloadAnimation ldy	ManAnimation
    599  1ce0		       b9 00 f6    ContinueAnim lda	Manimate,y	; delay count
    600  1ce3		       d0 07		      bne	NewFrameOK
    601  1ce5		       b9 01 f6 	      lda	Manimate+1,y
    602  1ce8		       a8		      tay
    603  1ce9		       4c e0 f4 	      jmp	ContinueAnim
    604  1cec
    605  1cec		       10 0d	   NewFrameOK bpl	doDelay
    606  1cee
    607  1cee		       c8		      iny		; handle a REFLECT
    608  1cef		       a5 a4		      lda	ManLastDirection
    609  1cf1		       29 f7		      and	#%11110111
    610  1cf3		       19 00 f6 	      ora	Manimate,y
    611  1cf6		       85 a4		      sta	ManLastDirection
    612  1cf8
    613  1cf8		       c8		      iny
    614  1cf9		       d0 e5		      bne	ContinueAnim
    615  1cfb
    616  1cfb		       85 a0	   doDelay    sta	ManDelayCount
    617  1cfd
    618  1cfd		       c8		      iny
    619  1cfe		       b9 00 f6 	      lda	Manimate,y
    620  1d01		       85 a3		      sta	ManAnimationFrameLO
    621  1d03
    622  1d03		       c8		      iny
    623  1d04		       84 a1		      sty	ManAnimation
    624  1d06
    625  1d06		       60	   AnimationOK rts
    626  1d07
    627  1d07
    628  1d07
    629  1d07		       40 40	   pscol      .byte.b	$40, $40
    630  1d09		       60 60		      .byte.b	$60, $60
    631  1d0b
    632  1d0b							;------------------------------------------------------------------------------
    633  1d0b
------- FILE i2c_v2.2.inc LEVEL 3 PASS 3
      0  1d0b					      include	"i2c_v2.2.inc"
      1  1d0b							;
      2  1d0b							; i2c_v2.2.inc
      3  1d0b							;
      4  1d0b							;
      5  1d0b							; AtariVox EEPROM Driver
      6  1d0b							;
      7  1d0b							; By Alex Herbert, 2004
      8  1d0b							;
      9  1d0b							; Optimisations by Thomas Jentzsch, 2006/2008
     10  1d0b							;
     11  1d0b
     12  1d0b
     13  1d0b							; I/O Constants
     14  1d0b
     15  1d0b		       00 04	   I2C_SDA_MASK equ	$04
     16  1d0b		       00 08	   I2C_SCL_MASK equ	$08
     17  1d0b
     18  1d0b
     19  1d0b							; Signalling Macros
     20  1d0b
     21  1d0b							;  MAC     I2C_SCL_0
     22  1d0b							;    lda     #$00
     23  1d0b							;    sta     SWCHA
     24  1d0b							;  ENDM
     25  1d0b
     26  1d0b							;  MAC     I2C_SCL_1
     27  1d0b							;    lda     #I2C_SCL_MASK
     28  1d0b							;    sta     SWCHA
     29  1d0b							;  ENDM
     30  1d0b
     31  1d0b							;  MAC     I2C_SDA_IN
     32  1d0b							;    lda     #I2C_SCL_MASK
     33  1d0b							;    sta     SWACNT
     34  1d0b							;  ENDM
     35  1d0b
     36  1d0b							;  MAC     I2C_SDA_OUT
     37  1d0b							;    lda     #I2C_SCL_MASK|I2C_SDA_MASK
     38  1d0b							;    sta     SWACNT
     39  1d0b							;  ENDM
     40  1d0b
     41  1d0b
     42  1d0b					      MAC	i2c_start
     43  1d0b							; I2C_SCL_1
     44  1d0b					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2	; 2	     I2C_SCL_MASK
     45  1d0b					      sta	SWCHA	; 4
     46  1d0b							; I2C_SDA_OUT
     47  1d0b					      lsr		; 2	     I2C_SCL_MASK|I2C_SDA_MASK
     48  1d0b					      sta	SWACNT	; 4
     49  1d0b							; total: 12 cycles
     50  1d0b					      ENDM
     51  1d0b
     52  1d0b
     53  1d0b					      MAC	i2c_txbit
     54  1d0b							; I2C_SCL_0
     55  1d0b					      lda	#%0011	; 2
     56  1d0b					      sta	SWCHA	; 4
     57  1d0b							; set bit
     58  1d0b					      adc	#%1000	; 2
     59  1d0b					      sta	SWACNT	; 4	     SDA = !C (a = %1000 / %1100)
     60  1d0b							; I2C_SCL_1
     61  1d0b					      lda	#I2C_SCL_MASK	; 2
     62  1d0b					      sta	SWCHA	; 4
     63  1d0b							; total: 18 cycles
     64  1d0b					      ENDM
     65  1d0b
     66  1d0b
     67  1d0b					      MAC	i2c_txnack
     68  1d0b							; I2C_SCL_0
     69  1d0b					      lda	#I2C_SCL_MASK*2	; 2	     $00
     70  1d0b					      sta	SWCHA	; 4
     71  1d0b							; I2C_SDA_IN
     72  1d0b					      lsr		; 2	     I2C_SCL_MASK
     73  1d0b					      sta	SWACNT	; 4
     74  1d0b							; I2C_SCL_1
     75  1d0b					      nop		; 2	     required for timing!
     76  1d0b					      sta	SWCHA	; 4	     I2C_SCL_MASK
     77  1d0b							; total: 18 cycles
     78  1d0b					      ENDM
     79  1d0b
     80  1d0b
     81  1d0b							; Subroutine Macros
     82  1d0b
     83  1d0b					      MAC	i2c_subs
     84  1d0b
     85  1d0b				   i2c_startread
     86  1d0b							; use V to flag if previous byte needs ACK
     87  1d0b					      ldy	#%10100001	; 2	     eeprom read command
     88  1d0b					      .byte	$2c	; 2
     89  1d0b				   i2c_startwrite
     90  1d0b					      ldy	#%10100000	; 2	     eeprom write command
     91  1d0b					      I2C_START		;12	     start signal (clears V flag)
     92  1d0b					      tya		; 2 = 16
     93  1d0b				   i2c_txbyte
     94  1d0b					      eor	#$ff	; 2	     invert data byte
     95  1d0b					      sec		; 2
     96  1d0b					      rol		; 2 =	6    shift loop bit into a
     97  1d0b				   i2c_txbyteloop
     98  1d0b					      tay		; 2
     99  1d0b					      I2C_TXBIT		;18	     transmit
    100  1d0b					      tya		; 2
    101  1d0b					      asl		; 2	     shift next bit into C
    102  1d0b					      bne	i2c_txbyteloop	; 2= 26/27
    103  1d0b
    104  1d0b							; receive acknowledge bit
    105  1d0b
    106  1d0b					      beq	i2c_rxbit	;43 = 43
    107  1d0b							; i2c_txbyte: 264 cycles
    108  1d0b							;-------------------------------------------------------------------------------
    109  1d0b
    110  1d0b				   i2c_rxbyte
    111  1d0b					      bvc	i2c_rxskipack	; 2	     previous byte needs acknowledge?
    112  1d0b					      jsr	i2c_txack	;24	     transmit acknowledge bit
    113  1d0b
    114  1d0b				   i2c_rxskipack
    115  1d0b					      bit	i2c_rxbyte	; 4	     set V - next byte(s) require acknowledge
    116  1d0b
    117  1d0b					      lda	#1	; 2
    118  1d0b				   i2c_rxbyteloop
    119  1d0b					      tay		; 2 =	2
    120  1d0b				   i2c_rxbit		;	     receive bit in C
    121  1d0b					      I2C_TXNACK		;18 = 18
    122  1d0b
    123  1d0b					      lda	SWCHA	; 4
    124  1d0b					      lsr		; 2
    125  1d0b					      lsr		; 2
    126  1d0b					      lsr		; 2 = 10    C = SDA
    127  1d0b
    128  1d0b					      tya		; 2
    129  1d0b					      rol		; 2	     rotate into Y
    130  1d0b					      bcc	i2c_rxbyteloop	; 2=	6/7
    131  1d0b
    132  1d0b							; received byte in A
    133  1d0b					      rts		; 6 =	6
    134  1d0b							; i2c_rxbit:  40 cycles
    135  1d0b							; i2c_rxbyte: 310/333 cycles
    136  1d0b							;-------------------------------------------------------------------------------
    137  1d0b
    138  1d0b				   i2c_stopread
    139  1d0b					      bvc	i2c_stopwrite	; 2
    140  1d0b					      ldy	#$80	; 2
    141  1d0b					      jsr	i2c_rxbit	;46	     transmit no-acknowledge
    142  1d0b
    143  1d0b				   i2c_stopwrite
    144  1d0b					      jsr	i2c_txack	;30
    145  1d0b
    146  1d0b							; return port to input mode
    147  1d0b					      lda	#0	; 2	     0
    148  1d0b					      sta	SWACNT	; 4
    149  1d0b					      rts		; 6 = 12
    150  1d0b							; i2c_stopread:  45/92
    151  1d0b							; i2c_stopwrite: 42
    152  1d0b							;-------------------------------------------------------------------------------
    153  1d0b
    154  1d0b				   i2c_txack
    155  1d0b							; I2C_SCL_0
    156  1d0b					      lda	#0	; 2	     $00
    157  1d0b					      sta	SWCHA	; 4
    158  1d0b							; I2C_SDA_OUT
    159  1d0b					      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)	; 2	     I2C_SCL_MASK|I2C_SDA_MASK
    160  1d0b					      sta	SWACNT	; 4
    161  1d0b							; I2C_SCL_1
    162  1d0b					      asl		; 2	     I2C_SCL_MASK
    163  1d0b					      sta	SWCHA	; 4
    164  1d0b
    165  1d0b					      rts		; 6
    166  1d0b							; total: 24 cycles
    167  1d0b							;-------------------------------------------------------------------------------
    168  1d0b
    169  1d0b					      ENDM
    170  1d0b
    171  1d0b
    172  1d0b
------- FILE BANK_GENERIC.asm
    635  1d0b
      0  1d0b					      i2c_subs
      1  1d0b
      2  1d0b				   i2c_startread
      3  1d0b
      4  1d0b		       a0 a1		      ldy	#%10100001
      5  1d0d		       2c		      .byte.b	$2c
      6  1d0e				   i2c_startwrite
      7  1d0e		       a0 a0		      ldy	#%10100000
      0  1d10					      I2C_START
      1  1d10
      2  1d10		       a9 18		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)*2
      3  1d12		       8d 80 02 	      sta	SWCHA
      4  1d15
      5  1d15		       4a		      lsr
      6  1d16		       8d 81 02 	      sta	SWACNT
      7  1d19
      9  1d19		       98		      tya
     10  1d1a				   i2c_txbyte
     11  1d1a		       49 ff		      eor	#$ff
     12  1d1c		       38		      sec
     13  1d1d		       2a		      rol
     14  1d1e				   i2c_txbyteloop
     15  1d1e		       a8		      tay
      0  1d1f					      I2C_TXBIT
      1  1d1f
      2  1d1f		       a9 03		      lda	#%0011
      3  1d21		       8d 80 02 	      sta	SWCHA
      4  1d24
      5  1d24		       69 08		      adc	#%1000
      6  1d26		       8d 81 02 	      sta	SWACNT
      7  1d29
      8  1d29		       a9 08		      lda	#I2C_SCL_MASK
      9  1d2b		       8d 80 02 	      sta	SWCHA
     10  1d2e
     17  1d2e		       98		      tya
     18  1d2f		       0a		      asl
     19  1d30		       d0 ec		      bne	i2c_txbyteloop
     20  1d32
     21  1d32
     22  1d32
     23  1d32		       f0 0b		      beq	i2c_rxbit
     24  1d34
     25  1d34
     26  1d34
     27  1d34				   i2c_rxbyte
     28  1d34		       50 03		      bvc	i2c_rxskipack
     29  1d36		       20 67 f5 	      jsr	i2c_txack
     30  1d39
     31  1d39				   i2c_rxskipack
     32  1d39		       2c 34 f5 	      bit	i2c_rxbyte
     33  1d3c
     34  1d3c		       a9 01		      lda	#1
     35  1d3e				   i2c_rxbyteloop
     36  1d3e		       a8		      tay
     37  1d3f				   i2c_rxbit
      0  1d3f					      I2C_TXNACK
      1  1d3f
      2  1d3f		       a9 10		      lda	#I2C_SCL_MASK*2
      3  1d41		       8d 80 02 	      sta	SWCHA
      4  1d44
      5  1d44		       4a		      lsr
      6  1d45		       8d 81 02 	      sta	SWACNT
      7  1d48
      8  1d48		       ea		      nop
      9  1d49		       8d 80 02 	      sta	SWCHA
     10  1d4c
     39  1d4c
     40  1d4c		       ad 80 02 	      lda	SWCHA
     41  1d4f		       4a		      lsr
     42  1d50		       4a		      lsr
     43  1d51		       4a		      lsr
     44  1d52
     45  1d52		       98		      tya
     46  1d53		       2a		      rol
     47  1d54		       90 e8		      bcc	i2c_rxbyteloop
     48  1d56
     49  1d56
     50  1d56		       60		      rts
     51  1d57
     52  1d57
     53  1d57
     54  1d57
     55  1d57				   i2c_stopread
     56  1d57		       50 05		      bvc	i2c_stopwrite
     57  1d59		       a0 80		      ldy	#$80
     58  1d5b		       20 3f f5 	      jsr	i2c_rxbit
     59  1d5e
     60  1d5e				   i2c_stopwrite
     61  1d5e		       20 67 f5 	      jsr	i2c_txack
     62  1d61
     63  1d61
     64  1d61		       a9 00		      lda	#0
     65  1d63		       8d 81 02 	      sta	SWACNT
     66  1d66		       60		      rts
     67  1d67
     68  1d67
     69  1d67
     70  1d67
     71  1d67				   i2c_txack
     72  1d67
     73  1d67		       a9 00		      lda	#0
     74  1d69		       8d 80 02 	      sta	SWCHA
     75  1d6c
     76  1d6c		       a9 0c		      lda	#(I2C_SCL_MASK|I2C_SDA_MASK)
     77  1d6e		       8d 81 02 	      sta	SWACNT
     78  1d71
     79  1d71		       0a		      asl
     80  1d72		       8d 80 02 	      sta	SWCHA
     81  1d75
     82  1d75		       60		      rts
     83  1d76
     84  1d76
     85  1d76
    637  1d76
    638  1d76				   HandleSaveKey SUBROUTINE
    639  1d76
    640  1d76		       2f 00	   SAVEKEY_ADR =	$2F00	;	     tentative address for Sokoban (64 bytes)
    641  1d76
    642  1d76							;------------------------------------------------------------------------------
      0  1d76					      DEFINE_SUBROUTINE	ReadSaveKey	; = 2371
      1  1d76		       00 03	   BANK_ReadSaveKey =	_CURRENT_BANK
      2  1d76					      SUBROUTINE
      3  1d76				   ReadSaveKey
    644  1d76
    645  1d76							; assume no SaveKey found:
    646  1d76		       a9 ff		      lda	#$ff	; 2	     return $ff if no SaveKey found
    647  1d78		       85 dd		      sta	highScoreSK+2	; 3
    648  1d7a
    649  1d7a							; setup SaveKey:
    650  1d7a		       a5 de		      lda	startingLevel	; 3	     load start levelX*5 and level
    651  1d7c		       a6 b4		      ldx	level	; 3
    652  1d7e		       20 b7 f5 	      jsr	SetupSaveKey	;6+853
    653  1d81		       90 52		      bcc	NoSKfound	; 2/3
    654  1d83
    655  1d83							;    lda     #$34
    656  1d83							;    sta     COLUBK
    657  1d83
    658  1d83							; start read
    659  1d83		       20 5e f5 	      jsr	i2c_stopwrite	;6+42	     end of "fake" write
    660  1d86		       20 0b f5 	      jsr	i2c_startread	;6+284      Start signal and $a1 command byte
    661  1d89
    662  1d89							; read high score:
    663  1d89		       a2 02		      ldx	#3-1	; 2 = 1187
    664  1d8b				   .loopRead
    665  1d8b		       20 34 f5 	      jsr	i2c_rxbyte	;6+333      read byte from EEPROM
    666  1d8e		       c9 ff		      cmp	#$ff	; 2	     EEPROM slot empty?
    667  1d90		       d0 02		      bne	.skipEmpty	; 2/3	      no, skip clear
    668  1d92		       a9 00		      lda	#0	; 2	     clear EEPROM slot
    669  1d94				   .skipEmpty
    670  1d94		       95 db		      sta	highScoreSK,x	; 4
    671  1d96		       ca		      dex		; 2
    672  1d97		       10 f2		      bpl	.loopRead	; 2/3= 354
    673  1d99
    674  1d99							; stop read:
    675  1d99		       4c 57 f5 	      jmp	i2c_stopread	;3+92=95    terminate read
    676  1d9c
    677  1d9c							;------------------------------------------------------------------------------
      0  1d9c					      DEFINE_SUBROUTINE	WriteSaveKey	; = 1751
      1  1d9c		       00 03	   BANK_WriteSaveKey =	_CURRENT_BANK
      2  1d9c					      SUBROUTINE
      3  1d9c				   WriteSaveKey
    679  1d9c
    680  1d9c							; check if new high score:
    681  1d9c		       a6 db		      ldx	highScoreSK	; 3
    682  1d9e		       e8		      inx		; 2
    683  1d9f		       f0 34		      beq	NoSKfound	; 2/3	     no new high score, abort
    684  1da1
    685  1da1							; setup SaveKey:
    686  1da1		       a5 de		      lda	startingLevel	; 3	     load start levelX*5 and level
    687  1da3		       a6 df		      ldx	startLevel	; 3
    688  1da5		       20 b7 f5 	      jsr	SetupSaveKey	; 6+853
    689  1da8		       90 2b		      bcc	NoSKfound	; 2/3
    690  1daa
    691  1daa							;    lda     #$64
    692  1daa							;    sta     COLUBK
    693  1daa
    694  1daa							; write high score:
    695  1daa		       a2 02		      ldx	#3-1	; 2 = 841
    696  1dac				   .loopWrite
    697  1dac		       b5 db		      lda	highScoreSK,x	; 4
    698  1dae		       20 1a f5 	      jsr	i2c_txbyte	;6+264      transmit to EEPROM
    699  1db1		       ca		      dex		; 2
    700  1db2		       10 f8		      bpl	.loopWrite	; 2/3= 837
    701  1db4
    702  1db4							; stop write:
    703  1db4		       4c 5e f5 	      jmp	i2c_stopwrite	; 3+42= 45  terminate write and commit to memory
    704  1db7
    705  1db7
    706  1db7							;------------------------------------------------------------------------------
      0  1db7					      DEFINE_SUBROUTINE	SetupSaveKey	; = 853
      1  1db7		       00 03	   BANK_SetupSaveKey =	_CURRENT_BANK
      2  1db7					      SUBROUTINE
      3  1db7				   SetupSaveKey
    708  1db7
    709  1db7							; calculate slot;
    710  1db7							; a = levelX
    711  1db7							; x = level (0..4)
    712  1db7		       85 e0		      sta	offsetSK	; 3
    713  1db9		       8a		      txa		; 2
    714  1dba		       18		      clc		; 2
    715  1dbb		       65 e0		      adc	offsetSK	; 3
    716  1dbd		       85 e0		      sta	offsetSK	; 3
    717  1dbf		       0a		      asl		; 2	     multiply by 3
    718  1dc0		       65 e0		      adc	offsetSK	; 3
    719  1dc2		       69 00		      adc	#<SAVEKEY_ADR	; 2
    720  1dc4		       aa		      tax		; 2 = 22
    721  1dc5							; detect SaveKey:
    722  1dc5		       20 0e f5 	      jsr	i2c_startwrite	;6+280
    723  1dc8		       d0 0a		      bne	.exitSK	; 2/3
    724  1dca
    725  1dca							; setup address:
    726  1dca		       b8		      clv		; 2
    727  1dcb		       a9 2f		      lda	#>SAVEKEY_ADR	; 2	     upper byte of address
    728  1dcd		       20 1a f5 	      jsr	i2c_txbyte	;6+264
    729  1dd0		       8a		      txa		; 2	     x = lower byte offset
    730  1dd1		       4c 1a f5 	      jmp	i2c_txbyte	;3+264      returns C==1
    731  1dd4
    732  1dd4				   .exitSK
    733  1dd4		       18		      clc
    734  1dd5				   NoSKfound
    735  1dd5		       60		      rts
    736  1dd5					      ENDIF
    737  1dd6
    738  1e00		       00 00 00 00*	      align	256
    739  1e00
    740  1e00				   Manimate
    741  1e00				   AnimateSTAND
    742  1e00				   AnimateRIGHT
    743  1e00				   AnimateLEFT
    744  1e00				   AnimateUP
    745  1e00				   AnimateSTOPPED
    746  1e00		       7f		      .byte.b	127
    747  1e01		       1a		      .byte.b	<PLAYER_RIGHT0	;PLAYER_STAND
    748  1e02							;.byte 10
    749  1e02							;.byte < PLAYER_BLINK
    750  1e02							;.byte 127
    751  1e02							;.byte < PLAYER_STAND
    752  1e02							;.byte 0
    753  1e02							;.word AnimateTAP
    754  1e02
    755  1e02				   AnimateTAP
    756  1e02							;.byte 128, %0 		  ; reflect off, always tap with left foot
    757  1e02							;.byte 8
    758  1e02							;.byte < PLAYER_TAP0
    759  1e02							;.byte 8
    760  1e02							;.byte < PLAYER_TAP1
    761  1e02							;.byte 8
    762  1e02							;.byte < PLAYER_TAP0
    763  1e02							;.byte 8
    764  1e02							;.byte < PLAYER_TAP1
    765  1e02							;.byte 8
    766  1e02							;.byte < PLAYER_TAP0
    767  1e02							;.byte 8
    768  1e02							;.byte < PLAYER_TAP1
    769  1e02		       00		      .byte.b	0
    770  1e03		       00		      .byte.b	AnimateSTAND-Manimate	;word AnimateSTAND
    771  1e04
    772  1e04							;AnimateRIGHT
    773  1e04		       80 00		      .byte.b	128, %0	; reflect off
    774  1e06		       05		      .byte.b	5
    775  1e07		       1a		      .byte.b	< PLAYER_RIGHT0
    776  1e08		       05		      .byte.b	5
    777  1e09		       2f		      .byte.b	< PLAYER_RIGHT1
    778  1e0a		       00		      .byte.b	0
    779  1e0b		       00		      .byte.b	AnimateRIGHT-Manimate	;word AnimateRIGHT
    780  1e0c
    781  1e0c							;AnimateLEFT
    782  1e0c		       80 08		      .byte.b	128, %1000	; reflect ON
    783  1e0e		       05		      .byte.b	5
    784  1e0f		       1a		      .byte.b	< PLAYER_RIGHT0
    785  1e10		       05		      .byte.b	5
    786  1e11		       2f		      .byte.b	< PLAYER_RIGHT1
    787  1e12		       00		      .byte.b	0
    788  1e13		       00		      .byte.b	AnimateLEFT-Manimate	;word AnimateLEFT
    789  1e14
    790  1e14							;AnimateUP
    791  1e14							;    .byte 128, %0		   ; reflect off
    792  1e14							;    .byte 5
    793  1e14							;    .byte < PLAYER_TAP
    794  1e14							;    .byte 128, %1000
    795  1e14							;    .byte 5
    796  1e14							;    .byte < PLAYER_TAP
    797  1e14							;    .byte 0
    798  1e14							;    .word AnimateUP
    799  1e14
    800  1e14							;AnimateUP
    801  1e14		       05		      .byte.b	5
    802  1e15		       1a		      .byte.b	< PLAYER_RIGHT0
    803  1e16		       05		      .byte.b	5
    804  1e17		       2f		      .byte.b	< PLAYER_RIGHT1
    805  1e18		       00		      .byte.b	0
    806  1e19		       00		      .byte.b	AnimateUP-Manimate	;word AnimateUP
    807  1e1a
    808  1e1a				   AnimateBLANK
    809  1e1a		       7f		      .byte.b	127
    810  1e1b		       05		      .byte.b	< PLAYER_BLANK
    811  1e1c		       00		      .byte.b	0
    812  1e1d		       1a		      .byte.b	AnimateBLANK-Manimate	;word AnimateBLANK
    813  1e1e
    814  1e1e				   AnimateEND
      0  1e1e					      CHECKPAGEX	Manimate, "AnimateEND @ BANK_GENERIC"
      9  1e1e					      LIST	ON
    816  1e1e
    817  1e1e
      0  1e1e					      CHECK_BANK_SIZE	"GENERIC_BANK_1 -- full 2K"
      1  1e1e		       06 1e	   .TEMP      =	* - BANK_START
 GENERIC_BANK_1 -- full 2K (2K) SIZE =  $61e , FREE= $1e2
      2  1e1e					      ECHO	"GENERIC_BANK_1 -- full 2K", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  1e1e				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  1e1e				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  1e1e				  -	      ERR
      6  1e1e					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_LEVELS.asm LEVEL 2 PASS 3
      0  1e1e					      include	"BANK_LEVELS.asm"
      0  1e1e					      NEWBANK	LEVELS
      1  2564 ????				      SEG	LEVELS
      2  2000					      ORG	ORIGIN
      3  2000					      RORG	$F000
      4  2000				   BANK_START SET	*
      5  2000				   LEVELS     SET	ORIGIN / 2048
      6  2000				   ORIGIN     SET	ORIGIN + 2048
      7  2000				   _CURRENT_BANK SET	LEVELS
      2  2000
      3  2000					      MAC	defl
      4  2000					      START_LEVEL	{1}
      5  2000					      .byte	{2},0
      6  2000					      END_LEVEL	{1}
      7  2000					      ENDM
      8  2000
      9  2000
     10  2000							; "SOKWHOLE" collection...
     11  2000
      0  2000					      DEFL	_001_L, "3#|#@#|#$#|#.#|3#"
      0  2000					      START_LEVEL	_001_L
      1  2000				   LEVEL_START SET	*
      2  2000		       00 04	   BANK_LEVEL__001_L =	_CURRENT_BANK
      3  2000				   LEVEL__001_L SUBROUTINE
      4  2000				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2000
      2  2000		       33 23 7c 23*	      .byte.b	"3#|#@#|#$#|#.#|3#",0
      0  2012					      END_LEVEL	_001_L
      1  2012		       00		      .byte.b	0
      2  2012		       00 13	   LEVEL_SIZE__001_L =	* - LEVEL_START
      3  2013				  -	      IF	LEVEL_SIZE__001_L > MAX_LEVEL_SIZE
      4  2013				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__001_L
      5  2013					      ENDIF
      0  2013					      DEFL	_002_L, "3#2-|#.3#|#*$-#|#2-@#|5#"
      0  2013					      START_LEVEL	_002_L
      1  2013				   LEVEL_START SET	*
      2  2013		       00 04	   BANK_LEVEL__002_L =	_CURRENT_BANK
      3  2013				   LEVEL__002_L SUBROUTINE
      4  2013				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2013
      2  2013		       33 23 32 2d*	      .byte.b	"3#2-|#.3#|#*$-#|#2-@#|5#",0
      0  202c					      END_LEVEL	_002_L
      1  202c		       00		      .byte.b	0
      2  202c		       00 1a	   LEVEL_SIZE__002_L =	* - LEVEL_START
      3  202d				  -	      IF	LEVEL_SIZE__002_L > MAX_LEVEL_SIZE
      4  202d				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__002_L
      5  202d					      ENDIF
      0  202d					      DEFL	_003_L, "4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-"
      0  202d					      START_LEVEL	_003_L
      1  202d				   LEVEL_START SET	*
      2  202d		       00 04	   BANK_LEVEL__003_L =	_CURRENT_BANK
      3  202d				   LEVEL__003_L SUBROUTINE
      4  202d				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  202d
      2  202d		       34 2d 35 23*	      .byte.b	"4-5#|2-3#3-#|3#.*-#-#|#@$.$#2-#|2#5-2#|-7#-",0
      0  2059					      END_LEVEL	_003_L
      1  2059		       00		      .byte.b	0
      2  2059		       00 2d	   LEVEL_SIZE__003_L =	* - LEVEL_START
      3  205a				  -	      IF	LEVEL_SIZE__003_L > MAX_LEVEL_SIZE
      4  205a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_L
      5  205a					      ENDIF
      0  205a					      DEFL	_003_R, "9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-"
      0  205a					      START_LEVEL	_003_R
      1  205a				   LEVEL_START SET	*
      2  205a		       00 04	   BANK_LEVEL__003_R =	_CURRENT_BANK
      3  205a				   LEVEL__003_R SUBROUTINE
      4  205a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  205a
      2  205a		       39 23 7c 23*	      .byte.b	"9#|#7-#|#-*2.2#-#|2#$#$#2-#|-#-@3-2#|-7#-",0
      0  2084					      END_LEVEL	_003_R
      1  2084		       00		      .byte.b	0
      2  2084		       00 2b	   LEVEL_SIZE__003_R =	* - LEVEL_START
      3  2085				  -	      IF	LEVEL_SIZE__003_R > MAX_LEVEL_SIZE
      4  2085				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__003_R
      5  2085					      ENDIF
      0  2085					      DEFL	_004_L, "5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-"
      0  2085					      START_LEVEL	_004_L
      1  2085				   LEVEL_START SET	*
      2  2085		       00 04	   BANK_LEVEL__004_L =	_CURRENT_BANK
      3  2085				   LEVEL__004_L SUBROUTINE
      4  2085				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2085
      2  2085		       35 23 2d 7c*	      .byte.b	"5#-|#3-2#|#-.*-#|#2-$@#|#2-3#|4#2-",0
      0  20a8					      END_LEVEL	_004_L
      1  20a8		       00		      .byte.b	0
      2  20a8		       00 24	   LEVEL_SIZE__004_L =	* - LEVEL_START
      3  20a9				  -	      IF	LEVEL_SIZE__004_L > MAX_LEVEL_SIZE
      4  20a9				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_L
      5  20a9					      ENDIF
      0  20a9					      DEFL	_004_R, "-6#|-#4-#|2#-$*$#|#@$3.#|7#"
      0  20a9					      START_LEVEL	_004_R
      1  20a9				   LEVEL_START SET	*
      2  20a9		       00 04	   BANK_LEVEL__004_R =	_CURRENT_BANK
      3  20a9				   LEVEL__004_R SUBROUTINE
      4  20a9				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20a9
      2  20a9		       2d 36 23 7c*	      .byte.b	"-6#|-#4-#|2#-$*$#|#@$3.#|7#",0
      0  20c5					      END_LEVEL	_004_R
      1  20c5		       00		      .byte.b	0
      2  20c5		       00 1d	   LEVEL_SIZE__004_R =	* - LEVEL_START
      3  20c6				  -	      IF	LEVEL_SIZE__004_R > MAX_LEVEL_SIZE
      4  20c6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__004_R
      5  20c6					      ENDIF
      0  20c6					      DEFL	_010_L, "2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-"
      0  20c6					      START_LEVEL	_010_L
      1  20c6				   LEVEL_START SET	*
      2  20c6		       00 04	   BANK_LEVEL__010_L =	_CURRENT_BANK
      3  20c6				   LEVEL__010_L SUBROUTINE
      4  20c6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  20c6
      2  20c6		       32 2d 33 23*	      .byte.b	"2-3#-|2-#@#-|3#$#-|#2-.2#|#-$2.#|#-$.$#|#-$.-#|#-$.2#|5#-",0
      0  2100					      END_LEVEL	_010_L
      1  2100		       00		      .byte.b	0
      2  2100		       00 3b	   LEVEL_SIZE__010_L =	* - LEVEL_START
      3  2101				  -	      IF	LEVEL_SIZE__010_L > MAX_LEVEL_SIZE
      4  2101				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_L
      5  2101					      ENDIF
      0  2101					      DEFL	_010_R, "4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-"
      0  2101					      START_LEVEL	_010_R
      1  2101				   LEVEL_START SET	*
      2  2101		       00 04	   BANK_LEVEL__010_R =	_CURRENT_BANK
      3  2101				   LEVEL__010_R SUBROUTINE
      4  2101				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2101
      2  2101		       34 23 32 2d*	      .byte.b	"4#2-|#2-#2-|#-$3#|#-$2.#|#2-*-#|#-$*-#|2#-+2#|-4#-",0
      0  2134					      END_LEVEL	_010_R
      1  2134		       00		      .byte.b	0
      2  2134		       00 34	   LEVEL_SIZE__010_R =	* - LEVEL_START
      3  2135				  -	      IF	LEVEL_SIZE__010_R > MAX_LEVEL_SIZE
      4  2135				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__010_R
      5  2135					      ENDIF
      0  2135					      DEFL	_011_L, "-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-"
      0  2135					      START_LEVEL	_011_L
      1  2135				   LEVEL_START SET	*
      2  2135		       00 04	   BANK_LEVEL__011_L =	_CURRENT_BANK
      3  2135				   LEVEL__011_L SUBROUTINE
      4  2135				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2135
      2  2135		       2d 34 23 32*	      .byte.b	"-4#2-|-#2.3#|2#$*2.#|#@$-$-#|2#-$2-#|-2#2-2#|2-4#-",0
      0  2168					      END_LEVEL	_011_L
      1  2168		       00		      .byte.b	0
      2  2168		       00 34	   LEVEL_SIZE__011_L =	* - LEVEL_START
      3  2169				  -	      IF	LEVEL_SIZE__011_L > MAX_LEVEL_SIZE
      4  2169				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__011_L
      5  2169					      ENDIF
      0  2169					      DEFL	_064_L, "-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-"
      0  2169					      START_LEVEL	_064_L
      1  2169				   LEVEL_START SET	*
      2  2169		       00 04	   BANK_LEVEL__064_L =	_CURRENT_BANK
      3  2169				   LEVEL__064_L SUBROUTINE
      4  2169				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2169
      2  2169		       2d 38 23 33*	      .byte.b	"-8#3-|2#2-2#2-#3-|#3-2#2-#3-|#-@-$.$.#3-|3#-$*2.4#|2-#$-#*.3-#|2-#2-$-.-$-#|2-#2-7#|2-4#6-",0
      0  21c4					      END_LEVEL	_064_L
      1  21c4		       00		      .byte.b	0
      2  21c4		       00 5c	   LEVEL_SIZE__064_L =	* - LEVEL_START
      3  21c5				  -	      IF	LEVEL_SIZE__064_L > MAX_LEVEL_SIZE
      4  21c5				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_L
      5  21c5					      ENDIF
      0  21c5					      DEFL	_064_R, "4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-"
      0  21c5					      START_LEVEL	_064_R
      1  21c5				   LEVEL_START SET	*
      2  21c5		       00 04	   BANK_LEVEL__064_R =	_CURRENT_BANK
      3  21c5				   LEVEL__064_R SUBROUTINE
      4  21c5				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  21c5
      2  21c5		       34 23 2d 36*	      .byte.b	"4#-6#|#2-#-#4-#|#2-3#4-#|#-$*-$-$-2#|#2-3.-#-#-|3#2.#3$#-|2-2#2.-$@#-|3-7#-",0
      0  2211					      END_LEVEL	_064_R
      1  2211		       00		      .byte.b	0
      2  2211		       00 4d	   LEVEL_SIZE__064_R =	* - LEVEL_START
      3  2212				  -	      IF	LEVEL_SIZE__064_R > MAX_LEVEL_SIZE
      4  2212				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__064_R
      5  2212					      ENDIF
      0  2212					      DEFL	_065_L, "2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-"
      0  2212					      START_LEVEL	_065_L
      1  2212				   LEVEL_START SET	*
      2  2212		       00 04	   BANK_LEVEL__065_L =	_CURRENT_BANK
      3  2212				   LEVEL__065_L SUBROUTINE
      4  2212				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2212
      2  2212		       32 2d 35 23*	      .byte.b	"2-5#5-|3#3-#5-|#-3$-6#|#-.-#2.#2-@#|2#*2.*.3$-#|#2.$-#.$-$-#|2#.2-2#2-$-#|-6#3-2#|6-5#-",0
      0  226a					      END_LEVEL	_065_L
      1  226a		       00		      .byte.b	0
      2  226a		       00 59	   LEVEL_SIZE__065_L =	* - LEVEL_START
      3  226b				  -	      IF	LEVEL_SIZE__065_L > MAX_LEVEL_SIZE
      4  226b				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_L
      5  226b					      ENDIF
      0  226b					      DEFL	_065_R, "3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#"
      0  226b					      START_LEVEL	_065_R
      1  226b				   LEVEL_START SET	*
      2  226b		       00 04	   BANK_LEVEL__065_R =	_CURRENT_BANK
      3  226b				   LEVEL__065_R SUBROUTINE
      4  226b				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  226b
      2  226b		       33 2d 35 23*	      .byte.b	"3-5#2-|4#.2-#2-|#2-#2.$#2-|#2-$*.-3#|#2-$2.*$-#|2#3$.3-#|-#@$-.*2-#|-9#",0
      0  22b3					      END_LEVEL	_065_R
      1  22b3		       00		      .byte.b	0
      2  22b3		       00 49	   LEVEL_SIZE__065_R =	* - LEVEL_START
      3  22b4				  -	      IF	LEVEL_SIZE__065_R > MAX_LEVEL_SIZE
      4  22b4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__065_R
      5  22b4					      ENDIF
     25  22b4
     26  22b4							;  ##########
     27  22b4							;  #	  #  ####
     28  22b4							;  # $##$*.*$	#
     29  22b4							;  #@ # .....# #
     30  22b4							;  # $#$.. #	#
     31  22b4							;  #  $  #######
     32  22b4							;  #### $ $  #
     33  22b4							;     #      #
     34  22b4							;     ########
     35  22b4
      0  22b4					      START_LEVEL	_066_L
      1  22b4				   LEVEL_START SET	*
      2  22b4		       00 04	   BANK_LEVEL__066_L =	_CURRENT_BANK
      3  22b4				   LEVEL__066_L SUBROUTINE
      4  22b4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  22b4
     37  22b4		       31 30 23 33*	      .byte.b	"10#3-|#5-#2-4#|#-$2#$*.*$2-#|#@-#-5.#-#|#-$#$2.-#3-#|#2-$2-7#|4#-$-$2-#2-|3-#6-#2-|3-8#2-",0
      0  230e					      END_LEVEL	_066_L
      1  230e		       00		      .byte.b	0
      2  230e		       00 5b	   LEVEL_SIZE__066_L =	* - LEVEL_START
      3  230f				  -	      IF	LEVEL_SIZE__066_L > MAX_LEVEL_SIZE
      4  230f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_L
      5  230f					      ENDIF
     39  230f
     40  230f							;    #####
     41  230f							;    #   ##
     42  230f							;    #    #
     43  230f							;    # *.$#####
     44  230f							;    # **.. $ #
     45  230f							;  ###$$.#.## #
     46  230f							;  #  @$. $## #
     47  230f							;  #	#      #
     48  230f							;  ############
     49  230f
      0  230f					      START_LEVEL	_066_R
      1  230f				   LEVEL_START SET	*
      2  230f		       00 04	   BANK_LEVEL__066_R =	_CURRENT_BANK
      3  230f				   LEVEL__066_R SUBROUTINE
      4  230f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  230f
     51  230f		       32 2d 35 23*	      .byte.b	"2-5#5-|2-#3-2#4-|2-#4-#4-|2-#-*.$5#|2-#-2*2.-$-#|3#2$.#.2#-#|#2-@$.-$2#-#|#3-#6-#|12#",0
      0  2365					      END_LEVEL	_066_R
      1  2365		       00		      .byte.b	0
      2  2365		       00 57	   LEVEL_SIZE__066_R =	* - LEVEL_START
      3  2366				  -	      IF	LEVEL_SIZE__066_R > MAX_LEVEL_SIZE
      4  2366				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__066_R
      5  2366					      ENDIF
     53  2366
     54  2366							;  ########
     55  2366							;#   @  #
     56  2366							;# $$ $$####
     57  2366							;#  ##$ $ .#
     58  2366							;# $## .*#.#
     59  2366							;#  ## *.*.#
     60  2366							;#  ## . . #
     61  2366							;###########
     62  2366
      0  2366					      START_LEVEL	_067_L
      1  2366				   LEVEL_START SET	*
      2  2366		       00 04	   BANK_LEVEL__067_L =	_CURRENT_BANK
      3  2366				   LEVEL__067_L SUBROUTINE
      4  2366				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2366
     64  2366		       38 23 33 2d*	      .byte.b	"8#3-|#3-@2-#3-|#-2$-2$4#|#2-2#$-$-.#|#-$2#-.*#.#|#2-2#-*.*.#|#2-2#-.-.-#|11#",0
      0  23b3					      END_LEVEL	_067_L
      1  23b3		       00		      .byte.b	0
      2  23b3		       00 4e	   LEVEL_SIZE__067_L =	* - LEVEL_START
      3  23b4				  -	      IF	LEVEL_SIZE__067_L > MAX_LEVEL_SIZE
      4  23b4				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_L
      5  23b4					      ENDIF
     66  23b4
     67  23b4							;  #######  ####
     68  23b4							;#	## #  #
     69  23b4							;# $$	.###$ #
     70  23b4							;##  #$*..   #
     71  23b4							; ##  *..#$# #
     72  23b4							;  ##+*..# $ #
     73  23b4							;   # $ $   ##
     74  23b4							;   ####   ##
     75  23b4							;	#####
     76  23b4
      0  23b4					      START_LEVEL	_067_R
      1  23b4				   LEVEL_START SET	*
      2  23b4		       00 04	   BANK_LEVEL__067_R =	_CURRENT_BANK
      3  23b4				   LEVEL__067_R SUBROUTINE
      4  23b4				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  23b4
     78  23b4		       37 23 32 2d*	      .byte.b	"7#2-4#|#5-2#-#2-#|#-2$2-.3#$-#|2#2-#$*2.3-#|-2#2-*2.#$#-#|2-2#+*2.#-$-#|3-#-$-$3-2#|3-4#3-2#-|6-5#2-",0
      0  2419					      END_LEVEL	_067_R
      1  2419		       00		      .byte.b	0
      2  2419		       00 66	   LEVEL_SIZE__067_R =	* - LEVEL_START
      3  241a				  -	      IF	LEVEL_SIZE__067_R > MAX_LEVEL_SIZE
      4  241a				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__067_R
      5  241a					      ENDIF
     80  241a
     81  241a							;  ##########
     82  241a							;  #  #     #
     83  241a							;  # $#$ $  #
     84  241a							;  # $  $.  #
     85  241a							;  #  #.*.$##
     86  241a							;  # $#.** #
     87  241a							;  ##@*...##
     88  241a							;   ## *  #
     89  241a							;    ######
     90  241a
      0  241a					      START_LEVEL	_068_L
      1  241a				   LEVEL_START SET	*
      2  241a		       00 04	   BANK_LEVEL__068_L =	_CURRENT_BANK
      3  241a				   LEVEL__068_L SUBROUTINE
      4  241a				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  241a
     92  241a		       31 30 23 7c*	      .byte.b	"10#|#2-#5-#|#-$#$-$2-#|#-$2-$.2-#|#2-#.*.$2#|#-$#.2*-#-|2#@*3.2#-|-2#-*2-#2-|2-6#2-",0
      0  246e					      END_LEVEL	_068_L
      1  246e		       00		      .byte.b	0
      2  246e		       00 55	   LEVEL_SIZE__068_L =	* - LEVEL_START
      3  246f				  -	      IF	LEVEL_SIZE__068_L > MAX_LEVEL_SIZE
      4  246f				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_L
      5  246f					      ENDIF
     94  246f
     95  246f							;  #####
     96  246f							;###	#
     97  246f							;#  $	#
     98  246f							;####* $$###
     99  246f							;#...*.#   #
    100  246f							;#.#.*.# $ #
    101  246f							;#$# $@$  ##
    102  246f							;#   ###  #
    103  246f							;##### ####
    104  246f
      0  246f					      START_LEVEL	_068_R
      1  246f				   LEVEL_START SET	*
      2  246f		       00 04	   BANK_LEVEL__068_R =	_CURRENT_BANK
      3  246f				   LEVEL__068_R SUBROUTINE
      4  246f				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  246f
    106  246f		       35 2d 35 23*	      .byte.b	"5-5#-|3-3#3-#-|3-#2-$2-#-|4#*-2$3#|#3.*.#3-#|#.#.*.#-$-#|#$#-$@$2-2#|#3-3#2-#-|5#-4#-",0
      0  24c5					      END_LEVEL	_068_R
      1  24c5		       00		      .byte.b	0
      2  24c5		       00 57	   LEVEL_SIZE__068_R =	* - LEVEL_START
      3  24c6				  -	      IF	LEVEL_SIZE__068_R > MAX_LEVEL_SIZE
      4  24c6				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__068_R
      5  24c6					      ENDIF
    108  24c6
    109  24c6							;  ######
    110  24c6							;#  $.###
    111  24c6							;#  *.. #
    112  24c6							;##$#. . ##
    113  24c6							;# $  #.. #
    114  24c6							;#@$$## $ #
    115  24c6							;# $	   #
    116  24c6							;#######  #
    117  24c6							;     ####
    118  24c6
      0  24c6					      START_LEVEL	_069_L
      1  24c6				   LEVEL_START SET	*
      2  24c6		       00 04	   BANK_LEVEL__069_L =	_CURRENT_BANK
      3  24c6				   LEVEL__069_L SUBROUTINE
      4  24c6				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  24c6
    120  24c6		       2d 36 23 33*	      .byte.b	"-6#3-|-#2-$.3#-|-#2-*2.-#-|2#$#.-.-2#|#-$2-#2.-#|#@2$2#-$-#|#-$6-#|7#2-#|6-4#",0
      0  2514					      END_LEVEL	_069_L
      1  2514		       00		      .byte.b	0
      2  2514		       00 4f	   LEVEL_SIZE__069_L =	* - LEVEL_START
      3  2515				  -	      IF	LEVEL_SIZE__069_L > MAX_LEVEL_SIZE
      4  2515				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_L
      5  2515					      ENDIF
    122  2515
    123  2515							;  #####
    124  2515							;##   #####
    125  2515							;##@$ $$   #
    126  2515							;# $#	$.*.#
    127  2515							;#  #	**..#
    128  2515							;# $  #. ###
    129  2515							;####	.##
    130  2515							; #####
    131  2515
      0  2515					      START_LEVEL	_069_R
      1  2515				   LEVEL_START SET	*
      2  2515		       00 04	   BANK_LEVEL__069_R =	_CURRENT_BANK
      3  2515				   LEVEL__069_R SUBROUTINE
      4  2515				   MAX_LEVEL_NUMBER SET	MAX_LEVEL_NUMBER + 1
      5  2515
    133  2515		       32 2d 35 23*	      .byte.b	"2-5#4-|-2#3-5#|2#@$-2$3-#|#-$#2-$.*.#|#2-#2-2*2.#|#-$2-#.-3#|4#2-.2#2-|3-5#3-",0
      0  2563					      END_LEVEL	_069_R
      1  2563		       00		      .byte.b	0
      2  2563		       00 4f	   LEVEL_SIZE__069_R =	* - LEVEL_START
      3  2564				  -	      IF	LEVEL_SIZE__069_R > MAX_LEVEL_SIZE
      4  2564				  -MAX_LEVEL_SIZE SET	LEVEL_SIZE__069_R
      5  2564					      ENDIF
    135  2564
    136  2564
      0  2564					      CHECK_BANK_SIZE	"LEVELS"
      1  2564		       05 64	   .TEMP      =	* - BANK_START
 LEVELS (2K) SIZE =  $564 , FREE= $29c
      2  2564					      ECHO	"LEVELS", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2564				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2564				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2564				  -	      ERR
      6  2564					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_INITBANK.asm LEVEL 2 PASS 3
      0  2564					      include	"BANK_INITBANK.asm"	; MUST be after banks that include levels -- otherwise MAX_LEVELBANK is not calculated properly
      1  2564
      0  2564					      NEWBANK	INITBANK
      1  2b3b ????				      SEG	INITBANK
      2  2800					      ORG	ORIGIN
      3  2800					      RORG	$F000
      4  2800				   BANK_START SET	*
      5  2800				   INITBANK   SET	ORIGIN / 2048
      6  2800				   ORIGIN     SET	ORIGIN + 2048
      7  2800				   _CURRENT_BANK SET	INITBANK
      3  2800
      4  2800		       00		      .byte.b	0	; to avoid extra cycle when accessing via BoardLineStartLO-1,y
      5  2801
      0  2801					      DEFINE_SUBROUTINE	BoardLineStartLO
      1  2801		       00 05	   BANK_BoardLineStartLO =	_CURRENT_BANK
      2  2801					      SUBROUTINE
      3  2801				   BoardLineStartLO
      7  2801
      8  2801							; Gives the start address (LO) of each board line
      9  2801
     10  2801				   .BOARD_LOCATION SET	Board
     11  2801					      REPEAT	SIZE_BOARD_Y
     12  2801				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2801				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2801					      ENDIF
     15  2801		       00		      .byte.b	<.BOARD_LOCATION
     16  2801				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2801					      REPEND
     12  2802				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2802				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2802					      ENDIF
     15  2802		       28		      .byte.b	<.BOARD_LOCATION
     16  2802				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2802					      REPEND
     12  2803				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2803				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2803					      ENDIF
     15  2803		       50		      .byte.b	<.BOARD_LOCATION
     16  2803				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2803					      REPEND
     12  2804				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2804				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2804					      ENDIF
     15  2804		       78		      .byte.b	<.BOARD_LOCATION
     16  2804				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2804					      REPEND
     12  2805				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2805				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2805					      ENDIF
     15  2805		       a0		      .byte.b	<.BOARD_LOCATION
     16  2805				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2805					      REPEND
     12  2806				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2806				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2806					      ENDIF
     15  2806		       c8		      .byte.b	<.BOARD_LOCATION
     16  2806				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2806					      REPEND
     12  2807					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2807				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2807					      ENDIF
     15  2807		       00		      .byte.b	<.BOARD_LOCATION
     16  2807				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2807					      REPEND
     12  2808				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2808				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2808					      ENDIF
     15  2808		       28		      .byte.b	<.BOARD_LOCATION
     16  2808				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2808					      REPEND
     12  2809				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2809				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2809					      ENDIF
     15  2809		       50		      .byte.b	<.BOARD_LOCATION
     16  2809				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2809					      REPEND
     12  280a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  280a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  280a					      ENDIF
     15  280a		       78		      .byte.b	<.BOARD_LOCATION
     16  280a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  280a					      REPEND
     12  280b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  280b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  280b					      ENDIF
     15  280b		       a0		      .byte.b	<.BOARD_LOCATION
     16  280b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  280b					      REPEND
     12  280c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  280c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  280c					      ENDIF
     15  280c		       c8		      .byte.b	<.BOARD_LOCATION
     16  280c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  280c					      REPEND
     12  280d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  280d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  280d					      ENDIF
     15  280d		       00		      .byte.b	<.BOARD_LOCATION
     16  280d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  280d					      REPEND
     12  280e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  280e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  280e					      ENDIF
     15  280e		       28		      .byte.b	<.BOARD_LOCATION
     16  280e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  280e					      REPEND
     12  280f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  280f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  280f					      ENDIF
     15  280f		       50		      .byte.b	<.BOARD_LOCATION
     16  280f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  280f					      REPEND
     12  2810				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2810				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2810					      ENDIF
     15  2810		       78		      .byte.b	<.BOARD_LOCATION
     16  2810				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2810					      REPEND
     12  2811				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2811				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2811					      ENDIF
     15  2811		       a0		      .byte.b	<.BOARD_LOCATION
     16  2811				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2811					      REPEND
     12  2812				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2812				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2812					      ENDIF
     15  2812		       c8		      .byte.b	<.BOARD_LOCATION
     16  2812				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2812					      REPEND
     12  2813					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2813				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2813					      ENDIF
     15  2813		       00		      .byte.b	<.BOARD_LOCATION
     16  2813				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2813					      REPEND
     12  2814				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2814				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2814					      ENDIF
     15  2814		       28		      .byte.b	<.BOARD_LOCATION
     16  2814				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2814					      REPEND
     12  2815				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2815				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2815					      ENDIF
     15  2815		       50		      .byte.b	<.BOARD_LOCATION
     16  2815				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     11  2815					      REPEND
     12  2816				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     13  2816				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     14  2816					      ENDIF
     15  2816		       78		      .byte.b	<.BOARD_LOCATION
     16  2816				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     17  2817					      REPEND
      0  2817					      CHECKPAGEX	BoardLineStartLO, "BoardLineStartLO in BANK_INITBANK.asm"
      9  2817					      LIST	ON
     19  2817
     20  2817		       03 a0	   SIZE_BOARD =	.BOARD_LOCATION-Board	; verify calculated value
     21  2817
     22  2817							;------------------------------------------------------------------------------
     23  2817
     24  2817				   BoardLineStartHiR
     25  2817
     26  2817							; Gives the start address (HI) of each board line
     27  2817							; Note this caters for the memory wrapping when we go from bank to bank, as
     28  2817							; the board overlays multiple banks!
     29  2817
     30  2817				   .BOARD_LOCATION SET	Board
     31  2817					      REPEAT	SIZE_BOARD_Y
     32  2817				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2817				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2817					      ENDIF
     35  2817		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2817				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2817					      REPEND
     32  2818				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2818				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2818					      ENDIF
     35  2818		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2818				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2818					      REPEND
     32  2819				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2819				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2819					      ENDIF
     35  2819		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2819				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2819					      REPEND
     32  281a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  281a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  281a					      ENDIF
     35  281a		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  281a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  281a					      REPEND
     32  281b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  281b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  281b					      ENDIF
     35  281b		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  281b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  281b					      REPEND
     32  281c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  281c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  281c					      ENDIF
     35  281c		       10		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  281c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  281c					      REPEND
     32  281d					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  281d				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  281d					      ENDIF
     35  281d		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  281d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  281d					      REPEND
     32  281e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  281e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  281e					      ENDIF
     35  281e		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  281e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  281e					      REPEND
     32  281f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  281f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  281f					      ENDIF
     35  281f		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  281f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  281f					      REPEND
     32  2820				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2820				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2820					      ENDIF
     35  2820		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2820				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2820					      REPEND
     32  2821				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2821				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2821					      ENDIF
     35  2821		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2821				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2821					      REPEND
     32  2822				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2822				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2822					      ENDIF
     35  2822		       11		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2822				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2822					      REPEND
     32  2823					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2823				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2823					      ENDIF
     35  2823		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2823				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2823					      REPEND
     32  2824				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2824				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2824					      ENDIF
     35  2824		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2824				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2824					      REPEND
     32  2825				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2825				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2825					      ENDIF
     35  2825		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2825				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2825					      REPEND
     32  2826				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2826				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2826					      ENDIF
     35  2826		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2826				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2826					      REPEND
     32  2827				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2827				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2827					      ENDIF
     35  2827		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2827				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2827					      REPEND
     32  2828				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2828				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2828					      ENDIF
     35  2828		       12		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2828				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2828					      REPEND
     32  2829					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  2829				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  2829					      ENDIF
     35  2829		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  2829				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  2829					      REPEND
     32  282a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  282a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  282a					      ENDIF
     35  282a		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  282a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  282a					      REPEND
     32  282b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  282b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  282b					      ENDIF
     35  282b		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  282b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     31  282b					      REPEND
     32  282c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     33  282c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     34  282c					      ENDIF
     35  282c		       13		      .byte.b	>( .BOARD_LOCATION & $13FF )	; cater for mirroring of memory images
     36  282c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     37  282d					      REPEND
      0  282d					      CHECKPAGEX	BoardLineStartHiR, "BoardLineStartHiR in BANK_INITBANK"
      9  282d					      LIST	ON
     39  282d							;------------------------------------------------------------------------------
     40  282d
     41  282d				   BoardLineStartHiW
     42  282d
     43  282d							; Gives the start address (HI) of each board line
     44  282d							; Note this caters for the memory wrapping when we go from bank to bank, as
     45  282d							; the board overlays multiple banks!
     46  282d
     47  282d				   .BOARD_LOCATION SET	Board
     48  282d					      REPEAT	SIZE_BOARD_Y
     49  282d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  282d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  282d					      ENDIF
     52  282d		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  282d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  282d					      REPEND
     49  282e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  282e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  282e					      ENDIF
     52  282e		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  282e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  282e					      REPEND
     49  282f				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  282f				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  282f					      ENDIF
     52  282f		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  282f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  282f					      REPEND
     49  2830				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2830				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2830					      ENDIF
     52  2830		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2830				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  2830					      REPEND
     49  2831				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2831				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2831					      ENDIF
     52  2831		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2831				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  2831					      REPEND
     49  2832				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2832				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2832					      ENDIF
     52  2832		       14		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2832				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  2832					      REPEND
     49  2833					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2833				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2833					      ENDIF
     52  2833		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2833				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  2833					      REPEND
     49  2834				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2834				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2834					      ENDIF
     52  2834		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2834				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  2834					      REPEND
     49  2835				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2835				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2835					      ENDIF
     52  2835		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2835				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  2835					      REPEND
     49  2836				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2836				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2836					      ENDIF
     52  2836		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2836				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  2836					      REPEND
     49  2837				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2837				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2837					      ENDIF
     52  2837		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2837				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  2837					      REPEND
     49  2838				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2838				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2838					      ENDIF
     52  2838		       15		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2838				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  2838					      REPEND
     49  2839					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2839				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2839					      ENDIF
     52  2839		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2839				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  2839					      REPEND
     49  283a				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  283a				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  283a					      ENDIF
     52  283a		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  283a				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  283a					      REPEND
     49  283b				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  283b				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  283b					      ENDIF
     52  283b		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  283b				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  283b					      REPEND
     49  283c				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  283c				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  283c					      ENDIF
     52  283c		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  283c				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  283c					      REPEND
     49  283d				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  283d				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  283d					      ENDIF
     52  283d		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  283d				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  283d					      REPEND
     49  283e				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  283e				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  283e					      ENDIF
     52  283e		       16		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  283e				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  283e					      REPEND
     49  283f					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  283f				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  283f					      ENDIF
     52  283f		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  283f				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  283f					      REPEND
     49  2840				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2840				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2840					      ENDIF
     52  2840		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2840				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  2840					      REPEND
     49  2841				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2841				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2841					      ENDIF
     52  2841		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2841				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     48  2841					      REPEND
     49  2842				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     50  2842				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     51  2842					      ENDIF
     52  2842		       17		      .byte.b	>( ( .BOARD_LOCATION & $13FF ) + RAM_WRITE )	; cater for mirroring of memory images
     53  2842				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X
     54  2843					      REPEND
      0  2843					      CHECKPAGEX	BoardLineStartHiW, "BoardLineStartHiW in BANK_INITBANK"
      9  2843					      LIST	ON
     56  2843
     57  2843							;------------------------------------------------------------------------------
     58  2843				  -	      IF	MULTI_BANK_BOARD = YES
     59  2843				  -BoardBank
     60  2843					      ENDIF
     61  2843							; Gives the RAM bank of the start of the board row for a given row.
     62  2843
     63  2843				   .BOARD_LOCATION SET	Board - RAM_3E
     64  2843					      REPEAT	SIZE_BOARD_Y
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843					      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     64  2843					      REPEND
     65  2843				  -	      IF	>.BOARD_LOCATION != >(.BOARD_LOCATION + SIZE_BOARD_X-1)
     66  2843				  -.BOARD_LOCATION SET	.BOARD_LOCATION - <.BOARD_LOCATION + 256
     67  2843					      ENDIF
     68  2843				  -	      IF	MULTI_BANK_BOARD = YES
     69  2843				  -	      .byte	BANK_BOARD + (.BOARD_LOCATION / RAM_SIZE)	; actual bank #
     70  2843					      ENDIF
     71  2843				   .BOARD_LOCATION SET	.BOARD_LOCATION + SIZE_BOARD_X	; note, we CANNOT cross a page boundary within a row
     72  2843					      REPEND
     73  2843				  -	      IF	MULTI_BANK_BOARD = YES
     74  2843				  -	      CHECKPAGEX	BoardBank, "BoardBank in BANK_INITBANK.asm"
     75  2843					      ENDIF
     76  2843
     77  2843
     78  2843							;------------------------------------------------------------------------------
     79  2843
     80  2843				   CopyROMShadowToRAM_F000
     81  2843		       a9 f0		      lda	#>$F000
     82  2845
      0  2845					      DEFINE_SUBROUTINE	CopyROMShadowToRAM	; in INITBANK
      1  2845		       00 05	   BANK_CopyROMShadowToRAM =	_CURRENT_BANK
      2  2845					      SUBROUTINE
      3  2845				   CopyROMShadowToRAM
     84  2845
     85  2845							; Function copies a RAM prototype ROM bank into the destination RAM bank.  Typically
     86  2845							; the variable definitions are in the ROM shadow because this allows auto-initialisation
     87  2845							; of the variable contents from ROM declarations, but still allows access to them as
     88  2845							; variables when the correct RAM bank is switched in.	Code is also, of course, copied
     89  2845							; into the RAM destination so that code is callable whenever the ROM *or* RAM bank is
     90  2845							; switched in.  Further, if multiple copies are made to multiple RAM banks, then the
     91  2845							; code co-lives in all banks and may run even as bankswitching occurs between those
     92  2845							; banks -- by the very code itself.
     93  2845
     94  2845							; Note: Relies on ROM_Bank having being set via CALL mechanism to call this function
     95  2845		       85 bf		      sta	Board_AddressR+1
     96  2847		       86 d9		      stx	O_ROM_Source_Bank	; source bank
     97  2849		       84 c3		      sty	RAM_Bank	; destination bank
     98  284b
     99  284b		       a0 00		      ldy	#0
    100  284d		       84 be		      sty	Board_AddressR
    101  284f		       84 c0		      sty	Board_AddressW
    102  2851		       a9 14		      lda	#>($1000+RAM_WRITE)
    103  2853		       85 c1		      sta	Board_AddressW+1
    104  2855
    105  2855							; Iterate 4 pages (1K) for complete bank copy
    106  2855
    107  2855		       a9 04		      lda	#4
    108  2857		       85 d8		      sta	O_CopyCount
    109  2859
    110  2859		       84 da	   CopyPage   sty	O_Index
    111  285b		       a5 d9		      lda	O_ROM_Source_Bank
    112  285d		       20 12 f8 	      jsr	GetROMByte	; get byte from ROM shadow bank
    113  2860							;tax
    114  2860		       a4 da		      ldy	O_Index
    115  2862		       a6 c3		      ldx	RAM_Bank
    116  2864		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)	 write byte to RAM bank
    117  2867
    118  2867		       a4 da		      ldy	O_Index
    119  2869		       c8		      iny
    120  286a		       d0 ed		      bne	CopyPage
    121  286c
    122  286c		       e6 bf		      inc	Board_AddressR+1
    123  286e		       e6 c1		      inc	Board_AddressW+1
    124  2870
    125  2870		       c6 d8		      dec	O_CopyCount
    126  2872		       d0 e5		      bne	CopyPage
    127  2874
    128  2874		       a4 c3		      ldy	RAM_Bank	; TODO: remove!?
    129  2876		       60		      rts
    130  2877
    131  2877
    132  2877							;------------------------------------------------------------------------------
      0  2877					      DEFINE_SUBROUTINE	SetPlatformColours	; in INITBANK
      1  2877		       00 05	   BANK_SetPlatformColours =	_CURRENT_BANK
      2  2877					      SUBROUTINE
      3  2877				   SetPlatformColours
    134  2877
    135  2877							; Now modify the hardwired colours so that we're correctly switched for NTSC/PAL
    136  2877							; The platform (0=NTSC, 1=PAL) is set from the right difficulty switch
    137  2877							; Note: This relies on DrawTheScreen starting on page boundary so that the (),y
    138  2877							; addressing will not violate the page-crossing restriction of 3E.
    139  2877
    140  2877							;		  sty RAM_Bank			  ; we assume we called CopyROMShadowToRAM before
    141  2877
    142  2877		       a9 00		      lda	#<DrawTheScreen	; = 0
    143  2879		       85 c0		      sta	Board_AddressW
    144  287b		       a9 f4		      lda	#>( DrawTheScreen + RAM_WRITE )
    145  287d		       85 c1		      sta	Board_AddressW+1
    146  287f
    147  287f							; first, set the x index (with last one being a RTS ($60))
    148  287f
    149  287f		       a6 c3		      ldx	RAM_Bank
    150  2881		       e0 07		      cpx	#SCREEN_LINES-1	; might become variable when vertical scrolling
    151  2883		       d0 07		      bne	.skipPatch
    152  2885		       a9 60		      lda	#$60	; rts
    153  2887		       a0 41		      ldy	#<SELFMOD_X
    154  2889		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)	 set index/rts
    155  288c				   .skipPatch
    156  288c
    157  288c		       a2 02		      ldx	#3-1
    158  288e				   .loopColor
    159  288e		       86 d8		      stx	colorIdx
    160  2890							; set PF colors
    161  2890		       b5 bb		      lda	color,x
    162  2892		       bc b7 f0 	      ldy	SelfModColOfsTbl,x
    163  2895							;tax
    164  2895		       a6 c3		      ldx	RAM_Bank
    165  2897		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy PF colour RED/GREEN/BLUE to self-modifying RAM
    166  289a							; set player colors
    167  289a		       a6 d8		      ldx	colorIdx
    168  289c		       bd ba f0 	      lda	SelfModePlayerTbl,x
    169  289f		       a4 81		      ldy	Platform
    170  28a1		       c0 02		      cpy	#PAL
    171  28a3		       90 02		      bcc	.platform0
    172  28a5		       69 14		      adc	#LINES_PER_CHAR-1	; C==1!
    173  28a7				   .platform0
    174  28a7		       bc bd f0 	      ldy	SelfModPlayerColOfsTbl,x
    175  28aa							;tax
    176  28aa		       a6 c3		      ldx	RAM_Bank
    177  28ac		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)	 copy player colour RED/GREEN/BLUE to self-modifying RAM
    178  28af							; loop
    179  28af		       a6 d8		      ldx	colorIdx
    180  28b1		       ca		      dex
    181  28b2		       10 da		      bpl	.loopColor
    182  28b4
    183  28b4		       a4 c3		      ldy	RAM_Bank
    184  28b6		       60		      rts
    185  28b7
    186  28b7				   SelfModColOfsTbl
    187  28b7		       53 86 1c 	      .byte.b	<(SELFMOD_BLUE+1), <(SELFMOD_GREEN+1), <(SELFMOD_RED+1)
    188  28ba				   SelfModePlayerTbl
    189  28ba		       bd b6 af 	      .byte.b	<SpriteColourBLUE, <SpriteColourGREEN, <SpriteColourRED
    190  28bd				   SelfModPlayerColOfsTbl
    191  28bd		       4c 7f 15 	      .byte.b	<(SELFMOD_PLAYERCOL_BLUE+1), <(SELFMOD_PLAYERCOL_GREEN+1), <(SELFMOD_PLAYERCOL_RED+1)
    192  28c0
    193  28c0
    194  28c0				   DrawLineStartLO
    195  28c0
    196  28c0							; Gives the start address of each line in the draw flags buffer
    197  28c0
    198  28c0				   .DRAW_LOCATION SET	DrawFlag
    199  28c0					      REPEAT	SCREEN_LINES
    200  28c0		       50		      .byte.b	<.DRAW_LOCATION
    201  28c0				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  28c0					      REPEND
    200  28c1		       5a		      .byte.b	<.DRAW_LOCATION
    201  28c1				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  28c1					      REPEND
    200  28c2		       64		      .byte.b	<.DRAW_LOCATION
    201  28c2				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  28c2					      REPEND
    200  28c3		       6e		      .byte.b	<.DRAW_LOCATION
    201  28c3				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  28c3					      REPEND
    200  28c4		       78		      .byte.b	<.DRAW_LOCATION
    201  28c4				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  28c4					      REPEND
    200  28c5		       82		      .byte.b	<.DRAW_LOCATION
    201  28c5				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  28c5					      REPEND
    200  28c6		       8c		      .byte.b	<.DRAW_LOCATION
    201  28c6				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    199  28c6					      REPEND
    200  28c7		       96		      .byte.b	<.DRAW_LOCATION
    201  28c7				   .DRAW_LOCATION SET	.DRAW_LOCATION + SCREEN_WIDTH
    202  28c8					      REPEND
    203  28c8
    204  28c8
    205  28c8							;------------------------------------------------------------------------------
    206  28c8
      0  28c8					      DEFINE_SUBROUTINE	GetBoardAddressRW	; in INITBANK
      1  28c8		       00 05	   BANK_GetBoardAddressRW =	_CURRENT_BANK
      2  28c8					      SUBROUTINE
      3  28c8				   GetBoardAddressRW
    208  28c8							; Must share same bank as BoardLineStart tables
    209  28c8
    210  28c8		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    211  28cb		       85 be		      sta	Board_AddressR	; 3
    212  28cd		       85 c0		      sta	Board_AddressW	; 3
    213  28cf		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    214  28d2		       85 bf		      sta	Board_AddressR+1	; 3	     READ address
    215  28d4		       09 04		      ora	#>RAM_WRITE	; 2
    216  28d6		       85 c1		      sta	Board_AddressW+1	; 3	     WRITE address
    217  28d8				  -	      IF	MULTI_BANK_BOARD = YES
    218  28d8				  -	      ldx	BoardBank,y	; 4 = 26    switch this on return
    219  28d8					      ELSE
    220  28d8		       a2 0d		      ldx	#BANK_BOARD	; 2
    221  28da					      ENDIF
    222  28da		       60		      rts		; 6 = 32[-2]
    223  28db
    224  28db							;------------------------------------------------------------------------------
    225  28db
      0  28db					      DEFINE_SUBROUTINE	GetBoardAddressR	;=24[-2](A)
      1  28db		       00 05	   BANK_GetBoardAddressR =	_CURRENT_BANK
      2  28db					      SUBROUTINE
      3  28db				   GetBoardAddressR
    227  28db
    228  28db		       b9 01 f0 	      lda	BoardLineStartLO,y	; 4
    229  28de		       85 be		      sta	Board_AddressR	; 3
    230  28e0		       b9 17 f0 	      lda	BoardLineStartHiR,y	; 4
    231  28e3		       85 bf		      sta	Board_AddressR+1	; 3	 READ address
    232  28e5				  -	      IF	MULTI_BANK_BOARD = YES
    233  28e5				  -	      lda	BoardBank,y	; 4	 switch this on return
    234  28e5					      ELSE
    235  28e5		       a9 0d		      lda	#BANK_BOARD	; 2
    236  28e7					      ENDIF
    237  28e7		       60		      rts		; 6[-2]
    238  28e8
    239  28e8							;------------------------------------------------------------------------------
    240  28e8
      0  28e8					      DEFINE_SUBROUTINE	GetBoardAddressW	;=24[-2](A)
      1  28e8		       00 05	   BANK_GetBoardAddressW =	_CURRENT_BANK
      2  28e8					      SUBROUTINE
      3  28e8				   GetBoardAddressW
    242  28e8
    243  28e8							; Must share same bank as BoardLineStart tables
    244  28e8
    245  28e8		       b9 01 f0 	      lda	BoardLineStartLO,y	;4
    246  28eb		       85 c0		      sta	Board_AddressW	;3
    247  28ed		       b9 2d f0 	      lda	BoardLineStartHiW,y	;4
    248  28f0		       85 c1		      sta	Board_AddressW+1	;3 WRITE address
    249  28f2				  -	      IF	MULTI_BANK_BOARD = YES
    250  28f2				  -	      ldx	BoardBank,y	;4 switch this on return
    251  28f2					      ELSE
    252  28f2		       a2 0d		      ldx	#BANK_BOARD	;2
    253  28f4					      ENDIF
    254  28f4		       60	   QRet       rts		;6
    255  28f5
    256  28f5							;-------------------------------------------------------------------------------
    257  28f5
    258  28f5
    259  28f5				   OBJTYPE    SET	0
    260  28f5					      MAC	define_character
    261  28f5				   CHARACTER_{1} =	OBJTYPE
    262  28f5				   OBJTYPE    .SET	OBJTYPE + 1
    263  28f5					      ENDM
    264  28f5
    265  28f5							; Modifications to character #/order must also ensure the following are correct...
    266  28f5							;   CharacterDataVecLO/HI	   in BANK_FIXED.asm
    267  28f5							;   MoveVecLO/HI		   in BANK_INITBANK
    268  28f5							;   CharReplacement		   in BANK_ROM_SHADOW_DRAWBUFFERS
    269  28f5
      0  28f5					      DEFINE_CHARACTER	BLANK
      1  28f5		       00 00	   CHARACTER_BLANK =	OBJTYPE
      2  28f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  28f5					      DEFINE_CHARACTER	SOIL
      1  28f5		       00 01	   CHARACTER_SOIL =	OBJTYPE
      2  28f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  28f5					      DEFINE_CHARACTER	BOX
      1  28f5		       00 02	   CHARACTER_BOX =	OBJTYPE
      2  28f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  28f5					      DEFINE_CHARACTER	TARGET
      1  28f5		       00 03	   CHARACTER_TARGET =	OBJTYPE
      2  28f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  28f5					      DEFINE_CHARACTER	TARGET2
      1  28f5		       00 04	   CHARACTER_TARGET2 =	OBJTYPE
      2  28f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  28f5					      DEFINE_CHARACTER	MANOCCUPIED
      1  28f5		       00 05	   CHARACTER_MANOCCUPIED =	OBJTYPE
      2  28f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  28f5					      DEFINE_CHARACTER	STEEL
      1  28f5		       00 06	   CHARACTER_STEEL =	OBJTYPE
      2  28f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  28f5					      DEFINE_CHARACTER	WALL
      1  28f5		       00 07	   CHARACTER_WALL =	OBJTYPE
      2  28f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  28f5					      DEFINE_CHARACTER	BOX_ON_TARGET
      1  28f5		       00 08	   CHARACTER_BOX_ON_TARGET =	OBJTYPE
      2  28f5				   OBJTYPE    .SET	OBJTYPE + 1
      0  28f5					      DEFINE_CHARACTER	NOGO
      1  28f5		       00 09	   CHARACTER_NOGO =	OBJTYPE
      2  28f5				   OBJTYPE    .SET	OBJTYPE + 1
    280  28f5
      0  28f5					      DEFINE_CHARACTER	MAXIMUM
      1  28f5		       00 0a	   CHARACTER_MAXIMUM =	OBJTYPE
      2  28f5				   OBJTYPE    .SET	OBJTYPE + 1
    282  28f5
    283  28f5							;------------------------------------------------------------------------------
    284  28f5
      0  28f5					      DEFINE_SUBROUTINE	PushBox	; in INITBANK
      1  28f5		       00 05	   BANK_PushBox =	_CURRENT_BANK
      2  28f5					      SUBROUTINE
      3  28f5				   PushBox
    286  28f5
    287  28f5							; X = restoration character for square we are moving TO
    288  28f5							; so, if X = CHARACTER_TARGET AND we move, THEN we are pushing a box off a target
    289  28f5
    290  28f5		       85 c2		      sta	ROM_Bank
    291  28f7
    292  28f7		       a5 a5		      lda	ManPushCounter
    293  28f9		       c9 01		      cmp	#PUSH_LIMIT
    294  28fb		       90 6c		      bcc	cannotPush
    295  28fd
    296  28fd		       86 da		      stx	restorationCharacter	; BOX'S NEW CHAR
    297  28ff
    298  28ff							; Determine if the box is pushable
    299  28ff							; we use the joystick to calculate the subsequent square
    300  28ff
    301  28ff		       a5 90		      lda	BufferedJoystick
    302  2901		       4a		      lsr
    303  2902		       4a		      lsr
    304  2903		       4a		      lsr
    305  2904		       4a		      lsr
    306  2905		       48		      pha
    307  2906		       a8		      tay
    308  2907
    309  2907		       18		      clc
    310  2908		       a5 8d		      lda	POS_Y_NEW
    311  290a		       79 c6 f2 	      adc	JoyMoveY,y
    312  290d		       a8		      tay
    313  290e		       20 c8 f0 	      jsr	GetBoardAddressRW
    314  2911
    315  2911		       68		      pla
    316  2912		       a8		      tay
    317  2913
    318  2913		       18		      clc
    319  2914		       a5 8c		      lda	POS_X_NEW
    320  2916		       79 ba f2 	      adc	JoyMoveX,y
    321  2919		       48		      pha
    322  291a		       a8		      tay
    323  291b
    324  291b				  -	      IF	MULTI_BANK_BOARD = YES
    325  291b				  -	      lda	RAM_Bank
    326  291b					      ELSE
    327  291b		       a9 0d		      lda	#BANK_BOARD	; 2
    328  291d					      ENDIF
    329  291d		       20 17 f8 	      jsr	GetBoardCharacter	;6+20(A)
    330  2920		       68		      pla
    331  2921		       a8		      tay
    332  2922
    333  2922		       a9 02		      lda	#CHARACTER_BOX
    334  2924		       e0 00		      cpx	#CHARACTER_BLANK
    335  2926		       f0 13		      beq	canPushTarget
    336  2928
    337  2928		       e0 03		      cpx	#CHARACTER_TARGET
    338  292a		       f0 04		      beq	decreaseTargets
    339  292c		       e0 04		      cpx	#CHARACTER_TARGET2
    340  292e		       d0 39		      bne	cannotPush
    341  2930
    342  2930							; Box is now on a target - so decrease the remaining targets
    343  2930
    344  2930		       f8	   decreaseTargets sed
    345  2931		       38		      sec
    346  2932		       a5 b8		      lda	targetsRequired
    347  2934		       e9 01		      sbc	#1
    348  2936		       85 b8		      sta	targetsRequired
    349  2938		       d8		      cld
    350  2939
    351  2939		       a9 08		      lda	#CHARACTER_BOX_ON_TARGET
    352  293b		       48	   canPushTarget pha
    353  293c
    354  293c							; If the box *WAS* on a target (restoration character = CHARACTER_TARGET)
    355  293c							; then we increase targets (as there is one more to get)
    356  293c
    357  293c		       a5 da		      lda	restorationCharacter
    358  293e		       c9 03		      cmp	#CHARACTER_TARGET
    359  2940		       d0 09		      bne	notOnTargetAlready
    360  2942
    361  2942							; increase the required targets as box is leaving one
    362  2942
    363  2942		       f8		      sed
    364  2943		       18		      clc
    365  2944		       a5 b8		      lda	targetsRequired
    366  2946		       69 01		      adc	#1
    367  2948		       85 b8		      sta	targetsRequired
    368  294a		       d8		      cld
    369  294b
    370  294b				   notOnTargetAlready
    371  294b
    372  294b		       68		      pla
    373  294c
    374  294c
    375  294c				  -	      IF	MULTI_BANK_BOARD = YES
    376  294c				  -	      ldx	RAM_Bank
    377  294c					      ELSE
    378  294c		       a2 0d		      ldx	#BANK_BOARD	; 2
    379  294e					      ENDIF
    380  294e		       20 20 f8 	      jsr	PutBoardCharacter	;6+21(A)
    381  2951
    382  2951		       a5 8f		      lda	POS_VAR	; player's restoration character
    383  2953		       48		      pha
    384  2954
    385  2954		       a6 8d		      ldx	POS_Y_NEW
    386  2956		       86 8b		      stx	POS_Y
    387  2958		       a4 8c		      ldy	POS_X_NEW
    388  295a		       84 8a		      sty	POS_X
    389  295c		       a5 da		      lda	restorationCharacter
    390  295e		       85 8f		      sta	POS_VAR
    391  2960
    392  2960		       20 65 f9 	      jsr	RestoreOriginalCharacter	; put back BOX's restoration character
    393  2963
    394  2963		       68		      pla
    395  2964		       85 8f		      sta	POS_VAR
    396  2966
    397  2966							;START_SOUND SOUND_BOX
    398  2966
    399  2966		       4c c4 f9 	      jmp	MovePlayer	; now there's a gap, player should move in
    400  2969
    401  2969		       e6 a5	   cannotPush inc	ManPushCounter
    402  296b		       60		      rts
    403  296c
    404  296c							;------------------------------------------------------------------------------
    405  296c
    406  296c							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    407  296c							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    408  296c
    409  296c							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    410  296c
    411  296c							; if the creature dies then jump NextObject
    412  296c
    413  296c
    414  296c
    415  296c		       ff	   RDirY      .byte.b	-1	;,0,1,0
    416  296d		       00 01	   RDirX      .byte.b	0,1	;,0,-1
    417  296f		       00 ff 01 00 DirPushModX .byte.b	0,-1,1,0
    418  2973		       ff 00 00 01 DirPushModY .byte.b	-1,0,0,1
    419  2977		       01 02 03 00*Directional .byte.b	1,2,3,0,1,2, 0,0, 11,8,9,10,11,8
    420  2985
    421  2985
    422  2985							;------------------------------------------------------------------------------
    423  2985
    424  2985							; the auto-calculation of these was causing DASM to get confused and abort assembling.
    425  2985							; I don't particularly know why; probably because of the level variable-size array and the values
    426  2985							; changing from pass to pass. I've put in the hardwired values and it seems to be OK now.
    427  2985
    428  2985		       00 00	   MANMODE_STARTUP =	0
    429  2985		       00 01	   MANMODE_NORMAL =	1
    430  2985		       00 02	   MANMODE_DEAD =	2
    431  2985		       00 03	   MANMODE_WAITING =	3
    432  2985		       00 04	   MANMODE_WAITING2 =	4
    433  2985		       00 05	   MANMODE_WAITING_NT =	5
    434  2985		       00 06	   MANMODE_WAITING_NT2 =	6
    435  2985		       00 07	   MANMODE_NEXTLEVEL =	7
    436  2985		       00 08	   MANMODE_BONUS_START =	8
    437  2985		       00 09	   MANMODE_BONUS_RUN =	9
    438  2985
      0  2985					      DEFINE_SUBROUTINE	ManProcess	; in INITBANK
      1  2985		       00 05	   BANK_ManProcess =	_CURRENT_BANK
      2  2985					      SUBROUTINE
      3  2985				   ManProcess
    440  2985
    441  2985							;lda #$FF
    442  2985							;sta specialTimeFlag		  ; detects time overflow in bigbang (and TARGET grab)
    443  2985
    444  2985
    445  2985							; ManMode tells the player what it is currently doing.  State machine.
    446  2985
    447  2985					      if	1
    448  2985							; RESET to start next level
    449  2985
    450  2985		       ad 82 02 	      lda	SWCHB
    451  2988		       29 02		      and	#2
    452  298a		       d0 04		      bne	skipNextLevel
    453  298c		       a9 07		      lda	#MANMODE_NEXTLEVEL
    454  298e		       85 9f		      sta	ManMode
    455  2990				   skipNextLevel
    456  2990
    457  2990							; RESET to re-start current level
    458  2990
    459  2990		       ad 82 02 	      lda	SWCHB
    460  2993		       29 01		      and	#1
    461  2995		       d0 04		      bne	noReset
    462  2997		       a9 04		      lda	#MANMODE_WAITING2
    463  2999		       85 9f		      sta	ManMode
    464  299b				   noReset
    465  299b
    466  299b					      endif
    467  299b
    468  299b
    469  299b							; Check if all the boxes are on their target square
    470  299b
    471  299b		       a5 b8		      lda	targetsRequired
    472  299d		       d0 04		      bne	notComplete
    473  299f		       a9 07		      lda	#MANMODE_NEXTLEVEL
    474  29a1		       85 9f		      sta	ManMode
    475  29a3				   notComplete
    476  29a3
    477  29a3							;lda SWCHB
    478  29a3							;and #3
    479  29a3							;bne .skipReset	  ; BOTH select/reset = restart
    480  29a3
    481  29a3							;lsr SWCHB
    482  29a3							;bcs .skipReset
    483  29a3
    484  29a3
    485  29a3				   .skipReset
    486  29a3
    487  29a3							;sokldy ManMode
    488  29a3							;sok lda ManActionTimer,y
    489  29a3							;sok beq .skipTimer
    490  29a3		       20 cd f1 	      jsr	UpdateTimer
    491  29a6				   .skipTimer
    492  29a6		       a4 9f		      ldy	ManMode
    493  29a8		       b9 bd f1 	      lda	ManActionLO,y
    494  29ab		       85 d8		      sta	actionVector
    495  29ad		       b9 c5 f1 	      lda	ManActionHI,y
    496  29b0		       85 d9		      sta	actionVector+1
    497  29b2		       6c d8 00 	      jmp	(actionVector)
    498  29b5
    499  29b5				   ManActionTimer
    500  29b5		       00		      .byte.b	0	;<manStartup		 ; 0		 no timer
    501  29b6		       01		      .byte.b	1	;<normalMan		 ; 1		 timer
    502  29b7		       01		      .byte.b	1	;<deadMan		 ; 2		 timer
    503  29b8		       01		      .byte.b	1	;<waitingMan		 ; 3		 timer
    504  29b9		       01		      .byte.b	1	;<waitingManPress	 ; 4		 timer
    505  29ba		       00		      .byte.b	0	;<waitingManNoTim	 ; 5		 no timer
    506  29bb		       00		      .byte.b	0	;<waitingManPressNoTim  ; 6		 no timer
    507  29bc		       00		      .byte.b	0	;<nextLevelMan 	 ; 7		 no timer
    508  29bd				   ManActionLO
    509  29bd		       00		      .byte.b	<manStartup	; 0		 no timer
    510  29be		       2a		      .byte.b	<normalMan	; 1		 timer
    511  29bf		       2f		      .byte.b	<deadMan	; 2		 timer
    512  29c0		       23		      .byte.b	<waitingMan	; 3		 timer
    513  29c1		       23		      .byte.b	<waitingManPress	; 4		 timer
    514  29c2		       23		      .byte.b	<waitingMan	; 5		 no timer
    515  29c3		       23		      .byte.b	<waitingManPress	; 6		 no timer
    516  29c4		       be		      .byte.b	<nextLevelMan	; 7		 no timer
    517  29c5
    518  29c5				   ManActionHI
    519  29c5		       f2		      .byte.b	>manStartup	; no timer
    520  29c6		       f2		      .byte.b	>normalMan	; timer
    521  29c7		       f2		      .byte.b	>deadMan	; timer
    522  29c8		       f2		      .byte.b	>waitingMan	; timer
    523  29c9		       f2		      .byte.b	>waitingManPress	; timer
    524  29ca		       f2		      .byte.b	>waitingMan	; no timer
    525  29cb		       f2		      .byte.b	>waitingManPress	; no timer
    526  29cc		       fc		      .byte.b	>nextLevelMan	; no timer
    527  29cd
    528  29cd							;------------------------------------------------------------------------------
      0  29cd					      DEFINE_SUBROUTINE	UpdateTimer
      1  29cd		       00 05	   BANK_UpdateTimer =	_CURRENT_BANK
      2  29cd					      SUBROUTINE
      3  29cd				   UpdateTimer
    530  29cd
    531  29cd		       a9 09		      lda	#BANK_SCORING
    532  29cf		       20 08 f8 	      jsr	DrawTargetsRequiredFromROM
    533  29d2
    534  29d2
    535  29d2		       a2 03		      ldx	#3
    536  29d4		       a5 9f		      lda	ManMode
    537  29d6		       c9 09		      cmp	#MANMODE_BONUS_RUN
    538  29d8		       f0 0a		      beq	.setLoops
    539  29da
    540  29da		       a2 04		      ldx	#NUM_LEVELS-1	; intermissions run at full speed
    541  29dc		       24 b5		      bit	levelDisplay
    542  29de		       30 02		      bmi	.intermission2
    543  29e0		       a6 b4		      ldx	level
    544  29e2				   .intermission2
    545  29e2
    546  29e2		       a2 01		      ldx	#1
    547  29e4				   .setLoops
    548  29e4		       86 d9		      stx	timerLoops
    549  29e6		       d0 08		      bne	.notScoring
    550  29e8				   .loopTimer
    551  29e8		       a5 b4		      lda	level	; each second left adds 'level' to score
    552  29ea		       18		      clc
    553  29eb		       69 01		      adc	#1
    554  29ed		       20 b2 fc 	      jsr	ScoreAdd
    555  29f0				   .notScoring
    556  29f0							;		  sed
    557  29f0							;		  sec
    558  29f0							;		  lda moveCounter
    559  29f0							;		  sbc #1
    560  29f0							;		  sta moveCounter
    561  29f0							;		  cld
    562  29f0							;		  bcs .skipHi2a
    563  29f0							;		  dec moveCounterHi
    564  29f0							;.skipHi2a
    565  29f0							; check for running out of time sound:
    566  29f0							;		  lda moveCounterHi
    567  29f0							;		  bne .timeAbove9
    568  29f0							;		  lda #$09
    569  29f0							;		  sec
    570  29f0							;		  sbc moveCounter
    571  29f0							;		  bcc .timeAbove9
    572  29f0							; this assumes that SND_MASK_HI = %11110000
    573  29f0							;  and the time entries are ordered 9 to 0!
    574  29f0							;		  asl
    575  29f0							;		  asl
    576  29f0							;		  asl
    577  29f0							;		  asl
    578  29f0							;		  adc #SOUND_TIME_9
    579  29f0							;		  sta tmpSound
    580  29f0							;		  lda newSounds
    581  29f0							;		  and #<(~SND_MASK_HI)
    582  29f0							;		  ora tmpSound
    583  29f0							;		  sta newSounds
    584  29f0							;.skipTimeSound:
    585  29f0							;		  ldx moveCounter
    586  29f0							;		  bne .timeNotZero
    587  29f0							;		  stx AUDV0			  ; stop bonus sound
    588  29f0							;		  stx soundIdxLst
    589  29f0							;.contChannel1:
    590  29f0							;		  ldx #MANMODE_NEXTLEVEL	  ; time bonus
    591  29f0							;		  lda ManMode
    592  29f0							;		  cmp #MANMODE_BONUS_RUN
    593  29f0							;		  beq .nextLevel
    594  29f0							;		  ldx #MANMODE_WAITING_NT2	  ; time over
    595  29f0							;		  cmp #MANMODE_WAITING2 	  ; Man already dead?
    596  29f0							;		  beq .nextLevel
    597  29f0							;		  dex				  ; == MANMODE_WAITING_NT
    598  29f0							;.nextLevel
    599  29f0							;		  stx ManMode			  ; -> man dies
    600  29f0				   .timeNotZero
    601  29f0				   .forceTimeDraw
    602  29f0
    603  29f0
    604  29f0		       a9 09		      lda	#BANK_SCORING
    605  29f2		       4c 00 f8 	      jmp	DrawTimeFromROM	; Z-flag == 0!
    606  29f5
    607  29f5				   .timeAbove9
    608  29f5		       c6 d9		      dec	timerLoops
    609  29f7		       d0 ef		      bne	.loopTimer
    610  29f9		       f0 f5		      beq	.forceTimeDraw
    611  29fb
    612  29fb				   TimeFracTbl
    613  29fb		       1f		      .byte.b	31	; level 1, NTSC/PAL
    614  29fc		       1b		      .byte.b	27	; level 2, NTSC/PAL
    615  29fd		       18		      .byte.b	24	; level 3, NTSC/PAL
    616  29fe		       17		      .byte.b	23	; level 4, NTSC/PAL
    617  29ff		       16		      .byte.b	22	; level 5, NTSC/PAL
    618  2a00							; calculate: level 5 throttle * level 5 time / level x throttle
    619  2a00
    620  2a00
    621  2a00							;------------------------------------------------------------------------------
      0  2a00					      DEFINE_SUBROUTINE	manStartup
      1  2a00		       00 05	   BANK_manStartup =	_CURRENT_BANK
      2  2a00					      SUBROUTINE
      3  2a00				   manStartup
    623  2a00
    624  2a00				  -	      if	0
    625  2a00				  -	      lda	POS_Type
    626  2a00				  -	      pha
    627  2a00				  -	      lda	#TYPE_CIRCLE
    628  2a00				  -	      sta	POS_Type
    629  2a00				  -	      jsr	InsertObjectStack
    630  2a00				  -	      pla
    631  2a00				  -	      sta	POS_Type
    632  2a00					      endif
    633  2a00
    634  2a00		       a5 9b		      lda	ManX
    635  2a02		       85 8c		      sta	POS_X_NEW	;NewX
    636  2a04		       85 8a		      sta	POS_X
    637  2a06		       a5 9c		      lda	ManY
    638  2a08		       85 8d		      sta	POS_Y_NEW	;NewY
    639  2a0a		       85 8b		      sta	POS_Y
    640  2a0c
    641  2a0c		       e6 9a		      inc	manAnimationIndex
    642  2a0e		       a6 9a		      ldx	manAnimationIndex	; animation index
    643  2a10		       bd 20 f2 	      lda	.ManStartup-1,x
    644  2a13		       30 09		      bmi	CreateThePlayer
    645  2a15		       85 8e		      sta	POS_Type
    646  2a17
    647  2a17		       a9 ff		      lda	#$FF
    648  2a19		       85 a0		      sta	ManDelayCount	; anything, just non-0
    649  2a1b
    650  2a1b		       4c 3d f8 	      jmp	PutBoardCharacterFromRAM	;70 --> switches this bank out but who cares!
    651  2a1e
    652  2a1e				   CreateThePlayer
    653  2a1e
    654  2a1e		       e6 9f		      inc	ManMode	; --> MANMODE_NORMAL
    655  2a20				   RTS_CF
    656  2a20		       60		      rts
    657  2a21
    658  2a21				   .ManStartup
    659  2a21							;    .byte CHARACTER_NOGO
    660  2a21							;    .byte CHARACTER_NOGO
    661  2a21							;    .byte CHARACTER_STEEL
    662  2a21							;    .byte CHARACTER_STEEL
    663  2a21							;    .byte CHARACTER_NOGO
    664  2a21							;    .byte CHARACTER_NOGO
    665  2a21							;    .byte CHARACTER_STEEL
    666  2a21							;    .byte CHARACTER_NOGO
    667  2a21							;    .byte CHARACTER_STEEL
    668  2a21							;    .byte CHARACTER_NOGO
    669  2a21							;    .byte CHARACTER_STEEL
    670  2a21							;    .byte CHARACTER_NOGO
    671  2a21							;    .byte CHARACTER_STEEL
    672  2a21							;    .byte CHARACTER_NOGO
    673  2a21							;    .byte CHARACTER_STEEL
    674  2a21							;    .byte CHARACTER_NOGO
    675  2a21							;    .byte CHARACTER_STEEL
    676  2a21							;.byte CHARACTER_NOGO
    677  2a21		       05		      .byte.b	CHARACTER_MANOCCUPIED
    678  2a22		       ff		      .byte.b	-1
    679  2a23
    680  2a23							;------------------------------------------------------------------------------
    681  2a23
    682  2a23				   waitingMan
    683  2a23				   waitingManPress
    684  2a23
    685  2a23							;		  lda #50
    686  2a23							;		  sta ColourTimer
    687  2a23
    688  2a23
    689  2a23		       a5 c8		      lda	NextLevelTrigger
    690  2a25		       09 40		      ora	#BIT_NEXTLIFE
    691  2a27		       85 c8		      sta	NextLevelTrigger
    692  2a29		       60		      rts
    693  2a2a
    694  2a2a				  -	      if	0
    695  2a2a				  -	      dec	ManDelayCount
    696  2a2a				  -
    697  2a2a				  -	      lda	#0
    698  2a2a				  -	      sta	LookingAround
    699  2a2a				  -	      sta	BGColour
    700  2a2a				  -
    701  2a2a				  -			; Wait for button to be RELEASED first!
    702  2a2a				  -
    703  2a2a				  -	      lda	BufferedButton
    704  2a2a				  -	      bpl	noChange
    705  2a2a				  -	      inc	ManMode
    706  2a2a				  -
    707  2a2a				  -			; Man loses a life and re-starts level if lives available
    708  2a2a				  -			; Special-case: Bonus levels go to next level.
    709  2a2a				  -
    710  2a2a				  -	      IF	NUM_LIVES != -1
    711  2a2a				  -	      dec	ManCount	; works for P1P2 format
    712  2a2a				  -			; display lives after a live is lost
    713  2a2a				  -	      lda	scoringFlags	;
    714  2a2a				  -	      and	#~DISPLAY_FLAGS
    715  2a2a				  -	      ora	#DISPLAY_LIVES
    716  2a2a				  -	      sta	scoringFlags	;
    717  2a2a				  -	      ENDIF
    718  2a2a				  -	      jsr	goGeneralScoringSetups	; update the life display. Roundabout way of doing it.
    719  2a2a				  -
    720  2a2a				  -
    721  2a2a				  -	      lda	#120	; something long.  anything.
    722  2a2a				  -	      sta	scoringTimer	; first time through we wait on the current display
    723  2a2a				  -
    724  2a2a				  -			;waitingManPress
    725  2a2a				  -
    726  2a2a				  -			; Cycle the score display, player display, level display based on timing
    727  2a2a				  -			; see "Scoring timer" reset stomp comment in bank_generic.
    728  2a2a				  -
    729  2a2a				  -	      lda	scoringTimer
    730  2a2a				  -	      cmp	#10	; non-zero so we don't get stomped on by the scoring reset in
    731  2a2a				  -	      bcs	stillKicking
    732  2a2a				  -	      lda	#90	; something long.  anything.
    733  2a2a				  -	      sta	scoringTimer
    734  2a2a				  -
    735  2a2a				  -	      lda	ManCount
    736  2a2a				  -	      and	#$0f
    737  2a2a				  -	      cmp	#$01
    738  2a2a				  -	      ldx	scoringFlags
    739  2a2a				  -	      inx
    740  2a2a				  -	      txa
    741  2a2a				  -			; if game over for current player, display alternate scoreboard
    742  2a2a				  -	      and	#$f3
    743  2a2a				  -	      bcc	gameOver
    744  2a2a				  -			; else display targets/time and move count
    745  2a2a				  -	      and	#$f1
    746  2a2a				  -gameOver   sta	scoringFlags	;
    747  2a2a				  -
    748  2a2a				  -	      jsr	goGeneralScoringSetups	; update the score display.
    749  2a2a				  -
    750  2a2a				  -stillKicking
    751  2a2a				  -
    752  2a2a				  -	      lda	BufferedButton	; button pressed?
    753  2a2a				  -	      bmi	noChange
    754  2a2a				  -
    755  2a2a				  -	      lda	NextLevelTrigger
    756  2a2a				  -	      ora	#BIT_NEXTLIFE
    757  2a2a				  -	      sta	NextLevelTrigger
    758  2a2a				  -
    759  2a2a				  -noChange   rts
    760  2a2a					      endif
    761  2a2a
    762  2a2a							;------------------------------------------------------------------------------
    763  2a2a							; Normal man state
    764  2a2a
    765  2a2a
    766  2a2a				   normalMan
    767  2a2a
    768  2a2a							; Timer is still running, so we see if the player is to die for any reason
    769  2a2a
    770  2a2a							;		  bit demoMode
    771  2a2a							;		  bmi stayAlive
    772  2a2a							; SELECT pressed?
    773  2a2a							;		  lda SWCHB
    774  2a2a							;		  eor #$FF
    775  2a2a							;		  and #3
    776  2a2a							;		  bne Time0			  ; EITHER select or reset are pressed
    777  2a2a							;		  lsr
    778  2a2a							;		  lsr
    779  2a2a							;		  bcc Time0			  ; suicide!
    780  2a2a				   stayAlive
    781  2a2a
    782  2a2a							;------------------------------------------------------------------------------
    783  2a2a
    784  2a2a							;ldx ManY
    785  2a2a							;ldy ManX
    786  2a2a
    787  2a2a							;lda BoardLineStartLO,x
    788  2a2a							;sta Board_AddressR
    789  2a2a							;lda BoardLineStartHiR,x
    790  2a2a							;sta Board_AddressR+1
    791  2a2a
    792  2a2a				  -	      IF	MULTI_BANK_BOARD = YES
    793  2a2a				  -			;lda BoardBank,x		  ;4
    794  2a2a				  -			;sta RAM_Bank			  ;3
    795  2a2a					      ELSE
    796  2a2a							;lda #BANK_BOARD		  ;2
    797  2a2a					      ENDIF
    798  2a2a							;jsr GetBoardCharacter 	  ;6+20(A)
    799  2a2a
    800  2a2a							;lda CharToType,x
    801  2a2a							;cmp #TYPE_MAN
    802  2a2a							;beq PlayerAlive
    803  2a2a		       4c 5e f2 	      jmp	PlayerAlive	;sok
    804  2a2d
    805  2a2d							; character he's on isn't a MAN character, so he dies...
    806  2a2d
    807  2a2d				   Time0
    808  2a2d
    809  2a2d		       e6 9f		      inc	ManMode	; #1 -- player dead!
    810  2a2f
    811  2a2f
    812  2a2f		       a5 9b	   deadMan    lda	ManX
    813  2a31		       85 8a		      sta	POS_X
    814  2a33		       a5 9c		      lda	ManY
    815  2a35		       85 8b		      sta	POS_Y
    816  2a37
    817  2a37							;jsr BlankPlayerFrame
    818  2a37
    819  2a37							; and becomes a man waiting for resurrection...
    820  2a37
    821  2a37		       e6 9f		      inc	ManMode
    822  2a39
    823  2a39				   timeTooShortToDie
    824  2a39		       60		      rts
    825  2a3a
    826  2a3a							;------------------------------------------------------------------------------
    827  2a3a
    828  2a3a							;lookColour	  .byte $b0,$02
    829  2a3a
      0  2a3a					      DEFINE_SUBROUTINE	LookAround	; in INITBANK
      1  2a3a		       00 05	   BANK_LookAround =	_CURRENT_BANK
      2  2a3a					      SUBROUTINE
      3  2a3a				   LookAround
    831  2a3a
    832  2a3a		       a9 ff		      lda	#$FF
    833  2a3c		       85 92		      sta	BufferedButton
    834  2a3e
    835  2a3e							;ldx Platform
    836  2a3e							;lda lookColour,x
    837  2a3e							;sta BGColour
    838  2a3e
    839  2a3e							; Use the joystick as a window-scroller to change the viewport
    840  2a3e
    841  2a3e		       a5 90		      lda	BufferedJoystick
    842  2a40		       4a		      lsr
    843  2a41		       4a		      lsr
    844  2a42		       4a		      lsr
    845  2a43		       4a		      lsr
    846  2a44		       a8		      tay
    847  2a45
    848  2a45		       b9 ba f2 	      lda	JoyMoveX,y
    849  2a48							;asl
    850  2a48		       18		      clc
    851  2a49		       65 97		      adc	BoardScrollX
    852  2a4b		       c5 94		      cmp	BoardEdge_Right
    853  2a4d		       b0 02		      bcs	AbandonX
    854  2a4f		       85 97		      sta	BoardScrollX
    855  2a51
    856  2a51		       b9 c6 f2    AbandonX   lda	JoyMoveY,y
    857  2a54							;asl
    858  2a54		       18		      clc
    859  2a55		       65 96		      adc	BoardScrollY
    860  2a57		       c5 95		      cmp	BoardEdge_Bottom
    861  2a59		       b0 02		      bcs	AbandonY
    862  2a5b		       85 96		      sta	BoardScrollY
    863  2a5d
    864  2a5d		       60	   AbandonY   rts
    865  2a5e
    866  2a5e
    867  2a5e
    868  2a5e
    869  2a5e				   PlayerAlive
    870  2a5e
    871  2a5e							; Calling code uses 'POS_X_NEW' and 'POS_Y_NEW' as new player position, so these must be set
    872  2a5e							; before exiting via (for example) look-around option :)
    873  2a5e
    874  2a5e		       a5 9b		      lda	ManX
    875  2a60		       85 8c		      sta	POS_X_NEW
    876  2a62		       a5 9c		      lda	ManY
    877  2a64		       85 8d		      sta	POS_Y_NEW
    878  2a66
    879  2a66
    880  2a66							;------------------------------------------------------------------------------
    881  2a66							; Look around is triggered by holding down the fire button for a while, without any other
    882  2a66							; joystick directions chosen. The variable LookingAround has a negative value ($FF) when looking
    883  2a66							; is active. Otherwise, it is counting down to the time where it will trigger.
    884  2a66
    885  2a66		       00 00	   LOOK_DELAY =	0
    886  2a66
    887  2a66		       a2 00		      ldx	#LOOK_DELAY
    888  2a68		       a5 92		      lda	BufferedButton
    889  2a6a		       30 0d		      bmi	noLook	; button?
    890  2a6c		       a5 a6		      lda	LookingAround
    891  2a6e		       30 ca		      bmi	LookAround	; already looking
    892  2a70		       a5 90		      lda	BufferedJoystick
    893  2a72		       c9 f0		      cmp	#$F0
    894  2a74		       90 03		      bcc	noLook	; must have no directions chosen
    895  2a76		       a6 a6		      ldx	LookingAround
    896  2a78		       ca		      dex
    897  2a79		       86 a6	   noLook     stx	LookingAround
    898  2a7b
    899  2a7b
    900  2a7b							;------------------------------------------------------------------------------
    901  2a7b
    902  2a7b							; control the scrolling via the joystick
    903  2a7b
    904  2a7b		       a5 a4		      lda	ManLastDirection
    905  2a7d		       29 07		      and	#DIRECTION_BITS
    906  2a7f		       a8		      tay
    907  2a80
    908  2a80		       a5 90		      lda	BufferedJoystick	; joystick
    909  2a82		       25 91		      and	BufferedJoystick+1
    910  2a84
    911  2a84		       a2 00		      ldx	#0
    912  2a86		       0a	   .loopDirs  asl
    913  2a87		       90 07		      bcc	.dirFound
    914  2a89		       88		      dey
    915  2a8a		       e8		      inx
    916  2a8b		       e0 04		      cpx	#4
    917  2a8d		       d0 f7		      bne	.loopDirs
    918  2a8f		       18		      clc
    919  2a90				   .dirFound
    920  2a90		       a5 8c		      lda	POS_X_NEW	;NewX
    921  2a92		       7d d3 f2 	      adc	JoyDirX,x
    922  2a95		       85 8c		      sta	POS_X_NEW	;NewX
    923  2a97		       a5 8d		      lda	POS_Y_NEW	;NewY
    924  2a99		       18		      clc
    925  2a9a		       7d d1 f2 	      adc	JoyDirY,x
    926  2a9d		       85 8d		      sta	POS_Y_NEW	;NewY
    927  2a9f
    928  2a9f		       98		      tya
    929  2aa0		       f0 12		      beq	noMovement	; animation OK
    930  2aa2
    931  2aa2		       8a		      txa
    932  2aa3		       45 a4		      eor	ManLastDirection
    933  2aa5		       29 07		      and	#DIRECTION_BITS
    934  2aa7		       45 a4		      eor	ManLastDirection
    935  2aa9		       85 a4		      sta	ManLastDirection
    936  2aab		       bd b5 f2 	      lda	ManAnimTblLo,x
    937  2aae		       85 a1		      sta	ManAnimation
    938  2ab0							;lda ManAnimTblHi,x
    939  2ab0							;sta ManAnimation+1
    940  2ab0		       a9 00		      lda	#0
    941  2ab2		       85 a0		      sta	ManDelayCount
    942  2ab4				   phase0		;jsr MovePlayer
    943  2ab4				   noMovement		;ldx MAN_Player
    944  2ab4
    945  2ab4		       60	   DFS_rts    rts
    946  2ab5
    947  2ab5
    948  2ab5				   ManAnimTblLo
    949  2ab5		       00 00 00 00*	      .byte.b	AnimateRIGHT-Manimate, AnimateLEFT-Manimate, AnimateUP-Manimate, AnimateUP-Manimate, AnimateSTOPPED-Manimate
    950  2aba							;ManAnimTblHi
    951  2aba							;    .byte   >AnimateRIGHT, >AnimateLEFT, >AnimateUP, >AnimateUP, >AnimateSTOPPED
    952  2aba
    953  2aba
    954  2aba
    955  2aba		       00 00 00 00*JoyMoveX   .byte.b	0,0,0,0,0,1, 1,1,0,-1,-1,-1	;,0, 0,0,0
    956  2ac6		       00 00 00 00*JoyMoveY   .byte.b	0,0,0,0,0,1,-1,0,0, 1,-1	;, 0,0,1,-1,0
    957  2ad1
    958  2ad1				   JoyDirY
    959  2ad1		       00 00		      .byte.b	0,0	;,1,-1,0
    960  2ad3				   JoyDirX
    961  2ad3		       01 ff 00 00*	      .byte.b	1,-1,0,0,0
    962  2ad8
    963  2ad8
    964  2ad8							;------------------------------------------------------------------------------
    965  2ad8
    966  2ad8
      0  2ad8					      DEFINE_SUBROUTINE	DrawFullScreen	; = 2568[-96]
      1  2ad8		       00 05	   BANK_DrawFullScreen =	_CURRENT_BANK
      2  2ad8					      SUBROUTINE
      3  2ad8				   DrawFullScreen
    968  2ad8
    969  2ad8							; 83[-7] + 2484[-89] = 2567[-96]
    970  2ad8
    971  2ad8
    972  2ad8		       ad 84 02 	      lda	INTIM	; 4
    973  2adb		       c9 29		      cmp	#SEGTIME_BDF	; 2
    974  2add		       90 d5		      bcc	DFS_rts	; 2/3
      0  2adf					      STRESS_TIME	SEGTIME_BDF
      1  2adf				  -	      IF	TEST_SEGTIME_BDF = 1
      2  2adf				  -
      3  2adf				  -
      4  2adf				  -
      5  2adf				  -
      6  2adf				  -
      7  2adf				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  2adf				  -	      bne	. - 7
      9  2adf					      ENDIF
    976  2adf
    977  2adf		       a9 f4		      lda	#>( DrawFlag + RAM_WRITE )	; 2
    978  2ae1		       85 d9		      sta	BDF_DrawFlagAddress+1	; 3
    979  2ae3		       85 db		      sta	BDF_DrawFlagAddress2+1	; 3
    980  2ae5
    981  2ae5		       ba		      tsx		; 2
    982  2ae6		       86 e2		      stx	DHS_Stack	; 3
    983  2ae8
    984  2ae8		       e6 89		      inc	ScreenDrawPhase	; 5
    985  2aea
    986  2aea		       18		      clc		; 2	     required clear for DrawScreenRowPreparation
    987  2aeb		       a2 08		      ldx	#SCREEN_LINES	; 2
    988  2aed		       8a		      txa		; 2 = 31
    989  2aee
    990  2aee							; fall through
    991  2aee
    992  2aee							;------------------------------------------------------------------------------
    993  2aee
      0  2aee					      DEFINE_SUBROUTINE	DrawScreenRowPreparation	; = 52[-7]
      1  2aee		       00 05	   BANK_DrawScreenRowPreparation =	_CURRENT_BANK
      2  2aee					      SUBROUTINE
      3  2aee				   DrawScreenRowPreparation
    995  2aee
    996  2aee							;clc
    997  2aee		       ca		      dex		; 2
    998  2aef		       86 e1		      stx	DHS_Line	; 3
    999  2af1		       65 96		      adc	BoardScrollY	; 3	     the Y offset of screen into board
   1000  2af3		       a8		      tay		; 2 = 10
   1001  2af4
   1002  2af4							;clc
   1003  2af4		       b9 00 f0 	      lda	BoardLineStartLO-1,y	; 4	     Y is one too big!
   1004  2af7		       65 97		      adc	BoardScrollX	; 3	     the X offset of screen into board
   1005  2af9		       85 dc		      sta	BDF_BoardAddress	; 3
   1006  2afb		       69 05		      adc	#SCREEN_WIDTH/2	; 2
   1007  2afd		       85 de		      sta	BDF_BoardAddress2	; 3
   1008  2aff
   1009  2aff		       b9 16 f0 	      lda	BoardLineStartHiR-1,y	; 4	     a board line *WILL NOT CROSS* page boundary
   1010  2b02		       85 dd		      sta	BDF_BoardAddress+1	; 3
   1011  2b04		       85 df		      sta	BDF_BoardAddress2+1	; 3 = 25
   1012  2b06
   1013  2b06		       bd c0 f0 	      lda	DrawLineStartLO,x	; 4
   1014  2b09		       85 d8		      sta	BDF_DrawFlagAddress	; 3
   1015  2b0b		       69 05		      adc	#SCREEN_WIDTH/2	; 2
   1016  2b0d		       85 da		      sta	BDF_DrawFlagAddress2	; 3 = 12
   1017  2b0f
   1018  2b0f				  -	      IF	MULTI_BANK_BOARD = YES
   1019  2b0f				  -	      lda	BoardBank-1,y	; 4
   1020  2b0f				  -	      sta	BDF_BoardBank	; 3
   1021  2b0f					      ENDIF
   1022  2b0f		       a0 04		      ldy	#SCREEN_WIDTH/2-1	; 2
   1023  2b11		       4c 8b fa 	      jmp	CopyRow2	; 3 = 12[-7]
   1024  2b14
   1025  2b14							;------------------------------------------------------------------------------
   1026  2b14
      0  2b14					      DEFINE_SUBROUTINE	VectorProcess	;=19(A)
      1  2b14		       00 05	   BANK_VectorProcess =	_CURRENT_BANK
      2  2b14					      SUBROUTINE
      3  2b14				   VectorProcess
   1028  2b14
   1029  2b14							;sta ROM_Bank			  ;3		  processors can assume bank is stored
   1030  2b14
   1031  2b14		       bd 24 f3 	      lda	OSPointerHI,x	;4
   1032  2b17		       85 d9		      sta	POS_Vector+1	;3
   1033  2b19		       bd 21 f3 	      lda	OSPointerLO,x	;4
   1034  2b1c		       85 d8		      sta	POS_Vector	;3
   1035  2b1e
   1036  2b1e		       6c d8 00 	      jmp	(POS_Vector)	;5 = 19	 vector to processor for particular object type
   1037  2b21							;		 NOTE: Bank is either INITBANK or FIXED.
   1038  2b21
   1039  2b21
   1040  2b21				   OBJTYPE    SET	0
   1041  2b21					      MAC	define
   1042  2b21				   TYPE_{1}   =	OBJTYPE
   1043  2b21				   OBJTYPE    .SET	OBJTYPE + 1
   1044  2b21					      ENDM
   1045  2b21
   1046  2b21							; If adding/removing types, the following must also be updated...
   1047  2b21							;   InitialFace[...]		     in UnpackLevel.asm
   1048  2b21							;   BaseTypeCharacter[...]	     in BANK_FIXED.asm
   1049  2b21							;   BaseTypeCharacterFalling[...]   in BANK_FIXED.asm
   1050  2b21							;   OSPointerLO[...]		     in BANK_INITBANK.asm
   1051  2b21							;   OSPointerHI[...]		     in BANK_INITBANK.asm
   1052  2b21							;   CharReplacement[...]	     in BANK_ROM_SHADOW_DRAWBUFFERS.asm
   1053  2b21							;   Sortable[...]		     in BANK_FIXED.asm
   1054  2b21
   1055  2b21
      0  2b21					      DEFINE	MAN
      1  2b21		       00 00	   TYPE_MAN   =	OBJTYPE
      2  2b21				   OBJTYPE    .SET	OBJTYPE + 1
      0  2b21					      DEFINE	CIRCLE
      1  2b21		       00 01	   TYPE_CIRCLE =	OBJTYPE
      2  2b21				   OBJTYPE    .SET	OBJTYPE + 1
      0  2b21					      DEFINE	CIRCLE_HELPER
      1  2b21		       00 02	   TYPE_CIRCLE_HELPER =	OBJTYPE
      2  2b21				   OBJTYPE    .SET	OBJTYPE + 1
      0  2b21					      DEFINE	CIRCLE_DRAWER
      1  2b21		       00 03	   TYPE_CIRCLE_DRAWER =	OBJTYPE
      2  2b21				   OBJTYPE    .SET	OBJTYPE + 1
   1060  2b21
      0  2b21					      DEFINE	MAXIMUM
      1  2b21		       00 04	   TYPE_MAXIMUM =	OBJTYPE
      2  2b21				   OBJTYPE    .SET	OBJTYPE + 1
   1062  2b21
   1063  2b21
      0  2b21					      DEFINE_SUBROUTINE	OSPointerLO
      1  2b21		       00 05	   BANK_OSPointerLO =	_CURRENT_BANK
      2  2b21					      SUBROUTINE
      3  2b21				   OSPointerLO
   1065  2b21		       41		      .byte.b	<PROCESS_MAN
   1066  2b22		       db		      .byte.b	<PROCESS_CIRCLE
   1067  2b23		       d1		      .byte.b	<PROCESS_CIRCLE_HELPER
   1068  2b24
   1069  2b24				  -	      IF	* - OSPointerLO < TYPE_MAXIMUM-4
   1070  2b24				  -	      ECHO	"ERROR: Missing entry in OSPointerLO table!"
   1071  2b24				  -	      ERR
   1072  2b24					      ENDIF
   1073  2b24
   1074  2b24
      0  2b24					      DEFINE_SUBROUTINE	OSPointerHI
      1  2b24		       00 05	   BANK_OSPointerHI =	_CURRENT_BANK
      2  2b24					      SUBROUTINE
      3  2b24				   OSPointerHI
   1076  2b24		       f9		      .byte.b	>PROCESS_MAN
   1077  2b25		       f8		      .byte.b	>PROCESS_CIRCLE
   1078  2b26		       f8		      .byte.b	>PROCESS_CIRCLE_HELPER
   1079  2b27
   1080  2b27				  -	      IF	* - OSPointerHI < TYPE_MAXIMUM-4
   1081  2b27				  -	      ECHO	"ERROR: Missing entry in OSPointerHI table!"
   1082  2b27				  -	      ERR
   1083  2b27					      ENDIF
   1084  2b27
   1085  2b27							;------------------------------------------------------------------------------
   1086  2b27
      0  2b27					      DEFINE_SUBROUTINE	MoveVecLO	; [character type]
      1  2b27		       00 05	   BANK_MoveVecLO =	_CURRENT_BANK
      2  2b27					      SUBROUTINE
      3  2b27				   MoveVecLO
   1088  2b27
   1089  2b27		       f0		      .byte.b	<MOVE_BLANK
   1090  2b28		       f0		      .byte.b	<MOVE_SOIL
   1091  2b29		       23		      .byte.b	<MOVE_BOX
   1092  2b2a		       f0		      .byte.b	<MOVE_TARGET
   1093  2b2b		       f0		      .byte.b	<MOVE_TARGET
   1094  2b2c		       1e		      .byte.b	<MOVE_GENERIC	;man occupied
   1095  2b2d		       1e		      .byte.b	<MOVE_GENERIC	;steel
   1096  2b2e		       1e		      .byte.b	<MOVE_GENERIC	;wall
   1097  2b2f		       2e		      .byte.b	<MOVE_BOX_ON_TARGET	;box on target
   1098  2b30		       1e		      .byte.b	<MOVE_GENERIC	;nogo
   1099  2b31
   1100  2b31				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
   1101  2b31				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
   1102  2b31				  -	      ERR
   1103  2b31					      ENDIF
   1104  2b31
   1105  2b31
   1106  2b31
      0  2b31					      DEFINE_SUBROUTINE	MoveVecHI	;[character type]
      1  2b31		       00 05	   BANK_MoveVecHI =	_CURRENT_BANK
      2  2b31					      SUBROUTINE
      3  2b31				   MoveVecHI
   1108  2b31
   1109  2b31		       f9		      .byte.b	>MOVE_BLANK
   1110  2b32		       f9		      .byte.b	>MOVE_SOIL
   1111  2b33		       fa		      .byte.b	>MOVE_BOX
   1112  2b34		       f9		      .byte.b	>MOVE_TARGET
   1113  2b35		       f9		      .byte.b	>MOVE_TARGET
   1114  2b36		       fa		      .byte.b	>MOVE_GENERIC	;man occupied
   1115  2b37		       fa		      .byte.b	>MOVE_GENERIC	;steel
   1116  2b38		       fa		      .byte.b	>MOVE_GENERIC	;wall
   1117  2b39		       fa		      .byte.b	>MOVE_BOX_ON_TARGET	;box on target
   1118  2b3a		       fa		      .byte.b	>MOVE_GENERIC	;nogo
   1119  2b3b
   1120  2b3b				  -	      IF	* - MoveVecLO < CHARACTER_MAXIMUM
   1121  2b3b				  -	      ECHO	"ERROR: Missing entry in MoveVecLO table!"
   1122  2b3b				  -	      EXIT
   1123  2b3b					      ENDIF
   1124  2b3b
   1125  2b3b
      0  2b3b					      CHECK_BANK_SIZE	"INITBANK"
      1  2b3b		       03 3b	   .TEMP      =	* - BANK_START
 INITBANK (2K) SIZE =  $33b , FREE= $4c5
      2  2b3b					      ECHO	"INITBANK", "(2K) SIZE = ", .TEMP, ", FREE=", ROM_BANK_SIZE - .TEMP
      3  2b3b				  -	      if	( .TEMP ) > ROM_BANK_SIZE
      4  2b3b				  -	      ECHO	"BANK OVERFLOW @ ", * - ORIGIN
      5  2b3b				  -	      ERR
      6  2b3b					      endif
------- FILE ./sokoboo.asm
------- FILE BANK_FIXED.asm LEVEL 2 PASS 3
      0  2b3b					      include	"BANK_FIXED.asm"
      1  2b3b							;------------------------------------------------------------------------------
      2  2b3b							;###############################  FIXED BANK  #################################
      3  2b3b							;------------------------------------------------------------------------------
      4  2b3b
      5  2b3b
      6  2b3b				   ORIGIN     SET	FIXED_BANK
      7  2b3b
      0  2b3b					      NEWBANK	THE_FIXED_BANK
      1  7f75 ????				      SEG	THE_FIXED_BANK
      2  7800					      ORG	ORIGIN
      3  7800					      RORG	$F000
      4  7800				   BANK_START SET	*
      5  7800				   THE_FIXED_BANK SET	ORIGIN / 2048
      6  7800				   ORIGIN     SET	ORIGIN + 2048
      7  7800				   _CURRENT_BANK SET	THE_FIXED_BANK
      9  7800					      RORG	$f800
     10  7800
     11  7800
     12  7800
     13  7800							;------------------------------------------------------------------------------
     14  7800
      0  7800					      DEFINE_SUBROUTINE	DrawTimeFromROM
      1  7800		       00 0f	   BANK_DrawTimeFromROM =	_CURRENT_BANK
      2  7800					      SUBROUTINE
      3  7800				   DrawTimeFromROM
     16  7800
     17  7800		       85 3e		      sta	SET_BANK_RAM
     18  7802		       20 f5 f2 	      jsr	DrawTime
     19  7805		       85 3f		      sta	SET_BANK
     20  7807		       60		      rts
     21  7808
      0  7808					      DEFINE_SUBROUTINE	DrawTargetsRequiredFromROM
      1  7808		       00 0f	   BANK_DrawTargetsRequiredFromROM =	_CURRENT_BANK
      2  7808					      SUBROUTINE
      3  7808				   DrawTargetsRequiredFromROM
     23  7808
     24  7808		       85 3e		      sta	SET_BANK_RAM
     25  780a		       20 e0 f2 	      jsr	DrawTargetsRequired
     26  780d		       a5 c2		      lda	ROM_Bank
     27  780f		       85 3f		      sta	SET_BANK
     28  7811		       60		      rts
     29  7812
     30  7812							;------------------------------------------------------------------------------
     31  7812
      0  7812					      DEFINE_SUBROUTINE	GetROMByte	;=23(A)
      1  7812		       00 0f	   BANK_GetROMByte =	_CURRENT_BANK
      2  7812					      SUBROUTINE
      3  7812				   GetROMByte
     33  7812
     34  7812							; a = ROM bank to retrieve
     35  7812							; y = page index
     36  7812							; ROM_Bank = bank to return to
     37  7812							; (Board_AddressR) = page
     38  7812							; out a = byte from (Board_AddressR)
     39  7812
     40  7812		       85 3f		      sta	SET_BANK	;3
     41  7814		       4c 19 f8 	      jmp	GetBoardCharacter2	;3+17(A)	 unconditional
     42  7817
     43  7817							;------------------------------------------------------------------------------
     44  7817
      0  7817					      DEFINE_SUBROUTINE	GetBoardCharacter	;=20(A)
      1  7817		       00 0f	   BANK_GetBoardCharacter =	_CURRENT_BANK
      2  7817					      SUBROUTINE
      3  7817				   GetBoardCharacter
     46  7817
     47  7817							; call from ROM bank
     48  7817							; switches back to ROM_Bank on exit
     49  7817
     50  7817							; pass A = bank containing character
     51  7817							; Y = x character position
     52  7817							; (Board_AddressR) points to character position
     53  7817							; returns character from board
     54  7817
     55  7817
     56  7817		       85 3e		      sta	SET_BANK_RAM	;3   switch to bank to read
     57  7819
     58  7819				   GetBoardCharacter2		;=17(A)
     59  7819
     60  7819		       b3 be		      lax	(Board_AddressR),y	;5
     61  781b		       a4 c2		      ldy	ROM_Bank	;3
     62  781d		       84 3f		      sty	SET_BANK	;3   switch back caller's bank
     63  781f		       60		      rts		;6   and go back
     64  7820
     65  7820							;---------------------------------------------------------------------------
     66  7820
      0  7820					      DEFINE_SUBROUTINE	PutBoardCharacter	;=21(A)
      1  7820		       00 0f	   BANK_PutBoardCharacter =	_CURRENT_BANK
      2  7820					      SUBROUTINE
      3  7820				   PutBoardCharacter
     68  7820
     69  7820		       86 3e		      stx	SET_BANK_RAM	; 3
     70  7822
     71  7822				   PutBoardCharacterSB		; =18
     72  7822		       91 c0		      sta	(Board_AddressW),y	; 6
     73  7824		       a5 c2		      lda	ROM_Bank	; 3
     74  7826		       85 3f		      sta	SET_BANK	; 3
     75  7828		       60		      rts		; 6 = 21
     76  7829
     77  7829							;---------------------------------------------------------------------------
     78  7829
      0  7829					      DEFINE_SUBROUTINE	GetBoardCharacter__CALL_FROM_RAM__	;=61[-2](A)
      1  7829		       00 0f	   BANK_GetBoardCharacter__CALL_FROM_RAM__ =	_CURRENT_BANK
      2  7829					      SUBROUTINE
      3  7829				   GetBoardCharacter__CALL_FROM_RAM__
     80  7829
     81  7829		       a4 8b		      ldy	POS_Y	;3
     82  782b
     83  782b		       a9 05		      lda	#BANK_GetBoardAddressR	;
     84  782d		       85 3f		      sta	SET_BANK	;
     85  782f		       20 db f0 	      jsr	GetBoardAddressR	;11+24[-2](A)
     86  7832
     87  7832
      0  7832					      DEFINE_SUBROUTINE	PartialGetBoardCharacter	;=23
      1  7832		       00 0f	   BANK_PartialGetBoardCharacter =	_CURRENT_BANK
      2  7832					      SUBROUTINE
      3  7832				   PartialGetBoardCharacter
     89  7832
     90  7832
     91  7832		       85 3e		      sta	SET_BANK_RAM	;3
     92  7834		       a4 8a		      ldy	POS_X	;3
     93  7836		       b3 be		      lax	(Board_AddressR),y	;5
     94  7838		       a4 c3		      ldy	RAM_Bank	;3
     95  783a		       84 3e		      sty	SET_BANK_RAM	;3		 return to RAM caller
     96  783c		       60		      rts		;6		 and go back
     97  783d
     98  783d							;---------------------------------------------------------------------------
     99  783d
      0  783d					      DEFINE_SUBROUTINE	PutBoardCharacterFromRAM	;=71[-2]
      1  783d		       00 0f	   BANK_PutBoardCharacterFromRAM =	_CURRENT_BANK
      2  783d					      SUBROUTINE
      3  783d				   PutBoardCharacterFromRAM
    101  783d
    102  783d							; POS_Y  = row
    103  783d							; POS_Type = character to write
    104  783d							; POS_X     = column
    105  783d							; RAM_Bank = caller's bank
    106  783d
    107  783d		       a4 8b		      ldy	POS_Y	;3
    108  783f
    109  783f		       a9 05		      lda	#BANK_GetBoardAddressW	;
    110  7841		       85 3f		      sta	SET_BANK	;
    111  7843		       20 e8 f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
    112  7846
    113  7846		       86 3e		      stx	SET_BANK_RAM	;3
    114  7848
    115  7848		       a4 8a		      ldy	POS_X	;3
    116  784a		       a5 8e		      lda	POS_Type	;3
    117  784c		       91 c0		      sta	(Board_AddressW),y	;6
    118  784e		       a4 c3		      ldy	RAM_Bank	;3
    119  7850		       84 3e		      sty	SET_BANK_RAM	;3 return to RAM caller
    120  7852		       60		      rts		;6
    121  7853
    122  7853
    123  7853							;---------------------------------------------------------------------------
    124  7853
      0  7853					      DEFINE_SUBROUTINE	ProcessObjStack	; 15 minimum segtime abort
      1  7853		       00 0f	   BANK_ProcessObjStack =	_CURRENT_BANK
      2  7853					      SUBROUTINE
      3  7853				   ProcessObjStack
    126  7853
    127  7853		       ad 84 02 	      lda	INTIM	;4
    128  7856		       c9 04		      cmp	#MINIMUM_SEGTIME	;2
    129  7858		       90 3b		      bcc	EarlyAbort	;2/3= 8
      0  785a					      STRESS_TIME	MINIMUM_SEGTIME
      1  785a				  -	      IF	TEST_MINIMUM_SEGTIME = 1
      2  785a				  -
      3  785a				  -
      4  785a				  -
      5  785a				  -
      6  785a				  -
      7  785a				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  785a				  -	      bne	. - 7
      9  785a					      ENDIF
    131  785a
    132  785a		       a5 85		      lda	ObjStackNum	;3
    133  785c		       49 01		      eor	#1	;2
    134  785e		       aa		      tax		;2
    135  785f
    136  785f		       a5 cb		      lda	ObjIterator	;3
    137  7861		       d5 86		      cmp	ObjStackPtr,x	;5
    138  7863		       b0 2e		      bcs	nextPhase	;2/3
    139  7865
    140  7865
    141  7865							; Process an object...
    142  7865							; Actual object code (the handlers) starts 82 cycles after previous segtime check!
    143  7865
    144  7865		       bc c2 f9 	      ldy	BankObjStack,x	;4
    145  7868		       84 3e		      sty	SET_BANK_RAM	;3
    146  786a
    147  786a		       aa		      tax		;2
    148  786b		       bc 80 11 	      ldy	SortedObjPtr,x	;4		 indirect object pointer list (sorted)
    149  786e
    150  786e		       b9 00 10 	      lda	ObjStackX,y	;4
    151  7871		       85 8a		      sta	POS_X	;3
    152  7873		       b9 80 10 	      lda	ObjStackY,y	;4
    153  7876		       85 8b		      sta	POS_Y	;3
    154  7878		       b9 00 11 	      lda	ObjStackVar,y	;4
    155  787b		       85 8f		      sta	POS_VAR	;3
    156  787d		       be 00 12 	      ldx	ObjStackType,y	;4
    157  7880		       86 8e		      stx	POS_Type	;3
    158  7882
    159  7882		       a9 05		      lda	#BANK_VectorProcess	;2
    160  7884		       85 3f		      sta	SET_BANK	;3
    161  7886
    162  7886		       bd 24 f3 	      lda	OSPointerHI,x	;4
    163  7889		       85 d9		      sta	POS_Vector+1	;3
    164  788b		       bd 21 f3 	      lda	OSPointerLO,x	;4
    165  788e		       85 d8		      sta	POS_Vector	;3
    166  7890
    167  7890		       6c d8 00 	      jmp	(POS_Vector)	;5 = 82	 vector to processor for particular object type
    168  7893
    169  7893
    170  7893							;---------------------------------------------------------------------------
    171  7893							; Now process the blank stack.  This stack holds all the recently blanked squares
    172  7893							; and determines (and moves) BOXs or TARGETs into these squares.  The space vacated
    173  7893							; by these objects are added again to the blank stack.
    174  7893
    175  7893				   nextPhase
    176  7893
    177  7893							;clc
    178  7893							;lda circle_d
    179  7893							;adc #255
    180  7893							;sta circle_d
    181  7893							;bcc nocirc
    182  7893
    183  7893
    184  7893
    185  7893				   nocirc
    186  7893
    187  7893		       e6 89		      inc	ScreenDrawPhase	;5		 obj/blank finished -- let the draw stuff proceed
    188  7895		       60	   EarlyAbort rts		;6
    189  7896
    190  7896							;---------------------------------------------------------------------------
    191  7896
      0  7896					      DEFINE_SUBROUTINE	SwitchObjects	;=72
      1  7896		       00 0f	   BANK_SwitchObjects =	_CURRENT_BANK
      2  7896					      SUBROUTINE
      3  7896				   SwitchObjects
    193  7896
    194  7896							; The game loop has come to an end. The only possible "still happening" thing is the sort, which runs
    195  7896							; in parallel with other processes (objects, draw stack, etc). We may or may not want to wait for the
    196  7896							; sort to complete.  This code does all the checks needed to switch to the next game frame.
    197  7896
    198  7896		       ad 84 02 	      lda	INTIM	; 4
    199  7899		       c9 03		      cmp	#SEGTIME_SWITCHOBJECTS	; 2
    200  789b		       90 f8		      bcc	EarlyAbort	; 2/3= 8
      0  789d					      STRESS_TIME	SEGTIME_SWITCHOBJECTS
      1  789d				  -	      IF	TEST_SEGTIME_SWITCHOBJECTS = 1
      2  789d				  -
      3  789d				  -
      4  789d				  -
      5  789d				  -
      6  789d				  -
      7  789d				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  789d				  -	      bne	. - 7
      9  789d					      ENDIF
    202  789d
    203  789d							; If we're undertime, then abort. The sort will continue to run, and that's great. Only when
    204  789d							; we're at the throttle cutoff do we switch game-frames.
    205  789d
    206  789d							;sec
    207  789d		       a5 b6		      lda	Throttle	;3
    208  789f		       e9 a0		      sbc	#MAX_THROTTLE	;2
    209  78a1		       90 f2		      bcc	EarlyAbort	;2/3		 plenty of time left!
    210  78a3
    211  78a3							; Time is up. But we may be in a level which requires perfect sorting
    212  78a3							; So we check for these levels, and wait for the sort to complete for those.
    213  78a3
    214  78a3		       24 b5		      bit	levelDisplay	;3
    215  78a5		       50 08		      bvc	keepFractional	;2/3		 screen does not require complete sort
    216  78a7
    217  78a7							; We have a level which requires the sort to go to completion
    218  78a7							; Check to see if the sort is finished...
    219  78a7
    220  78a7		       a4 ca		      ldy	sortPtr	;3
    221  78a9		       d0 ea		      bne	EarlyAbort	;2/3		 sort still in progress, so wait
    222  78ab		       a4 c9		      ldy	sortRequired	;3
    223  78ad		       10 e6		      bpl	EarlyAbort	;2/3		 sort still in progress, so wait
    224  78af
    225  78af		       85 b6	   keepFractional sta	Throttle	;3		 save fractional 'left over' bit
    226  78b1
    227  78b1							; Pause the game with B/W switch:
    228  78b1
    229  78b1		       a5 80		      lda	gameMode
    230  78b3		       30 14		      bmi	.paused	; pause flag set
    231  78b5
    232  78b5							; Now that we have completed processing the object stack, we switch
    233  78b5							; the stack bank pointers for the next time around.
    234  78b5
    235  78b5		       a5 85		      lda	ObjStackNum	;3
    236  78b7		       49 01		      eor	#1	;2
    237  78b9		       aa		      tax		;2
    238  78ba		       86 85		      stx	ObjStackNum	;3		 swap stacks @here
    239  78bc
    240  78bc							; STOP the sort so it doesn't corrupt the "other" object stack. Sort may get a look-in immediately after
    241  78bc							; this code is finished, so we don't want it to do something unexpected!
    242  78bc
    243  78bc		       a0 ff		      ldy	#<(-1)	;2
    244  78be		       84 c9		      sty	sortRequired	;3
    245  78c0		       c8		      iny		;2		 Y==0
    246  78c1		       84 ca		      sty	sortPtr	;3
    247  78c3
    248  78c3							; Initialise the iterator and stack pointer for next time around.
    249  78c3							; Previously the stack pointer auto-initialised by popping the stack. Now we have an iterator it's
    250  78c3							; necessary to initialise both.
    251  78c3
    252  78c3		       84 cb		      sty	ObjIterator	;3		 Y==0
    253  78c5		       94 86		      sty	ObjStackPtr,x	;4
    254  78c7
    255  78c7		       84 89		      sty	ScreenDrawPhase	;3
    256  78c9				   .paused
    257  78c9		       60	   quickExit  rts		;6
    258  78ca
    259  78ca							;---------------------------------------------------------------------------
    260  78ca
      0  78ca					      DEFINE_SUBROUTINE	PROCESS_CIRCLE_DRAWER
      1  78ca		       00 0f	   BANK_PROCESS_CIRCLE_DRAWER =	_CURRENT_BANK
      2  78ca					      SUBROUTINE
      3  78ca				   PROCESS_CIRCLE_DRAWER
    262  78ca
    263  78ca		       a0 00		      ldy	#CHARACTER_BLANK
    264  78cc		       a5 aa		      lda	circle_d+1
    265  78ce							;jsr DrawCircle
    266  78ce							;bcc finCircle
    267  78ce							;lda #TYPE_CIRCLE_DRAWER
    268  78ce							;sta POS_Type
    269  78ce							;jsr InsertObjectStack
    270  78ce		       4c 87 f9    finCircle  jmp	NextObject
    271  78d1
      0  78d1					      DEFINE_SUBROUTINE	PROCESS_CIRCLE_HELPER
      1  78d1		       00 0f	   BANK_PROCESS_CIRCLE_HELPER =	_CURRENT_BANK
      2  78d1					      SUBROUTINE
      3  78d1				   PROCESS_CIRCLE_HELPER
    273  78d1
    274  78d1		       ad 84 02 	      lda	INTIM
    275  78d4		       c9 0a		      cmp	#SEGTIME_CIRCLE_HELPER
    276  78d6		       90 bd		      bcc	EarlyAbort
    277  78d8
    278  78d8
    279  78d8		       4c 87 f9 	      jmp	NextObject	; and die
    280  78db
    281  78db
      0  78db					      DEFINE_SUBROUTINE	PROCESS_CIRCLE
      1  78db		       00 0f	   BANK_PROCESS_CIRCLE =	_CURRENT_BANK
      2  78db					      SUBROUTINE
      3  78db				   PROCESS_CIRCLE
    283  78db
    284  78db		       ad 84 02 	      lda	INTIM
    285  78de		       c9 0a		      cmp	#SEGTIME_CIRCLE
    286  78e0		       90 b3		      bcc	EarlyAbort
    287  78e2
    288  78e2		       18		      clc
    289  78e3		       a5 a9		      lda	circle_d
    290  78e5		       69 19		      adc	#25
    291  78e7		       85 a9		      sta	circle_d
    292  78e9		       90 4b		      bcc	inactiveCircle
    293  78eb
    294  78eb		       e6 aa		      inc	circle_d+1
    295  78ed		       a5 aa		      lda	circle_d+1
    296  78ef		       c9 14		      cmp	#20
    297  78f1		       f0 4a		      beq	circleComplete
    298  78f3							; time to fire off another "ring" of the clearing circle
    299  78f3
    300  78f3							;sta POS_VAR		    ; diameter for helper to use
    301  78f3							;lda #TYPE_CIRCLE_HELPER
    302  78f3							;sta POS_Type
    303  78f3							;jsr InsertObjectStack
    304  78f3
    305  78f3
    306  78f3							; a = radius
    307  78f3
    308  78f3		       a0 00		      ldy	#CHARACTER_BLANK
    309  78f5		       84 ad		      sty	circ_char
    310  78f7
    311  78f7		       a5 aa		      lda	circle_d+1
    312  78f9		       38		      sec
    313  78fa		       e9 01		      sbc	#1
    314  78fc		       85 ab		      sta	circ_x
    315  78fe		       49 ff		      eor	#255
    316  7900		       18		      clc
    317  7901		       69 01		      adc	#1
    318  7903		       85 ae		      sta	circ_scratch	; "d" --> "1-r" in unit terms
    319  7905
    320  7905		       a9 00		      lda	#0
    321  7907		       85 ac		      sta	circ_y
    322  7909
    323  7909		       a5 aa		      lda	circle_d+1	; radius
    324  790b		       a9 03		      lda	#TYPE_CIRCLE_DRAWER
    325  790d		       85 8e		      sta	POS_Type
    326  790f							;jsr InsertObjectStack
    327  790f
    328  790f		       a0 00		      ldy	#CHARACTER_BLANK
    329  7911		       a5 aa		      lda	circle_d+1
    330  7913		       38		      sec
    331  7914		       e9 01		      sbc	#1
    332  7916		       20 fa fd 	      jsr	DrawCircle
    333  7919
    334  7919		       a0 06		      ldy	#CHARACTER_STEEL
    335  791b		       84 ad		      sty	circ_char
    336  791d		       a5 aa		      lda	circle_d+1
    337  791f		       85 ab		      sta	circ_x
    338  7921		       49 ff		      eor	#255
    339  7923		       18		      clc
    340  7924		       69 01		      adc	#1
    341  7926		       85 ae		      sta	circ_scratch	; "d" --> "1-r" in unit terms
    342  7928
    343  7928		       a9 00		      lda	#0
    344  792a		       85 ac		      sta	circ_y
    345  792c
    346  792c		       a5 aa		      lda	circle_d+1	; radius
    347  792e		       a9 03		      lda	#TYPE_CIRCLE_DRAWER
    348  7930		       85 8e		      sta	POS_Type
    349  7932							;jsr InsertObjectStack
    350  7932
    351  7932		       a0 00		      ldy	#CHARACTER_BLANK
    352  7934		       a5 aa		      lda	circle_d+1
    353  7936							;jsr DrawCircle
    354  7936
    355  7936
    356  7936
    357  7936							;			      inc circle_d+1
    358  7936							;			      ldy #CHARACTER_STEEL
    359  7936							;			      lda circle_d+1
    360  7936							;			      jsr DrawCircle
    361  7936
    362  7936		       a9 01	   inactiveCircle lda	#TYPE_CIRCLE
    363  7938		       85 8e		      sta	POS_Type
    364  793a		       20 94 f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    365  793d
    366  793d		       4c 87 f9    circleComplete jmp	NextObject
    367  7940
    368  7940							;---------------------------------------------------------------------------
    369  7940
    370  7940		       60	   EarlyAbort4 rts
    371  7941
      0  7941					      DEFINE_SUBROUTINE	PROCESS_MAN
      1  7941		       00 0f	   BANK_PROCESS_MAN =	_CURRENT_BANK
      2  7941					      SUBROUTINE
      3  7941				   PROCESS_MAN
    373  7941
    374  7941		       ad 84 02 	      lda	INTIM
    375  7944		       c9 18		      cmp	#SEGTIME_MAN
    376  7946		       90 f8		      bcc	EarlyAbort4
      0  7948					      STRESS_TIME	SEGTIME_MAN
      1  7948				  -	      IF	TEST_SEGTIME_MAN = 1
      2  7948				  -
      3  7948				  -
      4  7948				  -
      5  7948				  -
      6  7948				  -
      7  7948				  -	      echo	"***** WARNING! STRESS_TIME enabled @", ., "! *****"
      8  7948				  -	      bne	. - 7
      9  7948					      ENDIF
    378  7948
    379  7948		       a9 05		      lda	#BANK_ManProcess
    380  794a		       85 c2		      sta	ROM_Bank
    381  794c		       85 3f		      sta	SET_BANK
    382  794e		       20 85 f1 	      jsr	ManProcess
    383  7951
    384  7951		       20 c4 f9 	      jsr	MovePlayer	; 6+{}
    385  7954
    386  7954		       a9 03		      lda	#BANK_TrackPlayer	;
    387  7956		       85 3f		      sta	SET_BANK	;
    388  7958		       20 ae f3 	      jsr	TrackPlayer	;11+145
    389  795b
    390  795b		       a9 00		      lda	#TYPE_MAN	; 2
    391  795d		       85 8e		      sta	POS_Type	; 3
    392  795f
    393  795f		       20 94 f9 	      jsr	InsertObjectStack	; 6+76(B)	    re-insert man (POS X/Y DOESN'T MATTER)
    394  7962		       4c 87 f9    gnobj      jmp	NextObject
    395  7965
    396  7965							;---------------------------------------------------------------------------
    397  7965
      0  7965					      DEFINE_SUBROUTINE	RestoreOriginalCharacter	;=93[-2](A)
      1  7965		       00 0f	   BANK_RestoreOriginalCharacter =	_CURRENT_BANK
      2  7965					      SUBROUTINE
      3  7965				   RestoreOriginalCharacter
    399  7965
    400  7965		       a6 8b		      ldx	POS_Y	;3
    401  7967		       a4 8a		      ldy	POS_X	;3
    402  7969
    403  7969		       a9 05		      lda	#BANK_BoardLineStartLO	;2
    404  796b		       85 3f		      sta	SET_BANK	;3
    405  796d
    406  796d		       bd 01 f0 	      lda	BoardLineStartLO,x	;4
    407  7970		       85 c0		      sta	Board_AddressW	;3
    408  7972		       bd 2d f0 	      lda	BoardLineStartHiW,x	;4
    409  7975		       85 c1		      sta	Board_AddressW+1	;3 WRITE address
    410  7977				  -	      IF	MULTI_BANK_BOARD = YES
    411  7977				  -	      lda	BoardBank,x	;4 switch this on return
    412  7977					      ELSE
    413  7977		       a9 0d		      lda	#BANK_BOARD	;2
    414  7979					      ENDIF
    415  7979		       85 3e		      sta	SET_BANK_RAM	;3
    416  797b
    417  797b		       a5 8f		      lda	POS_VAR
    418  797d		       91 c0		      sta	(Board_AddressW),y	;6 clear vacated board position
    419  797f
    420  797f		       a5 c2		      lda	ROM_Bank	;3
    421  7981		       85 3f		      sta	SET_BANK	;3
    422  7983		       60	   EarlyAbortBOX rts		;6
    423  7984
    424  7984
    425  7984							;---------------------------------------------------------------------------
    426  7984
    427  7984							; IF the creature runs out of time to do stuff, then rts HOWEVER the creature must eventually do something
    428  7984							;  as it will be continually called in available time-slices until it does. This can lockup the system.
    429  7984
    430  7984							; if the creature is done, and is alive next cycle, then jump ReInsertObject
    431  7984
    432  7984							; if the creature dies then jump NextObject
    433  7984
    434  7984
    435  7984		       20 94 f9    ReInsertObject jsr	InsertObjectStack	; 6+76(B)  = 98 (if jumping here)	  place on stack so it keeps moving
    436  7987
    437  7987		       e6 cb	   NextObject inc	ObjIterator	; 5
    438  7989							;		  dec ObjStackPtr,x		  ; 6
    439  7989		       4c 53 f8 	      jmp	ProcessObjStack	; 3 = 16
    440  798c
    441  798c							;---------------------------------------------------------------------------
    442  798c
      0  798c					      DEFINE_SUBROUTINE	InsertObjectStackFromRAM	;=94(B)
      1  798c		       00 0f	   BANK_InsertObjectStackFromRAM =	_CURRENT_BANK
      2  798c					      SUBROUTINE
      3  798c				   InsertObjectStackFromRAM
    444  798c
    445  798c		       20 94 f9 	      jsr	InsertObjectStack	;6+76(B)
    446  798f		       a5 c3		      lda	RAM_Bank	;3
    447  7991		       85 3e		      sta	SET_BANK_RAM	;3
    448  7993
    449  7993		       60	   NotEnoughTime rts		;6
    450  7994
    451  7994							;---------------------------------------------------------------------------
    452  7994
      0  7994					      DEFINE_SUBROUTINE	InsertObjectStack	;=81(B)
      1  7994		       00 0f	   BANK_InsertObjectStack =	_CURRENT_BANK
      2  7994					      SUBROUTINE
      3  7994				   InsertObjectStack
    454  7994							; POS_X     x position
    455  7994							; POS_Y     y position
    456  7994							; POS_VAR   direction or other variable
    457  7994							; POS_Type  type of object
    458  7994
    459  7994		       a6 85		      ldx	ObjStackNum	; 3
    460  7996		       bc c2 f9 	      ldy	BankObjStack,x	; 4
    461  7999		       84 3e		      sty	SET_BANK_RAM	; 3
    462  799b		       b4 86		      ldy	ObjStackPtr,x	; 4 = 14
    463  799d
    464  799d
    465  799d		       a5 8b		      lda	POS_Y	; 3
    466  799f		       99 80 14 	      sta	ObjStackY+RAM_WRITE,y	; 5
    467  79a2		       a5 8a		      lda	POS_X	; 3
    468  79a4		       99 00 14 	      sta	ObjStackX+RAM_WRITE,y	; 5
    469  79a7		       a5 8f		      lda	POS_VAR	; 3
    470  79a9		       99 00 15 	      sta	ObjStackVar+RAM_WRITE,y	; 5
    471  79ac		       a5 8e		      lda	POS_Type	; 3
    472  79ae		       99 00 16 	      sta	ObjStackType+RAM_WRITE,y	; 5 = 32
    473  79b1
    474  79b1							; Nice addition limits overflow of the stack, BUT always reserves a spot for the man.
    475  79b1							; Objects are unceremoniously dumped when there's not enough space.  This is just trying to cater
    476  79b1							; for a no-win situation. Try and preserve the player at the cost of correct gameplay. Avoid crashing.
    477  79b1
    478  79b1
    479  79b1				  -	      IF	TYPE_MAN != 0
    480  79b1				  -	      cmp	#TYPE_MAN	; 2
    481  79b1					      ENDIF
    482  79b1		       f0 04		      beq	alwaysAllowMan	; 2/3
    483  79b3
    484  79b3		       c0 7e		      cpy	#OBJ_STACK_SIZE-2	; 2	     reserve 1 last-gasp slot for man only
    485  79b5		       b0 06		      bcs	insertDone	; 2/3= 6    no room -- drop object
    486  79b7				   alwaysAllowMan
    487  79b7
    488  79b7		       98		      tya		; 2
    489  79b8		       99 80 15 	      sta	SortedObjPtr+RAM_WRITE,y	; 5	     indirection pointer for later sorting
    490  79bb
    491  79bb		       f6 86		      inc	ObjStackPtr,x	; 7	     overflow is assumed not to happen!
    492  79bd
    493  79bd		       a4 c2	   insertDone ldy	ROM_Bank	; 3
    494  79bf		       84 3f		      sty	SET_BANK	; 3
    495  79c1
    496  79c1				   ManIsDead2
    497  79c1
    498  79c1
    499  79c1
    500  79c1		       60		      rts		; 6 = 29
    501  79c2
    502  79c2							;---------------------------------------------------------------------------
    503  79c2
    504  79c2		       0b 0c	   BankObjStack .byte.b	BANK_OBJSTACK, BANK_OBJSTACK2
    505  79c4
    506  79c4							;---------------------------------------------------------------------------
    507  79c4
    508  79c4				   MovePlayer
    509  79c4		       a5 9f		      lda	ManMode
    510  79c6		       c9 02		      cmp	#MANMODE_DEAD
    511  79c8		       b0 f7		      bcs	ManIsDead2
    512  79ca
    513  79ca		       a4 8d		      ldy	POS_Y_NEW
    514  79cc
    515  79cc		       a9 05		      lda	#BANK_GetBoardAddressRW	;2
    516  79ce		       85 3f		      sta	SET_BANK	;3
    517  79d0		       85 c2		      sta	ROM_Bank	;3
    518  79d2		       20 c8 f0 	      jsr	GetBoardAddressRW	;6+32[-2]
    519  79d5				  -	      IF	MULTI_BANK_BOARD = YES
    520  79d5				  -	      stx	RAM_Bank
    521  79d5					      ENDIF
    522  79d5		       86 3e		      stx	SET_BANK_RAM	; 3
    523  79d7
    524  79d7		       a4 8c		      ldy	POS_X_NEW
    525  79d9		       b3 be		      lax	(Board_AddressR),y
    526  79db
    527  79db		       a9 05		      lda	#BANK_MoveVecLO
    528  79dd		       85 3f		      sta	SET_BANK
    529  79df
    530  79df		       bd 27 f3 	      lda	MoveVecLO,x
    531  79e2		       85 d8		      sta	MAN_Move
    532  79e4		       bd 31 f3 	      lda	MoveVecHI,x
    533  79e7		       85 d9		      sta	MAN_Move+1
    534  79e9
    535  79e9				  -	      IF	MULTI_BANK_BOARD = YES
    536  79e9				  -	      lda	RAM_Bank
    537  79e9					      ELSE
    538  79e9		       a9 0d		      lda	#BANK_BOARD
    539  79eb					      ENDIF
    540  79eb		       85 3e		      sta	SET_BANK_RAM
    541  79ed		       6c d8 00 	      jmp	(MAN_Move)
    542  79f0
    543  79f0							;---------------------------------------------------------------------------
    544  79f0
      0  79f0					      DEFINE_SUBROUTINE	MOVE_BLANK
      1  79f0		       00 0f	   BANK_MOVE_BLANK =	_CURRENT_BANK
      2  79f0					      SUBROUTINE
      3  79f0				   MOVE_BLANK
      0  79f0					      DEFINE_SUBROUTINE	MOVE_SOIL
      1  79f0		       00 0f	   BANK_MOVE_SOIL =	_CURRENT_BANK
      2  79f0					      SUBROUTINE
      3  79f0				   MOVE_SOIL
      0  79f0					      DEFINE_SUBROUTINE	MOVE_TARGET
      1  79f0		       00 0f	   BANK_MOVE_TARGET =	_CURRENT_BANK
      2  79f0					      SUBROUTINE
      3  79f0				   MOVE_TARGET
    548  79f0
    549  79f0		       a4 8c		      ldy	POS_X_NEW
    550  79f2		       b1 be		      lda	(Board_AddressR),y	; what's on the board under man?
    551  79f4		       48		      pha
    552  79f5
    553  79f5		       a9 05		      lda	#CHARACTER_MANOCCUPIED
    554  79f7		       91 c0		      sta	(Board_AddressW),y
    555  79f9
    556  79f9		       a6 9c		      ldx	ManY
    557  79fb		       86 8b		      stx	POS_Y
    558  79fd		       a4 9b		      ldy	ManX
    559  79ff		       84 8a		      sty	POS_X
    560  7a01
    561  7a01		       20 65 f9 	      jsr	RestoreOriginalCharacter
    562  7a04
    563  7a04		       68		      pla
    564  7a05		       85 8f		      sta	POS_VAR	; save 'restore' characte
    565  7a07
    566  7a07		       a5 8c		      lda	POS_X_NEW
    567  7a09		       85 9b		      sta	ManX
    568  7a0b		       a5 8d		      lda	POS_Y_NEW
    569  7a0d		       85 9c		      sta	ManY	; actually MOVE!
    570  7a0f
    571  7a0f							; Move counter..
    572  7a0f
    573  7a0f		       f8		      sed
    574  7a10		       18		      clc
    575  7a11		       a5 b9		      lda	moveCounter
    576  7a13		       69 01		      adc	#1
    577  7a15		       85 b9		      sta	moveCounter
    578  7a17		       a5 ba		      lda	moveCounter+1
    579  7a19		       69 00		      adc	#0
    580  7a1b		       85 ba		      sta	moveCounter+1
    581  7a1d		       d8		      cld
    582  7a1e
    583  7a1e		       a9 00	   MOVE_GENERIC lda	#0	; 2
    584  7a20		       85 a5		      sta	ManPushCounter	; 3
    585  7a22
    586  7a22		       60	   timeExit   rts		; 6 = 11
    587  7a23
    588  7a23							;---------------------------------------------------------------------------
    589  7a23
      0  7a23					      DEFINE_SUBROUTINE	MOVE_BOX
      1  7a23		       00 0f	   BANK_MOVE_BOX =	_CURRENT_BANK
      2  7a23					      SUBROUTINE
      3  7a23				   MOVE_BOX
    591  7a23
    592  7a23		       a2 00		      ldx	#CHARACTER_BLANK	; restoration character
    593  7a25		       a9 05		      lda	#BANK_PushBox
    594  7a27		       85 c2		      sta	ROM_Bank
    595  7a29		       85 3f		      sta	SET_BANK
    596  7a2b		       4c f5 f0 	      jmp	PushBox
    597  7a2e
      0  7a2e					      DEFINE_SUBROUTINE	MOVE_BOX_ON_TARGET
      1  7a2e		       00 0f	   BANK_MOVE_BOX_ON_TARGET =	_CURRENT_BANK
      2  7a2e					      SUBROUTINE
      3  7a2e				   MOVE_BOX_ON_TARGET
    599  7a2e
    600  7a2e		       a2 03		      ldx	#CHARACTER_TARGET	; restoration character
    601  7a30		       a9 05		      lda	#BANK_PushBox
    602  7a32		       85 c2		      sta	ROM_Bank
    603  7a34		       85 3f		      sta	SET_BANK
    604  7a36		       4c f5 f0 	      jmp	PushBox
    605  7a39
    606  7a39							;---------------------------------------------------------------------------
    607  7a39
      0  7a39					      DEFINE_SUBROUTINE	StealCharDraw	; in FIXED_BANK
      1  7a39		       00 0f	   BANK_StealCharDraw =	_CURRENT_BANK
      2  7a39					      SUBROUTINE
      3  7a39				   StealCharDraw
    609  7a39
    610  7a39		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    611  7a3b		       85 3e		      sta	SET_BANK_RAM	; 3
    612  7a3d		       a4 84		      ldy	DrawStackPointer	; 3	     MUST have been set by BuildDrawStack!
    613  7a3f		       10 35		      bpl	EnterStealCharDraw	; 3 = 10(11)
    614  7a41
    615  7a41				   ExitStealCharDraw
    616  7a41
    617  7a41							; fall through...
    618  7a41
    619  7a41							;---------------------------------------------------------------------------
    620  7a41
      0  7a41					      DEFINE_SUBROUTINE	TimeSlice
      1  7a41		       00 0f	   BANK_TimeSlice =	_CURRENT_BANK
      2  7a41					      SUBROUTINE
      3  7a41				   TimeSlice
    622  7a41
    623  7a41							; FIRST check the time is sufficient for the smallest of the timeslices. Not much point
    624  7a41							; going ahead if there's insufficient time. This allows the previous character drawing to
    625  7a41							; be much smaller in time, as they don't have to include the timeslice code overhead.
    626  7a41
    627  7a41		       ad 84 02 	      lda	INTIM	; 4
    628  7a44		       c9 05		      cmp	#SEGTIME_MINIMUM_TIMESLICE	; 2
    629  7a46		       90 da		      bcc	timeExit	; 2(3)
    630  7a48
    631  7a48							; Uses the phase variable to vector to the correct processing code for the given timeslice
    632  7a48							; Code may be in any bank. Avoid the fixed bank at all costs!	Once a section is complete
    633  7a48							; it should increment ScreenDrawPhase.
    634  7a48
    635  7a48							; Switched-in bank(s) are undefined after this function is called!
    636  7a48
    637  7a48		       a9 03		      lda	#BANK_TS_PhaseVectorLO	; 2
    638  7a4a		       85 3f		      sta	SET_BANK	; 3
    639  7a4c
    640  7a4c		       a6 89		      ldx	ScreenDrawPhase	; 3		 current phase of drawing
    641  7a4e		       bd 35 f4 	      lda	TS_PhaseVectorLO,x	; 4
    642  7a51		       85 d8		      sta	TS_Vector	; 3
    643  7a53		       bd 3a f4 	      lda	TS_PhaseVectorHI,x	; 4
    644  7a56		       85 d9		      sta	TS_Vector+1	; 3
    645  7a58
    646  7a58		       bd 3f f4 	      lda	TS_PhaseBank,x	; 4
    647  7a5b		       85 3f		      sta	SET_BANK	; 3		 switch bank
    648  7a5d
    649  7a5d		       6c d8 00 	      jmp	(TS_Vector)	; 3 = 40	 vector to timeslice handler
    650  7a60
    651  7a60							; = 55 minimum return time (if segtime abort)
    652  7a60
    653  7a60							;---------------------------------------------------------------------------
    654  7a60
    655  7a60
    656  7a60				   DrawAnother
    657  7a60
    658  7a60		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2	     A = SCREEN_LINES
    659  7a62		       85 3e		      sta	SET_BANK_RAM	; 3 =	5
    660  7a64
    661  7a64		       a4 84		      ldy	DrawStackPointer	; 3 =	3    MUST have been set by BuildDrawStack!
    662  7a66
    663  7a66		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    664  7a69		       bd a0 f0 	      lda	ScreenBuffer,x	; 4	     new character to draw
    665  7a6c		       29 7f		      and	#~128	; 2
    666  7a6e		       9d a0 f4 	      sta	ScreenBuffer+RAM_WRITE,x	; 4 = 14    clear hint bit
    667  7a71
    668  7a71		       88		      dey		; 2
    669  7a72		       84 84		      sty	DrawStackPointer	; 3	     one less to draw
    670  7a74		       30 cb		      bmi	ExitStealCharDraw	; 2(3)=7
    671  7a76
    672  7a76				   EnterStealCharDraw		;	     RAM bank MUST be at BANK_DRAW_BUFFERS
    673  7a76
    674  7a76		       ad 84 02 	      lda	INTIM	; 4
    675  7a79		       c9 05		      cmp	#SEGTIME_SCD_MIN	; 2
    676  7a7b		       90 c4		      bcc	ExitStealCharDraw	; 2/3= 8
    677  7a7d
    678  7a7d		       be 00 f0 	      ldx	DrawStack,y	; 4	     in actuality a character index
    679  7a80		       bc a0 f0 	      ldy	ScreenBuffer,x	; 4 =	8    new character to draw
    680  7a83
    681  7a83		       bd 00 f2 	      lda	ROW_BankChar,x	; 4	     A = 0..SCREEN_LINES-1
    682  7a86		       85 3e		      sta	SET_BANK_RAM	; 3
    683  7a88		       4c 53 f1 	      jmp	StealPart3	; 3 = 10    --> 18 cycles after check for SEGTIME_SCD_MIN
    684  7a8b
    685  7a8b
    686  7a8b
    687  7a8b
      0  7a8b					      DEFINE_SUBROUTINE	DrawFullScreenMain	;=2484[-89]
      1  7a8b		       00 0f	   BANK_DrawFullScreenMain =	_CURRENT_BANK
      2  7a8b					      SUBROUTINE
      3  7a8b				   DrawFullScreenMain
    689  7a8b
    690  7a8b							; Check the screen for all those characters that need to be redrawn
    691  7a8b							; Just copies the mxn grid from the board to a DrawFlags array.  If the entry in
    692  7a8b							; the drawflags array is different to the ScreenBuffer array entry, then the
    693  7a8b							; screenbuffer will need redrawing.
    694  7a8b
    695  7a8b				   CopyRow2
    696  7a8b
    697  7a8b				  -	      IF	MULTI_BANK_BOARD = YES
    698  7a8b				  -	      lda	BDF_BoardBank	; 3
    699  7a8b					      ELSE
    700  7a8b		       a9 0d		      lda	#BANK_BOARD	; 2	 saves 5*8 = 40 cyles
    701  7a8d					      ENDIF
    702  7a8d		       85 3e		      sta	SET_BANK_RAM	; 3
    703  7a8f		       b3 dc		      lax	(BDF_BoardAddress),y	; 5
    704  7a91		       9a		      txs		; 2
    705  7a92		       b3 de		      lax	(BDF_BoardAddress2),y	; 5(= 18[-1])
    706  7a94
    707  7a94		       a9 08		      lda	#BANK_DRAW_BUFFERS	; 2
    708  7a96		       85 3e		      sta	SET_BANK_RAM	; 3
    709  7a98		       bd d1 f1 	      lda	CharReplacement,x	; 4
    710  7a9b		       91 da		      sta	(BDF_DrawFlagAddress2),y	; 6
    711  7a9d		       ba		      tsx		; 2
    712  7a9e		       bd d1 f1 	      lda	CharReplacement,x	; 4
    713  7aa1		       91 d8		      sta	(BDF_DrawFlagAddress),y	; 6(= 27)
    714  7aa3
    715  7aa3		       88		      dey		; 2
    716  7aa4		       10 e5		      bpl	CopyRow2	; 2/3=49/50[-1]
    717  7aa6							; total: 5*49[-1]-1 = 244[-5]
    718  7aa6
    719  7aa6		       a7 e1		      lax	DHS_Line	; 3
    720  7aa8		       f0 07		      beq	.exitCopy	; 2/3= 5/6
    721  7aaa
    722  7aaa		       a0 05		      ldy	#BANK_DrawScreenRowPreparation	;2
    723  7aac		       84 3f		      sty	SET_BANK	; 3
    724  7aae		       4c ee f2 	      jmp	DrawScreenRowPreparation	;55[-7] = 60[-7]
    725  7ab1
    726  7ab1							; total: (244[-5]+5)*8 + 60[-7]*7 + 1 + 11 = 2424[-89]
    727  7ab1
    728  7ab1
      0  7ab1					      CHECKPAGEX	CopyRow2, "CopyRow2 in BANK_FIXED.asm"
      9  7ab1					      LIST	ON
    730  7ab1
    731  7ab1		       a6 e2	   .exitCopy  ldx	DHS_Stack	; 3
    732  7ab3		       9a		      txs		; 2
    733  7ab4
    734  7ab4							; fall through
    735  7ab4
      0  7ab4					      DEFINE_SUBROUTINE	BuildDrawStack
      1  7ab4		       00 0f	   BANK_BuildDrawStack =	_CURRENT_BANK
      2  7ab4					      SUBROUTINE
      3  7ab4				   BuildDrawStack
    737  7ab4
    738  7ab4		       a9 08		      lda	#BANK_DRAW_BUFFERS
    739  7ab6		       85 3e		      sta	SET_BANK_RAM
    740  7ab8		       4c f1 f0 	      jmp	DrawStackUpdate
    741  7abb
    742  7abb							;---------------------------------------------------------------------------
    743  7abb
      0  7abb					      DEFINE_SUBROUTINE	DrawAIntoStack
      1  7abb		       00 0f	   BANK_DrawAIntoStack =	_CURRENT_BANK
      2  7abb					      SUBROUTINE
      3  7abb				   DrawAIntoStack
    745  7abb
    746  7abb		       a9 08		      lda	#BANK_DRAW_BUFFERS
    747  7abd		       85 3e		      sta	SET_BANK_RAM
    748  7abf		       4c 1c f1 	      jmp	DrawIntoStack
    749  7ac2
    750  7ac2
    751  7ac2							;---------------------------------------------------------------------------
    752  7ac2
    753  7ac2
    754  7ac2				   Reset
      0  7ac2					      CLEAN_START
      1  7ac2		       78		      sei
      2  7ac3		       d8		      cld
      3  7ac4
      4  7ac4		       a2 00		      ldx	#0
      5  7ac6		       8a		      txa
      6  7ac7		       a8		      tay
      7  7ac8		       ca	   .CLEAR_STACK dex
      8  7ac9		       9a		      txs
      9  7aca		       48		      pha
     10  7acb		       d0 fb		      bne	.CLEAR_STACK
     11  7acd
    756  7acd
    757  7acd							; Scoring bank is copied once (not per game, not per level...)
    758  7acd							; otherwise non-SaveKey high score gets zapped
    759  7acd
    760  7acd		       a2 02		      ldx	#ROM_SHADOW_OF_BANK_SCORING
    761  7acf		       a0 09		      ldy	#BANK_SCORING
    762  7ad1		       20 de fc 	      jsr	CopyROM2RAM_F000
    763  7ad4
    764  7ad4				   Restart		; go here on RESET + SELECT
    765  7ad4
    766  7ad4
    767  7ad4				   Title
    768  7ad4		       a2 ff		      ldx	#$ff	; adjust stack pointer after RESET + SELECT
    769  7ad6		       9a		      txs
    770  7ad7
    771  7ad7							; temporary vars from title screen are used to init level
    772  7ad7		       a9 03		      lda	#BANK_Cart_Init	; 2
    773  7ad9		       85 3f		      sta	SET_BANK	; 3
    774  7adb		       20 b9 f2 	      jsr	Cart_Init	; 6+x
    775  7ade
    776  7ade
    777  7ade							;---------------------------------------------------------------------------
    778  7ade
    779  7ade
    780  7ade		       f0 00	   SEGMENT_DECODE_LEVEL_SHADOW =	$F000	; if not = $F000, this will cause an assertion failure
    781  7ade
    782  7ade		       a2 03		      ldx	#BANK_DECODE_LEVEL_SHADOW
    783  7ae0		       a0 0a		      ldy	#BANK_DECODE_LEVEL
    784  7ae2		       20 de fc 	      jsr	CopyROM2RAM_F000
    785  7ae5
    786  7ae5
    787  7ae5							;---------------------------------------------------------------------------
    788  7ae5							; Once-only game initialisation goes here...
    789  7ae5							; now we have two players so things get a bit tricky
    790  7ae5
    791  7ae5		       a9 09		      lda	#BANK_SCORING
    792  7ae7		       85 3e		      sta	SET_BANK_RAM
    793  7ae9		       20 82 f3 	      jsr	GameInitialise
    794  7aec
    795  7aec
    796  7aec							;---------------------------------------------------------------------------
    797  7aec
    798  7aec				   RestartLevelNextPlayer
    799  7aec
    800  7aec
    801  7aec							; a player has lost a life.
    802  7aec							; store his vars, swap to other player, continue
    803  7aec
    804  7aec							;lda #BANK_SCORING
    805  7aec							;sta SET_BANK_RAM
    806  7aec							;jsr SwapPlayers
    807  7aec
    808  7aec		       a9 03		      lda	#BANK_SwapPlayersGeneric
    809  7aee		       85 3f		      sta	SET_BANK
    810  7af0		       20 10 f3 	      jsr	SwapPlayersGeneric
    811  7af3
    812  7af3				   NextLevelLevel
    813  7af3				   skipDemoCheck
    814  7af3
    815  7af3							; Initialise all in-game variables; those that must be re-initialised at the start of each level,
    816  7af3							; including those for general systems function. But NOT those which do not need re-initialising between
    817  7af3							; levels.
    818  7af3		       a9 03		      lda	#BANK_LevelInit	; 2
    819  7af5		       85 3f		      sta	SET_BANK	; 3
    820  7af7		       20 5f f3 	      jsr	LevelInit	; 6+x
    821  7afa
    822  7afa		       a9 00		      lda	#0
    823  7afc		       85 d8		      sta	base_x
    824  7afe		       85 d9		      sta	base_y
    825  7b00
    826  7b00		       a9 0a		      lda	#BANK_DECODE_LEVEL
    827  7b02		       85 3e		      sta	SET_BANK_RAM
    828  7b04		       20 4f f1 	      jsr	UnpackLevel
    829  7b07
    830  7b07							; TODO now we KNOW the width, we can set the top left accordingly and re-unpack
    831  7b07
    832  7b07		       a9 28		      lda	#SIZE_BOARD_X
    833  7b09		       85 94		      sta	BoardLimit_Width
    834  7b0b		       a9 16		      lda	#SIZE_BOARD_Y
    835  7b0d		       85 95		      sta	BoardLimit_Height
    836  7b0f
    837  7b0f							; Setup player animation and scroll limits.
    838  7b0f							; Mangle the board colours based on level
    839  7b0f
    840  7b0f		       a9 03		      lda	#BANK_CreateCreatures	; 2
    841  7b11		       85 3f		      sta	SET_BANK	; 3
    842  7b13		       20 28 f3 	      jsr	CreateCreatures	; 6+x
    843  7b16
    844  7b16
    845  7b16							; Setup the various digit and display pointers
    846  7b16							; Grab current player's score/level from backup
    847  7b16
    848  7b16		       20 d2 fc 	      jsr	goGeneralScoringSetups
    849  7b19
    850  7b19							; copy the screen draw ROM shadow to RAM
    851  7b19
    852  7b19		       a0 07		      ldy	#SCREEN_LINES-1
    853  7b1b		       a2 00	   CopyScreenBanks ldx	#ROM_SHADOW_OF_RAMBANK_CODE
    854  7b1d		       20 de fc 	      jsr	CopyROM2RAM_F000	; copy draw ROMShadow to RAM
    855  7b20		       20 77 f0 	      jsr	SetPlatformColours	; set NTSC or PAL RGB values for draw + index
    856  7b23		       88		      dey
    857  7b24		       10 f5		      bpl	CopyScreenBanks
    858  7b26
    859  7b26		       a2 01		      ldx	#ROM_SHADOW_OF_BANK_DRAW_BUFFERS
    860  7b28		       a0 08		      ldy	#BANK_DRAW_BUFFERS
    861  7b2a		       20 43 f0 	      jsr	CopyROMShadowToRAM_F000
    862  7b2d
    863  7b2d							;---------------------------------------------------------------------------
    864  7b2d
    865  7b2d		       a9 03		      lda	#BANK_Resync	; 2
    866  7b2f		       85 3f		      sta	SET_BANK	; 3
    867  7b31		       20 8a f3 	      jsr	Resync	; 6+x
    868  7b34
------- FILE sound/intro1_init.asm LEVEL 3 PASS 3
      0  7b34					      include	"sound/intro1_init.asm"
      1  7b34							; TIATracker music player
      2  7b34							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7b34							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7b34							; Email: andre.wichmann@gmx.de
      5  7b34							;
      6  7b34							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7b34							; you may not use this file except in compliance with the License.
      8  7b34							; You may obtain a copy of the License at
      9  7b34							;
     10  7b34							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7b34							;
     12  7b34							; Unless required by applicable law or agreed to in writing, software
     13  7b34							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7b34							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7b34							; See the License for the specific language governing permissions and
     16  7b34							; limitations under the License.
     17  7b34
     18  7b34							; Song author: 
     19  7b34							; Song name: 
     20  7b34
     21  7b34							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7b34
     23  7b34							; =====================================================================
     24  7b34							; Initialize music.
     25  7b34							; Set tt_cur_pat_index_c0/1 to the indexes of the first patterns from
     26  7b34							; tt_SequenceTable for each channel.
     27  7b34							; Set tt_timer and tt_cur_note_index_c0/1 to 0.
     28  7b34							; All other variables can start with any value.
     29  7b34							; =====================================================================
     30  7b34		       a9 00		      lda	#0
     31  7b36		       85 ce		      sta	tt_cur_pat_index_c0
     32  7b38		       a9 05		      lda	#5
     33  7b3a		       85 cf		      sta	tt_cur_pat_index_c1
     34  7b3c							; the rest should be 0 already from startup code. If not,
     35  7b3c							; set the following variables to 0 manually:
     36  7b3c							; - tt_timer
     37  7b3c							; - tt_cur_pat_index_c0
     38  7b3c							; - tt_cur_pat_index_c1
     39  7b3c							; - tt_cur_note_index_c0
     40  7b3c							; - tt_cur_note_index_c1
     41  7b3c
------- FILE BANK_FIXED.asm
    870  7b3c
    871  7b3c				   NewFrameStart
    872  7b3c
    873  7b3c		       24 c8		      bit	NextLevelTrigger
    874  7b3e		       10 b3		      bpl	NextLevelLevel	; game-triggered next level
    875  7b40		       70 aa		      bvs	RestartLevelNextPlayer	; loss of life
    876  7b42
    877  7b42							; Note: VSYNC must NOT be on when starting a new level! Else you get annoying TV signals.
    878  7b42
    879  7b42		       a9 0e		      lda	#%1110	; VSYNC ON
    880  7b44		       85 42	   .loopVSync sta	WSYNC
    881  7b46		       85 40		      sta	VSYNC
    882  7b48		       4a		      lsr
    883  7b49		       d0 f9		      bne	.loopVSync	; branch until VYSNC has been reset
    884  7b4b
    885  7b4b							; moved *after* the loop since this allows to *increase* timer values by 1!
    886  7b4b
    887  7b4b		       a6 81		      ldx	Platform
    888  7b4d		       bc 71 fc 	      ldy	VBlankTime,x
    889  7b50		       8c 96 02 	      sty	TIM64T
    890  7b53
    891  7b53
------- FILE sound/intro1_player.asm LEVEL 3 PASS 3
      0  7b53					      include	"sound/intro1_player.asm"
      1  7b53							; TIATracker music player
      2  7b53							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7b53							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7b53							; Email: andre.wichmann@gmx.de
      5  7b53							;
      6  7b53							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7b53							; you may not use this file except in compliance with the License.
      8  7b53							; You may obtain a copy of the License at
      9  7b53							;
     10  7b53							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7b53							;
     12  7b53							; Unless required by applicable law or agreed to in writing, software
     13  7b53							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7b53							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7b53							; See the License for the specific language governing permissions and
     16  7b53							; limitations under the License.
     17  7b53
     18  7b53							; Song author: 
     19  7b53							; Song name: 
     20  7b53
     21  7b53							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7b53
     23  7b53							; =====================================================================
     24  7b53							; TIATracker Player
     25  7b53							; =====================================================================
     26  7b53				   tt_PlayerStart
     27  7b53
     28  7b53							; PLANNED PLAYER VARIANTS:
     29  7b53							; - RAM, speed, player ROM: c0/c1 patterns have same length
     30  7b53							; - RAM: Pack 2 values (out of cur_pat_index, cur_note_index, envelope_index)
     31  7b53							;	 into one and use lsr/asl to unpack them, allowing only ranges of
     32  7b53							;	 16/16 or 32/8 for them, depending on number of patterns, max
     33  7b53							;	 pattern size and max ADSR size
     34  7b53							; - ROM: Check if tt_SequenceTable can hold ptrs directly without indexing
     35  7b53							;	 tt_PatternPtrLo/Hi. Can be smaller if not many patterns get repeated
     36  7b53							;	 (saves table and decode routine)
     37  7b53							; - Speed: Inline tt_CalcInsIndex
     38  7b53							; - Speed: Store ptr to current note in RAM instead of reconstructing it?
     39  7b53							;	 Might also save the need for cur_note_index
     40  7b53
     41  7b53
     42  7b53							; ---------------------------------------------------------------------
     43  7b53							; Helper macro: Retrieves current note. May advance pattern if needed.
     44  7b53							; Becomes a subroutine if TT_USE_OVERLAY is used.
     45  7b53							; ---------------------------------------------------------------------
     46  7b53					      MAC	tt_fetch_current_note
     47  7b53							; construct ptr to pattern
     48  7b53				   .constructPatPtr
     49  7b53					      ldy	tt_cur_pat_index_c0,x	; get current pattern (index into tt_SequenceTable)
     50  7b53					      lda	tt_SequenceTable,y
     51  7b53					      IF	TT_USE_GOTO = 1
     52  7b53					      bpl	.noPatternGoto
     53  7b53					      and	#%01111111	; mask out goto bit to get pattern number
     54  7b53					      sta	tt_cur_pat_index_c0,x	; store goto'ed pattern index
     55  7b53					      bpl	.constructPatPtr	; unconditional
     56  7b53				   .noPatternGoto
     57  7b53					      ENDIF
     58  7b53					      tay
     59  7b53					      lda	tt_PatternPtrLo,y
     60  7b53					      sta	tt_ptr
     61  7b53					      lda	tt_PatternPtrHi,y
     62  7b53					      sta	tt_ptr+1
     63  7b53							; get new note
     64  7b53					      IF	TT_USE_OVERLAY = 0
     65  7b53					      ldy	tt_cur_note_index_c0,x
     66  7b53					      ELSE
     67  7b53							; If the V flag is set and if the new note is an instrument,
     68  7b53							; it means it got pre-fetched by an overlay percussion, it has
     69  7b53							; to remain in sustain.
     70  7b53					      clv
     71  7b53							; check if note had been pre-fetched by overlay perc already
     72  7b53					      lda	tt_cur_note_index_c0,x
     73  7b53					      bpl	.notPrefetched
     74  7b53							; If so, remove flag
     75  7b53					      and	#%01111111
     76  7b53					      sta	tt_cur_note_index_c0,x
     77  7b53							; Set V flag for later
     78  7b53					      bit	tt_Bit6Set
     79  7b53				   .notPrefetched
     80  7b53					      tay
     81  7b53					      ENDIF
     82  7b53					      lda	(tt_ptr),y
     83  7b53							; pre-process new note
     84  7b53							; 7..5: instrument (1..7), 4..0 (0..31): frequency
     85  7b53							; 0/0: End of pattern
     86  7b53					      bne	.noEndOfPattern
     87  7b53							; End of pattern: Advance to next pattern
     88  7b53					      sta	tt_cur_note_index_c0,x	; a is 0
     89  7b53					      inc	tt_cur_pat_index_c0,x
     90  7b53					      bne	.constructPatPtr	; unconditional
     91  7b53				   .noEndOfPattern
     92  7b53					      ENDM
     93  7b53
     94  7b53
     95  7b53							; ---------------------------------------------------------------------
     96  7b53							; Music player entry. Call once per frame.
     97  7b53							; ---------------------------------------------------------------------
     98  7b53				   tt_Player  SUBROUTINE
     99  7b53							; ==================== Sequencer ====================
    100  7b53							; Decrease speed timer
    101  7b53		       c6 cd		      dec	tt_timer
    102  7b55		       10 6e		      bpl	.noNewNote
    103  7b57
    104  7b57							; Timer ran out: Do sequencer
    105  7b57							; Advance to next note
    106  7b57		       a2 01		      ldx	#1	; 2 channels
    107  7b59				   .advanceLoop
    108  7b59					      IF	TT_USE_OVERLAY = 1
    109  7b59		       20 6f fb 	      jsr	tt_FetchNote
    110  7b5c				  -	      ELSE
    111  7b5c				  -	      TT_FETCH_CURRENT_NOTE
    112  7b5c					      ENDIF
    113  7b5c							; Parse new note from pattern
    114  7b5c		       c9 10		      cmp	#TT_INS_PAUSE
    115  7b5e					      IF	TT_USE_SLIDE = 0
    116  7b5e		       90 55		      bcc	.finishedNewNote
    117  7b60		       d0 3d		      bne	.newNote
    118  7b62				  -	      ELSE
    119  7b62				  -	      beq	.pause
    120  7b62				  -	      bcs	.newNote
    121  7b62				  -
    122  7b62				  -			; --- slide/hold ---
    123  7b62				  -			; Adjust frequency and hold note in sustain.
    124  7b62				  -			; composer/tracker has to make sure that no unwanted
    125  7b62				  -			; under/overflow happens.
    126  7b62				  -			; Note: f = f + (8-(16-x)) = x + f - 8
    127  7b62				  -	      adc	tt_cur_ins_c0,x	; carry is clear after cmp
    128  7b62				  -	      sec
    129  7b62				  -	      sbc	#8
    130  7b62				  -	      sta	tt_cur_ins_c0,x
    131  7b62				  -	      bcs	.finishedNewNote	; unconditional, since legally no underflow can happen (ins>0 or HOLD for ins=0)
    132  7b62					      ENDIF
    133  7b62
    134  7b62							; --- pause ---
    135  7b62				   .pause
    136  7b62							; Get release index for current instrument. Since a pause can
    137  7b62							; only follow an instrument, we don't need to handle percussion
    138  7b62							; or commands.
    139  7b62		       b5 d4		      lda	tt_cur_ins_c0,x
    140  7b64		       20 fd fb 	      jsr	tt_CalcInsIndex
    141  7b67		       b9 58 fe 	      lda	tt_InsReleaseIndexes-1,y	; -1 b/c instruments start at #1
    142  7b6a							; Put it into release. Skip junk byte so index no longer indicates
    143  7b6a							; sustain phase.
    144  7b6a		       18		      clc
    145  7b6b		       69 01		      adc	#1
    146  7b6d		       90 44		      bcc	.storeADIndex	; unconditional
    147  7b6f
    148  7b6f							; ---------------------------------------------------------------------
    149  7b6f							; Helper subroutine to minimize ROM footprint. Will be inlined if
    150  7b6f							; TT_USE_OVERLAY is not used.
    151  7b6f							; Interleaved here so player can be inlined.
    152  7b6f							; ---------------------------------------------------------------------
    153  7b6f					      IF	TT_USE_OVERLAY = 1
    154  7b6f				   tt_FetchNote
      0  7b6f					      TT_FETCH_CURRENT_NOTE
      1  7b6f
      2  7b6f				   .constructPatPtr
      3  7b6f		       b4 ce		      ldy	tt_cur_pat_index_c0,x
      4  7b71		       b9 6b ff 	      lda	tt_SequenceTable,y
      5  7b74					      IF	TT_USE_GOTO = 1
      6  7b74		       10 06		      bpl	.noPatternGoto
      7  7b76		       29 7f		      and	#%01111111
      8  7b78		       95 ce		      sta	tt_cur_pat_index_c0,x
      9  7b7a		       10 f3		      bpl	.constructPatPtr
     10  7b7c				   .noPatternGoto
     11  7b7c					      ENDIF
     12  7b7c		       a8		      tay
     13  7b7d		       b9 61 ff 	      lda	tt_PatternPtrLo,y
     14  7b80		       85 d6		      sta	tt_ptr
     15  7b82		       b9 66 ff 	      lda	tt_PatternPtrHi,y
     16  7b85		       85 d7		      sta	tt_ptr+1
     17  7b87
     18  7b87				  -	      IF	TT_USE_OVERLAY = 0
     19  7b87				  -	      ldy	tt_cur_note_index_c0,x
     20  7b87					      ELSE
     21  7b87
     22  7b87
     23  7b87
     24  7b87		       b8		      clv
     25  7b88
     26  7b88		       b5 d0		      lda	tt_cur_note_index_c0,x
     27  7b8a		       10 07		      bpl	.notPrefetched
     28  7b8c
     29  7b8c		       29 7f		      and	#%01111111
     30  7b8e		       95 d0		      sta	tt_cur_note_index_c0,x
     31  7b90
     32  7b90		       2c 03 fc 	      bit	tt_Bit6Set
     33  7b93				   .notPrefetched
     34  7b93		       a8		      tay
     35  7b94					      ENDIF
     36  7b94		       b1 d6		      lda	(tt_ptr),y
     37  7b96
     38  7b96
     39  7b96
     40  7b96		       d0 06		      bne	.noEndOfPattern
     41  7b98
     42  7b98		       95 d0		      sta	tt_cur_note_index_c0,x
     43  7b9a		       f6 ce		      inc	tt_cur_pat_index_c0,x
     44  7b9c		       d0 d1		      bne	.constructPatPtr
     45  7b9e				   .noEndOfPattern
    156  7b9e		       60		      rts
    157  7b9f					      ENDIF
    158  7b9f
    159  7b9f
    160  7b9f							; --- start instrument or percussion ---
    161  7b9f				   .newNote
    162  7b9f		       95 d4		      sta	tt_cur_ins_c0,x	; set new instrument
    163  7ba1							; Instrument or percussion?
    164  7ba1		       c9 20		      cmp	#TT_FREQ_MASK+1
    165  7ba3		       b0 06		      bcs	.startInstrument
    166  7ba5
    167  7ba5							; --- start percussion ---
    168  7ba5							; Get index of envelope
    169  7ba5		       a8		      tay
    170  7ba6							; -TT_FIRST_PERC because percussion start with TT_FIRST_PERC
    171  7ba6		       b9 7c fe 	      lda	tt_PercIndexes-TT_FIRST_PERC,y
    172  7ba9		       d0 08		      bne	.storeADIndex	; unconditional, since index values are >0
    173  7bab
    174  7bab							; --- start instrument ---
    175  7bab				   .startInstrument
    176  7bab					      IF	TT_USE_OVERLAY = 1
    177  7bab							; If V flag is set, this note had been pre-fetched. That means
    178  7bab							; it should remain in sustain.
    179  7bab		       70 08		      bvs	.finishedNewNote
    180  7bad					      ENDIF
    181  7bad							; Put note into attack/decay
    182  7bad		       20 fd fb 	      jsr	tt_CalcInsIndex
    183  7bb0		       b9 4e fe 	      lda	tt_InsADIndexes-1,y	; -1 because instruments start at #1
    184  7bb3				   .storeADIndex
    185  7bb3		       95 d2		      sta	tt_envelope_index_c0,x
    186  7bb5
    187  7bb5							; --- Finished parsing new note ---
    188  7bb5				   .finishedNewNote
    189  7bb5							; increase note index into pattern
    190  7bb5		       f6 d0		      inc	tt_cur_note_index_c0,x
    191  7bb7							; loop over channels
    192  7bb7				   .sequencerNextChannel
    193  7bb7		       ca		      dex
    194  7bb8		       10 9f		      bpl	.advanceLoop
    195  7bba
    196  7bba							; Reset timer value
    197  7bba				  -	      IF	TT_GLOBAL_SPEED = 0
    198  7bba				  -			; Get timer value for current pattern in channel 0
    199  7bba				  -	      ldx	tt_cur_pat_index_c0	; get current pattern (index into tt_SequenceTable)
    200  7bba				  -	      ldy	tt_SequenceTable,x	; Current pattern index now in y
    201  7bba				  -	      IF	TT_USE_FUNKTEMPO = 0
    202  7bba				  -	      lda	tt_PatternSpeeds,y
    203  7bba				  -	      sta	tt_timer
    204  7bba				  -	      ELSE
    205  7bba				  -			; Test for odd/even frame
    206  7bba				  -	      lda	tt_cur_note_index_c0
    207  7bba				  -	      lsr
    208  7bba				  -	      lda	tt_PatternSpeeds,y	; does not affect carry flag
    209  7bba				  -	      bcc	.evenFrame
    210  7bba				  -	      and	#$0f	; does not affect carry flag
    211  7bba				  -	      bcs	.storeFunkTempo
    212  7bba				  -.evenFrame
    213  7bba				  -	      lsr
    214  7bba				  -	      lsr
    215  7bba				  -	      lsr
    216  7bba				  -	      lsr
    217  7bba				  -.storeFunkTempo
    218  7bba				  -	      sta	tt_timer
    219  7bba				  -	      ENDIF		; TT_USE_FUNKTEMPO = 0
    220  7bba				  -
    221  7bba					      ELSE
    222  7bba							; Global tempo
    223  7bba		       a2 04		      ldx	#TT_SPEED-1
    224  7bbc					      IF	TT_USE_FUNKTEMPO = 1
    225  7bbc		       a5 d0		      lda	tt_cur_note_index_c0
    226  7bbe		       4a		      lsr
    227  7bbf		       90 02		      bcc	.noOddFrame
    228  7bc1		       a2 03		      ldx	#TT_ODD_SPEED-1
    229  7bc3				   .noOddFrame
    230  7bc3					      ENDIF		; TT_USE_FUNKTEMPO = 1
    231  7bc3		       86 cd		      stx	tt_timer
    232  7bc5					      ENDIF		; TT_GLOBAL_SPEED = 0
    233  7bc5
    234  7bc5							; No new note to process
    235  7bc5				   .noNewNote
    236  7bc5
    237  7bc5							; ==================== Update registers ====================
    238  7bc5		       a2 01		      ldx	#1	; 2 channels
    239  7bc7				   .updateLoop
    240  7bc7							; Percussion or melodic instrument?
    241  7bc7		       b5 d4		      lda	tt_cur_ins_c0,x
    242  7bc9				  -	      IF	TT_STARTS_WITH_NOTES = 0
    243  7bc9				  -			; This branch can be removed if track starts with a note in each channel
    244  7bc9				  -	      beq	.afterAudioUpdate
    245  7bc9					      ENDIF
    246  7bc9		       c9 20		      cmp	#TT_FREQ_MASK+1
    247  7bcb		       b0 37		      bcs	.instrument	; Melodic instrument
    248  7bcd
    249  7bcd							; --- Percussion: Get envelope index ---
    250  7bcd		       b4 d2		      ldy	tt_envelope_index_c0,x
    251  7bcf							; Set AUDC and AUDV value from envelope
    252  7bcf		       b9 a5 fe 	      lda	tt_PercCtrlVolTable-1,y	; -1 because values are stored +1
    253  7bd2		       f0 02		      beq	.endOfPercussion	; 0 means end of percussion data
    254  7bd4		       f6 d2		      inc	tt_envelope_index_c0,x	; if end not reached: advance index
    255  7bd6				   .endOfPercussion
    256  7bd6		       95 59		      sta	AUDV0,x
    257  7bd8		       4a		      lsr
    258  7bd9		       4a		      lsr
    259  7bda		       4a		      lsr
    260  7bdb		       4a		      lsr
    261  7bdc		       95 55		      sta	AUDC0,x
    262  7bde							; Set AUDF
    263  7bde		       b9 8f fe 	      lda	tt_PercFreqTable-1,y	; -1 because values are stored +1
    264  7be1							; Bit 7 (overlay) might be set, but is unused in AUDF
    265  7be1		       95 57		      sta	AUDF0,x
    266  7be3					      IF	TT_USE_OVERLAY = 1
    267  7be3		       10 48		      bpl	.afterAudioUpdate
    268  7be5							; Overlay percussion: Fetch next note out of order
    269  7be5		       20 6f fb 	      jsr	tt_FetchNote
    270  7be8							; Only do something if it's a melodic instrument
    271  7be8		       c9 20		      cmp	#TT_FREQ_MASK+1
    272  7bea		       90 41		      bcc	.afterAudioUpdate
    273  7bec							; Instrument: Put into sustain
    274  7bec		       95 d4		      sta	tt_cur_ins_c0,x	; set new instrument
    275  7bee		       20 fd fb 	      jsr	tt_CalcInsIndex
    276  7bf1		       b9 53 fe 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start at #1
    277  7bf4		       95 d2		      sta	tt_envelope_index_c0,x
    278  7bf6							; Set prefetch flag. asl-sec-ror is smaller than lda-ora #128-sta
    279  7bf6		       16 d0		      asl	tt_cur_note_index_c0,x
    280  7bf8		       38		      sec
    281  7bf9		       76 d0		      ror	tt_cur_note_index_c0,x
    282  7bfb		       30 30		      bmi	.afterAudioUpdate	; unconditional
    283  7bfd				  -	      ELSE
    284  7bfd				  -	      jmp	.afterAudioUpdate
    285  7bfd					      ENDIF
    286  7bfd
    287  7bfd
    288  7bfd							; ---------------------------------------------------------------------
    289  7bfd							; Helper subroutine to minimize ROM footprint.
    290  7bfd							; Interleaved here so player routine can be inlined.
    291  7bfd							; ---------------------------------------------------------------------
    292  7bfd				   tt_CalcInsIndex
    293  7bfd							; move upper 3 bits to lower 3
    294  7bfd		       4a		      lsr
    295  7bfe		       4a		      lsr
    296  7bff		       4a		      lsr
    297  7c00		       4a		      lsr
    298  7c01		       4a		      lsr
    299  7c02		       a8		      tay
    300  7c03				   tt_Bit6Set		; This opcode has bit #6 set, for use with bit instruction
    301  7c03		       60		      rts
    302  7c04
    303  7c04
    304  7c04				   .instrument
    305  7c04							; --- Melodic instrument ---
    306  7c04							; Compute index into ADSR indexes and master Ctrl tables
    307  7c04		       20 fd fb 	      jsr	tt_CalcInsIndex
    308  7c07							; Set AUDC with master value for this instrument, while we are at it
    309  7c07		       b9 49 fe 	      lda	tt_InsCtrlTable-1,y	; -1 because instruments start with #1
    310  7c0a		       95 55		      sta	AUDC0,x
    311  7c0c							; advance ADSR counter and compare to end of Sustain
    312  7c0c		       b5 d2		      lda	tt_envelope_index_c0,x
    313  7c0e		       d9 58 fe 	      cmp	tt_InsReleaseIndexes-1,y	; -1 because instruments start with #1
    314  7c11		       d0 03		      bne	.noEndOfSustain
    315  7c13							; End of sustain: Go back to start of sustain
    316  7c13		       b9 53 fe 	      lda	tt_InsSustainIndexes-1,y	; -1 because instruments start with #1
    317  7c16				   .noEndOfSustain
    318  7c16		       a8		      tay
    319  7c17							; Set volume from envelope
    320  7c17		       b9 5e fe 	      lda	tt_InsFreqVolTable,y
    321  7c1a		       f0 01		      beq	.endOfEnvelope	; 0 means end of release has been reached:
    322  7c1c		       c8		      iny		; advance index otherwise
    323  7c1d				   .endOfEnvelope
    324  7c1d		       94 d2		      sty	tt_envelope_index_c0,x
    325  7c1f		       95 59		      sta	AUDV0,x
    326  7c21							; Now adjust frequency with ADSR value from envelope
    327  7c21		       4a		      lsr
    328  7c22		       4a		      lsr
    329  7c23		       4a		      lsr
    330  7c24		       4a		      lsr
    331  7c25		       18		      clc
    332  7c26		       75 d4		      adc	tt_cur_ins_c0,x
    333  7c28		       38		      sec
    334  7c29		       e9 08		      sbc	#8
    335  7c2b		       95 57		      sta	AUDF0,x
    336  7c2d
    337  7c2d				   .afterAudioUpdate
    338  7c2d							; loop over channels
    339  7c2d		       ca		      dex
    340  7c2e		       10 97		      bpl	.updateLoop
    341  7c30
 Music player size:  $dd
    342  7c30					      echo	"Music player size: ", *-tt_PlayerStart
------- FILE BANK_FIXED.asm
    893  7c30
    894  7c30		       20 39 fa 	      jsr	StealCharDraw	; NOTE THIS IS THE *ONLY* AREA BIG ENOUGH FOR > 30 INTIM NEEDS
    895  7c33
    896  7c33							;---------------------------------------------------------------------------
    897  7c33							; START OF DISPLAY
    898  7c33
    899  7c33		       a9 09		      lda	#BANK_SCORING	; 2
    900  7c35		       85 3e		      sta	SET_BANK_RAM	; 3
    901  7c37		       20 d3 f1 	      jsr	DrawDigits	; 6 = 11
    902  7c3a
    903  7c3a							;---------------------------------------------------------------------------
    904  7c3a							; A 42-cycle timing window in the screen draw code.  Perform any general
    905  7c3a							; per-frame code here, provided it takes exactly 42 cycles to execute.
    906  7c3a							; TJ: Well, not exactly 42 cycles, but it works! :)
    907  7c3a							;	 @09
    908  7c3a		       85 49		      sta	COLUBK	; 3	 value comes from subroutine
    909  7c3c							; + the 'black' left-side of top screen colour change when look-around is actually a HMOVE bar, so we can't fix it :)
    910  7c3c
    911  7c3c
    912  7c3c							;		  inc Throttle		      ; 5     speed limiter
      0  7c3c					      SLEEP	5	;	 TODO: optimize for space
      1  7c3c				   .CYCLES    SET	5
      2  7c3c
      3  7c3c				  -	      IF	.CYCLES < 2
      4  7c3c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c3c				  -	      ERR
      6  7c3c					      ENDIF
      7  7c3c
      8  7c3c					      IF	.CYCLES & 1
      9  7c3c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c3c		       04 00		      nop	0
     11  7c3e				  -	      ELSE
     12  7c3e				  -	      bit	VSYNC
     13  7c3e					      ENDIF
     14  7c3e				   .CYCLES    SET	.CYCLES - 3
     15  7c3e					      ENDIF
     16  7c3e
     17  7c3e					      REPEAT	.CYCLES / 2
     18  7c3e		       ea		      nop
     19  7c3f					      REPEND
    914  7c3f
    915  7c3f		       a9 15		      lda	#%00010101	; 2	 double width missile, double width player
    916  7c41		       ca		      dex		; 2	 = $6f, stars effect!
    917  7c42		       86 62		      stx	HMM0	; 3	 @24, exactly 21 cycles after the HMOVE
    918  7c44
    919  7c44		       85 44		      sta	NUSIZ0	; 3
    920  7c46		       84 65		      sty	VDELP0	; 3	 y = 0!
    921  7c48
      0  7c48					      SLEEP	10
      1  7c48				   .CYCLES    SET	10
      2  7c48
      3  7c48				  -	      IF	.CYCLES < 2
      4  7c48				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7c48				  -	      ERR
      6  7c48					      ENDIF
      7  7c48
      8  7c48				  -	      IF	.CYCLES & 1
      9  7c48				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  7c48				  -	      nop	0
     11  7c48				  -	      ELSE
     12  7c48				  -	      bit	VSYNC
     13  7c48				  -	      ENDIF
     14  7c48				  -.CYCLES    SET	.CYCLES - 3
     15  7c48					      ENDIF
     16  7c48
     17  7c48					      REPEAT	.CYCLES / 2
     18  7c48		       ea		      nop
     17  7c48					      REPEND
     18  7c49		       ea		      nop
     17  7c49					      REPEND
     18  7c4a		       ea		      nop
     17  7c4a					      REPEND
     18  7c4b		       ea		      nop
     17  7c4b					      REPEND
     18  7c4c		       ea		      nop
     19  7c4d					      REPEND
    923  7c4d							;iny			      ; 2     this relies on Y == 0 before...
    924  7c4d							;cpy extraLifeTimer	      ; 3     ..,and bit 0 is set in A
    925  7c4d							;adc #2		      ; 2
    926  7c4d							;sta ENAM0		      ; 3     dis/enable Cosmic Ark star effect
    927  7c4d
    928  7c4d		       a5 a4		      lda	ManLastDirection	; 3
    929  7c4f		       85 4b		      sta	REFP0	; 3
    930  7c51
    931  7c51		       a9 00		      lda	#BANK_SCREENMARKII1	; 2
    932  7c53		       85 3e		      sta	SET_BANK_RAM	; 3
    933  7c55		       20 00 f0 	      jsr	DrawTheScreen	; 6	 @57 from RAM, no less!!
    934  7c58							;	 @66
    935  7c58		       a9 03		      lda	#BANK_PostScreenCleanup	; 2
    936  7c5a		       85 3f		      sta	SET_BANK	; 3
    937  7c5c		       20 4c f4 	      jsr	PostScreenCleanup	; 6+x
    938  7c5f
    939  7c5f		       a9 00		      lda	#BANK_SelfModDrawPlayers	; 2
    940  7c61		       85 3f		      sta	SET_BANK	; 3
    941  7c63		       20 db f2 	      jsr	SelfModDrawPlayers	; 6+x
    942  7c66
    943  7c66		       20 39 fa 	      jsr	StealCharDraw
    944  7c69
    945  7c69		       ad 84 02    OverscanBD lda	INTIM	;4
    946  7c6c		       d0 fb		      bne	OverscanBD	;2/3
    947  7c6e		       4c 3c fb 	      jmp	NewFrameStart
    948  7c71				   VBlankTime
    949  7c71		       3e 3e		      .byte.b	VBLANK_TIM_NTSC, VBLANK_TIM_NTSC
    950  7c73		       55 55		      .byte.b	VBLANK_TIM_PAL, VBLANK_TIM_PAL
    951  7c75
    952  7c75							;---------------------------------------------------------------------------
    953  7c75
    954  7c75				   CharacterDataVecLO
    955  7c75
    956  7c75							; Two entries per character.  2nd is ptr to mirrored character
    957  7c75							; Characters don't have to be mirrored, obviously -- use the same pointer for both!
    958  7c75
    959  7c75		       05		      .byte.b	<CHARACTERSHAPE_BLANK
    960  7c76		       05		      .byte.b	<CHARACTERSHAPE_BLANK
    961  7c77		       2f		      .byte.b	<CHARACTERSHAPE_SOIL
    962  7c78		       2f		      .byte.b	<CHARACTERSHAPE_SOIL_MIRRORED
    963  7c79		       e7		      .byte.b	<CHARACTERSHAPE_BOX
    964  7c7a		       00		      .byte.b	<CHARACTERSHAPE_BOX_MIRRORED
    965  7c7b		       54		      .byte.b	<CHARACTERSHAPE_TARGET
    966  7c7c		       3f		      .byte.b	<CHARACTERSHAPE_TARGET_MIRRORED
    967  7c7d		       53		      .byte.b	<CHARACTERSHAPE_TARGET2
    968  7c7e		       3e		      .byte.b	<CHARACTERSHAPE_TARGET2_MIRRORED
    969  7c7f		       05		      .byte.b	<CHARACTERSHAPE_BLANK	; man occupied
    970  7c80		       05		      .byte.b	<CHARACTERSHAPE_BLANK
    971  7c81		       3f		      .byte.b	<CHARACTERSHAPE_STEEL
    972  7c82		       3f		      .byte.b	<CHARACTERSHAPE_STEEL_MIRRORED
    973  7c83		       20		      .byte.b	<CHARACTERSHAPE_WALL
    974  7c84		       35		      .byte.b	<CHARACTERSHAPE_WALL_MIRRORED
    975  7c85		       15		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET
    976  7c86		       2a		      .byte.b	<CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
    977  7c87		       05		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    978  7c88		       05		      .byte.b	<CHARACTERSHAPE_BLANK	; unkillable man
    979  7c89
    980  7c89				  -	      IF	* - CharacterDataVecLO != CHARACTER_MAXIMUM*2
    981  7c89				  -	      ECHO	"ERROR: Incorrect CharacterDataVecLO table!"
    982  7c89				  -	      ERR
    983  7c89					      ENDIF
    984  7c89
    985  7c89							;---------------------------------------------------------------------------
    986  7c89
    987  7c89				   CharacterDataVecHI
    988  7c89							; TJ: used by:
    989  7c89							; - BANK_ROM_SHADOW_DRAWBUFFERS.asm
    990  7c89
    991  7c89		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    992  7c8a		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
    993  7c8b		       f3		      .byte.b	>CHARACTERSHAPE_SOIL
    994  7c8c		       f3		      .byte.b	>CHARACTERSHAPE_SOIL_MIRRORED
    995  7c8d		       fc		      .byte.b	>CHARACTERSHAPE_BOX
    996  7c8e		       fd		      .byte.b	>CHARACTERSHAPE_BOX_MIRRORED
    997  7c8f		       f2		      .byte.b	>CHARACTERSHAPE_TARGET
    998  7c90		       f2		      .byte.b	>CHARACTERSHAPE_TARGET_MIRRORED
    999  7c91		       f2		      .byte.b	>CHARACTERSHAPE_TARGET2
   1000  7c92		       f2		      .byte.b	>CHARACTERSHAPE_TARGET2_MIRRORED
   1001  7c93		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; man occupied
   1002  7c94		       f3		      .byte.b	>CHARACTERSHAPE_BLANK
   1003  7c95		       fd		      .byte.b	>CHARACTERSHAPE_STEEL
   1004  7c96		       fd		      .byte.b	>CHARACTERSHAPE_STEEL_MIRRORED
   1005  7c97		       fe		      .byte.b	>CHARACTERSHAPE_WALL
   1006  7c98		       fe		      .byte.b	>CHARACTERSHAPE_WALL_MIRRORED
   1007  7c99		       fd		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET
   1008  7c9a		       fd		      .byte.b	>CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
   1009  7c9b		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
   1010  7c9c		       f3		      .byte.b	>CHARACTERSHAPE_BLANK	; unkillable man
   1011  7c9d
   1012  7c9d				  -	      IF	* - CharacterDataVecHI != CHARACTER_MAXIMUM*2
   1013  7c9d				  -	      ECHO	"ERROR: Incorrect CharacterDataVecHI table!"
   1014  7c9d				  -	      ERR
   1015  7c9d					      ENDIF
   1016  7c9d
   1017  7c9d							;---------------------------------------------------------------------------
   1018  7c9d
      0  7c9d					      DEFINE_SUBROUTINE	AnimateCharReplacements2	;139
      1  7c9d		       00 0f	   BANK_AnimateCharReplacements2 =	_CURRENT_BANK
      2  7c9d					      SUBROUTINE
      3  7c9d				   AnimateCharReplacements2
   1020  7c9d
   1021  7c9d							; This manages character animation on a per-object basis.  Morph/animate these
   1022  7c9d							; characters individually or as required.  Change will affect all characters
   1023  7c9d							; of the same type in the visible display.
   1024  7c9d
   1025  7c9d							; -------------------------------------------
   1026  7c9d
   1027  7c9d							; handle the non-mandatory animating things
   1028  7c9d
   1029  7c9d		       a5 b1		      lda	timer	;3
   1030  7c9f		       29 03		      and	#%11	;2
   1031  7ca1		       d0 0c		      bne	nothingAnimates	;2/3
   1032  7ca3
   1033  7ca3		       a5 98		      lda	scrollBits	;3
   1034  7ca5		       d0 08		      bne	nothingAnimates	;2/3		 DON'T animate if we scrolled
   1035  7ca7
   1036  7ca7		       ad d4 f1 	      lda	ANIM_TARGET	;4
   1037  7caa		       49 07		      eor	#CHARACTER_TARGET^CHARACTER_TARGET2	;2
   1038  7cac		       8d d4 f5 	      sta	ANIM_TARGET + RAM_WRITE	;4 = 15	 TARGET
   1039  7caf
   1040  7caf		       4c 16 f1    nothingAnimates jmp	retAnim	;3
   1041  7cb2
   1042  7cb2							;---------------------------------------------------------------------------
   1043  7cb2
      0  7cb2					      DEFINE_SUBROUTINE	ScoreAdd
      1  7cb2		       00 0f	   BANK_ScoreAdd =	_CURRENT_BANK
      2  7cb2					      SUBROUTINE
      3  7cb2				   ScoreAdd
   1045  7cb2							; TJ: used by:
   1046  7cb2							; - BANK_INITBANK.asm
   1047  7cb2		       a2 09		      ldx	#BANK_SCORING
   1048  7cb4		       86 3e		      stx	SET_BANK_RAM
   1049  7cb6		       20 0f f2 	      jsr	UpdateScore
   1050  7cb9		       a5 c2	   rbret      lda	ROM_Bank
   1051  7cbb		       85 3f		      sta	SET_BANK
   1052  7cbd		       60		      rts
   1053  7cbe
   1054  7cbe							;---------------------------------------------------------------------------
   1055  7cbe
      0  7cbe					      DEFINE_SUBROUTINE	nextLevelMan
      1  7cbe		       00 0f	   BANK_nextLevelMan =	_CURRENT_BANK
      2  7cbe					      SUBROUTINE
      3  7cbe				   nextLevelMan
   1057  7cbe
   1058  7cbe							;lda #BANK_NextLevelX
   1059  7cbe							;sta SET_BANK
   1060  7cbe							;jmp NextLevelX
   1061  7cbe
   1062  7cbe							; Now do the actual switching
   1063  7cbe
   1064  7cbe		       a5 c8		      lda	NextLevelTrigger
   1065  7cc0		       29 7f		      and	#<(~BIT_NEXTLEVEL)
   1066  7cc2		       85 c8		      sta	NextLevelTrigger
   1067  7cc4
   1068  7cc4							; Next level is due. Point to the next level, but if we're at the end of playable levels,
   1069  7cc4							; then increment the level number. This is completely circular, so we eventually wrap
   1070  7cc4							; the level back to 0 and start afresh.
   1071  7cc4
   1072  7cc4		       a5 b3		      lda	levelX
   1073  7cc6		       18		      clc
   1074  7cc7		       69 04		      adc	#LEVEL_DEFINITION_SIZE
   1075  7cc9		       c9 d0		      cmp	#LEVELNUM
   1076  7ccb		       90 02		      bcc	.level_ok
   1077  7ccd
   1078  7ccd		       a9 00		      lda	#0
   1079  7ccf		       85 b3	   .level_ok  sta	levelX
   1080  7cd1		       60		      rts
   1081  7cd2
   1082  7cd2
   1083  7cd2
   1084  7cd2							;---------------------------------------------------------------------------
   1085  7cd2
      0  7cd2					      DEFINE_SUBROUTINE	goGeneralScoringSetups
      1  7cd2		       00 0f	   BANK_goGeneralScoringSetups =	_CURRENT_BANK
      2  7cd2					      SUBROUTINE
      3  7cd2				   goGeneralScoringSetups
   1087  7cd2
   1088  7cd2		       a9 09		      lda	#BANK_SCORING
   1089  7cd4		       85 3e		      sta	SET_BANK_RAM
   1090  7cd6		       20 8f f2 	      jsr	GeneralScoringSetups
   1091  7cd9		       a5 c2		      lda	ROM_Bank
   1092  7cdb		       85 3f		      sta	SET_BANK
   1093  7cdd		       60		      rts
   1094  7cde							;---------------------------------------------------------------------------
   1095  7cde
      0  7cde					      DEFINE_SUBROUTINE	CopyROM2RAM_F000
      1  7cde		       00 0f	   BANK_CopyROM2RAM_F000 =	_CURRENT_BANK
      2  7cde					      SUBROUTINE
      3  7cde				   CopyROM2RAM_F000
   1097  7cde
   1098  7cde		       a9 05		      lda	#BANK_CopyROMShadowToRAM
   1099  7ce0		       85 3f		      sta	SET_BANK
   1100  7ce2		       85 c2		      sta	ROM_Bank
   1101  7ce4		       4c 43 f0 	      jmp	CopyROMShadowToRAM_F000
   1102  7ce7
   1103  7ce7
   1104  7ce7							;---------------------------------------------------------------------------
   1105  7ce7
------- FILE BOX.asm LEVEL 3 PASS 3
      0  7ce7					      include	"BOX.asm"	; 2 * LINES_PER_CHAR bytes
      0  7ce7					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX", LINES_PER_CHAR
     10  7ce7					      LIST	ON
      2  7ce7				   CHARACTERSHAPE_BOX
      3  7ce7				  -	      if	MIRRORED_BOX = NO
      4  7ce7				  -CHARACTERSHAPE_BOX_MIRRORED
      5  7ce7					      endif
      6  7ce7		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
      7  7cee		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
      8  7cf5		       00 00 00 00*	      .byte.b	%0,%0,%0,0,%0,%0,%0	;B
      9  7cfc
     10  7cfc							;--------------------------------------------------------------------------
     11  7cfc					      if	MIRRORED_BOX = YES
      0  7cfc					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_MIRRORED", LINES_PER_CHAR
 PAGE BREAK INSERTED FOR  CHARACTERSHAPE_BOX_MIRRORED
 REQUESTED SIZE =  $15
 WASTED SPACE =  $4
 PAGEBREAK LOCATION =  $fd00
     10  7d00					      LIST	ON
     13  7d00				   CHARACTERSHAPE_BOX_MIRRORED
     14  7d00		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%0	;R
     15  7d07		       ff ff 99 99*	      .byte.b	%11111111,%11111111,%10011001,%10011001,%11111111,%11111111,%11111111	;G
     16  7d0e		       00 00 00 00*	      .byte.b	%0,%0,0,0,%0,%0,%0	;B
     17  7d15					      endif
     18  7d15
      0  7d15					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET", LINES_PER_CHAR
     10  7d15					      LIST	ON
     20  7d15				   CHARACTERSHAPE_BOX_ON_TARGET
     21  7d15				  -	      if	MIRRORED_BOX = NO
     22  7d15				  -CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     23  7d15					      endif
     24  7d15		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     25  7d1c		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     26  7d23		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,0,%0,%0	;B
     27  7d2a
     28  7d2a							;--------------------------------------------------------------------------
     29  7d2a					      if	MIRRORED_BOX = YES
      0  7d2a					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED", LINES_PER_CHAR
     10  7d2a					      LIST	ON
     31  7d2a				   CHARACTERSHAPE_BOX_ON_TARGET_MIRRORED
     32  7d2a		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%0	;R
     33  7d31		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;G
     34  7d38		       00 66 66 66*	      .byte.b	%0,%01100110,%01100110,%01100110,0,%0,%0	;B
     35  7d3f					      endif
------- FILE BANK_FIXED.asm
------- FILE Steel_Wall.asm LEVEL 3 PASS 3
      0  7d3f					      include	"Steel_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      1  7d3f							;--------------------------------------------------------------------------
      0  7d3f					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL", LINES_PER_CHAR
     10  7d3f					      LIST	ON
      3  7d3f				   CHARACTERSHAPE_STEEL
      4  7d3f				   CHARACTERSHAPE_EXITDOOR
      5  7d3f				  -	      if	MIRRORED_STEEL = NO
      6  7d3f				  -CHARACTERSHAPE_STEEL_MIRRORED
      7  7d3f				  -CHARACTERSHAPE_EXITDOOR_MIRRORED
      8  7d3f				  -	      .byte	%00000000,%10001000,%00000000,%00000000,%00100010,%00000000,%00000000	;R
      9  7d3f				  -	      .byte	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;G
     10  7d3f				  -	      .byte	%11111111,%11111111,%01110111,%11111111,%11111111,%11011101,%11111111	;B
     11  7d3f					      endif
     12  7d3f
     13  7d3f							;--------------------------------------------------------------------------
     14  7d3f					      if	MIRRORED_STEEL = YES
      0  7d3f					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_STEEL_MIRRORED", LINES_PER_CHAR
     10  7d3f					      LIST	ON
     16  7d3f				   CHARACTERSHAPE_STEEL_MIRRORED
     17  7d3f				   CHARACTERSHAPE_EXITDOOR_MIRRORED
     18  7d3f		       00 11 00 00*	      .byte.b	%00000000,%00010001,%00000000,%00000000,%01000100,%00000000,%00000000	;R
     19  7d46		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;G
     20  7d4d		       ff ff ee ff*	      .byte.b	%11111111,%11111111,%11101110,%11111111,%11111111,%10111011,%11111111	;B
     21  7d54					      endif
------- FILE BANK_FIXED.asm
   1108  7d54							;---------------------------------------------------------------------------
   1109  7d54
------- FILE circle.asm LEVEL 3 PASS 3
      0  7d54					      include	"circle.asm"
      1  7d54
      2  7d54							;Begin {Circle}
      3  7d54							;x := r;
      4  7d54							;y := 0;
      5  7d54							;d := 1 - r;
      6  7d54							;Repeat
      7  7d54							;Circle_Points(x,y);
      8  7d54							;y := y + 1;
      9  7d54							;if d < 0 Then
     10  7d54							;    d := d + 2*y + 1
     11  7d54							;Else Begin
     12  7d54							;    x := x - 1;
     13  7d54							;    d := d + 2*(y-x) + 1
     14  7d54							;    End
     15  7d54							;Until x < y
     16  7d54							;End; {Circle}
     17  7d54
     18  7d54
      0  7d54					      DEFINE_SUBROUTINE	PlotChar
      1  7d54		       00 0f	   BANK_PlotChar =	_CURRENT_BANK
      2  7d54					      SUBROUTINE
      3  7d54				   PlotChar
     20  7d54
     21  7d54							; a = x pos
     22  7d54							; y = y pos
     23  7d54
     24  7d54		       c5 94		      cmp	BoardLimit_Width
     25  7d56		       b0 14		      bcs	off1x
     26  7d58		       c4 95		      cpy	BoardLimit_Height
     27  7d5a		       b0 10		      bcs	off1x
     28  7d5c
     29  7d5c		       48		      pha
     30  7d5d		       a9 05		      lda	#BANK_GetBoardAddressW	;
     31  7d5f		       85 3f		      sta	SET_BANK	;
     32  7d61		       20 e8 f0 	      jsr	GetBoardAddressW	;11+24[-2](A)
     33  7d64
     34  7d64		       86 3e		      stx	SET_BANK_RAM	;3
     35  7d66
     36  7d66		       68		      pla
     37  7d67		       a8		      tay
     38  7d68		       a5 ad		      lda	circ_char	;3
     39  7d6a		       91 c0		      sta	(Board_AddressW),y	;6
     40  7d6c		       60	   off1x      rts
     41  7d6d
     42  7d6d							;x	       Plot(x,y);
     43  7d6d							;x	       Plot(y,x);
     44  7d6d							;x	      Plot(y,-x);
     45  7d6d							;x	      Plot(x,-y);
     46  7d6d							;x	      Plot(-x,-y);
     47  7d6d							;x	      Plot(-y,-x);
     48  7d6d							;x	       Plot(-y,x);
     49  7d6d							;x	       Plot(-x,y)
     50  7d6d
      0  7d6d					      DEFINE_SUBROUTINE	PlotCirclePoints
      1  7d6d		       00 0f	   BANK_PlotCirclePoints =	_CURRENT_BANK
      2  7d6d					      SUBROUTINE
      3  7d6d				   PlotCirclePoints
     52  7d6d
     53  7d6d							; +x+y
     54  7d6d		       18		      clc
     55  7d6e		       a5 ac		      lda	circ_y
     56  7d70		       4a		      lsr
     57  7d71		       65 9c		      adc	ManY	; "origin"
     58  7d73		       a8		      tay
     59  7d74		       18		      clc
     60  7d75		       a5 ab		      lda	circ_x
     61  7d77		       4a		      lsr
     62  7d78		       65 9b		      adc	ManX
     63  7d7a		       c5 95		      cmp	BoardLimit_Height
     64  7d7c		       b0 ee		      bcs	off1x
     65  7d7e		       20 54 fd 	      jsr	PlotChar
     66  7d81
     67  7d81							;+y+x
     68  7d81		       18		      clc
     69  7d82		       a5 ab		      lda	circ_x
     70  7d84		       4a		      lsr
     71  7d85		       65 9c		      adc	ManY	; "origin"
     72  7d87		       a8		      tay
     73  7d88		       18		      clc
     74  7d89		       a5 ac		      lda	circ_y
     75  7d8b		       4a		      lsr
     76  7d8c		       65 9b		      adc	ManX
     77  7d8e		       20 54 fd 	      jsr	PlotChar
     78  7d91
     79  7d91							; y,-x
     80  7d91		       38		      sec
     81  7d92		       a5 9c		      lda	ManY
     82  7d94		       0a		      asl
     83  7d95		       e5 ab		      sbc	circ_x
     84  7d97		       4a		      lsr
     85  7d98		       a8		      tay
     86  7d99		       18		      clc
     87  7d9a		       a5 ac		      lda	circ_y
     88  7d9c		       4a		      lsr
     89  7d9d		       65 9b		      adc	ManX	; "origin"
     90  7d9f		       20 54 fd 	      jsr	PlotChar
     91  7da2
     92  7da2							; x,-y
     93  7da2		       a5 9c		      lda	ManY
     94  7da4		       0a		      asl
     95  7da5		       38		      sec
     96  7da6		       e5 ac		      sbc	circ_y	; "origin"
     97  7da8		       4a		      lsr
     98  7da9		       a8		      tay
     99  7daa		       a5 ab		      lda	circ_x
    100  7dac		       4a		      lsr
    101  7dad		       18		      clc
    102  7dae		       65 9b		      adc	ManX
    103  7db0		       20 54 fd 	      jsr	PlotChar
    104  7db3
    105  7db3							; -x,-y
    106  7db3		       a5 9c		      lda	ManY
    107  7db5		       0a		      asl
    108  7db6		       38		      sec
    109  7db7		       e5 ac		      sbc	circ_y	; "origin"
    110  7db9		       4a		      lsr
    111  7dba		       a8		      tay
    112  7dbb		       a5 9b		      lda	ManX
    113  7dbd		       0a		      asl
    114  7dbe		       38		      sec
    115  7dbf		       e5 ab		      sbc	circ_x
    116  7dc1		       4a		      lsr
    117  7dc2		       20 54 fd 	      jsr	PlotChar
    118  7dc5
    119  7dc5							; -y,-x
    120  7dc5		       a5 9c		      lda	ManY
    121  7dc7		       0a		      asl
    122  7dc8		       38		      sec
    123  7dc9		       e5 ab		      sbc	circ_x	; "origin"
    124  7dcb		       4a		      lsr
    125  7dcc		       a8		      tay
    126  7dcd		       a5 9b		      lda	ManX
    127  7dcf		       0a		      asl
    128  7dd0		       38		      sec
    129  7dd1		       e5 ac		      sbc	circ_y
    130  7dd3		       4a		      lsr
    131  7dd4		       20 54 fd 	      jsr	PlotChar
    132  7dd7
    133  7dd7							; -y,x
    134  7dd7		       a5 ab		      lda	circ_x
    135  7dd9		       4a		      lsr
    136  7dda		       18		      clc
    137  7ddb		       65 9c		      adc	ManY	; "origin"
    138  7ddd		       a8		      tay
    139  7dde		       a5 9b		      lda	ManX
    140  7de0		       0a		      asl
    141  7de1		       38		      sec
    142  7de2		       e5 ac		      sbc	circ_y
    143  7de4		       4a		      lsr
    144  7de5		       20 54 fd 	      jsr	PlotChar
    145  7de8
    146  7de8							; -x,y
    147  7de8		       a5 ac		      lda	circ_y
    148  7dea		       4a		      lsr
    149  7deb		       d8		      cld
    150  7dec		       65 9c		      adc	ManY	; "origin"
    151  7dee		       a8		      tay
    152  7def		       a5 9b		      lda	ManX
    153  7df1		       0a		      asl
    154  7df2		       38		      sec
    155  7df3		       e5 ab		      sbc	circ_x
    156  7df5		       4a		      lsr
    157  7df6		       20 54 fd 	      jsr	PlotChar
    158  7df9
    159  7df9
    160  7df9		       60		      rts		;6
    161  7dfa
    162  7dfa
    163  7dfa
      0  7dfa					      DEFINE_SUBROUTINE	DrawCircle
      1  7dfa		       00 0f	   BANK_DrawCircle =	_CURRENT_BANK
      2  7dfa					      SUBROUTINE
      3  7dfa				   DrawCircle
    165  7dfa							; a = radius
    166  7dfa							;		    sty circ_char
    167  7dfa							;		    sta circ_x
    168  7dfa							;		    eor #255
    169  7dfa							;		    clc
    170  7dfa							;		    adc #1
    171  7dfa							;		    sta circ_scratch	 ; "d" --> "1-r" in unit terms
    172  7dfa
    173  7dfa							;		    lda #0
    174  7dfa							;		    sta circ_y
    175  7dfa
    176  7dfa				   CircleRepeat
    177  7dfa
    178  7dfa
    179  7dfa
    180  7dfa		       20 6d fd 	      jsr	PlotCirclePoints
    181  7dfd		       e6 ac		      inc	circ_y
    182  7dff		       a5 ae		      lda	circ_scratch
    183  7e01		       10 09		      bpl	positiveD
    184  7e03
    185  7e03		       a5 ac		      lda	circ_y
    186  7e05		       0a		      asl
    187  7e06		       38		      sec		; "+1"
    188  7e07		       65 ae		      adc	circ_scratch
    189  7e09		       4c 17 fe 	      jmp	CCont
    190  7e0c
    191  7e0c		       c6 ab	   positiveD  dec	circ_x
    192  7e0e
    193  7e0e		       38		      sec
    194  7e0f		       a5 ac		      lda	circ_y
    195  7e11		       e5 ab		      sbc	circ_x
    196  7e13		       0a		      asl
    197  7e14		       38		      sec		; "+1"
    198  7e15		       65 ae		      adc	circ_scratch
    199  7e17
    200  7e17		       85 ae	   CCont      sta	circ_scratch
    201  7e19
    202  7e19		       a5 ab		      lda	circ_x
    203  7e1b		       c5 ac		      cmp	circ_y
    204  7e1d		       b0 db		      bcs	CircleRepeat	; circleDie
    205  7e1f
    206  7e1f		       60	   circleDie  rts
------- FILE BANK_FIXED.asm
------- FILE Brick_Wall.asm LEVEL 3 PASS 3
      0  7e20					      include	"Brick_Wall.asm"	; 2 * LINES_PER_CHAR bytes
      0  7e20					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL", LINES_PER_CHAR
     10  7e20					      LIST	ON
      2  7e20
      3  7e20		       00 00	   BRICK_WALL_DEF =	0
      4  7e20
      5  7e20				   CHARACTERSHAPE_WALL
      6  7e20				   CHARACTERSHAPE_WALL0
      7  7e20
      8  7e20
      9  7e20
     10  7e20				  -	      if	MIRRORED_WALL = NO
     11  7e20				  -CHARACTERSHAPE_WALL_MIRRORED
     12  7e20				  -CHARACTERSHAPE_WALL0_MIRRORED
     13  7e20					      endif
     14  7e20
     15  7e20					      if	BRICK_WALL_DEF = 0
     16  7e20		       00 ee ee 00*	      .byte.b	%00000000,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;R
     17  7e27		       ee ee ee 00*	      .byte.b	%11101110,%11101110,%11101110,%00000000,%10111011,%10111011,%10111011	;G
     18  7e2e		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     19  7e35					      endif
     20  7e35
     21  7e35
     22  7e35
     23  7e35							;--------------------------------------------------------------------------
     24  7e35					      if	MIRRORED_WALL = YES
      0  7e35					      OPTIONAL_PAGEBREAK	"CHARACTERSHAPE_WALL_MIRRORED", LINES_PER_CHAR
     10  7e35					      LIST	ON
     26  7e35				   CHARACTERSHAPE_WALL_MIRRORED
     27  7e35				   CHARACTERSHAPE_WALL0_MIRRORED
     28  7e35
     29  7e35					      if	BRICK_WALL_DEF = 0
     30  7e35		       00 77 77 00*	      .byte.b	%00000000,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;R
     31  7e3c		       77 77 77 00*	      .byte.b	%01110111,%01110111,%01110111,%00000000,%11011101,%11011101,%11011101	;G
     32  7e43		       ff ff ff ff*	      .byte.b	%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111	;B
     33  7e4a					      endif
     34  7e4a
     35  7e4a
     36  7e4a					      endif
------- FILE BANK_FIXED.asm
------- FILE sound/intro1_trackdata.asm LEVEL 3 PASS 3
      0  7e4a					      include	"sound/intro1_trackdata.asm"
      1  7e4a							; TIATracker music player
      2  7e4a							; Copyright 2016 Andre "Kylearan" Wichmann
      3  7e4a							; Website: https://bitbucket.org/kylearan/tiatracker
      4  7e4a							; Email: andre.wichmann@gmx.de
      5  7e4a							;
      6  7e4a							; Licensed under the Apache License, Version 2.0 (the "License");
      7  7e4a							; you may not use this file except in compliance with the License.
      8  7e4a							; You may obtain a copy of the License at
      9  7e4a							;
     10  7e4a							;   http://www.apache.org/licenses/LICENSE-2.0
     11  7e4a							;
     12  7e4a							; Unless required by applicable law or agreed to in writing, software
     13  7e4a							; distributed under the License is distributed on an "AS IS" BASIS,
     14  7e4a							; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     15  7e4a							; See the License for the specific language governing permissions and
     16  7e4a							; limitations under the License.
     17  7e4a
     18  7e4a							; Song author: 
     19  7e4a							; Song name: 
     20  7e4a
     21  7e4a							; @com.wudsn.ide.asm.hardware=ATARI2600
     22  7e4a
     23  7e4a							; =====================================================================
     24  7e4a							; TIATracker melodic and percussion instruments, patterns and sequencer
     25  7e4a							; data.
     26  7e4a							; =====================================================================
     27  7e4a				   tt_TrackDataStart
     28  7e4a
     29  7e4a							; =====================================================================
     30  7e4a							; Melodic instrument definitions (up to 7). tt_envelope_index_c0/1 hold
     31  7e4a							; the index values into these tables for the current instruments played
     32  7e4a							; in channel 0 and 1.
     33  7e4a							; 
     34  7e4a							; Each instrument is defined by:
     35  7e4a							; - tt_InsCtrlTable: the AUDC value
     36  7e4a							; - tt_InsADIndexes: the index of the start of the ADSR envelope as
     37  7e4a							;	 defined in tt_InsFreqVolTable
     38  7e4a							; - tt_InsSustainIndexes: the index of the start of the Sustain phase
     39  7e4a							;	 of the envelope
     40  7e4a							; - tt_InsReleaseIndexes: the index of the start of the Release phase
     41  7e4a							; - tt_InsFreqVolTable: The AUDF frequency and AUDV volume values of
     42  7e4a							;	 the envelope
     43  7e4a							; =====================================================================
     44  7e4a
     45  7e4a							; Instrument master CTRL values
     46  7e4a				   tt_InsCtrlTable
     47  7e4a		       07 04 0c 04*	      dc.b	$07, $04, $0c, $04, $0c
     48  7e4f
     49  7e4f
     50  7e4f							; Instrument Attack/Decay start indexes into ADSR tables.
     51  7e4f				   tt_InsADIndexes
     52  7e4f		       00 0e 0e 1e*	      dc.b	$00, $0e, $0e, $1e, $1e
     53  7e54
     54  7e54
     55  7e54							; Instrument Sustain start indexes into ADSR tables
     56  7e54				   tt_InsSustainIndexes
     57  7e54		       08 19 19 2b*	      dc.b	$08, $19, $19, $2b, $2b
     58  7e59
     59  7e59
     60  7e59							; Instrument Release start indexes into ADSR tables
     61  7e59							; Caution: Values are stored with an implicit -1 modifier! To get the
     62  7e59							; real index, add 1.
     63  7e59				   tt_InsReleaseIndexes
     64  7e59		       09 1b 1b 2c*	      dc.b	$09, $1b, $1b, $2c, $2c
     65  7e5e
     66  7e5e
     67  7e5e							; AUDVx and AUDFx ADSR envelope values.
     68  7e5e							; Each byte encodes the frequency and volume:
     69  7e5e							; - Bits 7..4: Freqency modifier for the current note ([-8..7]),
     70  7e5e							;	 8 means no change. Bit 7 is the sign bit.
     71  7e5e							; - Bits 3..0: Volume
     72  7e5e							; Between sustain and release is one byte that is not used and
     73  7e5e							; can be any value.
     74  7e5e							; The end of the release phase is encoded by a 0.
     75  7e5e				   tt_InsFreqVolTable
     76  7e5e							; 0: Pizzicato bassb
     77  7e5e		       8a 8a 89 88*	      dc.b	$8a, $8a, $89, $88, $86, $85, $85, $84
     78  7e66		       83 00 83 83*	      dc.b	$83, $00, $83, $83, $83, $00
     79  7e6c							; 1+2: Square2
     80  7e6c		       8c 8c 8b 89*	      dc.b	$8c, $8c, $8b, $89, $87, $85, $84, $83
     81  7e74		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $00, $81, $00
     82  7e7c							; 3+4: Square
     83  7e7c		       85 85 85 85*	      dc.b	$85, $85, $85, $85, $84, $83, $83, $82
     84  7e84		       82 82 81 81*	      dc.b	$82, $82, $81, $81, $81, $81, $00, $80
     85  7e8c		       00		      dc.b	$00
     86  7e8d
     87  7e8d
     88  7e8d
     89  7e8d							; =====================================================================
     90  7e8d							; Percussion instrument definitions (up to 15)
     91  7e8d							;
     92  7e8d							; Each percussion instrument is defined by:
     93  7e8d							; - tt_PercIndexes: The index of the first percussion frame as defined
     94  7e8d							;	 in tt_PercFreqTable and tt_PercCtrlVolTable
     95  7e8d							; - tt_PercFreqTable: The AUDF frequency value
     96  7e8d							; - tt_PercCtrlVolTable: The AUDV volume and AUDC values
     97  7e8d							; =====================================================================
     98  7e8d
     99  7e8d							; Indexes into percussion definitions signifying the first frame for
    100  7e8d							; each percussion in tt_PercFreqTable.
    101  7e8d							; Caution: Values are stored with an implicit +1 modifier! To get the
    102  7e8d							; real index, subtract 1.
    103  7e8d				   tt_PercIndexes
    104  7e8d		       01 0a 0c 	      dc.b	$01, $0a, $0c
    105  7e90
    106  7e90
    107  7e90							; The AUDF frequency values for the percussion instruments.
    108  7e90							; If the second to last value is negative (>=128), it means it's an
    109  7e90							; "overlay" percussion, i.e. the player fetches the next instrument note
    110  7e90							; immediately and starts it in the sustain phase next frame. (Needs
    111  7e90							; TT_USE_OVERLAY)
    112  7e90				   tt_PercFreqTable
    113  7e90							; 0: Kick
    114  7e90		       00 01 02 03*	      dc.b	$00, $01, $02, $03, $04, $05, $06, $87
    115  7e98		       00		      dc.b	$00
    116  7e99							; 1: HH
    117  7e99		       80 00		      dc.b	$80, $00
    118  7e9b							; 2: Snare
    119  7e9b		       01 03 06 0e*	      dc.b	$01, $03, $06, $0e, $13, $11, $15, $14
    120  7ea3		       17 1b 00 	      dc.b	$17, $1b, $00
    121  7ea6
    122  7ea6
    123  7ea6							; The AUDCx and AUDVx volume values for the percussion instruments.
    124  7ea6							; - Bits 7..4: AUDC value
    125  7ea6							; - Bits 3..0: AUDV value
    126  7ea6							; 0 means end of percussion data.
    127  7ea6				   tt_PercCtrlVolTable
    128  7ea6							; 0: Kick
    129  7ea6		       ee ed ed eb*	      dc.b	$ee, $ed, $ed, $eb, $e9, $e8, $e8, $e6
    130  7eae		       00		      dc.b	$00
    131  7eaf							; 1: HH
    132  7eaf		       87 00		      dc.b	$87, $00
    133  7eb1							; 2: Snare
    134  7eb1		       8b 8a 8a 8a*	      dc.b	$8b, $8a, $8a, $8a, $8a, $8a, $89, $88
    135  7eb9		       87 86 00 	      dc.b	$87, $86, $00
    136  7ebc
    137  7ebc
    138  7ebc
    139  7ebc							; =====================================================================
    140  7ebc							; Track definition
    141  7ebc							; The track is defined by:
    142  7ebc							; - tt_PatternX (X=0, 1, ...): Pattern definitions
    143  7ebc							; - tt_PatternPtrLo/Hi: Pointers to the tt_PatternX tables, serving
    144  7ebc							;	 as index values
    145  7ebc							; - tt_SequenceTable: The order in which the patterns should be played,
    146  7ebc							;	 i.e. indexes into tt_PatternPtrLo/Hi. Contains the sequences
    147  7ebc							;	 for all channels and sub-tracks. The variables
    148  7ebc							;	 tt_cur_pat_index_c0/1 hold an index into tt_SequenceTable for
    149  7ebc							;	 each channel.
    150  7ebc							;
    151  7ebc							; So tt_SequenceTable holds indexes into tt_PatternPtrLo/Hi, which
    152  7ebc							; in turn point to pattern definitions (tt_PatternX) in which the notes
    153  7ebc							; to play are specified.
    154  7ebc							; =====================================================================
    155  7ebc
    156  7ebc							; ---------------------------------------------------------------------
    157  7ebc							; Pattern definitions, one table per pattern. tt_cur_note_index_c0/1
    158  7ebc							; hold the index values into these tables for the current pattern
    159  7ebc							; played in channel 0 and 1.
    160  7ebc							;
    161  7ebc							; A pattern is a sequence of notes (one byte per note) ending with a 0.
    162  7ebc							; A note can be either:
    163  7ebc							; - Pause: Put melodic instrument into release. Must only follow a
    164  7ebc							;	 melodic instrument.
    165  7ebc							; - Hold: Continue to play last note (or silence). Default "empty" note.
    166  7ebc							; - Slide (needs TT_USE_SLIDE): Adjust frequency of last melodic note
    167  7ebc							;	 by -7..+7 and keep playing it
    168  7ebc							; - Play new note with melodic instrument
    169  7ebc							; - Play new note with percussion instrument
    170  7ebc							; - End of pattern
    171  7ebc							;
    172  7ebc							; A note is defined by:
    173  7ebc							; - Bits 7..5: 1-7 means play melodic instrument 1-7 with a new note
    174  7ebc							;	 and frequency in bits 4..0. If bits 7..5 are 0, bits 4..0 are
    175  7ebc							;	 defined as:
    176  7ebc							;	 - 0: End of pattern
    177  7ebc							;	 - [1..15]: Slide -7..+7 (needs TT_USE_SLIDE)
    178  7ebc							;	 - 8: Hold
    179  7ebc							;	 - 16: Pause
    180  7ebc							;	 - [17..31]: Play percussion instrument 1..15
    181  7ebc							;
    182  7ebc							; The tracker must ensure that a pause only follows a melodic
    183  7ebc							; instrument or a hold/slide.
    184  7ebc							; ---------------------------------------------------------------------
    185  7ebc		       00 1f	   TT_FREQ_MASK =	%00011111
    186  7ebc		       00 08	   TT_INS_HOLD =	8
    187  7ebc		       00 10	   TT_INS_PAUSE =	16
    188  7ebc		       00 11	   TT_FIRST_PERC =	17
    189  7ebc
    190  7ebc							; Intro left
    191  7ebc				   tt_pattern0
    192  7ebc		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $3e, $08
    193  7ec4		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $3e, $08
    194  7ecc		       11 08 3e 08*	      dc.b	$11, $08, $3e, $08, $12, $3e, $12, $3e
    195  7ed4		       13 08 3e 08*	      dc.b	$13, $08, $3e, $08, $12, $3e, $13, $08
    196  7edc		       00		      dc.b	$00
    197  7edd
    198  7edd							; Intro2 L
    199  7edd				   tt_pattern1
    200  7edd		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    201  7ee5		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    202  7eed		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    203  7ef5		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    204  7efd		       00		      dc.b	$00
    205  7efe
    206  7efe							; Intro2-fill L
    207  7efe				   tt_pattern2
    208  7efe		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $34, $08
    209  7f06		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $34, $08
    210  7f0e		       11 08 34 08*	      dc.b	$11, $08, $34, $08, $12, $34, $12, $34
    211  7f16		       13 08 34 08*	      dc.b	$13, $08, $34, $08, $12, $34, $13, $08
    212  7f1e		       00		      dc.b	$00
    213  7f1f
    214  7f1f							; Intro right
    215  7f1f				   tt_pattern3
    216  7f1f		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $73, $08
    217  7f27		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $73, $08, $73, $08
    218  7f2f		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $6e, $08, $b3, $08
    219  7f37		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    220  7f3f		       00		      dc.b	$00
    221  7f40
    222  7f40							; Intro2 R
    223  7f40				   tt_pattern4
    224  7f40		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    225  7f48		       6f 08 73 08*	      dc.b	$6f, $08, $73, $08, $b3, $08, $73, $08
    226  7f50		       b3 08 73 08*	      dc.b	$b3, $08, $73, $08, $b3, $08, $73, $08
    227  7f58		       71 08 73 08*	      dc.b	$71, $08, $73, $08, $74, $08, $71, $08
    228  7f60		       00		      dc.b	$00
    229  7f61
    230  7f61
    231  7f61
    232  7f61
    233  7f61							; Individual pattern speeds (needs TT_GLOBAL_SPEED = 0).
    234  7f61							; Each byte encodes the speed of one pattern in the order
    235  7f61							; of the tt_PatternPtr tables below.
    236  7f61							; If TT_USE_FUNKTEMPO is 1, then the low nibble encodes
    237  7f61							; the even speed and the high nibble the odd speed.
    238  7f61				  -	      IF	TT_GLOBAL_SPEED = 0
    239  7f61				  -tt_PatternSpeeds
    240  7f61				  -%%PATTERNSPEEDS%%
    241  7f61					      ENDIF
    242  7f61
    243  7f61
    244  7f61							; ---------------------------------------------------------------------
    245  7f61							; Pattern pointers look-up table.
    246  7f61							; ---------------------------------------------------------------------
    247  7f61				   tt_PatternPtrLo
    248  7f61		       bc dd fe 1f	      dc.b	<tt_pattern0, <tt_pattern1, <tt_pattern2, <tt_pattern3
    249  7f65		       40		      dc.b	<tt_pattern4
    250  7f66				   tt_PatternPtrHi
    251  7f66		       fe fe fe ff	      dc.b	>tt_pattern0, >tt_pattern1, >tt_pattern2, >tt_pattern3
    252  7f6a		       ff		      dc.b	>tt_pattern4
    253  7f6b
    254  7f6b
    255  7f6b							; ---------------------------------------------------------------------
    256  7f6b							; Pattern sequence table. Each byte is an index into the
    257  7f6b							; tt_PatternPtrLo/Hi tables where the pointers to the pattern
    258  7f6b							; definitions can be found. When a pattern has been played completely,
    259  7f6b							; the next byte from this table is used to get the address of the next
    260  7f6b							; pattern to play. tt_cur_pat_index_c0/1 hold the current index values
    261  7f6b							; into this table for channels 0 and 1.
    262  7f6b							; If TT_USE_GOTO is used, a value >=128 denotes a goto to the pattern
    263  7f6b							; number encoded in bits 6..0 (i.e. value AND %01111111).
    264  7f6b							; ---------------------------------------------------------------------
    265  7f6b				   tt_SequenceTable
    266  7f6b							; ---------- Channel 0 ----------
    267  7f6b		       00 00 01 02*	      dc.b	$00, $00, $01, $02, $80
    268  7f70
    269  7f70
    270  7f70							; ---------- Channel 1 ----------
    271  7f70		       03 04 03 04*	      dc.b	$03, $04, $03, $04, $85
    272  7f75
    273  7f75
 Track size:  $12b
    274  7f75					      echo	"Track size: ", *-tt_TrackDataStart
------- FILE BANK_FIXED.asm
   1113  7f75
 FREE BYTES IN FIXED BANK =  $86
   1114  7f75					      ECHO	"FREE BYTES IN FIXED BANK = ", $FFFB - *
   1115  7f75
   1116  7f75							;---------------------------------------------------------------------------
   1117  7f75							; The reset vectors
   1118  7f75							; these must live in the fixed bank (last 2K of any ROM image in TigerVision)
   1119  7f75
   1120  8000 ????				      SEG	InterruptVectors
   1121  7ffc					      ORG	FIXED_BANK + $7FC
   1122  7ffc					      RORG	$7ffC
   1123  7ffc
   1124  7ffc							;		 .word Reset	       ; NMI	    (not used)
   1125  7ffc		       c2 fa		      .word.w	Reset	; RESET
   1126  7ffe		       c2 fa		      .word.w	Reset	; IRQ	      (not used)
   1127  8000
   1128  8000							;---------------------------------------------------------------------------
------- FILE ./sokoboo.asm
    820  8000
    821  8000					      END
